init
flush
dealloc
_loadDefaultExtractorPluginsIfNeeded
documentRef
alloc
initWithSKDocumentRef:
initWithIndex:parentDocument:
fileURLWithPath:
initWithURL:
addDocument:withMIMETypeHint:canReplace:
defaultManager
enumeratorAtPath:
nextObject
stringByAppendingPathComponent:
fileAttributes
valueForKey:
skipDescendents
characterAtIndex:
loadDefaultExtractorPlugIns
initWithSKIndexRef:
initWithURL:indexName:indexType:analysisProperties:
initExistingIndexWithURL:indexName:writeAccess:
initWithMutableData:indexName:indexType:analysisProperties:
initExistingReadOnlyIndexWithData:indexName:
initExistingIndexWithMutableData:indexName:
invalidate
maximumBytesBeforeFlush
setMaximumBytesBeforeFlush:
compact
indexType
analysisProperties
documentCount
addDocument:withText:canReplace:
removeDocument:
propertiesForDocument:
setProperties:forDocument:
stateForDocument:
IDForDocument:
documentForDocumentID:
renameDocument:withName:
moveDocument:toNewParentDocument:
iteratorForParentDocument:
maxDocumentID
termCountForDocumentID:
termIDArrayForDocumentID:
frequencyForTermID:inDocumentID:
maxTermID
documentCountForTermID:
documentIDArrayForTermID:
termStringForTermID:
termIDForTermString:
indexRef
addDocumentAtPath:
addContentsOfDirectoryAtPath:withRecursion:
.cxx_destruct
_searchIndex
_data
URLWithString:
identifier
userDefaultsKey
baseURL
useDecoratedSource
initWithSortDescriptor:
hasMoreResults
remainingResults
nextResultsInTime:
cancel
sortDescriptor
_sortDescriptor
copy
count
initWithResults:withSortDescriptor:
_theResults
mutableCopy
initWithCapacity:
addObject:
isEqualToString:
ascending
selector
initWithKey:ascending:selector:
countByEnumeratingWithState:objects:count:
removeObjectAtIndex:
objectAtIndex:
addObjectsFromArray:
_sourceExpendedAtIndex:
mergeForTime:
removeAllObjects
valueForKeyPath:
stringWithUTF8String:
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
arrayWithCapacity:
_sortValueForObject:
array
objectAtIndexedSubscript:
compareObject:toObject:
rangeFromArray:aboveValue:includingExactMatches:startingIndex:nextFailedValue:
subarrayWithRange:
null
setObject:atIndexedSubscript:
setArray:
removeObjectsInRange:
raise:format:
initWithSources:withSortDescriptor:
numberOfCompares
setNumberOfCompares:
_theSources
_remainingSources
_sourceCaches
_unsignedMemory
_sortKey
_sortDescriptorForValue
_numberOfCompares
processInfo
environment
objectForKey:
class
isKindOfClass:
length
lowercaseString
standardUserDefaults
boolValue
respondsToSelector:
bundleForClass:
fileExistsAtPath:isDirectory:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
elementsForName:
_dr_firstChildNamed:
host
hasSuffix:
_dsa_isAppleURL
replaceOccurrencesOfString:withString:options:range:
hasPrefix:
replaceCharactersInRange:withString:
controlCharacterSet
rangeOfCharacterFromSet:
_dsa_stringAsPathComponent
initWithIndex:query:options:
searchRef
findMaximumMatches:inMaximumTime:returningIDs:andScores:
isFinished
_search
_moreToSearch
relevance
description
stringByAppendingString:
children
iterativeDescriptionWithIndent:
appendFormat:
title
stringWithFormat:
resultRelevance
setChildren:
setChildrenRelevance:
flattenTree
arrayWithObject:
_calculateChildrenRelevance
strongToStrongObjectsMapTable
node
setResultRelevance:
dictionaryWithObjectsAndKeys:
setObject:forKey:
type
parentNode
docSet
initWithNode:docSet:relevance:isTitleMatch:
objectEnumerator
componentsJoinedByString:
maximumRelevanceForResults:
buildResultTree:
copyWithZone:
isTitleMatch
nearestNodeID
childrenRelevance
_resultRelevance
_childrenRelevance
_children
initWithPath:searchResultID:documentID:docRootID:relevance:fromIndex:
URLPathAllowedCharacterSet
stringByAddingPercentEncodingWithAllowedCharacters:
urlForRootID:
scheme
documentsURL
URLWithString:relativeToURL:
absoluteURL
matchesExactNode
documentIDForSKID:
nodeWithID:
primaryParent
numberWithInteger:
name
path
lastPathComponent
searchResultWithPath:searchResultID:documentID:docRootID:relevance:fromIndex:
index
_index
_skID
_docID
_rootID
_path
_title
isValid
nodeWithIDNumber:
_node_or_ID
_docSet
_isTitleMatch
componentsSeparatedByString:
intValue
readWriteDispatchLockWithDebugName:
managedObjectModel
versionForModel:
localizedStringForKey:value:table:
modelForVersion:
initWithManagedObjectModel:
persistentStores
addPersistentStoreWithType:configuration:URL:options:error:
performBlockAndWait:
_setDocSet:forCoordinator:
managedObjectContext
convertXML:toContext:forModelVersion:withError:
saveChanges:
entityForName:inManagedObjectContext:
setEntity:
executeFetchRequest:error:
_URLForStoreInBundle:withLocalization:
initWithBundle:withPersistentStoreURL:modelVersion:forLocalization:error:
fileExistsAtPath:
initWithContentsOfURL:
metadataForPersistentStoreOfType:URL:options:error:
numberWithBool:
dictionaryWithObject:forKey:
stringWithContentsOfURL:encoding:error:
initWithBundle:withXML:withPersistentStoreCoordinator:modelVersion:forLocalization:error:
initWithDocRootDirectory:forLocalization:error:
sharedQueue
invalidateSearchesOfDocSet:
allValues
makeObjectsPerformSelector:
_pathForCachedNodePaths
removeItemAtPath:error:
localizedName
version
platformFamily
platformVersion
stringByAppendingFormat:
nodes
fallbackURL
_dumpStr
rootNode
releaseNoteInformation
bundleWithPath:
allObjects
compare:
sortedArrayUsingSelector:
arrayByAddingObjectsFromArray:
_startLoadingTOCInfo
childWithName:
_objectForInfoKey:
fallbackURLs
arrayWithObjects:count:
whitespaceAndNewlineCharacterSet
stringByTrimmingCharactersInSet:
textIndexURL
stringByDeletingLastPathComponent
numberWithInt:
dictionary
setWithObjects:
setDefaultRootPath:
setDocSet:
_indexNamed:forUpdating:
initWithDocSet:forBackgroundQueries:
setReadOnly:
searchTermsForNodeID:waitForCache:
initWithTerms:
timeIntervalSinceReferenceDate
dataWithContentsOfFile:
propertyListWithData:options:format:error:
initWithKeyOptions:valueOptions:capacity:
objectID
_setObjectID:forNodeID:
_objectIDForNodeID:
objectWithID:
setReturnsObjectsAsFaults:
predicateWithFormat:
setPredicate:
setFetchLimit:
_setObjectIDSForNodes:
initWithData:
searchTerms
modelVersion
containsObject:
initWithUnsignedInteger:
urlForNode:
relativePath
_apiLanguageMOs
architectureFlags
architectureNamesForArchitectureFlags:
knownArchitectureNames
removeObject:
regularExpressionWithPattern:options:error:
stringByReplacingMatchesInString:options:range:withTemplate:
persistentStoreURL
attributesOfItemAtPath:error:
fileModificationDate
_shouldLoadNodePathCache:
dataWithPropertyList:format:options:error:
writeToFile:atomically:
_loadCachedNodePaths
urlString
file
anchor
localPathForURLString:path:fileName:anchor:type:
_saveCachedNodePaths
_setupNodesByPath
rangeOfString:
nodeURLForLocalPath:inContext:
substringToIndex:
absoluteString
substringFromIndex:
setScheme:
setHost:
setPath:
nodeURL
fileName
nodeForURL:
fragment
isFileURL
_nodeForLookupString:URLisFileURL:URLPointsIntoDocSet:
relativeString
_resolveRemoteURL:forDocSets:resolvedWithDocSet:
_resolveRelativeURL:forDocSets:resolvedWithDocSet:
_resolveAbsoluteFileURL:forDocSets:resolvedWithDocSet:
availabilityInformationAsOfDistributionVersion:forArchitectures:
allTokens
supportsUSRLookup
isEqual:
scope
declaredInFrameworkName
isDeprecated
fastTokenWithUSR:name:language:relativeURL:scope:type:declaredInFrameworkName:deprecated:docSet:
tokenCacheURL
serializeFastTokenCache:toPath:
createCache:
setFastTokenCache:
performLockedWriterBlock:
fastTokenCache
archiveRootObject:toFile:
wouldLoadTokenCache
unarchiveObjectWithFile:
reason
tokensMatchingString:withMatchType:docSet:
performLockedReaderBlock:
docSet:hasTokenWithScope:
resolvedURL:forDocSets:withCompletionBlock:
isTokenDeprecated:
initWithURL:error:
initWithDocRootDirectory:withXML:
deleteDiskCaches
_dump
bundle
_resetBundle
localization
tokenFileURLs
nodeAtNamedPath:
isLegacyPackage
localizedDescription
localizedPublisherName
publisherIdentifier
localizedFeedName
feedURL
configurationVersion
minimumSupportedXcodeVersion
maximumSupportedXcodeVersion
docSetURL
certificateSigner
certificateIssuer
requiresUpdateForContent
offsetIntervalForUpdateCheck
fullTextIndexForUpdating:
apiIndexForUpdating:
sharedAPIIndex
sharedBackgroundAPIIndex
termManager
nodesWithIDNumbers:
searchTermsForNodes:
nodeWithUUID:
nodesWithUUIDPattern:
nodesWithDocumentType:
apiLanguages
availabilityArchitectures
bookNodeForURL:
allNodes
buildTokenCache
hasTokenCache
loadTokenCache
tokensMatchingString:withMatchType:
hasTokenWithScope:
_docSetBundle
_localization
_isLegacy
_isValid
_modelVersion
_documentsURL
_persistentStoreCoordinator
_managedObjectContext
_indexesByName
_mainTokenIndex
_backgroundTokenIndex
_docSetMO
_rootNode
_nodesByPath
_nodesByID
_availabilityArchitectures
_nodeByUUID
_tocLoadGroup
_nodeTermLists
_termManager
_searchTermsLoaded
_tokenCacheLock
_buildingTokenCache
_discoveredInvalidTokenCache
_fastTokenCache
isMainThread
searchForText:inNodes:inDocSet:withMatchType:
addQueuedQuery:inNodes:inDocSet:withMatchType:delegate:contextInfo:
addQueuedQuery:inDocSets:withMatchType:delegate:contextInfo:
cancelSearchWithDelegate:contextInfo:
containsTokens:
tokensMatchingCriteria:inNodes:error:
sharedManager
startTokenSearch:inDocSets:withSortDescriptors:delegate:contextInfo:
tokensMatchingUSR:docSet:
XMLDescription
lookupTokensWithUSR:
searchForText:inNodes:withMatchType:
searchForText:inNodes:withMatchType:delegate:contextInfo:
cancelTextSearchForDelegate:contextInfo:
searchForTokens:inNodes:
searchForText:inDocSets:withMatchType:delegate:contextInfo:
searchForTokens:inDocSets:withSortDescriptors:delegate:contextInfo:
cancelTokenSearchForDelegate:contextInfo:
persistentStoreCoordinator
initWithConcurrencyType:
setPersistentStoreCoordinator:
metadataForPersistentStore:
URLForPersistentStore:
removePersistentStore:error:
stringByAppendingPathExtension:
nodeID
parents
data
orderedTerms
_URLForModelInBundle:withLocalization:
errorWithDomain:code:userInfo:
migratePersistentStore:toURL:options:withType:error:
_writeCachedNodeInfo
setMetadata:forPersistentStore:
setAttributes:ofItemAtPath:error:
modelPathForVersion:
copyItemAtPath:toPath:error:
save:
defaultModelVersion
pathForResource:ofType:
entitiesByName
userInfo
_docSetForCoordinator:
_removePersistentStores
migrateDataToURL:copyModel:error:
docSetForManagedObject:
urlForNode:localizingPath:
stringByReplacingOccurrencesOfString:withString:
className
fileURLWithPath:isDirectory:
urlForTokenXML:
initWithContentsOfURL:options:error:
pathForResource:ofType:inDirectory:forLocalization:
pathForResource:ofType:inDirectory:
bundlePath
stringByResolvingSymlinksInPath
_localizedPathInBundle:forFile:forLocalization:
localizations
_localizedPathForNode:inBundle:forLocalization:
urlForToken:
tokenXMLForToken:
localizedPathsForNode:inBundle:
weakToWeakObjectsMapTable
removeObjectForKey:
performBlock:
countForFetchRequest:error:
initWithBool:
initWithKey:ascending:
setSortDescriptors:
unsignedIntegerValue
deleteObject:
readOnly
_resetTableForEntityNamed:
idInformationForIDXMLElement:
stringValue
standardizedLanguageForKey:
idInformationForIDString:
lastObject
initWithObjects:forKeys:
_mutableDictionaryForEntity:forKey:
insertNewObjectForEntityForName:inManagedObjectContext:
setValue:forKey:
_managedObjectWithName:forEntity:withKeyName:creatingIfMissing:inMutableDictionary:
managedObjectForLanguage:creatingIfMissing:
setWithArray:
managedObjectForTokenType:creatingIfMissing:
managedObjectForContainer:creatingIfMissing:
lowercaseUTF8ByteForString:
createTokenWithUSR:iDInformation:displayName:
UTF8String
numberWithChar:
executeBackgroundBlock:
tokensHaveParents
maxSortOrder
deleteTokenReferences
managedObjectForHeader:framework:creatingIfMissing:
managedObjectForFilePath:creatingIfMissing:
managedObjectForDistribution:version:architecture:creatingIfMissing:
languageCount
managedObjectsForLanguage
managedObjectsForTokenType
managedObjectsForContainer
createTokenWithIDInformation:
createRelatedTokenGroupNamed:withTokens:
_moc
_readOnly
_tokensHaveParents
_maxSortOrder
_fullNameLookup
_languageMOs
_tokenTypeMOs
_distributionMOs
_containerMOs
_headerMOs
arrayWithObjects:
orPredicateWithSubpredicates:
predicateWithValue:
addEntriesFromDictionary:
rangeOfString:options:range:
_predicateForLanguageCriterion:
_tokensMatchingPredicate:withSortDescriptors:returningType:fetchLimit:error:
andPredicateWithSubpredicates:
filteredArrayUsingPredicate:
setResultType:
predicateForQuery:
countTokensMatchingPredicate:error:
tokensMatchingCriteria:error:
tokensMatchingPredicate:withSortDescriptors:error:
tokenIDsMatchingPredicate:withSortDescriptors:fetchLimit:error:
tokenIDsMatchingPredicate:withSortDescriptors:error:
characterSetWithCharactersInString:
substringWithRange:
defaultRootDocument
nextDocument
_standardizedRootURL:
_loadMappingsFromProperties:
_loadDocRoots
rootIDForType:
rootDocumentForPath:
resourceSpecifier
searchDocumentWithScheme:parent:name:
setRootURL:forPath:ofType:
rootDocumentForType:
_removeDocumentForDocID:
indexSubDirectory:forDocument:atPath:onlyTypes:
indexFile:belowParent:atPath:
allKeys
indexDirectoryForDocument:atPath:onlyTypes:
_indexFile:belowParent:atPath:withDefaultTitle:
_indexDocSetNode:atPath:isFolder:localizedPathInfo:inRootPath:
pathExtension
extractTextFromHTMLFile:returningTitle:
string
documentAttributes
searchDocumentWithURL:
stringByPaddingToLength:withString:startingAtIndex:
rootTypeForID:
defaultRootID
setFallbackRootPath:
fallbackRootDocument
fallbackRootID
indexDocSetNode:atPath:usingLocalizedPathInfo:inRootPath:
indexDocSetNode:atPath:isFolder:inRootPath:
_rootDocumentForPath
_rootIDURLs
_rootIDTypes
_rootTypeIDs
_skIDToDSID
_mappingIsDirty
versionValue
initWithObjects:
initWithObjectsAndKeys:
_knownArchitectureFlags
willAccessValueForKey:
primitiveValueForKey:
didAccessValueForKey:
architectureFlagsForArchitectureNames:
assignVersions:forArchitectures:maximumVersion:inclusive:
jointVersionKey
setJointVersionKey:
_versionValue
encodingForHTMLData:
initWithContentsOfURL:encoding:error:
extractTextFromHTMLString:returningTitle:
initWithXMLString:options:error:
rootElement
extractTextFromXMLElement:returningTitle:
objectsForXQuery:constants:error:
nextNode
kind
appendString:
detach
attributeForName:
initWithData:encoding:
scannerWithString:
setCaseSensitive:
scanUpToString:intoString:
scanString:intoString:
attributesFromString:
compare:options:
_encodingForContentType:
alphanumericCharacterSet
addCharactersInString:
scanCharactersFromSet:intoString:
isAtEnd
termsFromQuery:
termMatchForSubstring:style:
termIDs
scoreForTermID:
initWithSearchString:withMatchType:usingManager:
failsAllTests
scoreForTermList:isTitleMatch:
_termMatchList
unsignedLongValue
docSets:didFindTokenSearchResults:isFinished:contextInfo:
caseInsensitiveCompare:
initWithQuery:forDocSet:withSortDescriptor:
initWithUnsignedLong:
date
doNextFetch
initWithFireDate:interval:target:selector:userInfo:repeats:
currentRunLoop
addTimer:forMode:
_searchQueue
_nextQueuePosition
_fetchTimer
setUsr:
setName:
setApiLanguage:
setRelativeURL:
setScope:
setType:
setDeclaredInFrameworkName:
setDeprecated:
apiLanguage
relativeURL
hash
allowsKeyedCoding
encodeObject:forKey:
encodeBool:forKey:
decodeObjectForKey:
decodeBoolForKey:
tokenWithFixedUpLanguage:
fastTokenWithLanguage:
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isMemberOfClass:
conformsToProtocol:
retain
release
autorelease
retainCount
zone
superclass
debugDescription
encodeWithCoder:
initWithCoder:
valueForDeclaredInFrameworkName
abstract
_XMLDescription
deprecated
tokenName
willChangeValueForKey:
setPrimitiveValue:forKey:
didChangeValueForKey:
_metainfoCreatingIfMissing:
declaration
sortedArrayUsingDescriptors:
returnValueInfo
throwsDiscussion
declaredIn
isAbsolutePath
deprecationSummary
setObject:forKeyedSubscript:
setIntroducedInVersions:
introducedInVersions
anyObject
introducedInVersion
setDeprecatedInVersions:
deprecatedInVersions
deprecatedInVersion
setRemovedAfterVersions:
removedAfterVersions
removedAfterVersion
mergedRelatedTokens
seeAlsoRelatedTokens
unionSet:
relatedGroups
_lastRemovalStringForArchitectures:fromRemovedVersions:
deprecationVersionStatementAsOfVersion:
dictionaryWithContentsOfFile:
tokenTypeCategoryForKey:forLocalization:
descriptionForIDInformation:
setTokenName:
setParentNode:
setAbstract:
abstractAsHTML
setDeclaration:
declarationAsHTML
setParametersInfo:
parametersInfo
setReturnValueInfo:
returnValueAbstractAsHTML
setThrowsDiscussion:
throwsDiscussionAsHTML
setDeclaredIn:
declaredInHeaderURL
setDeprecationSummary:
deprecationSummaryAsHTML
setSeeAlsoRelatedTokens:
setRelatedGroups:
setRelatedSampleCode:
relatedSampleCode
setRelatedDocuments:
relatedDocuments
setFile:
filePath
setAnchor:
superclasses
adoptedProtocols
setIntroducedInVersion:
introducedInVersionString
setDeprecatedInVersion:
deprecatedInVersionString
setRemovedAfterVersion:
removedAfterVersionString
distributionName
relatedTokens
availabilityVersionStatement
deprecationVersionStatement
tokenTypeCategory
URLString
initWithScheme:parent:name:
schemeName
parent
_searchDocument
performFetch
initWithIndexesInRange:
objectsAtIndexes:
insertObject:atIndex:
sortUsingDescriptors:
_convertNextIDsToObjectsInTime:
sleepForTimeInterval:
initWithArray:
_configureFetchesForQuery:andSortDescriptor:
_performNextFetch
numberWithUnsignedInteger:
_initBatchInfo
_query
_predicate
_rationalizedSortDescriptors
_batchType
_ascending
_batchInfo
_fetchLimit
_searchResultIDs
_cachedResults
_cancelSearch
_backgroundIsFinished
_sortOnMainThread
_hasReturnedResults
componentsSeparatedByCharactersInSet:
_termsFromString:usingWordBoundaries:
addTerm:
evaluateWithObject:
termMatchForTermID:withBaseScore:
termMatchForTermMatches:
idForTerm:
rangeOfString:options:range:locale:
termsFromString:
_terms
_nextID
setQuery:
setOptions:
copyNodeIDsForNodes:
filterResultsToDocIDs:
query
options
_filterResults:withMinimumScore:
_getResults:
initWithFilterableIndex:query:options:
setNodeFilter:
maximumRelevanceForResults
searchResultsInTime:minimumScore:
_maxMatches
_maxScore
_indexToSearch
_options
_documentIDs
_documentNames
_scores
_nodeIDFilter
bytes
dataWithBytesNoCopy:length:freeWhenDone:
initWithWordLists:usingManager:
_termIDs
_numberOfTerms
initWithXML:withContext:forModelVersion:withError:
_updateContext
nodesForXPath:error:
updateDocSetInfo:error:
initWithInt:
_addNode:withID:
documentType
_addNodeWithoutID:
nodeTypes
numberWithUnsignedInt:
_addNodeWithoutDocumentType:
setNode:
objectForKeyedSubscript:
setFileName:
setBaseURL:
updateChecksum
XPath
_nodeForID:
_nodeForXMLNode:withCache:
_setUpNodes:withCache:
_assignIDsToNodes
_addSubnodes:toNode:withCache:
_addRelatedNodes:toNode:withCache:
setRootNode:
_updatePrimaryParent
_assignDocumentTypesToNodes
processPendingChanges
undoManager
disableUndoRegistration
_setUpDocSet
_setUpNodes
_setUpReleaseNotes
enableUndoRegistration
_docSetInfo
_error
_nodesWithoutIDs
_nodesWithoutDocumentTypes
_indexDocumentIterator
checksumForLocalPath:
localPath
setChecksum:
docSets
initForDocSet:
matchType
_searchTermLists:inDocSet:forQuery:withMatchType:allowCancel:
setNodeTextResults:
processResults:
searchObjectForDocSet:
setFullTextResults:
setMaximumFullTextRelevance:
_mungeQueryString:forMatchType:
_searchFullTextIndex:
startSearch
isComplete
mergedResults
useSingularDelegateMethod
delegate
contextInfo
docSet:didFindTextSearchResults:isFinished:contextInfo:
docSets:didFindTextSearchResults:isFinished:contextInfo:
_looksLikeSearchKitQuery:
whitespaceCharacterSet
initWithQuery:matchType:docSets:nodes:delegate:contextInfo:
setUseSingularDelegateMethod:
_addQueuedQuery:inNodes:inDocSets:withMatchType:usingSingularDelegateMethod:delegate:contextInfo:
removeSearchObjectForDocSet:
sortUsingComparator:
indexSetWithIndexesInRange:
removeObjectsAtIndexes:
nodeTextResults
fullTextResults
_searchForDocSet
_searchResults
_currentSearchCanceled
_matchType
_docSets
_nodes
_delegate
_contextInfo
_useSingularDelegateMethod
prefetchNodes
maximumFullTextRelevance
sortedArrayUsingComparator:
_fullTextResults
_nodeTextResults
_maximumFullTextRelevance
integerValue
isRootNode
kName
kPath
kFileName
kAnchor
kURL
_isCurrentOrVersionAfter:
kNodeType
documentTypeNode
installDomain
domain
kSubnodeCount
longValue
_downloadableFiles
_cachedTermList
isSearchable
primaryNodePath
reverseObjectEnumerator
nodePaths
_primaryParentUsingNodePaths:
childCount
orderedSubnodes
_nodePathsWithExistingDescendants:
_namesForPath:
_subnodesWithSearchability:
_findNodes:inHierarchy:areSearchable:
_nodesInHierarchySearchable:
apiLanguagesInHierarchy
nodesInHierarchy
relatedNodes
urlsForDownloadableFilesByType
namedPaths
searchableChildren
unsearchableChildren
searchableNodesInHierarchy
languages
_isInvalidated
_rootNodeStateInitialized
_isRootNode
initForTermID:withBaseScore:
initForTermMatches:
scores
_termID
_score
cStringUsingEncoding:
enumerateObjectsUsingBlock:
stringWithCString:encoding:
.cxx_construct
tokenCache
tokenNames1
tokenNames2
scopes
tokenUSRIndex
DocSetIndex
DVTDownloadableIndexSourceDocs
DSAResultSource
DSAArrayResultSource
DSAMultipleResultSource
DocSetPrivateAddition
DocSetIndexSearch
DSATextSearchResult
NSCopying
DSASearchKitSearchResult
DSANodeSearchResult
DSADocSet
DSASearch
DSACoreData
DSANodePaths
DocSetPersistentStoreMapping
DSATokenIndex
Search
DSATextIndex
DSADistributionVersion
DocSetHTMLExtractor
DSATermQuery
DSATokenSearchManager
DSAFastToken
DSAToken
NSObject
NSCoding
DocSetIndexDocument
DSATokenSource
DSATermManager
DSATextSearch
DSATermList
DocSetXMLConverter
DocSetIndexDocumentIterator
DSANodeURL
DSATextSearchQueue
DSAQueuedTextSearch
DSAQueuedTextSearchResults
DSANode
Private
DSATermMatch
DSATermSingleMatch
DSATermGroupMatch
DSADocSet_FastTokenCache
v16@0:8
@24@0:8^{__SKIndex=}16
@44@0:8@16@24i32@36
@36@0:8@16@24c32
@32@0:8@16@24
c16@0:8
Q16@0:8
v24@0:8Q16
i16@0:8
@16@0:8
c36@0:8@16@24c32
c24@0:8@16
@24@0:8@16
v32@0:8@16@24
i24@0:8@16
q24@0:8@16
@24@0:8q16
c32@0:8@16@24
q16@0:8
Q24@0:8q16
Q32@0:8Q16q24
Q24@0:8Q16
@24@0:8Q16
Q24@0:8@16
^{__SKIndex=}16@0:8
c28@0:8@16c24
^{__SKIndex=}
@"NSMutableData"
@24@0:8d16
@"NSSortDescriptor"
@"NSArray"
{_NSRange=QQ}52@0:8@16@24c32Q36^@44
q32@0:8@16@24
@"NSMutableArray"
@"NSString"
@36@0:8@16@24I32
^{__SKSearch=}16@0:8
Q48@0:8Q16d24^q32^f40
^{__SKSearch=}
f24@0:8@16
@24@0:8^{_NSZone=}16
f16@0:8
v20@0:8f16
v24@0:8@16
@60@0:8@16Q24Q32Q40f48@52
@"DSATextIndex"
@40@0:8@16@24f32c36
@"DSADocSet"
@40@0:8@16@24^@32
@40@0:8@16@24@?32
@60@0:8^{__CFBundle=}16@24@32i40@44^@52
@52@0:8^{__CFBundle=}16@24i32@36^@44
@32@0:8@16^@24
{?=b24b20b20}16@0:8
d16@0:8
@28@0:8@16c24
@20@0:8c16
@32@0:8@16c24c28
@32@0:8@16Q24
^{__CFBundle=}
@"NSURL"
@"NSPersistentStoreCoordinator"
@"NSManagedObjectContext"
@"NSMutableDictionary"
@"DSATokenIndex"
@"NSManagedObject"
@"DSANode"
@"NSDictionary"
@"NSObject<OS_dispatch_group>"
@"NSMapTable"
@"DSATermManager"
@"DVTDispatchLock"
@"DSADocSet_FastTokenCache"
@40@0:8@16@24Q32
c56@0:8@16@24Q32@40^v48
v32@0:8@16^v24
c56@0:8@16@24@32@40^v48
c36@0:8@16c24^@28
c24@0:8^@16
@32@0:8^{__CFBundle=}16@24
@20@0:8i16
@40@0:8@16@24@32
v20@0:8c16
v24@0:8@?16
@52@0:8@16@24@32c40^@44
@40@0:8@16@24i32c36
@"NSNumber"
@56@0:8@16@24Q32Q40^@48
@48@0:8@16@24Q32^@40
Q32@0:8@16^@24
v40@0:8@16@24@32
v24@0:8q16
v52@0:8@16@24c32@36@44
v48@0:8@16@24@32@40
v44@0:8@16@24c32@36
c40@0:8@16@24@32
c48@0:8@16@24@32@40
q24@0:8q16
^{__CFDictionary=}
@48@0:8@16@24{?=b24b20b20}32c44
{?="majorVersion"b24"minorVersion"b20"patchVersion"b20}
@40@0:8@16Q24@32
f32@0:8@16^c24
@"NSTimer"
@84@0:8@16@24@32@40@48@56@64c72@76
@"NSXMLDocument"16@0:8
@"<DSAToken>"24@0:8@"NSString"16
@"NSString"16@0:8
@"NSURL"16@0:8
@"DSADocSet"16@0:8
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
c24@0:8#16
c24@0:8@"Protocol"16
c24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@36@0:8{?=b24b20b20}16@28
@"NSXMLDocument"
@24@0:8^v16
^v16@0:8
@"NSPredicate"
I24@0:8@16
v20@0:8I16
I16@0:8
v24@0:8^{__CFSet=}16
Q28@0:8Q16f24
@28@0:8d16f24
@"DocSetIndexSearch"
r^^{__CFString}
^{__CFSet=}
^I16@0:8
c44@0:8@16@24i32^@36
c32@0:8@16^@24
@44@0:8@16@24i32^@36
v28@0:8@16i24
@"NSMutableSet"
^{__SKIndexDocumentIterator=}
@56@0:8@16@24@32@40Q48
c68@0:8@16@24@32Q40c48@52^v60
c64@0:8@16@24@32Q40@48^v56
@52@0:8@16@24@32Q40c48
@48@0:8@16@24@32Q40
@64@0:8@16Q24@32@40@48^v56
^{__CFSet=}24@0:8@16
v36@0:8@16@24c32
c20@0:8i16
@24@0:8I16f20
^f16@0:8
f20@0:8I16
{unordered_multimap<std::__1::basic_string<char>, const tokenPayload, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, const tokenPayload> > >="__table_"{__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload> > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> *> > >="__first_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *>}"__second_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> *> >="__first_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> > >="__first_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::hash<std::__1::basic_string<char> >, true> >="__first_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::equal_to<std::__1::basic_string<char> >, true> >="__first_"f}}}
{unordered_set<std::__1::basic_string<char>, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::basic_string<char> > >="__table_"{__hash_table<std::__1::basic_string<char>, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::basic_string<char> > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *> > >="__first_"^^{__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *>}"__second_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *> >="__first_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::basic_string<char>, void *> > >="__first_"{__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::hash<std::__1::basic_string<char> > >="__first_"Q}"__p3_"{__compressed_pair<float, std::__1::equal_to<std::__1::basic_string<char> > >="__first_"f}}}
{set<std::__1::basic_string<char>, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::basic_string<char> > >="__tree_"{__tree<std::__1::basic_string<char>, std::__1::less<std::__1::basic_string<char> >, std::__1::allocator<std::__1::basic_string<char> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::basic_string<char>, void *> > >="__first_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::less<std::__1::basic_string<char> > >="__first_"Q}}}
{unordered_multimap<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> >, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > > > >="__table_"{__hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > > > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *> *> > >="__first_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *>}"__second_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *> *> >="__first_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> > >="__first_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, std::__1::hash<std::__1::basic_string<char> >, true> >="__first_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *> > >, std::__1::equal_to<std::__1::basic_string<char> >, true> >="__first_"f}}}
docset-index
DVTDownloadableIndexDocs
https://devimages-cdn.apple.com/library/downloads/
sortDescriptor
T@"NSSortDescriptor",R,V_sortDescriptor
self
Fetch remaining sources: %6.3lf
Merge remaining sources: %6.3lf
/Library/Caches/com.apple.xbs/Sources/DocSetFrameworks/DocSetFrameworks-12009/DADocSetAccess/Utilities/DSAResultSource.m
<Unknown File>
Memory allocation failed during search results merge.
IndexOutOfBounds
Index %lu is outside the bounds of array (%lu)
numberOfCompares
TQ,V_numberOfCompares
DocSetDebug
DocSetAccess
.apple.com
apple.com
%@ (%5.2lf)
result
CONFLICT: Found 2 real search results for the same node
children
DocSetLogSearchResults
results = %@
roots =
resultRelevance
Tf,V_resultRelevance
childrenRelevance
Tf,V_childrenRelevance
T@"NSArray",C,V_children
relevance
Tf,R
title
T@"NSString",R,C
isTitleMatch
Tc,R
docset
Title
com.apple.DADocSetAccess
docSet.dsidx
docSet.skidx
docSet
docSet.tokencache
DocSetModelVersion
%u.%u.%u
DSADocSet Token Cache Lock
Documents
Persistent store does not contain a documentation set model
Persistent store does not contain a recognized documentation set model.
Unable to find/read the %@ documentation set model
default
legacy
Unable to find/read the default documentation set model.
v8@?0
Error converting XML to CoreData: %@
Error saving converted XML to persistent store: %@
DocSet
Found no DocSet record
Failed to find the primary 'DocSet' record.
Successfully loaded %@
Unable to load bundle
Unable to load documentation set's bundle.
Error loading persistent store at %@: %@
No model found for version of persistent store. Not loading %@
Nodes.xml
Error reading configuration file: %@
Unable to find either a loadable database or a Nodes.xml configuration file
Unable to find the database or 'Nodes.xml' configuration file.
%@ %d.%d.%d
 (%@ %@)
%@ (%lu nodes)
  Web = %@
Tokens.xml
Tokens
.xml
rootNode
DocSetDescription
DocSetPublisherName
DocSetPublisherIdentifier
DocSetFeedName
DocSetFeedURL
configurationVersion
DocSetPlatformFamily
DocSetPlatformVersion
DocSetMinimumXcodeVersion
DocSetMaximumXcodeVersion
DocSetFallbackURLs
DocSetFallbackURL
DocSetCertificateSigner
DocSetCertificateIssuer
DocSetRequiresUpdateForContent
%@.lproj
-[DSADocSet textIndexURL]
/Library/Caches/com.apple.xbs/Sources/DocSetFrameworks/DocSetFrameworks-12009/DADocSetAccess/Access/DSADocSet.m
Could not retrieve text index URL for DocSet (%@) because the doc set's bundle did not exist or does not contain a resources directory
Unable to create directory %@
FullText
docSet.toc
nodeInfo
indexedTerms
... done loading TOC cache with %lu nodes (%lf)
Failed to generate TOC cache
Failed to read data from TOC cache
Node
kID = %@
kID IN %@
NodeUUID
uuid = %@
node
uuid LIKE %@
kDocumentType = %@
ReleaseNote
path
uuid
APILanguage
Error searching for languages: %@
fullName
DistributionVersion
Error searching for distribution versions: %@
node_paths
[^A-Za-z0-9\.\-]
%@-%d.%d.%d.plist
... done loading node path cache with %lu nodes (%lf)
Failed to generate node path cache
Failed to read data from node path cache
index.html
https:
http:
file
Token
Failed to archive fast token cache to nil URL
Failed to archive fast token cache from path: %@
Found no TokenCache in: %@
Archive in cache path is not of the correct type: %@
Failed to unarchive fast token cache from path: %@
Invalid fast token cache archive at path %@: %@ (%@)
matchString must not be nil
scope must not be nil
-[DSADocSet tokenCacheURL]
((resourcesURL)) != nil
%@ should not be nil.
(resourcesURL)
fastTokenCache
T@"DSADocSet_FastTokenCache",&,V_fastTokenCache
localizedDescription
T@"NSString",R
localizedPublisherName
publisherIdentifier
requiresUpdateForContent
isValid
hasTokenCache
wouldLoadTokenCache
Doc set search not executing on main thread!
supportsUSRLookup
Error removing persistent store: %@
Removed persistent store %p
+[DSADocSet(DSACoreData) _URLForStoreInBundle:withLocalization:]
((resourceURL)) != nil
(resourceURL)
+[DSADocSet(DSACoreData) _URLForModelInBundle:withLocalization:]
Unable to generate a path for documentation set's default database.
Unable to generate a path for documentation set's default model.
migrate data to: %@
Unable to delete %@
Failed to save documentation set's database.
Unable to delete existing persistent store.
Overwriting existing store
Saving managed object context
Error saving changes to persistent store: %@
_v%d
Loading legacy model %@
file.path
-[DSADocSet(DSANodePaths) urlForTokenXML:]
Token usr value for token %@ is supposed to be a string, but it is a %@ with value %@
__objc_no
Called DVTWarn
Path for token %@ is supposed to be a string, but it is a %@ with value %@
Internal error reading documentation set.
Documentation set could not be read.
DSAInvalidContextException
parentNode != NULL
alphaSortOrder
Name
Type
Scope
//apple_ref/
Symbol ID missing //apple_ref/ prefix: %@
man page(%@)
buildsetting
writerid
DocSetNilHandle
Passed a nil pointer to a mutable dictionary for entity %@
Header
headerPath = %@
headerPath
frameworkName
FilePath
path = %@
TokenType
typeName
%@ : %@ : %d
jointVersionKey
Container
containerName
tokenUSR
tokenName
firstLowercaseUTF8Byte
tokenType
container
language
Tried to create a token with an unrecognized language value: %@
TokenGroup
tokens
frameworks
maxResults
nameMatchType
parentNode
appleRef
language = %@
language != NULL
language IN %@
language = NULL
tokenUSR = %@
tokenName LIKE[c] %@
firstLowercaseUTF8Byte = %@ && tokenName LIKE[c] %@
firstLowercaseUTF8Byte = %@ && tokenName BEGINSWITH[c] %@
tokenName CONTAINS[c] %@
firstLowercaseUTF8Byte = %@ && tokenName = %@
tokenType = %@
container = %@
metainformation.declaredIn.frameworkName IN %@
parentNode IN %@
parentNode = NULL
parentNode = %@
self = %@
self IN %@
__DEFAULT__
__ABSOLUTE__
__FALLBACK__
IdMappingKey%lu
IdMappingValue%lu
IdMappingKey%d
IdMappingValue%d
root = %@ (%ld)
Multiple document roots of type %@ exist in index
Found untyped document root in index: %@
Load mappings: %6.3lf
docset://%@
Attempted to modify an existing root document for path: %@
New %@ = %ld (%@: %@)
Unable to find root document for path %@
html
HTML
Path
IsFolder
LocalizationPaths
.book
versionString
ppc64
i386
x86_64
architectureFlags
distributionName
DocSetIncompatibleModel
Attempted to set the version information of a version record, but could not parse into 3 pieces the joint key passed in: %@.
Error reading %@
   --> Successfully read file as Latin-1
extractTextFromHTMLFile: Caught %@: %@
contains(lower-case(/html/head/meta[lower-case(@name) eq "robots"]/@content), "noindex")
script
style
noframes
meta
name
IndexTitle
content
<meta 
http-equiv
Content-Type
charset
clconst
tmplt
instm
instp
intf
intfcm
intfm
intfp
func
ftmplt
econst
tdef
data
macro
infoplistkey
DSAAvailabilityStatus
DSAAvailabilityVersionStatement
DSAAvailabilityDeprecationVersion
DSAAvailabilityDistributionName
DSATokenParameterName
DSATokenParameterAbstractAsHTML
DSATokenReturnValueAbstractAsHTML
/Library/Caches/com.apple.xbs/Sources/DocSetFrameworks/DocSetFrameworks-12009/DADocSetAccess/CoreDataModel/DSAToken.m
name is a required argument
relativeURL is a required argument
type is a required argument
%@/%@/%@/%@
relativeURL
scope
type
declaredInFrameworkName
deprecated
apiLanguage
Objective-C
Objective-C++
hash
TQ,R
superclass
T#,R
description
debugDescription
T@"NSURL",R,C,N
Tc,R,GisDeprecated
T@"DSADocSet",R
T@"NSString",C,Vusr
T@"NSString",C,Vname
T@"NSString",C,VapiLanguage
T@"NSString",C,VrelativeURL
T@"NSString",C,Vscope
T@"NSString",C,Vtype
T@"NSString",C,VdeclaredInFrameworkName
Tc,GisDeprecated,Vdeprecated
T@"DSADocSet",&,VdocSet
metainformation
TokenMetainformation
language.fullName
tokenType.typeName
container.containerName
abstract
declaration
parameters
Param%d
Parameter
parameterName
order
returnValue
ReturnValue
throwsDiscussion
declaredIn
deprecationSummary
relatedTokens
relatedGroups
relatedSampleCode
relatedDocuments
anchor
superclassContainers
protocolContainers
introducedInVersions
deprecatedInVersions
removedAfterVersions
 to 
 and later
APILanguages
strings
Failed to find or read the APILanguages.strings file for the framework
TokenTypes
Failed to find or read the TokenTypes.strings file for the framework
Function
Unable to create SearchDocument!
Exception thrown performing background fetch: %@
docSet.localizedName
tokenTypeCategory
batchValues
batchPosition
alphaSortOrder >= %@ && alphaSortOrder < %@
tokenType IN %@
.,/!<>()'"&|
Error: Found duplicate term entries: %@
%@-%lu
SELF LIKE %@
exception: %@
version
Category
Documentation set's nodes XML file uses an unsupported format.
Unable to determine version of documentation set's nodes XML file.
./Documents
DocSetNodes
XML does not represent a doc set.  Should have a DocSetNodes root element
Documentation set's nodes XML file does not have the proper root element (DocSetNodes).
Unable to update XML document to current spec
DocSetDuplicateNodeID
Duplicate Node ID number detected for ID=%d
kDocumentType
primaryParent
kName
kNodeType
documentType
sample code
reference
recipe
video
playground
generic
Document type is not recognized: %@
noindex
kIsSearchable
UUID
File
Anchor
baseURL
NodeURL
kPath
kFileName
kAnchor
kURL
Download
sourcecode
ibook
epub
Download type is not recognized: %@.
DownloadableFile
apiLanguages
NodeRef
refid
OrderedSubnode
isPrimaryTOCNode
Failed to find subnode
orderedSubnodes
kSubnodeCount
Failed to find related node
relatedNodes
Library
Documentation set's nodes XML file is missing a 'TOC' element.
.//Node
Subnodes
Node|NodeRef
RelatedNodes
.//NodeRef
Unable to locate the root node for doc set
Unable to find the root 'Node' element for the documentation set.
XcodeReleaseNotes
noderef
Unable to locate node '%@' for custom UUID
ReleaseNote element did not contain both an 'id' and 'noderef' value
Couldn't set up doc set!
Couldn't set up nodes!
Couldn't set up release notes!
checksum = %@
T@"NSString",&,D,N
fileName
checksum
T@"NSNumber",&,D,N
T@"DSANode",&,D,N
/Library/Caches/com.apple.xbs/Sources/DocSetFrameworks/DocSetFrameworks-12009/DADocSetAccess/TextIndex/DSATextSearchQueue.m
Search not starting on main thread
MainQueue: %@
-[DSATextSearchQueue startSearch]_block_invoke_2
Unable to generate full-text search object
"()!&|*
 AND 
 OR 
 NOT 
NOT 
Async search not called on main thread
Cancel search not called on main thread
Invalidate search not called on main thread
q24@?0@"DSANodeSearchResult"8@"DSANodeSearchResult"16
Search not called on main thread
Title search: %lf (%lu docs)
SearchKit search: %lf (%lu docs)
query
T@"NSString",R,V_query
matchType
TQ,R,V_matchType
docSets
T@"NSArray",R,V_docSets
nodes
T@"NSArray",R,V_nodes
delegate
T@,R,V_delegate
contextInfo
T^v,R,V_contextInfo
useSingularDelegateMethod
Tc,V_useSingularDelegateMethod
q24@?0@"DSATextSearchResult"8@"DSATextSearchResult"16
Merged %lu title matches and %lu text matches: %lf (%lu docs)
fullTextResults
T@"NSArray",&,V_fullTextResults
nodeTextResults
T@"NSArray",&,V_nodeTextResults
maximumFullTextRelevance
Tf,V_maximumFullTextRelevance
folder
bundle
section
Unable to locate a docset to query about a Node entity
Unknown
node = %@
orderedSelfs.parent
T@"NSNumber",R,D
T@"NSString",R,D
T@,R,D
installDomain
T@"NSSet",R,D
documentTypeNode
T@"DSANode",R
%@ (%lu documents)
    
  %@
   %@
   %@
%4lu (%6.3lf)
q24@?0@8@16
ERROR: Merging term matches that contain more than 1 element not allowed
<%@: %lu terms>
v32@?0@"DSAFastToken"8Q16^c24
/Library/Caches/com.apple.xbs/Sources/DocSetFrameworks/DocSetFrameworks-12009/DADocSetAccess/Access/DSADocSet_FastTokenCache.mm
Invalid match type %lu.
v24@?0r^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >={__compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> >={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}8^{vector<DSAFastToken *, std::__1::allocator<DSAFastToken *> >=^@^@{__compressed_pair<DSAFastToken *__strong *, std::__1::allocator<DSAFastToken *> >=^@}}16
v24@?0^{unordered_set<std::__1::basic_string<char>, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::basic_string<char> > >={__hash_table<std::__1::basic_string<char>, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::basic_string<char> > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *> *> >=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::basic_string<char>, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::hash<std::__1::basic_string<char> > >=Q}{__compressed_pair<float, std::__1::equal_to<std::__1::basic_string<char> > >=f}}}8^{vector<DSAFastToken *, std::__1::allocator<DSAFastToken *> >=^@^@{__compressed_pair<DSAFastToken *__strong *, std::__1::allocator<DSAFastToken *> >=^@}}16
?333333
@(#)PROGRAM:DADocSetAccess  PROJECT:DocSetFrameworks-12009
