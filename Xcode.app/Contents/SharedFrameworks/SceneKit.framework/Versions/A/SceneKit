Error: C3DTransformsArrayAppendTransforms - out of bounds
C3DTransformsArray
<C3DTransformsArray %p>
C3DFXOutline.plist
Outline-pickedObjects
C3DFXOutlineRetina.plist
C3DFXAuthoring.plist
--OutlineMaterial--
PickedObject.glsl
Diffuse: Pre-integrated irradiance
v8@?0
scn_draw_fullscreen_quad_vertex
draw_diffusePreIntegrated_fragment
v16@?0@"<MTLCommandBuffer>"8
cubemap_from_sh
Specular: Pre-integrated LD
draw_specularPreIntegratedLD_fragment
-[SCNMetalResourceManager(PBR) radianceTextureForEnvironmentTexture:queue:group:]
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/NewRenderer/SCNMetalResourceManager+PBR.mm
error == nil
Specular: Pre-integrated DFG
compute_specularPreIntegratedDFG
TEXCOORD
Warning: The instance_effect with URL %s does not reference an effect, skipping it
NULL
Warning: Found an invalid material [%s], reverting to a default material
Warning: We cannot yet read geometries without IDs; discarding one
bump.texture
shininess.texture
constant_ambient.texture
constant_diffuse.texture
multiply.texture
HANNEL
CHANNEL1
ANNEL
CHANNEL2
NNEL
CHANNEL3
CHANNEL4
CHANNEL5
CHANNEL6
CHANNEL
CHANNEL0
texcoord
Error: C3DIO_COLLADA_ReadMesh: geometry should already be cached into the library
kSceneSourcePreserveOriginalTopology
Warning: The source %s does not have a Technique_common element. This might be caused by an exporter bug. Skipping it.
Warning: Found a source %s without a Technique_common element. This might be caused by an exporter bug. Skipping it.
Warning: The source %s has some unsupported traits (advanced params or non-float arrays). Skipping it
Warning: Found a source with some unsupported traits (advanced params or non-float arrays). Skipping it
Warning: The source %s has some unsupported traits (non-float array or interleaved arrays). Skipping it
Warning: Found a source with some unsupported traits (non-float array or interleaved arrays). Skipping it
Warning: Found an invalid source (stride == 0). Skipping it
Warning: Invalid source %s: offset + stride * count > source count. Skipping it
Warning: Found an invalid source (offset + stride * count > source count). Skipping it
Warning: Source %s: unsupported semantic %s. Skipping it.
Warning: Found an source with the unsupported semantic %s. Skipping it
COLLADA_MeshSource
Error: C3DIO_COLLADA_ReadElements: geometryElement references an index out of bounds - ignoring
Error: __CreateMeshElement inconsistent index count
COLLADA_MeshElement
Error: Cannot load image %@. Using dummy texture.
v20@?0C8r*12
Error: unknown compression format
Error: Cannot load image %@. Texture will be garbage.
Error: C3DRendererCreateTextureWithImage : error while getting bitmap bytes
compute_cubemap_from_latlong
compute_latlong_from_cubemap
Error: failed loading texture named %@ : %@
C3DAnimationClusterKeyframes
<C3DAnimationClusterKeyframes %p>
C3DAnimationCluster
<C3DAnimationCluster %p>
vertex4
kNodeToSIDKey
kMorphingImportKey
kSkinningImportKey
kSkinningUsedGeometriesKey
kSceneSourceOptimizeVertexCache
No data or file to load from
/dev/null
An error occurred while parsing the COLLADA file. Please check that it has not been corrupted.
Error: The DOM could not be loaded
Error: Found errors while checking the document for coherency:
SCNDetailedErrorsKey
Error: %@
Error: Could not deindex.
The meshes in the document appear to be corrupted.
visual_scene
Error: Unable to get the referenced visual_scene
Error: Could not get the instance_visual_scene
The document does not have a scene. Please check that it has not been corrupted.
%.1f %.1f %.1f
SceneKit
+0000
%FT%T%z
SketchUp
Blender
FCOLLADA
start_time
end_time
MAX3D
frame_rate
OpenCL
clVertexProgram
vertex_program
spec_level.float
double_sided
true
Warning: ____C3DIO_COLLADA_LoadImageSurface: can't find image
Warning: ____C3DIO_COLLADA_LoadImageSurface: can't find sub image
__C3DIO_COLLADA_CopySampler: error
__C3DIO_COLLADA_CopySampler failed to resolve image reference
runtimePath
Warning: Could not interpret the URL %s
location
relativePath
Warning: Could not interpret (2) the URL %s
Warning: Could not initialize an image, an init_from element is needed
scene
SCNMonitor
SCNKitError : can't load nib named : SCNMonitor
SCNKitTypeInspector
can't load nib named : SCNKitTypeInspector
selection
name
address
type
semantic
childs
error in SCNTypeInspectorView : returned object is not a dictionary
instance
Error: can't edit NULL address
Error: can't edit pointer
Error: can't edit unknown type
%@ 0x%p
false
[%f, %f]
[%f, %f, %f]
[%f, %f, %f, %f]
identity
[%f, %f, %f, %f][%f, %f, %f, %f][%f, %f, %f, %f][%f, %f, %f, %f]
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
T@,&
/[], 
_timesToRepeat
_timesRepeated
_repeatedAction
_forever
Error: repeatAction: invoked with a nil action
Error: repeatActionForever: invoked with a nil action
_opacityTarget
_opacityTargetReversed
_lastOpacity
_isRelative
Warning: Could not interpret or find the image for the id %s, ignoring it
Warning: Could not find the image information for the id %s, ignoring it
Warning: Could not find the image information (empty fx_surface array), ignoring it
Warning: Unsupported domFx_surface_type_enum
Error: Expecting a surface
constant_ambient
constant_diffuse
Error: C3DIO_COLLADA_ReadEffect error 4
multiply
shader.use_self_illum_color
ambient_diffuse_lock
litPerPixel
extendedLightingModel
None
invertCulling
avoidsOverLighting
writesToDepthBuffer
readsFromDepthBuffer
fresnelExponent.float
intensities
Error: invalid property name
.float
image
texture
color
start
animations
nodeToTransformArray
Error: failed to resolve referenced animation %@ at index %ld
%s-%d
animation-%d
INPUT
OUTPUT
IN_TANGENT
OUT_TANGENT
INTERPOLATION
input
Error: invalid collada file - missing animation input
output
inTangent
outTangent
interpolation
animation
parentGroup
grandParentGroup
Warning: failed to create an animation keyframes for: %s
Warning: failed to create an animation target for: %s
Warning: failed to create an animation for target: %s
ANGLE
Warning: kvcPathForElement: We do not know how to handle elements named %s
Error: Found a Rotate element without 4 attached floats. Please check the document for consistency.
rotation
ambient
ambient.color
diffuse
diffuse.color
specular
specular.color
emission
emission.color
transparent
transparent.color
reflective
reflective.color
Warning: kvcPathForElement: unknown color slot: %s
Warning: kvcPathForElement: unexpected color path
focal_depth
ALPHA
DOUBLE_SIDED
doubleSided
(0)(0)
(0)(1)
(0)(2)
(1)(0)
(1)(1)
(1)(2)
(2)(0)
(2)(1)
(2)(2)
(3)(0)
(3)(1)
(3)(2)
focalDistance
sample_radius
aperture
hotspot_beam
spotInnerAngle
falloff
spotOuterAngle
Warning: inconsistent keyframe length
LINEAR
STEP
Error: invalid tangent buffer length
BEZIER
Warning: trying to animate kC3DBaseTypeNone
Error: _sampleAndAddAnimations can't find transform stack for node %@
Error: animation duration is too long: %f - skip sampling
Error: unable to sample transform animation - fail to transpose animation target
Error: unable to sample transform animation - no transform found with sid %@
Error: unable to sample transform animation - no transform sid found
Warning: failed to evaluate animation to bake animation
Error: unable to sample transform animation - to parent animation to attach sampled animation
Error: _C3DCreateTransformAnimationChannelFromChannels - no path
Warning: invalide animation group detected
Warning: loaded an animation with duration == 0
q16@?0^{__C3DNode=}8
unnamed animation #%d
Info: zNear of 0 found while loading DAE - will use 0.01 instead
Warning: Found a camera without either an orthographic specification or a perspective one. Discarding the camera. Please ensure the document has been checked for consistency.
Warning: Should not register a node without light to the light system
Error: Node is already registered to the light system
Error: Invalid runtime light index
Error: The shadow node is not registered
Error: Too many shadow caster lights at once. Limit is %d
C3DLightingSystem
<C3DLightingSystem %p>
Error: Too many effective lights at once. Limit is %d
shadow_attributes.type
use_far_attenuation
far_attenuation_end
attenuation_far_end
far_attenuation_start
attenuation_far_start
near_attenuation_start
attenuation_near_start
attenuationStart
attenuationEnd
attenuationFalloffExponent
intensity
shadow
enable
shadowRadius
zNear
zFar
orthographicScale
spotParameters
outerAngle
falloffExponent
innerAngle
Error: Found a Rotate element without the 4 required floats, please ensure the document has been checked for coherency
Error: Found a translate element without three associated floats; please ensure the document has been checked for consistency
Error: Found a scale element without three associated floats; please ensure the document has been checked for consistency
Warning: We do not handle skew transforms yet
Error: Cannot create an unique ID for a node
visibility
renderingOrder
opacity
Warning: Node %@: we do not handle multiple controller instances per node. Using the first and skipping the others
Warning: We do not handle multiple controller instances per node. Using the first and skipping the others
Warning: Could not create an instance_node, no URL specified. Please check the document for consistency.
user_properties
lightmap_path
Warning: Lightmap image at path %s not found, can't create lightmap info
Warning: No path found, can't create lightmap info
uv_set
triggerOptionsForRealtimeViewer
kSceneSourceMaximumMemoryForImages
kSceneSourceAutoLimitMemoryForImages
kSceneSourceCreateNewLibrary
kSceneSourceInvertMaterialOpacity
kSceneSourceCreateCameraIfAbsent
kSceneSourceCreateLightIfAbsent
kSceneSourceCreateNormalsIfAbsent
kSceneSourceAdjustInvalidClippingPlanes
kSceneSourceFlattenScene
kSceneSourceSplitMeshesForGLES
kSceneSourcePreloadImages
kSceneSourceBakeKeyframing
kSceneSourceConvertToYUpIfNeeded
kSceneSourceConvertToUnit
kSceneSourceAnimationLoadingMode
keepSeparate
playRepeatedly
playOnce
playUsingSceneTime
kSceneSourceCleanupMeshes
kSceneSourceRemoveConstantAnimations
kSceneSourceRemoveAllLights
kSceneSourceRemoveColorArrays
kSceneSourceInterleaveSources
kSceneSourceMakeSourcesCheaper
kSceneSourceSkipConsistencyCheck
kSceneSourceCheckConsistency
kC3DIOSceneSourceWasExportedBySceneKit
kSceneSourceUseSafeMode
kSceneSourceAssetDirectoryURLs
kSceneSourceOverrideAssetURLs
kSceneSourceStrictConformanceKey
kSceneSourceVerboseMode
kSceneSourceFormatHint
kSceneSourceProcessIsSandboxed
kSceneSourceSkipSandboxValidation
kSceneSourceSkipImagePathResolution
contributors
created
modified
up_axis
unit
authoring_tool
author
unitName
unitMeter
com.apple.SceneKit
kEnclosingDirectoryURL
C3DSceneSource
Unknown or missing file
Could not load the scene
The document does not appear to be a valid COLLADA file. Please check that is has not been corrupted.
The document does not appear to be valid. Please re-create it from your original COLLADA assets.
<C3DSceneSource >
org.khronos.collada.digital-asset-exchange
C3DParticleModifier
<C3DParticleModifierRef>
Error: Failed to create instance of type %ld. Extra size too large
Error: Failed to create instance of type %@
weakRef
T@,W,N,VweakRef
Error: Color deserialize: could not read the float array
Error: Color deserialize: no color or no deserialized data
Error: C3DBaseTypeForCFNumberType: Type not supported
Error: C3DConvertToPlatformIndependentData - archiving pointers makes no sense
Error: C3DConvertToPlatformIndependentData - Type not supported
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to read
Error: C3DConvertFromPlatformIndependentData: Not enough room for the specified count & stride to write
Error: C3DConvertFromPlatformIndependentData - Type not supported
none
float
bool
char
double
C3DFloat
float4x4
float3x3
color4
short
half
uchar
ushort
int2
int3
int4
ucharn
charn
10a2n
u10a2n
uchar4
char4
uchar4n
char4n
ushort2
ushort3
ushort4
shorn
short2
short3
short4
ushortn
ushort2n
ushort3n
ushort4n
short2n
short3n
short4n
half2
half3
half4
Warning: C3DBaseTypeFromDescription - signed/unsigned ambiguity
Error: C3DBaseTypeFromDescription - Type not supported
Error: C3DBaseTypeRequires32to64bitConversion:: unknown type
Error: C3DAddBaseType - type %d can't be added
Error: C3DAddBaseType - addition of half float not supported
Error: C3DAddBaseType - unknown type
Error: C3DSubBaseType - type %d can't be substracted
Error: C3DSubBaseType - substraction of half float not supported
Error: C3DSubBaseType - unknown type
Error: C3DMultBaseTypeWithFloat - type %d can't be multiplied
Error: C3DMultBaseTypeWithFloat - multiply half float not supported
Error: C3DMultBaseTypeWithFloat - unknown type
Error: Conversion to C string failed
Warning: C3DParseVersionNumber - No version found
#ext
define
undef
ifndef
Assertion failed [comparisonDepth<=comparisonMaxCount] too many nested macros in shader
ifdef
else
elif
endif
hw.optional.sse2
hw.optional.sse3
hw.optional.supplementalsse3
hw.optional.sse4_1
hw.optional.sse4_2
hw.optional.avx1_0
hw.optional.fma
Error: failed to load resource named %@
Error: failed to load dictionary named %@
Error: failed to load json named %@ (reason: %@)
Error: failed to load json named %@
com.apple.sceneKit.forceGL
com.apple.sceneKit.forceMetal
com.apple.sceneKit.showsStatistics
com.apple.sceneKit.enableCameraControl
com.apple.sceneKit.batchMaxCount
com.apple.sceneKit.forceNoAA
com.apple.sceneKit.disableLinearSpaceRendering
com.apple.sceneKit.disableWideGamut
com.apple.sceneKit.enablePostMorphUnifyNormals
com.apple.sceneKit.enableStandardShadersWithFunctionConstants
com.apple.sceneKit.forceNMOSBehavior
com.apple.sceneKit.verbose
com.apple.sceneKit.isolateCacheMissShader
SCNDisableLinearSpaceRendering
Info: linear rendering forced to %d
SCNDisableWideGamut
SKESceneDocument
SKEDocumentSanitizer
Error: Could not deserialize a number array (nil buffer or serialized data)
Error: Could not deserialize a number (%@) in a number array
Error: Could not deserialize a number array (unexpected type)
vec2
vec3
vec4
ivec2
ivec4
mat44
Warning: C3DBaseTypeFromString: unknown type name '%@'
#define %@ %@
Warning: operator incorreclty parsed : %@
defined
wrong syntax : defined() with no token
wrong syntax : unknown token
parsing error : extra parenthesis found
parsing error : parenthesis mismatch
<%@:%p "%@"
  mesh: %@
  mat%d: %@
Error: Geometry deserialization: cannot find the mesh ID
Error: Geometry deserialization: cannot find the specified mesh
bindInfos
Error: Geometry deserialization: cannot find the specified material
Warning: _C3DGeometryFinalizeDeserialization - material ID of 0 is unexpected
mesh
overrideMaterial
materials
levelsOfDetail
sceneRef
Error: cannot generate points : mismatch between vertices and normals count
Error: Cannot use volume generation on a generic mesh. fallbacking on surface
Error: Could not deserialize the property %@ in the serialized effect %@
C3DGeometry
Error: C3DMeshElementCreateByMergingElements - strip not supported
Error: C3DMeshElementCreateByMergingElements - merging elements with different byte per index
Warning: %s does not support non-renderable topologies.
C3DMeshElementGetIndexCountPerPrimitive
Error: C3DMeshElementGetIndexCount:primitive type not handled
Error: unexpected vertex count
CHANNEL %ld/%ld
%4u : %4u %4u %4u
%4u : %4u %4u
%4u : %4u
%2u : [Polygon %4u]
 %4u
v24@?0I8^I12I20
C3DMeshElement
<C3DMeshElement %p type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>
triangles
triangleStrip
lines
points
polygons
triangleFan
patch
invalid
Error: Mesh element deserialization: no faces count
Error: Mesh element deserialization: no mesh element type
Error: Mesh element deserialization: no bytes per index
Error: Could not read the indexes
Error: Mesh element deserialization: no serialized indices
linesArray
trianglesArray
pointsArray
trianglesStrip
polygonsArray
Warning: Unknown mesh element type %@, assuming triangles array.
indexes
subElementsCount
bytesPerIndex
primitiveNormals
bbox[0]
bbox[1]
Error: C3DMeshElementSetPrimitives invalid index buffer size
Error: __readIndexInBuffer - index (%u) out of bounds (%lu)
v16@?0@"MTLRenderPipelineDescriptor"8
SCNGeometryUniformTessellator tessellation factors
SCNGeometryScreenSpaceAdaptiveTessellator tessellation factors
Compute SCNGeometryScreenSpaceAdaptiveTessellator tessellation factors
compute_tessellation_factors_screeenspace_adaptive_uint16
compute_tessellation_factors_screeenspace_adaptive_uint32
kC3DGeometryTessellatorTypeConstrainedEdgeLength tessellation factors
Compute kC3DGeometryTessellatorTypeConstrainedEdgeLength tessellation factors
compute_tessellation_factors_constrained_edge_uint16
compute_tessellation_factors_constrained_edge_uint32
parentView
T@"SCNView",N,V_parentView
Error: failed to copy a snapshot of %@
q16@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8
v24@?0^^{__C3DNode}8q16
Error: C3DTriangle3BarycentricCoordinates fail
Error: C3DSurfacePositionWithBlinnApproximationOnMeshAtLocation inconsistency
C3DHitTestResult
<C3DHitTestResult %@ %f,%f,%f>
Error: _C3DHitTestResultComputeSmoothedValues no node
Error: _C3DHitTestResultComputeSmoothedValues no mesh
Error: _C3DUnProjectPoints : invalid viewport dimension
Error: error in _C3DUnProjectPoints
%@-splitContainer
splitContainer
Warning: unlock not locked ressource
Error: C3DMeshSubdivide inconsistency
B8@?0
Warning: try to preload a geometry with no mesh
Error: WARNING: NULL data in mesh source (warming geometry)
B16@?0@?<v@?>8
Warning: %s is deprecated please use %s instead
C3DGetResidentMeshElement
Error: Cannot generate tangents without valid positions
Error: Cannot generate valid tangents without valid texture coordinates
Error: Cannot generate valid tangents without valid normals
Error: invalid geometry detected - skip C3DCreateTexTangentWithGeometryOptimized
Error: target mesh has a different number of vertices (%d != %d)
v16@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8
Error: Cannot generate tangents without positions
Error: Cannot generate tangents without texture coordinates
Error: error in C3DMeshCreateTextureTangentsIfNeeded
Warning: Cannot create an interleaved copy, count mismatch
v32@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8c16q20C28
default camera
Kernel debug
Error: Given sources must be of the same length for interval list creation
Warning: __MergeMeshSources unknown source type
%@-split%d
Error: C3DSourceAccessorCopyDataToAccessor failed
Warning: C3DUnifyNormalsFromGeometry can only process triangles and polygons
Warning: C3DUnifyNormalsFromGeometry empty indices
_audioSource
_wait
value
T@,&,N
target
T@,&,N,Vtarget
action
T:,N,Vaction
Error: inconsistency in lru list
Error: inconsistency in lru list (2)
C3DListNode
<C3DListNode %p>
C3DList
<C3DList %p: head %p, tail %p, %ld objects>
_actions
_mycaction->_animIndex
Error: [SCNAction sequence:] invoked with nil
Error: C3DMatrix4x4MakePerspective_GL : bad fov Y
Error: C3DMatrix4x4MakePerspective_GL : bad fov X
Error: C3DMatrix4x4MakePerspective_GL : bad fov
Error: C3DMatrix4x4MakePerspective_MTL : bad fov Y
Error: C3DMatrix4x4MakeOrtho - bad projection info
C3DTransformTree
<C3DTransformTree %p>
v24@?0^{__C3DNode=}8^B16
Error: Could not create texture with descriptor : %@
setupBlock
T@?,C,N,VsetupBlock
executeBlock
T@?,C,N,VexecuteBlock
reduceTmp1
reduceTmp2
scn_depth_minmax_downx4_init
scn_depth_minmax_downx4_step
scn_depth_minmax_tail
SCNMTLReduceDepthPass
SCNMTLReduceDepthPass - Sync
Error: object %@ doesn't conform to the copying protocol
Error: invalid ref count for entity %@
v16@?0^{__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}8
sourceObject
T@,&,N,VsourceObject
keyPathSrc
T@"NSString",&,N,VkeyPathSrc
keyPathDst
T@"NSString",&,N,VkeyPathDst
options
T@"NSDictionary",&,N,Voptions
C3DStack
<C3DStack>
C3D-Standard.metal
#import "scn_metal"
#import "scn_util.h"
#import "scn_lighting.h"
#import "scn_standard_constants.h"
#import "C3D-PBR.metal"
__ExtraVaryingsDecl__
__ShaderModifiersDecl__
__VertexExtraArguments__
__DoGeometryModifier__
__VertexExtraArgumentsPostTessellation__
__DoGeometryModifierPostTessellation__
__FragmentExtraArguments__
__DoSurfaceModifier__
__DoFragmentModifier__
C3D-CommonProfile.metal
#import "scn_tesselation.h"
__TexcoordDecl__
__SurfaceExtraDecl__
__LightingDecl__
__OpenSubdivDecl__
__VertexDoVertexOnlyTexcoord__
__VertexDoLighting__
__VertexDoTexcoord__
__VertexDoVertexOnlyTexcoordPostTessellation__
__VertexDoLightingPostTessellation__
__VertexDoTexcoordPostTessellation__
__FragmentDoTexcoord__
__FragmentDoLighting__
%@ %@;
depth
sampler
, device %@ %@ [[buffer(%d)]]
, constant %@& %@ [[buffer(%d)]]
, %@ %@ [[texture(%d)]]
, %@<float> %@ [[texture(%d)]]
, %@ %@ [[sampler(%d)]]
v32@?0@"NSString"8@"NSString"16^c24
%@%@
C3D-OpenSubdiv.metal
scn_metal
scn_util.h
scn_lighting.h
scn_standard_constants.h
C3D-PBR.metal
USE_VERTEX_EXTRA_ARGUMENTS
USE_FRAGMENT_EXTRA_ARGUMENTS
USE_SHADER_MODIFIERS
METAL
////////////////////////////////////////////////
// CommonProfile Shader v%d
USE_SPECULAR
USE_VIEW
USE_SHININESS
USE_PBR
, constant float4* u_shadowKernel [[buffer(%d)]]
USE_FOG
USE_POSITION
USE_SSAO
USE_FRESNEL
USE_NORMAL
AVOID_OVERLIGHTING
USE_AMBIENT_LIGHTING
USE_PROBES_LIGHTING
USE_LIGHTING
USE_PER_PIXEL_LIGHTING
USE_MODULATE
USE_PER_VERTEX_LIGHTING
HAS_NORMAL
HAS_VERTEX_COLOR
USE_VERTEX_COLOR
USE_INSTANCING
USE_POINT_RENDERING
DISABLE_LINEAR_RENDERING
USE_SKINNING
MAX_BONE_INFLUENCES
USE_MOTIONBLUR
USE_OUTLINE
USE_MODELTRANSFORM
USE_AMBIENT_AS_AMBIENTOCCLUSION
USE_TANGENT
USE_BITANGENT
USE_TRANSPARENT
USE_TRANSPARENCY_RGBZERO
LOCK_AMBIENT_WITH_DIFFUSE
USE_DOUBLE_SIDED
USE_TRANSPARENCY
USE_NODE_OPACITY
DIFFUSE_PREMULTIPLIED
    float2 %@Texcoord;
    _surface.%@Texcoord = in.texcoord%d;
USE_DISCARD
USE_MODELVIEWTRANSFORM
USE_MODELVIEWPROJECTIONTRANSFORM
USE_NORMALTRANSFORM
USE_SURFACE_EXTRA_DECL
USE_EXTRA_VARYINGS
USE_TESSELATION
scn_tesselation.h
TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE
TESSELLATION_SMOOTHING_MODE_PHONG
Error: cannot handle more than one lighting modifier
USE_GEOMETRY_MODIFIER
USE_SURFACE_MODIFIER
USE_FRAGMENT_MODIFIER
Error: only support one modifier per entrypoint (count=%d). 
Error: Invalid shader modifier : no code provided
scn_node.
USE_
v32@?0@"NSString"8@16^c24
    SCNShaderLight _light;
    _light.intensity = float4(1.);
    float4 color%d;
    _light.intensity = scn_lights.color%d * %f;
    _light.intensity = scn_lights.color%d;
    float4 direction%d;
    _light.direction = scn_lights.direction%d.xyz;
    float4 position%d;
    float3 _D = scn_lights.position%d.xyz - _surface.position;
    _light._att = scn_pbr_distanceAttenuation(_D);
    _light.direction = normalize(_D);
    _light._distance = length(_D);
    _light.direction = _D / _light._distance;
    _light.direction = normalize(scn_lights.position%d.xyz - _surface.position);
    _light._spotDirection = scn_lights.direction%d.xyz;
//Unsupported
    _light._att = 1.;
    float4 attenuation%d;
    float3 _att = scn_lights.attenuation%d.xyz;
    float4 spotAttenuation%d;
    float3 _spot = scn_lights.spotAttenuation%d.xyz;
, depth2d_array<float> u_shadowTexture%d [[texture(%d)]]
, depth2d<float> u_shadowTexture%d [[texture(%d)]]
    float4x4 shadowMatrix%d[%d];
    float4x4 shadowMatrix%d;
    float4 shadowColor%d;
    float4 _shDebug = ComputeCascadedShadowDebug(_surface.position, &scn_lights.shadowMatrix%d[0], %d, u_shadowTexture%d, %s, 0.1f);
    float _shadowingTerm = _shDebug.a;
    _surface.diffuse.rgb = mix(_shDebug.rgb, _surface.diffuse.rgb, 0.5f);
    float shadowRadius%d;
    float _shadowingTerm = ComputeCascadedSoftShadow(_surface.position, &scn_lights.shadowMatrix%d[0], %d, u_shadowTexture%d, %s, 0.1f, u_shadowKernel, %d, scn_lights.shadowRadius%d);
    float _shadowingTerm = ComputeBlendedCascadedShadow(_surface.position, &scn_lights.shadowMatrix%d[0], %d, u_shadowTexture%d, 0.1f);
    float _shadowingTerm = ComputeCascadedShadow(_surface.position, &scn_lights.shadowMatrix%d[0], %d, u_shadowTexture%d);
    float _shadowingTerm = ComputeSoftShadow(_surface.position, scn_lights.shadowMatrix%d, u_shadowTexture%u, u_shadowKernel, %d, scn_lights.shadowRadius%d);
    float _shadowingTerm = ComputeShadow(_surface.position, scn_lights.shadowMatrix%d, u_shadowTexture%u);
    _light._att *= (1. - _shadowingTerm * scn_lights.shadowColor%d.a);
    _light._att *= (1. - _shadowingTerm);
, texture2d<float> u_goboTexture%d [[texture(%d)]]
, sampler u_goboTexture%dSampler [[sampler(%d)]]
    float4x4 goboMatrix%d;
    float4 projectorColor%d;
    _light.intensity *= mix(float4(1.), texture2DProj(u_goboTexture%d, u_goboTexture%dSampler, (scn_lights.goboMatrix%d * float4(_surface.position, 1.))), scn_lights.projectorColor%d.a);
    _light.intensity *= scn_lights.projectorColor%d.a * texture2DProj(u_goboTexture%d, u_goboTexture%dSampler, (scn_lights.goboMatrix%d * float4(_surface.position, 1.)));
, texture2d<float> u_iesTexture%d [[texture(%d)]]
, sampler u_iesTexture%dSampler [[sampler(%d)]]
    _light.intensity *= u_iesTexture%d.sample(u_iesTexture%dSampler, float2(acos(dot(_light.direction, _light._spotDirection))*_spot.x,0.)).r;
    float4 up%d;
    float4 right%d;
 float vertAngle = acos(dot(_light.direction, _light._spotDirection));
 float3 surfaceRay = _surface.position-scn_lights.position%d.xyz;
 float3 projPos = normalize(surfaceRay - dot(surfaceRay,_light._spotDirection)*_light._spotDirection);
 float2 texCoord = float2(dot(projPos,scn_lights.right%d.xyz),dot(projPos,scn_lights.up%d.xyz))*vertAngle*_spot.x;
_light.intensity *= u_iesTexture%d.sample(u_iesTexture%dSampler, texCoord*0.5+0.5).r;
, texturecube<float> u_iesTexture%d [[texture(%d)]]
    float4x4 iesMatrix%d;
_light.intensity *= u_iesTexture%d.sample(u_iesTexture%dSampler, (scn_lights.iesMatrix%d * float4(_surface.position, 1.)).xyz).r;
    _light.intensity = 0;
    _lightingContribution.modulate *= _light._att * _light.intensity.rgb;
    _light._att *= step(_light._distance, _att.x);
    _light._att *= saturate(_light._distance * _att.x + _att.y);
    float _dstatt = saturate(_light._distance * _att.x + _att.y);
    _light._att *= (_dstatt  * _dstatt);
    _light._att *= pow(saturate(_light._distance * _att.x + _att.y), _att.z);
    _light._att *= step(_spot.x, dot(_light.direction, _light._spotDirection));
    _light._att *= saturate(dot(_light.direction, _light._spotDirection) * _spot.x + _spot.y);
    float _sptatt = saturate(dot(_light.direction, _light._spotDirection) * _spot.x + _spot.y);
    _light._att *= _sptatt * _sptatt;
    _light._att *= pow(saturate(dot(_light.direction, _light._spotDirection) * _spot.x + _spot.y), _spot.z);
    scn_pbr_lightingContribution(_surface, _light, scn_frame, _lightingContribution.diffuse, _lightingContribution.specular);
    _light.intensity.rgb *= _light._att * max(0.f, dot(_surface.normal, _light.direction));
    _lightingContribution.diffuse += _light.intensity.rgb;
    float3 _R = reflect(-_light.direction, _surface.normal);
    _lightingContribution.specular += pow(max(0.0, dot(_R, _surface.view)), _surface.shininess) * _light.intensity.rgb;
    float3 _halfVector = normalize(_light.direction + _surface.view);
    _lightingContribution.specular += pow(max(0.0, dot(_surface.normal, _halfVector)), _surface.shininess) * _light.intensity.rgb;
float2 _%@Texcoord = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;
float2 _%@Texcoord = _geometry.texcoords[%d].xy;
float2 texcoord%d;
out.texcoord%d = (scn_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;
out.texcoord%d = _geometry.texcoords[%d].xy;
USE_TEXCOORD
TEXTURE_TRANSFORM_COUNT
kSCNTexcoordCount
NEED_IN_TEXCOORD0
NEED_IN_TEXCOORD1
NEED_IN_TEXCOORD2
NEED_IN_TEXCOORD3
NEED_IN_TEXCOORD4
NEED_IN_TEXCOORD5
NEED_IN_TEXCOORD6
NEED_IN_TEXCOORD7
Warning: FOUND an edge shared by more than 2 triangles
Error: _edgeIndexInTriangle error: can't find edge
Error: _C3DChooseFirstTriangle error
initFromPath
geometryData
mappingChannelsCount
mappingCountChannel0
vertexCount
componentsPerValue
componentsType
valuesCount
data
kGeometrySourceSemanticVertex
kGeometrySourceSemanticNormal
kGeometrySourceSemanticColor
kGeometrySourceSemanticTexcoord
stride
offset
padding
sourceID
sourceTypeID
vertex
position
normal
textangent
texbinormal
joints
weights
vertexArrayID
elementsID
commonProfile
Apple Engine
geometryID
materialsID
facesCount
kAnimationsKey
kBindingsKey
kActionsKey
kLightKey
kSkinnerKey
kMorpherKey
kCameraKey
kSplineKey
kConstraints
kParticleSystem
kAudioPlayer
kLightmapInfoKey
kRenderingPriorityKey
kShaderModifiers
kPivotKey
libraryStorage
kMeshKey
rendererDelegate
kFilterKey
kTechniqueKey
kFloorPass
geometry
geometryElement
geometryElements
geometryVertexArray
geometrySource
genericSource
node
material
effect
keyframedAnimations
camera
light
skin
morph
linear
easeIn
easeOut
easeInEaseOut
default
kSupportsWrapModes
kTextureUnit
function
avoidsOverlighting
double sided
cullMode
cullBack
cullFront
constant
lambert
phong
blinn
physicallyBased
filter
ambientOcclusion
selfIllumination
metalness
roughness
displacement
emissionColor
ambientColor
diffuseColor
specularColor
reflectiveColor
transparentColor
normalColor
filterColor
emissionImageID
ambientImageID
diffuseImageID
specularImageID
reflectiveImageID
transparentImageID
filterImageID
normalImageID
shininessImageID
emissionTextureSampler
ambientTextureSampler
diffuseTextureSampler
specularTextureSampler
reflectiveTextureSampler
transparentTextureSampler
filterTextureSampler
normalTextureSampler
shininessTextureSampler
emissionUVSet
ambientUVSet
diffuseUVSet
specularUVSet
reflectiveUVSet
transparentUVSet
normalUVSet
filterUVSet
shininessUVSet
ambientOcclusionUVSet
selfIlluminationUVSet
metalnessUVSet
roughnessUVSet
displacementUVSet
shininess
reflectivity
transparency
indexOfRefraction
fresnelExponent
transparencyMode
A_ONE
RGB_ZERO
minFilter
magFilter
mipFilter
wrapS
wrapT
wrapP
imageType
textureType
anisotropy
SCNKitErrorDomain
mipmaping
env-mapping
SMAA
SSAO
SSAOParameters
frustumCulling
defaultLight
defaultCamera
probeRendering
pointOfView
rootNode
mirrorNode
floorNode
doClear
noJittering
renderInColorBuffer
frameHistoryCount
ignoreInfiniteFloor
combineRGBParameter
factor
mult
multfloat
pass-program
programName
kHitTestFirstFoundOnly
kHitTestSearchMode
kHitTestSortResults
kHitTestClipToZRange
kHitTestSkipTransparentNode
kHitTestSkipHiddenNode
kHitTestCategoryBitMask
kHitTestBackFaceCulling
kHitTestBoundingBoxOnly
kHitTestIgnoreChildNodes
kHitTestRootNode
kHitTestAllLayers
kC3DNotificationMeshSourceWillDie
kC3DNotificationMeshElementWillDie
kC3DNotificationImageWillDie
kC3DNotificationImageProxyWillDie
kC3DNotificationTextureSamplerWillDie
kC3DNotificationProgramWillDie
kC3DNotificationGeometryWillDie
kC3DNotificationMorphWillDie
kC3DNotificationSkinWillDie
kC3DNotificationMaterialWillDie
kC3DNotificationMeshWillDie
kC3DNotificationNodeWillDie
kC3DNotificationPassWillDie
kC3DNotificationEngineContextInvalidatePasses
kC3DNotificationEngineContextPassesDidUpdate
kC3DNotificationEngineContextReloadShaders
kC3DNotificationProfileWillDie
kC3DNotificationProfileDidDie
kC3DNotificationEntityAttributeDidChange
kC3DNotificationRendererElementWillDie
kC3DNotificationRendererElementProgramHashCodeWillDie
kC3DSceneDidUpdateNotification
transform
hidden
attributes
matrix
translation
orientation
scale
eulerAngles
quaternion
pivot
filters
dofIntensity
focalSize
apertureBladeCount
xFov
yFov
projectionTransform
firstMaterial
selfIlluminationOcclusion
lockAmbientWithDiffuse
contents
contentsTransform
borderColor
shadowColor
gobo
spotFalloffExponent
morpher
shaderModifiers
background
environment
customProperty
a_position
a_normal
a_tangent
a_color
a_skinningJoints
a_skinningWeights
a_texCoord0
a_texCoord1
a_texCoord2
a_texCoord3
a_texCoord4
a_texCoord5
a_texCoord6
a_texCoord7
%f %f %f
%f %f %f %f
vertexCrease
edgeCrease
Error: Morph: target vertex count do not match base vertex count (%d != %d)
Error: mismatch in the sources given
Error: MeshSource packing only supports non interleaved float sources
Error: Conversion from other types than float is not supported
Error: Conversion of an interleaved source is not supported, please convert your sources before interleaving
Error: C3DMeshSourceCreateCopyWithComponentsBaseType: unsupported type
Error: Conversion from %@ to %@ to is not supported
Warning: Unknown semantic %@
%4d : %3d %3d %3d %3d
%4d : %+.2f %+.2f
%4d : %+.2f %+.2f %+.2f
%4d : %+.2f %+.2f %+.2f %+.2f
type debugging not implemented
C3DMeshSource
<C3DMeshSource %p(%@) data:(%p) mut:%d count:%ld type:%@ divisor:%d mtl:%d offset:%d stride:%d
Error: no meshSource deserialize => semantic in mesh source
mkSemantic
Error: _C3DMeshSourceCopyPropertyList unsupported semantic
accessor
v16@?0^{__C3DRenderTarget={__CFRuntimeBase=QAQ}{?=CCCb1b1b1b1b1[4C]}^{__C3DTexture}Iq^vQIII}8
C3DFramebufferRegistry
<C3DFramebufferRegistry>
(null)
v24@?0q8r^v16
Warning: fail to setup the animation - won't be added to the animation stack
v16@?0^{__C3DAnimationNode={__CFRuntimeBase=QAQ}^{__C3DAnimation}^{__C3DModelTarget}^{__CFArray}^{__C3DAnimationNode}ffffffffdddd^{?}cb1b1b1b1b1b1b1b1b1b1b1b1b1b4b4b1b1d^{__CFString}^vqq^{__C3DAnimationNode}^{__C3DAnimationNode}^{__C3DAnimationManager}^{__C3DAnimationPlayer}^v{?=^?}}8
v32@?0@8Q16^c24
Error: unable to resolve target keypath: %@(%@)
Error: unable to resolve source keypath: %@(%@)
Error: trying to bind two incompatible keypath: %@(%@) -> %@(%@)
c32@?0@8Q16^c24
C3DAnimationManager
<C3DAnimationManager %p>
Error: _resolveAnimationGroupTargets - can't find common ancessor
Error: C3DKeyframeControllerSetKeyframeAtIndex - time is NaN
Error: C3DKeyframeControllerRef - index out of bounds
Warning: can't simplify keyframes because of cubic interpolation
Warning: can't simplify keyframes because of tcb values
Warning: can't simplify keyframes because of timing functions
C3DKeyframeController
<C3DKeyframeController %p>
keyframeVersion
keyframeType
keyCount
keyframes
keytimes
keytimes-data
Error: failed to deserialize animation data
values
values-data
timingFunctions
timingFunctions-data
interpolationModes
interpolationModes-data
tensionValues
tensionValues-data
continuityValues
continuityValues-data
biasValues
biasValues-data
inTangents
inTangents-data
outTangents
outTangents-data
interpolationMode
calculationMode
Error: _C3DKeyframeControllerFlattenKeyframeData unexpected value
Error: _C3DKeyframeControllerCreateKeyframeArray unknown key type
0.12
Warning: _C3DKeyDistance - can't compute key distance for type %d
C3D-wireframe
ManipulatorWireframe_vert
ManipulatorWireframe_frag
Error: Cannot append manipulator vertex data because we encountered an overflow and we are not allowed to flush
Sources
Elements
Textures
Uniforms
C3DAuthoringEnvironmentDrawStats
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DKit/authoring/SCNAuthoringEnvironment.m
rendererContext
SceneKit - Draw Statistics
Draw Statistics
v32@?0^q8^{CGSize=dd}16^^{?}24
v24@?0{CGSize=dd}8
Animations
Physics
Constraints
Particles
Delegate
Rendering
WaitDrawable
GL flush
--- ms
%2.1f s
%2.1f ms
BGRA8Unorm_sRGB
BGRA8Unorm
RGBA16Float
unknown
$4$ %@  $5$ %@
Mt %dfps
GL %dfps
sceneRenderer
T@"<SCNSceneRenderer>",R
selectedNodes
T@"NSArray",R,N
selectionIsReadonly
Tc,N
selecting
Tc,R,N
manipulator
T@"SCNManipulator",R,N
shouldSnapOnGrid
Tc,N,V_shouldSnapOnGrid
shouldSnapToAlign
Tc,N,V_shouldSnapToAlign
graphicalSelectionEnabled
Tc,N,V_graphicalSelectionEnabled
surroundToSelect
Tc,N,V_surroundToSelect
authoringDisplayMask
Tq,N
gridUnit
Td,R,N,V_gridUnit
editingSpace
Tq,N,V_editingSpace
viewMatrix
T{CATransform3D=dddddddddddddddd},R,N
delegate
T@"<SCNAuthoringEnvironmentDelegate>",W,N,V_delegate
C3DManipulatorColorAndTexture
C3DManipulatorColorOnly
C3DManipulator
C3DManipulatorLightProbe
ManipulatorColorAndTexture_vert
ManipulatorColorAndTexture_frag
ManipulatorColorOnly_vert
ManipulatorColorOnly_frag
Manipulator_vert
Manipulator_frag
ManipulatorLightProbe_vert
ManipulatorLightProbe_frag
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
Error: Unable to create context
Menlo
Menlo-Bold
%2.1fms
%zuB
%.3gKB
%.3gMB
%.3gGB
%.3gK
%.3gM
%.3gG
AuthEnvDraw
u_color
u_transform
u_sampler
AuthEnvDrawTEXTURED
C3DTimingFunction
<C3DTimingFunction>
v16@?0d8
Error: didAddToPhysicsWorld - can't share a physics behavior to multiple world
Warning: Character should already have a body
velocity
Td,N
jumpSpeed
com.apple.SceneKit.resourceCPUQueue
FrameConstant
Volatile
DefaultSamplerState
DefaultDepthStencilState
background_2D_vertid
background_2D_frag
background_cube_vertid
background_cube_frag
background_video_vertid
background_video_frag
Clear binding points
SceneKit render command buffer
Warning: Failed getting a valid drawable. Skipping this frame.
-[SCNRenderContextMetal _setupDescriptor:forPass:parameters:]
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/NewRenderer/SCNRenderContextMetal.mm
renderSize.x != 0 || fbDesc->viewportDependant
renderSize.y != 0 || fbDesc->viewportDependant
scn_depthbuffer
v16@?0@"<MTLBuffer>"8
LightingSet: uploaded count: %d
  LightingSet: uploaded size %d bytes
SceneKit - Draw scene background
SceneKit - Draw video background
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8^{__C3DLightRuntimeData=If[4{?=[4]}]^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}16
Error: Motion blur pass: no camera
SceneKit - Draw wireframe
modelTransform
v28@?0^v8I16@"SCNRenderContextMetal"20
inverseModelTransform
modelViewTransform
lightIndices
inverseModelViewTransform
normalTransform
modelViewProjectionTransform
lastFrameModelViewProjectionTransform
motionBlurIntensity
inverseModelViewProjectionTransform
boundingBox
worldBoundingBox
nodeOpacity
orientationPreserved
shCoefficients
skinningJointMatrices
v24@?0@"SCNMTLResourceBinding"8@"SCNRenderContextMetal"16
scn_lights
scn_skinningJointMatrices
scn_shCoefficients
scn_commonprofile
scn_pointSize
u_shadowKernel
shadowKernel
v28@?0c8@"SCNMTLResourceBinding"12@"SCNRenderContextMetal"20
u_%@Texture
u_reflectiveCubeTexture
u_shadowTexture%d
u_goboTexture%d
u_iesTexture%d
u_iesCubeTexture%d
color%d
position%d
direction%d
right%d
up%d
iesMatrix%d
attenuation%d
spotAttenuation%d
shadowMatrix%d
shadowRadius%d
shadowColor%d
goboMatrix%d
projectorColor%d
u_specularDFGTexture
u_radianceTexture
u_irradianceTexture
u_ssaoTexture
ssao-target
v32@?0@"SCNBufferBinding"8@"MTLArgument"16@"SCNMTLShaderBindingsGenerator"24
ds_debug_vert
ds_debug_frag
ds_dir_vert
ds_light_frag
ds_omni_vert
ds_omni_frag
ds_spot_vert
ds_spot_frag
deferred_light_pass
gBuffer0
gBuffer1
gBuffer2
gBuffer3
ds_omni_debug_vert
ds_omni_debug_frag
ds_spot_debug_vert
ds_spot_debug_frag
Rendering light (type: %d)
SceneKit compute command buffer
quad_vertex
quad_display_cube
quad_display_texture2D
quad_display_depth2D
scn_draw_quad_fragment_sk
scn_draw_quad_fragment
scn_supersampling_vertex
scn_supersampling_fragment
SuperSampling
SpriteKit - Overlay Render
SpriteKit - Background Render
SpriteKit - NonLinear Encoding
device
T@"<MTLDevice>",R,N
engineContext
T^{__C3DEngineContext=},R,N
textureTarget
T@"<MTLTexture>",R,N
resourceQueue
T@"NSObject<OS_dispatch_queue>",R,N
resourceGroup
T@"NSObject<OS_dispatch_group>",R,N
clientRenderPassDescriptor
T@"MTLRenderPassDescriptor",&,N,V_clientRenderPassDescriptor
clientRenderCommandEncoder
T@"<MTLRenderCommandEncoder>",&,N,V_clientRenderCommandEncoder
clientCommandBuffer
T@"<MTLCommandBuffer>",&,N,V_clientCommandBuffer
commandQueue
T@"<MTLCommandQueue>",&,N
frameConstantBufferPool
T^v,R,N
resourceManager
T@"SCNMetalResourceManager",R,N
Error: C3DEngineContextRenderTechnique - unknown draw instruction
Error: can not render without programs, using default
Error: _executeProgram - no pipeline state
Warning: renderTarget %@ should be valid - or maybe passes are disabled?
Error: pass has no storage for input %@
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8*16
Error: binding is broken : neither block or semantic
SceneKit-spotShadowDepth-%p
SceneKit-spotShadowDepth
^{__CFString=}16@?0^{__CFString=}8
C3DFXDeferredShadowPass.json
C3DFXForwardShadowPass.json
SceneKit_renderSceneFromLight
SceneKit_applyDeferredShadows
--ShadowMaterial--
Error: _initializeRenderFromLightPass - no light
Error: _initializeDeferredShadows - no light
lightDepthSampler
cascadeCount
sampleCount
cascadeBlending
debugCascades
deferredShadow_vert
deferredShadowCascades_frag
deferredShadow_frag
C3D-spotShadow
#define MAX_SAMPLE %d
#define unshareIndex %d
#define SPOT_SHADOW 1
#define USE_PCF 1
Error: _willExecuteDeferredShadows - no light
C3D-u_lightPos-symbol
C3D-u_lightDir-symbol
C3D-u_lightSpotAtt-symbol
C3D-light_MVP-symbol
C3D-shadowCascadeSplit-symbol
C3D-shadowCascadeDebugFactor-symbol
C3D-camera_MVP_i-symbol
C3D-shadowRadius-symbol
C3D-shadowColor-symbol
Error: _setupDeferredShadows - no light
C3D-shadowKernel-symbol
C3DKeyframedAnimation
<C3DKeyframedAnimation>
keyframeController
Error: _C3DKeyframedAnimationInitWithPropertyList plist invalid
keyframedAnimation
C3DAnimationNode
<C3DAnimationNode %p>
C3DAnimationClusterNode
<C3DAnimationClusterNode %p>
script
JSContext
elapsedTime
Position
Angle
RotationAxis
Velocity
AngularVelocity
Life
Color
Opacity
Size
Frame
FrameRate
Bounce
Friction
Charge
ContactPoint
ContactNormal
Error: can't set a property (%s::%d) on the presentation instance %@ - ignoring
-[SCNParticleSystem setName:]
%p-%d
Error: attempt to add a null animation player on %@
Error: attempt to add a null animation on %@
animations.%@.speed
scnp
failed to unarchive particle data at %@ (%@)
root
-[SCNParticleSystem setParticleGeometries:]
-[SCNParticleSystem setColliderNodes:]
-[SCNParticleSystem setPropertyControllers:]
-[SCNParticleSystem setParticleImage:]
-[SCNParticleSystem _setParticleImagePath:withResolvedPath:]
-[SCNParticleSystem setOrientationDirection:]
orientationDirection
-[SCNParticleSystem setAffectedByGravity:]
affectedByGravity
-[SCNParticleSystem setAffectedByPhysicsFields:]
-[SCNParticleSystem setBirthDirection:]
-[SCNParticleSystem setBirthLocation:]
-[SCNParticleSystem setBirthRate:]
birthRate
-[SCNParticleSystem setBirthRateVariation:]
birthRateVariation
-[SCNParticleSystem setBlackPassEnabled:]
-[SCNParticleSystem setBlendMode:]
-[SCNParticleSystem setDampingFactor:]
dampingFactor
-[SCNParticleSystem setEmissionDuration:]
emissionDuration
-[SCNParticleSystem setEmissionDurationVariation:]
emissionDurationVariation
-[SCNParticleSystem setEmitterShape:]
-[SCNParticleSystem setFixedTimeStep:]
fixedTimeStep
-[SCNParticleSystem setFresnelExponent:]
-[SCNParticleSystem setIdleDuration:]
idleDuration
-[SCNParticleSystem setIdleDurationVariation:]
idleDurationVariation
-[SCNParticleSystem setImageSequenceAnimationMode:]
-[SCNParticleSystem setImageSequenceColumnCount:]
imageSequenceColumnCount
-[SCNParticleSystem setImageSequenceFrameRate:]
imageSequenceFrameRate
-[SCNParticleSystem setImageSequenceFrameRateVariation:]
imageSequenceFrameRateVariation
-[SCNParticleSystem setImageSequenceInitialFrame:]
imageSequenceInitialFrame
-[SCNParticleSystem setImageSequenceInitialFrameVariation:]
imageSequenceInitialFrameVariation
-[SCNParticleSystem setImageSequenceRowCount:]
imageSequenceRowCount
-[SCNParticleSystem setIsLocal:]
isLocal
-[SCNParticleSystem setLightingEnabled:]
-[SCNParticleSystem setLoops:]
loops
-[SCNParticleSystem setOrientationMode:]
-[SCNParticleSystem setParticleAngle:]
particleAngle
-[SCNParticleSystem setParticleAngleVariation:]
particleAngleVariation
-[SCNParticleSystem setParticleAngularVelocity:]
particleAngularVelocity
-[SCNParticleSystem setParticleAngularVelocityVariation:]
particleAngularVelocityVariation
-[SCNParticleSystem setParticleBounce:]
particleBounce
-[SCNParticleSystem setParticleBounceVariation:]
particleBounceVariation
-[SCNParticleSystem setParticleCharge:]
particleCharge
-[SCNParticleSystem setParticleChargeVariation:]
particleChargeVariation
-[SCNParticleSystem setParticleColor:]
particleColor
-[SCNParticleSystem setParticleDiesOnCollision:]
-[SCNParticleSystem setParticleFriction:]
particleFriction
-[SCNParticleSystem setParticleFrictionVariation:]
particleFrictionVariation
-[SCNParticleSystem setParticleLifeSpan:]
particleLifeSpan
-[SCNParticleSystem setParticleLifeSpanVariation:]
particleLifeSpanVariation
-[SCNParticleSystem setParticleMass:]
particleMass
-[SCNParticleSystem setParticleMassVariation:]
particleMassVariation
-[SCNParticleSystem setParticleSize:]
particleSize
-[SCNParticleSystem setParticleSizeVariation:]
particleSizeVariation
-[SCNParticleSystem setParticleVelocity:]
particleVelocity
-[SCNParticleSystem setParticleVelocityVariation:]
particleVelocityVariation
-[SCNParticleSystem setPhysicsCollisionsEnabled:]
-[SCNParticleSystem setRenderingMode:]
-[SCNParticleSystem setSeed:]
-[SCNParticleSystem setSoftParticlesEnabled:]
-[SCNParticleSystem setSortingMode:]
-[SCNParticleSystem setSpeedFactor:]
speedFactor
-[SCNParticleSystem setSpreadingAngle:]
spreadingAngle
-[SCNParticleSystem setStretchFactor:]
stretchFactor
-[SCNParticleSystem setSystemSpawnedOnCollision:]
-[SCNParticleSystem setSystemSpawnedOnDying:]
-[SCNParticleSystem setSystemSpawnedOnLiving:]
-[SCNParticleSystem setWarmupDuration:]
warmupDuration
-[SCNParticleSystem setParticleIntensity:]
particleIntensity
-[SCNParticleSystem setParticleIntensityVariation:]
particleIntensityVariation
-[SCNParticleSystem setParticleColorVariation:]
particleColorVariation
-[SCNParticleSystem setEmittingDirection:]
emittingDirection
-[SCNParticleSystem setAcceleration:]
acceleration
particleImage
referenceName
emitterShape
birthLocation
birthDirection
affectedByPhysicsFields
physicsCollisionsEnabled
lightingEnabled
softParticlesEnabled
particleDiesOnCollision
blackPassEnabled
systemSpawnedOnCollision
systemSpawnedOnDying
systemSpawnedOnLiving
seed
blendMode
renderingMode
orientationMode
imageSequenceAnimationMode
particleGeometries
colliderNodes
propertyControllers
sortingMode
Error: referenced particle systems can't be resolved without a SCNAssetCatalog
Error: particle reference name is nil
supportsSecureCoding
Tc,R
animationKeys
T@"NSArray",R
T@"SCNGeometry",&,N
T{SCNVector3=ddd},N
local
Tc,N,GisLocal
T@"SCNParticleSystem",&,N
TQ,N
T@"NSColor",&,N
T{SCNVector4=dddd},N
Tc,N,GisBlackPassEnabled
Tc,N,GisLightingEnabled
T@"NSArray",C,N
T@"NSDictionary",C,N
Error: animation class %@ is not supported for particle systems
Error: Can't introspect type of property %@
Error: unknown particle controller input mode
Error: Cannot build cubemap from array of images because image at index %d is NULL
Error: Cannot build cubemap from array of images because image at index %d is not square: %fx%f
Error: Cannot build cubemap from array of images because image at index %d (%fx%f) does not have the expected size (%zux%zu)
Error: Cannot build cubemap from array of images because conversion to CGImageRef of image at index %d failed
Error: Cannot build column cubemap from non-cubemap image
Warning: Failed to create bitmap context for CG image %@
missingMaterialImage
Info: FixIncorrectPremultiply %@ time %u x %u : %fms
Error: Unknown cubemap image type
Error: Cannot support rotation layout for compressed texture
Error: Unknown Texture3D image type
isAttachment
C3DImage
<C3DImage %p src:%@ [%fx%f]>
<C3DImage %p src:%p [%fx%f]>
imageData
imageRelativePath
distantImageURL
Error: failed to load image with description: %@
Warning: serialize C3DImage: empty image
file
Error: _C3DImageCopyPropertyList error retrieving path
cgImage
clientImage
bitmap
hasAlpha
size
Error: Failed loading : %@
Error: unable to get a CGImageRef from image
SCNRendererOptions
~/%@-snapshot-%d.scn
archiving to %@
c24@?0@"SCNNode"8^c16
untitled
%.1f fps
tiff
v24@?0@"SCNNode"8^c16
Scene
[Root node]
<No name>
view
T@"SCNView",&,N
minificationFilter
magnificationFilter
%f %f %f %f
maxAnisotropy
C3DTextureSampler
<C3DTextureSampler>
Warning: While reading a texture sampler: could not read %@ (serializedData: %@), using the default value %d instead
Error: Could not serialize an integer
nearest
clamp
repeat
clampToBorder
collisionBitMask
results
backfaceCulling
closest
ccdPenetration
Error: convexSweep only works with convex shapes
behaviors
gravity
speed
timeStep
contactDelegate
T@"<SCNPhysicsContactDelegate>"
allBehaviors
Warning: PhysicsWarn: %s
Resource Manager Flush
C3D-EnvMap2D
textureSampler0
u_textureMatrix
C3D-EnvMapCube
u_mvp
u_zfar
C3DEngineContext
<C3DEngineContext>
C3DConvexPolyhedron
<C3DConvexPolyhedron %p>
Error: unsupported conversion %@ -> float4
NSScreenNumber
Format: %@ ; Size: %gx%g[%d] ; Texture: <%p> ; [rc:%ld/ts:%ld]
Name: %@ ; %@
T@,&,N,V_texture
T@"NSString",C,N,V_name
referenceCount
Tq,N,V_referenceCount
timeStamp
Tq,N,V_timeStamp
viewportDependant
renderBufferFormat
TC,R,N
<%@: %p | scene=%@ sceneTime=%f frame=%@ pointOfView=%@>
Error: SCNLayer::copyCGLPixelFormatForDisplayMask -> unable to find a valid pixel format
Error: copyCGLContextForPixelFormat: cannot create context error %d
sceneTime
playing
autoenablesDefaultLighting
jitteringEnabled
technique
renderer.%@
T@"SCNScene",&,N
T@"<SCNSceneRendererDelegate>",N
Tc,GisPlaying
T@"SCNNode",&,N
Tc,N,GisJitteringEnabled
showsStatistics
debugOptions
overlaySKScene
T@"SKScene",&,N
renderingAPI
TQ,R,N
context
currentRenderCommandEncoder
T@"<MTLRenderCommandEncoder>",R,N
colorPixelFormat
depthPixelFormat
stencilPixelFormat
T@"<MTLCommandQueue>",R,N
audioEngine
T@"AVAudioEngine",R,N
audioEnvironmentNode
T@"AVAudioEnvironmentNode",R,N
audioListener
currentTime
T@"SCNTechnique",C,N
C3DRendererElementStateBeginProcessing
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/AppleEngine/C3DRendererElementState.c
C3DRendererElementStateEndProcessing
__UpdateMatrixUniforms
C3DRendererElementStateDrawRendererElement
C3DRendererElementStateProcessRendererElement
C3DEngineContextGetRendererContext(engineContext)
C3DRendererElementState
<C3DRendererElementState>
v24@?0^{__CFString=}8^v16
C3DCreateProgram
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/AppleEngine/OpenGL/C3DGLUtils.m
Error: program failed to build:
C3DGLSLIntrospectProgramObject
Active uniforms %d for program id %d
u_%-2d location:%-2d name:%-*s type:%-12s (%d bytes)
Active attributes %d
a_%-2d location:%-2d name:%-*s type:%-12s (%d bytes)
C3DWriteFBOToDisk
_create_compile_and_attach_shader
renderer
_create_and_compile_shader
Error: Cannot compile empty shader %@
Error: %3d: %@
Error: failed to link program: %s
%3ld | %@
#version 150
#define attribute in
#define varying out
#define texture2D texture
#version 150
#define varying in
#define gl_FragColor FragColor
#define texture2D texture
out vec4 FragColor;
#version 120
^(\w+):\s[0-9]+:([0-9]+):\s(.+)$
error
C3DRendererContextSetupCommonPipeline
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/AppleEngine/OpenGL/C3DRendererContextGL.c
C3DRendererContextClear
C3DRendererContextGetEnableTexturePacking
C3DRendererContextIsEnabled
C3DRendererContextSetEnable
C3DRendererContextResetToDefaultStates
Reset all states
C3DRendererContextSetMatrix4x4UniformAtLocation
C3DRendererContextSetColor4UniformAtLocation
C3DRendererContextSetVector4UniformAtLocation
C3DRendererContextSetVector3UniformAtLocation
C3DRendererContextSetVector2UniformAtLocation
C3DRendererContextSetIntUniformAtLocation
C3DRendererContextSetInt2UniformAtLocation
C3DRendererContextSetInt3UniformAtLocation
C3DRendererContextSetInt4UniformAtLocation
C3DRendererContextSetFloatUniformAtLocation
C3DRendererContextBindProgramObject
C3DRendererContextUnbindProgramObject
C3DRendererContextSetupResidentMeshSourceAtLocation
Error: C3DRendererContextSetupResidentMeshSourceAtLocation:not handling type, using float as default
%02x
C3DRendererContextCreateProgramObjectForProgram
Error: C3DRendererContextCreateProgramObjectForProgram : missing vertex shader
Error: C3DRendererContextCreateProgramObjectForProgram : missing fragment shader
Error: C3DRendererContextCreateProgramObjectForProgram metal program unsupported
Error: C3DRendererContextCreateProgramObjectForProgram unsupported program
C3DRendererContextDeleteProgramObject
Warning: Trying to delete an empty or already released VBO
C3DRendererContextApplyTextureSampler
_C3DRendererContextComputeInternalSize
_C3DRendererContextComputeRenderBufferInternalSize
C3DRendererContextBindTexture
C3DRendererContextDeleteTexture
C3DRendererContextUpdateSubTextureWithImage
Error: error in C3DRendererUpdateSubTextureWithImage : empty bitmap
C3DRendererContextCreateTextureWithImage
Error: image copy did fail: %@
C3DCreateTextureFromIOSurface
C3DRendererContextCreateRenderTargetWithDescription
C3DRendererContextSetupFramebuffer
Error: C3DRendererContextSetupFramebuffer invoked twice on a Framebuffer
_C3DRendererContextBindFramebuffer
C3DRendererContextUnbindFramebuffer
C3DRendererContextResolveFramebuffer
_C3DRendererContextDeleteRenderBuffer
C3DRendererContextDeleteFramebuffer
C3DRendererContextSetBlendFunc
C3DRendererContextExtensionSupported
C3DRendererContextGetViewport
C3DRendererContextSetViewport
C3DRendererContextSetViewportForExternal2D
Warning: C3DRendererContextInferTextureTargetForImageTypeAndTextureSampler: called with kC3DTextureUntype type should be resolved before calling it, using GL_TEXTURE_2D as fallback
C3DRendererContextSetLight
C3DRendererContextBindCommonProfile
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead
C3DRendererContextUnbindCommonProfile
C3DRendererContextSetFrontFace
C3DRendererContextGetFrontFace
C3DRendererContextSetEnableWriteToDepth
C3DRendererContextSetEnableReadsFromDepth
C3DRendererContextAllocateBufferObject
C3DRendererContextUploadMeshSourceToBufferObject
C3DRendererContextCreateBufferObjectForMeshSource
Error: C3DRendererContextCreateBufferObjectForMeshSource - mesh source has no data
C3DRendererContextCreateBufferObjectForMeshElement
C3DRendererContextUploadMeshElementToBufferObject
C3DRendererContextUnbindTexture
C3DRendererContextUnbindTextureUnits
Error: C3DRendererContextBindMeshElement unsupported byte per index (%d)
_C3DRendererContextBindTextureGL
_C3DRendererContextUnbindTextureGL
__ReserveAndBindVolatileVBO
C3DRendererContextMapVolatileMesh
C3DRendererContextUnmapVolatileMesh
C3DRendererContextMapVolatileMeshElement
C3DRendererContextUnmapVolatileMeshElement
C3DRendererContextResetVolatileObjects
C3DRendererContextPushGroupMarker
C3DRendererContextPopGroupMarker
C3DRendererContext
<C3DRendererContext>
__FillProgramObjectLocations
Error: __FillProgramObjectLocations uniform index out of bounds
_C3DRendererContextCreateTextureWithSize
Error: bad row alignement: bpr = %d spp:%d bps:%d iPixelRowLength:%d rowAlignent:%d
Error: texture %d bits not supported
v24@?0C8^{__CFArray=}12I20
Error: Cannot load image %@.
Error: For best performance when using OpenGL, consider adding the `SCNDisableLinearSpaceRendering` and `SCNDisableWideGamut` keys with a bool value of `YES` to your app's Info.plist
v20@?0I8r*12
Error: _createTextureForRenderTarget - fbo size is zero
Error: _createRBOForRenderTargetDescription - fbo size is zero
C3DRenderContextAttachRenderTargetToFramebuffer
__drawCall
__SetupCommonProfileEffectProperty
Error: Max number of texture unit (%d) is reached - can't bind a new texture
Error: We do not handle property %d to get the program attribute enum for the texture (using default: diffuse)
C3DRendererContextDeleteVertexArrayObject
C3DBufferObject
<C3DBufferObject vbo:%ld  addr:0x%x lockCount:%d target:%d retainCount:%d>
block:%p offset:%d size:%d used:%d
free block:%p offset:%d size:%d used:%d
C3DCustomAllocator
<C3DCustomAllocator>
Error: block unknown
** dump allocator **
all blocks following head
free list ordered by size
commonprofile_frag
commonprofile_vert
commonprofile_post_tessellation_vert
standard_frag
standard_vert
standard_post_tessellation_vert
Warning: Failed to create program for hashcode %@: %@
Error: C3DCommonProfileProgramReleaseHashCode can't find cache for tracked resource
profile
Ti,R,N
USE_%@
USE_%@_COLOR
USE_%@_INTENSITY
USE_%@_TEXTURE_COMPONENT
USE_%@TEXCOORD
USE_%@_MAP
USE_%@_CUBEMAP
C3DCustomAllocatorGroup
<C3DCustomAllocatorGroup>
SceneKit-CI-nodetree-color-
SceneKit-CI-effect-color-
SceneKit_renderCINodeTree-
SceneKit-CI-nodetree-depth
SceneKit_ApplyCIFilter
SceneKit_renderCIQuad
C3D-CIFilter_middleZ
C3D-CIFilter_extent
SceneKit-CI-nodetree-color
SceneKit-CI-effect-color
SceneKit_renderCINodeTree
C3DFXCIFilterPassMetal.json
C3DFXCIFilterPass.json
NSNumber
Error: _applyCIFilter can't fint render target named SceneKit-CI-nodetree-color
Warning: CIFilter should have been clipped by the culling
Warning: CIFilter should have been clipped by the culling (2)
CICrop
inputRectangle
C3D-CIFilter_modelMatrix
C16@?0^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}8
C3DGeometryInitSubdivTopologyInfoIfNeeded
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Core/C3DGeometryOpenSubdivSupportInternal.cpp
(int32_t)vertexCountPerFaceCurrentIndex == topologyInfo->topologyDescriptor.numFaces
vertIndicesPerFaceCurrentIndex == topologyInfo->totalIndexCount
Warning: Found a mesh source with semantic '%@' and a component count of %d. Will use %d instead.
C3DSubdivCreateMesh
faceVertexIndices.size() == 4
Interpolate
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/primvarRefiner.h
level>0 && level<=(int)_refiner._refinements.size()
interpFromEdges
refinement.getNumChildVerticesFromFaces() > 0
Vtr::IndexIsValid(cVertOfFace)
interpFromVerts
vMask.AreFaceWeightsForFaceCenters()
assignSmoothMaskForVertex
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/../sdc/catmarkScheme.h
vertex.GetNumFaces() == vertex.GetNumEdges()
CombineVertexVertexMasks
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/../sdc/../sdc/scheme.h
this->AreFaceWeightsForFaceCenters() == dst.AreFaceWeightsForFaceCenters()
InterpolateVarying
InterpolateFaceVarying
interpFVarFromEdges
eFaceIndex == i
interpFVarFromVerts
pSibling == cSibling
Error: Position must be float3 to be subdivided. Actual type is %d
CreateMeshSources
faceVertexCount == 4
Failure in PrimvarRefiner::Limit() -- last level of refinement does not include full topology.
limit
tan1Mask.GetNumFaceWeights() == tan2Mask.GetNumFaceWeights()
tan1Mask.GetNumEdgeWeights() == tan2Mask.GetNumEdgeWeights()
assignSmoothLimitMask
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/../sdc/loopScheme.h
valence != 2
rgba16f
rgba32f
r16f
r32f
rg16
rg16f
rgba
framebufferColor
depth24
depth24stencil8
C3DFramebuffer
slot%d: %@ 
<C3DFramebuffer %p: color=%@ - depth=%@ color-samples=%d depth-samples=%d renderTargets:%@>
C3DMeshPacker
<C3DMeshPacker>
C3DFXMetalProgram
<C3DFXMetalProgram %p [vertex:`%@` fragment:`%@` macros:%@]>
Error: C3DRectanglePackerReleaseRect can't find rect
Error: C3DRectanglePackerReleaseRect double free
C3DRectanglePacker
<C3DRectanglePacker>
Error: mergeNodesIfPossible inconsistency
ds_default_vert_N
ds_default_frag_N
ds_default_vert
ds_default_frag
com.apple.scenekit.resourceManagerDeletionQueue
Error: C3DResourceManagerMakeProgramResident failed to compile program - fallback on default program
Error: rendererContext is not tracked by the resource manager
C3DResourceManager
<C3DResourceManager>
Error: __ResourceManagerDeleteTexture: texture to be deleted not found, bail out
Error: _C3DResourceManagerDeleteTexture source does not match to any stored texture (no texture samplers associated)
Error: _C3DResourceManagerDeleteTexture can't find image source
Warning: C3DResourceManagerMakeImageResident invalid image
Warning: single texture is larger than memory limit
kResourceManagerPendingMeshElementRemoval
kResourceManagerPendingImageRemoval
kResourceManagerPendingImageProxyRemoval
kResourceManagerPendingProgramRemoval
kResourceManagerPendingMeshRemoval
kResourceManagerPendingMeshSourceRemoval
C3DRasterizerStates
<C3DRasterizerStates %p> ZRead:%d ZWrite:%d ZFunc:%d cull:%d fill:%d
C3DTexture
<C3DTexture>
Error: failed to find a rect in packers
Error: cannot find packer address in packer list
C3DTexturePacker
<C3DTexturePacker>
Error: failed to create a new texture
C3DImageProxy
<C3DImageProxy>
C3DTextureProxy
<C3DTextureProxy>
Warning: Warning _lightNodes not NULL in C3DEnginePipelineSetup
C3DEnginePipeline
<C3DEnginePipeline %p>
Warning: C3DTriangle3BarycentricCoordinates: unable to solve the equation
Error: C3DRendererContextSetValueUniformAtLocation not implemented for this type (%d) yet
Error: uniform has incorrect type
Error: bad float x %f
Error: bad float y %f
Error: bad float z %f
Error: bad float w %f
C3DFXGLSLProgramObject
<C3DFXGLSLProgramObject %p>
Error: set transform not implemented on %@
Error: set position not implemented on %@
T@"SCNNode",&,N,Vnode
component
T@,&,N,Vcomponent
elementIndex
TQ,N,VelementIndex
T{CATransform3D=dddddddddddddddd},N
elementPosition
T{SCNVector3=ddd},R,N
com.apple.scenekit.jitteringUpdateQueue
enabled
Tc,N,GisEnabled
C3DFXProgramDelegate
<C3DFXProgramDelegate %p>
C3DPatchTypeFromOsdPatchType
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Core/C3DGeometryOpenSubdivSupport_Metal.mm
C3DPatchTypeToOsdPatchType
USE_OPENSUBDIV
OSD_PATCH_QUADS
OSD_PATCH_TRIANGLES
OSD_PATCH_REGULAR
CONTROL_POINTS_PER_PATCH
OSD_PATCH_GREGORY
OSD_PATCH_GREGORY_BASIS
OSD_PATCH_GREGORY_BOUNDARY
#include <metal_stdlib> 
struct OsdInputVertexType { 
    metal::packed_float3 position; 
    metal::packed_float2 texcoord
    metal::packed_float4 color; 
#define OSD_USER_VARYING_DECLARE                             
float2 texcoord
float4 color; 
#define OSD_USER_VARYING_DECLARE_PACKED                             
metal::packed_float2 texcoord
metal::packed_float4 color; 
#define OSD_USER_VARYING_PER_VERTEX(in, out)                 
out.texcoord
 = in.texcoord
out.color = in.color; 
#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)          
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out) 
 = mix(mix(a.texcoord
, b.texcoord
, UV.x), mix(c.texcoord
, d.texcoord
, UV.x), UV.y); 
out.color = mix(mix(a.color, b.color, UV.x), mix(c.color, d.color, UV.x), UV.y); 
#define OSD_USER_VARYING_DECLARE_ATTRIBUTE                   
 [[attribute(
)]]; 
float4 color [[attribute(
    metal::packed_float3 position; 
VERTEX_BUFFER_INDEX
PATCH_INDICES_BUFFER_INDEX
CONTROL_INDICES_BUFFER_INDEX
OSD_PATCHPARAM_BUFFER_INDEX
OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX
OSD_PERPATCHTESSFACTORS_BUFFER_INDEX
OSD_VALENCE_BUFFER_INDEX
OSD_QUADOFFSET_BUFFER_INDEX
TRANSFORMS_BUFFER_INDEX
TESSELLATION_LEVEL_BUFFER_INDEX
INDICES_BUFFER_INDEX
QUAD_TESSFACTORS_INDEX
OSD_PERPATCHVERTEXGREGORY_BUFFER_INDEX
OSD_PATCH_INDEX_BUFFER_INDEX
OSD_DRAWINDIRECT_BUFFER_INDEX
OSD_KERNELLIMIT_BUFFER_INDEX
OSD_PATCH_ENABLE_SINGLE_CREASE
OSD_FRACTIONAL_EVEN_SPACING
OSD_FRACTIONAL_ODD_SPACING
OSD_MAX_TESS_LEVEL
USE_STAGE_IN
USE_PTVS_FACTORS
USE_PTVS_SHARPNESS
THREADS_PER_THREADGROUP
CONTROL_POINTS_PER_THREAD
VERTEX_CONTROL_POINTS_PER_PATCH
OSD_MAX_VALENCE
OSD_NUM_ELEMENTS
OSD_ENABLE_BACKPATCH_CULL
OSD_USE_PATCH_INDEX_BUFFER
OSD_ENABLE_SCREENSPACE_TESSELLATION
OSD_ENABLE_PATCH_CULL
NEEDS_BARRIER
OSD_FVAR_WIDTH
OSD_FVAR_DATA_BUFFER_INDEX
OSD_FVAR_INDICES_BUFFER_INDEX
OSD_FVAR_PATCHPARAM_BUFFER_INDEX
OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX
OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING
OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING
OSD_COLOR_INTERPOLATION_MODE
OSD_TEXCOORD0_INTERPOLATION_MODE
OSD_TEXCOORD1_INTERPOLATION_MODE
OSD_TEXCOORD2_INTERPOLATION_MODE
OSD_TEXCOORD3_INTERPOLATION_MODE
OSD_TEXCOORD4_INTERPOLATION_MODE
OSD_TEXCOORD5_INTERPOLATION_MODE
OSD_TEXCOORD6_INTERPOLATION_MODE
OSD_TEXCOORD7_INTERPOLATION_MODE
OSD FVar data
OSD FVar indices
OSD FVar patch params
OSD Per-patch data
OSD Hull shader constant data
OSD Tessellation factors
Error: OSD_MAX_VALENCE is set to %d and current mesh has a max valence of %d
C3D-OpenSubdiv_compute.metal
compute_opensubdiv
scn_osd_synchronize_coarse_positions
SceneKit: Synchronize skin/morph for subdivision
SceneKit: Refine mesh
SceneKit: Compute tessellation factors for subdivision
Mesh
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/osd/../osd/mesh.h
_refiner
initializeContext
aoCoord
lightmapCoord
bitangent
Error: C3DImageToMDLTexture not supported for image 3D
Warning: Failed to create cubemap from Model I/O texture
While creating SCNSkinner: Could not find SCNNode %@
morpher.weights[%d]
SCNSceneKitAssociatedObject
c32@?0@"SCNGeometrySource"8Q16^c24
blendShape%d
normal%d
textureCoordinate%d
%@_%d
targetShapes
shapeSetTargetWeights
shapeSetTargetCounts
T@"MDLAnimatedScalarArray",R,N
jointPaths
jointBindTransforms
T@"NSData",R,N
meshBindTransform
T{?=[4]},R,N
AO_%@_%@.png
@"NSString"16@?0@"SCNNode"8
v32@?0@"SCNNode"8@"SCNGeometry"16@"NSArray"24
aoTexture
lightmapTexture
Error: unknown MKGeometryType
/tmp/ModelKit_AO_%@.png
fieldOfView
fstop
Error: a MDLObject has more than 1 child mesh - not supported
Error: failed to find MKMaterial corresponding SCNMaterial
Texture
Error: Unknown Model I/O semantic %@
Error: ranges and strings arrays must be of the same size
Error: ranges must be ordered
Error: incorrect ranges : cumulated size larger than the original string
SCNTechniqueView
SCNKitError : can't load nib named : SCNTechniqueView
T@"SCNView",&
_surface.emission.rgb = vec3(_surface.emission.a);
_surface.emission.a = 1.0;
_surface.emission.rgb *= vec3(%d.0, %d.0, %d.0);
_surface.emission.a = 1.0;
sourceContext
T@"NSOpenGLContext",&,N,V_sourceContext
C3DFXShader
<C3DFXShader %@>
source
stage
Warning: %s will return default value (false) for property %d
C3DEffectPropertyGetSemanticForColorIsRawFloatValue
C3DEffectCommonProfile
<C3DCommonProfileEffect %p : 
lightingModel : %d
perPixelLit : %d
isOpaque : %d
transparencyMode : %d
Emission
Ambient
Diffuse
Specular
Reflective
Transparent
Filter
Normal
Ambient Occlusion
Self Illumination
Metalness
Roughness
Displacement
Shininess
Reflectivity
Transparency
Fresnel
[%@] texture:%d xform:%d
versionNumber
ambientIntensity
diffuseIntensity
specularIntensity
emissionIntensity
multiplyIntensity
transparentIntensity
normalIntensity
ambientOcclusionIntensity
selfIlluminationIntensity
displacementIntensity
reflectiveIntensity
locksAmbientWithDiffuse
Error: No function %@ in the common profile %@
Error: Could not deserialize the color %@
Error: C3DEffectCommonProfile DeserializeColor: No property for the key %@
Error: Common profile deserialization: could not read the property %@
Error: Common profile deserialization: property found for the key %@
Error: Could not deserialize the texture sampler %@
Intensity
Error: Cannot find the specified image
Error: Cannot find the image ID for the key %@ in the dictionary %@
lightingModel
imagesCount
Error: orphan effect common profile detected
Warning: __OpacityFromColorSlot:unexpected transparency mode %d
C3DEffectSlot
<C3DEffectSlot>
mtltexture
imageProxy
transforms
uvSet
Info: can't set a texture component with multiple components to a SCNMaterialProperty
SCNAction: Run block actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
SCNAction: Run block actions can not be properly decoded, Objective-C blocks do not support NSSecureCoding.
threshold
thresholdType
C3DLOD
<C3DLOD>
C3DSpline
<C3DSpline %p>
Error: C3DMeshSourceAppendVector3 - Type not supported
Error: C3DMeshSourceAppendVector2 - Type not supported
Error: C3DMeshSourceAppendCopyOfElement - Type not supported
Error: C3DMeshSourceCreate: unsupported type
Error: unsupported SH order
Error: SH order unsupported : %d
Error: SphericalHarmonics Order not supported : %d
C3DLightProbesSystem
<C3DLightProbesSystem %p>
Error: _buildTetrahedrons - failed with first tetrahedron
Error: tetrahedrisation: index out of bounds
Error: C3DEdgeArrayAddEdge out of capacity
C3DEdgeArray
<C3DEdgeArray>
C3DTriangulationInfo
<C3DTriangulationInfo>
Error: C3DMeshElementEditorCreateWithMeshElement: mesh element is not a triangle array
Error: _C3DMeshElementEditorSetIndex unknown bytes per index
Error: C3DMeshElementEditorSplitTriangleAtIndex: triangleIndex out of bounds
Error: C3DMeshElementEditorSubdivideTriangleAtIndex: triangleIndex out of bounds
C3DMeshElementEditor
<C3DMeshElementEditor>
overrides
ide_
ske_
simd
Error: inconsistency - material count doesn't match - can't diff reference node
geometry.materials[%d]
Error: inconsistency - material has custom properties - can't diff reference node
particleSystems[0]
Error: inconsistency - hierarchy doesn't match - can't diff reference node
[%d]
Error: inconsistency - hierarchy changed - can't diff reference node
Error: failed to parse key path %@ - missing '['
Error: failed to parse key path %@ - missing ']'
Error: failed to evaluate key path %@ - material index %d out of bounds (%d)
v32@?0@8@16^c24
Error: failed to locate scene reference %@
SCNReferenceLoadingStack
Error: failed to resolve referenced scene (%@) cycle detected
referenceRoot
<%@: %p url=%@>
referenceURL
loadingPolicy
T@"NSURL",C,N
Tq,N,V_loadingPolicy
loaded
Tc,R,GisLoaded
referenceSceneName
T@"NSString",C,N,VreferenceSceneName
referenceNodeName
T@"NSString",C,N,VreferenceNodeName
repeatCount
repeatDuration
usesSceneTimeBase
Error: referenced animations can't be resolved without a SCNAssetCatalog
T@"NSString",C,N,VreferenceName
Error: referenced actions can't be resolved without a SCNAssetCatalog
{CATransform3D=dddddddddddddddd}
<%@: %p | scene=%@ sceneTime=%f pointOfView=%@>
Jittering is not supported on SCNMetalLayer
antialiasingMode
syncTimeWithCoreAnimation
Tc,N,V_syncTimeWithCoreAnimation
C3DAnimationPlayer
<C3DAnimationPlayer %p>
blendFactor
C3DIndexSet
indexSet 
(no index)
[number of indexes: %lu (in %lu ranges), indexes: (
-%lu
Error: Index %ld out of range bounds [0...%ld]
Error: Index %ld out of bounds [0...%ld]
T@"NSString",&,N,Vname
Ti,N,Vtype
readonly
Tc,N,Vreadonly
objectClass
T#,&,N,VobjectClass
constantToString
T@"NSDictionary",&,N,VconstantToString
%@: %@
objectController.selection%@.%@
selectedValue
vector2
vector3
vector4
matrix4
selectedIndex
%@[%d]
failed to instanciate a %@ with option %@
New %@
failed to instanciate a %@
%@.%@
objectController
T@"NSObjectController",W,N,V_objectController
stackControl
T@"NSPathControl",&,N,VstackControl
imageSequence
screenSpaceAmbientOcclusion
ssao
{CGPoint=dd}
{CGSize=dd}
{SCNVector3=ddd}
{SCNVector4=dddd}
@"NSString"
@"NSColor"
@"NSArray"
@"SCN
olor
ontent
mage
string
duration
autoreverses
additive
cumulative
isAnimationClip
removeOnCompletion
sceneTimeBased
fillModeMask
timeOffset
beginTime
fadeInDuration
fadeOutDuration
timingFunction
simpleAnimation
Error: C3DSimpleAnimationEvaluate - invalid evaluation function
C3DAnimation
<C3DAnimation>
C3DSimpleAnimation
<C3DSimpleAnimation>
baseType
Error: _C3DSimpleAnimationInitWithPropertyList - no base type
startValue
byValue
endValue
C3DLightAddLightSHContribution
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Core/C3DLight.c
C3DLight
<C3DLight %p> type:%@ IES:%d
Omni
Spot
Probe
attenuationEndDistance
attenuationStartDistance
shadowBias
temperature
property3
Error: While deserializing a light: could not decode the number for the key %@ (serializedData : %@)
property4
Error: While deserializing a light: no value for the key %@ (serializedData : %@)
castShadow
znear
zfar
shadowSoftenFactor
category
Error: While deserializing a light: could not decode the color
Error: While deserializing a light: could not decode the shadowcolor
shadowMapSize
directionalExtent
shadowMaxSampleCount
categoryBitMask
sh_eval_direction
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Math/sh_math.h
order < kSHMinOrder || order > kSHMaxOrder
sh_accumulate_omni_light
bodyA
bodyB
T@"SCNPhysicsBody",R,N
frameA
frameB
maximumAngularLimit1
maximumAngularLimit2
maximumTwistAngle
Info: invalid zNear value (0) set to camera
C3DCamera
<C3DCamera>
fStop
aspectRatio
sensorHeight
averageGray
bloomBlurRadius
bloomIntensity
bloomThreshold
colorFringeStrength
colorFringeIntensity
contrast
exposureAdaptationBrighteningSpeedFactor
exposureAdaptationDarkeningSpeedFactor
exposureAdaptationDuration
exposureAdaptationHistogramRangeHighProbability
exposureAdaptationHistogramRangeLowProbability
exposureOffset
focusDistance
focalLength
maximumExposure
minimumExposure
saturation
vignettingIntensity
vignettingPower
whitePoint
screenSpaceAmbientOcclusionIntensity
screenSpaceAmbientOcclusionRadius
screenSpaceAmbientOcclusionBias
screenSpaceAmbientOcclusionDepthThreshold
screenSpaceAmbientOcclusionNormalThreshold
screenSpaceAmbientOcclusionSampleCount
screenSpaceAmbientOcclusionDownSample
ortho
letterbox
fovHorizontal
customProj
autoZRange
xfov
yfov
xMag
bladeCount
dofSampleCount
sensorSize
Info: loaded camera has an invalid zNear value (0)
orthoScale
inputMode
inputScale
inputBias
inputOrigin
inputProperty
T@"CAAnimation",&,N
T@"SCNNode",W,N
T@"NSString",C,N
Error: Cannot get pixel buffer (CVPixelBufferRef)
Error: CVMetalTextureCacheCreateTextureFromImage failed with status %d
player
T@"AVPlayer",&,N
%s%p
 [inconsistent parent: %p != %p]
Warning: C3DNodeGetWorldMatrix - no transform tree
<no name>
C3DNode
Error: inconsistency in scene graph found in C3DNode finalize
<C3DNode:%p "%@"
  geometry: %@
  light: %@
  camera: %@
  skinner: %@
  morpher: %@
alpha
isJoint
matrix4x4
Error: Could not read a matrix (serializedData: %@)
Error: Could not read a quaternion
euler
Error: Could not read Euler
axisAngle
Error: Could not read the axis angle
Error: Could not read a matrix
Error: No data present to deserialize a rotation (serialized data : %@)
Error: Could not read a transform, position, scale and rotation have to be present (serializedData: %@)
Error: loading pivot from compressed collada file is not supported anymore - use SCN file format instead
kC3D
Error: Node deserialization: cannot retrieve the object ID
Warning: Node<->attribute inconsistency finalizing deserialization
Error: Node deserialization: cannot retrieve the lightmap image ID
Error: Node deserialization: cannot retrieve the lightmap image
firstChild
nextSibling
parent
skinner
v24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8^B16
Warning: Mesh '%@' : sources of redundant semantic '%@' will be ignored in rendering
sources
Error: Mesh deserialization: cannot find the sources in %@
Info: Mesh deserialization: Skipped a source that will be recreated at runtime : %@
Error: Mesh deserialization: cannot find the specified source
primarySourcesInfo
Error: Mesh deserialization: cannot deserialize a source
Error: Mesh deserialization: cannot init a mesh element
Error: C3DMeshCheckValidity - bad mesh found
Warning: Can only convert to lines or points element type
Warning: Can only convert from triangle array to another element type
subIDs
Error: Cannot find the specified primary source
Error: Cannot find the specified source
C3DMesh
<C3DMesh %p "%@"
  element%d: %@
  semantic:%@%d (%d) : %@
  semantic:%@ (%d) : %@
  renderable element%d: %@
  renderable semantic:%@%d (%d) : %@
  renderable semantic:%@ (%d) : %@
baseSourceLocators
Error: Could not deserialize a source locator in %@
verticesMask
boundingSphere
meshElements
Warning: Can't add two position sources
Error: __C3DMeshCopy - unable to resolve interleaved mesh
Error: Failed to build renderable data for mesh %p
Warning: Mesh %p has multiple channels but they all define the same topology
Error: Deindexer failed - Source %p (%@) has no original data at index %u
Warning: Mesh %p has multiple channels but deindexing didn't have any effect
Warning: Deindexing - Vertex at index %u of %u is not used by any geometry element
Error: __writeIndexInBuffer - index (%u) out of bounds (%lu)
Error: %s - Invalid polygon edge count (%u)
__C3DMeshElementCreateRenderablePrimitiveTypeCopy
Error: __C3DMeshElementCreateRenderablePrimitiveTypeCopy - polygon too large (%u) for index buffer (%u)
Error: Inconsistent index count after triangulation.
SCNAction: Custom actions can not be properly encoded, Objective-C blocks do not support NSSecureCoding.
SCNAction: Custom actions can not be properly decoded, Objective-C blocks do not support NSCoding.
effectID
C3DMaterial
<C3DMaterial %p : "%@"
common profile %@
custom %@
__library__
Warning: Could not deserialize an effect
enableWriteInDepthBuffer
enableReadsFromDepthBuffer
fillMode
v28@?0f8r^{Triangle=}12r^20
B20@?0^8I16
Warning: Slider can only process triangles.
Warning: Occluder can only process triangles.
C3DConstraintSlider
<C3DConstraintAcceleration>
C3DConstraintAvoidOccluder
<C3DConstraintAvoidOccluder %p>
_hasFired
nodeConstraints-%p
Warning: C3DSceneSetRootNode - old root node seems to be already connected to another scene
C3DScene
Warning: RootNode is not retained by the scene
<C3DScene>
fogColor
fogDensityExponent
fogEndDistance
fogStartDistance
startTime
endTime
frameRate
upAxis
Error: Could not read the animations manager
nodeTree
Error: C3DSceneRef _copySerializedHierarchy: lib entry not found
nodeID
Warning: Some nodes failed to be deserialized
Error: ... and we do not even have a root node, so bailing out
Error: Scene deserialization : cannot finalize the deserialization of the animation manager
Error: Library could not remap the ID %@
Error: _deserializeHierarchy: could not find the specified node in the library
Error: _deserializeHierarchy: no nodeID specified!
playbackSpeed
animationManager
lightingSystem
kSCNFreeViewCameraName
<%@: %p '%@'>
<%@: %p>
-[SCNCamera setName:]
-[SCNCamera setScreenSpaceAmbientOcclusionIntensity:]
-[SCNCamera setScreenSpaceAmbientOcclusionRadius:]
-[SCNCamera setScreenSpaceAmbientOcclusionBias:]
-[SCNCamera setScreenSpaceAmbientOcclusionDepthThreshold:]
-[SCNCamera setScreenSpaceAmbientOcclusionNormalThreshold:]
-[SCNCamera setScreenSpaceAmbientOcclusionSampleCount:]
-[SCNCamera setScreenSpaceAmbientOcclusionDownSample:]
-[SCNCamera setAutomaticallyAdjustsZRange:]
-[SCNCamera setAverageGray:]
-[SCNCamera setBloomBlurRadius:]
-[SCNCamera setBloomIntensity:]
-[SCNCamera setBloomThreshold:]
-[SCNCamera setCategoryBitMask:]
-[SCNCamera setColorFringeStrength:]
-[SCNCamera setColorFringeIntensity:]
-[SCNCamera setContrast:]
-[SCNCamera setExposureAdaptationBrighteningSpeedFactor:]
-[SCNCamera setExposureAdaptationDarkeningSpeedFactor:]
-[SCNCamera setExposureAdaptationDuration:]
-[SCNCamera setExposureAdaptationHistogramRangeHighProbability:]
-[SCNCamera setExposureAdaptationHistogramRangeLowProbability:]
-[SCNCamera setExposureAdaptationMode:]
-[SCNCamera setExposureOffset:]
-[SCNCamera setDofIntensity:]
-[SCNCamera setMaximumExposure:]
-[SCNCamera setMinimumExposure:]
-[SCNCamera setMotionBlurIntensity:]
-[SCNCamera setOrthographicScale:]
-[SCNCamera setSaturation:]
-[SCNCamera setUsesOrthographicProjection:]
-[SCNCamera setVignettingIntensity:]
-[SCNCamera setVignettingPower:]
-[SCNCamera setWantsExposureAdaptation:]
-[SCNCamera setWantsHDR:]
-[SCNCamera setWhitePoint:]
-[SCNCamera setXFov:]
-[SCNCamera setYFov:]
-[SCNCamera setZFar:]
-[SCNCamera setZNear:]
-[SCNCamera setFieldOfView:]
-[SCNCamera setSensorHeight:]
-[SCNCamera setFocalLength:]
-[SCNCamera setFStop:]
-[SCNCamera setApertureBladeCount:]
-[SCNCamera setFocalBlurSampleCount:]
-[SCNCamera setFocusDistance:]
-[SCNCamera setProjectionTransform:]
usesOrthographicProjection
automaticallyAdjustsZRange
projectionDirection
focalBlurSampleCount
exposureAdaptationMode
colorGrading
wantsHDR
wantsExposureAdaptation
focalBlurRadius
wantsDepthOfField
T@"SCNMaterialProperty",R,N
SCNMultisamplingDefaultSampleCount
SKGlobalSharedContextRegistry
Error: failed to create a GL context with the pixelFormat %@
Warning: SCNCreateGLContext - failed to share our context with SpriteKit - fallback on a private context
C3DRendererContextRetainContext
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DKit/utils/SCNKitUtils.m
renderContext
C3DRendererContextReleaseContext
SCNLightAttenuationStartKey
SCNLightAttenuationEndKey
SCNLightAttenuationFalloffExponentKey
SCNLightSpotInnerAngleKey
SCNLightSpotOuterAngleKey
SCNLightSpotFalloffExponentKey
SCNLightShadowNearClippingKey
SCNLightShadowFarClippingKey
SCNLightGoboProjectShadows
SCNLightConstantAttenuationKey
SCNLightLinearAttenuationKey
SCNLightQuadraticAttenuationKey
SCNLightFallOffAngleKey
SCNLightFallOffExponentKey
SCNLightHotspotBeamKey
quadratic
omni
directional
spot
probe
<%@: %p '%@' | type=%@>
<%@: %p | type=%@>
-[SCNLight setName:]
-[SCNLight setAttribute:forKey:]
-[SCNLight setAttenuationEndDistance:]
-[SCNLight setAttenuationFalloffExponent:]
-[SCNLight setAttenuationStartDistance:]
-[SCNLight setBaked:]
-[SCNLight setCastsShadow:]
-[SCNLight setCategoryBitMask:]
-[SCNLight setColor:]
-[SCNLight setIntensity:]
-[SCNLight setOrthographicScale:]
-[SCNLight setShadowBias:]
-[SCNLight setShadowColor:]
-[SCNLight setShadowMapSize:]
-[SCNLight setShadowRadius:]
-[SCNLight setShadowSampleCount:]
-[SCNLight setSpotFalloffExponent:]
-[SCNLight setSpotInnerAngle:]
-[SCNLight setSpotOuterAngle:]
-[SCNLight setTechnique:]
-[SCNLight setTemperature:]
-[SCNLight setType:]
-[SCNLight setUsesDeferredShadows:]
-[SCNLight setUsesModulatedMode:]
-[SCNLight setZFar:]
-[SCNLight setZNear:]
-[SCNLight setShadowCascadeCount:]
-[SCNLight setAutomaticallyAdjustsShadowProjection:]
-[SCNLight setMaximumShadowDistance:]
-[SCNLight setForcesBackFaceCasters:]
-[SCNLight setSampleDistributedShadowMaps:]
-[SCNLight setShadowCascadeSplittingFactor:]
-[SCNLight set_shadowCascadeDebugFactor:]
usesDeferredShadows
lightCategoryBitMask
spotFallOffExponent
maximumShadowDistance
autoShadowProjection
shadowCascadeCount
shadowCascadeSplittingFactor
forcesBackFaceCasters
sampleDistributedShadowMaps
version
goboProjectShadows
castsShadow
usesModulatedMode
baked
shouldBakeDirectLighting
shouldBakeIndirectLighting
sphericalHarmonics
shadowSampleCount
shadowSampleCount2
IESProfileURL
T{CGSize=dd},N
shadowMode
automaticallyAdjustsShadowProjection
T@"NSURL",&,N
sphericalHarmonicsCoefficients
T@"NSData",R,C,N
offsetX
offsetY
SCNLightingModelPhysicallyBased
SCNLightingModelBlinn
SCNLightingModelPhong
SCNLightingModelLambert
SCNLightingModelConstant
SCNLightingModelNone
mappingChannel
-[SCNMaterial setName:]
<%@: %p
 '%@'
  %@=%@
.color
content
Warning: can't prepare shadable animation with path %@
Error: Material : %@ is not an animatable path
-[SCNMaterial _shadableSetValue:forUndefinedKey:]
shaderModifiers.
customMaterialProperties
customMaterialAttributes
-[SCNMaterial setShaderModifiers:]
-[SCNMaterial setProgram:]
valuesForUndefinedKeys
failed to archive material's custom attributes. %@ %@
lightingModelName
shadableHelper
colorBufferWriteMask
program
T@"SCNProgram",&,N
Tc,N,GisLitPerPixel
Tc,N,GisDoubleSided
{CGRect={CGPoint=dd}{CGSize=dd}}
width
height
length
kProjectionTransform
kModelTransform
kViewTransform
kModelViewProjectionTransform
kModelViewTransform
kNormalTransform
kRenderPassName
-[SCNNode setName:]
%s%s {
dump node tree (%@)
------------------------------------------------------
%@%@
<%p>
-[SCNNode _setQuaternion:]
-[SCNNode _setPosition:]
-[SCNNode _setScale:]
-[SCNNode setMovabilityHint:]
-[SCNNode setCastsShadow:]
-[SCNNode setCategoryBitMask:]
-[SCNNode setHidden:]
-[SCNNode setOpacity:]
-[SCNNode setRenderingOrder:]
 pos(%f %f %f)
 rot(%f %f %f %f)
 scale(%f %f %f)
 light=%@
 camera=%@
 geometry=%@
 | no child
 | 1 child
 | %d children
nodes
childNodes
filters.
-[SCNNode setValue:forUndefinedKey:]
Error: attempt to add a parent node as a child node
Error: error in removeFromParentNode : inconsistent tree
Error: removing the root node of a scene from its scene is not allowed
action %p #%d
Error: physicsBody %@ already has a owner: %@ that is not %@
Error: Error: physicsBody %@ 's owner (%@) should be %@
Error: attempt to add a null particle system on %@
constraints
physicsBody
physicsField
particleSystem
fixedBoundingBoxExtrema[0]
fixedBoundingBoxExtrema[1]
paused
focusBehavior
action-keys
actions
clientAttributes
failed to archive node's client attributes. %@ %@
movabilityHint
hasActions
actionKeys
T@"SCNLight",&,N
T@"SCNCamera",&,N
T@"SCNSkinner",&,N
T@"SCNMorpher",&,N
worldTransform
worldPosition
worldOrientation
Tc,N,GisHidden
parentNode
T@"SCNNode",R,N
T@"SCNPhysicsBody",&,N
T@"SCNPhysicsField",&,N
T@"NSArray",C
presentationNode
Tc,N,GisPaused
T@"<SCNNodeRendererDelegate>",N
worldUp
worldRight
worldFront
localUp
localRight
localFront
-[SCNNode(SIMD) setSimdPivot:]
-[SCNNode(SIMD) setSimdTransform:]
-[SCNNode(SIMD) setSimdRotation:]
simdTransform
T{?=[4]},N
simdPosition
simdRotation
simdOrientation
T{?=},N
simdEulerAngles
simdScale
simdPivot
simdWorldPosition
simdWorldOrientation
simdWorldTransform
simdWorldUp
T,R,N
simdWorldRight
simdWorldFront
simdLocalUp
simdLocalRight
simdLocalFront
Error: error while transposing skeleton or morph target
Error: error while transposing animations to cloned tree
Error: format %d has no sRGB variant
Warning: r8Unorm_sRGB variant is not supported on macOS. Defaulting on r8Unorm.
Warning: rg8Unorm_sRGB variant is not supported on macOS. Defaulting on rg8Unorm.
Error: Failed to create Metal pixel format for %@ [%d components, %d bits per component, bitmap info: %u (%@|%@), float components: %@, color space: %@]
Struct
Array
float2x2
float2x3
float2x4
float3x2
float4x3
half2x2
half2x3
half2x4
half3x2
half3x3
half3x4
half4x2
half4x3
half4x4
uint
char2
char3
uchar2
uchar3
bool2
bool3
bool4
uchar2N
uchar3N
uchar4N
char2N
char3N
char4N
ushort2N
ushort3N
ushort4N
short2N
short3N
short4N
i1010102N
u1010102N
Invalid
RGBA8Unorm
RGBA8Unorm_sRGB
Depth16Unorm
Depth24Unorm_Stencil8
Depth32Float_Stencil8
Depth32Float
Stencil8
UnknownPixelFormat
Warning: unsupported texture type %d
Warning: C3DValueWriteToMTLData - unknown dataType %lu
Warning: value unsupported %d of member %@
Error: Unexpected pixel format %lu
shaderRead
shaderWrite
renderTarget
pixelFormatView
Warning: Tessellation is not supported on this device (%{public}@)
byteOrderDefault(Big)
byteOrder16Little
byteOrder32Little
byteOrder16Big
byteOrder32Big
byteOrderUnknown
alphaNone
alphaPremultipliedLast
alphaPremultipliedFirst
alphaLast
alphaFirst
alphaNoneSkipLast
alphaNoneSkipFirst
alphaOnly
alphaUnknown
kSceneStartTimeAttributeKey
kSceneEndTimeAttributeKey
kSceneFrameRateAttributeKey
kSceneUpAxisAttributeKey
Error: [SCNScene root] is deprecated, use rootNode instead
com.apple.scenekit
scnz
com.apple.scenekit.scene
com.apple.scenekit.scene.zip
Error: can't convert c3dImage to cgImage %@ (url=%@)
%@_textures
%@_texture%d.png
MDLAsset
children[
Error: _subnodeFromIndexPath - invalid keypath
Error: %@ is not in a scene yet
Warning: failed to load scene at %@
physicsWorld
userAttributes
sourceURL
T@"SCNPhysicsWorld",R,N
lightingEnvironment
SCNLayerTreeDidChange
Error: SCNTextureSource abstract method invoked %@
Error: SCNImageSource astract method invoked %@
-[SCNTextureOffscreenRenderingSource _buildMipmaps:]
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DKit/materials/SCNTextureSource.m
SKSCNRenderer
T@,&,N,V_delegate
Error: SCNTextureDelegateSource::textureProxy -> no delegate
Error: C3DTextureSourceGetSharedRendererContext: cannot create context error %d
SKScene
SSAOSampleCount
SSAODownSample
SSAOCameraOrtho
scn_ssao_compute
scn_ssao_downsample
scn_ssao_blur_x
scn_ssao_blur_y
scn_ssao_upsampling
aoTmp1
aoTmp2
depthMinMaxOffsetTexture
Error: No point of view set for tone mapping pass
Error: No camera set for tone mapping pass
ssao-depth
SSAO-DownSampleZ
SSAO-MinMaxOffset
SSAO-ComputeAO
SSAO-Blur&Upsampling
C3DFXSSAO.json
SceneKit_SSAO
SceneKit_SSAO_DEPTH
--DepthAndNormalMaterial--
#pragma body
_output.color = float4(_surface.normal.xyz, _surface.position.z);
srcColor
(1 - srcColor)
srcAlpha
(1 - srcAlpha)
dstColor
(1 - dstColor)
dstAlpha
(1 - dstAlpha)
blendColor
(1 - blendColor)
blendAlpha
(1 - blendAlpha)
srcAlphaSat
C3DBlendStates
<C3DBlendStates %p targetCount:%d needsBlendColor:%d
  blend:%s col[(src * %@) %@ (dst * %@)] alpha[(src * %@) %@ (dst * %@)]
  blend:%s col[(src * %@) %@ (dst * %@)]
C3DCoreProfileVertexAttribDivisor
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/AppleEngine/OpenGL/C3DGL_macOS_CoreProfile.c
C3DCoreProfileBlitFramebuffer
GL_EXT_framebuffer_multisample
GL_ARB_texture_float
C3DCoreProfileBindVertexArray
C3DCoreProfileGenVertexArrays
C3DCoreProfileDeleteVertexArrays
C3DCoreProfileMapBufferRange
C3DCoreProfileFlushMappedBufferRange
C3DCoreProfileUnmapBufferRange
C3DCoreProfileSetPatchControlPointCount
Error: C3DCoreProfileSlotToAttachmentID : unknown slot
_target
_selector
Warning: MappingChannel %d needed but not available
need_vertex_color
need_position
need_normal
need_tangent
need_texcoord0
need_texcoord1
need_texcoord2
need_texcoord3
need_texcoord4
need_texcoord5
need_texcoord6
need_texcoord7
use_io_vertex_color
use_io_position
use_io_normal
use_io_view
use_ambient
use_diffuse
use_specular
use_emission
use_multiply
use_reflective
use_transparent
use_diffuse_map
use_normal_map
use_transparent_map
use_emission_map
use_ambient_map
use_multiply_map
use_specular_map
use_reflective_map
use_reflectivecube_map
use_roughness_map
use_metalness_map
diffuse_texture_component
normal_texture_component
transparent_texture_component
emission_texture_component
ambient_texture_component
multiply_texture_component
specular_texture_component
reflective_texture_component
roughness_texture_component
metalness_texture_component
use_diffuse_intensity
use_normal_intensity
use_transparent_intensity
use_emission_intensity
use_ambient_intensity
use_multiply_intensity
use_specular_intensity
use_reflective_intensity
use_roughness_intensity
use_metalness_intensity
use_fresnel
use_transparency
use_transparency_rgbzero
diffuse_channel
normal_channel
transparent_channel
emission_channel
ambient_channel
multiply_channel
specular_channel
roughness_channel
metalness_channel
diffuse_texcoord_io_index
normal_texcoord_io_index
transparent_texcoord_io_index
emission_texcoord_io_index
ambient_texcoord_io_index
multiply_texcoord_io_index
specular_texcoord_io_index
roughness_texcoord_io_index
metalness_texcoord_io_index
diffuse_transform_index
normal_transform_index
transparent_transform_index
emission_transform_index
ambient_transform_index
multiply_transform_index
specular_transform_index
roughness_transform_index
metalness_transform_index
use_emission_as_selfIllumination
use_ambient_as_ambientOcclusion
use_texture_transforms
use_point_rendering
diffuse_premultiplied
use_discard
use_instancing
max_bone_count
lighting_model
use_lighting
use_ambient_lighting
use_modulate_lighting
use_per_vertex_lighting
avoid_overlighting
use_double_sided
use_probes_lighting
use_light0
use_light1
use_light2
use_light3
use_node_opacity
use_fog
use_ssao
io_texcoord_count
normals
SCNPreferredRenderingAPIKey
SCNPreferredDeviceKey
SCNPreferLowPowerDeviceKey
PrefersOpenGL
Info: PrefersOpenGL key is set in the plist but Metal is requested programmatically. GL will be used
PrefersLowPowerGPU
com.apple.sceneKit.preferLowPowerDevice
ibPreferredRenderingAPI
ibWantsMultisampling
allowsCameraControl
backgroundColor
ibSceneName
background.contents
kSCNViewObservingContext
SceneKit - SCNView Draw
Error: switchToCameraNamed: no camera named %@
SCNView::setAsynchronousLoading is deprecated
can't set an openGL context on a metal based SCNView
Warning: SCNView -> can't create a valid pixel format
Error: Can't set the pixel format of a Metal-based SCNView
Error: Pixel format defines an unknown sample count : %d
rendersContinuously
T@"NSColor",C,N
cameraControlConfiguration
T@"<SCNCameraControlConfiguration>",R,N
defaultCameraController
T@"SCNCameraController",R,N
preferredFramesPerSecond
openGLContext
T@"NSOpenGLContext",&,N
pixelFormat
T@"NSOpenGLPixelFormat",&,N
Error: attaching a single wheel to multiple vehicle is not supported
vehicle
wheelIndex
suspensionStiffness
suspensionCompression
suspensionDamping
maximumSuspensionTravel
frictionSlip
maximumSuspensionForce
connectionPosition
steeringAxis
axle
radius
suspensionRestLength
isFront
T@"SCNNode",R
T{SCNVector3=ddd}
C3DCullingSystem
<C3DCullingSystem %p>
C3DLegacyProfileVertexAttribDivisor
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/AppleEngine/OpenGL/C3DGL_macOS_LegacyProfile.c
C3DLegacyProfileBlitFramebuffer
C3DLegacyProfileBindVertexArray
C3DLegacyProfileGenVertexArrays
C3DLegacyProfileDeleteVertexArrays
C3DLegacyProfileMapBufferRange
Error: <FlushMappedBufferRange> unsupported on OpenGL Compatibility profile
C3DLegacyProfileUnmapBufferRange
_lastRatio
_scaleTarget
_scaleTargetReversed
_deltaScale
_isReversed
uniform
#pragma opaque
#pragma transparent
#pragma declaration
#pragma arguments
#pragma varyings
#pragma body
Error: syntax error in the uniform declaration : %@
scn_node
scn_frame
<null>
<%@ %@>
_duration
_timingMode
_beginTime
_pausedTime
_isRunning
_finished
timingMode
T@?,N
T{SCNVector3=ddd},N,Vposition
T{SCNVector3=ddd},N,Veuler
T{SCNVector3=ddd},N,Vscale
T{SCNVector4=dddd},N,Vrotation
usesEuler
Tc,N,VusesEuler
Tf,N,Vopacity
SCNActionCacheKey
Tq,N,Vtype
next
T@"SCNNodeComponent",&,N,Vnext
T@,W,N,Vcomponent
SCNRendererOffscreenSampleCount
transition pass
outgoingScene
T@"SCNScene",&,N,V_outgoingScene
transition
T@"SKTransition",&,N,V_transition
transitionStartTime
Td,N,V_transitionStartTime
outgoingPointOfView
T@"SCNNode",&,N,V_outgoingPointOfView
Error: SCNRenderer::init - no engine context
com.apple.scenekit.renderingQueue.%@%p
<SCNRenderer %p: scene = %@, pointOfView = %@, sceneTime = %f, context = %p>
clearPass
Warning: _deleteGLFramebuffer - No context!
SceneKit - Delete Framebuffer
Warning: _prepareGLRenderTarget - No context!
SceneKit - Create Framebuffer
Error: failed to create a framebuffer
Error: framebuffer width must be > 0
Error: framebuffer width must be < 8192
Error: framebuffer height must be > 0
Error: framebuffer height must be < 8192
Error: autoenablesDefaultLighting: renderer has no context
Error: setAutoenablesDefaultLighting: renderer has no context
camera.xFov
camera.yFov
camera.fieldOfView
camera.orthographicScale
camera.
Error: SCNRenderer::setTechnique - no engine available yet - ignoring
Error: prepareObject:shouldAbortBlock renderer has no GL context
Error: prepareObject:shouldAbortBlock failed to create a shared context
c8@?0
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DKit/context/SCNRenderer.m
<Unknown File>
We should have an engine context at this stage
No C Scene associated with %@
Metal implementation not done
SpriteKit - Draw Overlay
SceneKit - Flush
-[SCNRenderer _drawSceneWithLegacyRenderer:]
Error: glError before rendering SceneKit contents: %x
Warning: createSnapshot: no GL context
Error: Can only update lightProbe
SceneKit - Jitter
nextFrameTime
Td,R,N
textureID
TI,R,N
SCN_ENABLE_COLLECTION
scenekit.fps
scenekit.primcnt
scenekit.frmtime
scenekit.phytime
scenekit.prttime
scenekit.animtime
scenekit.clientTime
scenekit.consttime
scenekit.rendertime
scenekit.cpuidletime
scenekit.cawaittime
scenekit.deviceutil
scenekit.rendererutil
scenekit.tilerutil
__scnPerformanceData
v24@?0{_CSTypeRef=QQ}8
usedCount
Tq,V_usedCount
buffer
T@"<MTLBuffer>",&,N,V_buffer
Tq,N,V_offset
dataSource
T@,N,V_dataSource
<%@: %p> "%@"
argument
T@"MTLArgument",&,N,V_argument
T@"NSString",R,N
needsRenderResource
bindBlock
T@,C,N,V_bindBlock
semanticsCount
Tq,N,VsemanticsCount
bufferSize
Tq,N,VbufferSize
inputsCount
Tq,N,VinputsCount
materialModificationCount
Tq,N,VmaterialModificationCount
geometryModificationCount
Tq,N,VgeometryModificationCount
FrameBuffer bindings:
Node bindings:
Pass bindings:
Shadable bindings:
Light bindings:
state
T@"<MTLRenderPipelineState>",&,N,V_state
frameBufferBindings
T@"NSArray",C,N,V_frameBufferBindings
nodeBufferBindings
T@"NSArray",C,N,V_nodeBufferBindings
passBufferBindings
T@"NSArray",C,N,V_passBufferBindings
shadableBufferBindings
T@"NSArray",C,N,V_shadableBufferBindings
lightBufferBindings
T@"NSArray",C,N,V_lightBufferBindings
vertexBuffersUsageMask
buffer[%d] : %@
element[%d] : %@
buffers
T@"NSArray",C,N,V_buffers
elements
T@"NSArray",C,N,V_elements
vertexDescriptor
T@"MTLVertexDescriptor",&,N,V_vertexDescriptor
stageDescriptor
T@"MTLStageInputOutputDescriptor",&,N,V_stageDescriptor
vertexLayoutHash
TQ,N,VvertexLayoutHash
tessellationVertexDescriptor
T@"MTLVertexDescriptor",R,N,V_tessellationVertexDescriptor
tessellationVertexLayoutHash
volatileBuffer
T@"<MTLBuffer>",&,N,V_volatileBuffer
volatileOffset
Tq,N,VvolatileOffset
volatileStride
Tq,N,VvolatileStride
volatileSize
TQ,N,VvolatileSize
verticesCount
Tq,N,VverticesCount
mutabilityTimestamp
Tq,N,V_mutabilityTimestamp
<SCNMetalMeshElement: %p type: %d index buffer: %@ [%d] effective count: %d offset: %d>
indexCount
Tq,N,V_indexCount
instanceCount
TQ,N,V_instanceCount
sharedIndexBufferOffset
Tq,N,V_sharedIndexBufferOffset
indexBuffer
T@"SCNMTLBuffer",&,N,V_indexBuffer
indexType
TQ,N,V_indexType
primitiveType
TQ,N,V_primitiveType
primitiveCount
Tq,R,N
effectiveIndexOffset
Tq,R,N,V_effectiveIndexOffset
effectiveIndexCount
Tq,R,N,V_effectiveIndexCount
axisA
axisB
anchorA
anchorB
minLinearLimit
maxLinearLimit
minAngularLimit
maxAngularLimit
motorTargetLinearVelocity
motorMaximumForce
motorTargetAngularVelocity
motorMaximumTorque
minimumLinearLimit
maximumLinearLimit
minimumAngularLimit
maximumAngularLimit
_posTarget.x
_posTarget.y
_posTarget.z
_posTargetReversed.x
_posTargetReversed.y
_posTargetReversed.z
_posStart.x
_posStart.y
_posStart.z
Error: unknown light type %@
path
flatness
entityID
basic
keyframe
group
Error: SCNEncodeAnimations unknown animation: %@
class
Error: can't deserialize animation %@
Error: failed to deserialize animation %@
Error: SCNEncodeAnimations failed to encode animation: %@
Error: SCNEncodeAnimations unknown animation type: %@
keyPath
animation-players
animation-keys
bindings
/Contents/Resources/
imageNamed
imageNamed://
Error: SCNDecodemage: invalid archive
MDLSkyCubeTexture
imageNamed://%@
turbidity
sunElevation
upperAtmosphereScattering
groundAlbedo
horizonElevation
gamma
exposure
brightness
channelEncoding
dimensions.x
dimensions.y
highDynamicRangeCompression.x
highDynamicRangeCompression.y
groundColor
Warning: CGPath archiving: unknown path element type
SCNAnimationCommitOnCompletion
SCN_CAKeyframeAnimation %p (duration=%f, keyPath:%@)
c3dAnimation
commitsOnCompletion
removedOnCompletion
Warning: unable to infer the type of a basic animation: %@
Warning: unable to infer the type of a keyframed animation: %@
Error: animating between instances is not supported
Error: CAKeyframeAnimationToC3DAnimation :: too large value to animate : %d bytes
CAKeyframeAnimation based on CGPath are not supported
Error: CAKeyframeAnimation has no keyframe - skipping conversion
Error: SCNAnimationTargetGetValue unknown type (%d)
Error: can't add a NULL animation to %@
SCNAnimationAnimatesUsingSceneTimeKey
SCNAnimationFadeInDurationKey
SCNAnimationFadeOutDurationKey
SCNAnimationEventsKey
animationEvents
c3dTimingFunction
Error: can't encode an animation that has never been attached to any target
applyOnCompletion
fillForward
fillBackward
userInfo
failed to archive animation's userinfo. %@ %@
appliedOnCompletion
scna
Error: failed to convert CAAnimation to SCNAnimation
Warning: default duration is zero - using default transaction duration
Error: This animation can't be changed to additive. To make this animation additive first convert it to a CAAnimation, set it to additive and convert back to SCNAnimation
Error: This animation can't be changed to cumulative. To make this animation cumulative first convert it to a CAAnimation, set it to cumulative and convert back to SCNAnimation
<SCNAnimation(%p) keyPath=%@ duration=%f repeatCount=%f>
T@"SCNTimingFunction",&,N
blendInDuration
blendOutDuration
Tc,N,GisRemovedOnCompletion
Tc,N,GisAppliedOnCompletion
startDelay
fillsForward
fillsBackward
animationDidStart
T@?,C,N
animationDidStop
Tc,N,GisAdditive
Tc,N,GisCumulative
weight
<SCNAnimationPlayer(%p) animation=%@>
T@"SCNAnimation",R,N,V_animation
Error: unknown fill mode
q24@?0@"SCNAnimationEvent"8@"SCNAnimationEvent"16
Error: sub-animation %@ of %@ has no keyPath - ignoring
Error: C3DAnimationToCAAnimation: unsupported animation
Warning: SCNAnimationGroupToCAAnimationGroup - no target path
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert startValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert endValue
Warning: SCNSimpleAnimationToCABasicAnimation - can't convert byValue
geometryMemory
textureMemory
SCNSceneSourceUseModelIOToLoadDAEFiles
kSceneSourceCacheScenesByURLKey
kSceneSourceSceneIndexKey
kSceneSourceForceMorphNormals
SCNSourceURLForCurrentlyUnarchivedScene
SCNConsistencyElementIDErrorKey
SCNConsistencyElementTypeErrorKey
SCNConsistencyLineNumberErrorKey
kSceneSourceFormat
SCNSceneSourceInputSource
SCNSceneExportDestinationURL
SCNSceneExportUTIKey
SCNSceneExportCompressGeometryElements
SCNSceneExportEmbedReferences
SCNSceneExportPresentationTree
[SCNSceneSource scenesSourceWithURL:] nil URL
<%@: %p | URL='%@'>
The document "%@" could not be opened.
The document data could not be read.
v32@?0f8i12^{__CFError=}16^B24
failed to unarchive data at %@ (%@)
failed to unarchive scene at %@ - unknown decoded object class (%@)
failed to unarchive scene at %@ (%@)
v36@?0f8q12@"NSError"20^c28
Error: entryWithUID:withClass: object with uid %@ exists but is not a geometry
Error: entryWithUID:withClass: object with uid %@ exists but is not a material
Error: entryWithUID:withClass: object with uid %@ exists but is not an animation
Error: entryWithUID:withClass: object with uid %@ exists but is not a node
Error: entryWithUID:withClass: object with uid %@ exists but is not a light
Error: entryWithUID:withClass: object with uid %@ exists but is not a camera
Error: entryWithUID:withClass: object with uid %@ exists but is not a scene
Error: entryWithUID:withClass: object with uid %@ exists but is not a skinner
Error: entryWithUID:withClass: object with uid %@ exists but is not a morpher
Error: entryWithUID:withClass: object with uid %@ exists but is not an image
Error: entrieswithClass: class %@ is not a known C3D class
@16@?0^v8
T@"NSURL",R
T@"NSData",R
documentURL
T@"NSURL",&,N,V_documentURL
T@"NSDictionary",&,N,V_context
assetCatalog
T@"SCNAssetCatalog",&,N,V_assetCatalog
lookUpKey
T@"NSString",&,N,VlookUpKey
lookUpFoundInstance
T@,&,N,VlookUpFoundInstance
documentEnclosingURL
T@"NSURL",R,N
T@"NSDictionary",C,N,Voptions
bplist
Warning: C3DMeshElementConvertToPolygonArrayIfNeeded can only process triangles
VertexCache
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Core/C3DMeshElement_Tools.cpp
cacheSize < kMaxCacheSize
textureCoordinate is deprecated - use textureCoordinateWithMappingChannel instead
<%@: %p <%f,%f,%f> | geometryIndex=%d node=%@ bone=%@>
geometryIndex
faceIndex
localCoordinates
worldCoordinates
localNormal
worldNormal
boneNode
glID
TI,N,VglID
TI,N,Vtarget
T^v,N,Vcontext
T{CGSize=dd},N,Vsize
invalid wrapS value: %d
invalid wrapT value: %d
label
T@"NSString",C
T@"<MTLDevice>",R
cpuCacheMode
storageMode
heap
T@"<MTLHeap>",R
allocatedSize
rootResource
T@"<MTLResource>",R
parentTexture
T@"<MTLTexture>",R
parentRelativeLevel
parentRelativeSlice
T@"<MTLBuffer>",R
bufferOffset
bufferBytesPerRow
iosurface
T^{__IOSurface=},R
iosurfacePlane
mipmapLevelCount
arrayLength
usage
framebufferOnly
Tc,R,GisFramebufferOnly
-[SCNMaterialProperty setContentsTransform:]
Error: slotName %d not found
<%@: %p | contents=%@>
<data %p>
Error: array for material property contents must have 6 elements
Warning: copyC3DImageFromImage: invalid sub-image
imageArray
layer
skscene
sktexture
attachment
isCommonProfileProperty
propertyType
customSlotName
sRGB
textureComponents
SKTexture
GLKTextureInfo
AVPlayer
Error: unknown material property type for archiving
Error: unknown archived material property type
a_vertexColor
a_TexTangent
a_diffuseTexcoord
a_ambientTexcoord
a_specularTexcoord
a_emissionTexcoord
a_filterTexcoord
a_transparentTexcoord
a_normalTexcoord
a_lightmapTexcoord
u_cameraPosition
u_nodeOpacity
u_skinningJointMatrices
u_materialShininess
u_ambientColor
u_ambientIntensity
u_ambientTexture
u_ambientTextureMatrix
u_diffuseColor
u_diffuseIntensity
u_diffuseTexture
u_diffuseTextureMatrix
u_specularColor
u_specularIntensity
u_specularTexture
u_specularTextureMatrix
u_emissionColor
u_emissionIntensity
u_emissionTexture
u_emissionTextureMatrix
u_multiplyColor
u_multiplyIntensity
u_multiplyTexture
u_multiplyTextureMatrix
u_transparency
u_transparentColor
u_transparentIntensity
u_transparentTexture
u_transparentTextureMatrix
u_normalTexture
u_normalIntensity
u_normalTextureMatrix
u_shininessTexture
u_shininessTextureMatrix
u_lightmapTexture
u_reflectiveColor
u_reflectiveIntensity
u_reflectiveTexture
u_reflectiveTextureMatrix
u_fresnel
u_ambientLightColor
u_shCoefficients
u_fogColor
u_fogParameters
u_light%d_attenuation
u_light%d_spotAttenuation
u_light%d_color
u_light%d_position
u_light%d_direction
u_light%d_up
u_light%d_right
u_light%d_gobo
u_light%d_goboMatrix
u_light%d_goboIntensity
u_light%d_iesMatrix
u_light%d_iesTex
u_light%d_shadow
u_light%d_shadowMatrix
u_light%d_shadowRadius
u_light%d_shadowColor
u_zRange
u_orientationPreserved
Error: C3DLibraryCreateEntryIdentifier - unknown type
Error: _remapInfos does not contain an entry %@
Error: library does not contain an entry %d with kind %d
Warning: C3DLibraryAddEntryWithUniqueID - object has no unique ID
C3DLibrarySubStorage
<C3DLibrarySubStorage>
C3DLibrary
<C3DLibrary>
Error: Library: could not deserialize the substorage for the type %@
Error: unknown type: %d
Error: type %d is not serializable
Error: Library deserialization: could not finalize the deserialization of a substorage
Error: Library Deserialization: cannot finalize the deserialization of %@
Warning: C3DLibraryGetMemoryUsageForKind found an image with no sampler
ParticleSystem_MeshElement
Error: __CreateMeshElement unexpected byte per index
C3D-ParticleSystem_Trail
C3D-ParticleSystem
C3D-ParticleSystem_PointSprite
%@%1d%c%c%c%c%c%c%c%1dO%1d%c
enableLighting
enableColorRamp
enableCubeMap
enableStretch
enableAnimation
enableFog
animationMode
uberparticle_vert
uberparticleCube_frag
uberparticle_frag
.vsh
.fsh
Error: ParticleSystem shaders missing : %@
#define mediump 
#define ENABLE_LIGHTING
#define ENABLE_COLOR_RAMP
#define ENABLE_CUBE_MAP
#define ENABLE_STRETCH
#define ENABLE_BILLBOARD_VIEW
#define ENABLE_ORIENTATION_FREE
#define ENABLE_BILLBOARD_Y
#define ENABLE_BILLBOARD_SCREEN
#define ENABLE_FOG
#define ENABLE_ANIMATION %d
#define ENABLE_SOFT
BlackPass
viewTransform
u_viewToCubeWorld
u_fresnelExponent
u_lightPosition0
u_lightColor0
u_colorRamp
u_stretchFactor
u_frameSize
u_softParameters
u_invProj
u_depthSampler0
u_projectionTransform
u_textureSampler0
C3DParticleManager
<C3DParticleManagerRef>
C3DFXDefaultPass
Error: C3DFXTechniqueAppendPass out of capacity
Error: C3DFXTechniqueSetValueForSymbol - expect an image for paramName %@
Error: C3DFXTechniqueSetValueForSymbol - unknown param named %@
Error: C3DFXTechniqueGetValueForSymbol - unknown param named %@
sequence
passes
symbols
Error: invalue description for input named %@ - expect a dictionary
Error: C3DFXTechniqueCompile - invalid description (sequence missing or empty) %@
metalLibraryFile
metalVertexShader
metalFragmentShader
clientProgram
inputs
owners
outputs
COLOR
Info: pass named %@ appears to be useless - skipping
C3DFXDefault_velocity.plist
C3DFXDefaultPass.plist
C3DFXDeferredShadingDefaultPass.plist
C3DFXTechnique
<C3DFXTechnique>
pass %d
plist
targets
self
kPrimitiveGenerateMappingCoordinates
kPrimitiveVertexTransformation
kPrimitiveGenerateSmoothedEdges
kPrimitiveWidthSegments
kPrimitiveHeightSegments
kPrimitiveLengthSegments
kPrimitiveChamferSegments
kPrimitiveRotationSegments
kPrimitiveCapSegments
kPrimitiveRingSegments
kPrimitivePipeSegments
kPrimitiveSphereType
kPrimitiveSphereSegments
kPrimitiveTypeSphere
kPrimitiveTypeGeosphere
kPrimitiveTypeHemisphere
kPrimitiveGeosphereBase
kPrimitiveTypeTetrahedron
kPrimitiveTypeHexahedron
kPrimitiveTypeOctahedron
kPrimitiveTypeIcosahedron
widthSegmentCount
heightSegmentCount
lengthSegmentCount
chamferSegmentCount
segmentCount
radialSegmentCount
ringSegmentCount
pipeSegmentCount
-[SCNFloor setReflectionResolutionScaleFactor:]
-[SCNFloor setReflectionCategoryBitMask:]
-[SCNFloor setWidth:]
-[SCNFloor setLength:]
-[SCNFloor setReflectionFalloffEnd:]
reflectionFalloffEnd
-[SCNFloor setReflectionFalloffStart:]
reflectionFalloffStart
-[SCNFloor setReflectionSampleCount:]
-[SCNFloor setReflectivity:]
reflectionCategoryBitMask
reflectionResolutionScaleFactor
C3DFloor
<C3DFloor>
resolutionScaleFactor
reflectionBitMask
Error: Can't create a vehicle with this chassis because it is not in the scene yet
Warning: Chassis should already have a body
wheel
chassisBody
wheels
speedInKilometersPerHour
-[SCNGeometry setName:]
%@: %p '%@'
%@: %p
 | %d elements
<%@>
geometrySourceForSemantic is deprecated - use geometrySourcesForSemantic instead
-[SCNGeometry setBoundingBoxMin:max:]
Error: leaking mesh elements array
materials[
q24@?0@8@16
Error: Cannot set edge creases element because its primitive type is not SCNGeometryPrimitiveTypeLine
Error: Cannot set edge creases source because its semantic is not SCNGeometrySourceSemanticEdgeCrease
-[SCNGeometry _shadableSetValue:forUndefinedKey:]
-[SCNGeometry setShaderModifiers:]
-[SCNGeometry setProgram:]
sourceChannels
failed to archive geometry's custom attributes. %@ %@
subdivisionLevel
wantsAdaptiveSubdivision
edgeCreasesSource
edgeCreasesElement
subdivisionSettings
tessellator
T@"SCNMaterial",&,N
geometrySources
geometryElementCount
T@"SCNGeometryTessellator",&,N
T@"SCNGeometryElement",&,N
T@"SCNGeometrySource",&,N
Warning: Found elements with different channel counts in the same geometry
Error: Missing channel for source at index %u
Error: Invalid channel (%d) for source at index %u
SCNErrorDomain
T@"SKScene",&,N,V_scene
v16@?0@"NSTimer"8
T@"<SCNCameraControllerDelegate>",N,V_delegate
T@"SCNNode",&,N,V_pointOfView
interactionMode
Tq,N,V_interactionMode
automaticTarget
Tc,N,V_automaticTarget
inertiaEnabled
inertiaFriction
Tf,N
inertiaRunning
Tc,R,N,GisInertiaRunning
minimumVerticalAngle
maximumVerticalAngle
minimumHorizontalAngle
maximumHorizontalAngle
Error: Point of view has custom projection.
drivenByDefaultNavigationCameraController
simdUp
simdTarget
verticalMaximumAngle
horizontalMaximumAngle
AuthEnv2Root
_layerRoot
_lightRoot
_cameraRoot
_particlesRoot
_physicsFieldRoot
_pointsOfViewRoot
Perspective
Bottom
Left
Right
Front
Back
_authoringCamera%s
lightAuth
particlesAuth
cameraAuth
cameraFrustumAuth
cameraNearPlaneAuth
fieldAuth
DBGLightType
lightInnerAuth
lightOuterAuth
lightArrowAuth
lightSpotAuth
scn_probesphere_from_sh_vertex
scn_probesphere_from_sh_fragment
v40@?0@"<SCNBufferStream>"8@"SCNNode"16@"<SCNShadable>"24@"SCNRenderer"32
oa:%f ia:%f s:%f e:%f
AuthEnvHash
displayMask
readDepthMask
authoringCameraType
metallib
Error: FATAL ERROR : can't find default.metallib file in SceneKit's bundle
Error: FATAL ERROR : failed loading metal shaders default library, %@
com.apple.SceneKit.device
debug_isolate_frag
com.apple.sceneKit.traceResources
Error: Failed loading common profile chache library : %@
Error: Compilation failed %@
Error: ComputePipeline state creation failed %@
commonProfile_%@.metal
Info: FATAL ERROR : failed compiling shader:
v24@?0@"<MTLLibrary>"8@"NSError"16
presentedItemURL
T@"NSURL",R,C
presentedItemOperationQueue
T@"NSOperationQueue",R,&
primaryPresentedItemURL
observedPresentedItemUbiquityAttributes
T@"NSSet",R
debug_vert
debug_frag
debug_post_tessellation_vert
^(.*)$
program_source:([0-9]+):[0-9]+:\s(.+):\s(.+)$
^<program source>:([0-9]+):[0-9]+:\s(.+):\s(.+)$
\[SCN_(\w+)\((\d+)\)\]
Geometry
Surface
Fragment
LightingModel
materialsSemantic
domUVSetToSource
Warning: Could not find a skeleton for the URI %s
Warning: Could not find a node for the skeleton with the URI %s
jointNames
jointNamesAreIDs
Warning: Skipping the skin with source %s: it is not a geometry, or it is an invalid geometry
JOINT
INV_BIND_MATRIX
Error: Skipping the skin with source %s: we only support joints elements with joints and inverse bind matrices
Error: Skipping the skin with source %s: a joints source should have either a name array or an IDREF array
Error: Skipping the skin with source %s: inv bind matrices need to be 4x4 matrices. Please ensure the document has been checked for consistency
Error: Skipping the skin with source %s: a inv bind matrix accessor should have only one param
Error: Skipping the skin with source %s: a inv bind matrix should be a float4x4
Error: Skipping the skin with source %s: the number of floats describing the inverse bind matrices should be 16 * number of joints
The count element of domVertexWeights does not match the vertex count. Please ensure the document has been checked for consistency
Error: Skipping the skin with source %s: found two different sources for the bones
Error: Skipping the skin with source %s: vertex weights source not found
Error: Skipping the skin with source %s: vertex weights source accessor does not reference the source's float array
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead (3)
texture1D
textureCube
texture3D
SCNShaderLightDecl.glsl
float __shadow2DProj(sampler2DShadow tex, vec4 coord) {return textureProj( tex, coord );}
float __shadow2DProj(sampler2DShadow tex, vec4 coord) {return shadow2DProj( tex, coord ).x;}
uniform vec4 u_shadowKernel[%d];
SCNShaderSurfaceDecl.glsl
USE_EMISSION_AS_SELFILLUMINATION
    vec2 %@Texcoord;
    _surface.%@Texcoord = v_texcoord%d;
} _surface;
varying vec2 v_texcoord%d;
uniform mat4 u_%@TextureMatrix;
v_texcoord%d = (u_%@TextureMatrix * vec4(_geometry.texcoords[%d], 0., 1.)).xy;
v_texcoord%d = _geometry.texcoords[%d];
NEED_IN_TEXCOORD%d
C3D-UberShader.vsh
SCNShaderGeometryDecl.glsl
struct SCNShaderLightingContribution {vec3 ambient; vec3 diffuse; vec3 specular; vec3 modulate;} _lightingContribution;
u_modelViewTransform
SEPARATE_PROJECTION
u_normalTransform
__DoTexcoord__
#define kSCNTexcoordCount %ld
__DoLighting__
attribute
varying
Error: failed to load vertex uber shader.
C3D-UberShader.fsh
Error: failed to load fragment uber shader.
u_light%hu
    _light.intensity = vec4(1.);
uniform vec4 %@_color;
    _light.intensity = %@_color;
uniform vec4 %@_direction;
    _light.direction = %@_direction.xyz;
uniform vec4 %@_position;
    vec3 _D = %@_position.xyz - _surface.position;
    _light.dist = length(_D);
    _light.direction = _D / _light.dist;
    _light.direction = normalize(%@_position.xyz - _surface.position);
    _light.dir = %@_direction.xyz;
uniform vec4 %@_attenuation;
    vec3 _att = %@_attenuation.xyz;
    _light._att *= step(_light.dist, _att.x);
    _light._att *= clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    float _dstatt = clamp(_light.dist * _att.x + _att.y, 0.0, 1.0);
    _light._att *= (_dstatt  * _dstatt);
    _light._att *= pow(clamp(_light.dist * _att.x + _att.y, 0.0, 1.0), _att.z);
uniform vec4 %@_spotAttenuation;
    vec3 _spot = %@_spotAttenuation.xyz;
    _light._att *= step(_spot.x, dot(_light.direction, _light.dir));
    _light._att *= clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    float _sptatt = clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0);
    _light._att *= _sptatt * _sptatt;
    _light._att *= pow(clamp(dot(_light.direction, _light.dir) * _spot.x + _spot.y, 0.0, 1.0), _spot.z);
uniform sampler2DShadow %@_shadow;
uniform mat4 %@_shadowMatrix;
uniform float %@_shadowRadius;
    float _shadowingTerm = 0.0;
    vec4 _lightScreen = (%@_shadowMatrix * vec4(_surface.position, 1.));
    float _filteringSizeFactor = %@_shadowRadius * _lightScreen.w;
    for(int i=0; i < %d; i++){
        _shadowingTerm += __shadow2DProj(%@_shadow, _lightScreen + (u_shadowKernel[i] * _filteringSizeFactor));
    }
    _shadowingTerm /= float(%d);
    float _shadowingTerm = __shadow2DProj(%@_shadow, (%@_shadowMatrix * vec4(_surface.position, 1.)));
uniform vec4 %@_shadowColor;
    _light._att *= (1. - _shadowingTerm * %@_shadowColor.a);
uniform sampler2D %@_gobo;
uniform mat4 %@_goboMatrix;
uniform float %@_goboIntensity;
    _light.intensity *= mix(vec4(1.), texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.))), %@_goboIntensity);
    _light.intensity *= %@_goboIntensity * texture2DProj(%@_gobo, (%@_goboMatrix * vec4(_surface.position, 1.)));
uniform sampler2D %@_iesTex;
    _light.intensity *= texture2D(%@_iesTex, vec2(acos(dot(_light.direction, _light.dir))*_spot.x,0.));
uniform vec4 %@_up;
uniform vec4 %@_right;
 float vertAngle = acos(dot(_light.direction, _light.dir));
 vec3 surfaceRay = _surface.position-%@_position.xyz;
 vec3 projPos = normalize(surfaceRay - dot(surfaceRay,_light.dir)*_light.dir);
 vec2 texCoord = vec2(dot(projPos,%@_right.xyz),dot(projPos,%@_up.xyz))*vertAngle*_spot.x;
_light.intensity *= texture2D(%@_iesTex, texCoord*0.5+0.5);
uniform samplerCube %@_iesTex;
uniform mat4 %@_iesMatrix;
    _light.intensity *= textureCube(%@_iesTex, (%@_iesMatrix * vec4(_surface.position, 1.)).xyz);
Error: Physically based lighting model is not supported by the OpenGL renderer, using Phong instead (2)
    _light.intensity.rgb *= _light._att * max(0.0, dot(_surface.normal, _light.direction));
    _lightingContribution.diffuse += _light.intensity.rgb;
    vec3 _R = reflect(-_light.direction, _surface.normal);
    _lightingContribution.specular += pow(max(0.0, dot(_R, _surface.view)), _surface.shininess) * _light.intensity.rgb;
    vec3 _halfVector = normalize(_light.direction + _surface.view);
    _lightingContribution.specular += pow(max(0.0, dot(_surface.normal, _halfVector)), _surface.shininess) * _light.intensity.rgb;
  vec4 %@;
uniform %@ %@;
Warning: C3DSkinnerTransposeSkeleton - unable to transpose every joints
Warning: Cannot update the joints using node names: unammed joint found
Warning: Cannot update the joints using node names: can't find node named %@
Warning: _C3DSkinnerUpdateBoundingBox - skinned node has no geometry
Error: We did not succeed in locating all the joints, so do not update the geometry as it might be worse if we use the wrong bones.
Error: _computeJointMatrices - no joint handles
Error: C3DSkinnerUpdateJointsAndBoundingBox skinner has no mesh
Error: bone out of range %d>=%d [face:%d/vertex:%d]
Error: wrong weight sum %f [face:%d/vertex:%d]
C3DSkinner
<C3DSkinner %p skeleton:%p jointCount:%d cpuReady:%d gpuReady:%d
  skin:%p skinnedMesh:%p calcMode:%d
  JointBbox[%d] {%f,%f,%f} {%f,%f,%f}
skeletonID
skinID
Error: C3DSkinner serialization: lib entry not found
Warning: Skinner deserialization: cannot find the specified skeleton
Error: Skinner deserialization: cannot find a joint
Error: Skinner deserialization: cannot find the skin
Error: C3DSkinner deserialization: lib entry not found
Error: C3DSkinner deserialization: Could not get a valid number value
skeleton
meshCreated
bboxDirty
skinnedMesh
verticesJointsMatrices[%d]
normalsJointsMatrices[%d]
v32@?0@"SCNRenderTarget"8Q16^c24
v32@?0@8@"NSMutableArray"16^c24
v32@?0@8@"NSArray"16^c24
numberOfRenderTargets
_hide
Warning: failed to transpose skeleton
Error: SCNSkinner setBaseGeometry is deprecated on iOS10 and OS X 10.12 and has no effect
Error: SCNSkinner: there must be the same number of bone weights and bone indices
Error: SCNSkinner: bone weights must be of type `float`
Error: SCNSkinner: bone indices must be uint8 or uint16 (maximum of 2 bytes)
Error: SCNSkinner: bone indices stride must be equal to componentsPerVector * bytesPerComponent
Error: SCNSkinner: bone weights stride must be equal to componentsPerVector * bytesPerComponent
Error: mismatch between the vertex count and the number of bones per vertex
Error: can't create a skinner with no bones
Error: can't create a skinner with no base geometry
Error: bones count and bind transform count don't match
Error: number of transforms (%d) doesn't match the number of joints (%d)
baseGeometry
baseGeometryBindTransform
bones
Error: Bones index too large for compressed representation : %d
compressedSkinData
boneWeights
boneIndices
baseGeometryBindTransform-%d
boneInverseBindTransforms
T@"SCNGeometrySource",R,N
 %f %f %f %f
Error: Unsupported skin weight format
Warning: Morph vertexCount = %ld
Warning: [%ld] = %ld (%f)
Error: meshElement %d : %@
Error: invalid skin indices
Info: Too many influencing joints (%ld > %d) on the vertex #%u, will cap to %d and renormalize
C3DSkin
<C3DSkin %p name:%@ joint:%d weight:%d vertexCount:%d
  maxInf:%d morpher:%p
defaultShapeMatrix
inverseBindMatrix
jointsCount
Error: No jointsCount in the skin %@
Error: Unable to read the jointsCount in the skin %@
maxInfluences
Warning: No maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
Warning: Unable to read the maxInfluences in the skin %@, defaulting to 4. Please re-convert your assets.
inverseBindMatrices
Error: No inverseBindMatrices in the skin %@
defaultShapeMatrix
Error: No defaultShapeMatrix in the skin %@
baseMeshID
weightsCount
Error: A vertex weight index does not fit on an int
vertexWeightIndices
jointsForVertexWeights
vertexWeights
Error: Skin: Could not remap the ID for geometry %d
Error: Skin deserialization: no weightsCount in %@
Error: Skin deserialization: no jointsForVertexWeights in %@
Error: Skin deserialization: no vertexWeights in %@
Error: Skin deserialization: invalid vertexWeights
maxInfluencesPerVertex
influencingMorpher
vertexWeightIndices[%d]
vertexWeights[%d]
jointsForVertexWeights[%d]
C3DIONSZipFileArchiveHeaderOffset
C3DIONSZipFileArchiveCompressionType
C3DIONSZipFileArchiveCRC
C3DIONSZipFileArchiveCompressedLength
C3DIONSZipFileArchiveUncompressedLength
1.2.11
C3DFXFloorPass.plist
SceneKit_renderMirroredScene
SceneKit_renderFloor
u_floorNormal
u_floorTangent
u_floorCenter
u_floorExtent
u_floor_viewport
u_floorReflectivity
u_floorFalloffStart
u_floorFalloff
u_floorPlane
u_floorMVP_i
FloorGeomImpl.glsl
FloorGeomImpl-metal.h
USE_FALLOFF
USE_FALLOFF_START
FloorImpl.glsl
FloorImpl-metal.h
Error: GenericSource deserialize => no data type
Error: GenericSource deserialize => no count, bailing out
Error: GenericSource deserialize => no comp/value, bailing out
Error: GenericSource deserialize => no padding, bailing out
Error: Could not serialize the accessor's type
Error: accessor->_count too big
Error: accessor->_offset too big
Error: accessor->_padding too big
Error: Accessor serialization failed
Error: Accessor deserialization: Could not find the source ID
Error: Accessor deserialization: Could not find a valid source type
Error: Accessor deserialization: Could not remap the ID for source %d
Error: Accessor deserialization: : no serialized data
Error: C3DSourceAccessorGetValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetValuePtrAtIndex - no data
Error: C3DSourceAccessorGetMutableValuePtrAtIndex - index out of bounds : %d > %d
Error: C3DSourceAccessorGetVolatileValuePtrAtIndex - index out of bounds : %d > %d
Error: The destination does not have enough room to copy this data
Error: error in C3DSourceAccessorCopyDataToAccessor
C3DSourceAccessor
<C3DSourceAccessor %lx>
componentsCountPerValue
count
<C3DGenericSource %lx>
Error: ERROR: GenericSource deserialize => no data type, bailing out
Error: ERROR: GenericSource deserialize => no count, bailing out
Error: ERROR: GenericSource deserialize => no stride, bailing out
Error: Could not deserialize an accessor
Error: Could not serialize an accessor
Error: Cannot finalize the deserialization of mesh source: accessor data missing
Warning: Cannot duplicate a Metal Buffer source. Create an empty data instead.
delegationBlock
C3DGenericSource
Error: render pass has no attachment
<%@: %p> color0"%@" depth:"%@" sampleCount:%d
Error: Missing vertex function `%@`, error: %@
Error: Missing fragment function `%@`, error: %@
Info: Shaders without a vertex function are not allowed
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
Error: Compiler error while building render pipeline state for node "%@" (%p):
Error: Metal renderer does not support nil vertex function name
Error: Shader Cache usage : %d miss / %d hit
SCNMaterialData
Error: Failed to create library from source, error: %@
Error: format %@ not convertible to MTLVertexFormat
%@-%@
-Indices[%d]
Error: Failed to create compute pipeline state, error: %@
Error: Missing metal function named `%@`
Error: Failed to create compute pipeline state with descriptor, error: %@
Error: Error compiling function named `%@` : %@
scn_commonprofile_ds
Error: incorrect buffer size  for attachments vertex [%d] fragments [%d]. Expected:%d Provided:%d
Error: missing buffer for attachment %@ [vertex: %d fragments: %d]
Error: arguments %@ : mismatch between the NSData and the buffer size %ld != %ld
Warning: Missing texture value for %@
Error: Missing vertex function `%@`
Error: Missing fragment function `%@`
Error: Failed to create render pipeline state, error: %@
Error: Missing compute function `%@` in library %@
Error: Missing vertex function %@
Error: Missing fragment function %@
libraryManager
T@"SCNMetalLibraryManager",&,N,V_libraryManager
T@"<MTLDevice>",R,N,V_device
T^{__C3DScene=},R,V_scene
customAudioNode
Tc,R,V_customAudioNode
completed
Tc,V_completed
audioPlayer
T@"AVAudioPlayerNode",R,V_audioPlayer
willStartPlayback
T@?,C,N,VwillStartPlayback
didFinishPlayback
T@?,C,N,VdidFinishPlayback
audioNode
T@"AVAudioNode",R,N,V_audioNode
audioSource
T@"SCNAudioSource",R,N,V_audioSource
caff
aiff
Error: failed to load audio source at %@
Error: can't archive audio data directly
positional
Tc,N,GisPositional,Vpositional
volume
Tf,N,Vvolume
rate
Tf,N,Vrate
reverbBlend
Tf,N,VreverbBlend
Tc,N,V_loops
shouldStream
Tc,N,V_shouldStream
Warning: C3DResourceCacheGetResource - image changed on disk - ignore cache
C3DResourceCache
<C3DResourceCache 0x%lx>
C3DAnimationGroup
<C3DAnimationGroup %p animations:%@>
Error: Animation group deserialization: could not deserialize the animation
channels
Error: Could not deserialize an animation
Error: Could not deserialize an animation: animation not found in %@
targetPath
Error: Could not deserialize an animation: targetPath not found in %@
subAnimations
Error: _C3DAnimationChannelCopyPropertyList - no target path
 point(%f %f %f)
 normal(%f %f %f)
 impulse(%f)
 distance:%f
nodeA
nodeB
contactPoint
contactNormal
collisionImpulse
penetrationDistance
sweepTestFraction
Error: unable to update the physics shape of %@
Warning: cannot change collision bit masks without physics world
Error: cannot apply force on a body that is not attached to a SCNNode
Error: cannot clear forces on a body that is not attached to a SCNNode
Error: cannot attach a body to a null node %p
mass
charge
friction
restitution
rollingFriction
physicsShape
damping
angularVelocity
angularDamping
velocityFactor
angularVelocityFactor
ignoreGravity
explicitMomentOfInertia
momentOfInertia
contactTestBitMask
allowsResting
isDefaultShape
usesDefaultMomentOfInertia
T@"SCNPhysicsShape",&,N
isResting
Tc,N,GisAffectedByGravity
v40@?0q8q16q24q32
v24@?0d8f16f20
v28@?0f8f12f16f20f24
-[SCNPlane setCornerRadius:]
cornerRadius
-[SCNPlane setCornerSegmentCount:]
cornerSegmentCount
-[SCNPlane setHeight:]
-[SCNPlane setHeightSegmentCount:]
-[SCNPlane setPrimitiveType:]
-[SCNPlane setWidth:]
-[SCNPlane setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f>
-[SCNBox setChamferRadius:]
chamferRadius
-[SCNBox setChamferSegmentCount:]
-[SCNBox setHeight:]
-[SCNBox setHeightSegmentCount:]
-[SCNBox setLength:]
-[SCNBox setLengthSegmentCount:]
-[SCNBox setPrimitiveType:]
-[SCNBox setWidth:]
-[SCNBox setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f length=%.3f chamferRadius=%.3f>
boxwidth
boxheight
boxlength
boxchamferRadius
boxwidthSegmentCount
boxheightSegmentCount
boxlengthSegmentCount
boxchamferSegmentCount
boxprimitiveType
-[SCNPyramid setHeight:]
-[SCNPyramid setHeightSegmentCount:]
-[SCNPyramid setLength:]
-[SCNPyramid setLengthSegmentCount:]
-[SCNPyramid setPrimitiveType:]
-[SCNPyramid setWidth:]
-[SCNPyramid setWidthSegmentCount:]
<%@ | width=%.3f height=%.3f length=%.3f>
pyramidwidth
pyramidheight
pyramidlength
pyramidwidthSegmentCount
pyramidheightSegmentCount
pyramidlengthSegmentCount
pyramidprimitiveType
-[SCNSphere setGeodesic:]
-[SCNSphere setHemispheric:]
-[SCNSphere setPrimitiveType:]
-[SCNSphere setRadialSpan:]
radialSpan
-[SCNSphere setRadius:]
-[SCNSphere setSegmentCount:]
<%@ | radius=%.3f>
sphereradius
sphereradialSpan
spheresegmentCount
sphereprimitiveType
spheregeodesic
spherehemispheric
geodesic
Tc,N,GisGeodesic
-[SCNCylinder setHeight:]
-[SCNCylinder setHeightSegmentCount:]
-[SCNCylinder setPrimitiveType:]
-[SCNCylinder setRadialSegmentCount:]
-[SCNCylinder setRadialSpan:]
-[SCNCylinder setRadius:]
<%@ | radius=%.3f height=%.3f>
cylinderradius
cylinderheight
cylinderradialSpan
cylinderheightSegmentCount
cylinderradialSegmentCount
cylinderprimitiveType
-[SCNCone setBottomRadius:]
bottomRadius
-[SCNCone setHeight:]
-[SCNCone setHeightSegmentCount:]
-[SCNCone setPrimitiveType:]
-[SCNCone setRadialSegmentCount:]
-[SCNCone setTopRadius:]
topRadius
<%@ | topRadius=%.3f bottomRadius=%.3f height=%.3f>
conetopRadius
conebottomRadius
coneheight
coneheightSegmentCount
coneradialSegmentCount
coneprimitiveType
-[SCNTube setHeight:]
-[SCNTube setHeightSegmentCount:]
-[SCNTube setInnerRadius:]
innerRadius
-[SCNTube setOuterRadius:]
outerRadius
-[SCNTube setPrimitiveType:]
-[SCNTube setRadialSegmentCount:]
-[SCNTube setRadialSpan:]
<%@ | innerRadius=%.3f outerRadius=%.3f height=%.3f>
tubeinnerRadius
tubeouterRadius
tubeheight
tuberadialSpan
tubeheightSegmentCount
tuberadialSegmentCount
tubeprimitiveType
-[SCNCapsule setCapRadius:]
capRadius
-[SCNCapsule setCapSegmentCount:]
capSegmentCount
-[SCNCapsule setHeight:]
-[SCNCapsule setHeightSegmentCount:]
-[SCNCapsule setPrimitiveType:]
-[SCNCapsule setRadialSegmentCount:]
<%@ | capRadius=%.3f height=%.3f>
capsulecapRadius
capsuleheight
capsuleheightSegmentCount
capsuleradialSegmentCount
capsulecapSegmentCount
capsuleprimitiveType
-[SCNTorus setPipeRadius:]
pipeRadius
-[SCNTorus setPipeSegmentCount:]
-[SCNTorus setPrimitiveType:]
-[SCNTorus setRadialSpan:]
-[SCNTorus setRingRadius:]
ringRadius
-[SCNTorus setRingSegmentCount:]
<%@ | ringRadius=%.3f pipeRadius=%.3f>
torusringRadius
toruspipeRadius
torusradialSpan
torusringSegmentCount
toruspipeSegmentCount
torusprimitiveType
Error: SCNTextureSpriteKitSource::textureProxy -> no scene
C3DAvoidOccluderConstraintDelegate
<C3DAvoidOccluderConstraintDelegate %p>
create
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DIO/conditioners/conditionerBase.cpp
SkinInfo
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DIO/conditioners/deindexer_core.cpp
vindex == vnumber
Error: Index out of bounds.
Error: <vertices> not found in mesh, please check the document for consistency
Error: Deindexer: source %s has a count of %d, but the morphed source %s has a count of %d
Error: Deindexer: Detected a morph target and a morph source which do not have the same number of vertices
Error: No source referencing the <vertices> element found
POSITION
Error: [Deindexer] Found a vertices element without a POSITION source
deindexer
geometry processing
Error: [Deindexer] Found a mesh element without a <vertices> element in its inputs
Error: [Deindexer] Vertices %s: index %llu -> %llu out of bounds (%llu)
Error: [Deindexer] Input %d: index %llu out of bounds (%llu)
applyDeindexing
newsource
Error: [Deindexer] Source resizing failed, the size to allocate was probably too big
FloatSourcePair
elementSize == sizeof(double)
Error: [Deindexer] Source resizing failed, old/new indices are out of ranges
Error: [Deindexer] Source %s: index %llu out of bounds (%llu)
Error: [Deindexer] Vertices %s: index %llu out of bounds (%llu)
Error: [Deindexer] Found a source referencing %s which is not a vertices or input element
Error: [Deindexing] Target %d of a morph does not have a mesh
preferredFrameRate
adaptativeFrameRate
polygons2triangles
draw :%4d vertices:%8d primitives:%8d
program   count:%4d memory:%8d Kb
vbuffer   count:%4d memory:%8d Kb
ibuffer   count:%4d memory:%8d Kb
cbuffer   count:%4d memory:%8d Kb
texture   count:%4d memory:%8d Kb
Warning: FPS:%f FrameTime:%f (%f/%f)
Warning: DC:%d (V:%d P:%d) Sw VBO:%d IBO:%d FBO:%d
_axisRot
_rotX
_rotY
_rotZ
_lastRotX
_lastRotY
_lastRotZ
_isAxisAngle
_isUnitArc
_qRot
Error: Polylist2Triangles::createTrianglesFromPolylist error: vertex index out of bounds
polylists2triangles
SCNSceneGraphSelectedNodeDidChange
SCNKitSceneGraphView
can't load nib named : SCNKitSceneGraphView
Visibility
Bbox
local:%@ (valid:%d)
<inf. box>
<%.2f,%.2f,%.2f %.2f,%.2f,%.2f>
%@-node
[%@]-node
(N/A)
%p %@
Warning: Targets input missing in a <morph> element, ignoring the morph
Warning: Invalid <input> in a <morph> element, ignoring the morph
Warning: We only support name arrays and IDREF arrays for morph targets for now, ignoring the morph
Warning: Found a morph target which does not exist or is not a geometry, ignoring the morph
This <%s> does not have a <%s> descendant
This <%s> does not have a <%s> attribute
Unable to resolve the URI %s
Unable to find an element with the ID "%s"
(type=
, no ID found)
, no ID found, closest ancestor with ID = 
, ID=
Warning: [Coherency check] %s %s
The number of elements in the <%s> tag (%lld) should be %lld.
Offset too large
VERTEX
The %dth <p> element has less than %d vertices
The number of vertices in the %dth <p> element should be a multiple of %d
vertices
Warning: No bind_material in %s
Warning: Invalid bind_material %s: no technique_common
binding not found for material symbol
vcount
Warning: Unknown array type %s
computed_float_array
The stride of this source should at least be %llu
The number of items in this source is %llu but should at least be %llu.
Warning: Ignoring a non-required invalid input
Found %d elements with the same ID "%s"
UseIOStrictMode
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a texture element as it is a bit too harsh with texcoords
source_data
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a source_data element
Warning: Ignoring error XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 on a node element (Illusoft exports wrong layer attributes)
init_from
Warning: Ignoring an invalid URL exported by older exporters in an init_from element
xs:ID
xs:NCName
Warning: Ignoring an invalid names or IDs exported by exporters
library_images
library_effects
library_materials
Warning: Ignoring error concerning empty library_images elements
technique_common
Warning: Ignoring error concerning empty technique_common elements
Warning: Ignoring error concerning empty animation elements
text
Warning: Ignoring error concerning multiple texture elements
Warning: Ignoring error concerning slots exported in the wrong order
extra
library_physics_models
library_physics_scenes
instance_physics_scene
Warning: Ignoring error from an extra or physics element
annotate
Warning: Ignoring error concerning <annotate> elements
'sid'
is not a valid value of the atomic type 'xs:NCName'
Warning: Ignoring an invalid SID attribute error
'url'
is not a valid value of the atomic type 'xs:anyURI'
Warning: Ignoring an invalid URL attribute error
'id'
'name'
Warning: Ignoring an empty ID or name attribute on visual_scene error
Warning: Ignoring error concerning <extra> and <node> exported in the wrong order
subject
asset
Warning: Ignoring error concerning <subject> and <title> exported in the wrong order
canvas_aspect
Warning: Ignoring error concerning non-existent canvas_aspect element
Warning: Schema validation warning: msg=%s (%s:%d) (code %d)
Warning: Cannot perform validation, validation context could not be created
Error: Failed to parse the XML document (base URL: %s)
There must be one inverse bind matrix per joint
Cannot find a node with the SID "%s"
A skin must have either a name array or an IDREF array to store its joints.
Circular reference between nodes detected
Invalid node array
Invalid instance node array
Warning: could not find bundle %@, fall back to main bundle
COLLADASchema
http://www.w3.org/2001/03/xml.xsd
rewriteURI
No input with the semantic "%s" found
The "count" attribute of the <%s> tag (%llu) should be %llu.
The URI %s should point to a <%s> but points to a <%s>
Error: format %lu not supported for SH generation
compute_sh%d_from_cubemap_threadgroup_mem
compute_sh%d_from_cubemap
sum_sh%d
-[NSData(SCNExtensions) scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:]
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DKit/utils/NSData+SCNExtensions.m
-[NSData(SCNExtensions) scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataEncodingDeltaWithBytesPerIndex:]
-[NSData(SCNExtensions) scn_indexedDataDecodingDeltaWithBytesPerIndex:]
Error: [SCNAction group:] invoked with nil
T@"NSString",R
registryID
maxThreadsPerThreadgroup
T{?=QQQ},R
lowPower
Tc,R,GisLowPower
headless
Tc,R,GisHeadless
removable
Tc,R,GisRemovable
recommendedMaxWorkingSetSize
depth24Stencil8PixelFormatSupported
Tc,R,GisDepth24Stencil8PixelFormatSupported
readWriteTextureSupport
argumentBuffersSupport
rasterOrderGroupsSupported
Tc,R,GareRasterOrderGroupsSupported
currentAllocatedSize
maxThreadgroupMemoryLength
programmableSamplePositionsSupported
Tc,R,GareProgrammableSamplePositionsSupported
pendingGPUFrameCount
contentScaleFactor
superSamplingFactor
screenTransform
wantsWideGamut
disableLinearRendering
isOpaque
currentFrameIndex
showsAuthoringEnvironment
enablesDeferredShading
collectsCompilationErrors
compilationErrors
T@"NSDictionary",R,N
features
renderTargetRegistry
T@"SCNRenderTargetRegistry",R,N
T@"<SCNResourceManager>",R,N
Tq,R,N,VpendingGPUFrameCount
Tq,N,VsampleCount
Td,N,VcontentScaleFactor
Tc,N,VwantsWideGamut
Tc,N,VdisableLinearRendering
Tc,N,VisOpaque
Tc,N,VenablesDeferredShading
Tc,N,VcollectsCompilationErrors
T@"SCNRenderTargetRegistry",R,N,V_renderTargetRegistry
TQ,N,VdebugOptions
SCNPhysicsShapeTypeKey
SCNPhysicsShapeKeepAsCompoundKey
SCNPhysicsShapeScaleKey
SCNPhysicsShapeCollisionMarginKey
convexHull
concaveMesh
convexDecomposition
Warning: changing the content of a physics shape is not expected
Info: Non triangle list element type not yet supported in physics shape generation
Error: vertex format not supported for physics shape creation (%d)
Warning: Cannot create convex hull for entity %@
v32@?0@"SCNPhysicsShape"8Q16^c24
Error: Compound shapes cannot be created without shapes
Warning: SCNPhysicsShape does not support a SCNCone with TopRadius != 0.0
transformsCount
transform%d
referenceObject
T@,R,N,V_referenceObject
physicsShape[%f,%f,%f]
Warning: Physics shape construction does not support meshes with positions value type different from double or float. (%d)
SCNDefaultPhysicsShape
btTriangleInfoData
btTriangleInfoMapData
_C3DParametricGeometryCreateCacheHash_not_thread_safe
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Core/C3DParametricGeometry.c
size <= sizeof(C3DParametricGeometryType) + sizeof(C3DParametricGeometryParameters)
C3DParametricGeometry
Unknown
Pyramid
Cylinder
Cone
Tube
Capsule
Torus
Sphere
Plane
<%@<%@>:%p "%@"
Error: C3DParticleModifier_PhysicsField - no aether
Warning: overflow the max batch size boundary
C3DDynamicBatchingSystem
<C3DDynamicBatchingSystem %p>
Error: C3DGLSLProfileBindProfileInputs - profile has no technique
_bindInput
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/AppleEngine/C3DGLSLProfileInterpreter.c
Error: wrong location returned for input named %@
Error: can't find input named %@
Warning: the same program is shared by two passes but indexed in a different manner
Error: failed to find texture target named %@
Error: declared type doesn't match the uniform named %@
C3DGLSLGetUniformType
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/AppleEngine/OpenGL/C3DGL.c
ubyte
byte
invalid operation
invalid enum
invalid value
stack overflow
invalid framebuffer operation
no error
unknown error
Error: %s:%d framebuffer unsupported (%x)
C3DCheckFramebufferStatus
Error: %s:%d incomplete attachment (%x)
Error: %s:%d missing attachment (%x)
Error: %s:%d incomplete dimensions (%x)
Error: %s:%d incomplete format (%x)
Error: %s:%d incomplete draw buffer (%x)
Error: %s:%d incomplete read buffer (%x)
Error: %s:%d incomplete multisample ext (%x)
Error: %s:%d unknown error (%x)
vec2(
vec3(
vec4(
%g,%g
%g,%g,%g
%g,%g,%g,%g
C3DValue
<C3DValue %p - type:%d bytes:%p >
enableExposure
enableFrameLuminanceAutoExposure
enableHistogramAutoExposure
enableBloom
enableVignetting
enableColorGrading
enableSaturation
enableContrast
enableColorFringe
enableDebug
enableDepthOfField
DOFSampleCount
dof_compute_kernel
dof_blur
scn_postprocess
scn_motionblur_vert
scn_motionblur_blur
BloomA
BloomB
DOFColorCoC
DOFBlur
DOFCoCA
DOFCoCB
MotionBlurTexture
MotionBlurColorTexture
MotionBlurTileMax
MotionBlurNeighborMax
bloom_blur_frag_%d
scn_histogram_analyse
histogram analysis
scn_hdr_luminance_frag
FrameLuminance
histogram_immediate_luminance
histogram_adaptative_luminance
AverageLuminance
frame_luminance
sliding_lum
adaptative_lum
fixed_lum
dof_coc_downsample4
dof_coc_blurV
dof_coc_blurH
downsample_2x_bloom
downsample_2x_dof
downsample_2x_bloom_dof
downsample_4x_bloom
downsample_4x_dof
downsample_4x_bloom_dof
scn_motionblur_tilemax
scn_motionblur_neighbormax_x
scn_motionblur_neighbormax_y
Error: DOF pass: no camera
frambuffer histogram
luminance histogram
PostFX-LuminanceHistogram
PostFX-FrameLuminance
PostFX-MipMapFrameLuminance
PostFX-AverageLuminance
PostFX-ColorDepthDownSampling
SCN-DepthOfField
PostFX-BloomBlurX
PostFX-BloomBlurY
VELOCITY
PostFX-Compositing
SCN-MotionBlur
PostFX-MotionBlur
C3DFXPostProcess_depth.json
C3DFXPostProcess.json
SceneKit_PostProcess
arrangedObjects
arrangedObjects.SCNUI_name
insertObject:in%@AtIndex:
removeObjectFrom%@AtIndex:
objectIn%@AtIndex:
object of class %@ doesn't implement %@
SCNUIArrayInspector
table
T@"NSTableView",&,N,Vtable
T@"NSButton",&,N,Vadd
remove
T@"NSButton",&,N,Vremove
representedObject
T@,&,N,VrepresentedObject
T@,W,N,Vdelegate
removeButton
allowsCreation
T@,W,N,Vtarget
%.2f
mlDelegate
T@,W,N,VmlDelegate
tessellationFactorScale
maximumEdgeLength
edgeTessellationFactor
insideTessellationFactor
adaptive
screenSpace
tessellationPartitionMode
smoothingMode
Tc,N,GisAdaptive
Tc,N,GisScreenSpace
C3DFXSampler
<C3DFXSampler>
Info: SCNSceneSourceConvertUnitsToMetersKey and SCNSceneSourceConvertToYUpKey have no effect on compressed assets. Use Xcode's compression options instead
preferredExtensions
Warning: Safe mode enabled, denying the download of a network URL %@
Warning: Unable to find the image named %@ at the specified path (%@)
Warning: Invalid URL %@
Warning: light_map uv_set:%d is pointing to an invalid uv_set(no corresponding source) and was reset to 1
Warning: invalid zRange detected (whole scene clipped)
B24@?0^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}8^B16
nodeFromflattenedMesh
0.10
0.11
kEnclosingFolderURL
kSceneSourceInputLibrary
kC3DIOSerializationExportDelegate
kCreatePropertyListShouldZipOption
kCreatePropertyListShouldKeepReferencesToFilesOption
readerMinimumRequiredVersion
library
Error: can't serize plist :%@
Error: Could not get the data for the serialized property list
Could not get the data for the serialized property list
Error: Could not zip the serialized property list
Could not zip the serialized property list
zippedData
zipped
Error: failed to write scene
Error: This file cannot be opened (version is too old)
Error: This file cannot be opened (version of this c3d is too recent for this version of the framework)
Error: Could not find the zipped data
Error: Could not unzip the zipped data
Error: Error loading the unzipped data: %@
Error: cannot initialize library
Error: Cannot get the library in the serialized data
Error: cannot initialize scene
Error: cannot finalize scene deserialization
Warning: cannot finalize library deserialization
meter
kIDKey
kNameKey
entity-name
entity-ID
_kvc
C3DEntity
<C3DEntity:%p>
Error: unknown notification name
C3DEngineNotificationQueue
<C3DEngineNotificationQueue %p>
Warning: adding a node that was just removed %p
Warning: KTX file seems too small or is not a KTX
Error: Only big endian ktx are supported
Error: Only compressed ktx are supported
Error: Bad KTX format
Warning: Compression type %d not supported
Error: overflow reading mip %d (%d > %d)
C3D-DefaultProgram
C3DFXGLSLProgram
<C3DFXGLSLProgram %p>
vertexShader
tessellationControlShader
tessellationEvaluationShader
geometryShader
fragmentShader
attributeNamesToIndexes
uniformNamesToIndexes
Error: can't find program named %@
Warning: The morph base geometry does not exist or is not a geometry, ignoring the morph
Warning: Unable to read the geometry of one of the targets, ignoring the morph
Warning: Weights input missing in a <morph> element, ignoring the morph
Error: Mesh malformed : missing semantic "%@" in morph target "%@"
-MorphBase
Per vertex triangles offsets
Per vertex triangles indices
-Morph-SparseIndices
-Morph-Data
Assertion failed [sparseVertexCount == tgt->vectorCount] target buffer is incorrectly sized
morph_copy_pn_kernel
morph_blend_pn_kernel
morph_copy_kernel
morph_blend_kernel
blendpack_init_8x_pn_kernel
blendpack_add_8x_pn_kernel
blend_init_8x_p_kernel
blend_add_8x_p_kernel
v16@?0Q8
SceneKit: Morphing Incremental
blend_inc_init_8x_pn_kernel
blend_inc_add_8x_pn_kernel
blend_inc_init_8x_p_kernel
blend_inc_add_8x_p_kernel
SceneKit: Post-morphing Normal Smoothing
unify_u16
unify_u32
morphNormal
copy_generic
blend_generic
blend_sparse_u16_generic
blend_sparse_u32_generic
splat_indexed_vertices
SceneKit: Morphing Sparse
%@-PosNrm
needNormal
needTangent
maxBoneCount
%c%c%d
skin_LBS
SceneKit: Skinning
Error: _metalMeshForGPUComputeSkinMorph: was unable to generate tangents
Warning: Could not get the controller referenced by the URL %s. Please ensure the document has been checked for consistency
v16@?0^{__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}8
Error: Could not create morph intervals : Target %d is useless
C3DMorph
<C3DMorph %p "%@"
  calc:%d morphNrm:%d targets:%ld
[%ld] weight:%f %@
morphingType
Error: No morphingType in the morph %@
Error: Unable to read the morphingType in the morph %@
weightsID
targetIDs
weightsData
Error: Could not remap the ID for mesh %d
Error: Could not remap the ID for weights source %d
<unnamed %d>
Error: weights (%d) should match targetChannelCount (%d)
Error: channel weights (%d) should match target count (%d)
Error: Morphing for sources of type %@ not implemented yet
C3D-GaussianBlur
#define unshareIndex %d
#define MAX_SAMPLE %d
#define COMPONENT %c
GaussianBlur_vert
GaussianBlur_frag
C3D-blur-radiusH
C3D-blur-radiusV
C3D-blur-offsets
C3D-blur-weights
C3D-blur-samples
C3DMorpher
<C3DMorpher %p baseGeom:%p morphedMesh:%p state:%d
  morph:%@
morphID
Error: Morpher deserialization: cannot find the morph
Error: C3DMorpher deserialization: lib entry not found
Error: C3DMorpher deserialization: Could not get a valid number value
Warning: C3DFXContextGetFirstPassInstanceWithGroupID: failed to find pass instance with name (%@)
Error: _C3DFXSetupPasses : no context
Error: shadows are only supported by spot lights and directional lights
C3DFXContext
<C3DFXContext>
%d - %@
 (resolve)
 (%dx)
__C3DEngineContextRenderPassInstance
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/FX/C3DFXContext.m
NoName
Error: failed to bind program for pass %@
Error: pass %@ has no program set
u_inverseResolution
u_time
C3DFXContextBindFramebufferForPass
Error: C3DFXRenderPassWillExecute: invalid framebuffer
authoring
Warning: We do not support skipping <param>s yet
Warning: We do not support alternating types yet
Error: can't share a SCNPhysicsField is already attached to a SCNNode
halfExtent
strength
minimumDistance
active
scope
usesEllipsoidalExtent
exclusive
Tc,N,GisActive
Tc,N,GisExclusive
direction
block
smoothness
animationSpeed
SceneKit: C3DProgressDebugger fractionCompleted > 1.0
fractionCompleted
failed to load technique from dictionary: %@
-[SCNTechnique setValue:forSymbolNamed:]
valueForSymbol
dictionaryRepresentation
T@"NSDictionary",R
C3DRendererDelegate
<C3DRendererDelegate %p>
C3DNotificationCenter
<C3DNotificationCenter %p>
-[SCNMorpher setName:]
<SCNMorpher %p>
weights[%d]
-[SCNMorpher setWeight:forTargetAtIndex:]
Error: %@ setWeight:forTargetAtIndex:%d - index out of bounds (%d)
-[SCNMorpher setCalculationMode:]
weightID
useSparseTargets
channelTargetWeights
channelTargetCounts
shouldMorphNormals
T@"NSArray",&,N
unifiesNormals
T@"<MTLBuffer>",R,N,V_buffer
TQ,R,N,V_bufferSize
elementSize
TQ,R,N,V_elementSize
Error: Too many uniform custom samplers given (Max is %d)
Error: invalid custom texture slot.
com.apple.scenekit.programHashCodeQueue
C3DRendererElementProgramHashCode
<C3DRendererElementProgramHashCode %p : 
SM_Mat,
SM_Geo,
Aone,
Acst,
opq,
tgt,
lgh,
amb,
prob,
fog,
dynB,
pntR,
Constant
Lambert
Phong
Blinn
[%@:
PerPix|
Double|
OverLght|
WrNrm|
Nrmliz|
WriteDepth|
LinDepth|
LockAmb|
TrspA
TrspRGB
TrspSL
TrspDL
[Node:
skn(%d)|
LightMap|
VrtCol|
Tess|
AmbientOcclusion
SelfIllumination
Tex|
rgb0|
rgb1|
flt0|
texA|
int|
comp|
mat|
(1D)
(2D)
(3D)
(Cube)
[Lighting:
Soft(%d)
frame
T{CGRect={CGPoint=dd}{CGSize=dd}}
bounds
T{CGSize=dd}
T{SCNVector3=ddd},R
T{SCNVector4=dddd},R
T{CATransform3D=dddddddddddddddd},R
SCNInitializeJavascriptContext is deprecated - use SCNExportJavaScriptModule instread
JSValue
toVector4
toVector3
toTransform3D
valueWithVector3:inContext:
valueWithVector4:inContext:
valueWithTransform3D:inContext:
_SceneKitIsLoaded
SCNLayer
SCNAntialiasingModeMultisampling8X
SCNAntialiasingModeMultisampling16X
SCNMaterialProperty
SCNBoundingBox
SCNBoundingSphere
SCNTransaction
SCNColor
CAMediaTimingFunction
CABasicAnimation
CAAnimationGroup
CAKeyframeAnimation
CALayer
SCNImage
SCNValue
SCNView
SCNMetalLayer
SCNNode
SCNGeometry
SCNPhysicsWorld
SCNPhysicsBody
SCNTransformConstraint
SCNLookAtConstraint
SCNLight
SCNCylinder
SCNGeometryElement
SCNIKConstraint
SCNPhysicsVehicleWheel
SCNRenderer
SCNTube
SCNParticleSystem
SCNMorpher
SCNBox
SCNCamera
SCNLevelOfDetail
SCNMaterial
SCNProgram
SCNParticlePropertyController
SCNConstraint
SCNPlane
SCNCone
SCNPhysicsBehavior
SCNPhysicsHingeJoint
SCNPhysicsField
SCNGeometrySource
SCNTorus
SCNScene
SCNPhysicsShape
SCNCapsule
SCNFloor
SCNShape
SCNText
SCNTechnique
SCNPyramid
SCNSceneSource
SCNSphere
SCNPhysicsBallSocketJoint
SCNPhysicsSliderJoint
SCNPhysicsContact
SCNHitTestResult
SCNAnimationEvent
SCNPhysicsVehicle
SCNAction
SCNActionTimingModeLinear
SCNActionTimingModeEaseIn
SCNActionTimingModeEaseOut
SCNActionTimingModeEaseInEaseOut
SCNEditingLocalSpace
SCNEditingParentSpace
SCNEditingWorldSpace
SCNEditingScreenSpace
SCNManipulatorPositionCenter
SCNManipulatorPositionMin
SCNManipulatorPositionMax
SCNAuthoringDisplayBoundingBoxes
SCNAuthoringDisplayBoundingSpheres
SCNAuthoringDisplayCameraFrustum
SCNAuthoringDisplayLightExtents
SCNAuthoringDisplayCameraPosition
SCNAuthoringDisplayLightPosition
SCNAuthoringDisplayPhysics
SCNAuthoringDisplayPhysicsFields
SCNAuthoringDisplayGrid
SCNAuthoringDisplayLightProbes
SCNAuthoringDisplayWireframe
SCNAuthoringDisplaySkeletons
SCNAuthoringDisplayConstraints
SCNAuthoringDisplayCreases
SCNDebugDisplayLightInfluence
SCNAuthoringCameraPerspective
SCNAuthoringCameraTop
SCNAuthoringCameraBottom
SCNAuthoringCameraLeft
SCNAuthoringCameraRight
SCNAuthoringCameraFront
SCNAuthoringCameraBack
SCNCameraProjectionDirectionVertical
SCNCameraProjectionDirectionHorizontal
SCNInteractionModeFly
SCNInteractionModeOrbitTurntable
SCNInteractionModeOrbitAngleMapping
SCNInteractionModeOrbitCenteredArcball
SCNInteractionModeOrbitArcball
SCNInteractionModePan
SCNInteractionModeTruck
SCNCameraFieldOfViewOrientationVertical
SCNCameraFieldOfViewOrientationHorizontal
SCNCameraExposureAdaptationModeFrameLuminance
SCNCameraExposureAdaptationModeHistogramLuminance
SCNCameraFillModeFill
SCNCameraFillModeLetterbox
SCNGeometryPrimitiveTypeTriangles
SCNGeometryPrimitiveTypeTriangleStrip
SCNGeometryPrimitiveTypeLine
SCNGeometryPrimitiveTypePoint
SCNGeometryPrimitiveTypePolygon
SCNTessellationSmoothingModeNone
SCNTessellationSmoothingModePNTriangles
SCNTessellationSmoothingModePhong
SCNSubdivisionBoundaryInterpolationRuleNone
SCNSubdivisionBoundaryInterpolationRuleEdgeOnly
SCNSubdivisionBoundaryInterpolationRuleEdgeAndCorner
SCNSubdivisionFaceVaryingInterpolationRuleLinearNone
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersOnly
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersPlus1
SCNSubdivisionFaceVaryingInterpolationRuleLinearCornersPlus2
SCNSubdivisionFaceVaryingInterpolationRuleLinearBoundaries
SCNSubdivisionFaceVaryingInterpolationRuleLinearAll
SCNSubdivisionNormalSmoothingModeCrossTriangle
SCNSubdivisionNormalSmoothingModeCrossQuad
SCNSubdivisionNormalSmoothingModeLimit
SCNHitTestSearchModeClosest
SCNHitTestSearchModeAll
SCNHitTestSearchModeAny
SCNLevelOfDetailThresholdModeWorldSpaceDistance
SCNLevelOfDetailThresholdModeScreenSpaceRadius
SCNShadowModeForward
SCNShadowModeDeferred
SCNShadowModeModulated
SCNMorpherCalculationModeNormalized
SCNMorpherCalculationModeAdditive
SCNMovabilityHintFixed
SCNMovabilityHintMovable
SCNChamferModeBoth
SCNChamferModeFront
SCNChamferModeBack
SCNParticleSortingModeNone
SCNParticleSortingModeProjectedDepth
SCNParticleSortingModeDistance
SCNParticleSortingModeOldestFirst
SCNParticleSortingModeYoungestFirst
SCNParticleBlendModeAdditive
SCNParticleBlendModeSubtract
SCNParticleBlendModeMultiply
SCNParticleBlendModeScreen
SCNParticleBlendModeAlpha
SCNParticleBlendModeReplace
SCNParticleOrientationModeBillboardScreenAligned
SCNParticleOrientationModeBillboardViewAligned
SCNParticleOrientationModeFree
SCNParticleOrientationModeBillboardYAligned
SCNParticleBirthLocationSurface
SCNParticleBirthLocationVolume
SCNParticleBirthLocationVertex
SCNParticleBirthDirectionConstant
SCNParticleBirthDirectionSurfaceNormal
SCNParticleBirthDirectionRandom
SCNParticleImageSequenceAnimationModeRepeat
SCNParticleImageSequenceAnimationModeClamp
SCNParticleImageSequenceAnimationModeAutoReverse
SCNParticleInputModeOverLife
SCNParticleInputModeOverDistance
SCNParticleInputModeOverOtherProperty
SCNParticleModifierStagePreDynamics
SCNParticleModifierStagePostDynamics
SCNParticleModifierStagePreCollision
SCNParticleModifierStagePostCollision
SCNParticleEventBirth
SCNParticleEventDeath
SCNParticleEventCollision
SCNParticleRenderingModeSprite
SCNParticleRenderingModePointSprite
SCNParticleRenderingModeTrail
SCNParticleRenderingModeBeam
SCNParticleRenderingModeGeometry
SCNReferenceLoadingPolicyImmediate
SCNReferenceLoadingPolicyOnDemand
SCNAntialiasingModeNone
SCNAntialiasingModeMultisampling2X
SCNAntialiasingModeMultisampling4X
SCNRenderingAPIMetal
SCNRenderingAPIOpenGLLegacy
SCNRenderingAPIOpenGLCore32
SCNRenderingAPIOpenGLCore41
SCNSceneSourceStatusParsing
SCNSceneSourceStatusValidating
SCNSceneSourceStatusProcessing
SCNSceneSourceStatusComplete
SCNSceneSourceStatusError
SCNCullBack
SCNCullFront
SCNBufferFrequencyPerFrame
SCNBufferFrequencyPerNode
SCNBufferFrequencyPerShadable
SCNFillModeFill
SCNFillModeLines
SCNCullModeBack
SCNCullModeFront
SCNTransparencyModeAOne
SCNTransparencyModeRGBZero
SCNTransparencyModeSingleLayer
SCNTransparencyModeDualLayer
SCNTransparencyModeDefault
SCNBlendModeAlpha
SCNBlendModeAdd
SCNBlendModeSubtract
SCNBlendModeMultiply
SCNBlendModeScreen
SCNBlendModeReplace
SCNBlendModeMax
SCNFilterModeNone
SCNFilterModeNearest
SCNFilterModeLinear
SCNWrapModeClamp
SCNWrapModeRepeat
SCNWrapModeClampToBorder
SCNWrapModeMirror
SCNPhysicsBodyTypeStatic
SCNPhysicsBodyTypeDynamic
SCNPhysicsBodyTypeKinematic
SCNPhysicsFieldScopeInsideExtent
SCNPhysicsFieldScopeOutsideExtent
center
fromValue
toValue
Tc,GisAdditive
Tc,GisCumulative
T@"CAMediaTimingFunction",&
Tc,GisRemovedOnCompletion
T^{CGPath=}
keyTimes
T@,C,N
T@,N
Tc,N,GisPlaying
vertexFunctionName
fragmentFunctionName
opaque
Tc,N,GisOpaque
T@"<SCNProgramDelegate>",N
T@"<MTLLibrary>",&,N
presentationMorpher
T@"SCNMorpher",R,N
T@"SCNGeometry",R
screenSpaceRadius
Td,R
worldSpaceDistance
audioPlayers
particleSystems
hemispheric
Tc,N,GisHemispheric
geometrySourceChannels
influenceFactor
incremental
Tc,N,GisIncremental
presentationLight
T@"SCNLight",R,N
presentationMaterial
T@"SCNMaterial",R,N
targetOffset
upVector
gimbalLockEnabled
T@,R,N
primitiveRange
T{_NSRange=QQ},N
indicesChannelCount
interleavedIndicesChannels
Tc,R,N,GhasInterleavedIndicesChannels
pointSize
minimumPointScreenSpaceRadius
maximumPointScreenSpaceRadius
vectorCount
floatComponents
componentsPerVector
bytesPerComponent
dataOffset
dataStride
extrusionDepth
chamferMode
chamferProfile
chainRootNode
targetPosition
font
wrapped
Tc,N,GisWrapped
containerFrame
T{CGRect={CGPoint=dd}{CGSize=dd}},N
textSize
T{CGSize=dd},R,N
truncationMode
alignmentMode
SCNJS%@JSExport
SCN%@JSExport
%@JSExport
T@"CALayer",&,N,V_layer
Error: SCNTextureLayerSource::textureProxy -> no layer
bbox %p - min:[%f %f %f] max:[%f %f %f]
T{SCNVector3=ddd},N,Vmin
T{SCNVector3=ddd},N,Vmax
bsphere %p - center:[%f %f %f] radius:%f
T{SCNVector3=ddd},N,Vcenter
Td,N,Vradius
Error: Unflushed transaction present.
Error: Transaction stack contains an uncommited transaction.
Warning: invalid keypath: %@ sent to object %@
Warning: C3DTransactionFlush: command queue still not empty after 2 passes
Error: C3DTransactionCommit - transaction already committed
Error: C3DTransactionCommit - invalid transaction count - probably too many [transaction commit]
C3DCommandQueue
<C3DCommandQueue>
C3DTransaction
<C3DTransaction>
Error: Error killing thread with uncommitted transaction.
transition-0x
Error: C3DTransactionRemoveChild - inconsistency
Error: unexpected transaction commit (missing being ?)
UITrackingRunLoopMode
animationTimingFunction not implemented for Javascript
animationDuration
animationTimingFunction
T@"CAMediaTimingFunction",C,N
disableActions
completionBlock
kGeometrySourceSemanticTangent
kGeometrySourceSemanticVertexCrease
kGeometrySourceSemanticEdgeCrease
kGeometrySourceSemanticBoneWeights
kGeometrySourceSemanticBoneIndices
<%@: %p | semantic=%@ vectors=%d %@x%d>
Error: geometrySourceWithData: interleaved buffers as doubles are not supported
Error: failed to convert color data - skip convertion
Error: geometrySourceWithBuffer - invalid vertex format
Error: _geometrySourceWithSource - invalid vertex format
_geometrySourceWithSource - Conversion failed
Error: Could not create mesh source
componentType
Geometry source has invalid bounds
mutableData
T@"NSMutableData",R,N
<%@: %p | %u x %@, %u channels, %@ indices>
Error: SCNGeometryElement initialization - Invalid index size (%ld bytes)
Error: SCNGeometryElement initialization - Invalid polygon edge count (%ld)
compressedElementData
elementData
primitiveRangeLocation
primitiveRangeLength
ptSize
triangle
triangle strip
line
point
polygon
VendorID
ProductID
MaxInputReportSize
IOHIDManagerOpen failed - %d
T@"SCNView",R
enableFreeCamera
autoSwitchToFreeCamera
freeCamera
setGimbalLockVector is deprecated
Camera
Error: not able to get click origin
Warning: _beginTranslateAtLocation: invalid zRange
Warning: Warning: no C3DIntersectionRay3Plane
NSScrollWheelMultiplier
gimbalLockMode
gimbalLockVector
stickyAxis
enableInertia
allowsTranslation
automaticCameraTarget
cameraTarget
kC3DColladaResourcesServiceRequestArgumentsKey
kC3DColladaResourcesServiceReplyReturnCodeKey
kC3DColladaResourcesServiceReplyArgumentsKey
kC3DColladaResourcesCoordinatorRequestURLKey
kC3DColladaResourcesCoordinatorRequestExtensionKey
kC3DColladaResourcesCoordinatorRequestAssetDirectoryURLsKey
kC3DColladaResourcesCoordinatorRequestImagePathsKey
kC3DColladaResourcesCoordinatorReplyExtensionsKey
kC3DColladaResourcesExtractorRequestURLKey
kC3DColladaResourcesExtractorRequestExtensionKey
kC3DColladaResourcesExtractorRequestAssetDirectoryURLsKey
kC3DColladaResourcesExtractorReplyAssetDictionariesKey
kC3DColladaResourcesCheckerRequestResourcesKey
kC3DColladaResourcesCheckerReplyValidResourcesKey
SCNFlyCameraControllerForwardKeyCodeKey
SCNFlyCameraControllerBackwardKeyCodeKey
SCNFlyCameraControllerLeftKeyCodeKey
SCNFlyCameraControllerRightKeyCodeKey
Error: setGimbalLockVector is deprecated
Warning: _computeTranslationOrigin3DFromPoint: invalid zRange
flyModeVelocity
panSensitivity
truckSensitivity
rotationSensitivity
T@"SCNView",N
cameraController
T@"SCNCameraController",R,N,V_cameraController
T@"<SCNCameraNavigationControllerDelegate>",N,V_delegate
Tc,N,V_autoSwitchToFreeCamera
Td,N,V_flyModeVelocity
Td,N,V_panSensitivity
Td,N,V_truckSensitivity
Td,N,V_rotationSensitivity
Tc,N,V_enableFreeCamera
T@"SCNNode",R,N,V_freeViewCameraNode
T@"SCNView",N,V_view
com.apple.SceneKit.C3DColladaResourcesCoordinator
Error: Could not create service connection.
v16@?0^v8
Error: Message error: %s
Error: [ResourcesSandboxing] Could not unarchive reply arguments.
An error occurred while locating the resources needed to open this COLLADA file. Please check that it has not been corrupted.
Error: Could not issue extension for path: %s.
Error: Could not create the XPC message object
Error: Could not create object from message arguments.
Error: Could not get resource list from reply message.
extension
Error: Could not get extension at index: %d.
Error: Could not consume extension at index: %d.
uniform 
.<>?:/|&^*/+-=%!~
Symbol
String
Number
Operator
AssignementOperator
OpenParent
CloseParent
OpenBracket
CloseBracket
OpenSBracket
CloseSBracket
Comments
Comma
SemiColon
Blank
NewLine
MacroHash
float2
float3
float4
ivec3
uvec2
uint2
uvec3
uint3
uvec4
uint4
mat2
mat3
mat4
mat2x4
mat3x2
mat3x3
mat4x2
float4x2
mat3x4
float3x4
scn_frame.time
u_viewTransform
scn_frame.viewTransform
u_inverseViewTransform
scn_frame.inverseViewTransform
scn_frame.projectionTransform
u_inverseProjectionTransform
scn_frame.inverseProjectionTransform
scn_frame.cameraPosition
scn_frame.viewToCubeWorld
scn_frame.inverseResolution
u_modelTransform
scn_node.modelTransform
u_inverseModelTransform
scn_node.inverseModelTransform
scn_node.modelViewTransform
u_inverseModelViewTransform
scn_node.inverseModelViewTransform
scn_node.normalTransform
u_modelViewProjectionTransform
scn_node.modelViewProjectionTransform
u_inverseModelViewProjectionTransform
scn_node.inverseModelViewProjectionTransform
u_boundingBox
scn_node.boundingBox
u_worldBoundingBox
scn_node.worldBoundingBox
sampler1D
texture1d
sampler2D
texture2d
sampler3D
texture3d
samplerCube
texturecube
discard
discard_fragment()
gl_FragCoord
in.fragmentPosition
gl_FragColor
_output.color
gl_FrontFacing
isFrontFacing
filter::linear
texture1DProj
texture1DLod
texture1DProjLod
texture2D
texture2DLod
textureLod
texture2DProj
texture2DProjLod
texture3DProj
texture3DLod
texture3DProjLod
textureCubeLod
shadow1D
shadow1DProj
shadow1DLod
shadow1DProjLod
shadow2D
shadow2DProj
shadow2DLod
shadow2DProjLod
GetGLSLToMetalSampler
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Engine/AppleEngine/C3DShaderConverter.mm
it != mpStatics->mTextureFunc.end()
ParseUniform
mToken.mString == "uniform"
pragma
arguments
varyings
declaration
body
const
Parse
mpTokenizer == nullptr
while
#pragma arguments
#pragma body
#pragma declaration
.sample(
Sampler
, level(
, bias(
float2(
float3(
float4(
sampler 
Sampler
Error: Unable to resolve URL %@
http
niceDescription
presentation
mirror
empty
constaints
empty node
static
dynamic
kinematic
hinge
ballSocket
slider
drag
vortex
linear gravity
radial gravity
noise
turbulence
springField
electricField
magneticField
Shader source
back
front
aOne
zero
single layer
dual layer
physically based
plane
pyramid
sphere
cylinder
cone
tube
capsule
torus
floor
Hello!
perspective
vertical
horizontal
_shadowCascadeDebugFactor
Node
Shadable
Pass
Warning: arguments named %@ is reserved for type %d
vertexBuffer.
osdIndicesBuffer
osdTessellationLevel
osdVertexBuffer
osdFaceVaryingData
osdFaceVaryingIndices
osdFaceVaryingPatchParams
osdFaceVaryingPatchArray
vertexBuffer
patchParamBuffer
perPatchVertexBuffer
patchTessBuffer
scn_nodeInstances
Warning: unknown member in scn automated buffer : %@
Warning: struct member does not match pass description : %@
kExportPointOfViewAttribute
SCNExportSceneIdentifier
SCNExportMovieMirrored
SCNExportMovieSupersamplingFactor
SCNExportMovieFrameRate
SCNExportOperation : error not implemented
T@,N,V_delegate
T^v,N,V_userInfo
didEndSelector
T:,N,V_didEndSelector
T@"SCNScene",&,N,V_scene
T{CGSize=dd},N,V_size
Td,N,V_startTime
Td,N,V_endTime
progress
Td,N,V_progress
canceled
Tc,N,V_canceled
succeded
Tc,N,V_succeded
T@"NSDictionary",&,N,V_attributes
outputURL
T@"NSURL",&,N,V_outputURL
T@"NSError",&,N,V_error
TQ,N,V_antialiasingMode
T@"SCNRenderer",&,N,V_renderer
QTAddImageCodecType
QTMovieRateAttribute
Error: AVAssetWriter can't create a movie at %@ (error:%@)
Error: appendImage: failed to get a pixelBuffer from CVPixelBufferPoolRef
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DKit/utils/SCNExport.m
SceneKit: Couldn't create pixel buffer
Error: append pixel buffer failed
serial assetwriter input queue
Error: error while exporting movie: %@
v28@?0f8^{__CFError=}12^B20
B24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}16
v24@?0^{__C3DShapeBoundary=^{__C3DShapeVertex}IIddddi}8i16i20
C3DAppendPointToPath
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Primitives/Text/C3DShapeUtils.c
origin != C3DShapeVertexOriginCurveStart
C3DComputeLinesIntersection
denom != 0
C3DComputeLinesIntersectionForPoints
C3DShapeTriangulationCheckConsistency
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Primitives/Text/C3DShapeTriangulation.c
neighborB != t
neighborB != UNDEFINED_NEIGHBOR
neighborA == neighborB
neighborCount == 0
t->constrain[j] == false
neighborCount == 1
neighborA->neighbors[link] == t
neighborA->constrain[link] == t->constrain[j]
C3DShapeTriangulationTriangleContainingPoint
C3DLinkIndexFromTriangleToTriangle
C3DVertexNotSharedByTriangles
C3DShapeConnectedComponentTriangulatePseudopolygon
list->count > 1
C3DShapeTriangulationAddEdge
recycledTriangles.count == 0
C3DGlyphCreate
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Primitives/Text/C3DGlyph.c
shapeParams.cgPath == NULL
C3DGlyph
<C3DGlyph '%@' in '%@'>
C3DTextLine
<C3DTextLine>
C3DTextFrame
<C3DTextFrame>
Futura-Medium
C3DShape debug
v16@?0@?<v@?>8
v28@?0c8I12*16I24
v140@?0{__C3DShapeVertex={CGPoint=dd}{CGPoint=dd}{CGPoint=dd}{CGPoint=dd}dBi}8{CGPoint=dd}88f104{CGPoint=dd}108{CGPoint=dd}124
Error: C3DMeshCreateTextFrame: C3DTextFrameRef object is NULL, will create NULL mesh
Warning: Trying to draw a manipulator with no authoring environment set
v20@?0S8r^(C3DMatrix4x4=[16f][4]{?=[4]})12
_prepareSnapToAlignDataForAxis - unexpected axis
authoringEnvironment
T@"SCNAuthoringEnvironment",R
T@"NSOrderedSet",&,N
xAlignment
Tq,N,V_xAlignment
yAlignment
Tq,N,V_yAlignment
zAlignment
Tq,N,V_zAlignment
Tc,N,V_readonly
C3DSpokeCreate
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Primitives/Text/C3DShapeStraightSkeleton.c
CGPointEqualToPoint(origin, prev) == false
CGPointEqualToPoint(origin, next) == false
!isnan(spoke.direction.x)
!isnan(spoke.direction.y)
intersectionForSpokeAndSpoke
fabs(CGPointNorm(spoke1->direction) - 1) < epsilon
fabs(CGPointNorm(spoke2->direction) - 1) < epsilon
intersectionForSpokeAndEdge
spoke != edgeStart
spoke != edgeEnd
splitJoinFace
event.type == C3DStraightSkeletonEventSplit
spoke->boundaryOfVerticesIndex != INVALID_INDEX
other->boundaryOfVerticesIndex != INVALID_INDEX
d != INVALID_INDEX
f != INVALID_INDEX
C3DOffsetBuild
newFace.boundaries == NULL
C3DFXJitteringPassFloat.plist
SceneKit_JitterCopyFirstFrame
SceneKit_JitterToEven
SceneKit_JitterToOdd
SceneKit_JitterResolve
Copy_vert
Copy_frag
C3D-Copy
Add_vert
Add_frag
C3D-Add
C3D-jitter-factor-resolve
Mult_vert
Mult_frag
C3D-Mult_float
Error creating the xml writer
utf-8
Error at xmlTextWriterStartDocument
COLLADA
xmlns
http://www.collada.org/2005/11/COLLADASchema
1.4.1
Error at xmlTextWriterEndDocument
contributor
SceneKit Collada Exporter v1.0
Y_UP
Z_UP
X_UP
yyyy-MM-dd'T'HH:mm:ss'Z'
library_animations
library_animation_clips
effect_
%@%d
Warning: C3DIO(warn) _writeAnimationChannel: animation not supported - won't be exported
(%ld)
Error: can't find index of animated buffer component
Error: can't mix affine and matrices animations
can't mix euler and axisangle rotations
.ANGLE
transform animation not supported
_copyComponentForColor4Address
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DIO/collada/C3DIOColladaExport.c
offset<4
_copyComponentForMatrixAddress
offset<16
(%zd)(%zd)
_copyComponentForVector3Address
offset<3
_copyComponentForVector4Address
Warning: _writeSource - shared source detected (not supported)
Warning: _writeSource - shared accessor detected (not supported)
float_array
int_array
Name_array
%s-array
_writeArrayWithWriterFunc
ccpv == 1
Warning: _writeArrayWithWriterFunc: infinite double encountered
Warning: _writeArrayWithWriterFunc: infinite float encountered
_writeArrayWithWriterFunc: unknown array type
#%s-array
TIME
TRANSFORM
_writeAccessor
cpv <= sizeof(XYZWNames) / sizeof(char*)
cpv <= sizeof(RGBANames) / sizeof(char*)
cpv <= sizeof(STPQNames) / sizeof(char*)
cpv <= 1
param
HERMITE
_writeKeyframeAnimation: can't resolve animation path (root)
_writeKeyframeAnimation: can't resolve animation path
channel
%s/%s%s
SID_%d
animation_clip
instance_animation
library_cameras
optics
orthographic
xmag
library_lights
%g %g %g
constant_attenuation
linear_attenuation
quadratic_attenuation
falloff_angle
falloff_exponent
%g %g %g %g
probeParameters
tmpProbe
./no-path-found
Error: failed to generate a path for an image
instance_effect
#effect_%s
effect_%s
profile_COMMON
common
index_of_refraction
bump
newparam
_surface
Error: found a texture with no sampler
%s_%s
surface
CUBE
CLAMP
WRAP
BORDER
MIRROR
wrap_s
wrap_t
NONE
NEAREST
minfilter
magfilter
mipfilter
CHANNEL%d
library_geometries
Warning: geometry is partially double sided - not supported at export
%s-vertices
NORMAL
tristrips
TEXTANGENT
WEIGHT
#%s-vertices
%ld 
library_controllers
Warning: failed to find source of morph
controller
method
NORMALIZED
RELATIVE
%s-targets
IDREF_array
%s-targets-array
#%s-targets-array
MORPH_TARGET
IDREF
#%s-targets
MORPH_WEIGHT
bind_shape_matrix
vertex_weights
%d %ld 
%.7g 
library_visual_scenes
instance_visual_scene
instance_camera
instance_light
lightmap_path=%s
uv_set=%d
Warning: invalid light map info - not exported
translate
rotate
0 0 1 %g
0 1 0 %g
1 0 0 %g
instance_controller
instance_geometry
bind_material
instance_material
symbol
bind_vertex_input
input_semantic
input_set
draw
ignoreFloors
onlyShadowCasters
onlyMovableNodes
hasConstantAlpha
installViewport
includeCategoryMask
excludeCategoryMask
viewport
samples
colorStates
clearColor
sceneBackground
clear
depthStates
enableWrite
enableRead
func
stencilStates
behavior
backFaceBehavior
blendStates
Error: too many blend states: max render target is %d
Warning: can't create a fbo description for pass %@ - can't find pass description with name %@
Error: failed to load program %@
Error: failed to load program %@ %@
C3DFXPassInput
<C3DFXPassInput %@>
symbolName
uniformName
C3DFXPass
<C3DFXPass %@>
nameToInput
draw_scene
draw_node
draw_nodes
draw_geometry
draw_quad
metal_custom
draw_none
custom
preDraw
preFX
preToneMap
postFX
cullNone
Error: unknown cull mode named %@
never
always
equal
notEqual
less
lessEqual
greater
greaterEqual
Error: unknown depth comparison function named %@
depthFail
fail
pass
readMask
writeMask
referenceValue
keep
replace
increment
decrement
invert
incrementWrap
decrementWrap
colorSrc
colorDst
alphaSrc
alphaDst
colorOp
alphaOp
oneMinusSrcColor
oneMinusSrcAlpha
oneMinusDstColor
oneMinusDstAlpha
constantColor
oneMinusConstantColor
constantAlpha
oneMinusConstantAlpha
alphaSaturate
Error: unknown blend factor named %@
substract
reverseSubstract
Error: unknown blend op named %@
mipmapped
scaleFactor
%fx%f
texture_rectangle
color0
color1
color2
color3
stencil
Error: _bufferTypeFromName - unknown output type: %@
format
Warning: unknown texture format : %@
DEPTH
Error: description for input named %@ is missing
Error: 'type' is required for symbol %@
tangent
modelViewProjectionInverseTransform
modelViewInverseTransform
modelInverseTransform
viewInverseTransform
projectionInverseTransform
normalInverseTransform
Warning: symbol named %@ should be in "targets" not "symbols"
Warning: _convertOutputsDescriptionToOutputs - can't find output named %@
global
persistent
Error: _convertOutputsDescriptionToOutputs - unknown output type: %@
Error: _convertSlotToAttachmentID : unknown slot
Error: C3DRenderBufferGetSlotForOutputBufferType : unsupported type %d
C3DRenderTarget
<C3DRenderTarget %p - texture:%@ rbo:%d>
C3D-Add.fsh
C3D-wireframe.vsh
C3D-DefaultProgram.fsh
C3D-EnvMap2D.fsh
C3D-Copy.vsh
C3D-dof-Resolve.vsh
C3D-CommonProfile_probes_sh.metal
C3D-dof-downSample4x.vsh
C3D-GaussianBlur.vsh
C3D-Particles.metal
C3DManipulator.vsh
C3D-GaussianBlurAlpha.fsh
C3D-IncrementalAverage.vsh
C3DFXJitteringPass.plist
C3D-dof_depracted.metal
C3D-Histogram.metal
C3D-DeferredShadingCommon.h
C3D-OutlineMax.vsh
C3D-DeferredShading_Lighting.metal
C3D-spotShadow.vsh
C3D-BlendAuthoring.vsh
C3D-Copy.fsh
C3D-OutlineRetina.vsh
C3D-CIFilterComposite.fsh
C3D-DrawQuad.h
C3D-EnvMap2D.vsh
C3DFXMotionBlur.plist
C3D-Morph.metal
C3DManipulator.fsh
C3D-CIFilter.metal
C3D-DeferredShadow.metal
C3D-Outline.vsh
C3D-DeferredShading_Debug.metal
C3D-dof-ComputeNearCoc.fsh
C3D-PBR_compute.metal
C3D-VertexTransform.metal
C3D-GaussianBlurAlpha.vsh
C3D-Tessellation.metal
C3D-WarmupTexture.vsh
C3D-PickedObjects.vsh
C3D-ParticlesUber.metal
C3D-spotShadow.metal
C3D-OutlineMax.fsh
C3D-Background.metal
C3D-IncrementalAverage.fsh
C3D-spotShadow.fsh
C3D-CubemapUtils.metal
C3D-BlendAuthoring.fsh
C3D-EnvMapCube.vsh
C3D-CIFilterComposite.vsh
C3D-SuperSampling.metal
C3DManipulatorLightProbe.vsh
C3D-DrawQuad.metal
C3DFXDOFPass_deprecated.plist
C3D-Tessellation.h
C3D-dof-ComputeNearCoc.vsh
C3D-GaussianBlur.metal
C3D-dof-generateNearCoc.fsh
C3D-WarmupTexture.fsh
C3DFXCopyPass.plist
SCNShaderLightingContribution.glsl
C3D-DeferredShading_N.metal
C3DManipulatorColorOnly.vsh
C3D-OpenSubdiv_SkinMorph.metal
C3D-SuperSampling.h
C3D-MeshUtils.metal
C3D-Histogram.h
C3D-Jittering.metal
C3D-Mult_float.fsh
C3D-EnvMapCube.fsh
C3D-dof-Resolve.fsh
C3D-SSAO.h
C3D-Debug.metal
C3D-dof-Blur5x5.fsh
C3D-Outline.metal
C3D-ParticleSystem_Trail.vsh
C3D-PostProcess.metal
C3DManipulatorColorAndTexture.fsh
C3D-wireframe.fsh
C3D-DefaultProgram.vsh
C3DManipulatorLightProbe.fsh
C3D-dof-generateNearCoc.vsh
C3D-PickedObjects.fsh
C3D-PostProcessUtils.h
C3D-dof-downSample4x.fsh
C3D-Mult_float.vsh
C3D-Add.vsh
C3D-SphericalHarmonics.metal
C3D-ParticleSystem.fsh
C3D-Default.metal
C3D-dof-Blur5x5.vsh
C3D-DeferredShading.metal
C3D-GaussianBlur.fsh
C3DManipulatorColorOnly.fsh
C3D-SSAO.metal
C3D-Reduce.metal
C3D-PostProcess.h
C3D-MotionBlur.metal
C3D-AuthoringEnvironment.metal
C3D-ParticleSystem.vsh
C3D-Outline.fsh
C3D-OutlineRetina.fsh
C3D-ParticleSystem_Trail.fsh
C3D-ColorGrading.metal
C3DManipulatorColorAndTexture.vsh
C3D-Background.h
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(textureSampler0,TexCoord) + texture2D(textureSampler1,TexCoord);
uniform mat4 u_modelViewProjectionTransform;
attribute vec4 a_position;
attribute vec4 a_color;
varying vec3 v_vertexCenter;
void main()
    vec3 pos = a_position.xyz;
    int id = int(a_position.w); //  Position stores the vertex ID in the current triangle. Yup, a bit ugly.
    gl_Position = (u_modelViewProjectionTransform * vec4(pos, 1.0));
    
    float s = 1.;
    mat3 centers = mat3(vec3(s, 0. ,0.), vec3(0., s, 0.), vec3(0., 0., s));
    v_vertexCenter = centers[id];
void main (void)
gl_FragColor =
vec4(1.0,0.0,1.0,1.0);
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord);
attribute vec3 a_position;
varying vec2 TexCoord;
void main(void)
gl_Position = vec4(a_position, 1.0);
TexCoord = (a_position.xy + 1.0) * 0.5;
attribute vec4 a_position;
varying vec2 v_texCoord;
void main(void)
gl_Position = a_position;
    v_texCoord = (a_position.xy + 1.0) * 0.5;
#import <metal_stdlib>
using namespace metal;
// Include do not work in online compilation...
//#import <SceneKit/scn_metal>
// All this declarations should be in the "scn_metal" file
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3,
    SCNVertexSemanticTexcoord4,
    SCNVertexSemanticTexcoord5,
    SCNVertexSemanticTexcoord6,
    SCNVertexSemanticTexcoord7
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; // transform from view space to world space
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; // transform from view space to cube texture space (canonical Y Up space)
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; // x:-1/(end-start) y:1-start*x z:exp
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
// end "scn_metal"
// Tool function
inline float3x3 mat3(float4x4 mat4)
    return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);
inline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
inline float shadow2DProj(depth2d<float> tex, float4 uv)
    constexpr sampler linear_sampler(filter::linear, mip_filter::none, compare_func::greater_equal);
    //constexpr sampler linear_sampler(filter::linear, mip_filter::none, compare_func::none);
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(linear_sampler, uvp.xy, uvp.z);
// these are SH coef for a single component
struct sh2_vector
    float4 V;
struct sh3_vector
    float4 V0;
    float4 V1;
    float V2;
// these are packed SH3 for RGB components
struct sh2_coefficients
    sh2_vector R;
    sh2_vector G;
    sh2_vector B;
#define USE_PACKED_SH3 1
#if USE_PACKED_SH3
struct sh3_coefficients
    float4 ar;
    float4 ag;
    float4 ab;
    float4 br;
    float4 bg;
    float4 bb;
    float4 c;
#else
struct sh3_coefficients
    sh3_vector R;
    sh3_vector G;
    sh3_vector B;
#endif
constant half PI = 3.141592653f;
inline half sh3_dot(sh3_vector A,sh3_vector B)
    half Result = dot(A.V0, B.V0);
    Result += dot(A.V1, B.V1);
    Result += A.V2 * B.V2;
    return Result;
inline half3 sh3_dot(sh3_coefficients A,sh3_vector B)
    half3 Result = 0;
    sh3_vector rsh;
    rsh.V0 = A.ar;
    rsh.V1 = A.br;
    rsh.V2 = A.c.x;
    sh3_vector gsh;
    gsh.V0 = A.ag;
    gsh.V1 = A.bg;
    gsh.V2 = A.c.y;
    sh3_vector bsh;
    bsh.V0 = A.ab;
    bsh.V1 = A.bb;
    bsh.V2 = A.c.z;
    Result.r = sh3_dot(rsh,B);
    Result.g = sh3_dot(gsh,B);
    Result.b = sh3_dot(bsh,B);
    return Result;
inline half3 sh2_dot(sh2_coefficients A,sh2_vector B)
    half3 Result = 0;
    Result.r = dot(A.R.V, B.V);
    Result.g = dot(A.G.V, B.V);
    Result.b = dot(A.B.V, B.V);
    return Result;
inline sh2_vector sh2_basis(half3 dir)
    sh2_vector res;
    res.V.x = 0.282095f;
    res.V.y = -0.488603f * dir.y;
    res.V.z = 0.488603f * dir.z;
    res.V.w = -0.488603f * dir.x;
    return res;
inline sh3_vector sh3_basis(half3 dir)
    sh3_vector res;
    res.V0.x = 0.282095f;
    res.V0.y = -0.488603f * dir.y;
    res.V0.z = 0.488603f * dir.z;
    res.V0.w = -0.488603f * dir.x;
    
    half3 VectorSquared = dir * dir;
    res.V1.x = 1.092548f * dir.x * dir.y;
    res.V1.y = -1.092548f * dir.y * dir.z;
    res.V1.z = 0.315392f * (3.0f * VectorSquared.z - 1.0f);
    res.V1.w = -1.092548f * dir.x * dir.z;
    res.V2 = 0.546274f * (VectorSquared.x - VectorSquared.y);
    return res;
inline sh2_vector sh2_compute_diffuse_transfer(half3 normal, half Exponent)
    sh2_vector res = sh2_basis(normal);
    half L0 = 2 * PI / (1 + 1 * Exponent);
    half L1 = 2 * PI / (2 + 1 * Exponent);
    res.V.x *= L0;
    res.V.yzw *= L1;
    return res;
inline sh3_vector sh3_compute_diffuse_transfer(half3 normal, half Exponent)
    sh3_vector res = sh3_basis(normal);
    half L0 =
2 * PI / (1 + 1 * Exponent
    half L1 =
2 * PI / (2 + 1 * Exponent
    half L2 = Exponent *
2 * PI / (3 + 4 * Exponent + Exponent * Exponent
    res.V0.x *= L0;
    res.V0.yzw *= L1;
    res.V1.xyzw *= L2;
    res.V2 *= L2;
    return res;
#if (USE_PROBES_LIGHTING == 2)
inline float3 shEvalDirection(float4 dir, sh2_coefficients cachedSH)
    const float Exponent = 1;
    
    // Compute SH for the normal
    sh2_vector diffSH = sh2_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    // Compute lighting for this SH directions
    half3 lighting = max(half3(0,0,0), sh2_dot(cachedSH, diffSH)) / PI;
    
    //    lighting = half3(diffSH.V0.yzw * 0.5 + 0.5);
    
    return float3(lighting);
#elif (USE_PROBES_LIGHTING == 3)
#if USE_PACKED_SH3
inline float3 shEvalDirection(float4 dir, sh3_coefficients sh)
    float3 x1, x2, x3;
    
    // Linear + constant polynomial terms
    x1.r = dot(sh.ar, dir);
    x1.g = dot(sh.ag, dir);
    x1.b = dot(sh.ab, dir);
    
    // 4 of the quadratic polynomials
    float4 vB = dir.xyzz * dir.yzzx;
    x2.r = dot(sh.br, vB);
    x2.g = dot(sh.bg, vB);
    x2.b = dot(sh.bb, vB);
    
    // Final quadratic polynomial
    float vC = dir.x * dir.x - dir.y * dir.y;
    x3 = sh.c.xyz * vC;
    
    return x1 + x2 + x3;
#else
inline float3 shEvalDirection(float4 dir, sh3_coefficients cachedSH)
    const float Exponent = 1;
    
    // Compute SH for the normal
    sh3_vector diffSH = sh3_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    // Compute lighting for this SH directions
    half3 lighting = max(half3(0,0,0), DotSH3(cachedSH, diffSH)) / PI;
    
    //    lighting = half3(diffSH.V0.yzw * 0.5 + 0.5);
    
    return float3(lighting);
#endif // USE_PACKED_SH3
#endif // USE_PROBES_LIGHTING
// Inputs
typedef struct {
#ifdef USE_MODELTRANSFORM
    float4x4 modelTransform;
#endif
#ifdef USE_INVERSEMODELTRANSFORM
    float4x4 inverseModelTransform;
#endif
#ifdef USE_MODELVIEWTRANSFORM
    float4x4 modelViewTransform;
#endif
#ifdef USE_INVERSEMODELVIEWTRANSFORM
    float4x4 inverseModelViewTransform;
#endif
#ifdef USE_NORMALTRANSFORM
    float4x4 normalTransform;
#endif
#ifdef USE_MODELVIEWPROJECTIONTRANSFORM
    float4x4 modelViewProjectionTransform;
#endif
#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM
    float4x4 inverseModelViewProjectionTransform;
#endif
#ifdef USE_BOUNDINGBOX
    float2x3 boundingBox;
#endif
#ifdef USE_WORLDBOUNDINGBOX
    float2x3 worldBoundingBox;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    float orientationPreserved;
#endif
#ifdef USE_SKINNING
    float4 skinningJointMatrices[60]; // Consider having a separate buffer ?
#endif
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
    sh2_coefficients shCoefficients;
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
    sh3_coefficients shCoefficients;
#endif
    
} commonprofile_node;
typedef struct {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
    float4 color            [[attribute(SCNVertexSemanticColor)]];
    float4 skinningWeights  [[attribute(SCNVertexSemanticBoneWeights)]];
    uint4  skinningJoints   [[attribute(SCNVertexSemanticBoneIndices)]];
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];
    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];
    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];
    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];
} commonprofile_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 fragmentPosition [[position]]; // The window relative coordinate (x, y, z, 1/w) values for the fragment
#ifdef USE_VERTEX_COLOR
    float4 vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
    float3 diffuse;
#ifdef USE_SPECULAR
    float3 specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    float3 position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
    float3 normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    float3 tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    float3 bitangent;
#endif
#ifdef USE_TEXCOORD
    __TexcoordDecl__
#endif
} commonprofile_io;
struct SCNShaderSurface {
    float3 view;                // Direction from the point on the surface toward the camera (V)
    float3 position;            // Position of the fragment
    float3 normal;              // Normal of the fragment (N)
    float2 normalTexcoord;      // Normal texture coordinates
    float3 tangent;             // Tangent of the fragment
    float3 bitangent;           // Bitangent of the fragment
    float4 ambient;             // Ambient property of the fragment
    float2 ambientTexcoord;     // Ambient texture coordinates
    float4 diffuse;             // Diffuse property of the fragment. Alpha contains the opacity.
    float2 diffuseTexcoord;     // Diffuse texture coordinates
    float4 specular;            // Specular property of the fragment
    float2 specularTexcoord;    // Specular texture coordinates
    float4 emission;            // Emission property of the fragment
    float2 emissionTexcoord;    // Emission texture coordinates
    float4 multiply;            // Multiply property of the fragment
    float2 multiplyTexcoord;    // Multiply texture coordinates
    float4 transparent;         // Transparent property of the fragment
    float2 transparentTexcoord; // Transparent texture coordinates
    float4 reflective;          // Reflective property of the fragment
    float shininess;            // Shininess property of the fragment.
    float fresnel;              // Fresnel property of the fragment.
    float3 _normalTS;           // UNDOCUMENTED in tangent space
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderLightingContribution {
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
inline float4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float4 color = {0.,0.,0., surface.diffuse.a};
    
    float3 D = lighting.diffuse;
#ifdef USE_AMBIENT_LIGHTING
    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
        D += lighting.ambient * surface.ambient.rgb;
    #elif defined(LOCK_AMBIENT_WITH_DIFFUSE)
        D += lighting.ambient;
    #endif
#endif //  defined(USE_AMBIENT_LIGHTING)
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    // Do we want to clamp there ????
    color.rgb = surface.diffuse.rgb * D;
#if 1 // NEW_REFLECTIVE_BEHAVIOR
#ifdef USE_SPECULAR
    float3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    float3 S = float3(0.);
#endif
#ifdef USE_REFLECTIVE
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    S += surface.reflective.rgb * surface.ambient.rgb;
#else
    S += surface.reflective.rgb;
#endif
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
    color.rgb += S;
#endif
#else
#ifdef USE_SPECULAR
    color.rgb += surface.specular.rgb * lighting.specular;
#endif
#ifdef USE_REFLECTIVE
    color.rgb += surface.reflective.rgb * (lighting.diffuse + lighting.ambient);
#endif
#endif // NEW_REFLECTIVE_BEHAVIOR
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
// Structure to gather property of a light, packed to give access in a light shader modifier
struct SCNShaderLight {
    float4 intensity; // lowp, light intensity
    float3 direction; // mediump, vector from the point toward the light
    float  _att;
    float3 _spotDirection; // lowp, vector from the point to the light for point and spot, dist attenuations
    float  _distance; // mediump, distance from the point to the light (same coord. than range)
struct  commonprofile_lights {
#ifdef USE_LIGHTING
    __LightingDecl__
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float2 texcoords[8]; // MAX_UV
struct  commonprofile_uniforms {
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    
    float materialShininess;
    float transparency;
    float3 fresnel; // x: ((n1-n2)/(n1+n2))^2 y:1-x z:exponent
#ifdef TEXTURE_TRANSFORM_COUNT
    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
//    float4x4 u_viewToCubeWorld;
#endif
// Shader modifiers declaration (only enabled if one modifier is present)
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
// Vertex shader function
vertex commonprofile_io commonprofile_vert(commonprofile_vertex_t in [[ stage_in ]],
                                           constant SCNSceneBuffer& scn_frame [[buffer(0)]],
#ifdef USE_INSTANCING
                                           constant commonprofile_node* scn_node [[buffer(1)]]
                                           , uint instanceID [[ instance_id ]]
#else
                                           constant commonprofile_node& scn_node [[buffer(1)]]
#endif
#ifdef USE_PER_VERTEX_LIGHTING
                                           , constant commonprofile_lights& scn_lights [[buffer(2)]]
#endif
// used for texture transform and materialShininess in case of perVertexLighting
                                           , constant commonprofile_uniforms& scn_commonprofile [[buffer(3)]]
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
__VertexExtraArguments__
#endif
                                           )
    SCNShaderGeometry _geometry;
    // OPTIM in could be already float4?
    _geometry.position = float4(in.position, 1.0);
#ifdef USE_NORMAL
    _geometry.normal = in.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = in.tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = in.texcoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = in.texcoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = in.texcoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = in.texcoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = in.texcoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = in.texcoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = in.texcoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = in.texcoord7;
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = in.color;
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
    
#ifdef USE_SKINNING
    {
        float3 pos = 0.0;
#ifdef USE_NORMAL
        float3 nrm = 0.0;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        float3 tgt = 0.0;
#endif
        for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
            float weight = 1.0;
#else
            float weight = in.skinningWeights[i];
#endif
            int idx = int(in.skinningJoints[i]) * 3;
            float4x4 jointMatrix = float4x4(scn_node.skinningJointMatrices[idx],
                                            scn_node.skinningJointMatrices[idx+1],
                                            scn_node.skinningJointMatrices[idx+2],
                                            float4(0., 0., 0., 1.));
            
            pos += (_geometry.position * jointMatrix).xyz * weight;
#ifdef USE_NORMAL
            nrm += _geometry.normal * mat3(jointMatrix) * weight;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * mat3(jointMatrix) * weight;
#endif
        }
        
        _geometry.position.xyz = pos;
#ifdef USE_NORMAL
        _geometry.normal = nrm;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        _geometry.tangent.xyz = tgt;
#endif
    }
#endif
    
#ifdef USE_GEOMETRY_MODIFIER
// DoGeometryModifier START
__DoGeometryModifier__
// DoGeometryModifier END
#endif
    
#ifdef USE_INSTANCING
    constant commonprofile_node& node = scn_node[instanceID];
#else
    constant commonprofile_node& node = scn_node;
#endif
    
    // Transform the geometry elements in view space
#if defined(USE_POSITION) || defined(USE_NORMAL) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)
    SCNShaderSurface _surface;
#endif
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    _surface.position = (node.modelViewTransform * _geometry.position).xyz;
#endif
#ifdef USE_NORMAL
    _surface.normal = normalize(mat3(node.normalTransform) * _geometry.normal);
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _surface.tangent = normalize(mat3(node.normalTransform) * _geometry.tangent.xyz);
    _surface.bitangent = /*_geometry.tangent.w **/ cross(_surface.tangent, _surface.normal); // no need to renormalize since tangent and normal should be orthogonal
    // old code : _surface.bitangent =  normalize(cross(_surface.normal,_surface.tangent));
#endif
    
    //if USE_VIEW is 2 we may also need to set _surface.view. todo: make USE_VIEW a mask
#ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
#endif
    commonprofile_io out;
    
#ifdef USE_PER_VERTEX_LIGHTING
    // Lighting
    SCNShaderLightingContribution _lightingContribution;
    _lightingContribution.diffuse = 0.;
  #ifdef USE_SPECULAR
    _lightingContribution.specular = 0.;
    _surface.shininess = scn_commonprofile.materialShininess;
  #endif
__VertexDoLighting__
    out.diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
    out.specular = _lightingContribution.specular;
  #endif
#endif
    
#if defined(USE_POSITION) && (USE_POSITION == 2)
    out.position = _surface.position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
    out.normal = _surface.normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    out.tangent = _surface.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    out.bitangent = _surface.bitangent;
#endif
#ifdef USE_VERTEX_COLOR
    out.vertexColor = _geometry.color;
#endif
#ifdef USE_TEXCOORD
__VertexDoTexcoord__
#endif
    
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);
#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) // this means that the geometry are still in model space : we can transform it directly to NDC space
    out.fragmentPosition = node.modelViewProjectionTransform * _geometry.position;
#endif
    
    return out;
struct SCNOutput
    float4 color;
// Fragment shader function
fragment half4 commonprofile_frag(commonprofile_io in [[stage_in]],
                                  constant commonprofile_uniforms& scn_commonprofile [[buffer(0)]],
                                  constant SCNSceneBuffer& scn_frame [[buffer(1)]]
#ifdef USE_PER_PIXEL_LIGHTING
                                  , constant commonprofile_lights& scn_lights [[buffer(2)]]
#endif
#ifdef USE_EMISSION_MAP
                                  , texture2d<float> u_emissionTexture [[texture(0)]]
                                  , sampler          u_emissionTextureSampler [[sampler(0)]]
#endif
#ifdef USE_AMBIENT_MAP
                                  , texture2d<float> u_ambientTexture [[texture(1)]]
                                  , sampler          u_ambientTextureSampler [[sampler(1)]]
#endif
#ifdef USE_DIFFUSE_MAP
                                  , texture2d<float> u_diffuseTexture [[texture(2)]]
                                  , sampler          u_diffuseTextureSampler [[sampler(2)]]
#endif
#ifdef USE_SPECULAR_MAP
                                  , texture2d<float> u_specularTexture [[texture(3)]]
                                  , sampler          u_specularTextureSampler [[sampler(3)]]
#endif
#ifdef USE_REFLECTIVE_MAP
                                  , texture2d<float> u_reflectiveTexture [[texture(4)]]
                                  , sampler          u_reflectiveTextureSampler [[sampler(4)]]
#elif defined(USE_REFLECTIVE_CUBEMAP)
                                  , texturecube<float> u_reflectiveTexture [[texture(4)]]
                                  , sampler            u_reflectiveTextureSampler [[sampler(4)]]
#endif
#ifdef USE_TRANSPARENT_MAP
                                  , texture2d<float> u_transparentTexture [[texture(5)]]
                                  , sampler          u_transparentTextureSampler [[sampler(5)]]
#endif
#ifdef USE_MULTIPLY_MAP
                                  , texture2d<float> u_multiplyTexture [[texture(6)]]
                                  , sampler          u_multiplyTextureSampler [[sampler(6)]]
#endif
#ifdef USE_NORMAL_MAP
                                  , texture2d<float> u_normalTexture [[texture(7)]]
                                  , sampler          u_normalTextureSampler [[sampler(7)]]
#endif
                                  , constant commonprofile_node& scn_node [[buffer(3)]]
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
__FragmentExtraArguments__
#endif
#if defined(USE_DOUBLE_SIDED)
                                  , bool isFrontFacing [[front_facing]]
#endif
                                  )
    SCNShaderSurface _surface;
#ifdef USE_TEXCOORD
__FragmentDoTexcoord__
#endif
#ifdef USE_AMBIENT_MAP
    _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
#ifdef USE_AMBIENT_INTENSITY
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    _surface.ambient.rgb = mix(float3(1.), _surface.ambient.rgb, scn_commonprofile.ambientIntensity);
#else
    _surface.ambient.rgb *= scn_commonprofile.ambientIntensity;
#endif
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = scn_commonprofile.ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = float4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= in.vertexColor;
#endif
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = scn_commonprofile.diffuseColor;
#else
    _surface.diffuse = float4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= in.vertexColor;
#endif
#ifdef USE_SPECULAR_MAP
    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular.rgb *= scn_commonprofile.specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = scn_commonprofile.specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = float4(0.);
#endif
#ifdef USE_EMISSION_MAP
    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission.rgb *= scn_commonprofile.emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = scn_commonprofile.emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = float4(0.);
#endif
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply.rgb = mix(float3(1.), _surface.multiply.rgb, scn_commonprofile.multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = scn_commonprofile.multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = float4(1.);
#endif
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= scn_commonprofile.transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = scn_commonprofile.transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = float4(1.);
#endif
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.normal = normalize(in.normal.xyz) * scn_node.orientationPreserved * ((float(isFrontFacing) * 2.0) - 1.0);
#else
    _surface.normal = normalize(in.normal.xyz);
#endif
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = in.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = in.bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = in.position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-in.position);
#endif
#ifdef USE_NORMAL_MAP
    float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb * 2. - 1.;
    // _surface.normal.z = 1. - sqrt(_surface.normal.x * _surface.normal.x + _surface.normal.y * _surface.normal.y);
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(float3(0., 0., 1.), _surface._normalTS, scn_commonprofile.normalIntensity);
#endif
    // transform the normal in view space
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = float3(0.);
#endif
    
#ifdef USE_REFLECTIVE_MAP
    float3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5);
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    float3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); // sample the cube map in world space
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = scn_commonprofile.reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = float4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.0 - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = scn_commonprofile.materialShininess;
#endif
    
#ifdef USE_SURFACE_MODIFIER
// DoSurfaceModifier START
__DoSurfaceModifier__
// DoSurfaceModifier END
#endif
    // Lighting
    SCNShaderLightingContribution _lightingContribution = {0};
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
#ifdef USE_PROBES_LIGHTING
    _lightingContribution.diffuse = shEvalDirection(float4(scn::mat4_mult_float3(scn_frame.viewToCubeTransform, _surface.normal), 1.), scn_node.shCoefficients);
#else
    _lightingContribution.diffuse = float3(0.);
#endif
#ifdef USE_MODULATE
    _lightingContribution.modulate = float3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = float3(0.);
#endif
__FragmentDoLighting__
#else // USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = in.diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = in.specular;
#endif
#endif
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
#ifdef USE_SPECULAR
    _lightingContribution.specular = saturate(_lightingContribution.specular);
#endif // USE_SPECULAR
#endif // AVOID_OVERLIGHTING
#else // USE_LIGHTING
    _lightingContribution.diffuse = float3(1.);
#endif // USE_LIGHTING
    
    // Combine
    SCNOutput _output;
    _output.color = illuminate(_surface, _lightingContribution);
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
#endif
    
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
#ifdef USE_TRANSPARENT // Either a map or a color
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= scn_commonprofile.transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= scn_node.nodeOpacity;
#endif
    // compute luminance
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (float4(1.) - _surface.transparent);
#else // ALPHA_ONE
#ifdef USE_NODE_OPACITY
    _output.color *= (scn_node.nodeOpacity * _surface.transparent.a);
#else
    _output.color *= _surface.transparent.a;
#endif
#endif
#else
#ifdef USE_TRANSPARENCY // TRANSPARENCY without TRANSPARENT slot (nodeOpacity + diffuse.a)
#ifdef USE_NODE_OPACITY
    _output.color *= (scn_node.nodeOpacity * scn_commonprofile.transparency);
#else
    _output.color *= scn_commonprofile.transparency;
#endif // NODE_OPACITY
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
// DoFragmentModifier START
__DoFragmentModifier__
// DoFragmentModifier END
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) // we could set a different limit here
        discard_fragment();
#endif
    
    return half4(_output.color);
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    v_tcColor0 = tc + vec2( -1.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcColor1 = tc + vec2( +0.5, -1.5) * u_inversePixelSize * 0.25;
    v_tcDepth0 = tc + vec2( -2., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth1 = tc + vec2( -1., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth2 = tc + vec2( +0., -2. ) * u_inversePixelSize * 0.25;
    v_tcDepth3 = tc + vec2( +1., -2. ) * u_inversePixelSize * 0.25;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-PBR.metal"
#import "scn_tesselation.h"
// Inputs
typedef struct {
#ifdef USE_MODELTRANSFORM
    float4x4 modelTransform;
#endif
#ifdef USE_INVERSEMODELTRANSFORM
    float4x4 inverseModelTransform;
#endif
#ifdef USE_MODELVIEWTRANSFORM
    float4x4 modelViewTransform;
#endif
#ifdef USE_INVERSEMODELVIEWTRANSFORM
    float4x4 inverseModelViewTransform;
#endif
#ifdef USE_NORMALTRANSFORM
    float4x4 normalTransform;
#endif
#ifdef USE_MODELVIEWPROJECTIONTRANSFORM
    float4x4 modelViewProjectionTransform;
#endif
#ifdef USE_INVERSEMODELVIEWPROJECTIONTRANSFORM
    float4x4 inverseModelViewProjectionTransform;
#endif
#ifdef USE_MOTIONBLUR
    float4x4 lastFrameModelViewProjectionTransform;
    float motionBlurIntensity;
#endif
#ifdef USE_BOUNDINGBOX
    float2x3 boundingBox;
#endif
#ifdef USE_WORLDBOUNDINGBOX
    float2x3 worldBoundingBox;
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    float orientationPreserved;
#endif
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
    sh2_coefficients shCoefficients;
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
    sh3_coefficients shCoefficients;
#endif
#ifdef USE_SKINNING // need to be last since we may cut the buffer size based on the real bone number
    float4 skinningJointMatrices[765]; // Consider having a separate buffer ?
#endif
} commonprofile_node;
typedef struct {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
#ifdef HAS_NORMAL
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
#endif
#ifdef USE_TANGENT
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 color            [[attribute(SCNVertexSemanticColor)]];
#endif
#ifdef USE_SKINNING
    float4 skinningWeights  [[attribute(SCNVertexSemanticBoneWeights)]];
    uint4  skinningJoints   [[attribute(SCNVertexSemanticBoneIndices)]];
#endif
#ifdef NEED_IN_TEXCOORD0
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
#endif
#ifdef NEED_IN_TEXCOORD1
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
#endif
#ifdef NEED_IN_TEXCOORD2
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
#endif
#ifdef NEED_IN_TEXCOORD3
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
#endif
#ifdef NEED_IN_TEXCOORD4
    float2 texcoord4        [[attribute(SCNVertexSemanticTexcoord4)]];
#endif
#ifdef NEED_IN_TEXCOORD5
    float2 texcoord5        [[attribute(SCNVertexSemanticTexcoord5)]];
#endif
#ifdef NEED_IN_TEXCOORD6
    float2 texcoord6        [[attribute(SCNVertexSemanticTexcoord6)]];
#endif
#ifdef NEED_IN_TEXCOORD7
    float2 texcoord7        [[attribute(SCNVertexSemanticTexcoord7)]];
#endif
} scn_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 fragmentPosition [[position]]; // The window relative coordinate (x, y, z, 1/w) values for the fragment
#ifdef USE_POINT_RENDERING
    float fragmentSize [[point_size]];
#endif
#ifdef USE_VERTEX_COLOR
    float4 vertexColor;
#endif
#ifdef USE_PER_VERTEX_LIGHTING
    float3 diffuse;
#ifdef USE_SPECULAR
    float3 specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
    float3 position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && (defined(HAS_NORMAL) || defined(USE_OPENSUBDIV))
    float3 normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    float3 tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    float3 bitangent;
#endif
#ifdef USE_DISPLACEMENT_MAP
    float2 displacementTexcoord;   // Displacement texture coordinates
#endif
#ifdef USE_NODE_OPACITY
    float nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    float orientationPreserved;
#endif
#ifdef USE_TEXCOORD
    __TexcoordDecl__
#endif
    
#ifdef USE_EXTRA_VARYINGS
    __ExtraVaryingsDecl__
#endif
    
#ifdef USE_MOTIONBLUR
    float3 velocity;// [[ center_no_perspective ]];
#endif
#ifdef USE_OUTLINE
float outlineHash [[ flat ]];
#endif
} commonprofile_io;
struct SCNShaderSurface {
    float3 view;                // Direction from the point on the surface toward the camera (V)
    float3 position;            // Position of the fragment
    float3 normal;              // Normal of the fragment (N)
    float3 geometryNormal;      // Normal of the fragment - not taking into account normal map
    float2 normalTexcoord;      // Normal texture coordinates
    float3 tangent;             // Tangent of the fragment
    float3 bitangent;           // Bitangent of the fragment
    float4 ambient;             // Ambient property of the fragment
    float2 ambientTexcoord;     // Ambient texture coordinates
    float4 diffuse;             // Diffuse property of the fragment. Alpha contains the opacity.
    float2 diffuseTexcoord;     // Diffuse texture coordinates
    float4 specular;            // Specular property of the fragment
    float2 specularTexcoord;    // Specular texture coordinates
    float4 emission;            // Emission property of the fragment
    float2 emissionTexcoord;    // Emission texture coordinates
    float4 selfIllumination;            // selfIllumination property of the fragment
    float2 selfIlluminationTexcoord;    // selfIllumination texture coordinates
    float4 multiply;            // Multiply property of the fragment
    float2 multiplyTexcoord;    // Multiply texture coordinates
    float4 transparent;         // Transparent property of the fragment
    float2 transparentTexcoord; // Transparent texture coordinates
    float4 reflective;          // Reflective property of the fragment
    float  metalness;           // Metalness
    float2 metalnessTexcoord;   // Metalness texture coordinates
    float  roughness;           // Roughness
    float2 roughnessTexcoord;   // Roughness texture coordinates
    float shininess;            // Shininess property of the fragment.
    float fresnel;              // Fresnel property of the fragment.
    float ambientOcclusion;     // Ambient occlusion term of the fragment
    float3 _normalTS;           // UNDOCUMENTED in tangent space
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderLightingContribution {
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
// Structure to gather property of a light, packed to give access in a light shader modifier
struct SCNShaderLight {
    float4 intensity; // lowp, light intensity
    float3 direction; // mediump, vector from the point toward the light
    float  _att;
    float3 _spotDirection; // lowp, vector from the point to the light for point and spot, dist attenuations
    float  _distance; // mediump, distance from the point to the light (same coord. than range)
#ifdef USE_PBR
inline SCNPBRSurface SCNShaderSurfaceToSCNPBRSurface(SCNShaderSurface surface)
    SCNPBRSurface s;
    
    s.n = surface.normal;
    s.v = surface.view;
    s.albedo = surface.diffuse.xyz;
    
#ifdef USE_EMISSION
    s.emission = surface.emission.xyz;
#else
    s.emission = float3(0.);
#endif
#ifdef USE_SELFILLUMINATION
    s.selfIllumination = surface.selfIllumination.xyz;
#else
    s.selfIllumination = float3(0.);
#endif
    
    s.metalness = surface.metalness;
    s.roughness = surface.roughness;
    s.ao = surface.ambientOcclusion;
    return s;
static float4 scn_pbr_combine(SCNPBRSurface                      pbr_surface,
                              SCNShaderLightingContribution      lighting,
                              texture2d<float, access::sample>   specularDFG,
                              texturecube<float, access::sample> specularLD,
#ifdef USE_PROBES_LIGHTING
#if defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 2)
                              sh2_coefficients                   shCoefficients,
#elif defined(USE_PROBES_LIGHTING) && (USE_PROBES_LIGHTING == 3)
                              sh3_coefficients                   shCoefficients,
#endif
#else
                              texturecube<float, access::sample> irradiance,
#endif
                              constant SCNSceneBuffer&           scn_frame)
#ifdef USE_PROBES_LIGHTING
    float3 pbr_color = scn_pbr_color_IBL(pbr_surface, specularDFG, specularLD, shCoefficients, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#else
    float3 pbr_color = scn_pbr_color_IBL(pbr_surface, specularDFG, specularLD, irradiance, scn_frame.viewToCubeTransform, scn_frame.environmentIntensity);
#endif
    
    float4 color;
    color.rgb = (lighting.ambient * pbr_surface.ao + lighting.diffuse) * pbr_surface.albedo.rgb + lighting.specular + pbr_color;
    
#ifdef USE_EMISSION
    color.rgb += pbr_surface.emission.rgb;
#endif
    
    return color;
static void scn_pbr_lightingContribution(SCNShaderSurface                   surface,
                                         SCNShaderLight                     light,
                                         constant SCNSceneBuffer&           scn_frame,
                                         thread float3&                     lightingContributionDiffuse,
                                         thread float3&                     lightingContributionSpecular)
    SCNPBRSurface pbr_surface = SCNShaderSurfaceToSCNPBRSurface(surface);
    
    float3 diffuseOut, specularOut;
    scn_pbr_lightingContribution_pointLight(light.direction, pbr_surface.n, pbr_surface.v, pbr_surface.albedo, pbr_surface.metalness, pbr_surface.roughness, diffuseOut, specularOut);
    
    float3 lightFactor = light.intensity.rgb * light._att;
    lightingContributionDiffuse += diffuseOut * lightFactor;
    lightingContributionSpecular += specularOut * lightFactor;
#else // ifdef USE_PBR
inline float4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float4 color = {0.,0.,0., surface.diffuse.a};
    
    float3 D = lighting.diffuse;
#if defined(USE_AMBIENT_LIGHTING) && (defined(LOCK_AMBIENT_WITH_DIFFUSE) || defined(USE_AMBIENT_AS_AMBIENTOCCLUSION))
    D += lighting.ambient * surface.ambientOcclusion;
#endif
    
#ifdef USE_SELFILLUMINATION
    D += surface.selfIllumination.rgb;
#endif
    // Do we want to clamp there ????
    color.rgb = surface.diffuse.rgb * D;
    #ifdef USE_SPECULAR
        float3 S = lighting.specular;
    #elif defined(USE_REFLECTIVE)
        float3 S = float3(0.);
    #endif
    #ifdef USE_REFLECTIVE
        S += surface.reflective.rgb * surface.ambientOcclusion;
    #endif
    #ifdef USE_SPECULAR
        S *= surface.specular.rgb;
    #endif
    #if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
        color.rgb += S;
    #endif
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#ifdef USE_EMISSION
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
#endif
struct  commonprofile_lights {
#ifdef USE_LIGHTING
    __LightingDecl__
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float pointSize;
    float2 texcoords[8]; // MAX_UV
struct commonprofile_uniforms {
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 selfIlluminationColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float metalness;
    float roughness;
    
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float selfIlluminationIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    float metalnessIntensity;
    float roughnessIntensity;
    float displacementIntensity;
    
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; // x: ((n1-n2)/(n1+n2))^2 y:1-x z:exponent
#ifdef TEXTURE_TRANSFORM_COUNT
    float4x4 textureTransforms[TEXTURE_TRANSFORM_COUNT];
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
//    float4x4 u_viewToCubeWorld;
#endif
// Shader modifiers declaration (only enabled if one modifier is present)
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
#ifdef USE_OPENSUBDIV
__OpenSubdivDecl__
struct osd_packed_vertex {
    packed_float3 position;
#if defined(OSD_USER_VARYING_DECLARE_PACKED)
    OSD_USER_VARYING_DECLARE_PACKED
#endif
#endif
#ifdef USE_DISPLACEMENT_MAP
static void applyDisplacement(texture2d<float>                 displacementTexture,
                              sampler                          displacementTextureSampler,
                              float2                           displacementTexcoord,
                              thread SCNShaderGeometry&        geometry,
                              constant commonprofile_uniforms& scn_commonprofile)
#ifdef USE_DISPLACEMENT_TEXTURE_COMPONENT
float altitude = displacementTexture.sample(displacementTextureSampler, displacementTexcoord)[USE_DISPLACEMENT_TEXTURE_COMPONENT];
#ifdef USE_DISPLACEMENT_INTENSITY
altitude *= scn_commonprofile.displacementIntensity;
#endif
#if defined(USE_NORMAL) && (defined(HAS_NORMAL) || defined(USE_OPENSUBDIV))
float3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));
geometry.position.xyz += geometry.normal * altitude;
float3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);
float3 h;
h.x = displacementTexture.sample(displacementTextureSampler, displacementTexcoord)[USE_DISPLACEMENT_TEXTURE_COMPONENT];
h.y = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz)[USE_DISPLACEMENT_TEXTURE_COMPONENT];
h.z = displacementTexture.sample(displacementTextureSampler, displacementTexcoord-offset.zy)[USE_DISPLACEMENT_TEXTURE_COMPONENT];
#ifdef USE_DISPLACEMENT_INTENSITY
h *= scn_commonprofile.displacementIntensity;
#endif
float3 n = normalize( float3( (h.x - h.y)/offset.x, 1., (h.x - h.z)/offset.y) );
geometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;
geometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));
#endif // USE_NORMAL
#else // USE_DISPLACEMENT_TEXTURE_COMPONENT
float3 displacement = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;
#ifdef USE_DISPLACEMENT_INTENSITY
displacement *= scn_commonprofile.displacementIntensity;
#endif
#if defined(USE_NORMAL) && (defined(HAS_NORMAL) || defined(USE_OPENSUBDIV))
float3 bitangent = geometry.tangent.w * normalize(cross(geometry.tangent.xyz, geometry.normal.xyz));
geometry.position.xyz += geometry.tangent.xyz * displacement.x + geometry.normal.xyz * displacement.y + bitangent.xyz * displacement.z;
float3 offset = float3(1.f / displacementTexture.get_width(), 1.f / displacementTexture.get_height(), 0.f);
float3 a = displacementTexture.sample(displacementTextureSampler, displacementTexcoord).rgb;
float3 b = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.xz).rgb;
float3 c = displacementTexture.sample(displacementTextureSampler, displacementTexcoord+offset.zy).rgb;
#ifdef USE_DISPLACEMENT_INTENSITY
a *= scn_commonprofile.displacementIntensity;
b *= scn_commonprofile.displacementIntensity;
c *= scn_commonprofile.displacementIntensity;
#endif
b += offset.xzz;
c -= offset.zzy;
float3 n = (normalize( cross( b-a, c-a ) ));
geometry.normal = geometry.tangent.xyz * n.x + geometry.normal.xyz * n.y + bitangent.xyz * n.z;
geometry.tangent.xyz = normalize(cross(bitangent, geometry.normal));
#endif // USE_NORMAL
#endif // USE_DISPLACEMENT_TEXTURE_COMPONENT
#endif // USE_DISPLACEMENT_MAP
#ifdef USE_OUTLINE
static inline float hash(float2 p)
const float2 kMod2 = float2(443.8975f, 397.2973f);
p  = fract(p * kMod2);
p += dot(p.xy, p.yx+19.19f);
return fract(p.x * p.y);
#endif
// Vertex shader function
#ifndef USE_TESSELATION
vertex commonprofile_io commonprofile_vert(scn_vertex_t                       in                [[ stage_in ]]
                                           , constant SCNSceneBuffer&         scn_frame         [[ buffer(0) ]]
#ifdef USE_INSTANCING
                                           // we use device here to override the 64Ko limit of constant buffers on NV hardware
                                           , device commonprofile_node*       scn_nodeInstances [[ buffer(1) ]]
#else
                                           , constant commonprofile_node&     scn_node          [[ buffer(1) ]]
#endif
#ifdef USE_PER_VERTEX_LIGHTING
                                           , constant commonprofile_lights&   scn_lights        [[ buffer(2) ]]
#endif
// used for texture transform and materialShininess in case of perVertexLighting
                                           , constant commonprofile_uniforms& scn_commonprofile [[ buffer(3) ]]
                                           , uint                             scn_vertexID      [[ vertex_id ]]
                                           , uint                             scn_instanceID    [[ instance_id ]]
#ifdef USE_POINT_RENDERING
                                           // x:pointSize, y:minimumScreenSize, z:maximumScreenSize
                                           , constant float3&                 scn_pointSize     [[ buffer(4) ]]
#endif
#ifdef USE_DISPLACEMENT_MAP
   , texture2d<float>                 u_displacementTexture        [[ texture(0) ]]
   , sampler                          u_displacementTextureSampler [[ sampler(0) ]]
#endif
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
__VertexExtraArguments__
#endif
                                           )
#ifdef USE_INSTANCING
    device commonprofile_node& scn_node = scn_nodeInstances[scn_instanceID];
#endif
    SCNShaderGeometry _geometry;
    // OPTIM in could be already float4?
    _geometry.position = float4(in.position, 1.f);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _geometry.normal = in.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = in.tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = in.texcoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = in.texcoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = in.texcoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = in.texcoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = in.texcoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = in.texcoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = in.texcoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = in.texcoord7;
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = in.color;
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
#ifdef USE_POINT_RENDERING
    _geometry.pointSize = scn_pointSize.x;
#endif
    
#ifdef USE_TEXCOORD
    __VertexDoVertexOnlyTexcoord__
#endif
#ifdef USE_SKINNING
    {
        float3 pos = 0.f;
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
        float3 nrm = 0.f;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        float3 tgt = 0.f;
#endif
        for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
            float weight = 1.f;
#else
            float weight = in.skinningWeights[i];
            if (weight <= 0.f)
                continue;
#endif
            int idx = int(in.skinningJoints[i]) * 3;
            float4x4 jointMatrix = float4x4(scn_node.skinningJointMatrices[idx],
                                            scn_node.skinningJointMatrices[idx+1],
                                            scn_node.skinningJointMatrices[idx+2],
                                            float4(0., 0., 0., 1.));
            
            pos += (_geometry.position * jointMatrix).xyz * weight;
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
            nrm += _geometry.normal * scn::mat3(jointMatrix) * weight;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * scn::mat3(jointMatrix) * weight;
#endif
        }
        
        _geometry.position.xyz = pos;
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
        _geometry.normal = nrm;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        _geometry.tangent.xyz = tgt;
#endif
    }
#endif // USE_SKINNING
    
    commonprofile_io out;
    
#ifdef USE_DISPLACEMENT_MAP
applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);
#endif
#ifdef USE_GEOMETRY_MODIFIER
// DoGeometryModifier START
__DoGeometryModifier__
// DoGeometryModifier END
#endif
    
    // Transform the geometry elements in view space
#if defined(USE_POSITION) || (defined(USE_NORMAL) && defined(HAS_NORMAL)) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)
    SCNShaderSurface _surface;
#endif
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;
#endif
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _surface.normal = normalize(scn::mat3(scn_node.normalTransform) * _geometry.normal);
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _surface.tangent = normalize(scn::mat3(scn_node.normalTransform) * _geometry.tangent.xyz);
    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); // no need to renormalize since tangent and normal should be orthogonal
    // old code : _surface.bitangent =  normalize(cross(_surface.normal,_surface.tangent));
#endif
    
    //if USE_VIEW is 2 we may also need to set _surface.view. todo: make USE_VIEW a mask
#ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
#endif
    
#ifdef USE_PER_VERTEX_LIGHTING
    // Lighting
    SCNShaderLightingContribution _lightingContribution;
    _lightingContribution.diffuse = 0.;
  #ifdef USE_SPECULAR
    _lightingContribution.specular = 0.;
    _surface.shininess = scn_commonprofile.materialShininess;
  #endif
    __VertexDoLighting__
    out.diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
    out.specular = _lightingContribution.specular;
  #endif
#endif
    
#if defined(USE_POSITION) && (USE_POSITION == 2)
    out.position = _surface.position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && defined(HAS_NORMAL)
    out.normal = _surface.normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    out.tangent = _surface.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    out.bitangent = _surface.bitangent;
#endif
#ifdef USE_VERTEX_COLOR
    out.vertexColor = _geometry.color;
#endif
#ifdef USE_TEXCOORD
__VertexDoTexcoord__
#endif
    
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);
#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) // this means that the geometry are still in model space : we can transform it directly to NDC space
    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;
#endif
#ifdef USE_NODE_OPACITY
    out.nodeOpacity = scn_node.nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    out.orientationPreserved = scn_node.orientationPreserved;
#endif
#ifdef USE_POINT_RENDERING
    float screenSize = _geometry.pointSize / out.fragmentPosition.w;
    out.fragmentSize = clamp(screenSize, scn_pointSize.y, scn_pointSize.z);
#endif
    
#ifdef USE_MOTIONBLUR
    float4 lastFrameFragmentPosition = scn_node.lastFrameModelViewProjectionTransform * _geometry.position;
    out.velocity.xy = lastFrameFragmentPosition.xy * float2(1., -1.);
    out.velocity.z = lastFrameFragmentPosition.w;
#endif
#ifdef USE_OUTLINE
out.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;
#endif
    return out;
#else // #ifndef USE_TESSELATION
#if __METAL_VERSION__ >= 120
struct scn_patch_t {
    patch_control_point<scn_vertex_t> controlPoints;
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
[[ patch(quad, VERTEX_CONTROL_POINTS_PER_PATCH) ]]
#endif
#else // USE_OPENSUBDIV
[[ patch(triangle, 3) ]]
#endif // USE_OPENSUBDIV
vertex commonprofile_io commonprofile_post_tessellation_vert(
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
                                                             PatchInput                         patchInput                   [[ stage_in ]]
#else
                                                             OsdVertexBufferSet                 patchInput
#endif
                                                             , float2                           patchCoord                   [[ position_in_patch ]]
                                                             , uint                             patchID                      [[ patch_id ]]
                                                             , constant float&                  osdTessellationLevel         [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]]
#else // OSD_IS_ADAPTIVE
                                                             device unsigned const*             osdIndicesBuffer             [[ buffer(INDICES_BUFFER_INDEX) ]]
                                                             , device osd_packed_vertex const*  osdVertexBuffer              [[ buffer(VERTEX_BUFFER_INDEX) ]]
                                                             , uint                             vertexID                     [[ vertex_id ]]
#endif // OSD_IS_ADAPTIVE
#if defined(OSD_FVAR_WIDTH)
                                                             , device float const*              osdFaceVaryingData           [[ buffer(OSD_FVAR_DATA_BUFFER_INDEX) ]]
                                                             , device int const*                osdFaceVaryingIndices        [[ buffer(OSD_FVAR_INDICES_BUFFER_INDEX) ]]
#if OSD_IS_ADAPTIVE
                                                             , device packed_int3 const*        osdFaceVaryingPatchParams    [[ buffer(OSD_FVAR_PATCHPARAM_BUFFER_INDEX) ]]
                                                             , constant packed_int4&            osdFaceVaryingPatchArray     [[ buffer(OSD_FVAR_PATCH_ARRAY_BUFFER_INDEX) ]]
#endif
#endif //defined(OSD_FVAR_WIDTH)
#else // USE_OPENSUBDIV
                                                             scn_patch_t                        in                           [[ stage_in ]]
                                                             , float3                           patchCoord                   [[ position_in_patch ]]
#endif // USE_OPENSUBDIV
                                                             , constant SCNSceneBuffer&         scn_frame                    [[ buffer(0) ]]
#ifdef USE_INSTANCING
                                                             // we use device here to override the 64Ko limit of constant buffers on NV hardware
                                                             , device commonprofile_node*       scn_nodeInstances            [[ buffer(1) ]]
#else
                                                             , constant commonprofile_node&     scn_node                     [[ buffer(1) ]]
#endif
#ifdef USE_PER_VERTEX_LIGHTING
                                                             , constant commonprofile_lights&   scn_lights                   [[ buffer(2) ]]
#endif
                                                             // used for texture transform and materialShininess in case of perVertexLighting
                                                             , constant commonprofile_uniforms& scn_commonprofile            [[ buffer(3) ]]
                                                             , uint                             scn_instanceID               [[ instance_id ]]
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                                             __VertexExtraArgumentsPostTessellation__
#endif
#ifdef USE_DISPLACEMENT_MAP
                                                             , texture2d<float>                 u_displacementTexture        [[ texture(0) ]]
                                                             , sampler                          u_displacementTextureSampler [[ sampler(0) ]]
#endif
                                                             )
#ifdef USE_INSTANCING
    device commonprofile_node& scn_node = scn_nodeInstances[scn_instanceID];
#endif
    uint scn_vertexID; // we need scn_vertexID if a geometry modifier is used
    scn_vertexID = 0;
    SCNShaderGeometry _geometry;
#ifdef USE_OPENSUBDIV
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
    int3 patchParam = patchInput.patchParam;
#else
    int3 patchParam = patchInput.patchParamBuffer[patchID];
#endif
    
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    float tessellationLevel = min(osdTessellationLevel, (float)OSD_MAX_TESS_LEVEL) / exp2((float)refinementLevel - 1);
    
    OsdPatchVertex patchVertex = OsdComputePatch(tessellationLevel, patchCoord, patchID, patchInput);
    
#if defined(OSD_FVAR_WIDTH)
    int patchIndex = OsdGetPatchIndex(patchID);
    OsdInterpolateFaceVarings(_geometry, patchCoord.xy, patchIndex, osdFaceVaryingIndices, osdFaceVaryingData, osdFaceVaryingPatchParams, osdFaceVaryingPatchArray);
#endif
    
    _geometry.position = float4(patchVertex.position, 1.f);
    
#if defined(USE_NORMAL)
    _geometry.normal = patchVertex.normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = float4(patchVertex.tangent, -1.f);
    //_geometry.bitangent = patchVertex.bitangent;
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[0] = patchVertex.texcoord0;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[1] = patchVertex.texcoord1;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[2] = patchVertex.texcoord2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[3] = patchVertex.texcoord3;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[4] = patchVertex.texcoord4;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[5] = patchVertex.texcoord5;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[6] = patchVertex.texcoord6;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[7] = patchVertex.texcoord7;
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.color = patchVertex.color;
#endif
    
#else //OSD_IS_ADAPTIVE
#if OSD_PATCH_QUADS
    const uint primitiveIndex = vertexID / 6;
#ifdef USE_NORMAL
    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 0]].position;
    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 1]].position;
    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + 2]].position;
    float3 normal = normalize(cross(p2 - p1, p0 - p1));
#endif
    const uint triangleIndices[6] = { 0, 1, 2, 0, 2, 3 };
    const uint quadVertexIndex = triangleIndices[vertexID % 6];
    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 4 + quadVertexIndex]];
#elif OSD_PATCH_TRIANGLES
    const uint primitiveIndex = vertexID / 3;
#ifdef USE_NORMAL
    float3 p0 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 0]].position;
    float3 p1 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 1]].position;
    float3 p2 = osdVertexBuffer[osdIndicesBuffer[primitiveIndex * 3 + 2]].position;
    float3 normal = normalize(cross(p2 - p1, p0 - p1));
#endif
    osd_packed_vertex osdVertex = osdVertexBuffer[osdIndicesBuffer[vertexID]];
#endif
    
    float3 position = osdVertex.position;
    
#if defined(OSD_FVAR_WIDTH)
    int patchIndex = OsdGetPatchIndex(primitiveIndex);
#if OSD_PATCH_QUADS
    float2 quadUVs[4] = { float2(0,0), float2(1,0), float2(1,1), float2(0,1) };
    OsdInterpolateFaceVarings(_geometry, quadUVs[quadVertexIndex], patchIndex, osdFaceVaryingIndices, osdFaceVaryingData);
#elif OSD_PATCH_TRIANGLES
    //TODO
#endif
#endif
    
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    //_geometry.tangent = float4(osdVertex.tangent, 1);
    //_geometry.bitangent = osdVertex.bitangent;
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[0] = osdVertex.texcoord0;
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[1] = osdVertex.texcoord1;
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[2] = osdVertex.texcoord2;
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[3] = osdVertex.texcoord3;
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[4] = osdVertex.texcoord4;
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[5] = osdVertex.texcoord5;
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[6] = osdVertex.texcoord6;
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.texcoords[7] = osdVertex.texcoord7;
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_USER_VARYING)
    _geometry.color = osdVertex.color;
#endif
    
    _geometry.position = float4(position, 1.f);
#ifdef USE_NORMAL
    _geometry.normal = normal;
#endif
#endif //OSD_IS_ADAPTIVE
    
#else // USE_OPENSUBDIV
    
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE) || defined(TESSELLATION_SMOOTHING_MODE_PHONG)
    
    float3 P0 = in.controlPoints[0].position;
    float3 P1 = in.controlPoints[1].position;
    float3 P2 = in.controlPoints[2].position;
    
    float3 N0 = in.controlPoints[0].normal;
    float3 N1 = in.controlPoints[1].normal;
    float3 N2 = in.controlPoints[2].normal;
    
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)
    float3 position, normal;
    scn_smooth_geometry_pn_triangle(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);
#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)
    float3 position, normal;
    scn_smooth_geometry_phong(position, normal, patchCoord, P0, P1, P2, N0, N1, N2);
#endif
    
    _geometry.position = float4(position, 1.f);
#ifdef USE_NORMAL
    _geometry.normal = normal;
#endif
#else // GEOMETRY_SMOOTHING
    
    // OPTIM in could be already float4?
    _geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.f);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
    _geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));
#endif
    
#endif // GEOMETRY_SMOOTHING
    
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));
#endif
#ifdef NEED_IN_TEXCOORD0
    _geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD1
    _geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD2
    _geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD3
    _geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD4
    _geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD5
    _geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD6
    _geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);
#endif
#ifdef NEED_IN_TEXCOORD7
    _geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);
#endif
#ifdef HAS_VERTEX_COLOR
    _geometry.color = scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord);
#elif USE_VERTEX_COLOR
    _geometry.color = float4(1.);
#endif
#endif // USE_OPENSUBDIV
    
#ifdef USE_TEXCOORD
    __VertexDoVertexOnlyTexcoordPostTessellation__
#endif
#ifdef USE_DISPLACEMENT_MAP
applyDisplacement(u_displacementTexture, u_displacementTextureSampler, _displacementTexcoord, _geometry, scn_commonprofile);
#endif
    
#if defined(USE_SKINNING) && !defined(USE_OPENSUBDIV)
    {
        float3 pos[3] = {0.f, 0.f, 0.f};
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
        float3 nrm[3] = {0.f, 0.f, 0.f};
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        float3 tgt[3] = {0.f, 0.f, 0.f};
#endif
        for (int controlPointIndex = 0; controlPointIndex < 3; ++controlPointIndex) {
            for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
                float weight = 1.f;
#else
                float weight = in.controlPoints[controlPointIndex].skinningWeights[i];
                if (weight <= 0.f)
                    continue;
                
#endif
                int idx = int(in.controlPoints[controlPointIndex].skinningJoints[i]) * 3;
                float4x4 jointMatrix = float4x4(scn_node.skinningJointMatrices[idx],
                                                scn_node.skinningJointMatrices[idx+1],
                                                scn_node.skinningJointMatrices[idx+2],
                                                float4(0., 0., 0., 1.));
                
                pos[controlPointIndex] += (_geometry.position * jointMatrix).xyz * weight;
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
                nrm[controlPointIndex] += _geometry.normal * scn::mat3(jointMatrix) * weight;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
                tgt[controlPointIndex] += _geometry.tangent.xyz * scn::mat3(jointMatrix) * weight;
#endif
            }
        }
        
        _geometry.position.xyz = scn::barycentric_mix(pos[0], pos[1], pos[2], patchCoord);
#if defined(USE_NORMAL) && defined(HAS_NORMAL)
        _geometry.normal = scn::barycentric_mix(nrm[0], nrm[1], nrm[2], patchCoord);
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
        _geometry.tangent.xyz = scn::barycentric_mix(tgt[0], tgt[1], tgt[2], patchCoord);
#endif
    }
#endif // defined(USE_SKINNING) && !defined(USE_OPENSUBDIV)
    
    commonprofile_io out;
    
#ifdef USE_DISPLACEMENT_MAP
    out.displacementTexcoord = _displacementTexcoord;
#endif
    
#ifdef USE_GEOMETRY_MODIFIER
    // DoGeometryModifier START
    __DoGeometryModifierPostTessellation__
    // DoGeometryModifier END
#endif
    
    // Transform the geometry elements in view space
#if defined(USE_POSITION) || defined(USE_NORMAL) || defined(USE_TANGENT) || defined(USE_BITANGENT) || defined(USE_INSTANCING)
    SCNShaderSurface _surface;
#endif
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    _surface.position = (scn_node.modelViewTransform * _geometry.position).xyz;
#endif
#if defined(USE_NORMAL) && (defined(HAS_NORMAL) || defined(USE_OPENSUBDIV))
    _surface.normal = normalize(scn::mat3(scn_node.normalTransform) * _geometry.normal);
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _surface.tangent = normalize(scn::mat3(scn_node.normalTransform) * _geometry.tangent.xyz);
    _surface.bitangent = _geometry.tangent.w * cross(_surface.tangent, _surface.normal); // no need to renormalize since tangent and normal should be orthogonal
    // old code : _surface.bitangent =  normalize(cross(_surface.normal,_surface.tangent));
#endif
    
    //if USE_VIEW is 2 we may also need to set _surface.view. todo: make USE_VIEW a mask
#ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
#endif
    
#ifdef USE_PER_VERTEX_LIGHTING
    // Lighting
    SCNShaderLightingContribution _lightingContribution;
    _lightingContribution.diffuse = 0.;
  #ifdef USE_SPECULAR
    _lightingContribution.specular = 0.;
    _surface.shininess = scn_commonprofile.materialShininess;
  #endif
    __VertexDoLightingPostTessellation__
    out.diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
    out.specular = _lightingContribution.specular;
  #endif
#endif
    
#if defined(USE_POSITION) && (USE_POSITION == 2)
    out.position = _surface.position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2) && (defined(HAS_NORMAL) || defined(USE_OPENSUBDIV))
    out.normal = _surface.normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    out.tangent = _surface.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    out.bitangent = _surface.bitangent;
#endif
#ifdef USE_VERTEX_COLOR
    out.vertexColor = _geometry.color;
#endif
#ifdef USE_TEXCOORD
    __VertexDoTexcoordPostTessellation__
#endif
    
#if defined(USE_POSITION) || defined(USE_INSTANCING)
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.);
#elif defined(USE_MODELVIEWPROJECTIONTRANSFORM) // this means that the geometry are still in model space : we can transform it directly to NDC space
    out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;
#endif
    
#ifdef USE_NODE_OPACITY
    out.nodeOpacity = scn_node.nodeOpacity;
#endif
#ifdef USE_DOUBLE_SIDED
    out.orientationPreserved = scn_node.orientationPreserved;
#endif
#ifdef USE_MOTIONBLUR
float4 lastFrameFragmentPosition = scn_node.lastFrameModelViewProjectionTransform * _geometry.position;
out.velocity.xy = lastFrameFragmentPosition.xy * float2(1., -1.);
out.velocity.z = lastFrameFragmentPosition.w;
#endif
#ifdef USE_OUTLINE
out.outlineHash = hash(scn_node.modelTransform[3].xy)+1.f/255.f;
#endif
    return out;
#endif // __METAL_VERSION__
#endif // #ifndef USE_TESSELATION
struct SCNOutput
    float4 color [[ color(0) ]];
#ifdef USE_MOTIONBLUR
    half4 motionblur [[ color(1) ]];
#endif
// Fragment shader function
fragment SCNOutput commonprofile_frag(commonprofile_io                 in                         [[stage_in]],
                                  constant commonprofile_uniforms& scn_commonprofile          [[buffer(0)]],
                                  constant SCNSceneBuffer&         scn_frame                  [[buffer(1)]]
#ifdef USE_PER_PIXEL_LIGHTING
                                  , constant commonprofile_lights& scn_lights                 [[buffer(2)]]
#endif
#ifdef USE_EMISSION_MAP
                                  , texture2d<float>              u_emissionTexture           [[texture(0)]]
                                  , sampler                       u_emissionTextureSampler    [[sampler(0)]]
#endif
#ifdef USE_AMBIENT_MAP
                                  , texture2d<float>              u_ambientTexture            [[texture(1)]]
                                  , sampler                       u_ambientTextureSampler     [[sampler(1)]]
#endif
#ifdef USE_DIFFUSE_MAP
                                  , texture2d<float>              u_diffuseTexture            [[texture(2)]]
                                  , sampler                       u_diffuseTextureSampler     [[sampler(2)]]
#endif
#ifdef USE_SPECULAR_MAP
                                  , texture2d<float>              u_specularTexture           [[texture(3)]]
                                  , sampler                       u_specularTextureSampler    [[sampler(3)]]
#endif
#ifdef USE_REFLECTIVE_MAP
                                  , texture2d<float>              u_reflectiveTexture         [[texture(4)]]
                                  , sampler                       u_reflectiveTextureSampler  [[sampler(4)]]
#elif defined(USE_REFLECTIVE_CUBEMAP)
                                  , texturecube<float>            u_reflectiveTexture         [[texture(4)]]
                                  , sampler                       u_reflectiveTextureSampler  [[sampler(4)]]
#endif
#ifdef USE_TRANSPARENT_MAP
                                  , texture2d<float>              u_transparentTexture        [[texture(5)]]
                                  , sampler                       u_transparentTextureSampler [[sampler(5)]]
#endif
#ifdef USE_MULTIPLY_MAP
                                  , texture2d<float>              u_multiplyTexture           [[texture(6)]]
                                  , sampler                       u_multiplyTextureSampler    [[sampler(6)]]
#endif
#ifdef USE_NORMAL_MAP
                                  , texture2d<float>              u_normalTexture             [[texture(7)]]
                                  , sampler                       u_normalTextureSampler      [[sampler(7)]]
#endif
#ifdef USE_SELFILLUMINATION_MAP
                                  , texture2d<float>              u_selfIlluminationTexture           [[texture(8)]]
                                  , sampler                       u_selfIlluminationTextureSampler    [[sampler(8)]]
#endif
#ifdef USE_PBR
#ifdef USE_METALNESS_MAP
                                  , texture2d<float>              u_metalnessTexture          [[texture(3)]]
                                  , sampler                       u_metalnessTextureSampler   [[sampler(3)]]
#endif
#ifdef USE_ROUGHNESS_MAP
                                  , texture2d<float>              u_roughnessTexture          [[texture(4)]]
                                  , sampler                       u_roughnessTextureSampler   [[sampler(4)]]
#endif
#ifdef USE_DISPLACEMENT_MAP
                                  , texture2d<float>              u_displacementTexture        [[ texture(12) ]]
                                  , sampler                       u_displacementTextureSampler [[ sampler(12) ]]
#endif
#if !defined(USE_SELFILLUMINATION_MAP)
                                  , texturecube<float>            u_irradianceTexture         [[texture(8)]]
#endif
                                  , texturecube<float>            u_radianceTexture           [[texture(9)]]
                                  , texture2d<float>              u_specularDFGTexture        [[texture(10)]]
#endif
#ifdef USE_SSAO
                                  , texture2d<float>              u_ssaoTexture               [[texture(11)]]
#endif
                                  , constant commonprofile_node&  scn_node                    [[buffer(3)]]
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
__FragmentExtraArguments__
#endif
#if defined(USE_DOUBLE_SIDED)
                                  , bool                          isFrontFacing               [[front_facing]]
#endif
#ifdef USE_POINT_RENDERING
                                  , float2                        pointCoord                  [[point_coord]]
#endif
                                  
                                  )
    SCNShaderSurface _surface;
#ifdef USE_TEXCOORD
__FragmentDoTexcoord__
#endif
    _surface.ambientOcclusion = 1.f; // default to no AO
#ifdef USE_AMBIENT_MAP
    #ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
        _surface.ambientOcclusion = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord).r;
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        #endif
    #else // AMBIENT_MAP
        _surface.ambient = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        #ifdef USE_AMBIENT_INTENSITY
            _surface.ambient *= scn_commonprofile.ambientIntensity;
        #endif
    #endif // USE_AMBIENT_AS_AMBIENTOCCLUSION
#if defined(USE_AMBIENT_TEXTURE_COMPONENT)
    _surface.ambient = float4(_surface.ambient[USE_AMBIENT_TEXTURE_COMPONENT]);
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = scn_commonprofile.ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = float4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= in.vertexColor;
#endif
#if  defined(USE_SSAO)
    _surface.ambientOcclusion = u_ssaoTexture.sample( sampler(filter::linear), in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
#endif
    
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
#if defined(USE_DIFFUSE_TEXTURE_COMPONENT)
    _surface.diffuse = float4(_surface.diffuse[USE_DIFFUSE_TEXTURE_COMPONENT]);
#endif
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = scn_commonprofile.diffuseColor;
#else
    _surface.diffuse = float4(0.f,0.f,0.f,1.f);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= in.vertexColor;
#endif
#ifdef USE_SPECULAR_MAP
    _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
#if defined(USE_SPECULAR_TEXTURE_COMPONENT)
    _surface.specular = float4(_surface.specular[USE_SPECULAR_TEXTURE_COMPONENT]);
#endif
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= scn_commonprofile.specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = scn_commonprofile.specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = float4(0.f);
#endif
#ifdef USE_EMISSION_MAP
    _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
#if defined(USE_EMISSION_TEXTURE_COMPONENT)
    _surface.emission = float4(_surface.emission[USE_EMISSION_TEXTURE_COMPONENT]);
#endif
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= scn_commonprofile.emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = scn_commonprofile.emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = float4(0.);
#endif
#ifdef USE_SELFILLUMINATION_MAP
    _surface.selfIllumination = u_selfIlluminationTexture.sample(u_selfIlluminationTextureSampler, _surface.selfIlluminationTexcoord);
#if defined(USE_SELFILLUMINATION_TEXTURE_COMPONENT)
    _surface.selfIllumination = float4(_surface.selfIllumination[USE_SELFILLUMINATION_TEXTURE_COMPONENT]);
#endif
#ifdef USE_SELFILLUMINATION_INTENSITY
    _surface.selfIllumination *= scn_commonprofile.selfIlluminationIntensity;
#endif
#elif defined(USE_SELFILLUMINATION_COLOR)
    _surface.selfIllumination = scn_commonprofile.selfIlluminationColor;
#elif defined(USE_SELFILLUMINATION)
    _surface.selfIllumination = float4(0.);
#endif
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
#if defined(USE_MULTIPLY_TEXTURE_COMPONENT)
    _surface.multiply = float4(_surface.multiply[USE_MULTIPLY_TEXTURE_COMPONENT]);
#endif
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(float4(1.), _surface.multiply, scn_commonprofile.multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = scn_commonprofile.multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = float4(1.);
#endif
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
#if defined(USE_TRANSPARENT_TEXTURE_COMPONENT)
    _surface.transparent = float4(_surface.transparent[USE_TRANSPARENT_TEXTURE_COMPONENT]);
#endif
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= scn_commonprofile.transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = scn_commonprofile.transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = float4(1.);
#endif
    
#ifdef USE_METALNESS_MAP
#if defined(USE_METALNESS_TEXTURE_COMPONENT)
    _surface.metalness = float4(u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord))[USE_METALNESS_TEXTURE_COMPONENT];
#else
    _surface.metalness = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord).r;
#endif
#ifdef USE_METALNESS_INTENSITY
    _surface.metalness *= scn_commonprofile.metalnessIntensity;
#endif
#elif defined(USE_METALNESS_COLOR)
    _surface.metalness = scn_commonprofile.metalness;
#else
    _surface.metalness = 0;
#endif
    
#ifdef USE_ROUGHNESS_MAP
#if defined(USE_ROUGHNESS_TEXTURE_COMPONENT)
    _surface.roughness = float4(u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord))[USE_ROUGHNESS_TEXTURE_COMPONENT];
#else
    _surface.roughness = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
#endif
#ifdef USE_ROUGHNESS_INTENSITY
    _surface.roughness *= scn_commonprofile.roughnessIntensity;
#endif
#elif defined(USE_ROUGHNESS_COLOR)
    _surface.roughness = scn_commonprofile.roughness;
#else
    _surface.roughness = 0;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = in.position;
#endif
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#if defined(HAS_NORMAL) || defined(USE_OPENSUBDIV)
#ifdef USE_DOUBLE_SIDED
    _surface.geometryNormal = normalize(in.normal.xyz) * in.orientationPreserved * ((float(isFrontFacing) * 2.f) - 1.f);
#else
    _surface.geometryNormal = normalize(in.normal.xyz);
#endif
#else // need to generate the normal from the derivatives
    _surface.geometryNormal = normalize( cross(dfdy( _surface.position ), dfdx( _surface.position ) ));
#endif
    _surface.normal = _surface.geometryNormal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = in.tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = in.bitangent;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-in.position);
#endif
#if defined(USE_POSITION)
//    {
//    float3 p = in.position;
//    float3 dpdx = dfdx(p);
//    float3 dpdy = dfdy(p);
//        _surface.normal.rgb = normalize( cross(dpdx, dpdy) );
//    }
#endif
    
#if defined(USE_NORMAL_MAP)
    {
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
#ifdef USE_NORMAL_MAP
        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;
#if defined(USE_NORMAL_TEXTURE_COMPONENT)
        _surface._normalTS.xy = _surface._normalTS.xy * 2.f - 1.f;
        _surface._normalTS.z = sqrt(1.f - length_squared(_surface._normalTS.xy));
#else
        _surface._normalTS = _surface._normalTS * 2.f - 1.f;
#endif
#ifdef USE_NORMAL_INTENSITY
        _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);
#endif
#else
        _surface._normalTS = float3(0.f, 0.f, 1.f);
#endif
        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS.xyz );
    }
#else
    _surface._normalTS = float3(0.f, 0.f, 1.f);
#endif
#ifdef USE_REFLECTIVE_MAP
    float3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.f)*(refl.z+1.f));
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);
#if defined(USE_REFLECTIVE_TEXTURE_COMPONENT)
    _surface.reflective = float4(_surface.reflective[USE_REFLECTIVE_TEXTURE_COMPONENT]);
#endif
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    float3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); // sample the cube map in world space
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective *= scn_commonprofile.reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = scn_commonprofile.reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = float4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = scn_commonprofile.materialShininess;
#endif
#ifdef USE_SURFACE_MODIFIER
// DoSurfaceModifier START
__DoSurfaceModifier__
// DoSurfaceModifier END
#endif
    // Lighting
    SCNShaderLightingContribution _lightingContribution = {0};
    
    
    // Lighting
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = float3(0.);
#ifdef USE_MODULATE
    _lightingContribution.modulate = float3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = float3(0.);
#endif
__FragmentDoLighting__
#else // USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = in.diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = in.specular;
#endif
#endif
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
#ifdef USE_SPECULAR
    _lightingContribution.specular = saturate(_lightingContribution.specular);
#endif // USE_SPECULAR
#endif // AVOID_OVERLIGHTING
#else // USE_LIGHTING
    _lightingContribution.diffuse = float3(1.);
#endif // USE_LIGHTING
    // Combine
    SCNOutput _output;
#ifdef USE_PBR
    SCNPBRSurface pbr_surface = SCNShaderSurfaceToSCNPBRSurface(_surface);
    pbr_surface.selfIlluminationOcclusion = scn_commonprofile.selfIlluminationOcclusion;
#ifdef USE_PROBES_LIGHTING
    _output.color = scn_pbr_combine(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, scn_node.shCoefficients, scn_frame);
#elif defined(USE_SELFILLUMINATION_MAP)
    _output.color = scn_pbr_combine(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, u_radianceTexture, scn_frame);
#else
    _output.color = scn_pbr_combine(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, u_irradianceTexture, scn_frame);
#endif
    _output.color.a = _surface.diffuse.a;
#else
    _output.color = illuminate(_surface, _lightingContribution);
#endif
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
#endif
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
#ifdef USE_TRANSPARENT // Either a map or a color
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= scn_commonprofile.transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= in.nodeOpacity;
#endif
    // compute luminance
    _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);
    _output.color *= (float4(1.f) - _surface.transparent);
#else // ALPHA_ONE
#ifdef USE_NODE_OPACITY
    _output.color *= (in.nodeOpacity * _surface.transparent.a);
#else
    _output.color *= _surface.transparent.a;
#endif
#endif
#else
#ifdef USE_TRANSPARENCY // TRANSPARENCY without TRANSPARENT slot (nodeOpacity + diffuse.a)
#ifdef USE_NODE_OPACITY
    _output.color *= (in.nodeOpacity * scn_commonprofile.transparency);
#else
    _output.color *= scn_commonprofile.transparency;
#endif // NODE_OPACITY
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
// DoFragmentModifier START
__DoFragmentModifier__
// DoFragmentModifier END
#endif
    
#ifdef DISABLE_LINEAR_RENDERING
    _output.color.rgb = scn::linear_to_srgb(_output.color.rgb);
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) // we could set a different limit here
        discard_fragment();
#endif
#ifdef USE_POINT_RENDERING
    if ((dfdx(pointCoord.x) < 0.5f) && (length_squared(pointCoord * 2.f - 1.f) > 1.f)) {
        discard_fragment();
    }
#endif
    
#ifdef USE_MOTIONBLUR
    //_output.motionblur.xy = half2(in.fragmentPosition.xy*scn_frame.inverseResolution.xy*2.-1.);
    _output.motionblur.xy = (half2(in.fragmentPosition.xy*scn_frame.inverseResolution.xy*2.-1.) - half2(in.velocity.xy / in.velocity.z)) * scn_frame.motionBlurIntensity;
    _output.motionblur.z = length(_output.motionblur.xy);
    _output.motionblur.w = half(-_surface.position.z);
#endif
#ifdef USE_OUTLINE
_output.color.rgb = in.outlineHash;
#endif
    return _output;
#import <metal_stdlib>
using namespace metal;
// Include do not work in online compilation...
//#import <SceneKit/scn_metal>
inline float3 mat4_mult_float3(float4x4 matrix, float3 src)
    float3 dst  =  src.xxx * matrix[0].xyz;
    dst         += src.yyy * matrix[1].xyz;
    dst         += src.zzz * matrix[2].xyz;
    return dst;
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; // transform from view space to world space
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; // transform from view space to cube texture space (canonical Y Up space)
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; // x:-1/(end-start) y:1-start*x z:exp
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
    float       environmentIntensity;
// end of manual inclusion of scn_metal
/// Utils
constexpr sampler linear_sampler(filter::linear, mip_filter::nearest, address::clamp_to_edge);
#ifdef ENABLE_ORIENTATION_FREE
static float3x3 axisangle_to_matrix(float4 axis_angle)
    float c;
    float s = sincos(axis_angle.w, c);
    float t = 1. - c;
    
    float3x3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
    float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
#endif
#ifdef ENABLE_ANIMATION
constexpr sampler anim_sampler(filter::linear, mip_filter::nearest, address::repeat);
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
float4 ComputeUVS(float2 iNormUV, float iFrame, float4 iFrameSize)
    float4 outUV;
    
#if ENABLE_ANIMATION == CLAMP
    
    iFrame = clamp(iFrame, 0., iFrameSize.w - 1.); // clamp frame
    
    float intFrame;
    float frameFrac = modf(iFrame, intFrame);
    float2 frame;
    float intPart;
    frame.x = modf(intFrame * iFrameSize.x, intPart);
    frame.y = intPart * iFrameSize.y;
    
    outUV.xy = frame + iNormUV * iFrameSize.xy;
    outUV.w = frameFrac;
    outUV.z = step(0.9999, frame.x + iFrameSize.x); // next row or not
#elif ENABLE_ANIMATION == REPEAT
    
    float tmp = iFrame * iFrameSize.x;
    
    float2 frame;
    frame.y = tmp - fract(tmp);
    frame.x = fract(tmp) * iFrameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * iFrameSize.xy;
    outUV.w = frameFrac;
    outUV.z = (frame.x == (iFrameSize.z - 1.))?1.:0.; // next row or not
#else // AUTOREVERSE
    
    float invFrameCount = iFrameSize.x * iFrameSize.y;
    float normFrame = iFrame * invFrameCount;
    float lastFrame = iFrameSize.w - 1.;
    float frameIndex = fract(normFrame) * iFrameSize.w;
    if (fract(normFrame * 0.5) > 0.5) {
        frameIndex = (lastFrame-frameIndex);
    }
    
    frameIndex = clamp(frameIndex, 0., lastFrame); // clamp frame
    
    float tmp = frameIndex * iFrameSize.x;
    
    float2 frame;
    frame.y = tmp - fract(tmp);
    
    frame.x = fract(tmp) * iFrameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * iFrameSize.xy;
    
    outUV.w = frameFrac;
    outUV.z = (frame.x == (iFrameSize.z - 1.))?1.:0.; // next row or not
#endif
    return outUV;
#endif
typedef struct {
    // vertex data
    float2 texCoord1 [[attribute(SCNVertexSemanticTexcoord1)]]; // x:cornerX y:cornerY
    
    // instance data
    float4 position [[attribute(SCNVertexSemanticPosition)]]; // xyz: position, w:angle
    float3 texCoord0 [[attribute(SCNVertexSemanticTexcoord0)]]; // x:life y:size z:frame (texture animation)
    float4 color [[attribute(SCNVertexSemanticColor)]]; // particle color
#ifdef ENABLE_STRETCH
    float4 texCoord2 [[attribute(SCNVertexSemanticTexcoord2)]]; // velocity of the particle in .xyz
#elif defined(ENABLE_ORIENTATION_FREE)
    float4 texCoord2 [[attribute(SCNVertexSemanticTexcoord2)]]; // orientation in free mode as an axis angle
#endif
} particle_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float4 vertexColor;
#ifdef ENABLE_ANIMATION
    float3 uv0;
    float2 uv1;
#else
    float2 uv0;
#endif
#ifdef ENABLE_FOG
    float fogFactor;
#endif
#ifdef ENABLE_CUBE_MAP
    float3 normal;
#endif
} particle_io;
typedef struct {
    float4x4 viewTransform; // this should contain only the viewTransform if part are in world space or modelViewTransform otherwise
#if 0 // ENABLE_SOFT
    float u_eyeLinearZ;
#endif
#ifdef ENABLE_CUBE_MAP
    float u_fresnelExponent;
#endif
#ifdef ENABLE_STRETCH
    float u_stretchFactor;
#endif
#ifdef ENABLE_LIGHTING
    float3 u_lightPosition0; // in modelViewSpace already
    float4 u_lightColor0;
#endif
#ifdef ENABLE_ANIMATION
    float4 u_frameSize; // 1/dimX, 1/dimY, dimX, dimX*dimY
#endif
} particle_uniforms;
vertex particle_io particle_vert(particle_vertex_t in [[ stage_in ]],
#ifdef ENABLE_COLOR_RAMP
                                 texture2d<float> u_colorRamp [[texture(0)]],
#endif
                                 constant SCNSceneBuffer& scn_frame     [[buffer(0)]],
                                 constant particle_uniforms& scn_part   [[buffer(1)]])
    particle_io out;
    
    // transform the particle in view space
    float4 viewPos = scn_part.viewTransform * float4(in.position.xyz, 1);
    float3 N; // used for lighting and cubemaps
    
#ifdef ENABLE_STRETCH
    // compute the trail direction in viewSpace
    float4 viewDir = scn_part.viewTransform * float4(in.texCoord2.xyz, 0);
    viewDir *= scn_part.u_stretchFactor;
    
    // move the top vertices to the end of the trail
    viewPos.xyz += (in.texCoord1.y > 0.) ? viewDir.xyz : float3(0.);
    
    // compute the billboarding offsets
    //    float len = length(viewDir.xy);
    //    vec2 u = (len > 0.) ? viewDir.xy/len : vec2(0,1);
    float2 u = normalize(viewDir.xy); // divide by 0 seems to work.. otherwise replace by code commented beneath
    float2 r = float2(-u.y, u.x);
    float2 off = r * in.texCoord1.x + u * in.texCoord1.y ; // offset
    viewPos.xy += off * in.texCoord0.y; // * size
    
    N = normalize(float3(-off.x, -off.y, -2));
    
#else // ENABLE_STRETCH
    
    // TODO only rotate if needed (angle != 0)
    float cs;
    float sn = sincos(in.position.w, cs);
    // expand the quad corners
    float2 dir = { in.texCoord1.x * cs - in.texCoord1.y * sn,  in.texCoord1.y * cs + in.texCoord1.x * sn };
    dir *= in.texCoord0.y;
    
#ifdef ENABLE_ORIENTATION_FREE
    // TODO : we should work in world space then ? the transform is in worldSpace or localSpace...
    // TODO with version 120 we would not need this....
    float3x3 vt = float3x3(scn_part.viewTransform[0].xyz, scn_part.viewTransform[1].xyz, scn_part.viewTransform[2].xyz);
    float3x3 mat = vt * axisangle_to_matrix(in.texCoord2); // mat3(viewTransform)
    
#ifdef ENABLE_CUBE_MAP
    N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
    viewPos.xy += dir;
#else
    float3 off = mat[0] * dir.x + mat[1] * dir.y;
    viewPos.xyz += off;
#endif
    
    // TODO we should also tranform the normal for the lighting !!!!!
    
#elif defined(ENABLE_BILLBOARD_VIEW)
    float3 u = float3(0,1,0);
    float3 r = normalize(cross(u, -viewPos.xyz));
    float3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    N = normalize(float3(-off.x/in.texCoord0.y, -off.y/in.texCoord0.y, -2));
    
#elif defined(ENABLE_BILLBOARD_Y)
    float3 u = (scn_part.viewTransform * float4(0, 1, 0, 0)).xyz;
    float3 r = normalize(cross(u, float3(0,0,1))); // Screen Aligned
    //    vec3 r = normalize(cross(u, -viewPos.xyz)); // ViewAligned
    float3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    N = normalize(float3(-off.x/in.texCoord0.y, -off.y/in.texCoord0.y, -2));
    
#else // defined(ENABLE_BILLBOARD_SCREEN)
    viewPos.xy += dir;
    N = normalize(float3(-dir.x, -dir.y, -2));
    
#endif // ENABLE_ORIENTATION_FREE
    
#endif // ENABLE_STRETCH
    
#ifdef ENABLE_CUBE_MAP
#ifdef ENABLE_ORIENTATION_FREE
    out.normal.xyz = N;
#else
    float3 refl = reflect( viewPos.xyz, N );
    out.normal.xyz = mat4_mult_float3(scn_frame.viewToCubeTransform, refl);
#endif // ENABLE_ORIENTATION_FREE
#endif
    
#ifdef ENABLE_COLOR_RAMP
    constexpr sampler ramp_sampler(filter::linear, mip_filter::none, address::clamp_to_edge);
    out.vertexColor = in.color * u_colorRamp.sample(ramp_sampler, in.texCoord0.xx);
#else // use vertex color (TODO : use constant color if needed)
    out.vertexColor = in.color;
#endif
    
#ifndef ENABLE_BLACKPASS
    #ifdef ENABLE_LIGHTING
        float3 L = normalize(viewPos.xyz - scn_part.u_lightPosition0);
        
        #if defined(ENABLE_ORIENTATION_FREE) && !defined(ENABLE_CUBE_MAP)
            // if we want to bend the normal (but free orientation doesn't need too right ?)
            // vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? -normalize(-mat[2] + 0.1 * off) : -normalize(mat[2] + 0.1 * off);
            //    vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? mat[2] : -mat[2];
            N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
            
            // simple lambertian + back light diffusion
            float NdotL = dot(N, L);
            //    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * max(0., -NdotL));
            float3 diff = scn_part.u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
            
            // Specular
            float _shininess = 100.0;
            float3 halfVector = normalize(L + viewPos.xyz);
            float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
            out.vertexColor.rgb = out.vertexColor.rgb * diff + spec;
        #else
            // simple lambertian
            float3 diff = float3(max(0.0, dot(N, L))) * scn_part.u_lightColor0.rgb;
            
            // trilight model (lambertian + wrap around + hemispheric)
            //vec3 diff = lightColor0 * max(0., NdotL) + lightColor1 * (1. - abs(NdotL)) + lightColor2 * max(0., -NdotL);
            
            // todo : support ambient !!!!!!!!!!
            // diff += vec3(0.5);
            
            out.vertexColor.rgb *= diff;
        #endif // ENABLE_ORIENTATION_FREE
    #endif // ENABLE_LIGHTING
#endif // ENABLE_BLACKPASS
    
    // TexCoord
#ifdef ENABLE_ANIMATION
    float4 animUVS = ComputeUVS(in.texCoord1.xy * float2(0.5, -0.5) + 0.5, in.texCoord0.z, scn_part.u_frameSize);
    out.uv0 = animUVS.xyw;
    out.uv1 = animUVS.xy + scn_part.u_frameSize.xy * float2(1.0, animUVS.z);// + float2(-animUVS.z, 0); add this if you don't want wrap behavior in the sampler
#else
    out.uv0 = in.texCoord1.xy * float2(0.5, -0.5) + 0.5;
#endif
    
#ifndef ENABLE_BLACKPASS
#ifdef ENABLE_FOG
    out.fogFactor = pow(clamp(abs(viewPos.z) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0.0, scn_frame.fogColor.a), scn_frame.fogParameters.z);
#endif // ENABLE_FOG
#endif // ENABLE_BLACKPASS
    
#if 0 // ENABLE_SOFT
    out.eyeLinearZ = viewPos.z;
#endif
    
    out.position = scn_frame.projectionTransform * viewPos;
    return out;
// Fragment shader function
#if 0 // ENABLE_SOFT
uniform sampler2D u_depthSampler0;
uniform vec4 u_softParameters; // x: scale, y: power/contrast, zw : 1/viewPortSize
uniform mat4 u_invProj; // inverse of the projection transform, to reconstruct viewPos from screenPos
varying float v_eyeLinearZ;
float ComputeSoftFactor()
    vec2 normalizedFragCoord = gl_FragCoord.xy * u_softParameters.zw;
    float depthValue = texture2D(u_depthSampler0, gl_FragCoord.xy * u_softParameters.zw).x;
    
    vec3 screenPos = vec3(normalizedFragCoord, depthValue);
    vec4 viewPos = u_invProj * vec4(screenPos * 2. - 1., 1.);
    viewPos /= viewPos.w;
    
    float factor = clamp((v_eyeLinearZ - viewPos.z) * u_softParameters.x ,0. , 1.);
    
    // Do we really need this pow?
    // factor = pow(factor, u_softParameters.y);
    
    return factor;
#endif
fragment half4 particle_frag(particle_io in [[stage_in]],
                             constant particle_uniforms& pass [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame     [[buffer(1)]],
#ifdef ENABLE_CUBE_MAP
                             texturecube<float> u_textureSampler0 [[texture(0)]]
#else
                             texture2d<float> u_textureSampler0 [[texture(0)]]
#endif
                             )
#ifdef ENABLE_CUBE_MAP
    float2 p = in.uv0.xy * 2. - 1.;
    float r = dot(p,p); // len^2
    //    vec4 tex = vec4(normalize(v_normal.xyz), 1.) * step(r, 1.);
    float4 tex = u_textureSampler0.sample(linear_sampler, in.normal.xyz) * saturate(9.6 - 10. * r);
    // fresnel modulation
    tex.rgb *= pow(r, pass.u_fresnelExponent);
#else // ENABLE_CUBE_MAP
#ifdef ENABLE_ANIMATION // blend between two frames
    float4 tex = mix(u_textureSampler0.sample(anim_sampler, in.uv0.xy),
                   u_textureSampler0.sample(anim_sampler, in.uv1.xy), in.uv0.z);
#else
    float4 tex = u_textureSampler0.sample(linear_sampler, in.uv0.xy);
    
#endif // ENABLE_ANIMATION
#endif // ENABLE_CUBE_MAP
#if 0 // ENABLE_SOFT
    tex *= ComputeSoftFactor();
#endif
    
    float4 fragColor;
#ifdef ENABLE_CUBE_MAP
    fragColor.a = in.vertexColor.a * tex.a; // texture and colors need to be premultiplied
#ifdef ENABLE_FOG
    fragColor.rgb = mix(in.vertexColor.rgb + tex.rgb, scn_frame.fogColor.rgb, in.fogFactor) * fragColor.a; // texture and colors need to be premultiplied
#else
    fragColor.rgb = (in.vertexColor.rgb + tex.rgb) * fragColor.a; // texture and colors need to be premultiplied
#endif // ENABLE_FOG
#else
    fragColor = in.vertexColor * tex; // texture and colors need to be premultiplied
#ifdef ENABLE_FOG
    fragColor.rgb = mix(fragColor.rgb, scn_frame.fogColor.rgb * fragColor.a, in.fogFactor); // fog needs to be premultiplied too
#endif // ENABLE_FOG
#endif
    return half4(fragColor);
uniform mat4 u_modelViewProjectionTransform;
uniform mat4 u_transform;
uniform vec4 u_color;
attribute vec3 a_position;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * u_transform * vec4(a_position, 1.);
    v_vertexColor = u_color;
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2  offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
const float alphaThreshold = 0.9;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    float total = 0.0;
    for(i=0;i<n_sample;i++){
        vec4 c = texture2D(textureSampler0, TexCoord+offsets[i]);
        c.rgb *= c.a;
        accum += c * weights[i];
        total += weights[i] * c.a;
    }
    accum /= total;
gl_FragColor = accum;
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
//   Copyright 2013 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#include <metal_stdlib>
using namespace metal;
#import "scn_metal"
struct SCNTessellatorTransforms {
    float4x4 modelViewTransform;
    float4x4 modelViewProjectionTransform;
    float4x4 projectionTransform;
#if OSD_IS_ADAPTIVE
//----------------------------------------------------------
// OSD Kernel
//----------------------------------------------------------
//The user of OSD should define this kernel which serves as the landing point for all patch computation
//This compute function should just be copied and pasted, modifying the section under "User Vertex Transform"
//Or the entire function may be modified as needed (for example to add a patch index buffer)
kernel void compute_opensubdiv(
                               constant SCNTessellatorTransforms&     transforms                     [[ buffer(TRANSFORMS_BUFFER_INDEX) ]],
                               constant float&                        tessellationLevel              [[ buffer(TESSELLATION_LEVEL_BUFFER_INDEX) ]],
                               unsigned                               thread_position_in_grid        [[ thread_position_in_grid ]],
                               unsigned                               thread_position_in_threadgroup [[ thread_position_in_threadgroup ]],
                               unsigned                               threadgroup_position_in_grid   [[ threadgroup_position_in_grid ]],
                               OsdPatchParamBufferSet                 osdBuffers, //This struct contains all of the buffers needed by OSD
                               device MTLQuadTessellationFactorsHalf* quadTessellationFactors        [[ buffer(QUAD_TESSFACTORS_INDEX) ]]
#if OSD_USE_PATCH_INDEX_BUFFER
                               ,device unsigned* patchIndex                                          [[ buffer(OSD_PATCH_INDEX_BUFFER_INDEX) ]]
                               ,device MTLDrawPatchIndirectArguments* drawIndirectCommands           [[ buffer(OSD_DRAWINDIRECT_BUFFER_INDEX) ]]
#endif
                         )
    
    //----------------------------------------------------------
    // OSD Kernel Setup
    //----------------------------------------------------------
    
    //Contains the shared patchParam value used by all threads that act upon a single patch
    //the .z (sharpness) field is set to -1 (NAN) if that patch should be culled to signal other threads to return.
    threadgroup int3 patchParam[PATCHES_PER_THREADGROUP];
    
    threadgroup PatchVertexType patchVertices[PATCHES_PER_THREADGROUP * CONTROL_POINTS_PER_PATCH];
    
    const auto real_threadgroup = thread_position_in_grid / REAL_THREADGROUP_DIVISOR;
    const auto subthreadgroup_in_threadgroup = thread_position_in_threadgroup / REAL_THREADGROUP_DIVISOR;
    const auto real_thread_in_threadgroup = thread_position_in_threadgroup & (REAL_THREADGROUP_DIVISOR - 1);
    
#if NEEDS_BARRIER
    const auto validThread = thread_position_in_grid * CONTROL_POINTS_PER_THREAD < osdBuffers.kernelExecutionLimit;
#else
    const auto validThread = true;
    if(thread_position_in_grid * CONTROL_POINTS_PER_THREAD >= osdBuffers.kernelExecutionLimit)
        return;
#endif
    
    //----------------------------------------------------------
    // OSD Vertex Transform
    //----------------------------------------------------------
    if(validThread)
    {
        patchParam[subthreadgroup_in_threadgroup] = OsdGetPatchParam(real_threadgroup, osdBuffers.patchParamBuffer);
        
        for(unsigned threadOffset = 0; threadOffset < CONTROL_POINTS_PER_THREAD; threadOffset++)
        {
            const auto vertexId = osdBuffers.indexBuffer[(thread_position_in_grid * CONTROL_POINTS_PER_THREAD + threadOffset) * IndexLookupStride];
            const auto v = osdBuffers.vertexBuffer[vertexId];
            
            threadgroup auto& patchVertex = patchVertices[thread_position_in_threadgroup * CONTROL_POINTS_PER_THREAD + threadOffset];
            
            //----------------------------------------------------------
            // User Vertex Transform
            //----------------------------------------------------------
            
            OsdComputePerVertex(float4(v.position,1), patchVertex, vertexId, transforms.modelViewProjectionTransform, osdBuffers);
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_threadgroup);
#endif
    
    
    //----------------------------------------------------------
    // OSD Patch Cull
    //----------------------------------------------------------
    if(validThread)
    {
#if PATCHES_PER_THREADGROUP > 1
        auto patch = patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_THREAD * CONTROL_POINTS_PER_PATCH;
#else
        //Small optimization for the '1 patch per threadgroup' case
        auto patch = patchVertices;
#endif
        
        if(!OsdCullPerPatchVertex(patch, transforms.modelViewTransform))
        {
#if !OSD_USE_PATCH_INDEX_BUFFER
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[0] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[1] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[2] = 0.0h;
            quadTessellationFactors[real_threadgroup].edgeTessellationFactor[3] = 0.0h;
            quadTessellationFactors[real_threadgroup].insideTessellationFactor[0] = 0.0h;
            quadTessellationFactors[real_threadgroup].insideTessellationFactor[1] = 0.0h;
#endif
            
            patchParam[subthreadgroup_in_threadgroup].z = -1;
#if !NEEDS_BARRIER
            return;
#endif
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_threadgroup);
#endif
    
    //----------------------------------------------------------
    // OSD Patch Compute
    //----------------------------------------------------------
    if(validThread && patchParam[subthreadgroup_in_threadgroup].z != -1)
    {
        for(unsigned threadOffset = 0; threadOffset < CONTROL_POINTS_PER_THREAD; threadOffset++)
        {
            OsdComputePerPatchVertex(
                                     patchParam[subthreadgroup_in_threadgroup],
                                     real_thread_in_threadgroup * CONTROL_POINTS_PER_THREAD + threadOffset,
                                     real_threadgroup,
                                     thread_position_in_grid * CONTROL_POINTS_PER_THREAD + threadOffset,
                                     patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_PATCH,
                                     osdBuffers
                                     );
        }
    }
    
#if NEEDS_BARRIER
    threadgroup_barrier(mem_flags::mem_device_and_threadgroup);
#endif
    
    //----------------------------------------------------------
    // OSD Tessellation Factors
    //----------------------------------------------------------
    if(validThread && real_thread_in_threadgroup == 0)
    {
        
#if OSD_USE_PATCH_INDEX_BUFFER
        const auto patchId = atomic_fetch_add_explicit((device atomic_uint*)&drawIndirectCommands->patchCount, 1, memory_order_relaxed);
        patchIndex[patchId] = real_threadgroup;
#else
        const auto patchId = real_threadgroup;
#endif
        
        OsdComputePerPatchFactors(
                                  patchParam[subthreadgroup_in_threadgroup],
                                  tessellationLevel,
                                  real_threadgroup,
                                  transforms.projectionTransform,
                                  transforms.modelViewTransform,
                                  osdBuffers,
                                  patchVertices + subthreadgroup_in_threadgroup * CONTROL_POINTS_PER_PATCH,
                                  quadTessellationFactors[patchId]
                                  );
    }
#endif // OSD_IS_ADAPTIVE
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
<key>factor</key>
<string>C3D-jitter-factor</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
#ifdef __METAL_VERSION__
#define DECLARE_BOOL(a) constant bool a [[ function_constant( __COUNTER__ ) ]];
#define DECLARE_INT(a) constant int a [[ function_constant( 1000 + __COUNTER__ ) ]];
#define DECLARE_UINT(a) constant uint a [[ function_constant( 2000 + __COUNTER__ ) ]];
#define DECLARE_OPT_INT(a) constant int a [[ function_constant( 3000 + __COUNTER__ ) ]];
#define DECLARE_OPT_UINT(a) constant uint a [[ function_constant( 4000 + __COUNTER__ ) ]];
#else
#if !defined(DECLARE_BOOL) || !defined(DECLARE_INT) || !defined(DECLARE_UINT) || !defined(DECLARE_OPT_INT) || !defined(DECLARE_OPT_UINT)
#error Need to declare DECLARE_BOOL and DECLARE_INT macros
#endif
#endif
#define kSCNTexcoordCount 8
// Vertex inputs / attributes
DECLARE_BOOL(need_vertex_color)
DECLARE_BOOL(need_position)
DECLARE_BOOL(need_normal)
DECLARE_BOOL(need_tangent)
DECLARE_BOOL(need_texcoord0)
DECLARE_BOOL(need_texcoord1)
DECLARE_BOOL(need_texcoord2)
DECLARE_BOOL(need_texcoord3)
DECLARE_BOOL(need_texcoord4)
DECLARE_BOOL(need_texcoord5)
DECLARE_BOOL(need_texcoord6)
DECLARE_BOOL(need_texcoord7)
DECLARE_BOOL(use_io_vertex_color)
DECLARE_BOOL(use_io_position)
DECLARE_BOOL(use_io_normal)
DECLARE_BOOL(use_io_view)
// material specifics
DECLARE_BOOL(use_ambient)
DECLARE_BOOL(use_diffuse)
DECLARE_BOOL(use_specular)
DECLARE_BOOL(use_emission)
DECLARE_BOOL(use_multiply)
DECLARE_BOOL(use_reflective)
DECLARE_BOOL(use_transparent)
// Map Shared
DECLARE_BOOL(use_diffuse_map)
DECLARE_BOOL(use_normal_map)
DECLARE_BOOL(use_transparent_map)
DECLARE_BOOL(use_emission_map)
DECLARE_BOOL(use_ambient_map)
// Maps Non PBR
DECLARE_BOOL(use_multiply_map)
DECLARE_BOOL(use_specular_map)
DECLARE_BOOL(use_reflective_map)
DECLARE_BOOL(use_reflectivecube_map)
// Maps PBR
DECLARE_BOOL(use_roughness_map)
DECLARE_BOOL(use_metalness_map)
// Texture Components (only when used with maps)
DECLARE_OPT_INT(diffuse_texture_component)
DECLARE_OPT_INT(normal_texture_component)
DECLARE_OPT_INT(transparent_texture_component)
DECLARE_OPT_INT(emission_texture_component)
DECLARE_OPT_INT(ambient_texture_component)
DECLARE_OPT_INT(multiply_texture_component)
DECLARE_OPT_INT(specular_texture_component)
DECLARE_OPT_INT(reflective_texture_component)
DECLARE_OPT_INT(roughness_texture_component)
DECLARE_OPT_INT(metalness_texture_component)
// Intensity (only when used with maps)
DECLARE_BOOL(use_diffuse_intensity)
DECLARE_BOOL(use_normal_intensity)
DECLARE_BOOL(use_transparent_intensity)
DECLARE_BOOL(use_emission_intensity)
DECLARE_BOOL(use_ambient_intensity)
DECLARE_BOOL(use_multiply_intensity)
DECLARE_BOOL(use_specular_intensity)
DECLARE_BOOL(use_reflective_intensity)
DECLARE_BOOL(use_roughness_intensity)
DECLARE_BOOL(use_metalness_intensity)
DECLARE_BOOL(use_fresnel)
DECLARE_BOOL(use_transparency)
DECLARE_BOOL(use_transparency_rgbzero)
// Mapping Channel (only when used with maps)
DECLARE_INT(diffuse_channel)
DECLARE_INT(normal_channel)
DECLARE_INT(transparent_channel)
DECLARE_INT(emission_channel)
DECLARE_INT(ambient_channel)
DECLARE_INT(multiply_channel)
DECLARE_INT(specular_channel)
DECLARE_INT(roughness_channel)
DECLARE_INT(metalness_channel)
// io uv (only when used with maps)
DECLARE_OPT_INT(diffuse_texcoord_io_index)
DECLARE_OPT_INT(normal_texcoord_io_index)
DECLARE_OPT_INT(transparent_texcoord_io_index)
DECLARE_OPT_INT(emission_texcoord_io_index)
DECLARE_OPT_INT(ambient_texcoord_io_index)
DECLARE_OPT_INT(multiply_texcoord_io_index)
DECLARE_OPT_INT(specular_texcoord_io_index)
DECLARE_OPT_INT(roughness_texcoord_io_index)
DECLARE_OPT_INT(metalness_texcoord_io_index)
// Texture Transform (only when used with maps)
DECLARE_OPT_INT(diffuse_transform_index)
DECLARE_OPT_INT(normal_transform_index)
DECLARE_OPT_INT(transparent_transform_index)
DECLARE_OPT_INT(emission_transform_index)
DECLARE_OPT_INT(ambient_transform_index)
DECLARE_OPT_INT(multiply_transform_index)
DECLARE_OPT_INT(specular_transform_index)
DECLARE_OPT_INT(roughness_transform_index)
DECLARE_OPT_INT(metalness_transform_index)
DECLARE_BOOL(use_emission_as_selfIllumination)
DECLARE_BOOL(use_ambient_as_ambientOcclusion)
DECLARE_BOOL(use_texture_transforms)
DECLARE_BOOL(use_point_rendering)
DECLARE_BOOL(diffuse_premultiplied)
DECLARE_BOOL(use_discard)
// geometry specifics
DECLARE_BOOL(use_instancing)
DECLARE_INT(max_bone_count)
// lighting
DECLARE_INT(lighting_model)
DECLARE_BOOL(use_lighting) // Do we want this or a better suited/name depthOnly for shadow map ?
DECLARE_BOOL(use_ambient_lighting)
DECLARE_BOOL(use_modulate_lighting)
DECLARE_BOOL(use_per_vertex_lighting)
DECLARE_BOOL(avoid_overlighting) // this has to be disabled for HDR. Do we want to keep that
DECLARE_BOOL(use_double_sided)
DECLARE_BOOL(use_probes_lighting)
// only support SH3 for now, so no need for probes_order
DECLARE_OPT_UINT(use_light0);
DECLARE_OPT_UINT(use_light1);
DECLARE_OPT_UINT(use_light2);
DECLARE_OPT_UINT(use_light3);
// node specifics
DECLARE_BOOL(use_node_opacity)
// scene specifics
DECLARE_BOOL(use_fog)
DECLARE_BOOL(use_ssao)
// vertex output
DECLARE_INT(io_texcoord_count)
#undef DECLARE_BOOL
#undef DECLARE_INT
#undef DECLARE_UINT
#undef DECLARE_OPT_INT
#undef DECLARE_OPT_UINT
#import <metal_stdlib>
using namespace metal;
#import "C3D-Histogram.h"
#import "C3D-PostProcessUtils.h"
// MARK: - Analysis
kernel void scn_histogram_analyse(constant uint32_t*                            histogram          [[ buffer(0) ]],
                                  constant scn_histogram_info_t&                info               [[ buffer(1) ]],
                                  constant scn_histogram_analysis_parameters_t& analysisParameters [[ buffer(2) ]],
                                  device   scn_histogram_analysis_t&            analysis           [[ buffer(3) ]])
    // maximum value
    uint32_t numberOfValues = 0;
    analysis.maxValue = 0;
    for (uint32_t i = 0; i < info.numberOfHistogramEntries; ++i) {
        uint32_t entryValue = histogram[i];
        analysis.maxValue = max(analysis.maxValue, entryValue);
        numberOfValues += entryValue;
    }
    
    // average
    analysis.average = 0.0;
    for (uint32_t i = 0; i < info.numberOfHistogramEntries; ++i) {
        uint32_t entryValue = histogram[i];
        analysis.average += float(entryValue) * mix(info.minPixelValue.r, info.maxPixelValue.r, float(i) / float(info.numberOfHistogramEntries - 1));
    }
    analysis.average /= float(numberOfValues);
    
    // quantile bins
    analysis.lowValuesQuantileMaxBin = 0;
    uint32_t entryAccumulator = 0;
    
    for (uint32_t i = 0; i < info.numberOfHistogramEntries; ++i) {
        uint32_t entryValue = histogram[i];
        
        float probability = float(entryAccumulator) / float(numberOfValues);
        if (probability < analysisParameters.lowValuesQuantileProbability) {
            analysis.lowValuesQuantileMaxBin = i;
        }
        if (probability < analysisParameters.highValuesQuantileProbability) {
            analysis.highValuesQuantileMinBin = i;
        }
        
        entryAccumulator += entryValue;
    }
    
    // adjusted average
    analysis.adjustedAverage = 0.0;
    entryAccumulator = 0;
    for (uint32_t i = analysis.lowValuesQuantileMaxBin; i <= analysis.highValuesQuantileMinBin; ++i) {
        uint32_t entryValue = histogram[i];
        analysis.adjustedAverage += float(entryValue) * mix(info.minPixelValue.r, info.maxPixelValue.r, float(i) / float(info.numberOfHistogramEntries - 1));
        entryAccumulator += entryValue;
    }
    analysis.adjustedAverage /= float(entryAccumulator);
// MARK: - Drawing
constant float4 kBackgroundColor = float4(0.1, 0.1, 0.1, 0.99);
constant float4 kHighlightColor = float4(0.1, 0.5, 0.1, 0.99);
fragment float4 scn_draw_histogram_fragment(scn::draw_quad_io_t            in            [[ stage_in ]],
                                            constant uint32_t*             histogram     [[ buffer(0) ]],
                                            constant scn_histogram_info_t& histogramInfo [[ buffer(1) ]])
    uint32_t i = round(in.uv.x * float(2 * C3D_HISTOGRAM_DRAW_BORDER + histogramInfo.numberOfHistogramEntries - 1));
    uint32_t j = round((1.0 - in.uv.y) * float(C3D_HISTOGRAM_DRAW_BORDER + histogramInfo.numberOfHistogramEntries - 1));
    
    if (i < C3D_HISTOGRAM_DRAW_BORDER || i >= histogramInfo.numberOfHistogramEntries + C3D_HISTOGRAM_DRAW_BORDER || j > histogramInfo.numberOfHistogramEntries) {
        return kBackgroundColor;
    }
    
    uint32_t maxEntryValue = 0;
    for (uint32_t i = 0; i < histogramInfo.numberOfHistogramEntries * 3; ++i) {
        maxEntryValue = max(maxEntryValue, histogram[i]);
    }
    
    i = i - C3D_HISTOGRAM_DRAW_BORDER;
    
    uint32_t r = histogram[0 * histogramInfo.numberOfHistogramEntries + i];
    uint32_t g = histogram[1 * histogramInfo.numberOfHistogramEntries + i];
    uint32_t b = histogram[2 * histogramInfo.numberOfHistogramEntries + i];
    
    float y = (1.0 - in.uv.y) * float(C3D_HISTOGRAM_DRAW_BORDER + histogramInfo.numberOfHistogramEntries - 1) / float(histogramInfo.numberOfHistogramEntries - 1);
    
    bool3 result = bool3(y < float(r) / float(maxEntryValue),
                         y < float(g) / float(maxEntryValue),
                         y < float(b) / float(maxEntryValue));
    
    if (any(result)) {
        return float4(result.x, result.y, result.z, 1.0);
    }
    else {
        return kBackgroundColor;
    }
fragment float4 scn_draw_monochrome_histogram_fragment(scn::draw_quad_io_t                in                [[ stage_in ]],
                                                       constant uint32_t*                 histogram         [[ buffer(0) ]],
                                                       constant scn_histogram_info_t&     histogramInfo     [[ buffer(1) ]],
                                                       constant scn_histogram_analysis_t& histogramAnalysis [[ buffer(2) ]])
    uint32_t i = round(in.uv.x * float(2 * C3D_HISTOGRAM_DRAW_BORDER + histogramInfo.numberOfHistogramEntries - 1));
    uint32_t j = round((1.0 - in.uv.y) * float(C3D_HISTOGRAM_DRAW_BORDER + histogramInfo.numberOfHistogramEntries - 1));
    
    if (i < C3D_HISTOGRAM_DRAW_BORDER || i >= histogramInfo.numberOfHistogramEntries + C3D_HISTOGRAM_DRAW_BORDER || j > histogramInfo.numberOfHistogramEntries) {
        return kBackgroundColor;
    }
    
    i = i - C3D_HISTOGRAM_DRAW_BORDER;
    
    float y = (1.0 - in.uv.y) * float(C3D_HISTOGRAM_DRAW_BORDER + histogramInfo.numberOfHistogramEntries - 1) / float(histogramInfo.numberOfHistogramEntries - 1);
    uint32_t r = histogram[i];
    bool result = y < float(r) / float(histogramAnalysis.maxValue);
    
    { // CDF
        uint32_t numberOfValues = 0;
        for (uint32_t index = 0; index < histogramInfo.numberOfHistogramEntries; ++index) {
            uint32_t entryValue = histogram[index];
            numberOfValues += entryValue;
        }
        
        uint32_t entryAccumulator = 0;
        for (uint32_t index = 0; index <= i; ++index) {
            entryAccumulator += histogram[index];
        }
        
        if (round(histogramInfo.numberOfHistogramEntries * y) == round(histogramInfo.numberOfHistogramEntries * float(entryAccumulator) / float(numberOfValues))) {
            return float4(1.0, 0.0, 0.0, 1.0);
        }
    }
    
    if (all(result)) {
        return float4(result, result, result, 1.0);
    }
    else {
        if (histogramAnalysis.lowValuesQuantileMaxBin <= i && i <= histogramAnalysis.highValuesQuantileMinBin) {
            return kHighlightColor;
        }
        else {
            return kBackgroundColor;
        }
    }
#import <simd/simd.h>
#ifdef __cplusplus
using namespace simd;
// Should we do uniforms buffers per light type ?
// would be cleaner...
struct LightData {
    float4 positionVS_invSquareRadius; // needed for attenuation windowing
    float4 color_unscaledRadius; // needed for vertices expansion
    float4 direction_tanConeAngle; // only valid for directional lights and spot lights
    float2 spotAttenuation; // only valid for spot lights
    // should move in the SceneBuffer
    float4x4 invProjectionTransform;
struct commonprofile_uniforms_ds {
    
    float4 diffuseIntensity;
    float4 emissionIntensity;
    
    float ambientIntensity;
    float normalIntensity;
    float roughnessIntensity;
    float metalnessIntensity;
    
    float3x2 diffuseTransform;
    float3x2 ambientTransform;
    float3x2 emissionTransform;
    float3x2 normalTransform;
    
#endif
attribute vec4 a_position;
varying vec2 uv;
void main(void)
    gl_Position = a_position;
    uv = (a_position.xy + 1.0) * 0.5;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-PostProcessUtils.h"
#import "C3D-DeferredShadingCommon.h"
#import "C3D-PBR.metal"
struct LightUniforms {
    float4x4 modelTransform;
    float4x4 modelViewTransform;
    float4x4 normalTransform;
struct LightVertex {
    float3 position [[attribute(0)]];
struct LightIO {
    float4 position [[position]];
    float3 positionVS;
// everything stored in view space
struct Surface {
    SCNPBRSurface pbr;
    
    float   depth;
    float3  position;
    float4  xxxx; // unusued yet
// IOS only
// fragment FragmentOutput ds_default_frag(light_io in [[stage_in]], FragmentOutput gBuffers)
// Desktop version : surface created from fetching textures
static Surface createSurface(float4 positionSS, texture2d<float> albedo_roughness, texture2d<float> normal_depth, texture2d<float> texture3)
    Surface s;
    
#if 0 // normalized sampling
    constexpr sampler gbufferSampler(filter::nearest);
    float2 uv = positionSS.xy / float2(texture1.get_width(), texture1.get_height());
#else // pixel sampling
    constexpr sampler gbufferSampler(coord::pixel, filter::nearest);
    float2 uv = positionSS.xy;
#endif
    float4 a_r = albedo_roughness.sample(gbufferSampler, uv);
    s.pbr.albedo = a_r.rgb;
    s.pbr.roughness = a_r.a;
    s.pbr.metalness = 1.0; // TODO
    
    float4 n_d = normal_depth.sample(gbufferSampler, uv);
    s.pbr.n = normalize(n_d.xyz);
    s.depth = n_d.w;
    // no need to rescale since we store in fp texture
    // gb.normal_depth.xyz = gb.normal_depth.xyz * 2. - 1.;
    
    s.xxxx = texture3.sample(gbufferSampler, uv);
    
    return s;
static float distanceAttenuation(float3 lightVector, float invLightSquareRadius)
    float sqrDist = dot(lightVector, lightVector);
    float att = 1. / max(sqrDist, 0.0001);
    // smoothing factor to avoid hard clip of the lighting
    float factor = saturate(1. - sqrDist * invLightSquareRadius);
    factor *= factor;
    return att * factor;
static float angleAttenuation(float3 L, float3 lightDir, float2 spotAttenuation)
    float d = dot(lightDir, L);
    float att = saturate(d * spotAttenuation.x + spotAttenuation.y);
    return att * att;
#if USE_PBR
static float Fr_DisneyDiffuse(float NdotV, float NdotL, float LdotH, float linearRoughness)
    float energyBias = mix(0, 0.5, linearRoughness);
    float energyFactor = mix(1.0, 1.0 / 1.51, linearRoughness);
    float fd90 = energyBias + 2.0 * LdotH*LdotH * linearRoughness;
    float3 f0 = float3(1.0f, 1.0f, 1.0f);
    float lightScatter = F_Schlick(f0, fd90, NdotL).r;
    float viewScatter = F_Schlick(f0, fd90, NdotV).r;
    
    return lightScatter * viewScatter * energyFactor;
#endif
// Glossary
// N: surface normal (unit vector)
// V: view vector: surface to eye (unit vector)
// L: light vector: light to surface
static float3 illuminate(Surface surface, float3 L, float3 lightColor)
    float3 N        = surface.normal;
    float3 V        = surface.view;
    
#if USE_PBR // PBR
    const float PI  = 3.14159265;
    // Should come from material / GBuffer
    float roughness = 1 - surface.roughness * surface.roughness;
    float3 f0       = float3(1.0);
    float f90       = saturate(50.0 * dot(f0, 0.33));
    
    float NdotV     = abs(dot(N,V)) + 1e-5f; // avoid artifact
    float3 H        = normalize(V + L);
    float LdotH     = saturate(dot(L, H));
    float NdotH     = saturate(dot(N, H));
    float NdotL     = saturate(dot(N, L));
    
    // Specular BRDF
    float3 F        = F_Schlick(f0, f90, LdotH);
    float vis       = V_SmithGGXCorrelated(NdotV, NdotL, roughness);
    float D         = D_GGX(NdotH, roughness);
    float3 Fr       = D * F * vis / PI;
    
    float Fd        = Fr_DisneyDiffuse(NdotV, NdotL, LdotH, roughness);
    
    return lightColor * (surface.albedo * Fd + Fr);
#else
    // diffuse
    float diff = saturate(dot(N, L));
    
    // specular
    float shininess = surface.roughness * 128.;
    float3 H = normalize(V + L);
    float3 spec = pow(saturate(dot(N, H)), shininess);
    
    float3 luminance = lightColor * ((surface.albedo + spec) * diff);
    return luminance;
#endif
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_dir_vert(constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                           constant LightData& lightData [[buffer(2)]],
                           uint v_id [[ vertex_id ]])
    float4 in_position = scn::draw_quad_pos_from_id(v_id, 1.0);
    
    LightIO out;
    out.position = in_position;
    
    float3 positionVS = (lightData.invProjectionTransform * in_position).xyz;
    out.positionVS = float3(positionVS.xy / -positionVS.z, -1.);
    
    return out;
// Fragment shader function
fragment half4 ds_light_frag(LightIO in [[stage_in]] ,
                             constant LightData& lightData [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(1)]],
                             texture2d<float> gBuffer1 [[texture(1)]],
                             texture2d<float> gBuffer2 [[texture(2)]],
                             texture2d<float> gBuffer3 [[texture(3)]])
    Surface surface = createSurface(in.position, gBuffer1, gBuffer2, gBuffer3);
    
    // TODO Optimize -> store in SceneBuffer
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    float farClip = d / (1.f + c);
    
    float scene_z = surface.depth * farClip;
    surface.position = in.positionVS * scene_z;
    surface.pbr.v    = -normalize(surface.position);
    
//    float3 lightColor = lightData.color_unscaledRadius.rgb;
//    float3 lightDir = lightData.direction_tanConeAngle.xyz;
    // Debugging
    /*
    if (in.position.x < 300) {
//        return half4(gb.normal_depth.w);
        return half4(float4(v, 1.0));
    } else {
        return half4(float4(gb.roughness.xyz, 1.0));
//    } else if (in.texcoord.x < 0.75) {
//        return half4(abs(dot(n, lightDir)));
    }
     */
    
    float4 light = 1.;
//    light.rgb = PBR_illuminate(lightColor, lightDir, surface.pbr);
// TODO
    
    return half4( light );
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_omni_vert(LightVertex in [[ stage_in ]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                            constant LightUniforms& scn_node [[buffer(1)]],
                            constant LightData& lightData [[buffer(2)]])
    float4 in_position = float4(in.position * lightData.color_unscaledRadius.w, 1.0);
    
    LightIO out;
    out.positionVS =  (scn_node.modelViewTransform * in_position).xyz;
    out.position = scn_frame.projectionTransform * float4(out.positionVS, 1.0);
    return out;
fragment half4 ds_omni_frag(LightIO in [[stage_in]],
                            constant LightData& lightData [[buffer(0)]],
                            constant SCNSceneBuffer& scn_frame [[buffer(1)]],
                            texture2d<float> gBuffer1 [[texture(1)]],
                            texture2d<float> gBuffer2 [[texture(2)]],
                            texture2d<float> gBuffer3 [[texture(3)]]
                            )
    Surface surface = createSurface(in.position, gBuffer1, gBuffer2, gBuffer3);
    
    // TODO Optimize -> store in SceneBuffer
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    float farClip = d / (1.f + c);
    
    float scene_z = surface.depth * farClip;
    surface.position = in.positionVS * (scene_z / -in.positionVS.z);
    surface.pbr.v    = -normalize(surface.position);
    
    float3 lightColor = lightData.color_unscaledRadius.rgb;
    float3 lightPosition = lightData.positionVS_invSquareRadius.xyz;
    float  lightInvSquareRadius = lightData.positionVS_invSquareRadius.w;
    
    float3 unnormalizedLightVector = lightPosition - surface.position;
    float att = distanceAttenuation(unnormalizedLightVector, lightInvSquareRadius);
    float4 light(0.);
//    light.rgb = att * PBR_illuminate(lightColor, normalize(unnormalizedLightVector), surface.pbr);
// TODO
    light.rgb = att * lightColor;
    
//    result.xyz = half3(lightData.color.xyz);
    return half4( light );
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_spot_vert(LightVertex in [[ stage_in ]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                            constant LightUniforms& scn_node [[buffer(1)]],
                            constant LightData& lightData [[buffer(2)]])
    // Transform the cone (original apex in 0,1,0) and scale it with cone properties
    float3 pt = float3(in.position.x, - in.position.z, in.position.y - 0.5);
    pt.z *= lightData.color_unscaledRadius.w; // attenuation/radius
    pt.xy *= lightData.direction_tanConeAngle.w * pt.z; // expansion radial
    
    float4 in_position = float4(pt, 1.0);
    
    LightIO out;
    out.positionVS =  (scn_node.modelViewTransform * in_position).xyz;
    out.position = scn_frame.projectionTransform * float4(out.positionVS, 1.0);
    return out;
fragment half4 ds_spot_frag(LightIO in [[stage_in]],
                            constant LightData& lightData [[buffer(0)]],
                            constant SCNSceneBuffer& scn_frame [[buffer(1)]],
                            texture2d<float> gBuffer1 [[texture(1)]],
                            texture2d<float> gBuffer2 [[texture(2)]],
                            texture2d<float> gBuffer3 [[texture(3)]]
                            )
    Surface surface = createSurface(in.position, gBuffer1, gBuffer2, gBuffer3);
    
    // TODO Optimize -> store in SceneBuffer
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    float farClip = d / (1.f + c);
    
    float scene_z = surface.depth * farClip;
    
    surface.position = in.positionVS * (scene_z / -in.positionVS.z);
    surface.pbr.v    = -normalize(surface.position);
//    return half4(float4(surface.view.rg, 1.0, 1.0));
    float3 lightColor = lightData.color_unscaledRadius.rgb;
    float3 lightPosition = lightData.positionVS_invSquareRadius.xyz;
    float3 lightDirection = lightData.direction_tanConeAngle.xyz;
    float  lightInvSquareRadius = lightData.positionVS_invSquareRadius.w;
    
    float3 unnormalizedLightVector = lightPosition - surface.position;
    float att = distanceAttenuation(unnormalizedLightVector, lightInvSquareRadius);
    
    att *= angleAttenuation(normalize(unnormalizedLightVector), lightDirection, lightData.spotAttenuation);
    
    //
    float4 light(0.);
//    light.rgb = att * PBR_illuminate(lightColor, normalize(unnormalizedLightVector), surface.pbr);
// TODO
    light.rgb = lightColor * att;
    
    //    result.xyz = half3(lightData.color.xyz);
    return half4( light );
struct SCNShaderSurface
vec3 view; // in view space
vec3 position; // in view space
vec3 normal; // in view space
vec3 tangent; // in view space
vec3 bitangent; // in view space
float shininess;
    float fresnel;
    float ambientOcclusion;
vec3 _normalTS; // UNDOCUMENTED in tangent space
float hash(vec2 p)
    p  = fract(p * vec2(443.8975,397.2973));
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
#pragma body
float x = hash(u_modelTransform[3].xy);
_output.color = vec4(x+1./255.);
uniform sampler2D u_color;
uniform sampler2D u_depth;
uniform float     u_middleZ;
varying vec2 TexCoord;
void main (void)
gl_FragColor = texture2D(u_color,TexCoord);
    
#ifndef GL_ES
    gl_FragDepth = texture2D(u_depth,TexCoord).r;
    
    if(gl_FragDepth == 1.0){
        gl_FragDepth = u_middleZ;
    }
#endif
    
    //gl_FragColor.g = 0.3;
    //gl_FragColor = vec4(0.0,1.0,0.0,1.0);
    
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>Outline-pickedObjects</string>
<string>Outline-outline</string>
</array>
<key>passes</key>
<dict>
<key>Outline-pickedObjects</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>Outline-outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Outline</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outline_vert</string>
<key>metalFragmentShader</key>
<string>outline_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
typedef struct {
    vector_float2 quadOrigin;
    vector_float2 quadSize;
    vector_float2 drawableSize;
} draw_quad_frame_t;
  struct scn_floor {
    float2 u_floor_viewport;
    float u_floorReflectivity;
#ifdef USE_FALLOFF
    float4x4 u_floorMVP_i;
    float4 u_floorPlane;
    float u_floorFalloff;
#ifdef USE_FALLOFF_START
    float u_floorFalloffStart;
#endif
#endif
static inline float3 floorUnprojectPoint(float3 screenPos, float4x4 mvp_i)
    float4 pTmp = mvp_i * float4(screenPos.xy * 2.0 - 1.0, screenPos.z, 1.0);
    return pTmp.xyz / pTmp.w;
#pragma arguments
scn_floor scn_floorSurf
texture2d u_floorReflectionColor;
depth2d u_floorReflectionDepth;
#pragma body
float2 normalizedFragCoord = in.fragmentPosition.xy * scn_floorSurf.u_floor_viewport;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
constexpr sampler linear_sampler(filter::linear);
float4 floorColor = u_floorReflectionColor.sample(linear_sampler, normalizedFragCoord);
float reflectionFactor = scn_floorSurf.u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = u_floorReflectionDepth.sample(linear_sampler, normalizedFragCoord);
float3  floorPW = floorUnprojectPoint(float3(normalizedFragCoord.x, 1. - normalizedFragCoord.y, floorDepth), scn_floorSurf.u_floorMVP_i);
float floorDist = -dot(floorPW.xyz, scn_floorSurf.u_floorPlane.xyz) - scn_floorSurf.u_floorPlane.w;;
#ifdef USE_FALLOFF_START
floorDist -= scn_floorSurf.u_floorFalloffStart; // Falloff has been updated in CPU
#endif // USE_FALLOFF_START
reflectionFactor *= 1.0 - clamp(floorDist / scn_floorSurf.u_floorFalloff, 0.0, 1.0);
#endif // USE_FALLOFF
floorColor *= reflectionFactor; // integrate reflection factor
_output.color.rgb *= (1. - floorColor.a); // obscure existing color with reflection opacity
_output.color.rgba += floorColor.rgba; // additive blending with premultiplied alpha
attribute vec3 a_position;
varying vec2 TexCoord;
uniform mat4 u_textureMatrix;
void main(void)
gl_Position = vec4(a_position, 1.0);
    TexCoord = (u_textureMatrix * vec4(a_position.xy, 0., 1.)).xy * 0.5 + 0.5;
TexCoord.y = 1.0 - TexCoord.y;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>computeVelocity</string>
<string>blur1</string>
<string>blur2</string>
<string>renderMovableNodes</string>
</array>
<key>passes</key>
<dict>
<key>blur1</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>velocitySampler</key>
<string>VELOCITY</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_6taps</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>blur2</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>velocitySampler</key>
<string>VELOCITY</string>
<key>intensity</key>
<string>C3D-MotionBlur-Intensity-symbol</string>
</dict>
<key>program</key>
<string>C3D-GLSL-UNAVAILABLE</string>
<key>clientProgram</key>
<string>NO</string>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalFragmentShader</key>
<string>scn_motionblur_blur_12taps</string>
<key>metalVertexShader</key>
<string>scn_motionblur_vert</string>
</dict>
<key>renderMovableNodes</key>
<dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>onlyMovableNodes</key>
<true/>
<key>samples</key>
<integer>1</integer>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>C3D-MotionBlur-Intensity-symbol</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-oldViewProjectionTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>C3D-viewProjectionInverseTransform-symbol</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>VELOCITY</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba16f</string>
<key>scaleFactor</key>
<real>0.25</real>
</dict>
<key>blur-target</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
uniform float u_floorReflectivity;
uniform sampler2D u_floorReflectionColor;
uniform vec2 u_floor_viewport;
#ifdef USE_FALLOFF
uniform mat4 u_floorMVP_i;
uniform vec4 u_floorPlane;
uniform float u_floorFalloff;
#ifdef USE_FALLOFF_START
uniform float u_floorFalloffStart;
#endif
uniform sampler2D u_floorReflectionDepth;
vec3 floorUnprojectPoint(vec3 screenPos)
    vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
    pTmp.w = 1.0;
    pTmp = u_floorMVP_i * pTmp;
    pTmp /= pTmp.w;
    return vec3(pTmp);
#endif // USE_FALLOFF
#pragma body
vec2 normalizedFragCoord = gl_FragCoord.xy * u_floor_viewport;
normalizedFragCoord.xy += 0.2 * _surface._normalTS.xy;
vec4 floorColor = texture2D(u_floorReflectionColor, normalizedFragCoord);
float reflectionFactor = u_floorReflectivity;
#ifdef USE_FALLOFF
float floorDepth = texture2D(u_floorReflectionDepth, normalizedFragCoord).x;
vec3  floorPW = floorUnprojectPoint(vec3(normalizedFragCoord, floorDepth));
float floorDist = - dot(vec4(floorPW.xyz, 1.0), u_floorPlane);
#ifdef USE_FALLOFF_START
floorDist -= u_floorFalloffStart; // Falloff has been updated in CPU
#endif // USE_FALLOFF_START
reflectionFactor *= 1.0 - clamp(floorDist / u_floorFalloff, 0.0, 1.0);
#endif // USE_FALLOFF
floorColor *= reflectionFactor; // integrate reflection factor
_output.color.rgb *= (1. - floorColor.a); // obscure existing color with reflection opacity
_output.color.rgba += floorColor.rgba; // additive blending with premultiplied alpha
  "passes" : {
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "ignoreFloors" : true,
      "draw" : "DRAW_NODE",
      "node" : "self"
    },
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_m" : "C3D-CIFilter_modelMatrix",
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "program" : "C3D-CIFilterComposite",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    }
  },
  "sequence" : [
    "SceneKit_renderCINodeTree",
    "SceneKit_ApplyCIFilter",
    "SceneKit_renderCIQuad"
  ],
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_modelMatrix" : {
      "type" : "mat4"
    }
  },
  "targets" : {
    "SceneKit-CI-effect-color" : {
      "type" : "color"
    },
    "SceneKit-CI-nodetree-color" : {
      "target" : "texture_rectangle",
      "type" : "color"
    },
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    }
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
struct blend_uniforms {
    float weights[8];
    uint  maxIndex;
// Position only
kernel void blend_init_8x_p_kernel(uint index          [[ thread_position_in_grid ]],
                                    device packed_float3* outP       [[ buffer(0) ]],
                                    constant blend_uniforms& uniforms[[ buffer(3) ]],
                                    device packed_float3* base     [[ buffer(4) ]],
                                    device packed_float3* delta0   [[ buffer(5) ]],
                                    device packed_float3* delta1   [[ buffer(6) ]],
                                    device packed_float3* delta2   [[ buffer(7) ]],
                                    device packed_float3* delta3   [[ buffer(8) ]],
                                    device packed_float3* delta4   [[ buffer(9) ]],
                                    device packed_float3* delta5   [[ buffer(10) ]],
                                    device packed_float3* delta6   [[ buffer(11) ]],
                                    device packed_float3* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    outP[index] = base[index]
    + uniforms.weights[0] * delta0[index]
    + uniforms.weights[1] * delta1[index]
    + uniforms.weights[2] * delta2[index]
    + uniforms.weights[3] * delta3[index]
    + uniforms.weights[4] * delta4[index]
    + uniforms.weights[5] * delta5[index]
    + uniforms.weights[6] * delta6[index]
    + uniforms.weights[7] * delta7[index];
kernel void blend_add_8x_p_kernel(uint index          [[ thread_position_in_grid ]],
                                   device packed_float3* outP       [[ buffer(0) ]],
                                   constant blend_uniforms& uniforms[[ buffer(3) ]],
                                   device packed_float3* delta0   [[ buffer(5) ]],
                                   device packed_float3* delta1   [[ buffer(6) ]],
                                   device packed_float3* delta2   [[ buffer(7) ]],
                                   device packed_float3* delta3   [[ buffer(8) ]],
                                   device packed_float3* delta4   [[ buffer(9) ]],
                                   device packed_float3* delta5   [[ buffer(10) ]],
                                   device packed_float3* delta6   [[ buffer(11) ]],
                                   device packed_float3* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    outP[index] += uniforms.weights[0] * delta0[index]
    + uniforms.weights[1] * delta1[index]
    + uniforms.weights[2] * delta2[index]
    + uniforms.weights[3] * delta3[index]
    + uniforms.weights[4] * delta4[index]
    + uniforms.weights[5] * delta5[index]
    + uniforms.weights[6] * delta6[index]
    + uniforms.weights[7] * delta7[index];
// Position + Normal
typedef struct
    packed_float3 position;
    packed_float3 normal;
} morph_target_PN;
kernel void blend_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                    device packed_float3* outP       [[ buffer(0) ]],
                                    device packed_float3* outN       [[ buffer(1) ]],
                                    constant blend_uniforms& uniforms[[ buffer(3) ]],
                                    device morph_target_PN* base     [[ buffer(4) ]],
                                    device morph_target_PN* delta0   [[ buffer(5) ]],
                                    device morph_target_PN* delta1   [[ buffer(6) ]],
                                    device morph_target_PN* delta2   [[ buffer(7) ]],
                                    device morph_target_PN* delta3   [[ buffer(8) ]],
                                    device morph_target_PN* delta4   [[ buffer(9) ]],
                                    device morph_target_PN* delta5   [[ buffer(10) ]],
                                    device morph_target_PN* delta6   [[ buffer(11) ]],
                                    device morph_target_PN* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    outP[index] = base[index].position
    + uniforms.weights[0] * delta0[index].position
    + uniforms.weights[1] * delta1[index].position
    + uniforms.weights[2] * delta2[index].position
    + uniforms.weights[3] * delta3[index].position
    + uniforms.weights[4] * delta4[index].position
    + uniforms.weights[5] * delta5[index].position
    + uniforms.weights[6] * delta6[index].position
    + uniforms.weights[7] * delta7[index].position;
    
    outN[index] = base[index].normal
    + uniforms.weights[0] * delta0[index].normal
    + uniforms.weights[1] * delta1[index].normal
    + uniforms.weights[2] * delta2[index].normal
    + uniforms.weights[3] * delta3[index].normal
    + uniforms.weights[4] * delta4[index].normal
    + uniforms.weights[5] * delta5[index].normal
    + uniforms.weights[6] * delta6[index].normal
    + uniforms.weights[7] * delta7[index].normal;
kernel void blend_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                   device packed_float3* outP       [[ buffer(0) ]],
                                   device packed_float3* outN       [[ buffer(1) ]],
                                   constant blend_uniforms& uniforms[[ buffer(3) ]],
                                   device morph_target_PN* delta0   [[ buffer(5) ]],
                                   device morph_target_PN* delta1   [[ buffer(6) ]],
                                   device morph_target_PN* delta2   [[ buffer(7) ]],
                                   device morph_target_PN* delta3   [[ buffer(8) ]],
                                   device morph_target_PN* delta4   [[ buffer(9) ]],
                                   device morph_target_PN* delta5   [[ buffer(10) ]],
                                   device morph_target_PN* delta6   [[ buffer(11) ]],
                                   device morph_target_PN* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    outP[index] += uniforms.weights[0] * delta0[index].position
    + uniforms.weights[1] * delta1[index].position
    + uniforms.weights[2] * delta2[index].position
    + uniforms.weights[3] * delta3[index].position
    + uniforms.weights[4] * delta4[index].position
    + uniforms.weights[5] * delta5[index].position
    + uniforms.weights[6] * delta6[index].position
    + uniforms.weights[7] * delta7[index].position;
    
    outN[index] += uniforms.weights[0] * delta0[index].normal
    + uniforms.weights[1] * delta1[index].normal
    + uniforms.weights[2] * delta2[index].normal
    + uniforms.weights[3] * delta3[index].normal
    + uniforms.weights[4] * delta4[index].normal
    + uniforms.weights[5] * delta5[index].normal
    + uniforms.weights[6] * delta6[index].normal
    + uniforms.weights[7] * delta7[index].normal;
/// Packed_Normal
static inline float4 unpack_snorm10a2_to_float(uint n) {
    const float4 scale = { 1 / 511.f, 1 / 511.f, 1 / 511.f, 1 / 3.f };
    short4 i = { short(((int)n << 22) >> 22), short(((int)n << 12) >> 22), short(((int)n << 2) >> 22), short(n >> 30) };
    float4 f = float4(i);
    return f * scale;
static inline uint pack_float_to_snorm10a2(float4 v) {
//    v = clamp(v, float4(-1), float4(1));
    const float4 scale = { 511.f, 511.f, 511.f, 3.f };
    const uint4 mask = { 0x3ff, 0x3ff, 0x3ff, 0x3 };
    const uint4 iv = as_type<uint4>(int4(v * scale)) & mask;
    return (iv.x<<0)|(iv.y<<10)|(iv.z<<20)|(iv.w<<30);
static inline float4 unpack_snorm10a2_to_float(uint n) {
    return unpack_unorm10a2_to_float(n) * 2. - 1.;
static inline uint pack_float_to_snorm10a2(float4 v) {
    return pack_float_to_unorm10a2(v * 0.5 + 0.5);
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blendpack_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                        device packed_float3* outP       [[ buffer(0) ]],
                                        device packed_float3* outN       [[ buffer(1) ]],
                                        constant blend_uniforms& uniforms[[ buffer(3) ]],
                                        device float4* base     [[ buffer(4) ]],
                                        device float4* delta0   [[ buffer(5) ]],
                                        device float4* delta1   [[ buffer(6) ]],
                                        device float4* delta2   [[ buffer(7) ]],
                                        device float4* delta3   [[ buffer(8) ]],
                                        device float4* delta4   [[ buffer(9) ]],
                                        device float4* delta5   [[ buffer(10) ]],
                                        device float4* delta6   [[ buffer(11) ]],
                                        device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float4 base_val = base[index];
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = base_val.xyz
    + w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    float3 normal = unpack_snorm10a2_to_float(as_type<uint>(base_val.w)).xyz
    + w0 * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + w1 * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + w2 * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + w3 * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + w4 * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + w5 * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + w6 * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + w7 * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    
    outP[index] = pos;
    outN[index] = normal;
kernel void blendpack_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                       device packed_float3* outP       [[ buffer(0) ]],
                                       device packed_float3* outN       [[ buffer(1) ]],
                                       constant blend_uniforms& uniforms[[ buffer(3) ]],
                                       device float4* delta0   [[ buffer(5) ]],
                                       device float4* delta1   [[ buffer(6) ]],
                                       device float4* delta2   [[ buffer(7) ]],
                                       device float4* delta3   [[ buffer(8) ]],
                                       device float4* delta4   [[ buffer(9) ]],
                                       device float4* delta5   [[ buffer(10) ]],
                                       device float4* delta6   [[ buffer(11) ]],
                                       device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    float3 normal = w0 * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + w1 * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + w2 * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + w3 * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + w4 * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + w5 * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + w6 * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + w7 * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] += pos;
    outN[index] += normal;
// PackedNormal10a2
// Output interleaved
// we store position (xyz) and normal (stored as a 10a2) in (w) component for morph targets
// we output a single float4 where xyz contains float position values and normal is stored
// as a 10a2 stored in w component.
kernel void blendpack_dstint_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                            //                                            device packed_float3* outP       [[ buffer(0) ]],
                                            //                                            device packed_float3* outN       [[ buffer(1) ]],
                                            device float4* outPN       [[ buffer(0) ]],
                                            constant blend_uniforms& uniforms[[ buffer(3) ]],
                                            device float4* base     [[ buffer(4) ]],
                                            device float4* delta0   [[ buffer(5) ]],
                                            device float4* delta1   [[ buffer(6) ]],
                                            device float4* delta2   [[ buffer(7) ]],
                                            device float4* delta3   [[ buffer(8) ]],
                                            device float4* delta4   [[ buffer(9) ]],
                                            device float4* delta5   [[ buffer(10) ]],
                                            device float4* delta6   [[ buffer(11) ]],
                                            device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float4 base_val = base[index];
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = base_val.xyz
    + uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    float3 normal = unpack_snorm10a2_to_float(as_type<uint>(base_val.w)).xyz
    + uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outPN[index] = float4(pos, as_type<float>(pack_float_to_snorm10a2(float4(normal, 1.0f))));
// we store position (xyz) and normal (stored as a 10a2) in (w) component for morph targets
// we output a single float4 where xyz contains float position values and normal is stored
// as a 10a2 stored in w component.
kernel void blendpack_dstint_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                           device float4* outPN       [[ buffer(0) ]],
                                           constant blend_uniforms& uniforms[[ buffer(3) ]],
                                           device float4* delta0   [[ buffer(5) ]],
                                           device float4* delta1   [[ buffer(6) ]],
                                           device float4* delta2   [[ buffer(7) ]],
                                           device float4* delta3   [[ buffer(8) ]],
                                           device float4* delta4   [[ buffer(9) ]],
                                           device float4* delta5   [[ buffer(10) ]],
                                           device float4* delta6   [[ buffer(11) ]],
                                           device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    float3 normal = uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    float4 old_PN_val = outPN[index];
    old_PN_val.xyz += pos;
    normal += unpack_snorm10a2_to_float(as_type<uint>(old_PN_val.w)).xyz;
    
    old_PN_val.w = as_type<float>(pack_float_to_snorm10a2(float4(normal, 1.0f)));
    outPN[index] = old_PN_val;
/// Packed Half
// Need this packing instruction because alignment otherwise is 16 bytes
struct __attribute__((__packed__)) morphpackhalf_target_PN
    half4 position;
    uint normal;
kernel void blendpackhalf_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                        device packed_float3* outP       [[ buffer(0) ]],
                                        device packed_float3* outN       [[ buffer(1) ]],
                                        constant blend_uniforms& uniforms[[ buffer(3) ]],
                                        device morphpackhalf_target_PN* base     [[ buffer(4) ]],
                                        device morphpackhalf_target_PN* delta0   [[ buffer(5) ]],
                                        device morphpackhalf_target_PN* delta1   [[ buffer(6) ]],
                                        device morphpackhalf_target_PN* delta2   [[ buffer(7) ]],
                                        device morphpackhalf_target_PN* delta3   [[ buffer(8) ]],
                                        device morphpackhalf_target_PN* delta4   [[ buffer(9) ]],
                                        device morphpackhalf_target_PN* delta5   [[ buffer(10) ]],
                                        device morphpackhalf_target_PN* delta6   [[ buffer(11) ]],
                                        device morphpackhalf_target_PN* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    half3 pos = base[index].position.xyz
    + uniforms.weights[0] * delta0[index].position.xyz
    + uniforms.weights[1] * delta1[index].position.xyz
    + uniforms.weights[2] * delta2[index].position.xyz
    + uniforms.weights[3] * delta3[index].position.xyz
    + uniforms.weights[4] * delta4[index].position.xyz
    + uniforms.weights[5] * delta5[index].position.xyz
    + uniforms.weights[6] * delta6[index].position.xyz
    + uniforms.weights[7] * delta7[index].position.xyz;
    outP[index] = float3(pos);
    
    outN[index] = unpack_snorm10a2_to_float(base[index].normal).xyz
    + uniforms.weights[0] * unpack_snorm10a2_to_float(delta0[index].normal).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(delta1[index].normal).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(delta2[index].normal).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(delta3[index].normal).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(delta4[index].normal).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(delta5[index].normal).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(delta6[index].normal).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(delta7[index].normal).xyz;
kernel void blendpackhalf_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                       device packed_float3* outP       [[ buffer(0) ]],
                                       device packed_float3* outN       [[ buffer(1) ]],
                                       constant blend_uniforms& uniforms[[ buffer(3) ]],
                                       device morphpackhalf_target_PN* delta0   [[ buffer(5) ]],
                                       device morphpackhalf_target_PN* delta1   [[ buffer(6) ]],
                                       device morphpackhalf_target_PN* delta2   [[ buffer(7) ]],
                                       device morphpackhalf_target_PN* delta3   [[ buffer(8) ]],
                                       device morphpackhalf_target_PN* delta4   [[ buffer(9) ]],
                                       device morphpackhalf_target_PN* delta5   [[ buffer(10) ]],
                                       device morphpackhalf_target_PN* delta6   [[ buffer(11) ]],
                                       device morphpackhalf_target_PN* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    half3 pos = uniforms.weights[0] * delta0[index].position.xyz
    + uniforms.weights[1] * delta1[index].position.xyz
    + uniforms.weights[2] * delta2[index].position.xyz
    + uniforms.weights[3] * delta3[index].position.xyz
    + uniforms.weights[4] * delta4[index].position.xyz
    + uniforms.weights[5] * delta5[index].position.xyz
    + uniforms.weights[6] * delta6[index].position.xyz
    + uniforms.weights[7] * delta7[index].position.xyz;
    outP[index] += float3(pos.xyz);
    
    outN[index] += uniforms.weights[0] * unpack_snorm10a2_to_float(delta0[index].normal).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(delta1[index].normal).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(delta2[index].normal).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(delta3[index].normal).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(delta4[index].normal).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(delta5[index].normal).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(delta6[index].normal).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(delta7[index].normal).xyz;
///////////////////////
// Pack x2
kernel void blendpackx2_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                          uint gsize          [[ threads_per_grid ]],
                                          
                                          device packed_float3* outP       [[ buffer(0) ]],
                                          device packed_float3* outN       [[ buffer(1) ]],
                                          constant blend_uniforms& uniforms[[ buffer(3) ]],
                                          device float4* base     [[ buffer(4) ]],
                                          device float4* delta0   [[ buffer(5) ]],
                                          device float4* delta1   [[ buffer(6) ]],
                                          device float4* delta2   [[ buffer(7) ]],
                                          device float4* delta3   [[ buffer(8) ]],
                                          device float4* delta4   [[ buffer(9) ]],
                                          device float4* delta5   [[ buffer(10) ]],
                                          device float4* delta6   [[ buffer(11) ]],
                                          device float4* delta7   [[ buffer(12) ]])
    float4 base_val = base[index];
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = base_val.xyz
    + uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    
    float3 normal = unpack_snorm10a2_to_float(as_type<uint>(base_val.w)).xyz
    + uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] = pos;
    outN[index] = normal;
    
    index += gsize;
    if (index >= uniforms.maxIndex)
        return;
    
    base_val = base[index];
    delta0_val = delta0[index];
    delta1_val = delta1[index];
    delta2_val = delta2[index];
    delta3_val = delta3[index];
    delta4_val = delta4[index];
    delta5_val = delta5[index];
    delta6_val = delta6[index];
    delta7_val = delta7[index];
    
    pos = base_val.xyz
    + uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    
    normal = unpack_snorm10a2_to_float(as_type<uint>(base_val.w)).xyz
    + uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] = pos;
    outN[index] = normal;
kernel void blendpackx2_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                         uint gsize          [[ threads_per_grid ]],
                                         device packed_float3* outP       [[ buffer(0) ]],
                                         device packed_float3* outN       [[ buffer(1) ]],
                                         constant blend_uniforms& uniforms[[ buffer(3) ]],
                                         device float4* delta0   [[ buffer(5) ]],
                                         device float4* delta1   [[ buffer(6) ]],
                                         device float4* delta2   [[ buffer(7) ]],
                                         device float4* delta3   [[ buffer(8) ]],
                                         device float4* delta4   [[ buffer(9) ]],
                                         device float4* delta5   [[ buffer(10) ]],
                                         device float4* delta6   [[ buffer(11) ]],
                                         device float4* delta7   [[ buffer(12) ]])
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    
    float3 normal = uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] += pos;
    outN[index] += normal;
    
    index += gsize;
    if (index >= uniforms.maxIndex)
        return;
    
    delta0_val = delta0[index];
    delta1_val = delta1[index];
    delta2_val = delta2[index];
    delta3_val = delta3[index];
    delta4_val = delta4[index];
    delta5_val = delta5[index];
    delta6_val = delta6[index];
    delta7_val = delta7[index];
    
    pos = uniforms.weights[0] * delta0_val.xyz
    + uniforms.weights[1] * delta1_val.xyz
    + uniforms.weights[2] * delta2_val.xyz
    + uniforms.weights[3] * delta3_val.xyz
    + uniforms.weights[4] * delta4_val.xyz
    + uniforms.weights[5] * delta5_val.xyz
    + uniforms.weights[6] * delta6_val.xyz
    + uniforms.weights[7] * delta7_val.xyz;
    
    normal = uniforms.weights[0] * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + uniforms.weights[1] * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + uniforms.weights[2] * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + uniforms.weights[3] * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + uniforms.weights[4] * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + uniforms.weights[5] * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + uniforms.weights[6] * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + uniforms.weights[7] * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] += pos;
    outN[index] += normal;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
kernel void blend_inc_add_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                       device packed_float3* outP       [[ buffer(0) ]],
                                       device packed_float3* outN       [[ buffer(1) ]],
                                       constant blend_uniforms& uniforms[[ buffer(3) ]],
                                       device float4* delta0   [[ buffer(5) ]],
                                       device float4* delta1   [[ buffer(6) ]],
                                       device float4* delta2   [[ buffer(7) ]],
                                       device float4* delta3   [[ buffer(8) ]],
                                       device float4* delta4   [[ buffer(9) ]],
                                       device float4* delta5   [[ buffer(10) ]],
                                       device float4* delta6   [[ buffer(11) ]],
                                       device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    float3 normal = w0 * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + w1 * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + w2 * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + w3 * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + w4 * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + w5 * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + w6 * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + w7 * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] += pos;
    outN[index] += normal;
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blend_inc_init_8x_pn_kernel(uint index          [[ thread_position_in_grid ]],
                                        device packed_float3* outP       [[ buffer(0) ]],
                                        device packed_float3* outN       [[ buffer(1) ]],
                                        constant blend_uniforms& uniforms[[ buffer(3) ]],
                                        device float4* delta0   [[ buffer(5) ]],
                                        device float4* delta1   [[ buffer(6) ]],
                                        device float4* delta2   [[ buffer(7) ]],
                                        device float4* delta3   [[ buffer(8) ]],
                                        device float4* delta4   [[ buffer(9) ]],
                                        device float4* delta5   [[ buffer(10) ]],
                                        device float4* delta6   [[ buffer(11) ]],
                                        device float4* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float4 delta0_val = delta0[index];
    float4 delta1_val = delta1[index];
    float4 delta2_val = delta2[index];
    float4 delta3_val = delta3[index];
    float4 delta4_val = delta4[index];
    float4 delta5_val = delta5[index];
    float4 delta6_val = delta6[index];
    float4 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    float3 normal = w0 * unpack_snorm10a2_to_float(as_type<uint>(delta0_val.w)).xyz
    + w1 * unpack_snorm10a2_to_float(as_type<uint>(delta1_val.w)).xyz
    + w2 * unpack_snorm10a2_to_float(as_type<uint>(delta2_val.w)).xyz
    + w3 * unpack_snorm10a2_to_float(as_type<uint>(delta3_val.w)).xyz
    + w4 * unpack_snorm10a2_to_float(as_type<uint>(delta4_val.w)).xyz
    + w5 * unpack_snorm10a2_to_float(as_type<uint>(delta5_val.w)).xyz
    + w6 * unpack_snorm10a2_to_float(as_type<uint>(delta6_val.w)).xyz
    + w7 * unpack_snorm10a2_to_float(as_type<uint>(delta7_val.w)).xyz;
    
    outP[index] = pos;
    outN[index] = normal;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Position only
kernel void blend_inc_add_8x_p_kernel(uint index          [[ thread_position_in_grid ]],
                                       device packed_float3* outP       [[ buffer(0) ]],
                                       constant blend_uniforms& uniforms[[ buffer(3) ]],
                                       device packed_float3* delta0   [[ buffer(5) ]],
                                       device packed_float3* delta1   [[ buffer(6) ]],
                                       device packed_float3* delta2   [[ buffer(7) ]],
                                       device packed_float3* delta3   [[ buffer(8) ]],
                                       device packed_float3* delta4   [[ buffer(9) ]],
                                       device packed_float3* delta5   [[ buffer(10) ]],
                                       device packed_float3* delta6   [[ buffer(11) ]],
                                       device packed_float3* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float3 delta0_val = delta0[index];
    float3 delta1_val = delta1[index];
    float3 delta2_val = delta2[index];
    float3 delta3_val = delta3[index];
    float3 delta4_val = delta4[index];
    float3 delta5_val = delta5[index];
    float3 delta6_val = delta6[index];
    float3 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    outP[index] += pos;
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blend_inc_init_8x_p_kernel(uint index          [[ thread_position_in_grid ]],
                                        device packed_float3* outP       [[ buffer(0) ]],
                                        constant blend_uniforms& uniforms[[ buffer(3) ]],
                                        device packed_float3* delta0   [[ buffer(5) ]],
                                        device packed_float3* delta1   [[ buffer(6) ]],
                                        device packed_float3* delta2   [[ buffer(7) ]],
                                        device packed_float3* delta3   [[ buffer(8) ]],
                                        device packed_float3* delta4   [[ buffer(9) ]],
                                        device packed_float3* delta5   [[ buffer(10) ]],
                                        device packed_float3* delta6   [[ buffer(11) ]],
                                        device packed_float3* delta7   [[ buffer(12) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float w0 = uniforms.weights[0];
    float w1 = uniforms.weights[1];
    float w2 = uniforms.weights[2];
    float w3 = uniforms.weights[3];
    float w4 = uniforms.weights[4];
    float w5 = uniforms.weights[5];
    float w6 = uniforms.weights[6];
    float w7 = uniforms.weights[7];
    
    float3 delta0_val = delta0[index];
    float3 delta1_val = delta1[index];
    float3 delta2_val = delta2[index];
    float3 delta3_val = delta3[index];
    float3 delta4_val = delta4[index];
    float3 delta5_val = delta5[index];
    float3 delta6_val = delta6[index];
    float3 delta7_val = delta7[index];
    
    float3 pos = w0 * delta0_val.xyz
    + w1 * delta1_val.xyz
    + w2 * delta2_val.xyz
    + w3 * delta3_val.xyz
    + w4 * delta4_val.xyz
    + w5 * delta5_val.xyz
    + w6 * delta6_val.xyz
    + w7 * delta7_val.xyz;
    
    outP[index] = pos;
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
// sparse
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
struct sps_uniforms {
    float weight;
    float positionWeight;
    uint  maxIndex;
// interleaved version
// use float4 instead of struct as inputs because it is way faster!!!
// simple copy kernel
kernel void copy_interleaved_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                                 device float4* dst             [[ buffer(0) ]],
                                                 device float4* src             [[ buffer(1) ]],
                                                 constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    dst[index] = src[index];
kernel void blend_interleaved_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                                  device float4* dst             [[ buffer(0) ]],
                                                  device float4* src             [[ buffer(1) ]],
                                                  constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float4 dstVal   = dst[index];
    float3 pos      = dstVal.xyz;
    float4 nrm      = unpack_snorm10a2_to_float(as_type<uint>(dstVal.w));
    
    float4 val      = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w));
    
    float nrmPack = as_type<float>(pack_float_to_snorm10a2(normalize(nrm)));
    //    nrmPack = dstVal.w;
    dst[index] = float4(pos, nrmPack);
kernel void blend_interleaved_sparse_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                                         device float4* dst             [[ buffer(0) ]],
                                                         device float4* src             [[ buffer(1) ]],
                                                         device uint* indices           [[ buffer(2) ]],
                                                         constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    uint dstInd = indices[index];
    
    float4 dstVal   = dst[dstInd];
    float3 pos      = dstVal.xyz;
    float4 nrm      = unpack_snorm10a2_to_float(as_type<uint>(dstVal.w));
    float4 val  = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w));
    float nrmPack = as_type<float>(pack_float_to_snorm10a2(normalize(nrm)));
//    float nrmPack = dstVal.w;
    dst[dstInd] = float4(pos, nrmPack);
// non interleaved version
// simple copy kernel
kernel void copy_pos_float3_nrm_10a2(uint index                      [[ thread_position_in_grid ]],
                                     device packed_float3* outP      [[ buffer(0) ]],
                                     device float4* src              [[ buffer(1) ]],
                                     constant sps_uniforms& uniforms [[ buffer(3) ]],
                                     device packed_float3* outN      [[ buffer(4) ]]
                                     )
    if (index >= uniforms.maxIndex)
        return;
    float4 srcVal = src[index];
    outP[index] = srcVal.xyz;
    outN[index] = unpack_snorm10a2_to_float(as_type<uint>(srcVal.w)).xyz;
kernel void copy_pos_float3(uint index                      [[ thread_position_in_grid ]],
                            device packed_float3* outP      [[ buffer(0) ]],
                            device packed_float3* src              [[ buffer(1) ]],
                            constant sps_uniforms& uniforms [[ buffer(3) ]]
                            )
    if (index >= uniforms.maxIndex)
        return;
    
    outP[index] = float3(src[index]);
kernel void blend_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                      device packed_float3* outP     [[ buffer(0) ]],
                                      device float4* src             [[ buffer(1) ]],
                                      constant sps_uniforms& uniforms[[ buffer(3) ]],
                                      device packed_float3* outN     [[ buffer(4) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float3 pos      = outP[index];
    float3 nrm      = outN[index];
    
    float4 val      = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w)).xyz;
    
    // should we?
    // nrm = normalize(nrm);
    outP[index] = pos;
    outN[index] = nrm;
kernel void blend_pos_float3(uint index                     [[ thread_position_in_grid ]],
                             device packed_float3* outP     [[ buffer(0) ]],
                             device packed_float3* src      [[ buffer(1) ]],
                             constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    float3 val      = src[index];
    outP[index] += uniforms.weight * val.xyz;
kernel void blend_sparse_u32_pos_float3(uint index                     [[ thread_position_in_grid ]],
                                    device packed_float3* outP     [[ buffer(0) ]],
                                    device packed_float3* src      [[ buffer(1) ]],
                                    device uint* indices           [[ buffer(2) ]],
                                    constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    uint dstInd = indices[index];
    
    float3 pos      = outP[dstInd];
    
    float3 val  = src[index];
    pos += uniforms.weight * val.xyz;
    
    outP[dstInd] = pos;
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blend_sparse_u32_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                             device packed_float3* outP     [[ buffer(0) ]],
                                             device float4* src             [[ buffer(1) ]],
                                             device uint* indices           [[ buffer(2) ]],
                                             constant sps_uniforms& uniforms[[ buffer(3) ]],
                                             device packed_float3* outN     [[ buffer(4) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    uint dstInd = indices[index];
    
    float3 pos      = outP[dstInd];
    float3 nrm      = outN[dstInd];
    float4 val  = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w)).xyz;
    
    // should we?
    // nrm = normalize(nrm);
    outP[dstInd] = pos;
    outN[dstInd] = nrm;
kernel void blend_sparse_u16_pos_float3(uint index                     [[ thread_position_in_grid ]],
                                    device packed_float3* outP     [[ buffer(0) ]],
                                    device packed_float3* src      [[ buffer(1) ]],
                                    device ushort* indices         [[ buffer(2) ]],
                                    constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    ushort dstInd = indices[index];
    
    float3 val  = src[index];
    outP[dstInd] += uniforms.weight * val.xyz;
// use float4 instead of struct as inputs because it is way faster!!!
kernel void blend_sparse_u16_pos_float3_nrm_10a2(uint index                     [[ thread_position_in_grid ]],
                                             device packed_float3* outP     [[ buffer(0) ]],
                                             device float4* src             [[ buffer(1) ]],
                                             device ushort* indices         [[ buffer(2) ]],
                                             constant sps_uniforms& uniforms[[ buffer(3) ]],
                                             device packed_float3* outN     [[ buffer(4) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    ushort dstInd = indices[index];
    
    float3 pos      = outP[dstInd];
    float3 nrm      = outN[dstInd];
    
    float4 val  = src[index];
    pos += uniforms.weight * val.xyz;
    nrm += uniforms.weight * unpack_snorm10a2_to_float(as_type<uint>(val.w)).xyz;
    
    // should we?
    // nrm = normalize(nrm);
    
    outP[dstInd] = pos;
    outN[dstInd] = nrm;
// generic sparse versions
#if __METAL_VERSION__ >= 120
constant bool morphNormal    [[ function_constant(10) ]];
typedef struct {
    float3 position         [[ attribute(SCNVertexSemanticPosition) ]];
    float3 normal           [[ attribute(SCNVertexSemanticNormal), function_constant(morphNormal) ]];
//    float4 tangent          [[ attribute(SCNVertexSemanticTangent) ]];
} scn_morph_vertex_t;
kernel void copy_generic(uint index                             [[ thread_position_in_grid ]],
                             scn_morph_vertex_t in              [[ stage_in ]],
                             device packed_float3* outP         [[ buffer(0) ]],
                             device packed_float3* outN         [[ buffer(4), function_constant(morphNormal) ]],
                             constant sps_uniforms& uniforms    [[ buffer(3) ]]
                            )
    if (index >= uniforms.maxIndex)
        return;
    
    outP[index] = in.position;
    if (morphNormal)
        outN[index] = in.normal;
kernel void blend_generic(uint index                            [[ thread_position_in_grid ]],
                              scn_morph_vertex_t in             [[ stage_in ]],
                              device packed_float3* outP        [[ buffer(0) ]],
                              device packed_float3* outN        [[ buffer(4), function_constant(morphNormal) ]],
                              constant sps_uniforms& uniforms   [[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    outP[index] += uniforms.positionWeight * in.position;
    if (morphNormal)
        outN[index] += uniforms.weight * in.normal;
kernel void blend_sparse_u16_generic(uint index                         [[ thread_position_in_grid ]],
                                         scn_morph_vertex_t in          [[ stage_in ]],
                                         device packed_float3* outP     [[ buffer(0) ]],
                                         device packed_float3* outN     [[ buffer(4), function_constant(morphNormal) ]],
                                         device ushort* indices         [[ buffer(2) ]],
                                         constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    ushort dstInd = indices[index];
    outP[dstInd] += uniforms.positionWeight * in.position;
    if (morphNormal)
        outN[dstInd] += uniforms.weight * in.normal;
kernel void blend_sparse_u32_generic(uint index                         [[ thread_position_in_grid ]],
                                         scn_morph_vertex_t in          [[ stage_in ]],
                                         device packed_float3* outP     [[ buffer(0) ]],
                                         device packed_float3* outN     [[ buffer(4), function_constant(morphNormal) ]],
                                         device uint* indices           [[ buffer(2) ]],
                                         constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    uint dstInd = indices[index];
    outP[dstInd] += uniforms.positionWeight * in.position;
    if (morphNormal)
        outN[dstInd] += uniforms.weight * in.normal;
// for morph deindexing
kernel void splat_indexed_vertices(uint index                       [[ thread_position_in_grid ]],
                                     device packed_float3* outP     [[ buffer(0) ]],
                                     device packed_float3* outN     [[ buffer(4), function_constant(morphNormal) ]],
                                     device int* indexToProvoking   [[ buffer(2) ]],
                                     constant sps_uniforms& uniforms[[ buffer(3) ]])
    if (index >= uniforms.maxIndex)
        return;
    
    int srcInd = indexToProvoking[index];
    if (srcInd != -1) {
        outP[index] = outP[srcInd];
        if (morphNormal)
            outN[index] = outN[srcInd];
    }
#pragma mark -
#pragma mark Skin
constant bool needNormal    [[ function_constant(0) ]];
constant bool needTangent   [[ function_constant(1) ]];
constant int  maxBoneCount  [[ function_constant(2) ]];
constant bool useWeights    = maxBoneCount > 1;
typedef struct {
    float4 position         [[ attribute(SCNVertexSemanticPosition) ]];
    float3 normal           [[ attribute(SCNVertexSemanticNormal), function_constant(needNormal) ]];
    float4 tangent          [[ attribute(SCNVertexSemanticTangent), function_constant(needTangent) ]];
} scn_vertex_t; // __attribute__((scn_per_frame));
// OPTIM we could use the asymetric properties of bone weights/indices
// would need another array of vertexInfluences[ index ] { uint start; uint end }
// BUT this would always be a dynamic loop, where as unrolled max4 loops...
// and this wpould take more space when near every vertex has 4 influences
// -> need to profile
kernel void skin_LBS(uint index                               [[ thread_position_in_grid ]],
                     uint vertexCount                         [[ grid_size ]],
                     scn_vertex_t in                          [[ stage_in ]],
                     
                     device packed_uchar4* boneIndices        [[ buffer(0) ]],
                     constant float4* skinningJointMatrices   [[ buffer(1) ]],
                     device uint* boneWeights                 [[ buffer(2), function_constant(useWeights) ]],
                     device packed_float3* outPos             [[ buffer(3) ]],
                     device packed_float3* outNrm             [[ buffer(4), function_constant(needNormal) ]],
                     device packed_float4* outTgt             [[ buffer(5), function_constant(needTangent) ]]
                     )
    if (index >= vertexCount) {
        return;
    }
    float4 skinningWeights;
    if (useWeights)
        skinningWeights  = unpack_unorm4x8_to_float(as_type<uint>(boneWeights[ index ]));
    
     uchar4 skinningJoints    = boneIndices[ index ];
    
    float3 pos = 0.f;
    float3 nrm = 0.f;
    float3 tgt = 0.f;
    for (int i = 0; i < maxBoneCount; ++i) {
        float weight = (useWeights) ? skinningWeights[i] : 1.f;
        if (weight <= 0.f)
            continue;
        
        int idx = int(skinningJoints[i]) * 3;
        float4x4 jointMatrix = float4x4(skinningJointMatrices[idx],
                                        skinningJointMatrices[idx+1],
                                        skinningJointMatrices[idx+2],
                                        float4(0.f, 0.f, 0.f, 1.f));
        
        pos += (in.position * jointMatrix).xyz * weight;
        
        if (needNormal)
            nrm += (in.normal * scn::mat3(jointMatrix)) * weight;
        
        if (needTangent)
            tgt += (in.tangent.xyz * scn::mat3(jointMatrix)) * weight;
    }
    outPos[ index ] = pos;
    
    if (needNormal)
        outNrm[ index ] = nrm;
    
    if (needTangent)
        outTgt[ index ] = float4(tgt, in.tangent.w);
    
#endif // __METAL_VERSION__
varying vec4 v_vertexColor;
void main()
    gl_FragColor = v_vertexColor;
#import <metal_stdlib>
using namespace metal;
struct scn_filterComposite_uniforms_t {
    float4   u_extent;
    float    u_middleZ;
struct scn_filterComposite_io_t {
    float4 position [[ position ]];
    float2 uv;
    float2 uvDepth;
vertex scn_filterComposite_io_t scn_filterCompositeVert(uint v_id [[ vertex_id ]],
                                                        constant scn_filterComposite_uniforms_t& uniforms [[ buffer(0) ]])
    scn_filterComposite_io_t out;
    
    float x = uniforms.u_extent.x + uniforms.u_extent.z * (v_id/2);
    float y = uniforms.u_extent.y + uniforms.u_extent.w * (v_id%2);
    
    out.position = float4(x, y, 0., 1.0);
    
    float uvx = uniforms.u_extent.z * (v_id/2);
    float uvy = uniforms.u_extent.w * ((1+v_id)%2);
    
    out.uv = float2(uvx, uvy) * float2(0.5, 0.5);
    out.uvDepth = float2(x, y) * float2(0.5, -0.5) + float2(0.5, 0.5);
    
    return out;
struct scn_filterCompositeOut {
    half4 color [[ color(0) ]];
    float depth [[ depth(any) ]]; // TODO optimize with greater or less
fragment scn_filterCompositeOut scn_filterCompositeFrag(scn_filterComposite_io_t in [[ stage_in ]],
                                                        texture2d<float> u_color   [[texture(0)]],
                                                        depth2d<float> u_depth   [[texture(1)]],
                                                        constant scn_filterComposite_uniforms_t& uniforms [[ buffer(0) ]]                                                        )
    scn_filterCompositeOut out;
    constexpr sampler linear_sampler(filter::nearest, address::clamp_to_zero);
    out.color = half4(u_color.sample(linear_sampler, in.uv));
    out.depth = u_depth.sample(linear_sampler, in.uvDepth);
    
    if(out.depth == 1.0)
        out.depth = uniforms.u_middleZ;//* 0.5 + 0.5;
    
//    out.color.rgb = half3(out.depth);
    
    return out;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_JitterCopyFirstFrame</string>
<string>SceneKit_JitterToEven</string>
<string>SceneKit_JitterToOdd</string>
<string>SceneKit_JitterResolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_JitterCopyFirstFrame</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToOdd</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-odd</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-even</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterToEven</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-jitter-even</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler1</key>
<string>SceneKit-jitter-odd</string>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_JitterResolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit-jitter-odd</string>
<key>factor</key>
<string>C3D-jitter-factor-resolve</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-jitter-odd</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
<key>SceneKit-jitter-even</key>
<dict>
<key>type</key>
<string>color</string>
<key>persistent</key>
<true/>
<key>format</key>
<string>rgba32f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-jitter-factor-resolve</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
</dict>
</plist>
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight"
  ],
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "global" : true,
      "type" : "depth"
    }
// Utility
// Tool function
namespace scn {
    
    // MARK: - Matrix/Vector utils
    
    inline float3x3 mat3(float4x4 mat4)
    {
        return float3x3(mat4[0].xyz, mat4[1].xyz, mat4[2].xyz);
    }
    
    inline float3 mat4_mult_float3_normalized(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return normalize(dst);
    }
    
    inline float3 mat4_mult_float3(float4x4 matrix, float3 src)
    {
        float3 dst  =  src.xxx * matrix[0].xyz;
        dst         += src.yyy * matrix[1].xyz;
        dst         += src.zzz * matrix[2].xyz;
        return dst;
    }
    inline float3 matrix_rotate(float4x4 mat, float3 dir)
    {
        return  dir.xxx * mat[0].xyz +
                dir.yyy * mat[1].xyz +
                dir.zzz * mat[2].xyz;
    }
    inline float4 matrix_transform(float4x4 mat, float3 pos)
    {
        return  pos.xxxx * mat[0] +
                pos.yyyy * mat[1] +
                pos.zzzz * mat[2] +
                           mat[3];
    }
    inline void generate_basis(float3 inR, thread float3 *outS, thread float3 *outT)
    {
        //float3 dir = abs(inR.z) < 0.999 ? float3(0, 0, 1) : float3(1, 0, 0);
        float3 dir = mix( float3(1.,0.,0.), float3(0.,0.,1.), step(0.999, abs(inR.z)) );
        *outS = normalize(cross(dir, inR));
        *outT = cross(inR, *outS);
    }
    
    // MARK: - Blending operators
    
    inline float3 blend_add(float3 base, float3 blend)
    {
        return min(base + blend, 1.0);
    }
    
    inline float3 blend_lighten(float3 base, float3 blend)
    {
        return max(blend, base);
    }
    
    inline float3 blend_screen(float3 base, float3 blend)
    {
        return (1.0 - ((1.0 - base) * (1.0 - blend)));
    }
    // MARK: - Math
    
    inline half sq(half f) {
        return f * f;
    }
    inline float sq(float f) {
        return f * f;
    }
    
    // MARK: - SIMD Extensions
    
    inline vector_float2 barycentric_mix(vector_float2 __x, vector_float2 __y, vector_float2 __z, vector_float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    inline vector_float3 barycentric_mix(vector_float3 __x, vector_float3 __y, vector_float3 __z, vector_float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    inline vector_float4 barycentric_mix(vector_float4 __x, vector_float4 __y, vector_float4 __z, vector_float3 __t) { return __t.x * __x + __t.y * __y + __t.z * __z; }
    
    static inline float rect(float2 lt, float2 rb, float2 uv)
    {
        float2 borders = step(lt, uv) * step(uv, rb);
        return borders.x * borders.y;
    }
    
    inline half4 debugColorForCascade(int cascade)
    {
        switch (cascade) {
            case 0:
            return half4(1.h, 0.h, 0.h, 1.h);
            case 1:
            return half4(0.9, 0.5, 0., 1.);
            case 2:
            return half4(1., 1., 0., 1.);
            case 3:
            return half4(0., 1., 0., 1.);
            default:
            return half4(0., 0., 0., 1.);
        }
    }
    
    inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)
    {
        float insideRect = rect(lt, rb + thickness, uv);
        float2 gt = thickness * gridSize;
        float2 lines = step(abs(lt - fract(uv * gridSize)), gt);
        return insideRect * (lines.x + lines.y);
    }
    
    // MARK: - Colors
    
    inline float luminance(float3 color)
    {
        // `color` assumed to be in the linear sRGB color space
        // https://en.wikipedia.org/wiki/Relative_luminance
        return color.r * 0.212671 + color.g * 0.715160 + color.b * 0.072169;
    }
    
    inline float srgb_to_linear(float c)
    {
        return (c <= 0.04045f) ? c / 12.92f : powr((c + 0.055f) / 1.055f, 2.4f);
    }
    
    inline half srgb_to_linear_fast(half c)
    {
        return powr(c, 2.2h);
    }
    
    inline half3 srgb_to_linear_fast(half3 c)
    {
        return powr(c, 2.2h);
    }
    
    inline half srgb_to_linear(half c)
    {
        // return (c <= 0.04045h) ? c / 12.92h : powr((c + 0.055h) / 1.055h, 2.4h);
        return (c <= 0.04045h) ? (c * 0.0773993808h) :  powr(0.9478672986h * c + 0.05213270142h, 2.4h);
    }
    
    inline float3 srgb_to_linear(float3 c)
    {
        return float3(srgb_to_linear(c.x), srgb_to_linear(c.y), srgb_to_linear(c.z));
    }
    
    inline float linear_to_srgb(float c)
    {
        return (c < 0.0031308f) ? (12.92f * c) : (1.055f * powr(c, 1.f/2.4f) - 0.055f);
    }
    
    inline float3 linear_to_srgb(float3 v) { // we do not saturate since linear extended values can be fed in
        return float3(linear_to_srgb(v.x), linear_to_srgb(v.y), linear_to_srgb(v.z));
    }
    
// MARK: GL helpers
template <typename T>
inline T dFdx(T v) {
    return dfdx(v);
// Y is up in GL and down in Metal
template <typename T>
inline T dFdy(T v) {
    return -dfdy(v);
// MARK: -
inline float4 texture2DProj(texture2d<float> tex, sampler smp, float4 uv)
    return tex.sample(smp, uv.xy / uv.w);
constexpr sampler shadow_sampler(coord::normalized, filter::linear, mip_filter::none, address::clamp_to_edge, compare_func::greater_equal);
inline float shadow2DProj(depth2d<float> tex, float4 uv)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);
inline float shadow2DProj(sampler smp, depth2d<float> tex, float4 uv)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(smp, uvp.xy, uvp.z);
inline float shadow2DArrayProj(depth2d_array<float> tex, float4 uv, uint slice)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);
// MARK Shadow
inline float ComputeShadow(float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap)
    //project into light space
    float4 lightScreen =  shadowMatrix * float4(worldPos, 1.0);
    
    // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
    lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
    
    float shadow = shadow2DProj(shadow_sampler, shadowMap, lightScreen);
    // Is this useful ?
    shadow *= step(0., lightScreen.w);
    
    return shadow;
inline float ComputeSoftShadow(float3 worldPos, float4x4 shadowMatrix, depth2d<float> shadowMap, constant float4* shadowKernel, int sampleCount, float shadowRadius)
    //project into light space
    float4 lightScreen =  shadowMatrix * float4(worldPos, 1.0);
    
    // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
    lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
    
    // penumbra
    float filteringSizeFactor = shadowRadius * lightScreen.w;
        
    //smooth all samples
    float totalAccum = 0.0;
    for(int i=0; i < sampleCount; i++){
        totalAccum += shadow2DProj(shadowMap, lightScreen + (shadowKernel[i] * filteringSizeFactor));
    }
    float shadow = totalAccum / float(sampleCount);
    
    // Is this useful ?
    shadow *= step(0., lightScreen.w);
    return shadow;
inline float ComputeBlendedCascadedShadow(float3 worldPos, constant float4x4* shadowMatrices, int cascadeCount, depth2d_array<float> shadowMaps, float cascadeBlendingFactor)
    float shadow = 0.f;
    float opacitySum = 0.f;
    for (int c = 0; c < cascadeCount; ++c) {
        
        float4 lightScreen =  shadowMatrices[c] * float4(worldPos, 1.0);
        
        // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
        
        // move in [-1..1] range
        float2 o = lightScreen.xy * 2.f - 1.f;
        // float2 o = (lightScreen.xy / lightScreen.w) * 2.f - 1.f; // do we need to test after projection ???
        const float edge = 1.f - cascadeBlendingFactor;
        // could also do a smoothstep
        o = 1.f - saturate((abs(o) - edge) / cascadeBlendingFactor);
        float opacity = o.x * o.y; //min(o.x, o.y);
        
        if (opacity > 0.f) { // this cascade should be considered
            
            float alpha = opacity * (1.f - opacitySum);
            
            shadow += shadow2DArrayProj(shadowMaps, lightScreen, c) * alpha;
            opacitySum += alpha;
        }
        
        if (opacitySum >= 1.f) // fully opaque shadow (no more blending needed) -> bail out
            break;
    }
    
    if (opacitySum)
        shadow /= opacitySum; // normalization
    
    return shadow;
inline float ComputeCascadedShadow(float3 worldPos, constant float4x4* shadowMatrices, int cascadeCount, depth2d_array<float> shadowMaps)
    for (int c = 0; c < cascadeCount; ++c) {
        
        float4 lightScreen =  shadowMatrices[c] * float4(worldPos, 1.0);
        
        // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
        
        // move in [-1..1] range
        float2 o = lightScreen.xy * 2.f - 1.f;
        // float2 o = (lightScreen.xy / lightScreen.w) * 2.f - 1.f; // do we need to test after projection ???
        float opacity = step(abs(o.x), 1.f) * step(abs(o.y), 1.f);
        
        if (opacity > 0.f) { // this cascade should be considered
            
            return shadow2DArrayProj(shadowMaps, lightScreen, c);
        }
    }
    
    return 0.f;
inline float ComputeCascadedSoftShadow(float3 worldPos, constant float4x4* shadowMatrices, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, float cascadeBlendingFactor, constant float4* shadowKernel, int sampleCount, float shadowRadius)
    float shadow = 0.f;
    float opacitySum = 0.f;
    
    for (int c = 0; c < cascadeCount; ++c) {
        
        float4 lightScreen =  shadowMatrices[c] * float4(worldPos, 1.0);
        
        // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
        
        // move in [-1..1] range
        float2 o = lightScreen.xy * 2.f - 1.f;
        // float2 o = (lightScreen.xy / lightScreen.w) * 2.f - 1.f; // do we need to test after projection ???
        float opacity = 1.f;
        if (enableCascadeBlending) {
            const float edge = 1.f - cascadeBlendingFactor;
            // could also do a smoothstep
            o = 1.f - saturate((abs(o) - edge) / cascadeBlendingFactor);
            opacity = o.x * o.y; //min(o.x, o.y);
        } else {
            opacity = step(abs(o.x), 1.f) * step(abs(o.y), 1.f);
        }
        
        if (opacity > 0.f) { // this cascade should be considered
            
            float alpha = opacity * (1.f - opacitySum);
            
            // penumbra
            float filteringSizeFactor = shadowRadius * lightScreen.w; //shadowRadius * lightScreen.w;//(distLight - lightDepth)*shadowRadius / lightDepth ;
            
            //smooth all samples
            float totalAccum = 0.0;
            for (int i=0; i < sampleCount; i++) {
                totalAccum += shadow2DArrayProj(shadowMaps, lightScreen + (shadowKernel[i] * filteringSizeFactor), c);
            }
            
            //    float shadow = totalAccum;
            shadow += (totalAccum / float(sampleCount)) * alpha;
            
            // shadow += shadow2DArrayProj(shadowMaps, lightScreen, c) * alpha;
            opacitySum += alpha;
            
        }
        
        if (opacitySum >= 1.f) // fully opaque shadow (no more blending needed) -> bail out
            break;
    }
    
    if (opacitySum)
    shadow /= opacitySum; // normalization
    
    return shadow;
inline float4 ComputeCascadedShadowDebug(float3 worldPos, constant float4x4* shadowMatrices, int cascadeCount, depth2d_array<float> shadowMaps, bool enableCascadeBlending, float cascadeBlendingFactor)
    float shadow = 0.f;
    float opacitySum = 0.f;
    half4 debugColorSum = 0.f;
    
    for (int c = 0; c < cascadeCount; ++c) {
        
        float4 lightScreen =  shadowMatrices[c] * float4(worldPos, 1.0);
        
        // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
        
        // move in [-1..1] range
        float2 o = lightScreen.xy * 2.f - 1.f;
        // float2 o = (lightScreen.xy / lightScreen.w) * 2.f - 1.f; // do we need to test after projection ???
        float opacity = 1.f;
        if (enableCascadeBlending) {
            const float edge = 1.f - cascadeBlendingFactor;
            // could also do a smoothstep
            o = 1.f - saturate((abs(o) - edge) / cascadeBlendingFactor);
            opacity = o.x * o.y; //min(o.x, o.y);
        } else {
            opacity = step(abs(o.x), 1.f) * step(abs(o.y), 1.f);
        }
        
        if (opacity > 0.f) { // this cascade should be considered
            
            float alpha = opacity * (1.f - opacitySum);
            
            { // cascade debug + grid
                float2 texPos = lightScreen.xy / lightScreen.w;
                float2 gridSize = float2(shadowMaps.get_width(), shadowMaps.get_height()) / 8;
                float gd = scn::grid(float2(0.f), float2(1.f), gridSize, 0.001f, texPos);
                half4 gridCol = mix(scn::debugColorForCascade(c), half4(0.f), half4(gd > 0.f));
                debugColorSum += gridCol * alpha;
            }
            
            shadow += shadow2DArrayProj(shadowMaps, lightScreen, c) * alpha;
            opacitySum += alpha;
            
        }
        
        if (opacitySum >= 1.f) // fully opaque shadow (no more blending needed) -> bail out
            break;
    }
    
    if (opacitySum)
        shadow /= opacitySum; // normalization
    
    return float4(float3(debugColorSum.rgb), shadow);
#import <metal_stdlib>
using namespace metal;
#if __METAL_VERSION__ >= 120
#define MAX_SAMPLE 64 // linked to C3D_MAX_SHADOW_SAMPLE_COUNT
#define MAX_CASCADES 4
#import "scn_util.h"
constant int sampleCount                    [[ function_constant(0) ]];
constant int cascadeCount                   [[ function_constant(1) ]];
constant bool cascadeBlending               [[ function_constant(2) ]];
constant bool debugCascades                 [[ function_constant(3) ]];
struct shadowMap_io {
    float4 position [[position]];
    float2 screenPosition;
    float2 texcoord;
struct shadowMap_uniforms {
    float4          u_kernel[MAX_SAMPLE];
    float4x4        camera_MVP_i;
    float4x4        light_MVP[MAX_CASCADES];
    float           viewSpaceSplitDistances[MAX_CASCADES + 1];
    float           cascadeDebugFactor;
    
    float3  u_lightPos;
    float3  u_lightDir;
    float3  u_lightSpotAtt;
    float shadowRadius;
    float4 shadowColor;
vertex shadowMap_io deferredShadow_vert(uint v_id [[ vertex_id ]])
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.f - 1.f;
    in_position.y = (float)(v_id % 2) * 2.f - 1.f;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    shadowMap_io out;
    out.position = in_position;
    out.screenPosition = in_position.xy;
    out.texcoord = in_position.xy * float2(0.5f, -0.5f) + 0.5f;
    return out;
// Fragment shader function
inline float3 unprojectPoint(float3 screenPos, float4x4 camera_MVP_i)
    float4 pTmp = camera_MVP_i * float4(screenPos, 1.f);
    return pTmp.xyz / pTmp.w;
fragment half4 deferredShadow_frag(shadowMap_io in [[stage_in]],
                              texture2d<half> colorSampler [[texture(0)]],
                              depth2d<float> depthSampler [[texture(1)]],
                              depth2d<float> lightDepthSampler [[texture(2)]],
                              constant shadowMap_uniforms& uniforms [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    
    //get color (no blur mode)
    half4 color = colorSampler.sample(samp, in.texcoord);
    
    //get z (need a bias on the read z value....)
//    float depthValue = depthSampler.sample(samp, in.texcoord) - 0.00001;
    float depthValue = depthSampler.sample(samp, in.texcoord);
    if (depthValue >= 1.f) // do not touch pixels without colors (OPTIM should use stencil)
        return color;
     
    //unproject to get world position
    float3 viewPos = unprojectPoint(float3(in.screenPosition.x, in.screenPosition.y, depthValue), uniforms.camera_MVP_i);
    
    float shadow = (sampleCount > 1) ?
    ComputeSoftShadow(viewPos, uniforms.light_MVP[0], lightDepthSampler, uniforms.u_kernel, sampleCount, uniforms.shadowRadius)
    :
    ComputeShadow(viewPos, uniforms.light_MVP[0], lightDepthSampler);
    shadow *= half(uniforms.shadowColor.a);
    //apply shadow on color buffer
    color.rgb = mix(color.rgb, half3(uniforms.shadowColor.rgb), half(shadow));
    
    return color;
fragment half4 deferredShadowCascades_frag(shadowMap_io in [[stage_in]],
                                   texture2d<half> colorSampler [[texture(0)]],
                                   depth2d<float> depthSampler [[texture(1)]],
                                   depth2d_array<float> lightDepthSampler [[texture(2)]],
                                   constant shadowMap_uniforms& uniforms [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    
    //get color (no blur mode)
    half4 color = colorSampler.sample(samp, in.texcoord);
    
    //get z (need a bias on the read z value....)
    //    float depthValue = depthSampler.sample(samp, in.texcoord) - 0.00001;
    float depthValue = depthSampler.sample(samp, in.texcoord);
    if (depthValue >= 1.f) // do not touch pixels without colors (OPTIM should use stencil)
        return color;
    
    //unproject to get world position
    float3 viewPos = unprojectPoint(float3(in.screenPosition.x, in.screenPosition.y, depthValue), uniforms.camera_MVP_i);
    
    //-----------------------------------------------------------------------------------------------------------------------
    float shadow;
    if (debugCascades) {
        float4 shadowDebug = ComputeCascadedShadowDebug(viewPos, &uniforms.light_MVP[0], cascadeCount, lightDepthSampler, cascadeBlending, 0.1f);
        color.rgb = mix(color.rgb, half3(shadowDebug.rgb), half(uniforms.cascadeDebugFactor));
        shadow = shadowDebug.a;
    } else {
        if (sampleCount > 1) {
            shadow = ComputeCascadedSoftShadow(viewPos, &uniforms.light_MVP[0], cascadeCount, lightDepthSampler, cascadeBlending, 0.1f, uniforms.u_kernel, sampleCount, uniforms.shadowRadius);
        } else {
            shadow = cascadeBlending ?
            ComputeBlendedCascadedShadow(viewPos, &uniforms.light_MVP[0], cascadeCount, lightDepthSampler, 0.1f)
            :
            ComputeCascadedShadow(viewPos, &uniforms.light_MVP[0], cascadeCount, lightDepthSampler);
            
        }
    }
    
    shadow *= half(uniforms.shadowColor.a);
    
    //apply shadow on color buffer
    color.rgb = mix(color.rgb, half3(uniforms.shadowColor.rgb), half(shadow));
    return color;
#if 0
// alternate functions, worst result and need viewSpace split planes
// viewTransform : world to view space
// keep for future reference
inline float ComputeCascadedShadowParallelSplit(float3 viewPos, float viewSpaceSplitDistances[MAX_CASCADES + 1], float4x4 shadowMatrices[MAX_CASCADES], int cascadeCount, depth2d_array<float> shadowMaps)
    float dist = -viewPos.z;
    
    // return half4(dist / 100.f, 0, 0, 1.f);
    
    float blendDist = 0.1f;
    
    float4 debugColor;
    
    // TODO use split pos to find right cascade
    float shadow = 0.f;
    for (int c = 0; c < cascadeCount; ++c) {
        
        if (dist < viewSpaceSplitDistances[c + 1]) {
            if (debugCascades)
                debugColor = float4(scn::debugColorForCascade(c));
            
            //project into light space
            float4 lightScreen =  shadowMatrices[c] * float4(viewPos, 1.0);
            
            // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
            lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
            
            shadow = shadow2DArrayProj(shadowMaps, lightScreen, c);
            
            // TODO put lastSplitLimit at inifinity
            float blendSplitLength = (viewSpaceSplitDistances[c + 1] - viewSpaceSplitDistances[c]) * blendDist;
            float blendSplitLimit = viewSpaceSplitDistances[c + 1] - blendSplitLength; // OPTIM could be stored
            if (dist > blendSplitLimit) {
                float factor = (dist - blendSplitLimit) / blendSplitLength;
                
                if (debugCascades)
                    debugColor = mix(debugColor, float4(scn::debugColorForCascade(c+1)), factor);
                
                //project into light space
                float4 lightScreen =  shadowMatrices[c + 1] * float4(viewPos, 1.0);
                
                // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
                lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
                
                shadow = mix(shadow, shadow2DArrayProj(shadowMaps, lightScreen, c + 1), factor);
            }
            break;
        }
    }
    
    return shadow;
#endif
#endif // __METAL_VERSION__
    "sequence" : [ "SceneKit_PostProcess"],
    "passes" : {
        "SceneKit_PostProcess" : {
            "outputs" : {
                "color" : "COLOR"
            },
            "inputs" : {
                "colorBuffer" : "COLOR",
                "depthBuffer" : "DEPTH"
            },
            "draw" : "DRAW_QUAD",
            "clientProgram" : "NO",
            "program" : "C3D-GLSL-UNAVAILABLE",
        }
    },
    "symbols" : {
    },
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "C3D-PostProcessUtils.h"
#import "C3D-DeferredShadingCommon.h"
struct LightUniforms {
    float4x4 modelTransform;
    float4x4 modelViewTransform;
    float4x4 normalTransform;
struct LightVertex {
    float3 position [[attribute(0)]];
struct LightIO {
    float4 position [[position]];
    float3 positionVS;
// IOS only
// fragment FragmentOutput ds_default_frag(light_io in [[stage_in]], FragmentOutput gBuffers)
struct GBuffer {
    float4 normal_depth; // stored in view space
    float4 albedo;
    float4 roughness;
class Text {
#define CHAR_SIZE float2(8, 12)
#define CHAR_SPACING float2(8, 12)
    
    constant constexpr static float4 ch_1 = float4(0x001030,0xF03030,0x303030,0xFC0000);
    float2 print_pos;
    
    float4 characters[59] = {
        float4(0x000000,0x000000,0x000000,0x000000), // Space 32
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0xC4CC18,0x3060CC,0x8C0000), // 37 '%'
        float4(0x000000,0x000000,0x000000,0x000000), // 38
        float4(0x0070D8,0xD870FA,0xDECCDC,0x760000), // 39 amp
        float4(0x003030,0x306000,0x000000,0x000000), // 40 ch_apo
        float4(0x000C18,0x306060,0x603018,0x0C0000),
        float4(0x006030,0x180C0C,0x0C1830,0x600000),
        float4(0x000000,0x663CFF,0x3C6600,0x000000),
        float4(0x000000,0x18187E,0x181800,0x000000),
        float4(0x000000,0x000000,0x000038,0x386000),
        float4(0x000000,0x0000FE,0x000000,0x000000),
        float4(0x000000,0x000000,0x000038,0x380000),
        float4(0x000002,0x060C18,0x3060C0,0x800000),
        float4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000), // 48 '0'
        float4(0x001030,0xF03030,0x303030,0xFC0000), //
        float4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000), // 50
        float4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000),
        float4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000),
        float4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000),
        float4(0x003860,0xC0C0F8,0xCCCCCC,0x780000),
        float4(0x00FEC6,0xC6060C,0x183030,0x300000),
        float4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000),
        float4(0x0078CC,0xCCCC7C,0x181830,0x700000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000), // 60
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x000000,0x000000,0x000000,0x000000),
        float4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000), // A
        float4(0x00FC66,0x66667C,0x666666,0xFC0000),
        float4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000),
        float4(0x00F86C,0x666666,0x66666C,0xF80000),
        float4(0x00FE62,0x60647C,0x646062,0xFE0000),
        float4(0x00FE66,0x62647C,0x646060,0xF00000),
        float4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000),
        float4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000),
        float4(0x007830,0x303030,0x303030,0x780000),
        float4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000),
        float4(0x00E666,0x6C6C78,0x6C6C66,0xE60000),
        float4(0x00F060,0x606060,0x626666,0xFE0000),
        float4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000),
        float4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000),
        float4(0x00386C,0xC6C6C6,0xC6C66C,0x380000),
        float4(0x00FC66,0x66667C,0x606060,0xF00000),
        float4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00),
        float4(0x00FC66,0x66667C,0x6C6666,0xE60000),
        float4(0x0078CC,0xCCC070,0x18CCCC,0x780000),
        float4(0x00FCB4,0x303030,0x303030,0x780000),
        float4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000),
        float4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000),
        float4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000),
        float4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000),
        float4(0x00CCCC,0xCCCC78,0x303030,0x780000),
        float4(0x00FECE,0x981830,0x6062C6,0xFE0000) // Z
    };
    
    float4 _textColor;
    float4 _shadowColor;
public:
    Text() {
        _textColor = float4(1.);
        _shadowColor = float4(0., 0., 0., 1.);
    }
    
    void setPrintPos(float2 pos) {
        print_pos = pos;
    }
    
    //Extracts bit b from the given number.
    //Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).
    float extract_bit(float n, float b)
    {
        b = clamp(b,-1.0,24.0);
        return floor(fmod(floor(n / pow(2.0,floor(b))),2.0));
    }
    
    //Returns the pixel at uv in the given bit-packed sprite.
    float sprite(float4 spr, float2 size, float2 uv)
    {
        uv = floor(uv);
        
        //Calculate the bit to extract (x + y * width) (flipped on x-axis)
        float bit = (size.x-uv.x-1.0) + uv.y * size.x;
        
        //Clipping bound to remove garbage outside the sprite's boundaries.
        bool bounds = all(uv >= float2(0)) && all(uv < size);
        
        float pixels = 0.0;
        pixels += extract_bit(spr.x, bit - 72.0);
        pixels += extract_bit(spr.y, bit - 48.0);
        pixels += extract_bit(spr.z, bit - 24.0);
        pixels += extract_bit(spr.w, bit - 00.0);
        
        return bounds ? pixels : 0.0;
    }
    //Prints a character and moves the print position forward by 1 character width.
    float printChar(float4 ch, float2 uv)
    {
        /*
         if( TEXT_MODE == INVERT )
         {
         //Inverts all of the bits in the character.
         ch = pow(2.0,24.0)-1.0-ch;
         }
         if( TEXT_MODE == UNDERLINE )
         {
         //Makes the bottom 8 bits all 1.
         //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,
         //then shifts it left 8 bits and adds 255 (binary 11111111).
         ch.w = floor(ch.w/256.0)*256.0 + 255.0;
         }
         */
        
        float px = sprite(ch, CHAR_SIZE, uv - print_pos);
        print_pos.x += CHAR_SPACING.x;
        return px;
    }
    //Prints a character and moves the print position forward by 1 character width.
    float printCh(char ch, float2 uv)
    {
        /*
         if( TEXT_MODE == INVERT )
         {
         //Inverts all of the bits in the character.
         ch = pow(2.0,24.0)-1.0-ch;
         }
         if( TEXT_MODE == UNDERLINE )
         {
         //Makes the bottom 8 bits all 1.
         //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,
         //then shifts it left 8 bits and adds 255 (binary 11111111).
         ch.w = floor(ch.w/256.0)*256.0 + 255.0;
         }
         */
        
        float px = sprite(characters[ch - ' '], CHAR_SIZE, uv - print_pos);
        print_pos.x += CHAR_SPACING.x;
        return px;
    }
    float printString(char str[], int count, float2 uv)
    {
        float px = 0.;
        for (int i =0; i < count; ++i) {
            px += printCh(str[i], uv);
        }
        return px;
    }
    float printStr4(const char constant str[4], float2 uv)
    {
        float px = 0.;
        px += printCh(str[0], uv);
        px += printCh(str[1], uv);
        px += printCh(str[2], uv);
        px += printCh(str[3], uv);
        return px;
    }
    float printStr(const char constant str[6], float2 uv)
    {
        float px = 0.;
        px += printCh(str[0], uv);
        px += printCh(str[1], uv);
        px += printCh(str[2], uv);
        px += printCh(str[3], uv);
        px += printCh(str[4], uv);
        px += printCh(str[5], uv);
        return px;
    }
    //Returns the digit sprite for the given number.
    float4 getDigit(float d)
    {
        int id = int(floor(d));
        if(id == 0) return characters['0' - 32];
        if(id == 1) return characters['1' - 32];
        if(id == 2) return characters['2' - 32];
        if(id == 3) return characters['3' - 32];
        if(id == 4) return characters['4' - 32];
        if(id == 5) return characters['5' - 32];
        if(id == 6) return characters['6' - 32];
        if(id == 7) return characters['7' - 32];
        if(id == 8) return characters['8' - 32];
        if(id == 9) return characters['9' - 32];
        return float4(0.0);
    }
    
    //Prints out the given number starting at pos.
    float printFloat(float number, float2 uv, int precision = 2)
    {
        float result = 0.0;
        
        if (number < 0.) {
            result += printChar(characters['-' - 32], uv);
            number = fabs(number);
        }
        
        for(int i = 3;i >= -precision;i--)
        {
            float digit = fmod( number / pow(10.0, float(i)) , 10.0);
            
            if(i == -1) //Add a decimal point.
            {
                result += printChar(characters['.' - 32],uv);
            }
            
            if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.
            {
                result += printChar(getDigit(digit),uv);
            }
        }
        return result;
    }
    
    #define MAX_INT_DIGITS 4
    float printInteger(float number, int zeros, float2 uv)
    {
        float result = 0.0;
        
        for(int i = MAX_INT_DIGITS;i >= 0;i--)
        {
            float digit = fmod( number / pow(10.0, float(i)) , 10.0);
            
            if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.
            {
                result += printChar(getDigit(digit),uv);
            }
        }   
        return result;
    }
    
    
    void setTextColor(float4 color) {
        _textColor = color;
    }
    void setShadowColor(float4 color) {
        _shadowColor = color;
    }
    
    float4 printStrShadow(const char constant str[6], float2 uv)
    {
        float2 oldPrintPos = print_pos;
        float4 col = _shadowColor * printStr(str, uv + float2(-2, 2));
        print_pos = oldPrintPos;
        col += _textColor * printStr(str, uv);
        return col;
    }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_debug_vert(constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                           constant LightData& lightData [[buffer(2)]],
                           uint v_id [[ vertex_id ]])
    float4 in_position = scn::draw_quad_pos_from_id(v_id, 1.0);
    
    LightIO out;
    out.position = in_position;
    
    float4 vs = (lightData.invProjectionTransform * in_position);
    out.positionVS = vs.xyz / vs.w;
    
    return out;
// Fragment shader function
fragment float4 ds_debug_frag(LightIO in [[stage_in]] ,
                             constant LightData& lightData [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(1)]],
                             texture2d<float> gBuffer1 [[texture(1)]],
                             texture2d<float> gBuffer2 [[texture(2)]],
                             texture2d<float> gBuffer3 [[texture(3)]])
    float2 scale = float2(4.);
    
    constexpr sampler gbufferSampler(filter::nearest, address::clamp_to_zero);
    float2 resolution = float2(gBuffer1.get_width(), gBuffer1.get_height());
    float2 invResolution = 1. / resolution;
    float2 uv = in.position.xy * invResolution;
    
    float4 color = 0.;
    if (uv.y < 0.25) { // vignette display
        float2 vignetteUV = uv * scale;
        if (uv.x < 0.25) { // normal [-1..1]
            color.rgb = gBuffer2.sample(gbufferSampler, vignetteUV).rgb * 0.5 + 0.5;
        } else if (uv.x < 0.5) { // depth [0..1]
            color.rgb = gBuffer2.sample(gbufferSampler, vignetteUV).www;
        } else if (uv.x < 0.75) { // albedo
            color.rgb = gBuffer1.sample(gbufferSampler, vignetteUV).rgb;
        } else { // roughness
            color.rgb = gBuffer1.sample(gbufferSampler, vignetteUV).www;
        }
    }
    
    // albedo
//    color += gBuffer1.sample(gbufferSampler, uv * scale);
    // normal
//    color.rgb += gBuffer2.sample(gbufferSampler, uv * scale + float2(-1, 0.)).rgb * 0.5 + 0.5;
//    color += gBuffer2.sample(gbufferSampler, uv * scale + float2(-2, 0.)).wwww;
//    color += gBuffer3.sample(gbufferSampler, uv * scale + float2(-3, 0.));
    color = saturate(color);
    
    float2 gridUV = fmod(uv, 1. / scale);
    float grid = (1. - step(invResolution.x, gridUV.x)) + (1. - step(invResolution.y, gridUV.y));
    float mask = step(uv.y, 1. / scale.y + invResolution.y);
    mask *= step(uv.x, 4. / scale.x + invResolution.x);
    color +=  grid * mask;
    color.a = mask;
    
    float2 pos = in.position.xy;
    pos.y = resolution.y - pos.y;
#if SHOW_LABELS
    Text text;
    float4 textMask = 0.;
    
    text.setPrintPos(float2(4, 3 * resolution.y / 4 - 14));
    textMask += text.printStrShadow("ALBEDO", pos);
    text.setPrintPos(float2(4 + resolution.x / 4, 3 * resolution.y / 4 - 14));
    textMask += text.printStrShadow("NORMAL", pos);
    text.setPrintPos(float2(4 + 2 * resolution.x / 4, 3 * resolution.y / 4 - 14));
    textMask += text.printStrShadow("ROUGH ", pos);
    text.setPrintPos(float2(4 + 3 * resolution.x / 4, 3 * resolution.y / 4 - 14));
    textMask += text.printStrShadow("DEPTH ", pos);
//    color = mix(color, textColor, textMask);
    color += textMask;
#endif
    
    return color;
////////////////////////////////////////////////////////////////////////////
// Omni debug shader
////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_omni_debug_vert(LightVertex in [[ stage_in ]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                            constant LightUniforms& scn_node [[buffer(1)]],
                            constant LightData& lightData [[buffer(2)]])
    float4 in_position = float4(in.position * lightData.color_unscaledRadius.w, 1.0);
    
    LightIO out;
    out.positionVS =  (scn_node.modelViewTransform * in_position).xyz;
    out.position = scn_frame.projectionTransform * float4(out.positionVS, 1.0);
    return out;
fragment half4 ds_omni_debug_frag( LightIO in [[stage_in]] )
    return half4( 0.05 );
////////////////////////////////////////////////////////////////////////////
// Spot debug shader
////////////////////////////////////////////////////////////////////////////
vertex LightIO ds_spot_debug_vert(LightVertex in [[ stage_in ]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                            constant LightUniforms& scn_node [[buffer(1)]],
                            constant LightData& lightData [[buffer(2)]])
    // Transform the cone (original apex in 0,1,0) and scale it with cone properties
    float3 pt = float3(in.position.x, - in.position.z, in.position.y - 0.5);
    pt.z *= lightData.color_unscaledRadius.w; // attenuation/radius
    pt.xy *= lightData.direction_tanConeAngle.w * pt.z; // expansion radial
    
    float4 in_position = float4(pt, 1.0);
    
    LightIO out;
    out.positionVS =  (scn_node.modelViewTransform * in_position).xyz;
    out.position = scn_frame.projectionTransform * float4(out.positionVS, 1.0);
    return out;
fragment half4 ds_spot_debug_frag( LightIO in [[stage_in]] )
    return half4( 0.05 );
uniform sampler2D downSampler;
uniform sampler2D blurSampler;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    vec4 blur = texture2D( blurSampler, v_texCoord);
    float coc = max( down.a, 2. * blur.a - down.a );
gl_FragColor = vec4(down.rgb, coc);
    // debug
    //gl_FragColor = vec4(coc, 0., 0., 1.);
#import <metal_stdlib>
#import <simd/simd.h>
using namespace metal;
#import "scn_util.h"
#import "C3D-PostProcessUtils.h"
#import "C3D-PBR.metal"
// MARK: Specular: Pre-integrated DFG
kernel void compute_specularPreIntegratedDFG(texture2d<float, access::write> texture [[ texture(0) ]],
                                             uint3                           index   [[ thread_position_in_grid ]])
    if (index.x < texture.get_width() && index.y < texture.get_height()) {
        
        float u = float(index.x + 0.5) / float(texture.get_width());
        float v = float(index.y + 0.5) / float(texture.get_height());
        
        float cosThetaV = u; // cos([0, pi/2]) = [0, 1]
        float roughness = v;
        float2 DFG = scn_specularDFG(cosThetaV, roughness);
        
        texture.write(float4(DFG, 0.0, 0.0), index.xy);
        
    }
// MARK: Specular: Pre-integrated LD
// Precompute direction on a hammersley pattern, with sampleCount dependant of the roughness?
// more rough means cone is wider but in the meantime sample is in a lower mip
struct scn_specularLD_lut_t
    float4      samples[1024]; // dir:xyz, weight:w
    uint        sampleCount;
    float       roughness;
    float       weightSum;
inline float3 scn_specularLD_lut(constant scn_specularLD_lut_t&     uniforms,
                                 texturecube<float, access::sample> environment,
                                 float3                             n)
    constexpr sampler linearSampler(filter::linear);
    
    float3 LD = float3(0.0);
    float3 tangent, bitangent;
    scn::generate_basis(n, &tangent, &bitangent);
    
    for (ushort i = 0; i < uniforms.sampleCount; ++i) {
        float4 s = uniforms.samples[i];
        float3 l = tangent * s.x + bitangent * s.y + n * s.z;
        float3 Li = environment.sample(linearSampler, l, level(0)).rgb;
        Li = min(Li, 65504.); // max float16/half representable value
        
        LD  += Li * s.w;
    }
    
    return LD / uniforms.weightSum;
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
kernel void compute_specularPreIntegratedLD(texturecube<float, access::write>  texture          [[ texture(0) ]],
                                            texturecube<float, access::sample> environmentProbe [[ texture(1) ]],
                                            constant float&                    roughness        [[ buffer(0) ]],
                                            uint3                              index            [[ thread_position_in_grid ]])
    uint width = texture.get_width();
    uint height = texture.get_height();
    if (index.x >= width && index.y >= height)
        return;
    constexpr sampler linearSampler(filter::linear);
    
    float u = float(index.x) / float(width - 1);
    float v = float(index.y) / float(height - 1);
    
    uint face = index.z;
    float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
    float3 n = normalize(dir);
    
    float3 LD = scn_specularLD_cube(roughness, environmentProbe, n);
    
    texture.write(float4(LD, 1.0), index.xy, face);
#endif
kernel void compute_specularPreIntegratedLD_texture2d(texture2d<float, access::write>    texture          [[ texture(0) ]],
                                                      texturecube<float, access::sample> environmentProbe [[ texture(1) ]],
                                                      constant float&                    roughness        [[ buffer(0) ]],
                                                      constant uint&                     face             [[ buffer(1) ]],
                                                      uint3                              index            [[ thread_position_in_grid ]])
    if (index.x < texture.get_width() && index.y < texture.get_height()) {
        
        constexpr sampler linearSampler(filter::linear);
        
        float u = float(index.x) / float(texture.get_width() - 1);
        float v = float(index.y) / float(texture.get_height() - 1);
        
        float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
        float3 n = normalize(dir);
        
        float3 LD = scn_specularLD_cube(roughness, environmentProbe, n);
        texture.write(float4(LD, 1.0), index.xy, 0);
        
    }
fragment float4 draw_specularPreIntegratedLD_fragment(scn::draw_quad_io_t                 in               [[ stage_in ]],
                                                      texturecube<float, access::sample>  environmentProbe [[ texture(1) ]],
                                                      constant float&                     roughness        [[ buffer(0) ]],
                                                      constant uint&                      face             [[ buffer(1) ]])
    constexpr sampler linearSampler(filter::linear);
    
    float u = in.uv.x;
    float v = in.uv.y;
    
    float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
    float3 n = normalize(dir);
    
    float3 LD = scn_specularLD_cube(roughness, environmentProbe, n);
    return float4(LD, 1.0);
// MARK: Diffuse: Pre-integration
kernel void compute_diffusePreIntegrated_texture2d(texture2d<float, access::write>    texture          [[ texture(0) ]],
                                                   texturecube<float, access::sample> environmentProbe [[ texture(1) ]],
                                                   constant uint&                     samplingMipLevel [[ buffer(0) ]],
                                                   constant uint&                     face             [[ buffer(1) ]],
                                                   uint3                              index            [[ thread_position_in_grid ]])
    if (index.x < texture.get_width() && index.y < texture.get_height()) {
        
        constexpr sampler linearSampler(filter::linear);
        
        float u = float(index.x) / float(texture.get_width() - 1);
        float v = float(index.y) / float(texture.get_height() - 1);
        
        float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
        float3 n = normalize(dir);
        
        float3 L = scn_irradiance_cube(environmentProbe, samplingMipLevel, n);
        texture.write(float4(L, 1.0), index.xy, 0);
    }
fragment float4 draw_diffusePreIntegrated_fragment(scn::draw_quad_io_t                 in               [[ stage_in ]],
                                                   texturecube<float, access::sample>  environmentProbe [[ texture(1) ]],
                                                   constant uint&                      samplingMipLevel [[ buffer(0) ]],
                                                   constant uint&                      face             [[ buffer(1) ]])
    constexpr sampler linearSampler(filter::linear);
    
    float u = in.uv.x;
    float v = in.uv.y;
    
    float3 dir = scn::cubemap_dir_from_uv(face, float2(u, v));
    float3 n = normalize(dir);
    
    float3 L = scn_irradiance_cube(environmentProbe, samplingMipLevel, n);
    return float4(L, 1.0);
    "sequence": [
                 "SceneKit_SSAO_DEPTH",
                 "SceneKit_SSAO"
                 ],
    "passes": {
        "SceneKit_SSAO_DEPTH": {
            "outputs": {
                "depth": "depth-target",
                "color": "ssao-depth"
            },
            "depthStates": {
                "clear": true
            },
            "colorStates": {
                "clear": true,
                "clearColor": "-100000. -100000. -100000. -100000."
            },
            "samples": 1,
            "__clientProgram": "NO",
            "draw": "DRAW_SCENE",
        },
        "SceneKit_SSAO": {
            "outputs": {
                "color": "COLOR"
            },
            "inputs": {
                "color": "COLOR"
            },
            "draw": "DRAW_QUAD",
            "clientProgram": "NO",
            "program": "C3D-GLSL-UNAVAILABLE"
        }
    },
    "symbols": {},
    "targets": {
        "depth-target": {
            "type": "depth",
        },
        "ssao-depth": {
            "format": "rgba16f",
            "type": "color",
            "global": true,
            "mipmapped": true,
            "scaleFactor": 1.0
        }
    }
#import <metal_stdlib>
using namespace metal;
///////////////////////////////////////////////////////////////////////////////////
// Compute kernels
typedef struct
    packed_float3 position;
} morphvertex_t;
kernel void morph_copy_kernel(uint index          [[ thread_position_in_grid ]],
                         device morphvertex_t* out      [[ buffer(0) ]],
                         device morphvertex_t* base     [[ buffer(4) ]])
    out[index].position = base[index].position;
kernel void morph_blend_kernel(uint index          [[ thread_position_in_grid ]],
                          device morphvertex_t* out      [[ buffer(0) ]],
                          device morphvertex_t* delta    [[ buffer(4) ]],
                          constant float& weight         [[ buffer(3) ]])
    out[index].position += weight * delta[index].position;
// Position + Normal
typedef struct
    packed_float3 position;
    packed_float3 normal;
} morph_target_PN;
kernel void morph_copy_pn_kernel(uint index          [[ thread_position_in_grid ]],
                              device packed_float3* outP       [[ buffer(0) ]],
                              device packed_float3* outN       [[ buffer(1) ]],
                              device morph_target_PN* src      [[ buffer(4) ]])
    outP[index] = src[index].position;
//    outN[index][0] = srcN[index][0];
//    outN[index][1] = 0; //srcN[index][1]; break in Muir220 !!!!
//    outN[index][2] = srcN[index][2];
//    = float3(0,1,0);
    outN[index] = src[index].normal;
kernel void morph_blend_pn_kernel(uint index          [[ thread_position_in_grid ]],
                               device packed_float3* outP       [[ buffer(0) ]],
                               device packed_float3* outN       [[ buffer(1) ]],
                               constant float& weight         [[ buffer(3) ]],
                               device morph_target_PN* delta  [[ buffer(4) ]])
    outP[index] += weight * delta[index].position;
    outN[index] += weight * delta[index].normal;
#include <metal_stdlib>
using namespace metal;
#include "C3D-Tessellation.h"
struct triangle_tessellation_factors_t
    half4 factors; // edge0, edge1, edge2, inside
static void tessellator_fetch_positions(device uint16_t *indices, device uint8_t *positions, uint8_t positionStride, uint32_t patchIndex, thread float3 &position0, thread float3 &position1, thread float3 &position2)
    uint16_t vertexIndex0 = indices[patchIndex * 3 + 0];
    uint16_t vertexIndex1 = indices[patchIndex * 3 + 1];
    uint16_t vertexIndex2 = indices[patchIndex * 3 + 2];
    
    position0 = *(device packed_float3 *)(positions + positionStride * vertexIndex0);
    position1 = *(device packed_float3 *)(positions + positionStride * vertexIndex1);
    position2 = *(device packed_float3 *)(positions + positionStride * vertexIndex2);
static void tessellator_fetch_positions(device uint32_t *indices, device uint8_t *positions, uint8_t positionStride, uint32_t patchIndex, thread float3 &position0, thread float3 &position1, thread float3 &position2)
    uint32_t vertexIndex0 = indices[patchIndex * 3 + 0];
    uint32_t vertexIndex1 = indices[patchIndex * 3 + 1];
    uint32_t vertexIndex2 = indices[patchIndex * 3 + 2];
    
    position0 = *(device packed_float3 *)(positions + positionStride * vertexIndex0);
    position1 = *(device packed_float3 *)(positions + positionStride * vertexIndex1);
    position2 = *(device packed_float3 *)(positions + positionStride * vertexIndex2);
// MARK: - kC3DGeometryTessellatorTypeScreenSpaceAdaptive
static half screeenspace_adaptive_factor(constant SCNTessellatorTransforms &transforms, float ndcTesselationFactor, float3 position0, float3 position1) {
    
    float4 p0 = transforms.modelViewTransform * float4(position0, 1.0);
    float4 p1 = transforms.modelViewTransform * float4(position1, 1.0);
    
    float diameter = distance(p0.xyz, p1.xyz);
    
    float3 center = (p0.xyz + p1.xyz) / 2.0;
    float4 projectedCenter = transforms.projectionTransform * float4(center, 1.0);
    
    float projectedDiameter = abs(diameter * transforms.projectionTransform[1][1] / projectedCenter.w);
    
    return projectedDiameter * ndcTesselationFactor;
static half4 screeenspace_adaptive_factors(constant SCNTessellatorTransforms &transforms, float ndcTesselationFactor, float3 position0, float3 position1, float3 position2) {
    half4 factors;
    factors[0] = screeenspace_adaptive_factor(transforms, ndcTesselationFactor, position0, position1);
    factors[1] = screeenspace_adaptive_factor(transforms, ndcTesselationFactor, position1, position2);
    factors[2] = screeenspace_adaptive_factor(transforms, ndcTesselationFactor, position2, position0);
    factors[3] = (factors[0] + factors[1] + factors[3]) / 3.0;
    return factors;
kernel void compute_tessellation_factors_screeenspace_adaptive_uint16(device triangle_tessellation_factors_t      *factors    [[ buffer(0) ]],
                                                                      device uint16_t                             *indices    [[ buffer(1) ]],
                                                                      device uint8_t                              *positions  [[ buffer(2) ]],
                                                                      constant screeenspace_adaptive_parameters_t &parameters [[ buffer(3) ]],
                                                                      uint32_t                                     patchIndex [[ thread_position_in_grid ]])
    if (patchIndex < parameters.patchCount) {
        float3 position0, position1, position2;
        tessellator_fetch_positions(indices, positions, parameters.positionStride, patchIndex, position0, position1, position2);
        
        factors[patchIndex].factors = screeenspace_adaptive_factors(parameters.transforms, parameters.ndcTesselationFactor, position0, position1, position2);
    }
kernel void compute_tessellation_factors_screeenspace_adaptive_uint32(device triangle_tessellation_factors_t      *factors    [[ buffer(0) ]],
                                                                      device uint32_t                             *indices    [[ buffer(1) ]],
                                                                      device uint8_t                              *positions  [[ buffer(2) ]],
                                                                      constant screeenspace_adaptive_parameters_t &parameters [[ buffer(3) ]],
                                                                      uint32_t                                     patchIndex [[ thread_position_in_grid ]])
    if (patchIndex < parameters.patchCount) {
        float3 position0, position1, position2;
        tessellator_fetch_positions(indices, positions, parameters.positionStride, patchIndex, position0, position1, position2);
        
        factors[patchIndex].factors = screeenspace_adaptive_factors(parameters.transforms, parameters.ndcTesselationFactor, position0, position1, position2);
    }
// MARK: - kC3DGeometryTessellatorTypeConstrainedEdgeLength
static half4 constrained_edge_factors(float maxLength, float3 position0, float3 position1, float3 position2) {
    half4 factors;
    factors[0] = ceil(length(position1 - position2) / maxLength);
    factors[1] = ceil(length(position0 - position2) / maxLength);
    factors[2] = ceil(length(position0 - position1) / maxLength);
    factors[3] = min(factors[0], min(factors[1], factors[2]));
    return factors;
kernel void compute_tessellation_factors_constrained_edge_uint16(device triangle_tessellation_factors_t  *factors    [[ buffer(0) ]],
                                                                 device uint16_t                         *indices    [[ buffer(1) ]],
                                                                 device uint8_t                          *positions  [[ buffer(2) ]],
                                                                 constant constrained_edge_parameters_t  &parameters [[ buffer(3) ]],
                                                                 uint32_t                                 patchIndex [[ thread_position_in_grid ]])
    if (patchIndex < parameters.patchCount) {
        float3 position0, position1, position2;
        tessellator_fetch_positions(indices, positions, parameters.positionStride, patchIndex, position0, position1, position2);
        
        factors[patchIndex].factors = constrained_edge_factors(parameters.maximumEdgeLength, position0, position1, position2);
    }
kernel void compute_tessellation_factors_constrained_edge_uint32(device triangle_tessellation_factors_t  *factors    [[ buffer(0) ]],
                                                                 device uint32_t                         *indices    [[ buffer(1) ]],
                                                                 device uint8_t                          *positions  [[ buffer(2) ]],
                                                                 constant constrained_edge_parameters_t  &parameters [[ buffer(3) ]],
                                                                 uint32_t                                 patchIndex [[ thread_position_in_grid ]])
    if (patchIndex < parameters.patchCount) {
        float3 position0, position1, position2;
        tessellator_fetch_positions(indices, positions, parameters.positionStride, patchIndex, position0, position1, position2);
        
        factors[patchIndex].factors = constrained_edge_factors(parameters.maximumEdgeLength, position0, position1, position2);
    }
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>color1</key>
<string>ALBEDO</string>
<key>color2</key>
<string>NORMAL_DEPTH</string>
<key>color3</key>
<string>DS3</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>drawSceneIncludesOverlays</key>
<true/>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
<key>targets</key>
<dict>
<key>ALBEDO</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>NORMAL_DEPTH</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba32f</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>DS3</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba32f</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
// Attributes
attribute vec4 a_position;
//uniforms
uniform mat4 u_modelViewProjectionTransform;
void main()
    gl_Position = u_modelViewProjectionTransform * a_position;
#import <metal_stdlib>
using namespace metal;
#if __METAL_VERSION__ >= 120
#import "scn_metal"
#import "scn_util.h"
#import "scn_lighting.h"
#import "scn_standard_constants.h"
#import "C3D-PBR.metal"
// TODO list
// normalTransform should be 3x3 : would avoid the 3x3 conversion
// we could also have a noscale mode where normalTransform == modelView
// lighting
enum C3DLightingModel
    C3DLightingModelConstant,
    C3DLightingModelLambert,
    C3DLightingModelPhong,
    C3DLightingModelBlinn,
    C3DLightingModelNone,
    C3DLightingModelPhysicallyBased,
// derivated constants
// Do we want to pack property like this ?
// constant uint dummy [[ function_constant( 500 ) ]];
// constant uint dummy2  = ((dummy > 2) & 0x3);
constant bool use_per_vertex_diffuse    = use_per_vertex_lighting;
constant bool use_per_vertex_specular   = use_per_vertex_lighting && use_specular;
constant bool use_per_pixel_lighting    = !use_per_vertex_lighting; // && use_lighting ???
constant bool lighting_model_is_pbr     = (lighting_model == C3DLightingModelPhysicallyBased);
constant bool use_pbr                   = is_function_constant_defined(lighting_model) && lighting_model_is_pbr;
constant bool use_io_texcoord0          = io_texcoord_count > 0;
constant bool use_io_texcoord1          = io_texcoord_count > 1;
constant bool use_io_texcoord2          = io_texcoord_count > 2;
constant bool use_io_texcoord3          = io_texcoord_count > 3;
constant bool use_io_texcoord4          = io_texcoord_count > 4;
constant bool use_io_texcoord5          = io_texcoord_count > 5;
constant bool use_io_texcoord6          = io_texcoord_count > 6;
constant bool use_io_texcoord7          = io_texcoord_count > 7;
constant bool use_no_instancing             = !use_instancing;
constant bool use_skinning                  = max_bone_count > 0;
constant bool has_multiple_bone_per_vertex  = max_bone_count > 1; //  && max_bone_count > 1; crash the compiler
constant bool use_skinningWeights           = use_skinning && has_multiple_bone_per_vertex; // crash the compiler
constant bool use_skinningJoints            = use_skinning;
// dummy needed waiting for <rdar://problem/28298920> Too many? Function constants break my other shaders
constant bool dummy_shadow0             = LIGHT_HAS_SHADOW(use_light0);
constant bool use_shadow0               = is_function_constant_defined(use_light0) && dummy_shadow0;
constant bool dummy_shadow1             = LIGHT_HAS_SHADOW(use_light1);
constant bool use_shadow1               = is_function_constant_defined(use_light1) && dummy_shadow1;
constant bool dummy_shadow2             = LIGHT_HAS_SHADOW(use_light2);
constant bool use_shadow2               = is_function_constant_defined(use_light2) && dummy_shadow2;
constant bool dummy_shadow3             = LIGHT_HAS_SHADOW(use_light3);
constant bool use_shadow3               = is_function_constant_defined(use_light3) && dummy_shadow3;
constant bool dummy_gobo0               = LIGHT_HAS_GOBO(use_light0);
constant bool use_gobo0                 = is_function_constant_defined(use_light0) && dummy_gobo0;
constant bool dummy_gobo1               = LIGHT_HAS_GOBO(use_light1);
constant bool use_gobo1                 = is_function_constant_defined(use_light1) && dummy_gobo1;
constant bool dummy_gobo2               = LIGHT_HAS_GOBO(use_light2);
constant bool use_gobo2                 = is_function_constant_defined(use_light2) && dummy_gobo2;
constant bool dummy_gobo3               = LIGHT_HAS_GOBO(use_light3);
constant bool use_gobo3                 = is_function_constant_defined(use_light3) && dummy_gobo3;
constant bool dummy_ies0                = LIGHT_TYPE(use_light0) == kC3DLightIES;
constant bool dummy_iesType2d0          = (LIGHT_IES_TYPE(use_light0) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube0        = (LIGHT_IES_TYPE(use_light0) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d0              = dummy_ies0 && dummy_iesType2d0;
constant bool dummy_iesCube0            = dummy_ies0 && dummy_iesTypeCube0;
constant bool use_ies0                  = is_function_constant_defined(use_light0) && dummy_ies2d0;
constant bool use_iesCube0              = is_function_constant_defined(use_light0) && dummy_iesCube0;
constant bool dummy_ies1                = LIGHT_TYPE(use_light1) == kC3DLightIES;
constant bool dummy_iesType2d1          = (LIGHT_IES_TYPE(use_light1) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube1        = (LIGHT_IES_TYPE(use_light1) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d1              = dummy_ies1 && dummy_iesType2d1;
constant bool dummy_iesCube1            = dummy_ies1 && dummy_iesTypeCube1;
constant bool use_ies1                  = is_function_constant_defined(use_light1) && dummy_ies2d1;
constant bool use_iesCube1              = is_function_constant_defined(use_light1) && dummy_iesCube1;
constant bool dummy_ies2                = LIGHT_TYPE(use_light2) == kC3DLightIES;
constant bool dummy_iesType2d2          = (LIGHT_IES_TYPE(use_light2) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube2        = (LIGHT_IES_TYPE(use_light2) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d2              = dummy_ies2 && dummy_iesType2d2;
constant bool dummy_iesCube2            = dummy_ies2 && dummy_iesTypeCube2;
constant bool use_ies2                  = is_function_constant_defined(use_light2) && dummy_ies2d2;
constant bool use_iesCube2              = is_function_constant_defined(use_light2) && dummy_iesCube2;
constant bool dummy_ies3                = LIGHT_TYPE(use_light3) == kC3DLightIES;
constant bool dummy_iesType2d3          = (LIGHT_IES_TYPE(use_light3) != kC3DLightIESTypeCubemap);
constant bool dummy_iesTypeCube3        = (LIGHT_IES_TYPE(use_light3) == kC3DLightIESTypeCubemap);
constant bool dummy_ies2d3              = dummy_ies3 && dummy_iesType2d3;
constant bool dummy_iesCube3            = dummy_ies3 && dummy_iesTypeCube3;
constant bool use_ies3                  = is_function_constant_defined(use_light3) && dummy_ies2d3;
constant bool use_iesCube3              = is_function_constant_defined(use_light3) && dummy_iesCube3;
constexpr sampler linearSampler(filter::linear, mip_filter::linear);
constexpr sampler shadowSampler(filter::linear, mip_filter::none, compare_func::greater_equal);
// Inputs
#define MAX_LIGHT_COUNT 8
typedef struct {
    // we always to transform to view_space, then project using scn_frame.projectionTransform
    float4x4 modelViewTransform;            // 64
    // the normal matrix may be the same than modelView if the model has no scale
    float4x4 normalTransform;               // + 64
    uint8_t lightIndices[MAX_LIGHT_COUNT];  // + 8
    float nodeOpacity;                      // + 4
    float orientationPreserved;             // + 4
    
} scn_std_node;
//#ifdef USE_SKINNING // need to be last since we may cut the buffer size based on the real bone number
//    float4 skinningJointMatrices[765]; // Consider having a separate buffer ?
//#endif
typedef struct {
    float3 position         [[ attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[ attribute(SCNVertexSemanticNormal),      function_constant(need_normal) ]];
    float4 tangent          [[ attribute(SCNVertexSemanticTangent),     function_constant(need_tangent) ]];
    float4 color            [[ attribute(SCNVertexSemanticColor)        function_constant(need_vertex_color) ]];
    float4 skinningWeights  [[ attribute(SCNVertexSemanticBoneWeights), function_constant(use_skinningWeights)]];
    uint4  skinningJoints   [[ attribute(SCNVertexSemanticBoneIndices), function_constant(use_skinningJoints)]];
    float2 texcoord0        [[ attribute(SCNVertexSemanticTexcoord0),   function_constant(need_texcoord0) ]];
    float2 texcoord1        [[ attribute(SCNVertexSemanticTexcoord1),   function_constant(need_texcoord1) ]];
    float2 texcoord2        [[ attribute(SCNVertexSemanticTexcoord2),   function_constant(need_texcoord2) ]];
    float2 texcoord3        [[ attribute(SCNVertexSemanticTexcoord3),   function_constant(need_texcoord3) ]];
    float2 texcoord4        [[ attribute(SCNVertexSemanticTexcoord4),   function_constant(need_texcoord4) ]];
    float2 texcoord5        [[ attribute(SCNVertexSemanticTexcoord5),   function_constant(need_texcoord5) ]];
    float2 texcoord6        [[ attribute(SCNVertexSemanticTexcoord6),   function_constant(need_texcoord6) ]];
    float2 texcoord7        [[ attribute(SCNVertexSemanticTexcoord7),   function_constant(need_texcoord7) ]];
} scn_vertex_t; // __attribute__((scn_per_frame));
// custom sources will be added as separate buffers
typedef struct {
    float4 fragmentPosition [[position]]; // The window relative coordinate (x, y, z, 1/w) values for the fragment
    
    float fragmentSize  [[ point_size, function_constant(use_point_rendering) ]];
    float4 vertexColor  [[ function_constant(use_io_vertex_color) ]];
    float3 position     [[ function_constant(use_io_position) ]];
    float3 normal       [[ function_constant(use_io_normal) ]];
    float3 tangent      [[ function_constant(need_tangent) ]];
    float3 bitangent    [[ function_constant(need_tangent) ]];
    // array are not supported in stage_in
    float2 texcoord0    [[ function_constant(use_io_texcoord0) ]];
    float2 texcoord1    [[ function_constant(use_io_texcoord1) ]];
    float2 texcoord2    [[ function_constant(use_io_texcoord2) ]];
    float2 texcoord3    [[ function_constant(use_io_texcoord3) ]];
    float2 texcoord4    [[ function_constant(use_io_texcoord4) ]];
    float2 texcoord5    [[ function_constant(use_io_texcoord5) ]];
    float2 texcoord6    [[ function_constant(use_io_texcoord6) ]];
    float2 texcoord7    [[ function_constant(use_io_texcoord7) ]];
    float3 diffuse      [[ function_constant(use_per_vertex_diffuse) ]];
    float3 specular     [[ function_constant(use_per_vertex_specular) ]];
    
#ifdef USE_EXTRA_VARYINGS
    __ExtraVaryingsDecl__
#endif
    
} commonprofile_io;
struct SCNShaderSurface {
    float3 view;                // Direction from the point on the surface toward the camera (V)
    float3 position;            // Position of the fragment
    float3 normal;              // Normal of the fragment (N)
    float3 geometryNormal;      // Normal of the fragment - not taking into account normal map
    float2 normalTexcoord;      // Normal texture coordinates
    float3 tangent;             // Tangent of the fragment
    float3 bitangent;           // Bitangent of the fragment
    float4 ambient;             // Ambient property of the fragment
    float2 ambientTexcoord;     // Ambient texture coordinates
    float4 diffuse;             // Diffuse property of the fragment. Alpha contains the opacity.
    float2 diffuseTexcoord;     // Diffuse texture coordinates
    float4 specular;            // Specular property of the fragment
    float2 specularTexcoord;    // Specular texture coordinates
    float4 emission;            // Emission property of the fragment
    float2 emissionTexcoord;    // Emission texture coordinates
    float4 multiply;            // Multiply property of the fragment
    float2 multiplyTexcoord;    // Multiply texture coordinates
    float4 transparent;         // Transparent property of the fragment
    float2 transparentTexcoord; // Transparent texture coordinates
    float4 reflective;          // Reflective property of the fragment
    float  metalness;           // Metalness
    float2 metalnessTexcoord;   // Metalness texture coordinates
    float  roughness;           // Roughness
    float2 roughnessTexcoord;   // Metalness texture coordinates
    float shininess;            // Shininess property of the fragment.
    float fresnel;              // Fresnel property of the fragment.
    float ambientOcclusion;     // Ambient occlusion term of the fragment
    float3 _normalTS;           // UNDOCUMENTED in tangent space
#ifdef USE_SURFACE_EXTRA_DECL
    __SurfaceExtraDecl__
#endif
struct SCNShaderGeometry
    float4 position;
    float3 normal;
    float4 tangent;
    float4 color;
    float2 texcoords[8]; // MAX_UV
struct commonprofile_uniforms {
    float4 diffuseColor;
    float4 specularColor;
    float4 ambientColor;
    float4 emissionColor;
    float4 reflectiveColor;
    float4 multiplyColor;
    float4 transparentColor;
    float metalness;
    float roughness;
    
    float diffuseIntensity;
    float specularIntensity;
    float normalIntensity;
    float ambientIntensity;
    float emissionIntensity;
    float reflectiveIntensity;
    float multiplyIntensity;
    float transparentIntensity;
    float metalnessIntensity;
    float roughnessIntensity;
    float displacementIntensity;
    
    float materialShininess;
    float selfIlluminationOcclusion;
    float transparency;
    float3 fresnel; // x: ((n1-n2)/(n1+n2))^2 y:1-x z:exponent
    
    // TODO max transform count but the CPU will not always copy all this size
    float4x4 textureTransforms[1];
// Shader modifiers declaration (only enabled if one modifier is present)
#ifdef USE_SHADER_MODIFIERS
__ShaderModifiersDecl__
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////
struct SCNShaderLightingContribution {
    float3 ambient;
    float3 diffuse;
    float3 specular;
    float3 modulate;
struct SCNLightTextures {
    // possible shadow maps
    depth2d<float> u_shadowTexture0                     [[ texture(12) ]];
    depth2d<float> u_shadowTexture1                     [[ texture(13) ]];
    depth2d<float> u_shadowTexture2                     [[ texture(14) ]];
    depth2d<float> u_shadowTexture3                     [[ texture(15) ]];
    
    // possible gobo
    texture2d<float> u_goboTexture0                     [[ texture(16) ]];
    texture2d<float> u_goboTexture1                     [[ texture(17) ]];
    texture2d<float> u_goboTexture2                     [[ texture(18) ]];
    texture2d<float> u_goboTexture3                     [[ texture(19) ]];
    depth2d<float> _getShadowMap(uint lightInfo, SCNLightTextures lightTextures)
    {
        ushort shadowMapIndex = LIGHT_SHADOW_MAP(lightInfo);
        switch (shadowMapIndex) {
            case 1: return lightTextures.u_shadowTexture0;
            case 2: return lightTextures.u_shadowTexture1;
            case 3: return lightTextures.u_shadowTexture2;
            case 4: return lightTextures.u_shadowTexture3;
        }
    }
struct SCNLightingParameters {
    
    SCNLightData        lightData;
    uint                lightInfo;
    float3              lightDirection;
    float3              attenuation;
    SCNShaderSurface    surface;
static float3 scn_lighting_direction(SCNLightData lightData, uint lightInfo, thread SCNShaderSurface& surface)
    uint lightType = LIGHT_TYPE(lightInfo);
    if (lightType == kC3DLightDirectional) {
        return lightData.direction;
    }
    return normalize(lightData.position - surface.position);
    
static void scn_lambert_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 intensity = lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
static void scn_blinn_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    float3 intensity =  lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
    float3 h = normalize(l + surface.view);
    lightingContribution.specular += powr(max(0.f, dot(surface.normal, h)), surface.shininess) * intensity;
static void scn_phong_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 intensity = lightData.color.rgb * max(0.f, dot(surface.normal, l));
    lightingContribution.diffuse += intensity;
    
    float3 r = reflect(-l, surface.normal);
    lightingContribution.specular += pow(max(0.f, dot(r, surface.view)), surface.shininess) * intensity;
static void scn_pbr_lighting(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContribution)
    SCNLightData lightData      = params.lightData;
    SCNShaderSurface surface    = params.surface;
    float3 l                    = params.lightDirection;
    
    float3 diffuseOut, specularOut;
    scn_pbr_lightingContribution_pointLight(l, surface.normal.xyz, surface.view, surface.diffuse.rgb, surface.metalness, surface.roughness, diffuseOut, specularOut);
    
    lightingContribution.diffuse    += diffuseOut  * lightData.pbrColor.rgb;
    lightingContribution.specular   += specularOut * lightData.pbrColor.rgb;
static float scn_distance_attenuation(SCNLightingParameters params)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float3 l = params.surface.position - lightData.position;
    if (use_pbr) {
        uint lightType = LIGHT_TYPE(lightInfo);
        if (lightType == kC3DLightDirectional) { // directional light cannot have attenuation ?
            return 1.f;
        }
        return scn_pbr_distanceAttenuation(l);
    } else {
        uint distAttType = LIGHT_DIST_ATT(lightInfo);
        if (distAttType != kC3DLightAttenuationTypeNone) {
            
            float3 att = lightData.distanceAttenuation;
            float dist = length(l);
            switch (distAttType) {
                case kC3DLightAttenuationTypeConstant:
                    return step(dist, att.x);
                case kC3DLightAttenuationTypeLinear:
                    return saturate(dist * att.x + att.y);
                case kC3DLightAttenuationTypeQuadratic:
                    return scn::sq(saturate(dist * att.x + att.y));
                case kC3DLightAttenuationTypeExponent:
                    return pow(saturate(dist * att.x + att.y), att.z);
            }
        }
    }
    return 1.f;
static float scn_spot_attenuation(SCNLightingParameters params)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float3 l                = params.lightDirection;
    
    uint spotAttType = LIGHT_SPOT_ATT(lightInfo);
    if (spotAttType != kC3DLightAttenuationTypeNone) {
        
        float3 spotFactors = lightData.spotAttenuation;
        switch (spotAttType) {
            case kC3DLightAttenuationTypeConstant:
                return step(spotFactors.x, dot(l, lightData.direction));
            case kC3DLightAttenuationTypeLinear:
                return saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y);
            case kC3DLightAttenuationTypeQuadratic:
                return scn::sq(saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y));
            case kC3DLightAttenuationTypeExponent:
                return pow(saturate(dot(l, lightData.direction) * spotFactors.x + spotFactors.y), spotFactors.z);
        }
    }
    return 1.f;
/* This is the optimized version all-in-one, but we cannot pass nullptr as textures, so we had to split the shader
static void scn_optimized do_light(SCNLightingParameters params, depth2d<float> shadowMap, texture2d<float> goboMap, thread SCNShaderLightingContribution& lightingContrib)
    uint lightInfo          = params.lightInfo;
    // Do first the attenuations, working on light.color
    
    // Distance
    float attenuation = scn_distance_attenuation(params);
    
    // spot
    attenuation *= scn_spot_attenuation(params);
    
    // Shadow
    if (LIGHT_HAS_SHADOW(lightInfo)) {
        attenuation *= scn_shadow_attenuation(params, shadowMap);
    }
    
    // integrate attenuation in light.color
    params.lightData.color.rgb *= attenuation;
    
    // Gobo (keep it inline since it colorize the light color
    if (LIGHT_HAS_GOBO(lightInfo)) {
        SCNLightData lightData  = params.lightData;
        float goboIntensity = lightData.color.a; // TODO : what is this ? gobo intensity ?
        constexpr sampler goboSampler = sampler();
        float3 goboColor = texture2DProj(goboMap, goboSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f))).rgb;
        if (LIGHT_IS_MODULATE(lightInfo)) {
            params.lightData.color.rgb *= mix(float3(1.), goboColor, goboIntensity);
        } else {
            params.lightData.color.rgb *= goboColor * goboIntensity;
        }
    }
    
    // TODO IES
    
    switch (lighting_model) {
        case C3DLightingModelLambert:
            scn_lambert_lighting(params, lightingContrib);
            break;
        case C3DLightingModelBlinn:
            scn_blinn_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhong:
            scn_phong_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhysicallyBased:
            scn_pbr_lighting(params, lightingContrib);
            break;
        default:
            // static_assert(lighting_model == kLightingModelPhysicallyBased, "should not go there");
            break;
            //        case kLightingModelPhysicallyBased:
//            scn_pbr_lightingContribution_pointLight()
    }
static void scn_do_gobo(thread SCNLightingParameters& params, texture2d<float> goboMap)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    float goboIntensity = lightData.color.a; // TODO : what is this ? gobo intensity ?
    float3 goboColor = texture2DProj(goboMap, linearSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f))).rgb;
    if (LIGHT_IS_MODULATE(lightInfo)) {
        params.attenuation *= mix(float3(1.), goboColor, goboIntensity);
    } else {
        params.attenuation *= goboColor * goboIntensity;
    }
// IES 2D
static void scn_do_ies(thread SCNLightingParameters& params, texture2d<float> iesMap, sampler iesSampler)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    // OPTIMIZE : this is done twice posssibly (again in scn_light)
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    float3 spotFactors      = lightData.spotAttenuation;
    float att = 0.f;
    switch (LIGHT_IES_TYPE(lightInfo)) {
        case kC3DLightIESType1D:
            att = iesMap.sample(iesSampler, float2(acos(dot(params.lightDirection, lightData.direction))*spotFactors.x, 0.f)).r;
            break;
            
        case kC3DLightIESType2D:
        {
            
            float vertAngle     = acos(dot(params.lightDirection, lightData.direction));
            // OPTIMIZE : store in params along the lightingDirection
            float3 surfaceRay   = params.surface.position - lightData.position;
            float3 projPos = normalize(surfaceRay - dot(surfaceRay, lightData.direction) * lightData.direction);
            float2 texCoord = float2(dot(projPos, lightData.right), dot(projPos, lightData.up)) * vertAngle * spotFactors.x;
            att = iesMap.sample(iesSampler, texCoord * 0.5f + 0.5f).r;
            
        } break;
    }
    params.attenuation.rgb *= att;
// overload to treat IES cubemaps
static void scn_do_ies(thread SCNLightingParameters& params, texturecube<float> iesMap, sampler iesSampler)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    // OPTIMIZE : this is done twice posssibly (again in scn_light)
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    if (LIGHT_IES_TYPE(lightInfo) == kC3DLightIESTypeCubemap) {
        float att = iesMap.sample(iesSampler, (lightData.shadowMatrix * float4(params.surface.position, 1.f)).xyz).r;
        params.attenuation.rgb *= att;
    } // else we have a problem....
static void scn_do_shadow(thread SCNLightingParameters& params, depth2d<float> shadowMap, constant float4* u_shadowKernel)
    uint lightInfo          = params.lightInfo;
    SCNLightData lightData  = params.lightData;
    
    uchar sampleCount = LIGHT_SHADOW_SAMPLE(lightInfo);
    
    float4 lightScreen = lightData.shadowMatrix * float4(params.surface.position, 1.f);
    
    float shadowRadius = lightData.shadowRadius;
    
    float shadowingTerm = 0.f;
    if (sampleCount > 1) { // need soft shadows
        float filteringSizeFactor = shadowRadius * lightScreen.w;
        for (int i = 0; i < sampleCount; i++) {
            
            shadowingTerm += shadow2DProj(shadowSampler, shadowMap, lightScreen + (u_shadowKernel[i] * filteringSizeFactor));
        }
        shadowingTerm /= float(sampleCount);
    } else {
        shadowingTerm = shadow2DProj(shadowSampler, shadowMap, lightScreen);
    }
    
    // final shadow attenuation to lighting
    // shadow "color" stored in alpha of the light color
    params.attenuation *= (1.f - shadowingTerm * lightData.color.a);
static void scn_do_light(SCNLightingParameters params, thread SCNShaderLightingContribution& lightingContrib)
    uint lightInfo          = params.lightInfo;
    // update light direction (used for distance/spot attenuation, lighting...)
    params.lightDirection   = scn_lighting_direction(params.lightData, lightInfo, params.surface);
    
    // Do first the attenuations, working on light.color
    // Distance
    float attenuation = scn_distance_attenuation(params);
    
    // spot
    uint lightType = LIGHT_TYPE(lightInfo);
    if (lightType == kC3DLightSpot) {
        attenuation *= scn_spot_attenuation(params);
    }
    params.attenuation *= attenuation;
    // integrate attenuation in light.color
    params.lightData.color.rgb *= params.attenuation;
    params.lightData.pbrColor.rgb *= params.attenuation;
    switch (lighting_model) {
        case C3DLightingModelLambert:
            scn_lambert_lighting(params, lightingContrib);
            break;
        case C3DLightingModelBlinn:
            scn_blinn_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhong:
            scn_phong_lighting(params, lightingContrib);
            break;
        case C3DLightingModelPhysicallyBased:
            scn_pbr_lighting(params, lightingContrib);
            break;
        default:
            // static_assert(lighting_model == kLightingModelPhysicallyBased, "should not go there");
            break;
            //        case kLightingModelPhysicallyBased:
            //            scn_pbr_lightingContribution_pointLight()
    }
///////////////////////////////////////////////////////////////////////////////////////////////////////////
inline SCNPBRSurface SCNShaderSurfaceToSCNPBRSurface(SCNShaderSurface surface)
    SCNPBRSurface s;
    
    s.n = surface.normal;
    s.v = surface.view;
    s.albedo = surface.diffuse.xyz;
    
    if (use_emission)
        s.emission = surface.emission.xyz;
    else
        s.emission = float3(0.);
    
    s.metalness = surface.metalness;
    s.roughness = surface.roughness;
    s.ao = surface.ambientOcclusion;
    return s;
static float4 scn_pbr_combine_cubemap(SCNPBRSurface                      surface,
                                     SCNShaderLightingContribution      lighting,
                                     texture2d<float, access::sample>   specularDFG,
                                     texturecube<float, access::sample> specularLD,
                                     texturecube<float, access::sample> irradianceTexture,
                                     constant SCNSceneBuffer&           scn_frame)
    // inputs
    float4x4 localDirToWorldCubemapDir = scn_frame.viewToCubeTransform;
    float environmentIntensity = scn_frame.environmentIntensity;
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float3 r = reflect(-v, n); // mirror vector (view vector around normal)
    float NoV = saturate(dot(n, v));
    
    float3 diffuseDominantNDirection = n;
    float3 specularDominantNDirection = r;
    
    // transform in cubespace
    diffuseDominantNDirection = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
    
    float3 irradiance;
    if (use_emission_as_selfIllumination) {
        irradiance = surface.emission;
    } else {
        // Diffuse
        irradiance = irradianceTexture.sample(linearSampler, diffuseDominantNDirection).rgb * environmentIntensity;
    }
    
    // Specular
    float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
    
    float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb * environmentIntensity;
    float2 DFG = specularDFG.sample(linearSampler, float2(NoV, roughness)).rg;
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float3 diffuse = effectiveAlbedo * irradiance;
    float3 specular = LD * (reflectance * DFG.r + DFG.g);
    
    //
    float3 ibl_color;
    if (use_emission_as_selfIllumination) { // we have to invert the test compare to the first one due to a compiler bug
        
        float selfIlluminationAmbientOcclusion = saturate(mix(1., ambientOcclusion, surface.selfIlluminationOcclusion));
        ibl_color = selfIlluminationAmbientOcclusion * diffuse + ambientOcclusion * specular;
    } else {
        ibl_color = ambientOcclusion * (diffuse + specular);
    }
    
    float4 color;
    color.rgb = (lighting.ambient * surface.ao + lighting.diffuse) * surface.albedo.rgb + lighting.specular + ibl_color;
    
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    
    return color;
static float4 scn_pbr_combine_probes(SCNPBRSurface                      surface,
                              SCNShaderLightingContribution      lighting,
                              texture2d<float, access::sample>   specularDFG,
                              texturecube<float, access::sample> specularLD,
                              sh3_coefficients                   shCoefficients,
                              constant SCNSceneBuffer&           scn_frame)
    // inputs
    float4x4 localDirToWorldCubemapDir = scn_frame.viewToCubeTransform;
    float environmentIntensity = scn_frame.environmentIntensity;
    
    float3 n = surface.n;
    float3 v = surface.v;
    float3 albedo = surface.albedo;
    float metalness = surface.metalness;
    float roughness = surface.roughness;
    float ambientOcclusion = surface.ao;
    
    float3 r = reflect(-v, n); // mirror vector (view vector around normal)
    float NoV = saturate(dot(n, v));
    
    float3 diffuseDominantNDirection = n;
    float3 specularDominantNDirection = r;
    
    // transform in cubespace
    diffuseDominantNDirection = scn::mat4_mult_float3(localDirToWorldCubemapDir, diffuseDominantNDirection);
    
    float3 irradiance;
    if (use_emission_as_selfIllumination) {
        irradiance = surface.emission;
    } else {
        irradiance = shEvalDirection(float4(diffuseDominantNDirection, 1.), shCoefficients) * environmentIntensity;
    }
    
    // Specular
    float mipLevel = roughness * float(specularLD.get_num_mip_levels() - 1);
    
    float3 LD = specularLD.sample(linearSampler, scn::mat4_mult_float3(localDirToWorldCubemapDir, specularDominantNDirection), level(mipLevel)).rgb * environmentIntensity;
    float2 DFG = specularDFG.sample(linearSampler, float2(NoV, roughness)).rg;
    
    float3 effectiveAlbedo = mix(albedo, float3(0.0), metalness);
    float3 reflectance = mix(float3(PBR_F0_NON_METALLIC), albedo, metalness);
    
    float3 diffuse = effectiveAlbedo * irradiance;
    float3 specular = LD * (reflectance * DFG.r + DFG.g);
    
    //
    float3 ibl_color;
    if (use_emission_as_selfIllumination) { // we have to invert the test compare to the first one due to a compiler bug
        
        float selfIlluminationAmbientOcclusion = saturate(mix(1., ambientOcclusion, surface.selfIlluminationOcclusion));
        ibl_color = selfIlluminationAmbientOcclusion * diffuse + ambientOcclusion * specular;
    } else {
        ibl_color = ambientOcclusion * (diffuse + specular);
    }
    
    float4 color;
    color.rgb = (lighting.ambient * surface.ao + lighting.diffuse) * surface.albedo.rgb + lighting.specular + ibl_color;
    
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    
    return color;
inline float4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    float4 color = {0.,0.,0., surface.diffuse.a};
    
    float3 D = lighting.diffuse;
    if (use_ambient_lighting)
        D += lighting.ambient * surface.ambientOcclusion;
    if (use_emission_as_selfIllumination)
        D += surface.emission.rgb;
    // Do we want to clamp there ????
    color.rgb = surface.diffuse.rgb * D;
    if (use_specular || use_reflective) {
        float3 S = (use_specular) ? lighting.specular : float3(0.);
        if (use_reflective)
            S += surface.reflective.rgb * surface.ambientOcclusion;
        if (use_specular)
            S *= surface.specular.rgb;
        color.rgb += S;
    }
    
    if (use_ambient && !use_ambient_as_ambientOcclusion)
        color.rgb += surface.ambient.rgb * lighting.ambient;
    if (use_emission && !use_emission_as_selfIllumination)
        color.rgb += surface.emission.rgb;
    if (use_multiply)
        color.rgb *= surface.multiply.rgb;
    if (use_modulate_lighting)
        color.rgb *= lighting.modulate;
    return color;
// Vertex shader function
struct scn_patch_t {
    patch_control_point<scn_vertex_t> controlPoints;
static void standard_initalize_surface(thread SCNShaderSurface&  surface,
                                       thread SCNShaderGeometry& geometry,
                                       thread scn_std_node&      in_node)
    // if (use_position || use_instancing)
    surface.position = (in_node.modelViewTransform * geometry.position).xyz;
    
    if (use_io_normal)
        surface.normal = normalize(scn::mat3(in_node.normalTransform) * geometry.normal);
    
    if (need_tangent) {
        surface.tangent = normalize(scn::mat3(in_node.normalTransform) * geometry.tangent.xyz);
        // no need to renormalize since tangent and normal should be orthogonal
        surface.bitangent = geometry.tangent.w * cross(surface.tangent, surface.normal);
    }
    if (use_io_view)
        surface.view = normalize(-surface.position);
static void standard_initalize_geometry(thread scn_vertex_t&      in,
                                        thread SCNShaderGeometry& geometry)
    geometry.position = float4(in.position, 1.f);
    
    if (need_normal)
        geometry.normal = in.normal;
    
    if (need_tangent)
        geometry.tangent = in.tangent;
    
    if (need_texcoord0)
        geometry.texcoords[0] = in.texcoord0;
    if (need_texcoord1)
        geometry.texcoords[1] = in.texcoord1;
    if (need_texcoord2)
        geometry.texcoords[2] = in.texcoord2;
    if (need_texcoord3)
        geometry.texcoords[3] = in.texcoord3;
    if (need_texcoord4)
        geometry.texcoords[4] = in.texcoord4;
    if (need_texcoord5)
        geometry.texcoords[5] = in.texcoord5;
    if (need_texcoord6)
        geometry.texcoords[6] = in.texcoord6;
    if (need_texcoord7)
        geometry.texcoords[7] = in.texcoord7;
    
    geometry.color = (need_vertex_color) ? in.color : float4(1.f);
static void standard_initalize_geometry_post_tessellation(thread scn_patch_t&       in,
                                                          thread SCNShaderGeometry& geometry,
                                                          float3                    patchCoord)
    geometry.position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.0);
    
    if (need_normal)
        geometry.normal = normalize(scn::barycentric_mix(in.controlPoints[0].normal, in.controlPoints[1].normal, in.controlPoints[2].normal, patchCoord));
    
    if (need_tangent)
        geometry.tangent = normalize(scn::barycentric_mix(in.controlPoints[0].tangent, in.controlPoints[1].tangent, in.controlPoints[2].tangent, patchCoord));
    
    if (need_texcoord0)
        geometry.texcoords[0] = scn::barycentric_mix(in.controlPoints[0].texcoord0, in.controlPoints[1].texcoord0, in.controlPoints[2].texcoord0, patchCoord);
    if (need_texcoord1)
        geometry.texcoords[1] = scn::barycentric_mix(in.controlPoints[0].texcoord1, in.controlPoints[1].texcoord1, in.controlPoints[2].texcoord1, patchCoord);
    if (need_texcoord2)
        geometry.texcoords[2] = scn::barycentric_mix(in.controlPoints[0].texcoord2, in.controlPoints[1].texcoord2, in.controlPoints[2].texcoord2, patchCoord);
    if (need_texcoord3)
        geometry.texcoords[3] = scn::barycentric_mix(in.controlPoints[0].texcoord3, in.controlPoints[1].texcoord3, in.controlPoints[2].texcoord3, patchCoord);
    if (need_texcoord4)
        geometry.texcoords[4] = scn::barycentric_mix(in.controlPoints[0].texcoord4, in.controlPoints[1].texcoord4, in.controlPoints[2].texcoord4, patchCoord);
    if (need_texcoord5)
        geometry.texcoords[5] = scn::barycentric_mix(in.controlPoints[0].texcoord5, in.controlPoints[1].texcoord5, in.controlPoints[2].texcoord5, patchCoord);
    if (need_texcoord6)
        geometry.texcoords[6] = scn::barycentric_mix(in.controlPoints[0].texcoord6, in.controlPoints[1].texcoord6, in.controlPoints[2].texcoord6, patchCoord);
    if (need_texcoord7)
        geometry.texcoords[7] = scn::barycentric_mix(in.controlPoints[0].texcoord7, in.controlPoints[1].texcoord7, in.controlPoints[2].texcoord7, patchCoord);
    
    geometry.color = (need_vertex_color) ? scn::barycentric_mix(in.controlPoints[0].color, in.controlPoints[1].color, in.controlPoints[2].color, patchCoord) : float4(1.f);
static void standard_apply_skinning(float4                    skinningWeights,
                                    uint4                     skinningJoints,
                                    constant float4*          skinningJointMatrices,
                                    thread SCNShaderGeometry& geometry)
    float3 pos = 0.f;
    float3 nrm = 0.f;
    float3 tgt = 0.f;
    for (int i = 0; i < max_bone_count; ++i) {
        float weight = (max_bone_count > 1) ? skinningWeights[i] : 1.f;
        if (weight <= 0.f)
            continue;
        
        int idx = int(skinningJoints[i]) * 3;
        float4x4 jointMatrix = float4x4(skinningJointMatrices[idx],
                                        skinningJointMatrices[idx+1],
                                        skinningJointMatrices[idx+2],
                                        float4(0.f, 0.f, 0.f, 1.f));
        
        pos += (geometry.position * jointMatrix).xyz * weight;
        if (need_normal)
            nrm += geometry.normal * scn::mat3(jointMatrix) * weight;
        if (need_tangent)
            tgt += geometry.tangent.xyz * scn::mat3(jointMatrix) * weight;
    }
    
    geometry.position.xyz = pos;
    
    if (need_normal)
        geometry.normal = nrm;
    
    if (need_tangent)
        geometry.tangent.xyz = tgt;
static void standard_configure_out(constant commonprofile_uniforms& commonprofile,
                                   thread SCNShaderSurface&         surface,
                                   thread SCNShaderGeometry&        geometry,
                                   thread commonprofile_io&         out)
    if (use_io_position)
        out.position = surface.position;
    
    if (use_io_normal)
        out.normal = surface.normal;
    
    if (need_tangent) {
        out.tangent = surface.tangent;
        out.bitangent = surface.bitangent;
    }
    
    if (use_io_vertex_color)
        out.vertexColor = geometry.color;
    
    float2 uvOut[kSCNTexcoordCount];
    
    if (is_function_constant_defined(diffuse_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ diffuse_channel ];
        if (is_function_constant_defined(diffuse_transform_index))
            uv = (commonprofile.textureTransforms[diffuse_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ diffuse_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(normal_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ normal_channel ];
        if (is_function_constant_defined(normal_transform_index))
            uv = (commonprofile.textureTransforms[normal_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ normal_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(transparent_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ transparent_channel ];
        if (is_function_constant_defined(transparent_transform_index))
            uv = (commonprofile.textureTransforms[transparent_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ transparent_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(emission_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ emission_channel ];
        if (is_function_constant_defined(emission_transform_index))
            uv = (commonprofile.textureTransforms[emission_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ emission_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(ambient_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ ambient_channel ];
        if (is_function_constant_defined(ambient_transform_index))
            uv = (commonprofile.textureTransforms[ambient_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ ambient_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(multiply_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ multiply_channel ];
        if (is_function_constant_defined(multiply_transform_index))
            uv = (commonprofile.textureTransforms[multiply_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ multiply_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(specular_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ specular_channel ];
        if (is_function_constant_defined(specular_transform_index))
            uv = (commonprofile.textureTransforms[specular_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ specular_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(roughness_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ roughness_channel ];
        if (is_function_constant_defined(roughness_transform_index))
            uv = (commonprofile.textureTransforms[roughness_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ roughness_texcoord_io_index ] = uv;
    }
    
    if (is_function_constant_defined(metalness_texcoord_io_index)) {
        float2 uv = geometry.texcoords[ metalness_channel ];
        if (is_function_constant_defined(metalness_transform_index))
            uv = (commonprofile.textureTransforms[metalness_transform_index] * float4(uv, 0.f, 1.f)).xy;
        uvOut[ metalness_texcoord_io_index ] = uv;
    }
    
    switch (io_texcoord_count - 1) {
        case 7 : out.texcoord7 = uvOut[7];
        case 6 : out.texcoord6 = uvOut[6];
        case 5 : out.texcoord5 = uvOut[5];
        case 4 : out.texcoord4 = uvOut[4];
        case 3 : out.texcoord3 = uvOut[3];
        case 2 : out.texcoord2 = uvOut[2];
        case 1 : out.texcoord1 = uvOut[1];
        case 0 : out.texcoord0 = uvOut[0];
    }
vertex commonprofile_io standard_vert(scn_vertex_t                      in                        [[ stage_in ]],
                                      constant SCNSceneBuffer&          scn_frame                 [[ buffer(0) ]],
                                      constant scn_std_node&            scn_node                  [[ buffer(1), function_constant(use_no_instancing) ]],
                                      // we use device here to override the 64Ko limit of constant buffers on NV hardware
                                      device scn_std_node*              scn_nodeInstances         [[ buffer(1), function_constant(use_instancing) ]],
                                      device SCNLightData*              scn_lights                [[ buffer(2), function_constant(use_per_vertex_lighting) ]],
                                      constant commonprofile_uniforms&  scn_commonprofile         [[ buffer(3) ]],
                                      constant float4*                  scn_skinningJointMatrices [[ buffer(4), function_constant(use_skinning) ]], // should we use device ?
                                      uint                              instanceID                [[ instance_id, function_constant(use_instancing) ]]
                                      // used for texture transform and materialShininess in case of perVertexLighting
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                      __VertexExtraArguments__
#endif
                                      )
    scn_std_node in_node;
    if (use_instancing) {
        in_node = scn_nodeInstances[instanceID];
    } else {
        in_node = scn_node;
    }
    SCNShaderGeometry _geometry;
    standard_initalize_geometry(in, _geometry);
    if (use_skinning) {
        standard_apply_skinning(in.skinningWeights, in.skinningJoints, scn_skinningJointMatrices, _geometry);
    }
    
#ifdef USE_GEOMETRY_MODIFIER
// DoGeometryModifier START
__DoGeometryModifier__
// DoGeometryModifier END
#endif
    
    // Transform the geometry elements in view space
    SCNShaderSurface _surface;
    standard_initalize_surface(_surface, _geometry, in_node);
    commonprofile_io out;
    
    // Lighting
    if (use_per_vertex_lighting) {
        SCNShaderLightingContribution _lightingContribution;
        _lightingContribution.diffuse = 0.;
        _lightingContribution.specular = 0.;
        _surface.shininess = scn_commonprofile.materialShininess;
        // TODO
        //__VertexDoLighting__
        out.diffuse = _lightingContribution.diffuse;
        if (use_specular)
            out.specular = _lightingContribution.specular;
    }
    standard_configure_out(scn_commonprofile, _surface, _geometry, out);
    
    // if we want to keep a fast path, we have to provide scn_node.modelViewProjectionTransform
    // out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.f);
    
    if (use_point_rendering) // TODO make this configurable
        out.fragmentSize = 1.f;
    return out;
[[ patch(triangle, 3) ]]
vertex commonprofile_io standard_post_tessellation_vert(scn_patch_t                       in                        [[ stage_in ]],
                                                        float3                            patchCoord                [[ position_in_patch ]],
                                                        constant SCNSceneBuffer&          scn_frame                 [[ buffer(0) ]],
                                                        constant scn_std_node&            scn_node                  [[ buffer(1), function_constant(use_no_instancing) ]],
                                                        // we use device here to override the 64Ko limit of constant buffers on NV hardware
                                                        device scn_std_node*              scn_nodeInstances         [[ buffer(1), function_constant(use_instancing) ]],
                                                        device SCNLightData*              scn_lights                [[ buffer(2), function_constant(use_per_vertex_lighting) ]],
                                                        constant commonprofile_uniforms&  scn_commonprofile         [[ buffer(3) ]],
                                                        constant float4*                  scn_skinningJointMatrices [[ buffer(4), function_constant(use_skinning) ]], // should we use device ?
                                                        // 168 bytes
                                                        uint                              instanceID                [[ instance_id, function_constant(use_instancing) ]]
                                                        // used for texture transform and materialShininess in case of perVertexLighting
#ifdef USE_VERTEX_EXTRA_ARGUMENTS
                                      __VertexExtraArgumentsPostTessellation__
#endif
                                      )
    scn_std_node in_node;
    if (use_instancing) {
        in_node = scn_nodeInstances[instanceID];
    } else {
        in_node = scn_node;
    }
    
    SCNShaderGeometry _geometry;
    standard_initalize_geometry_post_tessellation(in, _geometry, patchCoord);
    
    if (use_skinning) {
        //TODO standard_apply_skinning(in.skinningWeights, in.skinningJoints, scn_skinningJointMatrices, _geometry);
    }
    
#ifdef USE_GEOMETRY_MODIFIER
    // DoGeometryModifier START
    __DoGeometryModifierPostTessellation__
    // DoGeometryModifier END
#endif
    
    // Transform the geometry elements in view space
    SCNShaderSurface _surface;
    standard_initalize_surface(_surface, _geometry, in_node);
    
    commonprofile_io out;
    
    // Lighting
    if (use_per_vertex_lighting) {
        SCNShaderLightingContribution _lightingContribution;
        _lightingContribution.diffuse = 0.;
        _lightingContribution.specular = 0.;
        _surface.shininess = scn_commonprofile.materialShininess;
        
        // TODO
        //__VertexDoLightingPostTessellation__
        
        out.diffuse = _lightingContribution.diffuse;
        if (use_specular)
            out.specular = _lightingContribution.specular;
    }
    
    standard_configure_out(scn_commonprofile, _surface, _geometry, out);
    
    // if we want to keep a fast path, we have to provide scn_node.modelViewProjectionTransform
    // out.fragmentPosition = scn_node.modelViewProjectionTransform * _geometry.position;
    
    out.fragmentPosition = scn_frame.projectionTransform * float4(_surface.position, 1.f);
    
    if (use_point_rendering) // TODO make this configurable
        out.fragmentSize = 1.f;
    return out;
struct SCNOutput
    float4 color;
// Fragment shader function
fragment half4 standard_frag(commonprofile_io in [[stage_in]],
                             constant commonprofile_uniforms& scn_commonprofile [[buffer(0)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(1)]]
                             
                             , device SCNLightData* scn_lights                     [[ buffer(2),  function_constant(use_per_pixel_lighting) ]]
                             , constant scn_std_node& scn_node                     [[ buffer(3), function_constant(use_no_instancing) ]]
                             , device scn_std_node* scn_nodeInstances              [[ buffer(3), function_constant(use_instancing) ]]
                             , constant float4* u_shadowKernel                     [[ buffer(4) ]] // will only be reflected if used
                             , constant sh3_coefficients& scn_shCoefficients       [[ buffer(5), function_constant(use_probes_lighting) ]]
                             , texture2d<float> u_emissionTexture                  [[ texture(0), function_constant(use_emission_map)]]
                             , sampler          u_emissionTextureSampler           [[ sampler(0), function_constant(use_emission_map)]]
                             , texture2d<float> u_ambientTexture                   [[ texture(1), function_constant(use_ambient_map)]]
                             , sampler          u_ambientTextureSampler            [[ sampler(1), function_constant(use_ambient_map)]]
                             , texture2d<float> u_diffuseTexture                   [[ texture(2), function_constant(use_diffuse_map)]]
                             , sampler          u_diffuseTextureSampler            [[ sampler(2), function_constant(use_diffuse_map)]]
                             , texture2d<float> u_specularTexture                  [[ texture(3), function_constant(use_specular_map)]]
                             , sampler          u_specularTextureSampler           [[ sampler(3), function_constant(use_specular_map)]]
                             , texture2d<float> u_reflectiveTexture                [[ texture(4), function_constant(use_reflective_map)]]
                             , sampler          u_reflectiveTextureSampler         [[ sampler(4), function_constant(use_reflective_map)]]
                             , texturecube<float> u_reflectiveCubeTexture          [[ texture(4), function_constant(use_reflectivecube_map)]]
                             , sampler            u_reflectiveCubeTextureSampler   [[ sampler(4), function_constant(use_reflectivecube_map)]]
                             , texture2d<float> u_transparentTexture               [[ texture(5), function_constant(use_transparent_map)]]
                             , sampler          u_transparentTextureSampler        [[ sampler(5), function_constant(use_transparent_map)]]
                             , texture2d<float> u_multiplyTexture                  [[ texture(6), function_constant(use_multiply_map)]]
                             , sampler          u_multiplyTextureSampler           [[ sampler(6), function_constant(use_multiply_map)]]
                             , texture2d<float> u_normalTexture                    [[ texture(7), function_constant(use_normal_map)]]
                             , sampler          u_normalTextureSampler             [[ sampler(7), function_constant(use_normal_map)]]
                             , texture2d<float> u_metalnessTexture                 [[ texture(3), function_constant(use_metalness_map) ]]
                             , sampler          u_metalnessTextureSampler          [[ sampler(3), function_constant(use_metalness_map) ]]
                             , texture2d<float> u_roughnessTexture                 [[ texture(4), function_constant(use_roughness_map) ]]
                             , sampler          u_roughnessTextureSampler          [[ sampler(4), function_constant(use_roughness_map) ]]
                             , texturecube<float> u_irradianceTexture              [[ texture(8), function_constant(use_pbr) ]]
                             
                             , texturecube<float> u_radianceTexture                [[ texture(9), function_constant(use_pbr) ]]
                             , texture2d<float>   u_specularDFGTexture             [[ texture(10), function_constant(use_pbr) ]]
                             , texture2d<float> u_ssaoTexture                      [[ texture(11), function_constant(use_ssao) ]]
                             // possible shadow maps
                             , depth2d<float> u_shadowTexture0                     [[ texture(12), function_constant(use_shadow0) ]]
                             , depth2d<float> u_shadowTexture1                     [[ texture(13), function_constant(use_shadow1) ]]
                             , depth2d<float> u_shadowTexture2                     [[ texture(14), function_constant(use_shadow2) ]]
                             , depth2d<float> u_shadowTexture3                     [[ texture(15), function_constant(use_shadow3) ]]
                             
                             // possible gobo
                             , texture2d<float> u_goboTexture0                     [[ texture(16), function_constant(use_gobo0) ]]
                             , texture2d<float> u_goboTexture1                     [[ texture(17), function_constant(use_gobo1) ]]
                             , texture2d<float> u_goboTexture2                     [[ texture(18), function_constant(use_gobo2) ]]
                             , texture2d<float> u_goboTexture3                     [[ texture(19), function_constant(use_gobo3) ]]
                             // we do not use external samplers for IES since it is not user configurable
                             // TODO but we should use some for GOBOs (but there are issues with the limited number of samplers)
                             // Moving to MSL 2.0, we should sampler array and indices
                             
                             // IES 2D
                             , texture2d<float> u_iesTexture0                      [[ texture(16), function_constant(use_ies0) ]]
                             , texture2d<float> u_iesTexture1                      [[ texture(17), function_constant(use_ies1) ]]
                             , texture2d<float> u_iesTexture2                      [[ texture(18), function_constant(use_ies2) ]]
                             , texture2d<float> u_iesTexture3                      [[ texture(19), function_constant(use_ies3) ]]
                             // IES Cube
                             , texturecube<float> u_iesCubeTexture0                [[ texture(16), function_constant(use_iesCube0) ]]
                             , texturecube<float> u_iesCubeTexture1                [[ texture(17), function_constant(use_iesCube1) ]]
                             , texturecube<float> u_iesCubeTexture2                [[ texture(18), function_constant(use_iesCube2) ]]
                             , texturecube<float> u_iesCubeTexture3                [[ texture(19), function_constant(use_iesCube3) ]]
                             
                             , bool isFrontFacing                                  [[ front_facing, function_constant(use_double_sided) ]]
#ifdef USE_FRAGMENT_EXTRA_ARGUMENTS
__FragmentExtraArguments__
#endif
                             )
    // <rdar://problem/28350584> Crash in metal compiler
    //  scn_std_node in_node = (use_instancing) ? scn_nodeInstances[0] : scn_node;
    scn_std_node in_node;
    if (use_instancing) {
        // TODO : we should pass the instance ID to the fragment shader
        in_node = scn_nodeInstances[0];
    } else {
        in_node = scn_node;
    }
    SCNShaderSurface _surface;
    float2 uv[kSCNTexcoordCount];
    switch (io_texcoord_count - 1) {
        case 7 : uv[7] = in.texcoord7;
        case 6 : uv[6] = in.texcoord6;
        case 5 : uv[5] = in.texcoord5;
        case 4 : uv[4] = in.texcoord4;
        case 3 : uv[3] = in.texcoord3;
        case 2 : uv[2] = in.texcoord2;
        case 1 : uv[1] = in.texcoord1;
        case 0 : uv[0] = in.texcoord0;
    }
    if (is_function_constant_defined(diffuse_texcoord_io_index))
        _surface.diffuseTexcoord = uv[diffuse_texcoord_io_index];
    
    if (is_function_constant_defined(normal_texcoord_io_index))
        _surface.normalTexcoord = uv[normal_texcoord_io_index];
    
    if (is_function_constant_defined(transparent_texcoord_io_index))
        _surface.transparentTexcoord = uv[transparent_texcoord_io_index];
    
    if (is_function_constant_defined(emission_texcoord_io_index))
        _surface.emissionTexcoord = uv[emission_texcoord_io_index];
    
    if (is_function_constant_defined(ambient_texcoord_io_index))
        _surface.ambientTexcoord = uv[ambient_texcoord_io_index];
    
    if (is_function_constant_defined(multiply_texcoord_io_index))
        _surface.multiplyTexcoord = uv[multiply_texcoord_io_index];
    
    if (is_function_constant_defined(specular_texcoord_io_index))
        _surface.specularTexcoord = uv[specular_texcoord_io_index];
    
    if (is_function_constant_defined(roughness_texcoord_io_index))
        _surface.roughnessTexcoord = uv[roughness_texcoord_io_index];
    if (is_function_constant_defined(metalness_texcoord_io_index))
        _surface.metalnessTexcoord = uv[metalness_texcoord_io_index];
    _surface.ambientOcclusion = 1.f; // default to no AO
    if (use_ambient_map) {
        float4 c = u_ambientTexture.sample(u_ambientTextureSampler, _surface.ambientTexcoord);
        if (is_function_constant_defined(ambient_texture_component)) {
            c = c[ambient_texture_component];
        }
        
        if (use_ambient_as_ambientOcclusion) {
            _surface.ambientOcclusion = c.r;
            if (use_ambient_intensity)
                _surface.ambientOcclusion = saturate(mix(1.f, _surface.ambientOcclusion, scn_commonprofile.ambientIntensity));
        } else {
            _surface.ambient = c;
            if (use_ambient_intensity)
                _surface.ambient *= scn_commonprofile.ambientIntensity;
        }
    } else {
        _surface.ambient = scn_commonprofile.ambientColor;
    }
    if (use_ambient && use_io_vertex_color)
        _surface.ambient *= in.vertexColor;
    if (use_ssao)
        _surface.ambientOcclusion *= u_ssaoTexture.sample( linearSampler, in.fragmentPosition.xy * scn_frame.inverseResolution.xy ).x;
    
    if (use_diffuse_map) {
        _surface.diffuse = u_diffuseTexture.sample(u_diffuseTextureSampler, _surface.diffuseTexcoord);
        if (is_function_constant_defined(diffuse_texture_component))
            _surface.diffuse = _surface.diffuse[diffuse_texture_component];
        if (use_diffuse_intensity)
            _surface.diffuse.rgb *= scn_commonprofile.diffuseIntensity;
    } else {
        _surface.diffuse = scn_commonprofile.diffuseColor;
    }
    if (use_diffuse && use_io_vertex_color) {
        _surface.diffuse *= in.vertexColor;
    }
    
    if (use_specular_map) {
        _surface.specular = u_specularTexture.sample(u_specularTextureSampler, _surface.specularTexcoord);
        if (is_function_constant_defined(specular_texture_component))
            _surface.specular = _surface.specular[specular_texture_component];
        if (use_specular_intensity)
            _surface.specular *= scn_commonprofile.specularIntensity;
    } else {
        _surface.specular = scn_commonprofile.specularColor;
    }
    if (use_emission_map) {
        _surface.emission = u_emissionTexture.sample(u_emissionTextureSampler, _surface.emissionTexcoord);
        if (is_function_constant_defined(emission_texture_component))
            _surface.emission = float4(_surface.emission[emission_texture_component]);
        if (use_emission_intensity)
            _surface.emission *= scn_commonprofile.emissionIntensity;
    } else {
        _surface.emission = scn_commonprofile.emissionColor;
    }
    if (use_multiply_map) {
        _surface.multiply = u_multiplyTexture.sample(u_multiplyTextureSampler, _surface.multiplyTexcoord);
        if (is_function_constant_defined(multiply_texture_component))
            _surface.multiply = float4(_surface.multiply[multiply_texture_component]);
        if (use_multiply_intensity)
            _surface.multiply = mix(float4(1.f), _surface.multiply, scn_commonprofile.multiplyIntensity);
    } else {
        _surface.multiply = scn_commonprofile.multiplyColor;
    }
    
    if (use_transparent_map) {
        _surface.transparent = u_transparentTexture.sample(u_transparentTextureSampler, _surface.transparentTexcoord);
        if (is_function_constant_defined(transparent_texture_component))
            _surface.transparent = float4(_surface.transparent[transparent_texture_component]);
        if (use_transparent_intensity)
            _surface.transparent *= scn_commonprofile.transparentIntensity;
    } else {
        _surface.transparent = scn_commonprofile.transparentColor;
    }
    if (use_metalness_map) {
        float4 c = u_metalnessTexture.sample(u_metalnessTextureSampler, _surface.metalnessTexcoord);
        if (is_function_constant_defined(metalness_texture_component))
            _surface.metalness = c[metalness_texture_component];
        else // metalness is monochromatic and we do support R8 texture
            _surface.metalness = c.r;
        if (use_metalness_intensity)
            _surface.metalness *= scn_commonprofile.metalnessIntensity;
    } else {
        _surface.metalness = scn_commonprofile.metalness;
    }
    
    if (use_roughness_map) {
        float4 c = u_roughnessTexture.sample(u_roughnessTextureSampler, _surface.roughnessTexcoord).r;
        if (is_function_constant_defined(roughness_texture_component))
            _surface.roughness = c[roughness_texture_component];
        else // roughness is monochromatic and we do support R8 texture
            _surface.roughness = c.r;
        if (use_roughness_intensity)
            _surface.roughness *= scn_commonprofile.roughnessIntensity;
    } else {
        _surface.roughness = scn_commonprofile.roughness;
    }
    // OPTIM : we could store intensity in roughness and always multiply by that (and init to 1 when no map)
    
    if (use_io_normal) {
        if (use_double_sided)
            _surface.geometryNormal = normalize(in.normal.xyz) * in_node.orientationPreserved * ((float(isFrontFacing) * 2.f) - 1.f);
        else
            _surface.geometryNormal = normalize(in.normal.xyz);
        _surface.normal = _surface.geometryNormal;
    }
    if (need_tangent) {
        _surface.tangent = in.tangent;
        _surface.bitangent = in.bitangent;
    }
    if (use_io_position)
        _surface.position = in.position;
    if (use_io_view)
        _surface.view = normalize(-in.position);
    if (use_normal_map) {
        float3x3 ts2vs = float3x3(_surface.tangent, _surface.bitangent, _surface.normal);
        _surface._normalTS = u_normalTexture.sample(u_normalTextureSampler, _surface.normalTexcoord).rgb;
        if (is_function_constant_defined(normal_texture_component)) { // special case : normal reconstructed from rg
            _surface._normalTS.xy = _surface._normalTS.xy * 2.f - 1.f;
            _surface._normalTS.z = sqrt(1 - length_squared(_surface._normalTS.xy));
        } else {
            _surface._normalTS = _surface._normalTS * 2.f - 1.f;
        }
        if (use_normal_intensity)
            _surface._normalTS = mix(float3(0.f, 0.f, 1.f), _surface._normalTS, scn_commonprofile.normalIntensity);
        // transform the normal in view space
        _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
    } else {
        _surface._normalTS = float3(0.f);
    }
    
    if (use_reflective_map) {
        
        float3 refl = reflect( -_surface.view, _surface.normal );
        float m = 2.f * sqrt( refl.x*refl.x + refl.y*refl.y + scn::sq(refl.z + 1.f));
        _surface.reflective = u_reflectiveTexture.sample(u_reflectiveTextureSampler, float2(float2(refl.x,-refl.y) / m) + 0.5f);
        if (is_function_constant_defined(reflective_texture_component))
            _surface.reflective = _surface.reflective[reflective_texture_component];
        
        if (use_reflective_intensity)
            _surface.reflective *= scn_commonprofile.reflectiveIntensity;
    
    } else if (use_reflectivecube_map) {
    
        float3 refl = reflect( _surface.position, _surface.normal );
        _surface.reflective = u_reflectiveCubeTexture.sample(u_reflectiveCubeTextureSampler, scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl)); // sample the cube map in world space
        if (is_function_constant_defined(reflective_texture_component))
            _surface.reflective = _surface.reflective[reflective_texture_component];
        
        if (use_reflective_intensity)
            _surface.reflective *= scn_commonprofile.reflectiveIntensity;
    
    } else {
        _surface.reflective = scn_commonprofile.reflectiveColor;
    }
    
    if (use_fresnel) {
        _surface.fresnel = scn_commonprofile.fresnel.x + scn_commonprofile.fresnel.y * pow(1.f - saturate(dot(_surface.view, _surface.normal)), scn_commonprofile.fresnel.z);
        _surface.reflective *= _surface.fresnel;
    }
    _surface.shininess = scn_commonprofile.materialShininess;
    
#ifdef USE_SURFACE_MODIFIER
// DoSurfaceModifier START
__DoSurfaceModifier__
// DoSurfaceModifier END
#endif
    SCNShaderLightingContribution _lightingContribution = {0};
    if (use_ambient_lighting)
        _lightingContribution.ambient = scn_frame.ambientLightingColor.rgb;
    
    if (use_lighting) {
        if (use_per_pixel_lighting) {
            _lightingContribution.diffuse = float3(0.f);
            if (use_modulate_lighting)
                _lightingContribution.modulate = float3(1.f);
            if (use_specular)
                _lightingContribution.specular = float3(0.f);
            
            if (is_function_constant_defined(use_light0)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light0;
                params.lightData = scn_lights[ in_node.lightIndices[0] ];
                params.attenuation = float3(1.f);
                if (use_shadow0) scn_do_shadow(params, u_shadowTexture0, u_shadowKernel);
                if (use_gobo0)   scn_do_gobo(params, u_goboTexture0);
                if (use_ies0)    scn_do_ies(params, u_iesTexture0, linearSampler /* u_iesTexture0Sampler */);
                if (use_iesCube0)    scn_do_ies(params, u_iesCubeTexture0, linearSampler /* u_iesCubeTexture0Sampler */);
                scn_do_light(params, _lightingContribution);
            }
            if (is_function_constant_defined(use_light1)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light1;
                params.lightData = scn_lights[ in_node.lightIndices[1] ];
                params.attenuation = float3(1.f);
                if (use_shadow1) scn_do_shadow(params, u_shadowTexture1, u_shadowKernel);
                if (use_gobo1)   scn_do_gobo(params, u_goboTexture1);
                if (use_ies1)    scn_do_ies(params, u_iesTexture1, linearSampler /* u_iesTexture1Sampler */);
                if (use_iesCube1)    scn_do_ies(params, u_iesCubeTexture1, linearSampler /* u_iesCubeTexture1Sampler */);
                scn_do_light(params, _lightingContribution);
            }
            if (is_function_constant_defined(use_light2)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light2;
                params.lightData = scn_lights[ in_node.lightIndices[2] ];
                params.attenuation = float3(1.f);
                if (use_shadow2) scn_do_shadow(params, u_shadowTexture2, u_shadowKernel);
                if (use_gobo2)   scn_do_gobo(params, u_goboTexture2);
                if (use_ies2)    scn_do_ies(params, u_iesTexture2, linearSampler /* u_iesTexture1Sampler */);
                if (use_iesCube2)    scn_do_ies(params, u_iesCubeTexture2, linearSampler /* u_iesCubeTexture1Sampler */);
                scn_do_light(params, _lightingContribution);
            }
            
            if (is_function_constant_defined(use_light3)) {
                SCNLightingParameters params;
                params.surface = _surface;
                params.lightInfo = use_light3;
                params.lightData = scn_lights[ in_node.lightIndices[3] ];
                params.attenuation = float3(1.f);
                if (use_shadow3) scn_do_shadow(params, u_shadowTexture3, u_shadowKernel);
                if (use_gobo3)   scn_do_gobo(params, u_goboTexture3);
                if (use_ies3)    scn_do_ies(params, u_iesTexture3, linearSampler /* u_iesTexture1Sampler */);
                if (use_iesCube3)    scn_do_ies(params, u_iesCubeTexture3, linearSampler /* u_iesCubeTexture1Sampler */);
                scn_do_light(params, _lightingContribution);
            }
            
        } else { // per vertex lighting
            _lightingContribution.diffuse = in.diffuse;
            if (use_specular)
                _lightingContribution.specular = in.specular;
        }
        if (avoid_overlighting) {
            _lightingContribution.diffuse = saturate(_lightingContribution.diffuse);
            if (use_specular)
                _lightingContribution.specular = saturate(_lightingContribution.specular);
        }
    } else { // no lighting
        _lightingContribution.diffuse = float3(1.f);
    }
    
    // Combine
    SCNOutput _output;
    if (use_pbr) {
        SCNPBRSurface pbr_surface = SCNShaderSurfaceToSCNPBRSurface(_surface);
        pbr_surface.selfIlluminationOcclusion = scn_commonprofile.selfIlluminationOcclusion;
        if (use_probes_lighting) {
            _output.color = scn_pbr_combine_probes(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, scn_shCoefficients, scn_frame);
        } else {
            _output.color = scn_pbr_combine_cubemap(pbr_surface, _lightingContribution, u_specularDFGTexture, u_radianceTexture, u_irradianceTexture, scn_frame);
        }
        _output.color.a = _surface.diffuse.a;
    } else {
        _output.color = illuminate(_surface, _lightingContribution);
    }
    
    if (use_fog) {
        float fogFactor = pow(clamp(length(_surface.position.xyz) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0., scn_frame.fogColor.a), scn_frame.fogParameters.z);
        _output.color.rgb = mix(_output.color.rgb, scn_frame.fogColor.rgb * _output.color.a, fogFactor);
    }
    if (!diffuse_premultiplied)
        _output.color.rgb *= _surface.diffuse.a;
    float nodeOpacity = use_node_opacity ? in_node.nodeOpacity : 1.f;
    if (use_transparent) {
        if (use_transparency)
            _surface.transparent *= scn_commonprofile.transparency;
        
        if (use_transparency_rgbzero) {
            // compute luminance
            _surface.transparent.a = (_surface.transparent.r * 0.212671f) + (_surface.transparent.g * 0.715160f) + (_surface.transparent.b * 0.072169f);
            _output.color *= nodeOpacity * (float4(1.f) - _surface.transparent);
        } else { // ALPHA_ONE
            _output.color *= (nodeOpacity * _surface.transparent.a);
        }
    } else {
        if (use_transparency) { // TRANSPARENCY without TRANSPARENT slot (nodeOpacity + diffuse.a)
            _output.color *= (nodeOpacity * scn_commonprofile.transparency);
        }
    }
    
#ifdef USE_FRAGMENT_MODIFIER
// DoFragmentModifier START
__DoFragmentModifier__
// DoFragmentModifier END
#endif
    
//#ifdef USE_SSAO
//    _output.color.rgb = float3(_surface.ambientOcclusion);
//#endif
    
    if (use_discard && _output.color.a == 0.) // we could set a different limit here
        discard_fragment();
    return half4(_output.color);
#endif // __METAL_VERSION__
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) && (USE_POSITION == 2)
varying vec3 v_position;
#endif
#if defined(USE_NORMAL) && (USE_NORMAL == 2)
varying vec3 v_normal;
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
varying vec3 v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
varying vec3 v_bitangent;
#endif
#ifdef USE_AMBIENT_LIGHTING
uniform vec4 u_ambientLightColor;
#endif
#ifdef USE_DIFFUSE_MAP
uniform sampler2D u_diffuseTexture;
#ifdef USE_DIFFUSE_INTENSITY
uniform float u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
uniform vec4 u_diffuseColor;
#endif
#ifdef USE_NORMAL_MAP
uniform sampler2D u_normalTexture;
#ifdef USE_NORMAL_INTENSITY
uniform float u_normalIntensity;
#endif
#endif
#ifdef USE_SHININESS
uniform float u_materialShininess;
#endif
#ifdef USE_SPECULAR
#ifdef USE_SPECULAR_MAP
uniform sampler2D u_specularTexture;
#ifdef USE_SPECULAR_INTENSITY
uniform float u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
uniform vec4 u_specularColor;
#endif
#endif // USE_SPECULAR
#ifdef USE_AMBIENT_MAP
uniform sampler2D u_ambientTexture;
#ifdef USE_AMBIENT_INTENSITY
uniform float u_ambientIntensity;
#endif
#elif defined(USE_AMBIENT_COLOR)
uniform vec4 u_ambientColor;
#endif
#ifdef USE_REFLECTIVE_MAP
uniform sampler2D u_reflectiveTexture;
#elif defined(USE_REFLECTIVE_COLOR)
uniform vec4 u_reflectiveColor;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform samplerCube u_reflectiveTexture;
#endif
#if defined(USE_REFLECTIVE_CUBEMAP)
uniform mat4 u_viewToCubeWorld;
#endif
#ifdef USE_REFLECTIVE_INTENSITY
uniform float u_reflectiveIntensity;
#endif
#ifdef USE_FRESNEL
uniform vec3 u_fresnel; // x: ((n1-n2)/(n1+n2))^2 y:1-x z:exponent
#endif
#ifdef USE_EMISSION_MAP
uniform sampler2D u_emissionTexture;
#ifdef USE_EMISSION_INTENSITY
uniform float u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
uniform vec4 u_emissionColor;
#endif
#ifdef USE_MULTIPLY_MAP
uniform sampler2D u_multiplyTexture;
#ifdef USE_MULTIPLY_INTENSITY
uniform float u_multiplyIntensity;
#endif
#elif defined(USE_MULTIPLY_COLOR)
uniform vec4 u_multiplyColor;
#endif
#ifdef USE_TRANSPARENT_MAP
uniform sampler2D u_transparentTexture;
#ifdef USE_TRANSPARENT_INTENSITY
uniform float u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
uniform vec4 u_transparentColor;
#endif
#ifdef USE_VERTEX_COLOR
varying vec4 v_vertexColor;
#endif
#ifdef USE_NODE_OPACITY // only for RGB_ZERO
uniform float u_nodeOpacity;
#endif
#ifdef USE_TRANSPARENCY // only for RGB_ZERO
uniform float u_transparency;
#endif
#ifdef USE_DOUBLE_SIDED
uniform float u_orientationPreserved;
#endif
#ifdef USE_TIME
uniform float u_time;
#endif
#ifdef USE_FOG
uniform vec4 u_fogColor;
uniform vec3 u_fogParameters; // x:-1/(end-start) y:1-start*x z:exp
#endif
float saturate(float x) {
    return clamp(x, 0., 1.);
vec2 saturate(vec2 x) {
    return clamp(x, vec2(0.), vec2(1.));
vec3 saturate(vec3 x) {
    return clamp(x, vec3(0.), vec3(1.));
vec4 saturate(vec4 x) {
    return clamp(x, vec4(0.), vec4(1.));
vec4 illuminate(SCNShaderSurface surface, SCNShaderLightingContribution lighting)
    vec4 color = vec4(0.,0.,0., surface.diffuse.a);
    
    vec3 D = lighting.diffuse;
#ifdef USE_AMBIENT_LIGHTING
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    D += lighting.ambient * surface.ambientOcclusion;
#elif defined(LOCK_AMBIENT_WITH_DIFFUSE)
    D += lighting.ambient;
#endif
#endif //  defined(USE_AMBIENT_LIGHTING)
#ifdef USE_EMISSION_AS_SELFILLUMINATION
    D += surface.emission.rgb;
#endif
    
    // Do we want to clamp there ????
    
    color.rgb = surface.diffuse.rgb * D;
#if 1 // NEW_REFLECTIVE_BEHAVIOR
#ifdef USE_SPECULAR
    vec3 S = lighting.specular;
#elif defined(USE_REFLECTIVE)
    vec3 S = vec3(0.);
#endif
#ifdef USE_REFLECTIVE
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    S += surface.reflective.rgb * surface.ambientOcclusion;
#else
    S += surface.reflective.rgb;
#endif
#endif
#ifdef USE_SPECULAR
    S *= surface.specular.rgb;
#endif
#if defined(USE_SPECULAR) || defined(USE_REFLECTIVE)
    color.rgb += S;
#endif
#else
#ifdef USE_SPECULAR
    color.rgb += surface.specular.rgb * lighting.specular;
#endif
#ifdef USE_REFLECTIVE
    color.rgb += surface.reflective.rgb * (lighting.diffuse + lighting.ambient);
#endif
#endif // NEW_REFLECTIVE_BEHAVIOR
#if defined(USE_AMBIENT) && !defined(USE_AMBIENT_AS_AMBIENTOCCLUSION)
    color.rgb += surface.ambient.rgb * lighting.ambient;
#endif
#if defined(USE_EMISSION) && !defined(USE_EMISSION_AS_SELFILLUMINATION)
    color.rgb += surface.emission.rgb;
#endif
#ifdef USE_MULTIPLY
    color.rgb *= surface.multiply.rgb;
#endif
#ifdef USE_MODULATE
    color.rgb *= lighting.modulate;
#endif
    return color;
struct SCNOutput
    vec4 color;
} _output;
void main(void)
#ifdef USE_TEXCOORD
    __DoTexcoord__
#endif
    
    _surface.ambientOcclusion = 1.0;
    
    //ambient
#ifdef USE_AMBIENT_MAP
    _surface.ambient = texture2D(u_ambientTexture, _surface.ambientTexcoord);
#ifdef USE_AMBIENT_INTENSITY
#ifdef USE_AMBIENT_AS_AMBIENTOCCLUSION
    _surface.ambientOcclusion = mix(1., _surface.ambient.r, u_ambientIntensity);
#else
    _surface.ambient *= u_ambientIntensity;
#endif
#endif
#elif defined(USE_AMBIENT_COLOR)
    _surface.ambient = u_ambientColor;
#elif defined(USE_AMBIENT)
    _surface.ambient = vec4(0.);
#endif
#if defined(USE_AMBIENT) && defined(USE_VERTEX_COLOR)
    _surface.ambient *= v_vertexColor;
#endif
    
    //diffuse
#ifdef USE_DIFFUSE_MAP
    _surface.diffuse = texture2D(u_diffuseTexture, _surface.diffuseTexcoord);
#ifdef USE_DIFFUSE_INTENSITY
    _surface.diffuse.rgb *= u_diffuseIntensity;
#endif
#elif defined(USE_DIFFUSE_COLOR)
    _surface.diffuse = u_diffuseColor;
#elif defined(USE_DIFFUSE)
    _surface.diffuse = vec4(0.,0.,0.,1.);
#endif
#if defined(USE_DIFFUSE) && defined(USE_VERTEX_COLOR)
    _surface.diffuse *= v_vertexColor;
#endif
    
    //specular
#ifdef USE_SPECULAR_MAP
    _surface.specular = texture2D(u_specularTexture, _surface.specularTexcoord);
#ifdef USE_SPECULAR_INTENSITY
    _surface.specular *= u_specularIntensity;
#endif
#elif defined(USE_SPECULAR_COLOR)
    _surface.specular = u_specularColor;
#elif defined(USE_SPECULAR)
    _surface.specular = vec4(0.);
#endif
    
    //emission
#ifdef USE_EMISSION_MAP
    _surface.emission = texture2D(u_emissionTexture, _surface.emissionTexcoord);
#ifdef USE_EMISSION_INTENSITY
    _surface.emission *= u_emissionIntensity;
#endif
#elif defined(USE_EMISSION_COLOR)
    _surface.emission = u_emissionColor;
#elif defined(USE_EMISSION)
    _surface.emission = vec4(0.);
#endif
    
    //multiply
#ifdef USE_MULTIPLY_MAP
    _surface.multiply = texture2D(u_multiplyTexture, _surface.multiplyTexcoord);
#ifdef USE_MULTIPLY_INTENSITY
    _surface.multiply = mix(vec4(1.), _surface.multiply, u_multiplyIntensity);
#endif
#elif defined(USE_MULTIPLY_COLOR)
    _surface.multiply = u_multiplyColor;
#elif defined(USE_MULTIPLY)
    _surface.multiply = vec4(1.);
#endif
    
    //transparent
#ifdef USE_TRANSPARENT_MAP
    _surface.transparent = texture2D(u_transparentTexture, _surface.transparentTexcoord);
#ifdef USE_TRANSPARENT_INTENSITY
    _surface.transparent *= u_transparentIntensity;
#endif
#elif defined(USE_TRANSPARENT_COLOR)
    _surface.transparent = u_transparentColor;
#elif defined(USE_TRANSPARENT)
    _surface.transparent = vec4(1.);
#endif
    
    //normal
#if (defined USE_NORMAL) && (USE_NORMAL == 2)
#ifdef USE_DOUBLE_SIDED
    _surface.normal = normalize(v_normal.xyz) * u_orientationPreserved * ((float(gl_FrontFacing) * 2.0) - 1.0);
#else
    _surface.normal = normalize(v_normal.xyz);
#endif
#endif
#if defined(USE_TANGENT) && (USE_TANGENT == 2)
    _surface.tangent = v_tangent;
#endif
#if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
    _surface.bitangent = v_bitangent;
#endif
#if (defined USE_POSITION) && (USE_POSITION == 2)
    _surface.position = v_position;
#endif
#if (defined USE_VIEW) && (USE_VIEW == 2)
    _surface.view = normalize(-v_position);
#endif
#ifdef USE_NORMAL_MAP
    mat3 ts2vs = mat3(_surface.tangent, _surface.bitangent, _surface.normal);
    _surface._normalTS = texture2D(u_normalTexture, _surface.normalTexcoord).rgb * 2. - 1.;
    // _surface.normal.z = 1. - sqrt(_surface.normal.x * _surface.normal.x + _surface.normal.y * _surface.normal.y);
#ifdef USE_NORMAL_INTENSITY
    _surface._normalTS = mix(vec3(0., 0., 1.), _surface._normalTS, u_normalIntensity);
#endif
    // transform the normal in view space
    _surface.normal.rgb = normalize(ts2vs * _surface._normalTS);
#else
    _surface._normalTS = vec3(0., 0., 0.);
#endif
    
    //reflective
#ifdef USE_REFLECTIVE_MAP
    vec3 refl = reflect( -_surface.view, _surface.normal );
    float m = 2.0 * sqrt( refl.x*refl.x + refl.y*refl.y + (refl.z+1.0)*(refl.z+1.0));
    _surface.reflective = texture2D(u_reflectiveTexture,vec2(vec2(refl.x,-refl.y) / m) + 0.5) ;
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_CUBEMAP)
    vec3 refl = reflect( _surface.position, _surface.normal );
    _surface.reflective = textureCube(u_reflectiveTexture, mat3(u_viewToCubeWorld) * refl); // sample the cube map in world space
#ifdef USE_REFLECTIVE_INTENSITY
    _surface.reflective.rgb *= u_reflectiveIntensity;
#endif
#elif defined(USE_REFLECTIVE_COLOR)
    _surface.reflective = u_reflectiveColor;
#elif defined(USE_REFLECTIVE)
    _surface.reflective = vec4(0.);
#endif
#ifdef USE_FRESNEL
    _surface.fresnel = u_fresnel.x + u_fresnel.y * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), u_fresnel.z);
    _surface.reflective *= _surface.fresnel;
#endif
#ifdef USE_SHININESS
    _surface.shininess = u_materialShininess;
#endif
    
    
    
    
#ifdef USE_SURFACE_MODIFIER
// DoSurfaceModifier START
__DoSurfaceModifier__
// DoSurfaceModifier END
#endif
    
    
    // Lighting
#ifdef USE_AMBIENT_LIGHTING
    _lightingContribution.ambient = u_ambientLightColor.rgb;
#elif defined(USE_AMBIENT)
    _lightingContribution.ambient = vec3(0.);
#endif
    
#ifdef USE_LIGHTING
#ifdef USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = vec3(0.);
#ifdef USE_MODULATE
    _lightingContribution.modulate = vec3(1.);
#endif
#ifdef USE_SPECULAR
    _lightingContribution.specular = vec3(0.);
#endif
    
    __DoLighting__
    
#else // USE_PER_PIXEL_LIGHTING
    _lightingContribution.diffuse = v_diffuse;
#ifdef USE_SPECULAR
    _lightingContribution.specular = v_specular;
#endif
#endif
    
    
#ifdef AVOID_OVERLIGHTING
    _lightingContribution.diffuse = clamp(_lightingContribution.diffuse, vec3(0.), vec3(1.));
#ifdef USE_SPECULAR
    _lightingContribution.specular = clamp(_lightingContribution.specular, vec3(0.), vec3(1.));
#endif // USE_SPECULAR
#endif // AVOID_OVERLIGHTING
#else // USE_LIGHTING
    _lightingContribution.diffuse = vec3(1.);
#endif // USE_LIGHTING
    
    // Combine
    _output.color = illuminate(_surface, _lightingContribution);
    
#ifdef USE_FOG
    float fogFactor = pow(clamp(length(_surface.position.xyz) * u_fogParameters.x + u_fogParameters.y, 0., u_fogColor.a), u_fogParameters.z);
    _output.color.rgb = mix(_output.color.rgb, u_fogColor.rgb * _output.color.a, fogFactor);
#endif
    
#ifndef DIFFUSE_PREMULTIPLIED
    _output.color.rgb *= _surface.diffuse.a;
#endif
    
#ifdef USE_TRANSPARENT // Either a map or a color
    
#ifdef USE_TRANSPARENCY
    _surface.transparent *= u_transparency;
#endif
    
#ifdef USE_TRANSPARENCY_RGBZERO
#ifdef USE_NODE_OPACITY
    _output.color *= u_nodeOpacity;
#endif
    // compute luminance
    _surface.transparent.a = (_surface.transparent.r * 0.212671) + (_surface.transparent.g * 0.715160) + (_surface.transparent.b * 0.072169);
    _output.color *= (vec4(1.) - _surface.transparent);
#else // ALPHA_ONE
    _output.color *= _surface.transparent.a;
#endif
#else
#ifdef USE_TRANSPARENCY // TRANSPARENCY without TRANSPARENT slot (nodeOpacity + diffuse.a)
    _output.color *= u_transparency;
#endif
#endif
    
#ifdef USE_FRAGMENT_MODIFIER
// DoFragmentModifier START
__DoFragmentModifier__
// DoFragmentModifier END
#endif
    
#ifdef USE_DISCARD
    if (_output.color.a == 0.) // we could set a different limit here
        discard;
#endif
    
    gl_FragColor = _output.color;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
constant bool enableLighting        [[ function_constant(0) ]];
constant bool enableColorRamp       [[ function_constant(1) ]];
constant bool enableCubeMap         [[ function_constant(2) ]];
constant bool enableStretch         [[ function_constant(3) ]];
constant bool enableFog             [[ function_constant(4) ]];
constant bool enableAnimation       [[ function_constant(5) ]];
constant uint orientation           [[ function_constant(6) ]];
constant uint animationMode         [[ function_constant(7) ]];
constant uint blendMode             [[ function_constant(8) ]];
/// Enums
enum {
    kC3DParticleBlendModeAdditive,
    kC3DParticleBlendModeSubtract,
    kC3DParticleBlendModeMultiply,
    kC3DParticleBlendModeScreen,
    kC3DParticleBlendModeAlpha,
    kC3DParticleBlendModeReplace
enum  {
    kC3DParticleOrientationModeBillboardScreenAligned,
    kC3DParticleOrientationModeBillboardViewAligned,
    kC3DParticleOrientationModeFree, 
   // free on all axis
    kC3DParticleOrientationModeBillboardYAligned, // fixed on Y axis
    kC3DParticleOrientationModeAxis 
   // main axis given
constexpr sampler linear_sampler(filter::linear, mip_filter::nearest, address::clamp_to_edge);
static float3x3 axisangle_to_matrix(float4 axis_angle)
    float c;
    float s = sincos(axis_angle.w, c);
    float t = 1. - c;
    
    float3x3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
    float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
static inline float3 arbitrary_tangent(float3 a)
    float3 cross_unit_z = { a.y, -a.x, 0.f };
    float3 cross_unit_x = { 0.f,  a.z,-a.y };
    bool z_is_zero = all(cross_unit_z == (float3)( 0.f ));
    return select(cross_unit_z, cross_unit_x, z_is_zero);
constexpr sampler anim_sampler(filter::linear, mip_filter::nearest, address::repeat);
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
static inline float4 ComputeUVS(float2 iNormUV, float iFrame, float4 iFrameSize)
    float4 outUV;
    
    switch (animationMode)
    {
        case CLAMP:
        {
            iFrame = clamp(iFrame, 0., iFrameSize.w - 1.); // clamp frame
            
            float intFrame;
            float frameFrac = modf(iFrame, intFrame);
            float2 frame;
            float intPart;
            frame.x = modf(intFrame * iFrameSize.x, intPart);
            frame.y = intPart * iFrameSize.y;
            
            outUV.xy = frame + iNormUV * iFrameSize.xy;
            outUV.w = frameFrac;
            outUV.z = step(0.9999, frame.x + iFrameSize.x); // next row or not
        } break;
         
        case REPEAT:
        {
            float tmp = iFrame * iFrameSize.x;
            
            float2 frame;
            frame.y = tmp - fract(tmp);
            frame.x = fract(tmp) * iFrameSize.z;
            
            float frameFrac = fract(frame.x);
            frame.x -= frameFrac;
            
            outUV.xy = (frame + iNormUV) * iFrameSize.xy;
            outUV.w = frameFrac;
            outUV.z = (frame.x == (iFrameSize.z - 1.))?1.:0.; // next row or not
        } break;
            
        default: // AUTOREVERSE
        {
            float invFrameCount = iFrameSize.x * iFrameSize.y;
            float normFrame = iFrame * invFrameCount;
            float lastFrame = iFrameSize.w - 1.;
            float frameIndex = fract(normFrame) * iFrameSize.w;
            if (fract(normFrame * 0.5) > 0.5) {
                frameIndex = (lastFrame-frameIndex);
            }
            
            frameIndex = clamp(frameIndex, 0., lastFrame); // clamp frame
            
            float tmp = frameIndex * iFrameSize.x;
            
            float2 frame;
            frame.y = tmp - fract(tmp);
            
            frame.x = fract(tmp) * iFrameSize.z;
            
            float frameFrac = fract(frame.x);
            frame.x -= frameFrac;
            
            outUV.xy = (frame + iNormUV) * iFrameSize.xy;
            
            outUV.w = frameFrac;
            outUV.z = (frame.x == (iFrameSize.z - 1.))?1.:0.; // next row or not
        }
    }
    return outUV;
typedef struct {
    // vertex data
    float2 texCoord1 [[attribute(SCNVertexSemanticTexcoord1)]]; // x:cornerX y:cornerY
    
    // instance data
    float4 position [[attribute(SCNVertexSemanticPosition)]]; // xyz: position, w:angle
    float3 texCoord0 [[attribute(SCNVertexSemanticTexcoord0)]]; // x:life y:size z:frame (texture animation)
    float4 color [[attribute(SCNVertexSemanticColor)]]; // particle color
    // only valid if enableStretch or orientationFree
    float4 texCoord2 [[attribute(SCNVertexSemanticTexcoord2)]]; // velocity of the particle in .xyz
} particle_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float4 vertexColor;
    float3 uv0;
    float2 uv1;
    float fogFactor;
    
    float3 normal;
} particle_io;
typedef struct {
    float4x4 viewTransform; // this should contain only the viewTransform if part are in world space or modelViewTransform otherwise
    float u_fresnelExponent;
    float u_stretchFactor;
    // enableLighting
    float3 u_lightPosition0; // in modelViewSpace already
    float4 u_lightColor0;
    float4 u_frameSize; // 1/dimX, 1/dimY, dimX, dimX*dimY
} particle_uniforms;
vertex particle_io uberparticle_vert(particle_vertex_t in               [[ stage_in ]],
                                 texture2d<float> u_colorRamp           [[texture(0)]],
                                 constant SCNSceneBuffer& scn_frame     [[buffer(0)]],
                                 constant particle_uniforms& scn_part   [[buffer(1)]])
    particle_io out;
    
    // transform the particle in view space
    float4 viewPos = scn_part.viewTransform * float4(in.position.xyz, 1);
    float3 N; // used for lighting and cubemaps
    
    if (enableStretch) {
        
        // compute the trail direction in viewSpace
        float4 viewDir = scn_part.viewTransform * float4(in.texCoord2.xyz, 0);
        viewDir *= scn_part.u_stretchFactor;
        
        // move the top vertices to the end of the trail
        viewPos.xyz += (in.texCoord1.y > 0.) ? viewDir.xyz : float3(0.);
        
        // compute the billboarding offsets
        //    float len = length(viewDir.xy);
        //    vec2 u = (len > 0.) ? viewDir.xy/len : vec2(0,1);
        float2 u = normalize(viewDir.xy); // divide by 0 seems to work.. otherwise replace by code commented beneath
        float2 r = float2(-u.y, u.x);
        float2 off = r * in.texCoord1.x + u * in.texCoord1.y ; // offset
        viewPos.xy += off * in.texCoord0.y; // * size
        
        N = normalize(float3(-off.x, -off.y, -2));
        
    } else { // enableStretch
        
        // TODO only rotate if needed (angle != 0)
        float cs;
        float sn = sincos(in.position.w, cs);
        
        // expand the quad corners
        float2 dir = { in.texCoord1.x * cs - in.texCoord1.y * sn,  in.texCoord1.y * cs + in.texCoord1.x * sn };
        dir *= in.texCoord0.y;
        
        switch (orientation) {
            case kC3DParticleOrientationModeAxis:
            case kC3DParticleOrientationModeFree:
            {
                float3x3 mat = float3x3(scn_part.viewTransform[0].xyz, scn_part.viewTransform[1].xyz, scn_part.viewTransform[2].xyz);
                
                if (orientation == kC3DParticleOrientationModeFree) {
                    mat = mat * axisangle_to_matrix(in.texCoord2); // mat3(viewTransform)
                } else {
                    float3 zDir = in.texCoord2.xyz;
                    float3 tgt = arbitrary_tangent( zDir );
                    float3x3 m = {
                        tgt,
                        cross( zDir, tgt ),
                        zDir
                    };
                    mat = mat * m; // mat3(viewTransform)
                }
                
                
                if (enableCubeMap) {
                    N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
                    viewPos.xy += dir;
                } else {
                    N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
                    
                    float3 off = mat[0] * dir.x + mat[1] * dir.y;
                    viewPos.xyz += off;
                }
                
                // TODO we should also tranform the normal for the lighting !!!!!
            } break;
                
            case kC3DParticleOrientationModeBillboardViewAligned:
            {
                float3 u = float3(0,1,0);
                float3 r = normalize(cross(u, -viewPos.xyz));
                float3 off = dir.x * r + dir.y * u;
                viewPos.xyz += off;
                N = normalize(float3(-off.x/in.texCoord0.y, -off.y/in.texCoord0.y, -2));
            } break;
                
            case kC3DParticleOrientationModeBillboardYAligned:
            {
                float3 u = (scn_part.viewTransform * float4(0, 1, 0, 0)).xyz;
                float3 r = normalize(cross(u, float3(0,0,1))); // Screen Aligned
                //    vec3 r = normalize(cross(u, -viewPos.xyz)); // ViewAligned
                float3 off = dir.x * r + dir.y * u;
                viewPos.xyz += off;
                N = normalize(float3(-off.x/in.texCoord0.y, -off.y/in.texCoord0.y, -2));
            } break;
                
            default: // ScreenAligned
            {
                viewPos.xy += dir;
                N = normalize(float3(-dir.x, -dir.y, -2));
            } break;
        }
    } // enableStretch
    
    if (enableCubeMap) {
        if (orientation == kC3DParticleOrientationModeFree)
            out.normal.xyz = N;
        else {
            float3 refl = reflect( viewPos.xyz, N );
            out.normal.xyz = scn::mat4_mult_float3(scn_frame.viewToCubeTransform, refl);
        }
    }
    
    if (enableColorRamp) {
        constexpr sampler ramp_sampler(filter::linear, mip_filter::none, address::clamp_to_edge);
        out.vertexColor = in.color * u_colorRamp.sample(ramp_sampler, in.texCoord0.xx);
    } else {
        // use vertex color (OPTIM : use constant color if not varying)
        out.vertexColor = in.color;
    }
    
#ifndef ENABLE_BLACKPASS
    if (enableLighting) {
        float3 L = normalize(viewPos.xyz - scn_part.u_lightPosition0);
        
        if ((orientation == kC3DParticleOrientationModeFree) && !enableCubeMap) {
            // if we want to bend the normal (but free orientation doesn't need too right ?)
            // vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? -normalize(-mat[2] + 0.1 * off) : -normalize(mat[2] + 0.1 * off);
            //    vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? mat[2] : -mat[2];
            
            // simple lambertian + back light diffusion
            float NdotL = dot(N, L);
            //    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * max(0., -NdotL));
            float3 diff = scn_part.u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
            
            // Specular
            float _shininess = 100.0;
            float3 halfVector = normalize(L + viewPos.xyz);
            float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
            out.vertexColor.rgb = out.vertexColor.rgb * diff + spec;
        } else {
            // simple lambertian
            float3 diff = float3(max(0.0, dot(N, L))) * scn_part.u_lightColor0.rgb;
            
            // trilight model (lambertian + wrap around + hemispheric)
            //vec3 diff = lightColor0 * max(0., NdotL) + lightColor1 * (1. - abs(NdotL)) + lightColor2 * max(0., -NdotL);
            
            // todo : support ambient !!!!!!!!!!
            // diff += vec3(0.5);
            
            out.vertexColor.rgb *= diff;
        }
    }
#endif // ENABLE_BLACKPASS
    
    // TexCoord
    if (enableAnimation) {
        float4 animUVS = ComputeUVS(in.texCoord1.xy * float2(0.5, -0.5) + 0.5, in.texCoord0.z, scn_part.u_frameSize);
        out.uv0 = animUVS.xyw;
        out.uv1 = animUVS.xy + scn_part.u_frameSize.xy * float2(1.0, animUVS.z);// + float2(-animUVS.z, 0); add this if you don't want wrap behavior in the sampler
    } else {
        out.uv0.xy = in.texCoord1.xy * float2(0.5, -0.5) + 0.5;
    }
    
#ifndef ENABLE_BLACKPASS
    if (enableFog) {
        float fogFactor = pow(clamp(abs(viewPos.z) * scn_frame.fogParameters.x + scn_frame.fogParameters.y, 0.0, scn_frame.fogColor.a), scn_frame.fogParameters.z);
        switch (blendMode) {
            case kC3DParticleBlendModeMultiply:
            case kC3DParticleBlendModeAlpha:
                out.fogFactor = fogFactor;
                break;
            case kC3DParticleBlendModeReplace:
                out.vertexColor.rgb = mix(out.vertexColor.rgb, scn_frame.fogColor.rgb, fogFactor);
                break;
            case kC3DParticleBlendModeAdditive:
            case kC3DParticleBlendModeSubtract:
            case kC3DParticleBlendModeScreen:
                out.vertexColor.rgb *= (1 - fogFactor);
                break;
        }
    } // enableFog
#endif // ENABLE_BLACKPASS
    
    out.position = scn_frame.projectionTransform * viewPos;
    return out;
// Fragment shader function
fragment half4 uberparticle_frag(particle_io in [[stage_in]],
                                 constant particle_uniforms& pass       [[buffer(0)]],
                                 constant SCNSceneBuffer& scn_frame     [[buffer(1)]],
                                 texture2d<float> u_textureSampler0     [[texture(0)]]
                             )
    float4 tex;
    if (enableAnimation) { // blend between two frames
        tex = mix(u_textureSampler0.sample(anim_sampler, in.uv0.xy),
                         u_textureSampler0.sample(anim_sampler, in.uv1.xy), in.uv0.z);
    } else {
        tex = u_textureSampler0.sample(linear_sampler, in.uv0.xy);
    }
    float4 fragColor = in.vertexColor * tex; // texture and colors need to be premultiplied
    if (enableFog) {
        
        switch(blendMode) {
            case kC3DParticleBlendModeAlpha:
                fragColor.rgb = mix(fragColor.rgb, scn_frame.fogColor.rgb * fragColor.a, in.fogFactor); // fog needs to be premultiplied too
                break;
            case kC3DParticleBlendModeMultiply:
                fragColor.rgb = mix(fragColor.rgb, float3(1), in.fogFactor);
                break;
        }
    }
    return half4(fragColor);
fragment half4 uberparticleCube_frag(particle_io in [[stage_in]],
                                 constant particle_uniforms& pass       [[buffer(0)]],
                                 constant SCNSceneBuffer& scn_frame     [[buffer(1)]],
                                 texturecube<float> u_textureSampler0   [[texture(0)]]
                                 )
    float2 p = in.uv0.xy * 2. - 1.;
    float r = dot(p,p); // len^2
    //    vec4 tex = vec4(normalize(v_normal.xyz), 1.) * step(r, 1.);
    float4 tex = u_textureSampler0.sample(linear_sampler, in.normal.xyz) * saturate(9.6 - 10. * r);
    // fresnel modulation
    tex.rgb *= pow(r, pass.u_fresnelExponent);
    
    float4 fragColor;
    fragColor.a = in.vertexColor.a * tex.a; // texture and colors need to be premultiplied
    
    if (enableFog) {
        fragColor.rgb = mix(in.vertexColor.rgb + tex.rgb, scn_frame.fogColor.rgb, in.fogFactor) * fragColor.a; // texture and colors need to be premultiplied
    } else {
        fragColor.rgb = (in.vertexColor.rgb + tex.rgb) * fragColor.a; // texture and colors need to be premultiplied
    }
    return half4(fragColor);
#import <metal_stdlib>
using namespace metal;
#ifndef MAX_SAMPLE
#define MAX_SAMPLE 1
#endif
#ifndef CASCADE_COUNT
#define CASCADE_COUNT 1
#endif
// #define DEBUG_CASCADES
#define ENABLE_CASCADE_BLENDING
#ifndef TARGET_OS_IPHONE
#ifdef SPOT_SHADOW
#define USE_SPOT_ATTENUATION 1
#else
#define USE_SPOT_ATTENUATION 0
#endif
#else
#define USE_SPOT_ATTENUATION 0
#endif
constexpr sampler shadow_sampler(coord::normalized, filter::linear, address::clamp_to_edge, compare_func::greater_equal);
float3 unprojectPoint(float3 screenPos, float4x4 camera_MVP_i);
static inline float _shadow2DProj(depth2d<float> tex, float4 uv)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, uvp.z);
inline float _shadow2DArrayProj(depth2d_array<float> tex, float4 uv, uint slice)
    float3 uvp = uv.xyz / uv.w;
    return tex.sample_compare(shadow_sampler, uvp.xy, slice, uvp.z);
struct shadowMap_io {
    float4 position [[position]];
    float2 texcoord;
struct shadowMap_uniforms {
    float4 u_kernel[MAX_SAMPLE];
    float4x4    viewTransform;
    float4x4    camera_MVP_i;
    float4x4  light_MVP[4];
#if CASCADE_COUNT > 1
    float viewSpaceSplitDistances[CASCADE_COUNT + 1];
#endif
    
    float3  u_lightPos;
    float3  u_lightDir;
    float3  u_lightSpotAtt;
    float shadowRadius;
    float4 shadowColor;
vertex shadowMap_io shadowMap_vert(uint v_id [[ vertex_id ]])
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    shadowMap_io out;
    out.position = in_position;
    out.texcoord = in_position.xy * float2(0.5, -0.5) + 0.5;
    return out;
// Fragment shader function
float3 unprojectPoint(float3 screenPos, float4x4 camera_MVP_i)
    float4 pTmp;
    
    pTmp.xy = (2.0 * screenPos.xy) - 1.0;
    pTmp.z = screenPos.z;
    pTmp.w = 1.0;
    
    pTmp = camera_MVP_i * pTmp;
    pTmp /= pTmp.w;
    
    return pTmp.xyz;
static inline float rect(float2 lt, float2 rb, float2 uv)
    float2 borders = step(lt, uv) * step(uv, rb);
    return borders.x * borders.y;
inline half4 debugColorForCascade(int cascade)
    switch (cascade) {
        case 0:
            return half4(1.h, 0.h, 0.h, 1.h);
        case 1:
            return half4(0.9, 0.5, 0., 1.);
        case 2:
            return half4(1., 1., 0., 1.);
        case 3:
            return half4(0., 1., 0., 1.);
        default:
            return half4(0., 0., 0., 1.);
    }
inline float grid(float2 lt, float2 rb, float2 gridSize, float thickness, float2 uv)
    float insideRect = rect(lt, rb + thickness, uv);
    float2 gt = thickness * gridSize;
    uv = fract(uv * gridSize);
    float2 lines = step(abs(lt - uv), gt);
    return insideRect * (lines.x + lines.y);
fragment half4 shadowMap_frag(shadowMap_io in [[stage_in]],
                              texture2d<float> colorSampler [[texture(0)]],
                              depth2d<float> depthSampler [[texture(1)]],
#if CASCADE_COUNT > 1
                              depth2d_array<float> lightDepthSampler [[texture(2)]],
#else
                              depth2d<float> lightDepthSampler [[texture(2)]],
#endif
                              constant shadowMap_uniforms& uniforms [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    
    //get color (no blur mode)
    float4 color = colorSampler.sample(samp, in.texcoord);
    
    //get z (need a bias on the read z value....)
//    float depthValue = depthSampler.sample(samp, in.texcoord) - 0.00001;
    float depthValue = depthSampler.sample(samp, in.texcoord);
    if (depthValue >= 1.f) // do not touch pixels without colors (OPTIM should use stencil)
        return half4(color);
    
    //unproject to get world position
    float3 worldPos = unprojectPoint(float3(in.texcoord.x, 1. - in.texcoord.y, depthValue), uniforms.camera_MVP_i);
#if 0
    float2 projNDC = abs((lightScreen.xy / lightScreen.w) * 2.f - 1.f);
    if (projNDC.x > 1.)
        return half4(0., 1., 0., 1.);
    
    if (projNDC.y > 1.)
        return half4(0., 0., 1., 1.);
    
    if ((lightScreen.z / lightScreen.w) > 1.)
        return half4(0., 1., 1., 1.);
    
    if ((lightScreen.z / lightScreen.w) < 0.)
        return half4(1., 1., 0., 1.);
#endif
    // compute spot attenuation ---------------------------------------------------------------------------------------------
#if USE_SPOT_ATTENUATION
    float3 lightToFragment = normalize(uniforms.u_lightPos - uniforms.worldPos);
    
    // TODO we should also consider also distance attenuation and GOBO...
    float att;
    if (uniforms.u_lightSpotAtt.z == 0.0)
        att = step(uniforms.u_lightSpotAtt.x, dot(uniforms.lightToFragment, uniforms.u_lightDir) + 0.00004);
    else
        att = pow(clamp(dot(uniforms.lightToFragment, uniforms.u_lightDir) * uniforms.u_lightSpotAtt.x + uniforms.u_lightSpotAtt.y, 0.0, 1.0), u_lightSpotAtt.z);
    
    if (att == 0.) {
        return half4(color.rgba);
    }
#endif // USE_SPOT_ATTENUATION
    //-----------------------------------------------------------------------------------------------------------------------
    
#if CASCADE_COUNT > 1
    
#if 1 // Projection Based Split selection
    
    float shadow = 0.f;
    float opacitySum = 0.f;
#ifdef DEBUG_CASCADES
    half4 debugColorSum = 0.f;
#endif
    
    for (uint c = 0; c < CASCADE_COUNT; ++c) {
        
        float4 lightScreen =  uniforms.light_MVP[c] * float4(worldPos, 1.0);
#if 0 // display the zone inside the shadow map
        {
            float2 texPos = lightScreen.xy / lightScreen.w;
            float2 gridSize = float2(lightDepthSampler.get_width(), lightDepthSampler.get_height()) / 32;
            float gd = grid(float2(0.f), float2(1.f), gridSize, 0.005f, texPos);
            color.rgba = mix(float4(debugColorForCascade(c)), color, float4(gd > 0.f));
        }
#endif
        // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
        lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
        
        // move in [-1..1] range
        float2 o = lightScreen.xy * 2.f - 1.f;
        // float2 o = (lightScreen.xy / lightScreen.w) * 2.f - 1.f; // do we need to test after projection ???
#ifdef ENABLE_CASCADE_BLENDING
        const float edge = 0.9f;
        // could also do a smoothstep
        o = 1.f - saturate((abs(o) - edge) / (1.f - edge));
        float opacity = o.x * o.y; //min(o.x, o.y);
#else
        float opacity = step(abs(o.x), 1.f) * step(abs(o.y), 1.f);
#endif
        
        if (opacity > 0.f) { // this cascade should be considered
            float alpha = opacity * (1.f - opacitySum);
#ifdef DEBUG_CASCADES
            {
                float2 texPos = lightScreen.xy / lightScreen.w;
                float2 gridSize = float2(lightDepthSampler.get_width(), lightDepthSampler.get_height()) / 8;
                float gd = grid(float2(0.f), float2(1.f), gridSize, 0.001f, texPos);
                half4 gridCol = mix(debugColorForCascade(c), half4(0.f), half4(gd > 0.f));
                debugColorSum += gridCol * alpha;
            }
#endif
            shadow += _shadow2DArrayProj(lightDepthSampler, lightScreen, c) * alpha;
            opacitySum += alpha;
            
        }
        
        if (opacitySum >= 1.f) // fully opaque shadow (no more blending needed) -> bail out
            break;
    }
    
#ifdef DEBUG_CASCADES
    color.rgba = mix(float4(debugColorSum), color, 0.5);
#endif
    if (opacitySum)
        shadow /= opacitySum; // normalization
    
#else // Distance based selection
    
    // OPTIM : everything should be done in view space, never go through world
    float3 viewPos = (uniforms.viewTransform * float4(worldPos, 1.0)).xyz;
    
    float dist = -viewPos.z;
    
    // return half4(dist / 100.f, 0, 0, 1.f);
    
    float blendDist = 0.1f;
    
    // TODO use split pos to find right cascade
    float shadow = 0.f;
    for (uint c = 0; c < CASCADE_COUNT; ++c) {
        
#if 0 // display the zone inside the shadow map
        {
            float4 lightScreen =  uniforms.light_MVP[c] * float4(worldPos, 1.0);
            float2 texPos = lightScreen.xy / lightScreen.w;
            float2 gridSize = float2(lightDepthSampler.get_width(), lightDepthSampler.get_height()) / 32;
            float gd = grid(float2(0.f), float2(1.f), gridSize, 0.005f, texPos);
            color.rgba = mix(float4(debugColorForCascade(c)), color, float4(gd > 0.f));
        }
#endif
        if (dist < uniforms.viewSpaceSplitDistances[c + 1]) {
#ifdef DEBUG_CASCADES
            color.rgba = mix(float4(debugColorForCascade(c)), color, 0.05);
#endif
            
            //project into light space
            float4 lightScreen =  uniforms.light_MVP[c] * float4(worldPos, 1.0);
            
            // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
            lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
            
            shadow = _shadow2DArrayProj(lightDepthSampler, lightScreen, c);
            // TODO put lastSplitLimit at inifinity
            float blendSplitLength = (uniforms.viewSpaceSplitDistances[c + 1] - uniforms.viewSpaceSplitDistances[c]) * blendDist;
            float blendSplitLimit = uniforms.viewSpaceSplitDistances[c + 1] - blendSplitLength; // OPTIM could be stored
            if (dist > blendSplitLimit) {
                float factor = (dist - blendSplitLimit) / blendSplitLength;
                
#ifdef DEBUG_CASCADES
                color.rgba = mix(color, float4(debugColorForCascade(c+1)), factor);
#endif
                
                //project into light space
                float4 lightScreen =  uniforms.light_MVP[c + 1] * float4(worldPos, 1.0);
                
                // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
                lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
                
                shadow = mix(shadow, _shadow2DArrayProj(lightDepthSampler, lightScreen, c + 1), factor);
            }
            break;
        }
    }
    
#endif Projection Based Split selection
    
#else // CASCADE_COUNT > 1
    
    //project into light space
    float4 lightScreen =  uniforms.light_MVP[0] * float4(worldPos, 1.0);
    
    // ensure receiver after the shadow projection box are not in shadow (when no caster == 1. instead of infinite)
    lightScreen.z = min(lightScreen.z, 0.9999f * lightScreen.w);
#if MAX_SAMPLE == 1
    float shadow = _shadow2DProj(lightDepthSampler, lightScreen);
#else
    // penumbra
    float filteringSizeFactor = uniforms.shadowRadius * lightScreen.w;//(distLight - lightDepth)*shadowRadius / lightDepth ;
    
    //smooth all samples
    float totalAccum = 0.0;
    for(int i=0; i < MAX_SAMPLE; i++){
        totalAccum += _shadow2DProj(lightDepthSampler, lightScreen + (uniforms.u_kernel[i] * filteringSizeFactor));
    }
    
//    float shadow = totalAccum;
    float shadow = totalAccum / float(MAX_SAMPLE);
#endif
    
#if !USE_SPOT_ATTENUATION
    shadow *= step(0., lightScreen.w);
#endif
#endif // CASCADE_COUNT > 1
    
    
    //    vec2 clamp = step(lightScreen.xy * lightScreen.xy, vec2(1.));
    //    shadow *= clamp.x * clamp.y;
    shadow *= uniforms.shadowColor.a;
#if USE_SPOT_ATTENUATION
    shadow = shadow * att;
#endif
    
    //apply shadow on color buffer
    return half4(mix(color.rgba, float4(uniforms.shadowColor.rgb, 1.0),  shadow));
uniform sampler2D colorBuffer;
uniform sampler2D outlineColorBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    float alpha = 0.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
    {
        alpha += texture2D(outlineColorBuffer, uv+vec2(i,j)*u_inverseResolution).r;
    }
    alpha /= 9.;
    
    //Final antialiased mix
    gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(1.,.6,.2,1.), vec4(min(alpha*2.,1.)) );
#import <metal_stdlib>
using namespace metal;
#import "C3D-Background.h"
#import "C3D-PostProcessUtils.h"
#import "scn_util.h"
typedef struct {
    float3 position [[attribute(0)]];
} background_vertex_t;
// MARK: Background - 2D texture
typedef struct {
    float4 position [[position]];
    float2 texcoord;
} background_2D_io;
vertex background_2D_io background_2D_vert(background_vertex_t             in       [[ stage_in ]],
                                           constant background_uniforms_t& uniforms [[ buffer(0) ]])
    float4 in_position = float4(in.position, 1.0);
    
    background_2D_io out;
    out.position = in_position;
    out.texcoord = (uniforms.modelViewProjectionTransform * in_position).xy * float2(0.5, -0.5) + 0.5;
    return out;
vertex background_2D_io background_2D_vertid(constant background_uniforms_t& uniforms [[ buffer(0) ]],
                                             uint                            v_id     [[ vertex_id ]])
    float4 in_position = scn::draw_quad_pos_from_id(v_id, 1.0);
    
    background_2D_io out;
    out.position = in_position;
    out.texcoord = (uniforms.modelViewProjectionTransform * in_position).xy * float2(0.5, -0.5) + 0.5;
    return out;
fragment half4 background_2D_frag(background_2D_io in    [[ stage_in ]],
                                  texture2d<float> tex2D [[ texture(0) ]],
                                  sampler          samp  [[ sampler(0) ]])
    float4 color = tex2D.sample(samp, in.texcoord);
    return half4(color);
// MARK: Background - Cube texture
typedef struct {
    float4 position [[position]];
    float3 texcoord;
} background_cube_io;
vertex background_cube_io background_cube_vert(background_vertex_t             in       [[ stage_in ]],
                                               constant background_uniforms_t& uniforms [[ buffer(0) ]])
    float4 in_position = float4(in.position, 1.0);
    
    background_cube_io out;
    out.position = (uniforms.modelViewProjectionTransform * in_position);
    out.texcoord = scn::mat4_mult_float3(uniforms.viewToCubeTransform, in_position.xyz);
    return out;
vertex background_cube_io background_cube_vertid(constant background_uniforms_t& uniforms [[ buffer(0) ]],
                                                 uint                            v_id     [[ vertex_id ]])
    float4 in_position;
    // generate cube vertices
    in_position.x = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id / 4) * 2.0 - 1.0;
    in_position.z = (float)((v_id % 4) / 2) * 2.0 - 1.0;
    in_position.w = 1.0;
    
    // need to rescale the cube
    in_position.xyz *= uniforms.zfar;
    
    background_cube_io out;
    out.position = (uniforms.modelViewProjectionTransform * in_position);
    out.texcoord = scn::mat4_mult_float3(uniforms.viewToCubeTransform, in_position.xyz);
    out.position.z = out.position.w * 0.999998; // we have to scale a little due to float imprecisions (zb~=1)
    return out;
fragment half4 background_cube_frag(background_cube_io in      [[ stage_in ]],
                                    texturecube<float> texCube [[ texture(0) ]],
                                    sampler            samp    [[ sampler(0) ]])
    float4 color = texCube.sample(samp, in.texcoord);
    return half4(color);
// MARK: Background - Video (2D texture)
typedef struct {
    float4 position [[position]];
    float2 texcoord;
} background_video_io;
vertex background_video_io background_video_vertid(constant background_video_uniforms_t& uniforms [[ buffer(0) ]],
                                                   uint                                  v_id     [[ vertex_id ]])
    background_video_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texcoord = uniforms.texcoords[v_id];
    return out;
fragment half4 background_video_frag(background_video_io in    [[ stage_in ]],
                                     texture2d<float>    tex2D [[ texture(0) ]],
                                     sampler             samp  [[ sampler(0) ]])
    float4 color = tex2D.sample(samp, in.texcoord);
    return half4(color);
uniform sampler2D textureSampler0;
uniform sampler2D textureSampler1;
uniform float factor;
varying vec2 TexCoord;
void main (void)
    vec4 newFragment = texture2D(textureSampler0,TexCoord);
    vec4 oldColor = texture2D(textureSampler1,TexCoord);
    
    gl_FragColor = (factor-1.0)*(oldColor/factor) + newFragment/factor;
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers // GL_ES 2
#extension GL_EXT_shadow_samplers : require
#endif
#endif
#if MAX_SAMPLE > 1
uniform vec4 u_kernel[MAX_SAMPLE];
#endif
uniform vec4 shadowColor;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
#ifdef USE_PCF
#ifdef GL_EXT_shadow_samplers // GL_ES 2
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProjEXT( tex, coord )
#elif __VERSION__ <= 120 // GL Compatibility Profile
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) shadow2DProj( tex, coord ).x
#else // GL Core Profile or GL_ES 3
    uniform sampler2DShadow lightDepthSampler;
    #define __shadow2DProj(tex,coord) textureProj( tex, coord )
#endif
#else // NO PCF
    uniform sampler2D lightDepthSampler;
    #define __shadow2DProj(tex, coord) clamp(coord.z - texture2DProj(tex, coord).x * coord.w, 0.0, 1.0);
#endif
uniform mat4  camera_MVP_i;
uniform mat4  light_MVP;
uniform vec3  u_lightPos;
uniform vec3  u_lightDir;
uniform vec3  u_lightSpotAtt;
uniform float shadowRadius;
// shadow spot attenuation
#ifndef TARGET_OS_IPHONE
    #ifdef SPOT_SHADOW
        #define USE_SPOT_ATTENUATION 1
    #else
        #define USE_SPOT_ATTENUATION 0
    #endif
#else
    #define USE_SPOT_ATTENUATION 0
#endif
varying vec2 TexCoord;
vec3 unprojectPoint(vec3 screenPos)
vec4 pTmp;
    pTmp.xyz = (2.0 * screenPos.xyz) - 1.0;
pTmp.w = 1.0;
pTmp = camera_MVP_i * pTmp;
    pTmp /= pTmp.w;
return vec3(pTmp);
void main (void)
    //get color (no blur mode)
    vec4 color = texture2D(colorSampler, TexCoord);
    
//get z
float depthValue = texture2D(depthSampler, TexCoord).x;
//unproject to get world position
vec3 worldPos = unprojectPoint(vec3(TexCoord, depthValue));
//project into light space
vec4 lightScreen =  light_MVP * vec4(worldPos, 1.0);
    
    // compute spot attenuation ---------------------------------------------------------------------------------------------
#if USE_SPOT_ATTENUATION
    vec3 lightToFragment = normalize(u_lightPos - worldPos);
    
    // TODO we should also consider also distance attenuation and GOBO...
    float att;
    if (u_lightSpotAtt.z == 0.0)
        att = step(u_lightSpotAtt.x, dot(lightToFragment, u_lightDir) + 0.00004);
    else
        att = pow(clamp(dot(lightToFragment, u_lightDir) * u_lightSpotAtt.x + u_lightSpotAtt.y, 0.0, 1.0), u_lightSpotAtt.z);
    
    if (att == 0.) {
        gl_FragColor = color.rgba;
        return;
    }
#endif // USE_SPOT_ATTENUATION
    //-----------------------------------------------------------------------------------------------------------------------
    
#if MAX_SAMPLE == 1
    float shadow = __shadow2DProj(lightDepthSampler, lightScreen);
#else
    // penumbra
    float filteringSizeFactor = shadowRadius * lightScreen.w;//(distLight - lightDepth)*shadowRadius / lightDepth ;
    
    //smooth all samples
    float totalAccum = 0.0;
    for(int i=0; i<MAX_SAMPLE; i++){
        totalAccum += __shadow2DProj(lightDepthSampler, lightScreen + (u_kernel[i] * filteringSizeFactor));
    }
    
    float shadow = totalAccum / float(MAX_SAMPLE);
#endif
    
#if !USE_SPOT_ATTENUATION
    shadow *= step(0., lightScreen.w);
#endif
    
    //    vec2 clamp = step(lightScreen.xy * lightScreen.xy, vec2(1.));
    //    shadow *= clamp.x * clamp.y;
    shadow *= shadowColor.a;
#if USE_SPOT_ATTENUATION
    shadow = shadow * att;
#endif
    
    //apply shadow on color buffer
    gl_FragColor = mix(color.rgba, vec4(shadowColor.rgb, 1.0),  shadow);
#import <metal_stdlib>
#import <metal_compute>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
// for cubemap utilities
#import "C3D-PBR.metal"
// MARK: lat-long to cubemap
kernel void compute_cubemap_from_latlong_views(texture2d<float, access::sample> latlongTexture [[ texture(0) ]],
                                               texture2d<float, access::write>  cubeFace0      [[ texture(1) ]],
                                               texture2d<float, access::write>  cubeFace1      [[ texture(2) ]],
                                               texture2d<float, access::write>  cubeFace2      [[ texture(3) ]],
                                               texture2d<float, access::write>  cubeFace3      [[ texture(4) ]],
                                               texture2d<float, access::write>  cubeFace4      [[ texture(5) ]],
                                               texture2d<float, access::write>  cubeFace5      [[ texture(6) ]],
                                               uint3                            index          [[ thread_position_in_grid ]])
    uint width = cubeFace0.get_width();
    uint height = cubeFace0.get_height();
    if (index.x >= width && index.y >= height)
        return;
    
    constexpr sampler smp = sampler(filter::linear, address::repeat);
    
    uint face = index.z;
    
    // uv in [0, 1]
    float2 uv = float2(float(index.x) / float(width - 1),
                       float(index.y) / float(height - 1));
    
    float3 dir = normalize(scn::cubemap_dir_from_uv(face, uv));
    
    float x = atan2(-dir.z, dir.x) / (2.0f * scn::PI);
    float y = acos(dir.y) / scn::PI;
    
    float4 color = latlongTexture.sample(smp, float2(x, y));
    
    switch(face) {
        case 0: cubeFace0.write(color, index.xy); break;
        case 1: cubeFace1.write(color, index.xy); break;
        case 2: cubeFace2.write(color, index.xy); break;
        case 3: cubeFace3.write(color, index.xy); break;
        case 4: cubeFace4.write(color, index.xy); break;
        case 5: cubeFace5.write(color, index.xy); break;
    }
#if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
kernel void compute_cubemap_from_latlong(texture2d<float, access::sample>  latlongTexture [[ texture(0) ]],
                                         texturecube<float, access::write> texture        [[ texture(1) ]],
                                         uint3                             index          [[ thread_position_in_grid ]])
    uint width = texture.get_width();
    uint height = texture.get_height();
    if (index.x >= width && index.y >= height)
        return;
    
    constexpr sampler smp = sampler(filter::linear, address::repeat);
    
    uint face = index.z;
    
    // uv in [0, 1]
    float2 uv = float2(float(index.x) / float(width - 1),
                       float(index.y) / float(height - 1));
    
    float3 dir = normalize(scn::cubemap_dir_from_uv(face, uv));
    
    float x = atan2(-dir.z, dir.x) / (2.0f * scn::PI);
    float y = acos(dir.y) / scn::PI;
    
    float4 color = latlongTexture.sample(smp, float2(x, y));
    texture.write(color, index.xy, face);
#endif // __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
// MARK: cubemap to lat-long
kernel void compute_latlong_from_cubemap(texturecube<float, access::sample> cubemap        [[ texture(0) ]],
                                         texture2d<float, access::write>    latlongTexture [[ texture(1) ]],
                                         uint2                              index          [[ thread_position_in_grid ]])
    constexpr sampler smp = sampler(filter::linear, address::repeat);
    
    // uv in [0, 1]
    float2 uv = float2(float(index.x) / float(latlongTexture.get_width() - 1),
                       float(index.y) / float(latlongTexture.get_height() - 1));
    
    float theta = uv.y * scn::PI;
    float phi   = uv.x * 2.0f * scn::PI;
    
    float x = cos(phi) * sin(theta);
    float y = cos(theta);
    float z = sin(phi) * sin(theta);
    
    float4 color = cubemap.sample(smp, float3(x, y, -z));
    latlongTexture.write(color, index.xy);
uniform sampler2D sceneColor;
uniform sampler2D authoringColor;
uniform sampler2D sceneDepth;
uniform sampler2D authoringDepth;
varying vec2 uv;
void main()
    vec4 scene = texture2D(sceneColor, uv);
    vec4 authoring = texture2D(authoringColor, uv);
    float scene_depth = texture2D(sceneDepth, uv).r;
    float authoring_depth = texture2D(authoringDepth, uv).r;
    if(scene_depth < authoring_depth){
        authoring.rgb *= 0.75;
//        authoring.rgb = mix(authoring.rgb, vec3(dot(authoring.rgb, authoring.rgb)), 0.5);
    }
    
    gl_FragColor = mix(scene, authoring, authoring.a);
attribute vec3 a_position;
uniform mat4 u_mvp;
uniform float u_zfar;
varying vec3 TexCoord;
void main()
gl_Position = (u_mvp * vec4(a_position * u_zfar, 1.)).xyww;
//gl_Position = u_mvp * vec4(a_position, 1.);
//gl_Position.z = gl_Position.w*0.9999;
TexCoord = vec3(a_position.x, a_position.y, -a_position.z);
// dir.y *= -1.0;
attribute vec3 a_position;
uniform mat4 u_m;
varying vec2 TexCoord;
void main(void)
gl_Position = u_m * vec4(a_position, 1.0);
TexCoord = (gl_Position.xy + 1.0) * 0.5;
#import <metal_stdlib>
using namespace metal;
#import "C3D-SuperSampling.h"
#import "C3D-PostProcessUtils.h"
vertex scn::draw_quad_io_t scn_supersampling_vertex(uint                                v_id [[ vertex_id ]],
                                                    constant scn_supersampling_parameter&  uni  [[ buffer(0)  ]])
    scn::draw_quad_io_t out;
    
    out.position = scn::draw_quad_pos_from_id(v_id, 0.0);
    out.uv = ( uni.transform * float4(scn::draw_quad_texcoord_from_id(v_id)*2.-1., 0., 0.) ).xy * .5 + .5;
    
    return out;
fragment float4 scn_supersampling_fragment(scn::draw_quad_io_t                   in        [[ stage_in ]],
                                             texture2d<float>                    input_tex [[ texture(0) ]],
                                             constant scn_supersampling_parameter&  uni       [[ buffer(0)  ]])
    constexpr sampler samp(filter::nearest);
    constexpr sampler samp_linear(filter::linear);
    
    float2 res = float2(input_tex.get_width(), input_tex.get_height() );
    
    float s = uni.superSampling/2.-.5;
    float2 uv = (in.uv*res + .5 + s)/res;
    
    return input_tex.sample(samp_linear, uv.xy);
  "sequence" : [
                "SceneKit_renderCINodeTree",
                "SceneKit_ApplyCIFilter",
                "SceneKit_renderCIQuad"
                ],
  "targets" : {
    "SceneKit-CI-nodetree-depth" : {
      "type" : "depth"
    },
    "SceneKit-CI-nodetree-color" : {
      "type" : "color",
      "format" : "rgba",
    },
    "SceneKit-CI-effect-color" : {
      "type" : "color",
      "format" : "rgba",
      "usage" : ["shaderWrite", "shaderRead"]
    }
  },
  "symbols" : {
    "C3D-CIFilter_middleZ" : {
      "type" : "float"
    },
    "C3D-CIFilter_extent" : {
      "type" : "vec4"
    }
  },
  "passes" : {
    "SceneKit_renderCIQuad" : {
      "inputs" : {
        "u_color" : {
          "target" : "SceneKit-CI-effect-color",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_middleZ" : "C3D-CIFilter_middleZ",
        "u_extent" : "C3D-CIFilter_extent",
        "u_depth" : {
          "target" : "SceneKit-CI-nodetree-depth",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        }
      },
      "hasConstantAlpha" : false,
      "colorStates" : {
        "clear" : false
      },
      "depthStates" : {
        "clear" : false
      },
      "cullMode" : "none",
      "metalVertexShader" : "scn_filterCompositeVert",
      "metalFragmentShader" : "scn_filterCompositeFrag",
      "draw" : "none",
      "clientProgram" : false,
      "blendStates" : {
        "enable" : true,
        "colorDst" : "oneMinusSrcAlpha",
        "colorSrc" : "one"
      }
    },
    "SceneKit_ApplyCIFilter" : {
      "outputs" : {
        "color" : "SceneKit-CI-effect-color"
      },
      "inputs" : {
        "myInput1" : "SceneKit-CI-nodetree-color"
      },
      "draw" : "CUSTOM"
    },
    "SceneKit_renderCINodeTree" : {
      "draw" : "DRAW_NODE",
      "node" : "self",
      "ignoreFloors" : true,
      "outputs" : {
        "depth" : "SceneKit-CI-nodetree-depth",
        "color" : "SceneKit-CI-nodetree-color"
      },
      "colorStates" : {
        "clear" : true
      },
      "depthStates" : {
        "clear" : true
      },
      
    }
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
//    v_vertexColor = a_color;
// In model space, must stay in it
struct SCNShaderGeometry
vec4 position;
vec3 normal;
vec4 tangent;
vec4 color;
vec2 texcoords[8]; // MAX_UV
} _geometry;
#import <metal_stdlib>
using namespace metal;
#import "scn_util.h"
#import "C3D-PostProcessUtils.h"
#import "C3D-DrawQuad.h"
vertex scn::draw_quad_io_t scn_draw_fullscreen_quad_vertex(uint v_id [[ vertex_id ]])
    scn::draw_quad_io_t out;
    out.position = scn::draw_quad_pos_from_id(v_id, 0.0);
    out.uv       = scn::draw_quad_texcoord_from_id(v_id);
    return out;
vertex scn::draw_quad_io_t scn_draw_quad_vertex(uint                        v_id  [[ vertex_id ]],
                                                constant draw_quad_frame_t& frame [[ buffer(0) ]])
    scn::draw_quad_io_t out;
    
    out.position = float4(((v_id / 2) * frame.quadSize.x + frame.quadOrigin.x) / frame.drawableSize.x * 2.0 - 1.0,
                          ((v_id % 2) * frame.quadSize.y + frame.quadOrigin.y) / frame.drawableSize.y * 2.0 - 1.0,
                          0.0,
                          1.0);
    
    out.uv = float2(v_id / 2,
                    1 - v_id % 2);
    
    return out;
fragment float4 scn_draw_quad_fragment(scn::draw_quad_io_t in        [[ stage_in ]],
                                       texture2d<float>    input_tex [[ texture(0) ]])
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    return input_tex.sample(linear_sampler, in.uv);
fragment float4 scn_draw_monochrome_quad_fragment(scn::draw_quad_io_t in        [[ stage_in ]],
                                                  texture2d<float>    input_tex [[ texture(0) ]])
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    float color = input_tex.sample(linear_sampler, in.uv).r;
    return float4(color, color, color, 1.0);
fragment half4 scn_draw_quad_fragment_sk(scn::draw_quad_io_t in        [[ stage_in ]],
                                          texture2d<half>    input_tex [[ texture(0) ]])
    constexpr sampler nearest_sampler;
    half4 col = input_tex.sample(nearest_sampler, in.uv);
    
    // spritekit alpha seems to be in gamma space -> need to linearize it
    col.a =  scn::srgb_to_linear_fast(col.a);
    
    return col;
fragment float4 scn_draw_quad_gamma_fragment(scn::draw_quad_io_t in        [[ stage_in ]],
                                             texture2d<float>    input_tex [[ texture(0) ]])
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    float4 col = input_tex.sample(linear_sampler, in.uv);
    col.rgb = scn::srgb_to_linear(col.rgb);
    return col;
// initial geometry is [-1,1] in XY plane (so z is always 0)
  uniform vec3 u_floorNormal;
  uniform vec4 u_floorTangent;
  uniform vec3 u_floorCenter;
  uniform vec2 u_floorExtent;
#pragma body
  vec3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
  _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
  _geometry.normal = u_floorNormal;
  _geometry.tangent = u_floorTangent;
  // we could check if the texCoord are really needed with ifdef USE_xxxx_MAP , or, better, work only on texcoordN [0..1]
  vec2 tc;
  if (u_floorNormal.y != 0.)
    tc = _geometry.position.xz * 0.01;
  else if (u_floorNormal.z != 0.)
    tc = _geometry.position.xy * 0.01;
  else
    tc = _geometry.position.yz * 0.01;
  for (int i = 0; i < kSCNTexcoordCount; ++i)
    _geometry.texcoords[i] = tc;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_downSample4x</string>
<string>SceneKit_DOF_generateNearCoc</string>
<string>SceneKit_DOF_blurCoc_H</string>
<string>SceneKit_DOF_blurCoc_V</string>
<string>SceneKit_blurColor4x_H</string>
<string>SceneKit_blurColor4x_V</string>
<string>SceneKit_DOF_computeNearCoc</string>
<string>SceneKit_DOF_smallBlur</string>
<string>SceneKit_DOF_resolve</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_downSample4x</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-downSample4x</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-downSample4x</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>DownSample4x_vert</string>
<key>metalFragmentShader</key>
<string>DownSample4x_frag</string>
</dict>
<key>SceneKit_DOF_generateNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>target</key>
<string>SceneKit-color-downSample4x</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>depthSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>DEPTH</string>
</dict>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-generateNearCoc</string>
<key>metalVertexShader</key>
<string>GenerateNearCoc_vert</string>
<key>clientProgram</key>
<false/>
<key>metalFragmentShader</key>
<string>GenerateNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_blurCoc_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-nearCoc</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_blurCoc_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>SceneKit_DOF_blurCoc_H_output</string>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_H</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_H_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusH</string>
<key>textureSampler0</key>
<string>SceneKit-color-downSample4x</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_blurColor4x_V</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_blurColor4x_V_output</string>
</dict>
<key>inputs</key>
<dict>
<key>radius</key>
<string>C3D-blur-radiusV</string>
<key>textureSampler0</key>
<string>SceneKit_blurColor4x_H_output</string>
<key>offsets</key>
<string>C3D-blur-offsets</string>
<key>weights</key>
<string>C3D-blur-weights</string>
<key>n_sample</key>
<string>C3D-blur-samples</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>clientProgram</key>
<false/>
</dict>
<key>SceneKit_DOF_computeNearCoc</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
</dict>
<key>inputs</key>
<dict>
<key>downSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit-color-nearCoc</string>
</dict>
<key>blurSampler</key>
<dict>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
<key>target</key>
<string>SceneKit_DOF_blurCoc_V_output</string>
</dict>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-ComputeNearCoc</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ComputeNearCoc_vert</string>
<key>metalFragmentShader</key>
<string>ComputeNearCoc_frag</string>
</dict>
<key>SceneKit_DOF_smallBlur</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<dict>
<key>target</key>
<string>SceneKit_DOF_computeNearCoc-output</string>
<key>sampler</key>
<dict>
<key>minificationFilter</key>
<string>nearest</string>
<key>magnificationFilter</key>
<string>nearest</string>
</dict>
</dict>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Blur5x5</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>Blur5x5_vert</string>
<key>metalFragmentShader</key>
<string>Blur5x5_frag</string>
</dict>
<key>SceneKit_DOF_resolve</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>colorSampler</key>
<string>COLOR</string>
<key>depthSampler</key>
<string>DEPTH</string>
<key>smallBlurSampler</key>
<string>SceneKit_DOF_smallBlur-ouput</string>
<key>largeBlurSampler</key>
<string>SceneKit_blurColor4x_V_output</string>
<key>CocScaleBias</key>
<string>C3D-dof-cocScaleBias</string>
<key>dofLerpScale</key>
<string>C3D-dof-lerpScale</string>
<key>dofLerpBias</key>
<string>C3D-dof-lerpBias</string>
<key>u_inversePixelSize</key>
<string>C3D-dof-invertPixelSize</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-dof-Resolve</string>
<key>clientProgram</key>
<false/>
<key>metalVertexShader</key>
<string>ResolveDOF_vert</string>
<key>metalFragmentShader</key>
<string>ResolveDOF_frag</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-color-downSample4x</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit-color-nearCoc</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_blurCoc_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_blurCoc_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_blurColor4x_H_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_blurColor4x_V_output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_computeNearCoc-output</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
<key>SceneKit_DOF_smallBlur-ouput</key>
<dict>
<key>type</key>
<string>color</string>
<key>scaleFactor</key>
<real>0.25</real>
<key>format</key>
<string>rgba16f</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>C3D-dof-cocScaleBias</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>C3D-dof-invertPixelSize</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>C3D-dof-lerpScale</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-dof-lerpBias</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>C3D-blur-radiusV</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-radiusH</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>C3D-blur-offsets</key>
<dict>
<key>type</key>
<string>vec2[31]</string>
</dict>
<key>C3D-blur-weights</key>
<dict>
<key>type</key>
<string>float[31]</string>
</dict>
<key>C3D-blur-samples</key>
<dict>
<key>type</key>
<string>int</string>
</dict>
</dict>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_renderMirroredScene</string>
<string>SceneKit_renderFloor</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderMirroredScene</key>
<dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>SceneKit-Floor-depth</string>
<key>color</key>
<string>SceneKit-Floor-color</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>SceneKit_renderFloor</key>
<dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<false/>
</dict>
<key>inputs</key>
<dict>
<key>u_floorReflectionDepth</key>
<string>SceneKit-Floor-depth</string>
<key>u_floorReflectionColor</key>
<string>SceneKit-Floor-color</string>
<key>u_floorNormal</key>
<string>u_floorNormal</string>
<key>u_floorTangent</key>
<string>u_floorTangent</string>
<key>u_floorCenter</key>
<string>u_floorCenter</string>
<key>u_floorExtent</key>
<string>u_floorExtent</string>
<key>u_floorReflectivity</key>
<string>u_floorReflectivity</string>
<key>u_floor_viewport</key>
<string>u_floor_viewport</string>
<key>u_floorMVP_i</key>
<string>u_floorMVP_i</string>
<key>u_floorPlane</key>
<string>u_floorPlane</string>
<key>u_floorFalloff</key>
<string>u_floorFalloff</string>
<key>u_floorFalloffStart</key>
<string>u_floorFalloffStart</string>
</dict>
<key>draw</key>
<string>DRAW_GEOMETRY</string>
<key>installViewport</key>
<false/>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>u_floorNormal</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorTangent</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorCenter</key>
<dict>
<key>type</key>
<string>vec3</string>
</dict>
<key>u_floorExtent</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>u_floor_viewport</key>
<dict>
<key>type</key>
<string>vec2</string>
</dict>
<key>u_floorReflectivity</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorMVP_i</key>
<dict>
<key>type</key>
<string>mat4</string>
</dict>
<key>u_floorPlane</key>
<dict>
<key>type</key>
<string>vec4</string>
</dict>
<key>u_floorFalloff</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
<key>u_floorFalloffStart</key>
<dict>
<key>type</key>
<string>float</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>SceneKit-Floor-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
<key>SceneKit-Floor-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba</string>
</dict>
</dict>
</dict>
</plist>
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "C3D-PostProcessUtils.h"
#ifndef MAX_SAMPLE
#define MAX_SAMPLE 32
#endif
struct GaussianBlur_io {
    float4 position [[position]];
    float2 texCoord;
struct GaussianBlur_uniforms {
    float2 offsets[MAX_SAMPLE];
    float weights[MAX_SAMPLE];
    int n_sample;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GaussianBlur
vertex GaussianBlur_io GaussianBlur_vert(
                                         uint v_id [[ vertex_id ]]
                                         )
    GaussianBlur_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 GaussianBlur_frag(
                                 GaussianBlur_io in [[stage_in]],
                                 texture2d<float> textureSampler0 [[texture(0)]],
                                 constant GaussianBlur_uniforms& uniforms [[buffer(0)]]
                                 )
    constexpr sampler samp(filter::linear);
    int i;
    
    float4 accum = float4(0.0);
    
    for (i=0; i < uniforms.n_sample; i++) {
        float4 c = textureSampler0.sample(samp, in.texCoord + uniforms.offsets[i]);
        accum += c * uniforms.weights[i];
    }
    
    return half4(accum);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// GaussianBlurAlpha
vertex GaussianBlur_io GaussianBlurAlpha_vert(
                                                   uint v_id [[ vertex_id ]]
                                                   )
    GaussianBlur_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 GaussianBlurAlpha_frag(
                                      GaussianBlur_io in [[stage_in]],
                                      texture2d<float> textureSampler0 [[texture(0)]],
                                      constant GaussianBlur_uniforms& uniforms [[buffer(0)]]
                                      )
    constexpr sampler samp(filter::linear);
    int i;
    
    float4 accum = float4(0.0);
    float total = 0.0;
    
    for (i=0; i < uniforms.n_sample; i++) {
        float4 c = textureSampler0.sample(samp, in.texCoord + uniforms.offsets[i]);
        c.rgb *= c.a;
        accum += c * uniforms.weights[i];
        total += uniforms.weights[i] * c.a;
    }
    
    accum /= total;
    return half4(accum);
uniform sampler2D downSampler;
uniform sampler2D depthSampler;
uniform vec3 CocScaleBias;
varying vec2 v_texCoord;
void main (void)
    vec4 down = texture2D( downSampler, v_texCoord);
    float depth = texture2D( depthSampler, v_texCoord).r;
    float coc = step(0., (depth * CocScaleBias.x + CocScaleBias.y)); // keep only near coc
gl_FragColor = vec4(down.rgb, coc * down.a);
    // debug
    //gl_FragColor = vec4(depth, 0., 0., 1.);
#extension GL_ARB_shader_texture_lod : enable
uniform sampler2D textureSampler0;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2DLod(textureSampler0,TexCoord, 0.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 1.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 2.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 3.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 4.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 5.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 6.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 7.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 8.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 9.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 10.0);
gl_FragColor +=
texture2DLod(textureSampler0,TexCoord, 11.0);    
    gl_FragColor /= 12.0;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>SceneKit_copy</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_copy</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-Copy</string>
<key>clientProgram</key>
<false/>
<key>inputs</key>
<dict>
<key>textureSampler0</key>
<string>COLOR</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
</dict>
</dict>
</plist>
struct SCNShaderLightingContribution
vec3 ambient;
vec3 diffuse;
vec3 specular;
} _lightingContribution;
#ifdef USE_SKINNING
uniform vec4 u_skinningJointMatrices[60];
attribute vec4 a_skinningWeights;
attribute vec4 a_skinningJoints;
#endif
// Attributes
attribute vec4 a_position;
#ifdef USE_NORMAL
attribute vec3 a_normal;
#endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
attribute vec4 a_tangent;
#endif
#ifdef NEED_IN_TEXCOORD0
attribute vec2 a_texCoord0;
#endif
#ifdef NEED_IN_TEXCOORD1
attribute vec2 a_texCoord1;
#endif
#ifdef NEED_IN_TEXCOORD2
attribute vec2 a_texCoord2;
#endif
#ifdef NEED_IN_TEXCOORD3
attribute vec2 a_texCoord3;
#endif
#ifdef NEED_IN_TEXCOORD4
attribute vec2 a_texCoord4;
#endif
#ifdef NEED_IN_TEXCOORD5
attribute vec2 a_texCoord5;
#endif
#ifdef NEED_IN_TEXCOORD6
attribute vec2 a_texCoord6;
#endif
#ifdef NEED_IN_TEXCOORD7
attribute vec2 a_texCoord7;
#endif
#ifdef USE_VERTEX_COLOR
attribute vec4 a_color;
varying vec4 v_vertexColor;
#endif
// Varyings
#ifdef USE_PER_VERTEX_LIGHTING
varying vec3 v_diffuse;
#ifdef USE_SPECULAR
varying vec3 v_specular;
#endif
#endif
#if defined(USE_POSITION) || defined(USE_VIEW)
varying vec3 v_position;
#endif
#ifdef USE_NORMAL
varying vec3 v_normal;
#endif
#ifdef USE_TANGENT
varying vec3 v_tangent;
#endif
#ifdef USE_BITANGENT
varying vec3 v_bitangent;
#endif
#if defined(USE_SPECULAR) && defined(USE_PER_VERTEX_LIGHTING)
uniform float u_materialShininess;
#endif
void main(void)
  _geometry.position = a_position;
  #ifdef USE_NORMAL
  _geometry.normal = a_normal;
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _geometry.tangent = a_tangent;
  #endif
  #ifdef NEED_IN_TEXCOORD0
  _geometry.texcoords[0] = a_texCoord0;
  #endif
  #ifdef NEED_IN_TEXCOORD1
  _geometry.texcoords[1] = a_texCoord1;
  #endif
  #ifdef NEED_IN_TEXCOORD2
  _geometry.texcoords[2] = a_texCoord2;
  #endif
  #ifdef NEED_IN_TEXCOORD3
  _geometry.texcoords[3] = a_texCoord3;
  #endif
  #ifdef NEED_IN_TEXCOORD4
  _geometry.texcoords[4] = a_texCoord4;
  #endif
  #ifdef NEED_IN_TEXCOORD5
  _geometry.texcoords[5] = a_texCoord5;
  #endif
  #ifdef NEED_IN_TEXCOORD6
  _geometry.texcoords[6] = a_texCoord6;
  #endif
  #ifdef NEED_IN_TEXCOORD7
  _geometry.texcoords[7] = a_texCoord7;
  #endif
#ifdef USE_VERTEX_COLOR
  _geometry.color = a_color;
#endif
  #ifdef USE_SKINNING
    vec3 pos = vec3(0.);
    #ifdef USE_NORMAL
    vec3 nrm = vec3(0.);
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    vec3 tgt = vec3(0.);
    #endif
    for (int i = 0; i < MAX_BONE_INFLUENCES; ++i) {
#if MAX_BONE_INFLUENCES == 1
        float weight = 1.0;
#else
        float weight = a_skinningWeights[i];
        
#endif
      int idx = int(a_skinningJoints[i]) * 3;
      mat4 jointMatrix = mat4(u_skinningJointMatrices[idx], u_skinningJointMatrices[idx+1], u_skinningJointMatrices[idx+2], vec4(0., 0., 0., 1.));
            pos += (_geometry.position * jointMatrix).xyz * weight;
      #ifdef USE_NORMAL
            nrm += _geometry.normal * mat3(jointMatrix) * weight;
      #endif
      #if defined(USE_TANGENT) || defined(USE_BITANGENT)
            tgt += _geometry.tangent.xyz * mat3(jointMatrix) * weight;
      #endif
    }
    
    _geometry.position.xyz = pos;
    #ifdef USE_NORMAL
    _geometry.normal = nrm;
    #endif
#if defined(USE_TANGENT) || defined(USE_BITANGENT)
    _geometry.tangent.xyz = tgt;
    #endif
  #endif
  #ifdef USE_GEOMETRY_MODIFIER
// DoGeometryModifier START
__DoGeometryModifier__
// DoGeometryModifier END
  #endif
  // Transform the geometry elements in view space
  #ifdef USE_POSITION
  _surface.position = (u_modelViewTransform * _geometry.position).xyz;
  #endif
  #ifdef USE_NORMAL
  _surface.normal = normalize(mat3(u_normalTransform) * _geometry.normal);
  #endif
  #if defined(USE_TANGENT) || defined(USE_BITANGENT)
  _surface.tangent = normalize(mat3(u_normalTransform) * _geometry.tangent.xyz);
  _surface.bitangent = /*_geometry.tangent.w **/ cross(_surface.tangent, _surface.normal); // no need to renormalize since tangent and normal should be orthogonal
    // old code : _surface.bitangent =  normalize(cross(_surface.normal,_surface.tangent));
  #endif
  //if USE_VIEW is 2 we may also need to set _surface.view. todo: make USE_VIEW a mask
  #ifdef USE_VIEW
    _surface.view = normalize(-_surface.position);
  #endif
  #ifdef USE_PER_VERTEX_LIGHTING
  _lightingContribution.diffuse = vec3(0.);
  #ifdef USE_SPECULAR
  _lightingContribution.specular = vec3(0.);
  _surface.shininess = u_materialShininess;
  #endif
  // Lighting
__DoLighting__
  v_diffuse = _lightingContribution.diffuse;
  #ifdef USE_SPECULAR
  v_specular = _lightingContribution.specular;
  #endif
  #endif
  #if defined(USE_POSITION) && (USE_POSITION == 2)
  v_position = _surface.position;
  #endif
  #if defined(USE_NORMAL) && (USE_NORMAL == 2)
  v_normal = _surface.normal;
  #endif
  #if defined(USE_TANGENT) && (USE_TANGENT == 2)
  v_tangent = _surface.tangent;
  #endif
  #if defined(USE_BITANGENT) && (USE_BITANGENT == 2)
  v_bitangent = _surface.bitangent;
  #endif
  #ifdef USE_VERTEX_COLOR
  v_vertexColor = _geometry.color;
  #endif
#ifdef USE_TEXCOORD
__DoTexcoord__
#endif
    
  // this means that the geometry are still in model space
  #if defined(SEPARATE_PROJECTION) && SEPARATE_PROJECTION
  gl_Position = u_projectionTransform * vec4(_surface.position, 1.);
  #else
  gl_Position = u_modelViewProjectionTransform * _geometry.position;
  #endif
#define USE_NORMAL_MAP
#define FUNC_VERT ds_default_vert_N
#define FUNC_FRAG ds_default_frag_N
#import "C3D-DeferredShading.metal"
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
varying vec4 v_vertexColor;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
// initial geometry is [-1,1] in XY plane (so z is always 0)
struct scn_floor_t {
    float3 u_floorNormal;
    float4 u_floorTangent;
    float3 u_floorCenter;
    float2 u_floorExtent;
#pragma arguments
    scn_floor_t scn_fg
#pragma body
    float3 u_floorNormal = scn_fg.u_floorNormal;
    float4 u_floorTangent = scn_fg.u_floorTangent;
    float3 u_floorCenter = scn_fg.u_floorCenter;
    float2 u_floorExtent = scn_fg.u_floorExtent;
    float3 floorBitangent =  normalize(cross(u_floorTangent.xyz, u_floorNormal));
    _geometry.position.xyz = u_floorCenter.xyz + u_floorExtent.x * (_geometry.position.x * u_floorTangent.xyz) + u_floorExtent.y * (_geometry.position.y * floorBitangent);
    _geometry.normal = u_floorNormal;
    _geometry.tangent = u_floorTangent;
    // we could check if the texCoord are really needed with ifdef USE_xxxx_MAP , or, better, work only on texcoordN [0..1]
    float2 tc;
    if (u_floorNormal.y != 0.)
        tc = _geometry.position.xz * 0.01;
    else if (u_floorNormal.z != 0.)
        tc = _geometry.position.xy * 0.01;
    else
        tc = _geometry.position.yz * 0.01;
    for (int i = 0; i < kSCNTexcoordCount; ++i)
        _geometry.texcoords[i] = tc;
#include <metal_stdlib>
using namespace metal;
kernel void scn_osd_synchronize_coarse_positions(device   const float* src         [[buffer(0)]],
                                                 device   float*       dst         [[buffer(1)]],
                                                 constant uint32_t*    indices     [[buffer(2)]],
                                                 constant uint&        dstStride   [[buffer(3)]],
                                                 constant uint&        numVertices [[buffer(4)]],
                                                 uint                  idx         [[thread_position_in_grid]])
    if (idx < numVertices) {
        int srcIndex = 3 * indices[idx];
        int dstIndex = idx * dstStride;
        
        dst[dstIndex + 0] = src[srcIndex + 0];
        dst[dstIndex + 1] = src[srcIndex + 1];
        dst[dstIndex + 2] = src[srcIndex + 2];
    }
typedef struct
    float4x4 transform;
    float superSampling;
} scn_supersampling_parameter;
#import <metal_stdlib>
using namespace metal;
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Unify normals
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// vertTri is [start, start,]
// sharedTri is [(i0,i1,i2), t1, t2, ...]
kernel void unify_u16(uint index                     [[ thread_position_in_grid ]],
                      device packed_float3* pos      [[ buffer(0) ]],
                      device packed_float3* nrm      [[ buffer(1) ]],
                      device int* vertTopology       [[ buffer(2) ]],
                      device ushort* sharedTriangles [[ buffer(3) ]],
                      constant uint& vertexCount     [[ buffer(4) ]])
    if (index >= vertexCount)
        return;
    int start = vertTopology[index    ] * 3;
    int end   = vertTopology[index + 1] * 3;
    
    float3 averageNrm = 0.f;
    for (int faceIndex = start; faceIndex < end; ) {
        ushort i0 = sharedTriangles[faceIndex++];
        ushort i1 = sharedTriangles[faceIndex++];
        ushort i2 = sharedTriangles[faceIndex++];
        
        float3 v0 = pos[i0];
        float3 v1 = pos[i1];
        float3 v2 = pos[i2];
        if (1) { // only consider triangle area
            // scale the normal by the triangle area -> remove the normalize
            // http://www.iquilezles.org/www/articles/normals/normals.htm
            float3 faceNormal = cross(v1 - v0, v2 - v0);
            // TODO consider crease threshold here
            averageNrm += faceNormal;
        
        } else { // consider triangle area + corner angle
            // disabled because not clearly better
            
            float3 e0, e1;
            if (index == i0) {
                e0 = v0 - v2;
                e1 = v1 - v0;
            } else if (index == i1) {
                e0 = v1 - v0;
                e1 = v2 - v1;
            } else /* if (index == i2) */ { // must be i2 (but not with quads)
                e0 = v2 - v1;
                e1 = v0 - v2;
            }
            float3 faceNormal = cross(e0, e1);
            
            // compute angle between edges
            float angle = dot( normalize(e0), normalize(e1) );
            // normalization [-1..1] -> [0..1], acos would be more correct but more expansive
            angle = 1.f - (angle * 0.5f + 0.5f);
            
            averageNrm += faceNormal * angle;
        }
        
    }
/* Debug valence
    int faceCount = (end - start)/3;
    switch (faceCount) {
        case 0: averageNrm = float3(0., 0., 0.); break;
        case 1: averageNrm = float3(1.0, 0., 0.); break;
        case 2: averageNrm = float3(0.0, 0.5, 0.5); break;
        case 3: averageNrm = float3(0.5, 1.0, 0.); break;
        case 4: averageNrm = float3(0., 0., 0.5); break;
        case 5: averageNrm = float3(0., 0.5, 0.); break;
        case 6: averageNrm = float3(0.5, 0., 0.5); break;
        case 7: averageNrm = float3(1., 0., 1.); break;
        case 8: averageNrm = float3(0.5, 0.5, 0.5); break;
        case 9: averageNrm = float3(1., 1., 1.); break;
//        default: averageNrm = float3(0., 0., 1.); break;
    }
 nrm[index] = averageNrm;
    
    nrm[index] = normalize(averageNrm);
kernel void unify_u32(uint index                     [[ thread_position_in_grid ]],
                      device packed_float3* pos      [[ buffer(0) ]],
                      device packed_float3* nrm      [[ buffer(1) ]],
                      device int* vertTopology       [[ buffer(2) ]],
                      device int* sharedTriangles    [[ buffer(3) ]],
                      constant uint& vertexCount     [[ buffer(4) ]])
    if (index >= vertexCount)
        return;
    
    int start = vertTopology[index];
    int end   = vertTopology[index + 1];
    
    float3 averageNrm = 0;
    for (int faceIndex = start; faceIndex < end; ++faceIndex) {
        
        int i0 = sharedTriangles[faceIndex * 3 + 0];
        int i1 = sharedTriangles[faceIndex * 3 + 1];
        int i2 = sharedTriangles[faceIndex * 3 + 2];
        
        float3 v0 = pos[i0];
        float3 v1 = pos[i1];
        float3 v2 = pos[i2];
        
        // scale the normal by the triangle area -> remove the normalize
        // http://www.iquilezles.org/www/articles/normals/normals.htm
        float3 faceNormal = cross(v1 - v0, v2 - v0);
        
        // TODO consider crease threshold here
        averageNrm += faceNormal;
    }
    
    nrm[index] = normalize(averageNrm);
#define C3D_HISTOGRAM_DRAW_BORDER 6
typedef struct {
    uint32_t        numberOfHistogramEntries;
    bool            histogramForAlpha;
    vector_float4   minPixelValue;
    vector_float4   maxPixelValue;
} scn_histogram_info_t;
typedef struct {
    float lowValuesQuantileProbability;
    float highValuesQuantileProbability;
} scn_histogram_analysis_parameters_t;
typedef struct {
    uint32_t maxValue;
    uint32_t lowValuesQuantileMaxBin;
    uint32_t highValuesQuantileMinBin;
    float    average;
    float    adjustedAverage;
} scn_histogram_analysis_t;
#if defined(TESSELLATION_SMOOTHING_MODE_PN_TRIANGLE)
static inline void scn_smooth_geometry_pn_triangle(thread float3 &position, thread float3 &normal, float3 patchCoord, float3 P0, float3 P1, float3 P2, float3 N0, float3 N1, float3 N2)
    float u = patchCoord.y;
    float v = patchCoord.z;
    float w = patchCoord.x;
    
    float3 P0P1 = P1 - P0;
    float3 P1P2 = P2 - P1;
    float3 P2P0 = P0 - P2;
    
    float w12 = dot(P0P1, N0);
    float w23 = dot(P1P2, N1);
    float w31 = dot(P2P0, N2);
    
    float w21 = dot(-P0P1, N1);
    float w32 = dot(-P1P2, N2);
    float w13 = dot(-P2P0, N0);
    
    float inv3 = 1.f / 3.f;
    
    float3 b210 = (2.f * P0 + P1 - w12 * N0) * inv3;
    float3 b021 = (2.f * P1 + P2 - w23 * N1) * inv3;
    float3 b201 = (2.f * P0 + P2 - w13 * N0) * inv3;
    
    float3 b120 = (2.f * P1 + P0 - w21 * N1) * inv3;
    float3 b012 = (2.f * P2 + P1 - w32 * N2) * inv3;
    float3 b102 = (2.f * P2 + P0 - w31 * N2) * inv3;
    
    float3 E = (b210 + b120 + b021 + b012 + b201 + b102) / 6.f;
    float3 V = (P0 + P1 + P2) * inv3;
    float3 b111 = E + (E - V) / 2.f;
    
    position.xyz =
    P0 * (w * w * w) +
    P1 * (u * u * u) +
    P2 * (v * v * v) +
    b210 * (3.f * w * w * u) +
    b120 * (3.f * w * u * u) +
    b201 * (3.f * w * w * v) +
    b021 * (3.f * u * u * v) +
    b102 * (3.f * w * v * v) +
    b012 * (3.f * u * v * v) +
    b111 * (6.f * w * u * v);
    
    float3 v12 = 2.f * dot(P0P1, N0 + N1) / dot(P0P1, P0P1);
    float3 v23 = 2.f * dot(P1P2, N1 + N2) / dot(P1P2, P1P2);
    float3 v31 = 2.f * dot(P2P0, N2 + N0) / dot(P2P0, P2P0);
    
    float3 h110 = N0 + N1 - v12 * P0P1;
    float3 h011 = N1 + N2 - v23 * P1P2;
    float3 h101 = N2 + N0 - v31 * P2P0;
    
    float3 n010 = normalize(h110);
    float3 n011 = normalize(h011);
    float3 n001 = normalize(h101);
    
    normal = normalize(
    N0 * w * w +
    N1 * u * u +
    N2 * v * v +
    n010 * w * u +
    n011 * u * v +
    n001 * w * v);
#elif defined(TESSELLATION_SMOOTHING_MODE_PHONG)
static inline void scn_smooth_geometry_phong(thread float3 &position, thread float3 &normal, float3 patchCoord, float3 P0, float3 P1, float3 P2, float3 N0, float3 N1, float3 N2)
    float3 P = scn::barycentric_mix(P0, P1, P2, patchCoord);
    
    float3 proj0 = P - dot(P - P0, N0) * N0;
    float3 proj1 = P - dot(P - P1, N1) * N1;
    float3 proj2 = P - dot(P - P2, N2) * N2;
    
    float3 Pproj = scn::barycentric_mix(proj0, proj1, proj2, patchCoord);
    
    const float alpha = 0.75f;
    position = mix(P, Pproj, alpha);
    normal = normalize(scn::barycentric_mix(N0, N1, N2, patchCoord));
#endif // GEOMETRY_SMOOTHING
#import <metal_stdlib>
using namespace metal;
#import "C3D-PostProcessUtils.h"
////////////////
// Add
struct Add_io {
    float4 position [[position]];
    float2 texCoord;
vertex Add_io Add_vert(
                                         uint v_id [[ vertex_id ]]
                                         )
    Add_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 Add_frag(
                        Add_io in [[stage_in]],
                        texture2d<float> textureSampler0 [[texture(0)]],
                        texture2d<float> textureSampler1 [[texture(1)]]
                        )
    constexpr sampler samp(filter::linear);
    return half4(textureSampler0.sample(samp, in.texCoord) + textureSampler1.sample(samp, in.texCoord));
////////////////////
// Copy
struct Copy_io {
    float4 position [[position]];
    float2 texCoord;
vertex Copy_io Copy_vert(
                       uint v_id [[ vertex_id ]]
                       )
    Copy_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 Copy_frag(
                        Copy_io in [[stage_in]],
                        texture2d<float> textureSampler0 [[texture(0)]]
                        )
    constexpr sampler samp(filter::linear);
    return half4(textureSampler0.sample(samp, in.texCoord));
/////////////////////
// Mult (float)
struct Mult_io {
    float4 position [[position]];
    float2 texCoord;
struct Mult_uniforms {
    float factor;
vertex Mult_io Mult_vert(
                         uint v_id [[ vertex_id ]]
                         )
    Mult_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 Mult_frag(
                         Mult_io in [[stage_in]],
                         texture2d<float> textureSampler0 [[texture(0)]],
                         constant Mult_uniforms& uniforms [[buffer(0)]]
                         )
    constexpr sampler samp(filter::linear);
    return half4(textureSampler0.sample(samp, in.texCoord) * uniforms.factor);
/////////////////////////
// IncrementalAverage
struct IncrementalAverage_io {
    float4 position [[position]];
    float2 texCoord;
struct IncrementalAverage_uniforms {
    float factor;
vertex IncrementalAverage_io IncrementalAverage_vert(
                       uint v_id [[ vertex_id ]]
                       )
    IncrementalAverage_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 IncrementalAverage_frag(
                        IncrementalAverage_io in [[stage_in]],
                        texture2d<float> textureSampler0 [[texture(0)]],
                        texture2d<float> textureSampler1 [[texture(1)]],
                        constant IncrementalAverage_uniforms& uniforms [[buffer(0)]]
                        )
    constexpr sampler samp(filter::linear);
    float4 newFragment = textureSampler0.sample(samp, in.texCoord);
    float4 oldColor = textureSampler1.sample(samp, in.texCoord);
    const float factor = uniforms.factor;
    return half4((factor - 1.0) * (oldColor / factor) + newFragment / factor);
uniform sampler2D textureSampler0;
uniform float factor;
varying vec2 TexCoord;
void main (void)
gl_FragColor =
texture2D(textureSampler0,TexCoord) * factor;
uniform samplerCube textureSampler0;
varying vec3 TexCoord;
#if __VERSION__ > 120 // GL Compatibility Profile
#define textureCube(tex,coord) texture( tex, coord )
#endif
void main (void)
    
gl_FragColor = textureCube(textureSampler0,TexCoord);
#define SSAORadius 6
#define SSAOStride 2
typedef struct __attribute__((__aligned__(256))) {
    float projScale;
    float radius;
    float radius2;
    float bias;
    float intensity;
    float depthThreshold;
    float normalThreshold;
    float zMax;
    float4 projectionInfo;
    
    int scale;
    
} scn_ssao_uniforms_t;
// LightInfo (must be synchronized with C3DLightProgramHash)
// Type (3 bits)        : 0
// DistAtt (3 bits)     : 3
// SpotAtt (3 bits)     : 6
// Gobo                 : 9
// Shadow               : 10
// ShadowColor          : 11 // seems useless : always multiply by color.a
// Modulate             : 12
// IES (2 bits)         : 13 // 2 bits (1D texture, 2D texture, Cubemap, unknown)
// ShadowSample (5 bits): 15
#define LIGHT_TYPE(a)           ((a      ) & 0x7)
#define LIGHT_DIST_ATT(a)       ((a >> 3) & 0x7)
#define LIGHT_SPOT_ATT(a)       ((a >> 6) & 0x7)
#define LIGHT_HAS_GOBO(a)       (a & (1 << 9))
#define LIGHT_HAS_SHADOW(a)     (a & (1 << 10))
#define LIGHT_IS_MODULATE(a)    (a & (1 << 12))
#define LIGHT_IES_TYPE(a)       ((a >> 13) & 0x3)
#define LIGHT_SHADOW_SAMPLE(a)  ((a >> 15) & 0x1f)
#if defined(__METAL_VERSION__)
enum C3DLightAttenuationType
    kC3DLightAttenuationTypeNone,
    kC3DLightAttenuationTypeConstant,
    kC3DLightAttenuationTypeLinear,
    kC3DLightAttenuationTypeQuadratic,
    kC3DLightAttenuationTypeExponent,
    kC3DLightAttenuationTypePhysicallyBased,
enum C3DLightType
    kC3DLightAmbient,
    kC3DLightDirectional,
    kC3DLightPoint,
    kC3DLightSpot,
    kC3DLightProbe,
    kC3DLightSky,
    kC3DLightIES
enum C3DLightIESType
    kC3DLightIESType1D,
    kC3DLightIESType2D,
    kC3DLightIESTypeCubemap,
    kC3DLightIESTypeNone
#endif
struct SCNLightData {
    float4 color; // .rgb: color * intensity * temperature / .a: shadowColor.a
    float4 pbrColor; // color to be used for PBR materials (include a PI factor)
    
    // TODO : consider storing directly the viewSpace matrix of the light
    float3 position;  // spot + omni, view space
    float3 direction; // spot + dir, view space
    float3 up; // ies, view space
    float3 right; // ies, view space
    
    float3 distanceAttenuation; // spot + omni
    float3 spotAttenuation; // spot only
    float shadowRadius; // TODO store in .w somewhere
    float4x4 shadowMatrix; // gobo + shadow
#import <metal_stdlib>
#import <simd/simd.h>
using namespace metal;
// MARK: Debug functions
typedef struct {
    float4 position [[ position ]];
    float2 uv;
} quad_io_t;
vertex quad_io_t quad_vertex(uint             v_id [[ vertex_id ]],
                             constant float4& rect [[ buffer(0) ]])
    quad_io_t out;
    
    float2 uv = float2(v_id / 2, v_id % 2);
    float2 ruv = rect.xy +  uv * rect.zw;
    out.position = float4(ruv.x * 2.0 - 1.0,
                          ruv.y * 2.0 - 1.0,
                          0.0,
                          1.0);
    
    out.uv = float2( uv.x, 1 - uv.y ) ;
    return out;
static float3 cubemap_sampling_coordinates(uint face, float2 uv)
    uv = 2.0f * uv - 1.0f; // [0, 1] -> [-1, 1]
    
    switch(face) {
        case 0:
            return float3(+1.0f, -uv.y, -uv.x);
            
        case 1:
            return float3(-1.0f, -uv.y, uv.x);
            
        case 2:
            return float3(uv.x, +1.0f, uv.y);
            
        case 3:
            return float3(uv.x, -1.0f, -uv.y);
            
        case 4:
            return float3(uv.x, -uv.y, +1.0f);
            
        case 5:
            return float3(-uv.x, -uv.y, -1.0f);
    }
    
    return float3(0.0);
inline bool isInRect(float4 rect, float2 p) {
    return
    rect.x <= p.x && p.x <= rect.x + rect.z &&
    rect.y <= p.y && p.y <= rect.y + rect.w;
inline float2 barycentricCoordinates(float4 rect, float2 p) {
    return float2((p.x - rect.x) / rect.z,  (p.y - rect.y) / rect.w);
inline float4 subrect(float4 rect, int i, int j) {
    return float4(rect.x + i * rect.z / 4.0,
                  rect.y + j * rect.w / 3.0,
                  rect.z / 4.0,
                  rect.w / 3.0);
static float4 sampleTexture(float2 uv, float4 mipLevelRect, uint mipLevel, texture2d<float> texture)
    constexpr sampler linearSampler(filter::linear, mip_filter::nearest);
    
    if (isInRect(mipLevelRect, uv)) {
        float2 faceUV = barycentricCoordinates(mipLevelRect, uv);
        return texture.sample(linearSampler, faceUV, level(mipLevel));
    }
    
    return float4(-1.0);
static float sampleDepth(float2 uv, float4 mipLevelRect, uint mipLevel, depth2d<float> texture)
    constexpr sampler linearSampler(filter::nearest, mip_filter::nearest);
    
    if (isInRect(mipLevelRect, uv)) {
        float2 faceUV = barycentricCoordinates(mipLevelRect, uv);
        return texture.sample(linearSampler, faceUV, level(mipLevel));
    }
    
    return -1.0;
static float4 sampleCubemap(float2 uv, float4 mipLevelRect, uint mipLevel, texturecube<float> texture)
    constexpr sampler linearSampler(filter::linear, mip_filter::nearest);
    
    if (isInRect(mipLevelRect, uv)) {
        float4 faceSubrect;
        float2 faceUV;
        
        // +X
        faceSubrect = subrect(mipLevelRect, 2, 1);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(0, faceUV), level(mipLevel));
        }
        
        // -X
        faceSubrect = subrect(mipLevelRect, 0, 1);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(1, faceUV), level(mipLevel));
        }
        
        // +Y
        faceSubrect = subrect(mipLevelRect, 1, 0);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(2, faceUV), level(mipLevel));
        }
        
        // -Y
        faceSubrect = subrect(mipLevelRect, 1, 2);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(3, faceUV), level(mipLevel));
        }
        
        // +Z
        faceSubrect = subrect(mipLevelRect, 1, 1);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(4, faceUV), level(mipLevel));
        }
        
        // -Z
        faceSubrect = subrect(mipLevelRect, 3, 1);
        faceUV = barycentricCoordinates(faceSubrect, uv);
        if (isInRect(faceSubrect, uv)) {
            return texture.sample(linearSampler, cubemap_sampling_coordinates(5, faceUV), level(mipLevel));
        }
    }
    
    return float4(-1.0);
fragment half4 quad_display_texture2D(quad_io_t        in      [[ stage_in ]],
                                      texture2d<float> texture [[ texture(0) ]])
    float4 rect = float4(2.0 / 3.0, 0.0, 1.0 / 3.0, 0.5);
    
    uint mipLevelCount = texture.get_num_mip_levels();
    for (uint mipLevel = 0; mipLevel < mipLevelCount; ++mipLevel) {
        
        float4 mipLevelRect = rect;
        if (mipLevel == 0) {
            mipLevelRect = float4(0.0, 0.0, (mipLevelCount != 1 ? 2.0 / 3.0 : 1.0), 1.0);
        }
        
        float4 color = sampleTexture(in.uv, mipLevelRect, mipLevel, texture);
        if (color.w != -1.0) {
            return half4(color);
        }
        
        if (mipLevel != 0) {
            rect = float4(rect.x,
                          rect.y + rect.w,
                          0.5 * rect.z,
                          0.5 * rect.w);
        }
    }
    
    discard_fragment();
    return half4(0.0);
fragment half4 quad_display_depth2D(quad_io_t        in      [[ stage_in ]],
                                      depth2d<float> texture [[ texture(0) ]])
    float4 rect = float4(2.0 / 3.0, 0.0, 1.0 / 3.0, 0.5);
    
    uint mipLevelCount = texture.get_num_mip_levels();
    for (uint mipLevel = 0; mipLevel < mipLevelCount; ++mipLevel) {
        
        float4 mipLevelRect = rect;
        if (mipLevel == 0) {
            mipLevelRect = float4(0.0, 0.0, (mipLevelCount != 1 ? 2.0 / 3.0 : 1.0), 1.0);
        }
        
        float color = sampleDepth(in.uv, mipLevelRect, mipLevel, texture);
        if (color != -1.0) {
            return half4(color, color, color, 1.f);
        }
        
        if (mipLevel != 0) {
            rect = float4(rect.x,
                          rect.y + rect.w,
                          0.5 * rect.z,
                          0.5 * rect.w);
        }
    }
    
    discard_fragment();
    return half4(0.0);
fragment half4 quad_display_cube(quad_io_t          in      [[ stage_in ]],
                                 texturecube<float> texture [[ texture(0) ]])
    float4 rect = float4(0.0, 0.0, 1.0, 1.0);
//    float4 col = rect;
//    col.rg = in.uv;
//    return half4(col);
    
    
    uint mipLevelCount = texture.get_num_mip_levels();
    
    for (uint mipLevel = 0; mipLevel < mipLevelCount; ++mipLevel) {
        
        float4 mipLevelRect = float4(rect.x, rect.y, rect.z, (mipLevelCount != 1 ? 0.75f : 1.0f) * rect.w);
//        float4 mipLevelRect = float4(rect.x, rect.y, rect.z, rect.w);
        
        float4 color = sampleCubemap(in.uv, mipLevelRect, mipLevel, texture);
        if (color.w != -1.0) {
            return half4(color);
        }
        
        rect = float4(rect.x + 0.5f * rect.z,
                      rect.y + 0.5f * rect.w,
                      0.5f * rect.z,
                      0.5f * rect.w);
    }
    
    {
        discard_fragment();
        return half4(0.0);
    }
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>sequence</key>
<array>
<string>Outline-pickedObjects</string>
<string>Outline-outline</string>
<string>Outline-max</string>
</array>
<key>passes</key>
<dict>
<key>Outline-pickedObjects</key>
<dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>u_modelViewProjectionTransform</key>
<string>u_modelViewProjectionTransform-symbol</string>
<key>u_modelTransform</key>
<string>u_modelTransform-symbol</string>
</dict>
<key>outputs</key>
<dict>
<key>depth</key>
<string>pickedObjects-depth</string>
<key>color</key>
<string>pickedObjects-color</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>samples</key>
<integer>1</integer>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>&quot;0. 0. 0. 1.&quot;</string>
</dict>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
</dict>
<key>Outline-outline</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>outline-color</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>pickedColorBuffer</key>
<string>pickedObjects-color</string>
<key>pickedDepthBuffer</key>
<string>pickedObjects-depth</string>
<key>colorBuffer</key>
<string>COLOR</string>
<key>depthBuffer</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineRetina</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineRetina_vert</string>
<key>metalFragmentShader</key>
<string>outlineRetina_frag</string>
</dict>
<key>Outline-max</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>outlineColorBuffer</key>
<string>outline-color</string>
<key>colorBuffer</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>program</key>
<string>C3D-OutlineMax</string>
<key>clientProgram</key>
<string>NO</string>
<key>metalVertexShader</key>
<string>outlineMax_vert</string>
<key>metalFragmentShader</key>
<string>outlineMax_frag</string>
</dict>
</dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>u_modelViewProjectionTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelViewProjectionTransform</string>
</dict>
<key>u_modelTransform-symbol</key>
<dict>
<key>semantic</key>
<string>modelTransform</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>targets</key>
<dict>
<key>outline-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-depth</key>
<dict>
<key>type</key>
<string>depth</string>
<key>format</key>
<string>depth24</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
<key>pickedObjects-color</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>r8</string>
<key>scaleFactor</key>
<integer>1</integer>
</dict>
</dict>
</dict>
</plist>
// This pixel shader applies a 3 x 3 blur to the image in
// colorMapSampler, which is the same size as the render target.
// The sample weights are 1/16 in the corners, 2/16 on the edges,
// and 4/16 in the center.
uniform sampler2D colorSampler;
varying vec4 v_texCoord;
void main (void)
    // Use bilinear filtering to average 4 color samples for free.
    vec4 color;
    color  = texture2D( colorSampler, v_texCoord.xz );
    color += texture2D( colorSampler, v_texCoord.yz );
    color += texture2D( colorSampler, v_texCoord.xw );
    color += texture2D( colorSampler, v_texCoord.yw );
    color *= 0.25;
    
gl_FragColor = vec4(color);
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "C3D-PostProcessUtils.h"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// PickedObject
#define MOD2 float2(443.8975,397.2973)
static inline float hash(float2 p)
    p  = fract(p * MOD2);
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
struct pickedObject_node_uniforms_t
    float4x4 modelTransform;
    float4x4 modelViewProjectionTransform;
struct pickedObject_io
    float4 position [[position]];
    float color;
struct pickedObject_vertex_t
    float3 position [[attribute(SCNVertexSemanticPosition)]];
vertex pickedObject_io pickedObject_vert(pickedObject_vertex_t in [[ stage_in ]], constant SCNSceneBuffer& frameUniforms [[buffer(0)]], constant pickedObject_node_uniforms_t& scn_node [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    pickedObject_io out;
    out.position = (scn_node.modelViewProjectionTransform * in_position);
    out.color = hash(scn_node.modelTransform[3].xy)+1./255.;
    return out;
// Pixel
fragment half pickedObject_frag(pickedObject_io in [[stage_in]])
    return half(in.color);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Outline
struct outline_io {
    float4 position [[position]];
    float2 texCoord;
vertex outline_io outline_vert( uint v_id [[ vertex_id ]] )
    outline_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 outline_frag( outline_io in [[stage_in]],
                             texture2d<half> pickedColorBuffer [[texture(0)]],
                             texture2d<half> colorBuffer [[texture(1)]],
                            depth2d<float> depthBuffer [[texture(2)]],
                            depth2d<float> pickedDepthBuffer [[texture(3)]],
                            constant SCNSceneBuffer& scn_frame [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    const float2 uv = in.texCoord;
    
    //Sobel
    float texels[9];
    texels[0] = pickedColorBuffer.sample(samp, uv, int2(-1,-1)).r;
    texels[1] = pickedColorBuffer.sample(samp, uv, int2( 0,-1)).r;
    texels[2] = pickedColorBuffer.sample(samp, uv, int2( 1,-1)).r;
    texels[3] = pickedColorBuffer.sample(samp, uv, int2(-1, 0)).r;
    texels[4] = pickedColorBuffer.sample(samp, uv).r;
    texels[5] = pickedColorBuffer.sample(samp, uv, int2( 1, 0)).r;
    texels[6] = pickedColorBuffer.sample(samp, uv, int2(-1, 1)).r;
    texels[7] = pickedColorBuffer.sample(samp, uv, int2( 0, 1)).r;
    texels[8] = pickedColorBuffer.sample(samp, uv, int2( 1, 1)).r;
    
    //A little hack for multi-objects selection
    float3 a = float3(texels[0],texels[3],texels[6]);
    float3 b = float3(texels[2],texels[5],texels[7]);
    bool3 tmp = a == b;
    float3 retLin = mix( float3(tmp), float3(not(tmp)), float3(b == float3(0.)) );
    
    a = float3(texels[0],texels[1],texels[2]);
    b = float3(texels[6],texels[7],texels[8]);
    tmp = a == b;
    float3 retCol = mix( float3(tmp), float3(not(tmp)), float3(b == float3(0.)) );
    
    float4 last = step(float4(0.002), float4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    //Get magnitude of the sobel filters
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    //Get min depth around 5x5 pixels
    float depth = 1.;
//    for(int i=-2; i<3; i++)
//        for(int j=-2; j<3; j++)
//            depth = min(depth, pickedDepthBuffer.sample(samp, uv, int2(i,j)));
    
    //Get min depth around 3x3 pixels
    for(int i=-1; i<2; i++)
        for(int j=-1; j<2; j++)
            depth = min(depth, pickedDepthBuffer.sample(samp, uv, int2(i,j)));
    
    
    //Outline color
    half4 color = colorBuffer.sample(samp, uv);
    half4 outline = half4(1.,.4,.0,1.);
    if ( depthBuffer.sample(samp, uv) < depth-0.000001  && texels[4] > 0.)
        return mix(color, outline, half4(.25));
    else
        return mix( color, outline, half4(min(magnitude/4.,1.)) );
vertex outline_io outlineRetina_vert( uint v_id [[ vertex_id ]] )
    outline_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 outlineRetina_frag( outline_io in [[stage_in]],
                             texture2d<half> pickedColorBuffer [[texture(0)]],
                             depth2d<float> depthBuffer [[texture(1)]],
                             depth2d<float> pickedDepthBuffer [[texture(2)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    const float2 uv = in.texCoord;
    
    //Sobel
    float texels[9];
    texels[0] = pickedColorBuffer.sample(samp, uv, int2(-1,-1)).r;
    texels[1] = pickedColorBuffer.sample(samp, uv, int2( 0,-1)).r;
    texels[2] = pickedColorBuffer.sample(samp, uv, int2( 1,-1)).r;
    texels[3] = pickedColorBuffer.sample(samp, uv, int2(-1, 0)).r;
    texels[4] = pickedColorBuffer.sample(samp, uv).r;
    texels[5] = pickedColorBuffer.sample(samp, uv, int2( 1, 0)).r;
    texels[6] = pickedColorBuffer.sample(samp, uv, int2(-1, 1)).r;
    texels[7] = pickedColorBuffer.sample(samp, uv, int2( 0, 1)).r;
    texels[8] = pickedColorBuffer.sample(samp, uv, int2( 1, 1)).r;
    
    //A little hack for multi-objects selection
    float3 a = float3(texels[0],texels[3],texels[6]);
    float3 b = float3(texels[2],texels[5],texels[7]);
    bool3 tmp = a == b;
    float3 retLin = mix( float3(tmp), float3(not(tmp)), float3(b == float3(0.)) );
    
    a = float3(texels[0],texels[1],texels[2]);
    b = float3(texels[6],texels[7],texels[8]);
    tmp = a == b;
    float3 retCol = mix( float3(tmp), float3(not(tmp)), float3(b == float3(0.)) );
    
    float4 last = step(float4(0.002), float4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    //Get magnitude of the sobel filters
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    //Get min depth around 5x5 pixels
    float depth = 1.;
//    for(int i=-2; i<3; i++)
//        for(int j=-2; j<3; j++)
//            depth = min(depth, pickedDepthBuffer.sample(samp, uv, int2(i,j)));
    
    //Get min depth around 3x3 pixels
    for(int i=-1; i<2; i++)
        for(int j=-1; j<2; j++)
            depth = min(depth, pickedDepthBuffer.sample(samp, uv, int2(i,j)));
    
    
    
    //Outline color
    if ( depthBuffer.sample(samp, uv) < depth-0.000001  && texels[4]> 0.)
        return half4(.25);
    else
        return half4(min(magnitude/4.,1.));
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Outline Max
vertex outline_io outlineMax_vert( uint v_id [[ vertex_id ]] )
    outline_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment half4 outlineMax_frag( outline_io in [[stage_in]],
                             texture2d<float> colorBuffer [[texture(0)]],
                             texture2d<float> outlineColorBuffer [[texture(1)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    const float2 uv = in.texCoord;
    
    float alpha = outlineColorBuffer.sample(samp, uv, int2(-1,-1)).r;
    alpha += outlineColorBuffer.sample(samp, uv, int2(0,-1)).r;
    alpha += outlineColorBuffer.sample(samp, uv, int2(1,-1)).r;
    alpha += outlineColorBuffer.sample(samp, uv, int2(-1,0)).r;
    alpha += outlineColorBuffer.sample(samp, uv, int2(0,0)).r;
    alpha += outlineColorBuffer.sample(samp, uv, int2(1,0)).r;
    alpha += outlineColorBuffer.sample(samp, uv, int2(-1,1)).r;
    alpha += outlineColorBuffer.sample(samp, uv, int2(0,1)).r;
    alpha += outlineColorBuffer.sample(samp, uv, int2(1,1)).r;
    alpha /= 9.;
    
    //alpha = mix(alpha, pixel.a, 0.5);
    
    //Final antialiased mix
    return mix( half4(colorBuffer.sample(samp,uv)), half4(1.,.4,.0,1.), half4(min(alpha*2.,1.)) );
attribute vec4 a_position;
attribute vec4 a_texCoord0; // x:life y:size z:cornerX w:cornerY
attribute vec4 a_texCoord1; // xyz:velocity w:cornerY
attribute vec4 a_color; // particle color
uniform mat4 viewTransform; // this should contain only the viewTransform if part are in world space or modelViewTransform otherwise
uniform mat4 u_projectionTransform;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main()
    // transform the particle in view space
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
    vec2 dir0 = normalize((viewTransform * vec4(normalize(a_texCoord1.xyz), 0)).xy);
    vec2 tangent = vec2(-dir0.y, dir0.x);
    
    viewPos.xy += tangent * a_texCoord0.y * a_texCoord1.w;
    v_vertexColor = a_color;
    v_uv0 = vec2(a_texCoord0.x, a_texCoord1.w * 0.5 + 0.5);
    
    gl_Position = u_projectionTransform * viewPos;
#import <metal_stdlib>
using namespace metal;
#import "C3D-PostProcess.h"
#import "C3D-PostProcessUtils.h"
#import "C3D-Histogram.h"
#import "scn_metal"
#import "scn_util.h"
using namespace scn;
#define PI 3.141592653589
#define USE_LUMINANCE_REINHARD 0
#define USE_REINHARD 1
#define USE_FILMIC 0
#define USE_ACES 0
#define ADAPTATIVE_DECAY 1
// MARK: Tonemapping operators
// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
inline half3 aces(half3 color)
    half a = 2.51h;
    half b = 0.03h;
    half c = 2.43h;
    half d = 0.59h;
    half e = 0.14h;
    return saturate((color * (a * color + b)) / (color * ( c * color + d) + e));
// Jim Heijl 2015
inline half3 filmic(half3 color, half whitePoint)
    
    half4 vh = half4(color, whitePoint);
    half4 va = (1.425h * vh) + 0.05h;
    half4 vf = ((vh * va + 0.004h) / ((vh * (va + 0.55h) + 0.0491h))) - 0.0821h;
    return vf.rgb / vf.www;
inline half3 simpleReinhardToneMapping(half3 color, half exposure)
    color *= exposure/(1.h + color / exposure);
    //    color = pow(color, float3(1. / gamma));
    return color;
inline half3 reinhardToneMapping(half3 col, half exposure, half whitePoint)
    col *= exposure;
    return (col * (1.h + col / whitePoint)) / (1.h + col);
inline half3 luminanceReinhardToneMapping(half3 col, half exposure, half whitePoint)
    float3 Yxy = rgb_to_Yxy(float3(col.rgb));
    half lumScaled = Yxy.r * exposure;
    half lumCompressed = (lumScaled * (1.h + lumScaled / whitePoint)) / (1.h + lumScaled);
    Yxy.x = lumCompressed;
    return half3(Yxy_to_rgb(Yxy));
// MARK: utility functions
inline bool pointInRect(float2 pt, float4 rect) {
    return all(pt > rect.xy) && all((pt - rect.xy) < rect.zw);
inline float2 rescalePointInRect(float2 pt, float4 rect) {
    return (pt - rect.xy) / rect.zw;
inline float toLogLum(float lum)
    //  we need the precise version of the log otherwise we do get NaNs....
    return precise::log(1 + lum);
inline float fromLogLum(float lum)
    return precise::exp(lum) - 1;
static float scn_exposure(constant scn_postprocess_uniforms_t& uni, float averageLum)
#if 0 // Auto compute middle grey
    
    // auto generate middleGrey based on averageLum [Krawczyk]
    float middleGrey = 1.03 - 2. / (2 + log10(uni.averageLuminance + 1));
    
#else
    float middleGrey = uni.averageLuminance;
#endif
    
    float exposure =  middleGrey / (averageLum + 0.000001);
    exposure = clamp(exposure, uni.minimumExposure, uni.maximumExposure) * uni.exposureOffset;
    
    return exposure;
static half3 scn_tonemap(half3 col, half whitePoint, half exposure)
#if USE_LUMINANCE_REINHARD
    return luminanceReinhardToneMapping(col, exposure, whitePoint);
#elif USE_REINHARD
    return reinhardToneMapping(col, exposure, whitePoint);
#elif USE_FILMIC
    return filmic(col * exposure, whitePoint);
#elif USE_ACES
    return aces(col * exposure);
#endif
    
static float3 scn_tonemap_threshold(float3 col, constant scn_postprocess_uniforms_t& uni, float exposure)
    float3 Yxy = rgb_to_Yxy(col.rgb);
    float LumScaled = max(Yxy.r * exposure - uni.bloomThreshold, 0.);
    float lumthreshold = max(LumScaled * (1.f + LumScaled / uni.whitePoint), 0.);
    Yxy.x = precise::saturate(lumthreshold / (lumthreshold + uni.bloomOffset));
    
    return Yxy_to_rgb(Yxy);
static half3 scn_colorgrading(half3 col, half intensity, texture3d<half> tex)
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear, address::clamp_to_edge);
    half3 corrected = tex.sample(linear_sampler, float3(col)).rgb;
    return mix(col, corrected, intensity);
static half4 draw_tonemap_curve(float2 uv, constant scn_postprocess_uniforms_t& uni, constant scn_autoexposure_parameters_t& buffer)
    float lumCompressed = float(scn_tonemap(half3(uv.xxx), uni.whitePoint, buffer.exposure).x);
    
    float4 col = float4(0.1, 0, 0, 1);
    // average lum
    col += step(abs(uv.y - saturate(buffer.averageLum / 4.)), 0.01) * float4(1);
    col += step(abs(uv.y - buffer.averageLum / 2.), 0.01) * float4(0., 1., 1., 1.);
    col += step(abs(uv.y - uni.minimumExposure / 2.), 0.01) * float4(0., 0., 1., 1.);
    col += step(abs(uv.y - uni.maximumExposure / 2.), 0.01) * float4(0., 1., 0., 1.);
    
    col += smoothstep(0.01, 0.0, abs(uv.y - lumCompressed)) * float4(1, 0, 0, 1);
    return half4(col);
// MARK: Fragment Shaders
fragment float scn_hdr_luminance_frag(scn::draw_quad_io_t in    [[stage_in]],
                                texture2d<float> input_tex      [[texture(0)]])
//    in.uv.y = 1. - in.uv.y;
    
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    float4 col = input_tex.sample(linear_sampler, in.uv);
    
    float3 Yxy = rgb_to_Yxy(col.rgb);
    float lum = toLogLum(Yxy.r);
    return lum;
#if (__METAL_VERSION__ < 120)
#error Need Metal Version 1.2
#endif
constant bool enableBloom                      [[ function_constant( 0) ]];
constant bool enableVignetting                 [[ function_constant( 1) ]];
constant bool enableColorGrading               [[ function_constant( 2) ]];
constant bool enableSaturation                 [[ function_constant( 3) ]];
constant bool enableContrast                   [[ function_constant( 4) ]];
constant bool enableColorFringe                [[ function_constant( 5) ]];
constant bool enableDebug                      [[ function_constant( 6) ]];
constant bool enableExposure                   [[ function_constant( 7) ]];
constant bool enableFrameLuminanceAutoExposure [[ function_constant( 8) ]];
constant bool enableHistogramAutoExposure      [[ function_constant( 9) ]];
constant bool enableDepthOfField               [[ function_constant(10) ]];
constant int  DOFSampleCount                   [[ function_constant(11) ]];
// Final gather (adaptation + tonemap + bloom + colorgrading)
fragment half4 scn_postprocess(scn::draw_quad_io_t                     in                     [[ stage_in ]],
                               texture2d<half>                         input_tex              [[ texture(0) ]],
                               texture2d<half>                         bloom_tex              [[ texture(1) ]],
                               texture3d<half>                         colorGrading_tex       [[ texture(2) ]],
                               texture2d<half>                         framelum_tex           [[ texture(3) ]],
                               texture1d<half>                         avglum_tex             [[ texture(4) ]],
                               texture2d<half>                         dof_tex                [[ texture(5) ]],
                               constant scn_postprocess_uniforms_t&    uni                    [[ buffer(0) ]],
                               constant scn_autoexposure_parameters_t& autoExposureParameters [[ buffer(1) ]])
    constexpr sampler linear_sampler(filter::linear);
    half4 col;
    
    col = input_tex.sample(linear_sampler, in.uv);
    
    if (enableColorFringe) {
        half ca = length_squared(in.uv - 0.5h) * uni.fringeStrength;
        half3 aberrationShift = half3(16.h / input_tex.get_width(), 0.h, -16.h / input_tex.get_width()) * ca;
        half3 fringe = col.rgb;
        fringe.x = input_tex.sample(linear_sampler, in.uv + float2( aberrationShift.x, 0) ).x;
        fringe.z = input_tex.sample(linear_sampler, in.uv + float2( aberrationShift.z, 0) ).z;
        col.rgb = mix(col.rgb, fringe.rgb, half(uni.fringeIntensity));
    }
    
    //Depth of field
    if (enableDepthOfField)
    {
        // 9 tap tent filter
        float2 invpixelsize = 1. / float2( dof_tex.get_width(), dof_tex.get_height() );
        float3 offset = float3(1., 0., -1.);
        
        half4 dof;
        half4 c0 = dof_tex.sample(linear_sampler, in.uv + offset.xx * invpixelsize );
        half4 c1 = dof_tex.sample(linear_sampler, in.uv + offset.yx * invpixelsize );
        half4 c2 = dof_tex.sample(linear_sampler, in.uv + offset.zx * invpixelsize );
        
        half4 c3 = dof_tex.sample(linear_sampler, in.uv + offset.xy * invpixelsize );
        half4 c4 = dof_tex.sample(linear_sampler, in.uv + offset.yy * invpixelsize );
        half4 c5 = dof_tex.sample(linear_sampler, in.uv + offset.zy * invpixelsize );
        
        
        half4 c6 = dof_tex.sample(linear_sampler, in.uv + offset.xz * invpixelsize );
        half4 c7 = dof_tex.sample(linear_sampler, in.uv + offset.yz * invpixelsize );
        half4 c8 = dof_tex.sample(linear_sampler, in.uv + offset.zz * invpixelsize );
        
        dof= c0 * 1.h + c1 * 2.h + c2 * 1.h +
             c3 * 2.h + c4 * 4.h + c5 * 2.h +
             c6 * 1.h + c7 * 2.h + c8 * 1.h;
        dof /= 16.h;
        
        col.rgb = mix(col.rgb, half3(dof.rgb), half(dof.a));
    }
    
    // Bloom
    if (enableExposure) {
        col.rgb = scn_tonemap(col.rgb, uni.whitePoint, autoExposureParameters.exposure);
    }
    
    if (enableBloom) {
        half3 bloom = bloom_tex.sample(linear_sampler, in.uv).rgb;
        col.rgb += bloom.rgb * uni.bloomIntensity;
    }
    
    
    // Color Grading
    if (enableColorGrading) {
        col.rgb = scn_colorgrading(col.rgb, half(uni.colorGradingIntensity), colorGrading_tex);
    }
    
    // contrast
    if (enableContrast) {
        half3 satCol = saturate(col.rgb);
        col.rgb = satCol - uni.contrast * (satCol - 1.h) * satCol * (satCol - 0.5h);
    }
    
    // saturate
    if (enableSaturation) {
        half lum = dot(col.rgb, half3(0.2126h, 0.7152h, 0.0722h));
        col.rgb = mix(half3(lum), col.rgb, half(uni.saturation));
    }
    
    // vignette
    if (enableVignetting) {
        col.rgb *= (1.h - uni.vignettingIntensity) + uni.vignettingIntensity * pow(16.0h * in.uv.x*in.uv.y*(1.0h-in.uv.x)*(1.0h-in.uv.y), uni.vignettingPower );
    }
    
    if (enableDebug) {
        constexpr sampler nearest_sampler(filter::nearest, mip_filter::nearest);
        float2 screenuv = { in.uv.x, 1. - in.uv.y };
        
        if (enableFrameLuminanceAutoExposure) {
            { // debug frame lum
                float4 rect = { 0.0, 0.0, 0.2, 0.2 };
                if (pointInRect(screenuv, rect)) {
                    float2 uv = rescalePointInRect(screenuv, rect);
                    int l = framelum_tex.get_num_mip_levels() - 3;
                    uv.y = 1. - uv.y;
                    return half4(framelum_tex.sample(nearest_sampler, uv, level(l)).x);
                }
            }
            { // debug avg lum
                float4 rect = { 0.2, 0.0, 0.2, 0.2 };
                if (pointInRect(screenuv, rect)) {
                    float2 uv = rescalePointInRect(screenuv, rect);
                    return half4(avglum_tex.sample(nearest_sampler, uv.x).x);
                }
            }
            { // debug tonemap
                float4 rect = { 0.4, 0.0, 0.2, 0.2 };
                if (pointInRect(screenuv, rect)) {
                    return draw_tonemap_curve(rescalePointInRect(screenuv, rect), uni, autoExposureParameters);
                }
            }
        }
        
        if (enableBloom) { // debug bloom
            float4 rect = { 0.6, 0.0, 0.2, 0.2 };
            if (pointInRect(screenuv, rect)) {
                float2 uv = rescalePointInRect(screenuv, rect);
                uv.y = 1. - uv.y;
                return half4(bloom_tex.sample(linear_sampler, uv));
            }
        }
        if (enableColorGrading) { // debug color_grading
            float4 rect = { 0.8, 0.0, 0.2, 0.2 };
            constexpr sampler smp(filter::nearest, mip_filter::nearest, address::clamp_to_zero);
            float2 alluv = rescalePointInRect(float2(in.uv.x, 1. - in.uv.y), rect);
            for (uint z = 0; z < 16; ++z) {
                float x = z % 4;
                float y = z / 4;
                float2 uv = rescalePointInRect(alluv, float4(x * 0.25, y * 0.25, 0.25, 0.25));
                half4 grad = colorGrading_tex.sample(smp, float3(uv.x, 1. - uv.y, z / 15.1));
                col.rgb = grad.rgb * grad.a + col.rgb * (1. - grad.a); // over operator
            }
        }
        
    }
    
    return half4(col);
// MARK: Compute Kernels
////////////////////////////////////////////////////////////
// Adaptative luminance
kernel void frame_luminance(uint2                            index      [[ thread_position_in_grid ]],
                            texture2d<float, access::sample> input_tex  [[ texture(0) ]],
                            texture2d<float, access::write>  output_tex [[ texture(1) ]]
                            )
    if (index.x >= output_tex.get_width() || index.y >= output_tex.get_height())
        return;
    
    // TODO we should go through the last line/colum
    uint2 tileSize = uint2(input_tex.get_width(), input_tex.get_height()) / uint2(output_tex.get_width(), output_tex.get_height());
    uint2 srcIndex = index * tileSize;
    
    float4 sumCol = 0.f;
    for (uint y = 0; y < tileSize.y; ++y) {
        for (uint x = 0; x < tileSize.x; ++x) {
            sumCol += input_tex.read(srcIndex + uint2(x,y));
        }
    }
    sumCol /= (tileSize.x * tileSize.y);
    
    float3 Yxy = rgb_to_Yxy(sumCol.rgb);
    float lum = toLogLum(Yxy.x);
    output_tex.write(lum, index);
kernel void sliding_lum(constant scn_postprocess_uniforms_t& uni         [[ buffer(0) ]],
                        texture1d<float, access::write>      avgLumTex   [[ texture(0) ]],
                        texture2d<float>                     frameLumTex [[ texture(1) ]]
                        )
    // read in the middle of the last mip of the frame texture mipmap chain
    constexpr sampler smp(filter::nearest, mip_filter::nearest);
    int l = frameLumTex.get_num_mip_levels() - 1;
    float frameLum = frameLumTex.sample(smp, float2(0.5), level(l)).r;
    
    // write it at the current frame
    avgLumTex.write(frameLum, uni.adaptationCurrentFrame);
static float scn_adaptative_luminance(constant scn_postprocess_uniforms_t& uniforms [[ buffer(0) ]],
                                      float                                currentLuminance,
                                      float                                targetLuminance)
    float tau = mix(uniforms.exposureAdaptationDarkeningSpeedFactor, uniforms.exposureAdaptationBrighteningSpeedFactor, step(targetLuminance, currentLuminance));
    return currentLuminance + (targetLuminance - currentLuminance) * (1.0 - exp(-uniforms.dt * tau));
kernel void adaptative_lum(constant scn_postprocess_uniforms_t& uni       [[ buffer(0) ]],
                           device scn_autoexposure_parameters_t&     output    [[ buffer(1) ]],
                           texture1d<float, access::read>       avgLumTex [[ texture(0)]])
    // now compute the sliding average
    float avgSum = 0.f;
    uint count = uni.adaptationFrameCount;
    for (uint i = 0; i < count; ++i) {
        avgSum += avgLumTex.read(i).x;
    }
    
#if ADAPTATIVE_DECAY
    float targetLum   = fromLogLum(avgSum / count);
    output.averageLum = scn_adaptative_luminance(uni, output.averageLum, targetLum);
#else
    output.averageLum = fromLogLum(avgSum / count);
#endif
    output.averageLum = precise::max(output.averageLum, 0.00001);
    output.exposure   = scn_exposure(uni, output.averageLum);
kernel void fixed_lum(constant scn_postprocess_uniforms_t& uni  [[ buffer(0) ]],
                      device   scn_autoexposure_parameters_t& output [[ buffer(1) ]])
    output.averageLum = 0.18; // default value for average gray, to match the adaptation
    output.exposure   = scn_exposure(uni, output.averageLum);
kernel void histogram_adaptative_luminance(constant scn_postprocess_uniforms_t& uniforms [[ buffer(0) ]],
                                           constant scn_histogram_analysis_t&   analysis [[ buffer(1) ]],
                                           device   scn_autoexposure_parameters_t&   output   [[ buffer(2) ]])
    output.averageLum = scn_adaptative_luminance(uniforms, output.averageLum, analysis.adjustedAverage);
    output.exposure   = scn_exposure(uniforms, output.averageLum);
kernel void histogram_immediate_luminance(constant scn_postprocess_uniforms_t& uniforms [[ buffer(0) ]],
                                          constant scn_histogram_analysis_t&   analysis [[ buffer(1) ]],
                                          device   scn_autoexposure_parameters_t&   output   [[ buffer(2) ]])
    output.averageLum = analysis.adjustedAverage;
    output.exposure   = scn_exposure(uniforms, output.averageLum);
#pragma MARK Bloom Blur
static half4 bloom_blur_frag(uint pairCount,
                             scn::draw_quad_io_t in [[stage_in]],
                             texture2d<float> textureSampler0,
                             constant scn_bloom_uniforms_t& uniforms
                             )
    constexpr sampler samp(filter::linear);
    
    uint index = 0;
    float4 c = textureSampler0.sample(samp, in.uv);
    float4 accum = c * uniforms.offsets_weight[index].z;
    float total = uniforms.offsets_weight[index].z;
    
    for (uint i = 0; i < pairCount; ++i) {
        float3 ow = uniforms.offsets_weight[1 + i];
        accum += textureSampler0.sample(samp, in.uv + ow.xy) * ow.z;
        accum += textureSampler0.sample(samp, in.uv - ow.xy) * ow.z;
        total += 2.f * ow.z;
    }
    
    accum /= total;
    return half4(accum);
fragment half4 bloom_blur_frag_1(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(1, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_2(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(2, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_3(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(3, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_4(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(4, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_5(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(5, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_6(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(6, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_7(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(7, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_8(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(8, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_9(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(9, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_10(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(10, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_11(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(11, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_12(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(12, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_13(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(13, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_14(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(14, in, textureSampler0, uniforms);
fragment half4 bloom_blur_frag_15(scn::draw_quad_io_t in [[stage_in]], texture2d<float> textureSampler0 [[texture(0)]], constant scn_bloom_uniforms_t& uniforms [[buffer(0)]])
    return bloom_blur_frag(15, in, textureSampler0, uniforms);
// ---------------------------------------------------
// Depth of field
// Generate the sampling kernel
kernel void dof_compute_kernel(constant scn_postprocess_uniforms_t&    uni     [[ buffer(0)  ]],
                               device float2*                          offsets [[ buffer(1) ]])
//    const float fMin = 36.;
//    const float fMax = 2.;
    float f = 1.;//(uni.fStop-fMin) / (fMax-fMin);
    int ngon = uni.dofBladeCount;
    
    float N = sqrt( float(DOFSampleCount) );
    const float PI4 = PI/4.;
    int i = 0;
    
    for(float x = 0.; x<N; x+=1.)
    for(float y = 0.; y<N; y+=1.)
    {
        float2 p = float2(x,y) / float2( N - 1.) * 2. - 1.;
        
        float2 r1(0.),r2(0.),r3(0.),r4(0.);
        
        if(p.x != 0.)
        {
            r1 = float2( p.x, PI4 * (p.y/p.x) );
            r3 = float2(-p.x, PI4 * (4. + (p.y/p.x)) );
        }
        if(p.y != 0.)
        {
            r2 = float2( p.y, PI4 * (2. - p.x/p.y) );
            r4 = float2(-p.y, PI4 * (6. - (p.x/p.y)) );
        }
        float2 a = mix(r1, r2, step(0., p.y-p.x));
        float2 b = mix(r3, r4, step(0., p.x-p.y));
        
        float2 rphi = mix(b, a, step(0., p.y+p.x));
        
        rphi.y += f;
        rphi.x *= (f > 0.0) ? pow( cos(PI / ngon) / cos( rphi.y - ( 2. * PI / ngon ) * floor( ( ngon * rphi.y + PI ) / ( 2. * PI ) ) ) , f) : 1.;
        
    
        offsets[i++] = float2( cos(rphi.y), sin(rphi.y) ) * rphi.x;
    }
// Downsample Bloom + CoC
// near CoC -
// far CoC +
static void downsample(ushort2                         index         [[ thread_position_in_grid ]],
                       ushort                          downsample,
                       bool                            computeBloom,
                       bool                            computeDOF,
                       depth2d<float, access::sample>  depthSampler  [[ texture(0) ]],
                       texture2d<half, access::sample> colorSampler  [[ texture(1) ]],
                       texture2d<half, access::write>  outDOF        [[ texture(2) ]],
                       texture2d<half, access::write>  outBloom      [[ texture(3) ]],
                       constant scn_postprocess_uniforms_t&    uni   [[ buffer(0)  ]],
                       constant scn_autoexposure_parameters_t& outbuf[[ buffer(1)  ]])
    if (index.x >= outDOF.get_width() || index.y >= outDOF.get_height())
        return;
    
    float2 invRes = 1. / float2( (float)colorSampler.get_width(), (float)colorSampler.get_height() );
    float2 uv = (float2(index*downsample) + 1. ) * invRes;
    
    constexpr sampler linear_sampler(filter::linear, address::clamp_to_zero);
    
    // Down sample color buffer
    half4 col = 0.h;
    float4 depth = 0.;
    
    if(downsample == 4)
    {
        col.rgb += colorSampler.sample(linear_sampler, uv, int2(0, 0)).rgb;
        col.rgb += colorSampler.sample(linear_sampler, uv, int2(2, 0)).rgb;
        col.rgb += colorSampler.sample(linear_sampler, uv, int2(0, 2)).rgb;
        col.rgb += colorSampler.sample(linear_sampler, uv, int2(2, 2)).rgb;
        col.rgb /= 4;
        depth += depthSampler.gather(linear_sampler, uv, int2(0, 0));
        depth += depthSampler.gather(linear_sampler, uv, int2(2, 0));
        depth += depthSampler.gather(linear_sampler, uv, int2(0, 2));
        depth += depthSampler.gather(linear_sampler, uv, int2(2, 2));
        depth /= 4;
    }
    else
    { // downsample 2x
        col.rgb = colorSampler.sample(linear_sampler, uv).rgb;
        depth = depthSampler.gather(linear_sampler, uv);
    }
    if(computeDOF)
    {
        
        half4 cocs = half4( -(depth * uni.dofCocScaleBias.x + uni.dofCocScaleBias.y) );
        
        // Output CoC = average of CoCs
        half nCoC = min(-cocs.x, min(-cocs.y, min(-cocs.z, -cocs.w)));
        half fCoC = max(cocs.x, max(cocs.y, max(cocs.z, cocs.w)));
        
        col.a = max(nCoC, fCoC)*sign(-nCoC);
        outDOF.write( col, index);
    }
    if(computeBloom)
    {
        col.rgb = half3( scn_tonemap_threshold(float3(col.rgb), uni, outbuf.exposure) );
        outBloom.write( col, index);
    }
    
kernel void downsample_2x_bloom(ushort2                         index         [[ thread_position_in_grid ]],
                                depth2d<float, access::sample>  depthSampler  [[ texture(0) ]],
                                texture2d<half, access::sample> colorSampler  [[ texture(1) ]],
                                texture2d<half, access::write>  outDOF        [[ texture(2) ]],
                                texture2d<half, access::write>  outBloom      [[ texture(3) ]],
                                constant scn_postprocess_uniforms_t&    uni   [[ buffer(0)  ]],
                                constant scn_autoexposure_parameters_t& outbuf[[ buffer(1)  ]])
    downsample(index, 2, true, false, depthSampler, colorSampler, outDOF, outBloom, uni, outbuf);
kernel void downsample_2x_dof(ushort2                         index         [[ thread_position_in_grid ]],
                              depth2d<float, access::sample>  depthSampler  [[ texture(0) ]],
                              texture2d<half, access::sample> colorSampler  [[ texture(1) ]],
                              texture2d<half, access::write>  outDOF        [[ texture(2) ]],
                              texture2d<half, access::write>  outBloom      [[ texture(3) ]],
                              constant scn_postprocess_uniforms_t&    uni   [[ buffer(0)  ]],
                              constant scn_autoexposure_parameters_t& outbuf[[ buffer(1)  ]])
    downsample(index, 2, false, true, depthSampler, colorSampler, outDOF, outBloom, uni, outbuf);
kernel void downsample_2x_bloom_dof(ushort2                         index         [[ thread_position_in_grid ]],
                                    depth2d<float, access::sample>  depthSampler  [[ texture(0) ]],
                                    texture2d<half, access::sample> colorSampler  [[ texture(1) ]],
                                    texture2d<half, access::write>  outDOF        [[ texture(2) ]],
                                    texture2d<half, access::write>  outBloom      [[ texture(3) ]],
                                    constant scn_postprocess_uniforms_t&    uni   [[ buffer(0)  ]],
                                    constant scn_autoexposure_parameters_t& outbuf[[ buffer(1)  ]])
    downsample(index, 2, true, true, depthSampler, colorSampler, outDOF, outBloom, uni, outbuf);
kernel void downsample_4x_bloom(ushort2                         index         [[ thread_position_in_grid ]],
                                depth2d<float, access::sample>  depthSampler  [[ texture(0) ]],
                                texture2d<half, access::sample> colorSampler  [[ texture(1) ]],
                                texture2d<half, access::write>  outDOF        [[ texture(2) ]],
                                texture2d<half, access::write>  outBloom      [[ texture(3) ]],
                                constant scn_postprocess_uniforms_t&    uni   [[ buffer(0)  ]],
                                constant scn_autoexposure_parameters_t& outbuf[[ buffer(1)  ]])
    downsample(index, 4, true, false, depthSampler, colorSampler, outDOF, outBloom, uni, outbuf);
kernel void downsample_4x_dof(ushort2                         index         [[ thread_position_in_grid ]],
                              depth2d<float, access::sample>  depthSampler  [[ texture(0) ]],
                              texture2d<half, access::sample> colorSampler  [[ texture(1) ]],
                              texture2d<half, access::write>  outDOF        [[ texture(2) ]],
                              texture2d<half, access::write>  outBloom      [[ texture(3) ]],
                              constant scn_postprocess_uniforms_t&    uni   [[ buffer(0)  ]],
                              constant scn_autoexposure_parameters_t& outbuf[[ buffer(1)  ]])
    downsample(index, 4, false, true, depthSampler, colorSampler, outDOF, outBloom, uni, outbuf);
kernel void downsample_4x_bloom_dof(ushort2                         index         [[ thread_position_in_grid ]],
                                    depth2d<float, access::sample>  depthSampler  [[ texture(0) ]],
                                    texture2d<half, access::sample> colorSampler  [[ texture(1) ]],
                                    texture2d<half, access::write>  outDOF        [[ texture(2) ]],
                                    texture2d<half, access::write>  outBloom      [[ texture(3) ]],
                                    constant scn_postprocess_uniforms_t&    uni   [[ buffer(0)  ]],
                                    constant scn_autoexposure_parameters_t& outbuf[[ buffer(1)  ]])
    downsample(index, 4, true, true, depthSampler, colorSampler, outDOF, outBloom, uni, outbuf);
// Downsample CoC 4x
kernel void dof_coc_downsample4(ushort2                        index    [[ thread_position_in_grid ]],
                                texture2d<half>                input_tex  [[ texture(0) ]],
                                texture2d<half, access::write> output_tex  [[ texture(1) ]],
                                constant scn_postprocess_uniforms_t&    uni [[ buffer(0)  ]])
    if (index.x >= output_tex.get_width() || index.y >= output_tex.get_height())
        return;
    
    half4 col = 0.f;
    
    float2 invRes = 1. / float2( (float)input_tex.get_width(), (float)input_tex.get_height() );
    float2 uv = (float2(index * 4) + 1.) * invRes;
    
    constexpr sampler linear_sampler(filter::linear, address::clamp_to_zero);
    col += input_tex.sample(linear_sampler, uv, int2(0, 0)).aaaa;
    col += input_tex.sample(linear_sampler, uv, int2(2, 0)).aaaa;
    col += input_tex.sample(linear_sampler, uv, int2(0, 2)).aaaa;
    col += input_tex.sample(linear_sampler, uv, int2(2, 2)).aaaa;
    col /= 4.h;
    
    
    output_tex.write(col, index);
    
// Blur Near CoC
kernel void dof_coc_blurV(ushort2                          index       [[ thread_position_in_grid ]],
                          texture2d<half, access::sample>  cocSampler [[ texture(0) ]],
                          texture2d<half, access::write>   out         [[ texture(1) ]],
                          constant scn_postprocess_uniforms_t&    uni [[ buffer(0)  ]])
    if (index.x >= out.get_width() || index.y >= out.get_height())
        return;
    
    float2 invRes = 1. / float2( (float)cocSampler.get_width(), (float)cocSampler.get_height() );
    float2 uv = (float2(index)+float2(.5)) * invRes;
    
    constexpr sampler samp(filter::linear);
    
    int radius = 5;
    half2 coc = 0.h;
    for(int i=-radius; i<=radius; i++)
    {
        half c = cocSampler.sample(samp, uv + float2(i,0)*invRes ).r;
        coc.r += max(0.h,-c);
        coc.g += max(0.h,c);
    }
    coc.rg /= radius*2.h;
    
    out.write( half4(coc, 0.h, 0.h), index );
kernel void dof_coc_blurH(ushort2                          index         [[ thread_position_in_grid ]],
                          texture2d<half, access::sample>  cocSampler  [[ texture(0) ]],
                          texture2d<half, access::write>   out         [[ texture(1) ]],
                          texture2d<half, access::sample>  colorCoCSampler  [[ texture(2) ]],
                          constant scn_postprocess_uniforms_t&    uni [[ buffer(0)  ]])
    if (index.x >= out.get_width() || index.y >= out.get_height())
        return;
    
    float2 invRes = 1. / float2( (float)cocSampler.get_width(), (float)cocSampler.get_height() );
    float2 uv = (float2(index)+float2(.5)) * invRes;
    
    constexpr sampler samp(filter::linear);
    
    int radius = 5;
    half2 coc = 0.h;
    for(int i=-radius; i<=radius; i++)
    {
        half2 c = cocSampler.sample(samp, uv + float2(0,i)*invRes ).rg;
        coc.r += c.r;
        coc.g += c.g;
    }
    coc.rg /= radius*2.h;
    
    out.write( half4(coc, 0.h, 0.h), index );
struct dof_kernel {
    float2 offsets[MAX_DOF_SAMPLE_COUNT];
// Bokeh filter
kernel void dof_blur(ushort2                                 index           [[ thread_position_in_grid ]],
                     texture2d<half, access::sample>         colorCoCSampler [[ texture(0) ]],
                     texture2d<half, access::sample>         blurCocSampler  [[ texture(1) ]],
                     texture2d<half, access::write>          out             [[ texture(2) ]],
                     constant scn_postprocess_uniforms_t&    uni             [[ buffer(0)  ]],
                     constant dof_kernel&                    cocKernel       [[ buffer(1) ]])
    if (index.x >= out.get_width() || index.y >= out.get_height())
        return;
    
    float2 invRes = 1.f / float2( (float)out.get_width(), (float)out.get_height() );
    float2 uv = (float2(index)+float2(.5)) * invRes;
    constexpr sampler samp(filter::linear);
    
    
    half4 base = colorCoCSampler.sample(samp, uv );
    half2 bCoC = blurCocSampler.sample(samp, uv ).xy;
    bCoC.y = max(bCoC.y, base.a);
    
    half2 radius = half2( bCoC.r, bCoC.g ) * half2(uni.dofIntensity);
    
    
    
    // Accumulate
    half4 fAcc = 0.0h; // Far field
    half4 nAcc = 0.0h; // Near field
    for(int i=0; i<DOFSampleCount;i++)
    {
        float2 disp = cocKernel.offsets[i];
        float2 duv = float2(disp.x, disp.y) * invRes;
        
        half4 nc = colorCoCSampler.sample(samp, uv + duv * radius.r );
        half4 fc = colorCoCSampler.sample(samp, uv + duv * radius.g );
        
        
        nAcc += half4(nc.rgb, saturate(-nc.a));
        fAcc += half4(fc.rgb, 1.0) * step(0.h, fc.a * bCoC.g );
    }
    
    // Normalize
    fAcc.rgb /= fAcc.a + (fAcc.a == 0.0h);
    nAcc.rgba /= half(DOFSampleCount);
    
    nAcc.a = saturate(2.h * nAcc.a); // magic trick to reduce ghost on the near blur !
    
    // Blend
    half4 col = 0.h;
    col.rgb = mix(base.rgb, fAcc.rgb, saturate(base.a));
    col.rgb =  mix(col.rgb, nAcc.rgb, half3(nAcc.a));
    col.a = saturate( max(nAcc.a,base.a) ) * uni.dofIntensity;
    
    
    out.write(col, index);
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
uniform sampler2D u_sampler;
void main()
    vec4 mask = texture2D(u_sampler, v_texCoord);
    gl_FragColor = v_vertexColor * mask;
#extension GL_OES_standard_derivatives : enable
precision highp float; 
uniform vec4 u_color;
varying vec3 v_vertexCenter;
#if 0
// Fragment shader function
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x);
vec3 smooth(vec3 edge0, vec3 edge1, vec3 x)
    vec3 t = clamp((x - edge0)/(edge1 - edge0), vec3(0.), vec3(1));
    return t * t * (3. - 2. * t);
#endif
void main()
    vec3 d = fwidth(v_vertexCenter);
    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, v_vertexCenter);
    //    vec3 a3 = smoothstep(vec3(0.0), d * 1.5, in.center);
    float edge =  min(min(a3.x, a3.y), a3.z);
    if (edge >= 1.0)
        discard;
    gl_FragColor = u_color * (1.0 - edge) * 0.95;
attribute vec4 a_position;
uniform mat4 u_modelViewProjectionTransform;
void main(void)
gl_Position = u_modelViewProjectionTransform * a_position;
struct SCNShaderLight
vec4 intensity; // lowp, light intensity
vec3 direction; // mediump, vector from the point toward the light
    
    // private
    float _att;
    vec3 dir; // lowp, vector from the point to the light for point and spot, dist attenuations
    float dist; // mediump, distance from the point to the light (same coord. than range)
void main()
    gl_FragColor = vec4(1.,0.,0.,1.);
uniform mat4 u_modelTransform;
#define MOD2 vec2(443.8975,397.2973)
float hash(vec2 p)
    p  = fract(p * MOD2);
    p += dot(p.xy, p.yx+19.19);
    return fract(p.x * p.y);
void main()
    float x = hash(u_modelTransform[3].xy);
gl_FragColor = vec4(vec3(x+1./255.),1.);
namespace scn {
    
    // MARK: - Matrix/Vector utils
    
    constant ushort2 gatherUV[4] =
    {
        ushort2(0,1),
        ushort2(1,1),
        ushort2(1,0),
        ushort2(0,0),
    };
    
    inline half4 scn_vector_min_and_indices(half4x4 v, thread ushort4 &outIndices)
    {
        const ushort4 i0 = ( 0 );
        const ushort4 i1 = ( 1 );
        const ushort4 i2 = ( 2 );
        const ushort4 i3 = ( 3 );
        half4x4     t = transpose(v);
        half4 min_xy  = min(t[0], t[1]);
        ushort4  ind_xy  = select(i0, i1, t[0] >= t[1]);
        half4 min_zw  = min(t[2], t[3]);
        ushort4  ind_zw  = select(i2, i3, t[2] >= t[3]);
        outIndices     = select(ind_xy, ind_zw, min_xy > min_zw);
        return min(min_xy, min_zw);
    }
    
    inline half4 scn_vector_max_and_indices(half4x4 v, thread ushort4 &outIndices)
    {
        const ushort4 i0 = ( 0 );
        const ushort4 i1 = ( 1 );
        const ushort4 i2 = ( 2 );
        const ushort4 i3 = ( 3 );
        half4x4     t = transpose(v);
        half4 max_xy  = max(t[0], t[1]);
        ushort4 ind_xy   = select(i0, i1, t[0] < t[1]);
        half4 max_zw  = max(t[2], t[3]);
        ushort4 ind_zw   = select(i2, i3, t[2] < t[3]);
        outIndices     = select(ind_xy, ind_zw, max_xy < max_zw);
        return max(max_xy, max_zw);
    }
    
    // 20 inst (15 with AVX)
    inline ushort scn_vector_min_index(half4 v)
    {
        ushort4 ind = { 0, 1, 2, 3  };
        half4 min_lh = min(v, v.zwxy);
        ushort4 min_ind_lh = select(ind, ind.zwxy, v > v.zwxy);
        return (min_lh.x < min_lh.y) ? min_ind_lh.x : min_ind_lh.y;
    }
    // 20 inst (15 with AVX)
    inline ushort scn_vector_max_index(half4 v)
    {
        ushort4 ind = { 0, 1, 2, 3  };
        half4 min_lh = max(v, v.zwxy);
        ushort4 min_ind_lh = select(ind, ind.zwxy, v < v.zwxy);
        return (min_lh.x > min_lh.y) ? min_ind_lh.x : min_ind_lh.y;
    }
    // MARK: - Drawing quads
    
    struct draw_quad_io_t {
        float4 position [[ position ]];
        float2 uv;
    };
    
    /*   Counterclockwise version            *   Clockwise version
     *                                       *
     *   pos = -1, 1           pos =  1, 1   *   pos = -1, 1           pos =  1, 1
     *   uv  =  0, 0           uv  =  1, 0   *   uv  =  0, 0           uv  =  1, 0
     *                                       *
     *               [2]--[3]                *               [1]--[3]
     *                | \  |                 *                | \  |
     *                |  \ |                 *                |  \ |
     *               [0]--[1]                *               [0]--[2]
     *                                       *
     *   pos = -1,-1           pos =  1,-1   *   pos = -1,-1           pos =  1,-1
     *   uv  =  0, 1           uv  =  1, 1   *   uv  =  0, 1           uv  =  1, 1
     *                                       *
     */
    
    
    inline float4 draw_quad_pos_from_id(uint v_id, float depth)
    {
        return float4((v_id % 2) * 2.0 - 1.0,
                      (v_id / 2) * 2.0 - 1.0,
                      depth,
                      1.0);
    }
    
    inline float2 draw_quad_texcoord_from_id(uint v_id)
    {
        return float2(v_id % 2,
                      1 - v_id / 2);
    }
    
    inline float4 draw_quad_pos_from_id_cw(uint v_id, float depth)
    {
        return float4((v_id / 2) * 2.0 - 1.0,
                      (v_id % 2) * 2.0 - 1.0,
                      depth,
                      1.0);
    }
    
    inline float2 draw_quad_texcoord_from_id_cw(uint v_id)
    {
        return float2(v_id / 2,
                      1 - v_id % 2);
    }
    
    // MARK: - Color conversion
    
    inline float3 rgb_to_Yxy(float3 rgb) {
        // RGB -> XYZ conversion (following ITU-R BT.709)
        const float3x3 RGB2XYZ = {
            {0.4125, 0.3576, 0.1805},
            {0.212671, 0.715160, 0.072169},
            {0.0193, 0.1192, 0.9505},
        };
        rgb = max(rgb, 0.00001);
        
        float3 XYZ = rgb *  RGB2XYZ;
        
        // XYZ -> Yxy conversion
        
        float3 Yxy;
        Yxy.r = XYZ.g;
        
        //Yxy.r = rgb.r * 0.212671 + rgb.g * 0.715160 + rgb.b * 0.072169;
        
        // x = X / (X + Y + Z)
        // y = X / (X + Y + Z)
        Yxy.gb = XYZ.rg / dot(1.0, XYZ.rgb);
        
        return Yxy;
    }
    
    inline float3 Yxy_to_rgb(float3 Yxy) {
        
        Yxy.b = max(Yxy.b, 0.00001);
        
        float3 XYZ;
        // Yxy -> XYZ conversion
        XYZ.r = Yxy.r * Yxy.g / Yxy.b;
        
        // X = Y * x / y
        XYZ.g = Yxy.r;
        
        // copy luminance Y
        XYZ.b = Yxy.r * (1 - Yxy.g - Yxy.b) / Yxy.b;
        
        // Z = Y * (1-x-y) / y
        
        // XYZ -> RGB conversion (following ITU-R BT.709)
        const float3x3 XYZ2RGB = {
            { 3.2410, -1.5374, -0.4986 },
            { -0.9692, 1.8760, 0.0416  },
            { 0.0556, -0.2040, 1.0570  }
        };
        
        return XYZ * XYZ2RGB;
    }
    
    inline float linearLuminanceToPerceptual(float luminance)
    {
        return log(max(luminance, 0.001f));
    }
    
    inline float perceptualLuminanceToLinear(float luminance)
    {
        return exp(luminance);
    }
    
uniform vec3 CocScaleBias;
uniform sampler2D colorSampler;
uniform sampler2D depthSampler;
uniform vec2 u_inversePixelSize;
varying vec2 v_tcColor0;
varying vec2 v_tcColor1;
varying vec2 v_tcDepth0;
varying vec2 v_tcDepth1;
varying vec2 v_tcDepth2;
varying vec2 v_tcDepth3;
vec4 saturate(vec4 val)
    return clamp(val, vec4(0.), vec4(1.));
void main (void)
    // "rowOfs" reduces how many moves PS2.0 uses to emulate swizzling.
//    vec2 dofRowDelta = vec2(0., 0.25 * invPixelSize.y);
    vec4 dofRowDelta = vec4(0., 1., 2., 3.) * u_inversePixelSize.y * 0.25;
    vec2 rowOfs[4];
    rowOfs[0] = dofRowDelta.xx; // 0,0 useless...
    rowOfs[1] = dofRowDelta.xy;
    rowOfs[2] = dofRowDelta.xz;
    rowOfs[3] = dofRowDelta.xw;
    
    // Use bilinear filtering to average 4 color samples for free.
    vec3 color;
    color  = texture2D( colorSampler, v_tcColor0.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy ).rgb;
    color += texture2D( colorSampler, v_tcColor0.xy + rowOfs[2] ).rgb;
    color += texture2D( colorSampler, v_tcColor1.xy + rowOfs[2] ).rgb;
    color *= 0.25;
    
    vec4 depth;
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[0] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[0] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[0] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[0] ).r;
    vec4 coc = abs(depth * CocScaleBias.x + CocScaleBias.y);
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[1] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[1] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[1] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[1] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[2] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[2] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[2] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[2] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    
    depth[0] = texture2D( depthSampler, v_tcDepth0.xy + rowOfs[3] ).r;
    depth[1] = texture2D( depthSampler, v_tcDepth1.xy + rowOfs[3] ).r;
    depth[2] = texture2D( depthSampler, v_tcDepth2.xy + rowOfs[3] ).r;
    depth[3] = texture2D( depthSampler, v_tcDepth3.xy + rowOfs[3] ).r;
    coc 
 = max(coc, abs(depth * CocScaleBias.x + CocScaleBias.y));
    float maxCoc = max( max( coc.x, coc.y ), max( coc.z, coc.w ) );
    //
    // this pass should be use to mark the zone not to blur = the zone which are in focus
gl_FragColor = vec4(color, maxCoc);
#import <metal_stdlib>
#import <metal_compute>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-PostProcessUtils.h"
// for cubemap utilities
#import "C3D-PBR.metal"
// MARK: Structures
#define USE_PRECISE_SOLIDANGLE 0
namespace scn {
    struct sh3_vector {
        float4 V0;
        float4 V1;
        float  V2;
    };
    
    struct sh3_rgb {
        float red[9];
        float green[9];
        float blue[9];
    };
    
    inline float dot_sh3_vector(sh3_vector A, sh3_vector B)
    {
        float Result = dot(A.V0, B.V0);
        Result += dot(A.V1, B.V1);
        Result += A.V2 * B.V2;
        return Result;
    }
    
    inline sh3_vector shVectorFromSh(float const constant sh[9])
    {
        sh3_vector res;
        res.V0 = float4(sh[0], sh[1], sh[2], sh[3]);
        res.V1 = float4(sh[4], sh[5], sh[6], sh[7]);
        res.V2 = sh[8];
        return res;
    }
// MARK: SH computation (from cubemap)
// warning: these functions works with the degree of the basis -> degree == order - 1
inline void sh_eval_basis(int shOrder, float3 dir, float b[9])
    if (shOrder > 0) {
        b[0] = 0.282095f;
    }
    if (shOrder > 1) {
        b[1] =-0.488603f *  dir.y;
        b[2] = 0.488603f *  dir.z;
        b[3] =-0.488603f *  dir.x;
    }
    if (shOrder > 2) {
        float3 d2 = dir * dir;
        b[4] = 1.092548f *  dir.x * dir.y;
        b[5] =-1.092548f *  dir.y * dir.z;
        b[6] = 0.315392f * (3 * d2.z - 1);
        b[7] =-1.092548f *  dir.x * dir.z;
        b[8] = 0.546274f * (d2.x - d2.y);
    }
inline void sh_eval_basis_3(float x,float y,float z, float b[16])
    const float z2 = z*z;
    
    /* m=0 */
    const float p_0_0 = 0.282094791773878140;
    b[  0] = p_0_0; // l=0,m=0
    const float p_1_0 = 0.488602511902919920 * z;
    b[  2] = p_1_0; // l=1,m=0
    const float p_2_0 = 0.946174695757560080 * z2 + -0.315391565252520050;
    b[  6] = p_2_0; // l=2,m=0
    const float p_3_0 = z*(1.865881662950577000 * z2 + -1.119528997770346200);
    b[ 12] = p_3_0; // l=3,m=0
    
    
    /* m=1 */
    const float s1 = y;
    const float c1 = x;
    const float p_1_1 = -0.488602511902919920;
    b[  1] = p_1_1*s1; // l=1,m=-1
    b[  3] = p_1_1*c1; // l=1,m=+1
    const float p_2_1 = -1.092548430592079200 * z;
    b[  5] = p_2_1*s1; // l=2,m=-1
    b[  7] = p_2_1*c1; // l=2,m=+1
    const float p_3_1 = -2.285228997322328800 * z2 + 0.457045799464465770;
    b[ 11] = p_3_1*s1; // l=3,m=-1
    b[ 13] = p_3_1*c1; // l=3,m=+1
    
    /* m=2 */
    const float s2 = x*s1 + y*c1;
    const float c2 = x*c1 - y*s1;
    const float p_2_2 = 0.546274215296039590;
    b[  4] = p_2_2*s2; // l=2,m=-2
    b[  8] = p_2_2*c2; // l=2,m=+2
    const float p_3_2 = 1.445305721320277100 * z;
    b[ 10] = p_3_2*s2; // l=3,m=-2
    b[ 14] = p_3_2*c2; // l=3,m=+2
    
    
    /* m=3 */
    const float s3 = x*s2 + y*c2;
    const float c3 = x*c2 - y*s2;
    const float p_3_3 = -0.590043589926643520;
    b[  9] = p_3_3*s3; // l=3,m=-3
    b[ 15] = p_3_3*c3; // l=3,m=+3
#if USE_PRECISE_SOLIDANGLE
inline float3 vector(int f, float x, float y, float z)
    float3 X, Y, Z;
    switch (f) {
        case 0:
            X = (float3){ 0.0,  0.0,  1.0 };
            Y = (float3){ 0.0,  1.0,  0.0 };
            Z = (float3){-1.0,  0.0,  0.0 };
            break;
        case 1:
            X = (float3){ 0.0,  0.0, -1.0 };
            Y = (float3){ 0.0,  1.0,  0.0 };
            Z = (float3){ 1.0,  0.0,  0.0 };
            break;
        case 2:
            X = (float3){-1.0,  0.0,  0.0 };
            Y = (float3){ 0.0,  0.0, -1.0 };
            Z = (float3){ 0.0, -1.0,  0.0 };
            break;
        case 3:
            X = (float3){-1.0,  0.0,  0.0 };
            Y = (float3){ 0.0,  0.0,  1.0 };
            Z = (float3){ 0.0,  1.0,  0.0 };
            break;
        case 4:
            X = (float3){-1.0,  0.0,  0.0 };
            Y = (float3){ 0.0,  1.0,  0.0 };
            Z = (float3){ 0.0,  0.0, -1.0 };
            break;
        case 5:
            X = (float3){ 1.0,  0.0,  0.0 };
            Y = (float3){ 0.0,  1.0,  0.0 };
            Z = (float3){ 0.0,  0.0,  1.0 };
            break;
            
    }
    
    float3 w;
    w.x = X[0] * x + Y[0] * y + Z[0] * z;
    w.y = X[1] * x + Y[1] * y + Z[1] * z;
    w.z = X[2] * x + Y[2] * y + Z[2] * z;
    
    return normalize(w);
inline float solid_angle(const float3 a,
                   const float3 b,
                   const float3 c)
    float n = fabs(a[0] * (b[1] * c[2] - b[2] * c[1]) +
                    a[1] * (b[2] * c[0] - b[0] * c[2]) +
                    a[2] * (b[0] * c[1] - b[1] * c[0]));
    
    float d = 1.0 + a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
    + a[0] * c[0] + a[1] * c[1] + a[2] * c[2]
    + b[0] * c[0] + b[1] * c[1] + b[2] * c[2];
    
    return 2.0 * atan2(n, d);
inline float calc_domega(const float3 v00,
                         const float3 v01,
                         const float3 v10,
                         const float3 v11)
    return (solid_angle(v00, v11, v01) +
            solid_angle(v11, v00, v10)) / (4 * scn::PI);
#endif
// MARK: sh sums
typedef enum {
    kCubeFaceCount = 6
} kCubeFaceCountEnum;
// Unoptimized version, without local thread group (for debugging)
static void sh_from_cubemap(uint                               shOrder,
                            texturecube<float, access::sample> cubemap     [[ texture(0) ]],
                            device float*                      outputSH    [[ buffer(0) ]])
    uint edgeSize = cubemap.get_width();
    
    float fEdgeSize = float(cubemap.get_width());
    float fB = -1. + 1. / fEdgeSize;
    float fS = 2. * ( 1. - 1. / fEdgeSize ) / ( fEdgeSize - 1.);
    
    constexpr sampler smp;
    
    float fWt = 0.0f;
    uint numCoeff = shOrder * shOrder;
    
    //
    const uint maxSHOrder = 4;
    float localSH[maxSHOrder * maxSHOrder];
    
    float3 localSHRGB[maxSHOrder * maxSHOrder] = { float3(0.f) };
    float invSurfaceArea = 4.0f / (fEdgeSize * fEdgeSize);
    
    //--- Process each face of the cubemap
    for (uint face=0; face < 6; ++face )
    {
        for( uint y=0; y < edgeSize; ++y )
        {
            for( uint x=0; x < edgeSize; ++x )
            {
    #if USE_PRECISE_SOLIDANGLE
                float y0  = (2.0 * (y      ) - fEdgeSize) / fEdgeSize;
                float y_  = (2.0 * (y + 0.5) - fEdgeSize) / fEdgeSize;
                float y1  = (2.0 * (y + 1.0) - fEdgeSize) / fEdgeSize;
                float x0  = (2.0 * (x      ) - fEdgeSize) / fEdgeSize;
                float x_  = (2.0 * (x + 0.5) - fEdgeSize) / fEdgeSize;
                float x1  = (2.0 * (x + 1.0) - fEdgeSize) / fEdgeSize;
                
                float3 v00 = vector(face, x0, y0, 1.f);
                float3 v01 = vector(face, x0, y1, 1.f);
                float3 v10 = vector(face, x1, y0, 1.f);
                float3 v11 = vector(face, x1, y1, 1.f);
                float3 dir = vector(face, x_, y_, 1.f);
                const float fDiffSolid = 4.0f * scn::PI * calc_domega(v00, v01, v10, v11);
    #else
                
                float2 uv( x * fS + fB, y * fS + fB );
                float3 dir = normalize(scn::cubemap_dir_from_sampleCoord(face, uv));
                
                const float fDiffSolid = invSurfaceArea / ((1. + dot(uv, uv)) * sqrt(1. + dot(uv, uv) ));
    #endif
                fWt += fDiffSolid;
                // compute SH
                sh_eval_basis(shOrder, dir, localSH);
                
                float4 col = cubemap.sample(smp, dir) * fDiffSolid;
                for( uint i=0; i < numCoeff; ++i ) {
                    localSHRGB[i] += col.xyz * localSH[i];
                }
            }
        }
    }
    
    // Output (scaling not needed since fWt should sum to 1)
    uint rOffset = 0;
    uint gOffset = numCoeff;
    uint bOffset = numCoeff * 2;
    for (uint j = 0; j < numCoeff; ++j) {
        float3 sh = localSHRGB[ j ];
        outputSH[j + rOffset] = sh.x;
        outputSH[j + gOffset] = sh.y;
        outputSH[j + bOffset] = sh.z;
    }
// generate version depending on a constant SH order (for compilation optimization to kick in)
kernel void compute_sh2_from_cubemap(texturecube<float, access::sample> cubemap     [[ texture(0) ]],
                                     device float*                      outputSHRGB [[ buffer(0) ]]
    sh_from_cubemap(2, cubemap, outputSHRGB);
kernel void compute_sh3_from_cubemap(texturecube<float, access::sample> cubemap     [[ texture(0) ]],
                                     device float*                      outputSHRGB [[ buffer(0) ]]
    sh_from_cubemap(3, cubemap, outputSHRGB);
kernel void compute_sh4_from_cubemap(texturecube<float, access::sample> cubemap     [[ texture(0) ]],
                                     device float*                      outputSHRGB [[ buffer(0) ]]
    sh_from_cubemap(4, cubemap, outputSHRGB);
// Version with threadgroup mem
typedef enum {
    kMaxThreadsPerThreadgroup = 64
} kMaxThreadsPerThreadgroupEnum;
static void sh_from_cubemap_threadgroup_mem(uint                               shOrder,
                                            texturecube<float, access::sample> cubemap                [[ texture(0) ]],
                                            device packed_float3*              outputSHRGB            [[ buffer(1) ]],
                                            threadgroup float3*                localSHRGB             [[ threadgroup(0) ]],
                                            uint                               index                  [[ threadgroup_position_in_grid ]],
                                            uint                               lid                    [[ thread_position_in_threadgroup ]],
                                            uint                               kThreadsPerThreadGroup [[ threads_per_threadgroup ]])
    uint edgeSize = cubemap.get_width();
    
    
    float fEdgeSize = float(cubemap.get_width());
    float fB = -1. + 1. / fEdgeSize;
    float fS = 2. * ( 1. - 1. / fEdgeSize ) / ( fEdgeSize - 1.);
    
    constexpr sampler smp;
    
    float fWt = 0.0f;
    uint numCoeff = shOrder * shOrder;
    
    float localSH[16]; //used to be numCoeff but: <rdar://problem/27330922> GPUCompiler-600.0.48.21 makes SceneKit-373 fail to build due to SceneKit use of VLA (variable length array)
    
    uint baseIndex = lid * numCoeff;
    for (uint i = 0; i < numCoeff; ++i) {
        localSHRGB[baseIndex + i] = float3(0.0f);
    }
    
    // Do we need this barrier since each thread write in a different memory location
    // threadgroup_barrier(mem_flags::mem_threadgroup);
    float invSurfaceArea = 4.0f / (fEdgeSize * fEdgeSize);
    
    uint face = index;
    for( uint y=0; y < edgeSize; ++y )
    {
        //        for( uint x=lid; x < edgeSize; x+=kThreadsPerThreadGroup )
        uint wcount = edgeSize / kThreadsPerThreadGroup;
        uint lastX = min((lid + 1) * wcount, edgeSize);
        for (uint x = lid * wcount; x <  lastX; ++x)
        {
            float2 uv( x * fS + fB, y * fS + fB );
            float3 dir = normalize(scn::cubemap_dir_from_sampleCoord(face, uv));
            
            const float fDiffSolid = invSurfaceArea / ((1. + dot(uv, uv)) * sqrt(1. + dot(uv, uv) ));
            fWt += fDiffSolid;
            // compute SH
            sh_eval_basis(shOrder, dir, localSH);
            
            float4 col = cubemap.sample(smp, dir) * fDiffSolid;
            for( uint i=0; i < numCoeff; ++i ) {
                localSHRGB[baseIndex + i] += col.xyz * localSH[i];
            }
        }
    }
    
    threadgroup_barrier(mem_flags::mem_threadgroup);
    
    // do the final sum
    if (lid == 0)
    {
        for (uint ti = 1; ti < kThreadsPerThreadGroup; ++ti)
        {
            for( uint i=0; i < numCoeff; ++i ) {
                localSHRGB[i] += localSHRGB[ti * numCoeff + i];
            }
        }
        
        // output
        for( uint i=0; i < numCoeff; ++i )
        {
            uint ind = numCoeff * index + i;
            outputSHRGB[ind] = localSHRGB[i].rgb;
        }
    }
kernel void compute_sh2_from_cubemap_threadgroup_mem(texturecube<float, access::sample> cubemap                [[ texture(0) ]],
                                                     device packed_float3*              outputSHRGB            [[ buffer(1) ]],
                                                     threadgroup float3*                localSHRGB             [[ threadgroup(0) ]],
                                                     uint                               index                  [[ threadgroup_position_in_grid ]],
                                                     uint                               lid                    [[ thread_position_in_threadgroup ]],
                                                     uint                               kThreadsPerThreadGroup [[ threads_per_threadgroup ]])
    sh_from_cubemap_threadgroup_mem(2, cubemap, outputSHRGB, localSHRGB, index, lid, kThreadsPerThreadGroup);
kernel void compute_sh3_from_cubemap_threadgroup_mem(texturecube<float, access::sample> cubemap                [[ texture(0) ]],
                                                     device packed_float3*              outputSHRGB            [[ buffer(1) ]],
                                                     threadgroup float3*                localSHRGB             [[ threadgroup(0) ]],
                                                     uint                               index                  [[ threadgroup_position_in_grid ]],
                                                     uint                               lid                    [[ thread_position_in_threadgroup ]],
                                                     uint                               kThreadsPerThreadGroup [[ threads_per_threadgroup ]])
    sh_from_cubemap_threadgroup_mem(3, cubemap, outputSHRGB, localSHRGB, index, lid, kThreadsPerThreadGroup);
kernel void compute_sh4_from_cubemap_threadgroup_mem(texturecube<float, access::sample> cubemap                [[ texture(0) ]],
                                                     device packed_float3*              outputSHRGB            [[ buffer(1) ]],
                                                     threadgroup float3*                localSHRGB             [[ threadgroup(0) ]],
                                                     uint                               index                  [[ threadgroup_position_in_grid ]],
                                                     uint                               lid                    [[ thread_position_in_threadgroup ]],
                                                     uint                               kThreadsPerThreadGroup [[ threads_per_threadgroup ]])
    sh_from_cubemap_threadgroup_mem(4, cubemap, outputSHRGB, localSHRGB, index, lid, kThreadsPerThreadGroup);
static void sh_sum(uint                  shOrder,
                   device float*         outputSH   [[ buffer(0) ]],
                   device packed_float3* inputSHRGB [[ buffer(1) ]])
    enum { kCubeFaceCount = 6 };
    uint numCoeff = shOrder * shOrder;
    
    // first clear
    for (uint j = 0; j < (numCoeff * 3); ++j) {
        outputSH[j] = 0;
    }
    
    uint rOffset = 0;
    uint gOffset = numCoeff;
    uint bOffset = numCoeff * 2;
    for (uint i = 0; i < kCubeFaceCount; ++i) {
        for (uint j = 0; j < numCoeff; ++j) {
            uint srcindex = i * numCoeff + j;
            float3 sh = inputSHRGB[srcindex];
            outputSH[j + rOffset] += sh.x;
            outputSH[j + gOffset] += sh.y;
            outputSH[j + bOffset] += sh.z;
        }
    }
kernel void sum_sh2(device float*         outputSH   [[ buffer(0) ]],
                    device packed_float3* inputSHRGB [[ buffer(1) ]])
    sh_sum(2, outputSH, inputSHRGB);
kernel void sum_sh3(device float*         outputSH   [[ buffer(0) ]],
                    device packed_float3* inputSHRGB [[ buffer(1) ]])
    sh_sum(3, outputSH, inputSHRGB);
kernel void sum_sh4(device float*         outputSH   [[ buffer(0) ]],
                    device packed_float3* inputSHRGB [[ buffer(1) ]])
    sh_sum(4, outputSH, inputSHRGB);
// MARK: Cubemap generation (from SH)
inline scn::sh3_vector sh3_basis(half3 dir)
    scn::sh3_vector res;
    res.V0.x = 0.282095f;
    res.V0.y = -0.488603f * dir.y;
    res.V0.z = 0.488603f * dir.z;
    res.V0.w = -0.488603f * dir.x;
    
    half3 VectorSquared = dir * dir;
    res.V1.x = 1.092548f * dir.x * dir.y;
    res.V1.y = -1.092548f * dir.y * dir.z;
    res.V1.z = 0.315392f * (3.0f * VectorSquared.z - 1.0f);
    res.V1.w = -1.092548f * dir.x * dir.z;
    res.V2 = 0.546274f * (VectorSquared.x - VectorSquared.y);
    return res;
inline scn::sh3_vector sh3_compute_diffuse_transfer(half3 normal, half Exponent)
    scn::sh3_vector res = sh3_basis(normal);
    half L0 =
 2 * scn::PI / (1 + 1 * Exponent);
    half L1 =
 2 * scn::PI / (2 + 1 * Exponent);
    half L2 = Exponent * 2 * scn::PI / (3 + 4 * Exponent + Exponent * Exponent);
    
    res.V0.x *= L0;
    res.V0.yzw *= L1;
    res.V1.xyzw *= L2;
    res.V2 *= L2;
    return res;
fragment float4 cubemap_from_sh(scn::draw_quad_io_t    in   [[ stage_in ]],
                                constant scn::sh3_rgb& sh   [[ buffer(0) ]],
                                constant uint&         face [[ buffer(1) ]])
    float3 dir = normalize(scn::cubemap_dir_from_uv(face, in.uv));
    
    const float Exponent = 1;
    
    // Compute SH for the normal
    scn::sh3_vector diffSH = sh3_compute_diffuse_transfer(half3(dir.xyz), Exponent);
    
    float r = dot_sh3_vector(scn::shVectorFromSh(sh.red), diffSH) / scn::PI;
    float g = dot_sh3_vector(scn::shVectorFromSh(sh.green), diffSH) / scn::PI;
    float b = dot_sh3_vector(scn::shVectorFromSh(sh.blue), diffSH) / scn::PI;
    
    return float4(max(0.0f, r), max(0.0f, g), max(0.0f, b), 1.0);
// MARK: Drawing
struct ProbeSphere_in
    float4 position [[ attribute(SCNVertexSemanticPosition) ]];
    float3 normal   [[ attribute(SCNVertexSemanticNormal) ]];
struct ProbeSphere_node
    float4x4 modelTransform;
    float4x4 modelViewProjectionTransform;
struct ProbeSphere_io
    float4 position [[ position ]];
    float3 dir;
vertex ProbeSphere_io scn_probesphere_from_sh_vertex(ProbeSphere_in             in        [[ stage_in ]],
                                                     constant SCNSceneBuffer&   scn_frame [[ buffer(0) ]],
                                                     constant ProbeSphere_node& scn_node  [[ buffer(1) ]])
    ProbeSphere_io out;
    
    out.position = scn_node.modelViewProjectionTransform * in.position;
    out.dir = scn::mat4_mult_float3(scn_frame.viewToCubeTransform, scn::mat4_mult_float3(scn_frame.viewTransform, in.normal));
    
    return out;
fragment float4 scn_probesphere_from_sh_fragment(ProbeSphere_io         in [[ stage_in ]],
                                                 constant scn::sh3_rgb& sh [[ buffer(0) ]])
    const float Exponent = 1;
    
    // Compute SH for the normal
    scn::sh3_vector diffSH = sh3_compute_diffuse_transfer(half3(in.dir), Exponent);
    
    float r = dot_sh3_vector(scn::shVectorFromSh(sh.red), diffSH) / scn::PI;
    float g = dot_sh3_vector(scn::shVectorFromSh(sh.green), diffSH) / scn::PI;
    float b = dot_sh3_vector(scn::shVectorFromSh(sh.blue), diffSH) / scn::PI;
    
    return float4(max(0.0f, r), max(0.0f, g), max(0.0f, b), 1.0);
#ifdef ENABLE_CUBE_MAP
uniform samplerCube u_textureSampler0;
uniform float u_fresnelExponent;
varying vec4 v_normal;
#ifdef ENABLE_FOG
uniform vec4 u_fogColor;
#endif
#else // ENABLE_CUBE_MAP
uniform sampler2D u_textureSampler0;
#endif
varying vec4 v_vertexColor;
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
#if __VERSION__ > 120 // GL Compatibility Profile
#ifndef texture2D
#define texture2D(tex,coord) texture( tex, coord )
#endif
#define textureCube(tex,coord) texture( tex, coord )
#endif
#ifdef ENABLE_SOFT
uniform sampler2D u_depthSampler0;
uniform vec4 u_softParameters; // x: scale, y: power/contrast, zw : 1/viewPortSize
uniform mat4 u_invProj; // inverse of the projection transform, to reconstruct viewPos from screenPos
varying float v_eyeLinearZ;
float ComputeSoftFactor()
    vec2 normalizedFragCoord = gl_FragCoord.xy * u_softParameters.zw;
float depthValue = texture2D(u_depthSampler0, gl_FragCoord.xy * u_softParameters.zw).x;
    
    vec3 screenPos = vec3(normalizedFragCoord, depthValue);
vec4 viewPos = u_invProj * vec4(screenPos * 2. - 1., 1.);
viewPos /= viewPos.w;
    
    float factor = clamp((v_eyeLinearZ - viewPos.z) * u_softParameters.x ,0. , 1.);
    // Do we really need this pow?
    // factor = pow(factor, u_softParameters.y);
    
    return factor;
#endif
void main(){
#ifdef ENABLE_CUBE_MAP
    vec2 p = v_uv0 * 2. - 1.;
    float r = dot(p,p); // len^2
    vec4 tex = textureCube(u_textureSampler0, v_normal.xyz) * clamp(9.6 - 10. * r, 0., 1.0);
    // fresnel modulation
    tex.rgb *= pow(r, u_fresnelExponent);
#else // ENABLE_CUBE_MAP
#ifdef ENABLE_ANIMATION // belnd between two frames
    vec4 tex = mix(texture2D(u_textureSampler0, v_uv0.xy),
                   texture2D(u_textureSampler0, v_uv1.xy), v_uv0.z);
#else
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
#endif // ENABLE_ANIMATION
#endif // ENABLE_CUBE_MAP
#ifdef ENABLE_SOFT
    tex *= ComputeSoftFactor();
#endif
    
    
#ifdef ENABLE_CUBE_MAP
    gl_FragColor.a = v_vertexColor.a * tex.a; // texture and colors need to be premultiplied
#ifdef ENABLE_FOG
    gl_FragColor.rgb = mix(v_vertexColor.rgb + tex.rgb, u_fogColor.rgb, v_normal.a) * gl_FragColor.a; // texture and colors need to be premultiplied
#else
    gl_FragColor.rgb = (v_vertexColor.rgb + tex.rgb) * gl_FragColor.a; // texture and colors need to be premultiplied
#endif // ENABLE_FOG
#else
    gl_FragColor = v_vertexColor * tex; // texture and colors need to be premultiplied
#endif
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
typedef struct {
    float4x4 modelTransform;
} debug_node;
typedef struct {
    float3 position [[attribute(0)]];
} debug_vertex_t;
#if __METAL_VERSION__ >= 120
typedef struct {
    patch_control_point<debug_vertex_t> controlPoints;
} debug_patch_t;
#endif
// Vertex shader function
vertex float4 debug_vert(debug_vertex_t           in        [[ stage_in ]],
                         constant SCNSceneBuffer& scn_frame [[ buffer(0) ]],
                         constant debug_node&     scn_node  [[ buffer(1) ]])
    float4 in_position = float4(in.position, 1.0);
    return scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
#if __METAL_VERSION__ >= 120
[[ patch(triangle, 3) ]]
vertex float4 debug_post_tessellation_vert(debug_patch_t            in         [[ stage_in ]],
                                           float3                   patchCoord [[ position_in_patch ]],
                                           constant SCNSceneBuffer& scn_frame  [[ buffer(0) ]],
                                           constant debug_node&     scn_node   [[ buffer(1) ]])
    float4 in_position = float4(scn::barycentric_mix(in.controlPoints[0].position, in.controlPoints[1].position, in.controlPoints[2].position, patchCoord), 1.0);
    return scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
#endif
// Fragment shader function
fragment half4 debug_frag()
    return half4(1.0, 0.0, 1.0, 1.0);
fragment half4 debug_isolate_frag()
    return half4(1.0, 0.0, 0.0, 1.0);
////////////////////////////////////////////////////////////////////////////
typedef struct {
    float3 position [[attribute(0)]];
    float3 normal [[attribute(1)]];
} debug_normal_vertex_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float4 color;
} debug_normal_io;
// Vertex shader function
vertex debug_normal_io debug_normal_vert(debug_normal_vertex_t    in        [[ stage_in ]],
                                         constant SCNSceneBuffer& scn_frame [[ buffer(0) ]],
                                         constant debug_node&     scn_node  [[ buffer(1) ]])
    float4 in_position = float4(in.position, 1.0);
    
    debug_normal_io out;
    out.position = scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
    //    float d = max(dot(in.normal, float3(0,0,1)), 0.0);
    //    out.color = float4(d);
    out.color.a = 1.0;
    out.color.rgb = in.normal.xyz * 0.5 + 0.5;
    return out;
// Fragment shader function
fragment half4 debug_normal_frag(debug_normal_io in [[stage_in]])
    return half4(in.color);
#ifndef __SCNMetalDefines__
#define __SCNMetalDefines__
enum {
    SCNVertexSemanticPosition,
    SCNVertexSemanticNormal,
    SCNVertexSemanticTangent,
    SCNVertexSemanticColor,
    SCNVertexSemanticBoneIndices,
    SCNVertexSemanticBoneWeights,
    SCNVertexSemanticTexcoord0,
    SCNVertexSemanticTexcoord1,
    SCNVertexSemanticTexcoord2,
    SCNVertexSemanticTexcoord3,
    SCNVertexSemanticTexcoord4,
    SCNVertexSemanticTexcoord5,
    SCNVertexSemanticTexcoord6,
    SCNVertexSemanticTexcoord7
// This structure hold all the informations that are constant through a render pass
// In a shader modifier, it is given both in vertex and fragment stage through an argument named "scn_frame".
struct SCNSceneBuffer {
    float4x4    viewTransform;
    float4x4    inverseViewTransform; // transform from view space to world space
    float4x4    projectionTransform;
    float4x4    viewProjectionTransform;
    float4x4    viewToCubeTransform; // transform from view space to cube texture space (canonical Y Up space)
    float4x4    lastFrameViewProjectionTransform;
    float4      ambientLightingColor;
    float4
fogColor;
    float3
fogParameters; // x:-1/(end-start) y:1-start*x z:exp
    float2      inverseResolution;
    float       time;
    float       sinTime;
    float       cosTime;
    float       random01;
    float       motionBlurIntensity;
    // new in macOS 10.12 and iOS 10
    float       environmentIntensity;
    float4x4    inverseProjectionTransform;
    float4x4    inverseViewProjectionTransform;
    // new in macOS 10.13 and iOS 11
    float2      nearFar; // x: near, y: far
    float4      viewportSize; // xy:size, zw:size / tan(fov/2)
// In custom shaders or in shader modifiers, you also have access to node relative information.
// This is done using an argument named "scn_node", which must be a struct with only the necessary fields
// among the following list:
// float4x4 modelTransform;
// float4x4 inverseModelTransform;
// float4x4 modelViewTransform;
// float4x4 inverseModelViewTransform;
// float4x4 normalTransform; // This is the inverseTransposeModelViewTransform, need for normal transformation
// float4x4 modelViewProjectionTransform;
// float4x4 inverseModelViewProjectionTransform;
// float2x3 boundingBox;
// float2x3 worldBoundingBox;
#endif /* defined(__SCNMetalDefines__) */
attribute vec4 a_position;
uniform vec2 u_inversePixelSize;
varying vec4 v_texCoord;
void main(void)
gl_Position = a_position;
    vec2 tc = (a_position.xy + 1.0) * 0.5;
    vec4 offset = vec4(-0.5, 0.5, -0.5, 0.5);
    v_texCoord = tc.xxyy + offset * u_inversePixelSize.xyxy;
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-DeferredShadingCommon.h"
#import "C3D-PBR.metal"
/// PBR shareable
#define str(a,b) a##b
#if defined(FUNC_VERT) && defined(FUNC_FRAG)
//#define tokenize(a) (#a)
//#define vertex_name   str(ds_default_vert_,tokenize(SHADER_SUFFIX))
//#define fragment_name   str(ds_default_frag_, tokenize(SHADER_SUFFIX))
#define vertex_name   FUNC_VERT
#define fragment_name FUNC_FRAG
#else
#define vertex_name   ds_default_vert
#define fragment_name ds_default_frag
#endif
inline float4 AmbientContribution(SCNPBRSurface surface, texturecube<float> irradianceTexture, texturecube<float> radianceTexture, constant SCNSceneBuffer& scn_frame, float4 vpos)
    float3 indirect = 0.0; //PBR_indirect(surface, irradianceTexture, radianceTexture, scn_frame);
    // TODO
    
    float4 color = float4(0., 0., 0., 1.);
    // ambient lighting (maybe kill it if irradiance map present)
    color.rgb  = (scn_frame.ambientLightingColor.rgb * surface.ao) * surface.albedo;
    // IBL irradiance + radiance
    color.rgb += indirect;
    // Emission
    color.rgb += surface.emission;
    
    return color;
struct GBufferUniforms {
    float4x4 modelTransform;
    float4x4 modelViewTransform;
    float4x4 normalTransform;
struct GBufferVertex {
    float3 position         [[attribute(SCNVertexSemanticPosition)]];
    float3 normal           [[attribute(SCNVertexSemanticNormal)]];
    float4 tangent          [[attribute(SCNVertexSemanticTangent)]];
    float4 color            [[attribute(SCNVertexSemanticColor)]];
    float4 skinningWeights  [[attribute(SCNVertexSemanticBoneWeights)]];
    uint4  skinningJoints   [[attribute(SCNVertexSemanticBoneIndices)]];
    float2 texcoord0        [[attribute(SCNVertexSemanticTexcoord0)]];
    float2 texcoord1        [[attribute(SCNVertexSemanticTexcoord1)]];
    float2 texcoord2        [[attribute(SCNVertexSemanticTexcoord2)]];
    float2 texcoord3        [[attribute(SCNVertexSemanticTexcoord3)]];
struct GBufferIO {
    float4 position [[position]];
    
    float4 positionVS;
    float3 normalVS;
#ifdef USE_NORMAL_MAP
    float3 tangentVS;
    float3 bitangentVS;
#endif
    float2 albedoTexcoord;
    float2 ambientTexcoord;
    float2 emissionTexcoord;
    float2 normalTexcoord;
struct FragmentOutput {
    float4 lighting [[ color(0) ]]; // accumulation of ambient, emissive, then later the lights themselves
    float4 albedo_roughness [[ color(1) ]]; // albedo + roughness
    float4 normal_depth [[ color(2) ]]; // in view space
    float4 xxxx [[ color(3) ]];
// Vertex shader function
vertex GBufferIO ds_default_vert(GBufferVertex in [[ stage_in ]],
                                 constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                                 constant GBufferUniforms& scn_node [[buffer(1)]],
                                 constant commonprofile_uniforms_ds& scn_commonprofile_ds [[buffer(2)]])
    float4 in_position = float4(in.position, 1.0);
    
    GBufferIO out;
    out.position = scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
    
    // view space position
    out.positionVS.xyz =  (scn_node.modelViewTransform * in_position).xyz;
    // far clip : OPTIM : we should store it in uniform (SceneBuffer) and access it in the fragment shader
    // for now compute it based on the projection matrix
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    out.positionVS.w = d / (1.f + c);
    
    // normal
    out.normalVS =  in.normal.xxx * scn_node.normalTransform[0].xyz;
    out.normalVS += in.normal.yyy * scn_node.normalTransform[1].xyz;
    out.normalVS += in.normal.zzz * scn_node.normalTransform[2].xyz;
    out.normalVS = normalize(out.normalVS); // * 0.5 + 0.5; // Normalization here is incorrect, should be done in the fragment shader
    
    // texcoord
    // TODO : how to choose between the n texcoords without recompiling
    // swizzling?
    // i.e. : out.albedoTexCoord = uniforms.albedoSwizzle.x * in.texcoord0 + uniforms.albedoSwizzle.y * in.texcoord1 + uniforms.albedoSwizzle.x * in.texcoord2 + uniforms.albedoSwizzle.x * in.texcoord3;
    // this can be more efficient if we szizzle the 4 texcoords like XXXX, YYYY. then that would be two dots
    out.albedoTexcoord = in.texcoord0;
    out.emissionTexcoord = in.texcoord0;
    out.ambientTexcoord = in.texcoord0;
    
    out.albedoTexcoord      = scn_commonprofile_ds.diffuseTransform * float3(out.albedoTexcoord, 1.f);
    out.emissionTexcoord    = scn_commonprofile_ds.emissionTransform * float3(out.emissionTexcoord, 1.f);
    out.ambientTexcoord     = scn_commonprofile_ds.ambientTransform * float3(out.ambientTexcoord, 1.f);
    
    // TODO transformation matrices
    
    return out;
// NormalMap version
vertex GBufferIO vertex_name(GBufferVertex in [[ stage_in ]],
                                   constant SCNSceneBuffer& scn_frame [[buffer(0)]],
                                   constant GBufferUniforms& scn_node [[buffer(1)]],
                                   constant commonprofile_uniforms_ds& scn_commonprofile_ds [[buffer(2)]])
    float4 in_position = float4(in.position, 1.0);
    
    GBufferIO out;
    out.position = scn_frame.viewProjectionTransform * (scn_node.modelTransform * in_position);
    
    // view space position
    out.positionVS.xyz =  (scn_node.modelViewTransform * in_position).xyz;
    // far clip : OPTIM : we should store it in uniform (SceneBuffer) and access it in the fragment shader
    // for now compute it based on the projection matrix
    float c = scn_frame.projectionTransform[2][2]; // (a + b) / (b - a)
    float d = scn_frame.projectionTransform[3][2]; // 2.a.b / (b - a)
    out.positionVS.w = d / (1.f + c);
    
    // Tangent basis vectors
    out.normalVS = scn::mat4_mult_float3_normalized(scn_node.normalTransform, in.normal);
#ifdef USE_NORMAL_MAP
    out.tangentVS = scn::mat4_mult_float3_normalized(scn_node.normalTransform, in.tangent.xyz);
    out.bitangentVS = /*_geometry.tangent.w **/ cross(out.tangentVS, out.normalVS); // no need to renormalize since tangent and normal should be orthogonal
#endif
    
    // texcoord
    // TODO : how to choose between the n texcoords without recompiling
    // swizzling?
    // i.e. : out.albedoTexCoord = uniforms.albedoSwizzle.x * in.texcoord0 + uniforms.albedoSwizzle.y * in.texcoord1 + uniforms.albedoSwizzle.x * in.texcoord2 + uniforms.albedoSwizzle.x * in.texcoord3;
    // this can be more efficient if we szizzle the 4 texcoords like XXXX, YYYY. then that would be two dots
    out.albedoTexcoord = in.texcoord0;
    out.normalTexcoord = in.texcoord0;
    out.emissionTexcoord = in.texcoord0;
    out.ambientTexcoord = in.texcoord0;
    
    out.albedoTexcoord     = scn_commonprofile_ds.diffuseTransform * float3(out.albedoTexcoord, 1.f);
    out.emissionTexcoord   = scn_commonprofile_ds.emissionTransform * float3(out.emissionTexcoord, 1.f);
    out.ambientTexcoord    = scn_commonprofile_ds.ambientTransform * float3(out.ambientTexcoord, 1.f);
    out.normalTexcoord     = scn_commonprofile_ds.normalTransform * float3(out.normalTexcoord, 1.f);
    
    return out;
static float3 ComputeAlbedo(texture2d<float> tex, sampler smp, float2 uv, constant commonprofile_uniforms_ds& uniforms)
    float3 albedo = tex.sample(smp, uv).rgb;
    // OPTIM intensity could be integrated in color -> always a mul
    albedo *= uniforms.diffuseIntensity.xyz; // in case of color, texture is white, otherwise color is white
    //    _surface.diffuse *= in.vertexColor;
    return albedo;
static float3 ComputeEmission(texture2d<float> tex, sampler smp, float2 uv, constant commonprofile_uniforms_ds& uniforms)
    float3 emission = tex.sample(smp, uv).rgb;
    // OPTIM intensity could be integrated in color -> always a mul -> depends on the property type. AO is mix to white...
    //    emission *= uniforms.emissionIntensity;
    emission *= uniforms.emissionIntensity.xyz; // in case of color, texture is white, otherwise color is white
    return emission;
static float ComputeAmbientOcclusion(texture2d<float> tex, sampler smp, float2 uv, constant commonprofile_uniforms_ds& uniforms)
    float ao = tex.sample(smp, uv).r; // in case of color, texture is white, otherwise color is white
    ao = mix(1.0, ao, uniforms.ambientIntensity);
    return ao;
// Fragment shader function
fragment FragmentOutput ds_default_frag(GBufferIO in [[stage_in]]
                                        , constant SCNSceneBuffer& scn_frame [[buffer(0)]]
                                        , constant commonprofile_uniforms_ds& scn_commonprofile_ds [[buffer(1)]]
                                        , texture2d<float> u_emissionTexture [[texture(0)]]
                                        , sampler          u_emissionTextureSampler [[sampler(0)]]
                                        , texture2d<float> u_ambientTexture [[texture(1)]]
                                        , sampler          u_ambientTextureSampler [[sampler(1)]]
                                        , texture2d<float> u_diffuseTexture [[texture(2)]]
                                        , sampler          u_diffuseTextureSampler [[sampler(2)]]
#ifdef USE_PBR
                                        , texturecube<float> u_irradianceTexture [[texture(8)]]
                                        , texturecube<float> u_radianceTexture [[texture(9)]]
#endif
                                        )
    // depth is stored linearly, normalized on far clip dimension [0..1]
    float depth = -in.positionVS.z / in.positionVS.w;
    
    SCNPBRSurface surface;
    // Albedo
    surface.albedo = ComputeAlbedo(u_diffuseTexture, u_diffuseTextureSampler, in.albedoTexcoord, scn_commonprofile_ds);
    // Ambient Occlusion
    surface.ao  = ComputeAmbientOcclusion(u_ambientTexture, u_ambientTextureSampler, in.ambientTexcoord, scn_commonprofile_ds);
    // Emission
    surface.emission = ComputeEmission(u_emissionTexture, u_emissionTextureSampler, in.emissionTexcoord, scn_commonprofile_ds);
    // Roughness
    surface.roughness = scn_commonprofile_ds.roughnessIntensity; // TODO sample map
    // Metalness
    surface.metalness = scn_commonprofile_ds.metalnessIntensity; // TODO sample map
    // Normal
    surface.N = in.normalVS;
    // Position
    // surface.position = in.positionVS.xyz;
    // View (Only needed if radiance available)
    surface.V = -normalize(in.positionVS.xyz);
    FragmentOutput output;
    output.lighting = AmbientContribution(surface, u_irradianceTexture, u_radianceTexture, scn_frame);
    output.albedo_roughness = float4(surface.albedo, surface.roughness);
    output.normal_depth = float4(surface.N, depth);       // normal+z
    output.xxxx = float4(in.positionVS.xyz, 1.); // debug viewPosition ???
    
    return output;
// NormalMap version
fragment FragmentOutput fragment_name(GBufferIO in [[stage_in]]
                                          , constant SCNSceneBuffer& scn_frame [[buffer(0)]]
                                          , constant commonprofile_uniforms_ds& scn_commonprofile_ds [[buffer(1)]]
                                          , texture2d<float> u_emissionTexture [[texture(0)]]
                                          , sampler          u_emissionTextureSampler [[sampler(0)]]
                                          , texture2d<float> u_ambientTexture [[texture(1)]]
                                          , sampler          u_ambientTextureSampler [[sampler(1)]]
                                          , texture2d<float> u_diffuseTexture [[texture(2)]]
                                          , sampler          u_diffuseTextureSampler [[sampler(2)]]
#ifdef USE_NORMAL_MAP
                                          , texture2d<float> u_normalTexture [[texture(7)]]
                                          , sampler          u_normalTextureSampler [[sampler(7)]]
#endif
#ifdef USE_PBR
                                          , texturecube<float> u_irradianceTexture [[texture(8)]]
                                          , texturecube<float> u_radianceTexture [[texture(9)]]
#endif
                                          )
    // depth is stored linearly, normalized on far clip dimension [0..1]
    float depth = -in.positionVS.z / in.positionVS.w;
    
    SCNPBRSurface surface;
    
    // Albedo
    surface.albedo = ComputeAlbedo(u_diffuseTexture, u_diffuseTextureSampler, in.albedoTexcoord, scn_commonprofile_ds);
    // Ambient Occlusion
    surface.ao  = ComputeAmbientOcclusion(u_ambientTexture, u_ambientTextureSampler, in.ambientTexcoord, scn_commonprofile_ds);
    // Emission
    surface.emission = ComputeEmission(u_emissionTexture, u_emissionTextureSampler, in.emissionTexcoord, scn_commonprofile_ds);
    // Roughness
    surface.roughness = scn_commonprofile_ds.roughnessIntensity; // TODO sample map
    // Metalness
    surface.metalness = scn_commonprofile_ds.metalnessIntensity; // TODO sample map
    // Position
    // surface.position = in.positionVS.xyz;
    // View (Only needed if radiance available)
    surface.v = -normalize(in.positionVS.xyz);
    // Normal
#ifdef USE_NORMAL_MAP
    float3 normal = u_normalTexture.sample(u_normalTextureSampler, in.normalTexcoord).rgb * 2. - 1.;
    normal = mix(float3(0., 0., 1.), normal, scn_commonprofile_ds.normalIntensity);
    // transform the normal in view space
    float3x3 tangentBasisTransform = float3x3(in.tangentVS, in.bitangentVS, in.normalVS);
    surface.n = normalize(tangentBasisTransform * normal);
#else
    surface.n = normalize(in.normalVS);
#endif
    
    FragmentOutput output;
    output.lighting = 0.0; //AmbientContribution(surface, u_irradianceTexture, u_radianceTexture, scn_frame, in.position);
    // TODO
    output.albedo_roughness = float4(surface.albedo, surface.roughness);
    output.normal_depth = float4(surface.n, depth);       // normal+z
    output.xxxx = float4(in.positionVS.xyz, 1.); // debug viewPosition ???
    return output;
varying vec2 TexCoord;
uniform sampler2D textureSampler0;
uniform vec2 offsets[MAX_SAMPLE];
uniform float weights[MAX_SAMPLE];
uniform int n_sample;
void main (void)
    int i;
    vec4 accum = vec4(0.0);
    for(i=0;i<n_sample;i++){
        accum += texture2D(textureSampler0, TexCoord+offsets[i]) *  weights[i];
    }
gl_FragColor = accum;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>targets</key>
<dict>
<key>VELOCITY</key>
<dict>
<key>type</key>
<string>color</string>
<key>format</key>
<string>rgba16f</string>
<key>scaleFactor</key>
<integer>1</integer>
<key>global</key>
<true/>
<key>clearColor</key>
<string>0. 0. 0. 999999999.</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>SceneKit_renderScene</string>
</array>
<key>passes</key>
<dict>
<key>SceneKit_renderScene</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
<key>color1</key>
<string>VELOCITY</string>
<key>depth</key>
<string>DEPTH</string>
</dict>
<key>draw</key>
<string>DRAW_SCENE</string>
<key>depthStates</key>
<dict>
<key>clear</key>
<true/>
</dict>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>sceneBackground</string>
</dict>
</dict>
</dict>
</dict>
</plist>
// toto SSAO related shaders
#include <metal_stdlib>
using namespace metal;
#import "C3D-SSAO.h"
#import "scn_metal"
#import "C3D-PostProcessUtils.h"
using namespace scn;
#define PI 3.141592653589
#if (__METAL_VERSION__ >= 120)
constant int SSAODownSample                      [[ function_constant( 0) ]];
constant int SSAOSampleCount                     [[ function_constant( 1) ]];
constant bool SSAOCameraOrtho                    [[ function_constant( 2) ]];
#else //Should be never called since API_AVAILABLE(macos(10.13), ios(11.0), tvos(11.0), watchos(4.0));
constant bool SSAOCameraOrtho  
 = false;
constant int SSAODownSample                   = 4;
constant int SSAOSampleCount                  = 11;
#endif
#define SSAO_BLUR 1
#define SSAO_UPSAMPLING 1
// -------------------------------------------------------------------------------------
// Downsample min max offset
// -------------------------------------------------------------------------------------
kernel void scn_ssao_downsample(ushort2                            index           [[ thread_position_in_grid ]],
                                texture2d<half, access::sample> depthSampler    [[ texture(0) ]],
                                texture2d<uint, access::write> out               [[ texture(1) ]],
                                constant scn_ssao_uniforms_t&  uni               [[ buffer(0)  ]])
    
    constexpr sampler samp(coord::pixel, filter::nearest, address::clamp_to_zero);
    
    // Gather order
    // (-,+), (+,+),(+,-),(-,-)
    if(SSAODownSample == 4)
    {
        if( index.x >= out.get_width() || index.y >= out.get_height() )
            return;
        float2 uv = float2(index*SSAODownSample)+.5;
        
        half4x4 zMat;
        zMat[0] = depthSampler.gather(samp, uv, int2(0, 2), component::w);
        zMat[1] = depthSampler.gather(samp, uv, int2(2, 2), component::w);
        zMat[2] = depthSampler.gather(samp, uv, int2(2, 0), component::w);
        zMat[3] = depthSampler.gather(samp, uv, int2(0, 0), component::w);
        
        
        ushort4 zID;
        half4 zValue = scn_vector_min_and_indices(zMat, zID);
        ushort id = scn_vector_min_index(zValue);
        
        ushort4 zID2;
        half4 zValue2 = scn_vector_max_and_indices(zMat, zID2);
        ushort id2 = scn_vector_max_index(zValue2);
        
        half a = step(0.h, half( (index.x + index.y&1) &1 ) );
        zID = ushort4( mix(half4(zID), half4(zID2), a) );
        id = ushort( mix(half(id), half(id2), a ) );
        
        out.write(uint4(10*id+zID[id],0,0,0), uint2(index));
    }
    else //if(SSAODownSample == 2)
    {
        index *= 2;
        if( index.x >= out.get_width() || index.y >= out.get_height() )
            return;
        float2 uv = float2(index*SSAODownSample)+.5;
        
        half4x4 zMat;
        zMat[0] = depthSampler.gather(samp, uv, int2(gatherUV[0]*2), component::w);
        zMat[1] = depthSampler.gather(samp, uv, int2(gatherUV[1]*2), component::w);
        zMat[2] = depthSampler.gather(samp, uv, int2(gatherUV[2]*2), component::w);
        zMat[3] = depthSampler.gather(samp, uv, int2(gatherUV[3]*2), component::w);
        
        
        ushort4 zID, zID2;
        scn_vector_min_and_indices(zMat, zID);
        scn_vector_max_and_indices(zMat, zID2);
        
        
        zID = clamp(zID,ushort4(0),ushort4(3));
        zID2 = clamp(zID2,ushort4(0),ushort4(3));
        
        out.write(uint4( zID[0],0,0,0), index+gatherUV[0]);
        out.write(uint4(zID2[1],0,0,0), index+gatherUV[1]);
        out.write(uint4( zID[2],0,0,0), index+gatherUV[2]);
        out.write(uint4(zID2[3],0,0,0), index+gatherUV[3]);
    }
    
// -------------------------------------------------------------------------------------
// Compute Raw AO
// -------------------------------------------------------------------------------------
inline float hash(uint2 c)
    int x = 0x3504f333*c.x*c.x + c.y;
    int y = 0xf1bbcdcb*c.y*c.y + c.x;
    
    return float(x*y)*(2.0/8589934592.0)+0.5;
inline float3 getCSPosition( float3 p, constant scn_ssao_uniforms_t& uni )
if(SSAOCameraOrtho)
return float3( (p.xy * uni.projectionInfo.xy + uni.projectionInfo.zw) , p.z);
else
return float3( (p.xy * uni.projectionInfo.xy + uni.projectionInfo.zw) * -p.z , p.z);
inline float3 getCSNormal( float3 p )
    return normalize( cross( dfdy(p), dfdx(p)) );
fragment float4 scn_ssao_compute(scn::draw_quad_io_t             in              [[ stage_in ]],
                                 texture2d<float>                depthSampler    [[ texture(0) ]],
                                 texture2d<uint>                 minMaxSampler   [[ texture(1) ]],
                                 constant scn_ssao_uniforms_t&    uni             [[ buffer(0)  ]])
    
    uint2 index = uint2(in.position.xy*SSAODownSample);
    if(SSAODownSample==2)
        index += uint2(gatherUV[ minMaxSampler.read(uint2(in.position.xy)).x ]);
    if(SSAODownSample==4)
    {
        uint id = minMaxSampler.read(uint2(in.position.xy)).x;
        index += uint2(gatherUV[ id/10 ]*2 + gatherUV[ id-(id/10)*10 ]);
    }
    
    
    // compute camera space info of the current pixel
    float4 nz = depthSampler.read(index);
    float3 ssP = float3(float2(index), nz.w ); // screen space
    float3 p = getCSPosition( ssP, uni); // camera space
    
    // sampling
    float ssRadius = uni.radius / -p.z ;
    float spinAngle = hash(index)*PI;
    
    float ao = 0.0;
    for(int i=0; i<SSAOSampleCount; i++)
    {
        // tap location
        float r = (float(i) + 0.5) * (1.0 / float(SSAOSampleCount));
        float theta = r * (7. * 2. * PI) + spinAngle;
        r *= ssRadius;
        float2 offset = float2(cos(theta), sin(theta)) * r;
        
        // get the camera space info of the tap location
        float3 sample_ssP = float3( float2(index)+offset, 0. ); // screen space
        int lvl = clamp( int(floor(log2(r))) -3, 0, int(depthSampler.get_num_mip_levels())-1 );
        uint2 uv = clamp( uint2(sample_ssP.xy) >> lvl, uint2(0), uint2(depthSampler.get_width(lvl),depthSampler.get_height(lvl))-1 );
        sample_ssP.z = depthSampler.read( uv, lvl ).w;
        float3 sample_p = getCSPosition( sample_ssP, uni ); // camera space
        
        // scalable ambient obscurance
        float3 v = sample_p - p;
        
        float vv = dot(v, v);
        float vn = dot(v, nz.xyz);
        
        float f = max(uni.radius2 - vv, 0.0);
        ao += f * f * f * max((vn - uni.bias) / (0.0001 + vv), 0.0);
    }
    
    
    ao = max(0.0, 1.0 - ao * uni.intensity / SSAOSampleCount * SSAODownSample  );
    
    
    // Magik bilateral box-filter over a quad for free
    if(SSAODownSample==1)
    {
        if (abs(dfdx(ssP.z)) < 0.02)
            ao -= dfdx(ao) * ((index.x & 1) - 0.5);
        if (abs(dfdy(ssP.z)) < 0.02)
            ao -= dfdy(ao) * ((index.y & 1) - 0.5);
    }
    
    return float4( ao, -ssP.z, float2(nz.xy) );
    
// -------------------------------------------------------------------------------------
// Depth aware bilateral blur
// -------------------------------------------------------------------------------------
static void scn_ssao_blur(ushort2                        index           [[ thread_position_in_grid ]],
                          ushort2                        id              [[ thread_position_in_threadgroup ]],
                          ushort2                        tileSize        [[ threads_per_threadgroup ]],
                          threadgroup half4*             tap             [[ threadgroup(0) ]],
                          texture2d<half, access::read>  aoSampler       [[ texture(0) ]],
                          texture2d<half, access::write> out             [[ texture(1) ]],
                          constant scn_ssao_uniforms_t&  uni             [[ buffer(0)  ]],
                          ushort2                        dim,
                          ushort2                        uv,
                          ushort2                        axis)
    
    
    //       [-- neg border --] [---------- real offset -----------] [-- pos border --]
    //       [0  1  2  3  4  5   6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23]
    
    // id 1  [ ][x][ ][ ][ ][ ] [ ][x][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ][ ]
    // id 17 [ ][ ][ ][ ][ ][ ] [ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][x] [ ][ ][ ][ ][ ][x]
    
    
    
    // get center tap
    id.x += SSAORadius*SSAOStride;
    half4 t = half4( aoSampler.read( uv ) );
    tap[id.x] = t;
    
    // get border tap
    if(id.x < SSAORadius*SSAOStride*2)
    {
        ushort dstI = id.x - SSAORadius*SSAOStride;
        tap[dstI] = half4( aoSampler.read( clamp(uv-axis*SSAORadius*SSAOStride, ushort2(0), dim) ) );
    }
else if((id.x >= tileSize.x ) && any( bool2(axis) && (uv < dim-SSAORadius*SSAOStride)) )
    {
        ushort dstI = id.x + SSAORadius*SSAOStride;
        tap[dstI] = half4( aoSampler.read( clamp(uv+axis*SSAORadius*SSAOStride, ushort2(0), dim) ) );
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    
    if (any(uv > dim))
        return;
    
    
    const half gaussian[7] = { 0.111220h, 0.107798h, 0.098151h, 0.083953h, 0.067458h, 0.050920h, 0.036108h };
    
    half2 ao = half2(tap[id.x].x * gaussian[0], 0.h);
    half2 weights = half2(gaussian[0], 0.h);
    
#if SSAO_BLUR
    
    half2 depthThreshold = half2(uni.depthThreshold);
    half4 normalThreshold = half4(uni.normalThreshold);
    for(ushort i=1; i<=SSAORadius; i++)
    {
        half4 lt = tap[id.x-i*SSAOStride];
        half4 rt = tap[id.x+i*SSAOStride];
        
        // gaussian + depth + normal weight
        half2 w = half2(gaussian[i]);
        
        half4 aoz = half4(lt.xy, rt.xy);
        w *= step( abs( aoz.yw - t.yy ), depthThreshold );
        
        half4 n = half4(lt.zw, rt.zw);
        half4 st = step( abs(t.zzww - n.xzyw), normalThreshold );
        w *= st.xy;
        w *= st.zw;
        
        // sum
        ao += aoz.xz * w;
        weights += w;
    }
#endif
    
    out.write( half4((ao.x+ao.y)/(weights.x+weights.y), t.yzw), uv);
kernel void scn_ssao_blur_x(ushort2                        index           [[ thread_position_in_grid ]],
                            ushort2                        id              [[ thread_position_in_threadgroup ]],
                            ushort2                        tileSize        [[ threads_per_threadgroup ]],
                            threadgroup half4*             tap             [[ threadgroup(0) ]],
                            texture2d<half, access::read>  aoSampler       [[ texture(0) ]],
                            texture2d<half, access::write> out             [[ texture(1) ]],
                            constant scn_ssao_uniforms_t&  uni             [[ buffer(0)  ]])
    ushort2 dim = ushort2(out.get_width()-1, out.get_height()-1);
    scn_ssao_blur(index, id, tileSize, tap, aoSampler, out, uni, dim, index, ushort2(1,0) );
    
kernel void scn_ssao_blur_y(ushort2                        index           [[ thread_position_in_grid ]],
                            ushort2                        id              [[ thread_position_in_threadgroup ]],
                            ushort2                        tileSize        [[ threads_per_threadgroup ]],
                            threadgroup half4*             tap             [[ threadgroup(0) ]],
                            texture2d<half, access::read>  aoSampler       [[ texture(0) ]],
                            texture2d<half, access::write> out             [[ texture(1) ]],
                            constant scn_ssao_uniforms_t&  uni             [[ buffer(0)  ]])
    ushort2 dim = ushort2(out.get_width()-1, out.get_height()-1);
    scn_ssao_blur(index.yx, id.yx, tileSize.yx, tap, aoSampler, out, uni, dim, index, ushort2(0,1) );
// -------------------------------------------------------------------------------------
// Upsampling
// -------------------------------------------------------------------------------------
kernel void scn_ssao_upsampling(ushort2                            index           [[ thread_position_in_grid ]],
                                texture2d<half, access::sample> aoSampler       [[ texture(0) ]],
                                texture2d<half, access::sample>   depthSampler    [[ texture(1) ]],
                                texture2d<half, access::write>  out             [[ texture(2) ]],
                                constant scn_ssao_uniforms_t&  uni               [[ buffer(0)  ]])
    if (index.x >= out.get_width() || index.y >= out.get_height())
        return;
    
    constexpr sampler samp(coord::pixel, filter::nearest, address::clamp_to_zero);
    constexpr sampler samp_linear(coord::pixel, filter::linear, address::clamp_to_zero);
    
    
    float2 uv = float2((index)/SSAODownSample)-.5;
    float2 uvLin = ((float2(index/SSAODownSample)));
    
#if SSAO_UPSAMPLING
    // gather pixels
    half4 lowZ = aoSampler.gather(samp, uv, int2(0), component::y) ;
    half z = depthSampler.read( index ).w;
    
    
    // nearest depth sample
    half4 w = abs(lowZ + z); // + because z is negative
    ushort minID = scn_vector_min_index(w);
    ushort maxID = scn_vector_max_index(w);
    
    
    uvLin = mix(uvLin, uv + float2(gatherUV[minID]), float( step(half(uni.depthThreshold), w[maxID]) ) );
#endif
    half ao = aoSampler.sample(samp_linear, uvLin ).r;
//    ao = step(uni.depthThreshold, w[maxID]);
//    ao = step(uni.bias, w[maxID]/z);
//    if( abs(index.x - out.get_width()/2) < 1 )
//        ao = 0.;
    
    out.write( half4(ao), index );
// Parallel reduction related radars
#include <metal_stdlib>
using namespace metal;
inline int lower_power_of_2(int x)
    //    return 1 << (32 - __builtin_clz (x - 1));
    return 1 << (32 - clz(x - 1));
inline uint lower_power_of_2(uint x)
    //    return 1 << (32 - __builtin_clz (x - 1));
    return 1 << (31 - clz(x));
static inline float4 reduce_op(float4 d0, float4 d1)
    d0.x = min(d0.x, d1.x);
    d0.y = max(d0.y, d1.y);
    d0.z += d1.z;
    d0.w += d1.w;
    return d0;
inline float vector_reduce_min(float4 v)
    float2 min_lh = min(v.xy, v.zw);
    return min(min_lh.x, min_lh.y);
inline float vector_reduce_max(float4 v)
    float2 max_lh = max(v.xy, v.zw);
    return max(max_lh.x, max_lh.y);
inline int vector_reduce_add(int4 v)
    int2 add_lh = v.xy + v.zw;
    return add_lh.x + add_lh.y;
inline int4 znon1(float4 d)
    return select(int4(0), int4(1), d < 1.f);
// downsample 2x
kernel void depth_minmax_down_x2_init(uint2 index [[ thread_position_in_grid ]]
                                 , constant uint2& dstSize [[ buffer(0) ]]
                                 , depth2d<float, access::sample> input_tex [[ texture(0) ]]
                                 , texture2d<float, access::write> output_tex [[ texture(1) ]]
                                 )
    if (index.x >= dstSize.x || index.y >= dstSize.y)
        return;
    
    uint2 srcIndex = index * 2; // downsampling 2
    
    constexpr sampler smp(filter::nearest, coord::pixel);
    float4 d = input_tex.gather(smp, float2(srcIndex));
    
    float4 minmax;
    minmax.x = vector_reduce_min(d);
    minmax.y = vector_reduce_max(d);
    minmax.z = vector_reduce_add(znon1(d));
    minmax.w = 4.f;
    output_tex.write(minmax, index);
kernel void depth_minmax_down_x2(uint2 index [[ thread_position_in_grid ]]
                                 , constant uint2& dstSize [[ buffer(0) ]]
                                 , texture2d<float, access::read> input_tex [[ texture(0) ]]
                                 , texture2d<float, access::write> output_tex [[ texture(1) ]]
                                 )
    if (index.x >= dstSize.x || index.y >= dstSize.y)
        return;
    
    uint2 srcIndex = index * 2; // downsampling 2
    
    constexpr sampler smp(filter::nearest, coord::pixel);
    float4 d0 = input_tex.read(srcIndex);
    float4 d1 = input_tex.read(srcIndex + uint2(1, 0));
    float4 d2 = input_tex.read(srcIndex + uint2(0, 1));
    float4 d3 = input_tex.read(srcIndex + uint2(1, 1));
    
    float4 minmax;
    minmax.x = min( min(d0.x, d1.x), min(d2.x, d3.x) );
    minmax.y = max( max(d0.y, d1.y), max(d2.y, d3.y) );
    minmax.z = d0.z + d1.z + d2.z + d3.z;
    minmax.w = d0.w + d1.w + d2.w + d3.w;
    output_tex.write(minmax, index);
// downsample 4x
kernel void scn_depthlinear_minmax_downx4_init(uint2 index [[ thread_position_in_grid ]]
                                      , constant uint2& dstSize [[ buffer(0) ]]
                                      , texture2d<float, access::sample> input_tex [[ texture(0) ]]
                                      , texture2d<float, access::write> output_tex [[ texture(1) ]]
                                      )
    if (index.x >= dstSize.x || index.y >= dstSize.y)
        return;
    
    uint2 srcIndex = index * 4; // downsampling 2
    
    constexpr sampler smp(filter::nearest, coord::pixel);
    float4 d0 = input_tex.gather(smp, float2(srcIndex));
    float4 d1 = input_tex.gather(smp, float2(srcIndex) + float2(2, 0));
    float4 d2 = input_tex.gather(smp, float2(srcIndex) + float2(0, 2));
    float4 d3 = input_tex.gather(smp, float2(srcIndex) + float2(2, 2));
    
    const float4 clearValue = 1.f;
    
    float4 dmin = 10000.f;
    float4 dm0 = select(d0, dmin, d0 == clearValue);
    float4 dm1 = select(d1, dmin, d1 == clearValue);
    float4 dm2 = select(d2, dmin, d2 == clearValue);
    float4 dm3 = select(d3, dmin, d3 == clearValue);
    float4 dmax = -10000.f;
    float4 dM0 = select(d0, dmax, d0 == clearValue);
    float4 dM1 = select(d1, dmax, d1 == clearValue);
    float4 dM2 = select(d2, dmax, d2 == clearValue);
    float4 dM3 = select(d3, dmax, d3 == clearValue);
    float4 minmax;
    minmax.x = vector_reduce_min(min( min(dm0, dm1), min(dm2, dm3) ));
    minmax.y = vector_reduce_max(max( max(dM0, dM1), max(dM2, dM3) ));
    minmax.z = vector_reduce_add(znon1(d0) + znon1(d1) + znon1(d2) + znon1(d3));
    minmax.w = 16.f;
    output_tex.write(minmax, index);
// ProjectionsInfos = float2(projMatrix._43, projMatrix._33)
kernel void scn_depth_minmax_downx4_init(uint2 index [[ thread_position_in_grid ]]
                                         , constant uint2& dstSize [[ buffer(0) ]]
                                         , constant float2& projectionInfos [[ buffer(1) ]]
                                         , depth2d<float, access::sample> input_tex [[ texture(0) ]]
                                         , texture2d<float, access::write> output_tex [[ texture(1) ]]
                                         )
    if (index.x >= dstSize.x || index.y >= dstSize.y)
        return;
    
    uint2 srcIndex = index * 4; // downsampling 2
    
    constexpr sampler smp(filter::nearest, coord::pixel);
    float4 d0 = input_tex.gather(smp, float2(srcIndex));
    float4 d1 = input_tex.gather(smp, float2(srcIndex) + float2(2, 0));
    float4 d2 = input_tex.gather(smp, float2(srcIndex) + float2(0, 2));
    float4 d3 = input_tex.gather(smp, float2(srcIndex) + float2(2, 2));
    
    // convert to linear
    float4 dl0 = projectionInfos.x / (projectionInfos.y - d0);
    float4 dl1 = projectionInfos.x / (projectionInfos.y - d1);
    float4 dl2 = projectionInfos.x / (projectionInfos.y - d2);
    float4 dl3 = projectionInfos.x / (projectionInfos.y - d3);
    
    const float4 clearValue = 1.f;
    
    float4 dmin = 1000.f;
    float4 dm0 = select(dl0, dmin, d0 == clearValue);
    float4 dm1 = select(dl1, dmin, d1 == clearValue);
    float4 dm2 = select(dl2, dmin, d2 == clearValue);
    float4 dm3 = select(dl3, dmin, d3 == clearValue);
    
    float4 dmax = -1000.f;
    float4 dM0 = select(dl0, dmax, d0 == clearValue);
    float4 dM1 = select(dl1, dmax, d1 == clearValue);
    float4 dM2 = select(dl2, dmax, d2 == clearValue);
    float4 dM3 = select(dl3, dmax, d3 == clearValue);
    
    float4 minmax;
    minmax.x = vector_reduce_min(min( min(dm0, dm1), min(dm2, dm3) ));
    minmax.y = vector_reduce_max(max( max(dM0, dM1), max(dM2, dM3) ));
    minmax.z = vector_reduce_add(znon1(d0) + znon1(d1) + znon1(d2) + znon1(d3));
    minmax.w = 16.f;
    output_tex.write(minmax, index);
kernel void scn_depth_minmax_downx4_step(uint2 index [[ thread_position_in_grid ]]
                                 , constant uint2& dstSize [[ buffer(0) ]]
                                 , texture2d<float, access::read> input_tex [[ texture(0) ]]
                                 , texture2d<float, access::write> output_tex [[ texture(1) ]]
                                 )
    if (index.x >= dstSize.x || index.y >= dstSize.y)
        return;
    
    uint2 srcIndex = index * 4; // downsampling 2
    
    constexpr sampler smp(filter::nearest, coord::pixel);
    
    float4 minmax(1000.f, -1000.f, 0.f, 0.f);
    
    for (int y = 0; y < 4; ++y) {
        for (int x = 0; x < 4; ++x) {
            float4 d0 = input_tex.read(srcIndex + uint2(x, y));
            minmax.x = min( minmax.x, d0.x );
            minmax.y = max( minmax.y, d0.y );
            minmax.z += d0.z;
            minmax.w += d0.w;
        }
    }
    output_tex.write(minmax, index);
kernel void scn_depth_minmax_tail(uint2 index [[ thread_position_in_grid ]]
                                      , uint tid [[ thread_index_in_threadgroup ]]
                                      , uint2 tileSize [[ threads_per_threadgroup ]]
                                      , device float4& minmax [[ buffer(1) ]]
                                      , texture2d<float, access::read> input_tex [[ texture(1) ]]
                                      )
    threadgroup float4 sdata[32 * 32];
    
    // each thread loads one element from global to shared mem unsigned int tid = threadIdx.x;
    sdata[tid] = input_tex.read(index);
    threadgroup_barrier(mem_flags::mem_threadgroup);
    
    uint threadCount = tileSize.x * tileSize.y;
    
    // optim this could be done in CPU and given to the shader
    uint tc2 = lower_power_of_2(threadCount);
    
    // reduction #3
    for (uint s=tc2/2; s>0; s>>=1) {
        if (tid < s) {
            float4 d0 = sdata[tid];
            float4 d1 = sdata[tid + s];
            sdata[tid] = reduce_op( d0, d1 );
        }
        threadgroup_barrier(mem_flags::mem_threadgroup);
    }
    
    // threadgroup_barrier(mem_flags::mem_device);
    // write result for this block to global mem
    if (tid == 0) {
        
        // the previous block only works for power of 2
        // so we need to take into account the remaining threads
        float4 v = sdata[0];
        for(unsigned int s=tc2; s < threadCount; ++s) {
            float4 d = sdata[s];
            v = reduce_op( v, d );
        }
        minmax = v;
        //        minmax = sdata[0];
    }
typedef struct __attribute__((__aligned__(256))) {
    // tone mapping
    float whitePoint;
    float averageLuminance;
    float minimumExposure;
    float maximumExposure;
    float exposureOffset;
    
    // exposure adaptation
    float exposureAdaptationDuration;
    float exposureAdaptationBrighteningSpeedFactor;
    float exposureAdaptationDarkeningSpeedFactor;
    
    float bloomThreshold;
    float bloomOffset;
    float bloomIntensity;
    float colorGradingIntensity;
    
    float vignettingPower;
    float vignettingIntensity;
    
    float fringeStrength;
    float fringeIntensity;
    
    float saturation;
    float contrast;
    
    float dt;
    uint32_t adaptationCurrentFrame;
    uint32_t adaptationFrameCount;
    
    
    // depth of field
    vector_float2 dofCocScaleBias;
    float dofIntensity;
    int dofBladeCount;
    float fStop;
    
    // motion blur
    float mbIntensity;
} scn_postprocess_uniforms_t;
typedef struct {
    float exposure;
    float averageLum;
} scn_autoexposure_parameters_t;
#define MAX_PAIR_SAMPLE_COUNT 15u
#define MAX_DOF_SAMPLE_COUNT 64
typedef struct {
    vector_float3   offsets_weight[1 + MAX_PAIR_SAMPLE_COUNT];
    
} scn_bloom_uniforms_t;
  "passes" : {
    "SceneKit_renderSceneFromLight" : {
      "outputs" : {
        "depth" : "SceneKit-spotShadowDepth"
      },
      "depthStates" : {
        "clear" : true
      },
      "samples" : 1,
      "onlyShadowCasters" : true,
      "pointOfView" : "self",
      "ignoreFloors" : true,
      "draw" : "DRAW_SCENE"
    },
    "SceneKit_applyDeferredShadows" : {
      "outputs" : {
        "color" : "COLOR"
      },
      "inputs" : {
          "light_MVP" : "C3D-light_MVP-symbol",
          "viewTransform" : "C3D-camera_view-symbol",
          "depthSampler" : {
          "target" : "DEPTH",
          "sampler" : {
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest"
          }
        },
        "u_kernel" : "C3D-shadowKernel-symbol",
        "lightDepthSampler" : {
          "target" : "SceneKit-spotShadowDepth",
          "sampler" : {
            "wrapS" : "clamp",
            "magnificationFilter" : "nearest",
            "minificationFilter" : "nearest",
            "wrapT" : "clamp"
          }
        },
        "shadowColor" : "C3D-shadowColor-symbol",
        "colorSampler" : "COLOR",
        "camera_MVP_i" : "C3D-camera_MVP_i-symbol",
        "viewSpaceSplitDistances" : "C3D-shadowCascadeSplit-symbol",
        "cascadeDebugFactor" : "C3D-shadowCascadeDebugFactor-symbol",
        "u_lightPos" : "C3D-u_lightPos-symbol",
        "u_lightDir" : "C3D-u_lightDir-symbol",
        "shadowRadius" : "C3D-shadowRadius-symbol",
        "u_lightSpotAtt" : "C3D-u_lightSpotAtt-symbol"
      },
      "metalFragmentShader" : "shadowMap_frag",
      "draw" : "DRAW_QUAD",
      "clientProgram" : false,
      "metalVertexShader" : "shadowMap_vert"
    }
  },
  "sequence" : [
    "SceneKit_renderSceneFromLight",
    "SceneKit_applyDeferredShadows"
  ],
  "symbols" : {
    "C3D-u_lightSpotAtt-symbol" : {
      "type" : "vec3"
    },
    "C3D-shadowColor-symbol" : {
      "type" : "vec4"
    },
    "C3D-camera_MVP_i-symbol" : {
      "type" : "mat4"
    },
    "C3D-camera_view-symbol" : {
      "type" : "mat4"
    },
    "C3D-u_lightPos-symbol" : {
      "type" : "vec3"
    },
    "C3D-zMapFactor-symbol" : {
      "type" : "float"
    },
    "C3D-light_MVP-symbol" : {
      "type" : "mat4[4]"
    },
    "C3D-shadowRadius-symbol" : {
      "type" : "float"
    },
    "C3D-shadowCascadeDebugFactor-symbol" : {
      "type" : "float"
    },
    "C3D-shadowKernel-symbol" : {
      "type" : "vec4[128]"
    },
    "C3D-shadowCascadeSplit-symbol" : {
      "type" : "float[5]"
    },
    "C3D-u_lightDir-symbol" : {
      "type" : "vec3"
    }
  },
  "targets" : {
    "SceneKit-spotShadowDepth" : {
      "type" : "depth"
    }
#import <metal_stdlib>
using namespace metal;
#import "C3D-PostProcess.h"
#import "scn_metal"
#import "C3D-PostProcessUtils.h"
using namespace scn;
#define MOTIONBLUR_DEBUG 0
#define PI 3.141592653589
// -------------------------------------------------------------------------------------
// Utils
// -------------------------------------------------------------------------------------
#if MOTIONBLUR_DEBUG
static inline float lineDist(float2 p, float2 start, float2 end, float width)
    float2 dir = start - end;
    float lngth = length(dir);
    dir /= lngth;
    float2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;
    return length( (start - p) - proj ) - (width / 2.0);
#endif
static inline float hash12(float2 p)
    float3 p3  = fract(float3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
static inline float2 jitterTile( float2 uv )
    float theta = hash12(uv) * PI * 2.;
    return float2( cos(theta), sin(theta) ) * 0.5 ;
static inline half scn_weight(half2 base, half2 tap_vz, half i, half len)
    half d;
    
    half2 depth = saturate( 0.5h + half2(1.h,-1.h)*(base.y-tap_vz.y));
    half2 spread = saturate( 1.h + len * half2(tap_vz.x, base.x) - i );
    d = dot(depth,spread);
    
    return d;
// -------------------------------------------------------------------------------------
// I/O + Vertex Shader
// -------------------------------------------------------------------------------------
struct scn_motionblur_uniforms_t {
    float4x4 viewProjectionInverseMatrix;
    float4x4 oldViewProjectionMatrix;
    float intensity;
struct scn_motionblur_io_t {
    float4 position [[position]];
    float2 texCoord; // [ 0, 1]
    float2 uv;       // [-1, 1]
vertex scn_motionblur_io_t scn_motionblur_vert(uint v_id [[ vertex_id ]])
    scn_motionblur_io_t out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    out.uv       = out.position.xy;
    return out;
// -------------------------------------------------------------------------------------
// Downsample velocity + dilate
// -------------------------------------------------------------------------------------
kernel void scn_motionblur_tilemax(ushort2                        index    [[ thread_position_in_grid ]],
                                   texture2d<half, access::sample>  tex      [[ texture(0) ]],
                                   texture2d<half, access::write> out      [[ texture(1) ]])
    
    if (index.x >= out.get_width() || index.y >= out.get_height())
        return;
    
    constexpr sampler samp(coord::pixel, filter::nearest);
    ushort2 uv = index*2;
    
    half4 v = tex.gather(samp, float2(uv)+.5, int2(0), component::z);
    ushort id = scn_vector_max_index( v );
    
    out.write( tex.read( uv + gatherUV[id] ), index);
static void scn_motionblur_neighbormax(ushort2                         index            [[ thread_position_in_grid ]],
                                       texture2d<half, access::sample> velocitySampler  [[ texture(0) ]],
                                       texture2d<half, access::write>  out              [[ texture(1) ]],
                                       int2 axis)
    if (index.x >= out.get_width() || index.y >= out.get_height())
        return;
    
    int2 uv = int2(index);
    
    half3x4 v;
    v[0] = velocitySampler.read( ushort2(uv + axis ) );
    v[1] = velocitySampler.read( ushort2(uv) );
    v[2] = velocitySampler.read( ushort2(uv - axis) );
    
    // get max id
    ushort id = step(v[0].z, v[1].z);
    id = id + step(v[id].z, v[2].z)*(2-id);
    
    
    out.write( v[id], index);
kernel void scn_motionblur_neighbormax_x(ushort2                         index            [[ thread_position_in_grid ]],
                                         texture2d<half, access::sample> velocitySampler  [[ texture(0) ]],
                                         texture2d<half, access::write>  out              [[ texture(1) ]])
    scn_motionblur_neighbormax( index, velocitySampler, out, int2(1,0));
kernel void scn_motionblur_neighbormax_y(ushort2                         index            [[ thread_position_in_grid ]],
                                         texture2d<half, access::sample> velocitySampler  [[ texture(0) ]],
                                         texture2d<half, access::write>  out              [[ texture(1) ]])
    scn_motionblur_neighbormax( index, velocitySampler, out, int2(0,1));
// -------------------------------------------------------------------------------------
// Motion blur
// -------------------------------------------------------------------------------------
fragment half4 scn_motionblur_blur(scn_motionblur_io_t                  in              [[ stage_in   ]],
                                          texture2d<half, access::sample>      velocitySampler [[ texture(0) ]],
                                          texture2d<half, access::sample>      neighborSampler [[ texture(1) ]],
                                          texture2d<half, access::sample>      colorSampler    [[ texture(2) ]],
                                          constant scn_postprocess_uniforms_t& uni             [[ buffer(0)  ]])
    constexpr sampler samp(filter::nearest);
    
    const ushort nbSamples = 6;
    // neighborMax infos
    half3 max_v = neighborSampler.sample(samp, in.texCoord+jitterTile(in.position.xy)/float2(neighborSampler.get_width(),neighborSampler.get_height())).xyz ;
    // get infos at the center point
    half4 base_v = velocitySampler.sample(samp, in.texCoord);
    half4 base_c = colorSampler.sample(samp, in.texCoord);
    
    // useless blur ?
    if( max_v.z < 0.001 ) return base_c;
    
    // sampling direction
    max_v *= (2.h / nbSamples);
    max_v.z = 1./max_v.z; // precalc
    
    half dither = hash12(in.position.xy)-.5;
    //return half4(dither);
    half4 col = half4(0.h);
    for(ushort i=0; i<nbSamples/2; i++)
    {
        // compute direction & uv
        half t = half(i) + dither;
        float4 uv = in.texCoord.xyxy + float4(max_v.xyxy * half4(1.,1., -1., -1.) * t);
        
        // get the taps in direction*(-1, 1)
        half2 tap1_vz = velocitySampler.sample(samp, uv.xy).zw;
        half2 tap2_vz = velocitySampler.sample(samp, uv.zw).zw;
        
        // compute weights
        half w1 = scn_weight(base_v.zw, tap1_vz, t,max_v.z);
        half w2 = scn_weight(base_v.zw, tap2_vz, t,max_v.z);
        
        // mirror mode to reconstruct the background better..
        bool2 mirror = bool2( tap1_vz.y > tap2_vz.y, tap1_vz.x < tap2_vz.x );
        w1 = all( mirror ) ? w2 : w1;
        w2 = any( mirror ) ? w2 : w1;
        
        // accumulate samples
        col += half4(colorSampler.sample(samp, uv.xy ).rgb, 1.h) * w1;
        col += half4(colorSampler.sample(samp, uv.zw ).rgb, 1.h) * w2;
    }
    
    
    col.rgba *= 1./nbSamples;
    col.rgb += base_c.rgb * (1.h - saturate(col.a)); // center tap
#if MOTIONBLUR_DEBUG
    {
        //col = half4(0.);
        float2 res = float2(colorSampler.get_width(),colorSampler.get_height());
        half2 vel = neighborSampler.sample(samp, in.texCoord).xy*2.;
        float2 cell = float2(res)/floor(float2(res) / 64.);
        float2 p = fmod(in.position.xy, cell);
        
        //grid
        if( any( p < float2(1.) ) )
            col = half4(1.);
        else if( any( p < float2(2.) ) || any( p >= cell-float2(1.) ) )
            col = half4(.5h);
        if( max_v.z < 0.004 )
            vel.xy = half2(0.01);
        //vector
        if( lineDist(p/cell, float2(.5)-float2((vel)), float2(.5)+float2((vel)), .08
) < .001 )
            col *= half4(0.25);
        if( lineDist(p/cell, float2(.5)-float2((vel)), float2(.5)+float2((vel)), .05
) < .001 )
            col = half4(1.);
        //check grid
        //col.xy += vel;
        //
        //    float2 offset = (p-cell/2)/cell;
        //    if(dither<abs(offset.x))
        //        offset = float2(1., 0.)*sign(offset);
        //    else if(dither<abs(offset.y))
        //        offset = float2(0., 1.)*sign(offset);
        //    else
        //        offset = float2(0.);
        //    col.xy += half2(abs(offset));
    }
#endif
    
    return half4(col.rgb, base_c.a);
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
#import "scn_util.h"
#import "C3D-PostProcessUtils.h"
// I/O struct:
typedef struct {
    float4 position [[position]];
    float4 color;
} directmesh_io;
struct blendAuthoring_io {
    float4 position [[position]];
    float2 texCoord;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Blend authoring
vertex blendAuthoring_io blendAuthoring_vert( uint v_id [[ vertex_id ]] )
    blendAuthoring_io out;
    out.position = scn::draw_quad_pos_from_id(v_id, 1.0);
    out.texCoord = scn::draw_quad_texcoord_from_id(v_id);
    return out;
fragment float4 blendAuthoring_frag( blendAuthoring_io in [[stage_in]],
                             texture2d<float> sceneColor [[texture(0)]],
                             texture2d<float> authoringColor [[texture(1)]],
                             depth2d<float> sceneDepth [[texture(2)]],
                             depth2d<float> authoringDepth [[texture(3)]],
                             constant SCNSceneBuffer& scn_frame [[buffer(0)]])
    constexpr sampler samp(filter::nearest);
    const float2 uv = in.texCoord;
    
    
    float4 scene = sceneColor.sample(samp, uv);
    float4 authoring = authoringColor.sample(samp, uv);
    
    float scene_depth = sceneDepth.sample(samp, uv);
    float authoring_depth = authoringDepth.sample(samp, uv);
    
    if(scene_depth < authoring_depth){
        authoring.rgb *= 0.75;
    }
    
    return mix(scene, authoring, authoring.a);
    
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Color Only
// Vertex shader function
typedef struct
    float4x4 modelViewProjectionTransform;
    float4 color;
} directmesh_vertex_uniforms_t;
typedef struct {
    float3 position [[attribute(SCNVertexSemanticPosition)]];
    float4 color [[attribute(SCNVertexSemanticColor)]];
} directmesh_vertex_color_t; // __attribute__((scn_per_frame));
vertex directmesh_io ManipulatorColorOnly_vert(directmesh_vertex_color_t in [[ stage_in ]],
                                               constant SCNSceneBuffer& frameUniforms [[buffer(0)]],
                                               constant directmesh_vertex_uniforms_t& myUniform [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    directmesh_io out;
    out.position = (myUniform.modelViewProjectionTransform * in_position);
    out.color.rgba = in.color;
    return out;
// Fragment shader function
fragment half4 ManipulatorColorOnly_frag(directmesh_io in [[stage_in]])
    return half4(in.color);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Color and Texture
typedef struct {
    float3 position [[attribute(SCNVertexSemanticPosition)]];
    float4 color [[attribute(SCNVertexSemanticColor)]];
    float2 uv [[attribute(SCNVertexSemanticTexcoord0)]];
} directmesh_vertex_color_uv_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float4 color;
    float2 uv;
} directmesh_uv_io;
vertex directmesh_uv_io ManipulatorColorAndTexture_vert(directmesh_vertex_color_uv_t in [[ stage_in ]],
                                                     constant SCNSceneBuffer& frameUniforms [[buffer(0)]],
                                                     constant directmesh_vertex_uniforms_t& myUniform [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    directmesh_uv_io out;
    out.position = (myUniform.modelViewProjectionTransform * in_position);
    out.color.rgba = in.color;
    out.uv = in.uv;
    return out;
// Fragment shader function
//fragment half4 ManipulatorColorAndTexture_frag(directmesh_io in [[stage_in]])
//    return half4(in.color);
fragment half4 ManipulatorColorAndTexture_frag(directmesh_uv_io in [[stage_in]],
                                    texture2d<float> tex [[texture(0)]])
    constexpr sampler linear_sampler(min_filter::linear, mag_filter::linear);
    float4 color = tex.sample(linear_sampler, in.uv) * in.color;
    //    color.rgb = in.texcoord * 0.5 + 0.5;
    return half4(color);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Vertex Only
typedef struct {
    float3 position [[attribute(SCNVertexSemanticPosition)]];
} directmesh_vertex_t; // __attribute__((scn_per_frame));
vertex directmesh_io Manipulator_vert(directmesh_vertex_t in [[ stage_in ]],
                                      constant SCNSceneBuffer& frameUniforms [[buffer(0)]],
                                      constant directmesh_vertex_uniforms_t& myUniform [[buffer(1)]])
    float4 in_position = float4(in.position, 1.0);
    
    directmesh_io out;
    out.position = (myUniform.modelViewProjectionTransform * in_position);
    out.color.rgba = myUniform.color;
    return out;
// Fragment shader function
fragment half4 Manipulator_frag(directmesh_io in [[stage_in]])
    return half4(in.color);
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// WireFrame
// Vertex shader function
typedef struct
    float4x4 modelViewProjectionTransform;
    float4 color;
} wireframe_vertex_uniforms_t;
typedef struct {
    float3 position [[attribute(SCNVertexSemanticPosition)]];
} wireframe_vertex_color_t; // __attribute__((scn_per_frame));
typedef struct {
    float4 position [[position]];
    float3 center;
} wireframe_io;
vertex wireframe_io ManipulatorWireframe_vert(
                                              uint v_id [[ vertex_id ]],
                                              directmesh_vertex_color_t in [[ stage_in ]],
                                               constant SCNSceneBuffer& frameUniforms [[buffer(0)]],
                                               constant wireframe_vertex_uniforms_t& myUniform [[buffer(1)]]
                                              )
    float4 in_position = float4(in.position, 1.0);
    
    wireframe_io out;
    out.position = (myUniform.modelViewProjectionTransform * in_position);
    int id = v_id % 3;
    float s = 1;
    float3x3 centers = float3x3(float3(s, 0 ,0), float3(0, s, 0), float3(0, 0, s));
    out.center = centers[id];
    return out;
// Fragment shader function
float3 smooth(float3 edge0, float3 edge1, float3 x);
float3 smooth(float3 edge0, float3 edge1, float3 x)
    float3 t = clamp((x - edge0)/(edge1 - edge0), float3(0.), float3(1));
    return t * t * (3 - 2 * t);
fragment half4 ManipulatorWireframe_frag(wireframe_io in [[stage_in]],
                                         constant wireframe_vertex_uniforms_t& myUniform [[buffer(1)]]
                                         )
    float3 d = fwidth(in.center);
    float3 a3 = smooth(float3(0.0), d * 1.5, in.center);
//    float3 a3 = smoothstep(float3(0.0), d * 1.5, in.center);
    float edge =  min(min(a3.x, a3.y), a3.z);
    
    return half4(myUniform.color * (1.0 - edge) * 0.95);
// vertex data
attribute vec2 a_texCoord1; // x:cornerX y:cornerY
// instance data
attribute vec4 a_position; // xyz: position, w:angle
attribute vec3 a_texCoord0; // x:life y:size z:frame (texture animation)
attribute vec4 a_color; // particle color
#ifdef ENABLE_STRETCH
attribute vec4 a_texCoord2; // velocity of the particle in .xyz
uniform float u_stretchFactor;
#elif defined(ENABLE_ORIENTATION_FREE)
attribute vec4 a_texCoord2; // orientation in free mode as an axis angle
mat3 axisangle_to_matrix(vec4 axis_angle)
float c = cos(axis_angle.w);
    float s = sin(axis_angle.w);
    float t = 1. - c;
    
    mat3 m;
    m[0][0] = c + axis_angle.x * axis_angle.x * t;
    m[1][1] = c + axis_angle.y * axis_angle.y * t;
    m[2][2] = c + axis_angle.z * axis_angle.z * t;
    
float tmp1 = axis_angle.x * axis_angle.y * t;
    float tmp2 = axis_angle.z * s;
    m[1][0] = tmp1 + tmp2;
    m[0][1] = tmp1 - tmp2;
    
    tmp1 = axis_angle.x * axis_angle.z * t;
    tmp2 = axis_angle.y * s;
    m[2][0] = tmp1 - tmp2;
    m[0][2] = tmp1 + tmp2;
    
    tmp1 = axis_angle.y*axis_angle.z*t;
    tmp2 = axis_angle.x*s;
    m[2][1] = tmp1 + tmp2;
    m[1][2] = tmp1 - tmp2;
    return m;
#endif
#ifdef ENABLE_FOG
uniform mediump vec4 u_fogColor;
uniform vec3 u_fogParameters; // x:-1/(end-start) y:1-start*x z:exp
#endif
#ifdef ENABLE_SOFT
varying float v_eyeLinearZ;
#endif
#ifdef ENABLE_CUBE_MAP
uniform mat4 u_viewToCubeWorld;
varying vec4 v_normal;
#endif
#ifdef ENABLE_ANIMATION
#define REPEAT 0
#define CLAMP 1
#define AUTOREVERSE  2
uniform vec4 u_frameSize; // 1/dimX, 1/dimY, dimX, dimX*dimY
// modf Only available for CoreProfile & GLES 3.0
float __modf(float value, out float intValue)
float fracValue = fract(value);
intValue = value - fracValue;
return fracValue;
vec4 ComputeUVS(vec2 iNormUV, float iFrame)
vec4 outUV;
#if ENABLE_ANIMATION == CLAMP
    
    iFrame = clamp(iFrame, 0., u_frameSize.w - 1.); // clamp frame
    
    float intFrame;
    float frameFrac = __modf(iFrame, intFrame);
    vec2 frame;
    frame.x = __modf(intFrame * u_frameSize.x, frame.y);
    frame.y *= u_frameSize.y;
    
    outUV.xy = frame + iNormUV * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = ((frame.x + u_frameSize.x) == 1.)?1.:0.; // next row or not
#elif ENABLE_ANIMATION == REPEAT
    
    float tmp = iFrame * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; // next row or not
#else // AUTOREVERSE
    
    float invFrameCount = u_frameSize.x * u_frameSize.y;
    float normFrame = iFrame * invFrameCount;
    float lastFrame = u_frameSize.w - 1.;
    float frameIndex = fract(normFrame) * u_frameSize.w;
    if (fract(normFrame * 0.5) > 0.5) {
        frameIndex = (lastFrame-frameIndex);
    }
    frameIndex = clamp(frameIndex, 0., lastFrame); // clamp frame
    
    float tmp = frameIndex * u_frameSize.x;
    
    vec2 frame;
    frame.y = tmp - fract(tmp);
    
    frame.x = fract(tmp) * u_frameSize.z;
    
    float frameFrac = fract(frame.x);
    frame.x -= frameFrac;
    
    outUV.xy = (frame + iNormUV) * u_frameSize.xy;
    
    outUV.w = frameFrac;
    outUV.z = (frame.x == (u_frameSize.z - 1.))?1.:0.; // next row or not
#endif
return outUV;
#endif
uniform mat4 viewTransform; // this should contain only the viewTransform if part are in world space or modelViewTransform otherwise
uniform mat4 u_projectionTransform;
#ifdef ENABLE_LIGHTING
// lighting
uniform vec3 u_lightPosition0; // in modelViewSpace already
uniform vec4 u_lightColor0;
#endif
#ifdef ENABLE_COLOR_RAMP
uniform sampler2D u_colorRamp;
#endif
#ifdef ENABLE_ANIMATION
varying vec3 v_uv0;
varying vec2 v_uv1;
#else
varying vec2 v_uv0;
#endif
varying vec4 v_vertexColor;
void main()
    // transform the particle in view space
    vec4 viewPos = viewTransform * vec4(a_position.xyz, 1);
#ifdef ENABLE_STRETCH
    // compute the trail direction in viewSpace
    vec4 viewDir = viewTransform * vec4(a_texCoord2.xyz, 0);
    viewDir *= u_stretchFactor;
    
    // move the top vertices to the end of the trail
    viewPos.xyz += (a_texCoord1.y > 0.) ? viewDir.xyz : vec3(0.);
    
    // compute the billboarding offsets
//    float len = length(viewDir.xy);
//    vec2 u = (len > 0.) ? viewDir.xy/len : vec2(0,1);
    vec2 u = normalize(viewDir.xy); // divide by 0 seems to work.. otherwise replace by code commented beneath
    vec2 r = vec2(-u.y, u.x);
    vec2 off = r * a_texCoord1.x + u * a_texCoord1.y ; // offset
    viewPos.xy += off * a_texCoord0.y; // * size
    vec3 N = normalize(vec3(-off.x, -off.y, -2));
    
#else // ENABLE_STRETCH
    
    // TODO only rotate if needed (angle != 0)
    float sn = sin(a_position.w);
    float cs = cos(a_position.w);
    // expand the quad corners
    vec2 dir = vec2( a_texCoord1.x * cs - a_texCoord1.y * sn,  a_texCoord1.y * cs + a_texCoord1.x * sn);
    dir *= a_texCoord0.y;
#ifdef ENABLE_ORIENTATION_FREE
    // TODO : we should work in world space then ? the transform is in worldSpace or localSpace...
    // TODO with version 120 we would not need this....
    mat3 vt = mat3(viewTransform[0].xyz, viewTransform[1].xyz, viewTransform[2].xyz);
    mat3 mat = vt * axisangle_to_matrix(a_texCoord2); // mat3(viewTransform)
    
#ifdef ENABLE_CUBE_MAP
    vec3 N = mat[0] * dir.x + mat[1] * dir.y + mat[2];
    viewPos.xy += dir;
#else
    vec3 off = mat[0] * dir.x + mat[1] * dir.y;
    viewPos.xyz += off;
#endif
    // TODO we should also tranform the normal for the lighting !!!!!
    
#elif defined(ENABLE_BILLBOARD_VIEW)
    vec3 u = vec3(0,1,0);
    vec3 r = normalize(cross(u, -viewPos.xyz));
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
#elif defined(ENABLE_BILLBOARD_Y)
    vec3 u = (viewTransform * vec4(0, 1, 0, 0)).xyz;
    vec3 r = normalize(cross(u, vec3(0,0,1))); // Screen Aligned
//    vec3 r = normalize(cross(u, -viewPos.xyz)); // ViewAligned
    vec3 off = dir.x * r + dir.y * u;
    viewPos.xyz += off;
    vec3 N = normalize(vec3(-off.x/a_texCoord0.y, -off.y/a_texCoord0.y, -2));
    
#else // defined(ENABLE_BILLBOARD_SCREEN)
    viewPos.xy += dir;
    vec3 N = normalize(vec3(-dir.x, -dir.y, -2));
    
#endif // ENABLE_ORIENTATION_FREE
#endif // ENABLE_STRETCH
#ifdef ENABLE_CUBE_MAP
#ifdef ENABLE_ORIENTATION_FREE
    v_normal.xyz = N;
#else
    vec3 refl = reflect( viewPos.xyz, N );
    v_normal.xyz = mat3(u_viewToCubeWorld) * refl;
#endif // ENABLE_ORIENTATION_FREE
#endif
#ifdef ENABLE_COLOR_RAMP
    v_vertexColor = a_color * texture2D(u_colorRamp, a_texCoord0.xx);
#else // use vertex color (TODO : use constant color if needed)
    v_vertexColor = a_color;
#endif
    
#ifndef ENABLE_BLACKPASS
#ifdef ENABLE_LIGHTING
    vec3 L = normalize(viewPos.xyz - u_lightPosition0);
#if defined(ENABLE_ORIENTATION_FREE) && !defined(ENABLE_CUBE_MAP)
    // if we want to bend the normal (but free orientation doesn't need too right ?)
    // vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? -normalize(-mat[2] + 0.1 * off) : -normalize(mat[2] + 0.1 * off);
//    vec3 N = (dot(mat[2], viewPos.xyz) > 0.) ? mat[2] : -mat[2];
    vec3 N = sign(dot(mat[2], viewPos.xyz)) * mat[2];
    // simple lambertian + back light diffusion
    float NdotL = dot(N, L);
//    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * max(0., -NdotL));
    vec3 diff = u_lightColor0.rgb * (max(0.0, NdotL) + 0.3 * (1. - abs(NdotL)));
    // Specular
    float _shininess = 100.0;
    vec3 halfVector = normalize(L + viewPos.xyz);
    float spec = max(0.0, pow(max(0.0, dot(N, halfVector)), _shininess));
    v_vertexColor.rgb *= diff;
    v_vertexColor.rgb += spec;
#else
    // simple lambertian
    vec3 diff = vec3(max(0.0, dot(N, L))) * u_lightColor0.rgb;
    // trilight model (lambertian + wrap around + hemispheric)
    //vec3 diff = lightColor0 * max(0., NdotL) + lightColor1 * (1. - abs(NdotL)) + lightColor2 * max(0., -NdotL);
    // todo : support ambient !!!!!!!!!!
    // diff += vec3(0.5);
    
    v_vertexColor.rgb *= diff;
#endif // ENABLE_ORIENTATION_FREE
#endif // ENABLE_LIGHTING
#endif // ENABLE_BLACKPASS
    // TexCoord
#ifdef ENABLE_ANIMATION
    vec4 animUVS = ComputeUVS(a_texCoord1.xy * vec2(0.5, -0.5) + 0.5, a_texCoord0.z);
    v_uv0 = animUVS.xyw;
    v_uv1 = animUVS.xy + u_frameSize.xy * vec2(1.0, animUVS.z);
#else
    v_uv0 = a_texCoord1.xy * vec2(0.5, -0.5) + 0.5;
#endif
    
#ifndef ENABLE_BLACKPASS
    #ifdef ENABLE_FOG
        float fogFactor = pow(clamp(viewPos.z * u_fogParameters.x + u_fogParameters.y, 0.0, u_fogColor.a), u_fogParameters.z);
        #ifdef ENABLE_CUBE_MAP
            v_normal.a = fogFactor;
        #else
            // vertex color is alpha premultiplied, but not the fogcolor
            v_vertexColor.rgb = mix(v_vertexColor.rgb, u_fogColor.rgb * v_vertexColor.a, fogFactor);
        #endif // ENABLE_CUBE_MAP
    #endif // ENABLE_FOG
#endif // ENABLE_BLACKPASS
#ifdef ENABLE_SOFT
    v_eyeLinearZ = viewPos.z;
#endif
    
    gl_Position = u_projectionTransform * viewPos;
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    //Sobel
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    //texels[4] = texture2D(pickedColorBuffer, uv + vec2(                0., 0.)).r;
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    //A little hack for multi-objects selection
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    //Get magnitude of the sobel filters
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    //Get min depth around 5x5 pixels
    float depth = 1.;
    for(int i=-2; i<3; i++)
    for(int j=-2; j<3; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    //Outline color
    vec3 outline = vec3(1.,.6,.2);
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), .25);
    else
        gl_FragColor = mix( texture2D(colorBuffer, uv), vec4(outline,1.), min(magnitude/4.,1.) );
//   Copyright 2013 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#include <metal_stdlib>
using namespace metal;
int OsdGetPatchNumControlVertices(int patchType) {
    switch(patchType) {
        case 3: return 4;
        case 6: return 16;
        case 9: return 20;
        default: return 0;
    }
const constant float4 patchColors[] = {
    float4(1.0f,  1.0f,  1.0f,  1.0f),   // regular
    float4(0.0f,  1.0f,  1.0f,  1.0f),   // regular pattern 0
    float4(0.0f,  0.5f,  1.0f,  1.0f),   // regular pattern 1
    float4(0.0f,  0.5f,  0.5f,  1.0f),   // regular pattern 2
    float4(0.5f,  0.0f,  1.0f,  1.0f),   // regular pattern 3
    float4(1.0f,  0.5f,  1.0f,  1.0f),   // regular pattern 4
    
    float4(1.0f,  0.50f,  0.5f,  1.0f),  // single crease
    float4(1.0f,  0.70f,  0.6f,  1.0f),  // single crease pattern 0
    float4(1.0f,  0.65f,  0.6f,  1.0f),  // single crease pattern 1
    float4(1.0f,  0.60f,  0.6f,  1.0f),  // single crease pattern 2
    float4(1.0f,  0.55f,  0.6f,  1.0f),  // single crease pattern 3
    float4(1.0f,  0.50f,  0.6f,  1.0f),  // single crease pattern 4
    
    float4(0.8f,  0.0f,  0.0f,  1.0f),   // boundary
    float4(0.0f,  0.0f,  0.75f, 1.0f),   // boundary pattern 0
    float4(0.0f,  0.2f,  0.75f, 1.0f),   // boundary pattern 1
    float4(0.0f,  0.4f,  0.75f, 1.0f),   // boundary pattern 2
    float4(0.0f,  0.6f,  0.75f, 1.0f),   // boundary pattern 3
    float4(0.0f,  0.8f,  0.75f, 1.0f),   // boundary pattern 4
    
    float4(0.0f,  1.0f,  0.0f,  1.0f),   // corner
    float4(0.25f, 0.25f, 0.25f, 1.0f),   // corner pattern 0
    float4(0.25f, 0.25f, 0.25f, 1.0f),   // corner pattern 1
    float4(0.25f, 0.25f, 0.25f, 1.0f),   // corner pattern 2
    float4(0.25f, 0.25f, 0.25f, 1.0f),   // corner pattern 3
    float4(0.25f, 0.25f, 0.25f, 1.0f),   // corner pattern 4
    
    float4(1.0f,  1.0f,  0.0f,  1.0f),   // gregory
    float4(1.0f,  1.0f,  0.0f,  1.0f),   // gregory
    float4(1.0f,  1.0f,  0.0f,  1.0f),   // gregory
    float4(1.0f,  1.0f,  0.0f,  1.0f),   // gregory
    float4(1.0f,  1.0f,  0.0f,  1.0f),   // gregory
    float4(1.0f,  1.0f,  0.0f,  1.0f),   // gregory
    
    float4(1.0f,  0.5f,  0.0f,  1.0f),   // gregory boundary
    float4(1.0f,  0.5f,  0.0f,  1.0f),   // gregory boundary
    float4(1.0f,  0.5f,  0.0f,  1.0f),   // gregory boundary
    float4(1.0f,  0.5f,  0.0f,  1.0f),   // gregory boundary
    float4(1.0f,  0.5f,  0.0f,  1.0f),   // gregory boundary
    float4(1.0f,  0.5f,  0.0f,  1.0f),   // gregory boundary
    
    float4(1.0f,  0.7f,  0.3f,  1.0f),   // gregory basis
    float4(1.0f,  0.7f,  0.3f,  1.0f),   // gregory basis
    float4(1.0f,  0.7f,  0.3f,  1.0f),   // gregory basis
    float4(1.0f,  0.7f,  0.3f,  1.0f),   // gregory basis
    float4(1.0f,  0.7f,  0.3f,  1.0f),   // gregory basis
    float4(1.0f,  0.7f,  0.3f,  1.0f)    // gregory basis
float4
getAdaptivePatchColor(int3 patchParam
#if OSD_PATCH_ENABLE_SINGLE_CREASE
                      , float2 vSegments
#else
#endif
                      )
    int patchType = 0;
    
    int edgeCount = popcount(OsdGetPatchBoundaryMask(patchParam));
    if (edgeCount == 1) {
        patchType = 2; // BOUNDARY
    }
    if (edgeCount == 2) {
        patchType = 3; // CORNER
    }
    
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    // check this after boundary/corner since single crease patch also has edgeCount.
    if (vSegments.y > 0) {
        patchType = 1;
    }
#elif OSD_PATCH_GREGORY
    patchType = 4;
#elif OSD_PATCH_GREGORY_BOUNDARY
    patchType = 5;
#elif OSD_PATCH_GREGORY_BASIS
    patchType = 6;
#endif
    
    int pattern = popcount(OsdGetPatchTransitionMask(patchParam));
    
    return patchColors[6*patchType + pattern];
#if OSD_IS_ADAPTIVE
#if USE_STAGE_IN
#if OSD_PATCH_REGULAR
struct ControlPoint
    
    float3 P [[attribute(0)]];
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 P1 [[attribute(1)]];
    float3 P2 [[attribute(2)]];
#if !USE_PTVS_SHARPNESS
    float2 vSegments [[attribute(3)]];
#endif // !USE_PTVS_SHARPNESS
#endif // OSD_PATCH_ENABLE_SINGLE_CREASE
struct PatchInput
    patch_control_point<ControlPoint> cv;
#if !USE_PTVS_FACTORS
    float4 tessOuterLo [[attribute(5)]];
    float4 tessOuterHi [[attribute(6)]];
#endif // !USE_PTVS_FACTORS
    int3 patchParam [[attribute(10)]];
#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
struct ControlPoint
    
    float3 P [[attribute(0)]];
    float3 Ep [[attribute(1)]];
    float3 Em [[attribute(2)]];
    float3 Fp [[attribute(3)]];
    float3 Fm [[attribute(4)]];
struct PatchInput
    patch_control_point<ControlPoint> cv;
    int3 patchParam [[attribute(10)]];
#elif OSD_PATCH_GREGORY_BASIS
struct ControlPoint
    float3 position [[attribute(0)]];
struct PatchInput
    patch_control_point<ControlPoint> cv;
    int3 patchParam [[attribute(10)]];
#endif
#endif // USE_STAGE_IN
#endif // OSD_IS_ADAPTIVE
#if defined(OSD_FVAR_WIDTH)
static void OsdInterpolateFaceVarings(thread SCNShaderGeometry&   geometry
                                      , float2                    uv
                                      , int                       patchIndex
                                      , device int const*         osdFaceVaryingIndices
                                      , device float const *      osdFaceVaryingData
#if OSD_IS_ADAPTIVE
                                      , device packed_int3 const* osdFaceVaryingPatchParams
                                      , constant packed_int4&     osdFaceVaryingPatchArray
#endif
                                      )
    
#if OSD_IS_ADAPTIVE
    int3 fvarPatchParam = osdFaceVaryingPatchParams[patchIndex];
    bool isRegular = OsdGetPatchIsRegular(fvarPatchParam);
    
    int4 patchArray = osdFaceVaryingPatchArray;
    int patchStride = OsdGetPatchNumControlVertices(patchArray.x);
    int patchType = select(patchArray.x, 6, isRegular);
    int patchCVs = OsdGetPatchNumControlVertices(patchType);
    
    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
    
    if (patchType == 3) {
        OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if (patchType == 6) {
        int boundaryMask = OsdGetPatchBoundaryMask(fvarPatchParam);
        OsdGetBSplinePatchWeights(uv.x, uv.y, 1.0f, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if (patchType == 9) {
        OsdGetGregoryPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
    }
#else    
    float wP[4], wDs[4], wDt[4], wDss[4], wDst[4], wDtt[4];
    int patchCVs = 4;
    int patchStride = patchCVs;
    OsdGetBilinearPatchWeights(uv.x, uv.y, 1.0f, wP, wDs, wDt, wDss, wDst, wDtt);
#endif
    
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[0] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[1] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[2] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[3] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[4] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[5] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[6] = float2(0.0);
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.texcoords[7] = float2(0.0);
#endif
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
    geometry.color = float4(0.0);
#endif
    
    for (int i = 0; i < patchCVs; ++i) {
        int index = osdFaceVaryingIndices[patchIndex * patchStride + i] * OSD_FVAR_WIDTH + 0 /* fvarOffset */;
#if defined(HAS_VERTEX_COLOR) && (OSD_COLOR_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.color += wP[i] * float4(osdFaceVaryingData[index++], osdFaceVaryingData[index++], osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
#if defined(NEED_IN_TEXCOORD0) && (OSD_TEXCOORD0_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[0] += wP[i] * float2(osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
#if defined(NEED_IN_TEXCOORD1) && (OSD_TEXCOORD1_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[1] += wP[i] * float2(osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
#if defined(NEED_IN_TEXCOORD2) && (OSD_TEXCOORD2_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[2] += wP[i] * float2(osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
#if defined(NEED_IN_TEXCOORD3) && (OSD_TEXCOORD3_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[3] += wP[i] * float2(osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
#if defined(NEED_IN_TEXCOORD4) && (OSD_TEXCOORD4_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[4] += wP[i] * float2(osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
#if defined(NEED_IN_TEXCOORD5) && (OSD_TEXCOORD5_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[5] += wP[i] * float2(osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
#if defined(NEED_IN_TEXCOORD6) && (OSD_TEXCOORD6_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[6] += wP[i] * float2(osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
#if defined(NEED_IN_TEXCOORD7) && (OSD_TEXCOORD7_INTERPOLATION_MODE == OSD_PRIMVAR_INTERPOLATION_MODE_FACE_VARYING)
        geometry.texcoords[7] += wP[i] * float2(osdFaceVaryingData[index++], osdFaceVaryingData[index++]);
#endif
    }
#endif //defined(OSD_FVAR_WIDTH)
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>symbols</key>
<dict>
<key>a_position-symbol</key>
<dict>
<key>semantic</key>
<string>vertex</string>
</dict>
<key>color</key>
<dict>
<key>semantic</key>
<string>none</string>
</dict>
</dict>
<key>sequence</key>
<array>
<string>authoring</string>
<string>authoringBlend</string>
</array>
<key>targets</key>
<dict>
<key>authoring-color</key>
<dict>
<key>type</key>
<string>color</string>
</dict>
<key>authoring-depth</key>
<dict>
<key>type</key>
<string>depth</string>
</dict>
</dict>
<key>passes</key>
<dict>
<key>authoring</key>
<dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>authoring-color</string>
<key>depth</key>
<string>authoring-depth</string>
</dict>
<key>draw</key>
<string>DRAW_NODES</string>
<key>colorStates</key>
<dict>
<key>clear</key>
<true/>
<key>clearColor</key>
<string>0 0 0 0</string>
</dict>
</dict>
<key>authoringBlend</key>
<dict>
<key>clientProgram</key>
<string>NO</string>
<key>program</key>
<string>C3D-BlendAuthoring</string>
<key>inputs</key>
<dict>
<key>a_position</key>
<string>a_position-symbol</string>
<key>sceneColor</key>
<string>COLOR</string>
<key>sceneDepth</key>
<string>DEPTH</string>
<key>authoringColor</key>
<string>authoring-color</string>
<key>authoringDepth</key>
<string>authoring-depth</string>
</dict>
<key>outputs</key>
<dict>
<key>color</key>
<string>COLOR</string>
</dict>
<key>draw</key>
<string>DRAW_QUAD</string>
<key>metalVertexShader</key>
<string>blendAuthoring_vert</string>
<key>metalFragmentShader</key>
<string>blendAuthoring_frag</string>
</dict>
</dict>
</dict>
</plist>
uniform sampler2D colorBuffer;
uniform sampler2D pickedColorBuffer;
uniform sampler2D depthBuffer;
uniform sampler2D pickedDepthBuffer;
uniform vec2 u_inverseResolution;
varying vec2 uv;
void main()
    //Sobel
    float texels[9];
    texels[0] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, -u_inverseResolution.y)).r;
    texels[1] = texture2D(pickedColorBuffer, uv + vec2(                0., -u_inverseResolution.y)).r;
    texels[2] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, -u_inverseResolution.y)).r;
    
    texels[3] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, 0.)).r;
    //texels[4] = texture2D(pickedColorBuffer, uv + vec2(                0., 0.)).r;
    texels[5] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, 0.)).r;
    
    texels[6] = texture2D(pickedColorBuffer, uv + vec2(-u_inverseResolution.x, u_inverseResolution.y)).r;
    texels[7] = texture2D(pickedColorBuffer, uv + vec2(                0., u_inverseResolution.y)).r;
    texels[8] = texture2D(pickedColorBuffer, uv + vec2( u_inverseResolution.x, u_inverseResolution.y)).r;
    
    
    //A little hack for multi-objects selection
    vec3 a = vec3(texels[0],texels[3],texels[6]);
    vec3 b = vec3(texels[2],texels[5],texels[7]);
    bvec3 tmp = equal(a,b);
    vec3 retLin = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    a = vec3(texels[0],texels[1],texels[2]);
    b = vec3(texels[6],texels[7],texels[8]);
    tmp = equal(a,b);
    vec3 retCol = mix( vec3(tmp), vec3(not(tmp)), vec3(equal(b,vec3(0.))) );
    
    
    vec4 last = step(vec4(0.002), vec4(texels[5],texels[7],texels[8], min(retLin.x, retCol.x)) );
    
    //Get magnitude of the sobel filters
    float x = last.w + 2.*retLin.y + retLin.z - retCol.z - 2.*last.x - last.z;
    float y = last.w + 2.*retCol.y + retCol.z - retLin.z- 2.*last.y - last.z;
    float magnitude = sqrt( x*x + y*y );
    
    
    
    //Get min depth around 3x3 pixels
    float depth = 1.;
    for(int i=-1; i<2; i++)
    for(int j=-1; j<2; j++)
        depth = min(depth, texture2D(pickedDepthBuffer, uv + u_inverseResolution*vec2(i,j)).r);
    
    
    //Outline color
    if( texture2D(depthBuffer, uv).x < depth-0.0000001 &&  texture2D(pickedColorBuffer, uv).r > 0.  )
        gl_FragColor = vec4(.25);
    else
        gl_FragColor = vec4( min(magnitude/4.,1.) );
    
// blend factors {One, InverseSourceAlpha}
uniform sampler2D u_textureSampler0;
varying vec2 v_uv0;
varying vec4 v_vertexColor;
void main(){
    vec4 tex = texture2D(u_textureSampler0, v_uv0);
    tex.rgb *= tex.a; // this premultiplied could be done upfront?
    
    vec4 col = v_vertexColor * tex;
gl_FragColor = vec4(col);
#import <metal_stdlib>
using namespace metal;
#import "scn_metal"
//------------------------------------------------------
// Global input output interface
//------------------------------------------------------
struct ColorGrading_io {
    float4 position [[position]];
    float2 uv; // 0..1
//------------------------------------------------------
// Vertex shaders
//------------------------------------------------------
vertex ColorGrading_io ColorGrading_vert( uint v_id [[ vertex_id ]] )
    // generate quad vertices
    // OPTIM: should be done as a triangle (x*4 - 1)
    float4 in_position;
    in_position.x = (float)(v_id / 2) * 2.0 - 1.0;
    in_position.y = (float)(v_id % 2) * 2.0 - 1.0;
    in_position.z = 1.0;
    in_position.w = 1.0;
    
    ColorGrading_io out;
    out.position = in_position;
    out.uv = in_position.xy * float2(.5, -.5) + float2( .5 );
    
    return out;
//------------------------------------------------------
// Fragment shaders
//------------------------------------------------------
fragment float4 ColorGrading_frag( ColorGrading_io in [[stage_in]],
                             texture2d<float> colorBuffer [[texture(0)]],
                             texture2d<float> LUT [[texture(1)]] )
    constexpr sampler samp(filter::linear);
    
    
    //Tmp code with texture 2D LUT
    const float sliceSize = 1.0 / 16.;
    const float slicePixelSize = sliceSize / 16.;
    const float sliceInnerSize = slicePixelSize * (16. - 1.0);
    
    float4 col = colorBuffer.sample(samp, in.uv);
    
    float offset = floor(col.b*16.);
    float delta  = fract(col.b*16.);
    float3 a = LUT.sample(samp, float2( col.r * sliceInnerSize + min(offset   ,15.)*sliceSize + .5*slicePixelSize, col.g + .5*slicePixelSize) ).rgb;
    float3 b = LUT.sample(samp, float2( col.r * sliceInnerSize + min(offset+1.,15.)*sliceSize + .5*slicePixelSize, col.g + .5*slicePixelSize) ).rgb;
    
    col.rgb = mix( a, b, float3(delta) );
    
    
    //Final code with texture 3D LUT
    // col.rgb = LUT.sample(samp, col.rgb);
    
    
    return col;
uniform mat4 u_modelViewProjectionTransform;
attribute vec3 a_position;
attribute vec4 a_color;
attribute vec2 a_texCoord0;
varying vec4 v_vertexColor;
varying vec2 v_texCoord;
void main()
    gl_Position = u_modelViewProjectionTransform * vec4(a_position, 1.);
    v_vertexColor = a_color;
    v_texCoord = a_texCoord0;
typedef struct {
#ifdef __SIMD_HEADER__
    matrix_float4x4 modelViewProjectionTransform;
    matrix_float4x4 viewToCubeTransform;
#else
    float4x4        modelViewProjectionTransform;
    float4x4        viewToCubeTransform;
#endif
    float zfar;
} background_uniforms_t;
typedef struct {
#ifdef __SIMD_HEADER__
    matrix_float4x2 texcoords;
#else
    float4x2        texcoords;
#endif
} background_video_uniforms_t;
Error: can't find text resource named %@
normalTexcoord
ambientTexcoord
diffuseTexcoord
specularTexcoord
emissionTexcoord
multiplyTexcoord
transparentTexcoord
fresnel
_surface.%@
_geometry.normal
_geometry.tangent
_geometry.color
C3DShaderModifier
<C3DShaderModifier %p language:%s, entryPoint:"%d" flags:%x
Metal
GLSL
  declaration : %@
  arguments : %@
  varyings : %@
  code : %@
Error: modifier without code is invalid
USE_EMISSIVETEXCOORD
USE_AMBIENTTEXCOORD
USE_DIFFUSETEXCOORD
USE_SPECULARTEXCOORD
USE_REFLECTIVETEXCOORD
USE_TRANSPARENTTEXCOORD
USE_FILTERTEXCOORD
USE_NORMALTEXCOORD
USE_METALNESSTEXCOORD
USE_ROUGHNESSTEXCOORD
u_%@TextureMatrix
{_SCNVector4=dddd}
{_SCNVector3=ddd}
Error: unexpected value (%@)
Warning: SCNDefaultValueWithBaseType - unknwon base type %d
Error: unexpected returned value for property %@ of object %@
is%@%@
Error: can't generate implementation for property of type %d
v@:^v
^v@:
v@:f
v@:i
v@:B
v@:c
v@:d
v@:{CGPoint=dd}
{CGPoint=dd}@:
v@:{SCNVector3=ddd}
{SCNVector3=ddd}@:
v@:{SCNVector4=dddd}
{SCNVector4=dddd}@:
v@:{SCNMatrix4=dddddddddddddddd}
{SCNMatrix4=dddddddddddddddd}@:
v@:{CATransform3D=dddddddddddddddd}
{CATransform3D=dddddddddddddddd}@:
v@:{C3DMatrix3x3=ddddddddd}
{C3DMatrix3x3=ddddddddd}@:
v@:{C3DColor4=ffff}
{C3DColor4=ffff}@:
v@:s
v@:C
v@:S
C3DConstraintController
<C3DConstraintController>
C3DConstraint
<C3DConstraint %@ %p>
C3DConstraintLookAt
<C3DConstraintLookAt %p>
C3DConstraintBillboard
<C3DConstraintBillboard %p>
C3DConstraintConstantScale
<C3DConstraintConstantScale>
C3DConstraintProcedural
<C3DConstraintProcedural>
C3DConstraintIK
<C3DConstraintIK %p>
Error: C3DConstraintApplyIK leef is not a child of root
Error: C3DConstraintApplyIK root and leaf nodes are the same node
C3DConstraintDistance
<C3DConstraintDistance>
maximumDistance
C3DConstraintAcceleration
maximumLinearAcceleration
maximumLinearVelocity
decelerationDistance
C3DConstraintReplicator
<C3DConstraintReplicator>
orientationOffset
positionOffset
scaleOffset
C3DConstraintManager
<C3DConstraintManagerRef>
Warning: unsupported ease out for contraint applied on base type %d
__controller
Error: C3DModelPathResolveCommonProfileProperty unknown path %@
Error: C3DModelPathResolverFindRootEntityForCFType: CFType %d not implemented
superClass
Error: _C3DModelPathResolverRegistryResolvePathWithClassName unknown path %@
Error: _C3DModelPathResolveColor4 unknown path %@
Error: _C3DModelPathResolveCommonProfileTexture unknown path %@
Error: _C3DModelPathResolveMatrix unknown path %@
Error: _C3DModelPathResolveTransform unknown path %@
Error: _C3DModelPathResolveRotation unknown path %@
Error: _C3DModelPathResolveVector3 unknown path %@
Error: _C3DModelPathResolveVector4 unknown path %@
Error: _C3DModelPathResolveNode unknown path %@
Error: _C3DModelPathResolveDynamicParameter unknown path %@
Error: _C3DModelPathResolveCommonProfile unknown path %@
Error: _C3DModelPathResolveMorpher unknown path %@
Warning: _C3DCreateAnimationTargetFromPath: can't resolve a path (null model)
Warning: _C3DCreateAnimationTargetFromPath: can't resolve a path
C3DModelTarget
<C3DModelTarget>
ControllerAnimation
ControllerVariableMode
ControllerVariableOverLife
ControllerVariableOverDistance
ControllerVariableOverOtherProperty
ControllerVariableOrigin
ControllerVariableScale
ControllerVariableBias
Error: Too many properties added to this ParticleSystem
Error: Cannot animate this particle semantic : %@
C3DParticleSystem
<C3DParticleSystemRef>
Error: Try to parametrize with a variable property not present : %@
Error: Unknown controller mode : %@
Error: Try to set a controller on a property not present : %@
InvLifeSpan
BirthTime
SortingIndices
Mass
TempData
EventIndex
C3DModelValueStorageItem
<C3DModelValueStorageItem %p>
C3DModelValueStorage
<C3DModelValueStorage>
targetDirection
replicatesOrientation
replicatesScale
replicatesPosition
collisionCategoryBitMask
bias
T@"<SCNAvoidOccluderConstraintDelegate>",N
occluderCategoryBitMask
freeAxes
TQ,N,V_freeAxes
v36@?0^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}8^v16^{__C3DModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}24f32
joint
T@"SCNNode",W,N,Vjoint
maxAllowedRotationAngle
Td,N,VmaxAllowedRotationAngle
node%d
angle%d
ikTarget
computeVelocity
C3D-MotionBlur-Intensity-symbol
Error: Motion blur pass: no point of view
C3D-viewProjectionInverseTransform-symbol
C3D-oldViewProjectionTransform-symbol
C3DAnimationEvents
<C3DAnimationEvents>
FreeList: (count:%d) (maxSpan:%d)
[%d:%d[ 
Error: RendererElementStore does not support span of more than %d
C3DRendererElementStore
<C3DRendererElementStore %p>
C3DIndexStore
<C3DIndexStore>
Error: indexstore::_getNextFreeIndex - no more free index
Error: ParticleSystem: mismatch in meshes and meshElements
C3DParticleSystemInstance
<C3DParticleSystemInstanceRef>
Error: C3DTransformGetValue - unexpected semantic
Error: C3DTransformSetValue unexptected component index %d
Error: C3DTransformSetValue - unexpected semantic
Error: C3DAllocatorDelete - unknown address
C3DAllocator
<C3DAllocator>
C3DAnimatableParamController
<C3DAnimatableParamController>
Error: technique should not be null
Error: type for key %@ is switching from %@ to %@, this will lead to improper animation
C3DKeyValueStore
<C3DKeyValueStore>
T@?,C,N,V_block
frequency
Tq,N,V_frequency
T@"NSString",C,N,V_semantic
T@"NSDictionary",&,N,V_options
SCNProgramDidChangeNotification
parameter
semanticInfos
SCNShaderModifierEntryPointGeometry
SCNShaderModifierEntryPointSurface
SCNShaderModifierEntryPointFragment
SCNShaderModifierEntryPointLightingModel
Error: Cannot use a program because shader modifiers are set
Error: ShaderModifiers - unkwnown supporting class '%@'
Error: Cannot use shader modifiers because a program is set
Warning: _updateC3DProgramInput can't find input named %@
v32@?0@"NSString"8@"SCNBufferBinding"16^c24
v24@?0i8^{__CFString=}12c20
owner
shaderModifiersArgumentsNames
SCNShadableDidCompileNotificationName
issues
shadable
T@"<SCNShadable>",R,N,V_shadable
entryPoint
T@"NSString",R,N,V_entryPoint
effectiveModifier
T@"NSString",R,N,V_effectiveModifier
message
T@"NSString",R,N,V_message
TQ,R,N,V_type
Tq,R,N,V_line
Error: ShaderModifiers - unkwnown entrypoint '%@'
%@ // [SCN_%@(%d)]
v24@?0@"NSString"8^c16
C3DArray
<C3DArray %p:, %d objects>
<%@ | string=%@ extrusionDepth=%.3f> 
-[SCNText set_wantsSeparateGeometryElements:]
-[SCNText setChamferRadius:]
-[SCNText setDiscretizedStraightLineMaxLength:]
-[SCNText setExtrusionDepth:]
-[SCNText setFlatness:]
-[SCNText setPrimitiveType:]
-[SCNText setString:]
-[SCNText setWrapped:]
-[SCNText setContainerFrame:]
discretizedStraightLineMaxLength
useCustomContainerFrame
customContainerFrame
_wantsSeparateGeometryElements
T@"NSFont",&,N
T@"NSBezierPath",C,N
Warning: Unknown alignment mode %@
Warning: Unknown truncation mode %@
<%@ | path=%@ extrusionDepth=%.3f> 
-[SCNShape setChamferMode:]
-[SCNShape setChamferRadius:]
-[SCNShape setDiscretizedStraightLineMaxLength:]
-[SCNShape setExtrusionDepth:]
-[SCNShape setPrimitiveType:]
C3DShape
<C3DShape '%@'>
C3DShapeGeometryValidate
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/sources/Core3DRuntime/Core/C3DShapeGeometry.m
CFGetTypeID(geometry) == C3DShapeGeometryGetTypeID()
Helvetica
C3DShapeGeometryMeshForBoundingBox
^{__C3DMesh=}8@?0
C3DShapeGeometryGetBoundingBox
C3DShapeGeometryGetBoundingSphere
C3DShapeGeometry
C3DTextGeometry
levelOfDetail <%p>: geometry:%@ threshold:%f useDistance:%d
mode
mat2x3
scn_frame.invScreenPixelSize
SceneKit_downSample4x
SceneKit_DOF_blurCoc_H
SceneKit_DOF_blurCoc_V
SceneKit_blurColor4x_H
SceneKit_blurColor4x_V
C3D-dof-lerpBias
C3D-dof-lerpScale
C3D-dof-cocScaleBias
C3D-dof-invertPixelSize
Error: DOF pass: no point of view
scnasset
.scnassets
catalogURL
T@"NSURL",R,N,V_catalogURL
btOptimizedBvhNodeData
btQuantizedBvhNodeData
btBvhSubtreeInfoData
btQuantizedBvhFloatData
btCollisionObjectFloatData
Overflow in AABB, object removed from simulation
If you can reproduce this, please email bugs@continuousphysics.com
Please include above information, your Platform, version of OS.
Thanks.
Triangle
btConvexInternalShapeData
Box2d
btTriangleMeshShapeData
BVHTRIANGLEMESH
CapsuleShape
btCapsuleShapeData
CapsuleX
CapsuleZ
btCollisionShapeData
btCompoundShapeChildData
btCompoundShapeData
Compound
btVector3FloatData
btConvexHullShapeData
Convex
ConvexTrimesh
CylinderY
btCylinderShapeData
CylinderX
CylinderZ
btPositionAndRadius
btMultiSphereShapeData
MultiSphere
SPHERE
STATICPLANE
btStaticPlaneShapeData
btIntIndexData
btShortIntIndexTripletData
btCharIndexTripletData
btVector3DoubleData
btMeshPartData
btStridingMeshInterfaceData
TRIANGLEMESH
btConeTwistConstraintData
btGeneric6DofConstraintData
btHingeConstraintFloatData
btPoint2PointConstraintFloatData
btSliderConstraintData
btTypedConstraintData
btDynamicsWorldFloatData
btRigidBodyFloatData
xml_base
BINORMAL
CONTINUITY
IMAGE
LINEAR_STEPS
TANGENT
TEXBINORMAL
InputGlobal
InputLocal
InputLocalOffset
InstanceWithExtra
TargetableFloat
TargetableFloat3
fx_surface_format_hint_common
range
precision
option
fx_surface_init_planar_common
fx_surface_init_volume_common
primary
fx_surface_init_cube_common
order
face
fx_surface_init_from_common
fx_surface_common
viewport_ratio
mip_levels
mipmap_generate
fx_sampler1D_common
border_color
mipmap_maxlevel
mipmap_bias
fx_sampler2D_common
fx_sampler3D_common
wrap_p
fx_samplerCUBE_common
fx_samplerRECT_common
fx_samplerDEPTH_common
fx_colortarget_common
fx_depthtarget_common
fx_stenciltarget_common
fx_clearcolor_common
fx_cleardepth_common
fx_clearstencil_common
fx_annotate_common
fx_include_common
fx_newparam_common
modifier
fx_code_profile
gl_sampler1D
gl_sampler2D
gl_sampler3D
gl_samplerCUBE
gl_samplerRECT
gl_samplerDEPTH
glsl_newarray_type
glsl_setarray_type
glsl_surface_type
generator
glsl_newparam
glsl_setparam_simple
glsl_setparam
common_float_or_param_type
common_color_or_texture_type
common_transparent_type
common_newparam_type
cg_sampler1D
cg_sampler2D
cg_sampler3D
cg_samplerCUBE
cg_samplerRECT
cg_samplerDEPTH
cg_connect_param
cg_newarray_type
cg_setarray_type
cg_setuser_type
cg_surface_type
cg_newparam
cg_setparam_simple
cg_setparam
gles_texture_constant_type
gles_texenv_command_type
gles_texcombiner_argumentRGB_type
gles_texcombiner_argumentAlpha_type
gles_texcombiner_commandRGB_type
gles_texcombiner_commandAlpha_type
gles_texcombiner_command_type
gles_texture_pipeline
gles_texture_unit
sampler_state
gles_sampler_state
gles_newparam
fx_surface_init_common
init_as_null
init_as_target
fx_annotate_type_common
fx_basic_type_common
float1x1
float1x2
float1x3
float1x4
float2x1
float3x1
float4x1
enum
gl_pipeline_settings
alpha_func
blend_func
dest
blend_func_separate
src_rgb
dest_rgb
src_alpha
dest_alpha
blend_equation
blend_equation_separate
color_material
cull_face
depth_func
fog_mode
fog_coord_src
front_face
light_model_color_control
logic_op
polygon_mode
shade_model
stencil_func
mask
stencil_op
zfail
zpass
stencil_func_separate
stencil_op_separate
stencil_mask_separate
light_enable
light_ambient
light_diffuse
light_specular
light_position
light_constant_attenuation
light_linear_attenuation
light_quadratic_attenuation
light_spot_cutoff
light_spot_direction
light_spot_exponent
textureCUBE
textureRECT
textureDEPTH
texture1D_enable
texture2D_enable
texture3D_enable
textureCUBE_enable
textureRECT_enable
textureDEPTH_enable
texture_env_color
texture_env_mode
clip_plane
clip_plane_enable
blend_color
clear_color
clear_stencil
clear_depth
color_mask
depth_bounds
depth_mask
depth_range
fog_density
fog_start
fog_end
fog_color
light_model_ambient
lighting_enable
line_stipple
line_width
material_ambient
material_diffuse
material_emission
material_shininess
material_specular
model_view_matrix
point_distance_attenuation
point_fade_threshold_size
point_size
point_size_min
point_size_max
polygon_offset
projection_matrix
scissor
stencil_mask
alpha_test_enable
auto_normal_enable
blend_enable
color_logic_op_enable
color_material_enable
cull_face_enable
depth_bounds_enable
depth_clamp_enable
depth_test_enable
dither_enable
fog_enable
light_model_local_viewer_enable
light_model_two_side_enable
line_smooth_enable
line_stipple_enable
logic_op_enable
multisample_enable
normalize_enable
point_smooth_enable
polygon_offset_fill_enable
polygon_offset_line_enable
polygon_offset_point_enable
polygon_smooth_enable
polygon_stipple_enable
rescale_normal_enable
sample_alpha_to_coverage_enable
sample_alpha_to_one_enable
sample_coverage_enable
scissor_test_enable
stencil_test_enable
glsl_param_type
cg_param_type
bool1
bool1x1
bool1x2
bool1x3
bool1x4
bool2x1
bool2x2
bool2x3
bool2x4
bool3x1
bool3x2
bool3x3
bool3x4
bool4x1
bool4x2
bool4x3
bool4x4
float1
int1
int1x1
int1x2
int1x3
int1x4
int2x1
int2x2
int2x3
int2x4
int3x1
int3x2
int3x3
int3x4
int4x1
int4x2
int4x3
int4x4
half1
half1x1
half1x2
half1x3
half1x4
half2x1
half3x1
half4x1
fixed
fixed1
fixed2
fixed3
fixed4
fixed1x1
fixed1x2
fixed1x3
fixed1x4
fixed2x1
fixed2x2
fixed2x3
fixed2x4
fixed3x1
fixed3x2
fixed3x3
fixed3x4
fixed4x1
fixed4x2
fixed4x3
fixed4x4
gles_pipeline_settings
texture_pipeline
light_linear_attenutation
texture_pipeline_enable
gles_basic_type_common
bool_array
spline
control_vertices
linestrips
polylist
trifans
lookat
skew
imager
comments
copyright
keywords
revision
title
evaluate_scene
render
technique_hint
setparam
instance_force_field
bind
instance_node
instance_physics_material
instance_physics_model
instance_rigid_body
angular_velocity
mass_frame
shape
hollow
instance_rigid_constraint
library_force_fields
library_nodes
library_physics_materials
fx_profile_abstract
gl_hook_abstract
profile_GLSL
shader
compiler_target
compiler_options
profile_CG
profile_GLES
color_target
depth_target
stencil_target
color_clear
depth_clear
stencil_clear
half_extents
equation
ellipsoid
tapered_cylinder
radius1
radius2
tapered_capsule
convex_mesh
force_field
physics_material
physics_scene
rigid_body
rigid_constraint
ref_attachment
interpenetrate
limits
swing_cone_and_twist
spring
angular
physics_model
format_hint
array
code
include
usertype
connect_param
texcombiner
texenv
init_cube
init_volume
init_planar
samplerCUBE
samplerRECT
samplerDEPTH
texture_unit
ymag
aspect_ratio
inertia
density
dynamic_friction
static_friction
time_step
stiffness
target_value
convex_hull_of
digits
magnitude
index
slice
0 0 0 1
0 0 0 0
0 0 1 0
0 0 -1
true true true true
0.2 0.2 0.2 1.0
1 65536
0.8 0.8 0.8 1.0
1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1
1 0 0
4294967295
operand
operator
constraint
minInclusive
-2147483648
maxInclusive
2147483647
platform
closed
Bool
DateTime
Float
Token
Uint
ListOfBools
ListOfFloats
ListOfHexBinary
ListOfInts
ListOfNames
ListOfTokens
ListOfUInts
Bool2
Bool3
Bool4
Float2
Float3
Float4
Float7
Float2x2
Float3x3
Float4x4
Float2x3
Float2x4
Float3x2
Float3x4
Float4x2
Float4x3
Int2
Int3
Int4
Int2x2
Int3x3
Int4x4
MorphMethodType
NodeType
NODE
URIFragmentType
UpAxisType
VersionType
1.4.0
Fx_color_common
Fx_opaque_enum
Fx_surface_type_enum
UNTYPED
RECT
Fx_surface_face_enum
POSITIVE_X
NEGATIVE_X
POSITIVE_Y
NEGATIVE_Y
POSITIVE_Z
NEGATIVE_Z
Fx_surface_format_hint_channels_enum
RGBA
XYZW
Fx_surface_format_hint_precision_enum
HIGH
Fx_surface_format_hint_range_enum
SNORM
UNORM
SINT
UINT
FLOAT
Fx_surface_format_hint_option_enum
SRGB_GAMMA
NORMALIZED3
NORMALIZED4
COMPRESSABLE
Fx_sampler_wrap_common
Fx_sampler_filter_common
NEAREST_MIPMAP_NEAREST
LINEAR_MIPMAP_NEAREST
NEAREST_MIPMAP_LINEAR
LINEAR_MIPMAP_LINEAR
Fx_modifier_enum_common
CONST
UNIFORM
VARYING
STATIC
VOLATILE
EXTERN
SHARED
Fx_draw_common
Fx_pipeline_stage_common
VERTEXPROGRAM
FRAGMENTPROGRAM
VERTEXSHADER
PIXELSHADER
GL_MAX_LIGHTS_index
GL_MAX_CLIP_PLANES_index
GL_MAX_TEXTURE_IMAGE_UNITS_index
Gl_blend_type
ZERO
SRC_COLOR
ONE_MINUS_SRC_COLOR
DEST_COLOR
ONE_MINUS_DEST_COLOR
SRC_ALPHA
ONE_MINUS_SRC_ALPHA
DST_ALPHA
ONE_MINUS_DST_ALPHA
CONSTANT_COLOR
ONE_MINUS_CONSTANT_COLOR
CONSTANT_ALPHA
ONE_MINUS_CONSTANT_ALPHA
SRC_ALPHA_SATURATE
Gl_face_type
FRONT
BACK
FRONT_AND_BACK
Gl_blend_equation_type
FUNC_ADD
FUNC_SUBTRACT
FUNC_REVERSE_SUBTRACT
Gl_func_type
NEVER
LESS
LEQUAL
EQUAL
GREATER
NOTEQUAL
GEQUAL
ALWAYS
Gl_stencil_op_type
KEEP
REPLACE
INCR
DECR
INVERT
INCR_WRAP
DECR_WRAP
Gl_material_type
EMISSION
AMBIENT
DIFFUSE
SPECULAR
AMBIENT_AND_DIFFUSE
Gl_fog_type
EXP2
Gl_fog_coord_src_type
FOG_COORDINATE
FRAGMENT_DEPTH
Gl_front_face_type
Gl_light_model_color_control_type
SINGLE_COLOR
SEPARATE_SPECULAR_COLOR
Gl_logic_op_type
CLEAR
AND_REVERSE
COPY
AND_INVERTED
NOOP
EQUIV
OR_REVERSE
COPY_INVERTED
NAND
Gl_polygon_mode_type
POINT
LINE
FILL
Gl_shade_model_type
FLAT
SMOOTH
Gl_alpha_value_type
Gl_enumeration
Glsl_float
Glsl_int
Glsl_bool
Glsl_ListOfBool
Glsl_ListOfFloat
Glsl_ListOfInt
Glsl_bool2
Glsl_bool3
Glsl_bool4
Glsl_float2
Glsl_float3
Glsl_float4
Glsl_float2x2
Glsl_float3x3
Glsl_float4x4
Glsl_int2
Glsl_int3
Glsl_int4
Glsl_pipeline_stage
Glsl_identifier
Cg_bool
Cg_float
Cg_int
Cg_half
Cg_fixed
Cg_bool1
Cg_float1
Cg_int1
Cg_half1
Cg_fixed1
Cg_ListOfBool
Cg_ListOfFloat
Cg_ListOfInt
Cg_ListOfHalf
Cg_ListOfFixed
Cg_bool2
Cg_bool3
Cg_bool4
Cg_bool1x1
Cg_bool1x2
Cg_bool1x3
Cg_bool1x4
Cg_bool2x1
Cg_bool2x2
Cg_bool2x3
Cg_bool2x4
Cg_bool3x1
Cg_bool3x2
Cg_bool3x3
Cg_bool3x4
Cg_bool4x1
Cg_bool4x2
Cg_bool4x3
Cg_bool4x4
Cg_float2
Cg_float3
Cg_float4
Cg_float1x1
Cg_float1x2
Cg_float1x3
Cg_float1x4
Cg_float2x1
Cg_float2x2
Cg_float2x3
Cg_float2x4
Cg_float3x1
Cg_float3x2
Cg_float3x3
Cg_float3x4
Cg_float4x1
Cg_float4x2
Cg_float4x3
Cg_float4x4
Cg_int2
Cg_int3
Cg_int4
Cg_int1x1
Cg_int1x2
Cg_int1x3
Cg_int1x4
Cg_int2x1
Cg_int2x2
Cg_int2x3
Cg_int2x4
Cg_int3x1
Cg_int3x2
Cg_int3x3
Cg_int3x4
Cg_int4x1
Cg_int4x2
Cg_int4x3
Cg_int4x4
Cg_half2
Cg_half3
Cg_half4
Cg_half1x1
Cg_half1x2
Cg_half1x3
Cg_half1x4
Cg_half2x1
Cg_half2x2
Cg_half2x3
Cg_half2x4
Cg_half3x1
Cg_half3x2
Cg_half3x3
Cg_half3x4
Cg_half4x1
Cg_half4x2
Cg_half4x3
Cg_half4x4
Cg_fixed2
Cg_fixed3
Cg_fixed4
Cg_fixed1x1
Cg_fixed1x2
Cg_fixed1x3
Cg_fixed1x4
Cg_fixed2x1
Cg_fixed2x2
Cg_fixed2x3
Cg_fixed2x4
Cg_fixed3x1
Cg_fixed3x2
Cg_fixed3x3
Cg_fixed3x4
Cg_fixed4x1
Cg_fixed4x2
Cg_fixed4x3
Cg_fixed4x4
Cg_pipeline_stage
FRAGMENT
Cg_identifier
GLES_MAX_LIGHTS_index
GLES_MAX_CLIP_PLANES_index
GLES_MAX_TEXTURE_COORDS_index
GLES_MAX_TEXTURE_IMAGE_UNITS_index
Gles_texenv_mode_enums
MODULATE
DECAL
BLEND
Gles_texcombiner_operatorRGB_enums
ADD_SIGNED
INTERPOLATE
SUBTRACT
DOT3_RGB
DOT3_RGBA
Gles_texcombiner_operatorAlpha_enums
Gles_texcombiner_source_enums
TEXTURE
CONSTANT
PRIMARY
PREVIOUS
Gles_texcombiner_operandRGB_enums
Gles_texcombiner_operandAlpha_enums
Gles_texcombiner_argument_index_type
Gles_sampler_wrap
REPEAT
CLAMP_TO_EDGE
MIRRORED_REPEAT
Gles_stencil_op_type
Gles_enumeration
Gles_rendertarget_common
SpringType
ANGULAR
camera_node
notype
badtype
xsBoolean
xsInteger
xsHexBinary
xsIntegerArray
xsHexBinaryArray
xsByte
xsInt
xsLong
xsLongArray
%lld
long
xsShort
xsNonNegativeInteger
xsUnsignedByte
xsUnsignedInt
xsPositiveInteger
ulong
xsUnsignedLong
%llu
xsFloat
xsDouble
xsDecimal
xsString
xsDateTime
token
xsID
xsNCName
xsNMTOKEN
xsName
xsToken
xsNameArray
xsTokenArray
xsNCNameArray
element
Element
TrackedElement
resolver
xsAnyURI
xsIDREF
xsIDREFS
idref_resolver
-INF
NaN encountered while setting an attribute or value
INF encountered while setting an attribute or value
-INF encountered while setting an attribute or value
createArray
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/ColladaDOM/src/dae/daeAtomicType.cpp
setDocument
Name
Type
Attr name
Attr value
Char data
Child count
Element 1
Element 2
---------
---------
id = %s
DefaultIDRefResolver
Failed to load XML document from memory
Failed to load 
The DOM was unable to create an element named 
 at line 
. Probably a schema violation.
The DOM was unable to create an attribute 
Probably a schema violation.
Trying to load an invalid COLLADA version for this DOM build!
Missing xmlns meta attribute for root element.
The DOM was unable to set a value for element of type 
placeElement
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/ColladaDOM/src/dae/daeMetaChoice.cpp
child
noname
contentsOrder
CMData
_value
RawResolver
daeRawResolver::resolveElement() - Can't get path from URI
-array
XMLResolver
daeStandardURIResolver::resolveElement() - Failed to resolve 
URI(%s)
scheme = %s
authority = %s
path = %s
query = %s
fragment = %s
URI without base = %s
file://
saveRawBinary
TRUE
Failed to open 
 in daeLIBXMLPlugin::readFromFile
Failed to open XML document from memory buffer in daeLIBXMLPlugin::readFromMemory
Error parsing XML in daeLIBXMLPlugin::read
readElement
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/ColladaDOM/src/modules/LIBXMLPlugin/daeLIBXMLPlugin.cpp
xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
can't get path in write
.raw
daeLIBXMLPlugin::write(
) failed
UTF-8
writeRawSource
accessor != NULL
%s#%ld
ColladaDOM Error: %s
ColladaDOM Warning: %s
completeTopologyFromFaceValues
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/vtr/fvarLevel.cpp
vSpan._size != 0
Error:  invalid sibling %d for face-vert %d.%d = %d
Error:  unexpected value %d for sibling %d of face-vert %d.%d = %d (expecting %d)
Error:  invalid sibling %d at vert-face %d.%d
Error:  value mismatch between face-vert %d.%d and vert-face %d.%d (%d != %d)
    vertex count       = %d
    source value count = %d
    vertex value count = %d
    face%4d:  
verts =
,  values =
,  siblings =
    vert%4d:  vcount = %1d, voffset =%4d, 
values =
, crease =
, semi-sharp =
    edge%4d:  verts = [%4d%4d], discts = [%d,%d]
getVertexEdgeValues
edgeTopologyMatches(eIndex)
getFaceValueTags
_vertValueIndices[srcValueIndex] == faceValues[i]
getFaceCompositeValueTag
Error:  value/vertex-value count mismatch
Error:  face-value/face-vert count mismatch
Error:  edge count mismatch
Error:  vertex count mismatch
Face-varying data channel:
  Inventory:
  Face values:
  Vertex values:
  Edge discontinuities:
bilinear
catmark
loop
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/stencilBuilder.cpp
_sources[i] < _coarseVertCount
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/patchTableFactory.cpp
IsPatchEligible
fVerts.size() == 4
GetRegularPatchBoundaryMask
eBoundaryMask != -1
computePatchParam
ptexIndex!=-1
createUniform
refiner.IsUniform()
ptype!=PatchDescriptor::NON_PATCH
npatches>=0
(levelVertOffset + fvalues[vert]) < (int)table->getFVarValues(fvc).size()
createAdaptive
! refiner.IsUniform()
populateAdaptivePatches
"Unknown Descriptor for FVar patch" == 0
assignBoundaryPropertiesFromEdgeMask
edgeMaskToCount[eMask] != -1
edgeMaskToIndex[eMask] != -1
assignBoundaryPropertiesFromVertexMask
_hasBoundaryEdge == false
singleBitVertexMaskToCount[vMask] != -1
identifyNonManifoldCornerSpan
vSpan._numFaces == 1
    numPatches=%d vertIndex=%d patchIndex=%d quadOffsetIndex=%d
getPatchIndex
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/patchTable.cpp
patchIndex<pa.numPatches
getPatchArrayVertices
pa.vertIndex<(Index)_patchVerts.size()
GetPatchArrayVertices
GetPatchVertices
(pa.vertIndex + patchIndex*size)<(Index)_patchVerts.size()
GetPatchParam
handle.patchIndex < (Index)_paramTable.size()
(pa.patchIndex + patchIndex) < (int)_paramTable.size()
GetSingleCreasePatchSharpnessValue
(handle.patchIndex) < (int)_sharpnessIndices.size()
index < (Index)_sharpnessValues.size()
(pa.patchIndex + patchIndex) < (int)_sharpnessIndices.size()
patchTable (0x%p)
  numPatches = %d
  patchArray %d:
EvaluateBasis
EvaluateBasisFaceVarying
getFVarPatchChannel
channel>=0 && channel<(int)_fvarChannels.size()
getPatchArray
arrayIndex<(Index)GetNumPatchArrays()
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no vertices.
Failure in TopologyRefinerFactory<>::Create() -- meshes without faces not yet supported.
Failure in TopologyRefinerFactory<>::Create() -- face with %d vertices > %d max.
Failure in TopologyRefinerFactory<>::Create() -- mesh contains no face-vertices.
Failure in TopologyRefinerFactory<>::Create() -- non-triangular faces not supported by Loop scheme.
prepareComponentTopologySizing
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/topologyRefinerFactory.cpp
baseLevel.getNumFaceEdgesTotal() > 0
baseLevel.getNumEdgeVerticesTotal() > 0
baseLevel.getNumEdgeFacesTotal() > 0
baseLevel.getNumVertexFacesTotal() > 0
baseLevel.getNumVertexEdgesTotal() > 0
Failure in TopologyRefinerFactory<>::Create() -- vertex with valence %d > %d max.
Failure in TopologyRefinerFactory<>::Create() -- maximum valence not assigned.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected from partial specification.
Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected as fully specified.
prepareComponentTagsAndSharpness
(schemeRegularInteriorValence == 4) || (schemeRegularInteriorValence == 6)
Failure in TopologyRefinerFactory<>::Create() -- face-varying channel %d has no values.
GetFaceId
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/ptexIndices.cpp
f<(int)_ptexIndices.size()
Failure in PtexIndices::GetAdjacency() -- currently only implemented for quad schemes.
GetAdjacency
adjEdges[i]!=-1
adjFaces[i]!=-1
quadrant>=0 && quadrant<fedges.size()
adjFaces[0]!=-1
adjFaces[3]!=-1
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/../vtr/../vtr/array.h
GetAdaptivePatchDescriptors
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/patchDescriptor.cpp
NON_PATCH
POINTS
LINES
QUADS
TRIANGLES
LOOP
REGULAR
GREGORY
GREGORY_BOUNDARY
GREGORY_BASIS
    type %s
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/osd/mtlPatchTable.mm
0 && "MTLPatchTable Creation Failed"
OSD PatchIndexBuffer
OSD PatchParamBuffer
MISSING_EDGE_FACES
MISSING_EDGE_VERTS
MISSING_FACE_EDGES
MISSING_FACE_VERTS
MISSING_VERT_FACES
MISSING_VERT_EDGES
FAILED_CORRELATION_EDGE_FACE
FAILED_CORRELATION_FACE_VERT
FAILED_CORRELATION_FACE_EDGE
FAILED_ORIENTATION_INCIDENT_EDGE
FAILED_ORIENTATION_INCIDENT_FACE
FAILED_ORIENTATION_INCIDENT_FACES_EDGES
DEGENERATE_EDGE
NON_MANIFOLD_EDGE
INVALID_CREASE_EDGE
INVALID_CREASE_VERT
getTopologyErrorString
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/vtr/level.cpp
%s - missing face-verts
%s - missing vert-faces
%s - face %d correlation of vert %d failed
%s - missing edge-faces
%s - missing face-edges
%s - face %d correlation of edge %d failed
%s - missing edge-verts
%s - missing vert-edges
%s - edge %d correlation of vert %d failed
%s - vertex %d cannot orient incident faces and edges
%s - vertex %d orientation failure at incident face %d
%s - vertex %d orientation failure at incident edge %d
%s - Error in eIndex = %d:  degenerate edge not tagged marked non-manifold
%s - edge %d with %d incident faces not tagged non-manifold
Level (0x%p):
  Depth = %d
    faces = %d
    edges = %d
    verts = %d
      face-vert counts/offset = %lu
      face-vert indices = %lu
        face %4d verts:  
      face-edge indices = %lu
        face %4d edges:  
      face tags = %lu
        face %4d:
  hole = %d
      face child-verts = %lu
      edge-vert indices = %lu
        edge %4d verts:  
      edge-face counts/offset = %lu
      edge-face indices       = %lu
      edge-face local-indices = %lu
        edge %4d faces:  
             face-edges:  
      edge child-verts = %lu
        edge %4d child vert:  %d
      edge sharpness = %lu
        edge %4d sharpness:  %f
      edge tags = %lu
        edge %4d:
  boundary = %d
, nonManifold = %d
, semiSharp = %d
, infSharp = %d
      vert-face counts/offset = %lu
      vert-face indices       = %lu
      vert-face local-indices = %lu
        vert %4d faces:  
             face-verts:  
      vert-edge counts/offset = %lu
      vert-edge indices       = %lu
      vert-edge local-indices = %lu
        vert %4d edges:  
             edge-verts:  
      vert child-verts = %lu
      vert sharpness = %lu
        vert %4d sharpness:  %f
      vert tags = %lu
        vert %4d:
  rule = %s
, boundary = %d
, corner = %d
, xordinary = %d
, infSharpEdges = %d
, infSharpCrease = %d
, infIrregular = %d
, semiSharpEdges = %d
gatherQuadRegularPartialRingAroundVertex
! level.isVertexNonManifold(vIndex)
gatherQuadLinearPatchPoints
(0 <= rotation) && (rotation < 4)
gatherQuadRegularInteriorPatchPoints
gatherQuadRegularBoundaryPatchPoints
(boundaryFaceInV0Faces >= 0) && (boundaryFaceInV1Faces >= 0)
gatherQuadRegularCornerPatchPoints
cornerFaceInIntVertFaces >= 0
completeTopologyFromFaceVertices
(vCount > 0) && (fCount > 0) && (eCount == 0)
_maxValence > 0
orderVertexFacesAndEdges
eCountOrdered == eCount
fCountOrdered == fCount
<uninitialized>
Smooth
Dart
Crease
Corner
ruleString
%d [%d
FindIndexIn4Tuple
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/vtr/../vtr/array.h
_size>=4
"FindIndexIn4Tuple() did not find expected value!" == 0
  Primary component counts:
  Topology relation sizes:
    Face relations:
    Edge relations:
    Vert relations:
MTLStencilTable
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/osd/mtlComputeEvaluator.mm
context != nil
context->device != nil && context->commandQueue != nil
StencilTable Sizes
StencilTable Offsets
StencilTable Indices
StencilTable Weights
StencilTable duWeights
StencilTable dvWeights
Compile
Using OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
LENGTH
SRC_STRIDE
DST_STRIDE
WORK_GROUP_SIZE
OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
PARAMETER_BUFFER_INDEX
SIZES_BUFFER_INDEX
OFFSETS_BUFFER_INDEX
WEIGHTS_BUFFER_INDEX
SRC_VERTEX_BUFFER_INDEX
DST_VERTEX_BUFFER_INDEX
DU_WEIGHTS_BUFFER_INDEX
DV_WEIGHTS_BUFFER_INDEX
DU_DERIVATIVE_BUFFER_INDEX
DV_DERIVATIVE_BUFFER_INDEX
PATCH_ARRAYS_BUFFER_INDEX
PATCH_COORDS_BUFFER_INDEX
PATCH_PARAMS_BUFFER_INDEX
Error compiling MTL Shader: %s
eval_stencils
Error compiling MTL Pipeline eval_stencils: %s
eval_patches
Error compiling MTL Pipeline eval_patches:  %s
EvalStencils
context != nullptr
device != nil && commandQueue != nil
EvalPatches
patchArrays.size() == 2
#line 0 "osd/mtlComputeKernel.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#include <metal_stdlib>
#ifndef OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
#define OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES 0
#endif
using namespace metal;
struct PatchCoord
    int arrayIndex;
    int patchIndex;
    int vertIndex;
    float s;
    float t;
struct PatchParam
    uint field0;
    uint field1;
    float sharpness;
struct KernelUniformArgs
int batchStart;
int batchEnd;
    int srcOffset;
int dstOffset;
    int3 duDesc;
    int3 dvDesc;
struct Vertex {
    float vertexData[LENGTH];
void clear(thread Vertex& v) {
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] = 0;
    }
Vertex readVertex(int index, device float* vertexBuffer, KernelUniformArgs args) {
    Vertex v;
    int vertexIndex = args.srcOffset + index * SRC_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] = vertexBuffer[vertexIndex + i];
    }
    return v;
void writeVertex(int index, Vertex v, device float* vertexBuffer, KernelUniformArgs args) {
    int vertexIndex = args.dstOffset + index * DST_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        vertexBuffer[vertexIndex + i] = v.vertexData[i];
    }
void writeVertexSeparate(int index, Vertex v, device float* dstVertexBuffer, KernelUniformArgs args) {
    int vertexIndex = args.dstOffset + index * DST_STRIDE;
    for (int i = 0; i < LENGTH; ++i) {
        dstVertexBuffer[vertexIndex + i] = v.vertexData[i];
    }
void addWithWeight(thread Vertex& v, const Vertex src, float weight) {
    for (int i = 0; i < LENGTH; ++i) {
        v.vertexData[i] += weight * src.vertexData[i];
    }
void writeDu(int index, Vertex du, device float* duDerivativeBuffer, KernelUniformArgs args)
    int duIndex = args.duDesc.x + index * args.duDesc.z;
    for(int i = 0; i < LENGTH; i++)
    {
        duDerivativeBuffer[duIndex + i] = du.vertexData[i];
    }
void writeDv(int index, Vertex dv, device float* dvDerivativeBuffer, KernelUniformArgs args)
    int dvIndex = args.dvDesc.x + index * args.dvDesc.z;
    for(int i = 0; i < LENGTH; i++)
    {
        dvDerivativeBuffer[dvIndex + i] = dv.vertexData[i];
    }
// ---------------------------------------------------------------------------
kernel void eval_stencils(
    uint thread_position_in_grid [[thread_position_in_grid]],
    const device int* sizes [[buffer(SIZES_BUFFER_INDEX)]],
    const device int* offsets [[buffer(OFFSETS_BUFFER_INDEX)]],
    const device int* indices [[buffer(INDICES_BUFFER_INDEX)]],
    const device float* weights [[buffer(WEIGHTS_BUFFER_INDEX)]],
    device float* srcVertices [[buffer(SRC_VERTEX_BUFFER_INDEX)]],
    device float* dstVertexBuffer [[buffer(DST_VERTEX_BUFFER_INDEX)]],
    const device float* duWeights [[buffer(DU_WEIGHTS_BUFFER_INDEX)]],
    const device float* dvWeights [[buffer(DV_WEIGHTS_BUFFER_INDEX)]],
    device float* duDerivativeBuffer [[buffer(DU_DERIVATIVE_BUFFER_INDEX)]],
    device float* dvDerivativeBuffer [[buffer(DV_DERIVATIVE_BUFFER_INDEX)]],
    const constant KernelUniformArgs& args [[buffer(PARAMETER_BUFFER_INDEX)]]
    auto current  = thread_position_in_grid + args.batchStart;
    if(current >= args.batchEnd)
        return;
    Vertex dst;
    clear(dst);
    auto offset = offsets[current];
    auto size = sizes[current];
    for(auto stencil = 0; stencil < size; stencil++)
    {
        auto vindex = offset + stencil;
        addWithWeight(dst, readVertex(indices[vindex], srcVertices, args), weights[vindex]);
    }
    writeVertex(current, dst, dstVertexBuffer, args);
#if OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
    Vertex du, dv;
    clear(du);
    clear(dv);
    for(auto i = 0; i < size; i++)
    {
        auto src = readVertex(indices[offset + i], srcVertices, args);
        addWithWeight(du, src, duWeights[offset + i]);
        addWithWeight(dv, src, dvWeights[offset + i]);
    }
    writeDu(current, du, duDerivativeBuffer, args);
    writeDv(current, dv, dvDerivativeBuffer, args);
#endif
// ---------------------------------------------------------------------------
// PERFORMANCE: stride could be constant, but not as significant as length
//struct PatchArray {
//    int patchType;
//    int numPatches;
//    int indexBase;        // an offset within the index buffer
//    int primitiveIdBase;  // an offset within the patch param buffer
//};
// # of patcharrays is 1 or 2.
uint getDepth(uint patchBits) {
    return (patchBits & 0xf);
float getParamFraction(uint patchBits) {
    uint nonQuadRoot = (patchBits >> 4) & 0x1;
    uint depth = getDepth(patchBits);
    if (nonQuadRoot == 1) {
        return 1.0f / float( 1 << (depth-1) );
    } else {
        return 1.0f / float( 1 << depth );
    }
float2 normalizePatchCoord(uint patchBits, float2 uv) {
    float frac = getParamFraction(patchBits);
    uint iu = (patchBits >> 22) & 0x3ff;
    uint iv = (patchBits >> 12) & 0x3ff;
    // top left corner
    float pu = float(iu*frac);
    float pv = float(iv*frac);
    // normalize u,v coordinates
    return float2((uv.x - pu) / frac, (uv.y - pv) / frac);
bool isRegular(uint patchBits) {
    return (((patchBits >> 5) & 0x1u) != 0);
int getNumControlVertices(int patchType) {
    switch(patchType) {
        case 3: return 4;
        case 6: return 16;
        case 9: return 20;
        default: return 0;
    }
// ---------------------------------------------------------------------------
kernel void eval_patches(
                         uint thread_position_in_grid [[thread_position_in_grid]],
                         const constant uint4* patchArrays [[buffer(PATCH_ARRAYS_BUFFER_INDEX)]],
                         device PatchCoord* patchCoords [[buffer(PATCH_COORDS_BUFFER_INDEX)]],
                         device int* patchIndices [[buffer(PATCH_INDICES_BUFFER_INDEX)]],
                         device PatchParam* patchParams [[buffer(PATCH_PARAMS_BUFFER_INDEX)]],
                         device float* srcVertexBuffer [[buffer(SRC_VERTEX_BUFFER_INDEX)]],
                         device float* dstVertexBuffer [[buffer(DST_VERTEX_BUFFER_INDEX)]],
                         device float* duDerivativeBuffer [[buffer(DU_DERIVATIVE_BUFFER_INDEX)]],
                         device float* dvDerivativeBuffer [[buffer(DV_DERIVATIVE_BUFFER_INDEX)]],
                         const constant KernelUniformArgs& args [[buffer(PARAMETER_BUFFER_INDEX)]]
                         )
    auto current = thread_position_in_grid;
    auto patchCoord = patchCoords[current];
    auto patchIndex = patchIndices[patchCoord.patchIndex];
    auto patchArray = patchArrays[patchCoord.arrayIndex];
    auto patchBits = patchParams[patchIndex].field1; 
    auto patchType = select(isRegular(patchBits), 6, patchArray.x);
    auto numControlVertices = getNumControlVertices(patchType);
    auto uv = normalizePatchCoord(patchBits, float2(patchCoord.s, patchCoord.t));
    auto dScale = float(1 << getDepth(patchBits));
    auto boundaryMask = int((patchBits >> 8) & 0xFU);
    float wP[20], wDs[20], wDt[20], wDss[20], wDst[20], wDtt[20];
    if(patchType == 3) {
        OsdGetBilinearPatchWeights(uv.x, uv.y, dScale, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if(patchType == 6) {
        OsdGetBSplinePatchWeights(uv.x, uv.y, dScale, boundaryMask, wP, wDs, wDt, wDss, wDst, wDtt);
    } else if(patchType == 9) {
        OsdGetGregoryPatchWeights(uv.x, uv.y, dScale, wP, wDs, wDt, wDss, wDst, wDtt);
    }
    Vertex dst, du, dv;
    clear(dst);
    clear(du);
    clear(dv);
    auto indexBase = patchArray.z + numControlVertices * (patchCoord.patchIndex - patchArray.w);
    for(auto cv = 0; cv < numControlVertices; cv++)
    {
        auto index = patchIndices[indexBase + cv];
        auto src = readVertex(index, srcVertexBuffer, args);
        addWithWeight(dst, src, wP[cv]);
        addWithWeight(du, src, wDs[cv]);
        addWithWeight(dv, src, wDt[cv]);
    }
    writeVertex(current, dst, dstVertexBuffer, args);
#if OPENSUBDIV_MTL_COMPUTE_USE_DERIVATIVES
    if(args.duDesc.y > 0)
        writeDu(current, du, duDerivativeBuffer, args);
    if(args.dvDesc.y > 0)
        writeDv(current, dv, dvDerivativeBuffer, args);
#endif
appendLocalPointStencilTable
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/stencilTableFactory.cpp
Create
locationArrays[i].numLocations>=0
patchtable && cvstencils
array.ptexIdx>=0
GetStencil
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/../far/stencilTable.h
(! _offsets.empty()) && i<(int)_offsets.size()
FindPatch
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/../far/patchMap.h
(u>=0.0f) && (u<=1.0f) && (v>=0.0f) && (v<=1.0f)
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/../far/primvarRefiner.h
ProtoBasis
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/gregoryBasis.cpp
cornerPatchFace[corner] != -1
computeCoefficient
valence > 0
Refinement
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/vtr/refinement.cpp
(childArg.getDepth() == 0) && (childArg.getNumVertices() == 0)
refine
_parent && _child
populateParentToChildMapping
"Unsupported empty sparse refinement detected in Refinement" == 0
  Face %d:
    Child vert:  %d
    Child faces: 
    Child edges: 
  Edge %d:
    Child edges: %d %d
  Vert %d:
subdivideFVarChannels
_child->_fvarChannels.size() == 0
this->_fvarChannels.size() == 0
markSparseVertexChildren
_parentVertexTag.size() > 0
markSparseEdgeChildren
_parentEdgeTag.size() > 0
Parent-to-child component mapping:
No Error
Fatal Error
Coding Error (internal)
Coding Error
Error
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/error.cpp
err!=FAR_NO_ERROR
%s: %s
Warning: %s
estimateAndAllocateChildValues
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/vtr/fvarRefinement.cpp
_refinement.isChildVertexComplete(cVert)
propagateValueTags
propagateValueCreases
_childFVar.hasSmoothBoundaries()
populateChildValuesForEdgeVertex
cVertFaces.size() == cVertFaceSiblings.size()
cVertFaces.size() >= cValueCount
populateChildValuesForVertexVertex
populateFaceVerticesFromParentFaces
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/vtr/triRefinement.cpp
pFaceVerts.size() == 3
pFaceChildren.size() == 4
populateFaceEdgesFromParentFaces
pFaceChildFaces.size() == 4
pFaceChildEdges.size() == 3
populateEdgeVerticesFromParentFaces
pFaceEdges.size() == 3
populateEdgeFacesFromParentFaces
populateVertexFacesFromParentEdges
markSparseFaceChildren
_parentFaceTag.size() > 0
fChildFaces.size() == 4
fChildEdges.size() == 3
SetChild
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/patchMap.cpp
quadrant<4
initialize
! node->children[quadrant].isSet
#define OSD_METAL_OSX 1
#define OSD_PATCH_BASIS_METAL 1
#line 0 "osd/mtlPatchCommon.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.Common
//----------------------------------------------------------
#include <metal_stdlib>
#define offsetof_(X, Y) &(((device X*)nullptr)->Y)
#define OSD_IS_ADAPTIVE (OSD_PATCH_REGULAR || OSD_PATCH_GREGORY_BASIS || OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY)
#ifndef OSD_MAX_TESS_LEVEL
#define OSD_MAX_TESS_LEVEL 64
#endif
#ifndef OSD_NUM_ELEMENTS
#define OSD_NUM_ELEMENTS 3
#endif
#ifndef OSD_USER_VARYING_DECLARE
#define OSD_USER_VARYING_DECLARE
#endif
#ifndef OSD_USER_VARYING_DECLARE_ATTRIBUTE
#define OSD_USER_VARYING_DECLARE_ATTRIBUTE
#endif
#ifndef OSD_USER_VARYING_PER_VERTEX
#define OSD_USER_VARYING_PER_VERTEX(in, out)
#endif
#ifndef OSD_USER_VARYING_PER_CONTROL_POINT
#define OSD_USER_VARYING_PER_CONTROL_POINT(in, out)
#endif
#ifndef OSD_USER_VARYING_PER_EVAL_POINT
#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d, out)
#endif
static_assert(sizeof(OsdInputVertexType) > 0, "OsdInputVertexType must be defined and have a float3 position member");
#if OSD_IS_ADAPTIVE
#if OSD_PATCH_GREGORY_BASIS
constant constexpr unsigned IndexLookupStride = 5;
#else 
constant constexpr unsigned IndexLookupStride = 1;
#endif
#define PATCHES_PER_THREADGROUP ((THREADS_PER_THREADGROUP * CONTROL_POINTS_PER_THREAD) / CONTROL_POINTS_PER_PATCH)
#define REAL_THREADGROUP_DIVISOR (CONTROL_POINTS_PER_PATCH / CONTROL_POINTS_PER_THREAD)
static_assert(REAL_THREADGROUP_DIVISOR % 2 == 0, "REAL_THREADGROUP_DIVISOR must be a power of 2");
static_assert(!OSD_ENABLE_SCREENSPACE_TESSELLATION || !USE_PTVS_FACTORS, "USE_PTVS_FACTORS cannot be enabled if OSD_ENABLE_SCREENSPACE_TESSELLATION is enabled");
static_assert(OSD_ENABLE_SCREENSPACE_TESSELLATION && (OSD_FRACTIONAL_ODD_SPACING || OSD_FRACTIONAL_EVEN_SPACING) || !OSD_ENABLE_SCREENSPACE_TESSELLATION, "OSD_ENABLE_SCREENSPACE_TESSELLATION requires OSD_FRACTIONAL_ODD_SPACING or OSD_FRACTIONAL_EVEN_SPACING");
#endif
//Adjustments to the UV reparameterization can be defined here. 
#ifndef OSD_UV_CORRECTION
#define OSD_UV_CORRECTION
#endif
using namespace metal;
// ----------------------------------------------------------------------------
// Patch Parameters
// ----------------------------------------------------------------------------
// Each patch has a corresponding patchParam. This is a set of three values
// specifying additional information about the patch:
//    faceId    -- topological face identifier (e.g. Ptex FaceId)
//    bitfield  -- refinement-level, non-quad, boundary, transition, uv-offset
//    sharpness -- crease sharpness for single-crease patches
// These are stored in OsdPatchParamBuffer indexed by the value returned
// from OsdGetPatchIndex() which is a function of the current PrimitiveID
// along with an optional client provided offset.
using OsdPatchParamBufferType = packed_int3;
struct OsdPerVertexGregory {
    float3 P;
    short3 clipFlag;
    int valence;
    float3 e0;
    float3 e1;
#if OSD_PATCH_GREGORY_BOUNDARY
    int zerothNeighbor;
    float3 org;
#endif
    float3 r[OSD_MAX_VALENCE];
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchVertexGregory {
    packed_float3 P;
    packed_float3 Ep;
    packed_float3 Em;
    packed_float3 Fp;
    packed_float3 Fm;
    OSD_USER_VARYING_DECLARE
//----------------------------------------------------------
// HLSL->Metal Compatibility
//----------------------------------------------------------
float4 mul(float4x4 a, float4 b)
    return a * b;
float3 mul(float4x4 a, float3 b)
    float3x3 m(a[0].xyz, a[1].xyz, a[2].xyz);
    return m * b;
//----------------------------------------------------------
// Patches.Common
//----------------------------------------------------------
// For now, fractional spacing is supported only with screen space tessellation
#ifndef OSD_ENABLE_SCREENSPACE_TESSELLATION
#undef OSD_FRACTIONAL_EVEN_SPACING
#undef OSD_FRACTIONAL_ODD_SPACING
#endif
struct HullVertex {
    float4 position;
#if OSD_ENABLE_PATCH_CULL
    short3 clipFlag;
#endif
    OSD_USER_VARYING_DECLARE
    float3 GetPosition() threadgroup
    {
        return position.xyz;
    }
    void SetPosition(float3 v) threadgroup
    {
    
position.xyz = v;
    }
// XXXdyu all downstream data can be handled by client code
struct OsdPatchVertex {
    float3 position;
    float3 normal;
    float3 tangent;
    float3 bitangent;
    float4 patchCoord; //u, v, faceLevel, faceId
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float3 Nu;
    float3 Nv;
#endif
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float2 vSegments;
#endif
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchTessFactors {
    float4 tessOuterLo;
    float4 tessOuterHi;
struct OsdPerPatchVertexBezier {
    packed_float3 P;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    packed_float3 P1;
    packed_float3 P2;
#if !USE_PTVS_SHARPNESS
    float2 vSegments;
#endif
#endif
    OSD_USER_VARYING_DECLARE
struct OsdPerPatchVertexGregoryBasis {
    packed_float3 P;
    OSD_USER_VARYING_DECLARE
#if OSD_PATCH_REGULAR
using PatchVertexType = HullVertex;
using PerPatchVertexType = OsdPerPatchVertexBezier;
#elif OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
using PatchVertexType = OsdPerVertexGregory;
using PerPatchVertexType = OsdPerPatchVertexGregory;
#elif OSD_PATCH_GREGORY_BASIS
using PatchVertexType = HullVertex;
using PerPatchVertexType = OsdPerPatchVertexGregoryBasis;
#else
using PatchVertexType = OsdInputVertexType;
using PerPatchVertexType = OsdInputVertexType;
#endif
//Shared buffers used by OSD that are common to all kernels
struct OsdPatchParamBufferSet
const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];
const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];
const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];
device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX)]];
#if !USE_PTVS_FACTORS    
    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];
#endif
#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
const device int* quadOffsetBuffer [[buffer(OSD_QUADOFFSET_BUFFER_INDEX)]];
const device int* valenceBuffer [[buffer(OSD_VALENCE_BUFFER_INDEX)]];
#endif
const constant unsigned& kernelExecutionLimit [[buffer(OSD_KERNELLIMIT_BUFFER_INDEX)]];
//Shared buffers used by OSD that are common to all PTVS implementations
struct OsdVertexBufferSet
const device OsdInputVertexType* vertexBuffer [[buffer(VERTEX_BUFFER_INDEX)]];
const device unsigned* indexBuffer [[buffer(CONTROL_INDICES_BUFFER_INDEX)]];
const device OsdPatchParamBufferType* patchParamBuffer [[buffer(OSD_PATCHPARAM_BUFFER_INDEX)]];
device PerPatchVertexType* perPatchVertexBuffer [[buffer(OSD_PERPATCHVERTEXBEZIER_BUFFER_INDEX)]];
#if !USE_PTVS_FACTORS    
    device OsdPerPatchTessFactors* patchTessBuffer [[buffer(OSD_PERPATCHTESSFACTORS_BUFFER_INDEX)]];
#endif
// ----------------------------------------------------------------------------
// Patch Parameters Accessors
// ----------------------------------------------------------------------------
int3 OsdGetPatchParam(int patchIndex, const device OsdPatchParamBufferType* osdPatchParamBuffer)
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    return int3(osdPatchParamBuffer[patchIndex]);
#else
    auto p = osdPatchParamBuffer[patchIndex];
    return int3(p[0], p[1], 0);
#endif
int OsdGetPatchIndex(int primitiveId)
    return primitiveId;
int OsdGetPatchFaceId(int3 patchParam)
    return (patchParam.x & 0xfffffff);
int OsdGetPatchFaceLevel(int3 patchParam)
    return (1 << ((patchParam.y & 0xf) - ((patchParam.y >> 4) & 1)));
int OsdGetPatchRefinementLevel(int3 patchParam)
    return (patchParam.y & 0xf);
int OsdGetPatchBoundaryMask(int3 patchParam)
    return ((patchParam.y >> 8) & 0xf);
int OsdGetPatchTransitionMask(int3 patchParam)
    return ((patchParam.x >> 28) & 0xf);
int2 OsdGetPatchFaceUV(int3 patchParam)
    int u = (patchParam.y >> 22) & 0x3ff;
    int v = (patchParam.y >> 12) & 0x3ff;
    return int2(u,v);
bool OsdGetPatchIsRegular(int3 patchParam)
    return ((patchParam.y >> 5) & 0x1) != 0;
float OsdGetPatchSharpness(int3 patchParam)
    return as_type<float>(patchParam.z);
float OsdGetPatchSingleCreaseSegmentParameter(int3 patchParam, float2 uv)
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    float s = 0;
    if ((boundaryMask & 1) != 0) {
        s = 1 - uv.y;
    } else if ((boundaryMask & 2) != 0) {
        s = uv.x;
    } else if ((boundaryMask & 4) != 0) {
        s = uv.y;
    } else if ((boundaryMask & 8) != 0) {
        s = 1 - uv.x;
    }
    return s;
// ----------------------------------------------------------------------------
void
OsdUnivar4x4(float u, thread float* B)
    float t = u;
    float s = 1.0f - u;
    
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
void
OsdUnivar4x4(float u, thread float* B, thread float* D)
    float t = u;
    float s = 1.0f - u;
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
    D[0] =    - A0;
    D[1] = A0 - A1;
    D[2] = A1 - A2;
    D[3] = A2;
void
OsdUnivar4x4(float u, thread float* B, thread float* D, thread float* C)
    float t = u;
    float s = 1.0f - u;
    float A0 = s * s;
    float A1 = 2 * s * t;
    float A2 = t * t;
    B[0] = s * A0;
    B[1] = t * A0 + s * A1;
    B[2] = t * A1 + s * A2;
    B[3] = t * A2;
    D[0] =    - A0;
    D[1] = A0 - A1;
    D[2] = A1 - A2;
    D[3] = A2;
    A0 =   - s;
    A1 = s - t;
    A2 = t;
    C[0] =    - A0;
    C[1] = A0 - A1;
    C[2] = A1 - A2;
    C[3] = A2;
// ----------------------------------------------------------------------------
float3
OsdEvalBezier(float3 cp[16], float2 uv)
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float B[4], D[4];
    OsdUnivar4x4(uv.x, B, D);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = cp[4*i + j];
            BUCP[i] += A * B[j];
        }
    }
    float3 P = float3(0,0,0);
    OsdUnivar4x4(uv.y, B, D);
    for (int k=0; k<4; ++k) {
        P += B[k] * BUCP[k];
    }
    return P;
bool OsdCullPerPatchVertex(
threadgroup PatchVertexType* patch, 
float4x4 ModelViewMatrix
#if OSD_ENABLE_BACKPATCH_CULL && OSD_PATCH_REGULAR
    auto v0 = float3(ModelViewMatrix * patch[5].position);
    auto v3 = float3(ModelViewMatrix * patch[6].position);
    auto v12 = float3(ModelViewMatrix * patch[9].position);
    auto n = normalize(cross(v3 - v0, v12 - v0));
    v0 = normalize(v0 + v3 + v12);
    if(dot(v0, n) > 0.6f)
    {
        return false;
    }
#endif
#if OSD_ENABLE_PATCH_CULL
    short3 clipFlag = short3(0,0,0);
    for(int i = 0; i < CONTROL_POINTS_PER_PATCH; ++i) {
        clipFlag |= patch[i].clipFlag;
    }
    if (any(clipFlag != short3(3,3,3))) {
        return false;
    }
#endif
    return true;
// When OSD_PATCH_ENABLE_SINGLE_CREASE is defined,
// this function evaluates single-crease patch, which is segmented into
// 3 parts in the v-direction.
//  v=0             vSegment.x        vSegment.y              v=1
//   +------------------+-------------------+------------------+
//   |       cp 0       |     cp 1          |      cp 2        |
//   | (infinite sharp) | (floor sharpness) | (ceil sharpness) |
//   +------------------+-------------------+------------------+
float3
OsdEvalBezier(device OsdPerPatchVertexBezier* cp, int3 patchParam, float2 uv)
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float B[4], D[4];
    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, uv);
    OsdUnivar4x4(uv.x, B, D);
#if OSD_PATCH_ENABLE_SINGLE_CREASE
#if USE_PTVS_SHARPNESS
    float sharpness = OsdGetPatchSharpness(patchParam);
    float Sf = floor(sharpness);
    float Sc = ceil(sharpness);
    float s0 = 1 - exp2(-Sf);
    float s1 = 1 - exp2(-Sc);
    float2 vSegments(s0, s1);
#else
    float2 vSegments = cp[0].vSegments;
#endif // USE_PTVS_SHARPNESS
    //By doing the offset calculation ahead of time it can be kept out of the actual indexing lookup.
    if(s <= vSegments.x)
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 0);
    else if( s <= vSegments.y)
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 3);
    else
        cp = (device OsdPerPatchVertexBezier*)(((device float*)cp) + 6);
    BUCP[0] += cp[0].P * B[0];
    BUCP[0] += cp[1].P * B[1];
    BUCP[0] += cp[2].P * B[2];
    BUCP[0] += cp[3].P * B[3];
    BUCP[1] += cp[4].P * B[0];
    BUCP[1] += cp[5].P * B[1];
    BUCP[1] += cp[6].P * B[2];
    BUCP[1] += cp[7].P * B[3];
    BUCP[2] += cp[8].P * B[0];
    BUCP[2] += cp[9].P * B[1];
    BUCP[2] += cp[10].P * B[2];
    BUCP[2] += cp[11].P * B[3];
    BUCP[3] += cp[12].P * B[0];
    BUCP[3] += cp[13].P * B[1];
    BUCP[3] += cp[14].P * B[2];
    BUCP[3] += cp[15].P * B[3];
#else // single crease
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = cp[4*i + j].P;
            BUCP[i] += A * B[j];
        }
    }
#endif  // single crease
    OsdUnivar4x4(uv.y, B);
    float3 P = B[0] * BUCP[0];
    for (int k=1; k<4; ++k) {
        P += B[k] * BUCP[k];
    }
    return P;
// ----------------------------------------------------------------------------
// Boundary Interpolation
// ----------------------------------------------------------------------------
template<typename VertexType>
void
OsdComputeBSplineBoundaryPoints(threadgroup VertexType* cpt, int3 patchParam)
//APPL TODO - multithread this
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if ((boundaryMask & 1) != 0) {
        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());
        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());
        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());
        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());
    }
    if ((boundaryMask & 2) != 0) {
        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());
        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());
        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());
        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());
    }
    if ((boundaryMask & 4) != 0) {
        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());
        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());
        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());
        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());
    }
    if ((boundaryMask & 8) != 0) {
        cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());
        cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());
        cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());
        cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());
    }
template<typename VertexType>
void
OsdComputeBSplineBoundaryPoints(thread VertexType* cpt, int3 patchParam)
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if ((boundaryMask & 1) != 0) {
        cpt[0].SetPosition(2*cpt[4].GetPosition() - cpt[8].GetPosition());
        cpt[1].SetPosition(2*cpt[5].GetPosition() - cpt[9].GetPosition());
        cpt[2].SetPosition(2*cpt[6].GetPosition() - cpt[10].GetPosition());
        cpt[3].SetPosition(2*cpt[7].GetPosition() - cpt[11].GetPosition());
    }
    if ((boundaryMask & 2) != 0) {
        cpt[3].SetPosition(2*cpt[2].GetPosition() - cpt[1].GetPosition());
        cpt[7].SetPosition(2*cpt[6].GetPosition() - cpt[5].GetPosition());
        cpt[11].SetPosition(2*cpt[10].GetPosition() - cpt[9].GetPosition());
        cpt[15].SetPosition(2*cpt[14].GetPosition() - cpt[13].GetPosition());
    }
    if ((boundaryMask & 4) != 0) {
        cpt[12].SetPosition(2*cpt[8].GetPosition() - cpt[4].GetPosition());
        cpt[13].SetPosition(2*cpt[9].GetPosition() - cpt[5].GetPosition());
        cpt[14].SetPosition(2*cpt[10].GetPosition() - cpt[6].GetPosition());
        cpt[15].SetPosition(2*cpt[11].GetPosition() - cpt[7].GetPosition());
    }
    if ((boundaryMask & 8) != 0) {
      cpt[0].SetPosition(2*cpt[1].GetPosition() - cpt[2].GetPosition());
      cpt[4].SetPosition(2*cpt[5].GetPosition() - cpt[6].GetPosition());
      cpt[8].SetPosition(2*cpt[9].GetPosition() - cpt[10].GetPosition());
      cpt[12].SetPosition(2*cpt[13].GetPosition() - cpt[14].GetPosition());
    }
void
OsdEvalPatchGregory(int3 patchParam, float2 UV, thread float3* cv,
                    thread float3& P, thread float3& dPu, thread float3& dPv,
                    thread float3& N, thread float3& dNu, thread float3& dNv)
    float u = UV.x, v = UV.y;
    float U = 1-u, V = 1-v;
    //(0,1)                              (1,1)
    //   P3         e3-      e2+         P2
    //      15------17-------11-------10
    //      |        |        |        |
    //      |        |        |        |
    //      |        | f3-    | f2+    |
    //      |       19       13        |
    //  e3+ 16-----18          14-----12 e2-
    //      |     f3+          f2-     |
    //      |                          |
    //      |                          |
    //      |     f0-         f1+      |
    //  e0- 2------4            8------6 e1+
    //      |        3 f0+    9        |
    //      |        |        | f1-    |
    //      |        |        |        |
    //      |        |        |        |
    //      0--------1--------7--------5
    //    P0        e0+      e1-         P1
    //(0,0)                               (1,0)
    float d11 = u+v;
    float d12 = U+v;
    float d21 = u+V;
    float d22 = U+V;
    float3 q[16];
    q[ 5] = (d11 == 0.0) ? cv[3]  : (u*cv[3] + v*cv[4])/d11;
    q[ 6] = (d12 == 0.0) ? cv[8]  : (U*cv[9] + v*cv[8])/d12;
    q[ 9] = (d21 == 0.0) ? cv[18] : (u*cv[19] + V*cv[18])/d21;
    q[10] = (d22 == 0.0) ? cv[13] : (U*cv[13] + V*cv[14])/d22;
    q[ 0] = cv[0];
    q[ 1] = cv[1];
    q[ 2] = cv[7];
    q[ 3] = cv[5];
    q[ 4] = cv[2];
    q[ 7] = cv[6];
    q[ 8] = cv[16];
    q[11] = cv[12];
    q[12] = cv[15];
    q[13] = cv[17];
    q[14] = cv[11];
    q[15] = cv[10];
    P   = float3(0,0,0);
    dPu = float3(0,0,0);
    dPv = float3(0,0,0);
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4], C[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    CUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    float3 dUU = float3(0,0,0);
    float3 dVV = float3(0,0,0);
    float3 dUV = float3(0,0,0);
    OsdUnivar4x4(UV.x, B, D, C);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = q[4*i + j];
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
            CUCP[i] += A * C[j];
        }
    }
    OsdUnivar4x4(UV.y, B, D, C);
    for (int i=0; i<4; ++i) {
        P   += B[i] * BUCP[i];
        dPu += B[i] * DUCP[i];
        dPv += D[i] * BUCP[i];
        dUU += B[i] * CUCP[i];
        dVV += C[i] * BUCP[i];
        dUV += D[i] * DUCP[i];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;
    float3 n = cross(dPu, dPv);
    N = normalize(n);
    float E = dot(dPu, dPu);
    float F = dot(dPu, dPv);
    float G = dot(dPv, dPv);
    float e = dot(N, dUU);
    float f = dot(N, dUV);
    float g = dot(N, dVV);
    dNu = (f*F-e*G)/(E*G-F*F) * dPu + (e*F-f*E)/(E*G-F*F) * dPv;
    dNv = (g*F-f*G)/(E*G-F*F) * dPu + (f*F-g*E)/(E*G-F*F) * dPv;
    dNu = dNu/length(n) - n * (dot(dNu,n)/powr(dot(n,n), 1.5));
    dNv = dNv/length(n) - n * (dot(dNv,n)/powr(dot(n,n), 1.5));
#else //OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = q[4*i + j];
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
        }
    }
    OsdUnivar4x4(UV.y, B, D);
    for (int i=0; i<4; ++i) {
        P += B[i] * BUCP[i];
        dPu += B[i] * DUCP[i];
        dPv += D[i] * BUCP[i];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    N = normalize(cross(dPu, dPv));
    dNu = float3(0,0,0);
    dNv = float3(0,0,0);
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
// ----------------------------------------------------------------------------
// Tessellation
// ----------------------------------------------------------------------------
// Organization of B-spline and Bezier control points.
// Each patch is defined by 16 control points (labeled 0-15).
// The patch will be evaluated across the domain from (0,0) at
// the lower-left to (1,1) at the upper-right. When computing
// adaptive tessellation metrics, we consider refined vertex-vertex
// and edge-vertex points along the transition edges of the patch
// (labeled vv* and ev* respectively).
// The two segments of each transition edge are labeled Lo and Hi,
// with the Lo segment occuring before the Hi segment along the
// transition edge's domain parameterization. These Lo and Hi segment
// tessellation levels determine how domain evaluation coordinates
// are remapped along transition edges. The Hi segment value will
// be zero for a non-transition edge.
// (0,1)                                         (1,1)
//   vv3                  ev23                   vv2
//        |       Lo3       |       Hi3       |
//      --O-----------O-----+-----O-----------O--
//        | 12        | 13     14 |        15 |
//        |           |           |           |
//        |           |           |           |
//    Hi0 |           |           |           | Hi2
//        |           |           |           |
//        O-----------O-----------O-----------O
//        | 8         | 9      10 |        11 |
//        |           |           |           |
// ev03 --+           |           |           +-- ev12
//        |           |           |           |
//        | 4         | 5       6 |         7 |
//        O-----------O-----------O-----------O
//        |           |           |           |
//    Lo0 |           |           |           | Lo2
//        |           |           |           |
//        |           |           |           |
//        | 0         | 1       2 |         3 |
//      --O-----------O-----+-----O-----------O--
//        |       Lo1       |       Hi1       |
//   vv0                  ev01                   vv1
// (0,0)                                         (1,0)
float OsdComputePostProjectionSphereExtent(const float4x4 OsdProjectionMatrix, float3 center, float diameter)
    //float4 p = OsdProjectionMatrix * float4(center, 1.0);
    float w = OsdProjectionMatrix[0][3] * center.x + OsdProjectionMatrix[1][3] * center.y + OsdProjectionMatrix[2][3] * center.z + OsdProjectionMatrix[3][3];
    return abs(diameter * OsdProjectionMatrix[1][1] / w);
// Round up to the nearest even integer
float OsdRoundUpEven(float x) {
    return 2*ceil(x/2);
// Round up to the nearest odd integer
float OsdRoundUpOdd(float x) {
    return 2*ceil((x+1)/2)-1;
// Compute outer and inner tessellation levels taking into account the
// current tessellation spacing mode.
void
OsdComputeTessLevels(thread float4& tessOuterLo, thread float4& tessOuterHi,
                     thread float4& tessLevelOuter, thread float2& tessLevelInner)
    // Outer levels are the sum of the Lo and Hi segments where the Hi
    // segments will have lengths of zero for non-transition edges.
#if OSD_FRACTIONAL_EVEN_SPACING
    // Combine fractional outer transition edge levels before rounding.
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    // Round the segments of transition edges separately. We will recover the
    // fractional parameterization of transition edges after tessellation.
    tessLevelOuter = combinedOuter;
    if (tessOuterHi[0] > 0) {
        tessLevelOuter[0] =
            OsdRoundUpEven(tessOuterLo[0]) + OsdRoundUpEven(tessOuterHi[0]);
    }
    if (tessOuterHi[1] > 0) {
        tessLevelOuter[1] =
            OsdRoundUpEven(tessOuterLo[1]) + OsdRoundUpEven(tessOuterHi[1]);
    }
    if (tessOuterHi[2] > 0) {
        tessLevelOuter[2] =
            OsdRoundUpEven(tessOuterLo[2]) + OsdRoundUpEven(tessOuterHi[2]);
    }
    if (tessOuterHi[3] > 0) {
        tessLevelOuter[3] =
            OsdRoundUpEven(tessOuterLo[3]) + OsdRoundUpEven(tessOuterHi[3]);
    }
#elif OSD_FRACTIONAL_ODD_SPACING
    // Combine fractional outer transition edge levels before rounding.
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    // Round the segments of transition edges separately. We will recover the
    // fractional parameterization of transition edges after tessellation.
    //
    // The sum of the two outer odd segment lengths will be an even number
    // which the tessellator will increase by +1 so that there will be a
    // total odd number of segments. We clamp the combinedOuter tess levels
    // (used to compute the inner tess levels) so that the outer transition
    // edges will be sampled without degenerate triangles.
    tessLevelOuter = combinedOuter;
    if (tessOuterHi[0] > 0) {
        tessLevelOuter[0] =
            OsdRoundUpOdd(tessOuterLo[0]) + OsdRoundUpOdd(tessOuterHi[0]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[1] > 0) {
        tessLevelOuter[1] =
            OsdRoundUpOdd(tessOuterLo[1]) + OsdRoundUpOdd(tessOuterHi[1]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[2] > 0) {
        tessLevelOuter[2] =
            OsdRoundUpOdd(tessOuterLo[2]) + OsdRoundUpOdd(tessOuterHi[2]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
    if (tessOuterHi[3] > 0) {
        tessLevelOuter[3] =
            OsdRoundUpOdd(tessOuterLo[3]) + OsdRoundUpOdd(tessOuterHi[3]);
        combinedOuter = max(float4(3,3,3,3), combinedOuter);
    }
#else //OSD_FRACTIONAL_ODD_SPACING
    // Round equally spaced transition edge levels before combining.
    tessOuterLo = round(tessOuterLo);
    tessOuterHi = round(tessOuterHi);
    float4 combinedOuter = tessOuterLo + tessOuterHi;
    tessLevelOuter = combinedOuter;
#endif //OSD_FRACTIONAL_ODD_SPACING
    // Inner levels are the averages the corresponding outer levels.
    tessLevelInner[0] = (combinedOuter[1] + combinedOuter[3]) * 0.5;
    tessLevelInner[1] = (combinedOuter[0] + combinedOuter[2]) * 0.5;
float OsdComputeTessLevel(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix, float3 p0, float3 p1)
    // Adaptive factor can be any computation that depends only on arg values.
    // Project the diameter of the edge's bounding sphere instead of using the
    // length of the projected edge itself to avoid problems near silhouettes.
    float3 center = (p0 + p1) / 2.0;
    float diameter = distance(p0, p1);
    float projLength = OsdComputePostProjectionSphereExtent(OsdProjectionMatrix, center, diameter);
    float tessLevel = max(1.0, OsdTessLevel * projLength);
    // We restrict adaptive tessellation levels to half of the device
    // supported maximum because transition edges are split into two
    // halfs and the sum of the two corresponding levels must not exceed
    // the device maximum. We impose this limit even for non-transition
    // edges because a non-transition edge must be able to match up with
    // one half of the transition edge of an adjacent transition patch.
    return min(tessLevel, (float)(OSD_MAX_TESS_LEVEL / 2));
void
OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,
                        thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Uniform factors are simple powers of two for each level.
    // The maximum here can be increased if we know the maximum
    // refinement level of the mesh:
    //     min(OSD_MAX_TESS_LEVEL, pow(2, MaximumRefinementLevel-1)
    int refinementLevel = OsdGetPatchRefinementLevel(patchParam);
    float tessLevel = min(OsdTessLevel, ((float)OSD_MAX_TESS_LEVEL / 2)) /
                        pow(2, refinementLevel - 1.0f);
//    float tessLevel = min(OsdTessLevel, (float)OSD_MAX_TESS_LEVEL);
//    if(refinementLevel != 0)
//         tessLevel /= (1 << (refinementLevel - 1));
//    else
//    {
//        tessLevel /= pow(2.0, (0 - 1));
//        tessLevel /= pow(2.0, (refinementLevel - 1));
//    }
    // tessLevels of transition edge should be clamped to 2.
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    float4 tessLevelMin = float4(1)
    + float4(((transitionMask & 8) >> 3),
             ((transitionMask & 1) >> 0),
             ((transitionMask & 2) >> 1),
             ((transitionMask & 4) >> 2));
//    tessLevelMin =  (tessLevelMin - 1.0) * 2.0f + 1.0;
//    tessLevelMin = float4(OsdTessLevel);
    tessOuterLo = max(float4(tessLevel,tessLevel,tessLevel,tessLevel),
                      tessLevelMin);
    tessOuterHi = float4(0,0,0,0);
//    tessOuterLo.x = refinementLevel;
void
OsdGetTessLevelsRefinedPoints(const float OsdTessLevel,
                              const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                              float3 cp[16], int3 patchParam,
                              thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. We compute the corresponding
    // vertex-vertex and edge-vertex refined points along the edges of the
    // patch using Catmull-Clark subdivision stencil weights.
    // For simplicity, we let the optimizer discard unused computation.
    float3 vv0 = (cp[0] + cp[2] + cp[8] + cp[10]) * 0.015625 +
    (cp[1] + cp[4] + cp[6] + cp[9]) * 0.09375 + cp[5] * 0.5625;
    float3 ev01 = (cp[1] + cp[2] + cp[9] + cp[10]) * 0.0625 +
    (cp[5] + cp[6]) * 0.375;
    float3 vv1 = (cp[1] + cp[3] + cp[9] + cp[11]) * 0.015625 +
    (cp[2] + cp[5] + cp[7] + cp[10]) * 0.09375 + cp[6] * 0.5625;
    float3 ev12 = (cp[5] + cp[7] + cp[9] + cp[11]) * 0.0625 +
    (cp[6] + cp[10]) * 0.375;
    float3 vv2 = (cp[5] + cp[7] + cp[13] + cp[15]) * 0.015625 +
    (cp[6] + cp[9] + cp[11] + cp[14]) * 0.09375 + cp[10] * 0.5625;
    float3 ev23 = (cp[5] + cp[6] + cp[13] + cp[14]) * 0.0625 +
    (cp[9] + cp[10]) * 0.375;
    float3 vv3 = (cp[4] + cp[6] + cp[12] + cp[14]) * 0.015625 +
    (cp[5] + cp[8] + cp[10] + cp[13]) * 0.09375 + cp[9] * 0.5625;
    float3 ev03 = (cp[4] + cp[6] + cp[8] + cp[10]) * 0.0625 +
    (cp[5] + cp[9]) * 0.375;
    tessOuterLo = float4(0,0,0,0);
    tessOuterHi = float4(0,0,0,0);
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
    if ((transitionMask & 8) != 0) {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev03);
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev03);
    } else {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[9]);
    }
    if ((transitionMask & 1) != 0) {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv0, ev01);
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev01);
    } else {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[5], cp[6]);
    }
    if ((transitionMask & 2) != 0) {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv1, ev12);
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev12);
    } else {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[6], cp[10]);
    }
    if ((transitionMask & 4) != 0) {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv3, ev23);
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, vv2, ev23);
    } else {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp[9], cp[10]);
    }
float3 miniMul(float4x4 a, float3 b)
    float3 r;
    r.x = a[0][0] * b[0] + a[1][0] * b[1] + a[2][0] * b[2] + a[3][0];
    r.y = a[0][1] * b[0] + a[1][1] * b[1] + a[2][1] * b[2] + a[3][1];
    r.z = a[0][2] * b[0] + a[1][2] * b[1] + a[2][2] * b[2] + a[3][2];
    return r;
void
OsdGetTessLevelsLimitPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                            device OsdPerPatchVertexBezier* cpBezier,
                            int3 patchParam, thread float4& tessOuterLo, thread float4& tessOuterHi)
    // Each edge of a transition patch is adjacent to one or two patches
    // at the next refined level of subdivision. When the patch control
    // points have been converted to the Bezier basis, the control points
    // at the four corners are on the limit surface (since a Bezier patch
    // interpolates its corner control points). We can compute an adaptive
    // tessellation level for transition edges on the limit surface by
    // evaluating a limit position at the mid point of each transition edge.
    tessOuterLo = float4(0,0,0,0);
    tessOuterHi = float4(0,0,0,0);
    int transitionMask = OsdGetPatchTransitionMask(patchParam);
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    // PERFOMANCE: we just need to pick the correct corner points from P, P1, P2
    float3 p0 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.0));
    float3 p3 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.0));
    float3 p12 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 1.0));
    float3 p15 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 1.0));
    p0 = miniMul(OsdModelViewMatrix, p0);
    p3 = miniMul(OsdModelViewMatrix, p3);
    p12 = miniMul(OsdModelViewMatrix, p12);
    p15 = miniMul(OsdModelViewMatrix, p15);
    thread float3 * tPt;
    float3 ev;
    if ((transitionMask & 8) != 0) { // EVO3
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p12, ev);
    } else {
        tPt = &p12;
    }
    tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p0, *tPt);
    
    if ((transitionMask & 1) != 0) { // EV01
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p3, ev);
    } else {
        tPt = &p3;
    }
    tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p0, *tPt);
    
    if ((transitionMask & 2) != 0) { // EV12
        ev = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p15, ev);
    } else {
        tPt = &p15;
    }
    tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p3, *tPt);
    
    if ((transitionMask & 4) != 0) { // EV23
        ev = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));
        ev = miniMul(OsdModelViewMatrix, ev);
        tPt = &ev;
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p15, ev);
    } else {
        tPt = &p15;
    }
    tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,p12, *tPt);
#else // OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 p0 = OsdEvalBezier(cpBezier, patchParam, float2(0.0, 0.5));
    float3 p3 = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 0.0));
    float3 p12 = OsdEvalBezier(cpBezier, patchParam, float2(1.0, 0.5));
    float3 p15 = OsdEvalBezier(cpBezier, patchParam, float2(0.5, 1.0));
    p0 = miniMul(OsdModelViewMatrix, p0);
    p3 = miniMul(OsdModelViewMatrix, p3);
    p12 = miniMul(OsdModelViewMatrix, p12);
    p15 = miniMul(OsdModelViewMatrix, p15);
    float3 c00 = miniMul(OsdModelViewMatrix, cpBezier[0].P);
    float3 c12 = miniMul(OsdModelViewMatrix, cpBezier[12].P);
    float3 c03 = miniMul(OsdModelViewMatrix, cpBezier[3].P);
    float3 c15 = miniMul(OsdModelViewMatrix, cpBezier[15].P);
    
    if ((transitionMask & 8) != 0) {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, p0);
        tessOuterHi[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, p0);
    } else {
        tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, c12);
    }
    if ((transitionMask & 1) != 0) {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, p3);
        tessOuterHi[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, p3);
    } else {
        tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c00, c03);
    }
    if ((transitionMask & 2) != 0) {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, p12);
        tessOuterHi[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c15, p12);
    } else {
        tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c03, c15);
    }
    if ((transitionMask & 4) != 0) {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, p15);
        tessOuterHi[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c15, p15);
    } else {
        tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix,c12, c15);
    }
#endif
void
OsdGetTessLevelsUniform(const float OsdTessLevel, int3 patchParam,
                        thread float4& tessLevelOuter, thread float2& tessLevelInner,
                        thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi, tessLevelOuter, tessLevelInner);
void
OsdGetTessLevelsAdaptiveRefinedPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                                      float3 cpRefined[16], int3 patchParam,
                                      thread float4& tessLevelOuter, thread float2& tessLevelInner,
                                      thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsRefinedPoints(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cpRefined, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
void
OsdGetTessLevelsAdaptiveLimitPoints(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                                    device OsdPerPatchVertexBezier* cpBezier,
                                    int3 patchParam,
                                    thread float4& tessLevelOuter, thread float2& tessLevelInner,
                                    thread float4& tessOuterLo, thread float4& tessOuterHi)
    OsdGetTessLevelsLimitPoints(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cpBezier, patchParam, tessOuterLo, tessOuterHi);
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
void
OsdGetTessLevels(const float OsdTessLevel, const float4x4 OsdProjectionMatrix, const float4x4 OsdModelViewMatrix,
                 float3 cp0, float3 cp1, float3 cp2, float3 cp3,
                 int3 patchParam,
                 thread float4& tessLevelOuter, thread float2& tessLevelInner)
    float4 tessOuterLo = float4(0,0,0,0);
    float4 tessOuterHi = float4(0,0,0,0);
    cp0 = mul(OsdModelViewMatrix, float4(cp0, 1.0)).xyz;
    cp1 = mul(OsdModelViewMatrix, float4(cp1, 1.0)).xyz;
    cp2 = mul(OsdModelViewMatrix, float4(cp2, 1.0)).xyz;
    cp3 = mul(OsdModelViewMatrix, float4(cp3, 1.0)).xyz;
#if OSD_ENABLE_SCREENSPACE_TESSELLATION
    tessOuterLo[0] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp1);
    tessOuterLo[1] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp0, cp3);
    tessOuterLo[2] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp2, cp3);
    tessOuterLo[3] = OsdComputeTessLevel(OsdTessLevel, OsdProjectionMatrix, OsdModelViewMatrix, cp1, cp2);
    tessOuterHi = float4(0,0,0,0);
#else //OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdGetTessLevelsUniform(OsdTessLevel, patchParam, tessOuterLo, tessOuterHi);
#endif //OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdComputeTessLevels(tessOuterLo, tessOuterHi,
                         tessLevelOuter, tessLevelInner);
#if OSD_FRACTIONAL_EVEN_SPACING || OSD_FRACTIONAL_ODD_SPACING
float
OsdGetTessFractionalSplit(float t, float level, float levelUp)
    // Fractional tessellation of an edge will produce n segments where n
    // is the tessellation level of the edge (level) rounded up to the
    // nearest even or odd integer (levelUp). There will be n-2 segments of
    // equal length (dx1) and two additional segments of equal length (dx0)
    // that are typically shorter than the other segments. The two additional
    // segments should be placed symmetrically on opposite sides of the
    // edge (offset).
#if OSD_FRACTIONAL_EVEN_SPACING
    if (level <= 2) return t;
    float base = pow(2.0,floor(log2(levelUp)));
    float offset = 1.0/(int(2*base-levelUp)/2 & int(base/2-1));
#elif OSD_FRACTIONAL_ODD_SPACING
    if (level <= 1) return t;
    float base = pow(2.0,floor(log2(levelUp)));
    float offset = 1.0/(((int(2*base-levelUp)/2+1) & int(base/2-1))+1);
#endif //OSD_FRACTIONAL_ODD_SPACING
    float dx0 = (1.0 - (levelUp-level)/2) / levelUp;
    float dx1 = (1.0 - 2.0*dx0) / (levelUp - 2.0*ceil(dx0));
    if (t < 0.5) {
        float x = levelUp/2 - round(t*levelUp);
        return 0.5 - (x*dx1 + int(x*offset > 1) * (dx0 - dx1));
    } else if (t > 0.5) {
        float x = round(t*levelUp) - levelUp/2;
        return 0.5 + (x*dx1 + int(x*offset > 1) * (dx0 - dx1));
    } else {
        return t;
    }
#endif //OSD_FRACTIONAL_EVEN_SPACING || OSD_FRACTIONAL_ODD_SPACING
float
OsdGetTessTransitionSplit(float t, float lo, float hi )
#if OSD_FRACTIONAL_EVEN_SPACING
  float loRoundUp = OsdRoundUpEven(lo);
  float hiRoundUp = OsdRoundUpEven(hi);
  // Convert the parametric t into a segment index along the combined edge.
  float ti = round(t * (loRoundUp + hiRoundUp));
  if (ti <= loRoundUp) {
      float t0 = ti / loRoundUp;
      return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;
   } else {
      float t1 = (ti - loRoundUp) / hiRoundUp;
      return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;
    }
#elif OSD_FRACTIONAL_ODD_SPACING
  float loRoundUp = OsdRoundUpOdd(lo);
  float hiRoundUp = OsdRoundUpOdd(hi);
  // Convert the parametric t into a segment index along the combined edge.
  // The +1 below is to account for the extra segment produced by the
  // tessellator since the sum of two odd tess levels will be rounded
  // up by one to the next odd integer tess level.
  float ti = (t * (loRoundUp + hiRoundUp + 1));
  OSD_UV_CORRECTION
  ti = round(ti);
  if (ti <= loRoundUp) {
      float t0 = ti / loRoundUp;
      return OsdGetTessFractionalSplit(t0, lo, loRoundUp) * 0.5;
  } else if (ti > (loRoundUp+1)) {
      float t1 = (ti - (loRoundUp+1)) / hiRoundUp;
      return OsdGetTessFractionalSplit(t1, hi, hiRoundUp) * 0.5 + 0.5;
  } else {
      return 0.5;
#else //OSD_FRACTIONAL_ODD_SPACING
  // Convert the parametric t into a segment index along the combined edge.
  float ti = round(t * (lo + hi));
  if (ti <= lo) {
      return (ti / lo) * 0.5;
  } else {
      return ((ti - lo) / hi) * 0.5 + 0.5;
#endif //OSD_FRACTIONAL_ODD_SPACING
float2
OsdGetTessParameterization(float2 uv, float4 tessOuterLo, float4 tessOuterHi)
    float2 UV = uv;
if (UV.x == 0 && tessOuterHi[0] > 0)
UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[0], tessOuterHi[0]);
else if (UV.y == 0 && tessOuterHi[1] > 0)
UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[1], tessOuterHi[1]);
else if (UV.x == 1 && tessOuterHi[2] > 0)
UV.y = OsdGetTessTransitionSplit(UV.y, tessOuterLo[2], tessOuterHi[2]);
else if (UV.y == 1 && tessOuterHi[3] > 0)
UV.x = OsdGetTessTransitionSplit(UV.x, tessOuterLo[3], tessOuterHi[3]);
    return UV;
int4 OsdGetPatchCoord(int3 patchParam)
    int faceId = OsdGetPatchFaceId(patchParam);
    int faceLevel = OsdGetPatchFaceLevel(patchParam);
    int2 faceUV = OsdGetPatchFaceUV(patchParam);
    return int4(faceUV.x, faceUV.y, faceLevel, faceId);
float4 OsdInterpolatePatchCoord(float2 localUV, int3 patchParam)
    int4 perPrimPatchCoord = OsdGetPatchCoord(patchParam);
    int faceId = perPrimPatchCoord.w;
    int faceLevel = perPrimPatchCoord.z;
    float2 faceUV = float2(perPrimPatchCoord.x, perPrimPatchCoord.y);
    float2 uv = localUV/faceLevel + faceUV/faceLevel;
    // add 0.5 to integer values for more robust interpolation
    return float4(uv.x, uv.y, faceLevel+0.5, faceId+0.5);
// ----------------------------------------------------------------------------
// GregoryBasis
// ----------------------------------------------------------------------------
void
OsdComputePerPatchVertexGregoryBasis(int3 patchParam, int ID, float3 cv,
                                     device OsdPerPatchVertexGregoryBasis& result)
    result.P = cv;
// Regular BSpline to Bezier
constant float4x4 Q(
                    float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),
                    float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),
                    float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),
                    float4(0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f)
                    );
// Infinitely Sharp (boundary)
constant float4x4 Mi(
                     float4(1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f),
                     float4(0.f,     4.f/6.f, 2.f/6.f, 0.f),
                     float4(0.f,     2.f/6.f, 4.f/6.f, 0.f),
                     float4(0.f,     0.f,     1.f,     0.f)
                     );
    
float4x4 OsdComputeMs2(float sharpness, float factor)
    float s = exp2(sharpness);
    float s2 = s*s;
    float s3 = s2*s;
    float sx6 = s*6.0;
    float sx6m2 = sx6 - 2;
    float sfrac1 = 1-s;
    float ssub1 = s-1;
    float ssub1_2 = ssub1 * ssub1;
    float div6 = 1.0/6.0;
    
    float4x4 m(
               float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3,    sfrac1 * ssub1_2),
               float4(0,      1 + 2*s + s2,         sx6m2 - 2*s2,             ssub1_2),
               float4(0,               1+s,                sx6m2,              sfrac1),
               float4(0,                 1,                sx6m2,                 1));
    
    m *= factor * (1/sx6);
    
    m[0][0] = div6 * factor;
    
    return m;
// ----------------------------------------------------------------------------
// BSpline
// ----------------------------------------------------------------------------
// convert BSpline cv to Bezier cv
template<typename VertexType> //VertexType should be some type that implements float3 VertexType::GetPosition()
void OsdComputePerPatchVertexBSpline(int3 patchParam, unsigned ID, threadgroup VertexType* cv, device OsdPerPatchVertexBezier& result)
    int i = ID%4;
    int j = ID/4;
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    float3 P  = float3(0,0,0); // 0 to 1-2^(-Sf)
    float3 P1 = float3(0,0,0); // 1-2^(-Sf) to 1-2^(-Sc)
    float3 P2 = float3(0,0,0); // 1-2^(-Sc) to 1
    float sharpness = OsdGetPatchSharpness(patchParam);
    int boundaryMask = OsdGetPatchBoundaryMask(patchParam);
    if (sharpness > 0 && (boundaryMask & 15))
    {
        float Sf = floor(sharpness);
        float Sc = ceil(sharpness);
        float Sr = fract(sharpness);
        float4x4 Mj = OsdComputeMs2(Sf, 1-Sr);
        float4x4 Ms = Mj;
        Mj += (Sr * Mi);
        Ms += OsdComputeMs2(Sc, Sr);
#if USE_PTVS_SHARPNESS
#else
        float s0 = 1 - exp2(-Sf);
        float s1 = 1 - exp2(-Sc);
        result.vSegments = float2(s0, s1);
#endif
        
        bool isBoundary[2];
        isBoundary[0] = (((boundaryMask & 8) != 0) || ((boundaryMask & 2) != 0)) ? true : false;
        isBoundary[1] = (((boundaryMask & 4) != 0) || ((boundaryMask & 1) != 0)) ? true : false;
        bool needsFlip[2];
        needsFlip[0] = (boundaryMask & 8) ? true : false;
        needsFlip[1] = (boundaryMask & 1) ? true : false;
        float3 Hi[4], Hj[4], Hs[4];
        
        if (isBoundary[0])
        {
            int t[4] = {0,1,2,3};
            int ti = i, step = 1, start = 0;
            if (needsFlip[0]) {
                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;
                ti = 3-i;
                start = 3; step = -1;
            }
            for (int l=0; l<4; ++l) {
                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);
                for (int k=0, tk = start; k<4; ++k, tk+=step) {
                    float3 p = cv[l*4 + k].GetPosition();
                    Hi[l] += Mi[ti][tk] * p;
                    Hj[l] += Mj[ti][tk] * p;
                    Hs[l] += Ms[ti][tk] * p;
                }
            }
        }
        else
        {
            for (int l=0; l<4; ++l) {
                Hi[l] = Hj[l] = Hs[l] = float3(0,0,0);
                for (int k=0; k<4; ++k) {
                    float3 p = cv[l*4 + k].GetPosition();
                    float3 val = Q[i][k] * p;
                    Hi[l] += val;
                    Hj[l] += val;
                    Hs[l] += val;
                }
            }
        }
        {
            int t[4] = {0,1,2,3};
            int tj = j, step = 1, start = 0;
            if (needsFlip[1]) {
                t[0] = 3; t[1] = 2; t[2] = 1; t[3] = 0;
                tj = 3-j;
                start = 3; step = -1;
            }
            for (int k=0, tk = start; k<4; ++k, tk+=step) {
                if (isBoundary[1])
                {
                    P  += Mi[tj][tk]*Hi[k];
                    P1 += Mj[tj][tk]*Hj[k];
                    P2 += Ms[tj][tk]*Hs[k];
                }
                else
                {
                    P  += Q[j][k]*Hi[k];
                    P1 += Q[j][k]*Hj[k];
                    P2 += Q[j][k]*Hs[k];
                }
            }
        }
    result.P  = P;
    result.P1 = P1;
    result.P2 = P2;
    } else {
#if USE_PTVS_SHARPNESS
#else
        result.vSegments = float2(0, 0);
#endif
        OsdComputeBSplineBoundaryPoints(cv, patchParam);
    float3 Hi[4];
    for (int l=0; l<4; ++l) {
        Hi[l] = float3(0,0,0);
        for (int k=0; k<4; ++k) {
            Hi[l] += Q[i][k] * cv[l*4 + k].GetPosition();
        }
    }
    for (int k=0; k<4; ++k) {
        P += Q[j][k]*Hi[k];
    }
        
    result.P  = P;
    result.P1 = P;
    result.P2 = P;
#else
    OsdComputeBSplineBoundaryPoints(cv, patchParam);
    float3 H[4];
    for (int l=0; l<4; ++l) {
        H[l] = float3(0,0,0);
        for(int k=0; k<4; ++k) {
            H[l] += Q[i][k] * (cv + l*4 + k)->GetPosition();
        }
    }
    {
        result.P = float3(0,0,0);
        for (int k=0; k<4; ++k){
            result.P += Q[j][k]*H[k];
        }
    }
#endif
template<typename PerPatchVertexBezier>
void
OsdEvalPatchBezier(int3 patchParam, float2 UV,
                   PerPatchVertexBezier cv,
                   thread float3& P, thread float3& dPu, thread float3& dPv,
                   thread float3& N, thread float3& dNu, thread float3& dNv,
                   thread float2& vSegments)
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    float B[4], D[4], C[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    CUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D, C);
#else
    float B[4], D[4];
    float3 BUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)},
    DUCP[4] = {float3(0,0,0),float3(0,0,0),float3(0,0,0),float3(0,0,0)};
    OsdUnivar4x4(UV.x, B, D);
#endif
    // ----------------------------------------------------------------
#if OSD_PATCH_ENABLE_SINGLE_CREASE
#if USE_PTVS_SHARPNESS
    float sharpness = OsdGetPatchSharpness(patchParam);
    float Sf = floor(sharpness);
    float Sc = ceil(sharpness);
    float s0 = 1 - exp2(-Sf);
    float s1 = 1 - exp2(-Sc);
    vSegments = float2(s0, s1);
#else //USE_PTVS_SHARPNESS
    vSegments = cv[0].vSegments;
#endif //USE_PTVS_SHARPNESS
    float s = OsdGetPatchSingleCreaseSegmentParameter(patchParam, UV);
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            int k = 4*i + j;
            float3 A = (s <= vSegments.x) ? cv[k].P
            :   ((s <= vSegments.y) ? cv[k].P1
                 : cv[k].P2);
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
#if OSD_COMPUTE_NORMAL_DERIVATIVES
            CUCP[i] += A * C[j];
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
        }
    }
#else //OSD_PATCH_ENABLE_SINGLE_CREASE
    // ----------------------------------------------------------------
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            float3 A = cv[4*i + j].P;
            BUCP[i] += A * B[j];
            DUCP[i] += A * D[j];
#if OSD_COMPUTE_NORMAL_DERIVATIVES
            CUCP[i] += A * C[j];
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
        }
    }
#endif //OSD_PATCH_ENABLE_SINGLE_CREASE
    // ----------------------------------------------------------------
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    // used for weingarten term
    OsdUnivar4x4(UV.y, B, D, C);
    P = B[0] * BUCP[0];
    dPu = B[0] * DUCP[0];
    dPv = D[0] * BUCP[0];
    float3 dUU = B[0] * CUCP[0];
    float3 dVV = C[0] * BUCP[0];
    float3 dUV = D[0] * DUCP[0];
    for (int k=1; k<4; ++k) {
        P   += B[k] * BUCP[k];
        dPu += B[k] * DUCP[k];
        dPv += D[k] * BUCP[k];
        dUU += B[k] * CUCP[k];
        dVV += C[k] * BUCP[k];
        dUV += D[k] * DUCP[k];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    dUU *= 6 * level;
    dVV *= 6 * level;
    dUV *= 9 * level;
    float3 n = cross(dPu, dPv);
    float ln = 1.0 / length(n);
    N = ln * n;
    float E = dot(dPu, dPu);
    float F = dot(dPu, dPv);
    float G = dot(dPv, dPv);
    float e = dot(N, dUU);
    float f = dot(N, dUV);
    float g = dot(N, dVV);
    float EGFF = 1.0 / (E*G - F*F);
    dNu = (f*F-e*G) * EGFF * dPu + (e*F-f*E) * EGFF * dPv;
    dNv = (g*F-f*G) * EGFF * dPu + (f*F-g*E) * EGFF * dPv;
    float powrn = 1.0 / powr(dot(n,n), 1.5);
    dNu = dNu * ln - n * (dot(dNu,n) * powrn);
    dNv = dNv * ln - n * (dot(dNv,n) * powrn);
#else //OSD_COMPUTE_NORMAL_DERIVATIVES
    OsdUnivar4x4(UV.y, B, D);
    P = B[0] * BUCP[0];
    dPu = B[0] * DUCP[0];
    dPv = D[0] * BUCP[0];
    for (int k=1; k<4; ++k) {
        P   += B[k] * BUCP[k];
        dPu += B[k] * DUCP[k];
        dPv += D[k] * BUCP[k];
    }
    int level = OsdGetPatchFaceLevel(patchParam);
    dPu *= 3 * level;
    dPv *= 3 * level;
    N = normalize(cross(dPu, dPv));
    dNu = float3(0,0,0);
    dNv = float3(0,0,0);
#endif //OSD_COMPUTE_NORMAL_DERIVATIVES
// compute single-crease patch matrix
float4x4 OsdComputeMs(float sharpness)
    float s = exp2(sharpness);
    float s2 = s*s;
    float s3 = s2*s;
    float4x4 m(
        float4(0, s + 1 + 3*s2 - s3, 7*s - 2 - 6*s2 + 2*s3, (1-s)*(s-1)*(s-1)),
        float4(0,       (1+s)*(1+s),        6*s - 2 - 2*s2,       (s-1)*(s-1)),
        float4(0,               1+s,               6*s - 2,               1-s),
        float4(0,                 1,               6*s - 2,                 1));
    m[0] /= (s*6.0);
    m[1] /= (s*6.0);
    m[2] /= (s*6.0);
    m[3] /= (s*6.0);
    m[0][0] = 1.0/6.0;
    return m;
// flip matrix orientation
float4x4 OsdFlipMatrix(float4x4 m)
    return float4x4(float4(m[3][3], m[3][2], m[3][1], m[3][0]),
                    float4(m[2][3], m[2][2], m[2][1], m[2][0]),
                    float4(m[1][3], m[1][2], m[1][1], m[1][0]),
                    float4(m[0][3], m[0][2], m[0][1], m[0][0]));
void OsdFlipMatrix(threadgroup float * src, threadgroup float * dst)
    for (int i = 0; i < 16; i++) dst[i] = src[15-i];
// ----------------------------------------------------------------------------
// Legacy Gregory
// ----------------------------------------------------------------------------
#if OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
#if OSD_MAX_VALENCE<=10
constant float ef[7] = {
    0.813008, 0.500000, 0.363636, 0.287505,
    0.238692, 0.204549, 0.179211
#else
constant float ef[27] = {
    0.812816, 0.500000, 0.363644, 0.287514,
    0.238688, 0.204544, 0.179229, 0.159657,
    0.144042, 0.131276, 0.120632, 0.111614,
    0.103872, 0.09715, 0.0912559, 0.0860444,
    0.0814022, 0.0772401, 0.0734867, 0.0700842,
    0.0669851, 0.0641504, 0.0615475, 0.0591488,
    0.0569311, 0.0548745, 0.0529621
#endif
float cosfn(int n, int j) {
    return cospi((2.0f * j)/float(n));
float sinfn(int n, int j) {
    return sinpi((2.0f * j)/float(n));
#ifndef OSD_MAX_VALENCE
#define OSD_MAX_VALENCE 4
#endif
template<typename OsdVertexBuffer>
float3 OsdReadVertex(int vertexIndex, OsdVertexBuffer osdVertexBuffer)
    int index = (vertexIndex /*+ OsdBaseVertex()*/);
    return osdVertexBuffer[index].position;
template<typename OsdValenceBuffer>
int OsdReadVertexValence(int vertexID, OsdValenceBuffer osdValenceBuffer)
    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1));
    return osdValenceBuffer[index];
template<typename OsdValenceBuffer>
int OsdReadVertexIndex(int vertexID, int valenceVertex, OsdValenceBuffer osdValenceBuffer)
    int index = int(vertexID * (2 * OSD_MAX_VALENCE + 1) + 1 + valenceVertex);
    return osdValenceBuffer[index];
template<typename OsdQuadOffsetBuffer>
int OsdReadQuadOffset(int primitiveID, int offsetVertex, OsdQuadOffsetBuffer osdQuadOffsetBuffer)
    int index = int(4*primitiveID + offsetVertex);
    return osdQuadOffsetBuffer[index];
void OsdComputePerVertexGregory(unsigned vID, float3 P, threadgroup OsdPerVertexGregory& v, OsdPatchParamBufferSet osdBuffers)
    v.clipFlag = short3(0,0,0);
    int ivalence = OsdReadVertexValence(vID, osdBuffers.valenceBuffer);
    v.valence = ivalence;
    int valence = abs(ivalence);
    float3 f[OSD_MAX_VALENCE];
    float3 pos = P;
    float3 opos = float3(0,0,0);
#if OSD_PATCH_GREGORY_BOUNDARY
    v.org = pos;
    int boundaryEdgeNeighbors[2];
    int currNeighbor = 0;
    int ibefore = 0;
    int zerothNeighbor = 0;
#endif
    for (int i=0; i<valence; ++i) {
        int im = (i+valence-1)%valence;
        int ip = (i+1)%valence;
        int idx_neighbor = OsdReadVertexIndex(vID, 2*i, osdBuffers.valenceBuffer);
#if OSD_PATCH_GREGORY_BOUNDARY
        bool isBoundaryNeighbor = false;
        int valenceNeighbor = OsdReadVertexValence(idx_neighbor, osdBuffers.valenceBuffer);
        if (valenceNeighbor < 0) {
            isBoundaryNeighbor = true;
            if (currNeighbor<2) {
                boundaryEdgeNeighbors[currNeighbor] = idx_neighbor;
            }
            currNeighbor++;
            if (currNeighbor == 1) {
                ibefore = i;
                zerothNeighbor = i;
            } else {
                if (i-ibefore == 1) {
                    int tmp = boundaryEdgeNeighbors[0];
                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];
                    boundaryEdgeNeighbors[1] = tmp;
                    zerothNeighbor = i;
                }
            }
        }
#endif
        float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);
        int idx_diagonal = OsdReadVertexIndex(vID, 2*i + 1, osdBuffers.valenceBuffer);
        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
        int idx_neighbor_p = OsdReadVertexIndex(vID, 2*ip, osdBuffers.valenceBuffer);
        float3 neighbor_p = OsdReadVertex(idx_neighbor_p, osdBuffers.vertexBuffer);
        int idx_neighbor_m = OsdReadVertexIndex(vID, 2*im, osdBuffers.valenceBuffer);
        float3 neighbor_m = OsdReadVertex(idx_neighbor_m, osdBuffers.vertexBuffer);
        int idx_diagonal_m = OsdReadVertexIndex(vID, 2*im + 1, osdBuffers.valenceBuffer);
        float3 diagonal_m = OsdReadVertex(idx_diagonal_m, osdBuffers.vertexBuffer);
        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);
        opos += f[i];
        v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;
    }
    opos /= valence;
    v.P = float4(opos, 1.0f).xyz;
    float3 e;
    v.e0 = float3(0,0,0);
    v.e1 = float3(0,0,0);
    for(int i=0; i<valence; ++i) {
        int im = (i + valence -1) % valence;
        e = 0.5f * (f[i] + f[im]);
        v.e0 += cosfn(valence, i)*e;
        v.e1 += sinfn(valence, i)*e;
    }
    v.e0 *= ef[valence - 3];
    v.e1 *= ef[valence - 3];
#if OSD_PATCH_GREGORY_BOUNDARY
    v.zerothNeighbor = zerothNeighbor;
    if (currNeighbor == 1) {
        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];
    }
    if (ivalence < 0) {
        if (valence > 2) {
            v.P = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +
                   OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +
                   4.0f * pos)/6.0f;
        } else {
            v.P = pos;
        }
        v.e0 = (OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) -
                OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer))/6.0;
        float k = float(float(valence) - 1.0f);    //k is the number of faces
        float c = cospi(1.0/k);
        float s = sinpi(1.0/k);
        float gamma = -(4.0f*s)/(3.0f*k+c);
        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));
        float beta_0 = s/(3.0f*k + c);
        int idx_diagonal = OsdReadVertexIndex(vID, 2*zerothNeighbor + 1, osdBuffers.valenceBuffer);
        float3 diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
        v.e1 = gamma * pos +
            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[0], osdBuffers.vertexBuffer) +
            alpha_0k * OsdReadVertex(boundaryEdgeNeighbors[1], osdBuffers.vertexBuffer) +
            beta_0 * diagonal;
        for (int x=1; x<valence - 1; ++x) {
            int curri = ((x + zerothNeighbor)%valence);
            float alpha = (4.0f*sinpi((float(x))/k))/(3.0f*k+c);
            float beta = (sinpi((float(x))/k) + sinpi((float(x+1))/k))/(3.0f*k+c);
            int idx_neighbor = OsdReadVertexIndex(vID, 2*curri, osdBuffers.valenceBuffer);
            float3 neighbor = OsdReadVertex(idx_neighbor, osdBuffers.vertexBuffer);
            idx_diagonal = OsdReadVertexIndex(vID, 2*curri + 1, osdBuffers.valenceBuffer);
            diagonal = OsdReadVertex(idx_diagonal, osdBuffers.vertexBuffer);
            v.e1 += alpha * neighbor + beta * diagonal;
        }
        v.e1 /= 3.0f;
    }
#endif
void
OsdComputePerPatchVertexGregory(int3 patchParam, unsigned ID, unsigned primitiveID,
                                threadgroup OsdPerVertexGregory* v,
                                device OsdPerPatchVertexGregory& result,
                                OsdPatchParamBufferSet osdBuffers)
    result.P = v[ID].P;
    int i = ID;
    int ip = (i+1)%4;
    int im = (i+3)%4;
    int valence = abs(v[i].valence);
    int n = valence;
    int start = OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) & 0xff;
    int prev = (OsdReadQuadOffset(primitiveID, i, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;
    int start_m = OsdReadQuadOffset(primitiveID, im, osdBuffers.quadOffsetBuffer) & 0xff;
    int prev_p = (OsdReadQuadOffset(primitiveID, ip, osdBuffers.quadOffsetBuffer) >> 8) & 0xff;
    int np = abs(v[ip].valence);
    int nm = abs(v[im].valence);
    // Control Vertices based on :
    // "Approximating Subdivision Surfaces with Gregory Patches
    //  for Hardware Tessellation"
    // Loop, Schaefer, Ni, Castano (ACM ToG Siggraph Asia 2009)
    //
    //  P3         e3-      e2+         P2
    //     O--------O--------O--------O
    //     |        |        |        |
    //     |        |        |        |
    //     |        | f3-    | f2+    |
    //     |        O        O        |
    // e3+ O------O            O------O e2-
    //     |     f3+          f2-     |
    //     |                          |
    //     |                          |
    //     |      f0-         f1+     |
    // e0- O------O            O------O e1+
    //     |        O        O        |
    //     |        | f0+    | f1-    |
    //     |        |        |        |
    //     |        |        |        |
    //     O--------O--------O--------O
    //  P0         e0+      e1-         P1
    //
#if OSD_PATCH_GREGORY_BOUNDARY
    float3 Em_ip;
    if (v[ip].valence < -2) {
        int j = (np + prev_p - v[ip].zerothNeighbor) % np;
        Em_ip = v[ip].P + cospi(j/float(np-1))*v[ip].e0 + sinpi(j/float(np-1))*v[ip].e1;
    } else {
        Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);
    }
    float3 Ep_im;
    if (v[im].valence < -2) {
        int j = (nm + start_m - v[im].zerothNeighbor) % nm;
        Ep_im = v[im].P + cospi(j/float(nm-1))*v[im].e0 + sinpi(j/float(nm-1))*v[im].e1;
    } else {
        Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);
    }
    if (v[i].valence < 0) {
        n = (n-1)*2;
    }
    if (v[im].valence < 0) {
        nm = (nm-1)*2;
    }
    if (v[ip].valence < 0) {
        np = (np-1)*2;
    }
    if (v[i].valence > 2) {
        result.Ep = v[i].P + (v[i].e0*cosfn(n, start) + v[i].e1*sinfn(n, start));
        result.Em = v[i].P + (v[i].e0*cosfn(n, prev) +  v[i].e1*sinfn(n, prev));
        float s1=3-2*cosfn(n,1)-cosfn(np,1);
        float s2=2*cosfn(n,1);
        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
    } else if (v[i].valence < -2) {
        int j = (valence + start - v[i].zerothNeighbor) % valence;
        result.Ep = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;
        j = (valence + prev - v[i].zerothNeighbor) % valence;
        result.Em = v[i].P + cospi(j/float(valence-1))*v[i].e0 + sinpi(j/float(valence-1))*v[i].e1;
        float3 Rp = ((-2.0f * v[i].org - 1.0f * v[im].org) + (2.0f * v[ip].org + 1.0f * v[(i+2)%4].org))/3.0f;
        float3 Rm = ((-2.0f * v[i].org - 1.0f * v[ip].org) + (2.0f * v[im].org + 1.0f * v[(i+2)%4].org))/3.0f;
        float s1 = 3-2*cosfn(n,1)-cosfn(np,1);
        float s2 = 2*cosfn(n,1);
        result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
        result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
        if (v[im].valence < 0) {
            s1 = 3-2*cosfn(n,1)-cosfn(np,1);
            result.Fp = result.Fm = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
        } else if (v[ip].valence < 0) {
            s1 = 3.0f-2.0f*cospi(2.0f/n)-cospi(2.0f/nm);
            result.Fm = result.Fp = (cosfn(nm,1)*v[i].P + s1*result.Em + s2*Ep_im - v[i].r[prev])/3.0f;
        }
    } else if (v[i].valence == -2) {
        result.Ep = (2.0f * v[i].org + v[ip].org)/3.0f;
        result.Em = (2.0f * v[i].org + v[im].org)/3.0f;
        result.Fp = result.Fm = (4.0f * v[i].org + v[(i+2)%n].org + 2.0f * v[ip].org + 2.0f * v[im].org)/9.0f;
    }
#else // not OSD_PATCH_GREGORY_BOUNDARY
    result.Ep = v[i].P + v[i].e0 * cosfn(n, start) + v[i].e1*sinfn(n, start);
    result.Em = v[i].P + v[i].e0 * cosfn(n, prev ) + v[i].e1*sinfn(n, prev );
    float3 Em_ip = v[ip].P + v[ip].e0*cosfn(np, prev_p) + v[ip].e1*sinfn(np, prev_p);
    float3 Ep_im = v[im].P + v[im].e0*cosfn(nm, start_m) + v[im].e1*sinfn(nm, start_m);
    float s1 = 3-2*cosfn(n,1)-cosfn(np,1);
    float s2 = 2*cosfn(n,1);
    result.Fp = (cosfn(np,1)*v[i].P + s1*result.Ep + s2*Em_ip + v[i].r[start])/3.0f;
    s1 = 3.0f-2.0f*cospi(2.0f/float(n))-cospi(2.0f/float(nm));
    result.Fm = (cosfn(nm,1)*v[i].P + s1*result.Em +s2*Ep_im - v[i].r[prev])/3.0f;
#endif
#endif  // OSD_PATCH_GREGORY || OSD_PATCH_GREGORY_BOUNDARY
//   Copyright 2016 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
#ifndef OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H
#define OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H
#if defined(OSD_PATCH_BASIS_GLSL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT out
    #define OSD_INOUT inout
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             elementType[](a0,a1,a2,a3,a4,a5,a6,a7)
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             elementType[](a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
#elif defined(OSD_PATCH_BASIS_HLSL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT out
    #define OSD_INOUT inout
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_CUDA)
    #define OSD_FUNCTION_STORAGE_CLASS __device__
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_OPENCL)
    #define OSD_FUNCTION_STORAGE_CLASS static
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#elif defined(OSD_PATCH_BASIS_METAL)
    #define OSD_FUNCTION_STORAGE_CLASS
    #define OSD_DATA_STORAGE_CLASS
    #define OSD_OPTIONAL(a) true
    #define OSD_OPTIONAL_INIT(a,b) b
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) thread elementType* identifier
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#else
    #define OSD_FUNCTION_STORAGE_CLASS static inline
    #define OSD_DATA_STORAGE_CLASS static
    #define OSD_OPTIONAL(a) (a)
    #define OSD_OPTIONAL_INIT(a,b) (a ? b : 0)
    #define OSD_OUT
    #define OSD_INOUT
    #define OSD_TYPE_ARRAY(elementType, identifier, arraySize) elementType identifier[arraySize]
    #define OSD_ARRAY_8(elementType,a0,a1,a2,a3,a4,a5,a6,a7)             {a0,a1,a2,a3,a4,a5,a6,a7}
    #define OSD_ARRAY_12(elementType,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)             {a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11}
#endif
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBezierWeights(
    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {
    // The four uniform cubic Bezier basis functions (in terms of t and its
    // complement tC) evaluated at t:
    float t2 = t*t;
    float tC = 1.0f - t;
    float tC2 = tC * tC;
    wP[0] = tC2 * tC;
    wP[1] = tC2 * t * 3.0f;
    wP[2] = t2 * tC * 3.0f;
    wP[3] = t2 * t;
    // Derivatives of the above four basis functions at t:
    if (OSD_OPTIONAL(wDP)) {
       wDP[0] = -3.0f * tC2;
       wDP[1] =  9.0f * t2 - 12.0f * t + 3.0f;
       wDP[2] = -9.0f * t2 +  6.0f * t;
       wDP[3] =  3.0f * t2;
    }
    // Second derivatives of the basis functions at t:
    if (OSD_OPTIONAL(wDP2)) {
        wDP2[0] =   6.0f * tC;
        wDP2[1] =  18.0f * t - 12.0f;
        wDP2[2] = -18.0f * t +  6.0f;
        wDP2[3] =   6.0f * t;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBSplineWeights(
    float t, OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDP2, 4)) {
    // The four uniform cubic B-Spline basis functions evaluated at t:
    const float one6th = 1.0f / 6.0f;
    float t2 = t * t;
    float t3 = t * t2;
    wP[0] = one6th * (1.0f - 3.0f*(t -      t2) -      t3);
    wP[1] = one6th * (4.0f           - 6.0f*t2  + 3.0f*t3);
    wP[2] = one6th * (1.0f + 3.0f*(t +      t2  -      t3));
    wP[3] = one6th * (                                 t3);
    // Derivatives of the above four basis functions at t:
    if (OSD_OPTIONAL(wDP)) {
        wDP[0] = -0.5f*t2 +      t - 0.5f;
        wDP[1] =  1.5f*t2 - 2.0f*t;
        wDP[2] = -1.5f*t2 +      t + 0.5f;
        wDP[3] =  0.5f*t2;
    }
    // Second derivatives of the basis functions at t:
    if (OSD_OPTIONAL(wDP2)) {
        wDP2[0] = -       t + 1.0f;
        wDP2[1] =  3.0f * t - 2.0f;
        wDP2[2] = -3.0f * t + 1.0f;
        wDP2[3] =         t;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBoxSplineWeights(float v, float w, OSD_TYPE_ARRAY(OSD_OUT float, wP, 12)) {
    float u = 1.0f - v - w;
    //
    //  The 12 basis functions of the quartic box spline (unscaled by their common
    //  factor of 1/12 until later, and formatted to make it easy to spot any
    //  typing errors):
    //
    //      15 terms for the 3 points above the triangle corners
    //       9 terms for the 3 points on faces opposite the triangle edges
    //       2 terms for the 6 points on faces opposite the triangle corners
    //
    //  Powers of each variable for notational convenience:
    float u2 = u*u;
    float u3 = u*u2;
    float u4 = u*u3;
    float v2 = v*v;
    float v3 = v*v2;
    float v4 = v*v3;
    float w2 = w*w;
    float w3 = w*w2;
    float w4 = w*w3;
    //  And now the basis functions:
    wP[ 0] = u4 + 2.0f*u3*v;
    wP[ 1] = u4 + 2.0f*u3*w;
    wP[ 8] = w4 + 2.0f*w3*u;
    wP[11] = w4 + 2.0f*w3*v;
    wP[ 9] = v4 + 2.0f*v3*w;
    wP[ 5] = v4 + 2.0f*v3*u;
    wP[ 2] = u4 + 2.0f*u3*w + 6.0f*u3*v + 6.0f*u2*v*w + 12.0f*u2*v2 +
                v4 + 2.0f*v3*w + 6.0f*v3*u + 6.0f*v2*u*w;
    wP[ 4] = w4 + 2.0f*w3*v + 6.0f*w3*u + 6.0f*w2*u*v + 12.0f*w2*u2 +
                u4 + 2.0f*u3*v + 6.0f*u3*w + 6.0f*u2*v*w;
    wP[10] = v4 + 2.0f*v3*u + 6.0f*v3*w + 6.0f*v2*w*u + 12.0f*v2*w2 +
                w4 + 2.0f*w3*u + 6.0f*w3*v + 6.0f*w3*u*v;
    wP[ 3] = v4 + 6*v3*w + 8*v3*u + 36*v2*w*u + 24*v2*u2 + 24*v*u3 +
                w4 + 6*w3*v + 8*w3*u + 36*w2*v*u + 24*w2*u2 + 24*w*u3 + 6*u4 + 60*u2*v*w + 12*v2*w2;
    wP[ 6] = w4 + 6*w3*u + 8*w3*v + 36*w2*u*v + 24*w2*v2 + 24*w*v3 +
                u4 + 6*u3*w + 8*u3*v + 36*u2*v*w + 24*u2*v2 + 24*u*v3 + 6*v4 + 60*v2*w*u + 12*w2*u2;
    wP[ 7] = u4 + 6*u3*v + 8*u3*w + 36*u2*v*w + 24*u2*w2 + 24*u*w3 +
                v4 + 6*v3*u + 8*v3*w + 36*v2*u*w + 24*v2*w2 + 24*v*w3 + 6*w4 + 60*w2*u*v + 12*u2*v2;
    for (int i = 0; i < 12; ++i) {
        wP[i] *= 1.0f / 12.0f;
    }
OSD_FUNCTION_STORAGE_CLASS
void
OsdGetBilinearPatchWeights(
        float s, float t, float dScale,
        OSD_TYPE_ARRAY(OSD_OUT float, wP, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 4),
        OSD_TYPE_ARRAY(OSD_OUT float, wDss, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 4), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 4)) {
    float sC = 1.0f - s,
          tC = 1.0f - t;
    if (OSD_OPTIONAL(wP)) {
        wP[0] = sC * tC;
        wP[1] =  s * tC;
        wP[2] =  s * t;
        wP[3] = sC * t;
    }
    if (OSD_OPTIONAL(derivS && derivT)) {
        wDs[0] = -tC * dScale;
        wDs[1] =  tC * dScale;
        wDs[2] =   t * dScale;
        wDs[3] =  -t * dScale;
        wDt[0] = -sC * dScale;
        wDt[1] =  -s * dScale;
        wDt[2] =   s * dScale;
        wDt[3] =  sC * dScale;
        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {
            float d2Scale = dScale * dScale;
            for(int i=0;i<4;i++) {
                wDss[i] = 0;
                wDtt[i] = 0;
            }
            wDst[0] =  d2Scale;
            wDst[1] = -d2Scale;
            wDst[2] = -d2Scale;
            wDst[3] =  d2Scale;
        }
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdAdjustBoundaryWeights(
        int boundary,
        OSD_TYPE_ARRAY(OSD_INOUT float, sWeights, 4), OSD_TYPE_ARRAY(OSD_INOUT float, tWeights, 4)) {
    if ((boundary & 1) != 0) {
        tWeights[2] -= tWeights[0];
        tWeights[1] += 2*tWeights[0];
        tWeights[0] = 0;
    }
    if ((boundary & 2) != 0) {
        sWeights[1] -= sWeights[3];
        sWeights[2] += 2*sWeights[3];
        sWeights[3] = 0;
    }
    if ((boundary & 4) != 0) {
        tWeights[1] -= tWeights[3];
        tWeights[2] += 2*tWeights[3];
        tWeights[3] = 0;
    }
    if ((boundary & 8) != 0) {
        sWeights[2] -= sWeights[0];
        sWeights[1] += 2*sWeights[0];
        sWeights[0] = 0;
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdComputeTensorProductPatchWeights(float dScale, int boundary,
    OSD_TYPE_ARRAY(float, sWeights, 4), OSD_TYPE_ARRAY(float, tWeights, 4),
    OSD_TYPE_ARRAY(float, dsWeights, 4), OSD_TYPE_ARRAY(float, dtWeights, 4),
    OSD_TYPE_ARRAY(float, dssWeights, 4), OSD_TYPE_ARRAY(float, dttWeights, 4),
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {
    if (OSD_OPTIONAL(wP)) {
        // Compute the tensor product weight of the (s,t) basis function
        // corresponding to each control vertex:
        OsdAdjustBoundaryWeights(boundary, sWeights, tWeights);
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                wP[4*i+j] = sWeights[j] * tWeights[i];
            }
        }
    }
    if (OSD_OPTIONAL(derivS && derivT)) {
        // Compute the tensor product weight of the differentiated (s,t) basis
        // function corresponding to each control vertex (scaled accordingly):
        OsdAdjustBoundaryWeights(boundary, dsWeights, dtWeights);
        for (int i = 0; i < 4; ++i) {
            for (int j = 0; j < 4; ++j) {
                wDs[4*i+j] = dsWeights[j] * tWeights[i] * dScale;
                wDt[4*i+j] = sWeights[j] * dtWeights[i] * dScale;
            }
        }
        if (OSD_OPTIONAL(derivSS && derivST && derivTT)) {
            // Compute the tensor product weight of appropriate differentiated
            // (s,t) basis functions for each control vertex (scaled accordingly):
            float d2Scale = dScale * dScale;
            OsdAdjustBoundaryWeights(boundary, dssWeights, dttWeights);
            for (int i = 0; i < 4; ++i) {
                for (int j = 0; j < 4; ++j) {
                    wDss[4*i+j] = dssWeights[j] * tWeights[i] * d2Scale;
                    wDst[4*i+j] = dsWeights[j] * dtWeights[i] * d2Scale;
                    wDtt[4*i+j] = sWeights[j] * dttWeights[i] * d2Scale;
                }
            }
        }
    }
OSD_FUNCTION_STORAGE_CLASS
void OsdGetBezierPatchWeights(
    float s, float t, float dScale,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDT, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDSS, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDST, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDTT, 16)) {
    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];
    OsdGetBezierWeights(s, OSD_OPTIONAL_INIT(wP, sWeights), OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));
    OsdGetBezierWeights(t, OSD_OPTIONAL_INIT(wP, tWeights), OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));
    OsdComputeTensorProductPatchWeights(dScale, /*boundary=*/0, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDS, wDT, wDSS, wDST, wDTT);
OSD_FUNCTION_STORAGE_CLASS
void OsdGetBSplinePatchWeights(
    float s, float t, float dScale, int boundary,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 16),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 16), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 16)) {
    float sWeights[4], tWeights[4], dsWeights[4], dtWeights[4], dssWeights[4], dttWeights[4];
    OsdGetBSplineWeights(s, sWeights, OSD_OPTIONAL_INIT(wDS, dsWeights), OSD_OPTIONAL_INIT(wDSS, dssWeights));
    OsdGetBSplineWeights(t, tWeights, OSD_OPTIONAL_INIT(wDT, dtWeights), OSD_OPTIONAL_INIT(wDTT, dttWeights));
    OsdComputeTensorProductPatchWeights(dScale, boundary, sWeights, tWeights, dsWeights, dtWeights, dssWeights, dttWeights, wP, wDs, wDt, wDss, wDst, wDtt);
OSD_FUNCTION_STORAGE_CLASS
void OsdGetGregoryPatchWeights(
    float s, float t, float dScale,
    OSD_TYPE_ARRAY(OSD_OUT float, wP, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDs, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDt, 20),
    OSD_TYPE_ARRAY(OSD_OUT float, wDss, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDst, 20), OSD_TYPE_ARRAY(OSD_OUT float, wDtt, 20)) {
    //
    //  P3         e3-      e2+         P2
    //     15------17-------11--------10
    //     |        |        |        |
    //     |        |        |        |
    //     |        | f3-    | f2+    |
    //     |       19       13        |
    // e3+ 16-----18           14-----12 e2-
    //     |     f3+          f2-     |
    //     |                          |
    //     |                          |
    //     |      f0-         f1+     |
    // e0- 2------4            8------6 e1+
    //     |        3        9        |
    //     |        | f0+    | f1-    |
    //     |        |        |        |
    //     |        |        |        |
    //     O--------1--------7--------5
    //  P0         e0+      e1-         P1
    //
    //  Indices of boundary and interior points and their corresponding Bezier points
    //  (this can be reduced with more direct indexing and unrolling of loops):
    //
    OSD_DATA_STORAGE_CLASS const int boundaryGregory[12] = OSD_ARRAY_12(int, 0, 1, 7, 5, 2, 6, 16, 12, 15, 17, 11, 10 );
    OSD_DATA_STORAGE_CLASS const int boundaryBezSCol[12] = OSD_ARRAY_12(int, 0, 1, 2, 3, 0, 3,  0,  3,  0,  1,  2,  3 );
    OSD_DATA_STORAGE_CLASS const int boundaryBezTRow[12] = OSD_ARRAY_12(int, 0, 0, 0, 0, 1, 1,  2,  2,  3,  3,  3,  3 );
    OSD_DATA_STORAGE_CLASS const int interiorGregory[8] = OSD_ARRAY_8(int, 3, 4,  8, 9,  13, 14,  18, 19 );
    OSD_DATA_STORAGE_CLASS const int interiorBezSCol[8] = OSD_ARRAY_8(int, 1, 1,  2, 2,   2,  2,   1,  1 );
    OSD_DATA_STORAGE_CLASS const int interiorBezTRow[8] = OSD_ARRAY_8(int, 1, 1,  1, 1,   2,  2,   2,  2 );
    //
    //  Bezier basis functions are denoted with B while the rational multipliers for the
    //  interior points will be denoted G -- so we have B(s), B(t) and G(s,t):
    //
    //  Directional Bezier basis functions B at s and t:
    float Bs[4], Bds[4], Bdss[4];
    float Bt[4], Bdt[4], Bdtt[4];
    OsdGetBezierWeights(s, Bs, OSD_OPTIONAL_INIT(wDs, Bds), OSD_OPTIONAL_INIT(wDss, Bdss));
    OsdGetBezierWeights(t, Bt, OSD_OPTIONAL_INIT(wDt, Bdt), OSD_OPTIONAL_INIT(wDtt, Bdtt));
    //  Rational multipliers G at s and t:
    float sC = 1.0f - s;
    float tC = 1.0f - t;
    //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:
    float df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);
    float df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);
    float df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);
    float df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);
    float G[8] = OSD_ARRAY_8(float, s*df0, t*df0,  t*df1, sC*df1,  sC*df2, tC*df2,  tC*df3, s*df3 );
    //  Combined weights for boundary and interior points:
    for (int i = 0; i < 12; ++i) {
        wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];
    }
    for (int i = 0; i < 8; ++i) {
        wP[interiorGregory[i]] = Bs[interiorBezSCol[i]] * Bt[interiorBezTRow[i]] * G[i];
    }
    //
    //  For derivatives, the basis functions for the interior points are rational and ideally
    //  require appropriate differentiation, i.e. product rule for the combination of B and G
    //  and the quotient rule for the rational G itself.  As initially proposed by Loop et al
    //  though, the approximation using the 16 Bezier points arising from the G(s,t) has
    //  proved adequate (and is what the GPU shaders use) so we continue to use that here.
    //
    //  An implementation of the true derivatives is provided for future reference -- it is
    //  unclear if the approximations will hold up under surface analysis involving higher
    //  order differentiation.
    //
    if (OSD_OPTIONAL(wDs && wDt)) {
        bool find_second_partials = OSD_OPTIONAL(wDs && wDst && wDtt);
        //  Remember to include derivative scaling in all assignments below:
        float d2Scale = dScale * dScale;
        //  Combined weights for boundary points -- simple (scaled) tensor products:
        for (int i = 0; i < 12; ++i) {
            int iDst = boundaryGregory[i];
            int tRow = boundaryBezTRow[i];
            int sCol = boundaryBezSCol[i];
            wDs[iDst] = Bds[sCol] * Bt[tRow] * dScale;
            wDt[iDst] = Bdt[tRow] * Bs[sCol] * dScale;
            if (find_second_partials) {
                wDss[iDst] = Bdss[sCol] * Bt[tRow] * d2Scale;
                wDst[iDst] = Bds[sCol] * Bdt[tRow] * d2Scale;
                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * d2Scale;
            }
        }
        // dclyde's note: skipping half of the product rule like this does seem to change the result a lot in my tests.
        // This is not a runtime bottleneck for cloth sims anyway so I'm just using the accurate version.
#ifndef OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES
        //  Approximation to the true Gregory derivatives by differentiating the Bezier patch
        //  unique to the given (s,t), i.e. having F = (g^+ * f^+) + (g^- * f^-) as its four
        //  interior points:
        //
        //  Combined weights for interior points -- (scaled) tensor products with G+ or G-:
        for (int i = 0; i < 8; ++i) {
            int iDst = interiorGregory[i];
            int tRow = interiorBezTRow[i];
            int sCol = interiorBezSCol[i];
            wDs[iDst] = Bds[sCol] * Bt[tRow] * G[i] * dScale;
            wDt[iDst] = Bdt[tRow] * Bs[sCol] * G[i] * dScale;
            if (find_second_partials) {
                wDss[iDst] = Bdss[sCol] * Bt[tRow] * G[i] * d2Scale;
                wDst[iDst] = Bds[sCol] * Bdt[tRow] * G[i] * d2Scale;
                wDtt[iDst] = Bs[sCol] * Bdtt[tRow] * G[i] * d2Scale;
            }
        }
#else
        //  True Gregory derivatives using appropriate differentiation of composite functions:
        //
        //  Note that for G(s,t) = N(s,t) / D(s,t), all N' and D' are trivial constants (which
        //  simplifies things for higher order derivatives).  And while each pair of functions
        //  G (i.e. the G+ and G- corresponding to points f+ and f-) must sum to 1 to ensure
        //  Bezier equivalence (when f+ = f-), the pairs of G' must similarly sum to 0.  So we
        //  can potentially compute only one of the pair and negate the result for the other
        //  (and with 4 or 8 computations involving these constants, this is all very SIMD
        //  friendly...) but for now we treat all 8 independently for simplicity.
        //
        //float N[8] = OSD_ARRAY_8(float,    s,     t,      t,     sC,      sC,     tC,      tC,     s );
        float D[8] = OSD_ARRAY_8(float,  df0,   df0,    df1,    df1,     df2,    df2,     df3,   df3 );
        OSD_DATA_STORAGE_CLASS const float Nds[8] = OSD_ARRAY_8(float, 1.0f, 0.0f,  0.0f, -1.0f, -1.0f,  0.0f,  0.0f,  1.0f );
        OSD_DATA_STORAGE_CLASS const float Ndt[8] = OSD_ARRAY_8(float, 0.0f, 1.0f,  1.0f,  0.0f,  0.0f, -1.0f, -1.0f,  0.0f );
        OSD_DATA_STORAGE_CLASS const float Dds[8] = OSD_ARRAY_8(float, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f,  1.0f,  1.0f );
        OSD_DATA_STORAGE_CLASS const float Ddt[8] = OSD_ARRAY_8(float, 1.0f, 1.0f,  1.0f,  1.0f, -1.0f, -1.0f, -1.0f, -1.0f );
        //  Combined weights for interior points -- (scaled) combinations of B, B', G and G':
        for (int i = 0; i < 8; ++i) {
            int iDst = interiorGregory[i];
            int tRow = interiorBezTRow[i];
            int sCol = interiorBezSCol[i];
            //  Quotient rule for G' (re-expressed in terms of G to simplify (and D = 1/D)):
            float Gds = (Nds[i] - Dds[i] * G[i]) * D[i];
            float Gdt = (Ndt[i] - Ddt[i] * G[i]) * D[i];
            //  Product rule combining B and B' with G and G' (and scaled):
            wDs[iDst] = (Bds[sCol] * G[i] + Bs[sCol] * Gds) * Bt[tRow] * dScale;
            wDt[iDst] = (Bdt[tRow] * G[i] + Bt[tRow] * Gdt) * Bs[sCol] * dScale;
            if (find_second_partials) {
                float Dsqr_inv = D[i]*D[i];
                float Gdss = 2.0f * Dds[i] * Dsqr_inv * (G[i] * Dds[i] - Nds[i]);
                float Gdst = Dsqr_inv * (2.0f * G[i] * Dds[i] * Ddt[i] - Nds[i] * Ddt[i] - Ndt[i] * Dds[i]);
                float Gdtt = 2.0f * Ddt[i] * Dsqr_inv * (G[i] * Ddt[i] - Ndt[i]);
                wDss[iDst] = (Bdss[sCol] * G[i] + 2.0f * Bds[sCol] * Gds + Bs[sCol] * Gdss) * Bt[tRow] * d2Scale;
                wDst[iDst] = (Bt[tRow] * (Bs[sCol] * Gdst + Bds[sCol] * Gdt) + Bdt[tRow] * (Bds[sCol] * G[i] + Bs[sCol] * Gds)) * d2Scale;
                wDtt[iDst] = (Bdtt[tRow] * G[i] + 2.0f * Bdt[tRow] * Gdt + Bt[tRow] * Gdtt) * Bs[sCol] * d2Scale;
            }
        }
#endif
    }
#endif /* OPENSUBDIV3_OSD_PATCH_BASIS_COMMON_H */
#define OSD_PATCH_LINES 1
#define OSD_PATCH_TRIANGLES 1
#define OSD_PATCH_QUADS 1
#define OSD_PATCH_BSPLINE 1
#define OSD_PATCH_REGULAR 1
#define OSD_PATCH_GREGORY 1
#define OSD_PATCH_GREGORY_BOUNDARY 1
#define OSD_PATCH_GREGORY_BASIS 1
GetPatchTypeDefine
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/osd/mtlPatchShaderSource.mm
"Unknown Far::PatchDescriptor::Type" && 0
GetPatchTypeSource
#line 0 "osd/mtlPatchBSpline.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.BSpline.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 vertexPosition,
    threadgroup HullVertex& hullVertex,
    int vertexId,
    float4x4 ModelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
    hullVertex.position = vertexPosition;
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(ModelViewProjectionMatrix, vertexPosition);   
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);              
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.BSpline.Factors
//----------------------------------------------------------
void OsdComputePerPatchBSplineFactors(
    int3 patchParam,
    float tessLevel,
    float4x4 projectionMatrix,
    float4x4 modelViewMatrix,
    device OsdPerPatchVertexBezier* patch
#if !USE_PTVS_FACTORS
    ,device OsdPerPatchTessFactors& patchFactors
#endif
    ,device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
    float4 tessOuterLo = float4(0,0,0,0);
    float4 tessOuterHi = float4(0,0,0,0);
#if OSD_ENABLE_SCREENSPACE_TESSELLATION
    OsdGetTessLevelsAdaptiveLimitPoints(
        tessLevel, 
        projectionMatrix, 
        modelViewMatrix,
        patch,
        patchParam,
        tessLevelOuter,
        tessLevelInner,
        tessOuterLo,
        tessOuterHi
        );
#else
    OsdGetTessLevelsUniform(
        tessLevel, 
        patchParam, 
        tessLevelOuter,
        tessLevelInner,
        tessOuterLo,
        tessOuterHi
        );
#endif
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
#if !USE_PTVS_FACTORS
    patchFactors.tessOuterLo = tessOuterLo;
    patchFactors.tessOuterHi = tessOuterHi;
#endif
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
OsdComputePerPatchBSplineFactors(
patchParam, 
tessLevel, 
projectionMatrix, 
modelViewMatrix, 
osdBuffer.perPatchVertexBuffer + patchID * CONTROL_POINTS_PER_PATCH,
#if !USE_PTVS_FACTORS
osdBuffer.patchTessBuffer[patchID],
#endif
quadFactors
//----------------------------------------------------------
// Patches.BSpline.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
OsdComputePerPatchVertexBSpline(patchParam, ID, patchVertices, osdBuffers.perPatchVertexBuffer[ControlID]);
    
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.BSpline.Domain
//----------------------------------------------------------
template<typename PerPatchVertexBezier>
OsdPatchVertex ds_regular_patches(
    const float TessLevel,
#if !USE_PTVS_FACTORS
    float4 tessOuterHi,
    float4 tessOuterLo,
#endif
    PerPatchVertexBezier cv,
    int3 patchParam,
    float2 domainCoord)
    OsdPatchVertex output;
    float3 P, dPu, dPv;
    float3 N, dNu, dNv;
    float2 vSegments;
#if !USE_PTVS_FACTORS
    float2 UV = OsdGetTessParameterization(domainCoord,
                                           tessOuterLo,
                                           tessOuterHi);
#else
    auto transitionMask = OsdGetPatchTransitionMask(patchParam);
    float4 tessLevelMin = float4(1)
    + float4(((transitionMask & 8) >> 3),
             ((transitionMask & 1) >> 0),
             ((transitionMask & 2) >> 1),
             ((transitionMask & 4) >> 2));
    float2 UV = OsdGetTessParameterization(domainCoord,
                                           tessLevelMin,
                                           float4(0));
#endif
    OsdEvalPatchBezier(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv, vSegments);
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
#if OSD_PATCH_ENABLE_SINGLE_CREASE
    output.vSegments = vSegments;
#endif
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    output.position = P;
    
    OSD_USER_VARYING_PER_EVAL_POINT(UV, cv[5], cv[6], cv[9], cv[10], output);
    
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexBezier>
#endif
OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexBezier osdPatch
#else
OsdVertexBufferSet osdBuffers
#endif
return ds_regular_patches(
tessLevel,
#if !USE_PTVS_FACTORS
#if USE_STAGE_IN
osdPatch.tessOuterHi,
osdPatch.tessOuterLo,
#else
osdBuffers.patchTessBuffer[patchID].tessOuterHi,
osdBuffers.patchTessBuffer[patchID].tessOuterLo,
#endif
#endif
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord
#line 0 "osd/mtlPatchGregory.metal"
//   Copyright 2013 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.Gregory.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 position,
    threadgroup OsdPerVertexGregory& hullVertex,
    int vertexId,
    float4x4 modelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
OsdComputePerVertexGregory(vertexId, position.xyz, hullVertex, osdBuffers);
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(modelViewProjectionMatrix, position);    
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.Gregory.Factors
//----------------------------------------------------------
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
OsdGetTessLevels(
tessLevel, 
projectionMatrix, 
modelViewMatrix,
patchVertices[0].P, 
patchVertices[3].P, 
patchVertices[2].P, 
patchVertices[1].P,
patchParam, 
tessLevelOuter, 
tessLevelInner
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
//----------------------------------------------------------
// Patches.Gregory.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
OsdComputePerPatchVertexGregory(
patchParam,
PrimitiveID,
patchVertices,
osdBuffers.perPatchVertexBuffer[ControlID],
osdBuffers);
    
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.Gregory.Domain
//----------------------------------------------------------
template<typename PerPatchVertexGregory>
OsdPatchVertex ds_gregory_patches(
                     PerPatchVertexGregory patch,
                     int3 patchParam,
                     float2 UV
                    )
    OsdPatchVertex output;
    
    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);
    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);
    
    float3 cv[20];
    cv[0] = patch[0].P;
    cv[1] = patch[0].Ep;
    cv[2] = patch[0].Em;
    cv[3] = patch[0].Fp;
    cv[4] = patch[0].Fm;
    
    cv[5] = patch[1].P;
    cv[6] = patch[1].Ep;
    cv[7] = patch[1].Em;
    cv[8] = patch[1].Fp;
    cv[9] = patch[1].Fm;
    
    cv[10] = patch[2].P;
    cv[11] = patch[2].Ep;
    cv[12] = patch[2].Em;
    cv[13] = patch[2].Fp;
    cv[14] = patch[2].Fm;
    
    cv[15] = patch[3].P;
    cv[16] = patch[3].Ep;
    cv[17] = patch[3].Em;
    cv[18] = patch[3].Fp;
    cv[19] = patch[3].Fm;
    
    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);
    
    // all code below here is client code
    output.position = P;
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[0], patch[1], patch[3], patch[2], output);
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexGregoryBasis osdPatch
#else
    OsdVertexBufferSet osdBuffers
#endif
return ds_gregory_patches(
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
        osdBuffers.perPatchVertexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
        osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord);
#line 0 "osd/mtlPatchGregoryBasis.metal"
//   Copyright 2015 Pixar
//   Licensed under the Apache License, Version 2.0 (the "Apache License")
//   with the following modification; you may not use this file except in
//   compliance with the Apache License and the following modification to it:
//   Section 6. Trademarks. is deleted and replaced with:
//   6. Trademarks. This License does not grant permission to use the trade
//      names, trademarks, service marks, or product names of the Licensor
//      and its affiliates, except as required to comply with Section 4(c) of
//      the License and to reproduce the content of the NOTICE file.
//   You may obtain a copy of the Apache License at
//       http://www.apache.org/licenses/LICENSE-2.0
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the Apache License with the above modification is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
//   KIND, either express or implied. See the Apache License for the specific
//   language governing permissions and limitations under the Apache License.
//----------------------------------------------------------
// Patches.GregoryBasis.Hull
//----------------------------------------------------------
void OsdComputePerVertex(
float4 position,
    threadgroup HullVertex& hullVertex,
    int vertexId,
    float4x4 modelViewProjectionMatrix,
    OsdPatchParamBufferSet osdBuffers
    )
hullVertex.position = position;
#if OSD_ENABLE_PATCH_CULL
    float4 clipPos = mul(modelViewProjectionMatrix, position);    
    short3 clip0 = short3(clipPos.x < clipPos.w,                    
    clipPos.y < clipPos.w,                    
    clipPos.z < clipPos.w);                   
    short3 clip1 = short3(clipPos.x > -clipPos.w,                   
    clipPos.y > -clipPos.w,                   
    clipPos.z > -clipPos.w);                  
    hullVertex.clipFlag = short3(clip0) + 2*short3(clip1);              
#endif
    
    OSD_USER_VARYING_PER_CONTROL_POINT(osdBuffers.vertexBuffer[vertexId], hullVertex);
//----------------------------------------------------------
// Patches.GregoryBasis.Factors
//----------------------------------------------------------
void OsdComputePerPatchFactors(
int3 patchParam,
float tessLevel,
unsigned patchID,
float4x4 projectionMatrix,
float4x4 modelViewMatrix,
OsdPatchParamBufferSet osdBuffer,
threadgroup PatchVertexType* patchVertices,
device MTLQuadTessellationFactorsHalf& quadFactors
    float4 tessLevelOuter = float4(0,0,0,0);
    float2 tessLevelInner = float2(0,0);
OsdGetTessLevels(
tessLevel, 
projectionMatrix, 
modelViewMatrix,
patchVertices[0].position.xyz, 
patchVertices[3].position.xyz, 
patchVertices[2].position.xyz, 
patchVertices[1].position.xyz,
patchParam, 
tessLevelOuter, 
tessLevelInner
    quadFactors.edgeTessellationFactor[0] = tessLevelOuter[0];
    quadFactors.edgeTessellationFactor[1] = tessLevelOuter[1];
    quadFactors.edgeTessellationFactor[2] = tessLevelOuter[2];
    quadFactors.edgeTessellationFactor[3] = tessLevelOuter[3];
    quadFactors.insideTessellationFactor[0] = tessLevelInner[0];
    quadFactors.insideTessellationFactor[1] = tessLevelInner[1];
//----------------------------------------------------------
// Patches.GregoryBasis.Vertex
//----------------------------------------------------------
void OsdComputePerPatchVertex(
int3 patchParam, 
unsigned ID, 
unsigned PrimitiveID, 
unsigned ControlID,
threadgroup PatchVertexType* patchVertices,
OsdPatchParamBufferSet osdBuffers
//Does nothing, all transforms are in the PTVS
    OSD_USER_VARYING_PER_VERTEX(patchVertices[ID], osdBuffers.perPatchVertexBuffer[ControlID]);
//----------------------------------------------------------
// Patches.GregoryBasis.Domain
//----------------------------------------------------------
#define USE_128BIT_GREGORY_BASIS_INDICES_READ 1
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
OsdPatchVertex ds_gregory_basis_patches(
#if USE_STAGE_IN
                     PerPatchVertexGregoryBasis patch,
#else
                     const device OsdInputVertexType* patch,
                     const device unsigned* patchIndices,
#endif
                     int3 patchParam,
                     float2 UV
                     )
    OsdPatchVertex output;
    float3 P = float3(0,0,0), dPu = float3(0,0,0), dPv = float3(0,0,0);
    float3 N = float3(0,0,0), dNu = float3(0,0,0), dNv = float3(0,0,0);
#if USE_STAGE_IN
    float3 cv[20];
    for(int i = 0; i < 20; i++)
        cv[i] = patch[i].position;
#else   
#if USE_128BIT_GREGORY_BASIS_INDICES_READ
    float3 cv[20];
    for(int i = 0; i < 5; i++) {
        int4 indices = ((device int4*)patchIndices)[i];
        
        int n = i * 4;
        cv[n + 0] = (patch + indices[0])->position;
        cv[n + 1] = (patch + indices[1])->position;
        cv[n + 2] = (patch + indices[2])->position;
        cv[n + 3] = (patch + indices[3])->position;
    }
#else
    float3 cv[20];
    for (int i = 0; i < 20; ++i) {
        cv[i] = patch[patchIndices[i]].position;
    }
#endif
#endif
    
    OsdEvalPatchGregory(patchParam, UV, cv, P, dPu, dPv, N, dNu, dNv);
    
    output.position = P;
    output.normal = N;
    output.tangent = dPu;
    output.bitangent = dPv;
#if OSD_COMPUTE_NORMAL_DERIVATIVES
    output.Nu = dNu;
    output.Nv = dNv;
#endif
    
    output.patchCoord = OsdInterpolatePatchCoord(UV, patchParam);
    
#if USE_STAGE_IN
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[0], patch[5], patch[15], patch[10], output);
#else
    OSD_USER_VARYING_PER_EVAL_POINT(UV, patch[patchIndices[0]], patch[patchIndices[5]], patch[patchIndices[15]], patch[patchIndices[10]], output);
#endif
    
    return output;
#if USE_STAGE_IN
template<typename PerPatchVertexGregoryBasis>
#endif
OsdPatchVertex OsdComputePatch(
float tessLevel,
float2 domainCoord,
unsigned patchID,
#if USE_STAGE_IN
PerPatchVertexGregoryBasis osdPatch
#else
OsdVertexBufferSet osdBuffers
#endif
return ds_gregory_basis_patches(
#if USE_STAGE_IN
osdPatch.cv,
osdPatch.patchParam,
#else
osdBuffers.vertexBuffer,
osdBuffers.indexBuffer + patchID * VERTEX_CONTROL_POINTS_PER_PATCH,
osdBuffers.patchParamBuffer[patchID],
#endif
domainCoord
EndCapBSplineBasisPatchFactory
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/endCapBSplineBasisPatchFactory.cpp
computeLimitStencils
(ringSize & 1) == 0
start > -1 && prev > -1
AddWithWeight
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/../far/gregoryBasis.h
_size < (int)_stencils.GetSize()
operator=
_size <= (int)_stencils.GetSize()
EndCapGregoryBasisPatchFactory
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/endCapGregoryBasisPatchFactory.cpp
GetPatchPoints
fedges.size()==4
aedge!=Vtr::INDEX_INVALID
adjPatchIndex>=0 && adjPatchIndex<(int)_levelAndFaceIndices.size()
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/vtr/quadRefinement.cpp
_splitType == Sdc::SPLIT_TO_QUADS
initializeInventory
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/topologyRefiner.cpp
_levels.size() == 1
Failure in TopologyRefiner::RefineUniform() -- base level is uninitialized.
Failure in TopologyRefiner::RefineUniform() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- base level is uninitialized.
Failure in TopologyRefiner::RefineAdaptive() -- previous refinements already applied.
Failure in TopologyRefiner::RefineAdaptive() -- currently only supported for Catmark scheme.
doesFaceHaveDistinctFaceVaryingFeatures
!level.doesFaceFVarTopologyMatch(face, fvarChannel)
getQuadOffsets
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/endCapLegacyGregoryPatchFactory.cpp
thisFaceInVFaces != -1
Edge %d specified to be sharp does not exist (%d, %d)
Vertex %d specified to be sharp does not exist
GetWeights
/Library/Caches/com.apple.xbs/Sources/SceneKit/SceneKit-433.6/lib/libOsd/sources/opensubdiv/far/patchBasis.cpp
OSD VertexBuffer
objectForKey:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
setUsage:
usage
setStorageMode:
newTextureWithDescriptor:
setLabel:
setObject:forKey:
release
_bakeSphericalHamonicsBasedIrradianceTexture:forEnvironmentTexture:applySH:
frameworkLibrary
pixelFormat
newRenderPipelineStateWithPixelFormat:vertexFunctionName:fragmentFunctionName:library:
alloc
init
colorAttachments
objectAtIndexedSubscript:
setTexture:
commandBuffer
setLevel:
setSlice:
renderCommandEncoderWithDescriptor:
setRenderPipelineState:
setFragmentTexture:atIndex:
setFragmentBytes:length:atIndex:
drawPrimitives:vertexStart:vertexCount:
endEncoding
mipmapLevelCount
blitCommandEncoder
generateMipmapsForTexture:
commit
sphericalHarmonicsForEnvironmentTexture:order:commandBuffer:
synchronizeResource:
addCompletedHandler:
setFragmentBuffer:offset:atIndex:
setMipmapLevelCount:
newFunctionWithName:
label
stringWithFormat:
setSampleCount:
setVertexFunction:
setFragmentFunction:
setPixelFormat:
setDepthAttachmentPixelFormat:
setStencilAttachmentPixelFormat:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newTextureViewWithPixelFormat:textureType:levels:slices:
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
computePipelineStateForKernel:
computeCommandEncoder
setComputePipelineState:
setTexture:atIndex:
dispatchForTexture:computeEncoder:pipelineState:
width
autorelease
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
irradianceTextureForEnvironmentTexture:queue:group:applySH:
_bakeStochasticIrradianceTexture:forEnvironmentTexture:mipmapLevelForSampling:useTextureView:
radianceTextureForEnvironmentTexture:queue:group:
specularDFGTexture
textureForSamplingTexture:atSize:mipmapLevelCount:
height
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
cubemapTextureForLatlongTexture:pixelFormat:needsMipmap:
depth
setTextureType:
setWidth:
setHeight:
setDepth:
textureType
_enqueueMipmapGenerationForTexture:
setTextures:withRange:
dispatchForCubemap:computeEncoder:pipelineState:
dispatchThreadgroups:threadsPerThreadgroup:
storageMode
waitUntilCompleted
renderResourceForImageProxy:sampler:engineContext:
resourceQueue
resourceGroup
renderResourceForImage:sampler:options:queue:group:
iosurface
retain
newTextureWithName:scaleFactor:bundle:options:error:
_textureDescriptorFromImage:needsMipMap:textureOptions:
_copyImage:toTexture:desc:textureOptions:needsMipMapGeneration:
convertTextureToCubeMapIfApplicable:needsMipmap:
_enqueueCopyFromTexture:toTexture:generateMipMaps:
latlongTextureForCubemap:pixelFormat:needsMipmap:
unstageTexture:
renderResourcesForEffectSlot:withEngineContext:
defaultTexture
defaultCubeTexture
defaultTexture3D
initWithFrame:
subviews
count
objectAtIndex:
removeFromSuperview
addSubview:
bounds
setFrame:
setAutoresizingMask:
willBeShown
respondsToSelector:
setNeedsDisplay:
showModelInspector:
window
close
dealloc
indexOfSelectedItem
scene
sceneRef
setRootNode:
_updateResourceManager
performSelector:withObject:afterDelay:
isEqualToString:
sceneDidChange
observeValueForKeyPath:ofObject:change:context:
removeObserver:forKeyPath:
addObserver:forKeyPath:options:context:
class
bundleForClass:
loadNibNamed:owner:topLevelObjects:
makeKeyAndOrderFront:
awakeFromNib
modelTypeChanged:
setSCNView:
launchMonitor:
.cxx_destruct
_nibLoaded
_modelViewContainer
_modelInspectors
_scnView
setDataSource:
setDelegate:
initWithCoder:
_commonInit
dictionary
setValue:forKey:
valueWithPointer:
numberWithInt:
reloadData
intValue
pointerValue
ivarsOfItem:
isKindOfClass:
identifier
floatValue
doubleValue
shortValue
boolValue
description
isEqual:
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isMemberOfClass:
conformsToProtocol:
retainCount
zone
hash
superclass
debugDescription
outlineView:numberOfChildrenOfItem:
outlineView:child:ofItem:
outlineView:isItemExpandable:
outlineView:objectValueForTableColumn:byItem:
outlineView:setObjectValue:forTableColumn:byItem:
outlineView:itemForPersistentObject:
outlineView:persistentObjectForItem:
outlineView:sortDescriptorsDidChange:
outlineView:pasteboardWriterForItem:
outlineView:draggingSession:willBeginAtPoint:forItems:
outlineView:draggingSession:endedAtPoint:operation:
outlineView:writeItems:toPasteboard:
outlineView:updateDraggingItemsForDrag:
outlineView:validateDrop:proposedItem:proposedChildIndex:
outlineView:acceptDrop:item:childIndex:
outlineView:namesOfPromisedFilesDroppedAtDestination:forDraggedItems:
control:textShouldBeginEditing:
control:textShouldEndEditing:
control:didFailToFormatString:errorDescription:
control:didFailToValidatePartialString:errorDescription:
control:isValidObject:
control:textView:doCommandBySelector:
control:textView:completions:forPartialWordRange:indexOfSelectedItem:
outlineView:viewForTableColumn:item:
outlineView:rowViewForItem:
outlineView:didAddRowView:forRow:
outlineView:didRemoveRowView:forRow:
outlineView:willDisplayCell:forTableColumn:item:
outlineView:shouldEditTableColumn:item:
selectionShouldChangeInOutlineView:
outlineView:shouldSelectItem:
outlineView:selectionIndexesForProposedSelection:
outlineView:shouldSelectTableColumn:
outlineView:mouseDownInHeaderOfTableColumn:
outlineView:didClickTableColumn:
outlineView:didDragTableColumn:
outlineView:toolTipForCell:rect:tableColumn:item:mouseLocation:
outlineView:heightOfRowByItem:
outlineView:typeSelectStringForTableColumn:item:
outlineView:nextTypeSelectMatchFromItem:toItem:forString:
outlineView:shouldTypeSelectForEvent:withCurrentSearchString:
outlineView:shouldShowCellExpansionForTableColumn:item:
outlineView:shouldTrackCell:forTableColumn:item:
outlineView:dataCellForTableColumn:item:
outlineView:isGroupItem:
outlineView:shouldExpandItem:
outlineView:shouldCollapseItem:
outlineView:willDisplayOutlineCell:forTableColumn:item:
outlineView:sizeToFitWidthOfColumn:
outlineView:shouldReorderColumn:toColumn:
outlineView:shouldShowOutlineCellForItem:
outlineViewSelectionDidChange:
outlineViewColumnDidMove:
outlineViewColumnDidResize:
outlineViewSelectionIsChanging:
outlineViewItemWillExpand:
outlineViewItemDidExpand:
outlineViewItemWillCollapse:
outlineViewItemDidCollapse:
instance
setInstance:
_instance
_mainView
_outlineView
_datasource
parentForItem:
characterSetWithCharactersInString:
componentsSeparatedByCharactersInSet:
countByEnumeratingWithState:objects:count:
caction
setCppAction:
decodeObjectOfClass:forKey:
unsignedIntValue
encodeWithCoder:
numberWithUnsignedInteger:
encodeObject:forKey:
numberWithBool:
isCustom
waitForDuration:
repeatAction:count:
copy
duration
setDuration:
repeatActionForever:
timingMode
setTimingMode:
reversedAction
supportsSecureCoding
copyWithZone:
_mycaction
_repeatedAction
finished
numberWithDouble:
numberWithFloat:
arrayWithObjects:count:
fadeOpacityBy:duration:
fadeOpacityTo:duration:
fadeInWithDuration:
fadeOutWithDuration:
parameters
opacity
setOpacity:
weakRef
copyWeakRef
setWeakRef:
URLByDeletingLastPathComponent
path
hasPrefix:
length
stringByReplacingCharactersInRange:withString:
characterAtIndex:
substringFromIndex:
stringByAppendingPathComponent:
stringByDeletingLastPathComponent
dictionaryWithObjects:forKeys:count:
standardizedURL
UTF8String
stringWithContentsOfURL:encoding:error:
dataUsingEncoding:
propertyListWithData:options:format:error:
dictionaryWithContentsOfURL:
JSONObjectWithData:options:error:
processInfo
operatingSystemVersion
standardUserDefaults
boolForKey:
integerForKey:
mainBundle
infoDictionary
contents
dataWithBytesNoCopy:length:freeWhenDone:
lastPathComponent
pathExtension
stringByDeletingPathExtension
indexType
_pipelineStateHashForMeshElement:patchType:
setTessellationPartitionMode:
setTessellationFactorStepFunction:
setTessellationControlPointIndexType:
setTessellationFactorScaleEnabled:
setTessellationFactorFormat:
setTessellationOutputWindingOrder:
setMaxTessellationFactor:
updateUniformTessellator:
updateScreenSpaceAdaptiveTessellator:parameters:
updateConstrainedEdgeLengthTessellator:withMesh:computeCommandEncoder:
updateSubdivisionSurfaceTessellator:parameters:
uniformTessellationDrawMeshElement:forMesh:instanceCount:renderCommandEncoder:renderContext:
screenSpaceAdaptiveTessellationDrawMeshElement:forMesh:instanceCount:renderCommandEncoder:renderContext:
constrainedEdgeLengthTessellationDrawMeshElement:forMesh:instanceCount:renderCommandEncoder:renderContext:
subdivisionSurfaceTessellationDraw:
device
newBufferWithBytes:length:options:
didModifyRange:
setTessellationFactorScale:
setTessellationFactorBuffer:offset:instanceStride:
_drawPatchForMeshElement:instanceCount:
elements
primitiveCount
newBufferWithLength:options:
vertexDescriptor
attributes
layouts
bufferIndex
pushDebugGroup:
indexBuffer
buffer
offset
sharedIndexBufferOffset
buffers
stride
threadExecutionWidth
engineContext
setBuffer:offset:atIndex:
setBytes:length:atIndex:
popDebugGroup
bufferForAttribute:
indexOfObject:
initWithGeometry:resourceManager:
pipelineStateHashForMeshElement:patchType:
newPipelineStateConfiguratorForMeshElement:patchType:
update:
draw:
_geometry
_resourceManager
_cachedTessellator
_tessellationFactorBuffer
maximumDrawableCount
lowLatency
drawForMetalBackingLayer
display
parentView
setParentView:
_parentView
_pixelFormatByDefaultingIfNeeded
_privateOpenGLContextIfAny
initWithFormat:shareContext:
setOpenGLContext:
canDraw
CGLContextObj
renderer
_engineContext
_drawInBackingLayerWithCGLContext:atTime:
context
snapshot
CGImageForProposedRect:context:hints:
canDrawConcurrently
openGLPixelFormatForDisplayMask:
openGLContextForPixelFormat:
_jitterRedisplayWithContext:
_cancelJitterRedisplay
_isRenderingForJittering
canDrawInOpenGLContext:pixelFormat:forLayerTime:displayTime:
drawInOpenGLContext:pixelFormat:forLayerTime:displayTime:
drawInContext:
_needsRedrawForJittering
integerValue
resourceManager
renderResourceForMesh:
contentScaleFactor
textureForEffectSlot:
decodeBoolForKey:
_setupDuration
encodeBool:forKey:
fileName
playAudioSource:waitForCompletion:
audioPlayerWithSource:
addAudioPlayer:
audioPlayers
audioSource
removeAudioPlayer:
arrayWithObjects:
registerForDraggedTypes:
colorWithAlphaComponent:
isEqualTo:
drawInRect:
copyC3DImageFromImage:
initWithCGImage:size:
firstResponder
colorWithCalibratedWhite:alpha:
color
setValue:
target
action
modifierFlags
launchImagePicker
orderFrontColorPanel:
types
containsObject:
dataForType:
fileURLWithPath:isDirectory:
URLWithString:
isFileURL
initWithPasteboard:
draggingPasteboard
imageContentsWithPasteboard:
value
drawRect:
acceptsFirstResponder
resignFirstResponder
becomeFirstResponder
changeColor:
mouseDown:
draggingEntered:
draggingUpdated:
prepareForDragOperation:
performDragOperation:
setTarget:
setAction:
_contents
_image
array
setWithArray:
decodeObjectOfClasses:forKey:
numberWithUnsignedLong:
sequenceWithActions:
initWithCapacity:
groupWithActions:
addObject:
timingFunction
setTimingFunction:
speed
setSpeed:
insertObject:atIndex:
_actions
arrayLength
cpuCacheMode
sampleCount
setArrayLength:
setCpuCacheMode:
setup:
execute:
setupBlock
setSetupBlock:
executeBlock
setExecuteBlock:
currentRenderPassDescriptor
resolveTexture
texture
newConstantBufferWithLength:options:
newComputePipelineStateWithFunctionName:
currentCommandBuffer
depthAttachment
maxTotalThreadsPerThreadgroup
_initCS
_stepCS
_tailCS
_reduceTmpTexture
_reduceResult
setBuffers:offsets:withRange:
firstObject
nodeRef
setSourceObject:
setKeyPathSrc:
setKeyPathDst:
setOptions:
sourceObject
keyPathSrc
keyPathDst
options
rangeOfString:
valueWithRange:
appendFormat:
hasSuffix:
addEntriesFromDictionary:
enumerateKeysAndObjectsUsingBlock:
dictionaryWithCapacity:
stringWithCapacity:
scn_stringByReplacingCharactersInRanges:withStrings:
setObject:forKeyedSubscript:
appendString:
stringByAppendingString:
_newProgramWithHashCodeWithFunctionConstants:engineContext:introspectionDataPtr:
objectForKeyedSubscript:
numberWithUnsignedChar:
numberWithLong:
profile
_newProgramWithHashCode:engineContext:introspectionDataPtr:
_useFunctionConstants
_originalSourceCode
_injectionPointRanges
uppercaseString
stringWithUTF8String:
numberWithUnsignedInt:
userAnimation
_owner
_source
_destination
enumerateObjectsUsingBlock:
indexesOfObjectsPassingTest:
removeObjectsAtIndexes:
mutableCopy
replaceObjectAtIndex:withObject:
doesNotRecognizeSelector:
defaultAuthoringDisplayMask
orderedSet
update
_initWithEngineContext:
mutableCopyWithZone:
_setAuthoringEnvironment:
readonly
setReadonly:
showsAuthoringEnvironment
authoringEnvironmentForScene:
setDisplayMask:
removeAllObjects
draw
pointOfView
simdWorldPosition
simdWorldFront
nodeWithNodeRef:
selectedItems
nodeManipulatorItemWithNode:screenSize:
_findFieldAttachedToNode:
isActive
halfExtent
usesEllipsoidalExtent
supportsOffset
supportsDirection
direction
_displayScaleFactor
evalAtLocation:
whiteColor
boundingRectWithSize:options:attributes:
initWithString:attributes:
drawAtPoint:
bezierPathWithOvalInRect:
fill
_setNeedsDisplay
beginEditingNodes:
selectNode:
arrayWithCapacity:
authoringEnvironmentNode
authoringEnvironmentCompanionNode
orderedSetWithArray:
_updateManipulatorTargets
setTargets:
selectedNodes
node
parentNode
component
screenSize
elementPosition
authoringEnvironment:selectionDidUpdateWithProposedSelection:
allObjects
type
distantFuture
nextEventMatchingMask:untilDate:inMode:dequeue:
mouseDragged:
mouseUp:
saveInitialSelection
setSelecting:
locationInWindow
convertPoint:fromView:
mouseMoved:
lock
_updateSelectionWithSelectionFrame:
unlock
authoringEnvironmentForSceneRenderer:
sceneRenderer
viewMatrix
selectionIsReadonly
setSelectionIsReadonly:
manipulator
setAuthoringDisplayMask:
authoringDisplayMask
cancelEdition
beginEditingNode:
selecting
drawLineFromPoint:toPoint:color:
drawString:atPoint:color:
isEditingSubComponent
shouldSnapOnGrid
setShouldSnapOnGrid:
shouldSnapToAlign
setShouldSnapToAlign:
gridUnit
editingSpace
setEditingSpace:
delegate
graphicalSelectionEnabled
setGraphicalSelectionEnabled:
surroundToSelect
setSurroundToSelect:
_sceneRenderer
_noColorProgram
_colorOnlyProgram
_colorAndTextureProgram
_lightProbesProgram
_wireframeProgram
_logsInfo
_boldLogsInfo
_upArrowInfo
_xyQuadrantInfo
_xyQuadrantRingInfo
_dynamicLinesInfo
_dynamicLinesNoDepthTestInfo
_dynamicTrianglesInfo
_overlayDynamicLinesInfo
_overlayDynamicTriangleInfo
_textInfo
_lightProbesInfo
_normalTextInfo
_boldTextInfo
_depthOnCullOnStates
_depthOffCullOnStates
_depthOnCullOffStates
_depthOffCullOffStates
_arrowIndicesOffset
_arrowIndicesCount
_quadrantIndicesOffset
_quadrantIndicesCount
_quadrantRingIndicesOffset
_quadrantRingIndicesCount
_authoringDisplayMask
_hasLighting
_shouldSnapOnGrid
_shouldSnapToAlign
_selectionIsReadonly
_editingSpace
_graphicalSelectionEnabled
_selectionP0
_selectionP1
_selecting
_surroundToSelect
_initialSelection
_selection
_selectedNodes
_lastGridDistance
_gridUnit
_visibleManipulableItems
_wireframeRenderer
_statisticsInfo
_drawScale
_manipulator
_delegate
_authEnv2
unmapVolatileMesh:modifiedVerticesCount:
unmapVolatileMeshElement:
anyObject
removeObject:
createVolatileMeshElementOfType:primitiveCount:bytesPerIndex:
mapVolatileMesh:verticesCount:
sceneWithSceneRef:
physicsWorld
_drawDebugInAuthoringEnvironment:
isDragging
transform
snapGuideIndexesOnAxis:
firstIndex
snapInfoAtIndex:axis:
indexGreaterThanIndex:
graphicsContextWithGraphicsPort:flipped:
setCurrentContext:
fontWithName:size:
stringFromByteCount:countStyle:
renderMesh:meshElement:withProgram:engineContext:transform:color:rasterizerStates:blendState:texture:depthBias:
convertPosition:toNode:
setWithSet:
addObjectsFromArray:
convertPointToBacking:
rendererOptionsPanelForView:
open
_postCommandWithBlock:
setWorldTransform:
_handleCreateIfNeeded:
_handle
_allowGhostObjects
initWithCharacter:
setWalkingDirection:
canJump
jump
setVelocity:
velocity
setJumpSpeed:
jumpSpeed
_update
_addToPhysicsWorld:
_willRemoveFromPhysicsWorld:
_definition
_characterController
_ghostObject
_filterCallback
_capsuleShape
_world
isDepth24Stencil8PixelFormatSupported
resourceManagerForDevice:
stats
newCommandQueue
newSamplerStateWithDescriptor:
setDepthWriteEnabled:
setDepthCompareFunction:
newDepthStencilStateWithDescriptor:
setClientCommandBuffer:
setClientRenderPassDescriptor:
setClientRenderCommandEncoder:
supportsFeatureSet:
purgeRenderTargetsMatchingFrameBuffer
beginFrame:
presentDrawable:
resetVolatileMeshes
resetVolatileMeshElements
endFrameWaitingUntilCompleted:
renderTargetWithDescription:size:arrayLength:name:useCount:
nextDrawable
_finalRenderTexture
supportsTextureSampleCount:
setObject:atIndexedSubscript:
setDepthAttachment:
stencilAttachment
setStencilAttachment:
_renderTargetWithDescription:size:name:useCount:
setLoadAction:
setClearDepth:
setStoreAction:
setResolveTexture:
setClearColor:
setClearStencil:
_setupDescriptor:forPass:parameters:
shaderManagerForPassDescriptor:
_clearRenderCaches
releaseRenderTargetNamed:
superSampling:into:
executeRenderPasses
waitForShadersCompilation
__C3DFXContextDidApplyPass:
enqueue
renderResourceForRasterizerState:
getObjects:range:
volatileBuffer
volatileOffset
primitiveType
effectiveIndexCount
effectiveIndexOffset
verticesCount
clearColor
renderResourceForProgramDesc:
state
setRasterizerStates:
renderResourceForSampler:
_setMeshBuffers:
_drawMeshElement:instanceCount:
renderResourceForMeshElement:
setPrimitiveRange:
startProcessingRendererElementsWithEngineIterationContext:
enablesDeferredShading
beginDeferredLighting
renderLight:lightType:lightData:
endDeferredLighting
debugOptions
drawWireframeOverlayForElements:range:store:
stopProcessingRendererElements
wireframeResourceForRendererElement:engineContext:
registerSemantic:withBlock:
bufferAtIndices:
argument
bufferDataSize
textureAtIndices:
samplerAtIndices:
registerShadableArgumentBindingBlockForBuffers:textures:samplers:
registerArgument:frequency:needsRenderResource:block:
registerArgument:frequency:block:
radianceTextureForEffectSlot:
irradianceTextureForEffectSlot:
renderTargetWithName:
frequency
block
addResourceBindingsForArgument:frequency:needsRenderResource:block:
registerUserBlockTrampoline:
volatileStride
setVolatileSize:
setVolatileBuffer:
setVolatileOffset:
volatileSize
lastObject
removeLastObject
setBuffer:
setOffset:
setUsedCount:
setupWithElement:
indexCount
_newMTLBufferFromPoolWithLength:
setIndexBuffer:
_recycleMTLBufferToPool:
setSharedIndexBufferOffset:
_createPassWithVertex:fragment:
libraryManager
newRenderPipelineStateWithRenderPassDescriptor:over:vertexFunctionName:fragmentFunctionName:library:
renderPassDescriptor
setVertexBytes:length:atIndex:
updateAtTime:
renderWithEncoder:pass:commandQueue:
newTextureViewWithPixelFormat:
_drawFullScreenTexture:over:
registerBindings
writeBytes:length:
_reduceStatsOfConstantBuffer:
initWithDevice:engineContext:
commandQueue
setCommandQueue:
frameConstantBufferPool
features
setWantsWideGamut:
wantsWideGamut
pendingGPUFrameCount
setDisableLinearRendering:
disableLinearRendering
setIsOpaque:
isOpaque
_clearUnusedBindingPoints
textureTarget
beginRenderPass:parameters:
_renderCommandEncoderWithDescriptor:
_clearRenderCommandEncoderCache
endRenderPass
currentBlitEncoder
newRenderTargetWithDescription:size:arrayLength:
_logLightingInformation
renderBackground:engineContext:
renderVideoBackground:engineContext:
processRendererElements:count:engineIterationContext:
mainColorTextureForChannel:
mainDepthTexture
renderTargetForSemantic:
_prepareMaterialTextures:
drawRenderElement:withPass:
setShowsAuthoringEnvironment:
collectsCompilationErrors
setCollectsCompilationErrors:
compilationErrors
drawFullScreenQuadForPass:
currentRenderCommandEncoder
currentComputeCommandEncoder
_drawPBRTextures
_drawShadowMaps
renderSKSceneWithRenderer:overlay:atTime:
clearRenderPasses
addRenderPass:
.cxx_construct
clientRenderPassDescriptor
clientRenderCommandEncoder
clientCommandBuffer
setDebugOptions:
_device
_isValidationEnabled
_profile
_features
_wantsWideGamut
_isOpaque
_disableLinearRendering
_commandQueue
_inFlightSemaphore
_pendingGPUFrameCount
_textureTarget
_layerTarget
_drawable
_currentRenderPassDescriptor
_renderSize
_currentShaderManager
_currentCommandBuffer
_renderEncoder
_currentComputeCommandBuffer
_currentComputeEncoder
_currentBlitCommandBuffer
_currentBlitEncoder
_currentPass
_currentPassIsMirrored
_renderPasses
_currentStreamBufferIndices
_volatileBufferPools
_frameVolatileBufferPool
_volatileMeshes
_bufferPool
_usedVolatileMeshElements
_freeVolatileMeshElements
_constantBufferPools
_frameConstantBufferPool
_defaultDepthStencilState
_defaultSamplerState
_background2DProgram
_backgroundCubeProgram
_backgroundVideoProgram
_backgroundRasterizerStates
_initialTime
_resourceQueue
_resourceGroup
_shadowKernelBuffer
_processingContext
_seed
_frameUniforms
_sceneUniforms
_lightsData
_nodeUniforms
_lighting
_cache
_deferredRendering
_compositeRendering
_downSamplePipelineState
_skCompositing
_debug
_showsAuthoringEnvironment
_compilationIssues
_renderTargets
_counters
_clientRenderPassDescriptor
_clientRenderCommandEncoder
_clientCommandBuffer
_debugOptions
setFragmentBufferOffset:atIndex:
setCullMode:
setTriangleFillMode:
setFrontFacingWinding:
setDepthClipMode:
setDepthBias:slopeScale:clamp:
setViewport:
setDepthStencilState:
setVertexBuffer:offset:atIndex:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
setVertexTextures:withRange:
setVertexTexture:atIndex:
setFragmentTextures:withRange:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
setFragmentSamplerState:atIndex:
defaultProgramUsingTessellation:
renderResourceForTessellatedGeometry:
tessellationVertexLayoutHash
vertexLayoutHash
frameBufferBindings
bindBlock
passBufferBindings
bufferSize
inputsCount
referenceCount
name
renderResourceForMaterial:geometry:renderPipeline:engineContext:
shadableBufferBindings
lightBufferBindings
semanticsCount
nodeBufferBindings
instanceCount
setBlendColorRed:green:blue:alpha:
setVertexSamplerState:atIndex:
textureBarrier
stringByReplacingOccurrencesOfString:withString:
setConstantValue:type:withName:
initWithString:
javaScriptActionWithDuration:script:
_script
globalObject
setException:
evaluateScript:
exception
toString
__CFObject
postCommandWithContext:object:applyBlock:
animation
removeObjectForKey:
prepareWithTarget:implicitDuration:
animationWithCAAnimation:
animationPlayerWithSCNAnimation:
addAnimationPlayer:forKey:
play
addAnimation:forKey:
allKeys
_scnAnimationForKey:
animationWithSCNAnimation:
animationKeys
animationPlayerForKey:
animationManager
_pauseAnimation:forKey:pausedByNode:
removeAnimationForKey:blendOutDuration:
postCommandWithContext:object:keyPath:applyBlock:
URLForResource:withExtension:subdirectory:
dataWithContentsOfURL:
initForReadingWithData:
setClass:forClassName:
_syncObjCModel
_syncObjCAnimations
particleSystemRef
geometryWithGeometryRef:
setEmitterShape:
setParticleColor:
_syncEntityObjCModel
begin
setImmediateMode:
setName:
particleImage
setParticleImage:
emissionDuration
setEmissionDuration:
emissionDurationVariation
setEmissionDurationVariation:
idleDuration
setIdleDuration:
idleDurationVariation
setIdleDurationVariation:
birthRate
setBirthRate:
birthRateVariation
setBirthRateVariation:
warmupDuration
setWarmupDuration:
emitterShape
birthLocation
setBirthLocation:
birthDirection
setBirthDirection:
emittingDirection
setEmittingDirection:
orientationDirection
setOrientationDirection:
acceleration
setAcceleration:
spreadingAngle
setSpreadingAngle:
loops
setLoops:
isLocal
setIsLocal:
affectedByGravity
setAffectedByGravity:
affectedByPhysicsFields
setAffectedByPhysicsFields:
physicsCollisionsEnabled
setPhysicsCollisionsEnabled:
isLightingEnabled
setLightingEnabled:
areSoftParticlesEnabled
setSoftParticlesEnabled:
particleDiesOnCollision
setParticleDiesOnCollision:
isBlackPassEnabled
setBlackPassEnabled:
particleAngle
setParticleAngle:
particleAngleVariation
setParticleAngleVariation:
particleVelocity
setParticleVelocity:
particleVelocityVariation
setParticleVelocityVariation:
particleAngularVelocity
setParticleAngularVelocity:
particleAngularVelocityVariation
setParticleAngularVelocityVariation:
particleLifeSpan
setParticleLifeSpan:
particleLifeSpanVariation
setParticleLifeSpanVariation:
particleBounce
setParticleBounce:
particleBounceVariation
setParticleBounceVariation:
particleFriction
setParticleFriction:
particleFrictionVariation
setParticleFrictionVariation:
particleCharge
setParticleCharge:
particleChargeVariation
setParticleChargeVariation:
particleColor
particleColorVariation
setParticleColorVariation:
systemSpawnedOnCollision
setSystemSpawnedOnCollision:
systemSpawnedOnDying
setSystemSpawnedOnDying:
systemSpawnedOnLiving
setSystemSpawnedOnLiving:
particleSize
setParticleSize:
particleSizeVariation
setParticleSizeVariation:
seed
setSeed:
blendMode
setBlendMode:
renderingMode
setRenderingMode:
orientationMode
setOrientationMode:
imageSequenceAnimationMode
setImageSequenceAnimationMode:
particleGeometries
setParticleGeometries:
colliderNodes
setColliderNodes:
propertyControllers
setPropertyControllers:
sortingMode
setSortingMode:
particleMass
setParticleMass:
particleMassVariation
setParticleMassVariation:
dampingFactor
setDampingFactor:
speedFactor
setSpeedFactor:
fixedTimeStep
setFixedTimeStep:
stretchFactor
setStretchFactor:
imageSequenceRowCount
setImageSequenceRowCount:
imageSequenceColumnCount
setImageSequenceColumnCount:
imageSequenceInitialFrame
setImageSequenceInitialFrame:
imageSequenceInitialFrameVariation
setImageSequenceInitialFrameVariation:
imageSequenceFrameRate
setImageSequenceFrameRate:
imageSequenceFrameRateVariation
setImageSequenceFrameRateVariation:
referenceName
setReferenceName:
_copyAnimationsFrom:
commitImmediate
initWithParticleSystemRef:
initPresentationSystemWithSystemRef:
numberWithShort:
_updateParticleC3DImage:
softParticlesEnabled
lightingEnabled
blackPassEnabled
postCommandWithContext:object:key:applyBlock:
containsValueForKey:
_isAReference
_customEncodingOfSCNParticleSystem:
encodeDouble:forKey:
encodeInteger:forKey:
assetCatalog
particleSystemNamed:
immediateMode
_customDecodingOfSCNParticleSystem:
decodeDoubleForKey:
decodeIntegerForKey:
setParticleIntensity:
setParticleIntensityVariation:
setFresnelExponent:
particleSystem
particleSystemNamed:inDirectory:
particleSystemWithParticleSystemRef:
removeAllAnimations
removeAnimationForKey:
removeAnimationForKey:fadeOutDuration:
animationForKey:
pauseAnimationForKey:
resumeAnimationForKey:
setSpeed:forAnimationKey:
isAnimationForKeyPaused:
setIdentifier:
__removeAnimation:forKey:
addAnimation:
_scnBindings
bindAnimatablePath:toObject:withKeyPath:options:
unbindAnimatablePath:
presentationInstance
isPausedOrPausedByInheritance
typeOfProperty:
_setParticleImagePath:withResolvedPath:
setLocal:
fresnelExponent
particleIntensity
particleIntensityVariation
reset
handleEvent:forProperties:withBlock:
addModifierForProperties:atStage:withBlock:
removeModifiersOfStage:
removeAllModifiers
_particleSystem
_isPresentationInstance
_animations
_bindings
_name
_emissionDuration
_emissionDurationVariation
_idleDuration
_idleDurationVariation
_birthRate
_birthRateVariation
_warmupDuration
_emitterShape
_birthLocation
_birthDirection
_emittingDirection
_orientationDirection
_acceleration
_spreadingAngle
_loops
_isLocal
_affectedByGravity
_affectedByPhysicsFields
_physicsCollisionsEnabled
_lightingEnabled
_softParticlesEnabled
_particleDiesOnCollision
_blackPassEnabled
_particleAngle
_particleAngleVariation
_particleVelocity
_particleVelocityVariation
_particleAngularVelocity
_particleAngularVelocityVariation
_particleLifeSpan
_particleLifeSpanVariation
_particleBounce
_particleBounceVariation
_particleFriction
_particleFrictionVariation
_particleCharge
_particleChargeVariation
_particleImage
_particleColor
_particleColorVariation
_systemSpawnedOnCollision
_systemSpawnedOnDying
_systemSpawnedOnLiving
_particleSize
_particleSizeVariation
_particleIntensity
_particleIntensityVariation
_blendMode
_renderingMode
_orientationMode
_imageSequenceAnimationMode
_particleGeometries
_colliderNodes
_propertyControllers
_sortingMode
_particleMass
_particleMassVariation
_dampingFactor
_speedFactor
_fixedTimeStep
_stretchFactor
_fresnelExponent
_imageSequenceColumnCount
_imageSequenceRowCount
_imageSequenceInitialFrame
_imageSequenceInitialFrameVariation
_imageSequenceFrameRate
_imageSequenceFrameRateVariation
_referenceName
valueForKey:
setC3dAnimation:
inputScale
inputBias
inputOrigin
inputMode
inputProperty
defaultUICatalogForBundle:
namedTextureWithName:scaleFactor:
size
isTextureKnown:
textureForName:
bundlePath
resourcePath
fileURLWithPath:
pathForResource:ofType:
initByReferencingFile:
panel
setDisplaysWhenScreenProfileChanges:
setMovableByWindowBackground:
sharedColorPanel
setShowsAlpha:
setObjectController:
setEnabled:
defaultCenter
selectionDidChange:
addObserver:selector:name:object:
expandItem:
rootNode
set_showsAuthoringEnvironment:
antialiasingMode
selectItemAtIndex:
selectAuthoringDisplayMask:
processName
stringByExpandingTildeInPath
writeToURL:options:delegate:progressHandler:
sharedWorkspace
openFile:
openGLContext
view
renderingAPI
layer
backingScaleFactor
setContentsScale:
setWantsBestResolutionOpenGLSurface:
_reshape
setDisableOverlays:
recompilePasses
camera
childNodesPassingTest:
setPointOfView:animate:
setPointOfCulling:
set_superSamplingFactor:
setAntialiasingMode:
_runFPSTestWithDuration:
setStringValue:
setFrozen:
setMaxValue:
setFloatValue:
setNumberOfTickMarks:
setAllowsTickMarkValuesOnly:
updateSeek
savePanel
setAllowedFileTypes:
runModal
TIFFRepresentation
writeToURL:atomically:
rendererWithDevice:options:
setScene:
endTime
enumerateHierarchyUsingBlock:
setEndTime:
_backingSize
renderMovieToURL:size:antialiasingMode:attributes:error:
menu
itemArray
setState:
_expandItem:
rowForItem:
indexSetWithIndex:
selectRowIndexes:byExtendingSelection:
scrollRowToVisible:
selectInstance:propertyName:
childNodes
selectionWillChange
willChangeValueForKey:
unbind
selection
didChangeValueForKey:
selectedNode
_authoringEnvironment
selectedRow
itemAtRow:
rendererContext
setView:
archiveToDesktop:
enableVBL:
toggleRetina:
hideSpriteKitOverlaysToggled:
disablePassesToggle:
selectCamera:
selectPointOfCulling:
comboBox:objectValueForItemAtIndex:
numberOfItemsInComboBox:
setSuperSampling:
setAntialiasingLevel:
runBench:
capture:
seekStep
setSeekStep:
close:
isolate:
exportAs:
inspectCamera:
showManipulators
_3dView
_panel
antialiasingLevels
displayOptions
benchResult
seekSlider
seekStepper
isolate
freezeButton
_sceneGraph
_inspector
pointOfViewComboBox
pointOfCullingComboBox
_viewLocked
_currentSeekStep
unsignedIntegerValue
_preTick:
commonInit
_willRemoveFromPhysicsWorld
wakeUpAllBodies
bodyA
_activate
bodyB
removeBehavior:
substringToIndex:
parseSpecialKey:withPath:intoDestination:
valueForUndefinedKey:
initWithResult:
_rayTestWithSegmentFromPoint:toPoint:options:
arrayWithObject:
clearAllForces
resetTransform
setAngularVelocity:
_setWorld:
_createDynamicWorldIfNeeded
hasReferenceToPhysicsBody:
addBehavior:
_customEncodingOfSCNPhysicsWorld:
_customDecodingOfSCNPhysicsWorld:
setGravity:
setScale:
setTimeStep:
_didDecodeSCNPhysicsWorld:
_physicsContact
initWithScene:
sceneWillDie
_isDefault
gravity
scale
timeStep
contactDelegate
setContactDelegate:
removeAllBehaviors
objectInAllBehaviorsAtIndex:
allBehaviors
rayTestWithSegmentFromPoint:toPoint:options:
contactTestBetweenBody:andBody:options:
contactTestWithBody:options:
convexSweepTestWithShape:fromTransform:toTransform:options:
updateCollisionPairs
_needsRedraw
enumerateBodiesUsingBlock:
_reset
_addFieldToWorld:
_removeFieldFromWorld:
_aetherHandle
_step:
_defaultVehicleRayCaster
addPhysicsBody:nodeRef:colGroup:colMask:colTest:
removePhysicsBody:handle:
_ghostPairCallback
_vehicleRayCaster
_debugDrawer
_aether
_hasActiveFields
_contactDelegate
_contact
_scene
_gravity
_speed
_scale
_timeStep
_fields
_elapsedTime
_behaviors
_bodies
physicsBody
categoryBitMask
collisionBitMask
contactTestBitMask
_contactWithManifold:index:
_prepareUpdate
physicsWorld:didBeginContact:
physicsWorld:didUpdateContact:
physicsWorld:didEndContact:
_fillNodeA:nodeB:contactPoint:collisionImpulse:distance:hitFraction:
_shouldPostUpdate
clearCaches
generatorWithProfile:
deferredGeneratorWithProfile:
programWithHashCode:engineContext:trackedResource:introspectionDataPtr:
renderTargetRegistry
currentFrameIndex
screen
deviceDescription
SCN_displayLinkCallback:
initWithDisplayID:queue:block:
SCN_setupDisplayLinkWithQueue:
initWithMTLTexture:options:
initWithDescription:size:arrayLength:
viewportDependant
renderBufferFormat
matchesDescription:size:arrayLength:
ciImage
setReferenceCount:
timeStamp
setTimeStamp:
_description
_size
_arrayLength
_ciImage
_texture
_referenceCount
_timeStamp
initWithContext:
cgl_ctx
rendererOptions
_initWithOptions:isPrivateRenderer:privateRendererOwner:clearsOnDraw:context:renderingAPI:
setRenderer:
CGColor
setBackgroundColor:
setNeedsDisplayOnBoundsChange:
initWithLayer:
_glContextDidChange
removeObserver:
setShowsStatistics:
showsStatistics
setAsynchronous:
isPlaying
_nextFrameTime
_pauseDisplayLink
_resumeDisplayLinkForDelayedFrame
cancelPreviousPerformRequestsWithTarget:selector:object:
isAsynchronous
_resumeDisplayLink
_resumeDisplayLinkIfNeeded
_pauseDisplayLinkIfPossible
setPointOfView:
setNeedsDisplay
pointOfCulling
sceneTime
frame
autoenablesDefaultLighting
setAutoenablesDefaultLighting:
_hitTest:viewport:options:
hitTestWithSegmentFromPoint:toPoint:options:
_isNodeInsideFrustum:withPointOfView:viewport:
_nodesInsideFrustumWithPointOfView:viewport:
CGLContext
setContext:
prepareObject:shouldAbortBlock:
prepareObjects:withCompletionHandler:
_projectPoints:count:viewport:
_projectPoint:viewport:
_unprojectPoint:viewport:
colorWithCGColor:
isJitteringEnabled
setJitteringEnabled:
setAnimationDuration:
_prepareForTransition:outgoingScene:outgoingPointOfView:completionHandler:
removeObserver:name:object:
setScene:completionHandler:
_sceneDidUpdate:
setSceneTime:
setPlaying:
_stop
_needsRepetitiveRedraw
restart
overlaySKScene
setOverlaySKScene:
audioEngine
audioEnvironmentNode
audioListener
setAudioListener:
setTechnique:
technique
stopIfNeeded
_drawWithJitteringPresentationMode
timeOffset
beginTime
_setBackingSize:
_drawAtTime:
_checkAndUpdateDisplayLinkStateIfNeeded
setWithObjects:
keyPathsForValuesAffectingValueForKey:
_kvoKeysForwardedToRenderer
setWithObject:
setByAddingObjectsFromSet:
automaticallyNotifiesObserversForKey:
isEnabled
play:
stop:
pause:
_systemTime
_antialiasingMode
snapshotAtTime:withSize:antialiasingMode:
presentScene:withTransition:incomingPointOfView:completionHandler:
hitTest:options:
isNodeInsideFrustum:withPointOfView:
nodesInsideFrustumWithPointOfView:
projectPoint:
unprojectPoint:
colorPixelFormat
depthPixelFormat
stencilPixelFormat
currentTime
setCurrentTime:
initWithRenderer:sharedContext:
rendersIntoMaterial
setRendersIntoMaterial:
projectPoints:count:
copyCGLPixelFormatForDisplayMask:
copyCGLContextForPixelFormat:
canDrawInCGLContext:pixelFormat:forLayerTime:displayTime:
drawInCGLContext:pixelFormat:forLayerTime:displayTime:
_systemTimeAnimationStarted:
contentLayer
scn_inLiveResize
_canJitter
_supportsJitteringSyncRedraw
stop
pause
_jitterer
_renderer
_mainContext
_drawForJittering
_rendersIntoMaterial
contentsScale
stringWithCString:encoding:
regularExpressionWithPattern:options:error:
matchesInString:options:range:
rangeAtIndex:
substringWithRange:
lowercaseString
setController:
controller
canBecomeKeyWindow
canBecomeMainWindow
_controller
setValueTransformer:forName:
initByReferencingURL:
initialize
transformedValueClass
allowsReverseTransformation
transformedValue:
reverseTransformedValue:
_program
_owners
initWithProfile:
emptyShaderCache
releaseProgramForResource:
_programMutex
_shaders
_trackedResourcesToHashcode
contextWithMTLDevice:
contextWithCGLContext:pixelFormat:colorSpace:options:
stringValue
vectorWithValues:count:
filterWithName:
setDefaults
vectorWithX:Y:Z:W:
extent
render:toMTLTexture:commandBuffer:bounds:colorSpace:
drawImage:inRect:fromRect:
initWithTexture:size:flipped:colorSpace:
currentContext
initWithShareContext:
textureWithName:scaleFactor:bundle:options:error:
setNode:
setComponent:
elementIndex
addItems:toScene:
removeItemsFromScene:
setScreenSize:
isNodeManipulator
setTransform:
worldTransform
setPosition:
parentItem
cloneForManipulators
validateClone
setElementIndex:
_screenSize
clone
setGizmo:
convertTransform:toNode:
addChildNode:
removeFromParentNode
jitter
_jitterAtStep:updateMainFramebuffer:redisplay:jitterer:
initWithDelegate:
delegateWillDie
isAborting
_enabled
_state
_iteration
_restartSourceIsSuspended
_restartSource
numberWithUnsignedShort:
setFastMathEnabled:
setPreprocessorMacros:
setThreadGroupSizeIsMultipleOfThreadExecutionWidth:
computePipelineForSourceCode:functionName:compileOptions:
setBufferOffset:atIndex:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
dataWithBytes:length:
initWithData:topLeftOrigin:name:dimensions:rowStride:channelCount:channelEncoding:isCube:
imageFromTexture
isCube
matrix
initWithMatrix:
children
initThroughSCNKitBridgeWithURL:preserveTopology:error:
sceneWithMDLAsset:options:
objectWithSCNNode:
jointPaths
jointBindTransforms
bytes
meshBindTransform
valueWithSCNMatrix4:
vertexCount
vertexAttributeDataForAttributeNamed:
dataStart
format
geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
animationWithKeyPath:
setValues:
setKeyTimes:
setBeginTime:
setAdditive:
setRemovedOnCompletion:
setAnimations:
shapeSetTargetCounts
targetShapes
geometryWithMDLMesh:
weights
elementCount
keyTimes
getFloatArray:maxCount:atTime:
setWeights:
setChannelTargetCounts:
shapeSetTargetWeights
setChannelTargetWeights:
morpher
isAnimated
timeSampleCount
getTimes:maxCount:
getFloatArray:maxCount:
setUsesSceneTimeBase:
setRepeatCount:
upAxis
valueWithSCNVector3:
setAttribute:forKey:
nodeWithMDLObject:masterObjects:sceneNodes:skinnedMeshes:options:
_addSkinnerWithMDLMesh:sceneNodes:
_resetSceneTimeRange
sceneWithMDLAsset:
assetWithSCNNode:
assetWithSCNNode:bufferAllocator:
initWithBufferAllocator:
objectWithSCNNode:bufferAllocator:
assetWithSCNScene:
assetWithSCNScene:bufferAllocator:
setMatrix:
cameraWithSCNCamera:
addChild:
light
lightProbeWithSCNLight:node:
lightWithSCNLight:
geometry
meshWithSCNGeometry:bufferAllocator:
geometrySourceChannels
geometrySources
semantic
indexOfObjectPassingTest:
geometrySourcesForSemantic:
vectorCount
setFormat:
setBufferIndex:
dataOffset
dataStride
setStride:
data
newBufferWithData:type:
firstMaterial
multiply
mappingChannel
selfIllumination
geometryElementCount
materials
geometryElementAtIndex:
submeshWithSCNGeometryElement:bufferAllocator:positionSourceChannel:
materialWithSCNMaterial:
setMaterial:
initWithVertexBuffers:vertexCount:descriptor:submeshes:
flipTextureCoordinatesInAttributeNamed:
meshWithSCNGeometry:
newSubmeshWithSCNGeometryElement:bufferAllocator:
newSubmeshWithSCNGeometryElement:bufferAllocator:positionSourceChannel:
dataWithLength:
mutableBytes
initWithName:indexBuffer:indexCount:indexType:geometryType:material:topology:
subdataWithRange:
hasInterleavedIndicesChannels
indicesChannelCount
bytesPerIndex
newSubmeshWithGeometryData:indexBufferLength:interleaved:channelCount:channelIdx:bytesPerIndex:indexType:geometryType:allocator:indexCount:topology:
initWithType:data:
setFaceCount:
setFaceTopology:
submeshWithSCNGeometryElement:
submeshWithSCNGeometryElement:bufferAllocator:
initWithName:scatteringFunction:
ambient
diffuse
specular
reflective
transparent
metalness
roughness
displacement
normal
isDoubleSided
setMaterialFace:
setColorSpace:
setColor:
attenuationStartDistance
setAttenuationStartDistance:
attenuationEndDistance
setAttenuationEndDistance:
attenuationFalloffExponent
setAttenuationFalloffExponent:
spotInnerAngle
setInnerConeAngle:
spotOuterAngle
setOuterConeAngle:
setLightType:
focusDistance
setFocusDistance:
sensorHeight
setSensorVerticalAperture:
apertureBladeCount
setApertureBladeCount:
useLegacyFov
yFov
fieldOfView
setFieldOfView:
aspectRatio
setSensorAspect:
zNear
setNearVisibilityDistance:
zFar
setFarVisibilityDistance:
focalBlurRadius
setMaximumCircleOfConfusion:
fStop
setFStop:
usesOrthographicProjection
setProjection:
nodeWithMDLObject:
submeshes
faceIndexing
geometryType
geometryWithMDLMesh:submesh:
setGeometry:
lightWithMDLLight:
setLight:
lightWithMDLLightProbe:
cameraWithMDLCamera:
setCamera:
transformAnimation
componentConformingToProtocol:
setMorpher:
copyJointBindTransformsInto:maxCount:
hidden
setHidden:
skinnerWithBaseGeometry:bones:boneInverseBindTransforms:boneWeights:boneIndices:
setSkinner:
UUID
UUIDString
generateAmbientOcclusionVertexColorsWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:
generateAmbientOcclusionTextureWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
generateLightMapVertexColorsWithLightsToConsider:objectsToConsider:vertexAttributeNamed:
generateLightMapTextureWithQuality:lightsToConsider:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:
_updateAssociatedSCNNodeWithGeometrySetter:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:
_associatedMDLObject
_bakeNodes:folderPath:inVertex:bakeAO:quality:attenuation:geomSetter:terminateSetter:
nodeWithMDLAsset:
containsString:
vertexBuffers
setMkSemantic:
geometrySourceWithMDLVertexAttribute:mesh:
geometryElementWithMDLSubmesh:
material
materialWithMDLMaterial:
geometryWithSources:elements:
setSubdivisionLevel:
setEdgeCreasesElement:
setEdgeCreasesSource:
setMaterials:
topology
initWithArray:copyItems:
geometryWithSources:elements:sourceChannels:
morpherWithMDLMesh:
faceTopology
faceCount
setLength:
appendBytes:length:
geometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
propertyNamed:
textureSamplerValue
writeToURL:
setString:
mkSemantic
ambientOcclusion
setMappingChannel:
setContents:
scatteringFunction
setLightingModelName:
materialFace
setDoubleSided:
propertyWithSemantic:
setShininess:
_integrateModelKitComputedMaps:withGeometry:node:texturePathProvider:vertexAttributeNamed:materialPropertyNamed:filePath:
innerConeAngle
setSpotInnerAngle:
outerConeAngle
setSpotOuterAngle:
colorWithRed:green:blue:alpha:
lightType
setType:
sensorVerticalAperture
setSensorHeight:
sensorAspect
setAspectRatio:
nearVisibilityDistance
setZNear:
farVisibilityDistance
setZFar:
setFocalBlurRadius:
projection
setUsesOrthographicProjection:
focalLengthAnimation
isSubclassOfClass:
values
setKeyPath:
focalDistanceAnimation
fStopAnimation
_associatedSCNNode
scn_C3DColorIgnoringColorSpace:success:
initWithName:semantic:float3:
initWithName:semantic:URL:
initWithName:semantic:string:
getC3DImageRef
initWithName:semantic:textureSampler:
setProperty:
edgeCreases
edgeCreaseIndices
edgeCreaseCount
vertexCreases
vertexCreaseIndices
vertexCreaseCount
attributeNamed:
URLValue
absoluteString
_setImagePath:withResolvedPath:
hardwareFilter
sWrapMode
setWrapS:
tWrapMode
setWrapT:
setContentsTransform:
float4Value
float3Value
geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
rangeValue
stringWithString:
techniquesDidUpdate:
reParsePasses
_defaultPixelFormat
setValues:forParameter:
setSourceContext:
removeAllItems
selectedItem
title
fxContext
addItemWithTitle:
selectTarget:
updateTargets
currentTexture
setAutoenablesItems:
lastItem
selectPass:
_passes
_target
_targetView
planeWithWidth:height:
setRotation:
blackColor
emission
isSelectedForSegment:
setSelected:forSegment:
setShaderModifiers:
renderer:willRenderScene:atTime:
renderer:didRenderScene:atTime:
setFilterChannel:
sourceContext
_filterChannel
_plane
_sourceContext
runBlock:queue:
updateWithTarget:forTime:
_block
_queue
setReferenceURL:
initWithURL:
enumerateNodesUsingBlock:
_isNameUnique:
_diffObject:with:path:
properties
slotName
particleSystems
_diffNode:with:path:
removeAllOverrides
_resolveURL
_loadReferencedSceneWithURL:catalog:
setValue:forKeyPath:
rangeOfString:options:
valueForKeyPath:
removeParticleSystem:
addParticleSystem:
_applyUnsharing:alreadyShared:
replaceMaterialAtIndex:withMaterial:
_applyOverride:forKeyPath:
setLoadingPolicy:
assetCatalogWithURL:
bundleURL
scheme
relativePath
isAbsolutePath
URLByAppendingPathComponent:
_loadWithCatalog:
sceneWithURL:options:error:
_catalog
sceneWithURL:
_loadWithURL:catalog:
_applyOverrides
catalogURL
documentURL
referenceNodeWithURL:
collectOverrides
addOverride:forKeyPath:
removeForKeyPath:
overrides
setOverrides:
setOverride:forKeyPath:
referenceURL
unload
isLoaded
load
_loadWithURL:
loadingPolicy
_referenceURL
_loaded
_overrides
_loadingPolicy
_catalogURL
_sourceDocumentURL
_reloadWithScene:
referenceSceneName
setReferenceSceneName:
referenceNodeName
setReferenceNodeName:
repeatCount
encodeFloat:forKey:
repeatDuration
usesSceneTimeBase
decodeFloatForKey:
setRepeatDuration:
animationNamed:
actionNamed:
setupWithActions:
componentsSeparatedByString:
deviceForOptions:
setDevice:
setFramebufferOnly:
invalidate
isMainThread
_renderingQueue
setPaused:
setPreferredFrameRate:
displayLink
setPaused:nextFrameTimeHint:lastUpdate:
preferredFrameRate
colorUsingColorSpaceName:
getRed:green:blue:alpha:
setOpaque:
convertTime:fromLayer:
_displayLinkStatsTick
set_viewport:
_getFrameIndex
_prepareFrame:
_beginFrame
_presentFramebuffer
_displayLinkStatsTack
set_antialiasingMode:
preferredFramesPerSecond
setPreferredFramesPerSecond:
pauseDisplayLink
resumeDisplayLink
_isGLLayerBacked
scn_backingLayer
syncTimeWithCoreAnimation
setSyncTimeWithCoreAnimation:
_displayLink
_preferredFramePerSeconds
_lastUpdate
_lastRenderedTime
_syncTimeWithCoreAnimation
objectClass
setObjectClass:
initWithData:
constantToString
setConstantToString:
instanceWillChange
instanceDidChange
clear
initWithTitle:action:keyEquivalent:
setRepresentedObject:
systemFontOfSize:
setAttributedTitle:
stackControl
setPathItems:
updateStackControl
setup
SCNUID_rangeForFloatProperty:min:max:
bind:toObject:withKeyPath:options:
SCNUID_constantToStringForProperty:
constantPopupChanged:
setButtonType:
setTitle:
setBezelStyle:
valueWithSize:
valueWithSCNVector4:
setEditable:
setImageFrameStyle:
contentsChanged:
arrayEditor
SCNUID_classForElementOfArray:
bindTo:withKeyPath:valueTransformerName:
colorChanged:
setAllowsCreation:
setAlternateTitle:
objectHandleClicked:
setRemoveButton:
removeObjectClicked:
SCNUID_enumForProperty:
popupChanged:
setFormatter:
filterPropertyName:ofClass:
SCNUID_creationOptions
setControlSize:
setBordered:
setToolTip:
addUIForFloatProperty:ofClass:
addUIForVec2Property:
addUIForVec3Property:
addUIForVec4Property:
addUIForMat4Property:
addUIForContentsProperty:
addUIForImageProperty:
addUIForColorProperty:
addUIForArrayProperty:ofClass:
addUIForObjectProperty:
addUIForBoolProperty:
addUIForStringProperty:ofClass:
addUIForIntProperty:ofClass:
setFrameOrigin:
setFrameSize:
setBoxType:
SCNUID_propertyOrdering
SCNUID_propertiesToFilterOut
addUIForProperty:ofClass:instance:
enclosingScrollView
scrollPoint:
allocationMenuForClass:propertyName:
currentEvent
popUpContextMenu:withEvent:forView:
didInstanciateNewElementInArray:
representedObject
numberWithInteger:
alternateTitle
SCNUID_instanciateWithOption:
initWithTitle:
newInstanceMenuClicked:
addItemWithTitle:action:keyEquivalent:
pathControlItemForInstance:
clickedPathItem
pathItems
menuItemForInstance:propertyName:
instanceNewElementInArray:withPropertyName:
array:didSelect:atIndex:
stackSelectionChanged:
pathControlClicked:
objectController
setStackControl:
_modelPath
_modelPathComponents
_stack
_pendingAllocationListener
_objectController
unbind:
SCNUID_additionalProperties
cell
systemFontSizeForControlSize:
font
fontName
setFont:
nextKeyView
setNextKeyView:
initWithBodyA:frameA:bodyB:frameB:
initWithBody:frame:
jointWithBodyA:frameA:bodyB:frameB:
jointWithBody:frame:
frameA
setFrameA:
frameB
setFrameB:
maximumAngularLimit1
setMaximumAngularLimit1:
maximumAngularLimit2
setMaximumAngularLimit2:
maximumTwistAngle
setMaximumTwistAngle:
_constraint
setAnimation:
setInputMode:
setInputScale:
setInputBias:
setInputOrigin:
setInputProperty:
_customEncodingOfSCNParticlePropertyController:
_customDecodingOfSCNParticlePropertyController:
particlePropertyControllerWithAnimation:
controllerWithAnimation:
c3dAnimation
_animation
_inputMode
_inputScale
_inputBias
_inputOrigin
_inputProperty
_c3dAnimation
initWithPixelBufferAttributes:
discardVideoData
currentItem
removeOutput:
addOutput:
itemTimeForHostTime:
hasNewPixelBufferForItemTime:
copyPixelBufferForItemTime:itemTimeForDisplay:
setPlayer:
player
connectToProxy:
cleanup:
metalTextureWithEngineContext:textureSampler:nextFrameTime:
_player
_videoOutput
_textureCache
_pixelBuffer
_mtlTexture
_width
_height
customActionWithDuration:actionBlock:
waitForDuration:withRange:
willStartWithTarget:atTime:
setFinished:
_hasFired
initWithCameraRef:
parentWillDie:
setXFov:
setYFov:
_updateFocalLength
techniqueRef
cameraRef
techniqueWithTechniqueRef:
initPresentationCameraWithCameraRef:
presentationCamera
dofIntensity
setDofIntensity:
_updateFov
projectionDirection
setProjectionDirection:
orthographicScale
setOrthographicScale:
projectionTransformWithViewportSize:
initWithParent:propertyType:
wantsDepthOfField
setWantsDepthOfField:
focalBlurSampleCount
setFocalBlurSampleCount:
focalSize
setFocalSize:
xFov
fillMode
setFillMode:
automaticallyAdjustsZRange
setAutomaticallyAdjustsZRange:
wantsHDR
setWantsHDR:
whitePoint
setWhitePoint:
averageGray
setAverageGray:
wantsExposureAdaptation
setWantsExposureAdaptation:
exposureAdaptationDuration
setExposureAdaptationDuration:
exposureAdaptationBrighteningSpeedFactor
setExposureAdaptationBrighteningSpeedFactor:
exposureAdaptationDarkeningSpeedFactor
setExposureAdaptationDarkeningSpeedFactor:
exposureAdaptationHistogramRangeLowProbability
setExposureAdaptationHistogramRangeLowProbability:
exposureAdaptationHistogramRangeHighProbability
setExposureAdaptationHistogramRangeHighProbability:
exposureAdaptationMode
setExposureAdaptationMode:
minimumExposure
setMinimumExposure:
maximumExposure
setMaximumExposure:
bloomIntensity
setBloomIntensity:
bloomThreshold
setBloomThreshold:
bloomBlurRadius
setBloomBlurRadius:
vignettingPower
setVignettingPower:
vignettingIntensity
setVignettingIntensity:
colorFringeStrength
setColorFringeStrength:
colorFringeIntensity
setColorFringeIntensity:
saturation
setSaturation:
contrast
setContrast:
motionBlurIntensity
setMotionBlurIntensity:
screenSpaceAmbientOcclusionIntensity
setScreenSpaceAmbientOcclusionIntensity:
screenSpaceAmbientOcclusionRadius
setScreenSpaceAmbientOcclusionRadius:
screenSpaceAmbientOcclusionBias
setScreenSpaceAmbientOcclusionBias:
screenSpaceAmbientOcclusionDepthThreshold
setScreenSpaceAmbientOcclusionDepthThreshold:
screenSpaceAmbientOcclusionNormalThreshold
setScreenSpaceAmbientOcclusionNormalThreshold:
screenSpaceAmbientOcclusionSampleCount
setScreenSpaceAmbientOcclusionSampleCount:
screenSpaceAmbientOcclusionDownSample
setScreenSpaceAmbientOcclusionDownSample:
setProjectionTransform:
_customEncodingOfSCNCamera:
encodeInt:forKey:
decodeIntForKey:
setCategoryBitMask:
setExposureOffset:
_didDecodeSCNCamera:
cameraWithCameraRef:
keyPathsForValuesAffectingFieldOfView
keyPathsForValuesAffectingFocalLength
_registerAsObserver
hasCustomProjectionTransform
exposureOffset
focalLength
setFocalLength:
aperture
setAperture:
fieldOfViewOrientation
setFieldOfViewOrientation:
xMag
setXMag:
yMag
setYMag:
projectionTransform
colorGrading
copyAnimationChannelForKeyPath:animation:
focalDistance
setFocalDistance:
_camera
_custom
_legacyFov
_usesOrthographicProjection
_automaticallyAdjustsZRange
_fillMode
_projectionDirection
_xFov
_yFov
_orthographicScale
_zNear
_zFar
_fieldOfView
_focalLength
_sensorSize
_fStop
_focusDistance
_dofIntensity
_bladeCount
_focalBlurSampleCount
_aspectRatio
_categoryBitMask
_projectionTransform
_technique
_colorGrading
_wantsHDR
_whitePoint
_averageGray
_exposureOffset
_minimumExposure
_maximumExposure
_wantsExposureAdaptation
_exposureAdaptationDuration
_exposureAdaptationBrighteningSpeedFactor
_exposureAdaptationDarkeningSpeedFactor
_exposureAdaptationHistogramRangeHighProbability
_exposureAdaptationHistogramRangeLowProbability
_exposureAdaptationMode
_bloomIntensity
_bloomThreshold
_bloomBlurRadius
_motionBlurIntensity
_vignettingPower
_vignettingIntensity
_colorFringeStrength
_colorFringeIntensity
_saturation
_contrast
_screenSpaceAmbientOcclusion
getControlPointAtIndex:values:
functionWithControlPoints::::
scn_colorWithC3DColor:
SCN_simdMatrix4Value
SCN_arrayWithSimdMatrix4:
SCNVector3Value
SCNVector4Value
SCNMatrix4Value
valueWithBytes:objCType:
getValue:
valueWithRect:
valueWithCATransform3D:
CATransform3DValue
SCN_CGPointValue
SCN_valueWithCGPoint:
SCN_valueWithSimdMatrix4:
stringByResolvingSymlinksInPath
defaultManager
attributesOfItemAtPath:error:
globalGLSharedContext
setGlobalGLSharedContext:
initWithLightRef:
initPresentationLightWithLightRef:
presentationLight
intensity
setIntensity:
shadowColor
setShadowColor:
shadowRadius
setShadowRadius:
castsShadow
setCastsShadow:
shadowSampleCount
setShadowSampleCount:
maximumShadowDistance
setMaximumShadowDistance:
automaticallyAdjustsShadowProjection
setAutomaticallyAdjustsShadowProjection:
shadowCascadeCount
setShadowCascadeCount:
gobo
copyPropertiesFrom:
setSpotFalloffExponent:
spotFalloffExponent
sphericalHarmonicsCoefficients
setSphericalHarmonicsCoefficients:
forcesBackFaceCasters
setForcesBackFaceCasters:
usesDeferredShadows
usesModulatedMode
setUsesDeferredShadows:
setUsesModulatedMode:
initWithIESProfile:
computeSceneKitRenderingTexture:
dimensions
encodeInt32:forKey:
setSampleDistributedShadowMaps:
setShadowCascadeSplittingFactor:
_customEncodingOfSCNLight:
_customDecodingOfSCNLight:
setBaked:
setShouldBakeDirectLighting:
setShouldBakeIndirectLighting:
set_sphericalHarmonics:
setTemperature:
sizeValue
setShadowMapSize:
setShadowBias:
setIESProfileURL:
_didDecodeSCNLight:
lightWithLightRef:
lightRef
copyAnimationChannelForKeyPath:property:
attributeForKey:
_probeTexture
set_probeTexture:
_sphericalHarmonics
shouldBakeDirectLighting
shouldBakeIndirectLighting
isBaked
shadowBias
shadowMapSize
temperature
forceBackFaceCasters
setForceBackFaceCasters:
adjustsShadowProjection
setAdjustsShadowProjection:
sampleDistributedShadowMaps
shadowCascadeSplittingFactor
_shadowCascadeDebugFactor
set_shadowCascadeDebugFactor:
shadowMode
setShadowMode:
IESProfileURL
_light
_goboProjectShadows
_castsShadow
_usesDeferredShadows
_usesModulatedMode
_baked
_shouldBakeDirectLighting
_shouldBakeIndirectLighting
_automaticallyAdjustsShadowProjection
_forcesBackFaceCasters
_sampleDistributedShadowMaps
_type
_color
_shadowColor
_shadowRadius
_intensity
_temperature
_shadowMapSize
_shadowSampleCount
_shadowCascadeCount
_maximumShadowDistance
_shadowCascadeSplittingFactor
_cascadeDebugFactor
_shadowBias
_attenuationStartDistance
_attenuationEndDistance
_attenuationFalloffExponent
_spotInnerAngle
_spotOuterAngle
_spotFalloffExponent
_gobo
_ies
_IESProfileURL
sphericalHarmonicsLevel
initWithMaterialRef:
ownerWillDie
materialRef
setVertexShader:
setTessellationControlShader:
setTessellationEvaluationShader:
setGeometryShader:
setFragmentShader:
setProgram:
initPresentationMaterialWithMaterialRef:
presentationMaterial
commonProfile
_materialPropertyClass
_setColor:
_setC3DImageRef:
_setupContentsFromC3DImage
builtinProperties
customMaterialProperties
arrayByAddingObjectsFromArray:
_setupMaterialProperty:
presentationMaterialProperty
_property:
isLitPerPixel
stringByAppendingFormat:
setValue:forUndefinedKey:
_copyAttributes:
shininess
transparency
setTransparency:
transparencyMode
setTransparencyMode:
lightingModelName
setLitPerPixel:
cullMode
program
locksAmbientWithDiffuse
setLocksAmbientWithDiffuse:
avoidsOverLighting
setAvoidsOverLighting:
writesToDepthBuffer
setWritesToDepthBuffer:
readsFromDepthBuffer
setReadsFromDepthBuffer:
colorBufferWriteMask
setColorBufferWriteMask:
shaderModifiers
unlinkCustomPropertyWithParent:
linkCustomPropertyWithParent:andCustomName:
effectSlot
initWithOwner:
_setupShadableHelperIfNeeded
shaderModifiersArgumentsNames
handleBindingOfSymbol:usingBlock:
handleUnbindingOfSymbol:usingBlock:
_shadableSetValue:forUndefinedKey:
objectWithName:class:
_setAttributes:
_customEncodingOfSCNMaterial:
_customDecodingOfSCNMaterial:
setIndexOfRefraction:
setSelfIlluminationOcclusion:
materialWithMaterialRef:
materialWithColor:
materialWithContents:
accessInstanceVariablesDirectly
resolveInstanceMethod:
materialNamed:
indexOfRefraction
selfIlluminationOcclusion
litPerPixel
content
setContent:
doubleSided
materialRefCreateIfNeeded
customMaterialPropertyNames
customMaterialAttributeNames
customMaterialAttributes
_material
_ambient
_diffuse
_specular
_emission
_reflective
_transparent
_multiply
_normal
_ambientOcclusion
_selfIllumination
_metalness
_roughness
_displacement
_valuesForUndefinedKeys
_shininess
_transparency
_indexOfRefraction
_selfIlluminationOcclusion
_transparencyMode
_lightingModelName
_cullMode
_shadableHelper
_litPerPixel
_doubleSided
_locksAmbientWithDiffuse
_avoidsOverLighting
_writesToDepthBuffer
_readsFromDepthBuffer
_colorBufferWriteMask
objCType
_setParent:
physicsField
_removeOwner
_ownerWillDie
initPresentationNodeWithNodeRef:
presentationNode
defaultCStringEncoding
cStringUsingEncoding:
_dump:
_dumpNodeTree:tab:
position
eulerAngles
setEulerAngles:
rotation
orientation
setOrientation:
pivot
setPivot:
isHidden
renderingOrder
setRenderingOrder:
movabilityHint
setMovabilityHint:
rendererDelegate
setRendererDelegate:
skinner
setPhysicsField:
constraints
setConstraints:
setAuthoringEnvironmentNode:
focusBehavior
setFocusBehavior:
setAuthoringEnvironmentCompanionNode:
isGizmo
actionKeys
actionForKey:
runAction:forKey:
setPhysicsBody:
_copyRecursively
_initChildNodesArray
_expandChildArrayIfNeeded
initWithNodeRef:
childNodeWithName:recursively:
_childNodesPassingTest:recursively:output:
childNodesPassingTest:recursively:
_enumerateChildNodesUsingBlock:
enumerateChildNodesUsingBlock:
_childNodesWithAttribute:output:recursively:
objectInChildNodesWithAttribute:firstOnly:
next
setNext:
initWithType:component:
_findComponentWithType:
_setComponent:withType:
presentationGeometry
skinnerWithSkinnerRef:
_setBaseGeometry:
morpherWithMorphRef:
simdConvertPosition:toNode:
hitTestResultsFromHitTestResultRef:
_updateAffine
simdRotation
simdWorldOrientation
setSimdWorldOrientation:
simdOrientation
_quaternion
setSimdOrientation:
simdEulerAngles
setSimdEulerAngles:
setSimdPosition:
simdPosition
setSimdScale:
simdScale
setSimdRotation:
setSimdTransform:
simdTransform
setSimdWorldPosition:
setSimdWorldTransform:
simdWorldTransform
setSimdPivot:
simdPivot
_removeComponentWithType:
_assignComponent:toContainerWithType:
__light
__skinner
skinnerRef
__morpher
morphRef
__camera
__geometry
geometryRef
filters
renderNode:renderer:arguments:
rendererWithContext:options:
_reSyncModelTree
countOfChildNodes
insertObject:inChildNodesAtIndex:
canAddChildNode:
_setHasFocusableChild
_setPausedOrPausedByInheritance:
__insertObject:inChildNodesAtIndex:
removeObjectAtIndex:
__removeObjectFromChildNodesAtIndex:
removeObjectFromChildNodesAtIndex:
_updateFocusableCache
indexOfChildNode:
replaceObjectInChildNodesAtIndex:withObject:
getBoundingBoxMin:max:
simdGetBoundingSphereCenter:radius:
isPresentationInstance
getBoundingSphereCenter:radius:
setCenter:
setRadius:
setMin:
setMax:
setGeometryRef:
flattenedClone
skeleton
setSkeleton:
allValues
isPaused
_focusableCandidates:
_isEffectivelyHidden
isFocusInteractionEnabled
removeActionForKey:
setCompletionBlock:
setKey:
runAction:forKey:completionHandler:
constraintRef
_setOwner:
entity
_removeDeadParticleSystem:
_particleSystems
simdConvertPosition:fromNode:
simdConvertVector:toNode:
simdConvertVector:fromNode:
simdConvertTransform:toNode:
simdConvertTransform:fromNode:
setBoundingBoxMin:max:
setFilters:
_customEncodingOfSCNNode:usePresentationInstance:
_encodeNodePropertiesWithCoder:
_customDecodingOfSCNNode:
_didDecodeSCNNode:
nodeWithGeometry:
keyPathsForValuesAffectingPosition
keyPathsForValuesAffectingTransform
keyPathsForValuesAffectingRotation
keyPathsForValuesAffectingEulerAngles
keyPathsForValuesAffectingOrientation
keyPathsForValuesAffectingScale
runAction:
runAction:completionHandler:
removeAllActions
hasActions
dump
_dumpTree
objectInChildNodesWithName:
childNodesWithAttribute:recursively:
childNodeWithName:
jsChildNodesWithAttribute:
_updateTransform
rotationRepresentation
worldOrientation
setWorldOrientation:
quaternion
setQuaternion:
_setQuaternion:
_euler
_setPosition:
_setScale:
setWorldPosition:
worldPosition
isHittable
setHittable:
mutableChildNodes
isJoint
setIsJoint:
renderInContext:
objectInChildNodesAtIndex:
removeAllChilds
insertChildNode:atIndex:
replaceChildNode:with:
getFrustum:withViewport:
getBoundingSphere
getBoundingBox
flattenedCopy
_subdividedCopyWithSubdivisionLevel:
canBecomeFocused
_isEligibleForFocus
actions
_removeAction:forKey:
setEntity:
removeAllParticleSystems
countOfParticleSystems
objectInParticleSystemsAtIndex:
insertObject:inParticleSystemsAtIndex:
removeObjectFromParticleSystemsAtIndex:
replaceObjectInParticleSystemsAtIndex:withObject:
convertPosition:fromNode:
convertVector:toNode:
convertVector:fromNode:
convertTransform:fromNode:
authoringEnvironmentPresentationNode
setAuthoringEnvironmentPresentationNode:
_node
_parent
_childNodes
_presentationInstance
_lightLoaded
_geometryLoaded
_cameraLoaded
_skinnerLoaded
_morpherLoaded
_paused
_pausedByInheritance
_affineUpToDate
_transformUpToDate
_hasPivot
_isJoint
_rotationRepresentation
_movability
_hidden
_ignoreAnimationWhenCopying_tmp
_focusBehavior
_isFocusableOrHasFocusableChild
_authoringEnvironmentNode
_hasComponentBitmask
_transform
_position
_rotation
_opacity
_renderingOrder
_components
_fixedBoundingBoxExtrema
_valueForKey
_rendererDelegate
simdLocalUp
simdLocalRight
simdLocalFront
simdWorldUp
simdWorldRight
simdLookAt:
simdLookAt:up:localFront:
simdLocalTranslateBy:
simdLocalRotateBy:
simdRotateBy:aroundTarget:
worldUp
worldRight
worldFront
lookAt:
lookAt:up:localFront:
localTranslateBy:
localRotateBy:
rotateBy:aroundTarget:
localUp
localRight
localFront
bones
setBones:
dataType
getBytes:bytesPerRow:fromRegion:mipmapLevel:
writeToFile:atomically:
_setRootNode:
sceneNamed:inDirectory:options:
URLByResolvingSymlinksInPath
sceneSourceWithURL:options:
sceneWithClass:options:error:
dictionaryWithDictionary:
sceneWithData:options:
sceneSourceWithData:options:
initWithSceneRef:
canImportFileExtension:
_physicsWorldCreateIfNeeded:
startDelay
setStartTime:
frameRate
setFrameRate:
playbackSpeed
setPlaybackSpeed:
setUpAxis:
startTime
writeImage:withSceneDocumentURL:originalImageURL:
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
fileExistsAtPath:
initWithCGImage:
representationUsingType:properties:
archivedDataWithRootObject:options:
scn_compressedDataUsingCompressionAlgorithm:
exportAssetToURL:
flush
library
indexAtPosition:
initWithIndexes:length:
_nodeWithIndexPath:
initWithURL:options:
_createSceneRefWithOptions:statusHandler:
initForJavascript:
_customEncodingOfSCNScene:
_didEncodeSCNScene:
setDocumentURL:
_customDecodingOfSCNScene:
setFogStartDistance:
setFogEndDistance:
setFogDensityExponent:
setFogColor:
_didDecodeSCNScene:
sceneNamed:
sceneNamed:options:
sceneWithURL:options:
sceneWithURL:atIndex:options:
sceneWithData:atIndex:options:
canImportFileUTI:
supportedFileUTIsForImport
supportedFileUTIsForExport
_indexPathForNode:
jsConstructor
_setSourceURL:
_scenes
setSceneSource:
sceneSource
root
setRootNode:forLayer:
rootNodeForLayer:
_scaleSceneBy:
background
lightingEnvironment
fogColor
fogEndDistance
fogDensityExponent
fogStartDistance
addSceneAnimation:forKey:target:
addParticleSystem:withTransform:
setPausedForEditing:
isPausedForEditing
_subnodeFromIndexPath:
_sceneSource
_physicsWorld
_rootNode
_layerRootNode
_background
_environment
_userAttributes
_fogStartDistance
_fogEndDistance
_fogDensityExponent
_fogColor
_sourceURL
_pausedForEditing
_imagePathWithSceneDocumentURL:originalImageURL:error:
_imagePathWithSceneDocumentURL:originalImageURL:
prefersGL3
rendererContextForTextureSourceWithEngineContext:
_textureWithEngineContext:textureSampler:nextFrameTime:
MTLTextureCache
textureSize
newTextureWithDescriptor:iosurface:plane:
setMTLTextureCache:
setSize:
supportsMetal
textureWithEngineContext:textureSampler:nextFrameTime:
renderWithEngineContext:textureSampler:nextFrameTime:
nextFrameTime
glTextureCache
setGlTextureCache:
_mtlTextureCache
_glTextureCache
textureSource
isPremultiplied
_createFramebufferWithEngineContext:size:
__prepareFramebufferWithSize:withEngineContext:textureSampler:needsStencil:
_buildMipmaps:
_bindFramebuffer:
_unbindFramebuffer:
_usesIOSurface
_framebufferSize
_framebuffer
postNotificationName:object:
rendererWithCGLContext:options:
setBackingScaleFactor:
setBounds:
sharedRegistry
rendererDidChange:
sourceRendererForEngineContext:source:textureSource:
removeSourceRenderersForEngineContext:
removeSourceRenderersForSource:
_registry
drawInContext:atTime:
needsUpdate
contentSize
__updateTextureWithDelegate:engineContext:
_nextUpdateDate
CGLPixelFormatObj
newRenderPipelineStateWithPixelFormat:vertexFunctionName:fragmentFunctionName:library:vertexConstantValues:fragmentConstantValues:
newComputePipelineStateWithFunctionName:constantValues:
_createFramebufferDependantResourcesWithRenderContext:renderPassDesc:camera:
setupWithContext:
executeWithContext:
_frameBufferFormat
_frameBufferWidth
_frameBufferHeight
_sampleCount
_downsample
_cameraOrtho
_aoRenderTarget
_depthMinMaxOffsetTexture
_aoTexture
_aoPipelineState
_downsamplePipelineState
_blurXPipelineState
_blurYPipelineState
_upsamplingPipelineState
_uniforms
setThreadgroupMemoryLength:atIndex:
perfromSelector:onTarget:
_selector
geometryElements
addNormalsWithAttributeNamed:creaseThreshold:
_setupObjCModelFrom:
_geometryByWeldingVerticesWithThreshold:normalThreshold:
meshSource
meshElement
_releaseCachedSourcesAndElements
bytesPerComponent
componentsPerVector
_componentType
_geometrySourceWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
_geometryByUnifyingNormalsWithCreaseThreshold:
_geometryByAddingSourcesOfSkinner:
_geometryByRemovingSkinnerSources
_discardOriginalTopology
isLowPower
_renderContextMetal
colorSpace
CGColorSpace
setColorspace:
setWantsLayer:
setCanDrawConcurrently:
setContentsGravity:
_defaultBackgroundColor
setAllowsCameraControl:
initWithView:
setNavigationCameraController:
initWithFrame:options:
_selectRenderingAPIWithOptions:
_commonInit:
renderingAPIForOptions:
_isMetalSupported
set_ibPreferredRenderingAPI:
set_ibWantsMultisampling:
decodeObjectForKey:
set_ibSceneName:
URLForResource:withExtension:
allowsCameraControl
backgroundColor
_ibSceneName
_ibWantsMultisampling
_ibPreferredRenderingAPI
_clearAppKitGLContext
sceneWillChange
_updateOpacity
_superSamplingFactor
set_screenTransform:
_screenTransform
_isLayerBacked
_openGLContext
_drawAtTime:WithContext:
wantsBestResolutionOpenGLSurface
_setContentsScaleFactor:
drawableSize
convertSizeToBacking:
_updateContentsScaleFactor
_installContext
isDrawableAvailable
viewWillDrawAtTime:
viewDidDrawAtTime:
_updateBackingSize
cameraWillChange
cameraDidChange
enabled
navigationCameraController
cameraController
setRendersContinuously:
_adjustBackingLayerPixelFormat
_openGLContextIfAny
_backgroundDidChange
willMoveFromView:
_didMoveToView:
_privateRendererShouldForwardSceneRendererDelegationMessagesToOwner
set_privateRendererShouldForwardSceneRendererDelegationMessagesToOwner:
setCGLContextObj:
eventHandler
wantsRedraw
_enablesDeferredShading
set_enablesDeferredShading:
_updateProbes:withProgress:
_beginMouseMovedTracking
_cancelMouseMovedTracking
initWithRect:options:owner:userInfo:
addTrackingArea:
trackingAreas
removeTrackingArea:
_defaultPixelFormatWithAPI:sampleCount:stencil:
lockFocusIfCanDraw
makeCurrentContext
_scnlayerBackedOpenGLContext
clearDrawable
_setLayerBackedOpenGLContext:
_setSurfaceBackedOpenGLContext:
_setOpenGLContext:madeWithPixelFormat:
_openGLContextDidChange:
_privateOpenGLContext
initWithAttributes:
getValues:forAttribute:forVirtualScreen:
wantsLayer
disableScreenUpdatesUntilFlush
_surfaceBackedOpenGLContext
scn_setBackingLayer:
object
displayIDDidChange:
_resetContentsScaleFactor
windowChangedScreen:
windowWillClose:
_windowBackingDidChange:
viewDidMoveToWindow
viewWillMoveToWindow:
rightMouseDown:
rightMouseUp:
rightMouseDragged:
scrollWheel:
magnifyWithEvent:
rotateWithEvent:
keyDown:
flagsChanged:
keyUp:
setAutoAdjustCamera:
autoAdjustCamera
setZoomFactor:
zoomFactor
rotateOf:
cameraControlConfiguration
defaultCameraController
rendersContinuously
setEventHandler:
eventHandlerWantsRedraw
_wantsSceneRendererDelegationMessages
set_wantsSceneRendererDelegationMessages:
_isEditor
switchToCameraNamed:
switchToNextCamera
set_disableLinearRendering:
ibPreferredRenderingAPI
setIbPreferredRenderingAPI:
ibSceneName
setIbSceneName:
ibWantsMultisampling
setIbWantsMultisampling:
setAllowsBrowsing:
setAsynchronousLoading:
viewWillStartLiveResize
viewDidEndLiveResize
reshape
makeBackingLayer
acceptsFirstMouse:
_currentSystemTime
_userDefinedPixelFormat
__ibSceneName
__ibPreferredRenderingAPI
_ibNoMultisampling
_renderingAPI
_rendersContinuously
_firstDrawDone
_drawOnMainThreadPending
_inRenderQueueForLayerBackedGLRendering
_isInLiveResize
_didTriggerRedrawWhileRendering
_backingLayer
_lock
_backgroundColor
_snapshotImageData
_snapshotImageDataLength
_navigationCameraController
_spriteKitEventHandler
setConnectionPosition:
btVehicle
wheelWithNode:
suspensionStiffness
setSuspensionStiffness:
suspensionCompression
setSuspensionCompression:
suspensionDamping
setSuspensionDamping:
maximumSuspensionTravel
setMaximumSuspensionTravel:
frictionSlip
setFrictionSlip:
maximumSuspensionForce
setMaximumSuspensionForce:
connectionPosition
steeringAxis
setSteeringAxis:
axle
setAxle:
radius
suspensionRestLength
setSuspensionRestLength:
isFront
setIsFront:
_setVehicle:
_setWheelIndex:
_vehicle
_wheelIndex
_suspensionStiffness
_suspensionCompression
_suspensionDamping
_maximumSuspensionTravel
_frictionSlip
_maximumSuspensionForce
_connectionPosition
_steeringAxis
_axle
_radius
_suspensionRestLength
_isFront
scaleBy:duration:
scaleTo:duration:
isRelative
moveByX:y:z:duration:
moveToX:y:z:duration:
rotateByX:y:z:duration:
rotateToX:y:z:duration:
rotateByAngle:aroundAxis:duration:
rotateToAxisAngle:duration:
rotateToX:y:z:duration:shortestUnitArc:
hide
unhide
runAction:onFirstChildWithName:
editingModeEnabled
setEditingModeEnabled:
moveBy:duration:
moveTo:duration:
sequence:
group:
performSelector:onTarget:
runBlock:
runAction:onChildNodeWithName:
javaScriptActionWithScript:duration:
durationRange
setDurationRange:
_caction
wasPausedWithTarget:atTime:
willResumeWithTarget:atTime:
timeJumpWithTarget:timeOffset:
ratioForTime:
wasAddedToTarget:atTime:
wasRemovedFromTarget:atTime:
euler
setEuler:
usesEuler
setUsesEuler:
transitionStartTime
setTransitionStartTime:
transition
setTransition:
outgoingPointOfView
setOutgoingPointOfView:
outgoingScene
setOutgoingScene:
offscreenRendererWithDevice:size:
offscreenRendererWithContext:size:
transitionPass
prepareRendererAtIndex:withScene:renderSize:pointOfView:parentRenderer:
_transitionStartTime
_transition
_outgoingScene
_outgoingPointOfView
completionHandler
_transitionPass
_renderers
_updateEngineCallbacks
globalMetalDevice
setGlobalMetalDevice:
setPrefersOpenGL:
metalLayer
viewportWithLetterboxingIfNeeded:
setContentScaleFactor:
_invalidateFramebuffer
setDrawableSize:
_prepareSKRenderer
_prepareRenderTarget
_deleteGLFramebuffer
_createOffscreenFramebufferIfNeeded
_prepareGLRenderTarget
metalDevice
setSuperSamplingFactor:
superSamplingFactor
setScreenTransform:
screenTransform
animationDuration
disableActions
setFromValue:
setToValue:
_renderer:didRenderScene:atTime:
_renderer:willRenderScene:atTime:
pausesIncomingScene
pausesOutgoingScene
_defaultPOVForScene:
setRendererPremultipliedBackgroundColor:
_contentsScaleFactor
_setupSKRendererIfNeeded
scaleMode
_overlaysDidUpdate:
_endFrame
_preparePreloadRenderer
_prepareObject:shouldAbortBlock:
_releasePreloadRenderer
currentProgress
isCancelled
_preloadResource:abortHandler:
progressWithTotalUnitCount:
becomeCurrentWithPendingUnitCount:
resignCurrent
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
renderer:updateAtTime:
renderer:didApplyAnimationsAtTime:
renderer:didSimulatePhysicsAtTime:
renderer:didApplyConstraintsAtTime:
_renderer:inputTimeForCurrentFrameWithTime:
_renderer:updateAtTime:
_renderer:didApplyAnimationsAtTime:
_renderer:didSimulatePhysicsAtTime:
_renderer:didApplyConstraintsAtTime:
_setSceneTime:
updateCurrentTimeIfPlayingWithSystemTime:
_updateSystemTimeAndDeltaTimeWithCurrentTime:
_update:
_updateWithSystemTime:
_isDirty
_notifyNextDirtyState
render:
_play
_pause
flushBuffer
setEnablesDeferredShading:
_compilationErrors
_renderSceneWithEngineContext:sceneTime:
_computeNextFrameTime
set_nextFrameTime:
updateAndDrawStatisticsIfNeeded
_needsRedrawAsap
_drawSceneWithNewRenderer:
_drawSceneWithLegacyRenderer:
_clearBackBuffer
set_systemTime:
set_deltaTime:
_installViewport
_duration
settingsForTransition:atTime:renderIncomingToTexture:renderOutgoingToTexture:renderIncomingToScreen:renderOutgoingToScreen:
_viewport
renderAtTime:
_drawScene:
MTLTexture
renderTransition:withInputTexture:outputTexture:time:encoder:pass:commandQueue:
textureID
renderTransition:withInputTexture:outputTexture:inputTextureSize:outputTextureSize:time:
_updatePointOfView
_renderAtTime:
_resolveAndDiscardGL
_renderAtTime:viewport:encoder:passDescriptor:commandQueue:commandBuffer:
_installGLContextAndSetViewport
createSnapshot:
snapshotRendererWithSize:
snapshotAtTime:
_setupOffscreenRendererWithSize:
setDisableActions:
_collectCompilationErrors
set_collectCompilationErrors:
__setTransitionContext:
updateProbes:atTime:
setResourceOptions:
renderAtTime:viewport:commandBuffer:passDescriptor:
drain
_rendererContext
_didRenderScene:
_willRenderScene:
disableOverlays
programWithNode:withMaterial:
_drawOverlaySceneAtTime:
jitteringEnabled
frozen
_copyPerformanceStatistics
_runningInExtension
_drawableSafeAreaInsets
set_drawableSafeAreaInsets:
_draw
renderWithViewport:commandBuffer:passDescriptor:
renderAtTime:viewport:encoder:passDescriptor:commandQueue:
render
copySnapshotWithSize:
initOffscreenRendererWithSize:options:
privateRendererOwner
_pointOfView
_pointOfCulling
__renderingQueue
__antialiasingMode
_framebufferInfo
_pointOfViewWasSet
_shouldDeleteFramebuffer
_isPrivateRenderer
_isViewPrivateRenderer
_renderingSnapshot
_autoUpdate
_isLayerPrivateRenderer
_contextIsDoubleBuffered
_currentSceneTime
_deltaTime
_forceSystemTime
_lastSystemTime
__nextFrameTime
_transitionContext
_playing
_isAnimating
_adaptativeState0
_adaptativeEndFrame
_adaptativeTechniqueTimeStamp
__viewport
__drawableSafeAreaInsets
_glContext
__openGLContext
_renderContext
_jitteringEnabled
_frozen
_delegateSupportsUpdate
_delegateSupportsDidApplyAnimations
_delegateSupportsDidSimulatePhysics
_delegateSupportsDidApplyConstraints
_delegateSupportsWillRender
_delegateSupportsDidRender
_delegateSupportsInputTime
_privateRendererOwnerSupportsUpdate
_privateRendererOwnerSupportsDidApplyAnimations
_privateRendererOwnerSupportsDidSimulatePhysics
_privateRendererOwnerSupportsDidApplyConstraints
_privateRendererOwnerSupportsWillRender
_privateRendererOwnerSupportsDidRender
_c3dBackgroundColor
_preloadRenderer
_privateRendererOwner
_snapshotRenderer
_overlayRenderer
_overlayScene
_disableOverlays
_contentScaleFactor
_isRunningInExtension
_showStatistics
_statisticsTimeStamp
pixelsWide
pixelsHigh
SCNPixelsWide
SCNPixelsHigh
isValid
representations
SCNFixDPI
NSSize
initWithObjectsAndKeys:
dictionaryWithObject:forKey:
CGImage
imageRepWithCIImage:
initWithSize:
addRepresentation:
imageRepWithData:
initWithBitmapDataPlanes:pixelsWide:pixelsHigh:bitsPerSample:samplesPerPixel:hasAlpha:isPlanar:colorSpaceName:bytesPerRow:bitsPerPixel:
graphicsContextWithBitmapImageRep:
saveGraphicsState
drawAtPoint:fromRect:operation:fraction:
flushGraphics
restoreGraphicsState
setData:
usedCount
incrementUsedCount
decrementUsedCount
dataSource
_usedCount
_buffer
_offset
_dataSource
string
setNeedsRenderResource:
needsRenderResource
setBindBlock:
setArgument:
_needsRenderResource
_indices
_samplerIndices
_bindBlock
_argument
setSemanticsCount:
setBufferSize:
_semantics
setInputsCount:
_inputs
_samplerInput
setResource:ofType:atIndices:
materialModificationCount
setMaterialModificationCount:
geometryModificationCount
setGeometryModificationCount:
_vertexBuffers
_fragmentBuffers
_vertexTextures
_fragmentTextures
_vertexSamplers
_fragmentSamplers
index
_computeUsageForArguments:stage:
vertexBuffersUsageMask
setFrameBufferBindings:
setNodeBufferBindings:
setLightBufferBindings:
setPassBufferBindings:
setShadableBufferBindings:
_sceneBuffer
_pass
_buffersUsageMask
_texturesUsageMask
_samplersUsageMask
_frameBufferBindings
_nodeBufferBindings
_lightBufferBindings
_passBufferBindings
_shadableBufferBindings
setStepFunction:
stepRate
setStepRate:
tessellationVertexDescriptor
stageDescriptor
setVertexLayoutHash:
setBuffers:
setElements:
setVertexDescriptor:
setStageDescriptor:
setVolatileStride:
setVerticesCount:
mutabilityTimestamp
setMutabilityTimestamp:
_mutabilityTimestamp
_tessellationVertexDescriptor
_tessellationVertexLayoutHash
_buffers
_elements
_vertexDescriptor
_stageDescriptor
_volatileBuffer
setPrimitiveType:
setIndexCount:
setInstanceCount:
setIndexType:
_primitiveType
_indexCount
_instanceCount
_sharedIndexBufferOffset
_indexBuffer
_indexType
_effectiveIndexOffset
_effectiveIndexCount
initWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
initWithBody:axis:anchor:
jointWithBodyA:axisA:anchorA:bodyB:axisB:anchorB:
jointWithBody:axis:anchor:
axisA
setAxisA:
axisB
setAxisB:
anchorA
setAnchorA:
anchorB
setAnchorB:
minimumLinearLimit
setMinimumLinearLimit:
maximumLinearLimit
setMaximumLinearLimit:
minimumAngularLimit
setMinimumAngularLimit:
maximumAngularLimit
setMaximumAngularLimit:
motorTargetLinearVelocity
setMotorTargetLinearVelocity:
motorMaximumForce
setMotorMaximumForce:
motorTargetAngularVelocity
setMotorTargetAngularVelocity:
motorMaximumTorque
setMotorMaximumTorque:
encodeBytes:length:forKey:
decodeBytesForKey:returnedLength:
flatness
setFlatness:
archivedDataWithRootObject:
unarchiveObjectWithData:
requiresSecureCoding
setRequiresSecureCoding:
finishDecoding
animationRef
animationWithC3DAnimation:
_setAnimation:
pathComponents
pathForResource:ofType:inDirectory:
imageNamed:
checkResourceIsReachableAndReturnError:
groundColor
turbidity
sunElevation
upperAtmosphereScattering
groundAlbedo
horizonElevation
gamma
exposure
brightness
channelEncoding
highDynamicRangeCompression
SCNMutableDeepCopy
keys
_setupFrom:
applyFunction:withContext:
_keys
_keyValues
indexSet
addIndexes:
removeIndexes:
elementAtIndex:associatedPoints:
bezierPath
moveToPoint:
lineToPoint:
currentPoint
curveToPoint:controlPoint1:controlPoint2:
closePath
initWithName:channelEncoding:textureDimensions:turbidity:sunElevation:upperAtmosphereScattering:groundAlbedo:
setHorizonElevation:
setGamma:
setExposure:
setBrightness:
setGroundColor:
setHighDynamicRangeCompression:
accessibilityDescription
_convertToCA
_clearC3DCache
timingFunctions
setTimingFunctions:
tensionValues
setTensionValues:
continuityValues
setContinuityValues:
biasValues
setBiasValues:
keyPath
setAutoreverses:
autoreverses
setTimeOffset:
setFadeInDuration:
fadeInDuration
setFadeOutDuration:
fadeOutDuration
isRemovedOnCompletion
setCommitsOnCompletion:
commitsOnCompletion
setAnimationEvents:
animationEvents
isAdditive
setCumulative:
isCumulative
additive
cumulative
_caReady
setTime:
setEventBlock:
animationEventWithKeyTime:block:
time
eventBlock
_eventTime
_eventBlock
fromValue
toValue
byValue
animationTimingFunction
functionWithName:
animationPlayerWithAnimationPlayerRef:
calculationMode
animationPlayerRef
caAnimation
SCN_evaluateAtTime:reverse:to:
initWithTimingFunctionRef:
functionWithTimingMode:
functionWithCAMediaTimingFunction:
c3dTimingFunction
_timingFunction
_setAnimationRef:
initWithC3DAnimation:
isAppliedOnCompletion
fillsForward
fillsBackward
setStartDelay:
setAppliedOnCompletion:
setFillsForward:
setFillsBackward:
animationWithContentsOfURL:
unarchiveObjectWithFile:
animationFromScene:
initWithCAAnimation:
_didMutate
setBlendInDuration:
setBlendOutDuration:
animationDidStart
setAnimationDidStart:
animationDidStop
setAnimationDidStop:
blendInDuration
blendOutDuration
_animationRef
_keyPath
_repeatCount
_timeOffset
_beginTime
_autoreverses
_removedOnCompletion
_applyOnCompletion
_additive
_cumulative
_usesSceneTimeBase
_fillForward
_fillBackward
_animationEvents
_fadeInDuration
_fadeOutDuration
_animationDidStart
_animationDidStop
_userInfo
_caAnimationCache
_userAnimation
initWithAnimationPlayerRef:
initWithSCNAnimation:
weight
setWeight:
paused
setBlendFactor:
stopWithBlendOutDuration:
animationPlayerWithAnimation:
blendFactor
stopWithFadeOutDuration:
_playerRef
_weight
sortedArrayUsingComparator:
animationDidStart:
animations
componentsJoinedByString:
setByValue:
animationDidStop:finished:
_shouldCacheWithOptions:
sceneSourceOptions
initWithKeyOptions:valueOptions:capacity:
_cachedSceneSourceForURL:options:
_cacheSceneSource:forURL:options:
_removeCachedSceneSourceIfNeededForURL:
initWithData:options:
sceneCount
sceneWithOptions:error:
errorWithDomain:code:userInfo:
localizedStringForKey:value:table:
dictionaryWithObjectsAndKeys:
scn_uncompressedDataUsingCompressionAlgorithm:
assetCatalogForResourceURL:
setAssetCatalog:
_sceneWithClass:options:statusHandler:
sceneWithClass:options:statusHandler:
copyPropertiesAtIndex:options:
copyImageFromC3DImage:
longValue
_appendToEntries:entriesWithType:passingTest:entryObjectConstructor:
entryWithIdentifier:withClass:
identifiersOfEntriesWithClass:
sceneTypes
sceneFileTypes
unarchiver:cannotDecodeObjectOfClassName:originalClasses:
unarchiver:didDecodeObject:
unarchiver:willReplaceObject:withObject:
unarchiverWillFinish:
unarchiverDidFinish:
countOfScenes
sceneAtIndex:options:
sceneAtIndex:options:error:
sceneWithOptions:statusHandler:
propertyForKey:
sceneSourceRef
entriesPassingTest:
entryWithID:withClass:
IDsOfEntriesWithClass:
sourceStatus
canExportToColladaWithNoDataLoss
performConsistencyCheck
_lastLoadedScene
_lastOptions
_sceneLoaded
_sceneSourceOptions
documentEnclosingURL
lookUpKey
setLookUpKey:
lookUpFoundInstance
setLookUpFoundInstance:
_context
_assetCatalog
_documentURL
allocWithZone:
initWithLength:
initForWritingWithMutableData:
finishEncoding
isEqualToDictionary:
textureCoordinatesWithMappingChannel:
worldCoordinates
geometryIndex
boneNode
faceIndex
localCoordinates
localNormal
worldNormal
textureCoordinate
modelTransform
_result
materialAttachmentWithGLKTextureInfo:
glID
setGlID:
parent
propertyType
_clearContents
_animationPathForKey:
_updateMaterialColor:
_updateMaterialNumber:
textureSampler
_updateMaterialFilters
_presentationMappingChannel
effectSlotCreateIfNeeded:
_updateMaterialBorderColor:
_updateMaterialAttachment:
_textureOptions
copyC3DImageFromImage:textureOptions:
_updateMaterialImage:
_updateC3DImageWithContents:
_updateMaterialSKScene:
_updateMaterialSKTexture:
_updateMaterialLayer:
_updateMaterialAVPlayer:
setImage:
setLayer:
setSkScene:
setSkTexture:
setAttachment:
setPurgeableState:
makeAliasable
isAliasable
heap
allocatedSize
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
rootResource
parentTexture
parentRelativeLevel
parentRelativeSlice
bufferOffset
bufferBytesPerRow
iosurfacePlane
isFramebufferOnly
setMtlTexture:
setAvPlayer:
image
_updateMaterialProceduralContents:
_updateMaterialMTLTexture:
__allocateContentTransformIfNeeded
_updateMaterialPropertyTransform:
propertyName
_copyC3DImageFromImageData:typeID:
setAccessibilityDescription:
_copyImageFromC3DImage:
minificationFilter
setMinificationFilter:
magnificationFilter
setMagnificationFilter:
mipFilter
setMipFilter:
contentsTransform
wrapS
wrapT
sRGBTexture
setSRGBTexture:
borderColor
setBorderColor:
textureComponents
setTextureComponents:
materialPropertyWithContents:
initPresentationMaterialPropertyWithModelProperty:
borderColor4
_skSceneDidChange:
metalTexture
hasAlpha
filteringMode
usesMipmaps
_layerDidChange:
setMaxAnisotropy:
_customEncodingOfSCNMaterialProperty:
_customDecodingOfSCNMaterialProperty:
_didDecodeSCNMaterialProperty:
dvt_supportedTypesForPropertyContents
initWithParent:andCustomName:
color4
attachment
pvrtcData
skScene
skTexture
avPlayer
maxAnisotropy
setProceduralContents:
proceduralContents
mtlTexture
_hasDefaultValues
_isCommonProfileProperty
_sRGB
_propertyType
_customSlotName
_borderColor
_contentType
_mappingChannel
_minificationFilter
_magnificationFilter
_mipFilter
_wrapS
_wrapT
_textureComponents
_maxAnisotropy
_customSlot
_c3dImage
_contentTransform
glTextureId
textureRect
isRotated
sublayers
null
setValueForKey:optionKey:options:
boxWithWidth:height:length:chamferRadius:
pyramidWithWidth:height:length:
sphereWithRadius:
setGeodesic:
cylinderWithRadius:height:
coneWithTopRadius:bottomRadius:height:
tubeWithInnerRadius:outerRadius:height:
capsuleWithCapRadius:height:
torusWithRingRadius:pipeRadius:
floor
planeWithWidth:height:options:
boxWithWidth:height:length:cornerRadius:options:
pyramidWithWidth:height:length:options:
sphereWithRadius:options:
cylinderWithRadius:height:options:
coneWithHeight:topRadius:bottomRadius:options:
tubeWithInnerRadius:outerRadius:height:options:
capsuleWithRadius:height:options:
torusWithRingRadius:pipeRadius:options:
floorWithOptions:
initWithGeometryRef:
reflectionFalloffStart
reflectionFalloffEnd
setReflectionFalloffStart:
setReflectionFalloffEnd:
reflectivity
setReflectivity:
reflectionResolutionScaleFactor
setReflectionResolutionScaleFactor:
reflectionSampleCount
setReflectionSampleCount:
reflectionCategoryBitMask
setReflectionCategoryBitMask:
_customDecodingOfSCNFloor:
initWithFloorGeometryRef:
floorRef
reflectionFallOffStart
reflectionFallOffEnd
setReflectionFallOffStart:
setReflectionFallOffEnd:
__createCFObject
_usesCustomScaleFactor
_reflectivity
_reflectionFalloffStart
_reflectionFalloffEnd
_reflectionCategoryBitMask
_length
_reflectionResolutionScaleFactor
_reflectionSampleCount
_initializeWheelsArray
initWithChassisBody:wheels:
_createWheel:
chassisBody
wheelAtIndex:
_customDecodingOfSCNPhysicsVehicle:
vehicleWithChassisBody:wheels:
wheels
setSteeringAngle:forWheelAtIndex:
applyEngineForce:forWheelAtIndex:
applyBrakingForce:forWheelAtIndex:
speedInKilometersPerHour
_chassisBody
_wheels
_speedKmHour
clientWillDie:
geometryDescription
initPresentationGeometryWithGeometryRef:
geometrySourceWithMeshSourceRef:
geometryElementWithMeshElementRef:
_setupGeometrySources
_setupGeometryElements
levelsOfDetail
setLevelsOfDetail:
subdivisionLevel
wantsAdaptiveSubdivision
setWantsAdaptiveSubdivision:
_subdivisionSettings
set_subdivisionSettings:
tessellator
setTessellator:
_materialWithName:
_expand
mutableMaterials
_firstMaterial
removeMaterialAtIndex:
insertMaterial:atIndex:
replaceObjectInMaterialsAtIndex:withObject:
insertObject:inMaterialsAtIndex:
removeObjectFromMaterialsAtIndex:
removeAllMaterials
setFirstMaterial:
parseSpecialKey:withPath:intoDestination:remainingPath:
thresholdMode
thresholdValue
removeClient:
addClient:
tessellatorValueDidChangeForClient:
replaceMaterial:with:
removeMaterial:
_customEncodingOfSCNGeometry:
_customDecodingOfSCNGeometry:
_setGeometryRef:
geometrySourceForSemantic:
_hasFixedBoundingBoxExtrema
interleavedCopy
_renderableCopy
keyForNodeAttributes
materialWithName:
countOfMaterials
objectInMaterialsAtIndex:
edgeCreasesElement
edgeCreasesSource
_unifyNormals
_sources
_sourceChannels
_materials
_levelsOfDetail
_subdivisionLevel
_subdivisionIsAdaptive
_edgeCreasesSource
_edgeCreasesElement
_tessellator
initWithMeshSource:
mutableGeometrySourcesForSemantic:
mutateGeometrySourcesWithSemantics:usingBlock:
pressureChangeWithEvent:
locationInNode:
nodeAtPoint:recursive:
isUserInteractionEnabled
_touchMap
_mouseIsDown
_rightMouseIsDown
_setInertiaRunning:
simdTarget
setSimdTarget:
simdUp
setSimdUp:
setPointOfView:updateUpTransform:
isInertiaRunning
maximumVerticalAngle
maximumHorizontalAngle
setMaximumVerticalAngle:
setMaximumHorizontalAngle:
_translateInCameraSpaceByX:Y:Z:
_resetOrientationState
_rotateByX:Y:
_directionForScreenPoint:viewport:
interactionMode
useOrbitInteractionMode
unrolledWorldOrientation:
automaticTarget
_mapToSphere:inViewport:
rotateByX:Y:
_updateArcballOrientation
_endDraggingWithVelocity:
drivenByDefaultNavigationCameraController
_updateRotation
_capOrientationAnglesToMaximum
_orientationForMode
_convertRotationFromWorldToPointOfView:
cameraInertiaWillStartForController:
_updateInertiaAtTime:
scheduledTimerWithTimeInterval:repeats:block:
cameraInertiaDidEndForController:
setUp:
setWorldUp:
setInteractionMode:
inertiaEnabled
setInertiaEnabled:
inertiaFriction
setInertiaFriction:
minimumVerticalAngle
minimumHorizontalAngle
setMinimumVerticalAngle:
setMinimumHorizontalAngle:
verticalMaximumAngle
horizontalMaximumAngle
setVerticalMaximumAngle:
setHorizontalMaximumAngle:
translateInCameraSpaceByX:Y:Z:
translateInScreenSpaceTo:viewport:
rollCameraSpaceBy:withPoint:viewport:
rollAroundTarget:
dollyToTarget:
clearRoll
stopInertia
frameNodes:
lookAtWith:target:
beginInteraction:withViewport:
continueInteraction:withViewport:sensitivity:
endInteraction:withViewport:velocity:
rollBy:aroundScreenPoint:viewport:
dollyBy:onScreenPoint:viewport:
_targetRelativeToPointOfViewParent
_isLocationValid:inViewport:
setAutomaticTarget:
_orientationState
_inputLocation
_arcball
_inertia
_minimumAngles
_maximumAngles
_handlingInteraction
_drivenBydefaultNavigationCameraController
_automaticTarget
_interactionMode
_orthographicViewSpaceTranslationForZoomAtScreenPoint:scaleDelta:viewport:
updateInertiaAtTime:
setDrivenByDefaultNavigationCameraController:
prepareScene:
addedNode:
setAuthoringCameraType:
lightGeometry
particlesGeometry
compare:
cameraGeometry
cameraFrustumGeometry
cameraNearPlaneGeometry
fieldGeometry
addLightNode:
addParticlesNode:
addCameraNode:
addPhysicsFieldNode:
removeLightNode:
removeParticlesNode:
removeCameraNode:
removePhysicsFieldNode:
setLibrary:
setVertexFunctionName:
setFragmentFunctionName:
handleBindingOfBufferNamed:frequency:usingBlock:
member:
updateLightTypeForNode:source:light:andRatio:
authoringCameraNodes
removedNode:
addNodeToSelection:
selectNodes:
cancelSelection
updateLightNode:withSourceNode:
updateParticlesNode:withSourceNode:
updateCameraNode:withSourceNode:
updateFieldNode:withSourceNode:
updateWithRenderer:
displayMask
readDepthMask
setReadDepthMask:
setAuthoringCamera:forView:
authoringCamera:
_layerRoot
_lightRoot
_cameraRoot
_particlesRoot
_physicsFieldsRoot
_cameraTarget
_pointsOfViewRoot
_lightsDictionary
_camerasDictionary
_particlesDictionary
_physicsFieldsDictionary
_lightGeometry
_cameraFrustumGeometry
_cameraGeometry
_cameraNearPlaneGeometry
_particlesGeometry
_fieldGeometry
_displayMask
_readDepthMask
_paleGreen
_paleBlue
_red
_green
_blue
_cyan
_yellow
_orange
_pink
_grayLight
_grayMedium
_grayDark
_white
authoringCameraType
newLibraryWithFile:error:
strongToStrongObjectsMapTable
functionNames
reloadFrameworkLibrary
sortedArrayUsingSelector:
dataWithContentsOfFile:
newLibraryWithData:error:
newDefaultLibrary
preprocessorMacros
hashCodeForSource:macros:hashStorageLock:
newLibraryWithSource:options:error:
newComputePipelineStateWithFunction:error:
replaceOccurrencesOfString:withString:options:range:
writeToURL:atomically:encoding:error:
setLanguageVersion:
localizedDescription
newLibraryWithSource:options:completionHandler:
presentedItemURL
presentedItemOperationQueue
relinquishPresentedItemToReader:
relinquishPresentedItemToWriter:
savePresentedItemChangesWithCompletionHandler:
accommodatePresentedItemDeletionWithCompletionHandler:
presentedItemDidMoveToURL:
presentedItemDidChange
presentedItemDidChangeUbiquityAttributes:
presentedItemDidGainVersion:
presentedItemDidLoseVersion:
presentedItemDidResolveConflictVersion:
accommodatePresentedSubitemDeletionAtURL:completionHandler:
presentedSubitemDidAppearAtURL:
presentedSubitemAtURL:didMoveToURL:
presentedSubitemDidChangeAtURL:
presentedSubitemAtURL:didGainVersion:
presentedSubitemAtURL:didLoseVersion:
presentedSubitemAtURL:didResolveConflictVersion:
primaryPresentedItemURL
observedPresentedItemUbiquityAttributes
initWithDevice:
clearCompiledLibraries
isolateProgram
deviceQueue
libraryForFile:
libraryForCommonProfileCache
newCommonProfileFunctionWithName:
libraryForSourceCode:preprocessorsMacros:programDelegate:programDesc:async:group:completionHandler:
_defaultLibrary
_frameworkLibrary
_resourcesFolderURL
_watchingFolderQueue
_deviceQueue
_traceResources
_commonProfileCacheLibrary
_commonProfilePrecompiledFunctions
_defaultProgram
_defaultProgramForTessellation
_isolateProgram
_sharedHashCodeSemaphore
_sharedHashCodeString
_availableLibraries
_availableCompiledLibraries
range
lineRangeForRange:
newlineCharacterSet
characterIsMember:
releaseRenderTarget:
initWithObjects:
removeObjectsInArray:
_purgeWithReason:
numberOfRenderTargets
initWithRenderContext:
retainTextureWithName:retainCount:
releaseTextureWithName:retainCount:
bumpTimeStamp
purge
finalizeFrame
viewportDidResize
cleanup
_nameToRenderTarget
_purgeArray
_frameStamp
numberWithUnsignedLongLong:
drawWithFrame:inView:
graphicsPort
clickCount
mouseLocation
makeFirstResponder:
deltaX
checkBounds:
_bindingAdaptor
validateAndCommitValueInEditor:editingIsEnding:errorUserInterfaceHandled:
sendAction:to:
minValue
maxValue
drag
rejectFirstResponder
initWithSkinnerRef:
_setSkeleton:
_createSkinnerWithVertexCount:bones:boneWeights:boneIndices:baseGeometry:
floatComponents
createSkinnerWithBaseGeometry:bones:boneWeights:boneIndices:
setBoneInverseBindTransforms:
setBaseGeometryBindTransform:
baseGeometry
baseGeometryBindTransform
boneWeights
boneIndices
boneInverseBindTransforms
_createSkinnerWithCompressedData:bonesCount:vertexCount:
_skinnerWithBaseGeometry:skinnableGeometry:bones:boneInverseBindTransforms:bindMatrix:
wantsCPUSkinning
setWantsCPUSkinning:
_bonesAndIndicesCompression
set_bonesAndIndicesCompression:
setBaseGeometry:
joints
_skinner
_baseGeometry
_skeleton
initWithData:options:error:
entryNames
contentsForEntryName:
initWithEntryNames:contents:properties:options:
archiveData
dataWithContentsOfFile:options:error:
archive:contentsForEntryName:
archive:streamForEntryName:
archive:propertiesForEntryName:
inputStreamWithData:
writeToFile:options:error:
replaceBytesInRange:withBytes:
appendData:
initWithPath:options:error:
initWithEntryNames:dataProvider:options:
streamForEntryName:
writeContentsForEntryName:toFile:options:error:
propertiesForEntryName:
archiveStream
_data
_provider
_desc
_path
_names
_properties
_cachedContents
_reserved
_zFlags
_reserved2
fileSystemRepresentation
initWithBytes:length:encoding:
debugQuickLookObjectWithPointOfView:
debugQuickLookObject
debugQuickLookData
SCN_safeHash
_pipeline
programHashCode
depthAttachmentPixelFormat
stencilAttachmentPixelFormat
vertexFunction
fragmentFunction
newFunctionWithName:constantValues:error:
newRenderPipelineStateWithDescriptor:options:completionHandler:
generateBindingsForPipeline:withReflection:program:material:geometry:pass:
vertexArguments
fragmentArguments
setBlendStates:
setWriteMask:
finalizeRenderPipeline:withRenderPipelineState:reflection:programDesc:forceCacheMissShader:error:
renderPipelineStateWithLibrary:renderPipelineDescriptor:metalProgram:async:tessellationConfigurator:completionHandler:
_removeMatchingProgram:pass:
initWithResourceManager:passDescription:
matchPassDescriptor:
programWillDie:
passWillDie:
_libraryManager
__engineStats
_prepareShadersGroup
_renderPipelineDescriptor
_availablePipelineStates
_availablePipelineStatesLock
_bindingsGenerator
weakToStrongObjectsMapTable
allocateRegistry
newCommandQueueWithMaxCommandBufferCount:
initWithDevice:fixedSizeElement:buffersize:name:
_meshSourceWillDie:
_meshElementWillDie:
_meshWillDie:
_imageWillDie:
_imageProxyWillDie:
_programWillDie:
_passWillDie:
_materialWillDie:
_geometryWillDie:
_morphWillDie:
_skinWillDie:
_programHashCodeWillDie:
unregisterManagerForDevice:
frontFaceStencil
setStencilCompareFunction:
setStencilFailureOperation:
setDepthFailureOperation:
setDepthStencilPassOperation:
setReadMask:
backFaceStencil
_bufferForData:bytesPerIndex:
__updateMutableMesh:withMetalMesh:
renderResourceForMeshSource:
objectEnumerator
isCompatibleWithMorph:
initWithMorph:baseGeometry:resourceManager:
initWithSkinner:baseMesh:resourceManager:
setComputeFunction:
newComputePipelineStateWithDescriptor:options:reflection:error:
computePipelineStateForKernel:threadGroupSizeIsMultipleOfThreadExecutionWidth:
getUniqueStageDescriptor:
setStageInputDescriptor:
newSubBufferWithBytes:length:blitEncoder:
newTextureWithDescriptor:offset:bytesPerRow:
addDebugMarker:range:
removeAllDebugMarkers
bufferDataType
bufferStructType
members
setMinFilter:
setMagFilter:
setSAddressMode:
setTAddressMode:
setRAddressMode:
renderPipelineDescriptorWithPixelFormat:vertexFunctionName:fragmentFunctionName:library:vertexConstantValues:fragmentConstantValues:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:
newComputePipelineStateWithFunctionName:library:constantValues:
newComputePipelineStateWithDescriptor:
setBlendingEnabled:
setSourceRGBBlendFactor:
setDestinationRGBBlendFactor:
setSourceAlphaBlendFactor:
setDestinationAlphaBlendFactor:
renderResourceForMorph:baseGeometry:
renderResourceForSkinner:baseMesh:
removeAllShaders
newLibraryWithSource:options:
newComputePipelineStateForKernel:withStageDescriptor:constants:constantsHash:
newIndexBufferWithLength:options:
renderPipelineDescriptorWithPixelFormat:vertexFunctionName:fragmentFunctionName:library:
newComputePipelineStateWithFunctionName:library:
setLibraryManager:
_commonProfileBuffersAllocator
_availableIrradianceTextures
_availableRadianceTextures
_availableImages
_availableImageProxy
_availableSamplers
_availableBuffers
_availableMeshes
_availableMeshSources
_availableMeshElements
_availableRasterizerStates
_availableMorphs
_availableSkins
_availableComputePipelines
_availableComputePipelinesWithStageDescriptor
_availableTessellators
_availableWireframeMaterials
_availableShadables
_availableShadablesSearchKey
_availableShaderManagers
_shaderManagerLock
_availableStageDescriptors
_stageDescriptorsLock
_nullStageDescriptor
_specularDFGTexture
_defaultTexture
_defaultTexture3D
_defaultCubeTexture
_mtkTextureLoader
setRgbBlendOperation:
setAlphaBlendOperation:
stepFunction
indexBufferIndex
initWithAVAudioNode:
setWillStartPlayback:
setDidFinishPlayback:
initWithSource:
audioBufferFormat
audioPlayerWithAVAudioNode:
setNodeRef:
recycle
willStartPlayback
didFinishPlayback
audioNode
audioPlayer
completed
setCompleted:
customAudioNode
_audioNode
_audioPlayer
_audioSource
_nodeRef
_customAudioNode
_completed
initWithAVAudioPCMBuffer:
setPositional:
setVolume:
setRate:
_loadURLWithBundle:
initWithFileNamed:inBundle:
initWithFileNamed:
volume
rate
reverbBlend
isPositional
shouldStream
setReverbBlend:
setShouldStream:
loadIfNeeded
_customEncodingOfSCNAudioSource:
_customDecodingOfSCNAudioSource:
audioSourceWithAVAudioPCMBuffer:
audioSourceNamed:
renderingAlgorithm
_load
_audioURL
_audioName
_shouldStream
positional
_setupWithManifold:index:point:
_fillNodeA:nodeB:
nodeA
nodeB
contactPoint
contactNormal
collisionImpulse
penetrationDistance
sweepTestFraction
_nodeA
_nodeB
_contactPoint
_contactNormal
_collisionImpulse
_distance
_fraction
_updateCount
_createBody
initWithType:shape:
bodyWithType:shape:
setMass:
isResting
referenceObject
setReferenceObject:
_shapeHandleWithShape:owner:
moveToTransform:
physicsShape
mass
charge
setCharge:
friction
setFriction:
restitution
setRestitution:
rollingFriction
setRollingFriction:
damping
setDamping:
angularVelocity
angularDamping
setAngularDamping:
velocityFactor
setVelocityFactor:
angularVelocityFactor
setAngularVelocityFactor:
setCollisionBitMask:
setContactTestBitMask:
allowsResting
setAllowsResting:
isAffectedByGravity
usesDefaultMomentOfInertia
setUsesDefaultMomentOfInertia:
momentOfInertia
setMomentOfInertia:
setPhysicsShape:
_didDecodeSCNPhysicsBody:
staticBody
dynamicBody
kinematicBody
respondsToCollision
applyForce:impulse:
applyForce:atPosition:impulse:
applyTorque:impulse:
resetToTransform:
moveToPosition:
rotateToAxisAngle:
_mass
_charge
_friction
_restitution
_rollingFriction
_physicsShape
_damping
_angularVelocity
_angularDamping
_velocityFactor
_angularVelocityFactor
_velocity
_ignoreGravity
_explicitMomentOfInertia
_momentOfInertia
_collisionBitMask
_contactTestBitMask
_allowsResting
_isDefaultShape
_body
_syncObjCModel:
initPresentationParametricGeometryWithParametricGeometryRef:
presentationPlane
cornerRadius
setCornerRadius:
widthSegmentCount
setWidthSegmentCount:
heightSegmentCount
setHeightSegmentCount:
cornerSegmentCount
setCornerSegmentCount:
initWithParametricGeometryRef:
_cornerRadius
_widthSegmentCount
_heightSegmentCount
_cornerSegmentCount
presentationBox
setChamferRadius:
chamferRadius
lengthSegmentCount
setLengthSegmentCount:
chamferSegmentCount
setChamferSegmentCount:
_boxwidth
_boxheight
_boxlength
_boxchamferRadius
_boxwidthSegmentCount
_boxheightSegmentCount
_boxlengthSegmentCount
_boxchamferSegmentCount
_boxprimitiveType
presentationPyramid
_pyramidwidth
_pyramidheight
_pyramidlength
_pyramidwidthSegmentCount
_pyramidheightSegmentCount
_pyramidlengthSegmentCount
_pyramidprimitiveType
presentationSphere
isGeodesic
radialSpan
setRadialSpan:
segmentCount
setSegmentCount:
isHemispheric
setHemispheric:
geodesic
_sphereradius
_sphereradialSpan
_spheresegmentCount
_sphereprimitiveType
_spheregeodesic
_spherehemispheric
presentationCylinder
radialSegmentCount
setRadialSegmentCount:
_cylinderradius
_cylinderheight
_cylinderradialSpan
_cylinderheightSegmentCount
_cylinderradialSegmentCount
_cylinderprimitiveType
presentationCone
topRadius
bottomRadius
setTopRadius:
setBottomRadius:
_conetopRadius
_conebottomRadius
_coneheight
_coneheightSegmentCount
_coneradialSegmentCount
_coneprimitiveType
presentationTube
outerRadius
setInnerRadius:
setOuterRadius:
innerRadius
_tubeinnerRadius
_tubeouterRadius
_tubeheight
_tuberadialSpan
_tubeheightSegmentCount
_tuberadialSegmentCount
_tubeprimitiveType
presentationCapsule
capRadius
setCapRadius:
capSegmentCount
setCapSegmentCount:
_capsulecapRadius
_capsuleheight
_capsuleheightSegmentCount
_capsuleradialSegmentCount
_capsulecapSegmentCount
_capsuleprimitiveType
presentationTorus
ringRadius
pipeRadius
setRingRadius:
setPipeRadius:
setRingSegmentCount:
setPipeSegmentCount:
pipeSegmentCount
ringSegmentCount
_torusringRadius
_toruspipeRadius
_torusradialSpan
_torusringSegmentCount
_toruspipeSegmentCount
_torusprimitiveType
__renderSKScene:withSKSCNRenderer:engineContext:viewport:atTime:
renderToFramebuffer:shouldClear:
__updateTextureWithSKScene:engineContext:sampler:
renderToTexture:commandQueue:
_cleanup
_isInvalidated
_callbackWithTime:
adaptativeFrameRate
setAdaptativeFrameRate:
queuedFrameCount
_displayID
_cvDisplayLink
_cglContext
_adaptativeFrameDuration
_invalidated
_lastFrameTime
_preferredFrameRate
_queuedFrameCount
techniquePanelForView:
tableColumns
updateSceneGraph
add:
del:
_typeInspector
shFromCPU:
_operateOnDataUsingCompressionAlgorithm:operation:
scn_indexedDataEncodingHighWatermarkWithBytesPerIndex:
scn_indexedDataDecodingHighWatermarkWithBytesPerIndex:
scn_indexedDataEncodingDeltaWithBytesPerIndex:
scn_indexedDataDecodingDeltaWithBytesPerIndex:
scn_indexedDataEncodingTrianglePairsWithBytesPerIndex:
scn_indexedDataDecodingTrianglePairsWithBytesPerIndex:
heapTextureSizeAndAlignWithDescriptor:
heapBufferSizeAndAlignWithLength:options:
newHeapWithDescriptor:
newBufferWithBytesNoCopy:length:options:deallocator:
newDefaultLibraryWithBundle:error:
newLibraryWithURL:error:
newRenderPipelineStateWithDescriptor:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithDescriptor:options:completionHandler:
newFence
minimumLinearTextureAlignmentForPixelFormat:
getDefaultSamplePositions:count:
newArgumentEncoderWithArguments:
registryID
maxThreadsPerThreadgroup
isHeadless
isRemovable
recommendedMaxWorkingSetSize
readWriteTextureSupport
argumentBuffersSupport
areRasterOrderGroupsSupported
currentAllocatedSize
maxThreadgroupMemoryLength
areProgrammableSamplePositionsSupported
processRendererElement:engineIterationContext:
_rendererPremultipliedBackgroundColor
_currentFrameIndex
_renderTargetRegistry
_needSuperSampling
initWithContent:options:
_setTransforms:
shapeWithGeometry:options:
_customEncodingOfSCNPhysicsShape:
_customDecodingOfSCNPhysicsShape:
shapeWithNode:options:
shapeWithShapes:transforms:
defaultShapeForGeometry:
initWithCachedObject:options:
transforms
_referenceObject
_options
_transforms
_cachedObject
_collisionShape
initWithDevice:histogramInfo:
_computeDofUniforms:camera:
_createFramebufferDependantResourcesWithRenderContext:renderPassDesc:postProcessConstants:
histogramSizeForSourceFormat:
encodeToCommandBuffer:sourceTexture:histogram:histogramOffset:
histogramInfo
_computeBloomBlurUniforms:textureSize:radius:horizontal:
_postProcessConstants
_scaleFactor
_dofColorCoCTexture
_dofCoCTextureA
_dofCoCTextureB
_dofBlurTexture
_dofSampleCount
_dofPipelineState
_dofKernel
_mbTileMax
_mbNeighborMax
_mbTexture
_mbColor
_mbBlurPipelineState
_mbVelocityPipelineState
_bloomTextureA
_bloomTextureB
_bloomBlurPipelineState
_downSampleBloomDOFPipelineState
_postProcessPipelineState
_histogramBuilder
_framebufferHistogramBuffer
_luminanceHistogramBuffer
_histogramAnalyserPipelineState
_histogramAnalysisBuffer
_histogramImmediateLuminancePipelineState
_histogramAdaptativeLuminancePipelineState
_frameLumTexture
_averageLumTexture
_autoExposureParametersBuffer
_frameLuminancePipelineState
_frameLuminanceCS
_slidingLuminancePipelineState
_adaptativeLuminancePipelineState
_fixedLuminancePipelineState
_frameIndex
table
removeObserver:forKeyPath:context:
instanceMethodSignatureForSelector:
invocationWithMethodSignature:
setSelector:
numberOfRows
setArgument:atIndex:
invokeWithTarget:
getReturnValue:
initWithNibName:bundle:
doubleClick:
setDoubleAction:
SCNUI_unbindAll
remove:
setTable:
setAdd:
remove
setRemove:
_arrayController
observer
arrayOwnerPath
observedKeyPath
_targetsProxy
setAlignment:
allowsCreation
removeButton
_removeButton
_allowsCreation
triggerBindings
vector4
setVector4:
matrix4
setMatrix4:
vector3
setVector3:
vector2
setVector2:
mlDelegate
prepareContentOfPopUpButton
setMlDelegate:
isAdaptive
isScreenSpace
tessellationFactorScale
tessellationPartitionMode
smoothingMode
edgeTessellationFactor
insideTessellationFactor
maximumEdgeLength
_tessellatorValueForGeometry:
tessellatorValueDidChange
setSmoothingMode:
adaptive
setAdaptive:
screenSpace
setScreenSpace:
setEdgeTessellationFactor:
setInsideTessellationFactor:
setMaximumEdgeLength:
_clients
_adaptive
_screenSpace
_maximumEdgeLength
_edgeTessellationFactor
_insideTessellationFactor
_tessellationFactorScale
_smoothingMode
_partitionMode
_writeSources:dstTypes:sourcesCount:inBuffer:stride:length:sparse:positionScale:
sparseIndexSize
_prepareTargetDataForIndex:morph:baseMesh:
isEqualToArray:
morphMesh:morph:computeEncoder:resourceManager:
morphOptimizedMesh:morph:computeEncoder:resourceManager:
morphIncrementalMesh:morpher:computeEncoder:resourceManager:
unifyMesh:computeEncoder:resourceManager:
morphSparseMesh:morpher:computeEncoder:resourceManager:
_baseBuffer
_baseVertexCount
_baseBufferTypes
_baseBufferTypesCount
_baseBufferStride
_targetBufferTypes
_targetBufferTypesCount
_targetBufferStride
_dstSemanticUsageMask
_srcSemanticUsageMask
_unifyPostMorphNormals
_shouldMorphNormals
_dataKindForMorphing
_splatProvokingVertices
_postUnifyInfo
_targets
_targetCount
_originalTargets
_copyCPS
_blendCPS
_blendSparseCPS
_splatCPS
skinMesh:with:skinner:renderContext:
_vertexCount
_needNormal
_needTangent
_skinIndicesBuffer
_skinWeightsBuffer
_computePS
_computeStageDesc
setStageInRegion:
initWithBodyA:anchorA:bodyB:anchorB:
initWithBody:anchor:
jointWithBodyA:anchorA:bodyB:anchorB:
jointWithBody:anchor:
field
setBlock:
setSmoothness:
setAnimationSpeed:
isExclusive
_createField
_setupCommonProperties
setHalfExtent:
setStrength:
setFalloffExponent:
setMinimumDistance:
setActive:
setScope:
setUsesEllipsoidalExtent:
setExclusive:
dragField
customFieldWithEvaluationBlock:
vortexField
radialGravityField
linearGravityField
noiseFieldWithSmoothness:animationSpeed:
turbulenceFieldWithSmoothness:animationSpeed:
springField
electricField
magneticField
_setDisplayScaleFactor:
strength
falloffExponent
minimumDistance
scope
exclusive
setDirection:
_halfExtent
_strength
_falloffExponent
_minimumDistance
_active
_scope
_usesEllipsoidalExtent
_exclusive
_direction
_field
axis
smoothness
animationSpeed
_smoothness
_animationSpeed
fractionCompleted
initWithTechniqueRef:
_symbolsAssignedValues
dictionaryRepresentation
techniqueWithDictionary:
setValue:forSymbolNamed:
initPresentationTechniqueWithTechniqueRef:
_customEncodingOfSCNTechnique:
_customDecodingOfSCNTechnique:
techniqueBySequencingTechniques:
valueForSymbolNamed:
_didInstallInEngineContext:
_valueForSymbol
initWithMorphRef:
initPresentationMorpherWithMorphRef:
presentationMorpher
setUnifiesNormals:
targets
_weightIndexForTargetNamed:
setWeight:forTargetAtIndex:
weightForTargetAtIndex:
initWithFormat:
weightIndexStringForIndex:
setCalculationMode:
channelTargetCounts
channelTargetWeights
unifiesNormals
_customEncodingOfSCNMorpher:
_customDecodingOfSCNMorpher:
_didDecodeSCNMorpher:
shouldMorphNormals
setShouldMorphNormals:
setWeight:forTargetNamed:
weightForTargetNamed:
wantsCPUMorphing
setWantsCPUMorphing:
convertToAdditiveWithBaseGeometry:
_isUsingSparseTargets
convertToSparseWithBaseGeometry:
_morpher
_calculationMode
_weights
_channelTargetCounts
_channelTargetWeights
_targetNameToIndexes
_unifyNormal
_useSparseTargets
deallocateElementAtOffset:
initWithPage:
_parentPage
addIndexesInRange:
removeIndex:
addIndex:
_allocateElement
initWithBuffer:elementSize:
isFull
hasFreeElementsLeft
newSubBuffer
_elementSize
_freeIndices
_newSubBuffer
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
elementSize
_bufferSize
_pages
_currentAllocatorPage
_allocatorLock
SCNJSExportProtocol
imageWithURL:
imageWithPath:
valueWithVector3:
valueWithVector4:
valueWithMatrix4:
color::::
toDouble
valueWithObject:inContext:
valueWithVector4:inContext:
valueWithVector3:inContext:
valueWithTransform3D:inContext:
toVector4
toVector3
toTransform3D
toBool
setValue:forProperty:
center
setAnimationTimingFunction:
setPath:
setSemantic:forSymbol:options:
semanticForSymbol:
vertexShader
fragmentShader
tessellationControlShader
tessellationEvaluationShader
geometryShader
vertexFunctionName
fragmentFunctionName
weightAtTargetIndex:
setWeight:atTargetIndex:
screenSpaceRadius
worldSpaceDistance
levelOfDetailWithGeometry:screenSpaceRadius:
levelOfDetailWithGeometry:worldSpaceDistance:
removeAllAudioPlayers
influenceFactor
setInfluenceFactor:
isIncremental
setIncremental:
targetOffset
setTargetOffset:
setLocalFront:
upVector
setUpVector:
gimbalLockEnabled
setGimbalLockEnabled:
lookAtConstraintWithTarget:
primitiveRange
pointSize
setPointSize:
minimumPointScreenSpaceRadius
setMinimumPointScreenSpaceRadius:
maximumPointScreenSpaceRadius
setMaximumPointScreenSpaceRadius:
geometrySourceWithVertices:count:
geometrySourceWithNormals:count:
geometrySourceWithTextureCoordinates:count:
extrusionDepth
setExtrusionDepth:
chamferMode
setChamferMode:
chamferProfile
setChamferProfile:
shapeWithPath:extrusionDepth:
initWithChainRootNode:
setMaxAllowedRotationAngle:forJoint:
maxAllowedRotationAngleForJoint:
chainRootNode
targetPosition
setTargetPosition:
inverseKinematicsConstraintWithChainRootNode:
transformConstraintInWorldSpace:withBlock:
positionConstraintInWorldSpace:withBlock:
orientationConstraintInWorldSpace:withBlock:
isWrapped
setWrapped:
containerFrame
setContainerFrame:
textSize
truncationMode
setTruncationMode:
alignmentMode
setAlignmentMode:
textWithString:extrusionDepth:
valueForProperty:
isUndefined
_layer
__renderLayer:withCARenderer:engineContext:viewport:atTime:forceUpdate:didUpdate:
layerToFocusForRenderedLayer:
setAnchorPoint:
anchorPoint
beginFrameAtTime:timeStamp:
updateBounds
endFrame
clearValue
addUpdateRect:
layerSizeInPixels
__updateTextureWithLayer:engineContext:sampler:
layerContentsScaleFactor
completionBlock
currentState
checkUncommittedTransactions
dataByConvertingDoublesToFloats:count:
initWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:
initWithData:semantic:vectorCount:componentType:componentCount:dataOffset:dataStride:
dataWithVector3Array:count:bytesPerComponent:
dataWithPointArray:count:bytesPerComponent:
initWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:
raise:format:
geometrySourceWithColorComponents:count:hasAlpha:colorSpace:
geometrySourceWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:
_geometrySourceWithSource:vertexFormat:
_printData
_meshSource
_semantic
_vectorCount
_componentCount
_dataOffset
_dataStride
_mkSemantic
_mtlBuffer
_mtlVertexFormat
mutableData
initWithMeshElement:
initWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:
_optimizedGeometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:
_optimizeTriangleIndices
_computeACMR
_meshElement
_elementData
_primitiveCount
_primitiveRange
_indicesChannelCount
_interleavedIndicesChannels
_bytesPerIndex
_pointSize
_minimumPointScreenSpaceRadius
_maximumPointScreenSpaceRadius
initWithDeviceRef:
handleReport:data:
deviceRef
setEnableFreeCamera:
freeCamera
enableFreeCamera
autoSwitchToFreeCamera
setAutoSwitchToFreeCamera:
activateFreeCamera
_view
_hidManager
_controllers
_enableFreeCamera
_autoSwitchToFreeCamera
invalidateCameraTarget
setAutomaticCameraTarget:
_switchToFreeViewCamera
frontVector
_browseScale
setCameraTarget:
_resetFreeViewCamera
_prepareFreeViewCamera
viewedObjectSphere
updateBrowseScaleFactor
_freeCameraActivated
_installFreeViewCameraIfNeeded
computeAutomaticTargetPoint
cameraAutomaticTargetPoint
cameraTarget
zoomBy:animate:
_translationCoef
focusNode:
_resetBrowseScaleFactor
_rotateWithDrag:mode:stickyAxis:
translateByX:Y:Z:
_isInertiaRunning
_onInertiaTimer
_3DConnexionIsPressed
endDraggingWithVelocity:
computeBoundingSphereOmittingFloorsForNode:sphere:
frontVectorWithPointOfView:
matrixWithNoRoll:
floatForKey:
deltaY
_scrollWheelMultiplier
magnification
_beginTranslateAtLocation:
_startBrowsingIfNeeded:
_computeStickyAxisIfNeeded:
_didDragTo:
_translateTo:
endDragging
allowsTranslation
setAllowsTranslation:
enableInertia
setEnableInertia:
gimbalLockMode
setGimbalLockMode:
gimbalLockVector
setGimbalLockVector:
automaticCameraTarget
stickyAxis
setStickyAxis:
zoomBy:
rotateWithVector:mode:
_freeViewCameraNode
_initialPoint
_initialMatrix
_initialZoom
_originalFovX
_originalFovY
_originalOrthoScale
_zoomFactor
_clickOrigin
_stickyMove
_stickyDirection
_currentStickyAxis
_lastDragLocation
_lastDragTime
_stickyAxis
_viewedObjectSphere
_isViewedObjectSphereComputed
_hasAutomaticCameraTarget
_automaticCameraTargetUpToDate
_didEverFocusNode
_allowsTranslation
_pinchShouldMoveCamera
_alternateMode
_upDirIsSet
_gimbalLockMode
_inertiaRunning
_browseMode
_upDir
_autoCameraTarget
_browseScaleFactor
_totalDragWithInertia
_inertiaVelocity
_lastSimulationTime
initWithBytesNoCopy:length:freeWhenDone:
setKeyCodeConfiguration:
_computeAutomaticTargetPointIfNeeded
focusNodes:
_pointOfViewUsesOrthographicProjection
_pointOfViewOrthographicScale
_orthographicScaleForZoomFactor:
_sceneBoundingSphere
_orthographicZoomFactorForProposedZoomFactor:
_setPointOfViewOrthographicScale:
didChangePointOfView
_defaultTargetForScene:
_stopInertia
_setupUpVector
isHandlingKeyboard
isARepeat
timestamp
keyCode
willChangePointOfView
updateKeyboardStateAndRedrawIfNeeded:
_willBeginInteraction
_computeTranslationOrigin3DFromPoint:
_effectiveStickyAxis
_translateToViewPoint:
_modeSensitivity
mouseLocationOutsideOfEventStream
momentumPhase
hasPreciseScrollingDeltas
scrollingDeltaY
scrollingDeltaX
isDirectionInvertedFromDevice
phase
viewportMousePosition
panSensitivity
truckSensitivity
rotationSensitivity
flyModeVelocity
setFlyModeVelocity:
setPanSensitivity:
setTruckSensitivity:
setRotationSensitivity:
_computeBoundingSphereOmittingFloorsForNode:sphere:
_cameraOriginalFieldOfView
_fieldOfViewZoomFactor
_orthographicZoomFactor
_translationAllowed
_isSceneBoundingSphereComputed
_shouldUpdateTarget
_shouldIgnoreMomentumEvents
_translationOrigin
_initialPointOfViewWorldPosition
_lastKeyInputTime
_flyModeVelocity
_panSensitivity
_truckSensitivity
_rotationSensitivity
_initialInputLocation
_lastInputLocation
_lastRotationAngle
_drawAtTimeLock
_keyboard
_scrollWheelModifiers
_cameraController
unsignedShortValue
SCNUI_name
SCNUID_viewForProperty:
initWithBlock:frequency:needsRenderResource:
_frequency
structType
arrayType
elementType
addPassResourceBindingsForArgument:
_parseArguments:stage:
_searchArguments:forArgumentNamed:type:
_dictionaryForFrequency:
_checkForAssociatedSamplerOnBinding:argument:
deallocateRegistry
_current
_nodeBindings
_frameBindings
_shadableBindings
_passBindings
_lightBindings
initWithRenderer:size:attributes:outputURL:
main
error
setUserInfo:
setDidEndSelector:
_exportAsMovieOperationWithDestinationURL:size:attributes:delegate:didEndSelector:userInfo:
initWithScene:attributes:outputURL:
writeToURL:options:
exportAsMovieOperationWithDestinationURL:size:attributes:delegate:didEndSelector:userInfo:
exportAsCOLLADAOperationWithDestinationURL:attributes:delegate:didEndSelector:userInfo:
succeded
progress
canceled
setCanceled:
cancel
userInfo
didEndSelector
setProgress:
setAttributes:
outputURL
setOutputURL:
setError:
setSucceded:
_didEndSelector
_startTime
_endTime
_canceled
_succeded
_progress
_error
_attributes
_outputURL
initWithMediaType:outputSettings:
setExpectsMediaDataInRealTime:
initWithAssetWriterInput:sourcePixelBufferAttributes:
removeItemAtURL:error:
initWithURL:fileType:error:
status
addInput:
startWriting
startSessionAtSourceTime:
imageToEncodeForProposedImage:userInfo:
pixelBufferPool
appendPixelBuffer:withPresentationTime:
isReadyForMoreMediaData
_copySnapshot:
renderAndAppendWithPresentationTime:usingAdaptor:metalTextureCache:cvQueue:completionBlock:
appendImage:withPresentationTime:usingAdaptor:
completedUnitCount
setCompletedUnitCount:
markAsFinished
requestMediaDataWhenReadyOnQueue:usingBlock:
finishWritingWithCompletionHandler:
_finishedExport
_setupMovieToWritableFile:
_assetWriterInput
_avAdaptor
_assetWriter
_rate
_mirrored
_supersampling
authoringEnvironment
orderedSetWithCapacity:
orderedSetWithObject:
_deleteOriginalData
effectiveEditingSpace
_updateActionWithEvent:
_snapPositionToAlign:original:unit:axisMove:rayStart:rayDir:didSnap:snapIndexes:
updateItemsPosition
updateItemsRotation:
removeAllIndexes
clearSnapIndexes
_updateCloneStateWithEvent:
_applyWithEvent:
_saveOriginalData
validateClones
authoringEnvironment:didMoveItems:fromTransform:
authoringEnvironment:didCloneSelection:
setupClones
removeClonesFromScene
addClonesToScene
_prepareSnapToAlignData:minOffset:maxOffset:
prepareSnapToAlignData
prepareSnapToAlignDataIfNeeded
xAlignment
setXAlignment:
yAlignment
setYAlignment:
zAlignment
setZAlignment:
_xAxisToZAxisTransform
_yAxisToZAxisTransform
_xyPlaneToYZPlaneTransform
_xyPlaneToXZPlaneTransform
_actionData
_isMouseDown
_readonly
_lastModifierFlags
_action
_originalData
_originalDataCount
_worldInitialMatrix
_worldMatrix
_snapToAlignCount
_snapToAlignOnX
_snapToAlignOnY
_snapToAlignOnZ
_snapXIndexes
_snapYIndexes
_snapZIndexes
_xAlignment
_yAlignment
_zAlignment
_cloneSet
_cloning
initWithContentsOfURL:options:error:
runAction:afterActionWithKey:
_subSpriteKey
_actionKey
_waitForKeyedAction
_runOnSubSprite
_fired
unsignedCharValue
numberWithChar:
valueWithPoint:
charValue
pointValue
capitalizedString
copyTo:
setConstraintRef:
finalizeDecodeConstraint:
_constraintRef
_incremental
_influenceFactor
initWithTarget:
_customEncodingOfSCNLookAtConstraint:
_customDecodingOfSCNLookAtConstraint:
_gimbalLockEnabled
_targetOffset
_upVector
_localFront
maximumDistance
setMaximumDistance:
_customEncodingOfSCNDistanceConstraint:
_customDecodingOfSCNDistanceConstraint:
distanceConstraint
distanceConstraintWithTarget:
targetDirection
setTargetDirection:
keepTargetDirection
setKeepTargetDirection:
_maximumDistance
_keepTargetDirection
_targetDirection
_maximumDirectionAngle
replicatorConstraint
replicatesOrientation
setReplicatesOrientation:
replicatesPosition
setReplicatesPosition:
replicatesScale
setReplicatesScale:
orientationOffset
setOrientationOffset:
positionOffset
setPositionOffset:
scaleOffset
setScaleOffset:
_customEncodingOfSCNReplicatorConstraint:
_customDecodingOfSCNReplicatorConstraint:
replicatorConstraintWithTarget:
_replicateOrientation
_replicatePosition
_replicateScale
_orientationOffset
_positionOffset
_scaleOffset
maximumLinearVelocity
setMaximumLinearVelocity:
maximumLinearAcceleration
setMaximumLinearAcceleration:
decelerationDistance
setDecelerationDistance:
accelerationConstraint
_maximumLinearVelocity
_maximumLinearAcceleration
_decelerationDistance
collisionCategoryBitMask
setCollisionCategoryBitMask:
sliderConstraint
occluderCategoryBitMask
setOccluderCategoryBitMask:
bias
setBias:
avoidOccluderConstraint:shouldAvoidOccluder:forNode:
avoidOccluderConstraint:didAvoidOccluder:forNode:
_customEncodingOfSCNAvoidOccluderConstraint:
_customDecodingOfSCNAvoidOccluderConstraint:
avoidOccluderConstraint
avoidOccluderConstraintWithTarget:
setFreeAxes:
freeAxes
billboardConstraint
_freeAxes
constantScaleConstraint
initTransformInWorld:withBlock:
initPositionInWorld:withBlock:
initOrientationInWorldSpace:withBlock:
joint
setJoint:
maxAllowedRotationAngle
setMaxAllowedRotationAngle:
setChainRootNode:
jointForNode:
_customEncodingOfSCNIKConstraint:
_customDecodingOfSCNIKConstraint:
_didDecodeSCNIKConstraint:
_chainRootNode
_ikTarget
_jointsPerNode
setFrequency:
setSemantic:
infoWithSemantic:options:
postNotificationName:object:userInfo:
programIsOpaque:
setSemanticInfos:
_customEncodingOfSCNProgram:
_customDecodingOfSCNProgram:
setByAddingObject:
programWithLibrary:
shadingLanguage
_optionsForSymbol:
_allSymbolsWithSceneKitSemantic
_bufferBindings
setSemantic:forSymbol:
_vertexShader
_tessellationControlShader
_tessellationEvaluationShader
_geometryShader
_fragmentShader
_vertexFunctionName
_fragmentFunctionName
_semanticInfos
_opaque
_library
_stopObservingProgram
_programDidChange:
_setC3DProgram
_startObservingProgram
program:bindValueForSymbol:atLocation:programID:renderer:
program:unbindValueForSymbol:atLocation:programID:renderer:
owner
initWithDictionary:copyItems:
_shaderModifiersDidChange
_updateC3DProgramInputForSymbol:
_programFromPassAtIndex:
_updateC3DProgramInput:forSymbol:
_updateAllC3DProgramInputs
_setC3DProgramDelegate
_customEncodingOfSCNShadableHelper:
_customDecodingOfSCNShadableHelper:
_didDecodeSCNShadableHelper:
_bindValueForSymbol:atLocation:programID:node:renderer:
_unbindValueForSymbol:atLocation:programID:node:renderer:
_shaderModifiers
_argumentsNames
_symbolToBinder
_symbolToUnbinder
issueWithShadable:entryPoint:effectiveModifier:message:line:type:
shadable
entryPoint
effectiveModifier
message
line
_shadable
_entryPoint
_effectiveModifier
_message
_line
stringWithContentsOfFile:encoding:error:
enumerateLinesUsingBlock:
program:handleError:
initPresentationTextGeometryWithTextGeometryRef:
initWithTextGeometryRef:
attribute:atIndex:effectiveRange:
params
_customEncodingOfSCNText:
_customDecodingOfSCNText:
setDiscretizedStraightLineMaxLength:
rectValue
set_wantsSeparateGeometryElements:
text
copyAnimationPathForKeyPath:animation:
_wantsSeparateGeometryElements
discretizedStraightLineMaxLength
_flatness
_chamferRadius
_extrusionDepth
_discretizedStraightLineMaxLength
_chamferProfile
_string
_font
_wrapped
_alignmentMode
_truncationMode
_useCustomContainerFrame
_customContainerFrame
__wantsSeparateGeometryElements
initPresentationShapeGeometryWithShapeGeometryRef:
_customEncodingOfSCNShape:
_customDecodingOfSCNShape:
initWithShapeGeometryRef:
_chamferMode
setLineBreakMode:
_setupWithGeometry:thresholdMode:value:
initWithGeometry:thresholdMode:lod:
_customEncodingOfSCNLevelOfDetail:
_didDecodeSCNLevelOfDetail:
initWithGeometry:thresholdMode:thresholdValue:
_lod
_mode
cacheObject:forKey:
URLOfResourceNamed:
enumeratorAtPath:
nextObject
caseInsensitiveCompare:
lookUpKeyForObjectNamed:class:
recursivePathsForResourcesOfType:inDirectory:
assetCatalogNamed:
clearCache
pathByMakingURLRelativeToCatalog:
sceneDatabase
addInstance:withName:class:
Textures
SCNMonitor
SCNTypeInspector
NSOutlineViewDataSource
NSObject
NSOutlineViewDelegate
NSControlTextEditingDelegate
SCNActionRepeat
SCNActionFade
SCNWeakPointer
SCNMTLTessellator
SCNLowLatencyMetalLayer
SCNMetalBackingLayer
SCNBackingLayer
SCNActionPlaySound
SCNUIImagePicker
SCNActionSequence
SCNMTLRenderPass
SCNMTLReduceDepthPass
C3DBinding
SCNCommonProfileProgramGeneratorMetal
C3DAnimationBinding
SCNAuthoringEnvironment
SCNPhysicsCharacter
SCNRenderContextMetal
SCNBufferStream
SCNActionJavaScript
SCNParticleSystem
NSCopying
NSSecureCoding
NSCoding
SCNAnimatable
SCNRendererOptionsPanelController
SCNPhysicsWorld
SCN_DisplayLinkExtensions
SCNRenderTarget
SCNRenderContextOpenGL
SCNLayer
SCNSceneRenderer
SCNTechniqueSupport
SCNRendererOptionsPanel
SCN_NSImageFromSlotContents
SCNCommonProfileProgramCache
SCNCommonProfileProgramGenerator
SCNDeferredProgramGeneratorMetal
SCNPhysicsBehavior
SCNManipulableItem
SCNNodeManipulableItem
SCNJitterer
SCNModelIO
MDLMorphDeformerComponent
MDLComponent
MDLSkinDeformerComponent
SceneKitAdditions
SCNExtensions
SCNTechniquePanelController
SCNRenderTargetView
SCNActionRunBlock
SCNReferenceNode
SCNNodeReference
SCNAnimationReference
SCNActionReference
SCNMetalLayer
SCNUIProperty
SCN_NSImageFromParticleImage
SCNUID_ConstantTransformer
SCNUID_NumberTransformer
SCNUIDynamicInspector
SCNPhysicsConeTwistJoint
SCNParticlePropertyController
SCNAVPlayerSource
SCNActionCustom
SCNActionWait
SCNActionRemove
SCNCamera
SCNAdditions
Core3DKitAdditions
SCNLight
SCNMaterial
SCNShadable
SCNNode
SCNActionable
SCNBoundingVolume
Transforms
SIMD
SCNScene
SCNTextureSource
SCNImageSource
SCNTextureOffscreenRenderingSource
SCNSourceRendererRegistry
SCNDelegateSource
SCNTextureDelegateSource
SCNSSAOPass
SCNActionPerformSelector
SCNUtils
SCNView
SCNPhysicsVehicleWheel
SCNActionScale
SCNAction
Internal
SCNActionTargetState
SCNNodeComponent
SCNNodeWeakComponent
SCNRendererTransitionContext
SCNRenderer
SCNOffscreenRenderer
SCNAddition
SCNMTLBuffer
SCNMTLResourceBinding
SCNMTLSemanticResourceBinding
SCNMTLPassResourceBinding
SCNMetalShadable
SCNMetalRenderPipeline
SCNMetalMesh
SCNMetalMeshElement
SCNPhysicsSliderJoint
SCNActionMove
SCNDeepCopy
SCNOrderedDictionary
SCN_CAKeyframeAnimation
SCNAnimationEvent
SCNTimingFunction
SCNAnimation
SCNAnimationPlayer
SCNSceneSource
NSKeyedUnarchiverDelegate
SCNKeyedUnarchiver
SCNKeyedArchiver
SCNHitTestResult
SCNMaterialAttachment
MTLTexture
MTLResource
SCNMaterialProperty
SCNFloor
SCNPhysicsVehicle
SCNGeometry
SCNMutableGeometry
SCNSpriteKitEventHandler
SCNCameraController
SCNAuthoringEnvironment2
3@$0"0 0
SCNMetalLibraryManager
NSFilePresenter
SCNCommonProfileProgramGeneratorGL
SCNRenderTargetRegistry
SCNActionHide
SCNUIScrubberCell
SCNUIScrubber
SCNSkinner
C3DIONSZipFileArchive
SCN_DTAdditions
SCNMTLShadableKey
SCNMetalWireframeResource
1$0"0 0
2%0"0 0 0
SCNMetalShaderManager
MTLBuffer
SCNMetalResourceManager
SCNResourceManager
SCNAudioPlayer
SCNAudioSource
SCNPhysicsContact
SCNPhysicsBody
SCNPlane
SCNBox
SCNPyramid
SCNSphere
SCNCylinder
SCNCone
SCNTube
SCNCapsule
SCNTorus
SCNSpriteKitSource
SCNTextureSpriteKitSource
SCNDisplayLink
SCNTechniquePanel
SCNActionRotate
SCNUISceneGraphView
SCNActionGroup
MTLDevice
SCNRenderContextImp
SCNRenderContext
SCNPhysicsShape
SCNPostProcessPass
SCNUIArrayEditor
SCNUIArrayEditorController
SCNUIHandleButton
SCNUIColorWell
SCNUIBindableView
SCNUIVector4TextField
SCNUIMatrix4TextField
SCNUIVector3TextField
SCNUIVector2TextField
SCNUIPopUpButton
SCNGeometryTessellator
SCNMTLMorph
SCNMTLSkin
SCNPhysicsBallSocketJoint
SCNPhysicsField
SCNPhysicsLinearGravityField
SCNPhysicsRadialGravityField
SCNPhysicsSpringField
SCNPhysicsMagneticField
SCNPhysicsElectricField
SCNPhysicsDragField
SCNPhysicsCustomField
SCNPhysicsVortexField
SCNPhysicsNoiseField
SCNPhysicsTurbulenceField
_C3DProgressDebugger
SCNTechnique
SCNMorpher
SCNMTLSubBuffer
SCNFixedSizePage
SCNMTLBufferAllocator
SCNJSLayerJSExport
JSExport
SCN_JSSupport
SCNJSImageJSExport
SCNJSImage
SCNJSValueSExport
SCNJSValue
SCNJSExtensions
SCNJSValueTmpImp
SCNMaterialPropertyJSExport
SCNBoundingBoxJSExport
SCNBoundingSphereJSExport
SCNTransactionJSExport
SCNColorJSExport
SCNJSBasicAnimationJSExport
SCNJSAnimationGroupJSExport
SCNJSKeyframeAnimationJSExport
SCNViewJSExport
SCNMetalLayerJSExport
SCNPhysicsBehaviorJSExport
SCNParticlePropertyControllerJSExport
SCNPhysicsHingeJointJSExport
SCNPhysicsContactJSExport
SCNProgramJSExport
SCNTorusJSExport
SCNMorpherJSExport
SCNCapsuleJSExport
SCNLevelOfDetailJSExport
SCNRendererJSExport
SCNCylinderJSExport
SCNFloorJSExport
SCNNodeJSExport
SCNPlaneJSExport
SCNPhysicsBallSocketJointJSExport
SCNConeJSExport
SCNSphereJSExport
SCNGeometryJSExport
SCNConstraintJSExport
SCNPhysicsSliderJointJSExport
SCNLightJSExport
SCNMaterialJSExport
SCNParticleSystemJSExport
SCNHitTestResultJSExport
SCNPhysicsVehicleJSExport
SCNTubeJSExport
SCNLookAtConstraintJSExport
SCNPhysicsShapeJSExport
SCNGeometryElementJSExport
SCNGeometrySourceJSExport
SCNShapeJSExport
SCNSceneSourceJSExport
SCNPyramidJSExport
SCNCameraJSExport
SCNIKConstraintJSExport
SCNTechniqueJSExport
SCNPhysicsWorldJSExport
SCNPhysicsBodyJSExport
SCNBoxJSExport
SCNTransformConstraintJSExport
SCNAnimationEventJSExport
SCNActionJSExport
SCNSceneJSExport
SCNPhysicsVehicleWheelJSExport
SCNPhysicsFieldJSExport
SCNTextJSExport
SCNJSMediaTimingFunctionJSExport
SCNLayerSource
SCNTextureLayerSource
SCNBoundingBox
SCNBoundingSphere
SCNTransaction
SCNGeometrySource
SCNMutableGeometrySource
SCNGeometryElement
SCN3DConnexionDevice
SCNEventHandler
SCNCameraControlEventHandler
SCNCameraNavigationController
SCNCameraControlConfiguration
SCNCameraControllerDelegate
SCNUIDynamicInspectorConfiguration
SCNUIDynamicUI
SCNMTLArgumentBinder
SCNMTLShaderBindingsGenerator
SCNMovieExport
SCNExportAddition
SCNExportOperation
_SCNExportOperation
SCNMovieExportOperation
SCNCOLLADAExportOperation
SCNManipulator
SCNActionRunAction
SCNConstraint
SCNLookAtConstraint
SCNDistanceConstraint
SCNReplicatorConstraint
SCNAccelerationConstraint
SCNSliderConstraint
SCNAvoidOccluderConstraint
SCNBillboardConstraint
SCNConstantScaleConstraint
SCNTransformConstraint
SCNIKJoint
SCNIKConstraint
/////////$2@
SCNBufferBinding
SCNProgramSemanticInfo
SCNProgram
SCNShadableHelper
_SCNShadableCompilationIssue
SCNText
SCNShape
SCNPhysicsHingeJoint
SCNLevelOfDetail
SCNAssetCatalog
SCNSceneDatabase
SCNSceneLookUpUnarchiver
@48@0:8@16@24@32@?40
v44@0:8@16@24Q32c40
v40@0:8@16@24@?32
@40@0:8@16@24@32
@16@0:8
@40@0:8@16Q24^Q32
@28@0:8@16c24
@24@0:8@16
v36@0:8@16@24c32
v24@0:8@16
@32@0:8^{__C3DImage=}16c24i28
v48@0:8^{__C3DImage=}16@24@32i40c44
@36@0:8@16Q24c32
@32@0:8^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16^{__C3DEngineContext=}24
@40@0:8^{__C3DImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^{__C3DEngineContext=}32
@52@0:8^{__C3DImage=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24i32@36@44
v20@0:8i16
v16@0:8
^{__C3DScene=}16@0:8
v48@0:8@16@24@32^v40
@"NSView"
[10@"NSView"]
@"SCNView"
c24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
c16@0:8
c24@0:8#16
c24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
c24@0:8@"Protocol"16
@"NSString"16@0:8
q32@0:8@16@24
@40@0:8@16q24@32
c32@0:8@16@24
v48@0:8@16@24@32@40
@32@0:8@16@24
v32@0:8@16@24
v56@0:8@16@24{CGPoint=dd}32@48
v56@0:8@16@24{CGPoint=dd}32Q48
c40@0:8@16@24@32
Q48@0:8@16@24@32q40
c48@0:8@16@24@32q40
q32@0:8@"NSOutlineView"16@24
@40@0:8@"NSOutlineView"16q24@32
c32@0:8@"NSOutlineView"16@24
@40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
v48@0:8@"NSOutlineView"16@24@"NSTableColumn"32@40
@32@0:8@"NSOutlineView"16@24
v32@0:8@"NSOutlineView"16@"NSArray"24
@"<NSPasteboardWriting>"32@0:8@"NSOutlineView"16@24
v56@0:8@"NSOutlineView"16@"NSDraggingSession"24{CGPoint=dd}32@"NSArray"48
v56@0:8@"NSOutlineView"16@"NSDraggingSession"24{CGPoint=dd}32Q48
c40@0:8@"NSOutlineView"16@"NSArray"24@"NSPasteboard"32
v32@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24
Q48@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24@32q40
c48@0:8@"NSOutlineView"16@"<NSDraggingInfo>"24@32q40
@"NSArray"40@0:8@"NSOutlineView"16@"NSURL"24@"NSArray"32
v40@0:8@16@24@32
c40@0:8@16@24:32
@64@0:8@16@24@32{_NSRange=QQ}40^q56
c32@0:8@"NSControl"16@"NSText"24
c40@0:8@"NSControl"16@"NSString"24@"NSString"32
v40@0:8@"NSControl"16@"NSString"24@"NSString"32
c32@0:8@"NSControl"16@24
c40@0:8@"NSControl"16@"NSTextView"24:32
@"NSArray"64@0:8@"NSControl"16@"NSTextView"24@"NSArray"32{_NSRange=QQ}40^q56
v40@0:8@16@24q32
@72@0:8@16@24^{CGRect={CGPoint=dd}{CGSize=dd}}32@40@48{CGPoint=dd}56
d32@0:8@16@24
@48@0:8@16@24@32@40
c48@0:8@16@24@32@40
d32@0:8@16q24
c40@0:8@16q24q32
@"NSView"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
@"NSTableRowView"32@0:8@"NSOutlineView"16@24
v40@0:8@"NSOutlineView"16@"NSTableRowView"24q32
c40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
c24@0:8@"NSOutlineView"16
@"NSIndexSet"32@0:8@"NSOutlineView"16@"NSIndexSet"24
c32@0:8@"NSOutlineView"16@"NSTableColumn"24
v32@0:8@"NSOutlineView"16@"NSTableColumn"24
@"NSString"72@0:8@"NSOutlineView"16@"NSCell"24^{CGRect={CGPoint=dd}{CGSize=dd}}32@"NSTableColumn"40@48{CGPoint=dd}56
d32@0:8@"NSOutlineView"16@24
@"NSString"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
@48@0:8@"NSOutlineView"16@24@32@"NSString"40
c40@0:8@"NSOutlineView"16@"NSEvent"24@"NSString"32
c48@0:8@"NSOutlineView"16@"NSCell"24@"NSTableColumn"32@40
@"NSCell"40@0:8@"NSOutlineView"16@"NSTableColumn"24@32
d32@0:8@"NSOutlineView"16q24
c40@0:8@"NSOutlineView"16q24q32
v24@0:8@"NSNotification"16
@48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
@"NSOutlineView"
@"NSMutableDictionary"
@32@0:8@16Q24
@24@0:8^{_NSZone=}16
^{SCNCActionRepeat=^^?f@?@BdddddBB@?^{__CFString}qdddd^{SCNCAction}QQdc}
@"SCNAction"
@32@0:8d16d24
@24@0:8d16
^{SCNCActionFade=^^?f@?@BdddddBB@?^{__CFString}qddddfffc}
@32@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@24
{?=b2b2b2b1}28@0:8@16C24
C28@0:8@16C24
@?28@0:8@16C24
v64@0:8{?=@@@@^{?}BB}16
v88@0:8{?=@@I@@@@@C}16
v40@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16
v56@0:8@16@24Q32@40@48
v88@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16{?=@@@@^{?}BB}40
v56@0:8{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}16@40@48
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}
@"SCNMetalResourceManager"
{?="type"C"tessellationFactorScale"f"tessellationPartitionMode"I"tessellationSmoothingMode"C"parameters"(?="uniform"{?="edgeTessellationFactor"f"insideTessellationFactor"f}"screenSpaceAdaptive"{?="projectedEdgeLength"f}"constrainedEdgeLength"{?="maximumEdgeLength"f}"subdivisionSurface"{?="tessellationLevel"C"wantsSingleCreasePatch"b1"useScreenSpaceTessellation"b1})}
@"<MTLBuffer>"
@20@0:8I16
v24@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16
c48@0:8@16@24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v48@0:8@16@24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v24@0:8^{CGContext=}16
^{SCNCPlaySound=^^?f@?@BdddddBB@?^{__CFString}qddddcc@}
v48@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16
Q24@0:8@16
:16@0:8
v24@0:8:16
@"NSImage"
^{SCNCActionSequence=^^?f@?@BdddddBB@?^{__CFString}qdddd{vector<SCNCAction *, std::__1::allocator<SCNCAction *> >=^^{SCNCAction}^^{SCNCAction}{__compressed_pair<SCNCAction **, std::__1::allocator<SCNCAction *> >=^^{SCNCAction}}}Qd}
@"NSArray"
@?16@0:8
v24@0:8@?16
@"<MTLComputePipelineState>"
[2@"<MTLTexture>"]
@"NSString"
@"NSDictionary"
i16@0:8
^{__C3DFXProgram=}40@0:8^{__C3DRendererElementProgramHashCode=}16^{__C3DEngineContext=}24^{?=q^{?}[4{?=qq}][4{?=qq}][4q]^v^vB}32
^{__C3DModelTarget={__CFRuntimeBase=QAQ}^v^vscCCB^?^?}
q16@0:8
@24@0:8^{__C3DEngineContext=}16
{CATransform3D=dddddddddddddddd}16@0:8
v20@0:8c16
v24@0:8q16
v24@0:8Q16
v72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@64
v48@0:8@16{CGPoint=dd}24@40
d16@0:8
^{__C3DEngineContext=}
@"<SCNSceneRenderer>"
^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}
{?="weakProgram"^{__C3DFXProgram}"baseIndex"I"baseVertex"I"vertexSize"I"allocatedVerticesSize"I"allocatedIndicesSize"I"textureImage"^{__C3DImage}"texture"^{__C3DTexture}"drawMode"I"orthographic"B"clearDepthBuffer"B"enableDepthTest"B"enableCulling"B"isDynamic"B"mesh"^{__C3DMesh}"meshElement"^{__C3DMeshElement}"_cache"{?="verticesStride"Q"colorsStride"Q"uvsStride"Q"verticesData"*"colorsData"*"uvsData"*}"_usedMeshes"@"NSMutableSet""_freeMeshes"@"NSMutableSet""_usedMeshElements"@"NSMutableSet""_freeMeshElements"@"NSMutableSet"}
{?="textureInfo"{?="texture"^{__C3DImage}"textureSize"{CGSize="width"d"height"d}"isRetina"B}"lineHeight"d"characterWidth_texture"s"characterWidth_typography"^d"characterHeight_texture"s"symbolRects"^{?}}
^{__C3DRasterizerStates=}
@"NSSet"
@"NSMutableOrderedSet"
@"NSMutableArray"
{?="initialized"B"showFullStatistics"B"fps"f"waitDisplayLinkTime"f"pressedButtonIndex"q"fpsString"^{__CFString}"shortString"^{__CFString}"internalString"^{__CFString}"lightingStatistics"[9I]"stats"{__C3DEngineStats="verticesProcessed"I"primitivesProcessed"I"drawCount"I"drawStep"I"frameCount"I"fboSwitches"I"vboSwitches"I"attSwitches"I"attEnabling"I"iboSwitches"I"vaoSwitches"I"prgSwitches"I"texSwitches"I"rssSwitches"I"getCount"I"uniformFloatSent"I"uniformIntSent"I"uniformVector2Sent"I"uniformVector3Sent"I"uniformVector4Sent"I"uniformMatrix4Sent"I"vboUploaded"I"iboUploaded"I"texUploaded"I"cpuTime"d"cstrTime"d"phyTime"d"prtTime"d"animTime"d"skinTime"d"mrphTime"d"rendTime"d"twoDTime"d"delegateTime"d"glFlushTime"d"waitDisplayLinkTime"d"drawableWaitTime"d"lastDisplayLinkTime"d"prgCount"I"texCount"I"fboCount"I"vboCount"I"rboCount"I"iboCount"I"cboCount"I"vaoCount"I"fboMemory"I"rboMemory"I"vboMemory"I"iboMemory"I"cboMemory"I"texMemory"I"backBufferMemory"I"depthBuffersMemory"I"frmAvgTime"d"frmMinTime"d"frmMaxTime"d"frameTimeHistory"[60d]"frameTimeCurrentIndex"I"startTime"d"lastFrameTime"d}}
@"SCNManipulator"
@"SCNAuthoringEnvironment2"
v40@0:8{SCNVector3=ddd}16
v24@0:8d16
{?="characterBody"@"SCNPhysicsBody""direction"{SCNVector3="x"d"y"d"z"d}"velocity"d"jumpSpeed"d}
^{btCharacterControllerInterface=^^?}
^{btPairCachingGhostObject=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btHashedOverlappingPairCache}}
^{btOverlapFilterCallback=^^?}
^{btCapsuleShape=^^?i^v{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffi}
@"SCNPhysicsWorld"
v32@0:8^v16Q24
^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}32@0:8@16@24
@32@0:8@16^{__C3DEngineContext=}24
^{__C3DEngineContext=}16@0:8
^v16@0:8
I16@0:8
c24@0:8Q16
^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}16@0:8
@48@0:8{?=CCCb1b1b1b1b1[4C]}1624@32q40
c40@0:8@16^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}24^{?=CCB}32
c27@0:8^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}16{?=CCB}24
v24@0:8^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}16
@40@0:8^{?=CCCb1b1b1b1b1[4C]}1624Q32
@24@0:8^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16
v24@0:8^{__C3DRasterizerStates=}16
v32@0:8@16Q24
v32@0:8^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16^{__C3DEngineContext=}24
v32@0:8^{__C3DImageProxy={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^vC}16^{__C3DEngineContext=}24
v148@0:8^{__C3DMesh=}16^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}fff^v^{__C3DMeshSource}[2]^{?}I}24^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}32^{__C3DEngineContext=}40(C3DMatrix4x4=[16f][4]{?=[4]})48r^{C3DColor4=(?=[4f]{?=ffff})}112^{__C3DRasterizerStates=}120^{__C3DBlendStates=}128^{__C3DImage=}136c144
v36@0:8^{?=SS}16I24^{?=^{__C3DEnginePipeline}^{__C3DEngineContext}^{__C3DFXPassInstance}^i^{__C3DNode}BB}28
v24@0:8^{?=^{__C3DEnginePipeline}^{__C3DEngineContext}^{__C3DFXPassInstance}^i^{__C3DNode}BB}16
@24@0:8Q16
@20@0:8i16
v24@0:8^{__C3DMaterial=}16
v32@0:8^{__C3DRendererElement=^{__C3DNode}^{__C3DGeometry}^{__C3DMesh}^v^{__C3DMaterial}^{__C3DFXTechnique}^{__C3DRendererElementProgramHashCode}{?=[8C]}iIb8b1b1b1b1b1b1b1b3b1b3}16^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}24
v48@0:8^{?=SS}16{?=qq}24^{__C3DRendererElementStore=}40
c32@0:8^{__C3DMesh=}16q24
v32@0:8^{__C3DMesh=}16q24
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}fff^v^{__C3DMeshSource}[2]^{?}I}36@0:8c16q20q28
v24@0:8^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}fff^v^{__C3DMeshSource}[2]^{?}I}16
v36@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}16i24^{__C3DLightRuntimeData=If[4{?=[4]}]^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}28
v28@0:8@16c24
v36@0:8@16c24d28
@"<MTLDevice>"
@"<MTLCommandQueue>"
@"NSObject<OS_dispatch_semaphore>"
{atomic<int>="__a_"Ai}
@"<MTLTexture>"
@"CAMetalLayer"
@"<CAMetalDrawable>"
@"MTLRenderPassDescriptor"
@"SCNMetalShaderManager"
@"<MTLCommandBuffer>"
{SCNMTLRenderCommandEncoder="_winding"Q"_cullMode"Q"_fillMode"Q"_clipMode"Q"_blendColor""_lockCullMode"B"_lockFillMode"B"_vertexBuffers"[31{?="buffer"@"<MTLBuffer>""offset"Q}]"_vertexTextures"[128@"<MTLTexture>"]"_vertexSamplers"[16@"<MTLSamplerState>"]"_fragmentBuffers"[31{?="buffer"@"<MTLBuffer>""offset"Q}]"_fragmentTextures"[128@"<MTLTexture>"]"_fragmentSamplers"[16@"<MTLSamplerState>"]"_renderPipelineState"@"<MTLRenderPipelineState>""_commandBuffer"@"<MTLCommandBuffer>""_encoder"@"<MTLRenderCommandEncoder>""_bufferPool"^{SCNMTLBufferPool}"_vertexTexturesToBind"t"_fragmentTexturesToBind"t}
@"<MTLComputeCommandEncoder>"
@"<MTLBlitCommandEncoder>"
^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}
{?="vertexIndex"c"fragmentIndex"c}
[3^{SCNMTLBufferPool}]
^{SCNMTLBufferPool=@Q@Q{vector<SCNMTLBufferPool::Buffer, std::__1::allocator<SCNMTLBufferPool::Buffer> >=^{Buffer}^{Buffer}{__compressed_pair<SCNMTLBufferPool::Buffer *, std::__1::allocator<SCNMTLBufferPool::Buffer> >=^{Buffer}}}II@*QQ}
@"<MTLDepthStencilState>"
@"<MTLSamplerState>"
^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFDictionary}^v^{__CFDictionary}^v^{__CFString}}
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_group>"
{?="passInstance"^{__C3DFXPassInstance}"lightingSystem"^{__C3DLightingSystem}"dynamicBatchingSystem"^{__C3DDynamicBatchingSystem}"pass"^{__C3DFXPass}"passRequiresLighting"c"passRequiresLastFrameTransform"c"transformTree"^{__C3DTransformTree}}
{SCNSceneBuffer="viewTransform"{float4x4="columns"[4]}"inverseViewTransform"{float4x4="columns"[4]}"projectionTransform"{float4x4="columns"[4]}"viewProjectionTransform"{float4x4="columns"[4]}"viewToCubeTransform"{float4x4="columns"[4]}"lastFrameViewProjectionTransform"{float4x4="columns"[4]}"ambientLightingColor""fogColor""fogParameters""inverseResolution""time"f"sinTime"f"cosTime"f"random01"f"motionBlurIntensity"f"environmentIntensity"f"inverseProjectionTransform"{float4x4="columns"[4]}"inverseViewProjectionTransform"{float4x4="columns"[4]}"nearFar""viewportSize"}
{?="buffer"@"<MTLBuffer>""offset"Q}
{?="buffer"@"<MTLBuffer>""offset"Q"size"Q"shadowMaps"[256@"<MTLTexture>"]"textureMaps"[256@"<MTLTexture>"]"samplerStates"[256@"<MTLSamplerState>"]}
{?="modelTransform"{float4x4="columns"[4]}"lastFrameModelTransform"{float4x4="columns"[4]}"normalTransform"{float4x4="columns"[4]}"modelViewTransform"{float4x4="columns"[4]}"modelViewProjectionTransform"{float4x4="columns"[4]}"boundingBox"{float2x3="columns"[2]}"worldBoundingBox"{float2x3="columns"[2]}"instanceNode"^{__C3DNode}"flags"I"probeCacheIndex"^I"boneTransformSizeWritten"I}
{?="currentLightingSet"{?="lights"[8C]}"currentShadowMaps"[8@"<MTLTexture>"]"currentGoboMaps"[8@"<MTLTexture>"]"frameLightingSetDatas"{unordered_map<unsigned long long, SCNMTLLightSetData, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, SCNMTLLightSetData> > >="__table_"{__hash_table<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData> > >="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *> > >="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *> > >="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *> >="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *> *> >="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> > >="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::hash<unsigned long long>, true> >="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, SCNMTLLightSetData>, std::__1::equal_to<unsigned long long>, true> >="__value_"f}}}"currentLightingHashKey"Q"currentLightingDesc"{?="count"q"lights"[8^{__C3DLight}]"lightsData"[8^{__C3DLightRuntimeData}]}}
{Cache="rasterizerStates"^{__C3DRasterizerStates}"mesh"^{__C3DMesh}"metalMesh"@"SCNMetalMesh""meshElement"^{__C3DMeshElement}"metalMeshElement"@"SCNMetalMeshElement""program"^{__C3DFXProgram}"material"^{__C3DMaterial}"geometry"^{__C3DGeometry}"metalShadable"@"SCNMetalShadable""commonProfile"^{__C3DEffectCommonProfile}"blendStates"^{__C3DBlendStates}"colorBufferWriteMask"C"node"^{__C3DNode}"vertexDescriptorHash"Q"tessellationPipelineStateHash"C"renderPipeline"@"SCNMetalRenderPipeline"}
{?="debugLightMeshPass"[7^{__C3DFXPass}]"lightPasses"[7^{__C3DFXPass}]"lightMeshes"[7^{__C3DMesh}]"resourcesAreReady"c}
{?="pixelFormat"Q"depthFormat"Q"stencilFormat"Q"sampleCount"Q"replaceRPS"@"<MTLRenderPipelineState>""overRPS"@"<MTLRenderPipelineState>"}
@"<MTLRenderPipelineState>"
{?="backgroundTexture"@"<MTLTexture>""overlayTexture"@"<MTLTexture>""stencilTexture"@"<MTLTexture>"}
{?="pixelFormat"Q"sampleCount"Q"displayCubemapPS"@"<MTLRenderPipelineState>""displayTexture2DPS"@"<MTLRenderPipelineState>""displayDepth2DPS"@"<MTLRenderPipelineState>"}
{?="collectEnabled"c"errors"@"NSMutableDictionary"}
{?="currentColors"[4@"<MTLTexture>"]"currentDepth"@"<MTLTexture>""currentStencil"@"<MTLTexture>""mainColors"[4@"<MTLTexture>"]"mainDepth"@"<MTLTexture>""outputColors"[4@"<MTLTexture>"]"outputDepth"@"<MTLTexture>"}
{?="modelTransformBindingCount"I"modelViewTransformBindingCount"I"normalTransformBindingCount"I"nodeOpacityBindingCount"I}
@"<MTLRenderCommandEncoder>"
@32@0:8d16@24
@24@0:8^{__C3DParticleSystem=}16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
v32@0:8@16d24
v32@0:8d16@24
v32@0:8@"<SCNAnimation>"16@"NSString"24
v32@0:8@"SCNAnimationPlayer"16@"NSString"24
v24@0:8@"NSString"16
@"SCNAnimationPlayer"24@0:8@"NSString"16
v32@0:8@"NSString"16d24
@"CAAnimation"24@0:8@"NSString"16
v32@0:8d16@"NSString"24
c24@0:8@"NSString"16
@"NSArray"16@0:8
r^v16@0:8
^{__C3DAnimationManager=}16@0:8
v32@0:8c16@20c28
^{__C3DParticleSystem=}16@0:8
s24@0:8@16
{SCNVector3=ddd}16@0:8
{SCNVector4=dddd}16@0:8
v48@0:8{SCNVector4=dddd}16
v40@0:8q16@24@?32
v40@0:8@16q24@?32
^{__C3DParticleSystem=}
@"SCNOrderedDictionary"
@"SCNGeometry"
{SCNVector3="x"d"y"d"z"d}
@"NSColor"
{SCNVector4="x"d"y"d"z"d"w"d}
@"SCNParticleSystem"
^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][12{?=iII}][12I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16@0:8
@32@0:8@16q24
q24@0:8@16
@"SCNRendererOptionsPanel"
@"NSPopUpButton"
@"NSTextField"
@"NSSlider"
@"NSStepper"
@"NSButton"
@"SCNUIDynamicInspector"
@"NSComboBox"
c40@0:8@16@24^@32
@72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@64
@56@0:8{btVector3=(?=[4f])}16{btVector3=(?=[4f])}32@48
@288@0:8@16{CATransform3D=dddddddddddddddd}24{CATransform3D=dddddddddddddddd}152@280
^{c3dAether={vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}^^{c3dPhysicsField}{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}}}{vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}^^{c3dPhysicsField}{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >=^^{c3dPhysicsField}}}I}16@0:8
^{btVehicleRaycaster=^^?}16@0:8
^{btDynamicsWorld=^^?{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btDispatcher}{btDispatcherInfo=fiifB^{btIDebugDraw}BBBfBf}^{btBroadphaseInterface}^{btIDebugDraw}B^?^?^v{btContactSolverInfo=fffffifffffiffffiiiff}f}16@0:8
v24@0:8^v16
v56@0:8@16^{__C3DNode=}24Q32Q40Q48
v32@0:8@16^v24
^{btDiscreteDynamicsWorld=^^?{btAlignedObjectArray<btCollisionObject *>={btAlignedAllocator<btCollisionObject *, 16>=}ii^^{btCollisionObject}B}^{btDispatcher}{btDispatcherInfo=fiifB^{btIDebugDraw}BBBfBf}^{btBroadphaseInterface}^{btIDebugDraw}B^?^?^v{btContactSolverInfo=fffffifffffiffffiiiff}f{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}^{InplaceSolverIslandCallback}^{btConstraintSolver}^{btSimulationIslandManager}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}{btAlignedObjectArray<btRigidBody *>={btAlignedAllocator<btRigidBody *, 16>=}ii^^{btRigidBody}B}{btVector3=(?=[4f])}fBBBB{btAlignedObjectArray<btActionInterface *>={btAlignedAllocator<btActionInterface *, 16>=}ii^^{btActionInterface}B}i{btAlignedObjectArray<btPersistentManifold *>={btAlignedAllocator<btPersistentManifold *, 16>=}ii^^{btPersistentManifold}B}B}
^{btOverlappingPairCallback=^^?}
^{btVehicleRaycaster=^^?}
^{btC3DDebugDraw=^^?i^v}
{c3dAether="_fields"{vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >="__value_"^^{c3dPhysicsField}}}"_activeFields"{vector<c3dPhysicsField *, std::__1::allocator<c3dPhysicsField *> >="__begin_"^^{c3dPhysicsField}"__end_"^^{c3dPhysicsField}"__end_cap_"{__compressed_pair<c3dPhysicsField **, std::__1::allocator<c3dPhysicsField *> >="__value_"^^{c3dPhysicsField}}}"_lastOverrideIndex"I}
@"<SCNPhysicsContactDelegate>"
@"SCNPhysicsContact"
@"SCNScene"
@"NSMutableSet"
C16@0:8
c40@0:8^{?=CCCb1b1b1b1b1[4C]}1624Q32
{?="format"C"sampleCount"C"textureUsage"C"renderToTexture"b1"forceTextureRect"b1"viewportDependant"b1"renderToIOSurface"b1"mipmapped"b1"padding"[4C]}
@"CIImage"
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}
v48@0:8@16@24@32@?40
@40@0:8{CGPoint=dd}16@32
{SCNVector3=ddd}40@0:8{SCNVector3=ddd}16
c32@0:8@16@?24
v32@0:8@16@?24
v48@0:8@"SCNScene"16@"SKTransition"24@"SCNNode"32@?<v@?>40
@"NSArray"40@0:8{CGPoint=dd}16@"NSDictionary"32
c32@0:8@"SCNNode"16@"SCNNode"24
@"NSArray"24@0:8@"SCNNode"16
c32@0:8@16@?<c@?>24
v32@0:8@"NSArray"16@?<v@?c>24
@"SCNScene"16@0:8
v24@0:8@"SCNScene"16
@"<SCNSceneRendererDelegate>"16@0:8
v24@0:8@"<SCNSceneRendererDelegate>"16
@"SCNNode"16@0:8
v24@0:8@"SCNNode"16
@"SKScene"16@0:8
v24@0:8@"SKScene"16
@"<MTLRenderCommandEncoder>"16@0:8
@"<MTLDevice>"16@0:8
@"<MTLCommandQueue>"16@0:8
@"AVAudioEngine"16@0:8
@"AVAudioEnvironmentNode"16@0:8
@"SCNTechnique"16@0:8
v24@0:8@"SCNTechnique"16
@32@0:8@16^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24
v32@0:8^{SCNVector3=ddd}16Q24
v24@0:8^{CGColor=}16
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16@0:8
^{_CGLPixelFormatObject=}20@0:8I16
^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24@0:8^{_CGLPixelFormatObject=}16
c48@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16^{_CGLPixelFormatObject=}24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
v48@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16^{_CGLPixelFormatObject=}24d32r^{?=IiqQdq{CVSMPTETime=ssIIIssss}QQ}40
@"SCNJitterer"
@"SCNRenderer"
^{__C3DFXProgram=}
^{__CFSet=}
^{__C3DFXProgram=}48@0:8^{__C3DRendererElementProgramHashCode=}16^{__C3DEngineContext=}24@32^{?=q^{?}[4{?=qq}][4{?=qq}][4q]^v^vB}40
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
^{__CFDictionary=}
v144@0:8{CATransform3D=dddddddddddddddd}16
@"SCNNode"
@32@0:8@16d24
@"<SCNJittererDelegate>"
@"NSObject<OS_dispatch_source>"
@40@0:8@16@24Q32
@100@0:8@16Q24B32Q36Q44Q52Q60q68@76Q84@92
@"MDLAnimatedScalarArray"16@0:8
Q32@0:8^{?=[4]}16Q24
{?=[4]}16@0:8
@"NSData"16@0:8
v64@0:8@16@24c32c36f40f44@?48@?56
@56@0:8@16@24@32@40@48
@72@0:8@16@24@32@?40@48@56@64
v48@0:8@?16@?24@32@40
^{__C3DFXContext=}16@0:8
^{__C3DTexture=}16@0:8
@"SCNTechniquePanel"
@"SCNRenderTargetView"
v24@0:8^{__C3DTexture=}16
v40@0:8@16@24d32
^{__C3DTexture=}
@"SCNPlane"
@"NSOpenGLContext"
@32@0:8@?16@24
@"NSURL"
@"SCNDisplayLink"
v24@0:8#16
@32@0:8@16#24
@40@0:8@16#24@32
v40@0:8@16@24Q32
@32@0:8#16@24
@"SCNUIArrayEditor"
@"NSObjectController"
@"NSPathControl"
@288@0:8@16{CATransform3D=dddddddddddddddd}24@152{CATransform3D=dddddddddddddddd}160
@152@0:8@16{CATransform3D=dddddddddddddddd}24
{?="bodyA"@"SCNPhysicsBody""frameA"{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}"bodyB"@"SCNPhysicsBody""frameB"{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}"maximumAngularLimit1"d"maximumAngularLimit2"d"maximumTwistAngle"d}
^{btConeTwistConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ffffffff{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffffffBBBBff{btVector3=(?=[4f])}BB{btQuaternion=(?=[4f])}f{btVector3=(?=[4f])}ifff}
@"CAAnimation"
v24@0:8^{__C3DImageProxy=}16
v24@0:8^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][12{?=iII}][12I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}16
@40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
@"AVPlayer"
@"AVPlayerItemVideoOutput"
^{__CVMetalTextureCache=}
^{__CVBuffer=}
@32@0:8d16@?24
^{SCNCActionCustom=^^?f@?@BdddddBB@?^{__CFString}qdddd@?}
^{SCNCActionWait=^^?f@?@BdddddBB@?^{__CFString}qdddd}
@24@0:8^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]})dd}ffffiib1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})fffffffffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}}16
f16@0:8
v20@0:8f16
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]})dd}ffffiib1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})fffffffffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}}16@0:8
{CATransform3D=dddddddddddddddd}32@0:8{CGSize=dd}16
^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]})dd}ffffiib1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})fffffffffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}}
{CATransform3D="m11"d"m12"d"m13"d"m14"d"m21"d"m22"d"m23"d"m24"d"m31"d"m32"d"m33"d"m34"d"m41"d"m42"d"m43"d"m44"d}
@"SCNTechnique"
@"SCNMaterialProperty"
{?="intensity"f"radius"f"bias"f"depthThreshold"f"normalThreshold"f"sampleCount"q"downSample"q}
{C3DColor4=(?=[4f]{?=ffff})}28@0:8c16^c20
@24@0:8r^{C3DColor4=(?=[4f]{?=ffff})}16
@80@0:8{?=[4]}16
{CGPoint=dd}16@0:8
@32@0:8{CGPoint=dd}16
@40@0:8{SCNVector3=ddd}16
@48@0:8{SCNVector4=dddd}16
@144@0:8{CATransform3D=dddddddddddddddd}16
@24@0:8^{__C3DLight={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{C3DColor4=(?=[4f]{?=ffff})}iffffffff{C3DColor4=(?=[4f]{?=ffff})}fffffCCQBb1b1b1b1b1b1b1b1b1ddd^{__C3DEffectSlot}^{__C3DEffectSlot}if^{__C3DFXTechnique}^v^{__CFData}}16
^{__C3DLight={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{C3DColor4=(?=[4f]{?=ffff})}iffffffff{C3DColor4=(?=[4f]{?=ffff})}fffffCCQBb1b1b1b1b1b1b1b1b1ddd^{__C3DEffectSlot}^{__C3DEffectSlot}if^{__C3DFXTechnique}^v^{__CFData}}16@0:8
{CGSize=dd}16@0:8
v32@0:8{CGSize=dd}16
^{__C3DLight={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{C3DColor4=(?=[4f]{?=ffff})}iffffffff{C3DColor4=(?=[4f]{?=ffff})}fffffCCQBb1b1b1b1b1b1b1b1b1ddd^{__C3DEffectSlot}^{__C3DEffectSlot}if^{__C3DFXTechnique}^v^{__CFData}}
{CGSize="width"d"height"d}
@"NSData"
@24@0:8^{__C3DMaterial=}16
v32@0:8@"NSString"16@?<v@?II@"SCNNode"@"SCNRenderer">24
@"SCNProgram"16@0:8
v24@0:8@"SCNProgram"16
@"NSDictionary"16@0:8
v24@0:8@"NSDictionary"16
^{__C3DMaterial=}16@0:8
^{__C3DEffectCommonProfile={__CFRuntimeBase=QAQ}^{__C3DMaterial}i^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}^{__C3DEffectSlot}fffffCqBBb1b1b1b1b1b1b1b1b1b13}16@0:8
v24@0:8^@16
@24@0:8^@16
^{__C3DMaterial=}
@"SCNShadableHelper"
@24@0:8^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}16
v24@0:8@"SCNAction"16
v32@0:8@"SCNAction"16@?<v@?>24
v32@0:8@"SCNAction"16@"NSString"24
v40@0:8@"SCNAction"16@"NSString"24@?<v@?>32
@"SCNAction"24@0:8@"NSString"16
c32@0:8^{SCNVector3=ddd}16^{SCNVector3=ddd}24
v32@0:8^{SCNVector3=ddd}16^{SCNVector3=ddd}24
c32@0:8^{SCNVector3=ddd}16^d24
c36@0:8@?16c24@28
@28@0:8@?16c24
@24@0:8@?16
c24@0:8@?16
v36@0:8#16@24c32
@28@0:8#16c24
@24@0:8q16
v32@0:8@16q24
^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}16@0:8
{?=}16@0:8
v32@0:8{?=}16
16@0:8
v32@0:816
v32@0:8Q16@24
c40@0:8^{C3DPlane=(?={?=ffff})}1624
v24@0:8^{__C3DParticleSystem=}16
{SCNVector3=ddd}48@0:8{SCNVector3=ddd}16@40
{CATransform3D=dddddddddddddddd}152@0:8{CATransform3D=dddddddddddddddd}16@144
^{__C3DNode={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DNode}^{__C3DNode}^{__C3DNode}i{?=(C3DMatrix4x4=[16f][4]{?=[4]})(?=)}^(C3DMatrix4x4)BfQib1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b3{?={?=SS}I}^{?}^{__C3DGeometry}^{__C3DSkinner}f{?=}}
{?="columns"[4]}
(?="eulerAngles""axisAngle""quaternion"{?="vector"})
@"SCNNodeComponent"
^{SCNVector3=ddd}
v88@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40{SCNVector3=ddd}64
v72@0:8{SCNVector4=dddd}16{SCNVector3=ddd}48
c32@0:8^16^f24
v80@0:8{?=[4]}16
40@0:816@32
{?=[4]}88@0:8{?=[4]}16@80
v64@0:8163248
v48@0:8{?=}1632
@40@0:8@16@24^@32
@24@0:8^{__C3DScene=}16
v28@0:8@16i24
@20@0:8c16
c48@0:8@16@24@32@?40
v152@0:8@16{CATransform3D=dddddddddddddddd}24
^{__C3DScene=}
@"SCNSceneSource"
[4@"SCNNode"]
@"SCNAuthoringEnvironment"
v24@0:816
^{__C3DRendererContext={__CFRuntimeBase=QAQ}iIIIIfI^{__C3DTexture}^{__C3DStack}^vBBBBBB^{__CFDictionary}I^{__CFDictionary}^{__CFDictionary}^{__CFDictionary}{C3DColor4=(?=[4f]{?=ffff})}^vq^{__C3DFXProgramObject}{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}{Cache=[16I]Ii^{__C3DBlendStates}I^{__C3DRasterizerStates}^{__C3DMesh}^{__C3DMeshElement}IIiI^viii}{?=[5I][5i][12{?=iII}][12I]^?^?^?^?^?^?^?^?^?^?}[2{VolatileObject=^{__C3DArray}II^{__CFArray}}]^{__C3DArray}I^{__CFDictionary}}24@0:8^{__C3DEngineContext=}16
^{__C3DTexture=}40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
v40@0:8^{__C3DEngineContext=}16^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}24^d32
v40@0:8^{__C3DEngineContext=}16{CGSize=dd}24
^{__C3DTexture=}52@0:8{CGSize=dd}16^{__C3DEngineContext=}32^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}40c48
v24@0:8^{__C3DEngineContext=}16
^{__C3DFramebuffer=}
@40@0:8^{__C3DEngineContext=}16@24@32
v32@0:8@16^{__C3DEngineContext=}24
v24@0:8^{?=^{__C3DFXPass}^{__C3DFXTechnique}^v^{__C3DEngineContext}^{__C3DFXProgramObject}d^v^{__C3DRendererElement}q}16
v40@0:8@16@24^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]})dd}ffffiib1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})fffffffffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}}32
@"SCNRenderTarget"
{?="projScale"f"radius"f"radius2"f"bias"f"intensity"f"depthThreshold"f"normalThreshold"f"zMax"f"projectionInfo""scale"i}
@36@0:8Q16Q24c32
@56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48
v32@0:8d16^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}24
d24@0:8d16
v32@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16d24
@"NSOpenGLPixelFormat"
@"CALayer"
@"NSRecursiveLock"
@"<SCNEventHandler>"
@"SCNSpriteKitEventHandler"
@"SCNPhysicsVehicle"
^{SCNCActionScale=^^?f@?@BdddddBB@?^{__CFString}qddddfffffcc}
@48@0:8d16d24d32d40
@48@0:8{SCNVector3=ddd}16d40
@56@0:8d16{SCNVector3=ddd}24d48
@56@0:8{SCNVector4=dddd}16d48
@52@0:8d16d24d32d40c48
^{SCNCAction=^^?f@?@BdddddBB@?^{__CFString}qdddd}16@0:8
^{SCNCAction=^^?f@?@BdddddBB@?^{__CFString}qdddd}
@32@0:8q16@24
^{__C3DFXPass=}16@0:8
@60@0:8i16@20{CGSize=dd}28@44@52
@"SKTransition"
^{__C3DFXPass=}
[2@"SCNOffscreenRenderer"]
@32@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16@24
@56@0:8@16c24@28c36^v40Q48
32@0:816
v48@0:8^{SCNVector3=ddd}16Q24{CGSize=dd}32
{SCNVector3=ddd}56@0:8{SCNVector3=ddd}16{CGSize=dd}40
v24@0:8^{__C3DScene=}16
@56@0:8{CGPoint=dd}16{CGSize=dd}32@48
c48@0:8@16@24{CGSize=dd}32
@40@0:8@16{CGSize=dd}24
v32@0:8^{__C3DEngineContext=}16d24
c24@0:8^{__C3DScene=}16
v64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48@56
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64
v88@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72@80
v80@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@56@64@72
^{CGImage=}24@0:8d16
@48@0:8d16{CGSize=dd}24Q40
@32@0:8{CGSize=dd}16
^{CGImage=}32@0:8{CGSize=dd}16
@40@0:8{CGSize=dd}16@32
v40@0:8Q16c24c28@32
@"NSLock"
{?="frameBuffer"^{__C3DFramebuffer}"multisamplingFrameBuffer"^{__C3DFramebuffer}"drawableSize"{CGSize="width"d"height"d}}
@"SCNRendererTransitionContext"
@"<SCNRenderContext>"
{C3DColor4=""(?="rgba"[4f]""{?="r"f"g"f"b"f"a"f})}
@"__SKSCNRenderer"
@40@0:8^{_CGLContextObject=^{__GLIContextRec}{__GLIFunctionDispatchRec=^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?^?}^{_CGLPrivateObject}^v}16{CGSize=dd}24
@"MTLArgument"
^{?=@?II}
^{?=^{__C3DFXPassInput}II}
^{__C3DFXPassInput=}
v34@0:8@16Q24{?=cc}32
@18@0:8{?=cc}16
[31@]
[16@]
[2I]
@"MTLVertexDescriptor"
@"MTLStageInputOutputDescriptor"
v32@0:8{?=qq}16
@"SCNMTLBuffer"
@128@0:8@16{SCNVector3=ddd}24{SCNVector3=ddd}48@72{SCNVector3=ddd}80{SCNVector3=ddd}104
@72@0:8@16{SCNVector3=ddd}24{SCNVector3=ddd}48
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""axisA"{SCNVector3="x"d"y"d"z"d}"anchorA"{SCNVector3="x"d"y"d"z"d}"axisB"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}"minLinearLimit"d"maxLinearLimit"d"minAngularLimit"d"maxAngularLimit"d"motorTargetLinearVelocity"d"motorMaximumForce"d"motorTargetAngularVelocity"d"motorMaximumTorque"d}
^{btSliderConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}BB{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}BffffffffffffffffffffffffffffBBi[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3f][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]f{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffBfffBfff}
^{SCNCActionMove=^^?f@?@BdddddBB@?^{__CFString}qdddddcc}
v32@0:8^?16^v24
^{__C3DKeyframedAnimation=}16@0:8
v24@0:8^{__C3DKeyframedAnimation=}16
^{__C3DKeyframedAnimation=}
c36@0:8d16c24^v28
@24@0:8^{__C3DTimingFunction=}16
^{__C3DTimingFunction=}16@0:8
^{__C3DTimingFunction=}
@24@0:8^{__C3DAnimation=}16
v24@0:8^{__C3DAnimation=}16
^{__C3DAnimation=}16@0:8
^{__C3DAnimation=}
@"SCNTimingFunction"
@24@0:8^{__C3DAnimationPlayer=}16
^{__C3DAnimationPlayer=}16@0:8
^{__C3DAnimationPlayer=}
@"SCNAnimation"
#40@0:8@16@24@32
#40@0:8@"NSKeyedUnarchiver"16@"NSString"24@"NSArray"32
@32@0:8@"NSKeyedUnarchiver"16@24
v40@0:8@"NSKeyedUnarchiver"16@24@32
v24@0:8@"NSKeyedUnarchiver"16
@32@0:8Q16@24
@40@0:8Q16@24^@32
^{__C3DScene=}32@0:8@16@?24
@40@0:8#16@24@?32
@32@0:8@16@?24
@40@0:8#16@24^@32
@32@0:8@16^@24
^{__C3DSceneSource=}16@0:8
^{__C3DLibrary=}16@0:8
@24@0:8#16
c48@0:8@16Q24@?32@?40
^{__C3DSceneSource=}
@"SCNAssetCatalog"
@24@0:8^{__CFArray=}16
@24@0:8^{__C3DHitTestResult=}16
{CGPoint=dd}24@0:8q16
^{__C3DHitTestResult=}
v20@0:8I16
Q24@0:8Q16
@"<MTLHeap>"16@0:8
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
^{__IOSurface=}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"<MTLResource>"16@0:8
@"<MTLTexture>"16@0:8
@"<MTLBuffer>"16@0:8
^{__C3DImage=}32@0:8@16Q24
^{__C3DImage=}28@0:8@16i24
^{__C3DImage=}24@0:8@16
@24@0:8^{__C3DImage=}16
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}20@0:8c16
v24@0:8^{__C3DImage=}16
{C3DColor4=(?=[4f]{?=ffff})}16@0:8
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}16@0:8
^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}16@0:8
v80@0:8(C3DMatrix4x4=[16f][4]{?=[4]})16
^{__C3DEffectSlot={__CFRuntimeBase=QAQ}{C3DColor4=(?=[4f]{?=ffff})}^v(?=^{__C3DImage}^v^{__C3DImageProxy}^{__C3DTexture})b8b1b1b1b4c^{__C3DTextureSampler}^(C3DMatrix4x4)fi^v}
^{__C3DImage=}
^{CATransform3D=dddddddddddddddd}
@40@0:8d16d24@32
@56@0:8d16d24d32d40@48
@48@0:8d16d24d32@40
@24@0:8^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16
^{__C3DFloor={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}ffffifffQ}16@0:8
^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16@0:8
^{btRaycastVehicle=^^?{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}iiff^{btVehicleRaycaster}fff^{btRigidBody}iii{btAlignedObjectArray<btWheelInfo>={btAlignedAllocator<btWheelInfo, 16>=}ii^{btWheelInfo}B}}16@0:8
v32@0:8d16q24
@"SCNPhysicsBody"
^{btRaycastVehicle=^^?{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<btVector3>={btAlignedAllocator<btVector3, 16>=}ii^{btVector3}B}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}{btAlignedObjectArray<float>={btAlignedAllocator<float, 16>=}ii^fB}iiff^{btVehicleRaycaster}fff^{btRigidBody}iii{btAlignedObjectArray<btWheelInfo>={btAlignedAllocator<btWheelInfo, 16>=}ii^{btWheelInfo}B}}
@24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
v24@0:8^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}16
c48@0:8@16@24^@32^@40
{?=cCCC}16@0:8
v20@0:8{?=cCCC}16
{?="enableVertexWeldingAtImport"c"boundaryInterpolationRule"C"faceVaryingInterpolationRule"C"normalSmoothingMode"C}
@"SCNGeometrySource"
@"SCNGeometryElement"
@"SCNGeometryTessellator"
@"SKScene"
v28@0:8f16f20f24
v48@0:8{CGPoint=dd}16{CGSize=dd}32
v24@0:8f16f20
v52@0:8f16{CGPoint=dd}20{CGSize=dd}36
{?=}24@0:8o^f16
{?=[4]}48@0:81632
v56@0:8{CGPoint=dd}16{CGSize=dd}32d48
v64@0:8{CGPoint=dd}16{CGSize=dd}32{CGPoint=dd}48
48@0:8{CGPoint=dd}16{CGSize=dd}32
{?=}32@0:8{?=}16
c48@0:8{CGPoint=dd}16{CGSize=dd}32
v32@0:8{CGPoint=dd}16
{?="angles""initialAbsoluteAngles""initialTransformWorld"{?="columns"[4]}"initialOrientationWorld"{?="vector"}}
{?="start""current""last"}
{?="localArcballAdjustement""sphereLocationStart""sphereLocationCurrent"}
{?="inertiaEnabled"B"inertiaRunning"B"lastSimulationTime"d"friction"f"rotationSensitivity"f"translationSensitivity"f"velocity""timer"@"NSTimer"}
@"<SCNCameraControllerDelegate>"
44@0:816f24{CGSize=dd}28
v44@0:8@16@24@32f40
v32@0:8q16@24
@"NSURL"16@0:8
@"NSOperationQueue"16@0:8
v24@0:8@?<v@?@?<v@?>>16
v24@0:8@?<v@?@"NSError">16
v24@0:8@"NSURL"16
v24@0:8@"NSSet"16
v24@0:8@"NSFileVersion"16
v32@0:8@"NSURL"16@?<v@?@"NSError">24
v32@0:8@"NSURL"16@"NSURL"24
v32@0:8@"NSURL"16@"NSFileVersion"24
@"NSSet"16@0:8
^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}20@0:8c16
^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}16@0:8
v156@0:8@16@24^{__C3DFXProgramDelegate={__CFRuntimeBase=QAQ}{?=^?^?^?^?}^v}32{?=^{__C3DFXProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}Cc@{?=C@?}}40c136@140@?148
@"<MTLLibrary>"
@"NSOperationQueue"
^{__CFString=}
@"NSMapTable"
@56@0:8{?=CCCb1b1b1b1b1[4C]}1624q32@40q48
^{SCNCActionHide=^^?f@?@BdddddBB@?^{__CFString}qddddc}
v56@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@48
f20@0:8f16
{CGPoint="x"d"y"d}
@24@0:8^{__C3DSkinner=}16
^{__C3DSkinner=}48@0:8@16@24@32@40
^{__C3DSkinner=}56@0:8q16@24@32@40@48
^{__C3DSkinner=}40@0:8@16Q24Q32
@176@0:8@16@24@32@40{CATransform3D=dddddddddddddddd}48
^{__C3DSkinner=}16@0:8
^{__C3DSkinner=}
@40@0:8@16Q24^@32
@48@0:8@16@24@32Q40
c48@0:8@16@24Q32^@40
c40@0:8@16Q24^@32
{__zFlags="providerSuppliesContents"b1"providerSuppliesStreams"b1"providerSuppliesProperties"b1"noContentsCaching"b1"fileOpen"b1"reserved"b27}
[5^v]
@"SCNMetalRenderPipeline"
v24@0:8^{__C3DBlendStates=}16
v60@0:8@16@24^{__C3DFXMetalProgram={__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}[2^{__CFString}]^{__CFString}^{__CFDictionary}^v^{__CFDictionary}^v^{__CFString}}32c40@?44@?52
v148@0:8@16@24@32{?=^{__C3DFXProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}Cc@{?=C@?}}40B136@140
@112@0:8{?=^{__C3DFXProgram}^{__C3DMaterial}^{__C3DGeometry}^{__C3DFXPass}^{__C3DFXPass}@^{__C3DBlendStates}^{__C3DNode}Cc@{?=C@?}}16
v32@0:8^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}16^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}24
v24@0:8^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}16
@"SCNMetalLibraryManager"
^{__C3DEngineStats=IIIIIIIIIIIIIIIIIIIIIIIIddddddddddddddIIIIIIIIIIIIIIIIddd[60d]Idd}
@"MTLRenderPipelineDescriptor"
@"SCNMTLShaderBindingsGenerator"
v32@0:8{_NSRange=QQ}16
@40@0:8@16Q24Q32
v40@0:8@16{_NSRange=QQ}24
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@24@0:8^{__C3DRasterizerStates=}16
@24@0:8^{__C3DMesh=}16
@32@0:8^{__C3DMorph=}16^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}24
@32@0:8^{__C3DSkinner=}16^{__C3DMesh=}24
@24@0:8^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}16
@48@0:8^{__C3DMaterial=}16^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}24@32^{__C3DEngineContext=}40
@32@0:8^{__C3DRendererElement=^{__C3DNode}^{__C3DGeometry}^{__C3DMesh}^v^{__C3DMaterial}^{__C3DFXTechnique}^{__C3DRendererElementProgramHashCode}{?=[8C]}iIb8b1b1b1b1b1b1b1b3b1b3}16^{__C3DEngineContext=}24
@24@0:8^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16
@24@0:8^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}fff^v^{__C3DMeshSource}[2]^{?}I}16
@32@0:8^{__CFData=}16Q24
v32@0:8^{__C3DMesh=}16@24
@32@0:8Q16Q24
@40@0:8r^v16Q24Q32
@48@0:8Q16@24@32@40
@64@0:8Q16@24@32@40@48@56
@52@0:8@16c24@28@36@44
@"SCNMTLBufferAllocator"
{?="registry"@"NSMapTable""lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}}
@"SCNMTLShadableKey"
@"MTKTextureLoader"
v24@0:8^{__C3DNode=}16
^{__C3DNode=}16@0:8
@"AVAudioNode"
@"AVAudioPlayerNode"
@"SCNAudioSource"
^{__C3DNode=}
@32@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24
v96@0:8@16@24{SCNVector3=ddd}32{SCNVector3=ddd}56d80d88
v40@0:8r^{btPersistentManifold=i[4{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}]^{btCollisionObject}^{btCollisionObject}iffiii^{c3dContactCallback}}16q24r^{btManifoldPoint={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffffiiii^vBfffffffi{btVector3=(?=[4f])}{btVector3=(?=[4f])}}32
^{btRigidBody=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffBfffffff^{btMotionState}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}ii{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ii}16@0:8
^{btCollisionShape=^^?i^v}32@0:8@16@24
v44@0:8{SCNVector3=ddd}16c40
v68@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40c64
v52@0:8{SCNVector4=dddd}16c48
@"SCNPhysicsShape"
^{btRigidBody=^^?{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}if^{btBroadphaseProxy}^{btCollisionShape}^v^{btCollisionShape}iiiiffffi^vfffi{btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ffBfffffff^{btMotionState}{btAlignedObjectArray<btTypedConstraint *>={btAlignedAllocator<btTypedConstraint *, 16>=}ii^^{btTypedConstraint}B}ii{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}ii}
@24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
v24@0:8^{__C3DParametricGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=ffffffffffffiiiiiiiiiiiI}{?=^?^?^?^?^?^?}^{__CFData}}16
@40@0:8d16d24d32
v64@0:8@16@24^{__C3DEngineContext=}3240d56
d40@0:8@16^{__C3DEngineContext=}24^{__C3DTextureSampler={__CFRuntimeBase=QAQ}iiiiii{C3DColor4=(?=[4f]{?=ffff})}fCiQ}32
@36@0:8I16@20@?28
c36@0:8c16d20d28
v24@0:8^{_CGLContextObject=}16
^{__CVDisplayLink=}
^{_CGLContextObject=}
^{SCNCActionRotate=^^?f@?@BdddddBB@?^{__CFString}qddddfccccc}
@40@0:8@16Q24@32
@24@0:8i16i20
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
@48@0:8^v16Q24Q32@?40
@40@0:8@16^{__IOSurface=}24Q32
@48@0:8@16Q24^@32^@40
v40@0:8@16Q24@?32
v32@0:8^{?=ff}16Q24
{?=QQQ}16@0:8
@"<MTLCommandQueue>"24@0:8Q16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
v32@0:8{C3DColor4=(?=[4f]{?=ffff})}16
v32@0:8^{__C3DRendererElement=}16^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}24
^{__C3DMeshElement=}36@0:8c16q20q28
v24@0:8^{__C3DMeshElement=}16
v148@0:8^{__C3DMesh=}16^{__C3DMeshElement=}24^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}32^{__C3DEngineContext=}40(C3DMatrix4x4=[16f][4]{?=[4]})48r^{C3DColor4=(?=[4f]{?=ffff})}112^{__C3DRasterizerStates=}120^{__C3DBlendStates=}128^{__C3DImage=}136c144
v32@0:8^{__C3DImageProxy=}16^{__C3DEngineContext=}24
v36@0:8^{__C3DNode=}16i24^{__C3DLightRuntimeData=If[4{?=[4]}]^v^{__C3DTextureSampler}^v^{__C3DTextureSampler}}28
@"SCNRenderTargetRegistry"16@0:8
@"<SCNResourceManager>"16@0:8
v32@0:8^{__C3DRendererElement=}16^{?=^{__C3DEnginePipeline}^{__C3DEngineContext}^{__C3DFXPassInstance}^i^{__C3DNode}BB}24
@"SCNRenderTargetRegistry"
@32@0:8^v16@24
^{btCollisionShape=^^?i^v}16@0:8
^{btCollisionShape=^^?i^v}
I40@0:8^{?=[16]}1624f32B36
v32@0:8^{?=fffffffffffffffffffIIfiff}16^{__C3DCamera={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}{?=b1b1b1b1b1b1b1dddfd(C3DMatrix4x4=[16f][4]{?=[4]})dd}ffffiib1b1b1b1C(C3DMatrix4x4=[16f][4]{?=[4]})fffffffffffffffffffff{?=fffffii}^{__C3DEffectSlot}Q^{__C3DFXTechnique}}24
[5@"<MTLComputePipelineState>"]
[3@"<MTLComputePipelineState>"]
[15@"<MTLRenderPipelineState>"]
[6@"<MTLComputePipelineState>"]
@"MPSImageHistogram"
@"NSArrayController"
@"NSObject"
@"NSTableView"
@"SCNUIVector4TextField"
{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}24@0:8@16
v64@0:8r^^{__C3DMeshSource}16^s24I32^v36I44Q48c56f60
v40@0:8q16^{__C3DMorph=}24^{__C3DMesh=}32
@40@0:8^{__C3DMorph=}16^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}24@32
c24@0:8^{__C3DMorph=}16
v48@0:8@16^{__C3DMorph=}24@32@40
v48@0:8@16^{__C3DMorpher={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DGeometry}^{__C3DMorph}^{__C3DMesh}II^fII}24@32@40
[3s]
{?="perVertexTrianglesOffsets"@"<MTLBuffer>""perVertexTrianglesIndices"@"<MTLBuffer>""sharedTriangleIs16Bits"c}
^{Target=@If[3^{__C3DMeshSource}]@I}
@40@0:8^{__C3DSkinner=}16^{__C3DMesh=}24@32
v48@0:8@16@24^{__C3DSkinner=}32@40
@80@0:8@16{SCNVector3=ddd}24@48{SCNVector3=ddd}56
@48@0:8@16{SCNVector3=ddd}24
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}}
^{btPoint2PointConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btVector3=(?=[4f])}{btVector3=(?=[4f])}iffB{btConstraintSetting=fff}}
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}16@0:8
^{c3dPhysicsField=^^?{?=[4]}{?=[4]}fffIBBBBf}
@24@0:8^{__C3DFXTechnique=}16
^{__C3DFXTechnique=}16@0:8
^{__C3DFXTechnique=}
@24@0:8^{__C3DMorph=}16
#24@0:8@16
^{__C3DMorph=}16@0:8
d24@0:8@16
v32@0:8d16Q24
d24@0:8Q16
^{__C3DMorph=}
@"SCNFixedSizePage"
@"NSMutableIndexSet"
@48@0:8@16Q24Q32@40
@40@0:8r^v16Q24@32
{CGRect={CGPoint=dd}{CGSize=dd}}16@0:8
@"CALayer"16@0:8
@24@0:8@"NSString"16
@56@0:8{SCNVector4=dddd}16@48
@48@0:8{SCNVector3=ddd}16@40
@152@0:8{CATransform3D=dddddddddddddddd}16@144
v32@0:8@"CAAnimation"16@"NSString"24
v32@0:8@16@"NSString"24
@"CAMediaTimingFunction"16@0:8
v24@0:8@"CAMediaTimingFunction"16
@"NSColor"48@0:8d16d24d32d40
v24@0:8@"NSArray"16
^{CGPath=}16@0:8
v24@0:8^{CGPath=}16
@"<SCNCameraControlConfiguration>"16@0:8
@"SCNCameraController"16@0:8
@"CAAnimation"16@0:8
v24@0:8@"CAAnimation"16
@24@0:8@"CAAnimation"16
@"SCNPhysicsBody"16@0:8
@128@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24{SCNVector3=ddd}48@"SCNPhysicsBody"72{SCNVector3=ddd}80{SCNVector3=ddd}104
@72@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24{SCNVector3=ddd}48
v40@0:8@"NSString"16q24@?<v@?@"<SCNBufferStream>"@"SCNNode"@"<SCNShadable>"@"SCNRenderer">32
v40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@"NSString"24@0:8@"NSString"16
@"<SCNProgramDelegate>"16@0:8
v24@0:8@"<SCNProgramDelegate>"16
v24@0:8@"<MTLLibrary>"16
d24@0:8q16
@"SCNMorpher"16@0:8
@"SCNGeometry"16@0:8
@32@0:8@"SCNGeometry"16d24
v72@0:8d16{CGRect={CGPoint=dd}{CGSize=dd}}24@"<MTLCommandBuffer>"56@"MTLRenderPassDescriptor"64
v64@0:8{CGRect={CGPoint=dd}{CGSize=dd}}16@"<MTLCommandBuffer>"48@"MTLRenderPassDescriptor"56
v32@0:8@"NSArray"16d24
@32@0:8^v16@"NSDictionary"24
@32@0:8@"<MTLDevice>"16@"NSDictionary"24
v24@0:8@"SCNAudioPlayer"16
v32@0:8@"SCNNode"16Q24
v32@0:8@"SCNNode"16@"SCNNode"24
@"SCNNode"28@0:8@"NSString"16c24
@"NSArray"24@0:8@?<c@?@"SCNNode"^c>16
v24@0:8@?<v@?@"SCNNode"^c>16
{SCNVector3=ddd}48@0:8{SCNVector3=ddd}16@"SCNNode"40
{CATransform3D=dddddddddddddddd}152@0:8{CATransform3D=dddddddddddddddd}16@"SCNNode"144
@"NSArray"72@0:8{SCNVector3=ddd}16{SCNVector3=ddd}40@"NSDictionary"64
v24@0:8@"SCNParticleSystem"16
@"SCNNode"24@0:8@"NSString"16
@"SCNLight"16@0:8
v24@0:8@"SCNLight"16
@"SCNCamera"16@0:8
v24@0:8@"SCNCamera"16
v24@0:8@"SCNGeometry"16
@"SCNSkinner"16@0:8
v24@0:8@"SCNSkinner"16
v24@0:8@"SCNMorpher"16
v24@0:8@"SCNPhysicsBody"16
@"SCNPhysicsField"16@0:8
v24@0:8@"SCNPhysicsField"16
@"<SCNNodeRendererDelegate>"16@0:8
v24@0:8@"<SCNNodeRendererDelegate>"16
@"SCNNode"24@0:8@"SCNGeometry"16
@24@0:8@"MDLObject"16
@80@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24@"SCNPhysicsBody"48{SCNVector3=ddd}56
@48@0:8@"SCNPhysicsBody"16{SCNVector3=ddd}24
v32@0:8@"SCNMaterial"16Q24
v32@0:8Q16@"SCNMaterial"24
@"SCNMaterial"24@0:8@"NSString"16
@"NSArray"24@0:8@"NSString"16
@"SCNGeometryElement"24@0:8q16
@"SCNMaterial"16@0:8
v24@0:8@"SCNMaterial"16
@"SCNGeometryTessellator"16@0:8
v24@0:8@"SCNGeometryTessellator"16
@"SCNGeometryElement"16@0:8
v24@0:8@"SCNGeometryElement"16
@"SCNGeometrySource"16@0:8
v24@0:8@"SCNGeometrySource"16
@32@0:8@"NSArray"16@"NSArray"24
@40@0:8@"NSArray"16@"NSArray"24@"NSArray"32
@24@0:8@"MDLMesh"16
@"SCNMaterialProperty"16@0:8
@24@0:8@"MDLLight"16
@24@0:8@"MDLMaterial"16
v40@0:8q16@"NSArray"24@?<v@?^^v^Q^Iq>32
v40@0:8@"NSArray"16q24@?<v@?^^v^Qqqf>32
@"SCNParticleSystem"16@0:8
@32@0:8@"NSString"16@"NSString"24
@32@0:8@"SCNPhysicsBody"16@"NSArray"24
@24@0:8@"SCNNode"16
@32@0:8@"SCNGeometry"16@"NSDictionary"24
@32@0:8@"SCNNode"16@"NSDictionary"24
{_NSRange=QQ}16@0:8
@60@0:8@16q24q32q40c48q52
@48@0:8@16q24q32q40
@60@0:8@"NSData"16q24q32q40c48q52
@48@0:8@"NSData"16q24q32q40
@24@0:8@"MDLSubmesh"16
@76@0:8@16@24q32c40q44q52q60q68
@32@0:8r^{SCNVector3=ddd}16q24
@32@0:8r^{CGPoint=dd}16q24
@76@0:8@"NSData"16@"NSString"24q32c40q44q52q60q68
@"SCNScene"32@0:8@"NSDictionary"16@?<v@?fq@"NSError"^c>24
@"SCNScene"32@0:8@"NSDictionary"16^@24
@32@0:8@"NSString"16#24
@"NSArray"24@0:8#16
@"NSArray"24@0:8@?<c@?@@"NSString"^c>16
@32@0:8@"NSURL"16@"NSDictionary"24
@32@0:8@"NSData"16@"NSDictionary"24
@24@0:8@"MDLCamera"16
v32@0:8d16@"SCNNode"24
d24@0:8@"SCNNode"16
v32@0:8@16@"<NSCopying>"24
@"SCNTechnique"24@0:8@"NSDictionary"16
@"SCNTechnique"24@0:8@"NSArray"16
v24@0:8@"SCNPhysicsBehavior"16
@"NSArray"40@0:8@"SCNPhysicsBody"16@"SCNPhysicsBody"24@"NSDictionary"32
@"NSArray"32@0:8@"SCNPhysicsBody"16@"NSDictionary"24
@"NSArray"288@0:8@"SCNPhysicsShape"16{CATransform3D=dddddddddddddddd}24{CATransform3D=dddddddddddddddd}152@"NSDictionary"280
@"<SCNPhysicsContactDelegate>"16@0:8
v24@0:8@"<SCNPhysicsContactDelegate>"16
@"SCNPhysicsShape"16@0:8
v24@0:8@"SCNPhysicsShape"16
@32@0:8q16@"SCNPhysicsShape"24
@28@0:8c16@?20
@28@0:8c16@?<{CATransform3D=dddddddddddddddd}@?@"SCNNode"{CATransform3D=dddddddddddddddd}>20
@28@0:8c16@?<{SCNVector3=ddd}@?@"SCNNode"{SCNVector3=ddd}>20
@28@0:8c16@?<{SCNVector4=dddd}@?@"SCNNode"{SCNVector4=dddd}>20
@32@0:8d16@?<v@?@"<SCNAnimation>"@c>24
@"SCNAction"16@0:8
@?<f@?f>16@0:8
v24@0:8@?<f@?f>16
@"SCNAction"48@0:8d16d24d32d40
@"SCNAction"48@0:8{SCNVector3=ddd}16d40
@"SCNAction"52@0:8d16d24d32d40c48
@"SCNAction"56@0:8d16{SCNVector3=ddd}24d48
@"SCNAction"56@0:8{SCNVector4=dddd}16d48
@"SCNAction"32@0:8d16d24
@"SCNAction"24@0:8@"NSArray"16
@"SCNAction"32@0:8@"SCNAction"16Q24
@"SCNAction"24@0:8@"SCNAction"16
@"SCNAction"24@0:8d16
@"SCNAction"24@0:8@?<v@?@"SCNNode">16
@"SCNAction"32@0:8@?<v@?@"SCNNode">16@"NSObject<OS_dispatch_queue>"24
@"SCNAction"32@0:8@"NSString"16d24
@"SCNAction"32@0:8d16@?<v@?@"SCNNode"d>24
v152@0:8@"SCNParticleSystem"16{CATransform3D=dddddddddddddddd}24
c48@0:8@"NSURL"16@"NSDictionary"24@"<SCNSceneExportDelegate>"32@?<v@?f@"NSError"^c>40
@"SCNPhysicsWorld"16@0:8
@40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@40@0:8@"NSURL"16@"NSDictionary"24^@32
@24@0:8@"MDLAsset"16
@"SCNPhysicsField"32@0:8d16d24
@"SCNPhysicsField"24@0:8@?<{SCNVector3=ddd}@?{SCNVector3=ddd}{SCNVector3=ddd}ffd>16
d76@0:8@16@24^{__C3DEngineContext=}3240d56c64^c68
v40@0:8^{__C3DScene=}16@24@?32
v48@0:8^{__C3DScene=}16@24@32@?40
@32@0:8r^d16q24
@40@0:8r^{SCNVector3=ddd}16q24^q32
@40@0:8r^{CGPoint=dd}16q24^q32
@68@0:8@16@24q32s40Q44q52q60
@44@0:8r^f16q24c32^{CGColorSpace=}36
@64@0:8@16Q24@32q40q48q56
s16@0:8
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}16@0:8
^{__C3DMeshSource={__C3DGenericSource={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DSourceAccessor}(?=^{__CFData}^v^v)qb1b1b1}SCC}
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}fff^v^{__C3DMeshSource}[2]^{?}I}16@0:8
^{__C3DMeshElement={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}II^{__C3DMeshElement}CCC{?=c^{__CFData}I^I{?=qq}CB}fff^v^{__C3DMeshSource}[2]^{?}I}
{_NSRange="location"Q"length"Q}
@24@0:8^{__IOHIDDevice=}16
v28@0:8I16@20
^{__IOHIDDevice=}
^{__IOHIDManager=}
24@0:8@16
{CATransform3D=dddddddddddddddd}144@0:8{CATransform3D=dddddddddddddddd}16
v24@0:8f16c20
v40@0:816q32
c32@0:8^{__C3DNode=}16^{C3DSphere=}24
{C3DSphere=}16@0:8
v48@0:8{CGPoint=dd}16q32Q40
(C3DMatrix4x4="components"[16f]"m"[4]"simd"{?="columns"[4]})
{C3DSphere="vector"}
c24@0:8@"NSEvent"16
@"SCNView"16@0:8
v24@0:8@"SCNView"16
v24@0:8@"SCNCameraController"16
(?={?=ffff})16@0:8
B16@0:8
(?="vector""center"""{?="x"f"y"f"z"f"radius"f})
{?="stickyMoveEnabled"B"direction""pickedAxis"Q"userStickyAxis"Q}
{?="automaticLocationUpToDate"B"hasAutomatic"B}
{?="lastDragLocation"{CGPoint="x"d"y"d}"velocity"{CGPoint="x"d"y"d}"lastDragTime"d}
{?="lock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"keyCodeConfiguration"@"NSDictionary""keyDown"{set<unsigned short, std::__1::less<unsigned short>, std::__1::allocator<unsigned short> >="__tree_"{__tree<unsigned short, std::__1::less<unsigned short>, std::__1::allocator<unsigned short> >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *>}"__pair1_"{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned short, void *> > >="__value_"{__tree_end_node<std::__1::__tree_node_base<void *> *>="__left_"^{__tree_node_base<void *>}}}"__pair3_"{__compressed_pair<unsigned long, std::__1::less<unsigned short> >="__value_"Q}}}"forward"{vector<unsigned short, std::__1::allocator<unsigned short> >="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >="__value_"^S}}"backward"{vector<unsigned short, std::__1::allocator<unsigned short> >="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >="__value_"^S}}"left"{vector<unsigned short, std::__1::allocator<unsigned short> >="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >="__value_"^S}}"right"{vector<unsigned short, std::__1::allocator<unsigned short> >="__begin_"^S"__end_"^S"__end_cap_"{__compressed_pair<unsigned short *, std::__1::allocator<unsigned short> >="__value_"^S}}}
{?="hasShift"B"hasOption"B}
@"SCNCameraController"
@"<SCNCameraNavigationControllerDelegate>"
c32@0:8@16#24
c40@0:8@16^d24^d32
@32@0:8@?16i24c28
v36@0:8@16i24@?28
v40@0:8@16i24c28@?32
v40@0:8@?16@?24@?32
q40@0:8@16@24Q32
v64@0:8@16@24^{__C3DFXProgram={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}ib1b1^{__C3DFXProgramDelegate}}32^{__C3DMaterial=}40^{__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}48^{__C3DFXPass={__CFRuntimeBase=QAQ}^{__CFString}iiB^{__C3DFXTechnique}^{__CFString}^{__CFString}^{__CFString}^{__CFString}B^{__C3DFXProgram}^{__C3DMaterial}^{__C3DBlendStates}^{__C3DRasterizerStates}{C3DColor4=(?=[4f]{?=ffff})}CIb1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1^{__C3DRendererElement}QQ{?=^?^?^?^?^?^?^?^?^v}{?=[4{?=CCCb1b1b1b1b1[4C]}]{?=CCCb1b1b1b1b1[4C]}b3b1b1}{CGPoint=dd}^{?}I^{__C3DNode}^{__C3DNode}^{__CFArray}^{__C3DNode}^{__CFString}^{__CFString}^{__CFString}^^{__C3DFXPassInput}qq^{__CFDictionary}^{__CFDictionary}}56
{?="stage"i"arguments"@"NSArray""customBlocks"@"NSDictionary""pass"^{__C3DFXPass}}
c64@0:8@16{CGSize=dd}24Q40@48^@56
@72@0:8@16{CGSize=dd}24@40@48:56^v64
@56@0:8@16@24@32:40^v48
@"NSError"
@56@0:8@16{CGSize=dd}24@40@48
v56@0:8^{CGImage=}16{?=qiIq}24@48
v72@0:8{?=qiIq}16@40^{__CVMetalTextureCache=}48@56@?64
@"AVAssetWriterInput"
@"AVAssetWriterInputPixelBufferAdaptor"
@"AVAssetWriter"
v112@0:8{?=@{CGPoint=dd}{CGPoint=dd}{SCNVector3=ddd}{SCNVector3=ddd}d}16
c112@0:8{?=@{CGPoint=dd}{CGPoint=dd}{SCNVector3=ddd}{SCNVector3=ddd}d}16
r^{?=f^vf}32@0:8Q16Q24
v52@0:8S162036
116@0:816{SCNVector3=ddd}32d56B646884^B100^q108
@"NSOrderedSet"
(?="axisMove"{?="selectedAxis"S"originalPosition""axisDirection""mouseDeltaVector"}"planeMove"{?="selectedPlane"S"originalPosition""planeNormal""pointInPlane""mouseDeltaVector"}"axisRotate"{?="selectedAxis"S"originalMouseLocation"{CGPoint="x"d"y"d}"rotationSign"f"originalRotation"})
{?="positions"^"orientations"^"originalLocalMatrix"^{CATransform3D}}
^{?=f^vf}
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16@0:8
v24@0:8^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}16
^{__C3DConstraint={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__CFString}fBB{?=^?^?^?^?^?^?}^v}
c48@0:8@16I24I28@32@40
v48@0:8@16I24I28@32@40
^{__C3DFXGLSLProgram=}24@0:8q16
v32@0:8^{__C3DFXGLSLProgram=}16@24
@"SCNProgram"
@64@0:8@16@24@32@40q48Q56
@"<SCNShadable>"
v24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
@24@0:8^{__C3DTextGeometry={__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}{?=^{__CTFrame}^v^viiBBB{CGRect={CGPoint=dd}{CGSize=dd}}}}16
{?={?=cddid^v^v}^v^viiBB{CGRect={CGPoint=dd}{CGSize=dd}}d}16@0:8
@"NSBezierPath"
@"NSFont"
{CGRect="origin"{CGPoint="x"d"y"d}"size"{CGSize="width"d"height"d}}
v24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
@24@0:8^{__C3DShapeGeometry={__C3DGeometry={__C3DEntity={__CFRuntimeBase=QAQ}^v^{__CFString}^{__CFString}^{__CFDictionary}^{__C3DScene}q}^{__C3DMesh}^{__C3DMaterial}^{__CFArray}^{__CFSet}^{__CFArray}^{?}b1^?{?=CB{?=BCCC}^{__C3DMeshElement}^{__C3DMeshSource}^{__C3DMesh}^v^v}{?=CfIC(?={?=ff}{?=f}{?=f}{?=Cb1b1})}C}{?=cfffif^{CGPath}^v^{CGPath}^v}^{__C3DMesh}[16C]}16
{?=cddid^v^v}16@0:8
{?="bodyA"@"SCNPhysicsBody""bodyB"@"SCNPhysicsBody""anchorA"{SCNVector3="x"d"y"d"z"d}"anchorB"{SCNVector3="x"d"y"d"z"d}"axisA"{SCNVector3="x"d"y"d"z"d}"axisB"{SCNVector3="x"d"y"d"z"d}}
^{btHingeConstraint=^^?ii(?=i^v)fBBi^{btRigidBody}^{btRigidBody}ff^{btJointFeedback}[3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}][3{btJacobianEntry={btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}{btVector3=(?=[4f])}f}]{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}{btTransform={btMatrix3x3=[3{btVector3=(?=[4f])}]}{btVector3=(?=[4f])}}ff{btAngularLimit=fffffffB}ffffBBBBBfifff}
v40@0:8@16q24d32
@40@0:8@16q24^{__C3DLOD=}32
^{__C3DLOD=}
v40@0:8@16@24#32
?333?
?G &?C
intensities.
fff?
?fff?fff?
L>fff?
bplist
MbP?
Mb`?
MbP?
>333?
>fff?
HAfff?
?fff?fff?fff?
?ffffff
?333333
p}?q=
_,b?_,b?_,b?
kvz=kvz=kvz=
33s?
Ga==
MAa[
8?Sx
tWxCE
?33s?333?
4@q=
333333
ffffff
333333
00000000000000007777777777777777
$tI,*
@ffffff
KTX 11
333333
?ff&?RGBA
VUU
VUU
i\)7.
blnOq
sy2-
i\)7.
blnOq
sy2-
@(#)PROGRAM:SceneKit  PROJECT:SceneKit-433.6
(knNff
fff?
?333?
?333?
fff@
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
7> }#>
