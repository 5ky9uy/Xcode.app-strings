Failed to convert texture
Failed to load texture
Images are identical
Images differ. RMS:%.2f MSE:%.2f PSNR:%.2f
Examining %s
File Not Found!
basic_string
vector
com.apple.TextureConverter.compress
version
compressor
format
options
^v8@?0
atcFormatUnknown
atcFormatR8Unorm
atcFormatR16F16
atcFormatR32F32
atcFormatRg8Unorm
atcFormatRg16F16
atcFormatRg32F32
atcFormatRgb8Unorm
atcFormatRgb16F16
atcFormatRgb32F32
atcFormatRgba8Unorm
atcFormatRgba16F16
atcFormatRgba32F32
atcFormatBgra8Unorm
atcFormatBc1Unorm
atcFormatBc2Unorm
atcFormatBc3Unorm
atcFormatBc4Snorm
atcFormatBc4Unorm
atcFormatBc5Snorm
atcFormatBc5Unorm
atcFormatBc6Sf16
atcFormatBc6Uf16
atcFormatBc7Unorm
atcFormatAstc4x4Unorm
atcFormatAstc4x4F16
atcFormatAstc5x4Unorm
atcFormatAstc5x4F16
atcFormatAstc5x5Unorm
atcFormatAstc5x5F16
atcFormatAstc6x5Unorm
atcFormatAstc6x5F16
atcFormatAstc6x6Unorm
atcFormatAstc6x6F16
atcFormatAstc8x5Unorm
atcFormatAstc8x5F16
atcFormatAstc8x6Unorm
atcFormatAstc8x6F16
atcFormatAstc8x8Unorm
atcFormatAstc8x8F16
atcFormatAstc10x5Unorm
atcFormatAstc10x5F16
atcFormatAstc10x6Unorm
atcFormatAstc10x6F16
atcFormatAstc10x8Unorm
atcFormatAstc10x8F16
atcFormatAstc10x10Unorm
atcFormatAstc10x10F16
atcFormatAstc12x10Unorm
atcFormatAstc12x10F16
atcFormatAstc12x12Unorm
atcFormatAstc12x12F16
atcFormatEacR11Snorm
atcFormatEacR11Unorm
atcFormatEacRg11Snorm
atcFormatEacRg11Unorm
atcFormatEacRgba8Unorm
atcFormatEtc2Rgb8Unorm
atcFormatEtc2Rgb8A1Unorm
atcFormatPvrtcRgb2BppUnorm
atcFormatPvrtcRgb4BppUnorm
atcFormatPvrtcRgba2BppUnorm
atcFormatPvrtcRgba4BppUnorm
atcFormatBc1Srgb
atcFormatBc2Srgb
atcFormatBc3Srgb
atcFormatBc7Srgb
atcFormatEacRgba8Srgb
atcFormatEtc2Rgb8Srgb
atcFormatEtc2Rgb8A1Srgb
atcFormatPvrtcRgb2BppSrgb
atcFormatPvrtcRgb4BppSrgb
atcFormatPvrtcRgba2BppSrgb
atcFormatPvrtcRgba4BppSrgb
atcFormatAstc4x4Srgb
atcFormatAstc5x4Srgb
atcFormatAstc5x5Srgb
atcFormatAstc6x5Srgb
atcFormatAstc6x6Srgb
atcFormatAstc8x5Srgb
atcFormatAstc8x6Srgb
atcFormatAstc8x8Srgb
atcFormatAstc10x5Srgb
atcFormatAstc10x6Srgb
atcFormatAstc10x8Srgb
atcFormatAstc10x10Srgb
atcFormatAstc12x10Srgb
atcFormatAstc12x12Srgb
Unknown pixel format
KTX2
Error: options == nullptr
Error: invalid options->format - %s
Error: invalid options->format - %i
Error: invalid gammaIn - %f
Error: invalid gammaOut - %f
Error: invalid rgbmRange - %f
Error: invalid compression format - %s
Error: invalid compression format - %i
Error: invalid compressor - %i
Error: invalid quality - %i
Error: invalid alphaMode - %i
Error: invalid alphaMode - %f
Error: invalid channelWeighting - %i
Error: invalid maxMipmaps - %i, maximum is 
Error: invalid mipmapFilter - %i
Error: invalid maxExtent - %i, maximum is 
Error: invalid resizeRoundMode - %i
Error: invalid resizeFilter - %i
Error: invalid wrapMode - %i
Error: invalid pvrtcPunchThroughMode - %i
Error: invalid decompression format - %s
Error: invalid decompression format - %i
Error: invalid decompressor - %i
Error: %s == nullptr
Error: invalid %s width - 0
Error: invalid %s height - 0
Error: invalid %s numMipLevels - %i, should be in range 1-%i 
Error: invalid %s type - %i
Error: invalid %s->format - %u
Error: invalid %s.surface[%i][%i].width - %i, should be %i or 0
Error: invalid %s.surface[%i][%i].height - %i, should be %i or 0
Error: invalid %s.surface[%i][%i].rowBytes - %i, should be >= %i or 0
Error: invalid %s.surface[%i][%i].size - %i, should be >= %i
Error: invalid %s.surface[%i][%i].data - NULL
Error: destTex == nullptr
Error: ATC_Context should set both memoryAllocator & memoryDeallocator, or neither.
sourceTex
Error: invalid sourceTex format - %s
Error: invalid sourceTex format - %i
Error: invalid fileFormat - %i
ATC_Decompress: Unsupported destination format: %s
refTex
compTex
false
TextureConverter %s
Usage: %s%s Arguments...
 [Options]
=value
Options:
--%s
 (default: "
Widths Differ: (%d != %d)
Heights Differ: (%d != %d)
Depths Differ: (%d != %d)
Texture Typed Differ: (%d != %d)
NumFaces Differ: (%d != %d)
NumMipmaps Differ: (%d != %d)
0123456789abcdefxp
0123456789ABCDEFXP
null
_KMGT
_kMGT
Error: 
Warning: 
----------
Progress [%s] %.0f%%
Progress [
] %.0f%%
Auto
PVRTC
Compressor info is not available for the atcCompressorAuto compressor
Compression info is not available for the selected compressor (%i)
Unsupported auto compression format: "
Using Compressor: %s
Compression format is not supported by the selected compressor
Output texture is more recent than the input texture
 but
Output texture
 was compressed with an older version of TextureConverter
 and
 compression options are compatible
%s, skipping.
Compressing mipmap level %d/%d for face %d/%d (width: %d, height: %d, depth: %d)...
Compressing mipmap level %d/%d (width: %d, height: %d, depth: %d)...
 RMS: %.2f, MSE: %.2f, PSNR: %.2f
Processing time: %.2fms (%.2f MPix/s)
RMS: %.2f, MSE: %.2f, PNSR: %.2f
, line 
, NVTT assertion failed "
Unsupported auto decompression format: (%s)
Compression format (%s) is not supported by the selected decompressor
Unsupported decompressed texture type
KTXwriter
Size:   
 mip-levels
Format: 
Compressed with TextureConverter: 
Compression options: 
Image content is uniform, resized image from (w: %d, h: %d, d: %d) to (w: %d, h: %d, d: %d)!
Resized image to (width: %d, height: %d, depth: %d)
fileName != __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/StdStream.h
FILE *nv::fileOpen(const char *, const char *)
alpha_mode
alpha_reference
alpha_to_coverage
alpha_weight
channel_weighting
check_date
check_details
compare
compression_format
compression_quality
crop_uniform_content
decompressor
decompressed
decompression_format
disable_annotation
disable_multithreading
file_format
flip_x
flip_y
flip_z
gamma_out
max_extent
max_mipmaps
mipmap_filter
normal_map
output
progressbar
pvrtc_punch_through
metrics
resize_filter
resize_round_mode
rgbm_encoding
rgbm_range
scale_range
srgb_format
verbose
wrap_mode
Ignore
Premultiply
Decompress
Compare
Examine
Kaiser
Fastest
Highest
Normal
Production
NearestMultipleOfFour
NearestPowerOfTwo
NextMultipleOfFour
NextPowerOfTwo
PreviousMultipleOfFour
PreviousPowerOfTwo
Clamp
Mirror
Repeat
Allowed
Forced
Unused
Linear
Perceptual
Compression format is not supported by the selected decompressor
Use alpha to coverage
Use alpha weight when compressing
Decode KTX ASTC images as HDR
Crop images with uniform content
Disable KTX file annotation
Disable multithreading
Flip image along x-axis
Flip image along y-axis
Flip image along z-axis
Treat image as normal map
Display progress bar
Report error metrics
Use RGBM encoding
Scale image to entire color range
Use sRGB pixel format
Output processing time in milliseconds
Verbose output
Compare the date/time of the source file to the output file (if present) & skip compression if the output file is newer. Can be combined with --
Compare the compression options and TextureConverter version against the output file (if present) & skip compression if not needed. Only supported for KTX files. Can be combined with --
Alpha reference for alpha to coverage
Range for RGBM encoding
Maximum image extent
Maximum number of mipmaps
Alpha mode
ETCPACK/PVRTC channel weighting
Compression format
Compression quality
Compressor library
Decompressor library
Decompression format
Gamma for input image, "
" or float value
Gamma for output texture, "
Filter for mipmap generation
Operation mode
File format
Output file path
Decompressed file path
Comparison file path
PVRTC punch through mode
Resize filter
Resize round mode
Wrap mode
TextureConverter
Usage options:
       TextureConverter --h : Detailed Usage
       TextureConverter -h  : TextureTool Compatibility Mode Usage
Missing input file path
Unsupported number of arguments
Unsupported mode "
Unsupported compression format "
Unsupported compression quality "
Unsupported compressor "
Unsupported file format "
Unsupported alpha mode
Unsupported mipmap filter "
Unsupported resize filter "
Unsupported resize round mode "
Unsupported wrap mode "
Unsupported ETCPACK/PVRTC channel weighting mode "
Unsupported PVRTC punch through mode "
The value for the RGBM range must be greater than or equal to 1.0
Compressors
Decompressors
ARM compression formats
ETC2COMP compression formats
ISPC compression formats
NVTT compression formats
PVRTC compression formats
STB compression formats
Input file formats
Output file formats
Operation modes
Compression qualities
Alpha modes
ETCPACK/PVRTC channel weighting modes
Resize filters
Resize round modes
Mipmap filters
Wrap modes
PVRTC punch through modes
, %s
File format does not support compression format
BGRA8
RGBA8
RGBA4
BGRA4
ABGR4
R5G6B5
B5G6R5
RGB5A1
BGR5A1
A1RGB5
A1BGR5
BGR10A2
RGB10A2
R16_Snorm
RGB16
RGB32
RGBA16
RGBA32
RG11B10
RGB9E5
ASTC4x2
ASTC4x2_HDR
ASTC4x4
ASTC4x4_HDR
ASTC5x4
ASTC5x4_HDR
ASTC5x5
ASTC5x5_HDR
ASTC6x5
ASTC6x5_HDR
ASTC6x6
ASTC6x6_HDR
ASTC8x4
ASTC8x4_HDR
ASTC8x5
ASTC8x5_HDR
ASTC8x6
ASTC8x6_HDR
ASTC8x8
ASTC8x8_HDR
ASTC10x5_HDR
ASTC10x6_HDR
ASTC10x8_HDR
ASTC10x10
ASTC10x10_HDR
ASTC12x10
ASTC12x10_HDR
ASTC12x12
ASTC12x12_HDR
EAC_R11
EAC_RGBA8
ETC2_RGB8
ETC2_RGB8A1
PVRTC_RGB_2BPP
PVRTC_RGB_4BPP
PVRTC_RGBA_2BPP
PVRTC_RGBA_4BPP
Unknown pixel format!
The selected pixelformat does not support sRGB
Unknown pixel format "
Unsupported KTX2 Image Dimensions (3)
Unsupported KTX2 Image Type (Array)
Unsupported KTX2 Image Format (%u)
TC_Version
TC_Options
Unknown texture type
Failed to write output file
Unsupported texture type
Apple TextureConverter 
, build: %b %d %Y, %T
TextureConverter TextureTool Compatibility Mode
Usage: TextureConverter [-hl]
       TextureConverter -c <reference_image> <input_image>
       TextureConverter [-ms] [-e <encoder>] [-p <preview_file>] -o <output> [-f <format>] <input_image>
       TextureConverter [-m] [-e <encoder>] -o <output> [-f <format>] <input_image>
       first form:
         -h       Display this help menu.
         -l       List available encoders, individual encoder options, and file formats.
       second form:
         -c       Compare <input_image> to <reference_image> and report differences.
       third form:
         -m       Generate a complete mipmap chain from the input image.
         -s       Report numerical differences between <input_image> and the encoded image.
         -e       Encode texture levels with <encoder>.
         -p       Output a PNG preview of the encoded output to <preview_file>. Requires -e option.
         -o       Write processed image to <output>.
         -f       Set file <format> for <output> image.
For detailed usage: TextureConverter --h
Encoders:
  PVRTC
    --bits-per-pixel-2
    --bits-per-pixel-4
    --punchthrough-unused
    --punchthrough-allowed
    --punchthrough-forced
    --alpha-is-independent
    --alpha-is-opacity
    --channel-weighting-linear
    --channel-weighting-perceptual
  ASTC
    --block-width-4
    --block-width-5
    --block-width-6
    --block-width-8
    --block-width-10
    --block-width-12
    --compression-mode-veryfast
    --compression-mode-fast
    --compression-mode-medium
    --compression-mode-thorough
    --compression-mode-exhaustive
    --srgb-yes
    --srgb-no
    --block-height-4
    --block-height-5
    --block-height-6
    --block-height-8
    --block-height-10
    --block-height-12
Formats:
  KTX
bits-per-pixel-2
bits-per-pixel-4
punchthrough-unused
punchthrough-allowed
punchthrough-forced
alpha-is-independent
alpha-is-opacity
channel-weighting-linear
channel-weighting-perceptual
block-width-4
block-width-5
block-width-6
block-width-8
block-width-10
block-width-12
compression-mode-veryfast
compression-mode-fast
compression-mode-medium
compression-mode-thorough
compression-mode-exhaustive
srgb-yes
srgb-no
block-height-4
block-height-5
block-height-6
block-height-8
block-height-10
block-height-12
h?lke:d:p:o:mf:c:s:r:
%s: no input file specified
%s: no output file specified
%s: -p option requires that -e is set
%s: decode mode not supported
%s: no reference file specified
%s: compare does not produce an output file
%s: compare does not produce a preview file
%s: generate mipmaps cannot be used with compare
%s: compare mode not supported
--time
--metrics
ASTC
--compressor=Auto
--compression_format=ASTC
--srgb_format
--compression_quality=Fastest
--compression_quality=Normal
--compression_quality=Production
--compression_quality=Highest
--compression_format=PVRTC_RGB_2BPP
--compression_format=PVRTC_RGBA_2BPP
--compression_format=PVRTC_RGB_4BPP
--compression_format=PVRTC_RGBA_4BPP
--pvrtc_punch_through=Allowed
--pvrtc_punch_through=Forced
--pvrtc_punch_through=Unused
--channel_weighting=Perceptual
--channel_weighting=Linear
--mipmap_filter=Box
--max_mipmaps=0
--file_format=KTX
--output=
Texture-Converter TextureTool Compatibility Mode
Migrate to the Texture-Converter interface for greater control
TextureConverter --h for more details
Calling 
beginScope
endScope
MTLAccelerationStructureBoundingBoxGeometryDescriptor
MTLAccelerationStructureDescriptor
MTLAccelerationStructureGeometryDescriptor
MTLAccelerationStructureTriangleGeometryDescriptor
MTLArgument
MTLArgumentDescriptor
MTLArrayType
MTLAttribute
MTLAttributeDescriptor
MTLAttributeDescriptorArray
MTLBinaryArchiveDescriptor
MTLBlitPassDescriptor
MTLBlitPassSampleBufferAttachmentDescriptor
MTLBlitPassSampleBufferAttachmentDescriptorArray
MTLBufferLayoutDescriptor
MTLBufferLayoutDescriptorArray
MTLCaptureDescriptor
MTLCaptureManager
MTLCommandBufferDescriptor
MTLCompileOptions
MTLComputePassDescriptor
MTLComputePassSampleBufferAttachmentDescriptor
MTLComputePassSampleBufferAttachmentDescriptorArray
MTLComputePipelineDescriptor
MTLComputePipelineReflection
MTLCounterSampleBufferDescriptor
MTLDepthStencilDescriptor
MTLFunctionConstant
MTLFunctionConstantValues
MTLFunctionDescriptor
MTLHeapDescriptor
MTLIndirectCommandBufferDescriptor
MTLInstanceAccelerationStructureDescriptor
MTLIntersectionFunctionDescriptor
MTLIntersectionFunctionTableDescriptor
MTLLinkedFunctions
MTLPipelineBufferDescriptor
MTLPipelineBufferDescriptorArray
MTLPointerType
MTLPrimitiveAccelerationStructureDescriptor
MTLRasterizationRateLayerArray
MTLRasterizationRateLayerDescriptor
MTLRasterizationRateMapDescriptor
MTLRasterizationRateSampleArray
MTLRenderPassAttachmentDescriptor
MTLRenderPassColorAttachmentDescriptor
MTLRenderPassColorAttachmentDescriptorArray
MTLRenderPassDepthAttachmentDescriptor
MTLRenderPassDescriptor
MTLRenderPassSampleBufferAttachmentDescriptor
MTLRenderPassSampleBufferAttachmentDescriptorArray
MTLRenderPassStencilAttachmentDescriptor
MTLRenderPipelineColorAttachmentDescriptor
MTLRenderPipelineColorAttachmentDescriptorArray
MTLRenderPipelineDescriptor
MTLRenderPipelineReflection
MTLResourceStatePassDescriptor
MTLResourceStatePassSampleBufferAttachmentDescriptor
MTLResourceStatePassSampleBufferAttachmentDescriptorArray
MTLSamplerDescriptor
MTLSharedEventHandle
MTLSharedEventListener
MTLSharedTextureHandle
MTLStageInputOutputDescriptor
MTLStencilDescriptor
MTLStructMember
MTLStructType
MTLTextureDescriptor
MTLTextureReferenceType
MTLTileRenderPipelineColorAttachmentDescriptor
MTLTileRenderPipelineColorAttachmentDescriptorArray
MTLTileRenderPipelineDescriptor
MTLType
MTLVertexAttribute
MTLVertexAttributeDescriptor
MTLVertexAttributeDescriptorArray
MTLVertexBufferLayoutDescriptor
MTLVertexBufferLayoutDescriptorArray
MTLVertexDescriptor
MTLVisibleFunctionTableDescriptor
GPUEndTime
GPUStartTime
accelerationStructureCommandEncoder
accelerationStructureSizesWithDescriptor:
access
addCompletedHandler:
addComputePipelineFunctionsWithDescriptor:error:
addDebugMarker:range:
addPresentedHandler:
addRenderPipelineFunctionsWithDescriptor:error:
addScheduledHandler:
addTileRenderPipelineFunctionsWithDescriptor:error:
alignment
allocatedSize
allowDuplicateIntersectionFunctionInvocation
allowGPUOptimizedContents
alphaBlendOperation
areBarycentricCoordsSupported
areProgrammableSamplePositionsSupported
areRasterOrderGroupsSupported
argumentBuffersSupport
argumentDescriptor
argumentIndex
argumentIndexStride
arguments
arrayLength
arrayType
attributeIndex
attributeType
attributes
backFaceStencil
binaryArchives
binaryFunctions
blitCommandEncoder
blitCommandEncoderWithDescriptor:
blitPassDescriptor
borderColor
boundingBoxBuffer
boundingBoxBufferOffset
boundingBoxCount
boundingBoxStride
buffer
bufferAlignment
bufferBytesPerRow
bufferDataSize
bufferDataType
bufferIndex
bufferOffset
bufferPointerType
bufferStructType
buffers
buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:
captureObject
clearBarrier
clearColor
clearDepth
clearStencil
colorAttachments
column
commandBuffer
commandBufferWithDescriptor:
commandBufferWithUnretainedReferences
commandQueue
commandTypes
commit
compareFunction
computeCommandEncoder
computeCommandEncoderWithDescriptor:
computeCommandEncoderWithDispatchType:
computeFunction
computePassDescriptor
concurrentDispatchThreadgroups:threadsPerThreadgroup:
concurrentDispatchThreads:threadsPerThreadgroup:
constantBlockAlignment
constantDataAtIndex:
constantValues
contents
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:
copyAccelerationStructure:toAccelerationStructure:
copyAndCompactAccelerationStructure:toAccelerationStructure:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
copyFromTexture:toTexture:
copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:
copyParameterDataToBuffer:offset:
counterSet
counterSets
counters
cpuCacheMode
currentAllocatedSize
dataSize
dataType
dealloc
debugLocation
debugSignposts
defaultCaptureScope
defaultRasterSampleCount
depth
depthAttachment
depthAttachmentPixelFormat
depthCompareFunction
depthFailureOperation
depthPlane
depthResolveFilter
depthStencilPassOperation
descriptor
destination
destinationAlphaBlendFactor
destinationRGBBlendFactor
device
didModifyRange:
dispatchQueue
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
dispatchThreadsPerTile:
dispatchType
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawPrimitives:indirectBuffer:indirectBufferOffset:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawableID
elementArrayType
elementIsArgumentBuffer
elementPointerType
elementStructType
elementTextureReferenceType
elementType
encodeSignalEvent:value:
encodeWaitForEvent:value:
encodedLength
encoderLabel
endEncoding
endOfEncoderSampleIndex
endOfFragmentSampleIndex
endOfVertexSampleIndex
enqueue
error
errorOptions
errorState
executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:
executeCommandsInBuffer:withRange:
fastMathEnabled
fillBuffer:range:value:
firstMipmapInTail
fragmentArguments
fragmentBuffers
fragmentFunction
frontFaceStencil
function
functionConstantsDictionary
functionCount
functionDescriptor
functionHandleWithFunction:
functionName
functionNames
functionType
functions
generateMipmapsForTexture:
geometryDescriptors
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
getBytes:bytesPerRow:fromRegion:mipmapLevel:
getDefaultSamplePositions:count:
getSamplePositions:count:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:
groups
hasUnifiedMemory
hazardTrackingMode
heap
heapBufferSizeAndAlignWithLength:options:
heapOffset
heapTextureSizeAndAlignWithDescriptor:
height
horizontal
horizontalSampleStorage
imageblockMemoryLengthForDimensions:
imageblockSampleLength
index
indexBuffer
indexBufferIndex
indexBufferOffset
indexType
indirectComputeCommandAtIndex:
indirectRenderCommandAtIndex:
inheritBuffers
inheritPipelineState
init
initWithDispatchQueue:
initWithSampleCount:
initWithSampleCount:horizontal:vertical:
inputPrimitiveTopology
insertDebugCaptureBoundary
insertDebugSignpost:
insertLibraries
installName
instanceCount
instanceDescriptorBuffer
instanceDescriptorBufferOffset
instanceDescriptorStride
instancedAccelerationStructures
intersectionFunctionTableDescriptor
intersectionFunctionTableOffset
iosurface
iosurfacePlane
isActive
isAliasable
isAlphaToCoverageEnabled
isAlphaToOneEnabled
isBlendingEnabled
isCapturing
isDepth24Stencil8PixelFormatSupported
isDepthTexture
isDepthWriteEnabled
isFramebufferOnly
isHeadless
isLowPower
isPatchControlPointData
isPatchData
isRasterizationEnabled
isRemovable
isShareable
isSparse
isTessellationFactorScaleEnabled
kernelEndTime
kernelStartTime
label
languageVersion
layerAtIndex:
layerCount
layers
layouts
length
level
libraries
libraryType
line
linkedFunctions
loadAction
location
locationNumber
lodAverage
lodMaxClamp
lodMinClamp
logs
magFilter
makeAliasable
mapPhysicalToScreenCoordinates:forLayer:
mapScreenToPhysicalCoordinates:forLayer:
maxAnisotropy
maxArgumentBufferSamplerCount
maxAvailableSizeWithAlignment:
maxBufferLength
maxCallStackDepth
maxFragmentBufferBindCount
maxKernelBufferBindCount
maxTessellationFactor
maxThreadgroupMemoryLength
maxThreadsPerThreadgroup
maxTotalThreadsPerThreadgroup
maxTransferRate
maxVertexAmplificationCount
maxVertexBufferBindCount
memberByName:
members
memoryBarrierWithResources:count:
memoryBarrierWithResources:count:afterStages:beforeStages:
memoryBarrierWithScope:
memoryBarrierWithScope:afterStages:beforeStages:
minFilter
minimumLinearTextureAlignmentForPixelFormat:
minimumTextureBufferAlignmentForPixelFormat:
mipFilter
mipmapLevelCount
mutability
name
newAccelerationStructureWithDescriptor:
newAccelerationStructureWithSize:
newArgumentEncoderForBufferAtIndex:
newArgumentEncoderWithArguments:
newArgumentEncoderWithBufferIndex:
newArgumentEncoderWithBufferIndex:reflection:
newBinaryArchiveWithDescriptor:error:
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
newBufferWithLength:options:
newBufferWithLength:options:offset:
newCaptureScopeWithCommandQueue:
newCaptureScopeWithDevice:
newCommandQueue
newCommandQueueWithMaxCommandBufferCount:
newComputePipelineStateWithAdditionalBinaryFunctions:error:
newComputePipelineStateWithDescriptor:options:completionHandler:
newComputePipelineStateWithDescriptor:options:reflection:error:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
newCounterSampleBufferWithDescriptor:error:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newDepthStencilStateWithDescriptor:
newDynamicLibrary:error:
newDynamicLibraryWithURL:error:
newEvent
newFence
newFunctionWithDescriptor:completionHandler:
newFunctionWithDescriptor:error:
newFunctionWithName:
newFunctionWithName:constantValues:completionHandler:
newFunctionWithName:constantValues:error:
newHeapWithDescriptor:
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
newIntersectionFunctionTableWithDescriptor:
newIntersectionFunctionWithDescriptor:completionHandler:
newIntersectionFunctionWithDescriptor:error:
newLibraryWithData:error:
newLibraryWithFile:error:
newLibraryWithSource:options:completionHandler:
newLibraryWithSource:options:error:
newLibraryWithURL:error:
newRasterizationRateMapWithDescriptor:
newRemoteBufferViewForDevice:
newRemoteTextureViewForDevice:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:options:completionHandler:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
newSamplerStateWithDescriptor:
newSharedEvent
newSharedEventHandle
newSharedEventWithHandle:
newSharedTextureHandle
newSharedTextureWithDescriptor:
newSharedTextureWithHandle:
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newTextureWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
newTextureWithDescriptor:offset:
newTextureWithDescriptor:offset:bytesPerRow:
newVisibleFunctionTableWithDescriptor:
normalizedCoordinates
notifyListener:atValue:block:
objectAtIndexedSubscript:
offset
opaque
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeIndirectCommandBuffer:withRange:
outputURL
parallelRenderCommandEncoderWithDescriptor:
parameterBufferSizeAndAlign
parentRelativeLevel
parentRelativeSlice
parentTexture
patchControlPointCount
patchType
peerCount
peerGroupID
peerIndex
physicalGranularity
physicalSizeForLayer:
pixelFormat
pointerType
popDebugGroup
preprocessorMacros
present
presentAfterMinimumDuration:
presentAtTime:
presentDrawable:
presentDrawable:afterMinimumDuration:
presentDrawable:atTime:
presentedTime
preserveInvariance
pushDebugGroup:
rAddressMode
rasterSampleCount
rasterizationRateMap
rasterizationRateMapDescriptorWithScreenSize:
rasterizationRateMapDescriptorWithScreenSize:layer:
rasterizationRateMapDescriptorWithScreenSize:layerCount:layers:
readMask
readWriteTextureSupport
recommendedMaxWorkingSetSize
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:
registryID
remoteStorageBuffer
remoteStorageTexture
removeAllDebugMarkers
renderCommandEncoder
renderCommandEncoderWithDescriptor:
renderPassDescriptor
renderTargetArrayLength
renderTargetHeight
renderTargetWidth
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
required
reset
resetCommandsInBuffer:withRange:
resetTextureAccessCounters:region:mipLevel:slice:
resetWithRange:
resolveCounterRange:
resolveCounters:inRange:destinationBuffer:destinationOffset:
resolveDepthPlane
resolveLevel
resolveSlice
resolveTexture
resourceOptions
resourceStateCommandEncoder
resourceStateCommandEncoderWithDescriptor:
resourceStatePassDescriptor
retainedReferences
rgbBlendOperation
rootResource
sAddressMode
sampleBuffer
sampleBufferAttachments
sampleCount
sampleCountersInBuffer:atSampleIndex:withBarrier:
sampleTimestamps:gpuTimestamp:
screenSize
serializeToURL:error:
setAccelerationStructure:atBufferIndex:
setAccelerationStructure:atIndex:
setAccess:
setAllowDuplicateIntersectionFunctionInvocation:
setAllowGPUOptimizedContents:
setAlphaBlendOperation:
setAlphaToCoverageEnabled:
setAlphaToOneEnabled:
setArgumentBuffer:offset:
setArgumentBuffer:startOffset:arrayElement:
setArrayLength:
setBackFaceStencil:
setBarrier
setBinaryArchives:
setBinaryFunctions:
setBlendColorRed:green:blue:alpha:
setBlendingEnabled:
setBorderColor:
setBoundingBoxBuffer:
setBoundingBoxBufferOffset:
setBoundingBoxCount:
setBoundingBoxStride:
setBuffer:offset:atIndex:
setBufferIndex:
setBufferOffset:atIndex:
setBuffers:offsets:withRange:
setBytes:length:atIndex:
setCaptureObject:
setClearColor:
setClearDepth:
setClearStencil:
setColorStoreAction:atIndex:
setColorStoreActionOptions:atIndex:
setCommandTypes:
setCompareFunction:
setComputeFunction:
setComputePipelineState:
setComputePipelineState:atIndex:
setComputePipelineStates:withRange:
setConstantBlockAlignment:
setConstantValue:type:atIndex:
setConstantValue:type:withName:
setConstantValues:
setConstantValues:type:withRange:
setCounterSet:
setCpuCacheMode:
setCullMode:
setDataType:
setDefaultCaptureScope:
setDefaultRasterSampleCount:
setDepth:
setDepthAttachment:
setDepthAttachmentPixelFormat:
setDepthBias:slopeScale:clamp:
setDepthClipMode:
setDepthCompareFunction:
setDepthFailureOperation:
setDepthPlane:
setDepthResolveFilter:
setDepthStencilPassOperation:
setDepthStencilState:
setDepthStoreAction:
setDepthStoreActionOptions:
setDepthWriteEnabled:
setDestination:
setDestinationAlphaBlendFactor:
setDestinationRGBBlendFactor:
setDispatchType:
setEndOfEncoderSampleIndex:
setEndOfFragmentSampleIndex:
setEndOfVertexSampleIndex:
setErrorOptions:
setFastMathEnabled:
setFormat:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBuffers:offsets:withRange:
setFragmentBytes:length:atIndex:
setFragmentFunction:
setFragmentSamplerState:atIndex:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentSamplerStates:withRange:
setFragmentTexture:atIndex:
setFragmentTextures:withRange:
setFrontFaceStencil:
setFrontFacingWinding:
setFunction:atIndex:
setFunctionCount:
setFunctions:
setFunctions:withRange:
setGeometryDescriptors:
setGroups:
setHazardTrackingMode:
setHeight:
setImageblockSampleLength:
setImageblockWidth:height:
setIndex:
setIndexBuffer:
setIndexBufferIndex:
setIndexBufferOffset:
setIndexType:
setIndirectCommandBuffer:atIndex:
setIndirectCommandBuffers:withRange:
setInheritBuffers:
setInheritPipelineState:
setInputPrimitiveTopology:
setInsertLibraries:
setInstallName:
setInstanceCount:
setInstanceDescriptorBuffer:
setInstanceDescriptorBufferOffset:
setInstanceDescriptorStride:
setInstancedAccelerationStructures:
setIntersectionFunctionTable:atBufferIndex:
setIntersectionFunctionTable:atIndex:
setIntersectionFunctionTableOffset:
setIntersectionFunctionTables:withBufferRange:
setIntersectionFunctionTables:withRange:
setKernelBuffer:offset:atIndex:
setLabel:
setLanguageVersion:
setLayer:atIndex:
setLevel:
setLibraries:
setLibraryType:
setLinkedFunctions:
setLoadAction:
setLodAverage:
setLodMaxClamp:
setLodMinClamp:
setMagFilter:
setMaxAnisotropy:
setMaxCallStackDepth:
setMaxFragmentBufferBindCount:
setMaxKernelBufferBindCount:
setMaxTessellationFactor:
setMaxTotalThreadsPerThreadgroup:
setMaxVertexAmplificationCount:
setMaxVertexBufferBindCount:
setMinFilter:
setMipFilter:
setMipmapLevelCount:
setMutability:
setName:
setNormalizedCoordinates:
setObject:atIndexedSubscript:
setOffset:
setOpaque:
setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:
setOpaqueTriangleIntersectionFunctionWithSignature:withRange:
setOptions:
setOutputURL:
setPixelFormat:
setPreprocessorMacros:
setPreserveInvariance:
setPurgeableState:
setRAddressMode:
setRasterSampleCount:
setRasterizationEnabled:
setRasterizationRateMap:
setReadMask:
setRenderPipelineState:
setRenderPipelineState:atIndex:
setRenderPipelineStates:withRange:
setRenderTargetArrayLength:
setRenderTargetHeight:
setRenderTargetWidth:
setResolveDepthPlane:
setResolveLevel:
setResolveSlice:
setResolveTexture:
setResourceOptions:
setRetainedReferences:
setRgbBlendOperation:
setSAddressMode:
setSampleBuffer:
setSampleCount:
setSamplePositions:count:
setSamplerState:atIndex:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setSamplerStates:withRange:
setScissorRect:
setScissorRects:count:
setScreenSize:
setSignaledValue:
setSize:
setSlice:
setSourceAlphaBlendFactor:
setSourceRGBBlendFactor:
setSpecializedName:
setStageInRegion:
setStageInRegionWithIndirectBuffer:indirectBufferOffset:
setStageInputDescriptor:
setStartOfEncoderSampleIndex:
setStartOfFragmentSampleIndex:
setStartOfVertexSampleIndex:
setStencilAttachment:
setStencilAttachmentPixelFormat:
setStencilCompareFunction:
setStencilFailureOperation:
setStencilFrontReferenceValue:backReferenceValue:
setStencilReferenceValue:
setStencilResolveFilter:
setStencilStoreAction:
setStencilStoreActionOptions:
setStepFunction:
setStepRate:
setStorageMode:
setStoreAction:
setStoreActionOptions:
setStride:
setSupportAddingBinaryFunctions:
setSupportArgumentBuffers:
setSupportIndirectCommandBuffers:
setSwizzle:
setTAddressMode:
setTessellationControlPointIndexType:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorFormat:
setTessellationFactorScale:
setTessellationFactorScaleEnabled:
setTessellationFactorStepFunction:
setTessellationOutputWindingOrder:
setTessellationPartitionMode:
setTexture:
setTexture:atIndex:
setTextureType:
setTextures:withRange:
setThreadGroupSizeIsMultipleOfThreadExecutionWidth:
setThreadgroupMemoryLength:
setThreadgroupMemoryLength:atIndex:
setThreadgroupMemoryLength:offset:atIndex:
setThreadgroupSizeMatchesTileSize:
setTileBuffer:offset:atIndex:
setTileBufferOffset:atIndex:
setTileBuffers:offsets:withRange:
setTileBytes:length:atIndex:
setTileFunction:
setTileHeight:
setTileSamplerState:atIndex:
setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setTileSamplerStates:withRange:
setTileTexture:atIndex:
setTileTextures:withRange:
setTileWidth:
setTriangleCount:
setTriangleFillMode:
setType:
setUrl:
setUsage:
setVertexAmplificationCount:viewMappings:
setVertexBuffer:
setVertexBuffer:offset:atIndex:
setVertexBufferOffset:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setVertexBytes:length:atIndex:
setVertexDescriptor:
setVertexFunction:
setVertexSamplerState:atIndex:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setVertexSamplerStates:withRange:
setVertexStride:
setVertexTexture:atIndex:
setVertexTextures:withRange:
setViewport:
setViewports:count:
setVisibilityResultBuffer:
setVisibilityResultMode:offset:
setVisibleFunctionTable:atBufferIndex:
setVisibleFunctionTable:atIndex:
setVisibleFunctionTables:withBufferRange:
setVisibleFunctionTables:withRange:
setWidth:
setWriteMask:
sharedCaptureManager
signaledValue
size
slice
sourceAlphaBlendFactor
sourceRGBBlendFactor
sparseTileSizeInBytes
sparseTileSizeWithTextureType:pixelFormat:sampleCount:
specializedName
stageInputAttributes
stageInputDescriptor
stageInputOutputDescriptor
startCaptureWithCommandQueue:
startCaptureWithDescriptor:error:
startCaptureWithDevice:
startCaptureWithScope:
startOfEncoderSampleIndex
startOfFragmentSampleIndex
startOfVertexSampleIndex
staticThreadgroupMemoryLength
status
stencilAttachment
stencilAttachmentPixelFormat
stencilCompareFunction
stencilFailureOperation
stencilResolveFilter
stepFunction
stepRate
stopCapture
storageMode
storeAction
storeActionOptions
stride
structType
supportAddingBinaryFunctions
supportArgumentBuffers
supportIndirectCommandBuffers
supports32BitFloatFiltering
supports32BitMSAA
supportsBCTextureCompression
supportsCounterSampling:
supportsDestination:
supportsDynamicLibraries
supportsFamily:
supportsFeatureSet:
supportsFunctionPointers
supportsPullModelInterpolation
supportsQueryTextureLOD
supportsRasterizationRateMapWithLayerCount:
supportsRaytracing
supportsShaderBarycentricCoordinates
supportsTextureSampleCount:
supportsVertexAmplificationCount:
swizzle
synchronizeResource:
synchronizeTexture:slice:level:
tAddressMode
tailSizeInBytes
tessellationControlPointIndexType
tessellationFactorFormat
tessellationFactorStepFunction
tessellationOutputWindingOrder
tessellationPartitionMode
texture
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
textureBarrier
textureBufferDescriptorWithPixelFormat:width:resourceOptions:usage:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
textureDataType
textureReferenceType
textureType
threadExecutionWidth
threadGroupSizeIsMultipleOfThreadExecutionWidth
threadgroupMemoryAlignment
threadgroupMemoryDataSize
threadgroupMemoryLength
threadgroupSizeMatchesTileSize
tileArguments
tileBuffers
tileFunction
tileHeight
tileWidth
triangleCount
type
updateFence:
updateFence:afterStages:
updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:
updateTextureMapping:mode:region:mipLevel:slice:
updateTextureMappings:mode:regions:mipLevels:slices:numRegions:
usage
useHeap:
useHeap:stages:
useHeaps:count:
useHeaps:count:stages:
useResource:usage:
useResource:usage:stages:
useResources:count:usage:
useResources:count:usage:stages:
usedSize
vertexArguments
vertexAttributes
vertexBuffer
vertexBufferOffset
vertexBuffers
vertexDescriptor
vertexFunction
vertexStride
vertical
verticalSampleStorage
visibilityResultBuffer
visibleFunctionTableDescriptor
waitForFence:
waitForFence:beforeStages:
waitUntilCompleted
waitUntilScheduled
width
writeCompactedAccelerationStructureSize:toBuffer:offset:
writeMask
NSArray
NSAutoreleasePool
NSBundle
NSCondition
NSDate
NSDictionary
NSError
NSNumber
NSObject
NSProcessInfo
NSSet
NSString
NSURL
NSValue
addObject:
activeProcessorCount
allBundles
allFrameworks
allObjects
alloc
appStoreReceiptURL
array
arrayWithObject:
arrayWithObjects:count:
automaticTerminationSupportEnabled
autorelease
beginActivityWithOptions:reason:
boolValue
broadcast
builtInPlugInsPath
builtInPlugInsURL
bundleIdentifier
bundlePath
bundleURL
bundleWithPath:
bundleWithURL:
characterAtIndex:
charValue
countByEnumeratingWithState:objects:count:
cStringUsingEncoding:
code
compare:
copy
count
dateWithTimeIntervalSinceNow:
descriptionWithLocale:
disableAutomaticTermination:
disableSuddenTermination
debugDescription
description
dictionary
dictionaryWithObject:forKey:
dictionaryWithObjects:forKeys:count:
domain
doubleValue
drain
enableAutomaticTermination:
enableSuddenTermination
endActivity:
environment
errorWithDomain:code:userInfo:
executablePath
executableURL
fileSystemRepresentation
fileURLWithPath:
floatValue
fullUserName
getValue:size:
globallyUniqueString
hash
hostName
infoDictionary
initFileURLWithPath:
initWithBool:
initWithBytes:objCType:
initWithBytesNoCopy:length:encoding:freeWhenDone:
initWithChar:
initWithCoder:
initWithCString:encoding:
initWithDomain:code:userInfo:
initWithDouble:
initWithFloat:
initWithInt:
initWithLong:
initWithLongLong:
initWithObjects:count:
initWithObjects:forKeys:count:
initWithPath:
initWithShort:
initWithString:
initWithUnsignedChar:
initWithUnsignedInt:
initWithUnsignedLong:
initWithUnsignedLongLong:
initWithUnsignedShort:
initWithURL:
integerValue
intValue
isEqual:
isEqualToNumber:
isEqualToString:
isEqualToValue:
isiOSAppOnMac
isLoaded
isLowPowerModeEnabled
isMacCatalystApp
isOperatingSystemAtLeastVersion:
keyEnumerator
lengthOfBytesUsingEncoding:
load
loadAndReturnError:
localizedDescription
localizedFailureReason
localizedInfoDictionary
localizedRecoveryOptions
localizedRecoverySuggestion
localizedStringForKey:value:table:
lock
longValue
longLongValue
mainBundle
maximumLengthOfBytesUsingEncoding:
methodSignatureForSelector:
mutableBytes
nextObject
numberWithBool:
numberWithChar:
numberWithDouble:
numberWithFloat:
numberWithInt:
numberWithLong:
numberWithLongLong:
numberWithShort:
numberWithUnsignedChar:
numberWithUnsignedInt:
numberWithUnsignedLong:
numberWithUnsignedLongLong:
numberWithUnsignedShort:
objCType
object
objectAtIndex:
objectEnumerator
objectForInfoDictionaryKey:
objectForKey:
operatingSystem
operatingSystemVersion
operatingSystemVersionString
pathForAuxiliaryExecutable:
performActivityWithOptions:reason:usingBlock:
performExpiringActivityWithReason:usingBlock:
physicalMemory
pointerValue
preflightAndReturnError:
privateFrameworksPath
privateFrameworksURL
processIdentifier
processInfo
processName
processorCount
rangeOfString:options:
release
resourcePath
resourceURL
respondsToSelector:
retain
retainCount
setAutomaticTerminationSupportEnabled:
setProcessName:
sharedFrameworksPath
sharedFrameworksURL
sharedSupportPath
sharedSupportURL
shortValue
showPools
signal
string
stringValue
stringWithString:
stringWithCString:encoding:
stringByAppendingString:
systemUptime
thermalState
unload
unlock
unsignedCharValue
unsignedIntegerValue
unsignedIntValue
unsignedLongValue
unsignedLongLongValue
unsignedShortValue
URLForAuxiliaryExecutable:
userInfo
userName
UTF8String
valueWithBytes:objCType:
valueWithPointer:
wait
waitUntilDate:
v24@?0^v8^v16
//  astc.metal
//  ASTCRuntime
//  Created by Georgi Rakidov on 28/01/2020.
//  Copyright 2020 APPLE. All rights reserved.
#include <metal_stdlib>
// Including header shared between this Metal shader code and Swift/C code executing Metal API commands
//#import "ShaderTypes.h"
#define BLOCKS_IN_GROUP_COUNT 64
using namespace metal;
//FUNCTION CONSTANTS
////////////////////////////////////////
constant int astc_block_width       [[ function_constant(0) ]];
constant int astc_block_height      [[ function_constant(1) ]];
constant int astc_channels          [[ function_constant(2) ]];
constant uint astc_packed_mode      [[ function_constant(3) ]];
////////////////////////////////////////
#define swap(a, b) {auto t = a; a=b; b=t;}
struct astc_settings
    int width;
    int height;
    int blocks_count;
    int width_in_blocks;
struct astc_block_data
    uint8_t weights[64];
    uint8_t endpoints[8];
struct range_values
    int levels_m;
    int levels_m_rcp;
    int levels_e;
    int levels;
struct pixel_set
    threadgroup uint32_t* restrict pixels;
    
    int width;
    int height;
float4 get_pixel_f(threadgroup const uint32_t* pixels, int x, int y)
    return unpack_unorm4x8_to_float(pixels[y*astc_block_width + x])*255.0;
//#define get_pixel(t,p,x,y) (unpack_unorm4x8_to_##t(p[y*astc_block_width + x])*t(255.0))
template<typename T>
void get_pixel(T out[], threadgroup const uint32_t* pixels, int x, int y)
    if(is_same<T, float>::value)
    {
        float4 tmp = unpack_unorm4x8_to_float(pixels[y*astc_block_width + x])*255.0;
        for(int i=0;i<4;++i)out[i] = tmp[i];
    }
    else
    {
        half4 tmp =  unpack_unorm4x8_to_half(pixels[y*astc_block_width + x])*255.0;
        for(int i=0;i<4;++i)out[i] = tmp[i];
    }
template <typename T>
T sq(T v)
    return v*v;
template <typename T>
T clamp(T v, int a, int b)
    return clamp(v, (T)a, (T)b);
template <typename T>
T dot3(T a[3], T b[3])
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
template <typename T>
inline T dot4(T a[4], T b[4])
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
template <typename T>
void ssymv3(T a[4], T covar[10], T b[4])
    a[0] = covar[0] * b[0] + covar[1] * b[1] + covar[2] * b[2];
    a[1] = covar[1] * b[0] + covar[4] * b[1] + covar[5] * b[2];
    a[2] = covar[2] * b[0] + covar[5] * b[1] + covar[7] * b[2];
template <typename T>
void ssymv4(T a[4], T covar[10], T b[4])
    a[0] = covar[0] * b[0] + covar[1] * b[1] + covar[2] * b[2] + covar[3] * b[3];
    a[1] = covar[1] * b[0] + covar[4] * b[1] + covar[5] * b[2] + covar[6] * b[3];
    a[2] = covar[2] * b[0] + covar[5] * b[1] + covar[7] * b[2] + covar[8] * b[3];
    a[3] = covar[3] * b[0] + covar[6] * b[1] + covar[8] * b[2] + covar[9] * b[3];
uint32_t get_field(uint32_t input, int a, int b)
    return (input >> b) & ((1 << (a - b + 1)) - 1);
int get_bits(uint32_t value, int from, int to)
    return (value >> from) & ((1 << (to + 1 - from)) - 1);
uint32_t get_bit(uint32_t input, int a)
    return get_field(input, a, a);
struct astc_block
    int width; // 2..8 <= 2^3
    int height;
    int dual_plane;
    int weight_range;
    int color_component_selector;
    int partitions;
    int partition_id;
    int color_endpoint_pairs;
    int channels;
    int color_endpoint_modes[4];
    int endpoint_range;
    
    astc_block(const uint32_t mode)
    {
        // uniform parameters
        width = int(2 + get_field(mode, 15, 13)); // 2..8 <= 2^3
        height = int(2 + get_field(mode, 18, 16)); // 2..8 <= 2^3
        dual_plane = int(get_field(mode, 19, 19));// 0 or 1
        partitions = 1;
        
        int colorEndpointModes0 = int(get_field(mode, 7, 6) * 2 + 6); // 6, 8, 10 or 12
        color_endpoint_pairs = 1 + (colorEndpointModes0 / 4);
        channels = (colorEndpointModes0 > 8) ? 4 : 3;
        // varying parameters
        weight_range = get_bits(mode, 0, 3);  // 0..11 <= 2^4
        color_component_selector = get_bits(mode, 4, 5);  // 0..2 <= 2^2
        partition_id = 0;
        color_endpoint_modes[0] = get_bits(mode, 6, 7) * 2 + 6; // 6, 8, 10 or 12
        endpoint_range = get_bits(mode, 8, 12); // 0..20 <= 2^5
    }
void accumulate_stats(float stats[15], float4 rgba, int channels)
    stats[10] += rgba[0];
    stats[11] += rgba[1];
    stats[12] += rgba[2];
    stats[0] += rgba[0] * rgba[0];
    stats[1] += rgba[0] * rgba[1];
    stats[2] += rgba[0] * rgba[2];
    stats[4] += rgba[1] * rgba[1];
    stats[5] += rgba[1] * rgba[2];
    stats[7] += rgba[2] * rgba[2];
    if (channels == 4)
    {
        stats[13] += rgba[3];
        stats[3] += rgba[0] * rgba[3];
        stats[6] += rgba[1] * rgba[3];
        stats[8] += rgba[2] * rgba[3];
        stats[9] += rgba[3] * rgba[3];
    }
void covar_from_stats(float covar[10], float stats[15], int channels)
    covar[0] = stats[0] - stats[10 + 0] * stats[10 + 0] / stats[14];
    covar[1] = stats[1] - stats[10 + 0] * stats[10 + 1] / stats[14];
    covar[2] = stats[2] - stats[10 + 0] * stats[10 + 2] / stats[14];
    covar[4] = stats[4] - stats[10 + 1] * stats[10 + 1] / stats[14];
    covar[5] = stats[5] - stats[10 + 1] * stats[10 + 2] / stats[14];
    covar[7] = stats[7] - stats[10 + 2] * stats[10 + 2] / stats[14];
    if (channels == 4)
    {
        covar[3] = stats[3] - stats[10 + 0] * stats[10 + 3] / stats[14];
        covar[6] = stats[6] - stats[10 + 1] * stats[10 + 3] / stats[14];
        covar[8] = stats[8] - stats[10 + 2] * stats[10 + 3] / stats[14];
        covar[9] = stats[9] - stats[10 + 3] * stats[10 + 3] / stats[14];
    }
void compute_axis(float axis[4], float covar[10], const int powerIterations, int channels)
    float vec[4] = { 1, 1, 1, 1 };
    for (int i = 0; i < powerIterations; i++)
    {
        if (channels == 3) ssymv3(axis, covar, vec);
        if (channels == 4) ssymv4(axis, covar, vec);
        for (int p = 0; p < channels; p++) vec[p] = axis[p];
        if (i % 2 == 1) // renormalize every other iteration
        {
            float norm_sq = 0;
            for (int p = 0; p < channels; p++)
                norm_sq += axis[p] * axis[p];
            float rnorm = rsqrt(norm_sq);
            for (int p = 0; p < channels; p++)
            {
                vec[p] *= rnorm;
            }
        }
    }
    for (int p = 0; p < channels; p++) axis[p] = vec[p];
void process_block(threadgroup uint32_t* restrict pixels, texture2d<half> src,
                uint xx, uint yy, uint width, uint height,
                bool zero_based, float dc[], float dir[])
    float stats[15] = { 0 };
    
    for (uint y = 0; y < height; y++)
    {
        for (uint x = 0; x < width; x++)
        {
            uint2 crd(xx * width + x, yy * height + y);
            
            half4 h_rgba = src.read(crd);
            float4 rgba = float4(h_rgba);
            //rgba.xyz = 1.0;
            rgba.w = 1.0;
            //rgba = float4(1,1,1,1);
            float4 rgba255 = rgba * 255.0f;
            
            accumulate_stats(stats, rgba255, 4);
            
            uint packed = pack_float_to_unorm4x8(rgba);
            pixels[y*astc_block_width + x] = packed;
        }
    }
    
    //width and height here are dimensions of the commpressed block
    //this function must be called only for blocks with the same dimesion as the global grid
    stats[14] += height * width;
    
    float cov[10];
    
    if (zero_based)
    {
        for (int p = 0; p < 4; p++) stats[10 + p] = 0;
    }
    covar_from_stats(cov, stats, 4);
    for (int p = 0; p < 4; p++)
        dc[p] = stats[10 + p] / stats[14];
    
    //Should work fine with 2,4,6,8,10
    int powerIterations = 2;
    float eps = sq(0.001) * 1000;
    cov[0] += eps;
    cov[4] += eps;
    cov[7] += eps;
    cov[9] += eps;
    
    compute_axis(dir, cov, powerIterations, 4);
void process_block_fast(threadgroup uint32_t* restrict pixels, texture2d<half> src,
                        //uint xx, uint yy, uint width, uint height, float ep[])
                        uint xx, uint yy, uint width, uint height, thread half3& ep_min, thread half3& ep_max)
    //half3 ep_min,ep_max;
    half lum_min = 1000.0h;
    half lum_max = 0.0h;
    for (uint y = 0; y < height; y++)
    {
        for (uint x = 0; x < width; x++)
        {
            uint2 crd(xx * width + x, yy * height + y);
            
            half3 rgb = src.read(crd).xyz;
            half lum = dot(rgb, half3(0.2126h, 0.7152h, 0.0722h));
            if(lum_max < lum)
            {
                lum_max = lum;
                ep_max = rgb;
            }
            if(lum_min > lum)
            {
                lum_min = lum;
                ep_min = rgb;
            }
            
            uint packed = pack_half_to_unorm4x8(half4(rgb, 1.0));
            pixels[y*width + x] = packed;
        }
    }
    
    ep_min *= 255.0;
    ep_max *= 255.0;
void fill_range_values(range_values values[], int _range[])
    int range = *_range;
    int range_div3 = (range * 21846) >> 16;
    int range_mod3 = range - range_div3 * 3;
    int levels_m = max(2, 5 - range_mod3 * 2);
    int levels_e = max(0, range_mod3 + range_div3 - 1);
    if (range == 0) levels_m = 2;
    int levels_m_rcp = 0x10000 / 2 + 1;
    if (levels_m == 3) levels_m_rcp = 0x10000 / 3 + 1;
    if (levels_m == 5) levels_m_rcp = 0x10000 / 5 + 1;
    values->levels_e = levels_e;
    values->levels_m = levels_m;
    values->levels_m_rcp = levels_m_rcp;
    values->levels = levels_m << levels_e;
range_values get_range_values(int range)
    range_values values;
    fill_range_values(&values, &range);
    return values;
int code_value(int value, range_values range)
    int coded = value;
    if (range.levels_m != 2 && range.levels > 5)
    {
        int value2 = value;
        if (value >= range.levels / 2) value2 = (range.levels - 1) - value;
        int q = (value2 * range.levels_m_rcp) >> 16;
        int r = value2 - q * range.levels_m;
        coded = q + r * (1 << (range.levels_e - 1));
        coded = coded * 2 + ((value >= range.levels / 2) ? 1 : 0);
    }
    return coded;
void code_block(const astc_block block[], threadgroup astc_block_data* restrict block_data)
    int num_weights = block->width * block->height * (block->dual_plane ? 2 : 1);
    range_values weight_range_values = get_range_values(block->weight_range);
    for (int i = 0; i < num_weights; i++)
    {
        block_data->weights[i] = code_value(block_data->weights[i], weight_range_values);
    }
    range_values endpoint_range_values = get_range_values(block->endpoint_range);
    for (int i = 0; i < 2 * block->color_endpoint_pairs; i++)
    {
        block_data->endpoints[i] = code_value(block_data->endpoints[i], endpoint_range_values);
    }
bool can_store(int value, int bits)
    if (value < 0) return false;
    if (value >= 1 << bits) return false;
    return true;
//TODO: Could this be a lookup table?
int pack_block_mode(const astc_block block[])
    int block_mode = 0;
    int D = !!block->dual_plane;
    int H = !!(block->weight_range >= 6);
    int DH = D * 2 + H;
    int R = block->weight_range + 2 - ((H > 0) ? 6 : 0);
    R = R / 2 + R % 2 * 4;
    if (can_store(block->width - 4, 2) && can_store(block->height - 2, 2))
    {
        int B = block->width - 4;
        int A = block->height - 2;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | (R & 3);
    }
    if (can_store(block->width - 8, 2) && can_store(block->height - 2, 2))
    {
        int B = block->width - 8;
        int A = block->height - 2;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | 4 | (R & 3);
    }
    if (can_store(block->width - 2, 2) && can_store(block->height - 8, 2))
    {
        int A = block->width - 2;
        int B = block->height - 8;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | 8 | (R & 3);
    }
    if (can_store(block->width - 2, 2) && can_store(block->height - 6, 1))
    {
        int A = block->width - 2;
        int B = block->height - 6;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | 12 | (R & 3);
    }
    if (can_store(block->width - 2, 1) && can_store(block->height - 2, 2))
    {
        int B = block->width;
        int A = block->height - 2;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | 12 | (R & 3);
    }
    if (DH == 0 && can_store(block->width - 6, 2) && can_store(block->height - 6, 2))
    {
        int A = block->width - 6;
        int B = block->height - 6;
        block_mode = (B << 9) | 256 | (A << 5) | (R << 2);
    }
    return block_mode;
constant static const int range_table[][3] =
    //2^ 3^ 5^
    { 1, 0, 0 }, // 0..1
    { 0, 1, 0 }, // 0..2
    { 2, 0, 0 }, // 0..3
    { 0, 0, 1 }, // 0..4
    { 1, 1, 0 }, // 0..5
    { 3, 0, 0 }, // 0..7
    { 1, 0, 1 }, // 0..9
    { 2, 1, 0 }, // 0..11
    { 4, 0, 0 }, // 0..15
    { 2, 0, 1 }, // 0..19
    { 3, 1, 0 }, // 0..23
    { 5, 0, 0 }, // 0..31
    { 3, 0, 1 }, // 0..39
    { 4, 1, 0 }, // 0..47
    { 6, 0, 0 }, // 0..63
    { 4, 0, 1 }, // 0..79
    { 5, 1, 0 }, // 0..95
    { 7, 0, 0 }, // 0..127
    { 5, 0, 1 }, // 0..159
    { 6, 1, 0 }, // 0..191
    { 8, 0, 0 }, // 0..255
int get_levels(int range)
    return (1 + 2 * range_table[range][1] + 4 * range_table[range][2]) << range_table[range][0];
int sequence_bits(int count, int range)
    int bits = count * range_table[range][0];
    bits += (count * range_table[range][1] * 8 + 4) / 5;
    bits += (count * range_table[range][2] * 7 + 2) / 3;
    return bits;
void set_bits(thread uint32_t data[4], thread int* pos, int bits, uint32_t value)
    int pos_val = *pos;
    
    int shift_left = pos_val % 32;
    
    int index = pos_val / 32;
    data[index] |= value << shift_left;
    
    int shifted_bits = 32 - shift_left;
    if(shifted_bits < bits)
    {
        data[index+1] |= value >> shifted_bits;
    }
    
    *pos = pos_val + bits;
void pack_five_trits(uint32_t data[4], int sequence[5], thread int* pos, int n)
    int t[5];
    int m[5];
    for (int i = 0; i < 5; i++)
    {
        t[i] = sequence[i] >> n;
        m[i] = sequence[i] - (t[i] << n);
    }
    int C;
    if (t[1] == 2 && t[2] == 2)
    {
        C = 3 * 4 + t[0];
    }
    else if (t[2] == 2)
    {
        C = t[1] * 16 + t[0] * 4 + 3;
    }
    else
    {
        C = t[2] * 16 + t[1] * 4 + t[0];
    }
    int T;
    if (t[3] == 2 && t[4] == 2)
    {
        T = get_field(C, 4, 2) * 32 + 7 * 4 + get_field(C, 1, 0);
    }
    else
    {
        T = get_field(C, 4, 0);
        if (t[4] == 2)
        {
            T += t[3] * 128 + 3 * 32;
        }
        else
        {
            T += t[4] * 128 + t[3] * 32;
        }
    }
    uint32_t pack1 = 0;
    pack1 |= m[0];
    pack1 |= get_field(T, 1, 0) << n;
    pack1 |= m[1] << (2 + n);
    uint32_t pack2 = 0;
    pack2 |= get_field(T, 3, 2);
    pack2 |= m[2] << 2;
    pack2 |= get_field(T, 4, 4) << (2 + n);
    pack2 |= m[3] << (3 + n);
    pack2 |= get_field(T, 6, 5) << (3 + n * 2);
    pack2 |= m[4] << (5 + n * 2);
    pack2 |= get_field(T, 7, 7) << (5 + n * 3);
    set_bits(data, pos, 2 + n * 2, pack1);
    set_bits(data, pos, 6 + n * 3, pack2);
void pack_three_quint(uint32_t data[4], int sequence[3], thread int* pos, int n)
    int q[3];
    int m[3];
    for (int i = 0; i < 3; i++)
    {
        q[i] = sequence[i] >> n;
        m[i] = sequence[i] - (q[i] << n);
    }
    int Q;
    if (q[0] == 4 && q[1] == 4)
    {
        Q = get_field(q[2], 1, 0) * 8 + 3 * 2 + get_bit(q[2], 2);
    }
    else
    {
        int C;
        if (q[1] == 4)
        {
            C = (q[0] << 3) + 5;
        }
        else
        {
            C = (q[1] << 3) + q[0];
        }
        if (q[2] == 4)
        {
            Q = get_field(~C, 2, 1) * 32 + get_field(C, 4, 3) * 8 + 3 * 2 + get_bit(C, 0);
        }
        else
        {
            Q = q[2] * 32 + get_field(C, 4, 0);
        }
    }
    uint32_t pack = 0;
    pack |= m[0];
    pack |= get_field(Q, 2, 0) << n;
    pack |= m[1] << (3 + n);
    pack |= get_field(Q, 4, 3) << (3 + n * 2);
    pack |= m[2] << (5 + n * 2);
    pack |= get_field(Q, 6, 5) << (5 + n * 3);
    set_bits(data, pos, 7 + n * 3, pack);
void pack_integer_sequence(uint32_t output_data[4], threadgroup const uint8_t* sequence, int pos, int count, int range)
    int n = range_table[range][0];
    int bits = sequence_bits(count, range);
    int pos0 = pos;
    uint32_t data[5] = { 0 };
    if (range_table[range][1] == 1)
    {
        for (int j = 0; j < (count + 4) / 5; j++)
        {
            int temp[5] = { 0 };
            for (int i = 0; i < min(count - j * 5, 5); i++) temp[i] = sequence[j * 5 + i];
            pack_five_trits(data, temp, &pos, n);
        }
    }
    else if (range_table[range][2] == 1)
    {
        for (int j = 0; j < (count + 2) / 3; j++)
        {
            int temp[3] = { 0 };
            for (int i = 0; i < min(count - j * 3, 3); i++) temp[i] = sequence[j * 3 + i];
            pack_three_quint(data, temp, &pos, n);
        }
    }
    else
    {
        for (int i = 0; i < count; i++)
        {
            set_bits(data, &pos, n, sequence[i]);
        }
    }
    if (pos0 + bits < 96) data[3] = 0;
    if (pos0 + bits < 64) data[2] = 0;
    if (pos0 + bits < 32) data[1] = 0;
    data[(pos0 + bits) / 32] &= (1 << ((pos0 + bits) % 32)) - 1;
    for (int k = 0; k < 4; k++) output_data[k] |= data[k];
void pack_block(uint32_t data[4],
                const astc_block block[],
                threadgroup const astc_block_data* restrict block_data)
    data[0] = 0;
    data[1] = 0;
    data[2] = 0;
    data[3] = 0;
    int pos = 0;
    set_bits(data, &pos, 11, pack_block_mode(block));
    int num_weights = block->width * block->height * (block->dual_plane ? 2 : 1);
    int weight_bits = sequence_bits(num_weights, block->weight_range);
    int extra_bits = 0;
    set_bits(data, &pos, 2, block->partitions - 1);
    set_bits(data, &pos, 4, block->color_endpoint_modes[0]);
    
    if (block->dual_plane)
    {
        extra_bits += 2;
        int pos2 = 128 - weight_bits - extra_bits;
        set_bits(data, &pos2, 2, block->color_component_selector);
    }
    int config_bits = pos + extra_bits;
    int remaining_bits = 128 - config_bits - weight_bits;
    int num_cem_pairs = 0;
    for (int j = 0; j < block->partitions; j++) num_cem_pairs += 1 + block->color_endpoint_modes[j] / 4;
    int endpoint_range = -1;
    for (int range = 20; range>0; range--)
    {
        int bits = sequence_bits(2 * num_cem_pairs, range);
        if (bits <= remaining_bits)
        {
            endpoint_range = range;
            break;
        }
    }
    pack_integer_sequence(data, block_data->endpoints, pos, 2 * num_cem_pairs, endpoint_range);
    
    uint32_t rdata[4] = { 0, 0, 0, 0 };
    pack_integer_sequence(rdata, block_data->weights, 0, num_weights, block->weight_range);
    for (int i = 0; i < 4; i++) data[i] |= reverse_bits(rdata[3 - i]);
/*void compute_pca_endpoints(float ep[8], pixel_set block[],
                                const threadgroup uint32_t* restrict pixels,
                                int channels, float dc[4], float dir[4])
    float ext[2] = { 1000, -1000 };
    for (int y = 0; y < astc_block_height; y++)
    for (int x = 0; x < astc_block_width; x++)
    {
        float proj = 0;
        
        float4 rgba = get_pixel_f(pixels, x, y);
        for (int p = 0; p < channels; p++)
            proj += (rgba[p] - dc[p]) * dir[p];
        ext[0] = min(ext[0], proj);
        ext[1] = max(ext[1], proj);
    }
    if (ext[1] - 1.0f < ext[0])
    {
        ext[1] += 0.5f;
        ext[0] -= 0.5f;
    }
    
    for (int i = 0; i < 2; i++)
    for (int p = 0; p < channels; p++)
    {
        ep[p * 2 + i] = dc[p] + dir[p] * ext[i];
    }
template <typename T>
void compute_pca_endpoints_fast(T ep[8], pixel_set block[],
                                const threadgroup uint32_t* restrict pixels,
                                int channels, T dc[4], T dir[4])
    T ext[2] = { 1000, -1000 };
    for (int y = 0; y < astc_block_height; y++)
    for (int x = 0; x < astc_block_width; x++)
    {
        T proj = 0;
        
        T rgba[4];
        get_pixel(rgba, pixels, x, y);
        for (int p = 0; p < channels; p++)
            proj += (rgba[p] - dc[p]) * dir[p];
        ext[0] = min(ext[0], proj);
        ext[1] = max(ext[1], proj);
    }
    if (ext[1] - 1.0f < ext[0])
    {
        ext[1] += 0.5f;
        ext[0] -= 0.5f;
    }
    
    for (int i = 0; i < 2; i++)
    for (int p = 0; p < channels; p++)
    {
        ep[p * 2 + i] = dc[p] + dir[p] * ext[i];
    }
template <typename T>
int quant_endpoint(T value, int levels)
    return clamp(value / T(255.0) * (levels - 1) + T(0.5), 0, levels - 1);
template <typename T>
void quantize_endpoints_scale(const astc_block block[],
                              threadgroup astc_block_data* restrict block_data,
                              T endpoints[4])
    int ep_levels = get_levels(block->endpoint_range);
    T near[3];
    T far[3];
    for (int p = 0; p < 3; p++)
    {
        near[p] = endpoints[p * 2 + 0];
        far[p] = endpoints[p * 2 + 1];
    }
    for (int p = 0; p < 3; p++)
        block_data->endpoints[p] = quant_endpoint(far[p], ep_levels);
    T sq_norm = dot3(far, far) + 0.00001;
    T scale = dot3(far, near) / sq_norm;
    block_data->endpoints[3] = quant_endpoint(scale * 256, ep_levels);
    if (block->color_endpoint_modes[0] > 8)
    {
        block_data->endpoints[4] = quant_endpoint(endpoints[3 * 2 + 0], ep_levels);
        block_data->endpoints[5] = quant_endpoint(endpoints[3 * 2 + 1], ep_levels);
    }
bool compare_endpoints(threadgroup uint8_t* endpoints, const astc_block block[])
    int sum = 0;
    for (int p = 0; p < 3; p++)
    {
        sum += endpoints[p * 2 + 0];
        sum -= endpoints[p * 2 + 1];
    }
    
    if (-2 <= sum && sum <= 2)
    {
        // avoid being too close so we don't need proper rounding
        for (int p = 0; p < 3; p++)
        {
            if (sum<=0)
                endpoints[p * 2 + 0] = clamp(endpoints[p * 2 + 0] - 1, 0, get_levels(block->endpoint_range) - 1);
            if (sum>0)
                endpoints[p * 2 + 1] = clamp(endpoints[p * 2 + 1] - 1, 0, get_levels(block->endpoint_range) - 1);
        }
        sum = 0;
        for (int p = 0; p < 3; p++)
        {
            sum += endpoints[p * 2 + 0];
            sum -= endpoints[p * 2 + 1];
        }
    }
    return sum > 0;
void reorder_endpoints(threadgroup uint8_t* endpoints, const astc_block block[], bool blue_contract)
    if (compare_endpoints(endpoints, block) == !blue_contract)
    for (int p = 0; p < 4; p++) swap(endpoints[p * 2], endpoints[p * 2 + 1]);
template <typename T>
void quantize_endpoints_pair(const astc_block block[],
                             threadgroup astc_block_data* restrict block_data,
                             T endpoints[6])
    int ep_levels = get_levels(block->endpoint_range);
    bool blue_contract = true;
    T blue_compressed[6];
    for (int i = 0; i < 2; i++)
    {
        blue_compressed[i + 0] = endpoints[i + 0] * 2 - endpoints[i + 4];
        blue_compressed[i + 2] = endpoints[i + 2] * 2 - endpoints[i + 4];
        blue_compressed[i + 4] = endpoints[i + 4];
        if (blue_compressed[i + 0] < 0) blue_contract = false;
        if (blue_compressed[i + 0] > 255) blue_contract = false;
        if (blue_compressed[i + 2] < 0) blue_contract = false;
        if (blue_compressed[i + 2] > 255) blue_contract = false;
    }
    
    if (blue_contract)
    {
        for (int p = 0; p < 3; p++)
        {
            block_data->endpoints[p * 2 + 0] = quant_endpoint(blue_compressed[p * 2 + 0], ep_levels);
            block_data->endpoints[p * 2 + 1] = quant_endpoint(blue_compressed[p * 2 + 1], ep_levels);
        }
    }
    else
    {
        for (int p = 0; p < 3; p++)
        {
            block_data->endpoints[p * 2 + 0] = quant_endpoint(endpoints[p * 2 + 0], ep_levels);
            block_data->endpoints[p * 2 + 1] = quant_endpoint(endpoints[p * 2 + 1], ep_levels);
        }
    }
    
    if (block->color_endpoint_modes[0] > 8)
    {
        block_data->endpoints[6] = quant_endpoint(endpoints[3 * 2 + 0], ep_levels);
        block_data->endpoints[7] = quant_endpoint(endpoints[3 * 2 + 1], ep_levels);
    }
    reorder_endpoints(block_data->endpoints, block, blue_contract);
template<typename T>
void quantize_endpoints(const astc_block block[],
                        threadgroup astc_block_data* restrict block_data,
                        T endpoints[])
    bool zero_based = (block->color_endpoint_modes[0] % 4) == 2;
    if (zero_based)
    {
        quantize_endpoints_scale(block, block_data, endpoints);
    }
    else
    {
        quantize_endpoints_pair(block, block_data, endpoints);
    }
inline int clamp_unorm8(int value)
    if (value < 0) return 0;
    if (value > 255) return 255;
    return value;
#define apply_blue_contract(r, g, b) { r = (r + b) >> 1; g = (g + b) >> 1; }
template <typename T>
void decode_endpoints(T endpoints[8], uint8_t coded_endpoints[], int mode)
    if ((mode % 4) == 2)
    {
        int v0 = coded_endpoints[0];
        int v1 = coded_endpoints[1];
        int v2 = coded_endpoints[2];
        int v3 = coded_endpoints[3];
        int v4 = coded_endpoints[4];
        int v5 = coded_endpoints[5];
        endpoints[0] = (v0 * v3) >> 8;
        endpoints[1] = (v1 * v3) >> 8;
        endpoints[2] = (v2 * v3) >> 8;
        endpoints[3] = 0xFF;
        endpoints[4] = v0;
        endpoints[5] = v1;
        endpoints[6] = v2;
        endpoints[7] = 0xFF;
        if (mode > 8)
        {
            endpoints[3] = clamp_unorm8(v4);
            endpoints[7] = clamp_unorm8(v5);
        }
    }
    if ((mode % 4) == 0)
    {
        int v0 = coded_endpoints[0];
        int v1 = coded_endpoints[1];
        int v2 = coded_endpoints[2];
        int v3 = coded_endpoints[3];
        int v4 = coded_endpoints[4];
        int v5 = coded_endpoints[5];
        int v6 = coded_endpoints[6];
        int v7 = coded_endpoints[7];
        bool swap_endpoints = v1 + v3 + v5 < v0 + v2 + v4;
        if (swap_endpoints)
        {
            swap(v0, v1);
            swap(v2, v3);
            swap(v4, v5);
            swap(v6, v7);
            apply_blue_contract(v0, v2, v4);
            apply_blue_contract(v1, v3, v5);
        }
        endpoints[0] = clamp_unorm8(v0);
        endpoints[1] = clamp_unorm8(v2);
        endpoints[2] = clamp_unorm8(v4);
        endpoints[3] = 0xFF;
        endpoints[4] = clamp_unorm8(v1);
        endpoints[5] = clamp_unorm8(v3);
        endpoints[6] = clamp_unorm8(v5);
        endpoints[7] = 0xFF;
        if (mode > 8)
        {
            endpoints[3] = clamp_unorm8(v6);
            endpoints[7] = clamp_unorm8(v7);
        }
    }
template <typename T>
void dequant_decode_endpoints(T endpoints[8], const threadgroup uint8_t* block_endpoints, int mode, int range)
    int levels = get_levels(range);
    int num_cem_pairs = 1 + mode / 4;
    uint8_t dequant_endpoints[8];
    for (int k = 0; k < 2 * num_cem_pairs; k++)
    {
        dequant_endpoints[k] = (int)(((int)block_endpoints[k]) * 255.0 / (levels - 1) + 0.5);
    }
    decode_endpoints(endpoints, dequant_endpoints, mode);
template <typename T>
void opt_weights_fast(threadgroup const uint32_t* restrict scaled_pixels,
                 const astc_block block[],
                 T rec_endpoints[],
                 threadgroup astc_block_data* restrict block_data)
    const int channels = 4;
    T w_levels = get_levels(block->weight_range);
    T dir[4]; dir[3] = 0;
    for (int p = 0; p < channels; p++) dir[p] = rec_endpoints[4 + p] - rec_endpoints[0 + p];
    T sq_norm = dot4(dir, dir) + 0.00001;
    for (int p = 0; p < channels; p++) dir[p] *= (w_levels - 1) / sq_norm;
    
    for (int y = 0; y < astc_block_height; y++)
    for (int x = 0; x < astc_block_width; x++)
    {
        T pixel[4]; pixel[3] = 0;
        
        T rgba[4];
        get_pixel(rgba, scaled_pixels, x, y);
        for (int p = 0; p < channels; ++p)
            pixel[p] = rgba[p] - rec_endpoints[0 + p];
        
        T q = clamp(dot4(pixel, dir) + 0.5, 0.0, w_levels - 1.0);
        block_data->weights[y * astc_block_width + x] = q;
    }
void endpoints_and_weights(threadgroup uint32_t* restrict scaled_pixels,
                    const astc_block block[],
                    threadgroup astc_block_data* restrict block_data,
                    float dc[],
                    float dir[]
                    )
    pixel_set pset;
    pset.pixels = scaled_pixels;
    pset.width = block->width;
    pset.height = block->height;
    float ep[8];
    //compute_pca_endpoints(ep, &pset, scaled_pixels, 4, dc, dir);
    compute_pca_endpoints_fast(ep, &pset, scaled_pixels, 4, dc, dir);
    
    quantize_endpoints(block, block_data, ep);
    
    float rec_endpoints[8];
    dequant_decode_endpoints(rec_endpoints, block_data->endpoints,
                             block->color_endpoint_modes[0], block->endpoint_range);
    opt_weights_fast(scaled_pixels, block, rec_endpoints, block_data);
kernel void astc_encode(texture2d<half>            inTexture               [[ texture(0) ]],
                        device uint*               dst                     [[ buffer(0) ]],
                        constant astc_settings*    settings                [[ buffer(1) ]],
                        uint                       block_index_in_group    [[ thread_index_in_threadgroup ]],
                        uint                       block_id                [[ thread_position_in_grid ]],
                        threadgroup uchar*         tg_mem_pool             [[threadgroup(0)]])
    if(block_id >= (uint)settings->blocks_count)
        return;
    
    threadgroup uint32_t*         _pixels = (threadgroup uint32_t*)tg_mem_pool;
    uint pixels_offset = (BLOCKS_IN_GROUP_COUNT) * (astc_block_width * astc_block_height);
    threadgroup astc_block_data*  _block_data = (threadgroup astc_block_data*)(_pixels + pixels_offset);
    
    threadgroup uint32_t* restrict pixels = &_pixels[astc_block_width * astc_block_height * block_index_in_group];
    threadgroup astc_block_data* block_data = &_block_data[block_index_in_group];
    
    uint width_in_blocks = settings->width_in_blocks;
    uint2 block_crd(block_id % width_in_blocks, block_id / width_in_blocks);
    
    const astc_block block(astc_packed_mode);
    float dc[4];
    float dir[4];
    bool zero_based = (block.color_endpoint_modes[0] % 4) == 2;
    process_block(pixels, inTexture,
                  block_crd.x, block_crd.y,
                  astc_block_width, astc_block_height,
                  zero_based, dc, dir);
    
    endpoints_and_weights(pixels, &block, block_data, dc, dir);
    
    code_block(&block, block_data);
    
    uint32_t data[4];
    pack_block(data, &block, block_data);
    for (int i = 0; i < 4; i++)
    {
        int outIndex = (block_crd.y * width_in_blocks + block_crd.x) * 4 + i;
        dst[outIndex] = data[i];
    }
kernel void astc_encode_fast(texture2d<half>       inTexture               [[ texture(0) ]],
                        device uint*               dst                     [[ buffer(0) ]],
                        constant astc_settings*    settings                [[ buffer(1) ]],
                        uint                       block_index_in_group    [[ thread_index_in_threadgroup ]],
                        uint                       block_id                [[ thread_position_in_grid ]],
                        threadgroup uchar*         tg_mem_pool             [[threadgroup(0)]])
    threadgroup uint32_t*         _pixels = (threadgroup uint32_t*)tg_mem_pool;
    uint pixels_offset = (BLOCKS_IN_GROUP_COUNT) * (astc_block_width * astc_block_height);
    threadgroup astc_block_data*  _block_data = (threadgroup astc_block_data*)(_pixels + pixels_offset);
    
    threadgroup uint32_t* restrict pixels = &_pixels[astc_block_width * astc_block_height * block_index_in_group];
    threadgroup astc_block_data* block_data = &_block_data[block_index_in_group];
    
    uint width_in_blocks = settings->width_in_blocks;
    uint2 block_crd(block_id % width_in_blocks, block_id / width_in_blocks);
    half3 ep_min, ep_max;
    process_block_fast(pixels, inTexture, block_crd.x, block_crd.y,
                       astc_block_width, astc_block_height, ep_min, ep_max);
    
    float ep[8];
    for(int p=0;p<3;++p)
    {
        ep[p*2 + 0] = ep_min[p];
        ep[p*2 + 1] = ep_max[p];
    }
    
    ep[6] = 255.0;
    ep[7] = 255.0;
    
    const astc_block block(astc_packed_mode);
    quantize_endpoints(&block, block_data, ep);
    
    float rec_endpoints[8];
    dequant_decode_endpoints(rec_endpoints, block_data->endpoints,
                             block.color_endpoint_modes[0],
                             block.endpoint_range);
    
    opt_weights_fast(pixels, &block, rec_endpoints, block_data);
    
    code_block(&block, block_data);
    
    uint32_t data[4];
    pack_block(data, &block, block_data);
    for (int i = 0; i < 4; i++)
    {
        int outIndex = (block_crd.y * width_in_blocks + block_crd.x) * 4 + i;
        dst[outIndex] = data[i];
    }
///////////////////////////
//BC1/BC3 encoding
void swap_ints(int u[], int v[], int n)
    for (int i=0; i<n; i++)
    {
        int t = u[i];
        u[i] = v[i];
        v[i] = t;
    }
int stb__Mul8Bit(int a, int b)
  int t = a*b + 128;
  return (t + (t >> 8)) >> 8;
ushort stb__As16Bit(int r, int g, int b)
   return (stb__Mul8Bit(r,31) << 11) + (stb__Mul8Bit(g,63) << 5) + stb__Mul8Bit(b,31);
ushort enc_rgb565(float c[3])
    return stb__As16Bit((int)c[0], (int)c[1], (int)c[2]);
void dec_rgb565(float c[3], int p)
    int c2 = (p>>0)&31;
    int c1 = (p>>5)&63;
    int c0 = (p>>11)&31;
    c[0] = (c0<<3)+(c0>>2);
    c[1] = (c1<<2)+(c1>>4);
    c[2] = (c2<<3)+(c2>>2);
uint fast_quant(threadgroup const uint* pixels, int p0, int p1)
    float c0[3];
    float c1[3];
    dec_rgb565(c0, p0);
    dec_rgb565(c1, p1);
    float dir[3];
    for (int p=0; p<3; p++) dir[p] = c1[p]-c0[p];
    
    float sq_norm = 0;
    for (int p=0; p<3; p++) sq_norm += sq(dir[p]);
    float rsq_norm = 1.0/sq_norm;
    for (int p=0; p<3; p++) dir[p] *= rsq_norm*3;
    float bias = 0.5;
    for (int p=0; p<3; p++) bias -= c0[p]*dir[p];
    uint bits = 0;
    uint scaler = 1;
    for(int y=0;y<astc_block_height;++y)
    {
        for(int x=0;x<astc_block_height;++x)
        {
            float dot = 0;
            float4 rgba = get_pixel_f(pixels, x, y);
            for (int p=0; p<3; p++)
            {
                dot += rgba[p]*dir[p];
            }
            int q = clamp((int)(dot+bias), 0, 3);
            bits += q*scaler;
            scaler *= 4;
        }
    }
    
    return bits;
uint fix_qbits(uint qbits)
    const uint mask_01b = 0x55555555;
    const uint mask_10b = 0xAAAAAAAA;
    uint qbits0 = qbits&mask_01b;
    uint qbits1 = qbits&mask_10b;
    qbits = (qbits1>>1) + (qbits1 ^ (qbits0<<1));
    return qbits;
kernel void bc1_encode_fast(texture2d<half>       inTexture               [[ texture(0) ]],
                    device uint*               dst                     [[ buffer(0) ]],
                    constant astc_settings*    settings                [[ buffer(1) ]],
                    uint                       block_index_in_group    [[ thread_index_in_threadgroup ]],
                    uint                       block_id                [[ thread_position_in_grid ]],
                    threadgroup uchar*         tg_mem_pool             [[threadgroup(0)]])
    threadgroup uint32_t*         _pixels = (threadgroup uint32_t*)tg_mem_pool;
    threadgroup uint32_t* restrict pixels = &_pixels[astc_block_width * astc_block_height * block_index_in_group];
    
    uint width_in_blocks = settings->width_in_blocks;
    uint2 block_crd(block_id % width_in_blocks, block_id / width_in_blocks);
    
    float c0[3];
    float c1[3];
    half3 ep_min, ep_max;
    process_block_fast(pixels, inTexture, block_crd.x, block_crd.y,
                       astc_block_width, astc_block_height, ep_min, ep_max);
    
    for(int i=0;i<3;++i)
    {
        c0[i] = ep_min[i];
        c1[i] = ep_max[i];
    }
    
    int p[2];
    p[0] = enc_rgb565(c0);
    p[1] = enc_rgb565(c1);
    if (p[0]<p[1]) swap_ints(&p[0], &p[1], 1);
    
    uint data[2];
    data[0] = (1<<16)*p[1]+p[0];
    data[1] = fast_quant(pixels, p[0], p[1]);
    
    data[1] = fix_qbits(data[1]);
    
    int out_index = (block_crd.y * width_in_blocks + block_crd.x) * 2;
    dst[out_index] = data[0];
    dst[out_index + 1] = data[1];
#include <metal_stdlib>
using namespace metal;
kernel void
simpleDecompress(texture2d<float, access::read> inTexture  [[texture(0)]],
                 texture2d<uint, access::write> outTexture [[texture(1)]],
                 uint2                          gid        [[thread_position_in_grid]])
    float4 fColour = inTexture.read(gid);
    outTexture.write(uint4(fColour*255.0), gid);
kernel void
simpleDecompress16F(texture2d<float, access::read> inTexture  [[texture(0)]],
                    texture2d<half, access::write> outTexture [[texture(1)]],
                    uint2                          gid        [[thread_position_in_grid]])
    float4 fColour = inTexture.read(gid);
    outTexture.write(half4(fColour), gid);
simpleDecompress16F
simpleDecompress
Compression failed
Bad checkerboard mod value %d (this isn't supposed to happen!)
Bad threshold mod value %d (this isn't supposed to happen!)
Bad mod value %d (this isn't supposed to happen!)
Bit replication is wrong! (%d, %d)
Bit extra replication is wrong! (%d, %d, %d, %d)
PVRTC requires a square image
PVRTC requires a first mip level with a width/height >= 8
PVRTC requires a width/height of power of two
ASTCENC_SUCCESS
ASTCENC_ERR_OUT_OF_MEM
ASTCENC_ERR_BAD_CPU_FLOAT
ASTCENC_ERR_BAD_PARAM
ASTCENC_ERR_BAD_BLOCK_SIZE
ASTCENC_ERR_BAD_PROFILE
ASTCENC_ERR_BAD_QUALITY
ASTCENC_ERR_BAD_FLAGS
ASTCENC_ERR_BAD_SWIZZLE
ASTCENC_ERR_BAD_CONTEXT
ASTCENC_ERR_NOT_IMPLEMENTED
EtcImage.cpp
Encode
m_paucEncodingBits == nullptr
effortblocks = %d
pass %u
    %u unfinished blocks
Finished %d Blocks out of %d
    %u iterated blocks
IterateThroughWorstBlocks
a_uiMultithreadingStride > 0
FindEncodingWarningTypesForCurFormat
ETC1
RGB8
SRGB8
RGB8A1
SRGB8A1
SRGBA8
SIGNED_R11
RG11
SIGNED_RG11
UNKNOWN
RunFirstPass
SetEncodingBits
GetError
EtcBlock4x4Encoding.h
m_fError >= 0.0f
thread constructor failed
InitFromSource
EtcBlock4x4.cpp
InitFromEtcEncodingBits
PLANAR
CalcPixelError
EtcBlock4x4Encoding.cpp
a_fDecodedAlpha >= 0.0f
PerformIteration
EtcBlock4x4Encoding_ETC1.cpp
!m_boolDone
CalculateSourceAverages
(fWeightSumLeft + fWeightSumRight) > 0.0f
(fWeightSumTop + fWeightSumBottom) > 0.0f
fWeightSumRight > 0.0f
fWeightSumLeft > 0.0f
fWeightSumBottom > 0.0f
fWeightSumTop > 0.0f
TryDifferential
encodingTry.m_fError < FLT_MAX
ptryBest1 != nullptr
ptryBest2 != nullptr
iDRed >= -4 && iDRed < 4
iDGreen >= -4 && iDGreen < 4
iDBlue >= -4 && iDBlue < 4
TryDifferentialHalf
iRed >= 0 && iRed <= 31
iGreen >= 0 && iGreen <= 31
iBlue >= 0 && iBlue <= 31
ptry < &a_phalf->m_atry[DifferentialTrys::Half::MAX_TRYS]
ptry->m_fError < FLT_MAX
TryIndividualHalf
iRed >= 0 && iRed <= 15
iGreen >= 0 && iGreen <= 15
iBlue >= 0 && iBlue <= 15
ptry < &a_phalf->m_atry[IndividualTrys::Half::MAX_TRYS]
m_mode == MODE_ETC1
iDRed2 >= -4 && iDRed2 < 4
iDGreen2 >= -4 && iDGreen2 < 4
iDBlue2 >= -4 && iDBlue2 < 4
InitFromEncodingBits
EtcBlock4x4Encoding_R11.cpp
CalculateR11
fMinRed <= fMaxRed
EtcBlock4x4Encoding_RG11.cpp
CalculateG11
fMinGrn <= fMaxGrn
EtcBlock4x4Encoding_RGB8.cpp
CalculateBaseColorsForTAndH
uiTransparentPixels < PIXELS
SetEncodingBits_T
m_mode == MODE_T
m_boolDiff == true
iRed2 < 0 || iRed2 > 31
SetEncodingBits_H
m_mode == MODE_H
iRed2 >= 0 && iRed2 <= 31
iGreen2 < 0 || iGreen2 > 31
SetEncodingBits_Planar
m_mode == MODE_PLANAR
iGreen2 >= 0 && iGreen2 <= 31
iBlue2 < 0 || iBlue2 > 31
EtcBlock4x4Encoding_RGB8A1.cpp
!m_boolOpaque
!m_boolTransparent
SetEncodingBits_ETC1
m_boolDiff
!m_boolPunchThroughPixels
m_boolTransparent
m_uiEncodingIterations == 0
EtcBlock4x4Encoding_RGBA8.cpp
CalculateA8
fMinAlpha <= fMaxAlpha
DifferentialTrys
EtcDifferentialTrys.cpp
a_uiRadius <= MAX_RADIUS
iRed1 >= (signed)(0 + a_uiRadius) && iRed1 <= (signed)(31 - a_uiRadius)
iRed2 >= (signed)(0 + a_uiRadius) && iRed2 <= (signed)(31 - a_uiRadius)
iGreen1 >= (signed)(0 + a_uiRadius) && iGreen1 <= (signed)(31 - a_uiRadius)
iGreen2 >= (signed)(0 + a_uiRadius) && iGreen2 <= (signed)(31 - a_uiRadius)
iBlue1 >= (signed)(0+a_uiRadius) && iBlue1 <= (signed)(31 - a_uiRadius)
iBlue2 >= (signed)(0 + a_uiRadius) && iBlue2 <= (signed)(31 - a_uiRadius)
IndividualTrys
EtcIndividualTrys.cpp
AddBlock
EtcSortedBlockList.cpp
m_uiAddedBlocks < m_uiImageBlocks
Sort
m_uiAddedBlocks == m_uiImageBlocks
pbucket->plinkLast->GetNext() == nullptr
%3d: e=%.3f rms=%.6f %u
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc6h/zohone.cpp
float ZOH::refineone(const Tile &, int, const FltEndpts *, char *)
data && availdatabits > 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc6h/bits.h
ZOH::Bits::Bits(const char *, int)
nbits >= 0 && nbits < 32
int ZOH::Bits::read(int)
bptr < bend
int ZOH::Bits::readone()
bw[10],bw[11],bw[12],bw[13],bw[14],bw[15],bx[3:0],gw[10],gw[11],gw[12],gw[13],gw[14],gw[15],gx[3:0],rw[10],rw[11],rw[12],rw[13],rw[14],rw[15],rx[3:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
bw[10],bw[11],bx[7:0],gw[10],gw[11],gx[7:0],rw[10],rw[11],rx[7:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
bw[10],bx[8:0],gw[10],gx[8:0],rw[10],rx[8:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
bx[9:0],gx[9:0],rx[9:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
data && maxdatabits > 0
ZOH::Bits::Bits(char *, int)
void ZOH::Bits::write(int, int)
void ZOH::Bits::writeone(int)
bptr < maxbits
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc6h/zohtwo.cpp
float ZOH::refinetwo(const Tile &, int, const FltEndpts *, char *)
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bz[1],bw[10],bx[3:0],gz[3:0],bz[0],gw[10],gx[3:0],gy[3:0],rw[10],rx[4:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
d[4:0],bz[3],gy[4],rz[3:0],bz[2],bz[0],ry[3:0],by[3:0],bz[1],bw[10],bx[3:0],gz[3:0],gw[10],gx[4:0],gy[3:0],gz[4],rw[10],rx[3:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
d[4:0],bz[3],bz[4],rz[3:0],bz[2:1],ry[3:0],by[3:0],bw[10],bx[4:0],gz[3:0],bz[0],gw[10],gx[3:0],gy[3:0],by[4],rw[10],rx[3:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bz[1],bx[4:0],gz[3:0],bz[0],gx[4:0],gy[3:0],gz[4],rx[4:0],bw[9:0],gw[9:0],rw[9:0],bz[4],by[4],gy[4],m[1:0]
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bz[1],bx[4:0],gz[3:0],bz[0],gx[4:0],gy[3:0],gz[4],rx[4:0],bz[4],bw[8:0],gy[4],gw[8:0],by[4],rw[8:0],m[4:0]
d[4:0],rz[5:0],ry[5:0],by[3:0],bz[1],bx[4:0],gz[3:0],bz[0],gx[4:0],gy[3:0],rx[5:0],bz[4:3],bw[7:0],gy[4],bz[2],gw[7:0],by[4],gz[4],rw[7:0],m[4:0]
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bz[1],bx[4:0],gz[3:0],gx[5:0],gy[3:0],gz[4],rx[4:0],bz[4],gz[5],bw[7:0],gy[4],gy[5],gw[7:0],by[4],bz[0],rw[7:0],m[4:0]
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bx[5:0],gz[3:0],bz[0],gx[4:0],gy[3:0],gz[4],rx[4:0],bz[4],bz[5],bw[7:0],gy[4],by[5],gw[7:0],by[4],bz[1],rw[7:0],m[4:0]
d[4:0],rz[5:0],ry[5:0],by[3:0],bx[5:0],gz[3:0],gx[5:0],gy[3:0],rx[5:0],bz[4],bz[5],bz[3],bw[6:0],gy[4],bz[2],by[5],gw[6:0],by[4],bz[1:0],rw[6:0],gz[5:4],gy[5],m[1:0]
d[4:0],rz[5:0],ry[5:0],by[3:0],bx[5:0],gz[3:0],gx[5:0],gy[3:0],rx[5:0],bz[4],bz[5],bz[3],gz[5],bw[5:0],gy[4],bz[2],by[5],gy[5],gw[5:0],by[4],bz[1:0],gz[4],rw[5:0],m[4:0]
in.getptr() == AVPCL::BITSIZE
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode0.cpp
void AVPCL::decompress_mode0(const char *, Tile &)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/bits.h
AVPCL::Bits::Bits(const char *, int)
void read_header(Bits &, IntEndptsRGB_2 *, int &, Pattern &, int &)
in.getptr() == patterns[pat_index].modebits
in.getptr() == 83
int AVPCL::Bits::read(int)
int AVPCL::Bits::readone()
compr_endpts.A[j] < 16
void compress_one(const IntEndptsRGB &, IntEndptsRGB_2 &)
compr_endpts.B[j] < 16
shapes[((shapeindex)&3)*4+((shapeindex)>>2)*64+(x)+(y)*16] == region
void swap_indices(IntEndptsRGB_2 *, int (*)[4], int)
orig_indices[i] != -1
float optimize_one(const Vector4 *, const float *, int, float, const IntEndptsRGB_2 &, const RegionPrec &, IntEndptsRGB_2 &)
new_indices[i] != -1
out.getptr() == AVPCL::BITSIZE
void emit_block(const IntEndptsRGB_2 *, int, const Pattern &, const int (*)[4], char *)
AVPCL::Bits::Bits(char *, int)
out.getptr() == 83
void write_header(const IntEndptsRGB_2 *, int, const Pattern &, Bits &)
void AVPCL::Bits::write(int, int)
void AVPCL::Bits::writeone(int)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode1.cpp
void AVPCL::decompress_mode1(const char *, Tile &)
void read_header(Bits &, IntEndptsRGB_1 *, int &, Pattern &, int &)
in.getptr() == 82
compr_endpts.A[j] < 64
void compress_one(const IntEndptsRGB &, IntEndptsRGB_1 &)
compr_endpts.B[j] < 64
void swap_indices(IntEndptsRGB_1 *, int (*)[4], int)
float optimize_one(const Vector4 *, const float *, int, float, const IntEndptsRGB_1 &, const RegionPrec &, IntEndptsRGB_1 &)
void emit_block(const IntEndptsRGB_1 *, int, const Pattern &, const int (*)[4], char *)
out.getptr() == 82
void write_header(const IntEndptsRGB_1 *, int, const Pattern &, Bits &)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode2.cpp
void AVPCL::decompress_mode2(const char *, Tile &)
void read_header(Bits &, IntEndptsRGB *, int &, Pattern &, int &)
in.getptr() == 99
void swap_indices(IntEndptsRGB *, int (*)[4], int)
float optimize_one(const Vector4 *, const float *, int, float, const IntEndptsRGB &, const RegionPrec &, IntEndptsRGB &)
void emit_block(const IntEndptsRGB *, int, const Pattern &, const int (*)[4], char *)
out.getptr() == 99
void write_header(const IntEndptsRGB *, int, const Pattern &, Bits &)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode3.cpp
void AVPCL::decompress_mode3(const char *, Tile &)
in.getptr() == 98
compr_endpts.A[j] < 128
compr_endpts.B[j] < 128
out.getptr() == 98
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode4.cpp
void AVPCL::decompress_mode4(const char *, Tile &)
void read_header(Bits &, IntEndptsRGBA *, int &, int &, int &, Pattern &, int &)
in.getptr() == 50
void assign_indices(const Tile &, int, int, int, IntEndptsRGBA *, const PatternPrec &, int (*)[4][4], float *)
orig_indices[j][i] != -1
float optimize_one(const Vector4 *, const float *, int, int, int, float, const IntEndptsRGBA &, const RegionPrec &, IntEndptsRGBA &)
float map_colors(const Vector4 *, const float *, int, int, int, const IntEndptsRGBA &, const RegionPrec &, float, int (*)[16])
void emit_block(const IntEndptsRGBA *, int, const Pattern &, const int (*)[4][4], int, int, char *)
out.getptr() == 50
void write_header(const IntEndptsRGBA *, int, const Pattern &, int, int, Bits &)
(indices[((indexmode == INDEXMODE_ALPHA_IS_2BITS) ? 1 : 0)][0][0] & (1<<(2-1))) == 0
void write_indices(const int (*)[4][4], int, int, Bits &)
(indices[((indexmode == INDEXMODE_ALPHA_IS_3BITS) ? 1 : 0)][0][0] & (1<<(3-1))) == 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode5.cpp
void AVPCL::decompress_mode5(const char *, Tile &)
in.getptr() == 66
out.getptr() == 66
(indices[((indexmode == INDEXMODE_ALPHA_IS_3BITS) ? 1 : 0)][0][0] & (1<<(2-1))) == 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode6.cpp
void AVPCL::decompress_mode6(const char *, Tile &)
void read_header(Bits &, IntEndptsRGBA_2 *, int &, Pattern &, int &)
in.getptr() == 65
void compress_one(const IntEndptsRGBA &, IntEndptsRGBA_2 &)
float optimize_one(const Vector4 *, const float *, int, float, const IntEndptsRGBA_2 &, const RegionPrec &, IntEndptsRGBA_2 &)
void emit_block(const IntEndptsRGBA_2 *, int, const Pattern &, const int (*)[4], char *)
out.getptr() == 65
void write_header(const IntEndptsRGBA_2 *, int, const Pattern &, Bits &)
(indices[0][0] & (1<<(4-1))) == 0
void write_indices(const int (*)[4], int, Bits &)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode7.cpp
void AVPCL::decompress_mode7(const char *, Tile &)
compr_endpts.A[j] < 32
compr_endpts.B[j] < 32
void swap_indices(IntEndptsRGBA_2 *, int (*)[4], int)
denom == 3 || denom == 7 || denom == 15
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_utils.cpp
static int AVPCL::Utils::lerp(int, int, int, int, int)
i >= 0 && i <= denom
bias >= 0 && bias <= denom/2
a >= 0 && b >= 0
static Vector4 AVPCL::Utils::lerp(Vector4::Arg, Vector4::Arg, int, int, int)
prec > 3
static int AVPCL::Utils::unquantize(int, int)
static int AVPCL::Utils::quantize(float, int)
unq <= 255
q >= 0 && q < (1 << prec)
(R==r) && (A==a)
static float AVPCL::Utils::premult(float, float)
Dumping stacktrace:
s_sig_handler_enabled != true
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/Debug.cpp
void nv::debug::enableSigHandler(bool)
s_sig_handler_enabled == true
void nv::debug::disableSigHandler()
  In: '%s'
  In: [%s] '%s'
Got signal %d, faulty address is %p, from %p
Got signal %d, faulty address is %p
Breakpoint hit.
Got signal %d
*** Assertion failed: %s
    On file: %s
    On function: %s
    On line: %d
*** Assertion failed: %s
    On file: %s
    On line: %d
base >= 2
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/StrLib.cpp
StringBuilder &nv::StringBuilder::number(int, int)
base <= 36
StringBuilder &nv::StringBuilder::number(uint, int)
size_hint != 0
StringBuilder &nv::StringBuilder::reserve(uint)
s != __null
StringBuilder &nv::StringBuilder::copy(const char *)
StringBuilder &nv::StringBuilder::copy(const char *, uint)
s.m_size == 0
StringBuilder &nv::StringBuilder::copy(const StringBuilder &)
!isNull()
void nv::Path::appendSeparator(char)
m_str != __null
void nv::Path::stripFileName()
void nv::Path::stripExtension()
str != __null
static const char *nv::Path::fileName(const char *)
static const char *nv::Path::extension(const char *)
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
count < 0xFFFF
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/StrLib.h
void nv::String::setRefCount(uint16)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/TextWriter.cpp
nv::TextWriter::TextWriter(Stream *)
s->isSaving()
channel >= 0 && channel < 4
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/ColorBlock.cpp
void nv::AlphaBlock4x4::init(const ColorBlock &, uint)
(rmask & gmask) == 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/DirectDrawSurface.cpp
void nv::DDSHeader::setPixelFormat(uint, uint, uint, uint, uint)
(rmask & bmask) == 0
(rmask & amask) == 0
(gmask & bmask) == 0
(gmask & amask) == 0
(bmask & amask) == 0
bitcount > 0 && bitcount <= 32
Flags: 0x%.8X
Height: %d
Width: %d
Depth: %d
Pitch: %d
Linear size: %d
Mipmap count: %d
Flags: 0x%.8X
FourCC: '%c%c%c%c' (0x%.8X)
Swizzle: '%c%c%c%c' (0x%.8X)
Bit count: %d
Red mask:   0x%.8X
Green mask: 0x%.8X
Blue mask:  0x%.8X
Alpha mask: 0x%.8X
Caps 1: 0x%.8X
Caps 2: 0x%.8X
Caps 3: 0x%.8X
Caps 4: 0x%.8X
DXGI Format: %u (%s)
Resource dimension: %u (%s)
Misc flag: %u
Array size: %u
NVIDIA Texture Tools %d.%d.%d
User Version: %d
R32G32B32A32_TYPELESS
R32G32B32A32_FLOAT
R32G32B32A32_UINT
R32G32B32A32_SINT
R32G32B32_TYPELESS
R32G32B32_FLOAT
R32G32B32_UINT
R32G32B32_SINT
R16G16B16A16_TYPELESS
R16G16B16A16_FLOAT
R16G16B16A16_UNORM
R16G16B16A16_UINT
R16G16B16A16_SNORM
R16G16B16A16_SINT
R32G32_TYPELESS
R32G32_FLOAT
R32G32_UINT
R32G32_SINT
R32G8X24_TYPELESS
D32_FLOAT_S8X24_UINT
R32_FLOAT_X8X24_TYPELESS
X32_TYPELESS_G8X24_UINT
R10G10B10A2_TYPELESS
R10G10B10A2_UNORM
R10G10B10A2_UINT
R11G11B10_FLOAT
R8G8B8A8_TYPELESS
R8G8B8A8_UNORM
R8G8B8A8_UNORM_SRGB
R8G8B8A8_UINT
R8G8B8A8_SNORM
R8G8B8A8_SINT
R16G16_TYPELESS
R16G16_FLOAT
R16G16_UNORM
R16G16_UINT
R16G16_SNORM
R16G16_SINT
R32_TYPELESS
D32_FLOAT
R32_FLOAT
R32_UINT
R32_SINT
R24G8_TYPELESS
D24_UNORM_S8_UINT
R24_UNORM_X8_TYPELESS
X24_TYPELESS_G8_UINT
R8G8_TYPELESS
R8G8_UNORM
R8G8_UINT
R8G8_SNORM
R8G8_SINT
R16_TYPELESS
R16_FLOAT
D16_UNORM
R16_UNORM
R16_UINT
R16_SNORM
R16_SINT
R8_TYPELESS
R8_UNORM
R8_UINT
R8_SNORM
R8_SINT
A8_UNORM
R1_UNORM
R9G9B9E5_SHAREDEXP
R8G8_B8G8_UNORM
G8R8_G8B8_UNORM
BC1_TYPELESS
BC1_UNORM
BC1_UNORM_SRGB
BC2_TYPELESS
BC2_UNORM
BC2_UNORM_SRGB
BC3_TYPELESS
BC3_UNORM
BC3_UNORM_SRGB
BC4_TYPELESS
BC4_UNORM
BC4_SNORM
BC5_TYPELESS
BC5_UNORM
BC5_SNORM
B5G6R5_UNORM
B5G5R5A1_UNORM
B8G8R8A8_UNORM
B8G8R8X8_UNORM
BUFFER
TEXTURE1D
TEXTURE2D
TEXTURE3D
Pixel Format:
Caps:
Version:
DX10 Header:
DDSCAPS2_CUBEMAP
DDSCAPS2_CUBEMAP_NEGATIVEZ
DDSCAPS2_CUBEMAP_POSITIVEZ
DDSCAPS2_CUBEMAP_NEGATIVEY
DDSCAPS2_CUBEMAP_POSITIVEY
DDSCAPS2_CUBEMAP_NEGATIVEX
DDSCAPS2_CUBEMAP_POSITIVEX
DDSCAPS2_CUBEMAP_ALL_FACES
DDSCAPS2_VOLUME
DDSCAPS_MIPMAP
DDSCAPS_TEXTURE
DDSCAPS_COMPLEX
DDPF_NORMAL
DDPF_ALPHAPREMULT
DDPF_PALETTEINDEXED8
DDPF_PALETTEINDEXED4
DDPF_PALETTEINDEXED2
DDPF_PALETTEINDEXED1
DDPF_ALPHA
DDPF_ALPHAPIXELS
DDPF_FOURCC
DDPF_LUMINANCE
DDPF_RGB
DDSD_MIPMAPCOUNT
DDSD_LINEARSIZE
DDSD_PITCH
DDSD_DEPTH
DDSD_HEIGHT
DDSD_WIDTH
DDSD_PIXELFORMAT
DDSD_CAPS
%d: %f
m_windowSize == 3
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/Filter.cpp
void nv::Kernel2::initEdgeDetection()
m_windowSize == 9
void nv::Kernel2::initBlendedSobel(const Vector4 &)
%d: 
 %6.4f
img != __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/FloatImage.cpp
void nv::FloatImage::initFrom(const Image *)
num <= 4
Image *nv::FloatImage::createImage(uint, uint) const
baseComponent + num <= m_componentCount
m_componentCount == 4
Image *nv::FloatImage::createImageGammaCorrect(float) const
src < m_componentCount
void nv::FloatImage::copyChannel(uint, uint)
dst < m_componentCount
baseComponent + 3 <= m_componentCount
void nv::FloatImage::normalize(uint)
baseComponent + 4 <= m_componentCount
void nv::FloatImage::transform(uint, const Matrix &, Vector4::Arg)
void nv::FloatImage::swizzle(uint, uint, uint, uint, uint)
r < 7 && g < 7 && b < 7 && a < 7
alpha < m_componentCount
FloatImage *nv::FloatImage::resize(const Filter &, uint, uint, WrapMode, uint) const
FloatImage *nv::FloatImage::resize(const Filter &, uint, uint, uint, WrapMode, uint) const
right - left <= windowSize
void nv::FloatImage::applyKernelY(const PolyphaseKernel &, int, int, uint, WrapMode, float *, int) const
void nv::FloatImage::applyKernelZ(const PolyphaseKernel &, int, int, uint, WrapMode, float *) const
void nv::FloatImage::applyKernelY(const PolyphaseKernel &, int, int, uint, uint, WrapMode, float *, int) const
.tga
.ppm
.hdr
.dds
image != __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/ImageIO.cpp
bool nv::ImageIO::saveFloat(const char *, Stream &, const FloatImage *, uint, uint)
unknown image type
bad png sig
bad bits_per_channel
multiple IHDR
bad IHDR len
too large
1/2/4/8/16-bit only
bad ctype
bad comp method
bad filter method
bad interlace method
0-pixel image
first not IHDR
invalid PLTE
tRNS after IDAT
tRNS before PLTE
bad tRNS len
tRNS with alpha
no PLTE
outofmem
outofdata
no IDAT
bad zlib header
no preset dict
bad compression
zlib corrupt
read past buffer
output buffer limit
bad sizes
bad codelengths
bad huffman code
bad dist
not enough pixels
invalid filter
invalid width
unsupported
bad offset
invalid
bad bpp
bad masks
not BMP
bad BMP
unknown BMP
BMP RLE
BMP JPEG/PNG
bad Image Descriptor
missing color table
unknown code
not GIF
no clear code
too many codes
illegal code in raster
not PSD
wrong version
wrong channel count
unsupported bit depth
wrong color format
corrupt
PICT
bad file
bad format
no SOI
no SOF
expected marker
bad DRI len
bad DQT type
bad DQT table
bad DHT header
bad COM len
bad APP len
unknown marker
bad code lengths
bad SOF len
only 8-bit
no header height
0 width
bad component count
bad H
bad V
bad TQ
bad DNL len
bad DNL height
bad SOS component count
bad SOS len
bad DC huff
bad AC huff
bad SOS
can't merge dc and ac
max value > 65535
#?RADIANCE
#?RADIANCE
#?RGBE
not HDR
FORMAT=32-bit_rle_rgbe
unsupported format
unsupported data layout
invalid decoded scanline length
bad palette
!s.isError()
bool saveTGA(Stream &, const Image *)
img->pixels() != __null
mem == __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/TgaFile.h
void nv::TgaFile::allocate()
%d %d
s.isLoading()
FloatImage *loadFloatDDS(Stream &)
s.isSaving()
bool saveFloatDDS(Stream &, const FloatImage *, uint, uint)
p->name == __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvthread/Thread.cpp
void nv::Thread::setName(const char *)
thread pool
worker %d
bitCount <= 32
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/CompressionOptions.cpp
void nvtt::CompressionOptions::setPixelFormat(uint, uint, uint, uint, uint)
maxMask > rmask
maxMask > gmask
maxMask > bmask
maxMask > amask
rsize <= 32 && gsize <= 32 && bsize <= 32 && asize <= 32
void nvtt::CompressionOptions::setPixelFormat(uint8, uint8, uint8, uint8)
alphaThreshold >= 0 && alphaThreshold < 256
void nvtt::CompressionOptions::setQuantization(bool, bool, bool, int)
output_channel >= 0 && output_channel < 4
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/CompressorETC.cpp
void nv::decompress_eac(const void *, Vector4 *, int)
input_channel >= 0 && input_channel < 4
float nv::compress_eac(Vector4 *, float *, int, int, bool, void *)
data.mode == ETC_Data::Mode_ETC1
table_idx < 8
void get_diff_subblock_palette(uint16, uint, Color32 *)
bool get_diff_subblock_palette(uint16, uint16, uint, Color32 *)
void get_abs_subblock_palette(uint16, uint, Color32 *)
int get_partition(const ETC_Data &, int, int)
data.mode == ETC_Data::Mode_Planar
void decode_etc2_planar(const ETC_Data &, Vector4 *)
options.onebit_alpha == false
float compress_etc(Vector4 *, float *, const ETC_Options &, void *)
success
Vector3 unpack_color_555(uint32, uint32)
float compress_etc_a1(Vector4 *, float *, const ETC_Options &, void *)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/CompressorRGB.cpp
virtual void nv::PixelFormatConverter::compress(nvtt::AlphaMode, uint, uint, uint, const float *, nvtt::TaskDispatcher *, const nvtt::CompressionOptions::Private &, const nvtt::OutputOptions::Private &)
arraySize == 1
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/Context.cpp
bool nvtt::Compressor::Private::outputHeader(nvtt::TextureType, int, int, int, int, int, bool, const CompressionOptions::Private &, const OutputOptions::Private &) const
m_count == 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/RefCounted.h
virtual nv::RefCounted::~RefCounted()
m_count > 0
uint nv::WeakProxy::release() const
uint nv::RefCounted::release() const
i < deviceCount()
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/cuda/CudaUtils.cpp
bool nv::cuda::setDevice(int)
Unsupported block format, cannot decompress image data!
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/Surface.cpp
bool nvtt::Surface::load(const char *, bool *)
bool nvtt::Surface::save(const char *, bool, bool) const
image resized %dx%d -> %dx%d (error=%f)
image can't be resized further (error=%f)
Unspecified error code
No error detected
Error (generic)
Unknown frame descriptor
Version not supported
Unsupported frame parameter
Frame requires too much memory for decoding
Corrupted block detected
Restored data doesn't match checksum
Unsupported parameter
Parameter is out of bound
Context should be init first
Allocation error : not enough memory
workSpace buffer is not large enough
Operation not authorized at current processing stage
tableLog requires too much memory : unsupported
Unsupported max Symbol Value : too large
Specified maxSymbolValue is too small
Dictionary is corrupted
Dictionary mismatch
Cannot create Dictionary from provided samples
Destination buffer is too small
Src size is incorrect
Operation on NULL destination buffer
Frame index is too large
An I/O error occurred when reading/seeking
Destination buffer is wrong
Source buffer is wrong
1.4.9
WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at least 10x, and preferably 100x the size of the dictionary! 
Cover parameters incorrect
Cover must have at least one input file
dictBufferCapacity must be at least %u
Failed to allocate dmer map: out of memory
Building dictionary
Constructed dictionary of size %u
Incorrect parameters
Trying %u different sets of parameters
d=%u
Failed to initialize context
k=%u
Failed to allocate parameters
%u%%       
%79s
FASTCOVER parameters incorrect
FASTCOVER must have at least one input file
Incorrect splitPoint
Incorrect accel
Incorrect k
%70s
statistics ... 
Total samples size is too large (%u MB), maximum size is %u MB
Total number of training samples is %u and is invalid.
Total number of testing samples is %u and is invalid.
Training on %u samples of total size %u
Testing on %u samples of total size %u
Failed to allocate scratch buffers
Constructing partial suffix array
Computing frequencies
Breaking content into %u epochs of size %u
Failed to allocate buffers: out of memory
Failed to select dictionary
Total number of training samples is %u and is invalid
Total number of testing samples is %u and is invalid.
Failed to allocate scratch buffers 
Failed to allocate frequency table 
Not enough memory 
 HUF_buildCTable error 
warning : pathological dataset : literals are not compressible : samples are noisy or too regular 
FSE_normalizeCount error with offcodeCount 
FSE_normalizeCount error with matchLengthCount 
FSE_normalizeCount error with litLengthCount 
HUF_writeCTable error 
FSE_writeNCount error with offcodeNCount 
FSE_writeNCount error with matchLengthNCount 
FSE_writeNCount error with litlengthNCount 
not enough space to write RepOffsets 
warning : ZSTD_compressBegin_usingCDict failed 
warning : could not compress sample size %u 
 %u segments found, of total size %u 
list %u best segments 
%3u:%3u bytes at pos %8u, savings %7u bytes |
!  warning : selected content significantly smaller than requested (%u < %u) 
!  consider increasing the number of samples (total size : %u MB)
!  consider increasing selectivity to produce larger dictionary (-s%u) 
!  note : larger dictionaries are not necessarily better, test its efficiency on samples 
!  note : calculated dictionary significantly larger than requested (%u > %u) 
!  consider increasing dictionary size, or produce denser dictionary (-s%u) 
!  always test dictionary efficiency on real samples 
sample set too large : reduced to %u MB ...
sorting %u files of total size %u MB ...
finding patterns ... 
minimum ratio : %u 
%4.2f %% 
found %3u matches of length >= %i at pos %7u  
Selected dict at position %u, of length %u : saves %u (ratio: %.2f)  
KTXorientation
S=%c,T=%c,R=%c
KTXanimData
 / libktx 
Unidentified app
__default__
v4.0.__default__
v4.0
KTXcubemapIncomplete
KTXglFormat
KTXdxgiFormat__
KTXmetalPixelFormat
KTXswizzle
KTXwriterScParams
KTXastcDecodeMode
00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899
]xEc
vH7B
W4vC
MbP?-C
]r2<
 9^;
cZK;#
%9)0
GTg8^
v?8i
-(;aU,$
G#]X
Q)b9
z@c"J
BN$N(
s\a=
$qE}
#a%
10WriterNull
@10Compressor
11NonCopyable
N12_GLOBAL__N_113AssertHandlerE
N2nv13AssertHandlerE
12Decompressor
N12_GLOBAL__N_113AssertHandlerE
6Writer
N4nvtt13OutputHandlerE
9BaseImage
NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
11BaseSurface
817UncompressedImage
C19UncompressedSurface
33s?
@ity=
compression_qualcompression_quality=
9WriterDds
17CompressedSurface
15CompressedImage
N2nv9StdStreamE
N2nv6StreamE
KTX 11
KTX 11
9WriterKtx
10WriterKtx2
2.0.160003
17DecompressorMetal
NSt3__117bad_function_callE
13CompressorArm
15DecompressorArm
B18CompressorEtc2Comp
14CompressorIspc
14CompressorNvtt
N4nvtt24SequentialTaskDispatcherE
N4nvtt14TaskDispatcherE
16DecompressorNvtt
=333333
?333333
?333333
15CompressorPvrtc
17DecompressorPvrtc
@13CompressorStb

   !! "
!!!""!$
"""##"%
###$$#$$$$$%%$%%%%%&&%&&&&&''&'''''(('((((())()))))**)*****++*(0+++,,+)1,,,--,+0---..-,1...//..0///00.0/1.0001102/1112214.2223325/333443444445545555566566666776777778878888899899999::9:::::;;:;;;;;<<;<<<<<==<=====>>=>>>>>??>????
?%!!?
9?JBB?
Z?^cc?
<?BAA?
UUU?UUU?UUU?UUU?UUU?UUU?UUU?UUU?
UUU?UUU?UUU?UUU?UUU?UUU?UUU?UUU?
?/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:771:5: Assertion failed: bits>=2 && bits<=4 
PPPP@@@@TTTT@PPT
@@PPTTU@PTU
@PPTUU
@T@TUU
TPP@P@@
DDDD
PPAT
UPPPPU
TTPPh
@PZj
UUPPZZ
@@jj
$$$$
P(i(iD
fffDDD
TRJ*33
33DD
0033
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1072:2: Assertion failed: bits >= 4 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1163:2: Assertion failed: mode <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1183:3: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1163:2: Assertion failed: mode <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1183:3: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1189:5: Assertion failed: mode <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1215:3: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1189:5: Assertion failed: mode <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1215:3: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1280:3: Assertion failed: best_q>=0 && best_q<=levels-1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1280:3: Assertion failed: best_q>=0 && best_q<=levels-1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1799:2: Assertion failed: (qblock[0]&15) < levels/2 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1799:2: Assertion failed: (qblock[0]&15) < levels/2 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1831:2: Assertion failed: v<pow2(bits) 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1831:2: Assertion failed: v<pow2(bits) 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1844:3: Assertion failed: from > 64+10 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1951:13: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1951:13: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2203:5: Assertion failed: span > 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2217:5: Assertion failed: mode_bits > 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2482:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2482:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2502:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 15 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2503:13: Assertion failed: -16 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2554:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 31 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2555:13: Assertion failed: -32 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2627:13: Assertion failed: qep[i * 4 + p] - qep[p] <= (1<<bits)/2 - 1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2628:13: Assertion failed: -(1<<bits)/2 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2738:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 15 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2739:13: Assertion failed: -16 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2810:13: Assertion failed: qep[i * 4 + p] - qep[p] <= (1<<bits)/2 - 1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2811:13: Assertion failed: -(1<<bits)/2 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2971:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 255 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2972:13: Assertion failed: -256 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3008:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 127 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3009:13: Assertion failed: -128 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3045:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3046:13: Assertion failed: -8 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3072:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2502:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 15 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2503:13: Assertion failed: -16 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2554:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 31 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2555:13: Assertion failed: -32 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2627:13: Assertion failed: qep[i * 4 + p] - qep[p] <= (1<<bits)/2 - 1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2628:13: Assertion failed: -(1<<bits)/2 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2738:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 15 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2739:13: Assertion failed: -16 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2810:13: Assertion failed: qep[i * 4 + p] - qep[p] <= (1<<bits)/2 - 1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2811:13: Assertion failed: -(1<<bits)/2 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2971:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 255 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2972:13: Assertion failed: -256 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3008:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 127 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3009:13: Assertion failed: -128 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3045:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3046:13: Assertion failed: -8 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3072:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3356:9: Assertion failed: best_q >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3356:9: Assertion failed: best_q >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3493:9: Assertion failed: idx < 165 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3493:9: Assertion failed: idx < 165 
3333333333333333@
UUU?
'7VU
 Ef$ 
e!@t
e\!Ptl!
%At#%Bt3%CtC%DsS%Enc%Fis%Gf
q+'Pt;'QjK'
)DT$)EO4)FKD)GHT)
+PT,+QL<+
H|+ T
1DT#1ET31FRC1GOS1HKc1IHs1JE
3BJ+3
G[4 Tk4!T{4"Q
j"6At26BtB6CtR6Dtb6Etr6Fr
g:8@tJ8ArZ8Bjj8
9Qr*9Rj:9
Sr;AT
<KK"<
>CM*>DH:>
E:?PTJ?QTZ?RRj?SMz?TH
E*@ T:@!TJ@"TZ@#Tj@$Nz@%E
CF4$CG34CH/DCI,TCJ*dCK&tC
',E@4<EA4LEB.\EC(lE
'<FP4LFQ4\FR.lFS(|F
F 4G!4
G"4,G#.<G$'LG`4\Ga4lGb.|Gc(
PH4#PI33PJ1CPK.SP
R@4+RA4;RB4KRC/[RD+kRE%{R
Ub4+Uc/;Ud+KUe%[U
taWAtqWBt
ZDk)ZEe9Z
jI[PtY[Qti[Rty[So
gY\ ti\!ty\"t
_B4"_C42_D4B_E4R_F4b_G4r_H4
e 4*e!4:e"4Je#4Ze$4je%4ze&1
fg'*f
iGT!iHT1iITAiJTQiKTai
E9k@TIkATYkBTikCTykDS
EImPTYmQTimRTymST
o%T)o&Q9o'LIo(EYo`TioaTyobT
4QrD4arE4qrF4
uJ))uK%9u
*9wQ4IwR4YwS4iwT4ywU4
%9y!4Iy"4Yy#4iy$4yy%4
zd4)ze49zf4Izg2Yzh.izi+yzj)
80?e
46=A
>r1F
>r1F
OyL?
295<295<
OyL?
_'?UM0
qo=UM0
_'?E,N?I
$H%?
$H%?
E,N?
<=2V
F"t=
A?~p^
7=~p^
A?F"t=
.R?z
;ge{
ek?;
C{;5{
s=Q/x
=ge{
Q/x=
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:570:5: Assertion failed: n <= 16 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:591:13: Assertion failed: e <= n 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:570:5: Assertion failed: n <= 16 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:591:13: Assertion failed: e <= n 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:609:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:609:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1247:5: Assertion failed: state->fastSkipTreshold <= 64 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1286:5: Assertion failed: count >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1247:5: Assertion failed: state->fastSkipTreshold <= 64 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1286:5: Assertion failed: count >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1247:5: Assertion failed: state->fastSkipTreshold <= 64 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1286:5: Assertion failed: count >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1988:5: Assertion failed: pitch <= 64 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1988:5: Assertion failed: pitch <= 64 
 !"#$%&'()*+,-./0123456789:;<=>?
>(knN
Q8=q=
oa^[
u>{r1?
?fff?
?fff?
?33s?
?fff?
 A33
?33s?
?fff?
 Aff
p}?NSt3__110__function6__funcIZ22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmjE3$_0NS_9allocatorISA_EEFjvEEE
NSt3__110__function6__baseIFjvEEE
Z22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmjE3$_0
NSt3__110__function6__funcIZ22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmjE3$_1NS_9allocatorISA_EEFvvEEE
NSt3__110__function6__baseIFvvEEE
Z22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmjE3$_1
w8#w
 !"$%&()*01245689:#'/37;,-.@ABDEFHIJPQRTUVXYZCGOSW[LMN
`abdefhijpqrtuvxyzcgosw{lmn
<=>\]^
 !"#$()*+,0123489:;<%-5=
@ABCDHIJKLPQRSTXYZ[\EMU]
`abcdhijklpqrstxyz{|emu}
fgFG&noNO.vwVW6~
^_>'/7?
((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((2
##############################----------------------------------------------------------------------------------------------------------------7
CrQjRjAZSJQ
B8R8S8C03
*B"Q"
2A*B
RTCD
OOwB
"b Q
lb,O
aysqSiCYAK
q"sH![
,!.R,3|
ry_p
hbaSYnXaMRsYC
3!+.
"C]"1#q"
r`B9m8
wbl3
.n7B$m
,"%Ql
aSarQ
QGPC
IFHbI7
0%Ra*
!q"!Cs8
RE05HR
*Q#%
2UQ%
5b
_8SAC9bA78G8sq
1HiF0
2v0M*
Xn0$)a*
POp!
+%"s(eH
q"E(-
4QERdb\
%B,r
5q
X4eZP
S4Q$U
HKP~HDS
qyh9C1
1_8S1n070
0b1O0u0;
(sQsP
)J z F HA
#D9e $
Q2I 
%3<R
]>4
=#
uPGHSQUI
F@7@
a61v0s1
@7A!;
#e %
Q%R5I
3DC<5l
XFY(YtQoX
1v870U)
)'0~(
+G(b1sQ6I_(
 &!HAn 
!e!!S
R5<"-
fxd{
yuyjh
ta(a
aT[cQV
kK8H9S1Z841
`sYv0
(a2u(
 $-n _(
 6)G@7 
' O@F8
9sHU
2-QU
'.#
Bq
adcuQD]fX
ITSt
@cIJA
9rA~8Z@
1V0+)F1'1
hn(s!b)
 O@S!C)
 6!;
#u K
]tQM
$/B<#
(qdct
4]fXuYTS
IyAc
hV0F1
1H1aZ
H8HS) C)s!
!+!!
"'!s
(z +
]<><
{(qtyyadk
ij`$gD
ITHo
@aBd@~@Z8
2H1_0S)
0C)
(+Ib)n(
)s!'!
b,!.
d}34
->q
TQM]D1
E333?
Iy^!I)>
H.yrH&3
F9'gF$y
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIImmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
88888888888888888888888888888888888888888888888888888888TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
..............................................EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ttttttttttttttttttttttttttttttttttttttttttttttt
""""""""""""""""""""""""""""""""""3333333333333333333333333333333333DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUffffffffffffffffffffffffffffffffffwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
(((((((((((((((((((((((((((666666666666666666666666666CCCCCCCCCCCCCCCCCCCCCCCCCCPPPPPPPPPPPPPPPPPPPPPPPPPPP^^^^^^^^^^^^^^^^^^^^^^^^^^^kkkkkkkkkkkkkkkkkkkkkkkkkkkyyyyyyyyyyyyyyyyyyyyyyyyyyy
!!!!!!!!!!!!!!!!!!!!!!,,,,,,,,,,,,,,,,,,,,,,7777777777777777777777BBBBBBBBBBBBBBBBBBBBBBMMMMMMMMMMMMMMMMMMMMMMXXXXXXXXXXXXXXXXXXXXXXccccccccccccccccccccccnnnnnnnnnnnnnnnnnnnnnnyyyyyyyyyyyyyyyyyyyyyyyy
!!!!!!!!!!!!!!!!!))))))))))))))))111111111111111199999999999999999BBBBBBBBBBBBBBBBBJJJJJJJJJJJJJJJJRRRRRRRRRRRRRRRRZZZZZZZZZZZZZZZZZccccccccccccccccckkkkkkkkkkkkkkkkssssssssssssssss{{{{{{{{{{{{{{{{{
             '''''''''''''-------------4444444444444:::::::::::::AAAAAAAAAAAAAGGGGGGGGGGGGGNNNNNNNNNNNNNTTTTTTTTTTTTT[[[[[[[[[[[[[aaaaaaaaaaaaahhhhhhhhhhhhhnnnnnnnnnnnnnuuuuuuuuuuuuu{{{{{{{{{{{{{{{
           &&&&&&&&&&&++++++++++0000000000066666666666;;;;;;;;;;;AAAAAAAAAAAFFFFFFFFFFFLLLLLLLLLLLQQQQQQQQQQVVVVVVVVVVV\\\\\\\\\\\aaaaaaaaaaagggggggggggllllllllllqqqqqqqqqqqwwwwwwwwwww||||||||||||

        $$$$$$$$((((((((,,,,,,,,000000004444444488888888<<<<<<<<<AAAAAAAAAEEEEEEEEIIIIIIIIMMMMMMMMQQQQQQQQUUUUUUUUYYYYYYYY]]]]]]]]aaaaaaaaeeeeeeeeiiiiiiiimmmmmmmmqqqqqqqquuuuuuuuyyyyyyyy}}}}}}}}}
      ######&&&&&&&*******------0000003333336666666:::::::======@@@@@@CCCCCCCGGGGGGGJJJJJJMMMMMMPPPPPPSSSSSSSWWWWWWWZZZZZZ]]]]]]```````dddddddggggggjjjjjjmmmmmmppppppptttttttwwwwwwzzzzzz}}}}}}}}
      #####%%%%%((((((+++++-----0000003333355555888888;;;;;=====@@@@@@CCCCCCFFFFFHHHHHKKKKKKNNNNNPPPPPSSSSSSVVVVVXXXXX[[[[[[^^^^^`````ccccccfffffhhhhhkkkkkknnnnnpppppssssssvvvvvxxxxx{{{{{{~~~~~~

    """"$$$$&&&&((((****,,,,....00002222444466668888::::<<<<>>>>@@@@BBBBDDDDFFFFHHHHJJJJLLLLNNNNPPPPRRRRTTTTVVVVXXXXZZZZ\\\\^^^^````bbbbddddffffhhhhjjjjllllnnnnpppprrrrttttvvvvxxxxzzzz||||~~~~~
   !!!###$$$&&&&((()))+++,,,....0001113334446666888999;;;<<<>>>>@@@AAACCCDDDFFFFHHHIIIKKKLLLNNNNPPPQQQSSSTTTVVVVXXXYYY[[[\\\^^^^```aaacccdddffffhhhiiikkklllnnnnpppqqqssstttvvvvxxxyyy{{{|||~~~~~
   !!"""$$$%%&&&((())***,,,--...000112224445566688899:::<<<==>>>@@@AABBBDDDEEFFFHHHIIJJJLLLMMNNNPPPQQRRRTTTUUVVVXXXYYZZZ\\\]]^^^```aabbbdddeefffhhhiijjjlllmmnnnpppqqrrrtttuuvvvxxxyyzzz|||}}~~~~
  !!""##$$%%&&''(())**++,,--..//00112233445566778899::;;<<==>>??@@AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ[[\\]]^^__``aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~




       
"""""""

$$$$$$$
&&&&&&&&''''''''
%%%%%%%
#######
!!!!!!!
      
""""""
$$$$$
&&&&&&
((((((
******
,,,,,
......//////
-----
++++++
))))))
''''''
%%%%%
######
!!!!!!

    !!!!""""####$$$$%%%%&&&&''''(((())))****++++,,,,----..../////0000111122223333444455556666777788889999::::;;;;<<<<====>>>>???
   000@@@@
"""222BBBB
$$$4444DDD
&&&6666FFF
((((888HHH
****:::JJJ
,,,<<<LLL
...>>>NNNNOOOO???///
MMM===---
KKK;;;++++
III999))))
GGG7777'''
EEE5555%%%
CCCC333###
AAAA111!!!
   @@@
"""BBB
$$$DDD
&&&FFF
((HHH
**JJJ,,LLL
..NNN
000PPP
222RRR
444TTT
666VVV
888XXX
:::ZZZ
<<<\\\
>>>^^^___???
]]]===
[[[;;;
YYY999
WWW777
UUU555
SSS333
QQQ111
OOO//
MMM--
KKK++
III))
GGG'''
EEE%%%
CCC###
AAA!!!
  !!""##$$%%&&''(())**++,,--..//00112233445566778899::;;<<==>>???@@AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ[[\\]]^^__``aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~
 @@`
"BBb
$DDd
&FFf
(HHh
*JJj
,LLl
.NNn
0PPp
2RRr
4TTt
6VVv
8XXx
:ZZz
<\\|
>^^~
}]]=
{[[;
yYY9
wWW7
uUU5
sSS3
qQQ1
oOO/
mMM-
kKK+
iII)
gGG'
eEE%
cCC#
aAA!
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
"3DUfw
!)19BJRZcks{
 $(,048<AEIMQUY]aeimquy}
 "$&(*,.02468:<>@BDFHJLNPRTVXZ\^`bdfhjlnprtvxz|~
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~




????????????????
%.7@
%.7@
$+29@
$)/5;@
#'+/48<@
#'+/48<@
#&)-037:=@
"%(*-0358;>@
"$&(*,.02468:<>@
"$&(*,.02468:<>@
@NSt3__120__shared_ptr_pointerIPhZN3Etc13EncodeMipmapsEPfjjNS2_5Image6FormatENS2_11ErrorMetricEfjjjjPNS2_8RawImageEPibE3$_0NS_9allocatorIhEEEE
ZN3Etc13EncodeMipmapsEPfjjNS_5Image6FormatENS_11ErrorMetricEfjjjjPNS_8RawImageEPibE3$_0
@@NSt3__119__async_assoc_stateIvNS_12__async_funcIMN3Etc5ImageEFvjjEJPS3_ijEEEEE
NSt3__119__async_assoc_stateIjNS_12__async_funcIMN3Etc5ImageEFjjjjEJPS3_jijEEEEE
NSt3__113__assoc_stateIjEE
?N3Etc16Block4x4EncodingE
N3Etc21Block4x4Encoding_ETC1E
N3Etc20Block4x4Encoding_R11E
N3Etc21Block4x4Encoding_RG11E
N3Etc21Block4x4Encoding_RGB8E
N3Etc23Block4x4Encoding_RGB8A1E
N3Etc30Block4x4Encoding_RGB8A1_OpaqueE
N3Etc35Block4x4Encoding_RGB8A1_TransparentE
GB33
?N3Etc22Block4x4Encoding_RGBA8E
N3Etc29Block4x4Encoding_RGBA8_OpaqueE
N3Etc34Block4x4Encoding_RGBA8_TransparentE
N12_GLOBAL__N_117UnixAssertHandlerE
Qs?K\
Qs?K\
?UUU
?N2nv6FilterE
N2nv9BoxFilterE
N2nv14TriangleFilterE
N2nv15QuadraticFilterE
N2nv11CubicFilterE
N2nv13BSplineFilterE
N2nv14MitchellFilterE
N2nv13LanczosFilterE
N2nv10SincFilterE
N2nv12KaiserFilterE
N2nv14GaussianFilterE
32-bit_rle_rgbe
FORMAT=32-bit_rl
N2nv14StdInputStreamE
!(0)"
#*1892+$
%,3:;4-&
'.5<=6/7>????????????????RGB
N2nv15StdOutputStreamE
KTX 11
8D`?8D`?8D`?8D`?
<-\4
8D`?
F#DS
]p$o
S%'1
F(DS
]p)o
S*'1
F-DS
]p.o
S/'1
F2DS
]p3o
S4'1
F7DS
]p8o
S9'1
F<DS
]p=o
S>'1
FADS
]pBo
SC'1
FFDS
]pGo
SH'1
FKDS
]pLo
SM'1
FPDS
]pQo
SR'1
FUDS
]pVo
SW'1
FZDS
]p[o
N2nv20ColorBlockCompressorE
N2nv19CompressorInterfaceE
N2nv20FloatColorCompressorE
N2nv14CompressorDXT1E
N2nv18CompressorBC3_RGBME
N2nv14CompressorETC1E
N2nv16CompressorETC2_RE
N2nv17CompressorETC2_RGE
N2nv18CompressorETC2_RGBE
N2nv19CompressorETC2_RGBAE
N2nv19CompressorETC2_RGBME
DXT1DXT1DXT3DXT5DXT5ATI1ATI2DXT1
BC6HBC7LDXT5ETC1
ETC2
PVR0PVR1PVR2PVR3
N2nv17FastCompressorBC4E
N2nv17FastCompressorBC5E
N2nv23ProductionCompressorBC4E
N2nv23ProductionCompressorBC5E
N2nv13CompressorBC6E
N2nv13CompressorBC7E
N2nv19FastCompressorDXT1aE
N2nv18FastCompressorDXT3E
N2nv18FastCompressorDXT5E
N2nv19FastCompressorDXT5nE
N2nv15CompressorDXT1aE
N2nv19CompressorDXT1_LumaE
N2nv14CompressorDXT3E
N2nv14CompressorDXT5E
N2nv15CompressorDXT5nE
?%!!?
9?JBB?
Z?^cc?
~GN2nv20PixelFormatConverterE
N4nvtt22ParallelTaskDispatcherE
N4nvtt11CubeSurface7PrivateE
!)19BJRZcks{
 $(,048<AEIMQUY]aeimquy}
?%!!?
9?JBB?
Z?^cc?
<?BAA?
@N4nvtt20DefaultOutputHandlerE
.M;R
NAvT
?N4nvtt7Surface7PrivateE
N2nv10RefCountedE
N8nvsquish9ColourFitE
c>N8nvsquish18WeightedClusterFitE
  !!""##$$$$%%%%&&&&&&&&''''''''(((((((((((((((())))))))))))))))********************************
\ww_,
zk&_
~NX4
_H^zvd
x`tm6
Sr]?
$8'S
$ffn
rq7x;P
)n/h%fPn
,!MbDg[
>ZF9
rT+6ZNw
izc}
Nl9\
x=9v
"f^n[
5nsfZ
^[L6
Vgh$
2aNuE
BTcq
2,THh
/fxLf
]k_W
Z/K]
(U$;s
hm~iD
KTX 11
KTX 20
KTX 11
KTX 20
KTX 11
KTX 20
KTX 20
XXXX PNG chunk not known
Failed to convert texture
Failed to load texture
Images are identical
Images differ. RMS:%.2f MSE:%.2f PSNR:%.2f
Examining %s
File Not Found!
basic_string
vector
com.apple.TextureConverter.compress
version
compressor
format
options
^v8@?0
atcFormatUnknown
atcFormatR8Unorm
atcFormatR16F16
atcFormatR32F32
atcFormatRg8Unorm
atcFormatRg16F16
atcFormatRg32F32
atcFormatRgb8Unorm
atcFormatRgb16F16
atcFormatRgb32F32
atcFormatRgba8Unorm
atcFormatRgba16F16
atcFormatRgba32F32
atcFormatBgra8Unorm
atcFormatBc1Unorm
atcFormatBc2Unorm
atcFormatBc3Unorm
atcFormatBc4Snorm
atcFormatBc4Unorm
atcFormatBc5Snorm
atcFormatBc5Unorm
atcFormatBc6Sf16
atcFormatBc6Uf16
atcFormatBc7Unorm
atcFormatAstc4x4Unorm
atcFormatAstc4x4F16
atcFormatAstc5x4Unorm
atcFormatAstc5x4F16
atcFormatAstc5x5Unorm
atcFormatAstc5x5F16
atcFormatAstc6x5Unorm
atcFormatAstc6x5F16
atcFormatAstc6x6Unorm
atcFormatAstc6x6F16
atcFormatAstc8x5Unorm
atcFormatAstc8x5F16
atcFormatAstc8x6Unorm
atcFormatAstc8x6F16
atcFormatAstc8x8Unorm
atcFormatAstc8x8F16
atcFormatAstc10x5Unorm
atcFormatAstc10x5F16
atcFormatAstc10x6Unorm
atcFormatAstc10x6F16
atcFormatAstc10x8Unorm
atcFormatAstc10x8F16
atcFormatAstc10x10Unorm
atcFormatAstc10x10F16
atcFormatAstc12x10Unorm
atcFormatAstc12x10F16
atcFormatAstc12x12Unorm
atcFormatAstc12x12F16
atcFormatEacR11Snorm
atcFormatEacR11Unorm
atcFormatEacRg11Snorm
atcFormatEacRg11Unorm
atcFormatEacRgba8Unorm
atcFormatEtc2Rgb8Unorm
atcFormatEtc2Rgb8A1Unorm
atcFormatPvrtcRgb2BppUnorm
atcFormatPvrtcRgb4BppUnorm
atcFormatPvrtcRgba2BppUnorm
atcFormatPvrtcRgba4BppUnorm
atcFormatBc1Srgb
atcFormatBc2Srgb
atcFormatBc3Srgb
atcFormatBc7Srgb
atcFormatEacRgba8Srgb
atcFormatEtc2Rgb8Srgb
atcFormatEtc2Rgb8A1Srgb
atcFormatPvrtcRgb2BppSrgb
atcFormatPvrtcRgb4BppSrgb
atcFormatPvrtcRgba2BppSrgb
atcFormatPvrtcRgba4BppSrgb
atcFormatAstc4x4Srgb
atcFormatAstc5x4Srgb
atcFormatAstc5x5Srgb
atcFormatAstc6x5Srgb
atcFormatAstc6x6Srgb
atcFormatAstc8x5Srgb
atcFormatAstc8x6Srgb
atcFormatAstc8x8Srgb
atcFormatAstc10x5Srgb
atcFormatAstc10x6Srgb
atcFormatAstc10x8Srgb
atcFormatAstc10x10Srgb
atcFormatAstc12x10Srgb
atcFormatAstc12x12Srgb
Unknown pixel format
KTX2
Error: options == nullptr
Error: invalid options->format - %s
Error: invalid options->format - %i
Error: invalid gammaIn - %f
Error: invalid gammaOut - %f
Error: invalid rgbmRange - %f
Error: invalid compression format - %s
Error: invalid compression format - %i
Error: invalid compressor - %i
Error: invalid quality - %i
Error: invalid alphaMode - %i
Error: invalid alphaMode - %f
Error: invalid channelWeighting - %i
Error: invalid maxMipmaps - %i, maximum is 
Error: invalid mipmapFilter - %i
Error: invalid maxExtent - %i, maximum is 
Error: invalid resizeRoundMode - %i
Error: invalid resizeFilter - %i
Error: invalid wrapMode - %i
Error: invalid pvrtcPunchThroughMode - %i
Error: invalid decompression format - %s
Error: invalid decompression format - %i
Error: invalid decompressor - %i
Error: %s == nullptr
Error: invalid %s width - 0
Error: invalid %s height - 0
Error: invalid %s numMipLevels - %i, should be in range 1-%i 
Error: invalid %s type - %i
Error: invalid %s->format - %u
Error: invalid %s.surface[%i][%i].width - %i, should be %i or 0
Error: invalid %s.surface[%i][%i].height - %i, should be %i or 0
Error: invalid %s.surface[%i][%i].rowBytes - %i, should be >= %i or 0
Error: invalid %s.surface[%i][%i].size - %i, should be >= %i
Error: invalid %s.surface[%i][%i].data - NULL
Error: destTex == nullptr
Error: ATC_Context should set both memoryAllocator & memoryDeallocator, or neither.
sourceTex
Error: invalid sourceTex format - %s
Error: invalid sourceTex format - %i
Error: invalid fileFormat - %i
ATC_Decompress: Unsupported destination format: %s
refTex
compTex
false
TextureConverter %s
Usage: %s%s Arguments...
 [Options]
=value
Options:
--%s
 (default: "
Widths Differ: (%d != %d)
Heights Differ: (%d != %d)
Depths Differ: (%d != %d)
Texture Typed Differ: (%d != %d)
NumFaces Differ: (%d != %d)
NumMipmaps Differ: (%d != %d)
0123456789abcdefxp
0123456789ABCDEFXP
null
_KMGT
_kMGT
Error: 
Warning: 
----------
Progress [%s] %.0f%%
Progress [
] %.0f%%
Auto
Compressor info is not available for the atcCompressorAuto compressor
Compression info is not available for the selected compressor (%i)
Unsupported auto compression format: "
Using Compressor: %s
Compression format is not supported by the selected compressor
Output texture is more recent than the input texture
 but
Output texture
 was compressed with an older version of TextureConverter
 and
 compression options are compatible
%s, skipping.
Compressing mipmap level %d/%d for face %d/%d (width: %d, height: %d, depth: %d)...
Compressing mipmap level %d/%d (width: %d, height: %d, depth: %d)...
 RMS: %.2f, MSE: %.2f, PSNR: %.2f
Processing time: %.2fms (%.2f MPix/s)
RMS: %.2f, MSE: %.2f, PNSR: %.2f
, line 
, NVTT assertion failed "
Unsupported auto decompression format: (%s)
Compression format (%s) is not supported by the selected decompressor
Unsupported decompressed texture type
KTXwriter
Size:   
 mip-levels
Format: 
Compressed with TextureConverter: 
Compression options: 
Image content is uniform, resized image from (w: %d, h: %d, d: %d) to (w: %d, h: %d, d: %d)!
Resized image to (width: %d, height: %d, depth: %d)
fileName != __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/StdStream.h
FILE *nv::fileOpen(const char *, const char *)
alpha_mode
alpha_reference
alpha_to_coverage
alpha_weight
channel_weighting
check_date
check_details
compare
compression_format
compression_quality
crop_uniform_content
decompressor
decompressed
decompression_format
disable_annotation
disable_multithreading
file_format
flip_x
flip_y
flip_z
gamma_out
max_extent
max_mipmaps
mipmap_filter
normal_map
output
progressbar
pvrtc_punch_through
metrics
resize_filter
resize_round_mode
rgbm_encoding
rgbm_range
scale_range
srgb_format
verbose
wrap_mode
Ignore
Premultiply
PVRTC
Decompress
Compare
Examine
Kaiser
Fastest
Highest
Normal
Production
NearestMultipleOfFour
NearestPowerOfTwo
NextMultipleOfFour
NextPowerOfTwo
PreviousMultipleOfFour
PreviousPowerOfTwo
Clamp
Mirror
Repeat
Allowed
Forced
Unused
Linear
Perceptual
Compression format is not supported by the selected decompressor
Use alpha to coverage
Use alpha weight when compressing
Decode KTX ASTC images as HDR
Crop images with uniform content
Disable KTX file annotation
Disable multithreading
Flip image along x-axis
Flip image along y-axis
Flip image along z-axis
Treat image as normal map
Display progress bar
Report error metrics
Use RGBM encoding
Scale image to entire color range
Use sRGB pixel format
Output processing time in milliseconds
Verbose output
Compare the date/time of the source file to the output file (if present) & skip compression if the output file is newer. Can be combined with --
Compare the compression options and TextureConverter version against the output file (if present) & skip compression if not needed. Only supported for KTX files. Can be combined with --
Alpha reference for alpha to coverage
Range for RGBM encoding
Maximum image extent
Maximum number of mipmaps
Alpha mode
ETCPACK/PVRTC channel weighting
Compression format
Compression quality
Compressor library
Decompressor library
Decompression format
Gamma for input image, "
" or float value
Gamma for output texture, "
Filter for mipmap generation
Operation mode
File format
Output file path
Decompressed file path
Comparison file path
PVRTC punch through mode
Resize filter
Resize round mode
Wrap mode
TextureConverter
Usage options:
       TextureConverter --h : Detailed Usage
       TextureConverter -h  : TextureTool Compatibility Mode Usage
Missing input file path
Unsupported number of arguments
Unsupported mode "
Unsupported compression format "
Unsupported compression quality "
Unsupported compressor "
Unsupported file format "
Unsupported alpha mode
Unsupported mipmap filter "
Unsupported resize filter "
Unsupported resize round mode "
Unsupported wrap mode "
Unsupported ETCPACK/PVRTC channel weighting mode "
Unsupported PVRTC punch through mode "
The value for the RGBM range must be greater than or equal to 1.0
Compressors
Decompressors
ARM compression formats
ETC2COMP compression formats
ISPC compression formats
NVTT compression formats
PVRTC compression formats
STB compression formats
Input file formats
Output file formats
Operation modes
Compression qualities
Alpha modes
ETCPACK/PVRTC channel weighting modes
Resize filters
Resize round modes
Mipmap filters
Wrap modes
PVRTC punch through modes
, %s
File format does not support compression format
BGRA8
RGBA8
RGBA4
BGRA4
ABGR4
R5G6B5
B5G6R5
RGB5A1
BGR5A1
A1RGB5
A1BGR5
BGR10A2
RGB10A2
R16_Snorm
RGB16
RGB32
RGBA16
RGBA32
RG11B10
RGB9E5
ASTC4x2
ASTC4x2_HDR
ASTC4x4
ASTC4x4_HDR
ASTC5x4
ASTC5x4_HDR
ASTC5x5
ASTC5x5_HDR
ASTC6x5
ASTC6x5_HDR
ASTC6x6
ASTC6x6_HDR
ASTC8x4
ASTC8x4_HDR
ASTC8x5
ASTC8x5_HDR
ASTC8x6
ASTC8x6_HDR
ASTC8x8
ASTC8x8_HDR
ASTC10x5_HDR
ASTC10x6_HDR
ASTC10x8_HDR
ASTC10x10
ASTC10x10_HDR
ASTC12x10
ASTC12x10_HDR
ASTC12x12
ASTC12x12_HDR
EAC_R11
EAC_RGBA8
ETC2_RGB8
ETC2_RGB8A1
PVRTC_RGB_2BPP
PVRTC_RGB_4BPP
PVRTC_RGBA_2BPP
PVRTC_RGBA_4BPP
Unknown pixel format!
The selected pixelformat does not support sRGB
Unknown pixel format "
Unsupported KTX2 Image Dimensions (3)
Unsupported KTX2 Image Type (Array)
Unsupported KTX2 Image Format (%u)
TC_Version
TC_Options
Unknown texture type
Failed to write output file
Unsupported texture type
Apple TextureConverter 
, build: %b %d %Y, %T
TextureConverter TextureTool Compatibility Mode
Usage: TextureConverter [-hl]
       TextureConverter -c <reference_image> <input_image>
       TextureConverter [-ms] [-e <encoder>] [-p <preview_file>] -o <output> [-f <format>] <input_image>
       TextureConverter [-m] [-e <encoder>] -o <output> [-f <format>] <input_image>
       first form:
         -h       Display this help menu.
         -l       List available encoders, individual encoder options, and file formats.
       second form:
         -c       Compare <input_image> to <reference_image> and report differences.
       third form:
         -m       Generate a complete mipmap chain from the input image.
         -s       Report numerical differences between <input_image> and the encoded image.
         -e       Encode texture levels with <encoder>.
         -p       Output a PNG preview of the encoded output to <preview_file>. Requires -e option.
         -o       Write processed image to <output>.
         -f       Set file <format> for <output> image.
For detailed usage: TextureConverter --h
Encoders:
  PVRTC
    --bits-per-pixel-2
    --bits-per-pixel-4
    --punchthrough-unused
    --punchthrough-allowed
    --punchthrough-forced
    --alpha-is-independent
    --alpha-is-opacity
    --channel-weighting-linear
    --channel-weighting-perceptual
  ASTC
    --block-width-4
    --block-width-5
    --block-width-6
    --block-width-8
    --block-width-10
    --block-width-12
    --compression-mode-veryfast
    --compression-mode-fast
    --compression-mode-medium
    --compression-mode-thorough
    --compression-mode-exhaustive
    --srgb-yes
    --srgb-no
    --block-height-4
    --block-height-5
    --block-height-6
    --block-height-8
    --block-height-10
    --block-height-12
Formats:
  KTX
bits-per-pixel-2
bits-per-pixel-4
punchthrough-unused
punchthrough-allowed
punchthrough-forced
alpha-is-independent
alpha-is-opacity
channel-weighting-linear
channel-weighting-perceptual
block-width-4
block-width-5
block-width-6
block-width-8
block-width-10
block-width-12
compression-mode-veryfast
compression-mode-fast
compression-mode-medium
compression-mode-thorough
compression-mode-exhaustive
srgb-yes
srgb-no
block-height-4
block-height-5
block-height-6
block-height-8
block-height-10
block-height-12
h?lke:d:p:o:mf:c:s:r:
%s: no input file specified
%s: no output file specified
%s: -p option requires that -e is set
%s: decode mode not supported
%s: no reference file specified
%s: compare does not produce an output file
%s: compare does not produce a preview file
%s: generate mipmaps cannot be used with compare
%s: compare mode not supported
--time
--metrics
ASTC
--compressor=Auto
--compression_format=ASTC
--srgb_format
--compression_quality=Fastest
--compression_quality=Normal
--compression_quality=Production
--compression_quality=Highest
--compression_format=PVRTC_RGB_2BPP
--compression_format=PVRTC_RGBA_2BPP
--compression_format=PVRTC_RGB_4BPP
--compression_format=PVRTC_RGBA_4BPP
--pvrtc_punch_through=Allowed
--pvrtc_punch_through=Forced
--pvrtc_punch_through=Unused
--channel_weighting=Perceptual
--channel_weighting=Linear
--mipmap_filter=Box
--max_mipmaps=0
--file_format=KTX
--output=
Texture-Converter TextureTool Compatibility Mode
Migrate to the Texture-Converter interface for greater control
TextureConverter --h for more details
Calling 
beginScope
endScope
MTLAccelerationStructureBoundingBoxGeometryDescriptor
MTLAccelerationStructureDescriptor
MTLAccelerationStructureGeometryDescriptor
MTLAccelerationStructureTriangleGeometryDescriptor
MTLArgument
MTLArgumentDescriptor
MTLArrayType
MTLAttribute
MTLAttributeDescriptor
MTLAttributeDescriptorArray
MTLBinaryArchiveDescriptor
MTLBlitPassDescriptor
MTLBlitPassSampleBufferAttachmentDescriptor
MTLBlitPassSampleBufferAttachmentDescriptorArray
MTLBufferLayoutDescriptor
MTLBufferLayoutDescriptorArray
MTLCaptureDescriptor
MTLCaptureManager
MTLCommandBufferDescriptor
MTLCompileOptions
MTLComputePassDescriptor
MTLComputePassSampleBufferAttachmentDescriptor
MTLComputePassSampleBufferAttachmentDescriptorArray
MTLComputePipelineDescriptor
MTLComputePipelineReflection
MTLCounterSampleBufferDescriptor
MTLDepthStencilDescriptor
MTLFunctionConstant
MTLFunctionConstantValues
MTLFunctionDescriptor
MTLHeapDescriptor
MTLIndirectCommandBufferDescriptor
MTLInstanceAccelerationStructureDescriptor
MTLIntersectionFunctionDescriptor
MTLIntersectionFunctionTableDescriptor
MTLLinkedFunctions
MTLPipelineBufferDescriptor
MTLPipelineBufferDescriptorArray
MTLPointerType
MTLPrimitiveAccelerationStructureDescriptor
MTLRasterizationRateLayerArray
MTLRasterizationRateLayerDescriptor
MTLRasterizationRateMapDescriptor
MTLRasterizationRateSampleArray
MTLRenderPassAttachmentDescriptor
MTLRenderPassColorAttachmentDescriptor
MTLRenderPassColorAttachmentDescriptorArray
MTLRenderPassDepthAttachmentDescriptor
MTLRenderPassDescriptor
MTLRenderPassSampleBufferAttachmentDescriptor
MTLRenderPassSampleBufferAttachmentDescriptorArray
MTLRenderPassStencilAttachmentDescriptor
MTLRenderPipelineColorAttachmentDescriptor
MTLRenderPipelineColorAttachmentDescriptorArray
MTLRenderPipelineDescriptor
MTLRenderPipelineReflection
MTLResourceStatePassDescriptor
MTLResourceStatePassSampleBufferAttachmentDescriptor
MTLResourceStatePassSampleBufferAttachmentDescriptorArray
MTLSamplerDescriptor
MTLSharedEventHandle
MTLSharedEventListener
MTLSharedTextureHandle
MTLStageInputOutputDescriptor
MTLStencilDescriptor
MTLStructMember
MTLStructType
MTLTextureDescriptor
MTLTextureReferenceType
MTLTileRenderPipelineColorAttachmentDescriptor
MTLTileRenderPipelineColorAttachmentDescriptorArray
MTLTileRenderPipelineDescriptor
MTLType
MTLVertexAttribute
MTLVertexAttributeDescriptor
MTLVertexAttributeDescriptorArray
MTLVertexBufferLayoutDescriptor
MTLVertexBufferLayoutDescriptorArray
MTLVertexDescriptor
MTLVisibleFunctionTableDescriptor
GPUEndTime
GPUStartTime
accelerationStructureCommandEncoder
accelerationStructureSizesWithDescriptor:
access
addCompletedHandler:
addComputePipelineFunctionsWithDescriptor:error:
addDebugMarker:range:
addPresentedHandler:
addRenderPipelineFunctionsWithDescriptor:error:
addScheduledHandler:
addTileRenderPipelineFunctionsWithDescriptor:error:
alignment
allocatedSize
allowDuplicateIntersectionFunctionInvocation
allowGPUOptimizedContents
alphaBlendOperation
areBarycentricCoordsSupported
areProgrammableSamplePositionsSupported
areRasterOrderGroupsSupported
argumentBuffersSupport
argumentDescriptor
argumentIndex
argumentIndexStride
arguments
arrayLength
arrayType
attributeIndex
attributeType
attributes
backFaceStencil
binaryArchives
binaryFunctions
blitCommandEncoder
blitCommandEncoderWithDescriptor:
blitPassDescriptor
borderColor
boundingBoxBuffer
boundingBoxBufferOffset
boundingBoxCount
boundingBoxStride
buffer
bufferAlignment
bufferBytesPerRow
bufferDataSize
bufferDataType
bufferIndex
bufferOffset
bufferPointerType
bufferStructType
buffers
buildAccelerationStructure:descriptor:scratchBuffer:scratchBufferOffset:
captureObject
clearBarrier
clearColor
clearDepth
clearStencil
colorAttachments
column
commandBuffer
commandBufferWithDescriptor:
commandBufferWithUnretainedReferences
commandQueue
commandTypes
commit
compareFunction
computeCommandEncoder
computeCommandEncoderWithDescriptor:
computeCommandEncoderWithDispatchType:
computeFunction
computePassDescriptor
concurrentDispatchThreadgroups:threadsPerThreadgroup:
concurrentDispatchThreads:threadsPerThreadgroup:
constantBlockAlignment
constantDataAtIndex:
constantValues
contents
convertSparsePixelRegions:toTileRegions:withTileSize:alignmentMode:numRegions:
convertSparseTileRegions:toPixelRegions:withTileSize:numRegions:
copyAccelerationStructure:toAccelerationStructure:
copyAndCompactAccelerationStructure:toAccelerationStructure:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
copyFromTexture:toTexture:
copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:
copyParameterDataToBuffer:offset:
counterSet
counterSets
counters
cpuCacheMode
currentAllocatedSize
dataSize
dataType
dealloc
debugLocation
debugSignposts
defaultCaptureScope
defaultRasterSampleCount
depth
depthAttachment
depthAttachmentPixelFormat
depthCompareFunction
depthFailureOperation
depthPlane
depthResolveFilter
depthStencilPassOperation
descriptor
destination
destinationAlphaBlendFactor
destinationRGBBlendFactor
device
didModifyRange:
dispatchQueue
dispatchThreadgroups:threadsPerThreadgroup:
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
dispatchThreadsPerTile:
dispatchType
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
drawPrimitives:indirectBuffer:indirectBufferOffset:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawableID
elementArrayType
elementIsArgumentBuffer
elementPointerType
elementStructType
elementTextureReferenceType
elementType
encodeSignalEvent:value:
encodeWaitForEvent:value:
encodedLength
encoderLabel
endEncoding
endOfEncoderSampleIndex
endOfFragmentSampleIndex
endOfVertexSampleIndex
enqueue
error
errorOptions
errorState
executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:
executeCommandsInBuffer:withRange:
fastMathEnabled
fillBuffer:range:value:
firstMipmapInTail
fragmentArguments
fragmentBuffers
fragmentFunction
frontFaceStencil
function
functionConstantsDictionary
functionCount
functionDescriptor
functionHandleWithFunction:
functionName
functionNames
functionType
functions
generateMipmapsForTexture:
geometryDescriptors
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
getBytes:bytesPerRow:fromRegion:mipmapLevel:
getDefaultSamplePositions:count:
getSamplePositions:count:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:
groups
hasUnifiedMemory
hazardTrackingMode
heap
heapBufferSizeAndAlignWithLength:options:
heapOffset
heapTextureSizeAndAlignWithDescriptor:
height
horizontal
horizontalSampleStorage
imageblockMemoryLengthForDimensions:
imageblockSampleLength
index
indexBuffer
indexBufferIndex
indexBufferOffset
indexType
indirectComputeCommandAtIndex:
indirectRenderCommandAtIndex:
inheritBuffers
inheritPipelineState
init
initWithDispatchQueue:
initWithSampleCount:
initWithSampleCount:horizontal:vertical:
inputPrimitiveTopology
insertDebugCaptureBoundary
insertDebugSignpost:
insertLibraries
installName
instanceCount
instanceDescriptorBuffer
instanceDescriptorBufferOffset
instanceDescriptorStride
instancedAccelerationStructures
intersectionFunctionTableDescriptor
intersectionFunctionTableOffset
iosurface
iosurfacePlane
isActive
isAliasable
isAlphaToCoverageEnabled
isAlphaToOneEnabled
isBlendingEnabled
isCapturing
isDepth24Stencil8PixelFormatSupported
isDepthTexture
isDepthWriteEnabled
isFramebufferOnly
isHeadless
isLowPower
isPatchControlPointData
isPatchData
isRasterizationEnabled
isRemovable
isShareable
isSparse
isTessellationFactorScaleEnabled
kernelEndTime
kernelStartTime
label
languageVersion
layerAtIndex:
layerCount
layers
layouts
length
level
libraries
libraryType
line
linkedFunctions
loadAction
location
locationNumber
lodAverage
lodMaxClamp
lodMinClamp
logs
magFilter
makeAliasable
mapPhysicalToScreenCoordinates:forLayer:
mapScreenToPhysicalCoordinates:forLayer:
maxAnisotropy
maxArgumentBufferSamplerCount
maxAvailableSizeWithAlignment:
maxBufferLength
maxCallStackDepth
maxFragmentBufferBindCount
maxKernelBufferBindCount
maxTessellationFactor
maxThreadgroupMemoryLength
maxThreadsPerThreadgroup
maxTotalThreadsPerThreadgroup
maxTransferRate
maxVertexAmplificationCount
maxVertexBufferBindCount
memberByName:
members
memoryBarrierWithResources:count:
memoryBarrierWithResources:count:afterStages:beforeStages:
memoryBarrierWithScope:
memoryBarrierWithScope:afterStages:beforeStages:
minFilter
minimumLinearTextureAlignmentForPixelFormat:
minimumTextureBufferAlignmentForPixelFormat:
mipFilter
mipmapLevelCount
mutability
name
newAccelerationStructureWithDescriptor:
newAccelerationStructureWithSize:
newArgumentEncoderForBufferAtIndex:
newArgumentEncoderWithArguments:
newArgumentEncoderWithBufferIndex:
newArgumentEncoderWithBufferIndex:reflection:
newBinaryArchiveWithDescriptor:error:
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
newBufferWithLength:options:
newBufferWithLength:options:offset:
newCaptureScopeWithCommandQueue:
newCaptureScopeWithDevice:
newCommandQueue
newCommandQueueWithMaxCommandBufferCount:
newComputePipelineStateWithAdditionalBinaryFunctions:error:
newComputePipelineStateWithDescriptor:options:completionHandler:
newComputePipelineStateWithDescriptor:options:reflection:error:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
newCounterSampleBufferWithDescriptor:error:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
newDepthStencilStateWithDescriptor:
newDynamicLibrary:error:
newDynamicLibraryWithURL:error:
newEvent
newFence
newFunctionWithDescriptor:completionHandler:
newFunctionWithDescriptor:error:
newFunctionWithName:
newFunctionWithName:constantValues:completionHandler:
newFunctionWithName:constantValues:error:
newHeapWithDescriptor:
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
newIntersectionFunctionTableWithDescriptor:
newIntersectionFunctionWithDescriptor:completionHandler:
newIntersectionFunctionWithDescriptor:error:
newLibraryWithData:error:
newLibraryWithFile:error:
newLibraryWithSource:options:completionHandler:
newLibraryWithSource:options:error:
newLibraryWithURL:error:
newRasterizationRateMapWithDescriptor:
newRemoteBufferViewForDevice:
newRemoteTextureViewForDevice:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:options:completionHandler:
newRenderPipelineStateWithDescriptor:options:reflection:error:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
newSamplerStateWithDescriptor:
newSharedEvent
newSharedEventHandle
newSharedEventWithHandle:
newSharedTextureHandle
newSharedTextureWithDescriptor:
newSharedTextureWithHandle:
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newTextureWithDescriptor:
newTextureWithDescriptor:iosurface:plane:
newTextureWithDescriptor:offset:
newTextureWithDescriptor:offset:bytesPerRow:
newVisibleFunctionTableWithDescriptor:
normalizedCoordinates
notifyListener:atValue:block:
objectAtIndexedSubscript:
offset
opaque
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeIndirectCommandBuffer:withRange:
outputURL
parallelRenderCommandEncoderWithDescriptor:
parameterBufferSizeAndAlign
parentRelativeLevel
parentRelativeSlice
parentTexture
patchControlPointCount
patchType
peerCount
peerGroupID
peerIndex
physicalGranularity
physicalSizeForLayer:
pixelFormat
pointerType
popDebugGroup
preprocessorMacros
present
presentAfterMinimumDuration:
presentAtTime:
presentDrawable:
presentDrawable:afterMinimumDuration:
presentDrawable:atTime:
presentedTime
preserveInvariance
pushDebugGroup:
rAddressMode
rasterSampleCount
rasterizationRateMap
rasterizationRateMapDescriptorWithScreenSize:
rasterizationRateMapDescriptorWithScreenSize:layer:
rasterizationRateMapDescriptorWithScreenSize:layerCount:layers:
readMask
readWriteTextureSupport
recommendedMaxWorkingSetSize
refitAccelerationStructure:descriptor:destination:scratchBuffer:scratchBufferOffset:
registryID
remoteStorageBuffer
remoteStorageTexture
removeAllDebugMarkers
renderCommandEncoder
renderCommandEncoderWithDescriptor:
renderPassDescriptor
renderTargetArrayLength
renderTargetHeight
renderTargetWidth
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
required
reset
resetCommandsInBuffer:withRange:
resetTextureAccessCounters:region:mipLevel:slice:
resetWithRange:
resolveCounterRange:
resolveCounters:inRange:destinationBuffer:destinationOffset:
resolveDepthPlane
resolveLevel
resolveSlice
resolveTexture
resourceOptions
resourceStateCommandEncoder
resourceStateCommandEncoderWithDescriptor:
resourceStatePassDescriptor
retainedReferences
rgbBlendOperation
rootResource
sAddressMode
sampleBuffer
sampleBufferAttachments
sampleCount
sampleCountersInBuffer:atSampleIndex:withBarrier:
sampleTimestamps:gpuTimestamp:
screenSize
serializeToURL:error:
setAccelerationStructure:atBufferIndex:
setAccelerationStructure:atIndex:
setAccess:
setAllowDuplicateIntersectionFunctionInvocation:
setAllowGPUOptimizedContents:
setAlphaBlendOperation:
setAlphaToCoverageEnabled:
setAlphaToOneEnabled:
setArgumentBuffer:offset:
setArgumentBuffer:startOffset:arrayElement:
setArrayLength:
setBackFaceStencil:
setBarrier
setBinaryArchives:
setBinaryFunctions:
setBlendColorRed:green:blue:alpha:
setBlendingEnabled:
setBorderColor:
setBoundingBoxBuffer:
setBoundingBoxBufferOffset:
setBoundingBoxCount:
setBoundingBoxStride:
setBuffer:offset:atIndex:
setBufferIndex:
setBufferOffset:atIndex:
setBuffers:offsets:withRange:
setBytes:length:atIndex:
setCaptureObject:
setClearColor:
setClearDepth:
setClearStencil:
setColorStoreAction:atIndex:
setColorStoreActionOptions:atIndex:
setCommandTypes:
setCompareFunction:
setComputeFunction:
setComputePipelineState:
setComputePipelineState:atIndex:
setComputePipelineStates:withRange:
setConstantBlockAlignment:
setConstantValue:type:atIndex:
setConstantValue:type:withName:
setConstantValues:
setConstantValues:type:withRange:
setCounterSet:
setCpuCacheMode:
setCullMode:
setDataType:
setDefaultCaptureScope:
setDefaultRasterSampleCount:
setDepth:
setDepthAttachment:
setDepthAttachmentPixelFormat:
setDepthBias:slopeScale:clamp:
setDepthClipMode:
setDepthCompareFunction:
setDepthFailureOperation:
setDepthPlane:
setDepthResolveFilter:
setDepthStencilPassOperation:
setDepthStencilState:
setDepthStoreAction:
setDepthStoreActionOptions:
setDepthWriteEnabled:
setDestination:
setDestinationAlphaBlendFactor:
setDestinationRGBBlendFactor:
setDispatchType:
setEndOfEncoderSampleIndex:
setEndOfFragmentSampleIndex:
setEndOfVertexSampleIndex:
setErrorOptions:
setFastMathEnabled:
setFormat:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBuffers:offsets:withRange:
setFragmentBytes:length:atIndex:
setFragmentFunction:
setFragmentSamplerState:atIndex:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentSamplerStates:withRange:
setFragmentTexture:atIndex:
setFragmentTextures:withRange:
setFrontFaceStencil:
setFrontFacingWinding:
setFunction:atIndex:
setFunctionCount:
setFunctions:
setFunctions:withRange:
setGeometryDescriptors:
setGroups:
setHazardTrackingMode:
setHeight:
setImageblockSampleLength:
setImageblockWidth:height:
setIndex:
setIndexBuffer:
setIndexBufferIndex:
setIndexBufferOffset:
setIndexType:
setIndirectCommandBuffer:atIndex:
setIndirectCommandBuffers:withRange:
setInheritBuffers:
setInheritPipelineState:
setInputPrimitiveTopology:
setInsertLibraries:
setInstallName:
setInstanceCount:
setInstanceDescriptorBuffer:
setInstanceDescriptorBufferOffset:
setInstanceDescriptorStride:
setInstancedAccelerationStructures:
setIntersectionFunctionTable:atBufferIndex:
setIntersectionFunctionTable:atIndex:
setIntersectionFunctionTableOffset:
setIntersectionFunctionTables:withBufferRange:
setIntersectionFunctionTables:withRange:
setKernelBuffer:offset:atIndex:
setLabel:
setLanguageVersion:
setLayer:atIndex:
setLevel:
setLibraries:
setLibraryType:
setLinkedFunctions:
setLoadAction:
setLodAverage:
setLodMaxClamp:
setLodMinClamp:
setMagFilter:
setMaxAnisotropy:
setMaxCallStackDepth:
setMaxFragmentBufferBindCount:
setMaxKernelBufferBindCount:
setMaxTessellationFactor:
setMaxTotalThreadsPerThreadgroup:
setMaxVertexAmplificationCount:
setMaxVertexBufferBindCount:
setMinFilter:
setMipFilter:
setMipmapLevelCount:
setMutability:
setName:
setNormalizedCoordinates:
setObject:atIndexedSubscript:
setOffset:
setOpaque:
setOpaqueTriangleIntersectionFunctionWithSignature:atIndex:
setOpaqueTriangleIntersectionFunctionWithSignature:withRange:
setOptions:
setOutputURL:
setPixelFormat:
setPreprocessorMacros:
setPreserveInvariance:
setPurgeableState:
setRAddressMode:
setRasterSampleCount:
setRasterizationEnabled:
setRasterizationRateMap:
setReadMask:
setRenderPipelineState:
setRenderPipelineState:atIndex:
setRenderPipelineStates:withRange:
setRenderTargetArrayLength:
setRenderTargetHeight:
setRenderTargetWidth:
setResolveDepthPlane:
setResolveLevel:
setResolveSlice:
setResolveTexture:
setResourceOptions:
setRetainedReferences:
setRgbBlendOperation:
setSAddressMode:
setSampleBuffer:
setSampleCount:
setSamplePositions:count:
setSamplerState:atIndex:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setSamplerStates:withRange:
setScissorRect:
setScissorRects:count:
setScreenSize:
setSignaledValue:
setSize:
setSlice:
setSourceAlphaBlendFactor:
setSourceRGBBlendFactor:
setSpecializedName:
setStageInRegion:
setStageInRegionWithIndirectBuffer:indirectBufferOffset:
setStageInputDescriptor:
setStartOfEncoderSampleIndex:
setStartOfFragmentSampleIndex:
setStartOfVertexSampleIndex:
setStencilAttachment:
setStencilAttachmentPixelFormat:
setStencilCompareFunction:
setStencilFailureOperation:
setStencilFrontReferenceValue:backReferenceValue:
setStencilReferenceValue:
setStencilResolveFilter:
setStencilStoreAction:
setStencilStoreActionOptions:
setStepFunction:
setStepRate:
setStorageMode:
setStoreAction:
setStoreActionOptions:
setStride:
setSupportAddingBinaryFunctions:
setSupportArgumentBuffers:
setSupportIndirectCommandBuffers:
setSwizzle:
setTAddressMode:
setTessellationControlPointIndexType:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorFormat:
setTessellationFactorScale:
setTessellationFactorScaleEnabled:
setTessellationFactorStepFunction:
setTessellationOutputWindingOrder:
setTessellationPartitionMode:
setTexture:
setTexture:atIndex:
setTextureType:
setTextures:withRange:
setThreadGroupSizeIsMultipleOfThreadExecutionWidth:
setThreadgroupMemoryLength:
setThreadgroupMemoryLength:atIndex:
setThreadgroupMemoryLength:offset:atIndex:
setThreadgroupSizeMatchesTileSize:
setTileBuffer:offset:atIndex:
setTileBufferOffset:atIndex:
setTileBuffers:offsets:withRange:
setTileBytes:length:atIndex:
setTileFunction:
setTileHeight:
setTileSamplerState:atIndex:
setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setTileSamplerStates:withRange:
setTileTexture:atIndex:
setTileTextures:withRange:
setTileWidth:
setTriangleCount:
setTriangleFillMode:
setType:
setUrl:
setUsage:
setVertexAmplificationCount:viewMappings:
setVertexBuffer:
setVertexBuffer:offset:atIndex:
setVertexBufferOffset:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setVertexBytes:length:atIndex:
setVertexDescriptor:
setVertexFunction:
setVertexSamplerState:atIndex:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setVertexSamplerStates:withRange:
setVertexStride:
setVertexTexture:atIndex:
setVertexTextures:withRange:
setViewport:
setViewports:count:
setVisibilityResultBuffer:
setVisibilityResultMode:offset:
setVisibleFunctionTable:atBufferIndex:
setVisibleFunctionTable:atIndex:
setVisibleFunctionTables:withBufferRange:
setVisibleFunctionTables:withRange:
setWidth:
setWriteMask:
sharedCaptureManager
signaledValue
size
slice
sourceAlphaBlendFactor
sourceRGBBlendFactor
sparseTileSizeInBytes
sparseTileSizeWithTextureType:pixelFormat:sampleCount:
specializedName
stageInputAttributes
stageInputDescriptor
stageInputOutputDescriptor
startCaptureWithCommandQueue:
startCaptureWithDescriptor:error:
startCaptureWithDevice:
startCaptureWithScope:
startOfEncoderSampleIndex
startOfFragmentSampleIndex
startOfVertexSampleIndex
staticThreadgroupMemoryLength
status
stencilAttachment
stencilAttachmentPixelFormat
stencilCompareFunction
stencilFailureOperation
stencilResolveFilter
stepFunction
stepRate
stopCapture
storageMode
storeAction
storeActionOptions
stride
structType
supportAddingBinaryFunctions
supportArgumentBuffers
supportIndirectCommandBuffers
supports32BitFloatFiltering
supports32BitMSAA
supportsBCTextureCompression
supportsCounterSampling:
supportsDestination:
supportsDynamicLibraries
supportsFamily:
supportsFeatureSet:
supportsFunctionPointers
supportsPullModelInterpolation
supportsQueryTextureLOD
supportsRasterizationRateMapWithLayerCount:
supportsRaytracing
supportsShaderBarycentricCoordinates
supportsTextureSampleCount:
supportsVertexAmplificationCount:
swizzle
synchronizeResource:
synchronizeTexture:slice:level:
tAddressMode
tailSizeInBytes
tessellationControlPointIndexType
tessellationFactorFormat
tessellationFactorStepFunction
tessellationOutputWindingOrder
tessellationPartitionMode
texture
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
textureBarrier
textureBufferDescriptorWithPixelFormat:width:resourceOptions:usage:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
textureDataType
textureReferenceType
textureType
threadExecutionWidth
threadGroupSizeIsMultipleOfThreadExecutionWidth
threadgroupMemoryAlignment
threadgroupMemoryDataSize
threadgroupMemoryLength
threadgroupSizeMatchesTileSize
tileArguments
tileBuffers
tileFunction
tileHeight
tileWidth
triangleCount
type
updateFence:
updateFence:afterStages:
updateTextureMapping:mode:indirectBuffer:indirectBufferOffset:
updateTextureMapping:mode:region:mipLevel:slice:
updateTextureMappings:mode:regions:mipLevels:slices:numRegions:
usage
useHeap:
useHeap:stages:
useHeaps:count:
useHeaps:count:stages:
useResource:usage:
useResource:usage:stages:
useResources:count:usage:
useResources:count:usage:stages:
usedSize
vertexArguments
vertexAttributes
vertexBuffer
vertexBufferOffset
vertexBuffers
vertexDescriptor
vertexFunction
vertexStride
vertical
verticalSampleStorage
visibilityResultBuffer
visibleFunctionTableDescriptor
waitForFence:
waitForFence:beforeStages:
waitUntilCompleted
waitUntilScheduled
width
writeCompactedAccelerationStructureSize:toBuffer:offset:
writeMask
NSArray
NSAutoreleasePool
NSBundle
NSCondition
NSDate
NSDictionary
NSError
NSNumber
NSObject
NSProcessInfo
NSSet
NSString
NSURL
NSValue
addObject:
activeProcessorCount
allBundles
allFrameworks
allObjects
alloc
appStoreReceiptURL
array
arrayWithObject:
arrayWithObjects:count:
automaticTerminationSupportEnabled
autorelease
beginActivityWithOptions:reason:
boolValue
broadcast
builtInPlugInsPath
builtInPlugInsURL
bundleIdentifier
bundlePath
bundleURL
bundleWithPath:
bundleWithURL:
characterAtIndex:
charValue
countByEnumeratingWithState:objects:count:
cStringUsingEncoding:
code
compare:
copy
count
dateWithTimeIntervalSinceNow:
descriptionWithLocale:
disableAutomaticTermination:
disableSuddenTermination
debugDescription
description
dictionary
dictionaryWithObject:forKey:
dictionaryWithObjects:forKeys:count:
domain
doubleValue
drain
enableAutomaticTermination:
enableSuddenTermination
endActivity:
environment
errorWithDomain:code:userInfo:
executablePath
executableURL
fileSystemRepresentation
fileURLWithPath:
floatValue
fullUserName
getValue:size:
globallyUniqueString
hash
hostName
infoDictionary
initFileURLWithPath:
initWithBool:
initWithBytes:objCType:
initWithBytesNoCopy:length:encoding:freeWhenDone:
initWithChar:
initWithCoder:
initWithCString:encoding:
initWithDomain:code:userInfo:
initWithDouble:
initWithFloat:
initWithInt:
initWithLong:
initWithLongLong:
initWithObjects:count:
initWithObjects:forKeys:count:
initWithPath:
initWithShort:
initWithString:
initWithUnsignedChar:
initWithUnsignedInt:
initWithUnsignedLong:
initWithUnsignedLongLong:
initWithUnsignedShort:
initWithURL:
integerValue
intValue
isEqual:
isEqualToNumber:
isEqualToString:
isEqualToValue:
isiOSAppOnMac
isLoaded
isLowPowerModeEnabled
isMacCatalystApp
isOperatingSystemAtLeastVersion:
keyEnumerator
lengthOfBytesUsingEncoding:
load
loadAndReturnError:
localizedDescription
localizedFailureReason
localizedInfoDictionary
localizedRecoveryOptions
localizedRecoverySuggestion
localizedStringForKey:value:table:
lock
longValue
longLongValue
mainBundle
maximumLengthOfBytesUsingEncoding:
methodSignatureForSelector:
mutableBytes
nextObject
numberWithBool:
numberWithChar:
numberWithDouble:
numberWithFloat:
numberWithInt:
numberWithLong:
numberWithLongLong:
numberWithShort:
numberWithUnsignedChar:
numberWithUnsignedInt:
numberWithUnsignedLong:
numberWithUnsignedLongLong:
numberWithUnsignedShort:
objCType
object
objectAtIndex:
objectEnumerator
objectForInfoDictionaryKey:
objectForKey:
operatingSystem
operatingSystemVersion
operatingSystemVersionString
pathForAuxiliaryExecutable:
performActivityWithOptions:reason:usingBlock:
performExpiringActivityWithReason:usingBlock:
physicalMemory
pointerValue
preflightAndReturnError:
privateFrameworksPath
privateFrameworksURL
processIdentifier
processInfo
processName
processorCount
rangeOfString:options:
release
resourcePath
resourceURL
respondsToSelector:
retain
retainCount
setAutomaticTerminationSupportEnabled:
setProcessName:
sharedFrameworksPath
sharedFrameworksURL
sharedSupportPath
sharedSupportURL
shortValue
showPools
signal
string
stringValue
stringWithString:
stringWithCString:encoding:
stringByAppendingString:
systemUptime
thermalState
unload
unlock
unsignedCharValue
unsignedIntegerValue
unsignedIntValue
unsignedLongValue
unsignedLongLongValue
unsignedShortValue
URLForAuxiliaryExecutable:
userInfo
userName
UTF8String
valueWithBytes:objCType:
valueWithPointer:
wait
waitUntilDate:
v24@?0^v8^v16
//  astc.metal
//  ASTCRuntime
//  Created by Georgi Rakidov on 28/01/2020.
//  Copyright 2020 APPLE. All rights reserved.
#include <metal_stdlib>
// Including header shared between this Metal shader code and Swift/C code executing Metal API commands
//#import "ShaderTypes.h"
#define BLOCKS_IN_GROUP_COUNT 64
using namespace metal;
//FUNCTION CONSTANTS
////////////////////////////////////////
constant int astc_block_width       [[ function_constant(0) ]];
constant int astc_block_height      [[ function_constant(1) ]];
constant int astc_channels          [[ function_constant(2) ]];
constant uint astc_packed_mode      [[ function_constant(3) ]];
////////////////////////////////////////
#define swap(a, b) {auto t = a; a=b; b=t;}
struct astc_settings
    int width;
    int height;
    int blocks_count;
    int width_in_blocks;
struct astc_block_data
    uint8_t weights[64];
    uint8_t endpoints[8];
struct range_values
    int levels_m;
    int levels_m_rcp;
    int levels_e;
    int levels;
struct pixel_set
    threadgroup uint32_t* restrict pixels;
    
    int width;
    int height;
float4 get_pixel_f(threadgroup const uint32_t* pixels, int x, int y)
    return unpack_unorm4x8_to_float(pixels[y*astc_block_width + x])*255.0;
//#define get_pixel(t,p,x,y) (unpack_unorm4x8_to_##t(p[y*astc_block_width + x])*t(255.0))
template<typename T>
void get_pixel(T out[], threadgroup const uint32_t* pixels, int x, int y)
    if(is_same<T, float>::value)
    {
        float4 tmp = unpack_unorm4x8_to_float(pixels[y*astc_block_width + x])*255.0;
        for(int i=0;i<4;++i)out[i] = tmp[i];
    }
    else
    {
        half4 tmp =  unpack_unorm4x8_to_half(pixels[y*astc_block_width + x])*255.0;
        for(int i=0;i<4;++i)out[i] = tmp[i];
    }
template <typename T>
T sq(T v)
    return v*v;
template <typename T>
T clamp(T v, int a, int b)
    return clamp(v, (T)a, (T)b);
template <typename T>
T dot3(T a[3], T b[3])
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
template <typename T>
inline T dot4(T a[4], T b[4])
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
template <typename T>
void ssymv3(T a[4], T covar[10], T b[4])
    a[0] = covar[0] * b[0] + covar[1] * b[1] + covar[2] * b[2];
    a[1] = covar[1] * b[0] + covar[4] * b[1] + covar[5] * b[2];
    a[2] = covar[2] * b[0] + covar[5] * b[1] + covar[7] * b[2];
template <typename T>
void ssymv4(T a[4], T covar[10], T b[4])
    a[0] = covar[0] * b[0] + covar[1] * b[1] + covar[2] * b[2] + covar[3] * b[3];
    a[1] = covar[1] * b[0] + covar[4] * b[1] + covar[5] * b[2] + covar[6] * b[3];
    a[2] = covar[2] * b[0] + covar[5] * b[1] + covar[7] * b[2] + covar[8] * b[3];
    a[3] = covar[3] * b[0] + covar[6] * b[1] + covar[8] * b[2] + covar[9] * b[3];
uint32_t get_field(uint32_t input, int a, int b)
    return (input >> b) & ((1 << (a - b + 1)) - 1);
int get_bits(uint32_t value, int from, int to)
    return (value >> from) & ((1 << (to + 1 - from)) - 1);
uint32_t get_bit(uint32_t input, int a)
    return get_field(input, a, a);
struct astc_block
    int width; // 2..8 <= 2^3
    int height;
    int dual_plane;
    int weight_range;
    int color_component_selector;
    int partitions;
    int partition_id;
    int color_endpoint_pairs;
    int channels;
    int color_endpoint_modes[4];
    int endpoint_range;
    
    astc_block(const uint32_t mode)
    {
        // uniform parameters
        width = int(2 + get_field(mode, 15, 13)); // 2..8 <= 2^3
        height = int(2 + get_field(mode, 18, 16)); // 2..8 <= 2^3
        dual_plane = int(get_field(mode, 19, 19));// 0 or 1
        partitions = 1;
        
        int colorEndpointModes0 = int(get_field(mode, 7, 6) * 2 + 6); // 6, 8, 10 or 12
        color_endpoint_pairs = 1 + (colorEndpointModes0 / 4);
        channels = (colorEndpointModes0 > 8) ? 4 : 3;
        // varying parameters
        weight_range = get_bits(mode, 0, 3);  // 0..11 <= 2^4
        color_component_selector = get_bits(mode, 4, 5);  // 0..2 <= 2^2
        partition_id = 0;
        color_endpoint_modes[0] = get_bits(mode, 6, 7) * 2 + 6; // 6, 8, 10 or 12
        endpoint_range = get_bits(mode, 8, 12); // 0..20 <= 2^5
    }
void accumulate_stats(float stats[15], float4 rgba, int channels)
    stats[10] += rgba[0];
    stats[11] += rgba[1];
    stats[12] += rgba[2];
    stats[0] += rgba[0] * rgba[0];
    stats[1] += rgba[0] * rgba[1];
    stats[2] += rgba[0] * rgba[2];
    stats[4] += rgba[1] * rgba[1];
    stats[5] += rgba[1] * rgba[2];
    stats[7] += rgba[2] * rgba[2];
    if (channels == 4)
    {
        stats[13] += rgba[3];
        stats[3] += rgba[0] * rgba[3];
        stats[6] += rgba[1] * rgba[3];
        stats[8] += rgba[2] * rgba[3];
        stats[9] += rgba[3] * rgba[3];
    }
void covar_from_stats(float covar[10], float stats[15], int channels)
    covar[0] = stats[0] - stats[10 + 0] * stats[10 + 0] / stats[14];
    covar[1] = stats[1] - stats[10 + 0] * stats[10 + 1] / stats[14];
    covar[2] = stats[2] - stats[10 + 0] * stats[10 + 2] / stats[14];
    covar[4] = stats[4] - stats[10 + 1] * stats[10 + 1] / stats[14];
    covar[5] = stats[5] - stats[10 + 1] * stats[10 + 2] / stats[14];
    covar[7] = stats[7] - stats[10 + 2] * stats[10 + 2] / stats[14];
    if (channels == 4)
    {
        covar[3] = stats[3] - stats[10 + 0] * stats[10 + 3] / stats[14];
        covar[6] = stats[6] - stats[10 + 1] * stats[10 + 3] / stats[14];
        covar[8] = stats[8] - stats[10 + 2] * stats[10 + 3] / stats[14];
        covar[9] = stats[9] - stats[10 + 3] * stats[10 + 3] / stats[14];
    }
void compute_axis(float axis[4], float covar[10], const int powerIterations, int channels)
    float vec[4] = { 1, 1, 1, 1 };
    for (int i = 0; i < powerIterations; i++)
    {
        if (channels == 3) ssymv3(axis, covar, vec);
        if (channels == 4) ssymv4(axis, covar, vec);
        for (int p = 0; p < channels; p++) vec[p] = axis[p];
        if (i % 2 == 1) // renormalize every other iteration
        {
            float norm_sq = 0;
            for (int p = 0; p < channels; p++)
                norm_sq += axis[p] * axis[p];
            float rnorm = rsqrt(norm_sq);
            for (int p = 0; p < channels; p++)
            {
                vec[p] *= rnorm;
            }
        }
    }
    for (int p = 0; p < channels; p++) axis[p] = vec[p];
void process_block(threadgroup uint32_t* restrict pixels, texture2d<half> src,
                uint xx, uint yy, uint width, uint height,
                bool zero_based, float dc[], float dir[])
    float stats[15] = { 0 };
    
    for (uint y = 0; y < height; y++)
    {
        for (uint x = 0; x < width; x++)
        {
            uint2 crd(xx * width + x, yy * height + y);
            
            half4 h_rgba = src.read(crd);
            float4 rgba = float4(h_rgba);
            //rgba.xyz = 1.0;
            rgba.w = 1.0;
            //rgba = float4(1,1,1,1);
            float4 rgba255 = rgba * 255.0f;
            
            accumulate_stats(stats, rgba255, 4);
            
            uint packed = pack_float_to_unorm4x8(rgba);
            pixels[y*astc_block_width + x] = packed;
        }
    }
    
    //width and height here are dimensions of the commpressed block
    //this function must be called only for blocks with the same dimesion as the global grid
    stats[14] += height * width;
    
    float cov[10];
    
    if (zero_based)
    {
        for (int p = 0; p < 4; p++) stats[10 + p] = 0;
    }
    covar_from_stats(cov, stats, 4);
    for (int p = 0; p < 4; p++)
        dc[p] = stats[10 + p] / stats[14];
    
    //Should work fine with 2,4,6,8,10
    int powerIterations = 2;
    float eps = sq(0.001) * 1000;
    cov[0] += eps;
    cov[4] += eps;
    cov[7] += eps;
    cov[9] += eps;
    
    compute_axis(dir, cov, powerIterations, 4);
void process_block_fast(threadgroup uint32_t* restrict pixels, texture2d<half> src,
                        //uint xx, uint yy, uint width, uint height, float ep[])
                        uint xx, uint yy, uint width, uint height, thread half3& ep_min, thread half3& ep_max)
    //half3 ep_min,ep_max;
    half lum_min = 1000.0h;
    half lum_max = 0.0h;
    for (uint y = 0; y < height; y++)
    {
        for (uint x = 0; x < width; x++)
        {
            uint2 crd(xx * width + x, yy * height + y);
            
            half3 rgb = src.read(crd).xyz;
            half lum = dot(rgb, half3(0.2126h, 0.7152h, 0.0722h));
            if(lum_max < lum)
            {
                lum_max = lum;
                ep_max = rgb;
            }
            if(lum_min > lum)
            {
                lum_min = lum;
                ep_min = rgb;
            }
            
            uint packed = pack_half_to_unorm4x8(half4(rgb, 1.0));
            pixels[y*width + x] = packed;
        }
    }
    
    ep_min *= 255.0;
    ep_max *= 255.0;
void fill_range_values(range_values values[], int _range[])
    int range = *_range;
    int range_div3 = (range * 21846) >> 16;
    int range_mod3 = range - range_div3 * 3;
    int levels_m = max(2, 5 - range_mod3 * 2);
    int levels_e = max(0, range_mod3 + range_div3 - 1);
    if (range == 0) levels_m = 2;
    int levels_m_rcp = 0x10000 / 2 + 1;
    if (levels_m == 3) levels_m_rcp = 0x10000 / 3 + 1;
    if (levels_m == 5) levels_m_rcp = 0x10000 / 5 + 1;
    values->levels_e = levels_e;
    values->levels_m = levels_m;
    values->levels_m_rcp = levels_m_rcp;
    values->levels = levels_m << levels_e;
range_values get_range_values(int range)
    range_values values;
    fill_range_values(&values, &range);
    return values;
int code_value(int value, range_values range)
    int coded = value;
    if (range.levels_m != 2 && range.levels > 5)
    {
        int value2 = value;
        if (value >= range.levels / 2) value2 = (range.levels - 1) - value;
        int q = (value2 * range.levels_m_rcp) >> 16;
        int r = value2 - q * range.levels_m;
        coded = q + r * (1 << (range.levels_e - 1));
        coded = coded * 2 + ((value >= range.levels / 2) ? 1 : 0);
    }
    return coded;
void code_block(const astc_block block[], threadgroup astc_block_data* restrict block_data)
    int num_weights = block->width * block->height * (block->dual_plane ? 2 : 1);
    range_values weight_range_values = get_range_values(block->weight_range);
    for (int i = 0; i < num_weights; i++)
    {
        block_data->weights[i] = code_value(block_data->weights[i], weight_range_values);
    }
    range_values endpoint_range_values = get_range_values(block->endpoint_range);
    for (int i = 0; i < 2 * block->color_endpoint_pairs; i++)
    {
        block_data->endpoints[i] = code_value(block_data->endpoints[i], endpoint_range_values);
    }
bool can_store(int value, int bits)
    if (value < 0) return false;
    if (value >= 1 << bits) return false;
    return true;
//TODO: Could this be a lookup table?
int pack_block_mode(const astc_block block[])
    int block_mode = 0;
    int D = !!block->dual_plane;
    int H = !!(block->weight_range >= 6);
    int DH = D * 2 + H;
    int R = block->weight_range + 2 - ((H > 0) ? 6 : 0);
    R = R / 2 + R % 2 * 4;
    if (can_store(block->width - 4, 2) && can_store(block->height - 2, 2))
    {
        int B = block->width - 4;
        int A = block->height - 2;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | (R & 3);
    }
    if (can_store(block->width - 8, 2) && can_store(block->height - 2, 2))
    {
        int B = block->width - 8;
        int A = block->height - 2;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | 4 | (R & 3);
    }
    if (can_store(block->width - 2, 2) && can_store(block->height - 8, 2))
    {
        int A = block->width - 2;
        int B = block->height - 8;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | 8 | (R & 3);
    }
    if (can_store(block->width - 2, 2) && can_store(block->height - 6, 1))
    {
        int A = block->width - 2;
        int B = block->height - 6;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | 12 | (R & 3);
    }
    if (can_store(block->width - 2, 1) && can_store(block->height - 2, 2))
    {
        int B = block->width;
        int A = block->height - 2;
        block_mode = (DH << 9) | (B << 7) | (A << 5) | ((R & 4) << 2) | 12 | (R & 3);
    }
    if (DH == 0 && can_store(block->width - 6, 2) && can_store(block->height - 6, 2))
    {
        int A = block->width - 6;
        int B = block->height - 6;
        block_mode = (B << 9) | 256 | (A << 5) | (R << 2);
    }
    return block_mode;
constant static const int range_table[][3] =
    //2^ 3^ 5^
    { 1, 0, 0 }, // 0..1
    { 0, 1, 0 }, // 0..2
    { 2, 0, 0 }, // 0..3
    { 0, 0, 1 }, // 0..4
    { 1, 1, 0 }, // 0..5
    { 3, 0, 0 }, // 0..7
    { 1, 0, 1 }, // 0..9
    { 2, 1, 0 }, // 0..11
    { 4, 0, 0 }, // 0..15
    { 2, 0, 1 }, // 0..19
    { 3, 1, 0 }, // 0..23
    { 5, 0, 0 }, // 0..31
    { 3, 0, 1 }, // 0..39
    { 4, 1, 0 }, // 0..47
    { 6, 0, 0 }, // 0..63
    { 4, 0, 1 }, // 0..79
    { 5, 1, 0 }, // 0..95
    { 7, 0, 0 }, // 0..127
    { 5, 0, 1 }, // 0..159
    { 6, 1, 0 }, // 0..191
    { 8, 0, 0 }, // 0..255
int get_levels(int range)
    return (1 + 2 * range_table[range][1] + 4 * range_table[range][2]) << range_table[range][0];
int sequence_bits(int count, int range)
    int bits = count * range_table[range][0];
    bits += (count * range_table[range][1] * 8 + 4) / 5;
    bits += (count * range_table[range][2] * 7 + 2) / 3;
    return bits;
void set_bits(thread uint32_t data[4], thread int* pos, int bits, uint32_t value)
    int pos_val = *pos;
    
    int shift_left = pos_val % 32;
    
    int index = pos_val / 32;
    data[index] |= value << shift_left;
    
    int shifted_bits = 32 - shift_left;
    if(shifted_bits < bits)
    {
        data[index+1] |= value >> shifted_bits;
    }
    
    *pos = pos_val + bits;
void pack_five_trits(uint32_t data[4], int sequence[5], thread int* pos, int n)
    int t[5];
    int m[5];
    for (int i = 0; i < 5; i++)
    {
        t[i] = sequence[i] >> n;
        m[i] = sequence[i] - (t[i] << n);
    }
    int C;
    if (t[1] == 2 && t[2] == 2)
    {
        C = 3 * 4 + t[0];
    }
    else if (t[2] == 2)
    {
        C = t[1] * 16 + t[0] * 4 + 3;
    }
    else
    {
        C = t[2] * 16 + t[1] * 4 + t[0];
    }
    int T;
    if (t[3] == 2 && t[4] == 2)
    {
        T = get_field(C, 4, 2) * 32 + 7 * 4 + get_field(C, 1, 0);
    }
    else
    {
        T = get_field(C, 4, 0);
        if (t[4] == 2)
        {
            T += t[3] * 128 + 3 * 32;
        }
        else
        {
            T += t[4] * 128 + t[3] * 32;
        }
    }
    uint32_t pack1 = 0;
    pack1 |= m[0];
    pack1 |= get_field(T, 1, 0) << n;
    pack1 |= m[1] << (2 + n);
    uint32_t pack2 = 0;
    pack2 |= get_field(T, 3, 2);
    pack2 |= m[2] << 2;
    pack2 |= get_field(T, 4, 4) << (2 + n);
    pack2 |= m[3] << (3 + n);
    pack2 |= get_field(T, 6, 5) << (3 + n * 2);
    pack2 |= m[4] << (5 + n * 2);
    pack2 |= get_field(T, 7, 7) << (5 + n * 3);
    set_bits(data, pos, 2 + n * 2, pack1);
    set_bits(data, pos, 6 + n * 3, pack2);
void pack_three_quint(uint32_t data[4], int sequence[3], thread int* pos, int n)
    int q[3];
    int m[3];
    for (int i = 0; i < 3; i++)
    {
        q[i] = sequence[i] >> n;
        m[i] = sequence[i] - (q[i] << n);
    }
    int Q;
    if (q[0] == 4 && q[1] == 4)
    {
        Q = get_field(q[2], 1, 0) * 8 + 3 * 2 + get_bit(q[2], 2);
    }
    else
    {
        int C;
        if (q[1] == 4)
        {
            C = (q[0] << 3) + 5;
        }
        else
        {
            C = (q[1] << 3) + q[0];
        }
        if (q[2] == 4)
        {
            Q = get_field(~C, 2, 1) * 32 + get_field(C, 4, 3) * 8 + 3 * 2 + get_bit(C, 0);
        }
        else
        {
            Q = q[2] * 32 + get_field(C, 4, 0);
        }
    }
    uint32_t pack = 0;
    pack |= m[0];
    pack |= get_field(Q, 2, 0) << n;
    pack |= m[1] << (3 + n);
    pack |= get_field(Q, 4, 3) << (3 + n * 2);
    pack |= m[2] << (5 + n * 2);
    pack |= get_field(Q, 6, 5) << (5 + n * 3);
    set_bits(data, pos, 7 + n * 3, pack);
void pack_integer_sequence(uint32_t output_data[4], threadgroup const uint8_t* sequence, int pos, int count, int range)
    int n = range_table[range][0];
    int bits = sequence_bits(count, range);
    int pos0 = pos;
    uint32_t data[5] = { 0 };
    if (range_table[range][1] == 1)
    {
        for (int j = 0; j < (count + 4) / 5; j++)
        {
            int temp[5] = { 0 };
            for (int i = 0; i < min(count - j * 5, 5); i++) temp[i] = sequence[j * 5 + i];
            pack_five_trits(data, temp, &pos, n);
        }
    }
    else if (range_table[range][2] == 1)
    {
        for (int j = 0; j < (count + 2) / 3; j++)
        {
            int temp[3] = { 0 };
            for (int i = 0; i < min(count - j * 3, 3); i++) temp[i] = sequence[j * 3 + i];
            pack_three_quint(data, temp, &pos, n);
        }
    }
    else
    {
        for (int i = 0; i < count; i++)
        {
            set_bits(data, &pos, n, sequence[i]);
        }
    }
    if (pos0 + bits < 96) data[3] = 0;
    if (pos0 + bits < 64) data[2] = 0;
    if (pos0 + bits < 32) data[1] = 0;
    data[(pos0 + bits) / 32] &= (1 << ((pos0 + bits) % 32)) - 1;
    for (int k = 0; k < 4; k++) output_data[k] |= data[k];
void pack_block(uint32_t data[4],
                const astc_block block[],
                threadgroup const astc_block_data* restrict block_data)
    data[0] = 0;
    data[1] = 0;
    data[2] = 0;
    data[3] = 0;
    int pos = 0;
    set_bits(data, &pos, 11, pack_block_mode(block));
    int num_weights = block->width * block->height * (block->dual_plane ? 2 : 1);
    int weight_bits = sequence_bits(num_weights, block->weight_range);
    int extra_bits = 0;
    set_bits(data, &pos, 2, block->partitions - 1);
    set_bits(data, &pos, 4, block->color_endpoint_modes[0]);
    
    if (block->dual_plane)
    {
        extra_bits += 2;
        int pos2 = 128 - weight_bits - extra_bits;
        set_bits(data, &pos2, 2, block->color_component_selector);
    }
    int config_bits = pos + extra_bits;
    int remaining_bits = 128 - config_bits - weight_bits;
    int num_cem_pairs = 0;
    for (int j = 0; j < block->partitions; j++) num_cem_pairs += 1 + block->color_endpoint_modes[j] / 4;
    int endpoint_range = -1;
    for (int range = 20; range>0; range--)
    {
        int bits = sequence_bits(2 * num_cem_pairs, range);
        if (bits <= remaining_bits)
        {
            endpoint_range = range;
            break;
        }
    }
    pack_integer_sequence(data, block_data->endpoints, pos, 2 * num_cem_pairs, endpoint_range);
    
    uint32_t rdata[4] = { 0, 0, 0, 0 };
    pack_integer_sequence(rdata, block_data->weights, 0, num_weights, block->weight_range);
    for (int i = 0; i < 4; i++) data[i] |= reverse_bits(rdata[3 - i]);
/*void compute_pca_endpoints(float ep[8], pixel_set block[],
                                const threadgroup uint32_t* restrict pixels,
                                int channels, float dc[4], float dir[4])
    float ext[2] = { 1000, -1000 };
    for (int y = 0; y < astc_block_height; y++)
    for (int x = 0; x < astc_block_width; x++)
    {
        float proj = 0;
        
        float4 rgba = get_pixel_f(pixels, x, y);
        for (int p = 0; p < channels; p++)
            proj += (rgba[p] - dc[p]) * dir[p];
        ext[0] = min(ext[0], proj);
        ext[1] = max(ext[1], proj);
    }
    if (ext[1] - 1.0f < ext[0])
    {
        ext[1] += 0.5f;
        ext[0] -= 0.5f;
    }
    
    for (int i = 0; i < 2; i++)
    for (int p = 0; p < channels; p++)
    {
        ep[p * 2 + i] = dc[p] + dir[p] * ext[i];
    }
template <typename T>
void compute_pca_endpoints_fast(T ep[8], pixel_set block[],
                                const threadgroup uint32_t* restrict pixels,
                                int channels, T dc[4], T dir[4])
    T ext[2] = { 1000, -1000 };
    for (int y = 0; y < astc_block_height; y++)
    for (int x = 0; x < astc_block_width; x++)
    {
        T proj = 0;
        
        T rgba[4];
        get_pixel(rgba, pixels, x, y);
        for (int p = 0; p < channels; p++)
            proj += (rgba[p] - dc[p]) * dir[p];
        ext[0] = min(ext[0], proj);
        ext[1] = max(ext[1], proj);
    }
    if (ext[1] - 1.0f < ext[0])
    {
        ext[1] += 0.5f;
        ext[0] -= 0.5f;
    }
    
    for (int i = 0; i < 2; i++)
    for (int p = 0; p < channels; p++)
    {
        ep[p * 2 + i] = dc[p] + dir[p] * ext[i];
    }
template <typename T>
int quant_endpoint(T value, int levels)
    return clamp(value / T(255.0) * (levels - 1) + T(0.5), 0, levels - 1);
template <typename T>
void quantize_endpoints_scale(const astc_block block[],
                              threadgroup astc_block_data* restrict block_data,
                              T endpoints[4])
    int ep_levels = get_levels(block->endpoint_range);
    T near[3];
    T far[3];
    for (int p = 0; p < 3; p++)
    {
        near[p] = endpoints[p * 2 + 0];
        far[p] = endpoints[p * 2 + 1];
    }
    for (int p = 0; p < 3; p++)
        block_data->endpoints[p] = quant_endpoint(far[p], ep_levels);
    T sq_norm = dot3(far, far) + 0.00001;
    T scale = dot3(far, near) / sq_norm;
    block_data->endpoints[3] = quant_endpoint(scale * 256, ep_levels);
    if (block->color_endpoint_modes[0] > 8)
    {
        block_data->endpoints[4] = quant_endpoint(endpoints[3 * 2 + 0], ep_levels);
        block_data->endpoints[5] = quant_endpoint(endpoints[3 * 2 + 1], ep_levels);
    }
bool compare_endpoints(threadgroup uint8_t* endpoints, const astc_block block[])
    int sum = 0;
    for (int p = 0; p < 3; p++)
    {
        sum += endpoints[p * 2 + 0];
        sum -= endpoints[p * 2 + 1];
    }
    
    if (-2 <= sum && sum <= 2)
    {
        // avoid being too close so we don't need proper rounding
        for (int p = 0; p < 3; p++)
        {
            if (sum<=0)
                endpoints[p * 2 + 0] = clamp(endpoints[p * 2 + 0] - 1, 0, get_levels(block->endpoint_range) - 1);
            if (sum>0)
                endpoints[p * 2 + 1] = clamp(endpoints[p * 2 + 1] - 1, 0, get_levels(block->endpoint_range) - 1);
        }
        sum = 0;
        for (int p = 0; p < 3; p++)
        {
            sum += endpoints[p * 2 + 0];
            sum -= endpoints[p * 2 + 1];
        }
    }
    return sum > 0;
void reorder_endpoints(threadgroup uint8_t* endpoints, const astc_block block[], bool blue_contract)
    if (compare_endpoints(endpoints, block) == !blue_contract)
    for (int p = 0; p < 4; p++) swap(endpoints[p * 2], endpoints[p * 2 + 1]);
template <typename T>
void quantize_endpoints_pair(const astc_block block[],
                             threadgroup astc_block_data* restrict block_data,
                             T endpoints[6])
    int ep_levels = get_levels(block->endpoint_range);
    bool blue_contract = true;
    T blue_compressed[6];
    for (int i = 0; i < 2; i++)
    {
        blue_compressed[i + 0] = endpoints[i + 0] * 2 - endpoints[i + 4];
        blue_compressed[i + 2] = endpoints[i + 2] * 2 - endpoints[i + 4];
        blue_compressed[i + 4] = endpoints[i + 4];
        if (blue_compressed[i + 0] < 0) blue_contract = false;
        if (blue_compressed[i + 0] > 255) blue_contract = false;
        if (blue_compressed[i + 2] < 0) blue_contract = false;
        if (blue_compressed[i + 2] > 255) blue_contract = false;
    }
    
    if (blue_contract)
    {
        for (int p = 0; p < 3; p++)
        {
            block_data->endpoints[p * 2 + 0] = quant_endpoint(blue_compressed[p * 2 + 0], ep_levels);
            block_data->endpoints[p * 2 + 1] = quant_endpoint(blue_compressed[p * 2 + 1], ep_levels);
        }
    }
    else
    {
        for (int p = 0; p < 3; p++)
        {
            block_data->endpoints[p * 2 + 0] = quant_endpoint(endpoints[p * 2 + 0], ep_levels);
            block_data->endpoints[p * 2 + 1] = quant_endpoint(endpoints[p * 2 + 1], ep_levels);
        }
    }
    
    if (block->color_endpoint_modes[0] > 8)
    {
        block_data->endpoints[6] = quant_endpoint(endpoints[3 * 2 + 0], ep_levels);
        block_data->endpoints[7] = quant_endpoint(endpoints[3 * 2 + 1], ep_levels);
    }
    reorder_endpoints(block_data->endpoints, block, blue_contract);
template<typename T>
void quantize_endpoints(const astc_block block[],
                        threadgroup astc_block_data* restrict block_data,
                        T endpoints[])
    bool zero_based = (block->color_endpoint_modes[0] % 4) == 2;
    if (zero_based)
    {
        quantize_endpoints_scale(block, block_data, endpoints);
    }
    else
    {
        quantize_endpoints_pair(block, block_data, endpoints);
    }
inline int clamp_unorm8(int value)
    if (value < 0) return 0;
    if (value > 255) return 255;
    return value;
#define apply_blue_contract(r, g, b) { r = (r + b) >> 1; g = (g + b) >> 1; }
template <typename T>
void decode_endpoints(T endpoints[8], uint8_t coded_endpoints[], int mode)
    if ((mode % 4) == 2)
    {
        int v0 = coded_endpoints[0];
        int v1 = coded_endpoints[1];
        int v2 = coded_endpoints[2];
        int v3 = coded_endpoints[3];
        int v4 = coded_endpoints[4];
        int v5 = coded_endpoints[5];
        endpoints[0] = (v0 * v3) >> 8;
        endpoints[1] = (v1 * v3) >> 8;
        endpoints[2] = (v2 * v3) >> 8;
        endpoints[3] = 0xFF;
        endpoints[4] = v0;
        endpoints[5] = v1;
        endpoints[6] = v2;
        endpoints[7] = 0xFF;
        if (mode > 8)
        {
            endpoints[3] = clamp_unorm8(v4);
            endpoints[7] = clamp_unorm8(v5);
        }
    }
    if ((mode % 4) == 0)
    {
        int v0 = coded_endpoints[0];
        int v1 = coded_endpoints[1];
        int v2 = coded_endpoints[2];
        int v3 = coded_endpoints[3];
        int v4 = coded_endpoints[4];
        int v5 = coded_endpoints[5];
        int v6 = coded_endpoints[6];
        int v7 = coded_endpoints[7];
        bool swap_endpoints = v1 + v3 + v5 < v0 + v2 + v4;
        if (swap_endpoints)
        {
            swap(v0, v1);
            swap(v2, v3);
            swap(v4, v5);
            swap(v6, v7);
            apply_blue_contract(v0, v2, v4);
            apply_blue_contract(v1, v3, v5);
        }
        endpoints[0] = clamp_unorm8(v0);
        endpoints[1] = clamp_unorm8(v2);
        endpoints[2] = clamp_unorm8(v4);
        endpoints[3] = 0xFF;
        endpoints[4] = clamp_unorm8(v1);
        endpoints[5] = clamp_unorm8(v3);
        endpoints[6] = clamp_unorm8(v5);
        endpoints[7] = 0xFF;
        if (mode > 8)
        {
            endpoints[3] = clamp_unorm8(v6);
            endpoints[7] = clamp_unorm8(v7);
        }
    }
template <typename T>
void dequant_decode_endpoints(T endpoints[8], const threadgroup uint8_t* block_endpoints, int mode, int range)
    int levels = get_levels(range);
    int num_cem_pairs = 1 + mode / 4;
    uint8_t dequant_endpoints[8];
    for (int k = 0; k < 2 * num_cem_pairs; k++)
    {
        dequant_endpoints[k] = (int)(((int)block_endpoints[k]) * 255.0 / (levels - 1) + 0.5);
    }
    decode_endpoints(endpoints, dequant_endpoints, mode);
template <typename T>
void opt_weights_fast(threadgroup const uint32_t* restrict scaled_pixels,
                 const astc_block block[],
                 T rec_endpoints[],
                 threadgroup astc_block_data* restrict block_data)
    const int channels = 4;
    T w_levels = get_levels(block->weight_range);
    T dir[4]; dir[3] = 0;
    for (int p = 0; p < channels; p++) dir[p] = rec_endpoints[4 + p] - rec_endpoints[0 + p];
    T sq_norm = dot4(dir, dir) + 0.00001;
    for (int p = 0; p < channels; p++) dir[p] *= (w_levels - 1) / sq_norm;
    
    for (int y = 0; y < astc_block_height; y++)
    for (int x = 0; x < astc_block_width; x++)
    {
        T pixel[4]; pixel[3] = 0;
        
        T rgba[4];
        get_pixel(rgba, scaled_pixels, x, y);
        for (int p = 0; p < channels; ++p)
            pixel[p] = rgba[p] - rec_endpoints[0 + p];
        
        T q = clamp(dot4(pixel, dir) + 0.5, 0.0, w_levels - 1.0);
        block_data->weights[y * astc_block_width + x] = q;
    }
void endpoints_and_weights(threadgroup uint32_t* restrict scaled_pixels,
                    const astc_block block[],
                    threadgroup astc_block_data* restrict block_data,
                    float dc[],
                    float dir[]
                    )
    pixel_set pset;
    pset.pixels = scaled_pixels;
    pset.width = block->width;
    pset.height = block->height;
    float ep[8];
    //compute_pca_endpoints(ep, &pset, scaled_pixels, 4, dc, dir);
    compute_pca_endpoints_fast(ep, &pset, scaled_pixels, 4, dc, dir);
    
    quantize_endpoints(block, block_data, ep);
    
    float rec_endpoints[8];
    dequant_decode_endpoints(rec_endpoints, block_data->endpoints,
                             block->color_endpoint_modes[0], block->endpoint_range);
    opt_weights_fast(scaled_pixels, block, rec_endpoints, block_data);
kernel void astc_encode(texture2d<half>            inTexture               [[ texture(0) ]],
                        device uint*               dst                     [[ buffer(0) ]],
                        constant astc_settings*    settings                [[ buffer(1) ]],
                        uint                       block_index_in_group    [[ thread_index_in_threadgroup ]],
                        uint                       block_id                [[ thread_position_in_grid ]],
                        threadgroup uchar*         tg_mem_pool             [[threadgroup(0)]])
    if(block_id >= (uint)settings->blocks_count)
        return;
    
    threadgroup uint32_t*         _pixels = (threadgroup uint32_t*)tg_mem_pool;
    uint pixels_offset = (BLOCKS_IN_GROUP_COUNT) * (astc_block_width * astc_block_height);
    threadgroup astc_block_data*  _block_data = (threadgroup astc_block_data*)(_pixels + pixels_offset);
    
    threadgroup uint32_t* restrict pixels = &_pixels[astc_block_width * astc_block_height * block_index_in_group];
    threadgroup astc_block_data* block_data = &_block_data[block_index_in_group];
    
    uint width_in_blocks = settings->width_in_blocks;
    uint2 block_crd(block_id % width_in_blocks, block_id / width_in_blocks);
    
    const astc_block block(astc_packed_mode);
    float dc[4];
    float dir[4];
    bool zero_based = (block.color_endpoint_modes[0] % 4) == 2;
    process_block(pixels, inTexture,
                  block_crd.x, block_crd.y,
                  astc_block_width, astc_block_height,
                  zero_based, dc, dir);
    
    endpoints_and_weights(pixels, &block, block_data, dc, dir);
    
    code_block(&block, block_data);
    
    uint32_t data[4];
    pack_block(data, &block, block_data);
    for (int i = 0; i < 4; i++)
    {
        int outIndex = (block_crd.y * width_in_blocks + block_crd.x) * 4 + i;
        dst[outIndex] = data[i];
    }
kernel void astc_encode_fast(texture2d<half>       inTexture               [[ texture(0) ]],
                        device uint*               dst                     [[ buffer(0) ]],
                        constant astc_settings*    settings                [[ buffer(1) ]],
                        uint                       block_index_in_group    [[ thread_index_in_threadgroup ]],
                        uint                       block_id                [[ thread_position_in_grid ]],
                        threadgroup uchar*         tg_mem_pool             [[threadgroup(0)]])
    threadgroup uint32_t*         _pixels = (threadgroup uint32_t*)tg_mem_pool;
    uint pixels_offset = (BLOCKS_IN_GROUP_COUNT) * (astc_block_width * astc_block_height);
    threadgroup astc_block_data*  _block_data = (threadgroup astc_block_data*)(_pixels + pixels_offset);
    
    threadgroup uint32_t* restrict pixels = &_pixels[astc_block_width * astc_block_height * block_index_in_group];
    threadgroup astc_block_data* block_data = &_block_data[block_index_in_group];
    
    uint width_in_blocks = settings->width_in_blocks;
    uint2 block_crd(block_id % width_in_blocks, block_id / width_in_blocks);
    half3 ep_min, ep_max;
    process_block_fast(pixels, inTexture, block_crd.x, block_crd.y,
                       astc_block_width, astc_block_height, ep_min, ep_max);
    
    float ep[8];
    for(int p=0;p<3;++p)
    {
        ep[p*2 + 0] = ep_min[p];
        ep[p*2 + 1] = ep_max[p];
    }
    
    ep[6] = 255.0;
    ep[7] = 255.0;
    
    const astc_block block(astc_packed_mode);
    quantize_endpoints(&block, block_data, ep);
    
    float rec_endpoints[8];
    dequant_decode_endpoints(rec_endpoints, block_data->endpoints,
                             block.color_endpoint_modes[0],
                             block.endpoint_range);
    
    opt_weights_fast(pixels, &block, rec_endpoints, block_data);
    
    code_block(&block, block_data);
    
    uint32_t data[4];
    pack_block(data, &block, block_data);
    for (int i = 0; i < 4; i++)
    {
        int outIndex = (block_crd.y * width_in_blocks + block_crd.x) * 4 + i;
        dst[outIndex] = data[i];
    }
///////////////////////////
//BC1/BC3 encoding
void swap_ints(int u[], int v[], int n)
    for (int i=0; i<n; i++)
    {
        int t = u[i];
        u[i] = v[i];
        v[i] = t;
    }
int stb__Mul8Bit(int a, int b)
  int t = a*b + 128;
  return (t + (t >> 8)) >> 8;
ushort stb__As16Bit(int r, int g, int b)
   return (stb__Mul8Bit(r,31) << 11) + (stb__Mul8Bit(g,63) << 5) + stb__Mul8Bit(b,31);
ushort enc_rgb565(float c[3])
    return stb__As16Bit((int)c[0], (int)c[1], (int)c[2]);
void dec_rgb565(float c[3], int p)
    int c2 = (p>>0)&31;
    int c1 = (p>>5)&63;
    int c0 = (p>>11)&31;
    c[0] = (c0<<3)+(c0>>2);
    c[1] = (c1<<2)+(c1>>4);
    c[2] = (c2<<3)+(c2>>2);
uint fast_quant(threadgroup const uint* pixels, int p0, int p1)
    float c0[3];
    float c1[3];
    dec_rgb565(c0, p0);
    dec_rgb565(c1, p1);
    float dir[3];
    for (int p=0; p<3; p++) dir[p] = c1[p]-c0[p];
    
    float sq_norm = 0;
    for (int p=0; p<3; p++) sq_norm += sq(dir[p]);
    float rsq_norm = 1.0/sq_norm;
    for (int p=0; p<3; p++) dir[p] *= rsq_norm*3;
    float bias = 0.5;
    for (int p=0; p<3; p++) bias -= c0[p]*dir[p];
    uint bits = 0;
    uint scaler = 1;
    for(int y=0;y<astc_block_height;++y)
    {
        for(int x=0;x<astc_block_height;++x)
        {
            float dot = 0;
            float4 rgba = get_pixel_f(pixels, x, y);
            for (int p=0; p<3; p++)
            {
                dot += rgba[p]*dir[p];
            }
            int q = clamp((int)(dot+bias), 0, 3);
            bits += q*scaler;
            scaler *= 4;
        }
    }
    
    return bits;
uint fix_qbits(uint qbits)
    const uint mask_01b = 0x55555555;
    const uint mask_10b = 0xAAAAAAAA;
    uint qbits0 = qbits&mask_01b;
    uint qbits1 = qbits&mask_10b;
    qbits = (qbits1>>1) + (qbits1 ^ (qbits0<<1));
    return qbits;
kernel void bc1_encode_fast(texture2d<half>       inTexture               [[ texture(0) ]],
                    device uint*               dst                     [[ buffer(0) ]],
                    constant astc_settings*    settings                [[ buffer(1) ]],
                    uint                       block_index_in_group    [[ thread_index_in_threadgroup ]],
                    uint                       block_id                [[ thread_position_in_grid ]],
                    threadgroup uchar*         tg_mem_pool             [[threadgroup(0)]])
    threadgroup uint32_t*         _pixels = (threadgroup uint32_t*)tg_mem_pool;
    threadgroup uint32_t* restrict pixels = &_pixels[astc_block_width * astc_block_height * block_index_in_group];
    
    uint width_in_blocks = settings->width_in_blocks;
    uint2 block_crd(block_id % width_in_blocks, block_id / width_in_blocks);
    
    float c0[3];
    float c1[3];
    half3 ep_min, ep_max;
    process_block_fast(pixels, inTexture, block_crd.x, block_crd.y,
                       astc_block_width, astc_block_height, ep_min, ep_max);
    
    for(int i=0;i<3;++i)
    {
        c0[i] = ep_min[i];
        c1[i] = ep_max[i];
    }
    
    int p[2];
    p[0] = enc_rgb565(c0);
    p[1] = enc_rgb565(c1);
    if (p[0]<p[1]) swap_ints(&p[0], &p[1], 1);
    
    uint data[2];
    data[0] = (1<<16)*p[1]+p[0];
    data[1] = fast_quant(pixels, p[0], p[1]);
    
    data[1] = fix_qbits(data[1]);
    
    int out_index = (block_crd.y * width_in_blocks + block_crd.x) * 2;
    dst[out_index] = data[0];
    dst[out_index + 1] = data[1];
#include <metal_stdlib>
using namespace metal;
kernel void
simpleDecompress(texture2d<float, access::read> inTexture  [[texture(0)]],
                 texture2d<uint, access::write> outTexture [[texture(1)]],
                 uint2                          gid        [[thread_position_in_grid]])
    float4 fColour = inTexture.read(gid);
    outTexture.write(uint4(fColour*255.0), gid);
kernel void
simpleDecompress16F(texture2d<float, access::read> inTexture  [[texture(0)]],
                    texture2d<half, access::write> outTexture [[texture(1)]],
                    uint2                          gid        [[thread_position_in_grid]])
    float4 fColour = inTexture.read(gid);
    outTexture.write(half4(fColour), gid);
simpleDecompress16F
simpleDecompress
Compression failed
Bad checkerboard mod value %d (this isn't supposed to happen!)
Bad threshold mod value %d (this isn't supposed to happen!)
Bad mod value %d (this isn't supposed to happen!)
Bit replication is wrong! (%d, %d)
Bit extra replication is wrong! (%d, %d, %d, %d)
PVRTC requires a square image
PVRTC requires a first mip level with a width/height >= 8
PVRTC requires a width/height of power of two
ASTCENC_SUCCESS
ASTCENC_ERR_OUT_OF_MEM
ASTCENC_ERR_BAD_CPU_FLOAT
ASTCENC_ERR_BAD_PARAM
ASTCENC_ERR_BAD_BLOCK_SIZE
ASTCENC_ERR_BAD_PROFILE
ASTCENC_ERR_BAD_QUALITY
ASTCENC_ERR_BAD_FLAGS
ASTCENC_ERR_BAD_SWIZZLE
ASTCENC_ERR_BAD_CONTEXT
ASTCENC_ERR_NOT_IMPLEMENTED
EtcImage.cpp
Encode
m_paucEncodingBits == nullptr
effortblocks = %d
pass %u
    %u unfinished blocks
Finished %d Blocks out of %d
    %u iterated blocks
IterateThroughWorstBlocks
a_uiMultithreadingStride > 0
FindEncodingWarningTypesForCurFormat
ETC1
RGB8
SRGB8
RGB8A1
SRGB8A1
SRGBA8
SIGNED_R11
RG11
SIGNED_RG11
UNKNOWN
RunFirstPass
SetEncodingBits
GetError
EtcBlock4x4Encoding.h
m_fError >= 0.0f
thread constructor failed
InitFromSource
EtcBlock4x4.cpp
InitFromEtcEncodingBits
PLANAR
CalcPixelError
EtcBlock4x4Encoding.cpp
a_fDecodedAlpha >= 0.0f
PerformIteration
EtcBlock4x4Encoding_ETC1.cpp
!m_boolDone
CalculateSourceAverages
(fWeightSumLeft + fWeightSumRight) > 0.0f
(fWeightSumTop + fWeightSumBottom) > 0.0f
fWeightSumRight > 0.0f
fWeightSumLeft > 0.0f
fWeightSumBottom > 0.0f
fWeightSumTop > 0.0f
TryDifferential
encodingTry.m_fError < FLT_MAX
ptryBest1 != nullptr
ptryBest2 != nullptr
iDRed >= -4 && iDRed < 4
iDGreen >= -4 && iDGreen < 4
iDBlue >= -4 && iDBlue < 4
TryDifferentialHalf
iRed >= 0 && iRed <= 31
iGreen >= 0 && iGreen <= 31
iBlue >= 0 && iBlue <= 31
ptry < &a_phalf->m_atry[DifferentialTrys::Half::MAX_TRYS]
ptry->m_fError < FLT_MAX
TryIndividualHalf
iRed >= 0 && iRed <= 15
iGreen >= 0 && iGreen <= 15
iBlue >= 0 && iBlue <= 15
ptry < &a_phalf->m_atry[IndividualTrys::Half::MAX_TRYS]
m_mode == MODE_ETC1
iDRed2 >= -4 && iDRed2 < 4
iDGreen2 >= -4 && iDGreen2 < 4
iDBlue2 >= -4 && iDBlue2 < 4
InitFromEncodingBits
EtcBlock4x4Encoding_R11.cpp
CalculateR11
fMinRed <= fMaxRed
EtcBlock4x4Encoding_RG11.cpp
CalculateG11
fMinGrn <= fMaxGrn
EtcBlock4x4Encoding_RGB8.cpp
CalculateBaseColorsForTAndH
uiTransparentPixels < PIXELS
SetEncodingBits_T
m_mode == MODE_T
m_boolDiff == true
iRed2 < 0 || iRed2 > 31
SetEncodingBits_H
m_mode == MODE_H
iRed2 >= 0 && iRed2 <= 31
iGreen2 < 0 || iGreen2 > 31
SetEncodingBits_Planar
m_mode == MODE_PLANAR
iGreen2 >= 0 && iGreen2 <= 31
iBlue2 < 0 || iBlue2 > 31
EtcBlock4x4Encoding_RGB8A1.cpp
!m_boolOpaque
!m_boolTransparent
SetEncodingBits_ETC1
m_boolDiff
!m_boolPunchThroughPixels
m_boolTransparent
m_uiEncodingIterations == 0
EtcBlock4x4Encoding_RGBA8.cpp
CalculateA8
fMinAlpha <= fMaxAlpha
DifferentialTrys
EtcDifferentialTrys.cpp
a_uiRadius <= MAX_RADIUS
iRed1 >= (signed)(0 + a_uiRadius) && iRed1 <= (signed)(31 - a_uiRadius)
iRed2 >= (signed)(0 + a_uiRadius) && iRed2 <= (signed)(31 - a_uiRadius)
iGreen1 >= (signed)(0 + a_uiRadius) && iGreen1 <= (signed)(31 - a_uiRadius)
iGreen2 >= (signed)(0 + a_uiRadius) && iGreen2 <= (signed)(31 - a_uiRadius)
iBlue1 >= (signed)(0+a_uiRadius) && iBlue1 <= (signed)(31 - a_uiRadius)
iBlue2 >= (signed)(0 + a_uiRadius) && iBlue2 <= (signed)(31 - a_uiRadius)
IndividualTrys
EtcIndividualTrys.cpp
AddBlock
EtcSortedBlockList.cpp
m_uiAddedBlocks < m_uiImageBlocks
Sort
m_uiAddedBlocks == m_uiImageBlocks
pbucket->plinkLast->GetNext() == nullptr
%3d: e=%.3f rms=%.6f %u
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc6h/zohone.cpp
float ZOH::refineone(const Tile &, int, const FltEndpts *, char *)
data && availdatabits > 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc6h/bits.h
ZOH::Bits::Bits(const char *, int)
nbits >= 0 && nbits < 32
int ZOH::Bits::read(int)
bptr < bend
int ZOH::Bits::readone()
bw[10],bw[11],bw[12],bw[13],bw[14],bw[15],bx[3:0],gw[10],gw[11],gw[12],gw[13],gw[14],gw[15],gx[3:0],rw[10],rw[11],rw[12],rw[13],rw[14],rw[15],rx[3:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
bw[10],bw[11],bx[7:0],gw[10],gw[11],gx[7:0],rw[10],rw[11],rx[7:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
bw[10],bx[8:0],gw[10],gx[8:0],rw[10],rx[8:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
bx[9:0],gx[9:0],rx[9:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
data && maxdatabits > 0
ZOH::Bits::Bits(char *, int)
void ZOH::Bits::write(int, int)
void ZOH::Bits::writeone(int)
bptr < maxbits
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc6h/zohtwo.cpp
float ZOH::refinetwo(const Tile &, int, const FltEndpts *, char *)
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bz[1],bw[10],bx[3:0],gz[3:0],bz[0],gw[10],gx[3:0],gy[3:0],rw[10],rx[4:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
d[4:0],bz[3],gy[4],rz[3:0],bz[2],bz[0],ry[3:0],by[3:0],bz[1],bw[10],bx[3:0],gz[3:0],gw[10],gx[4:0],gy[3:0],gz[4],rw[10],rx[3:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
d[4:0],bz[3],bz[4],rz[3:0],bz[2:1],ry[3:0],by[3:0],bw[10],bx[4:0],gz[3:0],bz[0],gw[10],gx[3:0],gy[3:0],by[4],rw[10],rx[3:0],bw[9:0],gw[9:0],rw[9:0],m[4:0]
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bz[1],bx[4:0],gz[3:0],bz[0],gx[4:0],gy[3:0],gz[4],rx[4:0],bw[9:0],gw[9:0],rw[9:0],bz[4],by[4],gy[4],m[1:0]
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bz[1],bx[4:0],gz[3:0],bz[0],gx[4:0],gy[3:0],gz[4],rx[4:0],bz[4],bw[8:0],gy[4],gw[8:0],by[4],rw[8:0],m[4:0]
d[4:0],rz[5:0],ry[5:0],by[3:0],bz[1],bx[4:0],gz[3:0],bz[0],gx[4:0],gy[3:0],rx[5:0],bz[4:3],bw[7:0],gy[4],bz[2],gw[7:0],by[4],gz[4],rw[7:0],m[4:0]
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bz[1],bx[4:0],gz[3:0],gx[5:0],gy[3:0],gz[4],rx[4:0],bz[4],gz[5],bw[7:0],gy[4],gy[5],gw[7:0],by[4],bz[0],rw[7:0],m[4:0]
d[4:0],bz[3],rz[4:0],bz[2],ry[4:0],by[3:0],bx[5:0],gz[3:0],bz[0],gx[4:0],gy[3:0],gz[4],rx[4:0],bz[4],bz[5],bw[7:0],gy[4],by[5],gw[7:0],by[4],bz[1],rw[7:0],m[4:0]
d[4:0],rz[5:0],ry[5:0],by[3:0],bx[5:0],gz[3:0],gx[5:0],gy[3:0],rx[5:0],bz[4],bz[5],bz[3],bw[6:0],gy[4],bz[2],by[5],gw[6:0],by[4],bz[1:0],rw[6:0],gz[5:4],gy[5],m[1:0]
d[4:0],rz[5:0],ry[5:0],by[3:0],bx[5:0],gz[3:0],gx[5:0],gy[3:0],rx[5:0],bz[4],bz[5],bz[3],gz[5],bw[5:0],gy[4],bz[2],by[5],gy[5],gw[5:0],by[4],bz[1:0],gz[4],rw[5:0],m[4:0]
in.getptr() == AVPCL::BITSIZE
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode0.cpp
void AVPCL::decompress_mode0(const char *, Tile &)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/bits.h
AVPCL::Bits::Bits(const char *, int)
void read_header(Bits &, IntEndptsRGB_2 *, int &, Pattern &, int &)
in.getptr() == patterns[pat_index].modebits
in.getptr() == 83
int AVPCL::Bits::read(int)
int AVPCL::Bits::readone()
compr_endpts.A[j] < 16
void compress_one(const IntEndptsRGB &, IntEndptsRGB_2 &)
compr_endpts.B[j] < 16
shapes[((shapeindex)&3)*4+((shapeindex)>>2)*64+(x)+(y)*16] == region
void swap_indices(IntEndptsRGB_2 *, int (*)[4], int)
orig_indices[i] != -1
float optimize_one(const Vector4 *, const float *, int, float, const IntEndptsRGB_2 &, const RegionPrec &, IntEndptsRGB_2 &)
new_indices[i] != -1
out.getptr() == AVPCL::BITSIZE
void emit_block(const IntEndptsRGB_2 *, int, const Pattern &, const int (*)[4], char *)
AVPCL::Bits::Bits(char *, int)
out.getptr() == 83
void write_header(const IntEndptsRGB_2 *, int, const Pattern &, Bits &)
void AVPCL::Bits::write(int, int)
void AVPCL::Bits::writeone(int)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode1.cpp
void AVPCL::decompress_mode1(const char *, Tile &)
void read_header(Bits &, IntEndptsRGB_1 *, int &, Pattern &, int &)
in.getptr() == 82
compr_endpts.A[j] < 64
void compress_one(const IntEndptsRGB &, IntEndptsRGB_1 &)
compr_endpts.B[j] < 64
void swap_indices(IntEndptsRGB_1 *, int (*)[4], int)
float optimize_one(const Vector4 *, const float *, int, float, const IntEndptsRGB_1 &, const RegionPrec &, IntEndptsRGB_1 &)
void emit_block(const IntEndptsRGB_1 *, int, const Pattern &, const int (*)[4], char *)
out.getptr() == 82
void write_header(const IntEndptsRGB_1 *, int, const Pattern &, Bits &)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode2.cpp
void AVPCL::decompress_mode2(const char *, Tile &)
void read_header(Bits &, IntEndptsRGB *, int &, Pattern &, int &)
in.getptr() == 99
void swap_indices(IntEndptsRGB *, int (*)[4], int)
float optimize_one(const Vector4 *, const float *, int, float, const IntEndptsRGB &, const RegionPrec &, IntEndptsRGB &)
void emit_block(const IntEndptsRGB *, int, const Pattern &, const int (*)[4], char *)
out.getptr() == 99
void write_header(const IntEndptsRGB *, int, const Pattern &, Bits &)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode3.cpp
void AVPCL::decompress_mode3(const char *, Tile &)
in.getptr() == 98
compr_endpts.A[j] < 128
compr_endpts.B[j] < 128
out.getptr() == 98
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode4.cpp
void AVPCL::decompress_mode4(const char *, Tile &)
void read_header(Bits &, IntEndptsRGBA *, int &, int &, int &, Pattern &, int &)
in.getptr() == 50
void assign_indices(const Tile &, int, int, int, IntEndptsRGBA *, const PatternPrec &, int (*)[4][4], float *)
orig_indices[j][i] != -1
float optimize_one(const Vector4 *, const float *, int, int, int, float, const IntEndptsRGBA &, const RegionPrec &, IntEndptsRGBA &)
float map_colors(const Vector4 *, const float *, int, int, int, const IntEndptsRGBA &, const RegionPrec &, float, int (*)[16])
void emit_block(const IntEndptsRGBA *, int, const Pattern &, const int (*)[4][4], int, int, char *)
out.getptr() == 50
void write_header(const IntEndptsRGBA *, int, const Pattern &, int, int, Bits &)
(indices[((indexmode == INDEXMODE_ALPHA_IS_2BITS) ? 1 : 0)][0][0] & (1<<(2-1))) == 0
void write_indices(const int (*)[4][4], int, int, Bits &)
(indices[((indexmode == INDEXMODE_ALPHA_IS_3BITS) ? 1 : 0)][0][0] & (1<<(3-1))) == 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode5.cpp
void AVPCL::decompress_mode5(const char *, Tile &)
in.getptr() == 66
out.getptr() == 66
(indices[((indexmode == INDEXMODE_ALPHA_IS_3BITS) ? 1 : 0)][0][0] & (1<<(2-1))) == 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode6.cpp
void AVPCL::decompress_mode6(const char *, Tile &)
void read_header(Bits &, IntEndptsRGBA_2 *, int &, Pattern &, int &)
in.getptr() == 65
void compress_one(const IntEndptsRGBA &, IntEndptsRGBA_2 &)
float optimize_one(const Vector4 *, const float *, int, float, const IntEndptsRGBA_2 &, const RegionPrec &, IntEndptsRGBA_2 &)
void emit_block(const IntEndptsRGBA_2 *, int, const Pattern &, const int (*)[4], char *)
out.getptr() == 65
void write_header(const IntEndptsRGBA_2 *, int, const Pattern &, Bits &)
(indices[0][0] & (1<<(4-1))) == 0
void write_indices(const int (*)[4], int, Bits &)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_mode7.cpp
void AVPCL::decompress_mode7(const char *, Tile &)
compr_endpts.A[j] < 32
compr_endpts.B[j] < 32
void swap_indices(IntEndptsRGBA_2 *, int (*)[4], int)
denom == 3 || denom == 7 || denom == 15
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/bc7/avpcl_utils.cpp
static int AVPCL::Utils::lerp(int, int, int, int, int)
i >= 0 && i <= denom
bias >= 0 && bias <= denom/2
a >= 0 && b >= 0
static Vector4 AVPCL::Utils::lerp(Vector4::Arg, Vector4::Arg, int, int, int)
prec > 3
static int AVPCL::Utils::unquantize(int, int)
static int AVPCL::Utils::quantize(float, int)
unq <= 255
q >= 0 && q < (1 << prec)
(R==r) && (A==a)
static float AVPCL::Utils::premult(float, float)
Dumping stacktrace:
s_sig_handler_enabled != true
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/Debug.cpp
void nv::debug::enableSigHandler(bool)
s_sig_handler_enabled == true
void nv::debug::disableSigHandler()
  In: '%s'
  In: [%s] '%s'
Got signal %d, faulty address is %p, from %p
Got signal %d, faulty address is %p
Breakpoint hit.
Got signal %d
*** Assertion failed: %s
    On file: %s
    On function: %s
    On line: %d
*** Assertion failed: %s
    On file: %s
    On line: %d
base >= 2
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/StrLib.cpp
StringBuilder &nv::StringBuilder::number(int, int)
base <= 36
StringBuilder &nv::StringBuilder::number(uint, int)
size_hint != 0
StringBuilder &nv::StringBuilder::reserve(uint)
s != __null
StringBuilder &nv::StringBuilder::copy(const char *)
StringBuilder &nv::StringBuilder::copy(const char *, uint)
s.m_size == 0
StringBuilder &nv::StringBuilder::copy(const StringBuilder &)
!isNull()
void nv::Path::appendSeparator(char)
m_str != __null
void nv::Path::stripFileName()
void nv::Path::stripExtension()
str != __null
static const char *nv::Path::fileName(const char *)
static const char *nv::Path::extension(const char *)
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
count < 0xFFFF
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/StrLib.h
void nv::String::setRefCount(uint16)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/TextWriter.cpp
nv::TextWriter::TextWriter(Stream *)
s->isSaving()
channel >= 0 && channel < 4
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/ColorBlock.cpp
void nv::AlphaBlock4x4::init(const ColorBlock &, uint)
(rmask & gmask) == 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/DirectDrawSurface.cpp
void nv::DDSHeader::setPixelFormat(uint, uint, uint, uint, uint)
(rmask & bmask) == 0
(rmask & amask) == 0
(gmask & bmask) == 0
(gmask & amask) == 0
(bmask & amask) == 0
bitcount > 0 && bitcount <= 32
Flags: 0x%.8X
Height: %d
Width: %d
Depth: %d
Pitch: %d
Linear size: %d
Mipmap count: %d
Flags: 0x%.8X
FourCC: '%c%c%c%c' (0x%.8X)
Swizzle: '%c%c%c%c' (0x%.8X)
Bit count: %d
Red mask:   0x%.8X
Green mask: 0x%.8X
Blue mask:  0x%.8X
Alpha mask: 0x%.8X
Caps 1: 0x%.8X
Caps 2: 0x%.8X
Caps 3: 0x%.8X
Caps 4: 0x%.8X
DXGI Format: %u (%s)
Resource dimension: %u (%s)
Misc flag: %u
Array size: %u
NVIDIA Texture Tools %d.%d.%d
User Version: %d
R32G32B32A32_TYPELESS
R32G32B32A32_FLOAT
R32G32B32A32_UINT
R32G32B32A32_SINT
R32G32B32_TYPELESS
R32G32B32_FLOAT
R32G32B32_UINT
R32G32B32_SINT
R16G16B16A16_TYPELESS
R16G16B16A16_FLOAT
R16G16B16A16_UNORM
R16G16B16A16_UINT
R16G16B16A16_SNORM
R16G16B16A16_SINT
R32G32_TYPELESS
R32G32_FLOAT
R32G32_UINT
R32G32_SINT
R32G8X24_TYPELESS
D32_FLOAT_S8X24_UINT
R32_FLOAT_X8X24_TYPELESS
X32_TYPELESS_G8X24_UINT
R10G10B10A2_TYPELESS
R10G10B10A2_UNORM
R10G10B10A2_UINT
R11G11B10_FLOAT
R8G8B8A8_TYPELESS
R8G8B8A8_UNORM
R8G8B8A8_UNORM_SRGB
R8G8B8A8_UINT
R8G8B8A8_SNORM
R8G8B8A8_SINT
R16G16_TYPELESS
R16G16_FLOAT
R16G16_UNORM
R16G16_UINT
R16G16_SNORM
R16G16_SINT
R32_TYPELESS
D32_FLOAT
R32_FLOAT
R32_UINT
R32_SINT
R24G8_TYPELESS
D24_UNORM_S8_UINT
R24_UNORM_X8_TYPELESS
X24_TYPELESS_G8_UINT
R8G8_TYPELESS
R8G8_UNORM
R8G8_UINT
R8G8_SNORM
R8G8_SINT
R16_TYPELESS
R16_FLOAT
D16_UNORM
R16_UNORM
R16_UINT
R16_SNORM
R16_SINT
R8_TYPELESS
R8_UNORM
R8_UINT
R8_SNORM
R8_SINT
A8_UNORM
R1_UNORM
R9G9B9E5_SHAREDEXP
R8G8_B8G8_UNORM
G8R8_G8B8_UNORM
BC1_TYPELESS
BC1_UNORM
BC1_UNORM_SRGB
BC2_TYPELESS
BC2_UNORM
BC2_UNORM_SRGB
BC3_TYPELESS
BC3_UNORM
BC3_UNORM_SRGB
BC4_TYPELESS
BC4_UNORM
BC4_SNORM
BC5_TYPELESS
BC5_UNORM
BC5_SNORM
B5G6R5_UNORM
B5G5R5A1_UNORM
B8G8R8A8_UNORM
B8G8R8X8_UNORM
BUFFER
TEXTURE1D
TEXTURE2D
TEXTURE3D
Pixel Format:
Caps:
Version:
DX10 Header:
DDSCAPS2_CUBEMAP
DDSCAPS2_CUBEMAP_NEGATIVEZ
DDSCAPS2_CUBEMAP_POSITIVEZ
DDSCAPS2_CUBEMAP_NEGATIVEY
DDSCAPS2_CUBEMAP_POSITIVEY
DDSCAPS2_CUBEMAP_NEGATIVEX
DDSCAPS2_CUBEMAP_POSITIVEX
DDSCAPS2_CUBEMAP_ALL_FACES
DDSCAPS2_VOLUME
DDSCAPS_MIPMAP
DDSCAPS_TEXTURE
DDSCAPS_COMPLEX
DDPF_NORMAL
DDPF_ALPHAPREMULT
DDPF_PALETTEINDEXED8
DDPF_PALETTEINDEXED4
DDPF_PALETTEINDEXED2
DDPF_PALETTEINDEXED1
DDPF_ALPHA
DDPF_ALPHAPIXELS
DDPF_FOURCC
DDPF_LUMINANCE
DDPF_RGB
DDSD_MIPMAPCOUNT
DDSD_LINEARSIZE
DDSD_PITCH
DDSD_DEPTH
DDSD_HEIGHT
DDSD_WIDTH
DDSD_PIXELFORMAT
DDSD_CAPS
%d: %f
m_windowSize == 3
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/Filter.cpp
void nv::Kernel2::initEdgeDetection()
m_windowSize == 9
void nv::Kernel2::initBlendedSobel(const Vector4 &)
%d: 
 %6.4f
img != __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/FloatImage.cpp
void nv::FloatImage::initFrom(const Image *)
num <= 4
Image *nv::FloatImage::createImage(uint, uint) const
baseComponent + num <= m_componentCount
m_componentCount == 4
Image *nv::FloatImage::createImageGammaCorrect(float) const
src < m_componentCount
void nv::FloatImage::copyChannel(uint, uint)
dst < m_componentCount
baseComponent + 3 <= m_componentCount
void nv::FloatImage::normalize(uint)
baseComponent + 4 <= m_componentCount
void nv::FloatImage::transform(uint, const Matrix &, Vector4::Arg)
void nv::FloatImage::swizzle(uint, uint, uint, uint, uint)
r < 7 && g < 7 && b < 7 && a < 7
alpha < m_componentCount
FloatImage *nv::FloatImage::resize(const Filter &, uint, uint, WrapMode, uint) const
FloatImage *nv::FloatImage::resize(const Filter &, uint, uint, uint, WrapMode, uint) const
right - left <= windowSize
void nv::FloatImage::applyKernelY(const PolyphaseKernel &, int, int, uint, WrapMode, float *, int) const
void nv::FloatImage::applyKernelZ(const PolyphaseKernel &, int, int, uint, WrapMode, float *) const
void nv::FloatImage::applyKernelY(const PolyphaseKernel &, int, int, uint, uint, WrapMode, float *, int) const
.tga
.ppm
.hdr
.dds
image != __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/ImageIO.cpp
bool nv::ImageIO::saveFloat(const char *, Stream &, const FloatImage *, uint, uint)
unknown image type
bad png sig
bad bits_per_channel
multiple IHDR
bad IHDR len
too large
1/2/4/8/16-bit only
bad ctype
bad comp method
bad filter method
bad interlace method
0-pixel image
first not IHDR
invalid PLTE
tRNS after IDAT
tRNS before PLTE
bad tRNS len
tRNS with alpha
no PLTE
outofmem
outofdata
no IDAT
bad zlib header
no preset dict
bad compression
zlib corrupt
read past buffer
output buffer limit
bad sizes
bad codelengths
bad huffman code
bad dist
not enough pixels
invalid filter
invalid width
unsupported
bad offset
invalid
bad bpp
bad masks
not BMP
bad BMP
unknown BMP
BMP RLE
BMP JPEG/PNG
bad Image Descriptor
missing color table
unknown code
not GIF
no clear code
too many codes
illegal code in raster
not PSD
wrong version
wrong channel count
unsupported bit depth
wrong color format
corrupt
PICT
bad file
bad format
no SOI
no SOF
expected marker
bad DRI len
bad DQT type
bad DQT table
bad DHT header
bad COM len
bad APP len
unknown marker
bad code lengths
bad SOF len
only 8-bit
no header height
0 width
bad component count
bad H
bad V
bad TQ
bad DNL len
bad DNL height
bad SOS component count
bad SOS len
bad DC huff
bad AC huff
bad SOS
can't merge dc and ac
max value > 65535
#?RADIANCE
#?RADIANCE
#?RGBE
not HDR
FORMAT=32-bit_rle_rgbe
unsupported format
unsupported data layout
invalid decoded scanline length
bad palette
!s.isError()
bool saveTGA(Stream &, const Image *)
img->pixels() != __null
mem == __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvimage/TgaFile.h
void nv::TgaFile::allocate()
%d %d
s.isLoading()
FloatImage *loadFloatDDS(Stream &)
s.isSaving()
bool saveFloatDDS(Stream &, const FloatImage *, uint, uint)
p->name == __null
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvthread/Thread.cpp
void nv::Thread::setName(const char *)
thread pool
worker %d
bitCount <= 32
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/CompressionOptions.cpp
void nvtt::CompressionOptions::setPixelFormat(uint, uint, uint, uint, uint)
maxMask > rmask
maxMask > gmask
maxMask > bmask
maxMask > amask
rsize <= 32 && gsize <= 32 && bsize <= 32 && asize <= 32
void nvtt::CompressionOptions::setPixelFormat(uint8, uint8, uint8, uint8)
alphaThreshold >= 0 && alphaThreshold < 256
void nvtt::CompressionOptions::setQuantization(bool, bool, bool, int)
output_channel >= 0 && output_channel < 4
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/CompressorETC.cpp
void nv::decompress_eac(const void *, Vector4 *, int)
input_channel >= 0 && input_channel < 4
float nv::compress_eac(Vector4 *, float *, int, int, bool, void *)
data.mode == ETC_Data::Mode_ETC1
table_idx < 8
void get_diff_subblock_palette(uint16, uint, Color32 *)
bool get_diff_subblock_palette(uint16, uint16, uint, Color32 *)
void get_abs_subblock_palette(uint16, uint, Color32 *)
int get_partition(const ETC_Data &, int, int)
data.mode == ETC_Data::Mode_Planar
void decode_etc2_planar(const ETC_Data &, Vector4 *)
options.onebit_alpha == false
float compress_etc(Vector4 *, float *, const ETC_Options &, void *)
success
Vector3 unpack_color_555(uint32, uint32)
float compress_etc_a1(Vector4 *, float *, const ETC_Options &, void *)
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/CompressorRGB.cpp
virtual void nv::PixelFormatConverter::compress(nvtt::AlphaMode, uint, uint, uint, const float *, nvtt::TaskDispatcher *, const nvtt::CompressionOptions::Private &, const nvtt::OutputOptions::Private &)
arraySize == 1
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/Context.cpp
bool nvtt::Compressor::Private::outputHeader(nvtt::TextureType, int, int, int, int, int, bool, const CompressionOptions::Private &, const OutputOptions::Private &) const
m_count == 0
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvcore/RefCounted.h
virtual nv::RefCounted::~RefCounted()
m_count > 0
uint nv::WeakProxy::release() const
uint nv::RefCounted::release() const
i < deviceCount()
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/cuda/CudaUtils.cpp
bool nv::cuda::setDevice(int)
Unsupported block format, cannot decompress image data!
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/nvidia-texture-tools/src/nvtt/Surface.cpp
bool nvtt::Surface::load(const char *, bool *)
bool nvtt::Surface::save(const char *, bool, bool) const
image resized %dx%d -> %dx%d (error=%f)
image can't be resized further (error=%f)
Unspecified error code
No error detected
Error (generic)
Unknown frame descriptor
Version not supported
Unsupported frame parameter
Frame requires too much memory for decoding
Corrupted block detected
Restored data doesn't match checksum
Unsupported parameter
Parameter is out of bound
Context should be init first
Allocation error : not enough memory
workSpace buffer is not large enough
Operation not authorized at current processing stage
tableLog requires too much memory : unsupported
Unsupported max Symbol Value : too large
Specified maxSymbolValue is too small
Dictionary is corrupted
Dictionary mismatch
Cannot create Dictionary from provided samples
Destination buffer is too small
Src size is incorrect
Operation on NULL destination buffer
Frame index is too large
An I/O error occurred when reading/seeking
Destination buffer is wrong
Source buffer is wrong
1.4.9
WARNING: The maximum dictionary size %u is too large compared to the source size %u! size(source)/size(dictionary) = %f, but it should be >= 10! This may lead to a subpar dictionary! We recommend training on sources at least 10x, and preferably 100x the size of the dictionary! 
Cover parameters incorrect
Cover must have at least one input file
dictBufferCapacity must be at least %u
Failed to allocate dmer map: out of memory
Building dictionary
Constructed dictionary of size %u
Incorrect parameters
Trying %u different sets of parameters
d=%u
Failed to initialize context
k=%u
Failed to allocate parameters
%u%%       
%79s
FASTCOVER parameters incorrect
FASTCOVER must have at least one input file
Incorrect splitPoint
Incorrect accel
Incorrect k
%70s
statistics ... 
Total samples size is too large (%u MB), maximum size is %u MB
Total number of training samples is %u and is invalid.
Total number of testing samples is %u and is invalid.
Training on %u samples of total size %u
Testing on %u samples of total size %u
Failed to allocate scratch buffers
Constructing partial suffix array
Computing frequencies
Breaking content into %u epochs of size %u
Failed to allocate buffers: out of memory
Failed to select dictionary
Total number of training samples is %u and is invalid
Total number of testing samples is %u and is invalid.
Failed to allocate scratch buffers 
Failed to allocate frequency table 
Not enough memory 
 HUF_buildCTable error 
warning : pathological dataset : literals are not compressible : samples are noisy or too regular 
FSE_normalizeCount error with offcodeCount 
FSE_normalizeCount error with matchLengthCount 
FSE_normalizeCount error with litLengthCount 
HUF_writeCTable error 
FSE_writeNCount error with offcodeNCount 
FSE_writeNCount error with matchLengthNCount 
FSE_writeNCount error with litlengthNCount 
not enough space to write RepOffsets 
warning : ZSTD_compressBegin_usingCDict failed 
warning : could not compress sample size %u 
 %u segments found, of total size %u 
list %u best segments 
%3u:%3u bytes at pos %8u, savings %7u bytes |
!  warning : selected content significantly smaller than requested (%u < %u) 
!  consider increasing the number of samples (total size : %u MB)
!  consider increasing selectivity to produce larger dictionary (-s%u) 
!  note : larger dictionaries are not necessarily better, test its efficiency on samples 
!  note : calculated dictionary significantly larger than requested (%u > %u) 
!  consider increasing dictionary size, or produce denser dictionary (-s%u) 
!  always test dictionary efficiency on real samples 
sample set too large : reduced to %u MB ...
sorting %u files of total size %u MB ...
finding patterns ... 
minimum ratio : %u 
%4.2f %% 
found %3u matches of length >= %i at pos %7u  
Selected dict at position %u, of length %u : saves %u (ratio: %.2f)  
KTXorientation
S=%c,T=%c,R=%c
KTXanimData
 / libktx 
Unidentified app
__default__
v4.0.__default__
v4.0
KTXcubemapIncomplete
KTXglFormat
KTXdxgiFormat__
KTXmetalPixelFormat
KTXswizzle
KTXwriterScParams
KTXastcDecodeMode
00"0000000000000000000000000000000000000000000000
IIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIII
IIIII
00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899
]xEc
vH7B
W4vC
MbP?-C
]r2<
 9^;
cZK;#
%9)0
GTg8^
v?8i
-(;aU,$
G#]X
Q)b9
z@c"J
BN$N(
s\a=
$qE}
#a%
10WriterNull
10Compressor
11NonCopyable
N12_GLOBAL__N_113AssertHandlerE
N2nv13AssertHandlerE
12Decompressor
N12_GLOBAL__N_113AssertHandlerE
6Writer
N4nvtt13OutputHandlerE
9BaseImage
NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
11BaseSurface
17UncompressedImage
N2nv14StdInputStreamE
19UncompressedSurface
compression_quality=
9WriterDds
17CompressedSurface
15CompressedImage
N2nv9StdStreamE
N2nv6StreamE
KTX 11
KTX 11
9WriterKtx
q10WriterKtx2
2.0.160003
17DecompressorMetal
NSt3__117bad_function_callE
13CompressorArm
15DecompressorArm
18CompressorEtc2Comp
14CompressorIspc
14CompressorNvtt
N4nvtt24SequentialTaskDispatcherE
N4nvtt14TaskDispatcherE
16DecompressorNvtt
 $(,048<
15CompressorPvrtc
17DecompressorPvrtc
13CompressorStb

   !! "
!!!""!$
"""##"%
###$$#$$$$$%%$%%%%%&&%&&&&&''&'''''(('((((())()))))**)*****++*(0+++,,+)1,,,--,+0---..-,1...//..0///00.0/1.0001102/1112214.2223325/333443444445545555566566666776777778878888899899999::9:::::;;:;;;;;<<;<<<<<==<=====>>=>>>>>??>????
?%!!?
9?JBB?
Z?^cc?
<?BAA?
?/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:771:5: Assertion failed: bits>=2 && bits<=4 
PPPP@@@@TTTT@PPT
@@PPTTU@PTU
@PPTUU
@T@TUU
TPP@P@@
DDDD
PPAT
UPPPPU
TTPPh
@PZj
UUPPZZ
@@jj
$$$$
P(i(iD
fffDDD
TRJ*33
33DD
0033
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1072:2: Assertion failed: bits >= 4 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1163:2: Assertion failed: mode <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1183:3: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1163:2: Assertion failed: mode <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1183:3: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1189:5: Assertion failed: mode <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1215:3: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1189:5: Assertion failed: mode <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1215:3: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1280:3: Assertion failed: best_q>=0 && best_q<=levels-1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1280:3: Assertion failed: best_q>=0 && best_q<=levels-1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1799:2: Assertion failed: (qblock[0]&15) < levels/2 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1799:2: Assertion failed: (qblock[0]&15) < levels/2 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1831:2: Assertion failed: v<pow2(bits) 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1831:2: Assertion failed: v<pow2(bits) 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1844:3: Assertion failed: from > 64+10 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1951:13: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:1951:13: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2203:5: Assertion failed: span > 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2217:5: Assertion failed: mode_bits > 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2482:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2482:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2502:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 15 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2503:13: Assertion failed: -16 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2554:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 31 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2555:13: Assertion failed: -32 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2627:13: Assertion failed: qep[i * 4 + p] - qep[p] <= (1<<bits)/2 - 1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2628:13: Assertion failed: -(1<<bits)/2 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2738:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 15 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2739:13: Assertion failed: -16 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2810:13: Assertion failed: qep[i * 4 + p] - qep[p] <= (1<<bits)/2 - 1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2811:13: Assertion failed: -(1<<bits)/2 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2971:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 255 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2972:13: Assertion failed: -256 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3008:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 127 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3009:13: Assertion failed: -128 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3045:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3046:13: Assertion failed: -8 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3072:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2502:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 15 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2503:13: Assertion failed: -16 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2554:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 31 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2555:13: Assertion failed: -32 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2627:13: Assertion failed: qep[i * 4 + p] - qep[p] <= (1<<bits)/2 - 1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2628:13: Assertion failed: -(1<<bits)/2 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2738:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 15 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2739:13: Assertion failed: -16 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2810:13: Assertion failed: qep[i * 4 + p] - qep[p] <= (1<<bits)/2 - 1 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2811:13: Assertion failed: -(1<<bits)/2 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2971:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 255 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:2972:13: Assertion failed: -256 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3008:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 127 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3009:13: Assertion failed: -128 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3045:13: Assertion failed: qep[i * 4 + p] - qep[p] <= 7 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3046:13: Assertion failed: -8 <= qep[i * 4 + p] - qep[p] 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3072:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3356:9: Assertion failed: best_q >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3356:9: Assertion failed: best_q >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3493:9: Assertion failed: idx < 165 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel.ispc:3493:9: Assertion failed: idx < 165 
 Ef$ 
e!@t
e\!Ptl!
%At#%Bt3%CtC%DsS%Enc%Fis%Gf
q+'Pt;'QjK'
)DT$)EO4)FKD)GHT)
+PT,+QL<+
H|+ T
1DT#1ET31FRC1GOS1HKc1IHs1JE
3BJ+3
G[4 Tk4!T{4"Q
j"6At26BtB6CtR6Dtb6Etr6Fr
g:8@tJ8ArZ8Bjj8
9Qr*9Rj:9
Sr;AT
<KK"<
>CM*>DH:>
E:?PTJ?QTZ?RRj?SMz?TH
E*@ T:@!TJ@"TZ@#Tj@$Nz@%E
CF4$CG34CH/DCI,TCJ*dCK&tC
',E@4<EA4LEB.\EC(lE
'<FP4LFQ4\FR.lFS(|F
F 4G!4
G"4,G#.<G$'LG`4\Ga4lGb.|Gc(
PH4#PI33PJ1CPK.SP
R@4+RA4;RB4KRC/[RD+kRE%{R
Ub4+Uc/;Ud+KUe%[U
taWAtqWBt
ZDk)ZEe9Z
jI[PtY[Qti[Rty[So
gY\ ti\!ty\"t
_B4"_C42_D4B_E4R_F4b_G4r_H4
e 4*e!4:e"4Je#4Ze$4je%4ze&1
fg'*f
iGT!iHT1iITAiJTQiKTai
E9k@TIkATYkBTikCTykDS
EImPTYmQTimRTymST
o%T)o&Q9o'LIo(EYo`TioaTyobT
4QrD4arE4qrF4
uJ))uK%9u
*9wQ4IwR4YwS4iwT4ywU4
%9y!4Iy"4Yy#4iy$4yy%4
zd4)ze49zf4Izg2Yzh.izi+yzj)
80?e
46=A
>r1F
>r1F
OyL?
295<295<
OyL?
_'?UM0
qo=UM0
_'?E,N?I
$H%?
$H%?
E,N?
<=2V
F"t=
A?~p^
7=~p^
A?F"t=
.R?z
;ge{
ek?;
C{;5{
s=Q/x
=ge{
Q/x=
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:570:5: Assertion failed: n <= 16 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:591:13: Assertion failed: e <= n 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:570:5: Assertion failed: n <= 16 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:591:13: Assertion failed: e <= n 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:609:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:609:9: Assertion failed: false 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1247:5: Assertion failed: state->fastSkipTreshold <= 64 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1286:5: Assertion failed: count >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1247:5: Assertion failed: state->fastSkipTreshold <= 64 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1286:5: Assertion failed: count >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1247:5: Assertion failed: state->fastSkipTreshold <= 64 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1286:5: Assertion failed: count >= 0 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1988:5: Assertion failed: pitch <= 64 
/AppleInternal/Library/BuildRoots/860631e9-c1c5-11ee-98ee-b6ef2fd8d87b/Library/Caches/com.apple.xbs/Sources/TextureConverter/ThirdParty/ispc-texture-compressor/ispc_texcomp/kernel_astc.ispc:1988:5: Assertion failed: pitch <= 64 
 !"#$%&'()*+,-./0123456789:;<=>?
Iqoa^[
?fff?
?33s?
?fff?
 A33
?33s?
?fff?
 Aff
p}?NSt3__110__function6__funcIZ22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmjE3$_0NS_9allocatorISA_EEFjvEEE
NSt3__110__function6__baseIFjvEEE
Z22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmjE3$_0
NSt3__110__function6__funcIZ22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmjE3$_1NS_9allocatorISA_EEFvvEEE
NSt3__110__function6__baseIFvvEEE
Z22astcenc_compress_imageP15astcenc_contextP13astcenc_imagePK15astcenc_swizzlePhmjE3$_1
 !"$%&()*01245689:#'/37;,-.@ABDEFHIJPQRTUVXYZCGOSW[LMN
`abdefhijpqrtuvxyzcgosw{lmn
<=>\]^
 !"#$()*+,0123489:;<%-5=
@ABCDHIJKLPQRSTXYZ[\EMU]
`abcdhijklpqrstxyz{|emu}
fgFG&noNO.vwVW6~
^_>'/7?
*3-30B
CrQjRjAZSJQ
B8R8S8C03
*B"Q"
2A*B
RTCD
OOwB
"b Q
lb,O
aysqSiCYAK
q"sH![
,!.R,3|
ry_p
hbaSYnXaMRsYC
3!+.
"C]"1#q"
r`B9m8
wbl3
.n7B$m
,"%Ql
aSarQ
QGPC
IFHbI7
0%Ra*
!q"!Cs8
RE05HR
*Q#%
2UQ%
5b
_8SAC9bA78G8sq
1HiF0
2v0M*
Xn0$)a*
POp!
+%"s(eH
q"E(-
4QERdb\
%B,r
5q
X4eZP
S4Q$U
HKP~HDS
qyh9C1
1_8S1n070
0b1O0u0;
(sQsP
)J z F HA
#D9e $
Q2I 
%3<R
]>4
=#
uPGHSQUI
F@7@
a61v0s1
@7A!;
#e %
Q%R5I
3DC<5l
XFY(YtQoX
1v870U)
)'0~(
+G(b1sQ6I_(
 &!HAn 
!e!!S
R5<"-
fxd{
yuyjh
ta(a
aT[cQV
kK8H9S1Z841
`sYv0
(a2u(
 $-n _(
 6)G@7 
' O@F8
9sHU
2-QU
'.#
Bq
adcuQD]fX
ITSt
@cIJA
9rA~8Z@
1V0+)F1'1
hn(s!b)
 O@S!C)
 6!;
#u K
]tQM
$/B<#
(qdct
4]fXuYTS
IyAc
hV0F1
1H1aZ
H8HS) C)s!
!+!!
"'!s
(z +
]<><
{(qtyyadk
ij`$gD
ITHo
@aBd@~@Z8
2H1_0S)
0C)
(+Ib)n(
)s!'!
b,!.
d}34
->q
TQM]D1
333?
Iy^!I)>
H.yrH&3
F9'gF$y
333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIImmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
88888888888888888888888888888888888888888888888888888888TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
..............................................EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ttttttttttttttttttttttttttttttttttttttttttttttt
""""""""""""""""""""""""""""""""""3333333333333333333333333333333333DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUffffffffffffffffffffffffffffffffffwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww
(((((((((((((((((((((((((((666666666666666666666666666CCCCCCCCCCCCCCCCCCCCCCCCCCPPPPPPPPPPPPPPPPPPPPPPPPPPP^^^^^^^^^^^^^^^^^^^^^^^^^^^kkkkkkkkkkkkkkkkkkkkkkkkkkkyyyyyyyyyyyyyyyyyyyyyyyyyyy
!!!!!!!!!!!!!!!!!!!!!!,,,,,,,,,,,,,,,,,,,,,,7777777777777777777777BBBBBBBBBBBBBBBBBBBBBBMMMMMMMMMMMMMMMMMMMMMMXXXXXXXXXXXXXXXXXXXXXXccccccccccccccccccccccnnnnnnnnnnnnnnnnnnnnnnyyyyyyyyyyyyyyyyyyyyyyyy
!!!!!!!!!!!!!!!!!))))))))))))))))111111111111111199999999999999999BBBBBBBBBBBBBBBBBJJJJJJJJJJJJJJJJRRRRRRRRRRRRRRRRZZZZZZZZZZZZZZZZZccccccccccccccccckkkkkkkkkkkkkkkkssssssssssssssss{{{{{{{{{{{{{{{{{
             '''''''''''''-------------4444444444444:::::::::::::AAAAAAAAAAAAAGGGGGGGGGGGGGNNNNNNNNNNNNNTTTTTTTTTTTTT[[[[[[[[[[[[[aaaaaaaaaaaaahhhhhhhhhhhhhnnnnnnnnnnnnnuuuuuuuuuuuuu{{{{{{{{{{{{{{{
           &&&&&&&&&&&++++++++++0000000000066666666666;;;;;;;;;;;AAAAAAAAAAAFFFFFFFFFFFLLLLLLLLLLLQQQQQQQQQQVVVVVVVVVVV\\\\\\\\\\\aaaaaaaaaaagggggggggggllllllllllqqqqqqqqqqqwwwwwwwwwww||||||||||||

        $$$$$$$$((((((((,,,,,,,,000000004444444488888888<<<<<<<<<AAAAAAAAAEEEEEEEEIIIIIIIIMMMMMMMMQQQQQQQQUUUUUUUUYYYYYYYY]]]]]]]]aaaaaaaaeeeeeeeeiiiiiiiimmmmmmmmqqqqqqqquuuuuuuuyyyyyyyy}}}}}}}}}
      ######&&&&&&&*******------0000003333336666666:::::::======@@@@@@CCCCCCCGGGGGGGJJJJJJMMMMMMPPPPPPSSSSSSSWWWWWWWZZZZZZ]]]]]]```````dddddddggggggjjjjjjmmmmmmppppppptttttttwwwwwwzzzzzz}}}}}}}}
      #####%%%%%((((((+++++-----0000003333355555888888;;;;;=====@@@@@@CCCCCCFFFFFHHHHHKKKKKKNNNNNPPPPPSSSSSSVVVVVXXXXX[[[[[[^^^^^`````ccccccfffffhhhhhkkkkkknnnnnpppppssssssvvvvvxxxxx{{{{{{~~~~~~

    """"$$$$&&&&((((****,,,,....00002222444466668888::::<<<<>>>>@@@@BBBBDDDDFFFFHHHHJJJJLLLLNNNNPPPPRRRRTTTTVVVVXXXXZZZZ\\\\^^^^````bbbbddddffffhhhhjjjjllllnnnnpppprrrrttttvvvvxxxxzzzz||||~~~~~
   !!!###$$$&&&&((()))+++,,,....0001113334446666888999;;;<<<>>>>@@@AAACCCDDDFFFFHHHIIIKKKLLLNNNNPPPQQQSSSTTTVVVVXXXYYY[[[\\\^^^^```aaacccdddffffhhhiiikkklllnnnnpppqqqssstttvvvvxxxyyy{{{|||~~~~~
   !!"""$$$%%&&&((())***,,,--...000112224445566688899:::<<<==>>>@@@AABBBDDDEEFFFHHHIIJJJLLLMMNNNPPPQQRRRTTTUUVVVXXXYYZZZ\\\]]^^^```aabbbdddeefffhhhiijjjlllmmnnnpppqqrrrtttuuvvvxxxyyzzz|||}}~~~~
  !!""##$$%%&&''(())**++,,--..//00112233445566778899::;;<<==>>??@@AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ[[\\]]^^__``aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~




       
"""""""

$$$$$$$
&&&&&&&&''''''''
%%%%%%%
#######
!!!!!!!
      
""""""
$$$$$
&&&&&&
((((((
******
,,,,,
......//////
-----
++++++
))))))
''''''
%%%%%
######
!!!!!!

    !!!!""""####$$$$%%%%&&&&''''(((())))****++++,,,,----..../////0000111122223333444455556666777788889999::::;;;;<<<<====>>>>???
   000@@@@
"""222BBBB
$$$4444DDD
&&&6666FFF
((((888HHH
****:::JJJ
,,,<<<LLL
...>>>NNNNOOOO???///
MMM===---
KKK;;;++++
III999))))
GGG7777'''
EEE5555%%%
CCCC333###
AAAA111!!!
   @@@
"""BBB
$$$DDD
&&&FFF
((HHH
**JJJ,,LLL
..NNN
000PPP
222RRR
444TTT
666VVV
888XXX
:::ZZZ
<<<\\\
>>>^^^___???
]]]===
[[[;;;
YYY999
WWW777
UUU555
SSS333
QQQ111
OOO//
MMM--
KKK++
III))
GGG'''
EEE%%%
CCC###
AAA!!!
  !!""##$$%%&&''(())**++,,--..//00112233445566778899::;;<<==>>???@@AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ[[\\]]^^__``aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~
 @@`
"BBb
$DDd
&FFf
(HHh
*JJj
,LLl
.NNn
0PPp
2RRr
4TTt
6VVv
8XXx
:ZZz
<\\|
>^^~
}]]=
{[[;
yYY9
wWW7
uUU5
sSS3
qQQ1
oOO/
mMM-
kKK+
iII)
gGG'
eEE%
cCC#
aAA!
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
"3DUfw
!)19BJRZcks{
 $(,048<AEIMQUY]aeimquy}
 "$&(*,.02468:<>@BDFHJLNPRTVXZ\^`bdfhjlnprtvxz|~
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~




%.7@
%.7@
$+29@
$)/5;@
#'+/48<@
#'+/48<@
#&)-037:=@
"%(*-0358;>@
"$&(*,.02468:<>@
"$&(*,.02468:<>@
>@NSt3__120__shared_ptr_pointerIPhZN3Etc13EncodeMipmapsEPfjjNS2_5Image6FormatENS2_11ErrorMetricEfjjjjPNS2_8RawImageEPibE3$_0NS_9allocatorIhEEEE
ZN3Etc13EncodeMipmapsEPfjjNS_5Image6FormatENS_11ErrorMetricEfjjjjPNS_8RawImageEPibE3$_0
NSt3__119__async_assoc_stateIvNS_12__async_funcIMN3Etc5ImageEFvjjEJPS3_ijEEEEE
NSt3__119__async_assoc_stateIjNS_12__async_funcIMN3Etc5ImageEFjjjjEJPS3_jijEEEEE
NSt3__113__assoc_stateIjEE
?N3Etc16Block4x4EncodingE
".Lr
N3Etc21Block4x4Encoding_ETC1E
N3Etc20Block4x4Encoding_R11E
!4>X
N3Etc21Block4x4Encoding_RG11E
N3Etc21Block4x4Encoding_RGB8E
N3Etc23Block4x4Encoding_RGB8A1E
N3Etc30Block4x4Encoding_RGB8A1_OpaqueE
N3Etc35Block4x4Encoding_RGB8A1_TransparentE
N3Etc22Block4x4Encoding_RGBA8E
N3Etc29Block4x4Encoding_RGBA8_OpaqueE
N3Etc34Block4x4Encoding_RGBA8_TransparentE
N12_GLOBAL__N_117UnixAssertHandlerE
$" &4206
gnpr
*******************%
************** "*****************************$
DDS |
NVTT
DX10
?UUU
?N2nv6FilterE
N2nv9BoxFilterE
N2nv14TriangleFilterE
N2nv15QuadraticFilterE
N2nv11CubicFilterE
N2nv13BSplineFilterE
N2nv14MitchellFilterE
N2nv13LanczosFilterE
N2nv10SincFilterE
N2nv12KaiserFilterE
N2nv14GaussianFilterE
tcccccc
ccccccc
ccccccc
!(0)"
#*1892+$
%,3:;4-&
'.5<=6/7>????????????????RGB
N2nv15StdOutputStreamE
KTX 11
F#DS
]p$o
S%'1
F(DS
]p)o
S*'1
F-DS
]p.o
S/'1
F2DS
]p3o
S4'1
F7DS
]p8o
S9'1
F<DS
]p=o
S>'1
FADS
]pBo
SC'1
FFDS
]pGo
SH'1
FKDS
]pLo
SM'1
FPDS
]pQo
SR'1
FUDS
]pVo
SW'1
FZDS
]p[o
N2nv20ColorBlockCompressorE
N2nv19CompressorInterfaceE
N2nv20FloatColorCompressorE
N2nv14CompressorDXT1E
N2nv18CompressorBC3_RGBME
N2nv14CompressorETC1E
N2nv16CompressorETC2_RE
N2nv17CompressorETC2_RGE
N2nv18CompressorETC2_RGBE
N2nv19CompressorETC2_RGBAE
N2nv19CompressorETC2_RGBME
DXT1DXT1DXT3DXT5DXT5ATI1ATI2DXT1
BC6HBC7LDXT5ETC1
ETC2
PVR0PVR1PVR2PVR3
N2nv17FastCompressorBC4E
N2nv17FastCompressorBC5E
N2nv23ProductionCompressorBC4E
N2nv23ProductionCompressorBC5E
N2nv13CompressorBC6E
N2nv13CompressorBC7E
N2nv19FastCompressorDXT1aE
N2nv18FastCompressorDXT3E
N2nv18FastCompressorDXT5E
N2nv19FastCompressorDXT5nE
N2nv15CompressorDXT1aE
N2nv19CompressorDXT1_LumaE
N2nv14CompressorDXT3E
N2nv14CompressorDXT5E
N2nv15CompressorDXT5nE
?%!!?
9?JBB?
Z?^cc?
*EEEE
EEEEEEEEEEEEEEE@
(CCCC
CCCCCCCCCCCCCCC>
#8888
8888888888888886N2nv20PixelFormatConverterE
 i+t6
N4nvtt22ParallelTaskDispatcherE
N4nvtt11CubeSurface7PrivateE
N2nv10RefCountedE
!)19BJRZcks{
AEIMQUY]aeimquy}
?%!!?
9?JBB?
Z?^cc?
<?BAA?
N4nvtt20DefaultOutputHandlerE
K{_~LLL]]]DDDJJJ:::RRRRRRRRR
#*>>>1
4TN4nvtt7Surface7PrivateE
N8nvsquish9ColourFitE
N8nvsquish18WeightedClusterFitE
(w)T
-269&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
=AE&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
9<?C
QW]cglp
#%')+-/VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV13579VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV;=?
68:<>@BDF
  !!""##$$$$%%%%&&&&&&&&''''''''(((((((((((((((())))))))))))))))********************************
\ww_,
zk&_
~NX4
_H^zvd
x`tm6
Sr]?
$8'S
$ffn
rq7x;P
)n/h%fPn
,!MbDg[
>ZF9
rT+6ZNw
izc}
Nl9\
x=9v
"f^n[
5nsfZ
^[L6
Vgh$
2aNuE
BTcq
2,THh
/fxLf
]k_W
Z/K]
(U$;s
hm~iD
KTX 11
KTX 20
KTX 11
KTX 20
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[[
[[[[[[
++++
wwwe
KKKKgggg
KTX 11
KTX 20
KTX 20
XXXX PNG chunk not known
