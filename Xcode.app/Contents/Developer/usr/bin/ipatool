#!/usr/bin/sandbox-exec -n no-network /usr/bin/ruby -E UTF-8 -v
# -*- coding: utf-8; mode: ruby -*-
#  A utility for performing various operations on IPA files.  This script is
#  intended to be invoked by xcodebuild.  It is not intended for direct use,
#  or for invocation in any manner other than through xcodebuild.  Any other
#  use is unsupported.
#  Copyright 
 2015-2018 Apple Inc. All Rights Reserved.
GC.disable
require 'optparse'
require 'cfpropertylist'
require 'shellwords'
require 'pathname'
require 'json'
require 'fileutils'
require 'find'
require 'tmpdir'
require 'ostruct'
require 'digest'
require 'sqlite3'
require 'pp'
require 'open3'
require 'set'
$stderr.puts "OS X #{`sw_vers -productVersion`.strip} #{`sw_vers -buildVersion`.strip}"
$stderr.puts "ENV: #{ENV.inspect}"
$stderr.puts "ARGV: #{ARGV.inspect}"
# Library
# If x fails, print message and backtrace, then exit(1)
def assert(x, message = nil)
  return if x
  $stderr.puts "Assertion failed: #{message}"
  $stderr.puts caller
  exit(1)
class Object
  # Useful as a way to add type annotations to code.
  def assert_kind_of(t, message = nil)
    assert(self.kind_of?(t), "#{self.class} is not kind of #{t}: #{message}")
  end
  # Useful as a way to add type annotations to code.
  def as(t, message = nil)
    assert_kind_of(t, message)
    self
  end
  # Useful as a way to add type annotations to code.
  def optional_as(t, message = nil)
    assert_kind_of(t, message)
    self
  end
  # Useful as a way to add type annotations to code.
  def assert_array_of(t, message = nil)
    assert_kind_of(Array, message)
    each{|x| x.assert_kind_of(t, message) }
  end
class NilClass
  # Useful as a way to add type annotations to code.
  def optional_as(t, message = nil)
    return nil
  end
class Hash
  def self.from_tuples(array)
    ret = self.new
    
    for k,v in array
      ret[k] = v
    end
    
    return ret
  end
  # Same as self[k] = v, but raises an exception if self[k] exists.
  def set_once(k, v)
    vOld = self[k]
    raise "Tried to set self[#{k.inspect}] = #{v.inspect}, but it's already set to #{vOld.inspect}." if vOld
    self[k] = v
  end
module Enumerable
  def group_using(&eql)
    groups = []
    for x in self
      done = false
      
      for g in groups
        if eql.call(g.first, x)
          g << x
          done = true
          break
        end
      end
      next if done
      groups << [x]
    end
    
    return groups
  end
  unless method_defined? :to_h
    def to_h
      return Hash.from_tuples(self)
    end
  end
class NilClass
  def nil_if_empty
    return nil
  end
module Enumerable
  def nil_if_empty
    return nil if self.size == 0
    return self
  end
class String
  def nil_if_empty
    return nil if self.size == 0
    return self
  end
class String
  def indent(level = 1)
    prefix = "    " * level
    return self.lines.
      map{|l| prefix + l}.
      join('') #lines retains \n
  end
  # We still support Ruby 2.0, so we need a workaround for unicode equivalence
  def unicode_equal?(other)
    return CmdSpec.new(locate_tool("python"), ["-c", "import sys; import unicodedata; print(unicodedata.normalize('NFC', sys.argv[1].decode('utf-8')) == unicodedata.normalize('NFC', sys.argv[2].decode('utf-8')))", self, other]).run(0, false, true).strip == "True"
  end
class Exception
  def to_log_s
    return "#{self.inspect}\n#{self.backtrace.join("\n").indent}"
  end
# Raises if it couldn't find it.
def locate_tool(name, additional_paths = [])
  return name if Pathname.new(name).absolute?
  path = (additional_paths||[]).map{|x|x.to_s}.join(File::PATH_SEPARATOR) + File::PATH_SEPARATOR + (ENV["PATH"] || "")
  paths = path.split(File::PATH_SEPARATOR).select{|p| p.nil_if_empty }
  candidates = paths.map{|p| p + "/" + name}
  result = candidates.detect{|p| File.executable?(p) }
  raise "Couldn't locate #{name.shellescape} in #{paths.shelljoin}" unless result.nil_if_empty
  return result
class CmdSpec
  attr_accessor :bin
  attr_accessor :args
  attr_accessor :env
  attr_accessor :chdir
  def initialize(bin, args, env = nil, chdir = nil)
    assert(bin)
    @bin = locate_tool(bin.to_s)
    @args = (args || []).map{|x|x.to_s}
    @env = (env || {}).map{|k,v| [k.to_s, v.to_s] }.to_h
    @chdir = chdir.to_s
  end
  def to_s
    chdir_s = if self.chdir.nil_if_empty then "cd #{self.chdir.shellescape} && " else "" end
    env_s = if self.env.nil_if_empty then self.env.map{|k,v| "#{k.shellescape}=#{v.shellescape} " }.join(' ') else "" end
    args_s = if self.args.nil_if_empty then " #{self.args.shelljoin}" else "" end
    return "#{chdir_s}#{env_s}#{bin.shellescape}#{args_s}"
  end
  def cache_key
    return "#{bin}#{args}#{env}#{chdir}"
  end
  class NonZeroExcitException < StandardError
    attr_reader :cmd_spec
    attr_reader :out_str
    attr_reader :err_str
    attr_reader :status
    def initialize(cmd_spec, out_str, err_str, status)
      @cmd_spec = cmd_spec
      @out_str = out_str
      @err_str = err_str
      @status = status
    end
  end
  # Raises NonZeroExcitException if the process exits with non-zero
  def run(log_indent = 0, verbose_log = true, use_cache = false)
    if use_cache
      $CMD_SPEC_CACHE ||= Hash.new
      key = self.cache_key
      
      cached_value = $CMD_SPEC_CACHE[key]
      if cached_value.nil?
        cached_value = self.run(log_indent, verbose_log, false)
        $CMD_SPEC_CACHE[key] = cached_value
      end
      
      return cached_value
    end
    
    $stderr.puts(self.to_s.indent(log_indent)) if verbose_log
    
    opts = {}
    opts[:chdir] = chdir if self.chdir.nil_if_empty
    out_str, err_str, status = Open3.capture3(self.env, self.bin, *self.args, opts)
    
    s = "Command exited with #{status}:\n#{self.to_s}\nStdout:\n#{out_str.indent}\nStderr:\n#{err_str.indent}\n"
    $stderr.puts(s.indent(log_indent+1)) if verbose_log
    
    unless status.success?
      raise NonZeroExcitException.new(self, out_str, err_str, status), s
    end
    
    return out_str
  end
# Resolves and stores a dependency graph for mach-o linkage. It stores an array of MachOImage dependencies per MachOImage.
class LinkageGraph
  # var graph : Hash <MachOImage -> [MachOImage]>
  def initialize
    @graph = Hash.new
  end
  def to_s(parent_path)
    img_to_s = lambda {|img|
      "#{img.machoFile.path.relative_path_from(parent_path)} #{img.arch}"
    }
    
    return @graph.each.map{|k, vs|
      "#{img_to_s.call(k)} ->\n#{vs.map{|v|img_to_s.call(v)}.join("\n").indent}"
    }.join("\n")
  end
  def [](x)
    return @graph[x]
  end
  def []=(x, y)
    return @graph[x] = y
  end
  # Resolve MachOImage dependencies for image.
  #   rpathStack : [Pathname] -- Holds the linker's @rpath stack. This accumulates as we chase further down the dependency tree.
  #   machOsByRealPath : { Pathname : FSMachOFileNode } -- Maps MachO files by real path so that we can resolve linkage paths to objects.
  #   executablePath : Pathname -- Current substitution for @executable_path.
  #   level : Int -- Log indentation level. This accumulates as we chase further down the dependency tree.
  def resolveLoadedDylibs(image, rpathFallbackStack, rpathStack = [], machOsByRealPath = {}, executablePath = nil, level = 0)
    # Did we already process this image?
    return if self[image]
    # If this is an executable, it becomes the new @executable_path
    executablePath = if image.type == "MH_EXECUTE" then image.machoFile.path.parent else executablePath end
    executablePath.assert_kind_of(Pathname) unless executablePath.nil?
    # Add its rpaths to the rpath stack
    rpaths = image.rpaths
    rpaths.assert_array_of(String)
    rpathStack = rpaths.map{|rpath|
      result = nil
      begin
        result = _expandPath(rpath, image, executablePath, [], rpathFallbackStack)
      rescue RuntimeError, SystemCallError, IOError => e
        EmitWarning(__LINE__, "Failed to resolve rpath for #{image.machoFile.path.basename}: #{e}")
        result = nil
      end
      result
    }.compact + rpathStack
    rpathStack.assert_array_of(Pathname)
    # Resolve its loaded libraries to MachOImage objects
    dylibs = image.loadedDylibs
    dylibs.assert_array_of(String)
    resolvedDylibs = dylibs.
      select{|n| !n.start_with?('/') }. # Skip absolute paths
      map{ |dylibName|
      resolvedImage = nil
      begin
        # Find a matching rpath to resolve against
        expandedPath = _expandPath(dylibName, image, executablePath, rpathStack, rpathFallbackStack).realpath
        # Find a model object
        resolvedMachO = machOsByRealPath[expandedPath] || (raise "Could not find MachO for #{expandedPath}")
        # Pick the best image/slice to link against
        resolvedImage = resolvedMachO.linkableImageForArch(image.arch) || (raise "Could not find image to link for #{image.arch} in #{expandedPath}")
      rescue RuntimeError, SystemCallError, IOError => e
        EmitWarning(__LINE__, "Failed to resolve linkage dependency #{image.machoFile.path.basename} #{image.arch} -> #{dylibName}: #{e}")
        resolvedImage = nil
      end
      resolvedImage
    }.compact
    resolvedDylibs.assert_array_of(MachOImage)
    
    self[image] = resolvedDylibs
    # $stderr.puts("LinkageGraph << #{image} ->\n#{resolvedDylibs.join("\n").indent}".indent(level))
    # Follow each dependency
    resolvedDylibs.each{|img| resolveLoadedDylibs(img, rpathFallbackStack, rpathStack, machOsByRealPath, executablePath, level + 1) }
  end
  # Expand @rpath/path -> /absolute/path.
  #   path : String - The linkage path to expand.
  #   image : MachOImage - The substitution for @loader_path.
  #   executablePath : Pathname - The substitution for @executable_path.
  #   rpathStack : [Pathname] - Stack of @rpath substitutions.
  def _expandPath(path, image, executablePath, rpathStack, rpathFallbackStack)
    s = path.dup
    if s =~ /^@executable_path/
      raise "Could not resolve @executable_path for #{path} from #{image.machoFile.path.basename}" unless executablePath
      s.gsub!(/^@executable_path/, executablePath.to_s)
    end
    s.gsub!(/^@loader_path/, image.machoFile.path.parent.to_s)
    if s =~ /^@rpath/
      all_rpaths = rpathStack + [LinkageGraph.parent_path_for_macho_binary_or_framework(image.machoFile.path)] + rpathFallbackStack
      s = all_rpaths.map{|rp|
        rp.assert_kind_of(Pathname)
        s.gsub(/^@rpath/, rp.to_s)
      }.find{|p|
        File.exist?(p)
      }
      raise "Could not resolve @rpath in #{path} from #{image.machoFile.path.basename}" if !s
    end
    return Pathname(s)
  end
  def self.parent_path_for_macho_binary_or_framework(binaryPath)
      parent = binaryPath.parent.realpath
      parent = parent.parent if parent.extname.downcase == ".framework"
      return parent
  end
CPUArchitecture = Struct.new(
                             # Name, e.g. arm64
                             :name,
                             # An image with this arch can link the following archs into its address space
                             :linkable_architectures,
                             # A CPU of this arch can also run the following archs, in preference order
                             :runnable_architectures,
                             ) do
  def self.all
    return CPU_ARCHITECTURE_ALL
  end
  def self.get(arch)
    return self.all.find{|a| a.name == arch } || (raise "Unknown arch #{arch}")
  end
CPU_ARCHITECTURE_ALL =
   CPUArchitecture.new("arm64e",  %w(arm64e), %w(arm64e arm64)),
   CPUArchitecture.new("arm64_32", %w(arm64_32), %w(arm64_32)),
   CPUArchitecture.new("arm64",  %w(arm64), %w(arm64 armv7s armv7)),
   CPUArchitecture.new("armv7s", %w(armv7s armv7), %w(armv7s armv7)),
   CPUArchitecture.new("armv7k", %w(armv7k), %w(armv7k)),
   CPUArchitecture.new("armv7",  %w(armv7), %w(armv7)),
class Pathname
  # Creates a new empty file (or directory if opts[:dir]). Fails if a file already exists at path. Returns self.
  def self.createExclusive(path, opts = {})
    path.parent.mkpath()
    if opts[:dir]
      Dir.mkdir(path) {}
    else
      File.open(path, File::WRONLY|File::CREAT|File::EXCL) {}
    end
    return path
  end
  # If path already exists, adds incrementing suffixes until it's unique and can be created with createExclusive(path, opts). Returns the new unique path.
  def self.createUnique(path, opts = {})
    uniquePath = path
    i = 0
    loop do
      suffix = i == 0 ? "" : "-#{i}"
      uniquePath = path.parent + (path.basename.to_s + suffix)
      i += 1
      Pathname.createExclusive(uniquePath, opts) rescue next
      return uniquePath
    end
  end
# Models the arg for --create-thinned and --skip-thinned
class ThinningVariantCLISpec
  # A device model identifier, product code, traits' artworkDevIdiom, or "all"
  attr :device # :: String
  attr :deploymentTarget # :: Gem::Version?
  def initialize(device, deploymentTarget)
    device.assert_kind_of(String)
    FatalError("expected non-empty device name for requested thinning variant") if device.empty?
    @device = device
    
    deploymentTarget.assert_kind_of(Gem::Version) unless deploymentTarget.nil?
    @deploymentTarget = deploymentTarget
  end
  def to_s
    deploymentTargetStr = if deploymentTarget.nil? then "" else "::#{deploymentTarget}" end
    return "#{device}#{deploymentTargetStr}"
  end
  # Parses a command-line arg
  def self.fromArg(str)
    if str == "all"
      return new(str, nil)
    elsif str =~ /^([^:]+)::([0-9\.]+)$/
      device = $1
      vers = Gem::Version.new($2)
      return new(device, vers)
    else
      raise "couldn't parse 'device::deploymentTarget' from: #{str}"
    end
    # if str =~ /^([^:]+)(::([0-9\.]+))?$/
    #   device = $1
    #   vers = if $3.nil_if_empty.nil? then nil else Gem::Version.new($3) end
    #   return new(device, vers)
    # else
    #   raise "couldn't parse 'device[::deploymentTarget]' from: #{str}"
    # end
  end
  def matches(thinningVariant)
    thinningVariant.assert_kind_of(ThinningVariant)
    return \
      (device == "all" || [thinningVariant.device.productType, thinningVariant.device.target, thinningVariant.traits.artworkDevIdiom].include?(device)) &&
      (deploymentTarget.nil? || deploymentTarget == thinningVariant.traits.deploymentTarget) &&
      true
  end
  def self.any_matches(specs, thinningVariant)
    return specs.any? { |s| s.matches(thinningVariant) }
  end
#  Parse Options
OPTIONS = OpenStruct.new()
OPTIONS.thinDevices = []
OPTIONS.skipThinDevices = []
OPTIONS.verbosity = 1
OPTIONS.useAssetutilEql = true
OPTIONS.translateWatchOS = true
OPTIONS.validateOutput = false
OPTIONS.validateOutputZeroVariants = nil
OPTIONS.bitcodeOptions = []
USAGE_BANNER = "usage: #{File.basename(__FILE__).shellescape} <ipa-or-dir> [options] [--output=<ipa-or-dir>]"
OptionParser.new do |opts|
  opts.banner = USAGE_BANNER
  opts.on("--info",
          "Prints information about the contents of the IPA") \
  do |v|
    OPTIONS.printInfo = true
  end
  opts.on("--validate",
          "Performs a variety of checks on the input IPA, reporting any errors or warnings on stderr as well as",
          "in the output JSON file (if one is requested)") \
  do |v|
    OPTIONS.validateInput = true
  end
  opts.on("--[no-]compile-bitcode",
          "Compile any bitcode that's in the IPA; if there is none, a warning is emitted but it's not an error",
          "If thinning is also enabled, the Bitcode won't be in any thinned IPAs") \
  do |v|
    OPTIONS.compileBitcode = v
  end
  opts.on("--[no-]translate-watchos") \
  do |v|
    OPTIONS.translateWatchOS = v
  end
  opts.on("--create-thinned=DEVICE", String,
          "Create thinned IPAs for devices with the given identifier",
          "The identifier is either a device identifier or the special name 'all' to generate all supported variants") \
  do |v|
    OPTIONS.thinDevices << ThinningVariantCLISpec.fromArg(v)
  end
  opts.on("--skip-thinned=DEVICE", String,
          "When used with --create-thinned=all, skip this device",
          "This allows --create-thinned=all to exclude certain devices",
          "It can be passed multiple times") \
  do |v|
    OPTIONS.skipThinDevices << ThinningVariantCLISpec.fromArg(v)
  end
  opts.on("--create-asset-packs",
          "Create asset packs from any on-demand resources",
          "The asset packs will be created in a directory next to the output",
          "If thinning is also enabled, the created asset packs will also be thinned for each set of traits",
          "If the --asset-manifest-url-prefix option is also provided, and AssetPackManifest.plist will be created") \
  do |v|
    OPTIONS.createAssetPacks = true
  end
  opts.on("--asset-manifest-url-prefix=URL",
          "URL prefix string for URLs in AssetPackManifest.plist",
          "This string will be prepended verbatim to each asset pack URL in generated AssetPackManifest.plist files",
          "Use this option to specify which server and subpath will vend the final, streamable asset packs",
          "If this option is omitted when --create-asset-packs is specified, no AssetPackManifest.plist will be created") \
  do |v|
    OPTIONS.urlPrefix = v
  end
  opts.on("--create-app-placeholders",
          "Create placeholder app bundles for each created application",
          "Placeholders just contain the Info.plist files, with additional information about ODR sizes etc") \
  do |v|
    OPTIONS.createAppPlaceholders = true
  end
  opts.on("-o", "--output=PATH", String,
          "Output path (either an non-thin IPA or directory of thin IPAs, depending on other options)",
          "When thinning, this directory will be created to contain a set of output IPAs",
          "Otherwise, this directory will be the single output IPA") \
  do |v|
    OPTIONS.outputPath = Pathname(v).absolute? ? Pathname(v) : Pathname.getwd() + Pathname(v)
  end
  opts.on("-t", "--tmpdir=PATH", String,
          "Path of directory to use as temporary directory",
          "The directory will be created, if needed, but will not be removed at the end",
          "If this option isn't provided, #{File.basename(__FILE__).shellescape} will create a unique temporary directory and remove it upon exit") \
  do |v|
    OPTIONS.tmpPath = Pathname(v).absolute? ? Pathname(v) : Pathname.getwd() + Pathname(v)
  end
  opts.on("-j", "--jobs=N",
          "Specifies the number of jobs to run simultaneously during bitcode compilation") \
  do |v|
    OPTIONS.bitcodeCompilationJFactor = v.to_i
  end
  opts.on("--toolchain=DIR",
          "Specify the toolchain path, if it isn't in the standard location realtive to ipatool",
          "This is normally not needed when invoking ipatool as part of AppStoreTools, but is used when invoked by Xcode.app") \
  do |v|
    OPTIONS.toolchainDir = Pathname(v).absolute? ? Pathname(v) : Pathname.getwd() + Pathname(v)
  end
  opts.on("--platforms=DIR",
          "Specify the platforms path, if it isn't in the standard location realtive to ipatool",
          "This is normally not needed when invoking ipatool as part of AppStoreTools, but is used when invoked by Xcode.app") \
  do |v|
    OPTIONS.platformsDir = Pathname(v).absolute? ? Pathname(v) : Pathname.getwd() + Pathname(v)
  end
  opts.on("--bitcode-build-option=OPTION",
          "The additional option passed to bitcode-build-tool",
          "This is normally not needed when invoking ipatool as part of AppStoreTools, but is used for bitcode-build-tool debugging") \
  do |v|
    OPTIONS.bitcodeOptions << v
  end
  opts.on("--[no-]use-assetutil-eql") do |v|
    OPTIONS.useAssetutilEql = v
  end
  opts.on("--[no-]validate-output") do |v|
    OPTIONS.validateOutput = v
  end
  opts.on("--[no-]validate-output-zero-variants") do |v|
    OPTIONS.validateOutputZeroVariants = v
  end
  opts.on("--app-store-tools-build-version=PATH") do |v|
    OPTIONS.appStoreToolsBuildVersion = v
  end
  opts.on("--app-store-tools-build-version-plist-path=PATH") do |v|
    OPTIONS.appStoreToolsBuildVersion = appStoreToolsBuildVersionFromPlist(Pathname(v))
  end
  opts.on_tail("--json=OUTPUT",
               "Provide output in JSON format. Other programs invoking #{File.basename(__FILE__).shellescape} are expected to use this option instead",
               "of trying to parse the default format. The output is a sequence of JSON dictionaries representing operations and issues.") \
  do |v|
    begin
      OPTIONS.jsonPipe = (v == "-") ? $stdout : File.open(v, 'w')
    rescue SystemCallError, IOError => e
      $stderr.puts "error: couldn't open the specified JSON file (#{e})"
      exit 1
    end
  end
  opts.on_tail("-v", "--verbose",
               "Increase the verbosity level; this option can be specified multiple times, each time making output more verbose") \
  do |v|
    OPTIONS.verbosity += 1
  end
  opts.on_tail("-q", "--quiet",
               "Makes ipatool completely silent; if this option is provided along with -v, the last one wins") \
  do |v|
    OPTIONS.verbosity = 0
  end
  opts.on_tail("--help", "Show this message") do
    puts opts
    exit
  end
end.parse!
if OPTIONS.validateOutputZeroVariants.nil?
  OPTIONS.validateOutputZeroVariants = OPTIONS.validateOutput && OPTIONS.skipThinDevices.empty?
#  Create Temporary Directory
# We might have been given a path for temporary files.  If not, we pick one (respecting 'TMP'), and clean it up at the end.
OPTIONS.tmpPath.mkpath() if OPTIONS.tmpPath
OPTIONS.tmpDir = Pathname(Dir.mktmpdir(File.basename(__FILE__, "rb"), OPTIONS.tmpPath))
at_exit { $stdout.puts "Removing temporary directory #{OPTIONS.tmpDir}..." if OPTIONS.verbosity >= 3 ; OPTIONS.tmpDir.rmtree() } unless OPTIONS.tmpPath
# now options.tmpPath is whatever the user specified, and options.tmpDir is always a directory that exists in the file system
#  Configure Structured Output
# During processing, structured output is added to the JsonOutput dictionary.
JsonOutput = { }
# Function to emit an error to stderr and also to the JSON output file, if defined.  Note that in a lot of current cases we use the line number as the code.
# This is temporary 
 in the future we should either define a catalog of errors with assigned numbers, or switch to using alphanumeric identifiers.
$EMITTED_ERRORS = false
def EmitError (code, desc, type = nil, expl = nil, outputHandle = $stderr)
  $EMITTED_ERRORS = true
  outputHandle.puts "error: #{desc}" if outputHandle
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "ERROR", type: type, code: code, description: desc, info: {}, explanation: expl }.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
# Function to emit a warning to stderr and also to the JSON output file, if defined.
def EmitWarning (code, desc, type = nil, expl = nil, outputHandle = $stderr)
  outputHandle.puts "warning: #{desc}" if outputHandle
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "WARN", type: type, code: code, description: desc, info: {}, explanation: expl }.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
# Function to emit an informational notice to stderr and also to the JSON output file, if defined.
def EmitInfo (code, desc, type = nil, expl = nil, outputHandle = $stderr)
  outputHandle.puts "info: #{desc}" if outputHandle
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "INFO", type: type, code: code, description: desc, info: {}, explanation: expl }.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
# Calls EmitError and exits with an error code.
def FatalError (code, desc, exitCode = 1)
  EmitError(code, desc, nil)
  exit(exitCode)
# Calls EmitError with a type of "malformed-ipa" without exiting.
def EmitIPAStructureValidationError (desc)
  EmitError(0, desc, "malformed-ipa")
# Calls EmitError with a type of "malformed-payload" without exiting.
def EmitIPAPayloadValidationError (desc)
  EmitError(0, desc, "malformed-payload")
# Calls EmitError with a type of "malformed-payload" and exits
def EmitFatalIPAPayloadValidationError (desc, exitCode = 1)
  EmitIPAPayloadValidationError(desc)
  exit(exitCode)
# Calls EmitError with a type of "malformed-payload" without exiting.
def EmitIPAOutputValidationError (desc)
  EmitError(0, desc, "malformed-output")
def LoadPlist(path, parentPathForDisplay = nil)
  relPath = path
  chdir = nil
  begin
    if parentPathForDisplay
      relPath = path.relative_path_from(parentPathForDisplay)
      chdir = parentPathForDisplay if parentPathForDisplay
    end
  rescue => ex
    $stderr.puts "warning: failed to format relative path (#{path}, #{parentPathForDisplay}): #{ex.message}"
    relPath = path
    chdir = nil
  end
  out_str = CmdSpec.new(locate_tool("plutil"), ['-convert', 'binary1', '-o', '-', '--', relPath.to_s], nil, chdir).run(0, false, true)
  pl = CFPropertyList::List.new
  pl.load_str(out_str, CFPropertyList::List::FORMAT_BINARY)
  return pl
# Loads a plist and categorizes parse errors as malformed-input.
def LoadUserPlist(path, parentPathForDisplay = nil)
  begin
    return LoadPlist(path, parentPathForDisplay)
  rescue => ex
    $stderr.puts "exception: #{ex.to_log_s}"
    EmitFatalIPAPayloadValidationError("Failed to read property list: #{ex.message}")
  end
def appStoreToolsBuildVersionFromPlist(path)
  data = LoadPlist(path)
  native = CFPropertyList::native_types(data.value)
  return native["ProductBuildVersion"].as(String)
JsonOutputFormatting = { indent: '  ', space: ' ', object_nl: "\n", array_nl: "\n", max_nesting: false }
at_exit {
  if $! && !$!.kind_of?(SystemExit)
    EmitError(__LINE__, "ipatool failed with an exception: #{$!.to_log_s}", "exception", nil, nil)
  end
  OPTIONS.jsonPipe.puts JSON.generate(JsonOutput, JsonOutputFormatting)
} if OPTIONS.jsonPipe
#  Check Arguments
# Check that we were given exactly one path: the IPA to operate on (either flattened or expanded).
if ARGV.count == 0
  $stderr.puts USAGE_BANNER
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "ERROR", code: -1, description: "error: invalid usage: no arguments provided", info: {}}.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
  exit 1
elsif ARGV.count == 1
  OPTIONS.inputPath = Pathname(ARGV[0])
  if not (OPTIONS.printInfo or OPTIONS.validateInput or OPTIONS.compileBitcode or !OPTIONS.thinDevices.empty? or OPTIONS.createAssetPacks)
    $stderr.puts "error: no action specified"
    $stderr.puts USAGE_BANNER
    JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
    JsonOutput[:alerts] << { level: "ERROR", code: -1, description: "error: invalid usage: no action specified", info: {}}.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
    exit 1
  end
else
  $stderr.puts "error: too many input files specified"
  $stderr.puts USAGE_BANNER
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "ERROR", code: -1, description: "error: invalid usage: too many input files specified", info: {}}.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
  exit 1
# If we weren't given a toolchain directory, we try to locate one.
unless OPTIONS.toolchainDir
  #  On the AppStoreTools disk image, the toolchain directory is the parent of the directory that contains ipatool.
  OPTIONS.toolchainDir = Pathname(__dir__).parent
# Make sure we did end up with a valid toolchain directory.
unless OPTIONS.toolchainDir.directory?
  FatalError(__LINE__, "toolchain directory #{OPTIONS.toolchainDir} #{OPTIONS.toolchainDir.exist? ? "isn't a directory" : "doesn't exist"}")
# Warn if the user specified an asset pack prefix URL that will never get used because asset packs aren't being created.
if OPTIONS.urlPrefix and not OPTIONS.createAssetPacks
  EmitWarning(__LINE__, "asset pack creation not requested, so --asset-manifest-url-prefix is ignored")
# If we weren't given a platform directory, we try to locate one.
unless OPTIONS.platformsDir
  #  On the AppStoreTools disk image, the platforms directory is off of the parent directory of the toolchains directory.
  OPTIONS.platformsDir = OPTIONS.toolchainDir.parent + "Platforms"
# Make sure we did end up with a valid platforms directory.
unless OPTIONS.platformsDir.directory?
  FatalError(__LINE__, "platforms directory #{OPTIONS.platformsDir} #{OPTIONS.platformsDir.exist? ? "isn't a directory" : "doesn't exist"}")
# Prepend the tools directory to the command line search path.
ENV["PATH"] = "#{OPTIONS.toolchainDir}/bin" + ":" + ENV["PATH"]
# Check that we were given an output directory if we're asked to compile bitcode and/or create thinned outputs.
if (OPTIONS.compileBitcode or !OPTIONS.thinDevices.empty? or OPTIONS.createAssetPacks) and not OPTIONS.outputPath
  actions = []
  actions << "bitcode compilation" if OPTIONS.compileBitcode
  actions << "device-specific thinning" if !OPTIONS.thinDevices.empty?
  actions << "asset-pack creation" if OPTIONS.createAssetPacks
  FatalError(__LINE__, "#{actions.join(" and ")} requested, but no --output argument provided")
if !OPTIONS.skipThinDevices.empty? &&
   !(OPTIONS.thinDevices.size == 1 && OPTIONS.thinDevices[0].to_s == "all")
  FatalError(__LINE__, "--skip-thinned is only compatible with --create-thinned=all")
if OPTIONS.appStoreToolsBuildVersion == nil
  candidates = [
    File.dirname(__FILE__) + "/../../version.plist",
    File.dirname(__FILE__) + "/../../../version.plist",
  path = candidates.detect { |p| File.exist?(p) }
  FatalError(__LINE__, "Could not find version.plist. Expected at #{candidates}. To override, pass a version in --app-store-tools-build-version or a path to a version.plist in --app-store-tools-build-version-plist-path.") if path.nil?
  $stderr.puts "Loading DTAppStoreToolsBuild via ProductBuildVersion from #{path}"
  OPTIONS.appStoreToolsBuildVersion = appStoreToolsBuildVersionFromPlist(Pathname(path))
APP_STORE_TOOLS_BUILD_VERSION_PATTERN = /^\d+\D+\d+\D*$/
unless OPTIONS.appStoreToolsBuildVersion =~ APP_STORE_TOOLS_BUILD_VERSION_PATTERN
  FatalError(__LINE__, "Expected #{OPTIONS.appStoreToolsBuildVersion} to match #{APP_STORE_TOOLS_BUILD_VERSION_PATTERN}, e.g. 10A208 or 10A208a")
#  Unpack Flattened IPA (If Needed)
# The input path may be either a file or a directory; if it's a file, we unpack it into our temporary directory.
OPTIONS.ipaName = OPTIONS.inputPath.basename
if OPTIONS.inputPath.file?
  # Use 'ditto -x -k' to unpack the IPA (it's really just a Zip file, for now); later we'll use the StreamingZip tool.
  $stdout.puts "Unpacking #{OPTIONS.inputPath.basename.to_s.shellescape}..." if OPTIONS.verbosity >= 3
  unpackedDir = OPTIONS.tmpDir.join("ipa")
  CmdSpec.new("ditto", ["-x", "-k", "--noqtn", "--noacl", OPTIONS.inputPath, unpackedDir]).run(0, false)
  OPTIONS.inputPath = unpackedDir
$stderr.puts "---"
$stderr.puts "IPA contents:"
$stderr.puts CmdSpec.new(locate_tool("find"), ["-s", "-f", OPTIONS.inputPath]).run(1, false, false)
$stderr.puts "---"
#  Allow us to annotate paths with architectures, when we know them
class Pathname
  attr_accessor  :arch            # Architecture identifier, if applicable (see the arch(3) man page)
#  Data Model
# Represents a single Mach-O image, backed by either a thin file or a slice of a fat file.
class MachOImage
  attr           :type             # Type of file, e.g. MH_EXECUTE, MH_DYLIB, etc
  attr           :platformIdentifier # Platform (macosx, iphoneos, etc)
  attr           :arch             # Architecture, e.g. x86_64 or arm64
  attr           :uuid             # UUID, from the UUID load command
  attr           :hasBitcode       # True if the Mach-O image contains bitcode
  attr           :hasExecCode      # True if the Mach-O image contains executable code
  attr           :isSigned         # True if the Mach-O image is signed
  attr_accessor  :machoFile        # The Mach-O file of which this image is a part (an FSMachOFileNode object)
  def initialize (type, platformIdentifier, arch, uuid, hasBitcode, hasExecCode, isSigned)
    @type = type
    @platformIdentifier = platformIdentifier
    @arch = arch
    @uuid = uuid
    @hasBitcode = hasBitcode
    @hasExecCode = hasExecCode
    @isSigned = isSigned
    @machoFile = nil  # this will be set later, when we're attached to an FSMachOFileNode
  end
  def platform
    return Platform.platformForIdentifer(self.platformIdentifier)
  end
  # We need to override to_s and inspect because MachOImage has a pointer back to its MachOFile and that cycle breaks the default inspect.
  def to_s
    return "<MachOImage #{self.machoFile.path} #{self.arch}>"
  end
  def inspect
    return to_s
  end
  def thinToPath (dstPath, level)
    # Creates a thin Mach-O file at the given path, taking the contents from the Mach-O image that backs this object.
    # If the backing is already thin, we can just copy the file; otherwise we need to use lipo(1) to extract the arch
    # slice into a new thin file.
    dstPath.parent.mkpath()
    unless machoFile.isFat
      # We already have a thin file (either from the start, or because it has already been thinned earlier).
      FileUtils.cp(self.machoFile.path, dstPath)
    else
      # We don't have a thin file, so we use lipo(1) to extract the slice from our Mach-O file.
      CmdSpec.new(locate_tool("lipo", [self.platform.toolsPath]), ["-thin", arch, machoFile.path, "-output", dstPath]).run(level, true)
    end
  end
  def isDylib
    return self.type == 'MH_DYLIB'
  end
  # Where are we storing the thinned version of this image before we process it (strip or recompile bitcode)?
  def thinnedInputPath(ipa, options)
    target_arch = arch
    return self.machoFile.path.reparent(ipa.path, options.tmpDir + "thinned-in" + target_arch)
  end
  # Where are we storing the thinned version of this image after we've processed it (stripped or recompiled bitcode)?
  def thinnedOutputPath(ipa, options, target_arch = arch)
    return self.machoFile.path.reparent(ipa.path, options.tmpDir + "thinned-out" + target_arch)
  end
  def rawLoadCommands
    @rawLoadCommands ||= CmdSpec.new(locate_tool("otool", [self.platform.toolsPath]), ["-l", "-v", "-m", "-arch", self.arch, self.machoFile.path]).run(0, true, true)
  end
  # Names from LC(_LAZY)?_LOAD(_WEAK)?_DYLIB commands.
  def loadedDylibs
    return rawLoadCommands.
      scan(/cmd LC(_LAZY)?_LOAD(_WEAK)?_DYLIB.*?name\s+(.*?)\s+\(offset\s+\d+\)/m).
      map{|groups| groups[2] }
  end
  def dylibNames
    return self.loadedDylibs.map{|l| l.sub(/^.*\/([^\/]*)$/, '\1') }
  end
  # Paths from LC_RPATH commands.
  def rpaths
    return rawLoadCommands.
      scan(/cmd LC_RPATH.*?path\s+(.*?)\s+\(offset \d+\)/m).
      map{|groups| groups[0] }
  end
  # Should we exclude this image from the output IPA?
  def shouldExcludeFromOutput
    if not defined? @shouldExcludeFromOutput
      @shouldExcludeFromOutput = lambda {
        return !self.machoFile.enclosingBundle.bitcodeCompilationRootMachO.machoImages.any?{ |img|
          img.arch == self.arch
        }
      }.call
    end
    return @shouldExcludeFromOutput
  end
  def shouldCompileBitcode(options)
    return (options.compileBitcode &&
            self.hasBitcode &&
            !self.shouldExcludeFromOutput &&
            self.machoFile.enclosingBundle.bitcodeCompilationRootMachO.machoImages.any? { |img|
              img.hasBitcode && img.arch == self.arch
            })
  end
  def shouldStripBitcode(options)
    return (self.hasBitcode &&
            !self.shouldExcludeFromOutput &&
            (!options.compileBitcode ||
             self.machoFile.enclosingBundle.bitcodeCompilationRootMachO.machoImages.any?{ |img|
               !img.hasBitcode && img.arch == self.arch
             }))
  end
class Pathname
  # /a/foo reparent from /a to /b => /b/foo
  def reparent(old_parent, new_parent)
    relpath = self.relative_path_from(old_parent) || (raise "#{old_parent} is not a parent of #{self}")
    return new_parent + relpath
  end
# Represents a file system entity.
class FSNode
  attr_accessor  :path              # Pathname for the file in the file system (can be relocated in special cases)
  attr           :enclosingBundle   # Reference to the bundle in which we're nested, or nil if we're the top
  def initialize (path, enclosingBundle)
    path = Pathname(path) unless path.kind_of?(Pathname)
    @path = path
    @enclosingBundle = enclosingBundle
  end
  def name
    return path.basename.to_s
  end
  def subnodes
    return nil
  end
class FSFileNode < FSNode
  def copyToPath (dstPath, thinningContext, level = 0)
    puts "#{"  "*level}copy #{name.shellescape}" if OPTIONS.verbosity >= 2
    # Copy the file contents to the destination path.
    FileUtils.cp(path, dstPath)
    # Make the mode of the destination the same as the source.
    dstPath.lchmod(path.stat().mode)
  end
class FSSymlinkNode < FSNode
  def copyToPath (dstPath, thinningContext, level = 0)
    puts "#{"  "*level}slnk #{name.shellescape}" if OPTIONS.verbosity >= 2
    # Copy the file contents to the destination path.
    dstPath.make_symlink(path.readlink())
    # Make the mode of the destination the same as the source.
    dstPath.lchmod(path.stat().mode)
  end
class FSDirectoryNode < FSNode
  attr  :subnodes      # Nodes representing the directory contents
  def initialize (path, enclosingBundle)
    super(path, enclosingBundle)
    @subnodes = []
  end
  def copyToPath (dstPath, thinningContext, level = 0)
    puts "#{"  "*level}mkdr #{name.shellescape}/" if OPTIONS.verbosity >= 2
    # First remove the existing directory, if any.
    dstPath.rmtree() rescue Errno::ENOENT
    # Create the top-level directory and then recurse downward.
    dstPath.mkpath()
    # Copy the file contents to the destination path.
    for subnode in subnodes
      subnode.copyToPath(dstPath + subnode.name, thinningContext, level + 1)
    end
    # Make the mode of the destination the same as the source.
    dstPath.lchmod(path.stat().mode)
  end
  # Calls block or returns an enumerator with every descendant model object of this directory
  def enumerateTree
    return enum_for(:enumerateTree) unless block_given?
    yield self
    self.subnodes.each { |n|
      if n.respond_to? :enumerateTree
        n.enumerateTree {|n2| yield n2}
      else
        yield n
      end
    }
  end
class FSMachOFileNode < FSFileNode
  attr_accessor  :machoImages   # Array of Mach-O images contained in the file (note that even if one, it could be a fat file)
  attr           :type          # MH_EXECUTE, MH_DYLIB, etc (technically an image property, but all should be the same)
  def initialize (path, enclosingBundle, machoImages)
    super(path, enclosingBundle)
    assert(machoImages.size > 0)
    @machoImages = machoImages.each{ |img|img.machoFile = self }
    @type = machoImages.first.type
    # we should warn if we find different types in different slices
  end
  def platform
    return self.machoImages[0].platform
  end
  def isFat
    output = lipo_info(path)
    if output =~ /Architectures in the fat file.*\:(.+)/m
      return true
    elsif output =~ /Non-fat file.*\:(.+)/m
      return false
    else
      raise "Couldn't parse output of #{cmd}: #{output}"
    end
  end
  # Given #arch, pick the best image to link against. Returns nil if we can't link any image in this MachO against #arch.
  def linkableImageForArch(arch)
    # Find the best Mach-O image to use, which matches the earliest linkable architecture.
    return CPUArchitecture.get(arch).linkable_architectures.map { |li|
      machoImages.find { |mi| mi.arch == li }
    }.compact.first
  end
  def linkableImageForArchOrError(arch)
    machoImage = self.linkableImageForArch(arch)
    unless machoImage
      EmitFatalIPAPayloadValidationError("couldn't find suitable architecture for linking #{arch} in Mach-O file #{path.to_s.shellescape}")
    end
    return machoImage
  end
  def shouldThin
    return self.enclosingBundle.shouldThin
  end
  def copyToPath (dstPath, thinningContext, level = 0)
    thinArch = nil
    if thinningContext.traits && self.shouldThin
      thinArch = thinningContext.traits.preferredArch
    elsif self.platform.identifier == "watchos" && thinningContext.mainTraits && !thinningContext.mainTraits.supportsEmbeddedUniversalWatchApp
      thinArch = "armv7k"
    end
    
    if thinArch
      puts "#{"  "*level}thin #{name.shellescape}" if OPTIONS.verbosity >= 2
      machoImage = self.linkableImageForArchOrError(thinArch)
      # Ask the Mach-O image to emit a thin binary to the destination path.
      machoImage.thinToPath(dstPath, level)
      # Make the mode of the destination the same as the source.
      dstPath.lchmod(path.stat().mode)
    else
      super(dstPath, thinningContext, level)
    end
  end
  def isDylib
    return machoImages.first.isDylib
  end
  def isSwiftRuntimeDylib
    return isDylib && self.name =~ /libswift.*\.dylib/
  end
  # After we've recompiled each image, where do we store the universal reassembled MachO?
  def universalReassemblyPath(ipa, options)
    return self.path.reparent(ipa.path, options.tmpDir + "universal-MachOs")
  end
class FSAssetCatalogFileNode < FSFileNode
  def shouldThin
    return self.enclosingBundle.shouldThin && !self.enclosingBundle.isWatchKitAppExtension
  end
  def copyToPath (dstPath, thinningContext, level = 0)
    if thinningContext.traits && self.shouldThin
      puts "#{"  "*level}asct #{name.shellescape}" if OPTIONS.verbosity >= 2
      CmdSpec.new(locate_tool("assetutil", [self.enclosingBundle.platform.toolsPath]),
                  (thinningContext.traits.to_assetutil_args_array +
                   [
                    "--output=#{dstPath}",
                    path,
                   ])
                  ).run(level)
      # Make the mode of the destination the same as the source.
      dstPath.lchmod(path.stat().mode) rescue Errno::ENOENT
    else
      super(dstPath, thinningContext, level)
    end
  end
  def mayHaveCarPlayAssets
    if not defined? @mayHaveCarPlayAssets
      @mayHaveCarPlayAssets = lambda {
        begin
          output = CmdSpec.new(locate_tool("assetutil", [self.enclosingBundle.platform.toolsPath]), ["-I", path]).run(0, 0, true)
          data = JSON.parse(output)
          data.assert_array_of(Hash)
          return data.any? { |entry| entry["Idiom"] == "car" }
        rescue => exc
          # If something goes wrong here, we need to conservatively assume it may have CarPlay assets
          EmitWarning(__LINE__, "Failed to determine if asset catalog has CarPlay assets, assuming it does.\n#{exc.to_log_s}")
          return true
        end
      }.call
    end
    return @mayHaveCarPlayAssets
  end
  # Would traits a and b produce the same output when they thin this AssetCatalog? A return value of true is conclusive, whereas false is not. It would be too expensive to compute a conclusive no.
  def eql_for_traits?(a, b, level = 0)
    # - graphicsclassfallbacks and hostedidioms should not be passed to -T
    return false if a.artworkHostedIdioms != b.artworkHostedIdioms && mayHaveCarPlayAssets
    
    a_arg = a.to_assetutil_T_string
    b_arg = b.to_assetutil_T_string
    return true if a_arg == b_arg
    # Sort args so that we'll share cache hits for A/B and B/A
    traits_args = [a_arg, b_arg].sort.join('/')
    output = CmdSpec.new(locate_tool("assetutil", [self.enclosingBundle.platform.toolsPath]),
                         [
                          "-T",
                          "#{traits_args}",
                          self.path,
                         ]
                         ).run(level, true, true)
    return false if output.start_with?("not equal ")
    if output.start_with?("equal ")
      return true
    end
    raise "Unknown assetutil -T output: #{output}"
  end
class FSBundleDirectoryNode < FSDirectoryNode
  attr           :infoDict                      # Info.plist contents of the bundle (always a dictionary)
  attr           :requiredDeviceCapabilities    # Set of required device capabilities
  # This class has multi-stage initialization. Anything which uses the below is not safe until initialized is true.
  attr_accessor  :initialized
  attr           :machoFiles                    # Any Mach-O files in the bundle (but not in nested bundles)
  attr_accessor  :mainMachoFile                 # Main executable Mach-O file, nil if none (always included in machoFiles)
  attr           :nestedBundles                 # Any nested bundles (but not any nested bundles inside those bundles)
  def initialize (path, enclosingBundle, infoDict)
    super(path, enclosingBundle)
    @infoDict = infoDict
    # The following properties will be populated by the logic that creates us.
    @machoFiles = []
    @mainMachoFile = nil
    @nestedBundles = []
    # Examine UIRequiredDeviceCapabilities
    @requiredDevCaps = infoDict["UIRequiredDeviceCapabilities"] || {}
    if @requiredDevCaps.kind_of?(Array)
      dict = {}
      for cap in @requiredDevCaps
        dict[cap] = true
      end
      @requiredDevCaps = dict
    end
  end
  def self.getInfoPlistIfPathIsBundle (path, parentPathForDisplay = nil)
    # Check if the given path seems like a bundle, and if so, return its Info.plist contents.
    return nil unless path.directory?
    infoPlistPath = path + "Info.plist"
    return nil unless infoPlistPath.file?
    infoPlist = LoadUserPlist(infoPlistPath, parentPathForDisplay)
    nativeInfoPlist = CFPropertyList::native_types(infoPlist.value) unless infoPlist == nil
    return nil unless nativeInfoPlist && nativeInfoPlist.kind_of?(Hash) && nativeInfoPlist["CFBundleIdentifier"]
    return nativeInfoPlist
  end
  def identifier ()
    return infoDict["CFBundleIdentifier"]
  end
  def supportedIdioms
    if not defined? @supportedIdioms
      @supportedIdioms = lambda {
        family = infoDict["UIDeviceFamily"]
        
        if family.nil_if_empty.nil?
          if self.enclosingBundle && self.platformIdentifier == self.enclosingBundle.platformIdentifier
            return self.enclosingBundle.supportedIdioms
          else
            return nil
          end
        end
        
        return ThinningTraits.assetutil_idioms_for_UIDeviceFamily(family)
      }.call
    end
    return @supportedIdioms
  end
  def statedPlatformIdentifier
    supportedPlatformIdents = infoDict["CFBundleSupportedPlatforms"]
    if self.enclosingBundle && supportedPlatformIdents.nil_if_empty.nil?
      return self.enclosingBundle.statedPlatformIdentifier
    end
    if !supportedPlatformIdents.kind_of?(Array) || supportedPlatformIdents.count != 1
      EmitFatalIPAPayloadValidationError("#{path.basename.to_s.shellescape}/Info.plist should specify CFBundleSupportedPlatforms with an array containing a single platform, e.g. CFBundleSupportedPlatforms = [ iPhoneOS ], but it has CFBundleSupportedPlatforms = #{supportedPlatformIdents}")
    end
    platformIdent = supportedPlatformIdents.first.downcase
    # WatchKit 1 app bundle
    platformIdent = "watchos" if platformIdent == "iphoneos" and isWatchKit1StubApp
    return platformIdent
  end
  def platformIdentifier
    platformIdent = statedPlatformIdentifier
    # Plain resources bundle
    assert(initialized, path.to_s) # assert that we've finalized mutable fields (machoFiles and nestedBundles)
    platformIdent = self.enclosingBundle.platformIdentifier if self.enclosingBundle && self.machoFiles.empty? && self.nestedBundles.empty?
    return platformIdent
  end
  def platform
    return Platform.platformForIdentifer(self.platformIdentifier)
  end
  # Gem::Version
  def deploymentTarget
    return @deploymentTarget ||= Gem::Version.new(infoDict["MinimumOSVersion"])
  end
  def supportedArchitectures ()
    assert(initialized, path.to_s)
    return @supportedArchs ||= machoFiles.map{ |file| file.machoImages.map{ |mimg| mimg.arch } }.reduce(:&) || []
  end
  def isSpotlightAppExtBundle ()
    extnDict = infoDict["NSExtension"]
    return false unless extnDict
    return extnDict["NSExtensionPointIdentifier"] == "com.apple.spotlight.index"
  end
  def infoPropertyListPath ()
    return path + "Info.plist"
  end
  def shouldThin
    return false if isWatchKitStubApp
    return !enclosingBundle || (enclosingBundle.shouldThin && platformIdentifier == enclosingBundle.platformIdentifier)
  end
  def copyToPath (dstPath, thinningContext, level = 0)
    puts "#{"  "*level}bndl #{name.shellescape} (#{platformIdentifier})" if OPTIONS.verbosity >= 2
    # First remove the existing directory, if any.
    dstPath.rmtree() rescue Errno::ENOENT
    # If our platform is distinct from the native platform of the parent bundle, we disable the thinning traits for
    # this subtree.  This is because in that case, this is actually a payload intended to be sent to another device
    # at a later time, and thinning it would be the wrong thing to do.
    thinningContext = thinningContext.subscope(nil) if !self.shouldThin
    # Modify the thinning traits to account for iPhone-only apps in compatibility mode on iPads.
    if thinningContext.traits and thinningContext.traits.artworkDevIdiom == "pad" and self.supportedIdioms == ["phone"]
      # It's an iPhone-only app being thinned for iPad.  We do some magic on the thinning traits to reflect the compatibility environment.
      traits = ThinningTraits.new(thinningContext.traits.deploymentTarget, thinningContext.traits.passDeploymentTargetToAssetutil, thinningContext.traits.preferredArch, "phone", thinningContext.traits.artworkHostedIdioms, 2, 0, thinningContext.traits.artworkDisplayGamut, thinningContext.traits.artworkDynamicDisplayMode, thinningContext.traits.devPerfMemoryClass,thinningContext.traits.gfxFeatureSetClass, thinningContext.traits.gfxFeatureSetFallbacks, thinningContext.traits.featuresToRemove  , thinningContext.traits.supportsEmbeddedUniversalWatchApp ).freeze
      thinningContext = ThinningContext.new(traits, traits, thinningContext.variants)
      puts "#{"  "*level}  (adjusting thinning traits to #{thinningContext.traits} for an iPhone-only app on an iPad)" if OPTIONS.verbosity >= 2
    end
    # If we are a Spotlight extension and the thinning traits say that we should strip it out, we skip the copying.
    if self.isSpotlightAppExtBundle() and thinningContext.traits and thinningContext.traits.featuresToRemove.include?("spotlight") then
      puts "#{"  "*level}  (skipping copying of a Spotlight Extension on this device)" if OPTIONS.verbosity >= 2
      skipCopying = true
    end
    if thinningContext.traits && thinningContext.traits.preferredArch
      runnableArchNames = CPUArchitecture.get(thinningContext.traits.preferredArch).runnable_architectures
      bundleRequiredArch = CPUArchitecture.all.find{|cpuArch| @requiredDevCaps[cpuArch.name] == true }
      if bundleRequiredArch && !runnableArchNames.include?(bundleRequiredArch.name)
        puts "#{"  "*level}  (skipping copying of a bundle due to incompatible architecture (thinning for runnable #{thinningContext.traits.preferredArch}, bundle requires #{bundleRequiredArch.name}))" if OPTIONS.verbosity >= 2
        skipCopying = true
      end
    end
    # Unless we've decided to skip this bundle completely, we copy it now (while possibly thinning).
    unless skipCopying
      # Create the top-level directory and then recurse downward.
      dstPath.mkpath()
      # Copy the file contents to the destination path (possibly applying thinning).
      for subnode in subnodes
        subnode.copyToPath(dstPath + subnode.name, thinningContext, level + 1)
      end
      # Make the mode of the destination the same as the source.
      dstPath.lchmod(path.stat().mode)
    end
  end
  def thinnableAssetCatalogs
    return self.enumerateTree.select{ |node| node.kind_of?(FSAssetCatalogFileNode) && node.shouldThin }
  end
# WatchKit extras
class FSBundleDirectoryNode
  def isWatchKitStubApp
    return path.extname == ".app" && plistBoolValue(infoDict["WKWatchKitApp"] || false)
  end
  def isWatchKit1StubApp
    return isWatchKitStubApp && enclosingBundle.isWatchKitAppExtension
  end
  def isWatchKit2StubApp
    return isWatchKitStubApp && enclosingBundle.platform.identifier == "iphoneos"
  end
  def isWatchKitAppExtension
    return path.extname == ".appex" &&
           self.infoDict["NSExtension"].kind_of?(Hash) &&
           self.infoDict["NSExtension"]["NSExtensionPointIdentifier"] == "com.apple.watchkit"
  end
  def isWatchKit1AppExtension
    return isWatchKitAppExtension && platform.identifier == "iphoneos"
  end
  def isWatchKit2AppExtension
    return isWatchKitAppExtension && platform.identifier == "watchos"
  end
# Bitcode recompilation extras
class FSBundleDirectoryNode
  def watchAppExChild
    assert(initialized, path.to_s)
    if not defined? @watchAppExChild
      @watchAppExChild = lambda {
        return (if self.isWatchKitStubApp then self.nestedBundles.detect{|b| b.isWatchKitAppExtension } else nil end)
      }.call
    end
    
    return @watchAppExChild
  end
  # This is usually the main app in an IPA, but iOS apps which contain watchOS apps will have two roots for bitcode compilation (one for iOS, one for watchOS). In the abstract, bitcode compilation needs to happen in linkage dependency order, so it starts with a tree of bundles and resolves dependencies within that tree. Dependency resolution cannot cross platform boundaries, so a bundle with a new platform becomes a new root.
  def isBitcodeCompilationRootBundle
    if not defined? @isBitcodeCompilationRootBundle
      @isBitcodeCompilationRootBundle = lambda {
        return (!self.enclosingBundle ||
                self.platformIdentifier != self.enclosingBundle.platformIdentifier ||
                self.watchAppExChild != nil)
      }.call
    end
    
    return @isBitcodeCompilationRootBundle
  end
  # Find the root bundle (see isBitcodeCompilationRootBundle) for the current tree. E.g. if this bundle is an iOS appex, this method will return the parent iOS app.
  def bitcodeCompilationRootBundle
    if not defined? @bitcodeCompilationRootBundle
      @bitcodeCompilationRootBundle = lambda {
        return (if self.isBitcodeCompilationRootBundle then self else self.enclosingBundle.bitcodeCompilationRootBundle end)
      }.call
    end
    
    return @bitcodeCompilationRootBundle
  end
  # Find the root bundle (see isBitcodeCompilationRootBundle and bitcodeCompilationRootBundle), then find the root mach-o from there. It's not necessarily the same as the bundle's mainMachoFile; watchOS apps contain a stub as their mainMachoFile, so the "root" mach-o as far as bitcode compilation is concerned is actually the user's appex (see isWatchKitAppExtension).
  def bitcodeCompilationRootMachO
    assert(initialized, path.to_s)
    if not defined? @bitcodeCompilationRootMachO
      @bitcodeCompilationRootMachO = lambda {
        root = bitcodeCompilationRootBundle
        actualRoot = root.watchAppExChild || root
        return actualRoot.mainMachoFile
      }.call
    end
    
    return @bitcodeCompilationRootMachO
  end
# An IPA object represents a directory tree containing the expanded contents of a .ipa file.  The IPA's path is the
# top-level directory.  The mainBundle property is the FSBundleDirectoryNode object that represents the main bundle
# underneath the IPA's Payload directory (if any).
class IPA
  attr  :path           # Pathname for the file in the file system
  attr  :mainBundle     # Reference to the main bundle inside the payload directory
  attr  :vpnPlugins     # Optional vpnplugin bundles inside the payload directory
  attr  :assetPacks     # Array of asset packs in the OnDemandResources directory, if any
  attr  :dsymFiles      # Paths of .dSYM files associated with the IPA (from compiling bitcode)
  attr  :dsymFilesUnthinned # Paths of .dSYM files associated with the IPA (from compiling bitcode) (unthinned, e.g. from a watchOS sub-bundle, this means that they're always in the output IPA)
  attr  :symcacheFiles  # Paths of .symbols files associated with the IPA (from compiling bitcode)
  attr  :symcacheFilesUnthinned  # Paths of .symbols files associated with the IPA (from compiling bitcode) (unthinned, e.g. from a watchOS sub-bundle, this means that they're always in the output IPA)
  attr  :linkageGraph   # LinkageGraph for all the MachOImage objects
  def initialize (path)
    # Scan the file system, constructing the
    path = Pathname(path) unless path.kind_of?(Pathname)
    @path = path
    EmitIPAStructureValidationError("IPA has no Payload directory") unless payloadPath.exist?
    
    appPaths = payloadPath.children.sort.select{ |chld| chld.extname == ".app" }
    EmitIPAStructureValidationError("IPA has no main app") unless appPaths.count == 1
    appPath = appPaths.first
    
    @mainBundle = MakeFileSystemNode(appPath, nil, nil, payloadPath)
    EmitIPAStructureValidationError("Couldn't load app at #{appPath}") unless mainBundle
    EmitIPAStructureValidationError("Couldn't load app at #{appPath}, found: #{mainBundle.class.name}: #{mainBundle}") unless mainBundle.kind_of?(FSBundleDirectoryNode)
    machOs = mainBundle.enumerateTree.select{|n| n.kind_of?(FSMachOFileNode) }
    # Cache [real path -> MachO] for use below
    machOsByRealPath = Hash[machOs.map{|m| [m.path.realpath, m] }]
    # Setup fallback rpaths for otherwise unresolved linkage. This ensures that we maintain previous behavior (link by name) if we can't resolve @rpaths. This can happen if the app includes a dylib that the executable does not link (maybe it's dlopen'ed instead).
    rpathFallbackStack = machOs.map{|m| LinkageGraph.parent_path_for_macho_binary_or_framework(m.path) }.uniq
    @linkageGraph = LinkageGraph.new
    # Resolve dylibs, starting with executables so that we can get a concrete @executable_path.
    machOs.
      # Partition by executable so that they go first, then flatten so that we process executables and dylibs as one collection.
      partition{|m| m.type == "MH_EXECUTE" }.flatten.
      each{|m|
      m.machoImages.each {|img|
        self.linkageGraph.resolveLoadedDylibs(img, rpathFallbackStack, [], machOsByRealPath)
      }
    }
    $stderr.puts "Complete LinkageGraph:\n#{self.linkageGraph.to_s(mainBundle.path.parent).indent}"
    vpnPluginPaths = payloadPath.children.sort.select{ |chld| chld.extname == ".vpnplugin" }
    @vpnPlugins = vpnPluginPaths.map{|p| MakeFileSystemNode(p, nil, nil, payloadPath) }
    assetPackPaths = assetPacksPath.children.sort.select{ |chld| chld.extname == ".assetpack" } if hasAssetPacks
    @assetPacks = assetPackPaths.collect{ |p| MakeFileSystemNode(p, nil, mainBundle, assetPacksPath) } if assetPackPaths
    @dsymFiles = []
    @dsymFilesUnthinned = []
    @symcacheFiles = []
    @symcacheFilesUnthinned = []
  end
  def payloadPath ()
    return @path + "Payload"
  end
  def assetPacksPath ()
    return @path + "Payload" + "OnDemandResources"
  end
  def symbolCachePath ()
    return @path + "Symbols"
  end
  def bitcodeSymbolMapsPath
    return @path + "BCSymbolMaps"
  end
  def hasAssetPacks ()
    return assetPacksPath.exist?
  end
  def hasSymbolCache ()
    return symbolCachePath.exist?
  end
  def hasBitcodeSymbolMaps
    bitcodeSymbolMapsPath.exist?
  end
  def thinnableAssetCatalogs
    mainBundleAssetCatalogs = self.mainBundle.thinnableAssetCatalogs
    assetPackAssetCatalogs = (self.assetPacks||[]).map{|ap| ap.thinnableAssetCatalogs }.flatten
    return mainBundleAssetCatalogs + assetPackAssetCatalogs
  end
  def appThinningInfoBasename
    return "AppThinning.plist"
  end
  def appThinningInfoPath
    return path + appThinningInfoBasename
  end
  def appThinningInfoDisplayPath
    return appThinningInfoPath.relative_path_from(path)
  end
  def appThinningInfo
    if not defined? @appThinningInfo
      @appThinningInfo = lambda {
        return Hash.new unless appThinningInfoPath.exist?
        result = CFPropertyList::native_types(LoadUserPlist(appThinningInfoPath, path).value)
        
        unless result.kind_of?(Hash)
          EmitFatalIPAPayloadValidationError("Expected dictionary in: #{appThinningInfoDisplayPath.to_s.shellescape}")
        end
        
        return result
      }.call
    end
    
    return @appThinningInfo
  end
  def stripSwiftSymbols
    if not defined? @stripSwiftSymbols
      @stripSwiftSymbols = lambda {
        keyName = "StripSwiftSymbols"
        value = appThinningInfo[keyName]
        bvalue = if value.nil? then true else plistBoolValue(value) end
        
        if bvalue.nil?
          EmitFatalIPAPayloadValidationError("Unexpected value for key #{keyName} in #{appThinningInfoDisplayPath.to_s.shellescape}: #{value}")
        end
        
        return bvalue
      }.call
    end
    
    return @stripSwiftSymbols
  end
def plistBoolValue(value)
  case value
  when "1", "YES", 1, true
    return true
  when "0", "NO", 0, false
    return false
  else
    return nil
  end
def lipo_info(path)
  return CmdSpec.new(locate_tool("lipo"), ["-info", path.to_s]).run(0, true, true)
def file_type(path)
  return CmdSpec.new(locate_tool("file"), ["-b", "--", path.to_s]).run(0, true, true).strip
#  Examines the file system entity at the path, and returns either a [MachOImage] (if the path refers to
#  a Mach-O file or a symlink to a Mach-O file) or nil (if it doesn't).  The returned MachOImage objects have a path
#  to either the single-architecture or the multi-architecture file so they can in the future   This function always
#  returns a string.
def GetMachOImagesFromOToolInfoForFile (path)
  # Make a quick exit if it doesn't seem like a Mach-O file (or a symlink to one).
  path = Pathname(path) unless path.kind_of?(Pathname)
  return nil unless path.exist? and path.file?
  return nil unless (file_type(path) =~ /Mach-O/ rescue nil)
  # Figure out which architectures it contains.  We end up with 'archs' as either a string if it's a single-architecture
  # Mach-O file, or as an array of strings (which could be even just a single one) if it's a multi-architecture Mach-O.
  output = lipo_info(path)
  return nil unless $? == 0
  if output =~ /Architectures in the fat file.*\:(.+)/m
    archs = $1.split
  elsif output =~ /Non-fat file.*\:(.+)/m
    archs = $1.strip
  else
    return nil
  end
  # puts "archs: #{[*archs].join(", ")}"
  # Use otool -h to figure out the Mach-O type.
  output = CmdSpec.new(locate_tool("otool"), ["-h", "-v", "-m", "-arch", "all", path.to_s]).run(0, true, true)
  machOType = /[0-9]+\s+(EXECUTE|DYLIB|BUNDLE)\s+[0-9]+/.match(output)[1] rescue "???"
  # puts "machOType: #{machOType}"
  # Go through the architectures, and construct a Mach-O image for it.
  machoImages = []
  for arch in [ *archs ]
    # Use otool(1) to get the load commands for the architecture, and strip off the first line.
    output = CmdSpec.new(locate_tool("otool"), ["-l", "-v", "-m", "-arch", arch, path]).run(0, true, true)
    output = output.lines.drop(1).join('')
    # Collect load commands.
    loadCommands = nil
    output.split(/Load command \d+\s*\n/).each { |substr|
      # Iterate over the lines in the load command. If we find a section, we deal with it.
      next if substr == ""
      (loadCommands ||= []) << (currentLoadCommand = OpenStruct.new())
      currentSection = nil
      substr.each_line { |line|
        # If the line is "Section", we create a new section.
        if line.strip == "Section"
          # It's the start of a new section.
          (currentLoadCommand["sections"] ||= []) << (currentSection = OpenStruct.new())
        else
          # It's a key value pair, which we add to either the load command or the current section.
          k,v = line.split(' ', 2)
          (currentSection || currentLoadCommand)[k.strip] = v.strip
        end
      }
    }
    # Record the UUID, if there is one.
    uuid = loadCommands.select{ |lc| lc.cmd == "LC_UUID" }.collect{ |lc| lc.uuid }.first
    # p uuid
    
    # Record the platform and the minimum deployment target.
    versionMinLoadCommandName = loadCommands.select{ |lc| lc.cmd =~ /LC_VERSION_MIN_(.+)/ }.collect{ |lc| lc.cmd }.first
    platformIdentifier = if versionMinLoadCommandName then Platform.platformIdentifierForVersionMinLoadCommand(versionMinLoadCommandName) else nil end
    if platformIdentifier.nil?
      versionLoadCommand = loadCommands.detect{ |lc| lc.cmd =~ /LC_BUILD_VERSION/ }
      platformIdentifier = versionLoadCommand.platform if versionLoadCommand
      platformIdentifier = "iphoneos" if platformIdentifier == "ios"
      platformIdentifier = "appletvos" if platformIdentifier == "tvos"
    end
    EmitWarning(__LINE__, "Could not determine platform for #{arch} in #{path}") unless platformIdentifier
    # p versionMinLoadCommandName
    # p minVersion
    # p sdkVersion
    # Record whether or not there is a code signature.
    hasCodeSignature = loadCommands.select{ |lc| lc.cmd == "LC_CODE_SIGNATURE" }.count > 0
    # p hasCodeSignature
    # Record whether or not there is executable code.
    hasBitcode = loadCommands.select{ |lc| lc.cmd == "LC_SEGMENT" or lc.cmd == "LC_SEGMENT_64" }.find{ |lc|
      # Select segments named "__LLVM" with sections named "__bundle".
      lc.segname == "__LLVM" and lc.sections and lc.sections.find{ |sc| sc.sectname == "__bundle"}
    }
    # p hasBitcode
    # Record whether or not there is bitcode.
    hasExecCode = loadCommands.select{ |lc| lc.cmd == "LC_SEGMENT" or lc.cmd == "LC_SEGMENT_64" }.select{ |lc|
      # Select "__TEXT" segments that aren't zero-sized.
      lc.segname == "__TEXT" and lc.filesize.to_i > 0
    }.count > 0
    # p hasExecCode
    # Finally, create a MachOImage object to represent the Mach-O image.
    machoImages << MachOImage.new("MH_" + machOType, platformIdentifier, arch, uuid, hasBitcode, hasExecCode, hasCodeSignature)
  end
  return machoImages
# Examines the file system entity at the path and returns the most specific kind of node that best represents it.
def MakeFileSystemNode (path, parentDirectory = nil, enclosingBundle = nil, parentPathForDisplay = nil)
  # Make a quick exit if the path doesn't even exist.
  path = Pathname(path) unless path.kind_of?(Pathname)
  raise "Nothing at path: #{path}" unless path.exist?
  # Otherwise, what we do depends on the type of file system entity.
  # puts "[#{path}]"
  case path.ftype
      
  when "file"
    # Check the file name suffix as a first indication of what kind of file it might be.
    case path.extname.downcase
    when ".car"
      magic_type = file_type(path)
      is_bom = magic_type == "Mac OS X bill of materials (BOM) file"
      
      if is_bom
        # If the file type is BOM, then slice accordingly, regardless of the file name (as long as it ends in .car).
        node = FSAssetCatalogFileNode.new(path, enclosingBundle)
      elsif path.basename.to_s.downcase == "assets.car" && path.parent == enclosingBundle.path
        # If the file name is exactly Assets.car and the file type is not BOM, then error (especially if our platforms on devices assume that Assets.car is a BOM file). 
This treats Assets.car as a 
reserved
 file name.
        displayPath = if parentPathForDisplay then path.relative_path_from(parentPathForDisplay) else path end
        EmitFatalIPAPayloadValidationError("Assets.car should be an asset catalog, but is \"#{magic_type}\": #{displayPath}")
      else
        # If the file name is not Assets.car and the file type is not BOM, then skip (i.e., the resource.car case).
        node = FSFileNode.new(path, enclosingBundle)
      end
    else
      # Possibly a Mach-O (we'll need to check the contents to know for sure)
      machoImages = GetMachOImagesFromOToolInfoForFile(path)
      if machoImages && !machoImages.empty? && (!enclosingBundle || machoImages.first.platformIdentifier == enclosingBundle.statedPlatformIdentifier)
        # Instantiate a Mach-O File Node and, if there is an enclosing bundle, add it to the list.
        node = FSMachOFileNode.new(path, enclosingBundle, machoImages)
        enclosingBundle.machoFiles << node if enclosingBundle
      else
        # Otherwise we consider it a regular File Node.
        node = FSFileNode.new(path, enclosingBundle)
      end
    end
    return node
  when "directory"
    # Check if this seems to be a bundle; if so, we get back the Info.plist contents.
    infoDict = FSBundleDirectoryNode.getInfoPlistIfPathIsBundle(path, parentPathForDisplay)
    if infoDict
      # It's a bundle. We instantiate a node, connect it to any enclosing bundle, and set it as the current one.
      node = FSBundleDirectoryNode.new(path, enclosingBundle, infoDict)
      enclosingBundle.nestedBundles << node if enclosingBundle
      bundle = node
    else
      # Not a bundle, so just create a regular directory node.
      node = FSDirectoryNode.new(path, enclosingBundle)
      bundle = enclosingBundle
    end
    # Descend the directory hierarchy.
    for cpath in path.children.sort
      subnode = MakeFileSystemNode(cpath, node, bundle, parentPathForDisplay)
      node.subnodes << subnode if subnode
    end
    # For a bundle directory, we do some post-processing after reading the subtree.
    if node.kind_of?(FSBundleDirectoryNode)
      # Look up the CFBundleExecutable key in the Info dictionary.
      mainExecName = node.infoDict['CFBundleExecutable']
      # If there is a value, we find it in the list of Mach-Os, and set it as the bundle's main Mach-O.
      if mainExecName
        bundle.mainMachoFile = node.subnodes.detect{ |n| n.name.unicode_equal?(mainExecName) }
      end
      node.initialized = true
    end
    # Return the directory node (or specialization of directory node, e.g. bundle node).
    return node
  when "link"
    # Create a symbolic link node.
    return FSSymlinkNode.new(path, enclosingBundle)
  else
    # Any other kind of entity is treated plainly (should we also warn?).
    return FSNode.new(path, enclosingBundle)
  end
def WalkBundle (bundle, level = 0)
  puts "#{"  " * level}[#{bundle}] #{bundle.infoDict["CFBundleIdentifier"]} #{bundle.infoDict["CFBundleSupportedPlatforms"]}"
  for machoFile in bundle.machoFiles.each
    puts "#{"  " * level} #{machoFile}"
    for machoImage in machoFile.machoImages
      puts "#{"  " * level} #{machoImage.type} #{machoImage.arch} #{machoImage.uuid}"
    end
  end
  for nestedBundle in bundle.nestedBundles
    WalkBundle(nestedBundle, level + 1)
  end
def WalkFiles (node, level = 0)
  puts "#{"  " * level}#{node.class}  #{node}"
  for subnode in (node.subnodes || [])
    WalkFiles(subnode, level + 1)
  end
class String
  def quote
    "\"#{self.gsub("\\", "\\\\").gsub("\"", "\\\"")}\""
  end
# Validate an unpacked IPA, emitting issues to the JSON.
def ValidateIPA (ipa)
  puts "Validating IPA structure..."
  # Then check the main bundle (and any nested subbundles).
  ValidatePayloadBundle(ipa.mainBundle, ipa)
  bundleDisplayPath = ipa.mainBundle.path.relative_path_from(ipa.payloadPath)
  deploymentTarget = ipa.mainBundle.deploymentTarget
  EmitIPAPayloadValidationError("Failed to parse MinimumOSVersion from 
#{bundleDisplayPath}/Info.plist
") if
    !deploymentTarget || deploymentTarget.to_s == "" || !Gem::Version.correct?(deploymentTarget.to_s)
# Validate a bundle in the payload of an unpacked IPA, emitting issues to the JSON.
def ValidatePayloadBundle (bundle, ipa, level = 0)
  bundleDisplayPath = bundle.path.relative_path_from(ipa.payloadPath)
  # Check the specific bundle we're given.
  EmitIPAPayloadValidationError("Bundle 
#{bundleDisplayPath}
 does not specify a platform identifier in its Info.plist") unless bundle.platformIdentifier.nil_if_empty
  EmitIPAPayloadValidationError("Info.plist of 
#{bundleDisplayPath}
 specifies a simulator platform for the CFBundleSupportedPlatforms key") if bundle.platformIdentifier.end_with?("simulator")
  platform = Platform.platformForIdentifer(bundle.platformIdentifier)
  EmitIPAPayloadValidationError("Bundle 
#{bundleDisplayPath}
 specifies an unknown platform in its Info.plist") unless platform
  EmitIPAPayloadValidationError("Info.plist of 
#{bundleDisplayPath}
 specifies WKWatchKitApp=1 but it is an iOS WatchKit extension") if
    bundle.infoDict['CFBundleSupportedPlatforms'] == ["iPhoneOS"] &&
    bundle.infoDict["WKWatchKitApp"] == true &&
    bundle.infoDict["NSExtension"].kind_of?(Hash) &&
    bundle.infoDict["NSExtension"]["NSExtensionPointIdentifier"] == "com.apple.watchkit"
  EmitIPAPayloadValidationError("Info.plist of 
#{bundleDisplayPath}
 should specify UIDeviceFamily with an array containing one or more entries") if bundle.supportedIdioms.nil_if_empty.nil?
  if bundle.isBitcodeCompilationRootBundle
    # It's a main bundle for its platform.  As such, we expect it to have a main Mach-O.
    mainMachoFile = bundle.bitcodeCompilationRootMachO
    if mainMachoFile.nil?
      EmitIPAPayloadValidationError("main bundle #{bundle.path.relative_path_from(ipa.payloadPath)} doesn't have a main Mach-O file")
    elsif !mainMachoFile.kind_of?(FSMachOFileNode)
      $stderr.puts "Main bundle '#{bundle.path.to_s}' : '#{bundle.platform.identifier}' main mach-o '#{mainMachoFile.path.to_s}' is of type '#{mainMachoFile.class.name}'"
      EmitIPAPayloadValidationError("main bundle #{bundle.path.relative_path_from(ipa.payloadPath)} specifies a main Mach-O file ('#{mainMachoFile.name}') that isn't an actual Mach-O")
    end
  end
  if platform
    for machoFile in bundle.machoFiles
      if machoFile.machoImages.any?{|mi| mi.hasBitcode }
        out_str, status = Open3.capture2e('bitcode-build-tool',
                                          "-t", (OPTIONS.toolchainDir + "bin").to_s,
                                          "--sdk", platform.sdkPath.to_s,
                                          '--verify', machoFile.path.to_s,
                                          )
        if !status.success?
          if status.exitstatus == 1
            EmitIPAPayloadValidationError("Failed to verify bitcode in #{machoFile.path.relative_path_from(machoFile.path.parent.parent)}:\n" + out_str)
          else
            raise ("bitcode-build-tool failed with #{status}: " + out_str)
          end
        end
      end
    end
  end
  # Recurse through any nested bundles (including, possibly, those of other platforms).
  for subbundle in bundle.nestedBundles
    ValidatePayloadBundle(subbundle, ipa, level + 1)
  end
def ValidateOutputIPA (srcIPA, outputIPA, options)
  # There should be no AppThinning plist
  if outputIPA.appThinningInfoPath.exist?
    EmitIPAOutputValidationError("Should have been removed: #{outputIPA.appThinningInfoPath.to_s.shellescape}")
  end
  # If we've changed the deployment target, it should have 2+ components for binary compatibility
  srcDeploymentTarget = srcIPA.mainBundle.infoDict["MinimumOSVersion"]
  deploymentTarget = outputIPA.mainBundle.infoDict["MinimumOSVersion"]
  if srcDeploymentTarget != deploymentTarget && (deploymentTarget.nil? || !deploymentTarget.kind_of?(String) || deploymentTarget.split('.').count < 2)
    EmitIPAOutputValidationError("Expected a MinimumOSVersion with 2+ dot-separated components but got '#{deploymentTarget}' in #{outputIPA.mainBundle.path.relative_path_from(outputIPA.path).to_s}")
  end
  # We should insert DTAppStoreToolsBuild
  appStoreToolsBuildVersion = outputIPA.mainBundle.infoDict["DTAppStoreToolsBuild"]
  if appStoreToolsBuildVersion == nil
    EmitIPAOutputValidationError("Expected Info.plist:DTAppStoreToolsBuild in #{outputIPA.mainBundle.path.relative_path_from(outputIPA.path).to_s}")
  else
    unless appStoreToolsBuildVersion =~ APP_STORE_TOOLS_BUILD_VERSION_PATTERN
      EmitIPAOutputValidationError(__LINE__, "Expected #{appStoreToolsBuildVersion} to match #{APP_STORE_TOOLS_BUILD_VERSION_PATTERN}, e.g. 10A208 or 10A208a")
    end
  end
  # We should have no remaining bitcode
  for machO in outputIPA.mainBundle.enumerateTree.select{|n| n.kind_of?(FSMachOFileNode) && n.machoImages.any?{|i| i.hasBitcode } }
    EmitIPAOutputValidationError("Found bitcode in #{machO.path}")
  end
  # If we compiled bitcode, we should have symbols
  if options.compileBitcode
    dSYMsDir = outputIPA.path + "dSYMs"
    dSYMs = if Dir.exist?(dSYMsDir) then Set.new(Dir.entries(dSYMsDir)) else Set.new() end
    
    symbolsDir = outputIPA.path + "Symbols"
    symbols = if Dir.exist?(symbolsDir) then Set.new(Dir.entries(symbolsDir)) else Set.new() end
    srcMachOs = srcIPA.mainBundle.enumerateTree.select{|n| n.kind_of?(FSMachOFileNode) }
    
    for machO in outputIPA.mainBundle.enumerateTree.select{|n| n.kind_of?(FSMachOFileNode) }
      correspondingInputPath = machO.path.relative_path_from(outputIPA.path)
      correspondingInputMachO = srcMachOs.detect{|n| n.path.relative_path_from(srcIPA.path) == correspondingInputPath }
      assert(correspondingInputMachO, "Could not find macho node with path: #{correspondingInputPath} in #{srcMachOs.map{|n| n.path.relative_path_from(srcIPA.path).to_s }}")
      
      for image in machO.machoImages
        correspondingInputImage = correspondingInputMachO.machoImages.detect{|i| i.arch == image.arch }
        if correspondingInputImage.nil? && options.translateWatchOS
          correspondingInputImage = correspondingInputMachO.machoImages.detect{|i| i.arch == "armv7k" && image.arch == "arm64_32" }
        end
        assert(correspondingInputImage, "Couldn't find image for #{image.arch} among #{correspondingInputMachO.machoImages.map{|i|i.arch}}")
        
        if correspondingInputImage.shouldCompileBitcode(options)
          EmitIPAOutputValidationError("Could not find dSYM for: #{machO.path} : #{image.arch}") unless dSYMs.include?(image.uuid + ".dSYM")
          EmitIPAOutputValidationError("Could not find symbols for: #{machO.path} : #{image.arch}") unless symbols.include?(image.uuid + ".symbols")
        end
      end
    end
  end
def CreateAssetPackManifest (assetPackDirPath, assetPackManifestFilePath, urlPrefix, parentPathForDisplay = nil)
  # Given a directory full of asset packs, go through them and create a manifest from them.
  assetPackManifestDicts = []
  for assetPackPath in assetPackDirPath.children.sort
    # Skip it if it isn't an asset pack.
    next unless assetPackPath.extname == ".assetpack"
    # Load the Info.plist from the asset pack.
    infoPlist = LoadUserPlist(assetPackDirPath + assetPackPath.basename + "Info.plist", parentPathForDisplay)
    nativeInfoPlist = CFPropertyList::native_types(infoPlist.value) unless infoPlist == nil
    # Here we should check that we have an Info.plist, and that it's well formed.
    next unless nativeInfoPlist
    # Add a dictionary entry to the AssetPackManifest.plist array.
    assetPackManifestDicts << {
      URL: urlPrefix + assetPackPath.basename.to_s,
      bundleKey: nativeInfoPlist["CFBundleIdentifier"] || "",
      isStreamable: true,
    }
  end
  # Emit the AssetPackManifest.plist.
  outputAssetPackManifestPlist = CFPropertyList::List.new
  outputAssetPackManifestPlist.value = CFPropertyList.guess({ "resources" => assetPackManifestDicts })
  outputAssetPackManifestPlist.save(assetPackManifestFilePath, CFPropertyList::List::FORMAT_XML)
# Creates an output IPA.  If thinning traits are provided, the output is thinned; otherwise, it's copied as-is.  Asset
# packs can optionally be extracted, and if an URL prefix is provided, an AssetPackManifest.plist can be created. This
# function returns a structure of information describing the created outputs.  This function doesn't deal with bitcode
# in any way; it assumes that bitcode has already been compiled, if needed.   The destination path is first removed if
# it exists, and any ancestor directories are created, if needed.
def CreateOutputIPA (srcIPA, cleanSrcIPA, dstPath, thinningContext, extractAssetPacks = false, assetPackManifestURLPrefix = nil, createPlaceholderBundle = false)
  # Create a result struct to contain the output describing the outputs.  It always contains at least the path.
  outputInfo = OpenStruct.new
  outputInfo.path = dstPath
  $stdout.puts "Creating #{thinningContext.traits ? thinningContext.traits.to_s : "universal"} IPA contents for #{thinningContext.variants.nil_if_empty ? thinningContext.variants.collect{|x|x.to_s}.sort.join(", ") : "all variants"}" if OPTIONS.verbosity >= 1
  # Remove anything that's already at the destination path.
  $stdout.puts "  Removing existing output directory" if dstPath.exist? and OPTIONS.verbosity >= 1
  dstPath.rmtree() rescue Errno::ENOENT
  # Create the output directory, and any ancestor directories.
  $stdout.puts "  Creating directory #{dstPath.to_s.shellescape}" if OPTIONS.verbosity >= 1
  dstPath.mkpath()
  # Copy the main payload bundle.  Whether or not it will be thinned as it is being copied depends on whether or not
  # we were given any thinning traits.
  $stdout.puts "  #{thinningContext.traits ? "Thinning" : "Copying"} #{srcIPA.mainBundle.name} output payload directory" if OPTIONS.verbosity >= 1
  srcIPA.mainBundle.copyToPath(dstPath + "Payload" + srcIPA.mainBundle.name, thinningContext, 2)
  srcIPA.vpnPlugins.each{ |vpnPlugin|
    # traits is intentionally nil. vpnPlugins are signed and we cannot break their signature.
    vpnPlugin.copyToPath(dstPath + "Payload" + vpnPlugin.name, ThinningContext.new(nil, nil, nil), 2)
  # Update the Info.plist of the main payload bundle to contain information about what devices it has been thinned for.
  # We copy only the Info.plist into the placeholder bundle.
  $stdout.puts "    Updating Info.plist with UISupportedDevices keys" if thinningContext.traits and OPTIONS.verbosity >= 1
  dstInfoPlistPath = dstPath + "Payload" + srcIPA.mainBundle.name + "Info.plist"
  infoPlist = LoadPlist(dstInfoPlistPath)
  nativeInfoPlist = CFPropertyList::native_types(infoPlist.value) unless infoPlist == nil
    
  nativeInfoPlist[:DTAppStoreToolsBuild] = OPTIONS.appStoreToolsBuildVersion.as(String)
  nativeInfoPlist[:UISupportedDevices] = thinningContext.variants.collect{|x|x.device.productType}.sort.uniq if thinningContext.variants.nil_if_empty
  if thinningContext.variants.nil_if_empty
    inputDeploymentTarget = srcIPA.mainBundle.deploymentTarget
    variantDeploymentTarget = thinningContext.variants.min { |a,b| a.traits.deploymentTarget <=> b.traits.deploymentTarget }.traits.deploymentTarget
    deploymentTarget = [inputDeploymentTarget, variantDeploymentTarget].max
    if deploymentTarget != inputDeploymentTarget
      components = deploymentTarget.to_s.split('.')
      if components.count < 2
        components << [0]
      end
      nativeInfoPlist[:MinimumOSVersion] = components.join('.')
    end
  end
  modifiedInfoPlist = CFPropertyList::List.new
  modifiedInfoPlist.value = CFPropertyList.guess(nativeInfoPlist)
  FileUtils.rm_f(dstInfoPlistPath)
  modifiedInfoPlist.save(dstInfoPlistPath, CFPropertyList::List::FORMAT_XML)
  preferred_arch_runnable_archs = thinningContext.traits ? CPUArchitecture.get(thinningContext.traits.preferredArch).runnable_architectures : []
  # Also copy any DWARF debug symbols files that are associated with it (generated by compiling bitcode).
  # Depending on our thinning options, we might be copying all of them, or only some.
  dsymFiles = (thinningContext.traits ? srcIPA.dsymFiles.select{ |p| preferred_arch_runnable_archs.include?(p.arch) } : srcIPA.dsymFiles) + srcIPA.dsymFilesUnthinned
  unless dsymFiles.empty?
    # Create a dSYMs directory in the output IPA.
    dsymDirPath = dstPath + "dSYMs"
    dsymDirPath.mkpath()
    $stdout.puts "  Copying .dSYM files to #{dsymDirPath.to_s.shellescape}" if OPTIONS.verbosity >= 1
    # Copy each of the .dSYM files to the dSYMs directory.
    for dsymFile in dsymFiles
      $stdout.puts "    #{dsymFile.basename.to_s.shellescape}" if OPTIONS.verbosity >= 2
      FileUtils.rmtree(dsymDirPath + dsymFile.basename)
      FileUtils.cp_r(dsymFile, dsymDirPath + dsymFile.basename)
    end
  end
  # Also copy any symbol cache files that are associated with it (generated by compiling bitcode).
  # Depending on our thinning options, we might be copying all of them, or only some.
  symcacheFiles = (thinningContext.traits ? srcIPA.symcacheFiles.select{ |p| preferred_arch_runnable_archs.include?(p.arch) } : srcIPA.symcacheFiles) + srcIPA.symcacheFilesUnthinned
  unless symcacheFiles.empty?
    # Create a Symbols directory in the output IPA.
    symbolsDirPath = dstPath + "Symbols"
    symbolsDirPath.mkpath()
    $stdout.puts "  Copying .symbols files to #{symbolsDirPath.to_s.shellescape}" if OPTIONS.verbosity >= 1
    # Copy each of the .symbols files to the Symbols directory.
    for symcacheFile in symcacheFiles
      $stdout.puts "    #{symcacheFile.basename.to_s.shellescape}" if OPTIONS.verbosity >= 2
      FileUtils.rmtree(symbolsDirPath + symcacheFile.basename)
      FileUtils.cp_r(symcacheFile, symbolsDirPath + symcacheFile.basename)
    end
  end
  # Extract asset packs, if appropriate.
  if srcIPA.hasAssetPacks
    # See if we're supposed to extract them.
    if extractAssetPacks
      # We're extracting asset packs into a directory next to the product, with a "-assetpacks" suffix.
      assetPackOutputDir = dstPath.parent + (dstPath.basename.to_s + "-assetpacks")
      $stdout.puts "  Extracting #{thinningContext.traits ? "thinned" : "unmodified"} asset packs to #{assetPackOutputDir.to_s.shellescape}" if OPTIONS.verbosity >= 1
      for assetPack in srcIPA.assetPacks
        $stdout.puts "    #{assetPack.name.to_s.shellescape}" if OPTIONS.verbosity >= 2
        assetPack.copyToPath(assetPackOutputDir + assetPack.name, thinningContext, 2)
      end
      outputInfo.assetPackOutputDir = assetPackOutputDir
      # Emit the AssetPackManifest.plist file, if appropriate.
      if assetPackManifestURLPrefix
        # We will put the asset pack manifest plist into the asset pack output directory.
        assetPackManifestFilePath = assetPackOutputDir + "AssetPackManifest.plist";
        # Now create it from the asset pack directory.
        $stdout.puts "  Creating asset pack manifest plist at #{assetPackManifestFilePath.to_s.shellescape}" if OPTIONS.verbosity >= 1
        CreateAssetPackManifest(assetPackOutputDir, assetPackManifestFilePath, assetPackManifestURLPrefix, srcIPA.payloadPath)
        # Make a note of where the asset pack manifest is.
        outputInfo.assetPackManifestPath = assetPackManifestFilePath
      else
        $stdout.puts "  (not creating an asset pack manifest plist, because no manifest url prefix was provided)" if OPTIONS.verbosity >= 1
      end
    else
      # We're not extracting asset packs, but the original contained them, so we copy them over.
      assetPackOutputDir = dstPath + "Payload" + "OnDemandResources"
      $stdout.puts "  Copying #{thinningContext.traits ? "thinned" : "unmodified"} asset packs in #{assetPackOutputDir.to_s.shellescape}" if OPTIONS.verbosity >= 1
      for assetPack in srcIPA.assetPacks
        $stdout.puts "    #{assetPack.name.to_s.shellescape}" if OPTIONS.verbosity >= 2
        assetPack.copyToPath(assetPackOutputDir + assetPack.name, thinningContext, 2)
      end
    end
  end
  # Create the application placeholder bundle, if requested.
  if createPlaceholderBundle
    # The path of the directory containing the placeholder is next to the product, with a "-placeholder" suffix.
    placeholderOutputDir = dstPath.parent + (dstPath.basename.to_s + "-placeholder")
    $stdout.puts "  Creating placeholder app wrapper at #{placeholderOutputDir.to_s.shellescape}" if OPTIONS.verbosity >= 1
    # We first remove any existing entry we find there.
    placeholderOutputDir.rmtree() rescue Errno::ENOENT
    # We create a placeholder bundle inside the directory.
    placeholderAppPath = placeholderOutputDir + srcIPA.mainBundle.name
    $stdout.puts "    Creating main bundle directory #{placeholderAppPath.basename.to_s.shellescape}" if OPTIONS.verbosity >= 1
    placeholderAppPath.mkpath()
    # We copy only the Info.plist into the placeholder bundle.
    $stdout.puts "    Creating placeholder Info.plist" if OPTIONS.verbosity >= 1
    infoPlist = LoadUserPlist(srcIPA.mainBundle.infoPropertyListPath, srcIPA.payloadPath)
    nativeInfoPlist = CFPropertyList::native_types(infoPlist.value) unless infoPlist == nil
    modifiedInfoPlist = CFPropertyList::List.new
    modifiedInfoPlist.value = CFPropertyList.guess(nativeInfoPlist)
    modifiedInfoPlist.save(placeholderAppPath + "Info.plist", CFPropertyList::List::FORMAT_XML)
    # Record the placeholder bundle's path in the output info descriptor.
    outputInfo.placeholderAppPath = placeholderAppPath
  end
  if OPTIONS.validateOutput
    ValidateOutputIPA(cleanSrcIPA, IPA.new(dstPath), OPTIONS)
  end
  return outputInfo
# We need to compile the bitcode once for each architecture that contains bitcode, and we need to do so in reverse
# dependency order.  This is because a Mach-O can only be compiled when any dynamic library on which it depends has
# already been compiled (or existed as executable code in the first place).  So we use a two-pass approach:  first
# we descend down through the bundle hierarchy, building up lists of Mach-O images to compile.  As we cross platform
# boundaries, we reevaluate whether to compile or strip bitcode.  We compile if we have been asked to do so and if
# the bundle's main executable contains bitcode, otherwise we strip it.  This decision is made for each architec-
# ture, so we end up with two sets: architectures to compile and architectures to strip.  Those two sets should be
# disjoint.  Any architecture that doesn't end up in either set should be omitted.  Mach-O images to that should be
# stripped can be stripped immediately, but those that should be compiled have to be added to a list and compiled
# later, as noted above (we have to compile them in the right order).
def CompileOrStripBitcodeInBundle (ipa, options, bundle, machoImagesToCompile = nil, machoFilesToReassemble = nil, level = 0)
  # If we're at the top level or if we are crossing into a new platform (i.e. if we area looking at a "main bundle"
  # for the platform), we reset our idea of the sets of architectures for which to compile or to strip bitcode.
  if bundle.isBitcodeCompilationRootBundle
    # Start a new list of Mach-O images to compile.  Note that this does not affect the lists that are already
    # being built up by callers.
    machoImagesToCompile = []
    # We also want to keep track of the Mach-O files that we will want to reassemble from compiled or stripped
    # pieces.
    machoFilesToReassemble = []
  end
  # Now go through the Mach-O files in the bundle, looking at each image in turn.
  puts "  #{"|  " * level}#{bundle.path.relative_path_from(ipa.payloadPath)} (identifier: #{bundle.identifier}, platform: #{bundle.platformIdentifier})" if options.verbosity >= 2
  for machoFile in bundle.machoFiles
    # Now go through the Mach-O images in the file, either compiling, stripping, or excluding as appropriate
    # based on its architecture.  We replace the list of Mach-O images with a possibly smaller list.
    puts "  #{"|  " * level}#{machoFile.type.downcase} '#{machoFile.path.relative_path_from(ipa.payloadPath)}'..." if options.verbosity >= 2
    adjustedMachoImages = []
    for machoImage in machoFile.machoImages
      # Exclude this Mach-O image if its architecture isn't one of the ones we want.
      if machoImage.shouldExcludeFromOutput
        puts "  #{"|  " * level}.#{machoImage.arch} (exclude)" if options.verbosity >= 2
        next
      end
      # Otherwise, we first make sure there's a thin Mach-O image file (this might
      # use lipo, or might just copy (or hard-link) the file if we already have a thin slice).
      machoImageInputPath = machoImage.thinnedInputPath(ipa, options)
      machoImageInputPath.parent.mkpath()
      
      machoImageOutputPath = machoImage.thinnedOutputPath(ipa, options)
      machoImageOutputPath.parent.mkpath()
      shouldCompileBitcode = nil
      # Some Watch apps are missing bitcode in their payload Swift libs, but do have bitcode in the archive's SwiftSupport
      if options.compileBitcode && !machoImage.hasBitcode && bundle.isWatchKitStubApp && machoFile.platform.identifier == "watchos" && machoFile.isSwiftRuntimeDylib
        replacementFile = ipa.path + "SwiftSupport" + "watchos" + machoFile.path.basename
        EmitFatalIPAPayloadValidationError("missing bitcode in #{machoFile.path.to_s.shellescape} : #{machoImage.arch} and no replacement found in SwiftSupport in #{replacementFile.to_s.shellescape}") unless File.exist?(replacementFile.to_s)
        
        replacementMachoFile = MakeFileSystemNode(replacementFile, nil, nil, nil).as(FSMachOFileNode, replacementFile.to_s)
        replacementMachoImage = replacementMachoFile.machoImages.detect { |i| i.arch == machoImage.arch }
        EmitFatalIPAPayloadValidationError("missing bitcode in both #{machoFile.path.to_s.shellescape} : #{machoImage.arch} and #{replacementMachoFile.path.to_s.shellescape} (missing arch)") unless replacementMachoImage
        EmitFatalIPAPayloadValidationError("missing bitcode in both #{machoFile.path.to_s.shellescape} : #{machoImage.arch} and #{replacementMachoFile.path.to_s.shellescape} : #{replacementMachoImage.arch}") unless replacementMachoImage.hasBitcode
        
        replacementMachoImage.thinToPath(machoImageInputPath, level)
        shouldCompileBitcode = true
      else
        machoImage.thinToPath(machoImageInputPath, level)
        shouldCompileBitcode = machoImage.shouldCompileBitcode(options)
      end
      
      # What we do next depends on whether or not the Mach-O has bitcode.
      if shouldCompileBitcode
        # Because we have to compile Mach-Os in dependency order, we defer the actual compilation.
        puts "  #{"|  " * level}.#{machoImage.arch} (compile)" if options.verbosity >= 2
        machoImagesToCompile << machoImage
        
      elsif machoImage.shouldStripBitcode(options)
        # But we can strip bitcode from the binary right away (no need to defer).  We do so in-place.
        puts "  #{"|  " * level}.#{machoImage.arch} (strip)" if options.verbosity >= 2
        CmdSpec.new(locate_tool("bitcode_strip", [machoImage.platform.toolsPath]), [ "-r", "-o", machoImageOutputPath, machoImageInputPath ]).run(level)
        # Strip Swift symbols from Swift dylibs
        if machoImage.machoFile.isSwiftRuntimeDylib && ipa.stripSwiftSymbols
          CmdSpec.new(locate_tool("strip", [machoImage.platform.toolsPath]), [ "-ST", machoImageOutputPath ]).run(level)
        end
        
      else
        # Otherwise, the Mach-O image doesn't have bitcode, so we strip swift symbols.
        
        # Strip Swift symbols from Swift dylibs
        if machoImage.machoFile.isSwiftRuntimeDylib && ipa.stripSwiftSymbols
          CmdSpec.new(locate_tool("strip", [machoImage.platform.toolsPath]), [ "-ST", "-o", machoImageOutputPath, "-", machoImageInputPath ]).run(level)
          verb = "strip-swift-dylib"
        else
          FileUtils.cp(machoImageInputPath, machoImageOutputPath)
          verb = "copy"
        end
        
        puts "  #{"|  " * level}.#{machoImage.arch} (#{verb})" if options.verbosity >= 2
      end
      # Add the Mach-O image as one that will appear in the universal Mach-O.
      adjustedMachoImages << machoImage
    end  # images
    # Set the list of adjusted Mach-O images as the Mach-O file's new list (excluding any unused images).
    machoFile.machoImages = adjustedMachoImages
    # Also remember that we'll need to re-lipo this Mach-O file for the universal binary.
    machoFilesToReassemble << machoFile
  end  # files
  # Recurse through any subbundles (including, possibly, those of other platforms).  We pass down or context
  # and accumulator containers.
  for subbundle in bundle.nestedBundles
    CompileOrStripBitcodeInBundle(ipa, options, subbundle, machoImagesToCompile, machoFilesToReassemble, level + 1)
  end
  # If we're a main bundle, we do the postprocessing, now that we've dealt with all Mach-Os and all subbundles.
  # This includes compiling any bitcode files that need it (in library dependency order), and reassembling the
  # Mach-O files for use in the universal binary.
  if bundle.isBitcodeCompilationRootBundle
    # Now go through the list of Mach-O images we need to compile.  We process them one architecture at a time.
    # We have already copied bitcode-less executables into a single per-architecture directory, so the bitcode
    # compiler will be able to find them.
    archsToCompile = if options.compileBitcode then bundle.bitcodeCompilationRootMachO.machoImages.select{|i| i.hasBitcode}.map{|i| i.arch} else [] end
    if options.compileBitcode && options.translateWatchOS && archsToCompile == ["armv7k"] && bundle.platform.identifier == "watchos"
      archsToCompile << "arm64_32"
    end
    
    for arch in archsToCompile
      # Get the list of Mach-O images that match the current architecture.
      puts "  #{"|  " * level}Compiling bitcode for #{arch}..." if options.verbosity >= 1
      remainingMachoImagesForArch = machoImagesToCompile.select{ |img| img.arch == arch }.nil_if_empty || machoImagesToCompile.select{ |img| img.arch == "armv7k" && arch == "arm64_32" }
      # Find the first Mach-O image that doesn't link against any Mach-O images that we still need to compile.
      while not remainingMachoImagesForArch.empty?
        # We still have Mach-O images to compile, so we need to find the next one whose dependencies have all
        # been resolved.
        namesOfRemainingMachOs = remainingMachoImagesForArch.select{|image| image.isDylib }.map{ |image| image.machoFile.name }
        machoImage = remainingMachoImagesForArch.select{ |image| (namesOfRemainingMachOs & image.dylibNames) == [] }.first
        # If we found a Mach-O image, we compile it.  If not, it means we hit a dependency cycle.
        if machoImage
          # Compile the bitcode, requesting that a .dSYM also be created in the output directory.  If the IPA has
          # a bitcode symbol deobfuscation map, we also pass it in now.
          machoName = machoImage.machoFile.name
          puts "  #{"|  " * level}  Compiling #{arch} bitcode in '#{machoName.to_s.shellescape}'" if options.verbosity >= 1
          dsymPath = options.tmpDir + "dSYMs" + arch + (machoName  + ".dSYM")
          dsymPath.parent.mkpath()
          bitcodeSymbolMap = ipa.bitcodeSymbolMapsPath if ipa.hasBitcodeSymbolMaps
          platformIdent = machoImage.platformIdentifier
          platform = Platform.platformForIdentifer(platformIdent)
          FatalError(__LINE__, "failed to compile bitcode for #{machoName} because we couldn't find the platform with identifier '#{platformIdent}'", platformIdent) unless platform
          
          machoImageOutputPath = machoImage.thinnedOutputPath(ipa, options, arch)
          machoImageOutputPath.parent.mkpath()
          # Determine the name of the dSYM file we want.  Initially we don't know its UUID, so we pass in a fixed name, and then we'll rename it once it's been created.
          dsymFile = Pathname(machoImageOutputPath.to_s + ".dSYM")
          
          translating_watch = machoImage.arch == "armv7k" && arch == "arm64_32"
          # Invoke the bitcode-build-tool(1) tool to compile and link the bitcode in the thin Mach-O file.
          begin
            cmdln  = []
            cmdln += [ "-v" ]
            cmdln += [ "-t", options.toolchainDir + "bin" ]
            cmdln += ipa.linkageGraph[machoImage].map{|img| img.thinnedOutputPath(ipa, options, arch).parent }.uniq.map{|p| ["-L", p] }.flatten
            cmdln += [ "--sdk", platform.sdkPath ]
            cmdln += [ "-o", machoImageOutputPath ]
            cmdln += [ "--generate-dsym", dsymFile ] if dsymFile
            cmdln += [ "--symbol-map", bitcodeSymbolMap ] if bitcodeSymbolMap
            cmdln += [ "-j", options.bitcodeCompilationJFactor ] if options.bitcodeCompilationJFactor and options.bitcodeCompilationJFactor > 0
            for opt in options.bitcodeOptions
              cmdln += [ opt ]
            end
            if ipa.stripSwiftSymbols
              cmdln += [ "--strip-swift-symbols" ]
            end
            if translating_watch
              cmdln += [ "--translate-watchos" ]
            end
            cmdln += [ machoImage.thinnedInputPath(ipa, options) ]
            CmdSpec.new(locate_tool("bitcode-build-tool", [machoImage.platform.toolsPath]), cmdln).run(level)
          end
          # Invoke the symbols(1) tool to create a symbol cache.
          begin
            cmdln  = []
            cmdln += [ "-failIfMissingDsym" ] if dsymFile
            cmdln += [ "-symbolsPackageDir", machoImageOutputPath.parent ]
            cmdln += [ machoImageOutputPath ]
            CmdSpec.new(locate_tool("symbols", [machoImage.platform.toolsPath]), cmdln).run(level)
            
            # We successfully created the symbol cache file(s).  We don't get told their names, so we scan them all, and figure out which ones are new.
            allSymcacheFiles = machoImageOutputPath.parent.children.sort.select{|f| f.extname == ".symbols" }
            newSymcacheFiles = allSymcacheFiles - ipa.symcacheFiles - ipa.symcacheFilesUnthinned
            # Go through the new ones, annotating each one with the architecture, and adding it to the IPA's list of symcache files.
            for symcacheFile in newSymcacheFiles
              # The architecture is the same as the original Mach-O architecture.
              symcacheFile.arch = arch
              if machoImage.machoFile.shouldThin
                ipa.symcacheFiles << symcacheFile
              else
                ipa.symcacheFilesUnthinned << symcacheFile
              end
            end
          end
          # If bitcode-build-tool(1) created a .dSYM file, we need to look in it to determine its UUID. Then we rename to it have that UUID.
          if dsymFile
            dsymBinaryPath = dsymFile + "Contents" + "Resources" + "DWARF" + machoName
            dsymImages = GetMachOImagesFromOToolInfoForFile(dsymBinaryPath)
            dsymImageForArch = dsymImages.detect{|i| i.arch == arch }
            assert(dsymImageForArch, "Couldn't find image for arch '#{arch}' in '#{dsymImages.map{|i|i.arch}}'")
            uuid = dsymImageForArch.uuid
            if uuid.nil_if_empty.nil?
              FatalError(__LINE__, "failed to determine UUID of dSYM file #{dsymFile.to_s.shellescape}")
            else
              # We were able to figure out the path of the dSYM, so we can rename the output file to it.  We annotate it with the architecture.
              newFileName = (uuid + ".dSYM")
              puts "  #{"|  " * level}  Renaming '#{dsymFile}' -> '#{newFileName}')" if options.verbosity >= 2
              newDSYMFile = dsymFile.parent + newFileName
              dsymFile.rename(newDSYMFile)
              dsymFile = newDSYMFile
              # We were successful, so annotate the path of the dsymFile with the architecture, and add it to the IPA's list of dSYMs.
              dsymFile.arch = arch
              if machoImage.machoFile.shouldThin
                ipa.dsymFiles << dsymFile
              else
                ipa.dsymFilesUnthinned << dsymFile
              end
            end
          end
          # Dequeue the Mach-O image we compiled, so we can move on to the next one.
          remainingMachoImagesForArch.delete(machoImage)
        else
          # We didn't find a Mach-O image, so we have a cycle.
          log = remainingMachoImagesForArch.map{|image| "\t#{image.machoFile.name}: #{(image.dylibNames & namesOfRemainingMachOs).join(', ')}" }.join("\n")
          FatalError(__LINE__, "failed to compile bitcode: found a cycle involving Mach-Os:\n#{log}")
        end
      end
    end
    # Finally, reassemble universal (multi-architecture) Mach-Os from the thin ones.
    for machoFile in machoFilesToReassemble
      # If we get here, we know that we have thin Mach-Os for every architecture (we exploded them into thin files).
      puts "  #{"|  " * level}Reassembling #{machoFile.path.relative_path_from(ipa.payloadPath)} [#{machoFile.machoImages.map{ |img| img.arch }.join(", ")}]" if options.verbosity >= 2
      univMachoFilePath = machoFile.universalReassemblyPath(ipa, options)
      univMachoFilePath.parent.mkpath()
      # :: [[arch, path]]
      inputs = machoFile.machoImages.map { |img| [img.arch, img.thinnedOutputPath(ipa, options)] }
      if options.compileBitcode && options.translateWatchOS && machoFile.enclosingBundle.platform.identifier == "watchos" && inputs.count == 1 && inputs[0][0] == "armv7k"
        if machoFile.enclosingBundle.isWatchKitStubApp && (machoFile.enclosingBundle.mainMachoFile == machoFile || machoFile.path.relative_path_from(machoFile.enclosingBundle.path) == Pathname("_WatchKitStub/WK"))
          sdkStubPath = machoFile.enclosingBundle.platform.sdkPath + "Library/Application Support/WatchKit/WK"
          
          archs = ["armv7k", "arm64_32"]
          stubImgs = (GetMachOImagesFromOToolInfoForFile(sdkStubPath) || []).select { |i| archs.include?(i.arch) }
          raise "Couldn't find #{archs} in #{sdkStubPath.to_s}" if stubImgs.count != archs.count
          
          # this has the side-effect of updating the machoFile parent pointer on each image, and we need that to call thinToPath
          FSMachOFileNode.new(sdkStubPath, nil, stubImgs)
          
          inputs = stubImgs.collect {|stubImg|
            thinnedStubPath = options.tmpDir + "WK_AST_stub_#{stubImg.arch}"
            stubImg.thinToPath(thinnedStubPath, level+1)
            [stubImg.arch, thinnedStubPath]
          }
        else
          inputs << ["arm64_32", machoFile.machoImages[0].thinnedOutputPath(ipa, options, "arm64_32")]
        end
      end
      
      if inputs.count == 1
        # We have only a single Mach-O image, so we just copy the thin file instead of creating a universal Mach-O with a single image.
        path = inputs[0][1]
        FileUtils.cp(path, univMachoFilePath)
        puts "  #{"|  " * level}  [cp #{path.to_s.shellescape} #{univMachoFilePath.to_s.shellescape}]" if options.verbosity >= 3
      else
        # We have more than one Mach-O image, so we use 'lipo' to put them back together.
        cmdln  = [ "-create" ]
        for arch, path in inputs
          cmdln += [ "-arch", arch, path ]
        end
        cmdln += [ "-output", univMachoFilePath ]
        
        CmdSpec.new(locate_tool("lipo", [machoFile.platform.toolsPath]), cmdln).run(level, true)
      end
      machoFile.path = univMachoFilePath
    end
  end  # isBitcodeCompilationRootBundle
# Main function for processing an unpacked IPA with a set of options.
# The first parameter is a directory containing the unpacked IPA contents, the second parameter is an options OpenStruct.
def ProcessIPA (ipaDir, options)
  # Create a model object to represent the IPA.  This will scan the file system hierarchy and return an object tree.
  puts "Scanning IPA..." if OPTIONS.verbosity >= 1
  ipa = IPA.new(ipaDir)
  # Create a new IPA from source, because srcIPA will be mutated
  cleanSrcIPA = if OPTIONS.validateOutput then IPA.new(ipaDir) else nil end
  # Check the input.  We always do this, since it's not very expensive and it makes many subsequent errors much clearer.
  ValidateIPA(ipa)
  if $EMITTED_ERRORS
    exit(1)
  end
  # Get a hold of the main bundle.
  mainBundle = ipa.mainBundle
  # If we weren't able to create a main bundle, we cannot proceed.
  if mainBundle == nil
    FatalError(__LINE__, "could not find main bundle in IPA 
#{OPTIONS.ipaName}
  end
  unless mainBundle.kind_of?(FSBundleDirectoryNode)
    FatalError(__LINE__, "main bundle in IPA 
#{OPTIONS.ipaName}
 doesn't seem to be well-formed")
  end
  JsonOutput[:thinnableAssetCatalogs] = ipa.thinnableAssetCatalogs.map{|x|x.path.to_s}
  # Check that the processing options make sense for the input IPA.  Otherwise we warn about it and disable asset packs.
  if options.createAssetPacks and not ipa.hasAssetPacks
    # We've been asked to create on-demand asset packs but the IPA doesn't contain any.
    EmitWarning(__LINE__, "Asset pack creation requested but IPA doesn't contain any ODR assets; ignoring the request")
    options.createAssetPacks = false
  end
  # Deal with bitcode.  If we've been asked to compile bitcode, we do so.  If we haven't been asked to compile bitcode,
  # but we have been asked to do thinning, we strip bitcode.  We also strip bitcode (instead of compiling it) if we've
  # been asked to compile bitcode but the main exectuable doesn't contain bitcode (this choice is made separately for
  # every platform).
  if options.compileBitcode or !options.thinDevices.empty?
    # Compile and/or strip any bitcode in the bundle.  This doesn't modify the input; any compiled or stripped binaries
    # are written to the temporary directory, and individual nodes in the node hierarchy are made to point to it.
    puts "#{options.compileBitcode ? "Compiling" : "Stripping"} bitcode..." if options.verbosity >= 1
    CompileOrStripBitcodeInBundle(ipa, options, mainBundle)
    # Explicitly ignore ipa.vpnPlugins. vpnPlugins are signed and we cannot break their signature.
  end
  # Create thinned-out device-specific IPAs, if requested.
  if !options.thinDevices.empty?
    # First we need to determine the relevant platform; it is the platform of the main bundle.  Embedded bundles may
    # have different platforms (e.g. a WatchKit app embedded inside an iPhoneOS app) but as it is not the main bundle,
    # it will not be thinned.  This is because the type of device on which the main bundle is installed is known at
    # installation time, allowing it to be thinned, the embedded bundle could later be transferred to any supported
    # device (e.g. any type of Apple Watch), so we cannot thin it.
    # Determine the sets of device traits that actually matter for this payload.  For example, if a particular
    # device prefers armv7s and another device prefers armv7, but the payload only has armv7, then the thinned
    # payload will be the same for both, and can be used for both devices (at least as far as architectures go).
    # Same thing for the other traits.
    traitsToVariants = makeThinningTraitsToThinningVariantsMap(mainBundle, OPTIONS.thinDevices, OPTIONS.skipThinDevices, ipa)
    if options.validateOutputZeroVariants && traitsToVariants.empty?
      EmitIPAOutputValidationError("None of the specified thinning devices match the payload")
    end
    # Now iterate over the chosen traits sets and create thinned IPAs.  For each trait set, we also know the list of
    # model identifiers to which that thinned version applies.
    for traits, thinningVariants in traitsToVariants
      # Create a device-specific, thinned-out copy of the IPA for the set of traits.
      # We start by determining the name to use for the thin IPA.  We have been requested to obfuscate the name so that
      # people don't try to make assumptions about what they see in it.  The path is specified in the output JSON file,
      # so there should never be a reason for a caller to make assumptions about the specific name.
      traitsName = Digest::SHA1.hexdigest(traits.to_s)
      # Call our main workhorse method to do the heavy lifting.
      outputInfo = CreateOutputIPA(ipa, cleanSrcIPA, options.outputPath + traitsName, ThinningContext.new(traits, traits, thinningVariants), options.createAssetPacks, options.urlPrefix, options.createAppPlaceholders)
      # Make a note about the thinned IPA we created.
      JsonOutput[:thinnedIPAs] = [] unless JsonOutput[:thinnedIPAs]
      JsonOutput[:thinnedIPAs] << {
        path: outputInfo.path,
        containsAssetPacks: (true if ipa.hasAssetPacks and not options.createAssetPacks),
        placeholderAppPath: outputInfo.placeholderAppPath,
        devices: thinningVariants.collect{|x|x.device.productType}.sort.uniq,
        installTargets: thinningVariants.collect{|x|
          {
            deviceModel: x.device.productType,
            operatingSystemVersion: x.traits.deploymentTarget.to_s
          }
        }.uniq,
        traits: traits.to_dict,
      }.reject { |k, v| v.nil? }
      if outputInfo.assetPackOutputDir
        # Make a note about the thinned asset packs we created.
        JsonOutput[:thinnedAssetPackSets] = [] unless JsonOutput[:thinnedAssetPackSets]
        JsonOutput[:thinnedAssetPackSets] << {
          path: outputInfo.assetPackOutputDir,
          manifest: outputInfo.assetPackManifestPath,
          devices: thinningVariants.collect{|x|x.device.productType}.sort.uniq,
          installTargets: thinningVariants.collect{|x|
            {
              deviceModel: x.device.productType,
              operatingSystemVersion: x.traits.deploymentTarget.to_s
            }
          }.uniq,
          traits: traits.to_dict,
        }.reject { |k, v| v.nil? }
      end
      puts if OPTIONS.verbosity >= 2
      puts "Created IPA at: #{outputInfo.path.to_s.shellescape}"
      puts "   and ODRs at: #{outputInfo.path.parent + (outputInfo.path.basename.to_s + "-assetpacks")}" if options.createAssetPacks
      puts "   and PLCs at: #{outputInfo.path.parent + (outputInfo.path.basename.to_s + "-placeholder")}" if options.createAppPlaceholders
      puts "   for deployment variants: #{thinningVariants.collect{|x|x.to_s}.sort.join(", ")}"
      puts
      puts if OPTIONS.verbosity >= 2
    end
  end
  # Unless we're just being asked for information or validating, we should also create the universal IPA.
  if not OPTIONS.printInfo and not OPTIONS.validateInput
    # Create a device-generic, universal copy of the IPA (though we might have compiled bitcode, and might or might not
    # be extracting asset packs and creating placeholder appwrappers, etc... all we know is that we're not thinning).
    # Call our main workhorse method to do the heavy lifting.
    outputInfo = CreateOutputIPA(ipa, cleanSrcIPA, options.outputPath + "universal", ThinningContext.new(nil, nil, nil), options.createAssetPacks, options.urlPrefix, options.createAppPlaceholders)
    # Make a note about the universal IPA we created.
    JsonOutput[:universalIPA] = {
      path: outputInfo.path,
      containsAssetPacks: (true if ipa.hasAssetPacks and not options.createAssetPacks),
      placeholderAppPath: outputInfo.placeholderAppPath,
    }.reject { |k, v| v.nil? }
    if outputInfo.assetPackOutputDir
      # Make a note about the asset packs we created.
      JsonOutput[:universalAssetPackSet] = {
        path: outputInfo.assetPackOutputDir,
        manifest: outputInfo.assetPackManifestPath,
      }.reject { |k, v| v.nil? }
    end
  end
  # Emit information about the payload, if requested.
  if OPTIONS.printInfo
    def NestedPayloadBundleInfoForJSON (bundle)
      # Construct and return a dictionary of bundle information, including for any nested bundles.
      info = {
        path: bundle.path,
        identifier: bundle.identifier,
        platform: bundle.platformIdentifier,
        isBitcodeCompilationRootBundle: bundle.isBitcodeCompilationRootBundle,
        bitcodeCompilationRootMachO: bundle.bitcodeCompilationRootMachO.path,
        machoFiles: bundle.machoFiles.collect do |mf|
          # Construct a dictionary for the Mach-O file.
          {  path: mf.path,
            slices: mf.machoImages.collect do |img|
              # Construct a dictionary for the Mach-O slice.
              {  type: img.type,
                platform: img.platformIdentifier,
                arch: img.arch,
                uuid: img.uuid,
                dylibNames: img.dylibNames,
                hasExecCode: img.hasExecCode,
                hasBitcode: img.hasBitcode,
                isSigned: img.isSigned,
              }
            end
          }
        end,
      }
      for subbundle in bundle.nestedBundles
        (info[:subbundles] ||= []) << NestedPayloadBundleInfoForJSON(subbundle)
      end
      return info
    end
    # Output the new-style, nested information.
    mainBundleInfo = NestedPayloadBundleInfoForJSON(mainBundle) || []
    # Add asset pack information for the main bundle (not submodules).
    mainBundleInfo[:assetPacks] = ipa.assetPacks.collect { |assetPack| assetPack.name } if ipa.assetPacks
    # Add supported-devices information for the main bundle (not submodules).
    allThinningTraitsToVariants = makeThinningTraitsToThinningVariantsMap(mainBundle, [ThinningVariantCLISpec.fromArg("all")], [], ipa)
    for traits, thinningVariants in allThinningTraitsToVariants
      # Legacy: TODO Remove
      # We get a dictionary of device traits and a list of device types for a single variant.  We partition it
      # into "device sets".  We never want to mix devices with different traits together, but we want to split
      # out some devices to make things more logical for users.
      for displayName in thinningVariants.collect{|x|x.device.displayName}.sort.uniq
        (mainBundleInfo[:supportedDeviceSets] ||= []) << {
          displayName: displayName,
          devices: thinningVariants.collect{|x|x.device}.select{ |dev| dev.displayName == displayName }.sort,
          traits: traits.to_dict,
        }
      end
    end
    
    mainBundleInfo[:allSupportedThinningVariants] = allThinningTraitsToVariants.collect {|_,vs| vs.collect { |v| v.to_dict }}
    
    JsonOutput[:nestedPayloadBundleInfo] = mainBundleInfo
  end
  if $EMITTED_ERRORS
    exit(1)
  end
class ThinningTraits
  attr_accessor :deploymentTarget # :: Gem::Version (min OS version)
  attr_accessor :passDeploymentTargetToAssetutil # :: Bool
  attr_accessor :preferredArch
  attr_accessor :artworkDevIdiom
  attr_accessor :artworkHostedIdioms
  attr_accessor :artworkScaleFactor
  attr_accessor :artworkDevSubtype
  attr_accessor :artworkDisplayGamut
  attr_accessor :artworkDynamicDisplayMode
  attr_accessor :devPerfMemoryClass
  attr_accessor :gfxFeatureSetClass
  attr_accessor :gfxFeatureSetFallbacks
  attr_accessor :featuresToRemove
  attr_accessor :supportsEmbeddedUniversalWatchApp
  def initialize (deploymentTarget, passDeploymentTargetToAssetutil, preferredArch, artworkDevIdiom, artworkHostedIdioms, artworkScaleFactor, artworkDevSubtype, artworkDisplayGamut, artworkDynamicDisplayMode, devPerfMemoryClass, gfxFeatureSetClass, gfxFeatureSetFallbacks, featuresToRemove , supportsEmbeddedUniversalWatchApp )
    deploymentTarget.assert_kind_of(Gem::Version)
    @deploymentTarget = deploymentTarget
    @passDeploymentTargetToAssetutil = passDeploymentTargetToAssetutil
    
    @preferredArch = preferredArch
    @artworkDevIdiom = artworkDevIdiom
    @artworkHostedIdioms = artworkHostedIdioms
    @artworkScaleFactor = artworkScaleFactor
    @artworkDevSubtype = artworkDevSubtype
    @artworkDisplayGamut = artworkDisplayGamut
    @artworkDynamicDisplayMode = artworkDynamicDisplayMode
    @devPerfMemoryClass = devPerfMemoryClass
    @gfxFeatureSetClass = gfxFeatureSetClass
    @gfxFeatureSetFallbacks = gfxFeatureSetFallbacks
    @featuresToRemove = featuresToRemove
    @supportsEmbeddedUniversalWatchApp = supportsEmbeddedUniversalWatchApp
  end
  def artworkDynamicDisplayMode_1080pSDR
    return "1080pSDR"
  end
  def preferredArchitectureAmongCandidates (availableArchs)
    # Given an array of available architectures, this method returns the one that's preferred.  If none are supported, we return nil.
    return CPUArchitecture.get(preferredArch).runnable_architectures.find{|a| availableArchs.include?(a) }
  end
  def supportedIdioms
    return ([self.artworkDevIdiom] + (if self.artworkDevIdiom == "pad" then ["phone"] else [] end)).sort
  end
  def == (other)
    self.to_s == other.to_s
  end
  def <=> (other)
    to_s <=> other.to_s
  end
  def eql? (other)
    return self == other
  end
  def hash
    return to_s.hash
  end
  def to_s
    return to_dict.to_s
  end
  def to_dict
    return {
      deploymentTarget: deploymentTarget,
      passDeploymentTargetToAssetutil: passDeploymentTargetToAssetutil,
      architecture: preferredArch,
      artworkDevIdiom: artworkDevIdiom,
      artworkHostedIdioms: artworkHostedIdioms,
      artworkScaleFactor: artworkScaleFactor,
      artworkDevSubtype: artworkDevSubtype,
      artworkDisplayGamut: artworkDisplayGamut,
      artworkDynamicDisplayMode: artworkDynamicDisplayMode,
      devPerfMemoryClass: devPerfMemoryClass,
      gfxFeatureSetClass: gfxFeatureSetClass,
      gfxFeatureSetFallbacks: gfxFeatureSetFallbacks,
      featuresToRemove: featuresToRemove,
      supportsEmbeddedUniversalWatchApp: supportsEmbeddedUniversalWatchApp,
    }.reject { |k, v| v.nil? }
  end
  # [(assetutilFlagName: String, traitsPropertyName: Symbol, traitsPropertyValueTransformer: Any -> String)]
  # How do you translate a device traits object for use with assetutil? You need to know which traits correspond to which assetutil flags and how to convert their values to assetutil's representation. This specifies that with a list of triples: the assetutil flag name, the corresponding ThinningTraits property name, and the function needed to convert the property value into a string to be used as an assetutil argument.
  def assetutil_translation_map
    id = Proc.new { |value| value.to_s }
    join_colon = Proc.new { |value| value.join(':') }
    join_comma = Proc.new { |value| value.join(',') }
    deploymentTargetTranslation = []
    if passDeploymentTargetToAssetutil
      deploymentTargetTranslation = [["deployment-target", :deploymentTarget, id]]
    end
    
    return deploymentTargetTranslation +
           [
            ["scale", :artworkScaleFactor, id],
            ["idiom", :artworkDevIdiom, id],
            ["subtype", :artworkDevSubtype, id],
            ["display-gamut", :artworkDisplayGamut, id],
            ["memory", :devPerfMemoryClass, id],
            ["graphicsclass", :gfxFeatureSetClass, id],
            ["graphicsclassfallbacks", :gfxFeatureSetFallbacks, join_colon],
            ["hostedidioms", :artworkHostedIdioms, join_comma],
           ]
  end
  # UIDeviceFamily #uidf may be a [String], [Int], or comma-separated String.
  def self.assetutil_idioms_for_UIDeviceFamily(uidf)
    uidf = [uidf].flatten.join(',').split(',').map{|x| x.to_s.strip.nil_if_empty }.compact.sort.uniq
    return uidf.map{|f|
      case f
      when "1"
        "phone"
      when "2"
        "pad"
      when "3"
        "tv"
      when "4"
        "watch"
      else
        raise "Unknown UIDeviceFamily: '#{f}' from '#{uidf}'"
      end
    }
  end
  # Return a copy of self where traits which affect assetutil have been taken from `other`
  def take_assetutil_traits(other)
    return ThinningTraits.new(other.deploymentTarget, other.passDeploymentTargetToAssetutil, self.preferredArch, other.artworkDevIdiom, other.artworkHostedIdioms, other.artworkScaleFactor, other.artworkDevSubtype, other.artworkDisplayGamut, other.artworkDynamicDisplayMode, other.devPerfMemoryClass, other.gfxFeatureSetClass, other.gfxFeatureSetFallbacks, self.featuresToRemove, self.supportsEmbeddedUniversalWatchApp).freeze
  end
  # { assetutilFlag: String => assetutilValue: String ]
  def to_assetutil_dict
    return assetutil_translation_map.map{|flag,sym,transformer|
      raw_value = self.send(sym)
      next unless raw_value
      
      t_value = transformer.call(raw_value)
      next unless t_value.nil_if_empty
      
      [flag, t_value]
    }.compact.to_h
  end
  # Array representation appropriate for assetutil parameters.
  # E.g. ["--idiom", "pad", "--scale", "1"]
  def to_assetutil_args_array
    if self.artworkDynamicDisplayMode == self.artworkDynamicDisplayMode_1080pSDR
      # We need two sets of args, one with 'scale:1 gamut:srgb' and one with 'scale:2 gamut:p3'
      a = self.dup
      a.artworkDynamicDisplayMode = nil
      a.artworkScaleFactor = 1
      a.artworkDisplayGamut = 'sRGB'
      
      b = self.dup
      b.artworkDynamicDisplayMode = nil
      b.artworkScaleFactor = 2
      b.artworkDisplayGamut = 'P3'
      
      return a.to_assetutil_args_array + b.to_assetutil_args_array
    else
      return self.to_assetutil_dict.to_a.map{|flag, value| ["--" + flag, value] }.flatten
    end
  end
  # String representation appropriate for assetutil -T.
  # E.g.: scale=1:idiom=pad:subtype=0:display-gamut=P3:memory=3:graphicsClass=MTL1,2:deployment=2016
  def to_assetutil_T_string
    skip = ["graphicsclassfallbacks", "hostedidioms"]
    renames = {
      "deployment-target" => "deployment"
    }
    
    if self.artworkDynamicDisplayMode == self.artworkDynamicDisplayMode_1080pSDR
      # We need two sets of args, one with 'scale:1 gamut:srgb' and one with 'scale:2 gamut:p3'
      a = self.dup
      a.artworkDynamicDisplayMode = nil
      a.artworkScaleFactor = 1
      a.artworkDisplayGamut = 'sRGB'
      
      b = self.dup
      b.artworkDynamicDisplayMode = nil
      b.artworkScaleFactor = 2
      b.artworkDisplayGamut = 'P3'
      return a.to_assetutil_T_string + ":" + b.to_assetutil_T_string
    else
      return self.to_assetutil_dict.delete_if{|k,v| skip.include?(k) }.to_a.map{|tuple|
        tuple[0] = renames[tuple[0]] || tuple[0]
        tuple.join('=')
      }.join(':')
    end
  end
# All the thinning information we need to pass through to thin an app and its nested bundles.
class ThinningContext
  # Current bundle
  attr :traits # :: ThinningTraits?
  # Top-level app bundle
  attr :mainTraits # :: ThinningTraits?
  # Top-level app bundle variants
  attr :variants # :: [ThinningVariant]
  def initialize(traits, mainTraits, variants)
    @traits = traits
    @mainTraits = mainTraits
    @variants = variants
  end
  def subscope(traits)
    return ThinningContext.new(traits, mainTraits, variants)
  end
class DeviceType
  attr  :target             # e.g. m68ap
  attr  :productType         # e.g. iPhone1,1
  attr  :displayName        # e.g. iPhone 4s
  def initialize (target, productType, displayName)
    @target = target
    @productType = productType
    @displayName = displayName || productType
  end
  def to_s
    return productType
  end
  def <=> (other)
    self.to_s <=> other.to_s
  end
  def to_dict
    return {
      target: target,
      productType: productType,
      displayName: displayName
    }
  end
class ThinningVariant
  attr :device # :: DeviceType
  attr :traits # :: ThinningTraits
  def initialize(device, traits)
    device.assert_kind_of(DeviceType)
    @device = device
    traits.assert_kind_of(ThinningTraits)
    @traits = traits
  end
  def to_s
    return to_dict.to_s
  end
  def to_dict
    return {
      device: device.to_dict,
      traits: traits.to_dict
    }
  end
def bestTraitsForBundle(bundle, traits, device)
  bundle.assert_kind_of(FSBundleDirectoryNode)
  traits.assert_kind_of(ThinningTraits)
  device.assert_kind_of(DeviceType)
  # Given a bundle whose supported device traits might not match what we'd prefer, we construct and return a device
  # traits object that represents as good of a match as possible.  If we cannot find one (e.g. if this is an armv7
  # device and the bundle only has arm64 code), we return nil.
  # Note that we also imbue the returned device traits with the features-to-remove for this device (if any).
  return nil,"the bundle doesn't contain any architectures in common among its executables (#{bundle.machoFiles.map{ |file| file.name }.join(", ")})" if bundle.supportedArchitectures.empty?
  # Check the architecture.
  bestArch = traits.preferredArchitectureAmongCandidates(bundle.supportedArchitectures)
  return nil,"the device doesn't support any of the available architectures (#{bundle.supportedArchitectures.join(", ")})" unless bestArch
  # Check the artwork idiom.
  return nil,"the device doesn't support the app's UIDeviceFamily" unless (traits.supportedIdioms & bundle.supportedIdioms).size > 0
  bestArtworkDisplayGamut = traits.artworkDisplayGamut
  if ["iPad6,3", "iPad6,4"].include?(device.productType)
    if bundle.deploymentTarget && bundle.deploymentTarget < Gem::Version.new("10.0")
      bestArtworkDisplayGamut = "all"
    end
  end
  # If there's no watch content, we can collapse this trait
  supportsEmbeddedUniversalWatchApp = traits.supportsEmbeddedUniversalWatchApp && bundle.nestedBundles.any? { |b| b.isWatchKitStubApp || b.isWatchKitAppExtension }
  # If we get this far, we create a (possibly downshifted)
  return ThinningTraits.new(traits.deploymentTarget, traits.passDeploymentTargetToAssetutil, bestArch, traits.artworkDevIdiom, traits.artworkHostedIdioms, traits.artworkScaleFactor, traits.artworkDevSubtype, bestArtworkDisplayGamut, traits.artworkDynamicDisplayMode, traits.devPerfMemoryClass, traits.gfxFeatureSetClass, traits.gfxFeatureSetFallbacks, traits.featuresToRemove, supportsEmbeddedUniversalWatchApp).freeze, nil
# :: [ThinningTraits: [ThinningVariant]]
def makeThinningTraitsToThinningVariantsMap(bundle, thinDevices, skipThinDevices, ipa)
  # We ask the bundle to figure out the supported platform; we are unable to proceed if we can't determine it.
  platformIdent = bundle.platformIdentifier()
  FatalError(__LINE__, "Cannot determine the supported platform for bundle at #{path.to_s.shellescape}") unless platformIdent
  # Look up the corresponding platform object.
  platform = Platform.platformForIdentifer(platformIdent)
  FatalError(__LINE__, "Cannot find platform with identifier '#{platformIdent}'") unless platform
  # Determine the sets of device traits that actually matter for this bundle.  For example, if a particular
  # device prefers armv7s and another device prefers armv7, but the bundle contains only armv7, then the thinned
  # payload will be the same for both, and can be used for both devices (at least as far as architectures go).
  # Same thing for the other traits.
  # Go through the device types and build a mapping from trait sets to device lists for the devices for which we
  # will create thinned variants.
  result = {}
  result.default = []
  # First we check if the device is even selected by the input options; if it isn't, we skip to the next one.
  candidates = platform.thinningVariants.select { |v|
    ThinningVariantCLISpec.any_matches(thinDevices, v)
  # For example: if we have variants for 9, 10, 11, 12, ... and the app is 10.2, we want to discard 9 (too low for deployment target) and 11 (because we can't vend specific OS variants to pre-iOS 12 devices). This is defined by OS_VARIANTS_PLATFORM_VERSION.
  perProductTypeCandidates = {}
  for c in candidates
    (perProductTypeCandidates[c.device.productType] ||= []) << c
  end
  candidates = []
  bundleTarget = bundle.deploymentTarget
  for prod,cs in perProductTypeCandidates
    topVariantLowerThanApp = cs.select { |c| c.traits.deploymentTarget <= bundleTarget }.max { |a,b| a.traits.deploymentTarget <=> b.traits.deploymentTarget }
    
    cs2 = cs
    if topVariantLowerThanApp
      # Remove variants below topVariantLowerThanApp
      cs2 = cs2.reject { |c| c.traits.deploymentTarget < topVariantLowerThanApp.traits.deploymentTarget }
      
      # Remove variants between topVariantLowerThanApp and osVariantsIntroducedInVersion
      cs2 = cs2.reject { |c| topVariantLowerThanApp.traits.deploymentTarget < c.traits.deploymentTarget && c.traits.deploymentTarget < platform.osVariantsIntroducedInVersion }
    end
    
    candidates += cs2
  end
  # We need to check skipped variants after we've discarded unnecessary versions. Otherwise we might keep unnecessary versions because we've skipped what we would have normally selected.
  candidates = candidates.reject { |v|
    ThinningVariantCLISpec.any_matches(skipThinDevices, v)
  for thinningVariant in candidates
    # Otherwise we know that we want to thin for the device, but we check if we need to modify the device traits
    # based on the bundle payload.  There are two possibilities: either we use a (possibly modified) set of device
    # traits (possibly modified, in case the payload contains something supported but not necessarily preferred by
    # the device traits, e.g. it prefers armv64 but can tolerate armv7), or we get back no device traits at all,
    # in case the device type doesn't support the bundle at all (e.g. an iPhone1,1 cannot run an app that doesn't
    # contain armv6 code).
    bestTraits,problemMessage = bestTraitsForBundle(bundle, thinningVariant.traits, thinningVariant.device)
    # It's possible that we couldn't find any device trait set that the device wants and the bundle supports.
    unless bestTraits
      EmitWarning(__LINE__, "Thinning variant #{thinningVariant.to_s} isn't supported by the bundle at #{bundle.path.to_s.shellescape}: #{problemMessage || "unknown reason"}")
      next
    end
    # If we get this far, we can create a thinned-down version for this type of device.  We add the trait set to
    # the list of ones we want to thin for, if we haven't already seen it, and we add the device to the list of
    # devices for which that trait set is the best fit.
    result[bestTraits] |= [ thinningVariant ]
  end
  $stderr.puts "---"
  def log_result(result, title)
    $stderr.puts "#{title}:"
    $stderr.puts "---"
    for k,vs in result
      $stderr.puts "Traits key:".indent(1)
      $stderr.puts "#{k}".indent(2)
      $stderr.puts ""
      $stderr.puts "Grouped variants:".indent(1)
      for v in vs
        $stderr.puts "#{v}".indent(2)
      end
      $stderr.puts "---"
    end
  end
  log_result(result, "makeThinningTraitsToThinningVariantsMap after bestTraitsForBundle")
  if OPTIONS.useAssetutilEql
    assetCatalogs = ipa.thinnableAssetCatalogs
    $stderr.puts "Thinnable AssetCatalogs:"
    $stderr.puts assetCatalogs.map{|x|x.path.to_s}.join("\n").indent
    $stderr.puts "---"
    $stderr.puts "Testing assetutil equality"
    $stderr.puts "---"
    
    assetTraitGroups = result.keys.sort.group_using { |a,b|
      # .all? is always true when assetCatalogs is empty
      assetCatalogs.all? {|ac|
        $stderr.puts "Testing assetutil equality for #{a} == #{b} using #{ac}"
        $stderr.puts "---"
        ac.eql_for_traits?(a, b, 1)
      }
    }
    $stderr.puts "---"
    $stderr.puts "AssetTraitGroups:"
    $stderr.puts "---"
    for g in assetTraitGroups
      $stderr.puts "---"
      $stderr.puts g.map{|x|x.to_s}.join("\n").indent
      next if g.size == 1
      # When coalescing equivalent traits, we want to keep whichever has the lowest deployment target
      t0 = g.min { |x,y| x.deploymentTarget <=> y.deploymentTarget }
      g.delete(t0)
      tail = g
      
      for t1 in tail
        variants = result[t1]
        result.delete(t1)
        # This operation coalesces assetutil traits and merges values with other matching device traits.
        t2 = t1.take_assetutil_traits(t0)
        result[t2] += variants
      end
    end
    
    $stderr.puts "---"
  end
  log_result(result, "makeThinningTraitsToThinningVariantsMap after AssetCatalog.eql_for_traits?")
  return result
OS_VARIANTS_PLATFORM_VERSION = {
  "iphoneos" => Gem::Version.new(12),
  "watchos" => Gem::Version.new(5),
  "appletvos" => Gem::Version.new(12),
# Represents a platform, including its identifier, its path, its SDK path, etc.  Right now there's just one platform (iPhone OS),
# since Mac OS X isn't supported.  But if we ever support any other platform, we want to be able to do so by merging in additional
# directories into the Platforms directory and have it all work.
class Platform
  attr  :identifier        # canonical identifier, e.g. iphoneos
  attr  :mainPath          # path of .platform folder itself
  attr  :sdkPath           # path of the SDK to use for the platform
  attr  :toolsPath         # path of platform-specific command line tools
  attr  :thinningVariants # :: [ThinningVariant]
  # Global mapping of platform identifiers to Platform objects.
  @@allKnownPlatformsByIdentifier = nil
  # Returns a hash that maps platform identifier to Platform objects for all known platforms.  Currently there's only iPhoneOS.
  def self.allKnownPlatforms ()
    unless @@allKnownPlatformsByIdentifier
      # Create a hash that we'll add entries to.
      @@allKnownPlatformsByIdentifier = {}
      # Look through the Platforms directory and find subdirectories having a ".platform" suffix.
      for platformDir in OPTIONS.platformsDir.children.sort
        # Skip it if it isn't a platform directory.
        next unless platformDir.extname == ".platform"
        # We can't count on .plists in the platform itself, so we look for an SDK directory with the same name as the platform.
        sdksDir = platformDir + "Developer" + "SDKs"
        sdkDir = sdksDir.children.sort.select{ |dir| dir.basename.to_s =~ /#{platformDir.basename(".platform").to_s}[0-9.]+\.sdk/ and not dir.basename.to_s =~ /[Ss]imulator/ }.sort.last rescue nil
        # Ignore platforms without an interesting SDK.
        unless sdkDir
          EmitWarning(__LINE__, "Configuration issue: platform #{platformDir.basename} doesn't have any non-simulator SDKs; ignoring it")
          next
        end
        # Try to load the 'SDKSettings.plist'. If we cannot find it, it isn't a valid SDK.
        sdk_settings_path = sdkDir + "SDKSettings.plist"
        if !File.exist?(sdk_settings_path)
          EmitWarning(__LINE__, "Configuration issue: platform #{platformDir.basename} doesn't have a '#{sdkDir.basename}' SDK with a SDKSettings.plist; ignoring it")
          next
        end
        
        sdkSettingsPlist = LoadPlist(sdk_settings_path)
        # Look for the 'CanonicalName' key.
        canonicalNameValue = sdkSettingsPlist.value.value["CanonicalName"] rescue nil
        unless canonicalNameValue
          EmitWarning(__LINE__, "Configuration issue: platform #{platformDir.basename} doesn't have an SDKSettings.plist with a 'CanonicalName' key at the top level")
          next
        end
        platformIdent = canonicalNameValue.value.gsub(/[0-9.]*$/, "")
        # Ignore uninteresting platforms such as Mac OS X.
        next if platformIdent == "macosx"
        # Instantiate a platform and add it to the mapping.
        platform = Platform.new(platformIdent, platformDir, sdkDir)
        @@allKnownPlatformsByIdentifier[platformIdent] = platform if platform
      end
    end
    return @@allKnownPlatformsByIdentifier
  end
  ## E.g. LC_VERSION_MIN_IPHONEOS -> iphoneos
  def self.platformIdentifierForVersionMinLoadCommand(loadCommandName)
    case loadCommandName.downcase
    when "lc_version_min_tvos"
      return "appletvos"
    when /^lc_version_min_(.*)$/
      return $1
    else
      raise "Unknown platform for load command: #{loadCommandName}"
    end
  end
  def self.platformForIdentifer (ident)
    return self.allKnownPlatforms[ident]
  end
  # :: Gem:Version. Which OS version introduced support for OS Variants?
  def osVariantsIntroducedInVersion()
    result = OS_VARIANTS_PLATFORM_VERSION[identifier]
    raise "Could not find OS Variants version for platform #{identifier}" if result.nil?
    return result
  end
  def initialize (platformIdent, mainPath, sdkPath)
    # Record the basic information.
    @identifier = platformIdent
    @mainPath = mainPath
    @sdkPath = sdkPath
    @toolsPath = mainPath + "usr" + "bin"
    # Determine the path of the device traits database that defines known devices for the platform.
    deviceTraitsDBPath = mainPath + "usr" + "standalone" + "device_traits.db"
    begin
      SQLite3::Database.new(deviceTraitsDBPath.to_s, { readonly: true , results_as_hash: true } ) do |db|
        deviceTraitsByID = {} # :: [Int: Row]
        devicesByTarget = {} # :: [String: DeviceType]
        deviceTraitsIDByTarget = {} # :: [String: Int]
        @thinningVariants = [] # :: [ThinningVariant]
        
        # Load the traits
        db.execute("select * from DeviceTraits") do |row|
          assert(deviceTraitsByID[row['DeviceTraitSetID']].nil?, "#{self.identifier}: conflicting DeviceTraitSetIDs for:\nOld: #{row['DeviceTraitSetID']}\nNew: #{row}")
          deviceTraitsByID[row['DeviceTraitSetID']] = row
        end
        
        # Devices
        db.execute("select * from Devices") do |row|
          target = row['Target']
          productType = row['ProductType']
          displayName = row['ProductDescription']
          devicesByTarget[target] = DeviceType.new(target, productType, displayName).freeze
          deviceTraitsIDByTarget[target] = row['DeviceTraitSet']
        end
        
        # [ThinningVariant]
        db.execute("select * from DeploymentVariant") do |row|
          # rdar://38568729
          deploymentTarget = Gem::Version.new(row['DeploymentTarget'].split('.')[0])
          target = row['DeviceTarget']
          device = devicesByTarget[target]
          
          traitsRow = nil
          passDeploymentTargetToAssetutil = nil
          if deploymentTarget < osVariantsIntroducedInVersion
            traitsRow = deviceTraitsByID[deviceTraitsIDByTarget[target]]
            passDeploymentTargetToAssetutil = false
          else
            traitsRow = deviceTraitsByID[row['DeviceTraitSet']]
            passDeploymentTargetToAssetutil = true
          end
          
          traits = ThinningTraits.new(deploymentTarget,
                                      passDeploymentTargetToAssetutil,
                                      traitsRow['PreferredArchitecture'],
                                      traitsRow['ArtworkDeviceIdiom'],
                                      (traitsRow['ArtworkHostedIdioms'] || "").split(","),
                                      traitsRow['ArtworkScaleFactor'],
                                      traitsRow['ArtworkDeviceSubtype'],
                                      traitsRow['ArtworkDisplayGamut'],
                                      traitsRow['ArtworkDynamicDisplayMode'],
                                      traitsRow['DevicePerformanceMemoryClass'],
                                      traitsRow['GraphicsFeatureSetClass'],
                                      (traitsRow['GraphicsFeatureSetFallbacks'] || "").split(":"),
                                      (traitsRow['FeaturesToRemove'] || "").split(":"),
                                    (traitsRow['ArtworkDeviceIdiom'] == "phone" && deploymentTarget >= Gem::Version.new("12"))
                                    ).freeze
        
        @thinningVariants << ThinningVariant.new(device, traits).freeze
      end
    end
    rescue => exc
      EmitWarning(__LINE__, "Couldn't load device traits database for platform '#{platformIdent}' from #{deviceTraitsDBPath.to_s.shellescape}:\n#{exc.to_log_s}")
      return nil
    end
  def to_s
    return identifier
  end
  def <=> (other)
    self.to_s <=> other.to_s
  end
# Load any platform information we have up-front.  We do this by asking for the mapping.
platforms = Platform.allKnownPlatforms()
FatalError(__LINE__, "couldn't find any platforms at all in #{OPTIONS.platformsDir}") if platforms.empty?
# At this point, the 'inputPath' option always refers to an unpacked IPA.  We process it using the option dictionary we've built it.
ProcessIPA(OPTIONS.inputPath, OPTIONS)
# We're done; we specifically do not flatten the IPA back up, because it still needs to be signed (which is the caller's responsibility).
