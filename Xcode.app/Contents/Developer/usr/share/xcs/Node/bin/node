../deps/openssl/openssl/ssl/bio_ssl.c
../deps/openssl/openssl/ssl/d1_both.c
s->d1->mtu >= dtls1_min_mtu(s)
s->init_num == (int)s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH
len == (unsigned int)ret
invalid state reached %s:%d
dtls1_retransmit_message() failed
s->init_off == 0
s->d1->w_msg_hdr.msg_len + ((s->version==DTLS1_BAD_VER)?3:DTLS1_CCS_HEADER_LENGTH) == (unsigned int)s->init_num
s->d1->w_msg_hdr.msg_len + DTLS1_HM_HEADER_LENGTH == (unsigned int)s->init_num
retransmit:  message %d non-existant
item != NULL
((long)msg_hdr->msg_len) > 0
../deps/openssl/openssl/ssl/d1_clnt.c
client finished
server finished
../deps/openssl/openssl/ssl/d1_lib.c
../deps/openssl/openssl/ssl/d1_pkt.c
SSL alert number 
len <= SSL3_RT_MAX_PLAIN_LENGTH
mac_size <= EVP_MAX_MD_SIZE
../deps/openssl/openssl/ssl/d1_srtp.c
SRTP_AES128_CM_SHA1_80
SRTP_AES128_CM_SHA1_32
../deps/openssl/openssl/ssl/d1_srvr.c
../deps/openssl/openssl/ssl/s23_clnt.c
s->version <= TLS_MAX_VERSION
../deps/openssl/openssl/ssl/s23_lib.c
../deps/openssl/openssl/ssl/s23_srvr.c
GET 
POST 
HEAD 
PUT 
CONNECT
../deps/openssl/openssl/ssl/s3_both.c
i <= EVP_MAX_MD_SIZE
../deps/openssl/openssl/ssl/s3_cbc.c
orig_len >= md_size
md_size <= EVP_MAX_MD_SIZE
data_plus_mac_plus_padding_size < 1024 * 1024
mac_secret_length <= sizeof(hmac_pad)
../deps/openssl/openssl/ssl/s3_clnt.c
../deps/openssl/openssl/ssl/s3_enc.c
NULL-MD5
NULL-SHA
RC4-MD5
RC4-SHA
IDEA-CBC-SHA
DES-CBC3-SHA
DH-DSS-DES-CBC3-SHA
DH-RSA-DES-CBC3-SHA
EDH-DSS-DES-CBC3-SHA
EDH-RSA-DES-CBC3-SHA
ADH-RC4-MD5
ADH-DES-CBC3-SHA
AES128-SHA
DH-DSS-AES128-SHA
DH-RSA-AES128-SHA
DHE-DSS-AES128-SHA
DHE-RSA-AES128-SHA
ADH-AES128-SHA
AES256-SHA
DH-DSS-AES256-SHA
DH-RSA-AES256-SHA
DHE-DSS-AES256-SHA
DHE-RSA-AES256-SHA
ADH-AES256-SHA
NULL-SHA256
AES128-SHA256
AES256-SHA256
DH-DSS-AES128-SHA256
DH-RSA-AES128-SHA256
DHE-DSS-AES128-SHA256
CAMELLIA128-SHA
DH-DSS-CAMELLIA128-SHA
DH-RSA-CAMELLIA128-SHA
DHE-DSS-CAMELLIA128-SHA
DHE-RSA-CAMELLIA128-SHA
ADH-CAMELLIA128-SHA
DHE-RSA-AES128-SHA256
DH-DSS-AES256-SHA256
DH-RSA-AES256-SHA256
DHE-DSS-AES256-SHA256
DHE-RSA-AES256-SHA256
ADH-AES128-SHA256
ADH-AES256-SHA256
GOST94-GOST89-GOST89
GOST2001-GOST89-GOST89
GOST94-NULL-GOST94
GOST2001-NULL-GOST94
CAMELLIA256-SHA
DH-DSS-CAMELLIA256-SHA
DH-RSA-CAMELLIA256-SHA
DHE-DSS-CAMELLIA256-SHA
DHE-RSA-CAMELLIA256-SHA
ADH-CAMELLIA256-SHA
PSK-RC4-SHA
PSK-3DES-EDE-CBC-SHA
PSK-AES128-CBC-SHA
PSK-AES256-CBC-SHA
SEED-SHA
DH-DSS-SEED-SHA
DH-RSA-SEED-SHA
DHE-DSS-SEED-SHA
DHE-RSA-SEED-SHA
ADH-SEED-SHA
AES128-GCM-SHA256
AES256-GCM-SHA384
DHE-RSA-AES128-GCM-SHA256
DHE-RSA-AES256-GCM-SHA384
DH-RSA-AES128-GCM-SHA256
DH-RSA-AES256-GCM-SHA384
DHE-DSS-AES128-GCM-SHA256
DHE-DSS-AES256-GCM-SHA384
DH-DSS-AES128-GCM-SHA256
DH-DSS-AES256-GCM-SHA384
ADH-AES128-GCM-SHA256
ADH-AES256-GCM-SHA384
ECDH-ECDSA-NULL-SHA
ECDH-ECDSA-RC4-SHA
ECDH-ECDSA-DES-CBC3-SHA
ECDH-ECDSA-AES128-SHA
ECDH-ECDSA-AES256-SHA
ECDHE-ECDSA-NULL-SHA
ECDHE-ECDSA-RC4-SHA
ECDHE-ECDSA-DES-CBC3-SHA
ECDHE-ECDSA-AES128-SHA
ECDHE-ECDSA-AES256-SHA
ECDH-RSA-NULL-SHA
ECDH-RSA-RC4-SHA
ECDH-RSA-DES-CBC3-SHA
ECDH-RSA-AES128-SHA
ECDH-RSA-AES256-SHA
ECDHE-RSA-NULL-SHA
ECDHE-RSA-RC4-SHA
ECDHE-RSA-DES-CBC3-SHA
ECDHE-RSA-AES128-SHA
ECDHE-RSA-AES256-SHA
AECDH-NULL-SHA
AECDH-RC4-SHA
AECDH-DES-CBC3-SHA
AECDH-AES128-SHA
AECDH-AES256-SHA
SRP-3DES-EDE-CBC-SHA
SRP-RSA-3DES-EDE-CBC-SHA
SRP-DSS-3DES-EDE-CBC-SHA
SRP-AES-128-CBC-SHA
SRP-RSA-AES-128-CBC-SHA
SRP-DSS-AES-128-CBC-SHA
SRP-AES-256-CBC-SHA
SRP-RSA-AES-256-CBC-SHA
SRP-DSS-AES-256-CBC-SHA
ECDHE-ECDSA-AES128-SHA256
ECDHE-ECDSA-AES256-SHA384
ECDH-ECDSA-AES128-SHA256
ECDH-ECDSA-AES256-SHA384
ECDHE-RSA-AES128-SHA256
ECDHE-RSA-AES256-SHA384
ECDH-RSA-AES128-SHA256
ECDH-RSA-AES256-SHA384
ECDHE-ECDSA-AES128-GCM-SHA256
ECDHE-ECDSA-AES256-GCM-SHA384
ECDH-ECDSA-AES128-GCM-SHA256
ECDH-ECDSA-AES256-GCM-SHA384
ECDHE-RSA-AES128-GCM-SHA256
ECDHE-RSA-AES256-GCM-SHA384
ECDH-RSA-AES128-GCM-SHA256
ECDH-RSA-AES256-GCM-SHA384
CLNT
SRVR
../deps/openssl/openssl/ssl/s3_lib.c
../deps/openssl/openssl/ssl/s3_pkt.c
s->s3->wnum <= INT_MAX
../deps/openssl/openssl/ssl/s3_srvr.c
GOST signature length is %d
ssl2-md5
ssl3-md5
ssl3-sha1
SHA1
RSA-SHA1-2
RSA-SHA1
DSA-SHA1-old
DSA-SHA1
DSS1
dss1
../deps/openssl/openssl/ssl/ssl_asn1.c
../deps/openssl/openssl/ssl/ssl_cert.c
SSL for verify callback
ssl_client
ssl_server
%s/%s
OPENSSL_DIR_read(&ctx, '
Verify error:
DES-CBC
DES-EDE3-CBC
RC2-CBC
IDEA-CBC
AES-128-CBC
AES-256-CBC
CAMELLIA-128-CBC
CAMELLIA-256-CBC
gost89-cnt
SEED-CBC
id-aes128-GCM
id-aes256-GCM
../deps/openssl/openssl/ssl/ssl_ciph.c
ssl_mac_secret_size[SSL_MD_MD5_IDX] >= 0
ssl_mac_secret_size[SSL_MD_SHA1_IDX] >= 0
md_gost94
ssl_mac_secret_size[SSL_MD_GOST94_IDX] >= 0
gost-mac
SHA256
SHA384
RC4-HMAC-MD5
AES-128-CBC-HMAC-SHA1
AES-256-CBC-HMAC-SHA1
AES-128-CBC-HMAC-SHA256
AES-256-CBC-HMAC-SHA256
DEFAULT
ALL:!EXPORT:!LOW:!aNULL:!eNULL:!SSLv2
%-23s %s Kx=%-8s Au=%-4s Enc=%-9s Mac=%-4s%s
 export
SSLv2
SSLv3
TLSv1.2
unknown
RSA(512)
RSA(1024)
DH/RSA
DH/DSS
KRB5
DH(512)
DH(1024)
ECDH/RSA
ECDH/ECDSA
GOST
None
ECDSA
GOST94
GOST01
DES(40)
DES(56)
3DES(168)
RC4(40)
RC4(56)
RC4(64)
RC4(128)
RC2(40)
RC2(56)
RC2(128)
IDEA(128)
AES(128)
AES(256)
AESGCM(128)
AESGCM(256)
Camellia(128)
Camellia(256)
SEED(128)
GOST89(256)
AEAD
GOST89
OPENSSL_malloc Error
Buffer too small
(NONE)
TLSv1/SSLv3
SUITEB128ONLY
SUITEB128C2
SUITEB128
SUITEB192
ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384
gost94
gost2001
COMPLEMENTOFALL
COMPLEMENTOFDEFAULT
kRSA
kDHr
kDHd
kEDH
kDHE
kKRB5
kECDHr
kECDHe
kECDH
kEECDH
kECDHE
kPSK
kSRP
kGOST
aRSA
aDSS
aKRB5
aNULL
aECDH
aECDSA
aPSK
aGOST94
aGOST01
aGOST
aSRP
EECDH
ECDHE
NULL
AECDH
3DES
IDEA
SEED
eNULL
AES128
AES256
AESGCM
CAMELLIA128
CAMELLIA256
CAMELLIA
GOST89MAC
TLSv1
EXPORT
EXPORT40
EXPORT56
MEDIUM
HIGH
FIPS
EXP-DHE-DSS-DES-CBC-SHA
DHE-DSS-DES-CBC-SHA
DHE-DSS-DES-CBC3-SHA
EXP-DHE-RSA-DES-CBC-SHA
DHE-RSA-DES-CBC-SHA
DHE-RSA-DES-CBC3-SHA
STRENGTH
../deps/openssl/openssl/ssl/ssl_conf.c
cmd=
, value=
SignatureAlgorithms
sigalgs
ClientSignatureAlgorithms
client_sigalgs
Curves
curves
ECDHParameters
named_curve
CipherString
cipher
Protocol
Options
cert
PrivateKey
ServerInfoFile
DHParameters
dhparam
automatic
auto
TLSv1.1
SessionTicket
EmptyFragments
Bugs
Compression
ServerPreference
NoResumptionOnRenegotiation
DHSingle
ECDHSingle
UnsafeLegacyRenegotiation
no_ssl2
no_ssl3
no_tls1
no_tls1_1
no_tls1_2
bugs
no_comp
ecdh_single
no_ticket
serverpref
legacy_renegotiation
legacy_server_connect
no_resumption_on_reneg
no_legacy_server_connect
strict
CHECK_SUITEB_CIPHER_LIST
CLIENT_CERTIFICATE
CLIENT_FINISHED
CLIENT_HELLO
CLIENT_MASTER_KEY
d2i_SSL_SESSION
do_dtls1_write
DO_SSL3_WRITE
dtls1_accept
DTLS1_ADD_CERT_TO_BUF
DTLS1_BUFFER_RECORD
dtls1_check_timeout_num
dtls1_client_hello
dtls1_connect
DTLS1_GET_HELLO_VERIFY
dtls1_get_message
DTLS1_GET_MESSAGE_FRAGMENT
dtls1_get_record
dtls1_handle_timeout
dtls1_heartbeat
dtls1_output_cert_chain
DTLS1_PREPROCESS_FRAGMENT
DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE
DTLS1_PROCESS_RECORD
dtls1_read_bytes
dtls1_read_failed
dtls1_send_certificate_request
dtls1_send_client_certificate
dtls1_send_client_key_exchange
dtls1_send_client_verify
DTLS1_SEND_HELLO_VERIFY_REQUEST
dtls1_send_server_certificate
dtls1_send_server_hello
dtls1_send_server_key_exchange
dtls1_write_app_data_bytes
GET_CLIENT_FINISHED
GET_CLIENT_HELLO
GET_CLIENT_MASTER_KEY
GET_SERVER_FINISHED
GET_SERVER_HELLO
GET_SERVER_STATIC_DH_KEY
GET_SERVER_VERIFY
i2d_SSL_SESSION
READ_N
REQUEST_CERTIFICATE
SERVER_FINISH
SERVER_HELLO
SERVER_VERIFY
ssl23_accept
SSL23_CLIENT_HELLO
ssl23_connect
SSL23_GET_CLIENT_HELLO
SSL23_GET_SERVER_HELLO
ssl23_peek
ssl23_read
ssl23_write
ssl2_accept
ssl2_connect
ssl2_enc_init
ssl2_generate_key_material
ssl2_peek
ssl2_read
SSL2_READ_INTERNAL
ssl2_set_certificate
ssl2_write
ssl3_accept
SSL3_ADD_CERT_TO_BUF
ssl3_callback_ctrl
ssl3_change_cipher_state
ssl3_check_cert_and_algorithm
ssl3_check_client_hello
SSL3_CHECK_FINISHED
ssl3_client_hello
ssl3_connect
ssl3_ctrl
ssl3_ctx_ctrl
ssl3_digest_cached_records
ssl3_do_change_cipher_spec
ssl3_enc
SSL3_GENERATE_KEY_BLOCK
ssl3_generate_master_secret
ssl3_get_certificate_request
ssl3_get_cert_status
ssl3_get_cert_verify
ssl3_get_client_certificate
ssl3_get_client_hello
ssl3_get_client_key_exchange
ssl3_get_finished
ssl3_get_key_exchange
ssl3_get_message
ssl3_get_new_session_ticket
ssl3_get_next_proto
SSL3_GET_RECORD
ssl3_get_server_certificate
ssl3_get_server_done
ssl3_get_server_hello
ssl3_handshake_mac
SSL3_NEW_SESSION_TICKET
ssl3_output_cert_chain
ssl3_peek
ssl3_read_bytes
ssl3_read_n
ssl3_send_certificate_request
ssl3_send_client_certificate
ssl3_send_client_key_exchange
ssl3_send_client_verify
ssl3_send_server_certificate
ssl3_send_server_hello
ssl3_send_server_key_exchange
ssl3_setup_key_block
ssl3_setup_read_buffer
ssl3_setup_write_buffer
ssl3_write_bytes
ssl3_write_pending
ssl_add_cert_chain
SSL_ADD_CERT_TO_BUF
ssl_add_clienthello_renegotiate_ext
ssl_add_clienthello_tlsext
ssl_add_clienthello_use_srtp_ext
SSL_add_dir_cert_subjects_to_stack
SSL_add_file_cert_subjects_to_stack
ssl_add_serverhello_renegotiate_ext
ssl_add_serverhello_tlsext
ssl_add_serverhello_use_srtp_ext
ssl_bad_method
ssl_build_cert_chain
ssl_bytes_to_cipher_list
ssl_cert_dup
ssl_cert_inst
SSL_CERT_INSTANTIATE
ssl_cert_new
SSL_check_private_key
SSL_CHECK_SERVERHELLO_TLSEXT
ssl_check_srvr_ecc_cert_and_alg
SSL_CIPHER_PROCESS_RULESTR
SSL_CIPHER_STRENGTH_SORT
SSL_clear
SSL_COMP_add_compression_method
SSL_CONF_cmd
ssl_create_cipher_list
SSL_ctrl
SSL_CTX_check_private_key
SSL_CTX_MAKE_PROFILES
SSL_CTX_new
SSL_CTX_set_cipher_list
SSL_CTX_set_client_cert_engine
SSL_CTX_set_purpose
SSL_CTX_set_session_id_context
SSL_CTX_set_ssl_version
SSL_CTX_set_trust
SSL_CTX_use_certificate
SSL_CTX_use_certificate_ASN1
SSL_CTX_use_certificate_chain_file
SSL_CTX_use_certificate_file
SSL_CTX_use_PrivateKey_ASN1
SSL_CTX_use_PrivateKey_file
SSL_CTX_use_psk_identity_hint
SSL_CTX_use_RSAPrivateKey
SSL_CTX_use_RSAPrivateKey_ASN1
SSL_CTX_use_RSAPrivateKey_file
SSL_CTX_use_serverinfo
SSL_CTX_use_serverinfo_file
SSL_do_handshake
ssl_get_new_session
ssl_get_prev_session
SSL_GET_SERVER_CERT_INDEX
SSL_GET_SERVER_SEND_CERT
ssl_get_server_send_pkey
ssl_get_sign_pkey
ssl_init_wbio_buffer
SSL_load_client_CA_file
SSL_new
ssl_parse_clienthello_renegotiate_ext
ssl_parse_clienthello_tlsext
ssl_parse_clienthello_use_srtp_ext
ssl_parse_serverhello_renegotiate_ext
ssl_parse_serverhello_tlsext
ssl_parse_serverhello_use_srtp_ext
SSL_peek
ssl_prepare_clienthello_tlsext
ssl_prepare_serverhello_tlsext
SSL_read
SSL_RSA_PRIVATE_DECRYPT
SSL_RSA_PUBLIC_ENCRYPT
SSL_SCAN_CLIENTHELLO_TLSEXT
SSL_SCAN_SERVERHELLO_TLSEXT
ssl_session_dup
SSL_SESSION_new
SSL_SESSION_print_fp
SSL_SESSION_set1_id_context
ssl_sess_cert_new
SSL_SET_CERT
SSL_set_cipher_list
SSL_set_fd
SSL_SET_PKEY
SSL_set_purpose
SSL_set_rfd
SSL_set_session
SSL_set_session_id_context
SSL_set_session_ticket_ext
SSL_set_trust
SSL_set_wfd
SSL_shutdown
SSL_SRP_CTX_init
ssl_undefined_const_function
ssl_undefined_function
ssl_undefined_void_function
SSL_use_certificate
SSL_use_certificate_ASN1
SSL_use_certificate_file
SSL_use_PrivateKey
SSL_use_PrivateKey_ASN1
SSL_use_PrivateKey_file
SSL_use_psk_identity_hint
SSL_use_RSAPrivateKey
SSL_use_RSAPrivateKey_ASN1
SSL_use_RSAPrivateKey_file
ssl_verify_cert_chain
SSL_write
tls12_check_peer_sigalg
tls1_cert_verify_mac
tls1_change_cipher_state
TLS1_CHECK_SERVERHELLO_TLSEXT
tls1_enc
tls1_export_keying_material
TLS1_GET_CURVELIST
tls1_heartbeat
TLS1_PREPARE_CLIENTHELLO_TLSEXT
TLS1_PREPARE_SERVERHELLO_TLSEXT
tls1_prf
tls1_setup_key_block
tls1_set_server_sigalgs
WRITE_PENDING
app data in handshake
attempt to reuse session in different context
bad alert record
bad authentication type
bad change cipher spec
bad checksum
bad data
bad data returned by callback
bad decompression
bad dh g length
bad dh g value
bad dh pub key length
bad dh pub key value
bad dh p length
bad dh p value
bad digest length
bad dsa signature
bad ecc cert
bad ecdsa signature
bad ecpoint
bad handshake length
bad hello request
bad length
bad mac decode
bad mac length
bad message type
bad packet length
bad protocol version number
bad psk identity hint length
bad response argument
bad rsa decrypt
bad rsa encrypt
bad rsa e length
bad rsa modulus length
bad rsa signature
bad signature
bad srp a length
bad srp b length
bad srp g length
bad srp n length
bad srp parameters
bad srp s length
bad srtp mki value
bad srtp protection profile list
bad ssl filetype
bad ssl session id length
bad state
bad value
bad write retry
bio not set
block cipher pad is wrong
bn lib
ca dn length mismatch
ca dn too long
ccs received early
certificate verify failed
cert cb error
cert length mismatch
challenge is different
cipher code wrong length
cipher or hash unavailable
cipher table src error
clienthello tlsext
compressed length too long
compression disabled
compression failure
compression id not within private range
compression library error
connection id is different
connection type not set
cookie mismatch
data between ccs and finished
data length too long
decryption failed
decryption failed or bad record mac
dh key too small
dh public value length is wrong
digest check failed
dtls message too big
duplicate compression id
ecc cert not for key agreement
ecc cert not for signing
ecc cert should have rsa signature
ecc cert should have sha1 signature
ecdh required for suiteb mode
ecgroup too large for cipher
empty srtp protection profile list
encrypted length too long
error generating tmp rsa key
error in received cipher list
excessive message size
extra data in message
got a fin before a ccs
got next proto before a ccs
got next proto without seeing extension
https proxy request
http request
illegal padding
illegal Suite B digest
inappropriate fallback
inconsistent compression
invalid challenge length
invalid command
invalid compression algorithm
invalid null cmd name
invalid purpose
invalid serverinfo data
invalid srp username
invalid status response
invalid ticket keys length
invalid trust
key arg too long
krb5
krb5 client cc principal (no tkt?)
krb5 client get cred
krb5 client init
krb5 client mk_req (expired tkt?)
krb5 server bad ticket
krb5 server init
krb5 server rd_req (keytab perms?)
krb5 server tkt expired
krb5 server tkt not yet valid
krb5 server tkt skew
length mismatch
length too short
library bug
library has no ciphers
message too long
missing dh dsa cert
missing dh key
missing dh rsa cert
missing dsa signing cert
missing ecdh cert
missing ecdsa signing cert
missing export tmp dh key
missing export tmp rsa key
missing rsa certificate
missing rsa encrypting cert
missing rsa signing cert
can't find SRP server param
missing tmp dh key
missing tmp ecdh key
missing tmp rsa key
missing tmp rsa pkey
missing verify message
multiple sgc restarts
non sslv2 initial packet
no certificates returned
no certificate assigned
no certificate returned
no certificate set
no certificate specified
no ciphers available
no ciphers passed
no ciphers specified
no cipher list
no cipher match
no client cert method
no client cert received
no compression specified
Peer haven't sent GOST certificate, required for selected ciphersuite
no method specified
no pem extensions
no privatekey
no private key assigned
no protocols available
no publickey
no renegotiation
digest requred for handshake isn't computed
no shared cipher
no shared sigature algorithms
no srtp profiles
no verify callback
null ssl ctx
null ssl method passed
old session cipher not returned
old session compression algorithm not returned
only DTLS 1.2 allowed in Suite B mode
only TLS 1.2 allowed in Suite B mode
only tls allowed in fips mode
opaque PRF input too long
packet length too long
parse tlsext
path too long
peer did not return a certificate
peer error
peer error certificate
peer error no certificate
peer error no cipher
peer error unsupported certificate type
pem name bad prefix
pem name too short
pre mac length too long
problems mapping cipher functions
protocol is shutdown
psk identity not found
psk no client cb
psk no server cb
public key encrypt error
public key is not rsa
public key not rsa
read bio not set
read timeout expired
read wrong packet type
record length mismatch
record too large
record too small
renegotiate ext too long
renegotiation encoding err
renegotiation mismatch
required cipher missing
required compresssion algorithm missing
reuse cert length not zero
reuse cert type not zero
reuse cipher list not zero
scsv received when renegotiating
serverhello tlsext
session id context uninitialized
short read
shutdown while in init
signature algorithms error
signature for non signing certificate
error with the srp params
srtp could not allocate profiles
srtp protection profile list too long
srtp unknown protection profile
ssl23 doing session id reuse
ssl2 connection id too long
ssl3 ext invalid ecpointformat
ssl3 ext invalid servername
ssl3 ext invalid servername type
ssl3 session id too long
ssl3 session id too short
sslv3 alert bad certificate
sslv3 alert bad record mac
sslv3 alert certificate expired
sslv3 alert certificate revoked
sslv3 alert certificate unknown
sslv3 alert decompression failure
sslv3 alert handshake failure
sslv3 alert illegal parameter
sslv3 alert no certificate
sslv3 alert unexpected message
sslv3 alert unsupported certificate
ssl ctx has no default ssl version
ssl handshake failure
ssl library has no ciphers
ssl session id callback failed
ssl session id conflict
ssl session id context too long
ssl session id has bad length
ssl session id is different
tlsv1 alert access denied
tlsv1 alert decode error
tlsv1 alert decryption failed
tlsv1 alert decrypt error
tlsv1 alert export restriction
tlsv1 alert inappropriate fallback
tlsv1 alert insufficient security
tlsv1 alert internal error
tlsv1 alert no renegotiation
tlsv1 alert protocol version
tlsv1 alert record overflow
tlsv1 alert unknown ca
tlsv1 alert user cancelled
tlsv1 bad certificate hash value
tlsv1 bad certificate status response
tlsv1 certificate unobtainable
tlsv1 unrecognized name
tlsv1 unsupported extension
tls client cert req with anon cipher
peer does not accept heartbeats
heartbeat request already pending
tls illegal exporter label
tls invalid ecpointformat list
tls peer did not respond with certificate list
tls rsa encrypted value length is wrong
tried to use unsupported cipher
unable to decode dh certs
unable to decode ecdh certs
unable to extract public key
unable to find dh parameters
unable to find ecdh parameters
unable to find public key parameters
unable to find ssl method
unable to load ssl2 md5 routines
unable to load ssl3 md5 routines
unable to load ssl3 sha1 routines
unexpected message
unexpected record
uninitialized
unknown alert type
unknown certificate type
unknown cipher returned
unknown cipher type
unknown cmd name
unknown digest
unknown key exchange type
unknown pkey type
unknown protocol
unknown remote error type
unknown ssl version
unknown state
unsafe legacy renegotiation disabled
unsupported cipher
unsupported compression algorithm
unsupported digest type
unsupported elliptic curve
unsupported protocol
unsupported ssl version
unsupported status type
use srtp not negotiated
write bio not set
wrong certificate type
wrong cipher returned
wrong curve
wrong message type
wrong number of key bits
wrong signature length
wrong signature size
wrong signature type
wrong ssl version
wrong version number
x509 lib
x509 verification setup problems
OpenSSL 1.0.2h  3 May 2016
../deps/openssl/openssl/ssl/ssl_lib.c
s->sid_ctx_length <= sizeof s->sid_ctx
DTLSv0.9
DTLSv1
DTLSv1.2
ssl->sid_ctx_length <= sizeof(ssl->sid_ctx)
../deps/openssl/openssl/ssl/ssl_rsa.c
SERVERINFO FOR 
../deps/openssl/openssl/ssl/ssl_sess.c
SSL SESSION PARAMETERS
before SSL initialization
before accept initialization
before connect initialization
SSL negotiation finished successfully
SSL renegotiate ciphers
before/connect initialization
ok/connect SSL initialization
before/accept initialization
ok/accept SSL initialization
SSLv2/v3 write client hello A
SSLv2/v3 write client hello B
SSLv2/v3 read server hello A
SSLv2/v3 read server hello B
SSLv2/v3 read client hello A
SSLv2/v3 read client hello B
DTLS1 read hello verify request A
DTLS1 read hello verify request B
DTLS1 write hello verify request A
DTLS1 write hello verify request B
read header
read body
read done
PINIT 
AINIT 
CINIT 
SSLOK 
SSLERR
23WCHA
23WCHB
23RSHA
23RCHA
23RCHB
DRCHVA
DRCHVB
DWCHVA
DWCHVB
UNKWN 
warning
fatal
close notify
unexpected_message
bad record mac
decompression failure
handshake failure
no certificate
bad certificate
unsupported certificate
certificate revoked
certificate expired
certificate unknown
illegal parameter
record overflow
unknown CA
access denied
decode error
decrypt error
export restriction
protocol version
insufficient security
internal error
user canceled
unsupported extension
certificate unobtainable
unrecognized name
bad certificate status response
bad certificate hash value
unknown PSK identity
../deps/openssl/openssl/ssl/ssl_txt.c
SSL-Session:
DTLSv1-bad
    Protocol  : %s
    Cipher    : %06lX
    Cipher    : %04lX
    Cipher    : %s
    Session-ID: 
%02X
    Session-ID-ctx: 
    Master-Key: 
    Key-Arg   : 
    PSK identity: 
    PSK identity hint: 
    SRP username: 
    TLS session ticket lifetime hint: %ld (seconds)
    TLS session ticket:
    Compression: %d
    Compression: %d (%s)
    Start Time: %ld
    Timeout   : %ld (sec)
    Verify return code: 
%ld (%s)
../deps/openssl/openssl/ssl/t1_enc.c
client write key
server write key
IV block
n >= 0
%s:%d: rec->data != rec->input
t >= 0
master secret
key expansion
chunk >= 0
../deps/openssl/openssl/ssl/t1_ext.c
!(meth->ext_flags & SSL_EXT_FLAG_SENT)
../deps/openssl/openssl/ssl/t1_lib.c
../deps/openssl/openssl/ssl/t1_reneg.c
!expected_len || s->s3->previous_client_finished_len
!expected_len || s->s3->previous_server_finished_len
../deps/openssl/openssl/ssl/tls_srp.c
../deps/openssl/openssl/crypto/aes/aes_ige.c
in && out && key && ivec
(AES_ENCRYPT == enc) || (AES_DECRYPT == enc)
(length % AES_BLOCK_SIZE) == 0
aes(partial)
../deps/openssl/openssl/crypto/asn1/a_bitstr.c
../deps/openssl/openssl/crypto/asn1/a_bool.c
../deps/openssl/openssl/crypto/asn1/a_bytes.c
../deps/openssl/openssl/crypto/asn1/a_d2i_fp.c
../deps/openssl/openssl/crypto/asn1/a_digest.c
../deps/openssl/openssl/crypto/asn1/a_dup.c
../deps/openssl/openssl/crypto/asn1/a_enum.c
../deps/openssl/openssl/crypto/asn1/a_gentm.c
%04d%02d%02d%02d%02d%02dZ
../deps/openssl/openssl/crypto/asn1/a_i2d_fp.c
../deps/openssl/openssl/crypto/asn1/a_int.c
../deps/openssl/openssl/crypto/asn1/a_mbstr.c
minsize=
maxsize=
../deps/openssl/openssl/crypto/asn1/a_object.c
<INVALID>
../deps/openssl/openssl/crypto/asn1/a_set.c
../deps/openssl/openssl/crypto/asn1/a_sign.c
../deps/openssl/openssl/crypto/asn1/a_strex.c
0123456789ABCDEF
\W%08lX
\U%04lX
\%02X
MASK:
nombstr
pkix
utf8only
default
../deps/openssl/openssl/crypto/asn1/a_strnid.c
ASN1_TIME
../deps/openssl/openssl/crypto/asn1/a_time.c
../deps/openssl/openssl/crypto/asn1/a_utctm.c
%02d%02d%02d%02d%02d%02dZ
../deps/openssl/openssl/crypto/asn1/a_verify.c
../deps/openssl/openssl/crypto/asn1/ameth_lib.c
a2d_ASN1_OBJECT
a2i_ASN1_ENUMERATED
a2i_ASN1_INTEGER
a2i_ASN1_STRING
APPEND_EXP
ASN1_BIT_STRING_set_bit
ASN1_CB
ASN1_CHECK_TLEN
ASN1_COLLATE_PRIMITIVE
ASN1_COLLECT
ASN1_D2I_EX_PRIMITIVE
ASN1_d2i_fp
ASN1_D2I_READ_BIO
ASN1_digest
ASN1_DO_ADB
ASN1_dup
ASN1_ENUMERATED_set
ASN1_ENUMERATED_to_BN
ASN1_EX_C2I
ASN1_FIND_END
ASN1_GENERALIZEDTIME_adj
ASN1_GENERALIZEDTIME_set
ASN1_generate_v3
ASN1_get_object
ASN1_HEADER_NEW
ASN1_i2d_bio
ASN1_i2d_fp
ASN1_INTEGER_set
ASN1_INTEGER_to_BN
ASN1_item_d2i_fp
ASN1_item_dup
ASN1_ITEM_EX_COMBINE_NEW
ASN1_ITEM_EX_D2I
ASN1_item_i2d_bio
ASN1_item_i2d_fp
ASN1_item_pack
ASN1_item_sign
ASN1_item_sign_ctx
ASN1_item_unpack
ASN1_item_verify
ASN1_mbstring_ncopy
ASN1_OBJECT_new
ASN1_OUTPUT_DATA
ASN1_pack_string
ASN1_PCTX_new
ASN1_PKCS5_PBE_SET
ASN1_seq_pack
ASN1_seq_unpack
ASN1_sign
ASN1_STR2TYPE
ASN1_STRING_set
ASN1_STRING_TABLE_add
ASN1_STRING_type_new
ASN1_TEMPLATE_EX_D2I
ASN1_TEMPLATE_NEW
ASN1_TEMPLATE_NOEXP_D2I
ASN1_TIME_adj
ASN1_TIME_set
ASN1_TYPE_get_int_octetstring
ASN1_TYPE_get_octetstring
ASN1_unpack_string
ASN1_UTCTIME_adj
ASN1_UTCTIME_set
ASN1_verify
B64_READ_ASN1
B64_WRITE_ASN1
BIO_new_NDEF
BITSTR_CB
BN_to_ASN1_ENUMERATED
BN_to_ASN1_INTEGER
c2i_ASN1_BIT_STRING
c2i_ASN1_INTEGER
c2i_ASN1_OBJECT
COLLECT_DATA
D2I_ASN1_BIT_STRING
d2i_ASN1_BOOLEAN
d2i_ASN1_bytes
D2I_ASN1_GENERALIZEDTIME
D2I_ASN1_HEADER
D2I_ASN1_INTEGER
d2i_ASN1_OBJECT
d2i_ASN1_SET
d2i_ASN1_type_bytes
d2i_ASN1_UINTEGER
D2I_ASN1_UTCTIME
d2i_AutoPrivateKey
d2i_Netscape_RSA
D2I_NETSCAPE_RSA_2
d2i_PrivateKey
d2i_PublicKey
d2i_RSA_NET
D2I_RSA_NET_2
D2I_X509
D2I_X509_CINF
d2i_X509_PKEY
i2d_ASN1_bio_stream
i2d_ASN1_SET
I2D_ASN1_TIME
i2d_DSA_PUBKEY
i2d_EC_PUBKEY
i2d_PrivateKey
i2d_PublicKey
i2d_RSA_NET
i2d_RSA_PUBKEY
LONG_C2I
OID_MODULE_INIT
PARSE_TAGGING
PKCS5_pbe2_set_iv
PKCS5_pbe_set
PKCS5_pbe_set0_algor
PKCS5_pbkdf2_set
SMIME_read_ASN1
SMIME_text
X509_CINF_NEW
X509_CRL_add0_revoked
X509_INFO_new
X509_NAME_ENCODE
X509_NAME_EX_D2I
X509_NAME_EX_NEW
X509_NEW
X509_PKEY_new
adding object
asn1 parse error
asn1 sig parse error
aux error
bad class
bad object header
bad password read
bad tag
bmpstring is wrong length
boolean is wrong length
buffer too small
cipher has no object identifier
context not initialised
data is wrong
decoding error
depth exceeded
digest and key type not supported
encode error
error getting time
error loading section
error parsing set element
error setting cipher params
expecting an integer
expecting an object
expecting a boolean
expecting a time
explicit length mismatch
explicit tag not constructed
field missing
first num too large
header too long
illegal bitstring format
illegal boolean
illegal characters
illegal format
illegal hex
illegal implicit tag
illegal integer
illegal nested tagging
illegal null
illegal null value
illegal object
illegal optional any
illegal options on item template
illegal tagged any
illegal time value
integer not ascii format
integer too large for long
invalid bit string bits left
invalid bmpstring length
invalid digit
invalid mime type
invalid modifier
invalid number
invalid object encoding
invalid separator
invalid time format
invalid universalstring length
invalid utf8string
iv too large
length error
list error
mime no content type
mime parse error
mime sig parse error
missing eoc
missing second number
missing value
mstring not universal
mstring wrong tag
nested asn1 string
non hex characters
not ascii format
not enough data
no content type
no default digest
no matching choice type
no multipart body failure
no multipart boundary
no sig content type
null is wrong length
object not ascii format
odd number of chars
private key header missing
second number too large
sequence length mismatch
sequence not constructed
sequence or set needs config
short line
sig invalid mime type
streaming not supported
string too long
string too short
tag value too high
the asn1 object identifier is not known for this md
time not ascii format
too long
type not constructed
type not primitive
unable to decode rsa key
unable to decode rsa private key
unexpected eoc
universalstring is wrong length
unknown format
unknown message digest algorithm
unknown object type
unknown public key type
unknown signature algorithm
unknown tag
unsupported any defined by type
unsupported encryption algorithm
unsupported public key type
unsupported type
wrong public key type
wrong tag
wrong type
../deps/openssl/openssl/crypto/asn1/asn1_gen.c
tag=
ASCII
UTF8
BITLIST
BOOL
BOOLEAN
INTEGER
ENUM
ENUMERATED
OBJECT
UTCTIME
GENERALIZEDTIME
GENTIME
OCTETSTRING
BITSTR
BITSTRING
UNIVERSALSTRING
UNIV
IA5STRING
UTF8String
BMPSTRING
VISIBLESTRING
VISIBLE
PRINTABLESTRING
PRINTABLE
T61STRING
TELETEXSTRING
GeneralString
GENSTR
NUMERIC
NUMERICSTRING
SEQUENCE
EXPLICIT
IMPLICIT
OCTWRAP
SEQWRAP
SETWRAP
BITWRAP
FORM
FORMAT
Char=
string=
../deps/openssl/openssl/crypto/asn1/asn1_lib.c
address=
 offset=
BIT STRING
OCTET STRING
OBJECT DESCRIPTOR
EXTERNAL
REAL
<ASN1 11>
UTF8STRING
<ASN1 13>
<ASN1 14>
<ASN1 15>
VIDEOTEXSTRING
GRAPHICSTRING
GENERALSTRING
<ASN1 29>
(unknown)
BAD RECURSION DEPTH
Error in encoding
%5ld:
d=%-2d hl=%ld l=%4ld 
d=%-2d hl=%ld l=inf  
length is greater than %ld
:BAD OBJECT
Bad boolean
[HEX DUMP]:
BAD INTEGER
BAD ENUMERATED
cons: 
prim: 
priv [ %d ] 
cont [ %d ]
appl [ %d ]
<ASN1 %d>
../deps/openssl/openssl/crypto/asn1/asn_mime.c
-----BEGIN %s-----
-----END %s-----
smime.p7m
application/x-pkcs7-
application/pkcs7-
MIME-Version: 1.0%s
Content-Type: multipart/signed;
 protocol="%ssignature";
 micalg="
"; boundary="----%s"%s%s
This is an S/MIME signed message%s%s
------%s%s
%s------%s%s
Content-Type: %ssignature;
 name="smime.p7s"%s
Content-Transfer-Encoding: base64%s
Content-Disposition: attachment;
 filename="smime.p7s"%s%s
%s------%s--%s%s
enveloped-data
signed-receipt
signed-data
certs-only
compressed-data
smime.p7z
 filename="%s"%s
Content-Type: %smime;
 smime-type=%s;
 name="%s"%s
Content-Transfer-Encoding: base64%s%s
content-type
multipart/signed
boundary
application/x-pkcs7-signature
application/pkcs7-signature
type: 
application/x-pkcs7-mime
application/pkcs7-mime
Content-Type: text/plain
text/plain
sha1
sha-256
sha-384
sha-512
gostr3411-94
oid_section
../deps/openssl/openssl/crypto/asn1/asn_moid.c
../deps/openssl/openssl/crypto/asn1/asn_pack.c
asn1
../deps/openssl/openssl/crypto/asn1/bio_asn1.c
ctx->buflen <= ctx->bufsize
../deps/openssl/openssl/crypto/asn1/bio_ndef.c
../deps/openssl/openssl/crypto/asn1/d2i_pr.c
../deps/openssl/openssl/crypto/asn1/d2i_pu.c
../deps/openssl/openssl/crypto/asn1/evp_asn1.c
0123456789ABCDEF
../deps/openssl/openssl/crypto/asn1/f_enum.c
../deps/openssl/openssl/crypto/asn1/f_int.c
../deps/openssl/openssl/crypto/asn1/f_string.c
../deps/openssl/openssl/crypto/asn1/i2d_pr.c
../deps/openssl/openssl/crypto/asn1/i2d_pu.c
NETSCAPE_ENCRYPTED_PKEY
NETSCAPE_PKEY
../deps/openssl/openssl/crypto/asn1/n_pkey.c
private-key
Enter Private Key password:
SGCKEYSALT
enckey
algor
private_key
NETSCAPE_CERT_SEQUENCE
type
certs
PBEPARAM
../deps/openssl/openssl/crypto/asn1/p5_pbe.c
salt
iter
PBE2PARAM
PBKDF2PARAM
../deps/openssl/openssl/crypto/asn1/p5_pbev2.c
keyfunc
encryption
keylength
PKCS8_PRIV_KEY_INFO
pkeyalg
pkey
attributes
../deps/openssl/openssl/crypto/asn1/t_crl.c
Certificate Revocation List (CRL):
%8sVersion %lu (0x%lx)
%8sIssuer: %s
%8sLast Update: 
%8sNext Update: 
NONE
CRL extensions
Revoked Certificates:
No Revoked Certificates.
    Serial Number: 
        Revocation Date: 
CRL entry extensions
%s 0
%s %s%lu (%s0x%lx)
%s%s
 (Negative)
%02x%s
../deps/openssl/openssl/crypto/asn1/t_req.c
Certificate Request:
    Data:
%8sVersion: %s%lu (%s0x%lx)
        Subject:%c
        Subject Public Key Info:
%12sPublic Key Algorithm: 
%12sUnable to load Public Key
%8sAttributes:
%12sa0:00
%12s
unable to print attribute
%8sRequested Extensions:
: %s
critical
%16s
Netscape SPKI:
  Public Key Algorithm: %s
UNKNOWN
  Unable to load public key
  Challenge String: %s
  Signature Algorithm: %s
      
../deps/openssl/openssl/crypto/asn1/t_x509.c
Certificate:
%8sVersion: %lu (0x%lx)
        Serial Number:
 %s%lu (%s0x%lx)
%12s%s
%02x%c
        Issuer:%c
        Validity
            Not Before: 
            Not After : 
%8sIssuer Unique ID: 
%8sSubject Unique ID: 
X509v3 extensions
        Subject OCSP hash: 
        Public key OCSP hash: 
    Signature Algorithm: 
Bad time value
%s %2d %02d:%02d:%02d%.*s %d%s
 GMT
%s %2d %02d:%02d:%02d %d%s
%*sTrusted Uses:
%*sNo Trusted Uses.
%*sRejected Uses:
%*sNo Rejected Uses.
%*sAlias: %s
%*sKey Id: 
%s%02X
../deps/openssl/openssl/crypto/asn1/tasn_dec.c
Field=
, Type=
Type=
../deps/openssl/openssl/crypto/asn1/tasn_enc.c
../deps/openssl/openssl/crypto/asn1/tasn_new.c
../deps/openssl/openssl/crypto/asn1/tasn_prn.c
%*s%s OF %s {
%*s%s:
%*s<EMPTY>
%*s}
<ABSENT>
:EXTERNAL TYPE %s
ERROR: selector [%d] invalid
Unprocessed type %d
 (%s)
NULL
BOOL ABSENT
TRUE
%s (%s)
 (%ld unused bits)
ASN1_INTEGER
ASN1_ENUMERATED
ASN1_BIT_STRING
ASN1_OCTET_STRING
ASN1_NULL
ASN1_OBJECT
ASN1_UTF8STRING
ASN1_PRINTABLESTRING
ASN1_T61STRING
ASN1_IA5STRING
ASN1_GENERALSTRING
ASN1_UTCTIME
ASN1_GENERALIZEDTIME
ASN1_VISIBLESTRING
ASN1_UNIVERSALSTRING
ASN1_BMPSTRING
ASN1_ANY
ASN1_SEQUENCE
ASN1_PRINTABLE
DISPLAYTEXT
DIRECTORYSTRING
ASN1_BOOLEAN
ASN1_TBOOLEAN
ASN1_FBOOLEAN
ASN1_OCTET_STRING_NDEF
ASN1_SEQUENCE_ANY
ASN1_SET_ANY
../deps/openssl/openssl/crypto/asn1/tasn_utl.c
X509_ALGOR
X509_ALGORS
algorithm
parameter
algorithms
X509_ATTRIBUTE
value.set
value.single
object
BIGNUM
X509_REVOKED
X509_CRL_INFO
X509_CRL
../deps/openssl/openssl/crypto/asn1/x_crl.c
revocationDate
extensions
sig_alg
issuer
lastUpdate
nextUpdate
revoked
signature
X509_EXTENSION
X509_EXTENSIONS
value
Extension
../deps/openssl/openssl/crypto/asn1/x_info.c
LONG
ZLONG
../deps/openssl/openssl/crypto/asn1/x_long.c
X509_NAME_ENTRY
X509_NAME_ENTRIES
X509_NAME_INTERNAL
X509_NAME
RDNS
Name
../deps/openssl/openssl/crypto/asn1/x_name.c
NETSCAPE_X509
header
../deps/openssl/openssl/crypto/asn1/x_pkey.c
X509_PUBKEY
../deps/openssl/openssl/crypto/asn1/x_pubkey.c
public_key
X509_REQ_INFO
X509_REQ
subject
pubkey
req_info
X509_SIG
digest
NETSCAPE_SPKAC
NETSCAPE_SPKI
challenge
spkac
sig_algor
X509_VAL
notBefore
notAfter
X509_CINF
X509
validity
issuerUID
subjectUID
cert_info
X509_CERT_AUX
X509_CERT_PAIR
trust
reject
alias
keyid
other
forward
reverse
blowfish(idx)
%04x - 
%s%04x - <SPACES/NULS>
%02X:
doapr()
../deps/openssl/openssl/crypto/bio/b_print.c
0123456789abcdef
0123456789
<NULL>
../deps/openssl/openssl/crypto/bio/b_sock.c
host=
http
telnet
socks
https
gopher
service='
getaddrinfo
freeaddrinfo
port='
sa.len.s <= sizeof(sa.from)
getnameinfo
%s:%s
%d.%d.%d.%d:%d
../deps/openssl/openssl/crypto/bio/bf_buff.c
non-blocking IO test filter
../deps/openssl/openssl/crypto/bio/bf_nbio.c
NULL filter
BIO[%p]: 
Free - %s
read(%d,%lu) - %s fd=%d
read(%d,%lu) - %s
write(%d,%lu) - %s fd=%d
write(%d,%lu) - %s
puts() - %s
gets(%lu) - %s
ctrl(%lu) - %s
read return %ld
write return %ld
gets return %ld
puts return %ld
ctrl return %ld
bio callback - unknown type (%d)
ACPT_STATE
BIO_accept
BIO_BER_GET_HEADER
BIO_callback_ctrl
BIO_ctrl
BIO_gethostbyname
BIO_gets
BIO_get_accept_socket
BIO_get_host_ip
BIO_get_port
BIO_MAKE_PAIR
BIO_new
BIO_new_file
BIO_new_mem_buf
BIO_nread
BIO_nread0
BIO_nwrite
BIO_nwrite0
BIO_puts
BIO_read
BIO_sock_init
BIO_write
BUFFER_CTRL
CONN_CTRL
CONN_STATE
DGRAM_SCTP_READ
DGRAM_SCTP_WRITE
FILE_CTRL
FILE_READ
LINEBUFFER_CTRL
MEM_READ
MEM_WRITE
WSASTARTUP
accept error
bad fopen mode
bad hostname lookup
broken pipe
connect error
EOF on memory BIO
error setting nbio
error setting nbio on accepted socket
error setting nbio on accept socket
gethostbyname addr is not af inet
invalid argument
invalid ip address
in use
keepalive
nbio connect error
no accept port specified
no hostname specified
no port defined
no port specified
no such file
null parameter
tag mismatch
unable to bind socket
unable to create socket
unable to listen socket
unsupported method
write to read only BIO
WSAStartup
../deps/openssl/openssl/crypto/bio/bio_lib.c
socket accept
../deps/openssl/openssl/crypto/bio/bss_acpt.c
../deps/openssl/openssl/crypto/bio/bss_bio.c
BIO pair
../deps/openssl/openssl/crypto/bio/bss_conn.c
socket connect
not initialized
datagram socket
../deps/openssl/openssl/crypto/bio/bss_dgram.c
sa.len.s <= sizeof(sa.peer)
getsockopt
sz.s <= sizeof(data->socket_timeout)
setsockopt
sz.s <= sizeof(struct timeval)
file descriptor
../deps/openssl/openssl/crypto/bio/bss_file.c
fopen('
FILE pointer
syslog
../deps/openssl/openssl/crypto/bio/bss_log.c
application
../deps/openssl/openssl/crypto/bio/bss_mem.c
memory buffer
socket
../deps/openssl/openssl/crypto/bn/bn_add.c
../deps/openssl/openssl/crypto/bn/bn_blind.c
../deps/openssl/openssl/crypto/bn/bn_ctx.c
../deps/openssl/openssl/crypto/bn/bn_div.c
BNRAND
BN_BLINDING_convert_ex
BN_BLINDING_create_param
BN_BLINDING_invert_ex
BN_BLINDING_new
BN_BLINDING_update
BN_bn2dec
BN_bn2hex
BN_CTX_get
BN_CTX_new
BN_CTX_start
BN_div
BN_div_no_branch
BN_div_recp
BN_exp
bn_expand2
BN_EXPAND_INTERNAL
BN_GF2m_mod
BN_GF2m_mod_exp
BN_GF2m_mod_mul
BN_GF2m_mod_solve_quad
BN_GF2m_mod_solve_quad_arr
BN_GF2m_mod_sqr
BN_GF2m_mod_sqrt
BN_lshift
BN_mod_exp2_mont
BN_mod_exp_mont
BN_mod_exp_mont_consttime
BN_mod_exp_mont_word
BN_mod_exp_recp
BN_mod_exp_simple
BN_mod_inverse
BN_mod_inverse_no_branch
BN_mod_lshift_quick
BN_mod_mul_reciprocal
BN_mod_sqrt
BN_mpi2bn
BN_new
BN_rand
BN_rand_range
BN_rshift
BN_usub
arg2 lt arg3
bad reciprocal
bignum too long
bits too small
called with even modulus
div by zero
encoding error
expand on static bignum data
input not reduced
invalid length
invalid range
invalid shift
not a square
no inverse
no solution
p is not prime
too many iterations
too many temporary variables
../deps/openssl/openssl/crypto/bn/bn_exp.c
../deps/openssl/openssl/crypto/bn/bn_exp2.c
../deps/openssl/openssl/crypto/bn/bn_gcd.c
../deps/openssl/openssl/crypto/bn/bn_gf2m.c
../deps/openssl/openssl/crypto/bn/bn_lib.c
../deps/openssl/openssl/crypto/bn/bn_mod.c
../deps/openssl/openssl/crypto/bn/bn_mont.c
../deps/openssl/openssl/crypto/bn/bn_mpi.c
../deps/openssl/openssl/crypto/bn/bn_print.c
%019lu
bn(%d,%d)
../deps/openssl/openssl/crypto/bn/bn_rand.c
../deps/openssl/openssl/crypto/bn/bn_recp.c
../deps/openssl/openssl/crypto/bn/bn_shift.c
../deps/openssl/openssl/crypto/bn/bn_sqrt.c
BUF_memdup
BUF_MEM_grow
BUF_MEM_grow_clean
BUF_MEM_new
BUF_strdup
BUF_strndup
../deps/openssl/openssl/crypto/buffer/buf_str.c
../deps/openssl/openssl/crypto/buffer/buffer.c
CMAC
OpenSSL CMAC method
hexkey
../deps/openssl/openssl/crypto/cmac/cmac.c
CMS_IssuerAndSerialNumber
CMS_OtherCertificateFormat
CMS_CertificateChoices
CMS_SignerIdentifier
CMS_EncapsulatedContentInfo
CMS_SignerInfo
CMS_OtherRevocationInfoFormat
CMS_RevocationInfoChoice
CMS_SignedData
CMS_OriginatorInfo
CMS_EncryptedContentInfo
CMS_KeyTransRecipientInfo
CMS_OtherKeyAttribute
CMS_RecipientKeyIdentifier
CMS_KeyAgreeRecipientIdentifier
CMS_RecipientEncryptedKey
CMS_OriginatorPublicKey
CMS_OriginatorIdentifierOrKey
CMS_KeyAgreeRecipientInfo
CMS_KEKIdentifier
CMS_KEKRecipientInfo
CMS_PasswordRecipientInfo
CMS_OtherRecipientInfo
CMS_RecipientInfo
CMS_EnvelopedData
CMS_DigestedData
CMS_EncryptedData
CMS_AuthenticatedData
CMS_CompressedData
CMS_ContentInfo
CMS_Attributes_Sign
CMS_Attributes_Verify
CMS_ReceiptsFrom
CMS_ReceiptRequest
CMS_Receipt
CMS_SharedInfo
otherCertFormat
otherCert
d.certificate
d.extendedCertificate
d.v1AttrCert
d.v2AttrCert
d.other
d.issuerAndSerialNumber
d.subjectKeyIdentifier
eContentType
eContent
digestAlgorithm
signedAttrs
signatureAlgorithm
unsignedAttrs
otherRevInfoFormat
otherRevInfo
d.crl
digestAlgorithms
encapContentInfo
certificates
crls
signerInfos
contentType
contentEncryptionAlgorithm
encryptedContent
keyEncryptionAlgorithm
encryptedKey
keyAttrId
keyAttr
subjectKeyIdentifier
date
d.rKeyId
publicKey
d.originatorKey
originator
recipientEncryptedKeys
keyIdentifier
kekid
keyDerivationAlgorithm
oriType
oriValue
d.ktri
d.kari
d.kekri
d.pwri
d.ori
originatorInfo
recipientInfos
encryptedContentInfo
unprotectedAttrs
macAlgorithm
authAttrs
unauthAttrs
compressionAlgorithm
d.data
d.signedData
d.envelopedData
d.digestedData
d.encryptedData
d.authenticatedData
d.compressedData
CMS_ATTRIBUTES
d.allOrFirstTier
d.receiptList
signedContentIdentifier
receiptsFrom
receiptsTo
originatorSignatureValue
keyInfo
entityUInfo
suppPubInfo
../deps/openssl/openssl/crypto/cms/cms_dd.c
../deps/openssl/openssl/crypto/cms/cms_enc.c
../deps/openssl/openssl/crypto/cms/cms_env.c
CHECK_CONTENT
CMS_add0_cert
CMS_add0_recipient_key
CMS_add0_recipient_password
CMS_add1_ReceiptRequest
CMS_add1_recipient_cert
CMS_add1_signer
CMS_ADD1_SIGNINGTIME
CMS_compress
cms_CompressedData_create
cms_CompressedData_init_bio
CMS_COPY_CONTENT
CMS_COPY_MESSAGEDIGEST
CMS_data
CMS_dataFinal
CMS_dataInit
CMS_decrypt
CMS_decrypt_set1_key
CMS_decrypt_set1_password
CMS_decrypt_set1_pkey
cms_DigestAlgorithm_find_ctx
cms_DigestAlgorithm_init_bio
cms_DigestedData_do_final
CMS_digest_verify
cms_encode_Receipt
CMS_encrypt
cms_EncryptedContent_init_bio
CMS_EncryptedData_decrypt
CMS_EncryptedData_encrypt
CMS_EncryptedData_set1_key
CMS_EnvelopedData_create
cms_EnvelopedData_init_bio
CMS_ENVELOPED_DATA_INIT
cms_env_asn1_ctrl
CMS_final
CMS_GET0_CERTIFICATE_CHOICES
CMS_get0_content
CMS_GET0_ECONTENT_TYPE
cms_get0_enveloped
CMS_GET0_REVOCATION_CHOICES
CMS_GET0_SIGNED
cms_msgSigDigest_add1
CMS_ReceiptRequest_create0
cms_Receipt_verify
CMS_RecipientInfo_decrypt
CMS_RecipientInfo_encrypt
cms_RecipientInfo_kari_encrypt
CMS_RecipientInfo_kari_get0_alg
CMS_RecipientInfo_kari_get0_orig_id
CMS_RecipientInfo_kari_get0_reks
CMS_RecipientInfo_kari_orig_id_cmp
CMS_RECIPIENTINFO_KEKRI_DECRYPT
CMS_RECIPIENTINFO_KEKRI_ENCRYPT
CMS_RecipientInfo_kekri_get0_id
CMS_RecipientInfo_kekri_id_cmp
CMS_RecipientInfo_ktri_cert_cmp
CMS_RECIPIENTINFO_KTRI_DECRYPT
CMS_RECIPIENTINFO_KTRI_ENCRYPT
CMS_RecipientInfo_ktri_get0_algs
CMS_RecipientInfo_ktri_get0_signer_id
cms_RecipientInfo_pwri_crypt
CMS_RecipientInfo_set0_key
CMS_RecipientInfo_set0_password
CMS_RecipientInfo_set0_pkey
CMS_SD_ASN1_CTRL
cms_set1_ias
cms_set1_keyid
cms_set1_SignerIdentifier
CMS_set_detached
CMS_sign
CMS_SIGNED_DATA_INIT
CMS_SIGNERINFO_CONTENT_SIGN
CMS_SignerInfo_sign
CMS_SignerInfo_verify
CMS_SIGNERINFO_VERIFY_CERT
CMS_SignerInfo_verify_content
CMS_sign_receipt
CMS_stream
CMS_uncompress
CMS_verify
add signer error
certificate already present
certificate has no keyid
certificate verify error
cipher initialisation error
cipher parameter initialisation error
cms datafinal error
cms lib
contentidentifier mismatch
content not found
content type mismatch
content type not compressed data
content type not enveloped data
content type not signed data
content verify error
ctrl error
ctrl failure
digest error
error getting public key
error reading messagedigest attribute
error setting key
error setting recipientinfo
invalid encrypted key length
invalid key encryption parameter
invalid key length
md bio init error
messagedigest attribute wrong length
messagedigest wrong length
msgsigdigest error
msgsigdigest verification failure
msgsigdigest wrong length
need one signer
not a signed receipt
not encrypted data
not kek
not key agreement
not key transport
not pwri
not supported for this key type
no cipher
no content
no digest set
no key
no key or cert
no matching digest
no matching recipient
no matching signature
no msgsigdigest
no password
no private key
no public key
no receipt request
no signers
private key does not match certificate
receipt decode error
recipient error
signer certificate not found
signfinal error
smime text error
store init error
type not compressed data
type not data
type not digested data
type not encrypted data
type not enveloped data
unable to finalize context
unknown cipher
unknown digest algorihm
unknown id
unsupported content type
unsupported kek algorithm
unsupported key encryption algorithm
unsupported recipient type
unsupported recpientinfo type
unwrap error
unwrap failure
verification failure
wrap error
../deps/openssl/openssl/crypto/cms/cms_ess.c
../deps/openssl/openssl/crypto/cms/cms_io.c
../deps/openssl/openssl/crypto/cms/cms_kari.c
../deps/openssl/openssl/crypto/cms/cms_lib.c
../deps/openssl/openssl/crypto/cms/cms_pwri.c
../deps/openssl/openssl/crypto/cms/cms_sd.c
../deps/openssl/openssl/crypto/cms/cms_smime.c
smime_sign
run length compression
(undef)
BIO_ZLIB_FLUSH
BIO_ZLIB_NEW
BIO_ZLIB_READ
BIO_ZLIB_WRITE
zlib deflate error
zlib inflate error
zlib not supported
../deps/openssl/openssl/crypto/comp/comp_lib.c
../deps/openssl/openssl/crypto/conf/conf_api.c
vv == NULL
OpenSSL default
../deps/openssl/openssl/crypto/conf/conf_def.c
line 
[%s] %s=%s
[[%s]]
WIN32
CONF_dump_fp
CONF_load
CONF_load_bio
CONF_load_fp
CONF_modules_load
CONF_parse_list
DEF_LOAD
DEF_LOAD_BIO
MODULE_INIT
MODULE_LOAD_DSO
MODULE_RUN
NCONF_dump_bio
NCONF_dump_fp
NCONF_get_number
NCONF_get_number_e
NCONF_get_section
NCONF_get_string
NCONF_load
NCONF_load_bio
NCONF_load_fp
NCONF_new
STR_COPY
error loading dso
list cannot be null
missing close square bracket
missing equal sign
missing finish function
missing init function
module initialization error
no close brace
no conf
no conf or environment variable
no section
no value
unable to create new section
unknown module name
variable has no value
../deps/openssl/openssl/crypto/conf/conf_lib.c
group=
 name=
openssl_conf
OPENSSL_CONF
../deps/openssl/openssl/crypto/conf/conf_mod.c
openssl.cnf
module=
%-8d
, retcode=
OPENSSL_init
OPENSSL_finish
, path=
CRYPTO_get_ex_new_index
CRYPTO_get_new_dynlockid
CRYPTO_get_new_lockid
CRYPTO_set_ex_data
DEF_ADD_INDEX
DEF_GET_CLASS
FIPS_mode_set
INT_DUP_EX_DATA
INT_FREE_EX_DATA
INT_NEW_EX_DATA
fips mode not supported
no dynlock create callback
../deps/openssl/openssl/crypto/cryptlib.c
pointer != NULL
dynamic
ERROR
OPENSSL_ia32cap
%lli
%s(%d): OpenSSL internal error, assertion failed: %s
<<ERROR>>
ex_data
x509
x509_info
x509_pkey
x509_crl
x509_req
evp_pkey
x509_store
ssl_ctx
ssl_cert
ssl_session
ssl_sess_cert
ssl_method
rand
rand2
debug_malloc
gethostbyname
getservbyname
readdir
RSA_blinding
debug_malloc2
dynlock
engine
ecdsa
ecdh
ec_pre_comp
store
comp
fips
fips2
built on: reproducible build, date unspecified
-C flags not included-
google
OPENSSLDIR: "/System/Library/OpenSSL/"
not available
cisc
des(%s,%s,%s,%s)
../deps/openssl/openssl/crypto/des/enc_read.c
../deps/openssl/openssl/crypto/des/enc_writ.c
OpenSSL PKCS#3 DH method
X9.42 DH
OpenSSL X9.42 DH method
DH Private-Key
DH Public-Key
DH Parameters
../deps/openssl/openssl/crypto/dh/dh_ameth.c
%s: (%d bit)
private-key:
public-key:
prime:
generator:
subgroup order:
subgroup factor:
seed:
counter:
recommended-private-length: %d bits
int_dhvparams
int_dhx942_dh
length
seed
counter
vparams
COMPUTE_KEY
DHparams_print_fp
DH_BUILTIN_GENPARAMS
DH_CMS_DECRYPT
DH_CMS_SET_PEERKEY
DH_CMS_SET_SHARED_INFO
DH_compute_key
DH_generate_key
DH_generate_parameters_ex
DH_new_method
DH_PARAM_DECODE
DH_PRIV_DECODE
DH_PRIV_ENCODE
DH_PUB_DECODE
DH_PUB_ENCODE
DO_DH_PRINT
GENERATE_KEY
GENERATE_PARAMETERS
PKEY_DH_DERIVE
PKEY_DH_KEYGEN
bad generator
bn decode error
bn error
invalid public key
kdf parameter error
keys not set
key size too small
modulus too large
non fips method
no parameters set
no private value
parameter encoding error
peer key error
shared info error
../deps/openssl/openssl/crypto/dh/dh_gen.c
OpenSSL DH Method
../deps/openssl/openssl/crypto/dh/dh_key.c
../deps/openssl/openssl/crypto/dh/dh_lib.c
../deps/openssl/openssl/crypto/dh/dh_pmeth.c
dh_paramgen_prime_len
dh_rfc5114
dh_paramgen_generator
dh_paramgen_subprime_len
dh_paramgen_type
../deps/openssl/openssl/crypto/dh/dh_prn.c
OpenSSL DSA method
../deps/openssl/openssl/crypto/dsa/dsa_ameth.c
Private-Key
Public-Key
DSA-Parameters
priv:
pub: 
P:   
Q:   
G:   
r:   
s:   
DSA_SIG
../deps/openssl/openssl/crypto/dsa/dsa_asn1.c
pub_key
priv_key
d2i_DSA_SIG
DO_DSA_PRINT
DSAparams_print
DSAparams_print_fp
DSA_BUILTIN_PARAMGEN2
DSA_do_sign
DSA_do_verify
DSA_generate_key
DSA_generate_parameters_ex
DSA_new_method
DSA_PARAM_DECODE
DSA_print_fp
DSA_PRIV_DECODE
DSA_PRIV_ENCODE
DSA_PUB_DECODE
DSA_PUB_ENCODE
DSA_sign
DSA_sign_setup
DSA_SIG_new
DSA_SIG_PRINT
DSA_verify
i2d_DSA_SIG
OLD_DSA_PRIV_DECODE
PKEY_DSA_CTRL
PKEY_DSA_KEYGEN
SIG_CB
bad q value
data too large for key size
invalid digest type
invalid parameters
missing parameters
need new setup values
non fips dsa method
q not prime
../deps/openssl/openssl/crypto/dsa/dsa_gen.c
../deps/openssl/openssl/crypto/dsa/dsa_lib.c
../deps/openssl/openssl/crypto/dsa/dsa_ossl.c
../deps/openssl/openssl/crypto/dsa/dsa_pmeth.c
dsa_paramgen_bits
dsa_paramgen_q_bits
dsa_paramgen_md
../deps/openssl/openssl/crypto/dsa/dsa_prn.c
../deps/openssl/openssl/crypto/dsa/dsa_sign.c
OpenSSL 'dlfcn' shared library method
../deps/openssl/openssl/crypto/dso/dso_dlfcn.c
filename(
symname(
lib%s.dylib
%s.dylib
dlfcn_pathbyaddr(): 
BEOS_BIND_FUNC
BEOS_BIND_VAR
BEOS_LOAD
BEOS_NAME_CONVERTER
BEOS_UNLOAD
DLFCN_BIND_FUNC
DLFCN_BIND_VAR
DLFCN_LOAD
DLFCN_MERGER
DLFCN_NAME_CONVERTER
DLFCN_UNLOAD
DL_BIND_FUNC
DL_BIND_VAR
DL_LOAD
DL_MERGER
DL_NAME_CONVERTER
DL_UNLOAD
DSO_bind_func
DSO_bind_var
DSO_convert_filename
DSO_ctrl
DSO_free
DSO_get_filename
DSO_get_loaded_filename
DSO_global_lookup
DSO_load
DSO_merge
DSO_new_method
DSO_pathbyaddr
DSO_set_filename
DSO_set_name_converter
DSO_up_ref
GLOBAL_LOOKUP_FUNC
PATHBYADDR
VMS_BIND_SYM
VMS_LOAD
VMS_MERGER
VMS_UNLOAD
WIN32_BIND_FUNC
WIN32_BIND_VAR
WIN32_GLOBALLOOKUP
WIN32_GLOBALLOOKUP_FUNC
WIN32_JOINER
WIN32_LOAD
WIN32_MERGER
WIN32_NAME_CONVERTER
WIN32_PATHBYADDR
WIN32_SPLITTER
WIN32_UNLOAD
control command failed
dso already loaded
empty file structure
failure
filename too big
cleanup method function failed
incorrect file syntax
could not load the shared library
name translation failed
no filename
no file specification
a null shared library handle was used
set filename failed
the meth_data stack is corrupt
could not bind to the requested symbol name
could not unload the shared library
functionality not supported
../deps/openssl/openssl/crypto/dso/dso_lib.c
NULL shared library method
../deps/openssl/openssl/crypto/ec/ec2_mult.c
../deps/openssl/openssl/crypto/ec/ec2_oct.c
../deps/openssl/openssl/crypto/ec/ec2_smpl.c
OpenSSL EC algorithm
../deps/openssl/openssl/crypto/ec/ec_ameth.c
ECDSA-Parameters
../deps/openssl/openssl/crypto/ec/ec_asn1.c
X9_62_PENTANOMIAL
X9_62_CHARACTERISTIC_TWO
X9_62_FIELDID
X9_62_CURVE
ECPARAMETERS
ECPKPARAMETERS
EC_PRIVATEKEY
p.onBasis
p.tpBasis
p.ppBasis
p.other
fieldType
p.prime
p.char_two
fieldID
curve
base
cofactor
value.named_curve
value.parameters
value.implicitlyCA
privateKey
parameters
../deps/openssl/openssl/crypto/ec/ec_check.c
../deps/openssl/openssl/crypto/ec/ec_curve.c
SECG/WTLS curve over a 112 bit prime field
SECG curve over a 112 bit prime field
SECG curve over a 128 bit prime field
SECG curve over a 160 bit prime field
SECG/WTLS curve over a 160 bit prime field
SECG curve over a 192 bit prime field
SECG curve over a 224 bit prime field
NIST/SECG curve over a 224 bit prime field
SECG curve over a 256 bit prime field
NIST/SECG curve over a 384 bit prime field
NIST/SECG curve over a 521 bit prime field
NIST/X9.62/SECG curve over a 192 bit prime field
X9.62 curve over a 192 bit prime field
X9.62 curve over a 239 bit prime field
X9.62/SECG curve over a 256 bit prime field
SECG curve over a 113 bit binary field
SECG/WTLS curve over a 131 bit binary field
SECG curve over a 131 bit binary field
NIST/SECG/WTLS curve over a 163 bit binary field
SECG curve over a 163 bit binary field
NIST/SECG curve over a 163 bit binary field
SECG curve over a 193 bit binary field
NIST/SECG/WTLS curve over a 233 bit binary field
SECG curve over a 239 bit binary field
NIST/SECG curve over a 283 bit binary field
NIST/SECG curve over a 409 bit binary field
NIST/SECG curve over a 571 bit binary field
X9.62 curve over a 163 bit binary field
X9.62 curve over a 176 bit binary field
X9.62 curve over a 191 bit binary field
X9.62 curve over a 208 bit binary field
X9.62 curve over a 239 bit binary field
X9.62 curve over a 272 bit binary field
X9.62 curve over a 304 bit binary field
X9.62 curve over a 359 bit binary field
X9.62 curve over a 368 bit binary field
X9.62 curve over a 431 bit binary field
WTLS curve over a 113 bit binary field
WTLS curve over a 112 bit prime field
WTLS curve over a 160 bit prime field
WTLS curvs over a 224 bit prime field
IPSec/IKE/Oakley curve #3 over a 155 bit binary field.
Not suitable for ECDSA.
Questionable extension field!
IPSec/IKE/Oakley curve #4 over a 185 bit binary field.
Not suitable for ECDSA.
Questionable extension field!
RFC 5639 curve over a 160 bit prime field
RFC 5639 curve over a 192 bit prime field
RFC 5639 curve over a 224 bit prime field
RFC 5639 curve over a 256 bit prime field
RFC 5639 curve over a 320 bit prime field
RFC 5639 curve over a 384 bit prime field
RFC 5639 curve over a 512 bit prime field
B-163
B-233
B-283
B-409
B-571
K-163
K-233
K-283
K-409
K-571
P-192
P-224
P-256
P-384
P-521
BN_TO_FELEM
COMPUTE_WNAF
d2i_ECParameters
d2i_ECPKParameters
d2i_ECPrivateKey
DO_EC_KEY_PRINT
ECDH_CMS_DECRYPT
ECDH_CMS_SET_SHARED_INFO
ECKEY_PARAM2TYPE
ECKEY_PARAM_DECODE
ECKEY_PRIV_DECODE
ECKEY_PRIV_ENCODE
ECKEY_PUB_DECODE
ECKEY_PUB_ENCODE
ECKEY_TYPE2PARAM
ECParameters_print
ECParameters_print_fp
ECPKParameters_print
ECPKParameters_print_fp
ecp_nistz256_get_affine
ecp_nistz256_mult_precompute
ecp_nistz256_points_mul
ecp_nistz256_pre_comp_new
ecp_nistz256_set_words
ecp_nistz256_windowed_mul
ECP_NIST_MOD_192
ECP_NIST_MOD_224
ECP_NIST_MOD_256
ECP_NIST_MOD_521
EC_ASN1_GROUP2CURVE
EC_ASN1_GROUP2FIELDID
EC_ASN1_GROUP2PARAMETERS
EC_ASN1_GROUP2PKPARAMETERS
EC_ASN1_PARAMETERS2GROUP
EC_ASN1_PKPARAMETERS2GROUP
EC_EX_DATA_set_data
EC_GF2M_MONTGOMERY_POINT_MULTIPLY
ec_GF2m_simple_group_check_discriminant
ec_GF2m_simple_group_set_curve
ec_GF2m_simple_oct2point
ec_GF2m_simple_point2oct
ec_GF2m_simple_point_get_affine_coordinates
ec_GF2m_simple_point_set_affine_coordinates
ec_GF2m_simple_set_compressed_coordinates
ec_GFp_mont_field_decode
ec_GFp_mont_field_encode
ec_GFp_mont_field_mul
ec_GFp_mont_field_set_to_one
ec_GFp_mont_field_sqr
ec_GFp_mont_group_set_curve
EC_GFP_MONT_GROUP_SET_CURVE_GFP
ec_GFp_nistp224_group_set_curve
ec_GFp_nistp224_points_mul
ec_GFp_nistp224_point_get_affine_coordinates
ec_GFp_nistp256_group_set_curve
ec_GFp_nistp256_points_mul
ec_GFp_nistp256_point_get_affine_coordinates
ec_GFp_nistp521_group_set_curve
ec_GFp_nistp521_points_mul
ec_GFp_nistp521_point_get_affine_coordinates
ec_GFp_nist_field_mul
ec_GFp_nist_field_sqr
ec_GFp_nist_group_set_curve
ec_GFp_simple_group_check_discriminant
ec_GFp_simple_group_set_curve
EC_GFP_SIMPLE_GROUP_SET_CURVE_GFP
EC_GFP_SIMPLE_GROUP_SET_GENERATOR
ec_GFp_simple_make_affine
ec_GFp_simple_oct2point
ec_GFp_simple_point2oct
ec_GFp_simple_points_make_affine
ec_GFp_simple_point_get_affine_coordinates
EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES_GFP
ec_GFp_simple_point_set_affine_coordinates
EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES_GFP
ec_GFp_simple_set_compressed_coordinates
EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES_GFP
EC_GROUP_check
EC_GROUP_check_discriminant
EC_GROUP_copy
EC_GROUP_get0_generator
EC_GROUP_get_cofactor
EC_GROUP_get_curve_GF2m
EC_GROUP_get_curve_GFp
EC_GROUP_get_degree
EC_GROUP_get_order
EC_GROUP_get_pentanomial_basis
EC_GROUP_get_trinomial_basis
EC_GROUP_new
EC_GROUP_new_by_curve_name
EC_GROUP_NEW_FROM_DATA
EC_GROUP_precompute_mult
EC_GROUP_set_curve_GF2m
EC_GROUP_set_curve_GFp
EC_GROUP_SET_EXTRA_DATA
EC_GROUP_set_generator
EC_KEY_check_key
EC_KEY_copy
EC_KEY_generate_key
EC_KEY_new
EC_KEY_print
EC_KEY_print_fp
EC_KEY_set_public_key_affine_coordinates
EC_POINTs_make_affine
EC_POINT_add
EC_POINT_cmp
EC_POINT_copy
EC_POINT_dbl
EC_POINT_get_affine_coordinates_GF2m
EC_POINT_get_affine_coordinates_GFp
EC_POINT_get_Jprojective_coordinates_GFp
EC_POINT_invert
EC_POINT_is_at_infinity
EC_POINT_is_on_curve
EC_POINT_make_affine
EC_POINT_mul
EC_POINT_new
EC_POINT_oct2point
EC_POINT_point2oct
EC_POINT_set_affine_coordinates_GF2m
EC_POINT_set_affine_coordinates_GFp
EC_POINT_set_compressed_coordinates_GF2m
EC_POINT_set_compressed_coordinates_GFp
EC_POINT_set_Jprojective_coordinates_GFp
EC_POINT_set_to_infinity
EC_PRE_COMP_DUP
EC_PRE_COMP_NEW
ec_wNAF_mul
ec_wNAF_precompute_mult
i2d_ECParameters
i2d_ECPKParameters
i2d_ECPrivateKey
i2o_ECPublicKey
NISTP224_PRE_COMP_NEW
NISTP256_PRE_COMP_NEW
NISTP521_PRE_COMP_NEW
o2i_ECPublicKey
OLD_EC_PRIV_DECODE
PKEY_EC_CTRL
PKEY_EC_CTRL_STR
PKEY_EC_DERIVE
PKEY_EC_KEYGEN
PKEY_EC_PARAMGEN
PKEY_EC_SIGN
asn1 error
asn1 unknown field
bignum out of range
coordinates out of range
d2i ecpkparameters failure
discriminant is zero
ec group new by name failure
field too large
gf2m not supported
group2pkparameters failure
i2d ecpkparameters failure
incompatible objects
invalid compressed point
invalid compression bit
invalid curve
invalid digest
invalid encoding
invalid field
invalid form
invalid group order
invalid pentanomial basis
invalid private key
invalid trinomial basis
missing private key
not a NIST prime
not a supported NIST prime
not implemented
no field mod
passed null parameter
pkparameters2group failure
point at infinity
point is not on curve
slot full
undefined generator
undefined order
unknown group
unknown order
unsupported field
wrong curve parameters
wrong order
../deps/openssl/openssl/crypto/ec/ec_key.c
../deps/openssl/openssl/crypto/ec/ec_lib.c
../deps/openssl/openssl/crypto/ec/ec_mult.c
../deps/openssl/openssl/crypto/ec/ec_oct.c
../deps/openssl/openssl/crypto/ec/ec_pmeth.c
ec_paramgen_curve
ec_param_enc
explicit
ecdh_kdf_md
ecdh_cofactor_mode
../deps/openssl/openssl/crypto/ec/ec_print.c
../deps/openssl/openssl/crypto/ec/eck_prn.c
Generator (compressed):
Generator (uncompressed):
Generator (hybrid):
ASN1 OID: %s
NIST CURVE: %s
Field Type: %s
Basis Type: %s
Polynomial:
Prime:
A:   
B:   
Order: 
Cofactor: 
Seed:
../deps/openssl/openssl/crypto/ec/ecp_mont.c
../deps/openssl/openssl/crypto/ec/ecp_nist.c
../deps/openssl/openssl/crypto/ec/ecp_oct.c
../deps/openssl/openssl/crypto/ec/ecp_smpl.c
ECDH_CHECK
ECDH_compute_key
ECDH_DATA_new_method
KDF failed
point arithmetic failure
../deps/openssl/openssl/crypto/ecdh/ech_lib.c
OpenSSL ECDH method
../deps/openssl/openssl/crypto/ecdh/ech_ossl.c
ECDSA_SIG
ECDSA_CHECK
ECDSA_DATA_NEW_METHOD
ECDSA_do_sign
ECDSA_do_verify
ECDSA_METHOD_new
ECDSA_sign_setup
err ec lib
random number generation failed
signature malloc failed
../deps/openssl/openssl/crypto/ecdsa/ecs_lib.c
OpenSSL ECDSA method
../deps/openssl/openssl/crypto/ecdsa/ecs_ossl.c
engines
../deps/openssl/openssl/crypto/engine/eng_cnf.c
engine_id
soft_load
dynamic_path
SO_PATH
LIST_ADD
LOAD
EMPTY
init
default_algorithms
section=
, name=
../deps/openssl/openssl/crypto/engine/eng_ctrl.c
Dynamic engine loading support
../deps/openssl/openssl/crypto/engine/eng_dyn.c
v_check
bind_engine
Specifies the path to the new ENGINE shared library
NO_VCHECK
Specifies to continue even if version checking fails (boolean)
Specifies an ENGINE id name for loading
Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)
DIR_LOAD
Specifies whether to load from 'DIR_ADD' directories (0=no,1=yes,2=mandatory)
DIR_ADD
Adds a directory from which ENGINEs can be loaded
Load up the ENGINE specified by other settings
DYNAMIC_CTRL
DYNAMIC_GET_DATA_CTX
DYNAMIC_LOAD
DYNAMIC_SET_DATA_CTX
ENGINE_add
ENGINE_by_id
ENGINE_cmd_is_executable
ENGINE_ctrl
ENGINE_ctrl_cmd
ENGINE_ctrl_cmd_string
ENGINE_finish
ENGINE_FREE_UTIL
ENGINE_get_cipher
ENGINE_GET_DEFAULT_TYPE
ENGINE_get_digest
ENGINE_get_next
ENGINE_get_pkey_asn1_meth
ENGINE_get_pkey_meth
ENGINE_get_prev
ENGINE_init
ENGINE_LIST_ADD
ENGINE_LIST_REMOVE
ENGINE_load_private_key
ENGINE_load_public_key
ENGINE_load_ssl_client_cert
ENGINE_new
ENGINE_remove
ENGINE_set_default_string
ENGINE_SET_DEFAULT_TYPE
ENGINE_set_id
ENGINE_set_name
ENGINE_TABLE_REGISTER
ENGINE_UNLOAD_KEY
ENGINE_UNLOCKED_FINISH
ENGINE_up_ref
INT_CTRL_HELPER
INT_ENGINE_CONFIGURE
INT_ENGINE_MODULE_INIT
LOG_MESSAGE
already loaded
argument is not a number
cmd not executable
command takes input
command takes no input
conflicting engine id
ctrl command not implemented
dh not implemented
dsa not implemented
DSO failure
dso not found
engines section error
engine configuration error
engine is not in the list
engine section error
failed loading private key
failed loading public key
finish failed
could not obtain hardware handle
'id' or 'name' missing
init failed
internal list error
invalid cmd name
invalid cmd number
invalid init value
invalid string
not initialised
not loaded
no control function
no index
no load function
no reference
no such engine
no unload function
provide parameters
rsa not implemented
unimplemented cipher
unimplemented digest
unimplemented public key method
version incompatibility
../deps/openssl/openssl/crypto/engine/eng_fat.c
str=
RAND
CIPHERS
DIGESTS
PKEY
PKEY_CRYPTO
PKEY_ASN1
../deps/openssl/openssl/crypto/engine/eng_init.c
../deps/openssl/openssl/crypto/engine/eng_lib.c
../deps/openssl/openssl/crypto/engine/eng_list.c
OPENSSL_ENGINES
Software engine support
(TEST_ENG_OPENSSL_RC4) test_init_key() called
(TEST_ENG_OPENSSL_PKEY)Loading Private key %s
../deps/openssl/openssl/crypto/engine/eng_pkey.c
rdrand
Intel RDRAND engine
../deps/openssl/openssl/crypto/engine/eng_table.c
../deps/openssl/openssl/crypto/engine/tb_asnmth.c
../deps/openssl/openssl/crypto/engine/tb_cipher.c
../deps/openssl/openssl/crypto/engine/tb_digest.c
../deps/openssl/openssl/crypto/engine/tb_pkmeth.c
../deps/openssl/openssl/crypto/err/err.c
lib(%lu)
func(%lu)
reason(%lu)
error:%08lX:%s:%s:%s
int_err_get (err.c)
int_thread_get (err.c)
unknown library
system library
bignum routines
rsa routines
Diffie-Hellman routines
digital envelope routines
memory buffer routines
object identifier routines
PEM routines
dsa routines
x509 certificate routines
asn1 encoding routines
configuration file routines
common libcrypto routines
elliptic curve routines
SSL routines
BIO routines
PKCS7 routines
X509 V3 routines
PKCS12 routines
random number generator
DSO support routines
time stamp routines
engine routines
OCSP routines
FIPS routines
CMS routines
HMAC routines
system lib
BN lib
RSA lib
DH lib
EVP lib
BUF lib
OBJ lib
PEM lib
DSA lib
X509 lib
ASN1 lib
CONF lib
CRYPTO lib
EC lib
SSL lib
BIO lib
PKCS7 lib
X509V3 lib
PKCS12 lib
RAND lib
DSO lib
ENGINE lib
OCSP lib
TS lib
nested asn1 error
bad asn1 object header
bad get asn1 object call
expecting an asn1 sequence
asn1 length mismatch
missing asn1 eos
malloc failure
called a function you should not call
passed a null parameter
called a function that was disabled at compile-time
fopen
connect
ioctlsocket
bind
listen
accept
opendir
fread
%lu:%s:%s:%d:%s
base64 encoding
../deps/openssl/openssl/crypto/evp/bio_b64.c
ctx->buf_off < (int)sizeof(ctx->buf)
ctx->buf_len <= (int)sizeof(ctx->buf)
ctx->buf_len >= ctx->buf_off
i <= n
ctx->buf_off <= (int)sizeof(ctx->buf)
ctx->tmp_len <= 3
ctx->buf_off + i < (int)sizeof(ctx->buf)
../deps/openssl/openssl/crypto/evp/bio_enc.c
message digest
reliable
The quick brown fox jumped over the lazy dog's back.
../deps/openssl/openssl/crypto/evp/bio_ok.c
DESX
DESX-CBC
desx
DES3
des3
idea
BF-CBC
blowfish
CAST
CAST5-CBC
cast
CAST-cbc
cast-cbc
aes128
AES192
AES-192-CBC
aes192
aes256
camellia128
CAMELLIA192
CAMELLIA-192-CBC
camellia192
camellia256
ripemd
RIPEMD160
rmd160
../deps/openssl/openssl/crypto/evp/digest.c
ctx->digest->md_size <= EVP_MAX_MD_SIZE
../deps/openssl/openssl/crypto/evp/e_aes.c
../deps/openssl/openssl/crypto/evp/e_camellia.c
../deps/openssl/openssl/crypto/evp/e_rc2.c
l <= sizeof(iv)
../deps/openssl/openssl/crypto/evp/encode.c
ctx->length <= (int)sizeof(ctx->enc_data)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
alg_section
../deps/openssl/openssl/crypto/evp/evp_cnf.c
fips_mode
name=
../deps/openssl/openssl/crypto/evp/evp_enc.c
ctx->cipher->block_size == 1 || ctx->cipher->block_size == 8 || ctx->cipher->block_size == 16
EVP_CIPHER_CTX_iv_length(ctx) <= (int)sizeof(ctx->iv)
bl <= (int)sizeof(ctx->buf)
b <= sizeof ctx->buf
b <= sizeof ctx->final
AESNI_INIT_KEY
AESNI_XTS_CIPHER
AES_INIT_KEY
AES_T4_INIT_KEY
AES_XTS
AES_XTS_CIPHER
ALG_MODULE_INIT
CAMELLIA_INIT_KEY
CMAC_INIT
CMLL_T4_INIT_KEY
D2I_PKEY
DO_SIGVER_INIT
DSAPKEY2PKCS8
DSA_PKEY2PKCS8
ECDSA_PKEY2PKCS8
ECKEY_PKEY2PKCS8
EVP_CipherInit_ex
EVP_CIPHER_CTX_copy
EVP_CIPHER_CTX_ctrl
EVP_CIPHER_CTX_set_key_length
EVP_DecryptFinal_ex
EVP_DigestInit_ex
EVP_EncryptFinal_ex
EVP_MD_CTX_copy_ex
EVP_MD_size
EVP_OpenInit
EVP_PBE_alg_add
EVP_PBE_alg_add_type
EVP_PBE_CipherInit
EVP_PKCS82PKEY
EVP_PKCS82PKEY_BROKEN
EVP_PKEY2PKCS8_broken
EVP_PKEY_copy_parameters
EVP_PKEY_CTX_ctrl
EVP_PKEY_CTX_ctrl_str
EVP_PKEY_CTX_dup
EVP_PKEY_decrypt
EVP_PKEY_decrypt_init
EVP_PKEY_decrypt_old
EVP_PKEY_derive
EVP_PKEY_derive_init
EVP_PKEY_derive_set_peer
EVP_PKEY_encrypt
EVP_PKEY_encrypt_init
EVP_PKEY_encrypt_old
EVP_PKEY_get1_DH
EVP_PKEY_get1_DSA
EVP_PKEY_GET1_ECDSA
EVP_PKEY_get1_EC_KEY
EVP_PKEY_get1_RSA
EVP_PKEY_keygen
EVP_PKEY_keygen_init
EVP_PKEY_new
EVP_PKEY_paramgen
EVP_PKEY_paramgen_init
EVP_PKEY_sign
EVP_PKEY_sign_init
EVP_PKEY_verify
EVP_PKEY_verify_init
EVP_PKEY_verify_recover
EVP_PKEY_verify_recover_init
EVP_RIJNDAEL
EVP_SignFinal
EVP_VerifyFinal
FIPS_CIPHERINIT
FIPS_CIPHER_CTX_COPY
FIPS_CIPHER_CTX_CTRL
FIPS_CIPHER_CTX_SET_KEY_LENGTH
FIPS_DIGESTINIT
FIPS_MD_CTX_COPY
HMAC_Init_ex
INT_CTX_NEW
PKCS5_PBE_keyivgen
PKCS5_v2_PBE_keyivgen
PKCS5_V2_PBKDF2_KEYIVGEN
PKCS8_set_broken
PKEY_SET_TYPE
RC2_MAGIC_TO_METH
RC5_CTRL
aes iv setup failed
aes key setup failed
asn1 lib
bad block length
bad decrypt
bad key length
bn pubkey error
camellia key setup failed
cipher parameter error
command not supported
ctrl not implemented
ctrl operation not implemented
data not multiple of block length
different key types
different parameters
disabled for fips
error setting fips mode
evp pbe cipherinit error
expecting an rsa key
expecting a dh key
expecting a dsa key
expecting a ecdsa key
expecting a ec key
initialization error
input not initialized
invalid fips mode
invalid operation
keygen failure
message digest is null
method not supported
no cipher set
no dsa parameters
no key set
no operation set
no sign function configured
no verify function configured
operation not supported for this keytype
operaton not initialized
pkcs8 unknown broken type
private key decode error
private key encode error
too large
unknown option
unknown pbe algorithm
unsuported number of rounds
unsupported algorithm
unsupported keylength
unsupported key derivation function
unsupported key size
unsupported prf
unsupported private key algorithm
unsupported salt type
wrap mode not allowed
wrong final block length
../deps/openssl/openssl/crypto/evp/evp_key.c
nkey <= EVP_MAX_KEY_LENGTH
niv <= EVP_MAX_IV_LENGTH
../deps/openssl/openssl/crypto/evp/evp_lib.c
l <= sizeof(c->iv)
j <= sizeof(c->iv)
../deps/openssl/openssl/crypto/evp/evp_pbe.c
TYPE=
../deps/openssl/openssl/crypto/evp/evp_pkey.c
../deps/openssl/openssl/crypto/evp/m_sigver.c
../deps/openssl/openssl/crypto/evp/p5_crpt.c
EVP_CIPHER_key_length(cipher) <= (int)sizeof(md_tmp)
EVP_CIPHER_iv_length(cipher) <= 16
../deps/openssl/openssl/crypto/evp/p5_crpt2.c
keylen <= sizeof key
../deps/openssl/openssl/crypto/evp/p_dec.c
../deps/openssl/openssl/crypto/evp/p_enc.c
../deps/openssl/openssl/crypto/evp/p_lib.c
Public Key
Private Key
Parameters
%s algorithm "%s" unsupported
../deps/openssl/openssl/crypto/evp/p_open.c
../deps/openssl/openssl/crypto/evp/p_sign.c
../deps/openssl/openssl/crypto/evp/p_verify.c
../deps/openssl/openssl/crypto/evp/pmeth_fn.c
../deps/openssl/openssl/crypto/evp/pmeth_gn.c
../deps/openssl/openssl/crypto/evp/pmeth_lib.c
../deps/openssl/openssl/crypto/ex_data.c
HMAC
OpenSSL HMAC method
../deps/openssl/openssl/crypto/hmac/hm_ameth.c
../deps/openssl/openssl/crypto/hmac/hm_pmeth.c
../deps/openssl/openssl/crypto/hmac/hmac.c
j <= (int)sizeof(ctx->key)
idea(int)
KRB5_ENCDATA
KRB5_PRINCNAME
KRB5_TKTBODY
KRB5_TICKET
KRB5_APREQBODY
KRB5_APREQ
KRB5_CHECKSUM
KRB5_ENCKEY
KRB5_AUTHDATA
KRB5_AUTHENTBODY
KRB5_AUTHENT
etype
kvno
nametype
namestring
tktvno
realm
sname
encdata
pvno
msgtype
apoptions
ticket
authenticator
ctype
checksum
ktype
keyvalue
adtype
addata
avno
crealm
cname
cksum
cusec
ctime
subkey
seqnum
authorization
num_items             = %lu
num_nodes             = %u
num_alloc_nodes       = %u
num_expands           = %lu
num_expand_reallocs   = %lu
num_contracts         = %lu
num_contract_reallocs = %lu
num_hash_calls        = %lu
num_comp_calls        = %lu
num_insert            = %lu
num_replace           = %lu
num_delete            = %lu
num_no_delete         = %lu
num_retrieve          = %lu
num_retrieve_miss     = %lu
num_hash_comps        = %lu
node %6u -> %3u
%lu nodes used out of %u
%lu items
load %d.%02d  actual load %d.%02d
../deps/openssl/openssl/crypto/lhash/lhash.c
../deps/openssl/openssl/crypto/mem.c
../deps/openssl/openssl/crypto/mem_dbg.c
%ld bytes leaked in %d chunks
[%02d:%02d:%02d] 
%5lu file=%s, line=%d, 
thread=%lu, 
number=%d, address=%08lX
 thread=%lu, file=%s, line=%d, info="
../deps/openssl/openssl/crypto/modes/gcm128.c
../deps/openssl/openssl/crypto/o_fips.c
../deps/openssl/openssl/crypto/objects/o_names.c
../deps/openssl/openssl/crypto/objects/obj_dat.c
.%lu
UNDEF
undefined
rsadsi
RSA Data Security, Inc.
pkcs
RSA Data Security, Inc. PKCS
rsaEncryption
RSA-MD2
md2WithRSAEncryption
RSA-MD5
md5WithRSAEncryption
PBE-MD2-DES
pbeWithMD2AndDES-CBC
PBE-MD5-DES
pbeWithMD5AndDES-CBC
X500
directory services (X.500)
commonName
countryName
localityName
stateOrProvinceName
organizationName
organizationalUnitName
pkcs7
pkcs7-data
pkcs7-signedData
pkcs7-envelopedData
pkcs7-signedAndEnvelopedData
pkcs7-digestData
pkcs7-encryptedData
pkcs3
dhKeyAgreement
DES-ECB
des-ecb
DES-CFB
des-cfb
des-cbc
DES-EDE
des-ede
DES-EDE3
des-ede3
idea-cbc
IDEA-CFB
idea-cfb
IDEA-ECB
idea-ecb
rc2-cbc
RC2-ECB
rc2-ecb
RC2-CFB
rc2-cfb
RC2-OFB
rc2-ofb
RSA-SHA
shaWithRSAEncryption
DES-EDE-CBC
des-ede-cbc
des-ede3-cbc
DES-OFB
des-ofb
IDEA-OFB
idea-ofb
pkcs9
emailAddress
unstructuredName
messageDigest
signingTime
countersignature
challengePassword
unstructuredAddress
extendedCertificateAttributes
Netscape
Netscape Communications Corp.
nsCertExt
Netscape Certificate Extension
nsDataType
Netscape Data Type
DES-EDE-CFB
des-ede-cfb
DES-EDE3-CFB
des-ede3-cfb
DES-EDE-OFB
des-ede-ofb
DES-EDE3-OFB
des-ede3-ofb
sha1WithRSAEncryption
DSA-SHA
dsaWithSHA
DSA-old
dsaEncryption-old
PBE-SHA1-RC2-64
pbeWithSHA1AndRC2-CBC
dsaWithSHA1-old
nsCertType
Netscape Cert Type
nsBaseUrl
Netscape Base Url
nsRevocationUrl
Netscape Revocation Url
nsCaRevocationUrl
Netscape CA Revocation Url
nsRenewalUrl
Netscape Renewal Url
nsCaPolicyUrl
Netscape CA Policy Url
nsSslServerName
Netscape SSL Server Name
nsComment
Netscape Comment
nsCertSequence
Netscape Certificate Sequence
desx-cbc
id-ce
X509v3 Subject Key Identifier
keyUsage
X509v3 Key Usage
privateKeyUsagePeriod
X509v3 Private Key Usage Period
subjectAltName
X509v3 Subject Alternative Name
issuerAltName
X509v3 Issuer Alternative Name
basicConstraints
X509v3 Basic Constraints
crlNumber
X509v3 CRL Number
certificatePolicies
X509v3 Certificate Policies
authorityKeyIdentifier
X509v3 Authority Key Identifier
bf-cbc
BF-ECB
bf-ecb
BF-CFB
bf-cfb
BF-OFB
bf-ofb
MDC2
mdc2
RSA-MDC2
mdc2WithRSA
RC4-40
rc4-40
RC2-40-CBC
rc2-40-cbc
givenName
surname
initials
crlDistributionPoints
X509v3 CRL Distribution Points
RSA-NP-MD5
md5WithRSA
description
cast5-cbc
CAST5-ECB
cast5-ecb
CAST5-CFB
cast5-cfb
CAST5-OFB
cast5-ofb
pbeWithMD5AndCast5CBC
dsaWithSHA1
MD5-SHA1
md5-sha1
sha1WithRSA
dsaEncryption
ripemd160
RSA-RIPEMD160
ripemd160WithRSA
RC5-CBC
rc5-cbc
RC5-ECB
rc5-ecb
RC5-CFB
rc5-cfb
RC5-OFB
rc5-ofb
ZLIB
zlib compression
extendedKeyUsage
X509v3 Extended Key Usage
PKIX
id-kp
serverAuth
TLS Web Server Authentication
clientAuth
TLS Web Client Authentication
codeSigning
Code Signing
emailProtection
E-mail Protection
timeStamping
Time Stamping
msCodeInd
Microsoft Individual Code Signing
msCodeCom
Microsoft Commercial Code Signing
msCTLSign
Microsoft Trust List Signing
msSGC
Microsoft Server Gated Crypto
msEFS
Microsoft Encrypted File System
nsSGC
Netscape Server Gated Crypto
deltaCRL
X509v3 Delta CRL Indicator
CRLReason
X509v3 CRL Reason Code
invalidityDate
Invalidity Date
SXNetID
Strong Extranet ID
PBE-SHA1-RC4-128
pbeWithSHA1And128BitRC4
PBE-SHA1-RC4-40
pbeWithSHA1And40BitRC4
PBE-SHA1-3DES
pbeWithSHA1And3-KeyTripleDES-CBC
PBE-SHA1-2DES
pbeWithSHA1And2-KeyTripleDES-CBC
PBE-SHA1-RC2-128
pbeWithSHA1And128BitRC2-CBC
PBE-SHA1-RC2-40
pbeWithSHA1And40BitRC2-CBC
keyBag
pkcs8ShroudedKeyBag
certBag
crlBag
secretBag
safeContentsBag
friendlyName
localKeyID
x509Certificate
sdsiCertificate
x509Crl
PBES2
PBMAC1
hmacWithSHA1
id-qt-cps
Policy Qualifier CPS
id-qt-unotice
Policy Qualifier User Notice
RC2-64-CBC
rc2-64-cbc
SMIME-CAPS
S/MIME Capabilities
PBE-MD2-RC2-64
pbeWithMD2AndRC2-CBC
PBE-MD5-RC2-64
pbeWithMD5AndRC2-CBC
PBE-SHA1-DES
pbeWithSHA1AndDES-CBC
msExtReq
Microsoft Extension Request
extReq
Extension Request
name
dnQualifier
id-pe
id-ad
authorityInfoAccess
Authority Information Access
OCSP
caIssuers
CA Issuers
OCSPSigning
OCSP Signing
member-body
ISO Member Body
ISO-US
ISO US Member Body
X9-57
X9.57
X9cm
X9.57 CM ?
pkcs1
pkcs5
SMIME
S/MIME
id-smime-mod
id-smime-ct
id-smime-aa
id-smime-alg
id-smime-cd
id-smime-spq
id-smime-cti
id-smime-mod-cms
id-smime-mod-ess
id-smime-mod-oid
id-smime-mod-msg-v3
id-smime-mod-ets-eSignature-88
id-smime-mod-ets-eSignature-97
id-smime-mod-ets-eSigPolicy-88
id-smime-mod-ets-eSigPolicy-97
id-smime-ct-receipt
id-smime-ct-authData
id-smime-ct-publishCert
id-smime-ct-TSTInfo
id-smime-ct-TDTInfo
id-smime-ct-contentInfo
id-smime-ct-DVCSRequestData
id-smime-ct-DVCSResponseData
id-smime-aa-receiptRequest
id-smime-aa-securityLabel
id-smime-aa-mlExpandHistory
id-smime-aa-contentHint
id-smime-aa-msgSigDigest
id-smime-aa-encapContentType
id-smime-aa-contentIdentifier
id-smime-aa-macValue
id-smime-aa-equivalentLabels
id-smime-aa-contentReference
id-smime-aa-encrypKeyPref
id-smime-aa-signingCertificate
id-smime-aa-smimeEncryptCerts
id-smime-aa-timeStampToken
id-smime-aa-ets-sigPolicyId
id-smime-aa-ets-commitmentType
id-smime-aa-ets-signerLocation
id-smime-aa-ets-signerAttr
id-smime-aa-ets-otherSigCert
id-smime-aa-ets-contentTimestamp
id-smime-aa-ets-CertificateRefs
id-smime-aa-ets-RevocationRefs
id-smime-aa-ets-certValues
id-smime-aa-ets-revocationValues
id-smime-aa-ets-escTimeStamp
id-smime-aa-ets-certCRLTimestamp
id-smime-aa-ets-archiveTimeStamp
id-smime-aa-signatureType
id-smime-aa-dvcs-dvc
id-smime-alg-ESDHwith3DES
id-smime-alg-ESDHwithRC2
id-smime-alg-3DESwrap
id-smime-alg-RC2wrap
id-smime-alg-ESDH
id-smime-alg-CMS3DESwrap
id-smime-alg-CMSRC2wrap
id-smime-cd-ldap
id-smime-spq-ets-sqt-uri
id-smime-spq-ets-sqt-unotice
id-smime-cti-ets-proofOfOrigin
id-smime-cti-ets-proofOfReceipt
id-smime-cti-ets-proofOfDelivery
id-smime-cti-ets-proofOfSender
id-smime-cti-ets-proofOfApproval
id-smime-cti-ets-proofOfCreation
id-pkix-mod
id-qt
id-it
id-pkip
id-alg
id-cmc
id-on
id-pda
id-aca
id-qcs
id-cct
id-pkix1-explicit-88
id-pkix1-implicit-88
id-pkix1-explicit-93
id-pkix1-implicit-93
id-mod-crmf
id-mod-cmc
id-mod-kea-profile-88
id-mod-kea-profile-93
id-mod-cmp
id-mod-qualified-cert-88
id-mod-qualified-cert-93
id-mod-attribute-cert
id-mod-timestamp-protocol
id-mod-ocsp
id-mod-dvcs
id-mod-cmp2000
biometricInfo
Biometric Info
qcStatements
ac-auditEntity
ac-targeting
aaControls
sbgp-ipAddrBlock
sbgp-autonomousSysNum
sbgp-routerIdentifier
textNotice
ipsecEndSystem
IPSec End System
ipsecTunnel
IPSec Tunnel
ipsecUser
IPSec User
DVCS
dvcs
id-it-caProtEncCert
id-it-signKeyPairTypes
id-it-encKeyPairTypes
id-it-preferredSymmAlg
id-it-caKeyUpdateInfo
id-it-currentCRL
id-it-unsupportedOIDs
id-it-subscriptionRequest
id-it-subscriptionResponse
id-it-keyPairParamReq
id-it-keyPairParamRep
id-it-revPassphrase
id-it-implicitConfirm
id-it-confirmWaitTime
id-it-origPKIMessage
id-regCtrl
id-regInfo
id-regCtrl-regToken
id-regCtrl-authenticator
id-regCtrl-pkiPublicationInfo
id-regCtrl-pkiArchiveOptions
id-regCtrl-oldCertID
id-regCtrl-protocolEncrKey
id-regInfo-utf8Pairs
id-regInfo-certReq
id-alg-des40
id-alg-noSignature
id-alg-dh-sig-hmac-sha1
id-alg-dh-pop
id-cmc-statusInfo
id-cmc-identification
id-cmc-identityProof
id-cmc-dataReturn
id-cmc-transactionId
id-cmc-senderNonce
id-cmc-recipientNonce
id-cmc-addExtensions
id-cmc-encryptedPOP
id-cmc-decryptedPOP
id-cmc-lraPOPWitness
id-cmc-getCert
id-cmc-getCRL
id-cmc-revokeRequest
id-cmc-regInfo
id-cmc-responseInfo
id-cmc-queryPending
id-cmc-popLinkRandom
id-cmc-popLinkWitness
id-cmc-confirmCertAcceptance
id-on-personalData
id-pda-dateOfBirth
id-pda-placeOfBirth
id-pda-gender
id-pda-countryOfCitizenship
id-pda-countryOfResidence
id-aca-authenticationInfo
id-aca-accessIdentity
id-aca-chargingIdentity
id-aca-group
id-aca-role
id-qcs-pkixQCSyntax-v1
id-cct-crs
id-cct-PKIData
id-cct-PKIResponse
ad_timestamping
AD Time Stamping
AD_DVCS
ad dvcs
basicOCSPResponse
Basic OCSP Response
Nonce
OCSP Nonce
CrlID
OCSP CRL ID
acceptableResponses
Acceptable OCSP Responses
noCheck
OCSP No Check
archiveCutoff
OCSP Archive Cutoff
serviceLocator
OCSP Service Locator
extendedStatus
Extended OCSP Status
valid
trustRoot
Trust Root
rsaSignature
X500algorithms
directory services - algorithms
IANA
iana
directory
Directory
mgmt
Management
experimental
Experimental
private
Private
security
Security
snmpv2
SNMPv2
Mail
enterprises
Enterprises
dcobject
dcObject
domainComponent
domain
Domain
selected-attribute-types
Selected Attribute Types
clearance
RSA-MD4
md4WithRSAEncryption
ac-proxying
subjectInfoAccess
Subject Information Access
id-aca-encAttrs
role
policyConstraints
X509v3 Policy Constraints
targetInformation
X509v3 AC Targeting
noRevAvail
X509v3 No Revocation Available
ansi-X9-62
ANSI X9.62
prime-field
characteristic-two-field
id-ecPublicKey
prime192v1
prime192v2
prime192v3
prime239v1
prime239v2
prime239v3
prime256v1
ecdsa-with-SHA1
CSPName
Microsoft CSP Name
AES-128-ECB
aes-128-ecb
aes-128-cbc
AES-128-OFB
aes-128-ofb
AES-128-CFB
aes-128-cfb
AES-192-ECB
aes-192-ecb
aes-192-cbc
AES-192-OFB
aes-192-ofb
AES-192-CFB
aes-192-cfb
AES-256-ECB
aes-256-ecb
aes-256-cbc
AES-256-OFB
aes-256-ofb
AES-256-CFB
aes-256-cfb
holdInstructionCode
Hold Instruction Code
holdInstructionNone
Hold Instruction None
holdInstructionCallIssuer
Hold Instruction Call Issuer
holdInstructionReject
Hold Instruction Reject
pilot
pilotAttributeType
pilotAttributeSyntax
pilotObjectClass
pilotGroups
iA5StringSyntax
caseIgnoreIA5StringSyntax
pilotObject
pilotPerson
account
document
room
documentSeries
rFC822localPart
dNSDomain
domainRelatedObject
friendlyCountry
simpleSecurityObject
pilotOrganization
pilotDSA
qualityLabelledData
userId
textEncodedORAddress
mail
rfc822Mailbox
info
favouriteDrink
roomNumber
photo
userClass
host
manager
documentIdentifier
documentTitle
documentVersion
documentAuthor
documentLocation
homeTelephoneNumber
secretary
otherMailbox
lastModifiedTime
lastModifiedBy
aRecord
pilotAttributeType27
mXRecord
nSRecord
sOARecord
cNAMERecord
associatedDomain
associatedName
homePostalAddress
personalTitle
mobileTelephoneNumber
pagerTelephoneNumber
friendlyCountryName
organizationalStatus
janetMailbox
mailPreferenceOption
buildingName
dSAQuality
singleLevelQuality
subtreeMinimumQuality
subtreeMaximumQuality
personalSignature
dITRedirect
audio
documentPublisher
x500UniqueIdentifier
mime-mhs
MIME MHS
mime-mhs-headings
mime-mhs-bodies
id-hex-partial-message
id-hex-multipart-message
generationQualifier
pseudonym
id-set
Secure Electronic Transactions
set-ctype
content types
set-msgExt
message extensions
set-attr
set-policy
set-certExt
certificate extensions
set-brand
setct-PANData
setct-PANToken
setct-PANOnly
setct-OIData
setct-PI
setct-PIData
setct-PIDataUnsigned
setct-HODInput
setct-AuthResBaggage
setct-AuthRevReqBaggage
setct-AuthRevResBaggage
setct-CapTokenSeq
setct-PInitResData
setct-PI-TBS
setct-PResData
setct-AuthReqTBS
setct-AuthResTBS
setct-AuthResTBSX
setct-AuthTokenTBS
setct-CapTokenData
setct-CapTokenTBS
setct-AcqCardCodeMsg
setct-AuthRevReqTBS
setct-AuthRevResData
setct-AuthRevResTBS
setct-CapReqTBS
setct-CapReqTBSX
setct-CapResData
setct-CapRevReqTBS
setct-CapRevReqTBSX
setct-CapRevResData
setct-CredReqTBS
setct-CredReqTBSX
setct-CredResData
setct-CredRevReqTBS
setct-CredRevReqTBSX
setct-CredRevResData
setct-PCertReqData
setct-PCertResTBS
setct-BatchAdminReqData
setct-BatchAdminResData
setct-CardCInitResTBS
setct-MeAqCInitResTBS
setct-RegFormResTBS
setct-CertReqData
setct-CertReqTBS
setct-CertResData
setct-CertInqReqTBS
setct-ErrorTBS
setct-PIDualSignedTBE
setct-PIUnsignedTBE
setct-AuthReqTBE
setct-AuthResTBE
setct-AuthResTBEX
setct-AuthTokenTBE
setct-CapTokenTBE
setct-CapTokenTBEX
setct-AcqCardCodeMsgTBE
setct-AuthRevReqTBE
setct-AuthRevResTBE
setct-AuthRevResTBEB
setct-CapReqTBE
setct-CapReqTBEX
setct-CapResTBE
setct-CapRevReqTBE
setct-CapRevReqTBEX
setct-CapRevResTBE
setct-CredReqTBE
setct-CredReqTBEX
setct-CredResTBE
setct-CredRevReqTBE
setct-CredRevReqTBEX
setct-CredRevResTBE
setct-BatchAdminReqTBE
setct-BatchAdminResTBE
setct-RegFormReqTBE
setct-CertReqTBE
setct-CertReqTBEX
setct-CertResTBE
setct-CRLNotificationTBS
setct-CRLNotificationResTBS
setct-BCIDistributionTBS
setext-genCrypt
generic cryptogram
setext-miAuth
merchant initiated auth
setext-pinSecure
setext-pinAny
setext-track2
setext-cv
additional verification
set-policy-root
setCext-hashedRoot
setCext-certType
setCext-merchData
setCext-cCertRequired
setCext-tunneling
setCext-setExt
setCext-setQualf
setCext-PGWYcapabilities
setCext-TokenIdentifier
setCext-Track2Data
setCext-TokenType
setCext-IssuerCapabilities
setAttr-Cert
setAttr-PGWYcap
payment gateway capabilities
setAttr-TokenType
setAttr-IssCap
issuer capabilities
set-rootKeyThumb
set-addPolicy
setAttr-Token-EMV
setAttr-Token-B0Prime
setAttr-IssCap-CVM
setAttr-IssCap-T2
setAttr-IssCap-Sig
setAttr-GenCryptgrm
generate cryptogram
setAttr-T2Enc
encrypted track 2
setAttr-T2cleartxt
cleartext track 2
setAttr-TokICCsig
ICC or token signature
setAttr-SecDevSig
secure device signature
set-brand-IATA-ATA
set-brand-Diners
set-brand-AmericanExpress
set-brand-JCB
set-brand-Visa
set-brand-MasterCard
set-brand-Novus
DES-CDMF
des-cdmf
rsaOAEPEncryptionSET
ITU-T
itu-t
JOINT-ISO-ITU-T
joint-iso-itu-t
international-organizations
International Organizations
msSmartcardLogin
Microsoft Smartcardlogin
msUPN
Microsoft Universal Principal Name
AES-128-CFB1
aes-128-cfb1
AES-192-CFB1
aes-192-cfb1
AES-256-CFB1
aes-256-cfb1
AES-128-CFB8
aes-128-cfb8
AES-192-CFB8
aes-192-cfb8
AES-256-CFB8
aes-256-cfb8
DES-CFB1
des-cfb1
DES-CFB8
des-cfb8
DES-EDE3-CFB1
des-ede3-cfb1
DES-EDE3-CFB8
des-ede3-cfb8
street
streetAddress
postalCode
id-ppl
proxyCertInfo
Proxy Certificate Information
id-ppl-anyLanguage
Any language
id-ppl-inheritAll
Inherit all
nameConstraints
X509v3 Name Constraints
id-ppl-independent
Independent
RSA-SHA256
sha256WithRSAEncryption
RSA-SHA384
sha384WithRSAEncryption
RSA-SHA512
sha512WithRSAEncryption
RSA-SHA224
sha224WithRSAEncryption
sha256
sha384
SHA512
sha512
SHA224
sha224
identified-organization
certicom-arc
wap-wsg
id-characteristic-two-basis
onBasis
tpBasis
ppBasis
c2pnb163v1
c2pnb163v2
c2pnb163v3
c2pnb176v1
c2tnb191v1
c2tnb191v2
c2tnb191v3
c2onb191v4
c2onb191v5
c2pnb208w1
c2tnb239v1
c2tnb239v2
c2tnb239v3
c2onb239v4
c2onb239v5
c2pnb272w1
c2pnb304w1
c2tnb359v1
c2pnb368w1
c2tnb431r1
secp112r1
secp112r2
secp128r1
secp128r2
secp160k1
secp160r1
secp160r2
secp192k1
secp224k1
secp224r1
secp256k1
secp384r1
secp521r1
sect113r1
sect113r2
sect131r1
sect131r2
sect163k1
sect163r1
sect163r2
sect193r1
sect193r2
sect233k1
sect233r1
sect239k1
sect283k1
sect283r1
sect409k1
sect409r1
sect571k1
sect571r1
wap-wsg-idm-ecid-wtls1
wap-wsg-idm-ecid-wtls3
wap-wsg-idm-ecid-wtls4
wap-wsg-idm-ecid-wtls5
wap-wsg-idm-ecid-wtls6
wap-wsg-idm-ecid-wtls7
wap-wsg-idm-ecid-wtls8
wap-wsg-idm-ecid-wtls9
wap-wsg-idm-ecid-wtls10
wap-wsg-idm-ecid-wtls11
wap-wsg-idm-ecid-wtls12
anyPolicy
X509v3 Any Policy
policyMappings
X509v3 Policy Mappings
inhibitAnyPolicy
X509v3 Inhibit Any Policy
Oakley-EC2N-3
ipsec3
Oakley-EC2N-4
ipsec4
camellia-128-cbc
camellia-192-cbc
camellia-256-cbc
CAMELLIA-128-ECB
camellia-128-ecb
CAMELLIA-192-ECB
camellia-192-ecb
CAMELLIA-256-ECB
camellia-256-ecb
CAMELLIA-128-CFB
camellia-128-cfb
CAMELLIA-192-CFB
camellia-192-cfb
CAMELLIA-256-CFB
camellia-256-cfb
CAMELLIA-128-CFB1
camellia-128-cfb1
CAMELLIA-192-CFB1
camellia-192-cfb1
CAMELLIA-256-CFB1
camellia-256-cfb1
CAMELLIA-128-CFB8
camellia-128-cfb8
CAMELLIA-192-CFB8
camellia-192-cfb8
CAMELLIA-256-CFB8
camellia-256-cfb8
CAMELLIA-128-OFB
camellia-128-ofb
CAMELLIA-192-OFB
camellia-192-ofb
CAMELLIA-256-OFB
camellia-256-ofb
subjectDirectoryAttributes
X509v3 Subject Directory Attributes
issuingDistributionPoint
X509v3 Issuing Distrubution Point
certificateIssuer
X509v3 Certificate Issuer
KISA
kisa
SEED-ECB
seed-ecb
seed-cbc
SEED-OFB
seed-ofb
SEED-CFB
seed-cfb
HMAC-MD5
hmac-md5
HMAC-SHA1
hmac-sha1
id-PasswordBasedMAC
password based MAC
id-DHBasedMac
Diffie-Hellman based MAC
id-it-suppLangTags
caRepository
CA Repository
id-smime-ct-compressedData
id-ct-asciiTextWithCRLF
id-aes128-wrap
id-aes192-wrap
id-aes256-wrap
ecdsa-with-Recommended
ecdsa-with-Specified
ecdsa-with-SHA224
ecdsa-with-SHA256
ecdsa-with-SHA384
ecdsa-with-SHA512
hmacWithMD5
hmacWithSHA224
hmacWithSHA256
hmacWithSHA384
hmacWithSHA512
dsa_with_SHA224
dsa_with_SHA256
whirlpool
cryptopro
cryptocom
id-GostR3411-94-with-GostR3410-2001
GOST R 34.11-94 with GOST R 34.10-2001
id-GostR3411-94-with-GostR3410-94
GOST R 34.11-94 with GOST R 34.10-94
GOST R 34.11-94
id-HMACGostR3411-94
HMAC GOST 34.11-94
GOST R 34.10-2001
GOST R 34.10-94
gost89
GOST 28147-89
GOST 28147-89 MAC
prf-gostr3411-94
GOST R 34.11-94 PRF
id-GostR3410-2001DH
GOST R 34.10-2001 DH
id-GostR3410-94DH
GOST R 34.10-94 DH
id-Gost28147-89-CryptoPro-KeyMeshing
id-Gost28147-89-None-KeyMeshing
id-GostR3411-94-TestParamSet
id-GostR3411-94-CryptoProParamSet
id-Gost28147-89-TestParamSet
id-Gost28147-89-CryptoPro-A-ParamSet
id-Gost28147-89-CryptoPro-B-ParamSet
id-Gost28147-89-CryptoPro-C-ParamSet
id-Gost28147-89-CryptoPro-D-ParamSet
id-Gost28147-89-CryptoPro-Oscar-1-1-ParamSet
id-Gost28147-89-CryptoPro-Oscar-1-0-ParamSet
id-Gost28147-89-CryptoPro-RIC-1-ParamSet
id-GostR3410-94-TestParamSet
id-GostR3410-94-CryptoPro-A-ParamSet
id-GostR3410-94-CryptoPro-B-ParamSet
id-GostR3410-94-CryptoPro-C-ParamSet
id-GostR3410-94-CryptoPro-D-ParamSet
id-GostR3410-94-CryptoPro-XchA-ParamSet
id-GostR3410-94-CryptoPro-XchB-ParamSet
id-GostR3410-94-CryptoPro-XchC-ParamSet
id-GostR3410-2001-TestParamSet
id-GostR3410-2001-CryptoPro-A-ParamSet
id-GostR3410-2001-CryptoPro-B-ParamSet
id-GostR3410-2001-CryptoPro-C-ParamSet
id-GostR3410-2001-CryptoPro-XchA-ParamSet
id-GostR3410-2001-CryptoPro-XchB-ParamSet
id-GostR3410-94-a
id-GostR3410-94-aBis
id-GostR3410-94-b
id-GostR3410-94-bBis
id-Gost28147-89-cc
GOST 28147-89 Cryptocom ParamSet
gost94cc
GOST 34.10-94 Cryptocom
gost2001cc
GOST 34.10-2001 Cryptocom
id-GostR3411-94-with-GostR3410-94-cc
GOST R 34.11-94 with GOST R 34.10-94 Cryptocom
id-GostR3411-94-with-GostR3410-2001-cc
GOST R 34.11-94 with GOST R 34.10-2001 Cryptocom
id-GostR3410-2001-ParamSet-cc
GOST R 3410-2001 Parameter Set Cryptocom
hmac
LocalKeySet
Microsoft Local Key set
freshestCRL
X509v3 Freshest CRL
id-on-permanentIdentifier
Permanent Identifier
searchGuide
businessCategory
postalAddress
postOfficeBox
physicalDeliveryOfficeName
telephoneNumber
telexNumber
teletexTerminalIdentifier
facsimileTelephoneNumber
x121Address
internationaliSDNNumber
registeredAddress
destinationIndicator
preferredDeliveryMethod
presentationAddress
supportedApplicationContext
member
roleOccupant
seeAlso
userPassword
userCertificate
cACertificate
authorityRevocationList
certificateRevocationList
crossCertificatePair
enhancedSearchGuide
protocolInformation
distinguishedName
uniqueMember
houseIdentifier
supportedAlgorithms
deltaRevocationList
dmdName
id-alg-PWRI-KEK
cmac
aes-128-gcm
id-aes128-CCM
aes-128-ccm
id-aes128-wrap-pad
id-aes192-GCM
aes-192-gcm
id-aes192-CCM
aes-192-ccm
id-aes192-wrap-pad
aes-256-gcm
id-aes256-CCM
aes-256-ccm
id-aes256-wrap-pad
AES-128-CTR
aes-128-ctr
AES-192-CTR
aes-192-ctr
AES-256-CTR
aes-256-ctr
id-camellia128-wrap
id-camellia192-wrap
id-camellia256-wrap
anyExtendedKeyUsage
Any Extended Key Usage
MGF1
mgf1
RSASSA-PSS
rsassaPss
AES-128-XTS
aes-128-xts
AES-256-XTS
aes-256-xts
rc4-hmac-md5
aes-128-cbc-hmac-sha1
AES-192-CBC-HMAC-SHA1
aes-192-cbc-hmac-sha1
aes-256-cbc-hmac-sha1
RSAES-OAEP
rsaesOaep
dhpublicnumber
brainpoolP160r1
brainpoolP160t1
brainpoolP192r1
brainpoolP192t1
brainpoolP224r1
brainpoolP224t1
brainpoolP256r1
brainpoolP256t1
brainpoolP320r1
brainpoolP320t1
brainpoolP384r1
brainpoolP384t1
brainpoolP512r1
brainpoolP512t1
PSPECIFIED
pSpecified
dhSinglePass-stdDH-sha1kdf-scheme
dhSinglePass-stdDH-sha224kdf-scheme
dhSinglePass-stdDH-sha256kdf-scheme
dhSinglePass-stdDH-sha384kdf-scheme
dhSinglePass-stdDH-sha512kdf-scheme
dhSinglePass-cofactorDH-sha1kdf-scheme
dhSinglePass-cofactorDH-sha224kdf-scheme
dhSinglePass-cofactorDH-sha256kdf-scheme
dhSinglePass-cofactorDH-sha384kdf-scheme
dhSinglePass-cofactorDH-sha512kdf-scheme
dh-std-kdf
dh-cofactor-kdf
aes-128-cbc-hmac-sha256
AES-192-CBC-HMAC-SHA256
aes-192-cbc-hmac-sha256
aes-256-cbc-hmac-sha256
ct_precert_scts
CT Precertificate SCTs
ct_precert_poison
CT Precertificate Poison
ct_precert_signer
CT Precertificate Signer
ct_cert_scts
CT Certificate SCTs
jurisdictionL
jurisdictionLocalityName
jurisdictionST
jurisdictionStateOrProvinceName
jurisdictionC
jurisdictionCountryName
OBJ_add_object
OBJ_create
OBJ_dup
OBJ_NAME_new_index
OBJ_nid2ln
OBJ_nid2obj
OBJ_nid2sn
unknown nid
../deps/openssl/openssl/crypto/objects/obj_lib.c
../deps/openssl/openssl/crypto/objects/obj_xref.c
OCSP_SIGNATURE
OCSP_CERTID
OCSP_ONEREQ
OCSP_REQINFO
OCSP_REQUEST
OCSP_RESPBYTES
OCSP_RESPONSE
OCSP_RESPID
OCSP_REVOKEDINFO
OCSP_CERTSTATUS
OCSP_SINGLERESP
OCSP_RESPDATA
OCSP_BASICRESP
OCSP_CRLID
OCSP_SERVICELOC
hashAlgorithm
issuerNameHash
issuerKeyHash
reqCert
singleRequestExtensions
requestorName
requestList
requestExtensions
tbsRequest
optionalSignature
responseType
response
responseStatus
responseBytes
value.byName
value.byKey
revocationTime
revocationReason
value.good
value.revoked
value.unknown
certId
certStatus
thisUpdate
singleExtensions
responderId
producedAt
responses
responseExtensions
tbsResponseData
crlUrl
crlNum
crlTime
locator
../deps/openssl/openssl/crypto/ocsp/ocsp_cl.c
ASN1_STRING_encode
D2I_OCSP_NONCE
OCSP_basic_add1_status
OCSP_basic_sign
OCSP_basic_verify
OCSP_cert_id_new
OCSP_CHECK_DELEGATED
OCSP_CHECK_IDS
OCSP_CHECK_ISSUER
OCSP_check_validity
OCSP_MATCH_ISSUERID
OCSP_parse_url
OCSP_request_sign
OCSP_request_verify
OCSP_response_get1_basic
OCSP_sendreq_bio
OCSP_sendreq_nbio
PARSE_HTTP_LINE1
REQUEST_VERIFY
digest err
error in nextupdate field
error in thisupdate field
error parsing url
missing ocspsigning usage
nextupdate before thisupdate
not basic response
no certificates in chain
no response data
no revoked time
request not signed
response contains no revocation data
root ca not trusted
server read error
server response error
server response parse error
server write error
signature failure
status expired
status not yet valid
status too old
unknown message digest
unsupported requestorname type
../deps/openssl/openssl/crypto/ocsp/ocsp_ext.c
../deps/openssl/openssl/crypto/ocsp/ocsp_ht.c
POST
Code=
,Reason=
../deps/openssl/openssl/crypto/ocsp/ocsp_lib.c
successful
malformedrequest
internalerror
trylater
sigrequired
unauthorized
good
unspecified
keyCompromise
cACompromise
affiliationChanged
superseded
cessationOfOperation
certificateHold
removeFromCRL
OCSP Request Data:
    Version: %lu (0x%lx)
    Requestor Name: 
    Requestor List:
Request Single Extensions
Request Extensions
OCSP Response Data:
    OCSP Response Status: %s (0x%lx)
    Response Type: 
 (unknown response type)
    Version: %lu (0x%lx)
    Responder Id: 
    Produced At: 
    Responses:
    Cert Status: %s
    Revocation Time: 
    Revocation Reason: %s (0x%lx)
    This Update: 
    Next Update: 
Response Single Extensions
Response Extensions
(UNKNOWN)
%*sCertificate ID:
%*sHash Algorithm: 
%*sIssuer Name Hash: 
%*sIssuer Key Hash: 
%*sSerial Number: 
../deps/openssl/openssl/crypto/ocsp/ocsp_srv.c
../deps/openssl/openssl/crypto/ocsp/ocsp_vfy.c
CERTIFICATE REQUEST
NEW CERTIFICATE REQUEST
X509 CRL
PKCS7
CERTIFICATE
RSA PRIVATE KEY
RSA PUBLIC KEY
PUBLIC KEY
DSA PRIVATE KEY
DSA PARAMETERS
EC PARAMETERS
EC PRIVATE KEY
B2I_DSS
b2i_PVK_bio
B2I_RSA
CHECK_BITLEN_DSA
CHECK_BITLEN_RSA
d2i_PKCS8PrivateKey_bio
d2i_PKCS8PrivateKey_fp
DO_B2I
DO_B2I_BIO
DO_BLOB_HEADER
DO_PK8PKEY
DO_PK8PKEY_FP
DO_PVK_BODY
DO_PVK_HEADER
I2B_PVK
i2b_PVK_bio
LOAD_IV
PEM_ASN1_read
PEM_ASN1_read_bio
PEM_ASN1_write
PEM_ASN1_write_bio
PEM_def_callback
PEM_do_header
PEM_F_PEM_WRITE_PKCS8PRIVATEKEY
PEM_get_EVP_CIPHER_INFO
PEM_PK8PKEY
PEM_read
PEM_read_bio
PEM_READ_BIO_DHPARAMS
PEM_read_bio_Parameters
PEM_READ_BIO_PRIVATEKEY
PEM_READ_DHPARAMS
PEM_READ_PRIVATEKEY
PEM_SealFinal
PEM_SealInit
PEM_SignFinal
PEM_write
PEM_write_bio
PEM_WRITE_PRIVATEKEY
PEM_X509_INFO_read
PEM_X509_INFO_read_bio
PEM_X509_INFO_write_bio
bad base64 decode
bad end line
bad iv chars
bad magic number
bad version number
bio write failure
cipher is null
error converting private key
expecting private key blob
expecting public key blob
inconsistent header
keyblob header parse error
keyblob too short
not dek info
not encrypted
not proc type
no start line
problems getting password
public key no rsa
pvk data too short
pvk too short
read key
short header
unsupported encryption
unsupported key components
../deps/openssl/openssl/crypto/pem/pem_info.c
TRUSTED CERTIFICATE
strlen(objstr) + 23 + 2 * enc->iv_len + 13 <= sizeof buf
Enter PEM pass phrase:
../deps/openssl/openssl/crypto/pem/pem_lib.c
phrase is too short, needs to be at least %d chars
ENCRYPTED
MIC-CLEAR
MIC-ONLY
BAD-TYPE
Proc-Type: 4,
0123456789ABCDEF
DEK-Info: 
Expecting: 
enc->iv_len <= (int)sizeof(iv)
Proc-Type: 
-----BEGIN 
-----
-----END 
ANY PRIVATE KEY
ENCRYPTED PRIVATE KEY
PRIVATE KEY
PARAMETERS
X9.42 DH PARAMETERS
DH PARAMETERS
X509 CERTIFICATE
PKCS #7 SIGNED DATA
../deps/openssl/openssl/crypto/pem/pem_oth.c
../deps/openssl/openssl/crypto/pem/pem_pk8.c
../deps/openssl/openssl/crypto/pem/pem_pkey.c
%s PRIVATE KEY
%s PARAMETERS
../deps/openssl/openssl/crypto/pem/pem_seal.c
../deps/openssl/openssl/crypto/pem/pem_sign.c
CERTIFICATE PAIR
../deps/openssl/openssl/crypto/pem/pvkfmt.c
../deps/openssl/openssl/crypto/pkcs12/p12_add.c
PKCS12
PKCS12_MAC_DATA
PKCS12_BAGS
PKCS12_SAFEBAG
PKCS12_SAFEBAGS
PKCS12_AUTHSAFES
authsafes
dinfo
value.x509cert
value.x509crl
value.sdsicert
value.other
attrib
value.keybag
value.shkeybag
value.safes
value.bag
../deps/openssl/openssl/crypto/pkcs12/p12_crpt.c
../deps/openssl/openssl/crypto/pkcs12/p12_crt.c
../deps/openssl/openssl/crypto/pkcs12/p12_decr.c
../deps/openssl/openssl/crypto/pkcs12/p12_init.c
../deps/openssl/openssl/crypto/pkcs12/p12_key.c
../deps/openssl/openssl/crypto/pkcs12/p12_kiss.c
../deps/openssl/openssl/crypto/pkcs12/p12_mutl.c
../deps/openssl/openssl/crypto/pkcs12/p12_npas.c
../deps/openssl/openssl/crypto/pkcs12/p12_p8e.c
../deps/openssl/openssl/crypto/pkcs12/p12_utl.c
PARSE_BAG
PARSE_BAGS
PKCS12_ADD_FRIENDLYNAME
PKCS12_add_friendlyname_asc
PKCS12_add_friendlyname_uni
PKCS12_add_localkeyid
PKCS12_create
PKCS12_gen_mac
PKCS12_init
PKCS12_item_decrypt_d2i
PKCS12_item_i2d_encrypt
PKCS12_item_pack_safebag
PKCS12_key_gen_asc
PKCS12_key_gen_uni
PKCS12_MAKE_KEYBAG
PKCS12_MAKE_SHKEYBAG
PKCS12_newpass
PKCS12_pack_p7data
PKCS12_pack_p7encdata
PKCS12_parse
PKCS12_pbe_crypt
PKCS12_PBE_keyivgen
PKCS12_setup_mac
PKCS12_set_mac
PKCS12_unpack_authsafes
PKCS12_unpack_p7data
PKCS12_verify_mac
PKCS8_add_keyusage
PKCS8_encrypt
cant pack structure
content type not data
encrypt error
error setting encrypted data type
invalid null argument
invalid null pkcs12 pointer
iv gen error
key gen error
mac absent
mac generation error
mac setup error
mac string set error
mac verify error
mac verify failure
parse error
pkcs12 algor cipherinit error
pkcs12 cipherfinal error
pkcs12 pbe crypt error
unknown digest algorithm
unsupported pkcs12 mode
PKCS7_SIGNED
PKCS7_SIGNER_INFO
PKCS7_ISSUER_AND_SERIAL
PKCS7_ENVELOPE
PKCS7_RECIP_INFO
PKCS7_ENC_CONTENT
PKCS7_SIGN_ENVELOPE
PKCS7_ENCRYPT
PKCS7_DIGEST
PKCS7_ATTR_SIGN
PKCS7_ATTR_VERIFY
d.sign
d.enveloped
d.signed_and_enveloped
d.digest
d.encrypted
md_algs
contents
signer_info
issuer_and_serial
digest_alg
auth_attr
digest_enc_alg
enc_digest
unauth_attr
serial
recipientinfo
enc_data
key_enc_algor
enc_key
content_type
PKCS7_ATTRIBUTES
../deps/openssl/openssl/crypto/pkcs7/pk7_attr.c
../deps/openssl/openssl/crypto/pkcs7/pk7_doit.c
../deps/openssl/openssl/crypto/pkcs7/pk7_lib.c
../deps/openssl/openssl/crypto/pkcs7/pk7_smime.c
B64_READ_PKCS7
B64_WRITE_PKCS7
DO_PKCS7_SIGNED_ATTRIB
i2d_PKCS7_bio_stream
PKCS7_add0_attrib_signing_time
PKCS7_add_attrib_smimecap
PKCS7_add_certificate
PKCS7_add_crl
PKCS7_add_recipient_info
PKCS7_add_signature
PKCS7_add_signer
PKCS7_BIO_ADD_DIGEST
PKCS7_COPY_EXISTING_DIGEST
PKCS7_ctrl
PKCS7_dataDecode
PKCS7_dataFinal
PKCS7_dataInit
PKCS7_DATASIGN
PKCS7_dataVerify
PKCS7_decrypt
PKCS7_DECRYPT_RINFO
PKCS7_ENCODE_RINFO
PKCS7_encrypt
PKCS7_final
PKCS7_FIND_DIGEST
PKCS7_get0_signers
PKCS7_RECIP_INFO_set
PKCS7_set_cipher
PKCS7_set_content
PKCS7_set_digest
PKCS7_set_type
PKCS7_sign
PKCS7_signatureVerify
PKCS7_SIGNER_INFO_set
PKCS7_SIGNER_INFO_sign
PKCS7_sign_add_signer
PKCS7_simple_smimecap
PKCS7_verify
SMIME_read_PKCS7
cipher not initialized
content and data present
decrypted key is wrong length
digest failure
encryption ctrl failure
encryption not supported for this key type
error adding recipient
error setting cipher
invalid null pointer
invalid signed data type
missing ceripend info
no matching digest type found
no recipient matches certificate
no recipient matches key
no signatures on data
operation not supported on this type
pkcs7 add signature error
pkcs7 add signer error
pkcs7 datafinal
pkcs7 datafinal error
pkcs7 datasign
pkcs7 parse error
pkcs7 sig parse error
signing ctrl failure
signing not supported for this key type
unable to find certificate
unable to find mem bio
unable to find message digest
unknown digest type
unknown operation
unsupported cipher type
wrong content type
wrong pkcs7 type
../deps/openssl/openssl/crypto/pqueue/pqueue.c
item
%02x%02x%02x%02x%02x%02x%02x%02x
../deps/openssl/openssl/crypto/rand/md_rand.c
....................
You need to read the OpenSSL FAQ, http://www.openssl.org/support/faq.html
RAND_get_rand_method
RAND_init_fips
SSLEAY_RAND_BYTES
dual ec drbg disabled
error initialising drbg
error instantiating drbg
no fips random method set
PRNG not seeded
/dev/urandom
/dev/random
/dev/srandom
/var/run/egd-pool
/dev/egd-pool
/etc/egd-pool
/etc/entropy
RANDFILE
HOME
.rnd
OpenSSL RSA method
../deps/openssl/openssl/crypto/rsa/rsa_ameth.c
Private-Key: (%d bit)
modulus:
publicExponent:
Public-Key: (%d bit)
Modulus:
Exponent:
privateExponent:
prime1:
prime2:
exponent1:
exponent2:
coefficient:
 (INVALID PSS PARAMETERS)
Hash Algorithm: 
sha1 (default)
Mask Algorithm: 
 with 
INVALID
mgf1 with sha1 (default)
Salt Length: 0x
14 (default)
Trailer Field: 0x
BC (default)
RSA_PSS_PARAMS
RSA_OAEP_PARAMS
dmp1
dmq1
iqmp
maskGenAlgorithm
saltLength
trailerField
hashFunc
maskGenFunc
pSourceFunc
../deps/openssl/openssl/crypto/rsa/rsa_chk.c
../deps/openssl/openssl/crypto/rsa/rsa_crpt.c
Eric Young's PKCS#1 RSA
../deps/openssl/openssl/crypto/rsa/rsa_eay.c
CHECK_PADDING_MD
DO_RSA_PRINT
INT_RSA_VERIFY
MEMORY_LOCK
OLD_RSA_PRIV_DECODE
PKEY_RSA_CTRL
PKEY_RSA_CTRL_STR
PKEY_RSA_SIGN
PKEY_RSA_VERIFY
PKEY_RSA_VERIFYRECOVER
RSA_ALGOR_TO_MD
RSA_BUILTIN_KEYGEN
RSA_check_key
RSA_CMS_DECRYPT
RSA_EAY_PRIVATE_DECRYPT
RSA_EAY_PRIVATE_ENCRYPT
RSA_EAY_PUBLIC_DECRYPT
RSA_EAY_PUBLIC_ENCRYPT
RSA_generate_key
RSA_generate_key_ex
RSA_ITEM_VERIFY
RSA_memory_lock
RSA_MGF1_TO_MD
RSA_new_method
RSA_NULL
RSA_NULL_MOD_EXP
RSA_NULL_PRIVATE_DECRYPT
RSA_NULL_PRIVATE_ENCRYPT
RSA_NULL_PUBLIC_DECRYPT
RSA_NULL_PUBLIC_ENCRYPT
RSA_padding_add_none
RSA_padding_add_PKCS1_OAEP
RSA_padding_add_PKCS1_OAEP_mgf1
RSA_padding_add_PKCS1_PSS
RSA_padding_add_PKCS1_PSS_mgf1
RSA_padding_add_PKCS1_type_1
RSA_padding_add_PKCS1_type_2
RSA_padding_add_SSLv23
RSA_padding_add_X931
RSA_padding_check_none
RSA_padding_check_PKCS1_OAEP
RSA_padding_check_PKCS1_OAEP_mgf1
RSA_padding_check_PKCS1_type_1
RSA_padding_check_PKCS1_type_2
RSA_padding_check_SSLv23
RSA_padding_check_X931
RSA_print
RSA_print_fp
RSA_private_decrypt
RSA_private_encrypt
RSA_PRIV_DECODE
RSA_PRIV_ENCODE
RSA_PSS_TO_CTX
RSA_public_decrypt
RSA_public_encrypt
RSA_PUB_DECODE
RSA_setup_blinding
RSA_sign
RSA_sign_ASN1_OCTET_STRING
RSA_verify
RSA_verify_ASN1_OCTET_STRING
RSA_verify_PKCS1_PSS
RSA_verify_PKCS1_PSS_mgf1
algorithm mismatch
bad e value
bad fixed header decrypt
bad pad byte count
block type is not 01
block type is not 02
data greater than mod len
data too large
data too large for modulus
data too small
data too small for key size
digest does not match
digest too big for rsa key
dmp1 not congruent to d
dmq1 not congruent to d
d e not congruent to 1
first octet invalid
illegal or unsupported padding mode
invalid digest length
invalid header
invalid keybits
invalid label
invalid message length
invalid mgf1 md
invalid oaep parameters
invalid padding
invalid padding mode
invalid pss parameters
invalid pss saltlen
invalid salt length
invalid trailer
invalid x931 digest
iqmp not inverse of q
last octet invalid
non fips rsa method
no public exponent
null before block missing
n does not equal p q
oaep decoding error
operation not allowed in fips mode
padding check failed
pkcs decoding error
p not prime
rsa operations not supported
salt length check failed
salt length recovery failed
sslv3 rollback attack
unknown algorithm type
unknown mask digest
unknown padding type
unknown pss digest
unsupported encryption type
unsupported label source
unsupported mask algorithm
unsupported mask parameter
unsupported signature type
value missing
../deps/openssl/openssl/crypto/rsa/rsa_gen.c
../deps/openssl/openssl/crypto/rsa/rsa_lib.c
../deps/openssl/openssl/crypto/rsa/rsa_none.c
Null RSA
../deps/openssl/openssl/crypto/rsa/rsa_null.c
../deps/openssl/openssl/crypto/rsa/rsa_oaep.c
../deps/openssl/openssl/crypto/rsa/rsa_pk1.c
../deps/openssl/openssl/crypto/rsa/rsa_pmeth.c
rsa_padding_mode
sslv23
none
oeap
oaep
x931
rsa_pss_saltlen
rsa_keygen_bits
rsa_keygen_pubexp
rsa_mgf1_md
rsa_oaep_md
rsa_oaep_label
../deps/openssl/openssl/crypto/rsa/rsa_prn.c
../deps/openssl/openssl/crypto/rsa/rsa_pss.c
../deps/openssl/openssl/crypto/rsa/rsa_saos.c
../deps/openssl/openssl/crypto/rsa/rsa_sign.c
../deps/openssl/openssl/crypto/rsa/rsa_ssl.c
../deps/openssl/openssl/crypto/rsa/rsa_x931.c
../deps/openssl/openssl/crypto/srp/srp_lib.c
8192
6144
4096
3072
2048
1536
1024
../deps/openssl/openssl/crypto/srp/srp_vfy.c
../deps/openssl/openssl/crypto/stack/stack.c
TS_MSG_IMPRINT
TS_REQ
TS_ACCURACY
TS_TST_INFO
TS_STATUS_INFO
TS_RESP
ESS_ISSUER_SERIAL
ESS_CERT_ID
ESS_SIGNING_CERT
../deps/openssl/openssl/crypto/ts/ts_asn1.c
hash_algo
hashed_msg
msg_imprint
policy_id
nonce
cert_req
seconds
millis
micros
time
accuracy
ordering
text
failure_info
status_info
token
hash
issuer_serial
cert_ids
policy_info
unable to load certificate: %s
unable to load certificates: %s
unable to load private key: %s
default_tsa
crypto_device
builtin
chil
../deps/openssl/openssl/crypto/ts/ts_conf.c
engine:
signer_cert
signer_key
default_policy
other_policies
digests
secs
millisecs
microsecs
clock_precision_digits
tsa_name
ess_cert_id_chain
variable lookup failed for %s::%s
invalid variable value for %s::%s
d2i_TS_RESP
DEF_SERIAL_CB
DEF_TIME_CB
ESS_ADD_SIGNING_CERT
ESS_CERT_ID_NEW_INIT
ESS_SIGNING_CERT_NEW_INIT
INT_TS_RESP_VERIFY_TOKEN
PKCS7_to_TS_TST_INFO
TS_ACCURACY_set_micros
TS_ACCURACY_set_millis
TS_ACCURACY_set_seconds
TS_CHECK_IMPRINTS
TS_CHECK_NONCES
TS_CHECK_POLICY
TS_CHECK_SIGNING_CERTS
TS_CHECK_STATUS_INFO
TS_COMPUTE_IMPRINT
TS_CONF_set_default_engine
TS_GET_STATUS_TEXT
TS_MSG_IMPRINT_set_algo
TS_REQ_set_msg_imprint
TS_REQ_set_nonce
TS_REQ_set_policy_id
TS_RESP_create_response
TS_RESP_CREATE_TST_INFO
TS_RESP_CTX_add_failure_info
TS_RESP_CTX_add_md
TS_RESP_CTX_add_policy
TS_RESP_CTX_new
TS_RESP_CTX_set_accuracy
TS_RESP_CTX_set_certs
TS_RESP_CTX_set_def_policy
TS_RESP_CTX_set_signer_cert
TS_RESP_CTX_set_status_info
TS_RESP_GET_POLICY
TS_RESP_SET_GENTIME_WITH_PRECISION
TS_RESP_set_status_info
TS_RESP_set_tst_info
TS_RESP_SIGN
TS_RESP_verify_signature
TS_RESP_verify_token
TS_TST_INFO_set_accuracy
TS_TST_INFO_set_msg_imprint
TS_TST_INFO_set_nonce
TS_TST_INFO_set_policy_id
TS_TST_INFO_set_serial
TS_TST_INFO_set_time
TS_TST_INFO_set_tsa
TS_VERIFY
TS_VERIFY_CERT
TS_VERIFY_CTX_new
bad pkcs7 type
bad type
could not set engine
could not set time
d2i ts resp int failed
detached content
ess add signing cert error
ess signing certificate error
invalid signer certificate purpose
message imprint mismatch
nonce mismatch
nonce not returned
no time stamp token
pkcs7 add signed attr error
pkcs7 to ts tst info failed
policy mismatch
response setup error
there must be one signer
time syscall error
token not present
token present
tsa name mismatch
tsa untrusted
tst info setup error
ts datasign
unacceptable policy
unsupported md algorithm
unsupported version
Extensions:
Hash Algorithm: %s
Message data:
Version: %d
Policy OID: 
unspecified
Nonce: 
Certificate required: %s
../deps/openssl/openssl/crypto/ts/ts_req_utils.c
Status info:
TST info:
Not included.
Granted.
Granted with modifications.
Rejected.
Waiting.
Revocation warning.
Revoked.
unrecognized or unsupported algorithm identifier
transaction not permitted or supported
the data submitted has the wrong format
the TSA's time source is not available
the requested TSA policy is not supported by the TSA
the requested extension is not supported by the TSA
the additional information requested could not be understood or is not available
the request cannot be handled due to system failure
Status: 
out of bounds
Status description: 
Failure info: 
Serial number: 
Time stamp: 
Accuracy: 
Ordering: %s
TSA: 
 seconds, 
 millis, 
 micros
../deps/openssl/openssl/crypto/ts/ts_rsp_sign.c
Bad request format or system error.
Error during response generation.
Error during serial number generation.
Time is not available.
Unsupported extension.
Bad request version.
Message digest algorithm is not supported.
Superfluous message digest parameter.
Bad message digest.
Requested policy is not supported.
Error during TSTInfo generation.
%04d%02d%02d%02d%02d%02d
.%06ld
Error during signature generation.
../deps/openssl/openssl/crypto/ts/ts_rsp_utils.c
../deps/openssl/openssl/crypto/ts/ts_rsp_verify.c
unknown code
status code: 
, status text: 
, failure codes: 
granted
grantedWithMods
rejection
waiting
revocationWarning
revocationNotification
badAlg
badRequest
badDataFormat
timeNotAvailable
unacceptedPolicy
unacceptedExtension
addInfoNotAvailable
systemFailure
../deps/openssl/openssl/crypto/ts/ts_verify_ctx.c
ctx != NULL
req != NULL
../deps/openssl/openssl/crypto/txt_db/txt_db.c
wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)
failure in sk_push
OPENSSL_malloc failure
GENERAL_ALLOCATE_BOOLEAN
GENERAL_ALLOCATE_PROMPT
GENERAL_ALLOCATE_STRING
UI_ctrl
UI_dup_error_string
UI_dup_info_string
UI_dup_input_boolean
UI_dup_input_string
UI_dup_verify_string
UI_get0_result
UI_new_method
UI_set_result
common ok and cancel characters
index too large
index too small
no result buffer
result too large
result too small
unknown control command
../deps/openssl/openssl/crypto/ui/ui_lib.c
Enter 
 for 
You must type in 
 to 
 characters
OpenSSL default user interface
../deps/openssl/openssl/crypto/ui/ui_openssl.c
/dev/tty
Verifying - %s
Verify failure
Load certs from files in a directory
../deps/openssl/openssl/crypto/x509/by_dir.c
%s%c%08lx.%s%d
Load file into cache
../deps/openssl/openssl/crypto/x509/by_file.c
../deps/openssl/openssl/crypto/x509/x509_att.c
../deps/openssl/openssl/crypto/x509/x509_cmp.c
/System/Library/OpenSSL//private
/System/Library/OpenSSL/
/System/Library/OpenSSL//certs
/System/Library/OpenSSL//cert.pem
SSL_CERT_DIR
SSL_CERT_FILE
ADD_CERT_DIR
BY_FILE_CTRL
CHECK_POLICY
DIR_CTRL
GET_CERT_BY_SUBJECT
NETSCAPE_SPKI_b64_decode
NETSCAPE_SPKI_b64_encode
X509at_add1_attr
X509v3_add_ext
X509_ATTRIBUTE_create_by_NID
X509_ATTRIBUTE_create_by_OBJ
X509_ATTRIBUTE_create_by_txt
X509_ATTRIBUTE_get0_data
X509_ATTRIBUTE_set1_data
X509_check_private_key
X509_CRL_diff
X509_CRL_print_fp
X509_EXTENSION_create_by_NID
X509_EXTENSION_create_by_OBJ
X509_get_pubkey_parameters
X509_load_cert_crl_file
X509_load_cert_file
X509_load_crl_file
X509_NAME_add_entry
X509_NAME_ENTRY_create_by_NID
X509_NAME_ENTRY_create_by_txt
X509_NAME_ENTRY_set_object
X509_NAME_oneline
X509_NAME_print
X509_print_ex_fp
X509_PUBKEY_get
X509_PUBKEY_set
X509_REQ_check_private_key
X509_REQ_print_ex
X509_REQ_print_fp
X509_REQ_to_X509
X509_STORE_add_cert
X509_STORE_add_crl
X509_STORE_CTX_get1_issuer
X509_STORE_CTX_init
X509_STORE_CTX_new
X509_STORE_CTX_purpose_inherit
X509_to_X509_REQ
X509_TRUST_add
X509_TRUST_set
X509_verify_cert
akid mismatch
bad x509 filetype
base64 decode error
cant check dh key
cert already in hash table
crl already delta
crl verify failure
err asn1 lib
idp mismatch
invalid directory
invalid field name
issuer mismatch
key type mismatch
key values mismatch
loading cert dir
loading defaults
name too long
newer crl not newer
no cert set for us to verify
no crl number
public key decode error
public key encode error
should retry
unable to find parameters in chain
unable to get certs public key
unknown key type
unknown purpose id
unknown trust id
wrong lookup type
../deps/openssl/openssl/crypto/x509/x509_lu.c
0123456789ABCDEF
NO X509_NAME
../deps/openssl/openssl/crypto/x509/x509_obj.c
../deps/openssl/openssl/crypto/x509/x509_r2x.c
../deps/openssl/openssl/crypto/x509/x509_req.c
../deps/openssl/openssl/crypto/x509/x509_trs.c
compatible
SSL Client
SSL Server
S/MIME email
Object Signer
OCSP responder
OCSP request
TSA server
unable to get issuer certificate
unable to get certificate CRL
unable to decrypt certificate's signature
unable to decrypt CRL's signature
unable to decode issuer public key
certificate signature failure
CRL signature failure
certificate is not yet valid
CRL is not yet valid
certificate has expired
CRL has expired
format error in certificate's notBefore field
format error in certificate's notAfter field
format error in CRL's lastUpdate field
format error in CRL's nextUpdate field
out of memory
self signed certificate
self signed certificate in certificate chain
unable to get local issuer certificate
unable to verify the first certificate
certificate chain too long
invalid CA certificate
invalid non-CA certificate (has CA markings)
path length constraint exceeded
proxy path length constraint exceeded
proxy certificates not allowed, please set the appropriate flag
unsupported certificate purpose
certificate not trusted
certificate rejected
application verification failure
subject issuer mismatch
authority and subject key identifier mismatch
authority and issuer serial number mismatch
key usage does not include certificate signing
unable to get CRL issuer certificate
unhandled critical extension
key usage does not include CRL signing
key usage does not include digital signature
unhandled critical CRL extension
invalid or inconsistent certificate extension
invalid or inconsistent certificate policy extension
no explicit policy
Different CRL scope
Unsupported extension feature
RFC 3779 resource not subset of parent's resources
permitted subtree violation
excluded subtree violation
name constraints minimum and maximum not supported
unsupported name constraint type
unsupported or invalid name constraint syntax
unsupported or invalid name syntax
CRL path validation error
Suite B: certificate version invalid
Suite B: invalid public key algorithm
Suite B: invalid ECC curve
Suite B: invalid signature algorithm
Suite B: curve not allowed for this LOS
Suite B: cannot sign P-384 with P-256
Hostname mismatch
Email address mismatch
IP address mismatch
error number %ld
../deps/openssl/openssl/crypto/x509/x509_v3.c
../deps/openssl/openssl/crypto/x509/x509_vfy.c
OPENSSL_ALLOW_PROXY_CERTS
../deps/openssl/openssl/crypto/x509/x509_vpm.c
../deps/openssl/openssl/crypto/x509/x509name.c
../deps/openssl/openssl/crypto/x509/x509spki.c
../deps/openssl/openssl/crypto/x509v3/pcy_cache.c
../deps/openssl/openssl/crypto/x509v3/pcy_data.c
../deps/openssl/openssl/crypto/x509v3/pcy_node.c
../deps/openssl/openssl/crypto/x509v3/pcy_tree.c
always
../deps/openssl/openssl/crypto/x509v3/v3_akey.c
AUTHORITY_KEYID
othername
<unsupported>
X400Name
EdiPartyName
email
DirName
IP Address
<invalid>
Registered ID
othername:<unsupported>
X400Name:<unsupported>
EdiPartyName:<unsupported>
email:%s
DNS:%s
URI:%s
DirName: 
IP Address:%d.%d.%d.%d
IP Address:<invalid>
../deps/openssl/openssl/crypto/x509v3/v3_alt.c
value=
dirName
otherName
copy
move
BASIC_CONSTRAINTS
pathlen
../deps/openssl/openssl/crypto/x509v3/v3_bcons.c
section:
,value:
../deps/openssl/openssl/crypto/x509v3/v3_bitst.c
client
server
Object Signing
objsign
Unused
reserved
SSL CA
sslCA
S/MIME CA
emailCA
Object Signing CA
objCA
Digital Signature
digitalSignature
Non Repudiation
nonRepudiation
Key Encipherment
keyEncipherment
Data Encipherment
dataEncipherment
Key Agreement
keyAgreement
Certificate Sign
keyCertSign
CRL Sign
cRLSign
Encipher Only
encipherOnly
Decipher Only
decipherOnly
../deps/openssl/openssl/crypto/x509v3/v3_conf.c
,section=
critical,
DER:
ASN1:
CERTIFICATEPOLICIES
POLICYINFO
POLICYQUALINFO
USERNOTICE
NOTICEREF
%*sPolicy: 
%*s%s
Critical
Non Critical
%*sNo Qualifiers
policyid
qualifiers
pqualid
d.cpsuri
d.usernotice
noticeref
exptext
organization
noticenos
../deps/openssl/openssl/crypto/x509v3/v3_cpols.c
ia5org
policyIdentifier
userNotice
explicitText
noticeNumbers
%*sCPS: %s
%*sUser Notice:
%*sUnknown Qualifier: 
%*sOrganization: %s
%*sNumber%s: 
%*sExplicit Text: %s
DIST_POINT_NAME
DIST_POINT
CRL_DIST_POINTS
ISSUING_DIST_POINT
../deps/openssl/openssl/crypto/x509v3/v3_crld.c
reasons
CRLissuer
fullname
relativename
unused
Key Compromise
CA Compromise
CACompromise
Affiliation Changed
Superseded
Cessation Of Operation
Certificate Hold
Privilege Withdrawn
privilegeWithdrawn
AA Compromise
AACompromise
name.fullname
name.relativename
distpoint
CRLDistributionPoints
onlyuser
onlyCA
onlysomereasons
indirectCRL
onlyattr
onlyAA
%*sOnly User Certificates
%*sOnly CA Certificates
%*sIndirect CRL
Only Some Reasons
%*sOnly Attribute Certificates
%*sFull Name:
%*sRelative Name:
%*s%s:
<EMPTY>
Reasons
%*sCRL Issuer:
Unspecified
Remove From CRL
EXTENDED_KEY_USAGE
../deps/openssl/openssl/crypto/x509v3/v3_extku.c
OTHERNAME
EDIPARTYNAME
GENERAL_NAME
GENERAL_NAMES
type_id
nameAssigner
partyName
d.otherName
d.rfc822Name
d.dNSName
d.x400Address
d.directoryName
d.ediPartyName
d.uniformResourceIdentifier
d.iPAddress
d.registeredID
GeneralNames
../deps/openssl/openssl/crypto/x509v3/v3_ia5.c
ACCESS_DESCRIPTION
AUTHORITY_INFO_ACCESS
method
location
../deps/openssl/openssl/crypto/x509v3/v3_info.c
../deps/openssl/openssl/crypto/x509v3/v3_lib.c
GENERAL_SUBTREE
NAME_CONSTRAINTS
minimum
maximum
permittedSubtrees
excludedSubtrees
permitted
excluded
../deps/openssl/openssl/crypto/x509v3/v3_ncons.c
Permitted
Excluded
%d.%d.%d.%d/%d.%d.%d.%d
%*scrlUrl: 
%*scrlNum: 
%*scrlTime: 
../deps/openssl/openssl/crypto/x509v3/v3_ocsp.c
%*sIssuer: 
%*sPath Length Constraint: 
infinite
%*sPolicy Language: 
%*sPolicy Text: %s
../deps/openssl/openssl/crypto/x509v3/v3_pci.c
language
policy
hex:
file:
text:
PROXY_POLICY
PROXY_CERT_INFO_EXTENSION
policyLanguage
pcPathLengthConstraint
proxyPolicy
POLICY_CONSTRAINTS
requireExplicitPolicy
inhibitPolicyMapping
Require Explicit Policy
Inhibit Policy Mapping
../deps/openssl/openssl/crypto/x509v3/v3_pcons.c
PKEY_USAGE_PERIOD
Not Before: 
Not After: 
POLICY_MAPPING
POLICY_MAPPINGS
issuerDomainPolicy
subjectDomainPolicy
../deps/openssl/openssl/crypto/x509v3/v3_pmaps.c
%*s%s
%*s<Parse Error>
%*s<Not Supported>
../deps/openssl/openssl/crypto/x509v3/v3_purp.c
SSL client
sslclient
SSL server
sslserver
Netscape SSL server
nssslserver
S/MIME signing
smimesign
S/MIME encryption
smimeencrypt
CRL signing
crlsign
Any Purpose
OCSP helper
ocsphelper
Time Stamp signing
timestampsign
../deps/openssl/openssl/crypto/x509v3/v3_scts.c
%*sSigned Certificate Timestamp:
%*sVersion   : 
v1(0)
%*sLog ID    : 
%*sTimestamp : 
%*sExtensions: 
%*sSignature : 
%*s            
unknown
%.14s.%03dZ
%02X%02X
../deps/openssl/openssl/crypto/x509v3/v3_skey.c
SXNETID
SXNET
../deps/openssl/openssl/crypto/x509v3/v3_sxnet.c
zone
%*sVersion: %ld (0x%lX)
%*sZone: %s, User: 
../deps/openssl/openssl/crypto/x509v3/v3_utl.c
FALSE
true
false
,name:
0123456789ABCDEF
xn--
%d.%d.%d.%d
a2i_GENERAL_NAME
ASIDENTIFIERCHOICE_CANONIZE
ASIDENTIFIERCHOICE_IS_CANONICAL
COPY_EMAIL
COPY_ISSUER
DO_DIRNAME
DO_EXT_CONF
DO_EXT_I2D
DO_EXT_NCONF
DO_I2V_NAME_CONSTRAINTS
GNAMES_FROM_SECTNAME
hex_to_string
i2s_ASN1_ENUMERATED
I2S_ASN1_IA5STRING
i2s_ASN1_INTEGER
I2V_AUTHORITY_INFO_ACCESS
NOTICE_SECTION
NREF_NOS
POLICY_SECTION
PROCESS_PCI_VALUE
R2I_CERTPOL
R2I_PCI
S2I_ASN1_IA5STRING
s2i_ASN1_INTEGER
s2i_ASN1_OCTET_STRING
S2I_ASN1_SKEY_ID
S2I_SKEY_ID
SET_DIST_POINT_NAME
string_to_hex
SXNET_add_id_asc
SXNET_add_id_INTEGER
SXNET_add_id_ulong
SXNET_get_id_asc
SXNET_get_id_ulong
V2I_ASIDENTIFIERS
v2i_ASN1_BIT_STRING
V2I_AUTHORITY_INFO_ACCESS
V2I_AUTHORITY_KEYID
V2I_BASIC_CONSTRAINTS
V2I_CRLD
V2I_EXTENDED_KEY_USAGE
v2i_GENERAL_NAMES
v2i_GENERAL_NAME_ex
V2I_IDP
V2I_IPADDRBLOCKS
V2I_ISSUER_ALT
V2I_NAME_CONSTRAINTS
V2I_POLICY_CONSTRAINTS
V2I_POLICY_MAPPINGS
V2I_SUBJECT_ALT
V3_ADDR_VALIDATE_PATH_INTERNAL
V3_GENERIC_EXTENSION
X509V3_add1_i2d
X509V3_add_value
X509V3_EXT_add
X509V3_EXT_add_alias
X509V3_EXT_conf
X509V3_EXT_free
X509V3_EXT_i2d
X509V3_EXT_nconf
X509V3_get_section
X509V3_get_string
X509V3_get_value_bool
X509V3_parse_list
X509_PURPOSE_add
X509_PURPOSE_set
bad ip address
bad object
bn dec2bn error
bn to asn1 integer error
cannot find free function
dirname error
distpoint already set
duplicate zone id
error converting zone
error creating extension
error in extension
expected a section name
extension exists
extension name error
extension not found
extension setting not supported
extension value error
illegal empty extension
illegal hex digit
incorrect policy syntax tag
invalid asnumber
invalid asrange
invalid boolean string
invalid extension string
invalid inheritance
invalid ipaddress
invalid multiple rdns
invalid name
invalid null name
invalid null value
invalid numbers
invalid object identifier
invalid option
invalid policy identifier
invalid proxy policy setting
invalid safi
invalid section
invalid syntax
issuer decode error
need organization and numbers
no config database
no issuer certificate
no issuer details
no policy identifier
no proxy cert policy language defined
no subject details
odd number of digits
operation not defined
othername error
policy language already defined
policy path length
policy path length already defined
policy syntax not currently supported
policy when proxy language requires no policy
section not found
unable to get issuer details
unable to get issuer keyid
unknown bit string argument
unknown extension
unknown extension name
unsupported option
user too long
4758cca
IBM 4758 CCA hardware engine support
IBM 4758 CCA RSA method
../deps/openssl/openssl/engines/e_4758cca.c
RANDOM  
CCA_RSA_SIGN
CCA_RSA_VERIFY
IBM_4758_CCA_CTRL
IBM_4758_CCA_FINISH
IBM_4758_CCA_INIT
IBM_4758_LOAD_PRIVKEY
IBM_4758_LOAD_PUBKEY
asn1 oid unknown for md
command not implemented
dso failure
size too large or too small
unit failure
IBM 4758 CCA RSA key handle
CSUNSAPI
CSNDKRR
CSNBRNG
CSNDDSG
CSNDDSV
CSNDPKX
CSNDPKE
CSNDPKD
Specifies the path to the '4758cca' shared library
Aep hardware engine support
Aep RSA method
../deps/openssl/openssl/engines/e_aep.c
Aep DSA method
Aep DH method
AEP_ModExp
AEP_ModExpCrt
AEP_Finalize
AEP_Initialize
AEP_OpenConnection
AEP_SetBNCallBacks
AEP_CloseConnection
AEP_CTRL
AEP_FINISH
AEP_GET_CONNECTION
AEP_INIT
AEP_MOD_EXP
AEP_MOD_EXP_CRT
AEP_RAND
AEP_RSA_MOD_EXP
close handles failed
connections in use
finalize failed
get handle failed
get random failed
init failure
missing key components
mod exp crt failed
mod exp failed
return connection failed
setbncallback failure
Specifies the path to the 'aep' shared library
atalla
Atalla hardware engine support
Atalla RSA method
../deps/openssl/openssl/engines/e_atalla.c
Atalla DSA method
Atalla DH method
ATALLA_CTRL
ATALLA_FINISH
ATALLA_INIT
ATALLA_MOD_EXP
ATALLA_RSA_MOD_EXP
bn ctx full
bn expand fail
request failed
atalla engine
atasi
ASI_GetHardwareConfig
ASI_RSAPrivateKeyOpFn
ASI_GetPerformanceStatistics
Specifies the path to the 'atasi' shared library
CHIL hardware engine support
CHIL RSA method
../deps/openssl/openssl/engines/e_chil.c
CHIL DH method
HWCRHK_CTRL
HWCRHK_FINISH
HWCRHK_GET_PASS
HWCRHK_INIT
HWCRHK_INSERT_CARD
HWCRHK_LOAD_PRIVKEY
HWCRHK_LOAD_PUBKEY
HWCRHK_MOD_EXP
HWCRHK_RAND_BYTES
HWCRHK_RSA_MOD_EXP
bio was freed
chil error
no callback
private key algorithms disabled
request fallback
CHIL engine
nFast HWCryptoHook RSA key handle
nfhwcrhk
HWCryptoHook_Init
HWCryptoHook_Finish
HWCryptoHook_ModExp
HWCryptoHook_RSA
HWCryptoHook_RSALoadKey
HWCryptoHook_RSAGetPublicKey
HWCryptoHook_RSAUnloadKey
HWCryptoHook_RandomBytes
HWCryptoHook_ModExpCRT
pass phrase
Current card: "%s"
Insert card "%s"
 then hit <enter> or C<enter> to cancel
Specifies the path to the 'hwcrhk' shared library
FORK_CHECK
Turns fork() checking on (non-zero) or off (zero)
THREAD_LOCKING
Turns thread-safe locking on (zero) or off (non-zero)
SET_USER_INTERFACE
Set the global user interface (internal)
SET_CALLBACK_DATA
Set the global user interface extra data (internal)
cswift
CryptoSwift hardware engine support
CryptoSwift RSA method
../deps/openssl/openssl/engines/e_cswift.c
CryptoSwift error number is 
CryptoSwift DSA method
CryptoSwift DH method
CSWIFT_CTRL
CSWIFT_DSA_SIGN
CSWIFT_DSA_VERIFY
CSWIFT_FINISH
CSWIFT_INIT
CSWIFT_MOD_EXP
CSWIFT_MOD_EXP_CRT
CSWIFT_RAND_BYTES
CSWIFT_RSA_MOD_EXP
bad key size
cswift engine
swift
swAcquireAccContext
swAttachKeyParam
swSimpleRequest
swReleaseAccContext
Specifies the path to the 'cswift' shared library
nuron
Nuron hardware engine support
Nuron RSA method
../deps/openssl/openssl/engines/e_nuron.c
Nuron DSA method
Nuron DH method
NURON_CTRL
NURON_FINISH
NURON_INIT
NURON_MOD_EXP
dso function not found
nuron engine
nuronssl
nuron_mod_exp
Specifies the path to the 'nuronssl' shared library
sureware
SureWare hardware engine support
SureWare RSA method
../deps/openssl/openssl/engines/e_sureware.c
SureWare DSA method
SureWare DH method
SUREWAREHK_CTRL
SUREWAREHK_DH_EX_FREE
SUREWAREHK_DSA_DO_SIGN
SUREWAREHK_EX_FREE
SUREWAREHK_FINISH
SUREWAREHK_INIT
SUREWAREHK_LOAD_PRIVKEY
SUREWAREHK_LOAD_PUBKEY
SUREWAREHK_MODEXP
SUREWAREHK_RAND_BYTES
SUREWAREHK_RAND_SEED
SUREWAREHK_RSA_PRIV_DEC
SUREWAREHK_RSA_SIGN
SUREWARE_LOAD_PUBLIC
sureware engine
SureWareHook RSA key handle
SureWareHook DSA key handle
SureWareHook
SureWareHook_Init
SureWareHook_Finish
SureWareHook_Rand_Bytes
SureWareHook_Rand_Seed
SureWareHook_Load_Privkey
SureWareHook_Load_Rsa_Pubkey
SureWareHook_Free
SureWareHook_Rsa_Priv_Dec
SureWareHook_Rsa_Sign
SureWareHook_Dsa_Sign
SureWareHook_Info_Pubkey
SureWareHook_Load_Dsa_Pubkey
SureWareHook_Mod_Exp
ubsec
UBSEC hardware engine support
UBSEC RSA method
../deps/openssl/openssl/engines/e_ubsec.c
/dev/ubskey
UBSEC DSA method
UBSEC DH method
UBSEC_CTRL
UBSEC_DH_COMPUTE_KEY
UBSEC_DH_GENERATE_KEY
UBSEC_DSA_DO_SIGN
UBSEC_DSA_VERIFY
UBSEC_FINISH
UBSEC_INIT
UBSEC_MOD_EXP
UBSEC_MOD_EXP_CRT
UBSEC_RAND_BYTES
UBSEC_RSA_MOD_EXP
UBSEC_RSA_MOD_EXP_CRT
ubsec engine
ubsec_bytes_to_bits
ubsec_bits_to_bytes
ubsec_open
ubsec_close
diffie_hellman_generate_ioctl
diffie_hellman_agree_ioctl
rsa_mod_exp_ioctl
rsa_mod_exp_crt_ioctl
dsa_sign_ioctl
dsa_verify_ioctl
math_accelerate_ioctl
rng_ioctl
ubsec_max_key_len_ioctl
Specifies the path to the 'ubsec' shared library
../deps/openssl/openssl/crypto/ec/ecp_nistz256.c
rc4(ptr,int)
../deps/v8/src/accessors.cc
(LookupIterator::ACCESSOR)==(it.state())
uint32_v->ToArrayLength(&length)
column_offset
line_offset
compilation_type
line_ends
is_debugger_script
context_data
eval_from_script
eval_from_script_position
eval_from_function_name
Malloced operator new
AlignedAlloc
*** Creating top level AllocationSite %p
Creating nested site (top, current, new) (%p, %p, %p)
*** Setting AllocationSite %p transition_info %p
Setting AllocationSite (%p, %p) transition_info %p
*** Creating Memento for %s %p
JSArray
JSObject
%10u %10u %*c
%s #%u
%u #%u
[AllocationTraceTree:]
Total size | Allocation count | Function id | id
[AddressToTraceMap (%lu): 
[%p - %p] => %u
(root)
(V8 API)
<--- Last few GCs --->
<--- JS stacktrace --->
Allocation failed - process out of memory
API fatal error handler returned after process out of memory
# Fatal error in %s
# %s
<embedded script>
Executing custom snapshot script took %0.3f ms
../deps/v8/src/api.cc
!try_catch.HasCaught()
mksnapshot
Creating snapshot took %0.3f ms
source != NULL || source_length_ == 0
Persistent::New
v8::FromJust
Maybe value is Nothing.
v8::ToLocalChecked
Empty MaybeLocal.
WeakCallbackInfo::GetInternalField
Internal field out of bounds.
HandleScope::HandleScope
Entering the V8 API without proper locking in place
EscapeableHandleScope::Escape
Escape value set twice
v8::Context::Exit()
Cannot exit non-entered context
v8::Context::GetEmbedderData()
v8::Context::SetEmbedderData()
v8::Context::GetAlignedPointerFromEmbedderData()
v8::Context::SetAlignedPointerInEmbedderData()
v8::FunctionTemplate::Inherit
FunctionTemplate::New
TypeSwitch::New
TypeSwitch::match
v8::FunctionTemplate::SetCallHandler
v8::FunctionTemplate::InstanceTemplate()
Reading from empty handle
v8::FunctionTemplate::SetLength
v8::FunctionTemplate::SetClassName
v8::FunctionTemplate::SetAcceptAnyReceiver
v8::FunctionTemplate::SetHiddenPrototype
v8::FunctionTemplate::ReadOnlyPrototype
v8::FunctionTemplate::RemovePrototype
ObjectTemplate::New
v8::ObjectTemplate::MarkAsUndetectable
v8::ObjectTemplate::SetAccessCheckCallbacks
v8::ObjectTemplate::SetHandler
v8::ObjectTemplate::SetCallAsFunctionHandler
v8::UnboundScript::GetId
UnboundScript::GetLineNumber
UnboundScript::GetName
UnboundScript::GetSourceURL
UnboundScript::GetSourceMappingURL
v8::Script::Run()
v8::ScriptCompiler::CompileUnbound()
i::FLAG_harmony_modules
v8::ScriptCompiler::CompileFunctionInContext()
(function(
(function(){
v8::ScriptCompiler::Compile()
v8::TryCatch::StackTrace
v8::Message::GetLineNumber()
$messageGetLineNumber
v8::Message::GetStartColumn()
$messageGetPositionInLine
v8::Message::GetEndColumn()
v8::Message::GetSourceLine()
$messageGetSourceLine
lineNumber
column
scriptId
scriptName
scriptNameOrSourceURL
functionName
isEval
isConstructor
JSON::Parse
$Error
$EvalError
$RangeError
$ReferenceError
$SyntaxError
$TypeError
$URIError
ToString
ToDetailString
ToObject
ToNumber
ToInteger
ToInt32
ToUInt32
v8::internal::Internals::CheckInitialized()
Isolate is not initialized or V8 has died
v8::External::Cast()
Could not convert to external
v8::Object::Cast()
Could not convert to object
v8::Function::Cast()
Could not convert to function
v8::Boolean::Cast()
Could not convert to boolean
v8::Name::Cast()
Could not convert to name
v8::String::Cast()
Could not convert to string
v8::Symbol::Cast()
Could not convert to symbol
v8::Number::Cast()
Could not convert to number
v8::Integer::Cast()
v8::Int32::Cast()
Could not convert to 32-bit signed integer
v8::Uint32::Cast()
Could not convert to 32-bit unsigned integer
v8::Array::Cast()
Could not convert to array
v8::Map::Cast()
Could not convert to Map
v8::Set::Cast()
Could not convert to Set
v8::Promise::Cast()
Could not convert to promise
v8::Promise::Resolver::Cast()
Could not convert to promise resolver
v8::ArrayBuffer::Cast()
Could not convert to ArrayBuffer
v8::ArrayBufferView::Cast()
Could not convert to ArrayBufferView
v8::TypedArray::Cast()
Could not convert to TypedArray
v8::Uint8Array::Cast()
Could not convert to Uint8Array
v8::Int8Array::Cast()
Could not convert to Int8Array
v8::Uint16Array::Cast()
Could not convert to Uint16Array
v8::Int16Array::Cast()
Could not convert to Int16Array
v8::Uint32Array::Cast()
Could not convert to Uint32Array
v8::Int32Array::Cast()
Could not convert to Int32Array
v8::Float32Array::Cast()
Could not convert to Float32Array
v8::Float64Array::Cast()
Could not convert to Float64Array
v8::Uint8ClampedArray::Cast()
Could not convert to Uint8ClampedArray
v8::DataView::Cast()
Could not convert to DataView
v8::SharedArrayBuffer::Cast()
Could not convert to SharedArrayBuffer
v8::Date::Cast()
Could not convert to date
v8::StringObject::Cast()
Could not convert to StringObject
v8::SymbolObject::Cast()
Could not convert to SymbolObject
v8::NumberObject::Cast()
Could not convert to NumberObject
v8::BooleanObject::Cast()
Could not convert to BooleanObject
v8::RegExp::Cast()
Could not convert to regular expression
NumberValue
IntegerValue
Int32Value
Uint32Value
ToArrayIndex
v8::Value::Equals()
EQUALS
StrictEquals
v8::Object::Set()
v8::Object::CreateDataProperty()
v8::Object::DefineOwnProperty()
$objectDefineOwnProperty
v8::Object::ForceSet
v8::Object::Get()
v8::Object::GetPropertyAttributes()
v8::Object::GetOwnPropertyDescriptor()
$objectGetOwnPropertyDescriptor
v8::Object::SetPrototype()
v8::Object::GetPropertyNames()
v8::Object::GetOwnPropertyNames()
[object ]
[object Object]
v8::Object::ObjectProtoToString()
v8::Object::Delete()
v8::Object::DeleteProperty()
v8::Object::HasOwnProperty()
v8::Object::HasRealNamedProperty()
v8::Object::HasRealIndexedProperty()
v8::Object::HasRealNamedCallbackProperty()
v8::Object::GetRealNamedPropertyInPrototypeChain()
v8::Object::GetRealNamedPropertyAttributesInPrototypeChain()
v8::Object::GetRealNamedProperty()
v8::Object::GetRealNamedPropertyAttributes()
!result.is_null()
v8::Object::CallAsFunction()
v8::Object::CallAsConstructor()
Function::New
v8::Function::NewInstance()
v8::Function::Call()
displayName
String::WriteUtf8
(expected)==(value)
(expectedEncoding)==(encoding)
v8::Object::GetInternalField()
v8::Object::SetInternalField()
v8::Object::GetAlignedPointerFromInternalField()
v8::Object::SetAlignedPointerInInternalField()
v8::V8::SetArrayBufferAllocator
ArrayBufferAllocator might only be set once
Context::New
v8::ObjectTemplate::NewInstance()
v8::FunctionTemplate::GetFunction()
External::New
String::NewFromUtf8
String::NewFromOneByte
String::NewFromTwoByte
v8::String::Concat
resource && resource->data()
String::NewExternalTwoByte
String::NewExternalOneByte
Object::New
NumberObject::New
NumberObject::NumberValue
BooleanObject::New
BooleanObject::BooleanValue
StringObject::New
StringObject::StringValue
SymbolObject::New
SymbolObject::SymbolValue
Date::New
Date::NumberValue
Date::DateTimeConfigurationChangeNotification
date_cache_version->get(0)->IsSmi()
RegExp::New
Array::New
v8::Array::CloneElementAt()
Map::New
Map::Clear
Map::Get
Map::Set
Map::Has
Map::Delete
Map::AsArray
Map::FromArray
Set::New
Set::Clear
Set::Add
Set::Has
Set::Delete
Set::AsArray
Set::FromArray
Promise::Resolver::New
Promise::Resolver::Resolve
Promise::Chain
Promise::Catch
Promise::Then
Promise::HasRejectHandler
v8::ArrayBuffer::Externalize
ArrayBuffer already externalized
v8::ArrayBuffer::Neuter
Only externalized ArrayBuffers can be neutered
Only neuterable ArrayBuffers can be neutered
v8::ArrayBuffer::Neuter()
v8::ArrayBuffer::New(size_t)
v8::ArrayBuffer::New(void*, size_t)
v8::Uint8Array::New(Local<ArrayBuffer>, size_t, size_t)
length exceeds max allowed value
i::FLAG_harmony_sharedarraybuffer
v8::Uint8Array::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::Int8Array::New(Local<ArrayBuffer>, size_t, size_t)
v8::Int8Array::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::Uint16Array::New(Local<ArrayBuffer>, size_t, size_t)
v8::Uint16Array::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::Int16Array::New(Local<ArrayBuffer>, size_t, size_t)
v8::Int16Array::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::Uint32Array::New(Local<ArrayBuffer>, size_t, size_t)
v8::Uint32Array::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::Int32Array::New(Local<ArrayBuffer>, size_t, size_t)
v8::Int32Array::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::Float32Array::New(Local<ArrayBuffer>, size_t, size_t)
v8::Float32Array::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::Float64Array::New(Local<ArrayBuffer>, size_t, size_t)
v8::Float64Array::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::Uint8ClampedArray::New(Local<ArrayBuffer>, size_t, size_t)
v8::Uint8ClampedArray::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::DataView::New(Local<ArrayBuffer>, size_t, size_t)
v8::DataView::New(Local<SharedArrayBuffer>, size_t, size_t)
v8::SharedArrayBuffer::Externalize
SharedArrayBuffer already externalized
v8::SharedArrayBuffer::New(size_t)
v8::SharedArrayBuffer::New(void*, size_t)
Symbol::New()
i::FLAG_expose_gc
Isolate::RequestGarbageCollection
Initializing isolate from custom startup snapshot failed
v8::Isolate::Dispose()
Disposing the isolate that is entered by a thread.
low memory notification
stack_limit
RangeError
ReferenceError
SyntaxError
TypeError
Error
v8::Debug::Call()
v8::Debug::GetMirror()
MakeMirror
v8::HeapSnapshot::Serialize
Unknown serialization format
Invalid stream chunk size
--prepare-always-opt --max-inlined-source-size=999999 --max-inlined-nodes=999999 --max-inlined-nodes-cumulative=999999 --noalways-opt
--always-opt
--deopt-every-n-times=13
PartialSerializer
StartupSerializer
Not a native context
Negative index
Index too large
Not a Smi
Pointer is not aligned
FunctionTemplate already instantiated
../deps/v8/src/prototype.h
!handle_.is_null()
Internal field out of bounds
is_valid
../deps/v8/src/objects-inl.h
Object::cast(READ_FIELD(this, kLengthOffset))->ToArrayLength(&index)
../deps/v8/src/handles.h
V8.External
ObjectTemplateSetNamedPropertyHandler
../deps/v8/src/layout-descriptor-inl.h
(!IsSmi() && (*layout_word_index < length())) || (IsSmi() && (*layout_word_index < 1))
v8::Object::SetAccessor()
APISetAccessor
String::Write
ApiNatives::InstantiateObject
DisableAccessChecks
EnableAccessChecks
DEOPTIMIZATION PADDING
../deps/v8/src/assembler.cc
(expected_size_)==(assembler_->pc_offset() - start_offset_)
no reloc 32
no reloc 64
embedded object
code target (js construct call)
debug break
code target
code target with id
property cell
runtime entry
js return
comment
position
statement position
external reference
internal reference
encoded internal reference
deopt reason
constant pool
veneer pool
debug break slot
code_age_sequence
number_of_modes
unknown relocation type
)  (
 (id=
  (deoptimization bailout 
 (size 
.entry>
(-> 
(<- 
__proto__
no reason
32 bit value in register is not zero-extended
Alignment marker expected
Allocation is not double aligned
API call returned invalid object
Arguments object value in a test context
Array boilerplate creation failed
Array index constant value too big
Assignment to arguments
Assignment to let variable before initialization
Assignment to LOOKUP variable
Assignment to parameter, function uses arguments object
Assignment to parameter in arguments object
Attempt to use undefined cache
Bad value context for arguments object value
Bad value context for arguments value
Bailed out due to dependency change
Bailout was not prepared
BinaryStub_GenerateFloatingPointCode
Both registers were smis in SelectNonSmi
Builtin function cannot be optimized
Call to a JavaScript runtime function
Cannot translate position in changed area
Class literal
Code generation failed
Code object not properly patched
Compound assignment to lookup slot
Computed property name
Context-allocated arguments
Copy buffers overlap
Could not generate +0.0
Could not generate -0.0
Debugger has break points
DebuggerStatement
Declaration in catch context
Declaration in with context
Default NaN mode not set
Delete with global variable
Delete with non-global variable
Destination of copy not aligned
DontDelete cells can't contain the hole
DoPushArgument not implemented for double type
Eliminated bounds check failed
EmitLoadRegister: Unsupported double immediate
eval
Expected 0 as a Smi sentinel
Expected alignment marker
Expected allocation site
Expected function object in register
Expected HeapNumber
Expected native context
Expected non-identical objects
Expected non-null context
Expected +0.0
Expected AllocationSite in property cell
Expected fixed array in feedback vector
Expected fixed array in register a2
Expected fixed array in register ebx
Expected fixed array in register r2
Expected fixed array in register rbx
Expected new space object
Expected smi or HeapNumber
Expected undefined or cell in register
Expecting alignment for CopyBytes
Export declaration
External string expected, but not found
Failed/bailed out last time
ForInStatement optimization is disabled
ForInStatement with non-local each variable
ForOfStatement
Frame is expected to be aligned
Function calls eval
Function is a generator
Function with illegal redeclaration
Generated code is too large
Generator failed to resume
Generator
Global functions must have initial map
HeapNumberMap register clobbered
Optimization disabled by filter
Import declaration
Improper object on prototype chain for store
Index is negative
Index is too large
Inlined runtime function: FastOneByteArrayJoin
Inlined runtime function: GetFromCache
Inlining bailed out
Input GPR is expected to have upper32 cleared
Input string too long
InstanceofStub unexpected call site cache (check)
InstanceofStub unexpected call site cache (cmp 1)
InstanceofStub unexpected call site cache (cmp 2)
InstanceofStub unexpected call site cache (mov)
Integer32ToSmiField writing to non-smi location
Invalid capture referenced
Invalid ElementsKind for InternalArray or InternalPackedArray
invalid full-codegen state
Invalid HandleScope level
Invalid left-hand side in assignment
Invalid lhs in compound assignment
Invalid lhs in count operation
Invalid min_length
JSGlobalObject::native_context should be a native context
JSGlobalProxy::context() should not be null
JSObject with fast elements map has slow elements
Let binding re-initialization
lhs has been clobbered
Live Bytes Count overflow chunk size
LiveEdit
Lookup variable in count operation
Map became deprecated
Map became unstable
Map is no longer in eax
Native function literal
Need a Smi literal here
No cases left
No empty arrays here in EmitFastOneByteArrayJoin
Non-initializer assignment to const
Non-smi index
Non-smi key in array literal
Non-smi value
Non-object value
Not enough virtual registers for values
Not enough spill slots for OSR
Not enough virtual registers (regalloc)
Object found in smi-only array
Object literal with complex property
Oddball in string table is not undefined or the hole
Offset out of range
Operand is a smi and not a name
Operand is a smi and not a string
Operand is a smi
Operand is not a date
Operand is not a name
Operand is not a number
Operand is not a smi
Operand is not a string
Operand is not smi
Operand not a number
The object is tagged
The object is not tagged
Optimization is disabled
Optimized too many times
Out of virtual registers while trying to allocate temp register
Parse/scope error
Possible direct call to eval
Preconditions were not met
Property allocation count failed
Received invalid return address
Reference to a variable which requires dynamic lookup
Reference to global lexical variable
Reference to uninitialized variable
Register did not match expected root
Register was clobbered
Remembered set pointer is in new space
Rest parameters
Return address not found in frame
Rhs has been clobbered
ScopedBlock
Allocation of script context
Smi addition overflow
Smi subtraction overflow
Spread in array literal
Stack access below stack pointer
Stack frame types must match
Super reference
The current stack pointer is below csp
The instruction should be a lis
The instruction should be a lui
The instruction should be an ori
The instruction should be an oris
The instruction should be a li
The instruction should be a sldi
The instruction to patch should be a load from the constant pool
The instruction to patch should be a ldr literal
The instruction to patch should be a lis
The instruction to patch should be a lui
The instruction to patch should be an ori
The source and destination are the same
The stack pointer is not aligned.
The stack was corrupted by MacroAssembler::Call()
Too many parameters/locals
Too many parameters
Too many spill slots needed for OSR
ToOperand32 unsupported immediate.
ToOperand IsDoubleRegister unimplemented
ToOperand Unsupported double immediate
TryCatchStatement
TryFinallyStatement
Unable to encode value as smi
Unaligned allocation in new space
Unaligned cell in write barrier
Undefined value not loaded
Undo allocation of non allocated memory
Unexpected allocation top
Unexpected color bit pattern found
Unexpected ElementsKind in array constructor
Unexpected fallthrough from CharCodeAt slow case
Unexpected fallthrough from CharFromCode slow case
Unexpected fall-through from string comparison
Unexpected fall-through in BinaryStub_GenerateFloatingPointCode
Unexpected fallthrough to CharCodeAt slow case
Unexpected fallthrough to CharFromCode slow case
Unexpected FPU stack depth after instruction
Unexpected initial map for Array function (1)
Unexpected initial map for Array function (2)
Unexpected initial map for Array function
Unexpected initial map for InternalArray function
Unexpected level after return from api call
Unexpected negative value
Unexpected number of pre-allocated property fields
Unexpected FPCR mode.
Unexpected smi value
Unexpected String function
Unexpected string type
Unexpected string wrapper instance size
Unexpected type for RegExp data, FixedArray expected
Unexpected value
Unexpected unused properties of string wrapper
unimplemented
Unsupported const compound assignment
Unsupported count operation with const
Unsupported double immediate
Unsupported let compound assignment
Unsupported lookup slot in declaration
Unsupported non-primitive compare
Unsupported phi use of arguments
Unsupported phi use of const variable
Unsupported tagged immediate
Variable resolved to with context
We should not have an empty lexical context
WithStatement
Wrong context passed to function
Wrong address or value passed to RecordWrite
Should not directly enter OSR-compiled function
Yield
---- Start Profiling Data ----
---- End Profiling Data ----
unknown function
schedule for 
block counts for 
block 
unimplemented code
EmptyObjectPrototype
EmptyStrongObject
() {}
ThrowTypeError
Function
Array
SetInstancePrototype
Number
Boolean
String
Symbol
Date
RegExp
RegExpPrototype
JSON
ArrayBuffer
Uint8Array
Int8Array
Uint16Array
Int16Array
Uint32Array
Int32Array
Float32Array
Float64Array
Uint8ClampedArray
DataView
WeakMap
WeakSet
FastAliasedArguments
SlowAliasedArguments
context_extension
$createDate
$toNumber
$toString
$toDetailString
$toObject
$toInteger
$toUint32
$toInt32
$toLength
$globalEval
$getStackTraceLine
$toCompletePropertyDescriptor
$promiseStatus
$promiseValue
$promiseCreate
$promiseResolve
$promiseReject
$promiseChain
$promiseCatch
$promiseThen
$observeNotifyChange
$observeEnqueueSpliceRecord
$observeBeginPerformSplice
$observeEndPerformSplice
$observeNativeObjectObserve
$observeNativeObjectGetNotifier
$observeNativeObjectNotifierPerformChange
$arrayValues
$mapGet
$mapSet
$mapHas
$mapDelete
$setAdd
$setHas
$setDelete
$mapFromArray
$setFromArray
$proxyDerivedHasTrap
$proxyDerivedGetTrap
$proxyDerivedSetTrap
$proxyEnumerate
rngstate
kMath
rempio2result
$reflectApply
$reflectConstruct
Reflect
SharedArrayBuffer
InternalArray
utils container for native scripts
container to export to extra natives
utils
Script
OpaqueReference
InternalPackedArray
SetIterator
MapIterator
$iteratorPrototype
GeneratorFunctionPrototype
GeneratorFunction
SloppyGeneratorFunction
StrictGeneratorFunction
StrongGeneratorFunction
Warning: Running without installed natives!
symbolHasInstance
symbolIsConcatSpreadable
symbolIsRegExp
symbolIterator
symbolToStringTag
symbolUnscopables
PostNatives
call
apply
native harmony-array-includes.js
native proxy.js
native harmony-regexp.js
native harmony-tostring.js
native harmony-reflect.js
native harmony-spread.js
native harmony-object.js
native harmony-sharedarraybuffer.js
native harmony-atomics.js
native harmony-concat-spreadable.js
PostExperimentals
Array.prototype
indexOf
lastIndexOf
push
shift
Function.prototype
String.prototype
charCodeAt
charAt
fromCharCode
Math
random
floor
round
ceil
sqrt
acos
asin
atan
atan2
imul
clz32
fround
Atomics
load
stackTraceLimit
$stackTraceSymbol
v8/free-buffer
v8/gc
v8/externalize
v8/statistics
v8/trigger-failure
v8::Context::New()
Cannot find required extension
Circular extension dependency
Error installing extension '%s'.
../deps/v8/src/bootstrapper.cc
(LookupIterator::ACCESS_CHECK)!=(it.state())
native function freeBuffer();
native function %s();
SetObjectPrototype
STRICT_EQUALS
COMPARE
COMPARE_STRONG
ADD_STRONG
SUB_STRONG
MUL_STRONG
DIV_STRONG
MOD_STRONG
BIT_OR
BIT_OR_STRONG
BIT_AND
BIT_AND_STRONG
BIT_XOR
BIT_XOR_STRONG
SHL_STRONG
SAR_STRONG
SHR_STRONG
DELETE
INSTANCE_OF
CALL_NON_FUNCTION
CALL_NON_FUNCTION_AS_CONSTRUCTOR
CALL_FUNCTION_PROXY
CALL_FUNCTION_PROXY_AS_CONSTRUCTOR
TO_OBJECT
TO_NUMBER
TO_STRING
TO_NAME
STRING_ADD_LEFT
STRING_ADD_LEFT_STRONG
STRING_ADD_RIGHT
STRING_ADD_RIGHT_STRONG
APPLY_PREPARE
REFLECT_APPLY_PREPARE
REFLECT_CONSTRUCT_PREPARE
CONCAT_ITERABLE_TO_ARRAY
STACK_OVERFLOW
Illegal
EmptyFunction
ArrayPush
ArrayPop
ArrayShift
ArrayUnshift
ArraySlice
ArraySplice
ArrayConcat
HandleApiCall
HandleApiCallConstruct
HandleApiCallAsFunction
HandleApiCallAsConstructor
RestrictedFunctionPropertiesThrower
RestrictedStrictArgumentsPropertiesThrower
ArgumentsAdaptorTrampoline
InOptimizationQueue
JSConstructStubGeneric
JSConstructStubForDerived
JSConstructStubApi
JSConstructStubNewTarget
JSEntryTrampoline
JSConstructEntryTrampoline
CompileLazy
CompileOptimized
CompileOptimizedConcurrent
NotifyDeoptimized
NotifySoftDeoptimized
NotifyLazyDeoptimized
NotifyStubFailure
NotifyStubFailureSaveDoubles
LoadIC_Miss
KeyedLoadIC_Miss
StoreIC_Miss
KeyedStoreIC_Miss
LoadIC_Getter_ForDeopt
KeyedLoadIC_Megamorphic
KeyedLoadIC_Megamorphic_Strong
StoreIC_Setter_ForDeopt
KeyedStoreIC_Initialize
KeyedStoreIC_PreMonomorphic
KeyedStoreIC_Megamorphic
KeyedStoreIC_Initialize_Strict
KeyedStoreIC_PreMonomorphic_Strict
KeyedStoreIC_Megamorphic_Strict
FunctionCall
FunctionApply
ReflectApply
ReflectConstruct
InternalArrayCode
ArrayCode
StringConstructCode
OnStackReplacement
InterruptCheck
OsrAfterStackCheck
StackCheck
MarkCodeAsToBeExecutedOnce
MarkCodeAsExecutedOnce
MarkCodeAsExecutedTwice
MakeQuadragenarianCodeYoungAgainOddMarking
MakeQuadragenarianCodeYoungAgainEvenMarking
MakeQuinquagenarianCodeYoungAgainOddMarking
MakeQuinquagenarianCodeYoungAgainEvenMarking
MakeSexagenarianCodeYoungAgainOddMarking
MakeSexagenarianCodeYoungAgainEvenMarking
MakeSeptuagenarianCodeYoungAgainOddMarking
MakeSeptuagenarianCodeYoungAgainEvenMarking
MakeOctogenarianCodeYoungAgainOddMarking
MakeOctogenarianCodeYoungAgainEvenMarking
LoadIC_Slow
LoadIC_Slow_Strong
KeyedLoadIC_Slow
KeyedLoadIC_Slow_Strong
StoreIC_Slow
KeyedStoreIC_Slow
LoadIC_Normal
LoadIC_Normal_Strong
StoreIC_Normal
Return_DebugBreak
CallFunctionStub_DebugBreak
CallConstructStub_DebugBreak
CallConstructStub_Recording_DebugBreak
CallICStub_DebugBreak
Slot_DebugBreak
PlainReturn_LiveEdit
FrameDropper_LiveEdit
Builtin: 
$arrayPush
$arrayPop
$arrayShift
$arrayUnshift
$arraySlice
$arraySplice
$arrayConcat
../deps/v8/src/builtins.cc
function->shared()->IsApiFunction()
raw_call_data->IsCallHandlerInfo()
constructor->shared()->IsApiFunction()
handler->IsCallHandlerInfo()
call non-function
ArgumentsAccessStub
ArrayConstructorStub
BinaryOpICWithAllocationSiteStub
CallApiFunctionStub
CallApiAccessorStub
CallApiGetterStub
CallConstructStub
CallFunctionStub
CallICStub
CallIC_ArrayStub
CEntryStub
CompareICStub
DoubleToIStub
FunctionPrototypeStub
InstanceofStub
InternalArrayConstructorStub
JSEntryStub
KeyedLoadICTrampolineStub
LoadICTrampolineStub
CallICTrampolineStub
CallIC_ArrayTrampolineStub
LoadIndexedInterceptorStub
LoadIndexedStringStub
MathPowStub
ProfileEntryHookStub
RecordWriteStub
RegExpExecStub
StoreArrayLiteralElementStub
StoreBufferOverflowStub
StoreElementStub
StringCompareStub
StubFailureTrampolineStub
SubStringStub
ToNumberStub
VectorStoreICTrampolineStub
VectorKeyedStoreICTrampolineStub
VectorStoreICStub
VectorKeyedStoreICStub
AllocateHeapNumberStub
ArrayNArgumentsConstructorStub
ArrayNoArgumentConstructorStub
ArraySingleArgumentConstructorStub
BinaryOpICStub
BinaryOpWithAllocationSiteStub
CompareNilICStub
CreateAllocationSiteStub
CreateWeakCellStub
ElementsTransitionAndStoreStub
FastCloneShallowArrayStub
FastCloneShallowObjectStub
FastNewClosureStub
FastNewContextStub
GrowArrayElementsStub
InternalArrayNArgumentsConstructorStub
InternalArrayNoArgumentConstructorStub
InternalArraySingleArgumentConstructorStub
KeyedLoadGenericStub
LoadScriptContextFieldStub
LoadDictionaryElementStub
NameDictionaryLookupStub
NumberToStringStub
TypeofStub
RegExpConstructResultStub
StoreFastElementStub
StoreScriptContextFieldStub
StringAddStub
ToBooleanStub
TransitionElementsKindStub
KeyedLoadICStub
LoadICStub
StringLengthTFStub
StringAddTFStub
MathFloorStub
ArrayBufferViewLoadFieldStub
LoadConstantStub
LoadFastElementStub
LoadFieldStub
KeyedLoadSloppyArgumentsStub
KeyedStoreSloppyArgumentsStub
StoreFieldStub
StoreGlobalStub
StoreTransitionStub
StringLengthStub
RestParamAccessStub
<NoCache>Stub
CheckNone
CheckLeft
CheckRight
CheckBoth
StringAddStub_
StringAddTFStub_
(NullValue)
(UndefinedValue)
Undefined
Null
MonomorphicMap
Generic
 (Array)
_REGS
_INLINE
_TRUEFALSE
ArgumentsAccessStub_
ReadElement
NewSloppyFast
NewSloppySlow
NewStrict
RestParamAccessStub_
CallFunctionStub_Args
_Recording
_Any
_None
_One
_More_Than_One
_DISABLE_ALLOCATION_SITES
Bool
SpecObject
HeapNumber
NotTenured
Tenured
JSConstructEntryStub
-----------------------------------------------------------
Compiling stub %s using hydrogen
[Lazy compilation of 
 took 
 ms]
HAllocate with AllocationSite %p %s
tenured
not tenured
user-defined
[generating %s code for %s function: 
--- Raw source ---
--- Unoptimized code ---
--- Optimized code ---
optimization_id = 
--- Code ---
source_position = 
--- End code ---
totals
                             Turbofan timing results:
%28s %10.3f ms / %5.1f %%%10u total / %5.1f %% %10u max %10u abs_max
                             -----------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------
%closure
%context
%this
../deps/v8/src/compiler/ast-graph-builder.cc
!shared_info.is_null()
(depth_)==(builder_->environment()->context_chain_length())
../deps/v8/src/compiler/ast-loop-assignment-analyzer.cc
var->IsStackAllocated()
../deps/v8/src/compiler/coalesced-live-ranges.cc
!range_to_evict->IsFixed()
Evicted range %d.
-- B%d start%s%s%s%s
 (deferred)
 (no frame)
 (construct frame)
 (deconstruct frame)
 (loop up to %d)
 (in loop %d)
-- Out of line code --
-- %s:%d:%d --
-- <unknown>:%d:%d --
../deps/v8/src/compiler/code-generator.cc
deoptimization_states_[i]
slots <= (1 << kStackSlotsBitCount)
offset <= (1 << kSafepointTableOffsetBitCount)
True
False
Caught
Uncaught
Switch
IfValue
Start
Loop
Merge
Parameter
OsrValue
Int32Constant
Int64Constant
Float32Constant
Float64Constant
ExternalConstant
NumberConstant
HeapConstant
Select
EffectPhi
EffectSet
ValueEffect
Finish
StateValues
TypedStateValues
FrameState
Projection
Call
TailCall
Dead
IfTrue
IfFalse
IfSuccess
IfDefault
Throw
Deoptimize
Return
Terminate
OsrNormalEntry
OsrLoopEntry
IfException
Branch
CEQ: Pre-visit of #%d:%s
  Assigned DFS number is %zu
CEQ: Mid-visit of #%d:%s
  Assigned class number is %zu
CEQ: Post-visit of #%d:%s
CEQ: Backedge from #%d:%s to #%d:%s
  BList erased: {%d->%d}
  BList: 
{%d->%d} 
Ignore
Push(
PokeAt(
JS_FRAME
ARGUMENTS_ADAPTOR
DeadLink: 
) -> 
turbo-%s
turbo-%p
turbo-none-%s
%s.%s
%s-%s.%s
"nodes":[
"edges":[
  subgraph cluster_BasicBlock
  ID
    shape="record"
    style="diagonals"
    style="rounded"
    style="filled"
    fillcolor="#999999"
    label="{{#
<>|{}
>X #
>F #
>E #
>C #
:n -> ID
constraint=false, 
style=bold, 
style=dotted, 
style=dashed, 
 -> ID
:s [color=transparent, 
digraph D {
  node [fontsize=8,height=0.25]
  rankdir="BT"
  ranksep="1.2 equally"
  overlap="false"
  splines="true"
  concentrate="true"
compilation
method "
stub
 Ctx:
 FS:
 Eff:
 Ctrl:
 type:
block
from_bci
to_bci
predecessors
successors
xhandlers
flags
dominator
loop_depth
first_lir_id
last_lir_id
states
locals
size
 pos:
 <|@
0 0 
 Goto
intervals
fixed
 "const(nostack):
 "double_stack:
 "stack:
{"id":
,"label":"
,"rankInputs":[0,
,"rankWithInput":[
,"rankInputs":[
,"rankInputs":[0]
,"pos":
,"opcode":"
,"control":
,"upper_type":"
,"lower_type":"
context
frame-state
effect
control
{"source":
,"target":
,"index":
,"type":"
begin_
end_
xmm1
xmm2
xmm3
xmm4
xmm5
xmm6
xmm7
xmm8
xmm9
xmm10
xmm11
xmm12
xmm13
xmm14
xmm15
null
../deps/v8/src/compiler/graph.cc
!base::bits::UnsignedAddOverflow32(id, 1, &next_node_id_)
Scheduling live range %d.
Assigning register %s to live range %d
Assigning %s to range %d
Attempting to allocate live range %d
Found free register %s for live range %d
Found evictable register %s for live range %d
Live range %d is defined by a spill operand.
../deps/v8/src/compiler/greedy-allocator.cc
scheduler().empty()
allocations_.empty()
Begin allocating function %s with the Greedy Allocator
End allocating function %s with the Greedy Allocator
range->CanBeSpilled(start)
../deps/v8/src/compiler/instruction-selector.cc
Unexpected operator #%d:%s @ node #%d
../deps/v8/src/compiler/machine-type.h
base::bits::IsPowerOfTwo32(result)
[constant:
[immediate:
[stack:
[double_stack:
|w32
|w64
|f32
|f64
ArchCallCodeObject
ArchTailCallCodeObject
ArchCallJSFunction
ArchTailCallJSFunction
ArchPrepareCallCFunction
ArchCallCFunction
ArchJmp
ArchLookupSwitch
ArchTableSwitch
ArchNop
ArchDeoptimize
ArchRet
ArchStackPointer
ArchFramePointer
ArchTruncateDoubleToI
CheckedLoadInt8
CheckedLoadUint8
CheckedLoadInt16
CheckedLoadUint16
CheckedLoadWord32
CheckedLoadFloat32
CheckedLoadFloat64
CheckedStoreWord8
CheckedStoreWord16
CheckedStoreWord32
CheckedStoreFloat32
CheckedStoreFloat64
X64Add
X64Add32
X64And
X64And32
X64Cmp
X64Cmp32
X64Test
X64Test32
X64Or
X64Or32
X64Xor
X64Xor32
X64Sub
X64Sub32
X64Imul
X64Imul32
X64ImulHigh32
X64UmulHigh32
X64Idiv
X64Idiv32
X64Udiv
X64Udiv32
X64Not
X64Not32
X64Neg
X64Neg32
X64Shl
X64Shl32
X64Shr
X64Shr32
X64Sar
X64Sar32
X64Ror
X64Ror32
X64Lzcnt32
SSEFloat32Cmp
SSEFloat32Add
SSEFloat32Sub
SSEFloat32Mul
SSEFloat32Div
SSEFloat32Abs
SSEFloat32Neg
SSEFloat32Sqrt
SSEFloat32Max
SSEFloat32Min
SSEFloat32ToFloat64
SSEFloat64Cmp
SSEFloat64Add
SSEFloat64Sub
SSEFloat64Mul
SSEFloat64Div
SSEFloat64Mod
SSEFloat64Abs
SSEFloat64Neg
SSEFloat64Sqrt
SSEFloat64Round
SSEFloat64Max
SSEFloat64Min
SSEFloat64ToFloat32
SSEFloat64ToInt32
SSEFloat64ToUint32
SSEInt32ToFloat64
SSEUint32ToFloat64
SSEFloat64ExtractLowWord32
SSEFloat64ExtractHighWord32
SSEFloat64InsertLowWord32
SSEFloat64InsertHighWord32
SSEFloat64LoadLowWord32
AVXFloat32Cmp
AVXFloat32Add
AVXFloat32Sub
AVXFloat32Mul
AVXFloat32Div
AVXFloat32Max
AVXFloat32Min
AVXFloat64Cmp
AVXFloat64Add
AVXFloat64Sub
AVXFloat64Mul
AVXFloat64Div
AVXFloat64Max
AVXFloat64Min
AVXFloat64Abs
AVXFloat64Neg
AVXFloat32Abs
AVXFloat32Neg
X64Movsxbl
X64Movzxbl
X64Movb
X64Movsxwl
X64Movzxwl
X64Movw
X64Movl
X64Movsxlq
X64Movq
X64Movsd
X64Movss
X64Lea32
X64Lea
X64Dec32
X64Inc32
X64Push
X64Poke
X64StoreWriteBarrier
X64StackCheck
MR1I
MR2I
MR4I
MR8I
branch
equal
not equal
signed less than
signed greater than or equal
signed less than or equal
signed greater than
unsigned less than
unsigned greater than or equal
unsigned less than or equal
unsigned greater than
unordered equal
unordered not equal
overflow
not overflow
gap 
          
) = 
 && 
 if 
../deps/v8/src/compiler/instruction.cc
(virtual_register)!=(InstructionOperand::kInvalidVirtualRegister)
IMM#
CST#
block->rpo_number() == rpo
: AO#
 loop blocks: [
  instructions: [
  predecessors:
     phi: 
Not inlining %s into %s because of different native contexts
Not inlining %s into %s because call is recursive
Not inlining %s into %s because inlinee uses arguments array
Inlining %s into %s
Sentinel
, ALLOW_TAIL_CALLS
JSCallFunction
JSCallRuntime
JSCallConstruct
JSLoadNamed
JSLoadProperty
JSStoreNamed
JSStoreProperty
JSDeleteProperty
JSLoadGlobal
JSStoreGlobal
JSLoadContext
JSStoreContext
JSLoadDynamicGlobal
JSLoadDynamicContext
JSCreateClosure
JSCreateLiteralArray
JSCreateLiteralObject
JSCreateCatchContext
sloppy
strong
JSEqual
JSNotEqual
JSStrictEqual
JSStrictNotEqual
JSUnaryNot
JSToBoolean
JSToNumber
JSToString
JSToName
JSToObject
JSYield
JSCreate
JSHasProperty
JSTypeOf
JSInstanceOf
JSForInDone
JSForInNext
JSForInPrepare
JSForInStep
JSStackCheck
JSCreateFunctionContext
JSCreateWithContext
JSCreateBlockContext
JSCreateModuleContext
JSCreateScriptContext
JSLessThan
JSGreaterThan
JSLessThanOrEqual
JSGreaterThanOrEqual
JSBitwiseOr
JSBitwiseXor
JSBitwiseAnd
JSShiftLeft
JSShiftRight
JSShiftRightLogical
JSAdd
JSSubtract
JSMultiply
JSDivide
JSModulus
../deps/v8/src/compiler/js-typed-lowering.cc
(k)<((sizeof(ArraySizeHelper(shifted_int32_ranges_))))
jt [%d] B%d
  parallel move
  flags
  nop
  jmp
  other
B%d 
-> B%d
jt-fw nop @%d
  xx %d
  fw %d -> %d (recurse)
  fw %d -> %d (cycle)
  fw %d -> %d (forward)
Code
Addr
Block 
; predecessors: 
    
- Lookup 
- Bind 
- Checkpoint 
    Live set: 
 #%d:%s
Loop %d headed at #%d
Loop depth = %d 
 H#%d
 B#%d
JavaScript
RoundToZero
NoWriteBarrier
FullWriteBarrier
Load
Store
CheckedLoad
CheckedStore
Word32And
Word32Or
Word32Xor
Word32Shl
Word32Shr
Word32Sar
Word32Ror
Word32Equal
Word32Clz
Word64And
Word64Or
Word64Xor
Word64Shl
Word64Shr
Word64Sar
Word64Ror
Word64Equal
Int32Add
Int32AddWithOverflow
Int32Sub
Int32SubWithOverflow
Int32Mul
Int32MulHigh
Int32Div
Int32Mod
Int32LessThan
Int32LessThanOrEqual
Uint32Div
Uint32LessThan
Uint32LessThanOrEqual
Uint32Mod
Uint32MulHigh
Int64Add
Int64Sub
Int64Mul
Int64Div
Int64Mod
Int64LessThan
Int64LessThanOrEqual
Uint64Div
Uint64Mod
Uint64LessThan
Uint64LessThanOrEqual
ChangeFloat32ToFloat64
ChangeFloat64ToInt32
ChangeFloat64ToUint32
ChangeInt32ToFloat64
ChangeInt32ToInt64
ChangeUint32ToFloat64
ChangeUint32ToUint64
TruncateFloat64ToFloat32
TruncateInt64ToInt32
Float32Abs
Float32Add
Float32Sub
Float32Mul
Float32Div
Float32Sqrt
Float64Abs
Float64Add
Float64Sub
Float64Mul
Float64Div
Float64Mod
Float64Sqrt
Float32Equal
Float32LessThan
Float32LessThanOrEqual
Float64Equal
Float64LessThan
Float64LessThanOrEqual
Float64ExtractLowWord32
Float64ExtractHighWord32
Float64InsertLowWord32
Float64InsertHighWord32
LoadStackPointer
LoadFramePointer
Float32Max
Float32Min
Float64Max
Float64Min
Float64RoundDown
Float64RoundTruncate
Float64RoundTiesAway
TruncateFloat64ToInt32
kRepBit
kRepWord8
kRepWord16
kRepWord32
kRepWord64
kRepFloat32
kRepFloat64
kRepTagged
kTypeBool
kTypeInt32
kTypeUint32
kTypeInt64
kTypeUint64
kTypeNumber
kTypeAny
NumberEqual
NumberLessThan
NumberLessThanOrEqual
ReferenceEqual
StringEqual
StringLessThan
StringLessThanOrEqual
BooleanNot
BooleanToNumber
NumberAdd
NumberSubtract
NumberMultiply
NumberDivide
NumberModulus
NumberShiftLeft
NumberShiftRight
NumberShiftRightLogical
NumberToInt32
NumberToUint32
PlainPrimitiveToNumber
ChangeTaggedToInt32
ChangeTaggedToUint32
ChangeTaggedToFloat64
ChangeInt32ToTagged
ChangeUint32ToTagged
ChangeFloat64ToTagged
ChangeBoolToBit
ChangeBitToBool
Allocate
LoadField
LoadBuffer
LoadElement
StoreField
StoreBuffer
StoreElement
ObjectIsSmi
ObjectIsNonNegativeSmi
UnknownOpcode
../deps/v8/src/compiler/operator.cc
(val)<=(std::numeric_limits<N>::max())
../deps/v8/src/compiler/osr.cc
osr_normal_entry
!osr_loop
osr_loop
(0)!=(live_input_count)
-- Graph after OSR duplication -- 
initializing
json
{"function":"
", "sourcePosition":
, "source":"
"phases":[
graph creation
---------------------------------------------------
Begin compiling method 
 using Turbofan
Initial untyped
OSR deconstruction
Inlined
Early trimmed
Typed
lowering
Lowered typed
Loop peeled
JSType feedback
Lowered simplified
Control flow optimized
Lowered changes
Lowered generic
Late trimmed
block building
test codegen
Machine
../deps/v8/src/compiler/pipeline.cc
CodeGen
register allocation
code generation
{"name":"disassembly","type":"disassembly","data":"
"nodePositions":
Finished compiling method 
----- Instruction sequence before register allocation -----
!data->register_allocation_data()->ExistsUseWithoutDefinition()
----- Instruction sequence after register allocation -----
init pipeline data
{"name":"Schedule","type":"schedule","data":"
-- Schedule --------------------------------------
{"name":"
","type":"graph","data":
-- Graph after 
 -- 
loop assignment analysis
graph builder
inlining
early graph trimming
typer
typed lowering
stress loop peeling
type feedback specializing
../deps/v8/src/compiler/js-type-feedback.h
(js_type_feedback) != nullptr
simplified lowering
control flow optimization
change lowering
generic lowering
late graph trimming
scheduling
select instructions
jump threading
generate code
meet register constraints
resolve phis
build live ranges
allocate general registers
allocate double registers
locate spill slots
frame elision
assign spill slots
commit assignment
populate pointer maps
connect ranges
resolve control flow
optimize moves
../deps/v8/src/compiler/register-allocator.cc
Start() <= pos->pos()
pos->pos() <= End()
interval != nullptr
Shorten live range %d to [%d
Ensure live range %d in interval [%d %d[
Add to live range %d interval [%d %d[
Add to live range %d use position %d
Range: 
phi 
nlphi 
Register allocator error: live v%d reached first block.
  (first use is at %d)
  (function: %s)
Allocating fixed reg for op %d
Fixed reg is tagged at %d
hint.second->IsResolved()
Splitting live range %d at %d
Splitting live range %d in position between [%d, %d]
Spilling live range %d
Processing interval %d start=%d
Live range %d already has a spill operand
Add live range %d to active
Add live range %d to inactive
Add live range %d to unhandled at %d
Add live range %d to unhandled at start
Add live range %d to unhandled unsorted at end
Sort unhandled
Moving live range %d from active to handled
Moving live range %d from active to inactive
Moving live range %d from inactive to handled
Moving live range %d from inactive to active
Found reg hint %s (free until [%d) for live range %d (end %d[).
Assigning preferred reg %s to live range %d
Assigning free reg %s to live range %d
Assigning blocked reg %s to live range %d
merged
start < end
Pointer for range %d (spilled at %d) at safe point %d
Pointer in register for range %d (start at %d) at safe point %d
../deps/v8/src/compiler/register-allocator-verifier.cc
(kSameAsFirst)!=(constraint.type_)
(InstructionOperand::kInvalidVirtualRegister)!=(constraint.virtual_register_)
(kImmediate)!=(constraint.type_)
(kConstant)!=(constraint.type_)
instr->InputCount() > 0
sequence()->instructions().size() == constraints()->size()
(instr)==(*instr_it)
operand_count == OperandCount(instr)
op->IsUnallocated()
op->IsConstant()
(ConstantOperand::cast(op)->virtual_register())==(constraint->value_)
op->IsImmediate()
(value)==(constraint->value_)
op->IsRegister()
(RegisterOperand::cast(op)->index())==(constraint->value_)
op->IsDoubleRegister()
(DoubleRegisterOperand::cast(op)->index())==(constraint->value_)
op->IsStackSlot()
(StackSlotOperand::cast(op)->index())==(constraint->value_)
op->IsDoubleStackSlot()
op->IsRegister() || op->IsStackSlot()
op->IsDoubleRegister() || op->IsDoubleStackSlot()
instr->GetParallelMove(inner_pos) == nullptr
move->source().IsAllocated() || move->source().IsConstant()
move->destination().IsAllocated()
!IsPhi(first_pred_vreg)
res.second
(kInvalidVreg)==(succ_val.second->define_vreg)
(succ_vreg)==(pred_val.second->use_vreg)
(succ_vreg)==(pred_val.second->define_vreg)
(succ_vreg)==(pred_val.second->succ_vreg)
less(o.first, it->first)
to_init->map().empty()
predecessor_index < block->rpo_number().ToSize()
cur != map().end()
it != map().end()
(v->define_vreg)==(use_vreg)
(v->use_vreg)==(use_vreg)
(v->succ_vreg)==(use_vreg)
v->define_vreg == use_vreg || v->use_vreg == use_vreg
it != phi_map_.end()
(kInvalidVreg)==(v->define_vreg)
v->define_vreg == phi->first_pred_vreg
goto
switch
deoptimize
tailcall
return
throw
Planning #
 for future add to B
Adding #
 to B
--- BLOCK B
 <- 
 ---
Goto
 -> 
  Use count of #%d:%s (used by #%d:%s)++ = %d
  Use count of #%d:%s (used by #%d:%s)-- = %d
    newly eligible #%d:%s
--- CREATING CFG -------------------------------------------
--- COMPUTING SPECIAL RPO ----------------------------------
Block id:%d's idom is id:%d, depth = %d
--- IMMEDIATE BLOCK DOMINATORS -----------------------------
--- PREPARE USES -------------------------------------------
--- SCHEDULE EARLY -----------------------------------------
roots: 
#%d:%s 
--- SCHEDULE LATE ------------------------------------------
--- SEAL FINAL SCHEDULE ------------------------------------
--- FUSE FLOATING CONTROL ----------------------------------
Schedule before control flow fusion:
propagation roots: 
Schedule after control flow fusion:
Move planned nodes from id:%d to id:%d
Create block id:%d for #%d:%s
Connect #%d:%s, id:%d -> end
Connect #%d:%s, id:%d -> id:%d
../deps/v8/src/compiler/scheduler.cc
(kBlockUnvisited1)==(schedule_->start()->loop_number())
(kBlockUnvisited1)==(schedule_->start()->rpo_number())
(0)==(static_cast<int>(schedule_->rpo_order()->size()))
id:%d is a loop header, increment loop depth to %d
id:%d is not in a loop (depth == %d)
id:%d has loop header id:%d, (depth == %d)
Scheduling fixed position node #%d:%s
Fixing #%d:%s minimum_block = id:%d, dominator_depth = %d
Propagating #%d:%s minimum_block = id:%d, dominator_depth = %d
Scheduling #%d:%s
Schedule late of #%d:%s is id:%d at loop depth %d, minimum = id:%d
  hoisting #%d:%s to block id:%d
  inspecting uses of coupled #%d:%s
  input@%d into a fixed phi #%d:%s
  input@%d into a fixed merge #%d:%s
  must dominate use #%d:%s in id:%d
  not splitting #%d:%s, it is used in id:%d
  not splitting #%d:%s, its common dominator id:%d is perfect
  pushing #%d:%s down to id:%d
  cloning #%d:%s for id:%d
clone #%d:%s -> #%d
Found SESE at #%d:%s
--{Propagation phase}--
 visit #%d: %s
  ==> output 
--{Simplified lowering phase}--
  initial: 
   queue?: 
   added: 
 inqueue: 
#%d:%-20s 
  change: #%d:%s(@%d #%d:%s) 
 from 
defer replacement #%d:%s with #%d:%s
  truncate-to-int32: #%d:%s(@%d #%d:%s) 
../deps/v8/src/compiler/representation-change.h
RepresentationChangerError: node #%d:%s of %s cannot be changed to %s
untagged base
tagged base
Uint8
Int8
Uint16
Int16
Uint32
Int32
Float32
Float64
Uint8Clamped
../deps/v8/src/compiler/state-values-utils.cc
current_depth_ < kMaxInlineDepth
other.done()
../deps/v8/src/compiler/verifier.cc
(input_count)==(node->InputCount())
frame_state->opcode() == IrOpcode::kFrameState || (node->opcode() == IrOpcode::kFrameState && frame_state->opcode() == IrOpcode::kStart)
IsDefUseChainLinkPresent(frame_state, node)
IsUseDefChainLinkPresent(frame_state, node)
IsDefUseChainLinkPresent(value, node)
IsUseDefChainLinkPresent(value, node)
IsDefUseChainLinkPresent(context, node)
IsUseDefChainLinkPresent(context, node)
IsDefUseChainLinkPresent(effect, node)
IsUseDefChainLinkPresent(effect, node)
IsDefUseChainLinkPresent(control, node)
IsUseDefChainLinkPresent(control, node)
!NodeProperties::IsValueEdge(edge) || use->opcode() == IrOpcode::kProjection || use->opcode() == IrOpcode::kParameter
(0)==(input_count)
node->op()->ValueOutputCount() == 0
node->op()->EffectOutputCount() == 0
node->op()->ControlOutputCount() == 0
use->opcode() == IrOpcode::kIfTrue || use->opcode() == IrOpcode::kIfFalse
(1)==(count_true)
(1)==(count_false)
(IrOpcode::kBranch)==(NodeProperties::GetControlInput(node, 0)->opcode())
!input->op()->HasProperty(Operator::kNoThrow)
(OpParameter<int32_t>(use->op()))!=(OpParameter<int32_t>(user->op()))
(1)<=(count_case)
(1)==(count_default)
(node->op()->ControlOutputCount())==(count_case + count_default)
(IrOpcode::kSwitch)==(NodeProperties::GetControlInput(node)->opcode())
(control_count)==(input_count)
(IrOpcode::kEnd)==(use->opcode())
(1)==(control_count)
(1)==(effect_count)
(2)==(input_count)
(IrOpcode::kLoop)==(NodeProperties::GetControlInput(node)->opcode())
(1)==(input_count)
(IrOpcode::kStart)==(start->opcode())
(-1)<=(index)
(index + 1)<(start->op()->ValueOutputCount())
(input->op()->ValueOutputCount())>(index)
(0)==(effect_count)
(0)==(control_count)
(3)==(value_count)
(value_count)==(control->op()->ControlInputCount())
(input_count)==(1 + value_count)
(0)==(value_count)
(effect_count)==(control->op()->ControlInputCount())
(input_count)==(1 + effect_count)
(1)<(effect_count)
bounds(ValueInput(node)).lower->Is(bounds(node).lower)
bounds(ValueInput(node)).upper->Is(bounds(node).upper)
(5)==(value_count)
(6)==(input_count)
bounds(node).upper->IsContext()
(graph->start()) != nullptr
(graph->end()) != nullptr
Node #%d:%s has duplicate projections #%d and #%d
(count)>=(rpo_order->size())
((*b))==(schedule->GetBlockById((*b)->id()))
(predecessor->rpo_number())>=(0)
(predecessor)==(schedule->GetBlockById(predecessor->id()))
(successor->rpo_number())>=(0)
(successor)==(schedule->GetBlockById(successor->id()))
(start)==(rpo_order->at(0))
(static_cast<int>(b))==(block->rpo_number())
(dom) == nullptr
(dom) != nullptr
(dom->rpo_number())<(block->rpo_number())
(block->rpo_number())>=(0)
(block)==(rpo_order->at(block->rpo_number()))
marked[rpo_order->at(b)->id().ToSize()]
Block B%d is not dominated by B%d
Block B%d is not immediately dominated by B%d
control->opcode() == IrOpcode::kMerge || control->opcode() == IrOpcode::kLoop
((*b))==(schedule->block(control))
(block)==(schedule->block(control))
GraphError: node #
 does not produce 
 output used by node #
TypeError: node #
 upper bound 
 is not 
 should never have a type
 must intersect 
(input @
) upper bound 
Node #%d:%s in B%d is not dominated by input@%d #%d:%s
Node #%d:%s in B%d is not dominated by control input #%d:%s
../deps/v8/src/compiler.cc
parse_info()
--- FUNCTION SOURCE (
) id{
} ---
--- END ---
INLINE (
} AS 
 AT 
Parser::ParseStatic(parse_info())
Compiler::Analyze(parse_info())
[compiling method 
 using TurboFan
 OSR
 using Crankshaft
[optimizing 
 - took %0.3f, %0.3f, %0.3f ms]
Compiled: %d functions with %d byte source size in %fms.
[Compiling and serializing took %0.3f ms]
[found optimized code for 
 at OSR AST id %d
[completed optimizing 
[aborted optimizing 
 because: %s]
(Code::FUNCTION)==(info->code()->kind())
Replacing with another optimized code
  ** Compilation queue full, will retry optimizing 
 later.
  ** Queued 
 for concurrent OSR at %d.
 for concurrent optimization.
../deps/v8/src/contexts.cc
used >= 0 && length > 0 && used < length
length < Smi::kMaxValue / 2
Code generation from strings disallowed for this context
-Infinity
Infinity
0123456789abcdefghijklmnopqrstuvwxyz
V8.DetachedContextAgeInGC
V8.GCIdleTimeAllottedInMS
V8.GCIdleTimeLimit.Overshot
V8.GCIdleTimeLimit.Undershot
V8.CodeCacheRejectReason
V8.GCCompactor
V8.GCScavenger
V8.GCContext
V8.GCIdleNotification
V8.GCIncrementalMarking
V8.GCLowMemoryNotification
V8.ParseMicroSeconds
V8.ParseLazyMicroSeconds
V8.PreParseMicroSeconds
V8.CompileMicroSeconds
V8.CompileEvalMicroSeconds
V8.CompileSerializeMicroSeconds
V8.CompileDeserializeMicroSeconds
V8.CompileScriptMicroSeconds
V8.CompileLazyMicroSeconds
V8.MemoryExternalFragmentationTotal
V8.MemoryExternalFragmentationOldSpace
V8.MemoryExternalFragmentationCodeSpace
V8.MemoryExternalFragmentationMapSpace
V8.MemoryExternalFragmentationLoSpace
V8.MemoryHeapFractionNewSpace
V8.MemoryHeapFractionOldSpace
V8.MemoryHeapFractionCodeSpace
V8.MemoryHeapFractionMapSpace
V8.MemoryHeapFractionLoSpace
V8.CodegenFractionCrankshaft
V8.MemoryHeapSampleTotalCommitted
V8.MemoryHeapSampleTotalUsed
V8.MemoryHeapSampleMapSpaceCommitted
V8.MemoryHeapSampleCodeSpaceCommitted
V8.MemoryHeapSampleMaximumCommitted
V8.MemoryHeapCommitted
V8.MemoryHeapUsed
c:V8.GlobalHandles
c:V8.OsMemoryAllocated
c:V8.NormalizedMaps
c:V8.ObjectPropertiesToDictionary
c:V8.ObjectElementsToDictionary
c:V8.AliveAfterLastGC
c:V8.ObjsSinceLastYoung
c:V8.ObjsSinceLastFull
c:V8.StringTableCapacity
c:V8.NumberOfSymbols
c:V8.ScriptWrappers
c:V8.CallInitializeStubs
c:V8.CallPreMonomorphicStubs
c:V8.CallNormalStubs
c:V8.CallMegamorphicStubs
c:V8.InlinedCopiedElements
c:V8.ArgumentsAdaptors
c:V8.CompilationCacheHits
c:V8.CompilationCacheMisses
c:V8.StringConstructorCalls
c:V8.StringConstructorConversions
c:V8.StringConstructorCachedNumber
c:V8.StringConstructorStringValue
c:V8.StringConstructorGCRequired
c:V8.TotalEvalSize
c:V8.TotalLoadSize
c:V8.TotalParseSize
c:V8.TotalPreparseSkipped
c:V8.TotalPreparseSymbolSkipped
c:V8.TotalCompileSize
c:V8.TotalFullCodegenSourceSize
c:V8.ContextsCreatedFromScratch
c:V8.ContextsCreatedBySnapshot
c:V8.PcToCode
c:V8.PcToCodeCached
c:V8.StoreBufferCompactions
c:V8.StoreBufferOverflows
c:V8.CodeStubs
c:V8.TotalStubsCodeSize
c:V8.TotalCompiledCodeSize
c:V8.GCCompactorCausedByRequest
c:V8.GCCompactorCausedByPromotedData
c:V8.GCCompactorCausedByOldspaceExhaustion
c:V8.GCLastResortFromJS
c:V8.GCLastResortFromHandles
c:V8.KeyedLoadGenericSmi
c:V8.KeyedLoadGenericSymbol
c:V8.KeyedLoadGenericLookupCache
c:V8.KeyedLoadGenericSlow
c:V8.KeyedLoadPolymorphicStubs
c:V8.KeyedLoadExternalArraySlow
c:V8.KeyedCallGenericSmiFast
c:V8.KeyedCallGenericSmiDict
c:V8.KeyedCallGenericLookupCache
c:V8.KeyedCallGenericLookupDict
c:V8.KeyedCallGenericSlow
c:V8.KeyedCallGenericSlowLoad
c:V8.NamedLoadGlobalStub
c:V8.NamedStoreGlobalInline
c:V8.NamedStoreGlobalInlineMiss
c:V8.KeyedStorePolymorphicStubs
c:V8.KeyedStoreExternalArraySlow
c:V8.StoreNormalMiss
c:V8.StoreNormalHit
c:V8.COWArraysCreatedStub
c:V8.COWArraysCreatedRuntime
c:V8.COWArraysConverted
c:V8.CallMiss
c:V8.KeyedCallMiss
c:V8.LoadMiss
c:V8.KeyedLoadMiss
c:V8.CallConst
c:V8.CallConstFastApi
c:V8.CallConstInterceptor
c:V8.CallConstInterceptorFastApi
c:V8.CallGlobalInline
c:V8.CallGlobalInlineMiss
c:V8.ConstructedObjects
c:V8.ConstructedObjectsRuntime
c:V8.NegativeLookups
c:V8.NegativeLookupsMiss
c:V8.MegamorphicStubCacheProbes
c:V8.MegamorphicStubCacheMisses
c:V8.MegamorphicStubCacheUpdates
c:V8.ArrayFunctionRuntime
c:V8.ArrayFunctionNative
c:V8.ForIn
c:V8.EnumCacheHits
c:V8.EnumCacheMisses
c:V8.FastNewClosureTotal
c:V8.FastNewClosureTryOptimized
c:V8.FastNewClosureInstallOptimized
c:V8.StringAddRuntime
c:V8.StringAddNative
c:V8.StringAddRuntimeExtToOneByte
c:V8.SubStringRuntime
c:V8.SubStringNative
c:V8.StringAddMakeTwoChar
c:V8.StringCompareNative
c:V8.StringCompareRuntime
c:V8.RegExpEntryRuntime
c:V8.RegExpEntryNative
c:V8.NumberToStringNative
c:V8.NumberToStringRuntime
c:V8.MathAcos
c:V8.MathAsin
c:V8.MathAtan
c:V8.MathAtan2
c:V8.MathClz32
c:V8.MathExp
c:V8.MathFloor
c:V8.MathLog
c:V8.MathPow
c:V8.MathRound
c:V8.MathSqrt
c:V8.StackInterrupts
c:V8.RuntimeProfilerTicks
c:V8.BoundsChecksEliminated
c:V8.BoundsChecksHoisted
c:V8.SoftDeoptsRequested
c:V8.SoftDeoptsInserted
c:V8.SoftDeoptsExecuted
c:V8.WriteBarriersDynamic
c:V8.WriteBarriersStatic
c:V8.MemoryNewSpaceBytesAvailable
c:V8.MemoryNewSpaceBytesCommitted
c:V8.MemoryNewSpaceBytesUsed
c:V8.MemoryOldSpaceBytesAvailable
c:V8.MemoryOldSpaceBytesCommitted
c:V8.MemoryOldSpaceBytesUsed
c:V8.MemoryCodeSpaceBytesAvailable
c:V8.MemoryCodeSpaceBytesCommitted
c:V8.MemoryCodeSpaceBytesUsed
c:V8.MemoryMapSpaceBytesAvailable
c:V8.MemoryMapSpaceBytesCommitted
c:V8.MemoryMapSpaceBytesUsed
c:V8.MemoryLoSpaceBytesAvailable
c:V8.MemoryLoSpaceBytesCommitted
c:V8.MemoryLoSpaceBytesUsed
c:V8.CountOf_STRING_TYPE
c:V8.SizeOf_STRING_TYPE
c:V8.CountOf_ONE_BYTE_STRING_TYPE
c:V8.SizeOf_ONE_BYTE_STRING_TYPE
c:V8.CountOf_CONS_STRING_TYPE
c:V8.SizeOf_CONS_STRING_TYPE
c:V8.CountOf_CONS_ONE_BYTE_STRING_TYPE
c:V8.SizeOf_CONS_ONE_BYTE_STRING_TYPE
c:V8.CountOf_SLICED_STRING_TYPE
c:V8.SizeOf_SLICED_STRING_TYPE
c:V8.CountOf_SLICED_ONE_BYTE_STRING_TYPE
c:V8.SizeOf_SLICED_ONE_BYTE_STRING_TYPE
c:V8.CountOf_EXTERNAL_STRING_TYPE
c:V8.SizeOf_EXTERNAL_STRING_TYPE
c:V8.CountOf_EXTERNAL_ONE_BYTE_STRING_TYPE
c:V8.SizeOf_EXTERNAL_ONE_BYTE_STRING_TYPE
c:V8.CountOf_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
c:V8.SizeOf_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
c:V8.CountOf_SHORT_EXTERNAL_STRING_TYPE
c:V8.SizeOf_SHORT_EXTERNAL_STRING_TYPE
c:V8.CountOf_SHORT_EXTERNAL_ONE_BYTE_STRING_TYPE
c:V8.SizeOf_SHORT_EXTERNAL_ONE_BYTE_STRING_TYPE
c:V8.CountOf_SHORT_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
c:V8.SizeOf_SHORT_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
c:V8.CountOf_INTERNALIZED_STRING_TYPE
c:V8.SizeOf_INTERNALIZED_STRING_TYPE
c:V8.CountOf_ONE_BYTE_INTERNALIZED_STRING_TYPE
c:V8.SizeOf_ONE_BYTE_INTERNALIZED_STRING_TYPE
c:V8.CountOf_EXTERNAL_INTERNALIZED_STRING_TYPE
c:V8.SizeOf_EXTERNAL_INTERNALIZED_STRING_TYPE
c:V8.CountOf_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
c:V8.SizeOf_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
c:V8.CountOf_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
c:V8.SizeOf_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
c:V8.CountOf_SHORT_EXTERNAL_INTERNALIZED_STRING_TYPE
c:V8.SizeOf_SHORT_EXTERNAL_INTERNALIZED_STRING_TYPE
c:V8.CountOf_SHORT_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
c:V8.SizeOf_SHORT_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
c:V8.CountOf_SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
c:V8.SizeOf_SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
c:V8.CountOf_SYMBOL_TYPE
c:V8.SizeOf_SYMBOL_TYPE
c:V8.CountOf_MAP_TYPE
c:V8.SizeOf_MAP_TYPE
c:V8.CountOf_CODE_TYPE
c:V8.SizeOf_CODE_TYPE
c:V8.CountOf_ODDBALL_TYPE
c:V8.SizeOf_ODDBALL_TYPE
c:V8.CountOf_CELL_TYPE
c:V8.SizeOf_CELL_TYPE
c:V8.CountOf_PROPERTY_CELL_TYPE
c:V8.SizeOf_PROPERTY_CELL_TYPE
c:V8.CountOf_HEAP_NUMBER_TYPE
c:V8.SizeOf_HEAP_NUMBER_TYPE
c:V8.CountOf_MUTABLE_HEAP_NUMBER_TYPE
c:V8.SizeOf_MUTABLE_HEAP_NUMBER_TYPE
c:V8.CountOf_FLOAT32X4_TYPE
c:V8.SizeOf_FLOAT32X4_TYPE
c:V8.CountOf_FOREIGN_TYPE
c:V8.SizeOf_FOREIGN_TYPE
c:V8.CountOf_BYTE_ARRAY_TYPE
c:V8.SizeOf_BYTE_ARRAY_TYPE
c:V8.CountOf_FREE_SPACE_TYPE
c:V8.SizeOf_FREE_SPACE_TYPE
c:V8.CountOf_EXTERNAL_INT8_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_INT8_ARRAY_TYPE
c:V8.CountOf_EXTERNAL_UINT8_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_UINT8_ARRAY_TYPE
c:V8.CountOf_EXTERNAL_INT16_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_INT16_ARRAY_TYPE
c:V8.CountOf_EXTERNAL_UINT16_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_UINT16_ARRAY_TYPE
c:V8.CountOf_EXTERNAL_INT32_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_INT32_ARRAY_TYPE
c:V8.CountOf_EXTERNAL_UINT32_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_UINT32_ARRAY_TYPE
c:V8.CountOf_EXTERNAL_FLOAT32_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_FLOAT32_ARRAY_TYPE
c:V8.CountOf_EXTERNAL_FLOAT64_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_FLOAT64_ARRAY_TYPE
c:V8.CountOf_EXTERNAL_UINT8_CLAMPED_ARRAY_TYPE
c:V8.SizeOf_EXTERNAL_UINT8_CLAMPED_ARRAY_TYPE
c:V8.CountOf_FIXED_INT8_ARRAY_TYPE
c:V8.SizeOf_FIXED_INT8_ARRAY_TYPE
c:V8.CountOf_FIXED_UINT8_ARRAY_TYPE
c:V8.SizeOf_FIXED_UINT8_ARRAY_TYPE
c:V8.CountOf_FIXED_INT16_ARRAY_TYPE
c:V8.SizeOf_FIXED_INT16_ARRAY_TYPE
c:V8.CountOf_FIXED_UINT16_ARRAY_TYPE
c:V8.SizeOf_FIXED_UINT16_ARRAY_TYPE
c:V8.CountOf_FIXED_INT32_ARRAY_TYPE
c:V8.SizeOf_FIXED_INT32_ARRAY_TYPE
c:V8.CountOf_FIXED_UINT32_ARRAY_TYPE
c:V8.SizeOf_FIXED_UINT32_ARRAY_TYPE
c:V8.CountOf_FIXED_FLOAT32_ARRAY_TYPE
c:V8.SizeOf_FIXED_FLOAT32_ARRAY_TYPE
c:V8.CountOf_FIXED_FLOAT64_ARRAY_TYPE
c:V8.SizeOf_FIXED_FLOAT64_ARRAY_TYPE
c:V8.CountOf_FIXED_UINT8_CLAMPED_ARRAY_TYPE
c:V8.SizeOf_FIXED_UINT8_CLAMPED_ARRAY_TYPE
c:V8.CountOf_FILLER_TYPE
c:V8.SizeOf_FILLER_TYPE
c:V8.CountOf_DECLARED_ACCESSOR_DESCRIPTOR_TYPE
c:V8.SizeOf_DECLARED_ACCESSOR_DESCRIPTOR_TYPE
c:V8.CountOf_DECLARED_ACCESSOR_INFO_TYPE
c:V8.SizeOf_DECLARED_ACCESSOR_INFO_TYPE
c:V8.CountOf_EXECUTABLE_ACCESSOR_INFO_TYPE
c:V8.SizeOf_EXECUTABLE_ACCESSOR_INFO_TYPE
c:V8.CountOf_ACCESSOR_PAIR_TYPE
c:V8.SizeOf_ACCESSOR_PAIR_TYPE
c:V8.CountOf_ACCESS_CHECK_INFO_TYPE
c:V8.SizeOf_ACCESS_CHECK_INFO_TYPE
c:V8.CountOf_INTERCEPTOR_INFO_TYPE
c:V8.SizeOf_INTERCEPTOR_INFO_TYPE
c:V8.CountOf_CALL_HANDLER_INFO_TYPE
c:V8.SizeOf_CALL_HANDLER_INFO_TYPE
c:V8.CountOf_FUNCTION_TEMPLATE_INFO_TYPE
c:V8.SizeOf_FUNCTION_TEMPLATE_INFO_TYPE
c:V8.CountOf_OBJECT_TEMPLATE_INFO_TYPE
c:V8.SizeOf_OBJECT_TEMPLATE_INFO_TYPE
c:V8.CountOf_SIGNATURE_INFO_TYPE
c:V8.SizeOf_SIGNATURE_INFO_TYPE
c:V8.CountOf_TYPE_SWITCH_INFO_TYPE
c:V8.SizeOf_TYPE_SWITCH_INFO_TYPE
c:V8.CountOf_ALLOCATION_MEMENTO_TYPE
c:V8.SizeOf_ALLOCATION_MEMENTO_TYPE
c:V8.CountOf_ALLOCATION_SITE_TYPE
c:V8.SizeOf_ALLOCATION_SITE_TYPE
c:V8.CountOf_SCRIPT_TYPE
c:V8.SizeOf_SCRIPT_TYPE
c:V8.CountOf_CODE_CACHE_TYPE
c:V8.SizeOf_CODE_CACHE_TYPE
c:V8.CountOf_POLYMORPHIC_CODE_CACHE_TYPE
c:V8.SizeOf_POLYMORPHIC_CODE_CACHE_TYPE
c:V8.CountOf_TYPE_FEEDBACK_INFO_TYPE
c:V8.SizeOf_TYPE_FEEDBACK_INFO_TYPE
c:V8.CountOf_ALIASED_ARGUMENTS_ENTRY_TYPE
c:V8.SizeOf_ALIASED_ARGUMENTS_ENTRY_TYPE
c:V8.CountOf_BOX_TYPE
c:V8.SizeOf_BOX_TYPE
c:V8.CountOf_PROTOTYPE_INFO_TYPE
c:V8.SizeOf_PROTOTYPE_INFO_TYPE
c:V8.CountOf_FIXED_ARRAY_TYPE
c:V8.SizeOf_FIXED_ARRAY_TYPE
c:V8.CountOf_FIXED_DOUBLE_ARRAY_TYPE
c:V8.SizeOf_FIXED_DOUBLE_ARRAY_TYPE
c:V8.CountOf_SHARED_FUNCTION_INFO_TYPE
c:V8.SizeOf_SHARED_FUNCTION_INFO_TYPE
c:V8.CountOf_WEAK_CELL_TYPE
c:V8.SizeOf_WEAK_CELL_TYPE
c:V8.CountOf_JS_MESSAGE_OBJECT_TYPE
c:V8.SizeOf_JS_MESSAGE_OBJECT_TYPE
c:V8.CountOf_JS_VALUE_TYPE
c:V8.SizeOf_JS_VALUE_TYPE
c:V8.CountOf_JS_DATE_TYPE
c:V8.SizeOf_JS_DATE_TYPE
c:V8.CountOf_JS_OBJECT_TYPE
c:V8.SizeOf_JS_OBJECT_TYPE
c:V8.CountOf_JS_CONTEXT_EXTENSION_OBJECT_TYPE
c:V8.SizeOf_JS_CONTEXT_EXTENSION_OBJECT_TYPE
c:V8.CountOf_JS_GENERATOR_OBJECT_TYPE
c:V8.SizeOf_JS_GENERATOR_OBJECT_TYPE
c:V8.CountOf_JS_MODULE_TYPE
c:V8.SizeOf_JS_MODULE_TYPE
c:V8.CountOf_JS_GLOBAL_OBJECT_TYPE
c:V8.SizeOf_JS_GLOBAL_OBJECT_TYPE
c:V8.CountOf_JS_BUILTINS_OBJECT_TYPE
c:V8.SizeOf_JS_BUILTINS_OBJECT_TYPE
c:V8.CountOf_JS_GLOBAL_PROXY_TYPE
c:V8.SizeOf_JS_GLOBAL_PROXY_TYPE
c:V8.CountOf_JS_ARRAY_TYPE
c:V8.SizeOf_JS_ARRAY_TYPE
c:V8.CountOf_JS_ARRAY_BUFFER_TYPE
c:V8.SizeOf_JS_ARRAY_BUFFER_TYPE
c:V8.CountOf_JS_TYPED_ARRAY_TYPE
c:V8.SizeOf_JS_TYPED_ARRAY_TYPE
c:V8.CountOf_JS_DATA_VIEW_TYPE
c:V8.SizeOf_JS_DATA_VIEW_TYPE
c:V8.CountOf_JS_PROXY_TYPE
c:V8.SizeOf_JS_PROXY_TYPE
c:V8.CountOf_JS_SET_TYPE
c:V8.SizeOf_JS_SET_TYPE
c:V8.CountOf_JS_MAP_TYPE
c:V8.SizeOf_JS_MAP_TYPE
c:V8.CountOf_JS_SET_ITERATOR_TYPE
c:V8.SizeOf_JS_SET_ITERATOR_TYPE
c:V8.CountOf_JS_MAP_ITERATOR_TYPE
c:V8.SizeOf_JS_MAP_ITERATOR_TYPE
c:V8.CountOf_JS_WEAK_MAP_TYPE
c:V8.SizeOf_JS_WEAK_MAP_TYPE
c:V8.CountOf_JS_WEAK_SET_TYPE
c:V8.SizeOf_JS_WEAK_SET_TYPE
c:V8.CountOf_JS_REGEXP_TYPE
c:V8.SizeOf_JS_REGEXP_TYPE
c:V8.CountOf_JS_FUNCTION_TYPE
c:V8.SizeOf_JS_FUNCTION_TYPE
c:V8.CountOf_JS_FUNCTION_PROXY_TYPE
c:V8.SizeOf_JS_FUNCTION_PROXY_TYPE
c:V8.CountOf_DEBUG_INFO_TYPE
c:V8.SizeOf_DEBUG_INFO_TYPE
c:V8.CountOf_BREAK_POINT_INFO_TYPE
c:V8.SizeOf_BREAK_POINT_INFO_TYPE
c:V8.CountOf_CODE_TYPE-FUNCTION
c:V8.SizeOf_CODE_TYPE-FUNCTION
c:V8.CountOf_CODE_TYPE-OPTIMIZED_FUNCTION
c:V8.SizeOf_CODE_TYPE-OPTIMIZED_FUNCTION
c:V8.CountOf_CODE_TYPE-STUB
c:V8.SizeOf_CODE_TYPE-STUB
c:V8.CountOf_CODE_TYPE-HANDLER
c:V8.SizeOf_CODE_TYPE-HANDLER
c:V8.CountOf_CODE_TYPE-BUILTIN
c:V8.SizeOf_CODE_TYPE-BUILTIN
c:V8.CountOf_CODE_TYPE-REGEXP
c:V8.SizeOf_CODE_TYPE-REGEXP
c:V8.CountOf_CODE_TYPE-LOAD_IC
c:V8.SizeOf_CODE_TYPE-LOAD_IC
c:V8.CountOf_CODE_TYPE-KEYED_LOAD_IC
c:V8.SizeOf_CODE_TYPE-KEYED_LOAD_IC
c:V8.CountOf_CODE_TYPE-CALL_IC
c:V8.SizeOf_CODE_TYPE-CALL_IC
c:V8.CountOf_CODE_TYPE-STORE_IC
c:V8.SizeOf_CODE_TYPE-STORE_IC
c:V8.CountOf_CODE_TYPE-KEYED_STORE_IC
c:V8.SizeOf_CODE_TYPE-KEYED_STORE_IC
c:V8.CountOf_CODE_TYPE-BINARY_OP_IC
c:V8.SizeOf_CODE_TYPE-BINARY_OP_IC
c:V8.CountOf_CODE_TYPE-COMPARE_IC
c:V8.SizeOf_CODE_TYPE-COMPARE_IC
c:V8.CountOf_CODE_TYPE-COMPARE_NIL_IC
c:V8.SizeOf_CODE_TYPE-COMPARE_NIL_IC
c:V8.CountOf_CODE_TYPE-TO_BOOLEAN_IC
c:V8.SizeOf_CODE_TYPE-TO_BOOLEAN_IC
c:V8.CountOf_FIXED_ARRAY-FAST_ELEMENTS_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-FAST_ELEMENTS_SUB_TYPE
c:V8.CountOf_FIXED_ARRAY-DICTIONARY_ELEMENTS_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-DICTIONARY_ELEMENTS_SUB_TYPE
c:V8.CountOf_FIXED_ARRAY-FAST_PROPERTIES_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-FAST_PROPERTIES_SUB_TYPE
c:V8.CountOf_FIXED_ARRAY-DICTIONARY_PROPERTIES_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-DICTIONARY_PROPERTIES_SUB_TYPE
c:V8.CountOf_FIXED_ARRAY-MAP_CODE_CACHE_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-MAP_CODE_CACHE_SUB_TYPE
c:V8.CountOf_FIXED_ARRAY-SCOPE_INFO_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-SCOPE_INFO_SUB_TYPE
c:V8.CountOf_FIXED_ARRAY-STRING_TABLE_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-STRING_TABLE_SUB_TYPE
c:V8.CountOf_FIXED_ARRAY-DESCRIPTOR_ARRAY_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-DESCRIPTOR_ARRAY_SUB_TYPE
c:V8.CountOf_FIXED_ARRAY-TRANSITION_ARRAY_SUB_TYPE
c:V8.SizeOf_FIXED_ARRAY-TRANSITION_ARRAY_SUB_TYPE
c:V8.CountOf_CODE_AGE-ToBeExecutedOnce
c:V8.SizeOf_CODE_AGE-ToBeExecutedOnce
c:V8.CountOf_CODE_AGE-NotExecuted
c:V8.SizeOf_CODE_AGE-NotExecuted
c:V8.CountOf_CODE_AGE-ExecutedOnce
c:V8.SizeOf_CODE_AGE-ExecutedOnce
c:V8.CountOf_CODE_AGE-NoAge
c:V8.SizeOf_CODE_AGE-NoAge
c:V8.CountOf_CODE_AGE-Quadragenarian
c:V8.SizeOf_CODE_AGE-Quadragenarian
c:V8.CountOf_CODE_AGE-Quinquagenarian
c:V8.SizeOf_CODE_AGE-Quinquagenarian
c:V8.CountOf_CODE_AGE-Sexagenarian
c:V8.SizeOf_CODE_AGE-Sexagenarian
c:V8.CountOf_CODE_AGE-Septuagenarian
c:V8.SizeOf_CODE_AGE-Septuagenarian
c:V8.CountOf_CODE_AGE-Octogenarian
c:V8.SizeOf_CODE_AGE-Octogenarian
v8:ProfEvntProc
args_count: 
get 
RegExp: 
set 
ScriptCache
mirror
debug
liveedit
../deps/v8/src/debug.cc
!it.done() && (it.frame()->fp() == thread_local_.last_fp_)
IsBreakPointTriggered
preparing for breakpoints
next_handle_
mirror_cache_
Debug::GetLoadedScripts
MakeExecutionState
MakeBreakEvent
MakeExceptionEvent
MakeCompileEvent
MakePromiseEvent
MakeAsyncTaskEvent
$promiseHasUserDefinedRejectHandler
UpdateScriptBreakPoints
debugCommandProcessor
processDebugRequest
isRunning
Got request from command queue, in interactive loop.
Put command on command_queue.
toJSONProtocol
Replacing code %08lx - %08lx (%d) with %08lx - %08lx (%d) for debugging, changing pc from %08lx to %08lx
../deps/v8/src/deoptimizer.cc
code->kind() == Code::OPTIMIZED_FUNCTION
isolate->deoptimizer_data()->current_ == NULL
(result) != nullptr
frame->is_optimized()
isolate->deoptimizer_data()->deoptimized_frame_info_ == NULL
(deoptimization_index)!=(Safepoint::kNoDeoptimizationIndex)
(jsframe_index)<(deoptimizer->jsframe_count())
(isolate->deoptimizer_data()->deoptimized_frame_info_)==(info)
context->IsNativeContext()
(function->next_function_link())==(next)
(code->kind())==(Code::OPTIMIZED_FUNCTION)
deoptimized code
[deoptimize all code in all contexts]
[deoptimize marked code in all contexts]
Unsupported deopt type
eager
soft
lazy
debugger
Could not find code for optimized function
(id)>=(0)
(mode)==(CALCULATE_ENTRY_ADDRESS)
(type)<(kBailoutTypesWithCodeEntry)
[couldn't find pc offset for node=
[method: 
[source:
unable to find pc offset during deoptimization
[deoptimizing (DEOPT %s): begin 
 (opt #%d) @%d, FP to SP delta: %d]
invalid frame
[deoptimizing (%s): end 
 @%d => node=%d, pc=0x%08lx, state=%s, alignment=%s, took %0.3f ms]
with padding
no padding
  translating frame 
 => node=%d, height=%d
frame_index >= 0 && frame_index < output_count_
(output_[frame_index]) == nullptr
caller's pc
caller's fp
context != isolate_->heap()->arguments_marker()
!compiled_code_->is_turbofanned()
context    
function    
(0u)==(output_offset)
(bailout_type_)==(EAGER)
  translating arguments adaptor => height=%d
frame_index > 0 && frame_index < output_count_ - 1
output_[frame_index] == NULL
context (adaptor sentinel)
argc 
(%d)
  translating construct stub => height=%d
context
function (construct sentinel)
code object
allocated receiver
setter
  translating %s stub => height=%u
function 
(%s sentinel)
compiled_code_->is_hydrogen_stub()
(translated_frame->height())==(param_count)
(param_count)>=(0)
  translating %s => StubFailureTrampolineStub, height=%d
(frame_index)==(0)
reinterpret_cast<Object*>(value)->IsContext()
function (stub failure sentinel)
args.arguments
args.arguments (the hole)
args.length
args.length (the hole)
args*
(0u)==(output_frame_offset)
(arguments_length_offset)>=(0)
args.arguments
Materialization [0x%08lx] <- 0x%08lx ;  
(DEBUGGER)==(bailout_type_)
frame->kind() == TranslatedFrame::kFunction
(expression_count + 1)==(frame->height())
(parameter_count)==(argument_frame->height() - 1)
(frame_arg_count)==(parameter_count)
  (input #%d)
    0x%08lx: [top + %d] <- 0x%08lx ;  %s
result == fixed_size + (stack_slots * kPointerSize) + outgoing_size
(Smi::cast(function))==(Smi::FromInt(StackFrame::STUB))
type == EAGER || type == SOFT || type == LAZY
entry_count <= Deoptimizer::kMaxNumberOfEntries
static_cast<int>(Deoptimizer::GetMaxDeoptTableSize()) >= desc.instr_size
Deoptimizer::EnsureCodeForDeoptimizationEntry
Unexpected stack frame type
(index)>=(0)
(index)<(ComputeParametersCount())
(StackFrame::JAVA_SCRIPT)==(type_)
Unexpected translation type
BEGIN
CONSTRUCT_STUB_FRAME
GETTER_STUB_FRAME
SETTER_STUB_FRAME
ARGUMENTS_ADAPTOR_FRAME
COMPILED_STUB_FRAME
DUPLICATED_OBJECT
ARGUMENTS_OBJECT
CAPTURED_OBJECT
REGISTER
INT32_REGISTER
UINT32_REGISTER
BOOL_REGISTER
DOUBLE_REGISTER
STACK_SLOT
INT32_STACK_SLOT
UINT32_STACK_SLOT
BOOL_STACK_SLOT
DOUBLE_STACK_SLOT
LITERAL
JS_FRAME_FUNCTION
(array->length())>(index)
(index)<(array->length())
(output_frame->GetFrameType())==(StackFrame::ARGUMENTS_ADAPTOR)
Constant global variable assignment
conversion overflow
division by zero
ElementsKind unhandled in KeyedLoadGenericStub
Expected heap number
Expected smi
Forced deopt to runtime
hole
Holey array despite packed elements_kind feedback
instance migration failed
Insufficient type feedback for call with arguments
Insufficient type feedback for combined type of binary operation
Insufficient type feedback for generic named access
Insufficient type feedback for keyed load
Insufficient type feedback for keyed store
Insufficient type feedback for LHS of binary operation
Insufficient type feedback for RHS of binary operation
key is negative
lost precision
lost precision or NaN
memento found
minus zero
Negative key encountered
negative value
no cache
non-strict elements in KeyedLoadGenericStub
not a date object
not a heap number
not a heap number/undefined/true/false
not a heap number/undefined
not a JavaScript object
not a Smi
out of bounds
Outside of range
receiver was a global object
too many arguments
Too many undetectable types
Tracing elements transitions
Type mismatch between feedback and constant
Unexpected cell contents in constant global store
Unexpected cell contents in global store
unexpected object
Unexpected RHS of binary operation
Uninitialized boilerplate in fast clone
Uninitialized boilerplate literals
Unknown map in polymorphic access
Unknown map in polymorphic call
Unknown map in polymorphic element access
Unknown map
value mismatch
wrong instance type
wrong map
null or undefined in for-in
(1U)==(uint32_value())
unexpected case
internal error: value missing
internal error: unexpected materialization.
  reading input frame %s
 => node=%d, args=%d, height=%d; inputs:
  reading arguments adaptor frame %s
 => height=%d; inputs:
  reading construct stub frame %s
  reading getter frame %s; inputs:
  reading setter frame %s; inputs:
  reading compiler stub frame => height=%d; inputs:
We should never get here - unexpected deopt info.
duplicated object #%d
argumets object #%d (length = %d)
captured object #%d (length = %d)
0x%08lx ; %s 
%ld ; %s 
%lu ; %s (uint)
%ld ; %s (bool)
%e ; %s (bool)
0x%08lx ; [fp %c %d] 
%d ; (int) [fp %c %d] 
%u ; (uint) [fp %c %d] 
%u ; (bool) [fp %c %d] 
%e ; (double) [fp %c %d] 
0x%08lx ; (literal %d) 
0x%08lx ; (frame function) 
opcode == Translation::BEGIN
    %3i: 
         
!iterator->HasNext() || static_cast<Translation::Opcode>(iterator->Next()) == Translation::BEGIN
frame->values_[*value_index].kind() == TranslatedValue::kTagged
[couldn't handle instance type %d]
unreachable
We should never get here - unexpected deopt slot kind.
arg_iterator == previous_frame->end()
[deoptimizer unlinked: 
 / %lx]
NO_REGISTERS
TOS_REG
%s  (%p)
%d  (%p)
%08x       constant
%08x       constant pool begin (num_const = %d)
%08lx      jump table entry %4ld
                  %s
%p  %4d  
    ;; debug: statement %d
    ;; debug: position %d
    ;; debug: deopt reason '%s'
    ;; object: %s
    ;; external reference (%s)
    ;; code:
 constructor,
 contextual,
 %s, %s
, %s
 %s, %s, 
argc = %d
minor: %d
 (id = %d)
    ;; %s
    ;; soft deoptimization bailout %d
    ;; lazy deoptimization bailout %d
    ;; deoptimization bailout %d
array
[OOB %s %s (%s length = %d, element accessed = %d) in 
[%s elements length not integer value in 
[%s elements length not a number in 
FAST_SMI_ELEMENTS
FAST_HOLEY_SMI_ELEMENTS
FAST_ELEMENTS
FAST_HOLEY_ELEMENTS
FAST_DOUBLE_ELEMENTS
FAST_HOLEY_DOUBLE_ELEMENTS
DICTIONARY_ELEMENTS
FAST_SLOPPY_ARGUMENTS_ELEMENTS
SLOW_SLOPPY_ARGUMENTS_ELEMENTS
EXTERNAL_INT8_ELEMENTS
EXTERNAL_UINT8_ELEMENTS
EXTERNAL_INT16_ELEMENTS
EXTERNAL_UINT16_ELEMENTS
EXTERNAL_INT32_ELEMENTS
EXTERNAL_UINT32_ELEMENTS
EXTERNAL_FLOAT32_ELEMENTS
EXTERNAL_FLOAT64_ELEMENTS
EXTERNAL_UINT8_CLAMPED_ELEMENTS
UINT8_ELEMENTS
INT8_ELEMENTS
UINT16_ELEMENTS
INT16_ELEMENTS
UINT32_ELEMENTS
INT32_ELEMENTS
FLOAT32_ELEMENTS
FLOAT64_ELEMENTS
UINT8_CLAMPED_ELEMENTS
unknown location (no JavaScript frames present)
apply from 
elements read
external elements read
../deps/v8/src/elements.cc
array->length()->ToArrayIndex(&old_length)
Hurrying incremental marking because of lack of progress
[IncrementalMarking] Restarting (new grey objects)
array->length()->ToArrayLength(&old_length)
dict->KeyAt(entry)->ToArrayIndex(&result)
../deps/v8/src/execution.cc
AllowJavascriptExecution::IsAllowed(isolate)
[Running deserialized script
: %s
native function externalizeString();native function isOneByteString();
externalizeString
First parameter to externalizeString() must be a string.
Second parameter to externalizeString() must be a boolean.
externalizeString() can't externalize twice.
externalizeString() failed.
isOneByteString() requires a single string argument.
native function getV8Statistics();
counters extension
global_handles
memory_allocated
normalized_maps
props_to_dictionary
elements_to_dictionary
alive_after_last_gc
objs_since_last_young
objs_since_last_full
string_table_capacity
number_of_symbols
script_wrappers
call_initialize_stubs
call_premonomorphic_stubs
call_normal_stubs
call_megamorphic_stubs
inlined_copied_elements
arguments_adaptors
compilation_cache_hits
compilation_cache_misses
string_ctor_calls
string_ctor_conversions
string_ctor_cached_number
string_ctor_string_value
string_ctor_gc_required
total_eval_size
total_load_size
total_parse_size
total_preparse_skipped
total_preparse_symbols_skipped
total_compile_size
total_full_codegen_source_size
contexts_created_from_scratch
contexts_created_by_snapshot
pc_to_code
pc_to_code_cached
store_buffer_compactions
store_buffer_overflows
total_stubs_code_size
total_compiled_code_size
gc_compactor_caused_by_request
gc_compactor_caused_by_promoted_data
gc_compactor_caused_by_oldspace_exhaustion
gc_last_resort_from_js
gc_last_resort_from_handles
keyed_load_generic_smi
keyed_load_generic_symbol
keyed_load_generic_lookup_cache
keyed_load_generic_slow
keyed_load_polymorphic_stubs
keyed_load_external_array_slow
keyed_call_generic_smi_fast
keyed_call_generic_smi_dict
keyed_call_generic_lookup_cache
keyed_call_generic_lookup_dict
keyed_call_generic_slow
keyed_call_generic_slow_load
named_load_global_stub
named_store_global_inline
named_store_global_inline_miss
keyed_store_polymorphic_stubs
keyed_store_external_array_slow
store_normal_miss
store_normal_hit
cow_arrays_created_stub
cow_arrays_created_runtime
cow_arrays_converted
call_miss
keyed_call_miss
load_miss
keyed_load_miss
call_const
call_const_fast_api
call_const_interceptor
call_const_interceptor_fast_api
call_global_inline
call_global_inline_miss
constructed_objects
constructed_objects_runtime
negative_lookups
negative_lookups_miss
megamorphic_stub_cache_probes
megamorphic_stub_cache_misses
megamorphic_stub_cache_updates
array_function_runtime
array_function_native
for_in
enum_cache_hits
enum_cache_misses
fast_new_closure_total
fast_new_closure_try_optimized
fast_new_closure_install_optimized
string_add_runtime
string_add_native
string_add_runtime_ext_to_one_byte
sub_string_runtime
sub_string_native
string_add_make_two_char
string_compare_native
string_compare_runtime
regexp_entry_runtime
regexp_entry_native
number_to_string_native
number_to_string_runtime
math_acos
math_asin
math_atan
math_atan2
math_clz32
math_exp
math_floor
math_log
math_pow
math_round
math_sqrt
stack_interrupts
runtime_profiler_ticks
bounds_checks_eliminated
bounds_checks_hoisted
soft_deopts_requested
soft_deopts_inserted
soft_deopts_executed
write_barriers_dynamic
write_barriers_static
new_space_bytes_available
new_space_bytes_committed
new_space_bytes_used
old_space_bytes_available
old_space_bytes_committed
old_space_bytes_used
code_space_bytes_available
code_space_bytes_committed
code_space_bytes_used
map_space_bytes_available
map_space_bytes_committed
map_space_bytes_used
lo_space_bytes_available
lo_space_bytes_committed
lo_space_bytes_used
count_of_STRING_TYPE
size_of_STRING_TYPE
count_of_ONE_BYTE_STRING_TYPE
size_of_ONE_BYTE_STRING_TYPE
count_of_CONS_STRING_TYPE
size_of_CONS_STRING_TYPE
count_of_CONS_ONE_BYTE_STRING_TYPE
size_of_CONS_ONE_BYTE_STRING_TYPE
count_of_SLICED_STRING_TYPE
size_of_SLICED_STRING_TYPE
count_of_SLICED_ONE_BYTE_STRING_TYPE
size_of_SLICED_ONE_BYTE_STRING_TYPE
count_of_EXTERNAL_STRING_TYPE
size_of_EXTERNAL_STRING_TYPE
count_of_EXTERNAL_ONE_BYTE_STRING_TYPE
size_of_EXTERNAL_ONE_BYTE_STRING_TYPE
count_of_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
size_of_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
count_of_SHORT_EXTERNAL_STRING_TYPE
size_of_SHORT_EXTERNAL_STRING_TYPE
count_of_SHORT_EXTERNAL_ONE_BYTE_STRING_TYPE
size_of_SHORT_EXTERNAL_ONE_BYTE_STRING_TYPE
count_of_SHORT_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
size_of_SHORT_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
count_of_INTERNALIZED_STRING_TYPE
size_of_INTERNALIZED_STRING_TYPE
count_of_ONE_BYTE_INTERNALIZED_STRING_TYPE
size_of_ONE_BYTE_INTERNALIZED_STRING_TYPE
count_of_EXTERNAL_INTERNALIZED_STRING_TYPE
size_of_EXTERNAL_INTERNALIZED_STRING_TYPE
count_of_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
size_of_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
count_of_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
size_of_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
count_of_SHORT_EXTERNAL_INTERNALIZED_STRING_TYPE
size_of_SHORT_EXTERNAL_INTERNALIZED_STRING_TYPE
count_of_SHORT_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
size_of_SHORT_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
count_of_SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
size_of_SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
count_of_SYMBOL_TYPE
size_of_SYMBOL_TYPE
count_of_MAP_TYPE
size_of_MAP_TYPE
count_of_CODE_TYPE
size_of_CODE_TYPE
count_of_ODDBALL_TYPE
size_of_ODDBALL_TYPE
count_of_CELL_TYPE
size_of_CELL_TYPE
count_of_PROPERTY_CELL_TYPE
size_of_PROPERTY_CELL_TYPE
count_of_HEAP_NUMBER_TYPE
size_of_HEAP_NUMBER_TYPE
count_of_MUTABLE_HEAP_NUMBER_TYPE
size_of_MUTABLE_HEAP_NUMBER_TYPE
count_of_FLOAT32X4_TYPE
size_of_FLOAT32X4_TYPE
count_of_FOREIGN_TYPE
size_of_FOREIGN_TYPE
count_of_BYTE_ARRAY_TYPE
size_of_BYTE_ARRAY_TYPE
count_of_FREE_SPACE_TYPE
size_of_FREE_SPACE_TYPE
count_of_EXTERNAL_INT8_ARRAY_TYPE
size_of_EXTERNAL_INT8_ARRAY_TYPE
count_of_EXTERNAL_UINT8_ARRAY_TYPE
size_of_EXTERNAL_UINT8_ARRAY_TYPE
count_of_EXTERNAL_INT16_ARRAY_TYPE
size_of_EXTERNAL_INT16_ARRAY_TYPE
count_of_EXTERNAL_UINT16_ARRAY_TYPE
size_of_EXTERNAL_UINT16_ARRAY_TYPE
count_of_EXTERNAL_INT32_ARRAY_TYPE
size_of_EXTERNAL_INT32_ARRAY_TYPE
count_of_EXTERNAL_UINT32_ARRAY_TYPE
size_of_EXTERNAL_UINT32_ARRAY_TYPE
count_of_EXTERNAL_FLOAT32_ARRAY_TYPE
size_of_EXTERNAL_FLOAT32_ARRAY_TYPE
count_of_EXTERNAL_FLOAT64_ARRAY_TYPE
size_of_EXTERNAL_FLOAT64_ARRAY_TYPE
count_of_EXTERNAL_UINT8_CLAMPED_ARRAY_TYPE
size_of_EXTERNAL_UINT8_CLAMPED_ARRAY_TYPE
count_of_FIXED_INT8_ARRAY_TYPE
size_of_FIXED_INT8_ARRAY_TYPE
count_of_FIXED_UINT8_ARRAY_TYPE
size_of_FIXED_UINT8_ARRAY_TYPE
count_of_FIXED_INT16_ARRAY_TYPE
size_of_FIXED_INT16_ARRAY_TYPE
count_of_FIXED_UINT16_ARRAY_TYPE
size_of_FIXED_UINT16_ARRAY_TYPE
count_of_FIXED_INT32_ARRAY_TYPE
size_of_FIXED_INT32_ARRAY_TYPE
count_of_FIXED_UINT32_ARRAY_TYPE
size_of_FIXED_UINT32_ARRAY_TYPE
count_of_FIXED_FLOAT32_ARRAY_TYPE
size_of_FIXED_FLOAT32_ARRAY_TYPE
count_of_FIXED_FLOAT64_ARRAY_TYPE
size_of_FIXED_FLOAT64_ARRAY_TYPE
count_of_FIXED_UINT8_CLAMPED_ARRAY_TYPE
size_of_FIXED_UINT8_CLAMPED_ARRAY_TYPE
count_of_FILLER_TYPE
size_of_FILLER_TYPE
count_of_DECLARED_ACCESSOR_DESCRIPTOR_TYPE
size_of_DECLARED_ACCESSOR_DESCRIPTOR_TYPE
count_of_DECLARED_ACCESSOR_INFO_TYPE
size_of_DECLARED_ACCESSOR_INFO_TYPE
count_of_EXECUTABLE_ACCESSOR_INFO_TYPE
size_of_EXECUTABLE_ACCESSOR_INFO_TYPE
count_of_ACCESSOR_PAIR_TYPE
size_of_ACCESSOR_PAIR_TYPE
count_of_ACCESS_CHECK_INFO_TYPE
size_of_ACCESS_CHECK_INFO_TYPE
count_of_INTERCEPTOR_INFO_TYPE
size_of_INTERCEPTOR_INFO_TYPE
count_of_CALL_HANDLER_INFO_TYPE
size_of_CALL_HANDLER_INFO_TYPE
count_of_FUNCTION_TEMPLATE_INFO_TYPE
size_of_FUNCTION_TEMPLATE_INFO_TYPE
count_of_OBJECT_TEMPLATE_INFO_TYPE
size_of_OBJECT_TEMPLATE_INFO_TYPE
count_of_SIGNATURE_INFO_TYPE
size_of_SIGNATURE_INFO_TYPE
count_of_TYPE_SWITCH_INFO_TYPE
size_of_TYPE_SWITCH_INFO_TYPE
count_of_ALLOCATION_MEMENTO_TYPE
size_of_ALLOCATION_MEMENTO_TYPE
count_of_ALLOCATION_SITE_TYPE
size_of_ALLOCATION_SITE_TYPE
count_of_SCRIPT_TYPE
size_of_SCRIPT_TYPE
count_of_CODE_CACHE_TYPE
size_of_CODE_CACHE_TYPE
count_of_POLYMORPHIC_CODE_CACHE_TYPE
size_of_POLYMORPHIC_CODE_CACHE_TYPE
count_of_TYPE_FEEDBACK_INFO_TYPE
size_of_TYPE_FEEDBACK_INFO_TYPE
count_of_ALIASED_ARGUMENTS_ENTRY_TYPE
size_of_ALIASED_ARGUMENTS_ENTRY_TYPE
count_of_BOX_TYPE
size_of_BOX_TYPE
count_of_PROTOTYPE_INFO_TYPE
size_of_PROTOTYPE_INFO_TYPE
count_of_FIXED_ARRAY_TYPE
size_of_FIXED_ARRAY_TYPE
count_of_FIXED_DOUBLE_ARRAY_TYPE
size_of_FIXED_DOUBLE_ARRAY_TYPE
count_of_SHARED_FUNCTION_INFO_TYPE
size_of_SHARED_FUNCTION_INFO_TYPE
count_of_WEAK_CELL_TYPE
size_of_WEAK_CELL_TYPE
count_of_JS_MESSAGE_OBJECT_TYPE
size_of_JS_MESSAGE_OBJECT_TYPE
count_of_JS_VALUE_TYPE
size_of_JS_VALUE_TYPE
count_of_JS_DATE_TYPE
size_of_JS_DATE_TYPE
count_of_JS_OBJECT_TYPE
size_of_JS_OBJECT_TYPE
count_of_JS_CONTEXT_EXTENSION_OBJECT_TYPE
size_of_JS_CONTEXT_EXTENSION_OBJECT_TYPE
count_of_JS_GENERATOR_OBJECT_TYPE
size_of_JS_GENERATOR_OBJECT_TYPE
count_of_JS_MODULE_TYPE
size_of_JS_MODULE_TYPE
count_of_JS_GLOBAL_OBJECT_TYPE
size_of_JS_GLOBAL_OBJECT_TYPE
count_of_JS_BUILTINS_OBJECT_TYPE
size_of_JS_BUILTINS_OBJECT_TYPE
count_of_JS_GLOBAL_PROXY_TYPE
size_of_JS_GLOBAL_PROXY_TYPE
count_of_JS_ARRAY_TYPE
size_of_JS_ARRAY_TYPE
count_of_JS_ARRAY_BUFFER_TYPE
size_of_JS_ARRAY_BUFFER_TYPE
count_of_JS_TYPED_ARRAY_TYPE
size_of_JS_TYPED_ARRAY_TYPE
count_of_JS_DATA_VIEW_TYPE
size_of_JS_DATA_VIEW_TYPE
count_of_JS_PROXY_TYPE
size_of_JS_PROXY_TYPE
count_of_JS_SET_TYPE
size_of_JS_SET_TYPE
count_of_JS_MAP_TYPE
size_of_JS_MAP_TYPE
count_of_JS_SET_ITERATOR_TYPE
size_of_JS_SET_ITERATOR_TYPE
count_of_JS_MAP_ITERATOR_TYPE
size_of_JS_MAP_ITERATOR_TYPE
count_of_JS_WEAK_MAP_TYPE
size_of_JS_WEAK_MAP_TYPE
count_of_JS_WEAK_SET_TYPE
size_of_JS_WEAK_SET_TYPE
count_of_JS_REGEXP_TYPE
size_of_JS_REGEXP_TYPE
count_of_JS_FUNCTION_TYPE
size_of_JS_FUNCTION_TYPE
count_of_JS_FUNCTION_PROXY_TYPE
size_of_JS_FUNCTION_PROXY_TYPE
count_of_DEBUG_INFO_TYPE
size_of_DEBUG_INFO_TYPE
count_of_BREAK_POINT_INFO_TYPE
size_of_BREAK_POINT_INFO_TYPE
count_of_CODE_TYPE_FUNCTION
size_of_CODE_TYPE_FUNCTION
count_of_CODE_TYPE_OPTIMIZED_FUNCTION
size_of_CODE_TYPE_OPTIMIZED_FUNCTION
count_of_CODE_TYPE_STUB
size_of_CODE_TYPE_STUB
count_of_CODE_TYPE_HANDLER
size_of_CODE_TYPE_HANDLER
count_of_CODE_TYPE_BUILTIN
size_of_CODE_TYPE_BUILTIN
count_of_CODE_TYPE_REGEXP
size_of_CODE_TYPE_REGEXP
count_of_CODE_TYPE_LOAD_IC
size_of_CODE_TYPE_LOAD_IC
count_of_CODE_TYPE_KEYED_LOAD_IC
size_of_CODE_TYPE_KEYED_LOAD_IC
count_of_CODE_TYPE_CALL_IC
size_of_CODE_TYPE_CALL_IC
count_of_CODE_TYPE_STORE_IC
size_of_CODE_TYPE_STORE_IC
count_of_CODE_TYPE_KEYED_STORE_IC
size_of_CODE_TYPE_KEYED_STORE_IC
count_of_CODE_TYPE_BINARY_OP_IC
size_of_CODE_TYPE_BINARY_OP_IC
count_of_CODE_TYPE_COMPARE_IC
size_of_CODE_TYPE_COMPARE_IC
count_of_CODE_TYPE_COMPARE_NIL_IC
size_of_CODE_TYPE_COMPARE_NIL_IC
count_of_CODE_TYPE_TO_BOOLEAN_IC
size_of_CODE_TYPE_TO_BOOLEAN_IC
count_of_FIXED_ARRAY_FAST_ELEMENTS_SUB_TYPE
size_of_FIXED_ARRAY_FAST_ELEMENTS_SUB_TYPE
count_of_FIXED_ARRAY_DICTIONARY_ELEMENTS_SUB_TYPE
size_of_FIXED_ARRAY_DICTIONARY_ELEMENTS_SUB_TYPE
count_of_FIXED_ARRAY_FAST_PROPERTIES_SUB_TYPE
size_of_FIXED_ARRAY_FAST_PROPERTIES_SUB_TYPE
count_of_FIXED_ARRAY_DICTIONARY_PROPERTIES_SUB_TYPE
size_of_FIXED_ARRAY_DICTIONARY_PROPERTIES_SUB_TYPE
count_of_FIXED_ARRAY_MAP_CODE_CACHE_SUB_TYPE
size_of_FIXED_ARRAY_MAP_CODE_CACHE_SUB_TYPE
count_of_FIXED_ARRAY_SCOPE_INFO_SUB_TYPE
size_of_FIXED_ARRAY_SCOPE_INFO_SUB_TYPE
count_of_FIXED_ARRAY_STRING_TABLE_SUB_TYPE
size_of_FIXED_ARRAY_STRING_TABLE_SUB_TYPE
count_of_FIXED_ARRAY_DESCRIPTOR_ARRAY_SUB_TYPE
size_of_FIXED_ARRAY_DESCRIPTOR_ARRAY_SUB_TYPE
count_of_FIXED_ARRAY_TRANSITION_ARRAY_SUB_TYPE
size_of_FIXED_ARRAY_TRANSITION_ARRAY_SUB_TYPE
total_committed_bytes
new_space_live_bytes
new_space_available_bytes
new_space_commited_bytes
old_space_live_bytes
old_space_available_bytes
old_space_commited_bytes
code_space_live_bytes
code_space_available_bytes
code_space_commited_bytes
lo_space_live_bytes
lo_space_available_bytes
lo_space_commited_bytes
amount_of_external_allocated_memory
native function triggerCheckFalse();native function triggerAssertFalse();native function triggerSlowAssertFalse();
triggerCheckFalse
triggerAssertFalse
triggerSlowAssertFalse
../deps/v8/src/extensions/trigger-failure-extension.cc
(0)==(strcmp(*v8::String::Utf8Value(str), "triggerSlowAssertFalse"))
allocation failure
last resort gc
CALL_AND_RETRY_LAST
MakeError
MakeTypeError
MakeSyntaxError
MakeReferenceError
MakeRangeError
MakeEvalError
../deps/v8/src/factory.cc
byte_offset % element_size == 0
length <= (std::numeric_limits<size_t>::max() / element_size)
length <= static_cast<size_t>(Smi::kMaxValue)
number_of_elements <= (std::numeric_limits<size_t>::max() / element_size)
number_of_elements <= static_cast<size_t>(Smi::kMaxValue)
<freezing call trap>
../deps/v8/src/heap/heap-inl.h
(String::kMaxLength)>=(str.length())
../deps/v8/src/heap/spaces.h
!object->IsSmi()
Hello, world!
/tmp/serdes
v8.log
/tmp/__v8_gc__
arm64_inst.csv
--no
Error: unrecognized flag %s
Try --help for options
Error: missing value for flag %s of type %s
Try --help for options
Error: illegal value for flag %s of type %s
Try --help for options
Usage:
  shell [options] -e string
    execute string in V8
  shell [options] file1 file2 ... filek
    run JavaScript scripts in file1, file2, ..., filek
  shell [options]
  shell [options] --shell [file1 file2 ... filek]
    run an interactive JavaScript shell
  d8 [options] file1 file2 ... filek
  d8 [options]
  d8 [options] --shell [file1 file2 ... filek]
    run the new debugging shell
Options:
  --
        type: 
  default: 
use_strict
enforce strict mode
use_strong
enforce strong mode
strong_mode
experimental strong language mode
strong_this
don't allow 'this' to escape from constructors
es_staging
enable all completed harmony features
harmony
harmony_shipping
enable all shipped harmony fetaures
legacy_const
legacy semantics for const in sloppy mode
harmony_modules
enable "harmony modules" (in progress)
harmony_array_includes
enable "harmony Array.prototype.includes" (in progress)
harmony_regexps
enable "harmony regular expression extensions" (in progress)
harmony_proxies
enable "harmony proxies" (in progress)
harmony_sloppy
enable "harmony features in sloppy mode" (in progress)
harmony_unicode_regexps
enable "harmony unicode regexps" (in progress)
harmony_reflect
enable "harmony Reflect API" (in progress)
harmony_destructuring
enable "harmony destructuring" (in progress)
harmony_sharedarraybuffer
enable "harmony sharedarraybuffer" (in progress)
harmony_atomics
enable "harmony atomics" (in progress)
harmony_new_target
enable "harmony new.target" (in progress)
harmony_tostring
enable "harmony toString"
harmony_concat_spreadable
enable "harmony isConcatSpreadable"
harmony_rest_parameters
enable "harmony rest parameters"
harmony_spreadcalls
enable "harmony spread-calls"
harmony_spread_arrays
enable "harmony spread in array literals"
harmony_arrow_functions
enable "harmony arrow functions"
harmony_computed_property_names
enable "harmony computed property names"
harmony_unicode
enable "harmony unicode escapes"
harmony_object
enable "harmony Object methods"
compiled_keyed_generic_loads
use optimizing compiler to generate keyed generic load stubs
pretenuring_call_new
pretenure call new
allocation_site_pretenuring
pretenure with allocation sites
trace_pretenuring
trace pretenuring decisions of HAllocate instructions
trace_pretenuring_statistics
trace allocation site pretenuring statistics
track_fields
track fields with only smi values
track_double_fields
track fields with double values
track_heap_object_fields
track fields with heap values
track_computed_fields
track computed boilerplate fields
track_field_types
track field types
smi_binop
support smi representation in binary operations
optimize_for_size
Enables optimizations which favor memory size over execution speed.
unbox_double_arrays
automatically unbox arrays of doubles
string_slices
use string slices
crankshaft
use crankshaft
hydrogen_filter
optimization filter
use_gvn
use hydrogen global value numbering
gvn_iterations
maximum number of GVN fix-point iterations
use_canonicalizing
use hydrogen instruction canonicalizing
use_inlining
use function inlining
use_escape_analysis
use hydrogen escape analysis
use_allocation_folding
use allocation folding
use_local_allocation_folding
only fold in basic blocks
use_write_barrier_elimination
eliminate write barriers targeting allocations in optimized code
max_inlining_levels
maximum number of inlining levels
max_inlined_source_size
maximum source size in bytes considered for a single inlining
max_inlined_nodes
maximum number of AST nodes considered for a single inlining
max_inlined_nodes_cumulative
maximum cumulative number of AST nodes considered for inlining
loop_invariant_code_motion
loop invariant code motion
fast_math
faster (but maybe less accurate) math functions
collect_megamorphic_maps_from_stub_cache
crankshaft harvests type feedback from stub cache
hydrogen_stats
print statistics for hydrogen
trace_check_elimination
trace check elimination phase
trace_environment_liveness
trace liveness of local variable slots
trace_hydrogen
trace generated hydrogen to file
trace_hydrogen_filter
hydrogen tracing filter
trace_hydrogen_stubs
trace generated hydrogen for stubs
trace_hydrogen_file
trace hydrogen to given file name
trace_phase
trace generated IR for specified phases
trace_inlining
trace inlining decisions
trace_load_elimination
trace load elimination
trace_store_elimination
trace store elimination
trace_alloc
trace register allocator
trace_all_uses
trace all use positions
trace_range
trace range analysis
trace_gvn
trace global value numbering
trace_representation
trace representation types
trace_removable_simulates
trace removable simulates
trace_escape_analysis
trace hydrogen escape analysis
trace_allocation_folding
trace allocation folding
trace_track_allocation_sites
trace the tracking of allocation sites
trace_migration
trace object migration
trace_generalization
trace map generalization
stress_pointer_maps
pointer map for every instruction
stress_environments
environment for every instruction
deopt_every_n_times
deoptimize every n times a deopt point is passed
deopt_every_n_garbage_collections
deoptimize every n garbage collections
print_deopt_stress
print number of possible deopt points
trap_on_deopt
put a break point before deoptimizing
trap_on_stub_deopt
put a break point before deoptimizing a stub
deoptimize_uncommon_cases
deoptimize uncommon cases
polymorphic_inlining
polymorphic inlining
use_osr
use on-stack replacement
array_bounds_checks_elimination
perform array bounds checks elimination
trace_bce
trace array bounds check elimination
array_bounds_checks_hoisting
perform array bounds checks hoisting
array_index_dehoisting
perform array index dehoisting
analyze_environment_liveness
analyze liveness of environment slots and zap dead values
load_elimination
use load elimination
check_elimination
use check elimination
store_elimination
use store elimination
dead_code_elimination
use dead code elimination
fold_constants
use constant folding
trace_dead_code_elimination
trace dead code elimination
unreachable_code_elimination
eliminate unreachable code
trace_osr
trace on-stack replacement
stress_runs
number of stress runs
lookup_sample_by_shared
when picking a function to optimize, watch for shared function info, not JSFunction itself
cache_optimized_code
cache optimized code for closures
flush_optimized_code_cache
flushes the cache of optimized code for closures on every GC
inline_construct
inline constructor calls
inline_arguments
inline functions with arguments object
inline_accessors
inline JavaScript accessors
escape_analysis_iterations
maximum number of escape analysis fix-point iterations
optimize_for_in
optimize functions containing for-in loops
concurrent_recompilation
optimizing hot functions asynchronously on a separate thread
trace_concurrent_recompilation
track concurrent recompilation
concurrent_recompilation_queue_length
the length of the concurrent compilation queue
concurrent_recompilation_delay
artificial compilation delay in ms
block_concurrent_recompilation
block queued jobs until released
concurrent_osr
concurrent on-stack replacement
omit_map_checks_for_leaf_maps
do not emit check maps for constant values that have a leaf map, deoptimize the optimized code if the layout of the maps changes.
turbo
enable TurboFan compiler
turbo_shipping
enable TurboFan compiler on subset
turbo_greedy_regalloc
use the greedy register allocator
turbo_filter
optimization filter for TurboFan compiler
trace_turbo
trace generated TurboFan IR
trace_turbo_graph
trace generated TurboFan graphs
trace_turbo_cfg_file
trace turbo cfg graph (for C1 visualizer) to a given file name
trace_turbo_types
trace TurboFan's types
trace_turbo_scheduler
trace TurboFan's scheduler
trace_turbo_reduction
trace TurboFan's various reducers
trace_turbo_jt
trace TurboFan's jump threading
trace_turbo_ceq
trace TurboFan's control equivalence
turbo_asm
enable TurboFan for asm.js code
turbo_asm_deoptimization
enable deoptimization in TurboFan for asm.js code
turbo_verify
verify TurboFan graphs at each phase
turbo_stats
print TurboFan statistics
turbo_splitting
split nodes during scheduling in TurboFan
turbo_types
use typed lowering in TurboFan
turbo_type_feedback
use type feedback in TurboFan
turbo_allocate
enable inline allocations in TurboFan
turbo_source_positions
track source code positions when building TurboFan IR
context_specialization
enable context specialization in TurboFan
turbo_inlining
enable inlining in TurboFan
trace_turbo_inlining
trace TurboFan inlining
loop_assignment_analysis
perform loop assignment analysis
turbo_profiling
enable profiling in TurboFan
turbo_verify_allocation
verify register allocation in TurboFan
turbo_move_optimization
optimize gap moves in TurboFan
turbo_jt
enable jump threading in TurboFan
turbo_osr
enable OSR in TurboFan
turbo_try_catch
enable try-catch support in TurboFan
turbo_try_finally
enable try-finally support in TurboFan
turbo_stress_loop_peeling
stress loop peeling optimization
turbo_cf_optimization
optimize control flow in TurboFan
turbo_frame_elision
elide frames in TurboFan
turbo_cache_shared_code
cache context-independent code
typed_array_max_size_in_heap
threshold for in-heap typed array
frame_count
number of stack frames inspected by the profiler
interrupt_budget
execution budget before interrupt is triggered
type_info_threshold
percentage of ICs that must have type info to allow optimization
generic_ic_threshold
max percentage of megamorphic/generic ICs to allow optimization
self_opt_count
call count before self-optimization
trace_opt_verbose
extra verbose compilation tracing
debug_code
generate extra code (assertions) for debugging
code_comments
emit comments in code disassembly
enable_sse3
enable use of SSE3 instructions if available
enable_sse4_1
enable use of SSE4.1 instructions if available
enable_sahf
enable use of SAHF instruction if available (X64 only)
enable_avx
enable use of AVX instructions if available
enable_fma3
enable use of FMA3 instructions if available
enable_bmi1
enable use of BMI1 instructions if available
enable_bmi2
enable use of BMI2 instructions if available
enable_lzcnt
enable use of LZCNT instruction if available
enable_popcnt
enable use of POPCNT instruction if available
enable_vfp3
enable use of VFP3 instructions if available
enable_armv7
enable use of ARMv7 instructions if available (ARM only)
enable_armv8
enable use of ARMv8 instructions if available (ARM 32-bit only)
enable_neon
enable use of NEON instructions if available (ARM only)
enable_sudiv
enable use of SDIV and UDIV instructions if available (ARM only)
enable_mls
enable use of MLS instructions if available (ARM only)
enable_movw_movt
enable loading 32-bit constant by means of movw/movt instruction pairs (ARM only)
enable_unaligned_accesses
enable unaligned accesses for ARMv7 (ARM only)
enable_32dregs
enable use of d16-d31 registers on ARM - this requires VFP3
enable_vldr_imm
enable use of constant pools for double immediate (ARM only)
force_long_branches
force all emitted branches to be in long mode (MIPS/PPC only)
mcpu
enable optimization for specific cpu
expose_natives_as
expose natives in global object
expose_debug_as
expose debug in global object
expose_free_buffer
expose freeBuffer extension
expose_gc
expose gc extension
expose_gc_as
expose gc extension under the specified name
expose_externalize_string
expose externalize string extension
expose_trigger_failure
expose trigger-failure extension
stack_trace_limit
number of stack frames to capture
builtins_in_stack_traces
show built-in functions in stack traces
disable_native_files
disable builtin natives files
inline_new
use fast inline allocation
trace_codegen
print name of functions for which code is generated
trace
trace function calls
mask_constants_with_cookie
use random jit cookie to mask large constants
use lazy compilation
trace_opt
trace lazy optimization
trace_opt_stats
trace lazy optimization statistics
use adaptive optimizations
always_opt
always try to optimize functions
always_osr
always try to OSR functions
prepare_always_opt
prepare for turning on always opt
trace_deopt
trace optimize function deoptimization
trace_stub_failures
trace deoptimization of generated code stubs
serialize_toplevel
enable caching of toplevel scripts
serialize_inner
enable caching of inner functions
trace_serializer
print code serializer trace
min_preparse_length
minimum length for automatic enable preparsing
max_opt_count
maximum number of optimization attempts before giving up.
compilation_cache
enable compilation cache
cache_prototype_transitions
cache prototype transitions
cpu_profiler_sampling_interval
CPU profiler sampling interval in microseconds
trace_debug_json
trace debugging JSON request/response
trace_js_array_abuse
trace out-of-bounds accesses to JS arrays
trace_external_array_abuse
trace out-of-bounds-accesses to external arrays
trace_array_abuse
trace out-of-bounds accesses to all arrays
enable_liveedit
enable liveedit experimental feature
hard_abort
abort by crashing
stack_size
default size of stack region v8 is allowed to use (in kBytes)
max_stack_trace_source_length
maximum length of function source code printed in a stack trace.
always_inline_smi_code
always inline smi code in non-opt code
min_semi_space_size
min size of a semi-space (in MBytes), the new space consists of twosemi-spaces
target_semi_space_size
target size of a semi-space (in MBytes) before triggering a GC
max_semi_space_size
max size of a semi-space (in MBytes), the new space consists of twosemi-spaces
semi_space_growth_factor
factor by which to grow the new space
experimental_new_space_growth_heuristic
Grow the new space based on the percentage of survivors instead of their absolute value.
max_old_space_size
max size of the old space (in Mbytes)
initial_old_space_size
initial old space size (in Mbytes)
max_executable_size
max size of executable memory (in Mbytes)
gc_global
always perform global GCs
gc_interval
garbage collect after <n> allocations
retain_maps_for_n_gc
keeps maps alive for <n> old space garbage collections
trace_gc
print one trace line following each garbage collection
trace_gc_nvp
print one detailed trace line in name=value format after each garbage collection
trace_gc_ignore_scavenger
do not print trace line after scavenger collection
trace_idle_notification
print one trace line following each idle notification
trace_idle_notification_verbose
prints the heap state used by the idle notification
print_cumulative_gc_stat
print cumulative GC statistics in name=value format on exit
print_max_heap_committed
print statistics of the maximum memory committed for the heap in name=value format on exit
trace_gc_verbose
print more details following each garbage collection
trace_allocation_stack_interval
print stack trace after <n> free-list allocations
trace_fragmentation
report fragmentation for old space
trace_fragmentation_verbose
report fragmentation for old space (detailed)
trace_mutator_utilization
print mutator utilization, allocation speed, gc speed
weak_embedded_maps_in_optimized_code
make maps embedded in optimized code weak
weak_embedded_objects_in_optimized_code
make objects embedded in optimized code weak
flush_code
flush code that we expect not to use again
trace_code_flushing
trace code flushing progress
age_code
track un-executed functions to age code and flush only old code (required for code flushing)
incremental_marking
use incremental marking
incremental_marking_steps
do incremental marking steps
overapproximate_weak_closure
overapproximate weak closer to reduce atomic pause time
min_progress_during_object_groups_marking
keep overapproximating the weak closure as long as we discover at least this many unmarked objects
max_object_groups_marking_rounds
at most try this many times to over approximate the weak closure
concurrent_sweeping
use concurrent sweeping
trace_incremental_marking
trace progress of the incremental marking
track_gc_object_stats
track object counts and memory usage
trace_gc_object_stats
trace object counts and memory usage
track_detached_contexts
track native contexts that are expected to be garbage collected
trace_detached_contexts
trace native contexts that are expected to be garbage collected
histogram_interval
time interval in ms for aggregating memory histograms
heap_profiler_trace_objects
Dump heap object allocations/movements/size_updates
use_idle_notification
Use idle notification to reduce memory footprint.
use_ic
use inline caching
trace_ic
trace inline cache state transitions
vector_stores
use vectors for store ics
native_code_counters
generate extra code for manipulating stats counters
always_compact
Perform compaction on every full GC
never_compact
Never perform compaction on full GC - testing only
compact_code_space
Compact code space on full collections
cleanup_code_caches_at_gc
Flush inline caches prior to mark compact collection and flush code caches in maps during mark compact cycle.
use_marking_progress_bar
Use a progress bar to scan large objects in increments when incremental marking is active.
zap_code_space
Zap free memory in code space with 0xCC while sweeping.
random_seed
Default seed for initializing random generator (0, the default, means to use system random).
trace_weak_arrays
Trace WeakFixedArray usage
track_prototype_users
Keep track of which maps refer to a given prototype object
trace_prototype_users
Trace updates to prototype user tracking
eliminate_prototype_chain_checks
Collapse prototype chain checks into single-cell checks
use_verbose_printer
allows verbose printing
allow_natives_syntax
allow natives syntax
trace_parse
trace parsing and preparsing
trace_sim
Trace simulator execution
debug_sim
Enable debugging the simulator
check_icache
Check icache flushes in ARM and MIPS simulator
stop_sim_at
Simulator stop after x number of instructions
sim_stack_alignment
Stack alingment in bytes in simulator (4 or 8, 8 is default)
sim_stack_size
Stack size of the ARM64, MIPS64 and PPC64 simulator in kBytes (default is 2 MB)
log_regs_modified
When logging register values, only print modified registers.
log_colour
When logging, try to use coloured output.
ignore_asm_unimplemented_break
Don't break for ASM_UNIMPLEMENTED_BREAK macros.
trace_sim_messages
Trace simulator debug messages. Implied by --trace-sim.
stack_trace_on_illegal
print stack trace when an illegal exception is thrown
abort_on_uncaught_exception
abort program (dump core) when an uncaught exception is thrown
randomize_hashes
randomize hashes to avoid predictable hash collisions (with snapshots this option cannot override the baked-in seed)
Fixed seed to use to hash property keys (0 means random)(with snapshots this option cannot override the baked-in seed)
profile_deserialization
Print the time it takes to deserialize the snapshot.
serialization_statistics
Collect statistics on serialized objects.
regexp_optimization
generate optimized regexp code
testing_bool_flag
testing_maybe_bool_flag
testing_int_flag
testing_float_flag
float-flag
testing_string_flag
string-flag
testing_prng_seed
Seed used for threading test randomness
testing_serialization_file
file in which to serialize heap
startup_blob
Write V8 startup blob file. (mksnapshot only)
profile_hydrogen_code_stub_compilation
Print the time it takes to lazily compile hydrogen code stubs.
predictable
enable predictable mode
force_marking_deque_overflows
force overflows of marking deque by reducing it's size to 64 words
stress_compaction
stress the GC compactor to flush out bugs (implies --force_marking_deque_overflows)
manual_evacuation_candidates_selection
Test mode only flag. It allows an unit test to select evacuation candidates pages (requires --stress_compaction).
help
Print usage message, including flags, on console
dump_counters
Dump counters on exit
Enable JavaScript debugger
map_counters
Map counters to a file
js_arguments
Pass all remaining arguments to the script. Alias for "--".
Minimal logging (no API, code, GC, suspect, or handles samples).
log_all
Log all events to the log file.
log_api
Log API events to the log file.
log_code
Log code events to the log file without profiling.
log_gc
Log heap samples on garbage collection for the hp2ps tool.
log_handles
Log global handle events.
log_snapshot_positions
log positions of (de)serialized objects in the snapshot.
log_suspect
Log suspect operations.
prof
Log statistical profiling information (implies --log-code).
prof_cpp
Like --prof, but ignore generated code.
prof_browser_mode
Used with --prof, turns on browser-compatible mode for profiling.
log_regexp
Log regular expression execution.
logfile
Specify the name of the log file.
logfile_per_isolate
Separate log files for each isolate.
ll_prof
Enable low-level linux profiler.
perf_basic_prof
Enable perf linux profiler (basic support).
perf_basic_prof_only_functions
Only report function code ranges to perf (i.e. no stubs).
gc_fake_mmap
Specify the name of the file for fake gc mmap used in ll_prof
log_internal_timer_events
Time internal events.
log_timer_events
Time events including external callbacks.
log_instruction_stats
Log AArch64 instruction statistics.
log_instruction_file
AArch64 instruction statistics log file.
log_instruction_period
AArch64 instruction statistics logging period.
redirect_code_traces
output deopt information and disassembly into file code-<pid>-<isolate id>.asm
redirect_code_traces_to
output deopt information and disassembly into the given file
hydrogen_track_positions
track source code positions when building IR
trace_elements_transitions
trace elements transitions
trace_creation_allocation_sites
trace the creation of allocation sites
print_code_stubs
print code stubs
test_secondary_stub_cache
test secondary stub cache by disabling the primary one
test_primary_stub_cache
test primary stub cache by disabling the secondary one
print_code
print generated code
print_opt_code
print optimized code
print_unopt_code
print unoptimized code before printing optimized code based on it
print_code_verbose
print more information for code
print_builtin_code
print generated code for builtins
sodium
print generated code output suitable for use with the Sodium code viewer
print_all_code
enable all flags related to printing code
unset
../deps/v8/src/flags.cc
n < static_cast<size_t>(buffer_size)
bool
maybe_bool
float
string
arguments
 at %s:%d
 at <unknown>:%d
 at <unknown>:<unknown>
new 
(this=
receiver: 
function: 
code: 
 NON-OPT
 OPT
pc: %d
../deps/v8/src/frames.cc
(Translation::JS_FRAME_FUNCTION)==(opcode)
%5d: 
[%d]: 
:~%d
] [pc=%p] 
(this=%o
// optimized frame
  // stack-allocated locals
  var 
// no expression found - inconsistent frame?
  // heap-allocated locals
// warning: missing context slot - inconsistent frame?
// warning: no context found - inconsistent frame?
  // expression stack (top to bottom)
  [%02d] : %o
arguments adaptor frame: %d->%d
  // actual arguments
  [%02d] : %o
  // not passed to callee
--------- s o u r c e   c o d e ---------
-----------------------------------------
full
../deps/v8/src/full-codegen.cc
(0)==(scope->num_stack_slots())
.result
../deps/v8/src/global-handles.cc
object_ != NULL
object_ != nullptr
state() != NEAR_DEATH
v8::HandleScope::CreateHandle()
Cannot create a handle without a HandleScope
%6lu @%6u %*c %s%s: 
%s %.40s
!!! unknown edge type: %d 
/hidden/
/object/
/closure/
/string/
/code/
/array/
/regexp/
/number/
/native/
/synthetic/
/concatenated string/
/sliced string/
/symbol/
/simd/
(GC roots)
Move object from %p to %p old size %6d new size %6d
Update object size : %p with old size %d and new size %d
Begin HeapObjectsMap::UpdateHeapObjectsMap. map has %d entries.
HeapObjectsMap::UpdateHeapObjectsMap
Update object      : %p %6d. Next address is %p
End HeapObjectsMap::UpdateHeapObjectsMap. map has %d entries.
../deps/v8/src/heap-snapshot-generator.cc
Check failed: %s.
(obj->Size())==(static_cast<int>(entry_info.size))
Begin HeapObjectsMap::FindUntrackedObjects. %d entries in map.
%d objects were skipped
Last %d objects were skipped
End HeapObjectsMap::FindUntrackedObjects. %d entries in map.
native_bind
%s / %s
(concatenated string)
(sliced string)
symbol
system / NativeContext
system / Context
number
simd
system / Map (String)
system / Map (OneByteString)
system / Map (ConsString)
system / Map (ConsOneByteString)
system / Map (SlicedString)
system / Map (SlicedOneByteString)
system / Map (ExternalString)
system / Map (ExternalOneByteString)
system / Map (ExternalStringWithOneByteData)
system / Map (ShortExternalString)
system / Map (ShortExternalOneByteString)
system / Map (ShortExternalStringWithOneByteData)
system / Map (InternalizedString)
system / Map (OneByteInternalizedString)
system / Map (ExternalInternalizedString)
system / Map (ExternalOneByteInternalizedString)
system / Map (ExternalInternalizedStringWithOneByteData)
system / Map (ShortExternalInternalizedString)
system / Map (ShortExternalOneByteInternalizedString)
system / Map (ShortExternalInternalizedStringWithOneByteData)
system / Map
system / Cell
system / PropertyCell
system / Foreign
system / Oddball
system / Box
system / ExecutableAccessorInfo
system / AccessorPair
system / AccessCheckInfo
system / InterceptorInfo
system / CallHandlerInfo
system / FunctionTemplateInfo
system / ObjectTemplateInfo
system / TypeSwitchInfo
system / Script
system / AllocationSite
system / AllocationMemento
system / CodeCache
system / PolymorphicCodeCache
system / TypeFeedbackInfo
system / AliasedArgumentsEntry
system / DebugInfo
system / BreakPointInfo
system / PrototypeInfo
system
native_context
initial_map
(function bindings)
(function literals)
bindings
literals
(shared function info)
shared
(context)
next_function_link
builtins
global_proxy
buffer
(object properties)
properties
(object elements)
elements
first
second
parent
table
closure
previous
extension
global
(context func. result caches)
(context norm. map cache)
(runtime context)
(context data)
global_proxy_object
security_token
boolean_function
number_function
string_function
string_function_prototype_map
symbol_function
object_function
js_object_strong_map
internal_array_function
array_function
js_array_maps
js_array_strong_maps
date_function
json_object
regexp_function
initial_object_prototype
initial_array_prototype
create_date_fun
to_number_fun
to_string_fun
to_detail_string_fun
to_object_fun
to_integer_fun
to_uint32_fun
to_int32_fun
to_length_fun
global_eval_fun
array_buffer_fun
shared_array_buffer_fun
array_buffer_map
uint8_array_fun
int8_array_fun
uint16_array_fun
int16_array_fun
uint32_array_fun
int32_array_fun
float32_array_fun
float64_array_fun
uint8_clamped_array_fun
int8_array_external_map
uint8_array_external_map
int16_array_external_map
uint16_array_external_map
int32_array_external_map
uint32_array_external_map
float32_array_external_map
float64_array_external_map
uint8_clamped_array_external_map
data_view_fun
sloppy_function_map
sloppy_function_with_readonly_prototype_map
strict_function_map
strong_function_map
sloppy_function_without_prototype_map
strict_function_without_prototype_map
strong_constructor_map
bound_function_map
regexp_result_map
sloppy_arguments_map
fast_aliased_arguments_map
slow_aliased_arguments_map
strict_arguments_map
message_listeners
make_message_fun
get_stack_trace_line_fun
configure_global_fun
function_cache
jsfunction_result_caches
normalized_map_cache
runtime_context
call_as_function_delegate
call_as_constructor_delegate
script_function
opaque_reference_function
context_extension_function
map_cache
strong_map_cache
embedder_data
allow_code_gen_from_strings
error_message_for_code_gen_from_strings
promise_status
promise_value
promise_create
promise_resolve
promise_reject
promise_chain
promise_catch
promise_then
to_complete_property_descriptor
derived_has_trap
derived_get_trap
derived_set_trap
proxy_enumerate
observers_notify_change
observers_enqueue_splice
observers_begin_perform_splice
observers_end_perform_splice
native_object_observe
native_object_get_notifier
native_object_notifier_perform_change
sloppy_generator_function_map
strict_generator_function_map
strong_generator_function_map
generator_object_prototype_map
iterator_result_map
js_map_fun
js_map_map
js_set_fun
js_set_map
map_get
map_set
map_has
map_delete
set_add
set_has
set_delete
map_from_array
set_from_array
map_iterator_map
set_iterator_map
array_values_iterator
script_context_table
natives_utils_object
extras_exports_object
optimized_functions_list
optimized_code_list
deoptimized_code_list
next_context_link
(prototype transitions
prototype_transitions
(transition array)
transitions
(transition)
transition
prototype_info
(map descriptors)
descriptors
code_cache
(back pointer)
back_pointer
constructor
(dependent code)
dependent_code
(code for %s)
(%s code)
(function scope info)
scope_info
instance_class_name
script
(construct stub code for %s)
(construct stub code)
construct_stub
function_data
debug_info
inferred_name
optimized_code_map
feedback_vector
source
(script line ends)
expected_receiver_type
getter
data
(default code cache)
default_cache
(code type cache)
type_cache
(%s builtin)
(code relocation info)
relocation_info
handler_table
(code deopt data)
deoptimization_data
type_feedback_info
gc_metadata
next_code_link
transition_info
nested_site
backing_store
bound_this
bound_function
bound_argument_%d
(hidden properties)
hidden_properties
get %s
set %s
byte_array_map
free_space_map
one_pointer_filler_map
two_pointer_filler_map
store_buffer_top
undefined_value
the_hole_value
null_value
true_value
false_value
empty_string
uninitialized_value
cell_map
global_property_cell_map
shared_function_info_map
meta_map
heap_number_map
mutable_heap_number_map
float32x4_map
native_context_map
fixed_array_map
code_map
scope_info_map
fixed_cow_array_map
fixed_double_array_map
weak_cell_map
one_byte_string_map
one_byte_internalized_string_map
function_context_map
empty_fixed_array
empty_byte_array
empty_descriptor_array
no_interceptor_result_sentinel
arguments_marker
exception
termination_exception
number_string_cache
instanceof_cache_function
instanceof_cache_map
instanceof_cache_answer
single_character_string_cache
string_split_cache
regexp_multiple_cache
hash_seed
hash_table_map
ordered_hash_table_map
symbol_map
string_map
cons_one_byte_string_map
cons_string_map
sliced_string_map
sliced_one_byte_string_map
external_string_map
external_string_with_one_byte_data_map
external_one_byte_string_map
native_source_string_map
short_external_string_map
short_external_string_with_one_byte_data_map
internalized_string_map
external_internalized_string_map
external_internalized_string_with_one_byte_data_map
external_one_byte_internalized_string_map
short_external_internalized_string_map
short_external_internalized_string_with_one_byte_data_map
short_external_one_byte_internalized_string_map
short_external_one_byte_string_map
external_int8_array_map
external_uint8_array_map
external_int16_array_map
external_uint16_array_map
external_int32_array_map
external_uint32_array_map
external_float32_array_map
external_float64_array_map
external_uint8_clamped_array_map
empty_external_int8_array
empty_external_uint8_array
empty_external_int16_array
empty_external_uint16_array
empty_external_int32_array
empty_external_uint32_array
empty_external_float32_array
empty_external_float64_array
empty_external_uint8_clamped_array
fixed_uint8_array_map
fixed_int8_array_map
fixed_uint16_array_map
fixed_int16_array_map
fixed_uint32_array_map
fixed_int32_array_map
fixed_float32_array_map
fixed_float64_array_map
fixed_uint8_clamped_array_map
empty_fixed_uint8_array
empty_fixed_int8_array
empty_fixed_uint16_array
empty_fixed_int16_array
empty_fixed_uint32_array
empty_fixed_int32_array
empty_fixed_float32_array
empty_fixed_float64_array
empty_fixed_uint8_clamped_array
sloppy_arguments_elements_map
catch_context_map
with_context_map
block_context_map
module_context_map
script_context_map
script_context_table_map
undefined_map
the_hole_map
null_map
boolean_map
uninitialized_map
arguments_marker_map
no_interceptor_result_sentinel_map
exception_map
termination_exception_map
message_object_map
foreign_map
neander_map
external_map
nan_value
infinity_value
minus_zero_value
minus_infinity_value
code_stubs
non_monomorphic_cache
polymorphic_code_cache
js_entry_code
js_construct_entry_code
natives_source_cache
experimental_natives_source_cache
extra_natives_source_cache
empty_script
intrinsic_function_names
undefined_cell
observation_state
symbol_registry
empty_slow_element_dictionary
materialized_objects
allocation_sites_scratchpad
microtask_queue
keyed_load_dummy_vector
keyed_store_dummy_vector
detached_contexts
retained_maps
weak_object_to_code_table
array_protector
empty_property_cell
weak_stack_trace_list
box_map
executable_accessor_info_map
accessor_pair_map
access_check_info_map
interceptor_info_map
call_handler_info_map
function_template_info_map
object_template_info_map
type_switch_info_map
script_map
allocation_site_map
allocation_memento_map
code_cache_map
polymorphic_code_cache_map
type_feedback_info_map
aliased_arguments_entry_map
debug_info_map
break_point_info_map
prototype_info_map
Object_string
proto_string
arguments_string
Arguments_string
caller_string
boolean_string
Boolean_string
callee_string
constructor_string
dot_result_string
eval_string
function_string
Function_string
length_string
name_string
null_string
number_string
Number_string
nan_string
source_string
source_url_string
source_mapping_url_string
this_string
global_string
ignore_case_string
multiline_string
sticky_string
unicode_string
harmony_regexps_string
harmony_tostring_string
harmony_unicode_regexps_string
input_string
index_string
last_index_string
object_string
prototype_string
string_string
String_string
symbol_string
Symbol_string
Map_string
Set_string
WeakMap_string
WeakSet_string
for_string
for_api_string
for_intern_string
private_api_string
private_intern_string
Date_string
char_at_string
undefined_string
value_of_string
stack_string
toJSON_string
KeyedLoadMonomorphic_string
KeyedStoreMonomorphic_string
stack_overflow_string
illegal_access_string
cell_value_string
illegal_argument_string
closure_string
dot_string
compare_ic_string
strict_compare_ic_string
infinity_string
minus_infinity_string
query_colon_string
Generator_string
throw_string
done_string
value_string
next_string
byte_length_string
byte_offset_string
minus_zero_string
Array_string
Error_string
RegExp_string
nonextensible_symbol
sealed_symbol
hash_code_symbol
frozen_symbol
nonexistent_symbol
elements_transition_symbol
observed_symbol
uninitialized_symbol
megamorphic_symbol
premonomorphic_symbol
stack_trace_symbol
detailed_stack_trace_symbol
normal_ic_symbol
home_object_symbol
intl_initialized_marker_symbol
intl_impl_object_symbol
promise_debug_marker_symbol
promise_has_handler_symbol
class_script_symbol
class_start_position_symbol
class_end_position_symbol
error_start_pos_symbol
error_end_pos_symbol
error_script_symbol
has_instance_symbol
is_concat_spreadable_symbol
is_regexp_symbol
iterator_symbol
to_string_tag_symbol
unscopables_symbol
!strong_gc_subroot_names_.is_empty()
%s / %ld entries
native
HeapSnapshotGenerator::GenerateSnapshot
"snapshot":{
"nodes":[
"edges":[
"trace_function_infos":[
"trace_tree":[
"samples":[
"strings":[
"meta":
{"node_fields":["type","name","id","self_size","edge_count","trace_node_id"],"node_types":[["hidden","array","string","object","code","closure","regexp","number","native","synthetic","concatenated string","sliced string"],"string","number","number","number","number","number"],"edge_fields":["type","name_or_index","to_node"],"edge_types":[["context","element","property","internal","hidden","shortcut","weak"],"string_or_number","node"],"trace_function_info_fields":["function_id","name","script_name","script_id","line","column"],"trace_node_fields":["id","function_info_index","count","size","children"],"sample_fields":["timestamp_us","last_assigned_id"]}
,"node_count":
,"edge_count":
,"trace_function_count":
"<dummy>"
Untracked object   : %p %6d. Next address is %p
Wrong size %6d: %p %6d. Next address is %p
Good object      : %p %6d. Next address is %p
../deps/v8/src/conversions.h
system / JSArrayBufferData
!disposed_
0123456789ABCDEF
HashMap::Initialize
Memory reducer: started GC #%d
Memory reducer: waiting for %.f ms
Memory reducer: finished GC #%d (%s)
will do more
done
memory reducer background GC
Memory reducer: started GC #%d (background idle)
no action
incremental marking with step %ld / ms
; finalized marking
full GC
finalize sweeping
contexts_disposed=%d 
contexts_disposal_rate=%f 
size_of_objects=%ld 
incremental_marking_stopped=%d 
sweeping_in_progress=%d 
has_low_allocation_rate=%d
mark_compact_speed=%ld 
incremental_marking_speed=%ld 
scavenge_speed=%ld 
new_space_size=%ld 
new_space_capacity=%ld 
new_space_allocation_throughput=%ld 
Scavenge
Mark-sweep
Unknown Event Type
[Finished reentrant %s during %s.]
%8.0f ms: 
%s %.1f (%.1f) -> %.1f (%.1f) MB, 
%.1f / %d ms
 (+ %.1f ms in %d steps since last GC)
 (+ %.1f ms in %d steps since start of marking, biggest step %.1f ms)
 [%s]
[I:%p] %8.0f ms: 
pause=%.1f 
mutator=%.1f 
gc=%s 
external=%.1f 
mark=%.1f 
sweep=%.2f 
sweepns=%.2f 
sweepos=%.2f 
sweepcode=%.2f 
sweepcell=%.2f 
sweepmap=%.2f 
evacuate=%.1f 
new_new=%.1f 
root_new=%.1f 
old_new=%.1f 
compaction_ptrs=%.1f 
intracompaction_ptrs=%.1f 
misc_compaction=%.1f 
weak_closure=%.1f 
inc_weak_closure=%.1f 
weakcollection_process=%.1f 
weakcollection_clear=%.1f 
weakcollection_abort=%.1f 
total_size_before=%ld 
total_size_after=%ld 
holes_size_before=%ld 
holes_size_after=%ld 
allocated=%ld 
promoted=%ld 
semi_space_copied=%ld 
nodes_died_in_new=%d 
nodes_copied_in_new=%d 
nodes_promoted=%d 
promotion_ratio=%.1f%% 
average_survival_ratio=%.1f%% 
promotion_rate=%.1f%% 
semi_space_copy_rate=%.1f%% 
context_disposal_rate=%.1f 
steps_count=%d 
steps_took=%.1f 
scavenge_throughput=%ld 
longest_step=%.1f 
incremental_marking_throughput=%ld 
GC in old space requested
GC in old space forced by flags
promotion limit reached
old generations exhausted
scavenge might not succeed
Memory allocator,   used: %6ld KB, available: %6ld KB
New space,          used: %6ld KB, available: %6ld KB, committed: %6ld KB
Old space,          used: %6ld KB, available: %6ld KB, committed: %6ld KB
Code space,         used: %6ld KB, available: %6ld KB, committed: %6ld KB
Map space,          used: %6ld KB, available: %6ld KB, committed: %6ld KB
Large object space, used: %6ld KB, available: %6ld KB, committed: %6ld KB
All spaces,         used: %6ld KB, available: %6ld KB, committed: %6ld KB
External memory reported: %6ld KB
Total time spent in GC  : %.1f ms
new_space
old_space
map_space
code_space
large_object_space
GC: (mode, #visited allocation sites, #active allocation sites, #mementos, #tenure decisions, #donttenure decisions) (%s, %d, %d, %d, %d, %d)
use scratchpad
use list
GC interrupt
[IncrementalMarking] Overapproximate weak closure (%s).
[IncrementalMarking] Scavenge during marking.
[IncrementalMarking] Delaying MarkSweep.
incremental marking delaying mark-sweep
GC epilogue
failed to reserve space in the new space
failed to reserve space in paged or large object space, trying to reduce memory footprint
failed to reserve space in paged or large object space
Committing semi space failed.
markcompact
begin
Deopt all allocation sites dependent code due to low survival rate in the old generation %f
Postpone entering high promotion mode as optimized pretenuring code is still being generated
Limited new space size due to high promotion rate: %d MB
Unlimited new space size due to low promotion rate: %d MB
Object
Arguments
caller
boolean
callee
function
source_url
source_mapping_url
this
ignoreCase
multiline
sticky
unicode
input
index
lastIndex
for_api
for_intern
private_api
private_intern
CharAt
valueOf
toJSON
KeyedLoadMonomorphic
KeyedStoreMonomorphic
$stackOverflowBoilerplate
illegal access
%cell_value
illegal argument
(closure)
(?:)
next
byteLength
byteOffset
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.isRegExp
Symbol.iterator
Symbol.toStringTag
Symbol.unscopables
invalid array length
../deps/v8/src/heap/heap.cc
map->instance_type() == JS_OBJECT_TYPE || map->instance_type() == JS_ARRAY_TYPE
Heap::MakeHeapIterable
Young generation mutator utilization = %.3f (mutator_speed=%.f, gc_speed=%.f)
Old generation mutator utilization = %.3f (mutator_speed=%.f, gc_speed=%.f)
Idle notification: overapproximate weak closure
idle notification: finalize incremental
idle notification: contexts disposed
idle notification: scavenge
Idle notification: requested idle time %.2f ms, used idle time %.2f ms, deadline usage %.2f ms [
HasBeenSetUp()
Max semi-space size cannot be more than %d kbytes
Min semi-space size cannot be more than the maximum semi-space size of %d MB
Target semi-space size cannot be less than the minimum semi-space size of %d MB
Target semi-space size cannot be less than the maximum semi-space size of %d MB
factor > 1.0
old_gen_size > 0
Heap growing factor %.1f based on mu=%.3f, speed_ratio=%.f (gc=%.f, mutator=%.f)
Grow: old size: %ld KB, new limit: %ld KB (%.1f)
Dampen: old size: %ld KB, old limit: %ld KB, new limit: %ld KB (%.1f)
heap-capacity
heap-available
(0u)==(gc_count_)
gc_count=%d 
mark_sweep_count=%d 
max_gc_pause=%.1f 
total_gc_time=%.1f 
min_in_mutator=%.1f 
max_alive_after_gc=%ld 
total_marking_time=%.1f 
total_sweeping_time=%.1f 
maximum_committed_by_heap=%ld 
maximum_committed_by_new_space=%ld 
maximum_committed_by_old_space=%ld 
maximum_committed_by_code_space=%ld 
maximum_committed_by_map_space=%ld 
maximum_committed_by_lo_space=%ld 
heap:%p, time:%f, gc:%d, type:%s, count:%d, size:%d
STRING_TYPE
ONE_BYTE_STRING_TYPE
CONS_STRING_TYPE
CONS_ONE_BYTE_STRING_TYPE
SLICED_STRING_TYPE
SLICED_ONE_BYTE_STRING_TYPE
EXTERNAL_STRING_TYPE
EXTERNAL_ONE_BYTE_STRING_TYPE
EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
SHORT_EXTERNAL_STRING_TYPE
SHORT_EXTERNAL_ONE_BYTE_STRING_TYPE
SHORT_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE
INTERNALIZED_STRING_TYPE
ONE_BYTE_INTERNALIZED_STRING_TYPE
EXTERNAL_INTERNALIZED_STRING_TYPE
EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
SHORT_EXTERNAL_INTERNALIZED_STRING_TYPE
SHORT_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE
SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE
SYMBOL_TYPE
MAP_TYPE
CODE_TYPE
ODDBALL_TYPE
CELL_TYPE
PROPERTY_CELL_TYPE
HEAP_NUMBER_TYPE
MUTABLE_HEAP_NUMBER_TYPE
FLOAT32X4_TYPE
FOREIGN_TYPE
BYTE_ARRAY_TYPE
FREE_SPACE_TYPE
EXTERNAL_INT8_ARRAY_TYPE
EXTERNAL_UINT8_ARRAY_TYPE
EXTERNAL_INT16_ARRAY_TYPE
EXTERNAL_UINT16_ARRAY_TYPE
EXTERNAL_INT32_ARRAY_TYPE
EXTERNAL_UINT32_ARRAY_TYPE
EXTERNAL_FLOAT32_ARRAY_TYPE
EXTERNAL_FLOAT64_ARRAY_TYPE
EXTERNAL_UINT8_CLAMPED_ARRAY_TYPE
FIXED_INT8_ARRAY_TYPE
FIXED_UINT8_ARRAY_TYPE
FIXED_INT16_ARRAY_TYPE
FIXED_UINT16_ARRAY_TYPE
FIXED_INT32_ARRAY_TYPE
FIXED_UINT32_ARRAY_TYPE
FIXED_FLOAT32_ARRAY_TYPE
FIXED_FLOAT64_ARRAY_TYPE
FIXED_UINT8_CLAMPED_ARRAY_TYPE
FILLER_TYPE
DECLARED_ACCESSOR_DESCRIPTOR_TYPE
DECLARED_ACCESSOR_INFO_TYPE
EXECUTABLE_ACCESSOR_INFO_TYPE
ACCESSOR_PAIR_TYPE
ACCESS_CHECK_INFO_TYPE
INTERCEPTOR_INFO_TYPE
CALL_HANDLER_INFO_TYPE
FUNCTION_TEMPLATE_INFO_TYPE
OBJECT_TEMPLATE_INFO_TYPE
SIGNATURE_INFO_TYPE
TYPE_SWITCH_INFO_TYPE
ALLOCATION_MEMENTO_TYPE
ALLOCATION_SITE_TYPE
SCRIPT_TYPE
CODE_CACHE_TYPE
POLYMORPHIC_CODE_CACHE_TYPE
TYPE_FEEDBACK_INFO_TYPE
ALIASED_ARGUMENTS_ENTRY_TYPE
BOX_TYPE
PROTOTYPE_INFO_TYPE
FIXED_ARRAY_TYPE
FIXED_DOUBLE_ARRAY_TYPE
SHARED_FUNCTION_INFO_TYPE
WEAK_CELL_TYPE
JS_MESSAGE_OBJECT_TYPE
JS_VALUE_TYPE
JS_DATE_TYPE
JS_OBJECT_TYPE
JS_CONTEXT_EXTENSION_OBJECT_TYPE
JS_GENERATOR_OBJECT_TYPE
JS_MODULE_TYPE
JS_GLOBAL_OBJECT_TYPE
JS_BUILTINS_OBJECT_TYPE
JS_GLOBAL_PROXY_TYPE
JS_ARRAY_TYPE
JS_ARRAY_BUFFER_TYPE
JS_TYPED_ARRAY_TYPE
JS_DATA_VIEW_TYPE
JS_PROXY_TYPE
JS_SET_TYPE
JS_MAP_TYPE
JS_SET_ITERATOR_TYPE
JS_MAP_ITERATOR_TYPE
JS_WEAK_MAP_TYPE
JS_WEAK_SET_TYPE
JS_REGEXP_TYPE
JS_FUNCTION_TYPE
JS_FUNCTION_PROXY_TYPE
DEBUG_INFO_TYPE
BREAK_POINT_INFO_TYPE
*CODE_FUNCTION
*CODE_OPTIMIZED_FUNCTION
*CODE_STUB
*CODE_HANDLER
*CODE_BUILTIN
*CODE_REGEXP
*CODE_LOAD_IC
*CODE_KEYED_LOAD_IC
*CODE_CALL_IC
*CODE_STORE_IC
*CODE_KEYED_STORE_IC
*CODE_BINARY_OP_IC
*CODE_COMPARE_IC
*CODE_COMPARE_NIL_IC
*CODE_TO_BOOLEAN_IC
*FIXED_ARRAY_FAST_ELEMENTS_SUB_TYPE
*FIXED_ARRAY_DICTIONARY_ELEMENTS_SUB_TYPE
*FIXED_ARRAY_FAST_PROPERTIES_SUB_TYPE
*FIXED_ARRAY_DICTIONARY_PROPERTIES_SUB_TYPE
*FIXED_ARRAY_MAP_CODE_CACHE_SUB_TYPE
*FIXED_ARRAY_SCOPE_INFO_SUB_TYPE
*FIXED_ARRAY_STRING_TABLE_SUB_TYPE
*FIXED_ARRAY_DESCRIPTOR_ARRAY_SUB_TYPE
*FIXED_ARRAY_TRANSITION_ARRAY_SUB_TYPE
*CODE_AGE_ToBeExecutedOnce
*CODE_AGE_NotExecuted
*CODE_AGE_ExecutedOnce
*CODE_AGE_NoAge
*CODE_AGE_Quadragenarian
*CODE_AGE_Quinquagenarian
*CODE_AGE_Sexagenarian
*CODE_AGE_Septuagenarian
*CODE_AGE_Octogenarian
CODE_KIND/FUNCTION
CODE_KIND/OPTIMIZED_FUNCTION
CODE_KIND/STUB
CODE_KIND/HANDLER
CODE_KIND/BUILTIN
CODE_KIND/REGEXP
CODE_KIND/LOAD_IC
CODE_KIND/KEYED_LOAD_IC
CODE_KIND/CALL_IC
CODE_KIND/STORE_IC
CODE_KIND/KEYED_STORE_IC
CODE_KIND/BINARY_OP_IC
CODE_KIND/COMPARE_IC
CODE_KIND/COMPARE_NIL_IC
CODE_KIND/TO_BOOLEAN_IC
FAST_ELEMENTS_SUB_TYPE
DICTIONARY_ELEMENTS_SUB_TYPE
FAST_PROPERTIES_SUB_TYPE
DICTIONARY_PROPERTIES_SUB_TYPE
MAP_CODE_CACHE_SUB_TYPE
SCOPE_INFO_SUB_TYPE
STRING_TABLE_SUB_TYPE
DESCRIPTOR_ARRAY_SUB_TYPE
TRANSITION_ARRAY_SUB_TYPE
CODE_AGE/ToBeExecutedOnce
CODE_AGE/NotExecuted
CODE_AGE/ExecutedOnce
CODE_AGE/NoAge
CODE_AGE/Quadragenarian
CODE_AGE/Quinquagenarian
CODE_AGE/Sexagenarian
CODE_AGE/Septuagenarian
CODE_AGE/Octogenarian
AllocationSite(%p): (created, found, ratio) (%d, %d, %f) %s => %s
handle_count_ < HandleScope::kCheckHandleThreshold
../deps/v8/src/heap/identity-map.cc
(0U)!=(raw_address)
(size_)<=((1024 * 1024 * 16))
Increasing marking speed to %d due to high promotion rate
[IncrementalMarking] Start (%s)
unknown reason
[IncrementalMarking] Start sweeping.
[IncrementalMarking] Start marking
[IncrementalMarking] Running
[IncrementalMarking] Hurry
[IncrementalMarking] Complete (hurry), spent %d ms.
[IncrementalMarking] Aborting.
[IncrementalMarking] requesting weak closure overapproximation.
[IncrementalMarking] Complete (normal).
old space step
Speed up marking after %d steps
Speed up marking because of low space left
Speed up marking because of heap size increase
Speed up marking because marker was not keeping up
Postponing speeding up marking until marking starts
Marking speed increased to %d
NEW_SPACE
OLD_SPACE
CODE_SPACE
MAP_SPACE
LO_SPACE
../deps/v8/src/heap/mark-compact.cc
!p->IsEvacuationCandidate()
p->slots_buffer() == NULL
Page in %s: %d KB free [fragmented if this >= %d KB], sum of live bytes in fragmented pages %d KB [max is %d KB]
Collected %d evacuation candidates [%d KB live] for space %s [mode %s]
reduce memory footprint
normal
[code-flushing clears: 
 - age: %d]
[code-flushing abandons function-info: 
[code-flushing abandons closure: 
[code-flushing abandons code-map: 
!marking_deque_.in_use()
EnsureMarkingDequeIsCommitted
large_object->IsHeapObject()
index_in_cell > 1
current_cell != 0
leading_zeros != 32
Marking::IsBlack(Marking::MarkBitFrom(object))
object->address() < reinterpret_cast<Address>(slot)
IsSlotInBlackObjectSlow(Page::FromAddress(slot), slot)
space->HasEmergencyMemory()
Evacuation
  Abandon %d out of %d page defragmentations due to lack of memory
  Defragmented %d pages
  migration slots buffer: %d
  page %p slots buffer: %d
[code-flushing is now %s]
!heap->InNewSpace(object)
Page %p is too popular. Disabling evacuation.
[%s]: %d pages, %d (%.1f%%) free
!IsRetry()
../deps/v8/src/heap/spaces.cc
CodeRange
MemoryAllocator::AllocateRawMemory
V8 Executable Allocation capacity exceeded
MemoryChunk
InitialChunk
!is_committed()
allocated
promoted
object->IsMap()
LargeObjectChunk
NewSpace
../deps/v8/src/heap/store-buffer.cc
(reinterpret_cast<uintptr_t>(old_start_) & 0xfff) == 0
kStoreBufferSize >= base::OS::CommitPageSize()
StoreBuffer::SetUp
object->IsHeapObject()
heap_->InNewSpace(object)
page->owner() == heap_->old_space()
hash_set_1_ == heap_->isolate()->store_buffer_hash_set_1_address()
hash_set_2_ == heap_->isolate()->store_buffer_hash_set_2_address()
Fresh bounds check data for block #%d: [%d]
Eliminating bounds check #%d, offset %d is covered
Updated bounds check data for block #%d: [%d - %d]
Eliminating check #%d after tightening
Moving second check #%d after first check #%d
Tightened check #%d with offset %d from #%d
H_Redundant phi elimination
Processing B%d, checkmaps-table:
  unreachable
  checkmaps-table @%d: %s #%d 
check #%d 
%d %s maps { 
checked
checked stable
unchecked stable
Replacing redundant CheckMaps #%d at B%d with #%d
Marking redundant CheckMaps #%d at B%d as stability check
Marking redundant CheckMaps #%d at B%d as dead
CheckMaps #%d at B%d narrowed
../deps/v8/src/hydrogen-check-elimination.cc
!instr->CheckChangesFlag(kMaps)
CompareMap #%d for #%d at B%d can't be eliminated: ambiguous set of maps
Marking redundant CompareMap #%d for #%d at B%d as %s
Marking redundant CompareObjectEqAndBranch #%d at B%d as false
Marking redundant IsStringAndBranch #%d at B%d as true
Marking redundant IsStringAndBranch #%d at B%d as false
../deps/v8/src/unique.h
size < kMaxCapacity
Removing redundant CheckInstanceType #%d at B%d
B%d checkmaps-table %s from B%d:
learned
copied
B%d checkmaps-table merged with B%d table:
[MarkLive 
root
H_Environment liveness analysis
#%d (%s) escapes through #%d (%s) @%d
#%d (%s) out of bounds at #%d (%s) @%d
#%d (%s) escapes redefinition #%d (%s) @%d
#%d (%s) is being captured
Analyzing data-flow in B%d
Replacing load #%d with #%d (%s)
Replacing store #%d%s
 (with transition)
inputs
uses
use requirements
#%d %s is used by #%d %s as %s%s
-trunc
Changing #%d %s representation %s -> %s based on %s
AbnormalExit
AccessArgumentsAt
AllocateBlockContext
ApplyArguments
ArgumentsElements
ArgumentsLength
ArgumentsObject
Bitwise
BlockEntry
BoundsCheck
BoundsCheckBaseIndexInformation
CallWithDescriptor
CallJSFunction
CallFunction
CallNew
CallNewArray
CallRuntime
CallStub
CapturedObject
Change
CheckArrayBufferNotNeutered
CheckHeapObject
CheckInstanceType
CheckMaps
CheckMapValue
CheckSmi
CheckValue
ClampToUint8
ClassOfTestAndBranch
CompareNumericAndBranch
CompareHoleAndBranch
CompareGeneric
CompareMinusZeroAndBranch
CompareObjectEqAndBranch
CompareMap
Constant
ConstructDouble
Context
DateField
DebugBreak
DeclareGlobals
DoubleBits
DummyUse
EnterInlined
EnvironmentMarker
ForceRepresentation
ForInCacheArray
ForInPrepareMap
FunctionLiteral
GetCachedArrayIndex
HasCachedArrayIndexAndBranch
HasInstanceTypeAndBranch
InnerAllocatedObject
InstanceOf
InstanceOfKnownGlobal
InvokeFunction
IsConstructCallAndBranch
IsObjectAndBranch
IsStringAndBranch
IsSmiAndBranch
IsUndetectableAndBranch
LeaveInlined
LoadContextSlot
LoadFieldByIndex
LoadFunctionPrototype
LoadGlobalGeneric
LoadKeyed
LoadKeyedGeneric
LoadNamedField
LoadNamedGeneric
LoadRoot
MapEnumLength
MathFloorOfDiv
MathMinMax
MaybeGrowElements
OsrEntry
Power
PushArguments
RegExpLiteral
SeqStringGetChar
SeqStringSetChar
Simulate
StoreCodeEntry
StoreContextSlot
StoreFrameContext
StoreKeyed
StoreKeyedGeneric
StoreNamedField
StoreNamedGeneric
StringAdd
StringCharCodeAt
StringCharFromCode
StringCompareAndBranch
ThisFunction
ToFastProperties
TransitionElementsKind
TrapAllocationMemento
Typeof
TypeofIsAndBranch
UnaryMathOperation
UnknownOSRValue
UseConst
WrapReceiver
 changes[
NewSpacePromotion
ArrayElements
ArrayLengths
StringLengths
BackingStoreFields
Calls
ContextSlots
DoubleArrayElements
DoubleFields
ElementsKind
ElementsPointer
GlobalVars
InobjectFields
Maps
OsrEntries
ExternalMemory
StringChars
TypedArrayElements
 [noOSE]
 [dead]
lookup
 var[
 (type-feedback-vector icslot 
 base: ((
) >> 
 [DISABLED]
boundscheck
base: 
, check: 
[save doubles] 
class_of_test(
], length 
 goto (
 (pop 
 values)
 [true]
 [false]
pow-half
 spec_object
 reg_exp
 array
 function
 == 
 truncating-smi
 truncating-int32
 -0?
 allow-undefined-as-nan
(stability-check)
internalized_string
expression
local
special
 uses:
#%d Phi is used by real #%d %s as %s
adding to #%d Phi uses of #%d Phi: s%d i%d d%d t%d
 pop 
] = 
 push 
[stable-map] 
[map 
[new space] 
output
 check_hole
 (write-barrier)
 (transition map 
] -> 
 (simple)
 offset 
#%d (%s) cannot fold into #%d (%s)
#%d (%s) cannot fold into #%d (%s), crosses basic blocks
#%d (%s) cannot fold into #%d (%s), dynamic allocation size in dominator
#%d (%s) cannot fold into #%d (%s), different spaces
#%d (%s) cannot fold into #%d (%s), can't estimate total allocation size
#%d (%s) cannot fold into #%d (%s), dynamic size value does not dominate target allocation
#%d (%s) cannot fold into #%d (%s) due to size: %d
#%d (%s) folded into #%d (%s)
_CheckBoth
_CheckLeft
_CheckRight
#%d %s is required by #%d %s as %s%s
%length
%elements
%map
[in-object]
[backing-store]
[external-memory]
HStringAdd with AllocationSite %p %s
H_Block building
H_Block ordering
H_Assign dominators
H_Restore actual values
Trying to inline the polymorphic call to %s from %s
Inlined %s called from %s.
Did not inline %s called from %s (%s).
target is api function
target text too big
target not inlineable
target contains unsupported syntax [early]
target AST is too large [early]
inline depth limit reached
target is recursive
cumulative AST node limit reached
parse failure
target has context-allocated variables
target AST is too large [late]
target contains unsupported syntax [late]
target uses arguments object
target has non-trivial declaration
could not generate deoptimization info
too few arguments passed to a strong function
inline graph construction failed
../deps/v8/src/hydrogen.cc
!isolate()->serializer_enabled()
Inlining api function 
Inlining builtin 
Constant length outside of valid inlining range.
Dont inline [new] Array(n) where n isn't constant.
Too many arguments to inline.
AllocationSite requested no inlining.
arguments->at(kInitializeArg)->IsLiteral()
!boilerplate_object->IsJSArray()
parameters
specials
locals
expressions
method "%s:%d"
 "B%d"
xhandlers
flags
 "dom-loop-succ"
 "dead"
 "osr"
 [hir:
] <|@
%d %s
 "%s"
 "double_stack:%d"
 "stack:%d"
 %d %d
 [%d, %d[
 %d M
--------------------------------------------------------------------------------
--- Hydrogen timing results:
--------------------------------------------------------------------------------
%33s
 %8.3f ms / %4.1f %% 
 %9zu bytes / %4.1f %%
--------------------------------------------------------------------------------
%33s %8.3f ms / %4.1f %% 
Create graph
Optimize graph
Generate and install code
%33s %8.3f ms           %9zu bytes
Total
%33s     (%.1f times slower than full code gen)
%33s %8.3f ms           %7.3f kB allocated
Average per kB source
../deps/v8/src/ast.h
!is_default()
_ClassOf
begin_%s
%s "%s"
%s %d000
end_%s
%s "B%d"
%s %d
H_Mark unreachable blocks
H_Dead code elimination
H_Escape analysis
H_Load elimination
H_Infer representations
H_Merge removable simulates
H_Mark deoptimize on undefined
H_Representation changes
H_Inferring types
H_Compute safe UInt32 operations
H_Canonicalize
H_Check Elimination
H_Store elimination
H_Range analysis
H_Compute change undefined to nan
H_Stack check elimination
H_Bounds checks elimination
H_Bounds checks hoisting
H_Dehoist index computations
Tracking global var [
(mapped to index 
Tracking inobject field access 
 (mapped to index 
H_Global value numbering
Using optimistic loop invariant code motion: %s
Try loop invariant motion for 
 changes 
Loop invariant code motion for 
 depends on 
Checking instruction i
) changes 
, depends on 
. Loop changes 
Hoisting loop invariant instruction i%d to block B%d
Analyzing block B%d%s
 (loop header)
Side-effect #%d in %d (%s) is dominated by %d (%s)
Instruction i
Replacing instruction i%d (%s) with i%d (%s)
Backtracking from block B%d to block b%d
 process L%d field %d (o%d)
  replace L%d -> v%d
 process S%d field %d (o%d) = v%d
  remove S%d
 kill-all i%d
 kill-maps i%d
 kill-elements-kind i%d
 kill-elements i%d
 kill-osr i%d
  skipping non existing property initialization store
 copy-to B%d
  field %d: 
[o%d =
 v%d
 merge-to B%d
Analyzing block B%d
Control flow range infer %d %s %d
Initial inferred range of %d (%s) set to [%d,%d]
Updated range of %d set to [%d,%d]
Original range was [%d,%d]
New information was [%d,%d]
[preparing state %p for B%d]
[%s with state %p in B%d: #%d %s]
processing
collecting
[copy state %p from B%d to new state %p for B%d]
[merge state %p from B%d into %p for B%d]
#%d Phi is not truncating Int32 because of #%d %s
#%d Phi is not truncating Smi because of #%d %s
++ Unobserved store S%d overwritten by S%d
-- Might remove store S%d
-- Observed store S%d by load L%d
-- Observed stores at I%d (%s might deoptimize)
-- Observed stores at I%d (%s might GC)
-- Observed stores at I%d (GVN flags of %s)
Tagged
TaggedPrimitive
TaggedNumber
HeapObject
HeapPrimitive
JSReceiver
(args(
METHOD
FUNCTION
_CreateAllocationMementos
_Strong
UNINITIALIZED
NUMBER
INTERNALIZED_STRING
STRING
UNIQUE_NAME
KNOWN_OBJECT
GENERIC
.COW
.IGNORE_OOB
.GROW
[%s%s in 
Keyed
 (%c->%c%s) 
LoadIC
[%s patching generic stub in 
(see below) (%s)]
name as array index
incompatible receiver type
KeyedLoadIC
same map added twice
max polymorph exceeded
set generic
StoreIC
LookupForWrite said 'false'
transition from slow
accessor on slow map
setter == 0
special data property in prototype chain
setter not a function
constant property
KeyedStoreIC
non-NORMAL target type
store mode mismatch
unsupported combination of external and normal arrays
unhandled internalized string key
map in array prototype
arguments receiver
dictionary prototype
non-smi-like key
non-JSObject receiver
slow stub
CallIC
[BinaryOpIC
 => 
 using allocation site 
../deps/v8/src/ic/ic.cc
stub.FindCodeInCache(&code)
[CompareIC in 
 ((%s+%s=%s)->(%s+%s=%s))#%s @ %p]
CompileLoadInitialize
CompileStoreInitialize
CompileStorePreMonomorphic
CompileStoreGeneric
CompileStoreMegamorphic
Load Descriptor
Store Descriptor
StoreTransition Descriptor
ElementTransitionAndStore Descriptor
VectorStoreICTrampoline Descriptor
VectorStoreIC Descriptor
Instanceof Descriptor
LoadWithVector Descriptor
FastNewClosure Descriptor
FastNewContext Descriptor
ToNumber Descriptor
NumberToString Descriptor
Typeof Descriptor
FastCloneShallowArray Descriptor
FastCloneShallowObject Descriptor
CreateAllocationSite Descriptor
CreateWeakCell Descriptor
CallFunction Descriptor
CallFunctionWithFeedback Descriptor
CallFunctionWithFeedbackAndVector Descriptor
CallConstruct Descriptor
RegExpConstructResult Descriptor
TransitionElementsKind Descriptor
AllocateHeapNumber Descriptor
ArrayConstructorConstantArgCount Descriptor
ArrayConstructor Descriptor
InternalArrayConstructorConstantArgCount Descriptor
InternalArrayConstructor Descriptor
Compare Descriptor
CompareNil Descriptor
ToBoolean Descriptor
BinaryOp Descriptor
BinaryOpWithAllocationSite Descriptor
StringAdd Descriptor
Keyed Descriptor
Named Descriptor
CallHandler Descriptor
ArgumentAdaptor Descriptor
ApiFunction Descriptor
ApiAccessor Descriptor
ApiGetter Descriptor
ArgumentsAccessRead Descriptor
StoreArrayLiteralElement Descriptor
MathPowTagged Descriptor
MathPowInteger Descriptor
ContextOnly Descriptor
GrowArrayElements Descriptor
MathRoundVariant Descriptor
../deps/v8/src/isolate.cc
thread_data_table_ == NULL
Attempt to print stack while printing stack (double fault)
If you are lucky you may find a partial stack dump on stdout.
Stacktrace (%x-%x) %p %p: %s
==== JS stack trace =========================================
==== Details ================================================
=====================
Uncaught RangeError: Maximum call stack size exceeded
Exception thrown during bootstrapping
Extension or internal compilation error: %s in %s at line %d.
Extension or internal compilation error in %s at line %d.
Extension or internal compilation error: %s.
Extension or internal compilation error.
FROM
code != nullptr
thread_data_table_
=== Stress deopt counter: %u
heap setup
heap object creation
Concurrent recompilation has been disabled for tracing.
SetupSymbolRegistry
keyFor
turbo-
.cfg
%d detached contexts are collected out of %d
detached context 0x%p
 survived %d GCs (leak?)
hydrogen-%d-%d.cfg
code-%d-%d.asm
Stack overflow
RegExp too big
L_Register constraints
L_Resolve phis
L_Connect ranges
L_Resolve control flow
L_Build live ranges
L_Populate pointer maps
L_Allocate general registers
L_Allocate double registers
../deps/v8/src/lithium-allocator.cc
start.Value() < end.Value()
;;; <@%d,#%d> -------------------- B%d (unreachable/replaced) --------------------
;;; <@%d,#%d> %s
(=%dS)
(=invalid_reg#%d)
(=%s)
(=invalid_double_reg#%d)
(WR)
[constant:%d]
[stack:%d]
[double_stack:%d]
(=invalid_reg#%d|R)
[%s|R]
(=invalid_double_reg#%d|R)
[id=%d|
deopt_id=%d|
parameters=%d|
arguments_stack_height=%d|
[hole]
L_Mark empty blocks
optimized
../deps/v8/src/lithium.cc
!value->IsPushArguments()
../deps/v8/src/liveedit.cc
raw_result->IsCode()
startPosition
endPosition
scriptObject
script_handle->IsScript() || script_handle->IsUndefined()
Function is blocked under native code
Function is blocked under a generator activation
shared->IsSharedFunctionInfo()
length->IsSmi()
element->IsSmi()
RelocInfoBuffer::GrowBuffer
Debugger mark-up on stack is not found
Stack manipulations are not supported in this architecture.
Unknown structure of stack above changing function
Not enough space for frame dropper frame (even with padding frame)
Not enough space for frame dropper frame
Failed to found requested frame
v8-version,%d,%d,%d,%d,%d
symbol(
hash %x)
:%i:
\u%04x
\x%02x
symbol(hash 
../deps/v8/src/log.cc
(size)!=(-1)
(perf_output_handle_) != nullptr
%llx %x %.*s
v8:Profiler
profiler
profiler,"begin",%d
%s,"%s"
%s,%d
%s,%ld
%s,0x%lx
api,check-security
shared-library,"%s",0x%08lx,0x%08lx
code-deopt,%ld,%d
current-time,%ld
timer-event-start,"%s",%ld
timer-event-end,"%s",%ld
regexp-compile,
,hit
,miss
api,%s,"%s","%s"
api,%s,"%s",symbol(hash %x)
api,%s,"%s",symbol("%s" hash %x)
api,%s,"%s",%u
api,%s,"%s"
api,%s
new,%s,0x%lx,%u
delete,%s,0x%lx
%s,%s,-2,
,1,"%s%s"
,1,symbol(hash %x)
,1,symbol("%s" hash %x)
"%s"
"%s 
:%d:%d",
"args_count: %d"
"%s",
%s,%d,
%s,%s,
%d,%d,
%.0f
suspect-read,
heap-sample-begin,"%s","%s",%.0f
heap-sample-end,"%s","%s"
heap-sample-item,%s,%d,%d
debug-tag,%s
debug-queue-event,%s,%15.3f,%s
,%ld
,overflow
Unknown code from the snapshot
A stub from the snapshot
Regular expression code
An IC handler from the snapshot
A keyed load IC from the snapshot
A load IC from the snapshot
A call IC from the snapshot
A store IC from the snapshot
A keyed store IC from the snapshot
Logger::LogCodeObjects
Logger::LogCompiledFunctions
Logger::LogAccessorCallbacks
V8.RecompileSynchronous
V8.RecompileConcurrent
V8.CompileFullCode
V8.Execute
V8.IcMiss
hash 
no source
code-creation
code-disable-optimization
code-move
code-delete
code-moving-gc
sfi-move
snapshot-pos
snapshot-code-name
tick
repeat
Builtin
CallDebugBreak
CallDebugPrepareStepIn
CallInitialize
CallMegamorphic
CallMiss
CallNormal
CallPreMonomorphic
LoadInitialize
LoadPreMonomorphic
LoadMegamorphic
StoreInitialize
StorePreMonomorphic
StoreGeneric
StoreMegamorphic
KeyedCallDebugBreak
KeyedCallDebugPrepareStepIn
KeyedCallInitialize
KeyedCallMegamorphic
KeyedCallMiss
KeyedCallNormal
KeyedCallPreMonomorphic
Callback
Eval
Handler
KeyedLoadPolymorphicIC
KeyedExternalArrayLoadIC
KeyedStorePolymorphicIC
KeyedExternalArrayStoreIC
LazyCompile
LoadPolymorphicIC
StorePolymorphicIC
Stub
%s,%s,%d,
,%d,
isolate-
DeletingProperty
%s:%i: %s
$noSideEffectToString
<error>
Cyclic __proto__ value
Error loading debugger
Internal % error. Default options are missing.
Uncaught %
Not supported
Internal error, wrong service type: %
Internal error. Wrong value type.
Function.prototype.apply was called on %, which is a % and not a function
Cannot modify frozen array elements
Cannot add/remove sealed array elements
Subclassing Arrays is not currently supported.
% is not a function
% called on non-object
% called on null or undefined
Cannot convert object to primitive value
Cannot prevent extension of an object with external array elements
Converting circular structure to JSON
Assignment to constant variable.
Class constructors cannot be invoked without 'new'
Constructor % requires 'new'
Currency code is required with currency style.
First argument to DataView constructor must be an ArrayBuffer
this is not a Date object.
Cannot define property:%, object is not extensible.
Object template has duplicate property '%'
Class extends value % may not be a generator function
Class extends value % is not a function or null
First argument to % must not be a regular expression
RegExp.prototype.flags getter called on non-object %
Bind must be called on a function
Generator is already running
Illegal invocation
Method % called on incompatible receiver %
Expecting a function in instanceof check, but got %
Function has non-object prototype '%' in instanceof check
invalid_argument
Cannot use 'in' operator to search for '%' in %
Iterator result % is not an object
Iterator value % is not an entry object
Language ID should be string or object.
Method % called on a non-object or on a wrong type of object.
Method invoked on undefined or null value.
Method invoked on an object that is not %.
no access
Cannot match against 'undefined' or 'null'.
% is not extensible
Cannot read property '%' of %
Cannot set property '%' of %
Cannot set property % of % which has only a getter
% is not an iterator
% is not a promise
% is not a constructor
% is not an i18n object.
% is not generic
% is not iterable
this is not a typed array.
% is not a shared typed array.
% is not an integer shared typed array.
Object.prototype.__defineGetter__: Expecting function
Getter must be a function: %
Can't add property %, object is not extensible
Object.prototype.__defineSetter__: Expecting function
Setter must be a function: %
Object.observe cannot deliver to a frozen function object
% cannot be called on the global proxy object
% cannot be called on access-checked objects
Third argument to Object.observe must be an array of strings.
Object.% cannot deliver to non-function
Object.% cannot % non-object
notify called on non-notifier object
Cannot perform non-function
Invalid non-string changeType
Invalid changeRecord with non-string 'type' property
Function object that's not a constructor was created with new
Chaining cycle detected for promise %
Property description must be an object: %
Property '%' of object % is not a function
Object prototype may only be an Object or null: %
Class extends value does not have valid prototype property %
Proxy handler % did not return a boolean value from 'delete' trap
Proxy.% called with non-object as handler
Proxy handler % returned % from '%' trap
Proxy handler % has no '%' trap
Proxy handler %0 has non-callable '%' trap
Trap '%' returned non-object %
Proxy.create called with no-object as prototype
Proxy handler % returned non-configurable descriptor for property '%' from '%' trap
Trap '%' returned repeated property name '%'
Proxy.createFunction called with non-function for '%' trap
Cannot redefine property: %
Cannot redefine a property of an object with external array elements
Reduce of empty array with no initial value
Cannot supply flags when constructing one RegExp from another
Trying to re-initialize % object.
resolvedOptions method called on a non-object or on a object that is not Intl.%.
Promise resolver % is not a function
'caller' and 'arguments' are restricted function properties and cannot be accessed in this context.
Classes may not have static property named prototype
Cannot assign to read only '% in strict mode
Cannot delete property '%' of %
'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
Cannot assign to read only property '%' of %
In strong mode, calling a function with too few arguments is deprecated
Deleting property '%' of strong object '%' is deprecated
In strong mode, implicit conversions are deprecated
On strong object %, redefining writable, non-configurable property '%' to be non-writable is deprecated
On strong object %, redefining the internal prototype is deprecated
% is not a symbol
Cannot convert a Symbol wrapper object to a primitive value
Cannot convert a Symbol value to a number
Cannot convert a Symbol value to a string
Cannot convert undefined or null to object
Invalid property.  A property cannot both have accessors and be writable or have a value, %
Identifier '%' has already been declared
% has no properties
%: Arguments list has wrong type
'super' is referenced from non-method
% is not defined
In strong mode, invoking the super constructor in a subclass is required
In strong mode, using an undeclared global variable '%' is not allowed
Unsupported reference to 'super'
Provided date is not in valid range.
Expected Area/Location for time zone, got %
Invalid array buffer length
Invalid array length
Invalid code point %
Invalid count value
Invalid currency code: %
Offset is outside the bounds of the DataView
Invalid data view length
Start offset is outside the bounds of the buffer
Invalid language tag: %
Invalid value used as weak map key
Invalid value used in weak set
Invalid string length
Invalid time value
% of % should be a multiple of %
Invalid typed array length
Start offset is too large:
Illegal value for localeMatcher:%
The normalization form should be one of %.
% argument must be between 0 and 20
% value is out of range.
Maximum call stack size exceeded
toPrecision() argument must be between 1 and 21
toString() radix argument must be between 2 and 36
Start offset is negative
Source is too large
Unsupported time zone specified %
Value % out of range for % options property %
Getter must not have any formal parameters.
Setter must have exactly one formal parameter.
Class constructor may not be an accessor
Class constructor may not be a generator
Derived constructors may only return object or undefined
Arrow function may not have duplicate parameter names
A class may only have one constructor
Duplicate export of '%'
Duplicate __proto__ fields are not allowed in object literals
for-in loop variable declaration may not have an initializer.
Invalid left-hand side in % loop: Must have a single binding.
for-of loop variable declaration may not have an initializer.
Illegal access
Illegal break statement
Illegal continue statement
Illegal return statement
Invalid left-hand side in for-loop
Invalid left-hand side expression in postfix operation
Invalid left-hand side expression in prefix operation
Invalid flags supplied to RegExp constructor '%'
Label '%' has already been declared
Malformed arrow function parameter list
Invalid regular expression: /%/: %
Invalid regular expression flags
Expected () to start arrow function, but got '%' instead of '=>'
Export '%' is not defined in module
More than one default clause in switch statement
Illegal newline after throw
Missing catch or finally after try
builtin %%IS_VAR: not a variable
Rest parameter must be last formal parameter
Setter function argument must not be a rest parameter
Function arg string contains parenthesis
Single function literal required
Block-scoped declarations (let, const, function, class) not yet supported outside strict mode
Delete of an unqualified identifier in strict mode.
Unexpected eval or arguments in strict mode
In strict mode code, functions can only be declared at top level or immediately within another function.
Octal literals are not allowed in strict mode.
Strict mode function may not have duplicate parameter names
Strict mode code may not include a with statement
In strong mode, 'arguments' is deprecated, use '...args' instead
In strong mode, returning from a constructor before its super constructor invocation or all assignments to 'this' is deprecated
In strong mode, returning a value from a constructor is deprecated
In strong mode, 'super' can only be used to invoke the super constructor, and cannot be nested inside another statement or expression
In strong mode, 'this' can only be used to initialize properties, and cannot be nested inside another statement or expression
In strong mode, 'delete' is deprecated, use maps or sets instead
In strong mode, direct calls to eval are deprecated
In strong mode, arrays with holes are deprecated, use maps instead
In strong mode, empty sub-statements are deprecated, make them explicit with '{}' instead
In strong mode, '==' and '!=' are deprecated, use '===' and '!==' instead
In strong mode, 'for'-'in' loops are deprecated, use 'for'-'of' instead
In strong mode, accessing missing property '%' of % is deprecated
In strong mode, invoking the super constructor multiple times is deprecated
In strong mode, the super constructor must be invoked before any assignment to 'this'
In strong mode, switch fall-through is deprecated, terminate each case with 'break', 'continue', 'return' or 'throw'
In strong mode, binding or assigning to 'undefined' is deprecated
In strong mode, declaring variable '%' before its use is required
In strong mode, 'var' is deprecated, use 'let' or 'const' instead
Octal literals are not allowed in template strings.
'this' is not a valid formal parameter name
Too many arguments in function call (only 65535 allowed)
Too many parameters in function definition (only 65535 allowed)
Too many variables declared (only 4194303 allowed)
Unexpected end of input
Unexpected reserved word
Unexpected strict mode reserved word
'super' keyword unexpected here
new.target expression is not allowed here
Unexpected template string
Unexpected token %
Unexpected identifier
Unexpected number
Unexpected string
Undefined label '%'
missing ) after argument list
Invalid regular expression: missing /
Unterminated template literal
Missing } in template expression
URI malformed
invalid table size
<Very long string[%u]>
<Invalid String>
<String[%u]: 
<String[%u]\: 
<JS Array[%u]>
<JS WeakMap>
<JS WeakSet>
<JS RegExp>
<JS Function 
<JS Function
 (SharedFunctionInfo %p)
<JS Generator>
<JS Module>
!!!INVALID CONSTRUCTOR!!!
!!!INVALID SHARED ON CONSTRUCTOR!!!
<%sa%s 
Global Object: 
 with %smap %p
deprecated 
<JS %sObject
Global 
 value = 
elements transition [
] in 
[reconfiguring 
{symbol 
kData
ACCESSORS
, attrs: 
[generalizing 
 maps
[migrating 
:%s->%s 
{symbol %p}
!!!INVALID POINTER!!!
!!!INVALID MAP!!!
<Map(
<FixedArray[
<FixedDoubleArray[
<ByteArray[
<FreeSpace[
<ExternalUint8Array[
<FixedUint8Array[
<ExternalInt8Array[
<FixedInt8Array[
<ExternalUint16Array[
<FixedUint16Array[
<ExternalInt16Array[
<FixedInt16Array[
<ExternalUint32Array[
<FixedUint32Array[
<ExternalInt32Array[
<FixedInt32Array[
<ExternalFloat32Array[
<FixedFloat32Array[
<ExternalFloat64Array[
<FixedFloat64Array[
<ExternalUint8ClampedArray[
<FixedUint8ClampedArray[
<SharedFunctionInfo 
<SharedFunctionInfo>
<JSMessageObject>
<Box>
<ExecutableAccessorInfo>
<AccessorPair>
<AccessCheckInfo>
<InterceptorInfo>
<CallHandlerInfo>
<FunctionTemplateInfo>
<ObjectTemplateInfo>
<TypeSwitchInfo>
<Script>
<AllocationSite>
<AllocationMemento>
<CodeCache>
<PolymorphicCodeCache>
<TypeFeedbackInfo>
<AliasedArgumentsEntry>
<DebugInfo>
<BreakPointInfo>
<PrototypeInfo>
<Code: 
<undefined>
<the hole>
<null>
<true>
<false>
<Odd Oddball>
<Number: 
<MutableNumber: 
<Float32x4: 
<JSProxy>
<JSFunctionProxy>
<Foreign>
Cell for 
PropertyCell for 
WeakCell for 
<Other heap object (
Unknown type: %d
../deps/v8/src/objects.cc
new_map->is_dictionary_map()
field type generalization
uninitialized field
GenAll_NotEquivalent
GenAll_InvalidElementsTransition
GenAll_RootModification1
GenAll_RootModification2
GenAll_Incompatible
GenAll_CantHaveMoreTransitions
interceptor-indexed-set
interceptor-named-set
typed elements write
elements write
getPropertyDescriptor
configurable_
hasWritable_
writable_
set_
delete
enumerable_
reconfigure
interceptor-indexed-has
interceptor-named-has
interceptor-indexed-get-has
interceptor-named-get-has
object->map() != isolate->heap()->sloppy_arguments_elements_map()
interceptor-indexed-delete
interceptor-named-delete
preventExtensions
GetPropertyAttributes(&it).IsJust()
maybe_name.ToHandle(&name)
GenAll_AttributesMismatchProtoMap
[WeakFixedArray: storing at index %d ]
[WeakFixedArray: searching for free slot]
[WeakFixedArray: growing to size %d ]
  ** Marking 
 for concurrent recompilation.
[evicting entry from optimizing code map (%s) for 
 (osr ast id %d)]
 (context-independent code)]
Registering %p as a user of prototype %p (map=%p).
Unregistering %p as a user of prototype %p.
nameOrSourceURL
<No Source>
<Invalid Source>
[disabled optimization for 
, reason: %s]
[didn't find optimized code in optimized code map for 
string_table
external_strings_table
strong_root_list
smi_root_list
bootstrapper
relocatable
compilationcache
handlescope
globalhandles
eternalhandles
threadmanager
strong roots
Extensions
(Internalized strings)
(External strings)
(Strong roots)
(Smi roots)
(Internal string)
(Bootstrapper)
(Isolate)
(Relocatable)
(Debugger)
(Compilation cache)
(Handle scope)
(Builtins)
(Global handles)
(Eternal handles)
(Thread manager)
(Extensions)
(target)==(old_target)
            ;;; deoptimize at %d_%d: %s
            ;;; deoptimize at %d: %s
OPTIMIZED_FUNCTION
STUB
HANDLER
BUILTIN
REGEXP
LOAD_IC
KEYED_LOAD_IC
CALL_IC
STORE_IC
KEYED_STORE_IC
BINARY_OP_IC
COMPARE_IC
COMPARE_NIL_IC
TO_BOOLEAN_IC
Inlined functions (count = 
Deoptimization Input Data (deopt points = 
 index  ast id    argc     pc
  commands
 {frame count=
, js frame count=
{ast_id=
, function=
, height=
{function}
{kind=
{function=
{input=
 (unsigned)}
 (bool)}
{literal_id=
{object_index=
{length=
Deoptimization Output Data (deopt points = 
ast id        pc  state
   from   to       hdlr
)  ->  
 (prediction=
, depth=
   off      hdlr (c)
  ->  
PREMONOMORPHIC
MONOMORPHIC
PROTOTYPE_FAILURE
POLYMORPHIC
MEGAMORPHIC
DEBUG_STUB
NORMAL
FAST
extra_ic_state = 
STRICT
kind = 
major_key = 
ic_state = 
type = 
compare_state = 
compare_operation = 
name = 
stack_slots = 
compiler = 
turbofan
full-codegen
Instructions (size = 
Safepoints (size = 
 (sp -> fp)  
<none>
 argc: 
Back edges (size = 
ast_id  pc_offset  loop_depth
Handler Table (size = 
RelocInfo (size = 
old_length_handle->ToArrayLength(&old_length)
array->length()->ToArrayLength(&new_length)
[marking dependent code 0x%08lx (opt #%d) for deoptimization, reason: %s]
weak-code
prototype-check
property-cell-changed
field-type
initial-map-changed
allocation-site-tenuring-changed
allocation-site-transition-changed
JSArray::cast(*object)->length()->ToArrayLength(&old_length)
transition_info->length()->ToArrayLength(&length)
AllocationSite: JSArray %p boilerplate %s updated %s->%s
(nested)
AllocationSite: JSArray %p site updated %s->%s
undecided
don't tenure
maybe tenure
tenure
zombie
it.IsFound()
array->length()->ToArrayLength(&length)
interceptor-indexed-get
interceptor-named-get
interceptor-named-enum
interceptor-indexed-enum
<Symbol: 
!string.is_null()
is_neuterable()
is_external()
Moving prototype_info %p from map %p to map %p.
(0)<=(max_slack)
Invalidating prototype map %p 's cell
JSReceiver::GetPropertyAttributes(&it).IsJust()
(length)==(properties)
  ** Flushed concurrent recompilation queues.
[COSR hit rate %d / %d]
[COSR - 
 is ready for install and entry at AST id %d]
  ** Aborting compilation for 
 as it has already been optimized.
[COSR - Discarded 
, AST id %d]
initializeConstGlobal
initializeVarGlobal
$concatIterableToArray
[parsing eval
[parsing script: %s
[parsing script
 - took %0.3f ms]
[parsing function: %s - took %0.3f ms]
from
for-of
for-in
../deps/v8/src/parser.cc
log_
Regular expression too large
Unterminated group
Unmatched ')'
Nothing to repeat
Invalid group
Too many captures
\ at end of pattern
Invalid escape
Invalid unicode escape
numbers out of order in {} quantifier.
Unterminated character class
Range out of order in character class
new.target
.this_function
(anonymous function)
use strict
use strong
use asm
_IsSpecObject
ThrowIteratorResultNotAnObject
.iterator
.for
.generator_object
_IsConstructCall
$getTemplateCallSite
$spreadIterable
$spreadArguments
../deps/v8/src/preparser.h
peek() == Token::TEMPLATE_SPAN || peek() == Token::TEMPLATE_TAIL
ILLEGAL
target
(intermediate value)
(...)
(%s%s
 %s 
(...
%5u %*s %s%s %d #%d
 %s:%d
%*s;;; deopted at script_id: %d position: %d with reason '%s'.
%*s;;;     Inline point: script_id %d position: %d.
%*s bailed out due to '%s'
[Top down]:
%p %5d %s
(program)
(idle)
(garbage collector)
(unresolved function)
immutable 
accessor
, dictionary_index: 
, field_index: 
, p: 
Descriptor 
(get: 
, set: 
IA32
ARM64
MIPS
Bytecode
RegExpMacroAssembler%s();
 AbortedCodeGeneration
label[%08x]: (Bind)
 AdvanceCurrentPosition(by=%d);
 CheckGreedyLoop(label[%08x]);
 PopCurrentPosition();
 PushCurrentPosition();
 Backtrack();
 GoTo(label[%08x]);
 PushBacktrack(label[%08x]);
 Succeed();%s
 [restart for global match]
 Fail();
 PopRegister(register=%d);
 PushRegister(register=%d, %s);
check stack limit
 AdvanceRegister(register=%d, by=%d);
 SetCurrentPositionFromEnd(by=%d);
 SetRegister(register=%d, to=%d);
 WriteCurrentPositionToRegister(register=%d,cp_offset=%d);
 ClearRegister(from=%d, to=%d);
 ReadCurrentPositionFromRegister(register=%d);
 WriteStackPointerToRegister(register=%d);
 ReadStackPointerFromRegister(register=%d);
 (unchecked)
 LoadCurrentCharacter(cp_offset=%d, label[%08x]%s (%d chars));
 CheckCharacterLT(c=0x%04x%s, label[%08x]);
 CheckCharacterGT(c=0x%04x%s, label[%08x]);
 CheckCharacter(c=0x%04x%s, label[%08x]);
 CheckAtStart(label[%08x]);
 CheckNotAtStart(label[%08x]);
 CheckNotCharacter(c=0x%04x%s, label[%08x]);
 CheckCharacterAfterAnd(c=0x%04x%s, mask=0x%04x, label[%08x]);
 CheckNotCharacterAfterAnd(c=0x%04x%s, mask=0x%04x, label[%08x]);
 CheckNotCharacterAfterMinusAnd(c=0x%04x, minus=%04x, mask=0x%04x, label[%08x]);
 CheckCharacterInRange(from=0x%04x%s, to=0x%04x%s, label[%08x]);
 CheckCharacterNotInRange(from=0x%04x%s, to=%04x%s, label[%08x]);
 CheckBitInTable(label[%08x] 
                                 
 CheckNotBackReference(register=%d, label[%08x]);
 CheckNotBackReferenceIgnoreCase(register=%d, label[%08x]);
 CheckSpecialCharacterClass(type='%c', label[%08x]): %s;
 IfRegisterLT(register=%d, number=%d, label[%08x]);
 IfRegisterEqPos(register=%d, label[%08x]);
 IfRegisterGE(register=%d, number=%d, label[%08x]);
 GetCode(%s);
[marking 
 for recompilation, reason: %s
, ICs with typeinfo: %d/%d (%d%%)
, generic ICs: %d/%d (%d%%)
[OSR - patching back edges in 
hot and stable
not much type info but very hot
[not yet optimizing 
, not enough type info: %d/%d (%d%%)]
small function
unshift
slice
splice
concat
../deps/v8/src/runtime/runtime-array.cc
args_length >= 2
pre_last_arg_index >= 0
last_arg_index >= 0
[removing optimized code for: 
notify deoptimized
[OSR - Still waiting for queued: 
 at AST id %d]
[OSR - Found ready: 
[OSR - Compiling: 
[OSR - Entry at AST id %d, offset %d in optimized code]
[OSR - Failed: 
[[TargetFunction]]
[[BoundThis]]
[[BoundArgs]]
suspended
closed
running
[[GeneratorStatus]]
[[GeneratorFunction]]
[[GeneratorReceiver]]
rejected
resolved
pending
[[PromiseStatus]]
[[PromiseValue]]
[[PrimitiveValue]]
../deps/v8/src/runtime/runtime-debug.cc
context_->IsNativeContext()
ObjectWithNullProto
%DebugConstructedBy
isolate->debug()->live_edit_enabled()
%CollectGarbage
keys
values
entries
[[IteratorHasMore]]
[[IteratorIndex]]
[[IteratorKind]]
$jsonSerializeAdapter
../deps/v8/src/json-stringifier.h
object->length()->ToArrayLength(&length)
Boilerplate
FastLiteral
../deps/v8/src/runtime/runtime-liveedit.cc
0123456789abcdefghijklmnopqrstuvwxyz
location_ != NULL
setPrototype
OptimizeForAdding
../deps/v8/src/runtime/runtime-object.cc
key->ToArrayIndex(&index)
array->length()->ToArrayIndex(&index)
RuntimeToFastProperties
original_constructor->IsJSFunction()
../deps/v8/src/runtime/runtime-scopes.cc
holder->IsJSObject()
!IsSubclassConstructor(callee->shared()->kind())
concurrent
no sync
abort: %s
%4d:%*s
} -> 
../deps/v8/src/runtime/runtime-typedarray.cc
byte_length->IsSmi() || byte_length->IsHeapNumber()
isolate->array_buffer_allocator() != NULL
Smi::FromInt(0) == array_buffer->byte_length()
../deps/v8/src/runtime/runtime.cc
new_dict.is_identical_to(dict)
LoadLookupSlot
LoadLookupSlotNoReferenceError
FinishArrayPrototypeSetup
SpecialArrayFunctions
PushIfAbsent
RemoveArrayHoles
MoveArrayContents
EstimateNumberOfElements
GetArrayKeys
ArrayConstructor
ArrayConstructorWithSubclassing
InternalArrayConstructor
NormalizeElements
GrowArrayElements
HasComplexElements
IsArray
HasCachedArrayIndex
FixedArrayGet
FixedArraySet
FastOneByteArrayJoin
AtomicsCompareExchange
AtomicsLoad
AtomicsStore
AtomicsAdd
AtomicsSub
AtomicsAnd
AtomicsOr
AtomicsXor
AtomicsExchange
AtomicsIsLockFree
ThrowNonMethodError
ThrowUnsupportedSuperError
ThrowConstructorNonCallableError
ThrowArrayNotSubclassableError
ThrowStaticPrototypeError
ThrowIfStaticPrototype
ToMethod
HomeObjectSymbol
DefineClass
DefineClassMethod
ClassGetSourceCode
LoadFromSuper
LoadKeyedFromSuper
StoreToSuper_Strict
StoreToSuper_Sloppy
StoreKeyedToSuper_Strict
StoreKeyedToSuper_Sloppy
HandleStepInForDerivedConstructors
DefaultConstructorCallSuper
CallSuperWithSpread
StringGetRawHashField
TheHole
JSCollectionGetTable
GenericHash
SetInitialize
SetGrow
SetShrink
SetClear
SetIteratorInitialize
SetIteratorClone
SetIteratorNext
SetIteratorDetails
MapInitialize
MapShrink
MapClear
MapGrow
MapIteratorInitialize
MapIteratorClone
MapIteratorDetails
GetWeakMapEntries
MapIteratorNext
WeakCollectionInitialize
WeakCollectionGet
WeakCollectionHas
WeakCollectionDelete
WeakCollectionSet
GetWeakSetValues
ObservationWeakMapCreate
CompileForOnStackReplacement
TryInstallOptimizedCode
CompileString
ResolvePossiblyDirectEval
DateMakeDay
DateSetValue
IsDate
ThrowNotDateError
DateCurrentTime
DateParseString
DateLocalTimezone
DateToUTC
DateCacheVersion
SetDebugEventListener
ScheduleBreak
DebugGetInternalProperties
DebugGetPropertyDetails
DebugGetProperty
DebugPropertyTypeFromDetails
DebugPropertyAttributesFromDetails
DebugPropertyIndexFromDetails
DebugNamedInterceptorPropertyValue
DebugIndexedInterceptorElementValue
CheckExecutionState
GetFrameCount
GetFrameDetails
GetScopeCount
GetStepInPositions
GetScopeDetails
GetAllScopesDetails
GetFunctionScopeCount
GetFunctionScopeDetails
SetScopeVariableValue
DebugPrintScopes
GetThreadCount
GetThreadDetails
SetDisableBreak
GetBreakLocations
SetFunctionBreakPoint
SetScriptBreakPoint
ClearBreakPoint
ChangeBreakOnException
IsBreakOnException
PrepareStep
ClearStepping
DebugEvaluate
DebugEvaluateGlobal
DebugGetLoadedScripts
DebugReferencedBy
DebugConstructedBy
DebugGetPrototype
DebugSetScriptSource
FunctionGetInferredName
GetFunctionCodePositionFromSource
ExecuteInDebugContext
GetDebugContext
CollectGarbage
GetHeapUsage
GetScript
DebugCallbackSupportsStepping
DebugPrepareStepInIfStepping
DebugPushPromise
DebugPopPromise
DebugPromiseEvent
DebugAsyncTaskEvent
DebugIsActive
DebugBreakInOptimizedCode
ForInDone
ForInFilter
ForInNext
ForInStep
IsSloppyModeFunction
FunctionGetName
FunctionSetName
FunctionNameShouldPrintAsAnonymous
FunctionMarkNameShouldPrintAsAnonymous
FunctionIsArrow
FunctionIsConciseMethod
FunctionRemovePrototype
FunctionGetScript
FunctionGetSourceCode
FunctionGetScriptSourcePosition
FunctionGetPositionForOffset
FunctionSetInstanceClassName
FunctionSetLength
FunctionSetPrototype
FunctionIsAPIFunction
FunctionIsBuiltin
SetCode
SetNativeFlag
ThrowStrongModeTooFewArguments
IsConstructor
SetForceInlineFlag
FunctionBindArguments
BoundFunctionGetBindings
NewObjectFromBound
Apply
GetFunctionDelegate
GetConstructorDelegate
GetOriginalConstructor
IsConstructCall
IsFunction
CreateJSGeneratorObject
SuspendJSGeneratorObject
ResumeJSGeneratorObject
GeneratorClose
GeneratorGetFunction
GeneratorGetContext
GeneratorGetReceiver
GeneratorGetContinuation
GeneratorGetSourcePosition
FunctionIsGenerator
GeneratorNext
GeneratorThrow
CheckIsBootstrapping
ReThrow
UnwindAndFindExceptionHandler
PromoteScheduledException
ThrowReferenceError
NewTypeError
NewSyntaxError
NewReferenceError
ThrowStrongModeImplicitConversion
PromiseRejectEvent
PromiseRevokeReject
PromiseHasHandlerSymbol
StackGuard
Interrupt
AllocateInNewSpace
AllocateInTargetSpace
CollectStackTrace
RenderCallSite
GetFromCacheRT
MessageGetStartPosition
MessageGetScript
FormatMessageString
CallSiteGetFileNameRT
CallSiteGetFunctionNameRT
CallSiteGetScriptNameOrSourceUrlRT
CallSiteGetMethodNameRT
CallSiteGetLineNumberRT
CallSiteGetColumnNumberRT
CallSiteIsNativeRT
CallSiteIsToplevelRT
CallSiteIsEvalRT
CallSiteIsConstructorRT
IS_VAR
GetFromCache
IncrementStatsCounter
Likely
Unlikely
HarmonyToString
GetTypeFeedbackVector
GetCallerJSFunction
QuoteJSONString
BasicJSONStringify
ParseJson
CreateObjectLiteral
CreateArrayLiteral
CreateArrayLiteralStubBailout
StoreArrayLiteralElement
LiveEditFindSharedFunctionInfosForScript
LiveEditGatherCompileInfo
LiveEditReplaceScript
LiveEditFunctionSourceUpdated
LiveEditReplaceFunctionCode
LiveEditFunctionSetScript
LiveEditReplaceRefToNestedFunction
LiveEditPatchFunctionPositions
LiveEditCheckAndDropActivations
LiveEditCompareStrings
LiveEditRestartFrame
MathAcos
MathAsin
MathAtan
MathLogRT
DoubleHi
DoubleLo
RemPiO2
MathAtan2
MathExpRT
MathClz32
MathFloor
MathPowSlow
MathPowRT
RoundNumber
MathSqrt
MathFround
MathPow
IsMinusZero
NumberToRadixString
NumberToFixed
NumberToExponential
NumberToPrecision
IsValidSmi
StringToNumber
StringParseInt
StringParseFloat
NumberToStringRT
NumberToStringSkipCache
NumberToInteger
NumberToIntegerMapMinusZero
NumberToJSUint32
NumberToJSInt32
NumberToSmi
NumberSub
NumberMul
NumberUnaryMinus
NumberDiv
NumberMod
NumberImul
NumberOr
NumberAnd
NumberXor
NumberShl
NumberShr
NumberSar
NumberEquals
NumberCompare
SmiLexicographicCompare
MaxSmi
NumberToString
IsSmi
IsNonNegativeSmi
GetRootNaN
GetPrototype
InternalSetPrototype
SetPrototype
IsInPrototypeChain
GetOwnProperty
PreventExtensions
IsExtensible
OptimizeObjectForAddingMultipleProperties
ObjectFreeze
ObjectSeal
GetProperty
GetPropertyStrong
KeyedGetProperty
KeyedGetPropertyStrong
AddNamedProperty
SetProperty
AddElement
AppendElement
DeleteProperty
HasOwnProperty
HasProperty
HasElement
IsPropertyEnumerable
GetPropertyNames
GetPropertyNamesFast
GetOwnPropertyNames
GetOwnElementNames
GetInterceptorInfo
GetNamedInterceptorPropertyNames
GetIndexedInterceptorElementNames
OwnKeys
ToBool
NewStringWrapper
AllocateHeapNumber
NewObject
NewObjectWithAllocationSite
FinalizeInstanceSize
GlobalProxy
LookupAccessor
LoadMutableDouble
TryMigrateInstance
IsJSGlobalProxy
DefineAccessorPropertyUnchecked
DefineDataPropertyUnchecked
GetDataProperty
HasFastPackedElements
ValueOf
SetValueOf
JSValueGetValue
HeapObjectGetMap
MapGetInstanceType
ObjectEquals
IsObject
IsUndetectableObject
IsSpecObject
IsStrong
ClassOf
DefineGetterPropertyUnchecked
DefineSetterPropertyUnchecked
IsAccessCheckNeeded
IsObserved
SetIsObserved
EnqueueMicrotask
RunMicrotasks
DeliverObservationChangeRecords
GetObservationState
ObserverObjectAndRecordHaveSameOrigin
ObjectWasCreatedInCurrentOrigin
GetObjectContextObjectObserve
GetObjectContextObjectGetNotifier
GetObjectContextNotifierPerformChange
CreateJSProxy
CreateJSFunctionProxy
IsJSProxy
IsJSFunctionProxy
GetHandler
GetCallTrap
GetConstructTrap
StringReplaceGlobalRegExpWithString
StringSplit
RegExpExec
RegExpConstructResultRT
RegExpConstructResult
RegExpInitializeAndCompile
MaterializeRegExpLiteral
RegExpExecMultiple
RegExpExecReThrow
IsRegExp
ThrowConstAssignError
InitializeVarGlobal
InitializeConstGlobal
DeclareLookupSlot
InitializeLegacyConstLookupSlot
NewArguments
NewSloppyArguments
NewStrictArguments
NewRestParam
NewRestParamSlow
NewClosureFromStubFailure
NewClosure
NewScriptContext
NewFunctionContext
PushWithContext
PushCatchContext
PushBlockContext
IsJSModule
PushModuleContext
DeclareModules
DeleteLookupSlot
StoreLookupSlot
GetArgumentsProperty
StringReplaceOneCharWithString
StringIndexOf
StringLastIndexOf
StringLocaleCompare
SubStringRT
SubString
StringAddRT
InternalizeString
StringMatch
StringCharCodeAtRT
CharFromCode
StringCompareRT
StringCompare
StringBuilderConcat
StringBuilderJoin
SparseJoinWithSeparator
StringToArray
StringToLowerCase
StringToUpperCase
StringTrim
TruncateString
NewString
NewConsString
StringEquals
FlattenString
StringCharAt
OneByteSeqStringGetChar
OneByteSeqStringSetChar
TwoByteSeqStringGetChar
TwoByteSeqStringSetChar
IsStringWrapperSafeForDefaultValueOf
StringGetLength
CreateSymbol
CreatePrivateSymbol
CreateGlobalPrivateSymbol
NewSymbolWrapper
SymbolDescription
SymbolRegistry
SymbolIsPrivate
DeoptimizeFunction
DeoptimizeNow
RunningInSimulator
IsConcurrentRecompilationSupported
OptimizeFunctionOnNextCall
OptimizeOsr
NeverOptimizeFunction
GetOptimizationStatus
UnblockConcurrentRecompilation
GetOptimizationCount
GetUndetectable
ClearFunctionTypeFeedback
NotifyContextDisposed
SetAllocationTimeout
DebugPrint
DebugTrace
GlobalPrint
SystemBreak
SetFlags
Abort
AbortJS
NativeScriptsCount
GetV8Version
DisassembleFunction
TraceEnter
TraceExit
HaveSameMap
HasFastSmiElements
HasFastObjectElements
HasFastSmiOrObjectElements
HasFastDoubleElements
HasFastHoleyElements
HasDictionaryElements
HasSloppyArgumentsElements
HasExternalArrayElements
HasFastProperties
HasExternalUint8Elements
HasExternalInt8Elements
HasExternalUint16Elements
HasExternalInt16Elements
HasExternalUint32Elements
HasExternalInt32Elements
HasExternalFloat32Elements
HasExternalFloat64Elements
HasExternalUint8ClampedElements
HasFixedUint8Elements
HasFixedInt8Elements
HasFixedUint16Elements
HasFixedInt16Elements
HasFixedUint32Elements
HasFixedInt32Elements
HasFixedFloat32Elements
HasFixedFloat64Elements
HasFixedUint8ClampedElements
ArrayBufferInitialize
ArrayBufferGetByteLength
ArrayBufferSliceImpl
ArrayBufferIsView
ArrayBufferNeuter
TypedArrayInitialize
TypedArrayInitializeFromArrayLike
ArrayBufferViewGetByteLength
ArrayBufferViewGetByteOffset
TypedArrayGetLength
DataViewGetBuffer
TypedArrayGetBuffer
TypedArraySetFastCases
TypedArrayMaxSizeInHeap
IsTypedArray
IsSharedTypedArray
IsSharedIntegerTypedArray
DataViewInitialize
DataViewGetUint8
DataViewGetInt8
DataViewGetUint16
DataViewGetInt16
DataViewGetUint32
DataViewGetInt32
DataViewGetFloat32
DataViewGetFloat64
DataViewSetUint8
DataViewSetInt8
DataViewSetUint16
DataViewSetInt16
DataViewSetUint32
DataViewSetInt32
DataViewSetFloat32
DataViewSetFloat64
URIEscape
URIUnescape
_LoadLookupSlot
_LoadLookupSlotNoReferenceError
_FinishArrayPrototypeSetup
_SpecialArrayFunctions
_TransitionElementsKind
_PushIfAbsent
_ArrayConcat
_RemoveArrayHoles
_MoveArrayContents
_EstimateNumberOfElements
_GetArrayKeys
_ArrayConstructor
_ArrayConstructorWithSubclassing
_InternalArrayConstructor
_NormalizeElements
_GrowArrayElements
_HasComplexElements
_IsArray
_HasCachedArrayIndex
_GetCachedArrayIndex
_FixedArrayGet
_FixedArraySet
_FastOneByteArrayJoin
_AtomicsCompareExchange
_AtomicsLoad
_AtomicsStore
_AtomicsAdd
_AtomicsSub
_AtomicsAnd
_AtomicsOr
_AtomicsXor
_AtomicsExchange
_AtomicsIsLockFree
_ThrowNonMethodError
_ThrowUnsupportedSuperError
_ThrowConstructorNonCallableError
_ThrowArrayNotSubclassableError
_ThrowStaticPrototypeError
_ThrowIfStaticPrototype
_ToMethod
_HomeObjectSymbol
_DefineClass
_DefineClassMethod
_ClassGetSourceCode
_LoadFromSuper
_LoadKeyedFromSuper
_StoreToSuper_Strict
_StoreToSuper_Sloppy
_StoreKeyedToSuper_Strict
_StoreKeyedToSuper_Sloppy
_HandleStepInForDerivedConstructors
_DefaultConstructorCallSuper
_CallSuperWithSpread
_StringGetRawHashField
_TheHole
_JSCollectionGetTable
_GenericHash
_SetInitialize
_SetGrow
_SetShrink
_SetClear
_SetIteratorInitialize
_SetIteratorClone
_SetIteratorNext
_SetIteratorDetails
_MapInitialize
_MapShrink
_MapClear
_MapGrow
_MapIteratorInitialize
_MapIteratorClone
_MapIteratorDetails
_GetWeakMapEntries
_MapIteratorNext
_WeakCollectionInitialize
_WeakCollectionGet
_WeakCollectionHas
_WeakCollectionDelete
_WeakCollectionSet
_GetWeakSetValues
_ObservationWeakMapCreate
_CompileLazy
_CompileOptimized
_NotifyStubFailure
_NotifyDeoptimized
_CompileForOnStackReplacement
_TryInstallOptimizedCode
_CompileString
_ResolvePossiblyDirectEval
_DateMakeDay
_DateSetValue
_IsDate
_ThrowNotDateError
_DateCurrentTime
_DateParseString
_DateLocalTimezone
_DateToUTC
_DateCacheVersion
_DateField
_DebugBreak
_SetDebugEventListener
_ScheduleBreak
_DebugGetInternalProperties
_DebugGetPropertyDetails
_DebugGetProperty
_DebugPropertyTypeFromDetails
_DebugPropertyAttributesFromDetails
_DebugPropertyIndexFromDetails
_DebugNamedInterceptorPropertyValue
_DebugIndexedInterceptorElementValue
_CheckExecutionState
_GetFrameCount
_GetFrameDetails
_GetScopeCount
_GetStepInPositions
_GetScopeDetails
_GetAllScopesDetails
_GetFunctionScopeCount
_GetFunctionScopeDetails
_SetScopeVariableValue
_DebugPrintScopes
_GetThreadCount
_GetThreadDetails
_SetDisableBreak
_GetBreakLocations
_SetFunctionBreakPoint
_SetScriptBreakPoint
_ClearBreakPoint
_ChangeBreakOnException
_IsBreakOnException
_PrepareStep
_ClearStepping
_DebugEvaluate
_DebugEvaluateGlobal
_DebugGetLoadedScripts
_DebugReferencedBy
_DebugConstructedBy
_DebugGetPrototype
_DebugSetScriptSource
_FunctionGetInferredName
_GetFunctionCodePositionFromSource
_ExecuteInDebugContext
_GetDebugContext
_CollectGarbage
_GetHeapUsage
_GetScript
_DebugCallbackSupportsStepping
_DebugPrepareStepInIfStepping
_DebugPushPromise
_DebugPopPromise
_DebugPromiseEvent
_DebugAsyncTaskEvent
_DebugIsActive
_DebugBreakInOptimizedCode
_ForInDone
_ForInFilter
_ForInNext
_ForInStep
_IsSloppyModeFunction
_FunctionGetName
_FunctionSetName
_FunctionNameShouldPrintAsAnonymous
_FunctionMarkNameShouldPrintAsAnonymous
_FunctionIsArrow
_FunctionIsConciseMethod
_FunctionRemovePrototype
_FunctionGetScript
_FunctionGetSourceCode
_FunctionGetScriptSourcePosition
_FunctionGetPositionForOffset
_FunctionSetInstanceClassName
_FunctionSetLength
_FunctionSetPrototype
_FunctionIsAPIFunction
_FunctionIsBuiltin
_SetCode
_SetNativeFlag
_ThrowStrongModeTooFewArguments
_IsConstructor
_SetForceInlineFlag
_FunctionBindArguments
_BoundFunctionGetBindings
_NewObjectFromBound
_Call
_Apply
_GetFunctionDelegate
_GetConstructorDelegate
_GetOriginalConstructor
_CallFunction
_IsFunction
_CreateJSGeneratorObject
_SuspendJSGeneratorObject
_ResumeJSGeneratorObject
_GeneratorClose
_GeneratorGetFunction
_GeneratorGetContext
_GeneratorGetReceiver
_GeneratorGetContinuation
_GeneratorGetSourcePosition
_FunctionIsGenerator
_GeneratorNext
_GeneratorThrow
_CheckIsBootstrapping
_Throw
_ReThrow
_UnwindAndFindExceptionHandler
_PromoteScheduledException
_ThrowReferenceError
_NewTypeError
_NewSyntaxError
_NewReferenceError
_ThrowIteratorResultNotAnObject
_ThrowStrongModeImplicitConversion
_PromiseRejectEvent
_PromiseRevokeReject
_PromiseHasHandlerSymbol
_StackGuard
_Interrupt
_AllocateInNewSpace
_AllocateInTargetSpace
_CollectStackTrace
_RenderCallSite
_GetFromCacheRT
_MessageGetStartPosition
_MessageGetScript
_FormatMessageString
_CallSiteGetFileNameRT
_CallSiteGetFunctionNameRT
_CallSiteGetScriptNameOrSourceUrlRT
_CallSiteGetMethodNameRT
_CallSiteGetLineNumberRT
_CallSiteGetColumnNumberRT
_CallSiteIsNativeRT
_CallSiteIsToplevelRT
_CallSiteIsEvalRT
_CallSiteIsConstructorRT
_IS_VAR
_GetFromCache
_IncrementStatsCounter
_Likely
_Unlikely
_HarmonyToString
_GetTypeFeedbackVector
_GetCallerJSFunction
_QuoteJSONString
_BasicJSONStringify
_ParseJson
_CreateObjectLiteral
_CreateArrayLiteral
_CreateArrayLiteralStubBailout
_StoreArrayLiteralElement
_LiveEditFindSharedFunctionInfosForScript
_LiveEditGatherCompileInfo
_LiveEditReplaceScript
_LiveEditFunctionSourceUpdated
_LiveEditReplaceFunctionCode
_LiveEditFunctionSetScript
_LiveEditReplaceRefToNestedFunction
_LiveEditPatchFunctionPositions
_LiveEditCheckAndDropActivations
_LiveEditCompareStrings
_LiveEditRestartFrame
_MathAcos
_MathAsin
_MathAtan
_MathLogRT
_DoubleHi
_DoubleLo
_ConstructDouble
_RemPiO2
_MathAtan2
_MathExpRT
_MathClz32
_MathFloor
_MathPowSlow
_MathPowRT
_RoundNumber
_MathSqrt
_MathFround
_MathPow
_IsMinusZero
_NumberToRadixString
_NumberToFixed
_NumberToExponential
_NumberToPrecision
_IsValidSmi
_StringToNumber
_StringParseInt
_StringParseFloat
_NumberToStringRT
_NumberToStringSkipCache
_NumberToInteger
_NumberToIntegerMapMinusZero
_NumberToJSUint32
_NumberToJSInt32
_NumberToSmi
_NumberAdd
_NumberSub
_NumberMul
_NumberUnaryMinus
_NumberDiv
_NumberMod
_NumberImul
_NumberOr
_NumberAnd
_NumberXor
_NumberShl
_NumberShr
_NumberSar
_NumberEquals
_NumberCompare
_SmiLexicographicCompare
_MaxSmi
_NumberToString
_IsSmi
_IsNonNegativeSmi
_GetRootNaN
_GetPrototype
_InternalSetPrototype
_SetPrototype
_IsInPrototypeChain
_GetOwnProperty
_PreventExtensions
_IsExtensible
_OptimizeObjectForAddingMultipleProperties
_ObjectFreeze
_ObjectSeal
_GetProperty
_GetPropertyStrong
_KeyedGetProperty
_KeyedGetPropertyStrong
_AddNamedProperty
_SetProperty
_AddElement
_AppendElement
_DeleteProperty
_HasOwnProperty
_HasProperty
_HasElement
_IsPropertyEnumerable
_GetPropertyNames
_GetPropertyNamesFast
_GetOwnPropertyNames
_GetOwnElementNames
_GetInterceptorInfo
_GetNamedInterceptorPropertyNames
_GetIndexedInterceptorElementNames
_OwnKeys
_ToFastProperties
_ToBool
_NewStringWrapper
_AllocateHeapNumber
_NewObject
_NewObjectWithAllocationSite
_FinalizeInstanceSize
_GlobalProxy
_LookupAccessor
_LoadMutableDouble
_TryMigrateInstance
_IsJSGlobalProxy
_DefineAccessorPropertyUnchecked
_DefineDataPropertyUnchecked
_GetDataProperty
_HasFastPackedElements
_ValueOf
_SetValueOf
_JSValueGetValue
_HeapObjectGetMap
_MapGetInstanceType
_ObjectEquals
_IsObject
_IsUndetectableObject
_IsStrong
_DefineGetterPropertyUnchecked
_DefineSetterPropertyUnchecked
_IsAccessCheckNeeded
_IsObserved
_SetIsObserved
_EnqueueMicrotask
_RunMicrotasks
_DeliverObservationChangeRecords
_GetObservationState
_ObserverObjectAndRecordHaveSameOrigin
_ObjectWasCreatedInCurrentOrigin
_GetObjectContextObjectObserve
_GetObjectContextObjectGetNotifier
_GetObjectContextNotifierPerformChange
_CreateJSProxy
_CreateJSFunctionProxy
_IsJSProxy
_IsJSFunctionProxy
_GetHandler
_GetCallTrap
_GetConstructTrap
_Fix
_StringReplaceGlobalRegExpWithString
_StringSplit
_RegExpExec
_RegExpConstructResultRT
_RegExpConstructResult
_RegExpInitializeAndCompile
_MaterializeRegExpLiteral
_RegExpExecMultiple
_RegExpExecReThrow
_IsRegExp
_ThrowConstAssignError
_DeclareGlobals
_InitializeVarGlobal
_InitializeConstGlobal
_DeclareLookupSlot
_InitializeLegacyConstLookupSlot
_NewArguments
_NewSloppyArguments
_NewStrictArguments
_NewRestParam
_NewRestParamSlow
_NewClosureFromStubFailure
_NewClosure
_NewScriptContext
_NewFunctionContext
_PushWithContext
_PushCatchContext
_PushBlockContext
_IsJSModule
_PushModuleContext
_DeclareModules
_DeleteLookupSlot
_StoreLookupSlot
_GetArgumentsProperty
_ArgumentsLength
_Arguments
_StringReplaceOneCharWithString
_StringIndexOf
_StringLastIndexOf
_StringLocaleCompare
_SubStringRT
_SubString
_StringAddRT
_StringAdd
_InternalizeString
_StringMatch
_StringCharCodeAtRT
_CharFromCode
_StringCompareRT
_StringCompare
_StringBuilderConcat
_StringBuilderJoin
_SparseJoinWithSeparator
_StringToArray
_StringToLowerCase
_StringToUpperCase
_StringTrim
_TruncateString
_NewString
_NewConsString
_StringEquals
_FlattenString
_StringCharFromCode
_StringCharAt
_OneByteSeqStringGetChar
_OneByteSeqStringSetChar
_TwoByteSeqStringGetChar
_TwoByteSeqStringSetChar
_StringCharCodeAt
_IsStringWrapperSafeForDefaultValueOf
_StringGetLength
_CreateSymbol
_CreatePrivateSymbol
_CreateGlobalPrivateSymbol
_NewSymbolWrapper
_SymbolDescription
_SymbolRegistry
_SymbolIsPrivate
_DeoptimizeFunction
_DeoptimizeNow
_RunningInSimulator
_IsConcurrentRecompilationSupported
_OptimizeFunctionOnNextCall
_OptimizeOsr
_NeverOptimizeFunction
_GetOptimizationStatus
_UnblockConcurrentRecompilation
_GetOptimizationCount
_GetUndetectable
_ClearFunctionTypeFeedback
_NotifyContextDisposed
_SetAllocationTimeout
_DebugPrint
_DebugTrace
_GlobalPrint
_SystemBreak
_SetFlags
_Abort
_AbortJS
_NativeScriptsCount
_GetV8Version
_DisassembleFunction
_TraceEnter
_TraceExit
_HaveSameMap
_HasFastSmiElements
_HasFastObjectElements
_HasFastSmiOrObjectElements
_HasFastDoubleElements
_HasFastHoleyElements
_HasDictionaryElements
_HasSloppyArgumentsElements
_HasExternalArrayElements
_HasFastProperties
_HasExternalUint8Elements
_HasExternalInt8Elements
_HasExternalUint16Elements
_HasExternalInt16Elements
_HasExternalUint32Elements
_HasExternalInt32Elements
_HasExternalFloat32Elements
_HasExternalFloat64Elements
_HasExternalUint8ClampedElements
_HasFixedUint8Elements
_HasFixedInt8Elements
_HasFixedUint16Elements
_HasFixedInt16Elements
_HasFixedUint32Elements
_HasFixedInt32Elements
_HasFixedFloat32Elements
_HasFixedFloat64Elements
_HasFixedUint8ClampedElements
_ArrayBufferInitialize
_ArrayBufferGetByteLength
_ArrayBufferSliceImpl
_ArrayBufferIsView
_ArrayBufferNeuter
_TypedArrayInitialize
_TypedArrayInitializeFromArrayLike
_ArrayBufferViewGetByteLength
_ArrayBufferViewGetByteOffset
_TypedArrayGetLength
_DataViewGetBuffer
_TypedArrayGetBuffer
_TypedArraySetFastCases
_TypedArrayMaxSizeInHeap
_IsTypedArray
_IsSharedTypedArray
_IsSharedIntegerTypedArray
_DataViewInitialize
_DataViewGetUint8
_DataViewGetInt8
_DataViewGetUint16
_DataViewGetInt16
_DataViewGetUint32
_DataViewGetInt32
_DataViewGetFloat32
_DataViewGetFloat64
_DataViewSetUint8
_DataViewSetInt8
_DataViewSetUint16
_DataViewSetInt16
_DataViewSetUint32
_DataViewSetInt32
_DataViewSetFloat32
_DataViewSetFloat64
_URIEscape
_URIUnescape
;;; Safepoint table.
SamplerThread
../deps/v8/src/scanner-character-streams.cc
utf8_split_char_buffer_length_ <= 4
sourceURL
sourceMappingURL
static
yield
.module
Heap::roots_array_start()
StackGuard::address_of_jslimit()
StackGuard::address_of_real_jslimit()
Heap::NewSpaceStart()
Heap::NewSpaceMask()
Heap::NewSpaceAllocationLimitAddress()
Heap::NewSpaceAllocationTopAddress()
Debug::Break()
Debug::step_in_fp_addr()
mod_two_doubles
KeyedLookupCache::keys()
KeyedLookupCache::field_offsets()
HandleScope::next
HandleScope::limit
HandleScope::level
Deoptimizer::New()
Deoptimizer::ComputeOutputFrames()
LDoubleConstant::min_int
LDoubleConstant::one_half
isolate
LDoubleConstant::negative_infinity
power_double_double_function
power_double_int_function
std::log
the_hole_nan
JSDate::GetField
date_cache_stamp
address_of_pending_message_obj
Code::MakeCodeYoung
cpu_features
Heap::OldSpaceAllocationTopAddress
Heap::OldSpaceAllocationLimitAddress
Heap::allocation_sites_list_address()
uint32_bias
Code::MarkCodeAsExecuted
CpuProfiler::is_profiling
Isolate::scheduled_exception
InvokeFunctionCallback
InvokeAccessorGetterCallback
CpuFeatures::FlushICache
Logger::EnterExternal
Logger::LeaveExternal
double_constants.minus_one_half
Isolate::stress_deopt_count_address()
Debug::after_break_target_address()
Debug::restarter_frame_function_pointer_address()
Debug::is_active_address()
NativeRegExpMacroAssembler::CaseInsensitiveCompareUC16()
RegExpMacroAssembler*::CheckStackGuardState()
NativeRegExpMacroAssembler::GrowStack()
NativeRegExpMacroAssembler::word_character_map
RegExpStack::limit_address()
RegExpStack::memory_address()
RegExpStack::memory_size()
OffsetsVector::static_offsets_vector
Builtins::Illegal
Builtins::EmptyFunction
Builtins::ArrayPush
Builtins::ArrayPop
Builtins::ArrayShift
Builtins::ArrayUnshift
Builtins::ArraySlice
Builtins::ArraySplice
Builtins::ArrayConcat
Builtins::HandleApiCall
Builtins::HandleApiCallConstruct
Builtins::HandleApiCallAsFunction
Builtins::HandleApiCallAsConstructor
Builtins::RestrictedFunctionPropertiesThrower
Builtins::RestrictedStrictArgumentsPropertiesThrower
Builtins::ArgumentsAdaptorTrampoline
Builtins::InOptimizationQueue
Builtins::JSConstructStubGeneric
Builtins::JSConstructStubForDerived
Builtins::JSConstructStubApi
Builtins::JSConstructStubNewTarget
Builtins::JSEntryTrampoline
Builtins::JSConstructEntryTrampoline
Builtins::CompileLazy
Builtins::CompileOptimized
Builtins::CompileOptimizedConcurrent
Builtins::NotifyDeoptimized
Builtins::NotifySoftDeoptimized
Builtins::NotifyLazyDeoptimized
Builtins::NotifyStubFailure
Builtins::NotifyStubFailureSaveDoubles
Builtins::LoadIC_Miss
Builtins::KeyedLoadIC_Miss
Builtins::StoreIC_Miss
Builtins::KeyedStoreIC_Miss
Builtins::LoadIC_Getter_ForDeopt
Builtins::KeyedLoadIC_Megamorphic
Builtins::KeyedLoadIC_Megamorphic_Strong
Builtins::StoreIC_Setter_ForDeopt
Builtins::KeyedStoreIC_Initialize
Builtins::KeyedStoreIC_PreMonomorphic
Builtins::KeyedStoreIC_Megamorphic
Builtins::KeyedStoreIC_Initialize_Strict
Builtins::KeyedStoreIC_PreMonomorphic_Strict
Builtins::KeyedStoreIC_Megamorphic_Strict
Builtins::FunctionCall
Builtins::FunctionApply
Builtins::ReflectApply
Builtins::ReflectConstruct
Builtins::InternalArrayCode
Builtins::ArrayCode
Builtins::StringConstructCode
Builtins::OnStackReplacement
Builtins::InterruptCheck
Builtins::OsrAfterStackCheck
Builtins::StackCheck
Builtins::MarkCodeAsToBeExecutedOnce
Builtins::MarkCodeAsExecutedOnce
Builtins::MarkCodeAsExecutedTwice
Builtins::MakeQuadragenarianCodeYoungAgainOddMarking
Builtins::MakeQuadragenarianCodeYoungAgainEvenMarking
Builtins::MakeQuinquagenarianCodeYoungAgainOddMarking
Builtins::MakeQuinquagenarianCodeYoungAgainEvenMarking
Builtins::MakeSexagenarianCodeYoungAgainOddMarking
Builtins::MakeSexagenarianCodeYoungAgainEvenMarking
Builtins::MakeSeptuagenarianCodeYoungAgainOddMarking
Builtins::MakeSeptuagenarianCodeYoungAgainEvenMarking
Builtins::MakeOctogenarianCodeYoungAgainOddMarking
Builtins::MakeOctogenarianCodeYoungAgainEvenMarking
Builtins::Return_DebugBreak
Builtins::CallFunctionStub_DebugBreak
Builtins::CallConstructStub_DebugBreak
Builtins::CallConstructStub_Recording_DebugBreak
Builtins::CallICStub_DebugBreak
Builtins::Slot_DebugBreak
Builtins::PlainReturn_LiveEdit
Builtins::FrameDropper_LiveEdit
Runtime::LoadLookupSlot
Runtime::LoadLookupSlotNoReferenceError
Runtime::FinishArrayPrototypeSetup
Runtime::SpecialArrayFunctions
Runtime::TransitionElementsKind
Runtime::PushIfAbsent
Runtime::ArrayConcat
Runtime::RemoveArrayHoles
Runtime::MoveArrayContents
Runtime::EstimateNumberOfElements
Runtime::GetArrayKeys
Runtime::ArrayConstructor
Runtime::ArrayConstructorWithSubclassing
Runtime::InternalArrayConstructor
Runtime::NormalizeElements
Runtime::GrowArrayElements
Runtime::HasComplexElements
Runtime::IsArray
Runtime::HasCachedArrayIndex
Runtime::GetCachedArrayIndex
Runtime::FixedArrayGet
Runtime::FixedArraySet
Runtime::FastOneByteArrayJoin
Runtime::AtomicsCompareExchange
Runtime::AtomicsLoad
Runtime::AtomicsStore
Runtime::AtomicsAdd
Runtime::AtomicsSub
Runtime::AtomicsAnd
Runtime::AtomicsOr
Runtime::AtomicsXor
Runtime::AtomicsExchange
Runtime::AtomicsIsLockFree
Runtime::ThrowNonMethodError
Runtime::ThrowUnsupportedSuperError
Runtime::ThrowConstructorNonCallableError
Runtime::ThrowArrayNotSubclassableError
Runtime::ThrowStaticPrototypeError
Runtime::ThrowIfStaticPrototype
Runtime::ToMethod
Runtime::HomeObjectSymbol
Runtime::DefineClass
Runtime::DefineClassMethod
Runtime::ClassGetSourceCode
Runtime::LoadFromSuper
Runtime::LoadKeyedFromSuper
Runtime::StoreToSuper_Strict
Runtime::StoreToSuper_Sloppy
Runtime::StoreKeyedToSuper_Strict
Runtime::StoreKeyedToSuper_Sloppy
Runtime::HandleStepInForDerivedConstructors
Runtime::DefaultConstructorCallSuper
Runtime::CallSuperWithSpread
Runtime::StringGetRawHashField
Runtime::TheHole
Runtime::JSCollectionGetTable
Runtime::GenericHash
Runtime::SetInitialize
Runtime::SetGrow
Runtime::SetShrink
Runtime::SetClear
Runtime::SetIteratorInitialize
Runtime::SetIteratorClone
Runtime::SetIteratorNext
Runtime::SetIteratorDetails
Runtime::MapInitialize
Runtime::MapShrink
Runtime::MapClear
Runtime::MapGrow
Runtime::MapIteratorInitialize
Runtime::MapIteratorClone
Runtime::MapIteratorDetails
Runtime::GetWeakMapEntries
Runtime::MapIteratorNext
Runtime::WeakCollectionInitialize
Runtime::WeakCollectionGet
Runtime::WeakCollectionHas
Runtime::WeakCollectionDelete
Runtime::WeakCollectionSet
Runtime::GetWeakSetValues
Runtime::ObservationWeakMapCreate
Runtime::CompileLazy
Runtime::CompileOptimized
Runtime::NotifyStubFailure
Runtime::NotifyDeoptimized
Runtime::CompileForOnStackReplacement
Runtime::TryInstallOptimizedCode
Runtime::CompileString
Runtime::ResolvePossiblyDirectEval
Runtime::DateMakeDay
Runtime::DateSetValue
Runtime::IsDate
Runtime::ThrowNotDateError
Runtime::DateCurrentTime
Runtime::DateParseString
Runtime::DateLocalTimezone
Runtime::DateToUTC
Runtime::DateCacheVersion
Runtime::DateField
Runtime::DebugBreak
Runtime::SetDebugEventListener
Runtime::ScheduleBreak
Runtime::DebugGetInternalProperties
Runtime::DebugGetPropertyDetails
Runtime::DebugGetProperty
Runtime::DebugPropertyTypeFromDetails
Runtime::DebugPropertyAttributesFromDetails
Runtime::DebugPropertyIndexFromDetails
Runtime::DebugNamedInterceptorPropertyValue
Runtime::DebugIndexedInterceptorElementValue
Runtime::CheckExecutionState
Runtime::GetFrameCount
Runtime::GetFrameDetails
Runtime::GetScopeCount
Runtime::GetStepInPositions
Runtime::GetScopeDetails
Runtime::GetAllScopesDetails
Runtime::GetFunctionScopeCount
Runtime::GetFunctionScopeDetails
Runtime::SetScopeVariableValue
Runtime::DebugPrintScopes
Runtime::GetThreadCount
Runtime::GetThreadDetails
Runtime::SetDisableBreak
Runtime::GetBreakLocations
Runtime::SetFunctionBreakPoint
Runtime::SetScriptBreakPoint
Runtime::ClearBreakPoint
Runtime::ChangeBreakOnException
Runtime::IsBreakOnException
Runtime::PrepareStep
Runtime::ClearStepping
Runtime::DebugEvaluate
Runtime::DebugEvaluateGlobal
Runtime::DebugGetLoadedScripts
Runtime::DebugReferencedBy
Runtime::DebugConstructedBy
Runtime::DebugGetPrototype
Runtime::DebugSetScriptSource
Runtime::FunctionGetInferredName
Runtime::GetFunctionCodePositionFromSource
Runtime::ExecuteInDebugContext
Runtime::GetDebugContext
Runtime::CollectGarbage
Runtime::GetHeapUsage
Runtime::GetScript
Runtime::DebugCallbackSupportsStepping
Runtime::DebugPrepareStepInIfStepping
Runtime::DebugPushPromise
Runtime::DebugPopPromise
Runtime::DebugPromiseEvent
Runtime::DebugAsyncTaskEvent
Runtime::DebugIsActive
Runtime::DebugBreakInOptimizedCode
Runtime::ForInDone
Runtime::ForInFilter
Runtime::ForInNext
Runtime::ForInStep
Runtime::IsSloppyModeFunction
Runtime::FunctionGetName
Runtime::FunctionSetName
Runtime::FunctionNameShouldPrintAsAnonymous
Runtime::FunctionMarkNameShouldPrintAsAnonymous
Runtime::FunctionIsArrow
Runtime::FunctionIsConciseMethod
Runtime::FunctionRemovePrototype
Runtime::FunctionGetScript
Runtime::FunctionGetSourceCode
Runtime::FunctionGetScriptSourcePosition
Runtime::FunctionGetPositionForOffset
Runtime::FunctionSetInstanceClassName
Runtime::FunctionSetLength
Runtime::FunctionSetPrototype
Runtime::FunctionIsAPIFunction
Runtime::FunctionIsBuiltin
Runtime::SetCode
Runtime::SetNativeFlag
Runtime::ThrowStrongModeTooFewArguments
Runtime::IsConstructor
Runtime::SetForceInlineFlag
Runtime::FunctionBindArguments
Runtime::BoundFunctionGetBindings
Runtime::NewObjectFromBound
Runtime::Call
Runtime::Apply
Runtime::GetFunctionDelegate
Runtime::GetConstructorDelegate
Runtime::GetOriginalConstructor
Runtime::CallFunction
Runtime::IsConstructCall
Runtime::IsFunction
Runtime::CreateJSGeneratorObject
Runtime::SuspendJSGeneratorObject
Runtime::ResumeJSGeneratorObject
Runtime::GeneratorClose
Runtime::GeneratorGetFunction
Runtime::GeneratorGetContext
Runtime::GeneratorGetReceiver
Runtime::GeneratorGetContinuation
Runtime::GeneratorGetSourcePosition
Runtime::FunctionIsGenerator
Runtime::GeneratorNext
Runtime::GeneratorThrow
Runtime::CheckIsBootstrapping
Runtime::Throw
Runtime::ReThrow
Runtime::UnwindAndFindExceptionHandler
Runtime::PromoteScheduledException
Runtime::ThrowReferenceError
Runtime::NewTypeError
Runtime::NewSyntaxError
Runtime::NewReferenceError
Runtime::ThrowIteratorResultNotAnObject
Runtime::ThrowStrongModeImplicitConversion
Runtime::PromiseRejectEvent
Runtime::PromiseRevokeReject
Runtime::PromiseHasHandlerSymbol
Runtime::StackGuard
Runtime::Interrupt
Runtime::AllocateInNewSpace
Runtime::AllocateInTargetSpace
Runtime::CollectStackTrace
Runtime::RenderCallSite
Runtime::GetFromCacheRT
Runtime::MessageGetStartPosition
Runtime::MessageGetScript
Runtime::FormatMessageString
Runtime::CallSiteGetFileNameRT
Runtime::CallSiteGetFunctionNameRT
Runtime::CallSiteGetScriptNameOrSourceUrlRT
Runtime::CallSiteGetMethodNameRT
Runtime::CallSiteGetLineNumberRT
Runtime::CallSiteGetColumnNumberRT
Runtime::CallSiteIsNativeRT
Runtime::CallSiteIsToplevelRT
Runtime::CallSiteIsEvalRT
Runtime::CallSiteIsConstructorRT
Runtime::IS_VAR
Runtime::GetFromCache
Runtime::IncrementStatsCounter
Runtime::Likely
Runtime::Unlikely
Runtime::HarmonyToString
Runtime::GetTypeFeedbackVector
Runtime::GetCallerJSFunction
Runtime::QuoteJSONString
Runtime::BasicJSONStringify
Runtime::ParseJson
Runtime::CreateObjectLiteral
Runtime::CreateArrayLiteral
Runtime::CreateArrayLiteralStubBailout
Runtime::StoreArrayLiteralElement
Runtime::LiveEditFindSharedFunctionInfosForScript
Runtime::LiveEditGatherCompileInfo
Runtime::LiveEditReplaceScript
Runtime::LiveEditFunctionSourceUpdated
Runtime::LiveEditReplaceFunctionCode
Runtime::LiveEditFunctionSetScript
Runtime::LiveEditReplaceRefToNestedFunction
Runtime::LiveEditPatchFunctionPositions
Runtime::LiveEditCheckAndDropActivations
Runtime::LiveEditCompareStrings
Runtime::LiveEditRestartFrame
Runtime::MathAcos
Runtime::MathAsin
Runtime::MathAtan
Runtime::MathLogRT
Runtime::DoubleHi
Runtime::DoubleLo
Runtime::ConstructDouble
Runtime::RemPiO2
Runtime::MathAtan2
Runtime::MathExpRT
Runtime::MathClz32
Runtime::MathFloor
Runtime::MathPowSlow
Runtime::MathPowRT
Runtime::RoundNumber
Runtime::MathSqrt
Runtime::MathFround
Runtime::MathPow
Runtime::IsMinusZero
Runtime::NumberToRadixString
Runtime::NumberToFixed
Runtime::NumberToExponential
Runtime::NumberToPrecision
Runtime::IsValidSmi
Runtime::StringToNumber
Runtime::StringParseInt
Runtime::StringParseFloat
Runtime::NumberToStringRT
Runtime::NumberToStringSkipCache
Runtime::NumberToInteger
Runtime::NumberToIntegerMapMinusZero
Runtime::NumberToJSUint32
Runtime::NumberToJSInt32
Runtime::NumberToSmi
Runtime::NumberAdd
Runtime::NumberSub
Runtime::NumberMul
Runtime::NumberUnaryMinus
Runtime::NumberDiv
Runtime::NumberMod
Runtime::NumberImul
Runtime::NumberOr
Runtime::NumberAnd
Runtime::NumberXor
Runtime::NumberShl
Runtime::NumberShr
Runtime::NumberSar
Runtime::NumberEquals
Runtime::NumberCompare
Runtime::SmiLexicographicCompare
Runtime::MaxSmi
Runtime::NumberToString
Runtime::IsSmi
Runtime::IsNonNegativeSmi
Runtime::GetRootNaN
Runtime::GetPrototype
Runtime::InternalSetPrototype
Runtime::SetPrototype
Runtime::IsInPrototypeChain
Runtime::GetOwnProperty
Runtime::PreventExtensions
Runtime::IsExtensible
Runtime::OptimizeObjectForAddingMultipleProperties
Runtime::ObjectFreeze
Runtime::ObjectSeal
Runtime::GetProperty
Runtime::GetPropertyStrong
Runtime::KeyedGetProperty
Runtime::KeyedGetPropertyStrong
Runtime::AddNamedProperty
Runtime::SetProperty
Runtime::AddElement
Runtime::AppendElement
Runtime::DeleteProperty
Runtime::HasOwnProperty
Runtime::HasProperty
Runtime::HasElement
Runtime::IsPropertyEnumerable
Runtime::GetPropertyNames
Runtime::GetPropertyNamesFast
Runtime::GetOwnPropertyNames
Runtime::GetOwnElementNames
Runtime::GetInterceptorInfo
Runtime::GetNamedInterceptorPropertyNames
Runtime::GetIndexedInterceptorElementNames
Runtime::OwnKeys
Runtime::ToFastProperties
Runtime::ToBool
Runtime::NewStringWrapper
Runtime::AllocateHeapNumber
Runtime::NewObject
Runtime::NewObjectWithAllocationSite
Runtime::FinalizeInstanceSize
Runtime::GlobalProxy
Runtime::LookupAccessor
Runtime::LoadMutableDouble
Runtime::TryMigrateInstance
Runtime::IsJSGlobalProxy
Runtime::DefineAccessorPropertyUnchecked
Runtime::DefineDataPropertyUnchecked
Runtime::GetDataProperty
Runtime::HasFastPackedElements
Runtime::ValueOf
Runtime::SetValueOf
Runtime::JSValueGetValue
Runtime::HeapObjectGetMap
Runtime::MapGetInstanceType
Runtime::ObjectEquals
Runtime::IsObject
Runtime::IsUndetectableObject
Runtime::IsSpecObject
Runtime::IsStrong
Runtime::ClassOf
Runtime::DefineGetterPropertyUnchecked
Runtime::DefineSetterPropertyUnchecked
Runtime::IsAccessCheckNeeded
Runtime::IsObserved
Runtime::SetIsObserved
Runtime::EnqueueMicrotask
Runtime::RunMicrotasks
Runtime::DeliverObservationChangeRecords
Runtime::GetObservationState
Runtime::ObserverObjectAndRecordHaveSameOrigin
Runtime::ObjectWasCreatedInCurrentOrigin
Runtime::GetObjectContextObjectObserve
Runtime::GetObjectContextObjectGetNotifier
Runtime::GetObjectContextNotifierPerformChange
Runtime::CreateJSProxy
Runtime::CreateJSFunctionProxy
Runtime::IsJSProxy
Runtime::IsJSFunctionProxy
Runtime::GetHandler
Runtime::GetCallTrap
Runtime::GetConstructTrap
Runtime::Fix
Runtime::StringReplaceGlobalRegExpWithString
Runtime::StringSplit
Runtime::RegExpExec
Runtime::RegExpConstructResultRT
Runtime::RegExpConstructResult
Runtime::RegExpInitializeAndCompile
Runtime::MaterializeRegExpLiteral
Runtime::RegExpExecMultiple
Runtime::RegExpExecReThrow
Runtime::IsRegExp
Runtime::ThrowConstAssignError
Runtime::DeclareGlobals
Runtime::InitializeVarGlobal
Runtime::InitializeConstGlobal
Runtime::DeclareLookupSlot
Runtime::InitializeLegacyConstLookupSlot
Runtime::NewArguments
Runtime::NewSloppyArguments
Runtime::NewStrictArguments
Runtime::NewRestParam
Runtime::NewRestParamSlow
Runtime::NewClosureFromStubFailure
Runtime::NewClosure
Runtime::NewScriptContext
Runtime::NewFunctionContext
Runtime::PushWithContext
Runtime::PushCatchContext
Runtime::PushBlockContext
Runtime::IsJSModule
Runtime::PushModuleContext
Runtime::DeclareModules
Runtime::DeleteLookupSlot
Runtime::StoreLookupSlot
Runtime::GetArgumentsProperty
Runtime::ArgumentsLength
Runtime::Arguments
Runtime::StringReplaceOneCharWithString
Runtime::StringIndexOf
Runtime::StringLastIndexOf
Runtime::StringLocaleCompare
Runtime::SubStringRT
Runtime::SubString
Runtime::StringAddRT
Runtime::StringAdd
Runtime::InternalizeString
Runtime::StringMatch
Runtime::StringCharCodeAtRT
Runtime::CharFromCode
Runtime::StringCompareRT
Runtime::StringCompare
Runtime::StringBuilderConcat
Runtime::StringBuilderJoin
Runtime::SparseJoinWithSeparator
Runtime::StringToArray
Runtime::StringToLowerCase
Runtime::StringToUpperCase
Runtime::StringTrim
Runtime::TruncateString
Runtime::NewString
Runtime::NewConsString
Runtime::StringEquals
Runtime::FlattenString
Runtime::StringCharFromCode
Runtime::StringCharAt
Runtime::OneByteSeqStringGetChar
Runtime::OneByteSeqStringSetChar
Runtime::TwoByteSeqStringGetChar
Runtime::TwoByteSeqStringSetChar
Runtime::StringCharCodeAt
Runtime::IsStringWrapperSafeForDefaultValueOf
Runtime::StringGetLength
Runtime::CreateSymbol
Runtime::CreatePrivateSymbol
Runtime::CreateGlobalPrivateSymbol
Runtime::NewSymbolWrapper
Runtime::SymbolDescription
Runtime::SymbolRegistry
Runtime::SymbolIsPrivate
Runtime::DeoptimizeFunction
Runtime::DeoptimizeNow
Runtime::RunningInSimulator
Runtime::IsConcurrentRecompilationSupported
Runtime::OptimizeFunctionOnNextCall
Runtime::OptimizeOsr
Runtime::NeverOptimizeFunction
Runtime::GetOptimizationStatus
Runtime::UnblockConcurrentRecompilation
Runtime::GetOptimizationCount
Runtime::GetUndetectable
Runtime::ClearFunctionTypeFeedback
Runtime::NotifyContextDisposed
Runtime::SetAllocationTimeout
Runtime::DebugPrint
Runtime::DebugTrace
Runtime::GlobalPrint
Runtime::SystemBreak
Runtime::SetFlags
Runtime::Abort
Runtime::AbortJS
Runtime::NativeScriptsCount
Runtime::GetV8Version
Runtime::DisassembleFunction
Runtime::TraceEnter
Runtime::TraceExit
Runtime::HaveSameMap
Runtime::HasFastSmiElements
Runtime::HasFastObjectElements
Runtime::HasFastSmiOrObjectElements
Runtime::HasFastDoubleElements
Runtime::HasFastHoleyElements
Runtime::HasDictionaryElements
Runtime::HasSloppyArgumentsElements
Runtime::HasExternalArrayElements
Runtime::HasFastProperties
Runtime::HasExternalUint8Elements
Runtime::HasExternalInt8Elements
Runtime::HasExternalUint16Elements
Runtime::HasExternalInt16Elements
Runtime::HasExternalUint32Elements
Runtime::HasExternalInt32Elements
Runtime::HasExternalFloat32Elements
Runtime::HasExternalFloat64Elements
Runtime::HasExternalUint8ClampedElements
Runtime::HasFixedUint8Elements
Runtime::HasFixedInt8Elements
Runtime::HasFixedUint16Elements
Runtime::HasFixedInt16Elements
Runtime::HasFixedUint32Elements
Runtime::HasFixedInt32Elements
Runtime::HasFixedFloat32Elements
Runtime::HasFixedFloat64Elements
Runtime::HasFixedUint8ClampedElements
Runtime::ArrayBufferInitialize
Runtime::ArrayBufferGetByteLength
Runtime::ArrayBufferSliceImpl
Runtime::ArrayBufferIsView
Runtime::ArrayBufferNeuter
Runtime::TypedArrayInitialize
Runtime::TypedArrayInitializeFromArrayLike
Runtime::ArrayBufferViewGetByteLength
Runtime::ArrayBufferViewGetByteOffset
Runtime::TypedArrayGetLength
Runtime::DataViewGetBuffer
Runtime::TypedArrayGetBuffer
Runtime::TypedArraySetFastCases
Runtime::TypedArrayMaxSizeInHeap
Runtime::IsTypedArray
Runtime::IsSharedTypedArray
Runtime::IsSharedIntegerTypedArray
Runtime::DataViewInitialize
Runtime::DataViewGetUint8
Runtime::DataViewGetInt8
Runtime::DataViewGetUint16
Runtime::DataViewGetInt16
Runtime::DataViewGetUint32
Runtime::DataViewGetInt32
Runtime::DataViewGetFloat32
Runtime::DataViewGetFloat64
Runtime::DataViewSetUint8
Runtime::DataViewSetInt8
Runtime::DataViewSetUint16
Runtime::DataViewSetInt16
Runtime::DataViewSetUint32
Runtime::DataViewSetInt32
Runtime::DataViewSetFloat32
Runtime::DataViewSetFloat64
Runtime::URIEscape
Runtime::URIUnescape
IC::LoadIC_Miss
IC::KeyedLoadIC_Miss
IC::CallIC_Miss
IC::CallIC_Customization_Miss
IC::StoreIC_Miss
IC::StoreIC_Slow
IC::KeyedStoreIC_Miss
IC::KeyedStoreIC_Slow
IC::StoreCallbackProperty
IC::LoadPropertyWithInterceptorOnly
IC::LoadPropertyWithInterceptor
IC::LoadElementWithInterceptor
IC::StorePropertyWithInterceptor
IC::CompareIC_Miss
IC::BinaryOpIC_Miss
IC::CompareNilIC_Miss
IC::Unreachable
IC::ToBooleanIC_Miss
Counters::global_handles
Counters::memory_allocated
Counters::normalized_maps
Counters::props_to_dictionary
Counters::elements_to_dictionary
Counters::alive_after_last_gc
Counters::objs_since_last_young
Counters::objs_since_last_full
Counters::string_table_capacity
Counters::number_of_symbols
Counters::script_wrappers
Counters::call_initialize_stubs
Counters::call_premonomorphic_stubs
Counters::call_normal_stubs
Counters::call_megamorphic_stubs
Counters::inlined_copied_elements
Counters::arguments_adaptors
Counters::compilation_cache_hits
Counters::compilation_cache_misses
Counters::string_ctor_calls
Counters::string_ctor_conversions
Counters::string_ctor_cached_number
Counters::string_ctor_string_value
Counters::string_ctor_gc_required
Counters::total_eval_size
Counters::total_load_size
Counters::total_parse_size
Counters::total_preparse_skipped
Counters::total_preparse_symbols_skipped
Counters::total_compile_size
Counters::total_full_codegen_source_size
Counters::contexts_created_from_scratch
Counters::contexts_created_by_snapshot
Counters::pc_to_code
Counters::pc_to_code_cached
Counters::store_buffer_compactions
Counters::store_buffer_overflows
Counters::code_stubs
Counters::total_stubs_code_size
Counters::total_compiled_code_size
Counters::gc_compactor_caused_by_request
Counters::gc_compactor_caused_by_promoted_data
Counters::gc_compactor_caused_by_oldspace_exhaustion
Counters::gc_last_resort_from_js
Counters::gc_last_resort_from_handles
Counters::keyed_load_generic_smi
Counters::keyed_load_generic_symbol
Counters::keyed_load_generic_lookup_cache
Counters::keyed_load_generic_slow
Counters::keyed_load_polymorphic_stubs
Counters::keyed_load_external_array_slow
Counters::keyed_call_generic_smi_fast
Counters::keyed_call_generic_smi_dict
Counters::keyed_call_generic_lookup_cache
Counters::keyed_call_generic_lookup_dict
Counters::keyed_call_generic_slow
Counters::keyed_call_generic_slow_load
Counters::named_load_global_stub
Counters::named_store_global_inline
Counters::named_store_global_inline_miss
Counters::keyed_store_polymorphic_stubs
Counters::keyed_store_external_array_slow
Counters::store_normal_miss
Counters::store_normal_hit
Counters::cow_arrays_created_stub
Counters::cow_arrays_created_runtime
Counters::cow_arrays_converted
Counters::call_miss
Counters::keyed_call_miss
Counters::load_miss
Counters::keyed_load_miss
Counters::call_const
Counters::call_const_fast_api
Counters::call_const_interceptor
Counters::call_const_interceptor_fast_api
Counters::call_global_inline
Counters::call_global_inline_miss
Counters::constructed_objects
Counters::constructed_objects_runtime
Counters::negative_lookups
Counters::negative_lookups_miss
Counters::megamorphic_stub_cache_probes
Counters::megamorphic_stub_cache_misses
Counters::megamorphic_stub_cache_updates
Counters::array_function_runtime
Counters::array_function_native
Counters::for_in
Counters::enum_cache_hits
Counters::enum_cache_misses
Counters::fast_new_closure_total
Counters::fast_new_closure_try_optimized
Counters::fast_new_closure_install_optimized
Counters::string_add_runtime
Counters::string_add_native
Counters::string_add_runtime_ext_to_one_byte
Counters::sub_string_runtime
Counters::sub_string_native
Counters::string_add_make_two_char
Counters::string_compare_native
Counters::string_compare_runtime
Counters::regexp_entry_runtime
Counters::regexp_entry_native
Counters::number_to_string_native
Counters::number_to_string_runtime
Counters::math_acos
Counters::math_asin
Counters::math_atan
Counters::math_atan2
Counters::math_clz32
Counters::math_exp
Counters::math_floor
Counters::math_log
Counters::math_pow
Counters::math_round
Counters::math_sqrt
Counters::stack_interrupts
Counters::runtime_profiler_ticks
Counters::bounds_checks_eliminated
Counters::bounds_checks_hoisted
Counters::soft_deopts_requested
Counters::soft_deopts_inserted
Counters::soft_deopts_executed
Counters::write_barriers_dynamic
Counters::write_barriers_static
Counters::new_space_bytes_available
Counters::new_space_bytes_committed
Counters::new_space_bytes_used
Counters::old_space_bytes_available
Counters::old_space_bytes_committed
Counters::old_space_bytes_used
Counters::code_space_bytes_available
Counters::code_space_bytes_committed
Counters::code_space_bytes_used
Counters::map_space_bytes_available
Counters::map_space_bytes_committed
Counters::map_space_bytes_used
Counters::lo_space_bytes_available
Counters::lo_space_bytes_committed
Counters::lo_space_bytes_used
Isolate::handler_address
Isolate::c_entry_fp_address
Isolate::c_function_address
Isolate::context_address
Isolate::pending_exception_address
Isolate::pending_handler_context_address
Isolate::pending_handler_code_address
Isolate::pending_handler_offset_address
Isolate::pending_handler_fp_address
Isolate::pending_handler_sp_address
Isolate::external_caught_exception_address
Isolate::js_entry_sp_address
Accessors::ArgumentsIteratorGetter
Accessors::ArgumentsIteratorSetter
Accessors::ArrayLengthGetter
Accessors::ArrayLengthSetter
Accessors::FunctionArgumentsGetter
Accessors::FunctionArgumentsSetter
Accessors::FunctionCallerGetter
Accessors::FunctionCallerSetter
Accessors::FunctionNameGetter
Accessors::FunctionNameSetter
Accessors::FunctionLengthGetter
Accessors::FunctionLengthSetter
Accessors::FunctionPrototypeGetter
Accessors::FunctionPrototypeSetter
Accessors::ScriptColumnOffsetGetter
Accessors::ScriptColumnOffsetSetter
Accessors::ScriptCompilationTypeGetter
Accessors::ScriptCompilationTypeSetter
Accessors::ScriptContextDataGetter
Accessors::ScriptContextDataSetter
Accessors::ScriptEvalFromScriptGetter
Accessors::ScriptEvalFromScriptSetter
Accessors::ScriptEvalFromScriptPositionGetter
Accessors::ScriptEvalFromScriptPositionSetter
Accessors::ScriptEvalFromFunctionNameGetter
Accessors::ScriptEvalFromFunctionNameSetter
Accessors::ScriptIdGetter
Accessors::ScriptIdSetter
Accessors::ScriptLineEndsGetter
Accessors::ScriptLineEndsSetter
Accessors::ScriptLineOffsetGetter
Accessors::ScriptLineOffsetSetter
Accessors::ScriptNameGetter
Accessors::ScriptNameSetter
Accessors::ScriptSourceGetter
Accessors::ScriptSourceSetter
Accessors::ScriptTypeGetter
Accessors::ScriptTypeSetter
Accessors::ScriptSourceUrlGetter
Accessors::ScriptSourceUrlSetter
Accessors::ScriptSourceMappingUrlGetter
Accessors::ScriptSourceMappingUrlSetter
Accessors::ScriptIsEmbedderDebugScriptGetter
Accessors::ScriptIsEmbedderDebugScriptSetter
Accessors::StringLengthGetter
Accessors::StringLengthSetter
StubCache::primary_->key
StubCache::primary_->value
StubCache::primary_->map
StubCache::secondary_->key
StubCache::secondary_->value
StubCache::secondary_->map
HandleScope::DeleteExtensions
IncrementalMarking::RecordWrite
StoreBuffer::StoreBufferOverflow
lazy_deopt
../deps/v8/src/snapshot/serialize.cc
(magic_number_)==(SerializedData::ComputeMagicNumber(external_reference_table_))
deserializing context
deserialize context
(start_address)==(code_space->top())
outdated_contexts->IsFixedArray()
filled
back_reference.chunk_index() == 0
(reservation[chunk_index].end)==(high_water_[space])
(chunk_index)<(reservation.length())
(limit)==(current)
  Spaces (bytes):
%16ld
%16d
(isolate->thread_manager()->FirstThreadStateInUse()) == nullptr
isolate->handle_scope_implementer()->blocks()->is_empty()
(0)==(isolate->global_handles()->NumberOfWeakHandles())
(0)==(isolate->eternal_handles()->NumberOfHandles())
!isolate->has_installed_extensions()
SkipOneWord
Byte
FixedArray size in words
 Encoding hot object %d:
HotObjectSkipDistance
 Encoding source object
kSourceObjectReference
 Encoding global proxy
kGlobalProxyReference
 Encoding back reference to: 
BackRefSkipDistance
 Encoding root %d:
SkipInPutRoot
root_index
BackRefValue
partial_snapshot_cache_index
ObjectSizeInWords
StringContent
SkipDistance
 Encoding heap object: 
(0)==(bytes_processed_so_far_)
 Encoding deferred heap object: 
deferred object size
repeat count
SkipB4ExternalRef
reference id
internal ref address
internal ref value
[Serializing from
[Serializing to %d bytes took %0.3f ms]
!obj->IsMap()
!obj->IsJSGlobalProxy() && !obj->IsGlobalObject()
!obj->IsHashTable()
!obj->IsJSFunction() && !obj->IsContext()
 Encoding builtin: %s
builtin_index
 Encoding code stub %s as %d
CodeStub key
 %s is a code stub
 %s is a builtin
 %s has no special handling
[Cached code failed check]
[Deserializing failed]
[Deserializing from %d bytes took %0.3f ms]
SkipDistanceFromSerializeObject
CodeSerializer
[Deserializing isolate (%d bytes) took %0.3f ms]
../deps/v8/src/snapshot/snapshot-common.cc
result->IsContext()
EmbedsScript(isolate) || (*outdated_contexts_out)->length() == 2
[Deserializing context (%d bytes) took %0.3f ms]
Deserialization will reserve:
%10d bytes per isolate
%10d bytes per context
Snapshot blob consists of:
%10d bytes for startup
%10d bytes for context
../deps/v8/src/snapshot/serialize.h
IsSane()
../deps/v8/src/string-stream.cc
(bytes)<=(length_)
#%d#
StackDump
/* anonymous */
<Invalid map>
<unboxed double> %.16g
%d: %o
                  ...
             %d: %3d 0x%02x
 '%c'
 ^%c
==== Key         ============================================
 #%d# %p: 
           value(): %o
(Function context is outside heap)
Security context: %o
(Function context is corrupt)
/* warning: 'function' was not a heap object */ 
/* warning: 'function' was not on the heap */ 
/* warning: function's map was not on the heap */ 
/* warning: function's map was not a valid map */ 
/* unresolved */ 
/* warning: no JSFunction object or function name found */ 
(aka 
<symbol>
LPAREN
RPAREN
LBRACK
RBRACK
LBRACE
RBRACE
COLON
SEMICOLON
PERIOD
ELLIPSIS
CONDITIONAL
ARROW
INIT_VAR
INIT_LET
INIT_CONST
INIT_CONST_LEGACY
ASSIGN
ASSIGN_BIT_OR
ASSIGN_BIT_XOR
ASSIGN_BIT_AND
ASSIGN_SHL
ASSIGN_SAR
ASSIGN_SHR
ASSIGN_ADD
ASSIGN_SUB
ASSIGN_MUL
ASSIGN_DIV
ASSIGN_MOD
COMMA
EQ_STRICT
NE_STRICT
INSTANCEOF
BIT_NOT
TYPEOF
VOID
BREAK
CASE
CATCH
CONTINUE
DEBUGGER
ELSE
FINALLY
RETURN
SWITCH
THIS
THROW
WHILE
WITH
NULL_LITERAL
TRUE_LITERAL
FALSE_LITERAL
IDENTIFIER
FUTURE_RESERVED_WORD
FUTURE_STRICT_RESERVED_WORD
CLASS
CONST
EXTENDS
IMPORT
STATIC
YIELD
SUPER
WHITESPACE
TEMPLATE_SPAN
TEMPLATE_TAIL
=init_var
=init_let
=init_const
=init_const_legacy
>>>=
rotate right
instanceof
typeof
void
break
case
catch
continue
else
finally
while
with
class
const
export
extends
import
super
../deps/v8/src/transitions.cc
new_nof <= kMaxNumberOfTransitions
../deps/v8/src/type-feedback-vector.cc
feedback == *TypeFeedbackVector::UninitializedSentinel(isolate)
UntaggedBit
UntaggedSigned8
UntaggedSigned16
UntaggedSigned32
UntaggedUnsigned8
UntaggedUnsigned16
UntaggedUnsigned32
UntaggedFloat32
UntaggedFloat64
UntaggedPointer
TaggedSigned
TaggedPointer
UntaggedSigned
UntaggedUnsigned
UntaggedIntegral8
UntaggedIntegral16
UntaggedIntegral32
UntaggedIntegral
UntaggedFloat
UntaggedNumber
Untagged
Negative31
Unsigned30
MinusZero
InternalizedString
OtherString
Undetectable
OtherObject
Proxy
Internal
Signed31
Signed32
Negative32
Unsigned31
Unsigned32
Integral32
PlainNumber
OrderedNumber
MinusZeroOrNaN
UniqueName
BooleanOrNumber
NullOrUndefined
NumberOrString
NumberOrUndefined
PlainPrimitive
Primitive
DetectableReceiver
Detectable
Receiver
ReceiverOrUndefined
StringOrReceiver
Unique
NonNumber
../deps/v8/src/types.cc
lub == number_bits
Class(
Constant(
Range(
Context(
Array(
[%d] 
[%d:%p] 
Cannot read from file %s.
Cannot open file %s for writing.
--turbo-filter=*
../deps/v8/src/v8.cc
!platform_
platform
platform_
CONST_LEGACY
DYNAMIC
DYNAMIC_GLOBAL
DYNAMIC_LOCAL
INTERNAL
TEMPORARY
4.5.103.37
 (candidate)
%d.%d.%d.%d%s%s
%d.%d.%d%s%s
-candidate
libv8-%d.%d.%d.%d%s.so
libv8-%d.%d.%d%s.so
Zone
../deps/v8/src/x64/assembler-x64.cc
cpu.has_sse2()
cpu.has_cmov()
atom
SSE3=%d SSE4_1=%d SAHF=%d AVX=%d FMA3=%d BMI1=%d BMI2=%d LZCNT=%d POPCNT=%d ATOM=%d
is_int8(disp)
external code buffer is too small
Assembler::GrowBuffer
V8 failed to get kernel version
../deps/v8/src/x64/builtins-x64.cc
!FLAG_pretenuring_call_new
(bad)
[rip+0x%x]
[%s]
[%s*%d%s0x%x]
[%s+%s*%d]
[%s%s0x%x]
[%s+%s*%d%s0x%x]
%s%c %s,
%s%c 
Imm???
idiv
%s%c %s
test%c 
, cl
, %d
jmp %s
j%s %s
set%s%c 
vfmadd132s%c %s,%s,
vfmadd213s%c %s,%s,
vfmadd231s%c %s,%s,
vfmsub132s%c %s,%s,
vfmsub213s%c %s,%s,
vfmsub231s%c %s,%s,
vfnmadd132s%c %s,%s,
vfnmadd213s%c %s,%s,
vfnmadd231s%c %s,%s,
vfnmsub132s%c %s,%s,
vfnmsub213s%c %s,%s,
vfnmsub231s%c %s,%s,
shlx%c %s,
vaddss %s,%s,
vmulss %s,%s,
vsubss %s,%s,
vminss %s,%s,
vdivss %s,%s,
vmaxss %s,%s,
vaddsd %s,%s,
vmulsd %s,%s,
vsubsd %s,%s,
vminsd %s,%s,
vdivsd %s,%s,
vmaxsd %s,%s,
andn%c %s,%s,
bzhi%c %s,
bextr%c %s,
blsr
blsmsk
blsi
pdep%c %s,%s,
mulx%c %s,%s,
shrx%c %s,
pext%c %s,%s,
sarx%c %s,
rorx%c %s,
vucomiss %s,
vandps %s,%s,
vxorps %s,%s,
vucomisd %s,
vandpd %s,%s,
vxorpd %s,%s,
fld_s
fstp_s
fstcw
fild_s
fisttp_s
fist_s
fistp_s
fld_d
fstp_d
fild_d
fistp_d
fxch
fchs
fabs
fninit
ftst
fld1
fldpi
fldln2
fldz
f2xm1
fyl2x
fptan
fprem1
fincstp
fprem
frndint
fscale
fsin
fcos
fucompp
fucomi
fclex
fadd
fsub
fmul
fdiv
ffree
fstp
fcompp
faddp
fsubp
fmulp
fdivp
fnstsw_ax
fucomip
%s st%d
extractps 
,%s,%d
roundsd %s,
pextrd 
pinsrd 
 %s,
movapd %s,
movapd 
mov%c %s,
movdqa %s,
mov%c 
movdqa 
movq 
movmskpd %s,
%s %s,%d
pslld
psrld
psllq
psrlq
andpd
orpd
xorpd
ucomisd
comisd
pcmpeqd
punpckldq
punpckhdq
%s %s,
movsd 
cvttsd2si%c %s,
cvtsd2si%c %s,
cmpeqsd
cmpltsd
cmplesd
cmpunordsd
cmpneqsd
cmpnltsd
cmpnlesd
cmpordsd
%s %s,%s
movss 
cvttss2si%c %s,
movq %s,
popcnt%c %s,
tzcnt%c %s,
lzcnt%c %s,
cmpeqss
cmpltss
cmpless
cmpunordss
cmpneqss
cmpnltss
cmpnless
cmpordss
movaps %s,
movaps 
ucomiss %s,
rcpps
andps
andnps
orps
xorps
addps
mulps
cvtps2pd
cvtdq2ps
subps
minps
divps
maxps
shufps %s, 
movmskps %s,
,%s,cl
cvtsi2sd
cvtsi2ss
sqrtsd
sqrtss
addsd
addss
mulsd
mulss
cvtsd2ss
cvtss2sd
minsd
minss
subsd
subss
divsd
divss
maxsd
maxss
cpuid
shld
shrd
movzxb
movzxw
movsxb
movsxw
REX.W 
rep 
%s%c
%s %s
mov%c %s,%s
%s rax,%s
ret 0x%x
pop 
movb 
,0x%x
cmpb 
xchg%c rax,%s
movb %s,
decb 
push 0x%x
movzxlq rax,(%s)
movzxlq (%s),rax
movq rax,(%s)
movq (%s),rax
test al,0x%x
test%c rax,0x%lx
cmp al,0x%x
%02x
noreg
noxmmreg
  %s
movsxl
test
xchg
leave
int3
pushad
popad
pushfd
popfd
sahf
fwait
movs
cmps
../deps/v8/src/x64/disasm-x64.cc
'Unimplemented Instruction'
bwlq
cmovo
cmovno
cmovc
cmovnc
cmovz
cmovnz
cmovna
cmova
cmovs
cmovns
cmovpe
cmovpo
cmovl
cmovge
cmovle
cmovg
r10l
r11l
r12l
r13l
r14l
r15l
xmm0
../deps/v8/src/x64/full-codegen-x64.cc
info_->function() != nullptr && (info_->function()->kind() & kSubclassConstructor) != 0
Z_Code generation
;;; Save clobbered callee double registers
;;; Restore clobbered callee double registers
;;; Allocate local context
;;; End allocate local context
;;; -------------------- Jump table --------------------
;;; <@%d,#%d> -------------------- Deferred %s --------------------
;;; Build frame
;;; Deferred code
;;; Destroy frame
;;; <@%d,#%d> -------------------- B%d%s --------------------
 (OSR entry)
 Dead block replaced with B%d
add-d
sub-d
mul-d
div-d
mod-d
add-t
sub-t
mul-t
mod-t
div-t
bit-and-t
bit-or-t
bit-xor-t
ror-t
sal-t
sar-t
shr-t
B%d | B%d on 
 then B%d else B%d
if is_object(
) then B%d else B%d
if is_string(
if is_smi(
if is_undetectable(
if string_compare(
if has_instance_type(
if has_cached_array_index(
if class_of_test(
, "%o") then B%d else B%d
if typeof 
 == "%s" then B%d else B%d
.code_entry = 
 (type-feedback-vector 
#%d / 
[%d]
[%d] <- 
 #%d / 
 (%s) 
 length 
 index 
 + %d]
 + %d] <-
] <- 
<the hole(nan)>
 %p -> %p
L_Building chunk
lazy-bailout
dummy
dummy-use
label
call-stub
wrap-receiver
apply-arguments
access-arguments-at
arguments-length
mod-by-power-of-2-i
mod-by-const-i
mod-i
div-by-power-of-2-i
div-by-const-i
div-i
flooring-div-by-power-of-2-i
flooring-div-by-const-i
flooring-div-i
mul-i
compare-numeric-and-branch
math-floor
math-round
math-fround
math-abs
math-log
math-clz32
math-exp
math-sqrt
math-pow-half
cmp-object-eq-and-branch
cmp-hole-and-branch
cmp-minus-zero-and-branch
is-object-and-branch
is-string-and-branch
is-smi-and-branch
is-undetectable-and-branch
string-compare-and-branch
has-instance-type-and-branch
get-cached-array-index
has-cached-array-index-and-branch
class-of-test-and-branch
cmp-t
instance-of
instance-of-known-global
bounds-check
bit-i
shift-i
sub-i
cmp-map-and-branch
map-enum-length
date-field
seq-string-get-char
seq-string-set-char
add-i
math-min-max
power
load-named-field
load-named-generic
load-function-prototype
load-keyed
load-keyed-generic
load-global-generic
load-context-slot
store-context-slot
push-argument
drop
store-code-entry
inner-allocated-object
declare-globals
call-js-function
call-with-descriptor
invoke-function
call-function
call-new
call-new-array
call-runtime
int32-to-double
uint32-to-double
number-tag-i
number-tag-u
number-tag-d
double-to-i
double-to-smi
tagged-to-i
smi-tag
double-untag
smi-untag
store-named-field
store-named-generic
store-keyed
store-keyed-generic
transition-elements-kind
trap-allocation-memento
maybe-grow-elements
string-add
string-char-code-at
string-char-from-code
check-value
check-array-buffer-not-neutered
check-instance-type
check-maps
check-smi
clamp-d-to-uint8
clamp-i-to-uint8
clamp-t-to-uint8
check-non-smi
double-bits
construct-double
allocate
regexp-literal
function-literal
to-fast-properties
typeof-is-and-branch
is-construct-call-and-branch
osr-entry
stack-check
for-in-prepare-map
for-in-cache-array
check-map-value
load-field-by-index
store-frame-context
allocate-block-context
arguments-elements
constant-d
constant-e
constant-i
constant-s
constant-t
load-root
this-function
unknown-osr-value
../deps/v8/src/x64/macro-assembler-x64.cc
f->nargs < 0 || f->nargs == num_arguments
mode.IsEmpty()
check-maps-depth
[  patching ic at %p, test=%p, delta=%d
-- OSR entrypoint --
../deps/v8/src/compiler/linkage-impl.h
incoming_->IsJSFunctionCall()
spill_index <= LinkageLocation::MAX_STACK_SLOT
js-call
c-call
Agent
../src/debug-agent.cc
(err) == (0)
Stop
node
--debug-agent
WorkerRun
(&child_loop_) == (env->event_loop())
DebugAPI
notifyListen
notifyWait
sendCommand
port
_debugAPI
NotifyWait
onclose
MessageHandler
(isolate) == (a->parent_env()->isolate())
WrapperInfo
../src/async-wrap.cc
(0xA1C) != (class_id)
wrapper->IsObject()
!wrapper.IsEmpty()
(object->InternalFieldCount()) > (0)
(nullptr) != (wrap)
env()->context() == env()->isolate()->GetCurrentContext()
node::AsyncWrap::MakeCallback
domain enter callback threw, please report this
domain exit callback threw, please report this
CRYPTO
FSEVENTWRAP
FSREQWRAP
GETADDRINFOREQWRAP
GETNAMEINFOREQWRAP
HTTPPARSER
JSSTREAM
PIPEWRAP
PIPECONNECTWRAP
PROCESSWRAP
QUERYWRAP
SHUTDOWNWRAP
SIGNALWRAP
STATWATCHER
TCPWRAP
TCPCONNECTWRAP
TIMERWRAP
TLSWRAP
TTYWRAP
UDPWRAP
UDPSENDWRAP
WRITEWRAP
async_wrap
setupHooks
disable
enable
Providers
hooks should not be set while also enabled
first argument must be an object
post
destroy
init callback must be a function
../src/env-inl.h
init callback is not assigned to a function
../src/util-inl.h
(false) == (object.IsEmpty())
WARNING: Detected use of sync API
    at [eval]:%i:%i
    at [eval] (%s:%i:%i)
    at %s:%i:%i
    at %s (%s:%i:%i)
~FSEventWrap
../src/fs_event_wrap.cc
(initialized_) == (false)
close
args.IsConstructCall()
(wrap->initialized_) == (false)
filename must be a valid string
OnEvent
(wrap->persistent().IsEmpty()) == (false)
0 && "bad fs events flag"
fs_event_wrap
AfterGetAddrInfo
../src/cares_wrap.cc
(address->ai_socktype) == (1)
cares_wrap
Initialize
(r) == (0)
queryA
queryAaaa
queryCname
queryMx
queryNs
queryTxt
querySrv
queryNaptr
querySoa
getHostByAddr
isIP
isIPv4
isIPv6
strerror
getServers
setServers
AF_INET
AF_INET6
AF_UNSPEC
AI_ADDRCONFIG
AI_V4MAPPED
GetAddrInfoReqWrap
GetNameInfoReqWrap
QueryReqWrap
ares_sockstate_cb
((env->cares_task_list())->rbh_root == __null)
task && "When an ares socket is closed we should have a handle for it"
ares_timeout
(false) == (((env->cares_task_list())->rbh_root == __null))
Query
(false) == (args.IsConstructCall())
args[0]->IsObject()
args[1]->IsString()
AsyncWrap
(provider) != (PROVIDER_NONE)
(object->InternalFieldCount()) >= (1)
~QueryWrap
(false) == (persistent().IsEmpty())
ParseError
(status) != (0)
EFORMERR
ESERVFAIL
ENOTFOUND
ENOTIMP
EREFUSED
EBADQUERY
EBADNAME
EBADFAMILY
EBADRESP
ECONNREFUSED
ETIMEOUT
EFILE
ENOMEM
EDESTRUCTION
EBADSTR
EBADFLAGS
ENONAME
EBADHINTS
ENOTINITIALIZED
ELOADIPHLPAPI
EADDRGETNETWORKPARAMS
ECANCELLED
UNKNOWN_ARES_ERROR
GetAddrInfo
args[2]->IsInt32()
0 && "bad address family"
GetNameInfo
args[2]->IsUint32()
uv_ip4_addr(*ip, port, reinterpret_cast<sockaddr_in*>(&addr)) == 0 || uv_ip6_addr(*ip, port, reinterpret_cast<sockaddr_in6*>(&addr)) == 0
GetServers
SetServers
arr->Get(i)->IsArray()
elm->Get(0)->Int32Value()
elm->Get(1)->IsString()
0 && "Bad address family."
NewGetAddrInfoReqWrap
NewGetNameInfoReqWrap
NewQueryReqWrap
../src/req-wrap-inl.h
(req_.data) == (this)
Close
../src/handle_wrap.cc
(false) == (wrap->persistent().IsEmpty())
~HandleWrap
persistent().IsEmpty()
OnClose
(wrap->handle__) == (nullptr)
../src/js_stream.cc
Buffer::HasInstance(args[1])
ReadBuffer
Buffer::HasInstance(args[0])
JSStream
doAlloc
doRead
doAfterWrite
finishWrite
finishShutdown
readBuffer
emitEOF
js_stream
(handle->InternalFieldCount()) > (0)
readStart
readStop
writev
writeUtf8String
writeUcs2String
writeBinaryString
SIGHUP
SIGINT
SIGQUIT
SIGILL
SIGTRAP
SIGABRT
SIGBUS
SIGFPE
SIGKILL
SIGUSR1
SIGSEGV
SIGUSR2
SIGPIPE
SIGALRM
SIGTERM
SIGCHLD
SIGCONT
SIGSTOP
SIGTSTP
SIGTTIN
SIGTTOU
SIGURG
SIGXCPU
SIGXFSZ
SIGVTALRM
SIGPROF
SIGWINCH
SIGIO
SIGSYS
 -> '
process._tickDomainCallback assigned to non-function
SetupDomainUse
../src/node.cc
args[0]->IsArray()
args[1]->IsArray()
_setupDomainUse
SetupNextTick
args[0]->IsFunction()
args[1]->IsObject()
runMicrotasks
_setupNextTick
SetupPromises
_setupPromises
MakeCallback
(env->context()) == (env->isolate()->GetCurrentContext())
recv->IsObject()
node::MakeCallback
cb_v->IsFunction()
16le
nary
ffer
utf8
utf-8
ascii
base64
ucs2
ucs-2
utf16le
utf-16le
binary
'raw' (array of integers) has been removed. Use 'binary'.
raws
'raws' encoding has been renamed to 'binary'. Please update your code.
Encode
'raw' encoding (array of integers) has been removed. Use 'binary'.
%s:%i
AppendExceptionLine
(off) >= (0)
(off) <= (max_off)
uv_resident_set_memory
Bad argument.
process.hrtime() only accepts an Array tuple.
get_builtin_module
mp == nullptr || (mp->nm_flags & 0x01) != 0
get_linked_module
mp == nullptr || (mp->nm_flags & 0x02) != 0
DLOpen
(modpending) == (nullptr)
process.dlopen takes exactly 2 arguments.
Module did not self-register.
Module version mismatch. Expected %d, got %d.
Built-in module self-registered.
Module has no declared entry point.
uncaughtException
version
v4.5.0
moduleLoadList
versions
http_parser
zlib
1.2.8
ares
1.10.1-DEV
modules
_promiseRejectEvent
unhandled
handled
openssl
arch
darwin
release
Argon
sourceUrl
https://nodejs.org/download/release/v4.5.0/node-v4.5.0.tar.gz
headersUrl
https://nodejs.org/download/release/v4.5.0/node-v4.5.0-headers.tar.gz
features
_eval
_print_eval
_syntax_check_only
_forceRepl
SetupProcessObject
preload_modules
_preload_modules
noDeprecation
throwDeprecation
profProcess
traceDeprecation
REVERT_CVE_2016_2216
_startProfilerIdleNotifier
_stopProfilerIdleNotifier
_getActiveRequests
_getActiveHandles
reallyExit
abort
chdir
umask
getuid
geteuid
setuid
seteuid
setgid
setegid
getgid
getegid
getgroups
setgroups
initgroups
_kill
_debugProcess
_debugPause
_debugEnd
hrtime
dlopen
uptime
memoryUsage
binding
_linkedBinding
node.js
LoadEnvironment
f_value->IsFunction()
_rawDebug
FreeEnvironment
(env) != (nullptr)
Init
(0) == (uv_mutex_init(&node_isolate_mutex))
(0) == (uv_async_init(uv_default_loop(), &dispatch_debug_messages_async, DispatchDebugMessagesAsyncCallback))
--prof
%s: bad option: %s
exitCode
beforeExit
emit
process
(argc) > (0)
EACCES
EADDRINUSE
EADDRNOTAVAIL
EAFNOSUPPORT
EAGAIN
EALREADY
EBADF
EBADMSG
EBUSY
ECANCELED
ECHILD
ECONNABORTED
ECONNRESET
EDEADLK
EDESTADDRREQ
EDOM
EDQUOT
EEXIST
EFAULT
EFBIG
EHOSTUNREACH
EIDRM
EILSEQ
EINPROGRESS
EINTR
EINVAL
EISCONN
EISDIR
ELOOP
EMFILE
EMLINK
EMSGSIZE
EMULTIHOP
ENAMETOOLONG
ENETDOWN
ENETRESET
ENETUNREACH
ENFILE
ENOBUFS
ENODATA
ENODEV
ENOENT
ENOEXEC
ENOLINK
ENOLCK
ENOMSG
ENOPROTOOPT
ENOSPC
ENOSR
ENOSTR
ENOSYS
ENOTCONN
ENOTDIR
ENOTEMPTY
ENOTSOCK
ENOTSUP
ENOTTY
ENXIO
EOVERFLOW
EPERM
EPIPE
EPROTO
EPROTONOSUPPORT
EPROTOTYPE
ERANGE
EROFS
ESPIPE
ESRCH
ESTALE
ETIME
ETIMEDOUT
ETXTBSY
EXDEV
FATAL ERROR: %s %s
FATAL ERROR: %s
<toString() threw exception>
%s: %s
%s: %s
crypto
uv_chdir
uv_cwd
argument must be an integer or octal string.
invalid octal string
setuid argument must be a number or a string
setuid user id does not exist
seteuid argument must be a number or string
seteuid user id does not exist
setgid argument must be a number or a string
setgid group id does not exist
setegid argument must be a number or string
setegid group id does not exist
argument 1 must be an array
group name not found
argument 1 must be a number or a string
argument 2 must be a number or a string
initgroups user not found
initgroups extra group not found
Binding %s
Binding
(mod->nm_register_func) == (nullptr)
(mod->nm_context_register_func) != (nullptr)
constants
natives
No such module: %s
No such module was linked: %s
Linked module has no declared entry point.
RawDebug
args.Length() == 1 && args[0]->IsString() && "must be called with a single string"
Invalid number of arguments.
kill
Starting debugger agent.
StartDebug
!debugger_running
Starting debugger on port %d failed
EnableDebug
debugger_running
NODE_DEBUG_ENABLED
internalMessage
--version
--help
--eval
--print
%s: %s requires an argument
--require
--check
--interactive
--no-deprecation
--trace-deprecation
--trace-sync-io
--track-heap-objects
--throw-deprecation
--security-revert=
--prof-process
--zero-fill-buffers
--v8-options
--tls-cipher-list=
--expose-internals
--expose_internals
ParseArgs
!preload_modules
--debug
--debug=
--debug-brk
--debug-brk=
--debug-port=
Debug port must be in range 1024 to 65535.
RegisterDebugSignalHandler
(0) == (uv_sem_init(&debug_semaphore, 0))
(0) == (pthread_attr_init(&attr))
(0) == (pthread_attr_setstacksize(&attr, 8192))
(0) == (pthread_attr_setdetachstate(&attr, 2))
(0) == (pthread_sigmask(3, &sigmask, &sigmask))
(0) == (pthread_sigmask(3, &sigmask, nullptr))
(0) == (pthread_attr_destroy(&attr))
node[%d]: pthread_create: %s
(0) == (pthread_sigmask(2, &sigmask, nullptr))
RegisterSignalHandler
(sigaction(signal, &sa, nullptr)) == (0)
InternalFieldObject
address
args
argv
arrowMessage
async
_asyncQueue
atime
birthtime
blksize
blocks
bytes
bytesParsed
bytesRead
callback
change
oncertcb
_onclose
code
compare
debugPort
dest
detached
_disposed
_emittingTopLevelDomainError
exchange
idle
enter
envPairs
errno
error
_events
execArgv
execPath
_exiting
exit
expire
exponent
exports
ext_key_usage
_externalStream
family
_fatalException
file
fingerprint
FSEvent
handle
heapTotal
heapUsed
hostmaster
ignore
_immediateCallback
infoAccess
inherit
internal
IPv4
ipv6
IPv6
isAlive
isClosing
issuerCertificate
killSignal
mark-sweep-compact
maxBuffer
message
minttl
mode
model
modulus
mtime
_needImmediateCallback
netmask
nice
nlink
nsname
OCSPRequest
offset
onchange
onclienthello
oncomplete
onconnection
ondone
onerror
onexit
onhandshakedone
onhandshakestart
onmessage
onnewsession
onnewsessiondone
onocspresponse
onread
onreadstart
onreadstop
onshutdown
onsignal
onstop
onwrite
order
owner
Parse Error
path
PBKDF2 Error
pipe
preference
priority
processed
prototype
rdev
readable
receivedShutdown
refresh
regexp
rename
replacement
retry
scavenge
scopeid
sentShutdown
serialNumber
service
servername
sessionId
signal
Invalid SNI context
sni_context
speed
stack
status
stdio
subjectaltname
syscall
_tickCallback
_tickDomainCallback
onticketkeycallback
timeout
times
timestamp
title
tls_npn
tls_ocsp
tls_sni
tlsTicket
<unknown>
user
valid_from
valid_to
weight
windowsVerbatimArguments
wrap
writable
writeQueueSize
x-forwarded-for
ZERO_RETURN
/dev/null
PlatformInit
(0) == (sigaction(nr, &act, nullptr))
NodeInstanceData
../src/node_internals.h
(event_loop_) != (nullptr)
StartNodeInstance
(node_isolate) == (nullptr)
(isolate) != (nullptr)
Usage: node [options] [ -e script | script.js ] [arguments] 
       node debug script.js [arguments] 
Options:
  -v, --version         print Node.js version
  -e, --eval script     evaluate script
  -p, --print           evaluate script and print result
  -c, --check           syntax check script without executing
  -i, --interactive     always enter the REPL even if stdin
                        does not appear to be a terminal
  -r, --require         module to preload (option can be repeated)
  --no-deprecation      silence deprecation warnings
  --trace-deprecation   show stack traces on deprecations
  --throw-deprecation   throw an exception anytime a deprecated function is used
  --trace-sync-io       show stack trace when use of sync IO
                        is detected after the first tick
  --track-heap-objects  track heap object allocations for heap snapshots
  --prof-process        process v8 profiler output generated
                        using --prof
  --zero-fill-buffers   automatically zero-fill all newly allocated
                        Buffer and SlowBuffer instances
  --v8-options          print v8 command line options
  --tls-cipher-list=val use an alternative default TLS cipher list
Environment variables:
NODE_PATH               ':'-separated list of directories
                        prefixed to the module search path.
NODE_DISABLE_COLORS     set to 1 to disable colors in the REPL
NODE_REPL_HISTORY       path to the persistent REPL history file
Documentation can be found at https://nodejs.org/
Data
../src/node_buffer.cc
val->IsUint8Array()
obj->IsUint8Array()
Length
actual <= length
(data) != (nullptr)
Copy
length <= kMaxLength
CreateFromString
args[0]->IsString()
argument is not an ArrayBuffer
Unable to set Object prototype
argument should be a Buffer
StringSlice
(args.This())->IsUint8Array()
(ts_obj_data) != (nullptr)
out of range index
(target_obj)->IsUint8Array()
(target_data) != (nullptr)
Fill
(args[0])->IsUint8Array()
length + start <= ts_obj_length
ByteLengthUtf8
Compare
(obj_a_data) != (nullptr)
(args[1])->IsUint8Array()
(obj_b_data) != (nullptr)
IndexOfString
args[2]->IsNumber()
IndexOfBuffer
(buf_data) != (nullptr)
IndexOfNumber
args[1]->IsNumber()
SetupBufferJS
asciiSlice
base64Slice
binarySlice
hexSlice
ucs2Slice
utf8Slice
asciiWrite
base64Write
binaryWrite
hexWrite
ucs2Write
utf8Write
setupBufferJS
createFromString
createFromArrayBuffer
byteLengthUtf8
fill
indexOfBuffer
indexOfNumber
indexOfString
readDoubleBE
readDoubleLE
readFloatBE
readFloatLE
writeDoubleBE
writeDoubleLE
writeFloatBE
writeFloatLE
kMaxLength
kStringMaxLength
WeakCallback
object->IsArrayBuffer()
(obj_data) != (nullptr)
StringWrite
Argument must be a string
Offset is out of bounds
Invalid hex string
ReadFloatGeneric
(offset + sizeof(T)) <= (ts_obj_length)
WriteFloatGeneric
StringSearch
../src/string_search.h
(pattern_length) > (0)
SingleCharSearch
(1) == (search->pattern_.length())
operator[]
index < length_
LinearSearch
(pattern.length()) > (1)
(i) <= (n)
CharCompare
(length) > (0)
InitialSearch
Vector
length > 0 && data != nullptr
../src/node_config.cc
config
ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA
E2BIG
EOPNOTSUPP
EWOULDBLOCK
SIGIOT
SSL_OP_ALL
SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
SSL_OP_CIPHER_SERVER_PREFERENCE
SSL_OP_CISCO_ANYCONNECT
SSL_OP_COOKIE_EXCHANGE
SSL_OP_CRYPTOPRO_TLSEXT_BUG
SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
SSL_OP_EPHEMERAL_RSA
SSL_OP_LEGACY_SERVER_CONNECT
SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER
SSL_OP_MICROSOFT_SESS_ID_BUG
SSL_OP_MSIE_SSLV2_RSA_PADDING
SSL_OP_NETSCAPE_CA_DN_BUG
SSL_OP_NETSCAPE_CHALLENGE_BUG
SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
SSL_OP_NO_COMPRESSION
SSL_OP_NO_QUERY_MTU
SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION
SSL_OP_NO_SSLv2
SSL_OP_NO_SSLv3
SSL_OP_NO_TICKET
SSL_OP_NO_TLSv1
SSL_OP_NO_TLSv1_1
SSL_OP_NO_TLSv1_2
SSL_OP_PKCS1_CHECK_1
SSL_OP_PKCS1_CHECK_2
SSL_OP_SINGLE_DH_USE
SSL_OP_SINGLE_ECDH_USE
SSL_OP_SSLEAY_080_CLIENT_DH_BUG
SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG
SSL_OP_TLS_BLOCK_PADDING_BUG
SSL_OP_TLS_D5_BUG
SSL_OP_TLS_ROLLBACK_BUG
ENGINE_METHOD_DSA
ENGINE_METHOD_DH
ENGINE_METHOD_RAND
ENGINE_METHOD_ECDH
ENGINE_METHOD_ECDSA
ENGINE_METHOD_CIPHERS
ENGINE_METHOD_DIGESTS
ENGINE_METHOD_STORE
ENGINE_METHOD_PKEY_METHS
ENGINE_METHOD_PKEY_ASN1_METHS
ENGINE_METHOD_ALL
ENGINE_METHOD_NONE
DH_CHECK_P_NOT_SAFE_PRIME
DH_CHECK_P_NOT_PRIME
DH_UNABLE_TO_CHECK_GENERATOR
DH_NOT_SUITABLE_GENERATOR
NPN_ENABLED
RSA_PKCS1_PADDING
RSA_SSLV23_PADDING
RSA_NO_PADDING
RSA_PKCS1_OAEP_PADDING
RSA_X931_PADDING
RSA_PKCS1_PSS_PADDING
POINT_CONVERSION_COMPRESSED
POINT_CONVERSION_UNCOMPRESSED
POINT_CONVERSION_HYBRID
O_RDONLY
O_WRONLY
O_RDWR
S_IFMT
S_IFREG
S_IFDIR
S_IFCHR
S_IFBLK
S_IFIFO
S_IFLNK
S_IFSOCK
O_CREAT
O_EXCL
O_NOCTTY
O_TRUNC
O_APPEND
O_DIRECTORY
O_NOFOLLOW
O_SYNC
O_SYMLINK
O_NONBLOCK
S_IRWXU
S_IRUSR
S_IWUSR
S_IXUSR
S_IRWXG
S_IRGRP
S_IWGRP
S_IXGRP
S_IRWXO
S_IROTH
S_IWOTH
S_IXOTH
F_OK
R_OK
W_OK
X_OK
UV_UDP_REUSEADDR
defaultCoreCipherList
defaultCipherList
runInDebugContext
makeContext
isContext
RunInDebugContext
../src/node_contextify.cc
!debug_context.IsEmpty()
sandbox argument must be an object.
_contextifyHidden
MakeContext
sandbox->GetHiddenValue(hidden_name).IsEmpty()
Could not instantiate context
_contextifyHiddenGlobal
sandbox must be an object
ContextifyScript
runInContext
runInThisContext
Must call vm.Script as a constructor.
evalmachine.<anonymous>
options must be an object
filename
lineOffset
columnOffset
displayErrors
contextifiedSandbox argument must be an object.
sandbox argument must have been converted to a context.
timeout must be a positive number
Script methods can only be called on script instances.
Script execution timed out.
(function cloneProperty(source, key, target) {
  if (key === 'Proxy') return;
  try {
    var desc = Object.getOwnPropertyDescriptor(source, key);
    if (desc.value === source) desc.value = target;
    Object.defineProperty(target, key, desc);
  } catch (e) {
   // Catch sealed properties errors
binding:script
CopyProperties
clone_property_method->IsFunction()
contextify
BuildStatsObject
../src/node_file.cc
FSInitialize
stats_constructor->IsFunction()
access
open
read
fdatasync
fsync
ftruncate
rmdir
mkdir
internalModuleReadFile
internalModuleStat
stat
lstat
fstat
link
symlink
readlink
unlink
writeBuffers
writeString
chmod
fchmod
chown
fchown
utimes
futimes
FSReqWrap
path and mode are required
path must be a string
mode must be an integer
Access
args[2]->IsObject()
After
(&req_wrap->req_) == (req)
0 && "Unhandled eio response"
fd is required
fd must be a file descriptor
path required
flags required
mode required
flags must be an int
mode must be an int
Open
args[3]->IsObject()
fd and buffer are required
Second argument needs to be a buffer
Length extends beyond buffer
Read
req->IsObject()
Fdatasync
Fsync
old path required
new path required
old path must be a string
new path must be a string
Rename
fd and length are required
Not an integer
FTruncate
RMDir
MKDir
ReadDir
scandir
(req_wrap.req.result) >= (0)
InternalModuleReadFile
(numchars) >= (0)
(0) == (uv_fs_close(loop, &close_req, fd, nullptr))
InternalModuleStat
Stat
LStat
FStat
dest path required
src path required
dest path must be a string
src path must be a string
Link
target path required
target path must be a string
junction
Unknown symlink type
Symlink
ReadLink
Unlink
First argument must be file descriptor
WriteBuffer
offset out of bounds
length out of bounds
off + len > buffer.length
write
WriteBuffers
args[0]->IsInt32()
Array elements all need to be buffers
(storage) <= (sizeof(T) * storage)
(index) < (length())
Chmod
fd and mode are required
FChmod
uid required
gid required
uid must be an unsigned int
gid must be an unsigned int
Chown
fd required
fd must be an int
FChown
atime required
mtime required
atime must be a number
mtime must be a number
UTimes
utime
FUTimes
futime
NewFSReqWrap
HTTPParser
REQUEST
RESPONSE
kOnHeaders
kOnHeadersComplete
kOnBody
kOnMessageComplete
kOnExecute
HEAD
OPTIONS
TRACE
COPY
LOCK
MKCOL
MOVE
PROPFIND
PROPPATCH
SEARCH
UNLOCK
BIND
REBIND
UNBIND
REPORT
MKACTIVITY
CHECKOUT
MERGE
M-SEARCH
NOTIFY
SUBSCRIBE
UNSUBSCRIBE
PATCH
PURGE
MKCALENDAR
LINK
UNLINK
methods
execute
finish
reinitialize
pause
resume
consume
unconsume
getCurrentBuffer
on_header_field_
../src/node_http_parser.cc
(num_fields_) < (arraysize(fields_))
(num_fields_) == (num_values_ + 1)
on_header_value_
(num_values_) < (arraysize(values_))
(num_values_) == (num_fields_)
type == HTTP_REQUEST || type == HTTP_RESPONSE
Execute
parser->current_buffer_.IsEmpty()
(parser->current_buffer_len_) == (0)
(parser->current_buffer_data_) == (nullptr)
(Buffer::HasInstance(args[0])) == (true)
Reinitialize
(env) == (parser->env())
Consume
(stream) != (nullptr)
../src/stream_base.h
set_http_parser_buffer
(http_parser_buffer_) == (nullptr)
ScopedRetainParser
(p_->refcount_) > (0)
Unconsume
Pause
_debug_agent
_debugger
_linklist
assert
child_process
console
cluster
dgram
events
freelist
_http_agent
_http_client
_http_common
_http_incoming
_http_outgoing
_http_server
module
punycode
querystring
readline
repl
stream
_stream_readable
_stream_writable
_stream_duplex
_stream_transform
_stream_passthrough
_stream_wrap
string_decoder
timers
_tls_common
_tls_legacy
_tls_wrap
util
internal/child_process
internal/cluster
internal/freelist
internal/net
internal/module
internal/socket_list
internal/repl
internal/util
internal/v8_prof_polyfill
internal/v8_prof_processor
internal/streams/lazy_transform
v8/tools/splaytree
v8/tools/codemap
v8/tools/consarray
v8/tools/csvparser
v8/tools/profile
v8/tools/profile_view
v8/tools/logreader
v8/tools/tickprocessor
v8/tools/SourceMap
v8/tools/tickprocessor-driver
getHostname
getLoadAvg
getUptime
getTotalMem
getFreeMem
getCPUs
getOSType
getOSRelease
getInterfaceAddresses
getHomeDirectory
isBigEndian
gethostname
uname
uv_interface_addresses
%02x:%02x:%02x:%02x:%02x:%02x
<unknown sa family>
uv_os_homedir
../src/node_os.cc
CVE-2016-2216: Strict HTTP Header Parsing
Unknown
SECURITY WARNING: Reverting %s
CVE-2016-2216
Error: Attempt to revert an unknown CVE [%s]
isArrayBuffer
isDataView
isDate
isMap
isMapIterator
isPromise
isRegExp
isSet
isSetIterator
isTypedArray
getHiddenValue
IsArrayBuffer
../src/node_util.cc
(1) == (args.Length())
IsDataView
IsMap
IsMapIterator
IsPromise
IsSet
IsSetIterator
obj must be an object
name must be a string
v8 flag is required
v8 flag must be a string
updateHeapStatisticsArrayBuffer
setFlagsFromString
heapStatisticsArrayBuffer
kTotalHeapSizeIndex
kTotalHeapSizeExecutableIndex
kTotalPhysicalSizeIndex
kTotalAvailableSize
kUsedHeapSizeIndex
kHeapSizeLimitIndex
heap_statistics_buffer
(heap_statistics_buffer_) != (nullptr)
set_heap_statistics_buffer
(heap_statistics_buffer_) == (nullptr)
../src/node_v8.cc
StatWatcher
stop
../src/node_stat_watcher.cc
(wrap->watcher_) == (handle)
(args.Length()) == (3)
Watchdog
../src/node_watchdog.cc
(0) == (rc)
Destroy
writeSync
params
reset
Zlib
Z_NO_FLUSH
Z_PARTIAL_FLUSH
Z_SYNC_FLUSH
Z_FULL_FLUSH
Z_FINISH
Z_BLOCK
Z_OK
Z_STREAM_END
Z_NEED_DICT
Z_ERRNO
Z_STREAM_ERROR
Z_DATA_ERROR
Z_MEM_ERROR
Z_BUF_ERROR
Z_VERSION_ERROR
Z_NO_COMPRESSION
Z_BEST_SPEED
Z_BEST_COMPRESSION
Z_DEFAULT_COMPRESSION
Z_FILTERED
Z_HUFFMAN_ONLY
Z_RLE
Z_FIXED
Z_DEFAULT_STRATEGY
ZLIB_VERNUM
DEFLATE
INFLATE
GZIP
GUNZIP
DEFLATERAW
INFLATERAW
UNZIP
ZLIB_VERSION
~ZCtx
../src/node_zlib.cc
(false) == (write_in_progress_ && "write in progress")
init_done_ && "close before init"
(mode_) <= (UNZIP)
(args.Length() == 4 || args.Length() == 5) && "init(windowBits, level, memLevel, strategy, [dictionary])"
(windowBits >= 8 && windowBits <= 15) && "invalid windowBits"
(level >= -1 && level <= 9) && "invalid compression level"
(memLevel >= 1 && memLevel <= 9) && "invalid memlevel"
(strategy == 1 || strategy == 2 || strategy == 3 || strategy == 4 || strategy == 0) && "invalid strategy"
0 && "wtf?"
Init error
Unref
(refs_) > (0)
Failed to set dictionary
Params
args.Length() == 2 && "params(level, strategy)"
Failed to set parameters
Failed to reset stream
(args.Length()) == (7)
ctx->init_done_ && "write before init"
ctx->mode_ != NONE && "already finalized"
(false) == (ctx->write_in_progress_ && "write already in progress")
(false) == (ctx->pending_close_ && "close is pending")
(false) == (args[0]->IsUndefined() && "must provide flush value")
0 && "Invalid flush value"
Buffer::IsWithinBounds(in_off, in_len, Buffer::Length(in_buf))
Buffer::HasInstance(args[4])
Buffer::IsWithinBounds(out_off, out_len, Buffer::Length(out_buf))
Process
Missing dictionary
Bad dictionary
Zlib error
Instantiate
../src/pipe_wrap.cc
(false) == (env->pipe_constructor_template().IsEmpty())
(false) == (constructor.IsEmpty())
(false) == (instance.IsEmpty())
Pipe
unref
PipeConnectWrap
PipeWrap
OnConnection
(&pipe_wrap->handle_) == (reinterpret_cast<uv_pipe_t*>(handle))
(pipe_wrap->persistent().IsEmpty()) == (false)
AfterConnect
(req_wrap->env()) == (wrap->env())
(req_wrap->persistent().IsEmpty()) == (false)
uv_pipe_open
Connect
NewPipeConnectWrap
pipe_wrap
../src/signal_wrap.cc
signal_wrap
Signal
SignalWrap
SyncProcessStdioPipe
../src/spawn_sync.cc
readable || writable
~SyncProcessStdioPipe
lifecycle_ == kUninitialized || lifecycle_ == kClosed
(lifecycle_) == (kUninitialized)
(lifecycle_) == (kInitialized)
(input_buffer_.base) != (nullptr)
lifecycle_ == kInitialized || lifecycle_ == kStarted
spawn
~SyncProcessRunner
(lifecycle_) == (kHandlesClosed)
TryInitializeAndRunLoop
(uv_loop_init(uv_loop_)) == (0)
(exit_status_) >= (0)
CloseHandlesAndDeleteLoop
(lifecycle_) < (kHandlesClosed)
(uv_loop_close(uv_loop_)) == (0)
(false) == (stdio_pipes_initialized_)
(false) == (kill_timer_initialized_)
CloseStdioPipes
(stdio_pipes_) != (nullptr)
(uv_loop_) != (nullptr)
CloseKillTimer
(timeout_) > (0)
Kill
r >= 0 || r == UV_ESRCH
BuildOutputArray
(lifecycle_) >= (kInitialized)
ParseStdioOption
0 && "invalid child stdio type"
uv_pipe
(lifecycle_) < (kClosing)
SetError
(error) != (0)
OnRead
(buf->base) == (data_ + used())
AddStdioIgnore
(child_fd) < (stdio_count_)
(stdio_pipes_[child_fd]) == (nullptr)
AddStdioPipe
AddStdioInheritFD
spawn_sync
WriteUCS2
../src/string_bytes.cc
(reinterpret_cast<uintptr_t>(aligned_dst) % sizeof(*dst)) == (0)
Write
val->IsString() == true
0 && "unknown encoding"
StorageSize
str->Length() % 2 == 0 && "invalid hex string length"
Size
(encoding) != (UCS2)
(buflen) <= (Buffer::kMaxLength)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
0123456789abcdef
Shutdown
../src/stream_base.cc
AfterShutdown
Writev
(offset) <= (storage_size)
(count) == (1)
AfterWrite
WriteString
(data_size) <= (storage_size)
(false) == (req_wrap->persistent().IsEmpty())
ShutdownWrap
WriteWrap
setBlocking
OnAlloc
../src/stream_wrap.cc
(wrap->stream()) == (reinterpret_cast<uv_stream_t*>(handle))
node::StreamWrap::DoAlloc(size_t, uv_buf_t*, void*)
Out Of Memory
OnReadImpl
(static_cast<size_t>(nread)) <= (buf->len)
(pending) == (UV_UNKNOWN_HANDLE)
OnReadCommon
SetBlocking
(args.Length()) > (0)
NewShutdownWrap
NewWriteWrap
stream_wrap
../src/tcp_wrap.cc
(env->tcp_constructor_template().IsEmpty()) == (false)
(constructor.IsEmpty()) == (false)
(instance.IsEmpty()) == (false)
reading
bind6
connect6
getsockname
getpeername
setNoDelay
setKeepAlive
TCPConnectWrap
TCPWrap
~TCPWrap
(&tcp_wrap->handle_) == (reinterpret_cast<uv_tcp_t*>(handle))
(tcp_wrap->persistent().IsEmpty()) == (false)
Connect6
NewTCPConnectWrap
tcp_wrap
GetSockOrPeerName
../src/timer_wrap.cc
timer_wrap
Timer
kOnTimeout
TimerWrap
now >= env->timer_base()
HandleWrap::IsAlive(wrap)
getWindowSize
setRawMode
isTTY
guessHandleType
GuessHandleType
../src/tty_wrap.cc
(fd) >= (0)
FILE
PIPE
IsTTY
GetWindowSize
tty_wrap
../src/process_wrap.cc
process_wrap
options.uid should be a number
options.gid should be a number
Spawn
(options.args[i]) != (nullptr)
(options.env[i]) != (nullptr)
(wrap->process_.data) == (wrap)
OnExit
(wrap) != (nullptr)
(&wrap->process_) == (handle)
ParseStdioOptions
UDPWrap
../src/udp_wrap.cc
send
send6
recvStart
recvStop
addMembership
dropMembership
setMulticastTTL
setMulticastLoopback
setBroadcast
setTTL
SendWrap
DoBind
0 && "unexpected address family"
SetTTL
(args.Length()) == (1)
SetBroadcast
SetMulticastTTL
SetMulticastLoopback
SetMembership
(args.Length()) == (2)
DoSend
args[3]->IsUint32()
args[4]->IsUint32()
args[5]->IsString()
args[6]->IsBoolean()
(length) <= (Buffer::Length(buffer_obj) - offset)
node::UDPWrap::OnAlloc(uv_handle_t*, size_t, uv_buf_t*)
(env->udp_constructor_function().IsEmpty()) == (false)
NewSendWrap
udp_wrap
err >= 0
errname
UV_E2BIG
UV_EACCES
UV_EADDRINUSE
UV_EADDRNOTAVAIL
UV_EAFNOSUPPORT
UV_EAGAIN
UV_EAI_ADDRFAMILY
UV_EAI_AGAIN
UV_EAI_BADFLAGS
UV_EAI_BADHINTS
UV_EAI_CANCELED
UV_EAI_FAIL
UV_EAI_FAMILY
UV_EAI_MEMORY
UV_EAI_NODATA
UV_EAI_NONAME
UV_EAI_OVERFLOW
UV_EAI_PROTOCOL
UV_EAI_SERVICE
UV_EAI_SOCKTYPE
UV_EALREADY
UV_EBADF
UV_EBUSY
UV_ECANCELED
UV_ECHARSET
UV_ECONNABORTED
UV_ECONNREFUSED
UV_ECONNRESET
UV_EDESTADDRREQ
UV_EEXIST
UV_EFAULT
UV_EFBIG
UV_EHOSTUNREACH
UV_EINTR
UV_EINVAL
UV_EIO
UV_EISCONN
UV_EISDIR
UV_ELOOP
UV_EMFILE
UV_EMSGSIZE
UV_ENAMETOOLONG
UV_ENETDOWN
UV_ENETUNREACH
UV_ENFILE
UV_ENOBUFS
UV_ENODEV
UV_ENOENT
UV_ENOMEM
UV_ENONET
UV_ENOPROTOOPT
UV_ENOSPC
UV_ENOSYS
UV_ENOTCONN
UV_ENOTDIR
UV_ENOTEMPTY
UV_ENOTSOCK
UV_ENOTSUP
UV_EPERM
UV_EPIPE
UV_EPROTO
UV_EPROTONOSUPPORT
UV_EPROTOTYPE
UV_ERANGE
UV_EROFS
UV_ESHUTDOWN
UV_ESPIPE
UV_ESRCH
UV_ETIMEDOUT
UV_ETXTBSY
UV_EXDEV
UV_UNKNOWN
UV_EOF
UV_ENXIO
UV_EMLINK
UV_EHOSTDOWN
../src/uv.cc
SetLengthAndZeroTerminate
(length + 1) <= (length_)
Invalidate
(buf_) == (buf_st_)
SSLWrap
../src/node_crypto.h
(ssl_) != (nullptr)
SecureContext
setKey
setCert
addCACert
addCRL
addRootCerts
setCiphers
setECDHCurve
setDHParam
setOptions
setSessionIdContext
setSessionTimeout
loadPKCS12
getTicketKeys
setTicketKeys
setFreeListLength
enableTicketKeyCallback
getCertificate
getIssuer
kTicketKeyReturnIndex
kTicketKeyHMACIndex
kTicketKeyAESIndex
kTicketKeyNameIndex
kTicketKeyIVIndex
_external
SSLv2_method
SSLv2 methods disabled
SSLv2_server_method
SSLv2_client_method
SSLv3_method
SSLv3 methods disabled
SSLv3_server_method
SSLv3_client_method
SSLv23_method
SSLv23_server_method
SSLv23_client_method
TLSv1_method
TLSv1_server_method
TLSv1_client_method
TLSv1_1_method
TLSv1_1_server_method
TLSv1_1_client_method
TLSv1_2_method
TLSv1_2_server_method
TLSv1_2_client_method
Unknown method
Bad parameter
PEM_read_bio_PrivateKey
SSL_CTX_use_PrivateKey
SSL_CTX_use_certificate_chain
../src/node_crypto.cc
(*issuer) == (nullptr)
(*cert) == (nullptr)
AddRootCerts
(sc->ca_store_) == (nullptr)
First argument should be a string
First argument should be a valid curve name
DH parameter is less than 1024 bits
WARNING: DH parameter is less than 2048 bits
Error setting temp DH parameter
SSL_CTX_set_session_id_context error
Unable to load BIO
Not a buffer
Failed to fetch tls ticket keys
Bad argument
HandleSSLError
err == 1 || err == 5
ClearError
(error->BooleanValue()) == (false)
Connection
encIn
clearOut
clearIn
encOut
clearPending
encPending
start
getServername
setSNICallback
First argument must be a tls module SecureContext
Takes 3 parameters
Second argument should be a buffer
Must give a Function as first argument
onselect
initiv
update
final
setAutoPadding
getAuthTag
setAuthTag
setAAD
CipherBase
(args.IsConstructCall()) == (true)
(cipher_) == (nullptr)
Unknown cipher
Invalid key length
Must give cipher-type, key
Invalid IV length
Must give cipher-type, key, and iv as argument
GetAuthTag
(*out) != (nullptr)
Attempting to get auth tag in unsupported state
Argument must be a Buffer
Attempting to set auth tag in unsupported state
Attempting to set AAD in unsupported state
Not a string or buffer
Trying to add data in unsupported state
Update
out != nullptr || out_len == 0
Unsupported state or unable to authenticate data
Unsupported state
Hmac
HmacInit
(initialised_) == (false)
Unknown message digest
Must give hashtype string, key as arguments
HmacUpdate fail
Hash
Must give hashtype string as argument
Digest method not supported
HashInit
HashUpdate fail
Not initialized
Not initialised
EVP_SignInit_ex failed
EVP_SignUpdate failed
PEM_read_bio_PrivateKey failed
PEM_read_bio_PUBKEY failed
sign
Sign
SignInit
Must give signtype string as argument
verify
Verify
VerifyInit
Must give verifytype string as argument
VerifyFinal
(hwritten) == (hlen)
generateKeys
computeSecret
getPrime
getGenerator
getPublicKey
getPrivateKey
setPublicKey
setPrivateKey
DiffieHellman
DiffieHellmanGroup
No group name given
Initialization failed
Unknown group
Key generation failed
No public key - did you forget to generate one?
No private key - did you forget to generate one?
First argument must be other party's public key
Invalid Key
Supplied key is too small
Supplied key is too large
Invalid key
ComputeSecret
(size) >= (0)
dataSize > size
First argument must be public key
First argument must be private key
ECDH
Failed to create EC_KEY using curve name
Failed to generate EC_KEY
Failed to allocate EC_POINT for a public key
Failed to translate Buffer to a EC_POINT
(out) != (nullptr)
Failed to compute ECDH key
GetPublicKey
You should generate ECDH keys first
Failed to get ECDH public key
Failed to get public key length
Failed to get public key
Failed to get ECDH private key
GetPrivateKey
Failed to convert ECDH private key to Buffer
Failed to convert Buffer to BN
Failed to convert BN to a private key
EIO_PBKDF2After
(status) == (0)
Bad password
node::PBKDF2()
Out of Memory
Bad salt
Iterations not a number
Bad iterations
Key length not a number
Bad key length
Bad digest name
RandomBytesAfter
size must be a number >= 0
size is not a valid Smi
SSL_CTX_new() failed.
SSL_new() failed.
GetCurves
(curves) != (nullptr)
verifySpkac
exportPublicKey
exportChallenge
Certificate
Missing argument
VerifySpkac
ExportPublicKey
ExportChallenge
InitCryptoOnce
(sk_num(((_STACK*) (1 ? (comp_methods) : (struct stack_st_SSL_COMP*)0)))) == (0)
SetEngine
args.Length() >= 2 && args[0]->IsString()
Engine "%s" was not found
setEngine
PBKDF2
randomBytes
getSSLCiphers
getCiphers
getHashes
getCurves
publicEncrypt
privateDecrypt
privateEncrypt
publicDecrypt
getPeerCertificate
getSession
setSession
loadSession
isSessionReused
isInitFinished
verifyError
getCurrentCipher
endParser
certCbDone
renegotiate
shutdownSSL
getTLSTicket
newSessionDone
setOCSPResponse
requestOCSP
setMaxSendFragment
getNegotiatedProtocol
setNPNProtocols
SetSNIContext
(SSL_set_SSL_CTX(ssl_, sc->ctx_)) == (sc->ctx_)
http/1.1
TLSExtStatusCallback
CheckEntropy
(status) >= (0)
BaseObject
(false) == (handle.IsEmpty())
~BaseObject
handle_.IsEmpty()
MakeWeak
Wrap
-----BEGIN CERTIFICATE-----
MIIDdTCCAl2gAwIBAgILBAAAAAABFUtaw5QwDQYJKoZIhvcNAQEFBQAwVzELMAkGA1UEBhMC
QkUxGTAXBgNVBAoTEEdsb2JhbFNpZ24gbnYtc2ExEDAOBgNVBAsTB1Jvb3QgQ0ExGzAZBgNV
BAMTEkdsb2JhbFNpZ24gUm9vdCBDQTAeFw05ODA5MDExMjAwMDBaFw0yODAxMjgxMjAwMDBa
MFcxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMRAwDgYDVQQLEwdS
b290IENBMRswGQYDVQQDExJHbG9iYWxTaWduIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUA
A4IBDwAwggEKAoIBAQDaDuaZjc6j40+Kfvvxi4Mla+pIH/EqsLmVEQS98GPR4mdmzxzdzxtI
K+6NiY6arymAZavpxy0Sy6scTHAHoT0KMM0VjU/43dSMUBUc71DuxC73/OlS8pF94G3VNTCO
XkNz8kHp1Wrjsok6Vjk4bwY8iGlbKk3Fp1S4bInMm/k8yuX9ifUSPJJ4ltbcdG6TRGHRjcdG
snUOhugZitVtbNV4FpWi6cgKOOvyJBNPc1STE4U6G7weNLWLBYy5d4ux2x8gkasJU26Qzns3
dLlwR5EiUWMWea6xrkEmCMgZK9FGqkjWZCrXgzT/LCrBbBlDSgeF59N89iFo7+ryUp9/k5DP
AgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRg
e2YaRQ2XyolQL30EzTSo//z9SzANBgkqhkiG9w0BAQUFAAOCAQEA1nPnfE920I2/7LqivjTF
KDK1fPxsnCwrvQmeU79rXqoRSLblCKOzyj1hTdNGCbM+w6DjY1Ub8rrvrTnhQ7k4o+YviiY7
76BQVvnGCv04zcQLcFGUl5gE38NflNUVyRRBnMRddWQVDf9VMOyGj/8N7yy5Y0b2qvzfvGn9
LhJIZJrglfCm7ymPAbEVtQwdpf5pLGkkeB6zpxxxYu7KyJesF12KwvhHhm4qxFYxldBniYUr
+WymXUadDKqC5JlR3XC321Y9YeRq4VzW9v493kHMB65jUr9TU/Qr6cf9tveCX4XSQRjbgbME
HMUfpIBvFSDJ3gyICh3WZlXi/EjJKSZp4A==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4GA1UECxMX
R2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNpZ24xEzARBgNVBAMT
Ckdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1MDgwMDAwWjBMMSAwHgYDVQQL
ExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEGA1UEChMKR2xvYmFsU2lnbjETMBEGA1UE
AxMKR2xvYmFsU2lnbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8o
mUVCxKs+IVSbC9N/hHD6ErPLv4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7
SqbKSaZeqKeMWhG8eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQ
BoZfXklqtTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd
C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pazq+r1feq
CapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCBmTAOBgNVHQ8BAf8E
BAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IHV2ccHsBqBt5ZtJot39wZhi4w
NgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5nbG9iYWxzaWduLm5ldC9yb290LXIyLmNy
bDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEA
mYFThxxol4aR7OBKuEQLq4GsJ0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkI
k7mpM0sYmsL4h4hO291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRD
LenVOavSot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd
AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7TBj0/VLZ
jmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEGjCCAwICEQCbfgZJoz5iudXukEhxKe9XMA0GCSqGSIb3DQEBBQUAMIHKMQswCQYDVQQG
EwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRydXN0
IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlTaWduLCBJbmMuIC0gRm9yIGF1dGhv
cml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlTaWduIENsYXNzIDMgUHVibGljIFByaW1h
cnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHMzAeFw05OTEwMDEwMDAwMDBaFw0zNjA3
MTYyMzU5NTlaMIHKMQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAd
BgNVBAsTFlZlcmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAxOTk5IFZlcmlT
aWduLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxRTBDBgNVBAMTPFZlcmlTaWdu
IENsYXNzIDMgUHVibGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHMzCC
ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMu6nFL8eB8aHm8bN3O9+MlrlBIwT/A2
R/XQkQr1F8ilYcEWQE37imGQ5XYgwREGfassbqb1EUGO+i2tKmFZpGcmTNDovFJbcCAEWNF6
yaRpvIMXZK0Fi7zQWM6NjPXr8EJJC52XJ2cybuGukxUccLwgTS8Y3pKI6GyFVxEa6X7jJhFU
okWWVYPKMIno3Nij7SqAP395ZVc+FSBmCC+Vk7+qRy+oRpfwEuL+wgorUeZ25rdGt+INpsyo
w0xZVYnm6FNcHOqd8GIWC6fJXwzw3sJ2zq/3avL6QaaiMxTJ5Xpj055iN9WFZZ4O5lMkdBte
HRJTW8cs54NJOxWuimi5V5cCAwEAATANBgkqhkiG9w0BAQUFAAOCAQEAERSWwauSCPc/L8my
/uRan2Te2yFPhpk0djZX3dAVL8WtfxUfN2JzPtTnX84XA9s1+ivbrmAJXx5fj267Cz3qWhMe
DGBvtcC1IyIuBwvLqXTLR7sdwdela8wv0kL9Sd2nic9TutoAWii/gt/4uhMdUIaC/Y4wjylG
sB49Ndo4YhYYSq3mtlFs3q9i6wHQHiT+eo8SGhJouPtmmRQURVyu565pF4ErWjfJXir0xuKh
XFSbplQAz/DxwceYMBo7Nhbbo27q/a2ywtrvAkcTisDxszGtTxzhT5yvDwyd93gN2PQ1VoDa
t20Xj50egWTh/sVFuq1ruQp6Tk9LhO5L8X3dEQ==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEKjCCAxKgAwIBAgIEOGPe+DANBgkqhkiG9w0BAQUFADCBtDEUMBIGA1UEChMLRW50cnVz
dC5uZXQxQDA+BgNVBAsUN3d3dy5lbnRydXN0Lm5ldC9DUFNfMjA0OCBpbmNvcnAuIGJ5IHJl
Zi4gKGxpbWl0cyBsaWFiLikxJTAjBgNVBAsTHChjKSAxOTk5IEVudHJ1c3QubmV0IExpbWl0
ZWQxMzAxBgNVBAMTKkVudHJ1c3QubmV0IENlcnRpZmljYXRpb24gQXV0aG9yaXR5ICgyMDQ4
KTAeFw05OTEyMjQxNzUwNTFaFw0yOTA3MjQxNDE1MTJaMIG0MRQwEgYDVQQKEwtFbnRydXN0
Lm5ldDFAMD4GA1UECxQ3d3d3LmVudHJ1c3QubmV0L0NQU18yMDQ4IGluY29ycC4gYnkgcmVm
LiAobGltaXRzIGxpYWIuKTElMCMGA1UECxMcKGMpIDE5OTkgRW50cnVzdC5uZXQgTGltaXRl
ZDEzMDEGA1UEAxMqRW50cnVzdC5uZXQgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgKDIwNDgp
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArU1LqRKGsuqjIAcVFmQqK0vRvwtK
TY7tgHalZ7d4QMBzQshowNtTK91euHaYNZOLGp18EzoOH1u3Hs/lJBQesYGpjX24zGtLA/EC
DNyrpUAkAH90lKGdCCmziAv1h3edVc3kw37XamSrhRSGlVuXMlBvPci6Zgzj/L24ScF2iUkZ
/cCovYmjZy/Gn7xxGWC4LeksyZB2ZnuU4q941mVTXTzWnLLPKQP5L6RQstRIzgUyVYr9smRM
DuSYB3Xbf9+5CFVghTAp+XtIpGmG4zU/HoZdenoVve8AjhUiVBcAkCaTvA5JaJG/+EfTnZVC
wQ5N328mz8MYIWJmQ3DW1cAH4QIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/
BAUwAwEB/zAdBgNVHQ4EFgQUVeSB0RGAvtiJuQijMfmhJAkWuXAwDQYJKoZIhvcNAQEFBQAD
ggEBADubj1abMOdTmXx6eadNl9cZlZD7Bh/KM3xGY4+WZiT6QBshJ8rmcnPyT/4xmf3IDExo
U8aAghOY+rat2l098c5u9hURlIIM7j+VrxGrD9cv3h8Dj1csHsm7mhpElesYT6YfzX1XEC+b
BAlahLVu2B064dae0Wx5XnkcFMXj0EyTO2U87d89vqbllRrDtRnDvV5bu/8j72gZyxKTJ1wD
LW8w0B62GqzeWvfRqqgnpv55gcR5mTNXuhKwqeBCbJPKVt7+bYQLCIt+jerXmCHG8+c8eS9e
nNFMFY3h7CI3zJpDC5fcgJCNs2ebb0gIFVbPv/ErfF6adulZkMV8gzURZVE=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJJRTESMBAG
A1UEChMJQmFsdGltb3JlMRMwEQYDVQQLEwpDeWJlclRydXN0MSIwIAYDVQQDExlCYWx0aW1v
cmUgQ3liZXJUcnVzdCBSb290MB4XDTAwMDUxMjE4NDYwMFoXDTI1MDUxMjIzNTkwMFowWjEL
MAkGA1UEBhMCSUUxEjAQBgNVBAoTCUJhbHRpbW9yZTETMBEGA1UECxMKQ3liZXJUcnVzdDEi
MCAGA1UEAxMZQmFsdGltb3JlIEN5YmVyVHJ1c3QgUm9vdDCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAKMEuyKrmD1X6CZymrV51Cni4eiVgLGw41uOKymaZN+hXe2wCQVt2ygu
zmKiYv60iNoS6zjrIZ3AQSsBUnuId9Mcj8e6uYi1agnnc+gRQKfRzMpijS3ljwumUNKoUMMo
6vWrJYeKmpYcqWe4PwzV9/lSEy/CG9VwcPCPwBLKBsua4dnKM3p31vjsufFoREJIE9LAwqSu
XmD+tqYF/LTdB1kC1FkYmGP1pWPgkAx9XbIGevOF6uvUA65ehD5f/xXtabz5OTZydc93Uk3z
yZAsuT3lySNTPx8kmCFcB5kpvcY67Oduhjprl3RjM71oGDHweI12v/yejl0qhqdNkNwnGjkC
AwEAAaNFMEMwHQYDVR0OBBYEFOWdWTCCR1jMrPoIVDaGezq1BE3wMBIGA1UdEwEB/wQIMAYB
Af8CAQMwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBBQUAA4IBAQCFDF2O5G9RaEIFoN27
TyclhAO992T9Ldcw46QQF+vaKSm2eT929hkTI7gQCvlYpNRhcL0EYWoSihfVCr3FvDB81ukM
JY2GQE/szKN+OMY3EU/t3WgxjkzSswF07r51XgdIGn9w/xZchMB5hbgF/X++ZRGjD8ACtPhS
NzkE1akxehi/oCr0Epn3o0WC4zxe9Z2etciefC7IpJ5OCBRLbf1wbWsaY71k5h+3zvDyny67
G7fyUIhzksLi4xaNmjICq44Y3ekQEe5+NauQrz4wlHrQMz2nZQ/1/I6eYs9HRCwBXbsdtTLS
R9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmp
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEGDCCAwCgAwIBAgIBATANBgkqhkiG9w0BAQUFADBlMQswCQYDVQQGEwJTRTEUMBIGA1UE
ChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSEwHwYDVQQD
ExhBZGRUcnVzdCBDbGFzcyAxIENBIFJvb3QwHhcNMDAwNTMwMTAzODMxWhcNMjAwNTMwMTAz
ODMxWjBlMQswCQYDVQQGEwJTRTEUMBIGA1UEChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFk
ZFRydXN0IFRUUCBOZXR3b3JrMSEwHwYDVQQDExhBZGRUcnVzdCBDbGFzcyAxIENBIFJvb3Qw
ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCWltQhSWDia+hBBwzexODcEyPNwTXH
+9ZOEQpnXvUGW2ulCDtbKRY654eyNAbFvAWlA3yCyykQruGIgb3WntP+LVbBFc7jJp0VLhD7
Bo8wBN6ntGO0/7Gcrjyvd7ZWxbWroulpOj0OM3kyP3CCkplhbY0wCI9xP6ZIVxn4JdxLZlyl
dI+Yrsj5wAYi56xz36Uu+1LcsRVlIPo1Zmne3yzxbrww2ywkEtvrNTVokMsAsJchPXQhI2U0
K7t4WaPW4XY5mqRJjox0r26kmqPZm9I4XJuiGMx1I4S+6+JNM3GOGvDC+Mcdoq0Dlyz4zyXG
9rgkMbFjXZJ/Y/AlyVMuH79NAgMBAAGjgdIwgc8wHQYDVR0OBBYEFJWxtPCUtr3H2tERCSG+
wa9J/RB7MAsGA1UdDwQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MIGPBgNVHSMEgYcwgYSAFJWx
tPCUtr3H2tERCSG+wa9J/RB7oWmkZzBlMQswCQYDVQQGEwJTRTEUMBIGA1UEChMLQWRkVHJ1
c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSEwHwYDVQQDExhBZGRUcnVz
dCBDbGFzcyAxIENBIFJvb3SCAQEwDQYJKoZIhvcNAQEFBQADggEBACxtZBsfzQ3duQH6lmM0
MkhHma6X7f1yFqZzR1r0693p9db7RcwpiURdv0Y5PejuvE1Uhh4dbOMXJ0PhiVYrqW9yTkkz
43J8KiOavD7/KCrto/8cI7pDVwlnTUtiBi34/2ydYB7YHEt9tTEv2dB8Xfjea4MYeDdXL+gz
B2ffHsdrKpV2ro9Xo/D0UrSpUwjP4E/TelOL/bscVjby/rK25Xa71SJlpz/+0WatC7xrmYbv
P33zGDLKe8bjq2RGlfgmadlVg3sslgf/WSxEo8bl6ancoWOAWiFeIc9TVPC6b4nbqKqVz4vj
ccweGyBECMB6tkD9xOQ14R0WHNC8K47Wcdk=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIENjCCAx6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBvMQswCQYDVQQGEwJTRTEUMBIGA1UE
ChMLQWRkVHJ1c3QgQUIxJjAkBgNVBAsTHUFkZFRydXN0IEV4dGVybmFsIFRUUCBOZXR3b3Jr
MSIwIAYDVQQDExlBZGRUcnVzdCBFeHRlcm5hbCBDQSBSb290MB4XDTAwMDUzMDEwNDgzOFoX
DTIwMDUzMDEwNDgzOFowbzELMAkGA1UEBhMCU0UxFDASBgNVBAoTC0FkZFRydXN0IEFCMSYw
JAYDVQQLEx1BZGRUcnVzdCBFeHRlcm5hbCBUVFAgTmV0d29yazEiMCAGA1UEAxMZQWRkVHJ1
c3QgRXh0ZXJuYWwgQ0EgUm9vdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALf3
GjPm8gAELTngTlvtH7xsD821+iO2zt6bETOXpClMfZOfvUq8k+0DGuOPz+VtUFrWlymUWoCw
SXrbLpX9uMq/NzgtHj6RQa1wVsfwTz/oMp50ysiQVOnGXw94nZpAPA6sYapeFI+eh6FqUNzX
mk6vBbOmcZSccbNQYArHE504B4YCqOmoaSYYkKtMsE8jqzpPhNjfzp/haW+710LXa0Tkx63u
bUFfclpxCDezeWWkWaCUN/cALw3CknLa0Dhy2xSoRcRdKn23tNbE7qzNE0S3ySvdQwAl+mG5
aWpYIxG3pzOPVnVZ9c0p10a3CitlttNCbxWyuHv77+ldU9U0WicCAwEAAaOB3DCB2TAdBgNV
HQ4EFgQUrb2YejS0Jvf6xCZU7wO94CTLVBowCwYDVR0PBAQDAgEGMA8GA1UdEwEB/wQFMAMB
Af8wgZkGA1UdIwSBkTCBjoAUrb2YejS0Jvf6xCZU7wO94CTLVBqhc6RxMG8xCzAJBgNVBAYT
AlNFMRQwEgYDVQQKEwtBZGRUcnVzdCBBQjEmMCQGA1UECxMdQWRkVHJ1c3QgRXh0ZXJuYWwg
VFRQIE5ldHdvcmsxIjAgBgNVBAMTGUFkZFRydXN0IEV4dGVybmFsIENBIFJvb3SCAQEwDQYJ
KoZIhvcNAQEFBQADggEBALCb4IUlwtYj4g+WBpKdQZic2YR5gdkeWxQHIzZlj7DYd7usQWxH
YINRsPkyPef89iYTx4AWpb9a/IfPeHmJIZriTAcKhjW88t5RxNKWt9x+Tu5w/Rw56wwCURQt
jr0W4MHfRnXnJK3s9EK0hZNwEGe6nQY1ShjTK3rMUUKhemPR5ruhxSvCNr4TDea9Y355e6cJ
DUCrat2PisP29owaQgVR1EX1n6diIWgVIEM8med8vSTYqZEXc4g/VhsxOBi0cQ+azcgOno4u
G+GMmIPLHzHxREzGBHNJdmAPx/i9F4BrLunMTA5amnkPIAou1Z5jJh5VkpTYghdae9C8x49O
hgQ=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEFTCCAv2gAwIBAgIBATANBgkqhkiG9w0BAQUFADBkMQswCQYDVQQGEwJTRTEUMBIGA1UE
ChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSAwHgYDVQQD
ExdBZGRUcnVzdCBQdWJsaWMgQ0EgUm9vdDAeFw0wMDA1MzAxMDQxNTBaFw0yMDA1MzAxMDQx
NTBaMGQxCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRUcnVzdCBBQjEdMBsGA1UECxMUQWRk
VHJ1c3QgVFRQIE5ldHdvcmsxIDAeBgNVBAMTF0FkZFRydXN0IFB1YmxpYyBDQSBSb290MIIB
IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6Rowj4OIFMEg2Dybjxt+A3S72mnTRqX4
jsIMEZBRpS9mVEBV6tsfSlbunyNu9DnLoblv8n75XYcmYZ4c+OLspoH4IcUkzBEMP9smcnrH
AZcHF/nXGCwwfQ56HmIexkvA/X1id9NEHif2P0tEs7c42TkfYNVRknMDtABp4/MUTu7R3AnP
dzRGULD4EfL+OHn3Bzn+UZKXC1sIXzSGAa2Il+tmzV7R/9x98oTaunet3IAIx6eH1lWfl2ro
yBFkuucZKT8Rs3iQhCBSWxHveNCD9tVIkNAwHM+A+WD+eeSI8t0A65RF62WUaUC6wNW0uLp9
BBGo6zEFlpROWCGOn9Bg/QIDAQABo4HRMIHOMB0GA1UdDgQWBBSBPjfYkrAfd59ctKtzquf2
NGAv+jALBgNVHQ8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zCBjgYDVR0jBIGGMIGDgBSBPjfY
krAfd59ctKtzquf2NGAv+qFopGYwZDELMAkGA1UEBhMCU0UxFDASBgNVBAoTC0FkZFRydXN0
IEFCMR0wGwYDVQQLExRBZGRUcnVzdCBUVFAgTmV0d29yazEgMB4GA1UEAxMXQWRkVHJ1c3Qg
UHVibGljIENBIFJvb3SCAQEwDQYJKoZIhvcNAQEFBQADggEBAAP3FUr4JNojVhaTdt02KLmu
G7jD8WS6IBh4lSknVwW8fCr0uVFV2ocC3g8WFzH4qnkuCRO7r7IgGRLlk/lL+YPoRNWyQSW/
iHVv/xD8SlTQX/D67zZzfRs2RcYhbbQVuE7PnFylPVoAjgbjPGsye/Kf8Lb93/AoGEjwxrzQ
vzSAlsJKsW2Ox5BF3i9nrEUEo3rcVZLJR2bYGozH7ZxOmuASu7VqTITh4SINhwBk/ox9Yjll
pu9CtoAlEmEBqCQTcAARJl/6NVDFSMwGR+gn2HCNX2TmoUQmXiLsks3/QppEIW1cxeMiHV9H
EufOX1362KqxMy3ZdvJOOjMMK7MtkAY=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEHjCCAwagAwIBAgIBATANBgkqhkiG9w0BAQUFADBnMQswCQYDVQQGEwJTRTEUMBIGA1UE
ChMLQWRkVHJ1c3QgQUIxHTAbBgNVBAsTFEFkZFRydXN0IFRUUCBOZXR3b3JrMSMwIQYDVQQD
ExpBZGRUcnVzdCBRdWFsaWZpZWQgQ0EgUm9vdDAeFw0wMDA1MzAxMDQ0NTBaFw0yMDA1MzAx
MDQ0NTBaMGcxCzAJBgNVBAYTAlNFMRQwEgYDVQQKEwtBZGRUcnVzdCBBQjEdMBsGA1UECxMU
QWRkVHJ1c3QgVFRQIE5ldHdvcmsxIzAhBgNVBAMTGkFkZFRydXN0IFF1YWxpZmllZCBDQSBS
b290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5B6a/twJWoekn0e+EV+vhDTb
Yjx5eLfpMLXsDBwqxBb/4Oxx64r1EW7tTw2R0hIYLUkVAcKkIhPHEWT/IhKauY5cLwjPcWqz
ZwFZ8V1G87B4pfYOQnrjfxvM0PC3KP0q6p6zsLkEqv32x7SxuCqg+1jxGaBvcCV+PmlKfw8i
2O+tCBGaKZnhqkRFmhJePp1tUvznoD1oL/BLcHwTOK28FSXx1s6rosAx1i+f4P8UWfyEk9mH
fExUE+uf0S0R+Bg6Ot4l2ffTQO2kBhLEO+GRwVY18BTcZTYJbqukB8c10cIDMzZbdSZtQvES
a0NvS3GU+jQd7RNuyoB/mC9suWXY6QIDAQABo4HUMIHRMB0GA1UdDgQWBBQ5lYtii1zJ1IC6
WA+XPxUIQ8yYpzALBgNVHQ8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zCBkQYDVR0jBIGJMIGG
gBQ5lYtii1zJ1IC6WA+XPxUIQ8yYp6FrpGkwZzELMAkGA1UEBhMCU0UxFDASBgNVBAoTC0Fk
ZFRydXN0IEFCMR0wGwYDVQQLExRBZGRUcnVzdCBUVFAgTmV0d29yazEjMCEGA1UEAxMaQWRk
VHJ1c3QgUXVhbGlmaWVkIENBIFJvb3SCAQEwDQYJKoZIhvcNAQEFBQADggEBABmrder4i2Vh
lRO6aQTvhsoToMeqT2QbPxj2qC0sVY8FtzDqQmodwCVRLae/DLPt7wh/bDxGGuoYQ992zPlm
hpwsaPXpF/gxsxjE1kh9I0xowX67ARRvxdlu3rsEQmr49lx95dr6h+sNNVJn0J6XdgWTP5XH
AeZpVTh/EGGZyeNfpso+gmNIquIISD6q8rKFYqa0p9m9N5xotS1WfbC3P6CxB9bpT9zeRXEw
Mn8bLgn5v1Kh7sKAPgZcLlVAwRv1cEWw3F369nJad9Jjzc9YiQBCYz95OdBEsIJuQRno3eDB
iFrRHnGTHyQwdOUeqN48Jzd/g66ed8/wMLH/S5noxqE=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEkTCCA3mgAwIBAgIERWtQVDANBgkqhkiG9w0BAQUFADCBsDELMAkGA1UEBhMCVVMxFjAU
BgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsTMHd3dy5lbnRydXN0Lm5ldC9DUFMgaXMg
aW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5jZTEfMB0GA1UECxMWKGMpIDIwMDYgRW50cnVzdCwg
SW5jLjEtMCsGA1UEAxMkRW50cnVzdCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4X
DTA2MTEyNzIwMjM0MloXDTI2MTEyNzIwNTM0MlowgbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQK
Ew1FbnRydXN0LCBJbmMuMTkwNwYDVQQLEzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29y
cG9yYXRlZCBieSByZWZlcmVuY2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4x
LTArBgNVBAMTJEVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBALaVtkNC+sZtKm9I35RMOVcF7sN5EUFoNu3s/poB
j6E4KPz3EEZmLk0eGrEaTsbRwJWIsMn/MYszA9u3g3s+IIRe7bJWKKf44LlAcTfFy0cOlypo
wCKVYhXbR9n10Cv/gkvJrT7eTNuQgFA/CYqEAOwwCj0Yzfv9KlmaI5UXLEWeH25DeW0MXJj+
SKfFI0dcXv1u5x609mhF0YaDW6KKjbHjKYD+JXGIrb68j6xSlkuqUY3kEzEZ6E5Nn9uss2rV
vDlUccp6en+Q3X0dgNmBu1kmwhH+5pPi94DkZfs0Nw4pgHBNrziGLp5/V6+eF67rHMsoIV+2
HNjnogQi+dPa2MsCAwEAAaOBsDCBrTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB
/zArBgNVHRAEJDAigA8yMDA2MTEyNzIwMjM0MlqBDzIwMjYxMTI3MjA1MzQyWjAfBgNVHSME
GDAWgBRokORnpKZTgMeGZqTx90tD+4S9bTAdBgNVHQ4EFgQUaJDkZ6SmU4DHhmak8fdLQ/uE
vW0wHQYJKoZIhvZ9B0EABBAwDhsIVjcuMTo0LjADAgSQMA0GCSqGSIb3DQEBBQUAA4IBAQCT
1DCw1wMgKtD5Y+iRDAUgqV8ZyntyTtSx29CW+1RaGSwMCPeyvIWonX9tO1KzKtvn1ISMY/YP
yyYBkVBs9F8U4pN0wBOeMDpQ47RgxRzwIkSNcUesyBrJ6ZuaAGAT/3B+XxFNSRuzFVJ7yVTa
v52Vr2ua2J7p8eRDjeIRRDq/r72DQnNSi6q7pynP9WQcCk3RvKqsnyrQ/39/2n3qse0wJcGE
2jTSW3iDVuycNsMm4hH2Z0kdkquM++v/eu6FSqdQgPCnXEqULl8FmTxSQeDNtGPPAUO6nIPc
j2A781q0tHuu2guQOHXvgR1m0vdXcDazv/wor3ElhVsT/h5/WrQ8
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDYTCCAkmgAwIBAgIQCgEBAQAAAnwAAAAKAAAAAjANBgkqhkiG9w0BAQUFADA6MRkwFwYD
VQQKExBSU0EgU2VjdXJpdHkgSW5jMR0wGwYDVQQLExRSU0EgU2VjdXJpdHkgMjA0OCBWMzAe
Fw0wMTAyMjIyMDM5MjNaFw0yNjAyMjIyMDM5MjNaMDoxGTAXBgNVBAoTEFJTQSBTZWN1cml0
eSBJbmMxHTAbBgNVBAsTFFJTQSBTZWN1cml0eSAyMDQ4IFYzMIIBIjANBgkqhkiG9w0BAQEF
AAOCAQ8AMIIBCgKCAQEAt49VcdKA3XtpeafwGFAyPGJn9gqVB93mG/Oe2dJBVGutn3y+Gc37
RqtBaB4Y6lXIL5F4iSj7Jylg/9+PjDvJSZu1pJTOAeo+tWN7fyb9Gd3AIb2E0S1PRsNO3Ng3
OTsor8udGuorryGlwSMiuLgbWhOHV4PR8CDn6E8jQrAApX2J6elhc5SYcSa8LWrg903w8bYq
ODGBDSnhAMFRD0xS+ARaqn1y07iHKrtjEAMqs6FPDVpeRrc9DvV07Jmf+T0kgYim3WBU6JU2
PcYJk5qjEoAAVZkZR73QpXzDuvsf9/UP+Ky5tfQ3mBMY3oVbtwyCO4dvlTlYMNpuAWgXIszA
CwIDAQABo2MwYTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAfBgNVHSMEGDAW
gBQHw1EwpKrpRa41JPr/JCwz0LGdjDAdBgNVHQ4EFgQUB8NRMKSq6UWuNST6/yQsM9CxnYww
DQYJKoZIhvcNAQEFBQADggEBAF8+hnZuuDU8TjYcHnmYv/3VEhF5Ug7uMYm83X/50cYVIeiK
AVQNOvtUudZj1LGqlk2iQk3UUx+LEN5/Zb5gEydxiKRz44Rj0aRV4VCT5hsOedBnvEbIvz8X
DZXmxpBp3ue0L96VfdASPz0+f00/FGj1EVDVwfSQpQgdMWD/YIwjVAqv/qFuxdF6Kmh4zx6C
CiC0H63lhbJqaHVOrSU3lIW+vaHU6rcMSzyd6BIA8F+sDeGscGNz9395nzIlQnQFgCi/vcEk
llgVsRch6YlL2weIZ/QVrXA+L02FO8K32/6YaCOJ4XQP3vTFhGMpG8zLB8kApKnXwiJPZ9d3
7CAFYd4=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDVDCCAjygAwIBAgIDAjRWMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVTMRYwFAYD
VQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9iYWwgQ0EwHhcNMDIw
NTIxMDQwMDAwWhcNMjIwNTIxMDQwMDAwWjBCMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2Vv
VHJ1c3QgSW5jLjEbMBkGA1UEAxMSR2VvVHJ1c3QgR2xvYmFsIENBMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEA2swYYzD99BcjGlZ+W988bDjkcbd4kdS8odhM+KhDtgPpTSEH
CIjaWC9mOSm9BXiLnTjoBbdqfnGk5sRgprDvgOSJKA+eJdbtg/OtppHHmMlCGDUUna2YRpIu
T8rxh0PBFpVXLVDviS2Aelet8u5fa9IAjbkU+BQVNdnARqN7csiRv8lVK83Qlz6cJmTM386D
GXHKTubU1XupGc1V3sjs0l44U+VcT4wt/lAjNvxm5suOpDkZALeVAjmRCw7+OC7RHQWa9k0+
bw8HHa8sHo9gOeL6NlMTOdReJivbPagUvTLrGAMoUgRx5aszPeE4uwc2hGKceeoWMPRfwCvo
cWvk+QIDAQABo1MwUTAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTAephojYn7qwVkDBF9
qn1luMrMTjAfBgNVHSMEGDAWgBTAephojYn7qwVkDBF9qn1luMrMTjANBgkqhkiG9w0BAQUF
AAOCAQEANeMpauUvXVSOKVCUn5kaFOSPeCpilKInZ57QzxpeR+nBsqTP3UEaBU6bS+5Kb1VS
syShNwrrZHYqLizz/Tt1kL/6cdjHPTfStQWVYrmm3ok9Nns4d0iXrKYgjy6myQzCsplFAMfO
EVEiIuCl6rYVSAlk6l5PdPcFPseKUgzbFbS9bZvlxrFUaKnjaZC2mqUPuLk/IH2uSrW4nOQd
tqvmlKXBx4Ot2/Unhw4EbNX/3aBd7YdStysVAq45pmp06drE57xNNB6pXE0zX5IJL4hmXXeX
xx12E6nV5fEWCRE11azbJHFwLJhWC9kXtNHjUStedejV0NxPNO3CBWaAocvmMw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDZjCCAk6gAwIBAgIBATANBgkqhkiG9w0BAQUFADBEMQswCQYDVQQGEwJVUzEWMBQGA1UE
ChMNR2VvVHJ1c3QgSW5jLjEdMBsGA1UEAxMUR2VvVHJ1c3QgR2xvYmFsIENBIDIwHhcNMDQw
MzA0MDUwMDAwWhcNMTkwMzA0MDUwMDAwWjBEMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNR2Vv
VHJ1c3QgSW5jLjEdMBsGA1UEAxMUR2VvVHJ1c3QgR2xvYmFsIENBIDIwggEiMA0GCSqGSIb3
DQEBAQUAA4IBDwAwggEKAoIBAQDvPE1APRDfO1MA4Wf+lGAVPoWI8YkNkMgoI5kF6Csgncbz
YEbYwbLVjDHZ3CB5JIG/NTL8Y2nbsSpr7iFY8gjpeMtvy/wWUsiRxP89c96xPqfCfWbB9X5S
JBri1WeR0IIQ13hLTytCOb1kLUCgsBDTOEhGiKEMuzozKmKY+wCdE1l/bztyqu6mD4b5BWHq
Z38MN5aL5mkWRxHCJ1kDs6ZgwiFAVvqgx306E+PsV8ez1q6diYD3Aecs9pYrEw15LNnA5IZ7
S4wMcoKK+xfNAGw6EzywhIdLFnopsk/bHdQL82Y3vdj2V7teJHq4PIu5+pIaGoSe2HSPqht/
XvT+RSIhAgMBAAGjYzBhMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFHE4NvICMVNHK266
ZUapEBVYIAUJMB8GA1UdIwQYMBaAFHE4NvICMVNHK266ZUapEBVYIAUJMA4GA1UdDwEB/wQE
AwIBhjANBgkqhkiG9w0BAQUFAAOCAQEAA/e1K6tdEPx7srJerJsOflN4WT5CBP51o62sgU7X
AotexC3IUnbHLB/8gTKY0UvGkpMzNTEv/NgdRN3ggX+d6YvhZJFiCzkIjKx0nVnZellSlxG5
FntvRdOW2TF9AjYPnDtuzywNA0ZF66D0f0hExghAzN4bcLUprbqLOzRldRtxIR0sFAqwlpW4
1uryZfspuk/qkZN0abby/+Ea0AzRdoXLiiW9l14sbxWZJue2Kf8i7MkCx1YAzUm5s2x7UwQa
4qjJqhIFI8LO57sEAszAR6LkxCkvW0VXiVHuPOtSCP8HNR6fNWpHSlaY0VqFH4z1Ir+rzoPz
4iIprn2DQKi6bA==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFaDCCA1CgAwIBAgIBATANBgkqhkiG9w0BAQUFADBFMQswCQYDVQQGEwJVUzEWMBQGA1UE
ChMNR2VvVHJ1c3QgSW5jLjEeMBwGA1UEAxMVR2VvVHJ1c3QgVW5pdmVyc2FsIENBMB4XDTA0
MDMwNDA1MDAwMFoXDTI5MDMwNDA1MDAwMFowRTELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUdl
b1RydXN0IEluYy4xHjAcBgNVBAMTFUdlb1RydXN0IFVuaXZlcnNhbCBDQTCCAiIwDQYJKoZI
hvcNAQEBBQADggIPADCCAgoCggIBAKYVVaCjxuAfjJ0hUNfBvitbtaSeodlyWL0AG0y/YckU
HUWCq8YdgNY96xCcOq9tJPi8cQGeBvV8Xx7BDlXKg5pZMK4ZyzBIle0iN430SppyZj6tlcDg
FgDgEB8rMQ7XlFTTQjOgNB0eRXbdT8oYN+yFFXoZCPzVx5zw8qkuEKmS5j1YPakWaDwvdSEY
fyh3peFhF7em6fgemdtzbvQKoiFs7tqqhZJmr/Z6a4LauiIINQ/PQvE1+mrufislzDoR5G2v
c7J2Ha3QsnhnGqQ5HFELZ1aD/ThdDc7d8Lsrlh/eezJS/R27tQahsiFepdaVaH/wmZ7cRQg+
59IJDTWU3YBOU5fXtQlEIGQWFwMCTFMNaN7VqnJNk22CDtucvc+081xdVHppCZbW2xHBjXWo
tM85yM48vCR85mLK4b19p71XZQvk/iXttmkQ3CgaRr0BHdCXteGYO8A3ZNY9lO4L4fUorgtW
v3GLIylBjobFS1J72HGrH4oVpjuDWtdYAVHGTEHZf9hBZ3KiKN9gg6meyHv8U3NyWfWTehd2
Ds735VzZC1U0oqpbtWpU5xPKV+yXbfReBi9Fi1jUIxaS5BZuKGNZMN9QAZxjiRqf2xeUgnA3
wySemkfWWspOqGmJch+RbNt+nhutxx9z3SxPGWX9f5NAEC7S8O08ni4oPmkmM8V7AgMBAAGj
YzBhMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFNq7LqqwDLiIJlF0XG0D08DYj3rWMB8G
A1UdIwQYMBaAFNq7LqqwDLiIJlF0XG0D08DYj3rWMA4GA1UdDwEB/wQEAwIBhjANBgkqhkiG
9w0BAQUFAAOCAgEAMXjmx7XfuJRAyXHEqDXsRh3ChfMoWIawC/yOsjmPRFWrZIRcaanQmjg8
+uUfNeVE44B5lGiku8SfPeE0zTBGi1QrlaXv9z+ZhP015s8xxtxqv6fXIwjhmF7DWgh2qaav
dy+3YL1ERmrvl/9zlcGO6JP7/TG37FcREUWbMPEaiDnBTzynANXH/KttgCJwpQzgXQQpAvvL
oJHRfNbDflDVnVi+QTjruXU8FdmbyUqDWcDaU/0zuzYYm4UPFd3uLax2k7nZAY1IEKj79TiG
8dsKxr2EoyNB3tZ3b4XUhRxQ4K5RirqNPnbiucon8l+f725ZDQbYKxek0nxru18UGkiPGkzn
s0ccjkxFKyDuSN/n3QmOGKjaQI2SJhFTYXNd673nxE0pN2HrrDktZy4W1vUAg4WhzH92xH3k
t0tm7wNFYGm2DFKWkoRepqO1pD4r2czYG0eq8kTaT/kD6PAUyz/zg97QwVTjt+gKN02LIFkD
MBmhLMi9ER/frslKxfMnZmaGrGiR/9nmUxwPi1xpZQomyB40w11Re9epnAahNt3ViZS82eQt
DF4JbAiXfKM9fJP/P6EUp8+1Xevb2xzEdt+Iub1FBZUbrvxGakyvSOPOrg/SfuvmbJxPgWp6
ZKy7PtXny3YuxadIwVyQD8vIP/rmMuGNG2+k5o7Y+SlIis5z/iw=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFbDCCA1SgAwIBAgIBATANBgkqhkiG9w0BAQUFADBHMQswCQYDVQQGEwJVUzEWMBQGA1UE
ChMNR2VvVHJ1c3QgSW5jLjEgMB4GA1UEAxMXR2VvVHJ1c3QgVW5pdmVyc2FsIENBIDIwHhcN
MDQwMzA0MDUwMDAwWhcNMjkwMzA0MDUwMDAwWjBHMQswCQYDVQQGEwJVUzEWMBQGA1UEChMN
R2VvVHJ1c3QgSW5jLjEgMB4GA1UEAxMXR2VvVHJ1c3QgVW5pdmVyc2FsIENBIDIwggIiMA0G
CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCzVFLByT7y2dyxUxpZKeexw0Uo5dfR7cXFS6Gq
dHtXr0om/Nj1XqduGdt0DE81WzILAePb63p3NeqqWuDW6KFXlPCQo3RWlEQwAx5cTiuFJnSC
egx2oG9NzkEtoBUGFF+3Qs17j1hhNNwqCPkuwwGmIkQcTAeC5lvO0Ep8BNMZcyfwqph/Lq9O
64ceJHdqXbboW0W63MOhBW9Wjo8QJqVJwy7XQYci4E+GymC16qFjwAGXEHm9ADwSbSsVsaxL
se4YuU6W3Nx2/zu+z18DwPw76L5GG//aQMJS9/7jOvdqdzXQ2o3rXhhqMcceujwbKNZrVMaq
W9eiLBsZzKIC9ptZvTdrhrVtgrrY6slWvKk2WP0+GfPtDCapkzj4T8FdIgbQl+rhrcZV4IEr
KIM6+vR7IVEAvlI4zs1meaj0gVbi0IMJR1FbUGrP20gaXT73y/Zl92zxlfgCOzJWgjl6W70v
iRu/obTo/3+NjN8D8WBOWBFM66M/ECuDmgFz2ZRthAAnZqzwcEAJQpKtT5MNYQlRJNiS1QuU
YbKHsu3/mjX/hVTK7URDrBs8FmtISgocQIgfksILAAX/8sgCSqSqqcyZlpwvWOB94b67B9xf
BHJcMTTD7F8t4D1kkCLm0ey4Lt1ZrtmhN79UNdxzMk+MBB4zsslG8dhcyFVQyWi9qLo2CQID
AQABo2MwYTAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBR281Xh+qQ2+/CfXGJx7Tz0RzgQ
KzAfBgNVHSMEGDAWgBR281Xh+qQ2+/CfXGJx7Tz0RzgQKzAOBgNVHQ8BAf8EBAMCAYYwDQYJ
KoZIhvcNAQEFBQADggIBAGbBxiPz2eAubl/oz66wsCVNK/g7WJtAJDday6sWSf+zdXkzoS9t
cBc0kf5nfo/sm+VegqlVHy/c1FEHEv6sFj4sNcZj/NwQ6w2jqtB8zNHQL1EuxBRa3ugZ4T7G
zKQp5y6EqgYweHZUcyiYWTjgAA1i00J9IZ+uPTqM1fp3DRgrFg5fNuH8KrUwJM/gYwx7WBr+
mbpCErGR9Hxo4sjoryzqyX6uuyo9DRXcNJW2GHSoag/HtPQTxORb7QrSpJdMKu0vbBKJPfEn
cKpqA1Ihn0CoZ1Dy81of398j9tx4TuaYT1U6U+Pv8vSfx3zYWK8pIpe44L2RLrB27FcRz+8p
RPPphXpgY+RdM4kX2TGq2tbzGDVyz4crL2MjhF2EjD9XoIj8mZEoJmmZ1I+XRL6O1UixpCgp
8RW04eWe3fiPpm8m1wk8OhwRDqZsN/etRIcsKMfYdIKz0G9KV7s1KSegi+ghp4dkNl3M2Bas
x7InQJJVOCiNUW7dFGdTbHFcJoRNdVq2fmBWqU2t+5sel/MN2dKXVHfaPRK34B7vCAas+YWH
6aLcr34YEoP9VhdBLtUpgn2Z9DH2canPLAEnpQW5qrJITirvn5NSUZU8UnOOVkwXQMAJKOSL
akhT2+zNVVXxxvjpoixMptEmX36vWkzaH6byHCx+rgIW0lbQL1dTR+iS
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDojCCAoqgAwIBAgIQE4Y1TR0/BvLB+WUF1ZAcYjANBgkqhkiG9w0BAQUFADBrMQswCQYD
VQQGEwJVUzENMAsGA1UEChMEVklTQTEvMC0GA1UECxMmVmlzYSBJbnRlcm5hdGlvbmFsIFNl
cnZpY2UgQXNzb2NpYXRpb24xHDAaBgNVBAMTE1Zpc2EgZUNvbW1lcmNlIFJvb3QwHhcNMDIw
NjI2MDIxODM2WhcNMjIwNjI0MDAxNjEyWjBrMQswCQYDVQQGEwJVUzENMAsGA1UEChMEVklT
QTEvMC0GA1UECxMmVmlzYSBJbnRlcm5hdGlvbmFsIFNlcnZpY2UgQXNzb2NpYXRpb24xHDAa
BgNVBAMTE1Zpc2EgZUNvbW1lcmNlIFJvb3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK
AoIBAQCvV95WHm6h2mCxlCfLF9sHP4CFT8icttD0b0/Pmdjh28JIXDqsOTPHH2qLJj0rNfVI
sZHBAk4ElpF7sDPwsRROEW+1QK8bRaVK7362rPKgH1g/EkZgPI2h4H3PVz4zHvtH8aoVlwdV
ZqW1LS7YgFmypw23RuwhY/81q6UCzyr0TP579ZRdhE2o8mCP2w4lPJ9zcc+U30rq299yOIzz
lr3xF7zSujtFWsan9sYXiwGd/BmoKoMWuDpI/k4+oKsGGelT84ATB+0tvz8KPFUgOSwsAGl0
lUq8ILKpeeUYiZGo3BxN77t+Nwtd/jmliFKMAGzsGHxBvfaLdXe6YJ2E5/4tAgMBAAGjQjBA
MA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBQVOIMPPyw/cDMe
zUb+B4wg4NfDtzANBgkqhkiG9w0BAQUFAAOCAQEAX/FBfXxcCLkr4NWSR/pnXKUTwwMhmytM
iUbPWU3J/qVAtmPN3XEolWcRzCSs00Rsca4BIGsDoo8Ytyk6feUWYFN4PMCvFYP3j1IzJL1k
k5fui/fbGKhtcbP3LBfQdCVp9/5rPJS+TUtBjE7ic9DjkCJzQ83z7+pzzkWKsKZJ/0x9nXGI
xHYdkFsd7v3M9+79YKWxehZx0RbQfBI8bGmX265fOZpwLwU8GUYEmSA20GBuYQa7FkKMcPcw
++DbZqMAAb3mLNqRX6BGi01qnD093QVG/na/oAo85ADmJ7f/hC3euiInlhBx6yLt398znM/j
ra6O1I7mT1GvFpLgXPYHDw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDDDCCAfSgAwIBAgIDAQAgMA0GCSqGSIb3DQEBBQUAMD4xCzAJBgNVBAYTAlBMMRswGQYD
VQQKExJVbml6ZXRvIFNwLiB6IG8uby4xEjAQBgNVBAMTCUNlcnR1bSBDQTAeFw0wMjA2MTEx
MDQ2MzlaFw0yNzA2MTExMDQ2MzlaMD4xCzAJBgNVBAYTAlBMMRswGQYDVQQKExJVbml6ZXRv
IFNwLiB6IG8uby4xEjAQBgNVBAMTCUNlcnR1bSBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP
ADCCAQoCggEBAM6xwS7TT3zNJc4YPk/EjG+AanPIW1H4m9LcuwBcsaD8dQPugfCI7iNS6eYV
M42sLQnFdvkrOYCJ5JdLkKWoePhzQ3ukYbDYWMzhbGZ+nPMJXlVjhNWo7/OxLjBos8Q82Kxu
jZlakE403Daaj4GIULdtlkIJ89eVgw1BS7Bqa/j8D35in2fE7SZfECYPCE/wpFcozo+47UX2
bu4lXapuOb7kky/ZR6By6/qmW6/KUz/iDsaWVhFu9+lmqSbYf5VT7QqFiLpPKaVCjF62/IUg
AKpoC6EahQGcxEZjgoi2IrHu/qpGWX7PNSzVttpd90gzFFS269lvzs2I1qsb2pY7HVkCAwEA
AaMTMBEwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQUFAAOCAQEAuI3O7+cUus/usESS
bLQ5PqKEbq24IXfS1HeCh+YgQYHu4vgRt2PRFze+GXYkHAQaTOs9qmdvLdTN/mUxcMUbpgIK
umB7bVjCmkn+YzILa+M6wKyrO7Do0wlRjBCDxjTgxSvgGrZgFCdsMneMvLJymM/NzD+5yCRC
FNZX/OYmQ6kd5YCQzgNUKD73P9P4Te1qCjqTE5s7FCMTY5w/0YcneeVMUeMBrYVdGjux1XMQ
pNPyvG5k9VpWkKjHDkx0Dy5xO/fIR/RpbxXyEV6DHpx8Uq79AtoSqFlnGNu8cN2bsWntgM6J
QEhqDjXKKWYVIZQs6GAqm4VKQPNriiTsBhYscw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEMjCCAxqgAwIBAgIBATANBgkqhkiG9w0BAQUFADB7MQswCQYDVQQGEwJHQjEbMBkGA1UE
CAwSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21v
ZG8gQ0EgTGltaXRlZDEhMB8GA1UEAwwYQUFBIENlcnRpZmljYXRlIFNlcnZpY2VzMB4XDTA0
MDEwMTAwMDAwMFoXDTI4MTIzMTIzNTk1OVowezELMAkGA1UEBhMCR0IxGzAZBgNVBAgMEkdy
ZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBwwHU2FsZm9yZDEaMBgGA1UECgwRQ29tb2RvIENB
IExpbWl0ZWQxITAfBgNVBAMMGEFBQSBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAL5AnfRu4ep2hxxNRUSOvkbIgwadwSr+GB+O5AL686td
UIoWMQuaBtDFcCLNSS1UY8y2bmhGC1Pqy0wkwLxyTurxFa70VJoSCsN6sjNg4tqJVfMiWPPe
3M/vg4aijJRPn2jymJBGhCfHdr/jzDUsi14HZGWCwEiwqJH5YZ92IFCokcdmtet4YgNW8Ioa
E+oxox6gmf049vYnMlhvB/VruPsUK6+3qszWY19zjNoFmag4qMsXeDZRrOme9Hg6jc8P2ULi
mAyrL58OAd7vn5lJ8S3frHRNG5i1R8XlKdH5kBjHYpy+g8cmez6KJcfA3Z3mNWgQIJ2P2N7S
w4ScDV7oL8kCAwEAAaOBwDCBvTAdBgNVHQ4EFgQUoBEKIz6W8Qfs4q8p74Klf9AwpLQwDgYD
VR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wewYDVR0fBHQwcjA4oDagNIYyaHR0cDov
L2NybC5jb21vZG9jYS5jb20vQUFBQ2VydGlmaWNhdGVTZXJ2aWNlcy5jcmwwNqA0oDKGMGh0
dHA6Ly9jcmwuY29tb2RvLm5ldC9BQUFDZXJ0aWZpY2F0ZVNlcnZpY2VzLmNybDANBgkqhkiG
9w0BAQUFAAOCAQEACFb8AvCb6P+k+tZ7xkSAzk/ExfYAWMymtrwUSWgEdujm7l3sAg9g1o1Q
GE8mTgHj5rCl7r+8dFRBv/38ErjHT1r0iWAFf2C3BUrz9vHCv8S5dIa2LX1rzNLzRt0vxuBq
w8M0Ayx9lt1awg6nCpnBBYurDC/zXDrPbDdVCYfeU0BsWO/8tqtlbgT2G9w84FoVxp7Z8VlI
MCFlA2zs6SFz7JsDoeA3raAVGI/6ugLOpyypEBMs1OUIJqsil2D4kF501KKaU73yqWjgom7C
12yxow+ev+to51byrvLjKzg6CYG1a4XXvi3tPxq3smPi9WIsgtRqAEFQ8TmDn5XpNpaYbg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEPzCCAyegAwIBAgIBATANBgkqhkiG9w0BAQUFADB+MQswCQYDVQQGEwJHQjEbMBkGA1UE
CAwSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21v
ZG8gQ0EgTGltaXRlZDEkMCIGA1UEAwwbU2VjdXJlIENlcnRpZmljYXRlIFNlcnZpY2VzMB4X
DTA0MDEwMTAwMDAwMFoXDTI4MTIzMTIzNTk1OVowfjELMAkGA1UEBhMCR0IxGzAZBgNVBAgM
EkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBwwHU2FsZm9yZDEaMBgGA1UECgwRQ29tb2Rv
IENBIExpbWl0ZWQxJDAiBgNVBAMMG1NlY3VyZSBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczCCASIw
DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMBxM4KK0HDrc4eCQNUd5MvJDkKQ+d40uaG6
EfQlhfPMcm3ye5drswfxdySRXyWP9nQ95IDC+DwN879A6vfIUtFyb+/Iq0G4bi4XKpVpDM3S
HpR7LZQdqnXXs5jLrLxkU0C8j6ysNstcrbvd4JQX7NFc0L/vpZXJkMWwrPsbQ996CF23uPJA
GysnnlDOXmWCiIxe004MeuoIkbY2qitC++rCoznl2yY4rYsK7hljxxwk3wN42ubqwUcaCwtG
Cd0C/N7Lh1/XMGNooa7cMqG6vv5Eq2i2pRcV/b3Vp6ea5EQz6YiO/O1R65NxTq0B50SOqy3L
qP4BSUjwwN3HaNiS/j0CAwEAAaOBxzCBxDAdBgNVHQ4EFgQUPNiTiMLAggnMAZkGkyDpnnAJ
Y08wDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wgYEGA1UdHwR6MHgwO6A5oDeG
NWh0dHA6Ly9jcmwuY29tb2RvY2EuY29tL1NlY3VyZUNlcnRpZmljYXRlU2VydmljZXMuY3Js
MDmgN6A1hjNodHRwOi8vY3JsLmNvbW9kby5uZXQvU2VjdXJlQ2VydGlmaWNhdGVTZXJ2aWNl
cy5jcmwwDQYJKoZIhvcNAQEFBQADggEBAIcBbSMdflsXfcFhMs+P5/OKlFlm4J4oqF7Tt/Q0
5qo5spcWxYJvMqTpjOev/e/C6LlLqqP05tqNZSH7uoDrJiiFGv45jN5bBAS0VPmjZ55B+glS
zAVIqMk/IQQezkhr/IXownuvf7fM+F86/TXGDe+X3EyrEeFryzHRbPtIgKvcnDe4IRRLDXE9
7IMzbtFuMhbsmMcWi1mmNKsFVy2T96oTy9IT4rcuO81rUBcJaD61JlfutuC23bkpgHl9j6Pw
pCikFcSF9CfUa7/lXORlAnZUtOM3ZiTTGWHIUhDlizeauan5Hb/qmZJhlv8BzaFfDbxxvA6s
Cx1HRR3B7Hzs/Sk=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEQzCCAyugAwIBAgIBATANBgkqhkiG9w0BAQUFADB/MQswCQYDVQQGEwJHQjEbMBkGA1UE
CAwSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHDAdTYWxmb3JkMRowGAYDVQQKDBFDb21v
ZG8gQ0EgTGltaXRlZDElMCMGA1UEAwwcVHJ1c3RlZCBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczAe
Fw0wNDAxMDEwMDAwMDBaFw0yODEyMzEyMzU5NTlaMH8xCzAJBgNVBAYTAkdCMRswGQYDVQQI
DBJHcmVhdGVyIE1hbmNoZXN0ZXIxEDAOBgNVBAcMB1NhbGZvcmQxGjAYBgNVBAoMEUNvbW9k
byBDQSBMaW1pdGVkMSUwIwYDVQQDDBxUcnVzdGVkIENlcnRpZmljYXRlIFNlcnZpY2VzMIIB
IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA33FvNlhTWvI2VFeAxHQIIO0Yfyod5jWa
HiWsnOWWfnJSoBVC21ndZHoa0Lh73TkVvFVIxO06AOoxEbrycXQaZ7jPM8yoMa+j49d/vzMt
TGo87IvDktJTdyR0nAducPy9C1t2ul/y/9c3S0pgePfw+spwtOpZqqPOSC+pw7ILfhdyFgym
BwwbOM/JYrc/oJOlh0Hyt3BAd9i+FHzjqMB6juljatEPmsbS9Is6FARW1O24zG71++IsWL1/
T2sr92AkWCTOJu80kTrV44HQsvAEAtdbtz6SrGsSivnkBbA7kUlcsutT6vifR4buv5XAwAaf
0lteERv0xwQ1KdJVXOTt6wIDAQABo4HJMIHGMB0GA1UdDgQWBBTFe1i97doladL3WRaoszLA
eydb9DAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zCBgwYDVR0fBHwwejA8oDqg
OIY2aHR0cDovL2NybC5jb21vZG9jYS5jb20vVHJ1c3RlZENlcnRpZmljYXRlU2VydmljZXMu
Y3JsMDqgOKA2hjRodHRwOi8vY3JsLmNvbW9kby5uZXQvVHJ1c3RlZENlcnRpZmljYXRlU2Vy
dmljZXMuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQDIk4E7ibSvuIQSTI3S8NtwuleGFTQQuS9/
HrCoiWChisJ3DFBKmwCL2Iv0QeLQg4pKHBQGsKNoBXAxMKdTmw7pSqBYaWcOrp32pSxBvzwG
a+RZzG0Q8ZZvH9/0BAKkn0U+yNj6NkZEUD+Cl5EfKNsYEYwq5GWDVxISjBc/lDb+XbDABHcT
uPQV1T84zJQ6VdCsmPW6AF/ghhmBeC8owH7TzEIK9a5QoNE+xqFx7D+gIIxmOom0jtTYsU0l
R+4viMi14QVFwL4Ucd56/Y57fU0IlqUSc/AtyjcndBInTMu2l+nZrghtWjlA3QVHdWpaIbOj
GM9O9y5Xt5hwXsjEeLBi
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF0DCCBLigAwIBAgIEOrZQizANBgkqhkiG9w0BAQUFADB/MQswCQYDVQQGEwJCTTEZMBcG
A1UEChMQUXVvVmFkaXMgTGltaXRlZDElMCMGA1UECxMcUm9vdCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTEuMCwGA1UEAxMlUXVvVmFkaXMgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0
eTAeFw0wMTAzMTkxODMzMzNaFw0yMTAzMTcxODMzMzNaMH8xCzAJBgNVBAYTAkJNMRkwFwYD
VQQKExBRdW9WYWRpcyBMaW1pdGVkMSUwIwYDVQQLExxSb290IENlcnRpZmljYXRpb24gQXV0
aG9yaXR5MS4wLAYDVQQDEyVRdW9WYWRpcyBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAv2G1lVO6V/z68mcLOhrfEYBklbTR
vM16z/Ypli4kVEAkOPcahdxYTMukJ0KX0J+DisPkBgNbAKVRHnAEdOLB1Dqr1607BxgFjv2D
rOpm2RgbaIr1VxqYuvXtdj182d6UajtLF8HVj71lODqV0D1VNk7feVcxKh7YWWVJWCCYfqtf
fp/p1k3sg3Spx2zY7ilKhSoGFPlU5tPaZQeLYzcS19Dsw3sgQUSj7cugF+FxZc4dZjH3dgEZ
yH0DWLaVSR2mEiboxgx24ONmy+pdpibu5cxfvWenAScOospUxbF6lR1xHkopigPcakXBpBle
bzbNw6Kwt/5cOOJSvPhEQ+aQuwIDAQABo4ICUjCCAk4wPQYIKwYBBQUHAQEEMTAvMC0GCCsG
AQUFBzABhiFodHRwczovL29jc3AucXVvdmFkaXNvZmZzaG9yZS5jb20wDwYDVR0TAQH/BAUw
AwEB/zCCARoGA1UdIASCAREwggENMIIBCQYJKwYBBAG+WAABMIH7MIHUBggrBgEFBQcCAjCB
xxqBxFJlbGlhbmNlIG9uIHRoZSBRdW9WYWRpcyBSb290IENlcnRpZmljYXRlIGJ5IGFueSBw
YXJ0eSBhc3N1bWVzIGFjY2VwdGFuY2Ugb2YgdGhlIHRoZW4gYXBwbGljYWJsZSBzdGFuZGFy
ZCB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZiB1c2UsIGNlcnRpZmljYXRpb24gcHJhY3RpY2Vz
LCBhbmQgdGhlIFF1b1ZhZGlzIENlcnRpZmljYXRlIFBvbGljeS4wIgYIKwYBBQUHAgEWFmh0
dHA6Ly93d3cucXVvdmFkaXMuYm0wHQYDVR0OBBYEFItLbe3TKbkGGew5Oanwl4Rqy+/fMIGu
BgNVHSMEgaYwgaOAFItLbe3TKbkGGew5Oanwl4Rqy+/foYGEpIGBMH8xCzAJBgNVBAYTAkJN
MRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMSUwIwYDVQQLExxSb290IENlcnRpZmljYXRp
b24gQXV0aG9yaXR5MS4wLAYDVQQDEyVRdW9WYWRpcyBSb290IENlcnRpZmljYXRpb24gQXV0
aG9yaXR5ggQ6tlCLMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQUFAAOCAQEAitQUtf70
mpKnGdSkfnIYj9lofFIk3WdvOXrEql494liwTXCYhGHoG+NpGA7O+0dQoE7/8CQfvbLO9Sf8
7C9TqnN7Az10buYWnuulLsS/VidQK2K6vkscPFVcQR0kvoIgR13VRH56FmjffU1RcHhXHTMe
/QKZnAzNCgVPx7uOpHX6Sm2xgI4JVrmcGmD+XcHXetwReNDWXcG31a0ymQM6isxUJTkxgXsT
IlG6Rmyhu576BGxJJnSP0nPrzDCi5upZIof4l/UO/erMkqQWxFIY6iHOsfHmhIHluqmGKPJD
Wl0Snawe2ajlCmqnf6CHKc/yiU3U7MXi5nrQNiOKSnQ2+Q==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFtzCCA5+gAwIBAgICBQkwDQYJKoZIhvcNAQEFBQAwRTELMAkGA1UEBhMCQk0xGTAXBgNV
BAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1ZhZGlzIFJvb3QgQ0EgMjAeFw0w
NjExMjQxODI3MDBaFw0zMTExMjQxODIzMzNaMEUxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBR
dW9WYWRpcyBMaW1pdGVkMRswGQYDVQQDExJRdW9WYWRpcyBSb290IENBIDIwggIiMA0GCSqG
SIb3DQEBAQUAA4ICDwAwggIKAoICAQCaGMpLlA0ALa8DKYrwD4HIrkwZhR0In6spRIXzL4Gt
Mh6QRr+jhiYaHv5+HBg6XJxgFyo6dIMzMH1hVBHL7avg5tKifvVrbxi3Cgst/ek+7wrGsxDp
3MJGF/hd/aTa/55JWpzmM+Yklvc/ulsrHHo1wtZn/qtmUIttKGAr79dgw8eTvI02kfN/+NsR
E8Scd3bBrrcCaoF6qUWD4gXmuVbBlDePSHFjIuwXZQeVikvfj8ZaCuWw419eaxGrDPmF60Tp
+ARz8un+XJiM9XOva7R+zdRcAitMOeGylZUtQofX1bOQQ7dsE/He3fbE+Ik/0XX1ksOR1YqI
0JDs3G3eicJlcZaLDQP9nL9bFqyS2+r+eXyt66/3FsvbzSUr5R/7mp/iUcw6UwxI5g69ybR2
BlLmEROFcmMDBOAENisgGQLodKcftslWZvB1JdxnwQ5hYIizPtGo/KPaHbDRsSNU30R2be1B
2MGyIrZTHN81Hdyhdyox5C315eXbyOD/5YDXC2Og/zOhD7osFRXql7PSorW+8oyWHhqPHWyk
YTe5hnMz15eWniN9gqRMgeKh0bpnX5UHoycR7hYQe7xFSkyyBNKr79X9DFHOUGoIMfmR2gyP
ZFwDwzqLID9ujWc9Otb+fVuIyV77zGHcizN300QyNQliBJIWENieJ0f7OyHj+OsdWwIDAQAB
o4GwMIGtMA8GA1UdEwEB/wQFMAMBAf8wCwYDVR0PBAQDAgEGMB0GA1UdDgQWBBQahGK8SEwz
JQTU7tD2A8QZRtGUazBuBgNVHSMEZzBlgBQahGK8SEwzJQTU7tD2A8QZRtGUa6FJpEcwRTEL
MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1Zh
ZGlzIFJvb3QgQ0EgMoICBQkwDQYJKoZIhvcNAQEFBQADggIBAD4KFk2fBluornFdLwUvZ+YT
RYPENvbzwCYMDbVHZF34tHLJRqUDGCdViXh9duqWNIAXINzng/iN/Ae42l9NLmeyhP3ZRPx3
UIHmfLTJDQtyU/h2BwdBR5YM++CCJpNVjP4iH2BlfF/nJrP3MpCYUNQ3cVX2kiF495V5+vgt
JodmVjB3pjd4M1IQWK4/YY7yarHvGH5KWWPKjaJW1acvvFYfzznB4vsKqBUsfU16Y8Zsl0Q8
0m/DShcK+JDSV6IZUaUtl0HaB0+pUNqQjZRG4T7wlP0QADj1O+hA4bRuVhogzG9Yje0uRY/W
6ZM/57Es3zrWIozchLsib9D45MY56QSIPMO661V6bYCZJPVsAfv4l7CUW+v90m/xd2gNNWQj
rLhVoQPRTUIZ3Ph1WVaj+ahJefivDrkRoHy3au000LYmYjgahwz46P0u05B/B5EqHdZ+XIWD
mbA4CD/pXvk1B+TJYm5Xf6dQlfe6yJvmjqIBxdZmv3lh8zwc4bmCXF2gw+nYSL0ZohEUGW6y
hhtoPkg3Goi3XZZenMfvJ2II4pEZXNLxId26F0KCl3GBUzGpn/Z9Yr9y4aOTHcyKJloJONDO
1w2AFrR4pTqHTI2KpdVGl/IsELm8VCLAAVBpQ570su9t+Oza8eOx79+Rj1QqCyXBJhnEUhAF
ZdWCEOrCMc0u
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIGnTCCBIWgAwIBAgICBcYwDQYJKoZIhvcNAQEFBQAwRTELMAkGA1UEBhMCQk0xGTAXBgNV
BAoTEFF1b1ZhZGlzIExpbWl0ZWQxGzAZBgNVBAMTElF1b1ZhZGlzIFJvb3QgQ0EgMzAeFw0w
NjExMjQxOTExMjNaFw0zMTExMjQxOTA2NDRaMEUxCzAJBgNVBAYTAkJNMRkwFwYDVQQKExBR
dW9WYWRpcyBMaW1pdGVkMRswGQYDVQQDExJRdW9WYWRpcyBSb290IENBIDMwggIiMA0GCSqG
SIb3DQEBAQUAA4ICDwAwggIKAoICAQDMV0IWVJzmmNPTTe7+7cefQzlKZbPoFog02w1ZkXTP
krgEQK0CSzGrvI2RaNggDhoB4hp7Thdd4oq3P5kazethq8Jlph+3t723j/z9cI8LoGe+AaJZ
z3HmDyl2/7FWeUUrH556VOijKTVopAFPD6QuN+8bv+OPEKhyq1hX51SGyMnzW9os2l2Objyj
Ptr7guXd8lyyBTNvijbO0BNO/79KDDRMpsMhvVAEVeuxu537RR5kFd5VAYwCdrXLoT9Cabwv
vWhDFlaJKjdhkf2mrk7AyxRllDdLkgbvBNDInIjbC3uBr7E9KsRlOni27tyAsdLTmZw67mta
a7ONt9XOnMK+pUsvFrGeaDsGb659n/je7Mwpp5ijJUMv7/FfJuGITfhebtfZFG4ZM2mnO4SJ
k8RTVROhUXhA+LjJou57ulJCg54U7QVSWllWp5f8nT8KKdjcT5EOE7zelaTfi5m+rJsziO+1
ga8bxiJTyPbH7pcUsMV8eFLI8M5ud2CEpukqdiDtWAEXMJPpGovgc2PZapKUSU60rUqFxKMi
MPwJ7Wgic6aIDFUhWMXhOp8q3crhkODZc6tsgLjoC2SToJyMGf+z0gzskSaHirOi4XCPLArl
zW1oUevaPwV/izLmE1xr/l9A4iLItLRkT9a6fUg+qGkM17uGcclzuD87nSVL2v9A6wIDAQAB
o4IBlTCCAZEwDwYDVR0TAQH/BAUwAwEB/zCB4QYDVR0gBIHZMIHWMIHTBgkrBgEEAb5YAAMw
gcUwgZMGCCsGAQUFBwICMIGGGoGDQW55IHVzZSBvZiB0aGlzIENlcnRpZmljYXRlIGNvbnN0
aXR1dGVzIGFjY2VwdGFuY2Ugb2YgdGhlIFF1b1ZhZGlzIFJvb3QgQ0EgMyBDZXJ0aWZpY2F0
ZSBQb2xpY3kgLyBDZXJ0aWZpY2F0aW9uIFByYWN0aWNlIFN0YXRlbWVudC4wLQYIKwYBBQUH
AgEWIWh0dHA6Ly93d3cucXVvdmFkaXNnbG9iYWwuY29tL2NwczALBgNVHQ8EBAMCAQYwHQYD
VR0OBBYEFPLAE+CCQz777i9nMpY1XNu4ywLQMG4GA1UdIwRnMGWAFPLAE+CCQz777i9nMpY1
XNu4ywLQoUmkRzBFMQswCQYDVQQGEwJCTTEZMBcGA1UEChMQUXVvVmFkaXMgTGltaXRlZDEb
MBkGA1UEAxMSUXVvVmFkaXMgUm9vdCBDQSAzggIFxjANBgkqhkiG9w0BAQUFAAOCAgEAT62g
LEz6wPJv92ZVqyM07ucp2sNbtrCD2dDQ4iH782CnO11gUyeim/YIIirnv6By5ZwkajGxkHon
24QRiSemd1o417+shvzuXYO8BsbRd2sPbSQvS3pspweWyuOEn62Iix2rFo1bZhfZFvSLgNLd
+LJ2w/w4E6oM3kJpK27zPOuAJ9v1pkQNn1pVWQvVDVJIxa6f8i+AxeoyUDUSly7B4f/xI4hR
OJ/yZlZ25w9Rl6VSDE1JUZU2Pb+iSwwQHYaZTKrzchGT5Or2m9qoXadNt54CrnMAyNojA+j5
6hl0YgCUyyIgvpSnWbWCar6ZeXqp8kokUvd0/bpO5qgdAm6xDYBEwa7TIzdfu4V8K5Iu6H6l
i92Z4b8nby1dqnuH/grdS/yO9SbkbnBCbjPsMZ57k8HkyWkaPcBrTiJt7qtYTcbQQcEr6k8S
h17rRdhs9ZgC06DYVYoGmRmioHfRMJ6szHXug/WwYjnPbFfiTNKRCw51KBuav/0aQ/HKd/s7
j2G4aSgWQgRecCocIdiP4b0jWy10QJLZYxkNc91pvGJHvOB0K7Lrfb5BG7XARsWhIstfTsEo
kt4YutUqKLsRixeTmJlglFwjz1onl14LBQaTNx47aTbrqZ5hHY8y2o4M1nQ+ewkk2gF3R8Q7
zTSMmfXK4SVhM7JZG+Ju1zdXtg2pEto=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDWjCCAkKgAwIBAgIBADANBgkqhkiG9w0BAQUFADBQMQswCQYDVQQGEwJKUDEYMBYGA1UE
ChMPU0VDT00gVHJ1c3QubmV0MScwJQYDVQQLEx5TZWN1cml0eSBDb21tdW5pY2F0aW9uIFJv
b3RDQTEwHhcNMDMwOTMwMDQyMDQ5WhcNMjMwOTMwMDQyMDQ5WjBQMQswCQYDVQQGEwJKUDEY
MBYGA1UEChMPU0VDT00gVHJ1c3QubmV0MScwJQYDVQQLEx5TZWN1cml0eSBDb21tdW5pY2F0
aW9uIFJvb3RDQTEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCzs/5/022x7xZ8
V6UMbXaKL0u/ZPtM7orw8yl89f/uKuDp6bpbZCKamm8sOiZpUQWZJtzVHGpxxpp9Hp3dfGzG
jGdnSj74cbAZJ6kJDKaVv0uMDPpVmDvY6CKhS3E4eayXkmmziX7qIWgGmBSWh9JhNrxtJ1ae
V+7AwFb9Ms+k2Y7CI9eNqPPYJayX5HA49LY6tJ07lyZDo6G8SVlyTCMwhwFY9k6+HGhWZq/N
QV3Is00qVUarH9oe4kA92819uZKAnDfdDJZkndwi92SL32HeFZRSFaB9UslLqCHJxrHty8OV
YNEP8Ktw+N/LTX7s1vqr2b1/VPKl6Xn62dZ2JChzAgMBAAGjPzA9MB0GA1UdDgQWBBSgc0mZ
aNyFW2XjmygvV5+9M7wHSDALBgNVHQ8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG
9w0BAQUFAAOCAQEAaECpqLvkT115swW1F7NgE+vGkl3g0dNq/vu+m22/xwVtWSDEHPC32oRY
AmP6SBbvT6UL90qY8j+eG61Ha2POCEfrUj94nK9NrvjVT8+amCoQQTlSxN3Zmw7vkwGusi7K
aEIkQmywszo+zenaSMQVy+n5Bw+SUEmK3TGXX8npN6o7WWWXlDLJs58+OmJYxUmtYg5xpTKq
L8aJdkNAExNnPaJUJRDL8Try2frbSVa7pv6nQTXD4IhhyYjH3zYQIphZ6rBK+1YWc26sTfci
oU+tHXotRSflMMFe8toTyyVCUZVHA4xsIcx0Qu1T/zOLjw9XARYvz6buyXAiFL39vmwLAw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDIDCCAgigAwIBAgIBHTANBgkqhkiG9w0BAQUFADA5MQswCQYDVQQGEwJGSTEPMA0GA1UE
ChMGU29uZXJhMRkwFwYDVQQDExBTb25lcmEgQ2xhc3MyIENBMB4XDTAxMDQwNjA3Mjk0MFoX
DTIxMDQwNjA3Mjk0MFowOTELMAkGA1UEBhMCRkkxDzANBgNVBAoTBlNvbmVyYTEZMBcGA1UE
AxMQU29uZXJhIENsYXNzMiBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJAX
SjWdyvANlsdE+hY3/Ei9vX+ALTU74W+oZ6m/AxxNjG8yR9VBaKQTBME1DJqEQ/xcHf+Js+gX
GM2RX/uJ4+q/Tl18GybTdXnt5oTjV+WtKcT0OijnpXuENmmz/V52vaMtmdOQTiMofRhj8VQ7
Jp12W5dCsv+u8E7s3TmVToMGf+dJQMjFAbJUWmYdPfz56TwKnoG4cPABi+QjVHzIrviQHgCW
ctRUz2EjvOr7nQKV0ba5cTppCD8PtOFCx4j1P5iop7oc4HFx71hXgVB6XGt0Rg6DA5jDjqhu
8nYybieDwnPz3BjotJPqdURrBGAgcVeHnfO+oJAjPYok4doh28MCAwEAAaMzMDEwDwYDVR0T
AQH/BAUwAwEB/zARBgNVHQ4ECgQISqCqWITTXjwwCwYDVR0PBAQDAgEGMA0GCSqGSIb3DQEB
BQUAA4IBAQBazof5FnIVV0sd2ZvnoiYw7JNn39Yt0jSv9zilzqsWuasvfDXLrNAPtEwr/IDv
a4yRXzZ299uzGxnq9LIR/WFxRL8oszodv7ND6J+/3DEIcbCdjdY0RzKQxmUk96BKfARzjzlv
F4xytb1LyHr4e4PDKE6cCepnP7JnBBvDFNr450kkkdAdavphOe9r5yF1BgfYErQhIHBCcYHa
PJo2vqZbDWpsmh+Re/n570K6Tk6ezAyNlNzZRZxe7EJQY670XcSxEtzKO6gunRRaBXW37Ndj
4ro1tgQIkejanZz2ZrUYrAqmVCY0M9IbwdR/GjqOC6oybtv8TyWf2TLHllpwrN9M
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEdDCCA1ygAwIBAgIQRL4Mi1AAJLQR0zYq/mUK/TANBgkqhkiG9w0BAQUFADCBlzELMAkG
A1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQHEw5TYWx0IExha2UgQ2l0eTEeMBwGA1UE
ChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYDVQQLExhodHRwOi8vd3d3LnVzZXJ0cnVz
dC5jb20xHzAdBgNVBAMTFlVUTi1VU0VSRmlyc3QtSGFyZHdhcmUwHhcNOTkwNzA5MTgxMDQy
WhcNMTkwNzA5MTgxOTIyWjCBlzELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAlVUMRcwFQYDVQQH
Ew5TYWx0IExha2UgQ2l0eTEeMBwGA1UEChMVVGhlIFVTRVJUUlVTVCBOZXR3b3JrMSEwHwYD
VQQLExhodHRwOi8vd3d3LnVzZXJ0cnVzdC5jb20xHzAdBgNVBAMTFlVUTi1VU0VSRmlyc3Qt
SGFyZHdhcmUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCx98M4P7Sof885glFn
0G2f0v9Y8+efK+wNiVSZuTiZFvfgIXlIwrthdBKWHTxqctU8EGc6Oe0rE81m65UJM6Rsl7Ho
xuzBdXmcRl6Nq9Bq/bkqVRcQVLMZ8Jr28bFdtqdt++BxF2uiiPsA3/4aMXcMmgF6sTLjKwEH
OG7DpV4jvEWbe1DByTCP2+UretNb+zNAHqDVmBe8i4fDidNdoI6yqqr2jmmIBsX6iSHzCJ1p
LgkzmykNRg+MzEk0sGlRvfkGzWitZky8PqxhvQqIDsjfPe58BEydCl5rkdbux+0ojatNh4lz
0G6k0B4WixThdkQDf2Os5M1JnMWS9KsyoUhbAgMBAAGjgbkwgbYwCwYDVR0PBAQDAgHGMA8G
A1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFKFyXyYbKJhDlV0HN9WFlp1L0sNFMEQGA1UdHwQ9
MDswOaA3oDWGM2h0dHA6Ly9jcmwudXNlcnRydXN0LmNvbS9VVE4tVVNFUkZpcnN0LUhhcmR3
YXJlLmNybDAxBgNVHSUEKjAoBggrBgEFBQcDAQYIKwYBBQUHAwUGCCsGAQUFBwMGBggrBgEF
BQcDBzANBgkqhkiG9w0BAQUFAAOCAQEARxkP3nTGmZev/K0oXnWO6y1n7k57K9cM//bey1Wi
CuFMVGWTYGufEpytXoMs61quwOQt9ABjHbjAbPLPSbtNk28GpgoiskliCE7/yMgUsogWXecB
5BKV5UU0s4tpvc+0hY91UZ59Ojg6FEgSxvunOxqNDYJAB+gECJChicsZUN/KHAG8HQQZexB2
lzvukJDKxA4fFm517zP4029bHpbj4HR3dHuKom4t3XbWOTCC8KucUvIqx69JXn7HaOWCgchq
J/kniCrVWFCVH/A7HFe7fRQ5YiuayZSSKqMiDP+JJn1fIytH1xUdqWqeUQ0qUZ6B+dQ7XnAS
fxAynB67nfhmqA==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEvTCCA6WgAwIBAgIBADANBgkqhkiG9w0BAQUFADB/MQswCQYDVQQGEwJFVTEnMCUGA1UE
ChMeQUMgQ2FtZXJmaXJtYSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQLExpodHRwOi8vd3d3
LmNoYW1iZXJzaWduLm9yZzEiMCAGA1UEAxMZQ2hhbWJlcnMgb2YgQ29tbWVyY2UgUm9vdDAe
Fw0wMzA5MzAxNjEzNDNaFw0zNzA5MzAxNjEzNDRaMH8xCzAJBgNVBAYTAkVVMScwJQYDVQQK
Ex5BQyBDYW1lcmZpcm1hIFNBIENJRiBBODI3NDMyODcxIzAhBgNVBAsTGmh0dHA6Ly93d3cu
Y2hhbWJlcnNpZ24ub3JnMSIwIAYDVQQDExlDaGFtYmVycyBvZiBDb21tZXJjZSBSb290MIIB
IDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEAtzZV5aVdGDDg2olUkfzIx1L4L1DZ77F1
c2VHfRtbunXF/KGIJPov7coISjlUxFF6tdpg6jg8gbLL8bvZkSM/SAFwdakFKq0fcfPJVD0d
BmpAPrMMhe5cG3nCYsS4No41XQEMIwRHNaqbYE6gZj3LJgqcQKH0XZi/caulAGgq7YN6D6IU
tdQis4CwPAxaUWktWBiP7Zme8a7ileb2R6jWDA+wWFjbw2Y3npuRVDM30pQcakjJyfKl2qUM
I/cjDpwyVV5xnIQFUZot/eZOKjRa3spAN2cMVCFVd9oKDMyXroDclDZK9D7ONhMeU+SsTjoF
7Nuucpw4i9A5O4kKPnf+dQIBA6OCAUQwggFAMBIGA1UdEwEB/wQIMAYBAf8CAQwwPAYDVR0f
BDUwMzAxoC+gLYYraHR0cDovL2NybC5jaGFtYmVyc2lnbi5vcmcvY2hhbWJlcnNyb290LmNy
bDAdBgNVHQ4EFgQU45T1sU3p26EpW1eLTXYGduHRooowDgYDVR0PAQH/BAQDAgEGMBEGCWCG
SAGG+EIBAQQEAwIABzAnBgNVHREEIDAegRxjaGFtYmVyc3Jvb3RAY2hhbWJlcnNpZ24ub3Jn
MCcGA1UdEgQgMB6BHGNoYW1iZXJzcm9vdEBjaGFtYmVyc2lnbi5vcmcwWAYDVR0gBFEwTzBN
BgsrBgEEAYGHLgoDATA+MDwGCCsGAQUFBwIBFjBodHRwOi8vY3BzLmNoYW1iZXJzaWduLm9y
Zy9jcHMvY2hhbWJlcnNyb290Lmh0bWwwDQYJKoZIhvcNAQEFBQADggEBAAxBl8IahsAifJ/7
kPMa0QOx7xP5IV8EnNrJpY0nbJaHkb5BkAFyk+cefV/2icZdp0AJPaxJRUXcLo0waLIJuvvD
L8y6C98/d3tGfToSJI6WjzwFCm/SlCgdbQzALogi1djPHRPH8EjX1wWnz8dHnjs8NMiAT9QU
u/wNUPf6s+xCX6ndbcj0dc97wXImsQEcXCz9ek60AcUFV7nnPKoF2YjpB0ZBzu9Bga5Y34Oi
rsrXdx/nADydb47kMgkdTXg0eDQ8lJsm7U9xxhl6vSAiSFr+S30Dt+dYvsYyTnQeaN2oaFuz
Pu5ifdmA6Ap1erfutGWaIZDgqtCYvDi1czyL+Nw=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIExTCCA62gAwIBAgIBADANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJFVTEnMCUGA1UE
ChMeQUMgQ2FtZXJmaXJtYSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQLExpodHRwOi8vd3d3
LmNoYW1iZXJzaWduLm9yZzEgMB4GA1UEAxMXR2xvYmFsIENoYW1iZXJzaWduIFJvb3QwHhcN
MDMwOTMwMTYxNDE4WhcNMzcwOTMwMTYxNDE4WjB9MQswCQYDVQQGEwJFVTEnMCUGA1UEChMe
QUMgQ2FtZXJmaXJtYSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQLExpodHRwOi8vd3d3LmNo
YW1iZXJzaWduLm9yZzEgMB4GA1UEAxMXR2xvYmFsIENoYW1iZXJzaWduIFJvb3QwggEgMA0G
CSqGSIb3DQEBAQUAA4IBDQAwggEIAoIBAQCicKLQn0KuWxfH2H3PFIP8T8mhtxOviteePgQK
kotgVvq0Mi+ITaFgCPS3CU6gSS9J1tPfnZdan5QEcOw/Wdm3zGaLmFIoCQLfxS+EjXqXd7/s
QJ0lcqu1PzKY+7e3/HKE5TWH+VX6ox8Oby4o3Wmg2UIQxvi1RMLQQ3/bvOSiPGpVeAp3qdjq
GTK3L/5cPxvusZjsyq16aUXjlg9V9ubtdepl6DJWk0aJqCWKZQbua795B9Dxt6/tLE2Su8Co
X6dnfQTyFQhwrJLWfQTSM/tMtgsL+xrJxI0DqX5c8lCrEqWhz0hQpe/SyBoT+rB/sYIcd2oP
X9wLlY/vQ37mRQklAgEDo4IBUDCCAUwwEgYDVR0TAQH/BAgwBgEB/wIBDDA/BgNVHR8EODA2
MDSgMqAwhi5odHRwOi8vY3JsLmNoYW1iZXJzaWduLm9yZy9jaGFtYmVyc2lnbnJvb3QuY3Js
MB0GA1UdDgQWBBRDnDafsJ4wTcbOX60Qq+UDpfqpFDAOBgNVHQ8BAf8EBAMCAQYwEQYJYIZI
AYb4QgEBBAQDAgAHMCoGA1UdEQQjMCGBH2NoYW1iZXJzaWducm9vdEBjaGFtYmVyc2lnbi5v
cmcwKgYDVR0SBCMwIYEfY2hhbWJlcnNpZ25yb290QGNoYW1iZXJzaWduLm9yZzBbBgNVHSAE
VDBSMFAGCysGAQQBgYcuCgEBMEEwPwYIKwYBBQUHAgEWM2h0dHA6Ly9jcHMuY2hhbWJlcnNp
Z24ub3JnL2Nwcy9jaGFtYmVyc2lnbnJvb3QuaHRtbDANBgkqhkiG9w0BAQUFAAOCAQEAPDtw
kfkEVCeR4e3t/mh/YV3lQWVPMvEYBZRqHN4fcNs+ezICNLUMbKGKfKX0j//U2K0X1S0E0T9Y
gOKBWYi+wONGkyT+kL0mojAt6JcmVzWJdJYY9hXiryQZVgICsroPFOrGimbBhkVVi76Svpyk
BMdJPJ7oKXqJ1/6v/2j1pReQvayZzKWGVwlnRtvWFsJG8eSpUPWP0ZIV018+xgBJOm5YstHR
Jw0lyDL4IBHNfTIzSJRUTN3cecQwn+uOuFW114hcxWokPbLTBQNRxgfvzBRydD1ucs4YKIxK
oHflCStFREest2d/AYoFWpO+ocH/+OcOZ6RHSXZddZAa9SaP8A==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEMDCCAxigAwIBAgIQUJRs7Bjq1ZxN1ZfvdY+grTANBgkqhkiG9w0BAQUFADCBgjELMAkG
A1UEBhMCVVMxHjAcBgNVBAsTFXd3dy54cmFtcHNlY3VyaXR5LmNvbTEkMCIGA1UEChMbWFJh
bXAgU2VjdXJpdHkgU2VydmljZXMgSW5jMS0wKwYDVQQDEyRYUmFtcCBHbG9iYWwgQ2VydGlm
aWNhdGlvbiBBdXRob3JpdHkwHhcNMDQxMTAxMTcxNDA0WhcNMzUwMTAxMDUzNzE5WjCBgjEL
MAkGA1UEBhMCVVMxHjAcBgNVBAsTFXd3dy54cmFtcHNlY3VyaXR5LmNvbTEkMCIGA1UEChMb
WFJhbXAgU2VjdXJpdHkgU2VydmljZXMgSW5jMS0wKwYDVQQDEyRYUmFtcCBHbG9iYWwgQ2Vy
dGlmaWNhdGlvbiBBdXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCY
JB69FbS638eMpSe2OAtp87ZOqCwuIR1cRN8hXX4jdP5efrRKt6atH67gBhbim1vZZ3RrXYCP
KZ2GG9mcDZhtdhAoWORlsH9KmHmf4MMxfoArtYzAQDsRhtDLooY2YKTVMIJt2W7QDxIEM5df
T2Fa8OT5kavnHTu86M/0ay00fOJIYRyO82FEzG+gSqmUsE3a56k0enI4qEHMPJQRfevIpoy3
hsvKMzvZPTeL+3o+hiznc9cKV6xkmxnr9A8ECIqsAxcZZPRaJSKNNCyy9mgdEm3Tih4U2sSP
puIjhdV6Db1q4Ons7Be7QhtnqiXtRYMh/MHJfNViPvryxS3T/dRlAgMBAAGjgZ8wgZwwEwYJ
KwYBBAGCNxQCBAYeBABDAEEwCwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0O
BBYEFMZPoj0GY4QJnM5i5ASsjVy16bYbMDYGA1UdHwQvMC0wK6ApoCeGJWh0dHA6Ly9jcmwu
eHJhbXBzZWN1cml0eS5jb20vWEdDQS5jcmwwEAYJKwYBBAGCNxUBBAMCAQEwDQYJKoZIhvcN
AQEFBQADggEBAJEVOQMBG2f7Shz5CmBbodpNl2L5JFMn14JkTpAuw0kbK5rc/Kh4ZzXxHfAR
vbdI4xD2Dd8/0sm2qlWkSLoC295ZLhVbO50WfUfXN+pfTXYSNrsf16GBBEYgoyxtqZ4Bfj8p
zgCT3/3JknOJiWSe5yvkHJEs0rnOfc5vMZnT5r7SHpDwCRR5XCOrTdLaIR9NmXmd4c8nnxCb
HIgNsIpkQTG4DmyQJKSbXHGPurt+HBvbaoAPIbzp26a3QPSyi6mx5O+aGtA9aZnuqCij4Tyz
8LIRnM98QObd50N9otg6tamN8jSZxNQQ4Qb9CYQQO+7ETPTsJ3xCwnR8gooJybQDJbw=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEADCCAuigAwIBAgIBADANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJVUzEhMB8GA1UE
ChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRkeSBDbGFzcyAy
IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MB4XDTA0MDYyOTE3MDYyMFoXDTM0MDYyOTE3MDYy
MFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRoZSBHbyBEYWRkeSBHcm91cCwgSW5jLjEx
MC8GA1UECxMoR28gRGFkZHkgQ2xhc3MgMiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAw
DQYJKoZIhvcNAQEBBQADggENADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWiz
V3GgXne77ZtJ6XCAPVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HF
iH7Eux6wwdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLOtXi
EqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWoriMYavx4A6lN
f4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZEewo+YihfukEHU1jPEX44
dMX4/7VpkI+EdOqXG68CAQOjgcAwgb0wHQYDVR0OBBYEFNLEsNKR1EwRcbNhyz2h/t2oatTj
MIGNBgNVHSMEgYUwgYKAFNLEsNKR1EwRcbNhyz2h/t2oatTjoWekZTBjMQswCQYDVQQGEwJV
UzEhMB8GA1UEChMYVGhlIEdvIERhZGR5IEdyb3VwLCBJbmMuMTEwLwYDVQQLEyhHbyBEYWRk
eSBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5ggEAMAwGA1UdEwQFMAMBAf8wDQYJ
KoZIhvcNAQEFBQADggEBADJL87LKPpH8EsahB4yOd6AzBhRckB4Y9wimPQoZ+YeAEW5p5JYX
MP80kWNyOO7MHAGjHZQopDH2esRU1/blMVgDoszOYtuURXO1v0XJJLXVggKtI3lpjbi2Tc7P
TMozI+gciKqdi0FuFskg5YmezTvacPd+mSYgFFQlq25zheabIZ0KbIIOqPjCDPoQHmyW74cN
xA9hi63ugyuV+I6ShHI56yDqg+2DzZduCLzrTia2cyvk0/ZM/iZx4mERdEr/VxqHD3VILs9R
aRegAhJhldXRQLIQTO7ErBBDpqWeCtWVYpoNz4iCxTIM5CufReYNnyicsbkqWletNw+vHX/b
vZ8=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEDzCCAvegAwIBAgIBADANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJVUzElMCMGA1UE
ChMcU3RhcmZpZWxkIFRlY2hub2xvZ2llcywgSW5jLjEyMDAGA1UECxMpU3RhcmZpZWxkIENs
YXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDQwNjI5MTczOTE2WhcNMzQwNjI5
MTczOTE2WjBoMQswCQYDVQQGEwJVUzElMCMGA1UEChMcU3RhcmZpZWxkIFRlY2hub2xvZ2ll
cywgSW5jLjEyMDAGA1UECxMpU3RhcmZpZWxkIENsYXNzIDIgQ2VydGlmaWNhdGlvbiBBdXRo
b3JpdHkwggEgMA0GCSqGSIb3DQEBAQUAA4IBDQAwggEIAoIBAQC3Msj+6XGmBIWtDBFk385N
78gDGIc/oav7PKaf8MOh2tTYbitTkPskpD6E8J7oX+zlJ0T1KKY/e97gKvDIr1MvnsoFAZMe
j2YcOadN+lq2cwQlZut3f+dZxkqZJRRU6ybH838Z1TBwj6+wRir/resp7defqgSHo9T5iaU0
X9tDkYI22WY8sbi5gv2cOj4QyDvvBmVmepsZGD3/cVE8MC5fvj13c7JdBmzDI1aaK4Umkhyn
ArPkPw2vCHmCuDY96pzTNbO8acr1zJ3o/WSNF4Azbl5KXZnJHoe0nRrA1W4TNSNe35tfPe/W
93bC6j67eA0cQmdrBNj41tpvi/JEoAGrAgEDo4HFMIHCMB0GA1UdDgQWBBS/X7fRzt0fhvRb
Vazc1xDCDqmI5zCBkgYDVR0jBIGKMIGHgBS/X7fRzt0fhvRbVazc1xDCDqmI56FspGowaDEL
MAkGA1UEBhMCVVMxJTAjBgNVBAoTHFN0YXJmaWVsZCBUZWNobm9sb2dpZXMsIEluYy4xMjAw
BgNVBAsTKVN0YXJmaWVsZCBDbGFzcyAyIENlcnRpZmljYXRpb24gQXV0aG9yaXR5ggEAMAwG
A1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAAWdP4id0ckaVaGsafPzWdqbAYcaT1ep
oXkJKtv3L7IezMdeatiDh6GX70k1PncGQVhiv45YuApnP+yz3SFmH8lU+nLMPUxA2IGvd56D
eruix/U0F47ZEUD0/CwqTRV/p2JdLiXTAAsgGh1o+Re49L2L7ShZ3U0WixeDyLJlxy16paq8
U4Zt3VekyvggQQto8PT7dL5WXXp59fkdheMtlb71cZBDzI0fmgAKhynpVSJYACPq4xJDKVtH
CN2MQWplBqjlIapBtJUhlbl90TSrE9atvNziPTnNvT51cKEYWQPJIrSPnNVeKtelttQKbfi3
QBFGmh95DmK/D5fs4C8fF5Q=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIHyTCCBbGgAwIBAgIBATANBgkqhkiG9w0BAQUFADB9MQswCQYDVQQGEwJJTDEWMBQGA1UE
ChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUg
U2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcN
MDYwOTE3MTk0NjM2WhcNMzYwOTE3MTk0NjM2WjB9MQswCQYDVQQGEwJJTDEWMBQGA1UEChMN
U3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2ln
bmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0G
CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul3
8kMKogZkpMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf
OQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/CJi/6tRYc
cjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYTKqi5pquDSR3l8u/d
5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNiHzvEvqBTViVsUQn3qqvKv3b9
bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMMAv+Z6+hsTXBbKWWc3apdzK8BMewM69KN
6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w+2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHu
EhANxjJ/GP/89PrNbpHoNkm+Gkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZP
V/+Qt+OR0t3vwmC3Zzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOz
EmDyei+B26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID
AQABo4ICUjCCAk4wDAYDVR0TBAUwAwEB/zALBgNVHQ8EBAMCAa4wHQYDVR0OBBYEFE4L7xqk
QFulF2mHMMo0aEPQQa7yMGQGA1UdHwRdMFswLKAqoCiGJmh0dHA6Ly9jZXJ0LnN0YXJ0Y29t
Lm9yZy9zZnNjYS1jcmwuY3JsMCugKaAnhiVodHRwOi8vY3JsLnN0YXJ0Y29tLm9yZy9zZnNj
YS1jcmwuY3JsMIIBXQYDVR0gBIIBVDCCAVAwggFMBgsrBgEEAYG1NwEBATCCATswLwYIKwYB
BQUHAgEWI2h0dHA6Ly9jZXJ0LnN0YXJ0Y29tLm9yZy9wb2xpY3kucGRmMDUGCCsGAQUFBwIB
FilodHRwOi8vY2VydC5zdGFydGNvbS5vcmcvaW50ZXJtZWRpYXRlLnBkZjCB0AYIKwYBBQUH
AgIwgcMwJxYgU3RhcnQgQ29tbWVyY2lhbCAoU3RhcnRDb20pIEx0ZC4wAwIBARqBl0xpbWl0
ZWQgTGlhYmlsaXR5LCByZWFkIHRoZSBzZWN0aW9uICpMZWdhbCBMaW1pdGF0aW9ucyogb2Yg
dGhlIFN0YXJ0Q29tIENlcnRpZmljYXRpb24gQXV0aG9yaXR5IFBvbGljeSBhdmFpbGFibGUg
YXQgaHR0cDovL2NlcnQuc3RhcnRjb20ub3JnL3BvbGljeS5wZGYwEQYJYIZIAYb4QgEBBAQD
AgAHMDgGCWCGSAGG+EIBDQQrFilTdGFydENvbSBGcmVlIFNTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTANBgkqhkiG9w0BAQUFAAOCAgEAFmyZ9GYMNPXQhV59CuzaEE44HF7fpiUFS5Ey
weg78T3dRAlbB0mKKctmArexmvclmAk8jhvh3TaHK0u7aNM5Zj2gJsfyOZEdUauCe37Vzlrk
4gNXcGmXCPleWKYK34wGmkUWFjgKXlf2Ysd6AgXmvB618p70qSmD+LIU424oh0TDkBreOKk8
rENNZEXO3SipXPJzewT4F+irsfMuXGRuczE6Eri8sxHkfY+BUZo7jYn0TZNmezwD7dOaHZrz
ZVD1oNB1ny+v8OqCQ5j4aZyJecRDjkZy42Q2Eq/3JR44iZB3fsNrarnDy0RLrHiQi+fHLB5L
EUTINFInzQpdn4XBidUaePKVEFMy3YCEZnXZtWgo+2EuvoSoOMCZEoalHmdkrQYuL6lwhceW
D3yJZfWOQ1QOq92lgDmUYMA0yZZwLKMS9R9Ie70cfmu3nZD0Ijuu+PwqyvqCUqDvr0tVk+vB
tfAii6w0TiYiBKGHLHVKt+V9E9e4DGTANtLJL4YSjCMJwRuCO3NJo2pXh5Tl1njFmUNj403g
dy3hZZlyaQQaRwnmDwFWJPsfvw55qVguucQJAX6Vum0ABj6y6koQOdjQK/W/7HW/lwLFCRsI
3FU34oH7N4RDYiDK51ZLZer+bMEkkyShNOsF/5oirpt9P/FlUQqmMGqz9IgcgA38corog14=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFcjCCA1qgAwIBAgIQH51ZWtcvwgZEpYAIaeNe9jANBgkqhkiG9w0BAQUFADA/MQswCQYD
VQQGEwJUVzEwMC4GA1UECgwnR292ZXJubWVudCBSb290IENlcnRpZmljYXRpb24gQXV0aG9y
aXR5MB4XDTAyMTIwNTEzMjMzM1oXDTMyMTIwNTEzMjMzM1owPzELMAkGA1UEBhMCVFcxMDAu
BgNVBAoMJ0dvdmVybm1lbnQgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCAiIwDQYJ
KoZIhvcNAQEBBQADggIPADCCAgoCggIBAJoluOzMonWoe/fOW1mKydGGEghU7Jzy50b2iPN8
6aXfTEc2pBsBHH8eV4qNw8XRIePaJD9IK/ufLqGU5ywck9G/GwGHU5nOp/UKIXZ3/6m3xnOU
T0b3EEk3+qhZSV1qgQdW8or5BtD3cCJNtLdBuTK4sfCxw5w/cP1T3YGq2GN49thTbqGsaoQk
clSGxtKyyhwOeYHWtXBiCAEuTk8O1RGvqa/lmr/czIdtJuTJV6L7lvnM4T9TjGxMfptTCAts
F/tnyMKtsc2AtJfcdgEWFelq16TheEfOhtX7MfP6Mb40qij7cEwdScevLJ1tZqa2jWR+tSBq
nTuBto9AAGdLiYa4zGX+FVPpBMHWXx1E1wovJ5pGfaENda1UhhXcSTvxls4Pm6Dso3pdvtUq
dULle96ltqqvKKyskKw4t9VoNSZ63Pc78/1Fm9G7Q3hub/FCVGqY8A2tl+lSXunVanLeavcb
YBT0peS2cWeqH+riTcFCQP5nRhc4L0c/cZyu5SHKYS1tB6iEfC3uUSXxY5Ce/eFXiGvviiNt
sea9P63RPZYLhY3Naye7twWb7LuRqQoHEgKXTiCQ8P8NHuJBO9NAOueNXdpm5AKwB1KYXA6O
M5zCppX7VRluTI6uSw+9wThNXo+EHWbNxWCWtFJaBYmOlXqYwZE8lSOyDvR5tMl8wUohAgMB
AAGjajBoMB0GA1UdDgQWBBTMzO/MKWCkO7GStjz6MmKPrCUVOzAMBgNVHRMEBTADAQH/MDkG
BGcqBwAEMTAvMC0CAQAwCQYFKw4DAhoFADAHBgVnKgMAAAQUA5vwIhP/lSg209yewDL7MTqK
UWUwDQYJKoZIhvcNAQEFBQADggIBAECASvomyc5eMN1PhnR2WPWus4MzeKR6dBcZTulStbng
CnRiqmjKeKBMmo4sIy7VahIkv9Ro04rQ2JyftB8M3jh+Vzj8jeJPXgyfqzvS/3WXy6TjZwj/
5cAWtUgBfen5Cv8b5Wppv3ghqMKnI6mGq3ZW6A4M9hPdKmaKZEk9GhiHkASfQlK3T8v+R0F2
Ne//AHY2RTKbxkaFXeIksB7jSJaYV0eUVXoPQbFEJPPB/hprv4j9wabak2BegUqZIJxIZhm1
AHlUD7gsL0u8qV1bYH+Mh6XgUmMqvtg7hUAV/h62ZT/FS9p+tXo1KaMuephgIqP0fSdOLeq0
dDzpD6QzDxARvBMB1uUO07+1EqLhRSPAzAhuYbeJq4PjJB7mXQfnHyA+z2fI56wwbSdLaG5L
KlwCCDTb+HbkZ6MmnD+iMsJKxYEYMRBWqoTvLQr/uB930r+lWKBi5NdLkXWNiYCYfm3LU05e
r/ayl4WXudpVBrkk7tfGOB5jGxI7leFYrPLfhNVfmS8NVVvmONsuP3LpSIXLuykTjx44Vbnz
ssQwmSNOXfJIoRIM3BKQCZBUkQM8R+XVyWXgt0t97EfTsws+rZ7QdAAO671RrcDeLMDDav7v
3Aun+kbfYNucpllQdSNpc5Oy+fwC00fmcc4QAu4njIT/rEUNE1yDMuAlpYYsfPQS
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF2TCCA8GgAwIBAgIQXAuFXAvnWUHfV8w/f52oNjANBgkqhkiG9w0BAQUFADBkMQswCQYD
VQQGEwJjaDERMA8GA1UEChMIU3dpc3Njb20xJTAjBgNVBAsTHERpZ2l0YWwgQ2VydGlmaWNh
dGUgU2VydmljZXMxGzAZBgNVBAMTElN3aXNzY29tIFJvb3QgQ0EgMTAeFw0wNTA4MTgxMjA2
MjBaFw0yNTA4MTgyMjA2MjBaMGQxCzAJBgNVBAYTAmNoMREwDwYDVQQKEwhTd2lzc2NvbTEl
MCMGA1UECxMcRGlnaXRhbCBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczEbMBkGA1UEAxMSU3dpc3Nj
b20gUm9vdCBDQSAxMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA0LmwqAzZuz8h
+BvVM5OAFmUgdbI9m2BtRsiMMW8Xw/qabFbtPMWRV8PNq5ZJkCoZSx6jbVfd8StiKHVFXqrW
W/oLJdihFvkcxC7mlSpnzNApbjyFNDhhSbEAn9Y6cV9Nbc5fuankiX9qUvrKm/LcqfmdmUc/
TilftKaNXXsLmREDA/7n29uj/x2lzZAeAR81sH8A25Bvxn570e56eqeqDFdvpG3FEzuwpdnt
Mhy0XmeLVNxzh+XTF3xmUHJd1BpYwdnP2IkCb6dJtDZd0KTeByy2dbcokdaXvij1mB7qWybJ
vbCXc9qukSbraMH5ORXWZ0sKbU/Lz7DkQnGMU3nn7uHbHaBuHYwadzVcFh4rUx80i9Fs/PJn
B3r1re3WmquhsUvhzDdf/X/NTa64H5xD+SpYVUNFvJbNcA78yeNmuk6NO4HLFWR7uZToXTNS
hXEuT46iBhFRyePLoW4xCGQMwtI89Tbo19AOeCMgkckkKmUpWyL3Ic6DXqTz3kvTaI9GdVyD
CW4pa8RwjPWd1yAv/0bSKzjCL3UcPX7ape8eYIVpQtPM+GP+HkM5haa2Y0EQs3MevNP6yn0W
R+Kn1dCjigoIlmJWbjTb2QK5MHXjBNLnj8KwEUAKrNVxAmKLMb7dxiNYMUJDLXT5xp6mig/p
/r+D5kNXJLrvRjSq1xIBOO0CAwEAAaOBhjCBgzAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0hBBYw
FDASBgdghXQBUwABBgdghXQBUwABMBIGA1UdEwEB/wQIMAYBAf8CAQcwHwYDVR0jBBgwFoAU
AyUv3m+CATpcLNwroWm1Z9SM0/0wHQYDVR0OBBYEFAMlL95vggE6XCzcK6FptWfUjNP9MA0G
CSqGSIb3DQEBBQUAA4ICAQA1EMvspgQNDQ/NwNurqPKIlwzfky9NfEBWMXrrpA9gzXrzvsMn
jgM+pN0S734edAY8PzHyHHuRMSG08NBsl9Tpl7IkVh5WwzW9iAUPWxAaZOHHgjD5Mq2eUCzn
eAXQMbFamIp1TpBcahQq4FJHgmDmHtqBsfsUC1rxn9KVuj7QG9YVHaO+htXbD8BJZLsuUBlL
0iT43R4HVtA4oJVwIHaM190e3p9xxCPvgxNcoyQVTSlAPGrEqdi3pkSlDfTgnXceQHAm/NrZ
NuR55LU/vJtlvrsRls/bxig5OgjOR1tTWsWZ/l2p3e9M1MalrQLmjAcSHm8D0W+go/MpvRLH
UKKwf4ipmXeascClOS5cfGniLLDqN2qk4Vrh9VDlg++luyqI54zb/W1elxmofmZ1a3Hqv7HH
b6D0jqTsNFFbjCYDcKF31QESVwA12yPeDooomf2xEG9L/zgtYE4snOtnta1J7ksfrK/7DZBa
ZmBwXarNeNQk7shBoJMBkpxqnvy5JMWzFYJ+vq6VK+uxwNrjAWALXmmshFZhvnEX/h0TD/7G
h0Xp/jKgGg0TpJRVcaUWi7rKibCyx/yP2FS1k2Kdzs9Z+z0YzirLNRWCXf9UIltxUvu3yf5g
mwBBZPCqKuy2QkPOiWaByIufOVQDJdMWNY6E0F/6MBr1mmz0DlP5OlvRHA==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDtzCCAp+gAwIBAgIQDOfg5RfYRv6P5WD8G/AwOTANBgkqhkiG9w0BAQUFADBlMQswCQYD
VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
Y29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgQ0EwHhcNMDYxMTEwMDAw
MDAwWhcNMzExMTEwMDAwMDAwWjBlMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQg
SW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1
cmVkIElEIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCtDhXO5EOA
XLGH87dg+XESpa7cJpSIqvTO9SA5KFhgDPiA2qkVlTJhPLWxKISKityfCgyDF3qPkKyK53lT
XDGEKvYPmDI2dsze3Tyoou9q+yHyUmHfnyDXH+Kx2f4YZNISW1/5WBg1vEfNoTb5a3/UsDg+
wRvDjDPZ2C8Y/igPs6eD1sNuRMBhNZYW/lmci3Zt1/GiSw0r/wty2p5g0I6QNcZ4VYcgoc/l
bQrISXwxmDNsIumH0DJaoroTghHtORedmTpyoeb6pNnVFzF1roV9Iq4/AUaG9ih5yLHa5FcX
xH4cDrC0kqZWs72yl+2qp/C3xag/lRbQ/6GW6whfGHdPAgMBAAGjYzBhMA4GA1UdDwEB/wQE
AwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRF66Kv9JLLgjEtUYunpyGd823IDzAf
BgNVHSMEGDAWgBRF66Kv9JLLgjEtUYunpyGd823IDzANBgkqhkiG9w0BAQUFAAOCAQEAog68
3+Lt8ONyc3pklL/3cmbYMuRCdWKuh+vy1dneVrOfzM4UKLkNl2BcEkxY5NM9g0lFWJc1aRqo
R+pWxnmrEthngYTffwk8lOa4JiwgvT2zKIn3X/8i4peEH+ll74fg38FnSbNd67IJKusm7Xi+
fT8r87cmNW1fiQG2SVufAQWbqz0lwcy2f8Lxb4bG+mRo64EtlOtCt/qMHt1i8b5QZ7dsvfPx
H2sMNgcWfzd8qVttevESRmCD1ycEvkvOl77DZypoEd+A5wwzZr8TDRRu838fYxAe+o0bJW1s
j6W3YQGx0qMmoRBxna3iw/nDmVG3KwcIzi7mULKn+gpFL6Lw8g==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBhMQswCQYD
VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
Y29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBDQTAeFw0wNjExMTAwMDAwMDBa
Fw0zMTExMTAwMDAwMDBaMGExCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMx
GTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBS
b290IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4jvhEXLeqKTTo1eqUKKP
C3eQyaKl7hLOllsBCSDMAZOnTjC3U/dDxGkAV53ijSLdhwZAAIEJzs4bg7/fzTtxRuLWZscF
s3YnFo97nh6Vfe63SKMI2tavegw5BmV/Sl0fvBf4q77uKNd0f3p4mVmFaG5cIzJLv07A6Fpt
43C/dxC//AH2hdmoRBBYMql1GNXRor5H4idq9Joz+EkIYIvUX7Q6hL+hqkpMfT7PT19sdl6g
SzeRntwi5m3OFBqOasv+zbMUZBfHWymeMr/y7vrTC0LUq7dBMtoM1O/4gdW7jVg/tRvoSSii
cNoxBN33shbyTApOB6jtSj1etX+jkMOvJwIDAQABo2MwYTAOBgNVHQ8BAf8EBAMCAYYwDwYD
VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUA95QNVbRTLtm8KPiGxvDl7I90VUwHwYDVR0jBBgw
FoAUA95QNVbRTLtm8KPiGxvDl7I90VUwDQYJKoZIhvcNAQEFBQADggEBAMucN6pIExIK+t1E
nE9SsPTfrgT1eXkIoyQY/EsrhMAtudXH/vTBH1jLuG2cenTnmCmrEbXjcKChzUyImZOMkXDi
qw8cvpOp/2PV5Adg06O/nVsJ8dWO41P0jmP6P6fbtGbfYmbW0W5BjfIttep3Sp+dWOIrWcBA
I+0tKIJFPnlUkiaY4IBIqDfv8NZ5YBberOgOzW6sRBc4L0na4UU+Krk2U886UAb3LujEV0ls
YSEY1QSteDwsOoBrp+uvFRTp2InBuThs4pFsiv9kuXclVzDAGySj4dzp30d8tbQkCAUw7C29
C79Fv1C5qfPrmAESrciIxpg0X40KPMbp1ZWVbd4=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDxTCCAq2gAwIBAgIQAqxcJmoLQJuPC3nyrkYldzANBgkqhkiG9w0BAQUFADBsMQswCQYD
VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
Y29tMSswKQYDVQQDEyJEaWdpQ2VydCBIaWdoIEFzc3VyYW5jZSBFViBSb290IENBMB4XDTA2
MTExMDAwMDAwMFoXDTMxMTExMDAwMDAwMFowbDELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERp
Z2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTErMCkGA1UEAxMiRGlnaUNl
cnQgSGlnaCBBc3N1cmFuY2UgRVYgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
AQoCggEBAMbM5XPm+9S75S0tMqbf5YE/yc0lSbZxKsPVlDRnogocsF9ppkCxxLeyj9CYpKlB
WTrT3JTWPNt0OKRKzE0lgvdKpVMSOO7zSW1xkX5jtqumX8OkhPhPYlG++MXs2ziS4wblCJEM
xChBVfvLWokVfnHoNb9Ncgk9vjo4UFt3MRuNs8ckRZqnrG0AFFoEt7oT61EKmEFBIk5lYYeB
QVCmeVyJ3hlKV9Uu5l0cUyx+mM0aBhakaHPQNAQTXKFx01p8VdteZOE3hzBWBOURtCmAEvF5
OYiiAhF8J2a3iLd48soKqDirCmTCv2ZdlYTBoSUeh10aUAsgEsxBu24LUTi4S8sCAwEAAaNj
MGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFLE+w2kD+L9H
AdSYJhoIAu9jZCvDMB8GA1UdIwQYMBaAFLE+w2kD+L9HAdSYJhoIAu9jZCvDMA0GCSqGSIb3
DQEBBQUAA4IBAQAcGgaX3NecnzyIZgYIVyHbIUf4KmeqvxgydkAQV8GK83rZEWWONfqe/EW1
ntlMMUu4kehDLI6zeM7b41N5cdblIZQB2lWHmiRk9opmzN6cN82oNLFpmyPInngiK3BD41VH
MWEZ71jFhS9OMPagMRYjyOfiZRYzy78aG6A9+MpeizGLYAiJLQwGXFK3xPkKmNEVX58Svnw2
Yzi9RKR/5CYrCsSXaQ3pjOLAEFe4yHYSkVXySGnYvCoCWw9E1CAx2/S6cCZdkGCevEsXCS+0
yx5DaMkHJ8HSXPfqIbloEpw8nL+e/IBcm2PN7EeqJSdnoDfzAIJ9VNep+OkuE6N36B9K
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDkjCCAnqgAwIBAgIRAIW9S/PY2uNp9pTXX8OlRCMwDQYJKoZIhvcNAQEFBQAwPTELMAkG
A1UEBhMCRlIxETAPBgNVBAoTCENlcnRwbHVzMRswGQYDVQQDExJDbGFzcyAyIFByaW1hcnkg
Q0EwHhcNOTkwNzA3MTcwNTAwWhcNMTkwNzA2MjM1OTU5WjA9MQswCQYDVQQGEwJGUjERMA8G
A1UEChMIQ2VydHBsdXMxGzAZBgNVBAMTEkNsYXNzIDIgUHJpbWFyeSBDQTCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBANxQltAS+DXSCHh6tlJw/W/uz7kRy1134ezpfgSN1sxv
c0NXYKwzCkTsA18cgCSR5aiRVhKC9+Ar9NuuYS6JEI1rbLqzAr3VNsVINyPi8Fo3UjMXEuLR
YE2+L0ER4/YXJQyLkcAbmXuZVg2v7tK8R1fjeUl7NIknJITesezpWE7+Tt9avkGtrAjFGA7v
0lPubNCdEgETjdyAYveVqUSISnFOYFWe2yMZeVYHDD9jC1yw4r5+FfyUM1hBOHTE4Y+L3yas
H7WLO7dDWWuwJKZtkIvEcupdM5i3y95ee++U8Rs+yskhwcWYAqqi9lt3m/V+llU0HGdpwPFC
40es/CgcZlUCAwEAAaOBjDCBiTAPBgNVHRMECDAGAQH/AgEKMAsGA1UdDwQEAwIBBjAdBgNV
HQ4EFgQU43Mt38sOKAze3bOkynm4jrvoMIkwEQYJYIZIAYb4QgEBBAQDAgEGMDcGA1UdHwQw
MC4wLKAqoCiGJmh0dHA6Ly93d3cuY2VydHBsdXMuY29tL0NSTC9jbGFzczIuY3JsMA0GCSqG
SIb3DQEBBQUAA4IBAQCnVM+IRBnL39R/AN9WM2K191EBkOvDP9GIROkkXe/nFL0gt5o8AP5t
n9uQ3Nf0YtaLcF3n5QRIqWh8yfFC82x/xXp8HVGIutIKPidd3i1RTtMTZGnkLuPT55sJmabg
lZvOGtd/vjzOUrMRFcEPF80Du5wlFbqidon8BvEY0JNLDnyCt6X09l/+7UCmnYR0ObncHoUW
2ikbhiMAybuJfm6AiB4vFLQDJKgybwOaRywwvlbGp0ICcBvqQNi6BQNwB6SW//1IMwrh3KWB
kJtN3X3n57LNXMhqlfil9o3EXXgIvnsG1knPGTZQIy4I5p4FTUcY1Rbpsda2ENW7l7+ijrRU
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDSjCCAjKgAwIBAgIQRK+wgNajJ7qJMDmGLvhAazANBgkqhkiG9w0BAQUFADA/MSQwIgYD
VQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMTDkRTVCBSb290IENB
IFgzMB4XDTAwMDkzMDIxMTIxOVoXDTIxMDkzMDE0MDExNVowPzEkMCIGA1UEChMbRGlnaXRh
bCBTaWduYXR1cmUgVHJ1c3QgQ28uMRcwFQYDVQQDEw5EU1QgUm9vdCBDQSBYMzCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAN+v6ZdQCINXtMxiZfaQguzH0yxrMMpb7NnDfcdA
wRgUi+DoM3ZJKuM/IUmTrE4Orz5Iy2Xu/NMhD2XSKtkyj4zl93ewEnu1lcCJo6m67XMuegwG
MoOifooUMM0RoOEqOLl5CjH9UL2AZd+3UWODyOKIYepLYYHsUmu5ouJLGiifSKOeDNoJjj4X
Lh7dIN9bxiqKqy69cK3FCxolkHRyxXtqqzTWMIn/5WgTe1QLyNau7Fqckh49ZLOMxt+/yUFw
7BZy1SbsOFU5Q9D8/RhcQPGX69Wam40dutolucbY38EVAjqr2m7xPi71XAicPNaDaeQQmxkq
tilX4+U9m5/wAl0CAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYw
HQYDVR0OBBYEFMSnsaR7LHH62+FLkHX/xBVghYkQMA0GCSqGSIb3DQEBBQUAA4IBAQCjGiyb
FwBcqR7uKGY3Or+Dxz9LwwmglSBd49lZRNI+DT69ikugdB/OEIKcdBodfpga3csTS7MgROSR
6cz8faXbauX+5v3gTt23ADq1cEmv8uXrAvHRAosZy5Q6XkjEGB5YGV8eAlrwDPGxrancWYaL
bumR9YbK+rlmM6pZW87ipxZzR8srzJmwN0jP41ZL9c8PDHIyh8bwRLtTcm1D9SZImlJnt1ir
/md2cXjbDaJWFBM5JDGFoqgCWjBH4d1QB7wCCZAA62RjYJsWvIjJEubSfZGL+T0yjWW06Xyx
V3bqxbYoOb8VZRzI9neWagqNdwvYkQsEjgfbKbYK7p2CNTUQ
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIECTCCAvGgAwIBAgIQDV6ZCtadt3js2AdWO4YV2TANBgkqhkiG9w0BAQUFADBbMQswCQYD
VQQGEwJVUzEgMB4GA1UEChMXRGlnaXRhbCBTaWduYXR1cmUgVHJ1c3QxETAPBgNVBAsTCERT
VCBBQ0VTMRcwFQYDVQQDEw5EU1QgQUNFUyBDQSBYNjAeFw0wMzExMjAyMTE5NThaFw0xNzEx
MjAyMTE5NThaMFsxCzAJBgNVBAYTAlVTMSAwHgYDVQQKExdEaWdpdGFsIFNpZ25hdHVyZSBU
cnVzdDERMA8GA1UECxMIRFNUIEFDRVMxFzAVBgNVBAMTDkRTVCBBQ0VTIENBIFg2MIIBIjAN
BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuT31LMmU3HWKlV1j6IR3dma5WZFcRt2SPp/5
DgO0PWGSvSMmtWPuktKe1jzIDZBfZIGxqAgNTNj50wUoUrQBJcWVHAx+PhCEdc/BGZFjz+io
kYi5Q1K7gLFViYsx+tC3dr5BPTCapCIlF3PoHuLTrCq9Wzgh1SpL11V94zpVvddtawJXa+ZH
fAjIgrrep4c9oW24MFbCswKBXy314powGCi4ZtPLAZZv6opFVdbgnf9nKxcCpk4aahELfrd7
55jWjHZvwTvbUJN+5dCOHze4vbrGn2zpfDPyMjwmR/onJALJfh1biEITajV8fTXpLmaRcpPV
MibEdPVTo7NdmvYJywIDAQABo4HIMIHFMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQD
AgHGMB8GA1UdEQQYMBaBFHBraS1vcHNAdHJ1c3Rkc3QuY29tMGIGA1UdIARbMFkwVwYKYIZI
AWUDAgEBATBJMEcGCCsGAQUFBwIBFjtodHRwOi8vd3d3LnRydXN0ZHN0LmNvbS9jZXJ0aWZp
Y2F0ZXMvcG9saWN5L0FDRVMtaW5kZXguaHRtbDAdBgNVHQ4EFgQUCXIGThhDD+XWzMNqizF7
eI+og7gwDQYJKoZIhvcNAQEFBQADggEBAKPYjtay284F5zLNAdMEA+V25FYrnJmQ6AgwbN99
Pe7lv7UkQIRJ4dEorsTCOlMwiPH1d25Ryvr/ma8kXxug/fKshMrfqfBfBC6tFr8hlxCBPeP/
h40y3JTlR4peahPJlJU90u7INJXQgNStMgiAVDzgvVJT11J8smk/f3rPanTK+gQqnExaBqXp
IK1FZg9p8d2/6eMyi/rgwYZNcjwu2JN4Cir42NInPRmJX1p7ijvMDNpRrscL9yuwNwXsvFcj
4jjSm2jzVhKIT0J8uDHEtdvkyCE06UgRNe76x5JXxZ805Mf29w4LTJxoeHtxMcfrHuBnQfO3
oKfN5XozNmr6mis=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFujCCA6KgAwIBAgIJALtAHEP1Xk+wMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNVBAYTAkNI
MRUwEwYDVQQKEwxTd2lzc1NpZ24gQUcxHzAdBgNVBAMTFlN3aXNzU2lnbiBHb2xkIENBIC0g
RzIwHhcNMDYxMDI1MDgzMDM1WhcNMzYxMDI1MDgzMDM1WjBFMQswCQYDVQQGEwJDSDEVMBMG
A1UEChMMU3dpc3NTaWduIEFHMR8wHQYDVQQDExZTd2lzc1NpZ24gR29sZCBDQSAtIEcyMIIC
IjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAr+TufoskDhJuqVAtFkQ7kpJcyrhdhJJC
Eyq8ZVeCQD5XJM1QiyUqt2/876LQwB8CJEoTlo8jE+YoWACjR8cGp4QjK7u9lit/VcyLwVcf
DmJlD909Vopz2q5+bbqBHH5CjCA12UNNhPqE21Is8w4ndwtrvxEvcnifLtg+5hg3Wipy+dpi
kJKVyh+c6bM8K8vzARO/Ws/BtQpgvd21mWRTuKCWs2/iJneRjOBiEAKfNA+k1ZIzUd6+jbqE
emA8atufK+ze3gE/bk3lUIbLtK/tREDFylqM2tIrfKjuvqblCqoOpd8FUrdVxyJdMmqXl2MT
28nbeTZ7hTpKxVKJ+STnnXepgv9VHKVxaSvRAiTysybUa9oEVeXBCsdtMDeQKuSeFDNeFhdV
xVu1yzSJkvGdJo+hB9TGsnhQ2wwMC3wLjEHXuendjIj3o02yMszYF9rNt85mndT9Xv+9lz4p
ded+p2JYryU0pUHHPbwNUMoDAw8IWh+Vc3hiv69yFGkOpeUDDniOJihC8AcLYiAQZzlG+qkD
zAQ4embvIIO1jEpWjpEA/I5cgt6IoMPiaG59je883WX0XaxR7ySArqpWl2/5rX3aYT+Ydzyl
kbYcjCbaZaIJbcHiVOO5ykxMgI93e2CaHt+28kgeDrpOVG2Y4OGiGqJ3UM/EY5LsRxmd6+Zr
zsECAwEAAaOBrDCBqTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4E
FgQUWyV7lqRlUX64OfPAeGZe6Drn8O4wHwYDVR0jBBgwFoAUWyV7lqRlUX64OfPAeGZe6Drn
8O4wRgYDVR0gBD8wPTA7BglghXQBWQECAQEwLjAsBggrBgEFBQcCARYgaHR0cDovL3JlcG9z
aXRvcnkuc3dpc3NzaWduLmNvbS8wDQYJKoZIhvcNAQEFBQADggIBACe645R88a7A3hfm5djV
9VSwg/S7zV4Fe0+fdWavPOhWfvxyeDgD2StiGwC5+OlgzczOUYrHUDFu4Up+GC9pWbY9ZIEr
44OE5iKHjn3g7gKZYbge9LgriBIWhMIxkziWMaa5O1M/wySTVltpkuzFwbs4AOPsF6m43Md8
AYOfMke6UiI0HTJ6CVanfCU2qT1L2sCCbwq7EsiHSycR+R4tx5M/nttfJmtS2S6K8RTGRI0V
qbe/vd6mGu6uLftIdxf+u+yvGPUqUfA5hJeVbG4bwyvEdGB5JbAKJ9/fXtI5z0V9Qkvfsywe
xcZdylU6oJxpmo/a77KwPJ+HbBIrZXAVUjEaJM9vMSNQH4xPjyPDdEFjHFWoFN0+4FFQz/Eb
MFYOkrCChdiDyyJkvC24JdVUorgG6q2SpCSgwYa1ShNqR88uC1aVVMvOmttqtKay20EIhid3
92qgQmwLOM7XdVAyksLfKzAiSNDVQTglXaTpXZ/GlHXQRf0wl0OPkKsKx4ZzYEppLd6leNcG
2mqeSz53OiATIgHQv2ieY2BrNU0LbbqhPcCT4H8js1WtciVORvnSFu+wZMEBnunKoGqYDs/Y
YPIvSbjkQuE4NRb0yG5P94FW6LqjviOvrv1vA+ACOzB2+httQc8Bsem4yWb02ybzOqR08kkk
W8mw0FfB+j564ZfJ
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFvTCCA6WgAwIBAgIITxvUL1S7L0swDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCQ0gx
FTATBgNVBAoTDFN3aXNzU2lnbiBBRzEhMB8GA1UEAxMYU3dpc3NTaWduIFNpbHZlciBDQSAt
IEcyMB4XDTA2MTAyNTA4MzI0NloXDTM2MTAyNTA4MzI0NlowRzELMAkGA1UEBhMCQ0gxFTAT
BgNVBAoTDFN3aXNzU2lnbiBBRzEhMB8GA1UEAxMYU3dpc3NTaWduIFNpbHZlciBDQSAtIEcy
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAxPGHf9N4Mfc4yfjDmUO8x/e8N+dO
cbpLj6VzHVxumK4DV644N0MvFz0fyM5oEMF4rhkDKxD6LHmD9ui5aLlV8gREpzn5/ASLHvGi
TSf5YXu6t+WiE7brYT7QbNHm+/pe7R20nqA1W6GSy/BJkv6FCgU+5tkL4k+73JU3/JHpMjUi
0R86TieFnbAVlDLaYQ1HTWBCrpJH6INaUFjpiou5XaHc3ZlKHzZnu0jkg7Y360g6rw9njxcH
6ATK72oxh9TAtvmUcXtnZLi2kUpCe2UuMGoM9ZDulebyzYLs2aFK7PayS+VFheZteJMELpyC
bTapxDFkH4aDCyr0NQp4yVXPQbBH6TCfmb5hqAaEuSh6XzjZG6k4sIN/c8HDO0gqgg8hm7jM
qDXDhBuDsz6+pJVpATqJAHgE2cn0mRmrVn5bi4Y5FZGkECwJMoBgs5PAKrYYC51+jUnyEEp/
+dVGLxmSo5mnJqy7jDzmDrxHB9xzUfFwZC8I+bRHHTBsROopN4WSaGa8gzj+ezku01DwH/te
YLappvonQfGbGHLy9YR0SslnxFSuSGTfjNFusB3hB48IHpmccelM2KX3RxIfdNFRnobzwqIj
QAtz20um53MGjMGg6cFZrEb65i/4z3GcRm25xBWNOHkDRUjvxF3XCO6HOSKGsg0PWEP3calI
Lv3q1h8CAwEAAaOBrDCBqTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
HQ4EFgQUF6DNweRBtjpbO8tFnb0cwpj6hlgwHwYDVR0jBBgwFoAUF6DNweRBtjpbO8tFnb0c
wpj6hlgwRgYDVR0gBD8wPTA7BglghXQBWQEDAQEwLjAsBggrBgEFBQcCARYgaHR0cDovL3Jl
cG9zaXRvcnkuc3dpc3NzaWduLmNvbS8wDQYJKoZIhvcNAQEFBQADggIBAHPGgeAn0i0P4JUw
4ppBf1AsX19iYamGamkYDHRJ1l2E6kFSGG9YrVBWIGrGvShpWJHckRE1qTodvBqlYJ7YH39F
kWnZfrt4csEGDyrOj4VwYaygzQu4OSlWhDJOhrs9xCrZ1x9y7v5RoSJBsXECYxqCsGKrXlcS
H9/L3XWgwF15kIwb4FDm3jH+mHtwX6WQ2K34ArZv02DdQEsixT2tOnqfGhpHkXkzuoLcMmkD
lm4fS/Bx/uNncqCxv1yL5PqZIseEuRuNI5c/7SXgz2W79WEE790eslpBIlqhn10s6FvJbakM
DHiqYMZWjwFaDGi8aRl5xB9+lwW/xekkUV7U1UtT7dkjWjYDZaPBA61BMPNGG4WQr2W11bHk
Flt4dR2Xem1ZqSqPe97Dh4kQmUlzeMg9vVE1dCrV8X5pGyq7O70luJpaPXJhkGaH7gzWTdQR
dAtq/gsD/KNVV4n+SsuuWxcFyPKNIzFTONItaj+CuY0IavdeQXRuwxF+B6wpYJE/OMpXEA29
MC/HpeZBoNquBYeaoKRlbEwJDIm6uNO5wJOKMPqN5ZprFQFOZ6raYlY+hAhm0sQ2fac+EPyI
4NSA5QC9qvNOBqN6avlicuMJT+ubDgEj8Z+7fNzcbBGXJbLytGMU0gYqZ4yD9c7qB9iaah7s
5Aq7KkzrCWA5zspi2C5u
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDfDCCAmSgAwIBAgIQGKy1av1pthU6Y2yv2vrEoTANBgkqhkiG9w0BAQUFADBYMQswCQYD
VQQGEwJVUzEWMBQGA1UEChMNR2VvVHJ1c3QgSW5jLjExMC8GA1UEAxMoR2VvVHJ1c3QgUHJp
bWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjExMjcwMDAwMDBaFw0zNjA3MTYy
MzU5NTlaMFgxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMTEwLwYDVQQD
EyhHZW9UcnVzdCBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvrgVe//UfH1nrYNke8hCUy3f9oQIIGHWAVlqnEQRr+92
/ZV+zmEwu3qDXwK9AWbK7hWNb6EwnL2hhZ6UOvNWiAAxz9juapYC2e0DjPt1befquFUWBRaa
9OBesYjAZIVcFU2Ix7e64HXprQU9nceJSOC7KMgD4TCTZF5SwFlwIjVXiIrxlQqD17wxcwE0
7e9GceBrAqg1cmuXm2bgyxx5X9gaBGgeRwLmnWDiNpcB3841kt++Z8dtd1k7j53WkBWUvEI0
EME5+bEnPn7WinXFsq+W06Lem+SYvn3h6YGttm/81w7a4DSwDRp35+MImO9Y+pyEtzavwt+s
0vQQBnBxNQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAdBgNV
HQ4EFgQULNVQQZcVi/CPNmFbSvtr2ZnJM5IwDQYJKoZIhvcNAQEFBQADggEBAFpwfyzdtzRP
9YZRqSa+S7iq8XEN3GHHoOo0Hnp3DwQ16CePbJC/kRYkRj5KTs4rFtULUh38H2eiAkUxT87z
+gOneZ1TatnaYzr4gNfTmeGl4b7UVXGYNTq+k+qurUKykG/g/CFNNWMziUnWm07Kx+dOCQD3
2sfvmWKZd7aVIl6KoKv0uHiYyjgZmclynnjNS6yvGaBzEi38wkG6gZHaFloxt/m0cYASSJly
c1pZU8FjUjPtp8nSOQJw+uCxQmYpqptR7TBUIhRf2asdweSU8Pj1K/fqynhG1riR/aYNKxoU
AT6A8EKglQdebc3MS6RFjasS6LPeWuWgfOgPIh1a6Vk=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEIDCCAwigAwIBAgIQNE7VVyDV7exJ9C/ON9srbTANBgkqhkiG9w0BAQUFADCBqTELMAkG
A1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMfQ2VydGlmaWNhdGlv
biBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYGA1UECxMvKGMpIDIwMDYgdGhhd3RlLCBJbmMuIC0g
Rm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxHzAdBgNVBAMTFnRoYXd0ZSBQcmltYXJ5IFJvb3Qg
Q0EwHhcNMDYxMTE3MDAwMDAwWhcNMzYwNzE2MjM1OTU5WjCBqTELMAkGA1UEBhMCVVMxFTAT
BgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMfQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcyBE
aXZpc2lvbjE4MDYGA1UECxMvKGMpIDIwMDYgdGhhd3RlLCBJbmMuIC0gRm9yIGF1dGhvcml6
ZWQgdXNlIG9ubHkxHzAdBgNVBAMTFnRoYXd0ZSBQcmltYXJ5IFJvb3QgQ0EwggEiMA0GCSqG
SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCsoPD7gFnUnMekz52hWXMJEEUMDSxuaPFsW0hoSVk3
/AszGcJ3f8wQLZU0HObrTQmnHNK4yZc2AreJ1CRfBsDMRJSUjQJib+ta3RGNKJpchJAQeg29
dGYvajig4tVUROsdB58Hum/u6f1OCyn1PoSgAfGcq/gcfomk6KHYcWUNo1F77rzSImANuVud
37r8UVsLr5iy6S7pBOhih94ryNdOwUxkHt3Ph1i6Sk/KaAcdHJ1KxtUvkcx8cXIcxcBn6zL9
yZJclNqFwJu/U30rCfSMnZEfl2pSy94JNqR32HuHUETVPm4pafs5SSYeCaWAe0At6+gnhcn+
Yf1+5nyXHdWdAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0G
A1UdDgQWBBR7W0XPr87Lev0xkhpqtvNG61dIUDANBgkqhkiG9w0BAQUFAAOCAQEAeRHAS7OR
tvzw6WfUDW5FvlXok9LOAz/t2iWwHVfLHjp2oEzsUHboZHIMpKnxuIvW1oeEuzLlQRHAd9mz
YJ3rG9XRbkREqaYB7FViHXe4XI5ISXycO1cRrK1zN44veFyQaEfZYGDm/Ac9IiAXxPcW6cTY
cvnIc3zfFi8VqT79aie2oetaupgf1eNNZAqdE8hhuvU5HIe6uL17In/2/qxAeeWsEG89jxt5
dovEN7MhGITlNgDrYyCZuen+MwS7QcjBAvlEYyCegc5C09Y/LHbTY5xZ3Y+m4Q6gLkH3LpVH
z7z9M/P2C2F+fpErgUfCJzDupxBdN49cOSvkBPB7jVaMaA==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIE0zCCA7ugAwIBAgIQGNrRniZ96LtKIVjNzGs7SjANBgkqhkiG9w0BAQUFADCByjELMAkG
A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBU
cnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBWZXJpU2lnbiwgSW5jLiAtIEZvciBh
dXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBDbGFzcyAzIFB1YmxpYyBQ
cmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzUwHhcNMDYxMTA4MDAwMDAwWhcN
MzYwNzE2MjM1OTU5WjCByjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMu
MR8wHQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNiBW
ZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJp
U2lnbiBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0g
RzUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvJAgIKXo1nmAMqudLO07cfLw8
RRy7K+D+KQL5VwijZIUVJ/XxrcgxiV0i6CqqpkKzj/i5Vbext0uz/o9+B1fs70PbZmIVYc9g
DaTY3vjgw2IIPVQT60nKWVSFJuUrjxuf6/WhkcIzSdhDY2pSS9KP6HBRTdGJaXvHcPaz3BJ0
23tdS1bTlr8Vd6Gw9KIl8q8ckmcY5fQGBO+QueQA5N06tRn/Arr0PO7gi+s3i+z016zy9vA9
r911kTMZHRxAy3QkGSGT2RT+rCpSx4/VBEnkjWNHiDxpg8v+R70rfk/Fla4OndTRQ8Bnc+MU
CH7lP59zuDMKz10/NIeWiu5T6CUVAgMBAAGjgbIwga8wDwYDVR0TAQH/BAUwAwEB/zAOBgNV
HQ8BAf8EBAMCAQYwbQYIKwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJaW1hZ2UvZ2lmMCEwHzAH
BgUrDgMCGgQUj+XTGoasjY5rw8+AatRIGCx7GS4wJRYjaHR0cDovL2xvZ28udmVyaXNpZ24u
Y29tL3ZzbG9nby5naWYwHQYDVR0OBBYEFH/TZafC3ey78DAJ80M5+gKvMzEzMA0GCSqGSIb3
DQEBBQUAA4IBAQCTJEowX2LP2BqYLz3q3JktvXf2pXkiOOzEp6B4Eq1iDkVwZMXnl2YtmAl+
X6/WzChl8gGqCBpH3vn5fJJaCGkgDdk+bW48DW7Y5gaRQBi5+MHt39tBquCWIMnNZBU4gcmU
7qKEKQsTb47bDN0lAtukixlE0kF6BWlKWE9gyn6CagsCqiUXObXbf+eEZSqVir2G3l6BFoMt
EMze/aiCKm0oHw0LxOXnGiYZ4fQRbxC1lfznQgUy286dUV4otp6F01vvpX1FQHKOtw5rDgb7
MzVIcbidJ4vEZV8NhnacRHr2lVz2XTIIM6RUthg/aFzyQkqFOFSDX9HoLPKsEdao7WNq
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDuDCCAqCgAwIBAgIQDPCOXAgWpa1Cf/DrJxhZ0DANBgkqhkiG9w0BAQUFADBIMQswCQYD
VQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24xFzAVBgNVBAMTDlNl
Y3VyZVRydXN0IENBMB4XDTA2MTEwNzE5MzExOFoXDTI5MTIzMTE5NDA1NVowSDELMAkGA1UE
BhMCVVMxIDAeBgNVBAoTF1NlY3VyZVRydXN0IENvcnBvcmF0aW9uMRcwFQYDVQQDEw5TZWN1
cmVUcnVzdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKukgeWVzfX2FI7C
T8rU4niVWJxB4Q2ZQCQXOZEzZum+4YOvYlyJ0fwkW2Gz4BERQRwdbvC4u/jep4G6pkjGnx29
vo6pQT64lO0pGtSO0gMdA+9tDWccV9cGrcrI9f4Or2YlSASWC12juhbDCE/RRvgUXPLIXgGZ
bf2IzIaowW8xQmxSPmjL8xk037uHGFaAJsTQ3MBv396gwpEWoGQRS0S8Hvbn+mPeZqx2pHGj
7DaUaHp3pLHnDi+BeuK1cobvomuL8A/b01k/unK8RCSc43Oz969XL0Imnal0ugBS8kvNU3xH
CzaFDmapCJcWNFfBZveA4+1wVMeT4C4oFVmHursCAwEAAaOBnTCBmjATBgkrBgEEAYI3FAIE
Bh4EAEMAQTALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUQjK2FvoE
/f5dS3rD/fdMQB1aQ68wNAYDVR0fBC0wKzApoCegJYYjaHR0cDovL2NybC5zZWN1cmV0cnVz
dC5jb20vU1RDQS5jcmwwEAYJKwYBBAGCNxUBBAMCAQAwDQYJKoZIhvcNAQEFBQADggEBADDt
T0rhWDpSclu1pqNlGKa7UTt36Z3q059c4EVlew3KW+JwULKUBRSuSceNQQcSc5R+DCMh/bwQ
f2AQWnL1mA6s7Ll/3XpvXdMc9P+IBWlCqQVxyLesJugutIxq/3HcuLHfmbx8IVQr5Fiiu1cp
rp6poxkmD5kuCLDv/WnPmRoJjeOnnyvJNjR7JLN4TJUXpAYmHrZkUjZfYGfZnMUFdAvnZyPS
CPyI6a6Lf+Ew9Dd+/cYy2i2eRDAwbO4H3tI0/NL/QPZL9GZGBlSm8jIKYyYwa5vR3ItHuuG5
1WLQoqD0ZwV4KWMabwTW+MZMo5qxN7SN5ShLHZ4swrhovO0C7jE=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDvDCCAqSgAwIBAgIQB1YipOjUiolN9BPI8PjqpTANBgkqhkiG9w0BAQUFADBKMQswCQYD
VQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24xGTAXBgNVBAMTEFNl
Y3VyZSBHbG9iYWwgQ0EwHhcNMDYxMTA3MTk0MjI4WhcNMjkxMjMxMTk1MjA2WjBKMQswCQYD
VQQGEwJVUzEgMB4GA1UEChMXU2VjdXJlVHJ1c3QgQ29ycG9yYXRpb24xGTAXBgNVBAMTEFNl
Y3VyZSBHbG9iYWwgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCvNS7YrGxV
aQZx5RNoJLNP2MwhR/jxYDiJiQPpvepeRlMJ3Fz1Wuj3RSoC6zFh1ykzTM7HfAo3fg+6Mpjh
HZevj8fcyTiW89sa/FHtaMbQbqR8JNGuQsiWUGMu4P51/pinX0kuleM5M2SOHqRfkNJnPLLZ
/kG5VacJjnIFHovdRIWCQtBJwB1g8NEXLJXr9qXBkqPFwqcIYA1gBBCWeZ4WNOaptvolRTnI
HmX5k/Wq8VLcmZg9pYYaDDUz+kulBAYVHDGA76oYa8J719rO+TMg1fW9ajMtgQT7sFzUnKPi
XB3jqUJ1XnvUd+85VLrJChgbEplJL4hL/VBi0XPnj3pDAgMBAAGjgZ0wgZowEwYJKwYBBAGC
NxQCBAYeBABDAEEwCwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFK9E
BMJBfkiD2045AuzshHrmzsmkMDQGA1UdHwQtMCswKaAnoCWGI2h0dHA6Ly9jcmwuc2VjdXJl
dHJ1c3QuY29tL1NHQ0EuY3JsMBAGCSsGAQQBgjcVAQQDAgEAMA0GCSqGSIb3DQEBBQUAA4IB
AQBjGghAfaReUw132HquHw0LURYD7xh8yOOvaliTFGCRsoTciE6+OYo68+aCiV0BN7OrJKQV
DpI1WkpEXk5X+nXOH0jOZvQ8QCaSmGwb7iRGDBezUqXbpZGRzzfTb+cnCDpOGR86p1hcF895
P4vkp9MmI50mD1hp/Ed+stCNi5O/KU9DaXR2Z0vPB4zmAve14bRDtUstFJ/53CYNv6ZHdAbY
iNE6KTCEztI5gGIbqMdXSbxqVVFnFUq+NQfk1XWYN3kwFNspnWzFacxHVaIw98xcf8LDmBxr
ThaA63p4ZUWiABqvDA1VZDRIuJK58bRQKfJPIx/abKwfROHdI3hRW8cW
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEHTCCAwWgAwIBAgIQToEtioJl4AsC7j41AkblPTANBgkqhkiG9w0BAQUFADCBgTELMAkG
A1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9y
ZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxJzAlBgNVBAMTHkNPTU9ETyBDZXJ0aWZp
Y2F0aW9uIEF1dGhvcml0eTAeFw0wNjEyMDEwMDAwMDBaFw0yOTEyMzEyMzU5NTlaMIGBMQsw
CQYDVQQGEwJHQjEbMBkGA1UECBMSR3JlYXRlciBNYW5jaGVzdGVyMRAwDgYDVQQHEwdTYWxm
b3JkMRowGAYDVQQKExFDT01PRE8gQ0EgTGltaXRlZDEnMCUGA1UEAxMeQ09NT0RPIENlcnRp
ZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0ECL
i3LjkRv3UcEbVASY06m/weaKXTuH+7uIzg3jLz8GlvCiKVCZrts7oVewdFFxze1CkU1B/qnI
2GqGd0S7WWaXUF601CxwRM/aN5VCaTwwxHGzUvAhTaHYujl8HJ6jJJ3ygxaYqhZ8Q5sVW7eu
NJH+1GImGEaaP+vB+fGQV+useg2L23IwambV4EajcNxo2f8ESIl33rXp+2dtQem8Ob0y2WIC
8bGoPW43nOIv4tOiJovGuFVDiOEjPqXSJDlqR6sA1KGzqSX+DT+nHbrTUcELpNqsOO9VUCQF
ZUaTNE8tja3G1CEZ0o7KBWFxB3NH5YoZEr0ETc5OnKVIrLsm9wIDAQABo4GOMIGLMB0GA1Ud
DgQWBBQLWOWLxkwVN6RAqTCpIb5HNlpW/zAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUw
AwEB/zBJBgNVHR8EQjBAMD6gPKA6hjhodHRwOi8vY3JsLmNvbW9kb2NhLmNvbS9DT01PRE9D
ZXJ0aWZpY2F0aW9uQXV0aG9yaXR5LmNybDANBgkqhkiG9w0BAQUFAAOCAQEAPpiem/Yb6dc5
t3iuHXIYSdOH5EOC6z/JqvWote9VfCFSZfnVDeFs9D6Mk3ORLgLETgdxb8CPOGEIqB6BCsAv
IC9Bi5HcSEW88cbeunZrM8gALTFGTO3nnc+IlP8zwFboJIYmuNg4ON8qa90SzMc/RxdMosIG
lgnW2/4/PEZB31jiVg88O8EckzXZOFKs7sjsLjBOlDW0JB9LeGna8gI4zJVSk/BwJVmcIGfE
7vmLV2H0knZ9P4SNVbfo5azV8fUZVqZa+5Acr5Pr5RzUZ5ddBA6+C4OmF4O5MBKgxTMVBbkN
+8cFduPYSo38NBejxiEovjBFMR7HeL5YYTisO+IBZQ==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID5jCCAs6gAwIBAgIQV8szb8JcFuZHFhfjkDFo4DANBgkqhkiG9w0BAQUFADBiMQswCQYD
VQQGEwJVUzEhMB8GA1UEChMYTmV0d29yayBTb2x1dGlvbnMgTC5MLkMuMTAwLgYDVQQDEydO
ZXR3b3JrIFNvbHV0aW9ucyBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcNMDYxMjAxMDAwMDAw
WhcNMjkxMjMxMjM1OTU5WjBiMQswCQYDVQQGEwJVUzEhMB8GA1UEChMYTmV0d29yayBTb2x1
dGlvbnMgTC5MLkMuMTAwLgYDVQQDEydOZXR3b3JrIFNvbHV0aW9ucyBDZXJ0aWZpY2F0ZSBB
dXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDkvH6SMG3G2I4rC7xG
zuAnlt7e+foS0zwzc7MEL7xxjOWftiJgPl9dzgn/ggwbmlFQGiaJ3dVhXRncEg8tCqJDXRfQ
NJIg6nPPOCwGJgl6cvf6UDL4wpPTaaIjzkGxzOTVHzbRijr4jGPiFFlp7Q3Tf2vouAPlT2rl
mGNpSAW+Lv8ztumXWWn4Zxmuk2GWRBXTcrA/vGp97Eh/jcOrqnErU2lBUzS1sLnFBgrEsEX1
QV1uiUV7PTsmjHTC5dLRfbIR1PtYMiKagMnc/Qzpf14Dl847ABSHJ3A4qY5usyd2mFHgBeMh
qxrVhSI8KbWaFsWAqPS7azCPL0YCorEMIuDTAgMBAAGjgZcwgZQwHQYDVR0OBBYEFCEwyfsA
106Y2oeqKtCnLrFAMadMMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MFIGA1Ud
HwRLMEkwR6BFoEOGQWh0dHA6Ly9jcmwubmV0c29sc3NsLmNvbS9OZXR3b3JrU29sdXRpb25z
Q2VydGlmaWNhdGVBdXRob3JpdHkuY3JsMA0GCSqGSIb3DQEBBQUAA4IBAQC7rkvnt1frf6ot
t3NHhWrB5KUd5Oc86fRZZXe1eltajSU24HqXLjjAV2CDmAaDn7l2em5Q4LqILPxFzBiwmZVR
DuwduIj/h1AcgsLj4DKAv6ALR8jDMe+ZZzKATxcheQxpXN5eNK4CtSbqUN9/GGUsyfJj4akH
/nxxH2szJGoeBfcFaMBqEssuXmHLrijTfsK0ZpEmXzwuJF/LWA/rKOyvEZbz3HtvwKeI8lN3
s2Berq4o2jUsbzRF0ybh3uxbTydrFny9RAQYgrOJeRcQcT16ohZO9QHNpGxlaKFJdlxDydi8
NmdspZS11My5vWo1ViHe2MPr+8ukYEywVaCge1ey
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEvTCCA6WgAwIBAgIBATANBgkqhkiG9w0BAQUFADCBhTELMAkGA1UEBhMCVVMxIDAeBgNV
BAoMF1dlbGxzIEZhcmdvIFdlbGxzU2VjdXJlMRwwGgYDVQQLDBNXZWxscyBGYXJnbyBCYW5r
IE5BMTYwNAYDVQQDDC1XZWxsc1NlY3VyZSBQdWJsaWMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRo
b3JpdHkwHhcNMDcxMjEzMTcwNzU0WhcNMjIxMjE0MDAwNzU0WjCBhTELMAkGA1UEBhMCVVMx
IDAeBgNVBAoMF1dlbGxzIEZhcmdvIFdlbGxzU2VjdXJlMRwwGgYDVQQLDBNXZWxscyBGYXJn
byBCYW5rIE5BMTYwNAYDVQQDDC1XZWxsc1NlY3VyZSBQdWJsaWMgUm9vdCBDZXJ0aWZpY2F0
ZSBBdXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDub7S9eeKPCCGe
OARBJe+rWxxTkqxtnt3CxC5FlAM1iGd0V+PfjLindo8796jE2yljDpFoNoqXjopxaAkH5OjU
Dk/41itMpBb570OYj7OeUt9tkTmPOL13i0Nj67eT/DBMHAGTthP796EfvyXhdDcsHqRePGj4
S78NuR4uNuip5Kf4D8uCdXw1LSLWwr8L87T8bJVhHlfXBIEyg1J55oNjz7fLY4sR4r1e6/aN
7ZVyKLSsEmLpSjPmgzKuBXWVvYSV2ypcm44uDLiBK0HmOFafSZtsdvqKXfcBeYF8wYNABf5x
/Qw/zE5gCQ5lRxAvAcAFP4/4s0HvWkJ+We/SlwxlAgMBAAGjggE0MIIBMDAPBgNVHRMBAf8E
BTADAQH/MDkGA1UdHwQyMDAwLqAsoCqGKGh0dHA6Ly9jcmwucGtpLndlbGxzZmFyZ28uY29t
L3dzcHJjYS5jcmwwDgYDVR0PAQH/BAQDAgHGMB0GA1UdDgQWBBQmlRkQ2eihl5H/3BnZtQQ+
0nMKajCBsgYDVR0jBIGqMIGngBQmlRkQ2eihl5H/3BnZtQQ+0nMKaqGBi6SBiDCBhTELMAkG
A1UEBhMCVVMxIDAeBgNVBAoMF1dlbGxzIEZhcmdvIFdlbGxzU2VjdXJlMRwwGgYDVQQLDBNX
ZWxscyBGYXJnbyBCYW5rIE5BMTYwNAYDVQQDDC1XZWxsc1NlY3VyZSBQdWJsaWMgUm9vdCBD
ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQEwDQYJKoZIhvcNAQEFBQADggEBALkVsUSRzCPIK013
4/iaeycNzXK7mQDKfGYZUMbVmO2rvwNa5U3lHshPcZeG1eMd/ZDJPHV3V3p9+N701NX3leZ0
bh08rnyd2wIDBSxxSyU+B+NemvVmFymIGjifz6pBA4SXa5M4esowRBskRDPQ5NHcKDj0E0M1
NSljqHyita04pO2t/caaH/+Xc/77szWnk4bGdpEA5qxRFsQnMlzbc9qlk1eOPm01JghZ1edE
13YgY+esE2fDbbFwRnzVlhE9iW9dqKHrjQrawx0zbKPqZxmamX9LPYNRKh3KL4YMon4QLSvU
FpULB6ouFJJJtylv2G0xffX8oRAHh84vWdw+WNs=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICiTCCAg+gAwIBAgIQH0evqmIAcFBUTAGem2OZKjAKBggqhkjOPQQDAzCBhTELMAkGA1UE
BhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEa
MBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBFQ0MgQ2VydGlm
aWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwMzA2MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCBhTEL
MAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2Fs
Zm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBFQ0Mg
Q2VydGlmaWNhdGlvbiBBdXRob3JpdHkwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQDR3svdcmC
FYX7deSRFtSrYpn1PlILBs5BAH+X4QokPB0BBO490o0JlwzgdeT6+3eKKvUDYEs2ixYjFq0J
cfRK9ChQtP6IHG4/bC8vCVlbpVsLM5niwz2J+Wos77LTBumjQjBAMB0GA1UdDgQWBBR1cacZ
SBm8nZ3qQUfflMRId5nTeTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAKBggq
hkjOPQQDAwNoADBlAjEA7wNbeqy3eApyt4jf/7VGFAkK+qDmfQjGGoe9GKhzvSbKYAydzpmf
z1wPMOG+FDHqAjAU9JM8SaczepBGR7NjfRObTrdvGDeAU/7dIOA1mjbRxwG55tzd8/8dLDoW
V9mSOdY=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEAjCCAuqgAwIBAgIFORFFEJQwDQYJKoZIhvcNAQEFBQAwgYUxCzAJBgNVBAYTAkZSMQ8w
DQYDVQQIEwZGcmFuY2UxDjAMBgNVBAcTBVBhcmlzMRAwDgYDVQQKEwdQTS9TR0ROMQ4wDAYD
VQQLEwVEQ1NTSTEOMAwGA1UEAxMFSUdDL0ExIzAhBgkqhkiG9w0BCQEWFGlnY2FAc2dkbi5w
bS5nb3V2LmZyMB4XDTAyMTIxMzE0MjkyM1oXDTIwMTAxNzE0MjkyMlowgYUxCzAJBgNVBAYT
AkZSMQ8wDQYDVQQIEwZGcmFuY2UxDjAMBgNVBAcTBVBhcmlzMRAwDgYDVQQKEwdQTS9TR0RO
MQ4wDAYDVQQLEwVEQ1NTSTEOMAwGA1UEAxMFSUdDL0ExIzAhBgkqhkiG9w0BCQEWFGlnY2FA
c2dkbi5wbS5nb3V2LmZyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsh/R0GLF
MzvABIaIs9z4iPf930Pfeo2aSVz2TqrMHLmh6yeJ8kbpO0px1R2OLc/mratjUMdUC24SyZA2
xtgv2pGqaMVy/hcKshd+ebUyiHDKcMCWSo7kVc0dJ5S/znIq7Fz5cyD+vfcuiWe4u0dzEvfR
NWk68gq5rv9GQkaiv6GFGvm/5P9JhfejcIYyHF2fYPepraX/z9E0+X1bF8bc1g4oa8Ld8fUz
aJ1O/Id8NhLWo4DoQw1VYZTqZDdH6nfK0LJYBcNdfrGoRpAxVs5wKpayMLh35nnAvSk7/ZR3
TL0gzUEl4C7HG7vupARB0l2tEmqKm0f7yd1GQOGdPDPQtQIDAQABo3cwdTAPBgNVHRMBAf8E
BTADAQH/MAsGA1UdDwQEAwIBRjAVBgNVHSAEDjAMMAoGCCqBegF5AQEBMB0GA1UdDgQWBBSj
BS8YYFDCiQrdKyFP/45OqDAxNjAfBgNVHSMEGDAWgBSjBS8YYFDCiQrdKyFP/45OqDAxNjAN
BgkqhkiG9w0BAQUFAAOCAQEABdwm2Pp3FURo/C9mOnTgXeQp/wYHE4RKq89toB9RlPhJy3Q2
FLwV3duJL92PoF189RLrn544pEfMs5bZvpwlqwN+Mw+VgQ39FuCIvjfwbF3QMZsyK10XZZOY
YLxuj7GoPB7ZHPOpJkL5ZB3C55L29B5aqhlSXa/oovdgoPaN8In1buAKBQGVyYsgCrpa/Jos
PL3Dt8ldeCUFP1YUmwza+zpI/pdpXsoQhvdOlgQITeywvl3cO45Pwf2aNjSaTFR+FwNIlQgR
HAdvhQh+XU3Endv7rs6y0bO4g2wdsrN58dhwmX7wEwLOXt1R0982gaEbeC9xs/FZTEYYKKuF
0mBWWg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDfTCCAmWgAwIBAgIBADANBgkqhkiG9w0BAQUFADBgMQswCQYDVQQGEwJKUDElMCMGA1UE
ChMcU0VDT00gVHJ1c3QgU3lzdGVtcyBDTy4sTFRELjEqMCgGA1UECxMhU2VjdXJpdHkgQ29t
bXVuaWNhdGlvbiBFViBSb290Q0ExMB4XDTA3MDYwNjAyMTIzMloXDTM3MDYwNjAyMTIzMlow
YDELMAkGA1UEBhMCSlAxJTAjBgNVBAoTHFNFQ09NIFRydXN0IFN5c3RlbXMgQ08uLExURC4x
KjAoBgNVBAsTIVNlY3VyaXR5IENvbW11bmljYXRpb24gRVYgUm9vdENBMTCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBALx/7FebJOD+nLpCeamIivqA4PUHKUPqjgo0No0c+qe1
OXj/l3X3L+SqawSERMqm4miO/VVQYg+kcQ7OBzgtQoVQrTyWb4vVog7P3kmJPdZkLjjlHmy1
V4qe70gOzXppFodEtZDkBp2uoQSXWHnvIEqCa4wiv+wfD+mEce3xDuS4GBPMVjZd0ZoeUWs5
bmB2iDQL87PRsJ3KYeJkHcFGB7hj3R4zZbOOCVVSPbW9/wfrrWFVGCypaZhKqkDFMxRldAD5
kd6vA0jFQFTcD4SQaCDFkpbcLuUCRarAX1T4bepJz11sS6/vmsJWXMY1VkJqMF/Cq/biPT+z
yRGPMUzXn0kCAwEAAaNCMEAwHQYDVR0OBBYEFDVK9U2vP9eCOKyrcWUXdYydVZPmMA4GA1Ud
DwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBBQUAA4IBAQCoh+ns+EBn
XcPBZsdAS5f8hxOQWsTvoMpfi7ent/HWtWS3irO4G8za+6xmiEHO6Pzk2x6Ipu0nUBsCMCRG
ef4Eh3CXQHPRwMFXGZpppSeZq51ihPZRwSzJIxXYKLerJRO1RuGGAv8mjMSIkh1W/hln8lXk
gKNrnKt34VFxDSDbEJrbvXZ5B3eZKK2aXtqxT0QsNY6llsf9g/BYxnnWmHyojf6GPgcWkuF7
5x3sM3Z+Qi5KhfmRiWiEA4Glm5q+4zfFVKtWOxgtQaQM+ELbmaDgcm+7XeEWT1MKZPlO9L9O
VL14bIjqv5wTJMJwaaJ/D8g8rQjJsJhAoyrniIPtd490
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID8TCCAtmgAwIBAgIQQT1yx/RrH4FDffHSKFTfmjANBgkqhkiG9w0BAQUFADCBijELMAkG
A1UEBhMCQ0gxEDAOBgNVBAoTB1dJU2VLZXkxGzAZBgNVBAsTEkNvcHlyaWdodCAoYykgMjAw
NTEiMCAGA1UECxMZT0lTVEUgRm91bmRhdGlvbiBFbmRvcnNlZDEoMCYGA1UEAxMfT0lTVEUg
V0lTZUtleSBHbG9iYWwgUm9vdCBHQSBDQTAeFw0wNTEyMTExNjAzNDRaFw0zNzEyMTExNjA5
NTFaMIGKMQswCQYDVQQGEwJDSDEQMA4GA1UEChMHV0lTZUtleTEbMBkGA1UECxMSQ29weXJp
Z2h0IChjKSAyMDA1MSIwIAYDVQQLExlPSVNURSBGb3VuZGF0aW9uIEVuZG9yc2VkMSgwJgYD
VQQDEx9PSVNURSBXSVNlS2V5IEdsb2JhbCBSb290IEdBIENBMIIBIjANBgkqhkiG9w0BAQEF
AAOCAQ8AMIIBCgKCAQEAy0+zAJs9Nt350UlqaxBJH+zYK7LG+DKBKUOVTJoZIyEVRd7jyBxR
VVuuk+g3/ytr6dTqvirdqFEr12bDYVxgAsj1znJ7O7jyTmUIms2kahnBAbtzptf2w93NvKSL
tZlhuAGio9RN1AU9ka34tAhxZK9w8RxrfvbDd50kc3vkDIzh2TbhmYsFmQvtRTEJysIA2/dy
oJaqlYfQjse2YXMNdmaM3Bu0Y6Kff5MTMPGhJ9vZ/yxViJGg4E8HsChWjBgbl0SOid3gF27n
Ku+POQoxhILYQBRJLnpB5Kf+42TMwVlxSywhp1t94B3RLoGbw9ho972WG6xwsRYUC9tguSYB
BQIDAQABo1EwTzALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUswN+
rja8sHnR3JQmthG+IbJphpQwEAYJKwYBBAGCNxUBBAMCAQAwDQYJKoZIhvcNAQEFBQADggEB
AEuh/wuHbrP5wUOxSPMowB0uyQlB+pQAHKSkq0lPjz0e701vvbyk9vImMMkQyh2I+3QZH4VF
vbBsUfk2ftv1TDI6QU9bR8/oCy22xBmddMVHxjtqD6wU2zz0c5ypBd8A3HR4+vg1YFkCExh8
vPtNsCBtQ7tgMHpnM1zFmdH4LTlSc/uMqpclXHLZCB6rTjzjgTGfA6b7wP4piFXahNVQA7bi
hKOmNqoROgHhGEvWRGizPflTdISzRpFGlgC3gCy24eMQ4tui5yiPAZZiFj4A4xylNoEYokxS
dsARo27mHbrjWr42U8U+dY+GaSlYU7Wcu2+fXMUY7N0v4ZjJ/L7fCg0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIHqDCCBpCgAwIBAgIRAMy4579OKRr9otxmpRwsDxEwDQYJKoZIhvcNAQEFBQAwcjELMAkG
A1UEBhMCSFUxETAPBgNVBAcTCEJ1ZGFwZXN0MRYwFAYDVQQKEw1NaWNyb3NlYyBMdGQuMRQw
EgYDVQQLEwtlLVN6aWdubyBDQTEiMCAGA1UEAxMZTWljcm9zZWMgZS1Temlnbm8gUm9vdCBD
QTAeFw0wNTA0MDYxMjI4NDRaFw0xNzA0MDYxMjI4NDRaMHIxCzAJBgNVBAYTAkhVMREwDwYD
VQQHEwhCdWRhcGVzdDEWMBQGA1UEChMNTWljcm9zZWMgTHRkLjEUMBIGA1UECxMLZS1Temln
bm8gQ0ExIjAgBgNVBAMTGU1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EwggEiMA0GCSqGSIb3
DQEBAQUAA4IBDwAwggEKAoIBAQDtyADVgXvNOABHzNuEwSFpLHSQDCHZU4ftPkNEU6+r+ICb
PHiN1I2uuO/TEdyB5s87lozWbxXGd36hL+BfkrYn13aaHUM86tnsL+4582pnS4uCzyL4ZVX+
LMsvfUh6PXX5qqAnu3jCBspRwn5mS6/NoqdNAoI/gqyFxuEPkEeZlApxcpMqyabAvjxWTHOS
J/FrtfX9/DAFYJLG65Z+AZHCabEeHXtTRbjcQR/Ji3HWVBTji1R4P770Yjtb9aPs1ZJ04nQw
7wHb4dSrmZsqa/i9phyGI0Jf7Enemotb9HI6QMVJPqW+jqpx62z69Rrkav17fVVA71hu5tnV
vCSrwe+3AgMBAAGjggQ3MIIEMzBnBggrBgEFBQcBAQRbMFkwKAYIKwYBBQUHMAGGHGh0dHBz
Oi8vcmNhLmUtc3ppZ25vLmh1L29jc3AwLQYIKwYBBQUHMAKGIWh0dHA6Ly93d3cuZS1zemln
bm8uaHUvUm9vdENBLmNydDAPBgNVHRMBAf8EBTADAQH/MIIBcwYDVR0gBIIBajCCAWYwggFi
BgwrBgEEAYGoGAIBAQEwggFQMCgGCCsGAQUFBwIBFhxodHRwOi8vd3d3LmUtc3ppZ25vLmh1
L1NaU1ovMIIBIgYIKwYBBQUHAgIwggEUHoIBEABBACAAdABhAG4A+gBzAO0AdAB2AOEAbgB5
ACAA6QByAHQAZQBsAG0AZQB6AOkAcwDpAGgAZQB6ACAA6QBzACAAZQBsAGYAbwBnAGEAZADh
AHMA4QBoAG8AegAgAGEAIABTAHoAbwBsAGcA4QBsAHQAYQB0APMAIABTAHoAbwBsAGcA4QBs
AHQAYQB0AOEAcwBpACAAUwB6AGEAYgDhAGwAeQB6AGEAdABhACAAcwB6AGUAcgBpAG4AdAAg
AGsAZQBsAGwAIABlAGwAagDhAHIAbgBpADoAIABoAHQAdABwADoALwAvAHcAdwB3AC4AZQAt
AHMAegBpAGcAbgBvAC4AaAB1AC8AUwBaAFMAWgAvMIHIBgNVHR8EgcAwgb0wgbqggbeggbSG
IWh0dHA6Ly93d3cuZS1zemlnbm8uaHUvUm9vdENBLmNybIaBjmxkYXA6Ly9sZGFwLmUtc3pp
Z25vLmh1L0NOPU1pY3Jvc2VjJTIwZS1Temlnbm8lMjBSb290JTIwQ0EsT1U9ZS1Temlnbm8l
MjBDQSxPPU1pY3Jvc2VjJTIwTHRkLixMPUJ1ZGFwZXN0LEM9SFU/Y2VydGlmaWNhdGVSZXZv
Y2F0aW9uTGlzdDtiaW5hcnkwDgYDVR0PAQH/BAQDAgEGMIGWBgNVHREEgY4wgYuBEGluZm9A
ZS1zemlnbm8uaHWkdzB1MSMwIQYDVQQDDBpNaWNyb3NlYyBlLVN6aWduw7MgUm9vdCBDQTEW
MBQGA1UECwwNZS1TemlnbsOzIEhTWjEWMBQGA1UEChMNTWljcm9zZWMgS2Z0LjERMA8GA1UE
BxMIQnVkYXBlc3QxCzAJBgNVBAYTAkhVMIGsBgNVHSMEgaQwgaGAFMegSXUWYYTbMUuE0vE3
QJDvTtz3oXakdDByMQswCQYDVQQGEwJIVTERMA8GA1UEBxMIQnVkYXBlc3QxFjAUBgNVBAoT
DU1pY3Jvc2VjIEx0ZC4xFDASBgNVBAsTC2UtU3ppZ25vIENBMSIwIAYDVQQDExlNaWNyb3Nl
YyBlLVN6aWdubyBSb290IENBghEAzLjnv04pGv2i3GalHCwPETAdBgNVHQ4EFgQUx6BJdRZh
hNsxS4TS8TdAkO9O3PcwDQYJKoZIhvcNAQEFBQADggEBANMTnGZjWS7KXHAM/IO8VbH0jgds
ZifOwTsgqRy7RlRw7lrMoHfqaEQn6/Ip3Xep1fvj1KcExJW4C+FEaGAHQzAxQmHl7tnlJNUb
3+FKG6qfx1/4ehHqE5MAyopYse7tDk2016g2JnzgOsHVV4Lxdbb9iV/a86g4nzUGCM4ilb7N
1fy+W955a9x6qWVmvrElWl/tftOsRm1M9DKHtCAE4Gx4sHfRhUZLphK3dehKyVZs15KrnfVJ
ONJPU+NVkBHbmJbGSfI+9J8b4PeI3CVimUTYc78/MPMMNz7UwiiAc7EBt51alhQBS6kRnSlq
LtBdgcDPsiBDxwPgN05dCtxZICU=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDqDCCApCgAwIBAgIJAP7c4wEPyUj/MA0GCSqGSIb3DQEBBQUAMDQxCzAJBgNVBAYTAkZS
MRIwEAYDVQQKDAlEaGlteW90aXMxETAPBgNVBAMMCENlcnRpZ25hMB4XDTA3MDYyOTE1MTMw
NVoXDTI3MDYyOTE1MTMwNVowNDELMAkGA1UEBhMCRlIxEjAQBgNVBAoMCURoaW15b3RpczER
MA8GA1UEAwwIQ2VydGlnbmEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDIaPHJ
1tazNHUmgh7stL7qXOEm7RFHYeGifBZ4QCHkYJ5ayGPhxLGWkv8YbWkj4Sti993iNi+RB7lI
zw7sebYs5zRLcAglozyHGxnygQcPOJAZ0xH+hrTy0V4eHpbNgGzOOzGTtvKg0KmVEn2lmsxr
yIRWijOp5yIVUxbwzBfsV1/pogqYCd7jX5xv3EjjhQsVWqa6n6xI4wmy9/Qy3l40vhx4XUJb
zg4ij02Q130yGLMLLGq/jj8UEYkgDncUtT2UCIf3JR7VsmAA7G8qKCVuKj4YYxclPz5EIBb2
JsglrgVKtOdjLPOMFlN+XPsRGgjBRmKfIrjxwo1p3Po6WAbfAgMBAAGjgbwwgbkwDwYDVR0T
AQH/BAUwAwEB/zAdBgNVHQ4EFgQUGu3+QTmQtCRZvgHyUtVF9lo53BEwZAYDVR0jBF0wW4AU
Gu3+QTmQtCRZvgHyUtVF9lo53BGhOKQ2MDQxCzAJBgNVBAYTAkZSMRIwEAYDVQQKDAlEaGlt
eW90aXMxETAPBgNVBAMMCENlcnRpZ25hggkA/tzjAQ/JSP8wDgYDVR0PAQH/BAQDAgEGMBEG
CWCGSAGG+EIBAQQEAwIABzANBgkqhkiG9w0BAQUFAAOCAQEAhQMeknH2Qq/ho2Ge6/PAD/Kl
1NqV5ta+aDY9fm4fTIrv0Q8hbV6lUmPOEvjvKtpv6zf+EwLHyzs+ImvaYS5/1HI93TDhHkxA
GYwP15zRgzB7mFncfca5DClMoTOi62c6ZYTTluLtdkVwj7Ur3vkj1kluPBS1xp81HlDQwY9q
cEQCYsuuHWhBp6pX6FOqB9IG9tUUBguRA3UsbHK1YZWaDYu5Def131TN3ubY1gkIl2PlwS6w
t0QmwCbAr1UwnjvVNioZBPRcHv/PLLf/0P2HQBHVESO7SMAhqaQoLf0V+LBOK/QwWyH8EZE0
vkHve52Xdf+XlcCWWC/qu0bXu+TZLg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDnzCCAoegAwIBAgIBJjANBgkqhkiG9w0BAQUFADBxMQswCQYDVQQGEwJERTEcMBoGA1UE
ChMTRGV1dHNjaGUgVGVsZWtvbSBBRzEfMB0GA1UECxMWVC1UZWxlU2VjIFRydXN0IENlbnRl
cjEjMCEGA1UEAxMaRGV1dHNjaGUgVGVsZWtvbSBSb290IENBIDIwHhcNOTkwNzA5MTIxMTAw
WhcNMTkwNzA5MjM1OTAwWjBxMQswCQYDVQQGEwJERTEcMBoGA1UEChMTRGV1dHNjaGUgVGVs
ZWtvbSBBRzEfMB0GA1UECxMWVC1UZWxlU2VjIFRydXN0IENlbnRlcjEjMCEGA1UEAxMaRGV1
dHNjaGUgVGVsZWtvbSBSb290IENBIDIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
AQCrC6M14IspFLEUha88EOQ5bzVdSq7d6mGNlUn0b2SjGmBmpKlAIoTZ1KXleJMOaAGtuU1c
Os7TuKhCQN/Po7qCWWqSG6wcmtoIKyUn+WkjR/Hg6yx6m/UTAtB+NHzCnjwAWav12gz1Mjwr
rFDa1sPeg5TKqAyZMg4ISFZbavva4VhYAUlfckE8FQYBjl2tqriTtM2e66foai1SNNs671x1
Udrb8zH57nGYMsRUFUQM+ZtV7a3fGAigo4aKSe5TBY8ZTNXeWHmb0mocQqvF1afPaA+W5OFh
mHZhyJF81j4A4pFQh+GdCuatl9Idxjp9y7zaAzTVjlsB9WoHtxa2bkp/AgMBAAGjQjBAMB0G
A1UdDgQWBBQxw3kbuvVT1xfgiXotF2wKsyudMzAPBgNVHRMECDAGAQH/AgEFMA4GA1UdDwEB
/wQEAwIBBjANBgkqhkiG9w0BAQUFAAOCAQEAlGRZrTlk5ynrE/5aw4sTV8gEJPB0d8Bg42f7
6Ymmg7+Wgnxu1MM9756AbrsptJh6sTtU6zkXR34ajgv8HzFZMQSyzhfzLMdiNlXiItiJVbSY
SKpk+tYcNthEeFpaIzpXl/V6ME+un2pMSyuOoAPjPuCp1NJ70rOo4nI8rZ7/gFnkm0W09juw
zTkZmDLl6iFhkOQxIY40sfcvNUqFENrnijchvllj4PKFiDFT1FQUhXB59C4Gdyd1Lx+4ivn+
xbrYNuSD7Odlt79jWvNGr4GUN9RBjNYj1h7P9WgbRGOiWrqnNVmh5XAFmw4jV5mUCm26OWMo
hpLzGITY+9HPBVZkVw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDoTCCAomgAwIBAgILBAAAAAABD4WqLUgwDQYJKoZIhvcNAQEFBQAwOzEYMBYGA1UEChMP
Q3liZXJ0cnVzdCwgSW5jMR8wHQYDVQQDExZDeWJlcnRydXN0IEdsb2JhbCBSb290MB4XDTA2
MTIxNTA4MDAwMFoXDTIxMTIxNTA4MDAwMFowOzEYMBYGA1UEChMPQ3liZXJ0cnVzdCwgSW5j
MR8wHQYDVQQDExZDeWJlcnRydXN0IEdsb2JhbCBSb290MIIBIjANBgkqhkiG9w0BAQEFAAOC
AQ8AMIIBCgKCAQEA+Mi8vRRQZhP/8NN57CPytxrHjoXxEnOmGaoQ25yiZXRadz5RfVb23CO2
1O1fWLE3TdVJDm71aofW0ozSJ8bi/zafmGWgE07GKmSb1ZASzxQG9Dvj1Ci+6A74q05IlG2O
lTEQXO2iLb3VOm2yHLtgwEZLAfVJrn5GitB0jaEMAs7u/OePuGtm839EAL9mJRQr3RAwHQeW
P032a7iPt3sMpTjr3kfb1V05/Iin89cqdPHoWqI7n1C6poxFNcJQZZXcY4Lv3b93TZxiyWNz
FtApD0mpSPCzqrdsxacwOUBdrsTiXSZT8M4cIwhhqJQZugRiQOwfOHB3EgZxpzAYXSUnpQID
AQABo4GlMIGiMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBS2
CHsNesysIEyGVjJez6tuhS1wVzA/BgNVHR8EODA2MDSgMqAwhi5odHRwOi8vd3d3Mi5wdWJs
aWMtdHJ1c3QuY29tL2NybC9jdC9jdHJvb3QuY3JsMB8GA1UdIwQYMBaAFLYIew16zKwgTIZW
Ml7Pq26FLXBXMA0GCSqGSIb3DQEBBQUAA4IBAQBW7wojoFROlZfJ+InaRcHUowAl9B8Tq7ej
hVhpwjCt2BWKLePJzYFa+HMjWqd8BfP9IjsO0QbE2zZMcwSO5bAi5MXzLqXZI+O4Tkogp24C
JJ8iYGd7ix1yCcUxXOl5n4BHPa2hCwcUPUf/A2kaDAtE52Mlp3+yybh2hO0j9n0Hq0V+09+z
v+mKts2oomcrUtW3ZfA5TGOgkXmTUg9U3YO7n9GPp1Nzw8v/MOx8BLjYRB+TX3EJIrduPuoc
A06dGiBh+4E37F78CkWr1+cXVdCg6mCbpvbjjFspwgZgFJ0tl0ypkxWdYcQBX0jWWL1WMRJO
Ecgh4LMRkWXbtKaIOM5V
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFsDCCA5igAwIBAgIQFci9ZUdcr7iXAF7kBtK8nTANBgkqhkiG9w0BAQUFADBeMQswCQYD
VQQGEwJUVzEjMCEGA1UECgwaQ2h1bmdod2EgVGVsZWNvbSBDby4sIEx0ZC4xKjAoBgNVBAsM
IWVQS0kgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNDEyMjAwMjMxMjdaFw0z
NDEyMjAwMjMxMjdaMF4xCzAJBgNVBAYTAlRXMSMwIQYDVQQKDBpDaHVuZ2h3YSBUZWxlY29t
IENvLiwgTHRkLjEqMCgGA1UECwwhZVBLSSBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA4SUP7o3biDN1Z82tH306Tm2d0y8U
82N0ywEhajfqhFAHSyZbCUNsIZ5qyNUD9WBpj8zwIuQf5/dqIjG3LBXy4P4AakP/h2XGtRrB
p0xtInAhijHyl3SJCRImHJ7K2RKilTza6We/CKBk49ZCt0Xvl/T29de1ShUCWH2YWEtgvM3X
DZoTM1PRYfl61dd4s5oz9wCGzh1NlDivqOx4UXCKXBCDUSH3ET00hl7lSM2XgYI1TBnsZfZr
xQWh7kcT1rMhJ5QQCtkkO7q+RBNGMD+XPNjX12ruOzjjK9SXDrkb5wdJfzcq+Xd4z1TtW0ad
o4AOkUPB1ltfFLqfpo0kR0BZv3I4sjZsN/+Z0V0OWQqraffAsgRFelQArr5T9rXn4fg8ozHS
qf4hUmTFpmfwdQcGlBSBVcYn5AGPF8Fqcde+S/uUWH1+ETOxQvdibBjWzwloPn9s9h6PYq2l
Y9sJpx8iQkEeb5mKPtf5P0B6ebClAZLSnT0IFaUQAS2zMnaolQ2zepr7BxB4EW/hj8e6DyUa
dCrlHJhBmd8hh+iVBmoKs2pHdmX2Os+PYhcZewoozRrSgx4hxyy/vv9haLdnG7t4TY3OZ+Xk
wY63I2binZB1NJipNiuKmpS5nezMirH4JYlcWrYvjB9teSSnUmjDhDXiZo1jDiVN1Rmy5nk3
pyKdVDECAwEAAaNqMGgwHQYDVR0OBBYEFB4M97Zn8uGSJglFwFU5Lnc/QkqiMAwGA1UdEwQF
MAMBAf8wOQYEZyoHAAQxMC8wLQIBADAJBgUrDgMCGgUAMAcGBWcqAwAABBRFsMLHClZ87lt4
DJX5GFPBphzYEDANBgkqhkiG9w0BAQUFAAOCAgEACbODU1kBPpVJufGBuvl2ICO1J2B01GqZ
NF5sAFPZn/KmsSQHRGoqxqWOeBLoR9lYGxMqXnmbnwoqZ6YlPwZpVnPDimZI+ymBV3QGypzq
KOg4ZyYr8dW1P2WT+DZdjo2NQCCHGervJ8A9tDkPJXtoUHRVnAxZfVo9QZQlUgjgRywVMRnV
vwdVxrsStZf0X4OFunHB2WyBEXYKCrC/gpf36j36+uwtqSiUO1bd0lEursC9CBWMd1I0ltab
rNMdjmEPNXubrjlpC2JgQCA2j6/7Nu4tCEoduL+bXPjqpRugc6bY+G7gMwRfaKonh+3ZwZCc
7b3jajWvY9+rGNm65ulK6lCKD2GTHuItGeIwlDWSXQ62B68ZgI9HkFFLLk3dheLSClIKF5r8
GrBQAuUBo2M3IUxExJtRmREOc5wGj1QupyheRDmHVi03vYVElOEMSyycw5KFNGHLD7ibSkNS
/jQ6fbjpKdx2qcgw+BRxgMYeNkh0IkFch4LoGHGLQYlE535YW6i4jRPpp2zDR+2zGp1iro2C
6pSe3VkQw63d4k3jMdXH7OjysP6SHhYKGvzZ8/gntsm+HbRsZJB/9OTEW9c3rkIO3aQab3yI
VMUWbuF6aC74Or8NpDyJO3inTmODBCEIZ43ygknQW/2xzQ+DhNQ+IIX3Sj0rnP0qCglN6oH4
EZw=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFFzCCA/+gAwIBAgIBETANBgkqhkiG9w0BAQUFADCCASsxCzAJBgNVBAYTAlRSMRgwFgYD
VQQHDA9HZWJ6ZSAtIEtvY2FlbGkxRzBFBgNVBAoMPlTDvHJraXllIEJpbGltc2VsIHZlIFRl
a25vbG9qaWsgQXJhxZ90xLFybWEgS3VydW11IC0gVMOcQsSwVEFLMUgwRgYDVQQLDD9VbHVz
YWwgRWxla3Ryb25payB2ZSBLcmlwdG9sb2ppIEFyYcWfdMSxcm1hIEVuc3RpdMO8c8O8IC0g
VUVLQUUxIzAhBgNVBAsMGkthbXUgU2VydGlmaWthc3lvbiBNZXJrZXppMUowSAYDVQQDDEFU
w5xCxLBUQUsgVUVLQUUgS8O2ayBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPEsSAt
IFPDvHLDvG0gMzAeFw0wNzA4MjQxMTM3MDdaFw0xNzA4MjExMTM3MDdaMIIBKzELMAkGA1UE
BhMCVFIxGDAWBgNVBAcMD0dlYnplIC0gS29jYWVsaTFHMEUGA1UECgw+VMO8cmtpeWUgQmls
aW1zZWwgdmUgVGVrbm9sb2ppayBBcmHFn3TEsXJtYSBLdXJ1bXUgLSBUw5xCxLBUQUsxSDBG
BgNVBAsMP1VsdXNhbCBFbGVrdHJvbmlrIHZlIEtyaXB0b2xvamkgQXJhxZ90xLFybWEgRW5z
dGl0w7xzw7wgLSBVRUtBRTEjMCEGA1UECwwaS2FtdSBTZXJ0aWZpa2FzeW9uIE1lcmtlemkx
SjBIBgNVBAMMQVTDnELEsFRBSyBVRUtBRSBLw7ZrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xh
ecSxY8Sxc8SxIC0gU8O8csO8bSAzMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
im1L/xCIOsP2fpTo6iBkcK4hgb46ezzb8R1Sf1n68yJMlaCQvEhOEav7t7WNeoMojCZG2E6V
QIdhn8WebYGHV2yKO7Rm6sxA/OOqbLLLAdsyv9Lrhc+hDVXDWzhXcLh1xnnRFDDtG1hba+81
8qEhTsXOfJlfbLm4IpNQp81McGq+agV/E5wrHur+R84EpW+sky58K5+eeROR6Oqeyjh1jmKw
lZMq5d/pXpduIF9fhHpEORlAHLpVK/swsoHvhOPc7Jg4OQOFCKlUAwUp8MmPi+oLhmUZEdPp
CSPeaJMDyTYcIW7OjGbxmTDY17PDHfiBLqi9ggtm/oLL4eAagsNAgQIDAQABo0IwQDAdBgNV
HQ4EFgQUvYiHyY/2pAoLquvF/pEjnatKijIwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQF
MAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAB18+kmPNOm3JpIWmgV050vQbTlswyb2zrgxvMTf
vCr4N5EY3ATIZJkrGG2AA1nJrvhY0D7twyOfaTyGOBye79oneNGEN3GKPEs5z35FBtYt2IpN
eBLWrcLTy9LQQfMmNkqblWwM7uXRQydmwYj3erMgbOqwaSvHIOgMA8RBBZniP+Rr+KCGgceE
xh/VS4ESshYhLBOhgLJeDEoTniDYYkCrkOpkSi+sDQESeUWoL4cZaMjihccwsnX5OD+ywJO0
a+IDRM5noN+J1q2MdqMTw5RhK2vZbMEHCiIHhWyFJEapvj+LeISCfiQMnf2BN+MlqO02TpUs
yZyQ2uypQjyttgI=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDUzCCAjugAwIBAgIBATANBgkqhkiG9w0BAQUFADBLMQswCQYDVQQGEwJOTzEdMBsGA1UE
CgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxHTAbBgNVBAMMFEJ1eXBhc3MgQ2xhc3MgMiBDQSAx
MB4XDTA2MTAxMzEwMjUwOVoXDTE2MTAxMzEwMjUwOVowSzELMAkGA1UEBhMCTk8xHTAbBgNV
BAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MR0wGwYDVQQDDBRCdXlwYXNzIENsYXNzIDIgQ0Eg
MTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIs8B0XY9t/mx8q6jUPFR42wWsE4
25KEHK8T1A9vNkYgxC7McXA0ojTTNy7Y3Tp3L8DrKehc0rWpkTSHIln+zNvnma+WwajHQN2l
FYxuyHyXA8vmIPLXl18xoS830r7uvqmtqEyeIWZDO6i88wmjONVZJMHCR3axiFyCO7srpgTX
jAePzdVBHfCuuCkslFJgNJQ72uA40Z0zPhX0kzLFANq1KWYOOngPIVJfAuWSeyXTkh4vFZ2B
5J2O6O+JzhRMVB0cgRJNcKi+EAUXfh/RuFdV7c27UsKwHnjCTTZoy1YmwVLBvXb3WNVyfh9E
drsAiR0WnVE1703CVu9r4Iw7DekCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4E
FgQUP42aWYv8e3uco684sDntkHGA1sgwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBBQUA
A4IBAQAVGn4TirnoB6NLJzKyQJHyIdFkhb5jatLPgcIV1Xp+DCmsNx4cfHZSldq1fyOhKXdl
yTKdqC5Wq2B2zha0jX94wNWZUYN/Xtm+DKhQ7SLHrQVMdvvt7h5HZPb3J31cKA9FxVxiXqaa
kZG3Uxcu3K1gnZZkOb1naLKuBctN518fV4bVIJwo+28TOPX2EZL2fZleHwzoq0QkKXJAPTZS
r4xYkHPB7GEseaHsh7U/2k3ZIQAw3pDaDtMaSKk+hQsUi4y8QZ5q9w5wwDX3OaJdZtB7WZ+o
RxKaJyOkLY4ng5IgodcVf/EuGO70SH8vf/GhGLWhC5SgYiAynB321O+/TIho
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF5zCCA8+gAwIBAgIITK9zQhyOdAIwDQYJKoZIhvcNAQEFBQAwgYAxODA2BgNVBAMML0VC
RyBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sxc8SxMTcwNQYDVQQK
DC5FQkcgQmlsacWfaW0gVGVrbm9sb2ppbGVyaSB2ZSBIaXptZXRsZXJpIEEuxZ4uMQswCQYD
VQQGEwJUUjAeFw0wNjA4MTcwMDIxMDlaFw0xNjA4MTQwMDMxMDlaMIGAMTgwNgYDVQQDDC9F
QkcgRWxla3Ryb25payBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPEsTE3MDUGA1UE
CgwuRUJHIEJpbGnFn2ltIFRla25vbG9qaWxlcmkgdmUgSGl6bWV0bGVyaSBBLsWeLjELMAkG
A1UEBhMCVFIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDuoIRh0DpqZhAy2DE4
f6en5f2h4fuXd7hxlugTlkaDT7byX3JWbhNgpQGR4lvFzVcfd2NR/y8927k/qqk153nQ9dAk
tiHq6yOU/im/+4mRDGSaBUorzAzu8T2bgmmkTPiab+ci2hC6X5L8GCcKqKpE+i4stPtGmggD
g3KriORqcsnlZR9uKg+ds+g75AxuetpX/dfreYteIAbTdgtsApWjluTLdlHRKJ2hGvxEok3M
enaoDT2/F08iiFD9rrbskFBKW5+VQarKD7JK/oCZTqNGFav4c0JqwmZ2sQomFd2TkuzbqV9U
IlKRcF0T6kjsbgNs2d1s/OsNA/+mgxKb8amTD8UmTDGyY5lhcucqZJnSuOl14nypqZoaqsNW
2xCaPINStnuWt6yHd6i58mcLlEOzrz5z+kI2sSXFCjEmN1ZnuqMLfdb3ic1nobc6HmZP9qBV
FCVMLDMNpkGMvQQxahByCp0OLna9XvNRiYuoP1Vzv9s6xiQFlpJIqkuNKgPlV5EQ9GooFW5H
d4RcUXSfGenmHmMWOeMRFeNYGkS9y8RsZteEBt8w9DeiQyJ50hBs37vmExH8nYQKE3vwO9D8
owrXieqWfo1IhR5kX9tUoqzVegJ5a9KK8GfaZXINFHDk6Y54jzJ0fFfy1tb0Nokb+Clsi7n2
l9GkLqq+CxnCRelwXQIDAJ3Zo2MwYTAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
BjAdBgNVHQ4EFgQU587GT/wWZ5b6SqMHwQSny2re2kcwHwYDVR0jBBgwFoAU587GT/wWZ5b6
SqMHwQSny2re2kcwDQYJKoZIhvcNAQEFBQADggIBAJuYml2+8ygjdsZs93/mQJ7ANtyVDR2t
FcU22NU57/IeIl6zgrRdu0waypIN30ckHrMk2pGI6YNw3ZPX6bqz3xZaPt7gyPvT/Wwp+BVG
oGgmzJNSroIBk5DKd8pNSe/iWtkqvTDOTLKBtjDOWU/aWR1qeqRFsIImgYZ29fUQALjuswno
T4cCB64kXPBfrAowzIpAoHMEwfuJJPaaHFy3PApnNgUIMbOv2AFoKuB4j3TeuFGkjGwgPaL7
s9QJ/XvCgKqTbCmYIai7FvOpEl90tYeY8pUm3zTvilORiF0alKM/fCL414i6poyWqD1SNGKf
AB5UVUJnxk1Gj7sURT0KlhaOEKGXmdXTMIXM3rRyt7yKPBgpaP3ccQfuJDlq+u2lrDgv+R4Q
DgZxGhBM/nV+/x5XOULK1+EVoVZVWRvRo68R2E7DpSvvkL/A7IITW43WciyTTo9qKd+FPNMN
4KIYEsxVL0e3p5sC/kH2iExt2qkBR4NkJ2IQgtYSe14DHzSpyZH+r11thie3I6p1GMog57AP
14kOpmciY/SDQSsGS7tY1dHXt7kQY9iJSrSq3RZj9W6+YKH47ejWkE8axsWgKdOnIaj1Wjz3
x0miIZpKlVIglnKaZsv30oZDfCK+lvm9AahH3eU7QPl1K5srRmSGjR70j/sHd9DqSaIcjVIU
pgqT
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDODCCAiCgAwIBAgIGIAYFFnACMA0GCSqGSIb3DQEBBQUAMDsxCzAJBgNVBAYTAlJPMREw
DwYDVQQKEwhjZXJ0U0lHTjEZMBcGA1UECxMQY2VydFNJR04gUk9PVCBDQTAeFw0wNjA3MDQx
NzIwMDRaFw0zMTA3MDQxNzIwMDRaMDsxCzAJBgNVBAYTAlJPMREwDwYDVQQKEwhjZXJ0U0lH
TjEZMBcGA1UECxMQY2VydFNJR04gUk9PVCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
AQoCggEBALczuX7IJUqOtdu0KBuqV5Do0SLTZLrTk+jUrIZhQGpgV2hUhE28alQCBf/fm5oq
rl0Hj0rDKH/v+yv6efHHrfAQUySQi2bJqIirr1qjAOm+ukbuW3N7LBeCgV5iLKECZbO9xSsA
fsT8AzNXDe3i+s5dRdY4zTW2ssHQnIFKquSyAVwdj1+ZxLGt24gh65AIgoDzMKND5pCCrlUo
Se1b16kQOA7+j0xbm0bqQfWwCHTD0IgztnzXdN/chNFDDnU5oSVAKOp4yw4sLjmdjItuFhwv
JoIQ4uNllAoEwF73XVv4EOLQunpL+943AAAaWyjj0pxzPjKHmKHJUS/X3qwzs08CAwEAAaNC
MEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAcYwHQYDVR0OBBYEFOCMm9slSbPx
fIbWskKHC9BroNnkMA0GCSqGSIb3DQEBBQUAA4IBAQA+0hyJLjX8+HXd5n9liPRyTMks1zJO
890ZeUe9jjtbkw9QSSQTaxQGcu8J06Gh40CEyecYMnQ8SG4Pn0vU9x7Tk4ZkVJdjclDVVc/6
IJMCopvDI5NOFlV2oHB5bc0hH88vLbwZ44gx+FkagQnIl6Z0x2DEW8xXjrJ1/RsCCdtZb3KT
afcxQdaIOL+Hsr0Wefmq5L6IJd1hJyMctTEHBDa0GpC9oHRxUIltvBTjD4au8as+x6AJzKNI
0eDbZOeStc+vckNwi/nDhDwTqn6Sm1dTk/pwwpEOMfmbZ13pljheX7NzTogVZ96edhBiIL5V
aZVDADlN9u6wWk5JRFRYX0KD
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDVTCCAj2gAwIBAgIESTMAATANBgkqhkiG9w0BAQUFADAyMQswCQYDVQQGEwJDTjEOMAwG
A1UEChMFQ05OSUMxEzARBgNVBAMTCkNOTklDIFJPT1QwHhcNMDcwNDE2MDcwOTE0WhcNMjcw
NDE2MDcwOTE0WjAyMQswCQYDVQQGEwJDTjEOMAwGA1UEChMFQ05OSUMxEzARBgNVBAMTCkNO
TklDIFJPT1QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDTNfc/c3et6FtzF8LR
b+1VvG7q6KR5smzDo+/hn7E7SIX1mlwhIhAsxYLO2uOabjfhhyzcuQxauohV3/2q2x8x6gHx
3zkBwRP9SFIhxFXf2tizVHa6dLG3fdfA6PZZxU3Iva0fFNrfWEQlMhkqx35+jq44sDB7R3IJ
MfAw28Mbdim7aXZOV/kbZKKTVrdvmW7bCgScEeOAH8tjlBAKqeFkgjH5jCftppkA9nCTGPih
NIaj3XrCGHn2emU1z5DrvTOTn1OrczvmmzQgLx3vqR1jGqCA2wMv+SYahtKNu6m+UjqHZ0gN
v7Sg2Ca+I19zN38m5pIEo3/PIKe38zrKy5nLAgMBAAGjczBxMBEGCWCGSAGG+EIBAQQEAwIA
BzAfBgNVHSMEGDAWgBRl8jGtKvf33VKWCscCwQ7vptU7ETAPBgNVHRMBAf8EBTADAQH/MAsG
A1UdDwQEAwIB/jAdBgNVHQ4EFgQUZfIxrSr3991SlgrHAsEO76bVOxEwDQYJKoZIhvcNAQEF
BQADggEBAEs17szkrr/Dbq2flTtLP1se31cpolnKOOK5Gv+e5m4y3R6u6jW39ZORTtpC4cMX
YFDy0VwmuYK36m3knITnA3kXr5g9lNvHugDnuL8BV8F3RTIMO/G0HAiw/VGgod2aHRM2mm23
xzy54cXZF/qD1T0VoDy7HgviyJA/qIYM/PmLXoXLT1tLYhFHxUV8BS9BsZ4QaRuZluBVeftO
hpm4lNqGOGqTo+fLbuXf6iFViZx9fX+Y9QCJ7uOEwFyWtcVG6kbghVW2G8kS1sHNzYDzAgE8
yGnLRUhj2JTQ7IUOO04RZfSCjKY9ri4ilAnIXOo8gV0WKgOXFlUJ24pBgp5mmxE=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDoDCCAoigAwIBAgIBMTANBgkqhkiG9w0BAQUFADBDMQswCQYDVQQGEwJKUDEcMBoGA1UE
ChMTSmFwYW5lc2UgR292ZXJubWVudDEWMBQGA1UECxMNQXBwbGljYXRpb25DQTAeFw0wNzEy
MTIxNTAwMDBaFw0xNzEyMTIxNTAwMDBaMEMxCzAJBgNVBAYTAkpQMRwwGgYDVQQKExNKYXBh
bmVzZSBHb3Zlcm5tZW50MRYwFAYDVQQLEw1BcHBsaWNhdGlvbkNBMIIBIjANBgkqhkiG9w0B
AQEFAAOCAQ8AMIIBCgKCAQEAp23gdE6Hj6UG3mii24aZS2QNcfAKBZuOquHMLtJqO8F6tJdh
jYq+xpqcBrSGUeQ3DnR4fl+Kf5Sk10cI/VBaVuRorChzoHvpfxiSQE8tnfWuREhzNgaeZCw7
NCPbXCbkcXmP1G55IrmTwcrNwVbtiGrXoDkhBFcsovW8R0FPXjQilbUfKW1eSvNNcr5BViCH
/OlQR9cwFO5cjFW6WY2H/CPek9AEjP3vbb3QesmlOmpyM8ZKDQUXKi17safY1vC+9D/qDiht
QWEjdnjDuGWk81quzMKq2edY3rZ+nYVunyoKb58DKTCXKB28t89UKU5RMfkntigm/qJj5kEW
8DOYRwIDAQABo4GeMIGbMB0GA1UdDgQWBBRUWssmP3HMlEYNllPqa0jQk/5CdTAOBgNVHQ8B
Af8EBAMCAQYwWQYDVR0RBFIwUKROMEwxCzAJBgNVBAYTAkpQMRgwFgYDVQQKDA/ml6XmnKzl
m73mlL/lupwxIzAhBgNVBAsMGuOCouODl+ODquOCseODvOOCt+ODp+ODs0NBMA8GA1UdEwEB
/wQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBADlqRHZ3ODrso2dGD/mLBqj7apAxzn7s2tGJ
fHrrLgy9mTLnsCTWw//1sogJhyzjVOGjprIIC8CFqMjSnHH2HZ9g/DgzE+Ge3Atf2hZQKXsv
cJEPmbo0NI2VdMV+eKlmXb3KIXdCEKxmJj3ekav9FfBv7WxfEPjzFvYDio+nEhEMy/0/ecGc
/WLuo89UDNErXxc+4z6/wCs+CZv+iKZ+tJIX/COUgb1up8WMwusRRdv4QcmWdupwX3kSa+Sj
B1oF7ydJzyGfikwJcGapJsErEU4z0g781mzSDjJkaP+tBXhfAx2o45CsJOAPQKdLrosot4LK
GAfmt1t06SAZf7IbiVQ=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID/jCCAuagAwIBAgIQFaxulBmyeUtB9iepwxgPHzANBgkqhkiG9w0BAQsFADCBmDELMAkG
A1UEBhMCVVMxFjAUBgNVBAoTDUdlb1RydXN0IEluYy4xOTA3BgNVBAsTMChjKSAyMDA4IEdl
b1RydXN0IEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTE2MDQGA1UEAxMtR2VvVHJ1
c3QgUHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEczMB4XDTA4MDQwMjAwMDAw
MFoXDTM3MTIwMTIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJ
bmMuMTkwNwYDVQQLEzAoYykgMjAwOCBHZW9UcnVzdCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQg
dXNlIG9ubHkxNjA0BgNVBAMTLUdlb1RydXN0IFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRo
b3JpdHkgLSBHMzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANziXmJYHTNXOTIz
+uvLh4yn1ErdBojqZI4xmKU4kB6Yzy5jK/BGvESyiaHAKAxJcCGVn2TAppMSAmUmhsalifD6
14SgcK9PGpc/BkTVyetyEH3kMSj7HGHmKAdEc5IiaacDiGydY8hS2pgn5whMcD60yRLBxWeD
XTPzAxHsatBT4tG6NmCUgLthY2xbF37fQJQeqw3CIShwiP/WJmxsYAQlTlV+fe+/lEjetx3d
cI0FX4ilm/LC7urRQEFtYjgdVgbFA0dRIBn8exALDmKudlW/X3e+PkkBUz2YJQN2JFodtNuJ
6nnltrM7P7pMKEF/BqxqjsHQ9gUdfeZChuOl1UcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB
/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFMR5yo6hTgMdHNxr2zFblD4/MH8tMA0GCSqG
SIb3DQEBCwUAA4IBAQAtxRPPVoB7eni9n64smefv2t+UXglpp+duaIy9cr5HqQ6XErhK8WTT
Od8lNNTBzU6B8A8ExCSzNJbGpqow32hhc9f5joWJ7w5elShKKiePEI4ufIbEAp7aDHdlDkQN
kv39sxY2+hENHYwOB4lqKVb3cvTdFZx3NWZXqxNT2I7BQMXXExZacse3aQHEerGDAWh9jUGh
lBjBJVz88P6DAod8DQ3PLghcSkANPuyBYeYk28rgDi0Hsj5W3I31QYUHSJsMC8tJP33st/3L
jWeJGqvtux6jAAgIFyqCXDFdRootD4abdNlF+9RAsXqqaC2Gspki4cErx5z481+oghLrGREt
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICiDCCAg2gAwIBAgIQNfwmXNmET8k9Jj1Xm67XVjAKBggqhkjOPQQDAzCBhDELMAkGA1UE
BhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjE4MDYGA1UECxMvKGMpIDIwMDcgdGhhd3Rl
LCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxJDAiBgNVBAMTG3RoYXd0ZSBQcmlt
YXJ5IFJvb3QgQ0EgLSBHMjAeFw0wNzExMDUwMDAwMDBaFw0zODAxMTgyMzU5NTlaMIGEMQsw
CQYDVQQGEwJVUzEVMBMGA1UEChMMdGhhd3RlLCBJbmMuMTgwNgYDVQQLEy8oYykgMjAwNyB0
aGF3dGUsIEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTEkMCIGA1UEAxMbdGhhd3Rl
IFByaW1hcnkgUm9vdCBDQSAtIEcyMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEotWcgnuVnfFS
eIf+iha/BebfowJPDQfGAFG6DAJSLSKkQjnE/o/qycG+1E3/n3qe4rF8mq2nhglzh9HnmuN6
papu+7qzcMBniKI11KOasf2twu8x+qi58/sIxpHR+ymVo0IwQDAPBgNVHRMBAf8EBTADAQH/
MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUmtgAMADna3+FGO6Lts6KDPgR4bswCgYIKoZI
zj0EAwMDaQAwZgIxAN344FdHW6fmCsO99YCKlzUNG4k8VIZ3KMqh9HneteY4sPBlcIx/AlTC
v//YoT7ZzwIxAMSNlPzcU9LcnXgWHxUzI1NS41oxXZ3Krr0TKUQNJ1uo52icEvdYPy5yAlej
j6EULg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEKjCCAxKgAwIBAgIQYAGXt0an6rS0mtZLL/eQ+zANBgkqhkiG9w0BAQsFADCBrjELMAkG
A1UEBhMCVVMxFTATBgNVBAoTDHRoYXd0ZSwgSW5jLjEoMCYGA1UECxMfQ2VydGlmaWNhdGlv
biBTZXJ2aWNlcyBEaXZpc2lvbjE4MDYGA1UECxMvKGMpIDIwMDggdGhhd3RlLCBJbmMuIC0g
Rm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxJDAiBgNVBAMTG3RoYXd0ZSBQcmltYXJ5IFJvb3Qg
Q0EgLSBHMzAeFw0wODA0MDIwMDAwMDBaFw0zNzEyMDEyMzU5NTlaMIGuMQswCQYDVQQGEwJV
UzEVMBMGA1UEChMMdGhhd3RlLCBJbmMuMSgwJgYDVQQLEx9DZXJ0aWZpY2F0aW9uIFNlcnZp
Y2VzIERpdmlzaW9uMTgwNgYDVQQLEy8oYykgMjAwOCB0aGF3dGUsIEluYy4gLSBGb3IgYXV0
aG9yaXplZCB1c2Ugb25seTEkMCIGA1UEAxMbdGhhd3RlIFByaW1hcnkgUm9vdCBDQSAtIEcz
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsr8nLPvb2FvdeHsbnndmgcs+vHyu
86YnmjSjaDFxODNi5PNxZnmxqWWjpYvVj2AtP0LMqmsywCPLLEHd5N/8YZzic7IilRFDGF/E
th9XbAoFWCLINkw6fKXRz4aviKdEAhN0cXMKQlkC+BsUa0Lfb1+6a4KinVvnSr0eAXLbS3To
O39/fR8EtCab4LRarEc9VbjXsCZSKAExQGbY2SS99irY7CFJXJv2eul/VTV+lmuNk5Mny5K7
6qxAwJ/C+IDPXfRa3M50hqY+bAtTyr2SzhkGcuYMXDhpxwTWvGzOW/b3aJzcJRVIiKHpqfiY
nODz1TEoYRFsZ5aNOZnLwkUkOQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB
/wQEAwIBBjAdBgNVHQ4EFgQUrWyqlGCc7eT/+j4KdCtjA/e2Wb8wDQYJKoZIhvcNAQELBQAD
ggEBABpA2JVlrAmSicY59BDlqQ5mU1143vokkbvnRFHfxhY0Cu9qRFHqKweKA3rD6z8KLFIW
oCtDuSWQP3CpMyVtRRooOyfPqsMpQhvfO0zAMzRbQYi/aytlryjvsvXDqmbOe1but8jLZ8HJ
nBoYuMTDSQPxYA5QzUbF83d597YV4Djbxy8ooAw/dyZ02SUS2jHaGh7cKUGRIjxpp7sC8rZc
JwOJ9Abqm+RyguOhCcHpABnTPtRwa7pxpqpYrvS76Wy274fMm7v/OeZWYdMKp8RcTGB7BXcm
er/YB1IsYvdwY9k5vG8cwnncdimvzsUsZAReiDZuMdRAGmI0Nj81Aa6sY6A=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICrjCCAjWgAwIBAgIQPLL0SAoA4v7rJDteYD7DazAKBggqhkjOPQQDAzCBmDELMAkGA1UE
BhMCVVMxFjAUBgNVBAoTDUdlb1RydXN0IEluYy4xOTA3BgNVBAsTMChjKSAyMDA3IEdlb1Ry
dXN0IEluYy4gLSBGb3IgYXV0aG9yaXplZCB1c2Ugb25seTE2MDQGA1UEAxMtR2VvVHJ1c3Qg
UHJpbWFyeSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEcyMB4XDTA3MTEwNTAwMDAwMFoX
DTM4MDExODIzNTk1OVowgZgxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMu
MTkwNwYDVQQLEzAoYykgMjAwNyBHZW9UcnVzdCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNl
IG9ubHkxNjA0BgNVBAMTLUdlb1RydXN0IFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3Jp
dHkgLSBHMjB2MBAGByqGSM49AgEGBSuBBAAiA2IABBWx6P0DFUPlrOuHNxFi79KDNlJ9RVcL
So17VDs6bl8VAsBQps8lL33KSLjHUGMcKiEIfJo22Av+0SbFWDEwKCXzXV2juLaltJLtbCyf
691DiaI8S0iRHVDsJt/WYC69IaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
AQYwHQYDVR0OBBYEFBVfNVdRVfslsq0DafwBo/q+EVXVMAoGCCqGSM49BAMDA2cAMGQCMGSW
WaboCd6LuvpaiIjwH5HTRqjySkwCY/tsXzjbLkGTqQ7mndwxHLKgpxgceeHHNgIwOlavmnRs
9vuD4DPTCF+hnMJbn0bWtsuRBmOiBuczrD6ogRLQy7rQkgu2npaqBA+K
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEuTCCA6GgAwIBAgIQQBrEZCGzEyEDDrvkEhrFHTANBgkqhkiG9w0BAQsFADCBvTELMAkG
A1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBU
cnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwOCBWZXJpU2lnbiwgSW5jLiAtIEZvciBh
dXRob3JpemVkIHVzZSBvbmx5MTgwNgYDVQQDEy9WZXJpU2lnbiBVbml2ZXJzYWwgUm9vdCBD
ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wODA0MDIwMDAwMDBaFw0zNzEyMDEyMzU5NTla
MIG9MQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNpZ24sIEluYy4xHzAdBgNVBAsTFlZl
cmlTaWduIFRydXN0IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAyMDA4IFZlcmlTaWduLCBJbmMu
IC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxODA2BgNVBAMTL1ZlcmlTaWduIFVuaXZlcnNh
bCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAx2E3XrEBNNti1xWb/1hajCMj1mCOkdeQmIN65lgZOIzF9uVkhbSicfvtvbna
zU0AtMgtc6XHaXGVHzk8skQHnOgO+k1KxCHfKWGPMiJhgsWHH26MfF8WIFFE0XBPV+rjHOPM
ee5Y2A7Cs0WTwCznmhcrewA3ekEzeOEz4vMQGn+HLL729fdC4uW/h2KJXwBL38Xd5HVEMkE6
HnFuacsLdUYI0crSK5XQz/u5QGtkjFdN/BMReYTtXlT2NJ8IAfMQJQYXStrxHXpma5hgZqTZ
79IugvHw7wnqRMkVauIDbjPTrJ9VAMf2CGqUuV/c4DPxhGD5WycRtPwW8rtWaoAljQIDAQAB
o4GyMIGvMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMG0GCCsGAQUFBwEMBGEw
X6FdoFswWTBXMFUWCWltYWdlL2dpZjAhMB8wBwYFKw4DAhoEFI/l0xqGrI2Oa8PPgGrUSBgs
exkuMCUWI2h0dHA6Ly9sb2dvLnZlcmlzaWduLmNvbS92c2xvZ28uZ2lmMB0GA1UdDgQWBBS2
d/ppSEefUxLVwuoHMnYH0ZcHGTANBgkqhkiG9w0BAQsFAAOCAQEASvj4sAPmLGd75JR3Y8xu
TPl9Dg3cyLk1uXBPY/ok+myDjEedO2Pzmvl2MpWRsXe8rJq+seQxIcaBlVZaDrHC1LGmWazx
Y8u4TB1ZkErvkBYoH1quEPuBUDgMbMzxPcP1Y+Oz4yHJJDnp/RVmRvQbEdBNc6N9Rvk97ahf
YtTxP/jgdFcrGJ2BtMQo2pSXpXDrrB2+BxHw1dvd5Yzw1TKwg+ZX4o+/vqGqvz0dtdQ46tew
XDpPaj+PwGZsY6rp2aQW9IHRlRQOfc2VNNnSj3BzgXucfr2YYdhFh5iQxeuGMMY1v/D/w1WI
g0vvBZIGcfK4mJO37M2CYfE45k+XmCpajQ==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDhDCCAwqgAwIBAgIQL4D+I4wOIg9IZxIokYesszAKBggqhkjOPQQDAzCByjELMAkGA1UE
BhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJpU2lnbiBUcnVz
dCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNyBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRo
b3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBDbGFzcyAzIFB1YmxpYyBQcmlt
YXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzQwHhcNMDcxMTA1MDAwMDAwWhcNMzgw
MTE4MjM1OTU5WjCByjELMAkGA1UEBhMCVVMxFzAVBgNVBAoTDlZlcmlTaWduLCBJbmMuMR8w
HQYDVQQLExZWZXJpU2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykgMjAwNyBWZXJp
U2lnbiwgSW5jLiAtIEZvciBhdXRob3JpemVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2ln
biBDbGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRzQw
djAQBgcqhkjOPQIBBgUrgQQAIgNiAASnVnp8Utpkmw4tXNherJI9/gHmGUo9FANL+mAnINmD
iWn6VMaaGF5VKmTeBvaNSjutEDxlPZCIBIngMGGzrl0Bp3vefLK+ymVhAIau2o970ImtTR1Z
mkGxvEeA3J5iw/mjgbIwga8wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwbQYI
KwYBBQUHAQwEYTBfoV2gWzBZMFcwVRYJaW1hZ2UvZ2lmMCEwHzAHBgUrDgMCGgQUj+XTGoas
jY5rw8+AatRIGCx7GS4wJRYjaHR0cDovL2xvZ28udmVyaXNpZ24uY29tL3ZzbG9nby5naWYw
HQYDVR0OBBYEFLMWkf3upm7ktS5Jj4d4gYDs5bG1MAoGCCqGSM49BAMDA2gAMGUCMGYhDBgm
YFo4e1ZC4Kf8NoRRkSAsdk1DPcQdhCPQrNZ8NQbOzWm9kA3bbEhCHQ6qQgIxAJw9SDkjOVga
FRJZap7v1VmyHVIsmXHNxynfGyphe3HR3vPA5Q06Sqotp9iGKt0uEA==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEFTCCAv2gAwIBAgIGSUEs5AAQMA0GCSqGSIb3DQEBCwUAMIGnMQswCQYDVQQGEwJIVTER
MA8GA1UEBwwIQnVkYXBlc3QxFTATBgNVBAoMDE5ldExvY2sgS2Z0LjE3MDUGA1UECwwuVGFu
w7pzw610dsOhbnlraWFkw7NrIChDZXJ0aWZpY2F0aW9uIFNlcnZpY2VzKTE1MDMGA1UEAwws
TmV0TG9jayBBcmFueSAoQ2xhc3MgR29sZCkgRsWRdGFuw7pzw610dsOhbnkwHhcNMDgxMjEx
MTUwODIxWhcNMjgxMjA2MTUwODIxWjCBpzELMAkGA1UEBhMCSFUxETAPBgNVBAcMCEJ1ZGFw
ZXN0MRUwEwYDVQQKDAxOZXRMb2NrIEtmdC4xNzA1BgNVBAsMLlRhbsO6c8OtdHbDoW55a2lh
ZMOzayAoQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcykxNTAzBgNVBAMMLE5ldExvY2sgQXJhbnkg
KENsYXNzIEdvbGQpIEbFkXRhbsO6c8OtdHbDoW55MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAxCRec75LbRTDofTjl5Bu0jBFHjzuZ9lk4BqKf8owyoPjIMHj9DrTlF8afFtt
vzBPhCf2nx9JvMaZCpDyD/V/Q4Q3Y1GLeqVw/HpYzY6b7cNGbIRwXdrzAZAj/E4wqX7hJ2Pn
7WQ8oLjJM2P+FpD/sLj916jAwJRDC7bVWaaeVtAkH3B5r9s5VA1lddkVQZQBr17s9o3x/61k
/iCa11zr/qYfCGSji3ZVrR47KGAuhyXoqq8fxmRGILdwfzzeSNuWU7c5d+Qa4scWhHaXWy+7
GRWF+GmF9ZmnqfI0p6m2pgP8b4Y9VHx2BJtr+UBdADTHLpl1neWIA6pN+APSQnbAGwIDAKiL
o0UwQzASBgNVHRMBAf8ECDAGAQH/AgEEMA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUzPpn
k/C2uNClwB7zU/2MU9+D15YwDQYJKoZIhvcNAQELBQADggEBAKt/7hwWqZw8UQCgwBEIBaeZ
5m8BiFRhbvG5GK1Krf6BQCOUL/t1fC8oS2IkgYIL9WHxHG64YTjrgfpioTtaYtOUZcTh5m2C
+C8lcLIhJsFyUR+MLMOEkMNaj7rP9KdlpeuY0fsFskZ1FSNqb4VjMIDw1Z4fKRzCbLBQWV2Q
WzuoDTDPv31/zvGdg73JRm4gpvlhUbohL3u+pRVjodSVh/GeufOJ8z2FuLjbvrW5KfnaNwUA
SZQDhETnv0Mxz3WLJdH0pmT1kvarBes96aULNmLazAZfNou2XjG4Kvte9nHfRCaexOYNkbQu
dZWAUWpLMKawYqGT8ZvYzsRjdT9ZR7E=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFyjCCA7KgAwIBAgIEAJiWjDANBgkqhkiG9w0BAQsFADBaMQswCQYDVQQGEwJOTDEeMBwG
A1UECgwVU3RhYXQgZGVyIE5lZGVybGFuZGVuMSswKQYDVQQDDCJTdGFhdCBkZXIgTmVkZXJs
YW5kZW4gUm9vdCBDQSAtIEcyMB4XDTA4MDMyNjExMTgxN1oXDTIwMDMyNTExMDMxMFowWjEL
MAkGA1UEBhMCTkwxHjAcBgNVBAoMFVN0YWF0IGRlciBOZWRlcmxhbmRlbjErMCkGA1UEAwwi
U3RhYXQgZGVyIE5lZGVybGFuZGVuIFJvb3QgQ0EgLSBHMjCCAiIwDQYJKoZIhvcNAQEBBQAD
ggIPADCCAgoCggIBAMVZ5291qj5LnLW4rJ4L5PnZyqtdj7U5EILXr1HgO+EASGrP2uEGQxGZ
qhQlEq0i6ABtQ8SpuOUfiUtnvWFI7/3S4GCI5bkYYCjDdyutsDeqN95kWSpGV+RLufg3fNU2
54DBtvPUZ5uW6M7XxgpT0GtJlvOjCwV3SPcl5XCsMBQgJeN/dVrlSPhOewMHBPqCYYdu8DvE
pMfQ9XQ+pV0aCPKbJdL2rAQmPlU6Yiile7Iwr/g3wtG61jj99O9JMDeZJiFIhQGp5Rbn3JBV
3w/oOM2ZNyFPXfUib2rFEhZgF1XyZWampzCROME4HYYEhLoaJXhena/MUGDWE4dS7WMfbWV9
whUYdMrhfmQpjHLYFhN9C0lK8SgbIHRrxT3dsKpICT0ugpTNGmXZK4iambwYfp/ufWZ8Pr2U
uIHOzZgweMFvZ9C+X+Bo7d7iscksWXiSqt8rYGPy5V6548r6f1CGPqI0GAwJaCgRHOThuVw+
R7oyPxjMW4T182t0xHJ04eOLoEq9jWYv6q012iDTiIJh8BIitrzQ1aTsr1SIJSQ8p22xcik/
Plemf1WvbibG/ufMQFxRRIEKeN5KzlW/HdXZt1bv8Hb/C3m1r737qWmRRpdogBQ2HbN/uymY
NqUg+oJgYjOk7Na6B6duxc8UpufWkjTYgfX8HV2qXB72o007uPc5AgMBAAGjgZcwgZQwDwYD
VR0TAQH/BAUwAwEB/zBSBgNVHSAESzBJMEcGBFUdIAAwPzA9BggrBgEFBQcCARYxaHR0cDov
L3d3dy5wa2lvdmVyaGVpZC5ubC9wb2xpY2llcy9yb290LXBvbGljeS1HMjAOBgNVHQ8BAf8E
BAMCAQYwHQYDVR0OBBYEFJFoMocVHYnitfGsNig0jQt8YojrMA0GCSqGSIb3DQEBCwUAA4IC
AQCoQUpnKpKBglBu4dfYszk78wIVCVBR7y29JHuIhjv5tLySCZa59sCrI2AGeYwRTlHSeYAz
+51IvuxBQ4EffkdAHOV6CMqqi3WtFMTC6GY8ggen5ieCWxjmD27ZUD6KQhgpxrRW/FYQoAUX
vQwjf/ST7ZwaUb7dRUG/kSS0H4zpX897IZmflZ85OkYcbPnNe5yQzSipx6lVu6xiNGI1E0sU
OlWDuYaNkqbG9AclVMwWVxJKgnjIFNkXgiYtXSAfea7+1HAWFpWD2DU5/1JddRwWxRNVz0fM
dWVSSt7wsKfkCpYL+63C4iWEst3kvX5ZbJvw8NjnyvLplzh+ib7M+zkXYT9y2zqR2GUBGR2t
UKRXCnxLvJxxcypFURmFzI79R6d0lR2o0a9OF7FpJsKqeFdbxU2n5Z4FF5TKsl+gSRiNNOkm
bEgeqmiSBeGCc1qb3AdbCG19ndeNIdn8FCCqwkXfP+cAslHkwvgFuXkajDTznlvkN1trSt8s
V4pAWja63XVECDdCcAz+3F4hoKOKwJCcaNpQ5kUQR3i2TtJlycM33+FCY7BXN0Ute4qcvwXq
ZVUz9zkQxSgqIXobisQk+T8VyJoVIPVVYpbtbZNQvOSqeK3Zywplh6ZmwcSBo3c6WB4L7oOL
nR7SUqTMHW+wmG2UMbX4cQrcufx9MmDm66+KAQ==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIE5jCCA86gAwIBAgIEO45L/DANBgkqhkiG9w0BAQUFADBdMRgwFgYJKoZIhvcNAQkBFglw
a2lAc2suZWUxCzAJBgNVBAYTAkVFMSIwIAYDVQQKExlBUyBTZXJ0aWZpdHNlZXJpbWlza2Vz
a3VzMRAwDgYDVQQDEwdKdXVyLVNLMB4XDTAxMDgzMDE0MjMwMVoXDTE2MDgyNjE0MjMwMVow
XTEYMBYGCSqGSIb3DQEJARYJcGtpQHNrLmVlMQswCQYDVQQGEwJFRTEiMCAGA1UEChMZQVMg
U2VydGlmaXRzZWVyaW1pc2tlc2t1czEQMA4GA1UEAxMHSnV1ci1TSzCCASIwDQYJKoZIhvcN
AQEBBQADggEPADCCAQoCggEBAIFxNj4zB9bjMI0TfncyRsvPGbJgMUaXhvSYRqTCZUXP00B8
41oiqBB4M8yIsdOBSvZiF3tfTQou0M+LI+5PAk676w7KvRhj6IAcjeEcjT3g/1tf6mTll+g/
mX8MCgkzABpTpyHhOEvWgxutr2TC+Rx6jGZITWYfGAriPrsfB2WThbkasLnE+w0R9vXW+RvH
LCu3GFH+4Hv2qEivbDtPL+/40UceJlfwUR0zlv/vWT3aTdEVNMfqPxZIe5EcgEMPPbgFPtGz
lc3Yyg/CQ2fbt5PgIoIuvvVoKIO5wTtpeyDaTpxt4brNj3pssAki14sL2xzVWiZbDcDq5WDQ
n/413z8CAwEAAaOCAawwggGoMA8GA1UdEwEB/wQFMAMBAf8wggEWBgNVHSAEggENMIIBCTCC
AQUGCisGAQQBzh8BAQEwgfYwgdAGCCsGAQUFBwICMIHDHoHAAFMAZQBlACAAcwBlAHIAdABp
AGYAaQBrAGEAYQB0ACAAbwBuACAAdgDkAGwAagBhAHMAdABhAHQAdQBkACAAQQBTAC0AaQBz
ACAAUwBlAHIAdABpAGYAaQB0AHMAZQBlAHIAaQBtAGkAcwBrAGUAcwBrAHUAcwAgAGEAbABh
AG0ALQBTAEsAIABzAGUAcgB0AGkAZgBpAGsAYQBhAHQAaQBkAGUAIABrAGkAbgBuAGkAdABh
AG0AaQBzAGUAawBzMCEGCCsGAQUFBwIBFhVodHRwOi8vd3d3LnNrLmVlL2Nwcy8wKwYDVR0f
BCQwIjAgoB6gHIYaaHR0cDovL3d3dy5zay5lZS9qdXVyL2NybC8wHQYDVR0OBBYEFASqekej
5ImvGs8KQKcYP2/v6X2+MB8GA1UdIwQYMBaAFASqekej5ImvGs8KQKcYP2/v6X2+MA4GA1Ud
DwEB/wQEAwIB5jANBgkqhkiG9w0BAQUFAAOCAQEAe8EYlFOiCfP+JmeaUOTDBS8rNXiRTHyo
ERF5TElZrMj3hWVcRrs7EKACr81Ptcw2Kuxd/u+gkcm2k298gFTsxwhwDY77guwqYHhpNjbR
xZyLabVAyJRld/JXIWY7zoVAtjNjGr95HvxcHdMdkxuLDF2FvZkwMhgJkVLpfKG6/2SSmuz+
Ne6ML678IIbsSt4beDI3poHSna9aEhbKmVv8b20OxaAehsmR0FyYgl9jDIpaq9iVpszLita/
ZEuOyoqysOkhMp6qqIWYNIE5ITuoOlIyPfZrN4YGWhWY3PARZv40ILcD9EEQfTmEeZZyY7aW
AuVrua0ZTbvGRNs2yyqcjg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDMDCCAhigAwIBAgICA+gwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCSEsxFjAUBgNV
BAoTDUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdrb25nIFBvc3QgUm9vdCBDQSAxMB4X
DTAzMDUxNTA1MTMxNFoXDTIzMDUxNTA0NTIyOVowRzELMAkGA1UEBhMCSEsxFjAUBgNVBAoT
DUhvbmdrb25nIFBvc3QxIDAeBgNVBAMTF0hvbmdrb25nIFBvc3QgUm9vdCBDQSAxMIIBIjAN
BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArP84tulmAknjorThkPlAj3n54r15/gK97iSS
HSL22oVyaf7XPwnU3ZG1ApzQjVrhVcNQhrkpJsLj2aDxaQMoIIBFIi1WpztUlVYiWR8o3x8g
PW2iNr4joLFutbEnPzlTCeqrauh0ssJlXI6/fMN4hM2eFvz1Lk8gKgifd/PFHsSaUmYeSF7j
EAaPIpjhZY4bXSNmO7ilMlHIhqqhqZ5/dpTCpmy3QfDVyAY45tQM4vM7TG1QjMSDJ8EThFk9
nnV0ttgCXjqQesBCNnLsak3c78QA3xMYV18meMjWCnl3v/evt3a5pQuEF10Q6m/hq5URX208
o1xNg1vysxmKgIsLhwIDAQABoyYwJDASBgNVHRMBAf8ECDAGAQH/AgEDMA4GA1UdDwEB/wQE
AwIBxjANBgkqhkiG9w0BAQUFAAOCAQEADkbVPK7ih9legYsCmEEIjEy82tvuJxuC52pF7BaL
T4Wg87JwvVqWuspube5Gi27nKi6Wsxkz67SfqLI37piol7Yutmcn1KZJ/RyTZXaeQi/cImya
T/JaFTmxcdcrUehtHJjA2Sr0oYJ71clBoiMBdDhViw+5LmeiIAQ32pwL0xch4I+XeTRvhEgC
IDMb5jREn5Fw9IBehEPCKdJsEhTkYY2sEJCehFC78JZvRZ+K88psT/oROhUVRsPNH4NbLUES
7VBnQRM9IauUiqpOfMGx+6fWtScvl6tu4B3i0RwsH0Ti/L6RoZz71ilTc4afU9hDDl3WY4Jx
HYB0yvbiAmvZWg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDbTCCAlWgAwIBAgIBATANBgkqhkiG9w0BAQUFADBYMQswCQYDVQQGEwJKUDErMCkGA1UE
ChMiSmFwYW4gQ2VydGlmaWNhdGlvbiBTZXJ2aWNlcywgSW5jLjEcMBoGA1UEAxMTU2VjdXJl
U2lnbiBSb290Q0ExMTAeFw0wOTA0MDgwNDU2NDdaFw0yOTA0MDgwNDU2NDdaMFgxCzAJBgNV
BAYTAkpQMSswKQYDVQQKEyJKYXBhbiBDZXJ0aWZpY2F0aW9uIFNlcnZpY2VzLCBJbmMuMRww
GgYDVQQDExNTZWN1cmVTaWduIFJvb3RDQTExMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEA/XeqpRyQBTvLTJszi1oURaTnkBbR31fSIRCkF/3frNYfp+TbfPfs37gD2pRY/V1y
fIw/XwFndBWW4wI8h9uuywGOwvNmxoVF9ALGOrVisq/6nL+k5tSAMJjzDbaTj6nU2DbysPyK
yiyhFTOVMdrAG/LuYpmGYz+/3ZMqg6h2uRMft85OQoWPIucuGvKVCbIFtUROd6EgvanyTgp9
UK31BQ1FT0Zx/Sg+U/sE2C3XZR1KG/rPO7AxmjVuyIsG0wCR8pQIZUyxNAYAeoni8McDWc/V
1uinMrPmmECGxc0nEovMe863ETxiYAcjPitAbpSACW22s293bzUIUPsCh8U+iQIDAQABo0Iw
QDAdBgNVHQ4EFgQUW/hNT7KlhtQ60vFjmqC+CfZXt94wDgYDVR0PAQH/BAQDAgEGMA8GA1Ud
EwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAKChOBZmLqdWHyGcBvod7bkixTgm2E5P
7KN/ed5GIaGHd48HCJqypMWvDzKYC3xmKbabfSVSSUOrTC4rbnpwrxYO4wJs+0LmGJ1F2FXI
6Dvd5+H0LgscNFxsWEr7jIhQX5Ucv+2rIrVls4W6ng+4reV6G4pQOh29Dbx7VFALuUKvVaAY
ga1lme++5Jy/xIWrQbJUb9wlze144o4MjQlJ3WN7WmmWAiGovVJZ6X01y8hSyn+B/tlr0/cR
7SXf+Of5pPpyl4RTDaXQMhhRdlkUbA/r7F+AjHVDg8OFmP9Mni0N5HeDk061lgeLKBObjBmN
QSdJQO7e5iNEOdyhIta6A/I=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFtTCCA52gAwIBAgIIYY3HhjsBggUwDQYJKoZIhvcNAQEFBQAwRDEWMBQGA1UEAwwNQUNF
RElDT00gUm9vdDEMMAoGA1UECwwDUEtJMQ8wDQYDVQQKDAZFRElDT00xCzAJBgNVBAYTAkVT
MB4XDTA4MDQxODE2MjQyMloXDTI4MDQxMzE2MjQyMlowRDEWMBQGA1UEAwwNQUNFRElDT00g
Um9vdDEMMAoGA1UECwwDUEtJMQ8wDQYDVQQKDAZFRElDT00xCzAJBgNVBAYTAkVTMIICIjAN
BgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA/5KV4WgGdrQsyFhIyv2AVClVYyT/kGWbEHV7
w2rbYgIB8hiGtXxaOLHkWLn709gtn70yN78sFW2+tfQh0hOR2QetAQXW8713zl9CgQr5auOD
AKgrLlUTY4HKRxx7XBZXehuDYAQ6PmXDzQHe3qTWDLqO3tkE7hdWIpuPY/1NFgu3e3eM+SW1
0W2ZEi5PGrjm6gSSrj0RuVFCPYewMYWveVqc/udOXpJPQ/yrOq2lEiZmueIM15jO1FillUAK
t0SdE3QrwqXrIhWYENiLxQSfHY9g5QYbm8+5eaA9oiM/Qj9r+hwDezCNzmzAv+YbX79nuIQZ
1RXve8uQNjFiybwCq0Zfm/4aaJQ0PZCOrfbkHQl/Sog4P75n/TSW9R28MHTLOO7VbKvU/PQA
twBbhTIWdjPp2KOZnQUAqhbm84F9b32qhm2tFXTTxKJxqvQUfecyuB+81fFOvW8XAjnXDpVC
OscAPukmYxHqC9FK/xidstd7LzrZlvvoHpKuE1XI2Sf23EgbsCTBheN3nZqk8wwRHQ3ItBTu
tYJXCb8gWH8vIiPYcMt5bMlL8qkqyPyHK9caUPgn6C9D4zq92Fdx/c6mUlv53U3t5fZvie27
k5x2IXXwkkwp9y+cAS7+UEaeZAwUswdbxcJzbPEHXEUkFDWug/FqTYl6+rPYLWbwNof1K1MC
AwEAAaOBqjCBpzAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFKaz4SsrSbbXc6GqlPUB
53NlTKxQMA4GA1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUprPhKytJttdzoaqU9QHnc2VMrFAw
RAYDVR0gBD0wOzA5BgRVHSAAMDEwLwYIKwYBBQUHAgEWI2h0dHA6Ly9hY2VkaWNvbS5lZGlj
b21ncm91cC5jb20vZG9jMA0GCSqGSIb3DQEBBQUAA4ICAQDOLAtSUWImfQwng4/F9tqgaHtP
kl7qpHMyEVNEskTLnewPeUKzEKbHDZ3Ltvo/Onzqv4hTGzz3gvoFNTPhNahXwOf9jU8/kzJP
eGYDdwdY6ZXIfj7QeQCM8htRM5u8lOk6e25SLTKeI6RF+7YuE7CLGLHdztUdp0J/Vb77W7tH
1PwkzQSulgUV1qzOMPPKC8W64iLgpq0i5ALudBF/TP94HTXa5gI06xgSYXcGCRZj6hitoocf
8seACQl1ThCojz2GuHURwCRiipZ7SkXp7FnFvmuD5uHorLUwHv4FB4D54SMNUI8FmP8sX+g7
tq3PgbUhh8oIKiMnMCArz+2UW6yyetLHKKGKC5tNSixthT8Jcjxn4tncB7rrZXtaAWPWkFtP
F2Y9fwsZo5NjEFIqnxQWWOLcpfShFosOkYuByptZ+thrkQdlVV9SH686+5DdaaVbnG0OLLb6
zqylfDJKZ0DcMDQj3dcEI2bw/FWAp/tmGYI1Z2JwOV5vx+qQQEQIHriy1tvuWacNGHk0vFQY
XlPKNFHtRQrmjseCNj6nOGOpMCwXEGCSn1WHElkQwg9naRHMTh5+Spqtr0CodaxWkHS4oJyl
eW/c6RrIaQXpuvoDs3zk4E7Czp3otkYNbn5XOmeUwssfnHdKZ05phkOTOPu220+DkdRgfks+
KzgHVZhepA==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIECjCCAvKgAwIBAgIJAMJ+QwRORz8ZMA0GCSqGSIb3DQEBCwUAMIGCMQswCQYDVQQGEwJI
VTERMA8GA1UEBwwIQnVkYXBlc3QxFjAUBgNVBAoMDU1pY3Jvc2VjIEx0ZC4xJzAlBgNVBAMM
Hk1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EgMjAwOTEfMB0GCSqGSIb3DQEJARYQaW5mb0Bl
LXN6aWduby5odTAeFw0wOTA2MTYxMTMwMThaFw0yOTEyMzAxMTMwMThaMIGCMQswCQYDVQQG
EwJIVTERMA8GA1UEBwwIQnVkYXBlc3QxFjAUBgNVBAoMDU1pY3Jvc2VjIEx0ZC4xJzAlBgNV
BAMMHk1pY3Jvc2VjIGUtU3ppZ25vIFJvb3QgQ0EgMjAwOTEfMB0GCSqGSIb3DQEJARYQaW5m
b0BlLXN6aWduby5odTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOn4j/NjrdqG
2KfgQvvPkd6mJviZpWNwrZuuyjNAfW2WbqEORO7hE52UQlKavXWFdCyoDh2Tthi3jCyoz/tc
cbna7P7ofo/kLx2yqHWH2Leh5TvPmUpG0IMZfcChEhyVbUr02MelTTMuhTlAdX4UfIASmFDH
QWe4oIBhVKZsTh/gnQ4H6cm6M+f+wFUoLAKApxn1ntxVUwOXewdI/5n7N4okxFnMUBBjjqqp
GrCEGob5X7uxUG6k0QrM1XF+H6cbfPVTbiJfyyvm1HxdrtbCxkzlBQHZ7Vf8wSN5/PrIJIOV
87VqUQHQd9bpEqH5GoP7ghu5sJf0dgYzQ0mg/wu1+rUCAwEAAaOBgDB+MA8GA1UdEwEB/wQF
MAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBTLD8bfQkPMPcu1SCOhGnqmKrs0aDAf
BgNVHSMEGDAWgBTLD8bfQkPMPcu1SCOhGnqmKrs0aDAbBgNVHREEFDASgRBpbmZvQGUtc3pp
Z25vLmh1MA0GCSqGSIb3DQEBCwUAA4IBAQDJ0Q5eLtXMs3w+y/w9/w0olZMEyL/azXm4Q5Dw
pL7v8u8hmLzU1F0G9u5C7DBsoKqpyvGvivo/C3NqPuouQH4frlRheesuCDfXI/OMn74dseGk
ddug4lQUsbocKaQY9hK6ohQU4zE1yED/t+AFdlfBHFny+L/k7SViXITwfn4fs775tyERzAMB
VnCnEJIeGzSBHq2cGsMEPO0CYdYeBvNfOofyK/FFh+U9rNHHV4S9a67c2Pm2G2JwCz02yULy
Mtd6YebS2z3PyKnJm9zbWETXbzivf3jTo60adbocwTZ8jx5tHMN1Rq41Bab2XD0h7lbwyYIi
LXpUq3DDfSJlgnCW
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4GA1UECxMX
R2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNpZ24xEzARBgNVBAMT
Ckdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4MTAwMDAwWjBMMSAwHgYDVQQL
ExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xvYmFsU2lnbjETMBEGA1UE
AxMKR2xvYmFsU2lnbjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5Bngi
FvXAg7aEyiie/QV2EcWtiHL8RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0M
K66X17YUhhB5uzsTgHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL
0gRgykmmKPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZXriX7613
t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAwDgYDVR0PAQH/BAQD
AgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+oLkUkrk1Q+mOai97i3Ru8MA0G
CSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZURUm7lgAJQayzE4aGKAczymvmdLm6AC2u
pArT9fHxD4q/c2dKg8dEe3jgr25sbwMpjjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdW
PoO4zzUhw8lo/s7awlOqzJCK6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0
095MJ6RMG3NzdvQXmcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJr
lAGomecsMx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
WD9f
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIGFDCCA/ygAwIBAgIIU+w77vuySF8wDQYJKoZIhvcNAQEFBQAwUTELMAkGA1UEBhMCRVMx
QjBABgNVBAMMOUF1dG9yaWRhZCBkZSBDZXJ0aWZpY2FjaW9uIEZpcm1hcHJvZmVzaW9uYWwg
Q0lGIEE2MjYzNDA2ODAeFw0wOTA1MjAwODM4MTVaFw0zMDEyMzEwODM4MTVaMFExCzAJBgNV
BAYTAkVTMUIwQAYDVQQDDDlBdXRvcmlkYWQgZGUgQ2VydGlmaWNhY2lvbiBGaXJtYXByb2Zl
c2lvbmFsIENJRiBBNjI2MzQwNjgwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDK
lmuO6vj78aI14H9M2uDDUtd9thDIAl6zQyrET2qyyhxdKJp4ERppWVevtSBC5IsP5t9bpgOS
L/UR5GLXMnE42QQMcas9UX4PB99jBVzpv5RvwSmCwLTaUbDBPLutN0pcyvFLNg4kq7/DhHf9
qFD0sefGL9ItWY16Ck6WaVICqjaY7Pz6FIMMNx/Jkjd/14Et5cS54D40/mf0PmbR0/RAz15i
NA9wBj4gGFrO93IbJWyTdBSTo3OxDqqHECNZXyAFGUftaI6SEspd/NYrspI8IM/hX68gvqB2
f3bl7BqGYTM+53u0P6APjqK5am+5hyZvQWyIplD9amML9ZMWGxmPsu2bm8mQ9QEM3xk9Dz44
I8kvjwzRAv4bVdZO0I08r0+k8/6vKtMFnXkIoctXMbScyJCyZ/QYFpM6/EfY0XiWMR+6Kwxf
XZmtY4laJCB22N/9q06mIqqdXuYnin1oKaPnirjaEbsXLZmdEyRG98Xi2J+Of8ePdG1asuhy
9azuJBCtLxTa/y2aRnFHvkLfuwHb9H/TKI8xWVvTyQKmtFLKbpf7Q8UIJm+K9Lv9nyiqDdVF
8xM6HdjAeI9BZzwelGSuewvF6NkBiDkal4ZkQdU7hwxu+g/GvUgUvzlN1J5Bto+WHWOWk9mV
BngxaJ43BjuAiUVhOSPHG0SjFeUc+JIwuwIDAQABo4HvMIHsMBIGA1UdEwEB/wQIMAYBAf8C
AQEwDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRlzeurNR4APn7VdMActHNHDhpkLzCBpgYD
VR0gBIGeMIGbMIGYBgRVHSAAMIGPMC8GCCsGAQUFBwIBFiNodHRwOi8vd3d3LmZpcm1hcHJv
ZmVzaW9uYWwuY29tL2NwczBcBggrBgEFBQcCAjBQHk4AUABhAHMAZQBvACAAZABlACAAbABh
ACAAQgBvAG4AYQBuAG8AdgBhACAANAA3ACAAQgBhAHIAYwBlAGwAbwBuAGEAIAAwADgAMAAx
ADcwDQYJKoZIhvcNAQEFBQADggIBABd9oPm03cXF661LJLWhAqvdpYhKsg9VSytXjDvlMd3+
xDLx51tkljYyGOylMnfX40S2wBEqgLk9am58m9Ot/MPWo+ZkKXzR4Tgegiv/J2Wv+xYVxC5x
hOW1//qkR71kMrv2JYSiJ0L1ILDCExARzRAVukKQKtJE4ZYm6zFIEv0q2skGz3QeqUvVhyj5
eTSSPi5E6PaPT481PyWzOdxjKpBrIF/EUhJOlywqrJ2X3kjyo2bbwtKDlaZmp54lD+kLM5Fl
ClrD2VQS3a/DTg4fJl4N3LON7NWBcN7STyQF82xO9UxJZo3R/9ILJUFI/lGExkKvgATP0H5k
SeTy36LssUzAKh3ntLFlosS88Zj0qnAHY7S42jtM+kAiMFsRpvAFDsYCA0irhpuF3dvd6qJ2
gHN99ZwExEWN57kci57q13XRcrHedUTnQn3iV2t93Jm8PYMo6oCTjcVMZcFwgbg4/EMxsvYD
NEeyrPsiBsse3RdHHF9mudMaotoRsaS8I8nkvof/uZS2+F0gStRf571oe2XyFR7SOqkt6dhr
JKyXWERHrVkY8SFlcN7ONGCoQPHzPKTDKCOM/iczQ0CgFzzr6juwcqajuUpLXhZI9LK8yIyS
xZ2frHI2vDSANGupi5LAuBft7HZT9SQBjLMi6Et8Vcad+qMUu2WFbm5PEn4KPJ2V
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF8TCCA9mgAwIBAgIQALC3WhZIX7/hy/WL1xnmfTANBgkqhkiG9w0BAQsFADA4MQswCQYD
VQQGEwJFUzEUMBIGA1UECgwLSVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6ZW5wZS5jb20wHhcN
MDcxMjEzMTMwODI4WhcNMzcxMjEzMDgyNzI1WjA4MQswCQYDVQQGEwJFUzEUMBIGA1UECgwL
SVpFTlBFIFMuQS4xEzARBgNVBAMMCkl6ZW5wZS5jb20wggIiMA0GCSqGSIb3DQEBAQUAA4IC
DwAwggIKAoICAQDJ03rKDx6sp4boFmVqscIbRTJxldn+EFvMr+eleQGPicPK8lVx93e+d5Tz
cqQsRNiekpsUOqHnJJAKClaOxdgmlOHZSOEtPtoKct2jmRXagaKH9HtuJneJWK3W6wyyQXpz
bm3benhB6QiIEn6HLmYRY2xU+zydcsC8Lv/Ct90NduM61/e0aL6i9eOBbsFGb12N4E3GVFWJ
GjMxCrFXuaOKmMPsOzTFlUFpfnXCPCDFYbpRR6AgkJOhkEvzTnyFRVSa0QUmQbC1TR0zvsQD
yCV8wXDbO/QJLVQnSKwv4cSsPsjLkkxTOTcj7NMB+eAJRE1NZMDhDVqHIrytG6P+JrUV86f8
hBnp7KGItERphIPzidF0BqnMC9bC3ieFUCbKF7jJeodWLBoBHmy+E60QrLUk9TiRodZL2vG7
0t5HtfG8gfZZa88ZU+mNFctKy6lvROUbQc/hhqfK0GqfvEyNBjNaooXlkDWgYlwWTvDjovoD
GrQscbNYLN57C9saD+veIR8GdwYDsMnvmfzAuU8Lhij+0rnq49qlw0dpEuDb8PYZi+17cNcC
1u2HGCgsBCRMd+RIihrGO5rUD8r6ddIBQFqNeb+Lz0vPqhbBleStTIo+F5HUsWLlguWABKQD
fo2/2n+iD5dPDNMN+9fR5XJ+HMh3/1uaD7euBUbl8agW7EekFwIDAQABo4H2MIHzMIGwBgNV
HREEgagwgaWBD2luZm9AaXplbnBlLmNvbaSBkTCBjjFHMEUGA1UECgw+SVpFTlBFIFMuQS4g
LSBDSUYgQTAxMzM3MjYwLVJNZXJjLlZpdG9yaWEtR2FzdGVpeiBUMTA1NSBGNjIgUzgxQzBB
BgNVBAkMOkF2ZGEgZGVsIE1lZGl0ZXJyYW5lbyBFdG9yYmlkZWEgMTQgLSAwMTAxMCBWaXRv
cmlhLUdhc3RlaXowDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE
FB0cZQ6o8iV7tJHP5LGx5r1VdGwFMA0GCSqGSIb3DQEBCwUAA4ICAQB4pgwWSp9MiDrAyw6l
Fn2fuUhfGI8NYjb2zRlrrKvV9pF9rnHzP7MOeIWblaQnIUdCSnxIOvVFfLMMjlF4rJUT3sb9
fbgakEyrkgPH7UIBzg/YsfqikuFgba56awmqxinuaElnMIAkejEWOVt+8Rwu3WwJrfIxwYJO
ubv5vr8qhT/AQKM6WfxZSzwoJNu0FXWuDYi6LnPAvViH5ULy617uHjAimcs30cQhbIHsvm0m
5hzkQiCeR7Csg1lwLDXWrzY0tM07+DKo7+N4ifuNRSzanLh+QBxh5z6ikixL8s36mLYp//Py
e6kfLqCTVyvehQP5aTfLnnhqBbTFMXiJ7HqnheG5ezzevh55hM6fcA5ZwjUukCox2eRFekGk
LhObNA5me0mrZJfQRsN5nXJQY6aYWwa9SG3YOYNw6DXwBdGqvOPbyALqfP2C2sJbUjWumDqt
ujWTI6cfSN01RpiyEGjkpTHCClguGYEQyVB1/OpaFs4R1+7vUIgtYf8/QnMFlEPVjjxOAToZ
pR9GTnfQXeWBIiGH/pR9hNiTrdZoQ0iy2+tzJOeRf1SktoA+naM8THLCV8Sg1Mw4J87VBp6i
SNnpn86CcDaTmjvfliHjWbcM2pE38P1ZWrOZyGlsQyYBNWNgVYkDOnXYukrZVP/u3oDYLdE4
1V4tC5h9Pmzb/CaIxw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIHTzCCBTegAwIBAgIJAKPaQn6ksa7aMA0GCSqGSIb3DQEBBQUAMIGuMQswCQYDVQQGEwJF
VTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZp
cm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1l
cmZpcm1hIFMuQS4xKTAnBgNVBAMTIENoYW1iZXJzIG9mIENvbW1lcmNlIFJvb3QgLSAyMDA4
MB4XDTA4MDgwMTEyMjk1MFoXDTM4MDczMTEyMjk1MFowga4xCzAJBgNVBAYTAkVVMUMwQQYD
VQQHEzpNYWRyaWQgKHNlZSBjdXJyZW50IGFkZHJlc3MgYXQgd3d3LmNhbWVyZmlybWEuY29t
L2FkZHJlc3MpMRIwEAYDVQQFEwlBODI3NDMyODcxGzAZBgNVBAoTEkFDIENhbWVyZmlybWEg
Uy5BLjEpMCcGA1UEAxMgQ2hhbWJlcnMgb2YgQ29tbWVyY2UgUm9vdCAtIDIwMDgwggIiMA0G
CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCvAMtwNyuAWko6bHiUfaN/Gh/2NdW928sNRHI+
JrKQUrpjOyhYb6WzbZSm891kDFX29ufyIiKAXuFixrYp4YFs8r/lfTJqVKAyGVn+H4vXPWCG
hSRv4xGzdz4gljUha7MI2XAuZPeEklPWDrCQiorjh40G072QDuKZoRuGDtqaCrsLYVAGUvGe
f3bsyw/QHg3PmTA9HMRFEFis1tPo1+XqxQEHd9ZR5gN/ikilTWh1uem8nk4ZcfUyS5xtYBkL
+8ydddy/Js2Pk3g5eXNeJQ7KXOt3EgfLZEFHcpOrUMPrCXZkNNI5t3YRCQ12RcSprj1qr7V9
ZS+UWBDsXHyvfuK2GNnQm05aSd+pZgvMPMZ4fKecHePOjlO+Bd5gD2vlGts/4+EhySnB8esH
nFIbAURRPHsl18TlUlRdJQfKFiC4reRB7noI/plvg6aRArBsNlVq5331lubKgdaX8ZSD6e2w
sWsSaR6s+12pxZjptFtYer49okQ6Y1nUCyXeG0+95QGezdIp1Z8XGQpvvwyQ0wlf2eOKNcx5
Wk0ZN5K3xMGtr/R5JJqyAQuxr1yW84Ay+1w9mPGgP0revq+ULtlVmhduYJ1jbLhjya6BXBg1
4JC7vjxPNyK5fuvPnnchpj04gftI2jE9K+OJ9dC1vX7gUMQSibMjmhAxhduub+84Mxh2EQID
AQABo4IBbDCCAWgwEgYDVR0TAQH/BAgwBgEB/wIBDDAdBgNVHQ4EFgQU+SSsD7K1+HnA+mCI
G8TZTQKeFxkwgeMGA1UdIwSB2zCB2IAU+SSsD7K1+HnA+mCIG8TZTQKeFxmhgbSkgbEwga4x
CzAJBgNVBAYTAkVVMUMwQQYDVQQHEzpNYWRyaWQgKHNlZSBjdXJyZW50IGFkZHJlc3MgYXQg
d3d3LmNhbWVyZmlybWEuY29tL2FkZHJlc3MpMRIwEAYDVQQFEwlBODI3NDMyODcxGzAZBgNV
BAoTEkFDIENhbWVyZmlybWEgUy5BLjEpMCcGA1UEAxMgQ2hhbWJlcnMgb2YgQ29tbWVyY2Ug
Um9vdCAtIDIwMDiCCQCj2kJ+pLGu2jAOBgNVHQ8BAf8EBAMCAQYwPQYDVR0gBDYwNDAyBgRV
HSAAMCowKAYIKwYBBQUHAgEWHGh0dHA6Ly9wb2xpY3kuY2FtZXJmaXJtYS5jb20wDQYJKoZI
hvcNAQEFBQADggIBAJASryI1wqM58C7e6bXpeHxIvj99RZJe6dqxGfwWPJ+0W2aeaufDuV2I
6A+tzyMP3iU6XsxPpcG1Lawk0lgH3qLPaYRgM+gQDROpI9CF5Y57pp49chNyM/WqfcZjHwj0
/gF/JM8rLFQJ3uIrbZLGOU8W6jx+ekbURWpGqOt1glanq6B8aBMz9p0w8G8nOSQjKpD9kCk1
8pPfNKXG9/jvjA9iSnyu0/VU+I22mlaHFoI6M6taIgj3grrqLuBHmrS1RaMFO9ncLkVAO+rc
f+g769HsJtg1pDDFOqxXnrN2pSB7+R5KBWIBpih1YJeSDW4+TTdDDZIVnBgizVGZoCkaPF+K
MjNbMMeJL0eYD6MDxvbxrN8y8NmBGuScvfaAFPDRLLmF9dijscilIeUcE5fuDr3fKanvNFNb
0+RqE4QGtjICxFKuItLcsiFCGtpA8CnJ7AoMXOLQusxI0zcKzBIKinmwPQN/aUv0NCB9szTq
jktk9T79syNnFQ0EuPAtwQlRPLJsFfClI9eDdOTlLsn+mCdCxqvGnrDQWzilm1DefhiYtUU7
9nm06PcaewaD+9CL2rvHvRirCG88gGtAPxkZumWK5r7VXNM21+9AUiRgOGcEMeyP84LG3rlV
8zsxkVrctQgVrXYlCg17LofiDKYGvCYQbTed7N14jHyAxfDZd0jQ
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIHSTCCBTGgAwIBAgIJAMnN0+nVfSPOMA0GCSqGSIb3DQEBBQUAMIGsMQswCQYDVQQGEwJF
VTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZp
cm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1l
cmZpcm1hIFMuQS4xJzAlBgNVBAMTHkdsb2JhbCBDaGFtYmVyc2lnbiBSb290IC0gMjAwODAe
Fw0wODA4MDExMjMxNDBaFw0zODA3MzExMjMxNDBaMIGsMQswCQYDVQQGEwJFVTFDMEEGA1UE
BxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZpcm1hLmNvbS9h
ZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMu
QS4xJzAlBgNVBAMTHkdsb2JhbCBDaGFtYmVyc2lnbiBSb290IC0gMjAwODCCAiIwDQYJKoZI
hvcNAQEBBQADggIPADCCAgoCggIBAMDfVtPkOpt2RbQT2//BthmLN0EYlVJH6xedKYiONWwG
Mi5HYvNJBL99RDaxccy9Wglz1dmFRP+RVyXfXjaOcNFccUMd2drvXNL7G706tcuto8xEpw2u
IRU/uXpbknXYpBI4iRmKt4DS4jJvVpyR1ogQC7N0ZJJ0YPP2zxhPYLIj0Mc7zmFLmY/CDNBA
spjcDahOo7kKrmCgrUVSY7pmvWjg+b4aqIG7HkF4ddPB/gBVsIdU6CeQNR1MM62X/JcumIS/
LMmjv9GYERTtY/jKmIhYF5ntRQOXfjyGHoiMvvKRhI9lNNgATH23MRdaKXoKGCQwoze1eqkB
fSbW+Q6OWfH9GzO1KTsXO0G2Id3UwD2ln58fQ1DJu7xsepeY7s2MH/ucUa6LcL0nn3HAa6x9
kGbo1106DbDVwo3VyJ2dwW3Q0L9R5OP4wzg2rtandeavhENdk5IMagfeOx2YItaswTXbo6Al
/3K1dh3ebeksZixShNBFks4c5eUzHdwHU1SjqoI7mjcv3N2gZOnm3b2u/GSFHTynyQbehP9r
6GsaPMWis0L7iwk+XwhSx2LE1AVxv8Rk5Pihg+g+EpuoHtQ2TS9x9o0o9oOpE9JhwZG7SMA0
j0GMS0zbaRL/UJScIINZc+18ofLx/d33SdNDWKBWY8o9PeU1VlnpDsogzCtLkykPAgMBAAGj
ggFqMIIBZjASBgNVHRMBAf8ECDAGAQH/AgEMMB0GA1UdDgQWBBS5CcqcHtvTbDprru1U8VuT
BjUuXjCB4QYDVR0jBIHZMIHWgBS5CcqcHtvTbDprru1U8VuTBjUuXqGBsqSBrzCBrDELMAkG
A1UEBhMCRVUxQzBBBgNVBAcTOk1hZHJpZCAoc2VlIGN1cnJlbnQgYWRkcmVzcyBhdCB3d3cu
Y2FtZXJmaXJtYS5jb20vYWRkcmVzcykxEjAQBgNVBAUTCUE4Mjc0MzI4NzEbMBkGA1UEChMS
QUMgQ2FtZXJmaXJtYSBTLkEuMScwJQYDVQQDEx5HbG9iYWwgQ2hhbWJlcnNpZ24gUm9vdCAt
IDIwMDiCCQDJzdPp1X0jzjAOBgNVHQ8BAf8EBAMCAQYwPQYDVR0gBDYwNDAyBgRVHSAAMCow
KAYIKwYBBQUHAgEWHGh0dHA6Ly9wb2xpY3kuY2FtZXJmaXJtYS5jb20wDQYJKoZIhvcNAQEF
BQADggIBAICIf3DekijZBZRG/5BXqfEv3xoNa/p8DhxJJHkn2EaqbylZUohwEurdPfWbU1Rv
4WCiqAm57OtZfMY18dwY6fFn5a+6ReAJ3spED8IXDneRRXozX1+WLGiLwUePmJs9wOzL9dWC
koQ10b42OFZyMVtHLaoXpGNR6woBrX/sdZ7LoR/xfxKxueRkf2fWIyr0uDldmOghp+G9PUIa
dJpwr2hsUF1Jz//7Dl3mLEfXgTpZALVza2Mg9jFFCDkO9HB+QHBaP9BrQql0PSgvAm11cpUJ
jUhjxsYjV5KTXjXBjfkK9yydYhz2rXzdpjEetrHHfoUm+qRqtdpjMNHvkzeyZi99Bffnt0uY
lDXA2TopwZ2yUDMdSqlapskD7+3056huirRXhOukP9DuqqqHW2Pok+JrqNS4cnhrG+055F3L
m6qH1U9OAP7Zap88MQ8oAgF9mOinsKJknnn4SPIVqczmyETrP3iZ8ntxPjzxmKfFGBI/5rso
M0LpRQp8bfKGeS/Fghl9CYl8slR2iK7ewfPM4W7bMdaTrpmg7yVqc5iJWzouE4gev8CSlDQb
4ye3ix5vQv/n6TebUB0tovkC7stYWDpxvGjjqsGvHCgfotwjZT+B6q6Z09gwzxMNTxXJhLyn
SC34MCN32EZLeW32jO06f2ARePTpm67VVMB0gNELQp/B
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDxTCCAq2gAwIBAgIBADANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCVVMxEDAOBgNV
BAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAYBgNVBAoTEUdvRGFkZHkuY29t
LCBJbmMuMTEwLwYDVQQDEyhHbyBEYWRkeSBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eSAt
IEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgYMxCzAJBgNVBAYTAlVTMRAw
DgYDVQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMRowGAYDVQQKExFHb0RhZGR5
LmNvbSwgSW5jLjExMC8GA1UEAxMoR28gRGFkZHkgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3Jp
dHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9xYgjx+lk09xvJGKP3
gElY6SKDE6bFIEMBO4Tx5oVJnyfq9oQbTqC023CYxzIBsQU+B07u9PpPL1kwIuerGVZr4oAH
/PMWdYA5UXvl+TW2dE6pjYIT5LY/qQOD+qK+ihVqf94Lw7YZFAXK6sOoBJQ7RnwyDfMAZiLI
jWltNowRGLfTshxgtDj6AozO091GB94KPutdfMh8+7ArU6SSYmlRJQVhGkSBjCypQ5Yj36w6
gZoOKcUcqeldHraenjAKOc7xiID7S13MMuyFYkMlNAJWJwGRtDtwKj9useiciAF9n9T521Nt
YJ2/LOdYq7hfRvzOxBsDPAnrSTFcaUaz4EcCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAO
BgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFDqahQcQZyi27/a9BUFuIMGU2g/eMA0GCSqGSIb3
DQEBCwUAA4IBAQCZ21151fmXWWcDYfF+OwYxdS2hII5PZYe096acvNjpL9DbWu7PdIxztDhC
2gV7+AJ1uP2lsdeu9tfeE8tTEH6KRtGX+rcuKxGrkLAngPnon1rpN5+r5N9ss4UXnT3ZJE95
kTXWXwTrgIOrmgIttRD02JDHBHNA7XIloKmf7J6raBKZV8aPEjoJpL1E/QYVN8Gb5DKj7Tjo
2GTzLH4U/ALqn83/B2gX2yKQOC16jdFU8WnjXzPKej17CuPKf1855eJ1usV2GDPOLPAvTK33
sefOT6jEm0pUBsV/fdUID+Ic/n4XuKxe9tQWskMJDE32p2u0mYRlynqI4uJEvlz36hz1
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID3TCCAsWgAwIBAgIBADANBgkqhkiG9w0BAQsFADCBjzELMAkGA1UEBhMCVVMxEDAOBgNV
BAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoTHFN0YXJmaWVsZCBU
ZWNobm9sb2dpZXMsIEluYy4xMjAwBgNVBAMTKVN0YXJmaWVsZCBSb290IENlcnRpZmljYXRl
IEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1OVowgY8xCzAJ
BgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNkYWxlMSUwIwYD
VQQKExxTdGFyZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTIwMAYDVQQDEylTdGFyZmllbGQg
Um9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEP
ADCCAQoCggEBAL3twQP89o/8ArFvW59I2Z154qK3A2FWGMNHttfKPTUuiUP3oWmb3ooa/RMg
nLRJdzIpVv257IzdIvpy3Cdhl+72WoTsbhm5iSzchFvVdPtrX8WJpRBSiUZV9Lh1HOZ/5FSu
S/hVclcCGfgXcVnrHigHdMWdSL5stPSksPNkN3mSwOxGXn/hbVNMYq/NHwtjuzqd+/x5AJhh
dM8mgkBj87JyahkNmcrUDnXMN/uLicFZ8WJ/X7NfZTD4p7dNdloedl40wOiWVpmKs/B/pM29
3DIxfJHP4F8R+GuqSVzRmZTRouNjWwl2tVZi4Ut0HZbUJtQIBFnQmA4O5t78w+wfkPECAwEA
AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFHwMMh+n
2TB/xH1oo2Kooc6rB1snMA0GCSqGSIb3DQEBCwUAA4IBAQARWfolTwNvlJk7mh+ChTnUdgWU
XuEok21iXQnCoKjUsHU48TRqneSfioYmUeYs0cYtbpUgSpIB7LiKZ3sx4mcujJUDJi5DnUox
9g61DLu34jd/IroAow57UvtruzvE03lRTs2Q9GcHGcg8RnoNAX3FWOdt5oUwF5okxBDgBPfg
8n/Uqgr/Qh037ZTlZFkSIHc40zI+OIF1lnP6aI+xy84fxez6nH7PfrHxBy22/L/KpL/QlwVK
vOoYKAKQvVR4CSFx09F9HdkWsKlhPdAKACL8x3vLCWRFCztAgfd9fDL1mMpYjn0q7pBZc2T5
NnReJaH1ZgUufzkVqSr7UIuOhWn0
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID7zCCAtegAwIBAgIBADANBgkqhkiG9w0BAQsFADCBmDELMAkGA1UEBhMCVVMxEDAOBgNV
BAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxJTAjBgNVBAoTHFN0YXJmaWVsZCBU
ZWNobm9sb2dpZXMsIEluYy4xOzA5BgNVBAMTMlN0YXJmaWVsZCBTZXJ2aWNlcyBSb290IENl
cnRpZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIzNTk1
OVowgZgxCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQHEwpTY290dHNk
YWxlMSUwIwYDVQQKExxTdGFyZmllbGQgVGVjaG5vbG9naWVzLCBJbmMuMTswOQYDVQQDEzJT
dGFyZmllbGQgU2VydmljZXMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIw
DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANUMOsQq+U7i9b4Zl1+OiFOxHz/Lz58gE20p
OsgPfTz3a3Y4Y9k2YKibXlwAgLIvWX/2h/klQ4bnaRtSmpDhcePYLQ1Ob/bISdm28xpWriu2
dBTrz/sm4xq6HZYuajtYlIlHVv8loJNwU4PahHQUw2eeBGg6345AWh1KTs9DkTvnVtYAcMtS
7nt9rjrnvDH5RfbCYM8TWQIrgMw0R9+53pBlbQLPLJGmpufehRhJfGZOozptqbXuNC66DQO4
M99H67FrjSXZm86B0UVGMpZwh94CDklDhbZsc7tk6mFBrMnUVN+HL8cisibMn1lUaJ/8viov
xFUcdUBgF4UCVTmLfwUCAwEAAaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMC
AQYwHQYDVR0OBBYEFJxfAN+qAdcwKziIorhtSpzyEZGDMA0GCSqGSIb3DQEBCwUAA4IBAQBL
NqaEd2ndOxmfZyMIbw5hyf2E3F/YNoHN2BtBLZ9g3ccaaNnRbobhiCPPE95Dz+I0swSdHynV
v/heyNXBve6SbzJ08pGCL72CQnqtKrcgfU28elUSwhXqvfdqlS5sdJ/PHLTyxQGjhdByPq1z
qwubdQxtRbeOlKyWN7Wg0I8VRw7j6IPdj/3vQQF3zCepYoUz8jcI73HPdwbeyBkdiEDPfUYd
/x7H4c7/I9vG+o1VTqkC50cRRj70/b17KSa7qWFiNyi2LSr2EIZkyXCn0q23KXB56jzaYyWf
/Wi3MOxw+3WKt21gZ7IeyLnp2KhvAotnDU0mV3HaIPzBSlCNsSi6
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDTDCCAjSgAwIBAgIId3cGJyapsXwwDQYJKoZIhvcNAQELBQAwRDELMAkGA1UEBhMCVVMx
FDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVzdCBDb21tZXJjaWFs
MB4XDTEwMDEyOTE0MDYwNloXDTMwMTIzMTE0MDYwNlowRDELMAkGA1UEBhMCVVMxFDASBgNV
BAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVzdCBDb21tZXJjaWFsMIIBIjAN
BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA9htPZwcroRX1BiLLHwGy43NFBkRJLLtJJRTW
zsO3qyxPxkEylFf6EqdbDuKPHx6GGaeqtS25Xw2Kwq+FNXkyLbscYjfysVtKPcrNcV/pQr6U
6Mje+SJIZMblq8Yrba0F8PrVC8+a5fBQpIs7R6UjW3p6+DM/uO+Zl+MgwdYoic+U+7lF7eNA
FxHUdPALMeIrJmqbTFeurCA+ukV6BfO9m2kVrn1OIGPENXY6BwLJN/3HR+7o8XYdcxXyl6S1
yHp52UKqK39c/s4mT6NmgTWvRLpUHhwwMmWd5jyTXlBOeuM61G7MGvv50jeuJCqrVwMiKA1J
dX+3KNp1v47j3A55MQIDAQABo0IwQDAdBgNVHQ4EFgQUnZPGU4teyq8/nx4P5ZmVvCT2lI8w
DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQELBQADggEBAFis
9AQOzcAN/wr91LoWXym9e2iZWEnStB03TX8nfUYGXUPGhi4+c7ImfU+TqbbEKpqrIZcUsd6M
06uJFdhrJNTxFq7YpFzUf1GO7RgBsZNjvbz4YYCanrHOQnDiqX0GJX0nof5v7LMeJNrjS1Ua
ADs1tDvZ110w/YETifLCBivtZ8SOyUOyXGsViQK8YvxO8rUzqrJv0wqiUOP2O+guRMLbZjip
M1ZI8W0bM40NjD9gN53Tym1+NH4Nn3J2ixufcv1SNUFFApYvHLKac0khsUlHRUe072o0EclN
msxZt9YCnlpOZbWUrhvfKbAW8b8Angc6F2S1BLUjIZkKlTuXfO8=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDTDCCAjSgAwIBAgIIfE8EORzUmS0wDQYJKoZIhvcNAQEFBQAwRDELMAkGA1UEBhMCVVMx
FDASBgNVBAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVzdCBOZXR3b3JraW5n
MB4XDTEwMDEyOTE0MDgyNFoXDTMwMTIzMTE0MDgyNFowRDELMAkGA1UEBhMCVVMxFDASBgNV
BAoMC0FmZmlybVRydXN0MR8wHQYDVQQDDBZBZmZpcm1UcnVzdCBOZXR3b3JraW5nMIIBIjAN
BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtITMMxcua5Rsa2FSoOujz3mUTOWUgJnLVWRE
ZY9nZOIG41w3SfYvm4SEHi3yYJ0wTsyEheIszx6e/jarM3c1RNg1lho9Nuh6DtjVR6FqaYvZ
/Ls6rnla1fTWcbuakCNrmreIdIcMHl+5ni36q1Mr3Lt2PpNMCAiMHqIjHNRqrSK6mQEubWXL
viRmVSRLQESxG9fhwoXA3hA/Pe24/PHxI1Pcv2WXb9n5QHGNfb2V1M6+oF4nI979ptAmDgAp
6zxG8D1gvz9Q0twmQVGeFDdCBKNwV6gbh+0t+nvujArjqWaJGctB+d1ENmHP4ndGyH329JKB
Nv3bNPFyfvMMFr20FQIDAQABo0IwQDAdBgNVHQ4EFgQUBx/S55zawm6iQLSwelAQUHTEyL0w
DwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEBAIlX
shZ6qML91tmbmzTCnLQyFE2npN/svqe++EPbkTfOtDIuUFUaNU52Q3Eg75N3ThVwLofDwR1t
3Mu1J9QsVtFSUzpE0nPIxBsFZVpikpzuQY0x2+c06lkh1QF612S4ZDnNye2v7UsDSKegmQGA
3GWjNq5lWUhPgkvIZfFXHeVZLgo/bNjR9eUJtGxUAArgFU2HdW23WJZa3W3SAKD0m0i+wzek
ujbgfIeFlxoVot4uolu9rxj5kFDNcFn4J2dHy8egBzp90SxdbBk6ZrV9/ZFvgrG+CJPbFEfx
ojfHRZ48x3evZKiT3/Zpg4Jg8klCNO1aAFSFHBY2kgxc+qatv9s=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFRjCCAy6gAwIBAgIIbYwURrGmCu4wDQYJKoZIhvcNAQEMBQAwQTELMAkGA1UEBhMCVVMx
FDASBgNVBAoMC0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1UcnVzdCBQcmVtaXVtMB4X
DTEwMDEyOTE0MTAzNloXDTQwMTIzMTE0MTAzNlowQTELMAkGA1UEBhMCVVMxFDASBgNVBAoM
C0FmZmlybVRydXN0MRwwGgYDVQQDDBNBZmZpcm1UcnVzdCBQcmVtaXVtMIICIjANBgkqhkiG
9w0BAQEFAAOCAg8AMIICCgKCAgEAxBLfqV/+Qd3d9Z+K4/as4Tx4mrzY8H96oDMq3I0gW64t
b+eT2TZwamjPjlGjhVtnBKAQJG9dKILBl1fYSCkTtuG+kU3fhQxTGJoeJKJPj/CihQvL9Cl/
0qRY7iZNyaqoe5rZ+jjeRFcV5fiMyNlI4g0WJx0eyIOFJbe6qlVBzAMiSy2RjYvmia9mx+n/
K+k8rNrSs8PhaJyJ+HoAVt70VZVs+7pk3WKL3wt3MutizCaam7uqYoNMtAZ6MMgpv+0GTZe5
HMQxK9VfvFMSF5yZVylmd2EhMQcuJUmdGPLu8ytxjLW6OQdJd/zvLpKQBY0tL3d770O/Nbua
2Plzpyzy0FfuKE4mX4+QaAkvuPjcBukumj5Rp9EixAqnOEhss/n/fauGV+O61oV4d7pD6kh/
9ti+I20ev9E2bFhc8e6kGVQa9QPSdubhjL08s9NIS+LI+H+SqHZGnEJlPqQewQcDWkYtuJfz
t9WyVSHvutxMAJf7FJUnM7/oQ0dG0giZFmA7mn7S5u046uwBHjxIVkkJx0w3AJ6IDsBz4W9m
6XJHMD4Q5QsDyZpCAGzFlH5hxIrff4IaC1nEWTJ3s7xgaVY5/bQGeyzWZDbZvUjthB9+pSKP
KrhC9IK31FOQeE4tGv2Bb0TXOwF0lkLgAOIua+rF7nKsu7/+6qqo+Nz2snmKtmcCAwEAAaNC
MEAwHQYDVR0OBBYEFJ3AZ6YMItkm9UWrpmVSESfYRaxjMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBDAUAA4ICAQCzV00QYk465KzquByvMiPIs0laUZx2
KI15qldGF9X1Uva3ROgIRL8YhNILgM3FEv0AVQVhh0HctSSePMTYyPtwni94loMgNt58D2kT
iKV1NpgIpsbfrM7jWNa3Pt668+s0QNiigfV4Py/VpfzZotReBA4Xrf5B8OWycvpEgjNC6C1Y
91aMYj+6QrCcDFx+LmUmXFNPALJ4fqENmS2NuB2OosSw/WDQMKSOyARiqcTtNd56l+0OOF6S
L5Nwpamcb6d9Ex1+xghIsV5n61EIJenmJWtSKZGc0jlzCFfemQa0W50QBuHCAKi4HEoCChTQ
wUHK+4w1IX2COPKpVJEZNZOUbWo6xbLQu4mGk+ibyQ86p3q4ofB4Rvr8Ny/lioTz3/4E2aFo
oC8k4gmVBtWVyuEklut89pMFu+1z6S3RdTnX5yTb2E5fQ4+e0BQ5v1VwSJlXMbSc7kqYA5Yw
H2AG7hsj/oFgIxpHYoWlzBk0gG+zrBrjn/B7SK3VAdlntqlyk+otZrWyuOQ9PLLvTIzq6we/
qzWaVYa8GKa1qF60g2xraUDTn9zxw2lrueFtCfTxqlB2Cnp9ehehVZZCmTEJ3WARjQUwfuaO
RtGdFNrHF+QFlozEJLUbzxQHskD4o55BhrwE0GuWyCqANP2/7waj3VjFhT0+j/6eKeC2uAlo
GRwYQw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIB/jCCAYWgAwIBAgIIdJclisc/elQwCgYIKoZIzj0EAwMwRTELMAkGA1UEBhMCVVMxFDAS
BgNVBAoMC0FmZmlybVRydXN0MSAwHgYDVQQDDBdBZmZpcm1UcnVzdCBQcmVtaXVtIEVDQzAe
Fw0xMDAxMjkxNDIwMjRaFw00MDEyMzExNDIwMjRaMEUxCzAJBgNVBAYTAlVTMRQwEgYDVQQK
DAtBZmZpcm1UcnVzdDEgMB4GA1UEAwwXQWZmaXJtVHJ1c3QgUHJlbWl1bSBFQ0MwdjAQBgcq
hkjOPQIBBgUrgQQAIgNiAAQNMF4bFZ0D0KF5Nbc6PJJ6yhUczWLznCZcBz3lVPqj1swS6vQU
X+iOGasvLkjmrBhDeKzQN8O9ss0s5kfiGuZjuD0uL3jET9v0D6RoTFVya5UdThhClXjMNzyR
4ptlKymjQjBAMB0GA1UdDgQWBBSaryl6wBE1NSZRMADDav5A1a7WPDAPBgNVHRMBAf8EBTAD
AQH/MA4GA1UdDwEB/wQEAwIBBjAKBggqhkjOPQQDAwNnADBkAjAXCfOHiFBar8jAQr9HX/Vs
aobgxCd05DhT1wV/GzTjxi+zygk8N53X57hG8f2h4nECMEJZh0PUUd+60wkyWs6Iflc9nF9C
a/UHLbXwgpP5WW+uZPpY5Yse42O+tYHNbwKMeQ==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDuzCCAqOgAwIBAgIDBETAMA0GCSqGSIb3DQEBBQUAMH4xCzAJBgNVBAYTAlBMMSIwIAYD
VQQKExlVbml6ZXRvIFRlY2hub2xvZ2llcyBTLkEuMScwJQYDVQQLEx5DZXJ0dW0gQ2VydGlm
aWNhdGlvbiBBdXRob3JpdHkxIjAgBgNVBAMTGUNlcnR1bSBUcnVzdGVkIE5ldHdvcmsgQ0Ew
HhcNMDgxMDIyMTIwNzM3WhcNMjkxMjMxMTIwNzM3WjB+MQswCQYDVQQGEwJQTDEiMCAGA1UE
ChMZVW5pemV0byBUZWNobm9sb2dpZXMgUy5BLjEnMCUGA1UECxMeQ2VydHVtIENlcnRpZmlj
YXRpb24gQXV0aG9yaXR5MSIwIAYDVQQDExlDZXJ0dW0gVHJ1c3RlZCBOZXR3b3JrIENBMIIB
IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4/t9o3K6wvDJFIf1awFO4W5AB7ptJ11/
91sts1rHUV+rpDKmYYe2bg+G0jACl/jXaVehGDldamR5xgFZrDwxSjh80gTSSyjoIF87B6LM
TXPb865Px1bVWqeWifrzq2jUI4ZZJ88JJ7ysbnKDHDBy3+Ci6dLhdHUZvSqeexVUBBvXQzmt
VSjF4hq79MDkrjhJM8x2hZ85RdKknvISjFH4fOQtf/WsX+sWn7Et0brMkUJ3TCXJkDhv2/DM
+44el1k+1WBO5gUo7Ul5E0u6SNsv+XLTOcr+H9g0cvW0QM8xAcPs3hEtF10fuFDRXhmnad4H
MyjKUJX5p1TLVIZQRan5SQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQI
ds3LB/8k9sXN7buQvOKEN0Z19zAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggEB
AKaorSLOAT2mo/9i0Eidi15ysHhE49wcrwn9I0j6vSrEuVUEtRCjjSfeC4Jj0O7eDDd5QVsi
srCaQVymcODU0HfLI9MA4GxWL+FpDQ3Zqr8hgVDZBqWo/5U30Kr+4rP1mS1FhIrlQgnXdAIv
94nYmem8J9RHjboNRhx3zxSkHLmkMcScKHQDNP8zGSal6Q10tz6XxnboJ5ajZt3hrvJBW8qY
VoNzcOSGGtIxQbovvi0TWnZvTuhOgQ4/WwMioBK+ZlgRSssDxLQqKi2WF+A5VLxI03YnnZot
BqbJ7DnSq9ufmgsnAjUpsUCV5/nonFWIGUbWtzT1fs45mtk48VH3Tyw=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFnDCCA4SgAwIBAgIBATANBgkqhkiG9w0BAQUFADBjMQswCQYDVQQGEwJGUjETMBEGA1UE
ChMKQ2VydGlub21pczEXMBUGA1UECxMOMDAwMiA0MzM5OTg5MDMxJjAkBgNVBAMMHUNlcnRp
bm9taXMgLSBBdXRvcml0w6kgUmFjaW5lMB4XDTA4MDkxNzA4Mjg1OVoXDTI4MDkxNzA4Mjg1
OVowYzELMAkGA1UEBhMCRlIxEzARBgNVBAoTCkNlcnRpbm9taXMxFzAVBgNVBAsTDjAwMDIg
NDMzOTk4OTAzMSYwJAYDVQQDDB1DZXJ0aW5vbWlzIC0gQXV0b3JpdMOpIFJhY2luZTCCAiIw
DQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAJ2Fn4bT46/HsmtuM+Cet0I0VZ35gb5j2CN2
DpdUzZlMGvE5x4jYF1AMnmHawE5V3udauHpOd4cN5bjr+p5eex7Ezyh0x5P1FMYiKAT5kcOr
J3NqDi5N8y4oH3DfVS9O7cdxbwlyLu3VMpfQ8Vh30WC8Tl7bmoT2R2FFK/ZQpn9qcSdIhDWe
rP5pqZ56XjUl+rSnSTV3lqc2W+HN3yNw2F1MpQiD8aYkOBOo7C+ooWfHpi2GR+6K/OybDnT0
K0kCe5B1jPyZOQE51kqJ5Z52qz6WKDgmi92NjMD2AR5vpTESOH2VwnHu7XSu5DaiQ3XV8QCb
4uTXzEIDS3h65X27uK4uIJPT5GHfceF2Z5c/tt9qc1pkIuVC28+BA5PY9OMQ4HL2AHCs8MF6
DwV/zzRpRbWT5BnbUhYjBYkOjUjkJW+zeL9i9Qf6lSTClrLooyPCXQP8w9PlfMl1I9f09bze
5N/NgL+RiH2nE7Q5uiy6vdFrzPOlKO1Enn1So2+WLhl+HPNbxxaOu2B9d2ZHVIIAEWBsMsGo
OBvrbpgT1u449fCfDu/+MYHB0iSVL1N6aaLwD4ZFjliCK0wi1F6g530mJ0jfJUaNSih8hp75
mxpZuWW/Bd22Ql095gBIgl4g9xGC3srYn+Y3RyYe63j3YcNBZFgCQfna4NH4+ej9Uji29Ynf
AgMBAAGjWzBZMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBQN
jLZh2kS40RR9w759XkjwzspqsDAXBgNVHSAEEDAOMAwGCiqBegFWAgIAAQEwDQYJKoZIhvcN
AQEFBQADggIBACQ+YAZ+He86PtvqrxyaLAEL9MW12Ukx9F1BjYkMTv9sov3/4gbIOZ/xWqnd
IlgVqIrTseYyCYIDbNc/CMf4uboAbbnW/FIyXaR/pDGUu7ZMOH8oMDX/nyNTt7buFHAAQCva
R6s0fl6nVjBhK4tDrP22iCj1a7Y+YEq6QpA0Z43q619FVDsXrIvkxmUP7tCMXWY5zjKn2BCX
wH40nJ+U8/aGH88bc62UeYdocMMzpXDn2NU4lG9jeeu/Cg4I58UvD0KgKxRA/yHgBcUn4YQR
E7rWhh1BCxMjidPJC+iKunqjo3M3NYB9Ergzd0A4wPpeMNLytqOx1qKVl4GbUu1pTP+A5FPb
VFsDbVRfsbjvJL1vnxHDx2TCDyhihWZeGnuyt++uNckZM6i4J9szVb9o4XVIRFb7zdNIu0eJ
Oqxp9YDG5ERQL1TEqkPFMTFYvZbF6nVsmnWxTfj3l/+WFvKXTej28xH5On2KOG4Ey+HTRRWq
pdEdnV1j6CTmNhTih60bWfVEm/vXd3wfAXBioSAaosUaKPQhA+4u2cGA6rnZgtZbdsLLO7XS
APCjDuGtbkD326C00EauFddEwk01+dIL8hf2rGbVJLJP0RyZwG71fet0BLj5TXcJ17TPBzAJ
8bgAVtkXFhYKK4bfjwEZGuW7gmP/vgt2Fl43N+bYdJeimUV5
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIGizCCBXOgAwIBAgIEO0XlaDANBgkqhkiG9w0BAQUFADBoMQswCQYDVQQGEwJFUzEfMB0G
A1UEChMWR2VuZXJhbGl0YXQgVmFsZW5jaWFuYTEPMA0GA1UECxMGUEtJR1ZBMScwJQYDVQQD
Ex5Sb290IENBIEdlbmVyYWxpdGF0IFZhbGVuY2lhbmEwHhcNMDEwNzA2MTYyMjQ3WhcNMjEw
NzAxMTUyMjQ3WjBoMQswCQYDVQQGEwJFUzEfMB0GA1UEChMWR2VuZXJhbGl0YXQgVmFsZW5j
aWFuYTEPMA0GA1UECxMGUEtJR1ZBMScwJQYDVQQDEx5Sb290IENBIEdlbmVyYWxpdGF0IFZh
bGVuY2lhbmEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDGKqtXETcvIorKA3Qd
yu0togu8M1JAJke+WmmmO3I2F0zo37i7L3bhQEZ0ZQKQUgi0/6iMweDHiVYQOTPvaLRfX9pt
I6GJXiKjSgbwJ/BXufjpTjJ3Cj9BZPPrZe52/lSqfR0grvPXdMIKX/UIKFIIzFVd0g/bmoGl
u6GzwZTNVOAydTGRGmKy3nXiz0+J2ZGQD0EbtFpKd71ng+CT516nDOeB0/RSrFOyA8dEJvt5
5cs0YFAQexvba9dHq198aMpunUEDEO5rmXteJajCq+TA81yc477OMUxkHl6AovWDfgzWyoxV
jr7gvkkHD6MkQXpYHYTqWBLI4bft75PelAgxAgMBAAGjggM7MIIDNzAyBggrBgEFBQcBAQQm
MCQwIgYIKwYBBQUHMAGGFmh0dHA6Ly9vY3NwLnBraS5ndmEuZXMwEgYDVR0TAQH/BAgwBgEB
/wIBAjCCAjQGA1UdIASCAiswggInMIICIwYKKwYBBAG/VQIBADCCAhMwggHoBggrBgEFBQcC
AjCCAdoeggHWAEEAdQB0AG8AcgBpAGQAYQBkACAAZABlACAAQwBlAHIAdABpAGYAaQBjAGEA
YwBpAPMAbgAgAFIAYQDtAHoAIABkAGUAIABsAGEAIABHAGUAbgBlAHIAYQBsAGkAdABhAHQA
IABWAGEAbABlAG4AYwBpAGEAbgBhAC4ADQAKAEwAYQAgAEQAZQBjAGwAYQByAGEAYwBpAPMA
bgAgAGQAZQAgAFAAcgDhAGMAdABpAGMAYQBzACAAZABlACAAQwBlAHIAdABpAGYAaQBjAGEA
YwBpAPMAbgAgAHEAdQBlACAAcgBpAGcAZQAgAGUAbAAgAGYAdQBuAGMAaQBvAG4AYQBtAGkA
ZQBuAHQAbwAgAGQAZQAgAGwAYQAgAHAAcgBlAHMAZQBuAHQAZQAgAEEAdQB0AG8AcgBpAGQA
YQBkACAAZABlACAAQwBlAHIAdABpAGYAaQBjAGEAYwBpAPMAbgAgAHMAZQAgAGUAbgBjAHUA
ZQBuAHQAcgBhACAAZQBuACAAbABhACAAZABpAHIAZQBjAGMAaQDzAG4AIAB3AGUAYgAgAGgA
dAB0AHAAOgAvAC8AdwB3AHcALgBwAGsAaQAuAGcAdgBhAC4AZQBzAC8AYwBwAHMwJQYIKwYB
BQUHAgEWGWh0dHA6Ly93d3cucGtpLmd2YS5lcy9jcHMwHQYDVR0OBBYEFHs100DSHHgZZu90
ECjcPk+yeAT8MIGVBgNVHSMEgY0wgYqAFHs100DSHHgZZu90ECjcPk+yeAT8oWykajBoMQsw
CQYDVQQGEwJFUzEfMB0GA1UEChMWR2VuZXJhbGl0YXQgVmFsZW5jaWFuYTEPMA0GA1UECxMG
UEtJR1ZBMScwJQYDVQQDEx5Sb290IENBIEdlbmVyYWxpdGF0IFZhbGVuY2lhbmGCBDtF5Wgw
DQYJKoZIhvcNAQEFBQADggEBACRhTvW1yEICKrNcda3FbcrnlD+laJWIwVTAEGmiEi8YPyVQ
qHxK6sYJ2fR1xkDar1CdPaUWu20xxsdzCkj+IHLtb8zog2EWRpABlUt9jppSCS/2bxzkoXHP
jCpaF3ODR00PNvsETUlR4hTJZGH71BTg9J63NI8KJr2XXPR5OkowGcytT6CYirQxlyric21+
eLj4iIlPsSKRZEv1UN4D2+XFducTZnV+ZfsBn5OHiJ35Rld8TWCvmHMTI6QgkYH60GFmuH3R
r9ZvHmw96RH9qfmCIoaZM3Fa6hlXPZHNqcCjbgcTpsnt+GijnsNacgmHKNHEc8RzGF9QdRYx
n7fofMM=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDezCCAmOgAwIBAgIBATANBgkqhkiG9w0BAQUFADBfMQswCQYDVQQGEwJUVzESMBAGA1UE
CgwJVEFJV0FOLUNBMRAwDgYDVQQLDAdSb290IENBMSowKAYDVQQDDCFUV0NBIFJvb3QgQ2Vy
dGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMDgwODI4MDcyNDMzWhcNMzAxMjMxMTU1OTU5WjBf
MQswCQYDVQQGEwJUVzESMBAGA1UECgwJVEFJV0FOLUNBMRAwDgYDVQQLDAdSb290IENBMSow
KAYDVQQDDCFUV0NBIFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggEiMA0GCSqGSIb3
DQEBAQUAA4IBDwAwggEKAoIBAQCwfnK4pAOU5qfeCTiRShFAh6d8WWQUe7UREN3+v9XAu1bi
hSX0NXIP+FPQQeFEAcK0HMMxQhZHhTMidrIKbw/lJVBPhYa+v5guEGcevhEFhgWQxFnQfHgQ
sIBct+HHK3XLfJ+utdGdIzdjp9xCoi2SBBtQwXu4PhvJVgSLL1KbralW6cH/ralYhzC2gfeX
RfwZVzsrb+RH9JlF/h3x+JejiB03HFyP4HYlmlD4oFT/RJB2I9IyxsOrBr/8+7/zrX2SYgJb
KdM1o5OaQ2RgXbL6Mv87BK9NQGr5x+PvI/1ry+UPizgN7gr8/g+YnzAx3WxSZfmLgb4i4RxY
A7qRG4kHAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1Ud
DgQWBBRqOFsmjd6LWvJPelSDGRjjCDWmujANBgkqhkiG9w0BAQUFAAOCAQEAPNV3PdrfibqH
DAhUaiBQkr6wQT25JmSDCi/oQMCXKCeCMErJk/9q56YAf4lCmtYR5VPOL8zy2gXE/uJQxDqG
fczafhAJO5I1KlOy/usrBdlsXebQ79NqZp4VKIV66IIArB6nCWlWQtNoURi+VJq/REG6Sb4g
umlc7rh3zc5sH62Dlhh9DrUUOYTxKOkto557HnpyWoOzeW/vtPzQCqVYT0bf+215WfKEIlKu
D8z7fDvnaspHYcN6+NOSBB+4IIThNlQWx0DeO4pz3N/GCUzf7Nr/1FNCocnyYh0igzyXxfkZ
YiesZSLX0zzG5Y6yU8xJzrww/nsOM5D77dIUkR8Hrw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDdzCCAl+gAwIBAgIBADANBgkqhkiG9w0BAQsFADBdMQswCQYDVQQGEwJKUDElMCMGA1UE
ChMcU0VDT00gVHJ1c3QgU3lzdGVtcyBDTy4sTFRELjEnMCUGA1UECxMeU2VjdXJpdHkgQ29t
bXVuaWNhdGlvbiBSb290Q0EyMB4XDTA5MDUyOTA1MDAzOVoXDTI5MDUyOTA1MDAzOVowXTEL
MAkGA1UEBhMCSlAxJTAjBgNVBAoTHFNFQ09NIFRydXN0IFN5c3RlbXMgQ08uLExURC4xJzAl
BgNVBAsTHlNlY3VyaXR5IENvbW11bmljYXRpb24gUm9vdENBMjCCASIwDQYJKoZIhvcNAQEB
BQADggEPADCCAQoCggEBANAVOVKxUrO6xVmCxF1SrjpDZYBLx/KWvNs2l9amZIyoXvDjChz3
35c9S672XewhtUGrzbl+dp+++T42NKA7wfYxEUV0kz1XgMX5iZnK5atq1LXaQZAQwdbWQonC
v/Q4EpVMVAX3NuRFg3sUZdbcDE3R3n4MqzvEFb46VqZab3ZpUql6ucjrappdUtAtCms1FgkQ
hNBqyjoGADdH5H5XTz+L62e4iKrFvlNVspHEfbmwhRkGeC7bYRr6hfVKkaHnFtWOojnflLhw
Hyg/i/xAXmODPIMqGplrz95Zajv8bxbXH/1KEOtOghY6rCcMU/Gt1SSwawNQwS08Ft1ENCca
dfsCAwEAAaNCMEAwHQYDVR0OBBYEFAqFqXdlBZh8QIH4D5csOPEK7DzPMA4GA1UdDwEB/wQE
AwIBBjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQBMOqNErLlFsceTfsgL
CkLfZOoc7llsCLqJX2rKSpWeeo8HxdpFcoJxDjrSzG+ntKEju/Ykn8sX/oymzsLS28yN/HH8
AynBbF0zX2S2ZTuJbxh2ePXcokgfGT+Ok+vx+hfuzU7jBBJV1uXk3fs+BXziHV7Gp7yXT2g6
9ekuCkO2r1dcYmh8t/2jioSgrGK+KwmHNPBqAbubKVY8/gA3zyNs8U6qtnRGEmyR7jTV7JqR
50S+kDFy1UkC9gLl9B/rfNmWVan/7Ir5mUf/NVoCqgTLiluHcSmRvaS0eg29mvVXIwAHIRc/
SjnRBUkLp7Y3gaVdjKozXoEofKd9J+sAro03
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFVjCCBD6gAwIBAgIQ7is969Qh3hSoYqwE893EATANBgkqhkiG9w0BAQUFADCB8zELMAkG
A1UEBhMCRVMxOzA5BgNVBAoTMkFnZW5jaWEgQ2F0YWxhbmEgZGUgQ2VydGlmaWNhY2lvIChO
SUYgUS0wODAxMTc2LUkpMSgwJgYDVQQLEx9TZXJ2ZWlzIFB1YmxpY3MgZGUgQ2VydGlmaWNh
Y2lvMTUwMwYDVQQLEyxWZWdldSBodHRwczovL3d3dy5jYXRjZXJ0Lm5ldC92ZXJhcnJlbCAo
YykwMzE1MDMGA1UECxMsSmVyYXJxdWlhIEVudGl0YXRzIGRlIENlcnRpZmljYWNpbyBDYXRh
bGFuZXMxDzANBgNVBAMTBkVDLUFDQzAeFw0wMzAxMDcyMzAwMDBaFw0zMTAxMDcyMjU5NTla
MIHzMQswCQYDVQQGEwJFUzE7MDkGA1UEChMyQWdlbmNpYSBDYXRhbGFuYSBkZSBDZXJ0aWZp
Y2FjaW8gKE5JRiBRLTA4MDExNzYtSSkxKDAmBgNVBAsTH1NlcnZlaXMgUHVibGljcyBkZSBD
ZXJ0aWZpY2FjaW8xNTAzBgNVBAsTLFZlZ2V1IGh0dHBzOi8vd3d3LmNhdGNlcnQubmV0L3Zl
cmFycmVsIChjKTAzMTUwMwYDVQQLEyxKZXJhcnF1aWEgRW50aXRhdHMgZGUgQ2VydGlmaWNh
Y2lvIENhdGFsYW5lczEPMA0GA1UEAxMGRUMtQUNDMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAsyLHT+KXQpWIR4NA9h0X84NzJB5R85iKw5K4/0CQBXCHYMkAqbWUZRkiFRfC
Q2xmRJoNBD45b6VLeqpjt4pEndljkYRm4CgPukLjbo73FCeTae6RDqNfDrHrZqJyTxIThmV6
PttPB/SnCWDaOkKZx7J/sxaVHMf5NLWUhdWZXqBIoH7nF2W4onW4HvPlQn2v7fOKSGRdghST
2MDk/7NQcvJ29rNdQlB50JQ+awwAvthrDk4q7D7SzIKiGGUzE3eeml0aE9jD2z3Il3rucO2n
5nzbcc8tlGLfbdb1OL4/pYUKGbio2Al1QnDE6u/LDsg0qBIimAy4E5S2S+zw0JDnJwIDAQAB
o4HjMIHgMB0GA1UdEQQWMBSBEmVjX2FjY0BjYXRjZXJ0Lm5ldDAPBgNVHRMBAf8EBTADAQH/
MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUoMOLRKo3pUW/l4Ba0fF4opvpXY0wfwYDVR0g
BHgwdjB0BgsrBgEEAfV4AQMBCjBlMCwGCCsGAQUFBwIBFiBodHRwczovL3d3dy5jYXRjZXJ0
Lm5ldC92ZXJhcnJlbDA1BggrBgEFBQcCAjApGidWZWdldSBodHRwczovL3d3dy5jYXRjZXJ0
Lm5ldC92ZXJhcnJlbCAwDQYJKoZIhvcNAQEFBQADggEBAKBIW4IB9k1IuDlVNZyAelOZ1Vr/
sXE7zDkJlF7W2u++AVtd0x7Y/X1PzaBB4DSTv8vihpw3kpBWHNzrKQXlxJ7HNd+KDM3FIUPp
qojlNcAZQmNaAl6kSBg6hW/cnbw/nZzBh7h6YQjpdwt/cKt63dmXLGQehb+8dJahw3oS7Awa
boMMPOhyRp/7SNVel+axofjk70YllJyJ22k4vuxcDlbHZVHlUIiIv0LVKz3l+bqeLrPK9HOS
Agu+TGbrIP65y7WZf+a2E/rKS03Z7lNGBjvGTq2TWoF+bCpLagVFjPIhpDGQh2xlnJ2lYJU6
Un/10asIbvPuW/mIPX64b24D5EI=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEMTCCAxmgAwIBAgIBADANBgkqhkiG9w0BAQUFADCBlTELMAkGA1UEBhMCR1IxRDBCBgNV
BAoTO0hlbGxlbmljIEFjYWRlbWljIGFuZCBSZXNlYXJjaCBJbnN0aXR1dGlvbnMgQ2VydC4g
QXV0aG9yaXR5MUAwPgYDVQQDEzdIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFyY2ggSW5z
dGl0dXRpb25zIFJvb3RDQSAyMDExMB4XDTExMTIwNjEzNDk1MloXDTMxMTIwMTEzNDk1Mlow
gZUxCzAJBgNVBAYTAkdSMUQwQgYDVQQKEztIZWxsZW5pYyBBY2FkZW1pYyBhbmQgUmVzZWFy
Y2ggSW5zdGl0dXRpb25zIENlcnQuIEF1dGhvcml0eTFAMD4GA1UEAxM3SGVsbGVuaWMgQWNh
ZGVtaWMgYW5kIFJlc2VhcmNoIEluc3RpdHV0aW9ucyBSb290Q0EgMjAxMTCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAKlTAOMupvaO+mDYLZU++CwqVE7NuYRhlFhPjz2L5EPz
dYmNUeTDN9KKiE15HrcS3UN4SoqS5tdI1Q+kOilENbgH9mgdVc04UfCMJDGFr4PJfel3r+0a
e50X+bOdOFAPplp5kYCvN66m0zH7tSYJnTxa71HFK9+WXesyHgLacEnsbgzImjeN9/E2YEsm
LIKe0HjzDQ9jpFEw4fkrJxIH2Oq9GGKYsFk3fb7u8yBRQlqD75O6aRXxYp2fmTmCobd0LovU
xQt7L/DICto9eQqakxylKHJzkUOap9FNhYS5qXSPFEDH3N6sQWRstBmbAmNtJGSPRLIl6s5d
dAxjMlyNh+UCAwEAAaOBiTCBhjAPBgNVHRMBAf8EBTADAQH/MAsGA1UdDwQEAwIBBjAdBgNV
HQ4EFgQUppFC/RNhSiOeCKQp5dgTBCPuQSUwRwYDVR0eBEAwPqA8MAWCAy5ncjAFggMuZXUw
BoIELmVkdTAGggQub3JnMAWBAy5ncjAFgQMuZXUwBoEELmVkdTAGgQQub3JnMA0GCSqGSIb3
DQEBBQUAA4IBAQAf73lB4XtuP7KMhjdCSk4cNx6NZrokgclPEg8hwAOXhiVtXdMiKahsog2p
6z0GW5k6x8zDmjR/qw7IThzh+uTczQ2+vyT+bOdrwg3IBp5OjWEopmr95fZi6hg8TqBTnbI6
nOulnJEWtk2C4AwFSKls9cz4y51JtPACpf1wA+2KIaWuE4ZJwzNzvoc7dIsXRSZMFpGD/md9
zU1jZ/rzAxKWeAaNsWftjj++n08C9bMJL/NMh98qy5V8AcysNnq/onN694/BtZqhFLKPM58N
7yLcZnuEvUUXBj08yrl3NI/K6s8/MT7jiOOASSXIl7WdmplNsDz4SgCbZN2fOUvRJ9e4
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFuzCCA6OgAwIBAgIIVwoRl0LE48wwDQYJKoZIhvcNAQELBQAwazELMAkGA1UEBhMCSVQx
DjAMBgNVBAcMBU1pbGFuMSMwIQYDVQQKDBpBY3RhbGlzIFMucC5BLi8wMzM1ODUyMDk2NzEn
MCUGA1UEAwweQWN0YWxpcyBBdXRoZW50aWNhdGlvbiBSb290IENBMB4XDTExMDkyMjExMjIw
MloXDTMwMDkyMjExMjIwMlowazELMAkGA1UEBhMCSVQxDjAMBgNVBAcMBU1pbGFuMSMwIQYD
VQQKDBpBY3RhbGlzIFMucC5BLi8wMzM1ODUyMDk2NzEnMCUGA1UEAwweQWN0YWxpcyBBdXRo
ZW50aWNhdGlvbiBSb290IENBMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAp8bE
pSmkLO/lGMWwUKNvUTufClrJwkg4CsIcoBh/kbWHuUA/3R1oHwiD1S0eiKD4j1aPbZkCkpAW
1V8IbInX4ay8IMKx4INRimlNAJZaby/ARH6jDuSRzVju3PvHHkVH3Se5CAGfpiEd9UEtL0z9
KK3giq0itFZljoZUj5NDKd45RnijMCO6zfB9E1fAXdKDa0hMxKufgFpbOr3JpyI/gCczWw63
igxdBzcIy2zSekciRDXFzMwujt0q7bd9Zg1fYVEiVRvjRuPjPdA1YprbrxTIW6HMiRvhMCb8
oJsfgadHHwTrozmSBp+Z07/T6k9QnBn+locePGX2oxgkg4YQ51Q+qDp2JE+BIcXjDwL4k5RH
ILv+1A7TaLndxHqEguNTVHnd25zS8gebLra8Pu2Fbe8lEfKXGkJh90qX6IuxEAf6ZYGyojnP
9zz/GPvG8VqLWeICrHuS0E4UT1lF9gxeKF+w6D9Fz8+vm2/7hNN3WpVvrJSEnu68wEqPSpP4
RCHiMUVhUE4Q2OM1fEwZtN4Fv6MGn8i1zeQf1xcGDXqVdFUNaBr8EBtiZJ1t4JWgw5QHVw0U
5r0F+7if5t+L4sbnfpb2U8WANFAoWPASUHEXMLrmeGO89LKtmyuy/uE5jF66CyCU3nuDuP/j
Vo23Eek7jPKxwV2dpAtMK9myGPW1n0sCAwEAAaNjMGEwHQYDVR0OBBYEFFLYiDrIn3hm7Ynz
ezhwlMkCAjbQMA8GA1UdEwEB/wQFMAMBAf8wHwYDVR0jBBgwFoAUUtiIOsifeGbtifN7OHCU
yQICNtAwDgYDVR0PAQH/BAQDAgEGMA0GCSqGSIb3DQEBCwUAA4ICAQALe3KHwGCmSUyIWOYd
iPcUZEim2FgKDk8TNd81HdTtBjHIgT5q1d07GjLukD0R0i70jsNjLiNmsGe+b7bAEzlgqqI0
JZN1Ut6nna0Oh4lScWoWPBkdg/iaKWW+9D+a2fDzWochcYBNy+A4mz+7+uAwTc+G02UQGRjR
lwKxK3JCaKygvU5a2hi/a5iB0P2avl4VSM0RFbnAKVy06Ij3Pjaut2L9HmLecHgQHEhb2ryk
OLpn7VU+Xlff1ANATIGk0k9jpwlCCRT8AKnCgHNPLsBA2RF7SOp6AsDT6ygBJlh0wcBzIm2T
lf05fbsq4/aC4yyXX04fkZT6/iyj2HYauE2yOE+b+h1IYHkm4vP9qdCa6HCPSXrW5b0KDtst
842/6+OkfcvHlXHo2qN8xcL4dJIEG4aspCJTQLas/kx2z/uUMsA1n3Y/buWQbqCmJqK4LL7R
K4X9p2jIugErsWx0Hbhzlefut8cl8ABMALJ+tguLHPPAUJ4lueAI3jZm/zel0btUZCzJJ7VL
kn5l/9Mt4blOvH+kQSGQQXemOR/qnuOf0GZvBeyqdn6/axag67XH/JJULysRJyU3eExRarDz
zFhdFPFqSBX/wge2sY0PjlxQRrM9vwGYT7JZVEc+NHt4bVaTLnPqZih4zR0Uv6CPLy64Lo7y
FIrM6bV8+2ydDKXhlg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDZzCCAk+gAwIBAgIQGx+ttiD5JNM2a/fH8YygWTANBgkqhkiG9w0BAQUFADBFMQswCQYD
VQQGEwJHQjEYMBYGA1UEChMPVHJ1c3RpcyBMaW1pdGVkMRwwGgYDVQQLExNUcnVzdGlzIEZQ
UyBSb290IENBMB4XDTAzMTIyMzEyMTQwNloXDTI0MDEyMTExMzY1NFowRTELMAkGA1UEBhMC
R0IxGDAWBgNVBAoTD1RydXN0aXMgTGltaXRlZDEcMBoGA1UECxMTVHJ1c3RpcyBGUFMgUm9v
dCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMVQe547NdDfxIzNjpvto8A2
mfRC6qc+gIMPpqdZh8mQRUN+AOqGeSoDvT03mYlmt+WKVoaTnGhLaASMk5MCPjDSNzoiYYkc
hU59j9WvezX2fihHiTHcDnlkH5nSW7r+f2C/revnPDgpai/lkQtV/+xvWNUtyd5MZnGPDNcE
2gfmHhjjvSkCqPoc4Vu5g6hBSLwacY3nYuUtsuvffM/bq1rKMfFMIvMFE/eC+XN5DL7XSxzA
0RU8k0Fk0ea+IxciAIleH2ulrG6nS4zto3Lmr2NNL4XSFDWaLk6M6jKYKIahkQlBOrTh4/L6
8MkKokHdqeMDx4gVOxzUGpTXn2RZEm0CAwEAAaNTMFEwDwYDVR0TAQH/BAUwAwEB/zAfBgNV
HSMEGDAWgBS6+nEleYtXQSUhhgtx67JkDoshZzAdBgNVHQ4EFgQUuvpxJXmLV0ElIYYLceuy
ZA6LIWcwDQYJKoZIhvcNAQEFBQADggEBAH5Y//01GX2cGE+esCu8jowU/yyg2kdbw++BLa8F
6nRIW/M+TgfHbcWzk88iNVy2P3UnXwmWzaD+vkAMXBJV+JOCyinpXj9WV4s4NvdFGkwozZ5B
uO1WTISkQMi4sKUraXAEasP41BIy+Q7DsdwyhEQsb8tGD+pmQQ9P8Vilpg0ND2HepZ5dfWWh
PBfnqFVO76DH7cZEf1T1o+CP8HxVIo8ptoGj4W1OLBuAZ+ytIJ8MYmHVl/9D7S3B2l0pKoU/
rGXuhg8FjZBf3+6f9L/uHfuY5H+QK4R4EA5sSVPvFVtlRkpdr7r7OnIdzfYliB6XzCGcKQEN
ZetX2fNXlrtIzYE=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIHhzCCBW+gAwIBAgIBLTANBgkqhkiG9w0BAQsFADB9MQswCQYDVQQGEwJJTDEWMBQGA1UE
ChMNU3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUg
U2lnbmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcN
MDYwOTE3MTk0NjM3WhcNMzYwOTE3MTk0NjM2WjB9MQswCQYDVQQGEwJJTDEWMBQGA1UEChMN
U3RhcnRDb20gTHRkLjErMCkGA1UECxMiU2VjdXJlIERpZ2l0YWwgQ2VydGlmaWNhdGUgU2ln
bmluZzEpMCcGA1UEAxMgU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0G
CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDBiNsJvGxGfHiflXu1M5DycmLWwTYgIiRezul3
8kMKogZkpMyONvg45iPwbm2xPN1yo4UcodM9tDMr0y+v/uqwQVlntsQGfQqedIXWeUyAN3rf
OQVSWff0G0ZDpNKFhdLDcfN1YjS6LIp/Ho/u7TTQEceWzVI9ujPW3U3eCztKS5/CJi/6tRYc
cjV3yjxd5srhJosaNnZcAdt0FCX+7bWgiA/deMotHweXMAEtcnn6RtYTKqi5pquDSR3l8u/d
5AGOGAqPY1MWhWKpDhk6zLVmpsJrdAfkK+F2PrRt2PZE4XNiHzvEvqBTViVsUQn3qqvKv3b9
bZvzndu/PWa8DFaqr5hIlTpL36dYUNk4dalb6kMMAv+Z6+hsTXBbKWWc3apdzK8BMewM69KN
6Oqce+Zu9ydmDBpI125C4z/eIT574Q1w+2OqqGwaVLRcJXrJosmLFqa7LH4XXgVNWG4SHQHu
EhANxjJ/GP/89PrNbpHoNkm+Gkhpi8KWTRoSsmkXwQqQ1vp5Iki/untp+HDH+no32NgN0nZP
V/+Qt+OR0t3vwmC3Zzrd/qqc8NSLf3Iizsafl7b4r4qgEKjZ+xjGtrVcUjyJthkqcwEKDwOz
EmDyei+B26Nu/yYwl/WL3YlXtq09s68rxbd2AvCl1iuahhQqcvbjM4xdCUsT37uMdBNSSwID
AQABo4ICEDCCAgwwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE
FE4L7xqkQFulF2mHMMo0aEPQQa7yMB8GA1UdIwQYMBaAFE4L7xqkQFulF2mHMMo0aEPQQa7y
MIIBWgYDVR0gBIIBUTCCAU0wggFJBgsrBgEEAYG1NwEBATCCATgwLgYIKwYBBQUHAgEWImh0
dHA6Ly93d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYwNAYIKwYBBQUHAgEWKGh0dHA6Ly93
d3cuc3RhcnRzc2wuY29tL2ludGVybWVkaWF0ZS5wZGYwgc8GCCsGAQUFBwICMIHCMCcWIFN0
YXJ0IENvbW1lcmNpYWwgKFN0YXJ0Q29tKSBMdGQuMAMCAQEagZZMaW1pdGVkIExpYWJpbGl0
eSwgcmVhZCB0aGUgc2VjdGlvbiAqTGVnYWwgTGltaXRhdGlvbnMqIG9mIHRoZSBTdGFydENv
bSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSBQb2xpY3kgYXZhaWxhYmxlIGF0IGh0dHA6Ly93
d3cuc3RhcnRzc2wuY29tL3BvbGljeS5wZGYwEQYJYIZIAYb4QgEBBAQDAgAHMDgGCWCGSAGG
+EIBDQQrFilTdGFydENvbSBGcmVlIFNTTCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTANBgkq
hkiG9w0BAQsFAAOCAgEAjo/n3JR5fPGFf59Jb2vKXfuM/gTFwWLRfUKKvFO3lANmMD+x5wqn
UCBVJX92ehQN6wQOQOY+2IirByeDqXWmN3PH/UvSTa0XQMhGvjt/UfzDtgUx3M2FIk5xt/Jx
XrAaxrqTi3iSSoX4eA+D/i+tLPfkpLst0OcNOrg+zvZ49q5HJMqjNTbOx8aHmNrs++myzieb
iMMEofYLWWivydsQD032ZGNcpRJvkrKTlMeIFw6Ttn5ii5B/q06f/ON1FE8qMt9bDeD1e5MN
q6HPh+GlBEXoPBKlCcWw0bdT82AUuoVpaiF8H3VhFyAXe2w7QSlc4axa0c2Mm+tgHRns9+Ww
2vl5GKVFP0lDV9LdJNUso/2RjSe15esUBppMeyG7Oq0wBhjA2MFrLH9ZXF2RsXAiV+uKa0hK
1Q8p7MZAwC+ITGgBF3f0JBlPvfrhsiAhS90a2Cl9qrjeVOwhVYBsHvUwyKMQ5bLmKhQxw4Ut
jJixhlpPiVktucf3HMiKf8CdBUrmQk9io20ppB+Fq9vlgcitKj1MXVuEJnHEhV5xJMqlG2zY
YdMa4FTbzrqpMrUi9nNBCV24F10OD5mQ1kfabwo6YigUZ4LZ8dCAWZvLMdibD4x3TrVoivJs
9iQOLWxwxXPR3hTQcY+203sC9uO41Alua551hDnmfyWl8kgAwKQB2j8=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFYzCCA0ugAwIBAgIBOzANBgkqhkiG9w0BAQsFADBTMQswCQYDVQQGEwJJTDEWMBQGA1UE
ChMNU3RhcnRDb20gTHRkLjEsMCoGA1UEAxMjU3RhcnRDb20gQ2VydGlmaWNhdGlvbiBBdXRo
b3JpdHkgRzIwHhcNMTAwMTAxMDEwMDAxWhcNMzkxMjMxMjM1OTAxWjBTMQswCQYDVQQGEwJJ
TDEWMBQGA1UEChMNU3RhcnRDb20gTHRkLjEsMCoGA1UEAxMjU3RhcnRDb20gQ2VydGlmaWNh
dGlvbiBBdXRob3JpdHkgRzIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2iTZb
B7cgNr2Cu+EWIAOVeq8Oo1XJJZlKxdBWQYeQTSFgpBSHO839sj60ZwNq7eEPS8CRhXBF4EKe
3ikj1AENoBB5uNsDvfOpL9HG4A/LnooUCri99lZi8cVytjIl2bLzvWXFDSxu1ZJvGIsAQRSC
b0AgJnooD/Uefyf3lLE3PbfHkffiAez9lInhzG7TNtYKGXmu1zSCZf98Qru23QumNK9LYP5/
Q0kGi4xDuFby2X8hQxfqp0iVAXV16iulQ5XqFYSdCI0mblWbq9zSOdIxHWDirMxWRST1HFSr
7obdljKF+ExP6JV2tgXdNiNnvP8V4so75qbsO+wmETRIjfaAKxojAuuKHDp2KntWFhxyKrOq
42ClAJ8Em+JvHhRYW6Vsi1g8w7pOOlz34ZYrPu8HvKTlXcxNnw3h3Kq74W4a7I/htkxNeXJd
FzULHdfBR9qWJODQcqhaX2YtENwvKhOuJv4KHBnM0D4LnMgJLvlblnpHnOl68wVQdJVznjAJ
85eCXuaPOQgeWeU1FEIT/wCc976qUM/iUUjXuG+v+E5+M5iSFGI6dWPPe/regjupuznixL0s
AA7IF6wT700ljtizkC+p2il9Ha90OrInwMEePnWjFqmveiJdnxMaz6eg6+OGCtP95paV1yPI
N93EfKo2rJgaErHgTuixO/XWb/Ew1wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1Ud
DwEB/wQEAwIBBjAdBgNVHQ4EFgQUS8W0QGutHLOlHGVuRjaJhwUMDrYwDQYJKoZIhvcNAQEL
BQADggIBAHNXPyzVlTJ+N9uWkusZXn5T50HsEbZH77Xe7XRcxfGOSeD8bpkTzZ+K2s06Ctg6
Wgk/XzTQLwPSZh0avZyQN8gMjgdalEVGKua+etqhqaRpEpKwfTbURIfXUfEpY9Z1zRbkJ4kd
+MIySP3bmdCPX1R0zKxnNBFi2QwKN4fRoxdIjtIXHfbX/dtl6/2o1PXWT6RbdejF0mCy2wl+
JYt7ulKSnj7oxXehPOBKc2thz4bcQ///If4jXSRK9dNtD2IEBVeC2m6kMyV5Sy5UGYvMLD0w
6dEG/+gyRr61M3Z3qAFdlsHB1b6uJcDJHgoJIIihDsnzb02CVAAgp9KP5DlUFy6NHrgbuxu9
mk47EDTcnIhT76IxW1hPkWLIwpqazRVdOKnWvvgTtZ8SafJQYqz7Fzf07rh1Z2AQ+4NQ+US1
dZxAF7L+/XldblhYXzD8AK6vM8EOTmy6p6ahfzLbOOCxchcKK5HsamMm7YnUeMx0HgX4a/6M
anY5Ka5lIxKVCCIcl85bBu4M4ru8H0ST9tg4RQUh7eStqxK2A6RCLi3ECToDZ2mEmuFZkIoo
hdVddLHRDiBYmxOlsGOm7XtH/UVVMKTumtTm4ofvmMkyghEpIrwACjFeLQ/Ajulrso8uBtjR
kcfGEvRM/TAXw8HaOFvjqermobp573PYtlNXLfbQ4ddI
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEdMBsGA1UE
CgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3MgQ2xhc3MgMiBSb290
IENBMB4XDTEwMTAyNjA4MzgwM1oXDTQwMTAyNjA4MzgwM1owTjELMAkGA1UEBhMCTk8xHTAb
BgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAwHgYDVQQDDBdCdXlwYXNzIENsYXNzIDIg
Um9vdCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBANfHXvfBB9R3+0Mh9PT1
aeTuMgHbo4Yf5FkNuud1g1Lr6hxhFUi7HQfKjK6w3Jad6sNgkoaCKHOcVgb/S2TwDCo3SbXl
zwx87vFKu3MwZfPVL4O2fuPn9Z6rYPnT8Z2SdIrkHJasW4DptfQxh6NR/Md+oW+OU3fUl8FV
M5I+GC911K2GScuVr1QGbNgGE41b/+EmGVnAJLqBcXmQRFBoJJRfuLMR8SlBYaNByyM21cHx
MlAQTn/0hpPshNOOvEu/XAFOBz3cFIqUCqTqc/sLUegTBxj6DvEr0VQVfTzh97QZQmdiXnfg
olXsttlpF9U6r0TtSsWe5HonfOV116rLJeffawrbD02TTqigzXsu8lkBarcNuAeBfos4Gzjm
CleZPe4h6KP1DBbdi+w0jpwqHAAVF41og9JwnxgIzRFo1clrUs3ERo/ctfPYV3Me6ZQ5BL/T
3jjetFPsaRyifsSP5BtwrfKi+fv3FmRmaZ9JUaLiFRhnBkp/1Wy1TbMz4GHrXb7pmA8y1x1L
PC5aAVKRCfLf6o3YBkBjqhHk/sM3nhRSP/TizPJhk9H9Z2vXUq6/aKtAQ6BXNVN48FP4YUIH
ZMbXb5tMOA1jrGKvNouicwoN9SG9dKpN6nIDSdvHXx1iY8f93ZHsM+71bbRuMGjeyNYmsHVe
e7QHIJihdjK4TWxPAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFMmAd+Bi
koL1RpzzuvdMw964o605MA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAU18h
9bqwOlI5LJKwbADJ784g7wbylp7ppHR/ehb8t/W2+xUbP6umwHJdELFx7rxP462sA20ucS6v
xOOto70MEae0/0qyexAQH6dXQbLArvQsWdZHEIjzIVEpMMpghq9Gqx3tOluwlN5E40EIosHs
Hdb9T7bWR9AUC8rmyrV7d35BH16Dx7aMOZawP5aBQW9gkOLo+fsicdl9sz1Gv7SEr5AcD48S
aq/v7h56rgJKihcrdv6sVIkkLE8/trKnToyokZf7KcZ7XC25y2a2t6hbElGFtQl+Ynhw/qlq
YLYdDnkM/crqJIByw5c/8nerQyIKx+u2DISCLIBrQYoIwOula9+ZEsuK1V6ADJHgJgg2SMX6
OBE1/yWDLfJ6v9r9jv6ly0UsH8SIU653DtmadsWOLB2jutXsMq7Aqqz30XpN69QH4kj3Io6w
pJ9qzo6ysmD0oyLQI+uUWnpp3Q+/QFesa1lQ2aOZ4W7+jQF5JyMV3pKdewlNWudLSDBaGOYK
beaP4NK75t98biGCwWg5TbSYWGZizEqQXsP6JwSxeRV0mcy+rSDeJmAc61ZRpqPq5KM/p/9h
3PFaTWwyI0PurKju7koSCTxdccK+efrCh2gdC/1cacwG0Jp9VJkqyTkaGa9LKkPzY11aWOIv
4x3kqdbQCtCev9eBCfHJxyYNrJgWVqA=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFWTCCA0GgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBOMQswCQYDVQQGEwJOTzEdMBsGA1UE
CgwUQnV5cGFzcyBBUy05ODMxNjMzMjcxIDAeBgNVBAMMF0J1eXBhc3MgQ2xhc3MgMyBSb290
IENBMB4XDTEwMTAyNjA4Mjg1OFoXDTQwMTAyNjA4Mjg1OFowTjELMAkGA1UEBhMCTk8xHTAb
BgNVBAoMFEJ1eXBhc3MgQVMtOTgzMTYzMzI3MSAwHgYDVQQDDBdCdXlwYXNzIENsYXNzIDMg
Um9vdCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAKXaCpUWUOOV8l6ddjEG
Mnqb8RB2uACatVI2zSRHsJ8YZLya9vrVediQYkwiL944PdbgqOkcLNt4EemOaFEVcsfzM4fk
oF0LXOBXByow9c3EN3coTRiR5r/VUv1xLXA+58bEiuPwKAv0dpihi4dVsjoT/Lc+JzeOIuOo
TyrvYLs9tznDDgFHmV0ST9tD+leh7fmdvhFHJlsTmKtdFoqwNxxXnUX/iJY2v7vKB3tvh2PX
0DJq1l1sDPGzbjniazEuOQAnFN44wOwZZoYS6J1yFhNkUsepNxz9gjDthBgd9K5c/3ATAOux
9TN6S9ZV+AWNS2mw9bMoNlwUxFFzTWsL8TQH2xc519woe2v1n/MuwU8XKhDzzMro6/1rqy6a
ny2CbgTUUgGTLT2G/H783+9CHaZr77kgxve9oKeV/afmiSTYzIw0bOIjL9kSGiG5VZFvC5F5
GQytQIgLcOJ60g7YaEi7ghM5EFjp2CoHxhLbWNvSO1UQRwUVZ2J+GGOmRj8JDlQyXr8NYnon
74Do29lLBlo3WiXQCBJ31G8JUJc9yB3D34xFMFbG02SrZvPAXpacw8Tvw3xrizp5f7NJzz3i
iZ+gMEuFuZyUJHmPfWupRWgPK9Dx2hzLabjKSWJtyNBjYt1gD1iqj6G8BaVmos8bdrKEZLFM
OVLAMLrwjEsCsLa3AgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFEe4zf/l
b+74suwvTg75JbCOPGvDMA4GA1UdDwEB/wQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAACAj
QTUEkMJAYmDv4jVM1z+s4jSQuKFvdvoWFqRINyzpkMLyPPgKn9iB5btb2iUspKdVcSQy9sgL
8rxq+JOssgfCX5/bzMiKqr5qb+FJEMwx14C7u8jYog5kV+qi9cKpMRXSIGrs/CIBKM+GuIAe
qcwRpTzyFrNHnfzSgCHEy9BHcEGhyoMZCCxt8l13nIoUE9Q2HJLw5QY33KbmkJs4j1xrG0aG
Q0JfPgEHU1RdZX33inOhmlRaHylDFCfChQ+1iHsaO5S3HWCntZznKWlXWpuTekMwGwPXYshA
pqr8ZORK15FTAaggiG6cX0S5y2CBNOxv033aSF/rtJC8LakcC6wc1aJoIIAE1vyxjy+7SjEN
SoYc6+I2KSb12tjE8nVhz36udmNKekBlk4f4HoCMhuWG1o8O/FMsYOgWYRqiPkN7zTlgVGr1
8okmAWiDSKIz6MkEkbIRNBE+6tBDGR8Dk5AM/1E9V/RBbuHLoL7ryWPNbczk+DaqaJ3tvV2X
cEQNtg413OEMXbugUZTLfhbrES+jkkXITHHZvMmZUldGL1DPvTVp9D0VzgalLA8+9oG6lLvD
u79leNKGef9JOxqDDPDeeOzI8k1MGt6CKfjBWtrt7uYnXuhF0J0cUahoq0Tj0Itq4/g7u9xN
12TyUb7mqqta6THuBrxzvxNiCp/HuZc=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUxKzApBgNV
BAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lz
dGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNz
IDMwHhcNMDgxMDAxMTAyOTU2WhcNMzMxMDAxMjM1OTU5WjCBgjELMAkGA1UEBhMCREUxKzAp
BgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQt
U3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENs
YXNzIDMwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC9dZPwYiJvJK7genasfb3Z
JNW4t/zN8ELg63iIVl6bmlQdTQyK9tPPcPRStdiTBONGhnFBSivwKixVA9ZIw+A5OO3yXDw/
RLyTPWGrTs0NvvAgJ1gORH8EGoel15YUNpDQSXuhdfsaa3Ox+M6pCSzyU9XDFES4hqX2iys5
2qMzVNn6chr3IhUciJFrf2blw2qAsCTz34ZFiP0Zf3WHHx+xGwpzJFu5ZeAsVMhg02YXP+HM
VDNzkQI6pn97djmiH5a2OK61yJN0HZ65tOVgnS9W0eDrXltMEnAMbEQgqxHY9Bn20pxSN+f6
tsIxO0rUFJmtxxr1XV/6B7h8DR/Wgx6zAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS1A/d2O2GCahKqGFPrAyGUv/7OyjANBgkqhkiG9w0B
AQsFAAOCAQEAVj3vlNW92nOyWL6ukK2YJ5f+AbGwUgC4TeQbIXQbfsDuXmkqJa9c1h3a0nnJ
85cp4IaH3gRZD/FZ1GSFS5mvJQQeyUapl96Cshtwn5z2r3Ex3XsFpSzTucpH9sry9uetuUg/
vBa3wW306gmv7PO15wWeph6KU1HWk4HMdJP2udqmJQV0eVp+QD6CSyYRMG7hP0HHRwA11fXT
91Q+gT3aSWqas+8QPebrb9HIIkfLzM8BMZLZGOMivgkeGj5asuRrDFR6fUNOuImle9eiPZaG
zPImNC1qkp2aGtAw4l1OBLBfiyB+d8E9lYLRRpo7PHi4b6HQDWSieB4pTpPDpFQUWw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEAzCCAuugAwIBAgIQVID5oHPtPwBMyonY43HmSjANBgkqhkiG9w0BAQUFADB1MQswCQYD
VQQGEwJFRTEiMCAGA1UECgwZQVMgU2VydGlmaXRzZWVyaW1pc2tlc2t1czEoMCYGA1UEAwwf
RUUgQ2VydGlmaWNhdGlvbiBDZW50cmUgUm9vdCBDQTEYMBYGCSqGSIb3DQEJARYJcGtpQHNr
LmVlMCIYDzIwMTAxMDMwMTAxMDMwWhgPMjAzMDEyMTcyMzU5NTlaMHUxCzAJBgNVBAYTAkVF
MSIwIAYDVQQKDBlBUyBTZXJ0aWZpdHNlZXJpbWlza2Vza3VzMSgwJgYDVQQDDB9FRSBDZXJ0
aWZpY2F0aW9uIENlbnRyZSBSb290IENBMRgwFgYJKoZIhvcNAQkBFglwa2lAc2suZWUwggEi
MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDIIMDs4MVLqwd4lfNE7vsLDP90jmG7sWLq
I9iroWUyeuuOF0+W2Ap7kaJjbMeMTC55v6kF/GlclY1i+blw7cNRfdCT5mzrMEvhvH2/UpvO
bntl8jixwKIy72KyaOBhU8E2lf/slLo2rpwcpzIP5Xy0xm90/XsY6KxX7QYgSzIwWFv9zajm
ofxwvI6Sc9uXp3whrj3B9UiHbCe9nyV0gVWw93X2PaRka9ZP585ArQ/dMtO8ihJTmMmJ+xAd
TX7Nfh9WDSFwhfYggx/2uh8Ej+p3iDXE/+pOoYtNP2MbRMNE1CV2yreN1x5KZmTNXMWcg+HC
CIia7E6j8T4cLNlsHaFLAgMBAAGjgYowgYcwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8E
BAMCAQYwHQYDVR0OBBYEFBLyWj7qVhy/zQas8fElyalL1BSZMEUGA1UdJQQ+MDwGCCsGAQUF
BwMCBggrBgEFBQcDAQYIKwYBBQUHAwMGCCsGAQUFBwMEBggrBgEFBQcDCAYIKwYBBQUHAwkw
DQYJKoZIhvcNAQEFBQADggEBAHv25MANqhlHt01Xo/6tu7Fq1Q+e2+RjxY6hUFaTlrg4wCQi
ZrxTFGGVv9DHKpY5P30osxBAIWrEr7BSdxjhlthWXePdNl4dp1BUoMUq5KqMlIpPnTX/dqQG
E5Gion0ARD9V04I8GtVbvFZMIi5GQ4okQC3zErg7cBqklrkar4dBGmoYDQZPxz5uuSlNDUmJ
EYcyW+ZLBMjkXOZ0c5RdFpgTlf7727FE5TpwrDdr5rMzcijJs1eg9gIWiAYLtqZLICjU3j2L
rTcFU3T+bsy8QxdxXvnFzBqpYe73dgzzcvRyrc9yAjYHR8/vGVCJYMzpJJUPwssd8m92kMfM
dcGWxZ0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEPTCCAyWgAwIBAgIBATANBgkqhkiG9w0BAQUFADCBvzE/MD0GA1UEAww2VMOcUktUUlVT
VCBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sxc8SxMQswCQYDVQQG
EwJUUjEPMA0GA1UEBwwGQW5rYXJhMV4wXAYDVQQKDFVUw5xSS1RSVVNUIEJpbGdpIMSwbGV0
acWfaW0gdmUgQmlsacWfaW0gR8O8dmVubGnEn2kgSGl6bWV0bGVyaSBBLsWeLiAoYykgQXJh
bMSxayAyMDA3MB4XDTA3MTIyNTE4MzcxOVoXDTE3MTIyMjE4MzcxOVowgb8xPzA9BgNVBAMM
NlTDnFJLVFJVU1QgRWxla3Ryb25payBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPE
sTELMAkGA1UEBhMCVFIxDzANBgNVBAcMBkFua2FyYTFeMFwGA1UECgxVVMOcUktUUlVTVCBC
aWxnaSDEsGxldGnFn2ltIHZlIEJpbGnFn2ltIEfDvHZlbmxpxJ9pIEhpem1ldGxlcmkgQS7F
ni4gKGMpIEFyYWzEsWsgMjAwNzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKu3
PgqMyKVYFeaK7yc9SrToJdPNM8Ig3BnuiD9NYvDdE3ePYakqtdTyuTFYKTsvP2qcb3N2Je40
IIDu6rfwxArNK4aUyeNgsURSsloptJGXg9i3phQvKUmi8wUG+7RP2qFsmmaf8EMJyupyj+sA
1zU511YXRxcw9L6/P8JorzZAwan0qafoEGsIiveGHtyaKhUG9qPw9ODHFNRRf8+0222vR5YX
m3dx2KdxnSQM9pQ/hTEST7ruToK4uT6PIzdezKKqdfcYbwnTrqdUKDT74eA7YH2gvnmJhsif
LfkKS8RQouf9eRbHegsYz85M733WB2+Y8a+xwXrXgTW4qhe04MsCAwEAAaNCMEAwHQYDVR0O
BBYEFCnFkKslrxHkYb+j/4hhkeYO/pyBMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTAD
AQH/MA0GCSqGSIb3DQEBBQUAA4IBAQAQDdr4Ouwo0RSVgrESLFF6QSU2TJ/sPx+EnWVUXKgW
AkD6bho3hO9ynYYKVZ1WKKxmLNA6VpM0ByWtCLCPyA8JWcqdmBzlVPi5RX9ql2+IaE1KBiY3
iAIOtsbWcpnOa3faYjGkVh+uX4132l32iPwa2Z61gfAyuOOI0JzzaqC5mxRZNTZPz/OOXl0X
rRWV2N2y1RVuAE6zS89mlOTgzbUF2mNXi+WzqtvALhyQRNsaXRik7r4EW5nVcV9VZWRi1aKb
BFmGyGJ353yCRWo9F7/snXUMrqNvWtMvmDb08PUZqxFdyKbjKlhqQgnDvZImZjINXQhVdP+M
mNAKpoRq0Tl9
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEMzCCAxugAwIBAgIDCYPzMA0GCSqGSIb3DQEBCwUAME0xCzAJBgNVBAYTAkRFMRUwEwYD
VQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMMHkQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIg
MjAwOTAeFw0wOTExMDUwODM1NThaFw0yOTExMDUwODM1NThaME0xCzAJBgNVBAYTAkRFMRUw
EwYDVQQKDAxELVRydXN0IEdtYkgxJzAlBgNVBAMMHkQtVFJVU1QgUm9vdCBDbGFzcyAzIENB
IDIgMjAwOTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANOySs96R+91myP6Oi/W
UEWJNTrGa9v+2wBoqOADER03UAifTUpolDWzU9GUY6cgVq/eUXjsKj3zSEhQPgrfRlWLJ23D
EE0NkVJD2IfgXU42tSHKXzlABF9bfsyjxiupQB7ZNoTWSPOSHjRGICTBpFGOShrvUD9pXRl/
RcPHAY9RySPocq60vFYJfxLLHLGvKZAKyVXMD9O0Gu1HNVpK7ZxzBCHQqr0ME7UAyiZsxGsM
lFqVlNpQmvH/pStmMaTJOKDfHR+4CS7zp+hnUquVH+BGPtikw8paxTGA6Eian5Rp/hnd2HN8
gcqW3o7tszIFZYQ05ub9VxC1X3a/L7AQDcUCAwEAAaOCARowggEWMA8GA1UdEwEB/wQFMAMB
Af8wHQYDVR0OBBYEFP3aFMSfMN4hvR5COfyrYyNJ4PGEMA4GA1UdDwEB/wQEAwIBBjCB0wYD
VR0fBIHLMIHIMIGAoH6gfIZ6bGRhcDovL2RpcmVjdG9yeS5kLXRydXN0Lm5ldC9DTj1ELVRS
VVNUJTIwUm9vdCUyMENsYXNzJTIwMyUyMENBJTIwMiUyMDIwMDksTz1ELVRydXN0JTIwR21i
SCxDPURFP2NlcnRpZmljYXRlcmV2b2NhdGlvbmxpc3QwQ6BBoD+GPWh0dHA6Ly93d3cuZC10
cnVzdC5uZXQvY3JsL2QtdHJ1c3Rfcm9vdF9jbGFzc18zX2NhXzJfMjAwOS5jcmwwDQYJKoZI
hvcNAQELBQADggEBAH+X2zDI36ScfSF6gHDOFBJpiBSVYEQBrLLpME+bUMJm2H6NMLVwMeni
acfzcNsgFYbQDfC+rAF1hM5+n02/t2A7nPPKHeJeaNijnZflQGDSNiH+0LS4F9p0o3/U37CY
Aqxva2ssJSRyoWXuJVrl5jLn8t+rSfrzkGkj2wTZ51xY/GXUl77M/C4KzCUqNQT4YJEVdT1B
/yMfGchs64JTBKbkTCJNjYy6zltz7GRUUG3RnFX7acM2w4y8PIWmawomDeCTmGCufsYkl4ph
X5GOZpIJhzbNi5stPvZR1FDUWSi9g/LMKHtThm3YJohw1+qRzT65ysCQblrGXnRl11z+o+I=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEQzCCAyugAwIBAgIDCYP0MA0GCSqGSIb3DQEBCwUAMFAxCzAJBgNVBAYTAkRFMRUwEwYD
VQQKDAxELVRydXN0IEdtYkgxKjAoBgNVBAMMIUQtVFJVU1QgUm9vdCBDbGFzcyAzIENBIDIg
RVYgMjAwOTAeFw0wOTExMDUwODUwNDZaFw0yOTExMDUwODUwNDZaMFAxCzAJBgNVBAYTAkRF
MRUwEwYDVQQKDAxELVRydXN0IEdtYkgxKjAoBgNVBAMMIUQtVFJVU1QgUm9vdCBDbGFzcyAz
IENBIDIgRVYgMjAwOTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJnxhDRwui+3
MKCOvXwEz75ivJn9gpfSegpnljgJ9hBOlSJzmY3aFS3nBfwZcyK3jpgAvDw9rKFs+9Z5JUut
8Mxk2og+KbgPCdM03TP1YtHhzRnp7hhPTFiu4h7WDFsVWtg6uMQYZB7jM7K1iXdODL/ZlGsT
l28So/6ZqQTMFexgaDbtCHu39b+T7WYxg4zGcTSHThfqr4uRjRxWQa4iN1438h3Z0S0NL2lR
p75mpoo6Kr3HGrHhFPC+Oh25z1uxav60sUYgovseO3Dvk5h9jHOW8sXvhXCtKSb8HgQ+HKDY
D8tSg2J87otTlZCpV6LqYQXY+U3EJ/pure3511H3a6UCAwEAAaOCASQwggEgMA8GA1UdEwEB
/wQFMAMBAf8wHQYDVR0OBBYEFNOUikxiEyoZLsyvcop9NteaHNxnMA4GA1UdDwEB/wQEAwIB
BjCB3QYDVR0fBIHVMIHSMIGHoIGEoIGBhn9sZGFwOi8vZGlyZWN0b3J5LmQtdHJ1c3QubmV0
L0NOPUQtVFJVU1QlMjBSb290JTIwQ2xhc3MlMjAzJTIwQ0ElMjAyJTIwRVYlMjAyMDA5LE89
RC1UcnVzdCUyMEdtYkgsQz1ERT9jZXJ0aWZpY2F0ZXJldm9jYXRpb25saXN0MEagRKBChkBo
dHRwOi8vd3d3LmQtdHJ1c3QubmV0L2NybC9kLXRydXN0X3Jvb3RfY2xhc3NfM19jYV8yX2V2
XzIwMDkuY3JsMA0GCSqGSIb3DQEBCwUAA4IBAQA07XtaPKSUiO8aEXUHL7P+PPoeUSbrh/Yp
3uDx1MYkCenBz1UbtDDZzhr+BlGmFaQt77JLvyAoJUnRpjZ3NOhk31KxEcdzes05nsKtjHEh
8lprr988TlWvsoRlFIm5d8sqMb7Po23Pb0iUMkZv53GMoKaEGTcH8gNFCSuGdXzfX2lXANtu
2KZyIktQ1HWYVt+3GP9DQ1CuekR78HlR10M9p9OB0/DJT7naxpeG0ILD5EJt/rDiZE4OJudA
NCa1CInXCGNjOCd1HjPqbqjdn5lPdE2BiYBL3ZqXKVwvvoFBuYz/6n1gBp7N1z3TLqMVvKjm
JuVvw9y4AyHqnxbxLFS1
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIJhjCCB26gAwIBAgIBCzANBgkqhkiG9w0BAQsFADCCAR4xPjA8BgNVBAMTNUF1dG9yaWRh
ZCBkZSBDZXJ0aWZpY2FjaW9uIFJhaXogZGVsIEVzdGFkbyBWZW5lem9sYW5vMQswCQYDVQQG
EwJWRTEQMA4GA1UEBxMHQ2FyYWNhczEZMBcGA1UECBMQRGlzdHJpdG8gQ2FwaXRhbDE2MDQG
A1UEChMtU2lzdGVtYSBOYWNpb25hbCBkZSBDZXJ0aWZpY2FjaW9uIEVsZWN0cm9uaWNhMUMw
QQYDVQQLEzpTdXBlcmludGVuZGVuY2lhIGRlIFNlcnZpY2lvcyBkZSBDZXJ0aWZpY2FjaW9u
IEVsZWN0cm9uaWNhMSUwIwYJKoZIhvcNAQkBFhZhY3JhaXpAc3VzY2VydGUuZ29iLnZlMB4X
DTEwMTIyODE2NTEwMFoXDTIwMTIyNTIzNTk1OVowgdExJjAkBgkqhkiG9w0BCQEWF2NvbnRh
Y3RvQHByb2NlcnQubmV0LnZlMQ8wDQYDVQQHEwZDaGFjYW8xEDAOBgNVBAgTB01pcmFuZGEx
KjAoBgNVBAsTIVByb3ZlZWRvciBkZSBDZXJ0aWZpY2Fkb3MgUFJPQ0VSVDE2MDQGA1UEChMt
U2lzdGVtYSBOYWNpb25hbCBkZSBDZXJ0aWZpY2FjaW9uIEVsZWN0cm9uaWNhMQswCQYDVQQG
EwJWRTETMBEGA1UEAxMKUFNDUHJvY2VydDCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoC
ggIBANW39KOUM6FGqVVhSQ2oh3NekS1wwQYalNo97BVCwfWMrmoX8Yqt/ICV6oNEolt6Vc5P
p6XVurgfoCfAUFM+jbnADrgV3NZs+J74BCXfgI8Qhd19L3uA3VcAZCP4bsm+lU/hdezgfl6V
zbHvvnpC2Mks0+saGiKLt38GieU89RLAu9MLmV+QfI4tL3czkkohRqipCKzx9hEC2ZUWno0v
luYC3XXCFCpa1sl9JcLB/KpnheLsvtF8PPqv1W7/U0HU9TI4seJfxPmOEO8GqQKJ/+MMbpfg
353bIdD0PghpbNjU5Db4g7ayNo+c7zo3Fn2/omnXO1ty0K+qP1xmk6wKImG20qCZyFSTXai2
0b1dCl53lKItwIKOvMoDKjSuc/HUtQy9vmebVOvh+qBa7Dh+PsHMosdEMXXqP+UH0quhJZb2
5uSgXTcYOWEAM11G1ADEtMo88aKjPvM6/2kwLkDd9p+cJsmWN63nOaK/6mnbVSKVUyqUtd+t
FjiBdWbjxywbk5yqjKPK2Ww8F22c3HxT4CAnQzb5EuE8XL1mv6JpIzi4mWCZDlZTOpx+FIyw
Bm/xhnaQr/2v/pDGj59/i5IjnOcVdo/Vi5QTcmn7K2FjiO/mpF7moxdqWEfLcU8UC17IAggm
osvpr2uKGcfLFFb14dq12fy/czja+eevbqQ34gcnAgMBAAGjggMXMIIDEzASBgNVHRMBAf8E
CDAGAQH/AgEBMDcGA1UdEgQwMC6CD3N1c2NlcnRlLmdvYi52ZaAbBgVghl4CAqASDBBSSUYt
Ry0yMDAwNDAzNi0wMB0GA1UdDgQWBBRBDxk4qpl/Qguk1yeYVKIXTC1RVDCCAVAGA1UdIwSC
AUcwggFDgBStuyIdxuDSAaj9dlBSk+2YwU2u06GCASakggEiMIIBHjE+MDwGA1UEAxM1QXV0
b3JpZGFkIGRlIENlcnRpZmljYWNpb24gUmFpeiBkZWwgRXN0YWRvIFZlbmV6b2xhbm8xCzAJ
BgNVBAYTAlZFMRAwDgYDVQQHEwdDYXJhY2FzMRkwFwYDVQQIExBEaXN0cml0byBDYXBpdGFs
MTYwNAYDVQQKEy1TaXN0ZW1hIE5hY2lvbmFsIGRlIENlcnRpZmljYWNpb24gRWxlY3Ryb25p
Y2ExQzBBBgNVBAsTOlN1cGVyaW50ZW5kZW5jaWEgZGUgU2VydmljaW9zIGRlIENlcnRpZmlj
YWNpb24gRWxlY3Ryb25pY2ExJTAjBgkqhkiG9w0BCQEWFmFjcmFpekBzdXNjZXJ0ZS5nb2Iu
dmWCAQowDgYDVR0PAQH/BAQDAgEGME0GA1UdEQRGMESCDnByb2NlcnQubmV0LnZloBUGBWCG
XgIBoAwMClBTQy0wMDAwMDKgGwYFYIZeAgKgEgwQUklGLUotMzE2MzUzNzMtNzB2BgNVHR8E
bzBtMEagRKBChkBodHRwOi8vd3d3LnN1c2NlcnRlLmdvYi52ZS9sY3IvQ0VSVElGSUNBRE8t
UkFJWi1TSEEzODRDUkxERVIuY3JsMCOgIaAfhh1sZGFwOi8vYWNyYWl6LnN1c2NlcnRlLmdv
Yi52ZTA3BggrBgEFBQcBAQQrMCkwJwYIKwYBBQUHMAGGG2h0dHA6Ly9vY3NwLnN1c2NlcnRl
LmdvYi52ZTBBBgNVHSAEOjA4MDYGBmCGXgMBAjAsMCoGCCsGAQUFBwIBFh5odHRwOi8vd3d3
LnN1c2NlcnRlLmdvYi52ZS9kcGMwDQYJKoZIhvcNAQELBQADggIBACtZ6yKZu4SqT96QxtGG
cSOeSwORR3C7wJJg7ODU523G0+1ng3dS1fLld6c2suNUvtm7CpsR72H0xpkzmfWvADmNg7+m
vTV+LFwxNG9s2/NkAZiqlCxB3RWGymspThbASfzXg0gTB1GEMVKIu4YXx2sviiCtxQuPcD4q
uxtxj7mkoP3YldmvWb8lK5jpY5MvYB7Eqvh39YtsL+1+LrVPQA3uvFd359m21D+VJzog1eWu
q2w1n8GhHVnchIHuTQfiSLaeS5UtQbHh6N5+LwUeaO6/u5BlOsju6rEYNxxik6SgMexxbJHm
pHmJWhSnFFAFTKQAVzAswbVhltw+HoSvOULP5dAssSS830DD7X9jSr3hTxJkhpXzsOfIt+FT
vZLm8wyWuevo5pLtp4EJFAv8lXrPj9Y0TzYS3F7RNHXGRoAvlQSMx4bEqCaJqD8Zm4G7UaRK
hqsLEQ+xrmNTbSjq3TNWOByyrYDT13K9mmyZY+gAu0F2BbdbmRiKw7gSXFbPVgx96OLP7bx0
R/vu0xdOIk9W/1DzLuY5poLWccret9W6aAjtmcz9opLLabid+Qqkpj5PkygqYWwHJgD/ll9o
hri4zspV4KuxPX+Y1zMOWj3YeMLEYC/HYvBhkdI4sPaeVdtAgAUSM84dkpvRabP/v/GSCmE1
P93+hvS84Bpxs2Km
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIID9zCCAt+gAwIBAgIESJ8AATANBgkqhkiG9w0BAQUFADCBijELMAkGA1UEBhMCQ04xMjAw
BgNVBAoMKUNoaW5hIEludGVybmV0IE5ldHdvcmsgSW5mb3JtYXRpb24gQ2VudGVyMUcwRQYD
VQQDDD5DaGluYSBJbnRlcm5ldCBOZXR3b3JrIEluZm9ybWF0aW9uIENlbnRlciBFViBDZXJ0
aWZpY2F0ZXMgUm9vdDAeFw0xMDA4MzEwNzExMjVaFw0zMDA4MzEwNzExMjVaMIGKMQswCQYD
VQQGEwJDTjEyMDAGA1UECgwpQ2hpbmEgSW50ZXJuZXQgTmV0d29yayBJbmZvcm1hdGlvbiBD
ZW50ZXIxRzBFBgNVBAMMPkNoaW5hIEludGVybmV0IE5ldHdvcmsgSW5mb3JtYXRpb24gQ2Vu
dGVyIEVWIENlcnRpZmljYXRlcyBSb290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
AQEAm35z7r07eKpkQ0H1UN+U8i6yjUqORlTSIRLIOTJCBumD1Z9S7eVnAztUwYyZmczpwA//
DdmEEbK40ctb3B75aDFk4Zv6dOtouSCV98YPjUesWgbdYavi7NifFy2cyjw1l1VxzUOFsUcW
9SxTgHbP0wBkvUCZ3czY28Sf1hNfQYOL+Q2HklY0bBoQCxfVWhyXWIQ8hBouXJE0bhlffxdp
xWXvayHG1VA6v2G5BY3vbzQ6sm8UY78WO5upKv23KzhmBsUs4qpnHkWnjQRmQvaPK++IIGmP
MowUc9orhpFjIpryp9vOiYurXccUwVswah+xt54ugQEC7c+WXmPbqOY4twIDAQABo2MwYTAf
BgNVHSMEGDAWgBR8cks5x8DbYqVPm6oYNJKiyoOCWTAPBgNVHRMBAf8EBTADAQH/MA4GA1Ud
DwEB/wQEAwIBBjAdBgNVHQ4EFgQUfHJLOcfA22KlT5uqGDSSosqDglkwDQYJKoZIhvcNAQEF
BQADggEBACrDx0M3j92tpLIM7twUbY8opJhJywyA6vPtI2Z1fcXTIWd50XPFtQO3WKwMVC/G
VhMPMdoG52U7HW8228gd+f2ABsqjPWYWqJ1MFn3AlUa1UeTiH9fqBk1jjZaM7+czV0I664zB
echNdn3e9rG3geCg+aF4RhcaVpjwTj2rHO3sOdwHSPdj/gauwqRcalsyiMXHM4WsZkJHwlgk
meHlPuV1LI5D1l08eB6olYIpUNHRFrrvwb562bTYzB5MRuF3sTGrvSrIzo9uoV1/A3U05K2J
RVRevq4opbs/eHnrc7MKDf2+yfdWrPa37S+bISnHOLaVxATywy39FCqQmbkHzJ8=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF2TCCA8GgAwIBAgIQHp4o6Ejy5e/DfEoeWhhntjANBgkqhkiG9w0BAQsFADBkMQswCQYD
VQQGEwJjaDERMA8GA1UEChMIU3dpc3Njb20xJTAjBgNVBAsTHERpZ2l0YWwgQ2VydGlmaWNh
dGUgU2VydmljZXMxGzAZBgNVBAMTElN3aXNzY29tIFJvb3QgQ0EgMjAeFw0xMTA2MjQwODM4
MTRaFw0zMTA2MjUwNzM4MTRaMGQxCzAJBgNVBAYTAmNoMREwDwYDVQQKEwhTd2lzc2NvbTEl
MCMGA1UECxMcRGlnaXRhbCBDZXJ0aWZpY2F0ZSBTZXJ2aWNlczEbMBkGA1UEAxMSU3dpc3Nj
b20gUm9vdCBDQSAyMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlUJOhJ1R5tMJ
6HJaI2nbeHCOFvErjw0DzpPMLgAIe6szjPTpQOYXTKueuEcUMncy3SgM3hhLX3af+Dk7/E6J
2HzFZ++r0rk0X2s682Q2zsKwzxNoysjL67XiPS4h3+os1OD5cJZM/2pYmLcX5BtS5X4HAB1f
2uY+lQS3aYg5oUFgJWFLlTloYhyxCwWJwDaCFCE/rtuh/bxvHGCGtlOUSbkrRsVPACu/obvL
P+DHVxxX6NZp+MEkUp2IVd3Chy50I9AU/SpHWrumnf2U5NGKpV+GY3aFy6//SSj8gO1MedK7
5MDvAe5QQQg1I3ArqRa0jG6F6bYRzzHdUyYb3y1aSgJA/MTAtukxGggo5WDDH8SQjhBiYEQN
7Aq+VRhxLKX0srwVYv8c474d2h5Xszx+zYIdkeNL6yxSNLCK/RJOlrDrcH+eOfdmQrGrrFLa
dkBXeyq96G4DsguAhYidDMfCd7Camlf0uPoTXGiTOmekl9AbmbeGMktg2M7v0Ax/lZ9vh0+H
io5fCHyqW/xavqGRn1V9TrALacywlKinh/LTSlDcX3KwFnUey7QYYpqwpzmqm59m2I2mbJYV
4+by+PGDYmy7Velhk6M99bFXi08jsJvllGov34zflVEpYKELKeRcVVi3qPyZ7iVNTA6z00yP
hOgpD/0QVAKFyPnlw4vP5w8CAwEAAaOBhjCBgzAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0hBBYw
FDASBgdghXQBUwIBBgdghXQBUwIBMBIGA1UdEwEB/wQIMAYBAf8CAQcwHQYDVR0OBBYEFE0m
ICKJS9PVpAqhb97iEoHF8TwuMB8GA1UdIwQYMBaAFE0mICKJS9PVpAqhb97iEoHF8TwuMA0G
CSqGSIb3DQEBCwUAA4ICAQAyCrKkG8t9voJXiblqf/P0wS4RfbgZPnm3qKhyN2abGu2sEzsO
v2LwnN+ee6FTSA5BesogpxcbtnjsQJHzQq0Qw1zv/2BZf82Fo4s9SBwlAjxnffUy6S8w5X2l
ejjQ82YqZh6NM4OKb3xuqFp1mrjX2lhIREeoTPpMSQpKwhI3qEAMw8jh0FcNlzKVxzqfl9NX
+Ave5XLzo9v/tdhZsnPdTSpxsrpJ9csc1fV5yJmz/MFMdOO0vSk3FQQoHt5FRnDsr7p4Dooq
zgB53MBfGWcsa0vvaGgLQ+OswWIJ76bdZWGgr4RVSJFSHMYlkSrQwSIjYVmvRRGFHQEkNI/P
s/8XciATwoCqISxxOQ7Qj1zB09GOInJGTB2Wrk9xseEFKZZZ9LuedT3PDTcNYtsmjGOpI99n
Bjx8Oto0QuFmtEYE3saWmA9LSHokMnWRn6z3aOkquVVlzl1h0ydw2Df+n7mvoC5Wt6NlUe07
qxS/TFED6F+KBZvuim6c779o+sjaC+NCydAXFJy3SuCvkychVSa1ZC+N8f+mQAWFBVzKBxlc
CxMoTFh/wqXvRdpg065lYZ1Tg3TCrvJcwhbtkj6EPnNgiLx29CzP0H1907he0ZESEOnN3col
49XtmS++dYFLJPlFRpTJKSFTnCZFqhMX5OfNeOI5wSsSnqaeG8XmDtkx2Q==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF4DCCA8igAwIBAgIRAPL6ZOJ0Y9ON/RAdBB92ylgwDQYJKoZIhvcNAQELBQAwZzELMAkG
A1UEBhMCY2gxETAPBgNVBAoTCFN3aXNzY29tMSUwIwYDVQQLExxEaWdpdGFsIENlcnRpZmlj
YXRlIFNlcnZpY2VzMR4wHAYDVQQDExVTd2lzc2NvbSBSb290IEVWIENBIDIwHhcNMTEwNjI0
MDk0NTA4WhcNMzEwNjI1MDg0NTA4WjBnMQswCQYDVQQGEwJjaDERMA8GA1UEChMIU3dpc3Nj
b20xJTAjBgNVBAsTHERpZ2l0YWwgQ2VydGlmaWNhdGUgU2VydmljZXMxHjAcBgNVBAMTFVN3
aXNzY29tIFJvb3QgRVYgQ0EgMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMT3
HS9X6lds93BdY7BxUglgRCgzo3pOCvrY6myLURYaVa5UJsTMRQdBTxB5f3HSek4/OE6zAMaV
ylvNwSqD1ycfMQ4jFrclyxy0uYAyXhqdk/HoPGAsp15XGVhRXrwsVgu42O+LgrQ8uMIkqBPH
oCE2G3pXKSinLr9xJZDzRINpUKTk4RtiGZQJo/PDvO/0vezbE53PnUgJUmfANykRHvvSEaeF
GHR55E+FFOtSN+KxRdjMDUN/rhPSays/p8LiqG12W0OfvrSdsyaGOx9/5fLoZigWJdBLlzin
5M8J0TbDC77aO0RYjb7xnglrPvMyxyuHxuxenPaHZa0zKcQvidm5y8kDnftslFGXEBuGCxob
P/YCfnvUxVFkKJ3106yDgYjTdLRZncHrYTNaRdHLOdAGalNgHa/2+2m8atwBz735j9m9W8E6
X47aD0upm50qKGsaCnw8qyIL5XctcfaCNYGu+HuB5ur+rPQam3Rc6I8k9l2dRsQs0h4rIWqD
J2dVSqTjyDKXZpBy2uPUZC5f46Fq9mDU5zXNysRojddxyNMkM3OxbPlq4SjbX8Y96L5V5jcb
7STZDxmPX2MYWFCBUWVv8p9+agTnNCRxunZLWB4ZvRVgRaoMEkABnRDixzgHcgplwLa7JSna
Fp6LNYth7eVxV4O1PHGf40+/fh6Bn0GXAgMBAAGjgYYwgYMwDgYDVR0PAQH/BAQDAgGGMB0G
A1UdIQQWMBQwEgYHYIV0AVMCAgYHYIV0AVMCAjASBgNVHRMBAf8ECDAGAQH/AgEDMB0GA1Ud
DgQWBBRF2aWBbj2ITY1x0kbBbkUe88SAnTAfBgNVHSMEGDAWgBRF2aWBbj2ITY1x0kbBbkUe
88SAnTANBgkqhkiG9w0BAQsFAAOCAgEAlDpzBp9SSzBc1P6xXCX5145v9Ydkn+0UjrgEjihL
j6p7jjm02Vj2e6E1CqGdivdj5eu9OYLU43otb98TPLr+flaYC/NUn81ETm484T4VvwYmneTw
kLbUwp4wLh/vx3rEUMfqe9pQy3omywC0Wqu1kx+AiYQElY2NfwmTv9SoqORjbdlk5LgpWgi/
UOGED1V7XwgiG/W9mR4U9s70WBCCswo9GcG/W6uqmdjyMb3lOGbcWAXH7WMaLgqXfIeTK7KK
4/HsGOV1timH59yLGn602MnTihdsfSlEvoqq9X46Lmgxk7lq2prg2+kupYTNHAq4Sgj5nPFh
JpiTt3tm7JFe3VE/23MPrQRYCd0EApUKPtN236YQHoA96M2kZNEzx5LH4k5E4wnJTsJdhw4S
nr8PyQUQ3nqjsTzyP6WqJ3mtMX0f/fwZacXduT98zca0wjAefm6S139hdlqP65VNvBFuIXxZ
N5nQBrz5Bm0yFqXZaajh3DyAHmBR3NdUIR7KYndP+tiPsys6DXhyyWhBWkdKwqPrGtcKqzwy
VcgKEZzfdNbwQBUdyLmPtTbFr/giuMod89a2GQ+fYWVq6nTIfI/DT11lgh/ZDYnadXL77/FH
ZxOzyNEZiCcmmpl5fx7kLD977vHeTYuWl8PVP3wbI+2ksx0WckNLIOFZfsLorSa/ovc=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFaTCCA1GgAwIBAgIJAMMDmu5QkG4oMA0GCSqGSIb3DQEBBQUAMFIxCzAJBgNVBAYTAlNL
MRMwEQYDVQQHEwpCcmF0aXNsYXZhMRMwEQYDVQQKEwpEaXNpZyBhLnMuMRkwFwYDVQQDExBD
QSBEaXNpZyBSb290IFIxMB4XDTEyMDcxOTA5MDY1NloXDTQyMDcxOTA5MDY1NlowUjELMAkG
A1UEBhMCU0sxEzARBgNVBAcTCkJyYXRpc2xhdmExEzARBgNVBAoTCkRpc2lnIGEucy4xGTAX
BgNVBAMTEENBIERpc2lnIFJvb3QgUjEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC
AQCqw3j33Jijp1pedxiy3QRkD2P9m5YJgNXoqqXinCaUOuiZc4yd39ffg/N4T0Dhf9Kn0uXK
E5Pn7cZ3Xza1lK/oOI7bm+V8u8yN63Vz4STN5qctGS7Y1oprFOsIYgrY3LMATcMjfF9DCCMy
EtztDK3AfQ+lekLZWnDZv6fXARz2m6uOt0qGeKAeVjGu74IKgEH3G8muqzIm1Cxr7X1r5OJe
IgpFy4QxTaz+29FHuvlglzmxZcfe+5nkCiKxLU3lSCZpq+Kq8/v8kiky6bM+TR8noc2OuRf7
JT7JbvN32g0S9l3HuzYQ1VTW8+DiR0jm3hTaYVKvJrT1cU/J19IG32PK/yHoWQbgCNWEFVP3
Q+V8xaCJmGtzxmjOZd69fwX3se72V6FglcXM6pM6vpmumwKjrckWtc7dXpl4fho5frLABaTA
gqWjR56M6ly2vGfb5ipN0gTco65F97yLnByn1tUD3AjLLhbKXEAz6GfDLuemROoRRRw1ZS0e
RWEkG4IupZ0zXWX4Qfkuy5Q/H6MMMSRE7cderVC6xkGbrPAXZcD4XW9boAo0PO7X6oifmPmv
TiT6l7Jkdtqr9O3jw2Dv1fkCyC2fg69naQanMVXVz0tv/wQFx1isXxYb5dKj6zHbHzMVTdDy
pVP1y+E9Tmgt2BLdqvLmTZtJ5cUoobqwWsagtQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/
MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUiQq0OJMa5qvum5EY+fU8PjXQ04IwDQYJKoZI
hvcNAQEFBQADggIBADKL9p1Kyb4U5YysOMo6CdQbzoaz3evUuii+Eq5FLAR0rBNRxVgYZk2C
2tXck8An4b58n1KeElb21Zyp9HWc+jcSjxyT7Ff+Bw+r1RL3D65hXlaASfX8MPWbTx9BLxyE
04nH4toCdu0Jz2zBuByDHBb6lM19oMgY0sidbvW9adRtPTXoHqJPYNcHKfyyo6SdbhWSVhlM
CrDpfNIZTUJG7L399ldb3Zh+pE3McgODWF3vkzpBemOqfDqo9ayk0d2iLbYq/J8BjuIQscTK
5GfbVSUZP/3oNn6z4eGBrxEWi1CXYBmCAMBrTXO40RMHPuq2MU/wQppt4hF05ZSsjYSVPCGv
xdpHyN85YmLLW1AL14FABZyb7bq2ix4Eb5YgOe2kfSnbSM6C3NQCjR0EMVrHS/BsYVLXtFHC
gWzN4funodKSds+xDzdYpPJScWc/DIh4gInByLUfkmO+p3qKViwaqKactV2zY9ATIKHrkWzQ
jX2v3wvkF7mGnjixlAxYjOBVqjtjbZqJYLhkKpLGN/R+Q0O3c+gB53+XD9fyexn9GtePyfqF
a3qdnom2piiZk4hA9z7NUaPK6u95RyG1/jLix8NRb76AdPCkwzryT+lf3xkK8jsTQ6wxpLPn
6/wY1gGp8yqPNg7rtLG8t0zJa7+h89n07eLw4+1knj0vllJPgFOL
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFaTCCA1GgAwIBAgIJAJK4iNuwisFjMA0GCSqGSIb3DQEBCwUAMFIxCzAJBgNVBAYTAlNL
MRMwEQYDVQQHEwpCcmF0aXNsYXZhMRMwEQYDVQQKEwpEaXNpZyBhLnMuMRkwFwYDVQQDExBD
QSBEaXNpZyBSb290IFIyMB4XDTEyMDcxOTA5MTUzMFoXDTQyMDcxOTA5MTUzMFowUjELMAkG
A1UEBhMCU0sxEzARBgNVBAcTCkJyYXRpc2xhdmExEzARBgNVBAoTCkRpc2lnIGEucy4xGTAX
BgNVBAMTEENBIERpc2lnIFJvb3QgUjIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoIC
AQCio8QACdaFXS1tFPbCw3OeNcJxVX6B+6tGUODBfEl45qt5WDza/3wcn9iXAng+a0EE6UG9
vgMsRfYvZNSrXaNHPWSb6WiaxswbP7q+sos0Ai6YVRn8jG+qX9pMzk0DIaPY0jSTVpbLTAwA
FjxfGs3Ix2ymrdMxp7zo5eFm1tL7A7RBZckQrg4FY8aAamkw/dLukO8NJ9+flXP04SXabBbe
QTg06ov80egEFGEtQX6sx3dOy1FU+16SGBsEWmjGycT6txOgmLcRK7fWV8x8nhfRyyX+hk4k
LlYMeE2eARKmK6cBZW58Yh2EhN/qwGu1pSqVg8NTEQxzHQuyRpDRQjrOQG6Vrf/GlK1ul4SO
fW+eioANSW1z4nuSHsPzwfPrLgVv2RvPN3YEyLRa5Beny912H9AZdugsBbPWnDTYltxhh5EF
5EQIM8HauQhl1K6yNg3ruji6DOWbnuuNZt2Zz9aJQfYEkoopKW1rOhzndX0CcQ7zwOe9yxnd
nWCywmZgtrEE7snmhrmaZkCo5xHtgUUDi/ZnWejBBhG93c+AAk9lQHhcR1DIm+YfgXvkRKhb
hZri3lrVx/k6RGZL5DJUfORsnLMOPReisjQS1n6yqEm70XooQL6iFh/f5DcfEXP7kAplQ6IN
fPgGAVUzfbANuPT1rqVCV3w2EYx7XsQDnYx5nQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/
MA4GA1UdDwEB/wQEAwIBBjAdBgNVHQ4EFgQUtZn4r7CU9eMg1gqtzk5WpC5uQu0wDQYJKoZI
hvcNAQELBQADggIBACYGXnDnZTPIgm7ZnBc6G3pmsgH2eDtpXi/q/075KMOYKmFMtCQSin1t
ERT3nLXK5ryeJ45MGcipvXrA1zYObYVybqjGom32+nNjf7xueQgcnYqfGopTpti72TVVsRHF
qQOzVju5hJMiXn7B9hJSi+osZ7z+Nkz1uM/Rs0mSO9MpDpkblvdhuDvEK7Z4bLQjb/D907Je
dR+Zlais9trhxTF7+9FGs9K8Z7RiVLoJ92Owk6Ka+elSLotgEqv89WBW7xBci8QaQtyDW2QO
y7W81k/BfDxujRNt+3vrMNDcTa/F1balTFtxyegxvug4BkihGuLq0t4SOVga/4AOgnXmt8kH
bA7v/zjxmHHEt38OFdAlab0inSvtBfZGR6ztwPDUO+Ls7pZbkBNOHlY667DvlruWIxG68kOG
dGSVyCh13x01utI3gzhTODY7z2zp+WsO0PsE6E9312UBeIYMej4hYvF/Y3EMyZ9E26gnonW+
boE+18DrG5gPcFw0sorMwIUY6256s/daoQe/qUKS82Ail+QUoQebTnbAjn39pCXHR+3/H3Os
zMOl6W8KjptlwlCFtaOgUxLMVYdh84GuEEZhvUQhuMI9dM9+JDX6HAcOmz0iyu8xL4ysEr3v
QCj8KWefshNPZiTEUxnpHikV7+ZtsH8tZ/3zbBt1RqPlShfppNcL
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIH0zCCBbugAwIBAgIIXsO3pkN/pOAwDQYJKoZIhvcNAQEFBQAwQjESMBAGA1UEAwwJQUND
VlJBSVoxMRAwDgYDVQQLDAdQS0lBQ0NWMQ0wCwYDVQQKDARBQ0NWMQswCQYDVQQGEwJFUzAe
Fw0xMTA1MDUwOTM3MzdaFw0zMDEyMzEwOTM3MzdaMEIxEjAQBgNVBAMMCUFDQ1ZSQUlaMTEQ
MA4GA1UECwwHUEtJQUNDVjENMAsGA1UECgwEQUNDVjELMAkGA1UEBhMCRVMwggIiMA0GCSqG
SIb3DQEBAQUAA4ICDwAwggIKAoICAQCbqau/YUqXry+XZpp0X9DZlv3P4uRm7x8fRzPCRKPf
mt4ftVTdFXxpNRFvu8gMjmoYHtiP2Ra8EEg2XPBjs5BaXCQ316PWywlxufEBcoSwfdtNgM38
02/J+Nq2DoLSRYWoG2ioPej0RGy9ocLLA76MPhMAhN9KSMDjIgro6TenGEyxCQ0jVn8ETdkX
hBilyNpAlHPrzg5XPAOBOp0KoVdDaaxXbXmQeOW1tDvYvEyNKKGno6e6Ak4l0Squ7a4DIrhr
IA8wKFSVf+DuzgpmndFALW4ir50awQUZ0m/A8p/4e7MCQvtQqR0tkw8jq8bBD5L/0KIV9VMJ
cRz/RROE5iZe+OCIHAr8Fraocwa48GOEAqDGWuzndN9wrqODJerWx5eHk6fGioozl2A3ED6X
Pm4pFdahD9GILBKfb6qkxkLrQaLjlUPTAYVtjrs78yM2x/474KElB0iryYl0/wiPgL/AlmXz
7uxLaL2diMMxs0Dx6M/2OLuc5NF/1OVYm3z61PMOm3WR5LpSLhl+0fXNWhn8ugb2+1KoS5kE
3fj5tItQo05iifCHJPqDQsGH+tUtKSpacXpkatcnYGMN285J9Y0fkIkyF/hzQ7jSWpOGYdbh
dQrqeWZ2iE9x6wQl1gpaepPluUsXQA+xtrn13k/c4LOsOxFwYIRKQ26ZIMApcQrAZQIDAQAB
o4ICyzCCAscwfQYIKwYBBQUHAQEEcTBvMEwGCCsGAQUFBzAChkBodHRwOi8vd3d3LmFjY3Yu
ZXMvZmlsZWFkbWluL0FyY2hpdm9zL2NlcnRpZmljYWRvcy9yYWl6YWNjdjEuY3J0MB8GCCsG
AQUFBzABhhNodHRwOi8vb2NzcC5hY2N2LmVzMB0GA1UdDgQWBBTSh7Tj3zcnk1X2VuqB5TbM
jB4/vTAPBgNVHRMBAf8EBTADAQH/MB8GA1UdIwQYMBaAFNKHtOPfNyeTVfZW6oHlNsyMHj+9
MIIBcwYDVR0gBIIBajCCAWYwggFiBgRVHSAAMIIBWDCCASIGCCsGAQUFBwICMIIBFB6CARAA
QQB1AHQAbwByAGkAZABhAGQAIABkAGUAIABDAGUAcgB0AGkAZgBpAGMAYQBjAGkA8wBuACAA
UgBhAO0AegAgAGQAZQAgAGwAYQAgAEEAQwBDAFYAIAAoAEEAZwBlAG4AYwBpAGEAIABkAGUA
IABUAGUAYwBuAG8AbABvAGcA7QBhACAAeQAgAEMAZQByAHQAaQBmAGkAYwBhAGMAaQDzAG4A
IABFAGwAZQBjAHQAcgDzAG4AaQBjAGEALAAgAEMASQBGACAAUQA0ADYAMAAxADEANQA2AEUA
KQAuACAAQwBQAFMAIABlAG4AIABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBjAGMAdgAuAGUA
czAwBggrBgEFBQcCARYkaHR0cDovL3d3dy5hY2N2LmVzL2xlZ2lzbGFjaW9uX2MuaHRtMFUG
A1UdHwROMEwwSqBIoEaGRGh0dHA6Ly93d3cuYWNjdi5lcy9maWxlYWRtaW4vQXJjaGl2b3Mv
Y2VydGlmaWNhZG9zL3JhaXphY2N2MV9kZXIuY3JsMA4GA1UdDwEB/wQEAwIBBjAXBgNVHREE
EDAOgQxhY2N2QGFjY3YuZXMwDQYJKoZIhvcNAQEFBQADggIBAJcxAp/n/UNnSEQU5CmH7Uwo
ZtCPNdpNYbdKl02125DgBS4OxnnQ8pdpD70ER9m+27Up2pvZrqmZ1dM8MJP1jaGo/AaNRPTK
FpV8M9xii6g3+CfYCS0b78gUJyCpZET/LtZ1qmxNYEAZSUNUY9rizLpm5U9EelvZaoErQNV/
+QEnWCzI7UiRfD+mAM/EKXMRNt6GGT6d7hmKG9Ww7Y49nCrADdg9ZuM8Db3VlFzi4qc1GwQA
9j9ajepDvV+JHanBsMyZ4k0ACtrJJ1vnE5Bc5PUzolVt3OAJTS+xJlsndQAJxGJ3KQhfnlms
tn6tn1QwIgPBHnFk/vk4CpYY3QIUrCPLBhwepH2NDd4nQeit2hW3sCPdK6jT2iWH7ehVRE2I
9DZ+hJp4rPcOVkkO1jMl1oRQQmwgEh0q1b688nCBpHBgvgW1m54ERL5hI6zppSSMEYCUWqKi
uUnSwdzRp+0xESyeGabu4VXhwOrPDYTkF7eifKXeVSUG7szAh1xA2syVP1XgNce4hL60Xc16
gwFy7ofmXx2utYXGJt/mwZrpHgJHnyqobalbz+xFd3+YJ5oyXSrjhO7FmGYvliAd3djDJ9ew
+f7Zfc3Qn48LFFhRny+Lwzgt3uiP1o2HpPVWQxaZLPSkVrQ0uGE3ycJYgBugl6H8WY3pEfbR
D0tVNEYqi4Y7
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFQTCCAymgAwIBAgICDL4wDQYJKoZIhvcNAQELBQAwUTELMAkGA1UEBhMCVFcxEjAQBgNV
BAoTCVRBSVdBTi1DQTEQMA4GA1UECxMHUm9vdCBDQTEcMBoGA1UEAxMTVFdDQSBHbG9iYWwg
Um9vdCBDQTAeFw0xMjA2MjcwNjI4MzNaFw0zMDEyMzExNTU5NTlaMFExCzAJBgNVBAYTAlRX
MRIwEAYDVQQKEwlUQUlXQU4tQ0ExEDAOBgNVBAsTB1Jvb3QgQ0ExHDAaBgNVBAMTE1RXQ0Eg
R2xvYmFsIFJvb3QgQ0EwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCwBdvI64zE
booh745NnHEKH1Jw7W2CnJfF10xORUnLQEK1EjRsGcJ0pDFfhQKX7EMzClPSnIyOt7h52yvV
avKOZsTuKwEHktSz0ALfUPZVr2YOy+BHYC8rMjk1Ujoog/h7FsYYuGLWRyWRzvAZEk2tY/XT
P3VfKfChMBwqoJimFb3u/Rk28OKRQ4/6ytYQJ0lM793B8YVwm8rqqFpD/G2Gb3PpN0Wp8DbH
zIh1HrtsBv+baz4X7GGqcXzGHaL3SekVtTzWoWH1EfcFbx39Eb7QMAfCKbAJTibc46KokWof
wpFFiFzlmLhxpRUZyXx1EcxwdE8tmx2RRP1WKKD+u4ZqyPpcC1jcxkt2yKsi2XMPpfRaAok/
T54igu6idFMqPVMnaR1sjjIsZAAmY2E2TqNGtz99sy2sbZCilaLOz9qC5wc0GZbpuCGqKX6m
OL6OKUohZnkfs8O1CWfe1tQHRvMq2uYiN2DLgbYPoA/pyJV/v1WRBXrPPRXAb94JlAGD1zQb
zECl8LibZ9WYkTunhHiVJqRaCPgrdLQABDzfuBSO6N+pjWxnkjMdwLfS7JLIvgm/LCkFbwJr
nu+8vyq8W8BQj0FwcYeyTbcEqYSjMq+u7msXi7Kx/mzhkIyIqJdIzshNy/MGz19qCkKxHh53
L46g5pIOBvwFItIm4TFRfTLcDwIDAQABoyMwITAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/
BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAgEAXzSBdu+WHdXltdkCY4QWwa6gcFGn90xHNcgL
1yg9iXHZqjNB6hQbbCEAwGxCGX6faVsgQt+i0trEfJdLjbDorMjupWkEmQqSpqsnLhpNgb+E
1HAerUf+/UqdM+DyucRFCCEK2mlpc3INvjT+lIutwx4116KD7+U4x6WFH6vPNOw/KP4M8VeG
TslV9xzU2KV9Bnpv1d8Q34FOIWWxtuEXeZVFBs5fzNxGiWNoRI2T9GRwoD2dKAXDOXC4Ynsg
/eTb6QihuJ49CcdP+yz4k3ZB3lLg4VfSnQO8d57+nile98FRYB/e2guyLXW3Q0iT5/Z5xoRd
gFlglPx4mI88k1HtQJAH32RjJMtOcQWh15QaiDLxInQirqWm2BJpTGCjAu4r7NRjkgtevi92
a6O2JryPA9gK8kxkRr05YuWW6zRjESjMlfGt7+/cgFhI6Uu46mWs6fyAtbXIRfmswZ/Zuepi
iI7E8UuDEq3mi4TWnsLrgxifarsbJGAzcMzs9zLzXNl5fe+epP7JI8Mk7hWSsT2RTyaGvWZz
JBPqpK5jwa19hAM8EHiGG3njxPPyBJUgriOCxLM6AGK/5jYk4Ve6xx6QddVfP5VhK8E7zeWz
aGHQRiapIVJpLesux+t3zqY6tQMzT3bR51xUAV3LePTJDL/PEo4XLSNolOer/qmyKwbQBM0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFODCCAyCgAwIBAgIRAJW+FqD3LkbxezmCcvqLzZYwDQYJKoZIhvcNAQEFBQAwNzEUMBIG
A1UECgwLVGVsaWFTb25lcmExHzAdBgNVBAMMFlRlbGlhU29uZXJhIFJvb3QgQ0EgdjEwHhcN
MDcxMDE4MTIwMDUwWhcNMzIxMDE4MTIwMDUwWjA3MRQwEgYDVQQKDAtUZWxpYVNvbmVyYTEf
MB0GA1UEAwwWVGVsaWFTb25lcmEgUm9vdCBDQSB2MTCCAiIwDQYJKoZIhvcNAQEBBQADggIP
ADCCAgoCggIBAMK+6yfwIaPzaSZVfp3FVRaRXP3vIb9TgHot0pGMYzHw7CTww6XScnwQbfQ3
t+XmfHnqjLWCi65ItqwA3GV17CpNX8GH9SBlK4GoRz6JI5UwFpB/6FcHSOcZrr9FZ7E3GwYq
/t75rH2D+1665I+XZ75Ljo1kB1c4VWk0Nj0TSO9P4tNmHqTPGrdeNjPUtAa9GAH9d4RQAEX1
jF3oI7x+/jXh7VB7qTCNGdMJjmhnXb88lxhTuylixcpecsHHltTbLaC0H2kD7OriUPEMPPCs
81Mt8Bz17Ww5OXOAFshSsCPN4D7c3TxHoLs1iuKYaIu+5b9y7tL6pe0S7fyYGKkmdtwoSxAg
HNN/Fnct7W+A90m7UwW7XWjH1Mh1Fj+JWov3F0fUTPHSiXk+TT2YqGHeOh7S+F4D4MHJHIzT
jU3TlTazN19jY5szFPAtJmtTfImMMsJu7D0hADnJoWjiUIMusDor8zagrC/kb2HCUQk5PotT
ubtn2txTuXZZNp1D5SDgPTJghSJRt8czu90VL6R4pgd7gUY2BIbdeTXHlSw7sKMXNeVzH7Rc
We/a6hBle3rQf5+ztCo3O3CLm1u5K7fsslESl1MpWtTwEhDcTwK7EpIvYtQ/aUN8Ddb8WHUB
iJ1YFkveupD/RwGJBmr2X7KQarMCpgKIv7NHfirZ1fpoeDVNAgMBAAGjPzA9MA8GA1UdEwEB
/wQFMAMBAf8wCwYDVR0PBAQDAgEGMB0GA1UdDgQWBBTwj1k4ALP1j5qWDNXr+nuqF+gTEjAN
BgkqhkiG9w0BAQUFAAOCAgEAvuRcYk4k9AwI//DTDGjkk0kiP0Qnb7tt3oNmzqjMDfz1mgbl
dxSR651Be5kqhOX//CHBXfDkH1e3damhXwIm/9fH907eT/j3HEbAek9ALCI18Bmx0GtnLLCo
4MBANzX2hFxc469CeP6nyQ1Q6g2EdvZR74NTxnr/DlZJLo961gzmJ1TjTQpgcmLNkQfWpb/I
mWvtxBnmq0wROMVvMeJuScg/doAmAyYp4Db29iBT4xdwNBedY2gea+zDTYa4EzAvXUYNR0PV
G6pZDrlcjQZIrXSHX8f8MVRBE+LHIQ6e4B4N4cB7Q4WQxYpYxmUKeFfyxiMPAdkgS94P+5KF
dSpcc41teyWRyu5FrgZLAMzTsVlQ2jqIOylDRl6XK1TOU2+NSueW+r9xDkKLfP0ooNBIytrE
gUy7onOTJsjrDNYmiLbAJM+7vVvrdX3pCI6GMyx5dwlppYn8s3CQh3aP0yK7Qs69cwsgJirQ
mz1wHiRszYd2qReWt88NkvuOGKmYSdGe/mBEciG5Ge3C9THxOUiIkCR1VBatzvT4aRRkOfuj
uLpwQMcnHL/EVlP6Y2XQ8xwOFvVrhlhNGNTkDY6lnVuR3HYkUD/GKvvZt5y11ubQ2egZixVx
SK236thZiNSQvxaz2emsWWFUyBy6ysHK4bkgTI86k4mloMy/0/Z1pHWWbVY=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIGSzCCBDOgAwIBAgIIamg+nFGby1MwDQYJKoZIhvcNAQELBQAwgbIxCzAJBgNVBAYTAlRS
MQ8wDQYDVQQHDAZBbmthcmExQDA+BgNVBAoMN0UtVHXEn3JhIEVCRyBCaWxpxZ9pbSBUZWtu
b2xvamlsZXJpIHZlIEhpem1ldGxlcmkgQS7Fni4xJjAkBgNVBAsMHUUtVHVncmEgU2VydGlm
aWthc3lvbiBNZXJrZXppMSgwJgYDVQQDDB9FLVR1Z3JhIENlcnRpZmljYXRpb24gQXV0aG9y
aXR5MB4XDTEzMDMwNTEyMDk0OFoXDTIzMDMwMzEyMDk0OFowgbIxCzAJBgNVBAYTAlRSMQ8w
DQYDVQQHDAZBbmthcmExQDA+BgNVBAoMN0UtVHXEn3JhIEVCRyBCaWxpxZ9pbSBUZWtub2xv
amlsZXJpIHZlIEhpem1ldGxlcmkgQS7Fni4xJjAkBgNVBAsMHUUtVHVncmEgU2VydGlmaWth
c3lvbiBNZXJrZXppMSgwJgYDVQQDDB9FLVR1Z3JhIENlcnRpZmljYXRpb24gQXV0aG9yaXR5
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA4vU/kwVRHoViVF56C/UYB4Oufq98
99SKa6VjQzm5S/fDxmSJPZQuVIBSOTkHS0vdhQd2h8y/L5VMzH2nPbxHD5hw+IyFHnSOkm0b
QNGZDbt1bsipa5rAhDGvykPL6ys06I+XawGb1Q5KCKpbknSFQ9OArqGIW66z6l7LFpp3RMih
9lRozt6Plyu6W0ACDGQXwLWTzeHxE2bODHnv0ZEoq1+gElIwcxmOj+GMB6LDu0rw6h8VqO4l
zKRG+Bsi77MOQ7osJLjFLFzUHPhdZL3Dk14opz8n8Y4e0ypQBaNV2cvnOVPAmJ6MVGKLJrD3
fY185MaeZkJVgkfnsliNZvcHfC425lAcP9tDJMW/hkd5s3kc91r0E+xs+D/iWR+V7kI+ua2o
MoVJl0b+SzGPWsutdEcf6ZG33ygEIqDUD13ieU/qbIWGvaimzuT6w+Gzrt48Ue7LE3wBf4QO
XVGUnhMMti6lTPk5cDZvlsouDERVxcr6XQKj39ZkjFqzAQqptQpHF//vkUAqjqFGOjGY5RH8
zLtJVor8udBhmm9lbObDyz51Sf6Pp+KJxWfXnUYTTjF2OySznhFlhqt/7x3U+LznrFpct1pH
XFXOVbQicVtbC/DP3KBhZOqp12gKY6fgDT+gr9Oq0n7vUaDmUStVkhUXU8u3Zg5mTPj5dUyQ
5xJwx0UCAwEAAaNjMGEwHQYDVR0OBBYEFC7j27JJ0JxUeVz6Jyr+zE7S6E5UMA8GA1UdEwEB
/wQFMAMBAf8wHwYDVR0jBBgwFoAULuPbsknQnFR5XPonKv7MTtLoTlQwDgYDVR0PAQH/BAQD
AgEGMA0GCSqGSIb3DQEBCwUAA4ICAQAFNzr0TbdF4kV1JI+2d1LoHNgQk2Xz8lkGpD4eKexd
0dCrfOAKkEh47U6YA5n+KGCRHTAduGN8qOY1tfrTYXbm1gdLymmasoR6d5NFFxWfJNCYExL/
u6Au/U5Mh/jOXKqYGwXgAEZKgoClM4so3O0409/lPun++1ndYYRP0lSWE2ETPo+Aab6TR7U1
Q9Jauz1c77NCR807VRMGsAnb/WP2OogKmW9+4c4bU2pEZiNRCHu8W1Ki/QY3OEBhj0qWuJA3
+GbHeJAAFS6LrVE1Uweoa2iu+U48BybNCAVwzDk/dr2l02cmAYamU9JgO3xDf1WKvJUawSg5
TB9D0pH0clmKuVb8P7Sd2nCcdlqMQ1DujjByTd//SffGqWfZbawCEeI6FiWnWAjLb1NBnEg4
R2gz0dfHj9R0IdTDBZB6/86WiLEVKV0jq9BgoRJP3vQXzTLlyb/IQ639Lo7xr+L0mPoSHyDY
wKcMhcWQ9DstliaxLL5Mq+ux0orJ23gTDx4JnW2PAJ8C2sH6H3p6CcRK5ogql5+Ji/03X186
zjhZhkuvcQu02PJwT58yE+Owp1fl2tpDy4Q08ijE6m30Ku/Ba3ba+367hTzSU8JNvnHhRdH9
I2cNE3X7z2VnIp2usAnRCf8dNL/+I5c30jn6PQ0GC7TbO6Orb1wdtn7os4I07QZcJA==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDwzCCAqugAwIBAgIBATANBgkqhkiG9w0BAQsFADCBgjELMAkGA1UEBhMCREUxKzApBgNV
BAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQtU3lz
dGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENsYXNz
IDIwHhcNMDgxMDAxMTA0MDE0WhcNMzMxMDAxMjM1OTU5WjCBgjELMAkGA1UEBhMCREUxKzAp
BgNVBAoMIlQtU3lzdGVtcyBFbnRlcnByaXNlIFNlcnZpY2VzIEdtYkgxHzAdBgNVBAsMFlQt
U3lzdGVtcyBUcnVzdCBDZW50ZXIxJTAjBgNVBAMMHFQtVGVsZVNlYyBHbG9iYWxSb290IENs
YXNzIDIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCqX9obX+hzkeXaXPSi5kfl
82hVYAUdAqSzm1nzHoqvNK38DcLZSBnuaY/JIPwhqgcZ7bBcrGXHX+0CfHt8LRvWurmAwhiC
FoT6ZrAIxlQjgeTNuUk/9k9uN0goOA/FvudocP05l03Sx5iRUKrERLMjfTlH6VJi1hKTXrcx
lkIF+3anHqP1wvzpesVsqXFP6st4vGCvx9702cu+fjOlbpSD8DT6IavqjnKgP6TeMFvvhk1q
lVtDRKgQFRzlAVfFmPHmBiiRqiDFt1MmUUOyCxGVWOHAD3bZwI18gfNycJ5v/hqO2V81xrJv
NHy+SE/iWjnX2J14np+GPgNeGYtEotXHAgMBAAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYD
VR0PAQH/BAQDAgEGMB0GA1UdDgQWBBS/WSA2AHmgoCJrjNXyYdK4LMuCSjANBgkqhkiG9w0B
AQsFAAOCAQEAMQOiYQsfdOhyNsZt+U2e+iKo4YFWz827n+qrkRk4r6p8FU3ztqONpfSO9kSp
p+ghla0+AGIWiPACuvxhI+YzmzB6azZie60EI4RYZeLbK4rnJVM3YlNfvNoBYimipidx5joi
fsFvHZVwIEoHNN/q/xWA5brXethbdXwFeilHfkCoMRN3zUA7tFFHei4R40cR3p1m0IvVVGb6
g1XqfMIpiRvpb7PO4gWEyS8+eIVibslfwXhjdFjASBgMmTnrpMwatXlajRWc2BQN9noHV8ci
gwUtPJslJj0Ys6lDfMjIq2SPDqO/nBudMNva0Bkuqjzx+zOAduTNrRlPBSeOE6Fuwg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDdzCCAl+gAwIBAgIIXDPLYixfszIwDQYJKoZIhvcNAQELBQAwPDEeMBwGA1UEAwwVQXRv
cyBUcnVzdGVkUm9vdCAyMDExMQ0wCwYDVQQKDARBdG9zMQswCQYDVQQGEwJERTAeFw0xMTA3
MDcxNDU4MzBaFw0zMDEyMzEyMzU5NTlaMDwxHjAcBgNVBAMMFUF0b3MgVHJ1c3RlZFJvb3Qg
MjAxMTENMAsGA1UECgwEQXRvczELMAkGA1UEBhMCREUwggEiMA0GCSqGSIb3DQEBAQUAA4IB
DwAwggEKAoIBAQCVhTuXbyo7LjvPpvMpNb7PGKw+qtn4TaA+Gke5vJrf8v7MPkfoepbCJI41
9KkM/IL9bcFyYie96mvr54rMVD6QUM+A1JX76LWC1BTFtqlVJVfbsVD2sGBkWXppzwO3bw2+
yj5vdHLqqjAqc2K+SZFhyBH+DgMq92og3AIVDV4VavzjgsG1xZ1kCWyjWZgHJ8cblithdHFs
Q/H3NYkQ4J7sVaE3IqKHBAUsR320HLliKWYoyrfhk/WklAOZuXCFteZI6o1Q/NnezG8HDt0L
cp2AMBYHlT8oDv3FdU9T1nSatCQujgKRz3bFmx5VdJx4IbHwLfELn8LVlhgf8FQieowHAgMB
AAGjfTB7MB0GA1UdDgQWBBSnpQaxLKYJYO7Rl+lwrrw7GWzbITAPBgNVHRMBAf8EBTADAQH/
MB8GA1UdIwQYMBaAFKelBrEspglg7tGX6XCuvDsZbNshMBgGA1UdIAQRMA8wDQYLKwYBBAGw
LQMEAQEwDgYDVR0PAQH/BAQDAgGGMA0GCSqGSIb3DQEBCwUAA4IBAQAmdzTblEiGKkGdLD4G
kGDEjKwLVLgfuXvTBznk+j57sj1O7Z8jvZfza1zv7v1Apt+hk6EKhqzvINB5Ab149xnYJDE0
BAGmuhWawyfc2E8PzBhj/5kPDpFrdRbhIfzYJsdHt6bPWHJxfrrhTZVHO8mvbaG0weyJ9rQP
OLXiZNwlz6bb65pcmaHFCN795trV1lpFDMS3wrUU77QR/w4VtfX128a961qn8FYiqTxlVMYV
qL2Gns2Dlmh6cYGJ4Qvh6hEbaAjMaZ7snkGeRDImeuKHCnE96+RapNLbxc3G3mB/ufNPRJLv
KrcYPqcZ2Qt9sTdBQrC6YB3y/gkRsPCHe6ed
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFYDCCA0igAwIBAgIUeFhfLq0sGUvjNwc1NBMotZbUZZMwDQYJKoZIhvcNAQELBQAwSDEL
MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAcBgNVBAMTFVF1b1Zh
ZGlzIFJvb3QgQ0EgMSBHMzAeFw0xMjAxMTIxNzI3NDRaFw00MjAxMTIxNzI3NDRaMEgxCzAJ
BgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMR4wHAYDVQQDExVRdW9WYWRp
cyBSb290IENBIDEgRzMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCgvlAQjuny
bEC0BJyFuTHK3C3kEakEPBtVwedYMB0ktMPvhd6MLOHBPd+C5k+tR4ds7FtJwUrVu4/sh6x/
gpqG7D0DmVIB0jWerNrwU8lmPNSsAgHaJNM7qAJGr6Qc4/hzWHa39g6QDbXwz8z6+cZM5cOG
MAqNF34168Xfuw6cwI2H44g4hWf6Pser4BOcBRiYz5P1sZK0/CPTz9XEJ0ngnjybCKOLXSoh
4Pw5qlPafX7PGglTvF0FBM+hSo+LdoINofjSxxR3W5A2B4GbPgb6Ul5jxaYA/qXpUhtStZI5
cgMJYr2wYBZupt0lwgNm3fME0UDiTouG9G/lg6AnhF4EwfWQvTA9xO+oabw4m6SkltFi2mnA
AZauy8RRNOoMqv8hjlmPSlzkYZqn0ukqeI1RPToV7qJZjqlc3sX5kCLliEVx3ZGZbHqfPT2Y
fF72vhZooF6uCyP8Wg+qInYtyaEQHeTTRCOQiJ/GKubX9ZqzWB4vMIkIG1SitZgj7Ah3HJVd
YdHLiZxfokqRmu8hqkkWCKi9YSgxyXSthfbZxbGL0eUQMk1fiyA6PEkfM4VZDdvLCXVDaXP7
a3F98N/ETH3Goy7IlXnLc6KOTk0k+17kBL5yG6YnLUlamXrXXAkgt3+UuU/xDRxeiEIbEbfn
kduebPRq34wGmAOtzCjvpUfzUwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB
/wQEAwIBBjAdBgNVHQ4EFgQUo5fW816iEOGrRZ88F2Q87gFwnMwwDQYJKoZIhvcNAQELBQAD
ggIBABj6W3X8PnrHX3fHyt/PX8MSxEBd1DKquGrX1RUVRpgjpeaQWxiZTOOtQqOCMTaIzen7
xASWSIsBx40Bz1szBpZGZnQdT+3Btrm0DWHMY37XLneMlhwqI2hrhVd2cDMT/uFPpiN3GPoa
jOi9ZcnPP/TJF9zrx7zABC4tRi9pZsMbj/7sPtPKlL92CiUNqXsCHKnQO18LwIE6PWThv6ct
Tr1NxNgpxiIY0MWscgKCP6o6ojoilzHdCGPDdRS5YCgtW2jgFqlmgiNR9etT2DGbe+m3nUvr
iBbP+V04ikkwj+3x6xn0dxoxGE1nVGwvb2X52z3sIexe9PSLymBlVNFxZPT5pqOBMzYzcfCk
eF9OrYMh3jRJjehZrJ3ydlo28hP0r+AJx2EqbPfgna67hkooby7utHnNkDPDs3b69fBsnQGQ
+p6Q9pxyz0fawx/kNSBT8lTR32GDpgLiJTjehTItXnOQUl1CxM49S+H5GYQd1aJQzEH7QRTD
vdbJWqNjZgKAvQU6O0ec7AAmTPWIUb+oI38YB7AL7YsmoWTTYUrrXJ/es69nA7Mf3W1daWhp
q1467HxpvMc7hU6eFbm0FU/DlXpY18ls6Wy58yljXrQs8C097Vpl4KlbQMJImYFtnh8GKjwS
tIsPm6Ik8KaN1nrgS7ZklmOVhMJKzRwuJIczYOXD
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFYDCCA0igAwIBAgIURFc0JFuBiZs18s64KztbpybwdSgwDQYJKoZIhvcNAQELBQAwSDEL
MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAcBgNVBAMTFVF1b1Zh
ZGlzIFJvb3QgQ0EgMiBHMzAeFw0xMjAxMTIxODU5MzJaFw00MjAxMTIxODU5MzJaMEgxCzAJ
BgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMR4wHAYDVQQDExVRdW9WYWRp
cyBSb290IENBIDIgRzMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQChriWyARjc
V4g/Ruv5r+LrI3HimtFhZiFfqq8nUeVuGxbULX1QsFN3vXg6YOJkApt8hpvWGo6t/x8Vf9WV
HhLL5hSEBMHfNrMWn4rjyduYNM7YMxcoRvynyfDStNVNCXJJ+fKH46nafaF9a7I6JaltUkSs
+L5u+9ymc5GQYaYDFCDy54ejiK2toIz/pgslUiXnFgHVy7g1gQyjO/Dh4fxaXc6AcW34Sas+
O7q414AB+6XrW7PFXmAqMaCvN+ggOp+oMiwMzAkd056OXbxMmO7FGmh77FOm6RQ1o9/NgJ8M
SPsc9PG/Srj61YxxSscfrf5BmrODXfKEVu+lV0POKa2Mq1W/xPtbAd0jIaFYAI7D0GoT7RPj
EiuA3GfmlbLNHiJuKvhB1PLKFAeNilUSxmn1uIZoL1NesNKqIcGY5jDjZ1XHm26sGahVpkUG
0CM62+tlXSoREfA7T8pt9DTEceT/AFr2XK4jYIVz8eQQsSWu1ZK7E8EM4DnatDlXtas1qnIh
O4M15zHfeiFuuDIIfR0ykRVKYnLP43ehvNURG3YBZwjgQQvD6xVu+KQZ2aKrr+InUlYrAoos
FCT5v0ICvybIxo/gbjh9Uy3l7ZizlWNof/k19N+IxWA1ksB8aRxhlRbQ694Lrz4EEEVlWFA4
r0jyWbYW8jwNkALGcC4BrTwV1wIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB
/wQEAwIBBjAdBgNVHQ4EFgQU7edvdlq/YOxJW8ald7tyFnGbxD0wDQYJKoZIhvcNAQELBQAD
ggIBAJHfgD9DCX5xwvfrs4iP4VGyvD11+ShdyLyZm3tdquXK4Qr36LLTn91nMX66AarHakE7
kNQIXLJgapDwyM4DYvmL7ftuKtwGTTwpD4kWilhMSA/ohGHqPHKmd+RCroijQ1h5fq7KpVMN
qT1wvSAZYaRsOPxDMuHBR//47PERIjKWnML2W2mWeyAMQ0GaW/ZZGYjeVYg3UQt4XAoeo0L9
x52ID8DyeAIkVJOviYeIyUqAHerQbj5hLja7NQ4nlv1mNDthcnPxFlxHBlRJAHpYErAK74X9
sbgzdWqTHBLmYF5vHX/JHyPLhGGfHoJE+V+tYlUkmlKY7VHnoX6XOuYvHxHaU4AshZ6rNRDb
Il9qxV6XU/IyAgkwo1jwDQHVcsaxfGl7w/U2Rcxhbl5MlMVerugOXou/983g7aEOGzPuVBj+
D77vfoRrQ+NwmNtddbINWQeFFSM51vHfqSYP1kjHs6Yi9TM3WpVHn3u6GBVv/9YUZINJ0gpn
IdsPNWNgKCLjsZWDzYWm3S8P52dSbrsvhXz1SnPnxT7AvSESBT/8twNJAlvIJebiVDj1eYeM
HVOyToV7BjjHLPj4sHKNJeV3UvQDHEimUF+IIDBu8oJDqz2XhOdT+yHBTw8imoa4WSr2Rz0Z
iC3oheGe7IUIarFsNMkd7EgrO3jtZsSOeWmD3n+M
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFYDCCA0igAwIBAgIULvWbAiin23r/1aOp7r0DoM8Sah0wDQYJKoZIhvcNAQELBQAwSDEL
MAkGA1UEBhMCQk0xGTAXBgNVBAoTEFF1b1ZhZGlzIExpbWl0ZWQxHjAcBgNVBAMTFVF1b1Zh
ZGlzIFJvb3QgQ0EgMyBHMzAeFw0xMjAxMTIyMDI2MzJaFw00MjAxMTIyMDI2MzJaMEgxCzAJ
BgNVBAYTAkJNMRkwFwYDVQQKExBRdW9WYWRpcyBMaW1pdGVkMR4wHAYDVQQDExVRdW9WYWRp
cyBSb290IENBIDMgRzMwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCzyw4QZ47q
FJenMioKVjZ/aEzHs286IxSR/xl/pcqs7rN2nXrpixurazHb+gtTTK/FpRp5PIpM/6zfJd5O
2YIyC0TeytuMrKNuFoM7pmRLMon7FhY4futD4tN0SsJiCnMK3UmzV9KwCoWdcTzeo8vAMvMB
OSBDGzXRU7Ox7sWTaYI+FrUoRqHe6okJ7UO4BUaKhvVZR74bbwEhELn9qdIoyhA5CcoTNs+c
ra1AdHkrAj80//ogaX3T7mH1urPnMNA3I4ZyYUUpSFlob3emLoG+B01vr87ERRORFHAGjx+f
+IdpsQ7vw4kZ6+ocYfx6bIrc1gMLnia6Et3UVDmrJqMz6nWB2i3ND0/kA9HvFZcba5DFApCT
ZgIhsUfei5pKgLlVj7WiL8DWM2fafsSntARE60f75li59wzweyuxwHApw0BiLTtIadwjPEjr
ewl5qW3aqDCYz4ByA4imW0aucnl8CAMhZa634RylsSqiMd5mBPfAdOhx3v89WcyWJhKLhZVX
GqtrdQtEPREoPHtht+KPZ0/l7DxMYIBpVzgeAVuNVejH38DMdyM0SXV89pgR6y3e7UEuFAUC
f+D+IOs15xGsIs5XPd7JMG0QA4XN8f+MFrXBsj6IbGB/kE+V9/YtrQE5BwT6dYB9v0lQ7e/J
xHwc64B+27bQ3RP+ydOc17KXqQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB
/wQEAwIBBjAdBgNVHQ4EFgQUxhfQvKjqAkPyGwaZXSuQILnXnOQwDQYJKoZIhvcNAQELBQAD
ggIBADRh2Va1EodVTd2jNTFGu6QHcrxfYWLopfsLN7E8trP6KZ1/AvWkyaiTt3pxKGmPc+FS
kNrVvjrlt3ZqVoAh313m6Tqe5T72omnHKgqwGEfcIHB9UqM+WXzBusnIFUBhynLWcKzSt/Ac
5IYp8M7vaGPQtSCKFWGafoaYtMnCdvvMujAWzKNhxnQT5WvvoxXqA/4Ti2Tk08HS6IT7SdEQ
TXlm66r99I0xHnAUrdzeZxNMgRVhvLfZkXdxGYFgu/BYpbWcC/ePIlUnwEsBbTuZDdQdm2Nn
L9DuDcpmvJRPpq3t/O5jrFc/ZSXPsoaP0Aj/uHYUbt7lJ+yreLVTubY/6CD50qi+YUbKh4yE
8/nxoGibIh6BJpsQBJFxwAYf3KDTuVan45gtf4Od34wrnDKOMpTwATwiKp9Dwi7DmDkHOHv8
XgBCH/MyJnmDhPbl8MFREsALHgQjDFSlTC9JxUrRtm5gDWv8a4uFJGS3iQ6rJUdbPM9+Sb3H
6QrG2vd+DhcI00iX0HGS8A85PjRqHH3Y8iKuu2n0M7SmSFXRDw4m6Oy2Cy2nhTXN/VnIn9HN
PlopNLk9hM6xZdRZkZFWdSHBd575euFgndOtBBj0fOtek49TSiIp+EgrPk2GrFt/ywaZWWDY
WGWVjUTR939+J399roD1B0y2PpxxVJkES/1Y+Zj0
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDljCCAn6gAwIBAgIQC5McOtY5Z+pnI7/Dr5r0SzANBgkqhkiG9w0BAQsFADBlMQswCQYD
VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
Y29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzIwHhcNMTMwODAxMTIw
MDAwWhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQg
SW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1
cmVkIElEIFJvb3QgRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDZ5ygvUj82
ckmIkzTz+GoeMVSAn61UQbVH35ao1K+ALbkKz3X9iaV9JPrjIgwrvJUXCzO/GU1BBpAAvQxN
EP4HteccbiJVMWWXvdMX0h5i89vqbFCMP4QMls+3ywPgym2hFEwbid3tALBSfK+RbLE4E9Hp
EgjAALAcKxHad3A2m67OeYfcgnDmCXRwVWmvo2ifv922ebPynXApVfSr/5Vh88lAbx3RvpO7
04gqu52/clpWcTs/1PPRCv4o76Pu2ZmvA9OPYLfykqGxvYmJHzDNw6YuYjOuFgJ3RFrngQo8
p0Quebg/BLxcoIfhG69Rjs3sLPr4/m3wOnyqi+RnlTGNAgMBAAGjQjBAMA8GA1UdEwEB/wQF
MAMBAf8wDgYDVR0PAQH/BAQDAgGGMB0GA1UdDgQWBBTOw0q5mVXyuNtgv6l+vVa1lzan1jAN
BgkqhkiG9w0BAQsFAAOCAQEAyqVVjOPIQW5pJ6d1Ee88hjZv0p3GeDgdaZaikmkuOGybfQTU
iaWxMTeKySHMq2zNixya1r9I0jJmwYrA8y8678Dj1JGG0VDjA9tzd29KOVPt3ibHtX2vK0LR
dWLjSisCx1BL4GnilmwORGYQRI+tBev4eaymG+g3NJ1TyWGqolKvSnAWhsI6yLETcDbYz+70
CjTVW0z9B5yiutkBclzzTcHdDrEcDcRjvq30FPuJ7KJBDkzMyFdA0G4Dqs0MjomZmWzwPDCv
ON9vvKO+KSAnq3T/EyJ43pdSVR6DtVQgA+6uwE9W3jfMw3+qBCe703e4YtsXfJwoIhNzbM8m
9Yop5w==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICRjCCAc2gAwIBAgIQC6Fa+h3foLVJRK/NJKBs7DAKBggqhkjOPQQDAzBlMQswCQYDVQQG
EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29t
MSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVkIElEIFJvb3QgRzMwHhcNMTMwODAxMTIwMDAw
WhcNMzgwMTE1MTIwMDAwWjBlMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5j
MRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdpQ2VydCBBc3N1cmVk
IElEIFJvb3QgRzMwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQZ57ysRGXtzbg/WPuNsVepRC0F
FfLvC/8QdJ+1YlJfZn4f5dwbRXkLzMZTCp2NXQLZqVneAlr2lSoOjThKiknGvMYDOAdfVdp+
CW7if17QRSAPWXYQ1qAk8C3eNvJsKTmjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/
BAQDAgGGMB0GA1UdDgQWBBTL0L2p4ZgFUaFNN6KDec6NHSrkhDAKBggqhkjOPQQDAwNnADBk
AjAlpIFFAmsSS3V0T8gj43DydXLefInwz5FyYZ5eEJJZVrmDxxDnOOlYJjZ91eQ0hjkCMHw2
U/Aw5WJjOpnitqM7mzT6HtoQknFekROn3aRukswy1vUhZscv6pZjamVFkpUBtA==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDjjCCAnagAwIBAgIQAzrx5qcRqaC7KGSxHQn65TANBgkqhkiG9w0BAQsFADBhMQswCQYD
VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
Y29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBHMjAeFw0xMzA4MDExMjAwMDBa
Fw0zODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMx
GTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBS
b290IEcyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuzfNNNx7a8myaJCtSnX/
RrohCgiN9RlUyfuI2/Ou8jqJkTx65qsGGmvPrC3oXgkkRLpimn7Wo6h+4FR1IAWsULecYxps
MNzaHxmx1x7e/dfgy5SDN67sH0NO3Xss0r0upS/kqbitOtSZpLYl6ZtrAGCSYP9PIUkY92eQ
q2EGnI/yuum06ZIya7XzV+hdG82MHauVBJVJ8zUtluNJbd134/tJS7SsVQepj5WztCO7TG1F
8PapspUwtP1MVYwnSlcUfIKdzXOS0xZKBgyMUNGPHgm+F6HmIcr9g+UQvIOlCsRnKPZzFBQ9
RnbDhxSJITRNrw9FDKZJobq7nMWxM4MphQIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4G
A1UdDwEB/wQEAwIBhjAdBgNVHQ4EFgQUTiJUIBiV5uNu5g/6+rkS7QYXjzkwDQYJKoZIhvcN
AQELBQADggEBAGBnKJRvDkhj6zHd6mcY1Yl9PMWLSn/pvtsrF9+wX3N3KjITOYFnQoQj8kVn
NeyIv/iPsGEMNKSuIEyExtv4NeF22d+mQrvHRAiGfzZ0JFrabA0UWTW98kndth/Jsw1HKj2Z
L7tcu7XUIOGZX1NGFdtom/DzMNU+MeKNhJ7jitralj41E6Vf8PlwUHBHQRFXGU7Aj64GxJUT
Fy8bJZ918rGOmaFvE7FBcf6IKshPECBV1/MUReXgRPTqh5Uykw7+U0b6LJ3/iyK5S9kJRaTe
pLiaWN0bfVKfjllDiIGknibVb63dDcY3fe0Dkhvld1927jyNxF1WW6LZZm6zNTflMrY=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICPzCCAcWgAwIBAgIQBVVWvPJepDU1w6QP1atFcjAKBggqhkjOPQQDAzBhMQswCQYDVQQG
EwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29t
MSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBHMzAeFw0xMzA4MDExMjAwMDBaFw0z
ODAxMTUxMjAwMDBaMGExCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAX
BgNVBAsTEHd3dy5kaWdpY2VydC5jb20xIDAeBgNVBAMTF0RpZ2lDZXJ0IEdsb2JhbCBSb290
IEczMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE3afZu4q4C/sLfyHS8L6+c/MzXRq8NOrexpu8
0JX28MzQC7phW1FGfp4tn+6OYwwX7Adw9c+ELkCDnOg/QW07rdOkFFk2eJ0DQ+4QE2xy3q6I
p6FrtUPOZ9wj/wMco+I+o0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBhjAd
BgNVHQ4EFgQUs9tIpPmhxdiuNkHMEWNpYim8S8YwCgYIKoZIzj0EAwMDaAAwZQIxAK288mw/
EkrRLTnDCgmXc/SINoyIJ7vmiI1Qhadj+Z4y3maTD/HMsQmP3Wyr+mt/oAIwOWZbwmSNuJ5Q
3KjVSaLtx9zRSX8XAbjIho9OjIgrqJqpisXRAL34VOKa5Vt8sycX
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFkDCCA3igAwIBAgIQBZsbV56OITLiOQe9p3d1XDANBgkqhkiG9w0BAQwFADBiMQswCQYD
VQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQu
Y29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVkIFJvb3QgRzQwHhcNMTMwODAxMTIwMDAw
WhcNMzgwMTE1MTIwMDAwWjBiMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5j
MRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSEwHwYDVQQDExhEaWdpQ2VydCBUcnVzdGVk
IFJvb3QgRzQwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC/5pBzaN675F1KPDAi
MGkz7MKnJS7JIT3yithZwuEppz1Yq3aaza57G4QNxDAf8xukOBbrVsaXbR2rsnnyyhHS5F/W
BTxSD1Ifxp4VpX6+n6lXFllVcq9ok3DCsrp1mWpzMpTREEQQLt+C8weE5nQ7bXHiLQwb7iDV
ySAdYyktzuxeTsiT+CFhmzTrBcZe7FsavOvJz82sNEBfsXpm7nfISKhmV1efVFiODCu3T6cw
2Vbuyntd463JT17lNecxy9qTXtyOj4DatpGYQJB5w3jHtrHEtWoYOAMQjdjUN6QuBX2I9YI+
EJFwq1WCQTLX2wRzKm6RAXwhTNS8rhsDdV14Ztk6MUSaM0C/CNdaSaTC5qmgZ92kJ7yhTzm1
EVgX9yRcRo9k98FpiHaYdj1ZXUJ2h4mXaXpI8OCiEhtmmnTK3kse5w5jrubU75KSOp493ADk
RSWJtppEGSt+wJS00mFt6zPZxd9LBADMfRyVw4/3IbKyEbe7f/LVjHAsQWCqsWMYRJUadmJ+
9oCw++hkpjPRiQfhvbfmQ6QYuKZ3AeEPlAwhHbJUKSWJbOUOUlFHdL4mrLZBdd56rF+NP8m8
00ERElvlEFDrMcXKchYiCd98THU/Y+whX8QgUWtvsauGi0/C1kVfnSD8oR7FwI+isX4KJpn1
5GkvmB0t9dmpsh3lGwIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIB
hjAdBgNVHQ4EFgQU7NfjgtJxXWRM3y5nP+e6mK4cD08wDQYJKoZIhvcNAQEMBQADggIBALth
2X2pbL4XxJEbw6GiAI3jZGgPVs93rnD5/ZpKmbnJeFwMDF/k5hQpVgs2SV1EY+CtnJYYZhsj
DT156W1r1lT40jzBQ0CuHVD1UvyQO7uYmWlrx8GnqGikJ9yd+SeuMIW59mdNOj6PWTkiU0Tr
yF0Dyu1Qen1iIQqAyHNm0aAFYF/opbSnr6j3bTWcfFqK1qI4mfN4i/RN0iAL3gTujJtHgXIN
wBQy7zBZLq7gcfJW5GqXb5JQbZaNaHqasjYUegbyJLkJEVDXCLG4iXqEI2FCKeWjzaIgQdfR
nGTZ6iahixTXTBmyUEFxPT9NcCOGDErcgdLMMpSEDQgJlxxPwO5rIHQw0uA5NBCFIRUBCOhV
Mt5xSdkoF1BN5r5N0XWs0Mr7QbhDparTwwVETyw2m+L64kW4I1NsBm9nVX9GtUw/bihaeSbS
pKhil9Ie4u1Ki7wb/UdKDd9nZn6yW0HQO+T0O/QEY+nvwlQAUaCKKsnOeMzV6ocEGLPOr0mI
r/OSmbaz5mEP0oUA51Aa5BuVnRmhuZyxm7EAHu/QD09CbMkKvO5D+jpxpchNJqU1/YldvIVi
HTLSoCtU7ZpXwdv6EM8Zt4tKG48BtieVU+i2iW1bvGjUI+iLUaJW+fCmgKDWHrO8Dw9TdSmq
6hN35N6MgSGtBxBHEa2HPQfRdbzP82Z+
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFdjCCA16gAwIBAgIQXmjWEXGUY1BWAGjzPsnFkTANBgkqhkiG9w0BAQUFADBVMQswCQYD
VQQGEwJDTjEaMBgGA1UEChMRV29TaWduIENBIExpbWl0ZWQxKjAoBgNVBAMTIUNlcnRpZmlj
YXRpb24gQXV0aG9yaXR5IG9mIFdvU2lnbjAeFw0wOTA4MDgwMTAwMDFaFw0zOTA4MDgwMTAw
MDFaMFUxCzAJBgNVBAYTAkNOMRowGAYDVQQKExFXb1NpZ24gQ0EgTGltaXRlZDEqMCgGA1UE
AxMhQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgb2YgV29TaWduMIICIjANBgkqhkiG9w0BAQEF
AAOCAg8AMIICCgKCAgEAvcqNrLiRFVaXe2tcesLea9mhsMMQI/qnobLMMfo+2aYpbxY94Gv4
uEBf2zmoAHqLoE1UfcIiePyOCbiohdfMlZdLdNiefvAA5A6JrkkoRBoQmTIPJYhTpA2zDxII
FgsDcSccf+Hb0v1naMQFXQoOXXDX2JegvFNBmpGN9J42Znp+VsGQX+axaCA2pIwkLCxHC1l2
ZjC1vt7tj/id07sBMOby8w7gLJKA84X5KIq0VC6a7fd2/BVoFutKbOsuEo/Uz/4Mx1wdC34F
Mr5esAkqQtXJTpCzWQ27en7N1QhatH/YHGkR+ScPewavVIMYe+HdVHpRaG53/Ma/UkpmRqGy
Zxq7o093oL5d//xWC0Nyd5DKnvnyOfUNqfTq1+ezEC8wQjchzDBwyYaYD8xYTYO7feUapTeN
tqwylwA6Y3EkHp43xP901DfA4v6IRmAR3Qg/UDaruHqklWJqbrDKaiFaafPz+x1wOZXzp26m
gYmhiMU7ccqjUu6Du/2gd/Tkb+dC221KmYo0SLwX3OSACCK28jHAPwQ+658geda4BmRkAjHX
qc1S+4RFaQkAKtxVi8QGRkvASh0JWzko/amrzgD5LkhLJuYwTKVYyrREgk/nkR4zw7CT/xH8
gdLKH3Ep3XZPkiWvHYG3Dy+MwwbMLyejSuQOmbp8HkUff6oZRZb9/D0CAwEAAaNCMEAwDgYD
VR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFOFmzw7R8bNLtwYgFP6H
EtX2/vs+MA0GCSqGSIb3DQEBBQUAA4ICAQCoy3JAsnbBfnv8rWTjMnvMPLZdRtP1LOJwXcgu
2AZ9mNELIaCJWSQBnfmvCX0KI4I01fx8cpm5o9dU9OpScA7F9dY74ToJMuYhOZO9sxXqT2r0
9Ys/L3yNWC7F4TmgPsc9SnOeQHrAK2GpZ8nzJLmzbVUsWh2eJXLOC62qx1ViC777Y7NhRCOj
y+EaDveaBk3e1CNOIZZbOVtXHS9dCF4Jef98l7VNg64N1uajeeAz0JmWAjCnPv/So0M/BVoG
6kQC2nz4SNAzqfkHx5Xh9T71XXG68pWpdIhhWeO/yloTunK0jF02h+mmxTwTv97QRCbut+wu
cPrXnbes5cVAWubXbHssw1abR80LzvobtCHXt2a49CUwi1wNuepnsvRtrtWhnk/Yn+knArAd
BtaP4/tIEp9/EaEQPkxROpaw0RPxx9gmrjrKkcRpnd8BKWRRb2jaFOwIQZeQjdCygPLPwj2/
kWjFgGcexGATVdVhmVd8upUPYUk6ynW8yQqTP2cOEvIo4jEbwFcW3wh8GcF+Dx+FHgo2fFt+
J7x6v+Db9NpSvd4MVHAxkUOVyLzwPt0JfjBkUO1/AaQzZ01oT74V77D2AhGiGxMlOtzCWfHj
XEa7ZywCRuoeSKbmW9m1vFGikpbbqsY3Iqb+zCB0oy2pLmvLwIIRIbWTee5Ehr7XHuQe+w==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFWDCCA0CgAwIBAgIQUHBrzdgT/BtOOzNy0hFIjTANBgkqhkiG9w0BAQsFADBGMQswCQYD
VQQGEwJDTjEaMBgGA1UEChMRV29TaWduIENBIExpbWl0ZWQxGzAZBgNVBAMMEkNBIOayg+mA
muagueivgeS5pjAeFw0wOTA4MDgwMTAwMDFaFw0zOTA4MDgwMTAwMDFaMEYxCzAJBgNVBAYT
AkNOMRowGAYDVQQKExFXb1NpZ24gQ0EgTGltaXRlZDEbMBkGA1UEAwwSQ0Eg5rKD6YCa5qC5
6K+B5LmmMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEA0EkhHiX8h8EqwqzbdoYG
TufQdDTc7WU1/FDWiD+k8H/rD195L4mx/bxjWDeTmzj4t1up+thxx7S8gJeNbEvxUNUqKaqo
GXqW5pWOdO2XCld19AXbbQs5uQF/qvbW2mzmBeCkTVL829B0txGMe41P/4eDrv8FAxNXUDf+
jJZSEExfv5RxadmWPgxDT74wwJ85dE8GRV2j1lY5aAfMh09Qd5Nx2UQIsYo06Yms25tO4dnk
UkWMLhQfkWsZHWgpLFbE4h4TV2TwYeO5Ed+w4VegG63XX9Gv2ystP9Bojg/qnw+LNVgbExz0
3jWhCl3W6t8Sb8D7aQdGctyB9gQjF+BNdeFyb7Ao65vh4YOhn0pdr8yb+gIgthhid5E7o9Vl
rdx8kHccREGkSovrlXLp9glk3Kgtn3R46MGiCWOc76DbT52VqyBPt7D3h1ymoOQ3OMdc4zUP
LK2jgKLsLl3Az+2LBcLmc272idX10kaO6m1jGx6KyX2m+Jzr5dVjhU1zZmkR/sgO9MHHZklT
fuQZa/HpelmjbX7FF+Ynxu8b22/8DU0GAbQOXDBGVWCvOGU6yke6rCzMRh+yRpY/8+0mBe53
oWprfi1tWFxK1I5nuPHa1UaKJ/kR8slC/k7e3x9cxKSGhxYzoacXGKUN5AXlK8IrC6KVkLn9
YDxOiT7nnO4fuwECAwEAAaNCMEAwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8w
HQYDVR0OBBYEFOBNv9ybQV0T6GTwp+kVpOGBwboxMA0GCSqGSIb3DQEBCwUAA4ICAQBqinA4
WbbaixjIvirTthnVZil6Xc1bL3McJk6jfW+rtylNpumlEYOnOXOvEESS5iVdT2H6yAa+Tkvv
/vMx/sZ8cApBWNromUuWyXi8mHwCKe0JgOYKOoICKuLJL8hWGSbueBwj/feTZU7n85iYr83d
2Z5AiDEoOqsuC7CsDCT6eiaY8xJhEPRdF/d+4niXVOKM6Cm6jBAyvd0zaziGfjk9DgNyp115
j0WKWa5bIW4xRtVZjc8VX90xJc/bYNaBRHIpAlf2ltTW/+op2znFuCyKGo3Oy+dCMYYFaA6e
FN0AkLppRQjbbpCBhqcqBT/mhDn4t/lXX0ykeVoQDF7Va/81XwVRHmyjdanPUIPTfPRm94KN
PQx96N97qA4bLJyuQHCH2u2nFoJavjVsIE4iYdm8UXrNemHcSxH5/mc0zy4EZmFcV5cjjPOG
G0jfKq+nwf/Yjj4Du9gqsPoUJbJRa4ZDhS4HIxaAjUz7tGM7zMN07RujHv41D198HRaG9Q7D
lfEvr10lO1Hm13ZBONFLAzkopR6RctR9q5czxNM+4Gm2KHmgCY0c0f9BckgG/Jou5yD5m6Le
ie2uPAmvylezkolwQOQvT8Jwg0DXJCxr5wkf09XHwQj02w47HAcLQxGEIYbpgNR12KvxAmLB
sX5VYc8T1yaw15zLKYs4SgsOkI26oQ==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF2DCCA8CgAwIBAgIQTKr5yttjb+Af907YWwOGnTANBgkqhkiG9w0BAQwFADCBhTELMAkG
A1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9y
ZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBSU0EgQ2Vy
dGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMTE5MDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCB
hTELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMH
U2FsZm9yZDEaMBgGA1UEChMRQ09NT0RPIENBIExpbWl0ZWQxKzApBgNVBAMTIkNPTU9ETyBS
U0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
AoICAQCR6FSS0gpWsawNJN3Fz0RndJkrN6N9I3AAcbxT38T6KhKPS38QVr2fcHK3YX/JSw8X
pz3jsARh7v8Rl8f0hj4K+j5c+ZPmNHrZFGvnnLOFoIJ6dq9xkNfs/Q36nGz637CC9BR++b7E
pi9Pf5l/tfxnQ3K9DADWietrLNPtj5gcFKt+5eNu/Nio5JIk2kNrYrhV/erBvGy2i/MOjZrk
m2xpmfh4SDBF1a3hDTxFYPwyllEnvGfDyi62a+pGx8cgoLEfZd5ICLqkTqnyg0Y3hOvozIFI
Q2dOciqbXL1MGyiKXCJ7tKuY2e7gUYPDCUZObT6Z+pUX2nwzV0E8jVHtC7ZcryxjGt9XyD+8
6V3Em69FmeKjWiS0uqlWPc9vqv9JWL7wqP/0uK3pN/u6uPQLOvnoQ0IeidiEyxPx2bvhiWC4
jChWrBQdnArncevPDt09qZahSL0896+1DSJMwBGB7FY79tOi4lu3sgQiUpWAk2nojkxl8ZED
LXB0AuqLZxUpaVICu9ffUGpVRr+goyhhf3DQw6KqLCGqR84onAZFdr+CGCe01a60y1Dma/RM
hnEw6abfFobg2P9A3fvQQoh/ozM6LlweQRGBY84YcWsr7KaKtzFcOmpH4MN5WdYgGq/yapiq
crxXStJLnbsQ/LBMQeXtHT1eKJ2czL+zUdqnR+WEUwIDAQABo0IwQDAdBgNVHQ4EFgQUu69+
Aj36pvE8hI6t7jiY7NkyMtQwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJ
KoZIhvcNAQEMBQADggIBAArx1UaEt65Ru2yyTUEUAJNMnMvlwFTPoCWOAvn9sKIN9SCYPBMt
rFaisNZ+EZLpLrqeLppysb0ZRGxhNaKatBYSaVqM4dc+pBroLwP0rmEdEBsqpIt6xf4FpuHA
1sj+nq6PK7o9mfjYcwlYRm6mnPTXJ9OV2jeDchzTc+CiR5kDOF3VSXkAKRzH7JsgHAckaVd4
sjn8OoSgtZx8jb8uk2IntznaFxiuvTwJaP+EmzzV1gsD41eeFPfR60/IvYcjt7ZJQ3mFXLrr
kguhxuhoqEwWsRqZCuhTLJK7oQkYdQxlqHvLI7cawiiFwxv/0Cti76R7CZGYZ4wUAc1oBmpj
IXUDgIiKboHGhfKppC3n9KUkEEeDys30jXlYsQab5xoq2Z0B15R97QNKyvDb6KkBPvVWmcke
jkk9u+UJueBPSZI9FoJAzMxZxuY67RIuaTxslbH9qh17f4a+Hg4yRvv7E491f0yLS0Zj/gA0
QHDBw7mh3aZw4gSzQbzpgJHqZJx64SIDqZxubw5lT2yHh17zbqD5daWbQOhTsiedSrnAdyGN
/4fy3ryM7xfft0kL0fJuMAsaDk527RH89elWsn2/x20Kk4yl0MC2Hb46TpSi125sC8KKfPog
88Tk5c0NqMuRkrF8hey1FGlmDoLnzc7ILaZRfyHBNVOFBkpdn627G190
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF3jCCA8agAwIBAgIQAf1tMPyjylGoG7xkDjUDLTANBgkqhkiG9w0BAQwFADCBiDELMAkG
A1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4w
HAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBSU0Eg
Q2VydGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMjAxMDAwMDAwWhcNMzgwMTE4MjM1OTU5
WjCBiDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNl
eSBDaXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJU
cnVzdCBSU0EgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4IC
DwAwggIKAoICAQCAEmUXNg7D2wiz0KxXDXbtzSfTTK1Qg2HiqiBNCS1kCdzOiZ/MPans9s/B
3PHTsdZ7NygRK0faOca8Ohm0X6a9fZ2jY0K2dvKpOyuR+OJv0OwWIJAJPuLodMkYtJHUYmTb
f6MG8YgYapAiPLz+E/CHFHv25B+O1ORRxhFnRghRy4YUVD+8M/5+bJz/Fp0YvVGONaanZshy
Z9shZrHUm3gDwFA66Mzw3LyeTP6vBZY1H1dat//O+T23LLb2VN3I5xI6Ta5MirdcmrS3ID3K
fyI0rn47aGYBROcBTkZTmzNg95S+UzeQc0PzMsNT79uq/nROacdrjGCT3sTHDN/hMq7MkztR
eJVni+49Vv4M0GkPGw/zJSZrM233bkf6c0Plfg6lZrEpfDKEY1WJxA3Bk1QwGROs0303p+td
Omw1XNtB1xLaqUkL39iAigmTYo61Zs8liM2EuLE/pDkP2QKe6xJMlXzzawWpXhaDzLhn4ugT
ncxbgtNMs+1b/97lc6wjOy0AvzVVdAlJ2ElYGn+SNuZRkg7zJn0cTRe8yexDJtC/QV9AqURE
9JnnV4eeUB9XVKg+/XRjL7FQZQnmWEIuQxpMtPAlR1n6BB6T1CZGSlCBst6+eLf8ZxXhyVeE
Hg9j1uliutZfVS7qXMYoCAQlObgOK6nyTJccBz8NUvXt7y+CDwIDAQABo0IwQDAdBgNVHQ4E
FgQUU3m/WqorSs9UgOHYm8Cd8rIDZsswDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMB
Af8wDQYJKoZIhvcNAQEMBQADggIBAFzUfA3P9wF9QZllDHPFUp/L+M+ZBn8b2kMVn54CVVeW
FPFSPCeHlCjtHzoBN6J2/FNQwISbxmtOuowhT6KOVWKR82kV2LyI48SqC/3vqOlLVSoGIG1V
eCkZ7l8wXEskEVX/JJpuXior7gtNn3/3ATiUFJVDBwn7YKnuHKsSjKCaXqeYalltiz8I+8jR
Ra8YFWSQEg9zKC7F4iRO/Fjs8PRF/iKz6y+O0tlFYQXBl2+odnKPi4w2r78NBc5xjeambx9s
pnFixdjQg3IM8WcRiQycE0xyNN+81XHfqnHd4blsjDwSXWXavVcStkNr/+XeTWYRUc+ZruwX
tuhxkYzeSf7dNXGiFSeUHM9h4ya7b6NnJSFd5t0dCy5oGzuCr+yDZ4XUmFF0sbmZgIn/f3gZ
XHlKYC6SQK5MNyosycdiyA5d9zZbyuAlJQG03RoHnHcAP9Dc1ew91Pq7P8yF1m9/qS3fuQL3
9ZeatTXaw2ewh0qpKJ4jjv9cJ2vhsE/zB+4ALtRZh8tSQZXq9EfX7mRBVXyNWQKV3WKdwrnu
Wih0hKWbt5DHDAff9Yk2dDLWKMGwsAvgnEzDHNb842m1R0aBL6KCq9NjRHDEjf8tM7qtj3u1
cIiuPhnPQCjY/MiQu12ZIvVS5ljFH4gxQ+6IHdfGjjxDah2nGN59PRbxYvnKkKj9
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICjzCCAhWgAwIBAgIQXIuZxVqUxdJxVt7NiYDMJjAKBggqhkjOPQQDAzCBiDELMAkGA1UE
BhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBDaXR5MR4wHAYD
VQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVzdCBFQ0MgQ2Vy
dGlmaWNhdGlvbiBBdXRob3JpdHkwHhcNMTAwMjAxMDAwMDAwWhcNMzgwMTE4MjM1OTU5WjCB
iDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCk5ldyBKZXJzZXkxFDASBgNVBAcTC0plcnNleSBD
aXR5MR4wHAYDVQQKExVUaGUgVVNFUlRSVVNUIE5ldHdvcmsxLjAsBgNVBAMTJVVTRVJUcnVz
dCBFQ0MgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAQa
rFRaqfloI+d61SRvU8Za2EurxtW20eZzca7dnNYMYf3boIkDuAUU7FfO7l0/4iGzzvfUinng
o4N+LZfQYcTxmdwlkWOrfzCjtHDix6EznPO/LlxTsV+zfTJ/ijTjeXmjQjBAMB0GA1UdDgQW
BBQ64QmG1M8ZwpZ2dEl23OA1xmNjmjAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB
/zAKBggqhkjOPQQDAwNoADBlAjA2Z6EWCNzklwBBHU6+4WMBzzuqQhFkoJ2UOQIReVx7Hfpk
ue4WQrO/isIJxOzksU0CMQDpKmFHjFJKS04YcPbWRNZu9YO6bVi9JNlWSOrvxKJGgYhqOkbR
qZtNyWHa0V1Xahg=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIB4TCCAYegAwIBAgIRKjikHJYKBN5CsiilC+g0mAIwCgYIKoZIzj0EAwIwUDEkMCIGA1UE
CxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI0MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMw
EQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoXDTM4MDExOTAzMTQwN1owUDEk
MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI0MRMwEQYDVQQKEwpHbG9iYWxT
aWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEuMZ5
049sJQ6fLjkZHAOkrprlOQcJFspjsbmG+IpXwVfOQvpzofdlQv8ewQCybnMO/8ch5Rikqtlx
P6jUuc6MHaNCMEAwDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYE
FFSwe61FuOJAf/sKbvu+M8k8o4TVMAoGCCqGSM49BAMCA0gAMEUCIQDckqGgE6bPA7DmxCGX
kPoUVy0D7O48027KqGx2vKLeuwIgJ6iFJzWbVsaj8kfSt24bAgAXqmemFZHe+pTsewv4n4Q=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICHjCCAaSgAwIBAgIRYFlJ4CYuu1X5CneKcflK2GwwCgYIKoZIzj0EAwMwUDEkMCIGA1UE
CxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI1MRMwEQYDVQQKEwpHbG9iYWxTaWduMRMw
EQYDVQQDEwpHbG9iYWxTaWduMB4XDTEyMTExMzAwMDAwMFoXDTM4MDExOTAzMTQwN1owUDEk
MCIGA1UECxMbR2xvYmFsU2lnbiBFQ0MgUm9vdCBDQSAtIFI1MRMwEQYDVQQKEwpHbG9iYWxT
aWduMRMwEQYDVQQDEwpHbG9iYWxTaWduMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAER0UOlvt9
Xb/pOdEh+J8LttV7HpI6SFkc8GIxLcB6KP4ap1yztsyX50XUWPrRd21DosCHZTQKH3rd6zwz
ocWdTaRvQZU4f8kehOvRnkmSh5SHDDqFSmafnVmTTZdhBoZKo0IwQDAOBgNVHQ8BAf8EBAMC
AQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUPeYpSJvqB8ohREom3m7e0oPQn1kwCgYI
KoZIzj0EAwMDaAAwZQIxAOVpEslu28YxuglB4Zf4+/2a4n0Sye18ZNPLBSWLVtmg515dTguD
nFt2KaAJJiFqYgIwcdK1j1zqO+F4CYWodZI7yFz9SO8NdCKoCOJuxUnOxwy8p2Fp8fc74SrL
+SvzZpA3
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFdDCCA1ygAwIBAgIEAJiiOTANBgkqhkiG9w0BAQsFADBaMQswCQYDVQQGEwJOTDEeMBwG
A1UECgwVU3RhYXQgZGVyIE5lZGVybGFuZGVuMSswKQYDVQQDDCJTdGFhdCBkZXIgTmVkZXJs
YW5kZW4gUm9vdCBDQSAtIEczMB4XDTEzMTExNDExMjg0MloXDTI4MTExMzIzMDAwMFowWjEL
MAkGA1UEBhMCTkwxHjAcBgNVBAoMFVN0YWF0IGRlciBOZWRlcmxhbmRlbjErMCkGA1UEAwwi
U3RhYXQgZGVyIE5lZGVybGFuZGVuIFJvb3QgQ0EgLSBHMzCCAiIwDQYJKoZIhvcNAQEBBQAD
ggIPADCCAgoCggIBAL4yolQPcPssXFnrbMSkUeiFKrPMSjTysF/zDsccPVMeiAho2G89rcKe
zIJnByeHaHE6n3WWIkYFsO2tx1ueKt6c/DrGlaf1F2cY5y9JCAxcz+bMNO14+1Cx3Gsy8KL+
tjzk7FqXxz8ecAgwoNzFs21v0IJyEavSgWhZghe3eJJg+szeP4TrjTgzkApyI/o1zCZxMdFy
KJLZWyNtZrVtB0LrpjPOktvA9mxjeM3KTj215VKb8b475lRgsGYeCasH/lSJEULR9yS6YHga
mPfJEf0WwTUaVHXvQ9Plrk7O53vDxk5hUUurmkVLoR9BvUhTFXFkC4az5S6+zqQbwSmEorXL
CCN2QyIkHxcE1G6cxvx/K2Ya7Irl1s9N9WMJtxU51nus6+N86U78dULI7ViVDAZCopz35HCz
33JvWjdAidiFpNfxC95DGdRKWCyMijmev4SH8RY7Ngzp07TKbBlBUgmhHbBqv4LvcFEhMtwF
dozL92TkA1CvjJFnq8Xy7ljY3r735zHPbMk7ccHViLVlvMDoFxcHErVc0qsgk7TmgoNwNsXN
o42ti+yjwUOH5kPiNL6VizXtBznaqB16nzaeErAMZRKQFWDZJkBE41ZgpRDUajz9QdwOWke2
75dhdU/Z/seyHdTtXUmzqWrLZoQT1Vyg3N9udwbRcXXIV2+vD3dbAgMBAAGjQjBAMA8GA1Ud
EwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBRUrfrHkleuyjWcLhL75Lpd
INyUVzANBgkqhkiG9w0BAQsFAAOCAgEAMJmdBTLIXg47mAE6iqTnB/d6+Oea31BDU5cqPco8
R5gu4RV78ZLzYdqQJRZlwJ9UXQ4DO1t3ApyEtg2YXzTdO2PCwyiBwpwpLiniyMMB8jPqKqrM
CQj3ZWfGzd/TtiunvczRDnBfuCPRy5FOCvTIeuXZYzbB1N/8Ipf3YF3qKS9Ysr1YvY2WTxB1
v0h7PVGHoTx0IsL8B3+A3MSs/mrBcDCw6Y5p4ixpgZQJut3+TcCDjJRYwEYgr5wfAvg1VUkv
RtTA8KCWAg8zxXHzniN9lLf9OtMJgwYh/WA9rjLA0u6NpvDntIJ8CsxwyXmA+P5M9zWEGYox
+wrZ13+b8KKaa8MFSu1BYBQw0aoRQm7TIwIEC8Zl3d1Sd9qBa7Ko+gE4uZbqKmxnl4mUnrzh
VNXkanjvSr0rmj1AfsbAddJu+2gw7OyLnflJNZoaLNmzlTnVHpL3prllL+U9bTpITAjc5CgS
KL59NVzq4BZ+Extq1z7XnvwtdbLBFNUjA9tbbws+eC8N3jONFrdI54OagQ97wUNNVQQXOEpR
1VmiiXTTn74eS9fGbbeIJG9gkaSChVtWQbzQRKtqE77RLFi3EjNYsjdj3BP1lB0/QFH1T/U6
7cjF68IeHRaVesd+QnGTbksVtzDfqu1XhUisHWrdOWnk4Xl4vs4Fv6EM94B7IWcnMFk=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFcDCCA1igAwIBAgIEAJiWjTANBgkqhkiG9w0BAQsFADBYMQswCQYDVQQGEwJOTDEeMBwG
A1UECgwVU3RhYXQgZGVyIE5lZGVybGFuZGVuMSkwJwYDVQQDDCBTdGFhdCBkZXIgTmVkZXJs
YW5kZW4gRVYgUm9vdCBDQTAeFw0xMDEyMDgxMTE5MjlaFw0yMjEyMDgxMTEwMjhaMFgxCzAJ
BgNVBAYTAk5MMR4wHAYDVQQKDBVTdGFhdCBkZXIgTmVkZXJsYW5kZW4xKTAnBgNVBAMMIFN0
YWF0IGRlciBOZWRlcmxhbmRlbiBFViBSb290IENBMIICIjANBgkqhkiG9w0BAQEFAAOCAg8A
MIICCgKCAgEA48d+ifkkSzrSM4M1LGns3Amk41GoJSt5uAg94JG6hIXGhaTK5skuU6TJJB79
VWZxXSzFYGgEt9nCUiY4iKTWO0Cmws0/zZiTs1QUWJZV1VD+hq2kY39ch/aO5ieSZxeSAgMs
3NZmdO3dZ//BYY1jTw+bbRcwJu+r0h8QoPnFfxZpgQNH7R5ojXKhTbImxrpsX23Wr9GxE46p
rfNeaXUmGD5BKyF/7otdBwadQ8QpCiv8Kj6GyzyDOvnJDdrFmeK8eEEzduG/L13lpJhQDBXd
4Pqcfzho0LKmeqfRMb1+ilgnQ7O6M5HTp5gVXJrm0w912fxBmJc+qiXbj5IusHsMX/FjqTf5
m3VpTCgmJdrV8hJwRVXj33NeN/UhbJCONVrJ0yPr08C+eKxCKFhmpUZtcALXEPlLVPxdhkqH
z3/KRawRWrUgUY0viEeXOcDPusBCAUCZSCELa6fS/ZbV0b5GnUngC6agIk440ME8MLxwjyx1
zNDFjFE7PZQIZCZhfbnDZY8UnCHQqv0XcgOPvZuM5l5Tnrmd74K74bzickFbIZTTRTeU0d8J
OV3nI6qaHcptqAqGhYqCvkIH1vI4gnPah1vlPNOePqc7nvQDs/nxfRN0Av+7oeX6AHkcpmZB
iFxgV6YuCcS6/ZrPpx9Aw7vMWgpVSzs4dlG4Y4uElBbmVvMCAwEAAaNCMEAwDwYDVR0TAQH/
BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYEFP6rAJCYniT8qcwaivsnuL8wbqg7
MA0GCSqGSIb3DQEBCwUAA4ICAQDPdyxuVr5Os7aEAJSrR8kN0nbHhp8dB9O2tLsIeK9p0gtJ
3jPFrK3CiAJ9Brc1AsFgyb/E6JTe1NOpEyVa/m6irn0F3H3zbPB+po3u2dfOWBfoqSmuc0iH
55vKbimhZF8ZE/euBhD/UcabTVUlT5OZEAFTdfETzsemQUHSv4ilf0X8rLiltTMMgsT7B/Zq
5SWEXwbKwYY5EdtYzXc7LMJMD16a4/CrPmEbUCTCwPTxGfARKbalGAKb12NMcIxHowNDXLld
RqANb/9Zjr7dn3LDWyvfjFvO5QxGbJKyCqNMVEIYFRIYvdr8unRu/8G2oGTYqV9Vrp9canaW
2HNnh/tNf1zuacpzEPuKqf2evTY4SUmH9A4U8OmHuD+nT3pajnnUk+S7aFKErGzp85hwVXIy
+TSrK0m1zSBi5Dp6Z2Orltxtrpfs/J92VoguZs9btsmksNcFuuEnL5O7Jiqik7Ab846+HUCj
uTaPPoIaGl6I6lD4WeKDRikL40Rc4ZW2aZCaFG+XroHPaO+Zmr615+F/+PoTRxZMzG0IQOeL
eG9QgkRQP2YGiqtDhFZKDyAthg710tvSeopLzaXoTvFeJiUBWSOgftL2fiFX1ye8FVdMpEbB
4IMeDExNH08GGeL5qPQ6gqGyeUN51q1veieQA6TqJIc/2b3Z6fJfUEkc7uzXLg==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFYDCCA0igAwIBAgIQCgFCgAAAAUUjyES1AAAAAjANBgkqhkiG9w0BAQsFADBKMQswCQYD
VQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MScwJQYDVQQDEx5JZGVuVHJ1c3QgQ29tbWVy
Y2lhbCBSb290IENBIDEwHhcNMTQwMTE2MTgxMjIzWhcNMzQwMTE2MTgxMjIzWjBKMQswCQYD
VQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MScwJQYDVQQDEx5JZGVuVHJ1c3QgQ29tbWVy
Y2lhbCBSb290IENBIDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCnUBneP5k9
1DNG8W9RYYKyqU+PZ4ldhNlT3Qwo2dfw/66VQ3KZ+bVdfIrBQuExUHTRgQ18zZshq0PirK1e
hm7zCYofWjK9ouuU+ehcCuz/mNKvcbO0U59Oh++SvL3sTzIwiEsXXlfEU8L2ApeN2WIrvyQf
Yo3fw7gpS0l4PJNgiCL8mdo2yMKi1CxUAGc1bnO/AljwpN3lsKImesrgNqUZFvX9t++uP0D1
bVoE/c40yiTcdCMbXTMTEl3EASX2MN0CXZ/g1Ue9tOsbobtJSdifWwLziuQkkORiT0/Br4sO
dBeo0XKIanoBScy0RnnGF7HamB4HWfp1IYVl3ZBWzvurpWCdxJ35UrCLvYf5jysjCiN2O/cz
4ckA82n5S6LgTrx+kzmEB/dEcH7+B1rlsazRGMzyNeVJSQjKVsk9+w8YfYs7wRPCTY/JTw43
6R+hDmrfYi7LNQZReSzIJTj0+kuniVyc0uMNOYZKdHzVWYfCP04MXFL0PfdSgvHqo6z9STQa
KPNBiDoT7uje/5kdX7rL6B7yuVBgwDHTc+XvvqDtMwt0viAgxGds8AgDelWAf0ZOlqf0Hj7h
9tgJ4TNkK2PXMl6f+cB7D3hvl7yTmvmcEpB4eoCHFddydJxVdHixuuFucAS6T6C6aMN7/zHw
cz09lCqxC0EOoP5NiGVreTO01wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/
BAUwAwEB/zAdBgNVHQ4EFgQU7UQZwNPwBovupHu+QucmVMiONnYwDQYJKoZIhvcNAQELBQAD
ggIBAA2ukDL2pkt8RHYZYR4nKM1eVO8lvOMIkPkp165oCOGUAFjvLi5+U1KMtlwH6oi6mYtQ
lNeCgN9hCQCTrQ0U5s7B8jeUeLBfnLOic7iPBZM4zY0+sLj7wM+x8uwtLRvM7Kqas6pgghst
O8OEPVeKlh6cdbjTMM1gCIOQ045U8U1mwF10A0Cj7oV+wh93nAbowacYXVKV7cndJZ5t+qnt
ozo00Fl72u1Q8zW/7esUTTHHYPTa8Yec4kjixsU3+wYQ+nVZZjFHKdp2mhzpgq7vmrlR94gj
mmmVYjzlVYA211QC//G5Xc7UI2/YRYRKW2XviQzdFKcgyxilJbQN+QHwotL0AMh0jqEqSI5l
2xPE4iUXfeu+h1sXIFRRk0pTAwvsXcoz7WL9RccvW9xYoIA55vrX/hMUpu09lEpCdNTDd1lz
zY9GvlU47/rokTLql1gEIt44w8y8bckzOmoKaT+gyOpyj4xjhiO9bTyWnpXgSUyqorkqG5w2
gXjtw+hG4iZZRHUe2XWJUc0QhJ1hYMtd+ZciTY6Y5uN/9lu7rs3KSoFrXgvzUeF0K+l+J6fZ
mUlO+KWA2yUPHGNiiskzZ2s8EIPGrd6ozRaOjfAHN3Gf8qv8QfXBi+wAN10J5U6A7/qxXDgG
pRtK4dw4LTzcqx+QGtVKnO7RcGzM7vRX+Bi6hG6H
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFZjCCA06gAwIBAgIQCgFCgAAAAUUjz0Z8AAAAAjANBgkqhkiG9w0BAQsFADBNMQswCQYD
VQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MSowKAYDVQQDEyFJZGVuVHJ1c3QgUHVibGlj
IFNlY3RvciBSb290IENBIDEwHhcNMTQwMTE2MTc1MzMyWhcNMzQwMTE2MTc1MzMyWjBNMQsw
CQYDVQQGEwJVUzESMBAGA1UEChMJSWRlblRydXN0MSowKAYDVQQDEyFJZGVuVHJ1c3QgUHVi
bGljIFNlY3RvciBSb290IENBIDEwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC2
IpT8pEiv6EdrCvsnduTyP4o7ekosMSqMjbCpwzFrqHd2hCa2rIFCDQjrVVi7evi8ZX3yoG2L
qEfpYnYeEe4IFNGyRBb06tD6Hi9e28tzQa68ALBKK0CyrOE7S8ItneShm+waOh7wCLPQ5CQ1
B5+ctMlSbdsHyo+1W/CD80/HLaXIrcuVIKQxKFdYWuSNG5qrng0M8gozOSI5Cpcu81N3uURF
/YTLNiCBWS2ab21ISGHKTN9T0a9SvESfqy9rg3LvdYDaBjMbXcjaY8ZNzaxmMc3R3j6HEDbh
uaR672BQssvKplbgN6+rNBM5Jeg5ZuSYeqoSmJxZZoY+rfGwyj4GD3vwEUs3oERte8uojHH0
1bWRNszwFcYr3lEXsZdMUD2xlVl8BX0tIdUAvwFnol57plzy9yLxkA2T26pEUWbMfXYD62qo
KjgZl3YNa4ph+bz27nb9cCvdKTz4Ch5bQhyLVi9VGxyhLrXHFub4qjySjmm2AcG1hp2JDws4
lFTo6tyePSW8Uybt1as5qsVATFSrsrTZ2fjXctscvG29ZV/viDUqZi/u9rNl8DONfJhBaUYP
Qxxp+pu10GFqzcpL2UyQRqsVWaFHVCkugyhfHMKiq3IXAAaOReyL4jM9f9oZRORicsPfIsby
VtTdX5Vy7W1f90gDW/3FKqD2cyOEEBsB5wIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYD
VR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQU43HgntinQtnbcZFrlJPrw6PRFKMwDQYJKoZIhvcN
AQELBQADggIBAEf63QqwEZE4rU1d9+UOl1QZgkiHVIyqZJnYWv6IAcVYpZmxI1Qjt2odIFfl
AWJBF9MJ23XLblSQdf4an4EKwt3X9wnQW3IV5B4Jaj0z8yGa5hV+rVHVDRDtfULAj+7AmgjV
QdZcDiFpboBhDhXAuM/FSRJSzL46zNQuOAXeNf0fb7iAaJg9TaDKQGXSc3z1i9kKlT/YPyNt
GtEqJBnZhbMX73huqVjRI9PHE+1yJX9dsXNw0H8GlwmEKYBhHfpe/3OsoOOJuBxxFcbeMX8S
3OFtm6/n6J91eEyrRjuazr8FGF1NFTwWmhlQBJqymm9li1JfPFgEKCXAZmExfrngdbkaqIHW
chezxQMxNRF4eKLg6TCMf4DfWN88uieW4oA0beOY02QnrEh+KHdcxiVhJfiFDGX6xDIvpZgF
5PgLZxYWxoK4Mhn5+bl53B/N66+rDt0b20XkeucC4pVd/GnwU2lhlXV5C15V5jgclKlZM57I
cXR5f1GJtshquDDIajjDbp7hNxbqBWJMWxJH7ae0s1hWx0nzfxJoCTFx8G34Tkf71oXuxVhA
GaQdp/lLQzfcaFpPz+vCZHTetBXZ9FRUGi8c15dxVJCO2SCdUyt/q4/i6jC8UDfv8Ue1fXws
BOxonbRJRBD0ckscZOf85muQ3Wl9af0AVqW3rLatt8o+Ae+c
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEPjCCAyagAwIBAgIESlOMKDANBgkqhkiG9w0BAQsFADCBvjELMAkGA1UEBhMCVVMxFjAU
BgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVzdC5uZXQvbGVn
YWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9y
aXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVzdCBSb290IENlcnRpZmljYXRpb24gQXV0
aG9yaXR5IC0gRzIwHhcNMDkwNzA3MTcyNTU0WhcNMzAxMjA3MTc1NTU0WjCBvjELMAkGA1UE
BhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVz
dC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDA5IEVudHJ1c3QsIEluYy4gLSBm
b3IgYXV0aG9yaXplZCB1c2Ugb25seTEyMDAGA1UEAxMpRW50cnVzdCBSb290IENlcnRpZmlj
YXRpb24gQXV0aG9yaXR5IC0gRzIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC6
hLZy254Ma+KZ6TABp3bqMriVQRrJ2mFOWHLP/vaCeb9zYQYKpSfYs1/TRU4cctZOMvJyig/3
gxnQaoCAAEUesMfnmr8SVycco2gvCoe9amsOXmXzHHfV1IWNcCG0szLni6LVhjkCsbjSR87k
yUnEO6fe+1R9V77w6G7CebI6C1XiUJgWMhNcL3hWwcKUs/Ja5CeanyTXxuzQmyWC48zCxEXF
jJd6BmsqEZ+pCm5IO2/b1BEZQvePB7/1U1+cPvQXLOZprE4yTGJ36rfo5bs0vBmLrpxR57d+
tVOxMyLlbc9wPBr64ptntoP0jaWvYkxN4FisZDQSA/i2jZRjJKRxAgMBAAGjQjBAMA4GA1Ud
DwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRqciZ60B7vfec7aVHUbI2f
kBJmqzANBgkqhkiG9w0BAQsFAAOCAQEAeZ8dlsa2eT8ijYfThwMEYGprmi5ZiXMRrEPR9RP/
jTkrwPK9T3CMqS/qF8QLVJ7UG5aYMzyorWKiAHarWWluBh1+xLlEjZivEtRh2woZRkfz6/dj
wUAFQKXSt/S1mja/qYh2iARVBCuch38aNzx+LaUa2NSJXsq9rD1s2G2v1fN2D807iDginWyT
msQ9v4IbZT+mD12q/OWyFcq1rca8PdCE6OoGcrBNOTJ4vz4RnAuknZoh8/CbCzB428Hch0P+
vGOaysXCHMnHjf87ElgI5rY97HosTvuDls4MPGmHVHOkc8KT/1EQrBVUAdj8BbGJoX90g5pJ
19xOe4pIb4tF9g==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIC+TCCAoCgAwIBAgINAKaLeSkAAAAAUNCR+TAKBggqhkjOPQQDAzCBvzELMAkGA1UEBhMC
VVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1NlZSB3d3cuZW50cnVzdC5u
ZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDEyIEVudHJ1c3QsIEluYy4gLSBmb3Ig
YXV0aG9yaXplZCB1c2Ugb25seTEzMDEGA1UEAxMqRW50cnVzdCBSb290IENlcnRpZmljYXRp
b24gQXV0aG9yaXR5IC0gRUMxMB4XDTEyMTIxODE1MjUzNloXDTM3MTIxODE1NTUzNlowgb8x
CzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3
LmVudHJ1c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxMiBFbnRydXN0LCBJ
bmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMzAxBgNVBAMTKkVudHJ1c3QgUm9vdCBD
ZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEVDMTB2MBAGByqGSM49AgEGBSuBBAAiA2IABIQT
ydC6bUF74mzQ61VfZgIaJPRbiWlH47jCffHyAsWfoPZb1YsGGYZPUxBtByQnoaD41UcZYUx9
ypMn6nQM72+WCf5j7HBdNq1nd67JnXxVRDqiY1Ef9eNi1KlHBz7MIKNCMEAwDgYDVR0PAQH/
BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFLdj5xrdjekIplWDpOBqUEFlEUJJ
MAoGCCqGSM49BAMDA2cAMGQCMGF52OVCR98crlOZF7ZvHH3hvxGU0QOIdeSNiaSKd0bebWHv
AvX7td/M/k7//qnmpwIwW5nXhTcGtXsI/esni0qU+eH6p44mCOh8kmhtc9hvJqwhAriZtyZB
WyVgrtBIGu4G
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFjTCCA3WgAwIBAgIEGErM1jANBgkqhkiG9w0BAQsFADBWMQswCQYDVQQGEwJDTjEwMC4G
A1UECgwnQ2hpbmEgRmluYW5jaWFsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MRUwEwYDVQQD
DAxDRkNBIEVWIFJPT1QwHhcNMTIwODA4MDMwNzAxWhcNMjkxMjMxMDMwNzAxWjBWMQswCQYD
VQQGEwJDTjEwMC4GA1UECgwnQ2hpbmEgRmluYW5jaWFsIENlcnRpZmljYXRpb24gQXV0aG9y
aXR5MRUwEwYDVQQDDAxDRkNBIEVWIFJPT1QwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
AoICAQDXXWvNED8fBVnVBU03sQ7smCuOFR36k0sXgiFxEFLXUWRwFsJVaU2OFW2fvwwbwuCj
Z9YMrM8irq93VCpLTIpTUnrD7i7es3ElweldPe6hL6P3KjzJIx1qqx2hp/Hz7KDVRM8Vz3Iv
HWOX6Jn5/ZOkVIBMUtRSqy5J35DNuF++P96hyk0g1CXohClTt7GIH//62pCfCqktQT+x8Rgp
7hZZLDRJGqgG16iI0gNyejLi6mhNbiyWZXvKWfry4t3uMCz7zEasxGPrb382KzRzEpR/38wm
nvFyXVBlWY9ps4deMm/DGIq1lY+wejfeWkU7xzbh72fROdOXW3NiGUgthxwG+3SYIElz8AXS
G7Ggo7cbcNOIabla1jj0Ytwli3i/+Oh+uFzJlU9fpy25IGvPa931DfSCt/SyZi4QKPaXWnuW
Fo8BGS1sbn85WAZkgwGDg8NNkt0yxoekN+kWzqotaK8KgWU6cMGbrU1tVMoqLUuFG7OA5nBF
DWteNfB/O7ic5ARwiRIlk9oKmSJgamNgTnYGmE69g60dWIolhdLHZR4tjsbftsbhf4oEIRUp
dPA+nJCdDC7xij5aqgwJHsfVPKPtl8MeNPo4+QgO48BdK4PRVmrJtqhUUy54Mmc9gn900Pvh
tgVguXDbjgv5E1hvcWAQUhC5wUEJ73IfZzF4/5YFjQIDAQABo2MwYTAfBgNVHSMEGDAWgBTj
/i39KNALtbq2osS/BqoFjJP7LzAPBgNVHRMBAf8EBTADAQH/MA4GA1UdDwEB/wQEAwIBBjAd
BgNVHQ4EFgQU4/4t/SjQC7W6tqLEvwaqBYyT+y8wDQYJKoZIhvcNAQELBQADggIBACXGumvr
h8vegjmWPfBEp2uEcwPenStPuiB/vHiyz5ewG5zz13ku9Ui20vsXiObTej/tUxPQ4i9qecsA
IyjmHjdXNYmEwnZPNDatZ8POQQaIxffu2Bq41gt/UP+TqhdLjOztUmCypAbqTuv0axn96/Ua
4CUqmtzHQTb3yHQFhDmVOdYLO6Qn+gjYXB74BGBSESgoA//vU2YApUo0FmZ8/Qmkrp5nGm9B
C2sGE5uPhnEFtC+NiWYzKXZUmhH4J/qyP5Hgzg0b8zAarb8iXRvTvyUFTeGSGn+ZnzxEk8rU
QElsgIfXBDrDMlI1Dlb4pd19xIsNER9Tyx6yF7Zod1rg1MvIB671Oi6ON7fQAUtDKXeMOZeP
glr4UeWJoBjnaH9dCi77o0cOPaYjesYBx4/IXr9tgFa+iiS6M+qf4TIRnvHST4D2G0CvOJ4R
UHlzEhLN5mydLIhyPDCBBpEi6lmt2hkuIsKNuYyH4Ga8cyNfIWRjgEj1oDwYPZTISEEdQLpe
/v5WOaHIz16eGWRGENoXkbcFgKyLmZJ956LYBws2J+dIeWCKw9cTXPhyQN9Ky8+ZAAoACxGV
2lZFA4gKn2fQ1XmxqI1AbQ3CekD6819kR5LLU7m7Wc5P/dAVUwHY3+vZ5nbv0CO7O6l5s9UC
Kc2Jo5YPSjXnTkLAdc0Hz+Ys63su
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEJzCCAw+gAwIBAgIHAI4X/iQggTANBgkqhkiG9w0BAQsFADCBsTELMAkGA1UEBhMCVFIx
DzANBgNVBAcMBkFua2FyYTFNMEsGA1UECgxEVMOcUktUUlVTVCBCaWxnaSDEsGxldGnFn2lt
IHZlIEJpbGnFn2ltIEfDvHZlbmxpxJ9pIEhpem1ldGxlcmkgQS7Fni4xQjBABgNVBAMMOVTD
nFJLVFJVU1QgRWxla3Ryb25payBTZXJ0aWZpa2EgSGl6bWV0IFNhxJ9sYXnEsWPEsXPEsSBI
NTAeFw0xMzA0MzAwODA3MDFaFw0yMzA0MjgwODA3MDFaMIGxMQswCQYDVQQGEwJUUjEPMA0G
A1UEBwwGQW5rYXJhMU0wSwYDVQQKDERUw5xSS1RSVVNUIEJpbGdpIMSwbGV0acWfaW0gdmUg
QmlsacWfaW0gR8O8dmVubGnEn2kgSGl6bWV0bGVyaSBBLsWeLjFCMEAGA1UEAww5VMOcUktU
UlVTVCBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sxc8SxIEg1MIIB
IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApCUZ4WWe60ghUEoI5RHwWrom/4NZzkQq
L/7hzmAD/I0Dpe3/a6i6zDQGn1k19uwsu537jVJp45wnEFPzpALFp/kRGml1bsMdi9GYjZOH
p3GXDSHHmflS0yxjXVW86B8BSLlg/kJK9siArs1mep5Fimh34khon6La8eHBEJ/rPCmBp+Ey
CNSgBbGM+42WAA4+Jd9ThiI7/PS98wl+d+yG6w8z5UNP9FR1bSmZLmZaQ9/LXMrI5Tjxfjs1
nQ/0xVqhzPMggCTTV+wVunUlm+hkS7M0hO8EuPbJbKoCPrZV4jI3X/xml1/N1p7HIL9Nxqw/
dV8c7TKcfGkAaZHjIxhT6QIDAQABo0IwQDAdBgNVHQ4EFgQUVpkHHtOsDGlktAxQR95DLL4g
wPswDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB
AJ5FdnsXSDLyOIspve6WSk6BGLFRRyDN0GSxDsnZAdkJzsiZ3GglE9Rc8qPoBP5yCccLqh0l
VX6Wmle3usURehnmp349hQ71+S4pL+f5bFgWV1Al9j4uPqrtd3GqqpmWRgqujuwqURawXs3q
ZwQcWDD1YIq9pr1N5Za0/EKJAWv2cMhQOQwt1WbZyNKzMrcbGW3LM/nfpeYVhDfwwvJllpKQ
d/Ct9JDpEXjXk4nAPQu6KfTomZ1yju2dL+6SfaHx/126M2CFYv4HAqGEVka+lgqaE9chTLd8
B59OTj+RdPsnnRHM3eaxynFNExc5JsUpISuTKWqW+qtB4Uu2NQvAmxU=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIEJjCCAw6gAwIBAgIGfaHyZeyKMA0GCSqGSIb3DQEBCwUAMIGxMQswCQYDVQQGEwJUUjEP
MA0GA1UEBwwGQW5rYXJhMU0wSwYDVQQKDERUw5xSS1RSVVNUIEJpbGdpIMSwbGV0acWfaW0g
dmUgQmlsacWfaW0gR8O8dmVubGnEn2kgSGl6bWV0bGVyaSBBLsWeLjFCMEAGA1UEAww5VMOc
UktUUlVTVCBFbGVrdHJvbmlrIFNlcnRpZmlrYSBIaXptZXQgU2HEn2xhecSxY8Sxc8SxIEg2
MB4XDTEzMTIxODA5MDQxMFoXDTIzMTIxNjA5MDQxMFowgbExCzAJBgNVBAYTAlRSMQ8wDQYD
VQQHDAZBbmthcmExTTBLBgNVBAoMRFTDnFJLVFJVU1QgQmlsZ2kgxLBsZXRpxZ9pbSB2ZSBC
aWxpxZ9pbSBHw7x2ZW5sacSfaSBIaXptZXRsZXJpIEEuxZ4uMUIwQAYDVQQDDDlUw5xSS1RS
VVNUIEVsZWt0cm9uaWsgU2VydGlmaWthIEhpem1ldCBTYcSfbGF5xLFjxLFzxLEgSDYwggEi
MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCdsGjW6L0UlqMACprx9MfMkU1xeHe59yEm
FXNRFpQJRwXiM/VomjX/3EsvMsew7eKC5W/a2uqsxgbPJQ1BgfbBOCK9+bGlprMBvD9QFyv2
6WZV1DOzXPhDIHiTVRZwGTLmiddk671IUP320EEDwnS3/faAz1vFq6TWlRKb55cTMgPp1KtD
WxbtMyJkKbbSk60vbNg9tvYdDjTu0n2pVQ8g9P0pu5FbHH3GQjhtQiht1AH7zYiXSX6484P4
tZgvsycLSF5W506jM7NE1qXyGJTtHB6plVxiSvgNZ1GpryHV+DKdeboaX+UEVU0TRv/yz3TH
GmNtwx8XEsMeED5gCLMxAgMBAAGjQjBAMB0GA1UdDgQWBBTdVRcT9qzoSCHK77Wv0QAy7Z6M
tTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEA
b1gNl0OqFlQ+v6nfkkU/hQu7VtMMUszIv3ZnXuaqs6fvuay0EBQNdH49ba3RfdCaqaXKGDsC
QC4qnFAUi/5XfldcEQlLNkVS9z2sFP1E34uXI9TDwe7UU5X+LEr+DXCqu4svLcsyo4LyVN/Y
8t3XSHLuSqMplsNEzm61kod2pLv0kmzOLBQJZo6NrRa1xxsJYTvjIKIDgI6tflEATseWhvtD
mHd9KMeP2Cpu54Rvl0EpABZeTeIT6lnAY2c6RPuY/ATTMHKm9ocJV612ph1jmv3XZch4gyt1
O6VbuA1df74jrlZVlFjvH4GMKrLN5ptjnhi85WsGtAuYSyher4hYyw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFkjCCA3qgAwIBAgIBATANBgkqhkiG9w0BAQsFADBaMQswCQYDVQQGEwJGUjETMBEGA1UE
ChMKQ2VydGlub21pczEXMBUGA1UECxMOMDAwMiA0MzM5OTg5MDMxHTAbBgNVBAMTFENlcnRp
bm9taXMgLSBSb290IENBMB4XDTEzMTAyMTA5MTcxOFoXDTMzMTAyMTA5MTcxOFowWjELMAkG
A1UEBhMCRlIxEzARBgNVBAoTCkNlcnRpbm9taXMxFzAVBgNVBAsTDjAwMDIgNDMzOTk4OTAz
MR0wGwYDVQQDExRDZXJ0aW5vbWlzIC0gUm9vdCBDQTCCAiIwDQYJKoZIhvcNAQEBBQADggIP
ADCCAgoCggIBANTMCQosP5L2fxSeC5yaah1AMGT9qt8OHgZbn1CF6s2Nq0Nn3rD6foCWnoR4
kkjW4znuzuRZWJflLieY6pOod5tK8O90gC3rMB+12ceAnGInkYjwSond3IjmFPnVAy//ldu9
n+ws+hQVWZUKxkd8aRi5pwP5ynapz8dvtF4F/u7BUrJ1Mofs7SlmO/NKFoL21prbcpjp3vDF
TKWrteoB4owuZH9kb/2jJZOLyKIOSY008B/sWEUuNKqEUL3nskoTuLAPrjhdsKkb5nPJWqHZ
ZkCqqU2mNAKthH6yI8H7KsZn9DS2sJVqM09xRLWtwHkziOC/7aOgFLScCbAK42C++PhmiM1b
8XcF4LVzbsF9Ri6OSyemzTUK/eVNfaoqoynHWmgE6OXWk6RiwsXm9E/G+Z8ajYJJGYrKWUM6
6A0ywfRMEwNvbqY/kXPLynNvEiCL7sCCeN5LLsJJwx3tFvYk9CcbXFcx3FXuqB5vbKziRcxX
V4p1VxngtViZSTYxPDMBbRZKzbgqg4SGm/lg0h9tkQPTYKbVPZrdd5A9NaSfD171UkRpucC6
3M9933zZxKyGIjK8e2uR73r4F2iw4lNVYC2vPsKD2NkJK/DAZNuHi5HMkesE/Xa0lZrmFAYb
1TQdvtj/dBxThZngWVJKYe2InmtJiUZ+IFrZ50rlau7SZRFDAgMBAAGjYzBhMA4GA1UdDwEB
/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBTvkUz1pcMw6C8I6tNxIqSSaHh0
2TAfBgNVHSMEGDAWgBTvkUz1pcMw6C8I6tNxIqSSaHh02TANBgkqhkiG9w0BAQsFAAOCAgEA
fj1U2iJdGlg+O1QnurrMyOMaauo++RLrVl89UM7g6kgmJs95Vn6RHJk/0KGRHCwPT5iVWVO9
0CLYiF2cN/z7ZMF4jIuaYAnq1fohX9B0ZedQxb8uuQsLrbWwF6YSjNRieOpWauwK0kDDPAUw
Pk2Ut59KA9N9J0u2/kTO+hkzGm2kQtHdzMjI1xZSg081lLMSVX3l4kLr5JyTCcBMWwerx20R
oFAXlCOotQqSD7J6wWAsOMwaplv/8gzjqh8c3LigkyfeY+N/IZ865Z764BNqdeuWXGKRlI5n
U7aJ+BIJy29SWwNyhlCVCNSNh4YVH5Uk2KRvms6knZtt0rJ2BobGVgjF6wnaNsIbW0G+YSrj
cOa4pvi2WsS9Iff/ql+hbHY5ZtbqTFXhADObE5hjyW/QASAJN1LnDE8+zbz1X5YnpyACleAu
6AdBBR8Vbtaw5BngDwKTACdyxYvRVB9dSsNAl35VpnzBMwQUAR1JIGkLGZOdblgi90AMRgwj
Y/M50n92Uaf0yKHxDHYiI0ZSKS3io0EHVmmY0gUJvGnHWmHNj4FgFU2A3ZDifcRQ8ow7bkrH
xuaAKzyBvBGAFhAn1/DNP3nMcyrDflOR1m749fPH0FFNjkulW+YZFzvWgQncItzujrnEj1Ph
Z7szuIgVRs/taTX/dQ1G885x4cVrhkIGuUE=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDtTCCAp2gAwIBAgIQdrEgUnTwhYdGs/gjGvbCwDANBgkqhkiG9w0BAQsFADBtMQswCQYD
VQQGEwJDSDEQMA4GA1UEChMHV0lTZUtleTEiMCAGA1UECxMZT0lTVEUgRm91bmRhdGlvbiBF
bmRvcnNlZDEoMCYGA1UEAxMfT0lTVEUgV0lTZUtleSBHbG9iYWwgUm9vdCBHQiBDQTAeFw0x
NDEyMDExNTAwMzJaFw0zOTEyMDExNTEwMzFaMG0xCzAJBgNVBAYTAkNIMRAwDgYDVQQKEwdX
SVNlS2V5MSIwIAYDVQQLExlPSVNURSBGb3VuZGF0aW9uIEVuZG9yc2VkMSgwJgYDVQQDEx9P
SVNURSBXSVNlS2V5IEdsb2JhbCBSb290IEdCIENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEA2Be3HEokKtaXscriHvt9OO+Y9bI5mE4nuBFde9IllIiCFSZqGzG7qFshISvY
D06fWvGxWuR51jIjK+FTzJlFXHtPrby/h0oLS5daqPZI7H17Dc0hBt+eFf1Biki3IPShehtX
1F1Q/7pn2COZH8g/497/b1t3sWtuuMlk9+HKQUYOKXHQuSP8yYFfTvdv37+ErXNku7dCjmn2
1HYdfp2nuFeKUWdy19SouJVUQHMD9ur06/4oQnc/nSMbsrY9gBQHTC5P99UKFg29ZkM3fiND
ecNAhvVMKdqOmq0NpQSHiB6F4+lT1ZvIiwNjeOvgGUpuuy9rM2RYk61pv48b74JIxwIDAQAB
o1EwTzALBgNVHQ8EBAMCAYYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUNQ/INmNe4qPs
+TtmFc5RUuORmj0wEAYJKwYBBAGCNxUBBAMCAQAwDQYJKoZIhvcNAQELBQADggEBAEBM+4ey
mYGQfp3FsLAmzYh7KzKNbrghcViXfa43FK8+5/ea4n32cZiZBKpDdHij40lhPnOMTZTg+XHE
thYOU3gf1qKHLwI5gSk8rxWYITD+KJAAjNHhy/peyP34EEY7onhCkRd0VQreUGdNZtGn//3Z
wLWoo4rOZvUPQ82nK1d7Y0Zqqi5S2PTt4W2tKZB4SLrhI6qjiey1q5bAtEuiHZeeevJuQHHf
aPFlTc58Bd9TZaml8LGXBHAVRgOY1NK/VLSgWH1Sb9pWJmLU2NuJMW8c8CLC02IcNc1MaRVU
GpCY3useX8p3x8uOPUNpnJpY0CQ73xtAln41rYHHTnG6iBM=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDfDCCAmSgAwIBAgIQayXaioidfLwPBbOxemFFRDANBgkqhkiG9w0BAQsFADBYMQswCQYD
VQQGEwJDTjEaMBgGA1UEChMRV29TaWduIENBIExpbWl0ZWQxLTArBgNVBAMTJENlcnRpZmlj
YXRpb24gQXV0aG9yaXR5IG9mIFdvU2lnbiBHMjAeFw0xNDExMDgwMDU4NThaFw00NDExMDgw
MDU4NThaMFgxCzAJBgNVBAYTAkNOMRowGAYDVQQKExFXb1NpZ24gQ0EgTGltaXRlZDEtMCsG
A1UEAxMkQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgb2YgV29TaWduIEcyMIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvsXEoCKASU+/2YcRxlPhuw+9YH+v9oIOH9ywjj2X4FA8
jzrvZjtFB5sg+OPXJYY1kBaiXW8wGQiHC38Gsp1ij96vkqVg1CuAmlI/9ZqD6TRay9nVYlzm
DuDfBpgOgHzKtB0TiGsOqCR3A9DuW/PKaZE1OVbFbeP3PU9ekzgkyhjpJMuSA93MHD0JcOQg
5PGurLtzaaNjOg9FD6FKmsLRY6zLEPg95k4ot+vElbGs/V6r+kHLXZ1L3PR8du9nfwB6jdKg
GlxNIuG12t12s9R23164i5jIFFTMaxeSt+BKv0mUYQs4kI9dJGwlezt52eJ+na2fmKEG/HgU
YFf47oB3sQIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV
HQ4EFgQU+mCp62XF3RYUCE4MD42b4Pdkr2cwDQYJKoZIhvcNAQELBQADggEBAFfDejaCnI2Y
4qtAqkePx6db7XznPWZaOzG73/MWM5H8fHulwqZm46qwtyeYP0nXYGdnPzZPSsvxFPpahygc
7Y9BMsaV+X3avXtbwrAh449G3CE4Q3RM+zD4F3LBMvzIkRfEzFg3TgvMWvchNSiDbGAtROtS
jFA9tWwS1/oJu2yySrHFieT801LYYRf+epSEj3m2M1m6D8QL4nCgS3gu+sif/a+RZQp4OBXl
lxcU3fngLDT4ONCEIgDAFFEYKwLcMFrw6AF8NTojrwjkr6qOKEJJLvD1mTS+7Q9LGOHSJDy7
XUe3IfKN0QqZjuNuPq1w4I+5ysxugTH2e5x6eeRncRg=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIICCTCCAY+gAwIBAgIQaEpYcIBr8I8C+vbe6LCQkDAKBggqhkjOPQQDAzBGMQswCQYDVQQG
EwJDTjEaMBgGA1UEChMRV29TaWduIENBIExpbWl0ZWQxGzAZBgNVBAMTEkNBIFdvU2lnbiBF
Q0MgUm9vdDAeFw0xNDExMDgwMDU4NThaFw00NDExMDgwMDU4NThaMEYxCzAJBgNVBAYTAkNO
MRowGAYDVQQKExFXb1NpZ24gQ0EgTGltaXRlZDEbMBkGA1UEAxMSQ0EgV29TaWduIEVDQyBS
b290MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE4f2OuEMkq5Z7hcK6C62N4DrjJLnSsb6IOsq/
Srj57ywvr1FQPEd1bPiUt5v8KB7FVMxjnRZLU8HnIKvNrCXSf4/CwVqCXjCLelTOA7WRf6qU
0NGKSMyCBSah1VES1ns2o0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAd
BgNVHQ4EFgQUqv3VWqP2h4syhf3RMluARZPzA7gwCgYIKoZIzj0EAwMDaAAwZQIxAOSkhLCB
1T2wdKyUpOgOPQB0TKGXa/kNUTyh2Tv0Daupn75OcsqF1NnstTJFGG+rrQIwfcf3aWMvoeGY
7xMQ0Xk/0f7qO3/eVvSQsRUR2LIiFdAvwyYua/GRspBl9JrmkO5K
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIDcjCCAlqgAwIBAgIUPopdB+xV0jLVt+O2XwHrLdzk1uQwDQYJKoZIhvcNAQELBQAwUTEL
MAkGA1UEBhMCUEwxKDAmBgNVBAoMH0tyYWpvd2EgSXpiYSBSb3psaWN6ZW5pb3dhIFMuQS4x
GDAWBgNVBAMMD1NaQUZJUiBST09UIENBMjAeFw0xNTEwMTkwNzQzMzBaFw0zNTEwMTkwNzQz
MzBaMFExCzAJBgNVBAYTAlBMMSgwJgYDVQQKDB9LcmFqb3dhIEl6YmEgUm96bGljemVuaW93
YSBTLkEuMRgwFgYDVQQDDA9TWkFGSVIgUk9PVCBDQTIwggEiMA0GCSqGSIb3DQEBAQUAA4IB
DwAwggEKAoIBAQC3vD5QqEvNQLXOYeeWyrSh2gwisPq1e3YAd4wLz32ohswmUeQgPYUM1ljj
5/QqGJ3a0a4m7utT3PSQ1hNKDJA8w/Ta0o4NkjrcsbH/ON7Dui1fgLkCvUqdGw+0w8LBZwPd
3BucPbOw3gAeqDRHu5rr/gsUvTaE2g0gv/pby6kWIK05YO4vdbbnl5z5Pv1+TW9NL++IDWr6
3fE9biCloBK0TXC5ztdyO4mTp4CEHCdJckm1/zuVnsHMyAHs6A6KCpbns6aH5db5BSsNl0Bw
PLqsdVqc1U2dAgrSS5tmS0YHF2Wtn2yIANwiieDhZNRnvDF5YTy7ykHNXGoAyDw4jlivAgMB
AAGjQjBAMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgEGMB0GA1UdDgQWBBQuFqlK
GLXLzPVvUPMjX/hd56zwyDANBgkqhkiG9w0BAQsFAAOCAQEAtXP4A9xZWx126aMqe5Aosk3A
M0+qmrHUuOQn/6mWmc5G4G18TKI4pAZw8PRBEew/R40/cof5O/2kbytTAOD/OblqBw7rHRz2
onKQy4I9EYKL0rufKq8h5mOGnXkZ7/e7DDWQw4rtTw/1zBLZpD67oPwglV9PJi8RI4NOdQcP
v5vRtB3pEAT+ymCPoky4rc/hkA/NrgrHXXu3UNLUYfrVFdvXn4dRVOul4+vJhaAlIDf7js4M
NIThPIGyd05DpYhfhmehPea0XGG2Ptv+tyjFogeutcrKjSoS75ftwjCkySp6+/NNIxuZMzSg
LvWpCz/UXeHPhJ/iGcJfitYgHuNztw==
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIF0jCCA7qgAwIBAgIQIdbQSk8lD8kyN/yqXhKN6TANBgkqhkiG9w0BAQ0FADCBgDELMAkG
A1UEBhMCUEwxIjAgBgNVBAoTGVVuaXpldG8gVGVjaG5vbG9naWVzIFMuQS4xJzAlBgNVBAsT
HkNlcnR1bSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTEkMCIGA1UEAxMbQ2VydHVtIFRydXN0
ZWQgTmV0d29yayBDQSAyMCIYDzIwMTExMDA2MDgzOTU2WhgPMjA0NjEwMDYwODM5NTZaMIGA
MQswCQYDVQQGEwJQTDEiMCAGA1UEChMZVW5pemV0byBUZWNobm9sb2dpZXMgUy5BLjEnMCUG
A1UECxMeQ2VydHVtIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MSQwIgYDVQQDExtDZXJ0dW0g
VHJ1c3RlZCBOZXR3b3JrIENBIDIwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC9
+Xj45tWADGSdhhuWZGc/IjoedQF97/tcZ4zJzFxrqZHmuULlIEub2pt7uZld2ZuAS9eEQCsn
0+i6MLs+CRqnSZXvK0AkwpfHp+6bJe+oCgCXhVqqndwpyeI1B+twTUrWwbNWuKFBOJvR+zF/
j+Bf4bE/D44WSWDXBo0Y+aomEKsq09DRZ40bRr5HMNUuctHFY9rnY3lEfktjJImGLjQ/KUxS
iyqnwOKRKIm5wFv5HdnnJ63/mgKXwcZQkpsCLL2puTRZCr+ESv/f/rOf69me4Jgj7KZrdxYq
28ytOxykh9xGc14ZYmhFV+SQgkK7QtbwYeDBoz1mo130GO6IyY0XRSmZMnUCMe4pJshrAua1
YkV/NxVaI2iJ1D7eTiew8EAMvE0Xy02isx7QBlrd9pPPV3WZ9fqGGmd4s7+W/jTcvedSVuWz
5XV710GRBdxdaeOVDUO5/IOWOZV7bIBaTxNyxtd9KXpEulKkKtVBRgkg/iKgtlswjbyJDNXX
cPiHUv3a76xRLgezTv7QCdpw75j6VuZt27VXS9zlLCUVyJ4ueE742pyehizKV/Ma5ciSixqC
lnrDvFASadgOWkaLOusm+iPJtrCBvkIApPjW/jAux9JG9uWOdf3yzLnQh1vMBhBgu4M1t15n
3kfsmUjxpKEV/q2MYo45VU85FrmxY53/twIDAQABo0IwQDAPBgNVHRMBAf8EBTADAQH/MB0G
A1UdDgQWBBS2oVQ5AsOgP46KvPrU+Bym0ToO/TAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcN
AQENBQADggIBAHGlDs7k6b8/ONWJWsQCYftMxRQXLYtPU2sQF/xlhMcQSZDe28cmk4gmb3DW
Al45oPePq5a1pRNcgRRtDoGCERuKTsZPpd1iHkTfCVn0W3cLN+mLIMb4Ck4uWBzrM9DPhmDJ
2vuAL55MYIR4PSFk1vtBHxgP58l1cb29XN40hz5BsA72udY/CROWFC/emh1auVbONTqwX3BN
XuMp8SMoclm2q8KMZiYcdywmdjWLKKdpoPk79SPdhRB0yZADVpHnr7pH1BKXESLjokmUbOe3
lEu6LaTaM4tMpkT/WjzGHWTYtTHkpjx6qFcL2+1hGsvxznN3Y6SHb0xRONbkX8eftoEq5IVI
eVheO/jbAoJnwTnbw3RLPTYe+SmTiGhbqEQZIfCn6IENLOiTNrQ3ssqwGyZ6miUfmpqAnksq
P/ujmv5zMnHCnsZy4YpoJ/HkD7TETKVhk/iXEAcqMCWpuchxuO9ozC1+9eB+D4Kob7a6bIND
d82Kkhehnlt4Fj1F4jNy3eFmypnTycUm/Q1oBEauttmbjL4ZvrHG8hnjXALKLNhvSgfZyTXa
QHXyxKcZb55CEJh15pWLYLztxRLXis7VmFxWlgPF7ncGNf/P5O4/E2Hu29othfDNrp2yGAlF
w5Khchf8R7agCyzxxN5DaAhqXzvwdmP7zAYspsbiDrW5viSP
-----END CERTIFICATE-----
FreeCTXMem
(ca_store_) == (nullptr)
../src/async-wrap-inl.h
CheckWhitelistedServerCert
(chain) != (nullptr)
(sk_num(((_STACK*) (1 ? (chain) : (struct stack_st_X509*)0)))) > (0)
(root_cert) != (nullptr)
Bad input string
AllocateSufficientStorage
../src/util.h
(buf_) != (nullptr)
SetLength
(length) <= (length_)
modp1
modp2
modp5
modp14
modp15
modp16
modp17
modp18
(group_) != (nullptr)
node::PBKDF2Request()
node::RandomBytesRequest()
crypto_lock_cb
!(mode & 1) ^ !(mode & 2)
!(mode & 4) ^ !(mode & 8)
GetPeerCertificate
(cert) != (nullptr)
X509ToObject
(ext) != (nullptr)
(rv) == (1)
0x%lx
0123456789ABCDEF
DNS:
GetSession
(slen) > (0)
SSL_set_session error
UNABLE_TO_GET_ISSUER_CERT
UNABLE_TO_GET_CRL
UNABLE_TO_DECRYPT_CERT_SIGNATURE
UNABLE_TO_DECRYPT_CRL_SIGNATURE
UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY
CERT_SIGNATURE_FAILURE
CRL_SIGNATURE_FAILURE
CERT_NOT_YET_VALID
CERT_HAS_EXPIRED
CRL_NOT_YET_VALID
CRL_HAS_EXPIRED
ERROR_IN_CERT_NOT_BEFORE_FIELD
ERROR_IN_CERT_NOT_AFTER_FIELD
ERROR_IN_CRL_LAST_UPDATE_FIELD
ERROR_IN_CRL_NEXT_UPDATE_FIELD
OUT_OF_MEM
DEPTH_ZERO_SELF_SIGNED_CERT
SELF_SIGNED_CERT_IN_CHAIN
UNABLE_TO_GET_ISSUER_CERT_LOCALLY
UNABLE_TO_VERIFY_LEAF_SIGNATURE
CERT_CHAIN_TOO_LONG
CERT_REVOKED
INVALID_CA
PATH_LENGTH_EXCEEDED
INVALID_PURPOSE
CERT_UNTRUSTED
CERT_REJECTED
CertCbDone
w->is_waiting_cert_cb() && w->cert_cb_running_
Must give a Buffer as first argument
SetMaxSendFragment
args.Length() >= 1 && args[0]->IsNumber()
node.js SSL buffer
Ctrl
../src/node_crypto_bio.cc
0 && "Can't use SET_BUF_MEM_PTR with NodeBIO"
0 && "Can't use GET_BUF_MEM_PTR with NodeBIO"
(read_head_->read_pos_) <= (read_head_->write_pos_)
(expected) == (bytes_read)
FreeEmpty
(cur) != (write_head_)
(cur->write_pos_) == (cur->read_pos_)
IndexOf
(current->read_pos_) <= (current->write_pos_)
(max) == (bytes_read)
(write_head_->write_pos_) <= (write_head_->len_)
(write_head_->write_pos_) == (write_head_->len_)
Commit
Reset
read_head_->write_pos_ > read_head_->read_pos_
(length_) == (0)
FromBIO
../src/node_crypto_bio.h
First argument should be a StreamWrap instance
Second argument should be a SecureContext instance
Third argument should be boolean
../src/tls_wrap.cc
Receive
Already started.
wrap->is_client()
EncOut
write_size_ != 0 && count != 0
EncOutCb
(wrap->ssl_) != (nullptr)
GetSSLError
*err == 1 || *err == 5
(*msg) == (nullptr)
ClearIn
written == -1 || written == static_cast<int>(avail)
(written) >= (0)
DoWrite
(send_handle) == (nullptr)
Write after DestroySSL
written == -1 || written == static_cast<int>(bufs[i].len)
OnAllocSelf
(buf->base) != (nullptr)
DoRead
avail == 0 || data != nullptr
Bad arguments, expected two booleans
SetVerifyMode after destroySSL
EnableSessionCallbacks after destroySSL
Canceled because of SSL destruction
GetServername
SetServername
TLSWrap
receive
setVerifyMode
enableSessionCallbacks
destroySSL
enableCertCb
setServername
../src/base-object-inl.h
(consumed_) == (false)
(bio->ptr) != (nullptr)
GetCurrent
info.Data()->IsExternal()
~ReqWrap
tls_wrap
external memory allocation limit reached.
Unwrap
shutdown
writeBuffer
writeAsciiString
expected argument args[0] to be a connection object
_handle
expected object for _handle.As<Object>() to contain integer member fd
expected object for _conn to contain string member remoteAddress
remoteAddress
expected object for _conn to contain integer member remotePort
remotePort
expected object for _conn to contain integer member bufferSize
bufferSize
expected object for arg0 to contain string member url
expected object for arg0 to contain string member method
expected object for arg0 to contain object member headers
headers
expected object for request to contain string member headers
expected argument args[1] to be a connection object
expected object for arg0 to contain string member _header
_header
expected object for _conn to contain integer member fd
expected object for _conn to contain string member host
expected object for _conn to contain integer member port
DTRACE_NET_SERVER_CONNECTION
DTRACE_NET_STREAM_END
DTRACE_HTTP_SERVER_REQUEST
DTRACE_HTTP_SERVER_RESPONSE
DTRACE_HTTP_CLIENT_REQUEST
DTRACE_HTTP_CLIENT_RESPONSE
ares_destroy
../deps/cares/src/ares_destroy.c
ares__is_list_empty(&(channel->all_queries))
ares__is_list_empty(&(channel->queries_by_qid[i]))
ares__is_list_empty(&(channel->queries_by_timeout[i]))
ares__destroy_servers_state
ares__is_list_empty(&server->queries_to_server)
%lu.%lu.%lu.%lu.in-addr.arpa
%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.
%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa
/etc/hosts
LOCALDOMAIN
RES_OPTIONS
ndots:
retrans:
retry:
rotate
/etc/resolv.conf
search
nameserver
sortlist
options
/etc/nsswitch.conf
hosts:
files
/etc/host.conf
hosts
/etc/svc.conf
hosts=
255.255.255.255
handle_error
../deps/cares/src/ares_process.c
query->server == whichserver
ares__is_list_empty(&list_head)
end_query
sendreq->data_storage == NULL
Successful completion
DNS server returned answer with no data
DNS server claims query was misformatted
DNS server returned general failure
Domain name not found
DNS server does not implement requested operation
DNS server refused query
Misformatted DNS query
Misformatted domain name
Unsupported address family
Misformatted DNS reply
Could not contact DNS servers
Timeout while contacting DNS servers
End of file
Error reading file
Out of memory
Channel is being destroyed
Misformatted string
Illegal flags specified
Given hostname is not numeric
Illegal hints flags specified
c-ares library initialization not yet performed
Error loading iphlpapi.dll
Could not find GetNetworkParams function
DNS query cancelled
V8 WorkerThread
incorrect header check
unknown compression method
invalid window size
unknown header flags set
header crc mismatch
invalid block type
invalid stored block lengths
too many length or distance symbols
invalid code lengths set
invalid bit length repeat
invalid code -- missing end-of-block
invalid literal/lengths set
invalid distances set
invalid literal/length code
invalid distance code
invalid distance too far back
incorrect data check
incorrect length check
need dictionary
stream end
file error
stream error
data error
insufficient memory
buffer error
incompatible version
connection
proxy-connection
content-length
transfer-encoding
upgrade
chunked
keep-alive
HPE_OK
success
HPE_CB_message_begin
the on_message_begin callback failed
HPE_CB_url
the on_url callback failed
HPE_CB_header_field
the on_header_field callback failed
HPE_CB_header_value
the on_header_value callback failed
HPE_CB_headers_complete
the on_headers_complete callback failed
HPE_CB_body
the on_body callback failed
HPE_CB_message_complete
the on_message_complete callback failed
HPE_CB_status
the on_status callback failed
HPE_CB_chunk_header
the on_chunk_header callback failed
HPE_CB_chunk_complete
the on_chunk_complete callback failed
HPE_INVALID_EOF_STATE
stream ended at an unexpected time
HPE_HEADER_OVERFLOW
too many header bytes seen; overflow detected
HPE_CLOSED_CONNECTION
data received after completed connection: close message
HPE_INVALID_VERSION
invalid HTTP version
HPE_INVALID_STATUS
invalid HTTP status code
HPE_INVALID_METHOD
invalid HTTP method
HPE_INVALID_URL
invalid URL
HPE_INVALID_HOST
invalid host
HPE_INVALID_PORT
invalid port
HPE_INVALID_PATH
invalid path
HPE_INVALID_QUERY_STRING
invalid query string
HPE_INVALID_FRAGMENT
invalid fragment
HPE_LF_EXPECTED
LF character expected
HPE_INVALID_HEADER_TOKEN
invalid character in header
HPE_INVALID_CONTENT_LENGTH
invalid character in content-length header
HPE_UNEXPECTED_CONTENT_LENGTH
unexpected content-length header
HPE_INVALID_CHUNK_SIZE
invalid character in chunk size header
HPE_INVALID_CONSTANT
invalid constant string
HPE_INVALID_INTERNAL_STATE
encountered unexpected internal state
HPE_STRICT
strict mode assertion failed
HPE_PAUSED
parser is paused
HPE_UNKNOWN
an unknown error occurred
../deps/uv/src/fs-poll.c
uv_fs_poll_stop
ctx->parent_handle != NULL
uv_fs_poll_getpath
timer_cb
ctx->parent_handle->poll_ctx == ctx
UV_THREADPOOL_SIZE
uv__queue_done
../deps/uv/src/threadpool.c
EAI_ADDRFAMILY
EAI_AGAIN
EAI_BADFLAGS
EAI_BADHINTS
EAI_CANCELED
EAI_FAIL
EAI_FAMILY
EAI_MEMORY
EAI_NODATA
EAI_NONAME
EAI_OVERFLOW
EAI_PROTOCOL
EAI_SERVICE
EAI_SOCKTYPE
ECHARSET
ENONET
ESHUTDOWN
EHOSTDOWN
argument list too long
permission denied
address already in use
address not available
address family not supported
resource temporarily unavailable
temporary failure
bad ai_flags value
invalid value for hints
request canceled
permanent failure
ai_family not supported
no address
unknown node or service
argument buffer overflow
resolved protocol is unknown
service not available for socket type
socket type not supported
connection already in progress
bad file descriptor
resource busy or locked
operation canceled
invalid Unicode character
software caused connection abort
connection refused
connection reset by peer
destination address required
file already exists
bad address in system call argument
file too large
host is unreachable
interrupted system call
i/o error
socket is already connected
illegal operation on a directory
too many symbolic links encountered
too many open files
network is down
network is unreachable
file table overflow
no buffer space available
no such device
no such file or directory
not enough memory
machine is not on the network
protocol not available
no space left on device
function not implemented
socket is not connected
not a directory
directory not empty
socket operation on non-socket
operation not supported on socket
operation not permitted
protocol error
protocol not supported
protocol wrong type for socket
read-only file system
cannot send after transport endpoint shutdown
invalid seek
no such process
connection timed out
text file is busy
cross-device link not permitted
unknown error
end of file
no such device or address
too many links
host is down
uv_loop_delete
../deps/uv/src/uv-common.c
err == 0
Unknown system error %d
Unknown system error
check
fs_event
fs_poll
poll
prepare
timer
[%c%c%c] %-8s %p
1.9.1
uv_close
../deps/uv/src/unix/core.c
!(handle->flags & (UV_CLOSING | UV_CLOSED))
uv__make_close_pending
handle->flags & UV_CLOSING
!(handle->flags & UV_CLOSED)
uv__accept
sockfd >= 0
uv__close_nocheckstdio
fd > -1
uv__close
fd > STDERR_FILENO
uv__io_init
cb != NULL
fd >= -1
uv__io_start
0 == (events & ~(POLLIN | POLLOUT | UV__POLLRDHUP))
0 != events
w->fd >= 0
w->fd < INT_MAX
uv__io_stop
loop->watchers[w->fd] == w
loop->nfds > 0
uv__io_active
TMPDIR
TEMP
TEMPDIR
/tmp
uv__finish_close
no error
uv_fs_access
../deps/uv/src/unix/fs.c
path != NULL
uv__has_active_reqs(loop)
uv_fs_chmod
uv_fs_chown
uv_fs_lstat
uv_fs_link
uv_fs_mkdir
uv_fs_mkdtemp
uv_fs_open
uv_fs_read
uv_fs_scandir
uv_fs_readlink
uv_fs_realpath
uv_fs_rename
uv_fs_rmdir
uv_fs_stat
uv_fs_symlink
uv_fs_unlink
uv_fs_utime
uv_fs_write
uv__fs_done
req->result == 0
uv__getaddrinfo_translate_error
../deps/uv/src/unix/getaddrinfo.c
!"unknown EAI_* error code"
uv__getaddrinfo_done
uv__has_active_reqs(req->loop)
req->retcode == 0
uv__getnameinfo_done
../deps/uv/src/unix/getnameinfo.c
uv__loop_close
../deps/uv/src/unix/loop.c
QUEUE_EMPTY(&loop->wq) && "thread pool work queue not empty!"
!uv__has_active_reqs(loop)
uv_poll_stop
../deps/uv/src/unix/poll.c
uv_poll_start
(pevents & ~(UV_READABLE | UV_WRITABLE | UV_DISCONNECT)) == 0
uv_spawn
../deps/uv/src/unix/process.c
options->file != NULL
!(options->flags & ~(UV_PROCESS_DETACHED | UV_PROCESS_SETGID | UV_PROCESS_SETUID | UV_PROCESS_WINDOWS_HIDE | UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS))
err == pid
uv__process_init_stdio
container->data.stream != NULL
0 && "Unexpected flags"
uv__chld
signum == SIGCHLD
QUEUE_EMPTY(&pending)
uv__write_int
n == sizeof(val)
uv_signal_start
../deps/uv/src/unix/signal.c
uv_signal_stop
uv__signal_event
!(handle->flags & UV_CLOSING)
uv__signal_handler
r == sizeof msg || (r == -1 && (errno == EAGAIN || errno == EWOULDBLOCK))
(libuv) kqueue()
uv__stream_open
../deps/uv/src/unix/stream.c
fd >= 0
uv__stream_destroy
!uv__io_active(&stream->io_watcher, POLLIN | POLLOUT)
stream->flags & UV_CLOSED
uv__has_active_reqs(stream->loop)
stream->write_queue_size == 0
uv__server_io
events == POLLIN
stream->accepted_fd == -1
!(stream->flags & UV_CLOSING)
uv_accept
server->loop == client->loop
queued_fds->offset > 0
uv_shutdown
(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE) && "uv_shutdown (unix) only supports uv_handle_t right now"
uv__stream_fd(stream) >= 0
uv_write2
nbufs > 0
(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE || stream->type == UV_TTY) && "uv_write (unix) does not yet support other types of streams"
!(stream->flags & UV_STREAM_BLOCKING)
uv_try_write
uv_read_start
stream->type == UV_TCP || stream->type == UV_NAMED_PIPE || stream->type == UV_TTY
alloc_cb
uv___stream_fd
handle->type == UV_TCP || handle->type == UV_TTY || handle->type == UV_NAMED_PIPE
uv__stream_close
!uv__io_active(&handle->io_watcher, POLLIN | POLLOUT)
uv__stream_osx_select_cb
events != 0
events == (events & (POLLIN | POLLOUT))
uv__stream_osx_select
events != 0 || FD_ISSET(s->int_fd, s->sread)
(s->events == 0) || (stream->flags & UV_CLOSING)
uv__write_callbacks
uv__stream_osx_interrupt_select
r == 1
uv__stream_io
uv__stream_connect
stream->type == UV_TCP || stream->type == UV_NAMED_PIPE
uv__read
stream->alloc_cb != NULL
buf.base != NULL
ignoring non-SCM_RIGHTS ancillary data: %d
uv__stream_recv_cmsg
start + CMSG_LEN(count * sizeof(*pi)) == end
uv__drain
stream->shutdown_req
uv__write
req->handle == stream
fd_to_send >= 0
req->write_index < req->nbufs
stream->write_queue_size >= len
n == 0
n == 0 || n == -1
uv__write_req_size
req->bufs != NULL
req->handle->write_queue_size >= size
uv__tcp_connect
../deps/uv/src/unix/tcp.c
handle->type == UV_TCP
UV_TCP_SINGLE_ACCEPT
../deps/uv/src/unix/udp.c
uv__udp_finish_close
handle->io_watcher.fd == -1
handle->send_queue_size == 0
handle->send_queue_count == 0
uv__udp_send
addrlen <= sizeof(req->addr)
uv__has_active_reqs(handle->loop)
uv__udp_try_send
uv_udp_set_multicast_interface
uv__udp_run_completed
!(handle->flags & UV_UDP_PROCESSING)
uv__udp_maybe_deferred_bind
0 && "unsupported address family"
uv__udp_sendmsg
q != NULL
uv__udp_io
handle->type == UV_UDP
uv__udp_recvmsg
handle->recv_cb != NULL
handle->alloc_cb != NULL
uv_setup_args
../deps/uv/src/unix/proctitle.c
process_title.len + 1 == size
../deps/uv/src/unix/darwin.c
err == KERN_SUCCESS
machdep.cpu.brand_string
hw.model
hw.cpufrequency
../deps/uv/src/unix/fsevents.c
uv__cf_loop_signal
state != NULL
/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation
/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices
CFArrayCreate
CFRelease
CFRunLoopAddSource
CFRunLoopGetCurrent
CFRunLoopRemoveSource
CFRunLoopRun
CFRunLoopSourceCreate
CFRunLoopSourceSignal
CFRunLoopStop
CFRunLoopWakeUp
CFStringCreateWithFileSystemRepresentation
CFStringGetSystemEncoding
kCFRunLoopDefaultMode
FSEventStreamCreate
FSEventStreamFlushSync
FSEventStreamInvalidate
FSEventStreamRelease
FSEventStreamScheduleWithRunLoop
FSEventStreamStart
FSEventStreamStop
uv__fsevents_reschedule
q != &state->fsevent_handles
curr->realpath != NULL
uv__fsevents_create_stream
ref != NULL
uv__fsevents_event_cb
uv__fsevents_push_event
events != NULL || err != 0
/System/Library/Frameworks/ApplicationServices.framework/Versions/A/ApplicationServices
CFStringCreateWithCString
CFBundleGetBundleWithIdentifier
CFBundleGetDataPointerForName
CFBundleGetFunctionPointerForName
com.apple.LaunchServices
_LSGetCurrentApplicationASN
_LSSetApplicationInformationItem
_kLSDisplayNameKey
CFBundleGetInfoDictionary
CFBundleGetMainBundle
com.apple.HIServices
SetApplicationIsDaemon
_LSApplicationCheckIn
_LSSetApplicationLaunchServicesServerConnectionStatus
pthread_barrier_wait
../deps/uv/src/unix/pthread-barrier.c
pthread_cond_signal(&b->cond) == 0
uv__io_poll
../deps/uv/src/unix/kqueue.c
QUEUE_EMPTY(&loop->watcher_queue)
w->pevents != 0
w->fd < (int) loop->nwatchers
timeout >= -1
timeout != -1
loop->watchers != NULL
w->events == POLLIN
w->pevents == POLLIN
timeout > 0
uv__platform_invalidate_fd
 vs. 
==== C stack trace ===============================
(empty)
%2d: 
# Fatal error in %s, line %d
__TEXT
__text
pthread_setname_np
../deps/v8/src/base/platform/platform-posix.cc
V8 failed to initialize fast TLS on current kernel
runtime
prologue
v8natives
math
fdlibm
arraybuffer
typedarray
iterator-prototype
generator
object-observe
collection
weak-collection
collection-iterator
promise
messages
array-iterator
string-iterator
templates
harmony-array
harmony-typedarray
native debug.js
native mirror.js
native liveedit.js
native runtime.js
native prologue.js
native v8natives.js
native symbol.js
native array.js
native string.js
native uri.js
native math.js
native fdlibm.js
native date.js
native regexp.js
native arraybuffer.js
native typedarray.js
native iterator-prototype.js
native generator.js
native object-observe.js
native collection.js
native weak-collection.js
native collection-iterator.js
native promise.js
native messages.js
native json.js
native array-iterator.js
native string-iterator.js
native templates.js
native harmony-array.js
native harmony-typedarray.js
proxy
harmony-atomics
harmony-array-includes
harmony-concat-spreadable
harmony-tostring
harmony-regexp
harmony-reflect
harmony-spread
harmony-object
harmony-sharedarraybuffer
native dummy.js
DTLSv1 part of OpenSSL 1.0.2h  3 May 2016
SSLv3 part of OpenSSL 1.0.2h  3 May 2016
TLSv1 part of OpenSSL 1.0.2h  3 May 2016
AES part of OpenSSL 1.0.2h  3 May 2016
ASN.1 part of OpenSSL 1.0.2h  3 May 2016
%-18s
00000000000000007777777777777777
Blowfish part of OpenSSL 1.0.2h  3 May 2016
!(Ew
~&jE
 iciNWq
x`\`U
S2zw
Qjh/T
w?6r
\^c$j
yr,@
H{1S
"//w
AJsN
*!ec
pzKD)
ilRdV
|sG2
U$qk.
27;C
qUN1
/n[(
Ze2Zh@
Wcr"
T0.S
ap?#
r3A~
;"lY7
@n2w
_g@Cg
%xP(
B*k@5
mK1f
n:2C[
V@E'
::SU
^|1)
A4x{%`
no:7
7,gm;
.97yY
Bh;+j
.x7B
{x`M`
BFUa.X
YnFpW
-f3F2
r9$|
n6j/
HWyn
9)PF
(-}|
W;()f
_xU`u
08bX
w``u N
PANIC 
EMERG 
EMR 
ALERT 
ALR 
CRIT 
CRI 
ERROR 
ERR 
WARNING 
WARN 
WAR 
NOTICE 
NOTE 
NOT 
INFO 
INF 
DEBUG 
DBG 
5mmQ
vb^~
5mmQ
vb^~
I(fQ
5mmQ
vb^~
I(fQ
mg5NJ
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
Wza]lw
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
Wza]lw
(|YGNk
v!pH
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
Wza]lw
(|YGNk
v!pH
8/A0
%K3 QQ+
^p/F
f?H`
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
Wza]lw
(|YGNk
v!pH
8/A0
%K3 QQ+
^p/F
f?H`
Big Number part of OpenSSL 1.0.2h  3 May 2016
%/1A[_amsw
 ' ) - 3 G M Q _ c e i w } 
!5!A!I!O!Y![!_!s!}!
"!"%"+"1"9"K"O"c"g"s"u"
#'#)#/#3#5#E#Q#S#Y#c#k#
$)$=$A$C$M$_$g$k$y$}$
%'%1%=%C%K%O%s%
&'&)&5&;&?&K&S&Y&e&i&o&{&
'5'7'M'S'U'_'k'm's'w'
(!(1(=(?(I(Q([(](a(g(u(
)!)#)?)G)])e)i)o)u)
*%*/*O*U*_*e*k*m*s*
+'+1+3+=+?+K+O+U+i+m+o+{+
,#,/,5,9,A,W,Y,i,w,
-;-C-I-M-a-e-q-
.%.-.3.7.9.?.W.[.o.y.
/'/)/A/E/K/M/Q/W/o/u/}/
0#0)070;0U0Y0[0g0q0y0}0
1!1'1-191C1E1K1]1a1g1m1s1
2)252Y2]2c2k2o2u2w2{2
3%3+3/353A3G3[3_3g3k3s3y3
474E4U4W4c4i4m4
5-535;5A5Q5e5o5q5w5{5}5
6#6165676;6M6O6S6Y6a6k6m6
7?7E7I7O7]7a7u7
8!83858A8G8K8S8W8_8e8o8q8}8
9#9%9)9/9=9A9M9[9k9y9}9
:':+:1:K:Q:[:c:g:m:y:
;!;#;-;9;E;S;Y;_;q;{;
<)<5<C<O<S<[<e<k<q<
=!=-=3=7=?=C=o=s=u=y={=
>#>)>/>3>A>W>c>e>w>
?7?;?=?A?Y?_?e?g?y?}?
@!@%@+@1@?@C@E@]@a@g@m@
A!A3A5A;A?AYAeAkAwA{A
B#B)B/BCBSBUB[BaBsB}B
C%C'C3C7C9COCWCiC
D#D)D;D?DEDKDQDSDYDeDoD
E+E1EAEIESEUEaEwE}E
E0123456789ABCDEF
CAST part of OpenSSL 1.0.2h  3 May 2016
%?/?!
"o;h(Y
8On
T*_}x:
j Bz
u\B&
y7bT
Ab61
T<*2
a.z9
DGt2
yM;-
jMG\^|Y
C?9z
bcKU
!+g\
"%-U^7
PaH?
dv&4
wj-K
g&H`
~8lI
d^AE
;]>r
^(O= 
*,]I
Fv\;
Eub'z
\j#M
HJI
SRqDIK
_maz
mn`I:T`H
{OJW
z(~c
=;&o
~?Pa w
WFgO
(>nH&p
gTzu
B=!&|
!\1c
)eyC
c8:$
}oaO
]ny`
BN"r
kMxn
FS(l
h,DUu
uU~b
v^FES
SU2`
-7HD
ISgN
Es/#
s%iH
SH6tc
*Y#5
/C~A
^l(
Sj~=eI
PIMAC
gC_7
F_C)x;
a3bt
<tm
OxW2
Zbby
S4n)
lbfL
Tq*+
S9v.i
+LVvuOx39]O#2
}\cm
xzdD]
vOB9`
pqT3^-ZI
$;g9
A^e$
1d[O~
!![z
M:&)
CONF_def part of OpenSSL 1.0.2h  3 May 2016
CONF part of OpenSSL 1.0.2h  3 May 2016
libdes part of OpenSSL 1.0.2h  3 May 2016
DES part of OpenSSL 1.0.2h  3 May 2016
 !"#$% !"#$%&'()*+,-./0123456789:;<=>?@ABCD./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
  ##%%&&))**,,//1122447788;;==>>@@CCEEFFIIJJLLOOQQRRTTWWXX[[]]^^aabbddgghhkkmmnnppssuuvvyyzz||
Diffie-Hellman part of OpenSSL 1.0.2h  3 May 2016
qCJ.
s`a;
S#FI
i~wKVA\
o&1m&
8GZS
%0nV4
w8i_q
&`Pqy?
H5gRR-
XG[r
'#^QTy
`fPw.
?ggen
DSA part of OpenSSL 1.0.2h  3 May 2016
MinghuaQu)
MinghuaQuS
MinghuaQu
-(`|
MinghuaQu
;L8,
s(Fdi
(U1h
#Q7z
iFjt
E[3M
A2VPD
9C#U
)E\\*=
T*8U
U)l:T^8rv
&,o]
`kM=
9)jx
'>f,
a5<p
r$0I
ihD5
"cs73KI
XW=?'
h2Wl
'pQ 
&)j<
*0fT
m>gh
"o;o
|<C!FReQ
3Wk1^
sao5
(0'yX
zj{&
MinghuaQu
kV!DA
Nm^\
xzxv
Q/xtJ2
\ys$
MinghuaQuw
aybSr
L7~*
K4K 
X!;3; 
6qo~
{*eU
$XI(6
Yb6N4
uw&]
&>1;y
4`x/
MBb!
u;{Gk
Ik`dub`D
`yNT
9IGv
)Urz
$&nN
MinghuaQu
HT%+
{|WM
(fS{ggRcjh
&@'kd
Rbg.E
^3)2
(wMww
C q'O
UUUUUUUUUUUa
xUN'
q~!/
MinghuaQu
]&g''}
f&dy
Vg3LE
bV}TS
UUUUUUUUUUUUUU<o(
F$R-
oMinghuaQu
tfjgvmfv
(q-B
u+,@
b-w#
(ZdOt
+5I 
VggjeK uO5n
FV|FgUV
|I6?
t+c)
8A6j
)TpH
0Z@q
<4E87
9[#l
bmNP
GXqN
Ut]<E
b]jY
A2VPD
9C#U
)E\\*=
^J_spY
?jOb
^J_spY
^J_spY
^J_spY
bzUkm
S[{Q
$Cw!R
^J_spY
/\HS7_
hT.'
<0(.
~,Vg
r8l@
??M|
& ( 
nSw}Z
u0Az
,KH/
2bT~
& ( 
& ( 
nStf,a
/I%j
:eaI
FDA~i
^G 6
^G 6
^G 6
^G 6
M>}I
:z'H>
^G 6
]o~P
FF!w
A&<S
]o~P
]o~P
]o~P
p5Z3
]o~P
`VX:H
dZ!2.
}_|mPG@j^h
8]Vc2
IJ_H^[
pU>\AL
`VX:H
`VX:H
gB>d
pU>\AL
iEC part of OpenSSL 1.0.2h  3 May 2016
ECDH part of OpenSSL 1.0.2h  3 May 2016
ECDSA part of OpenSSL 1.0.2h  3 May 2016
6666666666666666jjjjjjjjjjjjjjjjJ
?456789:;<=
 !"#$%&'()*+,-./0123
EVP part of OpenSSL 1.0.2h  3 May 2016
\\\\\\\\\\\\\\\\
IDEA part of OpenSSL 1.0.2h  3 May 2016
lhash part of OpenSSL 1.0.2h  3 May 2016
MD4 part of OpenSSL 1.0.2h  3 May 2016
MD5 part of OpenSSL 1.0.2h  3 May 2016
Ag*g*
g+g+
Content-Type: application/ocsp-request
Content-Length: %d
%s %s HTTP/1.0
PEM part of OpenSSL 1.0.2h  3 May 2016
@@RAND part of OpenSSL 1.0.2h  3 May 2016
RC2 part of OpenSSL 1.0.2h  3 May 2016
!"\kN
5Mj*
6[%U
RIPE-MD160 part of OpenSSL 1.0.2h  3 May 2016
RSA part of OpenSSL 1.0.2h  3 May 2016
%\QM
`cC#( 
(D@D
xsK;
.pp@0
6tpD4
psC3
, ,
'prB2
``@ PP@
7XRJ
xpH8
`aA!
4@AA
|qM=
=trF6,#
"lbN.
haI)|pL<
>d`D$
.HCK
!hcK+dbF&
3|rN>
xrJ:DCG
'DAE
L@L
<0<pqA1
tqE5
?HAI
9dcG'
l`L,
1H@H
lcO/<1
-@@@
:LBN
h`H(|sO?
tsG7
-DBF
+daE%
*laM-\SO
:XPH
`bB"(!
xqI9
hbJ*("
`@ `QE
DcO/lcK+hSK
bB"`3
64CK
`L,l
((BN
+(bF&drJ:x#
rB2pBB
sC3pcG'd
 ,,
qM=|
bJ*h
`H(hqA1p
aA!`
sK;xPL
cC#`#
# AM
"
bN.l
HpH8x
p@0pqE5tsO?|1
`D$daM-l
pD4t
rF6t
*(RN
HqI9x
\sG7tPD
%$CO
rN>|
aE%d0<<
pL<|
aI)h
@LL
;8BJ
%$!M
C#`c
(( D
K;xs
@0pp
D4tp
$$ 
C3ps
,, 
B2pr
@ ``@
H8xp
A!`a
PRM=|q
F6tr
N.lb
LAI)haL<|p
D$d`
.,"K
! !K+hcF&db
N>|r
J:xrG
DALL@
<<0A1pq
E5tq
981G'dc
L,l`
O/lc
-,!@
H(h`O?|s
TRG7ts
+(#E%da
M-laO
:82H
B"`b
I9xq
J*hb
 ``@
D@D/lcO+hcK
"`bB303
HCK/
,l`L(
DAE!
LBN6
&dbF:xrJ'$#
2prB
3psC'dcG,
,, *
TSG.
=|qM
*hbJ1
(h`H1pqA
!`aA>
;xsK
\PL"
#`cC# #
.,"
.lbN
XRJ2
HAI8xpH
0pp@5tqE?|sO541
$d`D-laM
4tpD
6trF
\RN)
H@H9xqI
\SO7tsG
TPD2
DBF-
PRB+
>|rN
%daE<<06
<|pL
PP@981
)haI
L@L
HBJ7
SHA1 part of OpenSSL 1.0.2h  3 May 2016
p09Y
[SHA-256 part of OpenSSL 1.0.2h  3 May 2016
|6*)
g&3g
[SHA-512 part of OpenSSL 1.0.2h  3 May 2016
SHA part of OpenSSL 1.0.2h  3 May 2016
Stack part of OpenSSL 1.0.2h  3 May 2016
TXT_DB part of OpenSSL 1.0.2h  3 May 2016
X.509 part of OpenSSL 1.0.2h  3 May 2016
                ENGINE_rsa_sign
ENGINE_rsa_priv_dec
ENGINE_modexp
ENGINE_dsa_do_sign
ENGINE_rand_seed
ENGINE_rand_bytes
ENGINE_init
ENGINE_load_privkey
sureware_load_public
ENGINE_load_pubkey
CAMELLIA part of OpenSSL 1.0.2h  3 May 2016
%bw+s
"s;:
6lkc
ZL9L
sJfw>7G9@>
l4Ot
s6!TYK
wI-S
x@+
we-}_
hhwi
.Kc%
BT5f
NWzl
F1}"
Q>_>@
Jy).A
ZH^r
&&M9
A,uw"
((\T
L.V}
t0;?ZlP*m
v0o/5
#Mj-d
>yhP
7i@X
Hofw
./#{
.*Ce
hJxRX@_
H=`HY
 \sf
a|w9i
Ugi<
EG{M
2Uiwp"9
D~@.
1b4Ef
?vO`
[d>0
v>#d
RxT0<1
lei5:
1#Q;
ctl=`|
Zod6
.I`Mb"(
O_yG|
KlD#
}$z9*
m4}O
w0A4k
'av(
|hdX)
MlT8
!Ro/
RFCY
.Q.Ol
QtJ?
>)[8
d_r_0
cz>Sp
AGgV
!fUY
D g)*
>B=~,
*]r\)
.bmxz
b5o-
Tc`
V<X^
XMM{*
%_*:
YS1n
'qv"
.u\:
A.00h
Wmn|CH
uQ'ZH
W%|@
*D]WO"#y&
lM2p
3wQ]
"Wlw
)_+b~F
Op~)
Z0zd
RP;e!
9@Xp&
K8uH
h@M
UHz4Z}
<;SR
aF<7u
j/ \
0@9=
/s@:T
$hRh 
%E5u(
*[l=
$>Mm/JhA
aql*
f1cK%
#;T&
bu\N
zN( 
ik.R
V'uk:
6l13
!< `!
9:dzGN
U79Pc
i%|kB
7sAP'
\l:ArR
Y93a=7c@
Bu 5
q*g}%
*,t6
{G>~
8<pl
-JG&
4.j."
/A#i!&
#oy=i~
/I]P
yf2)
#k+ka\T
(E"w
Hc8a"
}_sR
j3kg
?eI[
kw.6#
u#+L
QTk$
{5`q@roz?
D2Lb!
(BZq
D"bu
B>J7I
G@.I
p)ou}
2|':
o)nV
AbW_
 ^LXjt
K5!n^n
[@oN
$f;Zv9l
 e->
]1h=bfz
{ry\W
3ja~
A#>\N
!HRN
^^h0
\#\d
)?0z
sh;7
~_K&
o1+v3
rZPM
`n#%c
1x?
SER<
ci;e*
7< M
rD]/
 Xia
uBY+
EovVY
:?ca
y;w9
g|MT
V~$j
*};8.
WRw[
tM(ie-V
SUWs
?_15]>
Y& -aY
7qp9
X:vS
ua-,
tb%]
jOJw"
dg< 
+D5X
bt1+
s}(C
(h W#
cL;p
u%gc
4+ 8
nCRD
w`1?
iU[&l
&7!K
O%.U/
8ca1
pSPo
KMBo8[
N'L&R/l
p4Z3
f#9i
!^(-
bh.b|C
|y4(
$%{/
;h)j 
[w\<0
ifTK
ex"y
eBeL
bie.+
rZ1VwGf5
~P2T
+7"u
N=Knn
O.:'
%*-L
.N_v
2a"l
kL+v<
F<mb
R=1C&b
[y_GE
%:Z&
Q{0^:
YbKh
q?{X
l :%
4)m1
*Y$ve
^K?F
M}8vhJ
6ynV8%
JPQv
SQ8_d`\
iILV]
I:/{
ne*+
@BH]f
I2nC
ciO"A
Z"T-478
]K^,
[fo@e
O05"
ss3Y!
\u_~
tdYv
a4H>
XwA0
!$k*
KS1
Uz_G3=
jcn,T,>
M$}x
#@Ez
a[D
1u+@A
>Sem
XqgA+
PR$"
fBBy
gdPI
pIp 
 $v E
7*QR
#kL|
=Q9M
\\MVT
} &j
saJ!
c(^a
J_R=I)
E)2G\
n1Z 
6-(\
BvVlZ\
Vp>u
 LU 
=.TE
uJ4CA2
m*Zu
z%2'
@jB+
q9\`
gi%3e
"YEu
,h11]
1?]N
f{A-<
_b(s
C<{@
Ltc$
fdxfv%
 &v7
,'#B
f%wyLmX:
Nz3I#B
VY5[;o
7_b]
`DZG
i%YR
5A10K
7q|Q@
_ee/?P
DnRv
A"k'
wY[K,
7}'&V
@{nZ
d/rRw
h}@3-
CD1mB"
%^#9#
YH%c
hRB.
PGr]
( 38
&?y5
mDJe
WrgoI
 rkC
9aDW
Y=QX
qA<?\
hEM&!
+Sgs
=cdE
5N{j
3''1
eODj
W2Q=
851Pe
V~~Vq
6afD
<3AC|[sqb
M?|Z
ya<O
F_[T
fA,'
>WK6
n@PK
s!#r
\Y|W2
&";T[
[`|bJj
d35P
_YWL
>o}-XH
Ij)s
u$k(
NJ{*
uC<[rR
q2'<Kv
W3fp
=$(t
2_d~
!9iV
dAN"
*UlS
-<nre!
<,W?
Z8^@
#Dq(
,K])D
X!}}p|u
GBd<}v
L=,>Y
wI%%
?gwL
9fkj
D?7"
ci/\
f!)E
@MfKZ
Vemn
[ve,P
O#&M
jb:5
*|9WD
"[I^
JD<t
hX^:
arPf
/2x1
6-zeZ
(jvg;
db("0
HbAta
2:3maJ
WL6e}:
W'6S`
R'#B
,3g4
t0{r)3
=O?AqP
t(1pC
Q{qk
Y-Ny
2];*
prh[
]@IZ
CR&C
U0Es
^DqPt
Q\X_
oN86
r-IE
uE*q#<
D*64
<Hs2)
"+s;b
3Qg^y
!0"J
).0n
`&H|&
..uR5&m
z[*
_p"_
50Q5
KQSlB
PEIF
tLY^m`6
pX-"
~jLRG
62$|S)6f
Z!${
P_+!
fU).
37LQ
[K#[
I_#]
[@qo
pG_*h
+W@!
?r>6;
s{5F
Qpr2
9V);
7ig
]i7,>
ai^/
n0?X
=S'\
h*Ax
Th{[
La0+
+C-.c
^.om5r
:gN(dq
G2xVo\?
,kj8
l`>,l}
U?Y5qX}
jNXcA
9o!5
cNUGK
vn%*
INdK
*5pB
F9q'
v<d2}
|hq_
VIgq qC:
w;@
YYHl
1\`T=h
}gE3
jfz1
]<(D
%~kE
X~ '.
,(Nk
n8<
^+#_
1GNK
j('+q
hX@e
0;Q5[
[f<>28
gj8(
?tya
(i/Al
j"MRX
)'9W:
Mlt(J
Qdsma
S8#w
BFEo
jLTKTz
ir@r`
+ -e
Y:T|
ug>c
GoJJw
mAFr
B+N3
&$6c
A|@Q&
3'<\
2Zq)
|}Eq1
8b&{
v)56
[f7@7F
Ow!y
RE!r
F_\,
qDGqT
.<P]A
%aIwV
fxv^
S<hN-AO
E[~u
PAGN_4
l&: q
Fi:je
qIRH
vAr>
,kXKlQT
~[I,
xx{'
ne[9
yHs8=
2^pV
BY_Lq)
WP4$!
aS&v&*
Z7"c
BCeA
LsiX
w~%#
4Mv8
V5u f
RzQU
1L$1
aRWZ5
/V;"
&_{u 
kIoQ
6r1ij
 _$7*xq?"
H!;)
;5jNf
ET`K\
u%WX
bgD$
"?j,
@WE]X
3Ej%Tb
.&D
aA0k
_}eOk
k8xA
z~")
aMo^
l&rB6
:cwd|
wxT%
V07;m
.W%(
t+RW
`gh'
U^Pg
g4FA
s=;\
R]Di
;uC#h/
Ep0u
u+]|
h|gg
O?'~^
6r-m_v
XD{p7
w{Z0
 0#&
jt(@L
}Xee+
Q`uV
N.8U}
LG.HK
`Ch.
x=^D
$J6"t
/RIv
}*x@
h5N.
O#wjk
tY)`
{S"8
.5.}
!N~g
1m2{
Mc]T=
c2\f?C
+v30Y
?x29
;%|>0
y?iLa
7;&j
[D{3
-,rI
4Zis
IChq
kn"[
^DnJ
xg-9Ja
r@4$
20t
Q@1~
r184
;*tL
;'Dl
h`v%
z>Hz
]&@+fk:
Z~wl
zF):O4
RM~]qY
/[vS!
ld*^
<{:K
5:[A
R/Qs
YWQa:B
E"Y6
:3R$
td5)
wE2C
EvLa
F#bgn?MwN|%
LT[N
t%n}
EN2 s/
`:zQF
KFz"
[U#9
B6uZ
N`UaK
Sr89[
hloav\
rL[i+
=#N"u#
ia7@
&k(_
E;-j
Jvp)
h2n_\
{-uY
-AvRJ
5-:)
31tPR
:mIR
KV;-W
D.Hog^
p!PcA1|
g*4}
O1NzNfj'fGv
egUkr
"Ks</
eyj5yR
hc[N
JM0L
F/o4
$g#8lu#
XfJ7
]}Wl
Q*hd
`ITS
K|oT
?u^$
L-@V
stLDp
_Ek6b]
%,?~
][LK~lO
6Qd=
a;Tg
>'SMN{
qPq2k
.dx_LV9
sK2?
},MQ
<~{Su;u
]C*<
Mq~h
rAGW
4F0I
Cc?[
:'L8<
%eyu~
@<:nq
IP{s
iaR
k^ZP
;42=
(NQ[
`47/
Z]$M
{s!{
TPS'
Z+5AS
kp3/y*U
sKu{~X
6#RDP#
<{,&
L0fO*'
AW:S
jHLy
;Qo0
}//
aPw0
t}f<
8+Qw
G{Ol
@F(%
dDV8
#AL#~\
-5X5
yWTb?
7OsR
] OO
k~Rz
GXy{
@dKb]
 ->T
rF6?
]FhSD}
aD/x
O*7`
oWnS
?, i
*^2F
WD%g"0Q-)
80F2<
r]q-
2:pS
hbvc
yRnkB
ka`O
_Q/1
,oYR
>]q&`
vm:u
--FD-
If]
%Gdnv
_jPo
,ZFDGn
<K4Q
6i$R
[j>w
2Tm=#
XYD%
),d?
 F%)
s-}24
IC'W
1t;K
11nN
.4bb
DBDc
#U\l
'={i
Y.\Q
RD6O
5a=Z
 f*Wk;
j[6Z
!AECO
*,vJEd
Qj{Jd
Jo#"
<YVtV&
hW1M
OHVO
awO8
if.F<h
4Pl
?d86L
mpkQ
y0JY
$JXsZ
Uv1t
Kr/.
:QYJ
K1m;
r9rW
0(u[
hN2D
y2Cu
g u}DE
P!bxo
 W*M!
/!dq
e>;[
71iB
O'.K
7?XEAVn
PmR"H?
4<Td
\s}r
pkL'
Bd]U
Hhr+g
|c~=;F
{\VM
oBFX}k6U
osM@
`o_je
t(ydU
8SIffK5W
TE@[=-
h0XB
]>vk
vF'l
k/.fG"
*9'R
M0 E
tLsq
;T7 
ELF0
*qi?
 '3?g
GoXis
it^[
UEax
oB4Do4
l]i%
,9(}ZA
>; xs:
',*\
iVY2L
~/;0
f%g}
TM=U*
,kn}
gb`X
r~s-v7
!!'c)Q,
:>#S
$-9(
SEqS
xQfF
3-+K
cq#p
]MSd
7%Ot
L4uGv~;6
Go^ldg
5hcr
^]T\
Y;C;8V
2\fWQx
]GT7]
kR;X
$?$6n
&|w-
K{(K
K/VTR
g]i/H
<Vz.~
2f)l=
Ydh-
Dd g4X3
05=k
0}dV
v&l(
;\>-,
T&^U
#?dC
Ykg"
wOUigi<
z1_|'B
<BWK
NXfT>o
.>6c
Y4i%
lC57
T72[t
&b,C
wQ0"
cpLm
|=jz
A: z
YMI( 
,fQM(
- \=B
oXHT
!^<U
$wB
^W,|*
;LGEW
fP;y
>"<_
Nu6Q
W^p*
Xu"L
p^A{
N5dIn9
:=kT
L*~'
(5jP
,e8\
n5cM
.Vu{
oG/(
iMOb
s%95
"zbe
>"I;6
IQ`+
jB#W
'O6n
6*l$
N[iY 
?VBH;
!g>\
Y`pV
XB`i|
8%J,
\6Sp
"qVS
b0M%
d[kHy 
c~+,
02V8[
OrqK
k`K.
Hq,r/f
wRlb.
"%sy'
WfMD{
4f h
#$>6
Dhq0
{;UO
 %4hf
=!$\
cdP%
<>[h
o$g31
/p;i
hvL&
-Cq?
EhQ,[3
DNkv
l^f^
F{(3?
U).ovc
 _GDK
wfA'@7
L@4T
p^i9
)*-9
N|rO
CAAz
@i1V
-2&Z
}VKRZ
HO8?
"l7ql`R2lWf
12'0
$_~I
V_a|I
Q{<n
O?#7n
"2MR
O:e"
KCsJ
oad2:,
@80^
JAohR
^Nij
'sp3s
rC3rp
ZXF,`i
6K;L#k;{
TPk+L
_$D,!
hb`V
7W}2
>0`9
Jy;B`]A
$@D4Z
4Ch;
WLs6
?80)
'Z9t%
0<cz
vAu&
~w]UG
77#<@
`h9T~
:n;4
Hg>?S
LXKQ
_ Lq
Fop]
Q6p]
[D55
8.)4
)J9o
}n2W
Ea%'
k+Aq
K{"Kb,p
.a%|
)fuG
kSN6'
ZSz@
BoX5
tNt5
1>Vp
{ziv
|}ht
7zRQ
 Ul~
i#_@
:n# 
pp&c
rRfKR
x^`{
2cb:RO
2W[~
3icq
{9d:c
(JF|
5t?F
EjNG
|[y7
Pr"V
g{syW*
sm{c
:w4v
=L&i>
].S"
&g"X
-+ziV
O#;>
Nw!qB
6%vi
}BzJ88
O=o_
bPb:L7X)
^[t0
=f<=
eXQd
Dj|*L
p{T\
_C0#
Wn4'
F.$)
u,$o
%2H/h'
V@1
@h!Aq8
Ht4qw
vzcrR
w_5&#R4
`]Bo2'
Ys/MA
'=mP
{ghz6
gF{A
c`FE%
_=1<<@b
h &N
L!a_
B!rA
WZTR
rFur`7
kV'0
;qV!
W3i+,
d(s${
 !3/
%s q
v|2$
nhsR
"VG[
D(V]
!7-@\
sT5w!
w,Q)#I
[HTiW
.K'!
(D4D
&Ylb
wlLYP
iFFp}A
L5*[
5EwO
!s8p
9g3|3
}W70d
B}-'
:q>*C
\?+u
{C^k
,}aK
*>pg
}|aR!
M'Ezb
8dS2
IquO
s=%(nh0
+ _c
yyen
2+~,@
;Zj09
wm"h
09,h
5~EW
?U>P
1xT$
/zt1
6p]!
HdEu
/5dJ
>*`r
&AK(h
zRXU 
HU>mA$_E*
P(UH 
-U`5K
IytF
. +F
VM%G]f
?srJO
F+Zb
4)#bH
)(oE
KWjI
0W/5
bSh&+
oi3o
Ee{5
]#hQ
rg#E
`28)fk
qTm_fC=
nyYn
A4Wn>
Rg4I
F'pY
2)Ab`
i5BH
B8Z"h
Jm_9
\5Ok
tLl 
gTH.M
Hp)X?
.$@b
<SVX
gxv>
%P>K
ZjLS
ps(crh
H.aR
Xd3h
bj^;
PHhn}Y
:=2"p
,Y;v>
Gz,J
9r#xV
Rxy3
XFle
#y"jl
qx(q
Oh%u'
>8;I)
#P0_?G0
P;w
<!H.
qOy*o
w=Zk
tdAW
|3ox
/\U ?J
t80z
gXC.nT
\1kYL
so=H*m
A<fP
1:uV+T
h&eC
NrPn
CMB!
2 ^f
,:&K
uQbK!
qf`ny
 Jtl
6?S.>
s@'0q
C7HSY
~R65Fu
Vcsc 
I+8G
>1w.
+gC&s
\kc:
$HypYkf
w|+P
1\Z/
n`3i
-|\E
,L2y
;>4>se=
dn3@
t_Q=
JS_!0
5giP
{'Pg
%F!G
f@-r
9Zr4
Q4EX
W9c
TXJw^{
'2>l
[\%M
[t%G
wn)*T$4?5z
j&LQ
q&v
V<h+5*
hr_H
Ul 
S&x0
z<d2
x#Nb
F2M+
gHAx
Tz$o
GNNw
^->6
o*:TJ&
h8*,
jtv2@
kte'
"P=r
ETh7
XjfR
D!\R
c5@O
F~e:
5;{4
1}oP
<e%X
HH&a
4zj@1;IJ
RO%s.
xFKF
*.Tn
fUnh\
!|IjK&
pO0h
yb_A
6H,N
P A@~t
F(`y
kpEKI
"_m#
fpnS
$4cC
j[D
wRe3c
MrFW
AC2,h
`'>W
.]R:
<5!!
k8fo
PHAG2
ai`UJ4
{Zr}
D.]ppM
`'~}
oG)e5L
BcT`
*1~Pt
lDcW
[.3&
w-g2
U7{8+S
a:<w
@:e+
.Wqb^?
bmMV
N[Ox
f4%B.&
]ne3
*it%2
VF+c
Xuub
H0+G+R
WOCR
ub=A
Dq;n
jV*d9O
t4O_
h%!!
eC z
P|iC
|11Jv
c51.l
x\"b
N7CJ'
rw4rs
2I y)
)~NZ
-!8t
&NF:
L4Eud
-|p.
.6<A>Y
nmvos^
y_jO
pRTH
?>#t
&Y}F
2M~/
Pm8A?
@X!pf
29<~
H8,2
iSXc
eA"*`
>!-B
J`KL
7m:e
Z+C=
J#}QU^u
%)(*$J
9v;
Sn^G
 [?oR
Zd[w
k0>Z,
ol*>
K[C7W+
Ye\B
L[*J
x/OA
U?E*
/8.i
tGTS
I;b_b
cCPtH
. j
odMsh
,m+=
Kbf}
1=fI
Vj&{
J>D2
6bX+
^RB!r
>fN46R^
iC!l
^=.Z
o!>d]
F|w)a]c
g'L0X7b
9N1=@
Dc&6\<H:
/%`A
7J!<{
C`<6
EA/c
~[S
u5bB
j2ty
B-}=#
dOj,
*^!l}
9J9;6
<p[r
6,2K
Y%b)
)Ck?B
_1/<
v$m%
sn_d.
_`@
Hc S
B+Uk=
-mB:t
"IYW
6+?R6_
yH/Yy
_{j!g>
1--R
'g0dW
}=\x]y1
Y&4{
*>#R
z(ov
7o4H
[OdP
KuBEN
Jq;v
?".P"
*iO`
a@XZ
s?uj
O$G;
p:(L
%0nP
6myY;
I"9|OxTex
@Q~i
}CQBf
rmhD
SO~c
7gS_
Rq[R
#lyj
B`4I
F,mZq
Vt_9
wap}Q
-l34
}2&2
9*VU
ayf+
;2(-/
{&);
(5Me
9Y@nJM
28Vm
8TZvrv<
 FWa
wci.
,3{H
,hmQ#
"!HR
mzP"T
@Zs3
W"Fe~
otT)
m&9W
aevF~
7#T)
vAj}
">|vG
'yU#y
T~a@E
XWY]
YedcCH}
xI<'
c/L\
B{Y.w
v1GZ
5c">/
e+3E
L5^x|S
|InzT
A>x8
)-M1
1j!6
LqH!)8
{D[X
y&3Gl
s=QT
O~`L{
V<"+u~
mL~(
yH3f
W)p[
x,5J
BZZn
N]#8f'
2nIg
?fx
{H}yq
5/0
0tU+xc:
9QTA
P5[1
W>peSp>9
M/\u
eyBH_
{8w1
We_A0
@Pgl
D(n%6
(3"B
Zpwz
}"6M:Q
U RDn
(M@<&
.%X&1
*kf[R
p2{l
&q6}A,
e$ChX f~&]
] D:
sF29
{#GC
,:]u
09|+
[7H<
ChGg
'6J~Um
-\6G5
#ep~(
>4|6eXg_e
!#QRFt
a;*
!UMU`*
cuxG
'pSN.F
~yhZ
z$9)~
G1b1
6c&0|vvX
-,O'-U
(vQF
:'&l
tv 
jTuf
?uWS
k`'^
jA(U
KsF8
V,s>
KSV<
:Vlq
mOD:V
SNtu
=mT=
~9ob
F|'|,
)]hR
CPBQ
9@u,
,a:z
$* I
p618
Tiid
2d\v
zxNIjo
yS/h
q27_A
VDPr
]l6'
uE]*P
{L&W
feop(
uaqf
XLuC'4
<f7_
\r^mX
PG$$e
9966
hl5v
s.Q;
}%^Z
+_6S
xp$=S
B.z\85p
d!{G
TK#|
&TR::
[/5l
MS[;6
'A,6y-
Gew}
X @l(&
MGrB
vqw0
I&\w
d}i&
=y.g^
D514p
'4\&Q{
dE\,"
/U$n
m>FC*a7H
N#ih
 T;6P/Arc
s>a,
mZKB
zlVO
R-0(
t2U 
5dO7
!;y0
yG/9
{a"r
uxX/
|!yX
K. 9
W!Uf
@#i4$N
_.oG
Fgi?)
a]?xG
N=JR_"
 vJza
9&)A
3w2URu
~:/3
RH/Y
ClQ(|
7wKR
u)4A
k%bf
#:}H
LT$/
g9rB
5'0v2ZP
>n{J
LbWf
VGG@
t=\z
>7^0g
mS'7
C[L6
xxH}
aXvC
B.,~
v'A>M6
we?0
]r}R{
/l?Y
&H/T
QoOG
mK<v
co7S
Fm{#t
j0ksJ
sV u
&8@Cb
"2[j
Ew`)9Q
%,Il
12v)
Y*<i
Y,_M
hnM<
.r&I|C
e]g?
XNU`{3
8q-S*]X
(G]U
hW*m
"?xF
27d7
dWry
"e.&
FN|p
rixZ
+Z#O
vW3N&
sD9>&
(d4t8
k/sn
 4m/
#~X,
 &Y&_|
b@`" 
b=G3
MZL}
q6Kl
orOF
EQuM}
JZIX
6O|T%
V3 s
,ShfPQ
h`Zr
6_wEX
x3"
hFcg
VbfOc,p
KT8v
:^5[
tq}a
T;&)
AWt.
#t9;@Z
wA?}
ZB`!
zG2m8
 N+B
rkqg
<zT/
hW_z
@*I|
7$U8[
@1OJ
J$/\
CKh/Q
<4}->
Y{.-
eN.d
I{i3|G
|XYl
RtIF
}>Yx
}9]Jn+LhyK
9]ZV
|s(H
/`P*d#
8sOy
.4+w
A%N_A
9dYeiJ
qF{qc
-D65K
:NAy
8pe7?
CBI]6
GTsW
~,ue`
axfb5
%IW;"!*
k26C*
,7~5d
f{A 
8= zp
S<Fb
Ksg4X
)Fmk
&V6J
7GK2
CVcn
#S_U
dhWTh
k"5d
;bwP*
E;5k
l7@J
A9ur
C6DN
2p"6
Xz"7
&c_-o
5b!g
~5c^
DsBV
*hsD
C-gr
W`c[
C\lVQ
67-s
z/B,9d
[.[@
y#y&Jb
4S>:
C!OFtq74
u6Bm
p-6\D 
>ztq
-LTY/:]
od?;7y
?dt]X
!3mmXs
&8W
t``4*O
\43n7
tA`KO/3G!
?HP4
Iw,e=2-b[
T-k_
*gFBk
F7!z
 FLK
GL.n
N=j`
<C"?
k&P-
.AJ[
0&-[U
wT/`
i4a."
g5}6
yJ;Bf
?/p|
1Ag a
G0Tv~:
t`+T
e_x
E!-<p
; E6
dHHp
=&sf9
z+4/\M
"CJ\
35-w
Ye80D=
<YGr+
Bs'n
,ARu@y6
!D]#t^;Gc
)_{cV
Z#Pe
.LH)
1FV\
>p00<
Ff,n
G?g~:
~7'j
Sd:z
w+Ce
&w**
u+e*
a(hq
0M2~@p
![7{
rX&O0
UY6[E
Av $1
s(//
|_1<
$GIRu
6@['
.yAu[7
YO}':
+A*Z<Z
9oB#
G2bQ
M(F
O7v%
V<S'
+Ei`
CGP%AI
ul2
52pk
 8ff
_Lx6
Ne\#
E&^G
RrBoN
~If D
xS/
N!vh
,%l*
4W{(
g|FeW
(1O\,n
K#3'!
rK}^
a|gj(
G[R{(
)pa+
{zFd
bpFh
zz2K
3M5cWAK
[;1/
;`Fzc
Jq?a
RC4 part of OpenSSL 1.0.2h  3 May 2016
B.6?
-;eU
U1(\Q
mSx@
b}$l
~)p$w
11eU%
z^KD
  @ 
Infinity
Infinity
@UUUUU
/tmp/perf-%d.map
333333
\u0000
 \u0001
 \u0002
 \u0003
 \u0004
 \u0005
 \u0006
 \u0007
     \t
     \n
     \u000b
     \r
     \u000e
 \u000f
 \u0010
 \u0011
 \u0012
 \u0013
 \u0014
 \u0015
 \u0016
 \u0017
 \u0018
 \u0019
 \u001a
 \u001b
 \u001c
 \u001d
 \u001e
 \u001f
      !
      \"
     #
      $
      %
      &
      '
      (
      )
      *
      +
      ,
      -
      .
      /
      0
      1
      2
      3
      4
      5
      6
      7
      8
      9
      :
      ;
      <
      =
      >
      ?
      @
      A
      B
      C
      D
      E
      F
      G
      H
      I
      J
      K
      L
      M
      N
      O
      P
      Q
      R
      S
      T
      U
      V
      W
      X
      Y
      Z
      [
      \\
     ]
      ^
      _
      `
      a
      b
      c
      d
      e
      f
      g
      h
      i
      j
      k
      l
      m
      n
      o
      p
      q
      r
      s
      t
      u
      v
      w
      x
      y
      z
      {
      |
      }
      ~
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
0123456789ABCDEF
dddddddddddddddddddddddddddddddddddddddd
ddddddddddddd
ddddddddddddddddddddddddddd
ddddddddddddddddddddddddddddd
vH7B
W4vC
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTKKTTKKKKKKKKKKKKKKKKKKKKKKKKKKKTTTTTTKKKKKKKKKTTTT
?1cb
{9IUUUUU
=LUUUUU
cUUUUU
"mm?
DC?h
?sS`
?v<y5
=UUUUUU
UUUUU
?DR>
33333
NEJ(~
-Dt>
@ %z8
2.7.0
--expose_debug_as=v8debug
--typed_array_max_size_in_heap=0
|@// Hello, and welcome to hacking node.js!
// This file is invoked by node::LoadEnvironment in src/node.cc, and is
// responsible for bootstrapping the node.js core. As special caution is given
// to the performance of the startup process, many dependencies are invoked
// lazily.
'use strict';
(function(process) {
  this.global = this;
  function startup() {
    var EventEmitter = NativeModule.require('events');
    process._eventsCount = 0;
    Object.setPrototypeOf(process, Object.create(EventEmitter.prototype, {
      constructor: {
        value: process.constructor
      }
    }));
    EventEmitter.call(process);
    process.EventEmitter = EventEmitter; // process.EventEmitter is deprecated
    // do this good and early, since it handles errors.
    startup.processFatal();
    startup.globalVariables();
    startup.globalTimeouts();
    startup.globalConsole();
    startup.processAssert();
    startup.processConfig();
    startup.processNextTick();
    startup.processPromises();
    startup.processStdio();
    startup.processKillAndExit();
    startup.processSignalHandlers();
    // Do not initialize channel in debugger agent, it deletes env variable
    // and the main thread won't see it.
    if (process.argv[1] !== '--debug-agent')
      startup.processChannel();
    startup.processRawDebug();
    process.argv[0] = process.execPath;
    // There are various modes that Node can run in. The most common two
    // are running from a script and running the REPL - but there are a few
    // others like the debugger or running --eval arguments. Here we decide
    // which mode we run in.
    if (NativeModule.exists('_third_party_main')) {
      // To allow people to extend Node in different ways, this hook allows
      // one to drop a file lib/_third_party_main.js into the build
      // directory which will be executed instead of Node's normal loading.
      process.nextTick(function() {
        NativeModule.require('_third_party_main');
      });
    } else if (process.argv[1] == 'debug') {
      // Start the debugger agent
      NativeModule.require('_debugger').start();
    } else if (process.argv[1] == '--debug-agent') {
      // Start the debugger agent
      NativeModule.require('_debug_agent').start();
    } else if (process.profProcess) {
      NativeModule.require('internal/v8_prof_processor');
    } else {
      // There is user code to be run
      // If this is a worker in cluster mode, start up the communication
      // channel. This needs to be done before any user code gets executed
      // (including preload modules).
      if (process.argv[1] && process.env.NODE_UNIQUE_ID) {
        var cluster = NativeModule.require('cluster');
        cluster._setupWorker();
        // Make sure it's not accidentally inherited by child processes.
        delete process.env.NODE_UNIQUE_ID;
      }
      if (process._eval != null) {
        // User passed '-e' or '--eval' arguments to Node.
        startup.preloadModules();
        evalScript('[eval]');
      } else if (process.argv[1]) {
        // make process.argv[1] into a full path
        var path = NativeModule.require('path');
        process.argv[1] = path.resolve(process.argv[1]);
        var Module = NativeModule.require('module');
        // check if user passed `-c` or `--check` arguments to Node.
        if (process._syntax_check_only != null) {
          var vm = NativeModule.require('vm');
          var fs = NativeModule.require('fs');
          var internalModule = NativeModule.require('internal/module');
          // read the source
          var filename = Module._resolveFilename(process.argv[1]);
          var source = fs.readFileSync(filename, 'utf-8');
          // remove shebang and BOM
          source = internalModule.stripBOM(source.replace(/^\#\!.*/, ''));
          // wrap it
          source = Module.wrap(source);
          // compile the script, this will throw if it fails
          new vm.Script(source, {filename: filename, displayErrors: true});
          process.exit(0);
        }
        startup.preloadModules();
        if (global.v8debug &&
            process.execArgv.some(function(arg) {
              return arg.match(/^--debug-brk(=[0-9]*)?$/);
            })) {
          // XXX Fix this terrible hack!
          //
          // Give the client program a few ticks to connect.
          // Otherwise, there's a race condition where `node debug foo.js`
          // will not be able to connect in time to catch the first
          // breakpoint message on line 1.
          //
          // A better fix would be to somehow get a message from the
          // global.v8debug object about a connection, and runMain when
          // that occurs.  --isaacs
          var debugTimeout = +process.env.NODE_DEBUG_TIMEOUT || 50;
          setTimeout(Module.runMain, debugTimeout);
        } else {
          // Main entry point into most programs:
          Module.runMain();
        }
      } else {
        // If -i or --interactive were passed, or stdin is a TTY.
        if (process._forceRepl || NativeModule.require('tty').isatty(0)) {
          // REPL
          var cliRepl = NativeModule.require('internal/repl');
          cliRepl.createInternalRepl(process.env, function(err, repl) {
            if (err) {
              throw err;
            }
            repl.on('exit', function() {
              if (repl._flushing) {
                repl.pause();
                return repl.once('flushHistory', function() {
                  process.exit();
                });
              }
              process.exit();
            });
          });
        } else {
          // Read all of stdin - execute it.
          process.stdin.setEncoding('utf8');
          var code = '';
          process.stdin.on('data', function(d) {
            code += d;
          });
          process.stdin.on('end', function() {
            process._eval = code;
            evalScript('[stdin]');
          });
        }
      }
    }
  startup.globalVariables = function() {
    global.process = process;
    global.global = global;
    global.GLOBAL = global;
    global.root = global;
    global.Buffer = NativeModule.require('buffer').Buffer;
    process.domain = null;
    process._exiting = false;
  };
  startup.globalTimeouts = function() {
    const timers = NativeModule.require('timers');
    global.clearImmediate = timers.clearImmediate;
    global.clearInterval = timers.clearInterval;
    global.clearTimeout = timers.clearTimeout;
    global.setImmediate = timers.setImmediate;
    global.setInterval = timers.setInterval;
    global.setTimeout = timers.setTimeout;
  };
  startup.globalConsole = function() {
    global.__defineGetter__('console', function() {
      return NativeModule.require('console');
    });
  };
  startup._lazyConstants = null;
  startup.lazyConstants = function() {
    if (!startup._lazyConstants) {
      startup._lazyConstants = process.binding('constants');
    }
    return startup._lazyConstants;
  };
  startup.processFatal = function() {
    process._fatalException = function(er) {
      var caught;
      if (process.domain && process.domain._errorHandler)
        caught = process.domain._errorHandler(er) || caught;
      if (!caught)
        caught = process.emit('uncaughtException', er);
      // If someone handled it, then great.  otherwise, die in C++ land
      // since that means that we'll exit the process, emit the 'exit' event
      if (!caught) {
        try {
          if (!process._exiting) {
            process._exiting = true;
            process.emit('exit', 1);
          }
        } catch (er) {
          // nothing to be done about it at this point.
        }
      // if we handled an error, then make sure any ticks get processed
      } else {
        NativeModule.require('timers').setImmediate(process._tickCallback);
      }
      return caught;
    };
  };
  var assert;
  startup.processAssert = function() {
    assert = process.assert = function(x, msg) {
      if (!x) throw new Error(msg || 'assertion error');
    };
  };
  startup.processConfig = function() {
    // used for `process.config`, but not a real module
    var config = NativeModule._source.config;
    delete NativeModule._source.config;
    // strip the gyp comment line at the beginning
    config = config.split('\n')
        .slice(1)
        .join('\n')
        .replace(/"/g, '\\"')
        .replace(/'/g, '"');
    process.config = JSON.parse(config, function(key, value) {
      if (value === 'true') return true;
      if (value === 'false') return false;
      return value;
    });
  };
  var addPendingUnhandledRejection;
  var hasBeenNotifiedProperty = new WeakMap();
  startup.processNextTick = function() {
    var nextTickQueue = [];
    var pendingUnhandledRejections = [];
    var microtasksScheduled = false;
    // Used to run V8's micro task queue.
    var _runMicrotasks = {};
    // *Must* match Environment::TickInfo::Fields in src/env.h.
    var kIndex = 0;
    var kLength = 1;
    process.nextTick = nextTick;
    // Needs to be accessible from beyond this scope.
    process._tickCallback = _tickCallback;
    process._tickDomainCallback = _tickDomainCallback;
    // This tickInfo thing is used so that the C++ code in src/node.cc
    // can have easy access to our nextTick state, and avoid unnecessary
    // calls into JS land.
    const tickInfo = process._setupNextTick(_tickCallback, _runMicrotasks);
    _runMicrotasks = _runMicrotasks.runMicrotasks;
    function tickDone() {
      if (tickInfo[kLength] !== 0) {
        if (tickInfo[kLength] <= tickInfo[kIndex]) {
          nextTickQueue = [];
          tickInfo[kLength] = 0;
        } else {
          nextTickQueue.splice(0, tickInfo[kIndex]);
          tickInfo[kLength] = nextTickQueue.length;
        }
      }
      tickInfo[kIndex] = 0;
    }
    function scheduleMicrotasks() {
      if (microtasksScheduled)
        return;
      nextTickQueue.push({
        callback: runMicrotasksCallback,
        domain: null
      });
      tickInfo[kLength]++;
      microtasksScheduled = true;
    }
    function runMicrotasksCallback() {
      microtasksScheduled = false;
      _runMicrotasks();
      if (tickInfo[kIndex] < tickInfo[kLength] ||
          emitPendingUnhandledRejections())
        scheduleMicrotasks();
    }
    // Run callbacks that have no domain.
    // Using domains will cause this to be overridden.
    function _tickCallback() {
      var callback, args, tock;
      do {
        while (tickInfo[kIndex] < tickInfo[kLength]) {
          tock = nextTickQueue[tickInfo[kIndex]++];
          callback = tock.callback;
          args = tock.args;
          // Using separate callback execution functions helps to limit the
          // scope of DEOPTs caused by using try blocks and allows direct
          // callback invocation with small numbers of arguments to avoid the
          // performance hit associated with using `fn.apply()`
          if (args === undefined) {
            nextTickCallbackWith0Args(callback);
          } else {
            switch (args.length) {
              case 1:
                nextTickCallbackWith1Arg(callback, args[0]);
                break;
              case 2:
                nextTickCallbackWith2Args(callback, args[0], args[1]);
                break;
              case 3:
                nextTickCallbackWith3Args(callback, args[0], args[1], args[2]);
                break;
              default:
                nextTickCallbackWithManyArgs(callback, args);
            }
          }
          if (1e4 < tickInfo[kIndex])
            tickDone();
        }
        tickDone();
        _runMicrotasks();
        emitPendingUnhandledRejections();
      } while (tickInfo[kLength] !== 0);
    }
    function _tickDomainCallback() {
      var callback, domain, args, tock;
      do {
        while (tickInfo[kIndex] < tickInfo[kLength]) {
          tock = nextTickQueue[tickInfo[kIndex]++];
          callback = tock.callback;
          domain = tock.domain;
          args = tock.args;
          if (domain)
            domain.enter();
          // Using separate callback execution functions helps to limit the
          // scope of DEOPTs caused by using try blocks and allows direct
          // callback invocation with small numbers of arguments to avoid the
          // performance hit associated with using `fn.apply()`
          if (args === undefined) {
            nextTickCallbackWith0Args(callback);
          } else {
            switch (args.length) {
              case 1:
                nextTickCallbackWith1Arg(callback, args[0]);
                break;
              case 2:
                nextTickCallbackWith2Args(callback, args[0], args[1]);
                break;
              case 3:
                nextTickCallbackWith3Args(callback, args[0], args[1], args[2]);
                break;
              default:
                nextTickCallbackWithManyArgs(callback, args);
            }
          }
          if (1e4 < tickInfo[kIndex])
            tickDone();
          if (domain)
            domain.exit();
        }
        tickDone();
        _runMicrotasks();
        emitPendingUnhandledRejections();
      } while (tickInfo[kLength] !== 0);
    }
    function nextTickCallbackWith0Args(callback) {
      var threw = true;
      try {
        callback();
        threw = false;
      } finally {
        if (threw)
          tickDone();
      }
    }
    function nextTickCallbackWith1Arg(callback, arg1) {
      var threw = true;
      try {
        callback(arg1);
        threw = false;
      } finally {
        if (threw)
          tickDone();
      }
    }
    function nextTickCallbackWith2Args(callback, arg1, arg2) {
      var threw = true;
      try {
        callback(arg1, arg2);
        threw = false;
      } finally {
        if (threw)
          tickDone();
      }
    }
    function nextTickCallbackWith3Args(callback, arg1, arg2, arg3) {
      var threw = true;
      try {
        callback(arg1, arg2, arg3);
        threw = false;
      } finally {
        if (threw)
          tickDone();
      }
    }
    function nextTickCallbackWithManyArgs(callback, args) {
      var threw = true;
      try {
        callback.apply(null, args);
        threw = false;
      } finally {
        if (threw)
          tickDone();
      }
    }
    function TickObject(c, args) {
      this.callback = c;
      this.domain = process.domain || null;
      this.args = args;
    }
    function nextTick(callback) {
      // on the way out, don't bother. it won't get fired anyway.
      if (process._exiting)
        return;
      var args;
      if (arguments.length > 1) {
        args = [];
        for (var i = 1; i < arguments.length; i++)
          args.push(arguments[i]);
      }
      nextTickQueue.push(new TickObject(callback, args));
      tickInfo[kLength]++;
    }
    function emitPendingUnhandledRejections() {
      var hadListeners = false;
      while (pendingUnhandledRejections.length > 0) {
        var promise = pendingUnhandledRejections.shift();
        var reason = pendingUnhandledRejections.shift();
        if (hasBeenNotifiedProperty.get(promise) === false) {
          hasBeenNotifiedProperty.set(promise, true);
          if (!process.emit('unhandledRejection', reason, promise)) {
            // Nobody is listening.
            // TODO(petkaantonov) Take some default action, see #830
          } else {
            hadListeners = true;
          }
        }
      }
      return hadListeners;
    }
    addPendingUnhandledRejection = function(promise, reason) {
      pendingUnhandledRejections.push(promise, reason);
      scheduleMicrotasks();
    };
  };
  startup.processPromises = function() {
    var promiseRejectEvent = process._promiseRejectEvent;
    function unhandledRejection(promise, reason) {
      hasBeenNotifiedProperty.set(promise, false);
      addPendingUnhandledRejection(promise, reason);
    }
    function rejectionHandled(promise) {
      var hasBeenNotified = hasBeenNotifiedProperty.get(promise);
      if (hasBeenNotified !== undefined) {
        hasBeenNotifiedProperty.delete(promise);
        if (hasBeenNotified === true) {
          process.nextTick(function() {
            process.emit('rejectionHandled', promise);
          });
        }
      }
    }
    process._setupPromises(function(event, promise, reason) {
      if (event === promiseRejectEvent.unhandled)
        unhandledRejection(promise, reason);
      else if (event === promiseRejectEvent.handled)
        rejectionHandled(promise);
      else
        NativeModule.require('assert').fail('unexpected PromiseRejectEvent');
    });
  };
  function evalScript(name) {
    var Module = NativeModule.require('module');
    var path = NativeModule.require('path');
    try {
      var cwd = process.cwd();
    } catch (e) {
      // getcwd(3) can fail if the current working directory has been deleted.
      // Fall back to the directory name of the (absolute) executable path.
      // It's not really correct but what are the alternatives?
      cwd = path.dirname(process.execPath);
    }
    var module = new Module(name);
    module.filename = path.join(cwd, name);
    module.paths = Module._nodeModulePaths(cwd);
    var script = process._eval;
    var body = script;
    script = `global.__filename = ${JSON.stringify(name)};\n` +
             'global.exports = exports;\n' +
             'global.module = module;\n' +
             'global.__dirname = __dirname;\n' +
             'global.require = require;\n' +
             'return require("vm").runInThisContext(' +
             `${JSON.stringify(body)}, { filename: ` +
             `${JSON.stringify(name)} });\n`;
    // Defer evaluation for a tick.  This is a workaround for deferred
    // events not firing when evaluating scripts from the command line,
    // see https://github.com/nodejs/node/issues/1600.
    process.nextTick(function() {
      var result = module._compile(script, `${name}-wrapper`);
      if (process._print_eval) console.log(result);
    });
  function createWritableStdioStream(fd) {
    var stream;
    var tty_wrap = process.binding('tty_wrap');
    // Note stream._type is used for test-module-load-list.js
    switch (tty_wrap.guessHandleType(fd)) {
      case 'TTY':
        var tty = NativeModule.require('tty');
        stream = new tty.WriteStream(fd);
        stream._type = 'tty';
        break;
      case 'FILE':
        var fs = NativeModule.require('fs');
        stream = new fs.SyncWriteStream(fd, { autoClose: false });
        stream._type = 'fs';
        break;
      case 'PIPE':
      case 'TCP':
        var net = NativeModule.require('net');
        stream = new net.Socket({
          fd: fd,
          readable: false,
          writable: true
        });
        stream._type = 'pipe';
        break;
      default:
        // Probably an error on in uv_guess_handle()
        throw new Error('Implement me. Unknown stream file type!');
    }
    // For supporting legacy API we put the FD here.
    stream.fd = fd;
    stream._isStdio = true;
    return stream;
  startup.processStdio = function() {
    var stdin, stdout, stderr;
    process.__defineGetter__('stdout', function() {
      if (stdout) return stdout;
      stdout = createWritableStdioStream(1);
      stdout.destroy = stdout.destroySoon = function(er) {
        er = er || new Error('process.stdout cannot be closed.');
        stdout.emit('error', er);
      };
      if (stdout.isTTY) {
        process.on('SIGWINCH', function() {
          stdout._refreshSize();
        });
      }
      return stdout;
    });
    process.__defineGetter__('stderr', function() {
      if (stderr) return stderr;
      stderr = createWritableStdioStream(2);
      stderr.destroy = stderr.destroySoon = function(er) {
        er = er || new Error('process.stderr cannot be closed.');
        stderr.emit('error', er);
      };
      if (stderr.isTTY) {
        process.on('SIGWINCH', function() {
          stderr._refreshSize();
        });
      }
      return stderr;
    });
    process.__defineGetter__('stdin', function() {
      if (stdin) return stdin;
      var tty_wrap = process.binding('tty_wrap');
      var fd = 0;
      switch (tty_wrap.guessHandleType(fd)) {
        case 'TTY':
          var tty = NativeModule.require('tty');
          stdin = new tty.ReadStream(fd, {
            highWaterMark: 0,
            readable: true,
            writable: false
          });
          break;
        case 'FILE':
          var fs = NativeModule.require('fs');
          stdin = new fs.ReadStream(null, { fd: fd, autoClose: false });
          break;
        case 'PIPE':
        case 'TCP':
          var net = NativeModule.require('net');
          // It could be that process has been started with an IPC channel
          // sitting on fd=0, in such case the pipe for this fd is already
          // present and creating a new one will lead to the assertion failure
          // in libuv.
          if (process._channel && process._channel.fd === fd) {
            stdin = new net.Socket({
              handle: process._channel,
              readable: true,
              writable: false
            });
          } else {
            stdin = new net.Socket({
              fd: fd,
              readable: true,
              writable: false
            });
          }
          // Make sure the stdin can't be `.end()`-ed
          stdin._writableState.ended = true;
          break;
        default:
          // Probably an error on in uv_guess_handle()
          throw new Error('Implement me. Unknown stdin file type!');
      }
      // For supporting legacy API we put the FD here.
      stdin.fd = fd;
      // stdin starts out life in a paused state, but node doesn't
      // know yet.  Explicitly to readStop() it to put it in the
      // not-reading state.
      if (stdin._handle && stdin._handle.readStop) {
        stdin._handle.reading = false;
        stdin._readableState.reading = false;
        stdin._handle.readStop();
      }
      // if the user calls stdin.pause(), then we need to stop reading
      // immediately, so that the process can close down.
      stdin.on('pause', function() {
        if (!stdin._handle)
          return;
        stdin._readableState.reading = false;
        stdin._handle.reading = false;
        stdin._handle.readStop();
      });
      return stdin;
    });
    process.openStdin = function() {
      process.stdin.resume();
      return process.stdin;
    };
  };
  startup.processKillAndExit = function() {
    process.exit = function(code) {
      if (code || code === 0)
        process.exitCode = code;
      if (!process._exiting) {
        process._exiting = true;
        process.emit('exit', process.exitCode || 0);
      }
      process.reallyExit(process.exitCode || 0);
    };
    process.kill = function(pid, sig) {
      var err;
      if (pid != (pid | 0)) {
        throw new TypeError('invalid pid');
      }
      // preserve null signal
      if (0 === sig) {
        err = process._kill(pid, 0);
      } else {
        sig = sig || 'SIGTERM';
        if (startup.lazyConstants()[sig] &&
            sig.slice(0, 3) === 'SIG') {
          err = process._kill(pid, startup.lazyConstants()[sig]);
        } else {
          throw new Error(`Unknown signal: ${sig}`);
        }
      }
      if (err) {
        var errnoException = NativeModule.require('util')._errnoException;
        throw errnoException(err, 'kill');
      }
      return true;
    };
  };
  startup.processSignalHandlers = function() {
    // Load events module in order to access prototype elements on process like
    // process.addListener.
    var signalWraps = {};
    function isSignal(event) {
      return typeof event === 'string' &&
             event.slice(0, 3) === 'SIG' &&
             startup.lazyConstants().hasOwnProperty(event);
    }
    // Detect presence of a listener for the special signal types
    process.on('newListener', function(type, listener) {
      if (isSignal(type) &&
          !signalWraps.hasOwnProperty(type)) {
        var Signal = process.binding('signal_wrap').Signal;
        var wrap = new Signal();
        wrap.unref();
        wrap.onsignal = function() { process.emit(type); };
        var signum = startup.lazyConstants()[type];
        var err = wrap.start(signum);
        if (err) {
          wrap.close();
          var errnoException = NativeModule.require('util')._errnoException;
          throw errnoException(err, 'uv_signal_start');
        }
        signalWraps[type] = wrap;
      }
    });
    process.on('removeListener', function(type, listener) {
      if (signalWraps.hasOwnProperty(type) && this.listenerCount(type) === 0) {
        signalWraps[type].close();
        delete signalWraps[type];
      }
    });
  };
  startup.processChannel = function() {
    // If we were spawned with env NODE_CHANNEL_FD then load that up and
    // start parsing data from that stream.
    if (process.env.NODE_CHANNEL_FD) {
      var fd = parseInt(process.env.NODE_CHANNEL_FD, 10);
      assert(fd >= 0);
      // Make sure it's not accidentally inherited by child processes.
      delete process.env.NODE_CHANNEL_FD;
      var cp = NativeModule.require('child_process');
      // Load tcp_wrap to avoid situation where we might immediately receive
      // a message.
      // FIXME is this really necessary?
      process.binding('tcp_wrap');
      cp._forkChild(fd);
      assert(process.send);
    }
  };
  startup.processRawDebug = function() {
    var format = NativeModule.require('util').format;
    var rawDebug = process._rawDebug;
    process._rawDebug = function() {
      rawDebug(format.apply(null, arguments));
    };
  };
  // Load preload modules
  startup.preloadModules = function() {
    if (process._preload_modules) {
      NativeModule.require('module')._preloadModules(process._preload_modules);
    }
  };
  // Below you find a minimal module system, which is used to load the node
  // core modules found in lib/*.js. All core modules are compiled into the
  // node binary, so they can be loaded faster.
  var ContextifyScript = process.binding('contextify').ContextifyScript;
  function runInThisContext(code, options) {
    var script = new ContextifyScript(code, options);
    return script.runInThisContext();
  function NativeModule(id) {
    this.filename = `${id}.js`;
    this.id = id;
    this.exports = {};
    this.loaded = false;
    this.loading = true;
  NativeModule._source = process.binding('natives');
  NativeModule._cache = {};
  NativeModule.require = function(id) {
    if (id == 'native_module') {
      return NativeModule;
    }
    var cached = NativeModule.getCached(id);
    if (cached && (cached.loaded || cached.loading)) {
      return cached.exports;
    }
    if (!NativeModule.exists(id)) {
      throw new Error(`No such native module ${id}`);
    }
    process.moduleLoadList.push(`NativeModule ${id}`);
    var nativeModule = new NativeModule(id);
    nativeModule.cache();
    nativeModule.compile();
    return nativeModule.exports;
  };
  NativeModule.getCached = function(id) {
    return NativeModule._cache[id];
  };
  NativeModule.exists = function(id) {
    return NativeModule._source.hasOwnProperty(id);
  };
  const EXPOSE_INTERNALS = process.execArgv.some(function(arg) {
    return arg.match(/^--expose[-_]internals$/);
  });
  if (EXPOSE_INTERNALS) {
    NativeModule.nonInternalExists = NativeModule.exists;
    NativeModule.isInternal = function(id) {
      return false;
    };
  } else {
    NativeModule.nonInternalExists = function(id) {
      return NativeModule.exists(id) && !NativeModule.isInternal(id);
    };
    NativeModule.isInternal = function(id) {
      return id.startsWith('internal/');
    };
  NativeModule.getSource = function(id) {
    return NativeModule._source[id];
  };
  NativeModule.wrap = function(script) {
    return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];
  };
  NativeModule.wrapper = [
    '(function (exports, require, module, __filename, __dirname) { ',
    '\n});'
  ];
  NativeModule.prototype.compile = function() {
    var source = NativeModule.getSource(this.id);
    source = NativeModule.wrap(source);
    this.loading = true;
    try {
      var fn = runInThisContext(source, {
        filename: this.filename,
        lineOffset: 0
      });
      fn(this.exports, NativeModule.require, this, this.filename);
      this.loaded = true;
    } finally {
      this.loading = false;
    }
  };
  NativeModule.prototype.cache = function() {
    NativeModule._cache[this.id] = this;
  };
  startup();
'use strict';
const assert = require('assert');
const net = require('net');
const util = require('util');
const Buffer = require('buffer').Buffer;
const Transform = require('stream').Transform;
exports.start = function start() {
  var agent = new Agent();
  // Do not let `agent.listen()` request listening from cluster master
  const cluster = require('cluster');
  cluster.isWorker = false;
  cluster.isMaster = true;
  agent.on('error', function(err) {
    process._rawDebug(err.stack || err);
  });
  agent.listen(process._debugAPI.port, function() {
    var addr = this.address();
    process._rawDebug('Debugger listening on port %d', addr.port);
    process._debugAPI.notifyListen();
  });
  // Just to spin-off events
  // TODO(indutny): Figure out why node.cc isn't doing this
  setImmediate(function() {
  });
  process._debugAPI.onclose = function() {
    // We don't care about it, but it prevents loop from cleaning up gently
    // NOTE: removeAllListeners won't work, as it doesn't call `removeListener`
    process.listeners('SIGWINCH').forEach(function(fn) {
      process.removeListener('SIGWINCH', fn);
    });
    agent.close();
  };
  // Not used now, but anyway
  return agent;
function Agent() {
  net.Server.call(this, this.onConnection);
  this.first = true;
  this.binding = process._debugAPI;
  assert(this.binding, 'Debugger agent running without bindings!');
  var self = this;
  this.binding.onmessage = function(msg) {
    self.clients.forEach(function(client) {
      client.send({}, msg);
    });
  };
  this.clients = [];
util.inherits(Agent, net.Server);
Agent.prototype.onConnection = function onConnection(socket) {
  var c = new Client(this, socket);
  c.start();
  this.clients.push(c);
  var self = this;
  c.once('close', function() {
    var index = self.clients.indexOf(c);
    assert(index !== -1);
    self.clients.splice(index, 1);
  });
Agent.prototype.notifyWait = function notifyWait() {
  if (this.first)
    this.binding.notifyWait();
  this.first = false;
function Client(agent, socket) {
  Transform.call(this, {
    readableObjectMode: true
  });
  this.agent = agent;
  this.binding = this.agent.binding;
  this.socket = socket;
  // Parse incoming data
  this.state = 'headers';
  this.headers = {};
  this.buffer = '';
  socket.pipe(this);
  this.on('data', this.onCommand);
  var self = this;
  this.socket.on('close', function() {
    self.destroy();
  });
util.inherits(Client, Transform);
Client.prototype.destroy = function destroy(msg) {
  this.socket.destroy();
  this.emit('close');
Client.prototype._transform = function _transform(data, enc, cb) {
  cb();
  this.buffer += data;
  while (true) {
    if (this.state === 'headers') {
      // Not enough data
      if (!this.buffer.includes('\r\n'))
        break;
      if (this.buffer.startsWith('\r\n')) {
        this.buffer = this.buffer.slice(2);
        this.state = 'body';
        continue;
      }
      // Match:
      //   Header-name: header-value\r\n
      var match = this.buffer.match(/^([^:\s\r\n]+)\s*:\s*([^\s\r\n]+)\r\n/);
      if (!match)
        return this.destroy('Expected header, but failed to parse it');
      this.headers[match[1].toLowerCase()] = match[2];
      this.buffer = this.buffer.slice(match[0].length);
    } else {
      var len = this.headers['content-length'];
      if (len === undefined)
        return this.destroy('Expected content-length');
      len = len | 0;
      if (Buffer.byteLength(this.buffer) < len)
        break;
      this.push(new Command(this.headers, this.buffer.slice(0, len)));
      this.state = 'headers';
      this.buffer = this.buffer.slice(len);
      this.headers = {};
    }
Client.prototype.send = function send(headers, data) {
  if (!data)
    data = '';
  var out = [];
  Object.keys(headers).forEach(function(key) {
    out.push(key + ': ' + headers[key]);
  });
  out.push('Content-Length: ' + Buffer.byteLength(data), '');
  this.socket.cork();
  this.socket.write(out.join('\r\n') + '\r\n');
  if (data.length > 0)
    this.socket.write(data);
  this.socket.uncork();
Client.prototype.start = function start() {
  this.send({
    Type: 'connect',
    'V8-Version': process.versions.v8,
    'Protocol-Version': 1,
    'Embedding-Host': 'node ' + process.version
  });
Client.prototype.onCommand = function onCommand(cmd) {
  this.binding.sendCommand(cmd.body);
  this.agent.notifyWait();
function Command(headers, body) {
  this.headers = headers;
  this.body = body;
'use strict';
const util = require('util');
const path = require('path');
const net = require('net');
const vm = require('vm');
const Module = require('module');
const repl = require('repl');
const inherits = util.inherits;
const assert = require('assert');
const spawn = require('child_process').spawn;
const Buffer = require('buffer').Buffer;
exports.start = function(argv, stdin, stdout) {
  argv || (argv = process.argv.slice(2));
  if (argv.length < 1) {
    console.error('Usage: node debug script.js');
    console.error('       node debug <host>:<port>');
    console.error('       node debug -p <pid>');
    process.exit(1);
  // Setup input/output streams
  stdin = stdin || process.stdin;
  stdout = stdout || process.stdout;
  const args = [`--debug-brk=${exports.port}`].concat(argv);
  const interface_ = new Interface(stdin, stdout, args);
  stdin.resume();
  process.on('uncaughtException', function(e) {
    console.error("There was an internal error in Node's debugger. " +
        'Please report this bug.');
    console.error(e.message);
    console.error(e.stack);
    if (interface_.child) interface_.child.kill();
    process.exit(1);
  });
exports.port = process.debugPort;
// Parser/Serializer for V8 debugger protocol
// https://github.com/v8/v8/wiki/Debugging-Protocol
// Usage:
//    p = new Protocol();
//    p.onResponse = function(res) {
//      // do stuff with response from V8
//    };
//    socket.setEncoding('utf8');
//    socket.on('data', function(s) {
//      // Pass strings into the protocol
//      p.execute(s);
//    });
function Protocol() {
  this._newRes();
exports.Protocol = Protocol;
Protocol.prototype._newRes = function(raw) {
  this.res = { raw: raw || '', headers: {} };
  this.state = 'headers';
  this.reqSeq = 1;
  this.execute('');
Protocol.prototype.execute = function(d) {
  var res = this.res;
  res.raw += d;
  switch (this.state) {
    case 'headers':
      var endHeaderIndex = res.raw.indexOf('\r\n\r\n');
      if (endHeaderIndex < 0) break;
      var rawHeader = res.raw.slice(0, endHeaderIndex);
      var endHeaderByteIndex = Buffer.byteLength(rawHeader, 'utf8');
      var lines = rawHeader.split('\r\n');
      for (var i = 0; i < lines.length; i++) {
        var kv = lines[i].split(/: +/);
        res.headers[kv[0]] = kv[1];
      }
      this.contentLength = +res.headers['Content-Length'];
      this.bodyStartByteIndex = endHeaderByteIndex + 4;
      this.state = 'body';
      var len = Buffer.byteLength(res.raw, 'utf8');
      if (len - this.bodyStartByteIndex < this.contentLength) {
        break;
      }
      // falls through
    case 'body':
      var resRawByteLength = Buffer.byteLength(res.raw, 'utf8');
      if (resRawByteLength - this.bodyStartByteIndex >= this.contentLength) {
        var buf = new Buffer(resRawByteLength);
        buf.write(res.raw, 0, resRawByteLength, 'utf8');
        res.body =
            buf.slice(this.bodyStartByteIndex,
                      this.bodyStartByteIndex +
                      this.contentLength).toString('utf8');
        // JSON parse body?
        res.body = res.body.length ? JSON.parse(res.body) : {};
        // Done!
        this.onResponse(res);
        this._newRes(buf.slice(this.bodyStartByteIndex +
                               this.contentLength).toString('utf8'));
      }
      break;
    default:
      throw new Error('Unknown state');
Protocol.prototype.serialize = function(req) {
  req.type = 'request';
  req.seq = this.reqSeq++;
  var json = JSON.stringify(req);
  return 'Content-Length: ' + Buffer.byteLength(json, 'utf8') +
         '\r\n\r\n' + json;
const NO_FRAME = -1;
function Client() {
  net.Socket.call(this);
  var protocol = this.protocol = new Protocol(this);
  this._reqCallbacks = [];
  var socket = this;
  this.currentFrame = NO_FRAME;
  this.currentSourceLine = -1;
  this.handles = {};
  this.scripts = {};
  this.breakpoints = [];
  // Note that 'Protocol' requires strings instead of Buffers.
  socket.setEncoding('utf8');
  socket.on('data', function(d) {
    protocol.execute(d);
  });
  protocol.onResponse = (res) => this._onResponse(res);
inherits(Client, net.Socket);
exports.Client = Client;
Client.prototype._addHandle = function(desc) {
  if (desc === null || typeof desc !== 'object' ||
      typeof desc.handle !== 'number') {
    return;
  this.handles[desc.handle] = desc;
  if (desc.type === 'script') {
    this._addScript(desc);
const natives = process.binding('natives');
Client.prototype._addScript = function(desc) {
  this.scripts[desc.id] = desc;
  if (desc.name) {
    desc.isNative = (desc.name.replace('.js', '') in natives) ||
                    desc.name == 'node.js';
Client.prototype._removeScript = function(desc) {
  this.scripts[desc.id] = undefined;
Client.prototype._onResponse = function(res) {
  var cb;
  var index = -1;
  this._reqCallbacks.some(function(fn, i) {
    if (fn.request_seq == res.body.request_seq) {
      cb = fn;
      index = i;
      return true;
    }
  });
  var self = this;
  var handled = false;
  if (res.headers.Type == 'connect') {
    // Request a list of scripts for our own storage.
    self.reqScripts();
    self.emit('ready');
    handled = true;
  } else if (res.body && res.body.event == 'break') {
    this.emit('break', res.body);
    handled = true;
  } else if (res.body && res.body.event == 'exception') {
    this.emit('exception', res.body);
    handled = true;
  } else if (res.body && res.body.event == 'afterCompile') {
    this._addHandle(res.body.body.script);
    handled = true;
  } else if (res.body && res.body.event == 'scriptCollected') {
    // ???
    this._removeScript(res.body.body.script);
    handled = true;
  } else if (res.body && res.body.event === 'compileError') {
    // This event is not used anywhere right now, perhaps somewhere in the
    // future?
    handled = true;
  if (cb) {
    this._reqCallbacks.splice(index, 1);
    handled = true;
    var err = res.success === false && (res.message || true) ||
              res.body.success === false && (res.body.message || true);
    cb(err, res.body && res.body.body || res.body, res);
  if (!handled) this.emit('unhandledResponse', res.body);
Client.prototype.req = function(req, cb) {
  this.write(this.protocol.serialize(req));
  cb.request_seq = req.seq;
  this._reqCallbacks.push(cb);
Client.prototype.reqVersion = function(cb) {
  cb = cb || function() {};
  this.req({ command: 'version' }, function(err, body, res) {
    if (err) return cb(err);
    cb(null, res.body.body.V8Version, res.body.running);
  });
Client.prototype.reqLookup = function(refs, cb) {
  var self = this;
  // TODO: We have a cache of handle's we've already seen in this.handles
  // This can be used if we're careful.
  var req = {
    command: 'lookup',
    arguments: {
      handles: refs
    }
  };
  cb = cb || function() {};
  this.req(req, function(err, res) {
    if (err) return cb(err);
    for (var ref in res) {
      if (res[ref] !== null && typeof res[ref] === 'object') {
        self._addHandle(res[ref]);
      }
    }
    cb(null, res);
  });
Client.prototype.reqScopes = function(cb) {
  const self = this;
  const req = {
    command: 'scopes',
    arguments: {}
  };
  cb = cb || function() {};
  this.req(req, function(err, res) {
    if (err) return cb(err);
    var refs = res.scopes.map(function(scope) {
      return scope.object.ref;
    });
    self.reqLookup(refs, function(err, res) {
      if (err) return cb(err);
      var globals = Object.keys(res).map(function(key) {
        return res[key].properties.map(function(prop) {
          return prop.name;
        });
      });
      cb(null, globals.reverse());
    });
  });
// This is like reqEval, except it will look up the expression in each of the
// scopes associated with the current frame.
Client.prototype.reqEval = function(expression, cb) {
  var self = this;
  if (this.currentFrame == NO_FRAME) {
    // Only need to eval in global scope.
    this.reqFrameEval(expression, NO_FRAME, cb);
    return;
  cb = cb || function() {};
  // Otherwise we need to get the current frame to see which scopes it has.
  this.reqBacktrace(function(err, bt) {
    if (err || !bt.frames) {
      // ??
      return cb(null, {});
    }
    var frame = bt.frames[self.currentFrame];
    var evalFrames = frame.scopes.map(function(s) {
      if (!s) return;
      var x = bt.frames[s.index];
      if (!x) return;
      return x.index;
    });
    self._reqFramesEval(expression, evalFrames, cb);
  });
// Finds the first scope in the array in which the expression evals.
Client.prototype._reqFramesEval = function(expression, evalFrames, cb) {
  if (evalFrames.length == 0) {
    // Just eval in global scope.
    this.reqFrameEval(expression, NO_FRAME, cb);
    return;
  var self = this;
  var i = evalFrames.shift();
  cb = cb || function() {};
  this.reqFrameEval(expression, i, function(err, res) {
    if (!err) return cb(null, res);
    self._reqFramesEval(expression, evalFrames, cb);
  });
Client.prototype.reqFrameEval = function(expression, frame, cb) {
  var self = this;
  var req = {
    command: 'evaluate',
    arguments: { expression: expression }
  };
  if (frame == NO_FRAME) {
    req.arguments.global = true;
  } else {
    req.arguments.frame = frame;
  cb = cb || function() {};
  this.req(req, function(err, res) {
    if (!err) self._addHandle(res);
    cb(err, res);
  });
// reqBacktrace(cb)
// TODO: from, to, bottom
Client.prototype.reqBacktrace = function(cb) {
  this.req({ command: 'backtrace', arguments: { inlineRefs: true } }, cb);
// reqSetExceptionBreak(type, cb)
// TODO: from, to, bottom
Client.prototype.reqSetExceptionBreak = function(type, cb) {
  this.req({
    command: 'setexceptionbreak',
    arguments: { type: type, enabled: true }
  }, cb);
// Returns an array of objects like this:
//   { handle: 11,
//     type: 'script',
//     name: 'node.js',
//     id: 14,
//     lineOffset: 0,
//     columnOffset: 0,
//     lineCount: 562,
//     sourceStart: '(function(process) {\n\n  ',
//     sourceLength: 15939,
//     scriptType: 2,
//     compilationType: 0,
//     context: { ref: 10 },
//     text: 'node.js (lines: 562)' }
Client.prototype.reqScripts = function(cb) {
  var self = this;
  cb = cb || function() {};
  this.req({ command: 'scripts' }, function(err, res) {
    if (err) return cb(err);
    for (var i = 0; i < res.length; i++) {
      self._addHandle(res[i]);
    }
    cb(null);
  });
Client.prototype.reqContinue = function(cb) {
  this.currentFrame = NO_FRAME;
  this.req({ command: 'continue' }, cb);
Client.prototype.listbreakpoints = function(cb) {
  this.req({ command: 'listbreakpoints' }, cb);
Client.prototype.setBreakpoint = function(req, cb) {
  req = {
    command: 'setbreakpoint',
    arguments: req
  };
  this.req(req, cb);
Client.prototype.clearBreakpoint = function(req, cb) {
  req = {
    command: 'clearbreakpoint',
    arguments: req
  };
  this.req(req, cb);
Client.prototype.reqSource = function(from, to, cb) {
  var req = {
    command: 'source',
    fromLine: from,
    toLine: to
  };
  this.req(req, cb);
// client.next(1, cb);
Client.prototype.step = function(action, count, cb) {
  var req = {
    command: 'continue',
    arguments: { stepaction: action, stepcount: count }
  };
  this.currentFrame = NO_FRAME;
  this.req(req, cb);
Client.prototype.mirrorObject = function(handle, depth, cb) {
  var self = this;
  var val;
  if (handle.type === 'object') {
    // The handle looks something like this:
    // { handle: 8,
    //   type: 'object',
    //   className: 'Object',
    //   constructorFunction: { ref: 9 },
    //   protoObject: { ref: 4 },
    //   prototypeObject: { ref: 2 },
    //   properties: [ { name: 'hello', propertyType: 1, ref: 10 } ],
    //   text: '#<an Object>' }
    // For now ignore the className and constructor and prototype.
    // TJ's method of object inspection would probably be good for this:
    // https://groups.google.com/forum/?pli=1#!topic/nodejs-dev/4gkWBOimiOg
    var propertyRefs = handle.properties.map(function(p) {
      return p.ref;
    });
    cb = cb || function() {};
    this.reqLookup(propertyRefs, function(err, res) {
      if (err) {
        console.error('problem with reqLookup');
        cb(null, handle);
        return;
      }
      var mirror;
      var waiting = 1;
      if (handle.className == 'Array') {
        mirror = [];
      } else if (handle.className == 'Date') {
        mirror = new Date(handle.value);
      } else {
        mirror = {};
      }
      var keyValues = [];
      handle.properties.forEach(function(prop, i) {
        var value = res[prop.ref];
        var mirrorValue;
        if (value) {
          mirrorValue = value.value ? value.value : value.text;
        } else {
          mirrorValue = '[?]';
        }
        // Skip the 'length' property.
        if (Array.isArray(mirror) && prop.name === 'length') {
          return;
        }
        keyValues[i] = {
          name: prop.name,
          value: mirrorValue
        };
        if (value && value.handle && depth > 0) {
          waiting++;
          self.mirrorObject(value, depth - 1, function(err, result) {
            if (!err) keyValues[i].value = result;
            waitForOthers();
          });
        }
      });
      waitForOthers();
      function waitForOthers() {
        if (--waiting === 0) {
          keyValues.forEach(function(kv) {
            mirror[kv.name] = kv.value;
          });
          cb(null, mirror);
        }
      }
    });
    return;
  } else if (handle.type === 'function') {
    val = function() {};
  } else if (handle.type === 'null') {
    val = null;
  } else if (handle.value !== undefined) {
    val = handle.value;
  } else if (handle.type === 'undefined') {
    val = undefined;
  } else {
    val = handle;
  process.nextTick(cb, null, val);
Client.prototype.fullTrace = function(cb) {
  var self = this;
  cb = cb || function() {};
  this.reqBacktrace(function(err, trace) {
    if (err) return cb(err);
    if (trace.totalFrames <= 0) return cb(Error('No frames'));
    var refs = [];
    for (var i = 0; i < trace.frames.length; i++) {
      var frame = trace.frames[i];
      // looks like this:
      // { type: 'frame',
      //   index: 0,
      //   receiver: { ref: 1 },
      //   func: { ref: 0 },
      //   script: { ref: 7 },
      //   constructCall: false,
      //   atReturn: false,
      //   debuggerFrame: false,
      //   arguments: [],
      //   locals: [],
      //   position: 160,
      //   line: 7,
      //   column: 2,
      //   sourceLineText: '  debugger;',
      //   scopes: [ { type: 1, index: 0 }, { type: 0, index: 1 } ],
      //   text: '#00 blah() /home/ryan/projects/node/test-debug.js l...' }
      refs.push(frame.script.ref);
      refs.push(frame.func.ref);
      refs.push(frame.receiver.ref);
    }
    self.reqLookup(refs, function(err, res) {
      if (err) return cb(err);
      for (var i = 0; i < trace.frames.length; i++) {
        var frame = trace.frames[i];
        frame.script = res[frame.script.ref];
        frame.func = res[frame.func.ref];
        frame.receiver = res[frame.receiver.ref];
      }
      cb(null, trace);
    });
  });
const commands = [
    'run (r)',
    'cont (c)',
    'next (n)',
    'step (s)',
    'out (o)',
    'backtrace (bt)',
    'setBreakpoint (sb)',
    'clearBreakpoint (cb)'
  ],
    'watch',
    'unwatch',
    'watchers',
    'repl',
    'exec',
    'restart',
    'kill',
    'list',
    'scripts',
    'breakOnException',
    'breakpoints',
    'version'
var helpMessage = 'Commands: ' + commands.map(function(group) {
  return group.join(', ');
}).join(',\n');
function SourceUnderline(sourceText, position, repl) {
  if (!sourceText) return '';
  const head = sourceText.slice(0, position);
  var tail = sourceText.slice(position);
  // Colourize char if stdout supports colours
  if (repl.useColors) {
    tail = tail.replace(/(.+?)([^\w]|$)/, '\u001b[32m$1\u001b[39m$2');
  // Return source line with coloured char at `position`
  return [
    head,
    tail
  ].join('');
function SourceInfo(body) {
  var result = body.exception ? 'exception in ' : 'break in ';
  if (body.script) {
    if (body.script.name) {
      var name = body.script.name;
      const dir = path.resolve() + '/';
      // Change path to relative, if possible
      if (name.indexOf(dir) === 0) {
        name = name.slice(dir.length);
      }
      result += name;
    } else {
      result += '[unnamed]';
    }
  result += ':';
  result += body.sourceLine + 1;
  if (body.exception) result += '\n' + body.exception.text;
  return result;
// This class is the repl-enabled debugger interface which is invoked on
// "node debug"
function Interface(stdin, stdout, args) {
  var self = this;
  this.stdin = stdin;
  this.stdout = stdout;
  this.args = args;
  // Two eval modes are available: controlEval and debugEval
  // But controlEval is used by default
  var opts = {
    prompt: 'debug> ',
    input: this.stdin,
    output: this.stdout,
    eval: (code, ctx, file, cb) => this.controlEval(code, ctx, file, cb),
    useGlobal: false,
    ignoreUndefined: true
  };
  if (parseInt(process.env['NODE_NO_READLINE'], 10)) {
    opts.terminal = false;
  } else if (parseInt(process.env['NODE_FORCE_READLINE'], 10)) {
    opts.terminal = true;
    // Emulate Ctrl+C if we're emulating terminal
    if (!this.stdout.isTTY) {
      process.on('SIGINT', function() {
        self.repl.rli.emit('SIGINT');
      });
    }
  if (parseInt(process.env['NODE_DISABLE_COLORS'], 10)) {
    opts.useColors = false;
  this.repl = repl.start(opts);
  // Do not print useless warning
  repl._builtinLibs.splice(repl._builtinLibs.indexOf('repl'), 1);
  // Kill child process when main process dies
  this.repl.on('exit', function() {
    process.exit(0);
  });
  // Handle all possible exits
  process.on('exit', () => this.killChild());
  process.once('SIGTERM', process.exit.bind(process, 0));
  process.once('SIGHUP', process.exit.bind(process, 0));
  var proto = Interface.prototype;
  const ignored = ['pause', 'resume', 'exitRepl', 'handleBreak',
                   'requireConnection', 'killChild', 'trySpawn',
                   'controlEval', 'debugEval', 'print', 'childPrint',
                   'clearline'];
  const shortcut = {
    'run': 'r',
    'cont': 'c',
    'next': 'n',
    'step': 's',
    'out': 'o',
    'backtrace': 'bt',
    'setBreakpoint': 'sb',
    'clearBreakpoint': 'cb',
    'pause_': 'pause'
  };
  function defineProperty(key, protoKey) {
    // Check arity
    var fn = proto[protoKey].bind(self);
    if (proto[protoKey].length === 0) {
      Object.defineProperty(self.repl.context, key, {
        get: fn,
        enumerable: true,
        configurable: false
      });
    } else {
      self.repl.context[key] = fn;
    }
  // Copy all prototype methods in repl context
  // Setup them as getters if possible
  for (var i in proto) {
    if (Object.prototype.hasOwnProperty.call(proto, i) &&
        ignored.indexOf(i) === -1) {
      defineProperty(i, i);
      if (shortcut[i]) defineProperty(shortcut[i], i);
    }
  this.killed = false;
  this.waiting = null;
  this.paused = 0;
  this.context = this.repl.context;
  this.history = {
    debug: [],
    control: []
  };
  this.breakpoints = [];
  this._watchers = [];
  // Run script automatically
  this.pause();
  setImmediate(() => { this.run(); });
// Stream control
Interface.prototype.pause = function() {
  if (this.killed || this.paused++ > 0) return this;
  this.repl.rli.pause();
  this.stdin.pause();
  return this;
Interface.prototype.resume = function(silent) {
  if (this.killed || this.paused === 0 || --this.paused !== 0) return this;
  this.repl.rli.resume();
  if (silent !== true) {
    this.repl.displayPrompt();
  this.stdin.resume();
  if (this.waiting) {
    this.waiting();
    this.waiting = null;
  return this;
// Clear current line
Interface.prototype.clearline = function() {
  if (this.stdout.isTTY) {
    this.stdout.cursorTo(0);
    this.stdout.clearLine(1);
  } else {
    this.stdout.write('\b');
// Print text to output stream
Interface.prototype.print = function(text, oneline) {
  if (this.killed) return;
  this.clearline();
  this.stdout.write(typeof text === 'string' ? text : util.inspect(text));
  if (oneline !== true) {
    this.stdout.write('\n');
// Format and print text from child process
Interface.prototype.childPrint = function(text) {
  this.print(text.toString().split(/\r\n|\r|\n/g).filter(function(chunk) {
    return chunk;
  }).map(function(chunk) {
    return '< ' + chunk;
  }).join('\n'));
  this.repl.displayPrompt(true);
// Errors formatting
Interface.prototype.error = function(text) {
  this.print(text);
  this.resume();
// Debugger's `break` event handler
Interface.prototype.handleBreak = function(r) {
  var self = this;
  this.pause();
  // Save execution context's data
  this.client.currentSourceLine = r.sourceLine;
  this.client.currentSourceLineText = r.sourceLineText;
  this.client.currentSourceColumn = r.sourceColumn;
  this.client.currentFrame = 0;
  this.client.currentScript = r.script && r.script.name;
  // Print break data
  this.print(SourceInfo(r));
  // Show watchers' values
  this.watchers(true, function(err) {
    if (err) return self.error(err);
    // And list source
    self.list(2);
    self.resume(true);
  });
// Internal method for checking connection state
Interface.prototype.requireConnection = function() {
  if (!this.client) {
    this.error('App isn\'t running... Try `run` instead');
    return false;
  return true;
// Evals
// Used for debugger's commands evaluation and execution
Interface.prototype.controlEval = function(code, context, filename, callback) {
  try {
    // Repeat last command if empty line are going to be evaluated
    if (this.repl.rli.history && this.repl.rli.history.length > 0) {
      if (code === '\n') {
        code = this.repl.rli.history[0] + '\n';
      }
    }
    // exec process.title => exec("process.title");
    var match = code.match(/^\s*exec\s+([^\n]*)/);
    if (match) {
      code = 'exec(' + JSON.stringify(match[1]) + ')';
    }
    var result = vm.runInContext(code, context, filename);
    // Repl should not ask for next command
    // if current one was asynchronous.
    if (this.paused === 0) return callback(null, result);
    // Add a callback for asynchronous command
    // (it will be automatically invoked by .resume() method
    this.waiting = function() {
      callback(null, result);
    };
  } catch (e) {
    callback(e);
// Used for debugger's remote evaluation (`repl`) commands
Interface.prototype.debugEval = function(code, context, filename, callback) {
  if (!this.requireConnection()) return;
  const self = this;
  const client = this.client;
  // Repl asked for scope variables
  if (code === '.scope') {
    client.reqScopes(callback);
    return;
  var frame = client.currentFrame === NO_FRAME ? frame : undefined;
  self.pause();
  // Request remote evaluation globally or in current frame
  client.reqFrameEval(code, frame, function(err, res) {
    if (err) {
      callback(err);
      self.resume(true);
      return;
    }
    // Request object by handles (and it's sub-properties)
    client.mirrorObject(res, 3, function(err, mirror) {
      callback(null, mirror);
      self.resume(true);
    });
  });
// Utils
// Adds spaces and prefix to number
// maxN is a maximum number we should have space for
function leftPad(n, prefix, maxN) {
  const s = n.toString();
  const nchars = Math.max(2, String(maxN).length) + 1;
  const nspaces = nchars - s.length - 1;
  return prefix + ' '.repeat(nspaces) + s;
// Commands
// Print help message
Interface.prototype.help = function() {
  this.print(helpMessage);
// Run script
Interface.prototype.run = function() {
  var callback = arguments[0];
  if (this.child) {
    this.error('App is already running... Try `restart` instead');
    callback && callback(true);
  } else {
    this.trySpawn(callback);
// Restart script
Interface.prototype.restart = function() {
  if (!this.requireConnection()) return;
  var self = this;
  self.pause();
  self.killChild();
  // XXX need to wait a little bit for the restart to work?
  setTimeout(function() {
    self.trySpawn();
    self.resume();
  }, 1000);
// Print version
Interface.prototype.version = function() {
  if (!this.requireConnection()) return;
  var self = this;
  this.pause();
  this.client.reqVersion(function(err, v) {
    if (err) {
      self.error(err);
    } else {
      self.print(v);
    }
    self.resume();
  });
// List source code
Interface.prototype.list = function(delta) {
  if (!this.requireConnection()) return;
  delta || (delta = 5);
  const self = this;
  const client = this.client;
  const from = client.currentSourceLine - delta + 1;
  const to = client.currentSourceLine + delta + 1;
  self.pause();
  client.reqSource(from, to, function(err, res) {
    if (err || !res) {
      self.error('You can\'t list source code right now');
      self.resume();
      return;
    }
    var lines = res.source.split('\n');
    for (var i = 0; i < lines.length; i++) {
      var lineno = res.fromLine + i + 1;
      if (lineno < from || lineno > to) continue;
      const current = lineno == 1 + client.currentSourceLine;
      const breakpoint = client.breakpoints.some(function(bp) {
        return (bp.scriptReq === client.currentScript ||
                bp.script === client.currentScript) &&
                bp.line == lineno;
      });
      if (lineno == 1) {
        // The first line needs to have the module wrapper filtered out of
        // it.
        var wrapper = Module.wrapper[0];
        lines[i] = lines[i].slice(wrapper.length);
        client.currentSourceColumn -= wrapper.length;
      }
      // Highlight executing statement
      var line;
      if (current) {
        line = SourceUnderline(lines[i],
                               client.currentSourceColumn,
                               self.repl);
      } else {
        line = lines[i];
      }
      var prefixChar = ' ';
      if (current) {
        prefixChar = '>';
      } else if (breakpoint) {
        prefixChar = '*';
      }
      self.print(leftPad(lineno, prefixChar, to) + ' ' + line);
    }
    self.resume();
  });
// Print backtrace
Interface.prototype.backtrace = function() {
  if (!this.requireConnection()) return;
  const self = this;
  const client = this.client;
  self.pause();
  client.fullTrace(function(err, bt) {
    if (err) {
      self.error('Can\'t request backtrace now');
      self.resume();
      return;
    }
    if (bt.totalFrames == 0) {
      self.print('(empty stack)');
    } else {
      const trace = [];
      const firstFrameNative = bt.frames[0].script.isNative;
      for (var i = 0; i < bt.frames.length; i++) {
        var frame = bt.frames[i];
        if (!firstFrameNative && frame.script.isNative) break;
        var text = '#' + i + ' ';
        if (frame.func.inferredName && frame.func.inferredName.length > 0) {
          text += frame.func.inferredName + ' ';
        }
        text += path.basename(frame.script.name) + ':';
        text += (frame.line + 1) + ':' + (frame.column + 1);
        trace.push(text);
      }
      self.print(trace.join('\n'));
    }
    self.resume();
  });
// First argument tells if it should display internal node scripts or not
// (available only for internal debugger's functions)
Interface.prototype.scripts = function() {
  if (!this.requireConnection()) return;
  const client = this.client;
  const displayNatives = arguments[0] || false;
  const scripts = [];
  this.pause();
  for (var id in client.scripts) {
    var script = client.scripts[id];
    if (script !== null && typeof script === 'object' && script.name) {
      if (displayNatives ||
          script.name == client.currentScript ||
          !script.isNative) {
        scripts.push(
            (script.name == client.currentScript ? '* ' : '  ') +
            id + ': ' +
            path.basename(script.name)
        );
      }
    }
  this.print(scripts.join('\n'));
  this.resume();
// Continue execution of script
Interface.prototype.cont = function() {
  if (!this.requireConnection()) return;
  this.pause();
  var self = this;
  this.client.reqContinue(function(err) {
    if (err) self.error(err);
    self.resume();
  });
// Step commands generator
Interface.stepGenerator = function(type, count) {
  return function() {
    if (!this.requireConnection()) return;
    var self = this;
    self.pause();
    self.client.step(type, count, function(err, res) {
      if (err) self.error(err);
      self.resume();
    });
  };
// Jump to next command
Interface.prototype.next = Interface.stepGenerator('next', 1);
// Step in
Interface.prototype.step = Interface.stepGenerator('in', 1);
// Step out
Interface.prototype.out = Interface.stepGenerator('out', 1);
// Watch
Interface.prototype.watch = function(expr) {
  this._watchers.push(expr);
// Unwatch
Interface.prototype.unwatch = function(expr) {
  var index = this._watchers.indexOf(expr);
  // Unwatch by expression
  // or
  // Unwatch by watcher number
  this._watchers.splice(index !== -1 ? index : +expr, 1);
// List watchers
Interface.prototype.watchers = function() {
  var self = this;
  var verbose = arguments[0] || false;
  var callback = arguments[1] || function() {};
  var waiting = this._watchers.length;
  var values = [];
  this.pause();
  if (!waiting) {
    this.resume();
    return callback();
  this._watchers.forEach(function(watcher, i) {
    self.debugEval(watcher, null, null, function(err, value) {
      values[i] = err ? '<error>' : value;
      wait();
    });
  });
  function wait() {
    if (--waiting === 0) {
      if (verbose) self.print('Watchers:');
      self._watchers.forEach(function(watcher, i) {
        self.print(leftPad(i, ' ', self._watchers.length - 1) +
                   ': ' + watcher + ' = ' +
                   JSON.stringify(values[i]));
      });
      if (verbose) self.print('');
      self.resume();
      callback(null);
    }
// Break on exception
Interface.prototype.breakOnException = function breakOnException() {
  if (!this.requireConnection()) return;
  var self = this;
  // Break on exceptions
  this.pause();
  this.client.reqSetExceptionBreak('all', function(err, res) {
    self.resume();
  });
// Add breakpoint
Interface.prototype.setBreakpoint = function(script, line,
                                             condition, silent) {
  if (!this.requireConnection()) return;
  const self = this;
  var scriptId;
  var ambiguous;
  // setBreakpoint() should insert breakpoint on current line
  if (script === undefined) {
    script = this.client.currentScript;
    line = this.client.currentSourceLine + 1;
  // setBreakpoint(line-number) should insert breakpoint in current script
  if (line === undefined && typeof script === 'number') {
    line = script;
    script = this.client.currentScript;
  if (script === undefined) {
    this.print('Cannot determine the current script, ' +
        'make sure the debugged process is paused.');
    return;
  let req;
  if (script.endsWith('()')) {
    // setBreakpoint('functionname()');
    req = {
      type: 'function',
      target: script.replace(/\(\)$/, ''),
      condition: condition
    };
  } else {
    // setBreakpoint('scriptname')
    if (script != +script && !this.client.scripts[script]) {
      var scripts = this.client.scripts;
      for (var id in scripts) {
        if (scripts[id] &&
            scripts[id].name &&
            scripts[id].name.indexOf(script) !== -1) {
          if (scriptId) {
            ambiguous = true;
          }
          scriptId = id;
        }
      }
    } else {
      scriptId = script;
    }
    if (ambiguous) return this.error('Script name is ambiguous');
    if (line <= 0) return this.error('Line should be a positive value');
    if (scriptId) {
      req = {
        type: 'scriptId',
        target: scriptId,
        line: line - 1,
        condition: condition
      };
    } else {
      this.print('Warning: script \'' + script + '\' was not loaded yet.');
      var escapedPath = script.replace(/([/\\.?*()^${}|[\]])/g, '\\$1');
      var scriptPathRegex = '^(.*[\\/\\\\])?' + escapedPath + '$';
      req = {
        type: 'scriptRegExp',
        target: scriptPathRegex,
        line: line - 1,
        condition: condition
      };
    }
  self.pause();
  self.client.setBreakpoint(req, function(err, res) {
    if (err) {
      if (!silent) {
        self.error(err);
      }
    } else {
      if (!silent) {
        self.list(5);
      }
      // Try load scriptId and line from response
      if (!scriptId) {
        scriptId = res.script_id;
        line = res.line + 1;
      }
      // Remember this breakpoint even if scriptId is not resolved yet
      self.client.breakpoints.push({
        id: res.breakpoint,
        scriptId: scriptId,
        script: (self.client.scripts[scriptId] || {}).name,
        line: line,
        condition: condition,
        scriptReq: script
      });
    }
    self.resume();
  });
// Clear breakpoint
Interface.prototype.clearBreakpoint = function(script, line) {
  if (!this.requireConnection()) return;
  var ambiguous;
  var breakpoint;
  var scriptId;
  var index;
  this.client.breakpoints.some(function(bp, i) {
    if (bp.scriptId === script ||
        bp.scriptReq === script ||
        (bp.script && bp.script.indexOf(script) !== -1)) {
      if (index !== undefined) {
        ambiguous = true;
      }
      scriptId = script;
      if (bp.line === line) {
        index = i;
        breakpoint = bp.id;
        return true;
      }
    }
  });
  if (!scriptId && !this.client.scripts[script]) {
    var scripts = this.client.scripts;
    for (var id in scripts) {
      if (scripts[id] &&
          scripts[id].name &&
          scripts[id].name.indexOf(script) !== -1) {
        if (scriptId) {
          ambiguous = true;
        }
        scriptId = id;
      }
    }
  if (ambiguous) return this.error('Script name is ambiguous');
  if (scriptId === undefined) {
    return this.error('Script ' + script + ' not found');
  if (breakpoint === undefined) {
    return this.error('Breakpoint not found on line ' + line);
  var self = this;
  const req = {breakpoint};
  self.pause();
  self.client.clearBreakpoint(req, function(err, res) {
    if (err) {
      self.error(err);
    } else {
      self.client.breakpoints.splice(index, 1);
      self.list(5);
    }
    self.resume();
  });
// Show breakpoints
Interface.prototype.breakpoints = function() {
  if (!this.requireConnection()) return;
  this.pause();
  var self = this;
  this.client.listbreakpoints(function(err, res) {
    if (err) {
      self.error(err);
    } else {
      self.print(res);
      self.resume();
    }
  });
// Pause child process
Interface.prototype.pause_ = function() {
  if (!this.requireConnection()) return;
  const self = this;
  const cmd = 'process._debugPause();';
  this.pause();
  this.client.reqFrameEval(cmd, NO_FRAME, function(err, res) {
    if (err) {
      self.error(err);
    } else {
      self.resume();
    }
  });
// execute expression
Interface.prototype.exec = function(code) {
  this.debugEval(code, null, null, (err, result) => {
    if (err) {
      this.error(err);
    } else {
      this.print(util.inspect(result, {colors: true}));
    }
  });
// Kill child process
Interface.prototype.kill = function() {
  if (!this.child) return;
  this.killChild();
// Activate debug repl
Interface.prototype.repl = function() {
  if (!this.requireConnection()) return;
  var self = this;
  self.print('Press Ctrl + C to leave debug repl');
  // Don't display any default messages
  var listeners = this.repl.rli.listeners('SIGINT').slice(0);
  this.repl.rli.removeAllListeners('SIGINT');
  function exitDebugRepl() {
    // Restore all listeners
    process.nextTick(function() {
      listeners.forEach(function(listener) {
        self.repl.rli.on('SIGINT', listener);
      });
    });
    // Exit debug repl
    self.exitRepl();
    self.repl.rli.removeListener('SIGINT', exitDebugRepl);
    self.repl.removeListener('exit', exitDebugRepl);
  // Exit debug repl on SIGINT
  this.repl.rli.on('SIGINT', exitDebugRepl);
  // Exit debug repl on repl exit
  this.repl.on('exit', exitDebugRepl);
  // Set new
  this.repl.eval = (code, ctx, file, cb) =>
    this.debugEval(code, ctx, file, cb);
  this.repl.context = {};
  // Swap history
  this.history.control = this.repl.rli.history;
  this.repl.rli.history = this.history.debug;
  this.repl.rli.setPrompt('> ');
  this.repl.displayPrompt();
// Exit debug repl
Interface.prototype.exitRepl = function() {
  // Restore eval
  this.repl.eval = (code, ctx, file, cb) =>
    this.controlEval(code, ctx, file, cb);
  // Swap history
  this.history.debug = this.repl.rli.history;
  this.repl.rli.history = this.history.control;
  this.repl.context = this.context;
  this.repl.rli.setPrompt('debug> ');
  this.repl.displayPrompt();
// Quit
Interface.prototype.quit = function() {
  this.killChild();
  process.exit(0);
// Kills child process
Interface.prototype.killChild = function() {
  if (this.child) {
    this.child.kill();
    this.child = null;
  if (this.client) {
    // Save breakpoints
    this.breakpoints = this.client.breakpoints;
    this.client.destroy();
    this.client = null;
// Spawns child process (and restores breakpoints)
Interface.prototype.trySpawn = function(cb) {
  const self = this;
  const breakpoints = this.breakpoints || [];
  var port = exports.port;
  var host = '127.0.0.1';
  var childArgs = this.args;
  this.killChild();
  assert(!this.child);
  var isRemote = false;
  if (this.args.length === 2) {
    const match = this.args[1].match(/^([^:]+):(\d+)$/);
    if (match) {
      // Connecting to remote debugger
      // `node debug localhost:5858`
      host = match[1];
      port = parseInt(match[2], 10);
      isRemote = true;
    }
  } else if (this.args.length === 3) {
    // `node debug -p pid`
    if (this.args[1] === '-p' && /^\d+$/.test(this.args[2])) {
      const pid = parseInt(this.args[2], 10);
      try {
        process._debugProcess(pid);
      } catch (e) {
        if (e.code === 'ESRCH') {
          console.error(`Target process: ${pid} doesn't exist.`);
          process.exit(1);
        }
        throw e;
      }
      isRemote = true;
    } else {
      const match = this.args[1].match(/^--port=(\d+)$/);
      if (match) {
        // Start debugger on custom port
        // `node debug --port=5858 app.js`
        port = parseInt(match[1], 10);
        childArgs = ['--debug-brk=' + port].concat(this.args.slice(2));
      }
    }
  if (!isRemote) {
    // pipe stream into debugger
    this.child = spawn(process.execPath, childArgs);
    this.child.stdout.on('data', (text) => this.childPrint(text));
    this.child.stderr.on('data', (text) => this.childPrint(text));
  this.pause();
  const client = self.client = new Client();
  var connectionAttempts = 0;
  client.once('ready', function() {
    self.stdout.write(' ok\n');
    // Restore breakpoints
    breakpoints.forEach(function(bp) {
      self.print('Restoring breakpoint ' + bp.scriptReq + ':' + bp.line);
      self.setBreakpoint(bp.scriptReq, bp.line, bp.condition, true);
    });
    client.on('close', function() {
      self.pause();
      self.print('program terminated');
      self.resume();
      self.client = null;
      self.killChild();
    });
    if (cb) cb();
    self.resume();
  });
  client.on('unhandledResponse', function(res) {
    self.pause();
    self.print('\nunhandled res:' + JSON.stringify(res));
    self.resume();
  });
  client.on('break', function(res) {
    self.handleBreak(res.body);
  });
  client.on('exception', function(res) {
    self.handleBreak(res.body);
  });
  client.on('error', connectError);
  function connectError() {
    // If it's failed to connect 10 times then print failed message
    if (connectionAttempts >= 10) {
      console.error(' failed, please retry');
      process.exit(1);
    }
    setTimeout(attemptConnect, 500);
  function attemptConnect() {
    ++connectionAttempts;
    self.stdout.write('.');
    client.connect(port, host);
  if (isRemote) {
    self.print('connecting to ' + host + ':' + port + ' ..', true);
    attemptConnect();
  } else {
    this.child.stderr.once('data', function() {
      self.print('connecting to ' + host + ':' + port + ' ..', true);
      setImmediate(attemptConnect);
    });
'use strict';
function init(list) {
  list._idleNext = list;
  list._idlePrev = list;
exports.init = init;
// show the most idle item
function peek(list) {
  if (list._idlePrev == list) return null;
  return list._idlePrev;
exports.peek = peek;
// remove the most idle item from the list
function shift(list) {
  var first = list._idlePrev;
  remove(first);
  return first;
exports.shift = shift;
// remove a item from its list
function remove(item) {
  if (item._idleNext) {
    item._idleNext._idlePrev = item._idlePrev;
  if (item._idlePrev) {
    item._idlePrev._idleNext = item._idleNext;
  item._idleNext = null;
  item._idlePrev = null;
exports.remove = remove;
// remove a item from its list and place at the end.
function append(list, item) {
  remove(item);
  item._idleNext = list._idleNext;
  list._idleNext._idlePrev = item;
  item._idlePrev = list;
  list._idleNext = item;
exports.append = append;
function isEmpty(list) {
  return list._idleNext === list;
exports.isEmpty = isEmpty;
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
// UTILITY
const compare = process.binding('buffer').compare;
const util = require('util');
const Buffer = require('buffer').Buffer;
const pToString = (obj) => Object.prototype.toString.call(obj);
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.
const assert = module.exports = ok;
// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  var stackStartFunction = options.stackStartFunction || fail;
  Error.captureStackTrace(this, stackStartFunction);
// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);
function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
function getMessage(self) {
  return truncate(util.inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(util.inspect(self.expected), 128);
// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;
// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.
function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
assert.ok = ok;
// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);
assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);
assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (actual instanceof Buffer && expected instanceof Buffer) {
    return compare(actual, expected) === 0;
  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();
  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;
  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;
  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (ArrayBuffer.isView(actual) && ArrayBuffer.isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Buffer(actual.buffer),
                   new Buffer(expected.buffer)) === 0;
  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    memos = memos || {actual: [], expected: []};
    const actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  const aIsArgs = isArguments(a);
  const bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  const ka = Object.keys(a);
  const kb = Object.keys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  return true;
// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  if (Error.isPrototypeOf(expected)) {
    return false;
  return expected.call({}, actual) === true;
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  return error;
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== 'function') {
    throw new TypeError('block must be a function');
  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');
  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  const userProvidedMessage = typeof message === 'string';
  const isUnwantedException = !shouldThrow && util.isError(actual);
  const isUnexpectedException = !shouldThrow && actual && !expected;
  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);
assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
assert.ifError = function(err) { if (err) throw err; };
/* eslint-disable require-buffer */
'use strict';
const binding = process.binding('buffer');
const internalUtil = require('internal/util');
const bindingObj = {};
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
exports.kMaxLength = binding.kMaxLength;
Buffer.poolSize = 8 * 1024;
var poolSize, poolOffset, allocPool;
binding.setupBufferJS(Buffer.prototype, bindingObj);
const flags = bindingObj.flags;
const kNoZeroFill = 0;
function createBuffer(size, noZeroFill) {
  flags[kNoZeroFill] = noZeroFill ? 1 : 0;
  try {
    const ui8 = new Uint8Array(size);
    Object.setPrototypeOf(ui8, Buffer.prototype);
    return ui8;
  } finally {
    flags[kNoZeroFill] = 0;
function createPool() {
  poolSize = Buffer.poolSize;
  allocPool = createBuffer(poolSize, true);
  poolOffset = 0;
createPool();
function alignPool() {
  // Ensure aligned slices
  if (poolOffset & 0x7) {
    poolOffset |= 0x7;
    poolOffset++;
function Buffer(arg, encoding) {
  // Common case.
  if (typeof arg === 'number') {
    // If less than zero, or NaN.
    if (arg < 0 || arg !== arg)
      arg = 0;
    return allocate(arg);
  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(arg, encoding);
  // Unusual.
  return fromObject(arg);
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer)
 **/
Buffer.from = function(value, encoding) {
  if (typeof value === 'number')
    throw new TypeError('"value" argument must not be a number');
  if (typeof value === 'string') {
    return fromString(value, encoding);
  // Unusual.
  return fromObject(value);
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function(size, fill, encoding) {
  if (typeof size !== 'number')
    throw new TypeError('"size" argument must be a number');
  if (size <= 0)
    return createBuffer(size);
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    // Also, don't apply encoding if fill is a number.
    if (typeof fill !== 'number' && typeof encoding === 'string')
      fill = Buffer.from(fill, encoding);
    return createBuffer(size, true).fill(fill);
  return createBuffer(size);
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer
 * instance.
 **/
Buffer.allocUnsafe = function(size) {
  if (typeof size !== 'number')
    throw new TypeError('"size" argument must be a number');
  return allocate(size);
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled
 * Buffer instance that is not allocated off the pre-initialized pool.
 **/
Buffer.allocUnsafeSlow = function(size) {
  if (typeof size !== 'number')
    throw new TypeError('"size" argument must be a number');
  return createBuffer(size, true);
function SlowBuffer(length) {
  if (+length != length)
    length = 0;
  return createBuffer(+length, true);
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
function allocate(size) {
  if (size <= 0) {
    return createBuffer(0);
  if (size < (Buffer.poolSize >>> 1)) {
    if (size > (poolSize - poolOffset))
      createPool();
    var b = allocPool.slice(poolOffset, poolOffset + size);
    poolOffset += size;
    alignPool();
    return b;
  } else {
    // Even though this is checked above, the conditional is a safety net and
    // sanity check to prevent any subsequent typed array allocation from not
    // being zero filled.
    return createBuffer(size, true);
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '')
    encoding = 'utf8';
  var length = byteLength(string, encoding);
  if (length >= (Buffer.poolSize >>> 1))
    return binding.createFromString(string, encoding);
  if (length > (poolSize - poolOffset))
    createPool();
  var actual = allocPool.write(string, poolOffset, encoding);
  var b = allocPool.slice(poolOffset, poolOffset + actual);
  poolOffset += actual;
  alignPool();
  return b;
function fromArrayLike(obj) {
  const length = obj.length;
  const b = allocate(length);
  for (var i = 0; i < length; i++)
    b[i] = obj[i] & 255;
  return b;
function fromObject(obj) {
  if (obj instanceof Buffer) {
    const b = allocate(obj.length);
    if (b.length === 0)
      return b;
    obj.copy(b, 0, 0, obj.length);
    return b;
  if (obj == null) {
    throw new TypeError('must start with number, buffer, array or string');
  if (obj instanceof ArrayBuffer) {
    return binding.createFromArrayBuffer(obj);
  if (obj.buffer instanceof ArrayBuffer || 'length' in obj) {
    if (typeof obj.length !== 'number' || obj.length !== obj.length) {
      return allocate(0);
    }
    return fromArrayLike(obj);
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  throw new TypeError('must start with number, buffer, array or string');
// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer;
Buffer.compare = function compare(a, b) {
  if (!(a instanceof Buffer) ||
      !(b instanceof Buffer)) {
    throw new TypeError('Arguments must be Buffers');
  if (a === b) {
    return 0;
  return binding.compare(a, b);
Buffer.isEncoding = function(encoding) {
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
      case 'raw':
        return true;
      default:
        if (loweredCase)
          return false;
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
Buffer.concat = function(list, length) {
  var i;
  if (!Array.isArray(list))
    throw new TypeError('list argument must be an Array of Buffers.');
  if (list.length === 0)
    return new Buffer(0);
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; i++)
      length += list[i].length;
  } else {
    length = length >>> 0;
  var buffer = new Buffer(length);
  var pos = 0;
  for (i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  return buffer;
function base64ByteLength(str, bytes) {
  // Handle padding
  if (str.charCodeAt(bytes - 1) === 0x3D)
    bytes--;
  if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D)
    bytes--;
  // Base64 ratio: 3/4
  return (bytes * 3) >>> 2;
function byteLength(string, encoding) {
  if (string instanceof Buffer)
    return string.length;
  if (typeof string !== 'string')
    string = '' + string;
  var len = string.length;
  if (len === 0)
    return 0;
  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      // eslint-disable-next-line no-fallthrough
      case 'raw':
      case 'raws':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return binding.byteLengthUtf8(string);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ByteLength(string, len);
      default:
        // The C++ binding defaulted to UTF8, we should too.
        if (loweredCase)
          return binding.byteLengthUtf8(string);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
Buffer.byteLength = byteLength;
// For backwards compatibility.
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function() {
    if (!(this instanceof Buffer))
      return undefined;
    if (this.byteLength === 0 ||
        this.byteLength === this.buffer.byteLength) {
      return undefined;
    }
    return this.buffer;
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function() {
    if (!(this instanceof Buffer))
      return undefined;
    return this.byteOffset;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  start = start >>> 0;
  end = end === undefined || end === Infinity ? this.length : end >>> 0;
  if (!encoding) encoding = 'utf8';
  if (start < 0) start = 0;
  if (end > this.length) end = this.length;
  if (end <= start) return '';
  while (true) {
    switch (encoding) {
      case 'hex':
        return this.hexSlice(start, end);
      case 'utf8':
      case 'utf-8':
        return this.utf8Slice(start, end);
      case 'ascii':
        return this.asciiSlice(start, end);
      case 'binary':
        return this.binarySlice(start, end);
      case 'base64':
        return this.base64Slice(start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return this.ucs2Slice(start, end);
      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
Buffer.prototype.toString = function() {
  let result;
  if (arguments.length === 0) {
    result = this.utf8Slice(0, this.length);
  } else {
    result = slowToString.apply(this, arguments);
  if (result === undefined)
    throw new Error('toString failed');
  return result;
Buffer.prototype.equals = function equals(b) {
  if (!(b instanceof Buffer))
    throw new TypeError('Argument must be a Buffer');
  if (this === b)
    return true;
  return binding.compare(this, b) === 0;
// Inspect
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max)
      str += ' ... ';
  return '<' + this.constructor.name + ' ' + str + '>';
Buffer.prototype.compare = function compare(b) {
  if (!(b instanceof Buffer))
    throw new TypeError('Argument must be a Buffer');
  if (this === b)
    return 0;
  return binding.compare(this, b);
function slowIndexOf(buffer, val, byteOffset, encoding) {
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'utf8':
      case 'utf-8':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
      case 'binary':
        return binding.indexOfString(buffer, val, byteOffset, encoding);
      case 'base64':
      case 'ascii':
      case 'hex':
        return binding.indexOfBuffer(
            buffer, Buffer.from(val, encoding), byteOffset, encoding);
      default:
        if (loweredCase) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  byteOffset >>= 0;
  if (typeof val === 'string') {
    if (encoding === undefined) {
      return binding.indexOfString(this, val, byteOffset, encoding);
    }
    return slowIndexOf(this, val, byteOffset, encoding);
  } else if (val instanceof Buffer) {
    return binding.indexOfBuffer(this, val, byteOffset, encoding);
  } else if (typeof val === 'number') {
    return binding.indexOfNumber(this, val, byteOffset);
  throw new TypeError('val must be string, number or Buffer');
Buffer.prototype.fill = function fill(val, start, end) {
  start = start >> 0;
  end = (end === undefined) ? this.length : end >> 0;
  if (start < 0 || end > this.length)
    throw new RangeError('out of range index');
  if (end <= start)
    return this;
  if (typeof val !== 'string') {
    val = val >>> 0;
  } else if (val.length === 1) {
    var code = val.charCodeAt(0);
    if (code < 256)
      val = code;
  } else if (val.length === 0) {
    // Previously, if val === '', the Buffer would not fill,
    // which is rather surprising.
    val = 0;
  binding.fill(this, val, start, end);
  return this;
// XXX remove in v0.13
Buffer.prototype.get = internalUtil.deprecate(function get(offset) {
  offset = ~~offset;
  if (offset < 0 || offset >= this.length)
    throw new RangeError('index out of range');
  return this[offset];
}, 'Buffer.get is deprecated. Use array indexes instead.');
// XXX remove in v0.13
Buffer.prototype.set = internalUtil.deprecate(function set(offset, v) {
  offset = ~~offset;
  if (offset < 0 || offset >= this.length)
    throw new RangeError('index out of range');
  return this[offset] = v;
}, 'Buffer.set is deprecated. Use array indexes instead.');
var writeWarned = false;
const writeMsg = 'Buffer.write(string, encoding, offset, length) is ' +
                 'deprecated. Use write(string[, offset[, length]]' +
                 '[, encoding]) instead.';
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Buffer#write(string);
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined)
        encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // XXX legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    writeWarned = internalUtil.printDeprecationMessage(writeMsg, writeWarned);
    var swap = encoding;
    encoding = offset;
    offset = length >>> 0;
    length = swap;
  var remaining = this.length - offset;
  if (length === undefined || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0))
    throw new RangeError('attempt to write outside buffer bounds');
  if (!encoding)
    encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return this.hexWrite(string, offset, length);
      case 'utf8':
      case 'utf-8':
        return this.utf8Write(string, offset, length);
      case 'ascii':
        return this.asciiWrite(string, offset, length);
      case 'binary':
        return this.binaryWrite(string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return this.base64Write(string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return this.ucs2Write(string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
Buffer.prototype.toJSON = function() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this, 0)
  };
Buffer.prototype.slice = function slice(start, end) {
  const buffer = this.subarray(start, end);
  Object.setPrototypeOf(buffer, Buffer.prototype);
  return buffer;
function checkOffset(offset, ext, length) {
  if (offset + ext > length)
    throw new RangeError('index out of range');
Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100))
    val += this[offset + i] * mul;
  return val;
Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100))
    val += this[offset + --byteLength] * mul;
  return val;
Buffer.prototype.readUInt8 = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8);
Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1];
Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000);
Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3]);
Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100))
    val += this[offset + i] * mul;
  mul *= 0x80;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength);
  return val;
Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100))
    val += this[offset + --i] * mul;
  mul *= 0x80;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength);
  return val;
Buffer.prototype.readInt8 = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  var val = this[offset];
  return !(val & 0x80) ? val : (0xff - val + 1) * -1;
Buffer.prototype.readInt16LE = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val;
Buffer.prototype.readInt16BE = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val;
Buffer.prototype.readInt32LE = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24);
Buffer.prototype.readInt32BE = function(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3]);
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return binding.readFloatLE(this, offset);
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return binding.readFloatBE(this, offset);
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return binding.readDoubleLE(this, offset);
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return binding.readDoubleBE(this, offset);
function checkInt(buffer, value, offset, ext, max, min) {
  if (!(buffer instanceof Buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (value > max || value < min)
    throw new TypeError('value is out of bounds');
  if (offset + ext > buffer.length)
    throw new RangeError('index out of range');
Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  var mul = 1;
  var i = 0;
  this[offset] = value;
  while (++i < byteLength && (mul *= 0x100))
    this[offset + i] = (value / mul) >>> 0;
  return offset + byteLength;
Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value;
  while (--i >= 0 && (mul *= 0x100))
    this[offset + i] = (value / mul) >>> 0;
  return offset + byteLength;
Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value;
  return offset + 1;
Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value;
  this[offset + 1] = (value >>> 8);
  return offset + 2;
Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = (value >>> 8);
  this[offset + 1] = value;
  return offset + 2;
Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = (value >>> 24);
  this[offset + 2] = (value >>> 16);
  this[offset + 1] = (value >>> 8);
  this[offset] = value;
  return offset + 4;
Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = (value >>> 24);
  this[offset + 1] = (value >>> 16);
  this[offset + 2] = (value >>> 8);
  this[offset + 3] = value;
  return offset + 4;
Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1));
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0)
      sub = 1;
    this[offset + i] = ((value / mul) >> 0) - sub;
  return offset + byteLength;
Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1));
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0)
      sub = 1;
    this[offset + i] = ((value / mul) >> 0) - sub;
  return offset + byteLength;
Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80);
  this[offset] = value;
  return offset + 1;
Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value;
  this[offset + 1] = (value >>> 8);
  return offset + 2;
Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = (value >>> 8);
  this[offset + 1] = value;
  return offset + 2;
Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value;
  this[offset + 1] = (value >>> 8);
  this[offset + 2] = (value >>> 16);
  this[offset + 3] = (value >>> 24);
  return offset + 4;
Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = (value >>> 24);
  this[offset + 1] = (value >>> 16);
  this[offset + 2] = (value >>> 8);
  this[offset + 3] = value;
  return offset + 4;
function checkFloat(buffer, value, offset, ext) {
  if (!(buffer instanceof Buffer))
    throw new TypeError('buffer must be a Buffer instance');
  if (offset + ext > buffer.length)
    throw new RangeError('index out of range');
Buffer.prototype.writeFloatLE = function writeFloatLE(val, offset, noAssert) {
  val = +val;
  offset = offset >>> 0;
  if (!noAssert)
    checkFloat(this, val, offset, 4);
  binding.writeFloatLE(this, val, offset);
  return offset + 4;
Buffer.prototype.writeFloatBE = function writeFloatBE(val, offset, noAssert) {
  val = +val;
  offset = offset >>> 0;
  if (!noAssert)
    checkFloat(this, val, offset, 4);
  binding.writeFloatBE(this, val, offset);
  return offset + 4;
Buffer.prototype.writeDoubleLE = function writeDoubleLE(val, offset, noAssert) {
  val = +val;
  offset = offset >>> 0;
  if (!noAssert)
    checkFloat(this, val, offset, 8);
  binding.writeDoubleLE(this, val, offset);
  return offset + 8;
Buffer.prototype.writeDoubleBE = function writeDoubleBE(val, offset, noAssert) {
  val = +val;
  offset = offset >>> 0;
  if (!noAssert)
    checkFloat(this, val, offset, 8);
  binding.writeDoubleBE(this, val, offset);
  return offset + 8;
'use strict';
const util = require('util');
const internalUtil = require('internal/util');
const debug = util.debuglog('child_process');
const constants = require('constants');
const uv = process.binding('uv');
const spawn_sync = process.binding('spawn_sync');
const Buffer = require('buffer').Buffer;
const Pipe = process.binding('pipe_wrap').Pipe;
const child_process = require('internal/child_process');
const errnoException = util._errnoException;
const _validateStdio = child_process._validateStdio;
const setupChannel = child_process.setupChannel;
const ChildProcess = exports.ChildProcess = child_process.ChildProcess;
exports.fork = function(modulePath /*, args, options*/) {
  // Get options and args arguments.
  var options, args, execArgv;
  if (Array.isArray(arguments[1])) {
    args = arguments[1];
    options = util._extend({}, arguments[2]);
  } else if (arguments[1] && typeof arguments[1] !== 'object') {
    throw new TypeError('Incorrect value of args option');
  } else {
    args = [];
    options = util._extend({}, arguments[1]);
  // Prepare arguments for fork:
  execArgv = options.execArgv || process.execArgv;
  if (execArgv === process.execArgv && process._eval != null) {
    const index = execArgv.lastIndexOf(process._eval);
    if (index > 0) {
      // Remove the -e switch to avoid fork bombing ourselves.
      execArgv = execArgv.slice();
      execArgv.splice(index - 1, 2);
    }
  args = execArgv.concat([modulePath], args);
  // Leave stdin open for the IPC channel. stdout and stderr should be the
  // same as the parent's if silent isn't set.
  options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :
      [0, 1, 2, 'ipc'];
  options.execPath = options.execPath || process.execPath;
  return spawn(options.execPath, args, options);
exports._forkChild = function(fd) {
  // set process.send()
  var p = new Pipe(true);
  p.open(fd);
  p.unref();
  const control = setupChannel(process, p);
  process.on('newListener', function(name) {
    if (name === 'message' || name === 'disconnect') control.ref();
  });
  process.on('removeListener', function(name) {
    if (name === 'message' || name === 'disconnect') control.unref();
  });
function normalizeExecArgs(command /*, options, callback*/) {
  var file, args, options, callback;
  if (typeof arguments[1] === 'function') {
    options = undefined;
    callback = arguments[1];
  } else {
    options = arguments[1];
    callback = arguments[2];
  if (process.platform === 'win32') {
    file = process.env.comspec || 'cmd.exe';
    args = ['/s', '/c', '"' + command + '"'];
    // Make a shallow copy before patching so we don't clobber the user's
    // options object.
    options = util._extend({}, options);
    options.windowsVerbatimArguments = true;
  } else {
    file = '/bin/sh';
    args = ['-c', command];
  if (options && options.shell)
    file = options.shell;
  return {
    cmd: command,
    file: file,
    args: args,
    options: options,
    callback: callback
  };
exports.exec = function(command /*, options, callback*/) {
  var opts = normalizeExecArgs.apply(null, arguments);
  return exports.execFile(opts.file,
                          opts.args,
                          opts.options,
                          opts.callback);
exports.execFile = function(file /*, args, options, callback*/) {
  var args = [], callback;
  var options = {
    encoding: 'utf8',
    timeout: 0,
    maxBuffer: 200 * 1024,
    killSignal: 'SIGTERM',
    cwd: null,
    env: null
  };
  // Parse the optional positional parameters.
  var pos = 1;
  if (pos < arguments.length && Array.isArray(arguments[pos])) {
    args = arguments[pos++];
  } else if (pos < arguments.length && arguments[pos] == null) {
    pos++;
  if (pos < arguments.length && typeof arguments[pos] === 'object') {
    options = util._extend(options, arguments[pos++]);
  } else if (pos < arguments.length && arguments[pos] == null) {
    pos++;
  if (pos < arguments.length && typeof arguments[pos] === 'function') {
    callback = arguments[pos++];
  if (pos === 1 && arguments.length > 1) {
    throw new TypeError('Incorrect value of args option');
  var child = spawn(file, args, {
    cwd: options.cwd,
    env: options.env,
    gid: options.gid,
    uid: options.uid,
    windowsVerbatimArguments: !!options.windowsVerbatimArguments
  });
  var encoding;
  var _stdout;
  var _stderr;
  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {
    encoding = options.encoding;
    _stdout = '';
    _stderr = '';
  } else {
    _stdout = [];
    _stderr = [];
    encoding = null;
  var stdoutLen = 0;
  var stderrLen = 0;
  var killed = false;
  var exited = false;
  var timeoutId;
  var ex = null;
  function exithandler(code, signal) {
    if (exited) return;
    exited = true;
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
    if (!callback) return;
    // merge chunks
    var stdout;
    var stderr;
    if (encoding) {
      stdout = _stdout;
      stderr = _stderr;
    } else {
      stdout = Buffer.concat(_stdout);
      stderr = Buffer.concat(_stderr);
    }
    if (ex) {
      // Will be handled later
    } else if (code === 0 && signal === null) {
      callback(null, stdout, stderr);
      return;
    }
    var cmd = file;
    if (args.length !== 0)
      cmd += ' ' + args.join(' ');
    if (!ex) {
      ex = new Error('Command failed: ' + cmd + '\n' + stderr);
      ex.killed = child.killed || killed;
      ex.code = code < 0 ? uv.errname(code) : code;
      ex.signal = signal;
    }
    ex.cmd = cmd;
    callback(ex, stdout, stderr);
  function errorhandler(e) {
    ex = e;
    if (child.stdout)
      child.stdout.destroy();
    if (child.stderr)
      child.stderr.destroy();
    exithandler();
  function kill() {
    if (child.stdout)
      child.stdout.destroy();
    if (child.stderr)
      child.stderr.destroy();
    killed = true;
    try {
      child.kill(options.killSignal);
    } catch (e) {
      ex = e;
      exithandler();
    }
  if (options.timeout > 0) {
    timeoutId = setTimeout(function() {
      kill();
      timeoutId = null;
    }, options.timeout);
  if (child.stdout) {
    if (encoding)
      child.stdout.setEncoding(encoding);
    child.stdout.addListener('data', function(chunk) {
      stdoutLen += encoding ? Buffer.byteLength(chunk, encoding) : chunk.length;
      if (stdoutLen > options.maxBuffer) {
        ex = new Error('stdout maxBuffer exceeded');
        kill();
      } else {
        if (encoding)
          _stdout += chunk;
        else
          _stdout.push(chunk);
      }
    });
  if (child.stderr) {
    if (encoding)
      child.stderr.setEncoding(encoding);
    child.stderr.addListener('data', function(chunk) {
      stderrLen += encoding ? Buffer.byteLength(chunk, encoding) : chunk.length;
      if (stderrLen > options.maxBuffer) {
        ex = new Error('stderr maxBuffer exceeded');
        kill();
      } else {
        if (encoding)
          _stderr += chunk;
        else
          _stderr.push(chunk);
      }
    });
  child.addListener('close', exithandler);
  child.addListener('error', errorhandler);
  return child;
var _deprecatedCustomFds = internalUtil.deprecate(function(options) {
  options.stdio = options.customFds.map(function(fd) {
    return fd === -1 ? 'pipe' : fd;
  });
}, 'child_process: options.customFds option is deprecated. ' +
   'Use options.stdio instead.');
function _convertCustomFds(options) {
  if (options && options.customFds && !options.stdio) {
    _deprecatedCustomFds(options);
function normalizeSpawnArguments(file /*, args, options*/) {
  var args, options;
  if (Array.isArray(arguments[1])) {
    args = arguments[1].slice(0);
    options = arguments[2];
  } else if (arguments[1] !== undefined &&
             (arguments[1] === null || typeof arguments[1] !== 'object')) {
    throw new TypeError('Incorrect value of args option');
  } else {
    args = [];
    options = arguments[1];
  if (options === undefined)
    options = {};
  else if (options === null || typeof options !== 'object')
    throw new TypeError('options argument must be an object');
  options = util._extend({}, options);
  args.unshift(file);
  var env = options.env || process.env;
  var envPairs = [];
  for (var key in env) {
    envPairs.push(key + '=' + env[key]);
  _convertCustomFds(options);
  return {
    file: file,
    args: args,
    options: options,
    envPairs: envPairs
  };
var spawn = exports.spawn = function(/*file, args, options*/) {
  var opts = normalizeSpawnArguments.apply(null, arguments);
  var options = opts.options;
  var child = new ChildProcess();
  debug('spawn', opts.args, options);
  child.spawn({
    file: opts.file,
    args: opts.args,
    cwd: options.cwd,
    windowsVerbatimArguments: !!options.windowsVerbatimArguments,
    detached: !!options.detached,
    envPairs: opts.envPairs,
    stdio: options.stdio,
    uid: options.uid,
    gid: options.gid
  });
  return child;
function lookupSignal(signal) {
  if (typeof signal === 'number')
    return signal;
  if (!(signal in constants))
    throw new Error('Unknown signal: ' + signal);
  return constants[signal];
function spawnSync(/*file, args, options*/) {
  var opts = normalizeSpawnArguments.apply(null, arguments);
  var options = opts.options;
  var i;
  debug('spawnSync', opts.args, options);
  options.file = opts.file;
  options.args = opts.args;
  options.envPairs = opts.envPairs;
  if (options.killSignal)
    options.killSignal = lookupSignal(options.killSignal);
  options.stdio = _validateStdio(options.stdio || 'pipe', true).stdio;
  if (options.input) {
    var stdin = options.stdio[0] = util._extend({}, options.stdio[0]);
    stdin.input = options.input;
  // We may want to pass data in on any given fd, ensure it is a valid buffer
  for (i = 0; i < options.stdio.length; i++) {
    var input = options.stdio[i] && options.stdio[i].input;
    if (input != null) {
      var pipe = options.stdio[i] = util._extend({}, options.stdio[i]);
      if (Buffer.isBuffer(input))
        pipe.input = input;
      else if (typeof input === 'string')
        pipe.input = new Buffer(input, options.encoding);
      else
        throw new TypeError(util.format(
            'stdio[%d] should be Buffer or string not %s',
            i,
            typeof input));
    }
  var result = spawn_sync.spawn(options);
  if (result.output && options.encoding && options.encoding !== 'buffer') {
    for (i = 0; i < result.output.length; i++) {
      if (!result.output[i])
        continue;
      result.output[i] = result.output[i].toString(options.encoding);
    }
  result.stdout = result.output && result.output[1];
  result.stderr = result.output && result.output[2];
  if (result.error) {
    result.error = errnoException(result.error, 'spawnSync ' + opts.file);
    result.error.path = opts.file;
    result.error.spawnargs = opts.args.slice(1);
  util._extend(result, opts);
  return result;
exports.spawnSync = spawnSync;
function checkExecSyncError(ret) {
  if (ret.error || ret.status !== 0) {
    var err = ret.error;
    ret.error = null;
    if (!err) {
      var msg = 'Command failed: ';
      msg += ret.cmd || ret.args.join(' ');
      if (ret.stderr)
        msg += '\n' + ret.stderr.toString();
      err = new Error(msg);
    }
    util._extend(err, ret);
    return err;
  return false;
function execFileSync(/*command, args, options*/) {
  var opts = normalizeSpawnArguments.apply(null, arguments);
  var inheritStderr = !opts.options.stdio;
  var ret = spawnSync(opts.file, opts.args.slice(1), opts.options);
  if (inheritStderr)
    process.stderr.write(ret.stderr);
  var err = checkExecSyncError(ret);
  if (err)
    throw err;
  else
    return ret.stdout;
exports.execFileSync = execFileSync;
function execSync(/*command, options*/) {
  var opts = normalizeExecArgs.apply(null, arguments);
  var inheritStderr = opts.options ? !opts.options.stdio : true;
  var ret = spawnSync(opts.file, opts.args, opts.options);
  ret.cmd = opts.cmd;
  if (inheritStderr)
    process.stderr.write(ret.stderr);
  var err = checkExecSyncError(ret);
  if (err)
    throw err;
  else
    return ret.stdout;
exports.execSync = execSync;
'use strict';
const util = require('util');
function Console(stdout, stderr) {
  if (!(this instanceof Console)) {
    return new Console(stdout, stderr);
  if (!stdout || typeof stdout.write !== 'function') {
    throw new TypeError('Console expects a writable stream instance');
  if (!stderr) {
    stderr = stdout;
  } else if (typeof stderr.write !== 'function') {
    throw new TypeError('Console expects writable stream instances');
  var prop = {
    writable: true,
    enumerable: false,
    configurable: true
  };
  prop.value = stdout;
  Object.defineProperty(this, '_stdout', prop);
  prop.value = stderr;
  Object.defineProperty(this, '_stderr', prop);
  prop.value = new Map();
  Object.defineProperty(this, '_times', prop);
  // bind the prototype functions to this Console instance
  var keys = Object.keys(Console.prototype);
  for (var v = 0; v < keys.length; v++) {
    var k = keys[v];
    this[k] = this[k].bind(this);
Console.prototype.log = function() {
  this._stdout.write(util.format.apply(null, arguments) + '\n');
Console.prototype.info = Console.prototype.log;
Console.prototype.warn = function() {
  this._stderr.write(util.format.apply(null, arguments) + '\n');
Console.prototype.error = Console.prototype.warn;
Console.prototype.dir = function(object, options) {
  this._stdout.write(util.inspect(object, util._extend({
    customInspect: false
  }, options)) + '\n');
Console.prototype.time = function(label) {
  this._times.set(label, Date.now());
Console.prototype.timeEnd = function(label) {
  var time = this._times.get(label);
  if (!time) {
    throw new Error('No such label: ' + label);
  var duration = Date.now() - time;
  this.log('%s: %dms', label, duration);
Console.prototype.trace = function trace() {
  // TODO probably can to do this better with V8's debug object once that is
  // exposed.
  var err = new Error();
  err.name = 'Trace';
  err.message = util.format.apply(null, arguments);
  Error.captureStackTrace(err, trace);
  this.error(err.stack);
Console.prototype.assert = function(expression) {
  if (!expression) {
    const argsLen = arguments.length || 1;
    const arr = new Array(argsLen - 1);
    for (var i = 1; i < argsLen; i++)
      arr[i - 1] = arguments[i];
    require('assert').ok(false, util.format.apply(null, arr));
module.exports = new Console(process.stdout, process.stderr);
module.exports.Console = Console;
'use strict';
module.exports = process.binding('constants');
// Note: In 0.8 and before, crypto functions all defaulted to using
// binary-encoded strings rather than buffers.
'use strict';
exports.DEFAULT_ENCODING = 'buffer';
try {
  var binding = process.binding('crypto');
  var randomBytes = binding.randomBytes;
  var getCiphers = binding.getCiphers;
  var getHashes = binding.getHashes;
  var getCurves = binding.getCurves;
} catch (e) {
  throw new Error('node.js not compiled with openssl crypto support.');
const Buffer = require('buffer').Buffer;
const constants = require('constants');
const stream = require('stream');
const util = require('util');
const internalUtil = require('internal/util');
const LazyTransform = require('internal/streams/lazy_transform');
const DH_GENERATOR = 2;
// This is here because many functions accepted binary strings without
// any explicit encoding in older versions of node, and we don't want
// to break them unnecessarily.
function toBuf(str, encoding) {
  encoding = encoding || 'binary';
  if (typeof str === 'string') {
    if (encoding === 'buffer')
      encoding = 'binary';
    str = new Buffer(str, encoding);
  return str;
exports._toBuf = toBuf;
const assert = require('assert');
const StringDecoder = require('string_decoder').StringDecoder;
exports.createHash = exports.Hash = Hash;
function Hash(algorithm, options) {
  if (!(this instanceof Hash))
    return new Hash(algorithm, options);
  this._handle = new binding.Hash(algorithm);
  LazyTransform.call(this, options);
util.inherits(Hash, LazyTransform);
Hash.prototype._transform = function(chunk, encoding, callback) {
  this._handle.update(chunk, encoding);
  callback();
Hash.prototype._flush = function(callback) {
  this.push(this._handle.digest());
  callback();
Hash.prototype.update = function(data, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding === 'buffer' && typeof data === 'string')
    encoding = 'binary';
  this._handle.update(data, encoding);
  return this;
Hash.prototype.digest = function(outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  return this._handle.digest(outputEncoding);
exports.createHmac = exports.Hmac = Hmac;
function Hmac(hmac, key, options) {
  if (!(this instanceof Hmac))
    return new Hmac(hmac, key, options);
  this._handle = new binding.Hmac();
  this._handle.init(hmac, toBuf(key));
  LazyTransform.call(this, options);
util.inherits(Hmac, LazyTransform);
Hmac.prototype.update = Hash.prototype.update;
Hmac.prototype.digest = Hash.prototype.digest;
Hmac.prototype._flush = Hash.prototype._flush;
Hmac.prototype._transform = Hash.prototype._transform;
function getDecoder(decoder, encoding) {
  if (encoding === 'utf-8') encoding = 'utf8';  // Normalize encoding.
  decoder = decoder || new StringDecoder(encoding);
  assert(decoder.encoding === encoding, 'Cannot change encoding');
  return decoder;
exports.createCipher = exports.Cipher = Cipher;
function Cipher(cipher, password, options) {
  if (!(this instanceof Cipher))
    return new Cipher(cipher, password, options);
  this._handle = new binding.CipherBase(true);
  this._handle.init(cipher, toBuf(password));
  this._decoder = null;
  LazyTransform.call(this, options);
util.inherits(Cipher, LazyTransform);
Cipher.prototype._transform = function(chunk, encoding, callback) {
  this.push(this._handle.update(chunk, encoding));
  callback();
Cipher.prototype._flush = function(callback) {
  try {
    this.push(this._handle.final());
  } catch (e) {
    callback(e);
    return;
  callback();
Cipher.prototype.update = function(data, inputEncoding, outputEncoding) {
  inputEncoding = inputEncoding || exports.DEFAULT_ENCODING;
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  var ret = this._handle.update(data, inputEncoding);
  if (outputEncoding && outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.write(ret);
  return ret;
Cipher.prototype.final = function(outputEncoding) {
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;
  var ret = this._handle.final();
  if (outputEncoding && outputEncoding !== 'buffer') {
    this._decoder = getDecoder(this._decoder, outputEncoding);
    ret = this._decoder.end(ret);
  return ret;
Cipher.prototype.setAutoPadding = function(ap) {
  this._handle.setAutoPadding(ap);
  return this;
Cipher.prototype.getAuthTag = function() {
  return this._handle.getAuthTag();
Cipher.prototype.setAuthTag = function(tagbuf) {
  this._handle.setAuthTag(tagbuf);
Cipher.prototype.setAAD = function(aadbuf) {
  this._handle.setAAD(aadbuf);
exports.createCipheriv = exports.Cipheriv = Cipheriv;
function Cipheriv(cipher, key, iv, options) {
  if (!(this instanceof Cipheriv))
    return new Cipheriv(cipher, key, iv, options);
  this._handle = new binding.CipherBase(true);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;
  LazyTransform.call(this, options);
util.inherits(Cipheriv, LazyTransform);
Cipheriv.prototype._transform = Cipher.prototype._transform;
Cipheriv.prototype._flush = Cipher.prototype._flush;
Cipheriv.prototype.update = Cipher.prototype.update;
Cipheriv.prototype.final = Cipher.prototype.final;
Cipheriv.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;
Cipheriv.prototype.getAuthTag = Cipher.prototype.getAuthTag;
Cipheriv.prototype.setAuthTag = Cipher.prototype.setAuthTag;
Cipheriv.prototype.setAAD = Cipher.prototype.setAAD;
exports.createDecipher = exports.Decipher = Decipher;
function Decipher(cipher, password, options) {
  if (!(this instanceof Decipher))
    return new Decipher(cipher, password, options);
  this._handle = new binding.CipherBase(false);
  this._handle.init(cipher, toBuf(password));
  this._decoder = null;
  LazyTransform.call(this, options);
util.inherits(Decipher, LazyTransform);
Decipher.prototype._transform = Cipher.prototype._transform;
Decipher.prototype._flush = Cipher.prototype._flush;
Decipher.prototype.update = Cipher.prototype.update;
Decipher.prototype.final = Cipher.prototype.final;
Decipher.prototype.finaltol = Cipher.prototype.final;
Decipher.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;
Decipher.prototype.getAuthTag = Cipher.prototype.getAuthTag;
Decipher.prototype.setAuthTag = Cipher.prototype.setAuthTag;
Decipher.prototype.setAAD = Cipher.prototype.setAAD;
exports.createDecipheriv = exports.Decipheriv = Decipheriv;
function Decipheriv(cipher, key, iv, options) {
  if (!(this instanceof Decipheriv))
    return new Decipheriv(cipher, key, iv, options);
  this._handle = new binding.CipherBase(false);
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));
  this._decoder = null;
  LazyTransform.call(this, options);
util.inherits(Decipheriv, LazyTransform);
Decipheriv.prototype._transform = Cipher.prototype._transform;
Decipheriv.prototype._flush = Cipher.prototype._flush;
Decipheriv.prototype.update = Cipher.prototype.update;
Decipheriv.prototype.final = Cipher.prototype.final;
Decipheriv.prototype.finaltol = Cipher.prototype.final;
Decipheriv.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;
Decipheriv.prototype.getAuthTag = Cipher.prototype.getAuthTag;
Decipheriv.prototype.setAuthTag = Cipher.prototype.setAuthTag;
Decipheriv.prototype.setAAD = Cipher.prototype.setAAD;
exports.createSign = exports.Sign = Sign;
function Sign(algorithm, options) {
  if (!(this instanceof Sign))
    return new Sign(algorithm, options);
  this._handle = new binding.Sign();
  this._handle.init(algorithm);
  stream.Writable.call(this, options);
util.inherits(Sign, stream.Writable);
Sign.prototype._write = function(chunk, encoding, callback) {
  this._handle.update(chunk, encoding);
  callback();
Sign.prototype.update = Hash.prototype.update;
Sign.prototype.sign = function(options, encoding) {
  if (!options)
    throw new Error('No key provided to sign');
  var key = options.key || options;
  var passphrase = options.passphrase || null;
  var ret = this._handle.sign(toBuf(key), null, passphrase);
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding && encoding !== 'buffer')
    ret = ret.toString(encoding);
  return ret;
exports.createVerify = exports.Verify = Verify;
function Verify(algorithm, options) {
  if (!(this instanceof Verify))
    return new Verify(algorithm, options);
  this._handle = new binding.Verify();
  this._handle.init(algorithm);
  stream.Writable.call(this, options);
util.inherits(Verify, stream.Writable);
Verify.prototype._write = Sign.prototype._write;
Verify.prototype.update = Sign.prototype.update;
Verify.prototype.verify = function(object, signature, sigEncoding) {
  sigEncoding = sigEncoding || exports.DEFAULT_ENCODING;
  return this._handle.verify(toBuf(object), toBuf(signature, sigEncoding));
function rsaPublic(method, defaultPadding) {
  return function(options, buffer) {
    var key = options.key || options;
    var padding = options.padding || defaultPadding;
    var passphrase = options.passphrase || null;
    return method(toBuf(key), buffer, padding, passphrase);
  };
function rsaPrivate(method, defaultPadding) {
  return function(options, buffer) {
    var key = options.key || options;
    var passphrase = options.passphrase || null;
    var padding = options.padding || defaultPadding;
    return method(toBuf(key), buffer, padding, passphrase);
  };
exports.publicEncrypt = rsaPublic(binding.publicEncrypt,
                                  constants.RSA_PKCS1_OAEP_PADDING);
exports.publicDecrypt = rsaPublic(binding.publicDecrypt,
                                  constants.RSA_PKCS1_PADDING);
exports.privateEncrypt = rsaPrivate(binding.privateEncrypt,
                                    constants.RSA_PKCS1_PADDING);
exports.privateDecrypt = rsaPrivate(binding.privateDecrypt,
                                    constants.RSA_PKCS1_OAEP_PADDING);
exports.createDiffieHellman = exports.DiffieHellman = DiffieHellman;
function DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {
  if (!(this instanceof DiffieHellman))
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);
  if (!(sizeOrKey instanceof Buffer) &&
      typeof sizeOrKey !== 'number' &&
      typeof sizeOrKey !== 'string')
    throw new TypeError('First argument should be number, string or Buffer');
  if (keyEncoding) {
    if (typeof keyEncoding !== 'string' ||
        (!Buffer.isEncoding(keyEncoding) && keyEncoding !== 'buffer')) {
      genEncoding = generator;
      generator = keyEncoding;
      keyEncoding = false;
    }
  keyEncoding = keyEncoding || exports.DEFAULT_ENCODING;
  genEncoding = genEncoding || exports.DEFAULT_ENCODING;
  if (typeof sizeOrKey !== 'number')
    sizeOrKey = toBuf(sizeOrKey, keyEncoding);
  if (!generator)
    generator = DH_GENERATOR;
  else if (typeof generator !== 'number')
    generator = toBuf(generator, genEncoding);
  this._handle = new binding.DiffieHellman(sizeOrKey, generator);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
exports.DiffieHellmanGroup =
    exports.createDiffieHellmanGroup =
    exports.getDiffieHellman = DiffieHellmanGroup;
function DiffieHellmanGroup(name) {
  if (!(this instanceof DiffieHellmanGroup))
    return new DiffieHellmanGroup(name);
  this._handle = new binding.DiffieHellmanGroup(name);
  Object.defineProperty(this, 'verifyError', {
    enumerable: true,
    value: this._handle.verifyError,
    writable: false
  });
DiffieHellmanGroup.prototype.generateKeys =
    DiffieHellman.prototype.generateKeys =
    dhGenerateKeys;
function dhGenerateKeys(encoding) {
  var keys = this._handle.generateKeys();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding && encoding !== 'buffer')
    keys = keys.toString(encoding);
  return keys;
DiffieHellmanGroup.prototype.computeSecret =
    DiffieHellman.prototype.computeSecret =
    dhComputeSecret;
function dhComputeSecret(key, inEnc, outEnc) {
  inEnc = inEnc || exports.DEFAULT_ENCODING;
  outEnc = outEnc || exports.DEFAULT_ENCODING;
  var ret = this._handle.computeSecret(toBuf(key, inEnc));
  if (outEnc && outEnc !== 'buffer')
    ret = ret.toString(outEnc);
  return ret;
DiffieHellmanGroup.prototype.getPrime =
    DiffieHellman.prototype.getPrime =
    dhGetPrime;
function dhGetPrime(encoding) {
  var prime = this._handle.getPrime();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding && encoding !== 'buffer')
    prime = prime.toString(encoding);
  return prime;
DiffieHellmanGroup.prototype.getGenerator =
    DiffieHellman.prototype.getGenerator =
    dhGetGenerator;
function dhGetGenerator(encoding) {
  var generator = this._handle.getGenerator();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding && encoding !== 'buffer')
    generator = generator.toString(encoding);
  return generator;
DiffieHellmanGroup.prototype.getPublicKey =
    DiffieHellman.prototype.getPublicKey =
    dhGetPublicKey;
function dhGetPublicKey(encoding) {
  var key = this._handle.getPublicKey();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding && encoding !== 'buffer')
    key = key.toString(encoding);
  return key;
DiffieHellmanGroup.prototype.getPrivateKey =
    DiffieHellman.prototype.getPrivateKey =
    dhGetPrivateKey;
function dhGetPrivateKey(encoding) {
  var key = this._handle.getPrivateKey();
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding && encoding !== 'buffer')
    key = key.toString(encoding);
  return key;
DiffieHellman.prototype.setPublicKey = function(key, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  this._handle.setPublicKey(toBuf(key, encoding));
  return this;
DiffieHellman.prototype.setPrivateKey = function(key, encoding) {
  encoding = encoding || exports.DEFAULT_ENCODING;
  this._handle.setPrivateKey(toBuf(key, encoding));
  return this;
function ECDH(curve) {
  if (typeof curve !== 'string')
    throw new TypeError('curve should be a string');
  this._handle = new binding.ECDH(curve);
exports.createECDH = function createECDH(curve) {
  return new ECDH(curve);
ECDH.prototype.computeSecret = DiffieHellman.prototype.computeSecret;
ECDH.prototype.setPrivateKey = DiffieHellman.prototype.setPrivateKey;
ECDH.prototype.setPublicKey = DiffieHellman.prototype.setPublicKey;
ECDH.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey;
ECDH.prototype.generateKeys = function generateKeys(encoding, format) {
  this._handle.generateKeys();
  return this.getPublicKey(encoding, format);
ECDH.prototype.getPublicKey = function getPublicKey(encoding, format) {
  var f;
  if (format) {
    if (typeof format === 'number')
      f = format;
    if (format === 'compressed')
      f = constants.POINT_CONVERSION_COMPRESSED;
    else if (format === 'hybrid')
      f = constants.POINT_CONVERSION_HYBRID;
    // Default
    else if (format === 'uncompressed')
      f = constants.POINT_CONVERSION_UNCOMPRESSED;
    else
      throw new TypeError('Bad format: ' + format);
  } else {
    f = constants.POINT_CONVERSION_UNCOMPRESSED;
  var key = this._handle.getPublicKey(f);
  encoding = encoding || exports.DEFAULT_ENCODING;
  if (encoding && encoding !== 'buffer')
    key = key.toString(encoding);
  return key;
exports.pbkdf2 = function(password,
                          salt,
                          iterations,
                          keylen,
                          digest,
                          callback) {
  if (typeof digest === 'function') {
    callback = digest;
    digest = undefined;
  if (typeof callback !== 'function')
    throw new Error('No callback provided to pbkdf2');
  return pbkdf2(password, salt, iterations, keylen, digest, callback);
exports.pbkdf2Sync = function(password, salt, iterations, keylen, digest) {
  return pbkdf2(password, salt, iterations, keylen, digest);
function pbkdf2(password, salt, iterations, keylen, digest, callback) {
  password = toBuf(password);
  salt = toBuf(salt);
  if (exports.DEFAULT_ENCODING === 'buffer')
    return binding.PBKDF2(password, salt, iterations, keylen, digest, callback);
  // at this point, we need to handle encodings.
  var encoding = exports.DEFAULT_ENCODING;
  if (callback) {
    var next = function(er, ret) {
      if (ret)
        ret = ret.toString(encoding);
      callback(er, ret);
    };
    binding.PBKDF2(password, salt, iterations, keylen, digest, next);
  } else {
    var ret = binding.PBKDF2(password, salt, iterations, keylen, digest);
    return ret.toString(encoding);
exports.Certificate = Certificate;
function Certificate() {
  if (!(this instanceof Certificate))
    return new Certificate();
  this._handle = new binding.Certificate();
Certificate.prototype.verifySpkac = function(object) {
  return this._handle.verifySpkac(object);
Certificate.prototype.exportPublicKey = function(object, encoding) {
  return this._handle.exportPublicKey(toBuf(object, encoding));
Certificate.prototype.exportChallenge = function(object, encoding) {
  return this._handle.exportChallenge(toBuf(object, encoding));
exports.setEngine = function setEngine(id, flags) {
  if (typeof id !== 'string')
    throw new TypeError('id should be a string');
  if (flags && typeof flags !== 'number')
    throw new TypeError('flags should be a number, if present');
  flags = flags >>> 0;
  // Use provided engine for everything by default
  if (flags === 0)
    flags = constants.ENGINE_METHOD_ALL;
  return binding.setEngine(id, flags);
exports.randomBytes = exports.pseudoRandomBytes = randomBytes;
exports.rng = exports.prng = randomBytes;
exports.getCiphers = function() {
  return filterDuplicates(getCiphers());
exports.getHashes = function() {
  return filterDuplicates(getHashes());
exports.getCurves = function() {
  return filterDuplicates(getCurves());
function filterDuplicates(names) {
  // Drop all-caps names in favor of their lowercase aliases,
  // for example, 'sha1' instead of 'SHA1'.
  var ctx = {};
  names.forEach(function(name) {
    var key = name;
    if (/^[0-9A-Z\-]+$/.test(key)) key = key.toLowerCase();
    if (!ctx.hasOwnProperty(key) || ctx[key] < name)
      ctx[key] = name;
  });
  return Object.getOwnPropertyNames(ctx).map(function(key) {
    return ctx[key];
  }).sort();
// Legacy API
exports.__defineGetter__('createCredentials',
  internalUtil.deprecate(function() {
    return require('tls').createSecureContext;
  }, 'crypto.createCredentials is deprecated. ' +
     'Use tls.createSecureContext instead.'));
exports.__defineGetter__('Credentials', internalUtil.deprecate(function() {
  return require('tls').SecureContext;
}, 'crypto.Credentials is deprecated. ' +
   'Use tls.createSecureContext instead.'));
'use strict';
const EventEmitter = require('events');
const assert = require('assert');
const dgram = require('dgram');
const fork = require('child_process').fork;
const net = require('net');
const util = require('util');
const SCHED_NONE = 1;
const SCHED_RR = 2;
const uv = process.binding('uv');
const cluster = new EventEmitter();
module.exports = cluster;
cluster.Worker = Worker;
cluster.isWorker = ('NODE_UNIQUE_ID' in process.env);
cluster.isMaster = (cluster.isWorker === false);
function Worker(options) {
  if (!(this instanceof Worker))
    return new Worker(options);
  EventEmitter.call(this);
  if (options === null || typeof options !== 'object')
    options = {};
  this.suicide = undefined;
  this.state = options.state || 'none';
  this.id = options.id | 0;
  if (options.process) {
    this.process = options.process;
    this.process.on('error', (code, signal) =>
      this.emit('error', code, signal)
    );
    this.process.on('message', (message, handle) =>
      this.emit('message', message, handle)
    );
util.inherits(Worker, EventEmitter);
Worker.prototype.kill = function() {
  this.destroy.apply(this, arguments);
Worker.prototype.send = function() {
  this.process.send.apply(this.process, arguments);
Worker.prototype.isDead = function isDead() {
  return this.process.exitCode != null || this.process.signalCode != null;
Worker.prototype.isConnected = function isConnected() {
  return this.process.connected;
// Master/worker specific methods are defined in the *Init() functions.
function SharedHandle(key, address, port, addressType, backlog, fd, flags) {
  this.key = key;
  this.workers = [];
  this.handle = null;
  this.errno = 0;
  // FIXME(bnoordhuis) Polymorphic return type for lack of a better solution.
  var rval;
  if (addressType === 'udp4' || addressType === 'udp6')
    rval = dgram._createSocketHandle(address, port, addressType, fd, flags);
  else
    rval = net._createServerHandle(address, port, addressType, fd);
  if (typeof rval === 'number')
    this.errno = rval;
  else
    this.handle = rval;
SharedHandle.prototype.add = function(worker, send) {
  assert(this.workers.indexOf(worker) === -1);
  this.workers.push(worker);
  send(this.errno, null, this.handle);
SharedHandle.prototype.remove = function(worker) {
  var index = this.workers.indexOf(worker);
  if (index === -1) return false; // The worker wasn't sharing this handle.
  this.workers.splice(index, 1);
  if (this.workers.length !== 0) return false;
  this.handle.close();
  this.handle = null;
  return true;
// Start a round-robin server. Master accepts connections and distributes
// them over the workers.
function RoundRobinHandle(key, address, port, addressType, backlog, fd) {
  this.key = key;
  this.all = {};
  this.free = [];
  this.handles = [];
  this.handle = null;
  this.server = net.createServer(assert.fail);
  if (fd >= 0)
    this.server.listen({ fd: fd });
  else if (port >= 0)
    this.server.listen(port, address);
  else
    this.server.listen(address);  // UNIX socket path.
  var self = this;
  this.server.once('listening', function() {
    self.handle = self.server._handle;
    self.handle.onconnection = self.distribute.bind(self);
    self.server._handle = null;
    self.server = null;
  });
RoundRobinHandle.prototype.add = function(worker, send) {
  assert(worker.id in this.all === false);
  this.all[worker.id] = worker;
  var self = this;
  function done() {
    if (self.handle.getsockname) {
      var out = {};
      self.handle.getsockname(out);
      // TODO(bnoordhuis) Check err.
      send(null, { sockname: out }, null);
    } else {
      send(null, null, null);  // UNIX socket.
    }
    self.handoff(worker);  // In case there are connections pending.
  if (this.server === null) return done();
  // Still busy binding.
  this.server.once('listening', done);
  this.server.once('error', function(err) {
    // Hack: translate 'EADDRINUSE' error string back to numeric error code.
    // It works but ideally we'd have some backchannel between the net and
    // cluster modules for stuff like this.
    var errno = uv['UV_' + err.errno];
    send(errno, null);
  });
RoundRobinHandle.prototype.remove = function(worker) {
  if (worker.id in this.all === false) return false;
  delete this.all[worker.id];
  var index = this.free.indexOf(worker);
  if (index !== -1) this.free.splice(index, 1);
  if (Object.getOwnPropertyNames(this.all).length !== 0) return false;
  for (var handle; handle = this.handles.shift(); handle.close());
  this.handle.close();
  this.handle = null;
  return true;
RoundRobinHandle.prototype.distribute = function(err, handle) {
  this.handles.push(handle);
  var worker = this.free.shift();
  if (worker) this.handoff(worker);
RoundRobinHandle.prototype.handoff = function(worker) {
  if (worker.id in this.all === false) {
    return;  // Worker is closing (or has closed) the server.
  var handle = this.handles.shift();
  if (handle === undefined) {
    this.free.push(worker);  // Add to ready queue again.
    return;
  var message = { act: 'newconn', key: this.key };
  var self = this;
  sendHelper(worker.process, message, handle, function(reply) {
    if (reply.accepted)
      handle.close();
    else
      self.distribute(0, handle);  // Worker is shutting down. Send to another.
    self.handoff(worker);
  });
if (cluster.isMaster)
  masterInit();
else
  workerInit();
function masterInit() {
  cluster.workers = {};
  var intercom = new EventEmitter();
  cluster.settings = {};
  // XXX(bnoordhuis) Fold cluster.schedulingPolicy into cluster.settings?
  var schedulingPolicy = {
    'none': SCHED_NONE,
    'rr': SCHED_RR
  }[process.env.NODE_CLUSTER_SCHED_POLICY];
  if (schedulingPolicy === undefined) {
    // FIXME Round-robin doesn't perform well on Windows right now due to the
    // way IOCP is wired up. Bert is going to fix that, eventually.
    schedulingPolicy = (process.platform === 'win32') ? SCHED_NONE : SCHED_RR;
  cluster.schedulingPolicy = schedulingPolicy;
  cluster.SCHED_NONE = SCHED_NONE;  // Leave it to the operating system.
  cluster.SCHED_RR = SCHED_RR;      // Master distributes connections.
  // Keyed on address:port:etc. When a worker dies, we walk over the handles
  // and remove() the worker from each one. remove() may do a linear scan
  // itself so we might end up with an O(n*m) operation. Ergo, FIXME.
  const handles = require('internal/cluster').handles;
  var initialized = false;
  cluster.setupMaster = function(options) {
    var settings = {
      args: process.argv.slice(2),
      exec: process.argv[1],
      execArgv: process.execArgv,
      silent: false
    };
    settings = util._extend(settings, cluster.settings);
    settings = util._extend(settings, options || {});
    // Tell V8 to write profile data for each process to a separate file.
    // Without --logfile=v8-%p.log, everything ends up in a single, unusable
    // file. (Unusable because what V8 logs are memory addresses and each
    // process has its own memory mappings.)
    if (settings.execArgv.some((s) => s.startsWith('--prof')) &&
        !settings.execArgv.some((s) => s.startsWith('--logfile='))) {
      settings.execArgv = settings.execArgv.concat(['--logfile=v8-%p.log']);
    }
    cluster.settings = settings;
    if (initialized === true)
      return process.nextTick(setupSettingsNT, settings);
    initialized = true;
    schedulingPolicy = cluster.schedulingPolicy;  // Freeze policy.
    assert(schedulingPolicy === SCHED_NONE || schedulingPolicy === SCHED_RR,
           'Bad cluster.schedulingPolicy: ' + schedulingPolicy);
    var hasDebugArg = process.execArgv.some(function(argv) {
      return /^(--debug|--debug-brk)(=\d+)?$/.test(argv);
    });
    process.nextTick(setupSettingsNT, settings);
    // Send debug signal only if not started in debug mode, this helps a lot
    // on windows, because RegisterDebugHandler is not called when node starts
    // with --debug.* arg.
    if (hasDebugArg)
      return;
    process.on('internalMessage', function(message) {
      if (message.cmd !== 'NODE_DEBUG_ENABLED') return;
      var key;
      for (key in cluster.workers) {
        var worker = cluster.workers[key];
        if (worker.state === 'online' || worker.state === 'listening') {
          process._debugProcess(worker.process.pid);
        } else {
          worker.once('online', function() {
            process._debugProcess(this.process.pid);
          });
        }
      }
    });
  };
  function setupSettingsNT(settings) {
    cluster.emit('setup', settings);
  var debugPortOffset = 1;
  function createWorkerProcess(id, env) {
    var workerEnv = util._extend({}, process.env);
    var execArgv = cluster.settings.execArgv.slice();
    var debugPort = 0;
    workerEnv = util._extend(workerEnv, env);
    workerEnv.NODE_UNIQUE_ID = '' + id;
    for (var i = 0; i < execArgv.length; i++) {
      var match = execArgv[i].match(/^(--debug|--debug-(brk|port))(=\d+)?$/);
      if (match) {
        if (debugPort === 0) {
          debugPort = process.debugPort + debugPortOffset;
          ++debugPortOffset;
        }
        execArgv[i] = match[1] + '=' + debugPort;
      }
    }
    return fork(cluster.settings.exec, cluster.settings.args, {
      env: workerEnv,
      silent: cluster.settings.silent,
      execArgv: execArgv,
      gid: cluster.settings.gid,
      uid: cluster.settings.uid
    });
  var ids = 0;
  function removeWorker(worker) {
    assert(worker);
    delete cluster.workers[worker.id];
    if (Object.keys(cluster.workers).length === 0) {
      assert(Object.keys(handles).length === 0, 'Resource leak detected.');
      intercom.emit('disconnect');
    }
  function removeHandlesForWorker(worker) {
    assert(worker);
    for (var key in handles) {
      var handle = handles[key];
      if (handle.remove(worker)) delete handles[key];
    }
  cluster.fork = function(env) {
    cluster.setupMaster();
    const id = ++ids;
    const workerProcess = createWorkerProcess(id, env);
    const worker = new Worker({
      id: id,
      process: workerProcess
    });
    worker.on('message', (message, handle) =>
      cluster.emit('message', message, handle)
    );
    worker.process.once('exit', function(exitCode, signalCode) {
      /*
       * Remove the worker from the workers list only
       * if it has disconnected, otherwise we might
       * still want to access it.
       */
      if (!worker.isConnected()) {
        removeHandlesForWorker(worker);
        removeWorker(worker);
      }
      worker.suicide = !!worker.suicide;
      worker.state = 'dead';
      worker.emit('exit', exitCode, signalCode);
      cluster.emit('exit', worker, exitCode, signalCode);
    });
    worker.process.once('disconnect', function() {
      /*
       * Now is a good time to remove the handles
       * associated with this worker because it is
       * not connected to the master anymore.
       */
      removeHandlesForWorker(worker);
      /*
       * Remove the worker from the workers list only
       * if its process has exited. Otherwise, we might
       * still want to access it.
       */
      if (worker.isDead()) removeWorker(worker);
      worker.suicide = !!worker.suicide;
      worker.state = 'disconnected';
      worker.emit('disconnect');
      cluster.emit('disconnect', worker);
    });
    worker.process.on('internalMessage', internal(worker, onmessage));
    process.nextTick(emitForkNT, worker);
    cluster.workers[worker.id] = worker;
    return worker;
  };
  function emitForkNT(worker) {
    cluster.emit('fork', worker);
  cluster.disconnect = function(cb) {
    var workers = Object.keys(cluster.workers);
    if (workers.length === 0) {
      process.nextTick(intercom.emit.bind(intercom, 'disconnect'));
    } else {
      for (var key in workers) {
        key = workers[key];
        if (cluster.workers[key].isConnected())
          cluster.workers[key].disconnect();
      }
    }
    if (cb) intercom.once('disconnect', cb);
  };
  Worker.prototype.disconnect = function() {
    this.suicide = true;
    send(this, { act: 'disconnect' });
    removeHandlesForWorker(this);
    removeWorker(this);
  };
  Worker.prototype.destroy = function(signo) {
    signo = signo || 'SIGTERM';
    var proc = this.process;
    if (this.isConnected()) {
      this.once('disconnect', proc.kill.bind(proc, signo));
      this.disconnect();
      return;
    }
    proc.kill(signo);
  };
  function onmessage(message, handle) {
    var worker = this;
    if (message.act === 'online')
      online(worker);
    else if (message.act === 'queryServer')
      queryServer(worker, message);
    else if (message.act === 'listening')
      listening(worker, message);
    else if (message.act === 'suicide')
      suicide(worker, message);
    else if (message.act === 'close')
      close(worker, message);
  function online(worker) {
    worker.state = 'online';
    worker.emit('online');
    cluster.emit('online', worker);
  function suicide(worker, message) {
    worker.suicide = true;
    send(worker, { ack: message.seq });
  function queryServer(worker, message) {
    // Stop processing if worker already disconnecting
    if (worker.suicide)
      return;
    var args = [message.address,
                message.port,
                message.addressType,
                message.fd,
                message.index];
    var key = args.join(':');
    var handle = handles[key];
    if (handle === undefined) {
      var constructor = RoundRobinHandle;
      // UDP is exempt from round-robin connection balancing for what should
      // be obvious reasons: it's connectionless. There is nothing to send to
      // the workers except raw datagrams and that's pointless.
      if (schedulingPolicy !== SCHED_RR ||
          message.addressType === 'udp4' ||
          message.addressType === 'udp6') {
        constructor = SharedHandle;
      }
      handles[key] = handle = new constructor(key,
                                              message.address,
                                              message.port,
                                              message.addressType,
                                              message.backlog,
                                              message.fd,
                                              message.flags);
    }
    if (!handle.data) handle.data = message.data;
    // Set custom server data
    handle.add(worker, function(errno, reply, handle) {
      reply = util._extend({
        errno: errno,
        key: key,
        ack: message.seq,
        data: handles[key].data
      }, reply);
      if (errno) delete handles[key];  // Gives other workers a chance to retry.
      send(worker, reply, handle);
    });
  function listening(worker, message) {
    var info = {
      addressType: message.addressType,
      address: message.address,
      port: message.port,
      fd: message.fd
    };
    worker.state = 'listening';
    worker.emit('listening', info);
    cluster.emit('listening', worker, info);
  // Server in worker is closing, remove from list.  The handle may have been
  // removed by a prior call to removeHandlesForWorker() so guard against that.
  function close(worker, message) {
    var key = message.key;
    var handle = handles[key];
    if (handle && handle.remove(worker)) delete handles[key];
  function send(worker, message, handle, cb) {
    sendHelper(worker.process, message, handle, cb);
function workerInit() {
  var handles = {};
  var indexes = {};
  // Called from src/node.js
  cluster._setupWorker = function() {
    var worker = new Worker({
      id: +process.env.NODE_UNIQUE_ID | 0,
      process: process,
      state: 'online'
    });
    cluster.worker = worker;
    process.once('disconnect', function() {
      worker.emit('disconnect');
      if (!worker.suicide) {
        // Unexpected disconnect, master exited, or some such nastiness, so
        // worker exits immediately.
        process.exit(0);
      }
    });
    process.on('internalMessage', internal(worker, onmessage));
    send({ act: 'online' });
    function onmessage(message, handle) {
      if (message.act === 'newconn')
        onconnection(message, handle);
      else if (message.act === 'disconnect')
        _disconnect.call(worker, true);
    }
  };
  // obj is a net#Server or a dgram#Socket object.
  cluster._getServer = function(obj, options, cb) {
    const indexesKey = [ options.address,
                         options.port,
                         options.addressType,
                         options.fd ].join(':');
    if (indexes[indexesKey] === undefined)
      indexes[indexesKey] = 0;
    else
      indexes[indexesKey]++;
    const message = util._extend({
      act: 'queryServer',
      index: indexes[indexesKey],
      data: null
    }, options);
    // Set custom data on handle (i.e. tls tickets key)
    if (obj._getServerData) message.data = obj._getServerData();
    send(message, function(reply, handle) {
      if (obj._setServerData) obj._setServerData(reply.data);
      if (handle)
        shared(reply, handle, indexesKey, cb);  // Shared listen socket.
      else
        rr(reply, indexesKey, cb);              // Round-robin.
    });
    obj.once('listening', function() {
      cluster.worker.state = 'listening';
      const address = obj.address();
      message.act = 'listening';
      message.port = address && address.port || options.port;
      send(message);
    });
  };
  // Shared listen socket.
  function shared(message, handle, indexesKey, cb) {
    var key = message.key;
    // Monkey-patch the close() method so we can keep track of when it's
    // closed. Avoids resource leaks when the handle is short-lived.
    var close = handle.close;
    handle.close = function() {
      send({ act: 'close', key: key });
      delete handles[key];
      delete indexes[indexesKey];
      return close.apply(this, arguments);
    };
    assert(handles[key] === undefined);
    handles[key] = handle;
    cb(message.errno, handle);
  // Round-robin. Master distributes handles across workers.
  function rr(message, indexesKey, cb) {
    if (message.errno)
      return cb(message.errno, null);
    var key = message.key;
    function listen(backlog) {
      // TODO(bnoordhuis) Send a message to the master that tells it to
      // update the backlog size. The actual backlog should probably be
      // the largest requested size by any worker.
      return 0;
    }
    function close() {
      // lib/net.js treats server._handle.close() as effectively synchronous.
      // That means there is a time window between the call to close() and
      // the ack by the master process in which we can still receive handles.
      // onconnection() below handles that by sending those handles back to
      // the master.
      if (key === undefined) return;
      send({ act: 'close', key: key });
      delete handles[key];
      delete indexes[indexesKey];
      key = undefined;
    }
    function getsockname(out) {
      if (key) util._extend(out, message.sockname);
      return 0;
    }
    // XXX(bnoordhuis) Probably no point in implementing ref() and unref()
    // because the control channel is going to keep the worker alive anyway.
    function ref() {
    }
    function unref() {
    }
    // Faux handle. Mimics a TCPWrap with just enough fidelity to get away
    // with it. Fools net.Server into thinking that it's backed by a real
    // handle.
    var handle = {
      close: close,
      listen: listen,
      ref: ref,
      unref: unref,
    };
    if (message.sockname) {
      handle.getsockname = getsockname;  // TCP handles only.
    }
    assert(handles[key] === undefined);
    handles[key] = handle;
    cb(0, handle);
  // Round-robin connection.
  function onconnection(message, handle) {
    var key = message.key;
    var server = handles[key];
    var accepted = server !== undefined;
    send({ ack: message.seq, accepted: accepted });
    if (accepted) server.onconnection(0, handle);
  Worker.prototype.disconnect = function() {
    _disconnect.call(this);
  };
  Worker.prototype.destroy = function() {
    this.suicide = true;
    if (!this.isConnected()) process.exit(0);
    var exit = process.exit.bind(null, 0);
    send({ act: 'suicide' }, () => process.disconnect());
    process.once('disconnect', exit);
  };
  function send(message, cb) {
    sendHelper(process, message, null, cb);
  function _disconnect(masterInitiated) {
    this.suicide = true;
    let waitingCount = 1;
    function checkWaitingCount() {
      waitingCount--;
      if (waitingCount === 0) {
        // If disconnect is worker initiated, wait for ack to be sure suicide
        // is properly set in the master, otherwise, if it's master initiated
        // there's no need to send the suicide message
        if (masterInitiated) {
          process.disconnect();
        } else {
          send({ act: 'suicide' }, () => process.disconnect());
        }
      }
    }
    for (const key in handles) {
      const handle = handles[key];
      delete handles[key];
      waitingCount++;
      if (handle.owner)
        handle.owner.close(checkWaitingCount);
      else
        handle.close(checkWaitingCount);
    }
    checkWaitingCount();
var seq = 0;
var callbacks = {};
function sendHelper(proc, message, handle, cb) {
  if (!proc.connected)
    return false;
  // Mark message as internal. See INTERNAL_PREFIX in lib/child_process.js
  message = util._extend({ cmd: 'NODE_CLUSTER' }, message);
  if (cb) callbacks[seq] = cb;
  message.seq = seq;
  seq += 1;
  proc.send(message, handle);
// Returns an internalMessage listener that hands off normal messages
// to the callback but intercepts and redirects ACK messages.
function internal(worker, cb) {
  return function(message, handle) {
    if (message.cmd !== 'NODE_CLUSTER') return;
    var fn = cb;
    if (message.ack !== undefined && callbacks[message.ack] !== undefined) {
      fn = callbacks[message.ack];
      delete callbacks[message.ack];
    }
    fn.apply(worker, arguments);
  };
'use strict';
const assert = require('assert');
const Buffer = require('buffer').Buffer;
const util = require('util');
const EventEmitter = require('events');
const constants = require('constants');
const UDP = process.binding('udp_wrap').UDP;
const SendWrap = process.binding('udp_wrap').SendWrap;
const BIND_STATE_UNBOUND = 0;
const BIND_STATE_BINDING = 1;
const BIND_STATE_BOUND = 2;
// lazily loaded
var cluster = null;
var dns = null;
const errnoException = util._errnoException;
const exceptionWithHostPort = util._exceptionWithHostPort;
function lookup(address, family, callback) {
  if (!dns)
    dns = require('dns');
  return dns.lookup(address, family, callback);
function lookup4(address, callback) {
  return lookup(address || '0.0.0.0', 4, callback);
function lookup6(address, callback) {
  return lookup(address || '::0', 6, callback);
function newHandle(type) {
  if (type == 'udp4') {
    const handle = new UDP();
    handle.lookup = lookup4;
    return handle;
  if (type == 'udp6') {
    const handle = new UDP();
    handle.lookup = lookup6;
    handle.bind = handle.bind6;
    handle.send = handle.send6;
    return handle;
  if (type == 'unix_dgram')
    throw new Error('unix_dgram sockets are not supported any more.');
  throw new Error('Bad socket type specified. Valid types are: udp4, udp6');
exports._createSocketHandle = function(address, port, addressType, fd, flags) {
  // Opening an existing fd is not supported for UDP handles.
  assert(typeof fd !== 'number' || fd < 0);
  var handle = newHandle(addressType);
  if (port || address) {
    var err = handle.bind(address, port || 0, flags);
    if (err) {
      handle.close();
      return err;
    }
  return handle;
function Socket(type, listener) {
  EventEmitter.call(this);
  if (typeof type === 'object') {
    var options = type;
    type = options.type;
  var handle = newHandle(type);
  handle.owner = this;
  this._handle = handle;
  this._receiving = false;
  this._bindState = BIND_STATE_UNBOUND;
  this.type = type;
  this.fd = null; // compatibility hack
  // If true - UV_UDP_REUSEADDR flag will be set
  this._reuseAddr = options && options.reuseAddr;
  if (typeof listener === 'function')
    this.on('message', listener);
util.inherits(Socket, EventEmitter);
exports.Socket = Socket;
exports.createSocket = function(type, listener) {
  return new Socket(type, listener);
function startListening(socket) {
  socket._handle.onmessage = onMessage;
  // Todo: handle errors
  socket._handle.recvStart();
  socket._receiving = true;
  socket._bindState = BIND_STATE_BOUND;
  socket.fd = -42; // compatibility hack
  socket.emit('listening');
function replaceHandle(self, newHandle) {
  // Set up the handle that we got from master.
  newHandle.lookup = self._handle.lookup;
  newHandle.bind = self._handle.bind;
  newHandle.send = self._handle.send;
  newHandle.owner = self;
  // Replace the existing handle by the handle we got from master.
  self._handle.close();
  self._handle = newHandle;
Socket.prototype.bind = function(port_ /*, address, callback*/) {
  var self = this;
  let port = port_;
  self._healthCheck();
  if (this._bindState != BIND_STATE_UNBOUND)
    throw new Error('Socket is already bound');
  this._bindState = BIND_STATE_BINDING;
  if (typeof arguments[arguments.length - 1] === 'function')
    self.once('listening', arguments[arguments.length - 1]);
  if (port instanceof UDP) {
    replaceHandle(self, port);
    startListening(self);
    return self;
  var address;
  var exclusive;
  if (port !== null && typeof port === 'object') {
    address = port.address || '';
    exclusive = !!port.exclusive;
    port = port.port;
  } else {
    address = typeof arguments[1] === 'function' ? '' : arguments[1];
    exclusive = false;
  // resolve address first
  self._handle.lookup(address, function(err, ip) {
    if (err) {
      self._bindState = BIND_STATE_UNBOUND;
      self.emit('error', err);
      return;
    }
    if (!cluster)
      cluster = require('cluster');
    var flags = 0;
    if (self._reuseAddr)
      flags |= constants.UV_UDP_REUSEADDR;
    if (cluster.isWorker && !exclusive) {
      function onHandle(err, handle) {
        if (err) {
          var ex = exceptionWithHostPort(err, 'bind', ip, port);
          self.emit('error', ex);
          self._bindState = BIND_STATE_UNBOUND;
          return;
        }
        if (!self._handle)
          // handle has been closed in the mean time.
          return handle.close();
        replaceHandle(self, handle);
        startListening(self);
      }
      cluster._getServer(self, {
        address: ip,
        port: port,
        addressType: self.type,
        fd: -1,
        flags: flags
      }, onHandle);
    } else {
      if (!self._handle)
        return; // handle has been closed in the mean time
      const err = self._handle.bind(ip, port || 0, flags);
      if (err) {
        var ex = exceptionWithHostPort(err, 'bind', ip, port);
        self.emit('error', ex);
        self._bindState = BIND_STATE_UNBOUND;
        // Todo: close?
        return;
      }
      startListening(self);
    }
  });
  return self;
// thin wrapper around `send`, here for compatibility with dgram_legacy.js
Socket.prototype.sendto = function(buffer,
                                   offset,
                                   length,
                                   port,
                                   address,
                                   callback) {
  if (typeof offset !== 'number' || typeof length !== 'number')
    throw new Error('send takes offset and length as args 2 and 3');
  if (typeof address !== 'string')
    throw new Error(this.type + ' sockets must send to port, address');
  this.send(buffer, offset, length, port, address, callback);
Socket.prototype.send = function(buffer,
                                 offset,
                                 length,
                                 port,
                                 address,
                                 callback) {
  var self = this;
  if (typeof buffer === 'string')
    buffer = new Buffer(buffer);
  else if (!(buffer instanceof Buffer))
    throw new TypeError('First argument must be a buffer or string.');
  offset = offset | 0;
  if (offset < 0)
    throw new RangeError('Offset should be >= 0');
  if ((length == 0 && offset > buffer.length) ||
      (length > 0 && offset >= buffer.length))
    throw new RangeError('Offset into buffer too large');
  // Sending a zero-length datagram is kind of pointless but it _is_
  // allowed, hence check that length >= 0 rather than > 0.
  length = length | 0;
  if (length < 0)
    throw new RangeError('Length should be >= 0');
  if (offset + length > buffer.length)
    throw new RangeError('Offset + length beyond buffer length');
  port = port | 0;
  if (port <= 0 || port > 65535)
    throw new RangeError('Port should be > 0 and < 65536');
  // Normalize callback so it's either a function or undefined but not anything
  // else.
  if (typeof callback !== 'function')
    callback = undefined;
  self._healthCheck();
  if (self._bindState == BIND_STATE_UNBOUND)
    self.bind({port: 0, exclusive: true}, null);
  // If the socket hasn't been bound yet, push the outbound packet onto the
  // send queue and send after binding is complete.
  if (self._bindState != BIND_STATE_BOUND) {
    // If the send queue hasn't been initialized yet, do it, and install an
    // event handler that flushes the send queue after binding is done.
    if (!self._sendQueue) {
      self._sendQueue = [];
      self.once('listening', function() {
        // Flush the send queue.
        for (var i = 0; i < self._sendQueue.length; i++)
          self.send.apply(self, self._sendQueue[i]);
        self._sendQueue = undefined;
      });
    }
    self._sendQueue.push([buffer, offset, length, port, address, callback]);
    return;
  self._handle.lookup(address, function(ex, ip) {
    if (ex) {
      if (typeof callback === 'function') {
        callback(ex);
        return;
      }
      self.emit('error', ex);
    } else if (self._handle) {
      var req = new SendWrap();
      req.buffer = buffer;  // Keep reference alive.
      req.length = length;
      req.address = address;
      req.port = port;
      if (callback) {
        req.callback = callback;
        req.oncomplete = afterSend;
      }
      var err = self._handle.send(req,
                                  buffer,
                                  offset,
                                  length,
                                  port,
                                  ip,
                                  !!callback);
      if (err && callback) {
        // don't emit as error, dgram_legacy.js compatibility
        const ex = exceptionWithHostPort(err, 'send', address, port);
        process.nextTick(callback, ex);
      }
    }
  });
function afterSend(err) {
  if (err) {
    err = exceptionWithHostPort(err, 'send', this.address, this.port);
  this.callback(err, this.length);
Socket.prototype.close = function(callback) {
  if (typeof callback === 'function')
    this.on('close', callback);
  this._healthCheck();
  this._stopReceiving();
  this._handle.close();
  this._handle = null;
  process.nextTick(socketCloseNT, this);
  return this;
function socketCloseNT(self) {
  self.emit('close');
Socket.prototype.address = function() {
  this._healthCheck();
  var out = {};
  var err = this._handle.getsockname(out);
  if (err) {
    throw errnoException(err, 'getsockname');
  return out;
Socket.prototype.setBroadcast = function(arg) {
  var err = this._handle.setBroadcast(arg ? 1 : 0);
  if (err) {
    throw errnoException(err, 'setBroadcast');
Socket.prototype.setTTL = function(arg) {
  if (typeof arg !== 'number') {
    throw new TypeError('Argument must be a number');
  var err = this._handle.setTTL(arg);
  if (err) {
    throw errnoException(err, 'setTTL');
  return arg;
Socket.prototype.setMulticastTTL = function(arg) {
  if (typeof arg !== 'number') {
    throw new TypeError('Argument must be a number');
  var err = this._handle.setMulticastTTL(arg);
  if (err) {
    throw errnoException(err, 'setMulticastTTL');
  return arg;
Socket.prototype.setMulticastLoopback = function(arg) {
  var err = this._handle.setMulticastLoopback(arg ? 1 : 0);
  if (err) {
    throw errnoException(err, 'setMulticastLoopback');
  return arg; // 0.4 compatibility
Socket.prototype.addMembership = function(multicastAddress,
                                          interfaceAddress) {
  this._healthCheck();
  if (!multicastAddress) {
    throw new Error('multicast address must be specified');
  var err = this._handle.addMembership(multicastAddress, interfaceAddress);
  if (err) {
    throw errnoException(err, 'addMembership');
Socket.prototype.dropMembership = function(multicastAddress,
                                           interfaceAddress) {
  this._healthCheck();
  if (!multicastAddress) {
    throw new Error('multicast address must be specified');
  var err = this._handle.dropMembership(multicastAddress, interfaceAddress);
  if (err) {
    throw errnoException(err, 'dropMembership');
Socket.prototype._healthCheck = function() {
  if (!this._handle)
    throw new Error('Not running'); // error message from dgram_legacy.js
Socket.prototype._stopReceiving = function() {
  if (!this._receiving)
    return;
  this._handle.recvStop();
  this._receiving = false;
  this.fd = null; // compatibility hack
function onMessage(nread, handle, buf, rinfo) {
  var self = handle.owner;
  if (nread < 0) {
    return self.emit('error', errnoException(nread, 'recvmsg'));
  rinfo.size = buf.length; // compatibility
  self.emit('message', buf, rinfo);
Socket.prototype.ref = function() {
  if (this._handle)
    this._handle.ref();
  return this;
Socket.prototype.unref = function() {
  if (this._handle)
    this._handle.unref();
  return this;
'use strict';
const net = require('net');
const util = require('util');
const cares = process.binding('cares_wrap');
const uv = process.binding('uv');
const GetAddrInfoReqWrap = cares.GetAddrInfoReqWrap;
const GetNameInfoReqWrap = cares.GetNameInfoReqWrap;
const QueryReqWrap = cares.QueryReqWrap;
const isIp = net.isIP;
function errnoException(err, syscall, hostname) {
  // FIXME(bnoordhuis) Remove this backwards compatibility nonsense and pass
  // the true error to the user. ENOTFOUND is not even a proper POSIX error!
  if (err === uv.UV_EAI_MEMORY ||
      err === uv.UV_EAI_NODATA ||
      err === uv.UV_EAI_NONAME) {
    err = 'ENOTFOUND';
  var ex = null;
  if (typeof err === 'string') {  // c-ares error code.
    const errHost = hostname ? ' ' + hostname : '';
    ex = new Error(`${syscall} ${err}${errHost}`);
    ex.code = err;
    ex.errno = err;
    ex.syscall = syscall;
  } else {
    ex = util._errnoException(err, syscall);
  if (hostname) {
    ex.hostname = hostname;
  return ex;
// c-ares invokes a callback either synchronously or asynchronously,
// but the dns API should always invoke a callback asynchronously.
// This function makes sure that the callback is invoked asynchronously.
// It returns a function that invokes the callback within nextTick().
// To avoid invoking unnecessary nextTick(), `immediately` property of
// returned function should be set to true after c-ares returned.
// Usage:
// function someAPI(callback) {
//   callback = makeAsync(callback);
//   channel.someAPI(..., callback);
//   callback.immediately = true;
// }
function makeAsync(callback) {
  if (typeof callback !== 'function') {
    return callback;
  return function asyncCallback() {
    if (asyncCallback.immediately) {
      // The API already returned, we can invoke the callback immediately.
      callback.apply(null, arguments);
    } else {
      var args = new Array(arguments.length + 1);
      args[0] = callback;
      for (var i = 1, a = 0; a < arguments.length; ++i, ++a)
        args[i] = arguments[a];
      process.nextTick.apply(null, args);
    }
  };
function onlookup(err, addresses) {
  if (err) {
    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));
  if (this.family) {
    this.callback(null, addresses[0], this.family);
  } else {
    this.callback(null, addresses[0], addresses[0].indexOf(':') >= 0 ? 6 : 4);
function onlookupall(err, addresses) {
  var results = [];
  if (err) {
    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));
  for (var i = 0; i < addresses.length; i++) {
    results.push({
      address: addresses[i],
      family: this.family || (addresses[i].indexOf(':') >= 0 ? 6 : 4)
    });
  this.callback(null, results);
// Easy DNS A/AAAA look up
// lookup(hostname, [options,] callback)
exports.lookup = function lookup(hostname, options, callback) {
  var hints = 0;
  var family = -1;
  var all = false;
  // Parse arguments
  if (hostname && typeof hostname !== 'string') {
    throw new TypeError('invalid arguments: ' +
                        'hostname must be a string or falsey');
  } else if (typeof options === 'function') {
    callback = options;
    family = 0;
  } else if (typeof callback !== 'function') {
    throw new TypeError('invalid arguments: callback must be passed');
  } else if (options !== null && typeof options === 'object') {
    hints = options.hints >>> 0;
    family = options.family >>> 0;
    all = options.all === true;
    if (hints !== 0 &&
        hints !== exports.ADDRCONFIG &&
        hints !== exports.V4MAPPED &&
        hints !== (exports.ADDRCONFIG | exports.V4MAPPED)) {
      throw new TypeError('invalid argument: hints must use valid flags');
    }
  } else {
    family = options >>> 0;
  if (family !== 0 && family !== 4 && family !== 6)
    throw new TypeError('invalid argument: family must be 4 or 6');
  callback = makeAsync(callback);
  if (!hostname) {
    if (all) {
      callback(null, []);
    } else {
      callback(null, null, family === 6 ? 6 : 4);
    }
    return {};
  var matchedFamily = net.isIP(hostname);
  if (matchedFamily) {
    if (all) {
      callback(null, [{address: hostname, family: matchedFamily}]);
    } else {
      callback(null, hostname, matchedFamily);
    }
    return {};
  var req = new GetAddrInfoReqWrap();
  req.callback = callback;
  req.family = family;
  req.hostname = hostname;
  req.oncomplete = all ? onlookupall : onlookup;
  var err = cares.getaddrinfo(req, hostname, family, hints);
  if (err) {
    callback(errnoException(err, 'getaddrinfo', hostname));
    return {};
  callback.immediately = true;
  return req;
function onlookupservice(err, host, service) {
  if (err)
    return this.callback(errnoException(err, 'getnameinfo', this.host));
  this.callback(null, host, service);
// lookupService(address, port, callback)
exports.lookupService = function(host, port, callback) {
  if (arguments.length !== 3)
    throw new Error('invalid arguments');
  if (cares.isIP(host) === 0)
    throw new TypeError('host needs to be a valid IP address');
  if (typeof port !== 'number')
    throw new TypeError(`port argument must be a number, got "${port}"`);
  callback = makeAsync(callback);
  var req = new GetNameInfoReqWrap();
  req.callback = callback;
  req.host = host;
  req.port = port;
  req.oncomplete = onlookupservice;
  var err = cares.getnameinfo(req, host, port);
  if (err) throw errnoException(err, 'getnameinfo', host);
  callback.immediately = true;
  return req;
function onresolve(err, result) {
  if (err)
    this.callback(errnoException(err, this.bindingName, this.hostname));
  else
    this.callback(null, result);
function resolver(bindingName) {
  var binding = cares[bindingName];
  return function query(name, callback) {
    if (typeof name !== 'string') {
      throw new Error('Name must be a string');
    } else if (typeof callback !== 'function') {
      throw new Error('Callback must be a function');
    }
    callback = makeAsync(callback);
    var req = new QueryReqWrap();
    req.bindingName = bindingName;
    req.callback = callback;
    req.hostname = name;
    req.oncomplete = onresolve;
    var err = binding(req, name);
    if (err) throw errnoException(err, bindingName);
    callback.immediately = true;
    return req;
  };
var resolveMap = Object.create(null);
exports.resolve4 = resolveMap.A = resolver('queryA');
exports.resolve6 = resolveMap.AAAA = resolver('queryAaaa');
exports.resolveCname = resolveMap.CNAME = resolver('queryCname');
exports.resolveMx = resolveMap.MX = resolver('queryMx');
exports.resolveNs = resolveMap.NS = resolver('queryNs');
exports.resolveTxt = resolveMap.TXT = resolver('queryTxt');
exports.resolveSrv = resolveMap.SRV = resolver('querySrv');
exports.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');
exports.resolveSoa = resolveMap.SOA = resolver('querySoa');
exports.reverse = resolveMap.PTR = resolver('getHostByAddr');
exports.resolve = function(hostname, type_, callback_) {
  var resolver, callback;
  if (typeof type_ === 'string') {
    resolver = resolveMap[type_];
    callback = callback_;
  } else if (typeof type_ === 'function') {
    resolver = exports.resolve4;
    callback = type_;
  } else {
    throw new Error('Type must be a string');
  if (typeof resolver === 'function') {
    return resolver(hostname, callback);
  } else {
    throw new Error(`Unknown type "${type_}"`);
exports.getServers = function() {
  return cares.getServers();
exports.setServers = function(servers) {
  // cache the original servers because in the event of an error setting the
  // servers cares won't have any servers available for resolution
  var orig = cares.getServers();
  var newSet = [];
  servers.forEach(function(serv) {
    var ver = isIp(serv);
    if (ver)
      return newSet.push([ver, serv]);
    var match = serv.match(/\[(.*)\](:\d+)?/);
    // we have an IPv6 in brackets
    if (match) {
      ver = isIp(match[1]);
      if (ver)
        return newSet.push([ver, match[1]]);
    }
    var s = serv.split(/:\d+$/)[0];
    ver = isIp(s);
    if (ver)
      return newSet.push([ver, s]);
    throw new Error(`IP address is not properly formatted: ${serv}`);
  });
  var r = cares.setServers(newSet);
  if (r) {
    // reset the servers to the old servers, because ares probably unset them
    cares.setServers(orig.join(','));
    var err = cares.strerror(r);
    throw new Error(`c-ares failed to set servers: "${err}" [${servers}]`);
// uv_getaddrinfo flags
exports.ADDRCONFIG = cares.AI_ADDRCONFIG;
exports.V4MAPPED = cares.AI_V4MAPPED;
// ERROR CODES
exports.NODATA = 'ENODATA';
exports.FORMERR = 'EFORMERR';
exports.SERVFAIL = 'ESERVFAIL';
exports.NOTFOUND = 'ENOTFOUND';
exports.NOTIMP = 'ENOTIMP';
exports.REFUSED = 'EREFUSED';
exports.BADQUERY = 'EBADQUERY';
exports.BADNAME = 'EBADNAME';
exports.BADFAMILY = 'EBADFAMILY';
exports.BADRESP = 'EBADRESP';
exports.CONNREFUSED = 'ECONNREFUSED';
exports.TIMEOUT = 'ETIMEOUT';
exports.EOF = 'EOF';
exports.FILE = 'EFILE';
exports.NOMEM = 'ENOMEM';
exports.DESTRUCTION = 'EDESTRUCTION';
exports.BADSTR = 'EBADSTR';
exports.BADFLAGS = 'EBADFLAGS';
exports.NONAME = 'ENONAME';
exports.BADHINTS = 'EBADHINTS';
exports.NOTINITIALIZED = 'ENOTINITIALIZED';
exports.LOADIPHLPAPI = 'ELOADIPHLPAPI';
exports.ADDRGETNETWORKPARAMS = 'EADDRGETNETWORKPARAMS';
exports.CANCELLED = 'ECANCELLED';
'use strict';
// WARNING: THIS MODULE IS PENDING DEPRECATION.
// No new pull requests targeting this module will be accepted
// unless they address existing, critical bugs.
const util = require('util');
const EventEmitter = require('events');
const inherits = util.inherits;
// communicate with events module, but don't require that
// module to have to load this one, since this module has
// a few side effects.
EventEmitter.usingDomains = true;
// overwrite process.domain with a getter/setter that will allow for more
// effective optimizations
var _domain = [null];
Object.defineProperty(process, 'domain', {
  enumerable: true,
  get: function() {
    return _domain[0];
  },
  set: function(arg) {
    return _domain[0] = arg;
// It's possible to enter one domain while already inside
// another one.  the stack is each entered domain.
const stack = [];
exports._stack = stack;
// let the process know we're using domains
const _domain_flag = process._setupDomainUse(_domain, stack);
exports.Domain = Domain;
exports.create = exports.createDomain = function() {
  return new Domain();
// the active domain is always the one that we're currently in.
exports.active = null;
inherits(Domain, EventEmitter);
function Domain() {
  EventEmitter.call(this);
  this.members = [];
Domain.prototype.members = undefined;
Domain.prototype._disposed = undefined;
// Called by process._fatalException in case an error was thrown.
Domain.prototype._errorHandler = function errorHandler(er) {
  var caught = false;
  var self = this;
  function emitError() {
    var handled = self.emit('error', er);
    // Exit all domains on the stack.  Uncaught exceptions end the
    // current tick and no domains should be left on the stack
    // between ticks.
    stack.length = 0;
    exports.active = process.domain = null;
    return handled;
  // ignore errors on disposed domains.
  //
  // XXX This is a bit stupid.  We should probably get rid of
  // domain.dispose() altogether.  It's almost always a terrible
  // idea.  --isaacs
  if (this._disposed)
    return true;
  if (!util.isPrimitive(er)) {
    er.domain = this;
    er.domainThrown = true;
  // The top-level domain-handler is handled separately.
  //
  // The reason is that if V8 was passed a command line option
  // asking it to abort on an uncaught exception (currently
  // "--abort-on-uncaught-exception"), we want an uncaught exception
  // in the top-level domain error handler to make the
  // process abort. Using try/catch here would always make V8 think
  // that these exceptions are caught, and thus would prevent it from
  // aborting in these cases.
  if (stack.length === 1) {
    // If there's no error handler, do not emit an 'error' event
    // as this would throw an error, make the process exit, and thus
    // prevent the process 'uncaughtException' event from being emitted
    // if a listener is set.
    if (EventEmitter.listenerCount(self, 'error') > 0) {
      try {
        // Set the _emittingTopLevelDomainError so that we know that, even
        // if technically the top-level domain is still active, it would
        // be ok to abort on an uncaught exception at this point
        process._emittingTopLevelDomainError = true;
        caught = emitError();
      } finally {
        process._emittingTopLevelDomainError = false;
      }
    }
  } else {
    // wrap this in a try/catch so we don't get infinite throwing
    try {
      // One of three things will happen here.
      //
      // 1. There is a handler, caught = true
      // 2. There is no handler, caught = false
      // 3. It throws, caught = false
      //
      // If caught is false after this, then there's no need to exit()
      // the domain, because we're going to crash the process anyway.
      caught = emitError();
    } catch (er2) {
      // The domain error handler threw!  oh no!
      // See if another domain can catch THIS error,
      // or else crash on the original one.
      // If the user already exited it, then don't double-exit.
      if (this === exports.active) {
        stack.pop();
      }
      if (stack.length) {
        exports.active = process.domain = stack[stack.length - 1];
        caught = process._fatalException(er2);
      } else {
        caught = false;
      }
      return caught;
    }
  return caught;
Domain.prototype.enter = function() {
  if (this._disposed) return;
  // note that this might be a no-op, but we still need
  // to push it onto the stack so that we can pop it later.
  exports.active = process.domain = this;
  stack.push(this);
  _domain_flag[0] = stack.length;
Domain.prototype.exit = function() {
  // skip disposed domains, as usual, but also don't do anything if this
  // domain is not on the stack.
  var index = stack.lastIndexOf(this);
  if (this._disposed || index === -1) return;
  // exit all domains until this one.
  stack.splice(index);
  _domain_flag[0] = stack.length;
  exports.active = stack[stack.length - 1];
  process.domain = exports.active;
// note: this works for timers as well.
Domain.prototype.add = function(ee) {
  // If the domain is disposed or already added, then nothing left to do.
  if (this._disposed || ee.domain === this)
    return;
  // has a domain already - remove it first.
  if (ee.domain)
    ee.domain.remove(ee);
  // check for circular Domain->Domain links.
  // This causes bad insanity!
  //
  // For example:
  // var d = domain.create();
  // var e = domain.create();
  // d.add(e);
  // e.add(d);
  // e.emit('error', er); // RangeError, stack overflow!
  if (this.domain && (ee instanceof Domain)) {
    for (var d = this.domain; d; d = d.domain) {
      if (ee === d) return;
    }
  ee.domain = this;
  this.members.push(ee);
Domain.prototype.remove = function(ee) {
  ee.domain = null;
  var index = this.members.indexOf(ee);
  if (index !== -1)
    this.members.splice(index, 1);
Domain.prototype.run = function(fn) {
  if (this._disposed)
    return;
  var ret;
  this.enter();
  if (arguments.length >= 2) {
    var len = arguments.length;
    var args = new Array(len - 1);
    for (var i = 1; i < len; i++)
      args[i - 1] = arguments[i];
    ret = fn.apply(this, args);
  } else {
    ret = fn.call(this);
  this.exit();
  return ret;
function intercepted(_this, self, cb, fnargs) {
  if (self._disposed)
    return;
  if (fnargs[0] && fnargs[0] instanceof Error) {
    var er = fnargs[0];
    util._extend(er, {
      domainBound: cb,
      domainThrown: false,
      domain: self
    });
    self.emit('error', er);
    return;
  var args = [];
  var i, ret;
  self.enter();
  if (fnargs.length > 1) {
    for (i = 1; i < fnargs.length; i++)
      args.push(fnargs[i]);
    ret = cb.apply(_this, args);
  } else {
    ret = cb.call(_this);
  self.exit();
  return ret;
Domain.prototype.intercept = function(cb) {
  var self = this;
  function runIntercepted() {
    return intercepted(this, self, cb, arguments);
  return runIntercepted;
function bound(_this, self, cb, fnargs) {
  if (self._disposed)
    return;
  var ret;
  self.enter();
  if (fnargs.length > 0)
    ret = cb.apply(_this, fnargs);
  else
    ret = cb.call(_this);
  self.exit();
  return ret;
Domain.prototype.bind = function(cb) {
  var self = this;
  function runBound() {
    return bound(this, self, cb, arguments);
  runBound.domain = this;
  return runBound;
Domain.prototype.dispose = util.deprecate(function() {
  if (this._disposed) return;
  // if we're the active domain, then get out now.
  this.exit();
  // remove from parent domain, if there is one.
  if (this.domain) this.domain.remove(this);
  // kill the references so that they can be properly gc'ed.
  this.members.length = 0;
  // mark this domain as 'no longer relevant'
  // so that it can't be entered or activated.
  this._disposed = true;
'use strict';
var domain;
function EventEmitter() {
  EventEmitter.init.call(this);
module.exports = EventEmitter;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    domain = domain || require('domain');
    if (domain.active && !(this instanceof domain.Domain)) {
      this.domain = domain.active;
    }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = {};
    this._eventsCount = 0;
  this._maxListeners = this._maxListeners || undefined;
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === 'error');
  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;
  domain = this.domain;
  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event.');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  handler = events[type];
  if (!handler)
    return false;
  if (domain && this !== process) {
    domain.enter();
    needDomainExit = true;
  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  if (needDomainExit)
    domain.exit();
  return true;
EventEmitter.prototype.addListener = function addListener(type, listener) {
  var m;
  var events;
  var existing;
  if (typeof listener !== 'function')
    throw new TypeError('listener must be a function');
  events = this._events;
  if (!events) {
    events = this._events = {};
    this._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      this.emit('newListener', type,
                listener.listener ? listener.listener : listener);
      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = this._events;
    }
    existing = events[type];
  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++this._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = [existing, listener];
    } else {
      // If we've already got an array, just append.
      existing.push(listener);
    }
    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(this);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d %s listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      existing.length, type);
        console.trace();
      }
    }
  return this;
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('listener must be a function');
  var fired = false;
  function g() {
    this.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  g.listener = listener;
  this.on(type, g);
  return this;
// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i;
      if (typeof listener !== 'function')
        throw new TypeError('listener must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type];
      if (!list)
        return this;
      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = {};
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;
        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = {};
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit('removeListener', type, listener);
      }
      return this;
    };
EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;
      events = this._events;
      if (!events)
        return this;
      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = {};
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = {};
          else
            delete events[type];
        }
        return this;
      }
      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = {};
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }
      return this;
    };
EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;
  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  return ret;
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  const events = this._events;
  if (events) {
    const evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  return 0;
// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
'use strict';
const util = require('internal/util');
module.exports = require('internal/freelist');
util.printDeprecationMessage('freelist module is deprecated.');
// Maintainers, keep in mind that ES1-style octal literals (`0666`) are not
// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).
'use strict';
const SlowBuffer = require('buffer').SlowBuffer;
const util = require('util');
const pathModule = require('path');
const binding = process.binding('fs');
const constants = require('constants');
const fs = exports;
const Buffer = require('buffer').Buffer;
const Stream = require('stream').Stream;
const EventEmitter = require('events');
const FSReqWrap = binding.FSReqWrap;
const FSEvent = process.binding('fs_event_wrap').FSEvent;
const Readable = Stream.Readable;
const Writable = Stream.Writable;
const kMinPoolSpace = 128;
const kMaxLength = require('buffer').kMaxLength;
const O_APPEND = constants.O_APPEND || 0;
const O_CREAT = constants.O_CREAT || 0;
const O_EXCL = constants.O_EXCL || 0;
const O_RDONLY = constants.O_RDONLY || 0;
const O_RDWR = constants.O_RDWR || 0;
const O_SYNC = constants.O_SYNC || 0;
const O_TRUNC = constants.O_TRUNC || 0;
const O_WRONLY = constants.O_WRONLY || 0;
const isWindows = process.platform === 'win32';
const DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
const errnoException = util._errnoException;
function throwOptionsError(options) {
  throw new TypeError('Expected options to be either an object or a string, ' +
    'but got ' + typeof options + ' instead');
function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  if (DEBUG) {
    var backtrace = new Error();
    return function(err) {
      if (err) {
        backtrace.stack = err.name + ': ' + err.message +
                          backtrace.stack.substr(backtrace.name.length);
        throw backtrace;
      }
    };
  return function(err) {
    if (err) {
      throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
    }
  };
function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
// Ensure that callbacks run in the global context. Only use this function
// for callbacks that are passed to the binding layer, callbacks that are
// invoked from JS already run in the proper scope.
function makeCallback(cb) {
  if (cb === undefined) {
    return rethrow();
  if (typeof cb !== 'function') {
    throw new TypeError('callback must be a function');
  return function() {
    return cb.apply(null, arguments);
  };
function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
function nullCheck(path, callback) {
  if (('' + path).indexOf('\u0000') !== -1) {
    var er = new Error('Path must be a string without null bytes.');
    er.code = 'ENOENT';
    if (typeof callback !== 'function')
      throw er;
    process.nextTick(callback, er);
    return false;
  return true;
// Static method to set the stats properties on a Stats object.
fs.Stats = function(
    dev,
    mode,
    nlink,
    uid,
    gid,
    rdev,
    blksize,
    ino,
    size,
    blocks,
    atim_msec,
    mtim_msec,
    ctim_msec,
    birthtim_msec) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
  this.atime = new Date(atim_msec);
  this.mtime = new Date(mtim_msec);
  this.ctime = new Date(ctim_msec);
  this.birthtime = new Date(birthtim_msec);
// Create a C++ binding to the function which creates a Stats object.
binding.FSInitialize(fs.Stats);
fs.Stats.prototype._checkModeProperty = function(property) {
  return ((this.mode & constants.S_IFMT) === property);
fs.Stats.prototype.isDirectory = function() {
  return this._checkModeProperty(constants.S_IFDIR);
fs.Stats.prototype.isFile = function() {
  return this._checkModeProperty(constants.S_IFREG);
fs.Stats.prototype.isBlockDevice = function() {
  return this._checkModeProperty(constants.S_IFBLK);
fs.Stats.prototype.isCharacterDevice = function() {
  return this._checkModeProperty(constants.S_IFCHR);
fs.Stats.prototype.isSymbolicLink = function() {
  return this._checkModeProperty(constants.S_IFLNK);
fs.Stats.prototype.isFIFO = function() {
  return this._checkModeProperty(constants.S_IFIFO);
fs.Stats.prototype.isSocket = function() {
  return this._checkModeProperty(constants.S_IFSOCK);
// Don't allow mode to accidentally be overwritten.
['F_OK', 'R_OK', 'W_OK', 'X_OK'].forEach(function(key) {
  Object.defineProperty(fs, key, {
    enumerable: true, value: constants[key] || 0, writable: false
  });
fs.access = function(path, mode, callback) {
  if (typeof mode === 'function') {
    callback = mode;
    mode = fs.F_OK;
  } else if (typeof callback !== 'function') {
    throw new TypeError('callback must be a function');
  if (!nullCheck(path, callback))
    return;
  mode = mode | 0;
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.access(pathModule._makeLong(path), mode, req);
fs.accessSync = function(path, mode) {
  nullCheck(path);
  if (mode === undefined)
    mode = fs.F_OK;
  else
    mode = mode | 0;
  binding.access(pathModule._makeLong(path), mode);
fs.exists = function(path, callback) {
  if (!nullCheck(path, cb)) return;
  var req = new FSReqWrap();
  req.oncomplete = cb;
  binding.stat(pathModule._makeLong(path), req);
  function cb(err, stats) {
    if (callback) callback(err ? false : true);
fs.existsSync = function(path) {
  try {
    nullCheck(path);
    binding.stat(pathModule._makeLong(path));
    return true;
  } catch (e) {
    return false;
fs.readFile = function(path, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);
  if (!options || typeof options === 'function') {
    options = { encoding: null, flag: 'r' };
  } else if (typeof options === 'string') {
    options = { encoding: options, flag: 'r' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  var encoding = options.encoding;
  assertEncoding(encoding);
  var flag = options.flag || 'r';
  if (!nullCheck(path, callback))
    return;
  var context = new ReadFileContext(callback, encoding);
  var req = new FSReqWrap();
  req.context = context;
  req.oncomplete = readFileAfterOpen;
  binding.open(pathModule._makeLong(path),
               stringToFlags(flag),
               0o666,
               req);
const kReadFileBufferLength = 8 * 1024;
function ReadFileContext(callback, encoding) {
  this.fd = undefined;
  this.size = undefined;
  this.callback = callback;
  this.buffers = null;
  this.buffer = null;
  this.pos = 0;
  this.encoding = encoding;
  this.err = null;
ReadFileContext.prototype.read = function() {
  var buffer;
  var offset;
  var length;
  if (this.size === 0) {
    buffer = this.buffer = new SlowBuffer(kReadFileBufferLength);
    offset = 0;
    length = kReadFileBufferLength;
  } else {
    buffer = this.buffer;
    offset = this.pos;
    length = this.size - this.pos;
  var req = new FSReqWrap();
  req.oncomplete = readFileAfterRead;
  req.context = this;
  binding.read(this.fd, buffer, offset, length, -1, req);
ReadFileContext.prototype.close = function(err) {
  var req = new FSReqWrap();
  req.oncomplete = readFileAfterClose;
  req.context = this;
  this.err = err;
  binding.close(this.fd, req);
function readFileAfterOpen(err, fd) {
  var context = this.context;
  if (err) {
    context.callback(err);
    return;
  context.fd = fd;
  var req = new FSReqWrap();
  req.oncomplete = readFileAfterStat;
  req.context = context;
  binding.fstat(fd, req);
function readFileAfterStat(err, st) {
  var context = this.context;
  if (err)
    return context.close(err);
  var size = context.size = st.isFile() ? st.size : 0;
  if (size === 0) {
    context.buffers = [];
    context.read();
    return;
  if (size > kMaxLength) {
    err = new RangeError('File size is greater than possible Buffer: ' +
                         `0x${kMaxLength.toString(16)} bytes`);
    return context.close(err);
  context.buffer = new SlowBuffer(size);
  context.read();
function readFileAfterRead(err, bytesRead) {
  var context = this.context;
  if (err)
    return context.close(err);
  if (bytesRead === 0)
    return context.close();
  context.pos += bytesRead;
  if (context.size !== 0) {
    if (context.pos === context.size)
      context.close();
    else
      context.read();
  } else {
    // unknown size, just read until we don't get bytes.
    context.buffers.push(context.buffer.slice(0, bytesRead));
    context.read();
function readFileAfterClose(err) {
  var context = this.context;
  var buffer = null;
  var callback = context.callback;
  if (context.err)
    return callback(context.err);
  if (context.size === 0)
    buffer = Buffer.concat(context.buffers, context.pos);
  else if (context.pos < context.size)
    buffer = context.buffer.slice(0, context.pos);
  else
    buffer = context.buffer;
  if (context.encoding)
    buffer = buffer.toString(context.encoding);
  callback(err, buffer);
fs.readFileSync = function(path, options) {
  if (!options) {
    options = { encoding: null, flag: 'r' };
  } else if (typeof options === 'string') {
    options = { encoding: options, flag: 'r' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  var encoding = options.encoding;
  assertEncoding(encoding);
  var flag = options.flag || 'r';
  var fd = fs.openSync(path, flag, 0o666);
  var st;
  var size;
  var threw = true;
  try {
    st = fs.fstatSync(fd);
    size = st.isFile() ? st.size : 0;
    threw = false;
  } finally {
    if (threw) fs.closeSync(fd);
  var pos = 0;
  var buffer; // single buffer with file data
  var buffers; // list for when size is unknown
  if (size === 0) {
    buffers = [];
  } else {
    threw = true;
    try {
      buffer = new Buffer(size);
      threw = false;
    } finally {
      if (threw) fs.closeSync(fd);
    }
  var done = false;
  var bytesRead;
  while (!done) {
    threw = true;
    try {
      if (size !== 0) {
        bytesRead = fs.readSync(fd, buffer, pos, size - pos);
      } else {
        // the kernel lies about many files.
        // Go ahead and try to read some bytes.
        buffer = new Buffer(8192);
        bytesRead = fs.readSync(fd, buffer, 0, 8192);
        if (bytesRead) {
          buffers.push(buffer.slice(0, bytesRead));
        }
      }
      threw = false;
    } finally {
      if (threw) fs.closeSync(fd);
    }
    pos += bytesRead;
    done = (bytesRead === 0) || (size !== 0 && pos >= size);
  fs.closeSync(fd);
  if (size === 0) {
    // data was collected into the buffers list.
    buffer = Buffer.concat(buffers, pos);
  } else if (pos < size) {
    buffer = buffer.slice(0, pos);
  if (encoding) buffer = buffer.toString(encoding);
  return buffer;
// Used by binding.open and friends
function stringToFlags(flag) {
  // Only mess with strings
  if (typeof flag !== 'string') {
    return flag;
  switch (flag) {
    case 'r' : return O_RDONLY;
    case 'rs' : // fall through
    case 'sr' : return O_RDONLY | O_SYNC;
    case 'r+' : return O_RDWR;
    case 'rs+' : // fall through
    case 'sr+' : return O_RDWR | O_SYNC;
    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;
    case 'wx' : // fall through
    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;
    case 'wx+': // fall through
    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;
    case 'ax' : // fall through
    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;
    case 'ax+': // fall through
    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
  throw new Error('Unknown file open flag: ' + flag);
// exported but hidden, only used by test/simple/test-fs-open-flags.js
Object.defineProperty(exports, '_stringToFlags', {
  enumerable: false,
  value: stringToFlags
// Yes, the follow could be easily DRYed up but I provide the explicit
// list to make the arguments clear.
fs.close = function(fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.close(fd, req);
fs.closeSync = function(fd) {
  return binding.close(fd);
function modeNum(m, def) {
  if (typeof m === 'number')
    return m;
  if (typeof m === 'string')
    return parseInt(m, 8);
  if (def)
    return modeNum(def);
  return undefined;
fs.open = function(path, flags, mode, callback_) {
  var callback = makeCallback(arguments[arguments.length - 1]);
  mode = modeNum(mode, 0o666);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.open(pathModule._makeLong(path),
               stringToFlags(flags),
               mode,
               req);
fs.openSync = function(path, flags, mode) {
  mode = modeNum(mode, 0o666);
  nullCheck(path);
  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);
fs.read = function(fd, buffer, offset, length, position, callback) {
  if (!(buffer instanceof Buffer)) {
    // legacy string interface (fd, length, position, encoding, callback)
    const cb = arguments[4];
    const encoding = arguments[3];
    assertEncoding(encoding);
    position = arguments[2];
    length = arguments[1];
    buffer = new Buffer(length);
    offset = 0;
    callback = function(err, bytesRead) {
      if (!cb) return;
      var str = (bytesRead > 0) ? buffer.toString(encoding, 0, bytesRead) : '';
      (cb)(err, str, bytesRead);
    };
  function wrapper(err, bytesRead) {
    // Retain a reference to buffer so that it can't be GC'ed too soon.
    callback && callback(err, bytesRead || 0, buffer);
  var req = new FSReqWrap();
  req.oncomplete = wrapper;
  binding.read(fd, buffer, offset, length, position, req);
fs.readSync = function(fd, buffer, offset, length, position) {
  var legacy = false;
  var encoding;
  if (!(buffer instanceof Buffer)) {
    // legacy string interface (fd, length, position, encoding, callback)
    legacy = true;
    encoding = arguments[3];
    assertEncoding(encoding);
    position = arguments[2];
    length = arguments[1];
    buffer = new Buffer(length);
    offset = 0;
  var r = binding.read(fd, buffer, offset, length, position);
  if (!legacy) {
    return r;
  var str = (r > 0) ? buffer.toString(encoding, 0, r) : '';
  return [str, r];
// usage:
//  fs.write(fd, buffer, offset, length[, position], callback);
// OR
//  fs.write(fd, string[, position[, encoding]], callback);
fs.write = function(fd, buffer, offset, length, position, callback) {
  function wrapper(err, written) {
    // Retain a reference to buffer so that it can't be GC'ed too soon.
    callback(err, written || 0, buffer);
  var req = new FSReqWrap();
  req.oncomplete = wrapper;
  if (buffer instanceof Buffer) {
    // if no position is passed then assume null
    if (typeof position === 'function') {
      callback = position;
      position = null;
    }
    callback = maybeCallback(callback);
    return binding.writeBuffer(fd, buffer, offset, length, position, req);
  if (typeof buffer !== 'string')
    buffer += '';
  if (typeof position !== 'function') {
    if (typeof offset === 'function') {
      position = offset;
      offset = null;
    } else {
      position = length;
    }
    length = 'utf8';
  callback = maybeCallback(position);
  return binding.writeString(fd, buffer, offset, length, req);
// usage:
//  fs.writeSync(fd, buffer, offset, length[, position]);
// OR
//  fs.writeSync(fd, string[, position[, encoding]]);
fs.writeSync = function(fd, buffer, offset, length, position) {
  if (buffer instanceof Buffer) {
    if (position === undefined)
      position = null;
    return binding.writeBuffer(fd, buffer, offset, length, position);
  if (typeof buffer !== 'string')
    buffer += '';
  if (offset === undefined)
    offset = null;
  return binding.writeString(fd, buffer, offset, length, position);
fs.rename = function(oldPath, newPath, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(oldPath, callback)) return;
  if (!nullCheck(newPath, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rename(pathModule._makeLong(oldPath),
                 pathModule._makeLong(newPath),
                 req);
fs.renameSync = function(oldPath, newPath) {
  nullCheck(oldPath);
  nullCheck(newPath);
  return binding.rename(pathModule._makeLong(oldPath),
                        pathModule._makeLong(newPath));
fs.truncate = function(path, len, callback) {
  if (typeof path === 'number') {
    return fs.ftruncate(path, len, callback);
  if (typeof len === 'function') {
    callback = len;
    len = 0;
  } else if (len === undefined) {
    len = 0;
  callback = maybeCallback(callback);
  fs.open(path, 'r+', function(er, fd) {
    if (er) return callback(er);
    var req = new FSReqWrap();
    req.oncomplete = function ftruncateCb(er) {
      fs.close(fd, function(er2) {
        callback(er || er2);
      });
    };
    binding.ftruncate(fd, len, req);
  });
fs.truncateSync = function(path, len) {
  if (typeof path === 'number') {
    // legacy
    return fs.ftruncateSync(path, len);
  if (len === undefined) {
    len = 0;
  // allow error to be thrown, but still close fd.
  var fd = fs.openSync(path, 'r+');
  var ret;
  try {
    ret = fs.ftruncateSync(fd, len);
  } finally {
    fs.closeSync(fd);
  return ret;
fs.ftruncate = function(fd, len, callback) {
  if (typeof len === 'function') {
    callback = len;
    len = 0;
  } else if (len === undefined) {
    len = 0;
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.ftruncate(fd, len, req);
fs.ftruncateSync = function(fd, len) {
  if (len === undefined) {
    len = 0;
  return binding.ftruncate(fd, len);
fs.rmdir = function(path, callback) {
  callback = maybeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rmdir(pathModule._makeLong(path), req);
fs.rmdirSync = function(path) {
  nullCheck(path);
  return binding.rmdir(pathModule._makeLong(path));
fs.fdatasync = function(fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fdatasync(fd, req);
fs.fdatasyncSync = function(fd) {
  return binding.fdatasync(fd);
fs.fsync = function(fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fsync(fd, req);
fs.fsyncSync = function(fd) {
  return binding.fsync(fd);
fs.mkdir = function(path, mode, callback) {
  if (typeof mode === 'function') callback = mode;
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.mkdir(pathModule._makeLong(path),
                modeNum(mode, 0o777),
                req);
fs.mkdirSync = function(path, mode) {
  nullCheck(path);
  return binding.mkdir(pathModule._makeLong(path),
                       modeNum(mode, 0o777));
fs.readdir = function(path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.readdir(pathModule._makeLong(path), req);
fs.readdirSync = function(path) {
  nullCheck(path);
  return binding.readdir(pathModule._makeLong(path));
fs.fstat = function(fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fstat(fd, req);
fs.lstat = function(path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.lstat(pathModule._makeLong(path), req);
fs.stat = function(path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.stat(pathModule._makeLong(path), req);
fs.fstatSync = function(fd) {
  return binding.fstat(fd);
fs.lstatSync = function(path) {
  nullCheck(path);
  return binding.lstat(pathModule._makeLong(path));
fs.statSync = function(path) {
  nullCheck(path);
  return binding.stat(pathModule._makeLong(path));
fs.readlink = function(path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.readlink(pathModule._makeLong(path), req);
fs.readlinkSync = function(path) {
  nullCheck(path);
  return binding.readlink(pathModule._makeLong(path));
function preprocessSymlinkDestination(path, type, linkPath) {
  if (!isWindows) {
    // No preprocessing is needed on Unix.
    return path;
  } else if (type === 'junction') {
    // Junctions paths need to be absolute and \\?\-prefixed.
    // A relative target is relative to the link's parent directory.
    path = pathModule.resolve(linkPath, '..', path);
    return pathModule._makeLong(path);
  } else {
    // Windows symlinks don't tolerate forward slashes.
    return ('' + path).replace(/\//g, '\\');
fs.symlink = function(target, path, type_, callback_) {
  var type = (typeof type_ === 'string' ? type_ : null);
  var callback = makeCallback(arguments[arguments.length - 1]);
  if (!nullCheck(target, callback)) return;
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.symlink(preprocessSymlinkDestination(target, type, path),
                  pathModule._makeLong(path),
                  type,
                  req);
fs.symlinkSync = function(target, path, type) {
  type = (typeof type === 'string' ? type : null);
  nullCheck(target);
  nullCheck(path);
  return binding.symlink(preprocessSymlinkDestination(target, type, path),
                         pathModule._makeLong(path),
                         type);
fs.link = function(srcpath, dstpath, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(srcpath, callback)) return;
  if (!nullCheck(dstpath, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.link(pathModule._makeLong(srcpath),
               pathModule._makeLong(dstpath),
               req);
fs.linkSync = function(srcpath, dstpath) {
  nullCheck(srcpath);
  nullCheck(dstpath);
  return binding.link(pathModule._makeLong(srcpath),
                      pathModule._makeLong(dstpath));
fs.unlink = function(path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.unlink(pathModule._makeLong(path), req);
fs.unlinkSync = function(path) {
  nullCheck(path);
  return binding.unlink(pathModule._makeLong(path));
fs.fchmod = function(fd, mode, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fchmod(fd, modeNum(mode), req);
fs.fchmodSync = function(fd, mode) {
  return binding.fchmod(fd, modeNum(mode));
if (constants.hasOwnProperty('O_SYMLINK')) {
  fs.lchmod = function(path, mode, callback) {
    callback = maybeCallback(callback);
    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {
      if (err) {
        callback(err);
        return;
      }
      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      fs.fchmod(fd, mode, function(err) {
        fs.close(fd, function(err2) {
          callback(err || err2);
        });
      });
    });
  };
  fs.lchmodSync = function(path, mode) {
    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);
    // prefer to return the chmod error, if one occurs,
    // but still try to close, and report closing errors if they occur.
    var err, err2, ret;
    try {
      ret = fs.fchmodSync(fd, mode);
    } catch (er) {
      err = er;
    }
    try {
      fs.closeSync(fd);
    } catch (er) {
      err2 = er;
    }
    if (err || err2) throw (err || err2);
    return ret;
  };
fs.chmod = function(path, mode, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.chmod(pathModule._makeLong(path),
                modeNum(mode),
                req);
fs.chmodSync = function(path, mode) {
  nullCheck(path);
  return binding.chmod(pathModule._makeLong(path), modeNum(mode));
if (constants.hasOwnProperty('O_SYMLINK')) {
  fs.lchown = function(path, uid, gid, callback) {
    callback = maybeCallback(callback);
    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {
      if (err) {
        callback(err);
        return;
      }
      fs.fchown(fd, uid, gid, callback);
    });
  };
  fs.lchownSync = function(path, uid, gid) {
    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);
    return fs.fchownSync(fd, uid, gid);
  };
fs.fchown = function(fd, uid, gid, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fchown(fd, uid, gid, req);
fs.fchownSync = function(fd, uid, gid) {
  return binding.fchown(fd, uid, gid);
fs.chown = function(path, uid, gid, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.chown(pathModule._makeLong(path), uid, gid, req);
fs.chownSync = function(path, uid, gid) {
  nullCheck(path);
  return binding.chown(pathModule._makeLong(path), uid, gid);
// converts Date or number to a fractional UNIX timestamp
function toUnixTimestamp(time) {
  if (typeof time === 'string' && +time == time) {
    return +time;
  if (typeof time === 'number') {
    if (!Number.isFinite(time) || time < 0) {
      return Date.now() / 1000;
    }
    return time;
  if (util.isDate(time)) {
    // convert to 123.456 UNIX timestamp
    return time.getTime() / 1000;
  throw new Error('Cannot parse time: ' + time);
// exported for unit tests, not for public consumption
fs._toUnixTimestamp = toUnixTimestamp;
fs.utimes = function(path, atime, mtime, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.utimes(pathModule._makeLong(path),
                 toUnixTimestamp(atime),
                 toUnixTimestamp(mtime),
                 req);
fs.utimesSync = function(path, atime, mtime) {
  nullCheck(path);
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  binding.utimes(pathModule._makeLong(path), atime, mtime);
fs.futimes = function(fd, atime, mtime, callback) {
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.futimes(fd, atime, mtime, req);
fs.futimesSync = function(fd, atime, mtime) {
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  binding.futimes(fd, atime, mtime);
function writeAll(fd, buffer, offset, length, position, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);
  // write(fd, buffer, offset, length, position, callback)
  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {
    if (writeErr) {
      fs.close(fd, function() {
        callback(writeErr);
      });
    } else {
      if (written === length) {
        fs.close(fd, callback);
      } else {
        offset += written;
        length -= written;
        if (position !== null) {
          position += written;
        }
        writeAll(fd, buffer, offset, length, position, callback);
      }
    }
  });
fs.writeFile = function(path, data, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);
  if (!options || typeof options === 'function') {
    options = { encoding: 'utf8', mode: 0o666, flag: 'w' };
  } else if (typeof options === 'string') {
    options = { encoding: options, mode: 0o666, flag: 'w' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  assertEncoding(options.encoding);
  var flag = options.flag || 'w';
  fs.open(path, flag, options.mode, function(openErr, fd) {
    if (openErr) {
      callback(openErr);
    } else {
      var buffer = (data instanceof Buffer) ? data : new Buffer('' + data,
          options.encoding || 'utf8');
      var position = /a/.test(flag) ? null : 0;
      writeAll(fd, buffer, 0, buffer.length, position, callback);
    }
  });
fs.writeFileSync = function(path, data, options) {
  if (!options) {
    options = { encoding: 'utf8', mode: 0o666, flag: 'w' };
  } else if (typeof options === 'string') {
    options = { encoding: options, mode: 0o666, flag: 'w' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  assertEncoding(options.encoding);
  var flag = options.flag || 'w';
  var fd = fs.openSync(path, flag, options.mode);
  if (!(data instanceof Buffer)) {
    data = new Buffer('' + data, options.encoding || 'utf8');
  var offset = 0;
  var length = data.length;
  var position = /a/.test(flag) ? null : 0;
  try {
    while (length > 0) {
      var written = fs.writeSync(fd, data, offset, length, position);
      offset += written;
      length -= written;
      if (position !== null) {
        position += written;
      }
    }
  } finally {
    fs.closeSync(fd);
fs.appendFile = function(path, data, options, callback_) {
  var callback = maybeCallback(arguments[arguments.length - 1]);
  if (!options || typeof options === 'function') {
    options = { encoding: 'utf8', mode: 0o666, flag: 'a' };
  } else if (typeof options === 'string') {
    options = { encoding: options, mode: 0o666, flag: 'a' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  if (!options.flag)
    options = util._extend({ flag: 'a' }, options);
  fs.writeFile(path, data, options, callback);
fs.appendFileSync = function(path, data, options) {
  if (!options) {
    options = { encoding: 'utf8', mode: 0o666, flag: 'a' };
  } else if (typeof options === 'string') {
    options = { encoding: options, mode: 0o666, flag: 'a' };
  } else if (typeof options !== 'object') {
    throwOptionsError(options);
  if (!options.flag)
    options = util._extend({ flag: 'a' }, options);
  fs.writeFileSync(path, data, options);
function FSWatcher() {
  EventEmitter.call(this);
  var self = this;
  this._handle = new FSEvent();
  this._handle.owner = this;
  this._handle.onchange = function(status, event, filename) {
    if (status < 0) {
      self._handle.close();
      const error = errnoException(status, `watch ${filename}`);
      error.filename = filename;
      self.emit('error', error);
    } else {
      self.emit('change', event, filename);
    }
  };
util.inherits(FSWatcher, EventEmitter);
FSWatcher.prototype.start = function(filename, persistent, recursive) {
  nullCheck(filename);
  var err = this._handle.start(pathModule._makeLong(filename),
                               persistent,
                               recursive);
  if (err) {
    this._handle.close();
    const error = errnoException(err, `watch ${filename}`);
    error.filename = filename;
    throw error;
FSWatcher.prototype.close = function() {
  this._handle.close();
fs.watch = function(filename) {
  nullCheck(filename);
  var watcher;
  var options;
  var listener;
  if (arguments[1] !== null && typeof arguments[1] === 'object') {
    options = arguments[1];
    listener = arguments[2];
  } else {
    options = {};
    listener = arguments[1];
  if (options.persistent === undefined) options.persistent = true;
  if (options.recursive === undefined) options.recursive = false;
  watcher = new FSWatcher();
  watcher.start(filename, options.persistent, options.recursive);
  if (listener) {
    watcher.addListener('change', listener);
  return watcher;
// Stat Change Watchers
function StatWatcher() {
  EventEmitter.call(this);
  var self = this;
  this._handle = new binding.StatWatcher();
  // uv_fs_poll is a little more powerful than ev_stat but we curb it for
  // the sake of backwards compatibility
  var oldStatus = -1;
  this._handle.onchange = function(current, previous, newStatus) {
    if (oldStatus === -1 &&
        newStatus === -1 &&
        current.nlink === previous.nlink) return;
    oldStatus = newStatus;
    self.emit('change', current, previous);
  };
  this._handle.onstop = function() {
    self.emit('stop');
  };
util.inherits(StatWatcher, EventEmitter);
StatWatcher.prototype.start = function(filename, persistent, interval) {
  nullCheck(filename);
  this._handle.start(pathModule._makeLong(filename), persistent, interval);
StatWatcher.prototype.stop = function() {
  this._handle.stop();
const statWatchers = new Map();
fs.watchFile = function(filename, options, listener) {
  nullCheck(filename);
  filename = pathModule.resolve(filename);
  var stat;
  var defaults = {
    // Poll interval in milliseconds. 5007 is what libev used to use. It's
    // a little on the slow side but let's stick with it for now to keep
    // behavioral changes to a minimum.
    interval: 5007,
    persistent: true
  };
  if (options !== null && typeof options === 'object') {
    options = util._extend(defaults, options);
  } else {
    listener = options;
    options = defaults;
  if (typeof listener !== 'function') {
    throw new Error('watchFile requires a listener function');
  stat = statWatchers.get(filename);
  if (stat === undefined) {
    stat = new StatWatcher();
    stat.start(filename, options.persistent, options.interval);
    statWatchers.set(filename, stat);
  stat.addListener('change', listener);
  return stat;
fs.unwatchFile = function(filename, listener) {
  nullCheck(filename);
  filename = pathModule.resolve(filename);
  var stat = statWatchers.get(filename);
  if (stat === undefined) return;
  if (typeof listener === 'function') {
    stat.removeListener('change', listener);
  } else {
    stat.removeAllListeners('change');
  if (stat.listenerCount('change') === 0) {
    stat.stop();
    statWatchers.delete(filename);
// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
const nextPartRe = isWindows ?
  /(.*?)(?:[\/\\]+|$)/g :
  /(.*?)(?:[\/]+|$)/g;
// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
const splitRootRe = isWindows ?
  /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/ :
  /^[\/]*/;
fs.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);
  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  const original = p;
  const seenLinks = {};
  const knownHard = {};
  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;
  start();
  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';
    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;
    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }
    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }
      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  if (cache) cache[original] = p;
  return p;
fs.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  // make p is absolute
  p = pathModule.resolve(p);
  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  const original = p;
  const seenLinks = {};
  const knownHard = {};
  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;
  start();
  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';
    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;
    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }
    return fs.lstat(base, gotStat);
  function gotStat(err, stat) {
    if (err) return cb(err);
    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }
    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);
      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  function gotTarget(err, target, base) {
    if (err) return cb(err);
    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
var pool;
function allocNewPool(poolSize) {
  pool = new Buffer(poolSize);
  pool.used = 0;
fs.createReadStream = function(path, options) {
  return new ReadStream(path, options);
util.inherits(ReadStream, Readable);
fs.ReadStream = ReadStream;
function ReadStream(path, options) {
  if (!(this instanceof ReadStream))
    return new ReadStream(path, options);
  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('options must be a string or an object');
  // a little bit bigger buffer and water marks by default
  options = Object.create(options);
  if (options.highWaterMark === undefined)
    options.highWaterMark = 64 * 1024;
  Readable.call(this, options);
  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'r' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;
  this.start = options.start;
  this.end = options.end;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
  this.pos = undefined;
  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('start must be a Number');
    }
    if (this.end === undefined) {
      this.end = Infinity;
    } else if (typeof this.end !== 'number') {
      throw new TypeError('end must be a Number');
    }
    if (this.start > this.end) {
      throw new Error('start must be <= end');
    }
    this.pos = this.start;
  if (typeof this.fd !== 'number')
    this.open();
  this.on('end', function() {
    if (this.autoClose) {
      this.destroy();
    }
  });
fs.FileReadStream = fs.ReadStream; // support the legacy name
ReadStream.prototype.open = function() {
  var self = this;
  fs.open(this.path, this.flags, this.mode, function(er, fd) {
    if (er) {
      if (self.autoClose) {
        self.destroy();
      }
      self.emit('error', er);
      return;
    }
    self.fd = fd;
    self.emit('open', fd);
    // start the flow of data.
    self.read();
  });
ReadStream.prototype._read = function(n) {
  if (typeof this.fd !== 'number')
    return this.once('open', function() {
      this._read(n);
    });
  if (this.destroyed)
    return;
  if (!pool || pool.length - pool.used < kMinPoolSpace) {
    // discard the old pool.
    pool = null;
    allocNewPool(this._readableState.highWaterMark);
  // Grab another reference to the pool in the case that while we're
  // in the thread pool another read() finishes up the pool, and
  // allocates a new one.
  var thisPool = pool;
  var toRead = Math.min(pool.length - pool.used, n);
  var start = pool.used;
  if (this.pos !== undefined)
    toRead = Math.min(this.end - this.pos + 1, toRead);
  // already read everything we were supposed to read!
  // treat as EOF.
  if (toRead <= 0)
    return this.push(null);
  // the actual read.
  var self = this;
  fs.read(this.fd, pool, pool.used, toRead, this.pos, onread);
  // move the pool positions, and internal position for reading.
  if (this.pos !== undefined)
    this.pos += toRead;
  pool.used += toRead;
  function onread(er, bytesRead) {
    if (er) {
      if (self.autoClose) {
        self.destroy();
      }
      self.emit('error', er);
    } else {
      var b = null;
      if (bytesRead > 0)
        b = thisPool.slice(start, start + bytesRead);
      self.push(b);
    }
ReadStream.prototype.destroy = function() {
  if (this.destroyed)
    return;
  this.destroyed = true;
  this.close();
ReadStream.prototype.close = function(cb) {
  var self = this;
  if (cb)
    this.once('close', cb);
  if (this.closed || typeof this.fd !== 'number') {
    if (typeof this.fd !== 'number') {
      this.once('open', close);
      return;
    }
    return process.nextTick(() => this.emit('close'));
  this.closed = true;
  close();
  function close(fd) {
    fs.close(fd || self.fd, function(er) {
      if (er)
        self.emit('error', er);
      else
        self.emit('close');
    });
    self.fd = null;
fs.createWriteStream = function(path, options) {
  return new WriteStream(path, options);
util.inherits(WriteStream, Writable);
fs.WriteStream = WriteStream;
function WriteStream(path, options) {
  if (!(this instanceof WriteStream))
    return new WriteStream(path, options);
  if (options === undefined)
    options = {};
  else if (typeof options === 'string')
    options = { encoding: options };
  else if (options === null || typeof options !== 'object')
    throw new TypeError('options must be a string or an object');
  options = Object.create(options);
  Writable.call(this, options);
  this.path = path;
  this.fd = options.fd === undefined ? null : options.fd;
  this.flags = options.flags === undefined ? 'w' : options.flags;
  this.mode = options.mode === undefined ? 0o666 : options.mode;
  this.start = options.start;
  this.pos = undefined;
  this.bytesWritten = 0;
  if (this.start !== undefined) {
    if (typeof this.start !== 'number') {
      throw new TypeError('start must be a Number');
    }
    if (this.start < 0) {
      throw new Error('start must be >= zero');
    }
    this.pos = this.start;
  if (options.encoding)
    this.setDefaultEncoding(options.encoding);
  if (typeof this.fd !== 'number')
    this.open();
  // dispose on finish.
  this.once('finish', this.close);
fs.FileWriteStream = fs.WriteStream; // support the legacy name
WriteStream.prototype.open = function() {
  fs.open(this.path, this.flags, this.mode, function(er, fd) {
    if (er) {
      this.destroy();
      this.emit('error', er);
      return;
    }
    this.fd = fd;
    this.emit('open', fd);
  }.bind(this));
WriteStream.prototype._write = function(data, encoding, cb) {
  if (!(data instanceof Buffer))
    return this.emit('error', new Error('Invalid data'));
  if (typeof this.fd !== 'number')
    return this.once('open', function() {
      this._write(data, encoding, cb);
    });
  var self = this;
  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
    if (er) {
      self.destroy();
      return cb(er);
    }
    self.bytesWritten += bytes;
    cb();
  });
  if (this.pos !== undefined)
    this.pos += data.length;
function writev(fd, chunks, position, callback) {
  function wrapper(err, written) {
    // Retain a reference to chunks so that they can't be GC'ed too soon.
    callback(err, written || 0, chunks);
  const req = new FSReqWrap();
  req.oncomplete = wrapper;
  binding.writeBuffers(fd, chunks, position, req);
WriteStream.prototype._writev = function(data, cb) {
  if (typeof this.fd !== 'number')
    return this.once('open', function() {
      this._writev(data, cb);
    });
  const self = this;
  const len = data.length;
  const chunks = new Array(len);
  var size = 0;
  for (var i = 0; i < len; i++) {
    var chunk = data[i].chunk;
    chunks[i] = chunk;
    size += chunk.length;
  writev(this.fd, chunks, this.pos, function(er, bytes) {
    if (er) {
      self.destroy();
      return cb(er);
    }
    self.bytesWritten += bytes;
    cb();
  });
  if (this.pos !== undefined)
    this.pos += size;
WriteStream.prototype.destroy = ReadStream.prototype.destroy;
WriteStream.prototype.close = ReadStream.prototype.close;
// There is no shutdown() for files.
WriteStream.prototype.destroySoon = WriteStream.prototype.end;
// SyncWriteStream is internal. DO NOT USE.
// Temporary hack for process.stdout and process.stderr when piped to files.
function SyncWriteStream(fd, options) {
  Stream.call(this);
  options = options || {};
  this.fd = fd;
  this.writable = true;
  this.readable = false;
  this.autoClose = options.autoClose === undefined ? true : options.autoClose;
util.inherits(SyncWriteStream, Stream);
// Export
Object.defineProperty(fs, 'SyncWriteStream', {
  configurable: true,
  writable: true,
  value: SyncWriteStream
SyncWriteStream.prototype.write = function(data, arg1, arg2) {
  var encoding, cb;
  // parse arguments
  if (arg1) {
    if (typeof arg1 === 'string') {
      encoding = arg1;
      cb = arg2;
    } else if (typeof arg1 === 'function') {
      cb = arg1;
    } else {
      throw new Error('bad arg');
    }
  assertEncoding(encoding);
  // Change strings to buffers. SLOW
  if (typeof data === 'string') {
    data = new Buffer(data, encoding);
  fs.writeSync(this.fd, data, 0, data.length);
  if (cb) {
    process.nextTick(cb);
  return true;
SyncWriteStream.prototype.end = function(data, arg1, arg2) {
  if (data) {
    this.write(data, arg1, arg2);
  this.destroy();
SyncWriteStream.prototype.destroy = function() {
  if (this.autoClose)
    fs.closeSync(this.fd);
  this.fd = null;
  this.emit('close');
  return true;
SyncWriteStream.prototype.destroySoon = SyncWriteStream.prototype.destroy;
'use strict';
const util = require('util');
const internalUtil = require('internal/util');
const EventEmitter = require('events');
exports.IncomingMessage = require('_http_incoming').IncomingMessage;
const common = require('_http_common');
exports.METHODS = common.methods.slice().sort();
exports.OutgoingMessage = require('_http_outgoing').OutgoingMessage;
const server = require('_http_server');
exports.ServerResponse = server.ServerResponse;
exports.STATUS_CODES = server.STATUS_CODES;
const agent = require('_http_agent');
const Agent = exports.Agent = agent.Agent;
exports.globalAgent = agent.globalAgent;
const client = require('_http_client');
const ClientRequest = exports.ClientRequest = client.ClientRequest;
exports.request = function(options, cb) {
  return new ClientRequest(options, cb);
exports.get = function(options, cb) {
  var req = exports.request(options, cb);
  req.end();
  return req;
exports._connectionListener = server._connectionListener;
const Server = exports.Server = server.Server;
exports.createServer = function(requestListener) {
  return new Server(requestListener);
// Legacy Interface
function Client(port, host) {
  if (!(this instanceof Client)) return new Client(port, host);
  EventEmitter.call(this);
  host = host || 'localhost';
  port = port || 80;
  this.host = host;
  this.port = port;
  this.agent = new Agent({ host: host, port: port, maxSockets: 1 });
util.inherits(Client, EventEmitter);
Client.prototype.request = function(method, path, headers) {
  var self = this;
  var options = {};
  options.host = self.host;
  options.port = self.port;
  if (method[0] === '/') {
    headers = path;
    path = method;
    method = 'GET';
  options.method = method;
  options.path = path;
  options.headers = headers;
  options.agent = self.agent;
  var c = new ClientRequest(options);
  c.on('error', function(e) {
    self.emit('error', e);
  });
  // The old Client interface emitted 'end' on socket end.
  // This doesn't map to how we want things to operate in the future
  // but it will get removed when we remove this legacy interface.
  c.on('socket', function(s) {
    s.on('end', function() {
      if (self._decoder) {
        var ret = self._decoder.end();
        if (ret)
          self.emit('data', ret);
      }
      self.emit('end');
    });
  });
  return c;
exports.Client = internalUtil.deprecate(Client, 'http.Client is deprecated.');
exports.createClient = internalUtil.deprecate(function(port, host) {
  return new Client(port, host);
}, 'http.createClient is deprecated. Use http.request instead.');
'use strict';
const net = require('net');
const util = require('util');
const EventEmitter = require('events');
const debug = util.debuglog('http');
// New Agent code.
// The largest departure from the previous implementation is that
// an Agent instance holds connections for a variable number of host:ports.
// Surprisingly, this is still API compatible as far as third parties are
// concerned. The only code that really notices the difference is the
// request object.
// Another departure is that all code related to HTTP parsing is in
// ClientRequest.onSocket(). The Agent is now *strictly*
// concerned with managing a connection pool.
function Agent(options) {
  if (!(this instanceof Agent))
    return new Agent(options);
  EventEmitter.call(this);
  var self = this;
  self.defaultPort = 80;
  self.protocol = 'http:';
  self.options = util._extend({}, options);
  // don't confuse net and make it think that we're connecting to a pipe
  self.options.path = null;
  self.requests = {};
  self.sockets = {};
  self.freeSockets = {};
  self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;
  self.keepAlive = self.options.keepAlive || false;
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;
  self.maxFreeSockets = self.options.maxFreeSockets || 256;
  self.on('free', function(socket, options) {
    var name = self.getName(options);
    debug('agent.on(free)', name);
    if (!socket.destroyed &&
        self.requests[name] && self.requests[name].length) {
      self.requests[name].shift().onSocket(socket);
      if (self.requests[name].length === 0) {
        // don't leak
        delete self.requests[name];
      }
    } else {
      // If there are no pending requests, then put it in
      // the freeSockets pool, but only if we're allowed to do so.
      var req = socket._httpMessage;
      if (req &&
          req.shouldKeepAlive &&
          !socket.destroyed &&
          self.keepAlive) {
        var freeSockets = self.freeSockets[name];
        var freeLen = freeSockets ? freeSockets.length : 0;
        var count = freeLen;
        if (self.sockets[name])
          count += self.sockets[name].length;
        if (count > self.maxSockets || freeLen >= self.maxFreeSockets) {
          socket.destroy();
        } else {
          freeSockets = freeSockets || [];
          self.freeSockets[name] = freeSockets;
          socket.setKeepAlive(true, self.keepAliveMsecs);
          socket.unref();
          socket._httpMessage = null;
          self.removeSocket(socket, options);
          freeSockets.push(socket);
        }
      } else {
        socket.destroy();
      }
    }
  });
util.inherits(Agent, EventEmitter);
exports.Agent = Agent;
Agent.defaultMaxSockets = Infinity;
Agent.prototype.createConnection = net.createConnection;
// Get the key for a given set of request options
Agent.prototype.getName = function(options) {
  var name = options.host || 'localhost';
  name += ':';
  if (options.port)
    name += options.port;
  name += ':';
  if (options.localAddress)
    name += options.localAddress;
  // Pacify parallel/test-http-agent-getname by only appending
  // the ':' when options.family is set.
  if (options.family === 4 || options.family === 6)
    name += ':' + options.family;
  return name;
Agent.prototype.addRequest = function(req, options) {
  // Legacy API: addRequest(req, host, port, path)
  if (typeof options === 'string') {
    options = {
      host: options,
      port: arguments[2],
      path: arguments[3]
    };
  options = util._extend({}, options);
  options = util._extend(options, this.options);
  var name = this.getName(options);
  if (!this.sockets[name]) {
    this.sockets[name] = [];
  var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;
  var sockLen = freeLen + this.sockets[name].length;
  if (freeLen) {
    // we have a free socket, so use that.
    var socket = this.freeSockets[name].shift();
    debug('have free socket');
    // don't leak
    if (!this.freeSockets[name].length)
      delete this.freeSockets[name];
    socket.ref();
    req.onSocket(socket);
    this.sockets[name].push(socket);
  } else if (sockLen < this.maxSockets) {
    debug('call onSocket', sockLen, freeLen);
    // If we are under maxSockets create a new one.
    req.onSocket(this.createSocket(req, options));
  } else {
    debug('wait for socket');
    // We are over limit so we'll add it to the queue.
    if (!this.requests[name]) {
      this.requests[name] = [];
    }
    this.requests[name].push(req);
Agent.prototype.createSocket = function(req, options) {
  var self = this;
  options = util._extend({}, options);
  options = util._extend(options, self.options);
  if (!options.servername) {
    options.servername = options.host;
    if (req) {
      var hostHeader = req.getHeader('host');
      if (hostHeader) {
        options.servername = hostHeader.replace(/:.*$/, '');
      }
    }
  var name = self.getName(options);
  options._agentKey = name;
  debug('createConnection', name, options);
  options.encoding = null;
  var s = self.createConnection(options);
  if (!self.sockets[name]) {
    self.sockets[name] = [];
  this.sockets[name].push(s);
  debug('sockets', name, this.sockets[name].length);
  function onFree() {
    self.emit('free', s, options);
  s.on('free', onFree);
  function onClose(err) {
    debug('CLIENT socket onClose');
    // This is the only place where sockets get removed from the Agent.
    // If you want to remove a socket from the pool, just close it.
    // All socket errors end in a close event anyway.
    self.removeSocket(s, options);
  s.on('close', onClose);
  function onRemove() {
    // We need this function for cases like HTTP 'upgrade'
    // (defined by WebSockets) where we need to remove a socket from the
    // pool because it'll be locked up indefinitely
    debug('CLIENT socket onRemove');
    self.removeSocket(s, options);
    s.removeListener('close', onClose);
    s.removeListener('free', onFree);
    s.removeListener('agentRemove', onRemove);
  s.on('agentRemove', onRemove);
  return s;
Agent.prototype.removeSocket = function(s, options) {
  var name = this.getName(options);
  debug('removeSocket', name, 'destroyed:', s.destroyed);
  var sets = [this.sockets];
  // If the socket was destroyed, remove it from the free buffers too.
  if (s.destroyed)
    sets.push(this.freeSockets);
  for (var sk = 0; sk < sets.length; sk++) {
    var sockets = sets[sk];
    if (sockets[name]) {
      var index = sockets[name].indexOf(s);
      if (index !== -1) {
        sockets[name].splice(index, 1);
        // Don't leak
        if (sockets[name].length === 0)
          delete sockets[name];
      }
    }
  if (this.requests[name] && this.requests[name].length) {
    debug('removeSocket, have a request, make a socket');
    var req = this.requests[name][0];
    // If we have pending requests and a socket gets closed make a new one
    this.createSocket(req, options).emit('free');
Agent.prototype.destroy = function() {
  var sets = [this.freeSockets, this.sockets];
  for (var s = 0; s < sets.length; s++) {
    var set = sets[s];
    var keys = Object.keys(set);
    for (var v = 0; v < keys.length; v++) {
      var setName = set[keys[v]];
      for (var n = 0; n < setName.length; n++) {
        setName[n].destroy();
      }
    }
exports.globalAgent = new Agent();
'use strict';
const util = require('util');
const net = require('net');
const url = require('url');
const HTTPParser = process.binding('http_parser').HTTPParser;
const assert = require('assert').ok;
const common = require('_http_common');
const httpSocketSetup = common.httpSocketSetup;
const parsers = common.parsers;
const freeParser = common.freeParser;
const debug = common.debug;
const OutgoingMessage = require('_http_outgoing').OutgoingMessage;
const Agent = require('_http_agent');
const Buffer = require('buffer').Buffer;
function ClientRequest(options, cb) {
  var self = this;
  OutgoingMessage.call(self);
  if (typeof options === 'string') {
    options = url.parse(options);
  } else {
    options = util._extend({}, options);
  var agent = options.agent;
  var defaultAgent = options._defaultAgent || Agent.globalAgent;
  if (agent === false) {
    agent = new defaultAgent.constructor();
  } else if ((agent === null || agent === undefined) &&
             !options.createConnection) {
    agent = defaultAgent;
  self.agent = agent;
  var protocol = options.protocol || defaultAgent.protocol;
  var expectedProtocol = defaultAgent.protocol;
  if (self.agent && self.agent.protocol)
    expectedProtocol = self.agent.protocol;
  if (options.path && / /.test(options.path)) {
    // The actual regex is more like /[^A-Za-z0-9\-._~!$&'()*+,;=/:@]/
    // with an additional rule for ignoring percentage-escaped characters
    // but that's a) hard to capture in a regular expression that performs
    // well, and b) possibly too restrictive for real-world usage. That's
    // why it only scans for spaces because those are guaranteed to create
    // an invalid request.
    throw new TypeError('Request path contains unescaped characters.');
  } else if (protocol !== expectedProtocol) {
    throw new Error('Protocol "' + protocol + '" not supported. ' +
                    'Expected "' + expectedProtocol + '".');
  const defaultPort = options.defaultPort ||
                      self.agent && self.agent.defaultPort;
  var port = options.port = options.port || defaultPort || 80;
  var host = options.host = options.hostname || options.host || 'localhost';
  if (options.setHost === undefined) {
    var setHost = true;
  self.socketPath = options.socketPath;
  var method = self.method = (options.method || 'GET').toUpperCase();
  self.path = options.path || '/';
  if (cb) {
    self.once('response', cb);
  if (!Array.isArray(options.headers)) {
    if (options.headers) {
      var keys = Object.keys(options.headers);
      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        self.setHeader(key, options.headers[key]);
      }
    }
    if (host && !this.getHeader('host') && setHost) {
      var hostHeader = host;
      var posColon = -1;
      // For the Host header, ensure that IPv6 addresses are enclosed
      // in square brackets, as defined by URI formatting
      // https://tools.ietf.org/html/rfc3986#section-3.2.2
      if (-1 !== (posColon = hostHeader.indexOf(':')) &&
          -1 !== (posColon = hostHeader.indexOf(':', posColon)) &&
          '[' !== hostHeader[0]) {
        hostHeader = `[${hostHeader}]`;
      }
      if (port && +port !== defaultPort) {
        hostHeader += ':' + port;
      }
      this.setHeader('Host', hostHeader);
    }
  if (options.auth && !this.getHeader('Authorization')) {
    //basic auth
    this.setHeader('Authorization', 'Basic ' +
                   new Buffer(options.auth).toString('base64'));
  if (method === 'GET' ||
      method === 'HEAD' ||
      method === 'DELETE' ||
      method === 'OPTIONS' ||
      method === 'CONNECT') {
    self.useChunkedEncodingByDefault = false;
  } else {
    self.useChunkedEncodingByDefault = true;
  if (Array.isArray(options.headers)) {
    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\r\n',
                      options.headers);
  } else if (self.getHeader('expect')) {
    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\r\n',
                      self._renderHeaders());
  if (self.socketPath) {
    self._last = true;
    self.shouldKeepAlive = false;
    self.onSocket(self.agent.createConnection({ path: self.socketPath }));
  } else if (self.agent) {
    // If there is an agent we should default to Connection:keep-alive,
    // but only if the Agent will actually reuse the connection!
    // If it's not a keepAlive agent, and the maxSockets==Infinity, then
    // there's never a case where this socket will actually be reused
    if (!self.agent.keepAlive && !Number.isFinite(self.agent.maxSockets)) {
      self._last = true;
      self.shouldKeepAlive = false;
    } else {
      self._last = false;
      self.shouldKeepAlive = true;
    }
    self.agent.addRequest(self, options);
  } else {
    // No agent, default to Connection:close.
    self._last = true;
    self.shouldKeepAlive = false;
    if (options.createConnection) {
      self.onSocket(options.createConnection(options));
    } else {
      debug('CLIENT use net.createConnection', options);
      self.onSocket(net.createConnection(options));
    }
  self._deferToConnect(null, null, function() {
    self._flush();
    self = null;
  });
  this._ended = false;
util.inherits(ClientRequest, OutgoingMessage);
exports.ClientRequest = ClientRequest;
ClientRequest.prototype.aborted = undefined;
ClientRequest.prototype._finish = function() {
  DTRACE_HTTP_CLIENT_REQUEST(this, this.connection);
  OutgoingMessage.prototype._finish.call(this);
ClientRequest.prototype._implicitHeader = function() {
  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\r\n',
                    this._renderHeaders());
ClientRequest.prototype.abort = function() {
  if (this.aborted === undefined) {
    process.nextTick(emitAbortNT, this);
  // Mark as aborting so we can avoid sending queued request data
  // This is used as a truthy flag elsewhere. The use of Date.now is for
  // debugging purposes only.
  this.aborted = Date.now();
  // If we're aborting, we don't care about any more response data.
  if (this.res)
    this.res._dump();
  else
    this.once('response', function(res) {
      res._dump();
    });
  // In the event that we don't have a socket, we will pop out of
  // the request queue through handling in onSocket.
  if (this.socket) {
    // in-progress
    this.socket.destroy();
function emitAbortNT(self) {
  self.emit('abort');
function createHangUpError() {
  var error = new Error('socket hang up');
  error.code = 'ECONNRESET';
  return error;
function socketCloseListener() {
  var socket = this;
  var req = socket._httpMessage;
  debug('HTTP socket close');
  // Pull through final chunk, if anything is buffered.
  // the ondata function will handle it properly, and this
  // is a no-op if no final chunk remains.
  socket.read();
  // NOTE: It's important to get parser here, because it could be freed by
  // the `socketOnData`.
  var parser = socket.parser;
  req.emit('close');
  if (req.res && req.res.readable) {
    // Socket closed before we emitted 'end' below.
    req.res.emit('aborted');
    var res = req.res;
    res.on('end', function() {
      res.emit('close');
    });
    res.push(null);
  } else if (!req.res && !req.socket._hadError) {
    // This socket error fired before we started to
    // receive a response. The error needs to
    // fire on the request.
    req.emit('error', createHangUpError());
    req.socket._hadError = true;
  // Too bad.  That output wasn't getting written.
  // This is pretty terrible that it doesn't raise an error.
  // Fixed better in v0.10
  if (req.output)
    req.output.length = 0;
  if (req.outputEncodings)
    req.outputEncodings.length = 0;
  if (parser) {
    parser.finish();
    freeParser(parser, req, socket);
function socketErrorListener(err) {
  var socket = this;
  var req = socket._httpMessage;
  debug('SOCKET ERROR:', err.message, err.stack);
  if (req) {
    req.emit('error', err);
    // For Safety. Some additional errors might fire later on
    // and we need to make sure we don't double-fire the error event.
    req.socket._hadError = true;
  // Handle any pending data
  socket.read();
  var parser = socket.parser;
  if (parser) {
    parser.finish();
    freeParser(parser, req, socket);
  // Ensure that no further data will come out of the socket
  socket.removeListener('data', socketOnData);
  socket.removeListener('end', socketOnEnd);
  socket.destroy();
function freeSocketErrorListener(err) {
  var socket = this;
  debug('SOCKET ERROR on FREE socket:', err.message, err.stack);
  socket.destroy();
  socket.emit('agentRemove');
function socketOnEnd() {
  var socket = this;
  var req = this._httpMessage;
  var parser = this.parser;
  if (!req.res && !req.socket._hadError) {
    // If we don't have a response then we know that the socket
    // ended prematurely and we need to emit an error on the request.
    req.emit('error', createHangUpError());
    req.socket._hadError = true;
  if (parser) {
    parser.finish();
    freeParser(parser, req, socket);
  socket.destroy();
function socketOnData(d) {
  var socket = this;
  var req = this._httpMessage;
  var parser = this.parser;
  assert(parser && parser.socket === socket);
  var ret = parser.execute(d);
  if (ret instanceof Error) {
    debug('parse error');
    freeParser(parser, req, socket);
    socket.destroy();
    req.emit('error', ret);
    req.socket._hadError = true;
  } else if (parser.incoming && parser.incoming.upgrade) {
    // Upgrade or CONNECT
    var bytesParsed = ret;
    var res = parser.incoming;
    req.res = res;
    socket.removeListener('data', socketOnData);
    socket.removeListener('end', socketOnEnd);
    parser.finish();
    var bodyHead = d.slice(bytesParsed, d.length);
    var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';
    if (req.listenerCount(eventName) > 0) {
      req.upgradeOrConnect = true;
      // detach the socket
      socket.emit('agentRemove');
      socket.removeListener('close', socketCloseListener);
      socket.removeListener('error', socketErrorListener);
      // TODO(isaacs): Need a way to reset a stream to fresh state
      // IE, not flowing, and not explicitly paused.
      socket._readableState.flowing = null;
      req.emit(eventName, res, socket, bodyHead);
      req.emit('close');
    } else {
      // Got Upgrade header or CONNECT method, but have no handler.
      socket.destroy();
    }
    freeParser(parser, req, socket);
  } else if (parser.incoming && parser.incoming.complete &&
             // When the status code is 100 (Continue), the server will
             // send a final response after this client sends a request
             // body. So, we must not free the parser.
             parser.incoming.statusCode !== 100) {
    socket.removeListener('data', socketOnData);
    socket.removeListener('end', socketOnEnd);
    freeParser(parser, req, socket);
// client
function parserOnIncomingClient(res, shouldKeepAlive) {
  var socket = this.socket;
  var req = socket._httpMessage;
  // propagate "domain" setting...
  if (req.domain && !res.domain) {
    debug('setting "res.domain"');
    res.domain = req.domain;
  debug('AGENT incoming response!');
  if (req.res) {
    // We already have a response object, this means the server
    // sent a double response.
    socket.destroy();
    return;
  req.res = res;
  // Responses to CONNECT request is handled as Upgrade.
  if (req.method === 'CONNECT') {
    res.upgrade = true;
    return 2; // skip body, and the rest
  // Responses to HEAD requests are crazy.
  // HEAD responses aren't allowed to have an entity-body
  // but *can* have a content-length which actually corresponds
  // to the content-length of the entity-body had the request
  // been a GET.
  var isHeadResponse = req.method === 'HEAD';
  debug('AGENT isHeadResponse', isHeadResponse);
  if (res.statusCode === 100) {
    // restart the parser, as this is a continue message.
    delete req.res; // Clear res so that we don't hit double-responses.
    req.emit('continue');
    return true;
  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {
    // Server MUST respond with Connection:keep-alive for us to enable it.
    // If we've been upgraded (via WebSockets) we also shouldn't try to
    // keep the connection open.
    req.shouldKeepAlive = false;
  DTRACE_HTTP_CLIENT_RESPONSE(socket, req);
  req.res = res;
  res.req = req;
  // add our listener first, so that we guarantee socket cleanup
  res.on('end', responseOnEnd);
  req.on('prefinish', requestOnPrefinish);
  var handled = req.emit('response', res);
  // If the user did not listen for the 'response' event, then they
  // can't possibly read the data, so we ._dump() it into the void
  // so that the socket doesn't hang there in a paused state.
  if (!handled)
    res._dump();
  return isHeadResponse;
// client
function responseKeepAlive(res, req) {
  var socket = req.socket;
  if (!req.shouldKeepAlive) {
    if (socket.writable) {
      debug('AGENT socket.destroySoon()');
      socket.destroySoon();
    }
    assert(!socket.writable);
  } else {
    debug('AGENT socket keep-alive');
    if (req.timeoutCb) {
      socket.setTimeout(0, req.timeoutCb);
      req.timeoutCb = null;
    }
    socket.removeListener('close', socketCloseListener);
    socket.removeListener('error', socketErrorListener);
    socket.once('error', freeSocketErrorListener);
    // Mark this socket as available, AFTER user-added end
    // handlers have a chance to run.
    process.nextTick(emitFreeNT, socket);
function responseOnEnd() {
  const res = this;
  const req = this.req;
  req._ended = true;
  if (!req.shouldKeepAlive || req.finished)
    responseKeepAlive(res, req);
function requestOnPrefinish() {
  const req = this;
  const res = this.res;
  if (!req.shouldKeepAlive)
    return;
  if (req._ended)
    responseKeepAlive(res, req);
function emitFreeNT(socket) {
  socket.emit('free');
function tickOnSocket(req, socket) {
  var parser = parsers.alloc();
  req.socket = socket;
  req.connection = socket;
  parser.reinitialize(HTTPParser.RESPONSE);
  parser.socket = socket;
  parser.incoming = null;
  parser.outgoing = req;
  req.parser = parser;
  socket.parser = parser;
  socket._httpMessage = req;
  // Setup "drain" propagation.
  httpSocketSetup(socket);
  // Propagate headers limit from request object to parser
  if (typeof req.maxHeadersCount === 'number') {
    parser.maxHeaderPairs = req.maxHeadersCount << 1;
  } else {
    // Set default value because parser may be reused from FreeList
    parser.maxHeaderPairs = 2000;
  parser.onIncoming = parserOnIncomingClient;
  socket.removeListener('error', freeSocketErrorListener);
  socket.on('error', socketErrorListener);
  socket.on('data', socketOnData);
  socket.on('end', socketOnEnd);
  socket.on('close', socketCloseListener);
  req.emit('socket', socket);
ClientRequest.prototype.onSocket = function(socket) {
  process.nextTick(onSocketNT, this, socket);
function onSocketNT(req, socket) {
  if (req.aborted) {
    // If we were aborted while waiting for a socket, skip the whole thing.
    socket.emit('free');
  } else {
    tickOnSocket(req, socket);
ClientRequest.prototype._deferToConnect = function(method, arguments_, cb) {
  // This function is for calls that need to happen once the socket is
  // connected and writable. It's an important promisy thing for all the socket
  // calls that happen either now (when a socket is assigned) or
  // in the future (when a socket gets assigned out of the pool and is
  // eventually writable).
  var self = this;
  function callSocketMethod() {
    if (method)
      self.socket[method].apply(self.socket, arguments_);
    if (typeof cb === 'function')
      cb();
  var onSocket = function() {
    if (self.socket.writable) {
      callSocketMethod();
    } else {
      self.socket.once('connect', callSocketMethod);
    }
  };
  if (!self.socket) {
    self.once('socket', onSocket);
  } else {
    onSocket();
ClientRequest.prototype.setTimeout = function(msecs, callback) {
  if (callback) this.once('timeout', callback);
  var self = this;
  function emitTimeout() {
    self.emit('timeout');
  if (this.socket && this.socket.writable) {
    if (this.timeoutCb)
      this.socket.setTimeout(0, this.timeoutCb);
    this.timeoutCb = emitTimeout;
    this.socket.setTimeout(msecs, emitTimeout);
    return this;
  // Set timeoutCb so that it'll get cleaned up on request end
  this.timeoutCb = emitTimeout;
  if (this.socket) {
    var sock = this.socket;
    this.socket.once('connect', function() {
      sock.setTimeout(msecs, emitTimeout);
    });
    return this;
  this.once('socket', function(sock) {
    sock.setTimeout(msecs, emitTimeout);
  });
  return this;
ClientRequest.prototype.setNoDelay = function() {
  const argsLen = arguments.length;
  const args = new Array(argsLen);
  for (var i = 0; i < argsLen; i++)
    args[i] = arguments[i];
  this._deferToConnect('setNoDelay', args);
ClientRequest.prototype.setSocketKeepAlive = function() {
  const argsLen = arguments.length;
  const args = new Array(argsLen);
  for (var i = 0; i < argsLen; i++)
    args[i] = arguments[i];
  this._deferToConnect('setKeepAlive', args);
ClientRequest.prototype.clearTimeout = function(cb) {
  this.setTimeout(0, cb);
'use strict';
const FreeList = require('internal/freelist').FreeList;
const HTTPParser = process.binding('http_parser').HTTPParser;
const incoming = require('_http_incoming');
const IncomingMessage = incoming.IncomingMessage;
const readStart = incoming.readStart;
const readStop = incoming.readStop;
const debug = require('util').debuglog('http');
exports.debug = debug;
exports.CRLF = '\r\n';
exports.chunkExpression = /chunk/i;
exports.continueExpression = /100-continue/i;
exports.methods = HTTPParser.methods;
const kOnHeaders = HTTPParser.kOnHeaders | 0;
const kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;
const kOnBody = HTTPParser.kOnBody | 0;
const kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;
const kOnExecute = HTTPParser.kOnExecute | 0;
// Only called in the slow case where slow means
// that the request headers were either fragmented
// across multiple TCP packets or too large to be
// processed in a single run. This method is also
// called to process trailing HTTP headers.
function parserOnHeaders(headers, url) {
  // Once we exceeded headers limit - stop collecting them
  if (this.maxHeaderPairs <= 0 ||
      this._headers.length < this.maxHeaderPairs) {
    this._headers = this._headers.concat(headers);
  this._url += url;
// `headers` and `url` are set only if .onHeaders() has not been called for
// this request.
// `url` is not set for response parsers but that's not applicable here since
// all our parsers are request parsers.
function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
                                 url, statusCode, statusMessage, upgrade,
                                 shouldKeepAlive) {
  var parser = this;
  if (!headers) {
    headers = parser._headers;
    parser._headers = [];
  if (!url) {
    url = parser._url;
    parser._url = '';
  parser.incoming = new IncomingMessage(parser.socket);
  parser.incoming.httpVersionMajor = versionMajor;
  parser.incoming.httpVersionMinor = versionMinor;
  parser.incoming.httpVersion = versionMajor + '.' + versionMinor;
  parser.incoming.url = url;
  var n = headers.length;
  // If parser.maxHeaderPairs <= 0 assume that there's no limit.
  if (parser.maxHeaderPairs > 0)
    n = Math.min(n, parser.maxHeaderPairs);
  parser.incoming._addHeaderLines(headers, n);
  if (typeof method === 'number') {
    // server only
    parser.incoming.method = HTTPParser.methods[method];
  } else {
    // client only
    parser.incoming.statusCode = statusCode;
    parser.incoming.statusMessage = statusMessage;
  // The client made non-upgrade request, and server is just advertising
  // supported protocols.
  //
  // See RFC7230 Section 6.7
  //
  // NOTE: RegExp below matches `upgrade` in `Connection: abc, upgrade, def`
  // header.
  if (upgrade &&
      parser.outgoing !== null &&
      (parser.outgoing._headers.upgrade === undefined ||
       !/(^|\W)upgrade(\W|$)/i.test(parser.outgoing._headers.connection))) {
    upgrade = false;
  parser.incoming.upgrade = upgrade;
  var skipBody = 0; // response to HEAD or CONNECT
  if (!upgrade) {
    // For upgraded connections and CONNECT method request, we'll emit this
    // after parser.execute so that we can capture the first part of the new
    // protocol.
    skipBody = parser.onIncoming(parser.incoming, shouldKeepAlive);
  if (typeof skipBody !== 'number')
    return skipBody ? 1 : 0;
  else
    return skipBody;
// XXX This is a mess.
// TODO: http.Parser should be a Writable emits request/response events.
function parserOnBody(b, start, len) {
  var parser = this;
  var stream = parser.incoming;
  // if the stream has already been removed, then drop it.
  if (!stream)
    return;
  var socket = stream.socket;
  // pretend this was the result of a stream._read call.
  if (len > 0 && !stream._dumped) {
    var slice = b.slice(start, start + len);
    var ret = stream.push(slice);
    if (!ret)
      readStop(socket);
function parserOnMessageComplete() {
  var parser = this;
  var stream = parser.incoming;
  if (stream) {
    stream.complete = true;
    // Emit any trailing headers.
    var headers = parser._headers;
    if (headers) {
      parser.incoming._addHeaderLines(headers, headers.length);
      parser._headers = [];
      parser._url = '';
    }
    // For emit end event
    stream.push(null);
  // force to read the next incoming message
  readStart(parser.socket);
var parsers = new FreeList('parsers', 1000, function() {
  var parser = new HTTPParser(HTTPParser.REQUEST);
  parser._headers = [];
  parser._url = '';
  parser._consumed = false;
  parser.socket = null;
  parser.incoming = null;
  parser.outgoing = null;
  // Only called in the slow case where slow means
  // that the request headers were either fragmented
  // across multiple TCP packets or too large to be
  // processed in a single run. This method is also
  // called to process trailing HTTP headers.
  parser[kOnHeaders] = parserOnHeaders;
  parser[kOnHeadersComplete] = parserOnHeadersComplete;
  parser[kOnBody] = parserOnBody;
  parser[kOnMessageComplete] = parserOnMessageComplete;
  parser[kOnExecute] = null;
  return parser;
exports.parsers = parsers;
// Free the parser and also break any links that it
// might have to any other things.
// TODO: All parser data should be attached to a
// single object, so that it can be easily cleaned
// up by doing `parser.data = {}`, which should
// be done in FreeList.free.  `parsers.free(parser)`
// should be all that is needed.
function freeParser(parser, req, socket) {
  if (parser) {
    parser._headers = [];
    parser.onIncoming = null;
    if (parser._consumed)
      parser.unconsume();
    parser._consumed = false;
    if (parser.socket)
      parser.socket.parser = null;
    parser.socket = null;
    parser.incoming = null;
    parser.outgoing = null;
    parser[kOnExecute] = null;
    if (parsers.free(parser) === false)
      parser.close();
    parser = null;
  if (req) {
    req.parser = null;
  if (socket) {
    socket.parser = null;
exports.freeParser = freeParser;
function ondrain() {
  if (this._httpMessage) this._httpMessage.emit('drain');
function httpSocketSetup(socket) {
  socket.removeListener('drain', ondrain);
  socket.on('drain', ondrain);
exports.httpSocketSetup = httpSocketSetup;
 * Verifies that the given val is a valid HTTP token
 * per the rules defined in RFC 7230
 * See https://tools.ietf.org/html/rfc7230#section-3.2.6
 * This implementation of checkIsHttpToken() loops over the string instead of
 * using a regular expression since the former is up to 180% faster with v8 4.9
 * depending on the string length (the shorter the string, the larger the
 * performance difference)
 **/
function checkIsHttpToken(val) {
  if (typeof val !== 'string' || val.length === 0)
    return false;
  for (var i = 0, len = val.length; i < len; i++) {
    var ch = val.charCodeAt(i);
    if (ch >= 65 && ch <= 90) // A-Z
      continue;
    if (ch >= 97 && ch <= 122) // a-z
      continue;
    // ^ => 94
    // _ => 95
    // ` => 96
    // | => 124
    // ~ => 126
    if (ch === 94 || ch === 95 || ch === 96 || ch === 124 || ch === 126)
      continue;
    if (ch >= 48 && ch <= 57) // 0-9
      continue;
    // ! => 33
    // # => 35
    // $ => 36
    // % => 37
    // & => 38
    // ' => 39
    // * => 42
    // + => 43
    // - => 45
    // . => 46
    if (ch >= 33 && ch <= 46) {
      if (ch === 34 || ch === 40 || ch === 41 || ch === 44)
        return false;
      continue;
    }
    return false;
  return true;
exports._checkIsHttpToken = checkIsHttpToken;
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 **/
function checkInvalidHeaderChar(val) {
  val = '' + val;
  for (var i = 0; i < val.length; i++) {
    const ch = val.charCodeAt(i);
    if (ch === 9) continue;
    if (ch <= 31 || ch > 255 || ch === 127) return true;
  return false;
exports._checkInvalidHeaderChar = checkInvalidHeaderChar;
'use strict';
const util = require('util');
const Stream = require('stream');
function readStart(socket) {
  if (socket && !socket._paused && socket.readable)
    socket.resume();
exports.readStart = readStart;
function readStop(socket) {
  if (socket)
    socket.pause();
exports.readStop = readStop;
/* Abstract base class for ServerRequest and ClientResponse. */
function IncomingMessage(socket) {
  Stream.Readable.call(this);
  // Set this to `true` so that stream.Readable won't attempt to read more
  // data on `IncomingMessage#push` (see `maybeReadMore` in
  // `_stream_readable.js`). This is important for proper tracking of
  // `IncomingMessage#_consuming` which is used to dump requests that users
  // haven't attempted to read.
  this._readableState.readingMore = true;
  this.socket = socket;
  this.connection = socket;
  this.httpVersionMajor = null;
  this.httpVersionMinor = null;
  this.httpVersion = null;
  this.complete = false;
  this.headers = {};
  this.rawHeaders = [];
  this.trailers = {};
  this.rawTrailers = [];
  this.readable = true;
  this.upgrade = null;
  // request (server) only
  this.url = '';
  this.method = null;
  // response (client) only
  this.statusCode = null;
  this.statusMessage = null;
  this.client = socket;
  // flag for backwards compatibility grossness.
  this._consuming = false;
  // flag for when we decide that this message cannot possibly be
  // read by the user, so there's no point continuing to handle it.
  this._dumped = false;
util.inherits(IncomingMessage, Stream.Readable);
exports.IncomingMessage = IncomingMessage;
IncomingMessage.prototype.setTimeout = function(msecs, callback) {
  if (callback)
    this.on('timeout', callback);
  this.socket.setTimeout(msecs);
  return this;
IncomingMessage.prototype.read = function(n) {
  if (!this._consuming)
    this._readableState.readingMore = false;
  this._consuming = true;
  this.read = Stream.Readable.prototype.read;
  return this.read(n);
IncomingMessage.prototype._read = function(n) {
  // We actually do almost nothing here, because the parserOnBody
  // function fills up our internal buffer directly.  However, we
  // do need to unpause the underlying socket so that it flows.
  if (this.socket.readable)
    readStart(this.socket);
// It's possible that the socket will be destroyed, and removed from
// any messages, before ever calling this.  In that case, just skip
// it, since something else is destroying this connection anyway.
IncomingMessage.prototype.destroy = function(error) {
  if (this.socket)
    this.socket.destroy(error);
IncomingMessage.prototype._addHeaderLines = function(headers, n) {
  if (headers && headers.length) {
    var raw, dest;
    if (this.complete) {
      raw = this.rawTrailers;
      dest = this.trailers;
    } else {
      raw = this.rawHeaders;
      dest = this.headers;
    }
    for (var i = 0; i < n; i += 2) {
      var k = headers[i];
      var v = headers[i + 1];
      raw.push(k);
      raw.push(v);
      this._addHeaderLine(k, v, dest);
    }
// Add the given (field, value) pair to the message
// Per RFC2616, section 4.2 it is acceptable to join multiple instances of the
// same header with a ', ' if the header in question supports specification of
// multiple values this way. If not, we declare the first instance the winner
// and drop the second. Extended header fields (those beginning with 'x-') are
// always joined.
IncomingMessage.prototype._addHeaderLine = function(field, value, dest) {
  field = field.toLowerCase();
  switch (field) {
    // Array headers:
    case 'set-cookie':
      if (dest[field] !== undefined) {
        dest[field].push(value);
      } else {
        dest[field] = [value];
      }
      break;
    /* eslint-disable max-len */
    // list is taken from:
    // https://mxr.mozilla.org/mozilla/source/netwerk/protocol/http/src/nsHttpHeaderArray.cpp
    /* eslint-enable max-len */
    case 'content-type':
    case 'content-length':
    case 'user-agent':
    case 'referer':
    case 'host':
    case 'authorization':
    case 'proxy-authorization':
    case 'if-modified-since':
    case 'if-unmodified-since':
    case 'from':
    case 'location':
    case 'max-forwards':
      // drop duplicates
      if (dest[field] === undefined)
        dest[field] = value;
      break;
    default:
      // make comma-separated list
      if (typeof dest[field] === 'string') {
        dest[field] += ', ' + value;
      } else {
        dest[field] = value;
      }
// Call this instead of resume() if we want to just
// dump all the data to /dev/null
IncomingMessage.prototype._dump = function() {
  if (!this._dumped) {
    this._dumped = true;
    this.resume();
'use strict';
const assert = require('assert').ok;
const Stream = require('stream');
const timers = require('timers');
const util = require('util');
const internalUtil = require('internal/util');
const Buffer = require('buffer').Buffer;
const common = require('_http_common');
const CRLF = common.CRLF;
const chunkExpression = common.chunkExpression;
const debug = common.debug;
const connectionExpression = /^Connection$/i;
const transferEncodingExpression = /^Transfer-Encoding$/i;
const closeExpression = /close/i;
const contentLengthExpression = /^Content-Length$/i;
const dateExpression = /^Date$/i;
const expectExpression = /^Expect$/i;
const trailerExpression = /^Trailer$/i;
const lenientHttpHeaders = !!process.REVERT_CVE_2016_2216;
const automaticHeaders = {
  connection: true,
  'content-length': true,
  'transfer-encoding': true,
  date: true
var dateCache;
function utcDate() {
  if (!dateCache) {
    var d = new Date();
    dateCache = d.toUTCString();
    timers.enroll(utcDate, 1000 - d.getMilliseconds());
    timers._unrefActive(utcDate);
  return dateCache;
utcDate._onTimeout = function() {
  dateCache = undefined;
function OutgoingMessage() {
  Stream.call(this);
  // Queue that holds all currently pending data, until the response will be
  // assigned to the socket (until it will its turn in the HTTP pipeline).
  this.output = [];
  this.outputEncodings = [];
  this.outputCallbacks = [];
  // `outputSize` is an approximate measure of how much data is queued on this
  // response. `_onPendingData` will be invoked to update similar global
  // per-connection counter. That counter will be used to pause/unpause the
  // TCP socket and HTTP Parser and thus handle the backpressure.
  this.outputSize = 0;
  this.writable = true;
  this._last = false;
  this.chunkedEncoding = false;
  this.shouldKeepAlive = true;
  this.useChunkedEncodingByDefault = true;
  this.sendDate = false;
  this._removedHeader = {};
  this._contentLength = null;
  this._hasBody = true;
  this._trailer = '';
  this.finished = false;
  this._headerSent = false;
  this.socket = null;
  this.connection = null;
  this._header = null;
  this._headers = null;
  this._headerNames = {};
  this._onPendingData = null;
util.inherits(OutgoingMessage, Stream);
exports.OutgoingMessage = OutgoingMessage;
OutgoingMessage.prototype.setTimeout = function(msecs, callback) {
  if (callback)
    this.on('timeout', callback);
  if (!this.socket) {
    this.once('socket', function(socket) {
      socket.setTimeout(msecs);
    });
  } else {
    this.socket.setTimeout(msecs);
  return this;
// It's possible that the socket will be destroyed, and removed from
// any messages, before ever calling this.  In that case, just skip
// it, since something else is destroying this connection anyway.
OutgoingMessage.prototype.destroy = function(error) {
  if (this.socket)
    this.socket.destroy(error);
  else
    this.once('socket', function(socket) {
      socket.destroy(error);
    });
// This abstract either writing directly to the socket or buffering it.
OutgoingMessage.prototype._send = function(data, encoding, callback) {
  // This is a shameful hack to get the headers and first body chunk onto
  // the same packet. Future versions of Node are going to take care of
  // this at a lower level and in a more general way.
  if (!this._headerSent) {
    if (typeof data === 'string' &&
        encoding !== 'hex' &&
        encoding !== 'base64') {
      data = this._header + data;
    } else {
      this.output.unshift(this._header);
      this.outputEncodings.unshift('binary');
      this.outputCallbacks.unshift(null);
      this.outputSize += this._header.length;
      if (typeof this._onPendingData === 'function')
        this._onPendingData(this._header.length);
    }
    this._headerSent = true;
  return this._writeRaw(data, encoding, callback);
OutgoingMessage.prototype._writeRaw = function(data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = null;
  var connection = this.connection;
  if (connection &&
      connection._httpMessage === this &&
      connection.writable &&
      !connection.destroyed) {
    // There might be pending data in the this.output buffer.
    var outputLength = this.output.length;
    if (outputLength > 0) {
      this._flushOutput(connection);
    } else if (data.length === 0) {
      if (typeof callback === 'function')
        process.nextTick(callback);
      return true;
    }
    // Directly write to socket.
    return connection.write(data, encoding, callback);
  } else if (connection && connection.destroyed) {
    // The socket was destroyed.  If we're still trying to write to it,
    // then we haven't gotten the 'close' event yet.
    return false;
  } else {
    // buffer, as long as we're not destroyed.
    return this._buffer(data, encoding, callback);
OutgoingMessage.prototype._buffer = function(data, encoding, callback) {
  this.output.push(data);
  this.outputEncodings.push(encoding);
  this.outputCallbacks.push(callback);
  this.outputSize += data.length;
  if (typeof this._onPendingData === 'function')
    this._onPendingData(data.length);
  return false;
OutgoingMessage.prototype._storeHeader = function(firstLine, headers) {
  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\r\n'
  // in the case of response it is: 'HTTP/1.1 200 OK\r\n'
  var state = {
    sentConnectionHeader: false,
    sentContentLengthHeader: false,
    sentTransferEncodingHeader: false,
    sentDateHeader: false,
    sentExpect: false,
    sentTrailer: false,
    messageHeader: firstLine
  };
  if (headers) {
    var keys = Object.keys(headers);
    var isArray = Array.isArray(headers);
    var field, value;
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      if (isArray) {
        field = headers[key][0];
        value = headers[key][1];
      } else {
        field = key;
        value = headers[key];
      }
      if (Array.isArray(value)) {
        for (var j = 0; j < value.length; j++) {
          storeHeader(this, state, field, value[j]);
        }
      } else {
        storeHeader(this, state, field, value);
      }
    }
  // Date header
  if (this.sendDate === true && state.sentDateHeader === false) {
    state.messageHeader += 'Date: ' + utcDate() + CRLF;
  // Force the connection to close when the response is a 204 No Content or
  // a 304 Not Modified and the user has set a "Transfer-Encoding: chunked"
  // header.
  //
  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but
  // node.js used to send out a zero chunk anyway to accommodate clients
  // that don't have special handling for those responses.
  //
  // It was pointed out that this might confuse reverse proxies to the point
  // of creating security liabilities, so suppress the zero chunk and force
  // the connection to close.
  var statusCode = this.statusCode;
  if ((statusCode === 204 || statusCode === 304) &&
      this.chunkedEncoding === true) {
    debug(statusCode + ' response should not use chunked encoding,' +
          ' closing connection.');
    this.chunkedEncoding = false;
    this.shouldKeepAlive = false;
  // keep-alive logic
  if (this._removedHeader.connection) {
    this._last = true;
    this.shouldKeepAlive = false;
  } else if (state.sentConnectionHeader === false) {
    var shouldSendKeepAlive = this.shouldKeepAlive &&
        (state.sentContentLengthHeader ||
         this.useChunkedEncodingByDefault ||
         this.agent);
    if (shouldSendKeepAlive) {
      state.messageHeader += 'Connection: keep-alive\r\n';
    } else {
      this._last = true;
      state.messageHeader += 'Connection: close\r\n';
    }
  if (state.sentContentLengthHeader === false &&
      state.sentTransferEncodingHeader === false) {
    if (!this._hasBody) {
      // Make sure we don't end the 0\r\n\r\n at the end of the message.
      this.chunkedEncoding = false;
    } else if (!this.useChunkedEncodingByDefault) {
      this._last = true;
    } else {
      if (!state.sentTrailer &&
          !this._removedHeader['content-length'] &&
          typeof this._contentLength === 'number') {
        state.messageHeader += 'Content-Length: ' + this._contentLength +
                               '\r\n';
      } else if (!this._removedHeader['transfer-encoding']) {
        state.messageHeader += 'Transfer-Encoding: chunked\r\n';
        this.chunkedEncoding = true;
      } else {
        // We should only be able to get here if both Content-Length and
        // Transfer-Encoding are removed by the user.
        // See: test/parallel/test-http-remove-header-stays-removed.js
        debug('Both Content-Length and Transfer-Encoding are removed');
      }
    }
  this._header = state.messageHeader + CRLF;
  this._headerSent = false;
  // wait until the first body chunk, or close(), is sent to flush,
  // UNLESS we're sending Expect: 100-continue.
  if (state.sentExpect) this._send('');
function storeHeader(self, state, field, value) {
  if (!lenientHttpHeaders) {
    if (!common._checkIsHttpToken(field)) {
      throw new TypeError(
        'Header name must be a valid HTTP Token ["' + field + '"]');
    }
    if (common._checkInvalidHeaderChar(value) === true) {
      throw new TypeError('The header content contains invalid characters');
    }
  state.messageHeader += field + ': ' + escapeHeaderValue(value) + CRLF;
  if (connectionExpression.test(field)) {
    state.sentConnectionHeader = true;
    if (closeExpression.test(value)) {
      self._last = true;
    } else {
      self.shouldKeepAlive = true;
    }
  } else if (transferEncodingExpression.test(field)) {
    state.sentTransferEncodingHeader = true;
    if (chunkExpression.test(value)) self.chunkedEncoding = true;
  } else if (contentLengthExpression.test(field)) {
    state.sentContentLengthHeader = true;
  } else if (dateExpression.test(field)) {
    state.sentDateHeader = true;
  } else if (expectExpression.test(field)) {
    state.sentExpect = true;
  } else if (trailerExpression.test(field)) {
    state.sentTrailer = true;
OutgoingMessage.prototype.setHeader = function(name, value) {
  if (typeof name !== 'string')
    throw new TypeError('`name` should be a string in setHeader(name, value).');
  if (value === undefined)
    throw new Error('`value` required in setHeader("' + name + '", value).');
  if (this._header)
    throw new Error('Can\'t set headers after they are sent.');
  if (!lenientHttpHeaders) {
    if (!common._checkIsHttpToken(name)) {
      throw new TypeError(
        'Trailer name must be a valid HTTP Token ["' + name + '"]');
    }
    if (common._checkInvalidHeaderChar(value) === true) {
      throw new TypeError('The header content contains invalid characters');
    }
  if (this._headers === null)
    this._headers = {};
  var key = name.toLowerCase();
  this._headers[key] = value;
  this._headerNames[key] = name;
  if (automaticHeaders[key])
    this._removedHeader[key] = false;
OutgoingMessage.prototype.getHeader = function(name) {
  if (arguments.length < 1) {
    throw new Error('`name` is required for getHeader(name).');
  if (!this._headers) return;
  var key = name.toLowerCase();
  return this._headers[key];
OutgoingMessage.prototype.removeHeader = function(name) {
  if (arguments.length < 1) {
    throw new Error('`name` is required for removeHeader(name).');
  if (this._header) {
    throw new Error('Can\'t remove headers after they are sent.');
  var key = name.toLowerCase();
  if (key === 'date')
    this.sendDate = false;
  else if (automaticHeaders[key])
    this._removedHeader[key] = true;
  if (this._headers) {
    delete this._headers[key];
    delete this._headerNames[key];
OutgoingMessage.prototype._renderHeaders = function() {
  if (this._header) {
    throw new Error('Can\'t render headers after they are sent to the client.');
  var headersMap = this._headers;
  if (!headersMap) return {};
  var headers = {};
  var keys = Object.keys(headersMap);
  var headerNames = this._headerNames;
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    headers[headerNames[key]] = headersMap[key];
  return headers;
Object.defineProperty(OutgoingMessage.prototype, 'headersSent', {
  configurable: true,
  enumerable: true,
  get: function() { return !!this._header; }
OutgoingMessage.prototype.write = function(chunk, encoding, callback) {
  if (this.finished) {
    var err = new Error('write after end');
    process.nextTick(writeAfterEndNT, this, err, callback);
    return true;
  if (!this._header) {
    this._implicitHeader();
  if (!this._hasBody) {
    debug('This type of response MUST NOT have a body. ' +
          'Ignoring write() calls.');
    return true;
  if (typeof chunk !== 'string' && !(chunk instanceof Buffer)) {
    throw new TypeError('first argument must be a string or Buffer');
  // If we get an empty string or buffer, then just do nothing, and
  // signal the user to keep writing.
  if (chunk.length === 0) return true;
  var len, ret;
  if (this.chunkedEncoding) {
    if (typeof chunk === 'string' &&
        encoding !== 'hex' &&
        encoding !== 'base64' &&
        encoding !== 'binary') {
      len = Buffer.byteLength(chunk, encoding);
      chunk = len.toString(16) + CRLF + chunk + CRLF;
      ret = this._send(chunk, encoding, callback);
    } else {
      // buffer, or a non-toString-friendly encoding
      if (typeof chunk === 'string')
        len = Buffer.byteLength(chunk, encoding);
      else
        len = chunk.length;
      if (this.connection && !this.connection.corked) {
        this.connection.cork();
        process.nextTick(connectionCorkNT, this.connection);
      }
      this._send(len.toString(16), 'binary', null);
      this._send(crlf_buf, null, null);
      this._send(chunk, encoding, null);
      ret = this._send(crlf_buf, null, callback);
    }
  } else {
    ret = this._send(chunk, encoding, callback);
  debug('write ret = ' + ret);
  return ret;
function writeAfterEndNT(self, err, callback) {
  self.emit('error', err);
  if (callback) callback(err);
function connectionCorkNT(conn) {
  conn.uncork();
function escapeHeaderValue(value) {
  if (!lenientHttpHeaders) return value;
  // Protect against response splitting. The regex test is there to
  // minimize the performance impact in the common case.
  return /[\r\n]/.test(value) ? value.replace(/[\r\n]+[ \t]*/g, '') : value;
OutgoingMessage.prototype.addTrailers = function(headers) {
  this._trailer = '';
  var keys = Object.keys(headers);
  var isArray = Array.isArray(headers);
  var field, value;
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    if (isArray) {
      field = headers[key][0];
      value = headers[key][1];
    } else {
      field = key;
      value = headers[key];
    }
    if (!lenientHttpHeaders) {
      if (!common._checkIsHttpToken(field)) {
        throw new TypeError(
          'Trailer name must be a valid HTTP Token ["' + field + '"]');
      }
      if (common._checkInvalidHeaderChar(value) === true) {
        throw new TypeError('The header content contains invalid characters');
      }
    }
    this._trailer += field + ': ' + escapeHeaderValue(value) + CRLF;
const crlf_buf = new Buffer('\r\n');
OutgoingMessage.prototype.end = function(data, encoding, callback) {
  if (typeof data === 'function') {
    callback = data;
    data = null;
  } else if (typeof encoding === 'function') {
    callback = encoding;
    encoding = null;
  if (data && typeof data !== 'string' && !(data instanceof Buffer)) {
    throw new TypeError('first argument must be a string or Buffer');
  if (this.finished) {
    return false;
  var self = this;
  function finish() {
    self.emit('finish');
  if (typeof callback === 'function')
    this.once('finish', callback);
  if (!this._header) {
    if (data) {
      if (typeof data === 'string')
        this._contentLength = Buffer.byteLength(data, encoding);
      else
        this._contentLength = data.length;
    } else {
      this._contentLength = 0;
    }
    this._implicitHeader();
  if (data && !this._hasBody) {
    debug('This type of response MUST NOT have a body. ' +
          'Ignoring data passed to end().');
    data = null;
  if (this.connection && data)
    this.connection.cork();
  var ret;
  if (data) {
    // Normal body write.
    this.write(data, encoding);
  if (this._hasBody && this.chunkedEncoding) {
    ret = this._send('0\r\n' + this._trailer + '\r\n', 'binary', finish);
  } else {
    // Force a flush, HACK.
    ret = this._send('', 'binary', finish);
  if (this.connection && data)
    this.connection.uncork();
  this.finished = true;
  // There is the first message on the outgoing queue, and we've sent
  // everything to the socket.
  debug('outgoing message end.');
  if (this.output.length === 0 &&
      this.connection &&
      this.connection._httpMessage === this) {
    this._finish();
  return ret;
OutgoingMessage.prototype._finish = function() {
  assert(this.connection);
  this.emit('prefinish');
// This logic is probably a bit confusing. Let me explain a bit:
// In both HTTP servers and clients it is possible to queue up several
// outgoing messages. This is easiest to imagine in the case of a client.
// Take the following situation:
//    req1 = client.request('GET', '/');
//    req2 = client.request('POST', '/');
// When the user does
//   req2.write('hello world\n');
// it's possible that the first request has not been completely flushed to
// the socket yet. Thus the outgoing messages need to be prepared to queue
// up data internally before sending it on further to the socket's queue.
// This function, outgoingFlush(), is called by both the Server and Client
// to attempt to flush any pending messages out to the socket.
OutgoingMessage.prototype._flush = function() {
  var socket = this.socket;
  var ret;
  if (socket && socket.writable) {
    // There might be remaining data in this.output; write it out
    ret = this._flushOutput(socket);
    if (this.finished) {
      // This is a queue to the server or client to bring in the next this.
      this._finish();
    } else if (ret) {
      // This is necessary to prevent https from breaking
      this.emit('drain');
    }
OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {
  var ret;
  var outputLength = this.output.length;
  if (outputLength <= 0)
    return ret;
  var output = this.output;
  var outputEncodings = this.outputEncodings;
  var outputCallbacks = this.outputCallbacks;
  socket.cork();
  for (var i = 0; i < outputLength; i++) {
    ret = socket.write(output[i], outputEncodings[i],
                       outputCallbacks[i]);
  socket.uncork();
  this.output = [];
  this.outputEncodings = [];
  this.outputCallbacks = [];
  if (typeof this._onPendingData === 'function')
    this._onPendingData(-this.outputSize);
  this.outputSize = 0;
  return ret;
OutgoingMessage.prototype.flushHeaders = function() {
  if (!this._header) {
    this._implicitHeader();
  // Force-flush the headers.
  this._send('');
OutgoingMessage.prototype.flush = internalUtil.deprecate(function() {
  this.flushHeaders();
}, 'OutgoingMessage.flush is deprecated. Use flushHeaders instead.');
'use strict';
const util = require('util');
const net = require('net');
const EventEmitter = require('events');
const HTTPParser = process.binding('http_parser').HTTPParser;
const assert = require('assert').ok;
const common = require('_http_common');
const parsers = common.parsers;
const freeParser = common.freeParser;
const debug = common.debug;
const CRLF = common.CRLF;
const continueExpression = common.continueExpression;
const chunkExpression = common.chunkExpression;
const httpSocketSetup = common.httpSocketSetup;
const OutgoingMessage = require('_http_outgoing').OutgoingMessage;
const STATUS_CODES = exports.STATUS_CODES = {
  100: 'Continue',
  101: 'Switching Protocols',
  102: 'Processing',                 // RFC 2518, obsoleted by RFC 4918
  200: 'OK',
  201: 'Created',
  202: 'Accepted',
  203: 'Non-Authoritative Information',
  204: 'No Content',
  205: 'Reset Content',
  206: 'Partial Content',
  207: 'Multi-Status',               // RFC 4918
  208: 'Already Reported',
  226: 'IM Used',
  300: 'Multiple Choices',
  301: 'Moved Permanently',
  302: 'Found',
  303: 'See Other',
  304: 'Not Modified',
  305: 'Use Proxy',
  307: 'Temporary Redirect',
  308: 'Permanent Redirect',         // RFC 7238
  400: 'Bad Request',
  401: 'Unauthorized',
  402: 'Payment Required',
  403: 'Forbidden',
  404: 'Not Found',
  405: 'Method Not Allowed',
  406: 'Not Acceptable',
  407: 'Proxy Authentication Required',
  408: 'Request Timeout',
  409: 'Conflict',
  410: 'Gone',
  411: 'Length Required',
  412: 'Precondition Failed',
  413: 'Payload Too Large',
  414: 'URI Too Long',
  415: 'Unsupported Media Type',
  416: 'Range Not Satisfiable',
  417: 'Expectation Failed',
  418: 'I\'m a teapot',              // RFC 2324
  421: 'Misdirected Request',
  422: 'Unprocessable Entity',       // RFC 4918
  423: 'Locked',                     // RFC 4918
  424: 'Failed Dependency',          // RFC 4918
  425: 'Unordered Collection',       // RFC 4918
  426: 'Upgrade Required',           // RFC 2817
  428: 'Precondition Required',      // RFC 6585
  429: 'Too Many Requests',          // RFC 6585
  431: 'Request Header Fields Too Large', // RFC 6585
  500: 'Internal Server Error',
  501: 'Not Implemented',
  502: 'Bad Gateway',
  503: 'Service Unavailable',
  504: 'Gateway Timeout',
  505: 'HTTP Version Not Supported',
  506: 'Variant Also Negotiates',    // RFC 2295
  507: 'Insufficient Storage',       // RFC 4918
  508: 'Loop Detected',
  509: 'Bandwidth Limit Exceeded',
  510: 'Not Extended',               // RFC 2774
  511: 'Network Authentication Required' // RFC 6585
const kOnExecute = HTTPParser.kOnExecute | 0;
function ServerResponse(req) {
  OutgoingMessage.call(this);
  if (req.method === 'HEAD') this._hasBody = false;
  this.sendDate = true;
  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {
    this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te);
    this.shouldKeepAlive = false;
util.inherits(ServerResponse, OutgoingMessage);
ServerResponse.prototype._finish = function() {
  DTRACE_HTTP_SERVER_RESPONSE(this.connection);
  OutgoingMessage.prototype._finish.call(this);
exports.ServerResponse = ServerResponse;
ServerResponse.prototype.statusCode = 200;
ServerResponse.prototype.statusMessage = undefined;
function onServerResponseClose() {
  // EventEmitter.emit makes a copy of the 'close' listeners array before
  // calling the listeners. detachSocket() unregisters onServerResponseClose
  // but if detachSocket() is called, directly or indirectly, by a 'close'
  // listener, onServerResponseClose is still in that copy of the listeners
  // array. That is, in the example below, b still gets called even though
  // it's been removed by a:
  //
  //   var EventEmitter = require('events');
  //   var obj = new EventEmitter();
  //   obj.on('event', a);
  //   obj.on('event', b);
  //   function a() { obj.removeListener('event', b) }
  //   function b() { throw "BAM!" }
  //   obj.emit('event');  // throws
  //
  // Ergo, we need to deal with stale 'close' events and handle the case
  // where the ServerResponse object has already been deconstructed.
  // Fortunately, that requires only a single if check. :-)
  if (this._httpMessage) this._httpMessage.emit('close');
ServerResponse.prototype.assignSocket = function(socket) {
  assert(!socket._httpMessage);
  socket._httpMessage = this;
  socket.on('close', onServerResponseClose);
  this.socket = socket;
  this.connection = socket;
  this.emit('socket', socket);
  this._flush();
ServerResponse.prototype.detachSocket = function(socket) {
  assert(socket._httpMessage === this);
  socket.removeListener('close', onServerResponseClose);
  socket._httpMessage = null;
  this.socket = this.connection = null;
ServerResponse.prototype.writeContinue = function(cb) {
  this._writeRaw('HTTP/1.1 100 Continue' + CRLF + CRLF, 'ascii', cb);
  this._sent100 = true;
ServerResponse.prototype._implicitHeader = function() {
  this.writeHead(this.statusCode);
ServerResponse.prototype.writeHead = function(statusCode, reason, obj) {
  var headers;
  if (typeof reason === 'string') {
    // writeHead(statusCode, reasonPhrase[, headers])
    this.statusMessage = reason;
  } else {
    // writeHead(statusCode[, headers])
    this.statusMessage =
        this.statusMessage || STATUS_CODES[statusCode] || 'unknown';
    obj = reason;
  this.statusCode = statusCode;
  if (this._headers) {
    // Slow-case: when progressive API and header fields are passed.
    if (obj) {
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (k) this.setHeader(k, obj[k]);
      }
    }
    // only progressive api is used
    headers = this._renderHeaders();
  } else {
    // only writeHead() called
    headers = obj;
  statusCode |= 0;
  if (statusCode < 100 || statusCode > 999)
    throw new RangeError(`Invalid status code: ${statusCode}`);
  var statusLine = 'HTTP/1.1 ' + statusCode.toString() + ' ' +
                   this.statusMessage + CRLF;
  if (statusCode === 204 || statusCode === 304 ||
      (100 <= statusCode && statusCode <= 199)) {
    // RFC 2616, 10.2.5:
    // The 204 response MUST NOT include a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.3.5:
    // The 304 response MUST NOT contain a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.1 Informational 1xx:
    // This class of status code indicates a provisional response,
    // consisting only of the Status-Line and optional headers, and is
    // terminated by an empty line.
    this._hasBody = false;
  // don't keep alive connections where the client expects 100 Continue
  // but we sent a final status; they may put extra bytes on the wire.
  if (this._expect_continue && !this._sent100) {
    this.shouldKeepAlive = false;
  this._storeHeader(statusLine, headers);
ServerResponse.prototype.writeHeader = function() {
  this.writeHead.apply(this, arguments);
function Server(requestListener) {
  if (!(this instanceof Server)) return new Server(requestListener);
  net.Server.call(this, { allowHalfOpen: true });
  if (requestListener) {
    this.addListener('request', requestListener);
  /* eslint-disable max-len */
  // Similar option to this. Too lazy to write my own docs.
  // http://www.squid-cache.org/Doc/config/half_closed_clients/
  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F
  /* eslint-enable max-len */
  this.httpAllowHalfOpen = false;
  this.addListener('connection', connectionListener);
  this.addListener('clientError', function(err, conn) {
    conn.destroy(err);
  });
  this.timeout = 2 * 60 * 1000;
  this._pendingResponseData = 0;
util.inherits(Server, net.Server);
Server.prototype.setTimeout = function(msecs, callback) {
  this.timeout = msecs;
  if (callback)
    this.on('timeout', callback);
  return this;
exports.Server = Server;
function connectionListener(socket) {
  var self = this;
  var outgoing = [];
  var incoming = [];
  var outgoingData = 0;
  function updateOutgoingData(delta) {
    // `outgoingData` is an approximate amount of bytes queued through all
    // inactive responses. If more data than the high watermark is queued - we
    // need to pause TCP socket/HTTP parser, and wait until the data will be
    // sent to the client.
    outgoingData += delta;
    if (socket._paused && outgoingData < socket._writableState.highWaterMark)
      return socketOnDrain();
  function abortIncoming() {
    while (incoming.length) {
      var req = incoming.shift();
      req.emit('aborted');
      req.emit('close');
    }
    // abort socket._httpMessage ?
  function serverSocketCloseListener() {
    debug('server socket close');
    // mark this parser as reusable
    if (this.parser) {
      freeParser(this.parser, null, this);
    }
    abortIncoming();
  debug('SERVER new http connection');
  httpSocketSetup(socket);
  // If the user has added a listener to the server,
  // request, or response, then it's their responsibility.
  // otherwise, destroy on timeout by default
  if (self.timeout)
    socket.setTimeout(self.timeout);
  socket.on('timeout', function() {
    var req = socket.parser && socket.parser.incoming;
    var reqTimeout = req && !req.complete && req.emit('timeout', socket);
    var res = socket._httpMessage;
    var resTimeout = res && res.emit('timeout', socket);
    var serverTimeout = self.emit('timeout', socket);
    if (!reqTimeout && !resTimeout && !serverTimeout)
      socket.destroy();
  });
  var parser = parsers.alloc();
  parser.reinitialize(HTTPParser.REQUEST);
  parser.socket = socket;
  socket.parser = parser;
  parser.incoming = null;
  // Propagate headers limit from server instance to parser
  if (typeof this.maxHeadersCount === 'number') {
    parser.maxHeaderPairs = this.maxHeadersCount << 1;
  } else {
    // Set default value because parser may be reused from FreeList
    parser.maxHeaderPairs = 2000;
  socket.addListener('error', socketOnError);
  socket.addListener('close', serverSocketCloseListener);
  parser.onIncoming = parserOnIncoming;
  socket.on('end', socketOnEnd);
  socket.on('data', socketOnData);
  // We are consuming socket, so it won't get any actual data
  socket.on('resume', onSocketResume);
  socket.on('pause', onSocketPause);
  socket.on('drain', socketOnDrain);
  // Override on to unconsume on `data`, `readable` listeners
  socket.on = socketOnWrap;
  var external = socket._handle._externalStream;
  if (external) {
    parser._consumed = true;
    parser.consume(external);
  external = null;
  parser[kOnExecute] = onParserExecute;
  // TODO(isaacs): Move all these functions out of here
  function socketOnError(e) {
    self.emit('clientError', e, this);
  function socketOnData(d) {
    assert(!socket._paused);
    debug('SERVER socketOnData %d', d.length);
    var ret = parser.execute(d);
    onParserExecuteCommon(ret, d);
  function onParserExecute(ret, d) {
    socket._unrefTimer();
    debug('SERVER socketOnParserExecute %d', ret);
    onParserExecuteCommon(ret, undefined);
  function onParserExecuteCommon(ret, d) {
    if (ret instanceof Error) {
      debug('parse error');
      socket.destroy(ret);
    } else if (parser.incoming && parser.incoming.upgrade) {
      // Upgrade or CONNECT
      var bytesParsed = ret;
      var req = parser.incoming;
      debug('SERVER upgrade or connect', req.method);
      if (!d)
        d = parser.getCurrentBuffer();
      socket.removeListener('data', socketOnData);
      socket.removeListener('end', socketOnEnd);
      socket.removeListener('close', serverSocketCloseListener);
      unconsume(parser, socket);
      parser.finish();
      freeParser(parser, req, null);
      parser = null;
      var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';
      if (EventEmitter.listenerCount(self, eventName) > 0) {
        debug('SERVER have listener for %s', eventName);
        var bodyHead = d.slice(bytesParsed, d.length);
        // TODO(isaacs): Need a way to reset a stream to fresh state
        // IE, not flowing, and not explicitly paused.
        socket._readableState.flowing = null;
        self.emit(eventName, req, socket, bodyHead);
      } else {
        // Got upgrade header or CONNECT method, but have no handler.
        socket.destroy();
      }
    }
    if (socket._paused && socket.parser) {
      // onIncoming paused the socket, we should pause the parser as well
      debug('pause parser');
      socket.parser.pause();
    }
  function socketOnEnd() {
    var socket = this;
    var ret = parser.finish();
    if (ret instanceof Error) {
      debug('parse error');
      socket.destroy(ret);
      return;
    }
    if (!self.httpAllowHalfOpen) {
      abortIncoming();
      if (socket.writable) socket.end();
    } else if (outgoing.length) {
      outgoing[outgoing.length - 1]._last = true;
    } else if (socket._httpMessage) {
      socket._httpMessage._last = true;
    } else {
      if (socket.writable) socket.end();
    }
  // The following callback is issued after the headers have been read on a
  // new message. In this callback we setup the response object and pass it
  // to the user.
  socket._paused = false;
  function socketOnDrain() {
    var needPause = outgoingData > socket._writableState.highWaterMark;
    // If we previously paused, then start reading again.
    if (socket._paused && !needPause) {
      socket._paused = false;
      if (socket.parser)
        socket.parser.resume();
      socket.resume();
    }
  function parserOnIncoming(req, shouldKeepAlive) {
    incoming.push(req);
    // If the writable end isn't consuming, then stop reading
    // so that we don't become overwhelmed by a flood of
    // pipelined requests that may never be resolved.
    if (!socket._paused) {
      var needPause = socket._writableState.needDrain ||
          outgoingData >= socket._writableState.highWaterMark;
      if (needPause) {
        socket._paused = true;
        // We also need to pause the parser, but don't do that until after
        // the call to execute, because we may still be processing the last
        // chunk.
        socket.pause();
      }
    }
    var res = new ServerResponse(req);
    res._onPendingData = updateOutgoingData;
    res.shouldKeepAlive = shouldKeepAlive;
    DTRACE_HTTP_SERVER_REQUEST(req, socket);
    ;
    ;
    if (socket._httpMessage) {
      // There are already pending outgoing res, append.
      outgoing.push(res);
    } else {
      res.assignSocket(socket);
    }
    // When we're finished writing the response, check if this is the last
    // response, if so destroy the socket.
    res.on('finish', resOnFinish);
    function resOnFinish() {
      // Usually the first incoming element should be our request.  it may
      // be that in the case abortIncoming() was called that the incoming
      // array will be empty.
      assert(incoming.length === 0 || incoming[0] === req);
      incoming.shift();
      // if the user never called req.read(), and didn't pipe() or
      // .resume() or .on('data'), then we call req._dump() so that the
      // bytes will be pulled off the wire.
      if (!req._consuming && !req._readableState.resumeScheduled)
        req._dump();
      res.detachSocket(socket);
      if (res._last) {
        socket.destroySoon();
      } else {
        // start sending the next message
        var m = outgoing.shift();
        if (m) {
          m.assignSocket(socket);
        }
      }
    }
    if (req.headers.expect !== undefined &&
        (req.httpVersionMajor == 1 && req.httpVersionMinor == 1) &&
        continueExpression.test(req.headers['expect'])) {
      res._expect_continue = true;
      if (EventEmitter.listenerCount(self, 'checkContinue') > 0) {
        self.emit('checkContinue', req, res);
      } else {
        res.writeContinue();
        self.emit('request', req, res);
      }
    } else {
      self.emit('request', req, res);
    }
    return false; // Not a HEAD response. (Not even a response!)
exports._connectionListener = connectionListener;
function onSocketResume() {
  // It may seem that the socket is resumed, but this is an enemy's trick to
  // deceive us! `resume` is emitted asynchronously, and may be called from
  // `incoming.readStart()`. Stop the socket again here, just to preserve the
  // state.
  //
  // We don't care about stream semantics for the consumed socket anyway.
  if (this._paused) {
    this.pause();
    return;
  if (this._handle && !this._handle.reading) {
    this._handle.reading = true;
    this._handle.readStart();
function onSocketPause() {
  if (this._handle && this._handle.reading) {
    this._handle.reading = false;
    this._handle.readStop();
function unconsume(parser, socket) {
  if (socket._handle) {
    if (parser._consumed)
      parser.unconsume(socket._handle._externalStream);
    parser._consumed = false;
    socket.removeListener('pause', onSocketPause);
    socket.removeListener('resume', onSocketResume);
function socketOnWrap(ev, fn) {
  var res = net.Socket.prototype.on.call(this, ev, fn);
  if (!this.parser) {
    this.on = net.Socket.prototype.on;
    return res;
  if (ev === 'data' || ev === 'readable')
    unconsume(this.parser, this);
  return res;
'use strict';
const tls = require('tls');
const url = require('url');
const http = require('http');
const util = require('util');
const inherits = util.inherits;
const debug = util.debuglog('https');
function Server(opts, requestListener) {
  if (!(this instanceof Server)) return new Server(opts, requestListener);
  if (process.features.tls_npn && !opts.NPNProtocols) {
    opts.NPNProtocols = ['http/1.1', 'http/1.0'];
  tls.Server.call(this, opts, http._connectionListener);
  this.httpAllowHalfOpen = false;
  if (requestListener) {
    this.addListener('request', requestListener);
  this.addListener('clientError', function(err, conn) {
    conn.destroy();
  });
  this.timeout = 2 * 60 * 1000;
inherits(Server, tls.Server);
exports.Server = Server;
Server.prototype.setTimeout = http.Server.prototype.setTimeout;
exports.createServer = function(opts, requestListener) {
  return new Server(opts, requestListener);
// HTTPS agents.
function createConnection(port, host, options) {
  if (port !== null && typeof port === 'object') {
    options = port;
  } else if (host !== null && typeof host === 'object') {
    options = host;
  } else if (options === null || typeof options !== 'object') {
    options = {};
  if (typeof port === 'number') {
    options.port = port;
  if (typeof host === 'string') {
    options.host = host;
  debug('createConnection', options);
  if (options._agentKey) {
    const session = this._getSession(options._agentKey);
    if (session) {
      debug('reuse session for %j', options._agentKey);
      options = util._extend({
        session: session
      }, options);
    }
  const socket = tls.connect(options, () => {
    if (!options._agentKey)
      return;
    this._cacheSession(options._agentKey, socket.getSession());
  });
  // Evict session on error
  socket.once('close', (err) => {
    if (err)
      this._evictSession(options._agentKey);
  });
  return socket;
function Agent(options) {
  http.Agent.call(this, options);
  this.defaultPort = 443;
  this.protocol = 'https:';
  this.maxCachedSessions = this.options.maxCachedSessions;
  if (this.maxCachedSessions === undefined)
    this.maxCachedSessions = 100;
  this._sessionCache = {
    map: {},
    list: []
  };
inherits(Agent, http.Agent);
Agent.prototype.createConnection = createConnection;
Agent.prototype.getName = function(options) {
  var name = http.Agent.prototype.getName.call(this, options);
  name += ':';
  if (options.ca)
    name += options.ca;
  name += ':';
  if (options.cert)
    name += options.cert;
  name += ':';
  if (options.ciphers)
    name += options.ciphers;
  name += ':';
  if (options.key)
    name += options.key;
  name += ':';
  if (options.pfx)
    name += options.pfx;
  name += ':';
  if (options.rejectUnauthorized !== undefined)
    name += options.rejectUnauthorized;
  name += ':';
  if (options.servername && options.servername !== options.host)
    name += options.servername;
  return name;
Agent.prototype._getSession = function _getSession(key) {
  return this._sessionCache.map[key];
Agent.prototype._cacheSession = function _cacheSession(key, session) {
  // Fast case - update existing entry
  if (this._sessionCache.map[key]) {
    this._sessionCache.map[key] = session;
    return;
  // Put new entry
  if (this._sessionCache.list.length >= this.maxCachedSessions) {
    const oldKey = this._sessionCache.list.shift();
    debug('evicting %j', oldKey);
    delete this._sessionCache.map[oldKey];
  this._sessionCache.list.push(key);
  this._sessionCache.map[key] = session;
Agent.prototype._evictSession = function _evictSession(key) {
  const index = this._sessionCache.list.indexOf(key);
  if (index === -1)
    return;
  this._sessionCache.list.splice(index, 1);
  delete this._sessionCache.map[key];
const globalAgent = new Agent();
exports.globalAgent = globalAgent;
exports.Agent = Agent;
exports.request = function(options, cb) {
  if (typeof options === 'string') {
    options = url.parse(options);
  } else {
    options = util._extend({}, options);
  options._defaultAgent = globalAgent;
  return http.request(options, cb);
exports.get = function(options, cb) {
  var req = exports.request(options, cb);
  req.end();
  return req;
'use strict';
const NativeModule = require('native_module');
const util = require('util');
const internalModule = require('internal/module');
const internalUtil = require('internal/util');
const runInThisContext = require('vm').runInThisContext;
const assert = require('assert').ok;
const fs = require('fs');
const path = require('path');
const internalModuleReadFile = process.binding('fs').internalModuleReadFile;
const internalModuleStat = process.binding('fs').internalModuleStat;
const splitRe = process.platform === 'win32' ? /[\/\\]/ : /\//;
const isIndexRe = /^index\.\w+?$/;
const shebangRe = /^\#\!.*/;
// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.parent = parent;
  if (parent && parent.children) {
    parent.children.push(this);
  this.filename = null;
  this.loaded = false;
  this.children = [];
module.exports = Module;
Module._cache = {};
Module._pathCache = {};
Module._extensions = {};
var modulePaths = [];
Module.globalPaths = [];
Module.wrapper = NativeModule.wrapper;
Module.wrap = NativeModule.wrap;
Module._debug = util.debuglog('module');
// We use this alias for the preprocessor that filters it out
const debug = Module._debug;
// given a module name, and a list of paths to test, returns the first
// matching file in the following precedence.
// require("a.<ext>")
//   -> a.<ext>
// require("a")
//   -> a
//   -> a.<ext>
//   -> a/index.<ext>
// check if the directory is a package.json dir
const packageMainCache = {};
function readPackage(requestPath) {
  if (hasOwnProperty(packageMainCache, requestPath)) {
    return packageMainCache[requestPath];
  var jsonPath = path.resolve(requestPath, 'package.json');
  var json = internalModuleReadFile(path._makeLong(jsonPath));
  if (json === undefined) {
    return false;
  try {
    var pkg = packageMainCache[requestPath] = JSON.parse(json).main;
  } catch (e) {
    e.path = jsonPath;
    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;
    throw e;
  return pkg;
function tryPackage(requestPath, exts) {
  var pkg = readPackage(requestPath);
  if (!pkg) return false;
  var filename = path.resolve(requestPath, pkg);
  return tryFile(filename) || tryExtensions(filename, exts) ||
         tryExtensions(path.resolve(filename, 'index'), exts);
// In order to minimize unnecessary lstat() calls,
// this cache is a list of known-real paths.
// Set to an empty object to reset.
Module._realpathCache = {};
// check if the file exists and is not a directory
function tryFile(requestPath) {
  const rc = internalModuleStat(path._makeLong(requestPath));
  return rc === 0 && toRealPath(requestPath);
function toRealPath(requestPath) {
  return fs.realpathSync(requestPath, Module._realpathCache);
// given a path check a the file exists with any of the set extensions
function tryExtensions(p, exts) {
  for (var i = 0, EL = exts.length; i < EL; i++) {
    var filename = tryFile(p + exts[i]);
    if (filename) {
      return filename;
    }
  return false;
var warned = false;
Module._findPath = function(request, paths) {
  if (path.isAbsolute(request)) {
    paths = [''];
  var cacheKey = JSON.stringify({request: request, paths: paths});
  if (Module._pathCache[cacheKey]) {
    return Module._pathCache[cacheKey];
  const exts = Object.keys(Module._extensions);
  const trailingSlash = request.slice(-1) === '/';
  // For each path
  for (var i = 0, PL = paths.length; i < PL; i++) {
    // Don't search further if path doesn't exist
    if (paths[i] && internalModuleStat(path._makeLong(paths[i])) < 1) continue;
    var basePath = path.resolve(paths[i], request);
    var filename;
    if (!trailingSlash) {
      const rc = internalModuleStat(path._makeLong(basePath));
      if (rc === 0) {  // File.
        filename = toRealPath(basePath);
      } else if (rc === 1) {  // Directory.
        filename = tryPackage(basePath, exts);
      }
      if (!filename) {
        // try it with each of the extensions
        filename = tryExtensions(basePath, exts);
      }
    }
    if (!filename) {
      filename = tryPackage(basePath, exts);
    }
    if (!filename) {
      // try it with each of the extensions at "index"
      filename = tryExtensions(path.resolve(basePath, 'index'), exts);
    }
    if (filename) {
      // Warn once if '.' resolved outside the module dir
      if (request === '.' && i > 0) {
        warned = internalUtil.printDeprecationMessage(
          'warning: require(\'.\') resolved outside the package ' +
          'directory. This functionality is deprecated and will be removed ' +
          'soon.', warned);
      }
      Module._pathCache[cacheKey] = filename;
      return filename;
    }
  return false;
// 'from' is the __dirname of the module.
Module._nodeModulePaths = function(from) {
  // guarantee that 'from' is absolute.
  from = path.resolve(from);
  // note: this approach *only* works when the path is guaranteed
  // to be absolute.  Doing a fully-edge-case-correct path.split
  // that works on both Windows and Posix is non-trivial.
  var paths = [];
  var parts = from.split(splitRe);
  for (var tip = parts.length - 1; tip >= 0; tip--) {
    // don't search in .../node_modules/node_modules
    if (parts[tip] === 'node_modules') continue;
    var dir = parts.slice(0, tip + 1).concat('node_modules').join(path.sep);
    paths.push(dir);
  return paths;
Module._resolveLookupPaths = function(request, parent) {
  if (NativeModule.nonInternalExists(request)) {
    return [request, []];
  var start = request.substring(0, 2);
  if (start !== './' && start !== '..') {
    var paths = modulePaths;
    if (parent) {
      if (!parent.paths) parent.paths = [];
      paths = parent.paths.concat(paths);
    }
    // Maintain backwards compat with certain broken uses of require('.')
    // by putting the module's directory in front of the lookup paths.
    if (request === '.') {
      if (parent && parent.filename) {
        paths.splice(0, 0, path.dirname(parent.filename));
      } else {
        paths.splice(0, 0, path.resolve(request));
      }
    }
    return [request, paths];
  // with --eval, parent.id is not set and parent.filename is null
  if (!parent || !parent.id || !parent.filename) {
    // make require('./path/to/foo') work - normally the path is taken
    // from realpath(__filename) but with eval there is no filename
    var mainPaths = ['.'].concat(modulePaths);
    mainPaths = Module._nodeModulePaths('.').concat(mainPaths);
    return [request, mainPaths];
  // Is the parent an index module?
  // We can assume the parent has a valid extension,
  // as it already has been accepted as a module.
  var isIndex = isIndexRe.test(path.basename(parent.filename));
  var parentIdPath = isIndex ? parent.id : path.dirname(parent.id);
  var id = path.resolve(parentIdPath, request);
  // make sure require('./path') and require('path') get distinct ids, even
  // when called from the toplevel js file
  if (parentIdPath === '.' && id.indexOf('/') === -1) {
    id = './' + id;
  debug('RELATIVE: requested: %s set ID to: %s from %s', request, id,
        parent.id);
  return [id, [path.dirname(parent.filename)]];
// Check the cache for the requested file.
// 1. If a module already exists in the cache: return its exports object.
// 2. If the module is native: call `NativeModule.require()` with the
//    filename and return the result.
// 3. Otherwise, create a new module for the file and save it to the cache.
//    Then have it load  the file contents before returning its exports
//    object.
Module._load = function(request, parent, isMain) {
  if (parent) {
    debug('Module._load REQUEST %s parent: %s', request, parent.id);
  var filename = Module._resolveFilename(request, parent);
  var cachedModule = Module._cache[filename];
  if (cachedModule) {
    return cachedModule.exports;
  if (NativeModule.nonInternalExists(filename)) {
    debug('load native module %s', request);
    return NativeModule.require(filename);
  var module = new Module(filename, parent);
  if (isMain) {
    process.mainModule = module;
    module.id = '.';
  Module._cache[filename] = module;
  var hadException = true;
  try {
    module.load(filename);
    hadException = false;
  } finally {
    if (hadException) {
      delete Module._cache[filename];
    }
  return module.exports;
Module._resolveFilename = function(request, parent) {
  if (NativeModule.nonInternalExists(request)) {
    return request;
  var resolvedModule = Module._resolveLookupPaths(request, parent);
  var id = resolvedModule[0];
  var paths = resolvedModule[1];
  // look up the filename first, since that's the cache key.
  debug('looking for %j in %j', id, paths);
  var filename = Module._findPath(request, paths);
  if (!filename) {
    var err = new Error("Cannot find module '" + request + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  return filename;
// Given a file name, pass it to the proper extension handler.
Module.prototype.load = function(filename) {
  debug('load %j for module %j', filename, this.id);
  assert(!this.loaded);
  this.filename = filename;
  this.paths = Module._nodeModulePaths(path.dirname(filename));
  var extension = path.extname(filename) || '.js';
  if (!Module._extensions[extension]) extension = '.js';
  Module._extensions[extension](this, filename);
  this.loaded = true;
// Loads a module at the given file path. Returns that module's
// `exports` property.
Module.prototype.require = function(path) {
  assert(path, 'missing path');
  assert(typeof path === 'string', 'path must be a string');
  return Module._load(path, this);
// Resolved path to process.argv[1] will be lazily placed here
// (needed for setting breakpoint when called with --debug-brk)
var resolvedArgv;
// Run the file contents in the correct scope or sandbox. Expose
// the correct helper variables (require, module, exports) to
// the file.
// Returns exception, if any.
Module.prototype._compile = function(content, filename) {
  // remove shebang
  content = content.replace(shebangRe, '');
  // create wrapper function
  var wrapper = Module.wrap(content);
  var compiledWrapper = runInThisContext(wrapper,
                                      { filename: filename, lineOffset: 0 });
  if (global.v8debug) {
    if (!resolvedArgv) {
      // we enter the repl if we're not given a filename argument.
      if (process.argv[1]) {
        resolvedArgv = Module._resolveFilename(process.argv[1], null);
      } else {
        resolvedArgv = 'repl';
      }
    }
    // Set breakpoint on module start
    if (filename === resolvedArgv) {
      // Installing this dummy debug event listener tells V8 to start
      // the debugger.  Without it, the setBreakPoint() fails with an
      // 'illegal access' error.
      global.v8debug.Debug.setListener(function() {});
      global.v8debug.Debug.setBreakPoint(compiledWrapper, 0, 0);
    }
  const dirname = path.dirname(filename);
  const require = internalModule.makeRequireFunction.call(this);
  Object.defineProperty(require, 'paths', { get: function() {
    throw new Error('require.paths is removed. Use ' +
                    'node_modules folders, or the NODE_PATH ' +
                    'environment variable instead.');
  }});
  require.registerExtension = function() {
    throw new Error('require.registerExtension() removed. Use ' +
                    'require.extensions instead.');
  };
  const args = [this.exports, require, this, filename, dirname];
  return compiledWrapper.apply(this.exports, args);
// Native extension for .js
Module._extensions['.js'] = function(module, filename) {
  var content = fs.readFileSync(filename, 'utf8');
  module._compile(internalModule.stripBOM(content), filename);
// Native extension for .json
Module._extensions['.json'] = function(module, filename) {
  var content = fs.readFileSync(filename, 'utf8');
  try {
    module.exports = JSON.parse(internalModule.stripBOM(content));
  } catch (err) {
    err.message = filename + ': ' + err.message;
    throw err;
//Native extension for .node
Module._extensions['.node'] = function(module, filename) {
  return process.dlopen(module, path._makeLong(filename));
// bootstrap main module.
Module.runMain = function() {
  // Load the main module--the command line argument.
  Module._load(process.argv[1], null, true);
  // Handle any nextTicks added in the first tick of the program
  process._tickCallback();
Module._initPaths = function() {
  const isWindows = process.platform === 'win32';
  var homeDir;
  if (isWindows) {
    homeDir = process.env.USERPROFILE;
  } else {
    homeDir = process.env.HOME;
  var paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];
  if (homeDir) {
    paths.unshift(path.resolve(homeDir, '.node_libraries'));
    paths.unshift(path.resolve(homeDir, '.node_modules'));
  var nodePath = process.env['NODE_PATH'];
  if (nodePath) {
    paths = nodePath.split(path.delimiter).filter(function(path) {
      return !!path;
    }).concat(paths);
  modulePaths = paths;
  // clone as a read-only copy, for introspection.
  Module.globalPaths = modulePaths.slice(0);
// TODO(bnoordhuis) Unused, remove in the future.
Module.requireRepl = internalUtil.deprecate(function() {
  return NativeModule.require('internal/repl');
}, 'Module.requireRepl is deprecated.');
Module._preloadModules = function(requests) {
  if (!Array.isArray(requests))
    return;
  // Preloaded modules have a dummy parent module which is deemed to exist
  // in the current working directory. This seeds the search path for
  // preloaded modules.
  var parent = new Module('internal/preload', null);
  try {
    parent.paths = Module._nodeModulePaths(process.cwd());
  catch (e) {
    if (e.code !== 'ENOENT') {
      throw e;
    }
  requests.forEach(function(request) {
    parent.require(request);
  });
Module._initPaths();
// backwards compatibility
Module.Module = Module;
'use strict';
const EventEmitter = require('events');
const stream = require('stream');
const timers = require('timers');
const util = require('util');
const internalUtil = require('internal/util');
const internalNet = require('internal/net');
const assert = require('assert');
const cares = process.binding('cares_wrap');
const uv = process.binding('uv');
const Buffer = require('buffer').Buffer;
const TTYWrap = process.binding('tty_wrap');
const TCP = process.binding('tcp_wrap').TCP;
const Pipe = process.binding('pipe_wrap').Pipe;
const TCPConnectWrap = process.binding('tcp_wrap').TCPConnectWrap;
const PipeConnectWrap = process.binding('pipe_wrap').PipeConnectWrap;
const ShutdownWrap = process.binding('stream_wrap').ShutdownWrap;
const WriteWrap = process.binding('stream_wrap').WriteWrap;
var cluster;
const errnoException = util._errnoException;
const exceptionWithHostPort = util._exceptionWithHostPort;
const isLegalPort = internalNet.isLegalPort;
function noop() {}
function createHandle(fd) {
  var type = TTYWrap.guessHandleType(fd);
  if (type === 'PIPE') return new Pipe();
  if (type === 'TCP') return new TCP();
  throw new TypeError('Unsupported fd type: ' + type);
const debug = util.debuglog('net');
function isPipeName(s) {
  return typeof s === 'string' && toNumber(s) === false;
exports.createServer = function(options, connectionListener) {
  return new Server(options, connectionListener);
// Target API:
// var s = net.connect({port: 80, host: 'google.com'}, function() {
//   ...
// });
// There are various forms:
// connect(options, [cb])
// connect(port, [host], [cb])
// connect(path, [cb]);
exports.connect = exports.createConnection = function() {
  const argsLen = arguments.length;
  var args = new Array(argsLen);
  for (var i = 0; i < argsLen; i++)
    args[i] = arguments[i];
  args = normalizeConnectArgs(args);
  debug('createConnection', args);
  var s = new Socket(args[0]);
  return Socket.prototype.connect.apply(s, args);
// Returns an array [options] or [options, cb]
// It is the same as the argument of Socket.prototype.connect().
function normalizeConnectArgs(args) {
  var options = {};
  if (args[0] !== null && typeof args[0] === 'object') {
    // connect(options, [cb])
    options = args[0];
  } else if (isPipeName(args[0])) {
    // connect(path, [cb]);
    options.path = args[0];
  } else {
    // connect(port, [host], [cb])
    options.port = args[0];
    if (typeof args[1] === 'string') {
      options.host = args[1];
    }
  var cb = args[args.length - 1];
  return typeof cb === 'function' ? [options, cb] : [options];
exports._normalizeConnectArgs = normalizeConnectArgs;
// called when creating new Socket, or when re-using a closed Socket
function initSocketHandle(self) {
  self.destroyed = false;
  self._bytesDispatched = 0;
  self._sockname = null;
  // Handle creation may be deferred to bind() or connect() time.
  if (self._handle) {
    self._handle.owner = self;
    self._handle.onread = onread;
    // If handle doesn't support writev - neither do we
    if (!self._handle.writev)
      self._writev = null;
const BYTES_READ = Symbol('bytesRead');
function Socket(options) {
  if (!(this instanceof Socket)) return new Socket(options);
  this._connecting = false;
  this._hadError = false;
  this._handle = null;
  this._parent = null;
  this._host = null;
  if (typeof options === 'number')
    options = { fd: options }; // Legacy interface.
  else if (options === undefined)
    options = {};
  stream.Duplex.call(this, options);
  if (options.handle) {
    this._handle = options.handle; // private
  } else if (options.fd !== undefined) {
    this._handle = createHandle(options.fd);
    this._handle.open(options.fd);
    if ((options.fd == 1 || options.fd == 2) &&
        (this._handle instanceof Pipe) &&
        process.platform === 'win32') {
      // Make stdout and stderr blocking on Windows
      var err = this._handle.setBlocking(true);
      if (err)
        throw errnoException(err, 'setBlocking');
    }
    this.readable = options.readable !== false;
    this.writable = options.writable !== false;
  } else {
    // these will be set once there is a connection
    this.readable = this.writable = false;
  // shut down the socket when we're finished with it.
  this.on('finish', onSocketFinish);
  this.on('_socketEnd', onSocketEnd);
  initSocketHandle(this);
  this._pendingData = null;
  this._pendingEncoding = '';
  // handle strings directly
  this._writableState.decodeStrings = false;
  // default to *not* allowing half open sockets
  this.allowHalfOpen = options && options.allowHalfOpen || false;
  // if we have a handle, then start the flow of data into the
  // buffer.  if not, then this will happen when we connect
  if (this._handle && options.readable !== false) {
    if (options.pauseOnCreate) {
      // stop the handle from reading and pause the stream
      this._handle.reading = false;
      this._handle.readStop();
      this._readableState.flowing = false;
    } else {
      this.read(0);
    }
  // Reserve properties
  this.server = null;
  this._server = null;
  // Used after `.destroy()`
  this[BYTES_READ] = 0;
util.inherits(Socket, stream.Duplex);
Socket.prototype._unrefTimer = function unrefTimer() {
  for (var s = this; s !== null; s = s._parent)
    timers._unrefActive(s);
// the user has called .end(), and all the bytes have been
// sent out to the other side.
// If allowHalfOpen is false, or if the readable side has
// ended already, then destroy.
// If allowHalfOpen is true, then we need to do a shutdown,
// so that only the writable side will be cleaned up.
function onSocketFinish() {
  // If still connecting - defer handling 'finish' until 'connect' will happen
  if (this._connecting) {
    debug('osF: not yet connected');
    return this.once('connect', onSocketFinish);
  debug('onSocketFinish');
  if (!this.readable || this._readableState.ended) {
    debug('oSF: ended, destroy', this._readableState);
    return this.destroy();
  debug('oSF: not ended, call shutdown()');
  // otherwise, just shutdown, or destroy() if not possible
  if (!this._handle || !this._handle.shutdown)
    return this.destroy();
  var req = new ShutdownWrap();
  req.oncomplete = afterShutdown;
  req.handle = this._handle;
  var err = this._handle.shutdown(req);
  if (err)
    return this._destroy(errnoException(err, 'shutdown'));
function afterShutdown(status, handle, req) {
  var self = handle.owner;
  debug('afterShutdown destroyed=%j', self.destroyed,
        self._readableState);
  // callback may come after call to destroy.
  if (self.destroyed)
    return;
  if (self._readableState.ended) {
    debug('readableState ended, destroying');
    self.destroy();
  } else {
    self.once('_socketEnd', self.destroy);
// the EOF has been received, and no more bytes are coming.
// if the writable side has ended already, then clean everything
// up.
function onSocketEnd() {
  // XXX Should not have to do as much crap in this function.
  // ended should already be true, since this is called *after*
  // the EOF errno and onread has eof'ed
  debug('onSocketEnd', this._readableState);
  this._readableState.ended = true;
  if (this._readableState.endEmitted) {
    this.readable = false;
    maybeDestroy(this);
  } else {
    this.once('end', function() {
      this.readable = false;
      maybeDestroy(this);
    });
    this.read(0);
  if (!this.allowHalfOpen) {
    this.write = writeAfterFIN;
    this.destroySoon();
// Provide a better error message when we call end() as a result
// of the other side sending a FIN.  The standard 'write after end'
// is overly vague, and makes it seem like the user's code is to blame.
function writeAfterFIN(chunk, encoding, cb) {
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  var er = new Error('This socket has been ended by the other party');
  er.code = 'EPIPE';
  // TODO: defer error events consistently everywhere, not just the cb
  this.emit('error', er);
  if (typeof cb === 'function') {
    process.nextTick(cb, er);
exports.Socket = Socket;
exports.Stream = Socket; // Legacy naming.
Socket.prototype.read = function(n) {
  if (n === 0)
    return stream.Readable.prototype.read.call(this, n);
  this.read = stream.Readable.prototype.read;
  this._consuming = true;
  return this.read(n);
Socket.prototype.listen = function() {
  debug('socket.listen');
  this.on('connection', arguments[0]);
  listen(this, null, null, null);
Socket.prototype.setTimeout = function(msecs, callback) {
  if (msecs === 0) {
    timers.unenroll(this);
    if (callback) {
      this.removeListener('timeout', callback);
    }
  } else {
    timers.enroll(this, msecs);
    timers._unrefActive(this);
    if (callback) {
      this.once('timeout', callback);
    }
  return this;
Socket.prototype._onTimeout = function() {
  debug('_onTimeout');
  this.emit('timeout');
Socket.prototype.setNoDelay = function(enable) {
  if (!this._handle) {
    this.once('connect',
              enable ? this.setNoDelay : () => this.setNoDelay(enable));
    return this;
  // backwards compatibility: assume true when `enable` is omitted
  if (this._handle.setNoDelay)
    this._handle.setNoDelay(enable === undefined ? true : !!enable);
  return this;
Socket.prototype.setKeepAlive = function(setting, msecs) {
  if (!this._handle) {
    this.once('connect', () => this.setKeepAlive(setting, msecs));
    return this;
  if (this._handle.setKeepAlive)
    this._handle.setKeepAlive(setting, ~~(msecs / 1000));
  return this;
Socket.prototype.address = function() {
  return this._getsockname();
Object.defineProperty(Socket.prototype, 'readyState', {
  get: function() {
    if (this._connecting) {
      return 'opening';
    } else if (this.readable && this.writable) {
      return 'open';
    } else if (this.readable && !this.writable) {
      return 'readOnly';
    } else if (!this.readable && this.writable) {
      return 'writeOnly';
    } else {
      return 'closed';
    }
Object.defineProperty(Socket.prototype, 'bufferSize', {
  get: function() {
    if (this._handle) {
      return this._handle.writeQueueSize + this._writableState.length;
    }
// Just call handle.readStart until we have enough in the buffer
Socket.prototype._read = function(n) {
  debug('_read');
  if (this._connecting || !this._handle) {
    debug('_read wait for connection');
    this.once('connect', () => this._read(n));
  } else if (!this._handle.reading) {
    // not already reading, start the flow
    debug('Socket._read readStart');
    this._handle.reading = true;
    var err = this._handle.readStart();
    if (err)
      this._destroy(errnoException(err, 'read'));
Socket.prototype.end = function(data, encoding) {
  stream.Duplex.prototype.end.call(this, data, encoding);
  this.writable = false;
  DTRACE_NET_STREAM_END(this);
  // just in case we're waiting for an EOF.
  if (this.readable && !this._readableState.endEmitted)
    this.read(0);
  else
    maybeDestroy(this);
// Call whenever we set writable=false or readable=false
function maybeDestroy(socket) {
  if (!socket.readable &&
      !socket.writable &&
      !socket.destroyed &&
      !socket._connecting &&
      !socket._writableState.length) {
    socket.destroy();
Socket.prototype.destroySoon = function() {
  if (this.writable)
    this.end();
  if (this._writableState.finished)
    this.destroy();
  else
    this.once('finish', this.destroy);
Socket.prototype._destroy = function(exception, cb) {
  debug('destroy');
  var self = this;
  function fireErrorCallbacks() {
    if (cb) cb(exception);
    if (exception && !self._writableState.errorEmitted) {
      process.nextTick(emitErrorNT, self, exception);
      self._writableState.errorEmitted = true;
    }
  if (this.destroyed) {
    debug('already destroyed, fire error callbacks');
    fireErrorCallbacks();
    return;
  self._connecting = false;
  this.readable = this.writable = false;
  for (var s = this; s !== null; s = s._parent)
    timers.unenroll(s);
  debug('close');
  if (this._handle) {
    if (this !== process.stderr)
      debug('close handle');
    var isException = exception ? true : false;
    // `bytesRead` should be accessible after `.destroy()`
    this[BYTES_READ] = this._handle.bytesRead;
    this._handle.close(function() {
      debug('emit close');
      self.emit('close', isException);
    });
    this._handle.onread = noop;
    this._handle = null;
    this._sockname = null;
  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case Socket.prototype.destroy()
  // is called within callbacks
  this.destroyed = true;
  fireErrorCallbacks();
  if (this._server) {
    ;
    debug('has server');
    this._server._connections--;
    if (this._server._emitCloseIfDrained) {
      this._server._emitCloseIfDrained();
    }
Socket.prototype.destroy = function(exception) {
  debug('destroy', exception);
  this._destroy(exception);
// This function is called whenever the handle gets a
// buffer, or when there's an error reading.
function onread(nread, buffer) {
  var handle = this;
  var self = handle.owner;
  assert(handle === self._handle, 'handle != self._handle');
  self._unrefTimer();
  debug('onread', nread);
  if (nread > 0) {
    debug('got data');
    // read success.
    // In theory (and in practice) calling readStop right now
    // will prevent this from being called again until _read() gets
    // called again.
    // Optimization: emit the original buffer with end points
    var ret = self.push(buffer);
    if (handle.reading && !ret) {
      handle.reading = false;
      debug('readStop');
      var err = handle.readStop();
      if (err)
        self._destroy(errnoException(err, 'read'));
    }
    return;
  // if we didn't get any bytes, that doesn't necessarily mean EOF.
  // wait for the next one.
  if (nread === 0) {
    debug('not any data, keep waiting');
    return;
  // Error, possibly EOF.
  if (nread !== uv.UV_EOF) {
    return self._destroy(errnoException(nread, 'read'));
  debug('EOF');
  if (self._readableState.length === 0) {
    self.readable = false;
    maybeDestroy(self);
  // push a null to signal the end of data.
  self.push(null);
  // internal end event so that we know that the actual socket
  // is no longer readable, and we can start the shutdown
  // procedure. No need to wait for all the data to be consumed.
  self.emit('_socketEnd');
Socket.prototype._getpeername = function() {
  if (!this._peername) {
    if (!this._handle || !this._handle.getpeername) {
      return {};
    }
    var out = {};
    var err = this._handle.getpeername(out);
    if (err) return {};  // FIXME(bnoordhuis) Throw?
    this._peername = out;
  return this._peername;
function protoGetter(name, callback) {
  Object.defineProperty(Socket.prototype, name, {
    configurable: false,
    enumerable: true,
    get: callback
  });
protoGetter('bytesRead', function bytesRead() {
  return this._handle ? this._handle.bytesRead : this[BYTES_READ];
protoGetter('remoteAddress', function remoteAddress() {
  return this._getpeername().address;
protoGetter('remoteFamily', function remoteFamily() {
  return this._getpeername().family;
protoGetter('remotePort', function remotePort() {
  return this._getpeername().port;
Socket.prototype._getsockname = function() {
  if (!this._handle || !this._handle.getsockname) {
    return {};
  if (!this._sockname) {
    var out = {};
    var err = this._handle.getsockname(out);
    if (err) return {};  // FIXME(bnoordhuis) Throw?
    this._sockname = out;
  return this._sockname;
protoGetter('localAddress', function localAddress() {
  return this._getsockname().address;
protoGetter('localPort', function localPort() {
  return this._getsockname().port;
Socket.prototype.write = function(chunk, encoding, cb) {
  if (typeof chunk !== 'string' && !(chunk instanceof Buffer))
    throw new TypeError('invalid data');
  return stream.Duplex.prototype.write.apply(this, arguments);
Socket.prototype._writeGeneric = function(writev, data, encoding, cb) {
  // If we are still connecting, then buffer this for later.
  // The Writable logic will buffer up any more writes while
  // waiting for this one to be done.
  if (this._connecting) {
    this._pendingData = data;
    this._pendingEncoding = encoding;
    this.once('connect', function() {
      this._writeGeneric(writev, data, encoding, cb);
    });
    return;
  this._pendingData = null;
  this._pendingEncoding = '';
  this._unrefTimer();
  if (!this._handle) {
    this._destroy(new Error('This socket is closed.'), cb);
    return false;
  var req = new WriteWrap();
  req.handle = this._handle;
  req.oncomplete = afterWrite;
  req.async = false;
  var err;
  if (writev) {
    var chunks = new Array(data.length << 1);
    for (var i = 0; i < data.length; i++) {
      var entry = data[i];
      chunks[i * 2] = entry.chunk;
      chunks[i * 2 + 1] = entry.encoding;
    }
    err = this._handle.writev(req, chunks);
    // Retain chunks
    if (err === 0) req._chunks = chunks;
  } else {
    var enc;
    if (data instanceof Buffer) {
      req.buffer = data;  // Keep reference alive.
      enc = 'buffer';
    } else {
      enc = encoding;
    }
    err = createWriteReq(req, this._handle, data, enc);
  if (err)
    return this._destroy(errnoException(err, 'write', req.error), cb);
  this._bytesDispatched += req.bytes;
  // If it was entirely flushed, we can write some more right now.
  // However, if more is left in the queue, then wait until that clears.
  if (req.async && this._handle.writeQueueSize != 0)
    req.cb = cb;
  else
    cb();
Socket.prototype._writev = function(chunks, cb) {
  this._writeGeneric(true, chunks, '', cb);
Socket.prototype._write = function(data, encoding, cb) {
  this._writeGeneric(false, data, encoding, cb);
function createWriteReq(req, handle, data, encoding) {
  switch (encoding) {
    case 'binary':
      return handle.writeBinaryString(req, data);
    case 'buffer':
      return handle.writeBuffer(req, data);
    case 'utf8':
    case 'utf-8':
      return handle.writeUtf8String(req, data);
    case 'ascii':
      return handle.writeAsciiString(req, data);
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return handle.writeUcs2String(req, data);
    default:
      return handle.writeBuffer(req, new Buffer(data, encoding));
protoGetter('bytesWritten', function bytesWritten() {
  var bytes = this._bytesDispatched;
  const state = this._writableState;
  const data = this._pendingData;
  const encoding = this._pendingEncoding;
  if (!state)
    return undefined;
  state.getBuffer().forEach(function(el) {
    if (el.chunk instanceof Buffer)
      bytes += el.chunk.length;
    else
      bytes += Buffer.byteLength(el.chunk, el.encoding);
  });
  if (data) {
    if (data instanceof Buffer)
      bytes += data.length;
    else
      bytes += Buffer.byteLength(data, encoding);
  return bytes;
function afterWrite(status, handle, req, err) {
  var self = handle.owner;
  if (self !== process.stderr && self !== process.stdout)
    debug('afterWrite', status);
  // callback may come after call to destroy.
  if (self.destroyed) {
    debug('afterWrite destroyed');
    return;
  if (status < 0) {
    var ex = errnoException(status, 'write', req.error);
    debug('write failure', ex);
    self._destroy(ex, req.cb);
    return;
  self._unrefTimer();
  if (self !== process.stderr && self !== process.stdout)
    debug('afterWrite call cb');
  if (req.cb)
    req.cb.call(self);
function connect(self, address, port, addressType, localAddress, localPort) {
  // TODO return promise from Socket.prototype.connect which
  // wraps _connectReq.
  assert.ok(self._connecting);
  var err;
  if (localAddress || localPort) {
    var bind;
    if (addressType === 4) {
      localAddress = localAddress || '0.0.0.0';
      bind = self._handle.bind;
    } else if (addressType === 6) {
      localAddress = localAddress || '::';
      bind = self._handle.bind6;
    } else {
      self._destroy(new TypeError('Invalid addressType: ' + addressType));
      return;
    }
    debug('binding to localAddress: %s and localPort: %d',
          localAddress,
          localPort);
    bind = bind.bind(self._handle);
    err = bind(localAddress, localPort);
    if (err) {
      const ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);
      self._destroy(ex);
      return;
    }
  if (addressType === 6 || addressType === 4) {
    const req = new TCPConnectWrap();
    req.oncomplete = afterConnect;
    req.address = address;
    req.port = port;
    req.localAddress = localAddress;
    req.localPort = localPort;
    if (addressType === 4)
      err = self._handle.connect(req, address, port);
    else
      err = self._handle.connect6(req, address, port);
  } else {
    const req = new PipeConnectWrap();
    req.address = address;
    req.oncomplete = afterConnect;
    err = self._handle.connect(req, address, afterConnect);
  if (err) {
    var sockname = self._getsockname();
    var details;
    if (sockname) {
      details = sockname.address + ':' + sockname.port;
    }
    const ex = exceptionWithHostPort(err, 'connect', address, port, details);
    self._destroy(ex);
Socket.prototype.connect = function(options, cb) {
  if (this.write !== Socket.prototype.write)
    this.write = Socket.prototype.write;
  if (options === null || typeof options !== 'object') {
    // Old API:
    // connect(port, [host], [cb])
    // connect(path, [cb]);
    const argsLen = arguments.length;
    var args = new Array(argsLen);
    for (var i = 0; i < argsLen; i++)
      args[i] = arguments[i];
    args = normalizeConnectArgs(args);
    return Socket.prototype.connect.apply(this, args);
  if (this.destroyed) {
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
    this.destroyed = false;
    this._handle = null;
    this._peername = null;
    this._sockname = null;
  var pipe = !!options.path;
  debug('pipe', pipe, options.path);
  if (!this._handle) {
    this._handle = pipe ? new Pipe() : new TCP();
    initSocketHandle(this);
  if (typeof cb === 'function') {
    this.once('connect', cb);
  this._unrefTimer();
  this._connecting = true;
  this.writable = true;
  if (pipe) {
    connect(this, options.path);
  } else {
    lookupAndConnect(this, options);
  return this;
function lookupAndConnect(self, options) {
  const dns = require('dns');
  var host = options.host || 'localhost';
  var port = options.port;
  var localAddress = options.localAddress;
  var localPort = options.localPort;
  if (localAddress && !exports.isIP(localAddress))
    throw new TypeError('localAddress must be a valid IP: ' + localAddress);
  if (localPort && typeof localPort !== 'number')
    throw new TypeError('localPort should be a number: ' + localPort);
  if (typeof port !== 'undefined') {
    if (typeof port !== 'number' && typeof port !== 'string')
      throw new TypeError('port should be a number or string: ' + port);
    if (!isLegalPort(port))
      throw new RangeError('port should be >= 0 and < 65536: ' + port);
  port |= 0;
  // If host is an IP, skip performing a lookup
  var addressType = exports.isIP(host);
  if (addressType) {
    process.nextTick(function() {
      if (self._connecting)
        connect(self, host, port, addressType, localAddress, localPort);
    });
    return;
  if (options.lookup && typeof options.lookup !== 'function')
    throw new TypeError('options.lookup should be a function.');
  var dnsopts = {
    family: options.family,
    hints: 0
  };
  if (dnsopts.family !== 4 && dnsopts.family !== 6) {
    dnsopts.hints = dns.ADDRCONFIG;
    // The AI_V4MAPPED hint is not supported on FreeBSD or Android,
    // and getaddrinfo returns EAI_BADFLAGS. However, it seems to be
    // supported on most other systems. See
    // http://lists.freebsd.org/pipermail/freebsd-bugs/2008-February/028260.html
    // for more information on the lack of support for FreeBSD.
    if (process.platform !== 'freebsd' && process.platform !== 'android')
      dnsopts.hints |= dns.V4MAPPED;
  debug('connect: find host ' + host);
  debug('connect: dns options', dnsopts);
  self._host = host;
  var lookup = options.lookup || dns.lookup;
  lookup(host, dnsopts, function(err, ip, addressType) {
    self.emit('lookup', err, ip, addressType);
    // It's possible we were destroyed while looking this up.
    // XXX it would be great if we could cancel the promise returned by
    // the look up.
    if (!self._connecting) return;
    if (err) {
      // net.createConnection() creates a net.Socket object and
      // immediately calls net.Socket.connect() on it (that's us).
      // There are no event listeners registered yet so defer the
      // error event to the next tick.
      err.host = options.host;
      err.port = options.port;
      err.message = err.message + ' ' + options.host + ':' + options.port;
      process.nextTick(connectErrorNT, self, err);
    } else {
      self._unrefTimer();
      connect(self,
              ip,
              port,
              addressType,
              localAddress,
              localPort);
    }
  });
function connectErrorNT(self, err) {
  self.emit('error', err);
  self._destroy();
Socket.prototype.ref = function() {
  if (!this._handle) {
    this.once('connect', this.ref);
    return this;
  this._handle.ref();
  return this;
Socket.prototype.unref = function() {
  if (!this._handle) {
    this.once('connect', this.unref);
    return this;
  this._handle.unref();
  return this;
function afterConnect(status, handle, req, readable, writable) {
  var self = handle.owner;
  // callback may come after call to destroy
  if (self.destroyed) {
    return;
  // Update handle if it was wrapped
  // TODO(indutny): assert that the handle is actually an ancestor of old one
  handle = self._handle;
  debug('afterConnect');
  assert.ok(self._connecting);
  self._connecting = false;
  self._sockname = null;
  if (status == 0) {
    self.readable = readable;
    self.writable = writable;
    self._unrefTimer();
    self.emit('connect');
    // start the first read, or get an immediate EOF.
    // this doesn't actually consume any bytes, because len=0.
    if (readable && !self.isPaused())
      self.read(0);
  } else {
    self._connecting = false;
    var details;
    if (req.localAddress && req.localPort) {
      details = req.localAddress + ':' + req.localPort;
    }
    var ex = exceptionWithHostPort(status,
                                   'connect',
                                   req.address,
                                   req.port,
                                   details);
    if (details) {
      ex.localAddress = req.localAddress;
      ex.localPort = req.localPort;
    }
    self._destroy(ex);
function Server(options, connectionListener) {
  if (!(this instanceof Server))
    return new Server(options, connectionListener);
  EventEmitter.call(this);
  var self = this;
  if (typeof options === 'function') {
    connectionListener = options;
    options = {};
    self.on('connection', connectionListener);
  } else {
    options = options || {};
    if (typeof connectionListener === 'function') {
      self.on('connection', connectionListener);
    }
  this._connections = 0;
  Object.defineProperty(this, 'connections', {
    get: internalUtil.deprecate(function() {
      if (self._usingSlaves) {
        return null;
      }
      return self._connections;
    }, 'Server.connections property is deprecated. ' +
       'Use Server.getConnections method instead.'),
    set: internalUtil.deprecate(function(val) {
      return (self._connections = val);
    }, 'Server.connections property is deprecated.'),
    configurable: true, enumerable: false
  });
  this._handle = null;
  this._usingSlaves = false;
  this._slaves = [];
  this._unref = false;
  this.allowHalfOpen = options.allowHalfOpen || false;
  this.pauseOnConnect = !!options.pauseOnConnect;
util.inherits(Server, EventEmitter);
exports.Server = Server;
function toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }
function _listen(handle, backlog) {
  // Use a backlog of 512 entries. We pass 511 to the listen() call because
  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);
  // which will thus give us a backlog of 512 entries.
  return handle.listen(backlog || 511);
function createServerHandle(address, port, addressType, fd) {
  var err = 0;
  // assign handle in listen, and clean up if bind or listen fails
  var handle;
  var isTCP = false;
  if (typeof fd === 'number' && fd >= 0) {
    try {
      handle = createHandle(fd);
    }
    catch (e) {
      // Not a fd we can listen on.  This will trigger an error.
      debug('listen invalid fd=' + fd + ': ' + e.message);
      return uv.UV_EINVAL;
    }
    handle.open(fd);
    handle.readable = true;
    handle.writable = true;
    assert(!address && !port);
  } else if (port === -1 && addressType === -1) {
    handle = new Pipe();
    if (process.platform === 'win32') {
      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);
      if (!isNaN(instances)) {
        handle.setPendingInstances(instances);
      }
    }
  } else {
    handle = new TCP();
    isTCP = true;
  if (address || port || isTCP) {
    debug('bind to ' + (address || 'anycast'));
    if (!address) {
      // Try binding to ipv6 first
      err = handle.bind6('::', port);
      if (err) {
        handle.close();
        // Fallback to ipv4
        return createServerHandle('0.0.0.0', port);
      }
    } else if (addressType === 6) {
      err = handle.bind6(address, port);
    } else {
      err = handle.bind(address, port);
    }
  if (err) {
    handle.close();
    return err;
  return handle;
exports._createServerHandle = createServerHandle;
Server.prototype._listen2 = function(address, port, addressType, backlog, fd) {
  debug('listen2', address, port, addressType, backlog, fd);
  // If there is not yet a handle, we need to create one and bind.
  // In the case of a server sent via IPC, we don't need to do this.
  if (this._handle) {
    debug('_listen2: have a handle already');
  } else {
    debug('_listen2: create a handle');
    var rval = null;
    if (!address && typeof fd !== 'number') {
      rval = createServerHandle('::', port, 6, fd);
      if (typeof rval === 'number') {
        rval = null;
        address = '0.0.0.0';
        addressType = 4;
      } else {
        address = '::';
        addressType = 6;
      }
    }
    if (rval === null)
      rval = createServerHandle(address, port, addressType, fd);
    if (typeof rval === 'number') {
      var error = exceptionWithHostPort(rval, 'listen', address, port);
      process.nextTick(emitErrorNT, this, error);
      return;
    }
    this._handle = rval;
  this._handle.onconnection = onconnection;
  this._handle.owner = this;
  var err = _listen(this._handle, backlog);
  if (err) {
    var ex = exceptionWithHostPort(err, 'listen', address, port);
    this._handle.close();
    this._handle = null;
    process.nextTick(emitErrorNT, this, ex);
    return;
  // generate connection key, this should be unique to the connection
  this._connectionKey = addressType + ':' + address + ':' + port;
  // unref the handle if the server was unref'ed prior to listening
  if (this._unref)
    this.unref();
  process.nextTick(emitListeningNT, this);
function emitErrorNT(self, err) {
  self.emit('error', err);
function emitListeningNT(self) {
  // ensure handle hasn't closed
  if (self._handle)
    self.emit('listening');
function listen(self, address, port, addressType, backlog, fd, exclusive) {
  exclusive = !!exclusive;
  if (!cluster) cluster = require('cluster');
  if (cluster.isMaster || exclusive) {
    self._listen2(address, port, addressType, backlog, fd);
    return;
  cluster._getServer(self, {
    address: address,
    port: port,
    addressType: addressType,
    fd: fd,
    flags: 0
  }, cb);
  function cb(err, handle) {
    // EADDRINUSE may not be reported until we call listen(). To complicate
    // matters, a failed bind() followed by listen() will implicitly bind to
    // a random port. Ergo, check that the socket is bound to the expected
    // port before calling listen().
    //
    // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a
    // getsockname() method. Non-issue for now, the cluster module doesn't
    // really support pipes anyway.
    if (err === 0 && port > 0 && handle.getsockname) {
      var out = {};
      err = handle.getsockname(out);
      if (err === 0 && port !== out.port)
        err = uv.UV_EADDRINUSE;
    }
    if (err) {
      var ex = exceptionWithHostPort(err, 'bind', address, port);
      return self.emit('error', ex);
    }
    self._handle = handle;
    self._listen2(address, port, addressType, backlog, fd);
Server.prototype.listen = function() {
  var self = this;
  var lastArg = arguments[arguments.length - 1];
  if (typeof lastArg === 'function') {
    self.once('listening', lastArg);
  var port = toNumber(arguments[0]);
  // The third optional argument is the backlog size.
  // When the ip is omitted it can be the second argument.
  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]);
  if (arguments.length === 0 || typeof arguments[0] === 'function') {
    // Bind to a random port.
    listen(self, null, 0, null, backlog);
  } else if (arguments[0] !== null && typeof arguments[0] === 'object') {
    var h = arguments[0];
    h = h._handle || h.handle || h;
    if (h instanceof TCP) {
      self._handle = h;
      listen(self, null, -1, -1, backlog);
    } else if (typeof h.fd === 'number' && h.fd >= 0) {
      listen(self, null, null, null, backlog, h.fd);
    } else {
      // The first argument is a configuration object
      if (h.backlog)
        backlog = h.backlog;
      if (typeof h.port === 'number' || typeof h.port === 'string' ||
          (typeof h.port === 'undefined' && 'port' in h)) {
        // Undefined is interpreted as zero (random port) for consistency
        // with net.connect().
        if (typeof h.port !== 'undefined' && !isLegalPort(h.port))
          throw new RangeError('port should be >= 0 and < 65536: ' + h.port);
        if (h.host)
          listenAfterLookup(h.port | 0, h.host, backlog, h.exclusive);
        else
          listen(self, null, h.port | 0, 4, backlog, undefined, h.exclusive);
      } else if (h.path && isPipeName(h.path)) {
        const pipeName = self._pipeName = h.path;
        listen(self, pipeName, -1, -1, backlog, undefined, h.exclusive);
      } else {
        throw new Error('Invalid listen argument: ' + h);
      }
    }
  } else if (isPipeName(arguments[0])) {
    // UNIX socket or Windows pipe.
    const pipeName = self._pipeName = arguments[0];
    listen(self, pipeName, -1, -1, backlog);
  } else if (arguments[1] === undefined ||
             typeof arguments[1] === 'function' ||
             typeof arguments[1] === 'number') {
    // The first argument is the port, no IP given.
    listen(self, null, port, 4, backlog);
  } else {
    // The first argument is the port, the second an IP.
    listenAfterLookup(port, arguments[1], backlog);
  function listenAfterLookup(port, address, backlog, exclusive) {
    require('dns').lookup(address, function(err, ip, addressType) {
      if (err) {
        self.emit('error', err);
      } else {
        addressType = ip ? addressType : 4;
        listen(self, ip, port, addressType, backlog, undefined, exclusive);
      }
    });
  return self;
Server.prototype.address = function() {
  if (this._handle && this._handle.getsockname) {
    var out = {};
    this._handle.getsockname(out);
    // TODO(bnoordhuis) Check err and throw?
    return out;
  } else if (this._pipeName) {
    return this._pipeName;
  } else {
    return null;
function onconnection(err, clientHandle) {
  var handle = this;
  var self = handle.owner;
  debug('onconnection');
  if (err) {
    self.emit('error', errnoException(err, 'accept'));
    return;
  if (self.maxConnections && self._connections >= self.maxConnections) {
    clientHandle.close();
    return;
  var socket = new Socket({
    handle: clientHandle,
    allowHalfOpen: self.allowHalfOpen,
    pauseOnCreate: self.pauseOnConnect
  });
  socket.readable = socket.writable = true;
  self._connections++;
  socket.server = self;
  socket._server = self;
  DTRACE_NET_SERVER_CONNECTION(socket);
  self.emit('connection', socket);
Server.prototype.getConnections = function(cb) {
  function end(err, connections) {
    process.nextTick(cb, err, connections);
  if (!this._usingSlaves) {
    return end(null, this._connections);
  // Poll slaves
  var left = this._slaves.length;
  var total = this._connections;
  function oncount(err, count) {
    if (err) {
      left = -1;
      return end(err);
    }
    total += count;
    if (--left === 0) return end(null, total);
  this._slaves.forEach(function(slave) {
    slave.getConnections(oncount);
  });
Server.prototype.close = function(cb) {
  function onSlaveClose() {
    if (--left !== 0) return;
    self._connections = 0;
    self._emitCloseIfDrained();
  if (typeof cb === 'function') {
    if (!this._handle) {
      this.once('close', function() {
        cb(new Error('Not running'));
      });
    } else {
      this.once('close', cb);
    }
  if (this._handle) {
    this._handle.close();
    this._handle = null;
  if (this._usingSlaves) {
    var self = this;
    var left = this._slaves.length;
    // Increment connections to be sure that, even if all sockets will be closed
    // during polling of slaves, `close` event will be emitted only once.
    this._connections++;
    // Poll slaves
    this._slaves.forEach(function(slave) {
      slave.close(onSlaveClose);
    });
  } else {
    this._emitCloseIfDrained();
  return this;
Server.prototype._emitCloseIfDrained = function() {
  debug('SERVER _emitCloseIfDrained');
  if (this._handle || this._connections) {
    debug('SERVER handle? %j   connections? %d',
          !!this._handle, this._connections);
    return;
  process.nextTick(emitCloseNT, this);
function emitCloseNT(self) {
  debug('SERVER: emit close');
  self.emit('close');
Server.prototype.listenFD = internalUtil.deprecate(function(fd, type) {
  return this.listen({ fd: fd });
}, 'Server.listenFD is deprecated. Use Server.listen({fd: <number>}) instead.');
Server.prototype._setupSlave = function(socketList) {
  this._usingSlaves = true;
  this._slaves.push(socketList);
Server.prototype.ref = function() {
  this._unref = false;
  if (this._handle)
    this._handle.ref();
  return this;
Server.prototype.unref = function() {
  this._unref = true;
  if (this._handle)
    this._handle.unref();
  return this;
exports.isIP = cares.isIP;
exports.isIPv4 = function(input) {
  return cares.isIPv4(input);
exports.isIPv6 = function(input) {
  return cares.isIPv6(input);
if (process.platform === 'win32') {
  var simultaneousAccepts;
  exports._setSimultaneousAccepts = function(handle) {
    if (handle === undefined) {
      return;
    }
    if (simultaneousAccepts === undefined) {
      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&
                             process.env.NODE_MANY_ACCEPTS !== '0');
    }
    if (handle._simultaneousAccepts !== simultaneousAccepts) {
      handle.setSimultaneousAccepts(simultaneousAccepts);
      handle._simultaneousAccepts = simultaneousAccepts;
    }
  };
} else {
  exports._setSimultaneousAccepts = function(handle) {};
'use strict';
const binding = process.binding('os');
const internalUtil = require('internal/util');
const isWindows = process.platform === 'win32';
exports.hostname = binding.getHostname;
exports.loadavg = binding.getLoadAvg;
exports.uptime = binding.getUptime;
exports.freemem = binding.getFreeMem;
exports.totalmem = binding.getTotalMem;
exports.cpus = binding.getCPUs;
exports.type = binding.getOSType;
exports.release = binding.getOSRelease;
exports.networkInterfaces = binding.getInterfaceAddresses;
exports.homedir = binding.getHomeDirectory;
exports.arch = function() {
  return process.arch;
exports.platform = function() {
  return process.platform;
exports.tmpdir = function() {
  var path;
  if (isWindows) {
    path = process.env.TEMP ||
           process.env.TMP ||
           (process.env.SystemRoot || process.env.windir) + '\\temp';
    if (path.length > 1 && path.endsWith('\\') && !path.endsWith(':\\'))
      path = path.slice(0, -1);
  } else {
    path = process.env.TMPDIR ||
           process.env.TMP ||
           process.env.TEMP ||
           '/tmp';
    if (path.length > 1 && path.endsWith('/'))
      path = path.slice(0, -1);
  return path;
exports.tmpDir = exports.tmpdir;
exports.getNetworkInterfaces = internalUtil.deprecate(function() {
  return exports.networkInterfaces();
}, 'os.getNetworkInterfaces is deprecated. ' +
   'Use os.networkInterfaces instead.');
exports.EOL = isWindows ? '\r\n' : '\n';
if (binding.isBigEndian)
  exports.endianness = function() { return 'BE'; };
else
  exports.endianness = function() { return 'LE'; };
'use strict';
const util = require('util');
const isWindows = process.platform === 'win32';
function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' +
                        util.inspect(path));
// resolves . and .. elements in a path array with directory names there
// must be no slashes or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  var res = [];
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i];
    // ignore empty parts
    if (!p || p === '.')
      continue;
    if (p === '..') {
      if (res.length && res[res.length - 1] !== '..') {
        res.pop();
      } else if (allowAboveRoot) {
        res.push('..');
      }
    } else {
      res.push(p);
    }
  return res;
// Returns an array with empty elements removed from either end of the input
// array or the original array if no elements need to be removed
function trimArray(arr) {
  var lastIndex = arr.length - 1;
  var start = 0;
  for (; start <= lastIndex; start++) {
    if (arr[start])
      break;
  var end = lastIndex;
  for (; end >= 0; end--) {
    if (arr[end])
      break;
  if (start === 0 && end === lastIndex)
    return arr;
  if (start > end)
    return [];
  return arr.slice(start, end + 1);
// Regex to split a windows path into three parts: [*, device, slash,
// tail] windows-only
const splitDeviceRe =
    /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
// Regex to split the tail part of the above into [*, dir, basename, ext]
const splitTailRe =
    /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
var win32 = {};
// Function to split a filename into [root, dir, basename, ext]
function win32SplitPath(filename) {
  // Separate device+slash from tail
  const result = splitDeviceRe.exec(filename);
  const device = (result[1] || '') + (result[2] || '');
  const tail = result[3];
  // Split the tail into dir, basename and extension
  const result2 = splitTailRe.exec(tail);
  const dir = result2[1];
  const basename = result2[2];
  const ext = result2[3];
  return [device, dir, basename, ext];
function win32StatPath(path) {
  const result = splitDeviceRe.exec(path);
  const device = result[1] || '';
  const isUnc = !!device && device[1] !== ':';
  return {
    device,
    isUnc,
    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute
    tail: result[3]
  };
function normalizeUNCRoot(device) {
  return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
// path.resolve([from ...], to)
win32.resolve = function() {
  var resolvedDevice = '';
  var resolvedTail = '';
  var resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1; i--) {
    var path;
    if (i >= 0) {
      path = arguments[i];
    } else if (!resolvedDevice) {
      path = process.cwd();
    } else {
      // Windows has the concept of drive-specific current working
      // directories. If we've resolved a drive letter but not yet an
      // absolute path, get cwd for that drive. We're sure the device is not
      // an unc path at this points, because unc paths are always absolute.
      path = process.env['=' + resolvedDevice];
      // Verify that a drive-local cwd was found and that it actually points
      // to our drive. If not, default to the drive's root.
      if (!path || path.substr(0, 3).toLowerCase() !==
          resolvedDevice.toLowerCase() + '\\') {
        path = resolvedDevice + '\\';
      }
    }
    assertPath(path);
    // Skip empty entries
    if (path === '') {
      continue;
    }
    const result = win32StatPath(path);
    const device = result.device;
    var isUnc = result.isUnc;
    const isAbsolute = result.isAbsolute;
    const tail = result.tail;
    if (device &&
        resolvedDevice &&
        device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      // This path points to another device so it is not applicable
      continue;
    }
    if (!resolvedDevice) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = tail + '\\' + resolvedTail;
      resolvedAbsolute = isAbsolute;
    }
    if (resolvedDevice && resolvedAbsolute) {
      break;
    }
  // Convert slashes to backslashes when `resolvedDevice` points to an UNC
  // root. Also squash multiple slashes into a single one where appropriate.
  if (isUnc) {
    resolvedDevice = normalizeUNCRoot(resolvedDevice);
  // At this point the path should be resolved to a full absolute path,
  // but handle relative paths to be safe (might happen when process.cwd()
  // fails)
  // Normalize the tail path
  resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/),
                                !resolvedAbsolute).join('\\');
  return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
         '.';
win32.normalize = function(path) {
  assertPath(path);
  const result = win32StatPath(path);
  var device = result.device;
  const isUnc = result.isUnc;
  const isAbsolute = result.isAbsolute;
  var tail = result.tail;
  const trailingSlash = /[\\\/]$/.test(tail);
  // Normalize the tail path
  tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join('\\');
  if (!tail && !isAbsolute) {
    tail = '.';
  if (tail && trailingSlash) {
    tail += '\\';
  // Convert slashes to backslashes when `device` points to an UNC root.
  // Also squash multiple slashes into a single one where appropriate.
  if (isUnc) {
    device = normalizeUNCRoot(device);
  return device + (isAbsolute ? '\\' : '') + tail;
win32.isAbsolute = function(path) {
  assertPath(path);
  return win32StatPath(path).isAbsolute;
win32.join = function() {
  var paths = [];
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];
    assertPath(arg);
    if (arg) {
      paths.push(arg);
    }
  var joined = paths.join('\\');
  // Make sure that the joined path doesn't start with two slashes, because
  // normalize() will mistake it for an UNC path then.
  //
  // This step is skipped when it is very clear that the user actually
  // intended to point at an UNC path. This is assumed when the first
  // non-empty string arguments starts with exactly two slashes followed by
  // at least one more non-slash character.
  //
  // Note that for normalize() to treat a path as an UNC path it needs to
  // have at least 2 components, so we don't filter for that here.
  // This means that the user can use join to construct UNC paths from
  // a server name and a share name; for example:
  //   path.join('//server', 'share') -> '\\\\server\\share\')
  if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
    joined = joined.replace(/^[\\\/]{2,}/, '\\');
  return win32.normalize(joined);
// path.relative(from, to)
// it will solve the relative path from 'from' to 'to', for instance:
// from = 'C:\\orandea\\test\\aaa'
// to = 'C:\\orandea\\impl\\bbb'
// The output of the function should be: '..\\..\\impl\\bbb'
win32.relative = function(from, to) {
  assertPath(from);
  assertPath(to);
  from = win32.resolve(from);
  to = win32.resolve(to);
  // windows is not case sensitive
  var lowerFrom = from.toLowerCase();
  var lowerTo = to.toLowerCase();
  var toParts = trimArray(to.split('\\'));
  var lowerFromParts = trimArray(lowerFrom.split('\\'));
  var lowerToParts = trimArray(lowerTo.split('\\'));
  var length = Math.min(lowerFromParts.length, lowerToParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (lowerFromParts[i] !== lowerToParts[i]) {
      samePartsLength = i;
      break;
    }
  if (samePartsLength === 0) {
    return to;
  var outputParts = [];
  for (var j = samePartsLength; j < lowerFromParts.length; j++) {
    outputParts.push('..');
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('\\');
win32._makeLong = function(path) {
  // Note: this will *probably* throw somewhere.
  if (typeof path !== 'string')
    return path;
  if (!path) {
    return '';
  var resolvedPath = win32.resolve(path);
  if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
    // path is local filesystem path, which needs to be converted
    // to long UNC path.
    return '\\\\?\\' + resolvedPath;
  } else if (/^\\\\[^?.]/.test(resolvedPath)) {
    // path is network UNC path, which needs to be converted
    // to long UNC path.
    return '\\\\?\\UNC\\' + resolvedPath.substring(2);
  return path;
win32.dirname = function(path) {
  const result = win32SplitPath(path);
  const root = result[0];
  var dir = result[1];
  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  return root + dir;
win32.basename = function(path, ext) {
  if (ext !== undefined && typeof ext !== 'string')
    throw new TypeError('ext must be a string');
  var f = win32SplitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  return f;
win32.extname = function(path) {
  return win32SplitPath(path)[3];
win32.format = function(pathObject) {
  if (pathObject === null || typeof pathObject !== 'object') {
    throw new TypeError(
        "Parameter 'pathObject' must be an object, not " + typeof pathObject
    );
  var root = pathObject.root || '';
  if (typeof root !== 'string') {
    throw new TypeError(
        "'pathObject.root' must be a string or undefined, not " +
        typeof pathObject.root
    );
  var dir = pathObject.dir;
  var base = pathObject.base || '';
  if (!dir) {
    return base;
  if (dir[dir.length - 1] === win32.sep) {
    return dir + base;
  return dir + win32.sep + base;
win32.parse = function(pathString) {
  assertPath(pathString);
  var allParts = win32SplitPath(pathString);
  return {
    root: allParts[0],
    dir: allParts[0] + allParts[1].slice(0, -1),
    base: allParts[2],
    ext: allParts[3],
    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
win32.sep = '\\';
win32.delimiter = ';';
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
const splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var posix = {};
function posixSplitPath(filename) {
  const out = splitPathRe.exec(filename);
  out.shift();
  return out;
// path.resolve([from ...], to)
// posix version
posix.resolve = function() {
  var resolvedPath = '';
  var resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();
    assertPath(path);
    // Skip empty entries
    if (path === '') {
      continue;
    }
    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path[0] === '/';
  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path
  resolvedPath = normalizeArray(resolvedPath.split('/'),
                                !resolvedAbsolute).join('/');
  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
// path.normalize(path)
// posix version
posix.normalize = function(path) {
  assertPath(path);
  const isAbsolute = posix.isAbsolute(path);
  const trailingSlash = path && path[path.length - 1] === '/';
  // Normalize the path
  path = normalizeArray(path.split('/'), !isAbsolute).join('/');
  if (!path && !isAbsolute) {
    path = '.';
  if (path && trailingSlash) {
    path += '/';
  return (isAbsolute ? '/' : '') + path;
// posix version
posix.isAbsolute = function(path) {
  assertPath(path);
  return !!path && path[0] === '/';
// posix version
posix.join = function() {
  var path = '';
  for (var i = 0; i < arguments.length; i++) {
    var segment = arguments[i];
    assertPath(segment);
    if (segment) {
      if (!path) {
        path += segment;
      } else {
        path += '/' + segment;
      }
    }
  return posix.normalize(path);
// path.relative(from, to)
// posix version
posix.relative = function(from, to) {
  assertPath(from);
  assertPath(to);
  from = posix.resolve(from).substr(1);
  to = posix.resolve(to).substr(1);
  var fromParts = trimArray(from.split('/'));
  var toParts = trimArray(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  var outputParts = [];
  for (var j = samePartsLength; j < fromParts.length; j++) {
    outputParts.push('..');
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
posix._makeLong = function(path) {
  return path;
posix.dirname = function(path) {
  const result = posixSplitPath(path);
  const root = result[0];
  var dir = result[1];
  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  return root + dir;
posix.basename = function(path, ext) {
  if (ext !== undefined && typeof ext !== 'string')
    throw new TypeError('ext must be a string');
  var f = posixSplitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  return f;
posix.extname = function(path) {
  return posixSplitPath(path)[3];
posix.format = function(pathObject) {
  if (pathObject === null || typeof pathObject !== 'object') {
    throw new TypeError(
        "Parameter 'pathObject' must be an object, not " + typeof pathObject
    );
  var root = pathObject.root || '';
  if (typeof root !== 'string') {
    throw new TypeError(
        "'pathObject.root' must be a string or undefined, not " +
        typeof pathObject.root
    );
  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';
  var base = pathObject.base || '';
  return dir + base;
posix.parse = function(pathString) {
  assertPath(pathString);
  var allParts = posixSplitPath(pathString);
  return {
    root: allParts[0],
    dir: allParts[0] + allParts[1].slice(0, -1),
    base: allParts[2],
    ext: allParts[3],
    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
  };
posix.sep = '/';
posix.delimiter = ':';
if (isWindows)
  module.exports = win32;
else /* posix */
  module.exports = posix;
module.exports.posix = posix;
module.exports.win32 = win32;
'use strict';
// Re-export process as a native module
module.exports = process;
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {
/** Detect free variables */
var freeExports = typeof exports == 'object' && exports &&
!exports.nodeType && exports;
var freeModule = typeof module == 'object' && module &&
!module.nodeType && module;
var freeGlobal = typeof global == 'object' && global;
if (
freeGlobal.global === freeGlobal ||
freeGlobal.window === freeGlobal ||
freeGlobal.self === freeGlobal
root = freeGlobal;
 * The `punycode` object.
 * @name punycode
 * @type Object
var punycode,
/** Highest positive signed 32-bit float value */
maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
/** Bootstring parameters */
base = 36,
tMin = 1,
tMax = 26,
skew = 38,
damp = 700,
initialBias = 72,
initialN = 128, // 0x80
delimiter = '-', // '\x2D'
/** Regular expressions */
regexPunycode = /^xn--/,
regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
/** Error messages */
errors = {
'overflow': 'Overflow: input needs wider integers to process',
'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
'invalid-input': 'Invalid input'
/** Convenience shortcuts */
baseMinusTMin = base - tMin,
floor = Math.floor,
stringFromCharCode = String.fromCharCode,
/** Temporary variable */
key;
/*--------------------------------------------------------------------------*/
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
function error(type) {
throw new RangeError(errors[type]);
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
function map(array, fn) {
var length = array.length;
var result = [];
while (length--) {
result[length] = fn(array[length]);
return result;
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
function mapDomain(string, fn) {
var parts = string.split('@');
var result = '';
if (parts.length > 1) {
// In email addresses, only the domain name should be punycoded. Leave
// the local part (i.e. everything up to `@`) intact.
result = parts[0] + '@';
string = parts[1];
// Avoid `split(regex)` for IE8 compatibility. See #17.
string = string.replace(regexSeparators, '\x2E');
var labels = string.split('.');
var encoded = map(labels, fn).join('.');
return result + encoded;
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
function ucs2decode(string) {
var output = [],
    counter = 0,
    length = string.length,
    value,
    extra;
while (counter < length) {
value = string.charCodeAt(counter++);
if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
// high surrogate, and there is a next character
extra = string.charCodeAt(counter++);
if ((extra & 0xFC00) == 0xDC00) { // low surrogate
output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
} else {
// unmatched surrogate; only append this code unit, in case the next
// code unit is the high surrogate of a surrogate pair
output.push(value);
counter--;
} else {
output.push(value);
return output;
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
function ucs2encode(array) {
return map(array, function(value) {
var output = '';
if (value > 0xFFFF) {
value -= 0x10000;
output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
value = 0xDC00 | value & 0x3FF;
output += stringFromCharCode(value);
return output;
}).join('');
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
function basicToDigit(codePoint) {
if (codePoint - 48 < 10) {
return codePoint - 22;
if (codePoint - 65 < 26) {
return codePoint - 65;
if (codePoint - 97 < 26) {
return codePoint - 97;
return base;
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
function digitToBasic(digit, flag) {
//  0..25 map to ASCII a..z or A..Z
// 26..35 map to ASCII 0..9
return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
function adapt(delta, numPoints, firstTime) {
var k = 0;
delta = firstTime ? floor(delta / damp) : delta >> 1;
delta += floor(delta / numPoints);
for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
delta = floor(delta / baseMinusTMin);
return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
function decode(input) {
// Don't use UCS-2
var output = [],
    inputLength = input.length,
    out,
    i = 0,
    n = initialN,
    bias = initialBias,
    basic,
    j,
    index,
    oldi,
    w,
    k,
    digit,
    t,
    /** Cached calculation results */
    baseMinusT;
// Handle the basic code points: let `basic` be the number of input code
// points before the last delimiter, or `0` if there is none, then copy
// the first basic code points to the output.
basic = input.lastIndexOf(delimiter);
if (basic < 0) {
basic = 0;
for (j = 0; j < basic; ++j) {
// if it's not a basic code point
if (input.charCodeAt(j) >= 0x80) {
error('not-basic');
output.push(input.charCodeAt(j));
// Main decoding loop: start just after the last delimiter if any basic code
// points were copied; start at the beginning otherwise.
for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
// `index` is the index of the next character to be consumed.
// Decode a generalized variable-length integer into `delta`,
// which gets added to `i`. The overflow checking is easier
// if we increase `i` as we go, then subtract off its starting
// value at the end to obtain `delta`.
for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
if (index >= inputLength) {
error('invalid-input');
digit = basicToDigit(input.charCodeAt(index++));
if (digit >= base || digit > floor((maxInt - i) / w)) {
error('overflow');
i += digit * w;
t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
if (digit < t) {
break;
baseMinusT = base - t;
if (w > floor(maxInt / baseMinusT)) {
error('overflow');
w *= baseMinusT;
out = output.length + 1;
bias = adapt(i - oldi, out, oldi == 0);
// `i` was supposed to wrap around from `out` to `0`,
// incrementing `n` each time, so we'll fix that now:
if (floor(i / out) > maxInt - n) {
error('overflow');
n += floor(i / out);
i %= out;
// Insert `n` at position `i` of the output
output.splice(i++, 0, n);
return ucs2encode(output);
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
function encode(input) {
var n,
    delta,
    handledCPCount,
    basicLength,
    bias,
    j,
    m,
    q,
    k,
    t,
    currentValue,
    output = [],
    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,
    /** Cached calculation results */
    handledCPCountPlusOne,
    baseMinusT,
    qMinusT;
// Convert the input in UCS-2 to Unicode
input = ucs2decode(input);
// Cache the length
inputLength = input.length;
// Initialize the state
n = initialN;
delta = 0;
bias = initialBias;
// Handle the basic code points
for (j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue < 0x80) {
output.push(stringFromCharCode(currentValue));
handledCPCount = basicLength = output.length;
// `handledCPCount` is the number of code points that have been handled;
// `basicLength` is the number of basic code points.
// Finish the basic string - if it is not empty - with a delimiter
if (basicLength) {
output.push(delimiter);
// Main encoding loop:
while (handledCPCount < inputLength) {
// All non-basic code points < n have been handled already. Find the next
// larger one:
for (m = maxInt, j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue >= n && currentValue < m) {
m = currentValue;
// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
// but guard against overflow
handledCPCountPlusOne = handledCPCount + 1;
if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
error('overflow');
delta += (m - n) * handledCPCountPlusOne;
n = m;
for (j = 0; j < inputLength; ++j) {
currentValue = input[j];
if (currentValue < n && ++delta > maxInt) {
error('overflow');
if (currentValue == n) {
// Represent delta as a generalized variable-length integer
for (q = delta, k = base; /* no condition */; k += base) {
t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
if (q < t) {
break;
qMinusT = q - t;
baseMinusT = base - t;
output.push(
stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
q = floor(qMinusT / baseMinusT);
output.push(stringFromCharCode(digitToBasic(q, 0)));
bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
delta = 0;
++handledCPCount;
++delta;
++n;
return output.join('');
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
function toUnicode(input) {
return mapDomain(input, function(string) {
return regexPunycode.test(string)
? decode(string.slice(4).toLowerCase())
: string;
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
function toASCII(input) {
return mapDomain(input, function(string) {
return regexNonASCII.test(string)
? 'xn--' + encode(string)
: string;
/*--------------------------------------------------------------------------*/
/** Define the public API */
punycode = {
 * A string representing the current Punycode.js version number.
 * @memberOf punycode
 * @type String
'version': '1.3.2',
 * An object of methods to convert from JavaScript's internal character
 * representation (UCS-2) to Unicode code points, and back.
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode
 * @type Object
'ucs2': {
'decode': ucs2decode,
'encode': ucs2encode
'decode': decode,
'encode': encode,
'toASCII': toASCII,
'toUnicode': toUnicode
/** Expose `punycode` */
// Some AMD build optimizers, like r.js, check for specific condition patterns
// like the following:
if (
typeof define == 'function' &&
typeof define.amd == 'object' &&
define.amd
define('punycode', function() {
return punycode;
} else if (freeExports && freeModule) {
if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
freeModule.exports = punycode;
} else { // in Narwhal or RingoJS v0.7.0-
for (key in punycode) {
punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
} else { // in Rhino or a web browser
root.punycode = punycode;
}(this));
// Query String Utilities
'use strict';
const QueryString = exports;
const Buffer = require('buffer').Buffer;
function charCode(c) {
  return c.charCodeAt(0);
// a safe fast alternative to decodeURIComponent
QueryString.unescapeBuffer = function(s, decodeSpaces) {
  var out = new Buffer(s.length);
  var state = 'CHAR'; // states: CHAR, HEX0, HEX1
  var n, m, hexchar;
  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {
    var c = s.charCodeAt(inIndex);
    switch (state) {
      case 'CHAR':
        switch (c) {
          case charCode('%'):
            n = 0;
            m = 0;
            state = 'HEX0';
            break;
          case charCode('+'):
            if (decodeSpaces) c = charCode(' ');
            // falls through
          default:
            out[outIndex++] = c;
            break;
        }
        break;
      case 'HEX0':
        state = 'HEX1';
        hexchar = c;
        if (charCode('0') <= c && c <= charCode('9')) {
          n = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          n = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          n = c - charCode('A') + 10;
        } else {
          out[outIndex++] = charCode('%');
          out[outIndex++] = c;
          state = 'CHAR';
          break;
        }
        break;
      case 'HEX1':
        state = 'CHAR';
        if (charCode('0') <= c && c <= charCode('9')) {
          m = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          m = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          m = c - charCode('A') + 10;
        } else {
          out[outIndex++] = charCode('%');
          out[outIndex++] = hexchar;
          out[outIndex++] = c;
          break;
        }
        out[outIndex++] = 16 * n + m;
        break;
    }
  // TODO support returning arbitrary buffers.
  return out.slice(0, outIndex - 1);
QueryString.unescape = function(s, decodeSpaces) {
  try {
    return decodeURIComponent(s);
  } catch (e) {
    return QueryString.unescapeBuffer(s, decodeSpaces).toString();
var hexTable = new Array(256);
for (var i = 0; i < 256; ++i)
  hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
QueryString.escape = function(str) {
  // replaces encodeURIComponent
  // http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3.4
  str = '' + str;
  var len = str.length;
  var out = '';
  var i, c;
  if (len === 0)
    return str;
  for (i = 0; i < len; ++i) {
    c = str.charCodeAt(i);
    // These characters do not need escaping (in order):
    // ! - . _ ~
    // ' ( ) *
    // digits
    // alpha (uppercase)
    // alpha (lowercase)
    if (c === 0x21 || c === 0x2D || c === 0x2E || c === 0x5F || c === 0x7E ||
        (c >= 0x27 && c <= 0x2A) ||
        (c >= 0x30 && c <= 0x39) ||
        (c >= 0x41 && c <= 0x5A) ||
        (c >= 0x61 && c <= 0x7A)) {
      out += str[i];
      continue;
    }
    // Other ASCII characters
    if (c < 0x80) {
      out += hexTable[c];
      continue;
    }
    // Multi-byte characters ...
    if (c < 0x800) {
      out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];
      continue;
    }
    if (c < 0xD800 || c >= 0xE000) {
      out += hexTable[0xE0 | (c >> 12)] +
             hexTable[0x80 | ((c >> 6) & 0x3F)] +
             hexTable[0x80 | (c & 0x3F)];
      continue;
    }
    // Surrogate pair
    ++i;
    var c2;
    if (i < str.length)
      c2 = str.charCodeAt(i) & 0x3FF;
    else
      throw new URIError('URI malformed');
    c = 0x10000 + (((c & 0x3FF) << 10) | c2);
    out += hexTable[0xF0 | (c >> 18)] +
           hexTable[0x80 | ((c >> 12) & 0x3F)] +
           hexTable[0x80 | ((c >> 6) & 0x3F)] +
           hexTable[0x80 | (c & 0x3F)];
  return out;
var stringifyPrimitive = function(v) {
  if (typeof v === 'string')
    return v;
  if (typeof v === 'number' && isFinite(v))
    return '' + v;
  if (typeof v === 'boolean')
    return v ? 'true' : 'false';
  return '';
QueryString.stringify = QueryString.encode = function(obj, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var encode = QueryString.escape;
  if (options && typeof options.encodeURIComponent === 'function') {
    encode = options.encodeURIComponent;
  if (obj !== null && typeof obj === 'object') {
    var keys = Object.keys(obj);
    var len = keys.length;
    var flast = len - 1;
    var fields = '';
    for (var i = 0; i < len; ++i) {
      var k = keys[i];
      var v = obj[k];
      var ks = encode(stringifyPrimitive(k)) + eq;
      if (Array.isArray(v)) {
        var vlen = v.length;
        var vlast = vlen - 1;
        for (var j = 0; j < vlen; ++j) {
          fields += ks + encode(stringifyPrimitive(v[j]));
          if (j < vlast)
            fields += sep;
        }
        if (vlen && i < flast)
          fields += sep;
      } else {
        fields += ks + encode(stringifyPrimitive(v));
        if (i < flast)
          fields += sep;
      }
    }
    return fields;
  return '';
// Parse a key=val string.
QueryString.parse = QueryString.decode = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  const eqLen = eq.length;
  var obj = {};
  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  qs = qs.split(sep);
  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  var decode = QueryString.unescape;
  if (options && typeof options.decodeURIComponent === 'function') {
    decode = options.decodeURIComponent;
  var keys = [];
  for (var i = 0; i < len; ++i) {
    // replacePlus() is used instead of a regexp because it is ~15-30% faster
    // with v8 4.7
    const x = replacePlus(qs[i]);
    const idx = x.indexOf(eq);
    var k, v;
    if (idx >= 0) {
      k = decodeStr(x.substring(0, idx), decode);
      v = decodeStr(x.substring(idx + eqLen), decode);
    } else {
      k = decodeStr(x, decode);
      v = '';
    }
    // Use a key array lookup instead of using hasOwnProperty(), which is slower
    if (keys.indexOf(k) === -1) {
      obj[k] = v;
      keys.push(k);
    } else if (obj[k] instanceof Array) {
      // `instanceof Array` is used instead of Array.isArray() because it is
      // ~15-20% faster with v8 4.7 and is safe to use because we are using it
      // with values being created within this function
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  return obj;
function replacePlus(str) {
  var ret = '';
  var start = 0;
  var i = -1;
  while ((i = str.indexOf('+', i + 1)) !== -1) {
    ret += str.slice(start, i);
    ret += '%20';
    start = i + 1;
  if (start === 0)
    return str;
  if (start < str.length)
    ret += str.slice(start);
  return ret;
// v8 does not optimize functions with try-catch blocks, so we isolate them here
// to minimize the damage
function decodeStr(s, decoder) {
  try {
    return decoder(s);
  } catch (e) {
    return QueryString.unescape(s, true);
// Inspiration for this code comes from Salvatore Sanfilippo's linenoise.
// https://github.com/antirez/linenoise
// Reference:
// * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
// * http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html
'use strict';
const kHistorySize = 30;
const util = require('util');
const debug = util.debuglog('readline');
const internalUtil = require('internal/util');
const inherits = util.inherits;
const Buffer = require('buffer').Buffer;
const EventEmitter = require('events');
exports.createInterface = function(input, output, completer, terminal) {
  var rl;
  if (arguments.length === 1) {
    rl = new Interface(input);
  } else {
    rl = new Interface(input, output, completer, terminal);
  return rl;
function Interface(input, output, completer, terminal) {
  if (!(this instanceof Interface)) {
    // call the constructor preserving original number of arguments
    const self = Object.create(Interface.prototype);
    Interface.apply(self, arguments);
    return self;
  this._sawReturn = false;
  this.isCompletionEnabled = true;
  EventEmitter.call(this);
  var historySize;
  if (arguments.length === 1) {
    // an options object was given
    output = input.output;
    completer = input.completer;
    terminal = input.terminal;
    historySize = input.historySize;
    input = input.input;
  historySize = historySize || kHistorySize;
  if (completer && typeof completer !== 'function') {
    throw new TypeError('Argument \'completer\' must be a function');
  if (typeof historySize !== 'number' ||
      isNaN(historySize) ||
      historySize < 0) {
    throw new TypeError('Argument \'historySize\' must be a positive number');
  // backwards compat; check the isTTY prop of the output stream
  //  when `terminal` was not specified
  if (terminal === undefined && !(output === null || output === undefined)) {
    terminal = !!output.isTTY;
  var self = this;
  this.output = output;
  this.input = input;
  this.historySize = historySize;
  // Check arity, 2 - for async, 1 for sync
  if (typeof completer === 'function') {
    this.completer = completer.length === 2 ? completer : function(v, cb) {
      cb(null, completer(v));
    };
  this.setPrompt('> ');
  this.terminal = !!terminal;
  function ondata(data) {
    self._normalWrite(data);
  function onend() {
    if (typeof self._line_buffer === 'string' &&
        self._line_buffer.length > 0) {
      self.emit('line', self._line_buffer);
    }
    self.close();
  function ontermend() {
    if (typeof self.line === 'string' && self.line.length > 0) {
      self.emit('line', self.line);
    }
    self.close();
  function onkeypress(s, key) {
    self._ttyWrite(s, key);
  function onresize() {
    self._refreshLine();
  if (!this.terminal) {
    input.on('data', ondata);
    input.on('end', onend);
    self.once('close', function() {
      input.removeListener('data', ondata);
      input.removeListener('end', onend);
    });
    var StringDecoder = require('string_decoder').StringDecoder; // lazy load
    this._decoder = new StringDecoder('utf8');
  } else {
    exports.emitKeypressEvents(input, this);
    // input usually refers to stdin
    input.on('keypress', onkeypress);
    input.on('end', ontermend);
    // Current line
    this.line = '';
    this._setRawMode(true);
    this.terminal = true;
    // Cursor position on the line.
    this.cursor = 0;
    this.history = [];
    this.historyIndex = -1;
    if (output !== null && output !== undefined)
      output.on('resize', onresize);
    self.once('close', function() {
      input.removeListener('keypress', onkeypress);
      input.removeListener('end', ontermend);
      if (output !== null && output !== undefined) {
        output.removeListener('resize', onresize);
      }
    });
  input.resume();
inherits(Interface, EventEmitter);
Interface.prototype.__defineGetter__('columns', function() {
  var columns = Infinity;
  if (this.output && this.output.columns)
    columns = this.output.columns;
  return columns;
Interface.prototype.setPrompt = function(prompt) {
  this._prompt = prompt;
Interface.prototype._setRawMode = function(mode) {
  if (typeof this.input.setRawMode === 'function') {
    return this.input.setRawMode(mode);
Interface.prototype.prompt = function(preserveCursor) {
  if (this.paused) this.resume();
  if (this.terminal) {
    if (!preserveCursor) this.cursor = 0;
    this._refreshLine();
  } else {
    this._writeToOutput(this._prompt);
Interface.prototype.question = function(query, cb) {
  if (typeof cb === 'function') {
    if (this._questionCallback) {
      this.prompt();
    } else {
      this._oldPrompt = this._prompt;
      this.setPrompt(query);
      this._questionCallback = cb;
      this.prompt();
    }
Interface.prototype._onLine = function(line) {
  if (this._questionCallback) {
    var cb = this._questionCallback;
    this._questionCallback = null;
    this.setPrompt(this._oldPrompt);
    cb(line);
  } else {
    this.emit('line', line);
Interface.prototype._writeToOutput = function _writeToOutput(stringToWrite) {
  if (typeof stringToWrite !== 'string')
    throw new TypeError('stringToWrite must be a string');
  if (this.output !== null && this.output !== undefined)
    this.output.write(stringToWrite);
Interface.prototype._addHistory = function() {
  if (this.line.length === 0) return '';
  if (this.history.length === 0 || this.history[0] !== this.line) {
    this.history.unshift(this.line);
    // Only store so many
    if (this.history.length > this.historySize) this.history.pop();
  this.historyIndex = -1;
  return this.history[0];
Interface.prototype._refreshLine = function() {
  // line length
  var line = this._prompt + this.line;
  var dispPos = this._getDisplayPos(line);
  var lineCols = dispPos.cols;
  var lineRows = dispPos.rows;
  // cursor position
  var cursorPos = this._getCursorPos();
  // first move to the bottom of the current line, based on cursor pos
  var prevRows = this.prevRows || 0;
  if (prevRows > 0) {
    exports.moveCursor(this.output, 0, -prevRows);
  // Cursor to left edge.
  exports.cursorTo(this.output, 0);
  // erase data
  exports.clearScreenDown(this.output);
  // Write the prompt and the current buffer content.
  this._writeToOutput(line);
  // Force terminal to allocate a new line
  if (lineCols === 0) {
    this._writeToOutput(' ');
  // Move cursor to original position.
  exports.cursorTo(this.output, cursorPos.cols);
  var diff = lineRows - cursorPos.rows;
  if (diff > 0) {
    exports.moveCursor(this.output, 0, -diff);
  this.prevRows = cursorPos.rows;
Interface.prototype.close = function() {
  if (this.closed) return;
  this.pause();
  if (this.terminal) {
    this._setRawMode(false);
  this.closed = true;
  this.emit('close');
Interface.prototype.pause = function() {
  if (this.paused) return;
  this.input.pause();
  this.paused = true;
  this.emit('pause');
  return this;
Interface.prototype.resume = function() {
  if (!this.paused) return;
  this.input.resume();
  this.paused = false;
  this.emit('resume');
  return this;
Interface.prototype.write = function(d, key) {
  if (this.paused) this.resume();
  this.terminal ? this._ttyWrite(d, key) : this._normalWrite(d);
// \r\n, \n, or \r followed by something other than \n
const lineEnding = /\r?\n|\r(?!\n)/;
Interface.prototype._normalWrite = function(b) {
  if (b === undefined) {
    return;
  var string = this._decoder.write(b);
  if (this._sawReturn) {
    string = string.replace(/^\n/, '');
    this._sawReturn = false;
  // Run test() on the new string chunk, not on the entire line buffer.
  var newPartContainsEnding = lineEnding.test(string);
  if (this._line_buffer) {
    string = this._line_buffer + string;
    this._line_buffer = null;
  if (newPartContainsEnding) {
    this._sawReturn = string.endsWith('\r');
    // got one or more newlines; process into "line" events
    var lines = string.split(lineEnding);
    // either '' or (concievably) the unfinished portion of the next line
    string = lines.pop();
    this._line_buffer = string;
    lines.forEach(function(line) {
      this._onLine(line);
    }, this);
  } else if (string) {
    // no newlines this time, save what we have for next time
    this._line_buffer = string;
Interface.prototype._insertString = function(c) {
  if (this.cursor < this.line.length) {
    var beg = this.line.slice(0, this.cursor);
    var end = this.line.slice(this.cursor, this.line.length);
    this.line = beg + c + end;
    this.cursor += c.length;
    this._refreshLine();
  } else {
    this.line += c;
    this.cursor += c.length;
    if (this._getCursorPos().cols === 0) {
      this._refreshLine();
    } else {
      this._writeToOutput(c);
    }
    // a hack to get the line refreshed if it's needed
    this._moveCursor(0);
Interface.prototype._tabComplete = function() {
  var self = this;
  self.pause();
  self.completer(self.line.slice(0, self.cursor), function(err, rv) {
    self.resume();
    if (err) {
      debug('tab completion error %j', err);
      return;
    }
    const completions = rv[0];
    const completeOn = rv[1];  // the text that was completed
    if (completions && completions.length) {
      // Apply/show completions.
      if (completions.length === 1) {
        self._insertString(completions[0].slice(completeOn.length));
      } else {
        self._writeToOutput('\r\n');
        var width = completions.reduce(function(a, b) {
          return a.length > b.length ? a : b;
        }).length + 2;  // 2 space padding
        var maxColumns = Math.floor(self.columns / width);
        if (!maxColumns || maxColumns === Infinity) {
          maxColumns = 1;
        }
        var group = [], c;
        for (var i = 0, compLen = completions.length; i < compLen; i++) {
          c = completions[i];
          if (c === '') {
            handleGroup(self, group, width, maxColumns);
            group = [];
          } else {
            group.push(c);
          }
        }
        handleGroup(self, group, width, maxColumns);
        // If there is a common prefix to all matches, then apply that
        // portion.
        var f = completions.filter(function(e) { if (e) return e; });
        var prefix = commonPrefix(f);
        if (prefix.length > completeOn.length) {
          self._insertString(prefix.slice(completeOn.length));
        }
      }
      self._refreshLine();
    }
  });
// this = Interface instance
function handleGroup(self, group, width, maxColumns) {
  if (group.length == 0) {
    return;
  var minRows = Math.ceil(group.length / maxColumns);
  for (var row = 0; row < minRows; row++) {
    for (var col = 0; col < maxColumns; col++) {
      var idx = row * maxColumns + col;
      if (idx >= group.length) {
        break;
      }
      var item = group[idx];
      self._writeToOutput(item);
      if (col < maxColumns - 1) {
        for (var s = 0, itemLen = item.length; s < width - itemLen;
             s++) {
          self._writeToOutput(' ');
        }
      }
    }
    self._writeToOutput('\r\n');
  self._writeToOutput('\r\n');
function commonPrefix(strings) {
  if (!strings || strings.length == 0) {
    return '';
  var sorted = strings.slice().sort();
  var min = sorted[0];
  var max = sorted[sorted.length - 1];
  for (var i = 0, len = min.length; i < len; i++) {
    if (min[i] != max[i]) {
      return min.slice(0, i);
    }
  return min;
Interface.prototype._wordLeft = function() {
  if (this.cursor > 0) {
    var leading = this.line.slice(0, this.cursor);
    var match = leading.match(/([^\w\s]+|\w+|)\s*$/);
    this._moveCursor(-match[0].length);
Interface.prototype._wordRight = function() {
  if (this.cursor < this.line.length) {
    var trailing = this.line.slice(this.cursor);
    var match = trailing.match(/^(\s+|\W+|\w+)\s*/);
    this._moveCursor(match[0].length);
Interface.prototype._deleteLeft = function() {
  if (this.cursor > 0 && this.line.length > 0) {
    this.line = this.line.slice(0, this.cursor - 1) +
                this.line.slice(this.cursor, this.line.length);
    this.cursor--;
    this._refreshLine();
Interface.prototype._deleteRight = function() {
  this.line = this.line.slice(0, this.cursor) +
              this.line.slice(this.cursor + 1, this.line.length);
  this._refreshLine();
Interface.prototype._deleteWordLeft = function() {
  if (this.cursor > 0) {
    var leading = this.line.slice(0, this.cursor);
    var match = leading.match(/([^\w\s]+|\w+|)\s*$/);
    leading = leading.slice(0, leading.length - match[0].length);
    this.line = leading + this.line.slice(this.cursor, this.line.length);
    this.cursor = leading.length;
    this._refreshLine();
Interface.prototype._deleteWordRight = function() {
  if (this.cursor < this.line.length) {
    var trailing = this.line.slice(this.cursor);
    var match = trailing.match(/^(\s+|\W+|\w+)\s*/);
    this.line = this.line.slice(0, this.cursor) +
                trailing.slice(match[0].length);
    this._refreshLine();
Interface.prototype._deleteLineLeft = function() {
  this.line = this.line.slice(this.cursor);
  this.cursor = 0;
  this._refreshLine();
Interface.prototype._deleteLineRight = function() {
  this.line = this.line.slice(0, this.cursor);
  this._refreshLine();
Interface.prototype.clearLine = function() {
  this._moveCursor(+Infinity);
  this._writeToOutput('\r\n');
  this.line = '';
  this.cursor = 0;
  this.prevRows = 0;
Interface.prototype._line = function() {
  var line = this._addHistory();
  this.clearLine();
  this._onLine(line);
Interface.prototype._historyNext = function() {
  if (this.historyIndex > 0) {
    this.historyIndex--;
    this.line = this.history[this.historyIndex];
    this.cursor = this.line.length; // set cursor to end of line.
    this._refreshLine();
  } else if (this.historyIndex === 0) {
    this.historyIndex = -1;
    this.cursor = 0;
    this.line = '';
    this._refreshLine();
Interface.prototype._historyPrev = function() {
  if (this.historyIndex + 1 < this.history.length) {
    this.historyIndex++;
    this.line = this.history[this.historyIndex];
    this.cursor = this.line.length; // set cursor to end of line.
    this._refreshLine();
// Returns the last character's display position of the given string
Interface.prototype._getDisplayPos = function(str) {
  var offset = 0;
  var col = this.columns;
  var row = 0;
  var code;
  str = stripVTControlCharacters(str);
  for (var i = 0, len = str.length; i < len; i++) {
    code = str.codePointAt(i);
    if (code >= 0x10000) { // surrogates
      i++;
    }
    if (code === 0x0a) { // new line \n
      offset = 0;
      row += 1;
      continue;
    }
    if (isFullWidthCodePoint(code)) {
      if ((offset + 1) % col === 0) {
        offset++;
      }
      offset += 2;
    } else {
      offset++;
    }
  var cols = offset % col;
  var rows = row + (offset - cols) / col;
  return {cols: cols, rows: rows};
// Returns current cursor's position and line
Interface.prototype._getCursorPos = function() {
  var columns = this.columns;
  var strBeforeCursor = this._prompt + this.line.substring(0, this.cursor);
  var dispPos = this._getDisplayPos(stripVTControlCharacters(strBeforeCursor));
  var cols = dispPos.cols;
  var rows = dispPos.rows;
  // If the cursor is on a full-width character which steps over the line,
  // move the cursor to the beginning of the next line.
  if (cols + 1 === columns &&
      this.cursor < this.line.length &&
      isFullWidthCodePoint(this.line.codePointAt(this.cursor))) {
    rows++;
    cols = 0;
  return {cols: cols, rows: rows};
// This function moves cursor dx places to the right
// (-dx for left) and refreshes the line if it is needed
Interface.prototype._moveCursor = function(dx) {
  var oldcursor = this.cursor;
  var oldPos = this._getCursorPos();
  this.cursor += dx;
  // bounds check
  if (this.cursor < 0) this.cursor = 0;
  else if (this.cursor > this.line.length) this.cursor = this.line.length;
  var newPos = this._getCursorPos();
  // check if cursors are in the same line
  if (oldPos.rows === newPos.rows) {
    var diffCursor = this.cursor - oldcursor;
    var diffWidth;
    if (diffCursor < 0) {
      diffWidth = -getStringWidth(
          this.line.substring(this.cursor, oldcursor)
          );
    } else if (diffCursor > 0) {
      diffWidth = getStringWidth(
          this.line.substring(this.cursor, oldcursor)
          );
    }
    exports.moveCursor(this.output, diffWidth, 0);
    this.prevRows = newPos.rows;
  } else {
    this._refreshLine();
// handle a write from the tty
Interface.prototype._ttyWrite = function(s, key) {
  key = key || {};
  // Ignore escape key - Fixes #2876
  if (key.name == 'escape') return;
  if (key.ctrl && key.shift) {
    /* Control and shift pressed */
    switch (key.name) {
      case 'backspace':
        this._deleteLineLeft();
        break;
      case 'delete':
        this._deleteLineRight();
        break;
    }
  } else if (key.ctrl) {
    /* Control key pressed */
    switch (key.name) {
      case 'c':
        if (this.listenerCount('SIGINT') > 0) {
          this.emit('SIGINT');
        } else {
          // This readline instance is finished
          this.close();
        }
        break;
      case 'h': // delete left
        this._deleteLeft();
        break;
      case 'd': // delete right or EOF
        if (this.cursor === 0 && this.line.length === 0) {
          // This readline instance is finished
          this.close();
        } else if (this.cursor < this.line.length) {
          this._deleteRight();
        }
        break;
      case 'u': // delete the whole line
        this.cursor = 0;
        this.line = '';
        this._refreshLine();
        break;
      case 'k': // delete from current to end of line
        this._deleteLineRight();
        break;
      case 'a': // go to the start of the line
        this._moveCursor(-Infinity);
        break;
      case 'e': // go to the end of the line
        this._moveCursor(+Infinity);
        break;
      case 'b': // back one character
        this._moveCursor(-1);
        break;
      case 'f': // forward one character
        this._moveCursor(+1);
        break;
      case 'l': // clear the whole screen
        exports.cursorTo(this.output, 0, 0);
        exports.clearScreenDown(this.output);
        this._refreshLine();
        break;
      case 'n': // next history item
        this._historyNext();
        break;
      case 'p': // previous history item
        this._historyPrev();
        break;
      case 'z':
        if (process.platform == 'win32') break;
        if (this.listenerCount('SIGTSTP') > 0) {
          this.emit('SIGTSTP');
        } else {
          process.once('SIGCONT', (function(self) {
            return function() {
              // Don't raise events if stream has already been abandoned.
              if (!self.paused) {
                // Stream must be paused and resumed after SIGCONT to catch
                // SIGINT, SIGTSTP, and EOF.
                self.pause();
                self.emit('SIGCONT');
              }
              // explicitly re-enable "raw mode" and move the cursor to
              // the correct position.
              // See https://github.com/joyent/node/issues/3295.
              self._setRawMode(true);
              self._refreshLine();
            };
          })(this));
          this._setRawMode(false);
          process.kill(process.pid, 'SIGTSTP');
        }
        break;
      case 'w': // delete backwards to a word boundary
      case 'backspace':
        this._deleteWordLeft();
        break;
      case 'delete': // delete forward to a word boundary
        this._deleteWordRight();
        break;
      case 'left':
        this._wordLeft();
        break;
      case 'right':
        this._wordRight();
        break;
    }
  } else if (key.meta) {
    /* Meta key pressed */
    switch (key.name) {
      case 'b': // backward word
        this._wordLeft();
        break;
      case 'f': // forward word
        this._wordRight();
        break;
      case 'd': // delete forward word
      case 'delete':
        this._deleteWordRight();
        break;
      case 'backspace': // delete backwards to a word boundary
        this._deleteWordLeft();
        break;
    }
  } else {
    /* No modifier keys used */
    // \r bookkeeping is only relevant if a \n comes right after.
    if (this._sawReturn && key.name !== 'enter')
      this._sawReturn = false;
    switch (key.name) {
      case 'return':  // carriage return, i.e. \r
        this._sawReturn = true;
        this._line();
        break;
      case 'enter':
        if (this._sawReturn)
          this._sawReturn = false;
        else
          this._line();
        break;
      case 'backspace':
        this._deleteLeft();
        break;
      case 'delete':
        this._deleteRight();
        break;
      case 'left':
        this._moveCursor(-1);
        break;
      case 'right':
        this._moveCursor(+1);
        break;
      case 'home':
        this._moveCursor(-Infinity);
        break;
      case 'end':
        this._moveCursor(+Infinity);
        break;
      case 'up':
        this._historyPrev();
        break;
      case 'down':
        this._historyNext();
        break;
      case 'tab':
        // If tab completion enabled, do that...
        if (typeof this.completer === 'function' && this.isCompletionEnabled) {
          this._tabComplete();
          break;
        }
        // falls through
      default:
        if (s instanceof Buffer)
          s = s.toString('utf-8');
        if (s) {
          var lines = s.split(/\r\n|\n|\r/);
          for (var i = 0, len = lines.length; i < len; i++) {
            if (i > 0) {
              this._line();
            }
            this._insertString(lines[i]);
          }
        }
    }
exports.Interface = Interface;
 * accepts a readable Stream instance and makes it emit "keypress" events
const KEYPRESS_DECODER = Symbol('keypress-decoder');
const ESCAPE_DECODER = Symbol('escape-decoder');
function emitKeypressEvents(stream, iface) {
  if (stream[KEYPRESS_DECODER]) return;
  var StringDecoder = require('string_decoder').StringDecoder; // lazy load
  stream[KEYPRESS_DECODER] = new StringDecoder('utf8');
  stream[ESCAPE_DECODER] = emitKeys(stream);
  stream[ESCAPE_DECODER].next();
  function onData(b) {
    if (stream.listenerCount('keypress') > 0) {
      var r = stream[KEYPRESS_DECODER].write(b);
      if (r) {
        for (var i = 0; i < r.length; i++) {
          if (r[i] === '\t' && typeof r[i + 1] === 'string' && iface) {
            iface.isCompletionEnabled = false;
          }
          try {
            stream[ESCAPE_DECODER].next(r[i]);
          } catch (err) {
            // if the generator throws (it could happen in the `keypress`
            // event), we need to restart it.
            stream[ESCAPE_DECODER] = emitKeys(stream);
            stream[ESCAPE_DECODER].next();
            throw err;
          } finally {
            if (iface) {
              iface.isCompletionEnabled = true;
            }
          }
        }
      }
    } else {
      // Nobody's watching anyway
      stream.removeListener('data', onData);
      stream.on('newListener', onNewListener);
    }
  function onNewListener(event) {
    if (event == 'keypress') {
      stream.on('data', onData);
      stream.removeListener('newListener', onNewListener);
    }
  if (stream.listenerCount('keypress') > 0) {
    stream.on('data', onData);
  } else {
    stream.on('newListener', onNewListener);
exports.emitKeypressEvents = emitKeypressEvents;
  Some patterns seen in terminal key escape codes, derived from combos seen
  at http://www.midnight-commander.org/browser/lib/tty/key.c
  ESC letter
  ESC [ letter
  ESC [ modifier letter
  ESC [ 1 ; modifier letter
  ESC [ num char
  ESC [ num ; modifier char
  ESC O letter
  ESC O modifier letter
  ESC O 1 ; modifier letter
  ESC N letter
  ESC [ [ num ; modifier char
  ESC [ [ 1 ; modifier letter
  ESC ESC [ num char
  ESC ESC O letter
  - char is usually ~ but $ and ^ also happen with rxvt
  - modifier is 1 +
                (shift     * 1) +
                (left_alt  * 2) +
                (ctrl      * 4) +
                (right_alt * 8)
  - two leading ESCs apparently mean the same as one leading ESC
// Regexes used for ansi escape code splitting
// eslint-disable-next-line no-control-regex
const metaKeyCodeReAnywhere = /(?:\x1b)([a-zA-Z0-9])/;
const functionKeyCodeReAnywhere = new RegExp('(?:\x1b+)(O|N|\\[|\\[\\[)(?:' + [
  '(\\d+)(?:;(\\d+))?([~^$])',
  '(?:M([@ #!a`])(.)(.))', // mouse
  '(?:1;)?(\\d+)?([a-zA-Z])'
].join('|') + ')');
function* emitKeys(stream) {
  while (true) {
    var ch = yield;
    var s = ch;
    var escaped = false;
    var key = {
      sequence: null,
      name: undefined,
      ctrl: false,
      meta: false,
      shift: false
    };
    if (ch === '\x1b') {
      escaped = true;
      s += (ch = yield);
      if (ch === '\x1b') {
        s += (ch = yield);
      }
    }
    if (escaped && (ch === 'O' || ch === '[')) {
      // ansi escape sequence
      var code = ch;
      var modifier = 0;
      if (ch === 'O') {
        // ESC O letter
        // ESC O modifier letter
        s += (ch = yield);
        if (ch >= '0' && ch <= '9') {
          modifier = (ch >> 0) - 1;
          s += (ch = yield);
        }
        code += ch;
      } else if (ch === '[') {
        // ESC [ letter
        // ESC [ modifier letter
        // ESC [ [ modifier letter
        // ESC [ [ num char
        s += (ch = yield);
        if (ch === '[') {
          // \x1b[[A
          //      ^--- escape codes might have a second bracket
          code += ch;
          s += (ch = yield);
        }
        /*
         * Here and later we try to buffer just enough data to get
         * a complete ascii sequence.
         *
         * We have basically two classes of ascii characters to process:
         *
         *
         * 1. `\x1b[24;5~` should be parsed as { code: '[24~', modifier: 5 }
         *
         * This particular example is featuring Ctrl+F12 in xterm.
         *
         *  - `;5` part is optional, e.g. it could be `\x1b[24~`
         *  - first part can contain one or two digits
         *
         * So the generic regexp is like /^\d\d?(;\d)?[~^$]$/
         *
         *
         * 2. `\x1b[1;5H` should be parsed as { code: '[H', modifier: 5 }
         *
         * This particular example is featuring Ctrl+Home in xterm.
         *
         *  - `1;5` part is optional, e.g. it could be `\x1b[H`
         *  - `1;` part is optional, e.g. it could be `\x1b[5H`
         *
         * So the generic regexp is like /^((\d;)?\d)?[A-Za-z]$/
         *
         */
        const cmdStart = s.length - 1;
        // skip one or two leading digits
        if (ch >= '0' && ch <= '9') {
          s += (ch = yield);
          if (ch >= '0' && ch <= '9') {
            s += (ch = yield);
          }
        }
        // skip modifier
        if (ch === ';') {
          s += (ch = yield);
          if (ch >= '0' && ch <= '9') {
            s += (ch = yield);
          }
        }
        /*
         * We buffered enough data, now trying to extract code
         * and modifier from it
         */
        const cmd = s.slice(cmdStart);
        var match;
        if ((match = cmd.match(/^(\d\d?)(;(\d))?([~^$])$/))) {
          code += match[1] + match[4];
          modifier = (match[3] || 1) - 1;
        } else if ((match = cmd.match(/^((\d;)?(\d))?([A-Za-z])$/))) {
          code += match[4];
          modifier = (match[3] || 1) - 1;
        } else {
          code += cmd;
        }
      }
      // Parse the key modifier
      key.ctrl = !!(modifier & 4);
      key.meta = !!(modifier & 10);
      key.shift = !!(modifier & 1);
      key.code = code;
      // Parse the key itself
      switch (code) {
        /* xterm/gnome ESC O letter */
        case 'OP': key.name = 'f1'; break;
        case 'OQ': key.name = 'f2'; break;
        case 'OR': key.name = 'f3'; break;
        case 'OS': key.name = 'f4'; break;
        /* xterm/rxvt ESC [ number ~ */
        case '[11~': key.name = 'f1'; break;
        case '[12~': key.name = 'f2'; break;
        case '[13~': key.name = 'f3'; break;
        case '[14~': key.name = 'f4'; break;
        /* from Cygwin and used in libuv */
        case '[[A': key.name = 'f1'; break;
        case '[[B': key.name = 'f2'; break;
        case '[[C': key.name = 'f3'; break;
        case '[[D': key.name = 'f4'; break;
        case '[[E': key.name = 'f5'; break;
        /* common */
        case '[15~': key.name = 'f5'; break;
        case '[17~': key.name = 'f6'; break;
        case '[18~': key.name = 'f7'; break;
        case '[19~': key.name = 'f8'; break;
        case '[20~': key.name = 'f9'; break;
        case '[21~': key.name = 'f10'; break;
        case '[23~': key.name = 'f11'; break;
        case '[24~': key.name = 'f12'; break;
        /* xterm ESC [ letter */
        case '[A': key.name = 'up'; break;
        case '[B': key.name = 'down'; break;
        case '[C': key.name = 'right'; break;
        case '[D': key.name = 'left'; break;
        case '[E': key.name = 'clear'; break;
        case '[F': key.name = 'end'; break;
        case '[H': key.name = 'home'; break;
        /* xterm/gnome ESC O letter */
        case 'OA': key.name = 'up'; break;
        case 'OB': key.name = 'down'; break;
        case 'OC': key.name = 'right'; break;
        case 'OD': key.name = 'left'; break;
        case 'OE': key.name = 'clear'; break;
        case 'OF': key.name = 'end'; break;
        case 'OH': key.name = 'home'; break;
        /* xterm/rxvt ESC [ number ~ */
        case '[1~': key.name = 'home'; break;
        case '[2~': key.name = 'insert'; break;
        case '[3~': key.name = 'delete'; break;
        case '[4~': key.name = 'end'; break;
        case '[5~': key.name = 'pageup'; break;
        case '[6~': key.name = 'pagedown'; break;
        /* putty */
        case '[[5~': key.name = 'pageup'; break;
        case '[[6~': key.name = 'pagedown'; break;
        /* rxvt */
        case '[7~': key.name = 'home'; break;
        case '[8~': key.name = 'end'; break;
        /* rxvt keys with modifiers */
        case '[a': key.name = 'up'; key.shift = true; break;
        case '[b': key.name = 'down'; key.shift = true; break;
        case '[c': key.name = 'right'; key.shift = true; break;
        case '[d': key.name = 'left'; key.shift = true; break;
        case '[e': key.name = 'clear'; key.shift = true; break;
        case '[2$': key.name = 'insert'; key.shift = true; break;
        case '[3$': key.name = 'delete'; key.shift = true; break;
        case '[5$': key.name = 'pageup'; key.shift = true; break;
        case '[6$': key.name = 'pagedown'; key.shift = true; break;
        case '[7$': key.name = 'home'; key.shift = true; break;
        case '[8$': key.name = 'end'; key.shift = true; break;
        case 'Oa': key.name = 'up'; key.ctrl = true; break;
        case 'Ob': key.name = 'down'; key.ctrl = true; break;
        case 'Oc': key.name = 'right'; key.ctrl = true; break;
        case 'Od': key.name = 'left'; key.ctrl = true; break;
        case 'Oe': key.name = 'clear'; key.ctrl = true; break;
        case '[2^': key.name = 'insert'; key.ctrl = true; break;
        case '[3^': key.name = 'delete'; key.ctrl = true; break;
        case '[5^': key.name = 'pageup'; key.ctrl = true; break;
        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;
        case '[7^': key.name = 'home'; key.ctrl = true; break;
        case '[8^': key.name = 'end'; key.ctrl = true; break;
        /* misc. */
        case '[Z': key.name = 'tab'; key.shift = true; break;
        default: key.name = 'undefined'; break;
      }
    } else if (ch === '\r') {
      // carriage return
      key.name = 'return';
    } else if (ch === '\n') {
      // enter, should have been called linefeed
      key.name = 'enter';
    } else if (ch === '\t') {
      // tab
      key.name = 'tab';
    } else if (ch === '\b' || ch === '\x7f') {
      // backspace or ctrl+h
      key.name = 'backspace';
      key.meta = escaped;
    } else if (ch === '\x1b') {
      // escape key
      key.name = 'escape';
      key.meta = escaped;
    } else if (ch === ' ') {
      key.name = 'space';
      key.meta = escaped;
    } else if (!escaped && ch <= '\x1a') {
      // ctrl+letter
      key.name = String.fromCharCode(ch.charCodeAt(0) + 'a'.charCodeAt(0) - 1);
      key.ctrl = true;
    } else if (/^[0-9A-Za-z]$/.test(ch)) {
      // letter, number, shift+letter
      key.name = ch.toLowerCase();
      key.shift = /^[A-Z]$/.test(ch);
      key.meta = escaped;
    }
    key.sequence = s;
    if (key.name !== undefined) {
      /* Named character or sequence */
      stream.emit('keypress', escaped ? undefined : s, key);
    } else if (s.length === 1) {
      /* Single unnamed character, e.g. "." */
      stream.emit('keypress', s);
    } else {
      /* Unrecognized or broken escape sequence, don't emit anything */
    }
 * moves the cursor to the x and y coordinate on the given stream
function cursorTo(stream, x, y) {
  if (stream === null || stream === undefined)
    return;
  if (typeof x !== 'number' && typeof y !== 'number')
    return;
  if (typeof x !== 'number')
    throw new Error("Can't set cursor row without also setting it's column");
  if (typeof y !== 'number') {
    stream.write('\x1b[' + (x + 1) + 'G');
  } else {
    stream.write('\x1b[' + (y + 1) + ';' + (x + 1) + 'H');
exports.cursorTo = cursorTo;
 * moves the cursor relative to its current location
function moveCursor(stream, dx, dy) {
  if (stream === null || stream === undefined)
    return;
  if (dx < 0) {
    stream.write('\x1b[' + (-dx) + 'D');
  } else if (dx > 0) {
    stream.write('\x1b[' + dx + 'C');
  if (dy < 0) {
    stream.write('\x1b[' + (-dy) + 'A');
  } else if (dy > 0) {
    stream.write('\x1b[' + dy + 'B');
exports.moveCursor = moveCursor;
 * clears the current line the cursor is on:
 *   -1 for left of the cursor
 *   +1 for right of the cursor
 *    0 for the entire line
function clearLine(stream, dir) {
  if (stream === null || stream === undefined)
    return;
  if (dir < 0) {
    // to the beginning
    stream.write('\x1b[1K');
  } else if (dir > 0) {
    // to the end
    stream.write('\x1b[0K');
  } else {
    // entire line
    stream.write('\x1b[2K');
exports.clearLine = clearLine;
 * clears the screen from the current position of the cursor down
function clearScreenDown(stream) {
  if (stream === null || stream === undefined)
    return;
  stream.write('\x1b[0J');
exports.clearScreenDown = clearScreenDown;
 * Returns the number of columns required to display the given string.
function getStringWidth(str) {
  var width = 0;
  str = stripVTControlCharacters(str);
  for (var i = 0, len = str.length; i < len; i++) {
    var code = str.codePointAt(i);
    if (code >= 0x10000) { // surrogates
      i++;
    }
    if (isFullWidthCodePoint(code)) {
      width += 2;
    } else {
      width++;
    }
  return width;
exports.getStringWidth = getStringWidth;
 * Returns true if the character represented by a given
 * Unicode code point is full-width. Otherwise returns false.
function isFullWidthCodePoint(code) {
  if (isNaN(code)) {
    return false;
  // Code points are derived from:
  // http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt
  if (code >= 0x1100 && (
      code <= 0x115f ||  // Hangul Jamo
      0x2329 === code || // LEFT-POINTING ANGLE BRACKET
      0x232a === code || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      (0x2e80 <= code && code <= 0x3247 && code !== 0x303f) ||
      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      0x3250 <= code && code <= 0x4dbf ||
      // CJK Unified Ideographs .. Yi Radicals
      0x4e00 <= code && code <= 0xa4c6 ||
      // Hangul Jamo Extended-A
      0xa960 <= code && code <= 0xa97c ||
      // Hangul Syllables
      0xac00 <= code && code <= 0xd7a3 ||
      // CJK Compatibility Ideographs
      0xf900 <= code && code <= 0xfaff ||
      // Vertical Forms
      0xfe10 <= code && code <= 0xfe19 ||
      // CJK Compatibility Forms .. Small Form Variants
      0xfe30 <= code && code <= 0xfe6b ||
      // Halfwidth and Fullwidth Forms
      0xff01 <= code && code <= 0xff60 ||
      0xffe0 <= code && code <= 0xffe6 ||
      // Kana Supplement
      0x1b000 <= code && code <= 0x1b001 ||
      // Enclosed Ideographic Supplement
      0x1f200 <= code && code <= 0x1f251 ||
      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      0x20000 <= code && code <= 0x3fffd)) {
    return true;
  return false;
exports.isFullWidthCodePoint = isFullWidthCodePoint;
 * Returns the Unicode code point for the character at the
 * given index in the given string. Similar to String.charCodeAt(),
 * but this function handles surrogates (code point >= 0x10000).
function codePointAt(str, index) {
  var code = str.charCodeAt(index);
  var low;
  if (0xd800 <= code && code <= 0xdbff) { // High surrogate
    low = str.charCodeAt(index + 1);
    if (!isNaN(low)) {
      code = 0x10000 + (code - 0xd800) * 0x400 + (low - 0xdc00);
    }
  return code;
exports.codePointAt = internalUtil.deprecate(codePointAt,
    'readline.codePointAt is deprecated. ' +
    'Use String.prototype.codePointAt instead.');
 * Tries to remove all VT control characters. Use to estimate displayed
 * string width. May be buggy due to not running a real state machine
function stripVTControlCharacters(str) {
  str = str.replace(new RegExp(functionKeyCodeReAnywhere.source, 'g'), '');
  return str.replace(new RegExp(metaKeyCodeReAnywhere.source, 'g'), '');
exports.stripVTControlCharacters = stripVTControlCharacters;
/* A repl library that you can include in your own code to get a runtime
 * interface to your program.
 *   var repl = require("repl");
 *   // start repl on stdin
 *   repl.start("prompt> ");
 *   // listen for unix socket connections and start repl on them
 *   net.createServer(function(socket) {
 *     repl.start("node via Unix socket> ", socket);
 *   }).listen("/tmp/node-repl-sock");
 *   // listen for TCP socket connections and start repl on them
 *   net.createServer(function(socket) {
 *     repl.start("node via TCP socket> ", socket);
 *   }).listen(5001);
 *   // expose foo to repl context
 *   repl.start("node > ").context.foo = "stdin is fun";
'use strict';
const internalModule = require('internal/module');
const internalUtil = require('internal/util');
const util = require('util');
const inherits = util.inherits;
const Stream = require('stream');
const vm = require('vm');
const path = require('path');
const fs = require('fs');
const rl = require('readline');
const Console = require('console').Console;
const Module = require('module');
const domain = require('domain');
const debug = util.debuglog('repl');
const parentModule = module;
const replMap = new WeakMap();
try {
  // hack for require.resolve("./relative") to work properly.
  module.filename = path.resolve('repl');
} catch (e) {
  // path.resolve('repl') fails when the current working directory has been
  // deleted.  Fall back to the directory name of the (absolute) executable
  // path.  It's not really correct but what are the alternatives?
  const dirname = path.dirname(process.execPath);
  module.filename = path.resolve(dirname, 'repl');
// hack for repl require to work properly with node_modules folders
module.paths = require('module')._nodeModulePaths(module.filename);
// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
// Can overridden with custom print functions, such as `probe` or `eyes.js`.
// This is the default "writer" value if none is passed in the REPL options.
exports.writer = util.inspect;
exports._builtinLibs = ['assert', 'buffer', 'child_process', 'cluster',
  'crypto', 'dgram', 'dns', 'domain', 'events', 'fs', 'http', 'https', 'net',
  'os', 'path', 'punycode', 'querystring', 'readline', 'stream',
  'string_decoder', 'tls', 'tty', 'url', 'util', 'v8', 'vm', 'zlib'];
const BLOCK_SCOPED_ERROR = 'Block-scoped declarations (let, const, function, ' +
                           'class) not yet supported outside strict mode';
class LineParser {
  constructor() {
    this.reset();
  reset() {
    this._literal = null;
    this.shouldFail = false;
    this.blockComment = false;
    this.regExpLiteral = false;
  parseLine(line) {
    var previous = null;
    this.shouldFail = false;
    const wasWithinStrLiteral = this._literal !== null;
    for (const current of line) {
      if (previous === '\\') {
        // valid escaping, skip processing. previous doesn't matter anymore
        previous = null;
        continue;
      }
      if (!this._literal) {
        if (this.regExpLiteral && current === '/') {
          this.regExpLiteral = false;
          previous = null;
          continue;
        }
        if (previous === '*' && current === '/') {
          if (this.blockComment) {
            this.blockComment = false;
            previous = null;
            continue;
          } else {
            this.shouldFail = true;
            break;
          }
        }
        // ignore rest of the line if `current` and `previous` are `/`s
        if (previous === current && previous === '/' && !this.blockComment) {
          break;
        }
        if (previous === '/') {
          if (current === '*') {
            this.blockComment = true;
          } else {
            this.regExpLiteral = true;
          }
          previous = null;
        }
      }
      if (this.blockComment || this.regExpLiteral) continue;
      if (current === this._literal) {
        this._literal = null;
      } else if (current === '\'' || current === '"') {
        this._literal = this._literal || current;
      }
      previous = current;
    }
    const isWithinStrLiteral = this._literal !== null;
    if (!wasWithinStrLiteral && !isWithinStrLiteral) {
      // Current line has nothing to do with String literals, trim both ends
      line = line.trim();
    } else if (wasWithinStrLiteral && !isWithinStrLiteral) {
      // was part of a string literal, but it is over now, trim only the end
      line = line.trimRight();
    } else if (isWithinStrLiteral && !wasWithinStrLiteral) {
      // was not part of a string literal, but it is now, trim only the start
      line = line.trimLeft();
    }
    const lastChar = line.charAt(line.length - 1);
    this.shouldFail = this.shouldFail ||
                      ((!this._literal && lastChar === '\\') ||
                      (this._literal   && lastChar !== '\\'));
    return line;
function REPLServer(prompt,
                    stream,
                    eval_,
                    useGlobal,
                    ignoreUndefined,
                    replMode) {
  if (!(this instanceof REPLServer)) {
    return new REPLServer(prompt,
                          stream,
                          eval_,
                          useGlobal,
                          ignoreUndefined,
                          replMode);
  var options, input, output, dom;
  if (prompt !== null && typeof prompt === 'object') {
    // an options object was given
    options = prompt;
    stream = options.stream || options.socket;
    input = options.input;
    output = options.output;
    eval_ = options.eval;
    useGlobal = options.useGlobal;
    ignoreUndefined = options.ignoreUndefined;
    prompt = options.prompt;
    dom = options.domain;
    replMode = options.replMode;
  } else if (typeof prompt !== 'string') {
    throw new Error('An options Object, or a prompt String are required');
  } else {
    options = {};
  var self = this;
  self._domain = dom || domain.create();
  self.useGlobal = !!useGlobal;
  self.ignoreUndefined = !!ignoreUndefined;
  self.replMode = replMode || exports.REPL_MODE_SLOPPY;
  self._inTemplateLiteral = false;
  // just for backwards compat, see github.com/joyent/node/pull/7127
  self.rli = this;
  const savedRegExMatches = ['', '', '', '', '', '', '', '', '', ''];
  const sep = '\u0000\u0000\u0000';
  const regExMatcher = new RegExp(`^${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)` +
                                  `${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)` +
                                  `${sep}(.*)$`);
  eval_ = eval_ || defaultEval;
  function defaultEval(code, context, file, cb) {
    var err, result, retry = false;
    // first, create the Script object to check the syntax
    while (true) {
      try {
        if (!/^\s*$/.test(code) &&
            (self.replMode === exports.REPL_MODE_STRICT || retry)) {
          // "void 0" keeps the repl from returning "use strict" as the
          // result value for let/const statements.
          code = `'use strict'; void 0;\n${code}`;
        }
        var script = vm.createScript(code, {
          filename: file,
          displayErrors: false
        });
      } catch (e) {
        debug('parse error %j', code, e);
        if (self.replMode === exports.REPL_MODE_MAGIC &&
            e.message === BLOCK_SCOPED_ERROR &&
            !retry) {
          retry = true;
          continue;
        }
        if (isRecoverableError(e, self))
          err = new Recoverable(e);
        else
          err = e;
      }
      break;
    }
    // This will set the values from `savedRegExMatches` to corresponding
    // predefined RegExp properties `RegExp.$1`, `RegExp.$2` ... `RegExp.$9`
    regExMatcher.test(savedRegExMatches.join(sep));
    if (!err) {
      try {
        if (self.useGlobal) {
          result = script.runInThisContext({ displayErrors: false });
        } else {
          result = script.runInContext(context, { displayErrors: false });
        }
      } catch (e) {
        err = e;
        if (err && process.domain) {
          debug('not recoverable, send to domain');
          process.domain.emit('error', err);
          process.domain.exit();
          return;
        }
      }
    }
    // After executing the current expression, store the values of RegExp
    // predefined properties back in `savedRegExMatches`
    for (let idx = 1; idx < savedRegExMatches.length; idx += 1) {
      savedRegExMatches[idx] = RegExp[`$${idx}`];
    }
    cb(err, result);
  self.eval = self._domain.bind(eval_);
  self._domain.on('error', function(e) {
    debug('domain error');
    const top = replMap.get(self);
    internalUtil.decorateErrorStack(e);
    if (e.stack && self.replMode === exports.REPL_MODE_STRICT) {
      e.stack = e.stack.replace(/(\s+at\s+repl:)(\d+)/,
                                (_, pre, line) => pre + (line - 1));
    }
    top.outputStream.write((e.stack || e) + '\n');
    top.lineParser.reset();
    top.bufferedCommand = '';
    top.lines.level = [];
    top.displayPrompt();
  });
  if (!input && !output) {
    // legacy API, passing a 'stream'/'socket' option
    if (!stream) {
      // use stdin and stdout as the default streams if none were given
      stream = process;
    }
    if (stream.stdin && stream.stdout) {
      // We're given custom object with 2 streams, or the `process` object
      input = stream.stdin;
      output = stream.stdout;
    } else {
      // We're given a duplex readable/writable Stream, like a `net.Socket`
      input = stream;
      output = stream;
    }
  self.inputStream = input;
  self.outputStream = output;
  self.resetContext();
  self.lineParser = new LineParser();
  self.bufferedCommand = '';
  self.lines.level = [];
  function complete(text, callback) {
    self.complete(text, callback);
  rl.Interface.call(this, {
    input: self.inputStream,
    output: self.outputStream,
    completer: complete,
    terminal: options.terminal,
    historySize: options.historySize
  });
  self.setPrompt(prompt !== undefined ? prompt : '> ');
  this.commands = Object.create(null);
  defineDefaultCommands(this);
  // figure out which "writer" function to use
  self.writer = options.writer || exports.writer;
  if (options.useColors === undefined) {
    options.useColors = self.terminal;
  self.useColors = !!options.useColors;
  if (self.useColors && self.writer === util.inspect) {
    // Turn on ANSI coloring.
    self.writer = function(obj, showHidden, depth) {
      return util.inspect(obj, showHidden, depth, true);
    };
  self.setPrompt(self._prompt);
  self.on('close', function() {
    self.emit('exit');
  });
  var sawSIGINT = false;
  self.on('SIGINT', function() {
    var empty = self.line.length === 0;
    self.clearLine();
    if (!(self.bufferedCommand && self.bufferedCommand.length > 0) && empty) {
      if (sawSIGINT) {
        self.close();
        sawSIGINT = false;
        return;
      }
      self.output.write('(To exit, press ^C again or type .exit)\n');
      sawSIGINT = true;
    } else {
      sawSIGINT = false;
    }
    self.lineParser.reset();
    self.bufferedCommand = '';
    self.lines.level = [];
    self.displayPrompt();
  });
  self.on('line', function(cmd) {
    debug('line %j', cmd);
    sawSIGINT = false;
    var skipCatchall = false;
    // leading whitespaces in template literals should not be trimmed.
    if (self._inTemplateLiteral) {
      self._inTemplateLiteral = false;
    } else {
      cmd = self.lineParser.parseLine(cmd);
    }
    // Check to see if a REPL keyword was used. If it returns true,
    // display next prompt and return.
    if (cmd && cmd.charAt(0) === '.' && isNaN(parseFloat(cmd))) {
      var matches = cmd.match(/^\.([^\s]+)\s*(.*)$/);
      var keyword = matches && matches[1];
      var rest = matches && matches[2];
      if (self.parseREPLKeyword(keyword, rest) === true) {
        return;
      } else {
        self.outputStream.write('Invalid REPL keyword\n');
        skipCatchall = true;
      }
    }
    if (!skipCatchall && (cmd || (!cmd && self.bufferedCommand))) {
      var evalCmd = self.bufferedCommand + cmd;
      if (/^\s*\{/.test(evalCmd) && /\}\s*$/.test(evalCmd)) {
        // It's confusing for `{ a : 1 }` to be interpreted as a block
        // statement rather than an object literal.  So, we first try
        // to wrap it in parentheses, so that it will be interpreted as
        // an expression.
        evalCmd = '(' + evalCmd + ')\n';
      } else {
        // otherwise we just append a \n so that it will be either
        // terminated, or continued onto the next expression if it's an
        // unexpected end of input.
        evalCmd = evalCmd + '\n';
      }
      debug('eval %j', evalCmd);
      self.eval(evalCmd, self.context, 'repl', finish);
    } else {
      finish(null);
    }
    function finish(e, ret) {
      debug('finish', e, ret);
      self.memory(cmd);
      if (e && !self.bufferedCommand && cmd.trim().startsWith('npm ')) {
        self.outputStream.write('npm should be run outside of the ' +
                                'node repl, in your normal shell.\n' +
                                '(Press Control-D to exit.)\n');
        self.lineParser.reset();
        self.bufferedCommand = '';
        self.displayPrompt();
        return;
      }
      // If error was SyntaxError and not JSON.parse error
      if (e) {
        if (e instanceof Recoverable && !self.lineParser.shouldFail) {
          // Start buffering data like that:
          // {
          // ...  x: 1
          // ... }
          self.bufferedCommand += cmd + '\n';
          self.displayPrompt();
          return;
        } else {
          self._domain.emit('error', e.err || e);
        }
      }
      // Clear buffer if no SyntaxErrors
      self.lineParser.reset();
      self.bufferedCommand = '';
      // If we got any output - print it (if no error)
      if (!e &&
          // When an invalid REPL command is used, error message is printed
          // immediately. We don't have to print anything else. So, only when
          // the second argument to this function is there, print it.
          arguments.length === 2 &&
          (!self.ignoreUndefined || ret !== undefined)) {
        self.context._ = ret;
        self.outputStream.write(self.writer(ret) + '\n');
      }
      // Display prompt again
      self.displayPrompt();
    }
  });
  self.on('SIGCONT', function() {
    self.displayPrompt(true);
  });
  self.displayPrompt();
inherits(REPLServer, rl.Interface);
exports.REPLServer = REPLServer;
exports.REPL_MODE_SLOPPY = Symbol('repl-sloppy');
exports.REPL_MODE_STRICT = Symbol('repl-strict');
exports.REPL_MODE_MAGIC = Symbol('repl-magic');
// prompt is a string to print on each line for the prompt,
// source is a stream to use for I/O, defaulting to stdin/stdout.
exports.start = function(prompt,
                         source,
                         eval_,
                         useGlobal,
                         ignoreUndefined,
                         replMode) {
  var repl = new REPLServer(prompt,
                            source,
                            eval_,
                            useGlobal,
                            ignoreUndefined,
                            replMode);
  if (!exports.repl) exports.repl = repl;
  replMap.set(repl, repl);
  return repl;
REPLServer.prototype.createContext = function() {
  var context;
  if (this.useGlobal) {
    context = global;
  } else {
    context = vm.createContext();
    for (var i in global) context[i] = global[i];
    context.console = new Console(this.outputStream);
    context.global = context;
    context.global.global = context;
  const module = new Module('<repl>');
  module.paths = Module._resolveLookupPaths('<repl>', parentModule)[1];
  const require = internalModule.makeRequireFunction.call(module);
  context.module = module;
  context.require = require;
  this.lines = [];
  this.lines.level = [];
  // make built-in modules available directly
  // (loaded lazily)
  exports._builtinLibs.forEach(function(name) {
    Object.defineProperty(context, name, {
      get: function() {
        var lib = require(name);
        context._ = context[name] = lib;
        return lib;
      },
      // allow the creation of other globals with this name
      set: function(val) {
        delete context[name];
        context[name] = val;
      },
      configurable: true
    });
  });
  return context;
REPLServer.prototype.resetContext = function() {
  this.context = this.createContext();
  // Allow REPL extensions to extend the new context
  this.emit('reset', this.context);
REPLServer.prototype.displayPrompt = function(preserveCursor) {
  var prompt = this._initialPrompt;
  if (this.bufferedCommand.length) {
    prompt = '...';
    const len = this.lines.level.length ? this.lines.level.length - 1 : 0;
    const levelInd = '..'.repeat(len);
    prompt += levelInd + ' ';
  // Do not overwrite `_initialPrompt` here
  REPLServer.super_.prototype.setPrompt.call(this, prompt);
  this.prompt(preserveCursor);
// When invoked as an API method, overwrite _initialPrompt
REPLServer.prototype.setPrompt = function setPrompt(prompt) {
  this._initialPrompt = prompt;
  REPLServer.super_.prototype.setPrompt.call(this, prompt);
// A stream to push an array into a REPL
// used in REPLServer.complete
function ArrayStream() {
  Stream.call(this);
  this.run = function(data) {
    var self = this;
    data.forEach(function(line) {
      self.emit('data', line + '\n');
    });
  };
util.inherits(ArrayStream, Stream);
ArrayStream.prototype.readable = true;
ArrayStream.prototype.writable = true;
ArrayStream.prototype.resume = function() {};
ArrayStream.prototype.write = function() {};
const requireRE = /\brequire\s*\(['"](([\w\.\/-]+\/)?([\w\.\/-]*))/;
const simpleExpressionRE =
    /(([a-zA-Z_$](?:\w|\$)*)\.)*([a-zA-Z_$](?:\w|\$)*)\.?$/;
function intFilter(item) {
  // filters out anything not starting with A-Z, a-z, $ or _
  return /^[A-Za-z_$]/.test(item);
function filteredOwnPropertyNames(obj) {
  if (!obj) return [];
  return Object.getOwnPropertyNames(obj).filter(intFilter);
// Provide a list of completions for the given leading text. This is
// given to the readline interface for handling tab completion.
// Example:
//  complete('var foo = util.')
//    -> [['util.print', 'util.debug', 'util.log', 'util.inspect', 'util.pump'],
//        'util.' ]
// Warning: This eval's code like "foo.bar.baz", so it will run property
// getter code.
REPLServer.prototype.complete = function(line, callback) {
  // There may be local variables to evaluate, try a nested REPL
  if (this.bufferedCommand !== undefined && this.bufferedCommand.length) {
    // Get a new array of inputed lines
    var tmp = this.lines.slice();
    // Kill off all function declarations to push all local variables into
    // global scope
    this.lines.level.forEach(function(kill) {
      if (kill.isFunction) {
        tmp[kill.line] = '';
      }
    });
    var flat = new ArrayStream();         // make a new "input" stream
    var magic = new REPLServer('', flat); // make a nested REPL
    magic.context = magic.createContext();
    flat.run(tmp);                        // eval the flattened code
    // all this is only profitable if the nested REPL
    // does not have a bufferedCommand
    if (!magic.bufferedCommand) {
      replMap.set(magic, replMap.get(this));
      return magic.complete(line, callback);
    }
  var completions;
  // list of completion lists, one for each inheritance "level"
  var completionGroups = [];
  var completeOn, i, group, c;
  // REPL commands (e.g. ".break").
  var match = null;
  match = line.match(/^\s*\.(\w*)$/);
  if (match) {
    completionGroups.push(Object.keys(this.commands));
    completeOn = match[1];
    if (match[1].length) {
      filter = match[1];
    }
    completionGroupsLoaded();
  } else if (match = line.match(requireRE)) {
    // require('...<Tab>')
    const exts = Object.keys(this.context.require.extensions);
    var indexRe = new RegExp('^index(' + exts.map(regexpEscape).join('|') +
                             ')$');
    completeOn = match[1];
    var subdir = match[2] || '';
    var filter = match[1];
    var dir, files, f, name, base, ext, abs, subfiles, s;
    group = [];
    var paths = module.paths.concat(require('module').globalPaths);
    for (i = 0; i < paths.length; i++) {
      dir = path.resolve(paths[i], subdir);
      try {
        files = fs.readdirSync(dir);
      } catch (e) {
        continue;
      }
      for (f = 0; f < files.length; f++) {
        name = files[f];
        ext = path.extname(name);
        base = name.slice(0, -ext.length);
        if (base.match(/-\d+\.\d+(\.\d+)?/) || name === '.npm') {
          // Exclude versioned names that 'npm' installs.
          continue;
        }
        if (exts.indexOf(ext) !== -1) {
          if (!subdir || base !== 'index') {
            group.push(subdir + base);
          }
        } else {
          abs = path.resolve(dir, name);
          try {
            if (fs.statSync(abs).isDirectory()) {
              group.push(subdir + name + '/');
              subfiles = fs.readdirSync(abs);
              for (s = 0; s < subfiles.length; s++) {
                if (indexRe.test(subfiles[s])) {
                  group.push(subdir + name);
                }
              }
            }
          } catch (e) {}
        }
      }
    }
    if (group.length) {
      completionGroups.push(group);
    }
    if (!subdir) {
      completionGroups.push(exports._builtinLibs);
    }
    completionGroupsLoaded();
  // Handle variable member lookup.
  // We support simple chained expressions like the following (no function
  // calls, etc.). That is for simplicity and also because we *eval* that
  // leading expression so for safety (see WARNING above) don't want to
  // eval function calls.
  //
  //   foo.bar<|>     # completions for 'foo' with filter 'bar'
  //   spam.eggs.<|>  # completions for 'spam.eggs' with filter ''
  //   foo<|>         # all scope vars with filter 'foo'
  //   foo.<|>        # completions for 'foo' with filter ''
  } else if (line.length === 0 || line[line.length - 1].match(/\w|\.|\$/)) {
    match = simpleExpressionRE.exec(line);
    if (line.length === 0 || match) {
      var expr;
      completeOn = (match ? match[0] : '');
      if (line.length === 0) {
        filter = '';
        expr = '';
      } else if (line[line.length - 1] === '.') {
        filter = '';
        expr = match[0].slice(0, match[0].length - 1);
      } else {
        var bits = match[0].split('.');
        filter = bits.pop();
        expr = bits.join('.');
      }
      // Resolve expr and get its completions.
      var memberGroups = [];
      if (!expr) {
        // If context is instance of vm.ScriptContext
        // Get global vars synchronously
        if (this.useGlobal || vm.isContext(this.context)) {
          var contextProto = this.context;
          while (contextProto = Object.getPrototypeOf(contextProto)) {
            completionGroups.push(filteredOwnPropertyNames(contextProto));
          }
          completionGroups.push(filteredOwnPropertyNames(this.context));
          addStandardGlobals(completionGroups, filter);
          completionGroupsLoaded();
        } else {
          this.eval('.scope', this.context, 'repl', function(err, globals) {
            if (err || !Array.isArray(globals)) {
              addStandardGlobals(completionGroups, filter);
            } else if (Array.isArray(globals[0])) {
              // Add grouped globals
              globals.forEach(function(group) {
                completionGroups.push(group);
              });
            } else {
              completionGroups.push(globals);
              addStandardGlobals(completionGroups, filter);
            }
            completionGroupsLoaded();
          });
        }
      } else {
        this.eval(expr, this.context, 'repl', function(e, obj) {
          // if (e) console.log(e);
          if (obj != null) {
            if (typeof obj === 'object' || typeof obj === 'function') {
              try {
                memberGroups.push(filteredOwnPropertyNames(obj));
              } catch (ex) {
                // Probably a Proxy object without `getOwnPropertyNames` trap.
                // We simply ignore it here, as we don't want to break the
                // autocompletion. Fixes the bug
                // https://github.com/nodejs/node/issues/2119
              }
            }
            // works for non-objects
            try {
              var sentinel = 5;
              var p;
              if (typeof obj === 'object' || typeof obj === 'function') {
                p = Object.getPrototypeOf(obj);
              } else {
                p = obj.constructor ? obj.constructor.prototype : null;
              }
              while (p !== null) {
                memberGroups.push(filteredOwnPropertyNames(p));
                p = Object.getPrototypeOf(p);
                // Circular refs possible? Let's guard against that.
                sentinel--;
                if (sentinel <= 0) {
                  break;
                }
              }
            } catch (e) {
              //console.log("completion error walking prototype chain:" + e);
            }
          }
          if (memberGroups.length) {
            for (i = 0; i < memberGroups.length; i++) {
              completionGroups.push(memberGroups[i].map(function(member) {
                return expr + '.' + member;
              }));
            }
            if (filter) {
              filter = expr + '.' + filter;
            }
          }
          completionGroupsLoaded();
        });
      }
    } else {
      completionGroupsLoaded();
    }
  } else {
    completionGroupsLoaded();
  // Will be called when all completionGroups are in place
  // Useful for async autocompletion
  function completionGroupsLoaded(err) {
    if (err) throw err;
    // Filter, sort (within each group), uniq and merge the completion groups.
    if (completionGroups.length && filter) {
      var newCompletionGroups = [];
      for (i = 0; i < completionGroups.length; i++) {
        group = completionGroups[i].filter(function(elem) {
          return elem.indexOf(filter) == 0;
        });
        if (group.length) {
          newCompletionGroups.push(group);
        }
      }
      completionGroups = newCompletionGroups;
    }
    if (completionGroups.length) {
      var uniq = {};  // unique completions across all groups
      completions = [];
      // Completion group 0 is the "closest"
      // (least far up the inheritance chain)
      // so we put its completions last: to be closest in the REPL.
      for (i = completionGroups.length - 1; i >= 0; i--) {
        group = completionGroups[i];
        group.sort();
        for (var j = 0; j < group.length; j++) {
          c = group[j];
          if (!hasOwnProperty(uniq, c)) {
            completions.push(c);
            uniq[c] = true;
          }
        }
        completions.push(''); // separator btwn groups
      }
      while (completions.length && completions[completions.length - 1] === '') {
        completions.pop();
      }
    }
    callback(null, [completions || [], completeOn]);
 * Used to parse and execute the Node REPL commands.
 * @param {keyword} keyword The command entered to check.
 * @return {Boolean} If true it means don't continue parsing the command.
REPLServer.prototype.parseREPLKeyword = function(keyword, rest) {
  var cmd = this.commands[keyword];
  if (cmd) {
    cmd.action.call(this, rest);
    return true;
  return false;
REPLServer.prototype.defineCommand = function(keyword, cmd) {
  if (typeof cmd === 'function') {
    cmd = {action: cmd};
  } else if (typeof cmd.action !== 'function') {
    throw new Error('bad argument, action must be a function');
  this.commands[keyword] = cmd;
REPLServer.prototype.memory = function memory(cmd) {
  var self = this;
  self.lines = self.lines || [];
  self.lines.level = self.lines.level || [];
  // save the line so I can do magic later
  if (cmd) {
    // TODO should I tab the level?
    const len = self.lines.level.length ? self.lines.level.length - 1 : 0;
    self.lines.push('  '.repeat(len) + cmd);
  } else {
    // I don't want to not change the format too much...
    self.lines.push('');
  // I need to know "depth."
  // Because I can not tell the difference between a } that
  // closes an object literal and a } that closes a function
  if (cmd) {
    // going down is { and (   e.g. function() {
    // going up is } and )
    var dw = cmd.match(/{|\(/g);
    var up = cmd.match(/}|\)/g);
    up = up ? up.length : 0;
    dw = dw ? dw.length : 0;
    var depth = dw - up;
    if (depth) {
      (function workIt() {
        if (depth > 0) {
          // going... down.
          // push the line#, depth count, and if the line is a function.
          // Since JS only has functional scope I only need to remove
          // "function() {" lines, clearly this will not work for
          // "function()
          // {" but nothing should break, only tab completion for local
          // scope will not work for this function.
          self.lines.level.push({
            line: self.lines.length - 1,
            depth: depth,
            isFunction: /\s*function\s*/.test(cmd)
          });
        } else if (depth < 0) {
          // going... up.
          var curr = self.lines.level.pop();
          if (curr) {
            var tmp = curr.depth + depth;
            if (tmp < 0) {
              //more to go, recurse
              depth += curr.depth;
              workIt();
            } else if (tmp > 0) {
              //remove and push back
              curr.depth += depth;
              self.lines.level.push(curr);
            }
          }
        }
      }());
    }
    // it is possible to determine a syntax error at this point.
    // if the REPL still has a bufferedCommand and
    // self.lines.level.length === 0
    // TODO? keep a log of level so that any syntax breaking lines can
    // be cleared on .break and in the case of a syntax error?
    // TODO? if a log was kept, then I could clear the bufferedComand and
    // eval these lines and throw the syntax error
  } else {
    self.lines.level = [];
function addStandardGlobals(completionGroups, filter) {
  // Global object properties
  // (http://www.ecma-international.org/publications/standards/Ecma-262.htm)
  completionGroups.push(['NaN', 'Infinity', 'undefined',
    'eval', 'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'decodeURI',
    'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
    'Object', 'Function', 'Array', 'String', 'Boolean', 'Number',
    'Date', 'RegExp', 'Error', 'EvalError', 'RangeError',
    'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',
    'Math', 'JSON']);
  // Common keywords. Exclude for completion on the empty string, b/c
  // they just get in the way.
  if (filter) {
    completionGroups.push(['break', 'case', 'catch', 'const',
      'continue', 'debugger', 'default', 'delete', 'do', 'else',
      'export', 'false', 'finally', 'for', 'function', 'if',
      'import', 'in', 'instanceof', 'let', 'new', 'null', 'return',
      'switch', 'this', 'throw', 'true', 'try', 'typeof', 'undefined',
      'var', 'void', 'while', 'with', 'yield']);
function defineDefaultCommands(repl) {
  repl.defineCommand('break', {
    help: 'Sometimes you get stuck, this gets you out',
    action: function() {
      this.lineParser.reset();
      this.bufferedCommand = '';
      this.displayPrompt();
    }
  });
  var clearMessage;
  if (repl.useGlobal) {
    clearMessage = 'Alias for .break';
  } else {
    clearMessage = 'Break, and also clear the local context';
  repl.defineCommand('clear', {
    help: clearMessage,
    action: function() {
      this.lineParser.reset();
      this.bufferedCommand = '';
      if (!this.useGlobal) {
        this.outputStream.write('Clearing context...\n');
        this.resetContext();
      }
      this.displayPrompt();
    }
  });
  repl.defineCommand('exit', {
    help: 'Exit the repl',
    action: function() {
      this.close();
    }
  });
  repl.defineCommand('help', {
    help: 'Show repl options',
    action: function() {
      var self = this;
      Object.keys(this.commands).sort().forEach(function(name) {
        var cmd = self.commands[name];
        self.outputStream.write(name + '\t' + (cmd.help || '') + '\n');
      });
      this.displayPrompt();
    }
  });
  repl.defineCommand('save', {
    help: 'Save all evaluated commands in this REPL session to a file',
    action: function(file) {
      try {
        fs.writeFileSync(file, this.lines.join('\n') + '\n');
        this.outputStream.write('Session saved to:' + file + '\n');
      } catch (e) {
        this.outputStream.write('Failed to save:' + file + '\n');
      }
      this.displayPrompt();
    }
  });
  repl.defineCommand('load', {
    help: 'Load JS from a file into the REPL session',
    action: function(file) {
      try {
        var stats = fs.statSync(file);
        if (stats && stats.isFile()) {
          var self = this;
          var data = fs.readFileSync(file, 'utf8');
          var lines = data.split('\n');
          this.displayPrompt();
          lines.forEach(function(line) {
            if (line) {
              self.write(line + '\n');
            }
          });
        } else {
          this.outputStream.write('Failed to load:' + file +
                                  ' is not a valid file\n');
        }
      } catch (e) {
        this.outputStream.write('Failed to load:' + file + '\n');
      }
      this.displayPrompt();
    }
  });
function regexpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
 * Converts commands that use var and function <name>() to use the
 * local exports.context when evaled. This provides a local context
 * on the REPL.
 * @param {String} cmd The cmd to convert.
 * @return {String} The converted command.
REPLServer.prototype.convertToContext = function(cmd) {
  const scopeVar = /^\s*var\s*([_\w\$]+)(.*)$/m;
  const scopeFunc = /^\s*function\s*([_\w\$]+)/;
  var matches;
  // Replaces: var foo = "bar";  with: self.context.foo = bar;
  matches = scopeVar.exec(cmd);
  if (matches && matches.length === 3) {
    return 'self.context.' + matches[1] + matches[2];
  // Replaces: function foo() {};  with: foo = function foo() {};
  matches = scopeFunc.exec(this.bufferedCommand);
  if (matches && matches.length === 2) {
    return matches[1] + ' = ' + this.bufferedCommand;
  return cmd;
// If the error is that we've unexpectedly ended the input,
// then let the user try to recover by adding more input.
function isRecoverableError(e, self) {
  if (e && e.name === 'SyntaxError') {
    var message = e.message;
    if (message === 'Unterminated template literal' ||
        message === 'Missing } in template expression') {
      self._inTemplateLiteral = true;
      return true;
    }
    return /^(Unexpected end of input|Unexpected token)/.test(message);
  return false;
function Recoverable(err) {
  this.err = err;
inherits(Recoverable, SyntaxError);
'use strict';
module.exports = Stream;
const EE = require('events');
const util = require('util');
util.inherits(Stream, EE);
Stream.Readable = require('_stream_readable');
Stream.Writable = require('_stream_writable');
Stream.Duplex = require('_stream_duplex');
Stream.Transform = require('_stream_transform');
Stream.PassThrough = require('_stream_passthrough');
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.
function Stream() {
  EE.call(this);
Stream.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  source.on('data', ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  dest.on('drain', ondrain);
  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  source.on('error', onerror);
  dest.on('error', onerror);
  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source);
  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
'use strict';
module.exports = Readable;
Readable.ReadableState = ReadableState;
const EE = require('events');
const Stream = require('stream');
const Buffer = require('buffer').Buffer;
const util = require('util');
const debug = util.debuglog('stream');
var StringDecoder;
util.inherits(Readable, Stream);
function ReadableState(options, stream) {
  options = options || {};
  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (stream instanceof Stream.Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;
  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';
  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;
  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;
  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  // legacy
  this.readable = true;
  if (options && typeof options.read === 'function')
    this._read = options.read;
  Stream.call(this);
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;
  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  return readableAddChunk(this, state, chunk, encoding, false);
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      const e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      const e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = (!state.objectMode && chunk.length === 0);
      }
      if (!addToFront)
        state.reading = false;
      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  return needMoreData(state);
// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
// Don't raise the hwm > 8MB
const MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  return n;
function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return n === 0 ? 0 : 1;
  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  if (n <= 0)
    return 0;
  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  return n;
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;
  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;
  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  n = howMuchToRead(n, state);
  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);
  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);
  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;
  if (ret === null) {
    state.needReadable = true;
    n = 0;
  state.length -= n;
  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;
  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);
  if (ret !== null)
    this.emit('data', ret);
  return ret;
function chunkInvalid(state, chunk) {
  var er = null;
  if (!(chunk instanceof Buffer) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  return er;
function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  state.ended = true;
  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  state.readingMore = false;
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;
  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  function onend() {
    debug('onend');
    dest.end();
  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);
    cleanedUp = true;
    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if (((state.pipesCount === 1 && state.pipes === dest) ||
           (state.pipesCount > 1 && state.pipes.indexOf(dest) !== -1)) &&
          !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (Array.isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];
  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  // tell the dest that it's being piped to
  dest.emit('pipe', src);
  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  return dest;
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;
  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;
  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;
    if (!dest)
      dest = state.pipes;
    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  // slow case. multiple pipe destinations.
  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (let i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  // try to find the right one.
  const i = state.pipes.indexOf(dest);
  if (i === -1)
    return this;
  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];
  dest.emit('unpipe', this);
  return this;
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  return res;
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  return this;
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  return this;
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;
  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }
    self.push(null);
  });
  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;
    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });
  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }; }(i);
    }
  // proxy certain important events.
  const events = ['error', 'close', 'destroy', 'pause', 'resume'];
  events.forEach(function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });
  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return self;
// exposed for testing purposes only.
Readable._fromList = fromList;
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;
  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;
  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else if (list.length === 1)
      ret = list[0];
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      const buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);
      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        const buf = list[0];
        var cpy = Math.min(n - c, buf.length);
        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);
        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();
        c += cpy;
      }
    }
  return ret;
function endReadable(stream) {
  var state = stream._readableState;
  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';
module.exports = Writable;
Writable.WritableState = WritableState;
const util = require('util');
const internalUtil = require('internal/util');
const Stream = require('stream');
const Buffer = require('buffer').Buffer;
util.inherits(Writable, Stream);
function nop() {}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
function WritableState(options, stream) {
  options = options || {};
  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (stream instanceof Stream.Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;
  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';
  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;
  // a flag to see when we're in the middle of a write.
  this.writing = false;
  // when true all writes will be buffered until .uncork() call
  this.corked = 0;
  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;
  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;
  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;
  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;
  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;
  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
  // count buffered requests
  this.bufferedRequestCount = 0;
  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  return out;
Object.defineProperty(WritableState.prototype, 'buffer', {
  get: internalUtil.deprecate(function() {
    return this.getBuffer();
  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +
     'instead.')
function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;
    if (typeof options.writev === 'function')
      this._writev = options.writev;
  Stream.call(this);
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(cb, er);
// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!(chunk instanceof Buffer) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(cb, er);
    valid = false;
  return valid;
Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  if (chunk instanceof Buffer)
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;
  if (typeof cb !== 'function')
    cb = nop;
  if (state.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  return ret;
Writable.prototype.cork = function() {
  var state = this._writableState;
  state.corked++;
Writable.prototype.uncork = function() {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.bufferedRequest)
      clearBuffer(this, state);
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string')
    encoding = encoding.toLowerCase();
  if (!Buffer.isEncoding(encoding))
    throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  return chunk;
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (chunk instanceof Buffer)
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  return ret;
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    process.nextTick(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);
    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null)
      state.lastBufferedRequest = null;
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  if (chunk !== null && chunk !== undefined)
    this.write(chunk, encoding);
  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
function needFinish(state) {
  return (state.ending &&
          state.length === 0 &&
          state.bufferedRequest === null &&
          !state.finished &&
          !state.writing);
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  return need;
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  state.ended = true;
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  this.next = null;
  this.entry = null;
  this.finish = (err) => {
    var entry = this.entry;
    this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = this;
    } else {
      state.corkedRequestsFree = this;
    }
  };
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
module.exports = Duplex;
const util = require('util');
const Readable = require('_stream_readable');
const Writable = require('_stream_writable');
util.inherits(Duplex, Readable);
var keys = Object.keys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once('end', onend);
// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
function onEndNT(self) {
  self.end();
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
// Here's how this works:
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';
module.exports = Transform;
const Duplex = require('_stream_duplex');
const util = require('util');
util.inherits(Transform, Duplex);
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== undefined)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  // when the writable side finishes, then flush out anything remaining.
  var stream = this;
  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;
  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;
    if (typeof options.flush === 'function')
      this._flush = options.flush;
  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
function done(stream, er) {
  if (er)
    return stream.emit('error', er);
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');
  if (ts.transforming)
    throw new Error('calling transform done when still transforming');
  return stream.push(null);
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';
module.exports = PassThrough;
const Transform = require('_stream_transform');
const util = require('util');
util.inherits(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
'use strict';
const assert = require('assert');
const util = require('util');
const Socket = require('net').Socket;
const JSStream = process.binding('js_stream').JSStream;
const Buffer = require('buffer').Buffer;
const uv = process.binding('uv');
const debug = util.debuglog('stream_wrap');
function StreamWrap(stream) {
  const handle = new JSStream();
  this.stream = stream;
  this._list = null;
  const self = this;
  handle.close = function(cb) {
    debug('close');
    self.doClose(cb);
  };
  handle.isAlive = function() {
    return self.isAlive();
  };
  handle.isClosing = function() {
    return self.isClosing();
  };
  handle.onreadstart = function() {
    return self.readStart();
  };
  handle.onreadstop = function() {
    return self.readStop();
  };
  handle.onshutdown = function(req) {
    return self.doShutdown(req);
  };
  handle.onwrite = function(req, bufs) {
    return self.doWrite(req, bufs);
  };
  this.stream.pause();
  this.stream.on('error', function onerror(err) {
    self.emit('error', err);
  });
  this.stream.on('data', function ondata(chunk) {
    if (!(chunk instanceof Buffer)) {
      // Make sure that no further `data` events will happen
      this.pause();
      this.removeListener('data', ondata);
      self.emit('error', new Error('Stream has StringDecoder'));
      return;
    }
    debug('data', chunk.length);
    if (self._handle)
      self._handle.readBuffer(chunk);
  });
  this.stream.once('end', function onend() {
    debug('end');
    if (self._handle)
      self._handle.emitEOF();
  });
  Socket.call(this, {
    handle: handle
  });
util.inherits(StreamWrap, Socket);
module.exports = StreamWrap;
// require('_stream_wrap').StreamWrap
StreamWrap.StreamWrap = StreamWrap;
StreamWrap.prototype.isAlive = function isAlive() {
  return true;
StreamWrap.prototype.isClosing = function isClosing() {
  return !this.readable || !this.writable;
StreamWrap.prototype.readStart = function readStart() {
  this.stream.resume();
  return 0;
StreamWrap.prototype.readStop = function readStop() {
  this.stream.pause();
  return 0;
StreamWrap.prototype.doShutdown = function doShutdown(req) {
  const self = this;
  const handle = this._handle;
  const item = this._enqueue('shutdown', req);
  this.stream.end(function() {
    // Ensure that write was dispatched
    setImmediate(function() {
      if (!self._dequeue(item))
        return;
      handle.finishShutdown(req, 0);
    });
  });
  return 0;
StreamWrap.prototype.doWrite = function doWrite(req, bufs) {
  const self = this;
  const handle = self._handle;
  var pending = bufs.length;
  // Queue the request to be able to cancel it
  const item = self._enqueue('write', req);
  self.stream.cork();
  bufs.forEach(function(buf) {
    self.stream.write(buf, done);
  });
  self.stream.uncork();
  function done(err) {
    if (!err && --pending !== 0)
      return;
    // Ensure that this is called once in case of error
    pending = 0;
    // Ensure that write was dispatched
    setImmediate(function() {
      // Do not invoke callback twice
      if (!self._dequeue(item))
        return;
      var errCode = 0;
      if (err) {
        if (err.code && uv['UV_' + err.code])
          errCode = uv['UV_' + err.code];
        else
          errCode = uv.UV_EPIPE;
      }
      handle.doAfterWrite(req);
      handle.finishWrite(req, errCode);
    });
  return 0;
function QueueItem(type, req) {
  this.type = type;
  this.req = req;
  this.prev = this;
  this.next = this;
StreamWrap.prototype._enqueue = function enqueue(type, req) {
  const item = new QueueItem(type, req);
  if (this._list === null) {
    this._list = item;
    return item;
  item.next = this._list.next;
  item.prev = this._list;
  item.next.prev = item;
  item.prev.next = item;
  return item;
StreamWrap.prototype._dequeue = function dequeue(item) {
  assert(item instanceof QueueItem);
  var next = item.next;
  var prev = item.prev;
  if (next === null && prev === null)
    return false;
  item.next = null;
  item.prev = null;
  if (next === item) {
    prev = null;
    next = null;
  } else {
    prev.next = next;
    next.prev = prev;
  if (this._list === item)
    this._list = next;
  return true;
StreamWrap.prototype.doClose = function doClose(cb) {
  const self = this;
  const handle = self._handle;
  setImmediate(function() {
    while (self._list !== null) {
      const item = self._list;
      const req = item.req;
      self._dequeue(item);
      const errCode = uv.UV_ECANCELED;
      if (item.type === 'write') {
        handle.doAfterWrite(req);
        handle.finishWrite(req, errCode);
      } else if (item.type === 'shutdown') {
        handle.finishShutdown(req, errCode);
      }
    }
    // Should be already set by net.js
    assert(self._handle === null);
    cb();
  });
'use strict';
const Buffer = require('buffer').Buffer;
function assertEncoding(encoding) {
  // Do not cache `Buffer.isEncoding`, some modules monkey-patch it to support
  // additional encodings
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
const StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var buflen = buffer.length;
  var charBuffer = this.charBuffer;
  var charLength = this.charLength;
  var charReceived = this.charReceived;
  var surrogateSize = this.surrogateSize;
  var encoding = this.encoding;
  var charCode;
  // if our last write ended with an incomplete multibyte character
  while (charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var diff = charLength - charReceived;
    var available = (buflen >= diff) ? diff : buflen;
    // add the new bytes to the char buffer
    buffer.copy(charBuffer, charReceived, 0, available);
    charReceived += available;
    if (charReceived < charLength) {
      // still not enough chars in this buffer? wait for more ...
      this.charLength = charLength;
      this.charReceived = charReceived;
      return '';
    }
    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buflen);
    buflen = buffer.length;
    // get the character that was split
    charStr = charBuffer.toString(encoding, 0, charLength);
    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      charLength += surrogateSize;
      charStr = '';
      continue;
    }
    charReceived = charLength = 0;
    // if there are no more bytes in this buffer, just emit our char
    if (buflen === 0) {
      this.charLength = charLength;
      this.charReceived = charReceived;
      return charStr;
    }
  // determine and set charLength / charReceived
  if (this.detectIncompleteChar(buffer))
    charLength = this.charLength;
  charReceived = this.charReceived;
  var end = buflen;
  if (charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(charBuffer, 0, buflen - charReceived, end);
    end -= charReceived;
  this.charLength = charLength;
  charStr += buffer.toString(encoding, 0, end);
  end = charStr.length - 1;
  charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    charLength += surrogateSize;
    charReceived += surrogateSize;
    charBuffer.copy(charBuffer, surrogateSize, 0, surrogateSize);
    buffer.copy(charBuffer, 0, 0, surrogateSize);
    this.charLength = charLength;
    this.charReceived = charReceived;
    return charStr.substring(0, end);
  // or just emit the charStr
  return charStr;
// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  var buflen = buffer.length;
  // determine how many bytes we have to check at the end of this buffer
  var i = (buflen >= 3) ? 3 : buflen;
  var newlen = false;
  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buflen - i];
    // See http://en.wikipedia.org/wiki/UTF-8#Description
    // 110XXXXX
    if (i === 1 && c >> 5 === 0x06) {
      this.charLength = 2;
      newlen = true;
      break;
    }
    // 1110XXXX
    if (i <= 2 && c >> 4 === 0x0E) {
      this.charLength = 3;
      newlen = true;
      break;
    }
    // 11110XXX
    if (i <= 3 && c >> 3 === 0x1E) {
      this.charLength = 4;
      newlen = true;
      break;
    }
  this.charReceived = i;
  return newlen;
StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);
  var charReceived = this.charReceived;
  if (charReceived) {
    var cr = charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.toString(enc, 0, cr);
  return res;
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
function utf16DetectIncompleteChar(buffer) {
  var charReceived = this.charReceived = buffer.length % 2;
  this.charLength = charReceived ? 2 : 0;
  return true;
function base64DetectIncompleteChar(buffer) {
  var charReceived = this.charReceived = buffer.length % 3;
  this.charLength = charReceived ? 3 : 0;
  return true;
'use strict';
const util = require('internal/util');
// the sys module was renamed to 'util'.
// this shim remains to keep old programs working.
// sys is deprecated and shouldn't be used
module.exports = require('util');
util.printDeprecationMessage('sys is deprecated. Use util instead.');
'use strict';
const Timer = process.binding('timer_wrap').Timer;
const L = require('_linklist'); // eslint-disable-line no-restricted-modules
const assert = require('assert').ok;
const util = require('util');
const debug = util.debuglog('timer');
const kOnTimeout = Timer.kOnTimeout | 0;
// Timeout values > TIMEOUT_MAX are set to 1.
const TIMEOUT_MAX = 2147483647; // 2^31-1
// IDLE TIMEOUTS
// Because often many sockets will have the same idle timeout we will not
// use one timeout watcher per item. It is too much overhead.  Instead
// we'll use a single watcher for all sockets with the same timeout value
// and a linked list. This technique is described in the libev manual:
// http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts
// Object containing all lists, timers
// key = time in milliseconds
// value = list
var lists = {};
// call this whenever the item is active (not idle)
// it will reset its timeout.
// the main function - creates lists on demand and the watchers associated
// with them.
exports.active = function(item) {
  const msecs = item._idleTimeout;
  if (msecs < 0 || msecs === undefined) return;
  item._idleStart = Timer.now();
  var list;
  if (lists[msecs]) {
    list = lists[msecs];
  } else {
    list = new Timer();
    list.start(msecs, 0);
    L.init(list);
    lists[msecs] = list;
    list.msecs = msecs;
    list[kOnTimeout] = listOnTimeout;
  L.append(list, item);
  assert(!L.isEmpty(list)); // list is not empty
function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;
  debug('timeout callback %d', msecs);
  var now = Timer.now();
  debug('now: %s', now);
  var diff, first, threw;
  while (first = L.peek(list)) {
    diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug('%d list wait because diff is %d', msecs, diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));
      if (!first._onTimeout) continue;
      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed)
        continue;
      try {
        if (domain)
          domain.enter();
        threw = true;
        first._called = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          // We need to continue processing after domain error handling
          // is complete, but not by using whatever domain was left over
          // when the timeout threw its exception.
          var oldDomain = process.domain;
          process.domain = null;
          process.nextTick(listOnTimeoutNT, list);
          process.domain = oldDomain;
        }
      }
    }
  debug('%d list empty', msecs);
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
function listOnTimeoutNT(list) {
  list[kOnTimeout]();
function reuse(item) {
  L.remove(item);
  var list = lists[item._idleTimeout];
  // if empty - reuse the watcher
  if (list && L.isEmpty(list)) {
    debug('reuse hit');
    list.stop();
    delete lists[item._idleTimeout];
    return list;
  return null;
const unenroll = exports.unenroll = function(item) {
  var list = reuse(item);
  if (list) {
    debug('unenroll: list empty');
    list.close();
  // if active is called later, then we want to make sure not to insert again
  item._idleTimeout = -1;
// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  if (typeof msecs !== 'number') {
    throw new TypeError('msecs must be a number');
  if (msecs < 0 || !isFinite(msecs)) {
    throw new RangeError('msecs must be a non-negative finite number');
  // if this item was already in a list somewhere
  // then we should unenroll it from that
  if (item._idleNext) unenroll(item);
  // Ensure that msecs fits into signed int32
  if (msecs > TIMEOUT_MAX) {
    msecs = TIMEOUT_MAX;
  item._idleTimeout = msecs;
  L.init(item);
 * DOM-style timers
exports.setTimeout = function(callback, after) {
  after *= 1; // coalesce to number or NaN
  if (!(after >= 1 && after <= TIMEOUT_MAX)) {
    after = 1; // schedule on next tick, follows browser behaviour
  var timer = new Timeout(after);
  var length = arguments.length;
  var ontimeout = callback;
  switch (length) {
    // fast cases
    case 0:
    case 1:
    case 2:
      break;
    case 3:
      ontimeout = () => callback.call(timer, arguments[2]);
      break;
    case 4:
      ontimeout = () => callback.call(timer, arguments[2], arguments[3]);
      break;
    case 5:
      ontimeout =
        () => callback.call(timer, arguments[2], arguments[3], arguments[4]);
      break;
    // slow case
    default:
      var args = new Array(length - 2);
      for (var i = 2; i < length; i++)
        args[i - 2] = arguments[i];
      ontimeout = () => callback.apply(timer, args);
      break;
  timer._onTimeout = ontimeout;
  if (process.domain) timer.domain = process.domain;
  exports.active(timer);
  return timer;
exports.clearTimeout = function(timer) {
  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {
    timer[kOnTimeout] = timer._onTimeout = null;
    if (timer instanceof Timeout) {
      timer.close(); // for after === 0
    } else {
      exports.unenroll(timer);
    }
exports.setInterval = function(callback, repeat) {
  repeat *= 1; // coalesce to number or NaN
  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX)) {
    repeat = 1; // schedule on next tick, follows browser behaviour
  var timer = new Timeout(repeat);
  var length = arguments.length;
  var ontimeout = callback;
  switch (length) {
    case 0:
    case 1:
    case 2:
      break;
    case 3:
      ontimeout = () => callback.call(timer, arguments[2]);
      break;
    case 4:
      ontimeout = () => callback.call(timer, arguments[2], arguments[3]);
      break;
    case 5:
      ontimeout =
        () => callback.call(timer, arguments[2], arguments[3], arguments[4]);
      break;
    default:
      var args = new Array(length - 2);
      for (var i = 2; i < length; i += 1)
        args[i - 2] = arguments[i];
      ontimeout = () => callback.apply(timer, args);
      break;
  timer._onTimeout = wrapper;
  timer._repeat = ontimeout;
  if (process.domain) timer.domain = process.domain;
  exports.active(timer);
  return timer;
  function wrapper() {
    timer._repeat();
    // Timer might be closed - no point in restarting it
    if (!timer._repeat)
      return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
exports.clearInterval = function(timer) {
  if (timer && timer._repeat) {
    timer._repeat = null;
    clearTimeout(timer);
const Timeout = function(after) {
  this._called = false;
  this._idleTimeout = after;
  this._idlePrev = this;
  this._idleNext = this;
  this._idleStart = null;
  this._onTimeout = null;
  this._repeat = null;
function unrefdHandle() {
  this.owner._onTimeout();
  if (!this.owner._repeat)
    this.owner.close();
Timeout.prototype.unref = function() {
  if (this._handle) {
    this._handle.unref();
  } else if (typeof this._onTimeout === 'function') {
    var now = Timer.now();
    if (!this._idleStart) this._idleStart = now;
    var delay = this._idleStart + this._idleTimeout - now;
    if (delay < 0) delay = 0;
    // Prevent running cb again when unref() is called during the same cb
    if (this._called && !this._repeat) {
      exports.unenroll(this);
      return;
    }
    var handle = reuse(this);
    this._handle = handle || new Timer();
    this._handle.owner = this;
    this._handle[kOnTimeout] = unrefdHandle;
    this._handle.start(delay, 0);
    this._handle.domain = this.domain;
    this._handle.unref();
  return this;
Timeout.prototype.ref = function() {
  if (this._handle)
    this._handle.ref();
  return this;
Timeout.prototype.close = function() {
  this._onTimeout = null;
  if (this._handle) {
    this._handle[kOnTimeout] = null;
    this._handle.close();
  } else {
    exports.unenroll(this);
  return this;
var immediateQueue = {};
L.init(immediateQueue);
function processImmediate() {
  var queue = immediateQueue;
  var domain, immediate;
  immediateQueue = {};
  L.init(immediateQueue);
  while (L.isEmpty(queue) === false) {
    immediate = L.shift(queue);
    domain = immediate.domain;
    if (domain)
      domain.enter();
    var threw = true;
    try {
      immediate._onImmediate();
      threw = false;
    } finally {
      if (threw) {
        if (!L.isEmpty(queue)) {
          // Handle any remaining on next tick, assuming we're still
          // alive to do so.
          while (!L.isEmpty(immediateQueue)) {
            L.append(queue, L.shift(immediateQueue));
          }
          immediateQueue = queue;
          process.nextTick(processImmediate);
        }
      }
    }
    if (domain)
      domain.exit();
  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an
  // immediate that's in |queue| is okay. Worst case is we make a superfluous
  // call to NeedImmediateCallbackSetter().
  if (L.isEmpty(immediateQueue)) {
    process._needImmediateCallback = false;
function Immediate() { }
Immediate.prototype.domain = undefined;
Immediate.prototype._onImmediate = undefined;
Immediate.prototype._idleNext = undefined;
Immediate.prototype._idlePrev = undefined;
exports.setImmediate = function(callback, arg1, arg2, arg3) {
  var i, args;
  var len = arguments.length;
  var immediate = new Immediate();
  L.init(immediate);
  switch (len) {
    // fast cases
    case 0:
    case 1:
      immediate._onImmediate = callback;
      break;
    case 2:
      immediate._onImmediate = function() {
        callback.call(immediate, arg1);
      };
      break;
    case 3:
      immediate._onImmediate = function() {
        callback.call(immediate, arg1, arg2);
      };
      break;
    case 4:
      immediate._onImmediate = function() {
        callback.call(immediate, arg1, arg2, arg3);
      };
      break;
    // slow case
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      immediate._onImmediate = function() {
        callback.apply(immediate, args);
      };
      break;
  if (!process._needImmediateCallback) {
    process._needImmediateCallback = true;
    process._immediateCallback = processImmediate;
  if (process.domain)
    immediate.domain = process.domain;
  L.append(immediateQueue, immediate);
  return immediate;
exports.clearImmediate = function(immediate) {
  if (!immediate) return;
  immediate._onImmediate = undefined;
  L.remove(immediate);
  if (L.isEmpty(immediateQueue)) {
    process._needImmediateCallback = false;
// Internal APIs that need timeouts should use timers._unrefActive instead of
// timers.active as internal timeouts shouldn't hold the loop open
var unrefList, unrefTimer;
function _makeTimerTimeout(timer) {
  var domain = timer.domain;
  var msecs = timer._idleTimeout;
  L.remove(timer);
  // Timer has been unenrolled by another timer that fired at the same time,
  // so don't make it timeout.
  if (msecs <= 0)
    return;
  if (!timer._onTimeout)
    return;
  if (domain) {
    if (domain._disposed)
      return;
    domain.enter();
  debug('unreftimer firing timeout');
  timer._called = true;
  _runOnTimeout(timer);
  if (domain)
    domain.exit();
function _runOnTimeout(timer) {
  var threw = true;
  try {
    timer._onTimeout();
    threw = false;
  } finally {
    if (threw) process.nextTick(unrefTimeout);
function unrefTimeout() {
  var now = Timer.now();
  debug('unrefTimer fired');
  var timeSinceLastActive;
  var nextTimeoutTime;
  var nextTimeoutDuration;
  var minNextTimeoutTime = TIMEOUT_MAX;
  var timersToTimeout = [];
  // The actual timer fired and has not yet been rearmed,
  // let's consider its next firing time is invalid for now.
  // It may be set to a relevant time in the future once
  // we scanned through the whole list of timeouts and if
  // we find a timeout that needs to expire.
  unrefTimer.when = -1;
  // Iterate over the list of timeouts,
  // call the onTimeout callback for those expired,
  // and rearm the actual timer if the next timeout to expire
  // will expire before the current actual timer.
  var cur = unrefList._idlePrev;
  while (cur !== unrefList) {
    timeSinceLastActive = now - cur._idleStart;
    if (timeSinceLastActive < cur._idleTimeout) {
      // This timer hasn't expired yet, but check if its expiring time is
      // earlier than the actual timer's expiring time
      nextTimeoutDuration = cur._idleTimeout - timeSinceLastActive;
      nextTimeoutTime = now + nextTimeoutDuration;
      if (minNextTimeoutTime === TIMEOUT_MAX ||
          (nextTimeoutTime < minNextTimeoutTime)) {
        // We found a timeout that will expire earlier,
        // store its next timeout time now so that we
        // can rearm the actual timer accordingly when
        // we scanned through the whole list.
        minNextTimeoutTime = nextTimeoutTime;
      }
    } else {
      // We found a timer that expired. Do not call its _onTimeout callback
      // right now, as it could mutate any item of the list (including itself).
      // Instead, add it to another list that will be processed once the list
      // of current timers has been fully traversed.
      timersToTimeout.push(cur);
    }
    cur = cur._idlePrev;
  var nbTimersToTimeout = timersToTimeout.length;
  for (var timerIdx = 0; timerIdx < nbTimersToTimeout; ++timerIdx)
    _makeTimerTimeout(timersToTimeout[timerIdx]);
  // Rearm the actual timer with the timeout delay
  // of the earliest timeout found.
  if (minNextTimeoutTime !== TIMEOUT_MAX) {
    unrefTimer.start(minNextTimeoutTime - now, 0);
    unrefTimer.when = minNextTimeoutTime;
    debug('unrefTimer rescheduled');
  } else if (L.isEmpty(unrefList)) {
    debug('unrefList is empty');
exports._unrefActive = function(item) {
  var msecs = item._idleTimeout;
  if (!msecs || msecs < 0) return;
  assert(msecs >= 0);
  L.remove(item);
  if (!unrefList) {
    debug('unrefList initialized');
    unrefList = {};
    L.init(unrefList);
    debug('unrefTimer initialized');
    unrefTimer = new Timer();
    unrefTimer.unref();
    unrefTimer.when = -1;
    unrefTimer[kOnTimeout] = unrefTimeout;
  var now = Timer.now();
  item._idleStart = now;
  var when = now + msecs;
  // If the actual timer is set to fire too late, or not set to fire at all,
  // we need to make it fire earlier
  if (unrefTimer.when === -1 || unrefTimer.when > when) {
    unrefTimer.start(msecs, 0);
    unrefTimer.when = when;
    debug('unrefTimer scheduled');
  debug('unrefList append to end');
  L.append(unrefList, item);
'use strict';
const net = require('net');
const url = require('url');
const binding = process.binding('crypto');
const Buffer = require('buffer').Buffer;
const constants = require('constants');
// Allow {CLIENT_RENEG_LIMIT} client-initiated session renegotiations
// every {CLIENT_RENEG_WINDOW} seconds. An error event is emitted if more
// renegotations are seen. The settings are applied to all remote client
// connections.
exports.CLIENT_RENEG_LIMIT = 3;
exports.CLIENT_RENEG_WINDOW = 600;
exports.SLAB_BUFFER_SIZE = 10 * 1024 * 1024;
exports.DEFAULT_CIPHERS = constants.defaultCipherList;
exports.DEFAULT_ECDH_CURVE = 'prime256v1';
exports.getCiphers = function() {
  const names = binding.getSSLCiphers();
  // Drop all-caps names in favor of their lowercase aliases,
  var ctx = {};
  names.forEach(function(name) {
    if (/^[0-9A-Z\-]+$/.test(name)) name = name.toLowerCase();
    ctx[name] = true;
  });
  return Object.getOwnPropertyNames(ctx).sort();
// Convert protocols array into valid OpenSSL protocols list
// ("\x06spdy/2\x08http/1.1\x08http/1.0")
exports.convertNPNProtocols = function convertNPNProtocols(NPNProtocols, out) {
  // If NPNProtocols is Array - translate it into buffer
  if (Array.isArray(NPNProtocols)) {
    var buff = new Buffer(NPNProtocols.reduce(function(p, c) {
      return p + 1 + Buffer.byteLength(c);
    }, 0));
    NPNProtocols.reduce(function(offset, c) {
      var clen = Buffer.byteLength(c);
      buff[offset] = clen;
      buff.write(c, offset + 1);
      return offset + 1 + clen;
    }, 0);
    NPNProtocols = buff;
  // If it's already a Buffer - store it
  if (NPNProtocols instanceof Buffer) {
    out.NPNProtocols = NPNProtocols;
exports.checkServerIdentity = function checkServerIdentity(host, cert) {
  // Create regexp to much hostnames
  function regexpify(host, wildcards) {
    // Add trailing dot (make hostnames uniform)
    if (!host || !host.endsWith('.')) host += '.';
    // The same applies to hostname with more than one wildcard,
    // if hostname has wildcard when wildcards are not allowed,
    // or if there are less than two dots after wildcard (i.e. *.com or *d.com)
    //
    // also
    //
    // "The client SHOULD NOT attempt to match a presented identifier in
    // which the wildcard character comprises a label other than the
    // left-most label (e.g., do not match bar.*.example.net)."
    // RFC6125
    if (!wildcards && /\*/.test(host) || /[\.\*].*\*/.test(host) ||
        /\*/.test(host) && !/\*.*\..+\..+/.test(host)) {
      return /$./;
    }
    // Replace wildcard chars with regexp's wildcard and
    // escape all characters that have special meaning in regexps
    // (i.e. '.', '[', '{', '*', and others)
    var re = host.replace(
        /\*([a-z0-9\\-_\.])|[\.,\-\\\^\$+?*\[\]\(\):!\|{}]/g,
        function(all, sub) {
          if (sub) return '[a-z0-9\\-_]*' + (sub === '-' ? '\\-' : sub);
          return '\\' + all;
        });
    return new RegExp('^' + re + '$', 'i');
  var dnsNames = [];
  var uriNames = [];
  const ips = [];
  var matchCN = true;
  var valid = false;
  var reason = 'Unknown reason';
  // There're several names to perform check against:
  // CN and altnames in certificate extension
  // (DNS names, IP addresses, and URIs)
  //
  // Walk through altnames and generate lists of those names
  if (cert.subjectaltname) {
    cert.subjectaltname.split(/, /g).forEach(function(altname) {
      var option = altname.match(/^(DNS|IP Address|URI):(.*)$/);
      if (!option)
        return;
      if (option[1] === 'DNS') {
        dnsNames.push(option[2]);
      } else if (option[1] === 'IP Address') {
        ips.push(option[2]);
      } else if (option[1] === 'URI') {
        var uri = url.parse(option[2]);
        if (uri) uriNames.push(uri.hostname);
      }
    });
  // If hostname is an IP address, it should be present in the list of IP
  // addresses.
  if (net.isIP(host)) {
    valid = ips.some(function(ip) {
      return ip === host;
    });
    if (!valid) {
      reason = `IP: ${host} is not in the cert's list: ${ips.join(', ')}`;
    }
  } else if (cert.subject) {
    // Transform hostname to canonical form
    if (!host || !host.endsWith('.')) host += '.';
    // Otherwise check all DNS/URI records from certificate
    // (with allowed wildcards)
    dnsNames = dnsNames.map(function(name) {
      return regexpify(name, true);
    });
    // Wildcards ain't allowed in URI names
    uriNames = uriNames.map(function(name) {
      return regexpify(name, false);
    });
    dnsNames = dnsNames.concat(uriNames);
    if (dnsNames.length > 0) matchCN = false;
    // Match against Common Name (CN) only if no supported identifiers are
    // present.
    //
    // "As noted, a client MUST NOT seek a match for a reference identifier
    //  of CN-ID if the presented identifiers include a DNS-ID, SRV-ID,
    //  URI-ID, or any application-specific identifier types supported by the
    //  client."
    // RFC6125
    if (matchCN) {
      var commonNames = cert.subject.CN;
      if (Array.isArray(commonNames)) {
        for (var i = 0, k = commonNames.length; i < k; ++i) {
          dnsNames.push(regexpify(commonNames[i], true));
        }
      } else {
        dnsNames.push(regexpify(commonNames, true));
      }
    }
    valid = dnsNames.some(function(re) {
      return re.test(host);
    });
    if (!valid) {
      if (cert.subjectaltname) {
        reason =
            `Host: ${host} is not in the cert's altnames: ` +
            `${cert.subjectaltname}`;
      } else {
        reason = `Host: ${host} is not cert's CN: ${cert.subject.CN}`;
      }
    }
  } else {
    reason = 'Cert is empty';
  if (!valid) {
    var err = new Error(
        `Hostname/IP doesn't match certificate's altnames: "${reason}"`);
    err.reason = reason;
    err.host = host;
    err.cert = cert;
    return err;
// Example:
// C=US\nST=CA\nL=SF\nO=Joyent\nOU=Node.js\nCN=ca1\nemailAddress=ry@clouds.org
exports.parseCertString = function parseCertString(s) {
  var out = {};
  var parts = s.split('\n');
  for (var i = 0, len = parts.length; i < len; i++) {
    var sepIndex = parts[i].indexOf('=');
    if (sepIndex > 0) {
      var key = parts[i].slice(0, sepIndex);
      var value = parts[i].slice(sepIndex + 1);
      if (key in out) {
        if (!Array.isArray(out[key])) {
          out[key] = [out[key]];
        }
        out[key].push(value);
      } else {
        out[key] = value;
      }
    }
  return out;
// Public API
exports.createSecureContext = require('_tls_common').createSecureContext;
exports.SecureContext = require('_tls_common').SecureContext;
exports.TLSSocket = require('_tls_wrap').TLSSocket;
exports.Server = require('_tls_wrap').Server;
exports.createServer = require('_tls_wrap').createServer;
exports.connect = require('_tls_wrap').connect;
exports.createSecurePair = require('_tls_legacy').createSecurePair;
'use strict';
const constants = require('constants');
const tls = require('tls');
// Lazily loaded
var crypto = null;
const binding = process.binding('crypto');
const NativeSecureContext = binding.SecureContext;
function SecureContext(secureProtocol, flags, context) {
  if (!(this instanceof SecureContext)) {
    return new SecureContext(secureProtocol, flags, context);
  if (context) {
    this.context = context;
  } else {
    this.context = new NativeSecureContext();
    if (secureProtocol) {
      this.context.init(secureProtocol);
    } else {
      this.context.init();
    }
  if (flags) this.context.setOptions(flags);
exports.SecureContext = SecureContext;
exports.createSecureContext = function createSecureContext(options, context) {
  if (!options) options = {};
  var secureOptions = options.secureOptions;
  if (options.honorCipherOrder)
    secureOptions |= constants.SSL_OP_CIPHER_SERVER_PREFERENCE;
  var c = new SecureContext(options.secureProtocol, secureOptions, context);
  if (context) return c;
  // NOTE: It's important to add CA before the cert to be able to load
  // cert's issuer in C++ code.
  if (options.ca) {
    if (Array.isArray(options.ca)) {
      for (let i = 0, len = options.ca.length; i < len; i++) {
        c.context.addCACert(options.ca[i]);
      }
    } else {
      c.context.addCACert(options.ca);
    }
  } else {
    c.context.addRootCerts();
  if (options.cert) {
    if (Array.isArray(options.cert)) {
      for (let i = 0; i < options.cert.length; i++)
        c.context.setCert(options.cert[i]);
    } else {
      c.context.setCert(options.cert);
    }
  // NOTE: It is important to set the key after the cert.
  // `ssl_set_pkey` returns `0` when the key does not much the cert, but
  // `ssl_set_cert` returns `1` and nullifies the key in the SSL structure
  // which leads to the crash later on.
  if (options.key) {
    if (Array.isArray(options.key)) {
      for (let i = 0; i < options.key.length; i++) {
        var key = options.key[i];
        if (key.passphrase)
          c.context.setKey(key.pem, key.passphrase);
        else
          c.context.setKey(key);
      }
    } else {
      if (options.passphrase) {
        c.context.setKey(options.key, options.passphrase);
      } else {
        c.context.setKey(options.key);
      }
    }
  if (options.ciphers)
    c.context.setCiphers(options.ciphers);
  else
    c.context.setCiphers(tls.DEFAULT_CIPHERS);
  if (options.ecdhCurve === undefined)
    c.context.setECDHCurve(tls.DEFAULT_ECDH_CURVE);
  else if (options.ecdhCurve)
    c.context.setECDHCurve(options.ecdhCurve);
  if (options.dhparam) c.context.setDHParam(options.dhparam);
  if (options.crl) {
    if (Array.isArray(options.crl)) {
      for (let i = 0, len = options.crl.length; i < len; i++) {
        c.context.addCRL(options.crl[i]);
      }
    } else {
      c.context.addCRL(options.crl);
    }
  if (options.sessionIdContext) {
    c.context.setSessionIdContext(options.sessionIdContext);
  if (options.pfx) {
    var pfx = options.pfx;
    var passphrase = options.passphrase;
    if (!crypto)
      crypto = require('crypto');
    pfx = crypto._toBuf(pfx);
    if (passphrase)
      passphrase = crypto._toBuf(passphrase);
    if (passphrase) {
      c.context.loadPKCS12(pfx, passphrase);
    } else {
      c.context.loadPKCS12(pfx);
    }
  // Do not keep read/write buffers in free list
  if (options.singleUse) {
    c.singleUse = true;
    c.context.setFreeListLength(0);
  return c;
exports.translatePeerCertificate = function translatePeerCertificate(c) {
  if (!c)
    return null;
  if (c.issuer) c.issuer = tls.parseCertString(c.issuer);
  if (c.issuerCertificate && c.issuerCertificate !== c) {
    c.issuerCertificate = translatePeerCertificate(c.issuerCertificate);
  if (c.subject) c.subject = tls.parseCertString(c.subject);
  if (c.infoAccess) {
    var info = c.infoAccess;
    c.infoAccess = {};
    // XXX: More key validation?
    info.replace(/([^\n:]*):([^\n]*)(?:\n|$)/g, function(all, key, val) {
      if (key === '__proto__')
        return;
      if (c.infoAccess.hasOwnProperty(key))
        c.infoAccess[key].push(val);
      else
        c.infoAccess[key] = [val];
    });
  return c;
'use strict';
const assert = require('assert');
const EventEmitter = require('events');
const stream = require('stream');
const tls = require('tls');
const util = require('util');
const common = require('_tls_common');
const debug = util.debuglog('tls-legacy');
const Buffer = require('buffer').Buffer;
const Timer = process.binding('timer_wrap').Timer;
var Connection = null;
try {
  Connection = process.binding('crypto').Connection;
} catch (e) {
  throw new Error('node.js not compiled with openssl crypto support.');
function SlabBuffer() {
  this.create();
SlabBuffer.prototype.create = function create() {
  this.isFull = false;
  this.pool = new Buffer(tls.SLAB_BUFFER_SIZE);
  this.offset = 0;
  this.remaining = this.pool.length;
SlabBuffer.prototype.use = function use(context, fn, size) {
  if (this.remaining === 0) {
    this.isFull = true;
    return 0;
  var actualSize = this.remaining;
  if (size !== null) actualSize = Math.min(size, actualSize);
  var bytes = fn.call(context, this.pool, this.offset, actualSize);
  if (bytes > 0) {
    this.offset += bytes;
    this.remaining -= bytes;
  assert(this.remaining >= 0);
  return bytes;
var slabBuffer = null;
// Base class of both CleartextStream and EncryptedStream
function CryptoStream(pair, options) {
  stream.Duplex.call(this, options);
  this.pair = pair;
  this._pending = null;
  this._pendingEncoding = '';
  this._pendingCallback = null;
  this._doneFlag = false;
  this._retryAfterPartial = false;
  this._halfRead = false;
  this._sslOutCb = null;
  this._resumingSession = false;
  this._reading = true;
  this._destroyed = false;
  this._ended = false;
  this._finished = false;
  this._opposite = null;
  if (slabBuffer === null) slabBuffer = new SlabBuffer();
  this._buffer = slabBuffer;
  this.once('finish', onCryptoStreamFinish);
  // net.Socket calls .onend too
  this.once('end', onCryptoStreamEnd);
util.inherits(CryptoStream, stream.Duplex);
function onCryptoStreamFinish() {
  this._finished = true;
  if (this === this.pair.cleartext) {
    debug('cleartext.onfinish');
    if (this.pair.ssl) {
      // Generate close notify
      // NOTE: first call checks if client has sent us shutdown,
      // second call enqueues shutdown into the BIO.
      if (this.pair.ssl.shutdownSSL() !== 1) {
        if (this.pair.ssl && this.pair.ssl.error)
          return this.pair.error();
        this.pair.ssl.shutdownSSL();
      }
      if (this.pair.ssl && this.pair.ssl.error)
        return this.pair.error();
    }
  } else {
    debug('encrypted.onfinish');
  // Try to read just to get sure that we won't miss EOF
  if (this._opposite.readable) this._opposite.read(0);
  if (this._opposite._ended) {
    this._done();
    // No half-close, sorry
    if (this === this.pair.cleartext) this._opposite._done();
function onCryptoStreamEnd() {
  this._ended = true;
  if (this === this.pair.cleartext) {
    debug('cleartext.onend');
  } else {
    debug('encrypted.onend');
// NOTE: Called once `this._opposite` is set.
CryptoStream.prototype.init = function init() {
  var self = this;
  this._opposite.on('sslOutEnd', function() {
    if (self._sslOutCb) {
      var cb = self._sslOutCb;
      self._sslOutCb = null;
      cb(null);
    }
  });
CryptoStream.prototype._write = function write(data, encoding, cb) {
  assert(this._pending === null);
  // Black-hole data
  if (!this.pair.ssl) return cb(null);
  // When resuming session don't accept any new data.
  // And do not put too much data into openssl, before writing it from encrypted
  // side.
  //
  // TODO(indutny): Remove magic number, use watermark based limits
  if (!this._resumingSession &&
      this._opposite._internallyPendingBytes() < 128 * 1024) {
    // Write current buffer now
    var written;
    if (this === this.pair.cleartext) {
      debug('cleartext.write called with %d bytes', data.length);
      written = this.pair.ssl.clearIn(data, 0, data.length);
    } else {
      debug('encrypted.write called with %d bytes', data.length);
      written = this.pair.ssl.encIn(data, 0, data.length);
    }
    // Handle and report errors
    if (this.pair.ssl && this.pair.ssl.error) {
      return cb(this.pair.error(true));
    }
    // Force SSL_read call to cycle some states/data inside OpenSSL
    this.pair.cleartext.read(0);
    // Cycle encrypted data
    if (this.pair.encrypted._internallyPendingBytes())
      this.pair.encrypted.read(0);
    // Get NPN and Server name when ready
    this.pair.maybeInitFinished();
    // Whole buffer was written
    if (written === data.length) {
      if (this === this.pair.cleartext) {
        debug('cleartext.write succeed with ' + written + ' bytes');
      } else {
        debug('encrypted.write succeed with ' + written + ' bytes');
      }
      // Invoke callback only when all data read from opposite stream
      if (this._opposite._halfRead) {
        assert(this._sslOutCb === null);
        this._sslOutCb = cb;
      } else {
        cb(null);
      }
      return;
    } else if (written !== 0 && written !== -1) {
      assert(!this._retryAfterPartial);
      this._retryAfterPartial = true;
      this._write(data.slice(written), encoding, cb);
      this._retryAfterPartial = false;
      return;
    }
  } else {
    debug('cleartext.write queue is full');
    // Force SSL_read call to cycle some states/data inside OpenSSL
    this.pair.cleartext.read(0);
  // No write has happened
  this._pending = data;
  this._pendingEncoding = encoding;
  this._pendingCallback = cb;
  if (this === this.pair.cleartext) {
    debug('cleartext.write queued with %d bytes', data.length);
  } else {
    debug('encrypted.write queued with %d bytes', data.length);
CryptoStream.prototype._writePending = function writePending() {
  const data = this._pending;
  const encoding = this._pendingEncoding;
  const cb = this._pendingCallback;
  this._pending = null;
  this._pendingEncoding = '';
  this._pendingCallback = null;
  this._write(data, encoding, cb);
CryptoStream.prototype._read = function read(size) {
  // XXX: EOF?!
  if (!this.pair.ssl) return this.push(null);
  // Wait for session to be resumed
  // Mark that we're done reading, but don't provide data or EOF
  if (this._resumingSession || !this._reading) return this.push('');
  var out;
  if (this === this.pair.cleartext) {
    debug('cleartext.read called with %d bytes', size);
    out = this.pair.ssl.clearOut;
  } else {
    debug('encrypted.read called with %d bytes', size);
    out = this.pair.ssl.encOut;
  var bytesRead = 0;
  const start = this._buffer.offset;
  var last = start;
  do {
    assert(last === this._buffer.offset);
    var read = this._buffer.use(this.pair.ssl, out, size - bytesRead);
    if (read > 0) {
      bytesRead += read;
    }
    last = this._buffer.offset;
    // Handle and report errors
    if (this.pair.ssl && this.pair.ssl.error) {
      this.pair.error();
      break;
    }
  } while (read > 0 &&
           !this._buffer.isFull &&
           bytesRead < size &&
           this.pair.ssl !== null);
  // Get NPN and Server name when ready
  this.pair.maybeInitFinished();
  // Create new buffer if previous was filled up
  var pool = this._buffer.pool;
  if (this._buffer.isFull) this._buffer.create();
  assert(bytesRead >= 0);
  if (this === this.pair.cleartext) {
    debug('cleartext.read succeed with %d bytes', bytesRead);
  } else {
    debug('encrypted.read succeed with %d bytes', bytesRead);
  // Try writing pending data
  if (this._pending !== null) this._writePending();
  if (this._opposite._pending !== null) this._opposite._writePending();
  if (bytesRead === 0) {
    // EOF when cleartext has finished and we have nothing to read
    if (this._opposite._finished && this._internallyPendingBytes() === 0 ||
        this.pair.ssl && this.pair.ssl.receivedShutdown) {
      // Perform graceful shutdown
      this._done();
      // No half-open, sorry!
      if (this === this.pair.cleartext) {
        this._opposite._done();
        // EOF
        this.push(null);
      } else if (!this.pair.ssl || !this.pair.ssl.receivedShutdown) {
        // EOF
        this.push(null);
      }
    } else {
      // Bail out
      this.push('');
    }
  } else {
    // Give them requested data
    this.push(pool.slice(start, start + bytesRead));
  // Let users know that we've some internal data to read
  var halfRead = this._internallyPendingBytes() !== 0;
  // Smart check to avoid invoking 'sslOutEnd' in the most of the cases
  if (this._halfRead !== halfRead) {
    this._halfRead = halfRead;
    // Notify listeners about internal data end
    if (!halfRead) {
      if (this === this.pair.cleartext) {
        debug('cleartext.sslOutEnd');
      } else {
        debug('encrypted.sslOutEnd');
      }
      this.emit('sslOutEnd');
    }
CryptoStream.prototype.setTimeout = function(timeout, callback) {
  if (this.socket) this.socket.setTimeout(timeout, callback);
CryptoStream.prototype.setNoDelay = function(noDelay) {
  if (this.socket) this.socket.setNoDelay(noDelay);
CryptoStream.prototype.setKeepAlive = function(enable, initialDelay) {
  if (this.socket) this.socket.setKeepAlive(enable, initialDelay);
CryptoStream.prototype.__defineGetter__('bytesWritten', function() {
  return this.socket ? this.socket.bytesWritten : 0;
CryptoStream.prototype.getPeerCertificate = function(detailed) {
  if (this.pair.ssl) {
    return common.translatePeerCertificate(
        this.pair.ssl.getPeerCertificate(detailed));
  return null;
CryptoStream.prototype.getSession = function() {
  if (this.pair.ssl) {
    return this.pair.ssl.getSession();
  return null;
CryptoStream.prototype.isSessionReused = function() {
  if (this.pair.ssl) {
    return this.pair.ssl.isSessionReused();
  return null;
CryptoStream.prototype.getCipher = function(err) {
  if (this.pair.ssl) {
    return this.pair.ssl.getCurrentCipher();
  } else {
    return null;
CryptoStream.prototype.end = function(chunk, encoding) {
  if (this === this.pair.cleartext) {
    debug('cleartext.end');
  } else {
    debug('encrypted.end');
  // Write pending data first
  if (this._pending !== null) this._writePending();
  this.writable = false;
  stream.Duplex.prototype.end.call(this, chunk, encoding);
CryptoStream.prototype.destroySoon = function(err) {
  if (this === this.pair.cleartext) {
    debug('cleartext.destroySoon');
  } else {
    debug('encrypted.destroySoon');
  if (this.writable)
    this.end();
  if (this._writableState.finished && this._opposite._ended) {
    this.destroy();
  } else {
    // Wait for both `finish` and `end` events to ensure that all data that
    // was written on this side was read from the other side.
    var self = this;
    var waiting = 1;
    var finish = function() {
      if (--waiting === 0) self.destroy();
    };
    this._opposite.once('end', finish);
    if (!this._finished) {
      this.once('finish', finish);
      ++waiting;
    }
CryptoStream.prototype.destroy = function(err) {
  if (this._destroyed) return;
  this._destroyed = true;
  this.readable = this.writable = false;
  // Destroy both ends
  if (this === this.pair.cleartext) {
    debug('cleartext.destroy');
  } else {
    debug('encrypted.destroy');
  this._opposite.destroy();
  process.nextTick(destroyNT, this, err ? true : false);
function destroyNT(self, hadErr) {
  // Force EOF
  self.push(null);
  // Emit 'close' event
  self.emit('close', hadErr);
CryptoStream.prototype._done = function() {
  this._doneFlag = true;
  if (this === this.pair.encrypted && !this.pair._secureEstablished)
    return this.pair.error();
  if (this.pair.cleartext._doneFlag &&
      this.pair.encrypted._doneFlag &&
      !this.pair._doneFlag) {
    // If both streams are done:
    this.pair.destroy();
// readyState is deprecated. Don't use it.
Object.defineProperty(CryptoStream.prototype, 'readyState', {
  get: function() {
    if (this._connecting) {
      return 'opening';
    } else if (this.readable && this.writable) {
      return 'open';
    } else if (this.readable && !this.writable) {
      return 'readOnly';
    } else if (!this.readable && this.writable) {
      return 'writeOnly';
    } else {
      return 'closed';
    }
function CleartextStream(pair, options) {
  CryptoStream.call(this, pair, options);
  // This is a fake kludge to support how the http impl sits
  // on top of net Sockets
  var self = this;
  this._handle = {
    readStop: function() {
      self._reading = false;
    },
    readStart: function() {
      if (self._reading && self._readableState.length > 0) return;
      self._reading = true;
      self.read(0);
      if (self._opposite.readable) self._opposite.read(0);
    }
  };
util.inherits(CleartextStream, CryptoStream);
CleartextStream.prototype._internallyPendingBytes = function() {
  if (this.pair.ssl) {
    return this.pair.ssl.clearPending();
  } else {
    return 0;
CleartextStream.prototype.address = function() {
  return this.socket && this.socket.address();
CleartextStream.prototype.__defineGetter__('remoteAddress', function() {
  return this.socket && this.socket.remoteAddress;
CleartextStream.prototype.__defineGetter__('remoteFamily', function() {
  return this.socket && this.socket.remoteFamily;
CleartextStream.prototype.__defineGetter__('remotePort', function() {
  return this.socket && this.socket.remotePort;
CleartextStream.prototype.__defineGetter__('localAddress', function() {
  return this.socket && this.socket.localAddress;
CleartextStream.prototype.__defineGetter__('localPort', function() {
  return this.socket && this.socket.localPort;
function EncryptedStream(pair, options) {
  CryptoStream.call(this, pair, options);
util.inherits(EncryptedStream, CryptoStream);
EncryptedStream.prototype._internallyPendingBytes = function() {
  if (this.pair.ssl) {
    return this.pair.ssl.encPending();
  } else {
    return 0;
function onhandshakestart() {
  debug('onhandshakestart');
  var self = this;
  var ssl = self.ssl;
  var now = Timer.now();
  assert(now >= ssl.lastHandshakeTime);
  if ((now - ssl.lastHandshakeTime) >= tls.CLIENT_RENEG_WINDOW * 1000) {
    ssl.handshakes = 0;
  var first = (ssl.lastHandshakeTime === 0);
  ssl.lastHandshakeTime = now;
  if (first) return;
  if (++ssl.handshakes > tls.CLIENT_RENEG_LIMIT) {
    // Defer the error event to the next tick. We're being called from OpenSSL's
    // state machine and OpenSSL is not re-entrant. We cannot allow the user's
    // callback to destroy the connection right now, it would crash and burn.
    setImmediate(function() {
      var err = new Error('TLS session renegotiation attack detected.');
      if (self.cleartext) self.cleartext.emit('error', err);
    });
function onhandshakedone() {
  // for future use
  debug('onhandshakedone');
function onclienthello(hello) {
  const self = this;
  var once = false;
  this._resumingSession = true;
  function callback(err, session) {
    if (once) return;
    once = true;
    if (err) return self.socket.destroy(err);
    setImmediate(function() {
      self.ssl.loadSession(session);
      self.ssl.endParser();
      // Cycle data
      self._resumingSession = false;
      self.cleartext.read(0);
      self.encrypted.read(0);
    });
  if (hello.sessionId.length <= 0 ||
      !this.server ||
      !this.server.emit('resumeSession', hello.sessionId, callback)) {
    callback(null, null);
function onnewsession(key, session) {
  if (!this.server) return;
  var self = this;
  var once = false;
  if (!self.server.emit('newSession', key, session, done))
    done();
  function done() {
    if (once)
      return;
    once = true;
    if (self.ssl)
      self.ssl.newSessionDone();
function onocspresponse(resp) {
  this.emit('OCSPResponse', resp);
 * Provides a pair of streams to do encrypted communication.
function SecurePair(context, isServer, requestCert, rejectUnauthorized,
                    options) {
  if (!(this instanceof SecurePair)) {
    return new SecurePair(context,
                          isServer,
                          requestCert,
                          rejectUnauthorized,
                          options);
  options || (options = {});
  EventEmitter.call(this);
  this.server = options.server;
  this._secureEstablished = false;
  this._isServer = isServer ? true : false;
  this._encWriteState = true;
  this._clearWriteState = true;
  this._doneFlag = false;
  this._destroying = false;
  if (!context) {
    this.credentials = tls.createSecureContext();
  } else {
    this.credentials = context;
  if (!this._isServer) {
    // For clients, we will always have either a given ca list or be using
    // default one
    requestCert = true;
  this._rejectUnauthorized = rejectUnauthorized ? true : false;
  this._requestCert = requestCert ? true : false;
  this.ssl = new Connection(this.credentials.context,
                            this._isServer ? true : false,
                            this._isServer ? this._requestCert :
                                             options.servername,
                            this._rejectUnauthorized);
  if (this._isServer) {
    this.ssl.onhandshakestart = () => onhandshakestart.call(this);
    this.ssl.onhandshakedone = () => onhandshakedone.call(this);
    this.ssl.onclienthello = (hello) => onclienthello.call(this, hello);
    this.ssl.onnewsession =
        (key, session) => onnewsession.call(this, key, session);
    this.ssl.lastHandshakeTime = 0;
    this.ssl.handshakes = 0;
  } else {
    this.ssl.onocspresponse = (resp) => onocspresponse.call(this, resp);
  if (process.features.tls_sni) {
    if (this._isServer && options.SNICallback) {
      this.ssl.setSNICallback(options.SNICallback);
    }
    this.servername = null;
  if (process.features.tls_npn && options.NPNProtocols) {
    this.ssl.setNPNProtocols(options.NPNProtocols);
    this.npnProtocol = null;
  /* Acts as a r/w stream to the cleartext side of the stream. */
  this.cleartext = new CleartextStream(this, options.cleartext);
  /* Acts as a r/w stream to the encrypted side of the stream. */
  this.encrypted = new EncryptedStream(this, options.encrypted);
  /* Let streams know about each other */
  this.cleartext._opposite = this.encrypted;
  this.encrypted._opposite = this.cleartext;
  this.cleartext.init();
  this.encrypted.init();
  process.nextTick(securePairNT, this, options);
util.inherits(SecurePair, EventEmitter);
function securePairNT(self, options) {
  /* The Connection may be destroyed by an abort call */
  if (self.ssl) {
    self.ssl.start();
    if (options.requestOCSP)
      self.ssl.requestOCSP();
    /* In case of cipher suite failures - SSL_accept/SSL_connect may fail */
    if (self.ssl && self.ssl.error)
      self.error();
exports.createSecurePair = function(context,
                                    isServer,
                                    requestCert,
                                    rejectUnauthorized,
                                    options) {
  var pair = new SecurePair(context,
                            isServer,
                            requestCert,
                            rejectUnauthorized,
                            options);
  return pair;
SecurePair.prototype.maybeInitFinished = function() {
  if (this.ssl && !this._secureEstablished && this.ssl.isInitFinished()) {
    if (process.features.tls_npn) {
      this.npnProtocol = this.ssl.getNegotiatedProtocol();
    }
    if (process.features.tls_sni) {
      this.servername = this.ssl.getServername();
    }
    this._secureEstablished = true;
    debug('secure established');
    this.emit('secure');
SecurePair.prototype.destroy = function() {
  if (this._destroying) return;
  if (!this._doneFlag) {
    debug('SecurePair.destroy');
    this._destroying = true;
    // SecurePair should be destroyed only after it's streams
    this.cleartext.destroy();
    this.encrypted.destroy();
    this._doneFlag = true;
    this.ssl.error = null;
    this.ssl.close();
    this.ssl = null;
SecurePair.prototype.error = function(returnOnly) {
  var err = this.ssl.error;
  this.ssl.error = null;
  if (!this._secureEstablished) {
    // Emit ECONNRESET instead of zero return
    if (!err || err.message === 'ZERO_RETURN') {
      var connReset = new Error('socket hang up');
      connReset.code = 'ECONNRESET';
      connReset.sslError = err && err.message;
      err = connReset;
    }
    this.destroy();
    if (!returnOnly) this.emit('error', err);
  } else if (this._isServer &&
             this._rejectUnauthorized &&
             /peer did not return a certificate/.test(err.message)) {
    // Not really an error.
    this.destroy();
  } else {
    if (!returnOnly) this.cleartext.emit('error', err);
  return err;
exports.pipe = function pipe(pair, socket) {
  pair.encrypted.pipe(socket);
  socket.pipe(pair.encrypted);
  pair.encrypted.on('close', function() {
    process.nextTick(pipeCloseNT, pair, socket);
  });
  pair.fd = socket.fd;
  var cleartext = pair.cleartext;
  cleartext.socket = socket;
  cleartext.encrypted = pair.encrypted;
  cleartext.authorized = false;
  // cycle the data whenever the socket drains, so that
  // we can pull some more into it.  normally this would
  // be handled by the fact that pipe() triggers read() calls
  // on writable.drain, but CryptoStreams are a bit more
  // complicated.  Since the encrypted side actually gets
  // its data from the cleartext side, we have to give it a
  // light kick to get in motion again.
  socket.on('drain', function() {
    if (pair.encrypted._pending)
      pair.encrypted._writePending();
    if (pair.cleartext._pending)
      pair.cleartext._writePending();
    pair.encrypted.read(0);
    pair.cleartext.read(0);
  });
  function onerror(e) {
    if (cleartext._controlReleased) {
      cleartext.emit('error', e);
    }
  function onclose() {
    socket.removeListener('error', onerror);
    socket.removeListener('timeout', ontimeout);
  function ontimeout() {
    cleartext.emit('timeout');
  socket.on('error', onerror);
  socket.on('close', onclose);
  socket.on('timeout', ontimeout);
  return cleartext;
function pipeCloseNT(pair, socket) {
  // Encrypted should be unpiped from socket to prevent possible
  // write after destroy.
  pair.encrypted.unpipe(socket);
  socket.destroySoon();
'use strict';
const assert = require('assert');
const crypto = require('crypto');
const net = require('net');
const tls = require('tls');
const util = require('util');
const common = require('_tls_common');
const StreamWrap = require('_stream_wrap').StreamWrap;
const Buffer = require('buffer').Buffer;
const Duplex = require('stream').Duplex;
const debug = util.debuglog('tls');
const Timer = process.binding('timer_wrap').Timer;
const tls_wrap = process.binding('tls_wrap');
const TCP = process.binding('tcp_wrap').TCP;
const Pipe = process.binding('pipe_wrap').Pipe;
const defaultSessionIdContext = getDefaultSessionIdContext();
function getDefaultSessionIdContext() {
  var defaultText = process.argv.join(' ');
  /* SSL_MAX_SID_CTX_LENGTH is 128 bits */
  if (process.binding('config').fipsMode) {
    return crypto.createHash('sha1')
      .update(defaultText)
      .digest('hex').slice(0, 32);
  } else {
    return crypto.createHash('md5')
      .update(defaultText)
      .digest('hex');
function onhandshakestart() {
  debug('onhandshakestart');
  var self = this;
  var ssl = self._handle;
  var now = Timer.now();
  assert(now >= ssl.lastHandshakeTime);
  if ((now - ssl.lastHandshakeTime) >= tls.CLIENT_RENEG_WINDOW * 1000) {
    ssl.handshakes = 0;
  var first = (ssl.lastHandshakeTime === 0);
  ssl.lastHandshakeTime = now;
  if (first) return;
  if (++ssl.handshakes > tls.CLIENT_RENEG_LIMIT) {
    // Defer the error event to the next tick. We're being called from OpenSSL's
    // state machine and OpenSSL is not re-entrant. We cannot allow the user's
    // callback to destroy the connection right now, it would crash and burn.
    setImmediate(function() {
      var err = new Error('TLS session renegotiation attack detected.');
      self._emitTLSError(err);
    });
function onhandshakedone() {
  // for future use
  debug('onhandshakedone');
  this._finishInit();
function loadSession(self, hello, cb) {
  var once = false;
  function onSession(err, session) {
    if (once)
      return cb(new Error('TLS session callback was called 2 times'));
    once = true;
    if (err)
      return cb(err);
    if (!self._handle)
      return cb(new Error('Socket is closed'));
    // NOTE: That we have disabled OpenSSL's internal session storage in
    // `node_crypto.cc` and hence its safe to rely on getting servername only
    // from clienthello or this place.
    var ret = self._handle.loadSession(session);
    cb(null, ret);
  if (hello.sessionId.length <= 0 ||
      hello.tlsTicket ||
      self.server &&
      !self.server.emit('resumeSession', hello.sessionId, onSession)) {
    cb(null);
function loadSNI(self, servername, cb) {
  if (!servername || !self._SNICallback)
    return cb(null);
  var once = false;
  self._SNICallback(servername, function(err, context) {
    if (once)
      return cb(new Error('TLS SNI callback was called 2 times'));
    once = true;
    if (err)
      return cb(err);
    if (!self._handle)
      return cb(new Error('Socket is closed'));
    // TODO(indutny): eventually disallow raw `SecureContext`
    if (context)
      self._handle.sni_context = context.context || context;
    cb(null, self._handle.sni_context);
  });
function requestOCSP(self, hello, ctx, cb) {
  if (!hello.OCSPRequest || !self.server)
    return cb(null);
  if (!ctx)
    ctx = self.server._sharedCreds;
  if (ctx.context)
    ctx = ctx.context;
  if (self.server.listenerCount('OCSPRequest') === 0) {
    return cb(null);
  } else {
    self.server.emit('OCSPRequest',
                     ctx.getCertificate(),
                     ctx.getIssuer(),
                     onOCSP);
  var once = false;
  function onOCSP(err, response) {
    if (once)
      return cb(new Error('TLS OCSP callback was called 2 times'));
    once = true;
    if (err)
      return cb(err);
    if (!self._handle)
      return cb(new Error('Socket is closed'));
    if (response)
      self._handle.setOCSPResponse(response);
    cb(null);
function onclienthello(hello) {
  var self = this;
  loadSession(self, hello, function(err, session) {
    if (err)
      return self.destroy(err);
    self._handle.endParser();
  });
function oncertcb(info) {
  var self = this;
  var servername = info.servername;
  loadSNI(self, servername, function(err, ctx) {
    if (err)
      return self.destroy(err);
    requestOCSP(self, info, ctx, function(err) {
      if (err)
        return self.destroy(err);
      if (!self._handle)
        return self.destroy(new Error('Socket is closed'));
      try {
        self._handle.certCbDone();
      } catch (e) {
        self.destroy(e);
      }
    });
  });
function onnewsession(key, session) {
  if (!this.server)
    return;
  var self = this;
  var once = false;
  this._newSessionPending = true;
  if (!this.server.emit('newSession', key, session, done))
    done();
  function done() {
    if (once)
      return;
    once = true;
    if (!self._handle)
      return self.destroy(new Error('Socket is closed'));
    self._handle.newSessionDone();
    self._newSessionPending = false;
    if (self._securePending)
      self._finishInit();
    self._securePending = false;
function onocspresponse(resp) {
  this.emit('OCSPResponse', resp);
function initRead(tls, wrapped) {
  // If we were destroyed already don't bother reading
  if (!tls._handle)
    return;
  // Socket already has some buffered data - emulate receiving it
  if (wrapped && wrapped._readableState && wrapped._readableState.length) {
    var buf;
    while ((buf = wrapped.read()) !== null)
      tls._handle.receive(buf);
  tls.read(0);
 * Provides a wrap of socket stream to do encrypted communication.
function TLSSocket(socket, options) {
  if (options === undefined)
    this._tlsOptions = {};
  else
    this._tlsOptions = options;
  this._secureEstablished = false;
  this._securePending = false;
  this._newSessionPending = false;
  this._controlReleased = false;
  this._SNICallback = null;
  this.servername = null;
  this.npnProtocol = null;
  this.authorized = false;
  this.authorizationError = null;
  // Wrap plain JS Stream into StreamWrap
  var wrap;
  if (!(socket instanceof net.Socket) && socket instanceof Duplex)
    wrap = new StreamWrap(socket);
  else if ((socket instanceof net.Socket) && !socket._handle)
    wrap = new StreamWrap(socket);
  else
    wrap = socket;
  // Just a documented property to make secure sockets
  // distinguishable from regular ones.
  this.encrypted = true;
  net.Socket.call(this, {
    handle: this._wrapHandle(wrap),
    allowHalfOpen: socket && socket.allowHalfOpen,
    readable: false,
    writable: false
  });
  // Proxy for API compatibility
  this.ssl = this._handle;
  this.on('error', this._emitTLSError);
  this._init(socket, wrap);
  // Make sure to setup all required properties like: `_connecting` before
  // starting the flow of the data
  this.readable = true;
  this.writable = true;
  // Read on next tick so the caller has a chance to setup listeners
  process.nextTick(initRead, this, socket);
util.inherits(TLSSocket, net.Socket);
exports.TLSSocket = TLSSocket;
var proxiedMethods = [
  'ref', 'unref', 'open', 'bind', 'listen', 'connect', 'bind6',
  'connect6', 'getsockname', 'getpeername', 'setNoDelay', 'setKeepAlive',
  'setSimultaneousAccepts', 'setBlocking',
  // PipeWrap
  'setPendingInstances'
// Proxy HandleWrap, PipeWrap and TCPWrap methods
proxiedMethods.forEach(function(name) {
  tls_wrap.TLSWrap.prototype[name] = function methodProxy() {
    if (this._parent[name])
      return this._parent[name].apply(this._parent, arguments);
  };
tls_wrap.TLSWrap.prototype.close = function closeProxy(cb) {
  if (this.owner)
    this.owner.ssl = null;
  if (this._parentWrap && this._parentWrap._handle === this._parent) {
    this._parentWrap.once('close', cb);
    return this._parentWrap.destroy();
  return this._parent.close(cb);
TLSSocket.prototype._wrapHandle = function(wrap) {
  var res;
  var handle;
  if (wrap)
    handle = wrap._handle;
  var options = this._tlsOptions;
  if (!handle) {
    handle = options.pipe ? new Pipe() : new TCP();
    handle.owner = this;
  // Wrap socket's handle
  var context = options.secureContext ||
                options.credentials ||
                tls.createSecureContext();
  res = tls_wrap.wrap(handle._externalStream,
                      context.context,
                      !!options.isServer);
  res._parent = handle;
  res._parentWrap = wrap;
  res._secureContext = context;
  res.reading = handle.reading;
  Object.defineProperty(handle, 'reading', {
    get: function readingGetter() {
      return res.reading;
    },
    set: function readingSetter(value) {
      res.reading = value;
    }
  });
  this.on('close', function() {
    // Make sure we are not doing it on OpenSSL's stack
    setImmediate(destroySSL, this);
    res = null;
  });
  return res;
function destroySSL(self) {
  self._destroySSL();
TLSSocket.prototype._destroySSL = function _destroySSL() {
  if (!this.ssl) return;
  this.ssl.destroySSL();
  if (this.ssl._secureContext.singleUse) {
    this.ssl._secureContext.context.close();
    this.ssl._secureContext.context = null;
  this.ssl = null;
TLSSocket.prototype._init = function(socket, wrap) {
  var self = this;
  var options = this._tlsOptions;
  var ssl = this._handle;
  // lib/net.js expect this value to be non-zero if write hasn't been flushed
  // immediately
  // TODO(indutny): rewise this solution, it might be 1 before handshake and
  // represent real writeQueueSize during regular writes.
  ssl.writeQueueSize = 1;
  this.server = options.server;
  // For clients, we will always have either a given ca list or be using
  // default one
  const requestCert = !!options.requestCert || !options.isServer;
  const rejectUnauthorized = !!options.rejectUnauthorized;
  this._requestCert = requestCert;
  this._rejectUnauthorized = rejectUnauthorized;
  if (requestCert || rejectUnauthorized)
    ssl.setVerifyMode(requestCert, rejectUnauthorized);
  if (options.isServer) {
    ssl.onhandshakestart = () => onhandshakestart.call(this);
    ssl.onhandshakedone = () => onhandshakedone.call(this);
    ssl.onclienthello = (hello) => onclienthello.call(this, hello);
    ssl.oncertcb = (info) => oncertcb.call(this, info);
    ssl.onnewsession = (key, session) => onnewsession.call(this, key, session);
    ssl.lastHandshakeTime = 0;
    ssl.handshakes = 0;
    if (this.server) {
      if (this.server.listenerCount('resumeSession') > 0 ||
          this.server.listenerCount('newSession') > 0) {
        ssl.enableSessionCallbacks();
      }
      if (this.server.listenerCount('OCSPRequest') > 0)
        ssl.enableCertCb();
    }
  } else {
    ssl.onhandshakestart = function() {};
    ssl.onhandshakedone = () => this._finishInit();
    ssl.onocspresponse = (resp) => onocspresponse.call(this, resp);
    if (options.session)
      ssl.setSession(options.session);
  ssl.onerror = function(err) {
    if (self._writableState.errorEmitted)
      return;
    // Destroy socket if error happened before handshake's finish
    if (!self._secureEstablished) {
      self.destroy(self._tlsError(err));
    } else if (options.isServer &&
               rejectUnauthorized &&
               /peer did not return a certificate/.test(err.message)) {
      // Ignore server's authorization errors
      self.destroy();
    } else {
      // Throw error
      self._emitTLSError(err);
    }
    self._writableState.errorEmitted = true;
  };
  // If custom SNICallback was given, or if
  // there're SNI contexts to perform match against -
  // set `.onsniselect` callback.
  if (process.features.tls_sni &&
      options.isServer &&
      options.SNICallback &&
      options.server &&
      (options.SNICallback !== SNICallback ||
       options.server._contexts.length)) {
    assert(typeof options.SNICallback === 'function');
    this._SNICallback = options.SNICallback;
    ssl.enableCertCb();
  if (process.features.tls_npn && options.NPNProtocols)
    ssl.setNPNProtocols(options.NPNProtocols);
  if (options.handshakeTimeout > 0)
    this.setTimeout(options.handshakeTimeout, this._handleTimeout);
  if (socket instanceof net.Socket) {
    this._parent = socket;
    // To prevent assertion in afterConnect() and properly kick off readStart
    this._connecting = socket._connecting || !socket._handle;
    socket.once('connect', function() {
      self._connecting = false;
      self.emit('connect');
    });
  // Assume `tls.connect()`
  if (wrap) {
    wrap.on('error', function(err) {
      self._emitTLSError(err);
    });
  } else {
    assert(!socket);
    this._connecting = true;
TLSSocket.prototype.renegotiate = function(options, callback) {
  var requestCert = this._requestCert;
  var rejectUnauthorized = this._rejectUnauthorized;
  if (this.destroyed)
    return;
  if (typeof options.requestCert !== 'undefined')
    requestCert = !!options.requestCert;
  if (typeof options.rejectUnauthorized !== 'undefined')
    rejectUnauthorized = !!options.rejectUnauthorized;
  if (requestCert !== this._requestCert ||
      rejectUnauthorized !== this._rejectUnauthorized) {
    this._handle.setVerifyMode(requestCert, rejectUnauthorized);
    this._requestCert = requestCert;
    this._rejectUnauthorized = rejectUnauthorized;
  if (!this._handle.renegotiate()) {
    if (callback) {
      process.nextTick(callback, new Error('Failed to renegotiate'));
    }
    return false;
  // Ensure that we'll cycle through internal openssl's state
  this.write('');
  if (callback) {
    this.once('secure', function() {
      callback(null);
    });
  return true;
TLSSocket.prototype.setMaxSendFragment = function setMaxSendFragment(size) {
  return this._handle.setMaxSendFragment(size) == 1;
TLSSocket.prototype.getTLSTicket = function getTLSTicket() {
  return this._handle.getTLSTicket();
TLSSocket.prototype._handleTimeout = function() {
  this._emitTLSError(new Error('TLS handshake timeout'));
TLSSocket.prototype._emitTLSError = function(err) {
  var e = this._tlsError(err);
  if (e)
    this.emit('error', e);
TLSSocket.prototype._tlsError = function(err) {
  this.emit('_tlsError', err);
  if (this._controlReleased)
    return err;
  return null;
TLSSocket.prototype._releaseControl = function() {
  if (this._controlReleased)
    return false;
  this._controlReleased = true;
  this.removeListener('error', this._emitTLSError);
  return true;
TLSSocket.prototype._finishInit = function() {
  // `newSession` callback wasn't called yet
  if (this._newSessionPending) {
    this._securePending = true;
    return;
  if (process.features.tls_npn) {
    this.npnProtocol = this._handle.getNegotiatedProtocol();
  if (process.features.tls_sni && this._tlsOptions.isServer) {
    this.servername = this._handle.getServername();
  debug('secure established');
  this._secureEstablished = true;
  if (this._tlsOptions.handshakeTimeout > 0)
    this.setTimeout(0, this._handleTimeout);
  this.emit('secure');
TLSSocket.prototype._start = function() {
  if (this._connecting) {
    this.once('connect', function() {
      this._start();
    });
    return;
  // Socket was destroyed before the connection was established
  if (!this._handle)
    return;
  debug('start');
  if (this._tlsOptions.requestOCSP)
    this._handle.requestOCSP();
  this._handle.start();
TLSSocket.prototype.setServername = function(name) {
  this._handle.setServername(name);
TLSSocket.prototype.setSession = function(session) {
  if (typeof session === 'string')
    session = new Buffer(session, 'binary');
  this._handle.setSession(session);
TLSSocket.prototype.getPeerCertificate = function(detailed) {
  if (this._handle) {
    return common.translatePeerCertificate(
        this._handle.getPeerCertificate(detailed));
  return null;
TLSSocket.prototype.getSession = function() {
  if (this._handle) {
    return this._handle.getSession();
  return null;
TLSSocket.prototype.isSessionReused = function() {
  if (this._handle) {
    return this._handle.isSessionReused();
  return null;
TLSSocket.prototype.getCipher = function(err) {
  if (this._handle) {
    return this._handle.getCurrentCipher();
  } else {
    return null;
// TODO: support anonymous (nocert) and PSK
// AUTHENTICATION MODES
// There are several levels of authentication that TLS/SSL supports.
// Read more about this in "man SSL_set_verify".
// 1. The server sends a certificate to the client but does not request a
// cert from the client. This is common for most HTTPS servers. The browser
// can verify the identity of the server, but the server does not know who
// the client is. Authenticating the client is usually done over HTTP using
// login boxes and cookies and stuff.
// 2. The server sends a cert to the client and requests that the client
// also send it a cert. The client knows who the server is and the server is
// requesting the client also identify themselves. There are several
// outcomes:
//   A) verifyError returns null meaning the client's certificate is signed
//   by one of the server's CAs. The server know's the client idenity now
//   and the client is authorized.
//   B) For some reason the client's certificate is not acceptable -
//   verifyError returns a string indicating the problem. The server can
//   either (i) reject the client or (ii) allow the client to connect as an
//   unauthorized connection.
// The mode is controlled by two boolean variables.
// requestCert
//   If true the server requests a certificate from client connections. For
//   the common HTTPS case, users will want this to be false, which is what
//   it defaults to.
// rejectUnauthorized
//   If true clients whose certificates are invalid for any reason will not
//   be allowed to make connections. If false, they will simply be marked as
//   unauthorized but secure communication will continue. By default this is
//   true.
// Options:
// - requestCert. Send verify request. Default to false.
// - rejectUnauthorized. Boolean, default to true.
// - key. string.
// - cert: string.
// - ca: string or array of strings.
// - sessionTimeout: integer.
// emit 'secureConnection'
//   function (tlsSocket) { }
//   "UNABLE_TO_GET_ISSUER_CERT", "UNABLE_TO_GET_CRL",
//   "UNABLE_TO_DECRYPT_CERT_SIGNATURE", "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
//   "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY", "CERT_SIGNATURE_FAILURE",
//   "CRL_SIGNATURE_FAILURE", "CERT_NOT_YET_VALID" "CERT_HAS_EXPIRED",
//   "CRL_NOT_YET_VALID", "CRL_HAS_EXPIRED" "ERROR_IN_CERT_NOT_BEFORE_FIELD",
//   "ERROR_IN_CERT_NOT_AFTER_FIELD", "ERROR_IN_CRL_LAST_UPDATE_FIELD",
//   "ERROR_IN_CRL_NEXT_UPDATE_FIELD", "OUT_OF_MEM",
//   "DEPTH_ZERO_SELF_SIGNED_CERT", "SELF_SIGNED_CERT_IN_CHAIN",
//   "UNABLE_TO_GET_ISSUER_CERT_LOCALLY", "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
//   "CERT_CHAIN_TOO_LONG", "CERT_REVOKED" "INVALID_CA",
//   "PATH_LENGTH_EXCEEDED", "INVALID_PURPOSE" "CERT_UNTRUSTED",
//   "CERT_REJECTED"
function Server(/* [options], listener */) {
  var options, listener;
  if (arguments[0] !== null && typeof arguments[0] === 'object') {
    options = arguments[0];
    listener = arguments[1];
  } else if (typeof arguments[0] === 'function') {
    options = {};
    listener = arguments[0];
  if (!(this instanceof Server)) return new Server(options, listener);
  this._contexts = [];
  var self = this;
  // Handle option defaults:
  this.setOptions(options);
  var sharedCreds = tls.createSecureContext({
    pfx: self.pfx,
    key: self.key,
    passphrase: self.passphrase,
    cert: self.cert,
    ca: self.ca,
    ciphers: self.ciphers,
    ecdhCurve: self.ecdhCurve,
    dhparam: self.dhparam,
    secureProtocol: self.secureProtocol,
    secureOptions: self.secureOptions,
    honorCipherOrder: self.honorCipherOrder,
    crl: self.crl,
    sessionIdContext: self.sessionIdContext
  });
  this._sharedCreds = sharedCreds;
  var timeout = options.handshakeTimeout || (120 * 1000);
  if (typeof timeout !== 'number') {
    throw new TypeError('handshakeTimeout must be a number');
  if (self.sessionTimeout) {
    sharedCreds.context.setSessionTimeout(self.sessionTimeout);
  if (self.ticketKeys) {
    sharedCreds.context.setTicketKeys(self.ticketKeys);
  // constructor call
  net.Server.call(this, function(raw_socket) {
    var socket = new TLSSocket(raw_socket, {
      secureContext: sharedCreds,
      isServer: true,
      server: self,
      requestCert: self.requestCert,
      rejectUnauthorized: self.rejectUnauthorized,
      handshakeTimeout: timeout,
      NPNProtocols: self.NPNProtocols,
      SNICallback: options.SNICallback || SNICallback
    });
    socket.on('secure', function() {
      if (socket._requestCert) {
        var verifyError = socket._handle.verifyError();
        if (verifyError) {
          socket.authorizationError = verifyError.code;
          if (socket._rejectUnauthorized)
            socket.destroy();
        } else {
          socket.authorized = true;
        }
      }
      if (!socket.destroyed && socket._releaseControl())
        self.emit('secureConnection', socket);
    });
    var errorEmitted = false;
    socket.on('close', function(err) {
      // Closed because of error - no need to emit it twice
      if (err)
        return;
      // Emit ECONNRESET
      if (!socket._controlReleased && !errorEmitted) {
        errorEmitted = true;
        var connReset = new Error('socket hang up');
        connReset.code = 'ECONNRESET';
        self.emit('clientError', connReset, socket);
      }
    });
    socket.on('_tlsError', function(err) {
      if (!socket._controlReleased && !errorEmitted) {
        errorEmitted = true;
        self.emit('clientError', err, socket);
      }
    });
  });
  if (listener) {
    this.on('secureConnection', listener);
util.inherits(Server, net.Server);
exports.Server = Server;
exports.createServer = function(options, listener) {
  return new Server(options, listener);
Server.prototype._getServerData = function() {
  return {
    ticketKeys: this.getTicketKeys().toString('hex')
  };
Server.prototype._setServerData = function(data) {
  this.setTicketKeys(new Buffer(data.ticketKeys, 'hex'));
Server.prototype.getTicketKeys = function getTicketKeys(keys) {
  return this._sharedCreds.context.getTicketKeys(keys);
Server.prototype.setTicketKeys = function setTicketKeys(keys) {
  this._sharedCreds.context.setTicketKeys(keys);
Server.prototype.setOptions = function(options) {
  if (typeof options.requestCert === 'boolean') {
    this.requestCert = options.requestCert;
  } else {
    this.requestCert = false;
  if (typeof options.rejectUnauthorized === 'boolean') {
    this.rejectUnauthorized = options.rejectUnauthorized;
  } else {
    this.rejectUnauthorized = false;
  if (options.pfx) this.pfx = options.pfx;
  if (options.key) this.key = options.key;
  if (options.passphrase) this.passphrase = options.passphrase;
  if (options.cert) this.cert = options.cert;
  if (options.ca) this.ca = options.ca;
  if (options.secureProtocol) this.secureProtocol = options.secureProtocol;
  if (options.crl) this.crl = options.crl;
  if (options.ciphers) this.ciphers = options.ciphers;
  if (options.ecdhCurve !== undefined)
    this.ecdhCurve = options.ecdhCurve;
  if (options.dhparam) this.dhparam = options.dhparam;
  if (options.sessionTimeout) this.sessionTimeout = options.sessionTimeout;
  if (options.ticketKeys) this.ticketKeys = options.ticketKeys;
  var secureOptions = options.secureOptions || 0;
  if (options.honorCipherOrder !== undefined)
    this.honorCipherOrder = !!options.honorCipherOrder;
  else
    this.honorCipherOrder = true;
  if (secureOptions) this.secureOptions = secureOptions;
  if (options.NPNProtocols) tls.convertNPNProtocols(options.NPNProtocols, this);
  if (options.sessionIdContext) {
    this.sessionIdContext = options.sessionIdContext;
  } else {
    this.sessionIdContext = defaultSessionIdContext;
// SNI Contexts High-Level API
Server.prototype.addContext = function(servername, context) {
  if (!servername) {
    throw new Error('Servername is required parameter for Server.addContext');
  var re = new RegExp('^' +
                      servername.replace(/([\.^$+?\-\\[\]{}])/g, '\\$1')
                                .replace(/\*/g, '[^\.]*') +
                      '$');
  this._contexts.push([re, tls.createSecureContext(context).context]);
function SNICallback(servername, callback) {
  var ctx;
  this.server._contexts.some(function(elem) {
    if (servername.match(elem[0]) !== null) {
      ctx = elem[1];
      return true;
    }
  });
  callback(null, ctx);
// Target API:
//  var s = tls.connect({port: 8000, host: "google.com"}, function() {
//    if (!s.authorized) {
//      s.destroy();
//      return;
//    }
//    // s.socket;
//    s.end("hello world\n");
//  });
function normalizeConnectArgs(listArgs) {
  var args = net._normalizeConnectArgs(listArgs);
  var options = args[0];
  var cb = args[1];
  if (listArgs[1] !== null && typeof listArgs[1] === 'object') {
    options = util._extend(options, listArgs[1]);
  } else if (listArgs[2] !== null && typeof listArgs[2] === 'object') {
    options = util._extend(options, listArgs[2]);
  return (cb) ? [options, cb] : [options];
exports.connect = function(/* [port, host], options, cb */) {
  const argsLen = arguments.length;
  var args = new Array(argsLen);
  for (var i = 0; i < argsLen; i++)
    args[i] = arguments[i];
  args = normalizeConnectArgs(args);
  var options = args[0];
  var cb = args[1];
  var defaults = {
    rejectUnauthorized: '0' !== process.env.NODE_TLS_REJECT_UNAUTHORIZED,
    ciphers: tls.DEFAULT_CIPHERS,
    checkServerIdentity: tls.checkServerIdentity
  };
  options = util._extend(defaults, options || {});
  if (!options.keepAlive)
    options.singleUse = true;
  assert(typeof options.checkServerIdentity === 'function');
  var hostname = options.servername ||
                 options.host ||
                 (options.socket && options.socket._host) ||
                 'localhost';
  const NPN = {};
  const context = tls.createSecureContext(options);
  tls.convertNPNProtocols(options.NPNProtocols, NPN);
  var socket = new TLSSocket(options.socket, {
    pipe: options.path && !options.port,
    secureContext: context,
    isServer: false,
    requestCert: true,
    rejectUnauthorized: options.rejectUnauthorized,
    session: options.session,
    NPNProtocols: NPN.NPNProtocols,
    requestOCSP: options.requestOCSP
  });
  if (cb)
    socket.once('secureConnect', cb);
  if (!options.socket) {
    var connect_opt;
    if (options.path && !options.port) {
      connect_opt = { path: options.path };
    } else {
      connect_opt = {
        port: options.port,
        host: options.host,
        family: options.family,
        localAddress: options.localAddress
      };
    }
    socket.connect(connect_opt, function() {
      socket._start();
    });
  socket._releaseControl();
  if (options.session)
    socket.setSession(options.session);
  if (options.servername)
    socket.setServername(options.servername);
  if (options.socket)
    socket._start();
  socket.on('secure', function() {
    var verifyError = socket._handle.verifyError();
    // Verify that server's identity matches it's certificate's names
    // Unless server has resumed our existing session
    if (!verifyError && !socket.isSessionReused()) {
      var cert = socket.getPeerCertificate();
      verifyError = options.checkServerIdentity(hostname, cert);
    }
    if (verifyError) {
      socket.authorized = false;
      socket.authorizationError = verifyError.code || verifyError.message;
      if (options.rejectUnauthorized) {
        socket.destroy(verifyError);
        return;
      } else {
        socket.emit('secureConnect');
      }
    } else {
      socket.authorized = true;
      socket.emit('secureConnect');
    }
    // Uncork incoming data
    socket.removeListener('end', onHangUp);
  });
  function onHangUp() {
    // NOTE: This logic is shared with _http_client.js
    if (!socket._hadError) {
      socket._hadError = true;
      var error = new Error('socket hang up');
      error.code = 'ECONNRESET';
      socket.destroy(error);
    }
  socket.once('end', onHangUp);
  return socket;
'use strict';
const util = require('util');
const internalUtil = require('internal/util');
const net = require('net');
const TTY = process.binding('tty_wrap').TTY;
const isTTY = process.binding('tty_wrap').isTTY;
const inherits = util.inherits;
const errnoException = util._errnoException;
exports.isatty = function(fd) {
  return isTTY(fd);
// backwards-compat
exports.setRawMode = internalUtil.deprecate(function(flag) {
  if (!process.stdin.isTTY) {
    throw new Error('can\'t set raw mode on non-tty');
  process.stdin.setRawMode(flag);
}, 'tty.setRawMode is deprecated. ' +
   'Use process.stdin.setRawMode instead.');
function ReadStream(fd, options) {
  if (!(this instanceof ReadStream))
    return new ReadStream(fd, options);
  options = util._extend({
    highWaterMark: 0,
    readable: true,
    writable: false,
    handle: new TTY(fd, true)
  }, options);
  net.Socket.call(this, options);
  this.isRaw = false;
  this.isTTY = true;
inherits(ReadStream, net.Socket);
exports.ReadStream = ReadStream;
ReadStream.prototype.setRawMode = function(flag) {
  flag = !!flag;
  this._handle.setRawMode(flag);
  this.isRaw = flag;
function WriteStream(fd) {
  if (!(this instanceof WriteStream)) return new WriteStream(fd);
  net.Socket.call(this, {
    handle: new TTY(fd, false),
    readable: false,
    writable: true
  });
  // Prevents interleaved stdout/stderr output in OS X terminals.
  // As noted in the following reference, local TTYs tend to be quite fast and
  // this behaviour has become expected due historical functionality on OS X,
  // even though it was originally intended to change in v1.0.2 (Libuv 1.2.1).
  // Ref: https://github.com/nodejs/node/pull/1771#issuecomment-119351671
  if (process.platform === 'darwin') this._handle.setBlocking(true);
  var winSize = [];
  var err = this._handle.getWindowSize(winSize);
  if (!err) {
    this.columns = winSize[0];
    this.rows = winSize[1];
inherits(WriteStream, net.Socket);
exports.WriteStream = WriteStream;
WriteStream.prototype.isTTY = true;
WriteStream.prototype._refreshSize = function() {
  var oldCols = this.columns;
  var oldRows = this.rows;
  var winSize = [];
  var err = this._handle.getWindowSize(winSize);
  if (err) {
    this.emit('error', errnoException(err, 'getWindowSize'));
    return;
  var newCols = winSize[0];
  var newRows = winSize[1];
  if (oldCols !== newCols || oldRows !== newRows) {
    this.columns = newCols;
    this.rows = newRows;
    this.emit('resize');
// backwards-compat
WriteStream.prototype.cursorTo = function(x, y) {
  require('readline').cursorTo(this, x, y);
WriteStream.prototype.moveCursor = function(dx, dy) {
  require('readline').moveCursor(this, dx, dy);
WriteStream.prototype.clearLine = function(dir) {
  require('readline').clearLine(this, dir);
WriteStream.prototype.clearScreenDown = function() {
  require('readline').clearScreenDown(this);
WriteStream.prototype.getWindowSize = function() {
  return [this.columns, this.rows];
'use strict';
const punycode = require('punycode');
exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
// Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.
const protocolPattern = /^([a-z0-9.+-]+:)/i;
const portPattern = /:[0-9]*$/;
// Special case for a simple path URL
const simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
const delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'];
// RFC 2396: characters not allowed for various reasons.
const unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims);
// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
const autoEscape = ['\''].concat(unwise);
// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path them.
const nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape);
const hostEndingChars = ['/', '?', '#'];
const hostnameMaxLen = 255;
const hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
const hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
// protocols that can allow "unsafe" and "unwise" chars.
const unsafeProtocol = {
  'javascript': true,
  'javascript:': true
// protocols that never have a hostname.
const hostlessProtocol = {
  'javascript': true,
  'javascript:': true
// protocols that always contain a // bit.
const slashedProtocol = {
  'http': true,
  'http:': true,
  'https': true,
  'https:': true,
  'ftp': true,
  'ftp:': true,
  'gopher': true,
  'gopher:': true,
  'file': true,
  'file:': true
const querystring = require('querystring');
function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  const queryIndex = url.indexOf('?');
  const splitter =
      (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#';
  const uSplit = url.split(splitter);
  const slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url;
  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();
  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:b path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      const hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }
    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      const hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    // pull out port.
    this.parseHost();
    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';
    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';
    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (let i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  //to support http.request
  if (this.pathname || this.search) {
    const p = this.pathname || '';
    const s = this.search || '';
    this.path = p + s;
  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof obj === 'string') obj = urlParse(obj);
  else if (typeof obj !== 'object' || obj === null)
    throw new TypeError("Parameter 'urlObj' must be an object, not " +
                        obj === null ? 'null' : typeof obj);
  else if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  var protocol = this.protocol || '';
  var pathname = this.pathname || '';
  var hash = this.hash || '';
  var host = false;
  var query = '';
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  if (this.query !== null &&
      typeof this.query === 'object' &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  var search = this.search || (query && ('?' + query)) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
Url.prototype.resolveObject = function(relative) {
  if (typeof relative === 'string') {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;
  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }
    result.href = result.format();
    return result;
  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host &&
        !/^file:?$/.test(relative.protocol) &&
        !hostlessProtocol[relative.protocol]) {
      const relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  const isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/');
  const isRelAbs = (
      relative.host ||
      relative.pathname && relative.pathname.charAt(0) === '/'
  );
  var mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname));
  const removeAllDots = mustEndAbs;
  let srcPath = result.pathname && result.pathname.split('/') || [];
  const relPath = relative.pathname && relative.pathname.split('/') || [];
  const psychotic = result.protocol && !slashedProtocol[result.protocol];
  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (relative.search !== null && relative.search !== undefined) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occasionally the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      const authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');
  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (let i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      spliceOne(srcPath, i);
    } else if (last === '..') {
      spliceOne(srcPath, i);
      up++;
    } else if (up) {
      spliceOne(srcPath, i);
      up--;
    }
  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');
  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occasionally the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    const authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  //to support request.http
  if (result.pathname !== null || result.search !== null) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  if (host) this.hostname = host;
// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
'use strict';
const uv = process.binding('uv');
const Buffer = require('buffer').Buffer;
const internalUtil = require('internal/util');
const binding = process.binding('util');
const isError = internalUtil.isError;
var Debug;
function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (_) {
    return '[Circular]';
exports.format = function(f) {
  if (typeof f !== 'string') {
    const objects = new Array(arguments.length);
    for (var index = 0; index < arguments.length; index++) {
      objects[index] = inspect(arguments[index]);
    }
    return objects.join(' ');
  var argLen = arguments.length;
  if (argLen === 1) return f;
  var str = '';
  var a = 1;
  var lastPos = 0;
  for (var i = 0; i < f.length;) {
    if (f.charCodeAt(i) === 37/*'%'*/ && i + 1 < f.length) {
      switch (f.charCodeAt(i + 1)) {
        case 100: // 'd'
          if (a >= argLen)
            break;
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += Number(arguments[a++]);
          lastPos = i = i + 2;
          continue;
        case 106: // 'j'
          if (a >= argLen)
            break;
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += tryStringify(arguments[a++]);
          lastPos = i = i + 2;
          continue;
        case 115: // 's'
          if (a >= argLen)
            break;
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += String(arguments[a++]);
          lastPos = i = i + 2;
          continue;
        case 37: // '%'
          if (lastPos < i)
            str += f.slice(lastPos, i);
          str += '%';
          lastPos = i = i + 2;
          continue;
      }
    }
    ++i;
  if (lastPos === 0)
    str = f;
  else if (lastPos < f.length)
    str += f.slice(lastPos);
  while (a < argLen) {
    const x = arguments[a++];
    if (x === null || (typeof x !== 'object' && typeof x !== 'symbol')) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  return str;
exports.deprecate = internalUtil._deprecate;
var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (debugEnviron === undefined)
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  return debugs[set];
 * Echos the value of a value. Tries to print the value out
 * in the best way possible given the different types.
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (typeof opts === 'boolean') {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  // set default options
  if (ctx.showHidden === undefined) ctx.showHidden = false;
  if (ctx.depth === undefined) ctx.depth = 2;
  if (ctx.colors === undefined) ctx.colors = false;
  if (ctx.customInspect === undefined) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
exports.inspect = inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'symbol': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
function stylizeNoColor(str, styleType) {
  return str;
function arrayToHash(array) {
  var hash = {};
  for (var i = 0; i < array.length; i++) {
    var val = array[i];
    hash[val] = true;
  return hash;
function getConstructorOf(obj) {
  while (obj) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
    if (descriptor !== undefined &&
        typeof descriptor.value === 'function' &&
        descriptor.value.name !== '') {
      return descriptor.value;
    }
    obj = Object.getPrototypeOf(obj);
  return null;
function ensureDebugIsInitialized() {
  if (Debug === undefined) {
    const runInDebugContext = require('vm').runInDebugContext;
    Debug = runInDebugContext('Debug');
function inspectPromise(p) {
  ensureDebugIsInitialized();
  // Only create a mirror if the object is a Promise.
  if (!binding.isPromise(p))
    return null;
  const mirror = Debug.MakeMirror(p, true);
  return {status: mirror.status(), value: mirror.promiseValue().value_};
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
    keys = keys.concat(Object.getOwnPropertySymbols(value));
  // This could be a boxed primitive (new String(), etc.), check valueOf()
  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return
  // a number which, when object has some additional user-stored `keys`,
  // will be printed out.
  var formatted;
  var raw = value;
  try {
    // the .valueOf() call can fail for a multitude of reasons
    if (!isDate(value))
      raw = value.valueOf();
  } catch (e) {
    // ignore...
  if (typeof raw === 'string') {
    // for boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    keys = keys.filter(function(key) {
      return !(key >= 0 && key < raw.length);
    });
  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (typeof value === 'function') {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
    // now check the `raw` value to handle boxed primitives
    if (typeof raw === 'string') {
      formatted = formatPrimitiveNoColor(ctx, raw);
      return ctx.stylize('[String: ' + formatted + ']', 'string');
    }
    if (typeof raw === 'number') {
      formatted = formatPrimitiveNoColor(ctx, raw);
      return ctx.stylize('[Number: ' + formatted + ']', 'number');
    }
    if (typeof raw === 'boolean') {
      formatted = formatPrimitiveNoColor(ctx, raw);
      return ctx.stylize('[Boolean: ' + formatted + ']', 'boolean');
    }
  var constructor = getConstructorOf(value);
  var base = '', empty = false, braces, formatter;
  // We can't compare constructors for various objects using a comparison like
  // `constructor === Array` because the object could have come from a different
  // context and thus the constructor won't match. Instead we check the
  // constructor names (including those up the prototype chain where needed) to
  // determine object types.
  if (Array.isArray(value)) {
    // Unset the constructor to prevent "Array [...]" for ordinary arrays.
    if (constructor && constructor.name === 'Array')
      constructor = null;
    braces = ['[', ']'];
    empty = value.length === 0;
    formatter = formatArray;
  } else if (binding.isSet(value)) {
    braces = ['{', '}'];
    // With `showHidden`, `length` will display as a hidden property for
    // arrays. For consistency's sake, do the same for `size`, even though this
    // property isn't selected by Object.getOwnPropertyNames().
    if (ctx.showHidden)
      keys.unshift('size');
    empty = value.size === 0;
    formatter = formatSet;
  } else if (binding.isMap(value)) {
    braces = ['{', '}'];
    // Ditto.
    if (ctx.showHidden)
      keys.unshift('size');
    empty = value.size === 0;
    formatter = formatMap;
  } else {
    var promiseInternals = inspectPromise(value);
    if (promiseInternals) {
      braces = ['{', '}'];
      formatter = formatPromise;
    } else {
      if (binding.isMapIterator(value)) {
        constructor = { name: 'MapIterator' };
        braces = ['{', '}'];
        empty = false;
        formatter = formatCollectionIterator;
      } else if (binding.isSetIterator(value)) {
        constructor = { name: 'SetIterator' };
        braces = ['{', '}'];
        empty = false;
        formatter = formatCollectionIterator;
      } else {
        // Unset the constructor to prevent "Object {...}" for ordinary objects.
        if (constructor && constructor.name === 'Object')
          constructor = null;
        braces = ['{', '}'];
        empty = true;  // No other data than keys.
        formatter = formatObject;
      }
    }
  empty = empty === true && keys.length === 0;
  // Make functions say that they are functions
  if (typeof value === 'function') {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  // Make boxed primitive Strings look like such
  if (typeof raw === 'string') {
    formatted = formatPrimitiveNoColor(ctx, raw);
    base = ' ' + '[String: ' + formatted + ']';
  // Make boxed primitive Numbers look like such
  if (typeof raw === 'number') {
    formatted = formatPrimitiveNoColor(ctx, raw);
    base = ' ' + '[Number: ' + formatted + ']';
  // Make boxed primitive Booleans look like such
  if (typeof raw === 'boolean') {
    formatted = formatPrimitiveNoColor(ctx, raw);
    base = ' ' + '[Boolean: ' + formatted + ']';
  // Add constructor name if available
  if (base === '' && constructor)
    braces[0] = constructor.name + ' ' + braces[0];
  if (empty === true) {
    return braces[0] + base + braces[1];
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  ctx.seen.push(value);
  var output = formatter(ctx, value, recurseTimes, visibleKeys, keys);
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
function formatPrimitive(ctx, value) {
  if (value === undefined)
    return ctx.stylize('undefined', 'undefined');
  // For some reason typeof null is "object", so special case here.
  if (value === null)
    return ctx.stylize('null', 'null');
  var type = typeof value;
  if (type === 'string') {
    var simple = '\'' +
                 JSON.stringify(value)
                     .replace(/^"|"$/g, '')
                     .replace(/'/g, "\\'")
                     .replace(/\\"/g, '"') +
                 '\'';
    return ctx.stylize(simple, 'string');
  if (type === 'number') {
    // Format -0 as '-0'. Strict equality won't distinguish 0 from -0,
    // so instead we use the fact that 1 / -0 < 0 whereas 1 / 0 > 0 .
    if (value === 0 && 1 / value < 0)
      return ctx.stylize('-0', 'number');
    return ctx.stylize('' + value, 'number');
  if (type === 'boolean')
    return ctx.stylize('' + value, 'boolean');
  // es6 symbol primitive
  if (type === 'symbol')
    return ctx.stylize(value.toString(), 'symbol');
function formatPrimitiveNoColor(ctx, value) {
  var stylize = ctx.stylize;
  ctx.stylize = stylizeNoColor;
  var str = formatPrimitive(ctx, value);
  ctx.stylize = stylize;
  return str;
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
function formatObject(ctx, value, recurseTimes, visibleKeys, keys) {
  return keys.map(function(key) {
    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, false);
  });
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  keys.forEach(function(key) {
    if (typeof key === 'symbol' || !key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
function formatSet(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  value.forEach(function(v) {
    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;
    var str = formatValue(ctx, v, nextRecurseTimes);
    output.push(str);
  });
  keys.forEach(function(key) {
    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                               key, false));
  });
  return output;
function formatMap(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  value.forEach(function(v, k) {
    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;
    var str = formatValue(ctx, k, nextRecurseTimes);
    str += ' => ';
    str += formatValue(ctx, v, nextRecurseTimes);
    output.push(str);
  });
  keys.forEach(function(key) {
    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                               key, false));
  });
  return output;
function formatCollectionIterator(ctx, value, recurseTimes, visibleKeys, keys) {
  ensureDebugIsInitialized();
  const mirror = Debug.MakeMirror(value, true);
  var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;
  var vals = mirror.preview();
  var output = [];
  for (const o of vals) {
    output.push(formatValue(ctx, o, nextRecurseTimes));
  return output;
function formatPromise(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  var internals = inspectPromise(value);
  if (internals.status === 'pending') {
    output.push('<pending>');
  } else {
    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;
    var str = formatValue(ctx, internals.value, nextRecurseTimes);
    if (internals.status === 'rejected') {
      output.push('<rejected> ' + str);
    } else {
      output.push(str);
    }
  keys.forEach(function(key) {
    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                               key, false));
  });
  return output;
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  if (!hasOwnProperty(visibleKeys, key)) {
    if (typeof key === 'symbol') {
      name = '[' + ctx.stylize(key.toString(), 'symbol') + ']';
    } else {
      name = '[' + key + ']';
    }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.replace(/\n/g, '\n  ');
        } else {
          str = str.replace(/(^|\n)/g, '\n   ');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  if (name === undefined) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'")
                 .replace(/\\\\/g, '\\');
      name = ctx.stylize(name, 'string');
    }
  return name + ': ' + str;
function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function(prev, cur) {
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] +
           // If the opening "brace" is too large, like in the case of "Set {",
           // we need to force the first item to be on the next line or the
           // items will not line up correctly.
           (base === '' && braces[0].length === 1 ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.isArray = Array.isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
exports.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
exports.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg === null || arg === undefined;
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
exports.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
exports.isString = isString;
function isSymbol(arg) {
  return typeof arg === 'symbol';
exports.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === undefined;
exports.isUndefined = isUndefined;
function isRegExp(re) {
  return binding.isRegExp(re);
exports.isRegExp = isRegExp;
function isObject(arg) {
  return arg !== null && typeof arg === 'object';
exports.isObject = isObject;
function isDate(d) {
  return binding.isDate(d);
exports.isDate = isDate;
exports.isError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
exports.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null ||
         typeof arg !== 'object' && typeof arg !== 'function';
exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];
// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
 * Inherit the prototype methods from one constructor into another.
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 * @throws {TypeError} Will error if either constructor is null, or if
 *     the super constructor lacks a prototype.
exports.inherits = function(ctor, superCtor) {
  if (ctor === undefined || ctor === null)
    throw new TypeError('The constructor to `inherits` must not be ' +
                        'null or undefined.');
  if (superCtor === undefined || superCtor === null)
    throw new TypeError('The super constructor to `inherits` must not ' +
                        'be null or undefined.');
  if (superCtor.prototype === undefined)
    throw new TypeError('The super constructor to `inherits` must ' +
                        'have a prototype.');
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (add === null || typeof add !== 'object') return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  return origin;
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
// Deprecated old stuff.
exports.p = internalUtil.deprecate(function() {
  for (var i = 0, len = arguments.length; i < len; ++i) {
    console.error(exports.inspect(arguments[i]));
}, 'util.p is deprecated. Use console.error instead.');
exports.exec = internalUtil.deprecate(function() {
  return require('child_process').exec.apply(this, arguments);
}, 'util.exec is deprecated. Use child_process.exec instead.');
exports.print = internalUtil.deprecate(function() {
  for (var i = 0, len = arguments.length; i < len; ++i) {
    process.stdout.write(String(arguments[i]));
}, 'util.print is deprecated. Use console.log instead.');
exports.puts = internalUtil.deprecate(function() {
  for (var i = 0, len = arguments.length; i < len; ++i) {
    process.stdout.write(arguments[i] + '\n');
}, 'util.puts is deprecated. Use console.log instead.');
exports.debug = internalUtil.deprecate(function(x) {
  process.stderr.write('DEBUG: ' + x + '\n');
}, 'util.debug is deprecated. Use console.error instead.');
exports.error = internalUtil.deprecate(function(x) {
  for (var i = 0, len = arguments.length; i < len; ++i) {
    process.stderr.write(arguments[i] + '\n');
}, 'util.error is deprecated. Use console.error instead.');
exports.pump = internalUtil.deprecate(function(readStream, writeStream, cb) {
  var callbackCalled = false;
  function call(a, b, c) {
    if (cb && !callbackCalled) {
      cb(a, b, c);
      callbackCalled = true;
    }
  readStream.addListener('data', function(chunk) {
    if (writeStream.write(chunk) === false) readStream.pause();
  });
  writeStream.addListener('drain', function() {
    readStream.resume();
  });
  readStream.addListener('end', function() {
    writeStream.end();
  });
  readStream.addListener('close', function() {
    call();
  });
  readStream.addListener('error', function(err) {
    writeStream.end();
    call(err);
  });
  writeStream.addListener('error', function(err) {
    readStream.destroy();
    call(err);
  });
}, 'util.pump is deprecated. Use readableStream.pipe instead.');
exports._errnoException = function(err, syscall, original) {
  var errname = uv.errname(err);
  var message = syscall + ' ' + errname;
  if (original)
    message += ' ' + original;
  var e = new Error(message);
  e.code = errname;
  e.errno = errname;
  e.syscall = syscall;
  return e;
exports._exceptionWithHostPort = function(err,
                                          syscall,
                                          address,
                                          port,
                                          additional) {
  var details;
  if (port && port > 0) {
    details = address + ':' + port;
  } else {
    details = address;
  if (additional) {
    details += ' - Local (' + additional + ')';
  var ex = exports._errnoException(err, syscall, details);
  ex.address = address;
  if (port) {
    ex.port = port;
  return ex;
// Copyright (c) 2014, StrongLoop Inc.
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
'use strict';
const v8binding = process.binding('v8');
const heapStatisticsBuffer =
    new Uint32Array(v8binding.heapStatisticsArrayBuffer);
const kTotalHeapSizeIndex = v8binding.kTotalHeapSizeIndex;
const kTotalHeapSizeExecutableIndex = v8binding.kTotalHeapSizeExecutableIndex;
const kTotalPhysicalSizeIndex = v8binding.kTotalPhysicalSizeIndex;
const kTotalAvailableSize = v8binding.kTotalAvailableSize;
const kUsedHeapSizeIndex = v8binding.kUsedHeapSizeIndex;
const kHeapSizeLimitIndex = v8binding.kHeapSizeLimitIndex;
exports.getHeapStatistics = function() {
  const buffer = heapStatisticsBuffer;
  v8binding.updateHeapStatisticsArrayBuffer();
  return {
    'total_heap_size': buffer[kTotalHeapSizeIndex],
    'total_heap_size_executable': buffer[kTotalHeapSizeExecutableIndex],
    'total_physical_size': buffer[kTotalPhysicalSizeIndex],
    'total_available_size': buffer[kTotalAvailableSize],
    'used_heap_size': buffer[kUsedHeapSizeIndex],
    'heap_size_limit': buffer[kHeapSizeLimitIndex]
  };
exports.setFlagsFromString = v8binding.setFlagsFromString;
'use strict';
const binding = process.binding('contextify');
const Script = binding.ContextifyScript;
// The binding provides a few useful primitives:
// - ContextifyScript(code, { filename = "evalmachine.anonymous",
//                            displayErrors = true } = {})
//   with methods:
//   - runInThisContext({ displayErrors = true } = {})
//   - runInContext(sandbox, { displayErrors = true, timeout = undefined } = {})
// - makeContext(sandbox)
// - isContext(sandbox)
// From this we build the entire documented API.
Script.prototype.runInNewContext = function(sandbox, options) {
  var context = exports.createContext(sandbox);
  return this.runInContext(context, options);
exports.Script = Script;
exports.createScript = function(code, options) {
  return new Script(code, options);
exports.createContext = function(sandbox) {
  if (sandbox === undefined) {
    sandbox = {};
  } else if (binding.isContext(sandbox)) {
    return sandbox;
  binding.makeContext(sandbox);
  return sandbox;
exports.runInDebugContext = function(code) {
  return binding.runInDebugContext(code);
exports.runInContext = function(code, contextifiedSandbox, options) {
  var script = new Script(code, options);
  return script.runInContext(contextifiedSandbox, options);
exports.runInNewContext = function(code, sandbox, options) {
  var script = new Script(code, options);
  return script.runInNewContext(sandbox, options);
exports.runInThisContext = function(code, options) {
  var script = new Script(code, options);
  return script.runInThisContext(options);
exports.isContext = binding.isContext;
'use strict';
const Buffer = require('buffer').Buffer;
const Transform = require('_stream_transform');
const binding = process.binding('zlib');
const util = require('util');
const assert = require('assert').ok;
const kMaxLength = require('buffer').kMaxLength;
const kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' +
                           'than 0x' + kMaxLength.toString(16) + ' bytes.';
// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;
// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = (16 * 1024);
binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;
binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
// expose all the zlib constants
const bkeys = Object.keys(binding);
for (var bk = 0; bk < bkeys.length; bk++) {
  var bkey = bkeys[bk];
  if (bkey.match(/^Z/)) {
    Object.defineProperty(exports, bkey, {
      enumerable: true, value: binding[bkey], writable: false
    });
// translation table for return codes.
const codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
const ckeys = Object.keys(codes);
for (var ck = 0; ck < ckeys.length; ck++) {
  var ckey = ckeys[ck];
  codes[codes[ckey]] = ckey;
Object.defineProperty(exports, 'codes', {
  enumerable: true, value: Object.freeze(codes), writable: false
exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;
exports.createDeflate = function(o) {
  return new Deflate(o);
exports.createInflate = function(o) {
  return new Inflate(o);
exports.createDeflateRaw = function(o) {
  return new DeflateRaw(o);
exports.createInflateRaw = function(o) {
  return new InflateRaw(o);
exports.createGzip = function(o) {
  return new Gzip(o);
exports.createGunzip = function(o) {
  return new Gunzip(o);
exports.createUnzip = function(o) {
  return new Unzip(o);
// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  return zlibBuffer(new Deflate(opts), buffer, callback);
exports.deflateSync = function(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
exports.gzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  return zlibBuffer(new Gzip(opts), buffer, callback);
exports.gzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
exports.deflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
exports.deflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
exports.unzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  return zlibBuffer(new Unzip(opts), buffer, callback);
exports.unzipSync = function(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
exports.inflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  return zlibBuffer(new Inflate(opts), buffer, callback);
exports.inflateSync = function(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
exports.gunzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  return zlibBuffer(new Gunzip(opts), buffer, callback);
exports.gunzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
exports.inflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
exports.inflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;
  engine.on('error', onError);
  engine.on('end', onEnd);
  engine.end(buffer);
  flow();
  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  function onEnd() {
    var buf;
    var err = null;
    if (nread >= kMaxLength) {
      err = new RangeError(kRangeErrorMessage);
    } else {
      buf = Buffer.concat(buffers, nread);
    }
    buffers = [];
    engine.close();
    callback(err, buf);
function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string')
    buffer = new Buffer(buffer);
  if (!(buffer instanceof Buffer))
    throw new TypeError('Not a string or buffer');
  var flushFlag = binding.Z_FINISH;
  return engine._processChunk(buffer, flushFlag);
// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
  Transform.call(this, opts);
  if (opts.flush) {
    if (opts.flush !== binding.Z_NO_FLUSH &&
        opts.flush !== binding.Z_PARTIAL_FLUSH &&
        opts.flush !== binding.Z_SYNC_FLUSH &&
        opts.flush !== binding.Z_FULL_FLUSH &&
        opts.flush !== binding.Z_FINISH &&
        opts.flush !== binding.Z_BLOCK) {
      throw new Error('Invalid flush flag: ' + opts.flush);
    }
  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
        opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL ||
        opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &&
        opts.strategy != exports.Z_HUFFMAN_ONLY &&
        opts.strategy != exports.Z_RLE &&
        opts.strategy != exports.Z_FIXED &&
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  if (opts.dictionary) {
    if (!(opts.dictionary instanceof Buffer)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  this._handle = new binding.Zlib(mode);
  var self = this;
  this._hadError = false;
  this._handle.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    self._handle = null;
    self._hadError = true;
    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };
  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;
  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;
  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                    level,
                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                    strategy,
                    opts.dictionary);
  this._buffer = new Buffer(this._chunkSize);
  this._offset = 0;
  this._closed = false;
  this._level = level;
  this._strategy = strategy;
  this.once('end', this.close);
util.inherits(Zlib, Transform);
Zlib.prototype.params = function(level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL ||
      level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  if (strategy != exports.Z_FILTERED &&
      strategy != exports.Z_HUFFMAN_ONLY &&
      strategy != exports.Z_RLE &&
      strategy != exports.Z_FIXED &&
      strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function() {
      assert(!self._closed, 'zlib binding closed');
      self._handle.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
Zlib.prototype.reset = function() {
  assert(!this._closed, 'zlib binding closed');
  return this._handle.reset();
// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function(callback) {
  this._transform(new Buffer(0), '', callback);
Zlib.prototype.flush = function(kind, callback) {
  var ws = this._writableState;
  if (typeof kind === 'function' || (kind === undefined && !callback)) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  if (ws.ended) {
    if (callback)
      process.nextTick(callback);
  } else if (ws.ending) {
    if (callback)
      this.once('end', callback);
  } else if (ws.needDrain) {
    if (callback) {
      this.once('drain', () => this.flush(kind, callback));
    }
  } else {
    this._flushFlag = kind;
    this.write(new Buffer(0), '', callback);
Zlib.prototype.close = function(callback) {
  if (callback)
    process.nextTick(callback);
  if (this._closed)
    return;
  this._closed = true;
  if (this._handle) {
    this._handle.close();
  process.nextTick(emitCloseNT, this);
function emitCloseNT(self) {
  self.emit('close');
Zlib.prototype._transform = function(chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);
  if (chunk !== null && !(chunk instanceof Buffer))
    return cb(new Error('invalid input'));
  if (this._closed)
    return cb(new Error('zlib binding closed'));
  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last)
    flushFlag = binding.Z_FINISH;
  else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  this._processChunk(chunk, flushFlag, cb);
Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;
  var self = this;
  var async = typeof cb === 'function';
  if (!async) {
    var buffers = [];
    var nread = 0;
    var error;
    this.on('error', function(er) {
      error = er;
    });
    assert(!this._closed, 'zlib binding closed');
    do {
      var res = this._handle.writeSync(flushFlag,
                                       chunk, // in
                                       inOff, // in_off
                                       availInBefore, // in_len
                                       this._buffer, // out
                                       this._offset, //out_off
                                       availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));
    if (this._hadError) {
      throw error;
    }
    if (nread >= kMaxLength) {
      this.close();
      throw new RangeError(kRangeErrorMessage);
    }
    var buf = Buffer.concat(buffers, nread);
    this.close();
    return buf;
  assert(!this._closed, 'zlib binding closed');
  var req = this._handle.write(flushFlag,
                               chunk, // in
                               inOff, // in_off
                               availInBefore, // in_len
                               this._buffer, // out
                               this._offset, //out_off
                               availOutBefore); // out_len
  req.buffer = chunk;
  req.callback = callback;
  function callback(availInAfter, availOutAfter) {
    // When the callback is used in an async write, the callback's
    // context is the `req` object that was created. The req object
    // is === this._handle, and that's why it's important to null
    // out the values after they are done being used. `this._handle`
    // can stay in memory longer than the callback and buffer are needed.
    if (this) {
      this.buffer = null;
      this.callback = null;
    }
    if (self._hadError)
      return;
    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');
    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }
    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = new Buffer(self._chunkSize);
    }
    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;
      if (!async)
        return true;
      var newReq = self._handle.write(flushFlag,
                                      chunk,
                                      inOff,
                                      availInBefore,
                                      self._buffer,
                                      self._offset,
                                      self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }
    if (!async)
      return false;
    // finished with the chunk.
    cb();
util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);
'use strict';
const StringDecoder = require('string_decoder').StringDecoder;
const Buffer = require('buffer').Buffer;
const EventEmitter = require('events');
const net = require('net');
const dgram = require('dgram');
const util = require('util');
const constants = require('constants');
const assert = require('assert');
const Process = process.binding('process_wrap').Process;
const WriteWrap = process.binding('stream_wrap').WriteWrap;
const uv = process.binding('uv');
const Pipe = process.binding('pipe_wrap').Pipe;
const TTY = process.binding('tty_wrap').TTY;
const TCP = process.binding('tcp_wrap').TCP;
const UDP = process.binding('udp_wrap').UDP;
const SocketList = require('internal/socket_list');
const errnoException = util._errnoException;
const SocketListSend = SocketList.SocketListSend;
const SocketListReceive = SocketList.SocketListReceive;
module.exports = {
  ChildProcess,
  setupChannel,
  _validateStdio,
  getSocketList
// this object contain function to convert TCP objects to native handle objects
// and back again.
const handleConversion = {
  'net.Native': {
    simultaneousAccepts: true,
    send: function(message, handle) {
      return handle;
    },
    got: function(message, handle, emit) {
      emit(handle);
    }
  },
  'net.Server': {
    simultaneousAccepts: true,
    send: function(message, server) {
      return server._handle;
    },
    got: function(message, handle, emit) {
      var server = new net.Server();
      server.listen(handle, function() {
        emit(server);
      });
    }
  },
  'net.Socket': {
    send: function(message, socket) {
      if (!socket._handle)
        return;
      // if the socket was created by net.Server
      if (socket.server) {
        // the slave should keep track of the socket
        message.key = socket.server._connectionKey;
        var firstTime = !this._channel.sockets.send[message.key];
        var socketList = getSocketList('send', this, message.key);
        // the server should no longer expose a .connection property
        // and when asked to close it should query the socket status from
        // the slaves
        if (firstTime) socket.server._setupSlave(socketList);
        // Act like socket is detached
        socket.server._connections--;
      }
      // remove handle from socket object, it will be closed when the socket
      // will be sent
      var handle = socket._handle;
      handle.onread = function() {};
      socket._handle = null;
      return handle;
    },
    postSend: function(handle) {
      // Close the Socket handle after sending it
      if (handle)
        handle.close();
    },
    got: function(message, handle, emit) {
      var socket = new net.Socket({handle: handle});
      socket.readable = socket.writable = true;
      // if the socket was created by net.Server we will track the socket
      if (message.key) {
        // add socket to connections list
        var socketList = getSocketList('got', this, message.key);
        socketList.add({
          socket: socket
        });
      }
      emit(socket);
    }
  },
  'dgram.Native': {
    simultaneousAccepts: false,
    send: function(message, handle) {
      return handle;
    },
    got: function(message, handle, emit) {
      emit(handle);
    }
  },
  'dgram.Socket': {
    simultaneousAccepts: false,
    send: function(message, socket) {
      message.dgramType = socket.type;
      return socket._handle;
    },
    got: function(message, handle, emit) {
      var socket = new dgram.Socket(message.dgramType);
      socket.bind(handle, function() {
        emit(socket);
      });
    }
function ChildProcess() {
  EventEmitter.call(this);
  var self = this;
  this._closesNeeded = 1;
  this._closesGot = 0;
  this.connected = false;
  this.signalCode = null;
  this.exitCode = null;
  this.killed = false;
  this.spawnfile = null;
  this._handle = new Process();
  this._handle.owner = this;
  this._handle.onexit = function(exitCode, signalCode) {
    //
    // follow 0.4.x behaviour:
    //
    // - normally terminated processes don't touch this.signalCode
    // - signaled processes don't touch this.exitCode
    //
    // new in 0.9.x:
    //
    // - spawn failures are reported with exitCode < 0
    //
    var syscall = self.spawnfile ? 'spawn ' + self.spawnfile : 'spawn';
    var err = (exitCode < 0) ? errnoException(exitCode, syscall) : null;
    if (signalCode) {
      self.signalCode = signalCode;
    } else {
      self.exitCode = exitCode;
    }
    if (self.stdin) {
      self.stdin.destroy();
    }
    self._handle.close();
    self._handle = null;
    if (exitCode < 0) {
      if (self.spawnfile)
        err.path = self.spawnfile;
      err.spawnargs = self.spawnargs.slice(1);
      self.emit('error', err);
    } else {
      self.emit('exit', self.exitCode, self.signalCode);
    }
    // if any of the stdio streams have not been touched,
    // then pull all the data through so that it can get the
    // eof and emit a 'close' event.
    // Do it on nextTick so that the user has one last chance
    // to consume the output, if for example they only want to
    // start reading the data once the process exits.
    process.nextTick(flushStdio, self);
    maybeClose(self);
  };
util.inherits(ChildProcess, EventEmitter);
function flushStdio(subprocess) {
  if (subprocess.stdio == null) return;
  subprocess.stdio.forEach(function(stream, fd, stdio) {
    if (!stream || !stream.readable || stream._readableState.readableListening)
      return;
    stream.resume();
  });
function createSocket(pipe, readable) {
  var s = new net.Socket({ handle: pipe });
  if (readable) {
    s.writable = false;
    s.readable = true;
  } else {
    s.writable = true;
    s.readable = false;
  return s;
function getHandleWrapType(stream) {
  if (stream instanceof Pipe) return 'pipe';
  if (stream instanceof TTY) return 'tty';
  if (stream instanceof TCP) return 'tcp';
  if (stream instanceof UDP) return 'udp';
  return false;
ChildProcess.prototype.spawn = function(options) {
  const self = this;
  var ipc;
  var ipcFd;
  // If no `stdio` option was given - use default
  var stdio = options.stdio || 'pipe';
  stdio = _validateStdio(stdio, false);
  ipc = stdio.ipc;
  ipcFd = stdio.ipcFd;
  stdio = options.stdio = stdio.stdio;
  if (ipc !== undefined) {
    // Let child process know about opened IPC channel
    options.envPairs = options.envPairs || [];
    options.envPairs.push('NODE_CHANNEL_FD=' + ipcFd);
  this.spawnfile = options.file;
  this.spawnargs = options.args;
  var err = this._handle.spawn(options);
  // Run-time errors should emit an error, not throw an exception.
  if (err === uv.UV_EAGAIN ||
      err === uv.UV_EMFILE ||
      err === uv.UV_ENFILE ||
      err === uv.UV_ENOENT) {
    process.nextTick(onErrorNT, self, err);
    // There is no point in continuing when we've hit EMFILE or ENFILE
    // because we won't be able to set up the stdio file descriptors.
    // It's kind of silly that the de facto spec for ENOENT (the test suite)
    // mandates that stdio _is_ set up, even if there is no process on the
    // receiving end, but it is what it is.
    if (err !== uv.UV_ENOENT) return err;
  } else if (err) {
    // Close all opened fds on error
    stdio.forEach(function(stdio) {
      if (stdio.type === 'pipe') {
        stdio.handle.close();
      }
    });
    this._handle.close();
    this._handle = null;
    throw errnoException(err, 'spawn');
  this.pid = this._handle.pid;
  stdio.forEach(function(stdio, i) {
    if (stdio.type === 'ignore') return;
    if (stdio.ipc) {
      self._closesNeeded++;
      return;
    }
    if (stdio.handle) {
      // when i === 0 - we're dealing with stdin
      // (which is the only one writable pipe)
      stdio.socket = createSocket(self.pid !== 0 ? stdio.handle : null, i > 0);
      if (i > 0 && self.pid !== 0) {
        self._closesNeeded++;
        stdio.socket.on('close', function() {
          maybeClose(self);
        });
      }
    }
  });
  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?
      stdio[0].socket : null;
  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?
      stdio[1].socket : null;
  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?
      stdio[2].socket : null;
  this.stdio = stdio.map(function(stdio) {
    return stdio.socket === undefined ? null : stdio.socket;
  });
  // Add .send() method and start listening for IPC data
  if (ipc !== undefined) setupChannel(this, ipc);
  return err;
function onErrorNT(self, err) {
  self._handle.onexit(err);
ChildProcess.prototype.kill = function(sig) {
  var signal;
  if (sig === 0) {
    signal = 0;
  } else if (!sig) {
    signal = constants['SIGTERM'];
  } else {
    signal = constants[sig];
  if (signal === undefined) {
    throw new Error('Unknown signal: ' + sig);
  if (this._handle) {
    var err = this._handle.kill(signal);
    if (err === 0) {
      /* Success. */
      this.killed = true;
      return true;
    }
    if (err === uv.UV_ESRCH) {
      /* Already dead. */
    } else if (err === uv.UV_EINVAL || err === uv.UV_ENOSYS) {
      /* The underlying platform doesn't support this signal. */
      throw errnoException(err, 'kill');
    } else {
      /* Other error, almost certainly EPERM. */
      this.emit('error', errnoException(err, 'kill'));
    }
  /* Kill didn't succeed. */
  return false;
ChildProcess.prototype.ref = function() {
  if (this._handle) this._handle.ref();
ChildProcess.prototype.unref = function() {
  if (this._handle) this._handle.unref();
function setupChannel(target, channel) {
  target._channel = channel;
  target._handleQueue = null;
  const control = new class extends EventEmitter {
    constructor() {
      super();
      this.channel = channel;
      this.refs = 0;
    }
    ref() {
      if (++this.refs === 1) {
        this.channel.ref();
      }
    }
    unref() {
      if (--this.refs === 0) {
        this.channel.unref();
        this.emit('unref');
      }
    }
  };
  var decoder = new StringDecoder('utf8');
  var jsonBuffer = '';
  channel.buffering = false;
  channel.onread = function(nread, pool, recvHandle) {
    // TODO(bnoordhuis) Check that nread > 0.
    if (pool) {
      jsonBuffer += decoder.write(pool);
      var i, start = 0;
      //Linebreak is used as a message end sign
      while ((i = jsonBuffer.indexOf('\n', start)) >= 0) {
        var json = jsonBuffer.slice(start, i);
        var message = JSON.parse(json);
        // There will be at most one NODE_HANDLE message in every chunk we
        // read because SCM_RIGHTS messages don't get coalesced. Make sure
        // that we deliver the handle with the right message however.
        if (message && message.cmd === 'NODE_HANDLE')
          handleMessage(target, message, recvHandle);
        else
          handleMessage(target, message, undefined);
        start = i + 1;
      }
      jsonBuffer = jsonBuffer.slice(start);
      this.buffering = jsonBuffer.length !== 0;
    } else {
      this.buffering = false;
      target.disconnect();
      channel.onread = nop;
      channel.close();
      target._channel = null;
      maybeClose(target);
    }
  };
  // object where socket lists will live
  channel.sockets = { got: {}, send: {} };
  // handlers will go through this
  target.on('internalMessage', function(message, handle) {
    // Once acknowledged - continue sending handles.
    if (message.cmd === 'NODE_HANDLE_ACK') {
      assert(Array.isArray(target._handleQueue));
      var queue = target._handleQueue;
      target._handleQueue = null;
      queue.forEach(function(args) {
        target._send(args.message, args.handle, false, args.callback);
      });
      // Process a pending disconnect (if any).
      if (!target.connected && target._channel && !target._handleQueue)
        target._disconnect();
      return;
    }
    if (message.cmd !== 'NODE_HANDLE') return;
    // Acknowledge handle receival. Don't emit error events (for example if
    // the other side has disconnected) because this call to send() is not
    // initiated by the user and it shouldn't be fatal to be unable to ACK
    // a message.
    target._send({ cmd: 'NODE_HANDLE_ACK' }, null, true);
    var obj = handleConversion[message.type];
    // Update simultaneous accepts on Windows
    if (process.platform === 'win32') {
      handle._simultaneousAccepts = false;
      net._setSimultaneousAccepts(handle);
    }
    // Convert handle object
    obj.got.call(this, message, handle, function(handle) {
      handleMessage(target, message.msg, handle);
    });
  });
  target.send = function(message, handle, callback) {
    if (typeof handle === 'function') {
      callback = handle;
      handle = undefined;
    }
    if (this.connected) {
      this._send(message, handle, false, callback);
      return;
    }
    const ex = new Error('channel closed');
    if (typeof callback === 'function') {
      process.nextTick(callback, ex);
    } else {
      this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.
    }
  };
  target._send = function(message, handle, swallowErrors, callback) {
    assert(this.connected || this._channel);
    if (message === undefined)
      throw new TypeError('message cannot be undefined');
    // package messages with a handle object
    if (handle) {
      // this message will be handled by an internalMessage event handler
      message = {
        cmd: 'NODE_HANDLE',
        type: null,
        msg: message
      };
      if (handle instanceof net.Socket) {
        message.type = 'net.Socket';
      } else if (handle instanceof net.Server) {
        message.type = 'net.Server';
      } else if (handle instanceof TCP || handle instanceof Pipe) {
        message.type = 'net.Native';
      } else if (handle instanceof dgram.Socket) {
        message.type = 'dgram.Socket';
      } else if (handle instanceof UDP) {
        message.type = 'dgram.Native';
      } else {
        throw new TypeError("This handle type can't be sent");
      }
      // Queue-up message and handle if we haven't received ACK yet.
      if (this._handleQueue) {
        this._handleQueue.push({
          callback: callback,
          handle: handle,
          message: message.msg,
        });
        return;
      }
      var obj = handleConversion[message.type];
      // convert TCP object to native handle object
      handle =
          handleConversion[message.type].send.call(target, message, handle);
      // If handle was sent twice, or it is impossible to get native handle
      // out of it - just send a text without the handle.
      if (!handle)
        message = message.msg;
      // Update simultaneous accepts on Windows
      if (obj.simultaneousAccepts) {
        net._setSimultaneousAccepts(handle);
      }
    } else if (this._handleQueue &&
               !(message && message.cmd === 'NODE_HANDLE_ACK')) {
      // Queue request anyway to avoid out-of-order messages.
      this._handleQueue.push({
        callback: callback,
        handle: null,
        message: message,
      });
      return;
    }
    var req = new WriteWrap();
    req.async = false;
    var string = JSON.stringify(message) + '\n';
    var err = channel.writeUtf8String(req, string, handle);
    if (err === 0) {
      if (handle && !this._handleQueue)
        this._handleQueue = [];
      req.oncomplete = function() {
        if (this.async === true)
          control.unref();
        if (obj && obj.postSend)
          obj.postSend(handle);
        if (typeof callback === 'function')
          callback(null);
      };
      if (req.async === true) {
        control.ref();
      } else {
        process.nextTick(function() { req.oncomplete(); });
      }
    } else {
      // Cleanup handle on error
      if (obj && obj.postSend)
        obj.postSend(handle);
      if (!swallowErrors) {
        const ex = errnoException(err, 'write');
        if (typeof callback === 'function') {
          process.nextTick(callback, ex);
        } else {
          this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.
        }
      }
    }
    /* If the master is > 2 read() calls behind, please stop sending. */
    return channel.writeQueueSize < (65536 * 2);
  };
  // connected will be set to false immediately when a disconnect() is
  // requested, even though the channel might still be alive internally to
  // process queued messages. The three states are distinguished as follows:
  // - disconnect() never requested: _channel is not null and connected
  //   is true
  // - disconnect() requested, messages in the queue: _channel is not null
  //   and connected is false
  // - disconnect() requested, channel actually disconnected: _channel is
  //   null and connected is false
  target.connected = true;
  target.disconnect = function() {
    if (!this.connected) {
      this.emit('error', new Error('IPC channel is already disconnected'));
      return;
    }
    // Do not allow any new messages to be written.
    this.connected = false;
    // If there are no queued messages, disconnect immediately. Otherwise,
    // postpone the disconnect so that it happens internally after the
    // queue is flushed.
    if (!this._handleQueue)
      this._disconnect();
  };
  target._disconnect = function() {
    assert(this._channel);
    // This marks the fact that the channel is actually disconnected.
    this._channel = null;
    var fired = false;
    function finish() {
      if (fired) return;
      fired = true;
      channel.close();
      target.emit('disconnect');
    }
    // If a message is being read, then wait for it to complete.
    if (channel.buffering) {
      this.once('message', finish);
      this.once('internalMessage', finish);
      return;
    }
    process.nextTick(finish);
  };
  channel.readStart();
  return control;
const INTERNAL_PREFIX = 'NODE_';
function handleMessage(target, message, handle) {
  if (!target._channel)
    return;
  var eventName = 'message';
  if (message !== null &&
      typeof message === 'object' &&
      typeof message.cmd === 'string' &&
      message.cmd.length > INTERNAL_PREFIX.length &&
      message.cmd.slice(0, INTERNAL_PREFIX.length) === INTERNAL_PREFIX) {
    eventName = 'internalMessage';
  process.nextTick(() => {
    target.emit(eventName, message, handle);
  });
function nop() { }
function _validateStdio(stdio, sync) {
  var ipc;
  var ipcFd;
  // Replace shortcut with an array
  if (typeof stdio === 'string') {
    switch (stdio) {
      case 'ignore': stdio = ['ignore', 'ignore', 'ignore']; break;
      case 'pipe': stdio = ['pipe', 'pipe', 'pipe']; break;
      case 'inherit': stdio = [0, 1, 2]; break;
      default: throw new TypeError('Incorrect value of stdio option: ' + stdio);
    }
  } else if (!Array.isArray(stdio)) {
    throw new TypeError('Incorrect value of stdio option: ' +
        util.inspect(stdio));
  // At least 3 stdio will be created
  // Don't concat() a new Array() because it would be sparse, and
  // stdio.reduce() would skip the sparse elements of stdio.
  // See http://stackoverflow.com/a/5501711/3561
  while (stdio.length < 3) stdio.push(undefined);
  // Translate stdio into C++-readable form
  // (i.e. PipeWraps or fds)
  stdio = stdio.reduce(function(acc, stdio, i) {
    function cleanup() {
      acc.filter(function(stdio) {
        return stdio.type === 'pipe' || stdio.type === 'ipc';
      }).forEach(function(stdio) {
        if (stdio.handle)
          stdio.handle.close();
      });
    }
    // Defaults
    if (stdio === null || stdio === undefined) {
      stdio = i < 3 ? 'pipe' : 'ignore';
    }
    if (stdio === null || stdio === 'ignore') {
      acc.push({type: 'ignore'});
    } else if (stdio === 'pipe' || typeof stdio === 'number' && stdio < 0) {
      var a = {
        type: 'pipe',
        readable: i === 0,
        writable: i !== 0
      };
      if (!sync)
        a.handle = new Pipe();
      acc.push(a);
    } else if (stdio === 'ipc') {
      if (sync || ipc !== undefined) {
        // Cleanup previously created pipes
        cleanup();
        if (!sync)
          throw new Error('Child process can have only one IPC pipe');
        else
          throw new Error('You cannot use IPC with synchronous forks');
      }
      ipc = new Pipe(true);
      ipcFd = i;
      acc.push({
        type: 'pipe',
        handle: ipc,
        ipc: true
      });
    } else if (stdio === 'inherit') {
      acc.push({
        type: 'inherit',
        fd: i
      });
    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {
      acc.push({
        type: 'fd',
        fd: typeof stdio === 'number' ? stdio : stdio.fd
      });
    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||
               getHandleWrapType(stdio._handle)) {
      var handle = getHandleWrapType(stdio) ?
          stdio :
          getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;
      acc.push({
        type: 'wrap',
        wrapType: getHandleWrapType(handle),
        handle: handle
      });
    } else if (stdio instanceof Buffer || typeof stdio === 'string') {
      if (!sync) {
        cleanup();
        throw new TypeError('Asynchronous forks do not support Buffer input: ' +
            util.inspect(stdio));
      }
    } else {
      // Cleanup
      cleanup();
      throw new TypeError('Incorrect value for stdio stream: ' +
          util.inspect(stdio));
    }
    return acc;
  }, []);
  return {stdio: stdio, ipc: ipc, ipcFd: ipcFd};
function getSocketList(type, slave, key) {
  var sockets = slave._channel.sockets[type];
  var socketList = sockets[key];
  if (!socketList) {
    var Construct = type === 'send' ? SocketListSend : SocketListReceive;
    socketList = sockets[key] = new Construct(slave, key);
  return socketList;
function maybeClose(subprocess) {
  subprocess._closesGot++;
  if (subprocess._closesGot == subprocess._closesNeeded) {
    subprocess.emit('close', subprocess.exitCode, subprocess.signalCode);
'use strict';
// Used in tests.
exports.handles = {};
'use strict';
// This is a free list to avoid creating so many of the same object.
exports.FreeList = function(name, max, constructor) {
  this.name = name;
  this.constructor = constructor;
  this.max = max;
  this.list = [];
exports.FreeList.prototype.alloc = function() {
  return this.list.length ? this.list.pop() :
                            this.constructor.apply(this, arguments);
exports.FreeList.prototype.free = function(obj) {
  if (this.list.length < this.max) {
    this.list.push(obj);
    return true;
  return false;
'use strict';
module.exports = { isLegalPort };
// Check that the port number is not NaN when coerced to a number,
// is an integer and that it falls within the legal range of port numbers.
function isLegalPort(port) {
  if (typeof port === 'string' && port.trim() === '')
    return false;
  return +port === (port >>> 0) && port >= 0 && port <= 0xFFFF;
'use strict';
module.exports = { makeRequireFunction, stripBOM };
// Invoke with makeRequireFunction.call(module) where |module| is the
// Module object to use as the context for the require() function.
function makeRequireFunction() {
  const Module = this.constructor;
  const self = this;
  function require(path) {
    return self.require(path);
  require.resolve = function(request) {
    return Module._resolveFilename(request, self);
  };
  require.main = process.mainModule;
  // Enable support to add extra extension types.
  require.extensions = Module._extensions;
  require.cache = Module._cache;
  return require;
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 * because the buffer-to-string conversion in `fs.readFileSync()`
 * translates it to FEFF, the UTF-16 BOM.
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  return content;
'use strict';
module.exports = {SocketListSend, SocketListReceive};
const EventEmitter = require('events');
const util = require('util');
// This object keep track of the socket there are sended
function SocketListSend(slave, key) {
  EventEmitter.call(this);
  this.key = key;
  this.slave = slave;
util.inherits(SocketListSend, EventEmitter);
SocketListSend.prototype._request = function(msg, cmd, callback) {
  var self = this;
  if (!this.slave.connected) return onclose();
  this.slave.send(msg);
  function onclose() {
    self.slave.removeListener('internalMessage', onreply);
    callback(new Error('Slave closed before reply'));
  function onreply(msg) {
    if (!(msg.cmd === cmd && msg.key === self.key)) return;
    self.slave.removeListener('disconnect', onclose);
    self.slave.removeListener('internalMessage', onreply);
    callback(null, msg);
  this.slave.once('disconnect', onclose);
  this.slave.on('internalMessage', onreply);
SocketListSend.prototype.close = function close(callback) {
  this._request({
    cmd: 'NODE_SOCKET_NOTIFY_CLOSE',
    key: this.key
  }, 'NODE_SOCKET_ALL_CLOSED', callback);
SocketListSend.prototype.getConnections = function getConnections(callback) {
  this._request({
    cmd: 'NODE_SOCKET_GET_COUNT',
    key: this.key
  }, 'NODE_SOCKET_COUNT', function(err, msg) {
    if (err) return callback(err);
    callback(null, msg.count);
  });
// This object keep track of the socket there are received
function SocketListReceive(slave, key) {
  EventEmitter.call(this);
  this.connections = 0;
  this.key = key;
  this.slave = slave;
  function onempty(self) {
    if (!self.slave.connected) return;
    self.slave.send({
      cmd: 'NODE_SOCKET_ALL_CLOSED',
      key: self.key
    });
  this.slave.on('internalMessage', (msg) => {
    if (msg.key !== this.key) return;
    if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {
      // Already empty
      if (this.connections === 0) return onempty(this);
      // Wait for sockets to get closed
      this.once('empty', onempty);
    } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {
      if (!this.slave.connected) return;
      this.slave.send({
        cmd: 'NODE_SOCKET_COUNT',
        key: this.key,
        count: this.connections
      });
    }
  });
util.inherits(SocketListReceive, EventEmitter);
SocketListReceive.prototype.add = function(obj) {
  this.connections++;
  // Notify previous owner of socket about its state change
  obj.socket.once('close', () => {
    this.connections--;
    if (this.connections === 0) this.emit('empty', this);
  });
'use strict';
const Interface = require('readline').Interface;
const REPL = require('repl');
const path = require('path');
const fs = require('fs');
const os = require('os');
const debug = require('util').debuglog('repl');
module.exports = Object.create(REPL);
module.exports.createInternalRepl = createRepl;
// XXX(chrisdickinson): The 15ms debounce value is somewhat arbitrary.
// The debounce is to guard against code pasted into the REPL.
const kDebounceHistoryMS = 15;
function createRepl(env, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts;
    opts = null;
  opts = opts || {
    ignoreUndefined: false,
    terminal: process.stdout.isTTY,
    useGlobal: true
  };
  if (parseInt(env.NODE_NO_READLINE)) {
    opts.terminal = false;
  // the "dumb" special terminal, as defined by terminfo, doesn't support
  // ANSI colour control codes.
  // see http://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials
  if (parseInt(env.NODE_DISABLE_COLORS) || env.TERM === 'dumb') {
    opts.useColors = false;
  opts.replMode = {
    'strict': REPL.REPL_MODE_STRICT,
    'sloppy': REPL.REPL_MODE_SLOPPY,
    'magic': REPL.REPL_MODE_MAGIC
  }[String(env.NODE_REPL_MODE).toLowerCase().trim()];
  if (opts.replMode === undefined) {
    opts.replMode = REPL.REPL_MODE_MAGIC;
  const historySize = Number(env.NODE_REPL_HISTORY_SIZE);
  if (!isNaN(historySize) && historySize > 0) {
    opts.historySize = historySize;
  } else {
    // XXX(chrisdickinson): set here to avoid affecting existing applications
    // using repl instances.
    opts.historySize = 1000;
  const repl = REPL.start(opts);
  if (opts.terminal) {
    return setupHistory(repl, env.NODE_REPL_HISTORY,
                        env.NODE_REPL_HISTORY_FILE, cb);
  repl._historyPrev = _replHistoryMessage;
  cb(null, repl);
function setupHistory(repl, historyPath, oldHistoryPath, ready) {
  // Empty string disables persistent history.
  if (typeof historyPath === 'string')
    historyPath = historyPath.trim();
  if (historyPath === '') {
    repl._historyPrev = _replHistoryMessage;
    return ready(null, repl);
  if (!historyPath) {
    try {
      historyPath = path.join(os.homedir(), '.node_repl_history');
    } catch (err) {
      repl._writeToOutput('\nError: Could not get the home directory.\n' +
                          'REPL session history will not be persisted.\n');
      repl._refreshLine();
      debug(err.stack);
      repl._historyPrev = _replHistoryMessage;
      return ready(null, repl);
    }
  var timer = null;
  var writing = false;
  var pending = false;
  repl.pause();
  // History files are conventionally not readable by others:
  // https://github.com/nodejs/node/issues/3392
  // https://github.com/nodejs/node/pull/3394
  fs.open(historyPath, 'a+', 0o0600, oninit);
  function oninit(err, hnd) {
    if (err) {
      // Cannot open history file.
      // Don't crash, just don't persist history.
      repl._writeToOutput('\nError: Could not open history file.\n' +
                          'REPL session history will not be persisted.\n');
      repl._refreshLine();
      debug(err.stack);
      repl._historyPrev = _replHistoryMessage;
      repl.resume();
      return ready(null, repl);
    }
    fs.close(hnd, onclose);
  function onclose(err) {
    if (err) {
      return ready(err);
    }
    fs.readFile(historyPath, 'utf8', onread);
  function onread(err, data) {
    if (err) {
      return ready(err);
    }
    if (data) {
      repl.history = data.split(/[\n\r]+/, repl.historySize);
    } else if (oldHistoryPath === historyPath) {
      // If pre-v3.0, the user had set NODE_REPL_HISTORY_FILE to
      // ~/.node_repl_history, warn the user about it and proceed.
      repl._writeToOutput(
          '\nThe old repl history file has the same name and location as ' +
          `the new one i.e., ${historyPath} and is empty.\nUsing it as is.\n`);
      repl._refreshLine();
    }  else if (oldHistoryPath) {
      // Grab data from the older pre-v3.0 JSON NODE_REPL_HISTORY_FILE format.
      repl._writeToOutput(
          '\nConverting old JSON repl history to line-separated history.\n' +
          `The new repl history file can be found at ${historyPath}.\n`);
      repl._refreshLine();
      try {
        // Pre-v3.0, repl history was stored as JSON.
        // Try and convert it to line separated history.
        const oldReplJSONHistory = fs.readFileSync(oldHistoryPath, 'utf8');
        // Only attempt to use the history if there was any.
        if (oldReplJSONHistory) repl.history = JSON.parse(oldReplJSONHistory);
        if (!Array.isArray(repl.history)) {
          throw new Error('Expected array, got ' + typeof repl.history);
        }
        repl.history = repl.history.slice(0, repl.historySize);
      } catch (err) {
        if (err.code !== 'ENOENT') {
          return ready(
            new Error(`Could not parse history data in ${oldHistoryPath}.`));
        }
      }
    }
    fs.open(historyPath, 'w', onhandle);
  function onhandle(err, hnd) {
    if (err) {
      return ready(err);
    }
    repl._historyHandle = hnd;
    repl.on('line', online);
    // reading the file data out erases it
    repl.once('flushHistory', function() {
      repl.resume();
      ready(null, repl);
    });
    flushHistory();
  // ------ history listeners ------
  function online() {
    repl._flushing = true;
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(flushHistory, kDebounceHistoryMS);
  function flushHistory() {
    timer = null;
    if (writing) {
      pending = true;
      return;
    }
    writing = true;
    const historyData = repl.history.join(os.EOL);
    fs.write(repl._historyHandle, historyData, 0, 'utf8', onwritten);
  function onwritten(err, data) {
    writing = false;
    if (pending) {
      pending = false;
      online();
    } else {
      repl._flushing = Boolean(timer);
      if (!repl._flushing) {
        repl.emit('flushHistory');
      }
    }
function _replHistoryMessage() {
  if (this.history.length === 0) {
    this._writeToOutput(
        '\nPersistent history support disabled. ' +
        'Set the NODE_REPL_HISTORY environment\nvariable to ' +
        'a valid, user-writable path to enable.\n'
    );
    this._refreshLine();
  this._historyPrev = Interface.prototype._historyPrev;
  return this._historyPrev();
'use strict';
const binding = process.binding('util');
const prefix = '(node) ';
exports.getHiddenValue = binding.getHiddenValue;
// All the internal deprecations have to use this function only, as this will
// prepend the prefix to the actual message.
exports.deprecate = function(fn, msg) {
  return exports._deprecate(fn, `${prefix}${msg}`);
// All the internal deprecations have to use this function only, as this will
// prepend the prefix to the actual message.
exports.printDeprecationMessage = function(msg, warned) {
  return exports._printDeprecationMessage(`${prefix}${msg}`, warned);
exports._printDeprecationMessage = function(msg, warned) {
  if (process.noDeprecation)
    return true;
  if (warned)
    return warned;
  if (process.throwDeprecation)
    throw new Error(msg);
  else if (process.traceDeprecation)
    console.trace(msg.startsWith(prefix) ? msg.replace(prefix, '') : msg);
  else
    console.error(msg);
  return true;
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports._deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (global.process === undefined) {
    return function() {
      return exports._deprecate(fn, msg).apply(this, arguments);
    };
  if (process.noDeprecation === true) {
    return fn;
  var warned = false;
  function deprecated() {
    warned = exports._printDeprecationMessage(msg, warned);
    return fn.apply(this, arguments);
  return deprecated;
exports.decorateErrorStack = function decorateErrorStack(err) {
  if (!(exports.isError(err) && err.stack))
    return;
  const arrow = exports.getHiddenValue(err, 'arrowMessage');
  if (arrow)
    err.stack = arrow + err.stack;
exports.isError = function isError(e) {
  return exports.objectToString(e) === '[object Error]' || e instanceof Error;
exports.objectToString = function objectToString(o) {
  return Object.prototype.toString.call(o);
// Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// Node polyfill
const fs = require('fs');
const cp = require('child_process');
const os = {
  system: function(name, args) {
    if (process.platform === 'linux' && name === 'nm') {
      // Filter out vdso and vsyscall entries.
      const arg = args[args.length - 1];
      if (arg === '[vdso]' ||
          arg == '[vsyscall]' ||
          /^[0-9a-f]+-[0-9a-f]+$/.test(arg)) {
        return '';
      }
    } else if (process.platform === 'darwin') {
      args.unshift('-c', name);
      name = '/bin/sh';
    }
    return cp.spawnSync(name, args).stdout.toString();
const print = console.log;
function read(fileName) {
  return fs.readFileSync(fileName, 'utf8');
const quit = process.exit;
// Polyfill "readline()".
const logFile = arguments[arguments.length - 1];
try {
  fs.accessSync(logFile);
} catch(e) {
  console.error('Please provide a valid isolate file as the final argument.');
  process.exit(1);
const fd = fs.openSync(logFile, 'r');
const buf = new Buffer(4096);
const dec = new (require('string_decoder').StringDecoder)('utf-8');
var line = '';
versionCheck();
function readline() {
  while (true) {
    var lineBreak = line.indexOf('\n');
    if (lineBreak !== -1) {
      var res = line.slice(0, lineBreak);
      line = line.slice(lineBreak + 1);
      return res;
    }
    var bytes = fs.readSync(fd, buf, 0, buf.length);
    line += dec.write(buf.slice(0, bytes));
    if (line.length === 0) {
      return false;
    }
function versionCheck() {
  // v8-version looks like "v8-version,$major,$minor,$build,$patch,$candidate"
  // whereas process.versions.v8 is either "$major.$minor.$build" or
  // "$major.$minor.$build.$patch".
  var firstLine = readline();
  line = firstLine + '\n' + line;
  firstLine = firstLine.split(',');
  const curVer = process.versions.v8.split('.');
  if (firstLine.length !== 6 && firstLine[0] !== 'v8-version') {
    console.log('Unable to read v8-version from log file.');
    return;
  // Compare major, minor and build; ignore the patch and candidate fields.
  for (var i = 0; i < 3; i++) {
    if (curVer[i] !== firstLine[i + 1]) {
      console.log('Testing v8 version different from logging version');
      return;
    }
/* eslint-disable strict */
const scriptFiles = [
  'internal/v8_prof_polyfill',
  'v8/tools/splaytree',
  'v8/tools/codemap',
  'v8/tools/csvparser',
  'v8/tools/consarray',
  'v8/tools/profile',
  'v8/tools/profile_view',
  'v8/tools/logreader',
  'v8/tools/tickprocessor',
  'v8/tools/SourceMap',
  'v8/tools/tickprocessor-driver'
var script = '';
scriptFiles.forEach(function(s) {
  script += process.binding('natives')[s] + '\n';
var tickArguments = [];
if (process.platform === 'darwin') {
  const nm = 'foo() { nm "$@" | (c++filt -p -i || cat) }; foo $@';
  tickArguments.push('--mac', '--nm=' + nm);
} else if (process.platform === 'win32') {
  tickArguments.push('--windows');
tickArguments.push.apply(tickArguments, process.argv.slice(1));
script = 'arguments = ' + JSON.stringify(tickArguments) + ';\n' + script;
eval(script);
// LazyTransform is a special type of Transform stream that is lazily loaded.
// This is used for performance with bi-API-ship: when two APIs are available
// for the stream, one conventional and one non-conventional.
'use strict';
const stream = require('stream');
const util = require('util');
module.exports = LazyTransform;
function LazyTransform(options) {
  this._options = options;
util.inherits(LazyTransform, stream.Transform);
  '_readableState',
  '_writableState',
  '_transformState'
].forEach(function(prop, i, props) {
  Object.defineProperty(LazyTransform.prototype, prop, {
    get: function() {
      stream.Transform.call(this, this._options);
      this._writableState.decodeStrings = false;
      this._writableState.defaultEncoding = 'binary';
      return this[prop];
    },
    set: function(val) {
      Object.defineProperty(this, prop, {
        value: val,
        enumerable: true,
        configurable: true,
        writable: true
      });
    },
    configurable: true,
    enumerable: true
  });
// Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Constructs a Splay tree.  A splay tree is a self-balancing binary
 * search tree with the additional property that recently accessed
 * elements are quick to access again. It performs basic operations
 * such as insertion, look-up and removal in O(log(n)) amortized time.
 * @constructor
function SplayTree() {
 * Pointer to the root node of the tree.
 * @type {SplayTree.Node}
 * @private
SplayTree.prototype.root_ = null;
 * @return {boolean} Whether the tree is empty.
SplayTree.prototype.isEmpty = function() {
  return !this.root_;
 * Inserts a node into the tree with the specified key and value if
 * the tree does not already contain a node with the specified key. If
 * the value is inserted, it becomes the root of the tree.
 * @param {number} key Key to insert into the tree.
 * @param {*} value Value to insert into the tree.
SplayTree.prototype.insert = function(key, value) {
  if (this.isEmpty()) {
    this.root_ = new SplayTree.Node(key, value);
    return;
  // Splay on the key to move the last node on the search path for
  // the key to the root of the tree.
  this.splay_(key);
  if (this.root_.key == key) {
    return;
  var node = new SplayTree.Node(key, value);
  if (key > this.root_.key) {
    node.left = this.root_;
    node.right = this.root_.right;
    this.root_.right = null;
  } else {
    node.right = this.root_;
    node.left = this.root_.left;
    this.root_.left = null;
  this.root_ = node;
 * Removes a node with the specified key from the tree if the tree
 * contains a node with this key. The removed node is returned. If the
 * key is not found, an exception is thrown.
 * @param {number} key Key to find and remove from the tree.
 * @return {SplayTree.Node} The removed node.
SplayTree.prototype.remove = function(key) {
  if (this.isEmpty()) {
    throw Error('Key not found: ' + key);
  this.splay_(key);
  if (this.root_.key != key) {
    throw Error('Key not found: ' + key);
  var removed = this.root_;
  if (!this.root_.left) {
    this.root_ = this.root_.right;
  } else {
    var right = this.root_.right;
    this.root_ = this.root_.left;
    // Splay to make sure that the new root has an empty right child.
    this.splay_(key);
    // Insert the original right child as the right child of the new
    // root.
    this.root_.right = right;
  return removed;
 * Returns the node having the specified key or null if the tree doesn't contain
 * a node with the specified key.
 * @param {number} key Key to find in the tree.
 * @return {SplayTree.Node} Node having the specified key.
SplayTree.prototype.find = function(key) {
  if (this.isEmpty()) {
    return null;
  this.splay_(key);
  return this.root_.key == key ? this.root_ : null;
 * @return {SplayTree.Node} Node having the minimum key value.
SplayTree.prototype.findMin = function() {
  if (this.isEmpty()) {
    return null;
  var current = this.root_;
  while (current.left) {
    current = current.left;
  return current;
 * @return {SplayTree.Node} Node having the maximum key value.
SplayTree.prototype.findMax = function(opt_startNode) {
  if (this.isEmpty()) {
    return null;
  var current = opt_startNode || this.root_;
  while (current.right) {
    current = current.right;
  return current;
 * @return {SplayTree.Node} Node having the maximum key value that
 *     is less or equal to the specified key value.
SplayTree.prototype.findGreatestLessThan = function(key) {
  if (this.isEmpty()) {
    return null;
  // Splay on the key to move the node with the given key or the last
  // node on the search path to the top of the tree.
  this.splay_(key);
  // Now the result is either the root node or the greatest node in
  // the left subtree.
  if (this.root_.key <= key) {
    return this.root_;
  } else if (this.root_.left) {
    return this.findMax(this.root_.left);
  } else {
    return null;
 * @return {Array<*>} An array containing all the values of tree's nodes paired
 *     with keys.
SplayTree.prototype.exportKeysAndValues = function() {
  var result = [];
  this.traverse_(function(node) { result.push([node.key, node.value]); });
  return result;
 * @return {Array<*>} An array containing all the values of tree's nodes.
SplayTree.prototype.exportValues = function() {
  var result = [];
  this.traverse_(function(node) { result.push(node.value); });
  return result;
 * Perform the splay operation for the given key. Moves the node with
 * the given key to the top of the tree.  If no node has the given
 * key, the last node on the search path is moved to the top of the
 * tree. This is the simplified top-down splaying algorithm from:
 * "Self-adjusting Binary Search Trees" by Sleator and Tarjan
 * @param {number} key Key to splay the tree on.
 * @private
SplayTree.prototype.splay_ = function(key) {
  if (this.isEmpty()) {
    return;
  // Create a dummy node.  The use of the dummy node is a bit
  // counter-intuitive: The right child of the dummy node will hold
  // the L tree of the algorithm.  The left child of the dummy node
  // will hold the R tree of the algorithm.  Using a dummy node, left
  // and right will always be nodes and we avoid special cases.
  var dummy, left, right;
  dummy = left = right = new SplayTree.Node(null, null);
  var current = this.root_;
  while (true) {
    if (key < current.key) {
      if (!current.left) {
        break;
      }
      if (key < current.left.key) {
        // Rotate right.
        var tmp = current.left;
        current.left = tmp.right;
        tmp.right = current;
        current = tmp;
        if (!current.left) {
          break;
        }
      }
      // Link right.
      right.left = current;
      right = current;
      current = current.left;
    } else if (key > current.key) {
      if (!current.right) {
        break;
      }
      if (key > current.right.key) {
        // Rotate left.
        var tmp = current.right;
        current.right = tmp.left;
        tmp.left = current;
        current = tmp;
        if (!current.right) {
          break;
        }
      }
      // Link left.
      left.right = current;
      left = current;
      current = current.right;
    } else {
      break;
    }
  // Assemble.
  left.right = current.left;
  right.left = current.right;
  current.left = dummy.right;
  current.right = dummy.left;
  this.root_ = current;
 * Performs a preorder traversal of the tree.
 * @param {function(SplayTree.Node)} f Visitor function.
 * @private
SplayTree.prototype.traverse_ = function(f) {
  var nodesToVisit = [this.root_];
  while (nodesToVisit.length > 0) {
    var node = nodesToVisit.shift();
    if (node == null) {
      continue;
    }
    f(node);
    nodesToVisit.push(node.left);
    nodesToVisit.push(node.right);
 * Constructs a Splay tree node.
 * @param {number} key Key.
 * @param {*} value Value.
SplayTree.Node = function(key, value) {
  this.key = key;
  this.value = value;
 * @type {SplayTree.Node}
SplayTree.Node.prototype.left = null;
 * @type {SplayTree.Node}
SplayTree.Node.prototype.right = null;
// Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Constructs a mapper that maps addresses into code entries.
 * @constructor
function CodeMap() {
  /**
   * Dynamic code entries. Used for JIT compiled code.
   */
  this.dynamics_ = new SplayTree();
  /**
   * Name generator for entries having duplicate names.
   */
  this.dynamicsNameGen_ = new CodeMap.NameGenerator();
  /**
   * Static code entries. Used for statically compiled code.
   */
  this.statics_ = new SplayTree();
  /**
   * Libraries entries. Used for the whole static code libraries.
   */
  this.libraries_ = new SplayTree();
  /**
   * Map of memory pages occupied with static code.
   */
  this.pages_ = [];
 * The number of alignment bits in a page address.
CodeMap.PAGE_ALIGNMENT = 12;
 * Page size in bytes.
CodeMap.PAGE_SIZE =
    1 << CodeMap.PAGE_ALIGNMENT;
 * Adds a dynamic (i.e. moveable and discardable) code entry.
 * @param {number} start The starting address.
 * @param {CodeMap.CodeEntry} codeEntry Code entry object.
CodeMap.prototype.addCode = function(start, codeEntry) {
  this.deleteAllCoveredNodes_(this.dynamics_, start, start + codeEntry.size);
  this.dynamics_.insert(start, codeEntry);
 * Moves a dynamic code entry. Throws an exception if there is no dynamic
 * code entry with the specified starting address.
 * @param {number} from The starting address of the entry being moved.
 * @param {number} to The destination address.
CodeMap.prototype.moveCode = function(from, to) {
  var removedNode = this.dynamics_.remove(from);
  this.deleteAllCoveredNodes_(this.dynamics_, to, to + removedNode.value.size);
  this.dynamics_.insert(to, removedNode.value);
 * Discards a dynamic code entry. Throws an exception if there is no dynamic
 * code entry with the specified starting address.
 * @param {number} start The starting address of the entry being deleted.
CodeMap.prototype.deleteCode = function(start) {
  var removedNode = this.dynamics_.remove(start);
 * Adds a library entry.
 * @param {number} start The starting address.
 * @param {CodeMap.CodeEntry} codeEntry Code entry object.
CodeMap.prototype.addLibrary = function(
    start, codeEntry) {
  this.markPages_(start, start + codeEntry.size);
  this.libraries_.insert(start, codeEntry);
 * Adds a static code entry.
 * @param {number} start The starting address.
 * @param {CodeMap.CodeEntry} codeEntry Code entry object.
CodeMap.prototype.addStaticCode = function(
    start, codeEntry) {
  this.statics_.insert(start, codeEntry);
 * @private
CodeMap.prototype.markPages_ = function(start, end) {
  for (var addr = start; addr <= end;
       addr += CodeMap.PAGE_SIZE) {
    this.pages_[addr >>> CodeMap.PAGE_ALIGNMENT] = 1;
 * @private
CodeMap.prototype.deleteAllCoveredNodes_ = function(tree, start, end) {
  var to_delete = [];
  var addr = end - 1;
  while (addr >= start) {
    var node = tree.findGreatestLessThan(addr);
    if (!node) break;
    var start2 = node.key, end2 = start2 + node.value.size;
    if (start2 < end && start < end2) to_delete.push(start2);
    addr = start2 - 1;
  for (var i = 0, l = to_delete.length; i < l; ++i) tree.remove(to_delete[i]);
 * @private
CodeMap.prototype.isAddressBelongsTo_ = function(addr, node) {
  return addr >= node.key && addr < (node.key + node.value.size);
 * @private
CodeMap.prototype.findInTree_ = function(tree, addr) {
  var node = tree.findGreatestLessThan(addr);
  return node && this.isAddressBelongsTo_(addr, node) ? node.value : null;
 * Finds a code entry that contains the specified address. Both static and
 * dynamic code entries are considered.
 * @param {number} addr Address.
CodeMap.prototype.findEntry = function(addr) {
  var pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
  if (pageAddr in this.pages_) {
    // Static code entries can contain "holes" of unnamed code.
    // In this case, the whole library is assigned to this address.
    return this.findInTree_(this.statics_, addr) ||
        this.findInTree_(this.libraries_, addr);
  var min = this.dynamics_.findMin();
  var max = this.dynamics_.findMax();
  if (max != null && addr < (max.key + max.value.size) && addr >= min.key) {
    var dynaEntry = this.findInTree_(this.dynamics_, addr);
    if (dynaEntry == null) return null;
    // Dedupe entry name.
    if (!dynaEntry.nameUpdated_) {
      dynaEntry.name = this.dynamicsNameGen_.getName(dynaEntry.name);
      dynaEntry.nameUpdated_ = true;
    }
    return dynaEntry;
  return null;
 * Returns a dynamic code entry using its starting address.
 * @param {number} addr Address.
CodeMap.prototype.findDynamicEntryByStartAddress =
    function(addr) {
  var node = this.dynamics_.find(addr);
  return node ? node.value : null;
 * Returns an array of all dynamic code entries.
CodeMap.prototype.getAllDynamicEntries = function() {
  return this.dynamics_.exportValues();
 * Returns an array of pairs of all dynamic code entries and their addresses.
CodeMap.prototype.getAllDynamicEntriesWithAddresses = function() {
  return this.dynamics_.exportKeysAndValues();
 * Returns an array of all static code entries.
CodeMap.prototype.getAllStaticEntries = function() {
  return this.statics_.exportValues();
 * Returns an array of all libraries entries.
CodeMap.prototype.getAllLibrariesEntries = function() {
  return this.libraries_.exportValues();
 * Creates a code entry object.
 * @param {number} size Code entry size in bytes.
 * @param {string} opt_name Code entry name.
 * @param {string} opt_type Code entry type, e.g. SHARED_LIB, CPP.
 * @constructor
CodeMap.CodeEntry = function(size, opt_name, opt_type) {
  this.size = size;
  this.name = opt_name || '';
  this.type = opt_type || '';
  this.nameUpdated_ = false;
CodeMap.CodeEntry.prototype.getName = function() {
  return this.name;
CodeMap.CodeEntry.prototype.toString = function() {
  return this.name + ': ' + this.size.toString(16);
CodeMap.NameGenerator = function() {
  this.knownNames_ = {};
CodeMap.NameGenerator.prototype.getName = function(name) {
  if (!(name in this.knownNames_)) {
    this.knownNames_[name] = 0;
    return name;
  var count = ++this.knownNames_[name];
  return name + ' {' + count + '}';
// Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Constructs a ConsArray object. It is used mainly for tree traversal.
 * In this use case we have lots of arrays that we need to iterate
 * sequentally. The internal Array implementation is horribly slow
 * when concatenating on large (10K items) arrays due to memory copying.
 * That's why we avoid copying memory and insead build a linked list
 * of arrays to iterate through.
 * @constructor
function ConsArray() {
  this.tail_ = new ConsArray.Cell(null, null);
  this.currCell_ = this.tail_;
  this.currCellPos_ = 0;
 * Concatenates another array for iterating. Empty arrays are ignored.
 * This operation can be safely performed during ongoing ConsArray
 * iteration.
 * @param {Array} arr Array to concatenate.
ConsArray.prototype.concat = function(arr) {
  if (arr.length > 0) {
    this.tail_.data = arr;
    this.tail_ = this.tail_.next = new ConsArray.Cell(null, null);
 * Whether the end of iteration is reached.
ConsArray.prototype.atEnd = function() {
  return this.currCell_ === null ||
      this.currCell_.data === null ||
      this.currCellPos_ >= this.currCell_.data.length;
 * Returns the current item, moves to the next one.
ConsArray.prototype.next = function() {
  var result = this.currCell_.data[this.currCellPos_++];
  if (this.currCellPos_ >= this.currCell_.data.length) {
    this.currCell_ = this.currCell_.next;
    this.currCellPos_ = 0;
  return result;
 * A cell object used for constructing a list in ConsArray.
 * @constructor
ConsArray.Cell = function(data, next) {
  this.data = data;
  this.next = next;
// Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Creates a CSV lines parser.
function CsvParser() {
 * A regex for matching a CSV field.
 * @private
CsvParser.CSV_FIELD_RE_ = /^"((?:[^"]|"")*)"|([^,]*)/;
 * A regex for matching a double quote.
 * @private
CsvParser.DOUBLE_QUOTE_RE_ = /""/g;
 * Parses a line of CSV-encoded values. Returns an array of fields.
 * @param {string} line Input line.
CsvParser.prototype.parseLine = function(line) {
  var fieldRe = CsvParser.CSV_FIELD_RE_;
  var doubleQuoteRe = CsvParser.DOUBLE_QUOTE_RE_;
  var pos = 0;
  var endPos = line.length;
  var fields = [];
  if (endPos > 0) {
    do {
      var fieldMatch = fieldRe.exec(line.substr(pos));
      if (typeof fieldMatch[1] === "string") {
        var field = fieldMatch[1];
        pos += field.length + 3;  // Skip comma and quotes.
        fields.push(field.replace(doubleQuoteRe, '"'));
      } else {
        // The second field pattern will match anything, thus
        // in the worst case the match will be an empty string.
        var field = fieldMatch[2];
        pos += field.length + 1;  // Skip comma.
        fields.push(field);
      }
    } while (pos <= endPos);
  return fields;
// Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Creates a profile object for processing profiling-related events
 * and calculating function execution times.
 * @constructor
function Profile() {
  this.codeMap_ = new CodeMap();
  this.topDownTree_ = new CallTree();
  this.bottomUpTree_ = new CallTree();
  this.c_entries_ = {};
 * Returns whether a function with the specified name must be skipped.
 * Should be overriden by subclasses.
 * @param {string} name Function name.
Profile.prototype.skipThisFunction = function(name) {
  return false;
 * Enum for profiler operations that involve looking up existing
 * code entries.
 * @enum {number}
Profile.Operation = {
  MOVE: 0,
  DELETE: 1,
  TICK: 2
 * Enum for code state regarding its dynamic optimization.
 * @enum {number}
Profile.CodeState = {
  COMPILED: 0,
  OPTIMIZABLE: 1,
  OPTIMIZED: 2
 * Called whenever the specified operation has failed finding a function
 * containing the specified address. Should be overriden by subclasses.
 * See the Profile.Operation enum for the list of
 * possible operations.
 * @param {number} operation Operation.
 * @param {number} addr Address of the unknown code.
 * @param {number} opt_stackPos If an unknown address is encountered
 *     during stack strace processing, specifies a position of the frame
 *     containing the address.
Profile.prototype.handleUnknownCode = function(
    operation, addr, opt_stackPos) {
 * Registers a library.
 * @param {string} name Code entry name.
 * @param {number} startAddr Starting address.
 * @param {number} endAddr Ending address.
Profile.prototype.addLibrary = function(
    name, startAddr, endAddr) {
  var entry = new CodeMap.CodeEntry(
      endAddr - startAddr, name, 'SHARED_LIB');
  this.codeMap_.addLibrary(startAddr, entry);
  return entry;
 * Registers statically compiled code entry.
 * @param {string} name Code entry name.
 * @param {number} startAddr Starting address.
 * @param {number} endAddr Ending address.
Profile.prototype.addStaticCode = function(
    name, startAddr, endAddr) {
  var entry = new CodeMap.CodeEntry(
      endAddr - startAddr, name, 'CPP');
  this.codeMap_.addStaticCode(startAddr, entry);
  return entry;
 * Registers dynamic (JIT-compiled) code entry.
 * @param {string} type Code entry type.
 * @param {string} name Code entry name.
 * @param {number} start Starting address.
 * @param {number} size Code entry size.
Profile.prototype.addCode = function(
    type, name, start, size) {
  var entry = new Profile.DynamicCodeEntry(size, type, name);
  this.codeMap_.addCode(start, entry);
  return entry;
 * Registers dynamic (JIT-compiled) code entry.
 * @param {string} type Code entry type.
 * @param {string} name Code entry name.
 * @param {number} start Starting address.
 * @param {number} size Code entry size.
 * @param {number} funcAddr Shared function object address.
 * @param {Profile.CodeState} state Optimization state.
Profile.prototype.addFuncCode = function(
    type, name, start, size, funcAddr, state) {
  // As code and functions are in the same address space,
  // it is safe to put them in a single code map.
  var func = this.codeMap_.findDynamicEntryByStartAddress(funcAddr);
  if (!func) {
    func = new Profile.FunctionEntry(name);
    this.codeMap_.addCode(funcAddr, func);
  } else if (func.name !== name) {
    // Function object has been overwritten with a new one.
    func.name = name;
  var entry = this.codeMap_.findDynamicEntryByStartAddress(start);
  if (entry) {
    if (entry.size === size && entry.func === func) {
      // Entry state has changed.
      entry.state = state;
    }
  } else {
    entry = new Profile.DynamicFuncCodeEntry(size, type, func, state);
    this.codeMap_.addCode(start, entry);
  return entry;
 * Reports about moving of a dynamic code entry.
 * @param {number} from Current code entry address.
 * @param {number} to New code entry address.
Profile.prototype.moveCode = function(from, to) {
  try {
    this.codeMap_.moveCode(from, to);
  } catch (e) {
    this.handleUnknownCode(Profile.Operation.MOVE, from);
 * Reports about deletion of a dynamic code entry.
 * @param {number} start Starting address.
Profile.prototype.deleteCode = function(start) {
  try {
    this.codeMap_.deleteCode(start);
  } catch (e) {
    this.handleUnknownCode(Profile.Operation.DELETE, start);
 * Reports about moving of a dynamic code entry.
 * @param {number} from Current code entry address.
 * @param {number} to New code entry address.
Profile.prototype.moveFunc = function(from, to) {
  if (this.codeMap_.findDynamicEntryByStartAddress(from)) {
    this.codeMap_.moveCode(from, to);
 * Retrieves a code entry by an address.
 * @param {number} addr Entry address.
Profile.prototype.findEntry = function(addr) {
  return this.codeMap_.findEntry(addr);
 * Records a tick event. Stack must contain a sequence of
 * addresses starting with the program counter value.
 * @param {Array<number>} stack Stack sample.
Profile.prototype.recordTick = function(stack) {
  var processedStack = this.resolveAndFilterFuncs_(stack);
  this.bottomUpTree_.addPath(processedStack);
  processedStack.reverse();
  this.topDownTree_.addPath(processedStack);
 * Translates addresses into function names and filters unneeded
 * functions.
 * @param {Array<number>} stack Stack sample.
Profile.prototype.resolveAndFilterFuncs_ = function(stack) {
  var result = [];
  var last_seen_c_function = '';
  var look_for_first_c_function = false;
  for (var i = 0; i < stack.length; ++i) {
    var entry = this.codeMap_.findEntry(stack[i]);
    if (entry) {
      var name = entry.getName();
      if (i === 0 && (entry.type === 'CPP' || entry.type === 'SHARED_LIB')) {
        look_for_first_c_function = true;
      }
      if (look_for_first_c_function && entry.type === 'CPP') {
        last_seen_c_function = name;
      }
      if (!this.skipThisFunction(name)) {
        result.push(name);
      }
    } else {
      this.handleUnknownCode(Profile.Operation.TICK, stack[i], i);
      if (i === 0) result.push("UNKNOWN");
    }
    if (look_for_first_c_function &&
        i > 0 &&
        (!entry || entry.type !== 'CPP') &&
        last_seen_c_function !== '') {
      if (this.c_entries_[last_seen_c_function] === undefined) {
        this.c_entries_[last_seen_c_function] = 0;
      }
      this.c_entries_[last_seen_c_function]++;
      look_for_first_c_function = false;  // Found it, we're done.
    }
  return result;
 * Performs a BF traversal of the top down call graph.
 * @param {function(CallTree.Node)} f Visitor function.
Profile.prototype.traverseTopDownTree = function(f) {
  this.topDownTree_.traverse(f);
 * Performs a BF traversal of the bottom up call graph.
 * @param {function(CallTree.Node)} f Visitor function.
Profile.prototype.traverseBottomUpTree = function(f) {
  this.bottomUpTree_.traverse(f);
 * Calculates a top down profile for a node with the specified label.
 * If no name specified, returns the whole top down calls tree.
 * @param {string} opt_label Node label.
Profile.prototype.getTopDownProfile = function(opt_label) {
  return this.getTreeProfile_(this.topDownTree_, opt_label);
 * Calculates a bottom up profile for a node with the specified label.
 * If no name specified, returns the whole bottom up calls tree.
 * @param {string} opt_label Node label.
Profile.prototype.getBottomUpProfile = function(opt_label) {
  return this.getTreeProfile_(this.bottomUpTree_, opt_label);
 * Helper function for calculating a tree profile.
 * @param {Profile.CallTree} tree Call tree.
 * @param {string} opt_label Node label.
Profile.prototype.getTreeProfile_ = function(tree, opt_label) {
  if (!opt_label) {
    tree.computeTotalWeights();
    return tree;
  } else {
    var subTree = tree.cloneSubtree(opt_label);
    subTree.computeTotalWeights();
    return subTree;
 * Calculates a flat profile of callees starting from a node with
 * the specified label. If no name specified, starts from the root.
 * @param {string} opt_label Starting node label.
Profile.prototype.getFlatProfile = function(opt_label) {
  var counters = new CallTree();
  var rootLabel = opt_label || CallTree.ROOT_NODE_LABEL;
  var precs = {};
  precs[rootLabel] = 0;
  var root = counters.findOrAddChild(rootLabel);
  this.topDownTree_.computeTotalWeights();
  this.topDownTree_.traverseInDepth(
    function onEnter(node) {
      if (!(node.label in precs)) {
        precs[node.label] = 0;
      }
      var nodeLabelIsRootLabel = node.label == rootLabel;
      if (nodeLabelIsRootLabel || precs[rootLabel] > 0) {
        if (precs[rootLabel] == 0) {
          root.selfWeight += node.selfWeight;
          root.totalWeight += node.totalWeight;
        } else {
          var rec = root.findOrAddChild(node.label);
          rec.selfWeight += node.selfWeight;
          if (nodeLabelIsRootLabel || precs[node.label] == 0) {
            rec.totalWeight += node.totalWeight;
          }
        }
        precs[node.label]++;
      }
    },
    function onExit(node) {
      if (node.label == rootLabel || precs[rootLabel] > 0) {
        precs[node.label]--;
      }
    },
    null);
  if (!opt_label) {
    // If we have created a flat profile for the whole program, we don't
    // need an explicit root in it. Thus, replace the counters tree
    // root with the node corresponding to the whole program.
    counters.root_ = root;
  } else {
    // Propagate weights so percents can be calculated correctly.
    counters.getRoot().selfWeight = root.selfWeight;
    counters.getRoot().totalWeight = root.totalWeight;
  return counters;
Profile.CEntryNode = function(name, ticks) {
  this.name = name;
  this.ticks = ticks;
Profile.prototype.getCEntryProfile = function() {
  var result = [new Profile.CEntryNode("TOTAL", 0)];
  var total_ticks = 0;
  for (var f in this.c_entries_) {
    var ticks = this.c_entries_[f];
    total_ticks += ticks;
    result.push(new Profile.CEntryNode(f, ticks));
  result[0].ticks = total_ticks;  // Sorting will keep this at index 0.
  result.sort(function(n1, n2) {
    return n2.ticks - n1.ticks || (n2.name < n1.name ? -1 : 1)
  });
  return result;
 * Cleans up function entries that are not referenced by code entries.
Profile.prototype.cleanUpFuncEntries = function() {
  var referencedFuncEntries = [];
  var entries = this.codeMap_.getAllDynamicEntriesWithAddresses();
  for (var i = 0, l = entries.length; i < l; ++i) {
    if (entries[i][1].constructor === Profile.FunctionEntry) {
      entries[i][1].used = false;
    }
  for (var i = 0, l = entries.length; i < l; ++i) {
    if ("func" in entries[i][1]) {
      entries[i][1].func.used = true;
    }
  for (var i = 0, l = entries.length; i < l; ++i) {
    if (entries[i][1].constructor === Profile.FunctionEntry &&
        !entries[i][1].used) {
      this.codeMap_.deleteCode(entries[i][0]);
    }
 * Creates a dynamic code entry.
 * @param {number} size Code size.
 * @param {string} type Code type.
 * @param {string} name Function name.
 * @constructor
Profile.DynamicCodeEntry = function(size, type, name) {
  CodeMap.CodeEntry.call(this, size, name, type);
 * Returns node name.
Profile.DynamicCodeEntry.prototype.getName = function() {
  return this.type + ': ' + this.name;
 * Returns raw node name (without type decoration).
Profile.DynamicCodeEntry.prototype.getRawName = function() {
  return this.name;
Profile.DynamicCodeEntry.prototype.isJSFunction = function() {
  return false;
Profile.DynamicCodeEntry.prototype.toString = function() {
  return this.getName() + ': ' + this.size.toString(16);
 * Creates a dynamic code entry.
 * @param {number} size Code size.
 * @param {string} type Code type.
 * @param {Profile.FunctionEntry} func Shared function entry.
 * @param {Profile.CodeState} state Code optimization state.
 * @constructor
Profile.DynamicFuncCodeEntry = function(size, type, func, state) {
  CodeMap.CodeEntry.call(this, size, '', type);
  this.func = func;
  this.state = state;
Profile.DynamicFuncCodeEntry.STATE_PREFIX = ["", "~", "*"];
 * Returns node name.
Profile.DynamicFuncCodeEntry.prototype.getName = function() {
  var name = this.func.getName();
  return this.type + ': ' + Profile.DynamicFuncCodeEntry.STATE_PREFIX[this.state] + name;
 * Returns raw node name (without type decoration).
Profile.DynamicFuncCodeEntry.prototype.getRawName = function() {
  return this.func.getName();
Profile.DynamicFuncCodeEntry.prototype.isJSFunction = function() {
  return true;
Profile.DynamicFuncCodeEntry.prototype.toString = function() {
  return this.getName() + ': ' + this.size.toString(16);
 * Creates a shared function object entry.
 * @param {string} name Function name.
 * @constructor
Profile.FunctionEntry = function(name) {
  CodeMap.CodeEntry.call(this, 0, name);
 * Returns node name.
Profile.FunctionEntry.prototype.getName = function() {
  var name = this.name;
  if (name.length == 0) {
    name = '<anonymous>';
  } else if (name.charAt(0) == ' ') {
    // An anonymous function with location: " aaa.js:10".
    name = '<anonymous>' + name;
  return name;
Profile.FunctionEntry.prototype.toString = CodeMap.CodeEntry.prototype.toString;
 * Constructs a call graph.
 * @constructor
function CallTree() {
  this.root_ = new CallTree.Node(
      CallTree.ROOT_NODE_LABEL);
 * The label of the root node.
CallTree.ROOT_NODE_LABEL = '';
 * @private
CallTree.prototype.totalsComputed_ = false;
 * Returns the tree root.
CallTree.prototype.getRoot = function() {
  return this.root_;
 * Adds the specified call path, constructing nodes as necessary.
 * @param {Array<string>} path Call path.
CallTree.prototype.addPath = function(path) {
  if (path.length == 0) {
    return;
  var curr = this.root_;
  for (var i = 0; i < path.length; ++i) {
    curr = curr.findOrAddChild(path[i]);
  curr.selfWeight++;
  this.totalsComputed_ = false;
 * Finds an immediate child of the specified parent with the specified
 * label, creates a child node if necessary. If a parent node isn't
 * specified, uses tree root.
 * @param {string} label Child node label.
CallTree.prototype.findOrAddChild = function(label) {
  return this.root_.findOrAddChild(label);
 * Creates a subtree by cloning and merging all subtrees rooted at nodes
 * with a given label. E.g. cloning the following call tree on label 'A'
 * will give the following result:
 *           <A>--<B>                                     <B>
 *          /                                            /
 *     <root>             == clone on 'A' ==>  <root>--<A>
 *          \                                            \
 *           <C>--<A>--<D>                                <D>
 * And <A>'s selfWeight will be the sum of selfWeights of <A>'s from the
 * source call tree.
 * @param {string} label The label of the new root node.
CallTree.prototype.cloneSubtree = function(label) {
  var subTree = new CallTree();
  this.traverse(function(node, parent) {
    if (!parent && node.label != label) {
      return null;
    }
    var child = (parent ? parent : subTree).findOrAddChild(node.label);
    child.selfWeight += node.selfWeight;
    return child;
  });
  return subTree;
 * Computes total weights in the call graph.
CallTree.prototype.computeTotalWeights = function() {
  if (this.totalsComputed_) {
    return;
  this.root_.computeTotalWeight();
  this.totalsComputed_ = true;
 * Traverses the call graph in preorder. This function can be used for
 * building optionally modified tree clones. This is the boilerplate code
 * for this scenario:
 * callTree.traverse(function(node, parentClone) {
 *   var nodeClone = cloneNode(node);
 *   if (parentClone)
 *     parentClone.addChild(nodeClone);
 *   return nodeClone;
 * });
 * @param {function(CallTree.Node, *)} f Visitor function.
 *    The second parameter is the result of calling 'f' on the parent node.
CallTree.prototype.traverse = function(f) {
  var pairsToProcess = new ConsArray();
  pairsToProcess.concat([{node: this.root_, param: null}]);
  while (!pairsToProcess.atEnd()) {
    var pair = pairsToProcess.next();
    var node = pair.node;
    var newParam = f(node, pair.param);
    var morePairsToProcess = [];
    node.forEachChild(function (child) {
        morePairsToProcess.push({node: child, param: newParam}); });
    pairsToProcess.concat(morePairsToProcess);
 * Performs an indepth call graph traversal.
 * @param {function(CallTree.Node)} enter A function called
 *     prior to visiting node's children.
 * @param {function(CallTree.Node)} exit A function called
 *     after visiting node's children.
CallTree.prototype.traverseInDepth = function(enter, exit) {
  function traverse(node) {
    enter(node);
    node.forEachChild(traverse);
    exit(node);
  traverse(this.root_);
 * Constructs a call graph node.
 * @param {string} label Node label.
 * @param {CallTree.Node} opt_parent Node parent.
CallTree.Node = function(label, opt_parent) {
  this.label = label;
  this.parent = opt_parent;
  this.children = {};
 * Node self weight (how many times this node was the last node in
 * a call path).
 * @type {number}
CallTree.Node.prototype.selfWeight = 0;
 * Node total weight (includes weights of all children).
 * @type {number}
CallTree.Node.prototype.totalWeight = 0;
 * Adds a child node.
 * @param {string} label Child node label.
CallTree.Node.prototype.addChild = function(label) {
  var child = new CallTree.Node(label, this);
  this.children[label] = child;
  return child;
 * Computes node's total weight.
CallTree.Node.prototype.computeTotalWeight =
    function() {
  var totalWeight = this.selfWeight;
  this.forEachChild(function(child) {
      totalWeight += child.computeTotalWeight(); });
  return this.totalWeight = totalWeight;
 * Returns all node's children as an array.
CallTree.Node.prototype.exportChildren = function() {
  var result = [];
  this.forEachChild(function (node) { result.push(node); });
  return result;
 * Finds an immediate child with the specified label.
 * @param {string} label Child node label.
CallTree.Node.prototype.findChild = function(label) {
  return this.children[label] || null;
 * Finds an immediate child with the specified label, creates a child
 * node if necessary.
 * @param {string} label Child node label.
CallTree.Node.prototype.findOrAddChild = function(label) {
  return this.findChild(label) || this.addChild(label);
 * Calls the specified function for every child.
 * @param {function(CallTree.Node)} f Visitor function.
CallTree.Node.prototype.forEachChild = function(f) {
  for (var c in this.children) {
    f(this.children[c]);
 * Walks up from the current node up to the call tree root.
 * @param {function(CallTree.Node)} f Visitor function.
CallTree.Node.prototype.walkUpToRoot = function(f) {
  for (var curr = this; curr != null; curr = curr.parent) {
    f(curr);
 * Tries to find a node with the specified path.
 * @param {Array<string>} labels The path.
 * @param {function(CallTree.Node)} opt_f Visitor function.
CallTree.Node.prototype.descendToChild = function(
    labels, opt_f) {
  for (var pos = 0, curr = this; pos < labels.length && curr != null; pos++) {
    var child = curr.findChild(labels[pos]);
    if (opt_f) {
      opt_f(child, pos);
    }
    curr = child;
  return curr;
// Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Creates a Profile View builder object.
 * @param {number} samplingRate Number of ms between profiler ticks.
 * @constructor
function ViewBuilder(samplingRate) {
  this.samplingRate = samplingRate;
 * Builds a profile view for the specified call tree.
 * @param {CallTree} callTree A call tree.
 * @param {boolean} opt_bottomUpViewWeights Whether remapping
 *     of self weights for a bottom up view is needed.
ViewBuilder.prototype.buildView = function(
    callTree, opt_bottomUpViewWeights) {
  var head;
  var samplingRate = this.samplingRate;
  var createViewNode = this.createViewNode;
  callTree.traverse(function(node, viewParent) {
    var totalWeight = node.totalWeight * samplingRate;
    var selfWeight = node.selfWeight * samplingRate;
    if (opt_bottomUpViewWeights === true) {
      if (viewParent === head) {
        selfWeight = totalWeight;
      } else {
        selfWeight = 0;
      }
    }
    var viewNode = createViewNode(node.label, totalWeight, selfWeight, head);
    if (viewParent) {
      viewParent.addChild(viewNode);
    } else {
      head = viewNode;
    }
    return viewNode;
  });
  var view = this.createView(head);
  return view;
 * Factory method for a profile view.
 * @param {ProfileView.Node} head View head node.
 * @return {ProfileView} Profile view.
ViewBuilder.prototype.createView = function(head) {
  return new ProfileView(head);
 * Factory method for a profile view node.
 * @param {string} internalFuncName A fully qualified function name.
 * @param {number} totalTime Amount of time that application spent in the
 *     corresponding function and its descendants (not that depending on
 *     profile they can be either callees or callers.)
 * @param {number} selfTime Amount of time that application spent in the
 *     corresponding function only.
 * @param {ProfileView.Node} head Profile view head.
 * @return {ProfileView.Node} Profile view node.
ViewBuilder.prototype.createViewNode = function(
    funcName, totalTime, selfTime, head) {
  return new ProfileView.Node(
      funcName, totalTime, selfTime, head);
 * Creates a Profile View object. It allows to perform sorting
 * and filtering actions on the profile.
 * @param {ProfileView.Node} head Head (root) node.
 * @constructor
function ProfileView(head) {
  this.head = head;
 * Sorts the profile view using the specified sort function.
 * @param {function(ProfileView.Node,
 *     ProfileView.Node):number} sortFunc A sorting
 *     functions. Must comply with Array.sort sorting function requirements.
ProfileView.prototype.sort = function(sortFunc) {
  this.traverse(function (node) {
    node.sortChildren(sortFunc);
  });
 * Traverses profile view nodes in preorder.
 * @param {function(ProfileView.Node)} f Visitor function.
ProfileView.prototype.traverse = function(f) {
  var nodesToTraverse = new ConsArray();
  nodesToTraverse.concat([this.head]);
  while (!nodesToTraverse.atEnd()) {
    var node = nodesToTraverse.next();
    f(node);
    nodesToTraverse.concat(node.children);
 * Constructs a Profile View node object. Each node object corresponds to
 * a function call.
 * @param {string} internalFuncName A fully qualified function name.
 * @param {number} totalTime Amount of time that application spent in the
 *     corresponding function and its descendants (not that depending on
 *     profile they can be either callees or callers.)
 * @param {number} selfTime Amount of time that application spent in the
 *     corresponding function only.
 * @param {ProfileView.Node} head Profile view head.
 * @constructor
ProfileView.Node = function(
    internalFuncName, totalTime, selfTime, head) {
  this.internalFuncName = internalFuncName;
  this.totalTime = totalTime;
  this.selfTime = selfTime;
  this.head = head;
  this.parent = null;
  this.children = [];
 * Returns a share of the function's total time in its parent's total time.
ProfileView.Node.prototype.__defineGetter__(
    'parentTotalPercent',
    function() { return this.totalTime /
      (this.parent ? this.parent.totalTime : this.totalTime) * 100.0; });
 * Adds a child to the node.
 * @param {ProfileView.Node} node Child node.
ProfileView.Node.prototype.addChild = function(node) {
  node.parent = this;
  this.children.push(node);
 * Sorts all the node's children recursively.
 * @param {function(ProfileView.Node,
 *     ProfileView.Node):number} sortFunc A sorting
 *     functions. Must comply with Array.sort sorting function requirements.
ProfileView.Node.prototype.sortChildren = function(
    sortFunc) {
  this.children.sort(sortFunc);
// Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * @fileoverview Log Reader is used to process log file produced by V8.
 * Base class for processing log files.
 * @param {Array.<Object>} dispatchTable A table used for parsing and processing
 *     log records.
 * @param {boolean} timedRange Ignore ticks outside timed range.
 * @param {boolean} pairwiseTimedRange Ignore ticks outside pairs of timer
 *     markers.
 * @constructor
function LogReader(dispatchTable, timedRange, pairwiseTimedRange) {
  /**
   * @type {Array.<Object>}
   */
  this.dispatchTable_ = dispatchTable;
  /**
   * @type {boolean}
   */
  this.timedRange_ = timedRange;
  /**
   * @type {boolean}
   */
  this.pairwiseTimedRange_ = pairwiseTimedRange;
  if (pairwiseTimedRange) {
    this.timedRange_ = true;
  /**
   * Current line.
   * @type {number}
   */
  this.lineNum_ = 0;
  /**
   * CSV lines parser.
   * @type {CsvParser}
   */
  this.csvParser_ = new CsvParser();
  /**
   * Keeps track of whether we've seen a "current-time" tick yet.
   * @type {boolean}
   */
  this.hasSeenTimerMarker_ = false;
  /**
   * List of log lines seen since last "current-time" tick.
   * @type {Array.<String>}
   */
  this.logLinesSinceLastTimerMarker_ = [];
 * Used for printing error messages.
 * @param {string} str Error message.
LogReader.prototype.printError = function(str) {
  // Do nothing.
 * Processes a portion of V8 profiler event log.
 * @param {string} chunk A portion of log.
LogReader.prototype.processLogChunk = function(chunk) {
  this.processLog_(chunk.split('\n'));
 * Processes a line of V8 profiler event log.
 * @param {string} line A line of log.
LogReader.prototype.processLogLine = function(line) {
  if (!this.timedRange_) {
    this.processLog_([line]);
    return;
  if (line.startsWith("current-time")) {
    if (this.hasSeenTimerMarker_) {
      this.processLog_(this.logLinesSinceLastTimerMarker_);
      this.logLinesSinceLastTimerMarker_ = [];
      // In pairwise mode, a "current-time" line ends the timed range.
      if (this.pairwiseTimedRange_) {
        this.hasSeenTimerMarker_ = false;
      }
    } else {
      this.hasSeenTimerMarker_ = true;
    }
  } else {
    if (this.hasSeenTimerMarker_) {
      this.logLinesSinceLastTimerMarker_.push(line);
    } else if (!line.startsWith("tick")) {
      this.processLog_([line]);
    }
 * Processes stack record.
 * @param {number} pc Program counter.
 * @param {number} func JS Function.
 * @param {Array.<string>} stack String representation of a stack.
 * @return {Array.<number>} Processed stack.
LogReader.prototype.processStack = function(pc, func, stack) {
  var fullStack = func ? [pc, func] : [pc];
  var prevFrame = pc;
  for (var i = 0, n = stack.length; i < n; ++i) {
    var frame = stack[i];
    var firstChar = frame.charAt(0);
    if (firstChar == '+' || firstChar == '-') {
      // An offset from the previous frame.
      prevFrame += parseInt(frame, 16);
      fullStack.push(prevFrame);
    // Filter out possible 'overflow' string.
    } else if (firstChar != 'o') {
      fullStack.push(parseInt(frame, 16));
    } else {
      print("dropping: " + frame);
    }
  return fullStack;
 * Returns whether a particular dispatch must be skipped.
 * @param {!Object} dispatch Dispatch record.
 * @return {boolean} True if dispatch must be skipped.
LogReader.prototype.skipDispatch = function(dispatch) {
  return false;
 * Does a dispatch of a log record.
 * @param {Array.<string>} fields Log record.
 * @private
LogReader.prototype.dispatchLogRow_ = function(fields) {
  // Obtain the dispatch.
  var command = fields[0];
  if (!(command in this.dispatchTable_)) return;
  var dispatch = this.dispatchTable_[command];
  if (dispatch === null || this.skipDispatch(dispatch)) {
    return;
  // Parse fields.
  var parsedFields = [];
  for (var i = 0; i < dispatch.parsers.length; ++i) {
    var parser = dispatch.parsers[i];
    if (parser === null) {
      parsedFields.push(fields[1 + i]);
    } else if (typeof parser == 'function') {
      parsedFields.push(parser(fields[1 + i]));
    } else {
      // var-args
      parsedFields.push(fields.slice(1 + i));
      break;
    }
  // Run the processor.
  dispatch.processor.apply(this, parsedFields);
 * Processes log lines.
 * @param {Array.<string>} lines Log lines.
 * @private
LogReader.prototype.processLog_ = function(lines) {
  for (var i = 0, n = lines.length; i < n; ++i, ++this.lineNum_) {
    var line = lines[i];
    if (!line) {
      continue;
    }
    try {
      var fields = this.csvParser_.parseLine(line);
      this.dispatchLogRow_(fields);
    } catch (e) {
      this.printError('line ' + (this.lineNum_ + 1) + ': ' + (e.message || e));
    }
// Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
function inherits(childCtor, parentCtor) {
  childCtor.prototype.__proto__ = parentCtor.prototype;
function V8Profile(separateIc) {
  Profile.call(this);
  if (!separateIc) {
    this.skipThisFunction = function(name) { return V8Profile.IC_RE.test(name); };
inherits(V8Profile, Profile);
V8Profile.IC_RE =
    /^(?:CallIC|LoadIC|StoreIC)|(?:Builtin: (?:Keyed)?(?:Call|Load|Store)IC_)/;
 * A thin wrapper around shell's 'read' function showing a file name on error.
function readFile(fileName) {
  try {
    return read(fileName);
  } catch (e) {
    print(fileName + ': ' + (e.message || e));
    throw e;
 * Parser for dynamic code optimization state.
function parseState(s) {
  switch (s) {
  case "": return Profile.CodeState.COMPILED;
  case "~": return Profile.CodeState.OPTIMIZABLE;
  case "*": return Profile.CodeState.OPTIMIZED;
  throw new Error("unknown code state: " + s);
function SnapshotLogProcessor() {
  LogReader.call(this, {
      'code-creation': {
          parsers: [null, parseInt, parseInt, parseInt, null, 'var-args'],
          processor: this.processCodeCreation },
      'code-move': { parsers: [parseInt, parseInt],
          processor: this.processCodeMove },
      'code-delete': { parsers: [parseInt],
          processor: this.processCodeDelete },
      'function-creation': null,
      'function-move': null,
      'function-delete': null,
      'sfi-move': null,
      'snapshot-pos': { parsers: [parseInt, parseInt],
          processor: this.processSnapshotPosition }});
  V8Profile.prototype.handleUnknownCode = function(operation, addr) {
    var op = Profile.Operation;
    switch (operation) {
      case op.MOVE:
        print('Snapshot: Code move event for unknown code: 0x' +
              addr.toString(16));
        break;
      case op.DELETE:
        print('Snapshot: Code delete event for unknown code: 0x' +
              addr.toString(16));
        break;
    }
  };
  this.profile_ = new V8Profile();
  this.serializedEntries_ = [];
inherits(SnapshotLogProcessor, LogReader);
SnapshotLogProcessor.prototype.processCodeCreation = function(
    type, kind, start, size, name, maybe_func) {
  if (maybe_func.length) {
    var funcAddr = parseInt(maybe_func[0]);
    var state = parseState(maybe_func[1]);
    this.profile_.addFuncCode(type, name, start, size, funcAddr, state);
  } else {
    this.profile_.addCode(type, name, start, size);
SnapshotLogProcessor.prototype.processCodeMove = function(from, to) {
  this.profile_.moveCode(from, to);
SnapshotLogProcessor.prototype.processCodeDelete = function(start) {
  this.profile_.deleteCode(start);
SnapshotLogProcessor.prototype.processSnapshotPosition = function(addr, pos) {
  this.serializedEntries_[pos] = this.profile_.findEntry(addr);
SnapshotLogProcessor.prototype.processLogFile = function(fileName) {
  var contents = readFile(fileName);
  this.processLogChunk(contents);
SnapshotLogProcessor.prototype.getSerializedEntryName = function(pos) {
  var entry = this.serializedEntries_[pos];
  return entry ? entry.getRawName() : null;
function TickProcessor(
    cppEntriesProvider,
    separateIc,
    callGraphSize,
    ignoreUnknown,
    stateFilter,
    snapshotLogProcessor,
    distortion,
    range,
    sourceMap,
    timedRange,
    pairwiseTimedRange) {
  LogReader.call(this, {
      'shared-library': { parsers: [null, parseInt, parseInt],
          processor: this.processSharedLibrary },
      'code-creation': {
          parsers: [null, parseInt, parseInt, parseInt, null, 'var-args'],
          processor: this.processCodeCreation },
      'code-move': { parsers: [parseInt, parseInt],
          processor: this.processCodeMove },
      'code-delete': { parsers: [parseInt],
          processor: this.processCodeDelete },
      'sfi-move': { parsers: [parseInt, parseInt],
          processor: this.processFunctionMove },
      'snapshot-pos': { parsers: [parseInt, parseInt],
          processor: this.processSnapshotPosition },
      'tick': {
          parsers: [parseInt, parseInt, parseInt,
                    parseInt, parseInt, 'var-args'],
          processor: this.processTick },
      'heap-sample-begin': { parsers: [null, null, parseInt],
          processor: this.processHeapSampleBegin },
      'heap-sample-end': { parsers: [null, null],
          processor: this.processHeapSampleEnd },
      'timer-event-start' : { parsers: [null, null, null],
                              processor: this.advanceDistortion },
      'timer-event-end' : { parsers: [null, null, null],
                            processor: this.advanceDistortion },
      // Ignored events.
      'profiler': null,
      'function-creation': null,
      'function-move': null,
      'function-delete': null,
      'heap-sample-item': null,
      'current-time': null,  // Handled specially, not parsed.
      // Obsolete row types.
      'code-allocate': null,
      'begin-code-region': null,
      'end-code-region': null },
      timedRange,
      pairwiseTimedRange);
  this.cppEntriesProvider_ = cppEntriesProvider;
  this.callGraphSize_ = callGraphSize;
  this.ignoreUnknown_ = ignoreUnknown;
  this.stateFilter_ = stateFilter;
  this.snapshotLogProcessor_ = snapshotLogProcessor;
  this.sourceMap = sourceMap;
  this.deserializedEntriesNames_ = [];
  var ticks = this.ticks_ =
    { total: 0, unaccounted: 0, excluded: 0, gc: 0 };
  distortion = parseInt(distortion);
  // Convert picoseconds to nanoseconds.
  this.distortion_per_entry = isNaN(distortion) ? 0 : (distortion / 1000);
  this.distortion = 0;
  var rangelimits = range ? range.split(",") : [];
  var range_start = parseInt(rangelimits[0]);
  var range_end = parseInt(rangelimits[1]);
  // Convert milliseconds to nanoseconds.
  this.range_start = isNaN(range_start) ? -Infinity : (range_start * 1000);
  this.range_end = isNaN(range_end) ? Infinity : (range_end * 1000)
  V8Profile.prototype.handleUnknownCode = function(
      operation, addr, opt_stackPos) {
    var op = Profile.Operation;
    switch (operation) {
      case op.MOVE:
        print('Code move event for unknown code: 0x' + addr.toString(16));
        break;
      case op.DELETE:
        print('Code delete event for unknown code: 0x' + addr.toString(16));
        break;
      case op.TICK:
        // Only unknown PCs (the first frame) are reported as unaccounted,
        // otherwise tick balance will be corrupted (this behavior is compatible
        // with the original tickprocessor.py script.)
        if (opt_stackPos == 0) {
          ticks.unaccounted++;
        }
        break;
    }
  };
  this.profile_ = new V8Profile(separateIc);
  this.codeTypes_ = {};
  // Count each tick as a time unit.
  this.viewBuilder_ = new ViewBuilder(1);
  this.lastLogFileName_ = null;
  this.generation_ = 1;
  this.currentProducerProfile_ = null;
inherits(TickProcessor, LogReader);
TickProcessor.VmStates = {
  JS: 0,
  GC: 1,
  COMPILER: 2,
  OTHER: 3,
  EXTERNAL: 4,
  IDLE: 5
TickProcessor.CodeTypes = {
  CPP: 0,
  SHARED_LIB: 1
// Otherwise, this is JS-related code. We are not adding it to
// codeTypes_ map because there can be zillions of them.
TickProcessor.CALL_PROFILE_CUTOFF_PCT = 2.0;
TickProcessor.CALL_GRAPH_SIZE = 5;
 * @override
TickProcessor.prototype.printError = function(str) {
  print(str);
TickProcessor.prototype.setCodeType = function(name, type) {
  this.codeTypes_[name] = TickProcessor.CodeTypes[type];
TickProcessor.prototype.isSharedLibrary = function(name) {
  return this.codeTypes_[name] == TickProcessor.CodeTypes.SHARED_LIB;
TickProcessor.prototype.isCppCode = function(name) {
  return this.codeTypes_[name] == TickProcessor.CodeTypes.CPP;
TickProcessor.prototype.isJsCode = function(name) {
  return name !== "UNKNOWN" && !(name in this.codeTypes_);
TickProcessor.prototype.processLogFile = function(fileName) {
  this.lastLogFileName_ = fileName;
  var line;
  while (line = readline()) {
    this.processLogLine(line);
TickProcessor.prototype.processLogFileInTest = function(fileName) {
   // Hack file name to avoid dealing with platform specifics.
  this.lastLogFileName_ = 'v8.log';
  var contents = readFile(fileName);
  this.processLogChunk(contents);
TickProcessor.prototype.processSharedLibrary = function(
    name, startAddr, endAddr) {
  var entry = this.profile_.addLibrary(name, startAddr, endAddr);
  this.setCodeType(entry.getName(), 'SHARED_LIB');
  var self = this;
  var libFuncs = this.cppEntriesProvider_.parseVmSymbols(
      name, startAddr, endAddr, function(fName, fStart, fEnd) {
    self.profile_.addStaticCode(fName, fStart, fEnd);
    self.setCodeType(fName, 'CPP');
  });
TickProcessor.prototype.processCodeCreation = function(
    type, kind, start, size, name, maybe_func) {
  name = this.deserializedEntriesNames_[start] || name;
  if (maybe_func.length) {
    var funcAddr = parseInt(maybe_func[0]);
    var state = parseState(maybe_func[1]);
    this.profile_.addFuncCode(type, name, start, size, funcAddr, state);
  } else {
    this.profile_.addCode(type, name, start, size);
TickProcessor.prototype.processCodeMove = function(from, to) {
  this.profile_.moveCode(from, to);
TickProcessor.prototype.processCodeDelete = function(start) {
  this.profile_.deleteCode(start);
TickProcessor.prototype.processFunctionMove = function(from, to) {
  this.profile_.moveFunc(from, to);
TickProcessor.prototype.processSnapshotPosition = function(addr, pos) {
  if (this.snapshotLogProcessor_) {
    this.deserializedEntriesNames_[addr] =
      this.snapshotLogProcessor_.getSerializedEntryName(pos);
TickProcessor.prototype.includeTick = function(vmState) {
  return this.stateFilter_ == null || this.stateFilter_ == vmState;
TickProcessor.prototype.processTick = function(pc,
                                               ns_since_start,
                                               is_external_callback,
                                               tos_or_external_callback,
                                               vmState,
                                               stack) {
  this.distortion += this.distortion_per_entry;
  ns_since_start -= this.distortion;
  if (ns_since_start < this.range_start || ns_since_start > this.range_end) {
    return;
  this.ticks_.total++;
  if (vmState == TickProcessor.VmStates.GC) this.ticks_.gc++;
  if (!this.includeTick(vmState)) {
    this.ticks_.excluded++;
    return;
  if (is_external_callback) {
    // Don't use PC when in external callback code, as it can point
    // inside callback's code, and we will erroneously report
    // that a callback calls itself. Instead we use tos_or_external_callback,
    // as simply resetting PC will produce unaccounted ticks.
    pc = tos_or_external_callback;
    tos_or_external_callback = 0;
  } else if (tos_or_external_callback) {
    // Find out, if top of stack was pointing inside a JS function
    // meaning that we have encountered a frameless invocation.
    var funcEntry = this.profile_.findEntry(tos_or_external_callback);
    if (!funcEntry || !funcEntry.isJSFunction || !funcEntry.isJSFunction()) {
      tos_or_external_callback = 0;
    }
  this.profile_.recordTick(this.processStack(pc, tos_or_external_callback, stack));
TickProcessor.prototype.advanceDistortion = function() {
  this.distortion += this.distortion_per_entry;
TickProcessor.prototype.processHeapSampleBegin = function(space, state, ticks) {
  if (space != 'Heap') return;
  this.currentProducerProfile_ = new CallTree();
TickProcessor.prototype.processHeapSampleEnd = function(space, state) {
  if (space != 'Heap' || !this.currentProducerProfile_) return;
  print('Generation ' + this.generation_ + ':');
  var tree = this.currentProducerProfile_;
  tree.computeTotalWeights();
  var producersView = this.viewBuilder_.buildView(tree);
  // Sort by total time, desc, then by name, desc.
  producersView.sort(function(rec1, rec2) {
      return rec2.totalTime - rec1.totalTime ||
          (rec2.internalFuncName < rec1.internalFuncName ? -1 : 1); });
  this.printHeavyProfile(producersView.head.children);
  this.currentProducerProfile_ = null;
  this.generation_++;
TickProcessor.prototype.printStatistics = function() {
  print('Statistical profiling result from ' + this.lastLogFileName_ +
        ', (' + this.ticks_.total +
        ' ticks, ' + this.ticks_.unaccounted + ' unaccounted, ' +
        this.ticks_.excluded + ' excluded).');
  if (this.ticks_.total == 0) return;
  var flatProfile = this.profile_.getFlatProfile();
  var flatView = this.viewBuilder_.buildView(flatProfile);
  // Sort by self time, desc, then by name, desc.
  flatView.sort(function(rec1, rec2) {
      return rec2.selfTime - rec1.selfTime ||
          (rec2.internalFuncName < rec1.internalFuncName ? -1 : 1); });
  var totalTicks = this.ticks_.total;
  if (this.ignoreUnknown_) {
    totalTicks -= this.ticks_.unaccounted;
  // Count library ticks
  var flatViewNodes = flatView.head.children;
  var self = this;
  var libraryTicks = 0;
  this.printHeader('Shared libraries');
  this.printEntries(flatViewNodes, totalTicks, null,
      function(name) { return self.isSharedLibrary(name); },
      function(rec) { libraryTicks += rec.selfTime; });
  var nonLibraryTicks = totalTicks - libraryTicks;
  var jsTicks = 0;
  this.printHeader('JavaScript');
  this.printEntries(flatViewNodes, totalTicks, nonLibraryTicks,
      function(name) { return self.isJsCode(name); },
      function(rec) { jsTicks += rec.selfTime; });
  var cppTicks = 0;
  this.printHeader('C++');
  this.printEntries(flatViewNodes, totalTicks, nonLibraryTicks,
      function(name) { return self.isCppCode(name); },
      function(rec) { cppTicks += rec.selfTime; });
  this.printHeader('Summary');
  this.printLine('JavaScript', jsTicks, totalTicks, nonLibraryTicks);
  this.printLine('C++', cppTicks, totalTicks, nonLibraryTicks);
  this.printLine('GC', this.ticks_.gc, totalTicks, nonLibraryTicks);
  this.printLine('Shared libraries', libraryTicks, totalTicks, null);
  if (!this.ignoreUnknown_ && this.ticks_.unaccounted > 0) {
    this.printLine('Unaccounted', this.ticks_.unaccounted,
                   this.ticks_.total, null);
  print('\n [C++ entry points]:');
  print('   ticks    cpp   total   name');
  var c_entry_functions = this.profile_.getCEntryProfile();
  var total_c_entry = c_entry_functions[0].ticks;
  for (var i = 1; i < c_entry_functions.length; i++) {
    c = c_entry_functions[i];
    this.printLine(c.name, c.ticks, total_c_entry, totalTicks);
  this.printHeavyProfHeader();
  var heavyProfile = this.profile_.getBottomUpProfile();
  var heavyView = this.viewBuilder_.buildView(heavyProfile);
  // To show the same percentages as in the flat profile.
  heavyView.head.totalTime = totalTicks;
  // Sort by total time, desc, then by name, desc.
  heavyView.sort(function(rec1, rec2) {
      return rec2.totalTime - rec1.totalTime ||
          (rec2.internalFuncName < rec1.internalFuncName ? -1 : 1); });
  this.printHeavyProfile(heavyView.head.children);
function padLeft(s, len) {
  s = s.toString();
  if (s.length < len) {
    var padLength = len - s.length;
    if (!(padLength in padLeft)) {
      padLeft[padLength] = new Array(padLength + 1).join(' ');
    }
    s = padLeft[padLength] + s;
  return s;
TickProcessor.prototype.printHeader = function(headerTitle) {
  print('\n [' + headerTitle + ']:');
  print('   ticks  total  nonlib   name');
TickProcessor.prototype.printLine = function(
    entry, ticks, totalTicks, nonLibTicks) {
  var pct = ticks * 100 / totalTicks;
  var nonLibPct = nonLibTicks != null
      ? padLeft((ticks * 100 / nonLibTicks).toFixed(1), 5) + '%  '
      : '        ';
  print('  ' + padLeft(ticks, 5) + '  ' +
        padLeft(pct.toFixed(1), 5) + '%  ' +
        nonLibPct +
        entry);
TickProcessor.prototype.printHeavyProfHeader = function() {
  print('\n [Bottom up (heavy) profile]:');
  print('  Note: percentage shows a share of a particular caller in the ' +
        'total\n' +
        '  amount of its parent calls.');
  print('  Callers occupying less than ' +
        TickProcessor.CALL_PROFILE_CUTOFF_PCT.toFixed(1) +
        '% are not shown.\n');
  print('   ticks parent  name');
TickProcessor.prototype.processProfile = function(
    profile, filterP, func) {
  for (var i = 0, n = profile.length; i < n; ++i) {
    var rec = profile[i];
    if (!filterP(rec.internalFuncName)) {
      continue;
    }
    func(rec);
TickProcessor.prototype.getLineAndColumn = function(name) {
  var re = /:([0-9]+):([0-9]+)$/;
  var array = re.exec(name);
  if (!array) {
    return null;
  return {line: array[1], column: array[2]};
TickProcessor.prototype.hasSourceMap = function() {
  return this.sourceMap != null;
TickProcessor.prototype.formatFunctionName = function(funcName) {
  if (!this.hasSourceMap()) {
    return funcName;
  var lc = this.getLineAndColumn(funcName);
  if (lc == null) {
    return funcName;
  // in source maps lines and columns are zero based
  var lineNumber = lc.line - 1;
  var column = lc.column - 1;
  var entry = this.sourceMap.findEntry(lineNumber, column);
  var sourceFile = entry[2];
  var sourceLine = entry[3] + 1;
  var sourceColumn = entry[4] + 1;
  return sourceFile + ':' + sourceLine + ':' + sourceColumn + ' -> ' + funcName;
TickProcessor.prototype.printEntries = function(
    profile, totalTicks, nonLibTicks, filterP, callback) {
  var that = this;
  this.processProfile(profile, filterP, function (rec) {
    if (rec.selfTime == 0) return;
    callback(rec);
    var funcName = that.formatFunctionName(rec.internalFuncName);
    that.printLine(funcName, rec.selfTime, totalTicks, nonLibTicks);
  });
TickProcessor.prototype.printHeavyProfile = function(profile, opt_indent) {
  var self = this;
  var indent = opt_indent || 0;
  var indentStr = padLeft('', indent);
  this.processProfile(profile, function() { return true; }, function (rec) {
    // Cut off too infrequent callers.
    if (rec.parentTotalPercent < TickProcessor.CALL_PROFILE_CUTOFF_PCT) return;
    var funcName = self.formatFunctionName(rec.internalFuncName);
    print('  ' + padLeft(rec.totalTime, 5) + '  ' +
          padLeft(rec.parentTotalPercent.toFixed(1), 5) + '%  ' +
          indentStr + funcName);
    // Limit backtrace depth.
    if (indent < 2 * self.callGraphSize_) {
      self.printHeavyProfile(rec.children, indent + 2);
    }
    // Delimit top-level functions.
    if (indent == 0) {
      print('');
    }
  });
function CppEntriesProvider() {
CppEntriesProvider.prototype.parseVmSymbols = function(
    libName, libStart, libEnd, processorFunc) {
  this.loadSymbols(libName);
  var prevEntry;
  function addEntry(funcInfo) {
    // Several functions can be mapped onto the same address. To avoid
    // creating zero-sized entries, skip such duplicates.
    // Also double-check that function belongs to the library address space.
    if (prevEntry && !prevEntry.end &&
        prevEntry.start < funcInfo.start &&
        prevEntry.start >= libStart && funcInfo.start <= libEnd) {
      processorFunc(prevEntry.name, prevEntry.start, funcInfo.start);
    }
    if (funcInfo.end &&
        (!prevEntry || prevEntry.start != funcInfo.start) &&
        funcInfo.start >= libStart && funcInfo.end <= libEnd) {
      processorFunc(funcInfo.name, funcInfo.start, funcInfo.end);
    }
    prevEntry = funcInfo;
  while (true) {
    var funcInfo = this.parseNextLine();
    if (funcInfo === null) {
      continue;
    } else if (funcInfo === false) {
      break;
    }
    if (funcInfo.start < libStart && funcInfo.start < libEnd - libStart) {
      funcInfo.start += libStart;
    }
    if (funcInfo.size) {
      funcInfo.end = funcInfo.start + funcInfo.size;
    }
    addEntry(funcInfo);
  addEntry({name: '', start: libEnd});
CppEntriesProvider.prototype.loadSymbols = function(libName) {
CppEntriesProvider.prototype.parseNextLine = function() {
  return false;
function UnixCppEntriesProvider(nmExec, targetRootFS) {
  this.symbols = [];
  this.parsePos = 0;
  this.nmExec = nmExec;
  this.targetRootFS = targetRootFS;
  this.FUNC_RE = /^([0-9a-fA-F]{8,16}) ([0-9a-fA-F]{8,16} )?[tTwW] (.*)$/;
inherits(UnixCppEntriesProvider, CppEntriesProvider);
UnixCppEntriesProvider.prototype.loadSymbols = function(libName) {
  this.parsePos = 0;
  libName = this.targetRootFS + libName;
  try {
    this.symbols = [
      os.system(this.nmExec, ['-C', '-n', '-S', libName], -1, -1),
      os.system(this.nmExec, ['-C', '-n', '-S', '-D', libName], -1, -1)
    ];
  } catch (e) {
    // If the library cannot be found on this system let's not panic.
    this.symbols = ['', ''];
UnixCppEntriesProvider.prototype.parseNextLine = function() {
  if (this.symbols.length == 0) {
    return false;
  var lineEndPos = this.symbols[0].indexOf('\n', this.parsePos);
  if (lineEndPos == -1) {
    this.symbols.shift();
    this.parsePos = 0;
    return this.parseNextLine();
  var line = this.symbols[0].substring(this.parsePos, lineEndPos);
  this.parsePos = lineEndPos + 1;
  var fields = line.match(this.FUNC_RE);
  var funcInfo = null;
  if (fields) {
    funcInfo = { name: fields[3], start: parseInt(fields[1], 16) };
    if (fields[2]) {
      funcInfo.size = parseInt(fields[2], 16);
    }
  return funcInfo;
function MacCppEntriesProvider(nmExec, targetRootFS) {
  UnixCppEntriesProvider.call(this, nmExec, targetRootFS);
  // Note an empty group. It is required, as UnixCppEntriesProvider expects 3 groups.
  this.FUNC_RE = /^([0-9a-fA-F]{8,16}) ()[iItT] (.*)$/;
inherits(MacCppEntriesProvider, UnixCppEntriesProvider);
MacCppEntriesProvider.prototype.loadSymbols = function(libName) {
  this.parsePos = 0;
  libName = this.targetRootFS + libName;
  // It seems that in OS X `nm` thinks that `-f` is a format option, not a
  // "flat" display option flag.
  try {
    this.symbols = [os.system(this.nmExec, ['-n', libName], -1, -1), ''];
  } catch (e) {
    // If the library cannot be found on this system let's not panic.
    this.symbols = '';
function WindowsCppEntriesProvider(_ignored_nmExec, targetRootFS) {
  this.targetRootFS = targetRootFS;
  this.symbols = '';
  this.parsePos = 0;
inherits(WindowsCppEntriesProvider, CppEntriesProvider);
WindowsCppEntriesProvider.FILENAME_RE = /^(.*)\.([^.]+)$/;
WindowsCppEntriesProvider.FUNC_RE =
    /^\s+0001:[0-9a-fA-F]{8}\s+([_\?@$0-9a-zA-Z]+)\s+([0-9a-fA-F]{8}).*$/;
WindowsCppEntriesProvider.IMAGE_BASE_RE =
    /^\s+0000:00000000\s+___ImageBase\s+([0-9a-fA-F]{8}).*$/;
// This is almost a constant on Windows.
WindowsCppEntriesProvider.EXE_IMAGE_BASE = 0x00400000;
WindowsCppEntriesProvider.prototype.loadSymbols = function(libName) {
  libName = this.targetRootFS + libName;
  var fileNameFields = libName.match(WindowsCppEntriesProvider.FILENAME_RE);
  if (!fileNameFields) return;
  var mapFileName = fileNameFields[1] + '.map';
  this.moduleType_ = fileNameFields[2].toLowerCase();
  try {
    this.symbols = read(mapFileName);
  } catch (e) {
    // If .map file cannot be found let's not panic.
    this.symbols = '';
WindowsCppEntriesProvider.prototype.parseNextLine = function() {
  var lineEndPos = this.symbols.indexOf('\r\n', this.parsePos);
  if (lineEndPos == -1) {
    return false;
  var line = this.symbols.substring(this.parsePos, lineEndPos);
  this.parsePos = lineEndPos + 2;
  // Image base entry is above all other symbols, so we can just
  // terminate parsing.
  var imageBaseFields = line.match(WindowsCppEntriesProvider.IMAGE_BASE_RE);
  if (imageBaseFields) {
    var imageBase = parseInt(imageBaseFields[1], 16);
    if ((this.moduleType_ == 'exe') !=
        (imageBase == WindowsCppEntriesProvider.EXE_IMAGE_BASE)) {
      return false;
    }
  var fields = line.match(WindowsCppEntriesProvider.FUNC_RE);
  return fields ?
      { name: this.unmangleName(fields[1]), start: parseInt(fields[2], 16) } :
      null;
 * Performs very simple unmangling of C++ names.
 * Does not handle arguments and template arguments. The mangled names have
 * the form:
 *   ?LookupInDescriptor@JSObject@internal@v8@@...arguments info...
WindowsCppEntriesProvider.prototype.unmangleName = function(name) {
  // Empty or non-mangled name.
  if (name.length < 1 || name.charAt(0) != '?') return name;
  var nameEndPos = name.indexOf('@@');
  var components = name.substring(1, nameEndPos).split('@');
  components.reverse();
  return components.join('::');
function ArgumentsProcessor(args) {
  this.args_ = args;
  this.result_ = ArgumentsProcessor.DEFAULTS;
  this.argsDispatch_ = {
    '-j': ['stateFilter', TickProcessor.VmStates.JS,
        'Show only ticks from JS VM state'],
    '-g': ['stateFilter', TickProcessor.VmStates.GC,
        'Show only ticks from GC VM state'],
    '-c': ['stateFilter', TickProcessor.VmStates.COMPILER,
        'Show only ticks from COMPILER VM state'],
    '-o': ['stateFilter', TickProcessor.VmStates.OTHER,
        'Show only ticks from OTHER VM state'],
    '-e': ['stateFilter', TickProcessor.VmStates.EXTERNAL,
        'Show only ticks from EXTERNAL VM state'],
    '--call-graph-size': ['callGraphSize', TickProcessor.CALL_GRAPH_SIZE,
        'Set the call graph size'],
    '--ignore-unknown': ['ignoreUnknown', true,
        'Exclude ticks of unknown code entries from processing'],
    '--separate-ic': ['separateIc', true,
        'Separate IC entries'],
    '--unix': ['platform', 'unix',
        'Specify that we are running on *nix platform'],
    '--windows': ['platform', 'windows',
        'Specify that we are running on Windows platform'],
    '--mac': ['platform', 'mac',
        'Specify that we are running on Mac OS X platform'],
    '--nm': ['nm', 'nm',
        'Specify the \'nm\' executable to use (e.g. --nm=/my_dir/nm)'],
    '--target': ['targetRootFS', '',
        'Specify the target root directory for cross environment'],
    '--snapshot-log': ['snapshotLogFileName', 'snapshot.log',
        'Specify snapshot log file to use (e.g. --snapshot-log=snapshot.log)'],
    '--range': ['range', 'auto,auto',
        'Specify the range limit as [start],[end]'],
    '--distortion': ['distortion', 0,
        'Specify the logging overhead in picoseconds'],
    '--source-map': ['sourceMap', null,
        'Specify the source map that should be used for output'],
    '--timed-range': ['timedRange', true,
        'Ignore ticks before first and after last Date.now() call'],
    '--pairwise-timed-range': ['pairwiseTimedRange', true,
        'Ignore ticks outside pairs of Date.now() calls']
  };
  this.argsDispatch_['--js'] = this.argsDispatch_['-j'];
  this.argsDispatch_['--gc'] = this.argsDispatch_['-g'];
  this.argsDispatch_['--compiler'] = this.argsDispatch_['-c'];
  this.argsDispatch_['--other'] = this.argsDispatch_['-o'];
  this.argsDispatch_['--external'] = this.argsDispatch_['-e'];
  this.argsDispatch_['--ptr'] = this.argsDispatch_['--pairwise-timed-range'];
ArgumentsProcessor.DEFAULTS = {
  logFileName: 'v8.log',
  snapshotLogFileName: null,
  platform: 'unix',
  stateFilter: null,
  callGraphSize: 5,
  ignoreUnknown: false,
  separateIc: false,
  targetRootFS: '',
  nm: 'nm',
  range: 'auto,auto',
  distortion: 0,
  timedRange: false,
  pairwiseTimedRange: false
ArgumentsProcessor.prototype.parse = function() {
  while (this.args_.length) {
    var arg = this.args_.shift();
    if (arg.charAt(0) != '-') {
      this.result_.logFileName = arg;
      continue;
    }
    var userValue = null;
    var eqPos = arg.indexOf('=');
    if (eqPos != -1) {
      userValue = arg.substr(eqPos + 1);
      arg = arg.substr(0, eqPos);
    }
    if (arg in this.argsDispatch_) {
      var dispatch = this.argsDispatch_[arg];
      this.result_[dispatch[0]] = userValue == null ? dispatch[1] : userValue;
    } else {
      return false;
    }
  return true;
ArgumentsProcessor.prototype.result = function() {
  return this.result_;
ArgumentsProcessor.prototype.printUsageAndExit = function() {
  function padRight(s, len) {
    s = s.toString();
    if (s.length < len) {
      s = s + (new Array(len - s.length + 1).join(' '));
    }
    return s;
  print('Cmdline args: [options] [log-file-name]\n' +
        'Default log file name is "' +
        ArgumentsProcessor.DEFAULTS.logFileName + '".\n');
  print('Options:');
  for (var arg in this.argsDispatch_) {
    var synonyms = [arg];
    var dispatch = this.argsDispatch_[arg];
    for (var synArg in this.argsDispatch_) {
      if (arg !== synArg && dispatch === this.argsDispatch_[synArg]) {
        synonyms.push(synArg);
        delete this.argsDispatch_[synArg];
      }
    }
    print('  ' + padRight(synonyms.join(', '), 20) + " " + dispatch[2]);
  quit(2);
// Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// This is a copy from blink dev tools, see:
// http://src.chromium.org/viewvc/blink/trunk/Source/devtools/front_end/SourceMap.js
// revision: 153407
// Added to make the file work without dev tools
WebInspector = {};
WebInspector.ParsedURL = {};
WebInspector.ParsedURL.completeURL = function(){};
// start of original file content
 * Copyright (C) 2012 Google Inc. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Implements Source Map V3 model. See http://code.google.com/p/closure-compiler/wiki/SourceMaps
 * for format description.
 * @constructor
 * @param {string} sourceMappingURL
 * @param {SourceMapV3} payload
WebInspector.SourceMap = function(sourceMappingURL, payload)
    if (!WebInspector.SourceMap.prototype._base64Map) {
        const base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        WebInspector.SourceMap.prototype._base64Map = {};
        for (var i = 0; i < base64Digits.length; ++i)
            WebInspector.SourceMap.prototype._base64Map[base64Digits.charAt(i)] = i;
    }
    this._sourceMappingURL = sourceMappingURL;
    this._reverseMappingsBySourceURL = {};
    this._mappings = [];
    this._sources = {};
    this._sourceContentByURL = {};
    this._parseMappingPayload(payload);
 * @param {string} sourceMapURL
 * @param {string} compiledURL
 * @param {function(WebInspector.SourceMap)} callback
WebInspector.SourceMap.load = function(sourceMapURL, compiledURL, callback)
    NetworkAgent.loadResourceForFrontend(WebInspector.resourceTreeModel.mainFrame.id, sourceMapURL, undefined, contentLoaded.bind(this));
    /**
     * @param {?Protocol.Error} error
     * @param {number} statusCode
     * @param {NetworkAgent.Headers} headers
     * @param {string} content
     */
    function contentLoaded(error, statusCode, headers, content)
    {
        if (error || !content || statusCode >= 400) {
            console.error("Could not load content for " + sourceMapURL + " : " + (error || ("HTTP status code: " + statusCode)));
            callback(null);
            return;
        }
        if (content.slice(0, 3) === ")]}")
            content = content.substring(content.indexOf('\n'));
        try {
            var payload = /** @type {SourceMapV3} */ (JSON.parse(content));
            var baseURL = sourceMapURL.startsWith("data:") ? compiledURL : sourceMapURL;
            callback(new WebInspector.SourceMap(baseURL, payload));
        } catch(e) {
            console.error(e.message);
            callback(null);
        }
    }
WebInspector.SourceMap.prototype = {
    /**
     * @return {Array.<string>}
     */
    sources: function()
    {
        return Object.keys(this._sources);
    },
    /**
     * @param {string} sourceURL
     * @return {string|undefined}
     */
    sourceContent: function(sourceURL)
    {
        return this._sourceContentByURL[sourceURL];
    },
    /**
     * @param {string} sourceURL
     * @param {WebInspector.ResourceType} contentType
     * @return {WebInspector.ContentProvider}
     */
    sourceContentProvider: function(sourceURL, contentType)
    {
        var lastIndexOfDot = sourceURL.lastIndexOf(".");
        var extension = lastIndexOfDot !== -1 ? sourceURL.substr(lastIndexOfDot + 1) : "";
        var mimeType = WebInspector.ResourceType.mimeTypesForExtensions[extension.toLowerCase()];
        var sourceContent = this.sourceContent(sourceURL);
        if (sourceContent)
            return new WebInspector.StaticContentProvider(contentType, sourceContent, mimeType);
        return new WebInspector.CompilerSourceMappingContentProvider(sourceURL, contentType, mimeType);
    },
    /**
     * @param {SourceMapV3} mappingPayload
     */
    _parseMappingPayload: function(mappingPayload)
    {
        if (mappingPayload.sections)
            this._parseSections(mappingPayload.sections);
        else
            this._parseMap(mappingPayload, 0, 0);
    },
    /**
     * @param {Array.<SourceMapV3.Section>} sections
     */
    _parseSections: function(sections)
    {
        for (var i = 0; i < sections.length; ++i) {
            var section = sections[i];
            this._parseMap(section.map, section.offset.line, section.offset.column);
        }
    },
    /**
     * @param {number} lineNumber in compiled resource
     * @param {number} columnNumber in compiled resource
     * @return {?Array}
     */
    findEntry: function(lineNumber, columnNumber)
    {
        var first = 0;
        var count = this._mappings.length;
        while (count > 1) {
          var step = count >> 1;
          var middle = first + step;
          var mapping = this._mappings[middle];
          if (lineNumber < mapping[0] || (lineNumber === mapping[0] && columnNumber < mapping[1]))
              count = step;
          else {
              first = middle;
              count -= step;
          }
        }
        var entry = this._mappings[first];
        if (!first && entry && (lineNumber < entry[0] || (lineNumber === entry[0] && columnNumber < entry[1])))
            return null;
        return entry;
    },
    /**
     * @param {string} sourceURL of the originating resource
     * @param {number} lineNumber in the originating resource
     * @return {Array}
     */
    findEntryReversed: function(sourceURL, lineNumber)
    {
        var mappings = this._reverseMappingsBySourceURL[sourceURL];
        for ( ; lineNumber < mappings.length; ++lineNumber) {
            var mapping = mappings[lineNumber];
            if (mapping)
                return mapping;
        }
        return this._mappings[0];
    },
    /**
     * @override
     */
    _parseMap: function(map, lineNumber, columnNumber)
    {
        var sourceIndex = 0;
        var sourceLineNumber = 0;
        var sourceColumnNumber = 0;
        var nameIndex = 0;
        var sources = [];
        var originalToCanonicalURLMap = {};
        for (var i = 0; i < map.sources.length; ++i) {
            var originalSourceURL = map.sources[i];
            var sourceRoot = map.sourceRoot || "";
            if (sourceRoot && !sourceRoot.endsWith("/"))
                sourceRoot += "/";
            var href = sourceRoot + originalSourceURL;
            var url = WebInspector.ParsedURL.completeURL(this._sourceMappingURL, href) || href;
            originalToCanonicalURLMap[originalSourceURL] = url;
            sources.push(url);
            this._sources[url] = true;
            if (map.sourcesContent && map.sourcesContent[i])
                this._sourceContentByURL[url] = map.sourcesContent[i];
        }
        var stringCharIterator = new WebInspector.SourceMap.StringCharIterator(map.mappings);
        var sourceURL = sources[sourceIndex];
        while (true) {
            if (stringCharIterator.peek() === ",")
                stringCharIterator.next();
            else {
                while (stringCharIterator.peek() === ";") {
                    lineNumber += 1;
                    columnNumber = 0;
                    stringCharIterator.next();
                }
                if (!stringCharIterator.hasNext())
                    break;
            }
            columnNumber += this._decodeVLQ(stringCharIterator);
            if (this._isSeparator(stringCharIterator.peek())) {
                this._mappings.push([lineNumber, columnNumber]);
                continue;
            }
            var sourceIndexDelta = this._decodeVLQ(stringCharIterator);
            if (sourceIndexDelta) {
                sourceIndex += sourceIndexDelta;
                sourceURL = sources[sourceIndex];
            }
            sourceLineNumber += this._decodeVLQ(stringCharIterator);
            sourceColumnNumber += this._decodeVLQ(stringCharIterator);
            if (!this._isSeparator(stringCharIterator.peek()))
                nameIndex += this._decodeVLQ(stringCharIterator);
            this._mappings.push([lineNumber, columnNumber, sourceURL, sourceLineNumber, sourceColumnNumber]);
        }
        for (var i = 0; i < this._mappings.length; ++i) {
            var mapping = this._mappings[i];
            var url = mapping[2];
            if (!url)
                continue;
            if (!this._reverseMappingsBySourceURL[url])
                this._reverseMappingsBySourceURL[url] = [];
            var reverseMappings = this._reverseMappingsBySourceURL[url];
            var sourceLine = mapping[3];
            if (!reverseMappings[sourceLine])
                reverseMappings[sourceLine] = [mapping[0], mapping[1]];
        }
    },
    /**
     * @param {string} char
     * @return {boolean}
     */
    _isSeparator: function(char)
    {
        return char === "," || char === ";";
    },
    /**
     * @param {WebInspector.SourceMap.StringCharIterator} stringCharIterator
     * @return {number}
     */
    _decodeVLQ: function(stringCharIterator)
    {
        // Read unsigned value.
        var result = 0;
        var shift = 0;
        do {
            var digit = this._base64Map[stringCharIterator.next()];
            result += (digit & this._VLQ_BASE_MASK) << shift;
            shift += this._VLQ_BASE_SHIFT;
        } while (digit & this._VLQ_CONTINUATION_MASK);
        // Fix the sign.
        var negative = result & 1;
        result >>= 1;
        return negative ? -result : result;
    },
    _VLQ_BASE_SHIFT: 5,
    _VLQ_BASE_MASK: (1 << 5) - 1,
    _VLQ_CONTINUATION_MASK: 1 << 5
 * @constructor
 * @param {string} string
WebInspector.SourceMap.StringCharIterator = function(string)
    this._string = string;
    this._position = 0;
WebInspector.SourceMap.StringCharIterator.prototype = {
    /**
     * @return {string}
     */
    next: function()
    {
        return this._string.charAt(this._position++);
    },
    /**
     * @return {string}
     */
    peek: function()
    {
        return this._string.charAt(this._position);
    },
    /**
     * @return {boolean}
     */
    hasNext: function()
    {
        return this._position < this._string.length;
    }
// Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// Tick Processor's code flow.
function processArguments(args) {
  var processor = new ArgumentsProcessor(args);
  if (processor.parse()) {
    return processor.result();
  } else {
    processor.printUsageAndExit();
function initSourceMapSupport() {
  // Pull dev tools source maps  into our name space.
  SourceMap = WebInspector.SourceMap;
  // Overwrite the load function to load scripts synchronously.
  SourceMap.load = function(sourceMapURL) {
    var content = readFile(sourceMapURL);
    var sourceMapObject = (JSON.parse(content));
    return new SourceMap(sourceMapURL, sourceMapObject);
  };
var entriesProviders = {
  'unix': UnixCppEntriesProvider,
  'windows': WindowsCppEntriesProvider,
  'mac': MacCppEntriesProvider
var params = processArguments(arguments);
var sourceMap = null;
if (params.sourceMap) {
  initSourceMapSupport();
  sourceMap = SourceMap.load(params.sourceMap);
var snapshotLogProcessor;
if (params.snapshotLogFileName) {
  snapshotLogProcessor = new SnapshotLogProcessor();
  snapshotLogProcessor.processLogFile(params.snapshotLogFileName);
var tickProcessor = new TickProcessor(
  new (entriesProviders[params.platform])(params.nm, params.targetRootFS),
  params.separateIc,
  params.callGraphSize,
  params.ignoreUnknown,
  params.stateFilter,
  snapshotLogProcessor,
  params.distortion,
  params.range,
  sourceMap,
  params.timedRange,
  params.pairwiseTimedRange);
tickProcessor.processLogFile(params.logFileName);
tickProcessor.printStatistics();
# Do not edit. Generated by the configure script.
{ 'target_defaults': { 'cflags': [],
                       'default_configuration': 'Release',
                       'defines': [],
                       'include_dirs': [],
                       'libraries': []},
  'variables': { 'asan': 0,
                 'host_arch': 'x64',
                 'icu_small': 'false',
                 'llvm_version': 0,
                 'node_byteorder': 'little',
                 'node_enable_v8_vtunejit': 'false',
                 'node_install_npm': 'true',
                 'node_prefix': '/usr/local',
                 'node_release_urlbase': '',
                 'node_shared_http_parser': 'false',
                 'node_shared_libuv': 'false',
                 'node_shared_openssl': 'false',
                 'node_shared_zlib': 'false',
                 'node_tag': '',
                 'node_use_dtrace': 'true',
                 'node_use_etw': 'false',
                 'node_use_lttng': 'false',
                 'node_use_openssl': 'true',
                 'node_use_perfctr': 'false',
                 'openssl_fips': '',
                 'openssl_no_asm': 0,
                 'target_arch': 'x64',
                 'uv_parent_path': '/deps/uv/',
                 'uv_use_dtrace': 'true',
                 'v8_enable_gdbjit': 0,
                 'v8_enable_i18n_support': 0,
                 'v8_no_strict_aliasing': 1,
                 'v8_optimized_debug': 0,
                 'v8_random_seed': 0,
                 'v8_use_snapshot': 'true',
                 'want_separate_host_toolset': 0,
                 'xcode_version': '8.0'}}
?456789:;<=
 !"#$%&'()*+,-./0123
-----BEGIN PUBLIC KEY-----
-----BEGIN RSA PUBLIC KEY-----
Operation not supported
CNNIC1
CNNIC ROOT
CN1200
)China Internet Network Information Center1G0E
>China Internet Network Information Center EV Certificates Root
A:B=
(u)/,
-3z0iL?
!!7Xp
j0+X
TA2
$b_k
HF)g
4I;g7
${l'n
jZ1rB
PLE<
gg2cI
StYul
3F>
*M~k
:l9=
81g>
:__?8S
b':
4fTm
@8=4={?j
ie)(
nOpr
%]-oMR
5\x>
7n;f
VFzE
o@!%
DK6
 *>4
SzGM
8D~j
`L,
&c0AWJ
N?rIf
w%4jr@
;1<0*g
d1e>
qA$|R
Y\7y
r$zW
FhNf!whp
El82
ka=*
 h\H
'8p`>
7qw[
3qp2i
rWyN>
k=MZN
jxQA39{
yDOo
i?p6%
 N z
ZjRe
!)[;epI!
/+WG
]fhv
J82 a
(:s9n
XJ\"
B!:jQ
eUN]cj4,
y_U
T5J?hC
,C$}
7$bRH2
mX$c
.GUq
$m1HruY
z`:G;j
@F8~
q;%ZI
oRQ46
dk>%
!^re
dB<t
4m`7
c-=0?
?}{
[)yom#
\q5?
_Z/M=
(&d=Z
gz;h
&E@H/
ne{g$
d~d
~Us{
>+0
s64/
z+w8
_rx8
.C*T]
7n /9
UOHzRv/y
g 9W
Q7,(2i3{
GM>,
(MU1
05;A
o^']g
1SGR
O!O&
M/Up
G<mU
.L$z^I
&k2P
dPJq
i:Z?x
"s'8
<9H"5X
|k\k@
KT9N
h}`46E
8#NU
0'& 
c9!\
T(9#
-29}
RU1X]
>] -
b9U9
RYMsh
Dw1r
;Ssym}
VCU4nF
E:XP
gILhN
Pvcp
11ph
<86.
B&\'
T:ae=w
'XP=
>o7S
r8.Y
@'Nf
F?O(
=M?\
[7"Lg
Ht?
*H<g
7Z$BS
')B]N
B{m=
&+Nq2
|E>"s<
8t=T
M;E`
$Mc
D9W%X
q28
N@N!
9^E[N
=6&d7
Scif
}ex,O
ENihy 
Y={1.
_/cS.
VH:vCz
[HaV
48QS
EAYAcId
=&$
Z?c4
Z#Gg,
iJG[
f<B/B5
'cU#Y
gGw^+,
hf3_
9O/xGv
L3nF
#L:v
,p%
.G7rd
`L<|
bc}d
cNzsv
M%.n
1V{i1K
MTMNA
mPnv
2S=P
6zrXA
tNV(
}YO#
lU\lCO
*kjh.
8P0U
I|Cs?9~
+D\m
Qj/3`
n-q 
#vj&U
SydX
E)|C
+7/]
hLQ"BbC
a*)S
;H/Q
@fU!
rF6Ax
Lo04
C',D
*a{(
d'9Y
=V7aA
iD@[
Q^}8
wMCo
CSF;
9HN>
[)=0
1U[}
xUin
-]iRM
\!iv
`(k_
'`8B
yK:5
Mk`L
'k74u
K4Kc
f+-D1:
]fyG
G1Ncn
3z9n
2fKtb.
i(t@
V1>xcd
12.Wti
]cj%
>}!b)
a|`;}
Wgm!S
Drsk
dL?N
fy(~
JQqd
QE|f
Ia.`
?_>Q
'=5i
s,Zn
%G;!%
nFXb
ZcbU
6C}6
Nv16j
?"-z
B$.v?
kUu#
8\+u
[/a"
qHmlg
cRZe
sdP
NR~t
|-p?U
u\h 
]\1'M
rp?dF
qT%k
b@?cv
(&a<
*"1-t
Hdu*:
=`Xv
SNU1*~
tDj?s)bC
/s;B$%
_c%0;I
Vr4h
6.hm
q#IHd
jM z
DwO@r
HwYq
*Wp%
rTj9
xA67
0@Zr
!5~K
yDZC{
b{q}
/E5y
(}Ox
N:B+
z'u3
4z3]M
sy}:[
XKBU
jW4{
Hn74
}-1+
P%<0H
~4+]s
jpTT
y1i"
9q2=
=AS=A]
%T4w:
0drP#
:t.5
Z&EYU
IF:Z_[
,%/t
6:yk`
`tcy)Lv
[cX40{
aqmz
.lu|C5
EBHnVD,
8%ii
Qvxa
wcbx
6p7.fm
ht (Kv
CsF
{#9C
Byr`
_/y}b
&*_;}
;"\7
SVp[dBj
K+S/]
f@e,Js
u>MH
6ZkK
mT?@
Ut8]
Do\yT
81n8
,q.#
-\-%s
q'v.
0|v6
t[0H
8niO
$L /<
kalm
%Qe
crn#:
jdc]|
IEmm;r
|^jN
d1B[
lyu^
<Wv.
T8?Ay
Hq_S}
p_ee
^t#t
(:Uw
$n%T_6
l__Q\-
J>l1
b7@#
kQ~2~
ng7e,B
 pib
$l!e
XlF.
k6$~
i,No
NYMf|DD
y!mUm
%JrW
{=F4_
V['xT
/GQ/T
\p)E
\-Yy]
SbAK
1OCJ
:g/yg`
4YHe
Xp8]
;OGN
^E,U
Vuz$R
HQ$%
UmI;R
6v+%2A-
nK6w0
'VEg
c[LA
jU.j
gi7
Mty
cjzH
X|wZe!
|F+J
`riZ
(Su5
kh7V!-
 omEC
kb]~23
0nB>
?R&v
1P_8KR<,
NgVI
WQe-
e?(p
KZY01P
PF?!
Mbs8
B{v{
vy=lc
~(t]
&5ip
nAxg
r?g<
I'[l
N2ym
%6/hTJ
Fe`j
u|""
=OZz$
Df_h4
21JW!
{Kbeq
H;-`
xOD[C
UngZ
P$I|
1z,kT
'H^D
lq'%
U"-8{
pDino
Y/p{
'|^R
+V-s
A$Lk
h5O|6$-
67X$Q
I ;J
^qk`
U@+yx[7
vdLX
,LvE
 UGf
ISRm
-#=`
KfF2
mLix
|H<C
DPh"l
pjqz
b1e_
08~3
v49#ma
}?*f
GGqZ'M?
:9_~W<
;V/9
f4+y
z?Ye
Hvpx
=|,AO
1rtzG
c4k1
zt3Y
U-*pp
VrH0
<[a0v
2T%I
U}>-
98m`4
i-I/Ll
7x'P
Mo|2W
ETXi
"UwN
UrW!0qsh
x.a`
sNM"
o[5u+
s~|j
r@g/B
 Oce
).ol:
O]1]@[
.]_p 1
NxBL
{b5x
-qD~
>J|
UaeI
~PHf
"_72d
N\"n
rsP&G
XEdQ`
/q$;l
\bQ2
-y7lr
y[w9>-
_j*'f
K(p3
>uVM
<v60mQ
"YGo
5=<(A
{9m%
rN{'
/#lra
BBOr
diLD
%`qX
xihF
gJZL;M5b
~MYv
z"%uUB 
ms!8_
MrCv
`dEL
nC=O_
!<EQ
ycj5'
H32]
Rvv0/
7RuK8
+t?o
N:GL
6%Z<6
eu>E
5q7aRz
m466R
hC D5
U56W
:vi
vUj
]Js;`
pm"U_
%XRS
%?p6
|NE{e
Ha;Y$-
wRJ8
;Q#|
F_:GO
u,/t]Y
%:d|
^p4m
@<>+
[_y*
dD>/c
rR]J
:6.h`
z9<2
vkC^l&
v6bk
&*SR
&krXV
3)}B
fsV'
w!%)
QPxW
QYGyP
1XU*(
qhhgZ
^jZ|
?smN
5mmQ
vb^~
5mmQ
vb^~
I(fQ
5mmQ
vb^~
I(fQ
mg5NJ
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
Wza]lw
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
Wza]lw
(|YGNk
v!pH
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
Wza]lw
(|YGNk
v!pH
8/A0
%K3 QQ+
^p/F
f?H`
5mmQ
vb^~
I(fQ
mg5NJ
^F.6
Wza]lw
(|YGNk
v!pH
8/A0
%K3 QQ+
^p/F
f?H`
-----BEGIN CERTIFICATE-----
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
Z* ,
H$6t
_~6
52F*
#jT$
^6o}
[-&LMb#{'
w+OQvr
R1h58
SKyu
)\ZEo^m/
ru&o
i8P/_
?(3w
H*0"ZOW
{kHw
)T`D
!AxU
l!;b
:1X:
y9*O
kM`~
Vc0a
dQy/
lDa>
7~8A
C-Yn
gqr<
$/o|
f-=v
mj>zjZ
l6qnk
IiGM>nw
1A26b
i91k
ewh/?y
*5KS
6~_'
F*.f
1wsHp
M8MF
Pe6^
#bML"
`F(>
vQO+t
[h1R
XsBI
hPU3
^oEZ_
2%k_
w3Xc
/P8i
OZw3(?
Z"0*
fP~V
D`T
^GP~
b;!l
V_:X1:
NJ2"v
O*9y]
fu`z
/yQA
&]|v
 deflate 1.2.8 Copyright 1995-2013 Jean-loup Gailly and Mark Adler 
 inflate 1.2.8 Copyright 1995-2013 Mark Adler 


#$%&'
0123456789
abcdefghijklmnopqrstuvwxyz
^_`abcdefghijklmnopqrstuvwxyz
%u.%u.%u.%u
0123456789
0123456789abcdef
0123456789ABCDEF
@wKA
"use strict";
var kDefaultBacktraceLength=10;
var Debug={};
var sourceLineBeginningSkip=/^(?:\s*(?:\/\*.*?\*\/)*)*/;
Debug.DebugEvent={Break:1,
Exception:2,
NewFunction:3,
BeforeCompile:4,
AfterCompile:5,
CompileError:6,
PromiseEvent:7,
AsyncTaskEvent:8};
Debug.ExceptionBreak={Caught:0,
Uncaught:1};
Debug.StepAction={StepOut:0,
StepNext:1,
StepIn:2,
StepMin:3,
StepInMin:4,
StepFrame:5};
Debug.ScriptType={Native:0,
Extension:1,
Normal:2};
Debug.ScriptCompilationType={Host:0,
Eval:1,
JSON:2};
Debug.ScriptBreakPointType={ScriptId:0,
ScriptName:1,
ScriptRegExp:2};
Debug.BreakPositionAlignment={
Statement:0,
BreakPosition:1
function ScriptTypeFlag(a){
return(1<<a);
var next_response_seq=0;
var next_break_point_number=1;
var break_points=[];
var script_break_points=[];
var debugger_flags={
breakPointsActive:{
value:true,
getValue:function(){return this.value;},
setValue:function(a){
this.value=!!a;
%SetDisableBreak(!this.value);
breakOnCaughtException:{
getValue:function(){return Debug.isBreakOnException();},
setValue:function(a){
if(a){
Debug.setBreakOnException();
}else{
Debug.clearBreakOnException();
breakOnUncaughtException:{
getValue:function(){return Debug.isBreakOnUncaughtException();},
setValue:function(a){
if(a){
Debug.setBreakOnUncaughtException();
}else{
Debug.clearBreakOnUncaughtException();
function MakeBreakPoint(a,b){
var c=new BreakPoint(a,b);
break_points.push(c);
return c;
function BreakPoint(a,b){
this.source_position_=a;
if(b){
this.script_break_point_=b;
}else{
this.number_=next_break_point_number++;
this.hit_count_=0;
this.active_=true;
this.condition_=null;
this.ignoreCount_=0;
BreakPoint.prototype.number=function(){
return this.number_;
BreakPoint.prototype.func=function(){
return this.func_;
BreakPoint.prototype.source_position=function(){
return this.source_position_;
BreakPoint.prototype.hit_count=function(){
return this.hit_count_;
BreakPoint.prototype.active=function(){
if(this.script_break_point()){
return this.script_break_point().active();
return this.active_;
BreakPoint.prototype.condition=function(){
if(this.script_break_point()&&this.script_break_point().condition()){
return this.script_break_point().condition();
return this.condition_;
BreakPoint.prototype.ignoreCount=function(){
return this.ignoreCount_;
BreakPoint.prototype.script_break_point=function(){
return this.script_break_point_;
BreakPoint.prototype.enable=function(){
this.active_=true;
BreakPoint.prototype.disable=function(){
this.active_=false;
BreakPoint.prototype.setCondition=function(a){
this.condition_=a;
BreakPoint.prototype.setIgnoreCount=function(a){
this.ignoreCount_=a;
BreakPoint.prototype.isTriggered=function(a){
if(!this.active())return false;
if(this.condition()){
try{
var b=a.frame(0).evaluate(this.condition());
if(!(b instanceof ValueMirror)||
!builtins.$toBoolean(b.value_)){
return false;
}catch(e){
return false;
this.hit_count_++;
if(this.script_break_point_){
this.script_break_point_.hit_count_++;
if(this.ignoreCount_>0){
this.ignoreCount_--;
return false;
return true;
function IsBreakPointTriggered(a,b){
return b.isTriggered(MakeExecutionState(a));
function ScriptBreakPoint(type,script_id_or_name,opt_line,opt_column,
opt_groupId,opt_position_alignment){
this.type_=type;
if(type==Debug.ScriptBreakPointType.ScriptId){
this.script_id_=script_id_or_name;
}else if(type==Debug.ScriptBreakPointType.ScriptName){
this.script_name_=script_id_or_name;
}else if(type==Debug.ScriptBreakPointType.ScriptRegExp){
this.script_regexp_object_=new RegExp(script_id_or_name);
}else{
throw new Error("Unexpected breakpoint type "+type);
this.line_=opt_line||0;
this.column_=opt_column;
this.groupId_=opt_groupId;
this.position_alignment_=(opt_position_alignment===(void 0))
?Debug.BreakPositionAlignment.Statement:opt_position_alignment;
this.hit_count_=0;
this.active_=true;
this.condition_=null;
this.ignoreCount_=0;
this.break_points_=[];
ScriptBreakPoint.prototype.cloneForOtherScript=function(a){
var b=new ScriptBreakPoint(Debug.ScriptBreakPointType.ScriptId,
a.id,this.line_,this.column_,this.groupId_,
this.position_alignment_);
b.number_=next_break_point_number++;
script_break_points.push(b);
b.hit_count_=this.hit_count_;
b.active_=this.active_;
b.condition_=this.condition_;
b.ignoreCount_=this.ignoreCount_;
return b;
ScriptBreakPoint.prototype.number=function(){
return this.number_;
ScriptBreakPoint.prototype.groupId=function(){
return this.groupId_;
ScriptBreakPoint.prototype.type=function(){
return this.type_;
ScriptBreakPoint.prototype.script_id=function(){
return this.script_id_;
ScriptBreakPoint.prototype.script_name=function(){
return this.script_name_;
ScriptBreakPoint.prototype.script_regexp_object=function(){
return this.script_regexp_object_;
ScriptBreakPoint.prototype.line=function(){
return this.line_;
ScriptBreakPoint.prototype.column=function(){
return this.column_;
ScriptBreakPoint.prototype.actual_locations=function(){
var a=[];
for(var b=0;b<this.break_points_.length;b++){
a.push(this.break_points_[b].actual_location);
return a;
ScriptBreakPoint.prototype.update_positions=function(a,b){
this.line_=a;
this.column_=b;
ScriptBreakPoint.prototype.hit_count=function(){
return this.hit_count_;
ScriptBreakPoint.prototype.active=function(){
return this.active_;
ScriptBreakPoint.prototype.condition=function(){
return this.condition_;
ScriptBreakPoint.prototype.ignoreCount=function(){
return this.ignoreCount_;
ScriptBreakPoint.prototype.enable=function(){
this.active_=true;
ScriptBreakPoint.prototype.disable=function(){
this.active_=false;
ScriptBreakPoint.prototype.setCondition=function(a){
this.condition_=a;
ScriptBreakPoint.prototype.setIgnoreCount=function(a){
this.ignoreCount_=a;
for(var b=0;b<this.break_points_.length;b++){
this.break_points_[b].setIgnoreCount(a);
ScriptBreakPoint.prototype.matchesScript=function(a){
if(this.type_==Debug.ScriptBreakPointType.ScriptId){
return this.script_id_==a.id;
}else{
if(!(a.line_offset<=this.line_&&
this.line_<a.line_offset+a.lineCount())){
return false;
if(this.type_==Debug.ScriptBreakPointType.ScriptName){
return this.script_name_==a.nameOrSourceURL();
}else if(this.type_==Debug.ScriptBreakPointType.ScriptRegExp){
return this.script_regexp_object_.test(a.nameOrSourceURL());
}else{
throw new Error("Unexpected breakpoint type "+this.type_);
ScriptBreakPoint.prototype.set=function(a){
var b=this.column();
var c=this.line();
if((b===(void 0))){
var d=a.sourceLine(this.line());
if(!a.sourceColumnStart_){
a.sourceColumnStart_=new Array(a.lineCount());
if((a.sourceColumnStart_[c]===(void 0))){
a.sourceColumnStart_[c]=
d.match(sourceLineBeginningSkip)[0].length;
b=a.sourceColumnStart_[c];
var e=Debug.findScriptSourcePosition(a,this.line(),b);
if((e===null))return;
var f=MakeBreakPoint(e,this);
f.setIgnoreCount(this.ignoreCount());
var g=%SetScriptBreakPoint(a,e,
this.position_alignment_,
if((g===(void 0))){
g=e;
var h=a.locationFromPosition(g,true);
f.actual_location={line:h.line,
column:h.column,
script_id:a.id};
this.break_points_.push(f);
return f;
ScriptBreakPoint.prototype.clear=function(){
var a=[];
for(var b=0;b<break_points.length;b++){
if(break_points[b].script_break_point()&&
break_points[b].script_break_point()===this){
%ClearBreakPoint(break_points[b]);
}else{
a.push(break_points[b]);
break_points=a;
this.break_points_=[];
function UpdateScriptBreakPoints(a){
for(var b=0;b<script_break_points.length;b++){
var c=script_break_points[b];
if((c.type()==Debug.ScriptBreakPointType.ScriptName||
c.type()==Debug.ScriptBreakPointType.ScriptRegExp)&&
c.matchesScript(a)){
c.set(a);
function GetScriptBreakPoints(a){
var b=[];
for(var c=0;c<script_break_points.length;c++){
if(script_break_points[c].matchesScript(a)){
b.push(script_break_points[c]);
return b;
Debug.setListener=function(a,b){
if(!(%_IsFunction(a))&&!(a===(void 0))&&!(a===null)){
throw new Error('Parameters have wrong types.');
%SetDebugEventListener(a,b);
Debug.breakLocations=function(a,b){
if(!(%_IsFunction(a)))throw new Error('Parameters have wrong types.');
var c=(b===(void 0))
?Debug.BreakPositionAlignment.Statement:b;
return %GetBreakLocations(a,c);
Debug.findScript=function(a){
if((%_IsFunction(a))){
return %FunctionGetScript(a);
}else if((%_IsRegExp(a))){
var b=Debug.scripts();
var c=null;
var d=0;
for(var e in b){
var g=b[e];
if(a.test(g.name)){
c=g;
d++;
if(d==1){
return c;
}else{
return undefined;
}else{
return %GetScript(a);
Debug.scriptSource=function(a){
return this.findScript(a).source;
Debug.source=function(a){
if(!(%_IsFunction(a)))throw new Error('Parameters have wrong types.');
return %FunctionGetSourceCode(a);
Debug.sourcePosition=function(a){
if(!(%_IsFunction(a)))throw new Error('Parameters have wrong types.');
return %FunctionGetScriptSourcePosition(a);
Debug.findFunctionSourceLocation=function(a,b,c){
var d=%FunctionGetScript(a);
var e=%FunctionGetScriptSourcePosition(a);
return d.locationFromLine(b,c,e);
Debug.findScriptSourcePosition=function(a,b,c){
var d=a.locationFromLine(b,c);
return d?d.position:null;
Debug.findBreakPoint=function(a,b){
var c;
for(var d=0;d<break_points.length;d++){
if(break_points[d].number()==a){
c=break_points[d];
if(b){
break_points.splice(d,1);
break;
if(c){
return c;
}else{
return this.findScriptBreakPoint(a,b);
Debug.findBreakPointActualLocations=function(a){
for(var b=0;b<script_break_points.length;b++){
if(script_break_points[b].number()==a){
return script_break_points[b].actual_locations();
for(var b=0;b<break_points.length;b++){
if(break_points[b].number()==a){
return[break_points[b].actual_location];
return[];
Debug.setBreakPoint=function(a,b,c,d){
if(!(%_IsFunction(a)))throw new Error('Parameters have wrong types.');
if(%FunctionIsAPIFunction(a)){
throw new Error('Cannot set break point in native code.');
var e=
this.findFunctionSourceLocation(a,b,c).position;
var g=e-this.sourcePosition(a);
var h=%FunctionGetScript(a);
if(h.type==Debug.ScriptType.Native){
throw new Error('Cannot set break point in native code.');
if(h&&h.id){
g+=%FunctionGetScriptSourcePosition(a);
var i=h.locationFromPosition(g,false);
return this.setScriptBreakPointById(h.id,
i.line,i.column,
}else{
var j=MakeBreakPoint(g);
var k=
%SetFunctionBreakPoint(a,g,j);
k+=this.sourcePosition(a);
var l=h.locationFromPosition(k,true);
j.actual_location={line:l.line,
column:l.column,
script_id:h.id};
j.setCondition(d);
return j.number();
Debug.setBreakPointByScriptIdAndPosition=function(script_id,position,
condition,enabled,
opt_position_alignment)
var a=MakeBreakPoint(position);
a.setCondition(condition);
if(!enabled){
a.disable();
var b=this.scripts();
var c=(opt_position_alignment===(void 0))
?Debug.BreakPositionAlignment.Statement:opt_position_alignment;
for(var d=0;d<b.length;d++){
if(script_id==b[d].id){
a.actual_position=%SetScriptBreakPoint(b[d],position,
c,a);
break;
return a;
Debug.enableBreakPoint=function(a){
var b=this.findBreakPoint(a,false);
if(b){
b.enable();
Debug.disableBreakPoint=function(a){
var b=this.findBreakPoint(a,false);
if(b){
b.disable();
Debug.changeBreakPointCondition=function(a,b){
var c=this.findBreakPoint(a,false);
c.setCondition(b);
Debug.changeBreakPointIgnoreCount=function(a,b){
if(b<0){
throw new Error('Invalid argument');
var c=this.findBreakPoint(a,false);
c.setIgnoreCount(b);
Debug.clearBreakPoint=function(a){
var b=this.findBreakPoint(a,true);
if(b){
return %ClearBreakPoint(b);
}else{
b=this.findScriptBreakPoint(a,true);
if(!b){
throw new Error('Invalid breakpoint');
Debug.clearAllBreakPoints=function(){
for(var a=0;a<break_points.length;a++){
var b=break_points[a];
%ClearBreakPoint(b);
break_points=[];
Debug.disableAllBreakPoints=function(){
for(var a=1;a<next_break_point_number;a++){
Debug.disableBreakPoint(a);
%ChangeBreakOnException(Debug.ExceptionBreak.Caught,false);
%ChangeBreakOnException(Debug.ExceptionBreak.Uncaught,false);
Debug.findScriptBreakPoint=function(a,b){
var c;
for(var d=0;d<script_break_points.length;d++){
if(script_break_points[d].number()==a){
c=script_break_points[d];
if(b){
c.clear();
script_break_points.splice(d,1);
break;
return c;
Debug.setScriptBreakPoint=function(type,script_id_or_name,
opt_line,opt_column,opt_condition,
opt_groupId,opt_position_alignment){
var a=
new ScriptBreakPoint(type,script_id_or_name,opt_line,opt_column,
opt_groupId,opt_position_alignment);
a.number_=next_break_point_number++;
a.setCondition(opt_condition);
script_break_points.push(a);
var b=this.scripts();
for(var c=0;c<b.length;c++){
if(a.matchesScript(b[c])){
a.set(b[c]);
return a.number();
Debug.setScriptBreakPointById=function(script_id,
opt_line,opt_column,
opt_condition,opt_groupId,
opt_position_alignment){
return this.setScriptBreakPoint(Debug.ScriptBreakPointType.ScriptId,
script_id,opt_line,opt_column,
opt_condition,opt_groupId,
opt_position_alignment);
Debug.setScriptBreakPointByName=function(script_name,
opt_line,opt_column,
opt_condition,opt_groupId){
return this.setScriptBreakPoint(Debug.ScriptBreakPointType.ScriptName,
script_name,opt_line,opt_column,
opt_condition,opt_groupId);
Debug.setScriptBreakPointByRegExp=function(script_regexp,
opt_line,opt_column,
opt_condition,opt_groupId){
return this.setScriptBreakPoint(Debug.ScriptBreakPointType.ScriptRegExp,
script_regexp,opt_line,opt_column,
opt_condition,opt_groupId);
Debug.enableScriptBreakPoint=function(a){
var b=this.findScriptBreakPoint(a,false);
b.enable();
Debug.disableScriptBreakPoint=function(a){
var b=this.findScriptBreakPoint(a,false);
b.disable();
Debug.changeScriptBreakPointCondition=function(
break_point_number,condition){
var a=this.findScriptBreakPoint(break_point_number,false);
a.setCondition(condition);
Debug.changeScriptBreakPointIgnoreCount=function(
break_point_number,ignoreCount){
if(ignoreCount<0){
throw new Error('Invalid argument');
var a=this.findScriptBreakPoint(break_point_number,false);
a.setIgnoreCount(ignoreCount);
Debug.scriptBreakPoints=function(){
return script_break_points;
Debug.clearStepping=function(){
%ClearStepping();
Debug.setBreakOnException=function(){
return %ChangeBreakOnException(Debug.ExceptionBreak.Caught,true);
Debug.clearBreakOnException=function(){
return %ChangeBreakOnException(Debug.ExceptionBreak.Caught,false);
Debug.isBreakOnException=function(){
return!!%IsBreakOnException(Debug.ExceptionBreak.Caught);
Debug.setBreakOnUncaughtException=function(){
return %ChangeBreakOnException(Debug.ExceptionBreak.Uncaught,true);
Debug.clearBreakOnUncaughtException=function(){
return %ChangeBreakOnException(Debug.ExceptionBreak.Uncaught,false);
Debug.isBreakOnUncaughtException=function(){
return!!%IsBreakOnException(Debug.ExceptionBreak.Uncaught);
Debug.showBreakPoints=function(a,b,c){
if(!(%_IsFunction(a)))throw new Error('Parameters have wrong types.');
var d=b?this.scriptSource(a):this.source(a);
var e=b?this.sourcePosition(a):0;
var g=this.breakLocations(a,c);
if(!g)return d;
g.sort(function(h,i){return h-i;});
var j="";
var k=0;
var l;
for(var m=0;m<g.length;m++){
l=g[m]-e;
j+=d.slice(k,l);
j+="[B"+m+"]";
k=l;
l=d.length;
j+=d.substring(k,l);
return j;
Debug.scripts=function(){
return %DebugGetLoadedScripts();
Debug.debuggerFlags=function(){
return debugger_flags;
Debug.MakeMirror=MakeMirror;
function MakeExecutionState(a){
return new ExecutionState(a);
function ExecutionState(a){
this.break_id=a;
this.selected_frame=0;
ExecutionState.prototype.prepareStep=function(opt_action,opt_count,
opt_callframe){
var a=Debug.StepAction.StepIn;
if(!(opt_action===(void 0)))a=builtins.$toNumber(opt_action);
var b=opt_count?builtins.$toNumber(opt_count):1;
var c=0;
if(!(opt_callframe===(void 0))){
c=opt_callframe.details_.frameId();
return %PrepareStep(this.break_id,a,b,c);
ExecutionState.prototype.evaluateGlobal=function(source,disable_break,
opt_additional_context){
return MakeMirror(%DebugEvaluateGlobal(this.break_id,source,
Boolean(disable_break),
opt_additional_context));
ExecutionState.prototype.frameCount=function(){
return %GetFrameCount(this.break_id);
ExecutionState.prototype.threadCount=function(){
return %GetThreadCount(this.break_id);
ExecutionState.prototype.frame=function(a){
if(a==null)a=this.selected_frame;
if(a<0||a>=this.frameCount()){
throw new Error('Illegal frame index.');
return new FrameMirror(this.break_id,a);
ExecutionState.prototype.setSelectedFrame=function(a){
var b=builtins.$toNumber(a);
if(b<0||b>=this.frameCount())throw new Error('Illegal frame index.');
this.selected_frame=b;
ExecutionState.prototype.selectedFrame=function(){
return this.selected_frame;
ExecutionState.prototype.debugCommandProcessor=function(a){
return new DebugCommandProcessor(this,a);
function MakeBreakEvent(a,b){
return new BreakEvent(a,b);
function BreakEvent(a,b){
this.frame_=new FrameMirror(a,0);
this.break_points_hit_=b;
BreakEvent.prototype.eventType=function(){
return Debug.DebugEvent.Break;
BreakEvent.prototype.func=function(){
return this.frame_.func();
BreakEvent.prototype.sourceLine=function(){
return this.frame_.sourceLine();
BreakEvent.prototype.sourceColumn=function(){
return this.frame_.sourceColumn();
BreakEvent.prototype.sourceLineText=function(){
return this.frame_.sourceLineText();
BreakEvent.prototype.breakPointsHit=function(){
return this.break_points_hit_;
BreakEvent.prototype.toJSONProtocol=function(){
var a={seq:next_response_seq++,
type:"event",
event:"break",
body:{invocationText:this.frame_.invocationText()}
var b=this.func().script();
if(b){
a.body.sourceLine=this.sourceLine(),
a.body.sourceColumn=this.sourceColumn(),
a.body.sourceLineText=this.sourceLineText(),
a.body.script=MakeScriptObject_(b,false);
if(this.breakPointsHit()){
a.body.breakpoints=[];
for(var c=0;c<this.breakPointsHit().length;c++){
var d=this.breakPointsHit()[c];
var e=d.script_break_point();
var g;
if(e){
g=e.number();
}else{
g=d.number();
a.body.breakpoints.push(g);
return JSON.stringify(ObjectToProtocolObject_(a));
function MakeExceptionEvent(a,b,c,d){
return new ExceptionEvent(a,b,c,d);
function ExceptionEvent(a,b,c,d){
this.exec_state_=new ExecutionState(a);
this.exception_=b;
this.uncaught_=c;
this.promise_=d;
ExceptionEvent.prototype.eventType=function(){
return Debug.DebugEvent.Exception;
ExceptionEvent.prototype.exception=function(){
return this.exception_;
ExceptionEvent.prototype.uncaught=function(){
return this.uncaught_;
ExceptionEvent.prototype.promise=function(){
return this.promise_;
ExceptionEvent.prototype.func=function(){
return this.exec_state_.frame(0).func();
ExceptionEvent.prototype.sourceLine=function(){
return this.exec_state_.frame(0).sourceLine();
ExceptionEvent.prototype.sourceColumn=function(){
return this.exec_state_.frame(0).sourceColumn();
ExceptionEvent.prototype.sourceLineText=function(){
return this.exec_state_.frame(0).sourceLineText();
ExceptionEvent.prototype.toJSONProtocol=function(){
var a=new ProtocolMessage();
a.event="exception";
a.body={uncaught:this.uncaught_,
exception:MakeMirror(this.exception_)
if(this.exec_state_.frameCount()>0){
a.body.sourceLine=this.sourceLine();
a.body.sourceColumn=this.sourceColumn();
a.body.sourceLineText=this.sourceLineText();
var b=this.func().script();
if(b){
a.body.script=MakeScriptObject_(b,false);
}else{
a.body.sourceLine=-1;
return a.toJSONProtocol();
function MakeCompileEvent(a,b){
return new CompileEvent(a,b);
function CompileEvent(a,b){
this.script_=MakeMirror(a);
this.type_=b;
CompileEvent.prototype.eventType=function(){
return this.type_;
CompileEvent.prototype.script=function(){
return this.script_;
CompileEvent.prototype.toJSONProtocol=function(){
var a=new ProtocolMessage();
a.running=true;
switch(this.type_){
case Debug.DebugEvent.BeforeCompile:
a.event="beforeCompile";
break;
case Debug.DebugEvent.AfterCompile:
a.event="afterCompile";
break;
case Debug.DebugEvent.CompileError:
a.event="compileError";
break;
a.body={};
a.body.script=this.script_;
return a.toJSONProtocol();
function MakeScriptObject_(a,b){
var c={id:a.id(),
name:a.name(),
lineOffset:a.lineOffset(),
columnOffset:a.columnOffset(),
lineCount:a.lineCount(),
if(!(a.data()===(void 0))){
c.data=a.data();
if(b){
c.source=a.source();
return c;
function MakePromiseEvent(a){
return new PromiseEvent(a);
function PromiseEvent(a){
this.promise_=a.promise;
this.parentPromise_=a.parentPromise;
this.status_=a.status;
this.value_=a.value;
PromiseEvent.prototype.promise=function(){
return MakeMirror(this.promise_);
PromiseEvent.prototype.parentPromise=function(){
return MakeMirror(this.parentPromise_);
PromiseEvent.prototype.status=function(){
return this.status_;
PromiseEvent.prototype.value=function(){
return MakeMirror(this.value_);
function MakeAsyncTaskEvent(a){
return new AsyncTaskEvent(a);
function AsyncTaskEvent(a){
this.type_=a.type;
this.name_=a.name;
this.id_=a.id;
AsyncTaskEvent.prototype.type=function(){
return this.type_;
AsyncTaskEvent.prototype.name=function(){
return this.name_;
AsyncTaskEvent.prototype.id=function(){
return this.id_;
function DebugCommandProcessor(a,b){
this.exec_state_=a;
this.running_=b||false;
DebugCommandProcessor.prototype.processDebugRequest=function(a){
return this.processDebugJSONRequest(a);
function ProtocolMessage(a){
this.seq=next_response_seq++;
if(a){
this.type='response';
this.request_seq=a.seq;
this.command=a.command;
}else{
this.type='event';
this.success=true;
this.running=undefined;
ProtocolMessage.prototype.setOption=function(a,b){
if(!this.options_){
this.options_={};
this.options_[a]=b;
ProtocolMessage.prototype.failed=function(a,b){
this.success=false;
this.message=a;
if((%_IsObject(b))){
this.error_details=b;
ProtocolMessage.prototype.toJSONProtocol=function(){
var a={};
a.seq=this.seq;
if(this.request_seq){
a.request_seq=this.request_seq;
a.type=this.type;
if(this.event){
a.event=this.event;
if(this.command){
a.command=this.command;
if(this.success){
a.success=this.success;
}else{
a.success=false;
if(this.body){
var b;
var c=MakeMirrorSerializer(true,this.options_);
if(this.body instanceof Mirror){
b=c.serializeValue(this.body);
}else if(this.body instanceof Array){
b=[];
for(var d=0;d<this.body.length;d++){
if(this.body[d]instanceof Mirror){
b.push(c.serializeValue(this.body[d]));
}else{
b.push(ObjectToProtocolObject_(this.body[d],c));
}else{
b=ObjectToProtocolObject_(this.body,c);
a.body=b;
a.refs=c.serializeReferencedObjects();
if(this.message){
a.message=this.message;
if(this.error_details){
a.error_details=this.error_details;
a.running=this.running;
return JSON.stringify(a);
DebugCommandProcessor.prototype.createResponse=function(a){
return new ProtocolMessage(a);
DebugCommandProcessor.prototype.processDebugJSONRequest=function(
json_request){
var a;
var b;
try{
try{
a=JSON.parse(json_request);
b=this.createResponse(a);
if(!a.type){
throw new Error('Type not specified');
if(a.type!='request'){
throw new Error("Illegal type '"+a.type+"' in request");
if(!a.command){
throw new Error('Command not specified');
if(a.arguments){
var c=a.arguments;
if(c.inlineRefs||c.compactFormat){
b.setOption('inlineRefs',true);
if(!(c.maxStringLength===(void 0))){
b.setOption('maxStringLength',c.maxStringLength);
var d=a.command.toLowerCase();
var e=DebugCommandProcessor.prototype.dispatch_[d];
if((%_IsFunction(e))){
%_CallFunction(this,a,b,e);
}else{
throw new Error('Unknown command "'+a.command+'" in request');
}catch(e){
if(!b){
b=this.createResponse();
b.success=false;
b.message=builtins.$toString(e);
try{
if(!(b.running===(void 0))){
this.running_=b.running;
b.running=this.running_;
return b.toJSONProtocol();
}catch(e){
return'{"seq":'+b.seq+','+
'"request_seq":'+a.seq+','+
'"type":"response",'+
'"success":false,'+
'"message":"Internal error: '+builtins.$toString(e)+'"}';
}catch(e){
return'{"seq":0,"type":"response","success":false,"message":"Internal error"}';
DebugCommandProcessor.prototype.continueRequest_=function(a,b){
if(a.arguments){
var c=1;
var d=Debug.StepAction.StepIn;
var e=a.arguments.stepaction;
var g=a.arguments.stepcount;
if(g){
c=builtins.$toNumber(g);
if(c<0){
throw new Error('Invalid stepcount argument "'+g+'".');
if(e){
if(e=='in'){
d=Debug.StepAction.StepIn;
}else if(e=='min'){
d=Debug.StepAction.StepMin;
}else if(e=='next'){
d=Debug.StepAction.StepNext;
}else if(e=='out'){
d=Debug.StepAction.StepOut;
}else{
throw new Error('Invalid stepaction argument "'+e+'".');
this.exec_state_.prepareStep(d,c);
b.running=true;
DebugCommandProcessor.prototype.breakRequest_=function(a,b){
DebugCommandProcessor.prototype.setBreakPointRequest_=
function(a,b){
if(!a.arguments){
b.failed('Missing arguments');
return;
var c=a.arguments.type;
var d=a.arguments.target;
var e=a.arguments.line;
var g=a.arguments.column;
var h=(a.arguments.enabled===(void 0))?
true:a.arguments.enabled;
var i=a.arguments.condition;
var j=a.arguments.ignoreCount;
var k=a.arguments.groupId;
if(!c||(d===(void 0))){
b.failed('Missing argument "type" or "target"');
return;
var l;
if(c=='function'){
if(!(typeof(d)==='string')){
b.failed('Argument "target" is not a string value');
return;
var m;
try{
m=this.exec_state_.evaluateGlobal(d).value();
}catch(e){
b.failed('Error: "'+builtins.$toString(e)+
'" evaluating "'+d+'"');
return;
if(!(%_IsFunction(m))){
b.failed('"'+d+'" does not evaluate to a function');
return;
l=Debug.setBreakPoint(m,e,g,i);
}else if(c=='handle'){
var n=parseInt(d,10);
var o=LookupMirror(n);
if(!o){
return b.failed('Object #'+n+'# not found');
if(!o.isFunction()){
return b.failed('Object #'+n+'# is not a function');
l=Debug.setBreakPoint(o.value(),
e,g,i);
}else if(c=='script'){
Debug.setScriptBreakPointByName(d,e,g,i,
}else if(c=='scriptId'){
Debug.setScriptBreakPointById(d,e,g,i,k);
}else if(c=='scriptRegExp'){
Debug.setScriptBreakPointByRegExp(d,e,g,i,
}else{
b.failed('Illegal type "'+c+'"');
return;
var p=Debug.findBreakPoint(l);
if(j){
Debug.changeBreakPointIgnoreCount(l,j);
if(!h){
Debug.disableBreakPoint(l);
b.body={type:c,
breakpoint:l};
if(p instanceof ScriptBreakPoint){
if(p.type()==Debug.ScriptBreakPointType.ScriptId){
b.body.type='scriptId';
b.body.script_id=p.script_id();
}else if(p.type()==Debug.ScriptBreakPointType.ScriptName){
b.body.type='scriptName';
b.body.script_name=p.script_name();
}else if(p.type()==Debug.ScriptBreakPointType.ScriptRegExp){
b.body.type='scriptRegExp';
b.body.script_regexp=p.script_regexp_object().source;
}else{
throw new Error("Internal error: Unexpected breakpoint type: "+
p.type());
b.body.line=p.line();
b.body.column=p.column();
b.body.actual_locations=p.actual_locations();
}else{
b.body.type='function';
b.body.actual_locations=[p.actual_location];
DebugCommandProcessor.prototype.changeBreakPointRequest_=function(
request,response){
if(!request.arguments){
response.failed('Missing arguments');
return;
var a=builtins.$toNumber(request.arguments.breakpoint);
var b=request.arguments.enabled;
var c=request.arguments.condition;
var d=request.arguments.ignoreCount;
if(!a){
response.failed('Missing argument "breakpoint"');
return;
if(!(b===(void 0))){
if(b){
Debug.enableBreakPoint(a);
}else{
Debug.disableBreakPoint(a);
if(!(c===(void 0))){
Debug.changeBreakPointCondition(a,c);
if(!(d===(void 0))){
Debug.changeBreakPointIgnoreCount(a,d);
DebugCommandProcessor.prototype.clearBreakPointGroupRequest_=function(
request,response){
if(!request.arguments){
response.failed('Missing arguments');
return;
var a=request.arguments.groupId;
if(!a){
response.failed('Missing argument "groupId"');
return;
var b=[];
var c=[];
for(var d=0;d<script_break_points.length;d++){
var e=script_break_points[d];
if(e.groupId()==a){
b.push(e.number());
e.clear();
}else{
c.push(e);
script_break_points=c;
response.body={breakpoints:b};
DebugCommandProcessor.prototype.clearBreakPointRequest_=function(
request,response){
if(!request.arguments){
response.failed('Missing arguments');
return;
var a=builtins.$toNumber(request.arguments.breakpoint);
if(!a){
response.failed('Missing argument "breakpoint"');
return;
Debug.clearBreakPoint(a);
response.body={breakpoint:a};
DebugCommandProcessor.prototype.listBreakpointsRequest_=function(
request,response){
var a=[];
for(var b=0;b<script_break_points.length;b++){
var c=script_break_points[b];
var d={
number:c.number(),
line:c.line(),
column:c.column(),
groupId:c.groupId(),
hit_count:c.hit_count(),
active:c.active(),
condition:c.condition(),
ignoreCount:c.ignoreCount(),
actual_locations:c.actual_locations()
if(c.type()==Debug.ScriptBreakPointType.ScriptId){
d.type='scriptId';
d.script_id=c.script_id();
}else if(c.type()==Debug.ScriptBreakPointType.ScriptName){
d.type='scriptName';
d.script_name=c.script_name();
}else if(c.type()==Debug.ScriptBreakPointType.ScriptRegExp){
d.type='scriptRegExp';
d.script_regexp=c.script_regexp_object().source;
}else{
throw new Error("Internal error: Unexpected breakpoint type: "+
c.type());
a.push(d);
response.body={
breakpoints:a,
breakOnExceptions:Debug.isBreakOnException(),
breakOnUncaughtExceptions:Debug.isBreakOnUncaughtException()
DebugCommandProcessor.prototype.disconnectRequest_=
function(a,b){
Debug.disableAllBreakPoints();
this.continueRequest_(a,b);
DebugCommandProcessor.prototype.setExceptionBreakRequest_=
function(a,b){
if(!a.arguments){
b.failed('Missing arguments');
return;
var c=a.arguments.type;
if(!c){
b.failed('Missing argument "type"');
return;
var d;
if(c=='all'){
d=!Debug.isBreakOnException();
}else if(c=='uncaught'){
d=!Debug.isBreakOnUncaughtException();
if(!(a.arguments.enabled===(void 0))){
d=a.arguments.enabled;
if((d!=true)&&(d!=false)){
b.failed('Illegal value for "enabled":"'+d+'"');
if(c=='all'){
%ChangeBreakOnException(Debug.ExceptionBreak.Caught,d);
}else if(c=='uncaught'){
%ChangeBreakOnException(Debug.ExceptionBreak.Uncaught,d);
}else{
b.failed('Unknown "type":"'+c+'"');
b.body={'type':c,'enabled':d};
DebugCommandProcessor.prototype.backtraceRequest_=function(
request,response){
var a=this.exec_state_.frameCount();
if(a==0){
response.body={
totalFrames:a
return;
var b=0;
var c=kDefaultBacktraceLength;
if(request.arguments){
if(request.arguments.fromFrame){
b=request.arguments.fromFrame;
if(request.arguments.toFrame){
c=request.arguments.toFrame;
if(request.arguments.bottom){
var d=a-b;
b=a-c;
c=d;
if(b<0||c<0){
return response.failed('Invalid frame number');
c=Math.min(a,c);
if(c<=b){
var e='Invalid frame range';
return response.failed(e);
var g=[];
for(var h=b;h<c;h++){
g.push(this.exec_state_.frame(h));
response.body={
fromFrame:b,
toFrame:c,
totalFrames:a,
frames:g
DebugCommandProcessor.prototype.frameRequest_=function(a,b){
if(this.exec_state_.frameCount()==0){
return b.failed('No frames');
if(a.arguments){
var c=a.arguments.number;
if(c<0||this.exec_state_.frameCount()<=c){
return b.failed('Invalid frame number');
this.exec_state_.setSelectedFrame(a.arguments.number);
b.body=this.exec_state_.frame();
DebugCommandProcessor.prototype.resolveFrameFromScopeDescription_=
function(a){
if(a&&!(a.frameNumber===(void 0))){
var b=a.frameNumber;
if(b<0||this.exec_state_.frameCount()<=b){
throw new Error('Invalid frame number');
return this.exec_state_.frame(b);
}else{
return this.exec_state_.frame();
DebugCommandProcessor.prototype.resolveScopeHolder_=
function(a){
if(a&&"functionHandle"in a){
if(!(typeof(a.functionHandle)==='number')){
throw new Error('Function handle must be a number');
var b=LookupMirror(a.functionHandle);
if(!b){
throw new Error('Failed to find function object by handle');
if(!b.isFunction()){
throw new Error('Value of non-function type is found by handle');
return b;
}else{
if(this.exec_state_.frameCount()==0){
throw new Error('No scopes');
var c=this.resolveFrameFromScopeDescription_(a);
return c;
DebugCommandProcessor.prototype.scopesRequest_=function(a,b){
var c=this.resolveScopeHolder_(a.arguments);
var d=c.scopeCount();
var e=[];
for(var g=0;g<d;g++){
e.push(c.scope(g));
b.body={
fromScope:0,
toScope:d,
totalScopes:d,
scopes:e
DebugCommandProcessor.prototype.scopeRequest_=function(a,b){
var c=this.resolveScopeHolder_(a.arguments);
var d=0;
if(a.arguments&&!(a.arguments.number===(void 0))){
d=builtins.$toNumber(a.arguments.number);
if(d<0||c.scopeCount()<=d){
return b.failed('Invalid scope number');
b.body=c.scope(d);
DebugCommandProcessor.resolveValue_=function(a){
if("handle"in a){
var b=LookupMirror(a.handle);
if(!b){
throw new Error("Failed to resolve value by handle, ' #"+
a.handle+"# not found");
return b.value();
}else if("stringDescription"in a){
if(a.type==BOOLEAN_TYPE){
return Boolean(a.stringDescription);
}else if(a.type==NUMBER_TYPE){
return Number(a.stringDescription);
}if(a.type==STRING_TYPE){
return String(a.stringDescription);
}else{
throw new Error("Unknown type");
}else if("value"in a){
return a.value;
}else if(a.type==UNDEFINED_TYPE){
return(void 0);
}else if(a.type==NULL_TYPE){
return null;
}else{
throw new Error("Failed to parse value description");
DebugCommandProcessor.prototype.setVariableValueRequest_=
function(a,b){
if(!a.arguments){
b.failed('Missing arguments');
return;
if((a.arguments.name===(void 0))){
b.failed('Missing variable name');
var c=a.arguments.name;
var d=a.arguments.scope;
var e=this.resolveScopeHolder_(d);
if((d.number===(void 0))){
b.failed('Missing scope number');
var g=builtins.$toNumber(d.number);
var h=e.scope(g);
var i=
DebugCommandProcessor.resolveValue_(a.arguments.newValue);
h.setVariableValue(c,i);
var j=MakeMirror(i);
b.body={
newValue:j
DebugCommandProcessor.prototype.evaluateRequest_=function(a,b){
if(!a.arguments){
return b.failed('Missing arguments');
var c=a.arguments.expression;
var d=a.arguments.frame;
var e=a.arguments.global;
var g=a.arguments.disable_break;
var h=a.arguments.additional_context;
try{
c=String(c);
}catch(e){
return b.failed('Failed to convert expression argument to string');
if(!(d===(void 0))&&e){
return b.failed('Arguments "frame" and "global" are exclusive');
var i;
if(h){
i={};
for(var j=0;j<h.length;j++){
var k=h[j];
if(!(typeof(k.name)==='string')){
return b.failed("Context element #"+j+
" doesn't contain name:string property");
var l=DebugCommandProcessor.resolveValue_(k);
i[k.name]=l;
if(e){
b.body=this.exec_state_.evaluateGlobal(
c,Boolean(g),i);
return;
if((g===(void 0))){
g=true;
if(this.exec_state_.frameCount()==0){
return b.failed('No frames');
if(!(d===(void 0))){
var m=builtins.$toNumber(d);
if(m<0||m>=this.exec_state_.frameCount()){
return b.failed('Invalid frame "'+d+'"');
b.body=this.exec_state_.frame(m).evaluate(
c,Boolean(g),i);
return;
}else{
b.body=this.exec_state_.frame().evaluate(
c,Boolean(g),i);
return;
DebugCommandProcessor.prototype.lookupRequest_=function(a,b){
if(!a.arguments){
return b.failed('Missing arguments');
var c=a.arguments.handles;
if((c===(void 0))){
return b.failed('Argument "handles" missing');
if(!(a.arguments.includeSource===(void 0))){
var d=builtins.$toBoolean(a.arguments.includeSource);
b.setOption('includeSource',d);
var e={};
for(var g=0;g<c.length;g++){
var h=c[g];
var i=LookupMirror(h);
if(!i){
return b.failed('Object #'+h+'# not found');
e[h]=i;
b.body=e;
DebugCommandProcessor.prototype.referencesRequest_=
function(a,b){
if(!a.arguments){
return b.failed('Missing arguments');
var c=a.arguments.type;
var d=a.arguments.handle;
if((c===(void 0))){
return b.failed('Argument "type" missing');
if((d===(void 0))){
return b.failed('Argument "handle" missing');
if(c!='referencedBy'&&c!='constructedBy'){
return b.failed('Invalid type "'+c+'"');
var e=LookupMirror(d);
if(e){
if(c=='referencedBy'){
b.body=e.referencedBy();
}else{
b.body=e.constructedBy();
}else{
return b.failed('Object #'+d+'# not found');
DebugCommandProcessor.prototype.sourceRequest_=function(a,b){
if(this.exec_state_.frameCount()==0){
return b.failed('No source');
var c;
var d;
var e=this.exec_state_.frame();
if(a.arguments){
c=a.arguments.fromLine;
d=a.arguments.toLine;
if(!(a.arguments.frame===(void 0))){
var g=builtins.$toNumber(a.arguments.frame);
if(g<0||g>=this.exec_state_.frameCount()){
return b.failed('Invalid frame "'+e+'"');
e=this.exec_state_.frame(g);
var h=e.func().script();
if(!h){
return b.failed('No source');
var i=h.sourceSlice(c,d);
if(!i){
return b.failed('Invalid line interval');
b.body={};
b.body.source=i.sourceText();
b.body.fromLine=i.from_line;
b.body.toLine=i.to_line;
b.body.fromPosition=i.from_position;
b.body.toPosition=i.to_position;
b.body.totalLines=h.lineCount();
DebugCommandProcessor.prototype.scriptsRequest_=function(a,b){
var c=ScriptTypeFlag(Debug.ScriptType.Normal);
var d=false;
var e=null;
if(a.arguments){
if(!(a.arguments.types===(void 0))){
c=builtins.$toNumber(a.arguments.types);
if(isNaN(c)||c<0){
return b.failed('Invalid types "'+
a.arguments.types+'"');
if(!(a.arguments.includeSource===(void 0))){
d=builtins.$toBoolean(a.arguments.includeSource);
b.setOption('includeSource',d);
if((%_IsArray(a.arguments.ids))){
e={};
var g=a.arguments.ids;
for(var h=0;h<g.length;h++){
e[g[h]]=true;
var i=null;
var j=null;
if(!(a.arguments.filter===(void 0))){
var k=builtins.$toNumber(a.arguments.filter);
if(!isNaN(k)){
j=k;
i=a.arguments.filter;
var l=%DebugGetLoadedScripts();
b.body=[];
for(var h=0;h<l.length;h++){
if(e&&!e[l[h].id]){
continue;
if(i||j){
var m=l[h];
var n=false;
if(j&&!n){
if(m.id&&m.id===j){
n=true;
if(i&&!n){
if(m.name&&m.name.indexOf(i)>=0){
n=true;
if(!n)continue;
if(c&ScriptTypeFlag(l[h].type)){
b.body.push(MakeMirror(l[h]));
DebugCommandProcessor.prototype.threadsRequest_=function(a,b){
var c=this.exec_state_.threadCount();
var d=[];
for(var e=0;e<c;e++){
var g=%GetThreadDetails(this.exec_state_.break_id,e);
var h={current:g[0],
id:g[1]
d.push(h);
b.body={
totalThreads:c,
threads:d
DebugCommandProcessor.prototype.suspendRequest_=function(a,b){
b.running=false;
DebugCommandProcessor.prototype.versionRequest_=function(a,b){
b.body={
V8Version:%GetV8Version()
DebugCommandProcessor.prototype.changeLiveRequest_=function(
request,response){
if(!request.arguments){
return response.failed('Missing arguments');
var a=request.arguments.script_id;
var b=!!request.arguments.preview_only;
var c=%DebugGetLoadedScripts();
var d=null;
for(var e=0;e<c.length;e++){
if(c[e].id==a){
d=c[e];
if(!d){
response.failed('Script not found');
return;
var g=new Array();
if(!(typeof(request.arguments.new_source)==='string')){
throw"new_source argument expected";
var h=request.arguments.new_source;
var i;
try{
i=Debug.LiveEdit.SetScriptSource(d,
h,b,g);
}catch(e){
if(e instanceof Debug.LiveEdit.Failure&&"details"in e){
response.failed(e.message,e.details);
return;
throw e;
response.body={change_log:g,result:i};
if(!b&&!this.running_&&i.stack_modified){
response.body.stepin_recommended=true;
DebugCommandProcessor.prototype.restartFrameRequest_=function(
request,response){
if(!request.arguments){
return response.failed('Missing arguments');
var a=request.arguments.frame;
if(this.exec_state_.frameCount()==0){
return response.failed('No frames');
var b;
if(!(a===(void 0))){
var c=builtins.$toNumber(a);
if(c<0||c>=this.exec_state_.frameCount()){
return response.failed('Invalid frame "'+a+'"');
b=this.exec_state_.frame(c);
}else{
b=this.exec_state_.frame();
var d=b.restart();
response.body={result:d};
DebugCommandProcessor.prototype.debuggerFlagsRequest_=function(request,
response){
if(!request.arguments){
response.failed('Missing arguments');
return;
var a=request.arguments.flags;
response.body={flags:[]};
if(!(a===(void 0))){
for(var b=0;b<a.length;b++){
var c=a[b].name;
var d=debugger_flags[c];
if(!d){
continue;
if('value'in a[b]){
d.setValue(a[b].value);
response.body.flags.push({name:c,value:d.getValue()});
}else{
for(var c in debugger_flags){
var e=debugger_flags[c].getValue();
response.body.flags.push({name:c,value:e});
DebugCommandProcessor.prototype.v8FlagsRequest_=function(a,b){
var c=a.arguments.flags;
if(!c)c='';
%SetFlags(c);
DebugCommandProcessor.prototype.gcRequest_=function(a,b){
var c=a.arguments.type;
if(!c)c='all';
var d=%GetHeapUsage();
%CollectGarbage(c);
var e=%GetHeapUsage();
b.body={"before":d,"after":e};
DebugCommandProcessor.prototype.dispatch_=(function(){
var a=DebugCommandProcessor.prototype;
return{
"continue":a.continueRequest_,
"break":a.breakRequest_,
"setbreakpoint":a.setBreakPointRequest_,
"changebreakpoint":a.changeBreakPointRequest_,
"clearbreakpoint":a.clearBreakPointRequest_,
"clearbreakpointgroup":a.clearBreakPointGroupRequest_,
"disconnect":a.disconnectRequest_,
"setexceptionbreak":a.setExceptionBreakRequest_,
"listbreakpoints":a.listBreakpointsRequest_,
"backtrace":a.backtraceRequest_,
"frame":a.frameRequest_,
"scopes":a.scopesRequest_,
"scope":a.scopeRequest_,
"setvariablevalue":a.setVariableValueRequest_,
"evaluate":a.evaluateRequest_,
"lookup":a.lookupRequest_,
"references":a.referencesRequest_,
"source":a.sourceRequest_,
"scripts":a.scriptsRequest_,
"threads":a.threadsRequest_,
"suspend":a.suspendRequest_,
"version":a.versionRequest_,
"changelive":a.changeLiveRequest_,
"restartframe":a.restartFrameRequest_,
"flags":a.debuggerFlagsRequest_,
"v8flag":a.v8FlagsRequest_,
"gc":a.gcRequest_,
})();
DebugCommandProcessor.prototype.isRunning=function(){
return this.running_;
DebugCommandProcessor.prototype.systemBreak=function(a,b){
return %SystemBreak();
function ObjectToProtocolObject_(a,b){
var c={};
for(var d in a){
if(typeof d=='string'){
var e=ValueToProtocolValue_(a[d],
if(!(e===(void 0))){
c[d]=e;
return c;
function ArrayToProtocolArray_(a,b){
var c=[];
for(var d=0;d<a.length;d++){
c.push(ValueToProtocolValue_(a[d],b));
return c;
function ValueToProtocolValue_(a,b){
var c;
switch(typeof a){
case'object':
if(a instanceof Mirror){
c=b.serializeValue(a);
}else if((%_IsArray(a))){
c=ArrayToProtocolArray_(a,b);
}else{
c=ObjectToProtocolObject_(a,b);
break;
case'boolean':
case'string':
case'number':
c=a;
break;
default:
c=null;
return c;
"use strict";
var next_handle_=0;
var next_transient_handle_=-1;
var mirror_cache_=[];
var mirror_cache_enabled_=true;
function ToggleMirrorCache(a){
mirror_cache_enabled_=a;
next_handle_=0;
mirror_cache_=[];
function ObjectIsPromise(a){
return(%_IsSpecObject(a))&&
!(%DebugGetProperty(a,builtins.$promiseStatus)===(void 0));
function MakeMirror(a,b){
var c;
if(!b&&mirror_cache_enabled_){
for(var d in mirror_cache_){
c=mirror_cache_[d];
if(c.value()===a){
return c;
if(c.isNumber()&&isNaN(c.value())&&
typeof a=='number'&&isNaN(a)){
return c;
if((a===(void 0))){
c=new UndefinedMirror();
}else if((a===null)){
c=new NullMirror();
}else if((typeof(a)==='boolean')){
c=new BooleanMirror(a);
}else if((typeof(a)==='number')){
c=new NumberMirror(a);
}else if((typeof(a)==='string')){
c=new StringMirror(a);
}else if((typeof(a)==='symbol')){
c=new SymbolMirror(a);
}else if((%_IsArray(a))){
c=new ArrayMirror(a);
}else if((%_IsDate(a))){
c=new DateMirror(a);
}else if((%_IsFunction(a))){
c=new FunctionMirror(a);
}else if((%_IsRegExp(a))){
c=new RegExpMirror(a);
}else if((%_ClassOf(a)==='Error')){
c=new ErrorMirror(a);
}else if((%_ClassOf(a)==='Script')){
c=new ScriptMirror(a);
}else if((%_ClassOf(a)==='Map')||(%_ClassOf(a)==='WeakMap')){
c=new MapMirror(a);
}else if((%_ClassOf(a)==='Set')||(%_ClassOf(a)==='WeakSet')){
c=new SetMirror(a);
}else if((%_ClassOf(a)==='Map Iterator')||(%_ClassOf(a)==='Set Iterator')){
c=new IteratorMirror(a);
}else if(ObjectIsPromise(a)){
c=new PromiseMirror(a);
}else if((%_ClassOf(a)==='Generator')){
c=new GeneratorMirror(a);
}else{
c=new ObjectMirror(a,OBJECT_TYPE,b);
if(mirror_cache_enabled_)mirror_cache_[c.handle()]=c;
return c;
function LookupMirror(a){
if(!mirror_cache_enabled_)throw new Error("Mirror cache is disabled");
return mirror_cache_[a];
function GetUndefinedMirror(){
return MakeMirror((void 0));
function inherits(a,b){
var c=function(){};
c.prototype=b.prototype;
a.super_=b.prototype;
a.prototype=new c();
a.prototype.constructor=a;
var UNDEFINED_TYPE='undefined';
var NULL_TYPE='null';
var BOOLEAN_TYPE='boolean';
var NUMBER_TYPE='number';
var STRING_TYPE='string';
var SYMBOL_TYPE='symbol';
var OBJECT_TYPE='object';
var FUNCTION_TYPE='function';
var REGEXP_TYPE='regexp';
var ERROR_TYPE='error';
var PROPERTY_TYPE='property';
var INTERNAL_PROPERTY_TYPE='internalProperty';
var FRAME_TYPE='frame';
var SCRIPT_TYPE='script';
var CONTEXT_TYPE='context';
var SCOPE_TYPE='scope';
var PROMISE_TYPE='promise';
var MAP_TYPE='map';
var SET_TYPE='set';
var ITERATOR_TYPE='iterator';
var GENERATOR_TYPE='generator';
var kMaxProtocolStringLength=80;
var PropertyKind={};
PropertyKind.Named=1;
PropertyKind.Indexed=2;
var PropertyType={};
PropertyType.Data=0;
PropertyType.DataConstant=2;
PropertyType.AccessorConstant=3;
var PropertyAttribute={};
PropertyAttribute.None=0;
PropertyAttribute.ReadOnly=1;
PropertyAttribute.DontEnum=2;
PropertyAttribute.DontDelete=4;
var ScopeType={Global:0,
Local:1,
With:2,
Closure:3,
Catch:4,
Block:5,
Script:6};
function Mirror(a){
this.type_=a;
Mirror.prototype.type=function(){
return this.type_;
Mirror.prototype.isValue=function(){
return this instanceof ValueMirror;
Mirror.prototype.isUndefined=function(){
return this instanceof UndefinedMirror;
Mirror.prototype.isNull=function(){
return this instanceof NullMirror;
Mirror.prototype.isBoolean=function(){
return this instanceof BooleanMirror;
Mirror.prototype.isNumber=function(){
return this instanceof NumberMirror;
Mirror.prototype.isString=function(){
return this instanceof StringMirror;
Mirror.prototype.isSymbol=function(){
return this instanceof SymbolMirror;
Mirror.prototype.isObject=function(){
return this instanceof ObjectMirror;
Mirror.prototype.isFunction=function(){
return this instanceof FunctionMirror;
Mirror.prototype.isUnresolvedFunction=function(){
return this instanceof UnresolvedFunctionMirror;
Mirror.prototype.isArray=function(){
return this instanceof ArrayMirror;
Mirror.prototype.isDate=function(){
return this instanceof DateMirror;
Mirror.prototype.isRegExp=function(){
return this instanceof RegExpMirror;
Mirror.prototype.isError=function(){
return this instanceof ErrorMirror;
Mirror.prototype.isPromise=function(){
return this instanceof PromiseMirror;
Mirror.prototype.isGenerator=function(){
return this instanceof GeneratorMirror;
Mirror.prototype.isProperty=function(){
return this instanceof PropertyMirror;
Mirror.prototype.isInternalProperty=function(){
return this instanceof InternalPropertyMirror;
Mirror.prototype.isFrame=function(){
return this instanceof FrameMirror;
Mirror.prototype.isScript=function(){
return this instanceof ScriptMirror;
Mirror.prototype.isContext=function(){
return this instanceof ContextMirror;
Mirror.prototype.isScope=function(){
return this instanceof ScopeMirror;
Mirror.prototype.isMap=function(){
return this instanceof MapMirror;
Mirror.prototype.isSet=function(){
return this instanceof SetMirror;
Mirror.prototype.isIterator=function(){
return this instanceof IteratorMirror;
Mirror.prototype.allocateHandle_=function(){
if(mirror_cache_enabled_)this.handle_=next_handle_++;
Mirror.prototype.allocateTransientHandle_=function(){
this.handle_=next_transient_handle_--;
Mirror.prototype.toText=function(){
return"#<"+this.constructor.name+">";
function ValueMirror(a,b,c){
%_CallFunction(this,a,Mirror);
this.value_=b;
if(!c){
this.allocateHandle_();
}else{
this.allocateTransientHandle_();
inherits(ValueMirror,Mirror);
Mirror.prototype.handle=function(){
return this.handle_;
ValueMirror.prototype.isPrimitive=function(){
var a=this.type();
return a==='undefined'||
a==='null'||
a==='boolean'||
a==='number'||
a==='string'||
a==='symbol';
ValueMirror.prototype.value=function(){
return this.value_;
function UndefinedMirror(){
%_CallFunction(this,UNDEFINED_TYPE,(void 0),ValueMirror);
inherits(UndefinedMirror,ValueMirror);
UndefinedMirror.prototype.toText=function(){
return'undefined';
function NullMirror(){
%_CallFunction(this,NULL_TYPE,null,ValueMirror);
inherits(NullMirror,ValueMirror);
NullMirror.prototype.toText=function(){
return'null';
function BooleanMirror(a){
%_CallFunction(this,BOOLEAN_TYPE,a,ValueMirror);
inherits(BooleanMirror,ValueMirror);
BooleanMirror.prototype.toText=function(){
return this.value_?'true':'false';
function NumberMirror(a){
%_CallFunction(this,NUMBER_TYPE,a,ValueMirror);
inherits(NumberMirror,ValueMirror);
NumberMirror.prototype.toText=function(){
return %_NumberToString(this.value_);
function StringMirror(a){
%_CallFunction(this,STRING_TYPE,a,ValueMirror);
inherits(StringMirror,ValueMirror);
StringMirror.prototype.length=function(){
return this.value_.length;
StringMirror.prototype.getTruncatedValue=function(a){
if(a!=-1&&this.length()>a){
return this.value_.substring(0,a)+
'... (length: '+this.length()+')';
return this.value_;
StringMirror.prototype.toText=function(){
return this.getTruncatedValue(kMaxProtocolStringLength);
function SymbolMirror(a){
%_CallFunction(this,SYMBOL_TYPE,a,ValueMirror);
inherits(SymbolMirror,ValueMirror);
SymbolMirror.prototype.description=function(){
return %SymbolDescription(%_ValueOf(this.value_));
SymbolMirror.prototype.toText=function(){
return %_CallFunction(this.value_,builtins.$symbolToString);
function ObjectMirror(a,b,c){
%_CallFunction(this,b||OBJECT_TYPE,a,c,ValueMirror);
inherits(ObjectMirror,ValueMirror);
ObjectMirror.prototype.className=function(){
return %_ClassOf(this.value_);
ObjectMirror.prototype.constructorFunction=function(){
return MakeMirror(%DebugGetProperty(this.value_,'constructor'));
ObjectMirror.prototype.prototypeObject=function(){
return MakeMirror(%DebugGetProperty(this.value_,'prototype'));
ObjectMirror.prototype.protoObject=function(){
return MakeMirror(%DebugGetPrototype(this.value_));
ObjectMirror.prototype.hasNamedInterceptor=function(){
var a=%GetInterceptorInfo(this.value_);
return(a&2)!=0;
ObjectMirror.prototype.hasIndexedInterceptor=function(){
var a=%GetInterceptorInfo(this.value_);
return(a&1)!=0;
function TryGetPropertyNames(a){
try{
return %GetOwnPropertyNames(a,32);
}catch(e){
return[];
ObjectMirror.prototype.propertyNames=function(a,b){
a=a||PropertyKind.Named|PropertyKind.Indexed;
var c;
var d;
var e=0;
if(a&PropertyKind.Named){
c=TryGetPropertyNames(this.value_);
e+=c.length;
if(this.hasNamedInterceptor()&&(a&PropertyKind.Named)){
var g=
%GetNamedInterceptorPropertyNames(this.value_);
if(g){
c=c.concat(g);
e+=g.length;
if(a&PropertyKind.Indexed){
d=%GetOwnElementNames(this.value_);
e+=d.length;
if(this.hasIndexedInterceptor()&&(a&PropertyKind.Indexed)){
var h=
%GetIndexedInterceptorElementNames(this.value_);
if(h){
d=d.concat(h);
e+=h.length;
b=Math.min(b||e,e);
var i=new Array(b);
var j=0;
if(a&PropertyKind.Named){
for(var k=0;j<b&&k<c.length;k++){
i[j++]=c[k];
if(a&PropertyKind.Indexed){
for(var k=0;j<b&&k<d.length;k++){
i[j++]=d[k];
return i;
ObjectMirror.prototype.properties=function(a,b){
var c=this.propertyNames(a,b);
var d=new Array(c.length);
for(var e=0;e<c.length;e++){
d[e]=this.property(c[e]);
return d;
ObjectMirror.prototype.internalProperties=function(){
return ObjectMirror.GetInternalProperties(this.value_);
ObjectMirror.prototype.property=function(a){
var b=%DebugGetPropertyDetails(this.value_,builtins.$toName(a));
if(b){
return new PropertyMirror(this,a,b);
return GetUndefinedMirror();
ObjectMirror.prototype.lookupProperty=function(a){
var b=this.properties();
for(var c=0;c<b.length;c++){
var d=b[c];
if(d.propertyType()!=PropertyType.AccessorConstant){
if(%_ObjectEquals(d.value_,a.value_)){
return d;
return GetUndefinedMirror();
ObjectMirror.prototype.referencedBy=function(a){
var b=%DebugReferencedBy(this.value_,
Mirror.prototype,a||0);
for(var c=0;c<b.length;c++){
b[c]=MakeMirror(b[c]);
return b;
ObjectMirror.prototype.toText=function(){
var a;
var b=this.constructorFunction();
if(!b.isFunction()){
a=this.className();
}else{
a=b.name();
if(!a){
a=this.className();
return'#<'+a+'>';
ObjectMirror.GetInternalProperties=function(a){
var b=%DebugGetInternalProperties(a);
var c=[];
for(var d=0;d<b.length;d+=2){
c.push(new InternalPropertyMirror(b[d],b[d+1]));
return c;
function FunctionMirror(a){
%_CallFunction(this,a,FUNCTION_TYPE,ObjectMirror);
this.resolved_=true;
inherits(FunctionMirror,ObjectMirror);
FunctionMirror.prototype.resolved=function(){
return this.resolved_;
FunctionMirror.prototype.name=function(){
return %FunctionGetName(this.value_);
FunctionMirror.prototype.inferredName=function(){
return %FunctionGetInferredName(this.value_);
FunctionMirror.prototype.source=function(){
if(this.resolved()){
return builtins.$functionSourceString(this.value_);
FunctionMirror.prototype.script=function(){
if(this.resolved()){
if(this.script_){
return this.script_;
var a=%FunctionGetScript(this.value_);
if(a){
return this.script_=MakeMirror(a);
FunctionMirror.prototype.sourcePosition_=function(){
if(this.resolved()){
return %FunctionGetScriptSourcePosition(this.value_);
FunctionMirror.prototype.sourceLocation=function(){
if(this.resolved()){
var a=this.script();
if(a){
return a.locationFromPosition(this.sourcePosition_(),true);
FunctionMirror.prototype.constructedBy=function(a){
if(this.resolved()){
var b=%DebugConstructedBy(this.value_,a||0);
for(var c=0;c<b.length;c++){
b[c]=MakeMirror(b[c]);
return b;
}else{
return[];
FunctionMirror.prototype.scopeCount=function(){
if(this.resolved()){
if((this.scopeCount_===(void 0))){
this.scopeCount_=%GetFunctionScopeCount(this.value());
return this.scopeCount_;
}else{
return 0;
FunctionMirror.prototype.scope=function(a){
if(this.resolved()){
return new ScopeMirror((void 0),this,a);
FunctionMirror.prototype.toText=function(){
return this.source();
function UnresolvedFunctionMirror(a){
%_CallFunction(this,FUNCTION_TYPE,a,ValueMirror);
this.propertyCount_=0;
this.elementCount_=0;
this.resolved_=false;
inherits(UnresolvedFunctionMirror,FunctionMirror);
UnresolvedFunctionMirror.prototype.className=function(){
return'Function';
UnresolvedFunctionMirror.prototype.constructorFunction=function(){
return GetUndefinedMirror();
UnresolvedFunctionMirror.prototype.prototypeObject=function(){
return GetUndefinedMirror();
UnresolvedFunctionMirror.prototype.protoObject=function(){
return GetUndefinedMirror();
UnresolvedFunctionMirror.prototype.name=function(){
return this.value_;
UnresolvedFunctionMirror.prototype.inferredName=function(){
return undefined;
UnresolvedFunctionMirror.prototype.propertyNames=function(a,b){
return[];
function ArrayMirror(a){
%_CallFunction(this,a,ObjectMirror);
inherits(ArrayMirror,ObjectMirror);
ArrayMirror.prototype.length=function(){
return this.value_.length;
ArrayMirror.prototype.indexedPropertiesFromRange=function(opt_from_index,
opt_to_index){
var a=opt_from_index||0;
var b=opt_to_index||this.length()-1;
if(a>b)return new Array();
var c=new Array(b-a+1);
for(var d=a;d<=b;d++){
var e=%DebugGetPropertyDetails(this.value_,builtins.$toString(d));
var g;
if(e){
g=new PropertyMirror(this,d,e);
}else{
g=GetUndefinedMirror();
c[d-a]=g;
return c;
function DateMirror(a){
%_CallFunction(this,a,ObjectMirror);
inherits(DateMirror,ObjectMirror);
DateMirror.prototype.toText=function(){
var a=JSON.stringify(this.value_);
return a.substring(1,a.length-1);
function RegExpMirror(a){
%_CallFunction(this,a,REGEXP_TYPE,ObjectMirror);
inherits(RegExpMirror,ObjectMirror);
RegExpMirror.prototype.source=function(){
return this.value_.source;
RegExpMirror.prototype.global=function(){
return this.value_.global;
RegExpMirror.prototype.ignoreCase=function(){
return this.value_.ignoreCase;
RegExpMirror.prototype.multiline=function(){
return this.value_.multiline;
RegExpMirror.prototype.sticky=function(){
return this.value_.sticky;
RegExpMirror.prototype.unicode=function(){
return this.value_.unicode;
RegExpMirror.prototype.toText=function(){
return"/"+this.source()+"/";
function ErrorMirror(a){
%_CallFunction(this,a,ERROR_TYPE,ObjectMirror);
inherits(ErrorMirror,ObjectMirror);
ErrorMirror.prototype.message=function(){
return this.value_.message;
ErrorMirror.prototype.toText=function(){
var a;
try{
a=%_CallFunction(this.value_,builtins.$errorToString);
}catch(e){
a='#<Error>';
return a;
function PromiseMirror(a){
%_CallFunction(this,a,PROMISE_TYPE,ObjectMirror);
inherits(PromiseMirror,ObjectMirror);
function PromiseGetStatus_(a){
var b=%DebugGetProperty(a,builtins.$promiseStatus);
if(b==0)return"pending";
if(b==1)return"resolved";
return"rejected";
function PromiseGetValue_(a){
return %DebugGetProperty(a,builtins.$promiseValue);
PromiseMirror.prototype.status=function(){
return PromiseGetStatus_(this.value_);
PromiseMirror.prototype.promiseValue=function(){
return MakeMirror(PromiseGetValue_(this.value_));
function MapMirror(a){
%_CallFunction(this,a,MAP_TYPE,ObjectMirror);
inherits(MapMirror,ObjectMirror);
MapMirror.prototype.entries=function(a){
var b=[];
if((%_ClassOf(this.value_)==='WeakMap')){
var c=%GetWeakMapEntries(this.value_,a||0);
for(var d=0;d<c.length;d+=2){
b.push({
key:c[d],
value:c[d+1]
return b;
var e=%_CallFunction(this.value_,builtins.$mapEntries);
var g;
while((!a||b.length<a)&&
!(g=e.next()).done){
b.push({
key:g.value[0],
value:g.value[1]
return b;
function SetMirror(a){
%_CallFunction(this,a,SET_TYPE,ObjectMirror);
inherits(SetMirror,ObjectMirror);
function IteratorGetValues_(a,b,c){
var d=[];
var e;
while((!c||d.length<c)&&
!(e=%_CallFunction(a,b)).done){
d.push(e.value);
return d;
SetMirror.prototype.values=function(a){
if((%_ClassOf(this.value_)==='WeakSet')){
return %GetWeakSetValues(this.value_,a||0);
var b=%_CallFunction(this.value_,builtins.$setValues);
return IteratorGetValues_(b,builtins.$setIteratorNext,a);
function IteratorMirror(a){
%_CallFunction(this,a,ITERATOR_TYPE,ObjectMirror);
inherits(IteratorMirror,ObjectMirror);
IteratorMirror.prototype.preview=function(a){
if((%_ClassOf(this.value_)==='Map Iterator')){
return IteratorGetValues_(%MapIteratorClone(this.value_),
builtins.$mapIteratorNext,
}else if((%_ClassOf(this.value_)==='Set Iterator')){
return IteratorGetValues_(%SetIteratorClone(this.value_),
builtins.$setIteratorNext,
function GeneratorMirror(a){
%_CallFunction(this,a,GENERATOR_TYPE,ObjectMirror);
inherits(GeneratorMirror,ObjectMirror);
function GeneratorGetStatus_(a){
var b=%GeneratorGetContinuation(a);
if(b<0)return"running";
if(b==0)return"closed";
return"suspended";
GeneratorMirror.prototype.status=function(){
return GeneratorGetStatus_(this.value_);
GeneratorMirror.prototype.sourcePosition_=function(){
return %GeneratorGetSourcePosition(this.value_);
GeneratorMirror.prototype.sourceLocation=function(){
var a=this.sourcePosition_();
if(!(a===(void 0))){
var b=this.func().script();
if(b){
return b.locationFromPosition(a,true);
GeneratorMirror.prototype.func=function(){
if(!this.func_){
this.func_=MakeMirror(%GeneratorGetFunction(this.value_));
return this.func_;
GeneratorMirror.prototype.context=function(){
if(!this.context_){
this.context_=new ContextMirror(%GeneratorGetContext(this.value_));
return this.context_;
GeneratorMirror.prototype.receiver=function(){
if(!this.receiver_){
this.receiver_=MakeMirror(%GeneratorGetReceiver(this.value_));
return this.receiver_;
function PropertyMirror(a,b,c){
%_CallFunction(this,PROPERTY_TYPE,Mirror);
this.mirror_=a;
this.name_=b;
this.value_=c[0];
this.details_=c[1];
this.is_interceptor_=c[2];
if(c.length>3){
this.exception_=c[3];
this.getter_=c[4];
this.setter_=c[5];
inherits(PropertyMirror,Mirror);
PropertyMirror.prototype.isReadOnly=function(){
return(this.attributes()&PropertyAttribute.ReadOnly)!=0;
PropertyMirror.prototype.isEnum=function(){
return(this.attributes()&PropertyAttribute.DontEnum)==0;
PropertyMirror.prototype.canDelete=function(){
return(this.attributes()&PropertyAttribute.DontDelete)==0;
PropertyMirror.prototype.name=function(){
return this.name_;
PropertyMirror.prototype.isIndexed=function(){
for(var a=0;a<this.name_.length;a++){
if(this.name_[a]<'0'||'9'<this.name_[a]){
return false;
return true;
PropertyMirror.prototype.value=function(){
return MakeMirror(this.value_,false);
PropertyMirror.prototype.isException=function(){
return this.exception_?true:false;
PropertyMirror.prototype.attributes=function(){
return %DebugPropertyAttributesFromDetails(this.details_);
PropertyMirror.prototype.propertyType=function(){
return %DebugPropertyTypeFromDetails(this.details_);
PropertyMirror.prototype.insertionIndex=function(){
return %DebugPropertyIndexFromDetails(this.details_);
PropertyMirror.prototype.hasGetter=function(){
return this.getter_?true:false;
PropertyMirror.prototype.hasSetter=function(){
return this.setter_?true:false;
PropertyMirror.prototype.getter=function(){
if(this.hasGetter()){
return MakeMirror(this.getter_);
}else{
return GetUndefinedMirror();
PropertyMirror.prototype.setter=function(){
if(this.hasSetter()){
return MakeMirror(this.setter_);
}else{
return GetUndefinedMirror();
PropertyMirror.prototype.isNative=function(){
return this.is_interceptor_||
((this.propertyType()==PropertyType.AccessorConstant)&&
!this.hasGetter()&&!this.hasSetter());
function InternalPropertyMirror(a,b){
%_CallFunction(this,INTERNAL_PROPERTY_TYPE,Mirror);
this.name_=a;
this.value_=b;
inherits(InternalPropertyMirror,Mirror);
InternalPropertyMirror.prototype.name=function(){
return this.name_;
InternalPropertyMirror.prototype.value=function(){
return MakeMirror(this.value_,false);
var kFrameDetailsFrameIdIndex=0;
var kFrameDetailsReceiverIndex=1;
var kFrameDetailsFunctionIndex=2;
var kFrameDetailsArgumentCountIndex=3;
var kFrameDetailsLocalCountIndex=4;
var kFrameDetailsSourcePositionIndex=5;
var kFrameDetailsConstructCallIndex=6;
var kFrameDetailsAtReturnIndex=7;
var kFrameDetailsFlagsIndex=8;
var kFrameDetailsFirstDynamicIndex=9;
var kFrameDetailsNameIndex=0;
var kFrameDetailsValueIndex=1;
var kFrameDetailsNameValueSize=2;
var kFrameDetailsFlagDebuggerFrameMask=1<<0;
var kFrameDetailsFlagOptimizedFrameMask=1<<1;
var kFrameDetailsFlagInlinedFrameIndexMask=7<<2;
function FrameDetails(a,b){
this.break_id_=a;
this.details_=%GetFrameDetails(a,b);
FrameDetails.prototype.frameId=function(){
%CheckExecutionState(this.break_id_);
return this.details_[kFrameDetailsFrameIdIndex];
FrameDetails.prototype.receiver=function(){
%CheckExecutionState(this.break_id_);
return this.details_[kFrameDetailsReceiverIndex];
FrameDetails.prototype.func=function(){
%CheckExecutionState(this.break_id_);
return this.details_[kFrameDetailsFunctionIndex];
FrameDetails.prototype.isConstructCall=function(){
%CheckExecutionState(this.break_id_);
return this.details_[kFrameDetailsConstructCallIndex];
FrameDetails.prototype.isAtReturn=function(){
%CheckExecutionState(this.break_id_);
return this.details_[kFrameDetailsAtReturnIndex];
FrameDetails.prototype.isDebuggerFrame=function(){
%CheckExecutionState(this.break_id_);
var a=kFrameDetailsFlagDebuggerFrameMask;
return(this.details_[kFrameDetailsFlagsIndex]&a)==a;
FrameDetails.prototype.isOptimizedFrame=function(){
%CheckExecutionState(this.break_id_);
var a=kFrameDetailsFlagOptimizedFrameMask;
return(this.details_[kFrameDetailsFlagsIndex]&a)==a;
FrameDetails.prototype.isInlinedFrame=function(){
return this.inlinedFrameIndex()>0;
FrameDetails.prototype.inlinedFrameIndex=function(){
%CheckExecutionState(this.break_id_);
var a=kFrameDetailsFlagInlinedFrameIndexMask;
return(this.details_[kFrameDetailsFlagsIndex]&a)>>2;
FrameDetails.prototype.argumentCount=function(){
%CheckExecutionState(this.break_id_);
return this.details_[kFrameDetailsArgumentCountIndex];
FrameDetails.prototype.argumentName=function(a){
%CheckExecutionState(this.break_id_);
if(a>=0&&a<this.argumentCount()){
return this.details_[kFrameDetailsFirstDynamicIndex+
a*kFrameDetailsNameValueSize+
kFrameDetailsNameIndex];
FrameDetails.prototype.argumentValue=function(a){
%CheckExecutionState(this.break_id_);
if(a>=0&&a<this.argumentCount()){
return this.details_[kFrameDetailsFirstDynamicIndex+
a*kFrameDetailsNameValueSize+
kFrameDetailsValueIndex];
FrameDetails.prototype.localCount=function(){
%CheckExecutionState(this.break_id_);
return this.details_[kFrameDetailsLocalCountIndex];
FrameDetails.prototype.sourcePosition=function(){
%CheckExecutionState(this.break_id_);
return this.details_[kFrameDetailsSourcePositionIndex];
FrameDetails.prototype.localName=function(a){
%CheckExecutionState(this.break_id_);
if(a>=0&&a<this.localCount()){
var b=kFrameDetailsFirstDynamicIndex+
this.argumentCount()*kFrameDetailsNameValueSize;
return this.details_[b+
a*kFrameDetailsNameValueSize+
kFrameDetailsNameIndex];
FrameDetails.prototype.localValue=function(a){
%CheckExecutionState(this.break_id_);
if(a>=0&&a<this.localCount()){
var b=kFrameDetailsFirstDynamicIndex+
this.argumentCount()*kFrameDetailsNameValueSize;
return this.details_[b+
a*kFrameDetailsNameValueSize+
kFrameDetailsValueIndex];
FrameDetails.prototype.returnValue=function(){
%CheckExecutionState(this.break_id_);
var a=
kFrameDetailsFirstDynamicIndex+
(this.argumentCount()+this.localCount())*kFrameDetailsNameValueSize;
if(this.details_[kFrameDetailsAtReturnIndex]){
return this.details_[a];
FrameDetails.prototype.scopeCount=function(){
if((this.scopeCount_===(void 0))){
this.scopeCount_=%GetScopeCount(this.break_id_,this.frameId());
return this.scopeCount_;
FrameDetails.prototype.stepInPositionsImpl=function(){
return %GetStepInPositions(this.break_id_,this.frameId());
function FrameMirror(a,b){
%_CallFunction(this,FRAME_TYPE,Mirror);
this.break_id_=a;
this.index_=b;
this.details_=new FrameDetails(a,b);
inherits(FrameMirror,Mirror);
FrameMirror.prototype.details=function(){
return this.details_;
FrameMirror.prototype.index=function(){
return this.index_;
FrameMirror.prototype.func=function(){
if(this.func_){
return this.func_;
var a=this.details_.func();
if((%_IsFunction(a))){
return this.func_=MakeMirror(a);
}else{
return new UnresolvedFunctionMirror(a);
FrameMirror.prototype.receiver=function(){
return MakeMirror(this.details_.receiver());
FrameMirror.prototype.isConstructCall=function(){
return this.details_.isConstructCall();
FrameMirror.prototype.isAtReturn=function(){
return this.details_.isAtReturn();
FrameMirror.prototype.isDebuggerFrame=function(){
return this.details_.isDebuggerFrame();
FrameMirror.prototype.isOptimizedFrame=function(){
return this.details_.isOptimizedFrame();
FrameMirror.prototype.isInlinedFrame=function(){
return this.details_.isInlinedFrame();
FrameMirror.prototype.inlinedFrameIndex=function(){
return this.details_.inlinedFrameIndex();
FrameMirror.prototype.argumentCount=function(){
return this.details_.argumentCount();
FrameMirror.prototype.argumentName=function(a){
return this.details_.argumentName(a);
FrameMirror.prototype.argumentValue=function(a){
return MakeMirror(this.details_.argumentValue(a));
FrameMirror.prototype.localCount=function(){
return this.details_.localCount();
FrameMirror.prototype.localName=function(a){
return this.details_.localName(a);
FrameMirror.prototype.localValue=function(a){
return MakeMirror(this.details_.localValue(a));
FrameMirror.prototype.returnValue=function(){
return MakeMirror(this.details_.returnValue());
FrameMirror.prototype.sourcePosition=function(){
return this.details_.sourcePosition();
FrameMirror.prototype.sourceLocation=function(){
var a=this.func();
if(a.resolved()){
var b=a.script();
if(b){
return b.locationFromPosition(this.sourcePosition(),true);
FrameMirror.prototype.sourceLine=function(){
var a=this.sourceLocation();
if(a){
return a.line;
FrameMirror.prototype.sourceColumn=function(){
var a=this.sourceLocation();
if(a){
return a.column;
FrameMirror.prototype.sourceLineText=function(){
var a=this.sourceLocation();
if(a){
return a.sourceText();
FrameMirror.prototype.scopeCount=function(){
return this.details_.scopeCount();
FrameMirror.prototype.scope=function(a){
return new ScopeMirror(this,(void 0),a);
FrameMirror.prototype.allScopes=function(a){
var b=%GetAllScopesDetails(this.break_id_,
this.details_.frameId(),
this.details_.inlinedFrameIndex(),
!!a);
var c=[];
for(var d=0;d<b.length;++d){
c.push(new ScopeMirror(this,(void 0),d,b[d]));
return c;
FrameMirror.prototype.stepInPositions=function(){
var a=this.func().script();
var b=this.func().sourcePosition_();
var c=this.details_.stepInPositionsImpl();
var d=[];
if(c){
for(var e=0;e<c.length;e++){
var g={};
var h=a.locationFromPosition(b+c[e],
true);
serializeLocationFields(h,g);
var i={
position:g
d.push(i);
return d;
FrameMirror.prototype.evaluate=function(source,disable_break,
opt_context_object){
return MakeMirror(%DebugEvaluate(this.break_id_,
this.details_.frameId(),
this.details_.inlinedFrameIndex(),
source,
Boolean(disable_break),
opt_context_object));
FrameMirror.prototype.invocationText=function(){
var a='';
var b=this.func();
var c=this.receiver();
if(this.isConstructCall()){
a+='new ';
a+=b.name()?b.name():'[anonymous]';
}else if(this.isDebuggerFrame()){
a+='[debugger]';
}else{
var d=
!c.className||(c.className()!='global');
if(d){
a+=c.toText();
var e=GetUndefinedMirror();
if(c.isObject()){
for(var g=c;
!g.isNull()&&e.isUndefined();
g=g.protoObject()){
e=g.lookupProperty(b);
if(!e.isUndefined()){
if(!e.isIndexed()){
if(d){
a+='.';
a+=e.name();
}else{
a+='[';
a+=e.name();
a+=']';
if(b.name()&&b.name()!=e.name()){
a+='(aka '+b.name()+')';
}else{
if(d){
a+='.';
a+=b.name()?b.name():'[anonymous]';
if(!this.isDebuggerFrame()){
a+='(';
for(var h=0;h<this.argumentCount();h++){
if(h!=0)a+=', ';
if(this.argumentName(h)){
a+=this.argumentName(h);
a+='=';
a+=this.argumentValue(h).toText();
a+=')';
if(this.isAtReturn()){
a+=' returning ';
a+=this.returnValue().toText();
return a;
FrameMirror.prototype.sourceAndPositionText=function(){
var a='';
var b=this.func();
if(b.resolved()){
var c=b.script();
if(c){
if(c.name()){
a+=c.name();
}else{
a+='[unnamed]';
if(!this.isDebuggerFrame()){
var d=this.sourceLocation();
a+=' line ';
a+=!(d===(void 0))?(d.line+1):'?';
a+=' column ';
a+=!(d===(void 0))?(d.column+1):'?';
if(!(this.sourcePosition()===(void 0))){
a+=' (position '+(this.sourcePosition()+1)+')';
}else{
a+='[no source]';
}else{
a+='[unresolved]';
return a;
FrameMirror.prototype.localsText=function(){
var a='';
var b=this.localCount();
if(b>0){
for(var c=0;c<b;++c){
a+='      var ';
a+=this.localName(c);
a+=' = ';
a+=this.localValue(c).toText();
if(c<b-1)a+='\n';
return a;
FrameMirror.prototype.restart=function(){
var a=%LiveEditRestartFrame(this.break_id_,this.index_);
if((a===(void 0))){
a="Failed to find requested frame";
return a;
FrameMirror.prototype.toText=function(a){
var b='';
b+='#'+(this.index()<=9?'0':'')+this.index();
b+=' ';
b+=this.invocationText();
b+=' ';
b+=this.sourceAndPositionText();
if(a){
b+='\n';
b+=this.localsText();
return b;
var kScopeDetailsTypeIndex=0;
var kScopeDetailsObjectIndex=1;
function ScopeDetails(a,b,c,d){
if(a){
this.break_id_=a.break_id_;
this.details_=d||
%GetScopeDetails(a.break_id_,
a.details_.frameId(),
a.details_.inlinedFrameIndex(),
this.frame_id_=a.details_.frameId();
this.inlined_frame_id_=a.details_.inlinedFrameIndex();
}else{
this.details_=d||%GetFunctionScopeDetails(b.value(),c);
this.fun_value_=b.value();
this.break_id_=undefined;
this.index_=c;
ScopeDetails.prototype.type=function(){
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
return this.details_[kScopeDetailsTypeIndex];
ScopeDetails.prototype.object=function(){
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
return this.details_[kScopeDetailsObjectIndex];
ScopeDetails.prototype.setVariableValueImpl=function(a,b){
var c;
if(!(this.break_id_===(void 0))){
%CheckExecutionState(this.break_id_);
c=%SetScopeVariableValue(this.break_id_,this.frame_id_,
this.inlined_frame_id_,this.index_,a,b);
}else{
c=%SetScopeVariableValue(this.fun_value_,null,null,this.index_,
a,b);
if(!c){
throw new Error("Failed to set variable value");
function ScopeMirror(a,b,c,d){
%_CallFunction(this,SCOPE_TYPE,Mirror);
if(a){
this.frame_index_=a.index_;
}else{
this.frame_index_=undefined;
this.scope_index_=c;
this.details_=new ScopeDetails(a,b,c,d);
inherits(ScopeMirror,Mirror);
ScopeMirror.prototype.details=function(){
return this.details_;
ScopeMirror.prototype.frameIndex=function(){
return this.frame_index_;
ScopeMirror.prototype.scopeIndex=function(){
return this.scope_index_;
ScopeMirror.prototype.scopeType=function(){
return this.details_.type();
ScopeMirror.prototype.scopeObject=function(){
var a=this.scopeType()==ScopeType.Local||
this.scopeType()==ScopeType.Closure||
this.scopeType()==ScopeType.Script;
return MakeMirror(this.details_.object(),a);
ScopeMirror.prototype.setVariableValue=function(a,b){
this.details_.setVariableValueImpl(a,b);
function ScriptMirror(a){
%_CallFunction(this,SCRIPT_TYPE,Mirror);
this.script_=a;
this.context_=new ContextMirror(a.context_data);
this.allocateHandle_();
inherits(ScriptMirror,Mirror);
ScriptMirror.prototype.value=function(){
return this.script_;
ScriptMirror.prototype.name=function(){
return this.script_.name||this.script_.nameOrSourceURL();
ScriptMirror.prototype.id=function(){
return this.script_.id;
ScriptMirror.prototype.source=function(){
return this.script_.source;
ScriptMirror.prototype.setSource=function(a){
%DebugSetScriptSource(this.script_,a);
ScriptMirror.prototype.lineOffset=function(){
return this.script_.line_offset;
ScriptMirror.prototype.columnOffset=function(){
return this.script_.column_offset;
ScriptMirror.prototype.data=function(){
return this.script_.data;
ScriptMirror.prototype.scriptType=function(){
return this.script_.type;
ScriptMirror.prototype.compilationType=function(){
return this.script_.compilation_type;
ScriptMirror.prototype.lineCount=function(){
return this.script_.lineCount();
ScriptMirror.prototype.locationFromPosition=function(
position,include_resource_offset){
return this.script_.locationFromPosition(position,include_resource_offset);
ScriptMirror.prototype.sourceSlice=function(a,b){
return this.script_.sourceSlice(a,b);
ScriptMirror.prototype.context=function(){
return this.context_;
ScriptMirror.prototype.evalFromScript=function(){
return MakeMirror(this.script_.eval_from_script);
ScriptMirror.prototype.evalFromFunctionName=function(){
return MakeMirror(this.script_.eval_from_function_name);
ScriptMirror.prototype.evalFromLocation=function(){
var a=this.evalFromScript();
if(!a.isUndefined()){
var b=this.script_.eval_from_script_position;
return a.locationFromPosition(b,true);
ScriptMirror.prototype.toText=function(){
var a='';
a+=this.name();
a+=' (lines: ';
if(this.lineOffset()>0){
a+=this.lineOffset();
a+='-';
a+=this.lineOffset()+this.lineCount()-1;
}else{
a+=this.lineCount();
a+=')';
return a;
function ContextMirror(a){
%_CallFunction(this,CONTEXT_TYPE,Mirror);
this.data_=a;
this.allocateHandle_();
inherits(ContextMirror,Mirror);
ContextMirror.prototype.data=function(){
return this.data_;
function MakeMirrorSerializer(a,b){
return new JSONProtocolSerializer(a,b);
function JSONProtocolSerializer(a,b){
this.details_=a;
this.options_=b;
this.mirrors_=[];
JSONProtocolSerializer.prototype.serializeReference=function(a){
return this.serialize_(a,true,true);
JSONProtocolSerializer.prototype.serializeValue=function(a){
var b=this.serialize_(a,false,true);
return b;
JSONProtocolSerializer.prototype.serializeReferencedObjects=function(){
var a=[];
var b=this.mirrors_.length;
for(var c=0;c<b;c++){
a.push(this.serialize_(this.mirrors_[c],false,false));
return a;
JSONProtocolSerializer.prototype.includeSource_=function(){
return this.options_&&this.options_.includeSource;
JSONProtocolSerializer.prototype.inlineRefs_=function(){
return this.options_&&this.options_.inlineRefs;
JSONProtocolSerializer.prototype.maxStringLength_=function(){
if((this.options_===(void 0))||
(this.options_.maxStringLength===(void 0))){
return kMaxProtocolStringLength;
return this.options_.maxStringLength;
JSONProtocolSerializer.prototype.add_=function(a){
for(var b=0;b<this.mirrors_.length;b++){
if(this.mirrors_[b]===a){
return;
this.mirrors_.push(a);
JSONProtocolSerializer.prototype.serializeReferenceWithDisplayData_=
function(a){
var b={};
b.ref=a.handle();
b.type=a.type();
switch(a.type()){
case UNDEFINED_TYPE:
case NULL_TYPE:
case BOOLEAN_TYPE:
case NUMBER_TYPE:
b.value=a.value();
break;
case STRING_TYPE:
b.value=a.getTruncatedValue(this.maxStringLength_());
break;
case SYMBOL_TYPE:
b.description=a.description();
break;
case FUNCTION_TYPE:
b.name=a.name();
b.inferredName=a.inferredName();
if(a.script()){
b.scriptId=a.script().id();
break;
case ERROR_TYPE:
case REGEXP_TYPE:
b.value=a.toText();
break;
case OBJECT_TYPE:
b.className=a.className();
break;
return b;
JSONProtocolSerializer.prototype.serialize_=function(mirror,reference,
details){
if(reference&&
(mirror.isValue()||mirror.isScript()||mirror.isContext())){
if(this.inlineRefs_()&&mirror.isValue()){
return this.serializeReferenceWithDisplayData_(mirror);
}else{
this.add_(mirror);
return{'ref':mirror.handle()};
var a={};
if(mirror.isValue()||mirror.isScript()||mirror.isContext()){
a.handle=mirror.handle();
a.type=mirror.type();
switch(mirror.type()){
case UNDEFINED_TYPE:
case NULL_TYPE:
break;
case BOOLEAN_TYPE:
a.value=mirror.value();
break;
case NUMBER_TYPE:
a.value=NumberToJSON_(mirror.value());
break;
case STRING_TYPE:
if(this.maxStringLength_()!=-1&&
mirror.length()>this.maxStringLength_()){
var b=mirror.getTruncatedValue(this.maxStringLength_());
a.value=b;
a.fromIndex=0;
a.toIndex=this.maxStringLength_();
}else{
a.value=mirror.value();
a.length=mirror.length();
break;
case SYMBOL_TYPE:
a.description=mirror.description();
break;
case OBJECT_TYPE:
case FUNCTION_TYPE:
case ERROR_TYPE:
case REGEXP_TYPE:
case PROMISE_TYPE:
case GENERATOR_TYPE:
this.serializeObject_(mirror,a,details);
break;
case PROPERTY_TYPE:
case INTERNAL_PROPERTY_TYPE:
throw new Error('PropertyMirror cannot be serialized independently');
break;
case FRAME_TYPE:
this.serializeFrame_(mirror,a);
break;
case SCOPE_TYPE:
this.serializeScope_(mirror,a);
break;
case SCRIPT_TYPE:
if(mirror.name()){
a.name=mirror.name();
a.id=mirror.id();
a.lineOffset=mirror.lineOffset();
a.columnOffset=mirror.columnOffset();
a.lineCount=mirror.lineCount();
if(mirror.data()){
a.data=mirror.data();
if(this.includeSource_()){
a.source=mirror.source();
}else{
var c=mirror.source().substring(0,80);
a.sourceStart=c;
a.sourceLength=mirror.source().length;
a.scriptType=mirror.scriptType();
a.compilationType=mirror.compilationType();
if(mirror.compilationType()==1&&
mirror.evalFromScript()){
a.evalFromScript=
this.serializeReference(mirror.evalFromScript());
var d=mirror.evalFromLocation();
if(d){
a.evalFromLocation={line:d.line,
column:d.column};
if(mirror.evalFromFunctionName()){
a.evalFromFunctionName=mirror.evalFromFunctionName();
if(mirror.context()){
a.context=this.serializeReference(mirror.context());
break;
case CONTEXT_TYPE:
a.data=mirror.data();
break;
a.text=mirror.toText();
return a;
JSONProtocolSerializer.prototype.serializeObject_=function(mirror,content,
details){
content.className=mirror.className();
content.constructorFunction=
this.serializeReference(mirror.constructorFunction());
content.protoObject=this.serializeReference(mirror.protoObject());
content.prototypeObject=this.serializeReference(mirror.prototypeObject());
if(mirror.hasNamedInterceptor()){
content.namedInterceptor=true;
if(mirror.hasIndexedInterceptor()){
content.indexedInterceptor=true;
if(mirror.isFunction()){
content.name=mirror.name();
if(!(mirror.inferredName()===(void 0))){
content.inferredName=mirror.inferredName();
content.resolved=mirror.resolved();
if(mirror.resolved()){
content.source=mirror.source();
if(mirror.script()){
content.script=this.serializeReference(mirror.script());
content.scriptId=mirror.script().id();
serializeLocationFields(mirror.sourceLocation(),content);
content.scopes=[];
for(var a=0;a<mirror.scopeCount();a++){
var b=mirror.scope(a);
content.scopes.push({
type:b.scopeType(),
index:a
if(mirror.isGenerator()){
content.status=mirror.status();
content.func=this.serializeReference(mirror.func())
content.receiver=this.serializeReference(mirror.receiver())
serializeLocationFields(mirror.sourceLocation(),content);
if(mirror.isDate()){
content.value=mirror.value();
if(mirror.isPromise()){
content.status=mirror.status();
content.promiseValue=this.serializeReference(mirror.promiseValue());
var c=mirror.propertyNames(PropertyKind.Named);
var d=mirror.propertyNames(PropertyKind.Indexed);
var e=new Array(c.length+d.length);
for(var a=0;a<c.length;a++){
var g=mirror.property(c[a]);
e[a]=this.serializeProperty_(g);
if(details){
this.add_(g.value());
for(var a=0;a<d.length;a++){
var g=mirror.property(d[a]);
e[c.length+a]=this.serializeProperty_(g);
if(details){
this.add_(g.value());
content.properties=e;
var h=mirror.internalProperties();
if(h.length>0){
var i=[];
for(var a=0;a<h.length;a++){
i.push(this.serializeInternalProperty_(h[a]));
content.internalProperties=i;
function serializeLocationFields(a,b){
if(!a){
return;
b.position=a.position;
var c=a.line;
if(!(c===(void 0))){
b.line=c;
var d=a.column;
if(!(d===(void 0))){
b.column=d;
JSONProtocolSerializer.prototype.serializeProperty_=function(a){
var b={};
b.name=a.name();
var c=a.value();
if(this.inlineRefs_()&&c.isValue()){
b.value=this.serializeReferenceWithDisplayData_(c);
}else{
if(a.attributes()!=PropertyAttribute.None){
b.attributes=a.attributes();
b.propertyType=a.propertyType();
b.ref=c.handle();
return b;
JSONProtocolSerializer.prototype.serializeInternalProperty_=
function(a){
var b={};
b.name=a.name();
var c=a.value();
if(this.inlineRefs_()&&c.isValue()){
b.value=this.serializeReferenceWithDisplayData_(c);
}else{
b.ref=c.handle();
return b;
JSONProtocolSerializer.prototype.serializeFrame_=function(a,b){
b.index=a.index();
b.receiver=this.serializeReference(a.receiver());
var c=a.func();
b.func=this.serializeReference(c);
var d=c.script();
if(d){
b.script=this.serializeReference(d);
b.constructCall=a.isConstructCall();
b.atReturn=a.isAtReturn();
if(a.isAtReturn()){
b.returnValue=this.serializeReference(a.returnValue());
b.debuggerFrame=a.isDebuggerFrame();
var e=new Array(a.argumentCount());
for(var g=0;g<a.argumentCount();g++){
var h={};
var i=a.argumentName(g);
if(i){
h.name=i;
h.value=this.serializeReference(a.argumentValue(g));
e[g]=h;
b.arguments=e;
var e=new Array(a.localCount());
for(var g=0;g<a.localCount();g++){
var j={};
j.name=a.localName(g);
j.value=this.serializeReference(a.localValue(g));
e[g]=j;
b.locals=e;
serializeLocationFields(a.sourceLocation(),b);
var k=a.sourceLineText();
if(!(k===(void 0))){
b.sourceLineText=k;
b.scopes=[];
for(var g=0;g<a.scopeCount();g++){
var l=a.scope(g);
b.scopes.push({
type:l.scopeType(),
index:g
JSONProtocolSerializer.prototype.serializeScope_=function(a,b){
b.index=a.scopeIndex();
b.frameIndex=a.frameIndex();
b.type=a.scopeType();
b.object=this.inlineRefs_()?
this.serializeValue(a.scopeObject()):
this.serializeReference(a.scopeObject());
function NumberToJSON_(a){
if(isNaN(a)){
return'NaN';
if(!(%_IsSmi(%IS_VAR(a))||((a==a)&&(a!=1/0)&&(a!=-1/0)))){
if(a>0){
return'Infinity';
}else{
return'-Infinity';
return a;
"use strict";
Debug.LiveEdit=new function(){
var a;
var b="stack_update_needs_step_in";
function ApplyPatchMultiChunk(script,diff_array,new_source,preview_only,
change_log){
var c=script.source;
var d=GatherCompileInfo(c,script);
var e=BuildCodeInfoTree(d);
var g=new PosTranslator(diff_array);
MarkChangedFunctions(e,g.GetChunks());
FindLiveSharedInfos(e,script);
var h;
try{
h=GatherCompileInfo(new_source,script);
}catch(e){
var i=
new Failure("Failed to compile new version of script: "+e);
if(e instanceof SyntaxError){
var j={
type:"liveedit_compile_error",
syntaxErrorMessage:e.message
CopyErrorPositionToDetails(e,j);
i.details=j;
throw i;
var k=BuildCodeInfoTree(h);
FindCorrespondingFunctions(e,k);
var l=new Array();
var m=new Array();
var n=new Array();
var o=new Array();
function HarvestTodo(p){
function CollectDamaged(q){
m.push(q);
for(var r=0;r<q.children.length;r++){
CollectDamaged(q.children[r]);
function CollectNew(t){
for(var r=0;r<t.length;r++){
n.push(t[r]);
CollectNew(t[r].children);
if(p.status==a.DAMAGED){
CollectDamaged(p);
return;
if(p.status==a.UNCHANGED){
o.push(p);
}else if(p.status==a.SOURCE_CHANGED){
o.push(p);
}else if(p.status==a.CHANGED){
l.push(p);
CollectNew(p.unmatched_new_nodes);
for(var r=0;r<p.children.length;r++){
HarvestTodo(p.children[r]);
var u={
change_tree:DescribeChangeTree(e),
textual_diff:{
old_len:c.length,
new_len:new_source.length,
chunks:diff_array
updated:false
if(preview_only){
return u;
HarvestTodo(e);
var v=new Array();
for(var r=0;r<l.length;r++){
var w=
l[r].live_shared_function_infos;
if(w){
for(var x=0;x<w.length;x++){
v.push(w[x]);
var y=
CheckStackActivations(v,change_log);
u.stack_modified=y!=0;
u[b]=
u.stack_modified;
var z=TemporaryRemoveBreakPoints(script,change_log);
var A;
if(m.length==0){
%LiveEditReplaceScript(script,new_source,null);
A=(void 0);
}else{
var B=CreateNameForOldScript(script);
A=%LiveEditReplaceScript(script,new_source,
var C=new Array();
change_log.push({linked_to_old_script:C});
for(var r=0;r<m.length;r++){
LinkToOldScript(m[r],A,
u.created_script_name=B;
for(var r=0;r<n.length;r++){
%LiveEditFunctionSetScript(
n[r].info.shared_function_info,script);
for(var r=0;r<l.length;r++){
PatchFunctionCode(l[r],change_log);
var D=new Array();
change_log.push({position_patched:D});
for(var r=0;r<o.length;r++){
PatchPositions(o[r],diff_array,
if(o[r].live_shared_function_infos){
o[r].live_shared_function_infos.
forEach(function(E){
%LiveEditFunctionSourceUpdated(E.raw_array);
z(g,A);
u.updated=true;
return u;
this.ApplyPatchMultiChunk=ApplyPatchMultiChunk;
function GatherCompileInfo(F,G){
var H=%LiveEditGatherCompileInfo(G,F);
var I=new Array();
var J=new Array();
for(var r=0;r<H.length;r++){
var E=new FunctionCompileInfo(H[r]);
%LiveEditFunctionSetScript(E.shared_function_info,(void 0));
I.push(E);
J.push(r);
for(var r=0;r<I.length;r++){
var K=r;
for(var x=r+1;x<I.length;x++){
if(I[K].start_position>I[x].start_position){
K=x;
if(K!=r){
var L=I[K];
var M=J[K];
I[K]=I[r];
J[K]=J[r];
I[r]=L;
J[r]=M;
var N=0;
function ResetIndexes(O,P){
var Q=-1;
while(N<I.length&&
I[N].outer_index==P){
var R=N;
I[R].outer_index=O;
if(Q!=-1){
I[Q].next_sibling_index=R;
Q=R;
N++;
ResetIndexes(R,J[R]);
if(Q!=-1){
I[Q].next_sibling_index=-1;
ResetIndexes(-1,-1);
Assert(N==I.length);
return I;
function PatchFunctionCode(p,S){
var T=p.corresponding_node.info;
if(p.live_shared_function_infos){
p.live_shared_function_infos.forEach(function(U){
%LiveEditReplaceFunctionCode(T.raw_array,
U.raw_array);
for(var r=0;r<p.children.length;r++){
if(p.children[r].corresponding_node){
var V=
p.children[r].corresponding_node.info.
shared_function_info;
if(p.children[r].live_shared_function_infos){
p.children[r].live_shared_function_infos.
forEach(function(W){
%LiveEditReplaceRefToNestedFunction(
U.info,
W.info);
S.push({function_patched:T.function_name});
}else{
S.push({function_patched:T.function_name,
function_info_not_found:true});
function LinkToOldScript(X,A,Y){
if(X.live_shared_function_infos){
X.live_shared_function_infos.
forEach(function(E){
%LiveEditFunctionSetScript(E.info,A);
Y.push({name:X.info.function_name});
}else{
Y.push(
{name:X.info.function_name,not_found:true});
function TemporaryRemoveBreakPoints(Z,S){
var aa=GetScriptBreakPoints(Z);
var ab=[];
S.push({break_points_update:ab});
var ac=[];
for(var r=0;r<aa.length;r++){
var ad=aa[r];
ad.clear();
var ae=Debug.findScriptSourcePosition(Z,
ad.line(),ad.column());
var af={
position:ae,
line:ad.line(),
column:ad.column()
ac.push(af);
return function(g,ag){
for(var r=0;r<aa.length;r++){
var ad=aa[r];
if(ag){
var ah=ad.cloneForOtherScript(ag);
ah.set(ag);
ab.push({
type:"copied_to_old",
id:ad.number(),
new_id:ah.number(),
positions:ac[r]
var ai=g.Translate(
ac[r].position,
PosTranslator.ShiftWithTopInsideChunkHandler);
var aj=
Z.locationFromPosition(ai,false);
ad.update_positions(aj.line,aj.column);
var ak={
position:ai,
line:aj.line,
column:aj.column
ad.set(Z);
ab.push({type:"position_changed",
id:ad.number(),
old_positions:ac[r],
new_positions:ak
function Assert(al,am){
if(!al){
if(am){
throw"Assert "+am;
}else{
throw"Assert";
function DiffChunk(an,ao,ap,aq){
this.pos1=an;
this.pos2=ao;
this.len1=ap;
this.len2=aq;
function PosTranslator(ar){
var as=new Array();
var at=0;
for(var r=0;r<ar.length;r+=3){
var au=ar[r];
var av=au+at;
var aw=ar[r+1];
var ax=ar[r+2];
as.push(new DiffChunk(au,av,aw-au,
ax-av));
at=ax-aw;
this.chunks=as;
PosTranslator.prototype.GetChunks=function(){
return this.chunks;
PosTranslator.prototype.Translate=function(ay,az){
var aA=this.chunks;
if(aA.length==0||ay<aA[0].pos1){
return ay;
var aB=0;
var aC=aA.length-1;
while(aB<aC){
var aD=Math.floor((aB+aC)/2);
if(ay<aA[aD+1].pos1){
aC=aD;
}else{
aB=aD+1;
var aE=aA[aB];
if(ay>=aE.pos1+aE.len1){
return ay+aE.pos2+aE.len2-aE.pos1-aE.len1;
if(!az){
az=PosTranslator.DefaultInsideChunkHandler;
return az(ay,aE);
PosTranslator.DefaultInsideChunkHandler=function(ay,aF){
Assert(false,"Cannot translate position in changed area");
PosTranslator.ShiftWithTopInsideChunkHandler=
function(ay,aF){
return ay-aF.pos1+aF.pos2;
var a={
UNCHANGED:"unchanged",
SOURCE_CHANGED:"source changed",
CHANGED:"changed",
DAMAGED:"damaged"
function CodeInfoTreeNode(aG,aH,aI){
this.info=aG;
this.children=aH;
this.array_index=aI;
this.parent=(void 0);
this.status=a.UNCHANGED;
this.status_explanation=(void 0);
this.new_start_pos=(void 0);
this.new_end_pos=(void 0);
this.corresponding_node=(void 0);
this.unmatched_new_nodes=(void 0);
this.textual_corresponding_node=(void 0);
this.textually_unmatched_new_nodes=(void 0);
this.live_shared_function_infos=(void 0);
function BuildCodeInfoTree(aJ){
var aK=0;
function BuildNode(){
var aL=aK;
aK++;
var aM=new Array();
while(aK<aJ.length&&
aJ[aK].outer_index==aL){
aM.push(BuildNode());
var q=new CodeInfoTreeNode(aJ[aL],aM,
aL);
for(var r=0;r<aM.length;r++){
aM[r].parent=q;
return q;
var aN=BuildNode();
Assert(aK==aJ.length);
return aN;
function MarkChangedFunctions(aO,as){
var aP=new function(){
var aQ=0;
var aR=0;
this.current=function(){return as[aQ];};
this.next=function(){
var aE=as[aQ];
aR=aE.pos2+aE.len2-(aE.pos1+aE.len1);
aQ++;
this.done=function(){return aQ>=as.length;};
this.TranslatePos=function(ay){return ay+aR;};
function ProcessInternals(aS){
aS.new_start_pos=aP.TranslatePos(
aS.info.start_position);
var aT=0;
var aU=false;
var aV=false;
while(!aP.done()&&
aP.current().pos1<aS.info.end_position){
if(aT<aS.children.length){
var aW=aS.children[aT];
if(aW.info.end_position<=aP.current().pos1){
ProcessUnchangedChild(aW);
aT++;
continue;
}else if(aW.info.start_position>=
aP.current().pos1+aP.current().len1){
aU=true;
aP.next();
continue;
}else if(aW.info.start_position<=aP.current().pos1&&
aW.info.end_position>=aP.current().pos1+
aP.current().len1){
ProcessInternals(aW);
aV=aV||
(aW.status!=a.UNCHANGED);
aU=aU||
(aW.status==a.DAMAGED);
aT++;
continue;
}else{
aU=true;
aW.status=a.DAMAGED;
aW.status_explanation=
"Text diff overlaps with function boundary";
aT++;
continue;
}else{
if(aP.current().pos1+aP.current().len1<=
aS.info.end_position){
aS.status=a.CHANGED;
aP.next();
continue;
}else{
aS.status=a.DAMAGED;
aS.status_explanation=
"Text diff overlaps with function boundary";
return;
Assert("Unreachable",false);
while(aT<aS.children.length){
var aW=aS.children[aT];
ProcessUnchangedChild(aW);
aT++;
if(aU){
aS.status=a.CHANGED;
}else if(aV){
aS.status=a.SOURCE_CHANGED;
aS.new_end_pos=
aP.TranslatePos(aS.info.end_position);
function ProcessUnchangedChild(q){
q.new_start_pos=aP.TranslatePos(q.info.start_position);
q.new_end_pos=aP.TranslatePos(q.info.end_position);
ProcessInternals(aO);
function FindCorrespondingFunctions(aX,aY){
function ProcessNode(p,aZ){
var ba=
IsFunctionContextLocalsChanged(p.info,aZ.info);
if(ba){
p.status=a.CHANGED;
var bb=p.children;
var bc=aZ.children;
var bd=[];
var be=[];
var bf=0;
var bg=0;
while(bf<bb.length){
if(bb[bf].status==a.DAMAGED){
bf++;
}else if(bg<bc.length){
if(bc[bg].info.start_position<
bb[bf].new_start_pos){
bd.push(bc[bg]);
be.push(bc[bg]);
bg++;
}else if(bc[bg].info.start_position==
bb[bf].new_start_pos){
if(bc[bg].info.end_position==
bb[bf].new_end_pos){
bb[bf].corresponding_node=
bc[bg];
bb[bf].textual_corresponding_node=
bc[bg];
if(ba){
bb[bf].status=a.DAMAGED;
bb[bf].status_explanation=
"Enclosing function is now incompatible. "+
bb[bf].corresponding_node=(void 0);
}else if(bb[bf].status!=
a.UNCHANGED){
ProcessNode(bb[bf],
bc[bg]);
if(bb[bf].status==a.DAMAGED){
bd.push(
bb[bf].corresponding_node);
bb[bf].corresponding_node=(void 0);
p.status=a.CHANGED;
}else{
bb[bf].status=a.DAMAGED;
bb[bf].status_explanation=
"No corresponding function in new script found";
p.status=a.CHANGED;
bd.push(bc[bg]);
be.push(bc[bg]);
bg++;
bf++;
}else{
bb[bf].status=a.DAMAGED;
bb[bf].status_explanation=
"No corresponding function in new script found";
p.status=a.CHANGED;
bf++;
}else{
bb[bf].status=a.DAMAGED;
bb[bf].status_explanation=
"No corresponding function in new script found";
p.status=a.CHANGED;
bf++;
while(bg<bc.length){
bd.push(bc[bg]);
be.push(bc[bg]);
bg++;
if(p.status==a.CHANGED){
if(p.info.param_num!=aZ.info.param_num){
p.status=a.DAMAGED;
p.status_explanation="Changed parameter number: "+
p.info.param_num+" and "+aZ.info.param_num;
p.unmatched_new_nodes=bd;
p.textually_unmatched_new_nodes=
ProcessNode(aX,aY);
aX.corresponding_node=aY;
aX.textual_corresponding_node=aY;
Assert(aX.status!=a.DAMAGED,
"Script became damaged");
function FindLiveSharedInfos(aX,G){
var bh=%LiveEditFindSharedFunctionInfosForScript(G);
var bi=new Array();
for(var r=0;r<bh.length;r++){
bi.push(new SharedInfoWrapper(bh[r]));
function FindFunctionInfos(I){
var bj=[];
for(var r=0;r<bi.length;r++){
var bk=bi[r];
if(bk.start_position==I.start_position&&
bk.end_position==I.end_position){
bj.push(bk);
if(bj.length>0){
return bj;
function TraverseTree(q){
q.live_shared_function_infos=FindFunctionInfos(q.info);
for(var r=0;r<q.children.length;r++){
TraverseTree(q.children[r]);
TraverseTree(aX);
function FunctionCompileInfo(bl){
this.function_name=bl[0];
this.start_position=bl[1];
this.end_position=bl[2];
this.param_num=bl[3];
this.code=bl[4];
this.code_scope_info=bl[5];
this.scope_info=bl[6];
this.outer_index=bl[7];
this.shared_function_info=bl[8];
this.next_sibling_index=null;
this.raw_array=bl;
function SharedInfoWrapper(bl){
this.function_name=bl[0];
this.start_position=bl[1];
this.end_position=bl[2];
this.info=bl[3];
this.raw_array=bl;
function PatchPositions(X,ar,Y){
if(X.live_shared_function_infos){
X.live_shared_function_infos.forEach(function(E){
%LiveEditPatchFunctionPositions(E.raw_array,
ar);
Y.push({name:X.info.function_name});
}else{
Y.push(
{name:X.info.function_name,info_not_found:true});
function CreateNameForOldScript(G){
return G.name+" (old)";
function IsFunctionContextLocalsChanged(bm,bn){
var bo=bm.scope_info;
var bp=bn.scope_info;
var bq;
var br;
if(bo){
bq=bo.toString();
}else{
bq="";
if(bp){
br=bp.toString();
}else{
br="";
if(bq!=br){
return"Variable map changed: ["+bq+
"] => ["+br+"]";
return;
var bs;
function CheckStackActivations(bt,S){
var bu=new Array();
for(var r=0;r<bt.length;r++){
bu[r]=bt[r].info;
var bv=%LiveEditCheckAndDropActivations(bu,true);
if(bv[bu.length]){
throw new Failure(bv[bu.length]);
var bw=new Array();
var bx=new Array();
for(var r=0;r<bu.length;r++){
var by=bt[r];
if(bv[r]==bs.REPLACED_ON_ACTIVE_STACK){
bx.push({name:by.function_name});
}else if(bv[r]!=bs.AVAILABLE_FOR_PATCH){
var bz={
name:by.function_name,
start_pos:by.start_position,
end_pos:by.end_position,
replace_problem:
bs.SymbolName(bv[r])
bw.push(bz);
if(bx.length>0){
S.push({dropped_from_stack:bx});
if(bw.length>0){
S.push({functions_on_stack:bw});
throw new Failure("Blocked by functions on stack");
return bx.length;
var bs={
AVAILABLE_FOR_PATCH:1,
BLOCKED_ON_ACTIVE_STACK:2,
BLOCKED_ON_OTHER_STACK:3,
BLOCKED_UNDER_NATIVE_CODE:4,
REPLACED_ON_ACTIVE_STACK:5,
BLOCKED_UNDER_GENERATOR:6,
BLOCKED_ACTIVE_GENERATOR:7
bs.SymbolName=function(bA){
var bB=bs;
for(var bC in bB){
if(bB[bC]==bA){
return bC;
function Failure(am){
this.message=am;
this.Failure=Failure;
Failure.prototype.toString=function(){
return"LiveEdit Failure: "+this.message;
function CopyErrorPositionToDetails(bD,j){
function createPositionStruct(G,bE){
if(bE==-1)return;
var bF=G.locationFromPosition(bE,true);
if(bF==null)return;
return{
line:bF.line+1,
column:bF.column+1,
position:bE
if(!("scriptObject"in bD)||!("startPosition"in bD)){
return;
var G=bD.scriptObject;
var bG={
start:createPositionStruct(G,bD.startPosition),
end:createPositionStruct(G,bD.endPosition)
j.position=bG;
function GetPcFromSourcePos(bH,bI){
return %GetFunctionCodePositionFromSource(bH,bI);
this.GetPcFromSourcePos=GetPcFromSourcePos;
function SetScriptSource(G,bJ,bK,S){
var c=G.source;
var bL=CompareStrings(c,bJ);
return ApplyPatchMultiChunk(G,bL,bJ,bK,
this.SetScriptSource=SetScriptSource;
function CompareStrings(bM,bN){
return %LiveEditCompareStrings(bM,bN);
function ApplySingleChunkPatch(G,change_pos,change_len,new_str,
var c=G.source;
var bJ=c.substring(0,change_pos)+
new_str+c.substring(change_pos+change_len);
return ApplyPatchMultiChunk(G,
[change_pos,change_pos+change_len,change_pos+new_str.length],
bJ,false,S);
function DescribeChangeTree(aX){
function ProcessOldNode(q){
var bO=[];
for(var r=0;r<q.children.length;r++){
var aW=q.children[r];
if(aW.status!=a.UNCHANGED){
bO.push(ProcessOldNode(aW));
var bP=[];
if(q.textually_unmatched_new_nodes){
for(var r=0;r<q.textually_unmatched_new_nodes.length;r++){
var aW=q.textually_unmatched_new_nodes[r];
bP.push(ProcessNewNode(aW));
var bQ={
name:q.info.function_name,
positions:DescribePositions(q),
status:q.status,
children:bO,
new_children:bP
if(q.status_explanation){
bQ.status_explanation=q.status_explanation;
if(q.textual_corresponding_node){
bQ.new_positions=DescribePositions(q.textual_corresponding_node);
return bQ;
function ProcessNewNode(q){
var bO=[];
if(false){
for(var r=0;r<q.children.length;r++){
bO.push(ProcessNewNode(q.children[r]));
var bQ={
name:q.info.function_name,
positions:DescribePositions(q),
children:bO,
return bQ;
function DescribePositions(q){
return{
start_position:q.info.start_position,
end_position:q.info.end_position
return ProcessOldNode(aX);
function RestartFrame(bR){
var bv=bR.restart();
if((typeof(bv)==='string')){
throw new Failure("Failed to restart frame: "+bv);
var bv={};
bv[b]=true;
return bv;
this.RestartFrame=RestartFrame;
this.TestApi={
PosTranslator:PosTranslator,
CompareStrings:CompareStrings,
ApplySingleChunkPatch:ApplySingleChunkPatch
var EQUALS;
var STRICT_EQUALS;
var COMPARE;
var COMPARE_STRONG;
var ADD;
var ADD_STRONG;
var STRING_ADD_LEFT;
var STRING_ADD_LEFT_STRONG;
var STRING_ADD_RIGHT;
var STRING_ADD_RIGHT_STRONG;
var SUB;
var SUB_STRONG;
var MUL;
var MUL_STRONG;
var DIV;
var DIV_STRONG;
var MOD;
var MOD_STRONG;
var BIT_OR;
var BIT_OR_STRONG;
var BIT_AND;
var BIT_AND_STRONG;
var BIT_XOR;
var BIT_XOR_STRONG;
var SHL;
var SHL_STRONG;
var SAR;
var SAR_STRONG;
var SHR;
var SHR_STRONG;
var DELETE;
var IN;
var INSTANCE_OF;
var CALL_NON_FUNCTION;
var CALL_NON_FUNCTION_AS_CONSTRUCTOR;
var CALL_FUNCTION_PROXY;
var CALL_FUNCTION_PROXY_AS_CONSTRUCTOR;
var CONCAT_ITERABLE_TO_ARRAY;
var APPLY_PREPARE;
var REFLECT_APPLY_PREPARE;
var REFLECT_CONSTRUCT_PREPARE;
var STACK_OVERFLOW;
var TO_OBJECT;
var TO_NUMBER;
var TO_STRING;
var TO_NAME;
var StringLengthTFStub;
var StringAddTFStub;
var MathFloorStub;
var $defaultNumber;
var $defaultString;
var $NaN;
var $nonNumberToNumber;
var $nonStringToString;
var $sameValue;
var $sameValueZero;
var $toBoolean;
var $toInt32;
var $toInteger;
var $toLength;
var $toName;
var $toNumber;
var $toObject;
var $toPositiveInteger;
var $toPrimitive;
var $toString;
var $toUint32;
(function(a,b){
%CheckIsBootstrapping();
var c=a.Array;
var d=a.Boolean;
var e=a.String;
var g=a.Number;
EQUALS=function EQUALS(h){
if((typeof(this)==='string')&&(typeof(h)==='string'))return %StringEquals(this,h);
var i=this;
while(true){
if((typeof(i)==='number')){
while(true){
if((typeof(h)==='number'))return %NumberEquals(i,h);
if((h==null))return 1;
if((typeof(h)==='symbol'))return 1;
if(!(%_IsSpecObject(h))){
return %NumberEquals(i,%$toNumber(h));
h=%$toPrimitive(h,0);
}else if((typeof(i)==='string')){
while(true){
if((typeof(h)==='string'))return %StringEquals(i,h);
if((typeof(h)==='symbol'))return 1;
if((typeof(h)==='number'))return %NumberEquals(%$toNumber(i),h);
if((typeof(h)==='boolean'))return %NumberEquals(%$toNumber(i),%$toNumber(h));
if((h==null))return 1;
h=%$toPrimitive(h,0);
}else if((typeof(i)==='symbol')){
if((typeof(h)==='symbol'))return %_ObjectEquals(i,h)?0:1;
return 1;
}else if((typeof(i)==='boolean')){
if((typeof(h)==='boolean'))return %_ObjectEquals(i,h)?0:1;
if((h==null))return 1;
if((typeof(h)==='number'))return %NumberEquals(%$toNumber(i),h);
if((typeof(h)==='string'))return %NumberEquals(%$toNumber(i),%$toNumber(h));
if((typeof(h)==='symbol'))return 1;
i=%$toNumber(i);
h=%$toPrimitive(h,0);
}else if((i==null)){
return(h==null)?0:1;
}else{
if((%_IsSpecObject(h))){
return %_ObjectEquals(i,h)?0:1;
if((h==null))return 1;
if((typeof(h)==='symbol'))return 1;
if((typeof(h)==='boolean'))h=%$toNumber(h);
i=%$toPrimitive(i,0);
STRICT_EQUALS=function STRICT_EQUALS(i){
if((typeof(this)==='string')){
if(!(typeof(i)==='string'))return 1;
return %StringEquals(this,i);
if((typeof(this)==='number')){
if(!(typeof(i)==='number'))return 1;
return %NumberEquals(this,i);
return %_ObjectEquals(this,i)?0:1;
COMPARE=function COMPARE(i,j){
var k;
var l;
if((typeof(this)==='string')){
if((typeof(i)==='string'))return %_StringCompare(this,i);
if((i===(void 0)))return j;
k=this;
}else if((typeof(this)==='number')){
if((typeof(i)==='number'))return %NumberCompare(this,i,j);
if((i===(void 0)))return j;
k=this;
}else if((this===(void 0))){
if(!(i===(void 0))){
%$toPrimitive(i,1);
return j;
}else if((i===(void 0))){
%$toPrimitive(this,1);
return j;
}else{
k=%$toPrimitive(this,1);
l=%$toPrimitive(i,1);
if((typeof(k)==='string')&&(typeof(l)==='string')){
return %_StringCompare(k,l);
}else{
var m=%$toNumber(k);
var n=%$toNumber(l);
if((!%_IsSmi(%IS_VAR(m))&&!(m==m))||(!%_IsSmi(%IS_VAR(n))&&!(n==n)))return j;
return %NumberCompare(m,n,j);
COMPARE_STRONG=function COMPARE_STRONG(i,j){
if((typeof(this)==='string')&&(typeof(i)==='string'))return %_StringCompare(this,i);
if((typeof(this)==='number')&&(typeof(i)==='number'))return %NumberCompare(this,i,j);
throw %MakeTypeError(106);
ADD=function ADD(i){
if((typeof(this)==='number')&&(typeof(i)==='number'))return %NumberAdd(this,i);
if((typeof(this)==='string')&&(typeof(i)==='string'))return %_StringAdd(this,i);
var o=%$toPrimitive(this,0);
var p=%$toPrimitive(i,0);
if((typeof(o)==='string')){
return %_StringAdd(o,%$toString(p));
}else if((typeof(p)==='string')){
return %_StringAdd(%$nonStringToString(o),p);
}else{
return %NumberAdd(%$toNumber(o),%$toNumber(p));
ADD_STRONG=function ADD_STRONG(i){
if((typeof(this)==='number')&&(typeof(i)==='number'))return %NumberAdd(this,i);
if((typeof(this)==='string')&&(typeof(i)==='string'))return %_StringAdd(this,i);
throw %MakeTypeError(106);
STRING_ADD_LEFT=function STRING_ADD_LEFT(h){
if(!(typeof(h)==='string')){
if((%_ClassOf(h)==='String')&&%_IsStringWrapperSafeForDefaultValueOf(h)){
h=%_ValueOf(h);
}else{
h=(typeof(h)==='number')
?%_NumberToString(h)
:%$toString(%$toPrimitive(h,0));
return %_StringAdd(this,h);
STRING_ADD_LEFT_STRONG=function STRING_ADD_LEFT_STRONG(h){
if((typeof(h)==='string')){
return %_StringAdd(this,h);
throw %MakeTypeError(106);
STRING_ADD_RIGHT=function STRING_ADD_RIGHT(h){
var i=this;
if(!(typeof(i)==='string')){
if((%_ClassOf(i)==='String')&&%_IsStringWrapperSafeForDefaultValueOf(i)){
i=%_ValueOf(i);
}else{
i=(typeof(i)==='number')
?%_NumberToString(i)
:%$toString(%$toPrimitive(i,0));
return %_StringAdd(i,h);
STRING_ADD_RIGHT_STRONG=function STRING_ADD_RIGHT_STRONG(h){
if((typeof(this)==='string')){
return %_StringAdd(this,h);
throw %MakeTypeError(106);
SUB=function SUB(h){
var i=(typeof(this)==='number')?this:%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
return %NumberSub(i,h);
SUB_STRONG=function SUB_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberSub(this,h);
throw %MakeTypeError(106);
MUL=function MUL(h){
var i=(typeof(this)==='number')?this:%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
return %NumberMul(i,h);
MUL_STRONG=function MUL_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberMul(this,h);
throw %MakeTypeError(106);
DIV=function DIV(h){
var i=(typeof(this)==='number')?this:%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
return %NumberDiv(i,h);
DIV_STRONG=function DIV_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberDiv(this,h);
throw %MakeTypeError(106);
MOD=function MOD(h){
var i=(typeof(this)==='number')?this:%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
return %NumberMod(i,h);
MOD_STRONG=function MOD_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberMod(this,h);
throw %MakeTypeError(106);
BIT_OR=function BIT_OR(h){
var i=(typeof(this)==='number')?this:%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
return %NumberOr(i,h);
BIT_OR_STRONG=function BIT_OR_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberOr(this,h);
throw %MakeTypeError(106);
BIT_AND=function BIT_AND(h){
var i;
if((typeof(this)==='number')){
i=this;
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
}else{
i=%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
if((!%_IsSmi(%IS_VAR(i))&&!(i==i)))return 0;
return %NumberAnd(i,h);
BIT_AND_STRONG=function BIT_AND_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberAnd(this,h);
throw %MakeTypeError(106);
BIT_XOR=function BIT_XOR(h){
var i=(typeof(this)==='number')?this:%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
return %NumberXor(i,h);
BIT_XOR_STRONG=function BIT_XOR_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberXor(this,h);
throw %MakeTypeError(106);
SHL=function SHL(h){
var i=(typeof(this)==='number')?this:%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
return %NumberShl(i,h);
SHL_STRONG=function SHL_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberShl(this,h);
throw %MakeTypeError(106);
SAR=function SAR(h){
var i;
if((typeof(this)==='number')){
i=this;
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
}else{
i=%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
if((!%_IsSmi(%IS_VAR(i))&&!(i==i)))return 0;
return %NumberSar(i,h);
SAR_STRONG=function SAR_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberSar(this,h);
throw %MakeTypeError(106);
SHR=function SHR(h){
var i=(typeof(this)==='number')?this:%$nonNumberToNumber(this);
if(!(typeof(h)==='number'))h=%$nonNumberToNumber(h);
return %NumberShr(i,h);
SHR_STRONG=function SHR_STRONG(h){
if((typeof(this)==='number')&&(typeof(h)==='number')){
return %NumberShr(this,h);
throw %MakeTypeError(106);
DELETE=function DELETE(q,r){
return %DeleteProperty(%$toObject(this),q,r);
IN=function IN(i){
if(!(%_IsSpecObject(i))){
throw %MakeTypeError(37,this,i);
if(%_IsNonNegativeSmi(this)){
if((%_IsArray(i))&&%_HasFastPackedElements(i)){
return this<i.length;
return %HasElement(i,this);
return %HasProperty(i,%$toName(this));
INSTANCE_OF=function INSTANCE_OF(t){
var u=this;
if(!(%_ClassOf(t)==='Function')){
throw %MakeTypeError(34,t);
if(!(%_IsSpecObject(u))){
return 1;
var v=%BoundFunctionGetBindings(t);
if(v){
t=v[0];
var w=t.prototype;
if(!(%_IsSpecObject(w))){
throw %MakeTypeError(35,w);
return %IsInPrototypeChain(w,u)?0:1;
CALL_NON_FUNCTION=function CALL_NON_FUNCTION(){
var x=%GetFunctionDelegate(this);
if(!(%_IsFunction(x))){
var y=%RenderCallSite();
if(y=="")y=typeof this;
throw %MakeTypeError(12,y);
return %Apply(x,this,arguments,0,%_ArgumentsLength());
CALL_NON_FUNCTION_AS_CONSTRUCTOR=function CALL_NON_FUNCTION_AS_CONSTRUCTOR(){
var x=%GetConstructorDelegate(this);
if(!(%_IsFunction(x))){
var y=%RenderCallSite();
if(y=="")y=typeof this;
throw %MakeTypeError(12,y);
return %Apply(x,this,arguments,0,%_ArgumentsLength());
CALL_FUNCTION_PROXY=function CALL_FUNCTION_PROXY(){
var z=%_ArgumentsLength()-1;
var A=%_Arguments(z);
var B=%GetCallTrap(A);
return %Apply(B,this,arguments,0,z);
CALL_FUNCTION_PROXY_AS_CONSTRUCTOR=
function CALL_FUNCTION_PROXY_AS_CONSTRUCTOR(){
var A=this;
var B=%GetConstructTrap(A);
return %Apply(B,this,arguments,0,%_ArgumentsLength());
APPLY_PREPARE=function APPLY_PREPARE(C){
var D;
if((%_IsArray(C))){
D=C.length;
if(%_IsSmi(D)&&D>=0&&D<0x800000&&
(%_ClassOf(this)==='Function')){
return D;
D=(C==null)?0:%$toUint32(C.length);
if(D>0x800000)throw %MakeRangeError(145);
if(!(%_ClassOf(this)==='Function')){
throw %MakeTypeError(8,%$toString(this),typeof this);
if(C!=null&&!(%_IsSpecObject(C))){
throw %MakeTypeError(117,"Function.prototype.apply");
return D;
REFLECT_APPLY_PREPARE=function REFLECT_APPLY_PREPARE(C){
var D;
if((%_IsArray(C))){
D=C.length;
if(%_IsSmi(D)&&D>=0&&D<0x800000&&
(%_ClassOf(this)==='Function')){
return D;
if(!(%_ClassOf(this)==='Function')){
throw %MakeTypeError(12,%$toString(this));
if(!(%_IsSpecObject(C))){
throw %MakeTypeError(117,"Reflect.apply");
D=%$toLength(C.length);
if(D>0x800000)throw %MakeRangeError(145);
return D;
REFLECT_CONSTRUCT_PREPARE=function REFLECT_CONSTRUCT_PREPARE(
C,newTarget){
var D;
var E=(%_ClassOf(this)==='Function')&&%IsConstructor(this);
var F=(%_ClassOf(newTarget)==='Function')&&%IsConstructor(newTarget);
if((%_IsArray(C))){
D=C.length;
if(%_IsSmi(D)&&D>=0&&D<0x800000&&
E&&F){
return D;
if(!E){
if(!(%_ClassOf(this)==='Function')){
throw %MakeTypeError(12,%$toString(this));
}else{
throw %MakeTypeError(52,%$toString(this));
if(!F){
if(!(%_ClassOf(newTarget)==='Function')){
throw %MakeTypeError(12,%$toString(newTarget));
}else{
throw %MakeTypeError(52,%$toString(newTarget));
if(!(%_IsSpecObject(C))){
throw %MakeTypeError(117,"Reflect.construct");
D=%$toLength(C.length);
if(D>0x800000)throw %MakeRangeError(145);
return D;
CONCAT_ITERABLE_TO_ARRAY=function CONCAT_ITERABLE_TO_ARRAY(G){
return %$concatIterableToArray(this,G);
STACK_OVERFLOW=function STACK_OVERFLOW(D){
throw %MakeRangeError(145);
TO_OBJECT=function TO_OBJECT(){
return %$toObject(this);
TO_NUMBER=function TO_NUMBER(){
return %$toNumber(this);
TO_STRING=function TO_STRING(){
return %$toString(this);
TO_NAME=function TO_NAME(){
return %$toName(this);
StringLengthTFStub=function StringLengthTFStub(H,I){
var J=function(K,L,M,N){
return %_StringGetLength(%_JSValueGetValue(K));
return J;
StringAddTFStub=function StringAddTFStub(H,I){
var J=function(k,l){
return %StringAdd(k,l);
return J;
MathFloorStub=function MathFloorStub(H,I){
var J=function(O,M,N){
var P=%_MathFloor(+N);
if(%_IsMinusZero(P)){
%_FixedArraySet(%_GetTypeFeedbackVector(O),((M|0)+1)|0,1);
return-0;
var Q=P|0;
if(Q===P){
return Q;
return P;
return J;
function ToPrimitive(i,R){
if((typeof(i)==='string'))return i;
if(!(%_IsSpecObject(i)))return i;
if((%_ClassOf(i)==='Symbol'))throw MakeTypeError(110);
if(R==0)R=((%_IsDate(i)))?2:1;
return(R==1)?DefaultNumber(i):DefaultString(i);
function ToBoolean(i){
if((typeof(i)==='boolean'))return i;
if((typeof(i)==='string'))return i.length!=0;
if(i==null)return false;
if((typeof(i)==='number'))return!((i==0)||(!%_IsSmi(%IS_VAR(i))&&!(i==i)));
return true;
function ToNumber(i){
if((typeof(i)==='number'))return i;
if((typeof(i)==='string')){
return %_HasCachedArrayIndex(i)?%_GetCachedArrayIndex(i)
:%StringToNumber(i);
if((typeof(i)==='boolean'))return i?1:0;
if((i===(void 0)))return $NaN;
if((typeof(i)==='symbol'))throw MakeTypeError(111);
return((i===null))?0:ToNumber(DefaultNumber(i));
function NonNumberToNumber(i){
if((typeof(i)==='string')){
return %_HasCachedArrayIndex(i)?%_GetCachedArrayIndex(i)
:%StringToNumber(i);
if((typeof(i)==='boolean'))return i?1:0;
if((i===(void 0)))return $NaN;
if((typeof(i)==='symbol'))throw MakeTypeError(111);
return((i===null))?0:ToNumber(DefaultNumber(i));
function ToString(i){
if((typeof(i)==='string'))return i;
if((typeof(i)==='number'))return %_NumberToString(i);
if((typeof(i)==='boolean'))return i?'true':'false';
if((i===(void 0)))return'undefined';
if((typeof(i)==='symbol'))throw MakeTypeError(112);
return((i===null))?'null':ToString(DefaultString(i));
function NonStringToString(i){
if((typeof(i)==='number'))return %_NumberToString(i);
if((typeof(i)==='boolean'))return i?'true':'false';
if((i===(void 0)))return'undefined';
if((typeof(i)==='symbol'))throw MakeTypeError(112);
return((i===null))?'null':ToString(DefaultString(i));
function ToName(i){
return(typeof(i)==='symbol')?i:ToString(i);
function ToObject(i){
if((typeof(i)==='string'))return new e(i);
if((typeof(i)==='number'))return new g(i);
if((typeof(i)==='boolean'))return new d(i);
if((typeof(i)==='symbol'))return %NewSymbolWrapper(i);
if((i==null)&&!(%_IsUndetectableObject(i))){
throw MakeTypeError(113);
return i;
function ToInteger(i){
if(%_IsSmi(i))return i;
return %NumberToInteger(ToNumber(i));
function ToLength(S){
S=ToInteger(S);
if(S<0)return 0;
return S<g.MAX_SAFE_INTEGER?S
:g.MAX_SAFE_INTEGER;
function ToUint32(i){
if(%_IsSmi(i)&&i>=0)return i;
return %NumberToJSUint32(ToNumber(i));
function ToInt32(i){
if(%_IsSmi(i))return i;
return %NumberToJSInt32(ToNumber(i));
function SameValue(i,h){
if(typeof i!=typeof h)return false;
if((typeof(i)==='number')){
if((!%_IsSmi(%IS_VAR(i))&&!(i==i))&&(!%_IsSmi(%IS_VAR(h))&&!(h==h)))return true;
if(i===0&&h===0&&%_IsMinusZero(i)!=%_IsMinusZero(h)){
return false;
return i===h;
function SameValueZero(i,h){
if(typeof i!=typeof h)return false;
if((typeof(i)==='number')){
if((!%_IsSmi(%IS_VAR(i))&&!(i==i))&&(!%_IsSmi(%IS_VAR(h))&&!(h==h)))return true;
return i===h;
function ConcatIterableToArray(T,G){
var U=T.length;
for(var V of G){
%AddElement(T,U++,V);
return T;
function IsPrimitive(i){
return!(%_IsSpecObject(i));
function IsConcatSpreadable(w){
if(!(%_IsSpecObject(w)))return false;
var W=w[symbolIsConcatSpreadable];
if((W===(void 0)))return(%_IsArray(w));
return ToBoolean(W);
function DefaultNumber(i){
if(!(%_ClassOf(i)==='Symbol')){
var X=i.valueOf;
if((%_ClassOf(X)==='Function')){
var N=%_CallFunction(i,X);
if(IsPrimitive(N))return N;
var Y=i.toString;
if((%_ClassOf(Y)==='Function')){
var Z=%_CallFunction(i,Y);
if(IsPrimitive(Z))return Z;
throw MakeTypeError(15);
function DefaultString(i){
if(!(%_ClassOf(i)==='Symbol')){
var Y=i.toString;
if((%_ClassOf(Y)==='Function')){
var Z=%_CallFunction(i,Y);
if(IsPrimitive(Z))return Z;
var X=i.valueOf;
if((%_ClassOf(X)==='Function')){
var N=%_CallFunction(i,X);
if(IsPrimitive(N))return N;
throw MakeTypeError(15);
function ToPositiveInteger(i,aa){
var M=(%_IsSmi(%IS_VAR(i))?i:%NumberToIntegerMapMinusZero($toNumber(i)));
if(M<0)throw MakeRangeError(aa);
return M;
%FunctionSetPrototype(c,new c(0));
$concatIterableToArray=ConcatIterableToArray;
$defaultNumber=DefaultNumber;
$defaultString=DefaultString;
$NaN=%GetRootNaN();
$nonNumberToNumber=NonNumberToNumber;
$nonStringToString=NonStringToString;
$sameValue=SameValue;
$sameValueZero=SameValueZero;
$toBoolean=ToBoolean;
$toInt32=ToInt32;
$toInteger=ToInteger;
$toLength=ToLength;
$toName=ToName;
$toNumber=ToNumber;
$toObject=ToObject;
$toPositiveInteger=ToPositiveInteger;
$toPrimitive=ToPrimitive;
$toString=ToString;
$toUint32=ToUint32;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=(void 0);
var d=(void 0);
var e=(void 0);
function Export(g){
g.next=d;
d=g;
function Import(g){
g.next=c;
c=g;
function ImportFromExperimental(g){
g.next=e;
e=g;
function SetFunctionName(g,h,i){
if((typeof(h)==='symbol')){
h="["+%SymbolDescription(h)+"]";
if((i===(void 0))){
%FunctionSetName(g,h);
}else{
%FunctionSetName(g,i+" "+h);
function InstallConstants(j,k){
%CheckIsBootstrapping();
%OptimizeObjectForAddingMultipleProperties(j,k.length>>1);
var l=2|4|1;
for(var m=0;m<k.length;m+=2){
var h=k[m];
var n=k[m+1];
%AddNamedProperty(j,h,n,l);
%ToFastProperties(j);
function InstallFunctions(j,l,o){
%CheckIsBootstrapping();
%OptimizeObjectForAddingMultipleProperties(j,o.length>>1);
for(var m=0;m<o.length;m+=2){
var p=o[m];
var g=o[m+1];
SetFunctionName(g,p);
%FunctionRemovePrototype(g);
%AddNamedProperty(j,p,g,l);
%SetNativeFlag(g);
%ToFastProperties(j);
function InstallGetter(j,h,q,l){
%CheckIsBootstrapping();
if(typeof l=="undefined"){
l=2;
SetFunctionName(q,h,"get");
%FunctionRemovePrototype(q);
%DefineAccessorPropertyUnchecked(j,h,q,null,l);
%SetNativeFlag(q);
function InstallGetterSetter(j,h,q,r){
%CheckIsBootstrapping();
SetFunctionName(q,h,"get");
SetFunctionName(r,h,"set");
%FunctionRemovePrototype(q);
%FunctionRemovePrototype(r);
%DefineAccessorPropertyUnchecked(j,h,q,r,2);
%SetNativeFlag(q);
%SetNativeFlag(r);
function SetUpLockedPrototype(
constructor,fields,methods){
%CheckIsBootstrapping();
var t=constructor.prototype;
var u=(methods.length>>1)+(fields?fields.length:0);
if(u>=4){
%OptimizeObjectForAddingMultipleProperties(t,u);
if(fields){
for(var m=0;m<fields.length;m++){
%AddNamedProperty(t,fields[m],
(void 0),2|4);
for(var m=0;m<methods.length;m+=2){
var p=methods[m];
var g=methods[m+1];
%AddNamedProperty(t,p,g,2|4|1);
%SetNativeFlag(g);
%InternalSetPrototype(t,null);
%ToFastProperties(t);
var v=(void 0);
function PostNatives(b){
%CheckIsBootstrapping();
var w={};
for(;!(d===(void 0));d=d.next)d(w);
for(;!(c===(void 0));c=c.next)c(w);
var x=[
"ArrayToString",
"GetIterator",
"GetMethod",
"InnerArrayEvery",
"InnerArrayFilter",
"InnerArrayForEach",
"InnerArrayIndexOf",
"InnerArrayJoin",
"InnerArrayLastIndexOf",
"InnerArrayMap",
"InnerArrayReduce",
"InnerArrayReduceRight",
"InnerArrayReverse",
"InnerArraySome",
"InnerArraySort",
"InnerArrayToLocaleString",
"IsNaN",
"MathMax",
"MathMin",
"ObjectIsFrozen",
"ObjectDefineProperty",
"OwnPropertyKeys",
"ToNameArray",
v={};
%OptimizeObjectForAddingMultipleProperties(
v,x.length);
for(var p of x){
v[p]=w[p];
%ToFastProperties(v);
w=(void 0);
b.PostNatives=(void 0);
b.ImportFromExperimental=(void 0);
function PostExperimentals(b){
%CheckIsBootstrapping();
for(;!(d===(void 0));d=d.next){
d(v);
for(;!(c===(void 0));c=c.next){
c(v);
for(;!(e===(void 0));
e=e.next){
e(v);
v=(void 0);
b.PostExperimentals=(void 0);
b.Import=(void 0);
b.Export=(void 0);
InstallFunctions(b,0,[
"Import",Import,
"Export",Export,
"ImportFromExperimental",ImportFromExperimental,
"SetFunctionName",SetFunctionName,
"InstallConstants",InstallConstants,
"InstallFunctions",InstallFunctions,
"InstallGetter",InstallGetter,
"InstallGetterSetter",InstallGetterSetter,
"SetUpLockedPrototype",SetUpLockedPrototype,
"PostNatives",PostNatives,
"PostExperimentals",PostExperimentals,
var $functionSourceString;
var $globalEval;
var $objectDefineOwnProperty;
var $objectGetOwnPropertyDescriptor;
var $toCompletePropertyDescriptor;
(function(a,b){
%CheckIsBootstrapping();
var c=a.Array;
var d=a.Boolean;
var e=a.Function;
var g=a.Number;
var h=a.Object;
var i=b.InternalArray;
var j;
var k;
var l;
var m;
var n;
b.Import(function(o){
j=o.MathAbs;
n=o.StringIndexOf;
b.ImportFromExperimental(function(o){
k=o.ProxyDelegateCallAndConstruct;
l=o.ProxyDerivedHasOwnTrap;
m=o.ProxyDerivedKeysTrap;
function GlobalIsNaN(p){
p=((typeof(%IS_VAR(p))==='number')?p:$nonNumberToNumber(p));
return(!%_IsSmi(%IS_VAR(p))&&!(p==p));
function GlobalIsFinite(p){
p=((typeof(%IS_VAR(p))==='number')?p:$nonNumberToNumber(p));
return(%_IsSmi(%IS_VAR(p))||((p==p)&&(p!=1/0)&&(p!=-1/0)));
function GlobalParseInt(q,r){
if((r===(void 0))||r===10||r===0){
if(%_IsSmi(q))return q;
if((typeof(q)==='number')&&
((0.01<q&&q<1e9)||
(-1e9<q&&q<-0.01))){
return q|0;
q=((typeof(%IS_VAR(q))==='string')?q:$nonStringToString(q));
r=r|0;
}else{
q=((typeof(%IS_VAR(q))==='string')?q:$nonStringToString(q));
r=(%_IsSmi(%IS_VAR(r))?r:(r>>0));
if(!(r==0||(2<=r&&r<=36))){
return $NaN;
if(%_HasCachedArrayIndex(q)&&
(r==0||r==10)){
return %_GetCachedArrayIndex(q);
return %StringParseInt(q,r);
function GlobalParseFloat(q){
q=((typeof(%IS_VAR(q))==='string')?q:$nonStringToString(q));
if(%_HasCachedArrayIndex(q))return %_GetCachedArrayIndex(q);
return %StringParseFloat(q);
function GlobalEval(t){
if(!(typeof(t)==='string'))return t;
var u=%GlobalProxy(GlobalEval);
var v=%CompileString(t,false);
if(!(%_IsFunction(v)))return v;
return %_CallFunction(u,v);
var w=2|4|1;
b.InstallConstants(a,[
"NaN",$NaN,
"Infinity",(1/0),
"undefined",(void 0),
b.InstallFunctions(a,2,[
"isNaN",GlobalIsNaN,
"isFinite",GlobalIsFinite,
"parseInt",GlobalParseInt,
"parseFloat",GlobalParseFloat,
"eval",GlobalEval
function ObjectToString(){
if((this===(void 0))&&!(%_IsUndetectableObject(this)))return"[object Undefined]";
if((this===null))return"[object Null]";
var x=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var y=%_ClassOf(x);
var z;
if(harmony_tostring){
z=x[symbolToStringTag];
if(!(typeof(z)==='string')){
z=y;
}else{
z=y;
return`[object ${z}]`;
function ObjectToLocaleString(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Object.prototype.toLocaleString");
return this.toString();
function ObjectValueOf(){
return((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
function ObjectHasOwnProperty(A){
var B=$toName(A);
var C=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
if(%_IsJSProxy(C)){
if((typeof(A)==='symbol'))return false;
var D=%GetHandler(C);
return CallTrap1(D,"hasOwn",l,B);
return %HasOwnProperty(C,B);
function ObjectIsPrototypeOf(E){
if(!(%_IsSpecObject(E)))return false;
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Object.prototype.isPrototypeOf");
return %IsInPrototypeChain(this,E);
function ObjectPropertyIsEnumerable(E){
var F=$toName(E);
if(%_IsJSProxy(this)){
if((typeof(E)==='symbol'))return false;
var G=GetOwnPropertyJS(this,F);
return(G===(void 0))?false:G.isEnumerable();
return %IsPropertyEnumerable(((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this)),F);
function ObjectDefineGetter(B,H){
var I=this;
if(I==null&&!(%_IsUndetectableObject(I))){
I=%GlobalProxy(ObjectDefineGetter);
if(!(%_ClassOf(H)==='Function')){
throw MakeTypeError(60);
var G=new PropertyDescriptor();
G.setGet(H);
G.setEnumerable(true);
G.setConfigurable(true);
DefineOwnProperty(((%_IsSpecObject(%IS_VAR(I)))?I:$toObject(I)),$toName(B),G,false);
function ObjectLookupGetter(B){
var I=this;
if(I==null&&!(%_IsUndetectableObject(I))){
I=%GlobalProxy(ObjectLookupGetter);
return %LookupAccessor(((%_IsSpecObject(%IS_VAR(I)))?I:$toObject(I)),$toName(B),0);
function ObjectDefineSetter(B,H){
var I=this;
if(I==null&&!(%_IsUndetectableObject(I))){
I=%GlobalProxy(ObjectDefineSetter);
if(!(%_ClassOf(H)==='Function')){
throw MakeTypeError(63);
var G=new PropertyDescriptor();
G.setSet(H);
G.setEnumerable(true);
G.setConfigurable(true);
DefineOwnProperty(((%_IsSpecObject(%IS_VAR(I)))?I:$toObject(I)),$toName(B),G,false);
function ObjectLookupSetter(B){
var I=this;
if(I==null&&!(%_IsUndetectableObject(I))){
I=%GlobalProxy(ObjectLookupSetter);
return %LookupAccessor(((%_IsSpecObject(%IS_VAR(I)))?I:$toObject(I)),$toName(B),1);
function ObjectKeys(J){
J=((%_IsSpecObject(%IS_VAR(J)))?J:$toObject(J));
if(%_IsJSProxy(J)){
var D=%GetHandler(J);
var K=CallTrap0(D,"keys",m);
return ToNameArray(K,"keys",false);
return %OwnKeys(J);
function IsAccessorDescriptor(G){
if((G===(void 0)))return false;
return G.hasGetter()||G.hasSetter();
function IsDataDescriptor(G){
if((G===(void 0)))return false;
return G.hasValue()||G.hasWritable();
function IsGenericDescriptor(G){
if((G===(void 0)))return false;
return!(IsAccessorDescriptor(G)||IsDataDescriptor(G));
function IsInconsistentDescriptor(G){
return IsAccessorDescriptor(G)&&IsDataDescriptor(G);
function FromPropertyDescriptor(G){
if((G===(void 0)))return G;
if(IsDataDescriptor(G)){
return{value:G.getValue(),
writable:G.isWritable(),
enumerable:G.isEnumerable(),
configurable:G.isConfigurable()};
return{get:G.getGet(),
set:G.getSet(),
enumerable:G.isEnumerable(),
configurable:G.isConfigurable()};
function FromGenericPropertyDescriptor(G){
if((G===(void 0)))return G;
var J=new h();
if(G.hasValue()){
%AddNamedProperty(J,"value",G.getValue(),0);
if(G.hasWritable()){
%AddNamedProperty(J,"writable",G.isWritable(),0);
if(G.hasGetter()){
%AddNamedProperty(J,"get",G.getGet(),0);
if(G.hasSetter()){
%AddNamedProperty(J,"set",G.getSet(),0);
if(G.hasEnumerable()){
%AddNamedProperty(J,"enumerable",G.isEnumerable(),0);
if(G.hasConfigurable()){
%AddNamedProperty(J,"configurable",G.isConfigurable(),0);
return J;
function ToPropertyDescriptor(J){
if(!(%_IsSpecObject(J)))throw MakeTypeError(77,J);
var G=new PropertyDescriptor();
if("enumerable"in J){
G.setEnumerable($toBoolean(J.enumerable));
if("configurable"in J){
G.setConfigurable($toBoolean(J.configurable));
if("value"in J){
G.setValue(J.value);
if("writable"in J){
G.setWritable($toBoolean(J.writable));
if("get"in J){
var L=J.get;
if(!(L===(void 0))&&!(%_ClassOf(L)==='Function')){
throw MakeTypeError(61,L);
G.setGet(L);
if("set"in J){
var M=J.set;
if(!(M===(void 0))&&!(%_ClassOf(M)==='Function')){
throw MakeTypeError(64,M);
G.setSet(M);
if(IsInconsistentDescriptor(G)){
throw MakeTypeError(114,J);
return G;
function ToCompletePropertyDescriptor(J){
var G=ToPropertyDescriptor(J);
if(IsGenericDescriptor(G)||IsDataDescriptor(G)){
if(!G.hasValue())G.setValue((void 0));
if(!G.hasWritable())G.setWritable(false);
}else{
if(!G.hasGetter())G.setGet((void 0));
if(!G.hasSetter())G.setSet((void 0));
if(!G.hasEnumerable())G.setEnumerable(false);
if(!G.hasConfigurable())G.setConfigurable(false);
return G;
function PropertyDescriptor(){
this.value_=(void 0);
this.hasValue_=false;
this.writable_=false;
this.hasWritable_=false;
this.enumerable_=false;
this.hasEnumerable_=false;
this.configurable_=false;
this.hasConfigurable_=false;
this.get_=(void 0);
this.hasGetter_=false;
this.set_=(void 0);
this.hasSetter_=false;
b.SetUpLockedPrototype(PropertyDescriptor,[
"value_",
"hasValue_",
"writable_",
"hasWritable_",
"enumerable_",
"hasEnumerable_",
"configurable_",
"hasConfigurable_",
"get_",
"hasGetter_",
"set_",
"hasSetter_"
"toString",function PropertyDescriptor_ToString(){
return"[object PropertyDescriptor]";
"setValue",function PropertyDescriptor_SetValue(A){
this.value_=A;
this.hasValue_=true;
"getValue",function PropertyDescriptor_GetValue(){
return this.value_;
"hasValue",function PropertyDescriptor_HasValue(){
return this.hasValue_;
"setEnumerable",function PropertyDescriptor_SetEnumerable(N){
this.enumerable_=N;
this.hasEnumerable_=true;
"isEnumerable",function PropertyDescriptor_IsEnumerable(){
return this.enumerable_;
"hasEnumerable",function PropertyDescriptor_HasEnumerable(){
return this.hasEnumerable_;
"setWritable",function PropertyDescriptor_SetWritable(O){
this.writable_=O;
this.hasWritable_=true;
"isWritable",function PropertyDescriptor_IsWritable(){
return this.writable_;
"hasWritable",function PropertyDescriptor_HasWritable(){
return this.hasWritable_;
"setConfigurable",
function PropertyDescriptor_SetConfigurable(P){
this.configurable_=P;
this.hasConfigurable_=true;
"hasConfigurable",function PropertyDescriptor_HasConfigurable(){
return this.hasConfigurable_;
"isConfigurable",function PropertyDescriptor_IsConfigurable(){
return this.configurable_;
"setGet",function PropertyDescriptor_SetGetter(L){
this.get_=L;
this.hasGetter_=true;
"getGet",function PropertyDescriptor_GetGetter(){
return this.get_;
"hasGetter",function PropertyDescriptor_HasGetter(){
return this.hasGetter_;
"setSet",function PropertyDescriptor_SetSetter(M){
this.set_=M;
this.hasSetter_=true;
"getSet",function PropertyDescriptor_GetSetter(){
return this.set_;
"hasSetter",function PropertyDescriptor_HasSetter(){
return this.hasSetter_;
function ConvertDescriptorArrayToDescriptor(Q){
if((Q===(void 0))){
return(void 0);
var G=new PropertyDescriptor();
if(Q[0]){
G.setGet(Q[2]);
G.setSet(Q[3]);
}else{
G.setValue(Q[1]);
G.setWritable(Q[4]);
G.setEnumerable(Q[5]);
G.setConfigurable(Q[6]);
return G;
function GetTrap(D,B,R){
var S=D[B];
if((S===(void 0))){
if((R===(void 0))){
throw MakeTypeError(84,D,B);
S=R;
}else if(!(%_ClassOf(S)==='Function')){
throw MakeTypeError(85,D,B);
return S;
function CallTrap0(D,B,R){
return %_CallFunction(D,GetTrap(D,B,R));
function CallTrap1(D,B,R,t){
return %_CallFunction(D,t,GetTrap(D,B,R));
function CallTrap2(D,B,R,t,T){
return %_CallFunction(D,t,T,GetTrap(D,B,R));
function GetOwnPropertyJS(J,U){
var V=$toName(U);
if(%_IsJSProxy(J)){
if((typeof(U)==='symbol'))return(void 0);
var D=%GetHandler(J);
var W=CallTrap1(
D,"getOwnPropertyDescriptor",(void 0),V);
if((W===(void 0)))return W;
var G=ToCompletePropertyDescriptor(W);
if(!G.isConfigurable()){
throw MakeTypeError(88,
D,V,"getOwnPropertyDescriptor");
return G;
var X=%GetOwnProperty(((%_IsSpecObject(%IS_VAR(J)))?J:$toObject(J)),V);
return ConvertDescriptorArrayToDescriptor(X);
function Delete(J,V,Y){
var G=GetOwnPropertyJS(J,V);
if((G===(void 0)))return true;
if(G.isConfigurable()){
%DeleteProperty(J,V,0);
return true;
}else if(Y){
throw MakeTypeError(24,V);
}else{
return;
function GetMethod(J,V){
var Z=J[V];
if((Z==null))return(void 0);
if((%_ClassOf(Z)==='Function'))return Z;
throw MakeTypeError(12,typeof Z);
function DefineProxyProperty(J,V,w,Y){
if((typeof(V)==='symbol'))return false;
var D=%GetHandler(J);
var aa=CallTrap2(D,"defineProperty",(void 0),V,w);
if(!$toBoolean(aa)){
if(Y){
throw MakeTypeError(83,
D,"false","defineProperty");
}else{
return false;
return true;
function DefineObjectProperty(J,V,G,Y){
var ab=%GetOwnProperty(J,$toName(V));
var ac=ConvertDescriptorArrayToDescriptor(ab);
var ad=%IsExtensible(J);
if((ac===(void 0))&&!ad){
if(Y){
throw MakeTypeError(24,V);
}else{
return false;
if(!(ac===(void 0))){
if((IsGenericDescriptor(G)||
IsDataDescriptor(G)==IsDataDescriptor(ac))&&
(!G.hasEnumerable()||
$sameValue(G.isEnumerable(),ac.isEnumerable()))&&
(!G.hasConfigurable()||
$sameValue(G.isConfigurable(),ac.isConfigurable()))&&
(!G.hasWritable()||
$sameValue(G.isWritable(),ac.isWritable()))&&
(!G.hasValue()||
$sameValue(G.getValue(),ac.getValue()))&&
(!G.hasGetter()||
$sameValue(G.getGet(),ac.getGet()))&&
(!G.hasSetter()||
$sameValue(G.getSet(),ac.getSet()))){
return true;
if(!ac.isConfigurable()){
if(G.isConfigurable()||
(G.hasEnumerable()&&
G.isEnumerable()!=ac.isEnumerable())){
if(Y){
throw MakeTypeError(91,V);
}else{
return false;
if(!IsGenericDescriptor(G)){
if(IsDataDescriptor(ac)!=IsDataDescriptor(G)){
if(Y){
throw MakeTypeError(91,V);
}else{
return false;
if(IsDataDescriptor(ac)&&IsDataDescriptor(G)){
var ae=ac.isWritable();
if(ae!=G.isWritable()){
if(!ae||(%IsStrong(J))){
if(Y){
throw ae
?MakeTypeError(107,J,V)
:MakeTypeError(91,V);
}else{
return false;
if(!ae&&G.hasValue()&&
!$sameValue(G.getValue(),ac.getValue())){
if(Y){
throw MakeTypeError(91,V);
}else{
return false;
if(IsAccessorDescriptor(G)&&IsAccessorDescriptor(ac)){
if(G.hasSetter()&&
!$sameValue(G.getSet(),ac.getSet())){
if(Y){
throw MakeTypeError(91,V);
}else{
return false;
if(G.hasGetter()&&!$sameValue(G.getGet(),ac.getGet())){
if(Y){
throw MakeTypeError(91,V);
}else{
return false;
var af=0;
if(G.hasEnumerable()){
af|=G.isEnumerable()?0:2;
}else if(!(ac===(void 0))){
af|=ac.isEnumerable()?0:2;
}else{
af|=2;
if(G.hasConfigurable()){
af|=G.isConfigurable()?0:4;
}else if(!(ac===(void 0))){
af|=ac.isConfigurable()?0:4;
}else
af|=4;
if(IsDataDescriptor(G)||
(IsGenericDescriptor(G)&&
((ac===(void 0))||IsDataDescriptor(ac)))){
if(G.hasWritable()){
af|=G.isWritable()?0:1;
}else if(!(ac===(void 0))){
af|=ac.isWritable()?0:1;
}else{
af|=1;
var A=(void 0);
if(G.hasValue()){
A=G.getValue();
}else if(!(ac===(void 0))&&IsDataDescriptor(ac)){
A=ac.getValue();
%DefineDataPropertyUnchecked(J,V,A,af);
}else{
var ag=null;
if(G.hasGetter()){
ag=G.getGet();
}else if(IsAccessorDescriptor(ac)&&ac.hasGetter()){
ag=ac.getGet();
var ah=null;
if(G.hasSetter()){
ah=G.getSet();
}else if(IsAccessorDescriptor(ac)&&ac.hasSetter()){
ah=ac.getSet();
%DefineAccessorPropertyUnchecked(J,V,ag,ah,af);
return true;
function DefineArrayProperty(J,V,G,Y){
if(!(typeof(V)==='symbol')){
var ai=$toUint32(V);
var aj=false;
if($toString(ai)==V&&ai!=4294967295){
var ak=J.length;
if(ai>=ak&&%IsObserved(J)){
aj=true;
$observeBeginPerformSplice(J);
var al=GetOwnPropertyJS(J,"length");
if((ai>=ak&&!al.isWritable())||
!DefineObjectProperty(J,V,G,true)){
if(aj)
$observeEndPerformSplice(J);
if(Y){
throw MakeTypeError(24,V);
}else{
return false;
if(ai>=ak){
J.length=ai+1;
if(aj){
$observeEndPerformSplice(J);
$observeEnqueueSpliceRecord(J,ak,[],ai+1-ak);
return true;
return DefineObjectProperty(J,V,G,Y);
function DefineOwnProperty(J,V,G,Y){
if(%_IsJSProxy(J)){
if((typeof(V)==='symbol'))return false;
var w=FromGenericPropertyDescriptor(G);
return DefineProxyProperty(J,V,w,Y);
}else if((%_IsArray(J))){
return DefineArrayProperty(J,V,G,Y);
}else{
return DefineObjectProperty(J,V,G,Y);
function DefineOwnPropertyFromAPI(J,V,A,G){
return DefineOwnProperty(J,V,ToPropertyDescriptor({
value:A,
writable:G[0],
enumerable:G[1],
configurable:G[2]
false);
function ObjectGetPrototypeOf(J){
return %_GetPrototype(((%_IsSpecObject(%IS_VAR(J)))?J:$toObject(J)));
function ObjectSetPrototypeOf(J,am){
if((J==null)&&!(%_IsUndetectableObject(J)))throw MakeTypeError(14,"Object.setPrototypeOf");
if(am!==null&&!(%_IsSpecObject(am))){
throw MakeTypeError(79,am);
if((%_IsSpecObject(J))){
%SetPrototype(J,am);
return J;
function ObjectGetOwnPropertyDescriptor(J,V){
var G=GetOwnPropertyJS(((%_IsSpecObject(%IS_VAR(J)))?J:$toObject(J)),V);
return FromPropertyDescriptor(G);
function ToNameArray(J,S,an){
if(!(%_IsSpecObject(J))){
throw MakeTypeError(86,S,J);
var ao=$toUint32(J.length);
var ap=new c(ao);
var aq=0;
var K={__proto__:null};
for(var ai=0;ai<ao;ai++){
var ar=$toName(J[ai]);
if((typeof(ar)==='symbol')&&!an)continue;
if(%HasOwnProperty(K,ar)){
throw MakeTypeError(89,S,ar);
ap[aq]=ar;
++aq;
K[ar]=0;
ap.length=aq;
return ap;
function ObjectGetOwnPropertyKeys(J,as){
var at=new i();
as|=32;
var au=%GetInterceptorInfo(J);
if((as&8)===0){
var av=%GetOwnElementNames(J);
for(var aw=0;aw<av.length;++aw){
av[aw]=%_NumberToString(av[aw]);
at.push(av);
if((au&1)!=0){
var ax=%GetIndexedInterceptorElementNames(J);
if(!(ax===(void 0))){
at.push(ax);
at.push(%GetOwnPropertyNames(J,as));
if((au&2)!=0){
var ay=
%GetNamedInterceptorPropertyNames(J);
if(!(ay===(void 0))){
at.push(ay);
var az=
%Apply(i.prototype.concat,
at[0],at,1,at.length-1);
if(au!=0){
var aA={__proto__:null};
var aB=0;
for(var aw=0;aw<az.length;++aw){
var B=az[aw];
if((typeof(B)==='symbol')){
if((as&16)||(%SymbolIsPrivate(B))){
continue;
}else{
if(as&8)continue;
B=$toString(B);
if(aA[B])continue;
aA[B]=true;
az[aB++]=B;
az.length=aB;
return az;
function OwnPropertyKeys(J){
if(%_IsJSProxy(J)){
var D=%GetHandler(J);
var K=CallTrap0(D,"ownKeys",(void 0));
return ToNameArray(K,"getOwnPropertyNames",false);
return ObjectGetOwnPropertyKeys(J,32);
function ObjectGetOwnPropertyNames(J){
J=((%_IsSpecObject(%IS_VAR(J)))?J:$toObject(J));
if(%_IsJSProxy(J)){
var D=%GetHandler(J);
var K=CallTrap0(D,"getOwnPropertyNames",(void 0));
return ToNameArray(K,"getOwnPropertyNames",false);
return ObjectGetOwnPropertyKeys(J,16);
function ObjectCreate(am,aC){
if(!(%_IsSpecObject(am))&&am!==null){
throw MakeTypeError(79,am);
var J={};
%InternalSetPrototype(J,am);
if(!(aC===(void 0)))ObjectDefineProperties(J,aC);
return J;
function ObjectDefineProperty(J,V,w){
if(!(%_IsSpecObject(J))){
throw MakeTypeError(13,"Object.defineProperty");
var B=$toName(V);
if(%_IsJSProxy(J)){
var aD={__proto__:null};
for(var aE in w){
aD[aE]=w[aE];
DefineProxyProperty(J,B,aD,true);
}else{
var G=ToPropertyDescriptor(w);
DefineOwnProperty(J,B,G,true);
return J;
function GetOwnEnumerablePropertyNames(C){
var K=new i();
for(var aF in C){
if(%HasOwnProperty(C,aF)){
K.push(aF);
var as=8|32;
var aG=%GetOwnPropertyNames(C,as);
for(var aw=0;aw<aG.length;++aw){
var aH=aG[aw];
if((typeof(aH)==='symbol')){
var G=ObjectGetOwnPropertyDescriptor(C,aH);
if(G.enumerable)K.push(aH);
return K;
function ObjectDefineProperties(J,aC){
if(!(%_IsSpecObject(J))){
throw MakeTypeError(13,"Object.defineProperties");
var X=((%_IsSpecObject(%IS_VAR(aC)))?aC:$toObject(aC));
var K=GetOwnEnumerablePropertyNames(X);
var aI=new i();
for(var aw=0;aw<K.length;aw++){
aI.push(ToPropertyDescriptor(X[K[aw]]));
for(var aw=0;aw<K.length;aw++){
DefineOwnProperty(J,K[aw],aI[aw],true);
return J;
function ProxyFix(J){
var D=%GetHandler(J);
var X=CallTrap0(D,"fix",(void 0));
if((X===(void 0))){
throw MakeTypeError(83,D,"undefined","fix");
if(%IsJSFunctionProxy(J)){
var aJ=%GetCallTrap(J);
var aK=%GetConstructTrap(J);
var aL=k(aJ,aK);
%Fix(J);
%SetCode(J,aL);
var aM=new h();
ObjectDefineProperty(aM,"constructor",
{value:J,writable:true,enumerable:false,configurable:true});
%FunctionSetPrototype(J,aM);
J.length=0;
}else{
%Fix(J);
ObjectDefineProperties(J,X);
function ObjectSealJS(J){
if(!(%_IsSpecObject(J)))return J;
var aN=%_IsJSProxy(J);
if(aN||%HasSloppyArgumentsElements(J)||%IsObserved(J)){
if(aN){
ProxyFix(J);
var K=ObjectGetOwnPropertyNames(J);
for(var aw=0;aw<K.length;aw++){
var B=K[aw];
var G=GetOwnPropertyJS(J,B);
if(G.isConfigurable()){
G.setConfigurable(false);
DefineOwnProperty(J,B,G,true);
%PreventExtensions(J);
}else{
%ObjectSeal(J);
return J;
function ObjectFreezeJS(J){
if(!(%_IsSpecObject(J)))return J;
var aN=%_IsJSProxy(J);
if(aN||%HasSloppyArgumentsElements(J)||%IsObserved(J)||
(%IsStrong(J))){
if(aN){
ProxyFix(J);
var K=ObjectGetOwnPropertyNames(J);
for(var aw=0;aw<K.length;aw++){
var B=K[aw];
var G=GetOwnPropertyJS(J,B);
if(G.isWritable()||G.isConfigurable()){
if(IsDataDescriptor(G))G.setWritable(false);
G.setConfigurable(false);
DefineOwnProperty(J,B,G,true);
%PreventExtensions(J);
}else{
%ObjectFreeze(J);
return J;
function ObjectPreventExtension(J){
if(!(%_IsSpecObject(J)))return J;
if(%_IsJSProxy(J)){
ProxyFix(J);
%PreventExtensions(J);
return J;
function ObjectIsSealed(J){
if(!(%_IsSpecObject(J)))return true;
if(%_IsJSProxy(J)){
return false;
if(%IsExtensible(J)){
return false;
var K=ObjectGetOwnPropertyNames(J);
for(var aw=0;aw<K.length;aw++){
var B=K[aw];
var G=GetOwnPropertyJS(J,B);
if(G.isConfigurable()){
return false;
return true;
function ObjectIsFrozen(J){
if(!(%_IsSpecObject(J)))return true;
if(%_IsJSProxy(J)){
return false;
if(%IsExtensible(J)){
return false;
var K=ObjectGetOwnPropertyNames(J);
for(var aw=0;aw<K.length;aw++){
var B=K[aw];
var G=GetOwnPropertyJS(J,B);
if(IsDataDescriptor(G)&&G.isWritable())return false;
if(G.isConfigurable())return false;
return true;
function ObjectIsExtensible(J){
if(!(%_IsSpecObject(J)))return false;
if(%_IsJSProxy(J)){
return true;
return %IsExtensible(J);
function ObjectIs(aO,aP){
return $sameValue(aO,aP);
function ObjectGetProto(){
return %_GetPrototype(((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this)));
function ObjectSetProto(am){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Object.prototype.__proto__");
if(((%_IsSpecObject(am))||(am===null))&&(%_IsSpecObject(this))){
%SetPrototype(this,am);
function ObjectConstructor(t){
if(%_IsConstructCall()){
if(t==null)return this;
return((%_IsSpecObject(%IS_VAR(t)))?t:$toObject(t));
}else{
if(t==null)return{};
return((%_IsSpecObject(%IS_VAR(t)))?t:$toObject(t));
%SetNativeFlag(h);
%SetCode(h,ObjectConstructor);
%AddNamedProperty(h.prototype,"constructor",h,
b.InstallFunctions(h.prototype,2,[
"toString",ObjectToString,
"toLocaleString",ObjectToLocaleString,
"valueOf",ObjectValueOf,
"hasOwnProperty",ObjectHasOwnProperty,
"isPrototypeOf",ObjectIsPrototypeOf,
"propertyIsEnumerable",ObjectPropertyIsEnumerable,
"__defineGetter__",ObjectDefineGetter,
"__lookupGetter__",ObjectLookupGetter,
"__defineSetter__",ObjectDefineSetter,
"__lookupSetter__",ObjectLookupSetter
b.InstallGetterSetter(h.prototype,"__proto__",ObjectGetProto,
ObjectSetProto);
b.InstallFunctions(h,2,[
"keys",ObjectKeys,
"create",ObjectCreate,
"defineProperty",ObjectDefineProperty,
"defineProperties",ObjectDefineProperties,
"freeze",ObjectFreezeJS,
"getPrototypeOf",ObjectGetPrototypeOf,
"setPrototypeOf",ObjectSetPrototypeOf,
"getOwnPropertyDescriptor",ObjectGetOwnPropertyDescriptor,
"getOwnPropertyNames",ObjectGetOwnPropertyNames,
"is",ObjectIs,
"isExtensible",ObjectIsExtensible,
"isFrozen",ObjectIsFrozen,
"isSealed",ObjectIsSealed,
"preventExtensions",ObjectPreventExtension,
"seal",ObjectSealJS
function BooleanConstructor(t){
if(%_IsConstructCall()){
%_SetValueOf(this,$toBoolean(t));
}else{
return $toBoolean(t);
function BooleanToString(){
var aQ=this;
if(!(typeof(aQ)==='boolean')){
if(!(%_ClassOf(aQ)==='Boolean')){
throw MakeTypeError(55,'Boolean.prototype.toString');
aQ=%_ValueOf(aQ);
return aQ?'true':'false';
function BooleanValueOf(){
if(!(typeof(this)==='boolean')&&!(%_ClassOf(this)==='Boolean')){
throw MakeTypeError(55,'Boolean.prototype.valueOf');
return %_ValueOf(this);
%SetCode(d,BooleanConstructor);
%FunctionSetPrototype(d,new d(false));
%AddNamedProperty(d.prototype,"constructor",d,
b.InstallFunctions(d.prototype,2,[
"toString",BooleanToString,
"valueOf",BooleanValueOf
function NumberConstructor(t){
var A=%_ArgumentsLength()==0?0:$toNumber(t);
if(%_IsConstructCall()){
%_SetValueOf(this,A);
}else{
return A;
function NumberToStringJS(r){
var p=this;
if(!(typeof(this)==='number')){
if(!(%_ClassOf(this)==='Number')){
throw MakeTypeError(55,'Number.prototype.toString');
p=%_ValueOf(this);
if((r===(void 0))||r===10){
return %_NumberToString(p);
r=(%_IsSmi(%IS_VAR(r))?r:%NumberToInteger($toNumber(r)));
if(r<2||r>36)throw MakeRangeError(147);
return %NumberToRadixString(p,r);
function NumberToLocaleString(){
return %_CallFunction(this,NumberToStringJS);
function NumberValueOf(){
if(!(typeof(this)==='number')&&!(%_ClassOf(this)==='Number')){
throw MakeTypeError(55,'Number.prototype.valueOf');
return %_ValueOf(this);
function NumberToFixedJS(aR){
var t=this;
if(!(typeof(this)==='number')){
if(!(%_ClassOf(this)==='Number')){
throw MakeTypeError(33,
"Number.prototype.toFixed",this);
t=%_ValueOf(this);
var v=(%_IsSmi(%IS_VAR(aR))?aR:%NumberToInteger($toNumber(aR)));
if(v<0||v>20){
throw MakeRangeError(143,"toFixed() digits");
if((!%_IsSmi(%IS_VAR(t))&&!(t==t)))return"NaN";
if(t==(1/0))return"Infinity";
if(t==-(1/0))return"-Infinity";
return %NumberToFixed(t,v);
function NumberToExponentialJS(aR){
var t=this;
if(!(typeof(this)==='number')){
if(!(%_ClassOf(this)==='Number')){
throw MakeTypeError(33,
"Number.prototype.toExponential",this);
t=%_ValueOf(this);
var v=(aR===(void 0))?(void 0):(%_IsSmi(%IS_VAR(aR))?aR:%NumberToInteger($toNumber(aR)));
if((!%_IsSmi(%IS_VAR(t))&&!(t==t)))return"NaN";
if(t==(1/0))return"Infinity";
if(t==-(1/0))return"-Infinity";
if((v===(void 0))){
v=-1;
}else if(v<0||v>20){
throw MakeRangeError(143,"toExponential()");
return %NumberToExponential(t,v);
function NumberToPrecisionJS(aS){
var t=this;
if(!(typeof(this)==='number')){
if(!(%_ClassOf(this)==='Number')){
throw MakeTypeError(33,
"Number.prototype.toPrecision",this);
t=%_ValueOf(this);
if((aS===(void 0)))return $toString(%_ValueOf(this));
var V=(%_IsSmi(%IS_VAR(aS))?aS:%NumberToInteger($toNumber(aS)));
if((!%_IsSmi(%IS_VAR(t))&&!(t==t)))return"NaN";
if(t==(1/0))return"Infinity";
if(t==-(1/0))return"-Infinity";
if(V<1||V>21){
throw MakeRangeError(146);
return %NumberToPrecision(t,V);
function NumberIsFinite(p){
return(typeof(p)==='number')&&(%_IsSmi(%IS_VAR(p))||((p==p)&&(p!=1/0)&&(p!=-1/0)));
function NumberIsInteger(p){
return NumberIsFinite(p)&&(%_IsSmi(%IS_VAR(p))?p:%NumberToInteger($toNumber(p)))==p;
function NumberIsNaN(p){
return(typeof(p)==='number')&&(!%_IsSmi(%IS_VAR(p))&&!(p==p));
function NumberIsSafeInteger(p){
if(NumberIsFinite(p)){
var aT=(%_IsSmi(%IS_VAR(p))?p:%NumberToInteger($toNumber(p)));
if(aT==p){
return j(aT)<=g.MAX_SAFE_INTEGER;
return false;
%SetCode(g,NumberConstructor);
%FunctionSetPrototype(g,new g(0));
%OptimizeObjectForAddingMultipleProperties(g.prototype,8);
%AddNamedProperty(g.prototype,"constructor",g,
b.InstallConstants(g,[
"MAX_VALUE",1.7976931348623157e+308,
"MIN_VALUE",5e-324,
"NaN",$NaN,
"NEGATIVE_INFINITY",-(1/0),
"POSITIVE_INFINITY",(1/0),
"MAX_SAFE_INTEGER",%_MathPow(2,53)-1,
"MIN_SAFE_INTEGER",-%_MathPow(2,53)+1,
"EPSILON",%_MathPow(2,-52)
b.InstallFunctions(g.prototype,2,[
"toString",NumberToStringJS,
"toLocaleString",NumberToLocaleString,
"valueOf",NumberValueOf,
"toFixed",NumberToFixedJS,
"toExponential",NumberToExponentialJS,
"toPrecision",NumberToPrecisionJS
b.InstallFunctions(g,2,[
"isFinite",NumberIsFinite,
"isInteger",NumberIsInteger,
"isNaN",NumberIsNaN,
"isSafeInteger",NumberIsSafeInteger,
"parseInt",GlobalParseInt,
"parseFloat",GlobalParseFloat
%SetForceInlineFlag(NumberIsNaN);
function NativeCodeFunctionSourceString(Z){
var B=%FunctionGetName(Z);
if(B){
return'function '+B+'() { [native code] }';
return'function () { [native code] }';
function FunctionSourceString(Z){
while(%IsJSFunctionProxy(Z)){
Z=%GetCallTrap(Z);
if(!(%_IsFunction(Z))){
throw MakeTypeError(55,'Function.prototype.toString');
if(%FunctionIsBuiltin(Z)){
return NativeCodeFunctionSourceString(Z);
var aU=%ClassGetSourceCode(Z);
if((typeof(aU)==='string')){
return aU;
var aV=%FunctionGetSourceCode(Z);
if(!(typeof(aV)==='string')){
return NativeCodeFunctionSourceString(Z);
if(%FunctionIsArrow(Z)){
return aV;
var B=%FunctionNameShouldPrintAsAnonymous(Z)
?'anonymous'
:%FunctionGetName(Z);
var aW=%FunctionIsGenerator(Z);
var aX=%FunctionIsConciseMethod(Z)
?(aW?'*':'')
:(aW?'function* ':'function ');
return aX+B+aV;
function FunctionToString(){
return FunctionSourceString(this);
function FunctionBind(aY){
if(!(%_ClassOf(this)==='Function'))throw MakeTypeError(30);
var aZ=function(){
"use strict";
if(%_IsConstructCall()){
return %NewObjectFromBound(aZ);
var ba=%BoundFunctionGetBindings(aZ);
var bb=%_ArgumentsLength();
if(bb==0){
return %Apply(ba[0],ba[1],ba,2,ba.length-2);
if(ba.length===2){
return %Apply(ba[0],ba[1],arguments,0,bb);
var bc=ba.length-2;
var bd=new i(bc+bb);
for(var aw=0;aw<bc;aw++){
bd[aw]=ba[aw+2];
for(var aB=0;aB<bb;aB++){
bd[aw++]=%_Arguments(aB);
return %Apply(ba[0],ba[1],bd,0,bc+bb);
var be=0;
var bf=this.length;
if((typeof bf==="number")&&
((bf>>>0)===bf)){
var bb=%_ArgumentsLength();
if(bb>0)bb--;
be=bf-bb;
if(be<0)be=0;
var aa=%FunctionBindArguments(aZ,this,
aY,be);
var B=this.name;
var bg=(typeof(B)==='string')?B:"";
%DefineDataPropertyUnchecked(aa,"name","bound "+bg,
2|1);
return aa;
function NewFunctionString(bh,bi){
var ao=bh.length;
var V='';
if(ao>1){
V=$toString(bh[0]);
for(var aw=1;aw<ao-1;aw++){
V+=','+$toString(bh[aw]);
if(%_CallFunction(V,')',n)!=-1){
throw MakeSyntaxError(185);
V+='\n/'+'**/';
var bj=(ao>0)?$toString(bh[ao-1]):'';
return'('+bi+'('+V+') {\n'+bj+'\n})';
function FunctionConstructor(bk){
var aV=NewFunctionString(arguments,'function');
var u=%GlobalProxy(FunctionConstructor);
var v=%_CallFunction(u,%CompileString(aV,true));
%FunctionMarkNameShouldPrintAsAnonymous(v);
return v;
%SetCode(e,FunctionConstructor);
%AddNamedProperty(e.prototype,"constructor",e,
b.InstallFunctions(e.prototype,2,[
"bind",FunctionBind,
"toString",FunctionToString
function GetIterator(J,bl){
if((bl===(void 0))){
bl=J[symbolIterator];
if(!(%_ClassOf(bl)==='Function')){
throw MakeTypeError(56,J);
var bm=%_CallFunction(J,bl);
if(!(%_IsSpecObject(bm))){
throw MakeTypeError(50,bm);
return bm;
$functionSourceString=FunctionSourceString;
$globalEval=GlobalEval;
$objectDefineOwnProperty=DefineOwnPropertyFromAPI;
$objectGetOwnPropertyDescriptor=ObjectGetOwnPropertyDescriptor;
$toCompletePropertyDescriptor=ToCompletePropertyDescriptor;
b.ObjectDefineProperties=ObjectDefineProperties;
b.ObjectDefineProperty=ObjectDefineProperty;
b.Export(function(bn){
bn.Delete=Delete;
bn.GetIterator=GetIterator;
bn.GetMethod=GetMethod;
bn.IsFinite=GlobalIsFinite;
bn.IsNaN=GlobalIsNaN;
bn.NewFunctionString=NewFunctionString;
bn.NumberIsNaN=NumberIsNaN;
bn.ObjectDefineProperty=ObjectDefineProperty;
bn.ObjectFreeze=ObjectFreezeJS;
bn.ObjectGetOwnPropertyKeys=ObjectGetOwnPropertyKeys;
bn.ObjectHasOwnProperty=ObjectHasOwnProperty;
bn.ObjectIsFrozen=ObjectIsFrozen;
bn.ObjectIsSealed=ObjectIsSealed;
bn.ObjectToString=ObjectToString;
bn.OwnPropertyKeys=OwnPropertyKeys;
bn.ToNameArray=ToNameArray;
var $symbolToString;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Object;
var d=a.Symbol;
var e;
b.Import(function(g){
e=g.ObjectGetOwnPropertyKeys;
function SymbolConstructor(h){
if(%_IsConstructCall())throw MakeTypeError(52,"Symbol");
return %CreateSymbol((h===(void 0))?h:$toString(h));
function SymbolToString(){
if(!((typeof(this)==='symbol')||(%_ClassOf(this)==='Symbol'))){
throw MakeTypeError(33,
"Symbol.prototype.toString",this);
var i=%SymbolDescription(%_ValueOf(this));
return"Symbol("+((i===(void 0))?"":i)+")";
function SymbolValueOf(){
if(!((typeof(this)==='symbol')||(%_ClassOf(this)==='Symbol'))){
throw MakeTypeError(33,
"Symbol.prototype.valueOf",this);
return %_ValueOf(this);
function SymbolFor(j){
j=((typeof(%IS_VAR(j))==='string')?j:$nonStringToString(j));
var k=%SymbolRegistry();
if((k.for[j]===(void 0))){
var l=%CreateSymbol(j);
k.for[j]=l;
k.keyFor[l]=j;
return k.for[j];
function SymbolKeyFor(l){
if(!(typeof(l)==='symbol'))throw MakeTypeError(109,l);
return %SymbolRegistry().keyFor[l];
function ObjectGetOwnPropertySymbols(m){
m=$toObject(m);
return e(m,8);
%SetCode(d,SymbolConstructor);
%FunctionSetPrototype(d,new c());
b.InstallConstants(d,[
"iterator",symbolIterator,
"unscopables",symbolUnscopables
b.InstallFunctions(d,2,[
"for",SymbolFor,
"keyFor",SymbolKeyFor
%AddNamedProperty(
d.prototype,"constructor",d,2);
%AddNamedProperty(
d.prototype,symbolToStringTag,"Symbol",2|1);
b.InstallFunctions(d.prototype,2,[
"toString",SymbolToString,
"valueOf",SymbolValueOf
b.InstallFunctions(c,2,[
"getOwnPropertySymbols",ObjectGetOwnPropertySymbols
$symbolToString=SymbolToString;
var $arrayConcat;
var $arrayPush;
var $arrayPop;
var $arrayShift;
var $arraySlice;
var $arraySplice;
var $arrayUnshift;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Array;
var d=b.InternalArray;
var e=b.InternalPackedArray;
var g;
var h;
var i;
var j;
var k;
var l;
b.Import(function(m){
g=m.Delete;
h=m.MathMin;
i=m.ObjectHasOwnProperty;
j=m.ObjectIsFrozen;
k=m.ObjectIsSealed;
l=m.ObjectToString;
var n=new d();
function GetSortedArrayKeys(o,p){
var q=new d();
if((typeof(p)==='number')){
var r=p;
for(var t=0;t<r;++t){
var u=o[t];
if(!(u===(void 0))||t in o){
q.push(t);
}else{
var v=p.length;
for(var w=0;w<v;++w){
var x=p[w];
if(!(x===(void 0))){
var u=o[x];
if(!(u===(void 0))||x in o){
q.push(x);
%_CallFunction(q,function(y,z){return y-z;},ArraySort);
return q;
function SparseJoinWithSeparatorJS(o,A,B,C){
var q=GetSortedArrayKeys(o,%GetArrayKeys(o,A));
var D=0;
var E=new d(q.length*2);
var F=-1;
for(var t=0;t<q.length;t++){
var x=q[t];
if(x!=F){
var u=o[x];
if(!(typeof(u)==='string'))u=B(u);
E[t*2]=x;
E[t*2+1]=u;
F=x;
return %SparseJoinWithSeparator(E,A,C);
function SparseJoin(o,A,B){
var q=GetSortedArrayKeys(o,%GetArrayKeys(o,A));
var G=-1;
var H=q.length;
var E=new d(H);
var I=0;
for(var t=0;t<H;t++){
var x=q[t];
if(x!=G){
var u=o[x];
if(!(typeof(u)==='string'))u=B(u);
E[I++]=u;
G=x;
return %StringBuilderConcat(E,I,'');
function UseSparseVariant(o,v,J,K){
if(!J||v<1000||%IsObserved(o)||
%HasComplexElements(o)){
return false;
if(!%_IsSmi(v)){
return true;
var L=v>>2;
var M=%EstimateNumberOfElements(o);
return(M<L)&&
(K>M*4);
function Join(o,v,C,B){
if(v==0)return'';
var J=(%_IsArray(o));
if(J){
if(!%PushIfAbsent(n,o))return'';
try{
if(UseSparseVariant(o,v,J,v)){
%NormalizeElements(o);
if(C.length==0){
return SparseJoin(o,v,B);
}else{
return SparseJoinWithSeparatorJS(o,v,B,C);
if(v==1){
var u=o[0];
if((typeof(u)==='string'))return u;
return B(u);
var E=new d(v);
if(C.length==0){
var I=0;
for(var t=0;t<v;t++){
var u=o[t];
if(!(typeof(u)==='string'))u=B(u);
E[I++]=u;
E.length=I;
var N=%_FastOneByteArrayJoin(E,'');
if(!(N===(void 0)))return N;
return %StringBuilderConcat(E,I,'');
if(!(typeof(o[0])==='number')){
for(var t=0;t<v;t++){
var u=o[t];
if(!(typeof(u)==='string'))u=B(u);
E[t]=u;
}else{
for(var t=0;t<v;t++){
var u=o[t];
if((typeof(u)==='number')){
u=%_NumberToString(u);
}else if(!(typeof(u)==='string')){
u=B(u);
E[t]=u;
var N=%_FastOneByteArrayJoin(E,C);
if(!(N===(void 0)))return N;
return %StringBuilderJoin(E,v,C);
}finally{
if(J)n.length=n.length-1;
function ConvertToString(O){
if((typeof(O)==='number'))return %_NumberToString(O);
if((typeof(O)==='boolean'))return O?'true':'false';
return((O==null))?'':$toString($defaultString(O));
function ConvertToLocaleString(u){
if((u==null)){
return'';
}else{
var P=$toObject(u);
return $toString(P.toLocaleString());
function SparseSlice(o,Q,R,A,S){
var p=%GetArrayKeys(o,Q+R);
if((typeof(p)==='number')){
var r=p;
for(var t=Q;t<r;++t){
var T=o[t];
if(!(T===(void 0))||t in o){
%AddElement(S,t-Q,T);
}else{
var v=p.length;
for(var w=0;w<v;++w){
var x=p[w];
if(!(x===(void 0))){
if(x>=Q){
var T=o[x];
if(!(T===(void 0))||x in o){
%AddElement(S,x-Q,T);
function SparseMove(o,Q,R,A,U){
if(U===R)return;
var V=new d(
h(A-R+U,0xffffffff));
var W;
var p=%GetArrayKeys(o,A);
if((typeof(p)==='number')){
var r=p;
for(var t=0;t<Q&&t<r;++t){
var T=o[t];
if(!(T===(void 0))||t in o){
V[t]=T;
for(var t=Q+R;t<r;++t){
var T=o[t];
if(!(T===(void 0))||t in o){
V[t-R+U]=T;
}else{
var v=p.length;
for(var w=0;w<v;++w){
var x=p[w];
if(!(x===(void 0))){
if(x<Q){
var T=o[x];
if(!(T===(void 0))||x in o){
V[x]=T;
}else if(x>=Q+R){
var T=o[x];
if(!(T===(void 0))||x in o){
var X=x-R+U;
V[X]=T;
if(X>0xfffffffe){
W=W||new d();
W.push(X);
%MoveArrayContents(V,o);
if(!(W===(void 0))){
var v=W.length;
for(var t=0;t<v;++t){
var x=W[t];
o[x]=V[x];
function SimpleSlice(o,Q,R,A,S){
var J=(%_IsArray(o));
for(var t=0;t<R;t++){
var Y=Q+t;
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(Y<o.length):(Y in o))){
var T=o[Y];
%AddElement(S,t,T);
function SimpleMove(o,Q,R,A,U){
var J=(%_IsArray(o));
if(U!==R){
if(U>R){
for(var t=A-R;t>Q;t--){
var Z=t+R-1;
var aa=t+U-1;
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(Z<o.length):(Z in o))){
o[aa]=o[Z];
}else{
delete o[aa];
}else{
for(var t=Q;t<A-R;t++){
var Z=t+R;
var aa=t+U;
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(Z<o.length):(Z in o))){
o[aa]=o[Z];
}else{
delete o[aa];
for(var t=A;t>A-R+U;t--){
delete o[t-1];
function ArrayToString(){
var o;
var ab;
if((%_IsArray(this))){
ab=this.join;
if(ab===ArrayJoin){
return Join(this,this.length,',',ConvertToString);
o=this;
}else{
o=$toObject(this);
ab=o.join;
if(!(%_ClassOf(ab)==='Function')){
return %_CallFunction(o,l);
return %_CallFunction(o,ab);
function InnerArrayToLocaleString(o,v){
var A=(v>>>0);
if(A===0)return"";
return Join(o,A,',',ConvertToLocaleString);
function ArrayToLocaleString(){
var o=$toObject(this);
var ac=o.length;
return InnerArrayToLocaleString(o,ac);
function InnerArrayJoin(C,o,v){
if((C===(void 0))){
C=',';
}else if(!(typeof(C)==='string')){
C=$nonStringToString(C);
var N=%_FastOneByteArrayJoin(o,C);
if(!(N===(void 0)))return N;
if(v===1){
var u=o[0];
if((typeof(u)==='string'))return u;
if((u==null))return'';
return $nonStringToString(u);
return Join(o,v,C,ConvertToString);
function ArrayJoin(C){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.join");
var o=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var v=(o.length>>>0);
return InnerArrayJoin(C,o,v);
function ObservedArrayPop(ad){
ad--;
var ae=this[ad];
try{
$observeBeginPerformSplice(this);
delete this[ad];
this.length=ad;
}finally{
$observeEndPerformSplice(this);
$observeEnqueueSpliceRecord(this,ad,[ae],0);
return ae;
function ArrayPop(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.pop");
var o=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var ad=(o.length>>>0);
if(ad==0){
o.length=ad;
return;
if(%IsObserved(o))
return ObservedArrayPop.call(o,ad);
ad--;
var ae=o[ad];
g(o,ad,true);
o.length=ad;
return ae;
function ObservedArrayPush(){
var ad=(this.length>>>0);
var af=%_ArgumentsLength();
try{
$observeBeginPerformSplice(this);
for(var t=0;t<af;t++){
this[t+ad]=%_Arguments(t);
var ag=ad+af;
this.length=ag;
}finally{
$observeEndPerformSplice(this);
$observeEnqueueSpliceRecord(this,ad,[],af);
return ag;
function ArrayPush(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.push");
if(%IsObserved(this))
return ObservedArrayPush.apply(this,arguments);
var o=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var ad=(o.length>>>0);
var af=%_ArgumentsLength();
for(var t=0;t<af;t++){
o[t+ad]=%_Arguments(t);
var ag=ad+af;
o.length=ag;
return ag;
function ArrayConcatJS(ah){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.concat");
var o=$toObject(this);
var ai=%_ArgumentsLength();
var aj=new d(1+ai);
aj[0]=o;
for(var t=0;t<ai;t++){
aj[t+1]=%_Arguments(t);
return %ArrayConcat(aj);
function SparseReverse(o,A){
var q=GetSortedArrayKeys(o,%GetArrayKeys(o,A));
var ak=q.length-1;
var al=0;
while(al<=ak){
var t=q[al];
var am=q[ak];
var an=A-am-1;
var ao,ap;
if(an<=t){
ap=am;
while(q[--ak]==am){}
ao=an;
if(an>=t){
ao=t;
while(q[++al]==t){}
ap=A-t-1;
var aq=o[ao];
if(!(aq===(void 0))||ao in o){
var ar=o[ap];
if(!(ar===(void 0))||ap in o){
o[ao]=ar;
o[ap]=aq;
}else{
o[ap]=aq;
delete o[ao];
}else{
var ar=o[ap];
if(!(ar===(void 0))||ap in o){
o[ao]=ar;
delete o[ap];
function InnerArrayReverse(o,A){
var am=A-1;
for(var t=0;t<am;t++,am--){
var aq=o[t];
if(!(aq===(void 0))||t in o){
var ar=o[am];
if(!(ar===(void 0))||am in o){
o[t]=ar;
o[am]=aq;
}else{
o[am]=aq;
delete o[t];
}else{
var ar=o[am];
if(!(ar===(void 0))||am in o){
o[t]=ar;
delete o[am];
return o;
function ArrayReverse(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.reverse");
var o=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var A=(o.length>>>0);
if(UseSparseVariant(o,A,(%_IsArray(o)),A)){
%NormalizeElements(o);
SparseReverse(o,A);
return o;
return InnerArrayReverse(o,A);
function ObservedArrayShift(A){
var as=this[0];
try{
$observeBeginPerformSplice(this);
SimpleMove(this,0,1,A,0);
this.length=A-1;
}finally{
$observeEndPerformSplice(this);
$observeEnqueueSpliceRecord(this,0,[as],0);
return as;
function ArrayShift(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.shift");
var o=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var A=(o.length>>>0);
if(A===0){
o.length=0;
return;
if(k(o))throw MakeTypeError(10);
if(%IsObserved(o))
return ObservedArrayShift.call(o,A);
var as=o[0];
if(UseSparseVariant(o,A,(%_IsArray(o)),A)){
SparseMove(o,0,1,A,0);
}else{
SimpleMove(o,0,1,A,0);
o.length=A-1;
return as;
function ObservedArrayUnshift(){
var A=(this.length>>>0);
var at=%_ArgumentsLength();
try{
$observeBeginPerformSplice(this);
SimpleMove(this,0,0,A,at);
for(var t=0;t<at;t++){
this[t]=%_Arguments(t);
var ag=A+at;
this.length=ag;
}finally{
$observeEndPerformSplice(this);
$observeEnqueueSpliceRecord(this,0,[],at);
return ag;
function ArrayUnshift(ah){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.unshift");
if(%IsObserved(this))
return ObservedArrayUnshift.apply(this,arguments);
var o=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var A=(o.length>>>0);
var at=%_ArgumentsLength();
if(A>0&&UseSparseVariant(o,A,(%_IsArray(o)),A)&&
!k(o)){
SparseMove(o,0,0,A,at);
}else{
SimpleMove(o,0,0,A,at);
for(var t=0;t<at;t++){
o[t]=%_Arguments(t);
var ag=A+at;
o.length=ag;
return ag;
function ArraySlice(au,av){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.slice");
var o=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var A=(o.length>>>0);
var Q=(%_IsSmi(%IS_VAR(au))?au:%NumberToInteger($toNumber(au)));
var aw=A;
if(!(av===(void 0)))aw=(%_IsSmi(%IS_VAR(av))?av:%NumberToInteger($toNumber(av)));
if(Q<0){
Q+=A;
if(Q<0)Q=0;
}else{
if(Q>A)Q=A;
if(aw<0){
aw+=A;
if(aw<0)aw=0;
}else{
if(aw>A)aw=A;
var N=[];
if(aw<Q)return N;
if(UseSparseVariant(o,A,(%_IsArray(o)),aw-Q)){
%NormalizeElements(o);
%NormalizeElements(N);
SparseSlice(o,Q,aw-Q,A,N);
}else{
SimpleSlice(o,Q,aw-Q,A,N);
N.length=aw-Q;
return N;
function ComputeSpliceStartIndex(Q,A){
if(Q<0){
Q+=A;
return Q<0?0:Q;
return Q>A?A:Q;
function ComputeSpliceDeleteCount(ax,at,A,Q){
var R=0;
if(at==1)
return A-Q;
R=(%_IsSmi(%IS_VAR(ax))?ax:%NumberToInteger($toNumber(ax)));
if(R<0)
return 0;
if(R>A-Q)
return A-Q;
return R;
function ObservedArraySplice(au,ax){
var at=%_ArgumentsLength();
var A=(this.length>>>0);
var Q=ComputeSpliceStartIndex((%_IsSmi(%IS_VAR(au))?au:%NumberToInteger($toNumber(au))),A);
var R=ComputeSpliceDeleteCount(ax,at,A,
var S=[];
S.length=R;
var ay=at>2?at-2:0;
try{
$observeBeginPerformSplice(this);
SimpleSlice(this,Q,R,A,S);
SimpleMove(this,Q,R,A,ay);
var t=Q;
var az=2;
var aA=%_ArgumentsLength();
while(az<aA){
this[t++]=%_Arguments(az++);
this.length=A-R+ay;
}finally{
$observeEndPerformSplice(this);
if(S.length||ay){
$observeEnqueueSpliceRecord(this,
S.slice(),
ay);
return S;
function ArraySplice(au,ax){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.splice");
if(%IsObserved(this))
return ObservedArraySplice.apply(this,arguments);
var at=%_ArgumentsLength();
var o=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var A=(o.length>>>0);
var Q=ComputeSpliceStartIndex((%_IsSmi(%IS_VAR(au))?au:%NumberToInteger($toNumber(au))),A);
var R=ComputeSpliceDeleteCount(ax,at,A,
var S=[];
S.length=R;
var ay=at>2?at-2:0;
if(R!=ay&&k(o)){
throw MakeTypeError(10);
}else if(R>0&&j(o)){
throw MakeTypeError(9);
var aB=R;
if(ay!=R){
aB+=A-Q-R;
if(UseSparseVariant(o,A,(%_IsArray(o)),aB)){
%NormalizeElements(o);
%NormalizeElements(S);
SparseSlice(o,Q,R,A,S);
SparseMove(o,Q,R,A,ay);
}else{
SimpleSlice(o,Q,R,A,S);
SimpleMove(o,Q,R,A,ay);
var t=Q;
var az=2;
var aA=%_ArgumentsLength();
while(az<aA){
o[t++]=%_Arguments(az++);
o.length=A-R+ay;
return S;
function InnerArraySort(v,aC){
if(!(%_ClassOf(aC)==='Function')){
aC=function(O,aD){
if(O===aD)return 0;
if(%_IsSmi(O)&&%_IsSmi(aD)){
return %SmiLexicographicCompare(O,aD);
O=$toString(O);
aD=$toString(aD);
if(O==aD)return 0;
else return O<aD?-1:1;
var aE=function InsertionSort(y,m,aF){
for(var t=m+1;t<aF;t++){
var aG=y[t];
for(var am=t-1;am>=m;am--){
var aH=y[am];
var aI=%_CallFunction((void 0),aH,aG,aC);
if(aI>0){
y[am+1]=aH;
}else{
break;
y[am+1]=aG;
var aJ=function(y,m,aF){
var aK=[];
var aL=200+((aF-m)&15);
for(var t=m+1,am=0;t<aF-1;t+=aL,am++){
aK[am]=[t,y[t]];
%_CallFunction(aK,function(y,z){
return %_CallFunction((void 0),y[1],z[1],aC);
},ArraySort);
var aM=aK[aK.length>>1][0];
return aM;
var aN=function QuickSort(y,m,aF){
var aM=0;
while(true){
if(aF-m<=10){
aE(y,m,aF);
return;
if(aF-m>1000){
aM=aJ(y,m,aF);
}else{
aM=m+((aF-m)>>1);
var aO=y[m];
var aP=y[aF-1];
var aQ=y[aM];
var aR=%_CallFunction((void 0),aO,aP,aC);
if(aR>0){
var aH=aO;
aO=aP;
aP=aH;
var aS=%_CallFunction((void 0),aO,aQ,aC);
if(aS>=0){
var aH=aO;
aO=aQ;
aQ=aP;
aP=aH;
}else{
var aT=%_CallFunction((void 0),aP,aQ,aC);
if(aT>0){
var aH=aP;
aP=aQ;
aQ=aH;
y[m]=aO;
y[aF-1]=aQ;
var aU=aP;
var aV=m+1;
var aW=aF-1;
y[aM]=y[aV];
y[aV]=aU;
partition:for(var t=aV+1;t<aW;t++){
var aG=y[t];
var aI=%_CallFunction((void 0),aG,aU,aC);
if(aI<0){
y[t]=y[aV];
y[aV]=aG;
aV++;
}else if(aI>0){
aW--;
if(aW==t)break partition;
var aX=y[aW];
aI=%_CallFunction((void 0),aX,aU,aC);
}while(aI>0);
y[t]=y[aW];
y[aW]=aG;
if(aI<0){
aG=y[t];
y[t]=y[aV];
y[aV]=aG;
aV++;
if(aF-aW<aV-m){
aN(y,aW,aF);
aF=aV;
}else{
aN(y,m,aV);
m=aW;
var aY=function CopyFromPrototype(aZ,v){
var ba=0;
for(var bb=%_GetPrototype(aZ);bb;bb=%_GetPrototype(bb)){
var p=%GetArrayKeys(bb,v);
if((typeof(p)==='number')){
var bc=p;
for(var t=0;t<bc;t++){
if(!(%_CallFunction(aZ,t,i))&&(%_CallFunction(bb,t,i))){
aZ[t]=bb[t];
if(t>=ba){ba=t+1;}
}else{
for(var t=0;t<p.length;t++){
var Y=p[t];
if(!(Y===(void 0))&&!(%_CallFunction(aZ,Y,i))
&&(%_CallFunction(bb,Y,i))){
aZ[Y]=bb[Y];
if(Y>=ba){ba=Y+1;}
return ba;
var bd=function(aZ,m,aF){
for(var bb=%_GetPrototype(aZ);bb;bb=%_GetPrototype(bb)){
var p=%GetArrayKeys(bb,aF);
if((typeof(p)==='number')){
var bc=p;
for(var t=m;t<bc;t++){
if((%_CallFunction(bb,t,i))){
aZ[t]=(void 0);
}else{
for(var t=0;t<p.length;t++){
var Y=p[t];
if(!(Y===(void 0))&&m<=Y&&
(%_CallFunction(bb,Y,i))){
aZ[Y]=(void 0);
var be=function SafeRemoveArrayHoles(aZ){
var bf=0;
var bg=v-1;
var bh=0;
while(bf<bg){
while(bf<bg&&
!(aZ[bf]===(void 0))){
bf++;
if(!(%_CallFunction(aZ,bf,i))){
bh++;
while(bf<bg&&
(aZ[bg]===(void 0))){
if(!(%_CallFunction(aZ,bg,i))){
bh++;
bg--;
if(bf<bg){
aZ[bf]=aZ[bg];
aZ[bg]=(void 0);
if(!(aZ[bf]===(void 0)))bf++;
var t;
for(t=bf;t<v-bh;t++){
aZ[t]=(void 0);
for(t=v-bh;t<v;t++){
if(t in %_GetPrototype(aZ)){
aZ[t]=(void 0);
}else{
delete aZ[t];
return bf;
if(v<2)return this;
var J=(%_IsArray(this));
var bi;
if(!J){
bi=aY(this,v);
var bj=%RemoveArrayHoles(this,v);
if(bj==-1){
bj=be(this);
aN(this,0,bj);
if(!J&&(bj+1<bi)){
bd(this,bj,bi);
return this;
function ArraySort(aC){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.sort");
var o=$toObject(this);
var v=(o.length>>>0);
return %_CallFunction(o,v,aC,InnerArraySort);
function InnerArrayFilter(bk,bl,o,v){
if(!(%_ClassOf(bk)==='Function'))throw MakeTypeError(12,bk);
var bm=false;
if((bl===null)){
if(%IsSloppyModeFunction(bk))bl=(void 0);
}else if(!(bl===(void 0))){
bm=(!(%_IsSpecObject(bl))&&%IsSloppyModeFunction(bk));
var bn=new d();
var bo=0;
var J=(%_IsArray(o));
var bp=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(bk);
for(var t=0;t<v;t++){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
var aG=o[t];
if(bp)%DebugPrepareStepInIfStepping(bk);
var bq=bm?$toObject(bl):bl;
if(%_CallFunction(bq,aG,t,o,bk)){
bn[bo++]=aG;
return bn;
function ArrayFilter(bk,bl){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.filter");
var o=$toObject(this);
var v=$toUint32(o.length);
var bn=InnerArrayFilter(bk,bl,o,v);
var N=new c();
%MoveArrayContents(bn,N);
return N;
function InnerArrayForEach(bk,bl,o,v){
if(!(%_ClassOf(bk)==='Function'))throw MakeTypeError(12,bk);
var bm=false;
if((bl===null)){
if(%IsSloppyModeFunction(bk))bl=(void 0);
}else if(!(bl===(void 0))){
bm=(!(%_IsSpecObject(bl))&&%IsSloppyModeFunction(bk));
var J=(%_IsArray(o));
var bp=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(bk);
for(var t=0;t<v;t++){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
var aG=o[t];
if(bp)%DebugPrepareStepInIfStepping(bk);
var bq=bm?$toObject(bl):bl;
%_CallFunction(bq,aG,t,o,bk);
function ArrayForEach(bk,bl){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.forEach");
var o=$toObject(this);
var v=(o.length>>>0);
InnerArrayForEach(bk,bl,o,v);
function InnerArraySome(bk,bl,o,v){
if(!(%_ClassOf(bk)==='Function'))throw MakeTypeError(12,bk);
var bm=false;
if((bl===null)){
if(%IsSloppyModeFunction(bk))bl=(void 0);
}else if(!(bl===(void 0))){
bm=(!(%_IsSpecObject(bl))&&%IsSloppyModeFunction(bk));
var J=(%_IsArray(o));
var bp=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(bk);
for(var t=0;t<v;t++){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
var aG=o[t];
if(bp)%DebugPrepareStepInIfStepping(bk);
var bq=bm?$toObject(bl):bl;
if(%_CallFunction(bq,aG,t,o,bk))return true;
return false;
function ArraySome(bk,bl){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.some");
var o=$toObject(this);
var v=(o.length>>>0);
return InnerArraySome(bk,bl,o,v);
function InnerArrayEvery(bk,bl,o,v){
if(!(%_ClassOf(bk)==='Function'))throw MakeTypeError(12,bk);
var bm=false;
if((bl===null)){
if(%IsSloppyModeFunction(bk))bl=(void 0);
}else if(!(bl===(void 0))){
bm=(!(%_IsSpecObject(bl))&&%IsSloppyModeFunction(bk));
var J=(%_IsArray(o));
var bp=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(bk);
for(var t=0;t<v;t++){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
var aG=o[t];
if(bp)%DebugPrepareStepInIfStepping(bk);
var bq=bm?$toObject(bl):bl;
if(!%_CallFunction(bq,aG,t,o,bk))return false;
return true;
function ArrayEvery(bk,bl){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.every");
var o=$toObject(this);
var v=(o.length>>>0);
return InnerArrayEvery(bk,bl,o,v);
function InnerArrayMap(bk,bl,o,v){
if(!(%_ClassOf(bk)==='Function'))throw MakeTypeError(12,bk);
var bm=false;
if((bl===null)){
if(%IsSloppyModeFunction(bk))bl=(void 0);
}else if(!(bl===(void 0))){
bm=(!(%_IsSpecObject(bl))&&%IsSloppyModeFunction(bk));
var bn=new d(v);
var J=(%_IsArray(o));
var bp=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(bk);
for(var t=0;t<v;t++){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
var aG=o[t];
if(bp)%DebugPrepareStepInIfStepping(bk);
var bq=bm?$toObject(bl):bl;
bn[t]=%_CallFunction(bq,aG,t,o,bk);
return bn;
function ArrayMap(bk,bl){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.map");
var o=$toObject(this);
var v=(o.length>>>0);
var bn=InnerArrayMap(bk,bl,o,v);
var N=new c();
%MoveArrayContents(bn,N);
return N;
function InnerArrayIndexOf(aG,Y,v){
if(v==0)return-1;
if((Y===(void 0))){
Y=0;
}else{
Y=(%_IsSmi(%IS_VAR(Y))?Y:%NumberToInteger($toNumber(Y)));
if(Y<0){
Y=v+Y;
if(Y<0)Y=0;
var br=Y;
var ba=v;
if(UseSparseVariant(this,v,(%_IsArray(this)),ba-br)){
%NormalizeElements(this);
var p=%GetArrayKeys(this,v);
if((typeof(p)==='number')){
ba=p;
}else{
if(p.length==0)return-1;
var bs=GetSortedArrayKeys(this,p);
var ad=bs.length;
var t=0;
while(t<ad&&bs[t]<Y)t++;
while(t<ad){
var x=bs[t];
if(!(x===(void 0))&&this[x]===aG)return x;
t++;
return-1;
if(!(aG===(void 0))){
for(var t=br;t<ba;t++){
if(this[t]===aG)return t;
return-1;
for(var t=br;t<ba;t++){
if((this[t]===(void 0))&&t in this){
return t;
return-1;
function ArrayIndexOf(aG,Y){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.indexOf");
var v=(this.length>>>0);
return %_CallFunction(this,aG,Y,v,InnerArrayIndexOf);
function InnerArrayLastIndexOf(aG,Y,v,bt){
if(v==0)return-1;
if(bt<2){
Y=v-1;
}else{
Y=(%_IsSmi(%IS_VAR(Y))?Y:%NumberToInteger($toNumber(Y)));
if(Y<0)Y+=v;
if(Y<0)return-1;
else if(Y>=v)Y=v-1;
var br=0;
var ba=Y;
if(UseSparseVariant(this,v,(%_IsArray(this)),Y)){
%NormalizeElements(this);
var p=%GetArrayKeys(this,Y+1);
if((typeof(p)==='number')){
ba=p;
}else{
if(p.length==0)return-1;
var bs=GetSortedArrayKeys(this,p);
var t=bs.length-1;
while(t>=0){
var x=bs[t];
if(!(x===(void 0))&&this[x]===aG)return x;
t--;
return-1;
if(!(aG===(void 0))){
for(var t=ba;t>=br;t--){
if(this[t]===aG)return t;
return-1;
for(var t=ba;t>=br;t--){
if((this[t]===(void 0))&&t in this){
return t;
return-1;
function ArrayLastIndexOf(aG,Y){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.lastIndexOf");
var v=(this.length>>>0);
return %_CallFunction(this,aG,Y,v,
%_ArgumentsLength(),InnerArrayLastIndexOf);
function InnerArrayReduce(bu,T,o,v,bt){
if(!(%_ClassOf(bu)==='Function')){
throw MakeTypeError(12,bu);
var J=(%_IsArray(o));
var t=0;
find_initial:if(bt<2){
for(;t<v;t++){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
T=o[t++];
break find_initial;
throw MakeTypeError(93);
var bp=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(bu);
for(;t<v;t++){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
var aG=o[t];
if(bp)%DebugPrepareStepInIfStepping(bu);
T=%_CallFunction((void 0),T,aG,t,o,bu);
return T;
function ArrayReduce(bu,T){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.reduce");
var o=$toObject(this);
var v=$toUint32(o.length);
return InnerArrayReduce(bu,T,o,v,
%_ArgumentsLength());
function InnerArrayReduceRight(bu,T,o,v,
bt){
if(!(%_ClassOf(bu)==='Function')){
throw MakeTypeError(12,bu);
var J=(%_IsArray(o));
var t=v-1;
find_initial:if(bt<2){
for(;t>=0;t--){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
T=o[t--];
break find_initial;
throw MakeTypeError(93);
var bp=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(bu);
for(;t>=0;t--){
if(((J&&%_HasFastPackedElements(%IS_VAR(o)))?(t<o.length):(t in o))){
var aG=o[t];
if(bp)%DebugPrepareStepInIfStepping(bu);
T=%_CallFunction((void 0),T,aG,t,o,bu);
return T;
function ArrayReduceRight(bu,T){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.reduceRight");
var o=$toObject(this);
var v=$toUint32(o.length);
return InnerArrayReduceRight(bu,T,o,v,
%_ArgumentsLength());
function ArrayIsArray(aZ){
return(%_IsArray(aZ));
%AddNamedProperty(c.prototype,"constructor",c,
var bv={
__proto__:null,
copyWithin:true,
entries:true,
fill:true,
find:true,
findIndex:true,
keys:true,
%AddNamedProperty(c.prototype,symbolUnscopables,bv,
2|1);
b.InstallFunctions(c,2,[
"isArray",ArrayIsArray
var bw=%SpecialArrayFunctions();
var bx=function(by,bz,A){
var bk=bz;
if(bw.hasOwnProperty(by)){
bk=bw[by];
if(!(A===(void 0))){
%FunctionSetLength(bk,A);
return bk;
b.InstallFunctions(c.prototype,2,[
"toString",bx("toString",ArrayToString),
"toLocaleString",bx("toLocaleString",ArrayToLocaleString),
"join",bx("join",ArrayJoin),
"pop",bx("pop",ArrayPop),
"push",bx("push",ArrayPush,1),
"concat",bx("concat",ArrayConcatJS,1),
"reverse",bx("reverse",ArrayReverse),
"shift",bx("shift",ArrayShift),
"unshift",bx("unshift",ArrayUnshift,1),
"slice",bx("slice",ArraySlice,2),
"splice",bx("splice",ArraySplice,2),
"sort",bx("sort",ArraySort),
"filter",bx("filter",ArrayFilter,1),
"forEach",bx("forEach",ArrayForEach,1),
"some",bx("some",ArraySome,1),
"every",bx("every",ArrayEvery,1),
"map",bx("map",ArrayMap,1),
"indexOf",bx("indexOf",ArrayIndexOf,1),
"lastIndexOf",bx("lastIndexOf",ArrayLastIndexOf,1),
"reduce",bx("reduce",ArrayReduce,1),
"reduceRight",bx("reduceRight",ArrayReduceRight,1)
%FinishArrayPrototypeSetup(c.prototype);
b.SetUpLockedPrototype(d,c(),[
"concat",bx("concat",ArrayConcatJS),
"indexOf",bx("indexOf",ArrayIndexOf),
"join",bx("join",ArrayJoin),
"pop",bx("pop",ArrayPop),
"push",bx("push",ArrayPush),
"shift",bx("shift",ArrayShift),
"splice",bx("splice",ArraySplice)
b.SetUpLockedPrototype(e,c(),[
"join",bx("join",ArrayJoin),
"pop",bx("pop",ArrayPop),
"push",bx("push",ArrayPush),
"shift",bx("shift",ArrayShift)
b.Export(function(aF){
aF.ArrayIndexOf=ArrayIndexOf;
aF.ArrayJoin=ArrayJoin;
aF.ArrayToString=ArrayToString;
aF.InnerArrayEvery=InnerArrayEvery;
aF.InnerArrayFilter=InnerArrayFilter;
aF.InnerArrayForEach=InnerArrayForEach;
aF.InnerArrayIndexOf=InnerArrayIndexOf;
aF.InnerArrayJoin=InnerArrayJoin;
aF.InnerArrayLastIndexOf=InnerArrayLastIndexOf;
aF.InnerArrayMap=InnerArrayMap;
aF.InnerArrayReduce=InnerArrayReduce;
aF.InnerArrayReduceRight=InnerArrayReduceRight;
aF.InnerArrayReverse=InnerArrayReverse;
aF.InnerArraySome=InnerArraySome;
aF.InnerArraySort=InnerArraySort;
aF.InnerArrayToLocaleString=InnerArrayToLocaleString;
$arrayConcat=ArrayConcatJS;
$arrayPush=ArrayPush;
$arrayPop=ArrayPop;
$arrayShift=ArrayShift;
$arraySlice=ArraySlice;
$arraySplice=ArraySplice;
$arrayUnshift=ArrayUnshift;
(function(a,b){
%CheckIsBootstrapping();
var c=a.RegExp;
var d=a.String;
var e=b.InternalArray;
var g=b.InternalPackedArray;
var h;
var i;
var j;
var k;
var l;
var m;
var n;
b.Import(function(o){
h=o.ArrayIndexOf;
i=o.ArrayJoin;
j=o.MathMax;
k=o.MathMin;
l=o.RegExpExec;
m=o.RegExpExecNoTests;
n=o.RegExpLastMatchInfo;
function StringConstructor(p){
if(%_ArgumentsLength()==0)p='';
if(%_IsConstructCall()){
%_SetValueOf(this,((typeof(%IS_VAR(p))==='string')?p:$nonStringToString(p)));
}else{
return(typeof(p)==='symbol')?
%_CallFunction(p,$symbolToString):((typeof(%IS_VAR(p))==='string')?p:$nonStringToString(p));
function StringToString(){
if(!(typeof(this)==='string')&&!(%_ClassOf(this)==='String')){
throw MakeTypeError(55,'String.prototype.toString');
return %_ValueOf(this);
function StringValueOf(){
if(!(typeof(this)==='string')&&!(%_ClassOf(this)==='String')){
throw MakeTypeError(55,'String.prototype.valueOf');
return %_ValueOf(this);
function StringCharAtJS(q){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.charAt");
var r=%_StringCharAt(this,q);
if(%_IsSmi(r)){
r=%_StringCharAt(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)),(%_IsSmi(%IS_VAR(q))?q:%NumberToInteger($toNumber(q))));
return r;
function StringCharCodeAtJS(q){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.charCodeAt");
var r=%_StringCharCodeAt(this,q);
if(!%_IsSmi(r)){
r=%_StringCharCodeAt(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)),(%_IsSmi(%IS_VAR(q))?q:%NumberToInteger($toNumber(q))));
return r;
function StringConcat(t){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.concat");
var u=%_ArgumentsLength();
var v=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
if(u===1){
return v+((typeof(%IS_VAR(t))==='string')?t:$nonStringToString(t));
var w=new e(u+1);
w[0]=v;
for(var x=0;x<u;x++){
var y=%_Arguments(x);
w[x+1]=((typeof(%IS_VAR(y))==='string')?y:$nonStringToString(y));
return %StringBuilderConcat(w,u+1,"");
function StringIndexOfJS(z){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.indexOf");
var A=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
z=((typeof(%IS_VAR(z))==='string')?z:$nonStringToString(z));
var B=0;
if(%_ArgumentsLength()>1){
B=%_Arguments(1);
B=(%_IsSmi(%IS_VAR(B))?B:%NumberToInteger($toNumber(B)));
if(B<0)B=0;
if(B>A.length)B=A.length;
return %StringIndexOf(A,z,B);
function StringLastIndexOfJS(C){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.lastIndexOf");
var D=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
var E=D.length;
var C=((typeof(%IS_VAR(C))==='string')?C:$nonStringToString(C));
var F=C.length;
var B=E-F;
if(%_ArgumentsLength()>1){
var G=$toNumber(%_Arguments(1));
if(!(!%_IsSmi(%IS_VAR(G))&&!(G==G))){
G=(%_IsSmi(%IS_VAR(G))?G:%NumberToInteger($toNumber(G)));
if(G<0){
G=0;
if(G+F<E){
B=G;
if(B<0){
return-1;
return %StringLastIndexOf(D,C,B);
function StringLocaleCompareJS(t){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.localeCompare");
return %StringLocaleCompare(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)),
((typeof(%IS_VAR(t))==='string')?t:$nonStringToString(t)));
function StringMatchJS(H){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.match");
var A=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
if((%_IsRegExp(H))){
var I=H.lastIndex;
(%_IsSmi(%IS_VAR(I))?I:$toNumber(I));
if(!H.global)return m(H,A,0);
var r=%StringMatch(A,H,n);
if(r!==null)$regexpLastMatchInfoOverride=null;
H.lastIndex=0;
return r;
H=new c(H);
return m(H,A,0);
function StringNormalizeJS(J){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.normalize");
var J=J?((typeof(%IS_VAR(J))==='string')?J:$nonStringToString(J)):'NFC';
var K=['NFC','NFD','NFKC','NFKD'];
var L=
%_CallFunction(K,J,h);
if(L===-1){
throw MakeRangeError(142,
%_CallFunction(K,', ',i));
return %_ValueOf(this);
var M=[2,"","",-1,-1];
function StringReplace(N,O){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.replace");
var A=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
if((%_IsRegExp(N))){
var I=N.lastIndex;
(%_IsSmi(%IS_VAR(I))?I:$toNumber(I));
if(!(%_ClassOf(O)==='Function')){
O=((typeof(%IS_VAR(O))==='string')?O:$nonStringToString(O));
if(!N.global){
var P=l(N,A,0);
if(P==null){
N.lastIndex=0
return A;
if(O.length==0){
return %_SubString(A,0,P[3])+
%_SubString(A,P[4],A.length)
return ExpandReplacement(O,A,n,
%_SubString(A,0,P[3]))+
%_SubString(A,P[4],A.length);
N.lastIndex=0;
if($regexpLastMatchInfoOverride==null){
return %StringReplaceGlobalRegExpWithString(
A,N,O,n);
}else{
var Q=n[1];
n[1]=0;
var R=%StringReplaceGlobalRegExpWithString(
A,N,O,n);
if(%_IsSmi(n[1])){
n[1]=Q;
}else{
$regexpLastMatchInfoOverride=null;
return R;
if(N.global){
return StringReplaceGlobalRegExpWithFunction(A,N,O);
return StringReplaceNonGlobalRegExpWithFunction(A,N,O);
N=((typeof(%IS_VAR(N))==='string')?N:$nonStringToString(N));
if(N.length==1&&
A.length>0xFF&&
(typeof(O)==='string')&&
%StringIndexOf(O,'$',0)<0){
return %StringReplaceOneCharWithString(A,N,O);
var S=%StringIndexOf(A,N,0);
if(S<0)return A;
var T=S+N.length;
var r=%_SubString(A,0,S);
if((%_ClassOf(O)==='Function')){
var U=(void 0);
r+=%_CallFunction(U,N,S,A,O);
}else{
M[3]=S;
M[4]=T;
r=ExpandReplacement(((typeof(%IS_VAR(O))==='string')?O:$nonStringToString(O)),
return r+%_SubString(A,T,A.length);
function ExpandReplacement(V,A,W,r){
var X=V.length;
var Y=%StringIndexOf(V,'$',0);
if(Y<0){
if(X>0)r+=V;
return r;
if(Y>0)r+=%_SubString(V,0,Y);
while(true){
var Z='$';
var G=Y+1;
if(G<X){
var aa=%_StringCharCodeAt(V,G);
if(aa==36){
++G;
r+='$';
}else if(aa==38){
++G;
%_SubString(A,W[3],W[4]);
}else if(aa==96){
++G;
r+=%_SubString(A,0,W[3]);
}else if(aa==39){
++G;
r+=%_SubString(A,W[4],A.length);
}else if(aa>=48&&aa<=57){
var ab=(aa-48)<<1;
var ac=1;
var ad=((W)[0]);
if(G+1<V.length){
var Y=%_StringCharCodeAt(V,G+1);
if(Y>=48&&Y<=57){
var ae=ab*10+((Y-48)<<1);
if(ae<ad){
ab=ae;
ac=2;
if(ab!=0&&ab<ad){
var S=W[(3+(ab))];
if(S>=0){
%_SubString(A,S,W[(3+(ab+1))]);
G+=ac;
}else{
r+='$';
}else{
r+='$';
}else{
r+='$';
Y=%StringIndexOf(V,'$',G);
if(Y<0){
if(G<X){
r+=%_SubString(V,G,X);
return r;
if(Y>G){
r+=%_SubString(V,G,Y);
return r;
function CaptureString(V,af,B){
var ag=B<<1;
var S=af[(3+(ag))];
if(S<0)return;
var T=af[(3+(ag+1))];
return %_SubString(V,S,T);
var ah=new e(4);
function StringReplaceGlobalRegExpWithFunction(A,H,O){
var ai=ah;
if(ai){
ah=null;
}else{
ai=new e(16);
var aj=%RegExpExecMultiple(H,
ai);
H.lastIndex=0;
if((aj===null)){
ah=ai;
return A;
var u=aj.length;
if(((n)[0])==2){
var ak=0;
var al=new g(null,0,A);
for(var x=0;x<u;x++){
var am=aj[x];
if(%_IsSmi(am)){
if(am>0){
ak=(am>>11)+(am&0x7ff);
}else{
ak=aj[++x]-am;
}else{
al[0]=am;
al[1]=ak;
$regexpLastMatchInfoOverride=al;
var an=
%_CallFunction((void 0),am,ak,A,O);
aj[x]=((typeof(%IS_VAR(an))==='string')?an:$nonStringToString(an));
ak+=am.length;
}else{
for(var x=0;x<u;x++){
var am=aj[x];
if(!%_IsSmi(am)){
$regexpLastMatchInfoOverride=am;
var an=%Apply(O,(void 0),am,0,am.length);
aj[x]=((typeof(%IS_VAR(an))==='string')?an:$nonStringToString(an));
var r=%StringBuilderConcat(aj,aj.length,A);
ai.length=0;
ah=ai;
return r;
function StringReplaceNonGlobalRegExpWithFunction(A,H,O){
var W=l(H,A,0);
if((W===null)){
H.lastIndex=0;
return A;
var B=W[3];
var r=%_SubString(A,0,B);
var ao=W[4];
var ap=((W)[0])>>1;
var aq;
if(ap==1){
var ar=%_SubString(A,B,ao);
aq=%_CallFunction((void 0),ar,B,A,O);
}else{
var as=new e(ap+2);
for(var at=0;at<ap;at++){
as[at]=CaptureString(A,W,at);
as[at]=B;
as[at+1]=A;
aq=%Apply(O,(void 0),as,0,at+2);
r+=aq;
return r+%_SubString(A,ao,A.length);
function StringSearch(au){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.search");
var H;
if((typeof(au)==='string')){
H=%_GetFromCache(0,au);
}else if((%_IsRegExp(au))){
H=au;
}else{
H=new c(au);
var P=l(H,((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)),0);
if(P){
return P[3];
return-1;
function StringSlice(S,T){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.slice");
var ar=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
var av=ar.length;
var aw=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var ax=av;
if(!(T===(void 0))){
ax=(%_IsSmi(%IS_VAR(T))?T:%NumberToInteger($toNumber(T)));
if(aw<0){
aw+=av;
if(aw<0){
aw=0;
}else{
if(aw>av){
return'';
if(ax<0){
ax+=av;
if(ax<0){
return'';
}else{
if(ax>av){
ax=av;
if(ax<=aw){
return'';
return %_SubString(ar,aw,ax);
function StringSplitJS(ay,az){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.split");
var A=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
az=((az===(void 0)))?0xffffffff:(az>>>0);
var X=A.length;
if(!(%_IsRegExp(ay))){
var aA=((typeof(%IS_VAR(ay))==='string')?ay:$nonStringToString(ay));
if(az===0)return[];
if((ay===(void 0)))return[A];
var aB=aA.length;
if(aB===0)return %StringToArray(A,az);
var r=%StringSplit(A,aA,az);
return r;
if(az===0)return[];
return StringSplitOnRegExp(A,ay,az,X);
function StringSplitOnRegExp(A,ay,az,X){
if(X===0){
if(l(ay,A,0,0)!=null){
return[];
return[A];
var aC=0;
var aD=0;
var aE=0;
var r=new e();
outer_loop:
while(true){
if(aD===X){
r[r.length]=%_SubString(A,aC,X);
break;
var W=l(ay,A,aD);
if(W==null||X===(aE=W[3])){
r[r.length]=%_SubString(A,aC,X);
break;
var aF=W[4];
if(aD===aF&&aF===aC){
aD++;
continue;
r[r.length]=%_SubString(A,aC,aE);
if(r.length===az)break;
var aG=((W)[0])+3;
for(var x=3+2;x<aG;){
var S=W[x++];
var T=W[x++];
if(T!=-1){
r[r.length]=%_SubString(A,S,T);
}else{
r[r.length]=(void 0);
if(r.length===az)break outer_loop;
aD=aC=aF;
var aH=[];
%MoveArrayContents(r,aH);
return aH;
function StringSubstring(S,T){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.subString");
var ar=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
var av=ar.length;
var aw=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
if(aw<0){
aw=0;
}else if(aw>av){
aw=av;
var ax=av;
if(!(T===(void 0))){
ax=(%_IsSmi(%IS_VAR(T))?T:%NumberToInteger($toNumber(T)));
if(ax>av){
ax=av;
}else{
if(ax<0)ax=0;
if(aw>ax){
var aI=ax;
ax=aw;
aw=aI;
return %_SubString(ar,aw,ax);
function StringSubstr(S,aJ){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.substr");
var ar=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
var u;
if((aJ===(void 0))){
u=ar.length;
}else{
u=(%_IsSmi(%IS_VAR(aJ))?aJ:%NumberToInteger($toNumber(aJ)));
if(u<=0)return'';
if((S===(void 0))){
S=0;
}else{
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
if(S>=ar.length)return'';
if(S<0){
S+=ar.length;
if(S<0)S=0;
var T=S+u;
if(T>ar.length)T=ar.length;
return %_SubString(ar,S,T);
function StringToLowerCaseJS(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.toLowerCase");
return %StringToLowerCase(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)));
function StringToLocaleLowerCase(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.toLocaleLowerCase");
return %StringToLowerCase(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)));
function StringToUpperCaseJS(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.toUpperCase");
return %StringToUpperCase(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)));
function StringToLocaleUpperCase(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.toLocaleUpperCase");
return %StringToUpperCase(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)));
function StringTrimJS(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.trim");
return %StringTrim(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)),true,true);
function StringTrimLeft(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.trimLeft");
return %StringTrim(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)),true,false);
function StringTrimRight(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.trimRight");
return %StringTrim(((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this)),false,true);
function StringFromCharCode(aK){
var aJ=%_ArgumentsLength();
if(aJ==1){
if(!%_IsSmi(aK))aK=$toNumber(aK);
return %_StringCharFromCode(aK&0xffff);
var aL=%NewString(aJ,true);
var x;
for(x=0;x<aJ;x++){
var aK=%_Arguments(x);
if(!%_IsSmi(aK))aK=$toNumber(aK)&0xffff;
if(aK<0)aK=aK&0xffff;
if(aK>0xff)break;
%_OneByteSeqStringSetChar(x,aK,aL);
if(x==aJ)return aL;
aL=%TruncateString(aL,x);
var aM=%NewString(aJ-x,false);
for(var at=0;x<aJ;x++,at++){
var aK=%_Arguments(x);
if(!%_IsSmi(aK))aK=$toNumber(aK)&0xffff;
%_TwoByteSeqStringSetChar(at,aK,aM);
return aL+aM;
function HtmlEscape(aN){
return %_CallFunction(((typeof(%IS_VAR(aN))==='string')?aN:$nonStringToString(aN)),/"/g,"&quot;",StringReplace);
function StringAnchor(aO){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.anchor");
return"<a name=\""+HtmlEscape(aO)+"\">"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+
"</a>";
function StringBig(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.big");
return"<big>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</big>";
function StringBlink(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.blink");
return"<blink>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</blink>";
function StringBold(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.bold");
return"<b>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</b>";
function StringFixed(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.fixed");
return"<tt>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</tt>";
function StringFontcolor(aP){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.fontcolor");
return"<font color=\""+HtmlEscape(aP)+"\">"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+
"</font>";
function StringFontsize(aQ){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.fontsize");
return"<font size=\""+HtmlEscape(aQ)+"\">"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+
"</font>";
function StringItalics(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.italics");
return"<i>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</i>";
function StringLink(ar){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.link");
return"<a href=\""+HtmlEscape(ar)+"\">"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</a>";
function StringSmall(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.small");
return"<small>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</small>";
function StringStrike(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.strike");
return"<strike>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</strike>";
function StringSub(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.sub");
return"<sub>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</sub>";
function StringSup(){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.sup");
return"<sup>"+((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this))+"</sup>";
function StringRepeat(aR){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.repeat");
var ar=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
var aJ=$toInteger(aR);
if(aJ<0||aJ>%_MaxSmi())throw MakeRangeError(128);
var aS="";
while(true){
if(aJ&1)aS+=ar;
aJ>>=1;
if(aJ===0)return aS;
ar+=ar;
function StringStartsWith(aT){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.startsWith");
var ar=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
if((%_IsRegExp(aT))){
throw MakeTypeError(28,"String.prototype.startsWith");
var aU=((typeof(%IS_VAR(aT))==='string')?aT:$nonStringToString(aT));
var q=0;
if(%_ArgumentsLength()>1){
q=%_Arguments(1);
q=$toInteger(q);
var av=ar.length;
var S=k(j(q,0),av);
var aV=aU.length;
if(aV+S>av){
return false;
return %StringIndexOf(ar,aU,S)===S;
function StringEndsWith(aT){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.endsWith");
var ar=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
if((%_IsRegExp(aT))){
throw MakeTypeError(28,"String.prototype.endsWith");
var aU=((typeof(%IS_VAR(aT))==='string')?aT:$nonStringToString(aT));
var av=ar.length;
var q=av;
if(%_ArgumentsLength()>1){
var aW=%_Arguments(1);
if(!(aW===(void 0))){
q=$toInteger(aW);
var T=k(j(q,0),av);
var aV=aU.length;
var S=T-aV;
if(S<0){
return false;
return %StringLastIndexOf(ar,aU,S)===S;
function StringIncludes(aT){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.includes");
var ar=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
if((%_IsRegExp(aT))){
throw MakeTypeError(28,"String.prototype.includes");
var aU=((typeof(%IS_VAR(aT))==='string')?aT:$nonStringToString(aT));
var q=0;
if(%_ArgumentsLength()>1){
q=%_Arguments(1);
q=$toInteger(q);
var av=ar.length;
var S=k(j(q,0),av);
var aV=aU.length;
if(aV+S>av){
return false;
return %StringIndexOf(ar,aU,S)!==-1;
function StringCodePointAt(q){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"String.prototype.codePointAt");
var V=((typeof(%IS_VAR(this))==='string')?this:$nonStringToString(this));
var aQ=V.length;
q=(%_IsSmi(%IS_VAR(q))?q:%NumberToInteger($toNumber(q)));
if(q<0||q>=aQ){
return(void 0);
var aX=%_StringCharCodeAt(V,q);
if(aX<0xD800||aX>0xDBFF||q+1==aQ){
return aX;
var aY=%_StringCharCodeAt(V,q+1);
if(aY<0xDC00||aY>0xDFFF){
return aX;
return(aX-0xD800)*0x400+aY+0x2400;
function StringFromCodePoint(aZ){
var aK;
var X=%_ArgumentsLength();
var B;
var r="";
for(B=0;B<X;B++){
aK=%_Arguments(B);
if(!%_IsSmi(aK)){
aK=$toNumber(aK);
if(aK<0||aK>0x10FFFF||aK!==(%_IsSmi(%IS_VAR(aK))?aK:%NumberToInteger($toNumber(aK)))){
throw MakeRangeError(127,aK);
if(aK<=0xFFFF){
r+=%_StringCharFromCode(aK);
}else{
aK-=0x10000;
r+=%_StringCharFromCode((aK>>>10)&0x3FF|0xD800);
r+=%_StringCharFromCode(aK&0x3FF|0xDC00);
return r;
function StringRaw(ba){
var bb=%_ArgumentsLength();
var bc=$toObject(ba);
var bd=$toObject(bc.raw);
var be=$toLength(bd.length);
if(be<=0)return"";
var r=$toString(bd[0]);
for(var x=1;x<be;++x){
if(x<bb){
r+=$toString(%_Arguments(x));
r+=$toString(bd[x]);
return r;
%SetCode(d,StringConstructor);
%FunctionSetPrototype(d,new d());
%AddNamedProperty(
d.prototype,"constructor",d,2);
b.InstallFunctions(d,2,[
"fromCharCode",StringFromCharCode,
"fromCodePoint",StringFromCodePoint,
"raw",StringRaw
b.InstallFunctions(d.prototype,2,[
"valueOf",StringValueOf,
"toString",StringToString,
"charAt",StringCharAtJS,
"charCodeAt",StringCharCodeAtJS,
"codePointAt",StringCodePointAt,
"concat",StringConcat,
"endsWith",StringEndsWith,
"includes",StringIncludes,
"indexOf",StringIndexOfJS,
"lastIndexOf",StringLastIndexOfJS,
"localeCompare",StringLocaleCompareJS,
"match",StringMatchJS,
"normalize",StringNormalizeJS,
"repeat",StringRepeat,
"replace",StringReplace,
"search",StringSearch,
"slice",StringSlice,
"split",StringSplitJS,
"substring",StringSubstring,
"substr",StringSubstr,
"startsWith",StringStartsWith,
"toLowerCase",StringToLowerCaseJS,
"toLocaleLowerCase",StringToLocaleLowerCase,
"toUpperCase",StringToUpperCaseJS,
"toLocaleUpperCase",StringToLocaleUpperCase,
"trim",StringTrimJS,
"trimLeft",StringTrimLeft,
"trimRight",StringTrimRight,
"link",StringLink,
"anchor",StringAnchor,
"fontcolor",StringFontcolor,
"fontsize",StringFontsize,
"big",StringBig,
"blink",StringBlink,
"bold",StringBold,
"fixed",StringFixed,
"italics",StringItalics,
"small",StringSmall,
"strike",StringStrike,
"sub",StringSub,
"sup",StringSup
b.Export(function(bf){
bf.StringCharAt=StringCharAtJS;
bf.StringIndexOf=StringIndexOfJS;
bf.StringLastIndexOf=StringLastIndexOfJS;
bf.StringMatch=StringMatchJS;
bf.StringReplace=StringReplace;
bf.StringSplit=StringSplitJS;
bf.StringSubstr=StringSubstr;
bf.StringSubstring=StringSubstring;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Object;
var d=a.Array;
var e=b.InternalArray;
function HexValueOf(g){
if(g>=48&&g<=57)return g-48;
if(g>=65&&g<=70)return g-55;
if(g>=97&&g<=102)return g-87;
return-1;
function isAlphaNumeric(h){
if(97<=h&&h<=122)return true;
if(65<=h&&h<=90)return true;
if(48<=h&&h<=57)return true;
return false;
var i=0;
function URIAddEncodedOctetToBuffer(j,k,l){
k[l++]=37;
k[l++]=i[j>>4];
k[l++]=i[j&0x0F];
return l;
function URIEncodeOctets(m,k,l){
if(i===0){
i=[48,49,50,51,52,53,54,55,56,57,
65,66,67,68,69,70];
l=URIAddEncodedOctetToBuffer(m[0],k,l);
if(m[1])l=URIAddEncodedOctetToBuffer(m[1],k,l);
if(m[2])l=URIAddEncodedOctetToBuffer(m[2],k,l);
if(m[3])l=URIAddEncodedOctetToBuffer(m[3],k,l);
return l;
function URIEncodeSingle(h,k,l){
var n=(h>>12)&0xF;
var o=(h>>6)&63;
var p=h&63;
var m=new d(3);
if(h<=0x007F){
m[0]=h;
}else if(h<=0x07FF){
m[0]=o+192;
m[1]=p+128;
}else{
m[0]=n+224;
m[1]=o+128;
m[2]=p+128;
return URIEncodeOctets(m,k,l);
function URIEncodePair(q,r,k,l){
var t=((q>>6)&0xF)+1;
var u=(q>>2)&0xF;
var n=q&3;
var o=(r>>6)&0xF;
var p=r&63;
var m=new d(4);
m[0]=(t>>2)+240;
m[1]=(((t&3)<<4)|u)+128;
m[2]=((n<<4)|o)+128;
m[3]=p+128;
return URIEncodeOctets(m,k,l);
function URIHexCharsToCharCode(v,w){
var x=HexValueOf(v);
var y=HexValueOf(w);
if(x==-1||y==-1)throw MakeURIError();
return(x<<4)|y;
function URIDecodeOctets(m,k,l){
var z;
var A=m[0];
if(A<0x80){
z=A;
}else if(A<0xc2){
throw MakeURIError();
}else{
var B=m[1];
if(A<0xe0){
var C=A&0x1f;
if((B<0x80)||(B>0xbf))throw MakeURIError();
var D=B&0x3f;
z=(C<<6)+D;
if(z<0x80||z>0x7ff)throw MakeURIError();
}else{
var E=m[2];
if(A<0xf0){
var C=A&0x0f;
if((B<0x80)||(B>0xbf))throw MakeURIError();
var D=B&0x3f;
if((E<0x80)||(E>0xbf))throw MakeURIError();
var F=E&0x3f;
z=(C<<12)+(D<<6)+F;
if((z<0x800)||(z>0xffff))throw MakeURIError();
}else{
var G=m[3];
if(A<0xf8){
var C=(A&0x07);
if((B<0x80)||(B>0xbf))throw MakeURIError();
var D=(B&0x3f);
if((E<0x80)||(E>0xbf)){
throw MakeURIError();
var F=(E&0x3f);
if((G<0x80)||(G>0xbf))throw MakeURIError();
var H=(G&0x3f);
z=(C<<18)+(D<<12)+(F<<6)+H;
if((z<0x10000)||(z>0x10ffff))throw MakeURIError();
}else{
throw MakeURIError();
if(0xD800<=z&&z<=0xDFFF)throw MakeURIError();
if(z<0x10000){
%_TwoByteSeqStringSetChar(l++,z,k);
}else{
%_TwoByteSeqStringSetChar(l++,(z>>10)+0xd7c0,k);
%_TwoByteSeqStringSetChar(l++,(z&0x3ff)+0xdc00,k);
return l;
function Encode(I,J){
I=((typeof(%IS_VAR(I))==='string')?I:$nonStringToString(I));
var K=I.length;
var L=new e(K);
var l=0;
for(var M=0;M<K;M++){
var q=%_StringCharCodeAt(I,M);
if(J(q)){
L[l++]=q;
}else{
if(q>=0xDC00&&q<=0xDFFF)throw MakeURIError();
if(q<0xD800||q>0xDBFF){
l=URIEncodeSingle(q,L,l);
}else{
M++;
if(M==K)throw MakeURIError();
var r=%_StringCharCodeAt(I,M);
if(r<0xDC00||r>0xDFFF)throw MakeURIError();
l=URIEncodePair(q,r,L,l);
var k=%NewString(L.length,true);
for(var N=0;N<L.length;N++){
%_OneByteSeqStringSetChar(N,L[N],k);
return k;
function Decode(I,O){
I=((typeof(%IS_VAR(I))==='string')?I:$nonStringToString(I));
var K=I.length;
var P=%NewString(K,true);
var l=0;
var M=0;
for(;M<K;M++){
var g=%_StringCharCodeAt(I,M);
if(g==37){
if(M+2>=K)throw MakeURIError();
var h=URIHexCharsToCharCode(%_StringCharCodeAt(I,M+1),
%_StringCharCodeAt(I,M+2));
if(h>>7)break;
if(O(h)){
%_OneByteSeqStringSetChar(l++,37,P);
%_OneByteSeqStringSetChar(l++,%_StringCharCodeAt(I,M+1),
%_OneByteSeqStringSetChar(l++,%_StringCharCodeAt(I,M+2),
}else{
%_OneByteSeqStringSetChar(l++,h,P);
M+=2;
}else{
if(g>0x7f)break;
%_OneByteSeqStringSetChar(l++,g,P);
P=%TruncateString(P,l);
if(M==K)return P;
var Q=%NewString(K-M,false);
l=0;
for(;M<K;M++){
var g=%_StringCharCodeAt(I,M);
if(g==37){
if(M+2>=K)throw MakeURIError();
var h=URIHexCharsToCharCode(%_StringCharCodeAt(I,++M),
%_StringCharCodeAt(I,++M));
if(h>>7){
var R=0;
while(((h<<++R)&0x80)!=0){}
if(R==1||R>4)throw MakeURIError();
var m=new d(R);
m[0]=h;
if(M+3*(R-1)>=K)throw MakeURIError();
for(var N=1;N<R;N++){
if(I[++M]!='%')throw MakeURIError();
m[N]=URIHexCharsToCharCode(%_StringCharCodeAt(I,++M),
%_StringCharCodeAt(I,++M));
l=URIDecodeOctets(m,Q,l);
}else if(O(h)){
%_TwoByteSeqStringSetChar(l++,37,Q);
%_TwoByteSeqStringSetChar(l++,%_StringCharCodeAt(I,M-1),
%_TwoByteSeqStringSetChar(l++,%_StringCharCodeAt(I,M),
}else{
%_TwoByteSeqStringSetChar(l++,h,Q);
}else{
%_TwoByteSeqStringSetChar(l++,g,Q);
Q=%TruncateString(Q,l);
return P+Q;
function URIEscapeJS(S){
var T=$toString(S);
return %URIEscape(T);
function URIUnescapeJS(S){
var T=$toString(S);
return %URIUnescape(T);
function URIDecode(I){
var U=function(h){
if(35<=h&&h<=36)return true;
if(h==38)return true;
if(43<=h&&h<=44)return true;
if(h==47)return true;
if(58<=h&&h<=59)return true;
if(h==61)return true;
if(63<=h&&h<=64)return true;
return false;
var V=$toString(I);
return Decode(V,U);
function URIDecodeComponent(W){
var U=function(h){return false;};
var V=$toString(W);
return Decode(V,U);
function URIEncode(I){
var X=function(h){
if(isAlphaNumeric(h))return true;
if(h==33)return true;
if(35<=h&&h<=36)return true;
if(38<=h&&h<=47)return true;
if(58<=h&&h<=59)return true;
if(h==61)return true;
if(63<=h&&h<=64)return true;
if(h==95)return true;
if(h==126)return true;
return false;
var V=$toString(I);
return Encode(V,X);
function URIEncodeComponent(W){
var X=function(h){
if(isAlphaNumeric(h))return true;
if(h==33)return true;
if(39<=h&&h<=42)return true;
if(45<=h&&h<=46)return true;
if(h==95)return true;
if(h==126)return true;
return false;
var V=$toString(W);
return Encode(V,X);
b.InstallFunctions(a,2,[
"escape",URIEscapeJS,
"unescape",URIUnescapeJS,
"decodeURI",URIDecode,
"decodeURIComponent",URIDecodeComponent,
"encodeURI",URIEncode,
"encodeURIComponent",URIEncodeComponent
var rngstate;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Object;
var d=b.InternalArray;
function MathAbs(e){
e=+e;
return(e>0)?e:0-e;
function MathAcosJS(e){
return %_MathAcos(+e);
function MathAsinJS(e){
return %_MathAsin(+e);
function MathAtanJS(e){
return %_MathAtan(+e);
function MathAtan2JS(g,e){
g=+g;
e=+e;
return %_MathAtan2(g,e);
function MathCeil(e){
return-%_MathFloor(-e);
function MathExp(e){
return %MathExpRT(((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e)));
function MathFloorJS(e){
return %_MathFloor(+e);
function MathLog(e){
return %_MathLogRT(((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e)));
function MathMax(h,i){
var j=%_ArgumentsLength();
if(j==2){
h=((typeof(%IS_VAR(h))==='number')?h:$nonNumberToNumber(h));
i=((typeof(%IS_VAR(i))==='number')?i:$nonNumberToNumber(i));
if(i>h)return i;
if(h>i)return h;
if(h==i){
return(h===0&&%_IsMinusZero(h))?i:h;
return $NaN;
var k=-(1/0);
for(var l=0;l<j;l++){
var m=%_Arguments(l);
m=((typeof(%IS_VAR(m))==='number')?m:$nonNumberToNumber(m));
if((!%_IsSmi(%IS_VAR(m))&&!(m==m))||m>k||(k===0&&m===0&&%_IsMinusZero(k))){
k=m;
return k;
function MathMin(h,i){
var j=%_ArgumentsLength();
if(j==2){
h=((typeof(%IS_VAR(h))==='number')?h:$nonNumberToNumber(h));
i=((typeof(%IS_VAR(i))==='number')?i:$nonNumberToNumber(i));
if(i>h)return h;
if(h>i)return i;
if(h==i){
return(h===0&&%_IsMinusZero(h))?h:i;
return $NaN;
var k=(1/0);
for(var l=0;l<j;l++){
var m=%_Arguments(l);
m=((typeof(%IS_VAR(m))==='number')?m:$nonNumberToNumber(m));
if((!%_IsSmi(%IS_VAR(m))&&!(m==m))||m<k||(k===0&&m===0&&%_IsMinusZero(m))){
k=m;
return k;
function MathPowJS(e,g){
return %_MathPow(((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e)),((typeof(%IS_VAR(g))==='number')?g:$nonNumberToNumber(g)));
function MathRandom(){
var n=(MathImul(18030,rngstate[0]&0xFFFF)+(rngstate[0]>>>16))|0;
rngstate[0]=n;
var o=(MathImul(36969,rngstate[1]&0xFFFF)+(rngstate[1]>>>16))|0;
rngstate[1]=o;
var e=((n<<16)+(o&0xFFFF))|0;
return(e<0?(e+0x100000000):e)*2.3283064365386962890625e-10;
function MathRandomRaw(){
var n=(MathImul(18030,rngstate[0]&0xFFFF)+(rngstate[0]>>>16))|0;
rngstate[0]=n;
var o=(MathImul(36969,rngstate[1]&0xFFFF)+(rngstate[1]>>>16))|0;
rngstate[1]=o;
var e=((n<<16)+(o&0xFFFF))|0;
return e&0x3fffffff;
function MathRound(e){
return %RoundNumber(((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e)));
function MathSqrtJS(e){
return %_MathSqrt(+e);
function MathImul(e,g){
return %NumberImul(((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e)),((typeof(%IS_VAR(g))==='number')?g:$nonNumberToNumber(g)));
function MathSign(e){
e=+e;
if(e>0)return 1;
if(e<0)return-1;
return e;
function MathTrunc(e){
e=+e;
if(e>0)return %_MathFloor(e);
if(e<0)return-%_MathFloor(-e);
return e;
function MathTanh(e){
e=((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e));
if(e===0)return e;
if(!(%_IsSmi(%IS_VAR(e))||((e==e)&&(e!=1/0)&&(e!=-1/0))))return MathSign(e);
var p=MathExp(e);
var q=MathExp(-e);
return(p-q)/(p+q);
function MathAsinh(e){
e=((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e));
if(e===0||!(%_IsSmi(%IS_VAR(e))||((e==e)&&(e!=1/0)&&(e!=-1/0))))return e;
if(e>0)return MathLog(e+%_MathSqrt(e*e+1));
return-MathLog(-e+%_MathSqrt(e*e+1));
function MathAcosh(e){
e=((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e));
if(e<1)return $NaN;
if(!(%_IsSmi(%IS_VAR(e))||((e==e)&&(e!=1/0)&&(e!=-1/0))))return e;
return MathLog(e+%_MathSqrt(e+1)*%_MathSqrt(e-1));
function MathAtanh(e){
e=((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e));
if(e===0)return e;
if(!(%_IsSmi(%IS_VAR(e))||((e==e)&&(e!=1/0)&&(e!=-1/0))))return $NaN;
return 0.5*MathLog((1+e)/(1-e));
function MathHypot(e,g){
var j=%_ArgumentsLength();
var r=new d(j);
var t=0;
for(var l=0;l<j;l++){
var m=%_Arguments(l);
m=((typeof(%IS_VAR(m))==='number')?m:$nonNumberToNumber(m));
if(m===(1/0)||m===-(1/0))return(1/0);
m=MathAbs(m);
if(m>t)t=m;
r[l]=m;
if(t===0)t=1;
var u=0;
var v=0;
for(var l=0;l<j;l++){
var m=r[l]/t;
var w=m*m-v;
var x=u+w;
v=(x-u)-w;
u=x;
return %_MathSqrt(u)*t;
function MathFroundJS(e){
return %MathFround(((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e)));
function MathClz32JS(e){
return %_MathClz32(e>>>0);
function MathCbrt(e){
e=((typeof(%IS_VAR(e))==='number')?e:$nonNumberToNumber(e));
if(e==0||!(%_IsSmi(%IS_VAR(e))||((e==e)&&(e!=1/0)&&(e!=-1/0))))return e;
return e>=0?CubeRoot(e):-CubeRoot(-e);
function CubeRoot(e){
var y=MathFloorJS(%_DoubleHi(e)/3)+0x2A9F7893;
var z=%_ConstructDouble(y,0);
z=(1.0/3.0)*(e/(z*z)+2*z);
z=(1.0/3.0)*(e/(z*z)+2*z);
z=(1.0/3.0)*(e/(z*z)+2*z);
return(1.0/3.0)*(e/(z*z)+2*z);
function MathConstructor(){}
var A=new MathConstructor();
%InternalSetPrototype(A,c.prototype);
%AddNamedProperty(a,"Math",A,2);
%FunctionSetInstanceClassName(MathConstructor,'Math');
%AddNamedProperty(A,symbolToStringTag,"Math",1|2);
b.InstallConstants(A,[
"E",2.7182818284590452354,
"LN10",2.302585092994046,
"LN2",0.6931471805599453,
"LOG2E",1.4426950408889634,
"LOG10E",0.4342944819032518,
"PI",3.1415926535897932,
"SQRT1_2",0.7071067811865476,
"SQRT2",1.4142135623730951
b.InstallFunctions(A,2,[
"random",MathRandom,
"abs",MathAbs,
"acos",MathAcosJS,
"asin",MathAsinJS,
"atan",MathAtanJS,
"ceil",MathCeil,
"exp",MathExp,
"floor",MathFloorJS,
"log",MathLog,
"round",MathRound,
"sqrt",MathSqrtJS,
"atan2",MathAtan2JS,
"pow",MathPowJS,
"max",MathMax,
"min",MathMin,
"imul",MathImul,
"sign",MathSign,
"trunc",MathTrunc,
"tanh",MathTanh,
"asinh",MathAsinh,
"acosh",MathAcosh,
"atanh",MathAtanh,
"hypot",MathHypot,
"fround",MathFroundJS,
"clz32",MathClz32JS,
"cbrt",MathCbrt
%SetForceInlineFlag(MathAbs);
%SetForceInlineFlag(MathAcosJS);
%SetForceInlineFlag(MathAsinJS);
%SetForceInlineFlag(MathAtanJS);
%SetForceInlineFlag(MathAtan2JS);
%SetForceInlineFlag(MathCeil);
%SetForceInlineFlag(MathClz32JS);
%SetForceInlineFlag(MathFloorJS);
%SetForceInlineFlag(MathRandom);
%SetForceInlineFlag(MathSign);
%SetForceInlineFlag(MathSqrtJS);
%SetForceInlineFlag(MathTrunc);
b.Export(function(B){
B.MathAbs=MathAbs;
B.MathExp=MathExp;
B.MathFloor=MathFloorJS;
B.IntRandom=MathRandomRaw;
B.MathMax=MathMax;
B.MathMin=MathMin;
var kMath;
var rempio2result;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Math;
var d;
var e;
b.Import(function(g){
d=g.MathAbs;
e=g.MathExp;
function KernelTan(h,i,j){
var k;
var l;
var m=%_DoubleHi(h);
var n=m&0x7fffffff;
if(n<0x3e300000){
if(((n|%_DoubleLo(h))|(j+1))==0){
return 1/d(h);
}else{
if(j==1){
return h;
}else{
var l=h+i;
var k=%_ConstructDouble(%_DoubleHi(l),0);
var o=i-(k-h);
var p=-1/l;
var q=%_ConstructDouble(%_DoubleHi(p),0);
var r=1+q*k;
return q+p*(r+q*o);
if(n>=0x3fe59428){
if(h<0){
h=-h;
i=-i;
k=kMath[32]-h;
l=kMath[33]-i;
h=k+l;
i=0;
k=h*h;
l=k*k;
var t=kMath[19+1]
+l*(kMath[19+3]
+l*(kMath[19+5]
l*(kMath[19+7]
+l*(kMath[19+9]
+l*kMath[19+11]
))));
var o=k*(kMath[19+2]
+l*(kMath[19+4]
+l*(kMath[19+6]
l*(kMath[19+8]
+l*(kMath[19+10]
+l*kMath[19+12]
)))));
var r=k*h;
t=i+k*(r*(t+o)+i);
t=t+kMath[19+0]
l=h+t;
if(n>=0x3fe59428){
return(1-((m>>30)&2))*
(j-2.0*(h-(l*l/(l+j)-t)));
if(j==1){
return l;
}else{
k=%_ConstructDouble(%_DoubleHi(l),0);
o=t-(k-h);
var p=-1/l;
var q=%_ConstructDouble(%_DoubleHi(p),0);
r=1+q*k;
return q+p*(r+q*o);
function MathSinSlow(h){
var u,v,w;
var m=%_DoubleHi(h);
var n=m&0x7fffffff;
if(n<0x4002d97c){
if(m>0){
var k=h-kMath[1];
if(n!=0x3ff921fb){
v=k-kMath[2];
w=(k-v)-kMath[2];
}else{
k-=kMath[3];
v=k-kMath[4];
w=(k-v)-kMath[4];
u=1;
}else{
var k=h+kMath[1];
if(n!=0x3ff921fb){
v=k+kMath[2];
w=(k-v)+kMath[2];
}else{
k+=kMath[3];
v=k+kMath[4];
w=(k-v)+kMath[4];
u=-1;
}else if(n<=0x413921fb){
var q=d(h);
u=(q*kMath[0]+0.5)|0;
var t=q-u*kMath[1];
var l=u*kMath[2];
v=t-l;
if(n-(%_DoubleHi(v)&0x7ff00000)>0x1000000){
q=t;
l=u*kMath[3];
t=q-l;
l=u*kMath[4]-((q-t)-l);
v=t-l;
if(n-(%_DoubleHi(v)&0x7ff00000)>0x3100000){
q=t;
l=u*kMath[5];
t=q-l;
l=u*kMath[6]-((q-t)-l);
v=t-l;
w=(t-v)-l;
if(m<0){
u=-u;
v=-v;
w=-w;
}else{
u=%RemPiO2(h,rempio2result);
v=rempio2result[0];
w=rempio2result[1];
var x=1-(u&2);
if(u&1){
var n=%_DoubleHi(v)&0x7fffffff;
var k=v*v;
var t=k*(4.16666666666666019037e-02+k*(-1.38888888888741095749e-03+k*(2.48015872894767294178e-05+k*(-2.75573143513906633035e-07+k*(2.08757232129817482790e-09+k*-1.13596475577881948265e-11)))));
if(n<0x3fd33333){
return(1-(0.5*k-(k*t-v*w)))*x;
}else{
var y;
if(n>0x3fe90000){
y=0.28125;
}else{
y=%_ConstructDouble(%_DoubleHi(0.25*v),0);
var z=0.5*k-y;
return(1-y-(z-(k*t-v*w)))*x;
}else{
var k=v*v;
var o=k*v;
var t=8.33333333332248946124e-03+k*(-1.98412698298579493134e-04+k*(2.75573137070700676789e-06+k*(-2.50507602534068634195e-08+k*1.58969099521155010221e-10)));
return(v-((k*(0.5*w-o*t)-w)-o*-1.66666666666666324348e-01))*x;
function MathCosSlow(h){
var u,v,w;
var m=%_DoubleHi(h);
var n=m&0x7fffffff;
if(n<0x4002d97c){
if(m>0){
var k=h-kMath[1];
if(n!=0x3ff921fb){
v=k-kMath[2];
w=(k-v)-kMath[2];
}else{
k-=kMath[3];
v=k-kMath[4];
w=(k-v)-kMath[4];
u=1;
}else{
var k=h+kMath[1];
if(n!=0x3ff921fb){
v=k+kMath[2];
w=(k-v)+kMath[2];
}else{
k+=kMath[3];
v=k+kMath[4];
w=(k-v)+kMath[4];
u=-1;
}else if(n<=0x413921fb){
var q=d(h);
u=(q*kMath[0]+0.5)|0;
var t=q-u*kMath[1];
var l=u*kMath[2];
v=t-l;
if(n-(%_DoubleHi(v)&0x7ff00000)>0x1000000){
q=t;
l=u*kMath[3];
t=q-l;
l=u*kMath[4]-((q-t)-l);
v=t-l;
if(n-(%_DoubleHi(v)&0x7ff00000)>0x3100000){
q=t;
l=u*kMath[5];
t=q-l;
l=u*kMath[6]-((q-t)-l);
v=t-l;
w=(t-v)-l;
if(m<0){
u=-u;
v=-v;
w=-w;
}else{
u=%RemPiO2(h,rempio2result);
v=rempio2result[0];
w=rempio2result[1];
if(u&1){
var x=(u&2)-1;
var k=v*v;
var o=k*v;
var t=8.33333333332248946124e-03+k*(-1.98412698298579493134e-04+k*(2.75573137070700676789e-06+k*(-2.50507602534068634195e-08+k*1.58969099521155010221e-10)));
return(v-((k*(0.5*w-o*t)-w)-o*-1.66666666666666324348e-01))*x;
}else{
var x=1-(u&2);
var n=%_DoubleHi(v)&0x7fffffff;
var k=v*v;
var t=k*(4.16666666666666019037e-02+k*(-1.38888888888741095749e-03+k*(2.48015872894767294178e-05+k*(-2.75573143513906633035e-07+k*(2.08757232129817482790e-09+k*-1.13596475577881948265e-11)))));
if(n<0x3fd33333){
return(1-(0.5*k-(k*t-v*w)))*x;
}else{
var y;
if(n>0x3fe90000){
y=0.28125;
}else{
y=%_ConstructDouble(%_DoubleHi(0.25*v),0);
var z=0.5*k-y;
return(1-y-(z-(k*t-v*w)))*x;
function MathSin(h){
h=+h;
if((%_DoubleHi(h)&0x7fffffff)<=0x3fe921fb){
var k=h*h;
var o=k*h;
var t=8.33333333332248946124e-03+k*(-1.98412698298579493134e-04+k*(2.75573137070700676789e-06+k*(-2.50507602534068634195e-08+k*1.58969099521155010221e-10)));
return(h-((k*(0.5*0-o*t)-0)-o*-1.66666666666666324348e-01));
return+MathSinSlow(h);
function MathCos(h){
h=+h;
if((%_DoubleHi(h)&0x7fffffff)<=0x3fe921fb){
var n=%_DoubleHi(h)&0x7fffffff;
var k=h*h;
var t=k*(4.16666666666666019037e-02+k*(-1.38888888888741095749e-03+k*(2.48015872894767294178e-05+k*(-2.75573143513906633035e-07+k*(2.08757232129817482790e-09+k*-1.13596475577881948265e-11)))));
if(n<0x3fd33333){
return(1-(0.5*k-(k*t-h*0)));
}else{
var y;
if(n>0x3fe90000){
y=0.28125;
}else{
y=%_ConstructDouble(%_DoubleHi(0.25*h),0);
var z=0.5*k-y;
return(1-y-(z-(k*t-h*0)));
return+MathCosSlow(h);
function MathTan(h){
h=h*1;
if((%_DoubleHi(h)&0x7fffffff)<=0x3fe921fb){
return KernelTan(h,0,1);
var u,v,w;
var m=%_DoubleHi(h);
var n=m&0x7fffffff;
if(n<0x4002d97c){
if(m>0){
var k=h-kMath[1];
if(n!=0x3ff921fb){
v=k-kMath[2];
w=(k-v)-kMath[2];
}else{
k-=kMath[3];
v=k-kMath[4];
w=(k-v)-kMath[4];
u=1;
}else{
var k=h+kMath[1];
if(n!=0x3ff921fb){
v=k+kMath[2];
w=(k-v)+kMath[2];
}else{
k+=kMath[3];
v=k+kMath[4];
w=(k-v)+kMath[4];
u=-1;
}else if(n<=0x413921fb){
var q=d(h);
u=(q*kMath[0]+0.5)|0;
var t=q-u*kMath[1];
var l=u*kMath[2];
v=t-l;
if(n-(%_DoubleHi(v)&0x7ff00000)>0x1000000){
q=t;
l=u*kMath[3];
t=q-l;
l=u*kMath[4]-((q-t)-l);
v=t-l;
if(n-(%_DoubleHi(v)&0x7ff00000)>0x3100000){
q=t;
l=u*kMath[5];
t=q-l;
l=u*kMath[6]-((q-t)-l);
v=t-l;
w=(t-v)-l;
if(m<0){
u=-u;
v=-v;
w=-w;
}else{
u=%RemPiO2(h,rempio2result);
v=rempio2result[0];
w=rempio2result[1];
return KernelTan(v,w,(u&1)?-1:1);
function MathLog1p(h){
h=h*1;
var m=%_DoubleHi(h);
var A=m&0x7fffffff;
var B=1;
var C=h;
var D=1;
var E=0;
var F=h;
if(m<0x3fda827a){
if(A>=0x3ff00000){
if(h===-1){
return-(1/0);
}else{
return $NaN;
}else if(A<0x3c900000){
return h;
}else if(A<0x3e200000){
return h-h*h*0.5;
if((m>0)||(m<=-0x402D413D)){
B=0;
if(m>=0x7ff00000)return h;
if(B!==0){
if(m<0x43400000){
F=1+h;
D=%_DoubleHi(F);
B=(D>>20)-1023;
E=(B>0)?1-(F-h):h-(F-1);
E=E/F;
}else{
D=%_DoubleHi(F);
B=(D>>20)-1023;
D=D&0xfffff;
if(D<0x6a09e){
F=%_ConstructDouble(D|0x3ff00000,%_DoubleLo(F));
}else{
++B;
F=%_ConstructDouble(D|0x3fe00000,%_DoubleLo(F));
D=(0x00100000-D)>>2;
C=F-1;
var G=0.5*C*C;
if(D===0){
if(C===0){
if(B===0){
return 0.0;
}else{
return B*kMath[34]+(E+B*kMath[35]);
var H=G*(1-kMath[36]*C);
if(B===0){
return C-H;
}else{
return B*kMath[34]-((H-(B*kMath[35]+E))-C);
var r=C/(2+C);
var k=r*r;
var H=k*((kMath[37+0])
+k*((kMath[37+1])
((kMath[37+2])
+k*((kMath[37+3])
((kMath[37+4])
+k*((kMath[37+5])
+k*(kMath[37+6])
))))));
if(B===0){
return C-(G-r*(G+H));
}else{
return B*kMath[34]-((G-(r*(G+H)+(B*kMath[35]+E)))-C);
function MathExpm1(h){
h=h*1;
var i;
var I;
var J;
var B;
var q;
var E;
var m=%_DoubleHi(h);
var K=m&0x80000000;
var i=(K===0)?h:-h;
m&=0x7fffffff;
if(m>=0x4043687a){
if(m>=0x40862e42){
if(m>=0x7ff00000){
return(h===-(1/0))?-1:h;
if(h>kMath[44])return(1/0);
if(K!=0)return-1;
if(m>0x3fd62e42){
if(m<0x3ff0a2b2){
if(K===0){
I=h-kMath[34];
J=kMath[35];
B=1;
}else{
I=h+kMath[34];
J=-kMath[35];
B=-1;
}else{
B=(kMath[45]*h+((K===0)?0.5:-0.5))|0;
q=B;
I=h-q*kMath[34];
J=q*kMath[35];
h=I-J;
E=(I-h)-J;
}else if(m<0x3c900000){
return h;
}else{
B=0;
var L=0.5*h;
var M=h*L;
var N=1+M*((kMath[46+0])
+M*((kMath[46+1])
((kMath[46+2])
+M*((kMath[46+3])
+M*(kMath[46+4])
))));
q=3-N*L;
var O=M*((N-q)/(6-h*q));
if(B===0){
return h-(h*O-M);
}else{
O=(h*(O-E)-E);
O-=M;
if(B===-1)return 0.5*(h-O)-0.5;
if(B===1){
if(h<-0.25)return-2*(O-(h+0.5));
return 1+2*(h-O);
if(B<=-2||B>56){
i=1-(O-h);
i=%_ConstructDouble(%_DoubleHi(i)+(B<<20),%_DoubleLo(i));
return i-1;
if(B<20){
q=%_ConstructDouble(0x3ff00000-(0x200000>>B),0);
i=q-(O-h);
i=%_ConstructDouble(%_DoubleHi(i)+(B<<20),%_DoubleLo(i));
}else{
q=%_ConstructDouble((0x3ff-B)<<20,0);
i=h-(O+q);
i+=1;
i=%_ConstructDouble(%_DoubleHi(i)+(B<<20),%_DoubleLo(i));
return i;
function MathSinh(h){
h=h*1;
var P=(h<0)?-0.5:0.5;
var A=d(h);
if(A<22){
if(A<3.725290298461914e-9)return h;
var q=MathExpm1(A);
if(A<1)return P*(2*q-q*q/(q+1));
return P*(q+q/(q+1));
if(A<709.7822265625)return P*e(A);
if(A<=kMath[51]){
var l=e(0.5*A);
var q=P*l;
return q*l;
return h*(1/0);
function MathCosh(h){
h=h*1;
var n=%_DoubleHi(h)&0x7fffffff;
if(n<0x3fd62e43){
var q=MathExpm1(d(h));
var l=1+q;
if(n<0x3c800000)return l;
return 1+(q*q)/(l+l);
if(n<0x40360000){
var q=e(d(h));
return 0.5*q+0.5/q;
if(n<0x40862e42)return 0.5*e(d(h));
if(d(h)<=kMath[51]){
var l=e(0.5*d(h));
var q=0.5*l;
return q*l;
if((!%_IsSmi(%IS_VAR(h))&&!(h==h)))return h;
return(1/0);
function MathLog10(h){
h=h*1;
var m=%_DoubleHi(h);
var Q=%_DoubleLo(h);
var B=0;
if(m<0x00100000){
if(((m&0x7fffffff)|Q)===0)return-(1/0);
if(m<0)return $NaN;
B-=54;
h*=18014398509481984;
m=%_DoubleHi(h);
Q=%_DoubleLo(h);
if(m>=0x7ff00000)return h;
B+=(m>>20)-1023;
var R=(B&0x80000000)>>>31;
m=(m&0x000fffff)|((0x3ff-R)<<20);
var i=B+R;
h=%_ConstructDouble(m,Q);
var k=i*kMath[54]+kMath[52]*%_MathLogRT(h);
return k+i*kMath[53];
function MathLog2(h){
h=h*1;
var A=d(h);
var m=%_DoubleHi(h);
var Q=%_DoubleLo(h);
var n=m&0x7fffffff;
if((n|Q)==0)return-(1/0);
if(m<0)return $NaN;
if(n>=0x7ff00000)return h;
var u=0;
if(n<0x00100000){
A*=9007199254740992;
u-=53;
n=%_DoubleHi(A);
u+=(n>>20)-0x3ff;
var S=n&0x000fffff;
n=S|0x3ff00000;
var T=1;
var U=0;
var V=0;
if(S>0x3988e){
if(S<0xbb67a){
T=1.5;
U=kMath[64];
V=kMath[65];
}else{
u+=1;
n-=0x00100000;
A=%_ConstructDouble(n,%_DoubleLo(A));
var F=A-T;
var o=1/(A+T);
var W=F*o;
var X=%_ConstructDouble(%_DoubleHi(W),0);
var Y=%_ConstructDouble(%_DoubleHi(A+T),0)
var Z=A-(Y-T);
var aa=o*((F-X*Y)-X*Z);
var ab=W*W;
var t=ab*ab*((kMath[55+0])
+ab*((kMath[55+1])
+ab*((kMath[55+2])
+ab*(
(kMath[55+3])
+ab*((kMath[55+4])
+ab*(kMath[55+5])
)))));
t+=aa*(X+W);
ab=X*X;
Y=%_ConstructDouble(%_DoubleHi(3.0+ab+t),0);
Z=t-((Y-3.0)-ab);
F=X*Y;
o=aa*Y+Z*W;
p_h=%_ConstructDouble(%_DoubleHi(F+o),0);
p_l=o-(p_h-F);
z_h=kMath[62]*p_h;
z_l=kMath[63]*p_h+p_l*kMath[61]+V;
var q=u;
var ac=%_ConstructDouble(%_DoubleHi(((z_h+z_l)+U)+q),0);
var ad=z_l-(((ac-q)-U)-z_h);
return ac+ad;
b.InstallFunctions(c,2,[
"cos",MathCos,
"sin",MathSin,
"tan",MathTan,
"sinh",MathSinh,
"cosh",MathCosh,
"log10",MathLog10,
"log2",MathLog2,
"log1p",MathLog1p,
"expm1",MathExpm1
%SetForceInlineFlag(MathSin);
%SetForceInlineFlag(MathCos);
var $createDate;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Date;
var d=b.InternalArray;
var e;
var g;
var h;
b.Import(function(i){
e=i.IsFinite;
g=i.MathAbs;
h=i.MathFloor;
var j=$NaN;
var k;
function LocalTimezone(l){
if((!%_IsSmi(%IS_VAR(l))&&!(l==l)))return"";
CheckDateCacheCurrent();
if(l==j){
return k;
var m=%DateLocalTimezone(l);
j=l;
k=m;
return m;
function UTC(n){
if((!%_IsSmi(%IS_VAR(n))&&!(n==n)))return n;
return %DateToUTC(n);
function MakeTime(o,p,q,r){
if(!e(o))return $NaN;
if(!e(p))return $NaN;
if(!e(q))return $NaN;
if(!e(r))return $NaN;
return(%_IsSmi(%IS_VAR(o))?o:%NumberToInteger($toNumber(o)))*3600000
+(%_IsSmi(%IS_VAR(p))?p:%NumberToInteger($toNumber(p)))*60000
+(%_IsSmi(%IS_VAR(q))?q:%NumberToInteger($toNumber(q)))*1000
+(%_IsSmi(%IS_VAR(r))?r:%NumberToInteger($toNumber(r)));
function TimeInYear(t){
return DaysInYear(t)*86400000;
function MakeDay(t,u,v){
if(!e(t)||!e(u)||!e(v))return $NaN;
t=(%_IsSmi(%IS_VAR(t))?t:%NumberToIntegerMapMinusZero($toNumber(t)));
u=(%_IsSmi(%IS_VAR(u))?u:%NumberToIntegerMapMinusZero($toNumber(u)));
v=(%_IsSmi(%IS_VAR(v))?v:%NumberToIntegerMapMinusZero($toNumber(v)));
if(t<-1000000||t>1000000||
u<-10000000||u>10000000){
return $NaN;
return %DateMakeDay(t|0,u|0)+v-1;
function MakeDate(w,n){
var n=w*86400000+n;
if(g(n)>8640002592000000)return $NaN;
return n;
function TimeClip(n){
if(!e(n))return $NaN;
if(g(n)>8640000000000000)return $NaN;
return(%_IsSmi(%IS_VAR(n))?n:%NumberToInteger($toNumber(n)));
var x={
time:0,
string:null
function DateConstructor(t,u,v,y,z,A,r){
if(!%_IsConstructCall()){
return %_CallFunction(new c(),DateToString);
var B=%_ArgumentsLength();
var C;
if(B==0){
C=%DateCurrentTime();
(%DateSetValue(this,C,1));
}else if(B==1){
if((typeof(t)==='number')){
C=t;
}else if((typeof(t)==='string')){
CheckDateCacheCurrent();
var D=x;
if(D.string===t){
C=D.time;
}else{
C=DateParse(t);
if(!(!%_IsSmi(%IS_VAR(C))&&!(C==C))){
D.time=C;
D.string=t;
}else{
var n=$toPrimitive(t,1);
C=(typeof(n)==='string')?DateParse(n):$toNumber(n);
(%DateSetValue(this,C,1));
}else{
t=$toNumber(t);
u=$toNumber(u);
v=B>2?$toNumber(v):1;
y=B>3?$toNumber(y):0;
z=B>4?$toNumber(z):0;
A=B>5?$toNumber(A):0;
r=B>6?$toNumber(r):0;
t=(!(!%_IsSmi(%IS_VAR(t))&&!(t==t))&&
0<=(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t)))&&
(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t)))<=99)?1900+(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t))):t;
var w=MakeDay(t,u,v);
var n=MakeTime(y,z,A,r);
C=MakeDate(w,n);
(%DateSetValue(this,C,0));
var E=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
var F=['Jan','Feb','Mar','Apr','May','Jun',
'Jul','Aug','Sep','Oct','Nov','Dec'];
function TwoDigitString(C){
return C<10?"0"+C:""+C;
function DateString(v){
if(!%_IsDate(v))%_ThrowNotDateError();
return E[(%_DateField(v,4))]+' '
+F[(%_DateField(v,2))]+' '
+TwoDigitString((%_DateField(v,3)))+' '
+(%_DateField(v,1));
var G=['Sunday','Monday','Tuesday','Wednesday',
'Thursday','Friday','Saturday'];
var H=['January','February','March','April','May','June',
'July','August','September','October','November','December'];
function LongDateString(v){
if(!%_IsDate(v))%_ThrowNotDateError();
return G[(%_DateField(v,4))]+', '
+H[(%_DateField(v,2))]+' '
+TwoDigitString((%_DateField(v,3)))+', '
+(%_DateField(v,1));
function TimeString(v){
if(!%_IsDate(v))%_ThrowNotDateError();
return TwoDigitString((%_DateField(v,5)))+':'
+TwoDigitString((%_DateField(v,6)))+':'
+TwoDigitString((%_DateField(v,7)));
function TimeStringUTC(v){
if(!%_IsDate(v))%_ThrowNotDateError();
return TwoDigitString((%_DateField(v,15)))+':'
+TwoDigitString((%_DateField(v,16)))+':'
+TwoDigitString((%_DateField(v,17)));
function LocalTimezoneString(v){
if(!%_IsDate(v))%_ThrowNotDateError();
var m=LocalTimezone((%_DateField(v,0)));
var I=-(%_DateField(v,21));
var J=(I>=0)?1:-1;
var y=h((J*I)/60);
var p=h((J*I)%60);
var K=' GMT'+((J==1)?'+':'-')+
TwoDigitString(y)+TwoDigitString(p);
return K+' ('+m+')';
function DatePrintString(v){
if(!%_IsDate(v))%_ThrowNotDateError();
return DateString(v)+' '+TimeString(v);
var L=new d(8);
function DateParse(M){
var N=%DateParseString($toString(M),L);
if((N===null))return $NaN;
var w=MakeDay(N[0],N[1],N[2]);
var n=MakeTime(N[3],N[4],N[5],N[6]);
var v=MakeDate(w,n);
if((N[7]===null)){
return TimeClip(UTC(v));
}else{
return TimeClip(v-N[7]*1000);
function DateUTC(t,u,v,y,z,A,r){
t=$toNumber(t);
u=$toNumber(u);
var B=%_ArgumentsLength();
v=B>2?$toNumber(v):1;
y=B>3?$toNumber(y):0;
z=B>4?$toNumber(z):0;
A=B>5?$toNumber(A):0;
r=B>6?$toNumber(r):0;
t=(!(!%_IsSmi(%IS_VAR(t))&&!(t==t))&&
0<=(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t)))&&
(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t)))<=99)?1900+(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t))):t;
var w=MakeDay(t,u,v);
var n=MakeTime(y,z,A,r);
return TimeClip(MakeDate(w,n));
function DateNow(){
return %DateCurrentTime();
function DateToString(){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0))
if((!%_IsSmi(%IS_VAR(l))&&!(l==l)))return'Invalid Date';
var O=LocalTimezoneString(this)
return DatePrintString(this)+O;
function DateToDateString(){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
if((!%_IsSmi(%IS_VAR(l))&&!(l==l)))return'Invalid Date';
return DateString(this);
function DateToTimeString(){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
if((!%_IsSmi(%IS_VAR(l))&&!(l==l)))return'Invalid Date';
var O=LocalTimezoneString(this);
return TimeString(this)+O;
function DateToLocaleString(){
if(!%_IsDate(this))%_ThrowNotDateError();
return %_CallFunction(this,DateToString);
function DateToLocaleDateString(){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
if((!%_IsSmi(%IS_VAR(l))&&!(l==l)))return'Invalid Date';
return LongDateString(this);
function DateToLocaleTimeString(){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
if((!%_IsSmi(%IS_VAR(l))&&!(l==l)))return'Invalid Date';
return TimeString(this);
function DateValueOf(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,0));
function DateGetTime(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,0));
function DateGetFullYear(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,1));
function DateGetUTCFullYear(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,11));
function DateGetMonth(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,2));
function DateGetUTCMonth(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,12));
function DateGetDate(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,3));
function DateGetUTCDate(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,13));
function DateGetDay(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,4));
function DateGetUTCDay(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,14));
function DateGetHours(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,5));
function DateGetUTCHours(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,15));
function DateGetMinutes(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,6));
function DateGetUTCMinutes(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,16));
function DateGetSeconds(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,7));
function DateGetUTCSeconds(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,17))
function DateGetMilliseconds(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,8));
function DateGetUTCMilliseconds(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,18));
function DateGetTimezoneOffset(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,21));
function DateSetTime(r){
if(!%_IsDate(this))%_ThrowNotDateError();
(%DateSetValue(this,$toNumber(r),1));
return(%_DateField(this,0));
function DateSetMilliseconds(r){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0)+%_DateField(this,21));
r=$toNumber(r);
var n=MakeTime((%_DateField(this,5)),(%_DateField(this,6)),(%_DateField(this,7)),r);
return(%DateSetValue(this,MakeDate((%_DateField(this,9)),n),0));
function DateSetUTCMilliseconds(r){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
r=$toNumber(r);
var n=MakeTime((%_DateField(this,15)),
(%_DateField(this,16)),
(%_DateField(this,17)),
return(%DateSetValue(this,MakeDate((%_DateField(this,19)),n),1));
function DateSetSeconds(q,r){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0)+%_DateField(this,21));
q=$toNumber(q);
r=%_ArgumentsLength()<2?(%_DateField(this,8)):$toNumber(r);
var n=MakeTime((%_DateField(this,5)),(%_DateField(this,6)),q,r);
return(%DateSetValue(this,MakeDate((%_DateField(this,9)),n),0));
function DateSetUTCSeconds(q,r){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
q=$toNumber(q);
r=%_ArgumentsLength()<2?(%_DateField(this,18)):$toNumber(r);
var n=MakeTime((%_DateField(this,15)),(%_DateField(this,16)),q,r);
return(%DateSetValue(this,MakeDate((%_DateField(this,19)),n),1));
function DateSetMinutes(p,q,r){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0)+%_DateField(this,21));
p=$toNumber(p);
var B=%_ArgumentsLength();
q=B<2?(%_DateField(this,7)):$toNumber(q);
r=B<3?(%_DateField(this,8)):$toNumber(r);
var n=MakeTime((%_DateField(this,5)),p,q,r);
return(%DateSetValue(this,MakeDate((%_DateField(this,9)),n),0));
function DateSetUTCMinutes(p,q,r){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
p=$toNumber(p);
var B=%_ArgumentsLength();
q=B<2?(%_DateField(this,17)):$toNumber(q);
r=B<3?(%_DateField(this,18)):$toNumber(r);
var n=MakeTime((%_DateField(this,15)),p,q,r);
return(%DateSetValue(this,MakeDate((%_DateField(this,19)),n),1));
function DateSetHours(o,p,q,r){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0)+%_DateField(this,21));
o=$toNumber(o);
var B=%_ArgumentsLength();
p=B<2?(%_DateField(this,6)):$toNumber(p);
q=B<3?(%_DateField(this,7)):$toNumber(q);
r=B<4?(%_DateField(this,8)):$toNumber(r);
var n=MakeTime(o,p,q,r);
return(%DateSetValue(this,MakeDate((%_DateField(this,9)),n),0));
function DateSetUTCHours(o,p,q,r){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
o=$toNumber(o);
var B=%_ArgumentsLength();
p=B<2?(%_DateField(this,16)):$toNumber(p);
q=B<3?(%_DateField(this,17)):$toNumber(q);
r=B<4?(%_DateField(this,18)):$toNumber(r);
var n=MakeTime(o,p,q,r);
return(%DateSetValue(this,MakeDate((%_DateField(this,19)),n),1));
function DateSetDate(v){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0)+%_DateField(this,21));
v=$toNumber(v);
var w=MakeDay((%_DateField(this,1)),(%_DateField(this,2)),v);
return(%DateSetValue(this,MakeDate(w,(%_DateField(this,10))),0));
function DateSetUTCDate(v){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
v=$toNumber(v);
var w=MakeDay((%_DateField(this,11)),(%_DateField(this,12)),v);
return(%DateSetValue(this,MakeDate(w,(%_DateField(this,20))),1));
function DateSetMonth(u,v){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0)+%_DateField(this,21));
u=$toNumber(u);
v=%_ArgumentsLength()<2?(%_DateField(this,3)):$toNumber(v);
var w=MakeDay((%_DateField(this,1)),u,v);
return(%DateSetValue(this,MakeDate(w,(%_DateField(this,10))),0));
function DateSetUTCMonth(u,v){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
u=$toNumber(u);
v=%_ArgumentsLength()<2?(%_DateField(this,13)):$toNumber(v);
var w=MakeDay((%_DateField(this,11)),u,v);
return(%DateSetValue(this,MakeDate(w,(%_DateField(this,20))),1));
function DateSetFullYear(t,u,v){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0)+%_DateField(this,21));
t=$toNumber(t);
var B=%_ArgumentsLength();
var n;
if((!%_IsSmi(%IS_VAR(l))&&!(l==l))){
u=B<2?0:$toNumber(u);
v=B<3?1:$toNumber(v);
n=0;
}else{
u=B<2?(%_DateField(this,2)):$toNumber(u);
v=B<3?(%_DateField(this,3)):$toNumber(v);
n=(%_DateField(this,10));
var w=MakeDay(t,u,v);
return(%DateSetValue(this,MakeDate(w,n),0));
function DateSetUTCFullYear(t,u,v){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
t=$toNumber(t);
var B=%_ArgumentsLength();
var n;
if((!%_IsSmi(%IS_VAR(l))&&!(l==l))){
u=B<2?0:$toNumber(u);
v=B<3?1:$toNumber(v);
n=0;
}else{
u=B<2?(%_DateField(this,12)):$toNumber(u);
v=B<3?(%_DateField(this,13)):$toNumber(v);
n=(%_DateField(this,20));
var w=MakeDay(t,u,v);
return(%DateSetValue(this,MakeDate(w,n),1));
function DateToUTCString(){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
if((!%_IsSmi(%IS_VAR(l))&&!(l==l)))return'Invalid Date';
return E[(%_DateField(this,14))]+', '
+TwoDigitString((%_DateField(this,13)))+' '
+F[(%_DateField(this,12))]+' '
+(%_DateField(this,11))+' '
+TimeStringUTC(this)+' GMT';
function DateGetYear(){
if(!%_IsDate(this))%_ThrowNotDateError();
return(%_DateField(this,1))-1900;
function DateSetYear(t){
if(!%_IsDate(this))%_ThrowNotDateError();
t=$toNumber(t);
if((!%_IsSmi(%IS_VAR(t))&&!(t==t)))return(%DateSetValue(this,$NaN,1));
t=(0<=(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t)))&&(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t)))<=99)
?1900+(%_IsSmi(%IS_VAR(t))?t:%NumberToInteger($toNumber(t))):t;
var l=(%_DateField(this,0)+%_DateField(this,21));
var u,v,n;
if((!%_IsSmi(%IS_VAR(l))&&!(l==l))){
u=0;
v=1;
n=0;
}else{
u=(%_DateField(this,2));
v=(%_DateField(this,3));
n=(%_DateField(this,10));
var w=MakeDay(t,u,v);
return(%DateSetValue(this,MakeDate(w,n),0));
function DateToGMTString(){
return %_CallFunction(this,DateToUTCString);
function PadInt(P,Q){
if(Q==1)return P;
return P<%_MathPow(10,Q-1)?'0'+PadInt(P,Q-1):P;
function DateToISOString(){
if(!%_IsDate(this))%_ThrowNotDateError();
var l=(%_DateField(this,0));
if((!%_IsSmi(%IS_VAR(l))&&!(l==l)))throw MakeRangeError(137);
var t=(%_DateField(this,11));
var R;
if(t>=0&&t<=9999){
R=PadInt(t,4);
}else{
if(t<0){
R="-"+PadInt(-t,6);
}else{
R="+"+PadInt(t,6);
return R+
'-'+PadInt((%_DateField(this,12))+1,2)+
'-'+PadInt((%_DateField(this,13)),2)+
'T'+PadInt((%_DateField(this,15)),2)+
':'+PadInt((%_DateField(this,16)),2)+
':'+PadInt((%_DateField(this,17)),2)+
'.'+PadInt((%_DateField(this,18)),3)+
'Z';
function DateToJSON(S){
var T=$toObject(this);
var U=$defaultNumber(T);
if((typeof(U)==='number')&&!(%_IsSmi(%IS_VAR(U))||((U==U)&&(U!=1/0)&&(U!=-1/0)))){
return null;
return T.toISOString();
var V;
var W=$NaN;
function CheckDateCacheCurrent(){
if(!V){
V=%DateCacheVersion();
if(!V)return;
if(V[0]==W){
return;
W=V[0];
j=$NaN;
k=(void 0);
x.time=$NaN;
x.string=null;
function CreateDate(n){
var v=new c();
v.setTime(n);
return v;
%SetCode(c,DateConstructor);
%FunctionSetPrototype(c,new c($NaN));
b.InstallFunctions(c,2,[
"UTC",DateUTC,
"parse",DateParse,
"now",DateNow
%AddNamedProperty(c.prototype,"constructor",c,2);
b.InstallFunctions(c.prototype,2,[
"toString",DateToString,
"toDateString",DateToDateString,
"toTimeString",DateToTimeString,
"toLocaleString",DateToLocaleString,
"toLocaleDateString",DateToLocaleDateString,
"toLocaleTimeString",DateToLocaleTimeString,
"valueOf",DateValueOf,
"getTime",DateGetTime,
"getFullYear",DateGetFullYear,
"getUTCFullYear",DateGetUTCFullYear,
"getMonth",DateGetMonth,
"getUTCMonth",DateGetUTCMonth,
"getDate",DateGetDate,
"getUTCDate",DateGetUTCDate,
"getDay",DateGetDay,
"getUTCDay",DateGetUTCDay,
"getHours",DateGetHours,
"getUTCHours",DateGetUTCHours,
"getMinutes",DateGetMinutes,
"getUTCMinutes",DateGetUTCMinutes,
"getSeconds",DateGetSeconds,
"getUTCSeconds",DateGetUTCSeconds,
"getMilliseconds",DateGetMilliseconds,
"getUTCMilliseconds",DateGetUTCMilliseconds,
"getTimezoneOffset",DateGetTimezoneOffset,
"setTime",DateSetTime,
"setMilliseconds",DateSetMilliseconds,
"setUTCMilliseconds",DateSetUTCMilliseconds,
"setSeconds",DateSetSeconds,
"setUTCSeconds",DateSetUTCSeconds,
"setMinutes",DateSetMinutes,
"setUTCMinutes",DateSetUTCMinutes,
"setHours",DateSetHours,
"setUTCHours",DateSetUTCHours,
"setDate",DateSetDate,
"setUTCDate",DateSetUTCDate,
"setMonth",DateSetMonth,
"setUTCMonth",DateSetUTCMonth,
"setFullYear",DateSetFullYear,
"setUTCFullYear",DateSetUTCFullYear,
"toGMTString",DateToGMTString,
"toUTCString",DateToUTCString,
"getYear",DateGetYear,
"setYear",DateSetYear,
"toISOString",DateToISOString,
"toJSON",DateToJSON
$createDate=CreateDate;
var $regexpLastMatchInfoOverride;
var harmony_regexps=false;
var harmony_unicode_regexps=false;
(function(a,b){
%CheckIsBootstrapping();
var c=a.RegExp;
var d=b.InternalPackedArray;
var e=new d(
(void 0),
$regexpLastMatchInfoOverride=null;
function DoConstructRegExp(g,h,i){
if((%_IsRegExp(h))){
if(!(i===(void 0)))throw MakeTypeError(94);
i=(h.global?'g':'')
+(h.ignoreCase?'i':'')
+(h.multiline?'m':'');
if(harmony_unicode_regexps)
i+=(h.unicode?'u':'');
if(harmony_regexps)
i+=(h.sticky?'y':'');
h=h.source;
h=(h===(void 0))?'':$toString(h);
i=(i===(void 0))?'':$toString(i);
%RegExpInitializeAndCompile(g,h,i);
function RegExpConstructor(h,i){
if(%_IsConstructCall()){
DoConstructRegExp(this,h,i);
}else{
if((%_IsRegExp(h))&&(i===(void 0))){
return h;
return new c(h,i);
function RegExpCompileJS(h,i){
if(this==c.prototype){
throw MakeTypeError(33,
'RegExp.prototype.compile',this);
if((h===(void 0))&&%_ArgumentsLength()!=0){
DoConstructRegExp(this,'undefined',i);
}else{
DoConstructRegExp(this,h,i);
function DoRegExpExec(j,k,l){
var m=%_RegExpExec(j,k,l,e);
if(m!==null)$regexpLastMatchInfoOverride=null;
return m;
function RegExpExecNoTests(j,k,n){
var o=%_RegExpExec(j,k,n,e);
if(o!==null){
$regexpLastMatchInfoOverride=null;
var p=((o)[0])>>1;
var n=o[3];
var q=o[4];
var r=%_SubString(k,n,q);
var m=%_RegExpConstructResult(p,n,k);
m[0]=r;
if(p==1)return m;
var t=3+2;
for(var u=1;u<p;u++){
n=o[t++];
if(n!=-1){
q=o[t];
m[u]=%_SubString(k,n,q);
t++;
return m;
j.lastIndex=0;
return null;
function RegExpExecJS(k){
if(!(%_IsRegExp(this))){
throw MakeTypeError(33,
'RegExp.prototype.exec',this);
k=((typeof(%IS_VAR(k))==='string')?k:$nonStringToString(k));
var v=this.lastIndex;
var u=(%_IsSmi(%IS_VAR(v))?v:%NumberToInteger($toNumber(v)));
var w=this.global||(harmony_regexps&&this.sticky);
if(w){
if(u<0||u>k.length){
this.lastIndex=0;
return null;
}else{
u=0;
var x=%_RegExpExec(this,k,u,e);
if((x===null)){
this.lastIndex=0;
return null;
$regexpLastMatchInfoOverride=null;
if(w){
this.lastIndex=e[4];
var p=((x)[0])>>1;
var n=x[3];
var q=x[4];
var r=%_SubString(k,n,q);
var m=%_RegExpConstructResult(p,n,k);
m[0]=r;
if(p==1)return m;
var t=3+2;
for(var u=1;u<p;u++){
n=x[t++];
if(n!=-1){
q=x[t];
m[u]=%_SubString(k,n,q);
t++;
return m;
var y;
var z;
function RegExpTest(k){
if(!(%_IsRegExp(this))){
throw MakeTypeError(33,
'RegExp.prototype.test',this);
k=((typeof(%IS_VAR(k))==='string')?k:$nonStringToString(k));
var v=this.lastIndex;
var u=(%_IsSmi(%IS_VAR(v))?v:%NumberToInteger($toNumber(v)));
if(this.global||(harmony_regexps&&this.sticky)){
if(u<0||u>k.length){
this.lastIndex=0;
return false;
var x=%_RegExpExec(this,k,u,e);
if((x===null)){
this.lastIndex=0;
return false;
$regexpLastMatchInfoOverride=null;
this.lastIndex=e[4];
return true;
}else{
var j=this;
if(j.source.length>=3&&
%_StringCharCodeAt(j.source,0)==46&&
%_StringCharCodeAt(j.source,1)==42&&
%_StringCharCodeAt(j.source,2)!=63){
j=TrimRegExp(j);
var x=%_RegExpExec(j,k,0,e);
if((x===null)){
this.lastIndex=0;
return false;
$regexpLastMatchInfoOverride=null;
return true;
function TrimRegExp(j){
if(!%_ObjectEquals(y,j)){
y=j;
new c(%_SubString(j.source,2,j.source.length),
(j.ignoreCase?j.multiline?"im":"i"
:j.multiline?"m":""));
return z;
function RegExpToString(){
if(!(%_IsRegExp(this))){
throw MakeTypeError(33,
'RegExp.prototype.toString',this);
var m='/'+this.source+'/';
if(this.global)m+='g';
if(this.ignoreCase)m+='i';
if(this.multiline)m+='m';
if(harmony_unicode_regexps&&this.unicode)m+='u';
if(harmony_regexps&&this.sticky)m+='y';
return m;
function RegExpGetLastMatch(){
if($regexpLastMatchInfoOverride!==null){
return(($regexpLastMatchInfoOverride)[0]);
var A=((e)[1]);
return %_SubString(A,
e[3],
e[4]);
function RegExpGetLastParen(){
if($regexpLastMatchInfoOverride){
var B=$regexpLastMatchInfoOverride;
if(B.length<=3)return'';
return B[B.length-3];
var C=((e)[0]);
if(C<=2)return'';
var A=((e)[1]);
var n=e[(3+(C-2))];
var q=e[(3+(C-1))];
if(n!=-1&&q!=-1){
return %_SubString(A,n,q);
return"";
function RegExpGetLeftContext(){
var D;
var E;
if(!$regexpLastMatchInfoOverride){
D=e[3];
E=((e)[1]);
}else{
var B=$regexpLastMatchInfoOverride;
D=((B)[(B).length-2]);
E=((B)[(B).length-1]);
return %_SubString(E,0,D);
function RegExpGetRightContext(){
var D;
var E;
if(!$regexpLastMatchInfoOverride){
D=e[4];
E=((e)[1]);
}else{
var B=$regexpLastMatchInfoOverride;
E=((B)[(B).length-1]);
var F=((B)[0]);
D=((B)[(B).length-2])+F.length;
return %_SubString(E,D,E.length);
function RegExpMakeCaptureGetter(G){
return function foo(){
if($regexpLastMatchInfoOverride){
if(G<$regexpLastMatchInfoOverride.length-2){
return(($regexpLastMatchInfoOverride)[(G)]);
return'';
var l=G*2;
if(l>=((e)[0]))return'';
var H=e[(3+(l))];
var I=e[(3+(l+1))];
if(H==-1||I==-1)return'';
return %_SubString(((e)[1]),H,I);
%FunctionSetInstanceClassName(c,'RegExp');
%AddNamedProperty(
c.prototype,'constructor',c,2);
%SetCode(c,RegExpConstructor);
b.InstallFunctions(c.prototype,2,[
"exec",RegExpExecJS,
"test",RegExpTest,
"toString",RegExpToString,
"compile",RegExpCompileJS
%FunctionSetLength(c.prototype.compile,1);
var J=function(){
var K=((e)[2]);
return(K===(void 0))?"":K;
var L=function(k){
((e)[2])=$toString(k);
%OptimizeObjectForAddingMultipleProperties(c,22);
%DefineAccessorPropertyUnchecked(c,'input',J,
L,4);
%DefineAccessorPropertyUnchecked(c,'$_',J,
L,2|4);
var M=false;
var N=function(){return M;};
var O=function(P){M=P?true:false;};
%DefineAccessorPropertyUnchecked(c,'multiline',N,
O,4);
%DefineAccessorPropertyUnchecked(c,'$*',N,
2|4);
var Q=function(R){};
%DefineAccessorPropertyUnchecked(c,'lastMatch',RegExpGetLastMatch,
Q,4);
%DefineAccessorPropertyUnchecked(c,'$&',RegExpGetLastMatch,
Q,2|4);
%DefineAccessorPropertyUnchecked(c,'lastParen',RegExpGetLastParen,
Q,4);
%DefineAccessorPropertyUnchecked(c,'$+',RegExpGetLastParen,
Q,2|4);
%DefineAccessorPropertyUnchecked(c,'leftContext',
RegExpGetLeftContext,Q,
%DefineAccessorPropertyUnchecked(c,'$`',RegExpGetLeftContext,
Q,2|4);
%DefineAccessorPropertyUnchecked(c,'rightContext',
RegExpGetRightContext,Q,
%DefineAccessorPropertyUnchecked(c,"$'",RegExpGetRightContext,
Q,2|4);
for(var u=1;u<10;++u){
%DefineAccessorPropertyUnchecked(c,'$'+u,
RegExpMakeCaptureGetter(u),Q,
%ToFastProperties(c);
b.Export(function(S){
S.RegExpExec=DoRegExpExec;
S.RegExpExecNoTests=RegExpExecNoTests;
S.RegExpLastMatchInfo=e;
S.RegExpTest=RegExpTest;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.ArrayBuffer;
var d=a.Object;
var e;
var g;
b.Import(function(h){
e=h.MathMax;
g=h.MathMin;
function ArrayBufferConstructor(i){
if(%_IsConstructCall()){
var j=$toPositiveInteger(i,125);
%ArrayBufferInitialize(this,j,false);
}else{
throw MakeTypeError(20,"ArrayBuffer");
function ArrayBufferGetByteLen(){
if(!(%_ClassOf(this)==='ArrayBuffer')){
throw MakeTypeError(33,
'ArrayBuffer.prototype.byteLength',this);
return %_ArrayBufferGetByteLength(this);
function ArrayBufferSlice(k,l){
if(!(%_ClassOf(this)==='ArrayBuffer')){
throw MakeTypeError(33,
'ArrayBuffer.prototype.slice',this);
var m=(%_IsSmi(%IS_VAR(k))?k:%NumberToInteger($toNumber(k)));
if(!(l===(void 0))){
l=(%_IsSmi(%IS_VAR(l))?l:%NumberToInteger($toNumber(l)));
var n;
var o=%_ArrayBufferGetByteLength(this);
if(m<0){
n=e(o+m,0);
}else{
n=g(m,o);
var p=(l===(void 0))?o:l;
var q;
if(p<0){
q=e(o+p,0);
}else{
q=g(p,o);
if(q<n){
q=n;
var r=q-n;
var t=new c(r);
%ArrayBufferSliceImpl(this,t,n);
return t;
function ArrayBufferIsViewJS(u){
return %ArrayBufferIsView(u);
%SetCode(c,ArrayBufferConstructor);
%FunctionSetPrototype(c,new d());
%AddNamedProperty(
c.prototype,"constructor",c,2);
%AddNamedProperty(c.prototype,
symbolToStringTag,"ArrayBuffer",2|1);
b.InstallGetter(c.prototype,"byteLength",ArrayBufferGetByteLen);
b.InstallFunctions(c,2,[
"isView",ArrayBufferIsViewJS
b.InstallFunctions(c.prototype,2,[
"slice",ArrayBufferSlice
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Array;
var d=a.ArrayBuffer;
var e=a.DataView;
var g=a.Object;
var h=a.Uint8Array;
var i=a.Int8Array;
var j=a.Uint16Array;
var k=a.Int16Array;
var l=a.Uint32Array;
var m=a.Int32Array;
var n=a.Float32Array;
var o=a.Float64Array;
var p=a.Uint8ClampedArray;
var q;
var r;
b.Import(function(t){
q=t.MathMax;
r=t.MathMin;
var u=b.InternalArray;
function Uint8ArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 1!==0){
throw MakeRangeError(138,
"start offset","Uint8Array",1);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 1!==0){
throw MakeRangeError(138,
"byte length","Uint8Array",1);
B=z-A;
C=B/1;
}else{
var C=y;
B=C*1;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,1,w,A,B,true);
function Uint8ArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*1;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,1,w,0,E,true);
}else{
%_TypedArrayInitialize(v,1,null,0,E,true);
function Uint8ArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*1;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,1,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,1,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Uint8ArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Uint8ArrayConstructByArrayLike(v,K);
function Uint8ArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Uint8ArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Uint8ArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Uint8ArrayConstructByArrayLike(this,O);
}else{
Uint8ArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Uint8Array")
function Uint8Array_GetBuffer(){
if(!(%_ClassOf(this)==='Uint8Array')){
throw MakeTypeError(33,"Uint8Array.buffer",this);
return %TypedArrayGetBuffer(this);
function Uint8Array_GetByteLength(){
if(!(%_ClassOf(this)==='Uint8Array')){
throw MakeTypeError(33,"Uint8Array.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Uint8Array_GetByteOffset(){
if(!(%_ClassOf(this)==='Uint8Array')){
throw MakeTypeError(33,"Uint8Array.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Uint8Array_GetLength(){
if(!(%_ClassOf(this)==='Uint8Array')){
throw MakeTypeError(33,"Uint8Array.length",this);
return %_TypedArrayGetLength(this);
function Uint8ArraySubArray(R,S){
if(!(%_ClassOf(this)==='Uint8Array')){
throw MakeTypeError(33,"Uint8Array.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*1;
return new h(%TypedArrayGetBuffer(this),
W,C);
function Int8ArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 1!==0){
throw MakeRangeError(138,
"start offset","Int8Array",1);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 1!==0){
throw MakeRangeError(138,
"byte length","Int8Array",1);
B=z-A;
C=B/1;
}else{
var C=y;
B=C*1;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,2,w,A,B,true);
function Int8ArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*1;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,2,w,0,E,true);
}else{
%_TypedArrayInitialize(v,2,null,0,E,true);
function Int8ArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*1;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,2,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,2,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Int8ArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Int8ArrayConstructByArrayLike(v,K);
function Int8ArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Int8ArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Int8ArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Int8ArrayConstructByArrayLike(this,O);
}else{
Int8ArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Int8Array")
function Int8Array_GetBuffer(){
if(!(%_ClassOf(this)==='Int8Array')){
throw MakeTypeError(33,"Int8Array.buffer",this);
return %TypedArrayGetBuffer(this);
function Int8Array_GetByteLength(){
if(!(%_ClassOf(this)==='Int8Array')){
throw MakeTypeError(33,"Int8Array.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Int8Array_GetByteOffset(){
if(!(%_ClassOf(this)==='Int8Array')){
throw MakeTypeError(33,"Int8Array.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Int8Array_GetLength(){
if(!(%_ClassOf(this)==='Int8Array')){
throw MakeTypeError(33,"Int8Array.length",this);
return %_TypedArrayGetLength(this);
function Int8ArraySubArray(R,S){
if(!(%_ClassOf(this)==='Int8Array')){
throw MakeTypeError(33,"Int8Array.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*1;
return new i(%TypedArrayGetBuffer(this),
W,C);
function Uint16ArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 2!==0){
throw MakeRangeError(138,
"start offset","Uint16Array",2);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 2!==0){
throw MakeRangeError(138,
"byte length","Uint16Array",2);
B=z-A;
C=B/2;
}else{
var C=y;
B=C*2;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,3,w,A,B,true);
function Uint16ArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*2;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,3,w,0,E,true);
}else{
%_TypedArrayInitialize(v,3,null,0,E,true);
function Uint16ArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*2;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,3,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,3,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Uint16ArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Uint16ArrayConstructByArrayLike(v,K);
function Uint16ArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Uint16ArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Uint16ArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Uint16ArrayConstructByArrayLike(this,O);
}else{
Uint16ArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Uint16Array")
function Uint16Array_GetBuffer(){
if(!(%_ClassOf(this)==='Uint16Array')){
throw MakeTypeError(33,"Uint16Array.buffer",this);
return %TypedArrayGetBuffer(this);
function Uint16Array_GetByteLength(){
if(!(%_ClassOf(this)==='Uint16Array')){
throw MakeTypeError(33,"Uint16Array.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Uint16Array_GetByteOffset(){
if(!(%_ClassOf(this)==='Uint16Array')){
throw MakeTypeError(33,"Uint16Array.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Uint16Array_GetLength(){
if(!(%_ClassOf(this)==='Uint16Array')){
throw MakeTypeError(33,"Uint16Array.length",this);
return %_TypedArrayGetLength(this);
function Uint16ArraySubArray(R,S){
if(!(%_ClassOf(this)==='Uint16Array')){
throw MakeTypeError(33,"Uint16Array.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*2;
return new j(%TypedArrayGetBuffer(this),
W,C);
function Int16ArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 2!==0){
throw MakeRangeError(138,
"start offset","Int16Array",2);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 2!==0){
throw MakeRangeError(138,
"byte length","Int16Array",2);
B=z-A;
C=B/2;
}else{
var C=y;
B=C*2;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,4,w,A,B,true);
function Int16ArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*2;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,4,w,0,E,true);
}else{
%_TypedArrayInitialize(v,4,null,0,E,true);
function Int16ArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*2;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,4,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,4,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Int16ArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Int16ArrayConstructByArrayLike(v,K);
function Int16ArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Int16ArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Int16ArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Int16ArrayConstructByArrayLike(this,O);
}else{
Int16ArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Int16Array")
function Int16Array_GetBuffer(){
if(!(%_ClassOf(this)==='Int16Array')){
throw MakeTypeError(33,"Int16Array.buffer",this);
return %TypedArrayGetBuffer(this);
function Int16Array_GetByteLength(){
if(!(%_ClassOf(this)==='Int16Array')){
throw MakeTypeError(33,"Int16Array.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Int16Array_GetByteOffset(){
if(!(%_ClassOf(this)==='Int16Array')){
throw MakeTypeError(33,"Int16Array.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Int16Array_GetLength(){
if(!(%_ClassOf(this)==='Int16Array')){
throw MakeTypeError(33,"Int16Array.length",this);
return %_TypedArrayGetLength(this);
function Int16ArraySubArray(R,S){
if(!(%_ClassOf(this)==='Int16Array')){
throw MakeTypeError(33,"Int16Array.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*2;
return new k(%TypedArrayGetBuffer(this),
W,C);
function Uint32ArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 4!==0){
throw MakeRangeError(138,
"start offset","Uint32Array",4);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 4!==0){
throw MakeRangeError(138,
"byte length","Uint32Array",4);
B=z-A;
C=B/4;
}else{
var C=y;
B=C*4;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,5,w,A,B,true);
function Uint32ArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*4;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,5,w,0,E,true);
}else{
%_TypedArrayInitialize(v,5,null,0,E,true);
function Uint32ArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*4;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,5,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,5,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Uint32ArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Uint32ArrayConstructByArrayLike(v,K);
function Uint32ArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Uint32ArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Uint32ArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Uint32ArrayConstructByArrayLike(this,O);
}else{
Uint32ArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Uint32Array")
function Uint32Array_GetBuffer(){
if(!(%_ClassOf(this)==='Uint32Array')){
throw MakeTypeError(33,"Uint32Array.buffer",this);
return %TypedArrayGetBuffer(this);
function Uint32Array_GetByteLength(){
if(!(%_ClassOf(this)==='Uint32Array')){
throw MakeTypeError(33,"Uint32Array.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Uint32Array_GetByteOffset(){
if(!(%_ClassOf(this)==='Uint32Array')){
throw MakeTypeError(33,"Uint32Array.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Uint32Array_GetLength(){
if(!(%_ClassOf(this)==='Uint32Array')){
throw MakeTypeError(33,"Uint32Array.length",this);
return %_TypedArrayGetLength(this);
function Uint32ArraySubArray(R,S){
if(!(%_ClassOf(this)==='Uint32Array')){
throw MakeTypeError(33,"Uint32Array.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*4;
return new l(%TypedArrayGetBuffer(this),
W,C);
function Int32ArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 4!==0){
throw MakeRangeError(138,
"start offset","Int32Array",4);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 4!==0){
throw MakeRangeError(138,
"byte length","Int32Array",4);
B=z-A;
C=B/4;
}else{
var C=y;
B=C*4;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,6,w,A,B,true);
function Int32ArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*4;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,6,w,0,E,true);
}else{
%_TypedArrayInitialize(v,6,null,0,E,true);
function Int32ArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*4;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,6,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,6,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Int32ArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Int32ArrayConstructByArrayLike(v,K);
function Int32ArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Int32ArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Int32ArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Int32ArrayConstructByArrayLike(this,O);
}else{
Int32ArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Int32Array")
function Int32Array_GetBuffer(){
if(!(%_ClassOf(this)==='Int32Array')){
throw MakeTypeError(33,"Int32Array.buffer",this);
return %TypedArrayGetBuffer(this);
function Int32Array_GetByteLength(){
if(!(%_ClassOf(this)==='Int32Array')){
throw MakeTypeError(33,"Int32Array.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Int32Array_GetByteOffset(){
if(!(%_ClassOf(this)==='Int32Array')){
throw MakeTypeError(33,"Int32Array.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Int32Array_GetLength(){
if(!(%_ClassOf(this)==='Int32Array')){
throw MakeTypeError(33,"Int32Array.length",this);
return %_TypedArrayGetLength(this);
function Int32ArraySubArray(R,S){
if(!(%_ClassOf(this)==='Int32Array')){
throw MakeTypeError(33,"Int32Array.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*4;
return new m(%TypedArrayGetBuffer(this),
W,C);
function Float32ArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 4!==0){
throw MakeRangeError(138,
"start offset","Float32Array",4);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 4!==0){
throw MakeRangeError(138,
"byte length","Float32Array",4);
B=z-A;
C=B/4;
}else{
var C=y;
B=C*4;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,7,w,A,B,true);
function Float32ArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*4;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,7,w,0,E,true);
}else{
%_TypedArrayInitialize(v,7,null,0,E,true);
function Float32ArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*4;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,7,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,7,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Float32ArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Float32ArrayConstructByArrayLike(v,K);
function Float32ArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Float32ArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Float32ArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Float32ArrayConstructByArrayLike(this,O);
}else{
Float32ArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Float32Array")
function Float32Array_GetBuffer(){
if(!(%_ClassOf(this)==='Float32Array')){
throw MakeTypeError(33,"Float32Array.buffer",this);
return %TypedArrayGetBuffer(this);
function Float32Array_GetByteLength(){
if(!(%_ClassOf(this)==='Float32Array')){
throw MakeTypeError(33,"Float32Array.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Float32Array_GetByteOffset(){
if(!(%_ClassOf(this)==='Float32Array')){
throw MakeTypeError(33,"Float32Array.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Float32Array_GetLength(){
if(!(%_ClassOf(this)==='Float32Array')){
throw MakeTypeError(33,"Float32Array.length",this);
return %_TypedArrayGetLength(this);
function Float32ArraySubArray(R,S){
if(!(%_ClassOf(this)==='Float32Array')){
throw MakeTypeError(33,"Float32Array.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*4;
return new n(%TypedArrayGetBuffer(this),
W,C);
function Float64ArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 8!==0){
throw MakeRangeError(138,
"start offset","Float64Array",8);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 8!==0){
throw MakeRangeError(138,
"byte length","Float64Array",8);
B=z-A;
C=B/8;
}else{
var C=y;
B=C*8;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,8,w,A,B,true);
function Float64ArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*8;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,8,w,0,E,true);
}else{
%_TypedArrayInitialize(v,8,null,0,E,true);
function Float64ArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*8;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,8,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,8,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Float64ArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Float64ArrayConstructByArrayLike(v,K);
function Float64ArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Float64ArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Float64ArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Float64ArrayConstructByArrayLike(this,O);
}else{
Float64ArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Float64Array")
function Float64Array_GetBuffer(){
if(!(%_ClassOf(this)==='Float64Array')){
throw MakeTypeError(33,"Float64Array.buffer",this);
return %TypedArrayGetBuffer(this);
function Float64Array_GetByteLength(){
if(!(%_ClassOf(this)==='Float64Array')){
throw MakeTypeError(33,"Float64Array.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Float64Array_GetByteOffset(){
if(!(%_ClassOf(this)==='Float64Array')){
throw MakeTypeError(33,"Float64Array.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Float64Array_GetLength(){
if(!(%_ClassOf(this)==='Float64Array')){
throw MakeTypeError(33,"Float64Array.length",this);
return %_TypedArrayGetLength(this);
function Float64ArraySubArray(R,S){
if(!(%_ClassOf(this)==='Float64Array')){
throw MakeTypeError(33,"Float64Array.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*8;
return new o(%TypedArrayGetBuffer(this),
W,C);
function Uint8ClampedArrayConstructByArrayBuffer(v,w,x,y){
if(!(x===(void 0))){
$toPositiveInteger(x,139);
if(!(y===(void 0))){
y=$toPositiveInteger(y,139);
var z=%_ArrayBufferGetByteLength(w);
var A;
if((x===(void 0))){
A=0;
}else{
A=x;
if(A % 1!==0){
throw MakeRangeError(138,
"start offset","Uint8ClampedArray",1);
if(A>z){
throw MakeRangeError(140);
var B;
var C;
if((y===(void 0))){
if(z % 1!==0){
throw MakeRangeError(138,
"byte length","Uint8ClampedArray",1);
B=z-A;
C=B/1;
}else{
var C=y;
B=C*1;
if((A+B>z)
||(C>%_MaxSmi())){
throw MakeRangeError(139);
%_TypedArrayInitialize(v,9,w,A,B,true);
function Uint8ClampedArrayConstructByLength(v,y){
var D=(y===(void 0))?
0:$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var E=D*1;
if(E>%_TypedArrayMaxSizeInHeap()){
var w=new d(E);
%_TypedArrayInitialize(v,9,w,0,E,true);
}else{
%_TypedArrayInitialize(v,9,null,0,E,true);
function Uint8ClampedArrayConstructByArrayLike(v,F){
var y=F.length;
var D=$toPositiveInteger(y,139);
if(D>%_MaxSmi()){
throw MakeRangeError(139);
var G=false;
var E=D*1;
if(E<=%_TypedArrayMaxSizeInHeap()){
%_TypedArrayInitialize(v,9,null,0,E,false);
}else{
%TypedArrayInitializeFromArrayLike(v,9,F,D);
if(!G){
for(var H=0;H<D;H++){
v[H]=F[H];
function Uint8ClampedArrayConstructByIterable(v,I,J){
var K=new u();
var L=%_CallFunction(I,J);
var M={
__proto__:null
M[symbolIterator]=function(){return L;}
for(var N of M){
K.push(N);
Uint8ClampedArrayConstructByArrayLike(v,K);
function Uint8ClampedArrayConstructor(O,P,Q){
if(%_IsConstructCall()){
if((%_ClassOf(O)==='ArrayBuffer')||(%_ClassOf(O)==='SharedArrayBuffer')){
Uint8ClampedArrayConstructByArrayBuffer(this,O,P,Q);
}else if((typeof(O)==='number')||(typeof(O)==='string')||
(typeof(O)==='boolean')||(O===(void 0))){
Uint8ClampedArrayConstructByLength(this,O);
}else{
var J=O[symbolIterator];
if((J===(void 0))||J===$arrayValues){
Uint8ClampedArrayConstructByArrayLike(this,O);
}else{
Uint8ClampedArrayConstructByIterable(this,O,J);
}else{
throw MakeTypeError(20,"Uint8ClampedArray")
function Uint8ClampedArray_GetBuffer(){
if(!(%_ClassOf(this)==='Uint8ClampedArray')){
throw MakeTypeError(33,"Uint8ClampedArray.buffer",this);
return %TypedArrayGetBuffer(this);
function Uint8ClampedArray_GetByteLength(){
if(!(%_ClassOf(this)==='Uint8ClampedArray')){
throw MakeTypeError(33,"Uint8ClampedArray.byteLength",this);
return %_ArrayBufferViewGetByteLength(this);
function Uint8ClampedArray_GetByteOffset(){
if(!(%_ClassOf(this)==='Uint8ClampedArray')){
throw MakeTypeError(33,"Uint8ClampedArray.byteOffset",this);
return %_ArrayBufferViewGetByteOffset(this);
function Uint8ClampedArray_GetLength(){
if(!(%_ClassOf(this)==='Uint8ClampedArray')){
throw MakeTypeError(33,"Uint8ClampedArray.length",this);
return %_TypedArrayGetLength(this);
function Uint8ClampedArraySubArray(R,S){
if(!(%_ClassOf(this)==='Uint8ClampedArray')){
throw MakeTypeError(33,"Uint8ClampedArray.subarray",this);
var T=(%_IsSmi(%IS_VAR(R))?R:%NumberToInteger($toNumber(R)));
if(!(S===(void 0))){
S=(%_IsSmi(%IS_VAR(S))?S:%NumberToInteger($toNumber(S)));
var U=%_TypedArrayGetLength(this);
if(T<0){
T=q(0,U+T);
}else{
T=r(U,T);
var V=(S===(void 0))?U:S;
if(V<0){
V=q(0,U+V);
}else{
V=r(V,U);
if(V<T){
V=T;
var C=V-T;
var W=
%_ArrayBufferViewGetByteOffset(this)+T*1;
return new p(%TypedArrayGetBuffer(this),
W,C);
function TypedArraySetFromArrayLike(X,Y,Z,A){
if(A>0){
for(var H=0;H<Z;H++){
X[A+H]=Y[H];
else{
for(var H=0;H<Z;H++){
X[H]=Y[H];
function TypedArraySetFromOverlappingTypedArray(X,Y,A){
var aa=Y.BYTES_PER_ELEMENT;
var ab=X.BYTES_PER_ELEMENT;
var Z=Y.length;
function CopyLeftPart(){
var ac=X.byteOffset+(A+1)*ab;
var ad=Y.byteOffset;
for(var ae=0;
ae<Z&&ac<=ad;
ae++){
X[A+ae]=Y[ae];
ac+=ab;
ad+=aa;
return ae;
var ae=CopyLeftPart();
function CopyRightPart(){
var ac=
X.byteOffset+(A+Z-1)*ab;
var ad=
Y.byteOffset+Z*aa;
for(var af=Z-1;
af>=ae&&ac>=ad;
af--){
X[A+af]=Y[af];
ac-=ab;
ad-=aa;
return af;
var af=CopyRightPart();
var ag=new c(af+1-ae);
for(var H=ae;H<=af;H++){
ag[H-ae]=Y[H];
for(H=ae;H<=af;H++){
X[A+H]=ag[H-ae];
function TypedArraySet(v,A){
var ah=(A===(void 0))?0:(%_IsSmi(%IS_VAR(A))?A:%NumberToInteger($toNumber(A)));
if(ah<0)throw MakeTypeError(148);
if(ah>%_MaxSmi()){
throw MakeRangeError(149);
switch(%TypedArraySetFastCases(this,v,ah)){
case 0:
return;
case 1:
TypedArraySetFromOverlappingTypedArray(this,v,ah);
return;
case 2:
TypedArraySetFromArrayLike(this,v,v.length,ah);
return;
case 3:
var D=v.length;
if((D===(void 0))){
if((typeof(v)==='number')){
throw MakeTypeError(36);
return;
if(ah+D>this.length){
throw MakeRangeError(149);
TypedArraySetFromArrayLike(this,v,D,ah);
return;
function TypedArrayGetToStringTag(){
if(!%_IsTypedArray(this))return;
var ai=%_ClassOf(this);
if((ai===(void 0)))return;
return ai;
%SetCode(h,Uint8ArrayConstructor);
%FunctionSetPrototype(h,new g());
%AddNamedProperty(h,"BYTES_PER_ELEMENT",1,
1|2|4);
%AddNamedProperty(h.prototype,
"constructor",a.Uint8Array,2);
%AddNamedProperty(h.prototype,
"BYTES_PER_ELEMENT",1,
1|2|4);
b.InstallGetter(h.prototype,"buffer",Uint8Array_GetBuffer);
b.InstallGetter(h.prototype,"byteOffset",Uint8Array_GetByteOffset,
2|4);
b.InstallGetter(h.prototype,"byteLength",Uint8Array_GetByteLength,
2|4);
b.InstallGetter(h.prototype,"length",Uint8Array_GetLength,
2|4);
b.InstallGetter(h.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(h.prototype,2,[
"subarray",Uint8ArraySubArray,
"set",TypedArraySet
%SetCode(i,Int8ArrayConstructor);
%FunctionSetPrototype(i,new g());
%AddNamedProperty(i,"BYTES_PER_ELEMENT",1,
1|2|4);
%AddNamedProperty(i.prototype,
"constructor",a.Int8Array,2);
%AddNamedProperty(i.prototype,
"BYTES_PER_ELEMENT",1,
1|2|4);
b.InstallGetter(i.prototype,"buffer",Int8Array_GetBuffer);
b.InstallGetter(i.prototype,"byteOffset",Int8Array_GetByteOffset,
2|4);
b.InstallGetter(i.prototype,"byteLength",Int8Array_GetByteLength,
2|4);
b.InstallGetter(i.prototype,"length",Int8Array_GetLength,
2|4);
b.InstallGetter(i.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(i.prototype,2,[
"subarray",Int8ArraySubArray,
"set",TypedArraySet
%SetCode(j,Uint16ArrayConstructor);
%FunctionSetPrototype(j,new g());
%AddNamedProperty(j,"BYTES_PER_ELEMENT",2,
1|2|4);
%AddNamedProperty(j.prototype,
"constructor",a.Uint16Array,2);
%AddNamedProperty(j.prototype,
"BYTES_PER_ELEMENT",2,
1|2|4);
b.InstallGetter(j.prototype,"buffer",Uint16Array_GetBuffer);
b.InstallGetter(j.prototype,"byteOffset",Uint16Array_GetByteOffset,
2|4);
b.InstallGetter(j.prototype,"byteLength",Uint16Array_GetByteLength,
2|4);
b.InstallGetter(j.prototype,"length",Uint16Array_GetLength,
2|4);
b.InstallGetter(j.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(j.prototype,2,[
"subarray",Uint16ArraySubArray,
"set",TypedArraySet
%SetCode(k,Int16ArrayConstructor);
%FunctionSetPrototype(k,new g());
%AddNamedProperty(k,"BYTES_PER_ELEMENT",2,
1|2|4);
%AddNamedProperty(k.prototype,
"constructor",a.Int16Array,2);
%AddNamedProperty(k.prototype,
"BYTES_PER_ELEMENT",2,
1|2|4);
b.InstallGetter(k.prototype,"buffer",Int16Array_GetBuffer);
b.InstallGetter(k.prototype,"byteOffset",Int16Array_GetByteOffset,
2|4);
b.InstallGetter(k.prototype,"byteLength",Int16Array_GetByteLength,
2|4);
b.InstallGetter(k.prototype,"length",Int16Array_GetLength,
2|4);
b.InstallGetter(k.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(k.prototype,2,[
"subarray",Int16ArraySubArray,
"set",TypedArraySet
%SetCode(l,Uint32ArrayConstructor);
%FunctionSetPrototype(l,new g());
%AddNamedProperty(l,"BYTES_PER_ELEMENT",4,
1|2|4);
%AddNamedProperty(l.prototype,
"constructor",a.Uint32Array,2);
%AddNamedProperty(l.prototype,
"BYTES_PER_ELEMENT",4,
1|2|4);
b.InstallGetter(l.prototype,"buffer",Uint32Array_GetBuffer);
b.InstallGetter(l.prototype,"byteOffset",Uint32Array_GetByteOffset,
2|4);
b.InstallGetter(l.prototype,"byteLength",Uint32Array_GetByteLength,
2|4);
b.InstallGetter(l.prototype,"length",Uint32Array_GetLength,
2|4);
b.InstallGetter(l.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(l.prototype,2,[
"subarray",Uint32ArraySubArray,
"set",TypedArraySet
%SetCode(m,Int32ArrayConstructor);
%FunctionSetPrototype(m,new g());
%AddNamedProperty(m,"BYTES_PER_ELEMENT",4,
1|2|4);
%AddNamedProperty(m.prototype,
"constructor",a.Int32Array,2);
%AddNamedProperty(m.prototype,
"BYTES_PER_ELEMENT",4,
1|2|4);
b.InstallGetter(m.prototype,"buffer",Int32Array_GetBuffer);
b.InstallGetter(m.prototype,"byteOffset",Int32Array_GetByteOffset,
2|4);
b.InstallGetter(m.prototype,"byteLength",Int32Array_GetByteLength,
2|4);
b.InstallGetter(m.prototype,"length",Int32Array_GetLength,
2|4);
b.InstallGetter(m.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(m.prototype,2,[
"subarray",Int32ArraySubArray,
"set",TypedArraySet
%SetCode(n,Float32ArrayConstructor);
%FunctionSetPrototype(n,new g());
%AddNamedProperty(n,"BYTES_PER_ELEMENT",4,
1|2|4);
%AddNamedProperty(n.prototype,
"constructor",a.Float32Array,2);
%AddNamedProperty(n.prototype,
"BYTES_PER_ELEMENT",4,
1|2|4);
b.InstallGetter(n.prototype,"buffer",Float32Array_GetBuffer);
b.InstallGetter(n.prototype,"byteOffset",Float32Array_GetByteOffset,
2|4);
b.InstallGetter(n.prototype,"byteLength",Float32Array_GetByteLength,
2|4);
b.InstallGetter(n.prototype,"length",Float32Array_GetLength,
2|4);
b.InstallGetter(n.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(n.prototype,2,[
"subarray",Float32ArraySubArray,
"set",TypedArraySet
%SetCode(o,Float64ArrayConstructor);
%FunctionSetPrototype(o,new g());
%AddNamedProperty(o,"BYTES_PER_ELEMENT",8,
1|2|4);
%AddNamedProperty(o.prototype,
"constructor",a.Float64Array,2);
%AddNamedProperty(o.prototype,
"BYTES_PER_ELEMENT",8,
1|2|4);
b.InstallGetter(o.prototype,"buffer",Float64Array_GetBuffer);
b.InstallGetter(o.prototype,"byteOffset",Float64Array_GetByteOffset,
2|4);
b.InstallGetter(o.prototype,"byteLength",Float64Array_GetByteLength,
2|4);
b.InstallGetter(o.prototype,"length",Float64Array_GetLength,
2|4);
b.InstallGetter(o.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(o.prototype,2,[
"subarray",Float64ArraySubArray,
"set",TypedArraySet
%SetCode(p,Uint8ClampedArrayConstructor);
%FunctionSetPrototype(p,new g());
%AddNamedProperty(p,"BYTES_PER_ELEMENT",1,
1|2|4);
%AddNamedProperty(p.prototype,
"constructor",a.Uint8ClampedArray,2);
%AddNamedProperty(p.prototype,
"BYTES_PER_ELEMENT",1,
1|2|4);
b.InstallGetter(p.prototype,"buffer",Uint8ClampedArray_GetBuffer);
b.InstallGetter(p.prototype,"byteOffset",Uint8ClampedArray_GetByteOffset,
2|4);
b.InstallGetter(p.prototype,"byteLength",Uint8ClampedArray_GetByteLength,
2|4);
b.InstallGetter(p.prototype,"length",Uint8ClampedArray_GetLength,
2|4);
b.InstallGetter(p.prototype,symbolToStringTag,
TypedArrayGetToStringTag);
b.InstallFunctions(p.prototype,2,[
"subarray",Uint8ClampedArraySubArray,
"set",TypedArraySet
function DataViewConstructor(w,x,E){
if(%_IsConstructCall()){
if(!(%_ClassOf(w)==='ArrayBuffer'))throw MakeTypeError(22);
if(!(x===(void 0))){
x=$toPositiveInteger(x,132);
if(!(E===(void 0))){
E=(%_IsSmi(%IS_VAR(E))?E:%NumberToInteger($toNumber(E)));
var z=%_ArrayBufferGetByteLength(w);
var A=(x===(void 0))?0:x;
if(A>z)throw MakeRangeError(132);
var y=(E===(void 0))
?z-A
if(y<0||A+y>z){
throw new MakeRangeError(131);
%_DataViewInitialize(this,w,A,y);
}else{
throw MakeTypeError(20,"DataView");
function DataViewGetBufferJS(){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,'DataView.buffer',this);
return %DataViewGetBuffer(this);
function DataViewGetByteOffset(){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.byteOffset',this);
return %_ArrayBufferViewGetByteOffset(this);
function DataViewGetByteLength(){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.byteLength',this);
return %_ArrayBufferViewGetByteLength(this);
function DataViewGetInt8JS(A,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.getInt8',this);
if(%_ArgumentsLength()<1)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
return %DataViewGetInt8(this,A,!!aj);
function DataViewSetInt8JS(A,N,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.setInt8',this);
if(%_ArgumentsLength()<2)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
%DataViewSetInt8(this,A,((typeof(%IS_VAR(N))==='number')?N:$nonNumberToNumber(N)),!!aj);
function DataViewGetUint8JS(A,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.getUint8',this);
if(%_ArgumentsLength()<1)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
return %DataViewGetUint8(this,A,!!aj);
function DataViewSetUint8JS(A,N,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.setUint8',this);
if(%_ArgumentsLength()<2)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
%DataViewSetUint8(this,A,((typeof(%IS_VAR(N))==='number')?N:$nonNumberToNumber(N)),!!aj);
function DataViewGetInt16JS(A,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.getInt16',this);
if(%_ArgumentsLength()<1)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
return %DataViewGetInt16(this,A,!!aj);
function DataViewSetInt16JS(A,N,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.setInt16',this);
if(%_ArgumentsLength()<2)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
%DataViewSetInt16(this,A,((typeof(%IS_VAR(N))==='number')?N:$nonNumberToNumber(N)),!!aj);
function DataViewGetUint16JS(A,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.getUint16',this);
if(%_ArgumentsLength()<1)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
return %DataViewGetUint16(this,A,!!aj);
function DataViewSetUint16JS(A,N,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.setUint16',this);
if(%_ArgumentsLength()<2)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
%DataViewSetUint16(this,A,((typeof(%IS_VAR(N))==='number')?N:$nonNumberToNumber(N)),!!aj);
function DataViewGetInt32JS(A,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.getInt32',this);
if(%_ArgumentsLength()<1)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
return %DataViewGetInt32(this,A,!!aj);
function DataViewSetInt32JS(A,N,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.setInt32',this);
if(%_ArgumentsLength()<2)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
%DataViewSetInt32(this,A,((typeof(%IS_VAR(N))==='number')?N:$nonNumberToNumber(N)),!!aj);
function DataViewGetUint32JS(A,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.getUint32',this);
if(%_ArgumentsLength()<1)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
return %DataViewGetUint32(this,A,!!aj);
function DataViewSetUint32JS(A,N,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.setUint32',this);
if(%_ArgumentsLength()<2)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
%DataViewSetUint32(this,A,((typeof(%IS_VAR(N))==='number')?N:$nonNumberToNumber(N)),!!aj);
function DataViewGetFloat32JS(A,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.getFloat32',this);
if(%_ArgumentsLength()<1)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
return %DataViewGetFloat32(this,A,!!aj);
function DataViewSetFloat32JS(A,N,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.setFloat32',this);
if(%_ArgumentsLength()<2)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
%DataViewSetFloat32(this,A,((typeof(%IS_VAR(N))==='number')?N:$nonNumberToNumber(N)),!!aj);
function DataViewGetFloat64JS(A,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.getFloat64',this);
if(%_ArgumentsLength()<1)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
return %DataViewGetFloat64(this,A,!!aj);
function DataViewSetFloat64JS(A,N,aj){
if(!(%_ClassOf(this)==='DataView')){
throw MakeTypeError(33,
'DataView.setFloat64',this);
if(%_ArgumentsLength()<2)throw MakeTypeError(36);
A=$toPositiveInteger(A,130);
%DataViewSetFloat64(this,A,((typeof(%IS_VAR(N))==='number')?N:$nonNumberToNumber(N)),!!aj);
%SetCode(e,DataViewConstructor);
%FunctionSetPrototype(e,new g);
%AddNamedProperty(e.prototype,"constructor",e,
%AddNamedProperty(e.prototype,symbolToStringTag,"DataView",
1|2);
b.InstallGetter(e.prototype,"buffer",DataViewGetBufferJS);
b.InstallGetter(e.prototype,"byteOffset",
DataViewGetByteOffset);
b.InstallGetter(e.prototype,"byteLength",
DataViewGetByteLength);
b.InstallFunctions(e.prototype,2,[
"getInt8",DataViewGetInt8JS,
"setInt8",DataViewSetInt8JS,
"getUint8",DataViewGetUint8JS,
"setUint8",DataViewSetUint8JS,
"getInt16",DataViewGetInt16JS,
"setInt16",DataViewSetInt16JS,
"getUint16",DataViewGetUint16JS,
"setUint16",DataViewSetUint16JS,
"getInt32",DataViewGetInt32JS,
"setInt32",DataViewSetInt32JS,
"getUint32",DataViewGetUint32JS,
"setUint32",DataViewSetUint32JS,
"getFloat32",DataViewGetFloat32JS,
"setFloat32",DataViewSetFloat32JS,
"getFloat64",DataViewGetFloat64JS,
"setFloat64",DataViewSetFloat64JS
var $iteratorPrototype;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Object;
function IteratorPrototypeIterator(){
return this;
b.SetFunctionName(IteratorPrototypeIterator,symbolIterator);
%AddNamedProperty($iteratorPrototype,symbolIterator,
IteratorPrototypeIterator,2);
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Function;
var d;
b.Import(function(e){
d=e.NewFunctionString;
function GeneratorObjectNext(g){
if(!(%_ClassOf(this)==='Generator')){
throw MakeTypeError(33,
'[Generator].prototype.next',this);
var h=%GeneratorGetContinuation(this);
if(h>0){
if((%_DebugIsActive()!=0))%DebugPrepareStepInIfStepping(this);
try{
return %_GeneratorNext(this,g);
}catch(e){
%GeneratorClose(this);
throw e;
}else if(h==0){
return{value:void 0,done:true};
}else{
throw MakeTypeError(31);
function GeneratorObjectThrow(i){
if(!(%_ClassOf(this)==='Generator')){
throw MakeTypeError(33,
'[Generator].prototype.throw',this);
var h=%GeneratorGetContinuation(this);
if(h>0){
try{
return %_GeneratorThrow(this,i);
}catch(e){
%GeneratorClose(this);
throw e;
}else if(h==0){
throw i;
}else{
throw MakeTypeError(31);
function GeneratorFunctionConstructor(j){
var k=d(arguments,'function*');
var l=%GlobalProxy(GeneratorFunctionConstructor);
var m=%_CallFunction(l,%CompileString(k,true));
%FunctionMarkNameShouldPrintAsAnonymous(m);
return m;
%NeverOptimizeFunction(GeneratorObjectNext);
%NeverOptimizeFunction(GeneratorObjectThrow);
var n=GeneratorFunctionPrototype.prototype;
b.InstallFunctions(n,
["next",GeneratorObjectNext,
"throw",GeneratorObjectThrow]);
%AddNamedProperty(n,"constructor",
GeneratorFunctionPrototype,2|1);
%AddNamedProperty(n,
symbolToStringTag,"Generator",2|1);
%InternalSetPrototype(GeneratorFunctionPrototype,c.prototype);
%AddNamedProperty(GeneratorFunctionPrototype,
symbolToStringTag,"GeneratorFunction",2|1);
%AddNamedProperty(GeneratorFunctionPrototype,"constructor",
GeneratorFunction,2|1);
%InternalSetPrototype(GeneratorFunction,c);
%SetCode(GeneratorFunction,GeneratorFunctionConstructor);
var $observeNotifyChange;
var $observeEnqueueSpliceRecord;
var $observeBeginPerformSplice;
var $observeEndPerformSplice;
var $observeNativeObjectObserve;
var $observeNativeObjectGetNotifier;
var $observeNativeObjectNotifierPerformChange;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Array;
var d=a.Object;
var e=b.InternalArray;
var g;
var h;
b.Import(function(i){
g=i.ObjectFreeze;
h=i.ObjectIsFrozen;
var j;
var k={};
function GetObservationStateJS(){
if((j===(void 0))){
j=%GetObservationState();
if((j.callbackInfoMap===(void 0))){
j.callbackInfoMap=%ObservationWeakMapCreate();
j.objectInfoMap=%ObservationWeakMapCreate();
j.notifierObjectInfoMap=%ObservationWeakMapCreate();
j.pendingObservers=null;
j.nextCallbackPriority=0;
j.lastMicrotaskId=0;
return j;
function GetPendingObservers(){
return GetObservationStateJS().pendingObservers;
function SetPendingObservers(l){
GetObservationStateJS().pendingObservers=l;
function GetNextCallbackPriority(){
return GetObservationStateJS().nextCallbackPriority++;
function nullProtoObject(){
return{__proto__:null};
function TypeMapCreate(){
return nullProtoObject();
function TypeMapAddType(m,n,o){
m[n]=o?1:(m[n]||0)+1;
function TypeMapRemoveType(m,n){
m[n]--;
function TypeMapCreateFromList(p,q){
var m=TypeMapCreate();
for(var r=0;r<q;r++){
TypeMapAddType(m,p[r],true);
return m;
function TypeMapHasType(m,n){
return!!m[n];
function TypeMapIsDisjointFrom(t,u){
if(!t||!u)
return true;
for(var n in t){
if(TypeMapHasType(t,n)&&TypeMapHasType(u,n))
return false;
return true;
var v=(function(){
var w=[
'add',
'update',
'delete',
'setPrototype',
'reconfigure',
'preventExtensions'
return TypeMapCreateFromList(w,w.length);
})();
function ObserverCreate(x,y){
if((y===(void 0)))
return x;
var z=nullProtoObject();
z.callback=x;
z.accept=y;
return z;
function ObserverGetCallback(z){
return(%_ClassOf(z)==='Function')?z:z.callback;
function ObserverGetAcceptTypes(z){
return(%_ClassOf(z)==='Function')?v:z.accept;
function ObserverIsActive(z,A){
return TypeMapIsDisjointFrom(ObjectInfoGetPerformingTypes(A),
ObserverGetAcceptTypes(z));
function ObjectInfoGetOrCreate(B){
var A=ObjectInfoGet(B);
if((A===(void 0))){
if(!%_IsJSProxy(B)){
%SetIsObserved(B);
object:B,
changeObservers:null,
notifier:null,
performing:null,
performingCount:0,
%WeakCollectionSet(GetObservationStateJS().objectInfoMap,
B,A,$getHash(B));
return A;
function ObjectInfoGet(B){
return %WeakCollectionGet(GetObservationStateJS().objectInfoMap,B,
$getHash(B));
function ObjectInfoGetFromNotifier(C){
return %WeakCollectionGet(GetObservationStateJS().notifierObjectInfoMap,
C,$getHash(C));
function ObjectInfoGetNotifier(A){
if((A.notifier===null)){
var C={__proto__:k};
A.notifier=C;
%WeakCollectionSet(GetObservationStateJS().notifierObjectInfoMap,
C,A,$getHash(C));
return A.notifier;
function ChangeObserversIsOptimized(D){
return(%_ClassOf(D)==='Function')||
(%_ClassOf(D.callback)==='Function');
function ObjectInfoNormalizeChangeObservers(A){
if(ChangeObserversIsOptimized(A.changeObservers)){
var z=A.changeObservers;
var x=ObserverGetCallback(z);
var E=CallbackInfoGet(x);
var F=CallbackInfoGetPriority(E);
A.changeObservers=nullProtoObject();
A.changeObservers[F]=z;
function ObjectInfoAddObserver(A,x,y){
var E=CallbackInfoGetOrCreate(x);
var z=ObserverCreate(x,y);
if(!A.changeObservers){
A.changeObservers=z;
return;
ObjectInfoNormalizeChangeObservers(A);
var F=CallbackInfoGetPriority(E);
A.changeObservers[F]=z;
function ObjectInfoRemoveObserver(A,x){
if(!A.changeObservers)
return;
if(ChangeObserversIsOptimized(A.changeObservers)){
if(x===ObserverGetCallback(A.changeObservers))
A.changeObservers=null;
return;
var E=CallbackInfoGet(x);
var F=CallbackInfoGetPriority(E);
A.changeObservers[F]=null;
function ObjectInfoHasActiveObservers(A){
if((A===(void 0))||!A.changeObservers)
return false;
if(ChangeObserversIsOptimized(A.changeObservers))
return ObserverIsActive(A.changeObservers,A);
for(var F in A.changeObservers){
var z=A.changeObservers[F];
if(!(z===null)&&ObserverIsActive(z,A))
return true;
return false;
function ObjectInfoAddPerformingType(A,n){
A.performing=A.performing||TypeMapCreate();
TypeMapAddType(A.performing,n);
A.performingCount++;
function ObjectInfoRemovePerformingType(A,n){
A.performingCount--;
TypeMapRemoveType(A.performing,n);
function ObjectInfoGetPerformingTypes(A){
return A.performingCount>0?A.performing:null;
function ConvertAcceptListToTypeMap(G){
if((G===(void 0)))
return G;
if(!(%_IsSpecObject(G)))throw MakeTypeError(68);
var H=$toInteger(G.length);
if(H<0)H=0;
return TypeMapCreateFromList(G,H);
function CallbackInfoGet(x){
return %WeakCollectionGet(GetObservationStateJS().callbackInfoMap,x,
$getHash(x));
function CallbackInfoSet(x,E){
%WeakCollectionSet(GetObservationStateJS().callbackInfoMap,
x,E,$getHash(x));
function CallbackInfoGetOrCreate(x){
var E=CallbackInfoGet(x);
if(!(E===(void 0)))
return E;
var F=GetNextCallbackPriority();
CallbackInfoSet(x,F);
return F;
function CallbackInfoGetPriority(E){
if((typeof(E)==='number'))
return E;
else
return E.priority;
function CallbackInfoNormalize(x){
var E=CallbackInfoGet(x);
if((typeof(E)==='number')){
var F=E;
E=new e;
E.priority=F;
CallbackInfoSet(x,E);
return E;
function ObjectObserve(B,x,y){
if(!(%_IsSpecObject(B)))
throw MakeTypeError(70,"observe","observe");
if(%IsJSGlobalProxy(B))
throw MakeTypeError(66,"observe");
if(%IsAccessCheckNeeded(B))
throw MakeTypeError(67,"observe");
if(!(%_ClassOf(x)==='Function'))
throw MakeTypeError(69,"observe");
if(h(x))
throw MakeTypeError(65);
var I=%GetObjectContextObjectObserve(B);
return I(B,x,y);
function NativeObjectObserve(B,x,y){
var A=ObjectInfoGetOrCreate(B);
var p=ConvertAcceptListToTypeMap(y);
ObjectInfoAddObserver(A,x,p);
return B;
function ObjectUnobserve(B,x){
if(!(%_IsSpecObject(B)))
throw MakeTypeError(70,"unobserve","unobserve");
if(%IsJSGlobalProxy(B))
throw MakeTypeError(66,"unobserve");
if(!(%_ClassOf(x)==='Function'))
throw MakeTypeError(69,"unobserve");
var A=ObjectInfoGet(B);
if((A===(void 0)))
return B;
ObjectInfoRemoveObserver(A,x);
return B;
function ArrayObserve(B,x){
return ObjectObserve(B,x,['add',
'update',
'delete',
'splice']);
function ArrayUnobserve(B,x){
return ObjectUnobserve(B,x);
function ObserverEnqueueIfActive(z,A,J){
if(!ObserverIsActive(z,A)||
!TypeMapHasType(ObserverGetAcceptTypes(z),J.type)){
return;
var x=ObserverGetCallback(z);
if(!%ObserverObjectAndRecordHaveSameOrigin(x,J.object,
J)){
return;
var E=CallbackInfoNormalize(x);
if((GetPendingObservers()===null)){
SetPendingObservers(nullProtoObject());
if((%_DebugIsActive()!=0)){
var K=++GetObservationStateJS().lastMicrotaskId;
var L="Object.observe";
%EnqueueMicrotask(function(){
%DebugAsyncTaskEvent({type:"willHandle",id:K,name:L});
ObserveMicrotaskRunner();
%DebugAsyncTaskEvent({type:"didHandle",id:K,name:L});
%DebugAsyncTaskEvent({type:"enqueue",id:K,name:L});
}else{
%EnqueueMicrotask(ObserveMicrotaskRunner);
GetPendingObservers()[E.priority]=x;
E.push(J);
function ObjectInfoEnqueueExternalChangeRecord(A,J,n){
if(!ObjectInfoHasActiveObservers(A))
return;
var M=!(n===(void 0));
var N=M?
{object:A.object,type:n}:
{object:A.object};
for(var O in J){
if(O==='object'||(M&&O==='type'))continue;
%DefineDataPropertyUnchecked(
N,O,J[O],1+4);
g(N);
ObjectInfoEnqueueInternalChangeRecord(A,N);
function ObjectInfoEnqueueInternalChangeRecord(A,J){
if((typeof(J.name)==='symbol'))return;
if(ChangeObserversIsOptimized(A.changeObservers)){
var z=A.changeObservers;
ObserverEnqueueIfActive(z,A,J);
return;
for(var F in A.changeObservers){
var z=A.changeObservers[F];
if((z===null))
continue;
ObserverEnqueueIfActive(z,A,J);
function BeginPerformSplice(P){
var A=ObjectInfoGet(P);
if(!(A===(void 0)))
ObjectInfoAddPerformingType(A,'splice');
function EndPerformSplice(P){
var A=ObjectInfoGet(P);
if(!(A===(void 0)))
ObjectInfoRemovePerformingType(A,'splice');
function EnqueueSpliceRecord(P,Q,R,S){
var A=ObjectInfoGet(P);
if(!ObjectInfoHasActiveObservers(A))
return;
var J={
type:'splice',
object:P,
index:Q,
removed:R,
addedCount:S
g(J);
g(J.removed);
ObjectInfoEnqueueInternalChangeRecord(A,J);
function NotifyChange(n,B,L,T){
var A=ObjectInfoGet(B);
if(!ObjectInfoHasActiveObservers(A))
return;
var J;
if(arguments.length==2){
J={type:n,object:B};
}else if(arguments.length==3){
J={type:n,object:B,name:L};
}else{
type:n,
object:B,
name:L,
oldValue:T
g(J);
ObjectInfoEnqueueInternalChangeRecord(A,J);
function ObjectNotifierNotify(J){
if(!(%_IsSpecObject(this)))
throw MakeTypeError(13,"notify");
var A=ObjectInfoGetFromNotifier(this);
if((A===(void 0)))
throw MakeTypeError(71);
if(!(typeof(J.type)==='string'))
throw MakeTypeError(74);
ObjectInfoEnqueueExternalChangeRecord(A,J);
function ObjectNotifierPerformChange(U,V){
if(!(%_IsSpecObject(this)))
throw MakeTypeError(13,"performChange");
var A=ObjectInfoGetFromNotifier(this);
if((A===(void 0)))
throw MakeTypeError(71);
if(!(typeof(U)==='string'))
throw MakeTypeError(73);
if(!(%_ClassOf(V)==='Function'))
throw MakeTypeError(72);
var W=%GetObjectContextNotifierPerformChange(A);
W(A,U,V);
function NativeObjectNotifierPerformChange(A,U,V){
ObjectInfoAddPerformingType(A,U);
var J;
try{
J=%_CallFunction((void 0),V);
}finally{
ObjectInfoRemovePerformingType(A,U);
if((%_IsSpecObject(J)))
ObjectInfoEnqueueExternalChangeRecord(A,J,U);
function ObjectGetNotifier(B){
if(!(%_IsSpecObject(B)))
throw MakeTypeError(70,"getNotifier","getNotifier");
if(%IsJSGlobalProxy(B))
throw MakeTypeError(66,"getNotifier");
if(%IsAccessCheckNeeded(B))
throw MakeTypeError(67,"getNotifier");
if(h(B))return null;
if(!%ObjectWasCreatedInCurrentOrigin(B))return null;
var X=%GetObjectContextObjectGetNotifier(B);
return X(B);
function NativeObjectGetNotifier(B){
var A=ObjectInfoGetOrCreate(B);
return ObjectInfoGetNotifier(A);
function CallbackDeliverPending(x){
var E=CallbackInfoGet(x);
if((E===(void 0))||(typeof(E)==='number'))
return false;
var F=E.priority;
CallbackInfoSet(x,F);
var l=GetPendingObservers();
if(!(l===null))
delete l[F];
var Y=[];
%MoveArrayContents(E,Y);
%DeliverObservationChangeRecords(x,Y);
return true;
function ObjectDeliverChangeRecords(x){
if(!(%_ClassOf(x)==='Function'))
throw MakeTypeError(69,"deliverChangeRecords");
while(CallbackDeliverPending(x)){}
function ObserveMicrotaskRunner(){
var l=GetPendingObservers();
if(!(l===null)){
SetPendingObservers(null);
for(var r in l){
CallbackDeliverPending(l[r]);
b.InstallFunctions(d,2,[
"deliverChangeRecords",ObjectDeliverChangeRecords,
"getNotifier",ObjectGetNotifier,
"observe",ObjectObserve,
"unobserve",ObjectUnobserve
b.InstallFunctions(c,2,[
"observe",ArrayObserve,
"unobserve",ArrayUnobserve
b.InstallFunctions(k,2,[
"notify",ObjectNotifierNotify,
"performChange",ObjectNotifierPerformChange
$observeNotifyChange=NotifyChange;
$observeEnqueueSpliceRecord=EnqueueSpliceRecord;
$observeBeginPerformSplice=BeginPerformSplice;
$observeEndPerformSplice=EndPerformSplice;
$observeNativeObjectObserve=NativeObjectObserve;
$observeNativeObjectGetNotifier=NativeObjectGetNotifier;
$observeNativeObjectNotifierPerformChange=NativeObjectNotifierPerformChange;
var $getHash;
var $getExistingHash;
var $mapSet;
var $mapHas;
var $mapDelete;
var $setAdd;
var $setHas;
var $setDelete;
var $mapFromArray;
var $setFromArray;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Map;
var d=a.Object;
var e=a.Set;
var g;
b.Import(function(h){
g=h.IntRandom;
var i;
b.Import(function(h){
i=h.NumberIsNaN;
function HashToEntry(j,k,l){
var m=(k&((l)-1));
return((%_FixedArrayGet(j,(3+(m))|0)));
%SetForceInlineFlag(HashToEntry);
function SetFindEntry(j,l,n,k){
var o=HashToEntry(j,k,l);
if(o===-1)return o;
var p=((%_FixedArrayGet(j,((3+(l)+((o)<<1)))|0)));
if(n===p)return o;
var q=i(n);
while(true){
if(q&&i(p)){
return o;
o=((%_FixedArrayGet(j,((3+(l)+((o)<<1))+1)|0)));
if(o===-1)return o;
p=((%_FixedArrayGet(j,((3+(l)+((o)<<1)))|0)));
if(n===p)return o;
return-1;
%SetForceInlineFlag(SetFindEntry);
function MapFindEntry(j,l,n,k){
var o=HashToEntry(j,k,l);
if(o===-1)return o;
var p=((%_FixedArrayGet(j,((3+(l)+((o)*3)))|0)));
if(n===p)return o;
var q=i(n);
while(true){
if(q&&i(p)){
return o;
o=((%_FixedArrayGet(j,((3+(l)+((o)*3))+2)|0)));
if(o===-1)return o;
p=((%_FixedArrayGet(j,((3+(l)+((o)*3)))|0)));
if(n===p)return o;
return-1;
%SetForceInlineFlag(MapFindEntry);
function ComputeIntegerHash(n,r){
var k=n;
k=k^r;
k=~k+(k<<15);
k=k^(k>>>12);
k=k+(k<<2);
k=k^(k>>>4);
k=(k*2057)|0;
k=k^(k>>>16);
return k&0x3fffffff;
%SetForceInlineFlag(ComputeIntegerHash);
var t=(%CreateGlobalPrivateSymbol("hash_code_symbol"));
function GetExistingHash(n){
if(%_IsSmi(n)){
return ComputeIntegerHash(n,0);
if((typeof(n)==='string')){
var u=%_StringGetRawHashField(n);
if((u&1)===0){
return u>>>2;
}else if((%_IsSpecObject(n))&&!%_IsJSProxy(n)&&!(%_ClassOf(n)==='global')){
var k=(n[t]);
return k;
return %GenericHash(n);
%SetForceInlineFlag(GetExistingHash);
function GetHash(n){
var k=GetExistingHash(n);
if((k===(void 0))){
k=g()|0;
if(k===0)k=1;
(n[t]=k);
return k;
%SetForceInlineFlag(GetHash);
function SetConstructor(v){
if(!%_IsConstructCall()){
throw MakeTypeError(20,"Set");
%_SetInitialize(this);
if(!(v==null)){
var w=this.add;
if(!(%_ClassOf(w)==='Function')){
throw MakeTypeError(78,'add',this);
for(var x of v){
%_CallFunction(this,x,w);
function SetAdd(n){
if(!(%_ClassOf(this)==='Set')){
throw MakeTypeError(33,'Set.prototype.add',this);
if(n===0){
n=0;
var j=%_JSCollectionGetTable(this);
var l=((%_FixedArrayGet(j,(0)|0)));
var k=GetHash(n);
if(SetFindEntry(j,l,n,k)!==-1)return this;
var y=((%_FixedArrayGet(j,(1)|0)));
var z=((%_FixedArrayGet(j,(2)|0)));
var A=l<<1;
if((y+z)>=A){
%SetGrow(this);
j=%_JSCollectionGetTable(this);
l=((%_FixedArrayGet(j,(0)|0)));
y=((%_FixedArrayGet(j,(1)|0)));
z=((%_FixedArrayGet(j,(2)|0)));
var o=y+z;
var B=(3+(l)+((o)<<1));
var m=(k&((l)-1));
var C=((%_FixedArrayGet(j,(3+(m))|0)));
((%_FixedArraySet(j,(3+(m))|0,o)));
(((%_FixedArraySet(j,(1)|0,(y+1)|0))));
(%_FixedArraySet(j,(B)|0,n));
((%_FixedArraySet(j,(B+1)|0,(C)|0)));
return this;
function SetHas(n){
if(!(%_ClassOf(this)==='Set')){
throw MakeTypeError(33,'Set.prototype.has',this);
var j=%_JSCollectionGetTable(this);
var l=((%_FixedArrayGet(j,(0)|0)));
var k=GetExistingHash(n);
if((k===(void 0)))return false;
return SetFindEntry(j,l,n,k)!==-1;
function SetDelete(n){
if(!(%_ClassOf(this)==='Set')){
throw MakeTypeError(33,
'Set.prototype.delete',this);
var j=%_JSCollectionGetTable(this);
var l=((%_FixedArrayGet(j,(0)|0)));
var k=GetExistingHash(n);
if((k===(void 0)))return false;
var o=SetFindEntry(j,l,n,k);
if(o===-1)return false;
var y=((%_FixedArrayGet(j,(1)|0)))-1;
var z=((%_FixedArrayGet(j,(2)|0)))+1;
var B=(3+(l)+((o)<<1));
(%_FixedArraySet(j,(B)|0,%_TheHole()));
(((%_FixedArraySet(j,(1)|0,(y)|0))));
(((%_FixedArraySet(j,(2)|0,(z)|0))));
if(y<(l>>>1))%SetShrink(this);
return true;
function SetGetSize(){
if(!(%_ClassOf(this)==='Set')){
throw MakeTypeError(33,
'Set.prototype.size',this);
var j=%_JSCollectionGetTable(this);
return((%_FixedArrayGet(j,(1)|0)));
function SetClearJS(){
if(!(%_ClassOf(this)==='Set')){
throw MakeTypeError(33,
'Set.prototype.clear',this);
%_SetClear(this);
function SetForEach(D,E){
if(!(%_ClassOf(this)==='Set')){
throw MakeTypeError(33,
'Set.prototype.forEach',this);
if(!(%_ClassOf(D)==='Function'))throw MakeTypeError(12,D);
var F=false;
if((E===null)){
if(%IsSloppyModeFunction(D))E=(void 0);
}else if(!(E===(void 0))){
F=(!(%_IsSpecObject(E))&&%IsSloppyModeFunction(D));
var G=new SetIterator(this,2);
var n;
var H=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(D);
var I=[(void 0)];
while(%SetIteratorNext(G,I)){
if(H)%DebugPrepareStepInIfStepping(D);
n=I[0];
var J=F?$toObject(E):E;
%_CallFunction(J,n,n,this,D);
%SetCode(e,SetConstructor);
%FunctionSetLength(e,0);
%FunctionSetPrototype(e,new d());
%AddNamedProperty(e.prototype,"constructor",e,2);
%AddNamedProperty(e.prototype,symbolToStringTag,"Set",
2|1);
%FunctionSetLength(SetForEach,1);
b.InstallGetter(e.prototype,"size",SetGetSize);
b.InstallFunctions(e.prototype,2,[
"add",SetAdd,
"has",SetHas,
"delete",SetDelete,
"clear",SetClearJS,
"forEach",SetForEach
function MapConstructor(v){
if(!%_IsConstructCall()){
throw MakeTypeError(20,"Map");
%_MapInitialize(this);
if(!(v==null)){
var w=this.set;
if(!(%_ClassOf(w)==='Function')){
throw MakeTypeError(78,'set',this);
for(var K of v){
if(!(%_IsSpecObject(K))){
throw MakeTypeError(39,K);
%_CallFunction(this,K[0],K[1],w);
function MapGet(n){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.get',this);
var j=%_JSCollectionGetTable(this);
var l=((%_FixedArrayGet(j,(0)|0)));
var k=GetExistingHash(n);
if((k===(void 0)))return(void 0);
var o=MapFindEntry(j,l,n,k);
if(o===-1)return(void 0);
return((%_FixedArrayGet(j,((3+(l)+((o)*3))+1)|0)));
function MapSet(n,x){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.set',this);
if(n===0){
n=0;
var j=%_JSCollectionGetTable(this);
var l=((%_FixedArrayGet(j,(0)|0)));
var k=GetHash(n);
var o=MapFindEntry(j,l,n,k);
if(o!==-1){
var L=(3+(l)+((o)*3));
(%_FixedArraySet(j,(L+1)|0,x));
return this;
var y=((%_FixedArrayGet(j,(1)|0)));
var z=((%_FixedArrayGet(j,(2)|0)));
var A=l<<1;
if((y+z)>=A){
%MapGrow(this);
j=%_JSCollectionGetTable(this);
l=((%_FixedArrayGet(j,(0)|0)));
y=((%_FixedArrayGet(j,(1)|0)));
z=((%_FixedArrayGet(j,(2)|0)));
o=y+z;
var B=(3+(l)+((o)*3));
var m=(k&((l)-1));
var C=((%_FixedArrayGet(j,(3+(m))|0)));
((%_FixedArraySet(j,(3+(m))|0,o)));
(((%_FixedArraySet(j,(1)|0,(y+1)|0))));
(%_FixedArraySet(j,(B)|0,n));
(%_FixedArraySet(j,(B+1)|0,x));
(%_FixedArraySet(j,(B+2)|0,C));
return this;
function MapHas(n){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.has',this);
var j=%_JSCollectionGetTable(this);
var l=((%_FixedArrayGet(j,(0)|0)));
var k=GetHash(n);
return MapFindEntry(j,l,n,k)!==-1;
function MapDelete(n){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.delete',this);
var j=%_JSCollectionGetTable(this);
var l=((%_FixedArrayGet(j,(0)|0)));
var k=GetHash(n);
var o=MapFindEntry(j,l,n,k);
if(o===-1)return false;
var y=((%_FixedArrayGet(j,(1)|0)))-1;
var z=((%_FixedArrayGet(j,(2)|0)))+1;
var B=(3+(l)+((o)*3));
(%_FixedArraySet(j,(B)|0,%_TheHole()));
(%_FixedArraySet(j,(B+1)|0,%_TheHole()));
(((%_FixedArraySet(j,(1)|0,(y)|0))));
(((%_FixedArraySet(j,(2)|0,(z)|0))));
if(y<(l>>>1))%MapShrink(this);
return true;
function MapGetSize(){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.size',this);
var j=%_JSCollectionGetTable(this);
return((%_FixedArrayGet(j,(1)|0)));
function MapClearJS(){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.clear',this);
%_MapClear(this);
function MapForEach(D,E){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.forEach',this);
if(!(%_ClassOf(D)==='Function'))throw MakeTypeError(12,D);
var F=false;
if((E===null)){
if(%IsSloppyModeFunction(D))E=(void 0);
}else if(!(E===(void 0))){
F=(!(%_IsSpecObject(E))&&%IsSloppyModeFunction(D));
var G=new MapIterator(this,3);
var H=(%_DebugIsActive()!=0)&&%DebugCallbackSupportsStepping(D);
var I=[(void 0),(void 0)];
while(%MapIteratorNext(G,I)){
if(H)%DebugPrepareStepInIfStepping(D);
var J=F?$toObject(E):E;
%_CallFunction(J,I[1],I[0],this,D);
%SetCode(c,MapConstructor);
%FunctionSetLength(c,0);
%FunctionSetPrototype(c,new d());
%AddNamedProperty(c.prototype,"constructor",c,2);
%AddNamedProperty(
c.prototype,symbolToStringTag,"Map",2|1);
%FunctionSetLength(MapForEach,1);
b.InstallGetter(c.prototype,"size",MapGetSize);
b.InstallFunctions(c.prototype,2,[
"get",MapGet,
"set",MapSet,
"has",MapHas,
"delete",MapDelete,
"clear",MapClearJS,
"forEach",MapForEach
$getHash=GetHash;
$getExistingHash=GetExistingHash;
$mapGet=MapGet;
$mapSet=MapSet;
$mapHas=MapHas;
$mapDelete=MapDelete;
$setAdd=SetAdd;
$setHas=SetHas;
$setDelete=SetDelete;
$mapFromArray=function(M){
var N=new c;
var O=M.length;
for(var P=0;P<O;P+=2){
var n=M[P];
var x=M[P+1];
%_CallFunction(N,n,x,MapSet);
return N;
$setFromArray=function(M){
var Q=new e;
var O=M.length;
for(var P=0;P<O;++P){
%_CallFunction(Q,M[P],SetAdd);
return Q;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Object;
var d=a.WeakMap;
var e=a.WeakSet;
function WeakMapConstructor(g){
if(!%_IsConstructCall()){
throw MakeTypeError(20,"WeakMap");
%WeakCollectionInitialize(this);
if(!(g==null)){
var h=this.set;
if(!(%_ClassOf(h)==='Function')){
throw MakeTypeError(78,'set',this);
for(var i of g){
if(!(%_IsSpecObject(i))){
throw MakeTypeError(39,i);
%_CallFunction(this,i[0],i[1],h);
function WeakMapGet(j){
if(!(%_ClassOf(this)==='WeakMap')){
throw MakeTypeError(33,
'WeakMap.prototype.get',this);
if(!(%_IsSpecObject(j)))return(void 0);
var k=$getExistingHash(j);
if((k===(void 0)))return(void 0);
return %WeakCollectionGet(this,j,k);
function WeakMapSet(j,l){
if(!(%_ClassOf(this)==='WeakMap')){
throw MakeTypeError(33,
'WeakMap.prototype.set',this);
if(!(%_IsSpecObject(j)))throw MakeTypeError(134);
return %WeakCollectionSet(this,j,l,$getHash(j));
function WeakMapHas(j){
if(!(%_ClassOf(this)==='WeakMap')){
throw MakeTypeError(33,
'WeakMap.prototype.has',this);
if(!(%_IsSpecObject(j)))return false;
var k=$getExistingHash(j);
if((k===(void 0)))return false;
return %WeakCollectionHas(this,j,k);
function WeakMapDelete(j){
if(!(%_ClassOf(this)==='WeakMap')){
throw MakeTypeError(33,
'WeakMap.prototype.delete',this);
if(!(%_IsSpecObject(j)))return false;
var k=$getExistingHash(j);
if((k===(void 0)))return false;
return %WeakCollectionDelete(this,j,k);
%SetCode(d,WeakMapConstructor);
%FunctionSetLength(d,0);
%FunctionSetPrototype(d,new c());
%AddNamedProperty(d.prototype,"constructor",d,
%AddNamedProperty(d.prototype,symbolToStringTag,"WeakMap",
2|1);
b.InstallFunctions(d.prototype,2,[
"get",WeakMapGet,
"set",WeakMapSet,
"has",WeakMapHas,
"delete",WeakMapDelete
function WeakSetConstructor(g){
if(!%_IsConstructCall()){
throw MakeTypeError(20,"WeakSet");
%WeakCollectionInitialize(this);
if(!(g==null)){
var h=this.add;
if(!(%_ClassOf(h)==='Function')){
throw MakeTypeError(78,'add',this);
for(var l of g){
%_CallFunction(this,l,h);
function WeakSetAdd(l){
if(!(%_ClassOf(this)==='WeakSet')){
throw MakeTypeError(33,
'WeakSet.prototype.add',this);
if(!(%_IsSpecObject(l)))throw MakeTypeError(135);
return %WeakCollectionSet(this,l,true,$getHash(l));
function WeakSetHas(l){
if(!(%_ClassOf(this)==='WeakSet')){
throw MakeTypeError(33,
'WeakSet.prototype.has',this);
if(!(%_IsSpecObject(l)))return false;
var k=$getExistingHash(l);
if((k===(void 0)))return false;
return %WeakCollectionHas(this,l,k);
function WeakSetDelete(l){
if(!(%_ClassOf(this)==='WeakSet')){
throw MakeTypeError(33,
'WeakSet.prototype.delete',this);
if(!(%_IsSpecObject(l)))return false;
var k=$getExistingHash(l);
if((k===(void 0)))return false;
return %WeakCollectionDelete(this,l,k);
%SetCode(e,WeakSetConstructor);
%FunctionSetLength(e,0);
%FunctionSetPrototype(e,new c());
%AddNamedProperty(e.prototype,"constructor",e,
%AddNamedProperty(e.prototype,symbolToStringTag,"WeakSet",
2|1);
b.InstallFunctions(e.prototype,2,[
"add",WeakSetAdd,
"has",WeakSetHas,
"delete",WeakSetDelete
var $mapEntries;
var $mapIteratorNext;
var $setIteratorNext;
var $setValues;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Map;
var d=a.Set;
function SetIteratorConstructor(e,g){
%SetIteratorInitialize(this,e,g);
function SetIteratorNextJS(){
if(!(%_ClassOf(this)==='Set Iterator')){
throw MakeTypeError(33,
'Set Iterator.prototype.next',this);
var h=[(void 0),(void 0)];
var i={value:h,done:false};
switch(%SetIteratorNext(this,h)){
case 0:
i.value=(void 0);
i.done=true;
break;
case 2:
i.value=h[0];
break;
case 3:
h[1]=h[0];
break;
return i;
function SetEntries(){
if(!(%_ClassOf(this)==='Set')){
throw MakeTypeError(33,
'Set.prototype.entries',this);
return new SetIterator(this,3);
function SetValues(){
if(!(%_ClassOf(this)==='Set')){
throw MakeTypeError(33,
'Set.prototype.values',this);
return new SetIterator(this,2);
%SetCode(SetIterator,SetIteratorConstructor);
%FunctionSetPrototype(SetIterator,{__proto__:$iteratorPrototype});
%FunctionSetInstanceClassName(SetIterator,'Set Iterator');
b.InstallFunctions(SetIterator.prototype,2,[
'next',SetIteratorNextJS
%AddNamedProperty(SetIterator.prototype,symbolToStringTag,
"Set Iterator",1|2);
b.InstallFunctions(d.prototype,2,[
'entries',SetEntries,
'keys',SetValues,
'values',SetValues
%AddNamedProperty(d.prototype,symbolIterator,SetValues,2);
$setIteratorNext=SetIteratorNextJS;
$setValues=SetValues;
function MapIteratorConstructor(j,g){
%MapIteratorInitialize(this,j,g);
function MapIteratorNextJS(){
if(!(%_ClassOf(this)==='Map Iterator')){
throw MakeTypeError(33,
'Map Iterator.prototype.next',this);
var h=[(void 0),(void 0)];
var i={value:h,done:false};
switch(%MapIteratorNext(this,h)){
case 0:
i.value=(void 0);
i.done=true;
break;
case 1:
i.value=h[0];
break;
case 2:
i.value=h[1];
break;
return i;
function MapEntries(){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.entries',this);
return new MapIterator(this,3);
function MapKeys(){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.keys',this);
return new MapIterator(this,1);
function MapValues(){
if(!(%_ClassOf(this)==='Map')){
throw MakeTypeError(33,
'Map.prototype.values',this);
return new MapIterator(this,2);
%SetCode(MapIterator,MapIteratorConstructor);
%FunctionSetPrototype(MapIterator,{__proto__:$iteratorPrototype});
%FunctionSetInstanceClassName(MapIterator,'Map Iterator');
b.InstallFunctions(MapIterator.prototype,2,[
'next',MapIteratorNextJS
%AddNamedProperty(MapIterator.prototype,symbolToStringTag,
"Map Iterator",1|2);
b.InstallFunctions(c.prototype,2,[
'entries',MapEntries,
'keys',MapKeys,
'values',MapValues
%AddNamedProperty(c.prototype,symbolIterator,MapEntries,2);
$mapEntries=MapEntries;
$mapIteratorNext=MapIteratorNextJS;
var $promiseCreate;
var $promiseResolve;
var $promiseReject;
var $promiseChain;
var $promiseCatch;
var $promiseThen;
var $promiseHasUserDefinedRejectHandler;
var $promiseStatus;
var $promiseValue;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=b.InternalArray;
var d=(%CreateGlobalPrivateSymbol("Promise#status"));
var e=(%CreateGlobalPrivateSymbol("Promise#value"));
var g=(%CreateGlobalPrivateSymbol("Promise#onResolve"));
var h=(%CreateGlobalPrivateSymbol("Promise#onReject"));
var i=(%CreateGlobalPrivateSymbol("Promise#raw"));
var j=%PromiseHasHandlerSymbol();
var k=0;
var l=function Promise(m){
if(m===i)return;
if(!%_IsConstructCall())throw MakeTypeError(51,this);
if(!(%_ClassOf(m)==='Function'))
throw MakeTypeError(97,m);
var n=PromiseInit(this);
try{
%DebugPushPromise(n,Promise);
m(function(o){PromiseResolve(n,o)},
function(p){PromiseReject(n,p)});
}catch(e){
PromiseReject(n,e);
}finally{
%DebugPopPromise();
function PromiseSet(n,q,r,t,u){
(n[d]=q);
(n[e]=r);
(n[g]=t);
(n[h]=u);
if((%_DebugIsActive()!=0)){
%DebugPromiseEvent({promise:n,status:q,value:r});
return n;
function PromiseCreateAndSet(q,r){
var n=new l(i);
if((%_DebugIsActive()!=0))PromiseSet(n,0,(void 0));
return PromiseSet(n,q,r);
function PromiseInit(n){
return PromiseSet(
n,0,(void 0),new c,new c)
function PromiseDone(n,q,r,v){
if((n[d])===0){
var w=(n[v]);
if(w.length)PromiseEnqueue(r,w,q);
PromiseSet(n,q,r);
function PromiseCoerce(x,o){
if(!IsPromise(o)&&(%_IsSpecObject(o))){
var y;
try{
y=o.then;
}catch(p){
return %_CallFunction(x,p,PromiseRejected);
if((%_ClassOf(y)==='Function')){
var z=%_CallFunction(x,PromiseDeferred);
try{
%_CallFunction(o,z.resolve,z.reject,y);
}catch(p){
z.reject(p);
return z.promise;
return o;
function PromiseHandle(r,A,z){
try{
%DebugPushPromise(z.promise,PromiseHandle);
if((%_DebugIsActive()!=0&&%DebugCallbackSupportsStepping(A)))%DebugPrepareStepInIfStepping(A);
var B=A(r);
if(B===z.promise)
throw MakeTypeError(76,B);
else if(IsPromise(B))
%_CallFunction(B,z.resolve,z.reject,PromiseChain);
else
z.resolve(B);
}catch(exception){
try{z.reject(exception);}catch(e){}
}finally{
%DebugPopPromise();
function PromiseEnqueue(r,w,q){
var C,D,E=(%_DebugIsActive()!=0);
%EnqueueMicrotask(function(){
if(E){
%DebugAsyncTaskEvent({type:"willHandle",id:C,name:D});
for(var F=0;F<w.length;F+=2){
PromiseHandle(r,w[F],w[F+1])
if(E){
%DebugAsyncTaskEvent({type:"didHandle",id:C,name:D});
if(E){
C=++k;
D=q>0?"Promise.resolve":"Promise.reject";
%DebugAsyncTaskEvent({type:"enqueue",id:C,name:D});
function PromiseIdResolveHandler(o){return o}
function PromiseIdRejectHandler(p){throw p}
function PromiseNopResolver(){}
function IsPromise(o){
return(%_IsSpecObject(o))&&(!(o[d]===(void 0)));
function PromiseCreate(){
return new l(PromiseNopResolver)
function PromiseResolve(n,o){
PromiseDone(n,+1,o,g)
function PromiseReject(n,p){
if((n[d])==0){
var G=(%_DebugIsActive()!=0);
if(G||!(!(n[j]===(void 0)))){
%PromiseRejectEvent(n,p,G);
PromiseDone(n,-1,p,h)
function PromiseDeferred(){
if(this===l){
var n=PromiseInit(new l(i));
return{
promise:n,
resolve:function(o){PromiseResolve(n,o)},
reject:function(p){PromiseReject(n,p)}
}else{
var B={promise:(void 0),reject:(void 0),resolve:(void 0)};
B.promise=new this(function(H,I){
B.resolve=H;
B.reject=I;
return B;
function PromiseResolved(o){
if(this===l){
return PromiseCreateAndSet(+1,o);
}else{
return new this(function(H,I){H(o)});
function PromiseRejected(p){
var n;
if(this===l){
n=PromiseCreateAndSet(-1,p);
%PromiseRejectEvent(n,p,false);
}else{
n=new this(function(H,I){I(p)});
return n;
function PromiseChain(t,u){
t=(t===(void 0))?PromiseIdResolveHandler:t;
u=(u===(void 0))?PromiseIdRejectHandler:u;
var z=%_CallFunction(this.constructor,PromiseDeferred);
switch((this[d])){
case(void 0):
throw MakeTypeError(51,this);
case 0:
(this[g]).push(t,z);
(this[h]).push(u,z);
break;
case+1:
PromiseEnqueue((this[e]),
[t,z],
+1);
break;
case-1:
if(!(!(this[j]===(void 0)))){
%PromiseRevokeReject(this);
PromiseEnqueue((this[e]),
[u,z],
-1);
break;
(this[j]=true);
if((%_DebugIsActive()!=0)){
%DebugPromiseEvent({promise:z.promise,parentPromise:this});
return z.promise;
function PromiseCatch(u){
return this.then((void 0),u);
function PromiseThen(t,u){
t=(%_ClassOf(t)==='Function')?t
:PromiseIdResolveHandler;
u=(%_ClassOf(u)==='Function')?u
:PromiseIdRejectHandler;
var J=this;
var x=this.constructor;
return %_CallFunction(
this,
function(o){
o=PromiseCoerce(x,o);
if(o===J){
if((%_DebugIsActive()!=0&&%DebugCallbackSupportsStepping(u)))%DebugPrepareStepInIfStepping(u);
return u(MakeTypeError(76,o));
}else if(IsPromise(o)){
return o.then(t,u);
}else{
if((%_DebugIsActive()!=0&&%DebugCallbackSupportsStepping(t)))%DebugPrepareStepInIfStepping(t);
return t(o);
PromiseChain
function PromiseCast(o){
return IsPromise(o)?o:new this(function(H){H(o)});
function PromiseAll(K){
var z=%_CallFunction(this,PromiseDeferred);
var L=[];
try{
var M=0;
var F=0;
for(var r of K){
this.resolve(r).then(
(function(F){
return function(o){
L[F]=o;
if(--M===0)z.resolve(L);
})(F),
function(p){z.reject(p);});
++F;
++M;
if(M===0){
z.resolve(L);
}catch(e){
z.reject(e)
return z.promise;
function PromiseRace(K){
var z=%_CallFunction(this,PromiseDeferred);
try{
for(var r of K){
this.resolve(r).then(
function(o){z.resolve(o)},
function(p){z.reject(p)});
}catch(e){
z.reject(e)
return z.promise;
function PromiseHasUserDefinedRejectHandlerRecursive(n){
var N=(n[h]);
if((N===(void 0)))return false;
for(var F=0;F<N.length;F+=2){
if(N[F]!=PromiseIdRejectHandler)return true;
if(PromiseHasUserDefinedRejectHandlerRecursive(N[F+1].promise)){
return true;
return false;
function PromiseHasUserDefinedRejectHandler(){
return PromiseHasUserDefinedRejectHandlerRecursive(this);
%AddNamedProperty(a,'Promise',l,2);
%AddNamedProperty(l.prototype,symbolToStringTag,"Promise",
2|1);
b.InstallFunctions(l,2,[
"defer",PromiseDeferred,
"accept",PromiseResolved,
"reject",PromiseRejected,
"all",PromiseAll,
"race",PromiseRace,
"resolve",PromiseCast
b.InstallFunctions(l.prototype,2,[
"chain",PromiseChain,
"then",PromiseThen,
"catch",PromiseCatch
$promiseCreate=PromiseCreate;
$promiseResolve=PromiseResolve;
$promiseReject=PromiseReject;
$promiseChain=PromiseChain;
$promiseCatch=PromiseCatch;
$promiseThen=PromiseThen;
$promiseHasUserDefinedRejectHandler=PromiseHasUserDefinedRejectHandler;
$promiseStatus=d;
$promiseValue=e;
var $errorToString;
var $getStackTraceLine;
var $messageGetPositionInLine;
var $messageGetLineNumber;
var $messageGetSourceLine;
var $noSideEffectToString;
var $stackOverflowBoilerplate;
var $stackTraceSymbol;
var $toDetailString;
var $Error;
var $EvalError;
var $RangeError;
var $ReferenceError;
var $SyntaxError;
var $TypeError;
var $URIError;
var MakeError;
var MakeEvalError;
var MakeRangeError;
var MakeReferenceError;
var MakeSyntaxError;
var MakeTypeError;
var MakeURIError;
(function(a,b){
%CheckIsBootstrapping();
var c=a.Object;
var d=b.InternalArray;
var e=b.ObjectDefineProperty;
var g;
var h;
var i;
var j;
var k;
b.Import(function(l){
g=l.ArrayJoin;
h=l.ObjectToString;
i=l.StringCharAt;
j=l.StringIndexOf;
k=l.StringSubstring;
var m;
var n;
var o;
var p;
var q;
var r;
var t;
function NoSideEffectsObjectToString(){
if((this===(void 0))&&!(%_IsUndetectableObject(this)))return"[object Undefined]";
if((this===null))return"[object Null]";
return"[object "+%_ClassOf(((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this)))+"]";
function NoSideEffectToString(u){
if((typeof(u)==='string'))return u;
if((typeof(u)==='number'))return %_NumberToString(u);
if((typeof(u)==='boolean'))return u?'true':'false';
if((u===(void 0)))return'undefined';
if((u===null))return'null';
if((%_IsFunction(u))){
var v=%_CallFunction(u,u,$functionSourceString);
if(v.length>128){
v=%_SubString(v,0,111)+"...<omitted>..."+
%_SubString(v,v.length-2,v.length);
return v;
if((typeof(u)==='symbol'))return %_CallFunction(u,$symbolToString);
if((%_IsObject(u))
&&%GetDataProperty(u,"toString")===h){
var w=%GetDataProperty(u,"constructor");
if(typeof w=="function"){
var x=w.name;
if((typeof(x)==='string')&&x!==""){
return"#<"+x+">";
if(CanBeSafelyTreatedAsAnErrorObject(u)){
return %_CallFunction(u,ErrorToString);
return %_CallFunction(u,NoSideEffectsObjectToString);
function CanBeSafelyTreatedAsAnErrorObject(u){
switch(%_ClassOf(u)){
case'Error':
case'EvalError':
case'RangeError':
case'ReferenceError':
case'SyntaxError':
case'TypeError':
case'URIError':
return true;
var y=%GetDataProperty(u,"toString");
return u instanceof m&&y===ErrorToString;
function ToStringCheckErrorObject(u){
if(CanBeSafelyTreatedAsAnErrorObject(u)){
return %_CallFunction(u,ErrorToString);
}else{
return $toString(u);
function ToDetailString(u){
if(u!=null&&(%_IsObject(u))&&u.toString===h){
var w=u.constructor;
if(typeof w=="function"){
var x=w.name;
if((typeof(x)==='string')&&x!==""){
return"#<"+x+">";
return ToStringCheckErrorObject(u);
function MakeGenericError(w,z,A,B,C){
if((A===(void 0))&&(typeof(z)==='string'))A=[];
return new w(FormatMessage(z,A,B,C));
%FunctionSetInstanceClassName(Script,'Script');
%AddNamedProperty(Script.prototype,'constructor',Script,
2|4|1);
%SetCode(Script,function(D){
throw MakeError(5);
function FormatMessage(z,A,B,C){
var A=NoSideEffectToString(A);
var B=NoSideEffectToString(B);
var C=NoSideEffectToString(C);
try{
return %FormatMessageString(z,A,B,C);
}catch(e){
return"<error>";
function GetLineNumber(E){
var F=%MessageGetStartPosition(E);
if(F==-1)return 0;
var G=%MessageGetScript(E);
var H=G.locationFromPosition(F,true);
if(H==null)return 0;
return H.line+1;
function GetSourceLine(E){
var G=%MessageGetScript(E);
var F=%MessageGetStartPosition(E);
var H=G.locationFromPosition(F,true);
if(H==null)return"";
return H.sourceText();
function ScriptLineFromPosition(I){
var J=0;
var K=this.lineCount()-1;
var L=this.line_ends;
if(I>L[K]){
return-1;
if(I<=L[0]){
return 0;
while(K>=1){
var M=(J+K)>>1;
if(I>L[M]){
J=M+1;
}else if(I<=L[M-1]){
K=M-1;
}else{
return M;
return-1;
function ScriptLocationFromPosition(I,
include_resource_offset){
var N=this.lineFromPosition(I);
if(N==-1)return null;
var L=this.line_ends;
var O=N==0?0:L[N-1]+1;
var P=L[N];
if(P>0&&%_CallFunction(this.source,P-1,i)=='\r'){
P--;
var Q=I-O;
if(include_resource_offset){
N+=this.line_offset;
if(N==this.line_offset){
Q+=this.column_offset;
return new SourceLocation(this,I,N,Q,O,P);
function ScriptLocationFromLine(R,S,T){
var N=0;
if(!(R===(void 0))){
N=R-this.line_offset;
var Q=S||0;
if(N==0){
Q-=this.column_offset;
var U=T||0;
if(N<0||Q<0||U<0)return null;
if(N==0){
return this.locationFromPosition(U+Q,false);
}else{
var V=this.lineFromPosition(U);
if(V==-1||V+N>=this.lineCount()){
return null;
return this.locationFromPosition(
this.line_ends[V+N-1]+1+Q);
function ScriptSourceSlice(W,X){
var Y=(W===(void 0))?this.line_offset
var Z=(X===(void 0))?this.line_offset+this.lineCount()
Y-=this.line_offset;
Z-=this.line_offset;
if(Y<0)Y=0;
if(Z>this.lineCount())Z=this.lineCount();
if(Y>=this.lineCount()||
Z<0||
Y>Z){
return null;
var L=this.line_ends;
var aa=Y==0?0:L[Y-1]+1;
var ab=Z==0?0:L[Z-1]+1;
return new SourceSlice(this,
Y+this.line_offset,
Z+this.line_offset,
aa,ab);
function ScriptSourceLine(R){
var N=0;
if(!(R===(void 0))){
N=R-this.line_offset;
if(N<0||this.lineCount()<=N){
return null;
var L=this.line_ends;
var O=N==0?0:L[N-1]+1;
var P=L[N];
return %_CallFunction(this.source,O,P,k);
function ScriptLineCount(){
return this.line_ends.length;
function ScriptLineEnd(ac){
return this.line_ends[ac];
function ScriptNameOrSourceURL(){
if(this.source_url)return this.source_url;
return this.name;
b.SetUpLockedPrototype(Script,[
"source",
"name",
"source_url",
"source_mapping_url",
"line_ends",
"line_offset",
"column_offset"
"lineFromPosition",ScriptLineFromPosition,
"locationFromPosition",ScriptLocationFromPosition,
"locationFromLine",ScriptLocationFromLine,
"sourceSlice",ScriptSourceSlice,
"sourceLine",ScriptSourceLine,
"lineCount",ScriptLineCount,
"nameOrSourceURL",ScriptNameOrSourceURL,
"lineEnd",ScriptLineEnd
function SourceLocation(G,I,N,Q,O,P){
this.script=G;
this.position=I;
this.line=N;
this.column=Q;
this.start=O;
this.end=P;
function SourceLocationSourceText(){
return %_CallFunction(this.script.source,
this.start,
this.end,
b.SetUpLockedPrototype(SourceLocation,
["script","position","line","column","start","end"],
["sourceText",SourceLocationSourceText]
function SourceSlice(G,Y,Z,aa,ab){
this.script=G;
this.from_line=Y;
this.to_line=Z;
this.from_position=aa;
this.to_position=ab;
function SourceSliceSourceText(){
return %_CallFunction(this.script.source,
this.from_position,
this.to_position,
b.SetUpLockedPrototype(SourceSlice,
["script","from_line","to_line","from_position","to_position"],
["sourceText",SourceSliceSourceText]
function GetPositionInLine(E){
var G=%MessageGetScript(E);
var F=%MessageGetStartPosition(E);
var H=G.locationFromPosition(F,false);
if(H==null)return-1;
return F-H.start;
function GetStackTraceLine(ad,ae,af,ag){
return new CallSite(ad,ae,af,false).toString();
var ah=(%CreatePrivateSymbol("CallSite#receiver"));
var ai=(%CreatePrivateSymbol("CallSite#function"));
var aj=(%CreatePrivateSymbol("CallSite#position"));
var ak=(%CreatePrivateSymbol("CallSite#strict_mode"));
function CallSite(al,ae,af,am){
(this[ah]=al);
(this[ai]=ae);
(this[aj]=af);
(this[ak]=am);
function CallSiteGetThis(){
return(this[ak])
?(void 0):(this[ah]);
function CallSiteGetFunction(){
return(this[ak])
?(void 0):(this[ai]);
function CallSiteGetPosition(){
return(this[aj]);
function CallSiteGetTypeName(){
return GetTypeName((this[ah]),false);
function CallSiteIsToplevel(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteIsToplevelRT(al,ae,af);
function CallSiteIsEval(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteIsEvalRT(al,ae,af);
function CallSiteGetEvalOrigin(){
var G=%FunctionGetScript((this[ai]));
return FormatEvalOrigin(G);
function CallSiteGetScriptNameOrSourceURL(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteGetScriptNameOrSourceUrlRT(al,ae,af);
function CallSiteGetFunctionName(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteGetFunctionNameRT(al,ae,af);
function CallSiteGetMethodName(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteGetMethodNameRT(al,ae,af);
function CallSiteGetFileName(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteGetFileNameRT(al,ae,af);
function CallSiteGetLineNumber(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteGetLineNumberRT(al,ae,af);
function CallSiteGetColumnNumber(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteGetColumnNumberRT(al,ae,af);
function CallSiteIsNative(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteIsNativeRT(al,ae,af);
function CallSiteIsConstructor(){
var al=(this[ah]);
var ae=(this[ai]);
var af=(this[aj]);
return %CallSiteIsConstructorRT(al,ae,af);
function CallSiteToString(){
var an;
var ao="";
if(this.isNative()){
ao="native";
}else{
an=this.getScriptNameOrSourceURL();
if(!an&&this.isEval()){
ao=this.getEvalOrigin();
ao+=", ";
if(an){
ao+=an;
}else{
ao+="<anonymous>";
var ap=this.getLineNumber();
if(ap!=null){
ao+=":"+ap;
var aq=this.getColumnNumber();
if(aq){
ao+=":"+aq;
var N="";
var ar=this.getFunctionName();
var as=true;
var at=this.isConstructor();
var au=!(this.isToplevel()||at);
if(au){
var av=GetTypeName((this[ah]),true);
var aw=this.getMethodName();
if(ar){
if(av&&
%_CallFunction(ar,av,j)!=0){
N+=av+".";
N+=ar;
if(aw&&
(%_CallFunction(ar,"."+aw,j)!=
ar.length-aw.length-1)){
N+=" [as "+aw+"]";
}else{
N+=av+"."+(aw||"<anonymous>");
}else if(at){
N+="new "+(ar||"<anonymous>");
}else if(ar){
N+=ar;
}else{
N+=ao;
as=false;
if(as){
N+=" ("+ao+")";
return N;
b.SetUpLockedPrototype(CallSite,["receiver","fun","pos"],[
"getThis",CallSiteGetThis,
"getTypeName",CallSiteGetTypeName,
"isToplevel",CallSiteIsToplevel,
"isEval",CallSiteIsEval,
"getEvalOrigin",CallSiteGetEvalOrigin,
"getScriptNameOrSourceURL",CallSiteGetScriptNameOrSourceURL,
"getFunction",CallSiteGetFunction,
"getFunctionName",CallSiteGetFunctionName,
"getMethodName",CallSiteGetMethodName,
"getFileName",CallSiteGetFileName,
"getLineNumber",CallSiteGetLineNumber,
"getColumnNumber",CallSiteGetColumnNumber,
"isNative",CallSiteIsNative,
"getPosition",CallSiteGetPosition,
"isConstructor",CallSiteIsConstructor,
"toString",CallSiteToString
function FormatEvalOrigin(G){
var ax=G.nameOrSourceURL();
if(ax){
return ax;
var ay="eval at ";
if(G.eval_from_function_name){
ay+=G.eval_from_function_name;
}else{
ay+="<anonymous>";
var az=G.eval_from_script;
if(az){
if(az.compilation_type==1){
ay+=" ("+FormatEvalOrigin(az)+")";
}else{
if(az.name){
ay+=" ("+az.name;
var H=az.locationFromPosition(
G.eval_from_script_position,true);
if(H){
ay+=":"+(H.line+1);
ay+=":"+(H.column+1);
ay+=")";
}else{
ay+=" (unknown source)";
return ay;
function FormatErrorString(aA){
try{
return %_CallFunction(aA,ErrorToString);
}catch(e){
try{
return"<error: "+e+">";
}catch(ee){
return"<error>";
function GetStackFrames(aB){
var aC=new d();
var aD=aB[0];
for(var M=1;M<aB.length;M+=4){
var ad=aB[M];
var ae=aB[M+1];
var aE=aB[M+2];
var aF=aB[M+3];
var af=%_IsSmi(aE)?aE:%FunctionGetPositionForOffset(aE,aF);
aD--;
aC.push(new CallSite(ad,ae,af,(aD<0)));
return aC;
var aG=false;
function FormatStackTrace(u,aB){
var aC=GetStackFrames(aB);
if((%_IsFunction(m.prepareStackTrace))&&
!aG){
var aH=[];
%MoveArrayContents(aC,aH);
aG=true;
var aI=(void 0);
try{
aI=m.prepareStackTrace(u,aH);
}catch(e){
throw e;
}finally{
aG=false;
return aI;
var aJ=new d();
aJ.push(FormatErrorString(u));
for(var M=0;M<aC.length;M++){
var aK=aC[M];
var N;
try{
N=aK.toString();
}catch(e){
try{
N="<error: "+e+">";
}catch(ee){
N="<error>";
aJ.push("    at "+N);
return %_CallFunction(aJ,"\n",g);
function GetTypeName(al,aL){
if((al==null))return null;
var w=al.constructor;
if(!w){
return aL?null:
%_CallFunction(al,NoSideEffectsObjectToString);
var x=w.name;
if(!x){
return aL?null:
%_CallFunction(al,NoSideEffectsObjectToString);
return x;
var aM=(%CreatePrivateSymbol("formatted stack trace"));
var aN=function(){
var aO=(void 0);
var aP=this;
while(aP){
var aO=
(aP[aM]);
if((aO===(void 0))){
var aI=(aP[$stackTraceSymbol]);
if((aI===(void 0))){
aP=%_GetPrototype(aP);
continue;
aO=FormatStackTrace(aP,aI);
(aP[$stackTraceSymbol]=(void 0));
(aP[aM]=aO);
return aO;
return(void 0);
var aQ=function(aR){
if((%HasOwnProperty(this,$stackTraceSymbol))){
(this[$stackTraceSymbol]=(void 0));
(this[aM]=aR);
var aS=function(){};
function DefineError(a,aT){
var aU=aT.name;
%AddNamedProperty(a,aU,aT,2);
if(aU=='Error'){
var aV=function(){};
%FunctionSetPrototype(aV,c.prototype);
%FunctionSetInstanceClassName(aV,'Error');
%FunctionSetPrototype(aT,new aV());
}else{
%FunctionSetPrototype(aT,new m());
%InternalSetPrototype(aT,m);
%FunctionSetInstanceClassName(aT,'Error');
%AddNamedProperty(aT.prototype,'constructor',aT,2);
%AddNamedProperty(aT.prototype,'name',aU,2);
%SetCode(aT,function(aW){
if(%_IsConstructCall()){
try{aS(this,aT);}catch(e){}
if(!(aW===(void 0))){
%AddNamedProperty(this,'message',$toString(aW),2);
}else{
return new aT(aW);
%SetNativeFlag(aT);
return aT;
m=DefineError(a,function Error(){});
t=DefineError(a,function EvalError(){});
o=DefineError(a,function RangeError(){});
r=DefineError(a,function ReferenceError(){});
q=DefineError(a,function SyntaxError(){});
n=DefineError(a,function TypeError(){});
p=DefineError(a,function URIError(){});
%AddNamedProperty(m.prototype,'message','',2);
var aX=new d();
var aY=new c();
function GetPropertyWithoutInvokingMonkeyGetters(aA,aU){
var aZ=aA;
while(aZ&&!%HasOwnProperty(aZ,aU)){
aZ=%_GetPrototype(aZ);
if((aZ===null))return(void 0);
if(!(%_IsObject(aZ)))return aA[aU];
var ba=%GetOwnProperty(aZ,aU);
if(ba&&ba[0]){
var bb=aU==="name";
if(aZ===r.prototype)
return bb?"ReferenceError":(void 0);
if(aZ===q.prototype)
return bb?"SyntaxError":(void 0);
if(aZ===n.prototype)
return bb?"TypeError":(void 0);
return aA[aU];
function ErrorToStringDetectCycle(aA){
if(!%PushIfAbsent(aX,aA))throw aY;
try{
var aU=GetPropertyWithoutInvokingMonkeyGetters(aA,"name");
aU=(aU===(void 0))?"Error":((typeof(%IS_VAR(aU))==='string')?aU:$nonStringToString(aU));
var E=GetPropertyWithoutInvokingMonkeyGetters(aA,"message");
E=(E===(void 0))?"":((typeof(%IS_VAR(E))==='string')?E:$nonStringToString(E));
if(aU==="")return E;
if(E==="")return aU;
return aU+": "+E;
}finally{
aX.length=aX.length-1;
function ErrorToString(){
if(!(%_IsSpecObject(this))){
throw MakeTypeError(13,"Error.prototype.toString");
try{
return ErrorToStringDetectCycle(this);
}catch(e){
if(e===aY){
return'';
throw e;
b.InstallFunctions(m.prototype,2,
['toString',ErrorToString]);
$errorToString=ErrorToString;
$getStackTraceLine=GetStackTraceLine;
$messageGetPositionInLine=GetPositionInLine;
$messageGetLineNumber=GetLineNumber;
$messageGetSourceLine=GetSourceLine;
$noSideEffectToString=NoSideEffectToString;
$toDetailString=ToDetailString;
$Error=m;
$EvalError=t;
$RangeError=o;
$ReferenceError=r;
$SyntaxError=q;
$TypeError=n;
$URIError=p;
MakeError=function(z,A,B,C){
return MakeGenericError(m,z,A,B,C);
MakeEvalError=function(z,A,B,C){
return MakeGenericError(t,z,A,B,C);
MakeRangeError=function(z,A,B,C){
return MakeGenericError(o,z,A,B,C);
MakeReferenceError=function(z,A,B,C){
return MakeGenericError(r,z,A,B,C);
MakeSyntaxError=function(z,A,B,C){
return MakeGenericError(q,z,A,B,C);
MakeTypeError=function(z,A,B,C){
return MakeGenericError(n,z,A,B,C);
MakeURIError=function(){
return MakeGenericError(p,233);
$stackOverflowBoilerplate=MakeRangeError(145);
%DefineAccessorPropertyUnchecked($stackOverflowBoilerplate,'stack',
aN,aQ,
aS=function captureStackTrace(u,bc){
e(u,'stack',{get:aN,
set:aQ,
configurable:true});
%CollectStackTrace(u,bc?bc:aS);
m.captureStackTrace=aS;
var $jsonSerializeAdapter;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.JSON;
var d=b.InternalArray;
var e;
var g;
var h;
b.Import(function(i){
e=i.MathMax;
g=i.MathMin;
h=i.ObjectHasOwnProperty;
function Revive(j,k,l){
var m=j[k];
if((%_IsObject(m))){
if((%_IsArray(m))){
var n=m.length;
for(var o=0;o<n;o++){
var p=Revive(m,%_NumberToString(o),l);
m[o]=p;
}else{
for(var q in m){
if((%_CallFunction(m,q,h))){
var p=Revive(m,q,l);
if((p===(void 0))){
delete m[q];
}else{
m[q]=p;
return %_CallFunction(j,k,m,l);
function JSONParse(r,l){
var t=%ParseJson(((typeof(%IS_VAR(r))==='string')?r:$nonStringToString(r)));
if((%_ClassOf(l)==='Function')){
return Revive({'':t},'',l);
}else{
return t;
function SerializeArray(u,v,w,x,y){
if(!%PushIfAbsent(w,u))throw MakeTypeError(17);
var z=x;
x+=y;
var A=new d();
var B=u.length;
for(var o=0;o<B;o++){
var C=JSONSerialize(%_NumberToString(o),u,v,w,
x,y);
if((C===(void 0))){
C="null";
A.push(C);
var D;
if(y==""){
D="["+A.join(",")+"]";
}else if(A.length>0){
var E=",\n"+x;
D="[\n"+x+A.join(E)+"\n"+
z+"]";
}else{
D="[]";
w.pop();
return D;
function SerializeObject(u,v,w,x,y){
if(!%PushIfAbsent(w,u))throw MakeTypeError(17);
var z=x;
x+=y;
var A=new d();
if((%_IsArray(v))){
var n=v.length;
for(var o=0;o<n;o++){
if((%_CallFunction(v,o,h))){
var q=v[o];
var C=JSONSerialize(q,u,v,w,x,y);
if(!(C===(void 0))){
var F=%QuoteJSONString(q)+":";
if(y!="")F+=" ";
F+=C;
A.push(F);
}else{
for(var q in u){
if((%_CallFunction(u,q,h))){
var C=JSONSerialize(q,u,v,w,x,y);
if(!(C===(void 0))){
var F=%QuoteJSONString(q)+":";
if(y!="")F+=" ";
F+=C;
A.push(F);
var D;
if(y==""){
D="{"+A.join(",")+"}";
}else if(A.length>0){
var E=",\n"+x;
D="{\n"+x+A.join(E)+"\n"+
z+"}";
}else{
D="{}";
w.pop();
return D;
function JSONSerialize(G,j,v,w,x,y){
var u=j[G];
if((%_IsSpecObject(u))){
var H=u.toJSON;
if((%_ClassOf(H)==='Function')){
u=%_CallFunction(u,G,H);
if((%_ClassOf(v)==='Function')){
u=%_CallFunction(j,G,u,v);
if((typeof(u)==='string')){
return %QuoteJSONString(u);
}else if((typeof(u)==='number')){
return((%_IsSmi(%IS_VAR(u))||u-u==0)?%_NumberToString(u):"null");
}else if((typeof(u)==='boolean')){
return u?"true":"false";
}else if((u===null)){
return"null";
}else if((%_IsSpecObject(u))&&!(typeof u=="function")){
if((%_IsArray(u))){
return SerializeArray(u,v,w,x,y);
}else if((%_ClassOf(u)==='Number')){
u=$toNumber(u);
return((%_IsSmi(%IS_VAR(u))||u-u==0)?%_NumberToString(u):"null");
}else if((%_ClassOf(u)==='String')){
return %QuoteJSONString($toString(u));
}else if((%_ClassOf(u)==='Boolean')){
return %_ValueOf(u)?"true":"false";
}else{
return SerializeObject(u,v,w,x,y);
return(void 0);
function JSONStringify(u,v,I){
if(%_ArgumentsLength()==1){
return %BasicJSONStringify(u);
if((%_IsArray(v))){
var J=new d();
var K={__proto__:null};
var n=v.length;
for(var o=0;o<n;o++){
var L=v[o];
var M;
if((typeof(L)==='string')){
M=L;
}else if((typeof(L)==='number')){
M=%_NumberToString(L);
}else if((%_ClassOf(L)==='String')||(%_ClassOf(L)==='Number')){
M=$toString(L);
}else{
continue;
if(!K[M]){
J.push(M);
K[M]=true;
v=J;
if((%_IsObject(I))){
if((%_ClassOf(I)==='Number')){
I=$toNumber(I);
}else if((%_ClassOf(I)==='String')){
I=$toString(I);
var y;
if((typeof(I)==='number')){
I=e(0,g($toInteger(I),10));
y=%_SubString("          ",0,I);
}else if((typeof(I)==='string')){
if(I.length>10){
y=%_SubString(I,0,10);
}else{
y=I;
}else{
y="";
return JSONSerialize('',{'':u},v,new d(),"",y);
%AddNamedProperty(c,symbolToStringTag,"JSON",1|2);
b.InstallFunctions(c,2,[
"parse",JSONParse,
"stringify",JSONStringify
$jsonSerializeAdapter=function(G,N){
var j={};
j[G]=N;
return JSONSerialize(G,j,(void 0),new d(),"","");
var $arrayValues;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Array;
var d=a.Uint8Array;
var e=a.Int8Array;
var g=a.Uint16Array;
var h=a.Int16Array;
var i=a.Uint32Array;
var j=a.Int32Array;
var k=a.Float32Array;
var l=a.Float64Array;
var m=a.Uint8ClampedArray;
var n=(%CreateGlobalPrivateSymbol("ArrayIterator#object"));
var o=(%CreateGlobalPrivateSymbol("ArrayIterator#next"));
var p=(%CreateGlobalPrivateSymbol("ArrayIterator#kind"));
function ArrayIterator(){}
function CreateArrayIterator(q,r){
var t=$toObject(q);
var u=new ArrayIterator;
(u[n]=t);
(u[o]=0);
(u[p]=r);
return u;
function CreateIteratorResultObject(v,w){
return{value:v,done:w};
function ArrayIteratorIterator(){
return this;
function ArrayIteratorNext(){
var u=$toObject(this);
if(!(!(u[o]===(void 0)))){
throw MakeTypeError(33,
'Array Iterator.prototype.next',this);
var q=(u[n]);
if((q===(void 0))){
return CreateIteratorResultObject((void 0),true);
var x=(u[o]);
var y=(u[p]);
var z=(q.length>>>0);
if(x>=z){
(u[n]=(void 0));
return CreateIteratorResultObject((void 0),true);
(u[o]=x+1);
if(y==2){
return CreateIteratorResultObject(q[x],false);
if(y==3){
return CreateIteratorResultObject([x,q[x]],false);
return CreateIteratorResultObject(x,false);
function ArrayEntries(){
return CreateArrayIterator(this,3);
function ArrayValues(){
return CreateArrayIterator(this,2);
function ArrayKeys(){
return CreateArrayIterator(this,1);
%FunctionSetPrototype(ArrayIterator,{__proto__:$iteratorPrototype});
%FunctionSetInstanceClassName(ArrayIterator,'Array Iterator');
b.InstallFunctions(ArrayIterator.prototype,2,[
'next',ArrayIteratorNext
b.SetFunctionName(ArrayIteratorIterator,symbolIterator);
%AddNamedProperty(ArrayIterator.prototype,symbolIterator,
ArrayIteratorIterator,2);
%AddNamedProperty(ArrayIterator.prototype,symbolToStringTag,
"Array Iterator",1|2);
b.InstallFunctions(c.prototype,2,[
'entries',ArrayEntries,
'keys',ArrayKeys
%AddNamedProperty(c.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(d.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(d.prototype,'values',ArrayValues,2);
%AddNamedProperty(d.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(d.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(e.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(e.prototype,'values',ArrayValues,2);
%AddNamedProperty(e.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(e.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(g.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(g.prototype,'values',ArrayValues,2);
%AddNamedProperty(g.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(g.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(h.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(h.prototype,'values',ArrayValues,2);
%AddNamedProperty(h.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(h.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(i.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(i.prototype,'values',ArrayValues,2);
%AddNamedProperty(i.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(i.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(j.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(j.prototype,'values',ArrayValues,2);
%AddNamedProperty(j.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(j.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(k.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(k.prototype,'values',ArrayValues,2);
%AddNamedProperty(k.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(k.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(l.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(l.prototype,'values',ArrayValues,2);
%AddNamedProperty(l.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(l.prototype,symbolIterator,ArrayValues,
%AddNamedProperty(m.prototype,'entries',ArrayEntries,2);
%AddNamedProperty(m.prototype,'values',ArrayValues,2);
%AddNamedProperty(m.prototype,'keys',ArrayKeys,2);
%AddNamedProperty(m.prototype,symbolIterator,ArrayValues,
b.Export(function(A){
A.ArrayIteratorCreateResultObject=CreateIteratorResultObject;
$arrayValues=ArrayValues;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.String;
var d;
b.Import(function(e){
d=e.ArrayIteratorCreateResultObject;
var g=
(%CreateGlobalPrivateSymbol("StringIterator#iteratedString"));
var h=(%CreateGlobalPrivateSymbol("StringIterator#next"));
function StringIterator(){}
function CreateStringIterator(i){
var j=((typeof(%IS_VAR(i))==='string')?i:$nonStringToString(i));
var k=new StringIterator;
(k[g]=j);
(k[h]=0);
return k;
function StringIteratorNext(){
var k=$toObject(this);
if(!(!(k[h]===(void 0)))){
throw MakeTypeError(33,
'String Iterator.prototype.next');
var j=(k[g]);
if((j===(void 0))){
return d((void 0),true);
var l=(k[h]);
var m=(j.length>>>0);
if(l>=m){
(k[g]=(void 0));
return d((void 0),true);
var n=%_StringCharCodeAt(j,l);
var o=%_StringCharFromCode(n);
l++;
if(n>=0xD800&&n<=0xDBFF&&l<m){
var p=%_StringCharCodeAt(j,l);
if(p>=0xDC00&&p<=0xDFFF){
o+=%_StringCharFromCode(p);
l++;
(k[h]=l);
return d(o,false);
function StringPrototypeIterator(){
return CreateStringIterator(this);
%FunctionSetPrototype(StringIterator,{__proto__:$iteratorPrototype});
%FunctionSetInstanceClassName(StringIterator,'String Iterator');
b.InstallFunctions(StringIterator.prototype,2,[
'next',StringIteratorNext
%AddNamedProperty(StringIterator.prototype,symbolToStringTag,
"String Iterator",1|2);
b.SetFunctionName(StringPrototypeIterator,symbolIterator);
%AddNamedProperty(c.prototype,symbolIterator,
StringPrototypeIterator,2);
var $getTemplateCallSite;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Map;
var d=b.InternalArray;
var e=new c;
var g=c.prototype.get;
var h=c.prototype.set;
function SameCallSiteElements(i,j){
var k=i.length;
var j=j.raw;
if(k!==j.length)return false;
for(var l=0;l<k;++l){
if(i[l]!==j[l])return false;
return true;
function GetCachedCallSite(m,n){
var o=%_CallFunction(e,n,g);
if((o===(void 0)))return;
var k=o.length;
for(var l=0;l<k;++l){
if(SameCallSiteElements(m,o[l]))return o[l];
function SetCachedCallSite(m,n){
var o=%_CallFunction(e,n,g);
var p;
if((o===(void 0))){
p=new d(1);
p[0]=m;
%_CallFunction(e,n,p,h);
}else{
o.push(m);
return m;
$getTemplateCallSite=function(m,i,n){
var q=GetCachedCallSite(i,n);
if(!(q===(void 0)))return q;
%AddNamedProperty(m,"raw",%ObjectFreeze(i),
1|2|4);
return SetCachedCallSite(%ObjectFreeze(m),n);
(function(a,b){
'use strict';
%CheckIsBootstrapping();
var c=a.Array;
var d=a.Symbol;
var e;
var g;
var h;
var i;
var j;
var k;
b.Import(function(l){
e=l.GetIterator;
g=l.GetMethod;
h=l.MathMax;
i=l.MathMin;
j=l.ObjectIsFrozen;
k=l.ObjectDefineProperty;
function InnerArrayCopyWithin(m,n,o,p,q){
m=(%_IsSmi(%IS_VAR(m))?m:%NumberToInteger($toNumber(m)));
var r;
if(m<0){
r=h(q+m,0);
}else{
r=i(m,q);
n=(%_IsSmi(%IS_VAR(n))?n:%NumberToInteger($toNumber(n)));
var l;
if(n<0){
l=h(q+n,0);
}else{
l=i(n,q);
o=(o===(void 0))?q:(%_IsSmi(%IS_VAR(o))?o:%NumberToInteger($toNumber(o)));
var t;
if(o<0){
t=h(q+o,0);
}else{
t=i(o,q);
var u=i(t-l,q-r);
var v=1;
if(l<r&&r<(l+u)){
v=-1;
l=l+u-1;
r=r+u-1;
while(u>0){
if(l in p){
p[r]=p[l];
}else{
delete p[r];
l=l+v;
r=r+v;
u--;
return p;
function ArrayCopyWithin(m,n,o){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.copyWithin");
var p=((%_IsSpecObject(%IS_VAR(this)))?this:$toObject(this));
var q=$toLength(p.length);
return InnerArrayCopyWithin(m,n,o,p,q);
function InnerArrayFind(w,x,p,q){
if(!(%_ClassOf(w)==='Function')){
throw MakeTypeError(12,w);
var y=false;
if((x===null)){
if(%IsSloppyModeFunction(w))x=(void 0);
}else if(!(x===(void 0))){
y=(!(%_IsSpecObject(x))&&%IsSloppyModeFunction(w));
for(var z=0;z<q;z++){
var A=p[z];
var B=y?$toObject(x):x;
if(%_CallFunction(B,A,z,p,w)){
return A;
return;
function ArrayFind(w,x){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.find");
var p=$toObject(this);
var q=$toInteger(p.length);
return InnerArrayFind(w,x,p,q);
function InnerArrayFindIndex(w,x,p,q){
if(!(%_ClassOf(w)==='Function')){
throw MakeTypeError(12,w);
var y=false;
if((x===null)){
if(%IsSloppyModeFunction(w))x=(void 0);
}else if(!(x===(void 0))){
y=(!(%_IsSpecObject(x))&&%IsSloppyModeFunction(w));
for(var z=0;z<q;z++){
var A=p[z];
var B=y?$toObject(x):x;
if(%_CallFunction(B,A,z,p,w)){
return z;
return-1;
function ArrayFindIndex(w,x){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.findIndex");
var p=$toObject(this);
var q=$toInteger(p.length);
return InnerArrayFindIndex(w,x,p,q);
function InnerArrayFill(C,n,o,p,q){
var z=(n===(void 0))?0:(%_IsSmi(%IS_VAR(n))?n:%NumberToInteger($toNumber(n)));
var o=(o===(void 0))?q:(%_IsSmi(%IS_VAR(o))?o:%NumberToInteger($toNumber(o)));
if(z<0){
z+=q;
if(z<0)z=0;
}else{
if(z>q)z=q;
if(o<0){
o+=q;
if(o<0)o=0;
}else{
if(o>q)o=q;
if((o-z)>0&&j(p)){
throw MakeTypeError(9);
for(;z<o;z++)
p[z]=C;
return p;
function ArrayFill(C,n,o){
if((this==null)&&!(%_IsUndetectableObject(this)))throw MakeTypeError(14,"Array.prototype.fill");
var p=$toObject(this);
var q=(p.length>>>0);
return InnerArrayFill(C,n,o,p,q);
function AddArrayElement(D,p,z,C){
if(D===c){
%AddElement(p,z,C);
}else{
k(p,z,{
value:C,writable:true,configurable:true,enumerable:true
function ArrayFrom(E,F,G){
var H=$toObject(E);
var I=!(F===(void 0));
if(I){
if(!(%_ClassOf(F)==='Function')){
throw MakeTypeError(12,F);
}else if(%IsSloppyModeFunction(F)){
if((G===null)){
G=(void 0);
}else if(!(G===(void 0))){
G=((%_IsSpecObject(%IS_VAR(G)))?G:$toObject(G));
var J=g(H,symbolIterator);
var K;
var L;
var M;
var N;
if(!(J===(void 0))){
L=%IsConstructor(this)?new this():[];
var O=e(H,J);
K=0;
while(true){
var P=O.next();
if(!(%_IsObject(P))){
throw MakeTypeError(38,P);
if(P.done){
L.length=K;
return L;
N=P.value;
if(I){
M=%_CallFunction(G,N,K,F);
}else{
M=N;
AddArrayElement(this,L,K,M);
K++;
}else{
var Q=$toLength(H.length);
L=%IsConstructor(this)?new this(Q):new c(Q);
for(K=0;K<Q;++K){
N=H[K];
if(I){
M=%_CallFunction(G,N,K,F);
}else{
M=N;
AddArrayElement(this,L,K,M);
L.length=K;
return L;
function ArrayOf(){
var q=%_ArgumentsLength();
var D=this;
var p=%IsConstructor(D)?new D(q):[];
for(var z=0;z<q;z++){
AddArrayElement(D,p,z,%_Arguments(z));
p.length=q;
return p;
%FunctionSetLength(ArrayCopyWithin,2);
%FunctionSetLength(ArrayFrom,1);
%FunctionSetLength(ArrayFill,1);
%FunctionSetLength(ArrayFind,1);
%FunctionSetLength(ArrayFindIndex,1);
b.InstallFunctions(c,2,[
"from",ArrayFrom,
"of",ArrayOf
b.InstallFunctions(c.prototype,2,[
"copyWithin",ArrayCopyWithin,
"find",ArrayFind,
"findIndex",ArrayFindIndex,
"fill",ArrayFill
b.Export(function(r){
r.ArrayFrom=ArrayFrom;
r.InnerArrayCopyWithin=InnerArrayCopyWithin;
r.InnerArrayFill=InnerArrayFill;
r.InnerArrayFind=InnerArrayFind;
r.InnerArrayFindIndex=InnerArrayFindIndex;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Uint8Array;
var d=a.Int8Array;
var e=a.Uint16Array;
var g=a.Int16Array;
var h=a.Uint32Array;
var i=a.Int32Array;
var j=a.Float32Array;
var k=a.Float64Array;
var l=a.Uint8ClampedArray;
var m=a.Array;
var n;
var o;
var p;
var q;
var r;
var t;
var u;
var v;
var w;
var x;
var y;
var z;
var A;
var B;
var C;
var D;
var E;
var F;
var G;
var H;
b.Import(function(I){
n=I.ArrayFrom;
o=I.ArrayToString;
p=I.InnerArrayCopyWithin;
q=I.InnerArrayEvery;
r=I.InnerArrayFill;
t=I.InnerArrayFilter;
u=I.InnerArrayFind;
v=I.InnerArrayFindIndex;
w=I.InnerArrayForEach;
x=I.InnerArrayIndexOf;
y=I.InnerArrayJoin;
z=I.InnerArrayLastIndexOf;
A=I.InnerArrayMap;
InnerArrayReduce=I.InnerArrayReduce;
InnerArrayReduceRight=I.InnerArrayReduceRight;
B=I.InnerArrayReverse;
C=I.InnerArraySome;
D=I.InnerArraySort;
E=I.InnerArrayToLocaleString;
F=I.IsNaN;
G=I.MathMax;
H=I.MathMin;
function ConstructTypedArray(J,K){
if(!%IsConstructor(J)||(J.prototype===(void 0))||
!%HasOwnProperty(J.prototype,"BYTES_PER_ELEMENT")){
throw MakeTypeError(57);
return new J(K);
function ConstructTypedArrayLike(L,K){
return ConstructTypedArray(L.constructor,K);
function TypedArrayCopyWithin(M,N,O){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return p(M,N,O,this,P);
%FunctionSetLength(TypedArrayCopyWithin,2);
function TypedArrayEvery(Q,R){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return q(Q,R,this,P);
%FunctionSetLength(TypedArrayEvery,1);
function TypedArrayForEach(Q,R){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
w(Q,R,this,P);
%FunctionSetLength(TypedArrayForEach,1);
function TypedArrayFill(S,N,O){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return r(S,N,O,this,P);
%FunctionSetLength(TypedArrayFill,1);
function TypedArrayFilter(T,U){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
var V=t(T,U,this,P);
return ConstructTypedArrayLike(this,V);
%FunctionSetLength(TypedArrayFilter,1);
function TypedArrayFind(T,U){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return u(T,U,this,P);
%FunctionSetLength(TypedArrayFind,1);
function TypedArrayFindIndex(T,U){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return v(T,U,this,P);
%FunctionSetLength(TypedArrayFindIndex,1);
function TypedArrayReverse(){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return B(this,P);
function TypedArrayComparefn(W,X){
if(F(W)&&F(X)){
return F(X)?0:1;
if(F(W)){
return 1;
if(W===0&&W===X){
if(%_IsMinusZero(W)){
if(!%_IsMinusZero(X)){
return-1;
}else if(%_IsMinusZero(X)){
return 1;
return W-X;
function TypedArraySort(Y){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
if((Y===(void 0))){
Y=TypedArrayComparefn;
return %_CallFunction(this,P,Y,D);
function TypedArrayIndexOf(Z,aa){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return %_CallFunction(this,Z,aa,P,x);
%FunctionSetLength(TypedArrayIndexOf,1);
function TypedArrayLastIndexOf(Z,aa){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return %_CallFunction(this,Z,aa,P,
%_ArgumentsLength(),z);
%FunctionSetLength(TypedArrayLastIndexOf,1);
function TypedArrayMap(T,U){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
var V=A(T,U,this,P);
return ConstructTypedArrayLike(this,V);
%FunctionSetLength(TypedArrayMap,1);
function TypedArraySome(Q,R){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return C(Q,R,this,P);
%FunctionSetLength(TypedArraySome,1);
function TypedArrayToLocaleString(){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return E(this,P);
function TypedArrayToString(){
return %_CallFunction(this,o);
function TypedArrayJoin(ab){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return y(ab,this,P);
function TypedArrayReduce(ac,ad){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return InnerArrayReduce(ac,ad,this,P,
%_ArgumentsLength());
%FunctionSetLength(TypedArrayReduce,1);
function TypedArrayReduceRight(ac,ad){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var P=%_TypedArrayGetLength(this);
return InnerArrayReduceRight(ac,ad,this,P,
%_ArgumentsLength());
%FunctionSetLength(TypedArrayReduceRight,1);
function TypedArraySlice(N,O){
if(!%_IsTypedArray(this))throw MakeTypeError(57);
var ae=%_TypedArrayGetLength(this);
var af=(%_IsSmi(%IS_VAR(N))?N:%NumberToInteger($toNumber(N)));
var ag;
if(af<0){
ag=G(ae+af,0);
}else{
ag=H(af,ae);
var ah;
if((O===(void 0))){
ah=ae;
}else{
ah=(%_IsSmi(%IS_VAR(O))?O:%NumberToInteger($toNumber(O)));
var ai;
if(ah<0){
ai=G(ae+ah,0);
}else{
ai=H(ah,ae);
var aj=G(ai-ag,0);
var V=ConstructTypedArrayLike(this,aj);
var ak=0;
while(ag<ai){
var al=this[ag];
V[ak]=al;
ag++;
ak++;
return V;
function TypedArrayOf(){
var P=%_ArgumentsLength();
var V=new this(P);
for(var am=0;am<P;am++){
V[am]=%_Arguments(am);
return V;
function TypedArrayFrom(an,ao,U){
var V=%_CallFunction(m,an,ao,U,n);
return ConstructTypedArray(this,V);
%FunctionSetLength(TypedArrayFrom,1);
b.InstallFunctions(c,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(c.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
b.InstallFunctions(d,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(d.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
b.InstallFunctions(e,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(e.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
b.InstallFunctions(g,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(g.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
b.InstallFunctions(h,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(h.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
b.InstallFunctions(i,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(i.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
b.InstallFunctions(j,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(j.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
b.InstallFunctions(k,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(k.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
b.InstallFunctions(l,2|4|1,[
"from",TypedArrayFrom,
"of",TypedArrayOf
b.InstallFunctions(l.prototype,2,[
"copyWithin",TypedArrayCopyWithin,
"every",TypedArrayEvery,
"fill",TypedArrayFill,
"filter",TypedArrayFilter,
"find",TypedArrayFind,
"findIndex",TypedArrayFindIndex,
"indexOf",TypedArrayIndexOf,
"join",TypedArrayJoin,
"lastIndexOf",TypedArrayLastIndexOf,
"forEach",TypedArrayForEach,
"map",TypedArrayMap,
"reduce",TypedArrayReduce,
"reduceRight",TypedArrayReduceRight,
"reverse",TypedArrayReverse,
"slice",TypedArraySlice,
"some",TypedArraySome,
"sort",TypedArraySort,
"toString",TypedArrayToString,
"toLocaleString",TypedArrayToLocaleString
var $proxyDerivedGetTrap;
var $proxyDerivedHasTrap;
var $proxyDerivedSetTrap;
var $proxyEnumerate;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Function;
var d=a.Object;
var e;
b.Import(function(f){
e=f.ToNameArray;
function ProxyCreate(g,h){
if(!(%_IsSpecObject(g)))
throw MakeTypeError(82,"create")
if((h===(void 0)))
h=null
else if(!((%_IsSpecObject(h))||(h===null)))
throw MakeTypeError(87)
return %CreateJSProxy(g,h)
function ProxyCreateFunction(g,i,j){
if(!(%_IsSpecObject(g)))
throw MakeTypeError(82,"createFunction")
if(!(%_ClassOf(i)==='Function'))
throw MakeTypeError(90,"call")
if((j===(void 0))){
j=DerivedConstructTrap(i)
}else if((%_ClassOf(j)==='Function')){
var k=j
j=function(){
return %Apply(k,(void 0),arguments,0,%_ArgumentsLength());
}else{
throw MakeTypeError(90,"construct")
return %CreateJSFunctionProxy(
g,i,j,c.prototype)
function DerivedConstructTrap(i){
return function(){
var h=this.prototype
if(!(%_IsSpecObject(h)))h=d.prototype
var l={__proto__:h};
var m=%Apply(i,l,arguments,0,%_ArgumentsLength());
return(%_IsSpecObject(m))?m:l
function DelegateCallAndConstruct(i,j){
return function(){
return %Apply(%_IsConstructCall()?j:i,
this,arguments,0,%_ArgumentsLength())
function DerivedGetTrap(n,o){
var p=this.getPropertyDescriptor(o)
if((p===(void 0))){return p}
if('value'in p){
return p.value
}else{
if((p.get===(void 0))){return p.get}
return %_CallFunction(n,p.get)
function DerivedSetTrap(n,o,q){
var p=this.getOwnPropertyDescriptor(o)
if(p){
if('writable'in p){
if(p.writable){
p.value=q
this.defineProperty(o,p)
return true
}else{
return false
}else{
if(p.set){
%_CallFunction(n,q,p.set)
return true
}else{
return false
p=this.getPropertyDescriptor(o)
if(p){
if('writable'in p){
if(p.writable){
}else{
return false
}else{
if(p.set){
%_CallFunction(n,q,p.set)
return true
}else{
return false
this.defineProperty(o,{
value:q,
writable:true,
enumerable:true,
configurable:true});
return true;
function DerivedHasTrap(o){
return!!this.getPropertyDescriptor(o)
function DerivedHasOwnTrap(o){
return!!this.getOwnPropertyDescriptor(o)
function DerivedKeysTrap(){
var r=this.getOwnPropertyNames()
var s=[]
for(var t=0,count=0;t<r.length;++t){
var o=r[t]
if((typeof(o)==='symbol'))continue
var p=this.getOwnPropertyDescriptor(((typeof(%IS_VAR(o))==='string')?o:$nonStringToString(o)))
if(!(p===(void 0))&&p.enumerable){
s[count++]=r[t]
return s
function DerivedEnumerateTrap(){
var r=this.getPropertyNames()
var s=[]
for(var t=0,count=0;t<r.length;++t){
var o=r[t]
if((typeof(o)==='symbol'))continue
var p=this.getPropertyDescriptor(((typeof(%IS_VAR(o))==='string')?o:$nonStringToString(o)))
if(!(p===(void 0))){
if(!p.configurable){
throw MakeTypeError(88,
this,o,"getPropertyDescriptor")
if(p.enumerable)s[count++]=r[t]
return s
function ProxyEnumerate(u){
var g=%GetHandler(u)
if((g.enumerate===(void 0))){
return %Apply(DerivedEnumerateTrap,g,[],0,0)
}else{
return e(g.enumerate(),"enumerate",false)
var v=new d();
%AddNamedProperty(a,"Proxy",v,2);
b.InstallFunctions(v,2,[
"create",ProxyCreate,
"createFunction",ProxyCreateFunction
$proxyDerivedGetTrap=DerivedGetTrap;
$proxyDerivedHasTrap=DerivedHasTrap;
$proxyDerivedSetTrap=DerivedSetTrap;
$proxyEnumerate=ProxyEnumerate;
b.Export(function(w){
w.ProxyDelegateCallAndConstruct=DelegateCallAndConstruct;
w.ProxyDerivedHasOwnTrap=DerivedHasOwnTrap;
w.ProxyDerivedKeysTrap=DerivedKeysTrap;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Function;
var d;
b.Import(function(e){
d=e.NewFunctionString;
function GeneratorObjectNext(f){
if(!(%_ClassOf(this)==='Generator')){
throw MakeTypeError(33,
'[Generator].prototype.next',this);
var g=%GeneratorGetContinuation(this);
if(g>0){
if((%_DebugIsActive()!=0))%DebugPrepareStepInIfStepping(this);
try{
return %_GeneratorNext(this,f);
}catch(e){
%GeneratorClose(this);
throw e;
}else if(g==0){
return{value:void 0,done:true};
}else{
throw MakeTypeError(31);
function GeneratorObjectThrow(h){
if(!(%_ClassOf(this)==='Generator')){
throw MakeTypeError(33,
'[Generator].prototype.throw',this);
var g=%GeneratorGetContinuation(this);
if(g>0){
try{
return %_GeneratorThrow(this,h);
}catch(e){
%GeneratorClose(this);
throw e;
}else if(g==0){
throw h;
}else{
throw MakeTypeError(31);
function GeneratorFunctionConstructor(i){
var j=d(arguments,'function*');
var k=%GlobalProxy(GeneratorFunctionConstructor);
var l=%_CallFunction(k,%CompileString(j,true));
%FunctionMarkNameShouldPrintAsAnonymous(l);
return l;
%NeverOptimizeFunction(GeneratorObjectNext);
%NeverOptimizeFunction(GeneratorObjectThrow);
var m=GeneratorFunctionPrototype.prototype;
b.InstallFunctions(m,
["next",GeneratorObjectNext,
"throw",GeneratorObjectThrow]);
%AddNamedProperty(m,"constructor",
GeneratorFunctionPrototype,2|1);
%AddNamedProperty(m,
symbolToStringTag,"Generator",2|1);
%InternalSetPrototype(GeneratorFunctionPrototype,c.prototype);
%AddNamedProperty(GeneratorFunctionPrototype,
symbolToStringTag,"GeneratorFunction",2|1);
%AddNamedProperty(GeneratorFunctionPrototype,"constructor",
GeneratorFunction,2|1);
%InternalSetPrototype(GeneratorFunction,c);
%SetCode(GeneratorFunction,GeneratorFunctionConstructor);
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Object;
function CheckSharedTypedArray(d){
if(!%_IsSharedTypedArray(d)){
throw MakeTypeError(58,d);
function CheckSharedIntegerTypedArray(e){
if(!%_IsSharedIntegerTypedArray(e)){
throw MakeTypeError(59,e);
function AtomicsCompareExchangeJS(d,f,g,h){
CheckSharedTypedArray(d);
f=$toInteger(f);
if(f<0||f>=d.length){
return(void 0);
return %_AtomicsCompareExchange(d,f,g,h);
function AtomicsLoadJS(d,f){
CheckSharedTypedArray(d);
f=$toInteger(f);
if(f<0||f>=d.length){
return(void 0);
return %_AtomicsLoad(d,f);
function AtomicsStoreJS(d,f,i){
CheckSharedTypedArray(d);
f=$toInteger(f);
if(f<0||f>=d.length){
return(void 0);
return %_AtomicsStore(d,f,i);
function AtomicsAddJS(e,f,i){
CheckSharedIntegerTypedArray(e);
f=$toInteger(f);
if(f<0||f>=e.length){
return(void 0);
return %_AtomicsAdd(e,f,i);
function AtomicsSubJS(e,f,i){
CheckSharedIntegerTypedArray(e);
f=$toInteger(f);
if(f<0||f>=e.length){
return(void 0);
return %_AtomicsSub(e,f,i);
function AtomicsAndJS(e,f,i){
CheckSharedIntegerTypedArray(e);
f=$toInteger(f);
if(f<0||f>=e.length){
return(void 0);
return %_AtomicsAnd(e,f,i);
function AtomicsOrJS(e,f,i){
CheckSharedIntegerTypedArray(e);
f=$toInteger(f);
if(f<0||f>=e.length){
return(void 0);
return %_AtomicsOr(e,f,i);
function AtomicsXorJS(e,f,i){
CheckSharedIntegerTypedArray(e);
f=$toInteger(f);
if(f<0||f>=e.length){
return(void 0);
return %_AtomicsXor(e,f,i);
function AtomicsExchangeJS(e,f,i){
CheckSharedIntegerTypedArray(e);
f=$toInteger(f);
if(f<0||f>=e.length){
return(void 0);
return %_AtomicsExchange(e,f,i);
function AtomicsIsLockFreeJS(j){
return %_AtomicsIsLockFree(j);
function AtomicsConstructor(){}
var k=new AtomicsConstructor();
%InternalSetPrototype(k,c.prototype);
%AddNamedProperty(a,"Atomics",k,2);
%FunctionSetInstanceClassName(AtomicsConstructor,'Atomics');
%AddNamedProperty(k,symbolToStringTag,"Atomics",1|2);
b.InstallFunctions(k,2,[
"compareExchange",AtomicsCompareExchangeJS,
"load",AtomicsLoadJS,
"store",AtomicsStoreJS,
"add",AtomicsAddJS,
"sub",AtomicsSubJS,
"and",AtomicsAndJS,
"or",AtomicsOrJS,
"xor",AtomicsXorJS,
"exchange",AtomicsExchangeJS,
"isLockFree",AtomicsIsLockFreeJS,
(function(a,b){
'use strict';
%CheckIsBootstrapping();
var c=a.Array;
function ArrayIncludes(d,e){
var f=$toObject(this);
var g=$toLength(f.length);
if(g===0){
return false;
var h=$toInteger(e);
var i;
if(h>=0){
i=h;
}else{
i=g+h;
if(i<0){
i=0;
while(i<g){
var j=f[i];
if($sameValueZero(d,j)){
return true;
++i;
return false;
%FunctionSetLength(ArrayIncludes,1);
b.InstallFunctions(c.prototype,2,[
"includes",ArrayIncludes
(function(a,b){
'use strict';
%CheckIsBootstrapping();
b.InstallConstants(a.Symbol,[
"isConcatSpreadable",symbolIsConcatSpreadable
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Symbol;
b.InstallConstants(c,[
"toStringTag",symbolToStringTag
(function(a,b){
'use strict';
%CheckIsBootstrapping();
var c=a.RegExp;
function RegExpGetFlags(){
if(!(%_IsSpecObject(this))){
throw MakeTypeError(29,$toString(this));
var d='';
if(this.global)d+='g';
if(this.ignoreCase)d+='i';
if(this.multiline)d+='m';
if(this.unicode)d+='u';
if(this.sticky)d+='y';
return d;
%DefineAccessorPropertyUnchecked(c.prototype,'flags',
RegExpGetFlags,null,2);
%SetNativeFlag(RegExpGetFlags);
(function(a,b){
'use strict';
%CheckIsBootstrapping();
var c=a.Reflect;
b.InstallFunctions(c,2,[
"apply",$reflectApply,
"construct",$reflectConstruct
var $spreadArguments;
var $spreadIterable;
(function(a,b){
'use strict';
var c=b.InternalArray;
function SpreadArguments(){
var d=%_ArgumentsLength();
var e=new c();
for(var f=0;f<d;++f){
var g=%_Arguments(f);
var h=g.length;
for(var i=0;i<h;++i){
e.push(g[i]);
return e;
function SpreadIterable(j){
if((j==null)){
throw MakeTypeError(56,j);
var e=new c();
for(var k of j){
e.push(k);
return e;
$spreadArguments=SpreadArguments;
$spreadIterable=SpreadIterable;
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.Object;
var d;
b.Import(function(e){
d=e.OwnPropertyKeys;
function ObjectAssign(f,g){
var h=((%_IsSpecObject(%IS_VAR(f)))?f:$toObject(f));
var i=%_ArgumentsLength();
if(i<2)return h;
for(var j=1;j<i;++j){
var k=%_Arguments(j);
if((k==null)){
continue;
var e=((%_IsSpecObject(%IS_VAR(k)))?k:$toObject(k));
var l=d(e);
var m=l.length;
for(var n=0;n<m;++n){
var o=l[n];
if(%IsPropertyEnumerable(e,o)){
var p=e[o];
h[o]=p;
return h;
b.InstallFunctions(c,2,[
"assign",ObjectAssign
(function(a,b){
"use strict";
%CheckIsBootstrapping();
var c=a.SharedArrayBuffer;
var d=a.Object;
function SharedArrayBufferConstructor(e){
if(%_IsConstructCall()){
var f=$toPositiveInteger(e,125);
%ArrayBufferInitialize(this,f,true);
}else{
throw MakeTypeError(20,"SharedArrayBuffer");
function SharedArrayBufferGetByteLen(){
if(!(%_ClassOf(this)==='SharedArrayBuffer')){
throw MakeTypeError(33,
'SharedArrayBuffer.prototype.byteLength',this);
return %_ArrayBufferGetByteLength(this);
function SharedArrayBufferIsViewJS(g){
return %ArrayBufferIsView(g);
%SetCode(c,SharedArrayBufferConstructor);
%FunctionSetPrototype(c,new d());
%AddNamedProperty(c.prototype,"constructor",
c,2);
%AddNamedProperty(c.prototype,
symbolToStringTag,"SharedArrayBuffer",2|1);
b.InstallGetter(c.prototype,"byteLength",
SharedArrayBufferGetByteLen);
b.InstallFunctions(c,2,[
"isView",SharedArrayBufferIsViewJS
(function() {})
null
hole
undefined
true
false
uninitialized
no_interceptor_result_sentinel
arguments_marker
exception
termination_exception
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
w/HcZcH
ARWSH
ARWD
 APH
t7McR_I
}+UH
ARWD
 AP3
ARWD
 APH
ARL;
ARWD
 APH
+&+ +
megamorphic_symbol
uninitialized_symbol
PQRSVWAPAQASATAVAWH
D$pH
d$ A_A^A\A[AYAX_^[ZYXH
[H#
KDZH
ZPRUVAPAQARASH
|$xH
|$xH
A[AZAYAX^]ZXH
[H#
KDZH
ZPRUVAPAQARASH
|$xH
|$xH
A[AZAYAX^]ZXH
[H#
KDZH
ZPRUVAPAQARASH
|$xH
|$xH
A[AZAYAX^]ZXH
[H#
KDZH
ZPRUVAPAQARASH
|$xH
|$xH
A[AZAYAX^]ZXH
PQRSUVWAPAQARASH
|$xI
|$xH
A[AZAYAX_^][ZYX
@H#
t!X^I
HD[X^I
[RSUWAPAQARASH
|$xH
|$xH
A[AZAYAX_][ZX^I
@H#
HD[X^
[RSUWAPAQARASH
|$xH
|$xH
A[AZAYAX_][ZX^
@H#
t!X^I
HD[X^I
[RSUWAPAQARASH
|$xH
|$xH
A[AZAYAX_][ZX^I
@H#
HD[X^
[RSUWAPAQARASH
|$xH
|$xH
A[AZAYAX_][ZX^
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
D$HH
d$ A_A^A\A[AYAX_^[ZYX
<$=8
@H#
t!XYI
HDZXYI
ZRUVWAPAQARASL
$$A[AZAYAX_^]ZXYI
@H#
HDZXY
ZRUVWAPAQARASL
$$A[AZAYAX_^]ZXY
@H#
t!XYI
HDZXYI
ZRUVWAPAQARASL
$$A[AZAYAX_^]ZXYI
@H#
HDZXY
ZRUVWAPAQARASL
$$A[AZAYAX_^]ZXY
PQRSUVWAPAQARASI
$$A[AZAYAX_^][ZYX
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
((
((
((
((
PQRSVWAPAQASATAVAWH
 APj
D$8H
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
%4+#+
U L9W
I;z
I;z
_RQPSW
@I#
t!XYM
HDZXYM
ZRSUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^][ZXYM
@I#
HDZXY
ZRSUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^][ZXY
@I#
t!XYM
HDZXYM
ZRSUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^][ZXYM
@I#
HDZXY
ZRSUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^][ZXY
w/HcZcH
ARWSH
l$ H
l$ I
@1Ap
ARRP
_RQPSW
8888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
@H#
HDZH
ZRUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]ZH
@H#
HDZH
ZRUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]ZH
@H#
HDZH
ZRUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]ZH
@H#
HDZH
ZRUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]ZH
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
%!+L
ARRPRPI
x_XZH
w/HcZcH
ARWSH
_SQPH
s7RW
<#=?
RH#
JD[H
[SUVWAPAQARASH
$$A[AZAYAX_^][H
RH#
JD[H
[SUVWAPAQARASH
$$A[AZAYAX_^][H
RH#
JD[H
[SUVWAPAQARASH
$$A[AZAYAX_^][H
RH#
JD[H
[SUVWAPAQARASH
$$A[AZAYAX_^][H
<<<<<LLL<<<<
z`IU
object
function
symbol
boolean
string
number
w/HcZcH
ARWSH
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
w/HcZcH
ARWPH
ARWSH
@1Ap
ARRP
[I#
t![YM
KDX[YM
XPRUVWAQARASH
|$xH
|$xH
A[AZAY_^]ZX[YM
[I#
KDX[Y
XPRUVWAQARASH
|$xH
|$xH
A[AZAY_^]ZX[Y
[I#
t![YM
KDX[YM
XPRUVWAQARASH
|$xH
|$xH
A[AZAY_^]ZX[YM
[I#
KDX[Y
XPRUVWAQARASH
|$xH
|$xH
A[AZAY_^]ZX[Y
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$hH
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
@1Ap
ARRP
l$ H
l$ I
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
ARRPRPI
x_XZH
@1Ap
w/HcZcH
PQRSVWAPAQASATAVAWH
D$hH
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
DDDDDDDDDDDDDD88888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
+++%
PQRSVWAPAQASATAVAWH
 AQj
D$0H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
+++%
PQRSVWAPAQASATAVAWH
 ASj
D$(H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
@1Ap
ARRP
ARWSH
w/HcZcH
+99999
YWRH
@r(AHr(
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD88888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
uH+
ARRPRPI
x_XZH
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD88888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
l$ H
l$ I
<#=8
[H#
t [YI
KDA[[YI
A[RUVWAPAQARASI
$$A[AZAYAX_^]Z[YI
[H#
KDA[[Y
A[RUVWAPAQARASI
$$A[AZAYAX_^]Z[Y
[H#
t [YI
KDA[[YI
A[RUVWAPAQARASI
$$A[AZAYAX_^]Z[YI
[H#
KDA[[Y
A[RUVWAPAQARASI
$$A[AZAYAX_^]Z[Y
++%'+
888t
A7H;
PQRSVWAPAQASATAVAWH
D$hH
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
RH#
JDXH
XPUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]XH
RH#
JDXH
XPUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]XH
RH#
JDXH
XPUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]XH
RH#
JDXH
XPUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]XH
w/HcZcH
ARWPH
ARWSH
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
@H#
t!X[I
HDAXX[I
AXRUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^]ZX[I
@H#
HDAXX[
AXRUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^]ZX[
@H#
t!X[I
HDAXX[I
AXRUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^]ZX[I
@H#
HDAXX[
AXRUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^]ZX[
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$HH
d$ A_A^A\A[AYAX_^[ZYX
DDDDDDDDDDDD88888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
<$=G
@H#
HD^H
^SUVWAPAQARASH
$$A[AZAYAX_^][H
@H#
HD^H
^SUVWAPAQARASH
$$A[AZAYAX_^][H
@H#
HD^H
^SUVWAPAQARASH
$$A[AZAYAX_^][H
@H#
HD^H
^SUVWAPAQARASH
$$A[AZAYAX_^][H
l$ H
l$ I
88888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$HH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
D$HH
d$ A_A^A\A[AYAX_^[ZYX
l$ H
l$ I
Hc\$H
l$ H
l$ I
l$ H
l$ I
w/HcZcH
ARWPH
ARWSH
+%1+
<$=A
@H#
HD[H
[SUVWAPAQARASH
$$A[AZAYAX_^][H
@H#
HD[H
[SUVWAPAQARASH
$$A[AZAYAX_^][H
@H#
HD[H
[SUVWAPAQARASH
$$A[AZAYAX_^][H
@H#
HD[H
[SUVWAPAQARASH
$$A[AZAYAX_^][H
U L9W
_RQPSW
%4+#+
#+5+T
I;Eh
[RQS
@Du
I;z
I;z
_RQPSW
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
H;D$
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
@H#
t!XYI
HDZXYI
ZRUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]ZXYI
@H#
HDZXY
ZRUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]ZXY
@H#
t!XYI
HDZXYI
ZRUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]ZXYI
@H#
HDZXY
ZRUVWAPAQARASH
|$xH
|$xH
A[AZAYAX_^]ZXY
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD88888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$8H
d$ A_A^A\A[AYAX_^[ZYX
l$ H
l$ I
l$ H
l$ I
++4
7I;_
+++(
l$ H
l$ I
@1Ap
ARRP
l$ H
l$ I
w/HcZcH
ARWPH
ARWSH
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD88888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
8888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
+++%
PQRSVWAPAQASATAVAWH
 AQj
D$0H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
q'r!
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
@1Ap
ARRP
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
w/HcZcH
ARWSH
l$ H
l$ I
+++%
PQRSVWAPAQASATAVAWH
 ATj
D$ H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
+++%
PQRSVWAPAQASATAVAWH
 AQj
D$0H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
q'r!
8888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
++%'+
888t
A7H;
PQRSVWAPAQASATAVAWH
D$hH
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$HH
d$ A_A^A\A[AYAX_^[ZYX
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
H;\$
uH+
ARRPRPI
x_XZH
l$ H
l$ I
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
[H#
KDZH
ZRUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^]ZH
[H#
KDZH
ZRUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^]ZH
[H#
KDZH
ZRUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^]ZH
[H#
KDZH
ZRUVWAPAQARASH
|$xL
|$xH
A[AZAYAX_^]ZH
DDDDDDDDDDDDDDDDDDDD88888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
ARARATAUAVAWSI
[A_A^A]A\H
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
xr`q
PQRSVWAPAQASATAVAWH
D$HH
d$ A_A^A\A[AYAX_^[ZYX
888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
+++%
PQRSVWAPAQASATAVAWH
 AQj
D$0H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
@1Ap
ARRP
l$ H
l$ I
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
L;D$
l$ H
l$ I
l$ H
l$ I
<#=E
[H#
KD^H
^RUVWAPAQARASH
$$A[AZAYAX_^]ZH
[H#
KD^H
^RUVWAPAQARASH
$$A[AZAYAX_^]ZH
[H#
KD^H
^RUVWAPAQARASH
$$A[AZAYAX_^]ZH
[H#
KD^H
^RUVWAPAQARASH
$$A[AZAYAX_^]ZH
l$ H
l$ I
<$=/
@I#
t!XYM
HDZXYM
ZRSUVWAPAQARH
$$AZAYAX_^][ZXYM
@I#
HDZXY
ZRSUVWAPAQARH
$$AZAYAX_^][ZXY
@I#
t!XYM
HDZXYM
ZRSUVWAPAQARH
$$AZAYAX_^][ZXYM
@I#
HDZXY
ZRSUVWAPAQARH
$$AZAYAX_^][ZXY
YPQH
l$ H
l$ I
M9T$
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
l$ H
l$ I
l$ H
l$ I
y/H%
PQRSVWAPAQASATAVAWH
D$pH
d$ A_A^A\A[AYAX_^[ZYXH
[H#
t![^I
KDX[^I
XPRUWAPAQARASH
|$xH
|$xH
A[AZAYAX_]ZX[^I
[H#
KDX[^
XPRUWAPAQARASH
|$xH
|$xH
A[AZAYAX_]ZX[^
[H#
t![^I
KDX[^I
XPRUWAPAQARASH
|$xH
|$xH
A[AZAYAX_]ZX[^I
[H#
KDX[^
XPRUWAPAQARASH
|$xH
|$xH
A[AZAYAX_]ZX[^
%!+L
ARRPRPI
x_XZH
w/HcZcH
ARWSH
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
M9T$
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
ARARATAUAVAWSI
[A_A^A]A\H
l$ H
l$ I
ARRPRPI
x_XZH
UHL9Q
 PWH
[Z_XH
 PWH
[Z_XH
((
((
((
((
((
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
D$8H
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
l$ H
l$ I
<$=/
@I#
t!XYM
HD[XYM
[RSUVWAQARASH
$$A[AZAY_^][ZXYM
@I#
HD[XY
[RSUVWAQARASH
$$A[AZAY_^][ZXY
@I#
t!XYM
HD[XYM
[RSUVWAQARASH
$$A[AZAY_^][ZXYM
@I#
HD[XY
[RSUVWAQARASH
$$A[AZAY_^][ZXY
l$ H
l$ I
@1Ap
ARRP
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
%!+L
ARRPRPI
x_XZH
U L9W
_RQPSW
@H#
HDZXY
ZRUVWAPAQARASL
$$A[AZAYAX_^]ZXY
@H#
HDZXY
ZRUVWAPAQARASL
$$A[AZAYAX_^]ZXY
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
++%4+
+)+|
PQRSVWAPAQASATAVAWH
D$PH
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$PH
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$PH
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
D$pH
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
@1Ap
ARRP
%!+L
ARRPRPI
x_XZH
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
w/HcZcH
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
PQRSVWAPAQASATAVAWH
D$@H
d$ A_A^A\A[AYAX_^[ZYX
l$ H
l$ I
%!+L
ARRPRPI
x_XZH
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
%4+#+
U L9W
I;z
I;z
_RQPSW
+++%
PQRSVWAPAQASATAVAWH
 ATj
D$ H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
w/HcZcH
ARWPH
ARWSH
l$ H
l$ I
@1Ap
ARRP
+++%
PQRSVWAPAQASATAVAWH
 ASj
D$(H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
+++%
PQRSVWAPAQASATAVAWH
 AQj
D$0H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
@1Ap
@1Ap
ARRP
l$ H
l$ I
%!+L
ARRPRPI
x_XZH
%4+#+
U L9W
I;z
I;z
_RQPSW
D88888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
+99999=%
+99999
+99999
YWRH
@r(AHr(
r,AIr`
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
@1Ap
ARRP
888888888
PQRSVWAPAQASATAVAWH
D$`H
d$ A_A^A\A[AYAX_^[ZYXH
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
l$ H
l$ I
+)+%
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXI
l$ H
l$ I
l$ H
l$ I
[RQPS
[RQPS
[RQPS
[RQPS
Z_)_
"?z\
_AddElement
DataViewSetFloat32
HasElement
_HasExternalUint16Elements
_JSValueGetValue
N`j{
_RemoveArrayHoles
GetFrameCount
IsObserved
_HasFixedInt16Elements
_HasDictionaryElements
ScheduleBreak
URIEscape
_ArrayConstructorWithSubclassing
_HasFastHoleyElements
_GetCallerJSFunction
IsConcurrentRecompilationSupported
NumberSub
DataViewGetUint16
_NumberShr
_DeoptimizeNow
IsSmi
_SetGrow
_HasOwnProperty
_NumberToJSUint32
DataViewGetInt16
_WeakCollectionHas
DebugPushPromise
ForInStep
_ArrayBufferIsView
_PromiseRevokeReject
_CallSiteIsNativeRT
_StringTrim
_HasFixedUint8ClampedElements
GetFunctionCodePositionFromSource
StringCharCodeAtRT
GetUndetectable
FunctionSetName
_CreateObjectLiteral
_SetIteratorClone
_StoreKeyedToSuper_Strict
CreateSymbol
CompileForOnStackReplacement
NewStringWrapper
_IsUndetectableObject
NumberXor
JSValueGetValue
_MoveArrayContents
FinishArrayPrototypeSetup
_DoubleLo
DebugReferencedBy
NumberToSmi
CallSiteIsEvalRT
ClearFunctionTypeFeedback
ThrowNonMethodError
HasExternalUint8ClampedElements
_DebugPrepareStepInIfStepping
IsUndetectableObject
NewClosureFromStubFailure
_NumberToInteger
_IsConstructCall
_ForInStep
LiveEditFunctionSourceUpdated
TraceEnter
_NumberMul
IsObject
ReThrow
_FunctionSetName
_HasFastSmiOrObjectElements
HasExternalFloat64Elements
_FunctionGetName
RenderCallSite
TwoByteSeqStringGetChar
NewTypeError
_FastOneByteArrayJoin
MathAsin
_AtomicsXor
_SetInitialize
_LiveEditFunctionSetScript
DefaultConstructorCallSuper
_IsMinusZero
DebugConstructedBy
PushCatchContext
_ForInNext
_HasFixedInt8Elements
NumberDiv
_TryInstallOptimizedCode
IsRegExp
_MathAtan
_CallFunction
DebugPrintScopes
_DataViewGetFloat64
DebugNamedInterceptorPropertyValue
_DataViewSetInt16
Apply
SubStringRT
_LoadLookupSlotNoReferenceError
StringLocaleCompare
_DeclareLookupSlot
_IsSmi
_GetPropertyNamesFast
_RegExpExecMultiple
ObserverObjectAndRecordHaveSameOrigin
_NewString
_NewRestParamSlow
CreateJSFunctionProxy
_InternalArrayConstructor
_DebugPopPromise
_DebugGetInternalProperties
WeakCollectionHas
_WeakCollectionDelete
_NotifyStubFailure
_GetConstructorDelegate
IsJSFunctionProxy
_NumberMod
_TraceExit
_SetFunctionBreakPoint
_HasExternalUint8ClampedElements
BasicJSONStringify
MathPowSlow
AtomicsAdd
TypedArrayInitialize
_DebugGetPrototype
ToBool
_GetScript
_NeverOptimizeFunction
_SubStringRT
_DataViewGetUint16
DeliverObservationChangeRecords
_SetProperty
_SetAllocationTimeout
_Likely
PreventExtensions
ForInFilter
_StringGetRawHashField
GetHeapUsage
_AllocateInTargetSpace
_CreateArrayLiteralStubBailout
StringAdd
HasExternalInt8Elements
_SetIteratorNext
DataViewGetFloat32
_MathSqrt
_InitializeLegacyConstLookupSlot
GetDataProperty
MapClear
_WeakCollectionGet
IsConstructCall
MathPow
_NumberOr
DebugPropertyTypeFromDetails
_NewObject
_GetThreadCount
GetStepInPositions
SetPrototype
_StackGuard
_GetScopeDetails
_StringParseInt
GetOriginalConstructor
PushWithContext
_NumberSub
SetDebugEventListener
LiveEditPatchFunctionPositions
_CharFromCode
_SetForceInlineFlag
_CompileForOnStackReplacement
_GeneratorNext
_GetScopeCount
_ArrayBufferGetByteLength
_IsRegExp
_CreateJSFunctionProxy
_IsDate
GetArrayKeys
CreateArrayLiteral
_ConstructDouble
_RoundNumber
_Abort
GetObjectContextObjectGetNotifier
LiveEditFindSharedFunctionInfosForScript
_ThrowIfStaticPrototype
v%;j
AddNamedProperty
CreateObjectLiteral
ClearBreakPoint
GetOptimizationStatus
InternalArrayConstructor
SetScopeVariableValue
_Apply
_IsConcurrentRecompilationSupported
_DeleteProperty
_DataViewSetFloat64
_GetFunctionScopeDetails
Abort
_FixedArraySet
LookupAccessor
MathClz32
_HasExternalInt32Elements
GrowArrayElements
_Fix
_GetFunctionCodePositionFromSource
HasCachedArrayIndex
_DefineAccessorPropertyUnchecked
_NewArguments
_GetFunctionDelegate
LiveEditReplaceRefToNestedFunction
SetForceInlineFlag
ArrayConstructor
GetRootNaN
NotifyDeoptimized
LoadMutableDouble
NewSymbolWrapper
r&=|
Arguments
_AbortJS
FormatMessageString
DataViewInitialize
~&Qz
_EstimateNumberOfElements
RegExpConstructResultRT
CollectGarbage
IsAccessCheckNeeded
_MapInitialize
LoadKeyedFromSuper
_CallSiteIsToplevelRT
SymbolRegistry
AbortJS
MathAtan
_StringToLowerCase
_NotifyDeoptimized
_NewObjectFromBound
_StringToArray
AddElement
UnblockConcurrentRecompilation
ThrowStrongModeTooFewArguments
_URIUnescape
_FunctionRemovePrototype
HomeObjectSymbol
RegExpExec
KeyedGetPropertyStrong
_SymbolRegistry
_LiveEditGatherCompileInfo
DataViewSetInt32
_GeneratorGetContext
_ObjectFreeze
StringCompareRT
LiveEditRestartFrame
_AtomicsIsLockFree
GetObservationState
IsExtensible
_GetWeakSetValues
_KeyedGetPropertyStrong
ClearStepping
_SmiLexicographicCompare
_GetHandler
_TypedArrayMaxSizeInHeap
GeneratorClose
GetConstructTrap
rGdC
_ClearBreakPoint
DoubleHi
WeakCollectionGet
HasFixedInt16Elements
_CallSiteIsEvalRT
_Arguments
AllocateInNewSpace
_GlobalPrint
CollectStackTrace
_IsSharedIntegerTypedArray
_NumberToExponential
URIUnescape
_ObjectEquals
CompileOptimized
IsConstructor
_GenericHash
RunningInSimulator
NewConsString
_HasFastDoubleElements
_DebugConstructedBy
_ToFastProperties
DebugSetScriptSource
GetFrameDetails
_SetNativeFlag
InitializeLegacyConstLookupSlot
_CompileString
StringToNumber
DateField
_EnqueueMicrotask
ThrowReferenceError
_MathFloor
IsSharedTypedArray
_StoreToSuper_Sloppy
HasFastDoubleElements
_MessageGetStartPosition
_BoundFunctionGetBindings
_HasExternalUint8Elements
DataViewSetInt16
_GeneratorGetFunction
CompileString
DateToUTC
DateCacheVersion
DeleteProperty
NewSyntaxError
StringCharFromCode
_HasFixedUint8Elements
LiveEditGatherCompileInfo
TruncateString
HasFixedInt8Elements
_IsStringWrapperSafeForDefaultValueOf
MaxSmi
_InternalSetPrototype
_HandleStepInForDerivedConstructors
_NumberUnaryMinus
_ToBool
StringTrim
_CallSiteGetScriptNameOrSourceUrlRT
_DateCurrentTime
_DateParseString
_DateToUTC
_CallSiteIsConstructorRT
_TwoByteSeqStringGetChar
CallSiteIsToplevelRT
_NewSymbolWrapper
_URIEscape
ResolvePossiblyDirectEval
NumberToInteger
StoreLookupSlot
FunctionIsGenerator
NewObjectFromBound
GetAllScopesDetails
NumberOr
HasFastPackedElements
StringReplaceOneCharWithString
_FunctionIsBuiltin
DisassembleFunction
GetTypeFeedbackVector
GetThreadCount
_HasSloppyArgumentsElements
_DebugPrintScopes
GetFunctionScopeCount
_FlattenString
_SetScriptBreakPoint
_LookupAccessor
TypedArrayGetBuffer
DateSetValue
GetDebugContext
IsPropertyEnumerable
_Interrupt
StringAddRT
GetPropertyNames
_LiveEditCompareStrings
_GlobalProxy
_OneByteSeqStringGetChar
IsNonNegativeSmi
ForInDone
_GeneratorGetSourcePosition
AtomicsExchange
_GetArgumentsProperty
HasFixedInt32Elements
NewArguments
_SymbolDescription
GeneratorGetReceiver
_CreateJSGeneratorObject
_FormatMessageString
_StoreArrayLiteralElement
DebugPropertyIndexFromDetails
_DeclareModules
_NumberToRadixString
_MathClz32
_HasFixedInt32Elements
_FunctionIsAPIFunction
DataViewGetUint32
ArrayBufferNeuter
OptimizeOsr
_DisassembleFunction
_TypedArraySetFastCases
zjEc
StoreKeyedToSuper_Sloppy
_IsSloppyModeFunction
ExecuteInDebugContext
MathPowRT
_SetValueOf
PushIfAbsent
GetScopeCount
CheckExecutionState
_SymbolIsPrivate
HasExternalInt32Elements
_GetV8Version
MapIteratorDetails
StringCharAt
_DataViewGetFloat32
MapInitialize
GetThreadDetails
SetInitialize
_CallSuperWithSpread
MathFround
_HasExternalInt8Elements
GetCachedArrayIndex
GetOwnPropertyNames
_DefaultConstructorCallSuper
ThrowNotDateError
DeleteLookupSlot
LiveEditCompareStrings
DefineSetterPropertyUnchecked
GetScopeDetails
_NumberToPrecision
_WeakCollectionInitialize
MathFloor
_MapClear
AtomicsSub
_DebugBreakInOptimizedCode
Vkt-
_ThrowNotDateError
_DeliverObservationChangeRecords
_DataViewGetBuffer
_HasExternalUint32Elements
SymbolIsPrivate
AtomicsCompareExchange
_OptimizeOsr
_ScheduleBreak
_NumberCompare
_NewConsString
OneByteSeqStringSetChar
NumberToExponential
_NormalizeElements
NormalizeElements
_NewStrictArguments
SetNativeFlag
_UnblockConcurrentRecompilation
DataViewSetUint16
_GeneratorGetReceiver
_ClassOf
GetCallerJSFunction
_NumberSar
_DebugBreak
ArrayBufferViewGetByteOffset
_TraceEnter
DebugBreak
_LoadKeyedFromSuper
HeapObjectGetMap
RegExpConstructResult
FunctionGetInferredName
_SetIteratorDetails
_GeneratorGetContinuation
HasFixedUint32Elements
_GetWeakMapEntries
_TypedArrayInitialize
IsJSProxy
_AppendElement
_HasFastObjectElements
GetObjectContextObjectObserve
GetCallTrap
HarmonyToString
_MathPowSlow
StringParseFloat
_NumberXor
IS_VAR
FunctionIsArrow
DebugPrint
HasComplexElements
_ClearStepping
SpecialArrayFunctions
ArrayConcat
_PromiseRejectEvent
_DataViewSetUint8
HasProperty
NumberToRadixString
StringGetRawHashField
_DataViewInitialize
GeneratorNext
_StringCharCodeAtRT
_CallSiteGetFunctionNameRT
NumberToJSUint32
_GetBreakLocations
_IsNonNegativeSmi
MoveArrayContents
SuspendJSGeneratorObject
_MathFround
_GetPropertyStrong
zMC9
_InternalizeString
CheckIsBootstrapping
DoubleLo
NewReferenceError
InternalSetPrototype
NeverOptimizeFunction
_IsInPrototypeChain
RemoveArrayHoles
DataViewSetInt8
ArrayBufferInitialize
IsBreakOnException
_GetOwnPropertyNames
FunctionMarkNameShouldPrintAsAnonymous
_ReThrow
_NewSloppyArguments
_UnwindAndFindExceptionHandler
HasFastObjectElements
NumberShr
_FunctionIsConciseMethod
_DoubleHi
FunctionSetPrototype
_IncrementStatsCounter
DataViewGetFloat64
_NumberToIntegerMapMinusZero
_MaxSmi
MathSqrt
_DefineClassMethod
WeakCollectionDelete
TypedArraySetFastCases
DataViewGetBuffer
NumberToFixed
_IsJSProxy
FixedArraySet
_GetObjectContextObjectObserve
NewString
OneByteSeqStringGetChar
HasFixedFloat64Elements
_StringLocaleCompare
_GetOptimizationCount
ArrayConstructorWithSubclassing
DebugPopPromise
_AtomicsOr
HasDictionaryElements
_ObservationWeakMapCreate
DateCurrentTime
_IsTypedArray
StackGuard
_NativeScriptsCount
_GetPrototype
_LiveEditFunctionSourceUpdated
_CollectStackTrace
_StringBuilderJoin
StringReplaceGlobalRegExpWithString
_FunctionNameShouldPrintAsAnonymous
CallSiteGetColumnNumberRT
MapGrow
_RenderCallSite
MathAcos
_SetFlags
_GetObservationState
_FunctionGetInferredName
NumberMul
GetFromCacheRT
NumberToIntegerMapMinusZero
FunctionIsAPIFunction
_MapIteratorClone
f/uY
StringToUpperCase
DefineClass
GetPropertyNamesFast
StoreKeyedToSuper_Strict
SetIteratorDetails
CreateGlobalPrivateSymbol
FunctionGetScript
_GetArrayKeys
FastOneByteArrayJoin
JSCollectionGetTable
_ArrayConstructor
_GrowArrayElements
_GetFrameDetails
AtomicsIsLockFree
_Throw
_DebugEvaluateGlobal
HasOwnProperty
AllocateHeapNumber
TheHole
AllocateInTargetSpace
_DataViewSetInt8
_DataViewGetUint8
_DebugTrace
AppendElement
_CreatePrivateSymbol
_IsConstructor
_DeclareGlobals
WeakCollectionInitialize
_PrepareStep
_StringLastIndexOf
GeneratorThrow
FinalizeInstanceSize
_FunctionMarkNameShouldPrintAsAnonymous
_IsPropertyEnumerable
MapIteratorNext
_FunctionGetPositionForOffset
_NewClosure
FunctionGetSourceCode
SetScriptBreakPoint
GetFunctionScopeDetails
TypedArrayInitializeFromArrayLike
SetProperty
^Px+
PushModuleContext
_CallSiteGetMethodNameRT
_HasProperty
SetAllocationTimeout
_CallSiteGetFileNameRT
TransitionElementsKind
FunctionGetPositionForOffset
_SparseJoinWithSeparator
GetPrototype
_GetTypeFeedbackVector
_LiveEditReplaceScript
InitializeConstGlobal
AtomicsAnd
_GetPropertyNames
_StoreLookupSlot
NumberToJSInt32
_DebugReferencedBy
_GetFrameCount
_StringCharFromCode
_HasExternalFloat32Elements
PromiseRejectEvent
_CheckExecutionState
GetFromCache
SetIteratorInitialize
StringGetLength
SetDisableBreak
_PushWithContext
IsJSGlobalProxy
MathLogRT
_MessageGetScript
_HasExternalArrayElements
_DataViewGetInt8
CreatePrivateSymbol
F1F
NumberAdd
_DeoptimizeFunction
IsStringWrapperSafeForDefaultValueOf
bQuF
LiveEditCheckAndDropActivations
b1e6
IsJSModule
fqJg
HasFixedUint8ClampedElements
_DebugEvaluate
GeneratorGetContext
_AtomicsAnd
ArrayBufferSliceImpl
_IsArray
PushBlockContext
_NewScriptContext
HasFastSmiOrObjectElements
_ThrowUnsupportedSuperError
NumberCompare
LoadFromSuper
ObjectSeal
_GetOriginalConstructor
CallFunction
DeclareModules
_GetRootNaN
TraceExit
_MathExpRT
NativeScriptsCount
_RegExpExec
MapIteratorInitialize
SetIsObserved
_CreateJSProxy
_MapIteratorNext
_GetAllScopesDetails
NewObjectWithAllocationSite
DebugTrace
_ForInFilter
_FixedArrayGet
_DebugPropertyAttributesFromDetails
_DebugPropertyTypeFromDetails
_HasFixedFloat32Elements
StringParseInt
_FunctionBindArguments
_DebugNamedInterceptorPropertyValue
DebugAsyncTaskEvent
IsDate
_FunctionGetScriptSourcePosition
_PushIfAbsent
StringMatch
_NumberImul
_ForInDone
_IsSharedTypedArray
RunMicrotasks
EstimateNumberOfElements
_KeyedGetProperty
ThrowStaticPrototypeError
_PromoteScheduledException
DataViewGetInt32
BoundFunctionGetBindings
DataViewGetInt8
CallSiteIsConstructorRT
_TruncateString
_FunctionGetSourceCode
GetFunctionDelegate
_GetNamedInterceptorPropertyNames
HasFixedUint8Elements
DebugGetPropertyDetails
_NewFunctionContext
_MathLogRT
_StringBuilderConcat
Throw
_SetDisableBreak
DebugGetLoadedScripts
IsSharedIntegerTypedArray
_LiveEditPatchFunctionPositions
FunctionRemovePrototype
_ArrayBufferViewGetByteOffset
StringBuilderJoin
HasExternalInt16Elements
_GetOwnElementNames
_ThrowStaticPrototypeError
_ArrayBufferNeuter
InitializeVarGlobal
_DeleteLookupSlot
_SetIsObserved
_HasExternalFloat64Elements
_GetFromCacheRT
IsSloppyModeFunction
CallSiteGetMethodNameRT
_QuoteJSONString
RoundNumber
ObjectFreeze
ThrowStrongModeImplicitConversion
IsValidSmi
DefineGetterPropertyUnchecked
DebugBreakInOptimizedCode
ArrayBufferIsView
_LoadFromSuper
_ObjectSeal
GetConstructorDelegate
DateMakeDay
HasExternalFloat32Elements
HasExternalUint8Elements
GetWeakMapEntries
FunctionGetName
_DataViewGetUint32
_IsJSModule
_StringGetLength
_TypedArrayGetLength
_NewObjectWithAllocationSite
_RegExpExecReThrow
SetCode
CreateJSGeneratorObject
_StringIndexOf
SymbolDescription
_IsJSFunctionProxy
IsSpecObject
_NumberToStringRT
_StringCharCodeAt
_TypedArrayGetBuffer
_HasExternalInt16Elements
NewRestParamSlow
_FunctionSetPrototype
_StringSplit
ObjectWasCreatedInCurrentOrigin
_HasComplexElements
_ParseJson
GetScript
_CollectGarbage
_OwnKeys
_NumberToString
_DataViewSetUint32
DebugPropertyAttributesFromDetails
Z5gK
PrepareStep
StringIndexOf
_DataViewSetFloat32
_FinishArrayPrototypeSetup
_StringEquals
_MaterializeRegExpLiteral
NumberToString
PromoteScheduledException
SetGrow
_DefineClass
_JSCollectionGetTable
NumberEquals
_Unlikely
_ArrayBufferViewGetByteLength
ThrowConstAssignError
_HasFixedUint32Elements
MaterializeRegExpLiteral
_AtomicsExchange
UnwindAndFindExceptionHandler
DebugEvaluate
_ValueOf
"6{(
_GetIndexedInterceptorElementNames
GlobalProxy
_NewReferenceError
_LoadMutableDouble
_CompileLazy
DateLocalTimezone
TryMigrateInstance
GetArgumentsProperty
_CreateArrayLiteral
DebugPromiseEvent
AtomicsLoad
OwnKeys
DataViewSetFloat64
FunctionSetInstanceClassName
_OneByteSeqStringSetChar
_DataViewSetUint16
StringToLowerCase
_HasElement
IncrementStatsCounter
_DateLocalTimezone
_RemPiO2
_InitializeConstGlobal
SetFunctionBreakPoint
NewClosure
_GetObjectContextNotifierPerformChange
_StringAdd
CallSiteIsNativeRT
_IsExtensible
ThrowIteratorResultNotAnObject
_CreateSymbol
_AtomicsStore
FunctionIsBuiltin
PromiseRevokeReject
GlobalPrint
_MapShrink
_DateField
_FunctionGetScript
ClassOf
_FunctionIsGenerator
B7St
_StringMatch
_MathPowRT
ToFastProperties
DeoptimizeNow
LiveEditFunctionSetScript
_ObserverObjectAndRecordHaveSameOrigin
_GetFunctionScopeCount
PromiseHasHandlerSymbol
HasSloppyArgumentsElements
AtomicsStore
_HasFixedFloat64Elements
_MathAcos
ThrowArrayNotSubclassableError
_SetDebugEventListener
CreateJSProxy
DebugCallbackSupportsStepping
_DataViewGetInt16
FunctionBindArguments
_SpecialArrayFunctions
DebugEvaluateGlobal
SetFlags
HaveSameMap
_SetScopeVariableValue
GetOwnElementNames
MessageGetStartPosition
_FunctionSetLength
_GetDebugContext
SetIteratorClone
OptimizeObjectForAddingMultipleProperties
_DateCacheVersion
_CompileOptimized
NumberShl
NumberSar
_MathPow
_HasFixedUint16Elements
_NumberToJSInt32
_ClearFunctionTypeFeedback
_MathAtan2
QuoteJSONString
MathExpRT
_MapIteratorInitialize
_ThrowIteratorResultNotAnObject
_ThrowArrayNotSubclassableError
FunctionNameShouldPrintAsAnonymous
_IsObserved
CreateArrayLiteralStubBailout
_IS_VAR
_NumberToStringSkipCache
IsStrong
HasFixedUint16Elements
_ThrowStrongModeTooFewArguments
GetPropertyStrong
GetNamedInterceptorPropertyNames
_DefineSetterPropertyUnchecked
_LiveEditReplaceFunctionCode
_RegExpConstructResult
NumberMod
_IsStrong
_ArrayConcat
_IsJSGlobalProxy
StoreToSuper_Sloppy
DebugPrepareStepInIfStepping
_PushCatchContext
_GetDataProperty
GetWeakSetValues
MapShrink
_DataViewGetInt32
_ClassGetSourceCode
FunctionGetScriptSourcePosition
TryInstallOptimizedCode
_SetShrink
_OptimizeObjectForAddingMultipleProperties
LiveEditReplaceScript
DeclareGlobals
_FunctionSetInstanceClassName
_PushModuleContext
_IsValidSmi
_AtomicsSub
DebugGetInternalProperties
NewRestParam
_TryMigrateInstance
_DebugPromiseEvent
_RegExpInitializeAndCompile
N9Kl
_IsAccessCheckNeeded
FunctionIsConciseMethod
RemPiO2
_ChangeBreakOnException
_ObjectWasCreatedInCurrentOrigin
_GetObjectContextObjectGetNotifier
FixedArrayGet
DeclareLookupSlot
_TransitionElementsKind
_GetFromCache
_LiveEditFindSharedFunctionInfosForScript
_SetCode
RegExpInitializeAndCompile
_LoadLookupSlot
InternalizeString
_StoreToSuper_Strict
DeoptimizeFunction
_DateSetValue
GetOptimizationCount
GetBreakLocations
_DebugGetLoadedScripts
ToMethod
CallSiteGetFunctionNameRT
_FinalizeInstanceSize
NewFunctionContext
HasExternalUint16Elements
_AtomicsCompareExchange
_StringToNumber
_AtomicsLoad
_ToMethod
TypedArrayMaxSizeInHeap
_ArrayBufferSliceImpl
DebugGetProperty
NumberToStringRT
_MapGrow
DebugGetPrototype
RZI1
_DebugPropertyIndexFromDetails
WeakCollectionSet
B:g>
_DateMakeDay
SetIteratorNext
_ExecuteInDebugContext
HasExternalUint32Elements
LoadLookupSlot
_SubString
_PreventExtensions
IsInPrototypeChain
RegExpExecMultiple
NewStrictArguments
GetInterceptorInfo
_ThrowConstAssignError
_DataViewSetInt32
_SetClear
_TwoByteSeqStringSetChar
NumberToStringSkipCache
HandleStepInForDerivedConstructors
_StoreKeyedToSuper_Sloppy
_MapIteratorDetails
DataViewSetUint32
DefineClassMethod
_LiveEditRestartFrame
SetShrink
ForInNext
MathAtan2
_AtomicsAdd
ObservationWeakMapCreate
GenericHash
Interrupt
MapGetInstanceType
_SetPrototype
GetV8Version
NotifyContextDisposed
_NewSyntaxError
_GetStepInPositions
_StringReplaceGlobalRegExpWithString
_TypedArrayInitializeFromArrayLike
_GetOwnProperty
SetClear
_GetThreadDetails
CallSuperWithSpread
_HomeObjectSymbol
_DebugAsyncTaskEvent
_HasFastPackedElements
V;i(
_GeneratorThrow
_CreateGlobalPrivateSymbol
_DefineDataPropertyUnchecked
_GetUndetectable
_MathAsin
_PushBlockContext
_HaveSameMap
ThrowIfStaticPrototype
ArrayBufferViewGetByteLength
_CallSiteGetColumnNumberRT
DefineDataPropertyUnchecked
StringLastIndexOf
_NewStringWrapper
StringToArray
_ThrowNonMethodError
_StringToUpperCase
ConstructDouble
StoreArrayLiteralElement
_ThrowStrongModeImplicitConversion
FlattenString
_ThrowConstructorNonCallableError
Call
_DebugGetProperty
NewScriptContext
_GetCachedArrayIndex
IsArray
LoadLookupSlotNoReferenceError
StoreToSuper_Strict
AtomicsXor
CallSiteGetScriptNameOrSourceUrlRT
LiveEditReplaceFunctionCode
SystemBreak
_ResumeJSGeneratorObject
_CheckIsBootstrapping
_SystemBreak
SmiLexicographicCompare
ClassGetSourceCode
_RegExpConstructResultRT
_DebugCallbackSupportsStepping
StringBuilderConcat
_DebugGetPropertyDetails
Likely
_LiveEditReplaceRefToNestedFunction
RegExpExecReThrow
_GetCallTrap
_DebugIndexedInterceptorElementValue
_MapGetInstanceType
IsFunction
_StringAddRT
_HeapObjectGetMap
_NumberToFixed
MapIteratorClone
_NewRestParam
CallSiteGetLineNumberRT
_NotifyContextDisposed
_DebugIsActive
_NewClosureFromStubFailure
_ArrayBufferInitialize
NewSloppyArguments
_FunctionIsArrow
GetObjectContextNotifierPerformChange
OptimizeFunctionOnNextCall
_BasicJSONStringify
_TheHole
_AddNamedProperty
_GetOptimizationStatus
_DefineGetterPropertyUnchecked
CompileLazy
StringEquals
.];"
ArgumentsLength
ParseJson
_OptimizeFunctionOnNextCall
MessageGetScript
NumberAnd
_StringCompareRT
_DebugSetScriptSource
StringCharCodeAt
_IsSpecObject
GetOwnProperty
KeyedGetProperty
_GetProperty
_GetInterceptorInfo
_RunMicrotasks
_StringCharAt
GetProperty
_RunningInSimulator
ChangeBreakOnException
HasFastHoleyElements
_DebugPushPromise
HasFastProperties
NumberUnaryMinus
FunctionSetLength
GetIndexedInterceptorElementNames
_SetIteratorInitialize
GeneratorGetFunction
_AllocateInNewSpace
GeneratorGetSourcePosition
DebugIndexedInterceptorElementValue
_NumberDiv
SetValueOf
HasExternalArrayElements
NumberToPrecision
NotifyStubFailure
IsMinusZero
_NumberShl
_HasFastProperties
_Call
_IsObject
DataViewGetUint8
_LiveEditCheckAndDropActivations
_GetHeapUsage
_DebugPrint
SubString
TwoByteSeqStringSetChar
ArrayBufferGetByteLength
DateParseString
_PromiseHasHandlerSymbol
DefineAccessorPropertyUnchecked
_NewTypeError
HasFastSmiElements
_NumberAdd
ValueOf
SparseJoinWithSeparator
_StringReplaceOneCharWithString
_CallSiteGetLineNumberRT
GeneratorGetContinuation
_HarmonyToString
ResumeJSGeneratorObject
Unlikely
_InitializeVarGlobal
ThrowUnsupportedSuperError
TypedArrayGetLength
AtomicsOr
StringCompare
_StringCompare
_AllocateHeapNumber
_GetConstructTrap
_StringParseFloat
_SuspendJSGeneratorObject
N?\C
NewObject
_ThrowReferenceError
ThrowConstructorNonCallableError
_HasCachedArrayIndex
EnqueueMicrotask
_IsFunction
_WeakCollectionSet
_NumberToSmi
_NumberAnd
NumberImul
_ArgumentsLength
CharFromCode
_IsBreakOnException
_GeneratorClose
_ResolvePossiblyDirectEval
_HasFastSmiElements
GetHandler
DataViewSetUint8
ObjectEquals
_NumberEquals
DebugIsActive
StringSplit
HasFixedFloat32Elements
IsTypedArray
CallSiteGetFileNameRT
for_api
keyFor
private_api
private_intern
StringIterator#next
nonextensible_symbol
nonextensible_symbol
nonexistent_symbol
nonexistent_symbol
stack_trace_symbol
stack_trace_symbol
Promise#raw
Promise#onResolve
megamorphic_symbol
promise_has_handler_symbol
*46!
promise_has_handler_symbol
ArrayIterator#object
intl_impl_object_symbol
intl_impl_object_symbol
ArrayIterator#kind
elements_transition_symbol
elements_transition_symbol
error_end_pos_symbol
error_end_pos_symbol
frozen_symbol
frozen_symbol
StringIterator#iteratedString
Promise#value
normal_ic_symbol
normal_ic_symbol
error_start_pos_symbol
error_start_pos_symbol
intl_initialized_marker_symbol
intl_initialized_marker_symbol
class_end_position_symbol
class_end_position_symbol
hash_code_symbol
hash_code_symbol
home_object_symbol
home_object_symbol
detailed_stack_trace_symbol
detailed_stack_trace_symbol
error_script_symbol
error_script_symbol
Promise#status
ArrayIterator#next
sealed_symbol
sealed_symbol
class_script_symbol
class_script_symbol
observed_symbol
observed_symbol
promise_debug_marker_symbol
promise_debug_marker_symbol
class_start_position_symbol
class_start_position_symbol
Promise#onReject
uninitialized_symbol
premonomorphic_symbol
premonomorphic_symbol
Object
__proto__
arguments
caller
Boolean
callee
constructor
.result
eval
Function
length
name
Number
source
source_url
source_mapping_url
this
global
ignoreCase
multiline
sticky
Fm?V
unicode
harmony_regexps
harmony_tostring
harmony_unicode_regexps
input
index
lastIndex
prototype
String
Symbol
WeakMap
WeakSet
for_intern
Date
CharAt
valueOf
stack
toJSON
KeyedLoadMonomorphic
KeyedStoreMonomorphic
$stackOverflowBoilerplate
illegal access
%cell_value
illegal argument
(closure)
Infinity
-Infinity
(?:)
Generator
throw
done
value
next
byteLength
byteOffset
Array
Error
RegExp
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.isRegExp
Symbol.iterator
Symbol.toStringTag
Symbol.unscopables
AZWARH
AZWARH
ARWW
+%*+L
 PWH;
<$WR
<$WW
 SSH
w/HcZcH
+ +XL
w/HcZcH
+%*+L
 PWH;
<$WR
<$WW
 SSH
+%++L
 PWRH;
<$WR
<$WW
 RSSH
w/HcZcH
ARWRH
w/HcZcH
ARWRH
ARWW
ARWWI
ARWWI
%7+%
T$I
%7+%
T$I
%7+%
T$I
%%+L
ARPQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXH
%%+L
ARPQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXH
_RQPSW
[RQPS
[RQPS
%4+#+
#+5+T
I;Eh
[RQS
@Du
I;z
I;z
_RQPSW
ARPXH
[RQPS
[RQPS
#+<+%
 [RQPj
I;Z
I;Z
I;} 
I;}@
I;} 
I;}@
M;Eh
U8M9P
H;_/
M;Eh
M;:w
M;Eh
U8M9P
H;_/
M;Eh
M;:w
[RQPS
[RQPS
[RQPS
#+<+%$+
 [RQPI
I;Z
I;Z
I;} 
I;}@
I;} 
I;}@
M;Eh
U8M9P
H;_/
M;Eh
M;:w
M;Eh
U8M9P
H;_/
M;Eh
M;:w
[RQPS
ARSH
t"I;]
 PSH
ZWRH
W'HcZcH
u PH
t"I;]
['SH
w/HcZcH
u PH
t"I;]
['SH
w/HcZcH
u PH
ARWPH
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXAZUH
VWAR
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYXAZUH
VWAR
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
PQRSVWAPAQASATAVAWH
d$ A_A^A\A[AYAX_^[ZYX
[RQS
[RQS
[RQS
[RQS
[RQPS
[RQPS
[RQS
[RQS
IJ;L
IJ;L
IJ;L
IJ;L
[RQPS
+%'+L
ARP3
XAZI
+%'+L
ARW3
_AZI
'+%9+L
 ARW3
_AZI
)+%;+L
 ARRSW3
_[ZAZI
+%(+L
ARRW3
_ZAZI
+%&+L
keys
native v8natives.js
isNaN
isFinite
parseInt
parseFloat
toString
toLocaleString
hasOwnProperty
isPrototypeOf
propertyIsEnumerable
__defineGetter__
__lookupGetter__
__defineSetter__
__lookupSetter__
IsAccessorDescriptor
IsDataDescriptor
IsGenericDescriptor
IsInconsistentDescriptor
FromPropertyDescriptor
FromGenericPropertyDescriptor
6],!
ToPropertyDescriptor
ToCompletePropertyDescriptor
PropertyDescriptor
ConvertDescriptorArrayToDescriptor
GetTrap
CallTrap0
NS7%
CallTrap1
CallTrap2
GetOwnPropertyJS
Delete
GetMethod
DefineProxyProperty
.T 0
DefineObjectProperty
DefineArrayProperty
DefineOwnProperty
DefineOwnPropertyFromAPI
getPrototypeOf
setPrototypeOf
getOwnPropertyDescriptor
ToNameArray
ObjectGetOwnPropertyKeys
OwnPropertyKeys
getOwnPropertyNames
create
defineProperty
GetOwnEnumerablePropertyNames
defineProperties
ProxyFix
seal
freeze
preventExtensions
isSealed
isFrozen
isExtensible
get __proto__
set __proto__
ObjectConstructor
BooleanConstructor
NumberConstructor
toFixed
toExponential
toPrecision
isInteger
isSafeInteger
z~fZ
NativeCodeFunctionSourceString
FunctionSourceString
bind
NewFunctionString
FunctionConstructor
GetIterator
PropertyDescriptor_ToString
PropertyDescriptor_SetValue
nn1z
PropertyDescriptor_GetValue
PropertyDescriptor_HasValue
PropertyDescriptor_SetEnumerable
PropertyDescriptor_IsEnumerable
PropertyDescriptor_HasEnumerable
PropertyDescriptor_SetWritable
PropertyDescriptor_IsWritable
PropertyDescriptor_HasWritable
PropertyDescriptor_SetConfigurable
PropertyDescriptor_HasConfigurable
PropertyDescriptor_IsConfigurable
PropertyDescriptor_SetGetter
PropertyDescriptor_GetGetter
PropertyDescriptor_HasGetter
PropertyDescriptor_SetSetter
PropertyDescriptor_GetSetter
PropertyDescriptor_HasSetter
GlobalParseInt
GlobalParseFloat
ObjectToLocaleString
ObjectValueOf
ObjectIsPrototypeOf
ObjectPropertyIsEnumerable
ObjectKeys
ObjectGetPrototypeOf
ObjectSetPrototypeOf
ObjectCreate
ObjectSealJS
ObjectPreventExtension
ObjectIsExtensible
ObjectIs
ObjectGetProto
ObjectSetProto
BooleanToString
BooleanValueOf
NumberToLocaleString
NumberValueOf
NumberToFixedJS
NumberToExponentialJS
NumberToPrecisionJS
NumberIsInteger
NumberIsSafeInteger
FunctionToString
FunctionBind
v2>B
.T@S
GlobalIsNaN
GlobalIsFinite
GlobalEval
ObjectToString
ObjectHasOwnProperty
ObjectDefineGetter
ObjectLookupGetter
ObjectDefineSetter
ObjectLookupSetter
ObjectGetOwnPropertyDescriptor
ObjectGetOwnPropertyNames
ObjectDefineProperty
ObjectDefineProperties
ObjectFreezeJS
ObjectIsSealed
ObjectIsFrozen
NumberToStringJS
NumberIsFinite
NumberIsNaN
captureStackTrace
native messages.js
NoSideEffectsObjectToString
NoSideEffectToString
CanBeSafelyTreatedAsAnErrorObject
ToStringCheckErrorObject
ToDetailString
MakeGenericError
FormatMessage
GetLineNumber
GetSourceLine
v yz
ScriptLineFromPosition
ScriptLocationFromPosition
ScriptLocationFromLine
ScriptSourceSlice
ScriptSourceLine
ScriptLineCount
ScriptLineEnd
ScriptNameOrSourceURL
SourceLocation
SourceLocationSourceText
SourceSlice
SourceSliceSourceText
GetPositionInLine
GetStackTraceLine
CallSite
CallSiteGetThis
CallSiteGetFunction
CallSiteGetPosition
CallSiteGetTypeName
CallSiteIsToplevel
CallSiteIsEval
CallSiteGetEvalOrigin
CallSiteGetScriptNameOrSourceURL
CallSiteGetFunctionName
CallSiteGetMethodName
CallSiteGetFileName
CallSiteGetLineNumber
CallSiteGetColumnNumber
CallSiteIsNative
CallSiteIsConstructor
CallSiteToString
FormatEvalOrigin
FormatErrorString
GetStackFrames
FormatStackTrace
Nq5
GetTypeName
DefineError
GetPropertyWithoutInvokingMonkeyGetters
ErrorToStringDetectCycle
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
MakeError
MakeEvalError
MakeRangeError
MakeReferenceError
MakeSyntaxError
MakeTypeError
MakeURIError
f"lV
ErrorToString
Script
builtins
$getHash
B3ca
GetHash
native collection.js
HashToEntry
SetFindEntry
MapFindEntry
ComputeIntegerHash
GetExistingHash
SetConstructor
.for
.iterator
delete
get size
clear
forEach
MapConstructor
get size
$mapFromArray
$setFromArray
SetHas
SetDelete
SetGetSize
SetClearJS
SetForEach
MapGet
MapHas
r<O|
MapDelete
MapGetSize
MapClearJS
MapForEach
SetAdd
MapSet
size
entries
native collection-iterator.js
values
SetIterator
Set Iterator
MapIterator
Map Iterator
MathRandomRaw
native math.js
acos
asin
atan
atan2
ceil
floor
random
round
sqrt
imul
sign
trunc
tanh
asinh
acosh
atanh
hypot
fround
clz32
cbrt
CubeRoot
MathConstructor
Math
MathAcosJS
MathAsinJS
MathAtanJS
MathAtan2JS
MathCeil
MathPowJS
MathRandom
MathRound
MathSqrtJS
MathTrunc
MathTanh
MathAsinh
MathAcosh
MathAtanh
MathHypot
MathFroundJS
MathClz32JS
MathCbrt
MathAbs
MathExp
MathFloorJS
MathLog
ZvsE
MathMax
MathMin
MathImul
MathSign
concat
indexOf
native array.js
J?+"
GetSortedArrayKeys
SparseJoinWithSeparatorJS
SparseJoin
UseSparseVariant
Join
ConvertToString
ConvertToLocaleString
SparseSlice
SparseMove
SimpleSlice
SimpleMove
InnerArrayToLocaleString
InnerArrayJoin
join
ObservedArrayPop
ArrayPop
ObservedArrayPush
ArrayPush
ArrayConcatJS
SparseReverse
InnerArrayReverse
reverse
ObservedArrayShift
ArrayShift
ObservedArrayUnshift
ArrayUnshift
ArraySlice
N)H[
ComputeSpliceStartIndex
ComputeSpliceDeleteCount
ObservedArraySplice
ArraySplice
InnerArraySort
sort
InnerArrayFilter
filter
InnerArrayForEach
InnerArraySome
some
InnerArrayEvery
every
InnerArrayMap
InnerArrayIndexOf
InnerArrayLastIndexOf
lastIndexOf
InnerArrayReduce
reduce
InnerArrayReduceRight
reduceRight
isArray
ArrayToLocaleString
ArrayReverse
ArrayFilter
ArrayForEach
ArraySome
ArrayEvery
ArrayMap
ArrayLastIndexOf
ArrayReduce
ArrayReduceRight
ArrayIsArray
ArrayToString
ArrayJoin
ArraySort
ArrayIndexOf
push
V2.Z
shift
splice
InternalArray
APPLY_PREPARE
native runtime.js
ToPrimitive
ToBoolean
ToNumber
NonNumberToNumber
ToString
NonStringToString
ToName
ToObject
ToInteger
ToLength
ToUint32
ToInt32
SameValue
SameValueZero
ConcatIterableToArray
IsPrimitive
IsConcatSpreadable
DefaultNumber
DefaultString
ToPositiveInteger
EQUALS
STRICT_EQUALS
COMPARE
COMPARE_STRONG
ADD_STRONG
STRING_ADD_LEFT
STRING_ADD_LEFT_STRONG
STRING_ADD_RIGHT
STRING_ADD_RIGHT_STRONG
SUB_STRONG
MUL_STRONG
DIV_STRONG
MOD_STRONG
BIT_OR
BIT_OR_STRONG
BIT_AND
BIT_AND_STRONG
BIT_XOR
BIT_XOR_STRONG
SHL_STRONG
SAR_STRONG
SHR_STRONG
~&xZ
DELETE
INSTANCE_OF
CALL_NON_FUNCTION
CALL_NON_FUNCTION_AS_CONSTRUCTOR
CALL_FUNCTION_PROXY
CALL_FUNCTION_PROXY_AS_CONSTRUCTOR
REFLECT_APPLY_PREPARE
REFLECT_CONSTRUCT_PREPARE
CONCAT_ITERABLE_TO_ARRAY
STACK_OVERFLOW
TO_OBJECT
TO_NUMBER
TO_STRING
TO_NAME
StringLengthTFStub
StringAddTFStub
MathFloorStub
fromCharCode
native string.js
StringConstructor
charAt
charCodeAt
localeCompare
match
normalize
replace
ExpandReplacement
CaptureString
StringReplaceGlobalRegExpWithFunction
StringReplaceNonGlobalRegExpWithFunction
search
slice
split
StringSplitOnRegExp
substring
substr
toLowerCase
toLocaleLowerCase
toUpperCase
toLocaleUpperCase
trim
trimLeft
trimRight
HtmlEscape
anchor
jNxH
blink
bold
fixed
fontcolor
fontsize
italics
link
small
strike
repeat
startsWith
endsWith
includes
codePointAt
fromCodePoint
StringToString
StringValueOf
StringCharCodeAtJS
nux 
StringConcat
StringLocaleCompareJS
StringNormalizeJS
StringSearch
StringSlice
StringToLowerCaseJS
StringToLocaleLowerCase
StringToUpperCaseJS
StringToLocaleUpperCase
StringTrimJS
StringTrimLeft
StringTrimRight
StringFromCharCode
StringAnchor
StringBig
StringBlink
StringBold
StringFixed
StringFontcolor
StringFontsize
StringItalics
StringLink
StringSmall
StringStrike
StringSub
StringSup
StringRepeat
StringStartsWith
StringEndsWith
StringIncludes
StringCodePointAt
StringFromCodePoint
StringRaw
StringCharAtJS
StringIndexOfJS
StringLastIndexOfJS
StringMatchJS
StringReplace
StringSplitJS
StringSubstring
StringSubstr
native regexp.js
DoConstructRegExp
RegExpConstructor
compile
DoRegExpExec
RegExpExecNoTests
exec
test
TrimRegExp
RegExpGetLastMatch
RegExpGetLastParen
RegExpGetLeftContext
RegExpGetRightContext
RegExpMakeCaptureGetter
RegExpCompileJS
RegExpExecJS
RegExpToString
RegExpTest
lastMatch
lastParen
leftContext
rightContext
InternalPackedArray
unshift
native array-iterator.js
ArrayIterator
Array Iterator
CreateArrayIterator
CreateIteratorResultObject
[Symbol.iterator]
ArrayValues
ArrayIteratorIterator
ArrayIteratorNext
ArrayEntries
ArrayKeys
copyWithin
native harmony-array.js
InnerArrayCopyWithin
InnerArrayFind
find
InnerArrayFindIndex
findIndex
InnerArrayFill
fill
AddArrayElement
from
ArrayCopyWithin
ArrayFind
ArrayFindIndex
ArrayFill
*Y(y
ArrayOf
ArrayFrom
[Symbol.iterator]
native string-iterator.js
StringIterator
String Iterator
CreateStringIterator
StringIteratorNext
StringPrototypeIterator
MAX_VALUE
MIN_VALUE
NEGATIVE_INFINITY
POSITIVE_INFINITY
MAX_SAFE_INTEGER
MIN_SAFE_INTEGER
EPSILON
$EvalError
message
$objectGetOwnPropertyDescriptor
$setAdd
$toPositiveInteger
symbolHasInstance
$mapDelete
$toCompletePropertyDescriptor
$arrayConcat
$mapSet
$observeEnqueueSpliceRecord
EnqueueSpliceRecord
native object-observe.js
GetObservationStateJS
GetPendingObservers
SetPendingObservers
GetNextCallbackPriority
nullProtoObject
TypeMapCreate
TypeMapAddType
TypeMapRemoveType
TypeMapCreateFromList
TypeMapHasType
TypeMapIsDisjointFrom
ObserverCreate
ObserverGetCallback
ObserverGetAcceptTypes
ObserverIsActive
ObjectInfoGetOrCreate
ObjectInfoGet
ObjectInfoGetFromNotifier
ObjectInfoGetNotifier
ChangeObserversIsOptimized
ObjectInfoNormalizeChangeObservers
ObjectInfoAddObserver
ObjectInfoRemoveObserver
ObjectInfoHasActiveObservers
ObjectInfoAddPerformingType
ObjectInfoRemovePerformingType
ObjectInfoGetPerformingTypes
ConvertAcceptListToTypeMap
CallbackInfoGet
CallbackInfoSet
CallbackInfoGetOrCreate
CallbackInfoGetPriority
CallbackInfoNormalize
observe
NativeObjectObserve
unobserve
ObserverEnqueueIfActive
ObjectInfoEnqueueExternalChangeRecord
ObjectInfoEnqueueInternalChangeRecord
BeginPerformSplice
EndPerformSplice
NotifyChange
notify
performChange
NativeObjectNotifierPerformChange
getNotifier
NativeObjectGetNotifier
CallbackDeliverPending
deliverChangeRecords
ObserveMicrotaskRunner
ArrayObserve
ArrayUnobserve
ObjectNotifierNotify
ObjectNotifierPerformChange
ObjectGetNotifier
ObjectDeliverChangeRecords
ObjectObserve
ObjectUnobserve
update
setPrototype
reconfigure
$setIteratorNext
$toDetailString
$messageGetSourceLine
$promiseCreate
PromiseCreate
native promise.js
PromiseSet
PromiseCreateAndSet
PromiseInit
PromiseDone
PromiseCoerce
PromiseHandle
PromiseEnqueue
PromiseIdResolveHandler
PromiseIdRejectHandler
PromiseNopResolver
IsPromise
PromiseResolve
PromiseReject
defer
accept
reject
chain
catch
then
resolve
race
PromiseHasUserDefinedRejectHandlerRecursive
jd H
PromiseHasUserDefinedRejectHandler
Promise
PromiseResolved
PromiseCatch
PromiseThen
PromiseCast
PromiseAll
PromiseRace
PromiseDeferred
PromiseRejected
PromiseChain
$sameValue
rempio2result
$URIError
symbolIsConcatSpreadable
$observeBeginPerformSplice
$nonNumberToNumber
$arrayUnshift
$toObject
$stackTraceSymbol
$mapHas
$promiseHasUserDefinedRejectHandler
$objectDefineOwnProperty
$promiseStatus
$observeEndPerformSplice
$promiseResolve
symbolToStringTag
$ReferenceError
$messageGetLineNumber
$arrayPop
$setHas
$promiseThen
$noSideEffectToString
$toLength
$NaN
$setValues
symbolIterator
$TypeError
$createDate
CreateDate
native date.js
LocalTimezone
MakeTime
TimeInYear
MakeDay
MakeDate
TimeClip
DateConstructor
TwoDigitString
DateString
LongDateString
TimeString
TimeStringUTC
LocalTimezoneString
DatePrintString
parse
toDateString
toTimeString
toLocaleDateString
toLocaleTimeString
getTime
getFullYear
getUTCFullYear
getMonth
getUTCMonth
getDate
getUTCDate
getDay
getUTCDay
getHours
getUTCHours
getMinutes
getUTCMinutes
getSeconds
getUTCSeconds
getMilliseconds
getUTCMilliseconds
getTimezoneOffset
setTime
setMilliseconds
setUTCMilliseconds
setSeconds
setUTCSeconds
setMinutes
setUTCMinutes
setHours
setUTCHours
setDate
setUTCDate
setMonth
setUTCMonth
setFullYear
setUTCFullYear
toUTCString
getYear
setYear
toGMTString
PadInt
toISOString
:zKJ
CheckDateCacheCurrent
DateUTC
DateNow
DateToDateString
DateToTimeString
DateToLocaleString
DateToLocaleDateString
DateToLocaleTimeString
DateValueOf
DateGetTime
DateGetFullYear
DateGetUTCFullYear
DateGetMonth
DateGetUTCMonth
DateGetDate
DateGetUTCDate
DateGetDay
VPiQ
DateGetUTCDay
DateGetHours
DateGetUTCHours
DateGetMinutes
DateGetUTCMinutes
DateGetSeconds
DateGetUTCSeconds
DateGetMilliseconds
DateGetUTCMilliseconds
DateGetTimezoneOffset
DateSetTime
DateSetMilliseconds
DateSetUTCMilliseconds
DateSetSeconds
DateSetUTCSeconds
DateSetMinutes
DateSetUTCMinutes
DateSetHours
DateSetUTCHours
DateSetDate
DateSetUTCDate
DateSetMonth
DateSetUTCMonth
DateSetFullYear
DateSetUTCFullYear
DateGetYear
DateSetYear
DateToGMTString
DateToISOString
DateToJSON
DateParse
DateToString
DateToUTCString
time
Sunday
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
January
February
March
April
June
July
August
September
October
November
December
rngstate
$errorToString
$jsonSerializeAdapter
native json.js
Revive
SerializeArray
SerializeObject
JSONSerialize
stringify
JSONParse
JSONStringify
$regexpLastMatchInfoOverride
$toInt32
$RangeError
$arrayPush
$sameValueZero
$functionSourceString
$observeNativeObjectNotifierPerformChange
$getExistingHash
$getStackTraceLine
symbolIsRegExp
OpaqueReference
$toBoolean
$toString
$arrayShift
Maximum call stack size exceeded
$promiseChain
$toNumber
$mapEntries
$globalEval
$concatIterableToArray
$defaultString
$messageGetPositionInLine
$observeNativeObjectGetNotifier
$toPrimitive
$arraySlice
$SyntaxError
$toName
$mapIteratorNext
$defaultNumber
$observeNotifyChange
$observeNativeObjectObserve
$arrayValues
kMath
GeneratorFunctionPrototype
GeneratorFunction
native generator.js
GeneratorFunctionConstructor
B)CZ
GeneratorObjectNext
GeneratorObjectThrow
$symbolToString
native symbol.js
SymbolConstructor
getOwnPropertySymbols
SymbolToString
SymbolValueOf
SymbolFor
SymbolKeyFor
ObjectGetOwnPropertySymbols
$toUint32
$getTemplateCallSite
native templates.js
SameCallSiteElements
GetCachedCallSite
SetCachedCallSite
$toInteger
symbolUnscopables
line_ends
line_offset
column_offset
lineFromPosition
locationFromPosition
locationFromLine
sourceSlice
sourceLine
lineCount
nameOrSourceURL
lineEnd
type
compilation_type
context_data
eval_from_script
eval_from_script_position
eval_from_function_name
is_debugger_script
$promiseValue
$Error
$arraySplice
$iteratorPrototype
$mapGet
$promiseCatch
$setDelete
$nonStringToString
$promiseReject
script
position
line
column
start
sourceText
from_line
to_line
from_position
to_position
CallSite#receiver
CallSite#function
6wbf
CallSite#position
CallSite#strict_mode
receiver
getThis
getTypeName
isToplevel
&z|#
isEval
getEvalOrigin
getScriptNameOrSourceURL
getFunction
getFunctionName
getMethodName
getFileName
getLineNumber
getColumnNumber
isNative
getPosition
isConstructor
formatted stack trace
value_
hasValue_
Z"82
writable_
hasWritable_
enumerable_
hasEnumerable_
configurable_
hasConfigurable_
get_
hasGetter_
set_
hasSetter_
setValue
getValue
hasValue
setEnumerable
isEnumerable
hasEnumerable
setWritable
isWritable
hasWritable
setConfigurable
hasConfigurable
nLo-
isConfigurable
setGet
getGet
hasGetter
setSet
getSet
hasSetter
ThrowTypeError
call
apply
() {}
Int16Array
BYTES_PER_ELEMENT
native harmony-typedarray.js
ConstructTypedArray
ConstructTypedArrayLike
TypedArrayComparefn
TypedArrayCopyWithin
TypedArrayEvery
TypedArrayForEach
TypedArrayFill
TypedArrayFilter
TypedArrayFind
TypedArrayFindIndex
TypedArrayReverse
TypedArraySort
TypedArrayIndexOf
TypedArrayLastIndexOf
TypedArrayMap
TypedArraySome
TypedArrayToLocaleString
TypedArrayToString
TypedArrayJoin
TypedArrayReduce
TypedArrayReduceRight
TypedArraySlice
TypedArrayOf
TypedArrayFrom
buffer
get buffer
native typedarray.js
Uint8ArrayConstructByArrayBuffer
Uint8ArrayConstructByLength
Uint8ArrayConstructByArrayLike
Uint8ArrayConstructByIterable
Uint8ArrayConstructor
get buffer
get byteLength
get byteOffset
get length
subarray
Int8ArrayConstructByArrayBuffer
Int8ArrayConstructByLength
Int8ArrayConstructByArrayLike
Int8ArrayConstructByIterable
Int8ArrayConstructor
get buffer
get byteLength
get byteOffset
get length
Uint16ArrayConstructByArrayBuffer
Uint16ArrayConstructByLength
Uint16ArrayConstructByArrayLike
Uint16ArrayConstructByIterable
Uint16ArrayConstructor
get buffer
get byteLength
get byteOffset
get length
Int16ArrayConstructByArrayBuffer
Int16ArrayConstructByLength
Int16ArrayConstructByArrayLike
Int16ArrayConstructByIterable
Int16ArrayConstructor
get byteLength
get byteOffset
get length
Uint32ArrayConstructByArrayBuffer
Uint32ArrayConstructByLength
Uint32ArrayConstructByArrayLike
Uint32ArrayConstructByIterable
Uint32ArrayConstructor
get buffer
get byteLength
get byteOffset
get length
Int32ArrayConstructByArrayBuffer
Int32ArrayConstructByLength
Int32ArrayConstructByArrayLike
Int32ArrayConstructByIterable
Int32ArrayConstructor
get buffer
get byteLength
get byteOffset
get length
Float32ArrayConstructByArrayBuffer
Float32ArrayConstructByLength
Float32ArrayConstructByArrayLike
Float32ArrayConstructByIterable
Float32ArrayConstructor
get buffer
get byteLength
get byteOffset
get length
Float64ArrayConstructByArrayBuffer
Float64ArrayConstructByLength
Float64ArrayConstructByArrayLike
Float64ArrayConstructByIterable
Float64ArrayConstructor
get buffer
get byteLength
get byteOffset
get length
Uint8ClampedArrayConstructByArrayBuffer
Uint8ClampedArrayConstructByLength
Uint8ClampedArrayConstructByArrayLike
Uint8ClampedArrayConstructByIterable
Uint8ClampedArrayConstructor
get buffer
get byteLength
get byteOffset
get length
TypedArraySetFromArrayLike
TypedArraySetFromOverlappingTypedArray
get [Symbol.toStringTag]
DataViewConstructor
get buffer
get byteOffset
get byteLength
getInt8
setInt8
getUint8
setUint8
getInt16
setInt16
getUint16
setUint16
getInt32
setInt32
getUint32
setUint32
getFloat32
setFloat32
getFloat64
setFloat64
Uint8Array_GetBuffer
Uint8Array_GetByteLength
Uint8Array_GetByteOffset
Uint8Array_GetLength
Uint8ArraySubArray
Int8Array_GetBuffer
Int8Array_GetByteLength
Int8Array_GetByteOffset
Int8Array_GetLength
Int8ArraySubArray
Uint16Array_GetBuffer
Uint16Array_GetByteLength
Uint16Array_GetByteOffset
Uint16Array_GetLength
Uint16ArraySubArray
Int16Array_GetBuffer
Int16Array_GetByteLength
Int16Array_GetByteOffset
Int16Array_GetLength
Int16ArraySubArray
Uint32Array_GetBuffer
Uint32Array_GetByteLength
Uint32Array_GetByteOffset
Uint32Array_GetLength
Uint32ArraySubArray
Int32Array_GetBuffer
Int32Array_GetByteLength
Int32Array_GetByteOffset
Int32Array_GetLength
Int32ArraySubArray
Float32Array_GetBuffer
Float32Array_GetByteLength
Float32Array_GetByteOffset
Float32Array_GetLength
Float32ArraySubArray
Float64Array_GetBuffer
Float64Array_GetByteLength
Float64Array_GetByteOffset
Float64Array_GetLength
Float64ArraySubArray
Uint8ClampedArray_GetBuffer
Uint8ClampedArray_GetByteLength
Uint8ClampedArray_GetByteOffset
Uint8ClampedArray_GetLength
Uint8ClampedArraySubArray
TypedArraySet
"/{*
TypedArrayGetToStringTag
DataViewGetBufferJS
DataViewGetByteOffset
DataViewGetByteLength
DataViewGetInt8JS
DataViewSetInt8JS
DataViewGetUint8JS
DataViewSetUint8JS
DataViewGetInt16JS
DataViewSetInt16JS
DataViewGetUint16JS
DataViewSetUint16JS
DataViewGetInt32JS
DataViewSetInt32JS
DataViewGetUint32JS
DataViewSetUint32JS
DataViewGetFloat32JS
DataViewSetFloat32JS
DataViewGetFloat64JS
DataViewSetFloat64JS
Uint8Array
Int8Array
Uint16Array
Uint32Array
Int32Array
Float32Array
Float64Array
Uint8ClampedArray
DataView
Vzc.
isView
native arraybuffer.js
ArrayBufferConstructor
get byteLength
ArrayBufferGetByteLen
ArrayBufferSlice
ArrayBufferIsViewJS
ArrayBuffer
native weak-collection.js
LN10
LOG2E
LOG10E
SQRT1_2
SQRT2
native fdlibm.js
KernelTan
MathSinSlow
MathCosSlow
log1p
expm1
sinh
cosh
log10
log2
MathSin
MathCos
MathTan
MathLog1p
MathSinh
MathCosh
MathLog10
MathLog2
MathExpm1
encodeURIComponent
native uri.js
HexValueOf
isAlphaNumeric
URIAddEncodedOctetToBuffer
URIEncodeOctets
URIEncodeSingle
URIEncodePair
URIHexCharsToCharCode
URIDecodeOctets
Encode
Decode
escape
unescape
decodeURI
decodeURIComponent
encodeURI
URIEscapeJS
URIUnescapeJS
URIDecode
URIDecodeComponent
URIEncode
URIEncodeComponent
iterator
unscopables
JSON
context_extension
Import
native prologue.js
Export
ImportFromExperimental
SetFunctionName
InstallConstants
InstallFunctions
InstallGetter
6B;l
InstallGetterSetter
SetUpLockedPrototype
fields
methods
PostNatives
PostExperimentals
IsNaN
[Symbol.iterator]
native iterator-prototype.js
<error>
...<omitted>...
hasOwn
ArrayIteratorCreateResultObject
SharedArrayBuffer
IsFinite
RegExpLastMatchInfo
Array Iterator.prototype.next
IntRandom
function*
====
=======
666666666666666666666666666666666666666666666666\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
                    
`H?f
F/p^
+QQ 3K%
0A/8
Hp!v
kNGY|(
wl]azW
6.F^
JN5gm
Qf(I
~^bv
Qmm5
`H?f
F/p^
+QQ 3K%
0A/8
Hp!v
kNGY|(
wl]azW
6.F^
JN5gm
Qf(I
~^bv
Qmm5
Hp!v
kNGY|(
wl]azW
6.F^
JN5gm
Qf(I
~^bv
Qmm5
wl]azW
6.F^
JN5gm
Qf(I
~^bv
Qmm5
uT_Rm#
'`ax
#ETHw
dlCz 
l}C.we
SK?Nv
'nU_O_M
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz./
@fRo
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
~~~~
