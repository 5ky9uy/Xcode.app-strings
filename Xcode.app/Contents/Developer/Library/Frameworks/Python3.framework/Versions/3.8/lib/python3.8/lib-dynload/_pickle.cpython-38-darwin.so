Optimized C implementation for the Python pickle module.
dump($module, /, obj, file, protocol=None, *, fix_imports=True,
     buffer_callback=None)
Write a pickled representation of obj to the open file object file.
This is equivalent to ``Pickler(file, protocol).dump(obj)``, but may
be more efficient.
The optional *protocol* argument tells the pickler to use the given
protocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default
protocol is 4. It was introduced in Python 3.4, and is incompatible
with previous versions.
Specifying a negative protocol version selects the highest protocol
version supported.  The higher the protocol used, the more recent the
version of Python needed to read the pickle produced.
The *file* argument must have a write() method that accepts a single
bytes argument.  It can thus be a file object opened for binary
writing, an io.BytesIO instance, or any other custom object that meets
this interface.
If *fix_imports* is True and protocol is less than 3, pickle will try
to map the new Python 3 names to the old module names used in Python
2, so that the pickle data stream is readable with Python 2.
If *buffer_callback* is None (the default), buffer views are serialized
into *file* as part of the pickle stream.  It is an error if
*buffer_callback* is not None and *protocol* is None or smaller than 5.
dumps($module, /, obj, protocol=None, *, fix_imports=True,
      buffer_callback=None)
Return the pickled representation of the object as a bytes object.
The optional *protocol* argument tells the pickler to use the given
protocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default
protocol is 4. It was introduced in Python 3.4, and is incompatible
with previous versions.
Specifying a negative protocol version selects the highest protocol
version supported.  The higher the protocol used, the more recent the
version of Python needed to read the pickle produced.
If *fix_imports* is True and *protocol* is less than 3, pickle will
try to map the new Python 3 names to the old module names used in
Python 2, so that the pickle data stream is readable with Python 2.
If *buffer_callback* is None (the default), buffer views are serialized
into *file* as part of the pickle stream.  It is an error if
*buffer_callback* is not None and *protocol* is None or smaller than 5.
load($module, /, file, *, fix_imports=True, encoding='ASCII',
     errors='strict', buffers=())
Read and return an object from the pickle data stored in a file.
This is equivalent to ``Unpickler(file).load()``, but may be more
efficient.
The protocol version of the pickle is detected automatically, so no
protocol argument is needed.  Bytes past the pickled object's
representation are ignored.
The argument *file* must have two methods, a read() method that takes
an integer argument, and a readline() method that requires no
arguments.  Both methods should return bytes.  Thus *file* can be a
binary file object opened for reading, an io.BytesIO object, or any
other custom object that meets this interface.
Optional keyword arguments are *fix_imports*, *encoding* and *errors*,
which are used to control compatibility support for pickle stream
generated by Python 2.  If *fix_imports* is True, pickle will try to
map the old Python 2 names to the new names used in Python 3.  The
*encoding* and *errors* tell pickle how to decode 8-bit string
instances pickled by Python 2; these default to 'ASCII' and 'strict',
respectively.  The *encoding* can be 'bytes' to read these 8-bit
string instances as bytes objects.
loads($module, /, data, *, fix_imports=True, encoding='ASCII',
      errors='strict', buffers=())
Read and return an object from the given pickle data.
The protocol version of the pickle is detected automatically, so no
protocol argument is needed.  Bytes past the pickled object's
representation are ignored.
Optional keyword arguments are *fix_imports*, *encoding* and *errors*,
which are used to control compatibility support for pickle stream
generated by Python 2.  If *fix_imports* is True, pickle will try to
map the old Python 2 names to the new names used in Python 3.  The
*encoding* and *errors* tell pickle how to decode 8-bit string
instances pickled by Python 2; these default to 'ASCII' and 'strict',
respectively.  The *encoding* can be 'bytes' to read these 8-bit
string instances as bytes objects.
Unpickler(file, *, fix_imports=True, encoding='ASCII', errors='strict',
          buffers=())
This takes a binary file for reading a pickle data stream.
The protocol version of the pickle is detected automatically, so no
protocol argument is needed.  Bytes past the pickled object's
representation are ignored.
The argument *file* must have two methods, a read() method that takes
an integer argument, and a readline() method that requires no
arguments.  Both methods should return bytes.  Thus *file* can be a
binary file object opened for reading, an io.BytesIO object, or any
other custom object that meets this interface.
Optional keyword arguments are *fix_imports*, *encoding* and *errors*,
which are used to control compatibility support for pickle stream
generated by Python 2.  If *fix_imports* is True, pickle will try to
map the old Python 2 names to the new names used in Python 3.  The
*encoding* and *errors* tell pickle how to decode 8-bit string
instances pickled by Python 2; these default to 'ASCII' and 'strict',
respectively.  The *encoding* can be 'bytes' to read these 8-bit
string instances as bytes objects.
load($self, /)
Load a pickle.
Read a pickled object representation from the open file object given
in the constructor, and return the reconstituted object hierarchy
specified therein.
find_class($self, module_name, global_name, /)
Return an object from a specified module.
If necessary, the module will be imported. Subclasses may override
this method (e.g. to restrict unpickling of arbitrary classes and
functions).
This method is called whenever a class or a function object is
needed.  Both arguments passed are str objects.
__sizeof__($self, /)
Returns size in memory, in bytes.
Pickler(file, protocol=None, fix_imports=True, buffer_callback=None)
This takes a binary file for writing a pickle data stream.
The optional *protocol* argument tells the pickler to use the given
protocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default
protocol is 4. It was introduced in Python 3.4, and is incompatible
with previous versions.
Specifying a negative protocol version selects the highest protocol
version supported.  The higher the protocol used, the more recent the
version of Python needed to read the pickle produced.
The *file* argument must have a write() method that accepts a single
bytes argument. It can thus be a file object opened for binary
writing, an io.BytesIO instance, or any other custom object that meets
this interface.
If *fix_imports* is True and protocol is less than 3, pickle will try
to map the new Python 3 names to the old module names used in Python
2, so that the pickle data stream is readable with Python 2.
If *buffer_callback* is None (the default), buffer views are
serialized into *file* as part of the pickle stream.
If *buffer_callback* is not None, then it can be called any number
of times with a buffer view.  If the callback returns a false value
(such as None), the given buffer is out-of-band; otherwise the
buffer is serialized in-band, i.e. inside the pickle stream.
It is an error if *buffer_callback* is not None and *protocol*
is None or smaller than 5.
dump($self, obj, /)
Write a pickled representation of the given object to the open file.
clear_memo($self, /)
Clears the pickler's "memo".
The memo is the data structure that remembers which objects the
pickler has already seen, so that shared or recursive objects are
pickled by reference and not by value.  This method is useful when
re-using picklers.
__sizeof__($self, /)
Returns size in memory, in bytes.
clear($self, /)
Remove all items from memo.
copy($self, /)
Copy the memo to a new object.
__reduce__($self, /)
Implement pickle support.
clear($self, /)
Remove all items from memo.
copy($self, /)
Copy the memo to a new object.
__reduce__($self, /)
Implement pickling support.
Pickler
Unpickler
PickleBuffer
_pickle.PickleError
_pickle.PicklingError
_pickle.UnpicklingError
PickleError
PicklingError
UnpicklingError
_pickle
dump
dumps
load
loads
file
protocol
fix_imports
buffer_callback
pickle protocol must be <= %d
write
file must have a 'write' attribute
buffer_callback needs protocol >= 5
reducer_override
 while pickling an object
__reduce__
__reduce_ex__
can't pickle '%.200s' object: %R
__reduce__ must return a string or tuple
persistent IDs in protocol 0 must be ASCII strings
%c%ld
int too large to pickle
memo id too large for LONG_BINGET
(O())
strict
latin1
(O(OO))
serializing a bytes object larger than 4 GiB requires pickle protocol 4 or higher
memo id too large for LONG_BINPUT
utf-8
surrogatepass
serializing a string larger than 4 GiB requires pickle protocol 4 or higher
items
fast mode: can't pickle cyclic objects including object type %.200s at %p
dictionary changed size during iteration
dict items iterator must return 2-tuples
(O(O))
set changed size during iteration
PickleBuffer can only pickled with protocol >= 5
PickleBuffer can not be pickled when pointing to a non-contiguous buffer
O(O)
__name__
__qualname__
Can't pickle %R: import of module %R failed
Can't pickle %R: attribute lookup %S on %S failed
Can't pickle %R: it's not the same object as %S.%S
Can't pickle %R: extension code %R isn't an integer
Can't pickle %R: extension code %ld is out of range
can't pickle module identifier '%S' using pickle protocol %i
can't pickle global identifier '%S' using pickle protocol %i
<locals>
Can't pickle local object %R
Can't pickle local attribute %R on %R
__module__
modules
__main__
unable to get sys.modules
_compat_pickle.REVERSE_NAME_MAPPING values should be 2-tuples, not %.200s
_compat_pickle.REVERSE_NAME_MAPPING values should be pairs of str, not (%.200s, %.200s)
_compat_pickle.REVERSE_IMPORT_MAPPING values should be strings, not %.200s
tuple returned by __reduce__ must contain 2 through 6 elements
save_reduce
first item of the tuple returned by __reduce__ must be callable
second item of the tuple returned by __reduce__ must be a tuple
fourth element of the tuple returned by __reduce__ must be an iterator, not %s
fifth element of the tuple returned by __reduce__ must be an iterator, not %s
sixth element of the tuple returned by __reduce__ must be a function, not %s
__newobj_ex__
__newobj__
length of the NEWOBJ_EX argument tuple must be exactly 3, not %zd
first item from NEWOBJ_EX argument tuple must be a class, not %.200s
second item from NEWOBJ_EX argument tuple must be a tuple, not %.200s
third item from NEWOBJ_EX argument tuple must be a dict, not %.200s
__new__
__newobj__ arglist is empty
args[0] from __newobj__ args is not a type
args[0] from __newobj__ args has the wrong class
__class__
encoding
errors
buffers
ASCII
argument 'encoding'
embedded null character
argument 'errors'
peek
read
readinto
readline
file must have 'read' and 'readline' attributes
Ran out of input
invalid load key, '%c'.
invalid load key, '\x%02x'.
read would overflow (invalid bytecode)
pickle data was truncated
could not convert string to int
LONG pickle has negative byte count
could not convert string to float
BINBYTES exceeds system's maximum size of %zd bytes
read() returned non-bytes object (%R)
readinto() returned negative size
BYTEARRAY8 exceeds system's maximum size of %zd bytes
pickle stream refers to out-of-band data but no *buffers* argument was given
not enough out-of-band buffers
unexpected MARK found
unpickling stack underflow
BINSTRING exceeds system's maximum size of %zd bytes
bytes
the STRING opcode argument must be quoted
BINUNICODE exceeds system's maximum size of %zd bytes
could not find MARK
odd number of items for DICT
__getinitargs__
find_class
NEWOBJ expected an arg tuple.
NEWOBJ class argument isn't a type object
NEWOBJ class argument has NULL tp_new
NEWOBJ_EX class argument must be a type, not %.200s
NEWOBJ_EX class argument doesn't have __new__
STACK_GLOBAL requires str
extend
append
__setstate__
__dict__
state is not a dictionary
slot state is not a dictionary
negative PUT argument
odd number of items for SETITEMS
A load persistent id instruction was encountered,
but no persistent_load function was specified.
unsupported pickle protocol: %d
FRAME length exceeds system's maximum of %zd bytes
EXT specifies code <= 0
unregistered extension code %ld
_inverted_registry[%ld] isn't a 2-tuple of strings
data
_pickle.Unpickler
__sizeof__
Unpickler.__init__() was not called by %s.__init__()
pickle.find_class
_compat_pickle.NAME_MAPPING values should be 2-tuples, not %.200s
_compat_pickle.NAME_MAPPING values should be pairs of str, not (%.200s, %.200s)
_compat_pickle.IMPORT_MAPPING values should be strings, not %.200s
Can't get attribute %R on %R
memo
persistent_load
attribute deletion is not supported
memo key must be integers
memo key must be positive integers.
'memo' attribute must be an UnpicklerMemoProxy object or dict, not %.200s
persistent_load must be a callable taking one argument
_pickle.Pickler
clear_memo
Pickler.__init__() was not called by %s.__init__()
fast
dispatch_table
persistent_id
'memo' values must be 2-item tuples
'memo' attribute must be a PicklerMemoProxy object or dict, not %.200s
persistent_id must be a callable taking one argument
_pickle.Pdata
_pickle.PicklerMemoProxy
clear
copy
_pickle.UnpicklerMemoProxy
getattr
copyreg
copyreg.dispatch_table should be a dict, not %.200s
_extension_registry
copyreg._extension_registry should be a dict, not %.200s
_inverted_registry
copyreg._inverted_registry should be a dict, not %.200s
_extension_cache
copyreg._extension_cache should be a dict, not %.200s
_compat_pickle
NAME_MAPPING
_compat_pickle.NAME_MAPPING should be a dict, not %.200s
IMPORT_MAPPING
_compat_pickle.IMPORT_MAPPING should be a dict, not %.200s
REVERSE_NAME_MAPPING
_compat_pickle.REVERSE_NAME_MAPPING should be a dict, not %.200s
REVERSE_IMPORT_MAPPING
_compat_pickle.REVERSE_IMPORT_MAPPING should be a dict, not %.200s
codecs
encode
codecs.encode should be a callable, not %.200s
functools
partial
