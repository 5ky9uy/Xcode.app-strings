__version__
_dialects
Dialect
_csv.Error
Error
_csv.Dialect
skipinitialspace
doublequote
strict
delimiter
escapechar
lineterminator
quotechar
quoting
|OOOOOOOOO
"delimiter" must be a 1-character string
quotechar must be set if quoting enabled
lineterminator must be set
dialect
unknown dialect
"%s" must be string, not %.200s
"%s" must be a 1-character string
"%s" must be a string
"%s" must be an integer
bad "quoting" value
_csv.reader
unexpected end of data
iterator should return strings, not %.200s (did you open the file in text mode?)
line contains NUL
'%c' expected after '%c'
new-line character seen in unquoted field - do you need to open the file in universal-newline mode?
field larger than field limit (%ld)
line_num
_csv.writer
writerow
writerows
iterable expected, not %.200s
single empty field record must be quoted
need to escape, but no escapechar set
_csv
reader
writer
list_dialects
register_dialect
unregister_dialect
get_dialect
field_size_limit
write
argument 1 must have a "write" method
dialect name must be a string
limit must be an integer
QUOTE_MINIMAL
QUOTE_ALL
QUOTE_NONNUMERIC
QUOTE_NONE
CSV dialect
The Dialect type records CSV parsing and generation options.
CSV reader
Reader objects are responsible for reading and parsing tabular data
in CSV format.
CSV writer
Writer objects are responsible for generating tabular data
in CSV format from sequence input.
writerow(iterable)
Construct and write a CSV record from an iterable of fields.  Non-string
elements will be converted to string.
writerows(iterable of iterables)
Construct and write a series of iterables to a csv file.  Non-string
elements will be converted to string.
CSV parsing and writing.
This module provides classes that assist in the reading and writing
of Comma Separated Value (CSV) files, and implements the interface
described by PEP 305.  Although many CSV files are simple to parse,
the format is not formally defined by a stable specification and
is subtle enough that parsing lines of a CSV file with something
like line.split(",") is bound to fail.  The module supports three
basic APIs: reading, writing, and registration of dialects.
DIALECT REGISTRATION:
Readers and writers support a dialect argument, which is a convenient
handle on a group of settings.  When the dialect argument is a string,
it identifies one of the dialects previously registered with the module.
If it is a class or instance, the attributes of the argument are used as
the settings for the reader or writer:
    class excel:
        delimiter = ','
        quotechar = '"'
        escapechar = None
        doublequote = True
        skipinitialspace = False
        lineterminator = '\r\n'
        quoting = QUOTE_MINIMAL
SETTINGS:
    * quotechar - specifies a one-character string to use as the
        quoting character.  It defaults to '"'.
    * delimiter - specifies a one-character string to use as the
        field separator.  It defaults to ','.
    * skipinitialspace - specifies how to interpret whitespace which
        immediately follows a delimiter.  It defaults to False, which
        means that whitespace immediately following a delimiter is part
        of the following field.
    * lineterminator -  specifies the character sequence which should
        terminate rows.
    * quoting - controls when quotes should be generated by the writer.
        It can take on any of the following module constants:
        csv.QUOTE_MINIMAL means only when required, for example, when a
            field contains either the quotechar or the delimiter
        csv.QUOTE_ALL means that quotes are always placed around fields.
        csv.QUOTE_NONNUMERIC means that quotes are always placed around
            fields which do not parse as integers or floating point
            numbers.
        csv.QUOTE_NONE means that quotes are never placed around fields.
    * escapechar - specifies a one-character string used to escape
        the delimiter when quoting is set to QUOTE_NONE.
    * doublequote - controls the handling of quotes inside fields.  When
        True, two consecutive quotes are interpreted as one during read,
        and when writing, each quote character embedded in the data is
        written as two quotes
    csv_reader = reader(iterable [, dialect='excel']
                        [optional keyword args])
    for row in csv_reader:
        process(row)
The "iterable" argument can be any object that returns a line
of input for each iteration, such as a file object or a list.  The
optional "dialect" parameter is discussed below.  The function
also accepts optional keyword arguments which override settings
provided by the dialect.
The returned object is an iterator.  Each iteration returns a row
of the CSV file (which can span multiple input lines).
    csv_writer = csv.writer(fileobj [, dialect='excel']
                            [optional keyword args])
    for row in sequence:
        csv_writer.writerow(row)
    [or]
    csv_writer = csv.writer(fileobj [, dialect='excel']
                            [optional keyword args])
    csv_writer.writerows(rows)
The "fileobj" argument can be any object that supports the file API.
Return a list of all know dialect names.
    names = csv.list_dialects()
Create a mapping from a string name to a dialect class.
    dialect = csv.register_dialect(name[, dialect[, **fmtparams]])
Delete the name/dialect mapping associated with a string name.
    csv.unregister_dialect(name)
Return the dialect instance associated with name.
    dialect = csv.get_dialect(name)
Sets an upper limit on parsed fields.
    csv.field_size_limit([limit])
Returns old limit. If limit is not given, no new limit is set and
the old limit is returned
#Z-3:FYCSV dialect
The Dialect type records CSV parsing and generation options.
CSV reader
Reader objects are responsible for reading and parsing tabular data
in CSV format.
CSV writer
Writer objects are responsible for generating tabular data
in CSV format from sequence input.
writerow(iterable)
Construct and write a CSV record from an iterable of fields.  Non-string
elements will be converted to string.
writerows(iterable of iterables)
Construct and write a series of iterables to a csv file.  Non-string
elements will be converted to string.
CSV parsing and writing.
This module provides classes that assist in the reading and writing
of Comma Separated Value (CSV) files, and implements the interface
described by PEP 305.  Although many CSV files are simple to parse,
the format is not formally defined by a stable specification and
is subtle enough that parsing lines of a CSV file with something
like line.split(",") is bound to fail.  The module supports three
basic APIs: reading, writing, and registration of dialects.
DIALECT REGISTRATION:
Readers and writers support a dialect argument, which is a convenient
handle on a group of settings.  When the dialect argument is a string,
it identifies one of the dialects previously registered with the module.
If it is a class or instance, the attributes of the argument are used as
the settings for the reader or writer:
    class excel:
        delimiter = ','
        quotechar = '"'
        escapechar = None
        doublequote = True
        skipinitialspace = False
        lineterminator = '\r\n'
        quoting = QUOTE_MINIMAL
SETTINGS:
    * quotechar - specifies a one-character string to use as the
        quoting character.  It defaults to '"'.
    * delimiter - specifies a one-character string to use as the
        field separator.  It defaults to ','.
    * skipinitialspace - specifies how to interpret whitespace which
        immediately follows a delimiter.  It defaults to False, which
        means that whitespace immediately following a delimiter is part
        of the following field.
    * lineterminator -  specifies the character sequence which should
        terminate rows.
    * quoting - controls when quotes should be generated by the writer.
        It can take on any of the following module constants:
        csv.QUOTE_MINIMAL means only when required, for example, when a
            field contains either the quotechar or the delimiter
        csv.QUOTE_ALL means that quotes are always placed around fields.
        csv.QUOTE_NONNUMERIC means that quotes are always placed around
            fields which do not parse as integers or floating point
            numbers.
        csv.QUOTE_NONE means that quotes are never placed around fields.
    * escapechar - specifies a one-character string used to escape
        the delimiter when quoting is set to QUOTE_NONE.
    * doublequote - controls the handling of quotes inside fields.  When
        True, two consecutive quotes are interpreted as one during read,
        and when writing, each quote character embedded in the data is
        written as two quotes
    csv_reader = reader(iterable [, dialect='excel']
                        [optional keyword args])
    for row in csv_reader:
        process(row)
The "iterable" argument can be any object that returns a line
of input for each iteration, such as a file object or a list.  The
optional "dialect" parameter is discussed below.  The function
also accepts optional keyword arguments which override settings
provided by the dialect.
The returned object is an iterator.  Each iteration returns a row
of the CSV file (which can span multiple input lines).
    csv_writer = csv.writer(fileobj [, dialect='excel']
                            [optional keyword args])
    for row in sequence:
        csv_writer.writerow(row)
    [or]
    csv_writer = csv.writer(fileobj [, dialect='excel']
                            [optional keyword args])
    csv_writer.writerows(rows)
The "fileobj" argument can be any object that supports the file API.
Return a list of all know dialect names.
    names = csv.list_dialects()
Create a mapping from a string name to a dialect class.
    dialect = csv.register_dialect(name[, dialect[, **fmtparams]])
Delete the name/dialect mapping associated with a string name.
    csv.unregister_dialect(name)
Return the dialect instance associated with name.
    dialect = csv.get_dialect(name)
Sets an upper limit on parsed fields.
    csv.field_size_limit([limit])
Returns old limit. If limit is not given, no new limit is set and
the old limit is returned
__version__
_dialects
Dialect
_csv.Error
Error
_csv.Dialect
skipinitialspace
doublequote
strict
delimiter
escapechar
lineterminator
quotechar
quoting
|OOOOOOOOO
"delimiter" must be a 1-character string
quotechar must be set if quoting enabled
lineterminator must be set
dialect
unknown dialect
"%s" must be string, not %.200s
"%s" must be a 1-character string
"%s" must be a string
"%s" must be an integer
bad "quoting" value
_csv.reader
unexpected end of data
iterator should return strings, not %.200s (did you open the file in text mode?)
line contains NUL
'%c' expected after '%c'
new-line character seen in unquoted field - do you need to open the file in universal-newline mode?
field larger than field limit (%ld)
line_num
_csv.writer
writerow
writerows
iterable expected, not %.200s
single empty field record must be quoted
need to escape, but no escapechar set
_csv
reader
writer
list_dialects
register_dialect
unregister_dialect
get_dialect
field_size_limit
write
argument 1 must have a "write" method
dialect name must be a string
limit must be an integer
QUOTE_MINIMAL
QUOTE_ALL
QUOTE_NONNUMERIC
QUOTE_NONE
