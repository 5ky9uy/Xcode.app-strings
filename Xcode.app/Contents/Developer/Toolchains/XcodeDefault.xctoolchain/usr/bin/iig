%s%s
astrcat
iig/iig.cpp
-1 != result
.iig
implements
const
volatile
restrict
%s:%3d [%03d]
 %s (%s)
                         type[%d] (%s)
                         comment[%d:%d] (%s)
  %s attribute: %s
kernel
native
remote
localonly
extends=
Construct
other
OSMetaClassBase
method:  (%s) %s::%s
void
overrides: (%s) %s::%s
  %s: attribute: %s
local
localhost
invokereply
reply
queuename=
type=
meth->typeMethod
error: %s::%s != type %s::%s
meth->mvirtual || meth->mstatic || meth->localonly
target
param->typeMethod
MACH_MSG_TYPE
OSAction
param->action
NULL == meth->target
%sCount
%s    ((%s) %s)
(in) 
(out)
meth->cls == cls
EmitRPCTypes
meth->msgid
%s_%s_%s
(1ULL << (__builtin_offsetof(%s_Content, hdr.object) / sizeof(OSObjectRef)))
struct %s_Content
    IORPCMessage hdr;
    kern_return_t _result;
    
OSObjectRef
(1ULL << (__builtin_offsetof(%s_Content, %s) / sizeof(OSObjectRef)))
%s%s *
const 
  %s;
    %s __%s[%d];
    uint64_t __replyBuffer[8];
#pragma pack(4)
struct %s
    IORPCMessageMach           mach;
    mach_msg_port_descriptor_t objects[%d];
    %s_Content content;
#pragma pack()
#define %s_ObjRefs (%s)
typedef union
    const IORPC rpc;
    struct
    {
        const struct %s_%s_Msg * message;
        struct %s_%s_Rpl       * reply;
        uint32_t sendSize;
        uint32_t replySize;
    };
%s_%s_Invocation;
#include <%s>  /* .iig include */ 
#include <%s>
CopyLines
false
    %s%s
static 
virtual 
kern_return_t
    %s(
        IORPC rpc%s
        
 %s%s
        OSDispatchMethod supermethod = NULL
)%s%s;
 const
 APPLE_KEXT_OVERRIDE
#define %s_Methods 
public:
    virtual kern_return_t
    Dispatch(const IORPC rpc) APPLE_KEXT_OVERRIDE;
    static kern_return_t
    _Dispatch(%s * self, const IORPC rpc);
protected:
    /* _Impl methods */
    %s_%s(%s_%s_Args)%s;
Call
Impl
protected:
    /* _Invoke methods */
    %skern_return_t
    %s_Invoke(const IORPC rpc,
        %s (*func)(%s_%s_Args));
        %s (%s::*func)(%s_%s_Args));
#define %s_KernelMethods 
protected:
    /* _Impl methods */
    %s_%s(%s_%s_Args);
#define %s_VirtualMethods 
/* iig(%s) generated from %s */
DriverKit-48
/* %s:%d-%d */
/* class %s %s:%d-%d */
EmitHeader
output: %s::%s (%s)
root
override
#define %s_%s_ID            0x%016qxULL
#define %s_%s_Args \
        const IORPC rpc%s
#if !KERNEL
extern OSMetaClass          * g%sMetaClass;
extern OSClassLoadInformation %s_Class;
class %sMetaClass : public OSMetaClass
public:
    New(OSObject * instance) override;
    Dispatch(const IORPC rpc) override;
#endif /* !KERNEL */
class %sInterface : public OSInterface
public:
    virtual %s
        
)%s = 0;
struct %s_IVars;
struct %s_LocalIVars;
class %s : public %s, public %sInterface
#if KERNEL
    OSDeclareDefaultStructorsWithDispatch(%s);
#endif /* KERNEL */
#if !KERNEL
    friend class %sMetaClass;
    union
        %s_IVars * ivars;
        %s_LocalIVars * lvars;
    virtual const OSMetaClass *
    getMetaClass() const APPLE_KEXT_OVERRIDE { return OSTypeID(%s); };
    using super = %s;
    %s_Methods
    %s_VirtualMethods
/* %s:%d- */
fprintpstrf
len < 256
"\%03o%s"
@iig end
/* %s */
/* @iig end */
#undef
IIG_IMPLEMENTATION
#define
IIG_IMPLEMENTATION 
#include <DriverKit/IOReturn.h>
#include <%s/%s.h>
#include "%s.h"
@iig implementation
OSMetaClass
extern OSMetaClass * g%sMetaClass;
#endif /* !KERNEL */
OSDefineMetaClassAndStructors(%s, %s);
#define %s_QueueNames  ""
    
i24@?0r^v8r^v16
#define %s%s_MethodNames  ""
MetaClass
struct OSClassDescription_%s_t
    OSClassDescription base;
    uint64_t           methodOptions[2 * %ld];
    uint64_t           metaMethodOptions[2 * %ld];
    char               queueNames[sizeof(%s_QueueNames)];
    char               methodNames[sizeof(%s_MethodNames)];
    char               metaMethodNames[sizeof(%sMetaClass_MethodNames)];
const struct OSClassDescription_%s_t
OSClassDescription_%s =
    .base =
        .descriptionSize         = sizeof(OSClassDescription_%s_t),
        .name                    = "%s",
        .superName               = "%s",
        .flags                   = %d*kOSClassCanRemote,
        .methodOptionsSize       = 2 * sizeof(uint64_t) * %ld,
        .metaMethodOptionsSize   = 2 * sizeof(uint64_t) * %ld,
        .queueNamesSize       = sizeof(%s_QueueNames),
        .methodNamesSize         = sizeof(%s_MethodNames),
        .metaMethodNamesSize     = sizeof(%sMetaClass_MethodNames),
        .methodOptionsOffset     = __builtin_offsetof(struct OSClassDescription_%s_t, methodOptions),
        .metaMethodOptionsOffset = __builtin_offsetof(struct OSClassDescription_%s_t, metaMethodOptions),
        .queueNamesOffset     = __builtin_offsetof(struct OSClassDescription_%s_t, queueNames),
        .methodNamesOffset       = __builtin_offsetof(struct OSClassDescription_%s_t, methodNames),
        .metaMethodNamesOffset   = __builtin_offsetof(struct OSClassDescription_%s_t, metaMethodNames),
    },
    .%sethodOptions =
metaM
    {
        0x%016qx,
        %s_%s_ID,
    },
    .queueNames      = %s_QueueNames,
    .methodNames     = %s_MethodNames,
    .metaMethodNames = %sMetaClass_MethodNames,
static kern_return_t
%s_New(OSMetaClass * instance);
OSClassLoadInformation
%s_Class = 
    .description       = &OSClassDescription_%s.base,
    .instanceSize      = sizeof(%s),
    .New               = &%s_New,
const void *
g%s_Declaration
__attribute__((visibility("hidden"),section("__DATA,__osclassinfo,regular,no_dead_strip")))
    = &%s_Class;
OSMetaClass * g%sMetaClass;
%s_New(OSMetaClass * instance)
    if (!new(instance) %sMetaClass) return (kIOReturnNoMemory);
    return (kIOReturnSuccess);
kern_return_t
%sMetaClass::New(OSObject * instance)
    return (kIOReturnUnderrun);
    if (!new(instance) %s) return (kIOReturnNoMemory);
kern_return_t
%s::Dispatch(const IORPC rpc)
    return _Dispatch(this, rpc);
kern_return_t
%s::MetaClass::Dispatch(const IORPC rpc)
#else /* KERNEL */
kern_return_t
%sMetaClass::Dispatch(const IORPC rpc)
kern_return_t
%s::_Dispatch(%s * self, const IORPC rpc)
    kern_return_t ret = kIOReturnUnsupported;
    IORPCMessage * msg = IORPCMessage(rpc.message);
    switch (msg->msgid)
        case %s_%s_ID:
            ret = %s%s%s%s_Invoke(rpc, &%s::%s_Impl);
self->
            ret = self->%s%s%s_Invoke(rpc, (%s (%s::*)(%s_%s_Args)) &%s::%s_Impl);
            break;
        default:
            ret = OSMetaClassBase::Dispatch(rpc);
            ret = self->OSMetaClassBase::Dispatch(rpc);
            ret = %s::_Dispatch(self, rpc);
    }
    return (ret);
%s::%s%s(
_Call
        OSDispatchMethod supermethod
    kern_return_t ret;
    struct %s_%s_Msg * msg = (typeof(msg)) rpc.reply;
        %s_%s_Msg msg;
        struct
        {
            %s_%s_Rpl rpl;
            mach_msg_max_trailer_t trailer;
        } rpl;
    } buf;
    struct %s_%s_Msg * msg = &buf.msg;
    struct %s_%s_Rpl * rpl = &buf.rpl.rpl;
    msg->mach.msgh.msgh_size = sizeof(*msg);
    msg->content.hdr.flags   = %d*kIORPCMessageOneway
                             | %d*kIORPCMessageLocalHost
                             | %d*kIORPCMessageOnqueue;
    msg->content.hdr.msgid   = %s_%s_ID;
    msg->content.hdr.object  = (OSObjectRef) OSTypeID(%s);
    msg->content.hdr.object = (OSObjectRef) %s;
this
    msg->content.hdr.objectRefs = %s_%s_Msg_ObjRefs;
    msg->mach.msgh_body.msgh_descriptor_count = %d;
    msg->mach.objects[%d].type = MACH_MSG_PORT_DESCRIPTOR;
    msg->mach.objects[%d].disposition = %s;
    msg->mach.objects[%d].name = %s;
    msg->content.%s = (OSObjectRef) %s;
    msg->content.%s = %s;
error: %s::%s oneway with results
char
    strlcpy(&msg->content.__%s[0], %s, sizeof(msg->content.__%s));
    bcopy(%s, &msg->content.__%s[0], %sCount * sizeof(msg->content.__%s[0]));
    ret = kIOReturnSuccess;
    IORPC rpc = { .message = &buf.msg.mach, .sendSize = sizeof(*msg), .reply = NULL, .replySize = 0 };
    IORPC rpc = { .message = &buf.msg.mach, .sendSize = sizeof(buf.msg), .reply = &buf.rpl.rpl.mach, .replySize = sizeof(buf.rpl) };
    ret = OSMTypeID(%s)->Invoke(rpc);
    ret = %s->Invoke(rpc);
    if (supermethod) ret = supermethod((OSObject *)this, rpc);
    else             ret = ((OSObject *)this)->Invoke(rpc);
    if (kIOReturnSuccess == ret)
    do {
        if (rpl->mach.msgh.msgh_size < 
(sizeof(IORPCMessageMach) + sizeof(IORPCMessage))) { ret = kIOReturnIPCError; { ret = kIOReturnIPCError; break; }; };
        if (rpl->mach.msgh_body.msgh_descriptor_count >= 1)
            if (rpl->mach.msgh.msgh_size < 
(sizeof(IORPCMessageMach) + sizeof(mach_msg_port_descriptor_t) + sizeof(IORPCMessage))) { ret = kIOReturnIPCError; break; };
        }
        else
            if (rpl->mach.msgh.msgh_size                  != sizeof(*rpl)) { ret = kIOReturnIPCError; break; };
            if (rpl->content.hdr.msgid                    != %s_%s_ID) { ret = kIOReturnIPCError; break; };
            if (rpl->mach.msgh_body.msgh_descriptor_count != %d) { ret = kIOReturnIPCError; break; };
            if (rpc.reply->objects[%d].type != MACH_MSG_PORT_DESCRIPTOR) { ret = kIOReturnIPCError; break; };
            if (rpc.reply->objects[%d].disposition != %s) { ret = kIOReturnIPCError; { ret = kIOReturnIPCError; break; }; };
            if (%s_%s_Rpl_ObjRefs   != rpl->content.hdr.objectRefs) { ret = kIOReturnIPCError; break; };
            ret = rpl->content._result;
    while (false);
        bcopy(&rpl->content.__%s[0], %s, rpl->content.%sCount * sizeof(rpl->content.__%s[0]));
        *%s = OSDynamicCast(%s, (OSObject *) rpl->content.%s);
        if (rpl->content.%s && !*%s) ret = kIOReturnBadArgument;
        *%s = rpl->mach.objects[%d].name;
        if (%s) *%s = rpl->content.%s;
        if (ret == kIOReturnSuccess) {
            IORPCMessage * message;
            OSObject     * object;
            message = IORPCMessage(rpc.reply);
            object  = (typeof(object)) message->object;
            if (!object || !(kIORPCMessageOneway & message->flags)) ret = kIOReturnIPCError;
            else
            {
                rpc.sendSize  = rpc.replySize;
                rpc.replySize = 0;
                rpc.reply     = NULL;
                ret = object->Invoke(rpc);
            }
    }
%s::%s_Invoke(const IORPC _rpc,
        %s (*func)(%s_%s_Args))
        %s (%s::*func)(%s_%s_Args))
    %s_%s_Invocation rpc = { _rpc };
    %s * %s;
    %s %s = (sizeof(rpc.reply->content.__%s) / sizeof(rpc.reply->content.__%s[0]));
    if (%s_%s_Msg_ObjRefs != rpc.message->content.hdr.objectRefs) return (kIOReturnIPCError);
    %s = OSDynamicCast(%s, (OSObject *) rpc.message->content.%s);
    if (!%s && rpc.message->content.%s) return (kIOReturnBadArgument);
    %s(%s*func)(
ret = 
this->
        %s%s
rpc.rpc,
        &rpc.message->content.__%s[0]
        &rpc.reply->content.__%s[0]
        %s
        rpc.message->objects[%d].name
        rpc.message->content.%s
        &%s
        (%s **)&rpc.reply->content.%s
        &rpc.reply->mach.objects[%d].name
        &rpc.reply->content.%s
        IORPCMessage * message;
        message = IORPCMessage(rpc.rpc.reply);
        if (!message->object || !(kIORPCMessageOneway & message->flags)) ret = kIOReturnIPCError;
    else
        rpc.reply->content.hdr.msgid   = %s_%s_ID;
        rpc.reply->content.hdr.object  = 0;
        rpc.reply->content.hdr.flags   = kIORPCMessageOneway;
        rpc.reply->mach.msgh.msgh_size = sizeof(*rpc.reply);
        rpc.reply->mach.msgh_body.msgh_descriptor_count = %d;
        rpc.reply->content._result     = ret;
        if (kIOReturnSuccess == ret)
            rpc.reply->content.hdr.objectRefs = %s_%s_Rpl_ObjRefs;
            rpc.reply->content.%s = %s;
            rpc.reply->mach.objects[%d].type = MACH_MSG_PORT_DESCRIPTOR;
            rpc.reply->mach.objects[%d].disposition = %s;
            rpc.reply->content.hdr.objectRefs = 0;
            for (uint32_t idx = 0; idx < %d; idx++)
                rpc.reply->mach.objects[idx].type        = MACH_MSG_PORT_DESCRIPTOR;
                rpc.reply->mach.objects[idx].disposition = MACH_MSG_TYPE_PORT_NONE;
                rpc.reply->mach.objects[idx].name        = MACH_PORT_NULL;
            rpc.reply->content.%s = (OSObjectRef) 0;
usage: %s --def <def input file> --header <header output file> --impl <implementation output file> [--log <log file>] [--framework-name <name>] -- <clang args>
header
impl
version
framework-name
h:i:s:
x86_64
-arch
-isysroot
iPhoneOS
WatchOS
BridgeOS
AppleTVOS
arm64
clang: %s
clang_createTranslationUnitFromSourceFile error
compile failed
visit:
construct:
emit:
