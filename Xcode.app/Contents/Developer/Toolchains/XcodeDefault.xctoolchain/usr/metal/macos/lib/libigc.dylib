%7$
% 7$
%"7$
%$7$
%&7$
%(7$
%*7$
%,7$
%.7$
%07$
%27$
%47$
%67$
%87$
%:7$
% 7$
%"7$
%$7$
%&7$
%(7$
%*7$
%,7$
%.7$
%07$
%27$
%47$
%67$
%87$
%:7$
%<7$
%>7$
%@7$
%B7$
%D7$
%F7$
%H7$
%J7$
%L7$
%N7$
%P7$
%R7$
%T7$
%V7$
%X7$
%Z7$
%\7$
%^7$
%`7$
%b7$
%d7$
%f7$
%h7$
%j7$
%l7$
%n7$
%p7$
%r7$
%t7$
%v7$
%x7$
%z7$
%|7$
%~7$
%8$
% 8$
%"8$
%$8$
%&8$
%(8$
%*8$
%,8$
%.8$
%08$
%28$
%48$
llvm.
aarch64
amdgcn
hexagon
mips
nvvm
r600
s390
xcore
null-pointer-is-valid
true
wasm
not_intrinsic
llvm.addressofreturnaddress
llvm.adjust.trampoline
llvm.annotation
llvm.assume
llvm.bitreverse
llvm.bswap
llvm.canonicalize
llvm.ceil
llvm.clear_cache
llvm.codeview.annotation
llvm.convert.from.fp16
llvm.convert.to.fp16
llvm.copysign
llvm.coro.alloc
llvm.coro.begin
llvm.coro.destroy
llvm.coro.done
llvm.coro.end
llvm.coro.frame
llvm.coro.free
llvm.coro.id
llvm.coro.noop
llvm.coro.param
llvm.coro.promise
llvm.coro.resume
llvm.coro.save
llvm.coro.size
llvm.coro.subfn.addr
llvm.coro.suspend
llvm.cos
llvm.ctlz
llvm.ctpop
llvm.cttz
llvm.dbg.addr
llvm.dbg.declare
llvm.dbg.label
llvm.dbg.value
llvm.debugtrap
llvm.donothing
llvm.eh.dwarf.cfa
llvm.eh.exceptioncode
llvm.eh.exceptionpointer
llvm.eh.return.i32
llvm.eh.return.i64
llvm.eh.sjlj.callsite
llvm.eh.sjlj.functioncontext
llvm.eh.sjlj.longjmp
llvm.eh.sjlj.lsda
llvm.eh.sjlj.setjmp
llvm.eh.sjlj.setup.dispatch
llvm.eh.typeid.for
llvm.eh.unwind.init
llvm.exp
llvm.exp2
llvm.expect
llvm.experimental.constrained.cos
llvm.experimental.constrained.exp
llvm.experimental.constrained.exp2
llvm.experimental.constrained.fadd
llvm.experimental.constrained.fdiv
llvm.experimental.constrained.fma
llvm.experimental.constrained.fmul
llvm.experimental.constrained.frem
llvm.experimental.constrained.fsub
llvm.experimental.constrained.log
llvm.experimental.constrained.log10
llvm.experimental.constrained.log2
llvm.experimental.constrained.nearbyint
llvm.experimental.constrained.pow
llvm.experimental.constrained.powi
llvm.experimental.constrained.rint
llvm.experimental.constrained.sin
llvm.experimental.constrained.sqrt
llvm.experimental.deoptimize
llvm.experimental.gc.relocate
llvm.experimental.gc.result
llvm.experimental.gc.statepoint
llvm.experimental.guard
llvm.experimental.patchpoint.i64
llvm.experimental.patchpoint.void
llvm.experimental.stackmap
llvm.experimental.vector.reduce.add
llvm.experimental.vector.reduce.and
llvm.experimental.vector.reduce.fadd
llvm.experimental.vector.reduce.fmax
llvm.experimental.vector.reduce.fmin
llvm.experimental.vector.reduce.fmul
llvm.experimental.vector.reduce.mul
llvm.experimental.vector.reduce.or
llvm.experimental.vector.reduce.smax
llvm.experimental.vector.reduce.smin
llvm.experimental.vector.reduce.umax
llvm.experimental.vector.reduce.umin
llvm.experimental.vector.reduce.xor
llvm.fabs
llvm.floor
llvm.flt.rounds
llvm.fma
llvm.fmuladd
llvm.frameaddress
llvm.fshl
llvm.fshr
llvm.gcread
llvm.gcroot
llvm.gcwrite
llvm.get.dynamic.area.offset
llvm.icall.branch.funnel
llvm.init.trampoline
llvm.instrprof.increment
llvm.instrprof.increment.step
llvm.instrprof.value.profile
llvm.invariant.end
llvm.invariant.start
llvm.launder.invariant.group
llvm.lifetime.end
llvm.lifetime.start
llvm.load.relative
llvm.localaddress
llvm.localescape
llvm.localrecover
llvm.log
llvm.log10
llvm.log2
llvm.longjmp
llvm.masked.compressstore
llvm.masked.expandload
llvm.masked.gather
llvm.masked.load
llvm.masked.scatter
llvm.masked.store
llvm.maxnum
llvm.memcpy
llvm.memcpy.element.unordered.atomic
llvm.memmove
llvm.memmove.element.unordered.atomic
llvm.memset
llvm.memset.element.unordered.atomic
llvm.minnum
llvm.nearbyint
llvm.objectsize
llvm.pcmarker
llvm.pow
llvm.powi
llvm.prefetch
llvm.ptr.annotation
llvm.read_register
llvm.readcyclecounter
llvm.returnaddress
llvm.rint
llvm.round
llvm.sadd.with.overflow
llvm.setjmp
llvm.sideeffect
llvm.siglongjmp
llvm.sigsetjmp
llvm.sin
llvm.smul.with.overflow
llvm.sqrt
llvm.ssa.copy
llvm.ssub.with.overflow
llvm.stackguard
llvm.stackprotector
llvm.stackrestore
llvm.stacksave
llvm.strip.invariant.group
llvm.thread.pointer
llvm.trap
llvm.trunc
llvm.type.checked.load
llvm.type.test
llvm.uadd.with.overflow
llvm.umul.with.overflow
llvm.usub.with.overflow
llvm.va_copy
llvm.va_end
llvm.va_start
llvm.var.annotation
llvm.write_register
llvm.xray.customevent
llvm.xray.typedevent
llvm.aarch64.clrex
llvm.aarch64.crc32b
llvm.aarch64.crc32cb
llvm.aarch64.crc32ch
llvm.aarch64.crc32cw
llvm.aarch64.crc32cx
llvm.aarch64.crc32h
llvm.aarch64.crc32w
llvm.aarch64.crc32x
llvm.aarch64.crypto.aesd
llvm.aarch64.crypto.aese
llvm.aarch64.crypto.aesimc
llvm.aarch64.crypto.aesmc
llvm.aarch64.crypto.sha1c
llvm.aarch64.crypto.sha1h
llvm.aarch64.crypto.sha1m
llvm.aarch64.crypto.sha1p
llvm.aarch64.crypto.sha1su0
llvm.aarch64.crypto.sha1su1
llvm.aarch64.crypto.sha256h
llvm.aarch64.crypto.sha256h2
llvm.aarch64.crypto.sha256su0
llvm.aarch64.crypto.sha256su1
llvm.aarch64.dmb
llvm.aarch64.dsb
llvm.aarch64.get.fpcr
llvm.aarch64.hint
llvm.aarch64.isb
llvm.aarch64.ldaxp
llvm.aarch64.ldaxr
llvm.aarch64.ldxp
llvm.aarch64.ldxr
llvm.aarch64.neon.abs
llvm.aarch64.neon.addhn
llvm.aarch64.neon.addp
llvm.aarch64.neon.cls
llvm.aarch64.neon.fabd
llvm.aarch64.neon.facge
llvm.aarch64.neon.facgt
llvm.aarch64.neon.faddv
llvm.aarch64.neon.fcvtas
llvm.aarch64.neon.fcvtau
llvm.aarch64.neon.fcvtms
llvm.aarch64.neon.fcvtmu
llvm.aarch64.neon.fcvtns
llvm.aarch64.neon.fcvtnu
llvm.aarch64.neon.fcvtps
llvm.aarch64.neon.fcvtpu
llvm.aarch64.neon.fcvtxn
llvm.aarch64.neon.fcvtzs
llvm.aarch64.neon.fcvtzu
llvm.aarch64.neon.fmax
llvm.aarch64.neon.fmaxnm
llvm.aarch64.neon.fmaxnmp
llvm.aarch64.neon.fmaxnmv
llvm.aarch64.neon.fmaxp
llvm.aarch64.neon.fmaxv
llvm.aarch64.neon.fmin
llvm.aarch64.neon.fminnm
llvm.aarch64.neon.fminnmp
llvm.aarch64.neon.fminnmv
llvm.aarch64.neon.fminp
llvm.aarch64.neon.fminv
llvm.aarch64.neon.fmulx
llvm.aarch64.neon.frecpe
llvm.aarch64.neon.frecps
llvm.aarch64.neon.frecpx
llvm.aarch64.neon.frintn
llvm.aarch64.neon.frsqrte
llvm.aarch64.neon.frsqrts
llvm.aarch64.neon.ld1x2
llvm.aarch64.neon.ld1x3
llvm.aarch64.neon.ld1x4
llvm.aarch64.neon.ld2
llvm.aarch64.neon.ld2lane
llvm.aarch64.neon.ld2r
llvm.aarch64.neon.ld3
llvm.aarch64.neon.ld3lane
llvm.aarch64.neon.ld3r
llvm.aarch64.neon.ld4
llvm.aarch64.neon.ld4lane
llvm.aarch64.neon.ld4r
llvm.aarch64.neon.pmul
llvm.aarch64.neon.pmull
llvm.aarch64.neon.pmull64
llvm.aarch64.neon.raddhn
llvm.aarch64.neon.rbit
llvm.aarch64.neon.rshrn
llvm.aarch64.neon.rsubhn
llvm.aarch64.neon.sabd
llvm.aarch64.neon.saddlp
llvm.aarch64.neon.saddlv
llvm.aarch64.neon.saddv
llvm.aarch64.neon.scalar.sqxtn
llvm.aarch64.neon.scalar.sqxtun
llvm.aarch64.neon.scalar.uqxtn
llvm.aarch64.neon.sdot
llvm.aarch64.neon.shadd
llvm.aarch64.neon.shll
llvm.aarch64.neon.shsub
llvm.aarch64.neon.smax
llvm.aarch64.neon.smaxp
llvm.aarch64.neon.smaxv
llvm.aarch64.neon.smin
llvm.aarch64.neon.sminp
llvm.aarch64.neon.sminv
llvm.aarch64.neon.smull
llvm.aarch64.neon.sqabs
llvm.aarch64.neon.sqadd
llvm.aarch64.neon.sqdmulh
llvm.aarch64.neon.sqdmull
llvm.aarch64.neon.sqdmulls.scalar
llvm.aarch64.neon.sqneg
llvm.aarch64.neon.sqrdmulh
llvm.aarch64.neon.sqrshl
llvm.aarch64.neon.sqrshrn
llvm.aarch64.neon.sqrshrun
llvm.aarch64.neon.sqshl
llvm.aarch64.neon.sqshlu
llvm.aarch64.neon.sqshrn
llvm.aarch64.neon.sqshrun
llvm.aarch64.neon.sqsub
llvm.aarch64.neon.sqxtn
llvm.aarch64.neon.sqxtun
llvm.aarch64.neon.srhadd
llvm.aarch64.neon.srshl
llvm.aarch64.neon.sshl
llvm.aarch64.neon.sshll
llvm.aarch64.neon.st1x2
llvm.aarch64.neon.st1x3
llvm.aarch64.neon.st1x4
llvm.aarch64.neon.st2
llvm.aarch64.neon.st2lane
llvm.aarch64.neon.st3
llvm.aarch64.neon.st3lane
llvm.aarch64.neon.st4
llvm.aarch64.neon.st4lane
llvm.aarch64.neon.subhn
llvm.aarch64.neon.suqadd
llvm.aarch64.neon.tbl1
llvm.aarch64.neon.tbl2
llvm.aarch64.neon.tbl3
llvm.aarch64.neon.tbl4
llvm.aarch64.neon.tbx1
llvm.aarch64.neon.tbx2
llvm.aarch64.neon.tbx3
llvm.aarch64.neon.tbx4
llvm.aarch64.neon.uabd
llvm.aarch64.neon.uaddlp
llvm.aarch64.neon.uaddlv
llvm.aarch64.neon.uaddv
llvm.aarch64.neon.udot
llvm.aarch64.neon.uhadd
AirMsaaSamplePattern
llvm.aarch64.neon.uhsub
llvm.aarch64.neon.umax
llvm.aarch64.neon.umaxp
llvm.aarch64.neon.umaxv
llvm.aarch64.neon.umin
llvm.aarch64.neon.uminp
llvm.aarch64.neon.uminv
llvm.aarch64.neon.umull
llvm.aarch64.neon.uqadd
llvm.aarch64.neon.uqrshl
llvm.aarch64.neon.uqrshrn
llvm.aarch64.neon.uqshl
llvm.aarch64.neon.uqshrn
llvm.aarch64.neon.uqsub
llvm.aarch64.neon.uqxtn
llvm.aarch64.neon.urecpe
llvm.aarch64.neon.urhadd
llvm.aarch64.neon.urshl
llvm.aarch64.neon.ursqrte
llvm.aarch64.neon.ushl
llvm.aarch64.neon.ushll
llvm.aarch64.neon.usqadd
llvm.aarch64.neon.vcopy.lane
llvm.aarch64.neon.vcvtfp2fxs
llvm.aarch64.neon.vcvtfp2fxu
llvm.aarch64.neon.vcvtfp2hf
llvm.aarch64.neon.vcvtfxs2fp
llvm.aarch64.neon.vcvtfxu2fp
llvm.aarch64.neon.vcvthf2fp
llvm.aarch64.neon.vsli
llvm.aarch64.neon.vsri
llvm.aarch64.sdiv
llvm.aarch64.sisd.fabd
llvm.aarch64.sisd.fcvtxn
llvm.aarch64.stlxp
llvm.aarch64.stlxr
llvm.aarch64.stxp
llvm.aarch64.stxr
llvm.aarch64.udiv
llvm.amdgcn.alignbit
llvm.amdgcn.alignbyte
llvm.amdgcn.atomic.dec
llvm.amdgcn.atomic.inc
llvm.amdgcn.break
llvm.amdgcn.buffer.atomic.add
llvm.amdgcn.buffer.atomic.and
llvm.amdgcn.buffer.atomic.cmpswap
llvm.amdgcn.buffer.atomic.or
llvm.amdgcn.buffer.atomic.smax
llvm.amdgcn.buffer.atomic.smin
llvm.amdgcn.buffer.atomic.sub
llvm.amdgcn.buffer.atomic.swap
llvm.amdgcn.buffer.atomic.umax
llvm.amdgcn.buffer.atomic.umin
llvm.amdgcn.buffer.atomic.xor
llvm.amdgcn.buffer.load
llvm.amdgcn.buffer.load.format
llvm.amdgcn.buffer.store
llvm.amdgcn.buffer.store.format
llvm.amdgcn.buffer.wbinvl1
llvm.amdgcn.buffer.wbinvl1.sc
llvm.amdgcn.buffer.wbinvl1.vol
llvm.amdgcn.class
llvm.amdgcn.cos
llvm.amdgcn.cubeid
llvm.amdgcn.cubema
llvm.amdgcn.cubesc
llvm.amdgcn.cubetc
llvm.amdgcn.cvt.pk.i16
llvm.amdgcn.cvt.pk.u16
llvm.amdgcn.cvt.pk.u8.f32
llvm.amdgcn.cvt.pknorm.i16
llvm.amdgcn.cvt.pknorm.u16
llvm.amdgcn.cvt.pkrtz
llvm.amdgcn.dispatch.id
llvm.amdgcn.dispatch.ptr
llvm.amdgcn.div.fixup
llvm.amdgcn.div.fmas
llvm.amdgcn.div.scale
llvm.amdgcn.ds.bpermute
llvm.amdgcn.ds.fadd
llvm.amdgcn.ds.fmax
llvm.amdgcn.ds.fmin
llvm.amdgcn.ds.permute
llvm.amdgcn.ds.swizzle
llvm.amdgcn.else
llvm.amdgcn.else.break
llvm.amdgcn.end.cf
llvm.amdgcn.exp
llvm.amdgcn.exp.compr
llvm.amdgcn.fcmp
llvm.amdgcn.fdiv.fast
llvm.amdgcn.fdot2
llvm.amdgcn.fmad.ftz
llvm.amdgcn.fmed3
llvm.amdgcn.fmul.legacy
llvm.amdgcn.fract
llvm.amdgcn.frexp.exp
llvm.amdgcn.frexp.mant
llvm.amdgcn.groupstaticsize
llvm.amdgcn.icmp
llvm.amdgcn.if
llvm.amdgcn.if.break
llvm.amdgcn.image.atomic.add.1d
llvm.amdgcn.image.atomic.add.1darray
llvm.amdgcn.image.atomic.add.2d
llvm.amdgcn.image.atomic.add.2darray
llvm.amdgcn.image.atomic.add.2darraymsaa
llvm.amdgcn.image.atomic.add.2dmsaa
llvm.amdgcn.image.atomic.add.3d
llvm.amdgcn.image.atomic.add.cube
llvm.amdgcn.image.atomic.and.1d
llvm.amdgcn.image.atomic.and.1darray
llvm.amdgcn.image.atomic.and.2d
llvm.amdgcn.image.atomic.and.2darray
llvm.amdgcn.image.atomic.and.2darraymsaa
llvm.amdgcn.image.atomic.and.2dmsaa
llvm.amdgcn.image.atomic.and.3d
llvm.amdgcn.image.atomic.and.cube
llvm.amdgcn.image.atomic.cmpswap.1d
llvm.amdgcn.image.atomic.cmpswap.1darray
llvm.amdgcn.image.atomic.cmpswap.2d
llvm.amdgcn.image.atomic.cmpswap.2darray
llvm.amdgcn.image.atomic.cmpswap.2darraymsaa
llvm.amdgcn.image.atomic.cmpswap.2dmsaa
llvm.amdgcn.image.atomic.cmpswap.3d
llvm.amdgcn.image.atomic.cmpswap.cube
llvm.amdgcn.image.atomic.dec.1d
llvm.amdgcn.image.atomic.dec.1darray
llvm.amdgcn.image.atomic.dec.2d
llvm.amdgcn.image.atomic.dec.2darray
llvm.amdgcn.image.atomic.dec.2darraymsaa
llvm.amdgcn.image.atomic.dec.2dmsaa
llvm.amdgcn.image.atomic.dec.3d
llvm.amdgcn.image.atomic.dec.cube
llvm.amdgcn.image.atomic.inc.1d
llvm.amdgcn.image.atomic.inc.1darray
llvm.amdgcn.image.atomic.inc.2d
llvm.amdgcn.image.atomic.inc.2darray
llvm.amdgcn.image.atomic.inc.2darraymsaa
llvm.amdgcn.image.atomic.inc.2dmsaa
llvm.amdgcn.image.atomic.inc.3d
llvm.amdgcn.image.atomic.inc.cube
llvm.amdgcn.image.atomic.or.1d
llvm.amdgcn.image.atomic.or.1darray
llvm.amdgcn.image.atomic.or.2d
llvm.amdgcn.image.atomic.or.2darray
llvm.amdgcn.image.atomic.or.2darraymsaa
llvm.amdgcn.image.atomic.or.2dmsaa
llvm.amdgcn.image.atomic.or.3d
llvm.amdgcn.image.atomic.or.cube
llvm.amdgcn.image.atomic.smax.1d
llvm.amdgcn.image.atomic.smax.1darray
llvm.amdgcn.image.atomic.smax.2d
llvm.amdgcn.image.atomic.smax.2darray
llvm.amdgcn.image.atomic.smax.2darraymsaa
llvm.amdgcn.image.atomic.smax.2dmsaa
llvm.amdgcn.image.atomic.smax.3d
llvm.amdgcn.image.atomic.smax.cube
llvm.amdgcn.image.atomic.smin.1d
llvm.amdgcn.image.atomic.smin.1darray
llvm.amdgcn.image.atomic.smin.2d
llvm.amdgcn.image.atomic.smin.2darray
llvm.amdgcn.image.atomic.smin.2darraymsaa
llvm.amdgcn.image.atomic.smin.2dmsaa
llvm.amdgcn.image.atomic.smin.3d
llvm.amdgcn.image.atomic.smin.cube
llvm.amdgcn.image.atomic.sub.1d
llvm.amdgcn.image.atomic.sub.1darray
llvm.amdgcn.image.atomic.sub.2d
llvm.amdgcn.image.atomic.sub.2darray
llvm.amdgcn.image.atomic.sub.2darraymsaa
llvm.amdgcn.image.atomic.sub.2dmsaa
llvm.amdgcn.image.atomic.sub.3d
llvm.amdgcn.image.atomic.sub.cube
llvm.amdgcn.image.atomic.swap.1d
float4x3
llvm.amdgcn.image.atomic.swap.1darray
llvm.amdgcn.image.atomic.swap.2d
llvm.amdgcn.image.atomic.swap.2darray
llvm.amdgcn.image.atomic.swap.2darraymsaa
llvm.amdgcn.image.atomic.swap.2dmsaa
llvm.amdgcn.image.atomic.swap.3d
llvm.amdgcn.image.atomic.swap.cube
llvm.amdgcn.image.atomic.umax.1d
llvm.amdgcn.image.atomic.umax.1darray
llvm.amdgcn.image.atomic.umax.2d
llvm.amdgcn.image.atomic.umax.2darray
llvm.amdgcn.image.atomic.umax.2darraymsaa
llvm.amdgcn.image.atomic.umax.2dmsaa
llvm.amdgcn.image.atomic.umax.3d
llvm.amdgcn.image.atomic.umax.cube
llvm.amdgcn.image.atomic.umin.1d
llvm.amdgcn.image.atomic.umin.1darray
llvm.amdgcn.image.atomic.umin.2d
llvm.amdgcn.image.atomic.umin.2darray
llvm.amdgcn.image.atomic.umin.2darraymsaa
llvm.amdgcn.image.atomic.umin.2dmsaa
llvm.amdgcn.image.atomic.umin.3d
llvm.amdgcn.image.atomic.umin.cube
llvm.amdgcn.image.atomic.xor.1d
llvm.amdgcn.image.atomic.xor.1darray
llvm.amdgcn.image.atomic.xor.2d
llvm.amdgcn.image.atomic.xor.2darray
llvm.amdgcn.image.atomic.xor.2darraymsaa
llvm.amdgcn.image.atomic.xor.2dmsaa
llvm.amdgcn.image.atomic.xor.3d
llvm.amdgcn.image.atomic.xor.cube
llvm.amdgcn.image.gather4.2d
llvm.amdgcn.image.gather4.2darray
llvm.amdgcn.image.gather4.b.2d
llvm.amdgcn.image.gather4.b.2darray
llvm.amdgcn.image.gather4.b.cl.2d
llvm.amdgcn.image.gather4.b.cl.2darray
llvm.amdgcn.image.gather4.b.cl.cube
llvm.amdgcn.image.gather4.b.cl.o.2d
llvm.amdgcn.image.gather4.b.cl.o.2darray
llvm.amdgcn.image.gather4.b.cl.o.cube
llvm.amdgcn.image.gather4.b.cube
llvm.amdgcn.image.gather4.b.o.2d
llvm.amdgcn.image.gather4.b.o.2darray
llvm.amdgcn.image.gather4.b.o.cube
llvm.amdgcn.image.gather4.c.2d
llvm.amdgcn.image.gather4.c.2darray
llvm.amdgcn.image.gather4.c.b.2d
llvm.amdgcn.image.gather4.c.b.2darray
llvm.amdgcn.image.gather4.c.b.cl.2d
llvm.amdgcn.image.gather4.c.b.cl.2darray
llvm.amdgcn.image.gather4.c.b.cl.cube
llvm.amdgcn.image.gather4.c.b.cl.o.2d
llvm.amdgcn.image.gather4.c.b.cl.o.2darray
llvm.amdgcn.image.gather4.c.b.cl.o.cube
llvm.amdgcn.image.gather4.c.b.cube
llvm.amdgcn.image.gather4.c.b.o.2d
llvm.amdgcn.image.gather4.c.b.o.2darray
llvm.amdgcn.image.gather4.c.b.o.cube
llvm.amdgcn.image.gather4.c.cl.2d
llvm.amdgcn.image.gather4.c.cl.2darray
llvm.amdgcn.image.gather4.c.cl.cube
llvm.amdgcn.image.gather4.c.cl.o.2d
llvm.amdgcn.image.gather4.c.cl.o.2darray
llvm.amdgcn.image.gather4.c.cl.o.cube
llvm.amdgcn.image.gather4.c.cube
llvm.amdgcn.image.gather4.c.l.2d
llvm.amdgcn.image.gather4.c.l.2darray
llvm.amdgcn.image.gather4.c.l.cube
llvm.amdgcn.image.gather4.c.l.o.2d
llvm.amdgcn.image.gather4.c.l.o.2darray
llvm.amdgcn.image.gather4.c.l.o.cube
llvm.amdgcn.image.gather4.c.lz.2d
llvm.amdgcn.image.gather4.c.lz.2darray
llvm.amdgcn.image.gather4.c.lz.cube
llvm.amdgcn.image.gather4.c.lz.o.2d
llvm.amdgcn.image.gather4.c.lz.o.2darray
llvm.amdgcn.image.gather4.c.lz.o.cube
llvm.amdgcn.image.gather4.c.o.2d
llvm.amdgcn.image.gather4.c.o.2darray
llvm.amdgcn.image.gather4.c.o.cube
llvm.amdgcn.image.gather4.cl.2d
llvm.amdgcn.image.gather4.cl.2darray
llvm.amdgcn.image.gather4.cl.cube
llvm.amdgcn.image.gather4.cl.o.2d
llvm.amdgcn.image.gather4.cl.o.2darray
llvm.amdgcn.image.gather4.cl.o.cube
llvm.amdgcn.image.gather4.cube
llvm.amdgcn.image.gather4.l.2d
air-raster-order-groups
llvm.amdgcn.image.gather4.l.2darray
llvm.amdgcn.image.gather4.l.cube
llvm.amdgcn.image.gather4.l.o.2d
llvm.amdgcn.image.gather4.l.o.2darray
llvm.amdgcn.image.gather4.l.o.cube
llvm.amdgcn.image.gather4.lz.2d
llvm.amdgcn.image.gather4.lz.2darray
llvm.amdgcn.image.gather4.lz.cube
llvm.amdgcn.image.gather4.lz.o.2d
llvm.amdgcn.image.gather4.lz.o.2darray
llvm.amdgcn.image.gather4.lz.o.cube
llvm.amdgcn.image.gather4.o.2d
llvm.amdgcn.image.gather4.o.2darray
llvm.amdgcn.image.gather4.o.cube
llvm.amdgcn.image.getlod.1d
llvm.amdgcn.image.getlod.1darray
llvm.amdgcn.image.getlod.2d
llvm.amdgcn.image.getlod.2darray
llvm.amdgcn.image.getlod.3d
llvm.amdgcn.image.getlod.cube
llvm.amdgcn.image.getresinfo.1d
llvm.amdgcn.image.getresinfo.1darray
llvm.amdgcn.image.getresinfo.2d
llvm.amdgcn.image.getresinfo.2darray
llvm.amdgcn.image.getresinfo.2darraymsaa
llvm.amdgcn.image.getresinfo.2dmsaa
llvm.amdgcn.image.getresinfo.3d
llvm.amdgcn.image.getresinfo.cube
llvm.amdgcn.image.load.1d
llvm.amdgcn.image.load.1darray
llvm.amdgcn.image.load.2d
llvm.amdgcn.image.load.2darray
llvm.amdgcn.image.load.2darraymsaa
llvm.amdgcn.image.load.2dmsaa
llvm.amdgcn.image.load.3d
llvm.amdgcn.image.load.cube
llvm.amdgcn.image.load.mip.1d
llvm.amdgcn.image.load.mip.1darray
llvm.amdgcn.image.load.mip.2d
llvm.amdgcn.image.load.mip.2darray
llvm.amdgcn.image.load.mip.3d
llvm.amdgcn.image.load.mip.cube
llvm.amdgcn.image.sample.1d
llvm.amdgcn.image.sample.1darray
llvm.amdgcn.image.sample.2d
air.dispatch_quadgroups_per_threadgroup
llvm.amdgcn.image.sample.2darray
llvm.amdgcn.image.sample.3d
llvm.amdgcn.image.sample.b.1d
llvm.amdgcn.image.sample.b.1darray
llvm.amdgcn.image.sample.b.2d
llvm.amdgcn.image.sample.b.2darray
llvm.amdgcn.image.sample.b.3d
llvm.amdgcn.image.sample.b.cl.1d
llvm.amdgcn.image.sample.b.cl.1darray
llvm.amdgcn.image.sample.b.cl.2d
llvm.amdgcn.image.sample.b.cl.2darray
llvm.amdgcn.image.sample.b.cl.3d
llvm.amdgcn.image.sample.b.cl.cube
llvm.amdgcn.image.sample.b.cl.o.1d
llvm.amdgcn.image.sample.b.cl.o.1darray
llvm.amdgcn.image.sample.b.cl.o.2d
llvm.amdgcn.image.sample.b.cl.o.2darray
llvm.amdgcn.image.sample.b.cl.o.3d
llvm.amdgcn.image.sample.b.cl.o.cube
llvm.amdgcn.image.sample.b.cube
llvm.amdgcn.image.sample.b.o.1d
llvm.amdgcn.image.sample.b.o.1darray
llvm.amdgcn.image.sample.b.o.2d
Translate AIR
llvm.amdgcn.image.sample.b.o.2darray
llvm.amdgcn.image.sample.b.o.3d
llvm.amdgcn.image.sample.b.o.cube
llvm.amdgcn.image.sample.c.1d
llvm.amdgcn.image.sample.c.1darray
llvm.amdgcn.image.sample.c.2d
llvm.amdgcn.image.sample.c.2darray
llvm.amdgcn.image.sample.c.3d
llvm.amdgcn.image.sample.c.b.1d
llvm.amdgcn.image.sample.c.b.1darray
llvm.amdgcn.image.sample.c.b.2d
llvm.amdgcn.image.sample.c.b.2darray
Custom Pass Optimization
llvm.amdgcn.image.sample.c.b.3d
llvm.amdgcn.image.sample.c.b.cl.1d
llvm.amdgcn.image.sample.c.b.cl.1darray
llvm.amdgcn.image.sample.c.b.cl.2d
llvm.amdgcn.image.sample.c.b.cl.2darray
llvm.amdgcn.image.sample.c.b.cl.3d
Indirect ICB Propagaion
llvm.amdgcn.image.sample.c.b.cl.cube
llvm.amdgcn.image.sample.c.b.cl.o.1d
llvm.amdgcn.image.sample.c.b.cl.o.1darray
llvm.amdgcn.image.sample.c.b.cl.o.2d
GenStrengthReduction
llvm.amdgcn.image.sample.c.b.cl.o.2darray
llvm.amdgcn.image.sample.c.b.cl.o.3d
flattenSmallSwitch
llvm.amdgcn.image.sample.c.b.cl.o.cube
llvm.amdgcn.image.sample.c.b.cube
if.then
llvm.amdgcn.image.sample.c.b.o.1d
if.end
llvm.amdgcn.image.sample.c.b.o.1darray
const-prop with shader-const replacement
llvm.amdgcn.image.sample.c.b.o.2d
igc-custom-unsafe-opt-pass
llvm.amdgcn.image.sample.c.b.o.2darray
igc-hoist-fmul-in-loop-pass
llvm.amdgcn.image.sample.c.b.o.3d
EarlyOutPatterns
llvm.amdgcn.image.sample.c.b.o.cube
.seg1
llvm.amdgcn.image.sample.c.cd.1d
.seg3
llvm.amdgcn.image.sample.c.cd.1darray
igc-custom-loop-opt
llvm.amdgcn.image.sample.c.cd.2d
igc-loop-canonicalization
llvm.amdgcn.image.sample.c.cd.2darray
llvm.amdgcn.image.sample.c.cd.3d
Custom Loop Versioning
llvm.amdgcn.image.sample.c.cd.cl.1d
BlendToDiscard
llvm.amdgcn.image.sample.c.cd.cl.1darray
igc-promote-resources-to-direct-addrspace
llvm.amdgcn.image.sample.c.cd.cl.2d
Pass promotes stateless accesses to bindless accesses
llvm.amdgcn.image.sample.c.cd.cl.2darray
PromoteStatelessToBindless
llvm.amdgcn.image.sample.c.cd.cl.3d
copysignf
llvm.amdgcn.image.sample.c.cd.cl.cube
fabs
llvm.amdgcn.image.sample.c.cd.cl.o.1d
fabsl
__builtin_IB_simd_media_block_write_4_h
overdefined
ntohs
expected ')' in parentheses expression
MCDwarfFragment
 PaddingPoliciesMask:
 Sym:
, addrspace(
addc
IntToPtr2
spp-split-backedge
llvm.hexagon.C4.fastcorner9
20ocl_image2d_array
__atomic_fetch_nand_16
unexpected token in variant, expected ')'
expected @code
unexpected token in '.ifb' directive
image2d_depth
, ...
none
OL, 
Can't find src file
mach
All llvm.experimental.deoptimize declarations must have the same calling convention
Allocation failed
<ST>
 data registers written
negative file number
llvm.amdgcn.writelane
llvm.bpf.pseudo
llvm.hexagon.C4.cmpneqi
ntohl
__sync_fetch_and_min_8
__atomic_fetch_nand_1
unexpected token in '.cv_linetable' directive
invalid variant on expression '
invalid SIMD width
 in '.build_version' directive
scev-mulops-inline-threshold
Threshold for inlining multiplication operands into a SCEV
rel32@hi
 Signed:
] unwind 
fill
page= "80.5, 110";
//.arg_
EL, 
%s_%s
Function Pass Manager
storing unsized types is not allowed
DICompileUnit not listed in llvm.dbg.cu
A No-Op Barrier Pass
!DIModule(
DW_LANG_UPC
DW_CC_nocall
 registers read back
spp-all-backedges
src1: immediate supported here on ternary instruction.
llvm.amdgcn.image.sample.d.cl.o.1darray
llvm.amdgcn.wqm.vote
llvm.arm.neon.vqsubu
llvm.bpf.load.word
llvm.hexagon.A2.vmaxw
llvm.hexagon.C4.cmpneq
", "
__fixunsxfdi
__llvm_memmove_element_unordered_atomic_16
__sync_fetch_and_umax_16
__atomic_fetch_xor_2
highest
.cfi_restore_state
 not currently supported for this target
Could not find incbin file '
line number less than zero in '.cv_loc' directive
unexpected symbol modifier following '@'
INVM
you must specify an offset on the stack
__literal16
overriding previous version directive
invalid group name
' begins
got@tlsgd@l
TYPEINDEX
 LineDelta:
USAGE: -HWThreadNumberPerEU <num>
Mismatched bundle_lock/unlock directives
malloc_ret_null
!DILexicalBlockFile(
          cleanup
spill
FESPSize
__AUTO_GENERATED_DUMMY_LAST_BB
//id
byte_offset
byte_size
kind
implicit_kind
expected comma in binary constantexpr
UNKNOWN_RA
air.patch_id
csel
rndz
<Invalid operator> 
BasicBlockPass Manager
invalid thrown type
Enclosing function does not use GC.
Stored value type does not match pointer operand type!
!dbg attachment of global variable must be a DIGlobalVariableExpression
invalid value for llvm.ident metadata entry operand(the operand should be a string)
.section
__sqrt_finite
 [null]
DW_AT_BORLAND_Delphi_metaclass
DW_OP_reg29
DW_LANG_PLI
DW_CC_program
SIMD8
 of high SIMD8
 address registers written
Src2TernaryImm
Illegal
toascii
calloc
Align1 not available on this platform
invalid instruction option
llvm.amdgcn.image.sample.c.lz.2darray
llvm.amdgcn.image.sample.d.cl.o.1d
llvm.amdgcn.kill
llvm.amdgcn.wqm
llvm.arm.neon.vcvtms
llvm.arm.neon.vqsubs
llvm.arm.smlatb
llvm.bpf.load.half
llvm.hexagon.A2.subh.l16.hl
llvm.hexagon.A2.vmaxuw
llvm.hexagon.A4.vcmpbgt
llvm.hexagon.C4.cmplteui
nearbyintl
__subdf3
__truncdfsf2
__fixunsdfsi
__nedf2
__llvm_memmove_element_unordered_atomic_1
__sync_fetch_and_or_1
__sync_fetch_and_umax_1
__atomic_fetch_sub_1
__atomic_fetch_or_4
single quote way too long
.weak_reference
.end
.cfi_rel_offset
.dcb.d
' not defined
unexpected token in directive
Could not find include file '
line number less than zero in '.loc' directive
unexpected token in '.cv_inline_site_id' directive
.warning argument must be a string
while in macro instantiation
Join
invalid '.rva' directive offset, can't be less than -2147483648 or greater than 2147483647
vfloorf
.watchos_version_min
.previous without corresponding .section
__constructor
invalid OS update specifier, comma expected
__precompiled_convert_f64_to_f16
expected '%<type>' or "<type>"
vISA_3DOption
fdiv
.globl
filechecksums_end
tlscall
got@dtprel@l
LDPLT
       
__svml_log2
__debug_cu_index
.rodata.cst16
setMessagePhaseXV@
igc-error-check
disable-nounwind-inference
isnull
typedwrite@
inteldialect 
!DIDerivedType(
 volatile
__builtin_IB_atomic_max_global_u32
xyzw
pseudo_kill
Scope
afterRemoveRedundantLabels
LABEL__EMPTYBB
%s.%03d.%s.dot
size = "80.0, 
black
 -> 
//.GRF count 
//.kernel_reordering_info_start
// -- GOOD: 
icmp requires pointer or integer operands
GRAPH_COLORING_FF_BC_RA
GRAPH_COLORING_SPILL_FF_RA
__builtin_IB_get_event_pool
NoDDChk
NoPreempt
smov
bfi2
GenSpecificPattern
cleanuppad
malloccall
BasicBlock Pass Manager
 (has loop)
'allocsize' 
invalid thrown types list
ptrtoint not supported for non-integral pointers
llvm.gcroot parameter #1 must either be a pointer alloca, or argument #2 must be a non-null constant.
gc.statepoint must read and write all memory to preserve reordering restrictions required by safepoint semantics
Store operand must be a pointer.
PtrToInt type mismatch
members of llvm.used must be named
incorrect number of operands in llvm.ident metadata
generic
Pass promotes indirect addrspace resource access to direct addrspace
__memcpy_chk
  %7.4f (%5.1f%%)
semicolon
tilde
-darwin
vaErode@
DW_AT_data_member_location
DW_AT_rvalue_reference
DW_AT_BORLAND_Delphi_record
DW_OP_lt
DW_OP_reg28
DW_OP_LLVM_fragment
DW_LANG_Fortran90
DW_CC_normal
MT1A_UF4x2
SIMD16
DWord
.hi8ds
sample max
must have 0xFF or 0xFD BTI
signed-integer min
sampler 
invalid region width on src1
Src2HorzStride
FlagModifier
SG3(0x
break
illegal
enable-store-refinement
uglygep
fputs
simdLaneId
unconvertible ternary align16 operand
expected address register subregister
expected }
llvm.amdgcn.image.sample.c.d.cl.2d
llvm.amdgcn.image.sample.c.lz.2d
llvm.amdgcn.image.sample.cd.cube
llvm.amdgcn.image.sample.d.cl.cube
llvm.amdgcn.image.sample.lz.o.2d
llvm.amdgcn.kernarg.segment.ptr
llvm.amdgcn.s.sendmsg
llvm.amdgcn.workitem.id.z
llvm.arm.mrrc2
llvm.arm.neon.vcvthf2fp
llvm.arm.neon.vmulp
llvm.arm.neon.vqshiftu
llvm.arm.neon.vtbl2
llvm.arm.smlaldx
llvm.arm.sxtab16
llvm.bpf.load.byte
llvm.hexagon.A2.combinew
llvm.hexagon.A2.subh.h16.sat.ll
llvm.hexagon.A2.vaddhs
llvm.hexagon.A2.vmaxuh
llvm.hexagon.A4.bitspliti
llvm.hexagon.A4.vcmpbeqi
llvm.hexagon.C2.cmpgt
llvm.hexagon.C4.cmplteu
right-square-bracket
__multi3
__modsi3
__addxf3
fmal
__gnu_f2h_ieee
__fixxfti
__gcc_qtou
__floatunsixf
__eqdf2
__gtdf2
__llvm_memcpy_element_unordered_atomic_2
__sync_lock_test_and_set_16
__sync_fetch_and_and_2
__sync_fetch_and_max_2
7027
__atomic_exchange_1
__atomic_fetch_add_2
__atomic_fetch_and_8
.simd8
invalid decimal number
.long
.org
.symbol_resolver
.ifge
.ifndef
.cv_filechecksumoffset
.cfi_def_cfa_offset
.err
.dc.w
unmatched .ifs or .elses
 // 
expected '=' after formal parameter identifier
 in '
expected identifier in directive
.abort '
invalid bundle alignment size (expected between 0 and 30)
unexpected token in '.line' directive
expected function id within range [0, UINT_MAX)
The Illegal Opcode Exception Enable flag in cr0.1 is normally set so the normal processing of an illegal opcode is to transfer control to the System Routine.
Instruction dispatch treats any unused 8-bit opcode (including bit 7 of the instruction, reserved for future opcode expansion) as if it is the illegal opcode.
The illegal opcode is zero because that byte value is more likely than most to be read via a wayward instruction pointer.
The illegal instruction is an instruction only in the same way that a NULL pointer in software is a pointer. Both are special values indicating invalid instances.
Format:
illegal
missing parameter qualifier for '
.err encountered
 * $$
xmmword ptr 
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive prior to entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving the else instruction will be redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by  <JIP>. The jump target should be the matching endif instruction for that conditional block.
The following table describes the 32-bit <JIP>. In GEN binary, <JIP> is at location <src1> and must be of type D (signed dword integer). <JIP> must be an immediate operand, it is a signed 32-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
If the <branch_ctrl> bit is set, then the <JIP> points to the first join instruction within the else block and <UIP> points to the endif instruction. If the <branch_ctrl> bit is not set,  <JIP> and <UIP>, both point to endif.
Format:
else (exec_size) JIP  UIP  branch_ctrl
An else instruction must not be followed by any instruction requiring register indirect access on source operands
If all channels are redirected (by else or before else), relative jump is performed to the location specified by <JIP> + 1.
.seh_endchained
unknown flag
invalid '.secrel32' directive offset, can't be less than zero or greater than std::numeric_limits<uint32_t>::max()
llvm.genx.GenISA.WaveBallot
.literal8
.objc_meta_class
.tdata
unexpected token in '.dump' or '.load' directive
" is deprecated
expected region type after '.data_region' directive
.u2f.outer.true.branch
__protocol
invalid OS major version number
 used while targeting 
Mergeable section must specify the type
unknown section type
.u2f.inner.true.branch
vISA_DumpCompilerStats
dp4a_ss@
Label: 
.byte
ScalarizeFunction
undefined .align directive, value size '
checksum_offset
Allocation failed
GOTREL
TLSLD
got@l
dtprel@ha
got@tprel@l
GPREL
igc-fix-dead-visible-functions
MCDummyFragment
 MaxBytesToEmit:
DW_AT_MIPS_ptr_dopetype
General options
__debug_gnu_pubn
__debug_rnglists
sampleCptr@
sampleDCptr@
setMessagePhase@
setMessagePhaseX@
sec_end
.subsection
Try to propagate nonnull argument attributes from callsites to caller functions.
slice_id@
notinit
sub_pair@
threadgroupbarrier_wait@
typedread@
protected 
avr_signalcc 
!DIGlobalVariableExpression(
-%%%%%%.
tail 
__builtin_IB_atomic_min_local_f32
swifterror 
fill
 out of 
% instructions of this kernel are compacted.
mem_fence
args: (
test
FullDebug
Illegal or unimplemented ISA opcode 
x86_fp80
domtree
be_fp
L_AUTO_f
beforeRemoveRedundantLabels
afterProcessGoto
LABEL__EMPTYBB__
%s.%03d.%s.dump
Succs: 
// Setup
cannot load symbol cmc_load_and_compile
<TR><TD ALIGN="CENTER">
    <TABLE BORDER="0" CELLBORDER="0" CELLSPACING="0">
    </TABLE>
    </TABLE>>];
//.CISA version 
//.RA type
//.spill flag load 
stageInGridOrigin
// Text representation might not be correct
// Bank Conflict Statistics: 
// --   OK: 
expected ')' in compare constantexpr
expected two operands to extractelement
LOCAL_FIRST_FIT_RA
GRAPH_COLORING_RR_BC_RA
GRAPH_COLORING_SPILL_FF_BC_RA
GRAPH_COLORING_SPILL_RR_RA
air.position_in_patch
Atomic
AccWrEn
NoSrcDepSet
movi
bfi1
Pass walks through sampler uses and detects sampler to texture mappings, and converts Sample to SampleL instructions.
CodeGenContext Wrapper
Flatten Small Switch
.backedge
inttoptr
landingpad
mallocsize
remark
' on Loop '
... Pass execution timing report ...
External
Function arguments must have first-class types!
' does not apply to function returns
' does not apply to functions!
invalid reference flags
subprogram declarations must not have a compile unit
Instruction has a name, but provides a void value!
inttoptr not supported for non-integral pointers
inalloca isn't on the last argument!
llvm.gcroot parameter #2 must be a constant.
gc.relocate: vector relocates to vector and pointer to pointer
 label and !dbg attachment
CatchSwitchInst handlers must be catchpads
atomic memory access' operand must have a power-of-two size
zext source and destination must both be a vector or neither
PtrToInt result must be integral
cannot guarantee tail call due to mismatched varargs
invalid llvm.used member
llvm.ident
Must specify at least 
Optimized build
igcinstcombine
__logl_finite
llvm.genx.GenISA.GradientX
        -----     
android
Optimizer
IO failure on output stream: 
colon
right-curly-bracket
prescott
goldmont-plus
__builtin_IB_atomic_min_local_i32
DW_TAG_shared_type
DW_AT_bit_offset
DW_AT_count
DW_AT_call_file
DW_AT_reference
DW_AT_MIPS_stride_elem
DW_AT_BORLAND_Delphi_class
DW_OP_const4s
DW_OP_le
DW_OP_lit29
DW_OP_reg27
DW_OP_breg29
DW_OP_GNU_const_index
DW_LANG_Fortran77
DW_LANG_Java
DW_LANG_BORLAND_Delphi
R_WEBASSEMBLY_SECTION_OFFSET_I32
MT1A_A64_UI
MT0W_US
A64 Untyped Atomic Integer Operation SIMD4x2
off (return immediately)
OWord
7040
media block 
urb dword read
 of low SIMD8
SIMD[1:0]
sample_max
Xlen
bti[
 (unknown float op)
atomic_smin
.bti[
__builtin_IB_atomic_cmpxchg_local_f16
ThreadCtrl
invalid region vertical stride on src1
Src2RegFile
CMaskUW(0x
sg8h
Addition
The brd instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if any channels are branched away.
In GEN binary, JIP is at location src1 when immediate and at location src0 when reg32, where reg32 is accessed as a scalar DWord. The ip register must be used (for example, by the assembler) as dst.
Format:
[(pred)] brd (exec_size) JIP
The dp4 instruction performs a four-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
Format:
[(pred)] dp4[.cmod] (exec_size) dst src0 src1
An if instruction starts an if/endif or an if/else/endif block of code. It restricts execution within the conditional block to only those channels that were enabled via the predicate control.
Each if instruction must have a matching endif instruction and may have up to one matching else instruction before the matching endif.
If all channels are inactive (for the if/endif or if/else/endif block), a jump is performed to the instruction referenced by JIP. This jump must be to right after the matching else instruction when present, or otherwise to the matching endif instruction of the conditional block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] if (exec_size) JIP UIP
missing required field 'scope'
__constant
Verify this pass produces no dead code
globalSizeUnavaliable
putchar
air.get_dispatch_quadgroups_per_threadgroup
Loop-Closed SSA Form Pass
swizzle W could not be retrieved
src%d: converting Align16 to Align1 (bits will re-assemble to Align1)
Q2 is obsolete; use M8 in execution offset: e.g. op (8|M8) ...
expected .
invalid region vertical stride
 must be an immediate label
out of dynamic memory in yyensure_buffer_stack()
instruction option
llvm.amdgcn.image.sample.c.cl.3d
llvm.amdgcn.image.sample.c.d.cl.1darray
llvm.amdgcn.image.sample.c.d.o.cube
llvm.amdgcn.image.sample.c.lz.1darray
llvm.amdgcn.image.sample.cd.1darray
llvm.amdgcn.image.sample.cd.cl.o.cube
llvm.amdgcn.image.sample.cl.o.2darray
llvm.amdgcn.image.sample.d.cl.3d
llvm.amdgcn.image.sample.l.3d
llvm.amdgcn.image.sample.lz.o.1darray
llvm.amdgcn.image.store.3d
llvm.amdgcn.interp.p2
llvm.amdgcn.readfirstlane
llvm.amdgcn.s.memtime
llvm.amdgcn.trig.preop
llvm.amdgcn.workitem.id.y
llvm.arm.isb
llvm.arm.mrrc
llvm.arm.neon.udot
llvm.arm.neon.vcvtfxu2fp
llvm.arm.neon.vld2lane
llvm.arm.neon.vmullu
llvm.arm.neon.vqmovnsu
llvm.arm.neon.vqshiftsu
llvm.arm.neon.vrsqrts
llvm.arm.neon.vtbl1
llvm.arm.sadd8
llvm.arm.smlald
llvm.arm.smusd
llvm.arm.strexd
llvm.arm.uqsub16
llvm.arm.vcvtru
llvm.hexagon.A2.addh.l16.sat.ll
llvm.hexagon.A2.combineii
llvm.hexagon.A2.orp
llvm.hexagon.A2.subh.h16.sat.lh
llvm.hexagon.A2.swiz
llvm.hexagon.A2.vaddh
llvm.hexagon.A2.vavgwcr
llvm.hexagon.A2.vmaxub
llvm.hexagon.A2.vrsadub.acc
llvm.hexagon.A4.bitsplit
llvm.hexagon.A4.cround.ri
llvm.hexagon.A4.vcmpbeq.any
llvm.hexagon.A4.vrminw
llvm.hexagon.C2.cmpgeui
llvm.hexagon.C2.pxfer.map
llvm.hexagon.C4.cmpltei
nearbyintf
__ashlhi3
__ashrhi3
__mulqi3
__divti3
__udivdi3
__negsi2
INTEL_PATCH_PRIVATE_MEMORY_SIZE
__gcc_qmul
__divtf3
__extenddftf2
EmitPass
__fixsfsi
__fixdfdi
Workaround pass used to fix functionality of special cases
V = 
__floatdixf
__floattixf
__floatuntidf
I = 
__ltdf2
__ledf2
__unorddf2
.shl.outer.merge.lo
__sync_val_compare_and_swap_2
__sync_lock_test_and_set_1
__sync_fetch_and_sub_4
.shl.outer.merge.hi
__sync_fetch_and_xor_8
__sync_fetch_and_nand_4
invalid BTI for fence (must be 0x0 or 0xFE)
.shl.outer.true.branch
__atomic_load_16
__atomic_store_4
__atomic_compare_exchange_4
.shl.merge.inner.lo
__atomic_fetch_sub_16
DataSize
.simd16
ReturnFormat
sample compare+LOD bias
.equiv
.byte
.align
.balignl
.globl
.shl.inner.false.branch
.irp
.bundle_lock
.ifeqs
.lshr.outer.merge.lo
.cv_func_id
.cv_inline_site_id
.cfi_sections
.lshr.outer.merge.hi
.cfi_window_save
.exitm
.dc.b
.lshr.outer.true.branch
.ds.l
.ds.x
on <h> region w must be Region::WI_INVALID
.lshr.merge.inner.lo
unexpected token in '.endif' directive
 Use -asm-macro-max-nesting-depth to increase this limit.
unexpected token in macro instantiation
.lshr.merge.inner.hi
 in '.org' directive
'.fill' directive pattern has been truncated to 32-bits
invalid '.comm' or '.lcomm' directive alignment, can't be less than zero
.lshr.inner.true.branch
expected comma in '.irp' directive
unexpected token in '.irpc' directive
MD5 checksum specified, but no file number
.lshr.inner.false.branch
expected file number in '.cv_file' directive
file number already allocated
halt
.ashr.outer.merge.lo
 in '.cfi_startproc' directive
Vararg parameter '
expected identifier in '.purgem' directive
.ashr.outer.merge.hi
unknown relocation name
expected identifier in '.addrsig_sym' directive
word ptr 
.ashr.outer.true.branch
expected symbol variant after '@'
expected '(' after operator
.symidx
.rva
.seh_pushframe
expected string in directive
same_contents
.ashr.merge.inner.hi
llvm.fabs.f32
.tbss
.destructor
.lazy_symbol_pointer
.objc_class
.objc_cls_refs
.picsymbol_stub
.ashr.inner.false.branch
expected identifier in .indirect_symbol directive
unexpected token in '.lsym' directive
__const
.u2f.outer.merge
invalid '.tbss' alignment, can't be lessthan zero
expected section name after comma in '.zerofill' directive
__bss
cleanupret
__class_vars
__instance_vars
__static_data
vISA_NumGenBinariesWillBePatched
absolute_symbol
.subsection
.preinit_array.
note
.soften
expected group name
 node
vISA_AddKernelID
.llvm.call-graph-profile
discard@
FK_PCRel_4
__symbols
.rsext
Disabled
.code64
.quad
Fragment can't be larger than a bundle size
<MCAssembler
  Symbols:[
_Z13get_global_idj
igc-type-legalizer
__builtin_spirv_BuiltInLocalInvocationId
.bundle_unlock forbidden when bundling is disabled
<<none>>
NTPOFF
EstimateFunctionSize
ABS8
prel31
high
Estimate Function Sizes
tprel@high
tprel@highest
dtprel@highera
.fix1.addrspacecast
IMGREL
function_type
FUNCTION
 Offset:
MCOrgFragment
MCPaddingFragment
 BundlePadding:
.fix2.addrspacecast
llvm.exp.f64
-setstartbp
<MCInst 
movcr@
__debug_abbrev
section_line_str
section_str_off
igc-addrspacecast-fix
rsq@
sampleBptr@
.debug_str_offsets
SmallVector capacity overflow during allocation
sampleinfoptr@
sampleptr@
setMessagePhaseV@
value evaluated as 
; <label>:
,#tls
,comdat
mach-o section specifier has invalid attribute
cstring_literals
simdSetMessagePhase@
simdShuffleDown@
simdSize@
.init
S_ATTR_STRIP_STATIC_SYMS
storestructured3@
storestructured4@
threadgroupbarrier@
threadgroupbarrier_signal@
typedmemoryfence@
' can not be undefined in a subtraction expression
<empty name> 
__builtin_IB_atomic_sub_local_i32
LLVM IR Parsing
distinct 
11ocl_image3d
!DIBasicType(
posix_spawn failed
!DIMacroFile(
 weak
19ocl_image2d_msaa
acquire
mem_fence
spill
 umin
             === Binary Compaction ===
 instructions of 3 src (mad/pln) are compacted.
 ; guid = 
(callee: ^
typeTests: (
llvm.loop.interleave.count
UNDEFINED_
DIFlagLValueReference
bool
__builtin_IB_atomic_max_global_u64
Enable optimization analysis remarks from passes whose name match the given regular expression
!AnalysisFPCommute
R_WEBASSEMBLY_TABLE_INDEX_SLEB
uniformRetVal
virtualConstProp
__builtin_IB_atomic_dec_global_i64
stage_in_grid_size_x
__AUTO_GENERATED_ELSE_LABEL__
L_AUTO_k
msaa_sample_pattern_offset
expected '=' in global variable
after_doCFGStructurizer
beforeProcessGoto
LABEL__
bindless_sampler_t
VCE_SAVE
Preds: 
texture_buffer
digraph 
__builtin_IB_atomic_max_local_i16
opencl.enable.FP_CONTRACT
 [shape=plaintext, label=<
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
<TR><TD>
Invalid alignment value
</FONT></TD></TR>
</TD></TR>
Explicit gep type does not match pointee type of pointer operand
//.platform 
//.stepping 
//.instCount 
LegalizeFunctionSignatures
//.spill GRF ref count 
//.spill flag store 
MaskCtrl
deviceEnqueueMaxWorkgroupSize
Failed to decode binary for asm output. Please report the issue and try disabling IGA disassembler for now.
.end_kernel
ConstantPointerProgramBinaryInfos
// --  BAD: 
snan
INVALID BTI
expected comma in compare constantexpr
packed_bool3
GOOD,
GOOD
packed_uchar3
inrange keyword may not appear on pointer operand
invalid operands to shufflevector
LOCAL_ROUND_ROBIN_RA
LOCAL_FIRST_FIT_BC_RA
HYBRID_RA
packed_half3
GRAPH_COLORING_FF_RA
GRAPH_COLORING_SPILL_RR_BC_RA
air.amplification_id
air.arg_type_size
Linear Interpolation
air.thread_position_in_grid
Switch
sat_exp
BreakPoint
NoCompact
air.concurrent_dispatch_threads_compute_command
Serialize
case value is not a constant integer
r8unorm
loop-exit-canonicalization
cbit
__builtin_spirv_OpGetKernelPreferredWorkGroupSizeMultiple
ResolveExternalVisibleFunctionName
TransformBlocks Pass
expected comma after load's type
NanHandling
Enqueue param is not a struct
unsupported platform
<unknown>:
alloca
sitofp
extractvalue
insertvalue
warning
IRInstrsBefore
 ***
' on Region '
pass
function_entry_count
vISA_HashVal
) attempted to be registered!
Offset not zero at the point of scalar access
Argument value does not match function argument type!
Invalid user of intrinsic instruction!
Attribute '
Attributes 'optsize and optnone' are incompatible!
' only applies to functions!
inlined-at should be a location
invalid vtable holder
invalid global variable ref
invalid unit type
Unexpected metadata round-trip through values
Only PHI nodes may reference their own value!
fpmath accuracy must have float type
Invalid bitcast
Duplicate integer as switch case
Attribute 'sret' cannot be used for vararg call arguments!
info argument of llvm.coro.begin must refer to an initialized constant
llvm.gcroot parameter #1 must be an alloca.
safepoints should have unique landingpads
gc.relocate: relocated value must be a gc pointer
calls to experimental_deoptimize must be followed by a return
conflicting debug info for argument
gc.statepoint number of deoptimization arguments must be positive
CatchSwitchInst cannot have empty handler list
Logical operators must have same type for operands and result!
atomic memory access' size must be byte-sized
cmpxchg instructions failure argument shall be no stronger than the success argument
ZExt only produces an integer
UIToFP result must be FP or FP vector
PtrToInt source must be pointer
Unwind edges out of a catch must have the same unwind dest as the parent catchswitch
cannot guarantee tail call due to mismatched parameter types
The landingpad instruction should have a consistent result type inside a function.
wrong initalizer for intrinsic global variable
invalid ID operand in module flag (expected metadata string)
expected a Function or null
INVALID
 (default: 
version
: Not enough positional command line arguments specified!
USAGE: 
IGC Int Type Legalizer
Vector functions library
??3@YAXPEAXAEBUnothrow_t@std@@@Z
-Gsize=7.5,10
rel32@lo
__cxa_atexit
unmaterialized function cannot have metadata
__strdup
igc-address-space-alias-analysis
Miscellaneous Ungrouped Timers
fuchsia
nvcl
eabihf
Check for input errors
(Twine 
S_ATTR_NO_TOC
hyphen
nine
left-curly-bracket
right-brace
repetition-operator operand invalid
geode
nocona
goldmont
TEMPDIR
15ocl_image2dmsaa
DW_TAG_ptr_to_member_type
DW_TAG_template_type_parameter
DW_TAG_condition
DW_TAG_GNU_template_template_param
DW_AT_byte_size
DW_AT_inline
DW_AT_calling_convention
DW_AT_static_link
DW_AT_call_column
DW_AT_recursive
DW_AT_dwo_name
DW_AT_alignment
DW_AT_MIPS_stride_byte
DW_AT_GNU_macros
DW_AT_BORLAND_Delphi_unit
DW_AT_APPLE_major_runtime_vers
DW_OP_const4u
DW_OP_mod
DW_OP_gt
DW_OP_lit13
DW_OP_lit28
DW_OP_reg13
DW_OP_reg26
DW_OP_breg13
DW_OP_breg28
DW_OP_bit_piece
DW_OP_GNU_addr_index
DW_ATE_UTF
DW_LANG_Modula2
DW_LANG_OCaml
DW_LANG_GOOGLE_RenderScript
greater-than-sign
R_WEBASSEMBLY_FUNCTION_OFFSET_I32
GED VERSION: 
MT0W_BS
MT1R_A64_US
MT_CC_OWDB
MT0A_UI
Transpose Read
A64 Untyped Atomic Integer Operation
A64 Untyped Atomic Float Add
aligned_store_block
Commit
 all L3 data
ChannelMode
a64 dword gathering read
7036
7130
typed_sgh
MSDUR_DWS
MessageTypeRC
.lo8ds
SlotGroupSelect
simd16 high
sample override lod
sample min
sample unorm+killpix
Rlen
Fill all 4 bytes per DW
_incoherent
 256b blocks
fp-compare and swap 
atomic_store
signed-integer max
invalid slot group value
 to surface 
12read_imageui20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
Src0HorzStride
dst region should be %s
operand has invalid math macro register
invalid field
Src1ChanSel
Src2DataType
src1: immediate operand in ternary align1 must be src0 or src2
BestStage1
]: #
ScratchOffset
CMaskUW
sg8l
register regioning restriction warning: Vertical stride must be used to cross GRF boundaries.
see Programmer's Reference Manual (Restriction 2.8)
Control Register
Component-wise extract a bit field from src2 using the bit field width from src0 and the bit field offset from src1. Store the extracted bit field value in the low bits of dst and sign extend (if D type) or zero extend (if UD type).
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
If offset + width > 32 then the extracted bit field is bits offset to 31 of src2, extracting only 32 - offset bits, less than width as the bit field cannot extend past the MSB of the source value. Otherwise extract width bits extending from bit positions offset to offset + width - 1.
Format:
[(pred)] bfe (exec_size) dst src0 src1 src2
Branch Diverging
Compare NaN
Dot Product 4
guards-predicate-pass-branch-weight
nullptr
sccp
  used by: 
reassociate-geps-verify-no-dead-code
Preserve canonical loop structure (default = true)
sink-common-insts
Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.
memcmp
__builtin_IB_sub_group_scan_OpGroupSMin
preserve-alignment-assumptions-during-inlining
: argument 
lcssa
igc-fix-resource-ptr
invalid reg file on dst
swizzle Z could not be retrieved
NoDDClr not supported on given platform
Q1 is obsolete; use M0 in execution offset: e.g. op (8|M0) ...
expected flag register
expected '\n', ';', or EOF
expected a0
acc5
expected ;
this form of indirect (r3[a0.0,16]) is invalid for send dst operand; use regular form: r[a0.0,16]
Message Descriptor is typeless
out of dynamic memory in yy_get_next_buffer()
expected %d data registers
Hoist FMul in Loop Pass
iga_disassemble* call uses deprecated options  (hex_floats or print_pc); see newest iga.h header file for updated fields
llvm.amdgcn.image.sample.c.cd.o.2d
llvm.amdgcn.image.sample.c.cl.2darray
llvm.amdgcn.image.sample.c.cube
llvm.amdgcn.image.sample.c.d.cl.1d
llvm.amdgcn.image.sample.c.d.cl.o.3d
llvm.amdgcn.image.sample.c.d.o.3d
llvm.amdgcn.image.sample.c.l.o.1darray
llvm.amdgcn.image.sample.c.lz.1d
llvm.amdgcn.image.sample.c.lz.o.cube
llvm.amdgcn.image.sample.cd.1d
llvm.amdgcn.image.sample.cd.cl.3d
llvm.amdgcn.image.sample.cd.cl.o.3d
llvm.amdgcn.image.sample.cl.1darray
llvm.amdgcn.image.sample.cl.o.2d
llvm.amdgcn.image.sample.d.3d
llvm.amdgcn.image.sample.d.cl.2darray
llvm.amdgcn.image.sample.d.o.2d
llvm.amdgcn.image.sample.l.2darray
llvm.amdgcn.image.sample.lz.1d
llvm.amdgcn.image.sample.lz.o.1d
llvm.amdgcn.image.sample.o.3d
llvm.amdgcn.image.store.2dmsaa
llvm.amdgcn.implicit.buffer.ptr
llvm.amdgcn.interp.p1
llvm.amdgcn.mqsad.pk.u16.u8
llvm.amdgcn.rcp.legacy
llvm.amdgcn.s.dcache.wb
llvm.amdgcn.s.memrealtime
llvm.amdgcn.sdot2
llvm.amdgcn.tbuffer.store
llvm.amdgcn.workgroup.id.x
llvm.amdgcn.workitem.id.x
llvm.arm.crc32cw
llvm.arm.hint
llvm.arm.ldrexd
llvm.arm.mrc2
llvm.arm.neon.sha1m
llvm.arm.neon.sha256su1
llvm.arm.neon.vcvtas
llvm.arm.neon.vcvtfxs2fp
llvm.arm.neon.vhsubs
llvm.arm.neon.vld2dup
llvm.arm.neon.vmaxs
llvm.arm.neon.vmulls
llvm.arm.neon.vpmins
llvm.arm.neon.vqmovns
llvm.arm.neon.vqrshiftu
llvm.arm.neon.vqshifts
llvm.arm.neon.vrintn
llvm.arm.neon.vrsqrte
llvm.arm.neon.vst1x4
llvm.arm.neon.vst4lane
llvm.arm.qadd16
llvm.arm.sadd16
llvm.arm.shsub16
llvm.arm.smladx
llvm.arm.smuad
llvm.arm.smulwt
llvm.arm.stc
llvm.arm.strex
llvm.arm.uhsax
llvm.arm.uqsax
llvm.arm.usub8
llvm.arm.vcvtr
llvm.hexagon.A2.addh.h16.ll
llvm.hexagon.A2.addh.l16.sat.hl
llvm.hexagon.A2.andp
llvm.hexagon.A2.combine.ll
llvm.hexagon.A2.minup
llvm.hexagon.A2.orir
llvm.hexagon.A2.subh.h16.hh
llvm.hexagon.A2.subh.h16.sat.hl
llvm.hexagon.A2.svaddhs
llvm.hexagon.A2.svsubuhs
llvm.hexagon.A2.tfrpi
llvm.hexagon.A2.vaddb.map
llvm.hexagon.A2.vavghr
llvm.hexagon.A2.vavgw
llvm.hexagon.A2.vcmpwgt
llvm.hexagon.A2.vmaxh
llvm.hexagon.A2.vnavghcr
llvm.hexagon.A2.vrsadub
llvm.hexagon.A2.vsubws
llvm.hexagon.A4.andnp
llvm.hexagon.A4.cmpheq
llvm.hexagon.A4.combineri
llvm.hexagon.A4.rcmpneqi
llvm.hexagon.A4.tlbmatch
llvm.hexagon.A4.vcmpwgtui
llvm.hexagon.A4.vrminuw
llvm.hexagon.C2.bitsclr
llvm.hexagon.C2.cmpgei
llvm.hexagon.C2.mask
llvm.hexagon.C2.orn
llvm.hexagon.C4.and.or
llvm.hexagon.C4.cmplte
llvm.genx.GenISA.PatchConstantOutput
LLVM_OVERRIDE_PRODUCER
DW_OP_mul
__lshrhi3
DW_OP_ne
/// End Inlined ASM
DW_OP_lit14
__divqi3
DW_OP_lit30
DW_OP_reg6
DW_OP_reg14
__umodhi3
DW_OP_reg30
__adddf3
DW_OP_breg14
__mulsf3
DW_OP_breg30
DW_OP_nop
DW_OP_implicit_value
__powitf2
DW_ATE_address
__gnu_h2f_ieee
DW_ATE_UCS
__truncxfdf2
DW_LANG_C99
DW_LANG_Python
DW_LANG_Rust
__fixtfti
DW_CC_pass_by_reference
__fixunsxfsi
igc-dp-to-fp-load-store
__floatsitf
R_WEBASSEMBLY_MEMORY_ADDR_LEB
__builtin_IB_atomic_inc_global_i64
__floatundidf
^(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$
__eqsf2
MT1R_T
__gedf2
MT1A_A64_UI4x2
MT2R_BS
MT_CC_DWS
MTRA_TA
MT1A_UF
__llvm_memcpy_element_unordered_atomic_16
Untyped Surface Read
__llvm_memset_element_unordered_atomic_8
A64 Block Read
Unaligned Oword Block Read Sampler Cache
Untyped Atomic Float Operation
__sync_fetch_and_add_8
air.set_buffer_visible_function_table
__sync_fetch_and_and_1
aligned oword block write
__sync_fetch_and_or_16
on (wait for fence commit)
 flushing
.dcti
__sync_fetch_and_max_16
__sync_fetch_and_umax_8
__sync_fetch_and_min_4
HandleLoadStoreInstructionsPass
__atomic_load_1
a64 dual block 
 hword
7122
__atomic_exchange_16
__atomic_fetch_add_1
atomic 32-bit integer (slot group high)
MSDUW_DWS
44777
unmonitor event
__atomic_fetch_xor_1
__atomic_fetch_xor_16
__atomic_fetch_nand_8
.shl.merge.inner.hi
invalid hexadecimal floating-point constant: expected at least one exponent digit
simd32/64
unterminated single quote
higher
missing expression
invalid assignment to '
sample with lod forced to 0
.shl.inner.true.branch
sample_deinterlace
.octa
unsupported DC2 op
4 OWords
DataElements:MDC_DWS_DS
Workaround fmax/fmin
DataElements:MDC_DS
.weak_definition
preserve-nan
.code16
64b integer compare and swap
atomic_iinc
.ifne
atomic_umax
.ifdef
SlotGroup:MDC_SG3
.line
true
GED failed to create instruction template
FlagRegNum
src0: unsupported type for ternary align1 encoding
Src0RegFile
.cfi_offset
DstRegNum
.cfi_return_column
NoPreempt not supported on this platform (dropping)
invalid value
.noaltmacro
invalid region horizontal stride on src1
.dc.s
Src2RepCtrl
.dcb.x
11read_imagef14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
, rd:
MathMacroExt
assembler local symbol '
invalid use of pseudo-symbol '.' as a label
unexpected token in '.if' directive
Preserve NAN (default false)
Encountered a .elseif that doesn't follow an .if or  an .elseif
11read_imagei14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
xga64
xbl128
' does not exist for macro '
expected identifier
invalid alignment value
IGC Load Shrink
be_sp
destination register ARF access requires {Switch} ThreadCtrl
TRIVIAL_BC_RA
packed_ushort4
unexpected token in '.include' directive
no matching '.endr' in definition
The add instruction performs component-wise addition of src0 and src1 and stores the results in dst.
Addition of two floating-point numbers follows rules in add (IEEE mode) or add (ALT mode).
Format:
[(pred)] add[.cmod] (exec_size) dst src0 src1
Use a source modifier with add to implement subtraction.
Arithmetic Shift Right
bfi1
in '
Break
inconsistent use of MD5 checksums
The cmpn instruction performs component-wise special-NaN comparison of src0 and src1 and stores the results in the selected flag register and in dst. It takes component-wise subtraction of src0 and src1, evaluating the conditional signals including NS based on the conditional modifier, and storing the conditional flag bits in bit-packed form in the destination flag register and all bits of dst channels. If the dst is not null, for the enabled channels, then all bits of the destination channel will contain the flag value for the channel. When the instruction operates on packed word format, one general register may store up to 16 such comparison results. In DWord format, one general register may store up to 8 results.
A conditional modifier must be specified; the conditional modifier field cannot be 0000b. More information about the conditional signals used is in the Creating Conditional Flags section.
For each enabled channel 0b or 1b is assigned to the appropriate flag bit and 0/all zeros or all ones (e.g, byte 0xFF, word 0xFFFF, DWord 0xFFFFFFFF) is assigned to dst.
Min/Max instructions use cmpn to select the destination from the input sources (see the Min Max of Floating Point Numbers section for details).
Format:
[(pred)] cmpn[.cmod] (exec_size) dst src0 src1
isa number less than zero
The endif instruction terminates an if/else/endif block of code. It restores execution to the channels that were active prior to the if/else/endif block.
The endif instruction is also used to hop out of nested conditionals by jumping to the end of the next outer conditional block when all channels are disabled.
The following table describes the 16-bit JIP. In GEN binary, JIP is at location src1 and must be of type W (signed word integer). JIP must be an immediate operand, it is a signed 16-bit number. This value is added to IP pre-increment.
Format:
endif JIP
Find First Bit from MSB Side
expected line number after 'inlined_at'
unassigned file number in '
unknown sub-directive in '.cv_loc' directive
UnifiedReturnBlock
 in '.cv_fpo_data' directive
IDIV
IQOT
' is already defined
RSQT
unexpected token in '.end' directive
expected comma
Return
rndu
The sad2 instruction takes source data channels from src0 and src1 in groups of 2-tuples. For each 2-tuple, it computes the sum-of-absolute-difference (SAD) between src0 and src1 and stores the scalar result in the first channel of the 2-tuple in dst.
The results are also stored in the accumulator register. The destination operand and the accumulator maintain 16 bits per channel precision.
The destination register must be aligned to even word (DWord). The even words in the destination region will contain the correct data. The odd words are also written but with undefined values.
Format:
[(pred)] sad2[.cmod] (exec_size) dst src0 src1
Send Message
' (no symbols present)
air.get_quadgroups_per_threadgroup
invalid modifier '
.data
.scl
sends
.ashr.merge.inner.lo
sinl
.seh_setframe
binary size is too small
IGA INTERNAL ERROR: 
unexpected Align1Ternary in current platform
invalid dst implicit accumulator reference (in ChEn)
GED reports invalid value for 
' is already linkonce
UnifiedRetVal
DW_AT_is_optional
.lsym
.popsection
NoPreempt not supported on given platform
.const
Q3 is obsolete; use M16 in execution offset: e.g. op (8|M16) ...
.ashr.inner.true.branch
expected instruction, block, or EOF
.thread_local_variable_pointer
expected operation subfunction
expected flag modifier function
.objc_protocol
destination region argument
.symbol_stub
acc6
.build_version
expected ,
syntax error in region (vertical stride)
-debug
unexpected token in '.section' directive
igc-loop-dce
section "
unary send prohibits src1 argument
can't open secure log file: 
37intel_work_group_vme_mb_multi_query_4PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
parse error
image2d_array_depth_t
expected string in '
VISA Legalizer
__cat_cls_meth
fence
.trunc
fcmp
__picsymbol_stub
vISA_GenerateISAASM
invalid OS minor version number
vISA_dumpNewSyntax
tvos
vISA_ISAASMNamesFile
Print PassManager debugging information
.local
print-before-all
DPEmusext
fini_array
 -*- '
llvm_call_graph_profile
 Analyses:
read
vISA_InsertHashMovs
SCC (
vISA_HashVal1
expected a comma
Maximum size for the name of non-global values.
Cannot represent a difference across sections
createMessagePhasesV@
cycleCounter@
FK_Data_4
.lsext
igc-legalization
reducedIndex
Only global arrays can have appending linkage!
FK_Data_Add_2
Attribute 'sret' is not on first or second parameter!
Default for platform
Attributes 'byval', 'inalloca', 'inreg', 'nest', and 'sret' are incompatible!
.u2f.roudning.branch
swifterror value when used in a callsite should be marked with swifterror attribute
__svml_sinf4
invalid number of bytes
invalid template parameter
cannot have fixups in virtual section!
line specified with no file
IGC 64-bit ops emulation
invalid type ref
<stdin>
PHI nodes must have at least one entry.  If the block is dead, the PHI should be removed!
Segment for file '
AS_SECURE_LOG_FILE
.group
Symbol: 
Reference to undefined temporary symbol 
Range types must match instruction type!
Called function is not pointer to function type!
Multiple gc-transition operand bundles
alignment of arg 0 of memory intrinsic must be 0 or a power of 2
Mark readonly load
TPREL
GOTPAGEOFF
GenOptLegalizer
gc.relocate operand #3 must be integer offset
masked_load: return must match pointer type
explicit_arg_num
diff16
highesta
invalid llvm.dbg.
gc.statepoint number of arguments to underlying call must be constant integer
gc.relocate connected to wrong gc.statepoint
dtpmod
img_access_float_coords
implicit_arg_desc
EH pad must be jumped to via an unwind edge
Changes indirect calls to direct calls if possible
Alloca array size must have integer type
got@dtprel
GEP base pointer is not a vector or a vector of pointers
got@tlsld@l
atomicrmw instructions cannot be unordered.
HI16
Type too small for SExt
DW_AT_MIPS_software_pipeline_depth
SIToFP source and dest vector length mismatch
' could not be evaluated in a subtraction expression
IntToPtr Vector width mismatch
MCDataFragment
Invalid operand types for ICmp instruction
musttail call must precede a ret with an optional bitcast
EH pads can't handle each other's exceptions
image1d_buffer
 bytes)
 NumValues:
Legalization Pass
denorm_exp_loop_end
module flag identifiers must be unique (or of 'require' type)
-replaceIndirectCallWithJmpi
Imm:
-hashmovs1
memoryfence@
mov_identity@
names_begin
namespac_begin
Cannot specify more than one option with cl::ConsumeAfter!
opencl_vec_type_hint
Can specify at most 
image2d_array_depth
__debug_inlined
Comma separated list of debug counter skip and count
.rodata.cst8
view-background
.debug_pubtypes
.debug_loc
.debug_names
.apple_types
Allocation failed
iwmmxt
sampleLptr@
.stack_sizes
.debug$H
skel_string
.drectve
.gfids$y
PurgeMetaDataUtilsPass
Low Precision Opt
llvm.genx.GenISA.cmpxchgatomicstructured
v8.4a
,#alloc
Address space alias analysis
liveness
mach-o section specifier requires a segment and section separated by a comma
GenXCodeGenModule
S_REGULAR
simdMediaBlockWrite@
simdMediaRegionCopy@
lazy_symbol_pointers
simdSetMessagePhaseV@
coalesced
S_INTERPOSING
S_LAZY_DYLIB_SYMBOL_POINTERS
S_THREAD_LOCAL_VARIABLES
storeraw_indexed@
S_ATTR_PURE_INSTRUCTIONS
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
storestructured2@
S_ATTR_DEBUG
unsupported directive in streamer
all .cv_loc directives for a function must be in the same section
subslice_id@
Chained unwind areas can't have handlers!
frame offset must be less than or equal to 240
If present, PushMachFrame must be the first UOP
Symbol name with unsupported characters
, Sym=
SubroutineInliner
igc-low-precision-opt
__builtin_IB_atomic_sub_global_i32
REG_NOMATCH
REG_ECTYPE
REG_EPAREN
avr_intrcc 
REG_INVARG
; uselistorder directives
usubb@
target triple = "
btver2
!DILocation(
Default
MetaData
Child timed out but wouldn't die
!DILexicalBlock(
DW_TAG_null
!DIObjCProperty(
DW_TAG_structure_type
__builtin_IB_atomic_min_local_u32
DW_TAG_base_type
uaddc@
DW_TAG_variable
 within 
DW_TAG_generic_subrange
unordered
wait
 inbounds
pseudo_kill
 xor
Lowers GEP into primitive ones
LowPrecisionOpt Pass
constant 
thread_local(localdynamic) 
ifunc 
 instructions are compacted.
", hash: (
 = gv: (
DW_AT_call_return_pc
wait
, aliasee: 
, readOnly: 
DW_AT_sf_names
__builtin_IB_atomic_xor_local_i32
DW_AT_GNU_pubnames
INVALID opcode 
, bitMask: 
, bit: 
  { 
stack-probe-size
pmovsx
min.cond
DW_OP_lit2
Objective-C Class Properties
^arm\.neon\.vst([1234]|[234]lane)\.v[a-z0-9]*$
21ocl_image2darraydepth
empty-set
Address space 0 can never be non-integral
Missing alignment specification for pointer in datalayout string
Sized aggregate specification in datalayout string
Metadata Utils Wrapper
Invalid ABI alignment, must be a power of 2
Expected token before separator in datalayout string
Allocation failed
DIFlagVirtual
DIFlagObjcClassComplete
DW_ATE_signed
DIFlagNoReturn
DIFlagFixedEnum
NoDebug
Enable optimization remarks from passes whose name match the given regular expression
llvm.used
 at line 
 (hotness: 
powf
R_WEBASSEMBLY_FUNCTION_INDEX_LEB
allOnes
singleImpl
Inorder PostDominator Tree: 
(badref), 
SLMSize
Dominator Tree Construction
UserDefined
__builtin_IB_get_local_id_y
__builtin_IB_get_local_size
llvm.genx.
igc-metadata-utils-wrapper
_AUTO_GENERATED_IF_LABEL_
virtual_binding_table_ds
local_size_z
global_offset_x
__builtin_IB_atomic_sub_local_i16
base_patch
variable expected to be numbered '%
afterRemoveUnreachableBlocks
before_doCFGStructurizer
air.atomic_fetch_and_explicit_texture
air.atomic_fetch_xor_explicit_texture
air.get_unique_identifier_command_buffer
air.get_unique_identifier_render_pipeline_state
Collect information related to hull shader
bindless_image_cube_depth_t
__MERGED_FRET_EXIT_BLOCK_f
texture2d
texturecube_array
depth2d_array
UnknownKernel
texture1d
igc-collect-hull-shader-properties
resTy
digraph UnknownKernel
vararg
MoveStaticAllocasPass
cannot load symbol cmc_free_compile_info
ICLLP
opencl.ocl.version
Lower inputs outputs for hull shader
MetaData Utils Wrapper
Invalid TYPE table
Alias and aliasee types don't match
Invalid calling convention ID
</TD></TR>
Never resolved function from blockaddress
igc-hull-shader-lowering
Invalid constant type
<TR><TD ALIGN="LEFT"><FONT color="
EXTRACTVAL: Invalid array index
INSERTVAL: Invalid array index
Callee is not a pointer
Personality function mismatch
Callee is not a pointer type
Clear tessellation factors
Insufficient function protos
//.kernel 
Malformed block
Unexpected end of file
//.options 
/System/Library/Frameworks/OpenCL.framework/Resources/
igc-cleartessfactors
types-legalization-pass
//.spill size 
less-precise-fpmad
no-nans-fp-math
instructions returning void cannot have a name
deviceEnqueueGetBlockSimdSize
map::at:  key not found
PtrDstToInt
SampleCmpToDiscard
.code
igc-add-implicit-args
legacy
igc-callgraphscc-analysis
.end_code
metadata
Layout blocks
CorrectlyRoundedDivSqrt
qnan
extractvalue operand must be aggregate type
igc-break-const-expr
Invalid Pass 
float4x2
OH, 
a64c
bool3
long3
packed_long3
ulong3
packed_ulong3
double3
12read_imageui14ocl_image3d_ro11ocl_samplerDv4_fS_S_
: numeric label targets the middle of an instruction
invalid getelementptr indices
packed_ushort3
Unsupported required sub group size
LOCAL_ROUND_ROBIN_BC_RA
uint3
packed_uint3
short3
HYBRID_BC_RA
int3
igc-ldshrink
half3
GRAPH_COLORING_RR_RA
const
__global
float3
ImplicitGlobalId
air.location_index
air.threads_per_threadgroup
air.stage_in_grid_size
air.thread_index_in_quadgroup
12write_imagei16ocl_image2darrayDv4_iS_
Align16
.emulation.
cond_dim2_true
AIR Conversion
mainFunc
MaxNumOfOutputSignatureEntries
max-work-group-size
for arguments marked with raster_order_group, emit sendc
denorm_or_zero_end
-fp32-correctly-rounded-divide-sqrt
NoMask
rsqrt_chan
air.get_dispatch_simdgroups_per_threadgroup
air.get_simdgroup_index_in_threadgroup
Compacted
unordered_map::at: key not found
LiveVarsAnalysis
air.set_pipeline_state_compute_command
air-fast-flag-propagation-mark-pass
AirFastFlagPropagationResolve
duplicate case value in switch
rg8unorm
rgba8unorm
12write_imagei14ocl_image3d_woDv4_iiS_
half4x3
visible_function_table
expected 'from' after cleanupret
float4x4
air.simdgroup_index_in_threadgroup
bfrev
output
29intel_work_group_vme_mb_queryPU3AS3jDv2_iS1_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
igc-air-legalize-resource-addrspace
TessInputControlPointCount
FP16DivWorkaround
igc-check-unresolved-builtin-functions
igc-air-samplers
AirResolveInlineSamplerWA
LivenessAnalysis
SPIR to IGC metadata translator
math
air.arg_unused
air.center
igc-air-metadata-parse
igc-code-gen-context-wrapper
invalid type for alloca
Translate AIR Builtins
malformed load/store mnemonic suffix
register range
address model
if.else
expected ',' after cmpxchg address
IGC Loop canonicalization
igc-spir-metadata-translation
__destructor
catchswitch
sdiv
zext
uitofp
call
shufflevector
WaveClustered@
gc-transition
error
print pass details when it is executed
Print IR after each pass
: IR instruction count changed from 
' is not initialized.
*** IR Dump Before 
Executing Pass '
' on Module '
time-passes
ModulePass Manager
synthetic_function_entry_count
cmpxchgatomicstructured@
running pass 
unexpected token in '.version' directive
Allocation failed
Struct tag metadata must have either 3 or 4 operands
Cycle detected in struct path
Functions cannot return aggregate values!
Calling convention does not support varargs or perfect forwarding!
Function declaration shouldn't have a personality routine
function must have a single !prof attachment
Global is marked as dllimport, but not external
Attributes 'byval', 'inalloca', 'nest', 'sret', 'nocapture', 'returned', 'swiftself', and 'swifterror' do not apply to return values!
inalloca isn't on the last parameter!
Attribute 'optnone' requires 'noinline'!
Attributes 'zeroext and signext' are incompatible!
Attribute 'swifterror' only applies to parameters with pointer type!
expected string with name of the !prof annotation
location requires a valid scope
invalid subrange count
invalid composite elements
invalid checksum
invalid global variable list
invalid subprogram declaration
subprogram definitions must have a compile unit
invalid static data member declaration
Expected valid value
PHI node entries do not match predecessors!
Instruction not embedded in basic block!
Cannot invoke an intrinsic other than donothing, patchpoint, statepoint, coro_resume or coro_destroy
fpmath takes one operand!
align takes one operand!
Instruction does not dominate all uses!
Intervals are not in order
Switch constants must all be same type as switch value!
Incorrect number of arguments passed to called function!
swifterror argument for call has mismatched parameter
Funclet bundle operands should correspond to a FuncletPadInst
Intrinsic name not mangled correctly for type arguments! Should be: 
element size of the element-wise unordered atomic memory intrinsic must be a constant int
incorrect alignment of the source argument
llvm.localescape only accepts static allocas
gc.relocate must return a pointer or a vector of pointers
gc.statepoint: insufficient arguments
gc.relocate: statepoint derived index doesn't fall within the 'gc parameters' section of the statepoint call
masked_store: mask must be vector
experimental_deoptimize return type must match caller return type
 intrinsic expression
dbg intrinsic without variable
gc.statepoint doesn't support wrapping non-void vararg functions yet
gc.statepoint number of deoptimization arguments must be constant integer
CleanupReturnInst needs to be provided a CleanupPad
CatchSwitchInst must unwind to an EH block which is not a landingpad.
A single unwind edge may only enter one EH pad
Logical operators only work with integral types!
Load cannot have Release ordering
Non-atomic load cannot have SynchronizationScope specified
Invalid indices for GEP pointer type!
cmpxchg instructions cannot be unordered.
Argument value type does not match pointer operand type!
ZExt only operates on integer
FPToUI result must be integer or integer vector
UIToFP source must be integer or integer vector
fptrunc source and destination must both be a vector or neither
DestTy too small for FPExt
AddrSpaceCast must be between different address spaces
Unwind edges out of a funclet pad must have the same unwind dest
Invalid operand types for FCmp instruction
cannot guarantee tail call due to mismatched parameter counts
Select values must have same type as select instruction!
LandingPadInst needs at least one clause or to be a cleanup.
'common' global must have a zero initializer!
wrong type for intrinsic global variable
unrecognized named metadata node in the llvm.dbg namespace
invalid behavior operand in module flag (unexpected constant)
expected a MDNode triple
expected an integer constant
-generateDebugInfo
Display list of all available options
Print all option values after command line parsing
' is all messed up!
This argument does not take a value.
Instead, it consumes any positional arguments until the next recognized option.
requires a value!
OVERVIEW: 
 <subcommand> -help" to get more help on a specific subcommand
7.0.0
 Added Flags: 
Trying 'xdg-open' program... 
 [subcommand]
??3@YAXPEAX_K@Z
??_U@YAPEAX_KAEBUnothrow_t@std@@@Z
indvar
armv3m
5TEJ
armv6t2
armv7-a
armv7-r
.tls$
'.fill' directive with negative repeat count has no effect
__sinpif
__sqrtf_finite
__strcpy_chk
Error opening info-output-file '
14ocl_image1d
   --System Time--
misc
mach-o section specifier has a malformed stub size
spir64
freebsd
windows
cuda
gnuabin32
eabi
armv7ve
igc-agg-arg
decULL:"
uhex:"
malloc_cont
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
newline
percent-sign
comma
three
eight
reverse-solidus
left-brace
vertical-line
trailing backslash (\)
braces not balanced
REG_BADRPT
*** unknown regexp error code ***
irparse
skylake
k6-3
pentium-mmx
yonah
k8-sse3
TEMP
!DISubroutineType(
' for 
GenIR Lowering
DW_TAG_member
DW_TAG_union_type
DW_TAG_module
DW_TAG_constant
DW_TAG_subprogram
DW_TAG_restrict_type
DW_TAG_imported_unit
DW_TAG_call_site
DW_TAG_class_template
DW_TAG_BORLAND_Delphi_dynamic_array
DW_AT_ordering
DW_AT_visibility
DW_AT_default_value
DW_AT_upper_bound
DW_AT_base_types
DW_AT_frame_base
DW_AT_specification
DW_AT_data_location
DW_AT_trampoline
DW_AT_picture_string
DW_AT_pure
DW_AT_string_length_byte_size
DW_AT_dwo_id
DW_AT_call_parameter
DW_AT_noreturn
DW_AT_MIPS_loop_unroll_factor
DW_AT_MIPS_has_inlines
DW_AT_src_coords
DW_AT_GNU_all_call_sites
DW_AT_BORLAND_property_read
DW_AT_BORLAND_property_default
DW_AT_BORLAND_closure
DW_AT_APPLE_block
DW_AT_APPLE_property
DW_OP_const2s
DW_OP_pick
DW_OP_minus
DW_OP_shr
DW_OP_ge
DW_OP_lit5
DW_OP_lit12
DW_OP_lit21
DW_OP_lit27
DW_OP_reg5
DW_OP_reg12
DW_OP_reg21
DW_OP_reg25
DW_OP_breg5
DW_OP_breg12
DW_OP_breg21
DW_OP_breg27
DW_OP_xderef_size
DW_OP_call_frame_cfa
DW_OP_regval_type
DW_OP_GNU_push_tls_address
DW_ATE_unsigned_char
DW_ATE_decimal_float
DW_LANG_Ada83
DW_LANG_Pascal83
DW_LANG_D
DW_LANG_C_plus_plus_11
DW_LANG_Fortran08
DW_LANG_Mips_Assembler
v6kz
 prologue 
amdpal
33IGIL_EnqueueKernelWithLocalParams9ocl_queueiPijPvjS0_S0_jS0_j9ndrange_ti12ocl_clkevent
R_WEBASSEMBLY_GLOBAL_INDEX_LEB
Strip specified level of directory name from source path in the profile counter name for static functions.
verify-dom-info
MT0R_OWUB
MT0W_DWS
MT1A_TA4x2
MT1R_A64_SB
MT2R_A64_US
MT_CC_OWUB
MTRR_TS
MT0R_US
OWord Dual Block Read
Byte Scattered Write
Untyped Surface Write
A64 Untyped Surface Read
Dword Scattered Read Constant Cache
Untyped Atomic Operation
base_vertex
MessageType
7032
byte scattering write
7069
L3 implies L1 flush
L3 Flush Targets
 instruction data
HWordOffset
a64 byte scattering write
a64 scattering write
7075
7039
_aligned
float atomic
7155
7149
7046
7099
disabled
44778
unmonitor
unsupported RC op
.f16
 replicated SIMD16
 with Per-Coarse Pixel PS outputs enable
.lrts
invalid sampler SIMD mode
simd16h
sample gradient
sample_lod
sample_gather4_po
sample_min
sample load mcs auxilary data
sample_unorm_killpix
sample 8x8
Mlen
2 OWords
Fill 2 bytes per DW
_simd
stateless
A64 
DataElements:MDC_A64_DB_HW
invalid MDC_SM3
atomic_fcas
atomic_icas
logical XOR
integer add
atomic_smax
typed_load
SG8U
included (two register header)
a64 dual block read/write unsupported
ClearTessFactors
PredInv
DstHorzStride
Src0Width
MsgDesc
DstAddrSubRegNum
Src0AddrImm
%s: %s%d number out of range
uip label invalid
no compact form
Src1AddrMode
Src1AddrSubRegNum
invalid region width on src0
Src2SrcMod
src%d: invalid operand kind
Src0TernaryImm
expected ')' in extractvalue constantexpr
MathMacroExt::INVALID
on <h> region v must be Region::VT_INVALID
|ChannelOffset
-<ERR>
float2x2
scratch
xbl256
HW64
HWSB(0x
CMask(0x
sg4x2
: PC 
register regioning restriction warning: If vertical stride and horizontal stride are 0, width must be 1.
see Programmer's Reference Manual (Restriction 2.6)
Channel Enable
Timestamp Register
Bit Field Extract
Bit Field Reverse
The calla instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the calla instruction. If none of the channels jump into the subroutine, the calla instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
If SPF is ON, none of the PcIP are updated.
When SPF is on, the predication control must be scalar.
The difference between calla and call is that calla uses JIP as the IP value rather than adding it to the IP value.
Format: [(pred)] calla (exec_size) dst JIP
cmpn
End If
The f32to16 instruction converts the single precision float in src0 to half precision float and storing in the lower word of each channel in dst.
Because this instruction does not have a 16-bit floating-point type, the destination data type must be Word (W).
Format:
[(pred)] f32to16[.cmod] (exec_size) dst src0
The frc instruction computes, component-wise, the truncate-to-minus-infinity fractional values of src0 and stores the results in dst. The results, in the range of [0.0, 1.0], are the fractional portion of the source data. The result is in the range [0.0, 1.0] irrespective of the rounding mode. Floating-point fraction computation follows the rules in the following tables, based on the current floating-point mode.
Format:
[(pred)] frc[.cmod] (exec_size) dst src0
missing required field 'expr'
llvm.genx.GenISA.URBRead
rs4gc-clobber-non-live
GsOutputClipDistanceMask
Sparse Conditional Constant Propagation
file number less than one
.sroa.
__builtin_IB_simd_media_block_write_8_l
__builtin_IB_get_image_bti
DW_TAG_BORLAND_Delphi_set
bonus-inst-threshold
invalid type for null constant
Forward switch condition to phi ops (default = false)
expected end of statement in '.warning' directive
spec-exec-max-speculation-cost
__builtin_IB_sub_group_reduce_OpGroupFAdd
memchr
utimes
fputc_unlocked
Collect GS Properties
Convert noalias attributes to metadata during inlining.
unexpected modifier on variable reference
maskedptr
__builtin_IB_sub_group_scan_OpGroupFMin
Verify loop lcssa form (time consuming)
__builtin_IB_get_local_id_z
powl
__flag_end_marker
: invalid operation format
dst has wrong region for binary normal form
dst: invalid math macro register (from ChEn)
swizzle Y could not be retrieved
src%d: invalid addressing mode
_Z41get_kernel_max_sub_group_size_for_ndrange
argument to operator must be integral
snan
NoDDChk not supported on given platform
Compacted mutually exclusive with Uncompacted/NoCompact
H2 is obsolete; use M16 in execution offset: e.g. op (16|M16) ...
N6 is obsolete; use M20 in execution offset: e.g. op (4|M20) ...
integer literal too large
invalid predication control
unexpected . (expected execution size)
src0 must be a notification register
invalid destination register
immediate offset is out of range; must be in [
send operand region has no effect and is deprecated syntax
acc4
unexpected |
invalid region width
register access granularity too small type
invalid send destination register
extended message descriptor is typeless
INTERNAL ERROR: parsing float literal
input in flex scanner failed
malformed register range (high register must be >= low)
surface index is out of bounds
expected %d address registers
atomic store cannot use Acquire ordering
iga_assemble call uses deprecated options  (error_on_compact_fail or autoset_deps); see newest iga.h header file for updated fields
llvm.amdgcn.image.sample.c.cd.cl.o.cube
llvm.amdgcn.image.sample.c.cd.o.1darray
llvm.amdgcn.image.sample.c.cl.1d
llvm.amdgcn.image.sample.c.cl.2d
llvm.amdgcn.image.sample.c.cl.o.2d
llvm.amdgcn.image.sample.c.cl.o.cube
llvm.amdgcn.image.sample.c.d.2darray
llvm.amdgcn.image.sample.c.d.3d
llvm.amdgcn.image.sample.c.d.cl.o.1d
llvm.amdgcn.image.sample.c.d.cl.o.2darray
llvm.amdgcn.image.sample.c.d.o.1darray
llvm.amdgcn.image.sample.c.d.o.2darray
llvm.amdgcn.image.sample.c.l.2darray
llvm.amdgcn.image.sample.c.l.o.1d
llvm.amdgcn.image.sample.c.l.o.cube
39intel_work_group_vme_mb_multi_check_8x8PU3AS3jjjjDv2_iDv4_i14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
llvm.amdgcn.image.sample.c.lz.o.1darray
llvm.amdgcn.image.sample.c.lz.o.3d
llvm.amdgcn.image.sample.c.o.2darray
llvm.amdgcn.image.sample.c.o.cube
llvm.amdgcn.image.sample.cd.cl.1d
llvm.amdgcn.image.sample.cd.cl.2darray
llvm.amdgcn.image.sample.cd.cl.o.2d
llvm.amdgcn.image.sample.cd.cl.o.2darray
llvm.amdgcn.image.sample.cd.o.2darray
llvm.amdgcn.image.sample.cl.1d
llvm.amdgcn.image.sample.cl.cube
llvm.amdgcn.image.sample.cl.o.1darray
llvm.amdgcn.image.sample.d.1d
llvm.amdgcn.image.sample.d.2darray
llvm.amdgcn.image.sample.d.cl.2d
45intel_work_group_vme_mb_multi_bidir_check_8x8PU3AS3jjjjDv2_ihhS1_14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
llvm.amdgcn.image.sample.d.cl.o.cube
llvm.amdgcn.image.sample.d.o.1darray
llvm.amdgcn.image.sample.l.1d
llvm.amdgcn.image.sample.l.2d
llvm.amdgcn.image.sample.l.o.2d
llvm.amdgcn.image.sample.l.o.cube
llvm.amdgcn.image.sample.lz.3d
llvm.amdgcn.image.sample.lz.cube
llvm.amdgcn.image.sample.o.1d
llvm.amdgcn.image.sample.o.2darray
llvm.amdgcn.image.store.2d
llvm.amdgcn.image.store.2darraymsaa
llvm.amdgcn.image.store.mip.2d
llvm.amdgcn.image.store.mip.cube
llvm.amdgcn.interp.mov
54intel_sub_group_avc_ime_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
llvm.amdgcn.loop
llvm.amdgcn.mov.dpp
llvm.amdgcn.qsad.pk.u16.u8
llvm.amdgcn.rcp
llvm.amdgcn.rsq.legacy
llvm.amdgcn.s.dcache.inv.vol
llvm.amdgcn.s.getreg
llvm.amdgcn.s.incperflevel
llvm.amdgcn.sad.hi.u8
llvm.amdgcn.sbfe
llvm.amdgcn.sffbh
llvm.amdgcn.tbuffer.load
llvm.amdgcn.udot8
llvm.amdgcn.wave.barrier
llvm.amdgcn.workgroup.id.z
62intel_sub_group_avc_ime_evaluate_with_dual_reference_streamout14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
llvm.arm.clrex
llvm.arm.crc32ch
llvm.arm.dmb
llvm.arm.get.fpscr
llvm.arm.ldc2
llvm.arm.ldrex
llvm.arm.mcrr2
llvm.arm.mrc
llvm.arm.neon.aesmc
llvm.arm.neon.sha1h
llvm.arm.neon.sha256h
llvm.arm.neon.sha256su0
llvm.arm.neon.vacge
llvm.arm.neon.vcls
llvm.arm.neon.vcvtfp2hf
61intel_sub_group_avc_ime_evaluate_with_dual_reference_streamin14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
llvm.arm.neon.vcvtps
llvm.arm.neon.vhaddu
llvm.arm.neon.vld1x3
llvm.arm.neon.vld2
llvm.arm.neon.vld4
llvm.arm.neon.vmaxnm
llvm.arm.neon.vminu
llvm.arm.neon.vmullp
llvm.arm.neon.vpaddls
llvm.arm.neon.vpmaxu
llvm.arm.neon.vqaddu
llvm.arm.neon.vqdmull
llvm.arm.neon.vqrshiftns
llvm.arm.neon.vqrshifts
llvm.arm.neon.vqshiftnu
64intel_sub_group_avc_ime_evaluate_with_dual_reference_streaminout14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
llvm.arm.neon.vrhadds
llvm.arm.neon.vrintm
llvm.arm.neon.vrshiftn
llvm.arm.neon.vrshiftu
llvm.arm.neon.vshiftu
llvm.arm.neon.vst1x3
llvm.arm.neon.vst3lane
llvm.arm.neon.vst4
llvm.arm.neon.vtbx2
llvm.arm.qadd
llvm.arm.qsub
llvm.arm.qsub8
llvm.arm.shadd16
llvm.arm.shsax
llvm.arm.smlad
54intel_sub_group_avc_ref_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ref_payload_t
llvm.arm.smlsd
llvm.arm.smlsldx
llvm.arm.smultb
llvm.arm.smulwb
llvm.arm.ssat16
llvm.arm.ssub8
llvm.arm.stlex
llvm.arm.stlexd
llvm.arm.uasx
llvm.arm.uhasx
llvm.arm.uqadd16
llvm.arm.uqasx
llvm.arm.usat
llvm.arm.usub16
llvm.arm.uxtb16
52intel_sub_group_avc_sic_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_sic_payload_t
llvm.hexagon.A2.add
llvm.hexagon.A2.addh.h16.lh
llvm.hexagon.A2.addh.h16.sat.ll
llvm.hexagon.A2.addh.l16.ll
llvm.hexagon.A2.addsat
llvm.hexagon.A2.andir
llvm.hexagon.A2.combine.hl
llvm.hexagon.A2.combine.lh
llvm.hexagon.A2.maxup
llvm.hexagon.A2.minu
llvm.hexagon.A2.not
llvm.hexagon.A2.or
llvm.hexagon.A2.sath
llvm.hexagon.A2.sub
llvm.hexagon.A2.subh.h16.sat.hh
__builtin_IB_convert_sampler_to_int
llvm.hexagon.A2.subp
llvm.hexagon.A2.svaddh
llvm.hexagon.A2.svnavgh
llvm.hexagon.A2.svsubhs
llvm.hexagon.A2.tfr
llvm.hexagon.A2.tfrp
llvm.hexagon.A2.vabsw
llvm.hexagon.A2.vabswsat
llvm.hexagon.A2.vaddw
llvm.hexagon.A2.vavghcr
llvm.hexagon.A2.vavguhr
llvm.hexagon.A2.vavguwr
llvm.hexagon.A2.vcmpheq
llvm.hexagon.A2.vcmpweq
llvm.hexagon.A2.vmaxb
__EnableSWSrgbWrites
llvm.hexagon.A2.vminuh
llvm.hexagon.A2.vnavgh
llvm.hexagon.A2.vnavgwr
llvm.hexagon.A2.vraddub.acc
llvm.hexagon.A2.vsubub
llvm.hexagon.A2.vsubw
llvm.hexagon.A2.zxth
llvm.hexagon.A4.andn
llvm.hexagon.A4.cmpbgt
llvm.hexagon.A4.cmpbgtui
llvm.hexagon.A4.cmphgtu
llvm.hexagon.A4.combineir
llvm.hexagon.A4.ornp
llvm.hexagon.A4.rcmpneq
llvm.hexagon.A4.round.rr.sat
_Z12get_group_idj
llvm.hexagon.A4.vcmphgti
llvm.hexagon.A4.vcmpwgti
llvm.hexagon.A4.vrmaxw
llvm.hexagon.A4.vrminuh
llvm.hexagon.C2.all8
llvm.hexagon.C2.any8
llvm.hexagon.C2.cmpeqi
llvm.hexagon.C2.cmpeqp
llvm.hexagon.C2.cmpgtui
llvm.hexagon.C2.cmpltu
llvm.hexagon.C2.muxri
llvm.hexagon.C2.or
llvm.hexagon.C2.vmux
llvm.hexagon.C4.and.andn
llvm.hexagon.C4.and.orn
igc-builtin-import
nearbyint
PAL[
DW_OP_const8u
DW_OP_swap
cvtu
Invalid weak external
DW_OP_shra
ctlz.trunc
__lshrti3
PreBIImportAnalysis
__ashrti3
llvm.ctlz.
__muldi3
BIImport
DW_OP_lit22
llvm.loop.vectorize.
__divdi3
__enqueue_kernel_basic
__udivsi3
Invalid address space, must be a 24bit integer
__modhi3
__enqueue_kernel_vaargs
DW_OP_reg22
Missing alignment specification in datalayout string
__umodti3
__enqueue_kernel_events_vaargs
__modti3
Invalid bit width, must be a 24bit integer
__subsf3
_Z14enqueue_kernel
DW_OP_breg22
not a number, or does not fit in an unsigned int
__multf3
enqueue_IB_kernel
__divxf3
DIFlagFwdDecl
===> Materialize Failure: 
DW_OP_deref_type
DIFlagObjectPointer
__extendxftf2
__powidf2
DIFlagVirtualInheritance
__trunctfhf2
MCSOptimization
DW_LANG_C_plus_plus
DIFlagThunk
__trunctfxf2
Loop Gating Optimization
__fixdfsi
LineTablesOnly
__fixxfdi
loop-gating
zeroext
Invalid regular expression '
__fixunssfti
GatingSimilarSamples
image1d_t
!Passed
__fixunstfti
Convert builtin functions from OpenCL to common GenISA
igc-workaround
DebugLoc
__floatdidf
igc-conv-ocl-to-common
__floattidf
Column
__floatunsidf
BuiltinsConverterFunction
Target
(no name)
__floatuntisf
CoordZ
__gcc_utoq
air-builtin-handler
__nesf2
CoordX
MT1W_US
Legalize Global Value Usages
__ltsf2
CoordY
__lesf2
__builtin_IB_get_num_groups
__gtsf2
floatColor
__unordsf2
stage_in_grid_origin_z
__llvm_memcpy_element_unordered_atomic_1
ColorX
__gcc_qgt
num_work_groups_x
__llvm_memmove_element_unordered_atomic_8
ColorY
Media Block Write
local_size_y
__sync_val_compare_and_swap_1
ColorZ
__sync_val_compare_and_swap_16
patch_index_buffer_offset
__sync_lock_test_and_set_8
ColorW
__builtin_IB_atomic_xchg_global_i16
air.get_global_buffer_visible_function_table
__sync_fetch_and_sub_2
Inconsistent use of image!
__sync_fetch_and_add_2
product
__sync_fetch_and_and_16
__builtin_IB_OCL_1d_ldui
7066
air.get_unique_identifier_texture
__sync_fetch_and_xor_4
__builtin_IB_OCL_1darr_ldui
__sync_fetch_and_nand_2
air.atomic_fetch_or_explicit_texture
__sync_fetch_and_max_1
__builtin_IB_OCL_2d_ldui
expected comdat keyword
sampler
air.atomic_fetch_add_explicit_texture
__builtin_IB_OCL_2darr_ldui
image3d_t
depth2d_ms
exp2l
__builtin_IB_OCL_3d_ldui
7034
bindless_image3d_t
__atomic_load_8
__builtin_IB_OCL_1d_ld
__atomic_store_2
bindless_image2d_array_t
__atomic_exchange
__builtin_IB_OCL_1darr_ld
7143
align
__atomic_compare_exchange_2
__builtin_IB_OCL_2d_ld
__atomic_exchange_4
tracepoint
__atomic_fetch_add_16
__builtin_IB_OCL_2darr_ld
__atomic_fetch_sub_8
igc-move-static-allocas
__atomic_fetch_and_4
__builtin_IB_OCL_3d_ld
__atomic_fetch_or_2
cmc_free_compile_info
__builtin_IB_OCL_2d_ldmcs
__sync_fetch_and_umin_8
opencl.compiler.ext.options
opencl.spir.version
__builtin_IB_OCL_2darr_ldmcs
__imp_
Expected a single module
SLOTGRP_LO
__builtin_IB_OCL_2d_ld2dms
invalid hexdecimal number
Expected a constant
Invalid global variable comdat ID
__builtin_IB_OCL_2darr_ld2dms
invalid binary number
Unknown attribute kind (
sample_resinfo
__builtin_IB_OCL_2d_ld2dmsui
sample gather4+pixel offset
Invalid value name
.equ
__builtin_IB_OCL_2darr_ld2dmsui
.string
Invalid instruction with no BB
.2byte
__builtin_IB_OCL_1d_sample_l
sample_flush
Insufficient operands to call
.double
__builtin_IB_OCL_1darr_sample_l
.balignw
INSERTVAL: Invalid struct index
.p2alignl
__builtin_IB_OCL_2d_sample_l
.extern
Invalid cast
.no_dead_strip
__builtin_IB_OCL_2darr_sample_l
image2d_array_t
Expect SubBlock
.lcomm
__builtin_IB_OCL_3d_sample_l
SimdMode:MDC_SM3
Invalid bitcode wrapper header
.rep
__builtin_IB_OCL_1d_sample_d
.bundle_align_mode
vec_type_hint
.ifeq
__builtin_IB_OCL_1darr_sample_d
atomic_isub
igc-legalize-function-signatures
.ifc
__builtin_IB_OCL_2d_sample_d
.ifle
Set builtin MetaData
.else
__builtin_IB_OCL_2darr_sample_d
 HWords from scratch base
KMPLOCK
.cv_file
__builtin_IB_OCL_3d_sample_d
.cv_inline_linetable
PrivateMemStatelessSize
.cv_filechecksums
__builtin_IB_OCL_1d_sample_lui
.uleb128
deviceEnqueueEventPool
.cfi_def_cfa
__builtin_IB_OCL_1darr_sample_lui
.sleb128
.cfi_remember_state
__builtin_IB_OCL_2d_sample_lui
Src1RegNum
sample_phase
.cfi_register
__builtin_IB_OCL_2darr_sample_lui
.macro
visaStackCall
.purgem
__builtin_IB_OCL_3d_sample_lui
src%d: unexpected register on this platform
size
.dc.a
__builtin_IB_OCL_1d_sample_dui
.warning
.dcb.b
__builtin_IB_OCL_1darr_sample_dui
BlockCoalescing
RestStage2
.ds.d
__builtin_IB_OCL_2d_sample_dui
.ds.w
.addrsig_sym
__builtin_IB_OCL_2darr_sample_dui
expected '(' after constantexpr cast
error: backend compiler failed build.
__builtin_IB_OCL_3d_sample_dui
image2d_buffer_t
float3x4
exp2f
__builtin_IB_write_1d_ui
packed_bool2
Encountered a .else that doesn't follow  an .if or an .elseif
__builtin_IB_write_1darr_ui
 levels deep.
packed_double2
invalid argument identifier for formal argument
__builtin_IB_write_2d_ui
packed_ulong2
too many positional arguments
__builtin_IB_write_2darr_ui
expected absolute expression
packed_long2
unknown token in expression
__builtin_IB_write_3d_ui
packed_uchar2
maximum bytes expression exceeds alignment and has no effect
__builtin_IB_write_2d_f
'.fill' directive with size greater than 8 has been truncated to 8
packed_char2
unable to emit symbol attribute
__builtin_IB_write_2darr_f
invalid '.comm' or '.lcomm' directive size, can't be less than zero
packed_ushort2
.abort detected. Assembly stopping.
__builtin_IB_frnd_ne
unexpected token in '.comm' or '.lcomm' directive
packed_short2
skip is negative
__builtin_IB_ftoh_rtn
packed_uint2
expected identifier in '.irp' directive
__builtin_IB_ftoh_rtp
expected comma in '.irpc' directive
packed_int2
unexpected token after expression in '.bundle_align_mode' directive
__builtin_IB_ftoh_rtz
The bfrev instruction component-wise reverses all the bits in src0 and stores the results in dst.
Format:
[(pred)] bfrev (exec_size) dst src0
packed_half2
explicit path specified, but no file number
__builtin_IB_dtoh_rtn
unexpected token after '.bundle_lock' directive option
packed_float2
unassigned file number in '.loc' directive
__builtin_IB_dtoh_rtp
Dot Product 2
constant
unsupported directive '.stabs'
__builtin_IB_dtoh_rtz
expected checksum kind in '.cv_file' directive
air.sample
expected function id in '
__builtin_IB_dtof_rtn
missing required field 'filename'
air.threads_per_simdgroup
air.instance_acceleration_structure
__builtin_IB_dtof_rtp
image2d_array_msaa_t
air.thread_execution_width
Line number less than zero in '.cv_inline_linetable' directive
__builtin_IB_dtof_rtz
The math instruction performs extended math function on the components in src0, or src0 and src1, and write the output to the channels of dst. The type of extended math function are based on the FC[3:0] encoding in the table below.
Format:
[(pred)] math (exec_size) dst src0 src1 <FC>
air.base_instance
.debug_frame
__builtin_IB_dtoi8_rtn
expected identifier in '.macro' directive
air.buffer
' has multiple parameters named '
__builtin_IB_dtoi8_rtp
igc.read_only_array
' in file, no current macro definition
__builtin_IB_dtoi8_rte
pointless default value for required parameter '
isGlobalSizeGT0
.warning directive invoked in source file
__builtin_IB_dtoi16_rtn
The not instruction performs logical NOT operation (or one's complement) of src0 and storing the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
A register source operand can use a source modifier:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the NOT operation.
Format:
[(pred)] not[.cmod] (exec_size) dst src0
TessInputControlPointCount
unexpected token in .reloc directive
__builtin_IB_dtoi16_rtp
expected double quoted string after .print
air-propagate-assumptions
literal value not a power of two greater then zero
__builtin_IB_dtoi16_rte
byte ptr 
denorm_or_zero
xword ptr 
__builtin_IB_dtoi32_rtn
air.get_thread_index_in_quadgroup
invalid escape sequence (unrecognized character)
__builtin_IB_dtoi32_rtp
acq_rel
air.get_dispatch_threads_per_threadgroup
vscanf
__builtin_IB_dtoi32_rte
vsnprintf
air.sampler_state
The not instruction performs logical NOT operation (or one's complement) of src0 and storing the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
A register source operand can use a source modifier:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). Such a source modifier is not particularly useful with the not instruction, as it changes the effect of not to just copying bits.
Format:
[(pred)] not[.cmod] (exec_size) dst src0
__builtin_IB_dtoi64_rtn
The smov instruction moves the components in src0 into dst.
For each enabled channel, copy src0 to dst. The immediate is used to selectively enable channels without using flags.
When predication is enabled, the predicate mask is not generated from the flags. Instead, the immediate is used to mask the execution mask. If any channel is enabled as a result of this masking, the instruction is executed.
When predication is not enabled, the immediate masks the execution mask. This provides flexibility to mask out any channel with an immediate.
Format:
[(pred)] smov[.cmod] (exec_size) dst src0 src1
When predication is disabled, the immediate provides the flexibility to perform a select operation without the use of flags.
When predication is enabled, the usage model provides flexibility to select any bit in the flag registers for predication for execution size of 1.
air.concurrent_dispatch_threadgroups_compute_command
.secrel32
__builtin_IB_dtoi64_rtp
.linkonce
AirFastFlagPropagationMark
.seh_startchained
__builtin_IB_dtoi64_rte
Output the .llvm generated from TransformBlocks pass
rgb9e5
.seh_savexmm
__builtin_IB_dtoui8_rtn
unexpected token in section switching directive
rg16snorm
conflicting section flags 'b' and 'd'.
__builtin_IB_dtoui8_rtp
same_size
instance_acceleration_structure
unrecognized COMDAT type '
__builtin_IB_dtoui8_rte
image2d_msaa_depth_t
half4x2
floor
__builtin_IB_dtoui16_rtn
vfabsf
air.quadgroup_index_in_threadgroup
right operand to operator must be floating point (append a .0 to force floating point)
__builtin_IB_dtoui16_rtp
NaN payload overflows
air.vertex
.secure_log_reset
__builtin_IB_dtoui16_rte
EOT is only allowed on send instructions
Loop Exit Canonicalization Pass
.cstring
__builtin_IB_dtoui32_rtn
.fvmlib_init1
MaxNumOfPatchConstantSignatureEntries
.literal4
__builtin_IB_dtoui32_rtp
label redefinition 
igc-workaround-FP16Div
.objc_category
__builtin_IB_dtoui32_rte
.objc_cls_meth
AirRWModification
.objc_message_refs
__builtin_IB_dtoui64_rtn
invalid destination register number (%s only has %d registers on this platform)
air.visible_function_references
.objc_symbols
__builtin_IB_dtoui64_rtp
.objc_meth_var_types
igc-metadata-schema-wrapper
.ident
__builtin_IB_dtoui64_rte
unbound identifier
air.no_perspective
indirect symbol not in a symbol pointer or stub section
__builtin_IB_itof_rtn
unexpected token in '.indirect_symbol' directive
IGC::PositionOnlyVertexShader
expected string in '.dump' or '.load' directive
__builtin_IB_itof_rtp
rndd
igc-const-prop
__const_coal
__builtin_IB_itof_rtz
ignoring directive .load for now
NAN handling
.popsection without corresponding .pushsection
__builtin_IB_uitof_rtn
scratch index is out of bounds
Unsafe Optimizations Pass
invalid '.tbss' directive size, can't be less thanzero
__builtin_IB_uitof_rtp
expected segment name after '.zerofill' directive
llvm.loop
invalid '.zerofill' directive alignment, can't be less than zero
__builtin_IB_uitof_rtz
Print Module IR
__builtin_IB_itofp64_rtn
vISA_useMultiThreadedLatencies
vISA_UnifiedSendCycle
__mod_term_func
__builtin_IB_itofp64_rtp
__igcbuiltin_dp_sqrt
vISA_Compaction
__class
__builtin_IB_itofp64_rtz
__inst_meth
vISA_SymbolReg
__module_info
__builtin_IB_uitofp64_rtn
Remainder
kernel_arg_access_qual
__thread_data
__builtin_IB_uitofp64_rtp
invalid OS major version number, integer expected
vISA_DumpIsaVarNames
vISA_UniqueLabels
__builtin_IB_uitofp64_rtz
vISA_DumpvISA
platform name expected
fpmath
__builtin_IB_frnd_pi
invalid OS update version number
.data.rel
debug-pass
__builtin_IB_frnd_ni
Executions
vISA_encoderFile
.hidden
__builtin_IB_frnd_zi
.fini_array.
vISA_InitPayload
Section cannot specifiy a group name while also acting as a member of the last group
__builtin_IB_native_cosf
DPEmuzext
vISA_clearScratchWritesBeforeEOT
progbits
__builtin_IB_native_cosh
.note
vISA_setFFID
expected '@<type>', '%<type>' or "<type>"
__builtin_IB_native_sinf
entry size must be positive
vISA_setStartBreakPoint
invalid metadata symbol
__builtin_IB_native_sinh
VISA_AsmFileNameUser
opt-bisect-limit
expected symbol type in directive
__builtin_IB_native_exp2f
Unnamed pass: implement Pass::getPassName()
NumCounts
non-global-value-max-name-size
__builtin_IB_native_exp2h
Type size nodes must be constants!
Bitwidth between the offsets and struct type entries must match
.rela
__builtin_IB_native_log2f
.symtab_shndxr
-dumpPassesLocation
Function context does not match Module context!
__builtin_IB_native_log2h
FK_PCRel_2
cmpxchg failure argument shall be no stronger than the success argument
floorf
__builtin_IB_native_sqrtf
r16snorm
-emitLocation
FK_SecRel_2
__builtin_IB_native_sqrth
FK_DTPRel_4
-enableWriteFusion
FK_Data_Sub_2
__builtin_IB_native_sqrtd
Scalarize functions
-nomacopt
Disable
__builtin_IB_popcount_1u32
.code32
-nofoldaddrimmed
.asciz
__builtin_IB_popcount_1u16
inrange 
-nomac
fragment covers entire variable
__builtin_IB_popcount_1u8
.lshr
-disableStructurizer
__builtin_IB_native_powrf
fix-fast-math-flags
-ALTMode
sleb128 and uleb128 expressions must be absolute
__builtin_IB_fma
-nolvn
__builtin_IB_fmah
__svml_cos2
-no4GRFSplit
filechecksums_begin
__builtin_IB_bfi
unable to write nop sequence of 
-forceSamplerHeader
Instruction has null operand!
__builtin_IB_ibfe
__svml_cos8
-disableMixMode
nonnull applies only to load instructions, use attributes for calls or invokes
__builtin_IB_ubfe
igc-emu64ops
-noalign1ternary
.bundle_lock forbidden when bundling is disabled
__builtin_IB_bfrev
sgid
-noFP64bRegion
__builtin_IB_fmax
<<invalid>>
-noipa
GOTOFF
__builtin_IB_fmin
INDNTPOFF
-noindirectforcespills
TLSGD
__builtin_IB_HMAX
write
-nofailsafera
TLVPPAGEOFF
__builtin_IB_HMIN
MarkReadOnlyLoadPass
-nosplitllr
WEAKREF
__builtin_IB_dmin
target2
-noremat
tlsdescseq
__builtin_IB_dmax
callees
-TotalGRFNum
__builtin_IB_mul_rtz_f64
hlo8
-enableBCR
tocbase
__builtin_IB_mul_rtz_f32
funcThen
-nopresched
tprel@ha
__builtin_IB_fma_rtz_f64
tprel@highera
-dumpSchedule
dtprel@h
__builtin_IB_fma_rtz_f32
dtprel@higher
-noDD-lookback
got@tprel
__builtin_IB_add_rtz_f64
dtprel@higha
-dump-noSrcDep
got@tlsgd
__builtin_IB_add_rtz_f32
IndirectCallOptimization
-noWAWSubregHazardAvoidance
tlsld
__builtin_IB_thread_group_barrier
got@tlsgd@ha
-HWThreadNumberPerEU
GDPLT
__builtin_IB_thread_group_barrier_signal
, insts: 
-nobxmlencoder
__builtin_IB_thread_group_barrier_wait
.fix1.bitcast
Fix invalid addrspacecast-relevant patterns
-printasmcount
<MCFixup
__builtin_IB_memfence
read_write
-genIsaasmList
MCRelaxableFragment
__builtin_IB_flush_sampler_cache
MCLEBFragment
-isaasmNamesOutputFile
MCCVDefRangeTableFragment
__builtin_IB_typedmemfence
 HasInstructions:
-decodedbg
 ValueSize:
__builtin_IB_simd_lane_id
kernel_arg_type
-initializePayload
ceil
__builtin_IB_vme_send_ime
-noFFIDProlog
 InstSize:
__builtin_IB_vme_send_fbr
unable to evaluate offset to undefined symbol '
__builtin_IB_vme_send_sic
-hashmovs
__eh_frame
__common
__builtin_IB_vme_send_fbr_new
__DWARF
-dumpToCurrentDir
help-list
__builtin_IB_vme_send_sic_new
image1d_array
-stepping
__swift_ast
__builtin_IB_vme_send_ime_new_uint4_uint8
__debug_line_str
USAGE: -spilloffset <offset>
__debug_pubtypes
__builtin_IB_vme_send_ime_new_uint8_uint8
__debug_str_offs
USAGE: -abortonspillthreshold <threshold>
__debug_ranges
__builtin_IB_vme_send_ime_new_uint4_uint4
USAGE: -presched-rp <threshold>
image2d_array_msaa_depth
debug-counter
__builtin_IB_vme_send_ime_new_uint8_uint4
USAGE: -unifiedSendCycle <cycle>
LLVM ERROR: 
Allocation failed
__builtin_IB_set_message_phase_legacy_dw
USAGE: -decodedbg <dbg filename>
Running 'xdot.py' program... 
__builtin_IB_set_message_phase_legacy_uw
bindless_sampler_t
PurgeMetaDataUtilsImport
Breakdown intrinsics into simpler operations to enable better optimization
__builtin_IB_set_message_phase_legacy_ub
USAGE: missing stepping string. 
breakdown-intrinsics
Allocation failed
__builtin_IB_set_message_phase_legacy
.debug_cu_index
NULL
armv3
__builtin_IB_create_message_phases
BreakdownIntrinsicPass
IR_Build
__builtin_IB_create_message_phases_uint2
double type is not supported on this platform
Misc_opts
armv6-m
__builtin_IB_create_message_phases_uint4
Cannot initialize MC for unknown object file format.
GRF_Hybrid_RA
Cannot evaluate subsection number
__builtin_IB_create_message_phases_uint8
__svml_logf8
preRA_Scheduling
      
__builtin_IB_create_message_phases_no_init
11ocl_image1d
IGA_Encoding
,#exclude
__builtin_IB_create_message_phases_no_init_uint2
VB_Create_Var
kernel_arg_base_type
__builtin_IB_create_message_phases_no_init_uint4
always-inline
mach-o section specifier of type 'symbol_stubs' requires a size specifier
__builtin_IB_create_message_phases_no_init_uint8
mips64
sparcv9
4byte_literals
__builtin_IB_get_message_phase_dw
literal_pointers
..., 
netbsd
__builtin_IB_get_message_phase_dw_uint2
mod_init_funcs
enable-coldcc-stress-test
contiki
__builtin_IB_get_message_phase_dw_uint4
20ocl_image1d_array
globalopt
enable-fmax-fmin-plus-zero
__builtin_IB_get_message_phase_dw_uint8
S_THREAD_LOCAL_ZEROFILL
smallstring:"
S_THREAD_LOCAL_VARIABLE_POINTERS
__builtin_IB_get_message_phase_uq
[:>:]]
strip_static_syms
__builtin_IB_get_message_phase_uq_uint2
S_ATTR_LIVE_SUPPORT
space
__builtin_IB_get_message_phase_uq_uint4
Fix the alignment of loads and stores according to OpenCL rules
Function Integration/Inlining
__builtin_IB_get_message_phase_uq_uint8
.seh_ directive must appear within an active frame
basic
__builtin_IB_set_message_phase_dw
11ocl_image2d
Enable inliner stats for imported functions
quotation-mark
__builtin_IB_set_message_phase_dw_uint2
__builtin_IB_get_local_lock
Callee
solidus
__builtin_IB_set_message_phase_dw_uint4
symbol '
AlwaysInline
round
__builtin_IB_set_message_phase_dw_uint8
__builtin_IB_atomic_add_local_i32
 align 
REG_0x%x
__builtin_IB_get_message_phase_uw
!<unknown kind #
IncreaseCostInOtherContexts
hidden 
__builtin_IB_get_message_phase_uw_uint2
dllexport 
parse
alignstack 
__builtin_IB_get_message_phase_uw_uint4
westmere
bitcode-mdindex-threshold
; ModuleID = '
__builtin_IB_get_message_phase_uw_uint8
__builtin_IB_atomic_xchg_local_i32
Invalid encoding
 = { 
__builtin_IB_set_message_phase_uw
Write Bitcode
GenX CodeGen module
__builtin_IB_set_message_phase_uw_uint2
skylake-avx512
PATH
__builtin_IB_set_message_phase_uw_uint4
Value: [null]
Disable symbolizing crash backtraces.
__builtin_IB_set_message_phase_uw_uint8
DW_TAG_imported_declaration
constant bigger than 128 bits detected!
type: 
__builtin_IB_get_message_phase_ub
(offset: 
invalid value number (too large)!
musttail 
__builtin_IB_get_message_phase_ub_uint2
wchar_size
available_externally
__builtin_IB_get_message_phase_ub_uint4
 atomic
undef
 unwind 
__builtin_IB_get_message_phase_ub_uint8
inalloca 
 reassoc
 ninf
__builtin_IB_set_message_phase_ub
 afn
alias
DW_AT_language
__builtin_IB_set_message_phase_ub_uint2
 sub
x86_stdcallcc
DW_AT_return_addr
__builtin_IB_set_message_phase_ub_uint4
 umax
arm_apcscc
 ; (
__builtin_IB_set_message_phase_ub_uint8
 preds = 
ptx_kernel
DW_AT_vtable_elem_location
__builtin_IB_get_message_phase
20ocl_image2dmsaadepth
intel_ocl_bicc
DW_AT_small
__builtin_IB_get_message_phase_uint2
<placeholder or erroneous Constant>
webkit_jscc
DW_AT_enum_class
__builtin_IB_get_message_phase_uint4
igc-gen-ir-lowering
preserve_allcc
, summaries: (
__builtin_IB_get_message_phase_uint8
, notEligibleToImport: 
hhvm_ccc
DW_AT_MIPS_loop_begin
__builtin_IB_set_message_phase
25ocl_image2darraymsaadepth
amdgpu_hs
, calls: (
__builtin_IB_set_message_phase_uint2
, typeIdInfo: (
amdgpu_cs
, offset: 
__builtin_IB_set_message_phase_uint4
typeTestRes: (kind: 
builtin
DW_AT_BORLAND_Delphi_ABI
__builtin_IB_set_message_phase_uint8
, resByArg: (
convergent
DW_AT_APPLE_property_setter
__builtin_IB_broadcast_message_phase_ub
16ocl_image2ddepth
inaccessiblemem_or_argmemonly
DW_OP_dup
__builtin_IB_broadcast_message_phase_ub_uint2
minsize
DW_OP_plus
__builtin_IB_broadcast_message_phase_ub_uint4
igc-shuffle-simplification
nocapture
ctpop.trunc
__builtin_IB_broadcast_message_phase_ub_uint8
__builtin_IB_atomic_cmpxchg_global_f32
norecurse
DW_OP_lit18
__builtin_IB_broadcast_message_phase_uw
vpmovm2
noreturn
DW_OP_reg2
__builtin_IB_broadcast_message_phase_uw_uint2
__builtin_IB_atomic_cmpxchg_local_f32
optsize
DW_OP_reg18
__builtin_IB_broadcast_message_phase_uw_uint4
GeometryShaderLowering
returns_twice
__builtin_IB_broadcast_message_phase_uw_uint8
Unknown specifier in datalayout string
DW_OP_breg18
__builtin_IB_broadcast_message_phase_dw
24IGIL_EnqueueKernelShared9ocl_queuejPvjS_S_jS_jiPi9ndrange_tii12ocl_clkevent
safestack
DW_OP_bregx
__builtin_IB_broadcast_message_phase_dw_uint2
DIFlagPublic
sanitize_thread
DW_OP_constx
__builtin_IB_broadcast_message_phase_dw_uint4
uwtable
DIFlagStaticMember
__builtin_IB_broadcast_message_phase_dw_uint8
DIFlagMultipleInheritance
exactmatch
DW_VIRTUALITY_pure_virtual
__builtin_IB_broadcast_message_phase_uq
18IGIL_EnqueueKernel9ocl_queuejPvjS_S_jS_j9ndrange_ti12ocl_clkevent
DW_LANG_ObjC
__builtin_IB_broadcast_message_phase_uq_uint2
Expected mangling specifier in datalayout string
name
DW_LANG_Dylan
__builtin_IB_broadcast_message_phase_uq_uint4
pass-remarks-analysis
critical
DW_CC_BORLAND_safecall
__builtin_IB_broadcast_message_phase_uq_uint8
__builtin_IB_atomic_and_global_i64
typeTestAssumeConstVCalls
!Analysis
__builtin_IB_simd_set_message_phase_ub
 at byte position 
single
Args
__builtin_IB_simd_set_message_phase_ub_uint2
Line
Verify dominator info (time consuming)
__builtin_IB_simd_set_message_phase_ub_uint4
Delete, 
mme5
(badref)
__builtin_IB_simd_set_message_phase_ub_uint8
(no_name)(
token
MT1R_MB
__builtin_IB_simd_set_message_phase_uw
igc-legalize-global-value-usages
extractelement
MT1W_A64_SB
__builtin_IB_simd_set_message_phase_uw_uint2
__builtin_IB_get_stage_in_grid_origin
use of undefined type named '
MT_RTW
__builtin_IB_simd_set_message_phase_uw_uint4
stage_in_grid_size_y
use of undefined summary '^
enqueued_local_size_z
__builtin_IB_simd_set_message_phase_uw_uint8
num_work_groups_y
unknown target property
Typed Surface Read
__builtin_IB_simd_set_message_phase_dw
14enqueue_marker9ocl_queuejPKU3AS412ocl_clkeventPU3AS412ocl_clkevent
expected '=' after deplibs
Oword Block Read Constant Cache
__builtin_IB_simd_set_message_phase_dw_uint2
virtual_binding_table_ps
non-struct types may not be recursive
Advanced MemOpt
__builtin_IB_simd_set_message_phase_dw_uint4
air.get_size_visible_function_table
air.is_null_visible_function_table
air.get_buffer_visible_function_table
__builtin_IB_simd_set_message_phase_dw_uint8
unknown selection kind
7033
__builtin_IB_simd_set_message_phase_uq
11read_imagef14ocl_image2d_ro11ocl_samplerDv2_fS_S_
expected end of metadata node
SLM fence
__builtin_IB_simd_set_message_phase_uq_uint2
__builtin_IB_atomic_min_global_u16
expected ':' at start of summary entry
 constant data
__builtin_IB_simd_set_message_phase_uq_uint4
air.atomic_compare_exchange_weak_explicit_texture
invalid linkage type for alias
7086
__builtin_IB_simd_set_message_phase_uq_uint8
bindless_image2d_msaa_depth_t
An alias or ifunc must have pointer type
7071
__builtin_IB_simd_get_message_phase_uw
11read_imagei14ocl_image2d_ro11ocl_samplerDv2_fS_S_
forward reference and definition of alias have different types
MSD1W_A64_OWDB
__builtin_IB_simd_get_message_phase_uw_uint2
texture2d_ms
unknown global variable property!
__builtin_IB_simd_get_message_phase_uw_uint4
texture2d_ms_array
attribute group has no attributes
skip
__builtin_IB_simd_get_message_phase_uw_uint8
llvm.dbg.cu
invalid use of parameter-only attribute on a function
unsupported DC1 op
__builtin_IB_simd_get_message_phase_uq
12read_imageui14ocl_image2d_ro11ocl_samplerDv2_fS_S_
expected string constant
signal event
__builtin_IB_simd_get_message_phase_uq_uint2
7048
expected ')' after thread local model
.f32
__builtin_IB_simd_get_message_phase_uq_uint4
opencl.used.optional.core.features
invalid use of parameter-only attribute
ffsl
__builtin_IB_simd_get_message_phase_uq_uint8
opencl.kernels
alignment is not a power of two
__builtin_IB_extract_mv_and_sad
11read_imagef20ocl_image2d_depth_ro11ocl_samplerDv2_fS_S_
dereferenceable bytes must be non-zero
sample+LOD bias
__builtin_IB_cmp_sads
Expected '(' in syncscope
sample_killpix
__builtin_IB_simdMediaRegionCopy
Invalid type
stack alignment is not a power of two
sample_ld2dms_w
__builtin_IB_ieee_sqrt
Operand bundles found with no consumer
void type only allowed for function results
sample_unorm_killpix_media
__builtin_IB_ieee_divide
11read_imagef20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
pointers to void are invalid; use i8* instead
DataElements:MDC_A64_DB_OW
__builtin_IB_ieee_divide_f64
__builtin_IB_atomic_xor_local_i16
unexpected ellipsis in argument list for 
absent
__builtin_IB_va_erode_64x4
Invalid type for value
expected '...' at end of argument list for musttail call in varargs function
DE8 (8 data elements per addr.)
__builtin_IB_va_dilate_64x4
Expect function block
argument can not have void type
no channels enabled
__builtin_IB_va_minmaxfilter_16x4_SLM
11read_imagei20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
argument attributes invalid in function type
returns new value
__builtin_IB_va_convolve_16x4_SLM
work_group_size_hint
invalid element type for struct
atomic_iipdec
__builtin_IB_va_convolve_16x1
llvm.
expected end of sequential type
integer compare and swap (non-64b)
__builtin_IB_va_convolve_16x4
igc-process-builtin-metaData
invalid array element type
PerSlotOffsetPresent
__builtin_IB_va_minmax
12read_imageui20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
ProcessFuncAttributes
referenced-indirectly
__builtin_IB_va_centroid
typed_store
multiple definition of local value named '
DstDataType
__builtin_IB_va_boolcentroid
deviceEnqueueParentEvent
expected end of constant
vmeSadAdjustMode
__builtin_IB_va_boolsum
 is not of type '
Src0RegNum
__builtin_IB_WaveBallot
11read_imagef26ocl_image2d_array_depth_ro11ocl_samplerDv4_fDv2_fS0_
expected string
nop doesn't support Switch option (dropping)
__builtin_IB_samplepos
 undefined reference to `jmp()' 
expected comma in block address expression
src%d: unsupported source operand kind (malformed IR)
__builtin_IB_dp4a_ss
IGCMetadata
referenced value is not a basic block
Src0MathMacroExt
__builtin_IB_dp4a_uu
igc-resolve-atomics
expected ')' at end of constantexpr cast
Src2MathMacroExt
__builtin_IB_dp4a_su
// File: 
Operand::Kind::?
simd
__builtin_IB_dp4a_us
imageNumMipLevels
expected comma in insertvalue constantexpr
on <v;h> region w must be Region::WI_INVALID
mcsl
WorkaroundAnalysis Pass
Check individual type of instructions
mcsh
no mapping for descriptors
float2x4
float3x3
imcsl
packed_bool4
BAD,
xga8
imcsh
packed_double3
nuw only applies to integer operations
cbl128
gradXZ
Ensures single precision divide and sqrt are correctly rounded
expected '(' in logical constantexpr
gradYZ
igc-correctly-rounded-div-sqrt
expected '(' in constantexpr
gradXY
packed_uchar4
grid
gradYY
char3
packed_char
packed_char3
gradXX
null
packed_ushort
gradYX
packed_short3
global values must be constants
__precompiled_udiv
12write_imagei14ocl_image3d_woDv4_iS_
expected '!' here
__precompiled_udiv2
packed_int3
missing required field 'count'
Bit Field Insert 2
__precompiled_udiv3
uint
missing required field 'baseType'
The call instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the call instruction. If none of the channels jump into the subroutine, the call instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
When SPF is on, the predication control must be scalar.
The following section describes JIP, the jump offset, for DevHSW+.
JIP can be an immediate or register value. When a jump occurs, this value is added to IP pre-increment. For DevHSW+, in GEN binary, JIP is at location src1 and src0 must be null. The GRF register must be put (for example, by the assembler) at dst location.
Format: [(pred)] call (exec_size) dst JIP
Format: [(pred)] call (exec_size) dst JIP
__precompiled_udiv4
packed_float3
'checksumkind' and 'checksum' must be provided together
__precompiled_udiv8
12write_imagei14ocl_image3d_rwDv4_iS_
missing 'distinct', required for !DISubprogram when 'isDefinition'
Else
__precompiled_udiv16
ushort2
expected '(' here
The fbl instruction counts component-wise the number of LSB 0 bits before the first 1 bit in src0, storing that number in dst.
Format:
[(pred)] fbl (exec_size) dst src0
If src0 contains no 1 bits, store 0xFFFFFFFF in dst.
__precompiled_umod
air.alias_implicit_imageblock_render_target
expected ')' here
line
__precompiled_umod2
TRIVIAL_RA
expected metadata operand
Multiply Add
__precompiled_umod3
air.threads_per_grid
integer constant must have integer type
air.vertex_id
__precompiled_umod4
air.emulation_argument
invalid type for undef constant
IREM
__precompiled_umod8
constant expression type mismatch
__precompiled_umod16
threads_per_grid_end
 of struct initializer doesn't match struct element type
No Operation
__precompiled_sdiv
12write_imagei16ocl_image2d_array_woDv4_iS_
invalid function linkage type
The rndd instruction takes component-wise floating point downward rounding (to the integral float number closer to negative infinity) of src0 and storing the rounded integral float results in dst. This is commonly referred to as the floor() function.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rndd[.cmod] (exec_size) dst src0
__precompiled_sdiv2
Analyzes device enqueue functions
'builtin' attribute not valid on function
__precompiled_sdiv3
denorm_exp
' with wrong type!
Pass legalizes texture and sampler addrspaces from GLOBAL/CONSTANT to indirect
__precompiled_sdiv4
__builtin_IB_get_group_id
' disagree
The cont instruction disables execution for the subset of channels for the remainder of the current loop iteration. Channels remain disabled until right before the while instuction or right before the condition check code block for the while instruction. If all enabled channels hit this instruction, jump to the instruction referenced by JIP where execution continues.
UIP should always reference the loop's associated while instruction. JIP should point to the last instruction of the inner most conditional block if the cont instruction is inside a conditional block. In case of the break instruction directly under the loop, the JIP and the UIP are the same.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] cont (exec_size) JIP UIP
__precompiled_sdiv8
12write_imagei20ocl_image2d_array_rwDv4_iS0_
unable to create block named '
Multiply Add for Macro
__precompiled_sdiv16
cubeMapCoordArray
expected instruction opcode
Perform component-wise logical left shift of the bits in src0 by the shift count indicated in src1, storing the results in dst, inserting zero bits in the number of LSBs indicated by the shift count.
Hardware detects overflow properly and uses it to perform any saturation operation on the result, as long as the shifted result is within 33 bits. Otherwise, the result is undefined.
Note: For word and DWord operands, the accumulators have 33 bits.
In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
Format:
[(pred)] shl[.cmod] (exec_size) dst src0 src1
__precompiled_smod
AIR Function Attribute Update
branch condition must have 'i1' type
Conditional Split Send Message
__precompiled_smod2
TransformBlocksOutput
WAFMinFMax
KMPLOCK
__precompiled_smod3
rgba16snorm
rg11b10f
AirEmulateArgumentBuffers
__precompiled_smod4
__get_kernel_work_group_size_impl
expected ']' at end of block list
unsupported Align16 ternary destination (unsupported SIMD)
__precompiled_smod8
rgba8snorm
too many arguments specified
) accessing GED_
__precompiled_smod16
ThreadGroupSize_X
expected '[' in catchpad/cleanuppad
half3x2
precompiled_u32divrem
register number out of bounds
expected 'from' after catchret
(integral) division by zero
precompiled_s32divrem
air.kernel
expected '[' with catchswitch labels
Atomic mot supported on given platform
precompiled_u32divrem_sp
air.location
expected 'within' after catchpad
N3 is obsolete; use M8 in execution offset: e.g. op (4|M8) ...
precompiled_s32divrem_sp
HSEntry
expected ',' in arithmetic operation
default_register_type
__igcbuiltin_dp_add
29intel_work_group_vme_mb_queryPU3AS3jDv2_iS1_14ocl_image2d_roS2_11ocl_sampler
expected ',' after compare value
expected 'b' (branch control)
__igcbuiltin_dp_sub
N7 is obsolete; use M24 in execution offset: e.g. op (4|M24) ...
expected ',' after select value
use 
__igcbuiltin_dp_fma
Translate AI
expected ',' after insertelement value
labs
__igcbuiltin_dp_mul
fast_math_enable
expected '[' in phi value list
noacc
__igcbuiltin_dp_div
12DoMultiQueryPU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_samplerj
'filter' clause has an invalid type
implicit type on src should be omitted
__igcbuiltin_dp_cmp
expected 'tail call', 'musttail call', or 'notail call'
Advanced DCE on loop
ThreadGroupSize_Z
__igcbuiltin_dp_to_int32
out of dynamic memory in yy_scan_bytes()
37intel_work_group_vme_mb_multi_query_8PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_sampler
LastPatternMatch Pass
__igcbuiltin_dp_to_uint32
Gen strength reduction
store operand must be a pointer
FCmpPaternMatch
__igcbuiltin_int32_to_dp
stored value and pointer type do not match
succeeded
HoistFMulInLoopPass
__igcbuiltin_uint32_to_dp
expected ',' after cmpxchg cmp operand
fminf
llabs
__igcbuiltin_dp_to_sp
vISA_ReorderDPSendToDifferentBti
Print BasicBlock IR
unreachable
catchpad
fsub
udiv
frem
atomicrmw
trunc
fptoui
fptosi
icmp
select
va_arg
insertelement
.legal
selected values for vector select must be vectors
false
DPEmuFlag
alias.scope
section_prefix
irr_loop
singlethread
Allocation failed
print pass structure before run()
Details
Print IR after specified passes
print-after-all
function names
IRSizeChange
 on module '
Pass '
- Corruption of the global PassRegistry
' is not preserving '
 Free these instances
'...
' on Function '
Used
FunctionPass Manager
Module Pass Manager
DPEmuCmp
branch_weights
,data
expected 'unique'
Allocation failed
PreCompiledFuncImport
) in function (
BISECT: 
Two passes with the same argument (-
vISA_dumpPayload
Allocation failed
Multiple symbol versions defined for 
Offset entries must be constants!
Could not find TBAA parent in struct type node
Access tag metadata must have either 4 or 5 operands
Malformed struct tag metadata: base and access-type should be non-null and point to Metadata nodes
Offset must be constant integer
' does not have terminator!
# formal arguments must match # of arguments for function type!
Calling convention requires void return type
Calling convention does not allow sret
Referencing personality function in another module!
function declaration may not have a !prof attachment
function must have a single !dbg attachment
DISubprogram attached to more than one function
Only global variables can have appending linkage!
GlobalValue with DLLImport Storage is dso_local!
Global is referenced in a different module!
Global is used by function in a different module
Cannot have multiple 'sret' parameters!
Cannot have multiple 'swifterror' parameters!
Attributes 'readnone and inaccessiblemem_or_argmemonly' are incompatible!
Attributes 'noinline and alwaysinline' are incompatible!
number of elements
Attributes 'sret and returned' are incompatible!
Attribute 'byval' only applies to parameters with pointer type!
igc-scalarize
swifterror value should be the second operand when used by stores
first operand should not be null
Invalid operand for global metadata!
All nodes should be resolved!
fragment is larger than or outside of variable
Count must either be a signed constant or a DIVariable
DWARF address space only applies to pointer or reference types
invalid file
invalid template params
invalid checksum length
invalid enum type
invalid retained type
invalid macro ref
invalid containing type
subprogram definitions must be distinct
Fix Fast Math Flags
anonymous module
missing global variable type
invalid imported entity
anonymous macro
Basic Block does not have terminator!
PHI node has multiple entries for the same basic block with different incoming values!
Function return type does not match operand type of return inst!
Terminator found in the middle of a basic block!
Use of instruction is not an instruction!
Cannot take the address of an intrinsic!
Referencing global in another module!
fpmath requires a floating point result!
nonnull applies only to pointer types
align applies only to load instructions, use attributes for calls or invokes
invalid !dbg metadata attachment
__builtin_spirv_BuiltInWorkgroupId
The upper limit must be an integer!
Intervals are overlapping
dereferenceable, dereferenceable_or_null take one operand!
Branch condition is not 'i1' type!
Called function must be a pointer!
Called function requires more parameters than were provided!
swifterror argument for call has mismatched alloca
swifterror argument should come from an alloca or parameter
Multiple deopt operand bundles
Expected exactly one funclet bundle operand
Intrinsic has incorrect argument type!
Callsite was not defined with variable arguments!
addr
isvolatile argument of memory intrinsics must be a constant int
incorrect alignment of the destination argument
mark-readonly-load
size argument of memory use markers must be a constant integer
multiple calls to llvm.localescape in one function
gc.result operand #1 must be from a statepoint
wrong number of arguments
gc.relocate operand #2 must be integer offset
gc.relocate: statepoint derived index out of bounds
gc.statepoint: number of deoptimization arguments must be a constant integer
gc.relocate: statepoint base index doesn't fall within the 'gc parameters' section of the statepoint call
masked_load: mask must be vector
masked_load: vector mask must be same length as data
experimental_guard must have exactly one "deopt" operand bundle
experimental_deoptimize must have exactly one "deopt" operand bundle
invalid rounding mode argument
 intrinsic variable
 variable and !dbg attachment
endIndirectCallBB
gc.statepoint callee must be of function pointer type
gc.statepoint mismatch in number of vararg call args
gc.statepoint call argument does not match wrapped function type
gc.statepoint number of transition arguments must be positive
gc.result connected to wrong gc.statepoint
The resume instruction should have a consistent result type inside a function.
CatchSwitchInst not the first non-PHI instruction in the block.
CatchSwitchInst has an invalid parent.
Catchswitch cannot unwind to one of its catchpads
EH pad cannot handle exceptions raised within it
Integer arithmetic operators must have same type for operands and result!
Floating-point arithmetic operators must have same type for operands and result!
Cannot allocate unsized type
loading unsized types is not allowed
atomic load operand must have integer, pointer, or floating point type!
indirect-call-optimization
Non-atomic store cannot have SynchronizationScope specified
GEP indexes must be integers
All GEP indices should be of integer type
cmpxchg instructions must be atomic.
atomicrmw instructions must be atomic.
atomicrmw operand must have integer type!
trunc source and destination must both be a vector or neither
DestTy too big for Trunc
sext source and destination must both be a vector or neither
FPToUI source must be FP or FP vector
FPToSI result must be integer or integer vector
UIToFP source and dest must both be vector or scalar
SIToFP result must be FP or FP vector
FPTrunc only produces an FP
fpext source and destination must both be a vector or neither
FixDeadVisibleFunctions
IntToPtr type mismatch
AddrSpaceCast result must be a pointer
CleanupPadInst has an invalid parent.
Bogus funclet pad use
Both operands to ICmp instruction are not of the same type!
Both operands to FCmp instruction are not of the same type!
PHI node operands are not the same type as the result!
cannot use musttail call with inline asm
bitcast following musttail call must use the call
Invalid operands for select instruction!
Invalid shufflevector operands!
Invalid InsertValueInst operands!
Filter operand is not an array of constants!
Global variable initializer type does not match global variable type!
invalid linkage for intrinsic global variable
image2d
Aliasee should be either GlobalValue or ConstantExpr
Alias cannot point to an interposable alias
invalid requirement on flag, flag does not have the required value
invalid behavior operand in module flag (expected constant integer)
invalid value for 'append'-type module flag (expected a metadata node)
'Linker Options' named metadata no longer supported
ldrawvector_indexed@
ldstructured@
%.9lu
    =
    -
Generic Options
help-list-hidden
print-options
print-all-options
inconsistency in registered CommandLine options
error - option can never match, because another positional argument will match an unbounded number of values, and this option does not require a value!
: Did you mean '-
: Too many positional arguments specified!
must be specified at least once!
not enough values!
  This option category has no options.
  Type "
 version 
image2d_array_msaa
: for the -
FPImm:
DebugCounter Error: 
-easyisaasm
LLVM ERROR: out of memory
'... 
xdg-open
USAGE: -hashmovs hi32 lo32
.debug_addr
Included from 
error: 
warning: 
note: 
remark: 
.debug_line.dwo
armv2
armv4t
armv5te
armv5tej
armv6k
v7ve
__cospi
armv8-m.base
__memset_chk
__nvvm_reflect
__sinpi
0x7000001e
llvm.genx.GenISA.GlobalSizeLocation
llvm.genx.GenISA.OutputTessFactors
llvm.genx.GenISA.createMessagePhases
Error Check
__stpncpy_chk
0123456789_.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
__strndup
__strtok_r
visaStackCall
File to append -stats and -timer output to
   ---User Time---
  --- Name ---
Total
enable-nonnull-arg-prop
riscv64
nvptx64
hsail64
cloudabi
dragonfly
macosx
solaris
nacl
mesa3d
gnux32
code16
kernel_arg_name
17ocl_image1dbuffer
stringref:"
decUI:"
decL:"
decLL:"
out of range number
storestructured1@
blank
digit
lower
!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
upper
backspace
form-feed
carriage-return
exclamation-mark
dollar-sign
right-parenthesis
plus-sign
slash
seven
__builtin_IB_atomic_add_global_i32
question-mark
backslash
underscore
grave-accent
16ocl_image2darray
 prefix 
invalid collating element
REG_EESCAPE
brackets ([ ]) not balanced
REG_EBRACE
invalid character range
out of memory
"can't happen" -- you found a bug
umulH@
bdver1
znver1
broadwell
penryn
k6-2
btver1
pentium
pentium4
pentium-m
vaConvolve@
0123456789abcdef
Size: 
TERM
Can't redirect stderr to stdout
Cannot open file '
-cl-kernel-arg-info
Unable to find target for this triple (no targets are registered)
DW_TAG_formal_parameter
DW_TAG_lexical_block
DW_TAG_string_type
DW_TAG_typedef
DW_TAG_common_inclusion
DW_TAG_inlined_subroutine
DW_TAG_access_declaration
DW_TAG_const_type
DW_TAG_namelist
DW_TAG_packed_type
DW_TAG_variant_part
DW_TAG_dwarf_procedure
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_coarray_type
DW_TAG_atomic_type
DW_TAG_MIPS_loop
DW_TAG_function_template
DW_TAG_GNU_call_site_parameter
DW_TAG_BORLAND_Delphi_string
DW_AT_location
DW_AT_name
DW_AT_high_pc
DW_AT_discr_value
DW_AT_comp_dir
DW_AT_containing_type
DW_AT_prototyped
DW_AT_bit_stride
DW_AT_artificial
__builtin_IB_atomic_max_local_u32
DW_AT_declaration
DW_AT_external
DW_AT_namelist_item
DW_AT_segment
DW_AT_virtuality
DW_AT_associated
DW_AT_extension
DW_AT_ranges
DW_AT_decimal_scale
DW_AT_digit_count
DW_AT_object_pointer
DW_AT_elemental
DW_AT_const_expr
DW_AT_string_length_bit_size
DW_AT_rnglists_base
__builtin_IB_atomic_or_global_i32
DW_AT_call_all_tail_calls
DW_AT_call_origin
DW_AT_call_target_clobbered
DW_AT_call_data_value
DW_AT_loclists_base
DW_AT_MIPS_epilog_begin
DW_AT_MIPS_abstract_name
DW_AT_MIPS_clone_origin
DW_AT_MIPS_assumed_size
DW_AT_mac_info
DW_AT_GNU_template_name
DW_AT_GNU_call_site_value
DW_AT_GNU_addr_base
DW_AT_GNU_discriminator
DW_AT_BORLAND_property_index
__builtin_IB_atomic_inc_global_i32
DW_AT_BORLAND_Delphi_interface
DW_AT_BORLAND_Delphi_frameptr
DW_AT_APPLE_optimized
DW_AT_APPLE_isa
DW_AT_APPLE_property_getter
DW_AT_APPLE_objc_complete_type
DW_OP_const1s
DW_OP_const2u
DW_OP_consts
DW_OP_over
DW_OP_abs
DW_OP_div
DW_OP_or
DW_OP_shl
DW_OP_eq
__builtin_IB_atomic_cmpxchg_global_i32
DW_OP_lit1
DW_OP_lit4
DW_OP_lit9
DW_OP_lit11
DW_OP_lit17
DW_OP_lit20
DW_OP_lit25
DW_OP_lit26
DW_OP_reg1
DW_OP_reg4
DW_OP_reg9
DW_OP_reg11
DW_OP_reg17
DW_OP_reg20
DW_OP_reg24
__builtin_IB_atomic_add_global_i64
DW_OP_breg1
DW_OP_breg4
DW_OP_breg9
DW_OP_breg11
DW_OP_breg17
DW_OP_breg20
DW_OP_breg25
DW_OP_breg26
DW_OP_fbreg
DW_OP_deref_size
DW_OP_call4
DW_OP_form_tls_address
DW_OP_addrx
DW_OP_const_type
DW_OP_reinterpret
__builtin_IB_atomic_min_global_u64
DW_ATE_float
DW_ATE_unsigned
DW_ATE_edited
DW_ATE_unsigned_fixed
DW_VIRTUALITY_virtual
DW_LANG_C
DW_LANG_Modula3
DW_LANG_C_plus_plus_03
DW_LANG_Julia
DW_LANG_Fortran03
DW_LANG_BLISS
__builtin_IB_atomic_max_global_f64
raw_sends
logb
logbf
malloc
memrchr
mkdir
llvm.genx.GenISA.PHASE.INPUT
elfiamcu
target-features
llvm.metadata
Name
R_WEBASSEMBLY_TYPE_INDEX_LEB
static-func-strip-dirname-prefix
 is not yet implemented
branchFunnel
mme4
nomme
MT0R_OWB
MT0_MEMFENCE
MT0W_OWDB
MT1A_UI4x2
MT1A_TA
MT1A_TC4x2
MT1W_TS
MT1W_A64_US
MT2R_A64_SB
MT2W_A64_SB
MT_CC_OWB
MT_RSI
MTR_MB
MTRW_TS
__builtin_IB_atomic_add_global_i16
Scratch Block Read
Unaligned OWord Block Read
OWord Block Write
DWord Scattered Write
Media Block Read
Typed Atomic Integer Operation SIMD4x2
Typed Surface Write
A64 Scattered Read
A64 Scattered Write
Oword Dual Block Read Constant Cache
Render Target Write
Typed Atomic Operation
14enqueue_marker9ocl_queuejPU3AS4K12ocl_clkeventPU3AS4S0_
expected 'global' or 'constant'
constant oword block read
constant dword gathering read
unsupported DCRO op
aligned_load_block
store_block
oword dual block read decode not supported
byte gathering read
dword scattering write
7067
slm_fence
global fence
FLush L1
 texture data
hword scratch block write
__builtin_IB_atomic_min_global_f16
7091
a64 byte gathering read
Byte with Status Return
a64 byte scattering with status return message
QWord
7072
7037
33440
MSD1R_A64_OWDB
 aligned
a64 float atomic
7118
7161
7167
__builtin_IB_atomic_max_global_i16
override
stride offset meaningless when override not set
typed
7109
7103
enabled
 with per-slot offset enabled
44779
signal
monitor event
GatewayOpcode
unknown render target op
full-precision
half-precision not supported on render target read
.rep16
__builtin_IB_atomic_max_local_u16
unknown write subop
PerCoarsePixelPSOutputs
.psp
; last render target
.sgh
12484
simd8h
simd8 high
 16b
sample compare
sample load
sample gather4
sample info
sample gather4+compare
sample derivatives+compare
__builtin_IB_atomic_or_global_i16
sample load with lod forced to 0
sample_ld_mcs
sample multi-sample without mcs
sample unorm
sample unorm for media
sample_8x8
SamplerIndex
 using sampler index 
1H (1 Oword accessed in high half of GRF)
MDC_IAR
Fill 1 byte per DW
Header
hdc_
__builtin_IB_atomic_inc_global_i16
DE4 (4 data elements per addr.)
 (SLM)
 A32
 (SSO)
channel mask must have one element not disabled
ChannelDisableMask:MDC_CMASK
atomic_fmax
atomic_fmin
no return value
 with return
atomic_or
atomic_xor
integer decrement
atomic_iadd
commuted integer subtract
__builtin_IB_atomic_cmpxchg_global_i16
unsigned-integer min
SimdMode:MDC_SM2R
SG8L
 (in owords)
DualHeader
hword unaligned
dual block
Mark empty blocks after deSSA
MathFC
ChannelOffset
CondModifier
Saturate
DstMathMacroExt
Src1DataType
Src0VertStride
ExMsgDesc
DescRegFile
DstChanEn
DstAddrImm
src%d: unsupported source operand kind/addrMode (malformed IR)
Src0AddrSubRegNum
%s: invalid register name for this platform
DepCtrl
cyclic dependency
unsupported opcode
src%d source modifier not supported (invalid IR)
Src1SrcMod
Src1AddrImm
Resolve atomic built-ins
Src0SrcMod
invalid region vertical stride on src0
Src0RepCtrl
Src1RepCtrl
Src2SubRegNum
src%d: math macro operands require Align16
11read_imagef14ocl_image3d_ro11ocl_samplerDv4_fS_S_
SinglePatch
// Line 
, to 
bti 
SrcModifier
/* [
11read_imagei14ocl_image3d_ro11ocl_samplerDv4_fS_S_
expected '(' in compare constantexpr
an operand is indirect
store needs binary send with non-null src1
fcmp requires floating point operands
surf
xsc32
ga32c
abl128
sbl256
PackedData
HWSB
uchar3
 after kernel end
register regioning restriction warning: ExecSize * sizeof(Type) exceeds 2 GRF
see Programmer's Reference Manual (Restriction 1.1)
register regioning restriction warning: SIMD1 requires vertical and horiztonal to be 0 (scalar region access)
see Programmer's Reference Manual (Restriction 2.5)
expected three operands to select
Index
Math Macro
Stack Pointer
State Register
Instruction Pointer
Debug
The addc instruction performs component-wise addition of src0 and src1 and stores the results in dst; it also stores the carry into acc.
If the operation produces a carry out, 0x00000001 is stored in acc, else 0x00000000 is stored in acc.
Format:
[(pred)] addc[.cmod] (exec_size) dst src0 src1
The and instruction performs component-wise logic AND operation between src0 and src1 and stores the results in dst.
Register source operands can use source modifiers:
[Pre-DevBDW]: Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the AND operation.
[DevBDW+]: Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a AND (NOT b) to be calculated with one instruction.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Format:
Source modifier is not allowed if source is an accumulator.
Average
bfi2
bfrev
The brc instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if all channels are branched away.
UIP should reference the instruction where all channels are expected to come together. JIP should reference the end of the innermost conditional block.
In GEN binary, JIP and UIP are at location src1 when immediates and at location src0 when reg64, where reg64 is accessed as paired DWord (regioning being <2;2,1>). The ip register must be used (for example, by the assembler) as dst. When offsets are immediate, src0 must be null.
Format:
[(pred)] brc (exec_size) JIP UIP
__builtin_spirv_BuiltInGlobalInvocationId
Call
Call Absolute
The cmp instruction performs component-wise comparison of src0 and src1 and stores the results in the selected flag register and in dst. It takes component-wise subtraction of src0 and src1, evaluating the conditional code (excluding NS signal) based on the conditional modifier, and storing the conditional bits in bit-packed form in the destination flag register and all bits of dst channels. If the dst is not null, for the enabled channels, then all bits of the destination channel will contain the flag value for the channel. When the instruction operates on packed word format, one general register may store up to 16 such comparison results. In DWord format, one general register may store up to 8 results.
A conditional modifier must be specified; the conditional modifier field cannot be 0000b. The comparison does not use the NS (NaN source) signals, as described in the Creating Conditional Flags section. Accordingly the conditional modifier should not be .u (unordered).
For each enabled channel 0b or 1b is assigned to the appropriate flag bit and 0/all zeros or all ones (e.g, byte 0xFF, word 0xFFFF, DWord 0xFFFFFFFF) is assigned to dst.
When any source type is floating-point, the cmp instruction obeys the rules described in the tables in the Floating Point Modes section of the Data Types chapter.
Format:
[(pred)] cmp[.cmod] (exec_size) dst src0 src1
The cont instruction disables execution for the subset of channels for the remainder of the current loop iteration. Channels remain disabled until right before the while instuction or right before the condition check code block for the while instruction. If all enabled channels hit this instruction, jump to the instruction referenced by JIP where execution continues.
UIP should always reference the loop's associated while instruction. JIP should point to the last instruction of the inner most conditional block if the cont instruction is inside a conditional block. In case of the break instruction directly under the loop, the JIP and the UIP are the same.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] cont (exec_size) JIP UIP
The dim instruction moves the 64-bit immediate value into enabled channels of dst.
Format:
[(pred)] dim[.cmod] (exec_size) dst src0
Dot Product 3
The dp3 instruction performs a three-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every fourth element of src0 (post-source-swizzle if present) is not involved in the computation.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
The dp4 instruction includes all four elements of each vector in the dot product. The dp2 instruction includes the first two elements of each vector in the dot product.
Format:
[(pred)] dp3[.cmod] (exec_size) dst src0 src1
else
endif
The f16to32 instruction converts the half precision float in src0 to single precision float and storing in dst.
Because this instruction does not have a 16-bit floating-point type, the source data type must be Word (W). The destination type must be F (Float).
Format:
[(pred)] f16to32[.cmod] (exec_size) dst src0
Single Precision Float to Half Precision Float
Find First Bit from LSB Side
Fraction
The halt instruction temporarily suspends execution for all enabled compute channels. Upon execution, the enabled channels are sent to the instruction at (IP + UIP), if all channels are enabled at HALT, jump to the instruction at (IP + JIP).
If the halt instruction is not inside any conditional code block, the values of JIP and UIP should be the same. If the halt instruction is inside a conditional code block, the UIP should be the end of the program and the JIP should be the end of the inner most conditional code block.
The UIP must point to a HALT Instruction.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] halt (exec_size) JIP UIP
__builtin_IB_get_default_device_queue
Sink common instructions (default = false)
spp-print-liveset-size
spp-print-base-pointers
__builtin_IB_simd_media_block_write_16_h
column position less than zero in '.loc' directive
__builtin_IB_get_max_workgroup_size
__llvm_deoptimize
sroa-random-shuffle-slices
Can't analyze slices for alloca: 
  A pointer to this alloca escaped by:
truncf
-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v24:32:32-v32:32:32-v48:64:64-v64:64:64-v96:128:128-v128:128:128-v192:256:256-v256:256:256-v512:512:512-v1024:1024:1024-n8:16:32
 (splittable)
__builtin_IB_get_prefered_workgroup_multiple
sroa_raw_cast
enable-nontrivial-unswitch
unswitch-threshold
The cost threshold for unswitching a loop.
__builtin_IB_sub_group_reduce_OpGroupSMax
unexpected token in '.purgem' directive
keep-loops
__builtin_IB_get_block_simd_size
forward-switch-cond
__builtin_IB_sub_group_reduce_OpGroupSMin
merge
simplifycfg
 contract
MaxNumOfInputSignatureEntries
spec-exec-max-not-hoisted
igc-device-enqueue-func-analysis
__builtin_IB_sub_group_scan_OpGroupSMax
igc-air-function-builder
puts
fputc
spec-exec-only-if-divergent-target
Dynamic Texture Folding
malloc
igc-device-enqueue-func-resolution
enable-noalias-to-md-conversion
__builtin_IB_sub_group_scan_OpGroupFAdd
savedstack
.exit
uname
struct._sampler_t
DeviceEnqueueFuncsResolution
.seh_endprologue
llvm.genx.GenISA.WaveAll
.noexc
.lr.ph
12write_imagei20ocl_image2d_array_woDv4_iiS0_
expected ',' after case value
error decoding instruction (no compacted form)
unsupported pseudo op (sub function of 
: invalid operation format
converting unary/binary Align16 dst to equivalent Align1
invalid addressing mode on dst
unsupported Align16 ternary destination for SIMD{8,16} (must be .xywz)
Align16 branches not supported
%s: invalid register file
swizzle X could not be retrieved
GED reports error (
src%d: inconvertible align16 operand
invalid addressing mode in src%d
Region::INVALID
12write_imagei14ocl_image3d_woDv4_iiS0_
expected '(' (start of execution size info)
old-style access to mme via acc (use mme%d for acc%d)
expected constant integer expression
right operand to operator must be integral
qnan
branching operands may not perform arithmetic on labels
syntax error in constant expression
duplicate instruction options
Atomic mutually exclusive with NoPreempt
NoMask goes precedes predication as (W) for WrEn: e.g. (W) op (..) ...   or    (W&f0.0) op (..) ..
H1 is obsolete; use M0 in execution offset: e.g. op (16|M0) ...
N2 is obsolete; use M4 in execution offset: e.g. op (4|M4) ...
N5 is obsolete; use M16 in execution offset: e.g. op (4|M16) ...
invalid default execution size; must be 1, 2, 4, 8, 16, 32
unexpected directive name
invalid mnemonic
expected predication control
jmpi must have (W) specified (automatically adding)
conditional modifier follows execution mask info: e.g. op (16|M0)  (le)f0.0 ...
unexpected subfunction for op
src0 must be a register
deprecated flag modifier syntax: 
flag register must be same for predication and flag modifier
expected indirect address offset
__builtin_spirv_OpGetKernelLocalSizeForSubgroupCount
implicit type on dst should be omitted
send operand subregisters have no effect and are deprecated syntax
old-style math macro register (use mme)
acc3
acc9
this doesn't support regioning
%s.Src%d region should be implicit
syntax error in source region
syntax error in region (width)
subregister out of bounds
hex literal too big for type
literal is out of bounds for type %s
immediate descriptor expression must be integral
rndu
ThreadGroupSize_X
yyset_column called with no buffer
fatal error - scanner input buffer overflow
atomic load must have explicit non-zero alignment
invalid message
malformed register range
address offset out of bounds for message type (>
expected surface index
missing %s argument
address range includes header (extra reg), but format does not allow for it
encode error
invalid state
0.15.17
cmpxchg operand must be a pointer
WARNING: 
llvm.amdgcn.image.sample.c.cd.cl.o.2darray
llvm.amdgcn.image.sample.c.cd.cl.o.3d
llvm.amdgcn.image.sample.c.cd.o.1d
mulh
llvm.amdgcn.image.sample.c.cd.o.3d
llvm.amdgcn.image.sample.c.cd.o.cube
llvm.amdgcn.image.sample.c.cl.1darray
cmpn
llvm.amdgcn.image.sample.c.cl.o.1d
llvm.amdgcn.image.sample.c.cl.o.1darray
llvm.amdgcn.image.sample.c.cl.o.3d
llvm.amdgcn.image.sample.c.d.1darray
llvm.amdgcn.image.sample.c.d.2d
41intel_work_group_vme_mb_multi_check_16x16PU3AS3jjjjDv2_ii14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
llvm.amdgcn.image.sample.c.d.cl.3d
llvm.amdgcn.image.sample.c.d.cl.cube
llvm.amdgcn.image.sample.c.d.cl.o.2d
endif
llvm.amdgcn.image.sample.c.d.cube
llvm.amdgcn.image.sample.c.d.o.1d
llvm.amdgcn.image.sample.c.d.o.2d
break
llvm.amdgcn.image.sample.c.l.1darray
llvm.amdgcn.image.sample.c.l.2d
llvm.amdgcn.image.sample.c.l.cube
halt
llvm.amdgcn.image.sample.c.l.o.2darray
llvm.amdgcn.image.sample.c.l.o.3d
igc-phielimination
return
llvm.amdgcn.image.sample.c.lz.cube
llvm.amdgcn.image.sample.c.lz.o.1d
llvm.amdgcn.image.sample.c.lz.o.2darray
join
llvm.amdgcn.image.sample.c.o.1darray
llvm.amdgcn.image.sample.c.o.2d
llvm.amdgcn.image.sample.c.o.3d
pseudo_fcall
llvm.amdgcn.image.sample.cd.2darray
llvm.amdgcn.image.sample.cd.3d
llvm.amdgcn.image.sample.cd.cl.2d
pseudo_exit
llvm.amdgcn.image.sample.cd.cl.o.1d
llvm.amdgcn.image.sample.cd.cl.o.1darray
47intel_work_group_vme_mb_multi_bidir_check_16x16PU3AS3jjjjDv2_ihhi14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
pseudo_fc_ret
llvm.amdgcn.image.sample.cd.o.1darray
llvm.amdgcn.image.sample.cd.o.2d
llvm.amdgcn.image.sample.cd.o.cube
sada2
llvm.amdgcn.image.sample.cl.2darray
llvm.amdgcn.image.sample.cl.3d
llvm.amdgcn.image.sample.cl.o.1d
llvm.amdgcn.image.sample.cl.o.cube
llvm.amdgcn.image.sample.cube
llvm.amdgcn.image.sample.d.2d
llvm.amdgcn.image.sample.d.cl.1darray
line
Lower GEP of Private Memory to Register Pass
llvm.amdgcn.image.sample.d.cl.o.2darray
llvm.amdgcn.image.sample.d.cl.o.3d
llvm.amdgcn.image.sample.d.o.1d
llvm.amdgcn.image.sample.d.o.3d
llvm.amdgcn.image.sample.d.o.cube
llvm.amdgcn.image.sample.l.1darray
pseudo_sada2
llvm.amdgcn.image.sample.l.o.1d
llvm.amdgcn.image.sample.l.o.1darray
llvm.amdgcn.image.sample.l.o.3d
send
llvm.amdgcn.image.sample.lz.2d
llvm.amdgcn.image.sample.lz.2darray
52intel_sub_group_avc_ime_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
sends
llvm.amdgcn.image.sample.lz.o.3d
llvm.amdgcn.image.sample.lz.o.cube
llvm.amdgcn.image.sample.o.2d
llvm.amdgcn.image.store.1d
llvm.amdgcn.image.store.1darray
llvm.amdgcn.image.store.2darray
pseudo_store_be_fp
llvm.amdgcn.image.store.mip.1d
llvm.amdgcn.image.store.mip.1darray
llvm.amdgcn.image.store.mip.3d
pseudo_caller_save
llvm.amdgcn.init.exec
llvm.amdgcn.init.exec.from.input
LowerGEPForPrivMem
pseudo_callee_save
llvm.amdgcn.lerp
llvm.amdgcn.log.clamp
llvm.amdgcn.mbcnt.lo
lifetime
llvm.amdgcn.msad.u8
llvm.amdgcn.ps.live
llvm.amdgcn.queue.ptr
DebugInfoPlaceholder
llvm.amdgcn.rsq
llvm.amdgcn.rsq.clamp
llvm.amdgcn.s.dcache.inv
pseudo_or
llvm.amdgcn.s.decperflevel
llvm.amdgcn.s.getpc
64intel_sub_group_avc_ime_evaluate_with_single_reference_streamout14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
pseudo_not
llvm.amdgcn.s.sleep
llvm.amdgcn.s.waitcnt
llvm.amdgcn.sad.u8
scaled untyped surface read
llvm.amdgcn.sdot8
llvm.amdgcn.set.inactive
llvm.amdgcn.sin
scaled A64 untyped surface read
llvm.amdgcn.udot2
llvm.amdgcn.udot4
llvm.amdgcn.update.dpp
scaled untyped surface write
llvm.amdgcn.workgroup.id.y
scaled A64 untyped surface write
Controls count of merged loads
scaled A64 scattered write
llvm.arm.cdp
llvm.arm.cdp2
llvm.arm.crc32cb
unrecognized DC2 message
llvm.arm.crc32w
llvm.arm.dbg
llvm.arm.dsb
render target read
llvm.arm.ldaexd
llvm.arm.ldc
llvm.arm.ldcl
llvm.arm.mcr2
llvm.arm.mcrr
63intel_sub_group_avc_ime_evaluate_with_single_reference_streamin14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
llvm.arm.neon.aese
llvm.arm.neon.aesimc
llvm.arm.neon.sha1c
unaligned oword block read
llvm.arm.neon.sha1su0
llvm.arm.neon.sha1su1
llvm.arm.neon.sha256h2
dword scattered read
llvm.arm.neon.vabdu
llvm.arm.neon.vabs
llvm.arm.neon.vbsl
hword block read
llvm.arm.neon.vcvtfp2fxs
llvm.arm.neon.vcvtfp2fxu
Controls count of merged stores
byte scattered read
llvm.arm.neon.vcvtns
llvm.arm.neon.vcvtnu
llvm.arm.neon.vhadds
hword block write
llvm.arm.neon.vld1
llvm.arm.neon.vld1x2
llvm.arm.neon.vld1x4
hword aligned block write
llvm.arm.neon.vld3dup
llvm.arm.neon.vld3lane
llvm.arm.neon.vld4lane
dword scattered write
llvm.arm.neon.vminnm
llvm.arm.neon.vmins
66intel_sub_group_avc_ime_evaluate_with_single_reference_streaminout14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
unrecognized DC0 message
llvm.arm.neon.vpadalu
llvm.arm.neon.vpadd
llvm.arm.neon.vpmaxs
scratch write
llvm.arm.neon.vqabs
llvm.arm.neon.vqadds
llvm.arm.neon.vqdmulh
transpose read
llvm.arm.neon.vqneg
llvm.arm.neon.vqrdmulh
llvm.arm.neon.vqrshiftnu
untyped atomic operation
llvm.arm.neon.vqshiftnsu
untyped atomic operation simd4x2
IGC Memory Optimization
media block read
llvm.arm.neon.vrecpe
llvm.arm.neon.vrecps
llvm.arm.neon.vrinta
typed atomic operation
llvm.arm.neon.vrintx
llvm.arm.neon.vrintz
llvm.arm.neon.vrshifts
untyped atomic float add
llvm.arm.neon.vshiftins
llvm.arm.neon.vshifts
llvm.arm.neon.vst1x2
media block write (non-iecp)
llvm.arm.neon.vst2lane
llvm.arm.neon.vst3
52intel_sub_group_avc_ref_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ref_payload_t
atomic counter operation simd4x2
llvm.arm.neon.vtbl4
llvm.arm.neon.vtbx1
llvm.arm.neon.vtbx4
a64 gathering read
llvm.arm.qasx
llvm.arm.qsax
llvm.arm.qsub16
a64 untyped atomic operation
llvm.arm.sel
llvm.arm.set.fpscr
llvm.arm.shasx
a64 block read
llvm.arm.smlabb
llvm.arm.smlabt
IGC Memory Optimization, the 2nd
a64 untyped atomic float add
llvm.arm.smlawb
llvm.arm.smlawt
llvm.arm.smlsld
a64 scattered write
llvm.arm.smulbb
llvm.arm.smulbt
llvm.arm.smultt
llvm.arm.space
llvm.arm.ssat
llvm.arm.ssub16
.sat
llvm.arm.stc2l
llvm.arm.stcl
54intel_sub_group_avc_sic_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_sic_payload_t
llvm.arm.uadd16
llvm.arm.uadd8
llvm.arm.uhadd8
, resLen=
llvm.arm.uhsub8
llvm.arm.undefined
llvm.arm.uqadd8
, extMsgLen=
llvm.arm.usad8
llvm.arm.usada8
llvm.arm.usax
llvm.arm.uxtab16
MergeURBWrites
llvm.hexagon.A2.absp
llvm.hexagon.A2.abssat
llvm.hexagon.A2.addh.h16.hl
llvm.hexagon.A2.addh.h16.sat.hl
llvm.hexagon.A2.addh.h16.sat.lh
llvm.hexagon.A2.addh.l16.hl
llvm.hexagon.A2.addp
llvm.hexagon.A2.addpsat
llvm.hexagon.A2.and
llvm.hexagon.A2.asrh
llvm.hexagon.A2.combine.hh
llvm.hexagon.A2.maxp
llvm.hexagon.A2.maxu
llvm.hexagon.A2.minp
llvm.hexagon.A2.negp
llvm.hexagon.A2.negsat
llvm.hexagon.A2.notp
llvm.hexagon.A2.sat
llvm.hexagon.A2.satb
llvm.hexagon.A2.satuh
llvm.hexagon.A2.subh.h16.lh
llvm.hexagon.A2.subh.h16.ll
Align1}
llvm.hexagon.A2.subh.l16.sat.hl
llvm.hexagon.A2.subh.l16.sat.ll
llvm.hexagon.A2.subsat
llvm.hexagon.A2.svavgh
llvm.hexagon.A2.svavghs
llvm.hexagon.A2.svsubh
llvm.hexagon.A2.sxth
llvm.hexagon.A2.sxtw
llvm.hexagon.A2.tfril
acc1
llvm.hexagon.A2.vabsh
llvm.hexagon.A2.vabshsat
__builtin_IB_convert_pipe_wo_to_intel_pipe
llvm.hexagon.A2.vaddubs
llvm.hexagon.A2.vadduhs
llvm.hexagon.A2.vavgh
llvm.hexagon.A2.vavgubr
llvm.hexagon.A2.vavguh
llvm.hexagon.A2.vavguw
llvm.hexagon.A2.vcmpbeq
llvm.hexagon.A2.vcmpbgtu
llvm.hexagon.A2.vcmphgtu
llvm.hexagon.A2.vconj
__private
llvm.hexagon.A2.vminh
llvm.hexagon.A2.vminub
llvm.hexagon.A2.vminw
tdr0
llvm.hexagon.A2.vnavgw
llvm.hexagon.A2.vnavgwcr
llvm.hexagon.A2.vraddub
unknown architecture reg
llvm.hexagon.A2.vsubh
llvm.hexagon.A2.vsubhs
llvm.hexagon.A2.vsubuhs
llvm.hexagon.A2.xorp
llvm.hexagon.A2.zxtb
_Z17get_global_offsetj
llvm.hexagon.A4.cmpbeq
llvm.hexagon.A4.cmpbeqi
llvm.hexagon.A4.cmpbgtu
llvm.hexagon.A4.cmphgt
llvm.hexagon.A4.cmphgti
llvm.hexagon.A4.cmphgtui
.acc
llvm.hexagon.A4.modwrapu
llvm.hexagon.A4.orn
llvm.hexagon.A4.rcmpeqi
//.declare 
llvm.hexagon.A4.round.ri.sat
llvm.hexagon.A4.round.rr
nounwind
r (spilled)
llvm.hexagon.A4.vcmpbgtui
llvm.hexagon.A4.vcmpheqi
llvm.hexagon.A4.vcmpweqi
f (spilled)
llvm.hexagon.A4.vrmaxuh
llvm.hexagon.A4.vrmaxuw
llvm.hexagon.A4.vrminh
Base=r
llvm.hexagon.A6.vcmpbeq.notany
llvm.hexagon.A6.vcmpbeq.notany.128B
llvm.hexagon.C2.andn
llvm.hexagon.C2.bitsset
llvm.hexagon.C2.cmpeq
get_sub_group_id
 rf=
llvm.hexagon.C2.cmpgtp
llvm.hexagon.C2.cmpgtu
llvm.hexagon.C2.cmplt
 type=
llvm.hexagon.C2.muxii
llvm.hexagon.C2.muxir
llvm.hexagon.C2.not
llvm.hexagon.C2.tfrrp
llvm.hexagon.C2.vitpack
llvm.hexagon.C4.and.and
 words
Convert load/store on doubles into store/loads on i32 or float types
reqd_work_group_size(
 (a0.
function
constant<
 (spilled -> 
dom-conditions-max-uses
 (spilled)
BadAssumption
 Type=
Detected conflicting code assumptions. Program may have undefined behavior, or compiler may have internal error.
 Input_Output
Unable to determine comdat of alias!
 Input
min-legal-vector-width
 Output
__ashlti3
__lshrdi3
avx512.mask.movshdup.
wany4h
__ashrdi3
all4h
__ashldi3
any2h
__mulsi3
any4h
Broken module found, compilation aborted!
any8h
intel_reqd_sub_group_size(
any16h
__muloti4
any32h
__divsi3
all2h
lane
all8h
__udivhi3
all16h
__mulodi4
all32h
__modqi3
anyv
Allocation failed
allv
intel_reqd_workgroup_walk_order(
f0.0
__umodqi3
__umoddi3
Pointer ABI alignment must be a power of 2
__addsf3
perror
__gcc_qadd
image
__gcc_qsub
__mulxf3
Invalid preferred alignment, must be a power of 2
bool
__divdf3
__subtf3
fmaf
DIFlagZero
Does pattern matching
__powixf2
none
__gcc_dtoq
DIFlagArtificial
mem_fence
__extendsfdf2
pseudo_kill
putc
spill
__truncxfhf2
fill
DIFlagRValueReference
CodeGenPatternMatch
(abs)
__gcc_qtos
-(abs)
__gcc_qtod
DIFlagMainSubprogram
__fixsfti
__trunctfsf2
__fixxfsi
CSK_MD5
CodeGenPatternMatchPass
module asm "
__fixunssfdi
pass-remarks-missed
__fixunsdfti
be_fp
__fixtfdi
be_sp
__fixunstfsi
StackCall
DW_CC_LLVM_IntelOclBicc
Spill candidate 
PrimIdLocation
 intf:
__floatsixf
__floatdisf
!AnalysisAliasing
(Liverange is local starting at line #
__floattisf
 and ending at line #
__floatsidf
 --- spilled
__floatunsisf
--max RP: 
static-func-full-module-prefix
--avg # neighbors: 
KillPixel
--max # neighbors: 
__floatundisf
__floatunditf
Roots: 
round-robin
__floatuntitf
first-fit
llvm.genx.GenISA.PullSnappedBarys
 BCR
__gcc_qeq
 graph coloring
DeletedBBs:
--# variables: 
DiscardRet
Caller save size: 
__gesf2
 bytes for fcall at cisa id 
__gcc_qge
Callee save size: 
_tmp
 bytes
__gcc_qlt
Total frame size: 
__gcc_qne
predicate
__gcc_qle
src0
__builtin_IB_get_local_id_x
src1
postDiscard
src2
__floatsisf
Def not found for use 
__gcc_qunord
) at CISA offset 
virtual_binding_table_cs
, src line 
__llvm_memcpy_element_unordered_atomic_8
=== Uses with reaching def - Flags ===
llvm.genx.GenISA.QuadPrefix
=== Uses with reaching def - Address ===
__llvm_memmove_element_unordered_atomic_4
=== Uses with reaching def - GRF ===
image2d_t
(Use -nolocalra switch for accurate results of uses without reaching defs)
Pixel shader lowering pass
=== Variables used but never defined ===
__llvm_memset_element_unordered_atomic_4
 (General)
_Unwind_Resume
 (Address)
global_size_z
 (Flag)
__sync_val_compare_and_swap_8
--address RA iteration 
__llvm_memset_element_unordered_atomic_2
Address_RA
__sync_lock_test_and_set_4
--flag RA iteration 
virtual_binding_table_hs
Flag_RA
igc-pixel-shader-addmask
--hybrid RA--
__sync_fetch_and_add_4
--skip hybrid RA due to high pressure: 
__sync_fetch_and_sub_1
=== Register Allocation ===
base_instance
Function: 
__sync_fetch_and_sub_16
Kernel: 
llvm.genx.GenISA.ROUNDNE
--GRF RA iteration 
__sync_fetch_and_and_8
air.get_function_pointer_visible_function_table
--split local send--
This is the pixel shader lowering pass 
--enable failSafe RA
__sync_fetch_and_or_8
--rematerialize
__sync_fetch_and_xor_2
--global send split
--# variables spilled: 
__sync_fetch_and_nand_1
--current spill size: 
__sync_fetch_and_or_4
Spill_GRF
__sync_fetch_and_nand_16
Local RA used 
air.atomic_exchange_explicit_texture
 GRFs
igc-pixel-shader-lowering
rmdir
: (Pred: 
__sync_fetch_and_umax_4
 Succ: 
__llvm_memset_element_unordered_atomic_1
__sync_fetch_and_min_2
max pressure: 
__sync_fetch_and_max_8
 inst(s)
__sync_fetch_and_umin_1
Dcl %s is Default32Bit but assignment is not Even aligned
a64 dword scattering write
's LRA assignment 
Lower discard intrinsics
 doesnt interfere with 
__atomic_load
Start verification for kernel: 
__atomic_load_4
) is split
bindless_image_cube_t
__atomic_store_1
) and 
__sync_fetch_and_umin_16
) are overlapping with incompatible emask but not masked as interfering
__atomic_store_16
) use overlapping physical assignments but not marked as interfering
bindless_image2d_array_msaa_t
End verification for kenel: 
igc-lower-discard
Default16Bit
__atomic_exchange_8
Default32Bit
__atomic_compare_exchange_1
Default64Bit
bindless_image1d_array_t
NonDefault
__atomic_compare_exchange_16
Undetermined
sinhl
-----
__atomic_fetch_add_8
DefaultPredicateMask
resID
(size = 
PixelShaderLowering
, spill cost = 
sscanf
, degree = 
__atomic_fetch_and_2
wait
__atomic_fetch_or_1
__atomic_fetch_sub_4
mem_fence
__atomic_fetch_or_16
pseudo_kill
target-cpu
spill
Lower Discard
fill
stat
--trivial RA
__atomic_fetch_nand_4
Allocated 100% GRF ranges without graph coloring.
llvm.genx.GenISA.RenderTargetRead
--local RA--
Could not find leader
--round-robin 
__atomic_fetch_xor_8
BCR 
invalid hexadecimal floating-point constant: expected at least one significand digit
invalid hexadecimal floating-point constant: expected exponent part 'p'
--first-fit 
bitset set argument out of range
Total GRF ranges: 
statvfs64
GRF ranges allocated by local RA: 
invalid octal number
% allocated by local RA
apple.cl.arg_metadata
Undoing local RA assignments
invalid character in input
Collect information related to domain shader
asm-macro-max-nesting-depth
The maximum nesting depth allowed for assembly macros.
redefinition of '
.set
Cannot load/store from pointer
.asciz
Recursive use of '
.value
bool
Invalid constant reference
PositionDepAnalysis
.8byte
.float
Explicit call type is not a function type
.balign
none
.quad
.p2alignw
Explicit invoke type is not a function type
SetMathPrecisionForPositionOutput
expected index
.lazy_reference
EXTRACTVAL: Invalid struct index
.reference
.zero
.comm
DataElements:MDC_DB_HW
bool
PreRA rematerialize flag
.incbin
.rept
' vs current: '
.endr
.include
none
===== LVN =====
GTPIN_IGC_OCL Error: Failed to call GTPIN_IGC_OCL_UpdateKernelInfo
Number of instructions removed: 
igc-pre-ra-remat-flag
insertCallReturnVar
.iflt
callReturn
.ifnb
===== Bank conflicts =====
_igc_bif_%s_%s_size
Found 
.ifnes
 conflicts (
DW_TAG_unspecified_parameters
 locals, 
.elseif
 globals) in kernel: 
Types Legalization pass
 // $
Use LivenessAnalysis to calculate register pressure
.space
before.
.stabs
after.
no-infs-fp-math
cleanMessageHeader
.cv_linetable
renameRegister
.skip
newLocalDefHoisting
.cv_stringtable
newLocalCopyPropagation
igc-process-func-attributes
sendFusion
igc-registerestimator
cselPeepHoleOpt
.abort
optimizeLogicOperation
.cfi_endproc
HWConformityChk
deviceEnqueueGetObjectId
preRA_Schedule
.cfi_def_cfa_register
regAlloc
DW_TAG_set_type
removeLifetimeOps
.cfi_lsda
countBankConflicts
image1d_buffer_t
removeRedundMov
RegisterEstimator
removeEmptyBlocks
.cfi_escape
insertFallThroughJump
.cfi_undefined
reassignBlockIDs
Analyzes CallGraphSCC
evalAddrExp
.macros_off
FoldAddrImmediate
.cfi_restore
chkRegBoundary
.endmacro
localSchedule
Add implicit args to all functions in the module and adjusts call to these functions
NoDD
SimplifyConstant
HWWorkaround
.altmacro
insertInstLabels
insertHashMovs
air64-apple-macosx
insertDummyCompactInst
.dc.l
mergeScalarInst
DW_TAG_enumerator
lowerMadSequence
.dcb
localSize
ifCvt
PromoteConstant
dumpPayload
.dcb.w
normalizeRegion
.ds.b
checkBarrierUsage
createR0Copy
.ds.s
initializePayload
.dcb.s
cleanupBindless
.addrsig
countGRFUsage
splitVariables
PruneUnusedArguments
changeMoveType
strtod
reRAPostSchedule
unexpected token at start of statement
accSubPostSchedule
.cfi_same_value
parsed instruction: [
reassociateConst
 for .file directives
split4GRFVars
expected string parameter for '.ifeqs' directive
addFFIDProlog
loadThreadPayload
This is an analysis pass for pulling constants for short shaders 
insertFenceBeforeEOT
unexpected token in '.ifdef'
insertScratchReadBeforeEOT
unexpected token in '.else' directive
mapOrphans
float2x3
_UIP
macros cannot be nested more than 
             === Local Definition Hoisting Optimization ===
expected identifier after '.ifdef'
Number of defs hoisted: 
<instantiation>
             === Message Header Optimization ===
bool2
 is reduced from 
Analyse shader to determine push const threshold
 to 
parameter named '
 instructions. 
' in macro '
% instructions of this kernel are removed.
double2
%s_optreport.txt
Wrong number of arguments
             === Merge Scalar Optimization ===
strtoll
Number of optimized bundles:
out of range literal value
Number of instructions saved:
float3x2
dynamicBufferOffset.bufferId
p2align directive with no operand(s) is ignored
wait
alignment directive can never be satisfied in this many bytes, ignoring maximum bytes expression
long2
mem_fence
'.fill' directive with negative size has no effect
pseudo_kill
 in directive
spill
non-local symbol required
fill
uchar2
C:\Intel\nodd.txt
ConstantBufferIndexedWithInstanceId
expected comma after first string for '.ifnes' directive
unexpected token in '.abort' directive
char2
expected string in '.include' directive
system
unexpected token in '.incbin' directive
image2d_msaa_t
promotes the values to be arguments
Count is negative
.endr
bool
short2
expected identifier in '.irpc' directive
unexpected token in '
unmatched '.endr' directive
uint2
igc-push-analysis
none
unexpected token in '.bundle_unlock' directive
unexpected token in '.file' directive
int2
file 0 not supported prior to DWARF-5
tmpfile64
file number less than one in '.loc' directive
half2
PushAnalysis
is_stmt value not the constant value of 0 or 1
unknown sub-directive in '.loc' directive
float2
bool
unexpected token in '.cv_file' directive
is_stmt value not 0 or 1
function id already allocated
air.raster_order_group
Scalarizer in codegen
llvm.genx.GenISA.URBReadOutput
none
file number less than one in '
Fix Inst Size for:
negative count has no effect
split into: 
unexpected token in '.cv_loc' directive
's live in: 
expected 'inlined_at' identifier in '.cv_inline_site_id' directive
File id less than zero in '.cv_inline_linetable' directive
's live in size: 
mach
's live out: 
igc-scalarizer-in-codegen
's live out size: 
unexpected tokens
PreRegAlloc
.eh_frame
air.thread_index_in_threadgroup
SP_GRF
unexpected token in '.cfi_signal_frame'
TM_GRF
expected symbol name
SP_MSG
macro '
FL_MSG
air.intersection
FL_GRF
Scalarizer in Codegen
FL_Send
no matching '.endmacro' in definition
unexpected '
tmp_shl_dst_bti
tmp_shl_y_offset
' is not defined
tmp_shl
 nsz
.error argument must be a string
cond_dim3_true
GenX Register Pressure Analysis
expression is negative
expression must be relocatable
__TessNumControlPoints
literal value out of range for directive
expression is not a constant value
unexpected expression in align
air.emulation
bool
igc-RegisterPressureEstimate
Expected End of Statement
qword ptr 
.even
 nuw
; Error: Block without parent!
none
invalid octal escape sequence (out of range)
%s.asm
image2d_array_msaa_depth_t
Fail to open 
RegisterPressureEstimate
SpillMemOffset
vprintf
vcoshf
invalid token in expression
DW_AT_bit_size
brackets expression not supported on this target
llvm.genx.GenISA.VirtualBindingTableBaseLocation
expected section directive before assembly directive
.text
IGC PreRA Scheduler
AsmName
.def
ArgSize
.endef
RetValSize
Air Function Attribute Update
perThreadInputSize
.secidx
Extern
.section
Callable
.seh_endproc
Caller
air.set_kernel_buffer_compute_command.p2i8
Composable
igc-PreRAScheduler
Entry
.seh_pushreg
Input
.seh_savereg
Input_Output
Insert markers around builtin calls marked with fast flag
NoWidening
.weak
Wrong input variable is used
.seh_handlerdata
ONLY ADDC AND SUBB are supported by this API
expected comma in directive
Destination for Arithmetic Instruction is NULL
rgba16unorm
BuiltinR0
__builtin_IB_memcpy_generic_to_private
BuiltinA0
expected ',' after true destination
BuiltinA0Dot2
newest
hw_tid
section '
samplerHeader
discard
Number of parameters does not match
a handler attribute must begin with '@'
LINE: 
label%d
FUNCTION: 
__builtin_IB_memcpy_private_to_generic
CHECK_NUM_OPNDS
 and
thread_local(initialexec) 
.desc
.indirect_symbol
NEGABS
.dump
.pushsection
thread_x
.secure_log_unique
thread_y
air.render_target
local_id_x
__builtin_IB_memcpy_private_to_private
local_id_y
.end_data_region
group_id_x
.constructor
group_id_y
voidProgram
group_id_z
.fvmlib_init0
group_count_x
.data_region
group_count_y
.literal16
TessellationShaderDomain
retval
__builtin_IB_memcpy_global_to_private
.non_lazy_symbol_pointer
hw_id
.objc_cat_inst_meth
color
HSOutputControlPointCount
global_data_base
.objc_class_vars
bitset test argument out of range
.mod_term_func
before.remat
.objc_instance_vars
after.remat
Pass walks through kernel and checks if there remains any unresolved air builtin function, in which case it is flagged as an error.
Skip block with instructions 
__builtin_IB_memcpy_private_to_global
Skip block with rp 
.objc_module_info
Before scheduling, 
.objc_string_object
After scheduling for presssure, 
AirRasterOrderGroups
After scheduling for latency, 
.static_data
[---] 
vexpm1f
the max pressure is 
.tlv
Max pressure instructions are: 
image2d_depth_t
schedule reverted due to mischeduling.
__builtin_IB_memcpy_constant_to_private
schedule not committed due to no change.
.macosx_version_min
schedule committed for latency.
unexpected token in '.desc' directive
the pressure is increased to 
AIR to IGC metadata parser
schedule committed with reduced pressure.
unable to emit indirect symbol attribute for: 
the reduced pressure is 
.ios_version_min
schedule reverted, 
unexpected token in '.subsections_via_symbols' directive
%s.bb%d.schedule
__builtin_IB_memcpy_private_to_constant
expected identifier after '.section' directive
 ... 
__text
+++++++++++ 
expected 
 empty cycles 
__data
 +++++++++++
vlog10f
vtanhf
nodes
__TEXT
 Prio:
TrivialLocalMemoryOpsElimination
 Earl:
__builtin_IB_memcpy_local_to_private
 Occu:
.secure_log_unique used but AS_SECURE_LOG_FILE environment variable unset.
%s.bb%d.dag.dot
unexpected token in '.tbss' directive
digraph DAG {
LogicalAndToBranch
#CCCCCC
__thread_bss
#FFEE99
.secure_log_unique specified multiple times
#FFFFFF
invalid '.zerofill' directive size, can't be less than zero
[label="
.seg2
__builtin_IB_memcpy_private_to_local
Lower inputs outputs for domain shader
, style="filled", fillcolor="
 (function: 
%d->%d
vISA_WAWSubregHazardAvoidance
__la_symbol_ptr
orange
unexpected token in '.end_data_region' directive
grey
__literal8
,color="
__builtin_IB_to_local
__OBJC
%s.bb%d.nodes
__category
vISA_NoAtomicSend
__cls_refs
__thread_ptr
,type="
__meta_class
%s.%s.dot
vISA_IGAEncoder
size = "80, 100";
__builtin_IB_to_private
// Nodes
vISA_GenerateBinary
[shape=record, label="{ID : 
both values to select must have same type
 PRIORITY : 
__thread_vars
__string_object
 ETIME : 
invalid OS minor version number, integer expected
Resolve generic address space
} "];
DW_AT_byte_stride
DW_AT_call_line
// Edges
.u2f.inner.merge.lo
prof
Number of operands mismatch between CISA instruction description and value passed in.
unknown platform name
ONE OF THE OPERANDS IS NULL!
vatanf
vasinhf
vatanhf
temp.isa
Could not open %s
vISA_LabelStr
Cannot open file %s
igc-gas-resolve
isaasmListFile.txt
.weakref
.internal
.visaasm
VISA_AsmFileName
.errors.txt
.bss.
 errors in vISA files.
.version
Please see error report written to the file 
.tbss.
Found a total of 
vISA_PlatformIsSet
Resolve compiler predefeind constants
init_array
nobits
vISA_ReRAPostSchedule
T252
llvm_linker_options
T255
Total
word
vISA_setA0toTdrForSendc
dword
igc-predefined-constant-resolve
qword
Verify if there is a pass dependency cycle.
oword
Linkage must be 'comdat'
 /EXPORT:
2GRF
llvm.module.flags
byte
expected commma
expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '%<type>' or "<type>"
(abs)
module (
(-abs)
unexpected token in '.ident' directive
safepoint-ir-verifier-print-only
vISA_dumpToCurrentDir
reserved0
Base nodes must have at least two operands
Access tag nodes must have the number of operands that is a multiple of 3!
No relocation available to represent this relative expression
This instruction shall not have a TBAA access tag!
ptrVec2ptrScl
FK_Data_1
FK_Data_2
FK_PCRel_1
-dotAll
line
FK_GPRel_1
FK_DTPRel_8
cosf
OPTPre
mulh
Old-style TBAA is no longer allowed, use struct-path TBAA instead
FK_SecRel_1
-dumpDebugConsoleOutput
FK_Data_Add_1
rndd
vacoshf
rndu
FK_Data_Sub_1
rnde
-dumpLiveness
rndz
sad2
Disable emission of the extended flags in .loc directives.
rsqrt
Enabled
-nocopyprop
reserved1C
NO_APP
reserved1D
dwarf-extended-loc
reserved1E
.ascii
-noregrenaming
UpdateOptPre
__svml_sin8
.note.GNU-stack
.weak
cbit
unsupported subtraction of qualified symbol
addr_add
expected assembly-time absolute expression
' (at offset '
-disableHFOpt
setp
OPTPost
 bytes
movs
non-zero initializer found in virtual section
-noScalarJmp
    
func
unable to write NOP sequence of 
label
, Index:
read_only
call
oword_ld
llvm.genx.GenISA.atomiccounterinc
oword_st
strtab_end
media_ld
-noreassoc
media_st
linetable_end
gather
scatter
as-secure-log-file-name
reserved3b
As secure log file name (initialized from AS_SECURE_LOG_FILE env variable)
oword_ld_unaligned
Check SIMD32 Profitability for OpenCL
reserved3d
DW_AT_rank
reserved3e
llvm-mc (based on LLVM 7.0.0)
reserved3f
Unterminated .bundle_lock when changing a section
sample
Emitting values inside a locked bundle is forbidden
sample_unorm
.comment
load
.bundle_align_mode cannot be changed once set
-forceMixMode
simd32-profit
fminmax
A Bundle can only have one Subtarget.
-foldEOT
bfrev
addc
Empty bundle-locked group is forbidden
subb
DTPREL
gather4_typed
-noroundrobin
scatter4_typed
Simd32Profitability
va_skl_plus
Intervals are contiguous
ifcall
-nolocalraroundrobin
faddr
TPOFF
file
GOTTPOFF
TLVP
reserved53
llvm.invariant.end parameter #2 must be a constant integer
vme_ime
TimeStatsCounter Start/Stop
vme_sic
GOTPAGE
vme_fbr
SIZE
vme_idm
-noloopra
reserved58
target1
barrier
PAGEOFF
sampler_cache_flush
tlsldo
fence
-nospillcleanup
raw_send
time-stats-counter
reserved5E
diff8
yield
reserved60
-spilloffset
reserved61
highera
reserved62
(module: ^
reserved63
got@ha
reserved64
-ratrace
reserved65
.demoted.zext
reserved66
toc@ha
fcall
tprel@h
fret
-verifyaugmentation
switchjmp
tprel@higher
sad2add
toc@h
plane
dtprel@l
goto
-presched-ctrl
sample_3d
Demote type safely
load_3d
PAGE
gather4_3d
dtprel@highesta
info_3d
-enable-noDD
rt_write_3d
got@tprel@ha
urb_write_3d
, live: 
typed_atomic
got@dtprel@ha
gather4_scaled
write_only
scatter4_scaled
igc-type-demote
reserved76
got@tlsld
reserved77
got@tlsld@ha
gather_scaled
-nofuse-typedWrites
scatter_scaled
LO16
llvm.genx.GenISA.broadcastMessagePhase
lifetime
LDGOT
sbarrier
-schedulerwindow
dword_atomic
Detect non-uniform usage of textures and samplers and check if they may be assumed uniform.
sqrtm
llvm.pow.f32
fputs$UNIX2003
divm
gotpcrel32@hi
-readSuppressionDepth
Allocation failed
dp4a
expression could not be evaluated
RESERVED_0
' cannot be used in assignment expr
reserved_1c
-output
reserved_1d
UniformAssumptions
reserved_1e
MCAlignFragment
reserved_3B
MCFillFragment
reserved_3D
-dumpcommonisa
reserved_3E
MCDwarfCallFrameFragment
reserved_3F
 Kind:
reserved_53
MCCVInlineLineTableFragment
reserved_58
-disableIGASyntax
samplr_cache_flush
VariableReuseAnalysis
reserved_5e
AddrSpaceCast vector pointer number of elements mismatch
reserved_60
 Alignment:
reserved_61
-uniqueLabels
reserved_62
reserved_63
 LayoutOrder:
reserved_64
                
reserved_65
Alias must point to a definition
reserved_66
Compute-once pass that provides a translation table for mapping attributes for LLVM values
3d_sample
, noRecurse: 
3d_load
 Size:
3d_gather4
-getfreegrfinfo
3d_info
 RangeEnd:
3d_rt_write
thread_group_size_hint
3d_urb_write
reserved_76
Reg:
reserved_77
TranslationTable
va_convolve_2d
Inst:(
va_minmax
 option: 
va_minmaxfilter
va_erode
__LD
va_dilate
image3d
va_boolcentroid
debug_names_begin
va_centroid
__apple_names
va_convolve_1d_v
Split loads/stores of big (or 3-element) vectors into smaller ones.
va_convolve_1d_h
__apple_namespac
va_convolve_1pixel
types_begin
va_floodfill
-compilerStats
va_lbpcreation
__debug_line
va_lbpcorrelation
objc_begin
va_correlationsearch
__debug_pubnames
va_hdc_convolve_2d
USAGE: Directory to dump VISA passes into
va_hdc_minmaxfilter
igc-vectorpreprocess
va_hdc_erode
Display available options (-help-hidden for more)
va_hdc_dilate
__debug_aranges
va_hdc_lbpcorrelation
USAGE: -TotalGRFNum <regNum>
va_hdc_lbpcreation
debug_macinfo
va_hdc_convolve_1d_h
__debug_str
va_hdc_convolve_1d_v
__LLVM_STACKMAPS
va_hdc_convolve_1pixel
resinfoptr@
svm_block_ld
VectorPreProcess
svm_block_st
.rodata.cst4
svm_gather
.gcc_except_table
svm_scatter
USAGE: File Name with isaasm paths.
svm_atomic
.debug_line_str
svm_gather4scaled
.debug_pubnames
svm_scatter4scaled
.debug_gnu_pubtypes
.debug_str
split
kernel_
.debug_macinfo
attr 
.apple_objc
"cm"
.apple_namespaces
"3d"
rng-seed
"cs"
.debug_rnglists
.decl P
.debug_abbrev.dwo
v_type=P 
sampleLCptr@
num_elts=
scalarize
.decl A
thumb
v_type=A 
.llvm_stackmaps
.decl S
.llvm_faultmaps
 v_type=S
.debug$S
 num_elts=
.debug$T
 v_name=
section_types_dwo
.decl T
section_abbrev_dwo
 v_type=T
elt0
.parameter 
addr_sec
.input 
.xdata
 offset=
.sxdata
.decl 
Cannot initialize MC for non-Windows COFF object files.
 v_type=G
Addr_Flag_RA
 alias=<
.version 
7E-M
.global_function 
elt1
.kernel 
DW_AT_body_begin
.funcdecl 
 Fragments:[
      
/// VISA Predefined Variables
  Interference
// .decl V
// .decl T
.linkonce
.kernel_attr Target=
,#write
Illegal or unimplemented CISA instruction (opcode, type): (
Encode+Emit
elt2
 /// $
setMessagePhaseX_legacy@
 for section 
track-memory
,none,
mach-o section specifier requires a segment whose length is between 1 and 16 characters
_global
mach-o section specifier uses an unknown section type
Reg Pressure Estimate
Elt0
aarch64
.signal
regular
.wait
le64
8byte_literals
.any
Analyze aggregate arguments
.all
non_lazy_symbol_pointers
S_NON_LAZY_SYMBOL_POINTERS
svm_
Elt1
block_
igc-agg-arg-analysis
mod_term_funcs
S_MOD_TERM_FUNC_POINTERS
.unaligned
S_GB_ZEROFILL
atomic
interposing
gather4scaled
S_16BYTE_LITERALS
scatter4scaled
S_DTRACE_DOF
Elt2
rope:
.function 
empty
FILE 
decI:"
LOC 
S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
raw_sendc 
raw_send 
[:<:]]
raw_sendsc.
isneg
raw_sends.
Process vector loads/stores for explicit vISA variable layout
eot.
0123456789
S_ATTR_SELF_MODIFYING_CODE
start 
debug
end 
S_ATTR_EXT_RELOC
S_ATTR_LOC_RELOC
pixel_null_mask.
parent function id not introduced by .cv_func_id or .cv_inline_site_id
cps.
function id not introduced by .cv_func_id or .cv_inline_site_id
divS.
igc-vectorprocess
igc-fix-alignment
Not all chained regions terminated!
illegal
End of a chained region outside a chained region!
31x31
frame register and offset can be set at most once
15x15
offset is not a multiple of 16
 4x16
stack allocation size is not a multiple of 8
 1x16
register save offset is not 8 byte aligned
 1x1
VectorProcess
8_connect
4_connect
help
 31x31
 Off=
 15x15
, FixupSection=
.mod
 because its definition is unavailable
<RTI>
 = comdat 
cosl
-cl-std=CL1.2
<LRTW>
uavSerializeOnResID@
<CPS>
 personality 
<PS>
define 
 gc "
!DIExpression(
Kernel Header / Declare Errors: 
dso_local 
dllimport 
TooCostly
Instruction / Operand / Region Errors: 
vptrcast
label%d's name index(%d) is not valid
_copysign
S%d's name index(%d) is not valid
sideeffect 
S%d's number of elements(%d) is not vaild
 increases the cost of inlining 
T%d's name index(%d) is not valid
 comdat
T%d's number of elements(%d) is not valid
<null operand!>
Input V%d is out of bound [%d, %d)
, { 
Input V%d = [%d, %d) intersects with V%d = [%d, %d)
ivybridge
Explicit input %d must not follow an implicit input %d
vCastload
Input %d points to an invalid variable(%d)
target datalayout = "
Input %d's size(%d) does not agree with its variable (V%d)'s
attributes #
Input%d points to an invalid sampler index(%d)
write-relbf-to-summary
Input%d points to an invalid/predefined surface index(%d)
Input%d's size(%d) does not agree with its surface's
Input%d has invalid operand class(%d)
operands: {
Invalid opcode, value: 
14ocl_image3d
vISA instruction not supported on this platform
Collect information related to vertex shader
CISA instruction uses an illegal execution size.
, summary: (
CISA instruction uses an illegal predicate value.
 Error in CISA variable decl: 
Value: 
V%d's name index(%d) is not valid: %s
!DISubprogram(
V%d's type(%s) is not legal: %s
!DIEnumerator(
V%d's number of elements(%d) is out of range: %s
disable-symbolication
V%d's alias offset must be zero when it is not aliased: %s
Metadata: slot = 
Circular alias detected, alias index: %d
igc-collect-vertex-shader-properties
Aliased variable aliases to an invalid alias index. Variable count: %d. invalid index: %d. %s
!DILabel(
Variable decl's alias offset exceeds the bounds of the aliased variable decl allocation size: %s
!DIMacro(
V%d's variable alignment is not a valid alignment value: %s
Metadata: function = 
V%d's alias index must point to a valid CISA variable index between 0 and %d. Currently points to invalid index V%d: %s
%"type 
 Error in address variable decl: 
 addrspace(
A%d's name index(%d) is not valid: %s
<badref> = 
Max possible address registers are 16 on BDW+: %s
Null bytes are not allowed in names
 Error in predicate variable decl: 
Lower inputs outputs for vertex shader
P%d's name index(%d) is not valid: %s
P%d's number of elements(%d) is not valid: %s
/-------------------------------------------!!!KERNEL HEADER ERRORS FOUND!!!-------------------------------------------\
bitwidth for integer type out of range!
/--------------------------------------------!!!INSTRUCTION ERROR FOUND!!!---------------------------------------------\
          filter 
Error in CISA routine with name: 
commercial-at
Error Message: 
 void
Diagnostics: 
local_unnamed_addr
 Instruction variables' decls: 
igc-vertex-shader-lowering
 Violating Instruction: 
DW_TAG_call_site_parameter
\----------------------------------------------------------------------------------------------------------------------/
DW_TAG_GNU_template_parameter_pack
ADDRESSOF Operand decl... are those even allowed>
DW_TAG_APPLE_property
Immediate operand: 
 arcp
Operand type: 
20ocl_image2darraymsaa
 unable to print.
 nsw
unknown operand?
 exact
                               
array::at
More than 1 kernel attribute defined SLMSize
__builtin_IB_atomic_max_local_i32
Operand modifier for non-general and non-indirect operands must be MODIFIER_NONE.
 nand
Only arithmetic modifiers should be used with arithmetic instruction general or indirect operands.
Only logical modifiers should be used with logical instruction general or indirect operands.
 min
Boolean types for immediate (constant literals) operands are disallowed.
x86_thiscallcc
Variable V%d is not declaired in CISA symtab.
 syncscope("
Constant Immediate operands are not allowed to be used as destination operands.
DW_AT_discr_list
Not allowed to write to a read only variable
ComputeShaderLowering
CISA region has width of 0
__builtin_IB_atomic_max_local_f32
Invalid execution size
addrspace(
Horizontal Stride should not be 0 for a destination operand.
externally_initialized 
There's no reason, to set the vertical stride or width of a destination operand. They are ignored.
, section "
Horizontal Stride should not be REGION_NULL
thread_local 
Legal CISA region horizontal stride parameter values: {0, 1, 2, 4}.
thread_local(localexec) 
Legal CISA region width parameter values: {1, 2, 4, 8, 16}.
alias 
Execution size must be greater than width.
print-wia-check
Legal CISA region vertical stride parameter values: {0, 1, 2, 4, 8, 16, 32}.
__builtin_IB_atomic_and_local_i32
CISA operand region access out of 2 GRF boundary (within %d bytes): %d
 = module: (
CISA operand accesses more than 2 GRF due to mis-alignment: start byte offset = %d, end byte offset = %d
path: "
WARNING: CISA region and offset cause an out of bounds byte access: 
 = typeid: (name: "
An access should not exceed the declared allocation size: 
) ; guid = 
  The access fails the following check to determine correct bounds (see CISA manual section 5.1 Region-based Addressing):
guid: 
  (row_offset * GRF_SIZE + col_offset) + (((i * v_stride) + (j * h_stride)) * type_size) <= type_size * num_elements:
anyregcc
Debug wia-check analysis
__builtin_IB_atomic_or_local_i32
) + (((
, dsoLocal: 
) + (
, refs: (
)) * 
, funcFlags: (
) <= 
readNone: 
Violating Instruction: 
, returnDoesNotAlias: 
For 3 source operand instructions, the destination operand's horizontal stride must be 1.
amdgpu_vs
LRP instruction only supports sources and destination of type F.
WIAnalysis: 
For 3 source operand instructions, region must be either scalar or contiguous
, relbf: 
Aliased variable aliases to an invalid alias index. Variable count: %d. invalid index: %d
vFuncId: (
Raw operand should be GRF-aligned: Raw offset is %d
amdgpu_gs
A CISA raw operand's offset field must be within the allocated operand size. Raw offset is %d, allocated number of elements is %d
, wpdResolutions: (
Execution size for a flag copy mov instruction should be 1, as it is a scalar copy.
Gen Simplification
dst operand type for a flag copy mov instruction should be UD/UW/UB.
, alignLog2: 
dst operand type for a flag copy mov instruction should be greater than or equal to the size of the src0 operand's type size.
, sizeM1: 
saturation is not allowed for dst operands of a flag copy mov instruction
Args: 
predication is not allowed for dst operands of a flag copy mov instruction
__builtin_IB_atomic_inc_local_i32
Destination operand of CISA MOVS instruction only supports general and indirect operands.
, info: 
Source0 operand of CISA MOVS instruction only supports general, indirect, and immediate operands.
, byte: 
Destination operand of CISA SETP instruction only supports predicate operands.
Source0 operand of CISA SETP instruction only supports general, indirect, and immediate operands.
AS =
FMINMAX opext must be either 0x0 or 0x1 (min or max).
profile-sample-accurate
Destination operand of CISA SEL instruction only supports general and indirect operands.
probe-stack
Source0 operand of CISA SEL instruction only supports general, indirect, and immediate operands.
  unknown 
Source1 operand of CISA SEL instruction only supports general, indirect, and immediate operands.
__builtin_IB_atomic_dec_local_i32
Illegal Move Instruction Opcode: %d, %s.
cvtps2pd
Illegal Synchronization Instruction Opcode: %d, %s.
Illegal Scalar Control Flow Instruction Opcode: %d, %s.
abs.cond
CISA ISA_VME_IME instruction uses illegal stream mode.
max.cond
CISA ISA_VME_IME instruction uses illegal search ctrl.
ctpop
CISA ISA_VME_IME uses undeclared surface.
noalias
CISA ISA_VME_SIC uses undeclared surface.
CISA ISA_VME_FBR uses undeclared surface.
Objective-C Image Info Version
FBRMbMode operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
^arm\.neon\.vld([1234]|[234]lane)\.v[a-z0-9]*$
FBRSubMbShape operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
.p0i8
FBRSubPredMode operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
palignr
Number of message source GRFs must be between 1 and 15
clang.arc.retainAutoreleasedReturnValueMarker
Number of message destination GRFs must be between 0 and 16
loop_header_weight
desc operand of CISA RAW_SEND instrution should be either a general, indirect, or immediate operand.
full-set
Number of source0 GRFs must be between 1 and 32
       ; preds =
Number of source1 GRFs must be between 1 and 32
Use llvm.dbg.addr for all local variables
Number of message destination GRFs must be between 0 and 32
Missing size specification for pointer in datalayout string
Valid range for num_out parameter of URB write is [1,8]
Invalid pointer size of 0 bytes
Valid range for global_offset parameter of URB write is [0,2047]
Pointer preferred alignment must be a power of 2
Only execution size of 8 is supported for URB write
Invalid index size of 0 bytes
Invalid encoding for register file
ABI alignment specification must be >0 for non-aggregate types
Illegal Miscellaneous Flow Instruction Opcode: %d, %s.
DW_OP_breg2
Destination of CISA arithmetic instruction should be general or indirect operand.
Illegal destination modifier for CISA arithmetic instruction.
__builtin_IB_atomic_sub_global_i64
%s does not support saturation
Invalid ABI alignment, must be a 16bit integer
%s does not support saturation on integer types.
Invalid preferred alignment, must be a 16bit integer
Only mul/add/mad/div/inv/sqrtm/sqrt/divm are allowed to use double precision floating point operands.
Preferred alignment cannot be less than the ABI alignment
%s only supports single and half float type
Trailing separator in datalayout string
%s only supports single float type
number of bits must be a byte width multiple
%s only supports integer and single precision float types
Invalid address space, must be a 24-bit integer
%s only supports integer type
lzd only supports UD type
__builtin_IB_atomic_min_global_i64
%s only support D/UD dst type
DIFlagAppleBlock
sad2/sad2add only supports W/UW dst type.
DIFlagBlockByrefStruct
%s only supports single UD type
DIFlagExplicit
%s has illegal dst type
DIFlagPrototyped
unsupported source modifier for arithmetic instruction
DIFlagVector
source in arithmetic instruction must be general, indirect, or immediate
swifterror
Arithmetic instructions that use single or double precision or half float types must use the same type for all of their operannds: dst(%s) and src%d(%s).
immediate src%d has %d type, and it must have integer type
__builtin_IB_atomic_min_global_f64
sad2/sad2add only supports B/UB types for src0 and src1; W/UW for src2 (sad2add). src%d has invalid type.
DIFlagIntroducedVirtual
mul/div does not support Q/UQ types for src%d
DIFlagBitField
ieee div does not support types for src%d, other than F/DF
DIFlagTypePassByValue
ieee sqrt does not support types for src%d, other than F/DF
DIFlagTypePassByReference
%s src0 and src1 only supports single UD type
DIFlagTrivial
lrp only supports general/immediate operands
DIFlagIndirectVirtualBase
Common ISA Logic instrutions are not allowed to have address operands.
 BB:
Operand type of logic operantion for predicate operands should all be BOOL (ie if one operand is BOOL they all have to be BOOL).
ror/rol does not support i8/i64 types
pass-remarks
fbl/fbh/cbit does not support Q/UQ type.
pattern
Predicate can not be used in logic operantion for predicate operands.
Enable missed optimization remarks from passes whose name match the given regular expression
All operands of logic instructions must be of integral type! opnd %d has float type %d
CSK_SHA1
All operands of logic instructions must be of integral type! opnd %d has unknow type %d
' in -pass-remarks: 
CISA compare instruction destination only supports a predicate operand.
CISA compare instruction sources do not support address or predicate operands.
CISA address instruction destination only supports an address operand.
ignoring invalid debug info in 
CISA ADDR_ADD instruction sources do not support predicate operands.
!Missed
Can not take the address of a pre-defined variable
typeTestAssumeVCalls
Can not take the address of a pre-defined surface
!Failure
Data type of the second source of ADDR_ADD should be WORD or BYTE.
Pass
CISA SAMPLER ISA_SAMPLE_UNORM instruction only accepts non-zero channel masks.
Function
CISA SAMPLER ISA_SAMPLE_UNORM instruction uses undeclared sampler.
33IGIL_EnqueueKernelWithLocalParams9ocl_queueiPijPvjS1_S1_jS1_j9ndrange_ti12ocl_clkevent
Surface T0 (the SLM surface) is not allowed for the SAMPLER instruction ISA_SAMPLE_UNORM.
WIAnalysis
CISA SAMPLER instruction ISA_SAMPLE_UNORM uses undefined surface.
/AppleInternal/Library/BuildRoots/1db8ea6b-8e8d-11ee-9041-cedaeb4cabe2/Library/Caches/com.apple.xbs/Sources/GPUDriversIntel/igc/gfx-driver/Source/visa/iga/GEDLibrary/GED_internal/Source/ged/xcoder/ged_ins.cpp
u_offset operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
        
v_offset operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
u_delta operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
PendUpdates:
v_delta operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
mme1
CISA SAMPLER SAMPLE/LOAD instruction uses undeclared sampler.
Insert, 
Surface T0 (the SLM surface) is not allowed for the SAMPLER instruction ISA_SAMPLE/ISA_LOAD.
MSD0R_HWB
CISA SAMPLER instruction ISA_SAMPLE/ISA_LOAD uses undefined surface.
WIAnalysis provides work item dependency info
CISA SAMPLER ISA_SAMPLE/ISA_LOAD instruction only accepts non-zero channel masks.
MT0R_OWDB
Illegal SIMD mode used in ISA_SAMPLE/ISA_LOAD inst.
This is a generic pass for builtins custom-lowering.
Pixel Null Mask Enable only valid for SKL+
air.hull
CPS LOD Compensation Enable must be disabled unless SIMD mode is simd8* or simd16*
AirArgumentPropagation
CPS LOD Compensation Enable is only supported for sample, sample_b, sample_b_c, sample_c and LOD
28IGIL_EnqueueKernelWithEvents9ocl_queuejPvjS_S_jS_jiPi9ndrange_tiiPKU3AS412ocl_clkeventPU3AS412ocl_clkevent12ocl_clkevent
CISA SAMPLER AVS instruction only accepts non-zero channel masks.
__builtin_IB_get_group_id
CISA VA MINMAXFILTER instruction uses undeclared sampler.
__builtin_IB_get_local_id_z
Surface T0 (the SLM surface) is not allowed for the SAMPLER AVS instruction.
igc-wi-analysis
CISA VA instruction MINMAX uses undefined surface.
__builtin_IB_atomic_cmpxchg_global_f64
u_offset operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
__builtin_IB_get_enqueued_local_size
v_offset operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
__builtin_IB_get_global_size
u_delta operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
stage_in_grid_size_z
v_delta operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
use of undefined value '@
u2d operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
stage_in_grid_origin_y
groupid operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
Scratch Block Write
verticalBlockNumber operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
consecu
cntrl for CISA SAMPLER AVS intruction should be a value 0-3 (8/16bit full/chrominance down sample).
__builtin_IB_atomic_add_local_i16
v2d operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
global_offset_z
execMode for CISA SAMPLER AVS intruction should be a value 0-3 (16x4, 8x4, 16x8, or 4x4).
global_offset_y
iefbypass operand of CISA SAMPLER AVS instruction should be either a general, indirect, or immediate operand.
global_size_y
Surface T0 (the SLM surface) is not allowed for VA instructions.
enqueued_local_size_x
u_offset operand of CISA MINMAX instrution should be either a general, indirect, or immediate operand.
local_size_x
v_offset operand of CISA MINMAX instrution should be either a general, indirect, or immediate operand.
work_dim
CISA VA instruction MINMAXFILTER uses undefined surface.
p_conse
u_offset operand of CISA MINMAXFILTER instrution should be either a general, indirect, or immediate operand.
virtual_binding_table_vs
v_offset operand of CISA MINMAXFILTER instrution should be either a general, indirect, or immediate operand.
tess_instance_stride
CISA VA VA CENTROID/BOOLCENTROID instruction MINMAX uses undefined surface.
tess_factor_scale
u_offset operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
MType
v_size operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
constant unaligned oword block read
h_size operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
LegacySimdMode
CISA VA CONVOLVE/ERODE/DILATE instruction uses undeclared sampler.
strided
CISA VA CONVOLVE/ERODE/DILATE instruction MINMAX uses undefined surface.
__builtin_IB_atomic_xchg_local_i16
u_offset operand of CISA CONVOLVE/ERODE/DILATE instrution should be either a general, indirect, or immediate operand.
v_offset operand of CISA CONVOLVE/ERODE/DILATE instrution should be either a general, indirect, or immediate operand.
Invalid VA sub-opcode: %d.
Surface T0 (the SLM surface) is not allowed for VA++ instructions.
CISA VA++ instruction LBP Correlation uses undefined surface.
air.get_unique_identifier_visible_function_table
u_offset operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
air.get_unique_identifier_sampler
v_offset operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
random 
Disparity operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
enqueued_local_size_y
CISA VA++ instruction uses undeclared sampler.
air.atomic_fetch_max_explicit_texture
CISA VA++ instruction uses undefined surface.
air.atomic_fetch_min_explicit_texture
u_offset operand of CISA VA++ instrution should be either a general, indirect, or immediate operand.
air.atomic_store_explicit_texture
v_offset operand of CISA VA++ instrution should be either a general, indirect, or immediate operand.
air.
Invalid mode field for CISA VA++ instruction. Only 4x16, 1x16, and 1x1 (in the case of 1 pixel convolve) are supported.
bindless_image_cube_array_depth_t
CISA LBP Creation VA++ instruction uses undefined surface.
depthcube
u_offset operand of CISA LBP Creation VA++ instrution should be either a general, indirect, or immediate operand.
Special const prop for SLM
v_offset operand of CISA LBP Creation VA++ instrution should be either a general, indirect, or immediate operand.
__builtin_IB_atomic_min_local_i16
Invalid mode field for CISA LBP Creation VA++ instruction. Only 5x5, 3x3, or both modes are supported.
bindless_image2d_array_msaa_depth_t
Pixel direction v-mask left of CISA VA++ FloodFill instruction only supports general, indirect, and immediate operands.
depth2d_ms_array
Pixel direction v-mask right of CISA VA++ FloodFill instruction only supports general, indirect, and immediate operands.
texturecube
loop_count of Common ISA sample instrution is invalid type.
bindless_image2d_depth_t
u_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
texture3d
v_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
bindless_image2d_t
CISA VA++ instruction Correlation search operand verticalOrigin can only be of operand class general, indirect, or immediate.
igc-slmconstprop
CISA VA++ instruction Correlation search operand horizontalOrigin can only be of operand class general, indirect, or immediate.
__builtin_IB_atomic_min_local_f16
CISA VA++ instruction Correlation search operand xDirectionSize can only be of operand class general, indirect, or immediate.
texture2d_array
CISA VA++ instruction Correlation search operand yDirectionSize can only be of operand class general, indirect, or immediate.
bindless_image1d_t
CISA VA++ instruction Correlation search operand xDirectionSearchSize can only be of operand class general, indirect, or immediate.
texture1d_array
CISA VA++ instruction Correlation search operand yDirectionSearchSize can only be of operand class general, indirect, or immediate.
bindless_image1d_buffer_t
u_offset of Common ISA HDC INSTRUCTION should not be address or predicate operand.
accessTy
v_offset of Common ISA HDC instruction should not be address or predicate operand.
needBufferOffset
CISA VA++ instruction uses invalid output pixel size.
Custom Pass for Position-Only Shader
CISA VA++ instruction uses invalid mode.
__builtin_IB_atomic_max_global_u16
disparity of Common ISA HDC LBPCORRELATION should not be address or predicate operand.
CISA VA++ instruction uses undefined destination surface.
x_offset of Common ISA HDC instruction should not be address or predicate operand.
y_offset of Common ISA HDC instruction should not be address or predicate operand.
Invalid VA++ sub-opcode: %d.
Move static allocas to entry basic block of the function
Illegal Sampler Instruction Opcode: %d, %s.
Illegal SIMD CF Instruction Opcode: %d, %s.
igc-remove-nonposition-output
MEDIA_LD modifier must be 0-5 not %d
depthcube_array
MEDIA_ST modifier must be 0-3 not %d
cmc_load_and_compile
Surface T0 (the SLM surface) is not allowed for MEDIA_LD/MEDIA_ST
libigcmc.so
CISA dataport instruction uses an undeclared surface.
opencl.used.extensions
MEDIA_LD/MEDIA_ST plane must be in the range [0, 3]: %d
Advanced Memory Optimization
MEDIA_LD/MEDIA_ST block width must be in the range [1, 32]: %d
opencl.compiler.options
MEDIA_LD/MEDIA_ST block height must be in the range [1, 64]: %d
sqrt
MEDIA_LD only supports objects that fit into a single dataport transaction where block width <= 64 bytes and size <= 256 bytes. Block width: %d. Block height: %d
remove non-position output in vertex shader
MEDIA_ST only supports objects that fit into a single dataport transaction where block width <= 64 bytes and size <= 256 bytes. Block width: %d. Block height: %d
__builtin_IB_atomic_max_local_f16
x_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
llvm.linker.options
y_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
Invalid function comdat ID
OWORD_LD*/OWORD_ST size must be in the range [0, 3] (ie, OWord block size must be 1/2/4/8. OWord block size: %d
Invalid empty synchronization scope names block
Surface T0 (the SLM surface) is not allowed for OWORD_LD*/OWORD_ST
Invalid multiple synchronization scope names blocks
Offset of Common ISA OWORD LD/ST instrutions should not be address or predicate operands.
Invalid TYPE table: Only named structs can be forward referenced
Incorrect element size for Gather/Scatter CISA inst.
Invalid vector length
global_offset of Common ISA gather/scatter instrution should not be address or predicate operand.
debug_loc
At least one channel must be enabled for TYPED GATEHR4/SCATTER4
__builtin_IB_atomic_and_local_i16
Surface T0/T5 (the SLM surface) is not allowed for TYPED SCATTTER4/GATHER4
Invalid multiple blocks
CISA dataport TYPED SCATTTER4/GATHER4 instruction uses an undeclared surface.
Malformed global initializer set
Invalid DWORD ATOMIC sub op.
Explicit load/store type does not match pointee type of pointer operand
src0 in ISA_DWORD_ATOMIC inst must be V0 for INC/DEC/PREDEC.
Load/Store operand is not a pointer type
src1 in ISA_DWORD_ATOMIC inst must be V0 for non CMPXCHG operations.
Invalid gep with no operands
Illegal dataport Instruction Opcode: %d, %s.
Explicit gep operator type does not match pointee type of pointer operand
Raw Operand %s has incorrect type %s
vectorized
EXPLICIT
__builtin_IB_atomic_or_local_i16
LOCAL_SIZE
Fast-math-flags specified for call without floating-point scalar or vector return type
GROUP_COUNT
Explicit call type does not match pointee type of callee operand
LOCAL_ID
Fast math flags indicator set for call with no FMF
PSEUDO_INPUT
Invalid function metadata: outgoing forward refs
Explicit invoke type does not match pointee type of callee operand
Callee is not of pointer to function type
simd8
nomod
Inserted value type doesn't match aggregate type
modified
INSERTVAL: Invalid type
INSERTVAL: Invalid instruction with 0 indices
bottom
EXTRACTVAL: Invalid type
top_mod
EXTRACTVAL: Invalid instruction with 0 indices
bottom_mod
Invalid ID
reserved
Invalid function metadata: incoming forward references
simd16
__builtin_IB_atomic_inc_local_i16
Trying to materialize functions before seeing function blocks
Could not find function in stream
Incompatible epoch: Bitcode '
' Reader: 'LLVM 
Invalid bitcode signature
Invalid record
__builtin_IB_atomic_dec_local_i16
RGBA
reqd_work_group_size
0000
vector
16-full
_igc_bif_%s_%s
16-downsampled
8-full
Legalize calls to functions/subroutines and their signatures
8-downsampled
Types Legalization Pass
__builtin_IB_atomic_cmpxchg_global_f16
IndirectlyCalled
__builtin_IB_AllocLocalMemPool
unsafe-fp-math
M1_NM
Fix the usage of GetBufferPtr, no combination of GetBufferPtr and GetResourcePtr
M2_NM
encoder line %d: unsupported GED setter %s (%s)
M3_NM
.debug_abbrev_begin
M4_NM
7.0.0')
M5_NM
localMemStatelessWindowSize
M6_NM
localMemStatelessWindowStartAddr
M7_NM
deviceEnqueuePreferedWorkgroupMultiple
M8_NM
expected end of struct constant
sample_b
deviceEnqueueDefaultDeviceQueue
sample_l
ex_desc register not supported on this platform for this instruction
sample_c
vector
sample_d
spinlock
sample_b_c
BuiltinCallGraphAnalysis
sample_l_c
AddImplictArgs
sample4
igc.functions
resinfo
vector
sampleinfo
pixel_phase
sample+killpix
coarse_phase
sample4_c
info_string
sample4_po
init_spinlock_var.start
sample4_po_c
air.vertex
sample_d_c
moduleHash
sample_lz
vector
sample_c_lz
load_lz
offset
load_2dms_w
SubgroupIndependentForwardProgressRequired
load_mcs
func_begin
convolve
type
minmax
minmaxfilter
entry
erode
EightPatch
dilate
DualPatch
boolcentroid
(sat)
centroid
CONV_1D_HORIZONTAL
func_end
CONV_1D_VERTICAL
//.kernel_reordering_info_end
CONV_1PIXEL
FLOOD_FILL
LBP_CREATION
LBP_CORRELATION
CORRELATION_SEARCH
error: 
HDC_CONVOLVE_2D
basic_string
HDC_MIN_MAX_FILTER
<stdin>
HDC_ERODE
has reg descs
HDC_DILATE
unsupported format kind (for now)
HDC_LBP_CORRELATION
store as send must have a null dst
HDC_LBP_CREATION
a32c
HDC_CONVOLVE_1D_H
not a send
HDC_CONVOLVE_1D_V
packed_bool
HDC_CONVOLVE_1P
bool4
UNDEFINED
module_begin
CM_Y16_FORMAT
ga32
CM_Y8_FORMAT
packed_double
CM_5x5_mode
double4
CM_3x3_mode
double
CM_BOTH_mode
bool
CM_16_FULL
packed_ulong
CM_16_DOWN_SAMPLE
ulong4
CM_8_FULL
module_end
CM_8_DOWN_SAMPLE
packed_long4
CM_AVS_16x4
packed_long
CM_AVS_INVALID
long4
CM_AVS_16x8
long
CM_MMF_16x4
expected ')' in constantexpr
CM_MMF_INVALID
packed_uchar
CM_MMF_16x1
CM_MMF_1x1
line_table_start
CM_MINMAX_ENABLE
not a macro instruction
CM_MAX_ENABLE
register regioning restriction warning: ExecSize <= Src.W (partial row)
see Programmer's Reference Manual (Restriction 2.1)
CM_MIN_ENABLE
__ocl_dbg_gid
CM_ED_64x4
char
CM_ED_32x4
CM_ED_64x1
CM_ED_32x1
CM_CONV_16x4
section_line
CM_CONV_INVALID
__ocl_dbg_lid
CM_CONV_16x1
packed_short
CM_CONV_1x1
short4
short
ushort
xchg
packed_uint
cmpxchg
uint4
minsint
igc.input.ir
maxsint
long long
fcmpwr
packed_int
int4
packed_half4
packed_half
half4
Intel OpenCL 
ICLLP
Implicit Global Id Pass - Add parameters for debugging
gen11
packed_float
gen11lp
float4
float
half
local
global
debug_end
air.arg_type_align_size
none
air.arg_name
USAGE: Unrecognized option "
air.arg_type_name
air.primitive_acceleration_structure
unrecognized platform string: 
air.amplification_count
USAGE: GenX_IR <InputFilename.isa> {Option List}
air.threads_per_quadgroup
Converts a CISA file into Gen binary or assembly
air.thread_index_in_simdgroup
Options :
section_info
    -output
ushort3
- Emit target assembly code to a file.
air.threadgroup_position_in_grid
    -noschedule
air.threadgroups_per_grid
- Turn off code scheduling.
air.thread_position_in_threadgroup
    -nocompaction
invalid use of function-local name
- Turn off binary compaction.
air.base_vertex
    -dumpcommonisa
FDIV
- Emit CISA assembly.
section_abbrev
USAGE: GenX_IR <InputFilename.visaasm> {Option List}
__builtin_IB_get_parent_event
Converting a CISA assembly file into CISA binary file
air.indirect_buffer
    -outputCisaBinaryName <CISABinaryName>
wrapper
- name for the CISA binary file.
vISA_DumpPasses
igc-emulate-argument-buffers
vISA_DumpPassesLocation
air.write
vISA_DumpDot
air.read_write
vISA_DumpDotAll
dwarf_frame
VISA_FullIRVerify
__builtin_IB_get_object_id
vISA_dumpVISAOptions
igc-air-conversion
vISA_dumpVISAOptionsAll
AIR conversion to IGC
vISA_Debug
MaxNumOfPatchConstantSignatureEntries
vISA_DebugConsoleDump
thread_index_in_threadgroup_end
vISA_Gtpin
ConstSampler
vISA_EmitLocation
air.read
vISA_dumpRPE
debug_range
vISA_dumpLiveness
AirInlineBuiltins
vISA_EnableAlways
AirPropagateAssumptions
vISA_EnableSendFusion
AirFunctionBuilder
vISA_EnableWriteFusion
denorm_exp_loop
vISA_EnableAtomicFusion
InstrStatitic
vISA_LocalCopyProp
vISA_LocalFlagOpt
Integer Subtraction with Borrow
vISA_LocalMACopt
section_debug_loc
vISA_LocalCleanMessageHeader
Resolve device enqueue functions
vISA_LocalRenameRegister
air.get_thread_index_in_simdgroup
vISA_LocalDefHoist
air.get_quadgroup_index_in_threadgroup
vISA_FoldAddrImmed
air.get_simdgroups_per_threadgroup
vISA_enableCSEL
__builtin_IB_get_local_id_y
vISA_OptReport
__builtin_IB_is_normalized_coords
vISA_MergeScalar
__builtin_IB_get_snap_wa_reqd
vISA_EnableMACOpt
text_begin
vISA_EnableDCE
DeviceEnqueueFuncsAnalysis
vISA_DisableleHFOpt
air.sampler_states
vISA_enableUnsafeCP_DF
__air_sampler_state_static
vISA_EnableStructurizer
igc-air-function-attribute-update
vISA_StructurizeCF
CmpXchgFail
vISA_EnableScalarJmp
air.clear_barrier_compute_command
vISA_enableCleanupBindless
air.set_threadgroup_memory_length_compute_command
vISA_EnableSplitVariables
.debug_info_begin
vISA_ChangeMoveType
air.set_kernel_buffer_compute_command.p1i8
vISA_accSubstitution
air-fast-flag-propagation-resolve-pass
vISA_doAccSubAfterSchedule
Resolve fast flag markers to operand attributes
vISA_ifCvt
Total
vISA_LVN
SyncFC
vISA_numGeneralAcc
unable to decompact
vISA_reassociate
: unsupported opcode on this platform
vISA_unsafeMath
.debug_info_end
vISA_split4GRFVar
srgba8unorm
vISA_noSrc1Byte
rg16unorm
vISA_expandPlane
rg8snorm
vISA_FImmToHFImm
r16unorm
vISA_cacheSamplerHeader
r8snorm
vISA_forceSamplerHeader
primitive_acceleration_structure
vISA_noncoherentStateless
intersection_function_table
vISA_enablePreemption
.debug_abbrev_begin
VISA_EnableBarrierInstCounterBits
half4x4
vISA_forceFPMAD
half3x4
vISA_DisableMixMode
expected ChOff
vISA_DisableHFMath
half2x3
vISA_ForceMixMode
void
vISA_UseSends
air.dispatch_threads_per_threadgroup
vISA_doAlign1Ternary
air.dispatch_simdgroups_per_threadgroup
vISA_loadThreadPayload
.debug_abbrev_end
vISA_foldEOTtoPrevSend
_Z38get_kernel_sub_group_count_for_ndrange
vISA_hasRNEandDenorm
air.fragment
vISA_forceNoFP64bRegioning
input
vISA_alignBindlessSampler
air.external_initializations
vISA_RoundRobin
air.global_bindings
vISA_PrintRegUsage
LegalizeStructLoadStores
vISA_IPA
LegalizeResourcePointer
vISA_LocalRA
vISA_LocalRARoundRobin
__builtin_spirv_OpGetKernelNDrangeSubGroupCount
vISA_ForceSpills
MaxNumOfOutputSignatureEntries
vISA_NoIndirectForceSpills
MaxNumOfInputSignatureEntries
vISA_AbortOnSpill
greedy-live-range-reduction
vISA_VerifyRA
Trivial greedy live range reduction to reduce register pressure for special cases.
vISA_LocalBankConflictReduction
Workaround for FP16div optimization causing a overflow
vISA_FailSafeRA
Check unresolved builtin functions
vISA_FlagSpillCodeCleanup
$dup
vISA_GRFSpillCodeCleanup
indirect_command_buffer
vISA_SpillSpaceCompression
air-rw-texture-analysis
vISA_ConsiderLoopInfoInRA
Colects read-write textures indexes and removes texture fences
vISA_ReserveR0
igc-translate-air
vISA_SpiltLLR
va_arg requires operand with first class type
vISA_EnableGlobalScopeAnalysis
PreprocessMetadata
vISA_LocalDeclareSplitInGlobalRA
sqrtf
vISA_DisableSpillCoalescing
vISA_GlobalSendVarSplit
__builtin_spirv_OpGetKernelMaxNumSubgroups
vISA_NoRemat
Air Metadata Schema Wrapper
vISA_ForceRemat
AIR Metadata Parse
vISA_SpillMemOffset
air.interpolation_function
vISA_ReservedGRFNum
air.centroid
vISA_TotalGRFNum
air.flat
vISA_GRFNumToUse
air.perspective
vISA_RATrace
.ptrcast
vISA_FastSpill
CodeGen Context Wrapper
vISA_AbortOnSpillThreshold
error: backend compiler failed build.
vISA_enableBCR
37intel_work_group_vme_mb_multi_query_8PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
vISA_hierarchicaIPA
fatal flex scanner internal error--no action found
vISA_VerifyAugmentation
igc-translate-air-builtins
vISA_LocalScheduling
Custom Const-prop Pass
vISA_preRA_Schedule
Enqueue param is not set
vISA_preRA_ScheduleForce
.off
vISA_preRA_ScheduleCtrl
air.compile.native_double_disable
vISA_preRA_ScheduleRPThreshold
IGCIndirectICBPropagaion
vISA_DumpSchedule
atomic load cannot use Release ordering
vISA_DumpDagDot
logicalAndToBranch
vISA_EnableNoDD
igc-custom-safe-opt
vISA_DebugNoDD
vISA_NoDDLookBack
invalid argument
vISA_EnableNoSrcDep
.zext
vISA_EnableNoSrcDepScen1
IGC Custom Loop Opt
vISA_EnableNoSrcDepScen2
IGC loop canonicalization
vISA_DumpNoSrcDep
sqrtl
vISA_stopNoSrcDepSetAt
.concat
vISA_FuseTypedWrites
SampleOffsetX@
Print Function IR
__fvmlib_init0
switch
invoke
resume
catchret
vISA_SchedulerWindowSize
fadd
fmul
vISA_HWThreadNumberPerEU
urem
srem
vISA_ReadSuppressionDepth
store
cmpxchg
getelementptr
vISA_BXMLEncoder
fptrunc
fpext
__igcbuiltin_sp_div
vISA_outputToFile
bitcast
addrspacecast
vISA_PrintASMCount
lshr
ashr
extractelement
vISA_GeneratevISABInary
.u2f.inner.merge.hi
vISA_IsaAssembly
select values cannot have token type
vector select condition element type must be i1
select condition must be i1 or <n x i1>
unknown
vISA_GenIsaAsmList
vISA_IsaasmNamesFileUsed
true
vISA_StripComments
.promote
range
tbaa.struct
unpredictable
invariant.group
associated
vISA_GetvISABinaryName
DPEmufp16tofp32
vISA_OutputvISABinaryName
.size
disable debug output
print pass arguments to pass to 'opt'
Structure
print pass name before it is executed
vISA_DecodeDbg
Print IR before specified passes
print-after
Print IR before each pass
vISA_CISAbinary
When printing IR for print-[before|after]{-all} always print a module IR
filter-print-funcs
Only print IR for functions whose name match this for all print-[before|after][-all] options
vISA_NoVerifyvISA
Releasing pass '
Running pass '
basic block
vISA_isParseMode
Required Passes:
Error: Required pass not found! Possible causes:
- Pass misconfiguration (e.g.: missing macros)
vISA_GetFreeGRFInfo
Pass Arguments: 
 -- '
' is the last user of following pass instances.
vISA_clearHDCWritesBeforeEOT
 Freeing Pass '
' on BasicBlock '
DPEmuTrunc
vISA_addFFIDProlog
Required
Preserved
 Uninitialized Pass
vISA_clearAccBeforeEOT
Time each pass, printing elapsed time for each on exit
vISA_replaceIndirectCallWithJmpi
.sclr
vISA_GenerateDebugInfo
broadcastMessagePhaseV@
expected metadata symbol
 -export:
,DATA
vISA_InsertDummyCompactInst
RtLibUseGOT
unique id must be positive
.elt
Maximum optimization to perform
function (
basic block (
NOT 
vISA_easyIsaasm
Pass::print not implemented for pass: '
createMessagePhasesNoInit@
NumFunctions
unexpected token
vISA_dumpTimer
Struct tag nodes must have an odd number of operands!
Struct tag nodes have a string as their first operand
Incorrect field entry in struct type node!
Offsets must be increasing!
Member size entries must be constants!
vISA_Stepping
Immutability tag on struct tag metadata must be a constant
Immutability part of the struct tag metadata must be either 0 or 1
Access type node must be a valid scalar type
-dumpPassesAll
Did not see access type in access path!
Basic Block in function '
Functions may not have common linkage
-dot
Attribute after last parameter!
Attribute 'builtin' can only be applied to a callsite.
GEP_lane
scalar
-fullIRVerify
Function takes token but isn't an intrinsic
Functions returns a token but isn't an intrinsic
function declaration may not have a !dbg attachment
-dumpVisaOptionsAll
Entry block to function must not have predecessors!
blockaddress may not be used with the entry block!
function !dbg attachment must be a subprogram
-gtpin
Global is external, but doesn't have external or weak linkage!
huge alignment values are unsupported
Declaration may not be in a Comdat!
-dumpRPE
GlobalValue with non default visibility must be dso_local!
Global is referenced by parentless instruction!
assembled.vect
-enableSendFusion
More than one parameter has attribute returned!
Incompatible argument and return types for 'returned' attribute
Cannot have multiple 'swiftself' parameters!
-enableAtomicFusion
Attributes 'readnone and writeonly' are incompatible!
Attributes 'readonly and writeonly' are incompatible!
Attributes 'readnone and inaccessiblememonly' are incompatible!
-noflagopt
Attribute 'jumptable' requires 'unnamed_addr'
element size
Attributes 'inalloca and readonly' are incompatible!
-nomsgheaderopt
Attributes 'byval' and 'inalloca' do not support unsized types!
Attribute 'swifterror' only applies to parameters with pointer to pointer type!
.shl
-nodefhoist
 argument must refer to an integer parameter
swifterror value can only be loaded and stored from, or as a swifterror argument!
!prof annotations should have no less than 2 operands
-disablecsel
second operand should not be null
expected integer argument to function_entry_count
Expected no forward declarations!
-nomergescalar
invalid expression
missing variable
invalid tag
-dce
invalid scope
invalid base type
Fix FMF for APIs that are using legacy IR
-enableUnsafeCP_DF
class/union requires a filename
discriminator can only appear on variant part
invalid subroutine type ref
-noStructurize
invalid filename
invalid enum list
invalid retained type list
-noSplitVariables
invalid imported entity ref
invalid macro list
invalid subroutine type
-noAccSub
invalid retained nodes, expected DILocalVariable or DILabel
-accSubPostSchedule
IGC Type Legalizer
-noifcvt
invalid local scope
invalid scope ref
missing global variable name
-numGeneralAcc
label requires a valid scope
invalid scope for imported entity
invalid macinfo type
-unsafeMath
function-local metadata not in basic block
function-local metadata used in wrong function
PHINode should have one entry for each predecessor of its parent basic block!
-nosrc1byte
Operand is null
Found return instr that returns non-void in Function of void return type!
__builtin_spirv_BuiltInGlobalInvocationID
-noSamplerHeaderCache
Invalid use of metadata!
Instruction referencing instruction not embedded in a basic block!
Instruction operands must be first-class values!
-ncstateless
Referring to a basic block in another function!
Referring to an argument in another function!
Cannot take the address of an inline asm!
-enableBarrierInstCounterBits
invalid fpmath accuracy!
Ranges are only for loads, calls and invokes!
align applies only to pointer types
-disableHFMath
align metadata value must be a power of 2!
alignment is larger that implementation defined limit
Binary Instruction seen with illegal int type. Legalization support missing. Inst opcode:%d
-nosends
It should have at least one range!
The lower limit must be an integer!
Range must not be empty!
-noLoadPayload
dereferenceable, dereferenceable_or_null apply only to pointer types
dereferenceable, dereferenceable_or_null apply only to load instructions, use attributes for calls or invokes
dereferenceable, dereferenceable_or_null metadata value must be an i64!
-hasRNEandDenorm
Indirectbr destinations must all have pointer type!
The unwind destination does not have an exception handling instruction!
Called function is not the same type as the call!
-alignBS
speculatable attribute may not apply to call sites
inalloca argument for call has mismatched alloca
assumeCond
-printregusage
Function has token parameter but isn't an intrinsic
Return type cannot be token for indirect call!
Multiple funclet operand bundles
-nolocalra
Intrinsic functions should never be defined!
Intrinsic has incorrect return type!
Intrinsic was not defined with variable arguments!
-forcespills
is_zero_undef argument of bit counting intrinsics must be a constant int
invalid llvm.dbg.declare intrinsic call 1
alignment of arg 1 of memory intrinsic must be 0 or a power of 2
-abortonspill
constant length must be a multiple of the element size in the element-wise atomic memory intrinsic
-verifyra
igc-int-type-legalizer
-nolocalBCR
invalid arguments to llvm.prefetch
llvm.stackprotector parameter #2 must resolve to an alloca.
llvm.localescape used outside of entry block
-disableFlagSpillClean
idx argument of llvm.localrecover must be a constant int
gc.statepoint support for inline assembly unimplemented
gc.result result type does not match wrapped callee
-reserveR0
gc relocate should be linked to a statepoint
gc relocate is incorrectly tied to the statepoint
gc.relocate: statepoint base index out of bounds
-enableGlobalScopeAnalysis
gc.statepoint: mismatch in number of call arguments
gc.statepoint: number of transition arguments must be a constant integer
RectListOptimization
-globalSendVarSplit
eh.exceptionpointer argument must be a catchpad
masked_load: must return a vector
masked_load: pass through and data type must match
-forceremat
masked_store: vector mask must be same length as data
experimental_guard cannot be invoked
experimental_deoptimize cannot be invoked
-reservedGRFNum
invalid arguments for constrained FP intrinsic
invalid exception behavior argument
 intrinsic address/value
-GRFNumToUse
 intrinsic requires a !dbg attachment
mismatched subprogram between llvm.dbg.
struct_arg_offset
-abortonspillthreshold
gc.statepoint number of patchable bytes must be a constant integer
gc.statepoint number of patchable bytes must be positive
gc.statepoint number of arguments to underlying call must be positive
-oldIPA
gc.statepoint flags must be constant integer
unknown flag used in gc.statepoint flags argument
gc.statepoint number of transition arguments must be constant integer
-noschedule
illegal use of statepoint token
gc.result or gc.relocate are the only value uses of a gc.statepoint
ResumeInst needs to be in a function with a personality.
-presched
CatchReturnInst needs to be provided a CatchPad
CatchSwitchInst needs to be in a function with a personality.
funcElse
-presched-rp
Block containing LandingPadInst must be jumped to only by the unwind edge of an invoke.
Block containg CatchPadInst must be jumped to only by its catchswitch.
A cleanupret must exit its cleanup
-dumpDagDot
Both operands to a binary operator are not of the same type!
Integer arithmetic operators only work with integral types!
Floating-point arithmetic operators only work with floating-point types!
-debug-noDD
Shift return type must be same as operands!
Allocation instruction pointer not in the stack address space!
Load operand must be a pointer.
-enable-noSrcDep
Atomic load must specify explicit alignment
-disable-noSrcDep-scen1
img_access_int_coords
-disable-noSrcDep-scen2
Atomic store must specify explicit alignment
atomic store operand must have integer, pointer, or floating point type!
GEP into unsized type!
-stop-noSrcDep-at
Vector GEP result width doesn't match operand's
Invalid GEP index vector width
fence instructions may only have acquire, release, acq_rel, or seq_cst ordering.
-nodpsendreorder
cmpxchg operand must have integer or pointer type
Expected value type does not match pointer operand type!
First atomicrmw operand must be a pointer.
-dontUseMultiThreadedLatencies
Trunc only operates on integer
Trunc only produces integer
Simplify return types and bodies of dead visible functions
-unifiedSendCycle
SExt only operates on integer
SExt only produces an integer
FPToUI source and dest must both be vector or scalar
-noAtomicSend
FPToSI source and dest must both be vector or scalar
FPToSI source must be FP or FP vector
FPToSI source and dest vector length mismatch
-nocompaction
SIToFP source and dest must both be vector or scalar
SIToFP source must be integer or integer vector
FPTrunc only operates on FP
-IGAEncoder
FPExt only operates on FP
FPExt only produces an FP
arg_desc
-symbolreg
IntToPtr source must be an integral
IntToPtr result must be a pointer
AddrSpaceCast source must be a pointer
-binary
CleanupPadInst needs to be in a function with a personality.
CleanupPadInst not the first non-PHI instruction in the block.
FuncletPadInst must not be nested within itself
-dumpisavarnames
CatchPadInst needs to be directly nested in a CatchSwitchInst.
CatchPadInst not the first non-PHI instruction in the block.
Invalid predicate in ICmp instruction!
-stripcomments
PHI nodes not grouped at top of basic block!
PHI nodes cannot have token type!
image1d
-numGenBinariesWillBePatched
cannot guarantee tail call due to mismatched calling conv
cannot guarantee tail call due to mismatched ABI impacting function attributes
musttail call result must be returned
-outputCisaBinaryName
Invalid extractelement operands!
Invalid insertelement operands!
Invalid ExtractValueInst operands!
-asmNameUser
LandingPadInst not the first non-PHI instruction in the block.
Catch operand does not have pointer type!
all indices passed to llvm.localrecover must be less than the number of arguments passed ot llvm.localescape in the parent function
-encoderStatisticsFile
'common' global may not be in a Comdat!
-CISAbinary
thread_group_size
-noverifyCISA
Aliasee cannot be NULL!
Alias and aliasee types should match!
Aliases cannot form a cycle
-rerapostschedule
comdat global value has private linkage
invalid requirement on flag, flag is not present in module
incorrect number of operands in module flag
-setA0toTdrForSendc
invalid value for 'require' module flag (expected metadata pair)
invalid value for 'require' module flag (first value operand should be a string)
wchar_size metadata requires constant integer argument
-setFFID
igc-translate-acl-printf
-clearAccBeforeEOT
image2d_msaa
<MCOperand 
image2d_msaa_depth
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
APInt(
-insertDummyCompactInst
0x%08x / 0x%08x = %.2f%%
%Y-%m-%d %H:%M:%S
may only occur zero or one times!
must occur exactly one time!
>...
' is invalid value for boolean argument! Try 0 or 1
' value invalid for integer argument!
' value invalid for uint argument!
 -   
= *unknown option value*
-dumpPayload
*no default*
= *cannot print option value*
Display list of available options (-help-list-hidden for more)
-timestats
help-hidden
Display all available options
Print non-default options after command line parsing
: CommandLine Error: Option '
' registered more than once!
error - this positional option will never be matched, because it does not Require a value, and a cl::ConsumeAfter option is active!
-platform
'.  Try: '
 -help'
image2d_array
USAGE: -numGeneralAcc <accNum>
: See: 
 -help
 positional arguments: See: 
USAGE: -reservedGRFNum <regNum>
does not allow a value! '
' specified.
' value invalid for floating point argument!
USAGE: -GRFNumToUse <regNum>
 [options]
SUBCOMMAND '
SUBCOMMANDS:
USAGE: -presched-ctrl <ctrl>
LLVM (http://llvm.org/):
LLVM
intel_reqd_sub_group_size
USAGE: -noDD-lookback <NUM>
Counters and values:
.rodata.cst32
 does not have an = in it
 is not a number
 is not a registered counter
 does not end with -skip or -count
.debug_info
Execute graph viewer in the background. Creates tmp file litter.
Error: 
Writing '
Trying 'open' program... 
USAGE: -asmNameUser <FILE>
(trunc 
ldmsptr16bit@
Accelerate framework
USAGE: -encoderStatisticsFile <reloc file>
llvm.genx.GenISA.DCL.DSCntrlPtInputVec
sampler_t
USAGE: File Name with isaasm paths. 
??2@YAPAXIABUnothrow_t@std@@@Z
??3@YAXPAXABUnothrow_t@std@@@Z
USAGE: -setFFID <ffid>
sampleDptr@
LLT_invalid
USAGE: -hashmovs1 hi32 lo32
Seed for the random number generator
.debug_info.dwo
Allocation failed
igc-purgeMetaDataUtils-import
USAGE: missing platform string. 
UNDEFINED 
xscale
arm64
aarch64
unordered_map::at: key not found
armv2a
jit_time.txt
armv4
timers.
HW_Conformity
armv6kz
Total_RA
GRF_Local_RA
__cospif
GRF_Global_RA
__memmove_chk
llvm.genx.GenISA.GetPixelMask
,#execinstr
  Graph Coloring
__sinhl_finite
asinl
atan2l
atanh
llvm.genx.GenISA.GlobalDataAccess
llvm.genx.GenISA.GridOriginLocation
llvm.genx.GenISA.GroupIdLocation
__powl_finite
Scheduling
 Inst:
__sqrtl_finite
Compaction
,unique,
Subsection number out of range
__stpcpy_chk
VB_Append_Instruction
__strncpy_chk
bcopy
llvm.genx.GenISA.GradientXfine
VB_Create_Operand
unsupported type 0x
VB_IR_Construction
Enable -time-passes memory tracking (this may be slow)
info-output-file
 for appending!
%9lld  
  Total Execution Time: %5.4f seconds (%5.4f wall clock)
Inliner for always_inline functions
   ---Wall Time---
  ---Mem---
16ocl_image1darray
simdMediaBlockRead@
aarch64_be
mips64el
powerpc64
i386
x86_64
amdil64
Stop inferring nounwind attribute during function-attrs pass
functionattrs
renderscript64
ananas
darwin
Deduce function attributes
linux
openbsd
Dead Global Elimination
minix
rtems
StringRef llvm::getTypeName() [DesiredTypeName = llvm::InnerAnalysisManagerProxy<FunctionAnalysisManager, Module>]
Enable stress test of coldcc by adding calling conv to all internal functions.
gnueabihf
gnueabi
Resolve aggregate arguments
Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enablingcoldcc
llvm.genx.GenISA.GradientY
globaldce
gnuabi64
cbrtf
logbl
logl
thread_local_zerofill
cstring:"
std::string:"
formatv:"
char:"
decUL:"
storerawvector_indexed@
pure_instructions
invalid number
no_toc
ResolveAggregateArguments
alnum
alpha
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
cntrl
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
next
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ 
punct
Global Variable Optimizer
0123456789ABCDEFabcdef
ipconstprop
alert
inline
vertical-tab
inliner-function-import-stats
basic statistics
AlignmentAnalysisPass
printing of statistics for each inlined function
number-sign
Cannot find option named '
apostrophe
left-parenthesis
asterisk
NoDefinition
period
full-stop
zero
 will not be inlined into 
five
14ocl_image2d
NotInlined
equals-sign
left-square-bracket
Inlined
circumflex
circumflex-accent
low-line
NeverInline
FunctionGroup analysis
 not inlined into 
 because it should never be inlined (cost=never)
llvm_regexec() failed to match
REG_BADPAT
invalid regular expression
REG_ECOLLATE
invalid character class
 because too costly to inline (cost=
invalid backreference number
REG_EBRACK
parentheses not balanced
Not inlining. Cost of inlining 
invalid repetition count(s)
REG_ERANGE
REG_ESPACE
 in other contexts
empty (sub)expression
REG_ASSERT
invalid argument to regex routine
Parse IR
__builtin_IB_atomic_xchg_global_i32
nehalem
sandybridge
amdfam10
bdver3
bdver4
haswell
Number of metadatas above which we emit an index to enable lazy-loading
cannonlake
core2
Write relative block frequency to function summary 
silvermont
Unexpected anonymous function when writing summary
pentium2
pentium3
__builtin_IB_atomic_min_global_i32
write-bitcode
athlon-xp
Bitcode Writer
__builtin_IB_atomic_min_global_u32
!DISubrange(
-%%%%%%
TMPDIR
Map Name: 
vaConvolveGRF_16x4@
checksumkind: 
Error waiting for child process
 (core dumped)
" doesn't exist!
/dev/null
 Uses(
Enable fmax/fmin + 0.0f flag
llvm-symbolizer
!DITemplateValueParameter(
DW_TAG_array_type
DW_TAG_entry_point
DW_TAG_enumeration_type
DW_TAG_label
constant bigger than 64 bits detected!
DW_TAG_reference_type
DW_TAG_compile_unit
DW_TAG_subroutine_type
end of file in COMDAT variable name
DW_TAG_variant
DW_TAG_common_block
DW_TAG_inheritance
end of file in string constant
DW_TAG_subrange_type
DW_TAG_with_stmt
DW_TAG_catch_block
end of file in global variable name
DW_TAG_file_type
DW_TAG_friend
DW_TAG_namelist_item
declare
DW_TAG_thrown_type
DW_TAG_try_block
DW_TAG_volatile_type
unnamed_addr
DW_TAG_namespace
DW_TAG_imported_module
__builtin_IB_atomic_max_global_i32
zeroinitializer
DW_TAG_rvalue_reference_type
DW_TAG_template_alias
DW_TAG_dynamic_type
unwind
DW_TAG_skeleton_unit
DW_TAG_immutable_type
DW_TAG_format_label
monotonic
DW_TAG_GNU_formal_parameter_pack
DW_TAG_GNU_call_site
DW_TAG_BORLAND_property
release
DW_TAG_BORLAND_Delphi_variant
DW_AT_sibling
__builtin_IB_atomic_max_global_f32
seq_cst
DW_AT_stmt_list
DW_AT_low_pc
DW_AT_discr
alignstack
DW_AT_string_length
DW_AT_common_reference
DW_AT_const_value
coldcc
DW_AT_lower_bound
DW_AT_producer
DW_AT_start_scope
x86_fastcallcc
DW_AT_accessibility
DW_AT_address_class
25ocl_image2d_array_msaa
x86_vectorcallcc
DW_AT_decl_file
DW_AT_decl_line
DW_AT_encoding
arm_aapcscc
DW_AT_identifier_case
DW_AT_macro_info
DW_AT_priority
msp430_intrcc
DW_AT_use_location
DW_AT_variable_parameter
DW_AT_allocated
ptx_device
DW_AT_entry_pc
DW_AT_use_UTF8
__builtin_IB_atomic_and_global_i32
spir_func
DW_AT_description
DW_AT_binary_scale
DW_AT_decimal_sign
x86_64_sysvcc
DW_AT_threads_scaled
DW_AT_explicit
DW_AT_endianity
x86_regcallcc
DW_AT_main_subprogram
DW_AT_data_bit_offset
DW_AT_linkage_name
swiftcc
DW_AT_str_offsets_base
DW_AT_addr_base
25ocl_image2d_msaa_depth
preserve_mostcc
DW_AT_call_all_calls
DW_AT_call_all_source_calls
DW_AT_call_value
ghccc
DW_AT_call_tail_call
DW_AT_call_target
DW_AT_call_data_location
hhvmcc
DW_AT_deleted
DW_AT_defaulted
DW_AT_MIPS_tail_loop_begin
cxx_fast_tlscc
DW_AT_MIPS_linkage_name
DW_AT_MIPS_stride
__builtin_IB_atomic_xor_global_i32
amdgpu_ls
DW_AT_MIPS_allocatable_dopetype
DW_AT_MIPS_assumed_shape_dopetype
DW_AT_src_info
amdgpu_es
DW_AT_body_end
DW_AT_GNU_vector
DW_AT_GNU_odr_signature
amdgpu_ps
DW_AT_GNU_dwo_id
DW_AT_GNU_ranges_base
DW_AT_GNU_pubtypes
amdgpu_kernel
DW_AT_BORLAND_property_implements
31ocl_image2d_array_msaa_depth
attributes
DW_AT_BORLAND_Delphi_destructor
DW_AT_BORLAND_Delphi_anonymous_method
DW_AT_BORLAND_Delphi_return
byval
DW_AT_LLVM_config_macros
DW_AT_LLVM_isysroot
DW_AT_APPLE_flags
cold
DW_AT_APPLE_omit_frame_ptr
DW_AT_APPLE_property_name
DW_AT_APPLE_property_attribute
dereferenceable
DW_OP_deref
DW_OP_const1u
__builtin_IB_atomic_dec_global_i32
inaccessiblememonly
DW_OP_const8s
DW_OP_constu
DW_OP_drop
inlinehint
DW_OP_rot
DW_OP_xderef
DW_OP_and
jumptable
DW_OP_neg
DW_OP_not
DW_OP_plus_uconst
naked
DW_OP_xor
DW_OP_bra
20ocl_image2d_depth
nobuiltin
DW_OP_skip
DW_OP_lit0
DW_OP_lit3
noduplicate
DW_OP_lit7
DW_OP_lit8
DW_OP_lit10
noinline
DW_OP_lit15
DW_OP_lit16
DW_OP_lit19
nonlazybind
DW_OP_lit23
DW_OP_lit24
__builtin_IB_atomic_cmpxchg_local_i32
noredzone
DW_OP_lit31
DW_OP_reg0
DW_OP_reg3
nocf_check
DW_OP_reg7
DW_OP_reg8
DW_OP_reg10
optnone
DW_OP_reg15
DW_OP_reg16
DW_OP_reg19
readnone
DW_OP_reg23
readonly
26ocl_image2d_array_depth
returned
DW_OP_reg31
DW_OP_breg0
DW_OP_breg3
signext
DW_OP_breg7
DW_OP_breg8
DW_OP_breg10
sret
DW_OP_breg15
DW_OP_breg16
DW_OP_breg19
sspreq
DW_OP_breg23
DW_OP_breg24
__builtin_IB_atomic_xchg_global_i64
strictfp
DW_OP_breg31
DW_OP_regx
DW_OP_piece
shadowcallstack
DW_OP_push_object_address
DW_OP_call2
DW_OP_call_ref
sanitize_hwaddress
DW_OP_stack_value
DW_OP_implicit_pointer
DW_OP_entry_value
sanitize_memory
DW_OP_xderef_type
DW_OP_convert
24IGIL_EnqueueKernelShared9ocl_queuejPvjS0_S0_jS0_jiPi9ndrange_tii12ocl_clkevent
swiftself
DW_ATE_boolean
DW_ATE_complex_float
DW_ATE_signed_char
writeonly
DW_ATE_packed_decimal
DW_ATE_numeric_string
DW_ATE_signed_fixed
opaque
DW_ATE_ASCII
DW_VIRTUALITY_none
DW_LANG_C89
largest
DW_LANG_Cobol74
DW_LANG_Cobol85
__builtin_IB_atomic_max_global_i64
samesize
DW_LANG_Ada95
DW_LANG_Fortran95
DW_LANG_ObjC_plus_plus
umax
DW_LANG_OpenCL
DW_LANG_Go
DW_LANG_Haskell
DW_LANG_C11
DW_LANG_Swift
DW_LANG_C_plus_plus_14
flags
DW_LANG_RenderScript
18IGIL_EnqueueKernel9ocl_queuejPvjS0_S0_jS0_j9ndrange_ti12ocl_clkevent
llvm.genx.GenISA.OutputTessControlPoint
log10l
lstat64
variable
 = type 
REG_ESUBREG
memccpy
typeCheckedLoadVCalls
mempcpy
DW_AT_call_pc
DW_OP_addr
REG_BADBR
typeCheckedLoadConstVCalls
Advanced Code Motion
unsat
byteArray
R_WEBASSEMBLY_TABLE_INDEX_I32
R_WEBASSEMBLY_MEMORY_ADDR_SLEB
R_WEBASSEMBLY_MEMORY_ADDR_I32
__builtin_IB_atomic_xor_global_i64
String
Use full module build paths in the profile counter names for static functions.
File
MapRawBytes
SurfaceUsage
0.41 (982f76f)
uniqueRetVal
mme0
mme2
mme3
mme6
mme7
MSD0W_HWB
fp128
MT0R_DWS
MT0R_BS
MT0W_OWB
x86_mmx
MT1R_US
MT1A_UI
MT1R_TS
zext
MT1W_MB
MT1A_TC
__builtin_IB_atomic_cmpxchg_global_i64
store
MT1R_A64_B
MT1W_A64_B
MT2R_US
Can't read textual IR with a Context that discards named Values
MT2W_US
MT2W_A64_US
MT2W_BS
use of undefined type '%
MT_SC_OWUB
MT_SC_MB
MT_RTR
use of undefined comdat '$
MT_MEMFENCE
MTW_MB
28IGIL_EnqueueKernelWithEvents9ocl_queuejPvjS0_S0_jS0_jiPi9ndrange_tiiPU3AS4K12ocl_clkeventPU3AS4S3_S3_
use of undefined metadata '!
MT1A_A64_UF
MT1A_A64_UF4x2
OWord Block Read
use of undefined type id summary '^
Byte Scattered Read
Memory Fence
OWord Dual Block Write
expected 'module asm'
Untyped Atomic Integer Operation
Untyped Atomic Integer Operation SIMD4x2
Typed Atomic Integer Operation
expected '=' after target triple
Typed Atomic Counter Operation
Typed Atomic Counter Operation SIMD4x2
__builtin_IB_atomic_sub_global_i16
expected '=' after source_filename
A64 Block Write
A64 Untyped Surface Write
Unaligned Oword Block Read Constant Cache
expected ']' at end of list
Media Block Read Sampler Cache
Read Surface Info
Render Target Read
expected 'type' after '='
A64 Untyped Atomic Float Operation
A64 Untyped Atomic Float Operation SIMD4x2
HSOutputControlPointCount
expected 'type' after name
beforeRemoveUnreachableBlocks
bits set in undefined field
const_load_block
unaligned_const_load_block
7041
7043
7084
expected '=' here
7028
aligned oword block read
7030
expected comdat type
20862
7029
oword dual block write decode not supported
redefinition of comdat '$
7068
dword gathering read
__builtin_IB_atomic_min_global_i16
Expected '{' here
sync_
synchronized 
global_fence
unexpected type in metadata definition
L1Flush
Flush L3
Expected 'gv', 'module', or 'typeid' at the start of summary entry
 r/w data
expected '(' at start of summary entry
7049
hword scratch block read
11read_imagef14ocl_image2d_ro11ocl_samplerDv2_fS1_S1
unexpected summary kind
7031
unsupported dc0 op
7089
symbol with local linkage must have default visibility
7070
7073
19316
invalid aliasee
a64 qword gathering read
a64 qword scattering write
7074
explicit pointee type doesn't match operand's pointee type
7038
HWord aligned unsupported on this platform
__builtin_IB_atomic_min_local_u16
redefinition of global '@
 read
 write
 unaligned
invalid type for global variable
 oword
 block
7126
expected global section string
a64 untyped atomic int32
DataWidth
untyped
expected attribute group id
7137
untyped atomic int32
11read_imagei14ocl_image2d_ro11ocl_samplerDv2_fS1_S1_
expected end of attribute group
mlen == 0 on write
 with vertical line stride 
, and 
unterminated attribute group
7087
7090
atomic 32-bit counter
invalid use of attribute on a function
atomic 32-bit integer
7113
ChannelMaskEnable
global variable reference must have pointer type
urb dword 
masked 
__builtin_IB_atomic_max_global_f16
' defined with type '
unsupported URB op
URBOpcode
monitor
expected integer
wait for event
unsupported GTWY op
expected localdynamic, initialexec or localexec
FP32
FP16
half-precision
expected '(' in address space
 SIMD16
expected ')' in address space
12read_imageui14ocl_image2d_ro11ocl_samplerDv2_fS1_S1_
invalid use of function-only attribute
 SIMD8
.???
Subop
invalid use of attribute on return type
PerSamplePS
 with Per-Sample Pixel PS outputs enable
LastRenderTargetSelect
expected metadata after comma
SLOTGRP_HI
 slot group high
SIMD[2]
huge alignments are not supported yet
simd32
invalid SIMD mode
__builtin_IB_atomic_and_global_i16
expected ')'
sample override LOD
expected metadata or 'align'
sample compare+override LOD
sample_ld
sample_gather4
'allocsize' indices can't refer to the same parameter
sample res info
sample_info
sample_gather4_c
Expected synchronization scope name
sample_gather4_po_c
sample gather4 pixel offset+compare
11read_imagef20ocl_image2d_depth_ro11ocl_samplerDv2_fS1_S1_
Expected ordering on atomic instruction
sample compare+with lod forced to 0
sample_ld_lz
sample ld2 multi-sample wide
expected ',' as start of index list
sample load multi-sample
sample_ld2ds
sample_
expected '>' at end of packed struct
sample deinterlace
sample_unorm_media
sample unorm+killpix for media
basic block pointers are invalid
sampler cache flush
SamplerMessageType
__builtin_IB_atomic_xor_global_i16
pointer to this type is invalid
unsupported TS op
unsupported sfid
1L (1 Oword accessed in low half of GRF)
expected '*' in address space
8 OWords
DataElements:MDC_DB_OW
this message requires a header (and it's absent)
expected ',' in argument list
SimdMode:MDC_SM2
field should be 
included
non-musttail call
scratch
musttail call in non-varargs function
11read_imagef20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
expected ')' at end of argument list
DE1 (1 data element per addr.)
DE2 (2 data elements per addr.)
surface 
expected ',' in input list
 (coherent stateless)
 A64
 (incoherent stateless)
operand bundle set must not be empty
untyped_load
untyped_store
 enabled
invalid type for function argument
this message forbids a header (and it's included)
DataElements:MDC_A64_DS
__builtin_IB_atomic_dec_global_i16
argument name invalid in function type
AtomicOp:MDC_AOP
ReturnDataControl
_ret
redefinition of type
atomic_and
logical AND
logical OR
expected '>' in packed struct
integer increment
atomic_idec
integer pre-decrement (returns pre-decrement value)
expected '}' at end of struct
integer subtract
atomic_irsub
11read_imagei20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
expected 'x' after element count
unsigned-integer max
atomic_umin
AtomicIntegerOp
zero element vector is illegal
 (high slot group)
_sgh
SG4x2
invalid vector element type
SlotGroup:MDC_SG2
GlobalUrbOffset
per-slot offset in payload
use of undefined value '%
oword unaligned
oword aligned
__builtin_IB_atomic_cmpxchg_local_i16
' is not a basic block
igc-wa-fminmax
invalid use of a non-first-class type
failed to allocate memory for kernel binary
GED unable to compact instruction
AccessMode
ExecSize
PredCtrl
instruction forward referenced with type '
FlagSubRegNum
AccWrCtrl
DstRegFile
expected value token
ExecutionDataType
BranchCtrl
Src1RegFile
expected end of packed struct
Src0DataType
ExDescRegFile
ExDescAddrSubRegNum
constant vector must not be empty
DstAddrMode
dst has inconvertible region for Align16 encoding
Align1 dst math macro unsupported on this platform.
vector element #
dst: unsupported destination operand kind/addrMode (malformed IR)
Src0AddrMode
Src0SubRegNum
expected end of array constant
align16 ternary dst must be to GRF
init_spinlock_var.end
array element #
DstSubRegNum
DebugCtrl
jip label invalid
expected comma in inline asm expression
GED_EncodeIns failed: %s
Src1VertStride
null pointer
expected '(' in block address expression
invalid interpreter
other error
src%d: unsupported region for translation to align16 encoding
expected ')' in block address expression
Src1SubRegNum
Src1MathMacroExt
11read_imagef26ocl_image2d_array_depth_ro11ocl_samplerDv4_fDv2_fS2_
cannot take blockaddress inside a declaration
Src1Width
Src1HorzStride
Src0ChanSel
cannot take address of numeric label after the function is defined
SrcDataType
src%d: unsupported region for Align16 encoding
src%d: mixed types require :f and :hf (or vice versa)
expected 'to' in constantexpr cast
Src2ChanSel
Src2RegNum
src%d: align1 ternary is not supported on this platform.
invalid cast opcode for cast from '
igc-layout
' to '
expected '(' in extractvalue constantexpr
Break constant expressions into instruction sequences
 wr:
h:INVALID
 from scratch offset 0x
 msc:
global memory
expected '(' in insertvalue constantexpr
dst region is not binary normal
expected ')' in insertvalue constantexpr
<Region::INVALID>
InstOpt
 */ 
invalid indices for insertvalue
 from #
insertvalue operand and field disagree in type: '
Layout
' instead of '
EH, 
src0 must be GRF
dst must be GRF for load
dst must be null for store
error decoding SIMD size from descriptor
descriptor SIMD size mismatches instruction ExecSize
src0 is null (doesn't fit operand mapping)
compare operands must have the same type
a32o
a64o
expected '(' in binary constantexpr
xsc8
xga32
xsc64
sc32
operands of constexpr must have same type
xubl128
bl128
cubl128
nsw only applies to integer operations
constexpr requires fp operands
DE(0x
BTS_SLM_A32
expected comma in logical constantexpr
OWs(0x
constexpr requires integer or integer vector operands
CMask
rgba
expected comma after getelementptr's type
base of getelementptr must be a pointer
12read_imageui14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
getelementptr index must be an integer
getelementptr vector index has a wrong number of elements
 targets
 before kernel start
packed_char4
invalid operand type combination for instruction
src type is not binary normal form
register regioning restriction warning: ExecSize == Src.W && Src.H != 0 && Src.V != Src.W * Src.H (vertical misalignment)
see Programmer's Reference Manual (Restriction 2.2)
register regioning restriction warning: SIMD1 requires horizontal stride of 0 (scalar region access)
see Programmer's Reference Manual (Restriction 2.4)
vector
expected three operands to shufflevector
General
Null
Accumulator
Flag Register
invalid extractelement operands
Message Control
invalid insertelement operands
Notification Register
Thread Dependency Register
expected comdat variable
Flow Control
__ocl_dbg_grid
comdat cannot be unnamed
addc
Addition with Carry
Logic And
expected metadata type
Perform component-wise arithmetic right shift of the bits in src0 by the shift count indicated in src1, storing the results in dst. If src0 has a signed type, insert copies of src0's sign bit in the number of MSBs indicated by the shift count. Otherwise insert 0 bits.
[Pre-DevBDW]: The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
[DevBDW+]: In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
For positive values, this operation is src0 / 2shiftCount and for negative values, this operation is src0 / 2shiftCount - 1.
Format:
[(pred)] asr[.cmod] (exec_size) dst src0 src1
If src0 is -1, the result is -1 regardless of the shift count.
For unsigned src0 types, asr and shr produce the same result.
The avg instruction performs component-wise integer average of src0 and src1 and stores the results in dst. An integer average uses integer upward rounding. It is equivalent to increment one to the addition of src0 and src1 and then apply an arithmetic right shift to this intermediate value.
Format:
The avg instruction performs component-wise integer average of src0 and src1 and stores the results in dst. An integer average uses integer upward rounding. It is equivalent to increment one to the addition of src0 and src1 and then apply an arithmetic right shift to this intermediate value.
missing required field 'tag'
Bit Field Insert 1
The bfi1 instruction is the first instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi1 instruction component-wise generates mask with control from src0 and src1 and stores the results in dst. The mask is used in the bfi2 instruction to generate the final result of bfi.
Create a bit mask corresponding to the bit field width and offset in src0 and src1. Store the bit mask in dst. The mask has all bits in the bit field set to 1 and all other bits as 0.
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi1 (exec_size) dst src0 src1
No accumulator access, implicit or explicit.
A SIMD16 instruction is not allowed.
The bfi2 instruction is the second instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi2 instruction component-wise performs the bitfield insert operation on src1 and src2 based on the mask in src0.
Use the mask in src0 to take a bit field value from the low bits of src1 and combine it with the value from src2 (so src2 provides all bits other than those masked out and replaced by the bit field value). Store the result in dst.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi2 (exec_size) dst src0 src1 src2
missing required field 'name'
Branch Converging
12write_imagei14ocl_image3d_woDv4_iS0_
unsigned enumerator with negative value
The break instruction is used to early-out from the inner most loop, or early out from the inner most switch block.
When used in a loop, upon execution, the break instruction terminates the loop for all execution channels enabled. If all the enabled channels hit the break instruction, jump to the instruction referenced by JIP. JIP should be the offset to the end of the inner most conditional or loop block, UIP should be the offset to the while instruction of the loop block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] break (exec_size) JIP UIP
call
calla
missing required field 'types'
Count Bits Set
The cbit instruction counts component-wise the total bits set in src0 and stores the resulting counts in dst.
Format:
[(pred)] cbit (exec_size) dst src0
Compare
missing required field 'directory'
cont
Continue
Double Precision Floating Point Immediate Data Move
missing 'distinct', required for !DICompileUnit
The dp2 instruction performs a two-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every third and fourth element of src0 (post-source-swizzle if present) are not involved in the computation.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
The dp4 instruction includes all four elements of each vector in the dot product. The dp3 instruction includes the first three elements of each vector in the dot product.
Format:
[(pred)] dp2[.cmod] (exec_size) dst src0 src1
igc-add-implicit-gid
missing required field 'file'
Dot Product Homogeneous
The dph instruction performs a four-wide homogeneous dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every fourth element of src0 (post-source-swizzle if present) is forced to 1.0f.
Use the dp4 instruction to do a four-wide dot product that includes all elements of src0 and src1.
Format:
[(pred)] dph[.cmod] (exec_size) dst src0 src1
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive before entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving at the else instruction are redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by JIP. The jump target should be the the matching endif instruction for that conditional block.
The following table describes the 16-bit JIP. In GEN binary, JIP is at location src1 and must be of type W (signed word integer). JIP must be an immediate operand, it is a signed 16-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
Format:
else (exec_size) JIP
missing required field 'discriminator'
f16to32
Half Precision Float to Single Precision Float
f32to16
missing required field 'line'
If src0 is unsigned, the fbh instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is signed and positive, the fbh instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is signed and negative, the fbh instruction counts component-wise the leading ones from src0 and stores the resulting counts in dst.
Format:
[(pred)] fbh (exec_size) dst src0
If src0 is zero, store 0xFFFFFFFF in dst.
If src0 is signed and is -1 (0xFFFFFFFF), store 0xFFFFFFFF in dst.
invalid DWARF op '
Halt
expected unsigned integer
12write_imagei14ocl_image3d_rwDv4_iS0_
element too large, limit is 
function expected to be numbered '%
igc-collect-domain-shader-properties
missing required field 'value'
missing required field 'var'
spp-print-liveset
__builtin_IB_simd_media_block_write_8_h
unexpected token in '.loc' directive
invalid metadata-value-metadata roundtrip
spp-rematerialization-threshold
expected three operands to insertelement
rs4gc-allow-statepoint-with-no-deopt-info
functions are not values, refer to them as pointers
packed_float4
__builtin_IB_simd_media_block_write_1_l
invalid type for inline asm constraint string
truncl
isa number not a constant value
__builtin_IB_simd_media_block_write_2_l
floating point constant invalid for type
sroa-strict-inbounds
llvm.genx.GenISA.createMessagePhasesNoInit
missing required field 'language'
null must be a pointer type
Slices of alloca: 
unexpected token in '.cv_func_id' directive
 slice #
invalid empty array initializer
__builtin_IB_simd_media_block_write_4_l
 fast
12write_imagei20ocl_image2d_array_woDv4_iS0_
invalid type for none constant
unsetenv
floating point constant does not have type '
initializer with struct type has wrong # elements
Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.
__builtin_IB_sub_group_reduce_OpGroupIAdd
macro defined with named parameters which are not used in macro body, possible positional parameter found in body which will have no effect
element 
.split
utime
Control the number of bonus instructions (default = 1)
expected a basic block
air.struct_type_info
__builtin_IB_sub_group_reduce_OpGroupUMax
switch-to-lookup
invalid linkage for function declaration
ungetc
.error directive invoked in source file
Convert switches to lookup tables (default = false)
ShaderHasClipCullInput
expected '(' in function argument list
Simplify the CFG
expected relocation name
Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.
functions with 'sret' argument must return void
__builtin_IB_sub_group_reduce_OpGroupUMin
invalid forward reference to function as global value!
12write_imagei16ocl_image2d_array_rwDv4_iS_
invalid forward reference to function '
spp-counted-loop-trip-width
spp-no-entry
spp-no-call
spp-no-backedge
vfscanf
__memcpy_chk
invalid redefinition of function '
chari
__builtin_IB_sub_group_scan_OpGroupUMax
unexpected backslash at end of string
type of definition and forward reference of '@
valloc
packed'ness of initializer and type don't match
fputs_unlocked
redefinition of argument '%
__builtin_IB_get_local_id_x
__builtin_IB_sub_group_scan_OpGroupUMin
fgetc_unlocked
function body requires at least one basic block
strtok
' (already modified)
fgets_unlocked
expected '=' after instruction id
Convert align attributes to assumptions during inlining.
expected '{' in function body
found end of file when expecting more instructions
ptrint
expected ']' in brackets expression
maskcond
expected fcmp predicate (e.g. 'oeq')
__builtin_IB_sub_group_scan_OpGroupFMax
rg11b10
12write_imagei16ocl_image2d_array_woDv4_iiS_
value doesn't match function result type '
.lpad-body
rgb10a2
verify-loop-lcssa
expected ',' after branch condition
cond
expected comdat type such as 'discard' or 'largest' after protection bits
Shuffle not supported in SIMD32
expected ',' after switch condition
expected comma after first string for '.ifeqs' directive
expected '[' with switch table
Calculate liveness based on LiveVars
switch condition must have integer type
illegal
SFID
unexpected padding at end of kernel
error decoding instruction
GED error decoding instruction
at pc 
expected ',' after indirectbr address
: unexpected format for basic instruction
dst: unsupported Align16 ChEn; only <1> (.xyzw) supported
unsupported Align16 Dst.ChEn (only .xyzw supported)
indirectbr address must have pointer type
unsupported Align16 ternary destination for SIMD2 (must be .xywz or .{xy,zw} for :df)
unsupported Align16 ternary destination for SIMD4 (must be .xywz or .{x,y,z,w})
error decoding instruction: SEND dst ARF
expected 'to' in invoke
%s: 0x%02X: invalid arf register
%s: %s%d: invalid register number 
_Z45get_kernel_preferred_work_group_size_multiple
Invalid result type for LLVM function
GED reports invalid field for 
(line 
 (line 
argument is not of expected type '
src%d.Rgn should have %s for binary normal form
src%d: macro instructions must be Align16 for this platform.
__get_kernel_preferred_work_group_multiple_impl
invoke instructions may not have an alignment
igc-livenessanalysis
half3x3
invalid ChOff
expected )
expected a send operand type
unexpected operand type for send
 must be a constant integer expression
expected 'caller' in cleanupret
left operand to operator must be floating point (append a .0 to force floating point)
left operand to operator must be integral
nan is deprecated, us snan(...) or qnan(...)
expected 'to' in catchret
NaN payload must be nonzero for snan
bare qnan and snan tokens deprecated (pass in a valid payload)
non-branching operations may not reference symbols
expected scope value for catchswitch
NoSrcDep not supported on given platform
ignoring unsupported instruction option {Switch}
Atomic mutually exclusive with Switch
expected ']' after catchswitch labels
Uncompacted
Uncomapcted/NoCompact mutually exclusive with Compacted
__builtin_spirv_OpEnqueueKernel
expected 'caller' in catchswitch
Q4 is obsolete; use M24 in execution offset: e.g. op (8|M24) ...
N1 is obsolete; use M0 in execution offset: e.g. op (4|M0) ...
N4 is obsolete; use M12 in execution offset: e.g. op (4|M12) ...
expected scope value for catchpad
N8 is obsolete; use M28 in execution offset: e.g. op (4|M28) ...
expected scope value for cleanuppad
default_execution_size
expected SIMD width (integral value)
expected default register type
invalid operand type for instruction
 (defined 
on line 
__builtin_spirv_OpGetKernelNDrangeMaxSubGroupSize
instruction requires integer or integer vector operands
Unexpected flag register number
expected flag subregister
saturation flag goes on destination operand: e.g. op (..) (sat)dst ...
icmp requires integer operands
subfunction is out of bounds
invalid subfunction
expected ',' after select condition
expected ]
deprecated flag modifier syntax (omit the brackets)
 for this function
expected ',' after vaarg operand
expected [
expected address subregister
12DoMultiQueryPU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_samplerj
expected ',' after extract value
invalid destination region
expected >
expected subregister
expected ',' after shuffle mask
access granularity too small for data type
expected math macro register (e.g. .mme0, ..., .mme7, or .nomme)
acc2
invalid shufflevector operands
acc7
acc8
expected |
expected ']' in phi value list
expected source operand
source modifier unsupported on this op
igc-block-transform
'catch' clause has an invalid type
syntax error in region (horizontal stride)
invalid region horizontal stride
expected source type
clause argument must be a constant
literal must be integral for type 
immediate integer floating point literals must be in hex or binary (e.g. 0x7F800000:f)
NaN payload value overflows
fast-math-flags specified for call without floating-point scalar or vector return type
expected extended send descriptor
call instructions may not have an alignment
indirect calls are not supported
ThreadGroupSize_Y
element count must have integer type
out of dynamic memory in yy_scan_buffer()
bad buffer in yy_scan_bytes()
yyset_lineno called with no buffer
fatal flex scanner internal error--end of buffer missed
load operand must be a pointer to a first class type
rnde
platform does not support packed (unary) send
unhandled ld/st operation kind
invalid address model for this message
invalid register range
expected ',' after store operand
surface offset
expected offset
surface index
store operand must be a first class value
invalid address model
unary store (stp) not supported yet
invalid %s
atomic store must have explicit non-zero alignment
Device enqueue invoke param is not a function
unknown error
out of memory
decode error
version mismatch
invalid object
invalid error code
cmpxchg cannot be unordered
cmpxchg failure ordering cannot include release semantics
dp4a
failed to allocate
ERROR: 
llvm.amdgcn.image.sample.c.cd.cl.o.2d
new value and pointer type do not match
madm
cmpxchg operand must be a first class value
llvm.amdgcn.image.sample.c.cd.cube
expected binary operation in atomicrmw
IGIL_calc_sub_group_count_for_ndrange
expected ',' after atomicrmw address
llvm.amdgcn.image.sample.c.cd.o.2darray
atomicrmw cannot be unordered
atomicrmw operand must be a pointer
37intel_work_group_vme_mb_multi_query_4PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_sampler
atomicrmw value and pointer type do not match
NDRange type mismatch
atomicrmw operand must be an integer
llvm.amdgcn.image.sample.c.cl.cube
atomicrmw operand must be power-of-two byte-sized integer
jmpi
fence cannot be unordered
llvm.amdgcn.image.sample.c.cl.o.2darray
fence cannot be monotonic
converted_ndrange
expected comma after insertvalue operand
llvm.amdgcn.image.sample.c.d.1d
value has no uses
value only has one use
Remove dead recurisive PHINode
wrong number of indexes, expected 
__builtin_IB_copyNDRangeTondrange
expected non-empty list of uselistorder indexes
llvm.amdgcn.image.sample.c.d.cl.2darray
expected '}' here
else
expected >= 2 uselistorder indexes
llvm.amdgcn.image.sample.c.d.cl.o.1darray
expected distinct uselistorder indexes in range [0, size)
struct.ndrange_t
expected uselistorder indexes to change the order
llvm.amdgcn.image.sample.c.d.cl.o.cube
expected uselistorder directive
while
expected comma in uselistorder directive
41intel_work_group_vme_mb_multi_check_16x16PU3AS3jjjjDv2_ii14ocl_image2d_roS2_S2_11ocl_sampler
expected comma in uselistorder_bb directive
enqueue_kernel signature does not match
expected function name in uselistorder_bb
llvm.amdgcn.image.sample.c.l.1d
invalid function forward reference in uselistorder_bb
cont
invalid declaration in uselistorder_bb
llvm.amdgcn.image.sample.c.l.3d
invalid numeric label in uselistorder_bb
_local
expected basic block name in uselistorder_bb
llvm.amdgcn.image.sample.c.l.o.2d
invalid basic block in uselistorder_bb
call
expected basic block in uselistorder_bb
-fasterRA
expected ':' here
captured value is null
expected 'path' here
llvm.amdgcn.image.sample.c.lz.3d
expected ',' here
goto
expected 'hash' here
llvm.amdgcn.image.sample.c.lz.o.2d
expected 'name' here
scalar_buf
expected 'summary' here
llvm.amdgcn.image.sample.c.o.1d
expected 'typeTestRes' here
expected 'kind' here
39intel_work_group_vme_mb_multi_check_8x8PU3AS3jjjjDv2_iDv4_i14ocl_image2d_roS3_S3_11ocl_sampler
unexpected TypeTestResolution kind
pointer_buf
expected 'sizeM1BitWidth' here
llvm.amdgcn.image.sample.cd.2d
expected ':'
pseudo_fret
expected optional TypeTestResolution field
llvm.amdgcn.image.sample.cd.cl.1darray
expected 'wpdResolutions' here
pointer_arg_map_buf
expected 'offset' here
llvm.amdgcn.image.sample.cd.cl.cube
expected 'wpdRes' here
pseudo_fc_call
unexpected WholeProgramDevirtResolution kind
uniform
expected optional WholeProgramDevirtResolution field
object_map_buf
expected 'byArg here
llvm.amdgcn.image.sample.cd.o.1d
unexpected WholeProgramDevirtResolution::ByArg kind
sad2
expected optional whole program devirt field
llvm.amdgcn.image.sample.cd.o.3d
expected 'args' here
unknown argument number for an object
expected name or guid tag
llvm.amdgcn.image.sample.cl.2d
expected 'summaries' here
expected summary type
47intel_work_group_vme_mb_multi_bidir_check_16x16PU3AS3jjjjDv2_ihhi14ocl_image2d_roS2_S2_S2_11ocl_sampler
expected 'insts' here
obj_id
expected optional function summary field
llvm.amdgcn.image.sample.cl.o.3d
expected 'aliasee' here
expected ':' in funcFlags
llvm.amdgcn.image.sample.d.1darray
expected '(' in funcFlags
local_size_buf
expected function flag type
llvm.amdgcn.image.sample.d.cl.1d
expected ')' in funcFlags
ThreadGroupSize_Y
expected ':' in calls
-noLocalSplit
expected '(' in calls
scalarParamBuf
expected 'callee' in call
llvm.amdgcn.image.sample.d.cl.o.2d
expected relbf
expected ')' in call
llvm.amdgcn.image.sample.d.cube
expected ')' in calls
globalArgBuf
invalid call edge hotness
llvm.amdgcn.image.sample.d.o.2darray
expected ':' in refs
pseudo_mad
expected '(' in refs
45intel_work_group_vme_mb_multi_bidir_check_8x8PU3AS3jjjjDv2_ihhS1_14ocl_image2d_roS2_S2_S2_11ocl_sampler
expected ')' in refs
globalPtrArgMappingBuf
expected '(' in typeIdInfo
llvm.amdgcn.image.sample.l.cube
invalid typeIdInfo list type
wait
expected ')' in typeIdInfo
llvm.amdgcn.image.sample.l.o.2darray
expected 'guid' here
getobjectidMappingBuf
expected 'linkage' here
llvm.amdgcn.image.sample.lz.1darray
expected 'notEligibleToImport' here
sendc
expected 'live' here
igc-priv-mem-to-reg
expected 'dsoLocal' here
casted_ptr
expected 'module' here
llvm.amdgcn.image.sample.lz.o.2darray
expected module ID
sendsc
expected GV ID
llvm.amdgcn.image.sample.o.1darray
expected type
__intel_calc_kernel_local_size_for_sub_group_count
expected field label here
llvm.amdgcn.image.sample.o.cube
column
scope
52intel_sub_group_avc_ime_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t
inlinedAt
__intel_calc_kernel_max_num_subgroups
invalid field '
llvm.amdgcn.image.store.cube
field '
pseudo_restore_be_fp
' cannot be specified more than once
llvm.amdgcn.image.store.mip.2darray
value for '
OpEnqueueKernel signature does not match
' too large, limit is 
llvm.amdgcn.implicitarg.ptr
' cannot be null
pseudo_caller_restore
igc.device.enqueue
header
invoke function should not be null
operands
llvm.amdgcn.ldexp
expected DWARF tag
pseudo_callee_restore
invalid DWARF tag
llvm.amdgcn.mbcnt.hi
Fail parent kernel lookup: possible closed self-enqueue
' cannot be empty
llvm.amdgcn.mqsad.u32.u8
count
intrinsic
lowerBound
54intel_sub_group_avc_ime_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t
expected signed integer
_dispatch_
' too small, limit is 
llvm.amdgcn.readlane
value
pseudo_and
isUnsigned
llvm.amdgcn.s.barrier
expected 'true' or 'false'
capture
encoding
llvm.amdgcn.s.dcache.wb.vol
expected DWARF type attribute encoding
pseudo_xor
invalid DWARF type attribute encoding
memopt-merge-load
baseType
local_ptr
extraData
llvm.amdgcn.s.sendmsghalt
dwarfAddressSpace
gateway
expected debug info flag
llvm.amdgcn.sad.u16
invalid debug info flag flag '
.block_struct
elements
llvm.amdgcn.sdot4
runtimeLang
scaled A64 scatter read
vtableHolder
64intel_sub_group_avc_ime_evaluate_with_single_reference_streamout14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t
templateParams
.block_descriptor
identifier
llvm.amdgcn.ubfe
discriminator
scaled byte scattered read
expected DWARF language
llvm.amdgcn.unreachable
invalid DWARF language
parent calls for invoke are not set
types
FixResourcePtrPass
expected DWARF calling convention
ThreadGroupSize_Z
invalid DWARF calling convention
kernel
filename
Fail parent call lookup: possible closed self-enqueue
directory
llvm.amdgcn.wwm
checksumkind
scaled byte scattede write
checksum
llvm.arm.crc32b
source
unknown_type
invalid checksum kind
llvm.arm.crc32h
language
render target write
producer
62intel_sub_group_avc_ime_evaluate_with_dual_reference_streamout14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t
isOptimized
_NSConcreteStackBlock
runtimeVersion
llvm.arm.ldaex
splitDebugFilename
unrecognized RT message
emissionKind
llvm.arm.ldc2l
enums
_NSConcreteGlobalBlock
retainedTypes
llvm.arm.mcr
globals
thread spawner
imports
memopt-merge-store
macros
llvm.loop.unroll.enable
dwoId
llvm.arm.neon.aesd
splitDebugInlining
oword block read
debugInfoForProfiling
llvm.arm.neon.sdot
gnuPubnames
llvm.loop.unroll.full
expected emission kind
llvm.arm.neon.sha1p
invalid emission kind
oword dual block read
linkageName
63intel_sub_group_avc_ime_evaluate_with_single_reference_streamin14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
isLocal
Disable loop unroll on retry
isDefinition
llvm.arm.neon.vabds
scopeLine
unrecognized DCC message
containingType
llvm.arm.neon.vacgt
virtuality
igc-disable-loop-unroll
virtualIndex
llvm.arm.neon.vcvtau
thisAdjustment
hword aligned block read
unit
kernel.asm
declaration
DisableLoopUnrollOnRetry
retainedNodes
llvm.arm.neon.vcvtmu
thrownTypes
memory fence
expected DWARF virtuality code
llvm.arm.neon.vcvtpu
invalid DWARF virtuality code
block_motion_estimate_intel
exportSymbols
llvm.arm.neon.vhsubu
expected DWARF macinfo type
oword block write
invalid DWARF macinfo type
61intel_sub_group_avc_ime_evaluate_with_dual_reference_streamin14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
configMacros
block_advanced_motion_estimate_check_intel
includePath
llvm.arm.neon.vld3
isysroot
oword dual block write
llvm.arm.neon.vld4dup
expr
block_advanced_motion_estimate_bidirectional_check_intel
setter
llvm.arm.neon.vmaxu
getter
byte scattered write
entity
print-summary-global-ids
erode_2d_intel
Print the global id for each value when reading the module summary
llvm.arm.neon.vpadals
Expected a single module
scratch read
llvm.bitcode
llvm.arm.neon.vpaddlu
Corrupted bitcode
dilate_2d_intel
Abbreviation starts with an Array or a Blob
llvm.arm.neon.vpminu
Array element type can't be an Array or a Blob
dp_pi
Array op not second to last
66intel_sub_group_avc_ime_evaluate_with_single_reference_streaminout14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
Array element type has to be an encoding of a type
min_filter_2d_intel
Fixed or VBR abbrev record with size > MaxChunkData
llvm.arm.neon.vqmovnu
Abbrev record with no operands
untyped surface read
Invalid abbrev number
llvm.arm.neon.vqrshiftnsu
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._
max_filter_2d_intel
import-full-type-definitions
llvm.arm.neon.vqshiftns
Import full type definitions for ThinLTO.
iterBarriers
disable-ondemand-mds-loading
OutputAsmPath
Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.
convolve_2d_intel
Corrupted Metadata block
llvm.arm.neon.vraddhn
Invalid metadata: fwd refs into function blocks
typed surface read
Invalid record: metadata strings layout
llvm.arm.neon.vrhaddu
Invalid record: metadata strings with no strings
minmax_2d_intel
Invalid record: metadata strings corrupt offset
llvm.arm.neon.vrintp
Invalid record: metadata strings bad length
typed atomic operation simd4x2
Invalid record: metadata strings truncated chars
64intel_sub_group_avc_ime_evaluate_with_dual_reference_streaminout14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
Invalid metadata attachment
centroid_2d_intel
Conflicting METADATA_KIND records
llvm.arm.neon.vrsubhn
METADATA_NAME not followed by METADATA_NAMED_NODE
untyped surface write
Invalid record: Unsupported version of DISubrange
llvm.arm.neon.vst1
Alignment value is too large
bool_centroid_2d_intel
Can't lazyload MD
llvm.arm.neon.vst2
Type mismatch in constant table!
atomic counter operation
llvm.global_ctors
igc-memopt
llvm.global_dtors
bool_sum_2d_intel
Linking globals named '
llvm.arm.neon.vtbl3
': can only link appending global with another appending global!
typed surface write
Appending variables with different element types!
llvm.arm.neon.vtbx3
Appending variables linked with different const'ness!
convolve_1d_intel
Appending variables with different alignment need to be linked!
llvm.arm.qadd8
Appending variables with different visibility need to be linked!
a64 untyped surface read
Appending variables with different unnamed_addr need to be linked!
52intel_sub_group_avc_ref_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ref_payload_t
Appending variables with different section name need to be linked!
convolve_pixel_intel
Linking two modules of different data layouts: '
llvm.arm.sasx
' is '
a64 untyped atomic operation simd4x2
' whereas '
llvm.arm.shadd8
Linking two modules of different target triples: 
lbp_image_intel
.text
.balign 2
.thumb
llvm.arm.shsub8
.text
.balign 4
.arm
a64 block write
linking module flags '
main
': IDs have conflicting override values
lbp_correlation_intel
': IDs have conflicting behaviors
llvm.arm.smlatt
': IDs have conflicting values
a64 untyped surface write
': does not have the required value
llvm.arm.smlsdx
Linking COMDATs named '
floodfill_intel
': invalid selection kinds!
llvm.arm.smuadx
': noduplicates has been violated!
unrecognized DC1 message
': ExactMatch violated!
54intel_sub_group_avc_ref_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ref_payload_t
': SameSize violated!
correlation_search_intel
': COMDAT key involves incomputable alias size.
llvm.arm.smusdx
': GlobalVariable required for data dependent selection!
': symbol multiply defined!
llvm.arm.ssax
Allocation failed
__builtin_IB_media_block_rectangle_read
DFSIn: 
llvm.arm.stc2
 DFSOut: 
Abstract Scope
igc-memopt2
Children ...
Analyzes extenstion functions arguments
live-debug-variables
llvm.arm.sxtb16
Enable the live debug variables pass
 // 
Allocation failed
llvm.arm.uhadd16
********** DEBUG VARIABLES **********
igc-extension-arg-analysis
llvm.arm.uhsub16
, msgLen=
 ind
54intel_sub_group_avc_sic_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_sic_payload_t
 Loc
SIMD16 is expected
llvm.arm.uqsub8
 @[ 
, barrier
use-segment-set-for-physregs
llvm.arm.usat16
Use segment set for the computation of the live ranges of physregs.
ExtensionArgAnalysis
********** MACHINEINSTRS **********
splitDouble
EMPTY
iterX
-phi
Resolves extension function
 weight:
llvm.hexagon.A2.abs
Clean updater: 
Null updater.
llvm.hexagon.A2.addh.h16.hh
 updater with gap = 
igc-extension-funcs-resolution
, last start = 
llvm.hexagon.A2.addh.h16.sat.hh
  Area 1:
  Spills:
52intel_sub_group_avc_sic_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_sic_payload_t
  Area 2:
ExtensionFuncsResolution
%08X
llvm.hexagon.A2.addi
  Alive in blocks: 
llvm.hexagon.A2.addsp
  Killed by:
__builtin_IB_vme_mb_block_type
 No instructions.
llvm.hexagon.A2.aslh
    #
regalloc=... not currently supported with -O0
NONE
Live Variable Analysis
__builtin_IB_vme_subpixel_mode
livevars
llvm.hexagon.A2.max
Can't print out MachineBasicBlock because parent MachineFunction
 is null
llvm.hexagon.A2.min
__builtin_IB_vme_sad_adjust_mode
<ir-block badref>
llvm.hexagon.A2.neg
%ir-block.
address-taken
landing-pad
__builtin_IB_vme_search_path_type
align 
llvm.hexagon.A2.roundsat
; predecessors: 
llvm.hexagon.A2.satub
successors: 
__builtin_IB_vme_helper_get_handle
0x%08x
llvm.hexagon.A2.subh.h16.hl
%.2f%%
Align1, 
liveins: 
ArgSize
__builtin_IB_vme_helper_get_as
llvm.hexagon.A2.subh.l16.ll
; Irreducible loop header weight: 
%bb.
llvm.hexagon.A2.subri
%08X
Analyzes extension functions
view-machine-block-freq-propagation-dags
llvm.hexagon.A2.svadduhs
Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.
null
do not display graphs.
__builtin_IB_convert_pipe_ro_to_intel_pipe
fraction
igc-extension-funcs-analysis
display a graph using the fractional block frequency representation.
llvm.hexagon.A2.sxtb
integer
acc0
display a graph using the raw integer fractional block frequency representation.
llvm.hexagon.A2.tfrih
display a graph using the real profile count if available.
ExtensionFuncsAnalysis
view-block-layout-with-bfi
llvm.hexagon.A2.tfrsi
Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.
print-machine-bfi
__local
Print the machine block frequency info.
GenericAddressAnalysis
static-likely-prob
llvm.hexagon.A2.vaddub
branch probability threshold in percentageto be considered very likely
dbg0
profile-likely-prob
llvm.hexagon.A2.vaddws
branch probability threshold in percentage to be considered very likely when profile is available
GenericAddressDynamicResolution
verify-machine-dom-info
llvm.hexagon.A2.vavgub
Verify machine dominator info (time consuming)
=============================--------------------------------
__UseNative64BitSubgroupBuiltin
Inorder Dominator Tree: 
LocalLoadBlock
DFSNumbers invalid: 
llvm.hexagon.A2.vavgwr
 slow queries.
cl::location(x) specified more than once!
llvm.hexagon.A2.vcmphgt
 <<exit node>>
GlobalPrivateLoadBlock
llvm.hexagon.A2.vcmpwgtu
Frame Objects:
iterY
  fi#
RetValSize
localLoad
dead
llvm.hexagon.A2.vminb
variable sized
size=
llvm.hexagon.A2.vminuw
, align=
globalOrPrivateLoad
, fixed
llvm.hexagon.A2.vnavghr
, at location [SP
align-all-functions
__ProfilingTimerResolution
Force the alignment of all functions.
CmpWindowLowerBound
no-realign-stack
llvm.hexagon.A2.vsubb.map
# Machine code for function 
Function Live Ins: 
llvm.hexagon.A2.vsububs
 in 
CmpWindowUpperBound
# End machine code for function 
llvm.hexagon.A2.xor
Jump Tables:
Constant Pool:
isPtrInWindow
  cp#
llvm.hexagon.A4.boundscheck
FailedISel
IsSSA
llvm.hexagon.A4.cmpbgti
Legalized
localWindowEnd
NoPHIs
llvm.hexagon.A4.cmpheqi
NoVRegs
.noacc
RegBankSelected
_Z12get_local_idj
Selected
Resolves image height, width, depth functions
TracksLiveness
llvm.hexagon.A4.cround.rr
Allocation failed
%jump-table.
llvm.hexagon.A4.rcmpeq
MachineFunction Printer
igc-image-func-resolution
llvm.hexagon.A4.round.ri
Base=
frame-setup 
Extern
frame-destroy 
ImageFuncResolution
nnan 
llvm.hexagon.A4.vcmpbgti
ninf 
a (spilled)
nsz 
llvm.hexagon.A4.vcmphgtui
arcp 
__builtin_IB_get_image_height
contract 
llvm.hexagon.A4.vrmaxh
afn 
.declare 
reassoc 
__builtin_spirv_BuiltInSubgroupId
UNKNOWN
__builtin_IB_get_image_width
 [sideeffect]
llvm.hexagon.A5.vaddhubs
 [mayload]
Base=a
 [maystore]
llvm.hexagon.C2.and
 [isconvergent]
__builtin_IB_get_image_depth
 [alignstack]
llvm.hexagon.C2.bitsclri
 [attdialect]
 ElementSize=
 [inteldialect]
work_group_size_hint(
:[reguse
__builtin_IB_get_image_num_mip_levels
:[regdef
llvm.hexagon.C2.cmpgti
:[regdef-ec
 size=
:[clobber
llvm.hexagon.C2.cmpgtup
:[imm
__builtin_IB_get_image_channel_data_type
:[mem
llvm.hexagon.C2.mux
:[??
 alias=
Built-in function pass
__builtin_IB_get_image_channel_order
llvm.hexagon.C2.tfrpr
 align=
llvm.hexagon.C2.xor
__builtin_IB_get_image_srgb_channel_order
exp2
new_entry
Output
__builtin_IB_get_image_array_size
wpdRes: (kind: 
constantrange<
__builtin_IB_get_image_num_samples
allocsize(
value-tracking
dereferenceable_or_null
__builtin_IB_get_address_mode
undefined
notconstant<
input module has no datalayout
nontemporal
Analyzes image height, width, depth functions
 tiedto:$
llvm.genx.GenISA.PixelPositionX
 debug-location 
__ashlsi3
 :: 
inreg
 line no:
igc-image-func-analysis
 indirect
open64
Loop at depth 
__lshrsi3
 containing: 
null-pointer-is-valid
<header>
ImageFuncsAnalysis
<latch>
x86_64-apple-darwin22.1.0
<exiting>
__ashrsi3
print-regmask-num-regs
DW_AT_LLVM_include_path
Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1
-ExtSLM
%subreg.
open
target-flags(
__mulhi3
<unknown>) 
, inlineBits: 
<unknown target flag>
localToChar
<unknown bitmask target flag>
inalloca
<mcsymbol 
__mulosi4
%fixed-stack.
%stack.
movedLocal
<badref>
pclose
implicit-def 
__divhi3
implicit 
DW_OP_lit6
def 
charToLocal
internal 
bdver2
dead 
__udivqi3
killed 
nonnull
undef 
GenSLM.LocalMemPoolOnGetMemPoolPtr
early-clobber 
opendir
debug-use 
__udivti3
renamable 
use-dbg-addr
.subreg
mempoolcast
(tied-def 
llvm.genx.GenISA.PixelPositionY
%const.
__moddi3
target-index(
optforfuzzing
<unknown>
localSLM
scoped-noalias
blockaddress(
__umodsi3
<regmask
igc-resource-indirection-pass
 and 
Resolve inline local variables/buffers
 more...
 ...
__negdi2
liveout(
Zero width native integer type in datalayout string
<cfi directive>
igc-resolve-inline-locals
intrinsic(@
_bb 
intrinsic(
__addtf3
pred(
Unknown mangling in datalayout string
volatile 
InlineLocalsResolutionPass
non-temporal 
noimplicitfloat
dereferenceable 
newKernel
invariant 
Analyzes OpenCL printf calls
load 
pread
store 
__muldf3
 on 
Unknown mangling specifier in datalayout string
 from 
igc-opencl-printf-analysis
 into 
DeSSA
stack
__divsf3
sspstrong
jump-table
OpenCLPrintfAnalysis
constant-pool
posix_memalign
call-entry 
__gcc_qdiv
call-entry &
DIFlagProtected
custom 
write_offset
, align 
llvm.genx.GenISA.PullCentroidBarys
, !tbaa 
__powisf2
, !alias.scope 
sanitize_address
, !noalias 
end_offset
, !range 
putc_unlocked
, addrspace 
__gcc_stoq
same_value 
DIFlagPrivate
remember_state 
buffer_ptr
restore_state 
__exp10f
offset 
__extendsftf2
def_cfa_register 
DW_OP_breg6
def_cfa_offset 
bblockJoin
def_cfa 
source_filename = "
rel_offset 
__truncdfhf2
adjust_cfa_offset 
DIFlagSingleInheritance
restore 
write_offset_true
escape 
speculatable
0x%02x
__truncxfsf2
undefined 
register 
write_offset_false
window_save 
putchar_unlocked
<unserializable cfi directive>
__trunctfdf2
%dwarfreg.
DIFlagReserved
<badreg>
write_offset_ptr
syncscope("
bonnell
__fixsfdi
not_atomic
noduplicates
consume
write_error_string
%ir.
putchar
enable-subreg-liveness
__fixdfti
Enable subregister liveness tracking.
Unexpected trailing characters after mangling specifier in datalayout string
TargetCustom
bblockFalseJoin
FixedStack
llvm.genx.GenISA.PullSampleIndexBarys
Stack
__fixtfsi
uselistorder
JumpTable
printf_ret_val
ConstantPool
popen
GlobalValueCallEntry
__fixunssfsi
ExternalSymbolCallEntry
DW_ATE_imaginary_float
stress-regalloc
to_float
__subxf3
Limit all regclasses to N registers
__fixunsdfdi
join-liveintervals
Resource Indirection Pass
Coalesce copies (default=true)
ptrBC
terminal-rule
llvm.genx.GenISA.cycleCounter
Apply the terminal rule
__fixunsxfti
join-splitedges
ignoring debug info with an invalid version (
Coalesce copies on split edges (default=subtarget)
Resolves OpenCL printf calls
join-globalcopies
__fixunstfdi
Coalesce copies that span blocks (default=subtarget)
Perform analysis and apply optimization to combine number of software threads
verify-coalescing
vector
Verify machine instrs before and after register coalescing
igc-opencl-printf-resolution
Data
pentiumpro
Anti
__gcc_itoq
Out 
__builtin_IB_atomic_or_global_i64
Ord 
OpenCLPrintfResolution
 Latency=
qsort
 Reg=
__floatditf
 Barrier
Hotness
 Memory
OCL IGC-Internal-ERRORERROR!!!: Non-OCL is not supposed to reach here!
 Artificial
<temporary!> 
 Weak
__floattitf
 Cluster
GED ERROR: 
EntrySU
Resolves private memory allocation
ExitSU
readlink
__floatunsitf
  # preds left       : 
indir
  # succs left       : 
igc-private-mem-resolution
  # weak preds left  : 
__exp10
  # weak succs left  : 
__floatundixf
  # rdefs left       : 
Breakpoint
  Latency            : 
PrivateMemoryResolution
  Depth              : 
realloc
  Height             : 
__floatuntixf
  Predecessors:
(no_name)
  Successors:
Analyzes the presence of private memory allocation
Scoreboard:
pwrite
%bb.
__eqtf2
) in 
Berd
igc-private-mem-usage-analysis
invalid
DW_CC_BORLAND_msreturn
stackmap-version
__netf2
Specify the stackmap encoding version (default = 3)
CC Tuple
disable-sched-hazard
PrivateMemoryUsageAnalysis
Disable hazard detection during preRA scheduling
athlon
$noreg
__getf2
UserSubroutine
physreg
Creates annotations for OpenCL program-scope structures
:sub(
realpath
schedmodel
__lttf2
Use TargetSchedModel for latency lookup
switch
scheditins
igc-programscope-constant-analysis
Use InstrItineraryData for latency lookup
!GenericDINode(
Remove unreachable machine basic blocks
__letf2
unreachable-mbb-elimination
__builtin_IB_get_stage_in_grid_size
ProgramScopeConstantAnalysisPass
remove
__gttf2
expected function name in blockaddress
i128
DW_AT_BORLAND_property_write
__unordtf2
__builtin_IB_get_simd_id
cast
f128
rename
ppcf128
__llvm_memcpy_element_unordered_atomic_4
isVoid
stage_in_grid_origin_x
Resolves references to inline constants
glue
reallocf
x86mmx
__llvm_memmove_element_unordered_atomic_2
v1i1
num_work_groups_z
v2i1
igc-programscope-constant-resolve
v4i1
ppc_fp128
v8i1
igc-threadcombining
v16i1
v32i1
ProgramScopeConstantResolutionPass
v64i1
v128i1
__llvm_memset_element_unordered_atomic_16
v512i1
global_size_x
v1024i1
Replace calls to instrinsics which are not supported by the codegen
v1i8
rint
v2i8
__sync_val_compare_and_swap_4
v4i8
expected '=' after target datalayout
v8i8
igc-replace-unsupported-intrinsics
v16i8
Allocation failed
v32i8
__sync_lock_test_and_set_2
v64i8
DWord Scattered Read
v128i8
memcpy_vsrc
v256i8
rintf
v1i16
__sync_fetch_and_add_1
v2i16
expected '=' after name
v4i16
memcpy_vdst
v8i16
DW_AT_GNU_dwo_name
v16i16
__sync_fetch_and_add_16
v32i16
v64i16
memcpy
v128i16
rintl
v1i32
__sync_fetch_and_sub_8
v2i32
air.get_null_visible_function_table
v4i32
memcpy_src
v8i32
rewind
v16i32
__sync_fetch_and_and_4
v32i32
v64i32
memcpy_dst
v1i64
expected top-level entity
v2i64
__sync_fetch_and_or_2
v4i64
CC Tuple list: 
v8i64
memcpy_rem
v16i64
__builtin_IB_atomic_min_global_f32
v32i64
__sync_fetch_and_xor_1
v1i128
air.get_unique_identifier_compute_pipeline_state
v1f32
v2f32
roundl
v2f16
__sync_fetch_and_xor_16
v4f16
Expected '!' here
v8f16
.post
v4f32
!DICompositeType(
v8f32
__sync_fetch_and_nand_8
v16f32
air.atomic_fetch_sub_explicit_texture
v1f64
.body
v2f64
Scoped NoAlias Alias Analysis
v4f64
__sync_fetch_and_max_4
v8f64
Metadata id is already used
Metadata
Untyped
puts
ExceptRef
__sync_fetch_and_umax_2
disable-demotion
load_block
Clone multicolor basic blocks but do not demote cross scopes
memset_vdst
disable-cleanups
tag: 
Do not remove implausible terminators or other similar cleanups
__sync_fetch_and_min_1
demote-catchswitch-only
found end of file while parsing summary entry
Demote catchswitch BBs only (for wasm EH)
memset
adce-remove-control-flow
llvm.genx.GenISA.ftoui.rtn
adce-remove-loops
__sync_fetch_and_min_16
adce
depth2d
Aggressive Dead Code Elimination
memset_dst
callsite-splitting-duplication-threshold
__sync_fetch_and_umin_2
Only allow instructions before a call, if their cost is below DuplicationThreshold
ThreadCombining
consthoist-with-block-frequency
CC Tuple list end. 
Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.
memset_rem
Simple constant propagation
setvbuf
constprop
__atomic_load_2
cvp-dont-process-adds
bindless_image_cube_array_t
Value Propagation
memmove.post
correlated-propagation
!DICompileUnit(
.lhs.trunc
__atomic_store
.rhs.trunc
explicit pointee type should be a function type
Dead Code Elimination
memmove.true
enable-dse-partial-overwrite-tracking
setitimer
Enable partial-overwrite tracking in DSE
__atomic_store_8
enable-dse-partial-store-merging
bindless_image2d_msaa_t
Enable partial store merging in DSE
memmove.false
Program could not be executed
Dead Store Elimination
__atomic_exchange_2
early-cse
forward reference and definition of global have different types
Controls which instructions are removed
memmmove
Early CSE
snprintf
Early CSE w/ MemorySSA
__atomic_compare_exchange
early-cse-memssa
SubType
__Buffer_Typed_DIM_Resource
memmove
__1D_DIM_Resource
llvm.genx.GenISA.RTWrite
__1D_ARRAY_DIM_Resource
__atomic_compare_exchange_8
__2D_DIM_Resource
expected '{' here
__2D_ARRAY_DIM_Resource
ReplaceUnsupportedIntrinsics
__3D_DIM_Resource
!DIFile(
__Cube_DIM_Resource
__atomic_fetch_add_4
__Cube_ARRAY_DIM_Resource
air.fragment
Allocates UAV and SRV numbers to kernel arguments
Warning: File name not specified with the -dump-opt-llvm option.
expected comma after alias or ifunc's type
metadata !"image_access_qualifier"
__atomic_fetch_sub_2
Old LLVM IR (possibly from legacy binary) :  not supported!
coalesce moves coming payloads, insert and extract element
<origin>
igc-resource-allocator
Parsing llvm module failed!
scanf
-cmc
__atomic_fetch_and_1
-instcombine-code-sinking=0
air.kernel
ResourceAllocatorPass
gpu_64-applecl-macosx
!DINamespace(
runtime.cligc64.bc
__atomic_fetch_and_16
Set llvm fast math flags according to compiler options
Error loading the Generic builtin resource
sprintf
Error lazily loading bitcode for generic builtins,is bitcode the right version and correctly formed?
__atomic_fetch_or_8
Error loading the Generic builtin module from buffer
ci-15.36-xxxxx
igc-set-fast-math-flags
vector
llvm.genx.GenISA.RTDualBlendSource
-cl-replace-global-offsets-by-zero
__atomic_fetch_xor_4
-cl-kernel-debug-enable
expected 32-bit integer (too large)
-cl-include-sip-csr
SetFastMathFlags
-cl-include-sip-kernel-debug
setbuf
-cl-include-sip-kernel-local-debug
__atomic_fetch_nand_2
-cl-intel-use-32bit-ptr-arith
-cl-intel-greater-than-4GB-buffer-required
__builtin_IB_sub_group_barrier
-cl-intel-has-buffer-offset-arg
; Function Attrs: 
-cl-intel-gtpin-rera
__stack_chk_fail
-cl-intel-no-prera-scheduling
fmaxf
-cl-intel-use-bindless-buffers
__builtin_IB_get_simd_size
-cl-intel-use-bindless-images
cannot have an attribute group reference in an attribute group
-cl-fp32-correctly-rounded-divide-sqrt
-cl-no-subgroup-ifp
llvm.global.annotations
-cl-uniform-work-group-size
__builtin_IB_get_simd_id
compilation error
image1d_array_t
 -filetype=spv
GenUpdateCB
-dumpvisa
CoalescingEngine
 -dumpvisa
__builtin_IB_simd_shuffle
!DITemplateTypeParameter(
basic_string
invalid hexadecimal number
SmallVector capacity overflow during allocation
Unify
Allocation failed
__builtin_IB_simd_shuffle_us
float2int-max-integer-bw
stat64
Max integer bitwidth to consider in float2int(default=64)
unterminated string constant
Base: 
expected '('
 Offset: 
__builtin_IB_simd_shuffle_f
 Length: 
statvfs
enable-pre
tlsgd
enable-load-pre
Bitwidth for integer type out of range
max-recurse-depth
__builtin_IB_simd_shuffle_h
Max recurse depth (default = 1000)
Invalid function argument type
unexpected token
expected metadata or 'addrspace'
.pre
__builtin_IB_simd_shuffle_b
.pre-phi
stpncpy
LoadClobbered
invalid reassignment of non-absolute variable '
Type
.cpo
OtherAccess
__builtin_IB_simd_shuffle_df
 because it is clobbered by 
llvm.genx.GenISA.RenderTargetReadSampleFreq
ClobberedBy
.ascii
LoadElim
Expected ')' in syncscope
InfavorOfValue
__builtin_IB_simd_shuffle_down
Global Value Numbering
stpcpy
LoadPRE
.short
load eliminated by PRE
Never resolved value found in function
gvn-max-hoisted
__builtin_IB_simd_shuffle_down_us
Max number of instructions to hoist (default unlimited = -1)
dso_location and DLL-StorageClass mismatch
gvn-hoist-max-bbs
.4byte
Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)
.hoist
gvn-hoist-max-depth
__builtin_IB_simd_shuffle_down_uc
Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)
strcat
gvn-hoist-max-chain-length
.single
Maximum length of dependent chains to hoist (default = 10, unlimited = -1)
Old-style alloca with a non-pointer type
__builtin_IB_simd_block_read_1_global
.sink
!DIImportedEntity(
irce-loop-size-cutoff
.align32
irce-print-changed-loops
pointers to void are invalid - use i8* instead
irce-print-range-checks
__builtin_IB_simd_block_read_2_global
irce-max-exit-prob-reciprocal
strcasecmp
irce-skip-profitability-checks
.p2align
irce-allow-unsigned-latch
e-p:32:32:32
InductiveRangeCheck:
__builtin_IB_simd_block_read_4_global
  Kind: 
DW_TAG_pointer_type
  Begin: 
.fill
  Step: 
expected '(' in call
  End: 
__builtin_IB_simd_block_read_8_global
  CheckUse: 
-dumpVisaOptions
 Operand: 
.global
RANGE_CHECK_UNKNOWN
sample_ld2dms
RANGE_CHECK_UPPER
__builtin_IB_simd_block_read_1_global_h
RANGE_CHECK_LOWER
unterminated comment
RANGE_CHECK_BOTH
.private_extern
llvm.loop.unroll.disable
igc-advmemopt
verify-indvars
__builtin_IB_simd_block_read_2_global_h
Verify the ScalarEvolution result after running indvars
llvm.genx.GenISA.itof.rtz
replexitval
.weak_def_can_be_hidden
Choose the strategy to replace exit value in IndVarSimplify
 (Producer: '
never
__builtin_IB_simd_block_read_4_global_h
never replace exit value
.common
cheap
Find interesting constants
only replace exit value when the cost is cheap
code sinking
always
__builtin_IB_simd_block_read_8_global_h
always replace exit value whenever possible
 = !{
indvars-post-increment-ranges
.code16gcc
Use post increment control-dependent ranges in IndVarSimplify
Invalid value
disable-lftr
__builtin_IB_simd_block_read_16_global_h
Disable Linear Function Test Replace optimization
strcpy
.int
.irpc
Remove redundant instructions
invalid function return type
instsimplify
__builtin_IB_simd_block_read_1_global_b
jump-threading-threshold
targetlibinfo
Max block size to duplicate for jump threading
.bundle_unlock
jump-threading-implication-search-threshold
GTPIN_IGC_OCL Error: Fail to find a free BTI for GT-Pin surface %d
The number of predecessors to search for a stronger condition to use to thread over a weaker condition
__builtin_IB_simd_block_read_2_global_b
print-lvi-after-jump-threading
strcspn
Print the LazyValueInfo cache after JumpThreading
.ifgt
thread-pre-split
forward references to non-struct type
__builtin_IB_simd_block_read_4_global_b
.thr_comm
llvm.genx.GenISA.SampleOffsetX
.thread
.ifb
.split-lp
A32 
select.unfold
__builtin_IB_simd_block_read_8_global_b
Jump Threading
strdup
jump-threading
.ifnc
LVI for function '
expected number in address space
__builtin_IB_simd_block_read_16_global_b
disable-licm-promotion
strcoll
Disable memory promotion in LICM pass
.ifnotdef
licm-max-num-uses-traversed
ProcessBuiltinMetaData
Max num uses visited for identifying load invariance in loop using invariant start (default = 8)
__builtin_IB_simd_block_read_1_global_l
.promoted
expected '(' in operand bundle
Loop Invariant Code Motion
.endif
licm
CodeHoisting
InstSunk
__builtin_IB_simd_block_read_2_global_l
Inst
.split.loop.exit
.loc
funclet
none
__builtin_IB_simd_block_read_4_global_l
.lcssa
strncasecmp
Hoisted
.cv_loc
LoadWithLoopInvariantAddressCondExecuted
__FastRelaxedMath
failed to hoist load with loop-invariant address because load is conditionally executed
__builtin_IB_simd_block_read_8_global_l
LoadWithLoopInvariantAddressInvalidated
!DILocalVariable(
failed to move load with loop-invariant address because the loop may invalidate its value
.cv_def_range
PromoteLoopAccessesToScalar
pagedir="TL";
Moving accesses to memory location out of the loop
__builtin_IB_simd_block_write_1_global
sink-freq-percent-threshold
strncat
Do not sink instructions that require cloning unless they execute less than this percent of the time.
.cv_fpo_data
max-uses-for-sinking
instruction expected to be numbered '%
Do not sink instructions that have too many uses.
__builtin_IB_simd_block_write_2_global
Delete dead loops
llvm.genx.GenISA.RuntimeValue
loop-deletion
.cfi_startproc
loop-prefetch-writes
Set Functions' linkage and attributes
Prefetch write addresses
__builtin_IB_simd_block_write_4_global
prefetch-distance
strncmp
Number of instructions to prefetch ahead
.cfi_adjust_cfa_offset
min-prefetch-stride
vmeSearchPathType
Min stride to add prefetches
__builtin_IB_simd_block_write_8_global
max-prefetch-iters-ahead
strlen
Max number of iterations to prefetch ahead
.cfi_personality
loop-distribute-verify
globalSize
Turn on DominatorTree and LoopInfo verification after Loop Distribution
__builtin_IB_simd_block_write_1_global_h
loop-distribute-non-if-convertible
size too large for vector
Whether to distribute into a loop that may not be if-convertible by the loop vectorizer
igc-find-interesting-constants
loop-distribute-scev-check-threshold
Code Hoisting
The maximum number of SCEV checks allowed for Loop Distribution
__builtin_IB_simd_block_write_2_global_h
loop-distribute-scev-check-threshold-with-pragma
notail 
The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma loop distribute(enable)
.cfi_signal_frame
enable-loop-distribute
enqueuedLocalSize
Enable the new, experimental LoopDistribution Pass
__builtin_IB_simd_block_write_4_global_h
use-lir-code-size-heurs
strndup
Use loop idiom recognition code size heuristics when compilingwith -Os/-Oz
.macros_on
memset_pattern16
invalid array element type: 
loop-interchange-threshold
__builtin_IB_simd_block_write_8_global_h
Interchange if you gain more than this number
FK_GPRel_2
runtime-check-per-loop-load-elim
.endm
Max number of memchecks allowed per eliminated load on average
Invalid user defined function being processed: 
loop-load-elimination-scev-check-threshold
__builtin_IB_simd_block_write_16_global_h
The maximum number of SCEV checks allowed for Loop Load Elimination
strnlen
loop-predication-enable-iv-truncation
.error
loop-predication-enable-count-down-loop
expected constraint string
loop-predication-skip-profitability-checks
__builtin_IB_simd_block_write_1_global_b
loop-predication-latch-probability-scale
llvm.genx.GenISA.SetDebugReg
scale factor for the latch probability. Value should be greater than 1. Lower values are ignored
.reloc
reroll-num-tolerated-failed-matches
DescRegNum
The maximum number of failures to tolerate during fuzzy matching. (default: 400)
__builtin_IB_simd_block_write_2_global_b
rotation-max-header-size
strspn
The default maximum header size for automatic loop rotation
.dc.d
Rotate Loops
expected basic block name in blockaddress
loop-rotate
__builtin_IB_simd_block_write_4_global_b
enable-lsr-phielim
strncpy
Enable LSR phi elimination
.dc.x
lsr-insns-cost
UserFunction
Add instruction count to a LSR cost model
__builtin_IB_simd_block_write_8_global_b
lsr-exp-narrow
vector elements must have integer, pointer or floating point type
Narrow LSR complex solution using expectation of registers number
.dcb.l
lsr-filter-same-scaled-reg
GsMaxOutputVertices
Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale
__builtin_IB_simd_block_write_16_global_b
[NumUses=
DW_AT_APPLE_runtime_class
reg(
**error: HasBaseReg**
ResolveOCLAtomics
**error: !HasBaseReg**
__builtin_IB_simd_block_write_1_global_l
*reg(
strtof
imm(
.ds.p
 instruction
FastStage1
__builtin_IB_simd_block_write_2_global_l
 reg
llvm.log.f64
, with addrec cost 
.print
, plus 
e-p:64:64:64
 IV mul
__builtin_IB_simd_block_write_4_global_l
 base add
__sync_fetch_and_umin_4
 scale cost
unassigned file number: 
 imm cost
invalid indices for extractvalue
 setup cost
__builtin_IB_simd_block_write_8_global_l
UserInst=
strcmp
, OperandValToReplace=
directional label undefined
, PostIncLoop=
invalid region horizontal stride on src0
, Offset=
__builtin_IB_simd_media_block_read_1
LSR Use: Kind=
llvm.genx.GenISA.SampleOffsetY
Basic
unknown directive
Special
insertvalue operand must be aggregate type
ICmpZero
__builtin_IB_simd_media_block_read_2
Address of 
llvm.genx.GenISA.setMessagePhaseV
pointer
unexpected token in '.ifc' directive
 in addrspace(
, Offsets={
__builtin_IB_simd_media_block_read_4
, all-fixups-outside-loop
expected string parameter for '.ifnes' directive
, widest fixup type: 
Find Interesting Constants
in formulae referencing 
GsOutputPrimitiveTopology
 in use 
__builtin_IB_simd_media_block_read_8
 , add offset 
strtold
LSR has identified the following interesting factors and types: 
unexpected token in '.elseif' directive
LSR is examining the following fixup sites:
BreakConstantExprPass
LSR is examining the following uses:
__builtin_IB_simd_media_block_read_1_h
unroll-threshold
; Materializable
The cost threshold for loop unrolling
Encountered a .endif that doesn't follow an .if or .else
unroll-partial-threshold
The cost threshold for partial loop unrolling
__builtin_IB_simd_media_block_read_2_h
unroll-max-percent-threshold-boost
strtol
The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat.
.endmacro
unroll-max-iteration-count-to-analyze
packed_double4
Don't allow loop unrolling to simulate more than this number ofiterations when checking full unroll profitability
__builtin_IB_simd_media_block_read_4_h
unroll-count
          catch 
Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes
cannot mix positional and keyword arguments
unroll-max-count
expected ')' in binary constantexpr
Set the max unroll count for partial and runtime unrolling, fortesting purposes
__builtin_IB_simd_media_block_read_8_h
unroll-full-max-count
strtoul
Set the max unroll count for full unrolling, for testing purposes
missing value for required parameter '
unroll-peel-count
packed_ulong4
Set the unroll peeling count, for testing purposes
__builtin_IB_simd_media_block_read_16_h
unroll-allow-partial
DW_TAG_interface_type
Allows loops to be partially unrolled until -unroll-threshold loop size is reached.
unbalanced parentheses in macro argument
unroll-allow-remainder
constexpr requires integer operands
Allow generation of a loop remainder (extra iterations) when unrolling a loop.
__builtin_IB_simd_media_block_read_1_b
unroll-runtime
llvm.genx.GenISA.SetStream
Unroll loops with run-time trip counts
' directive
unroll-max-upperbound
HW64(0x
The max of trip count upper bound that is considered in unrolling
__builtin_IB_simd_media_block_read_2_b
pragma-unroll-threshold
ulong2
Unrolled size limit for loops with an unroll(full) or unroll_count pragma.
invalid floating point literal
flat-loop-tripcount-threshold
GsInputPrimitiveType
If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.
__builtin_IB_simd_media_block_read_4_b
unroll-allow-peeling
strxfrm
Allows loops to be peeled when the dynamic trip count is known to be low.
alignment must be a power of 2
unroll-remainder
ulong
Allow the loop remainder to be unrolled.
__builtin_IB_simd_media_block_read_8_b
unroll-revisit-child-loops
Target Library Information
Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited.
unexpected token in '.fill' directive
llvm.loop.unroll.count
uchar4
llvm.loop.unroll.runtime.disable
__builtin_IB_simd_media_block_read_16_b
Unroll loops
strtoull
loop-unroll
unexpected token in '.zero' directive
UnrollAsDirectedTooLarge
base element of getelementptr must be sized
Unable to unroll loop as directed by unroll(enable) pragma because unrolled size is too large.
__builtin_IB_simd_media_block_read_1_l
FullUnrollAsDirectedTooLarge
to caller
Unable to fully unroll loop as directed by unroll pragma because unrolled size is too large.
alignment not supported on this target
CantFullUnrollAsDirectedRuntimeTripCount
char4
Unable to fully unroll loop as directed by unroll(full) pragma because loop has a runtime trip count.
__builtin_IB_simd_media_block_read_2_l
DifferentUnrollCountFromDirected
strtok_r
Unable to unroll loop the number of times directed by unroll_count pragma because remainder loop is restricted (that could architecture specific or because the loop contains a convergent instruction) and so must have an unroll count that divides the loop trip multiple of 
invalid symbol redefinition
TripMultiple
uchar
.  Unrolling instead 
__builtin_IB_simd_media_block_read_4_l
UnrollCount
DW_TAG_type_unit
allow-unroll-and-jam
' detected. Assembly stopping.
Allows loops to be unroll-and-jammed.
ushort4
unroll-and-jam-count
__builtin_IB_simd_media_block_read_8_l
Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes
llvm.genx.GenISA.StackAlloca
unroll-and-jam-threshold
expected string in '.incbin' directive
Threshold to use for inner loop when doing unroll and jam.
packed_short4
pragma-unroll-and-jam-threshold
__builtin_IB_simd_media_block_write_1
Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.
expected ')' in logical constantexpr
loop-unswitch-threshold
dynamic texture folding
Max loop size to unswitch
GsMaxInputAttributeCount
licm-versioning-invariant-threshold
__builtin_IB_simd_media_block_write_2
LoopVersioningLICM's minimum allowed percentageof possible invariant instructions per loop
tmpfile
licm-versioning-max-depth-threshold
unexpected token in '.endr' directive
LoopVersioningLICM's threshold for maximum allowed loop nest/depth
packed_uint4
llvm.mem.parallel_loop_access
__builtin_IB_simd_media_block_write_4
likely-branch-weight
DW_TAG_class_type
Weight of the branch likely to be taken (default = 2000)
expected End of Statement
unlikely-branch-weight
expected ')' after comdat var
Weight of the branch unlikely to be taken (default = 1)
__builtin_IB_simd_media_block_write_8
times
The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)
expected end of statement
deopt
packed_int4
MemCpy Optimization
__builtin_IB_simd_media_block_write_1_h
memcpyopt
          to 
Controls which instructions are value numbered
invalid option for '.bundle_lock' directive
source specified, but no file number
Controls which instructions we create phi of ops for
__builtin_IB_simd_media_block_write_2_h
enable-phi-of-ops
expected 'within' identifier in '.cv_inline_site_id' directive
sroa_raw_idx
missing required field 'type'
sroa_cast
__builtin_IB_simd_media_block_write_1_b
sroa_idx
DW_TAG_template_value_parameter
sroa
expected integer in '
 is not a valid parameter qualifier for '
ymmword ptr 
load.ext
cbit
jmpi
Jump Indexed
The jmpi instruction redirects program execution to an index offset relative to the post-incremented instruction pointer. The index is a signed integer value, with positive or zero integers for forward jumps, and negative integers for backward jumps. In GEN binary, index is at location src1. The ip register must be put (for example, by the assembler) at the dst and src0 locations. Predication is allowed to provide conditional jump with a scalar condition. As the execution size is 1, the first channel of PMASK (flags post prediction control and negate) is used to determine whether the jump is taken or not. If the condition is false, the jump is not taken and execution continues with the next instruction.
Note: Unlike other flow control instructions, the offset used by jmpi is relative to the incremented instruction pointer rather than the IP value for the instruction itself.
Format:
[(pred)] jmpi (1) index {NoMask}
An index of 0 does nothing, continuing execution with the next instruction.
An index of -16 (if the jmpi instruction is in native format) or -8 (if the jmpi instruction is in compact format) is an infinite loop on the jmpi instruction.
Line
The line instruction computes a component-wise line equation (v = p * u + q where u, v are vectors and p, q are scalars) of src0 and src1 and stores the results in dst. src1 is the input vector u. src0 provides input scalars p and q, where p is the scalar value based on the region description of src0 and q is the scalar value implied from src0 region. Specifically, q is the fourth component of the 4-tuple (128-bit aligned) that p belongs to.
Format:
[(pred)] line[.cmod] (exec_size) dst src0 src1
The lrp instruction takes component-wise multiplication of src0 and src1, and adds the result to the component-wise multiplication of src2 and (1 - src0), and then stores the final results in dst.
Format:
[(pred)] lrp[.cmod] (exec_size) dst src0 src1 src2
Leading Zero Detection
The lzd instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is zero, store 32 in dst.
Format:
[(pred)] lzd[.cmod] (exec_size) dst src0
Multiply Accumulate
The mac instruction takes component-wise multiplication of src0 and src1, adds the results with the corresponding accumulator values, and then stores the final results in dst.
Format:
[(pred)] mac[.cmod] (exec_size) dst src0 src1
Multiply Accumulate High
The mach instruction performs DWord integer multiply-accumulate operation and outputs the high DWord (bits 63:32). For each enabled channel, this instruction multiplies the DWord in src1 with the high word of the DWord in src0, left shifts the result by 16 bits, adds it with the corresponding accumulator values, and keeps the whole 64-bit result in the accumulator. It then stores the high DWord (bits 63:32) of the results in dst.
This instruction is intended to be used to emulate 32-bit DWord integer multiplication by using the large number of bits available in the accumulator. For example, the following four instructions perform vector multiplication of two 32-bit signed integer sources from r2 and r3 and store the resulting vectors with the high 32 bits in r5 and the low 32 bits in r6.
mul (8) acc0:d r2.0<8;8,1>:d r3.0<8;8,1>:d //All channels must be enabled
mach (8) rTemp<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d //All channels must be enabled
mov (8) r5.0<1>:d rTemp<8;8,1>:d // High 32 bits
mov (8) r6.0<1>:d acc0:d // Low 32 bits
The mul and mach instructions must have all channels enabled. The first mov should have channel enable from the destHI of IMUL, the second mov should have the channel enable from the destLO of IMUL. As mach is used to generate part of the 64-bit DWord integer results, saturation modifier should not be used. In fact, saturation modifier should not be used for any of these four instructions. Source and destination operands must be DWord integers. Source and destination must be of the same type, signed integer or unsigned integer. If dst is UD, src0 and src1 may be UD and/or D. However, if any of src0 and src1 is D, source modifier (abs) must be present to convert it to match with dst. If dst is D, src0 and src1 must also be D. They cannot be UD as it may cause unexpected overflow because the computed results are limited to 64 bits.
Format:
[(pred)] mach[.cmod] (exec_size) dst src0 src1
The mad instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The conditional modifier and saturation (.sat) must not be used when src1 or src2 are dwords.
Format:
[(pred)] mad[.cmod] (exec_size) dst src0 src1 src2
math
Extended Math Function
MathFC[3:0]
math.cos
Cosine function. cos(src0)
math.exp
Exponential (E^src0)
fdiv
math.fdiv
Floating-Point Divide function. src0/src1
idiv
math.idiv
Integer Divide with Quotient and Remainder. The quotient goes in the destination register; the remainder goes in the following register.
math.inv
Reciprocal (Multiplicative Inverse): 1/src0
iqot
math.iqot
Integer Quotient only
irem
math.irem
Integer Remainder only
math.log
Natural log: ln(src0)
math.pow
src0^src1
rsqt
math.rsqt
Reciprocal Square Root: 1/sqt(src)
math.sin
Sine function. sin(src0)
math.sqt
endian_shift
__builtin_IB_simd_media_block_write_2_b
insert
tanhl
column position less than zero in '.cv_loc' directive
.shift
CheckInstrTypes
.ext
__builtin_IB_simd_media_block_write_4_b
.insert
llvm.genx.GenISA.typedmemoryfence
load.trunc
expected SourceField in '.cv_inline_linetable' directive
.expand
unknown read subop
blend
__builtin_IB_simd_media_block_write_8_b
oldload
expected SourceLineNum in '.cv_inline_linetable' directive
copyload
igc-dynamic-texture-folding
isplat
GsOutputCullDistanceMask
vsplat
__builtin_IB_simd_media_block_write_16_b
.fca
 nnan
.gep
Expected an identifier
.load
air.stage_in_grid_origin
.sroa.speculated
__builtin_IB_media_block_read
.sroa.speculate.load.
unlink
.sroa.speculate.load.true
unsupported encoding.
.sroa.speculate.load.false
air.instance_id
SROA
__builtin_IB_media_block_write
Scalar Replacement Of Aggregates
llvm.genx.GenISA.URBWrite
' should be last one in the list of parameters.
disable-separate-const-offset-from-gep
Emulate Argument Buffers
Do not separate the constant offset from a GEP instruction
' directive with negative repeat count has no effect
Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.
invalid linkage for function definition
structurizecfg-skip-uniform-regions
__builtin_IB_sub_group_reduce_OpGroupFMax
Force whether the StructurizeCFG pass skips uniform regions
llvm.genx.GenISA.UpdateDiscardMask
lpad
unexpected expression in _emit
lpad.phi
Square Root
Move
The mov instruction moves the components in src0 into the channels of dst. If src0 and dst are of different types, format conversion is performed. If src0 is a scalar immediate, the immediate value is loaded into enabled channels of dst.
A mov with the same source and destination type, no source modifier, and no saturation is a raw move. A packed byte destination region (B or UB type with HorzStride == 1 and ExecSize > 1) can only be written using raw move.
When denorm mode is flush to zero, a raw mov instruction with saturation modifier will not flush the denorm input or output to zero (Denorm is preserved).
Format: [(pred)] mov[.cmod] (exec_size) dst src0
A mov instruction with a source modifier always copies a denorm source value to a denorm destination value
(in the manner of a raw move).
There is no direct conversion from B/UB to DF or DF to B/UB. Use two instructions and a word or DWord intermediate type.
movi
Move Indexed
The movi instruction performs a fast component-wise indexed move for subfields from src0 to dst. The source
operand must be an indirectly-addressed register. All channels of the source operand share the same register
number, which is provided by the register field of the first address subregister, with a possible immediate
register offset. The register fields of the subsequent address subregisters are ignored by hardware. The
subregister number of a source channel is provided by the subregister field of the corresponding address
subregister, with a possible immediate subregister offset.
The destination register may be either a directly-addressed or an indirectly-addressed register.
This instruction effectively performs a subfield shuffling from one register to another. Up to eight
subfields can be selected by an instruction.
Format: [(pred)] movi (exec_size) dst src0
HW Implementation Details:
The source register is calculated by adding the register portion of the first index register with the
register portion of the address immediate, a0.0[11:5] + addr_imm[9:5]
For byte movi, byte0 of the destination is selected by (a0.0[4:0]), byte1 is selected by (a0.1[4:0]), ...,
and byte7 is selected by (a0.7[4:0]). The rest of the bytes are undefined.
For word movi, byte0 of the destination is selected by (a0.0[4:1] & 0), byte1 is selected by (a0.0[4:1]
& 1), byte2 is selected by (a0.1[4:1] & 0), byte3 is selected by (a0.1[4:1] & 1), ..., and byte15
is selected by (a0.7[4:1] & 1). The rest of the bytes are undefined.
For DWord or float movi, byte0 of the destination is selected by (a0.0[4:2] & 00b), byte1 is selected
by (a0.0[4:2] & 01b), byte2 is selected by (a0.0[4:2] & 10b), byte3 is selected by (a0.0[4:2] &
11b), byte4 is selected by (a0.1[4:2] & 00b), byte5 is selected by (a0.1[4:2] & 01b), ..., byte31
is selected by (a0.7[4:2] & 11b).
For all 3 conditions above, a0.n[4:0] = a0.n[4:0] + addr_imm[4:0].
Multiply
The mul instruction performs component-wise multiplication of src0 and src1 and stores the results in dst.
When both src0 and src1 are of type D or UD, only the low 16 bits of each element of src1 are used. The accumulator maintains full 48-bit precision. The macro described in the mach instruction should be used to obtain the full precision 64-bit multiplication result.
Multiplication of two floating-point numbers follows the rules in mul - Multiply [Pre-DevBDW] or mul - Multiply [Pre-DevBDW]) based on the applicable floating-point mode.
Format:
[(pred)] mul[.cmod] (exec_size) dst src0 src1
Do nothing. The nop instruction takes an instruction dispatch but performs no operation. It can be used for assembly patching in memory, or to insert a delay in the program sequence.
Format:
Logic Not
Logic Or
The or instruction performs component-wise logic OR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the OR operation.
Format:
[(pred)] or[.cmod] (exec_size) dst src0 src1
Plane
The pln instruction computes a component-wise plane equation (w = p*u+q*v+r where u/v/w are vectors and p/q/r are scalars) of src0 and src1 and stores the results in dst. src1 is the input vector u.
src0 provides input scalars p, q, and r, where p is the scalar value based on the region description of src0 and q and r are the scalar values implied from the src0 region. Specifically, q is the second component and r is the fourth component of the 4-tuple (128-bit aligned) that p belongs to.
Format:
[(pred)] pln[.cmod] (exec_size) dst src0 src1
Return execution to the code sequence that called a subroutine.
The ret instruction can be predicated or non-predicated. If non-predicated, all channels jump to the return IP in the first channel of src0 and restore CallMask from the second channel of src0. If predicated, the enabled channels jump to the return IP from the first channel of src0 and the corresponding bits in the CallMask are cleared to zero; if all CallMask bits are zero after the ret instruction, then execution jumps to the return IP from the first channel of src0.
When SPF is on, the predication control must be scalar.
Format:
[(pred)] ret (exec_size) null src0
rndd
Round Down
rnde
Round to Nearest or Even
The rnde instruction takes component-wise floating point round-to-even operation of src0 with results in two pieces - a downward rounded integral float results stored in dst and the round-to-even increments stored in the rounding increment bits. The round-to-even increment must be added to the results in dst to create the final round-to-even values to emulate the round-to-even operation, commonly known as the round() function. The final results are the one of the two integral float values that is nearer to the input values. If the neither possibility is nearer, the even alternative is chosen.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rnde[.cmod] (exec_size) dst src0
Round Up
The rndu instruction takes component-wise floating point upward rounding (to the integral float number closer to positive infinity) of src0, commonly known as the ceiling() function.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rndu[.cmod] (exec_size) dst src0
rndz
Round to Zero
The rndz instruction takes component-wise floating point round-to-zero operation of src0 with results in two pieces - a downward rounded integral float results stored in dst and the round-to-zero increments stored in the rounding increment bits. The round-to-zero increment must be added to the results in dst to create the final round-to-zero values to emulate the round-to-zero operation, commonly known as the truncate() function. The final results are the one of the two closest integral float values to the input values that is nearer to zero.
Format:
[(pred)] rndz[.cmod] (exec_size) dst src0
sad2
Sum of Absolute Difference 2
sada2
Sum of Absolute Difference Accumulate 2
The sada2 instruction takes source data channels from src0 and src1 in groups of 2-tuples. For each 2-tuple, it computes the sum-of-absolute-difference (SAD) between src0 and src1, adds the intermediate result with the accumulator value corresponding to the first channel, and stores the scalar result in the first channel of the 2-tuple in dst.
The destination operand and the accumulator maintain 16 bits per channel precision. Higher precision (guide bits) stored in the accumulator allows up to 64 rounds of sada2 instructions to be issued back to back without overflowing the accumulator.
The destination register must be aligned to even word (DWord). The even words in the destination region will contain the correct data. The odd words are also written but with undefined values.
Format:
[(pred)] sada2[.cmod] (exec_size) dst src0 src1
Select
The sel instruction selectively moves the components in src0 or src1 into the channels of dst based on the predication. On a channel by channel basis, if the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst.
As the predication is used to select the two sources, it is not included in the evaluation of WrEn. The predicate clause is mandatory if cmod is omitted/0000b. If both predication and the conditional modifier are omitted, the results are undefined.
If the conditional modifier is specified (not 0000b, a compare is performed and the resulting condition flag is used for the sel instruction. Conditional modifiers .ge and .l follow the cmpn rules, and all other conditional modifiers follow the cmp rules. Predication is not allowed in this mode.
A sel instruction with cmod .l is used to emulate a MIN instruction.
A sel instruction with cmod .ge is used to emulate a MAX instruction.
For a sel instruction with a .l or .ge conditional modifier, if one source is NaN and the other not NaN, the non-NaN source is the result. If both sources are NaNs, the result is NaN. For all other conditional modifiers, if either source is NaN then src1 is selected.
A sel instruction without a conditional modifier always copies a denorm source value to a denorm destination value (in the manner of a raw move). This applies even if the source modifies are set on the sel instruction sources.
The sel instruction uses any conditional modifier internally and does not update the flag register if a conditional modifier is used.
A sel instruction with a conditional modifier flushes any selected denorm source value to a zero destination value.
Format:
(pred) sel[.cmod] (exec_size) dst src0 src1
send
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 6-bit immediate, imm6. The lower 4bits of the <ex_desc> specifies the SFID for the message. The MSb of the message descriptor, the EOT field, always comes from bit 127 of the instruction word, which is the MSb of imm6. A thread must terminate with a send instruction with EOT turned on.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
Thread managed memory coherency: A special usage of using non-null <dest> is to support write-commit signaling for memory write service by the Data Port Write unit. If <post_dest> is not null for a memory write request, the Data Port along with the Data Cache or Render Cache will wait until all the posted writes for the request have reached the coherent domain before sending back to the requesting thread an empty message to <dest> register. A memory write reaching the coherent domain, also referred to as reaching the global observable state, means that subsequent read to the same memory location, no matter which thread issues the read, must return the data of the write.
The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
sendc
Conditional Send Message
The sendc instruction has the same behavior as the send instruction except the following.
sendc first checks the dependent threads inside the Thread Dependency Register. There are up to 8 dependent threads in the TDR register. The sendc instruction executes only when all the dependent threads in the TDR register are retired.
Wait for dependencies in the TDR Register to clear, then send a message stored in registers starting at src to a shared function identified by exdesc along with control from desc with a general register writeback location at dst.
Format:
[(pred)] sendc (exec_size) dst src0 exdesc desc
Shift Left
Perform component-wise logical left shift of the bits in src0 by the shift count indicated in src1, storing the results in dst, inserting zero bits in the number of LSBs indicated by the shift count.
Hardware detects overflow properly and uses it to perform any saturation operation on the result, as long as the shifted result is within 33 bits. Otherwise, the result is undefined.
Note: For word and DWord operands, the accumulators have 33 bits.
The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
Format:
[(pred)] shl[.cmod] (exec_size) dst src0 src1
Shift Right
Perform component-wise logical right shift with zero insertion of the bits in src0 by the shift count indicated in src1, storing the results in dst. Insert zero bits in the number of MSBs indicated by the shift count.
src0 and dst can have different types and can be signed or unsigned.
Note: For word and DWord operands, the accumulators have 33 bits.
Note: For unsigned src0 types, shr and asr produce the same result.
The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
Format:
[(pred)] shr[.cmod] (exec_size) dst src0 src1
subb
The subb instruction performs component-wise subtraction of src0 and src1 and stores the results in dst, it also stores the borrow into acc.
If the operation produces a borrow (src0 < src1), write 0x00000001 to acc, else write 0x00000000 to acc.
Format:
[(pred)] subb[.cmod] (exec_size) dst src0 src1
wait
Wait Notification
__builtin_IB_sub_group_reduce_OpGroupFMin
_crit_edge
vfprintf
Break critical edges in CFG
 + $$
break-crit-edges
expected function name
cstr
__builtin_IB_sub_group_scan_OpGroupIAdd
strlen
!DIGlobalVariable(
strchr
dword ptr 
strncmp
air.visible
strncpy
.bss
eh.lpad-body
expected '=' after instruction name
thinlto_src_module
BlockReadLocal not supported!
------- Dumping inliner stats for [
DW_AT_import
] -------
.type
-- List of inlined functions:
The wait instruction evaluates the value of the notification count register nreg. If nreg is zero, thread execution is suspended and the thread is put in 'wait_for_notification' state. If nreg is not zero (i.e., one or more notifications have been received), nreg is decremented by one and the thread continues executing on the next instruction. If a thread is in the 'wait_for_notification' state, when a notification arrives, the notification count register is incremented by one. As the notification count register becomes nonzero, the thread wakes up to continue execution and at the same time the notification register is decremented by one. If only one notification arrived, the notification register value becomes zero. However, during the above mentioned time period, it is possible that more notifications may arrive, making the notification register nonzero again.
When multiple notifications are received, software must use wait instructions to decrement notification count registers for each notification.
Notification register n0.0:ud is for thread to thread communication (via the Message Gateway shared function) and n0.1:ud for host to thread communication (through MMIO registers). See the Message Gateway chapter for thread-thread communication and the Debug chapter for host-to-thread communication.
Format:
wait (exec_size) nreg
while
While
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
The following table describes the 16-bit jump target offset JIP. JIP is a signed 16-bit number, added to IP pre-increment, and should point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing. In GEN binary, JIP is at location src1 and must be of type W (signed word integer).
Format:
[(pred)] while (exec_size) JIP
Logic Xor
The xor instruction performs component-wise logic XOR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the XOR operation.
Format:
[(pred)] xor[.cmod] (exec_size) dst src0 src1
The bfi1 instruction is the first instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi1 instruction component-wise generates mask with control from src0 and src1 and stores the results in dst. The mask is used in the bfi2 instruction to generate the final result of bfi.
Create a bit mask corresponding to the bit field width and offset in src0 and src1. Store the bit mask in dst. The mask has all bits in the bit field set to 1 and all other bits as 0.
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi1 (exec_size) dst src0 src1
No accumulator access, implicit or explicit.
The brc instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if all channels are branched away.
UIP should reference the instruction where all channels are expected to come together. JIP should reference the end of the innermost conditional block.
In GEN binary, JIP and UIP use locations src1 and src0 respectively when immediate and location src0 when reg64, where reg64 is accessed as paired DWord (regioning being <2;2,1>). dst must be IP. When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] brc (exec_size) JIP UIP
The break instruction is used to early-out from the inner most loop, or early out from the inner most switch block.
When used in a loop, upon execution, the break instruction terminates the loop for all execution channels enabled. If all the enabled channels hit the break instruction, jump to the instruction referenced by JIP. JIP should be the offset to the end of the inner most conditional or loop block, UIP should be the offset to the while instruction of the loop block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] break (exec_size) JIP UIP
csel
Conditional Select
The csel instruction selectively moves components in src0 or src1 to the dst based on the result of the compare of src2 with zero. If the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst. The csel instruction provides the function of a cmp followed by sel. The instruction must not be used if cmpn is required. The instruction does not update the flag register.
The comparison follows the same rule as cmp instruction for that data type.
Format:
csel (exec_size) dst src0 src1 src2
The endif instruction terminates an if/else/endif block of code. It restores execution to the channels that were active prior to the if/else/endif block.
The endif instruction is also used to hop out of nested conditionals by jumping to the end of the next outer conditional block when all channels are disabled.
The following table describes the 32-bit JIP. In GEN binary, JIP is at location src1 and must be of type D (signed DWord integer). JIP must be an immediate operand, it is a signed 32-bit number. This value is added to IP pre-increment.
Format:
endif JIP
goto
Goto
The goto instruction directs the instruction pointer to the offset specified by the UIP offset or to the next IP based on the BranchCtrl bit in the instruction. The active channels that are predicated on this instruction will take the IP + UIP path when BranchCtrl is set else the channels take IP + 1. The active channels that are not predicated on this instruction will be made inactive and waiting to be joined at the join IP. The join IP is IP + UIP when BranchCtrl is clear else it is the next IP.
When there are no active channels the instruction pointer will move to IP + JIP.
The goto instruction is used in conjunction with a join instruction. A goto deactivates some channels that are reactivated at some program-specified join instruction. See the join instruction for the activation rules.
The goto and join instructions enable unstructured program control flow. These instructions must be used with additional care where dangling channels can result without proper compiler checks, meaning that it is expected that programs will navigate through these paths to reactivate the channels. Hardware does not provide native checks or reconvergence.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer).
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] goto (exec_size) JIP UIP branch_ctrl
The halt instruction temporarily suspends execution for all enabled compute channels. Upon execution, the enabled channels are sent to the instruction at (IP + UIP), if all channels are enabled at HALT, jump to the instruction at (IP + JIP).
If the halt instruction is not inside any conditional code block, the values of JIP and UIP should be the same. If the halt instruction is inside a conditional code block, the UIP should be the end of the program and the JIP should be the end of the inner most conditional code block.
The UIP must point to a HALT Instruction.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate and dst must be null.
Format:
[(pred)] halt (exec_size) JIP UIP
An if instruction starts an if/endif or an if/else/endif block of code. It restricts execution within the conditional block to only those channels that were enabled via the predicate control.
Each if instruction must have a matching endif instruction and may have up to one matching else instruction before the matching endif.
If all channels are inactive (for the if/endif or if/else/endif block), a jump is performed to the instruction referenced by JIP. This jump must be to right after the matching else instruction when present, or otherwise to the matching endif instruction of the conditional block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the 32-bit exit code <JIP> and <UIP>. If <branch_ctrl> is set, then the JIP points to the first join instruction within the if block. If <branch_ctrl> is not set, <JIP> should point to the instruction right after the matching else instruction if it exsits, otherwise <JIP> should point to the endif instruction. <UIP> should always point to the endif instruction. When a jump occurs, this value is added to IP pre-increment. In GEN instruction binary, <JIP> and <UIP> are at location <src0> & <src1> and must be of type D (signed dword integer).
Format:
[(pred)] if (exec_size JIP UIP <branch_ctrl>
join
The join instruction makes the inactive channels active at the join IP if those channels are predicated. Any deactivated channels due to a goto instruction match the join IP are activated (qualified with predicates at join). If no IP is matched at this join, the program goes to the next IP with the active channels which followed the program path up to the join instruction. If no active channels are present after executing the join instruction, the program jumps to the offset specified by JIP instead of next IP.
The join instruction is used in conjunction with a goto instruction. The join activates channels that are deactivated by the goto instruction. See the goto instruction for the deactivation rules.
The goto and join instructions enable unstructured program control flow. These instructions must be used with additional care where dangling channels can result without proper compiler checks, meaning that it is expected that programs will navigate through these paths to reactivate the channels. Hardware does not provide native checks or reconvergence.
The following table describes the 32-bit JIP. In GEN binary, JIP is at location src1 and must be of type D (signed DWord integer). JIP must be an immediate operand and is a signed 32-bit number. This value is added to IP pre-increment.
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] join (exec_size) JIP
An index of 0 is an infinite loop.
The mach instruction performs DWord integer multiply-accumulate operation and outputs the high DWord (bits 63:32). For each enabled channel, this instruction multiplies the DWord in src0 with the high word of the DWord in src1, left shifts the result by 16 bits, adds it with the corresponding accumulator values, and keeps the whole 64-bit result in the accumulator. It then stores the high DWord (bits 63:32) of the results in dst. This instruction is intended to be used to emulate 32-bit DWord integer multiplication by using the large number of bits available in the accumulator. For example, the following instructions perform vector multiplication of two 32-bit signed integer sources from r2 and r3 and store the resulting vectors with the high 32 bits in r5 and the low 32 bits in r6.
mul (8) acc0:d r2.0<8;8,1>:d r3.0<16;8,2>:uw
mach (8) r5.0<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d
mov (8) r6.0<1>:d acc0:d // Low 32 bits.
Here is a different example including negation. An added preliminary mov is required for source modification on src1.
mov (8) r3.0<1>:d -r3<8;8,1>:d
mul (8) acc0:d r2.0<8;8,1>:d r3.0<16;8,2>:uw
mach (8) r5.0<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d // High 32 bits
mov (8) r6.0<1>:d acc0:d // Low 32 bits.
The mach should have channel enable from the destHI of IMUL, the mov should have the channel enable from the destLO of IMUL. As mach is used to generate part of the 64-bit DWord integer results, saturation modifier should not be used. In fact, saturation modifier should not be used for any of these four instructions. Source and destination operands must be DWord integers. Source and destination must be of the same type, signed integer or unsigned integer. If dst is UD, src0 and src1 may be UD and/or D. However, if any of src0 and src1 is D, source modifier (abs) must be present to convert it to match with dst. If dst is D, src0 and src1 must also be D. They cannot be UD as it may cause unexpected overflow because the computed results are limited to 64 bits.
Format:
[(pred)] mach[.cmod] (exec_size) dst src0 src1
madm
The madm instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The source and destination operands have a higher precision carried in the exponent for this operation. The madm instruction is used for macro operations, where precision is accumulated over several instructions. This accumulation requires the exponent to increase by 2 extra bits across multiple madm operations.
Refer to Macros Defined in 'Math' Section for usage and restrictions of this operation.
Format:
[(pred)] madm[.cmod] (exec_size) dst src0 src1 src2
invm
math.invm
Reciprocal Macro for IEEE754-compliant fdiv
rsqtm
math.rsqtm
RSQTM
Reciprocal Square Root Macro for IEEE754-compliant rsqt
The mov instruction moves the components in src0 into the channels of dst. If src0 and dst are of different types, format conversion is performed. If src0 is a scalar immediate, the immediate value is loaded into enabled channels of dst.
A mov with the same source and destination type, no source modifier, and no saturation is a raw move. A packed byte destination region (B or UB type with HorzStride == 1 and ExecSize > 1) can only be written using raw move.
When denorm mode is flush to zero, a raw mov instruction with saturation modifier will not flush the denorm input or output to zero (Denorm is preserved).
Format: [(pred)] mov[.cmod] (exec_size) dst src0
A mov instruction with a source modifier always copies a denorm source value to a denorm destination value
(in the manner of a raw move).
There is no direct conversion from B/UB to DF or DF to B/UB. Use two instructions and a word or DWord intermediate type.
There is no direct conversion from B/UB to Q/UQ or Q/UQ to B/UB. Use two instructions and a word or DWord intermediate integer type.
There is no direct conversion from HF to DF or DF to HF. Use two instructions and F (Float) as an intermediate type.
There is no direct conversion from HF to Q/UQ or Q/UQ to HF. Use two instructions and F (Float) or a word integer type or a DWord integer type as an intermediate type.
The mul instruction performs component-wise multiplication of src0 and src1 and stores the results in dst. When multiplying integer datatypes, if src0 is DW and src1 is W, irrespective of the destination datatype, the accumulator maintains full 48-bit precision. This is required to handle the macro for 32x32 multiplication. The macro described in the mach instruction should be used to obtain the full precision 64-bit multiplication results.
Note: A 32x32 multiply operation is handled natively, without a macro. When operating in this mode, the resulting 64-bit data is packed, unlike the macro, where the lower and upper 32 bits of the result are written to different general registers by two separate instructions. Refer to the macro description for details.
When multiplying integer data types, if one of the sources is a DW, the resulting full precision data is stored in the accumulator. However, if the destination data type is either W or DW, the low bits of the result are written to the destination register and the remaining high bits are discarded. This results in undefined Overflow and Sign flags. Therefore, conditional modifiers and saturation (.sat) cannot be used in this case.
Format:
[(pred)] mul[.cmod] (exec_size) dst src0 src1
The or instruction performs component-wise logic OR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a OR (NOT b) to be calculated with one instruction.
Format:
[(pred)] or[.cmod] (exec_size) dst src0 src1
The sel instruction selectively moves the components in src0 or src1 into the channels of dst based on the predication. On a channel by channel basis, if the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst.
As the predication is used to select the two sources, it is not included in the evaluation of WrEn. The predicate clause is mandatory if cmod is omitted/0000b. If both predication and the conditional modifier are omitted, the results are undefined.
If the conditional modifier is specified (not 0000b, a compare is performed and the resulting condition flag is used for the sel instruction. Conditional modifiers .ge and .l follow the cmpn rules, and all other conditional modifiers follow the cmp rules. Predication is not allowed in this mode.
A sel instruction with cmod .l is used to emulate a MIN instruction.
A sel instruction with cmod .ge is used to emulate a MAX instruction.
For a sel instruction with a .l or .ge conditional modifier, if one source is NaN and the other not NaN, the non-NaN source is the result. If both sources are NaNs, the result is NaN. For all other conditional modifiers, if either source is NaN then src1 is selected.
A sel instruction without a conditional modifier always copies a denorm source value to a denorm destination value (in the manner of a raw move). This applies even if the source modifies are set on the sel instruction sources.
The sel instruction uses any conditional modifier internally and does not update the flag register if a conditional modifier is used.
A sel instruction with cmod or source modifier will flush denorm to zero, depending on the denorm mode bit; a sel instruction without cmod and source modifier will retain denorm.
Format:
(pred) sel[.cmod] (exec_size) dst src0 src1
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 6-bit immediate, imm6. The lower 4bits of the <ex_desc> specifies the SFID for the message. The MSb of the message descriptor, the EOT field, always comes from bit 127 of the instruction word, which is the MSb of imm6. A thread must terminate with a send instruction with EOT turned on.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals. <dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined. If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null. If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off. The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware). The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases. The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
Thread managed memory coherency: A special usage of using non-null <dest> is to support write-commit signaling for memory write service by the Data Port Write unit. If <post_dest> is not null for a memory write request, the Data Port along with the Data Cache or Render Cache will wait until all the posted writes for the request have reached the coherent domain before sending back to the requesting thread an empty message to <dest> register. A memory write reaching the coherent domain, also referred to as reaching the global observable state, means that subsequent read to the same memory location, no matter which thread issues the read, must return the data of the write.
Perform component-wise logical right shift with zero insertion of the bits in src0 by the shift count indicated in src1, storing the results in dst. Insert zero bits in the number of MSBs indicated by the shift count.
src0 and dst can have different types and can be signed or unsigned.
Note: For word and DWord operands, the accumulators have 33 bits.
Note: For unsigned src0 types, shr and asr produce the same result.
In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
Format:
[(pred)] shr[.cmod] (exec_size) dst src0 src1
smov
Scattered Move
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
The following table describes the 32-bit jump target offset JIP. JIP is a signed 32-bit number, added to IP pre-increment, and should point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing. In GEN binary, JIP is at location src1 and must be of type D (signed dword integer).
Format:
[(pred)] while (exec_size) JIP
The xor instruction performs component-wise logic XOR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a XOR (NOT b) to be calculated with one instruction.
Format:
[(pred)] xor[.cmod] (exec_size) dst src0 src1
The call instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the call instruction. If none of the channels jump into the subroutine, the call instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
When SPF is on, the predication control must be scalar.
The following section describes JIP, the jump offset, for DevSKL+.
JIP can be an immediate or register value. When a jump occurs, this value is added to IP pre-increment. In GEN binary, JIP is at location src1 and src0 must be null. The GRF register must be put (for example, by the assembler) at dst location.
Format: [(pred)] call (exec_size) dst JIP
Format: [(pred)] call (exec_size) dst JIP
The mac instruction takes component-wise multiplication of src0 and src1, adds the results with the corresponding accumulator values, and then stores the final results in dst.
Format:
[(pred)] mac[.cmod] (exec_size) dst src0 src1
When source and destination datatypes are different, the implied datatype for the accumulator operand is always the destination datatype.
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The extended message descriptor field <ex_desc> also contains the extended function control field to be sent to the Target Shared Function over message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 32-bit immediate, imm32. The lower 4bits of the <ex_desc> specifies the SFID for the message. The bit5 of the extended message descriptor, the EOT field, always comes from bit 127 of the instruction word. A thread must terminate with a send instruction with EOT turned on. The higher 16bits, bit31:16 specify the 16bit extended function control field. Interpretation of the extended function control signals is subject to the target external function.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for the source.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals. <dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined. If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null. If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off. The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware). The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases. The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
Split Send Message
The sends instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The sends instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src0> and <src1> are the lead GRF registers for the first and second block of the request respectively. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers corresponding to src0) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend message descriptor field <ex_desc> contains the target function ID, the Extended Message Length (the number of consecutive GRF registers corresponding to src1) and the extended function control signals. WrEn is forwarded to the target function in the message sideband.
The sends instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 31 bits of <reg32a> are used.
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 only. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:16 specify the 16bit extended function control. Interpretation of the extended function control signals is subject to the target external function.</ex_desc></ex_desc></ex_desc></ex_desc>
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 or a 32bit scalar register, <reg32a>. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:12 specify the 20bit extended function control. Interpretation of the extended function control signals is subject to the target external function. The scalar register <reg32a> is selected when SelReg32ExDesc is set, ExDesc.RegNum[3:0] provides the addressing for reg32a for extended message descriptor. This selects one of the index sub registers. Subregisters selected are always aligned to dword. This implies, the even index subregisters must be used.</reg32a></ex_desc></ex_desc></ex_desc></reg32a></ex_desc>
Function control is now extended to 20 bits as specified in the below definition.
<src0> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<src1> is a 256-bit aligned GRF register or a null register. It serves as the leading GRF register for the second block of the request when it is not a null register. It is required that the second block of GRFs does not overlap with the first block. If it is a null register the Extended Message Length must be 0. The sum of Message Length and Extended Message Length must not be greater than 15 on SKL.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for both the sources.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The destination type field is always valid and is used to generate the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The address immediates for indirect sources and destination must be oword aligned.
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'sends' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
NoDDClr and NoDDChk must not be used for send instruction.
Send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sends (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
sendsc
The sendsc instruction has the same behavior as the sends instruction except the following.
sendsc first checks the dependent threads inside the Thread Dependency Register. There are up to 8 dependent threads in the TDR register. The sendsc instruction executes only when all the dependent threads in the TDR register are retired.
Wait for dependencies in the TDR Register to clear, then send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sendsc (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] while (exec_size) JIP
Inlined 
BlockWriteLocal not supported!
imported 
vsprintf
not imported 
.safeseh
function [
expected icmp predicate (e.g. 'eq')
: #inlines = 
xOffset
, #inlines_to_importing_module = 
 <unknown operation 
-- Summary:
.seh_proc
All functions: 
igc.internal_symbol
, imported functions: 
yOffset
inlined functions
redefinition of function '@
all functions
.seh_handler
imported functions inlined anywhere
collectgeometryshaderproperties
imported functions
simdSize
imported functions inlined into importing module
 add
, remaining
.seh_stackalloc
non-imported functions inlined anywhere
__flag_begin_marker
non-imported functions
simdLaneId16
non-imported functions inlined into importing module
wcslen
% of 
one_only
.preheader
expected '[' with indirectbr
.outer
simdShuffle
loop-simplify
vsscanf
Canonicalize natural loops
associative
unroll-runtime-epilog
The csel instruction selectively moves components in src0 or src1 to the dst based on the result of the compare of src2 with zero. If the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst. The csel instruction provides the function of a cmp followed by sel. The instruction must not be used if cmpn is required. The instruction does not update the flag register.
The comparison follows the same rule as cmp instruction for that data type.
When Access Mode is Align1, accumulator may be used as source or destination.
Format:
csel (exec_size) dst src0 src1 src2
The sends instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The sends instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src0> and <src1> are the lead GRF registers for the first and second block of the request respectively. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers corresponding to src0) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend message descriptor field <ex_desc> contains the target function ID, the Extended Message Length (the number of consecutive GRF registers corresponding to src1) and the extended function control signals. WrEn is forwarded to the target function in the message sideband.
The sends instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 31 bits of <reg32a> are used.
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 only. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:16 specify the 16bit extended function control. Interpretation of the extended function control signals is subject to the target external function.</ex_desc></ex_desc></ex_desc></ex_desc>
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 or a 32bit scalar register, <reg32a>. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:12 specify the 20bit extended function control. Interpretation of the extended function control signals is subject to the target external function. The scalar register <reg32a> is selected when SelReg32ExDesc is set, ExDesc.RegNum[3:0] provides the addressing for reg32a for extended message descriptor. This selects one of the index sub registers. Subregisters selected are always aligned to dword. This implies, the even index subregisters must be used.</reg32a></ex_desc></ex_desc></ex_desc></reg32a></ex_desc>
Function control is now extended to 20 bits as specified in the below definition.
Function control is now extended to 20 bits as specified in the below definition.
The sum of Message Length and Extended Message Length must not be greater than 31.
<src0> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<src1> is a 256-bit aligned GRF register or a null register. It serves as the leading GRF register for the second block of the request when it is not a null register. It is required that the second block of GRFs does not overlap with the first block. If it is a null register the Extended Message Length must be 0. The sum of Message Length and Extended Message Length must not be greater than 15 on SKL.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for both the sources.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The destination type field is always valid and is used to generate the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The address immediates for indirect sources and destination must be oword aligned.
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'sends' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
NoDDClr and NoDDChk must not be used for send instruction.
Send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sends (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
dp4a
Dot Product 4 Accumulate
DP4A is a packed four-wide integer dot product and accumulate operation.
Each source's 32-bit channel value is treated as four element vector of 8-bit integer values.
The operation performs a 32-bit precision dot product of those four bytes and adds it with a 32-bit accumulator (typically a GRF, not necessarily an acc# reg).
Format: [(pred)] dp4a (exec_size) dst src0 src1 src2
EXAMPLE (SIMD1 for simplicity):
mov  (1) r1.0:d  0x0102037F:d // (char4)(0x1,0x2,0x3,0x7F)
mov  (1) r2.0:d  50:d
dp4a (1) r3.0:d  r2:d r1:d r1:d
// r3.0 = 50 + (0x1*0x1 + 0x2*0x2 + 0x3*0x3 + 0x7F*0x7F)
//      = 50 + (1 + 4 + 9 + 16129)
//      = 16193
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive prior to entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving the else instruction will be redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by  <JIP>. The jump target should be the matching endif instruction for that conditional block.
The following table describes the 32-bit <JIP>. In GEN binary, <JIP> is at location <src1> and must be of type D (signed dword integer). <JIP> must be an immediate operand, it is a signed 32-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
If the <branch_ctrl> bit is set, then the <JIP> points to the first join instruction within the else block and <UIP> points to the endif instruction. If the <branch_ctrl> bit is not set,  <JIP> and <UIP>, both point to endif.
Format:
else (exec_size) JIP  UIP  branch_ctrl
An else instruction must not be followed by any instruction requiring register indirect access on source operands
The mad instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The conditional modifier and saturation (.sat) must not be used when src1 or src2 are dwords.
Plane and Linear Interpolation instructions are removed. The following macros must be used to emulate Plane and Linear Interpolation operations.
Plane Instruction Emulation
The below plane instruction
pln (16) r20.0<1>:f r10.4<0;1,0>:f r4.0<8;8,1>:f
is emulated as below
mad (8) acc0<1>:nf r10.7<0;1,0>:f r4.0<8;8,1>:f r10.4<0;1,0>:f
mad (8) r20.0<1>:f acc0<8;8,1>:nf r5.0<8;8,1>:f r10.5<0;1,0>:f
mad (8) acc0<1>:nf r10.7<0;1,0>:f r6.0<8;8,1>:f r10.4<0;1,0>:f
mad (8) r21.0<1>:f acc0<8;8,1>:nf r7.0<8;8,1>:f r10.5<0;1,0>:f
In case of SIMD8 pln instruction only the first pair of mad instructions are used.
Linear Interpolation Instruction Emulation
The below lrp instruction
lrp (16) r40.0<1>:f r10.0<8;8,1>:f r20.0<8;8,1>:f r30.0<8;8,1>:f
is emulated as below
mad (8) acc0<1>:nf r30.0<8;8,1>:f r10.0<8;8,1>:f r20.0<8;8,1>:f
mad (8) r40.0<1>:f acc0<8;8,1>:nf -r10.0<8;8,1>:f r30.0<8;8,1>:f
mad (8) acc0<1>:nf r31.0<8;8,1>:f r11.0<8;8,1>:f r21.0<8;8,1>:f
mad (8) r41.0<1>:f acc0<8;8,1>:nf -r11.0<8;8,1>:f r31.0<8;8,1>:f
In case of SIMD8 lrp instruction only the first pair of mad instructions are used.
Format:
[(pred)] mad[.cmod] (exec_size) dst src0 src1 src2
The math instruction performs extended math function on the components in src0, or src0 and src1, and write the output to the channels of dst. The type of extended math function are based on the FC[3:0] encoding in the table below.
Format:
[(pred)] math.<FC> (exec_size) dst src0 src1
Rotate Left
Perform component-wise logical rotate left operation of the bits in src0 by the rotate count indicated in src1, storing the result in dst. src0 and src1 are treated as unsigned numbers with only the bits within the specified datatype used during this operation. This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers are supported. Extra precision bits available in accumulator are ignored during this operation and only the bits within the specified datatype are used.
src0 and dst must be of same datatype precision.
Format: [(pred)] rol[.cmod] (exec_size) dst src0 src1
Rotate Right
Perform component-wise logical rotate right operation of the bits in src0 by the rotate count indicated in src1, storing the result in dst. src0 and src1 are treated as unsigned numbers with only the bits within the specified datatype used during this operation. This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers are supported. Extra precision bits available in accumulator are ignored during this operation and only the bits within the specified datatype are used.
src0 and dst must be of same datatype precision.
Format: [(pred)] ror[.cmod] (exec_size) dst src0 src1
Allow runtime unrolled loops to be unrolled with epilog instead of prolog.
Shuffle Down not supported in SIMD32
unroll-verify-domtree
invalid variant '
Verify domtree after unrolling
cannot make section associative with .linkonce
FullyUnrolled
expected 'unwind' in invoke
completely unrolled loop with 
simdShuffleDown
Peeled
DCL_DSPatchConstInputVec@
 peeled loop by 
you must specify one or both of @unwind or @except
PeelCount
not enough parameters specified for call
 with a breakout at trip 
Block reads not supported in SIMD32
BreakoutTrip
expected @unwind or @except
PartialUnrolled
sample multiversioning
unrolled loop by a factor of 
CollectGeometryShaderProperties
 trips per branch
Block writes not supported in SIMD32
 with run-time trip count
vceilf
unroll-peel-max-count
.alt_entry
Max average trip count which will cause loop peeling.
half2x2
unroll-force-peel-count
SIMD Media Block Read not supported in SIMD32
Force a peel count regardless of profiling information.
half2x4
.peel.begin
.subsections_via_symbols
.peel.next
expected 'unwind' in cleanupret
.peel.newph
SIMD Media Block Write not supported in SIMD32
.peel
you must specify a stack pointer offset
unroll-runtime-multi-exit
.previous
Allow runtime unrolling for loops with multiple exits, when epilog is generated
air.hull
.new
width argument supplied to intel_media_block_read*() must be constant.
.unr-lcssa
fastcc
.epil.preheader
.zerofill
.prol.preheader
expected 'within' after catchswitch
.prol.loopexit
height argument supplied to intel_media_block_read*() must be constant.
xtraiter
llvm.sqrt.f32
lcmp.mod
.const_data
unroll_iter
invalid register file in src%d
niter
width argument supplied to intel_media_block_write*() must be constant.
.nsub
 max
.ncmp
.dyld
epil
expected 'unwind' after catchswitch scope
prol
height argument supplied to intel_media_block_write*() must be constant.
.iter
vsqrtf
.cmp
.linker_option
.unr
HullShaderForcedDispatchMask
.epilog-lcssa
intel_media_block_read
.loopexit
expected SIMD width
loop-version-annotate-no-alias
.mod_init_func
Add no-alias annotation for instructions that are disambiguated by memchecks
twoScalar
intel_media_block_write
Lower SwitchInst's to branches
llvm.exp.f32
lowerswitch
.objc_cat_cls_meth
NewDefault
HullShaderDispatchMode
NodeBlock
width for 
Pivot
llvm.genx.GenISA.WaveClustered
LeafBlock
.objc_class_names
SwitchLeaf
expected ',' in logical operation
mem2reg
*() must be <= 
Promote Memory to Register
vexpf
verify-predicateinfo
.objc_inst_meth
Verify PredicateInfo in legacy printer pass.
NoDDClr
predicateinfo-rename
height for 
Controls which variables are renamed with predicateinfo
 xchg
phi-node-folding-threshold
.objc_meth_var_names
Control the amount of phi node folding to perform (default = 2)
expected 'to' after cast value
simplifycfg-dup-ret
 bytes wide 
Duplicate return instructions into unconditional branches
register number is too high
simplifycfg-sink-common
.objc_selector_strs
Sink common instructions down to the end block
AIR Samplers
simplifycfg-hoist-cond-stores
*() attempt of 
Hoist conditional stores if an unconditional store precedes
simplifycfg-merge-cond-stores
.static_const
Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store
air.compile.framebuffer_fetch_disable
simplifycfg-merge-cond-stores-aggressively
 bytes.  Must be <= 
When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result
DW_AT_abstract_origin
speculate-one-expensive-inst
.thread_init_func
Allow exactly one expensive instruction to be speculatively executed
fast_math_disable
max-speculation-depth
 bytes.
Limit maximum recursion depth when calculating costs of speculatively executed instructions
expected 'within' after cleanuppad
.old
igc-sample-multiversioning
or.cond
chunkPtr
not.cond
_uc*() widths must be quad pixel aligned.
and.cond
vlog1pf
.sink.split
.alt_entry must preceed symbol definition
switch.edge
unknown
.fold.split
_us*() widths must be dual pixel aligned.
magicptr
llvm.genx.GenISA.WaveInverseBallot
infloop
non-local symbol required in directive
switch.early.test
phi node must have first class type
spec.store.select
Resolves sub group functions
spec.select
llvm.log.f32
.critedge
directive '.lsym' is unsupported
brmerge
subregister out of bounds for data type
.mux
igc-sub-group-func-resolution
condstore.split
simplifycfg.merge
ignoring directive .dump for now
switch.selectcmp
error: 
switch.select
SubGroupFuncsResolution
no-jump-tables
llvm.log10.f32
switch.lookup
__textcoal_nt
switch.tableidx
out of dynamic memory in yy_create_buffer()
switch.hole_check
invariant.load
switch.maskindex
switch.shifted
__datacoal_nt
switch.lobit
igc-gen-specific-pattern
switch.table.
p%d:32:32:32
switch.idx.cast
DW_AT_decl_column
switch.idx.mult
change section name to "
switch.offset
expected destination type
switch.cast
p%d:
switch.shiftamt
expected ',' after shuffle value
switch.downshift
unexpected token in '.secure_log_unique' directive
switch.masked
Constant Coalescing
switch.tableidx.zext
-p%d:32:32:32
switch.gep
vsinf
switch.load
unexpected token in '.secure_log_reset' directive
inverted.cmp
air.compile.framebuffer_fetch_enable
indvars
Tries to convert stateless to statefull accesses
iv.rem
llvm.genx.GenISA.WavePrefix
.urem
__DATA
.udiv
Custom Unsafe Optimization Pass
enable-double-float-shrink
igc-stateless-to-statefull-resolution
Enable unsafe double to float shrinking for math lib calls
vlogbf
endptr
unexpected token in '.zerofill' directive
strchr
ld/st operation name
strrchr
StatelessToStatefull
strcmpload
Interpolate@
strlenfirst
unknown region type in '.data_region' directive
strpbrk
fmaxl
strstr
Emit linker warnings to user
memchr.bounds
vlogf
memchr.bits
__cstring
memchr
__igcbuiltin_sp_to_dp
lhsc
undefined-references
lhsv
__dyld
rhsc
__fvmlib_init1
rhsv
indirectbr
chardiff
undefined reference to `
memcmp
.tvos_version_min
real
__literal4
imag
cabs
reciprocal
__mod_init_func
square
Sample Multiversioning
isinf
igc-constant-coalescing
log2
log10
llvm.cos.f32
logmul
__cat_inst_meth
load
tanf
UndefinedReferencesPass
tanl
DW_AT_type
cttz
__cls_meth
ctlz
sext
isdigittmp
Resolve WG built-in
isdigit
vcosf
isascii
__message_refs
ptrtoint
igc-wg-resolution
iprintf
llvm.genx.GenISA.WaveShuffleIndex
__selector_strs
leninc
siprintf
WGFuncResolution
fiprintf
arm_aapcs_vfpcc
__sincospif_stret
__static_const
__sincospi_stret
vasinf
sincospi
cmpDim
sinpi
__symbol_stub
cospi
__thread_init
instcombine
vector select requires selected vectors to have the same vector length as select condition
simplify-libcalls
tmpOffsetR0
folded strlen(select) to select of constants
vtanf
disable-basicaa
OS minor version number required, comma expected
NoAlias
MustAlias
offsetR0
MayAlias
external 
PartialAlias
invalid OS update version number, integer expected
External Alias Analysis
CE: 
external-aa
groupId
Function Alias Analysis Results
global 
previous definition is here
alias-set-saturation-threshold
llvm.sin.f32
The maximum number of pointers may-alias sets may contain before degradation
globalOffset
  AliasSet[
 No predecessors!
must
watchos
make.implicit
 alias, 
numGroups
No access 
vacosf
Ref       
.rodata
Mod       
version number required, comma expected
Mod/Ref   
grid_origin
[volatile] 
.data.rel.ro
 forwarding to 
.symver
Pointers: 
Arguments
    
grid_size
 Unknown instructions: 
__nl_symbol_ptr
Alias Set Tracker: 
.protected
 alias sets for 
print-before
 pointer values.
Resolves work item functions
verify-assumption-cache
vsinhf
Enable verification of assumption cache
.cg_profile
Assumption in scanned function not in cache
print-module-scope
Assumption Cache Tracker
igc-wi-func-resolution
assumption-cache-tracker
llvm.genx.GenISA.WorkGroupAny
basicaa-recphi
.tdata.
basicaa
IRInstrsAfter
Basic Alias Analysis (stateless AA impl)
WIFuncResolution
view-block-freq-propagation-dags
Pop up a window to show a dag displaying how block frequencies propagation through the CFG.
handling and lowering for data available across functions and dylibs
view-bfi-func-name
Output
The option to specify the name of the function whose CFG will be displayed.
__builtin_IB_get_global_offset
view-hot-freq-percent
SetDebugReg@
An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.
preinit_array
pgo-view-counts
*** IR Dump After 
A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.
__builtin_IB_get_work_dim
do not show.
register can't be represented in SEH unwind info
graph
llvm_odrtab
show a graph.
Made Modification '
text
__builtin_IB_get_sync_buffer
show in text.
, sizeM1BitWidth: 
print-bfi
DWARF2 only supports one section per compilation unit
Print the block frequency info.
' on Call Graph Nodes '
print-bfi-func-name
Analyzes work item functions
The option to specify the name of the function whose block frequency info is printed.
Group section must specify the type
BlockFrequencyDAGs
expected the entry size
block-frequency-info: 
printf
: float = 
igc-wi-func-analysis
, int = 
enable-scoped-noalias
, count = 
invalid linkage
, irr_loop_header_weight = 
DPEmuFabs
Block Frequency Analysis
WIFuncsAnalysis
block-freq
__unnamed_
error opening file '
symbol is not in a section: 
' for writing!
cmpSADs@
 done. 
Sets a limit on unrolling metadata to control compile time
digraph "
ProfileSummary
unique id is too large
digraph unnamed {
.u2f.rounding.merge.hi
label="
igc-clamp-loop-unroll
Node
expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '@<type>', '%<type>' or "<type>"
 [shape=record,
unsupported attribute in '.type' directive
label="{
DebugInfoPass
}"];
ClampLoopUnroll
color="red"
createMessagePhases@
Unknown
expected a '@' in the name
 -> Node
igc-precompiled-import
Converts 3d images access to 2d array image accesses where possible
label="%.1f%%"
expected integer count in '.cg_profile' directive
,color="red"
A @@ version cannot be undefined
print-bpi
createMessagePhasesNoInitV@
Print the branch probability info.
igc-3d-to-2darray
print-bpi-func-name
<<null function>>
The option to specify the name of the function whose branch probability info is printed.
.strtab
---- Branch Probabilities ----
unexpected token in '.type' directive
Image3dToImage2darray
edge 
.llvm_addrsig
 probability is 
.rel
 [HOT edge]
Access size field must be a constant
Branch Probability Analysis
converts get_local_size() to get_enqueued_local_size()
branch-prob
Undefined temporary symbol
Inclusion-Based CFL Alias Analysis
Size expression must be absolute.
cfl-anders-aa
Access bit-width not the same as description bit-width
Unification-Based CFL Alias Analysis
igc-rewrite-local-size
cfl-steens-aa
vISA_Platform
Invalidating all non-preserved analyses for: 
FK_Data_8
Invalidating analysis: 
Invalid struct return type!
Call graph node for function: '
RewriteLocalSize
Call graph node <<null function>>
.symtab
FK_PCRel_8
>>  #uses=
Function takes metadata but isn't an intrinsic
  CS<
srem
> calls 
fmax
function '
global-data-resolution-pass
external node
---- AliasMap ----
No call graph has been built!
urem
CallGraph Construction
__svml_expf8
basiccg
FK_TPRel_8
max-cg-scc-iterations
!dbg attachment points at wrong subprogram for function
CallGraph Pass Manager
sext
Call Graph SCC Pass Manager
spir_kernel
size-info
FK_SecRel_8
Print CallGraph IR
GlobalValue with private or internal linkage must be dso_local!
Printing <null> Function
addconv
acos
llvm.genx.GenISA.add.pair
asin
FK_Data_Add_8
atan
More than one parameter has attribute nest!
atan2
diff.neg
acosf
 <<NULL ALIASEE>>
asinf
FK_Data_Sub_8
atanf
Attributes 'readnone and readonly' are incompatible!
atan2f
.not
cosh
__svml_sin4
ceilf
Enable
coshf
Attributes 'minsize and optnone' are incompatible!
expf
fmod
DW_AT_mutable
fmodf
logf
Wrong types for attribute: 
log10f
notmask
roundf
__svml_sin2
sinh
.zero
sinhf
 argument is out of bounds
tanh
.masked
tanhf
llvm intrinsics cannot be defined!
__acos_finite
.short
__acosf_finite
  Aliasee: 
__asin_finite
and.shrunk
__asinf_finite
llvm.genx.GenISA.add.rtz
__atan2_finite
.weak
__atan2f_finite
scope points into the type hierarchy
__cosh_finite
bitfield
__coshf_finite
-optreport
__exp_finite
expected relocatable expression
__expf_finite
invalid pointer to member type
__exp2_finite
notlhs
__exp2f_finite
.long
__log_finite
invalid .org offset '
__logf_finite
invalid vector, expected one element of type subrange
__log10_finite
notrhs
__log10f_finite
__pow_finite
Padding cannot exceed 255 bytes
__powf_finite
compile units must be distinct
__sinh_finite
.demorgan
__sinhf_finite
FK_GPRel_8
non-zero initializer found in section '
invalid imported entity list
da-delinearize
igc-instcombine-guard-widening-window
Try to delinearize array references.
DW_AT_signature
 Empty
  Sections:[
    
 Any
invalid retained nodes list
 Point is <
How wide an instruction window to bypass looking for another guard
__svml_sinf8
 Distance is 
           
*X + 
cannot have column info without line info
*Y = 
blendv
 Line is 
first operand should be 'function_entry_count' or 'synthetic_function_entry_count'
enable-unsafe-globalsmodref-alias-results
GlobalDataResolutionPass
Globals Alias Analysis
     
globals-aa
exec
IV Users for loop 
__svml_sinf16
 with backedge-taken count 
strtab_begin
 (post-inc with loop 
function-local metadata used outside a function
 in  
thunk
Printing <null> User
win64cc
icp-remaining-percent-threshold
linetable_begin
The percentage threshold against remaining unpromoted indirect call count for the promotion
Instruction has bogus parent pointer!
icp-total-percent-threshold
nest
The percentage threshold against total count for the promotion
llvm.sin.f64
icp-max-prom
Allocation failed
Max number of promotions for a single indirect call callsite
Instruction returns a non-scalar type!
inline-threshold
nvptx-f32ftz
Control the amount of inlining to perform (default = 225)
-expandPlane
inlinehint-threshold
Threshold for inlining functions with inline hint
Referencing function in another module!
inline-cold-callsite-threshold
unmaskedload
Threshold for inlining cold callsites
__svml_cos4
inlinecold-threshold
inconsistent use of embedded source
Threshold for inlining functions with cold attribute
fpmath accuracy not a positive number!
hot-callsite-threshold
.splatinsert
Threshold for hot callsites 
-enablePreemption
locally-hot-callsite-threshold
 redeclared as different type
Threshold for locally hot callsites 
align metadata value must be an i64!
cold-callsite-rel-freq
.splat
Maxmimum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information.
hot-callsite-rel-freq
Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information.
Unfinished range!
inline-cost-full
castvec
Compute the full inline cost of a call site even when the cost exceeds the threshold.
local variable requires a valid scope
      NumConstantArgs: 
.bundle_unlock without matching lock
      NumConstantOffsetPtrArgs: 
      NumAllocaArgs: 
tmpcast
      NumConstantPtrCmps: 
__svml_cosf8
      NumConstantPtrDiffs: 
      NumInstructionsSimplified: 
Indirectbr operand must have pointer type!
      NumInstructions: 
      SROACostSavings: 
      SROACostSavingsLost: 
      LoadEliminationCost: 
Call parameter type does not match function signature!
      ContainsNoDuplicateCall: 
.lobit
      Cost: 
__svml_cosf4
      Threshold: 
DTPOFF
inline-cost
Function has metadata parameter but isn't an intrinsic
 has uninlinable pattern and cost is not fully computed
.mask
 is recursive and allocates too much stack space. Cost is not fully computed
name: "
Lazy Branch Probability Analysis
GOTPCREL
lazy-branch-prob
inlinable function call in a function with debug info must have a !dbg location
Lazy Block Frequency Analysis
lazy-block-freq
llvm.genx.GenISA.atomiccounterpredec
Lazy Value Information Analysis
GOTNTPOFF
lazy-value-info
info argument of llvm.coro.begin must refer to either a struct or an array
; LatticeVal for: '
.unshifted
' is: 
' is not a divisor of padding size '
' in BB: '
TLSLDM
available-load-scan-limit
element size of the element-wise atomic memory intrinsic must be a power of 2
Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value
.idx
force-vector-width
dp4a_su@
Sets the SIMD width. Zero is autoselect.
tlsdesc
force-vector-interleave
llvm.init_trampoline parameter #2 must resolve to a function.
Sets the vectorization interleave count. Zero is autoselect.
.sext
runtime-memory-check-threshold
TLVPPAGE
When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).
Cleans up symbols and relocation that are not longer needed due to various optimizations
memory-check-merge-threshold
---- InsEltMap ----
Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)
.add
max-dependences
DW_AT_friend
Maximum number of dependences collected by loop-access analysis (default = 100)
SECREL32
enable-mem-access-versioning
safepoint block should be well formed
Enable symbolic stride memory access versioning
to.ptr
store-to-load-forwarding-conflict-detection
__svml_pow2
Enable conflict detection in loop-access analysis
GOT_PREL
enable-mssa-loop-dependency
gc.statement: number of call arguments must be constant integer
Enable MemorySSA dependency for loop pass manager
.ptr
<unnamed loop>
llvm.genx.GenISA.bfi
verify-loop-info
sbrel
Verify loop info (time consuming)
gc.relocate: relocating a pointer shouldn't change its address space
 (loop: 
.conv
; Preheader:
__svml_pow4
; Loop:
Printing <null> block
masked_store: storee must match pointer type
; Exit blocks
sadd
Natural Loop Information
igc-domain-shader-lowering
loops
diff32
<deleted loop>
calls to experimental_deoptimize must be followed by a return of the value computed by experimental_deoptimize
<deleted>
sadd.result
Loop Pass Manager
__svml_pow8
Print Loop IR
higha
LCSSA Verifier
llvm.dbg.
lcssa-verification
sadd.overflow
Loop Pass Manager
llvm.cos.f64
memdep-block-scan-limit
got@h
The number of instructions to scan in a block in memory dependency analysis (default = 100)
gc.statepoint ID must be a constant integer
memdep-block-number-limit
umul
The number of blocks to scan during memory dependency analysis (default = 1000)
llvm.localrecover first argument must be function defined in this module
memdep
toc@l
Memory Dependence Analysis
  Root Value : 
memssa-check-limit
umul.value
The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)
linkage: 
verify-memoryssa
tprel@l
Verify MemorySSA in legacy printer pass.
gc.statepoint too few arguments according to length fields
 = MemoryDef(
.cast
 = MemoryPhi(
__svml_powf8
MemoryUse(
tprel@higha
Memory SSA
CleanupReturnInst must unwind to an EH block which is not a landingpad.
memoryssa
.val
force-summary-edges-cold
llvm.genx.GenISA.bfrev
Force all edges in the function summary to cold
tprel@highesta
None.
EH pad cannot be in entry block.
all-non-critical
storemerge
All non-critical edges.
__svml_powf16
All edges.
dtprel@high
llvm.compiler.used
EH pad jumps through a cycle of pads
Module Summary Analysis
.sub
module-summary-analysis
DW_AT_macros
ObjC-ARC-Based Alias Analysis
dtprel@highest
objc-arc-aa
Shifts only work with integral types!
enable-objc-arc-opts
.unpack
enable/disable all ARC Optimizations
llvm.pow.f64
objc_retainAutoreleasedReturnValue
got@tprel@h
objc_unsafeClaimAutoreleasedReturnValue
Translate ACL printf
objc_retainAutoreleaseReturnValue
.repack
llvm.arc.annotation.topdown.bbstart
__svml_powf4
llvm.arc.annotation.topdown.bbend
got@dtprel@h
llvm.arc.annotation.bottomup.bbstart
Store cannot have Acquire ordering
llvm.arc.annotation.bottomup.bbend
suba
opt-remark-emitter
gc.statepoint mismatch in number of call args
PHITransAddr: null
symbol-relocation-cleanup
PHITransAddr: 
       
  Input #
subc
 is 
x86_intrcc
.phi.trans.insert
got@tlsld@h
Phi Values Analysis
First cmpxchg operand must be a pointer.
phi-values
mulconv
Post-Dominator Tree Construction
__svml_exp2
postdomtree
PCREL
profile-summary-cutoff-hot
Invalid binary operation!
A count is hot if it exceeds the minimum count to reach this percentile of total counts.
igc-instcombine-max-num-phis
profile-summary-cutoff-cold
__svml_cosf16
A count is cold if it is below the minimum count to reach this percentile of total counts.
GDGOT
profile-sample-accurate
Type too small for ZExt
If the sample profile is accurate, we will mark all un-sampled callsite as cold. Otherwise, treat un-sampled callsites as if we have no profile.
Maximum number phis to handle in intptr/ptrint folding
profile-summary-huge-working-set-size-threshold
__svml_exp4
The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.
Desired percentile exceeds the maximum cutoff
FPToUI source and dest vector length mismatch
Profile summary info
profile-summary-info
DW_AT_export_symbols
<Function Return>
gotpcrel32@lo
 => 
UIToFP source and dest vector length mismatch
Region tree:
__svml_exp8
End region tree
rel64
verify-region-info
DestTy too big for FPTrunc
Verify region info (time consuming)
.shrunk
print-region-style
IEGOT
style of printing regions
Common symbol '
print no details
PtrToInt Vector width mismatch
extract
print regions in detail with block_iterator
GEP is not of right type for indices!
 Value:
print regions in detail with element_iterator
---- Multi-value Alias (value in both AliasMap & InsEltMap) ----
scalar-evolution-max-iterations
extract.t
Maximum number of iterations SCEV will symbolically execute a constant derived loop
, flags: (
verify-scev
MCCompactEncodedInstFragment
Verify ScalarEvolution's backedge taken counts (slow)
CatchPadInst needs to be in a function with a personality.
verify-scev-maps
narrow
Verify no dangling value in ScalarEvolution's ExprValueMap (slow)
Invalid predicate in FCmp instruction!
scev-addops-inline-threshold
not.
Threshold for inlining addition operands into a SCEV
llvm.genx.GenISA.broadcastMessagePhaseV
scalar-evolution-max-scev-compare-depth
MCSymbolIdFragment
Maximum depth of recursive SCEV complexity comparisons
cannot guarantee tail call due to mismatched return types
scalar-evolution-max-scev-operations-implication-depth
.inv
Maximum depth of recursive SCEV operations implication analysis
FK_GPRel_4
FK_TPRel_4
FK_SecRel_4
FK_Data_Add_4
FK_Data_Sub_4
scalar-evolution-max-value-compare-depth
<MCFragment 
Maximum depth of recursive value complexity comparisons
User-defined operators should not live outside of a pass!
scalar-evolution-max-arith-depth
.Elt
Maximum depth of recursive arithmetics
__svml_expf4
scalar-evolution-max-constant-evolving-depth
 (emit nops)
Maximum depth of recursive constant evolving
LandingPadInst needs to be in a function with a personality.
scalar-evolution-max-cast-depth
.lhs
Maximum depth of recursive SExt/ZExt/Trunc
got@tlsgd@h
scalar-evolution-max-add-rec-size
 Contents:[
Max coefficients in AddRec during evolving
'common' global may not be marked constant!
.rhs
(zext 
gather4POCptr@
(sext 
 Fixups:[
 AddrDelta:
Alias should have private, internal, linkonce, weak, linkonce_odr, weak_odr, or external linkage!
.extract
nuw><
nsw><
SymbolRelocationCleanup
nw><
  Root Value: 
       
 umax 
 smax 
__svml_expf16
<nuw>
 IsInsertionPoint:
<nsw>
invalid value for 'max' module flag (expected constant integer)
 /u 
instcombine-visit
sizeof(
invalid compile unit
alignof(
 RangeStart:
offsetof(
Dummy Pass for GenTTIImpl
***COULDNOTCOMPUTE***
Controls which instructions are visited
Classifying expressions for: 
unable to evaluate offset for variable '
  -->  
 U: 
sub_group_size
 S: 
igc-expensive-combines
Exits: 
<<Unknown>>
LoopDispositions: { 
Determining loop execution counts for: 
lodptr@
sampleBCptr@
Enable expensive instruction combines
igc-instcombine-maxarray-size
Trip Count Changed!
Old: 
<MCInst #
New: 
Expr:(
Delta: 
Equal predicate: 
 == 
__ustring
__gcc_except_tab
__compact_unwind
<nusw>
Maximum array size considered when doing a combine
igc-instcombine-lower-dbg-declare
.offs
<nssw>
scalar-evolution
Variant
__debug_names
Invariant
Computable
-addKernelID
Usage: -stop-noSrcDep-at <NUMBER>
USAGE: -schedulerwindow <window-size>
USAGE: missing number of gen binaries that will be patched.
Loop 
__apple_objc
<multiple exits> 
 [aliasee]
backedge-taken count is 
phitmp
Unpredictable backedge-taken count. 
__svml_log8
Loop 
__apple_types
max backedge-taken count is 
Display the version of this program
, actual taken count either this or zero.
trunc
Unpredictable max backedge-taken count. 
Can't open 
Predicated backedge-taken count is 
__debug_info
 Predicates:
: Unknown command line argument '
Unpredictable predicated backedge-taken count. 
Trip multiple is 
__svml_log4
Scalar Evolution Analysis
__debug_frame
ScalarEvolution-based Alias Analysis
 positional argument
scev-aa
SmallVector capacity overflow during allocation
scevgep
, hotness: 
.iv.next
__debug_gnu_pubt
multi-valued option specified with ValueDisallowed modifier!
Allocation failed
indvar.next
llvm.genx.GenISA.cmpSADs
smax
__debug_loc
__debug_macinfo
vector-library
No vector functions library
Accelerate
OPTIONS:
SVML
Intel SVML library
??2@YAPAXI@Z
??2@YAPEAX_KAEBUnothrow_t@std@@@Z
??_U@YAPEAX_K@Z
__debug_tu_index
__llvm_stackmaps
__LLVM_FAULTMAPS
.debug_abbrev
.debug_line
??2@YAPEAX_K@Z
??3@YAXPAX@Z
Symbol Relocation Analysis provides info needed to generate symbol and relocation entries
??3@YAXPAXI@Z
??_U@YAPAXI@Z
_ZdaPv
not_intrinsic
llvm.genx.GenISA.CatchAllDebugLine
llvm.genx.GenISA.DCL.DSPatchConstInputVec
??3@YAXPEAX@Z
??_U@YAPAXIABUnothrow_t@std@@@Z
??_V@YAXPAX@Z
??_V@YAXPAXABUnothrow_t@std@@@Z
Multiple errors:
Error
Inconvertible error value. An error has occurred that could not be converted to a known std::error_code. Please file a bug.
__llvm_faultmaps
??_V@YAXPAXI@Z
.debug_gnu_pubnames
??_V@YAXPEAX@Z
_IO_putc
_ZdaPvRKSt9nothrow_t
Graphviz
Running 'Graphviz' program... 
xdot|xdot.py
dot|fdp|neato|twopi|circo
-Tps
-Nfontname=Courier
Running '
' program... 
--spartan
dotty
Running 'dotty' program... 
Error: Couldn't find a usable graph viewer program:
??_V@YAXPEAXAEBUnothrow_t@std@@@Z
llvm.genx.GenISA.DCL.DSInputTessFactor
??_V@YAXPEAX_K@Z
Label String is not provided for the -uniqueLabels option.
_IO_getc
.debug_aranges
encoderStatistics.csv
_ZdaPvSt11align_val_t
.apple_names
_ZdaPvSt11align_val_tRKSt9nothrow_t
  Tried '
Remember to erase graph file: 
neato
twopi
circo
_ZdaPvj
llvm.genx.GenISA.DCL.GSinputVec
_ZdaPvm
.debug_ranges
_ZdlPv
_ZdlPvRKSt9nothrow_t
sampleKillPix@
_ZdlPvSt11align_val_t
llvm.genx.GenISA.DCL.GSsystemValue
_ZdlPvSt11align_val_tRKSt9nothrow_t
seed
_ZdlPvj
.debug_types.dwo
_ZdlPvm
igc-extractvalue-pair-fixup
_Znaj
llvm.genx.GenISA.DCL.HSControlPointID
_ZnajRKSt9nothrow_t
.debug_str.dwo
_ZnajSt11align_val_t
.debug_loc.dwo
_ZnajSt11align_val_tRKSt9nothrow_t
 [aliasee]  
_Znam
llvm.genx.GenISA.DCL.HSOutputCntrlPtInputVec
_ZnamRKSt9nothrow_t
.debug_rnglists.dwo
_ZnamSt11align_val_t
.debug_tu_index
_ZnamSt11align_val_tRKSt9nothrow_t
_Znwj
llvm.genx.GenISA.DCL.HSPatchConstInputVec
_ZnwjRKSt9nothrow_t
false
_ZnwjSt11align_val_t
.rdata
_ZnwjSt11align_val_tRKSt9nothrow_t
_Znwm
llvm.genx.GenISA.DCL.HSinputVec
_ZnwmRKSt9nothrow_t
.debug_str_offsets.dwo
_ZnwmSt11align_val_t
section_info_dwo
_ZnwmSt11align_val_tRKSt9nothrow_t
armv5t
__acosh_finite
llvm.genx.GenISA.DCL.ShaderInputVec
__acoshf_finite
__acoshl_finite
skel_loc
__acosl_finite
armv6
__asinl_finite
llvm.genx.GenISA.DCL.SystemValue
__atan2l_finite
invalid
__atanh_finite
.pdata
__atanhf_finite
v6t2
__atanhl_finite
llvm.genx.GenISA.DCL.input
__coshl_finite
llvm.genx.GenISA.DCL.inputVec
__cxa_guard_abort
section_str_off_dwo
__cxa_guard_acquire
 is out of range.
__cxa_guard_release
armv7-m
armv7e-m
v7em
armv8-a
__exp10_finite
llvm.genx.GenISA.EndPrimitive
__exp10f_finite
This file format doesn't support weak aliases.
__exp10l_finite
igc-symbols-relocation-analysis
__exp2l_finite
---- Phi-Var Isolations ----
__expl_finite
llvm.genx.GenISA.EnqueuedLocalSizeLocation
__isoc99_scanf
__isoc99_sscanf
__svml_logf4
<MCSection
__log10l_finite
8.3-A
__log2_finite
llvm.genx.GenISA.GetBufferPtr
__log2f_finite
__log2l_finite
access
__svml_logf16
mach-o section specifier requires a section whose length is between 1 and 16 characters
acosh
   --User+System--
acoshf
acoshl
armv8.1-a
8.1-A
v8.1a
armv8.2-a
8.2-A
v8.2a
armv8.3-a
v8.3a
armv8.4-a
8.4-A
armv8-r
8-M.Baseline
v8m.base
armv8-m.main
8-M.Mainline
v8m.main
iwmmxt2
armv7s
armv7k
v7-a
v5te
v6-m
v7-r
v7-m
v7e-m
v8-a
v8.1-a
v8.2-a
v8.3-a
v8.4-a
v8-r
v8-m.base
v8-m.main
acosl
mach-o section specifier cannot have a stub size specified because it does not have type 'symbol_stubs'
asinh
Var isolated : 
asinhf
llvm.genx.GenISA.GradientYfine
llvm.genx.GenISA.GsCutControlHeader
asinhl
_alloca
S_ZEROFILL
unknown
atanhf
S_CSTRING_LITERALS
atanhl
S_4BYTE_LITERALS
atanl
wasm64
amdhsa
atof
cbrtl
llvm.genx.GenISA.GridSizeLocation
llvm.genx.GenISA.GsStreamHeader
source_value@
atoi
S_8BYTE_LITERALS
atol
S_LITERAL_POINTERS
atoll
kfreebsd
bcmp
bzero
S_LAZY_SYMBOL_POINTERS
cabsf
haiku
cabsl
calloc
S_SYMBOL_STUBS
cbrt
ceill
chmod
chown
S_MOD_INIT_FUNC_POINTERS
clearerr
llvm.genx.GenISA.HSURBPatchHeaderRead
closedir
symbol_stubs
S_COALESCED
coshl
16byte_literals
ctermid
musl
musleabi
musleabihf
msvc
itanium
cygnus
coreclr
simulator
i486
macho
exp10
llvm.genx.GenISA.IEEE.Divide
exp10f
coldcc-rel-freq
exp10l
SymbolRelocation Analysis
expl
Leader : 
expm1
llvm.genx.GenISA.IEEE.Sqrt
expm1f
newgv
expm1l
thread_local_variables
fclose
thread_local_regular
fdopen
llvm.genx.GenISA.InitDiscardMask
feof
thread_local_variable_pointers
ferror
thread_local_init_function_pointers
fflush
AggregateArgumentsAnalysis
ffsll
llvm.genx.GenISA.InnerScalarTessFactors
fgetc
S_THREAD_LOCAL_REGULAR
fgetc_unlocked
fgetpos
21ocl_image1d_buffer
fgets
llvm.genx.GenISA.Interpolant
fgets_unlocked
GenXFunctionGroupAnalysis
fileno
no_dead_strip
flockfile
floorl
llvm.genx.GenISA.Interpolate
live_support
flsl
self_modifying_code
flsll
print
fmodl
llvm.genx.GenISA.Interpolate2
fopen
free_it
fopen64
S_ATTR_SOME_INSTRUCTIONS
fprintf
xdigit
fread
llvm.genx.GenISA.IsHelperInvocation
fread_unlocked
S_ATTR_NO_DEAD_STRIP
free
this directive must appear between .cfi_startproc and .cfi_endproc directives
frexp
frexpf
llvm.genx.GenISA.LocalIdLocation
frexpl
Interprocedural constant propagation
fscanf
invalid symbol redefinition
fseek
    
fseeko
llvm.genx.GenISA.LocalSizeLocation
fseeko64
.seh_* directives are not supported on this target
fsetpos
Starting a function before ending the previous one!
fstat
fstat64
llvm.genx.GenISA.MediaBlockRead
fstatvfs
disable-inlined-alloca-merging
fstatvfs64
Don't know what kind of handler this is!
ftell
ftello
llvm.genx.GenISA.MediaBlockRectangleRead
ftello64
starting new .cfi frame before finishing the previous one
ftrylockfile
stack allocation size must be non-zero
funlockfile
fwrite
llvm.genx.GenISA.MediaBlockWrite
fwrite_unlocked
verbose
getc
EmitRawText called on an MCStreamer that doesn't support it,  something must not be fully mc'ized
getc_unlocked
ampersand
getchar
llvm.genx.GenISA.OUTPUT
getchar_unlocked
getenv
getitimer
hyphen-minus
getlogin_r
llvm.genx.GenISA.OUTPUTGS
getpwnam
gets
, Addend=
gettimeofday
four
htonl
llvm.genx.GenISA.OUTPUTGS2
htons
Unfinished frame!
lchown
.file
ldexp
less-than-sign
ldexpf
llvm.genx.GenISA.OWordPtr
ldexpl
kernel_arg_addr_space
log1p
coalesce moves coming from phi nodes
log1pf
llvm.genx.GenISA.OuterScalarTessFactors
log1pl
 with cost=always
log2f
 section "
log2l
lstat
memalign
mktime
llvm.genx.GenISA.PHASE.OUTPUT
modf
modff
fwrite$UNIX2003
asm 
modfl
REG_EMPTY
costmodel-reduxcost
DW_AT_BORLAND_Delphi_constructor
DW_CC_pass_by_value
DW_CC_GNU_renesas_sh
DW_CC_GNU_borland_fastcall_i386
DW_CC_BORLAND_stdcall
DW_CC_BORLAND_pascal
DW_CC_BORLAND_msfastcall
DW_CC_BORLAND_thiscall
DW_CC_BORLAND_fastcall
DW_CC_LLVM_vectorcall
DW_CC_LLVM_Win64
DW_CC_LLVM_X86_64SysV
DW_CC_LLVM_AAPCS
DW_CC_LLVM_AAPCS_VFP
DW_CC_LLVM_SpirFunction
DW_CC_LLVM_OpenCLKernel
DW_CC_LLVM_Swift
DW_CC_LLVM_PreserveMost
DW_CC_LLVM_PreserveAll
DW_CC_LLVM_X86RegCall
DW_CC_GDB_IBM_OpenCL
DW_MACINFO_define
DW_MACINFO_undef
DW_MACINFO_start_file
DW_MACINFO_end_file
DW_MACINFO_vendor_ext
Recognize reduction patterns.
llvm.genx.GenISA.createMessagePhasesNoInitV
Target Transform Information
Resource indirection pass
sampler_t
enable-tbaa
/// Inlined ASM
Cycle found in TBAA metadata.
llvm.genx.GenISA.createMessagePhasesV
llvm.genx.GenISA.discard
llvm.genx.GenISA.dp4a.ss
llvm.genx.GenISA.dp4a.su
llvm.genx.GenISA.dp4a.us
llvm.genx.GenISA.dp4a.uu
llvm.genx.GenISA.dwordatomicstructured
llvm.genx.GenISA.eu.id
llvm.genx.GenISA.eu.thread.id
llvm.genx.GenISA.eu.thread.pause
llvm.genx.GenISA.evaluateSampler
llvm.genx.GenISA.extractMVAndSAD
llvm.genx.GenISA.f32tof16.rtz
llvm.genx.GenISA.fcmpxchgatomicraw
llvm.genx.GenISA.fcmpxchgatomicrawA64
llvm.genx.GenISA.fcmpxchgatomicstructured
llvm.genx.GenISA.firstbitHi
llvm.genx.GenISA.firstbitLo
llvm.genx.GenISA.firstbitShi
llvm.genx.GenISA.floatatomicraw
llvm.genx.GenISA.floatatomicrawA64
llvm.genx.GenISA.floatatomicstructured
llvm.genx.GenISA.flushsampler
llvm.genx.GenISA.fma.rtz
llvm.genx.GenISA.fsat
llvm.genx.GenISA.ftof.rtn
llvm.genx.GenISA.ftof.rtp
llvm.genx.GenISA.ftof.rtz
llvm.genx.GenISA.ftoi.rte
llvm.genx.GenISA.ftoi.rtn
llvm.genx.GenISA.ftoi.rtp
llvm.genx.GenISA.ftoui.rte
llvm.genx.GenISA.ftoui.rtp
llvm.genx.GenISA.gather4Cptr
llvm.genx.GenISA.gather4POCptr
llvm.genx.GenISA.gather4POptr
llvm.genx.GenISA.gather4ptr
llvm.genx.GenISA.getEnqueuedLocalSize
llvm.genx.GenISA.getGlobalSize
llvm.genx.GenISA.getGridOrigin
llvm.genx.GenISA.getGridSize
llvm.genx.GenISA.getGroupId
llvm.genx.GenISA.getLocalId
llvm.genx.GenISA.getLocalSize
llvm.genx.GenISA.getMessagePhase
llvm.genx.GenISA.getMessagePhaseV
llvm.genx.GenISA.getMessagePhaseX
llvm.genx.GenISA.getMessagePhaseXV
llvm.genx.GenISA.getSR0
llvm.genx.GenISA.getSimdGroupSize
llvm.genx.GenISA.globalSync
llvm.genx.GenISA.hw.thread.id
llvm.genx.GenISA.ibfe
llvm.genx.GenISA.icmpxchgatomicraw
llvm.genx.GenISA.icmpxchgatomicrawA64
llvm.genx.GenISA.icmpxchgatomictyped
llvm.genx.GenISA.imulH
llvm.genx.GenISA.intatomicraw
llvm.genx.GenISA.intatomicrawA64
llvm.genx.GenISA.intatomictyped
llvm.genx.GenISA.is.uniform
llvm.genx.GenISA.itof.rtn
llvm.genx.GenISA.itof.rtp
llvm.genx.GenISA.ldmcsptr
llvm.genx.GenISA.ldmsptr
llvm.genx.GenISA.ldmsptr16bit
llvm.genx.GenISA.ldptr
llvm.genx.GenISA.ldraw.indexed
llvm.genx.GenISA.ldrawvector.indexed
llvm.genx.GenISA.ldstructured
llvm.genx.GenISA.lodptr
llvm.genx.GenISA.memoryfence
llvm.genx.GenISA.mov.identity
llvm.genx.GenISA.movcr
llvm.genx.GenISA.movflag
llvm.genx.GenISA.mul.pair
llvm.genx.GenISA.mul.rtz
llvm.genx.GenISA.pair.to.ptr
llvm.genx.GenISA.patchInstanceId
llvm.genx.GenISA.ptr.to.pair
llvm.genx.GenISA.readsurfaceinfoptr
llvm.genx.GenISA.resinfoptr
llvm.genx.GenISA.rsq
llvm.genx.GenISA.sampleBCptr
llvm.genx.GenISA.sampleBptr
llvm.genx.GenISA.sampleCptr
llvm.genx.GenISA.sampleDCptr
llvm.genx.GenISA.sampleDptr
llvm.genx.GenISA.sampleKillPix
llvm.genx.GenISA.sampleLCptr
llvm.genx.GenISA.sampleLptr
llvm.genx.GenISA.sampleinfoptr
llvm.genx.GenISA.sampleptr
llvm.genx.GenISA.setMessagePhase
llvm.genx.GenISA.setMessagePhaseX
llvm.genx.GenISA.setMessagePhaseXV
llvm.genx.GenISA.setMessagePhaseX.legacy
llvm.genx.GenISA.setMessagePhase.legacy
llvm.genx.GenISA.simdBlockRead
llvm.genx.GenISA.simdBlockReadBindless
llvm.genx.GenISA.simdBlockWrite
llvm.genx.GenISA.simdBlockWriteBindless
llvm.genx.GenISA.simdGetMessagePhase
llvm.genx.GenISA.simdGetMessagePhaseV
llvm.genx.GenISA.simdLaneId
llvm.genx.GenISA.simdMediaBlockRead
llvm.genx.GenISA.simdMediaBlockWrite
llvm.genx.GenISA.simdMediaRegionCopy
llvm.genx.GenISA.simdSetMessagePhase
llvm.genx.GenISA.simdSetMessagePhaseV
llvm.genx.GenISA.simdShuffleDown
llvm.genx.GenISA.simdSize
llvm.genx.GenISA.slice.id
llvm.genx.GenISA.source.value
llvm.genx.GenISA.storeraw.indexed
llvm.genx.GenISA.storerawvector.indexed
llvm.genx.GenISA.storestructured1
llvm.genx.GenISA.storestructured2
llvm.genx.GenISA.storestructured3
llvm.genx.GenISA.storestructured4
llvm.genx.GenISA.sub.pair
llvm.genx.GenISA.subslice.id
llvm.genx.GenISA.threadgroupbarrier
llvm.genx.GenISA.threadgroupbarrier.signal
llvm.genx.GenISA.threadgroupbarrier.wait
llvm.genx.GenISA.typedread
llvm.genx.GenISA.typedwrite
llvm.genx.GenISA.uaddc
llvm.genx.GenISA.uavSerializeAll
llvm.genx.GenISA.uavSerializeOnResID
llvm.genx.GenISA.ubfe
llvm.genx.GenISA.uitof.rtn
llvm.genx.GenISA.uitof.rtp
llvm.genx.GenISA.uitof.rtz
llvm.genx.GenISA.umulH
llvm.genx.GenISA.usubb
llvm.genx.GenISA.vaBoolCentroid
llvm.genx.GenISA.vaBoolSum
llvm.genx.GenISA.vaCentroid
llvm.genx.GenISA.vaConvolve
llvm.genx.GenISA.vaConvolveGRF.16x1
llvm.genx.GenISA.vaConvolveGRF.16x4
llvm.genx.GenISA.vaDilate
llvm.genx.GenISA.vaErode
llvm.genx.GenISA.vaMinMax
llvm.genx.GenISA.vaMinMaxFilter
llvm.genx.GenISA.vmeSendFBR
llvm.genx.GenISA.vmeSendFBR2
llvm.genx.GenISA.vmeSendIME
llvm.genx.GenISA.vmeSendIME2
llvm.genx.GenISA.vmeSendSIC
llvm.genx.GenISA.vmeSendSIC2
llvm.genx.GenISA.wavebarrier
CatchAllDebugLine@
DCL_DSCntrlPtInputVec@
DCL_DSInputTessFactor@
DCL_GSinputVec@
DCL_GSsystemValue@
DCL_HSControlPointID@
DCL_HSOutputCntrlPtInputVec@
DCL_HSPatchConstInputVec@
DCL_HSinputVec@
DCL_ShaderInputVec@
DCL_SystemValue@
DCL_input@
DCL_inputVec@
EndPrimitive@
EnqueuedLocalSizeLocation@
GetBufferPtr@
GetPixelMask@
GlobalDataAccess@
GlobalSizeLocation@
GradientX@
GradientXfine@
GradientY@
GradientYfine@
GridOriginLocation@
GridSizeLocation@
GroupIdLocation@
GsCutControlHeader@
GsStreamHeader@
HSURBPatchHeaderRead@
IEEE_Divide@
IEEE_Sqrt@
InitDiscardMask@
InnerScalarTessFactors@
Interpolant@
Interpolate2@
IsHelperInvocation@
LocalIdLocation@
LocalSizeLocation@
MediaBlockRead@
MediaBlockRectangleRead@
MediaBlockWrite@
OUTPUT@
OUTPUTGS@
OUTPUTGS2@
OWordPtr@
OuterScalarTessFactors@
OutputTessControlPoint@
OutputTessFactors@
PHASE_INPUT@
PHASE_OUTPUT@
PatchConstantOutput@
PixelPositionX@
PixelPositionY@
PullCentroidBarys@
PullSampleIndexBarys@
PullSnappedBarys@
QuadPrefix@
ROUNDNE@
RTDualBlendSource@
RTWrite@
RenderTargetRead@
RenderTargetReadSampleFreq@
RuntimeValue@
SampleOffsetY@
SetStream@
StackAlloca@
URBRead@
URBReadOutput@
URBWrite@
UpdateDiscardMask@
VirtualBindingTableBaseLocation@
WaveAll@
WaveBallot@
WaveInverseBallot@
WavePrefix@
WaveShuffleIndex@
WorkGroupAny@
add_pair@
add_rtz@
atomiccounterinc@
atomiccounterpredec@
bfi@
bfrev@
broadcastMessagePhase@
dp4a_us@
dp4a_uu@
dwordatomicstructured@
eu_id@
eu_thread_id@
eu_thread_pause@
evaluateSampler@
extractMVAndSAD@
f32tof16_rtz@
fcmpxchgatomicraw@
fcmpxchgatomicrawA64@
fcmpxchgatomicstructured@
firstbitHi@
firstbitLo@
firstbitShi@
floatatomicraw@
floatatomicrawA64@
floatatomicstructured@
flushsampler@
fma_rtz@
fsat@
ftof_rtn@
ftof_rtp@
ftof_rtz@
ftoi_rte@
ftoi_rtn@
ftoi_rtp@
ftoui_rte@
ftoui_rtn@
ftoui_rtp@
gather4Cptr@
gather4POptr@
gather4ptr@
getEnqueuedLocalSize@
getGlobalSize@
getGridOrigin@
getGridSize@
getGroupId@
getLocalId@
getLocalSize@
getMessagePhase@
getMessagePhaseV@
getMessagePhaseX@
getMessagePhaseXV@
getSR0@
getSimdGroupSize@
globalSync@
hw_thread_id@
ibfe@
icmpxchgatomicraw@
icmpxchgatomicrawA64@
icmpxchgatomictyped@
imulH@
intatomicraw@
intatomicrawA64@
intatomictyped@
is_uniform@
itof_rtn@
itof_rtp@
itof_rtz@
ldmcsptr@
ldmsptr@
ldptr@
ldraw_indexed@
movflag@
mul_pair@
mul_rtz@
pair_to_ptr@
patchInstanceId@
ptr_to_pair@
readsurfaceinfoptr@
setMessagePhase_legacy@
simdBlockRead@
simdBlockReadBindless@
simdBlockWrite@
simdBlockWriteBindless@
simdGetMessagePhase@
simdGetMessagePhaseV@
simdLaneId@
uavSerializeAll@
ubfe@
uitof_rtn@
uitof_rtp@
uitof_rtz@
vaBoolCentroid@
vaBoolSum@
vaCentroid@
vaConvolveGRF_16x1@
vaDilate@
vaMinMax@
vaMinMaxFilter@
vmeSendFBR@
vmeSendFBR2@
vmeSendIME@
vmeSendIME2@
vmeSendSIC@
vmeSendSIC2@
wavebarrier@
Type-Based Alias Analysis
, singleImplName: "
tbaa
, byArg: (kind: 
PromoteResourceToDirectAS
subb
igc-promote-stateless-to-bindless
block_simd_size
copysign
iga api: unsupported platform
copysignl
decoding error: %s
fabsf
compare value and pointer type do not match
llvm.amdgcn.image.sample.c.cd.cl.o.1darray
llvm.hexagon.C4.fastcorner9.not
llvm.hexagon.C4.nbitsclr
llvm.hexagon.C4.nbitsclri
llvm.hexagon.C4.nbitsset
llvm.hexagon.C4.or.and
llvm.hexagon.C4.or.andn
llvm.hexagon.C4.or.or
llvm.hexagon.C4.or.orn
llvm.hexagon.F2.conv.d2df
llvm.hexagon.F2.conv.d2sf
llvm.hexagon.F2.conv.df2d
llvm.hexagon.F2.conv.df2d.chop
llvm.hexagon.F2.conv.df2sf
llvm.hexagon.F2.conv.df2ud
llvm.hexagon.F2.conv.df2ud.chop
llvm.hexagon.F2.conv.df2uw
llvm.hexagon.F2.conv.df2uw.chop
llvm.hexagon.F2.conv.df2w
llvm.hexagon.F2.conv.df2w.chop
llvm.hexagon.F2.conv.sf2d
llvm.hexagon.F2.conv.sf2d.chop
llvm.hexagon.F2.conv.sf2df
llvm.hexagon.F2.conv.sf2ud
llvm.hexagon.F2.conv.sf2ud.chop
llvm.hexagon.F2.conv.sf2uw
llvm.hexagon.F2.conv.sf2uw.chop
llvm.hexagon.F2.conv.sf2w
llvm.hexagon.F2.conv.sf2w.chop
llvm.hexagon.F2.conv.ud2df
llvm.hexagon.F2.conv.ud2sf
llvm.hexagon.F2.conv.uw2df
llvm.hexagon.F2.conv.uw2sf
llvm.hexagon.F2.conv.w2df
llvm.hexagon.F2.conv.w2sf
llvm.hexagon.F2.dfclass
llvm.hexagon.F2.dfcmpeq
llvm.hexagon.F2.dfcmpge
llvm.hexagon.F2.dfcmpgt
llvm.hexagon.F2.dfcmpuo
llvm.hexagon.F2.dfimm.n
llvm.hexagon.F2.dfimm.p
llvm.hexagon.F2.sfadd
llvm.hexagon.F2.sfclass
llvm.hexagon.F2.sfcmpeq
llvm.hexagon.F2.sfcmpge
llvm.hexagon.F2.sfcmpgt
llvm.hexagon.F2.sfcmpuo
llvm.hexagon.F2.sffixupd
llvm.hexagon.F2.sffixupn
llvm.hexagon.F2.sffixupr
llvm.hexagon.F2.sffma
llvm.hexagon.F2.sffma.lib
llvm.hexagon.F2.sffma.sc
llvm.hexagon.F2.sffms
llvm.hexagon.F2.sffms.lib
llvm.hexagon.F2.sfimm.n
llvm.hexagon.F2.sfimm.p
llvm.hexagon.F2.sfmax
llvm.hexagon.F2.sfmin
llvm.hexagon.F2.sfmpy
llvm.hexagon.F2.sfsub
llvm.hexagon.L2.loadrb.pbr
llvm.hexagon.L2.loadrb.pci
llvm.hexagon.L2.loadrb.pcr
llvm.hexagon.L2.loadrd.pbr
llvm.hexagon.L2.loadrd.pci
llvm.hexagon.L2.loadrd.pcr
llvm.hexagon.L2.loadrh.pbr
llvm.hexagon.L2.loadrh.pci
llvm.hexagon.L2.loadrh.pcr
llvm.hexagon.L2.loadri.pbr
llvm.hexagon.L2.loadri.pci
llvm.hexagon.L2.loadri.pcr
llvm.hexagon.L2.loadrub.pbr
llvm.hexagon.L2.loadrub.pci
llvm.hexagon.L2.loadrub.pcr
llvm.hexagon.L2.loadruh.pbr
llvm.hexagon.L2.loadruh.pci
llvm.hexagon.L2.loadruh.pcr
llvm.hexagon.L2.loadw.locked
llvm.hexagon.L4.loadd.locked
llvm.hexagon.M2.acci
llvm.hexagon.M2.accii
llvm.hexagon.M2.cmaci.s0
llvm.hexagon.M2.cmacr.s0
llvm.hexagon.M2.cmacs.s0
llvm.hexagon.M2.cmacs.s1
llvm.hexagon.M2.cmacsc.s0
llvm.hexagon.M2.cmacsc.s1
llvm.hexagon.M2.cmpyi.s0
llvm.hexagon.M2.cmpyr.s0
llvm.hexagon.M2.cmpyrs.s0
llvm.hexagon.M2.cmpyrs.s1
llvm.hexagon.M2.cmpyrsc.s0
llvm.hexagon.M2.cmpyrsc.s1
llvm.hexagon.M2.cmpys.s0
llvm.hexagon.M2.cmpys.s1
llvm.hexagon.M2.cmpysc.s0
llvm.hexagon.M2.cmpysc.s1
llvm.hexagon.M2.cnacs.s0
llvm.hexagon.M2.cnacs.s1
llvm.hexagon.M2.cnacsc.s0
llvm.hexagon.M2.cnacsc.s1
llvm.hexagon.M2.dpmpyss.acc.s0
llvm.hexagon.M2.dpmpyss.nac.s0
llvm.hexagon.M2.dpmpyss.rnd.s0
llvm.hexagon.M2.dpmpyss.s0
llvm.hexagon.M2.dpmpyuu.acc.s0
llvm.hexagon.M2.dpmpyuu.nac.s0
llvm.hexagon.M2.dpmpyuu.s0
llvm.hexagon.M2.hmmpyh.rs1
llvm.hexagon.M2.hmmpyh.s1
llvm.hexagon.M2.hmmpyl.rs1
llvm.hexagon.M2.hmmpyl.s1
llvm.hexagon.M2.maci
llvm.hexagon.M2.macsin
llvm.hexagon.M2.macsip
llvm.hexagon.M2.mmachs.rs0
llvm.hexagon.M2.mmachs.rs1
llvm.hexagon.M2.mmachs.s0
llvm.hexagon.M2.mmachs.s1
llvm.hexagon.M2.mmacls.rs0
llvm.hexagon.M2.mmacls.rs1
llvm.hexagon.M2.mmacls.s0
llvm.hexagon.M2.mmacls.s1
llvm.hexagon.M2.mmacuhs.rs0
llvm.hexagon.M2.mmacuhs.rs1
llvm.hexagon.M2.mmacuhs.s0
llvm.hexagon.M2.mmacuhs.s1
llvm.hexagon.M2.mmaculs.rs0
llvm.hexagon.M2.mmaculs.rs1
llvm.hexagon.M2.mmaculs.s0
llvm.hexagon.M2.mmaculs.s1
llvm.hexagon.M2.mmpyh.rs0
llvm.hexagon.M2.mmpyh.rs1
llvm.hexagon.M2.mmpyh.s0
llvm.hexagon.M2.mmpyh.s1
llvm.hexagon.M2.mmpyl.rs0
llvm.hexagon.M2.mmpyl.rs1
llvm.hexagon.M2.mmpyl.s0
llvm.hexagon.M2.mmpyl.s1
llvm.hexagon.M2.mmpyuh.rs0
llvm.hexagon.M2.mmpyuh.rs1
llvm.hexagon.M2.mmpyuh.s0
llvm.hexagon.M2.mmpyuh.s1
llvm.hexagon.M2.mmpyul.rs0
llvm.hexagon.M2.mmpyul.rs1
llvm.hexagon.M2.mmpyul.s0
llvm.hexagon.M2.mmpyul.s1
llvm.hexagon.M2.mpy.acc.hh.s0
llvm.hexagon.M2.mpy.acc.hh.s1
llvm.hexagon.M2.mpy.acc.hl.s0
llvm.hexagon.M2.mpy.acc.hl.s1
llvm.hexagon.M2.mpy.acc.lh.s0
llvm.hexagon.M2.mpy.acc.lh.s1
llvm.hexagon.M2.mpy.acc.ll.s0
llvm.hexagon.M2.mpy.acc.ll.s1
llvm.hexagon.M2.mpy.acc.sat.hh.s0
llvm.hexagon.M2.mpy.acc.sat.hh.s1
llvm.hexagon.M2.mpy.acc.sat.hl.s0
llvm.hexagon.M2.mpy.acc.sat.hl.s1
llvm.hexagon.M2.mpy.acc.sat.lh.s0
llvm.hexagon.M2.mpy.acc.sat.lh.s1
llvm.hexagon.M2.mpy.acc.sat.ll.s0
llvm.hexagon.M2.mpy.acc.sat.ll.s1
llvm.hexagon.M2.mpy.hh.s0
llvm.hexagon.M2.mpy.hh.s1
llvm.hexagon.M2.mpy.hl.s0
llvm.hexagon.M2.mpy.hl.s1
llvm.hexagon.M2.mpy.lh.s0
llvm.hexagon.M2.mpy.lh.s1
llvm.hexagon.M2.mpy.ll.s0
llvm.hexagon.M2.mpy.ll.s1
llvm.hexagon.M2.mpy.nac.hh.s0
llvm.hexagon.M2.mpy.nac.hh.s1
llvm.hexagon.M2.mpy.nac.hl.s0
llvm.hexagon.M2.mpy.nac.hl.s1
llvm.hexagon.M2.mpy.nac.lh.s0
llvm.hexagon.M2.mpy.nac.lh.s1
llvm.hexagon.M2.mpy.nac.ll.s0
llvm.hexagon.M2.mpy.nac.ll.s1
llvm.hexagon.M2.mpy.nac.sat.hh.s0
llvm.hexagon.M2.mpy.nac.sat.hh.s1
llvm.hexagon.M2.mpy.nac.sat.hl.s0
llvm.hexagon.M2.mpy.nac.sat.hl.s1
llvm.hexagon.M2.mpy.nac.sat.lh.s0
llvm.hexagon.M2.mpy.nac.sat.lh.s1
llvm.hexagon.M2.mpy.nac.sat.ll.s0
llvm.hexagon.M2.mpy.nac.sat.ll.s1
llvm.hexagon.M2.mpy.rnd.hh.s0
llvm.hexagon.M2.mpy.rnd.hh.s1
llvm.hexagon.M2.mpy.rnd.hl.s0
llvm.hexagon.M2.mpy.rnd.hl.s1
llvm.hexagon.M2.mpy.rnd.lh.s0
llvm.hexagon.M2.mpy.rnd.lh.s1
llvm.hexagon.M2.mpy.rnd.ll.s0
llvm.hexagon.M2.mpy.rnd.ll.s1
llvm.hexagon.M2.mpy.sat.hh.s0
llvm.hexagon.M2.mpy.sat.hh.s1
llvm.hexagon.M2.mpy.sat.hl.s0
llvm.hexagon.M2.mpy.sat.hl.s1
llvm.hexagon.M2.mpy.sat.lh.s0
llvm.hexagon.M2.mpy.sat.lh.s1
llvm.hexagon.M2.mpy.sat.ll.s0
llvm.hexagon.M2.mpy.sat.ll.s1
llvm.hexagon.M2.mpy.sat.rnd.hh.s0
llvm.hexagon.M2.mpy.sat.rnd.hh.s1
llvm.hexagon.M2.mpy.sat.rnd.hl.s0
llvm.hexagon.M2.mpy.sat.rnd.hl.s1
llvm.hexagon.M2.mpy.sat.rnd.lh.s0
llvm.hexagon.M2.mpy.sat.rnd.lh.s1
llvm.hexagon.M2.mpy.sat.rnd.ll.s0
llvm.hexagon.M2.mpy.sat.rnd.ll.s1
llvm.hexagon.M2.mpy.up
llvm.hexagon.M2.mpy.up.s1
llvm.hexagon.M2.mpy.up.s1.sat
llvm.hexagon.M2.mpyd.acc.hh.s0
llvm.hexagon.M2.mpyd.acc.hh.s1
llvm.hexagon.M2.mpyd.acc.hl.s0
llvm.hexagon.M2.mpyd.acc.hl.s1
llvm.hexagon.M2.mpyd.acc.lh.s0
llvm.hexagon.M2.mpyd.acc.lh.s1
llvm.hexagon.M2.mpyd.acc.ll.s0
llvm.hexagon.M2.mpyd.acc.ll.s1
llvm.hexagon.M2.mpyd.hh.s0
llvm.hexagon.M2.mpyd.hh.s1
llvm.hexagon.M2.mpyd.hl.s0
llvm.hexagon.M2.mpyd.hl.s1
llvm.hexagon.M2.mpyd.lh.s0
llvm.hexagon.M2.mpyd.lh.s1
llvm.hexagon.M2.mpyd.ll.s0
llvm.hexagon.M2.mpyd.ll.s1
llvm.hexagon.M2.mpyd.nac.hh.s0
llvm.hexagon.M2.mpyd.nac.hh.s1
llvm.hexagon.M2.mpyd.nac.hl.s0
llvm.hexagon.M2.mpyd.nac.hl.s1
llvm.hexagon.M2.mpyd.nac.lh.s0
llvm.hexagon.M2.mpyd.nac.lh.s1
llvm.hexagon.M2.mpyd.nac.ll.s0
llvm.hexagon.M2.mpyd.nac.ll.s1
llvm.hexagon.M2.mpyd.rnd.hh.s0
llvm.hexagon.M2.mpyd.rnd.hh.s1
llvm.hexagon.M2.mpyd.rnd.hl.s0
llvm.hexagon.M2.mpyd.rnd.hl.s1
llvm.hexagon.M2.mpyd.rnd.lh.s0
llvm.hexagon.M2.mpyd.rnd.lh.s1
llvm.hexagon.M2.mpyd.rnd.ll.s0
llvm.hexagon.M2.mpyd.rnd.ll.s1
llvm.hexagon.M2.mpyi
llvm.hexagon.M2.mpysmi
llvm.hexagon.M2.mpysu.up
llvm.hexagon.M2.mpyu.acc.hh.s0
llvm.hexagon.M2.mpyu.acc.hh.s1
llvm.hexagon.M2.mpyu.acc.hl.s0
llvm.hexagon.M2.mpyu.acc.hl.s1
llvm.hexagon.M2.mpyu.acc.lh.s0
llvm.hexagon.M2.mpyu.acc.lh.s1
llvm.hexagon.M2.mpyu.acc.ll.s0
llvm.hexagon.M2.mpyu.acc.ll.s1
llvm.hexagon.M2.mpyu.hh.s0
llvm.hexagon.M2.mpyu.hh.s1
llvm.hexagon.M2.mpyu.hl.s0
llvm.hexagon.M2.mpyu.hl.s1
llvm.hexagon.M2.mpyu.lh.s0
llvm.hexagon.M2.mpyu.lh.s1
llvm.hexagon.M2.mpyu.ll.s0
llvm.hexagon.M2.mpyu.ll.s1
llvm.hexagon.M2.mpyu.nac.hh.s0
llvm.hexagon.M2.mpyu.nac.hh.s1
llvm.hexagon.M2.mpyu.nac.hl.s0
llvm.hexagon.M2.mpyu.nac.hl.s1
llvm.hexagon.M2.mpyu.nac.lh.s0
llvm.hexagon.M2.mpyu.nac.lh.s1
llvm.hexagon.M2.mpyu.nac.ll.s0
llvm.hexagon.M2.mpyu.nac.ll.s1
llvm.hexagon.M2.mpyu.up
llvm.hexagon.M2.mpyud.acc.hh.s0
llvm.hexagon.M2.mpyud.acc.hh.s1
llvm.hexagon.M2.mpyud.acc.hl.s0
llvm.hexagon.M2.mpyud.acc.hl.s1
llvm.hexagon.M2.mpyud.acc.lh.s0
llvm.hexagon.M2.mpyud.acc.lh.s1
llvm.hexagon.M2.mpyud.acc.ll.s0
llvm.hexagon.M2.mpyud.acc.ll.s1
llvm.hexagon.M2.mpyud.hh.s0
llvm.hexagon.M2.mpyud.hh.s1
llvm.hexagon.M2.mpyud.hl.s0
llvm.hexagon.M2.mpyud.hl.s1
llvm.hexagon.M2.mpyud.lh.s0
llvm.hexagon.M2.mpyud.lh.s1
llvm.hexagon.M2.mpyud.ll.s0
llvm.hexagon.M2.mpyud.ll.s1
llvm.hexagon.M2.mpyud.nac.hh.s0
llvm.hexagon.M2.mpyud.nac.hh.s1
llvm.hexagon.M2.mpyud.nac.hl.s0
llvm.hexagon.M2.mpyud.nac.hl.s1
llvm.hexagon.M2.mpyud.nac.lh.s0
llvm.hexagon.M2.mpyud.nac.lh.s1
llvm.hexagon.M2.mpyud.nac.ll.s0
llvm.hexagon.M2.mpyud.nac.ll.s1
llvm.hexagon.M2.mpyui
llvm.hexagon.M2.nacci
llvm.hexagon.M2.naccii
llvm.hexagon.M2.subacc
llvm.hexagon.M2.vabsdiffh
llvm.hexagon.M2.vabsdiffw
llvm.hexagon.M2.vcmac.s0.sat.i
llvm.hexagon.M2.vcmac.s0.sat.r
llvm.hexagon.M2.vcmpy.s0.sat.i
llvm.hexagon.M2.vcmpy.s0.sat.r
llvm.hexagon.M2.vcmpy.s1.sat.i
llvm.hexagon.M2.vcmpy.s1.sat.r
llvm.hexagon.M2.vdmacs.s0
llvm.hexagon.M2.vdmacs.s1
llvm.hexagon.M2.vdmpyrs.s0
llvm.hexagon.M2.vdmpyrs.s1
llvm.hexagon.M2.vdmpys.s0
llvm.hexagon.M2.vdmpys.s1
llvm.hexagon.M2.vmac2
llvm.hexagon.M2.vmac2es
llvm.hexagon.M2.vmac2es.s0
llvm.hexagon.M2.vmac2es.s1
llvm.hexagon.M2.vmac2s.s0
llvm.hexagon.M2.vmac2s.s1
llvm.hexagon.M2.vmac2su.s0
llvm.hexagon.M2.vmac2su.s1
llvm.hexagon.M2.vmpy2es.s0
llvm.hexagon.M2.vmpy2es.s1
llvm.hexagon.M2.vmpy2s.s0
llvm.hexagon.M2.vmpy2s.s0pack
llvm.hexagon.M2.vmpy2s.s1
llvm.hexagon.M2.vmpy2s.s1pack
llvm.hexagon.M2.vmpy2su.s0
llvm.hexagon.M2.vmpy2su.s1
llvm.hexagon.M2.vraddh
llvm.hexagon.M2.vradduh
llvm.hexagon.M2.vrcmaci.s0
llvm.hexagon.M2.vrcmaci.s0c
llvm.hexagon.M2.vrcmacr.s0
llvm.hexagon.M2.vrcmacr.s0c
llvm.hexagon.M2.vrcmpyi.s0
llvm.hexagon.M2.vrcmpyi.s0c
llvm.hexagon.M2.vrcmpyr.s0
llvm.hexagon.M2.vrcmpyr.s0c
llvm.hexagon.M2.vrcmpys.acc.s1
llvm.hexagon.M2.vrcmpys.s1
llvm.hexagon.M2.vrcmpys.s1rp
llvm.hexagon.M2.vrmac.s0
llvm.hexagon.M2.vrmpy.s0
llvm.hexagon.M2.xor.xacc
llvm.hexagon.M4.and.and
llvm.hexagon.M4.and.andn
llvm.hexagon.M4.and.or
llvm.hexagon.M4.and.xor
llvm.hexagon.M4.cmpyi.wh
llvm.hexagon.M4.cmpyi.whc
llvm.hexagon.M4.cmpyr.wh
llvm.hexagon.M4.cmpyr.whc
llvm.hexagon.M4.mac.up.s1.sat
llvm.hexagon.M4.mpyri.addi
llvm.hexagon.M4.mpyri.addr
llvm.hexagon.M4.mpyri.addr.u2
llvm.hexagon.M4.mpyrr.addi
llvm.hexagon.M4.mpyrr.addr
llvm.hexagon.M4.nac.up.s1.sat
llvm.hexagon.M4.or.and
llvm.hexagon.M4.or.andn
llvm.hexagon.M4.or.or
llvm.hexagon.M4.or.xor
llvm.hexagon.M4.pmpyw
llvm.hexagon.M4.pmpyw.acc
llvm.hexagon.M4.vpmpyh
llvm.hexagon.M4.vpmpyh.acc
llvm.hexagon.M4.vrmpyeh.acc.s0
llvm.hexagon.M4.vrmpyeh.acc.s1
llvm.hexagon.M4.vrmpyeh.s0
llvm.hexagon.M4.vrmpyeh.s1
llvm.hexagon.M4.vrmpyoh.acc.s0
llvm.hexagon.M4.vrmpyoh.acc.s1
llvm.hexagon.M4.vrmpyoh.s0
llvm.hexagon.M4.vrmpyoh.s1
llvm.hexagon.M4.xor.and
llvm.hexagon.M4.xor.andn
llvm.hexagon.M4.xor.or
llvm.hexagon.M4.xor.xacc
llvm.hexagon.M5.vdmacbsu
llvm.hexagon.M5.vdmpybsu
llvm.hexagon.M5.vmacbsu
llvm.hexagon.M5.vmacbuu
llvm.hexagon.M5.vmpybsu
llvm.hexagon.M5.vmpybuu
llvm.hexagon.M5.vrmacbsu
llvm.hexagon.M5.vrmacbuu
llvm.hexagon.M5.vrmpybsu
llvm.hexagon.M5.vrmpybuu
llvm.hexagon.M6.vabsdiffb
llvm.hexagon.M6.vabsdiffub
llvm.hexagon.S2.addasl.rrri
llvm.hexagon.S2.asl.i.p
llvm.hexagon.S2.asl.i.p.acc
llvm.hexagon.S2.asl.i.p.and
llvm.hexagon.S2.asl.i.p.nac
llvm.hexagon.S2.asl.i.p.or
llvm.hexagon.S2.asl.i.p.xacc
llvm.hexagon.S2.asl.i.r
llvm.hexagon.S2.asl.i.r.acc
llvm.hexagon.S2.asl.i.r.and
llvm.hexagon.S2.asl.i.r.nac
llvm.hexagon.S2.asl.i.r.or
llvm.hexagon.S2.asl.i.r.sat
llvm.hexagon.S2.asl.i.r.xacc
llvm.hexagon.S2.asl.i.vh
llvm.hexagon.S2.asl.i.vw
llvm.hexagon.S2.asl.r.p
llvm.hexagon.S2.asl.r.p.acc
llvm.hexagon.S2.asl.r.p.and
llvm.hexagon.S2.asl.r.p.nac
llvm.hexagon.S2.asl.r.p.or
llvm.hexagon.S2.asl.r.p.xor
llvm.hexagon.S2.asl.r.r
llvm.hexagon.S2.asl.r.r.acc
llvm.hexagon.S2.asl.r.r.and
llvm.hexagon.S2.asl.r.r.nac
llvm.hexagon.S2.asl.r.r.or
llvm.hexagon.S2.asl.r.r.sat
llvm.hexagon.S2.asl.r.vh
llvm.hexagon.S2.asl.r.vw
llvm.hexagon.S2.asr.i.p
llvm.hexagon.S2.asr.i.p.acc
llvm.hexagon.S2.asr.i.p.and
llvm.hexagon.S2.asr.i.p.nac
llvm.hexagon.S2.asr.i.p.or
llvm.hexagon.S2.asr.i.p.rnd
llvm.hexagon.S2.asr.i.p.rnd.goodsyntax
llvm.hexagon.S2.asr.i.r
llvm.hexagon.S2.asr.i.r.acc
llvm.hexagon.S2.asr.i.r.and
llvm.hexagon.S2.asr.i.r.nac
llvm.hexagon.S2.asr.i.r.or
llvm.hexagon.S2.asr.i.r.rnd
llvm.hexagon.S2.asr.i.r.rnd.goodsyntax
llvm.hexagon.S2.asr.i.svw.trun
llvm.hexagon.S2.asr.i.vh
llvm.hexagon.S2.asr.i.vw
llvm.hexagon.S2.asr.r.p
llvm.hexagon.S2.asr.r.p.acc
llvm.hexagon.S2.asr.r.p.and
llvm.hexagon.S2.asr.r.p.nac
llvm.hexagon.S2.asr.r.p.or
llvm.hexagon.S2.asr.r.p.xor
llvm.hexagon.S2.asr.r.r
llvm.hexagon.S2.asr.r.r.acc
llvm.hexagon.S2.asr.r.r.and
llvm.hexagon.S2.asr.r.r.nac
llvm.hexagon.S2.asr.r.r.or
llvm.hexagon.S2.asr.r.r.sat
llvm.hexagon.S2.asr.r.svw.trun
llvm.hexagon.S2.asr.r.vh
llvm.hexagon.S2.asr.r.vw
llvm.hexagon.S2.brev
llvm.hexagon.S2.brevp
llvm.hexagon.S2.cabacencbin
llvm.hexagon.S2.cl0
llvm.hexagon.S2.cl0p
llvm.hexagon.S2.cl1
llvm.hexagon.S2.cl1p
llvm.hexagon.S2.clb
llvm.hexagon.S2.clbnorm
llvm.hexagon.S2.clbp
llvm.hexagon.S2.clrbit.i
llvm.hexagon.S2.clrbit.r
llvm.hexagon.S2.ct0
llvm.hexagon.S2.ct0p
llvm.hexagon.S2.ct1
llvm.hexagon.S2.ct1p
llvm.hexagon.S2.deinterleave
llvm.hexagon.S2.extractu
llvm.hexagon.S2.extractu.rp
llvm.hexagon.S2.extractup
llvm.hexagon.S2.extractup.rp
llvm.hexagon.S2.insert
llvm.hexagon.S2.insert.rp
llvm.hexagon.S2.insertp
llvm.hexagon.S2.insertp.rp
llvm.hexagon.S2.interleave
llvm.hexagon.S2.lfsp
llvm.hexagon.S2.lsl.r.p
llvm.hexagon.S2.lsl.r.p.acc
llvm.hexagon.S2.lsl.r.p.and
llvm.hexagon.S2.lsl.r.p.nac
llvm.hexagon.S2.lsl.r.p.or
llvm.hexagon.S2.lsl.r.p.xor
llvm.hexagon.S2.lsl.r.r
llvm.hexagon.S2.lsl.r.r.acc
llvm.hexagon.S2.lsl.r.r.and
llvm.hexagon.S2.lsl.r.r.nac
llvm.hexagon.S2.lsl.r.r.or
llvm.hexagon.S2.lsl.r.vh
llvm.hexagon.S2.lsl.r.vw
llvm.hexagon.S2.lsr.i.p
llvm.hexagon.S2.lsr.i.p.acc
llvm.hexagon.S2.lsr.i.p.and
llvm.hexagon.S2.lsr.i.p.nac
llvm.hexagon.S2.lsr.i.p.or
llvm.hexagon.S2.lsr.i.p.xacc
llvm.hexagon.S2.lsr.i.r
llvm.hexagon.S2.lsr.i.r.acc
llvm.hexagon.S2.lsr.i.r.and
llvm.hexagon.S2.lsr.i.r.nac
llvm.hexagon.S2.lsr.i.r.or
llvm.hexagon.S2.lsr.i.r.xacc
llvm.hexagon.S2.lsr.i.vh
llvm.hexagon.S2.lsr.i.vw
llvm.hexagon.S2.lsr.r.p
llvm.hexagon.S2.lsr.r.p.acc
llvm.hexagon.S2.lsr.r.p.and
llvm.hexagon.S2.lsr.r.p.nac
llvm.hexagon.S2.lsr.r.p.or
llvm.hexagon.S2.lsr.r.p.xor
llvm.hexagon.S2.lsr.r.r
llvm.hexagon.S2.lsr.r.r.acc
llvm.hexagon.S2.lsr.r.r.and
llvm.hexagon.S2.lsr.r.r.nac
llvm.hexagon.S2.lsr.r.r.or
llvm.hexagon.S2.lsr.r.vh
llvm.hexagon.S2.lsr.r.vw
llvm.hexagon.S2.packhl
llvm.hexagon.S2.parityp
llvm.hexagon.S2.setbit.i
llvm.hexagon.S2.setbit.r
llvm.hexagon.S2.shuffeb
llvm.hexagon.S2.shuffeh
llvm.hexagon.S2.shuffob
llvm.hexagon.S2.shuffoh
llvm.hexagon.S2.storerb.pbr
llvm.hexagon.S2.storerb.pci
llvm.hexagon.S2.storerb.pcr
llvm.hexagon.S2.storerd.pbr
llvm.hexagon.S2.storerd.pci
llvm.hexagon.S2.storerd.pcr
llvm.hexagon.S2.storerf.pbr
llvm.hexagon.S2.storerf.pci
llvm.hexagon.S2.storerf.pcr
llvm.hexagon.S2.storerh.pbr
llvm.hexagon.S2.storerh.pci
llvm.hexagon.S2.storerh.pcr
llvm.hexagon.S2.storeri.pbr
llvm.hexagon.S2.storeri.pci
llvm.hexagon.S2.storeri.pcr
llvm.hexagon.S2.storew.locked
llvm.hexagon.S2.svsathb
llvm.hexagon.S2.svsathub
llvm.hexagon.S2.tableidxb.goodsyntax
llvm.hexagon.S2.tableidxd.goodsyntax
llvm.hexagon.S2.tableidxh.goodsyntax
llvm.hexagon.S2.tableidxw.goodsyntax
llvm.hexagon.S2.togglebit.i
llvm.hexagon.S2.togglebit.r
llvm.hexagon.S2.tstbit.i
llvm.hexagon.S2.tstbit.r
llvm.hexagon.S2.valignib
llvm.hexagon.S2.valignrb
llvm.hexagon.S2.vcnegh
llvm.hexagon.S2.vcrotate
llvm.hexagon.S2.vrcnegh
llvm.hexagon.S2.vrndpackwh
llvm.hexagon.S2.vrndpackwhs
llvm.hexagon.S2.vsathb
llvm.hexagon.S2.vsathb.nopack
llvm.hexagon.S2.vsathub
llvm.hexagon.S2.vsathub.nopack
llvm.hexagon.S2.vsatwh
llvm.hexagon.S2.vsatwh.nopack
llvm.hexagon.S2.vsatwuh
llvm.hexagon.S2.vsatwuh.nopack
llvm.hexagon.S2.vsplatrb
llvm.hexagon.S2.vsplatrh
llvm.hexagon.S2.vspliceib
llvm.hexagon.S2.vsplicerb
llvm.hexagon.S2.vsxtbh
llvm.hexagon.S2.vsxthw
llvm.hexagon.S2.vtrunehb
llvm.hexagon.S2.vtrunewh
llvm.hexagon.S2.vtrunohb
llvm.hexagon.S2.vtrunowh
llvm.hexagon.S2.vzxtbh
llvm.hexagon.S2.vzxthw
llvm.hexagon.S4.addaddi
llvm.hexagon.S4.addi.asl.ri
llvm.hexagon.S4.addi.lsr.ri
llvm.hexagon.S4.andi.asl.ri
llvm.hexagon.S4.andi.lsr.ri
llvm.hexagon.S4.clbaddi
llvm.hexagon.S4.clbpaddi
llvm.hexagon.S4.clbpnorm
llvm.hexagon.S4.extract
llvm.hexagon.S4.extract.rp
llvm.hexagon.S4.extractp
llvm.hexagon.S4.extractp.rp
llvm.hexagon.S4.lsli
llvm.hexagon.S4.ntstbit.i
llvm.hexagon.S4.ntstbit.r
llvm.hexagon.S4.or.andi
llvm.hexagon.S4.or.andix
llvm.hexagon.S4.or.ori
llvm.hexagon.S4.ori.asl.ri
llvm.hexagon.S4.ori.lsr.ri
llvm.hexagon.S4.parity
llvm.hexagon.S4.stored.locked
llvm.hexagon.S4.subaddi
llvm.hexagon.S4.subi.asl.ri
llvm.hexagon.S4.subi.lsr.ri
llvm.hexagon.S4.vrcrotate
llvm.hexagon.S4.vrcrotate.acc
llvm.hexagon.S4.vxaddsubh
llvm.hexagon.S4.vxaddsubhr
llvm.hexagon.S4.vxaddsubw
llvm.hexagon.S4.vxsubaddh
llvm.hexagon.S4.vxsubaddhr
llvm.hexagon.S4.vxsubaddw
llvm.hexagon.S5.asrhub.rnd.sat.goodsyntax
llvm.hexagon.S5.asrhub.sat
llvm.hexagon.S5.popcountp
llvm.hexagon.S5.vasrhrnd.goodsyntax
llvm.hexagon.S6.rol.i.p
llvm.hexagon.S6.rol.i.p.acc
llvm.hexagon.S6.rol.i.p.and
llvm.hexagon.S6.rol.i.p.nac
llvm.hexagon.S6.rol.i.p.or
llvm.hexagon.S6.rol.i.p.xacc
llvm.hexagon.S6.rol.i.r
llvm.hexagon.S6.rol.i.r.acc
llvm.hexagon.S6.rol.i.r.and
llvm.hexagon.S6.rol.i.r.nac
llvm.hexagon.S6.rol.i.r.or
llvm.hexagon.S6.rol.i.r.xacc
llvm.hexagon.S6.vsplatrbp
llvm.hexagon.S6.vtrunehb.ppp
llvm.hexagon.S6.vtrunohb.ppp
llvm.hexagon.V6.extractw
llvm.hexagon.V6.extractw.128B
llvm.hexagon.V6.hi
llvm.hexagon.V6.hi.128B
llvm.hexagon.V6.lo
llvm.hexagon.V6.lo.128B
llvm.hexagon.V6.lvsplatb
llvm.hexagon.V6.lvsplatb.128B
llvm.hexagon.V6.lvsplath
llvm.hexagon.V6.lvsplath.128B
llvm.hexagon.V6.lvsplatw
llvm.hexagon.V6.lvsplatw.128B
llvm.hexagon.V6.pred.and
llvm.hexagon.V6.pred.and.128B
llvm.hexagon.V6.pred.and.n
llvm.hexagon.V6.pred.and.n.128B
llvm.hexagon.V6.pred.not
llvm.hexagon.V6.pred.not.128B
llvm.hexagon.V6.pred.or
llvm.hexagon.V6.pred.or.128B
llvm.hexagon.V6.pred.or.n
llvm.hexagon.V6.pred.or.n.128B
llvm.hexagon.V6.pred.scalar2
llvm.hexagon.V6.pred.scalar2.128B
llvm.hexagon.V6.pred.scalar2v2
llvm.hexagon.V6.pred.scalar2v2.128B
llvm.hexagon.V6.pred.xor
llvm.hexagon.V6.pred.xor.128B
llvm.hexagon.V6.shuffeqh
llvm.hexagon.V6.shuffeqh.128B
llvm.hexagon.V6.shuffeqw
llvm.hexagon.V6.shuffeqw.128B
llvm.hexagon.V6.vS32b.nqpred.ai
llvm.hexagon.V6.vS32b.nqpred.ai.128B
llvm.hexagon.V6.vS32b.nt.nqpred.ai
llvm.hexagon.V6.vS32b.nt.nqpred.ai.128B
llvm.hexagon.V6.vS32b.nt.qpred.ai
llvm.hexagon.V6.vS32b.nt.qpred.ai.128B
llvm.hexagon.V6.vS32b.qpred.ai
llvm.hexagon.V6.vS32b.qpred.ai.128B
llvm.hexagon.V6.vabsb
llvm.hexagon.V6.vabsb.128B
llvm.hexagon.V6.vabsb.sat
llvm.hexagon.V6.vabsb.sat.128B
llvm.hexagon.V6.vabsdiffh
llvm.hexagon.V6.vabsdiffh.128B
llvm.hexagon.V6.vabsdiffub
llvm.hexagon.V6.vabsdiffub.128B
llvm.hexagon.V6.vabsdiffuh
llvm.hexagon.V6.vabsdiffuh.128B
llvm.hexagon.V6.vabsdiffw
llvm.hexagon.V6.vabsdiffw.128B
llvm.hexagon.V6.vabsh
llvm.hexagon.V6.vabsh.128B
llvm.hexagon.V6.vabsh.sat
llvm.hexagon.V6.vabsh.sat.128B
llvm.hexagon.V6.vabsw
llvm.hexagon.V6.vabsw.128B
llvm.hexagon.V6.vabsw.sat
llvm.hexagon.V6.vabsw.sat.128B
llvm.hexagon.V6.vaddb
llvm.hexagon.V6.vaddb.128B
llvm.hexagon.V6.vaddb.dv
llvm.hexagon.V6.vaddb.dv.128B
llvm.hexagon.V6.vaddbnq
llvm.hexagon.V6.vaddbnq.128B
llvm.hexagon.V6.vaddbq
llvm.hexagon.V6.vaddbq.128B
llvm.hexagon.V6.vaddbsat
llvm.hexagon.V6.vaddbsat.128B
llvm.hexagon.V6.vaddbsat.dv
llvm.hexagon.V6.vaddbsat.dv.128B
llvm.hexagon.V6.vaddcarry
llvm.hexagon.V6.vaddcarry.128B
llvm.hexagon.V6.vaddclbh
llvm.hexagon.V6.vaddclbh.128B
llvm.hexagon.V6.vaddclbw
llvm.hexagon.V6.vaddclbw.128B
llvm.hexagon.V6.vaddh
llvm.hexagon.V6.vaddh.128B
llvm.hexagon.V6.vaddh.dv
llvm.hexagon.V6.vaddh.dv.128B
llvm.hexagon.V6.vaddhnq
llvm.hexagon.V6.vaddhnq.128B
llvm.hexagon.V6.vaddhq
llvm.hexagon.V6.vaddhq.128B
llvm.hexagon.V6.vaddhsat
llvm.hexagon.V6.vaddhsat.128B
llvm.hexagon.V6.vaddhsat.dv
llvm.hexagon.V6.vaddhsat.dv.128B
llvm.hexagon.V6.vaddhw
llvm.hexagon.V6.vaddhw.128B
llvm.hexagon.V6.vaddhw.acc
llvm.hexagon.V6.vaddhw.acc.128B
llvm.hexagon.V6.vaddubh
llvm.hexagon.V6.vaddubh.128B
llvm.hexagon.V6.vaddubh.acc
llvm.hexagon.V6.vaddubh.acc.128B
llvm.hexagon.V6.vaddubsat
llvm.hexagon.V6.vaddubsat.128B
llvm.hexagon.V6.vaddubsat.dv
llvm.hexagon.V6.vaddubsat.dv.128B
llvm.hexagon.V6.vaddububb.sat
llvm.hexagon.V6.vaddububb.sat.128B
llvm.hexagon.V6.vadduhsat
llvm.hexagon.V6.vadduhsat.128B
llvm.hexagon.V6.vadduhsat.dv
llvm.hexagon.V6.vadduhsat.dv.128B
llvm.hexagon.V6.vadduhw
llvm.hexagon.V6.vadduhw.128B
llvm.hexagon.V6.vadduhw.acc
llvm.hexagon.V6.vadduhw.acc.128B
llvm.hexagon.V6.vadduwsat
llvm.hexagon.V6.vadduwsat.128B
llvm.hexagon.V6.vadduwsat.dv
llvm.hexagon.V6.vadduwsat.dv.128B
llvm.hexagon.V6.vaddw
llvm.hexagon.V6.vaddw.128B
llvm.hexagon.V6.vaddw.dv
llvm.hexagon.V6.vaddw.dv.128B
llvm.hexagon.V6.vaddwnq
llvm.hexagon.V6.vaddwnq.128B
llvm.hexagon.V6.vaddwq
llvm.hexagon.V6.vaddwq.128B
llvm.hexagon.V6.vaddwsat
llvm.hexagon.V6.vaddwsat.128B
llvm.hexagon.V6.vaddwsat.dv
llvm.hexagon.V6.vaddwsat.dv.128B
llvm.hexagon.V6.valignb
llvm.hexagon.V6.valignb.128B
llvm.hexagon.V6.valignbi
llvm.hexagon.V6.valignbi.128B
llvm.hexagon.V6.vand
llvm.hexagon.V6.vand.128B
llvm.hexagon.V6.vandnqrt
llvm.hexagon.V6.vandnqrt.128B
llvm.hexagon.V6.vandnqrt.acc
llvm.hexagon.V6.vandnqrt.acc.128B
llvm.hexagon.V6.vandqrt
llvm.hexagon.V6.vandqrt.128B
llvm.hexagon.V6.vandqrt.acc
llvm.hexagon.V6.vandqrt.acc.128B
llvm.hexagon.V6.vandvnqv
llvm.hexagon.V6.vandvnqv.128B
llvm.hexagon.V6.vandvqv
llvm.hexagon.V6.vandvqv.128B
llvm.hexagon.V6.vandvrt
llvm.hexagon.V6.vandvrt.128B
llvm.hexagon.V6.vandvrt.acc
llvm.hexagon.V6.vandvrt.acc.128B
llvm.hexagon.V6.vaslh
llvm.hexagon.V6.vaslh.128B
llvm.hexagon.V6.vaslh.acc
llvm.hexagon.V6.vaslh.acc.128B
llvm.hexagon.V6.vaslhv
llvm.hexagon.V6.vaslhv.128B
llvm.hexagon.V6.vaslw
llvm.hexagon.V6.vaslw.128B
llvm.hexagon.V6.vaslw.acc
llvm.hexagon.V6.vaslw.acc.128B
llvm.hexagon.V6.vaslwv
llvm.hexagon.V6.vaslwv.128B
llvm.hexagon.V6.vasrh
llvm.hexagon.V6.vasrh.128B
llvm.hexagon.V6.vasrh.acc
llvm.hexagon.V6.vasrh.acc.128B
llvm.hexagon.V6.vasrhbrndsat
llvm.hexagon.V6.vasrhbrndsat.128B
llvm.hexagon.V6.vasrhbsat
llvm.hexagon.V6.vasrhbsat.128B
llvm.hexagon.V6.vasrhubrndsat
llvm.hexagon.V6.vasrhubrndsat.128B
llvm.hexagon.V6.vasrhubsat
llvm.hexagon.V6.vasrhubsat.128B
llvm.hexagon.V6.vasrhv
llvm.hexagon.V6.vasrhv.128B
llvm.hexagon.V6.vasruhubrndsat
llvm.hexagon.V6.vasruhubrndsat.128B
llvm.hexagon.V6.vasruhubsat
llvm.hexagon.V6.vasruhubsat.128B
llvm.hexagon.V6.vasruwuhrndsat
llvm.hexagon.V6.vasruwuhrndsat.128B
llvm.hexagon.V6.vasruwuhsat
llvm.hexagon.V6.vasruwuhsat.128B
llvm.hexagon.V6.vasrw
llvm.hexagon.V6.vasrw.128B
llvm.hexagon.V6.vasrw.acc
llvm.hexagon.V6.vasrw.acc.128B
llvm.hexagon.V6.vasrwh
llvm.hexagon.V6.vasrwh.128B
llvm.hexagon.V6.vasrwhrndsat
llvm.hexagon.V6.vasrwhrndsat.128B
llvm.hexagon.V6.vasrwhsat
llvm.hexagon.V6.vasrwhsat.128B
llvm.hexagon.V6.vasrwuhrndsat
llvm.hexagon.V6.vasrwuhrndsat.128B
llvm.hexagon.V6.vasrwuhsat
llvm.hexagon.V6.vasrwuhsat.128B
llvm.hexagon.V6.vasrwv
llvm.hexagon.V6.vasrwv.128B
llvm.hexagon.V6.vassign
llvm.hexagon.V6.vassign.128B
llvm.hexagon.V6.vassignp
llvm.hexagon.V6.vassignp.128B
llvm.hexagon.V6.vavgb
llvm.hexagon.V6.vavgb.128B
llvm.hexagon.V6.vavgbrnd
llvm.hexagon.V6.vavgbrnd.128B
llvm.hexagon.V6.vavgh
llvm.hexagon.V6.vavgh.128B
llvm.hexagon.V6.vavghrnd
llvm.hexagon.V6.vavghrnd.128B
llvm.hexagon.V6.vavgub
llvm.hexagon.V6.vavgub.128B
llvm.hexagon.V6.vavgubrnd
llvm.hexagon.V6.vavgubrnd.128B
llvm.hexagon.V6.vavguh
llvm.hexagon.V6.vavguh.128B
llvm.hexagon.V6.vavguhrnd
llvm.hexagon.V6.vavguhrnd.128B
llvm.hexagon.V6.vavguw
llvm.hexagon.V6.vavguw.128B
llvm.hexagon.V6.vavguwrnd
llvm.hexagon.V6.vavguwrnd.128B
llvm.hexagon.V6.vavgw
llvm.hexagon.V6.vavgw.128B
llvm.hexagon.V6.vavgwrnd
llvm.hexagon.V6.vavgwrnd.128B
llvm.hexagon.V6.vcl0h
llvm.hexagon.V6.vcl0h.128B
llvm.hexagon.V6.vcl0w
llvm.hexagon.V6.vcl0w.128B
llvm.hexagon.V6.vcombine
llvm.hexagon.V6.vcombine.128B
llvm.hexagon.V6.vd0
llvm.hexagon.V6.vd0.128B
llvm.hexagon.V6.vdd0
llvm.hexagon.V6.vdd0.128B
llvm.hexagon.V6.vdealb
llvm.hexagon.V6.vdealb.128B
llvm.hexagon.V6.vdealb4w
llvm.hexagon.V6.vdealb4w.128B
llvm.hexagon.V6.vdealh
llvm.hexagon.V6.vdealh.128B
llvm.hexagon.V6.vdealvdd
llvm.hexagon.V6.vdealvdd.128B
llvm.hexagon.V6.vdelta
llvm.hexagon.V6.vdelta.128B
llvm.hexagon.V6.vdmpybus
llvm.hexagon.V6.vdmpybus.128B
llvm.hexagon.V6.vdmpybus.acc
llvm.hexagon.V6.vdmpybus.acc.128B
llvm.hexagon.V6.vdmpybus.dv
llvm.hexagon.V6.vdmpybus.dv.128B
llvm.hexagon.V6.vdmpybus.dv.acc
llvm.hexagon.V6.vdmpybus.dv.acc.128B
llvm.hexagon.V6.vdmpyhb
llvm.hexagon.V6.vdmpyhb.128B
llvm.hexagon.V6.vdmpyhb.acc
llvm.hexagon.V6.vdmpyhb.acc.128B
llvm.hexagon.V6.vdmpyhb.dv
llvm.hexagon.V6.vdmpyhb.dv.128B
llvm.hexagon.V6.vdmpyhb.dv.acc
llvm.hexagon.V6.vdmpyhb.dv.acc.128B
llvm.hexagon.V6.vdmpyhisat
llvm.hexagon.V6.vdmpyhisat.128B
llvm.hexagon.V6.vdmpyhisat.acc
llvm.hexagon.V6.vdmpyhisat.acc.128B
llvm.hexagon.V6.vdmpyhsat
llvm.hexagon.V6.vdmpyhsat.128B
llvm.hexagon.V6.vdmpyhsat.acc
llvm.hexagon.V6.vdmpyhsat.acc.128B
llvm.hexagon.V6.vdmpyhsuisat
llvm.hexagon.V6.vdmpyhsuisat.128B
llvm.hexagon.V6.vdmpyhsuisat.acc
llvm.hexagon.V6.vdmpyhsuisat.acc.128B
llvm.hexagon.V6.vdmpyhsusat
llvm.hexagon.V6.vdmpyhsusat.128B
llvm.hexagon.V6.vdmpyhsusat.acc
llvm.hexagon.V6.vdmpyhsusat.acc.128B
llvm.hexagon.V6.vdmpyhvsat
llvm.hexagon.V6.vdmpyhvsat.128B
llvm.hexagon.V6.vdmpyhvsat.acc
llvm.hexagon.V6.vdmpyhvsat.acc.128B
llvm.hexagon.V6.vdsaduh
llvm.hexagon.V6.vdsaduh.128B
llvm.hexagon.V6.vdsaduh.acc
llvm.hexagon.V6.vdsaduh.acc.128B
llvm.hexagon.V6.veqb
llvm.hexagon.V6.veqb.128B
llvm.hexagon.V6.veqb.and
llvm.hexagon.V6.veqb.and.128B
llvm.hexagon.V6.veqb.or
llvm.hexagon.V6.veqb.or.128B
llvm.hexagon.V6.veqb.xor
llvm.hexagon.V6.veqb.xor.128B
llvm.hexagon.V6.veqh
llvm.hexagon.V6.veqh.128B
llvm.hexagon.V6.veqh.and
llvm.hexagon.V6.veqh.and.128B
llvm.hexagon.V6.veqh.or
llvm.hexagon.V6.veqh.or.128B
llvm.hexagon.V6.veqh.xor
llvm.hexagon.V6.veqh.xor.128B
llvm.hexagon.V6.veqw
llvm.hexagon.V6.veqw.128B
llvm.hexagon.V6.veqw.and
llvm.hexagon.V6.veqw.and.128B
llvm.hexagon.V6.veqw.or
llvm.hexagon.V6.veqw.or.128B
llvm.hexagon.V6.veqw.xor
llvm.hexagon.V6.veqw.xor.128B
llvm.hexagon.V6.vgathermh
llvm.hexagon.V6.vgathermh.128B
llvm.hexagon.V6.vgathermhq
llvm.hexagon.V6.vgathermhq.128B
llvm.hexagon.V6.vgathermhw
llvm.hexagon.V6.vgathermhw.128B
llvm.hexagon.V6.vgathermhwq
llvm.hexagon.V6.vgathermhwq.128B
llvm.hexagon.V6.vgathermw
llvm.hexagon.V6.vgathermw.128B
llvm.hexagon.V6.vgathermwq
llvm.hexagon.V6.vgathermwq.128B
llvm.hexagon.V6.vgtb
llvm.hexagon.V6.vgtb.128B
llvm.hexagon.V6.vgtb.and
llvm.hexagon.V6.vgtb.and.128B
llvm.hexagon.V6.vgtb.or
llvm.hexagon.V6.vgtb.or.128B
llvm.hexagon.V6.vgtb.xor
llvm.hexagon.V6.vgtb.xor.128B
llvm.hexagon.V6.vgth
llvm.hexagon.V6.vgth.128B
llvm.hexagon.V6.vgth.and
llvm.hexagon.V6.vgth.and.128B
llvm.hexagon.V6.vgth.or
llvm.hexagon.V6.vgth.or.128B
llvm.hexagon.V6.vgth.xor
llvm.hexagon.V6.vgth.xor.128B
llvm.hexagon.V6.vgtub
llvm.hexagon.V6.vgtub.128B
llvm.hexagon.V6.vgtub.and
llvm.hexagon.V6.vgtub.and.128B
llvm.hexagon.V6.vgtub.or
llvm.hexagon.V6.vgtub.or.128B
llvm.hexagon.V6.vgtub.xor
llvm.hexagon.V6.vgtub.xor.128B
llvm.hexagon.V6.vgtuh
llvm.hexagon.V6.vgtuh.128B
llvm.hexagon.V6.vgtuh.and
llvm.hexagon.V6.vgtuh.and.128B
llvm.hexagon.V6.vgtuh.or
llvm.hexagon.V6.vgtuh.or.128B
llvm.hexagon.V6.vgtuh.xor
llvm.hexagon.V6.vgtuh.xor.128B
llvm.hexagon.V6.vgtuw
llvm.hexagon.V6.vgtuw.128B
llvm.hexagon.V6.vgtuw.and
llvm.hexagon.V6.vgtuw.and.128B
llvm.hexagon.V6.vgtuw.or
llvm.hexagon.V6.vgtuw.or.128B
llvm.hexagon.V6.vgtuw.xor
llvm.hexagon.V6.vgtuw.xor.128B
llvm.hexagon.V6.vgtw
llvm.hexagon.V6.vgtw.128B
llvm.hexagon.V6.vgtw.and
llvm.hexagon.V6.vgtw.and.128B
llvm.hexagon.V6.vgtw.or
llvm.hexagon.V6.vgtw.or.128B
llvm.hexagon.V6.vgtw.xor
llvm.hexagon.V6.vgtw.xor.128B
llvm.hexagon.V6.vinsertwr
llvm.hexagon.V6.vinsertwr.128B
llvm.hexagon.V6.vlalignb
llvm.hexagon.V6.vlalignb.128B
llvm.hexagon.V6.vlalignbi
llvm.hexagon.V6.vlalignbi.128B
llvm.hexagon.V6.vlsrb
llvm.hexagon.V6.vlsrb.128B
llvm.hexagon.V6.vlsrh
llvm.hexagon.V6.vlsrh.128B
llvm.hexagon.V6.vlsrhv
llvm.hexagon.V6.vlsrhv.128B
llvm.hexagon.V6.vlsrw
llvm.hexagon.V6.vlsrw.128B
llvm.hexagon.V6.vlsrwv
llvm.hexagon.V6.vlsrwv.128B
llvm.hexagon.V6.vlut4
llvm.hexagon.V6.vlut4.128B
llvm.hexagon.V6.vlutvvb
llvm.hexagon.V6.vlutvvb.128B
llvm.hexagon.V6.vlutvvb.nm
llvm.hexagon.V6.vlutvvb.nm.128B
llvm.hexagon.V6.vlutvvb.oracc
llvm.hexagon.V6.vlutvvb.oracc.128B
llvm.hexagon.V6.vlutvvb.oracci
llvm.hexagon.V6.vlutvvb.oracci.128B
llvm.hexagon.V6.vlutvvbi
llvm.hexagon.V6.vlutvvbi.128B
llvm.hexagon.V6.vlutvwh
llvm.hexagon.V6.vlutvwh.128B
llvm.hexagon.V6.vlutvwh.nm
llvm.hexagon.V6.vlutvwh.nm.128B
llvm.hexagon.V6.vlutvwh.oracc
llvm.hexagon.V6.vlutvwh.oracc.128B
llvm.hexagon.V6.vlutvwh.oracci
llvm.hexagon.V6.vlutvwh.oracci.128B
llvm.hexagon.V6.vlutvwhi
llvm.hexagon.V6.vlutvwhi.128B
llvm.hexagon.V6.vmaskedstorenq
llvm.hexagon.V6.vmaskedstorenq.128B
llvm.hexagon.V6.vmaskedstorentnq
llvm.hexagon.V6.vmaskedstorentnq.128B
llvm.hexagon.V6.vmaskedstorentq
llvm.hexagon.V6.vmaskedstorentq.128B
llvm.hexagon.V6.vmaskedstoreq
llvm.hexagon.V6.vmaskedstoreq.128B
llvm.hexagon.V6.vmaxb
llvm.hexagon.V6.vmaxb.128B
llvm.hexagon.V6.vmaxh
llvm.hexagon.V6.vmaxh.128B
llvm.hexagon.V6.vmaxub
llvm.hexagon.V6.vmaxub.128B
llvm.hexagon.V6.vmaxuh
llvm.hexagon.V6.vmaxuh.128B
llvm.hexagon.V6.vmaxw
llvm.hexagon.V6.vmaxw.128B
llvm.hexagon.V6.vminb
llvm.hexagon.V6.vminb.128B
llvm.hexagon.V6.vminh
llvm.hexagon.V6.vminh.128B
llvm.hexagon.V6.vminub
llvm.hexagon.V6.vminub.128B
llvm.hexagon.V6.vminuh
llvm.hexagon.V6.vminuh.128B
llvm.hexagon.V6.vminw
llvm.hexagon.V6.vminw.128B
llvm.hexagon.V6.vmpabus
llvm.hexagon.V6.vmpabus.128B
llvm.hexagon.V6.vmpabus.acc
llvm.hexagon.V6.vmpabus.acc.128B
llvm.hexagon.V6.vmpabusv
llvm.hexagon.V6.vmpabusv.128B
llvm.hexagon.V6.vmpabuu
llvm.hexagon.V6.vmpabuu.128B
llvm.hexagon.V6.vmpabuu.acc
llvm.hexagon.V6.vmpabuu.acc.128B
llvm.hexagon.V6.vmpabuuv
llvm.hexagon.V6.vmpabuuv.128B
llvm.hexagon.V6.vmpahb
llvm.hexagon.V6.vmpahb.128B
llvm.hexagon.V6.vmpahb.acc
llvm.hexagon.V6.vmpahb.acc.128B
llvm.hexagon.V6.vmpahhsat
llvm.hexagon.V6.vmpahhsat.128B
llvm.hexagon.V6.vmpauhb
llvm.hexagon.V6.vmpauhb.128B
llvm.hexagon.V6.vmpauhb.acc
llvm.hexagon.V6.vmpauhb.acc.128B
llvm.hexagon.V6.vmpauhuhsat
llvm.hexagon.V6.vmpauhuhsat.128B
llvm.hexagon.V6.vmpsuhuhsat
llvm.hexagon.V6.vmpsuhuhsat.128B
llvm.hexagon.V6.vmpybus
llvm.hexagon.V6.vmpybus.128B
llvm.hexagon.V6.vmpybus.acc
llvm.hexagon.V6.vmpybus.acc.128B
llvm.hexagon.V6.vmpybusv
llvm.hexagon.V6.vmpybusv.128B
llvm.hexagon.V6.vmpybusv.acc
llvm.hexagon.V6.vmpybusv.acc.128B
llvm.hexagon.V6.vmpybv
llvm.hexagon.V6.vmpybv.128B
llvm.hexagon.V6.vmpybv.acc
llvm.hexagon.V6.vmpybv.acc.128B
llvm.hexagon.V6.vmpyewuh
llvm.hexagon.V6.vmpyewuh.128B
llvm.hexagon.V6.vmpyewuh.64
llvm.hexagon.V6.vmpyewuh.64.128B
llvm.hexagon.V6.vmpyh
llvm.hexagon.V6.vmpyh.128B
llvm.hexagon.V6.vmpyh.acc
llvm.hexagon.V6.vmpyh.acc.128B
llvm.hexagon.V6.vmpyhsat.acc
llvm.hexagon.V6.vmpyhsat.acc.128B
llvm.hexagon.V6.vmpyhsrs
llvm.hexagon.V6.vmpyhsrs.128B
llvm.hexagon.V6.vmpyhss
llvm.hexagon.V6.vmpyhss.128B
llvm.hexagon.V6.vmpyhus
llvm.hexagon.V6.vmpyhus.128B
llvm.hexagon.V6.vmpyhus.acc
llvm.hexagon.V6.vmpyhus.acc.128B
llvm.hexagon.V6.vmpyhv
llvm.hexagon.V6.vmpyhv.128B
llvm.hexagon.V6.vmpyhv.acc
llvm.hexagon.V6.vmpyhv.acc.128B
llvm.hexagon.V6.vmpyhvsrs
llvm.hexagon.V6.vmpyhvsrs.128B
llvm.hexagon.V6.vmpyieoh
llvm.hexagon.V6.vmpyieoh.128B
llvm.hexagon.V6.vmpyiewh.acc
llvm.hexagon.V6.vmpyiewh.acc.128B
llvm.hexagon.V6.vmpyiewuh
llvm.hexagon.V6.vmpyiewuh.128B
llvm.hexagon.V6.vmpyiewuh.acc
llvm.hexagon.V6.vmpyiewuh.acc.128B
llvm.hexagon.V6.vmpyih
llvm.hexagon.V6.vmpyih.128B
llvm.hexagon.V6.vmpyih.acc
llvm.hexagon.V6.vmpyih.acc.128B
llvm.hexagon.V6.vmpyihb
llvm.hexagon.V6.vmpyihb.128B
llvm.hexagon.V6.vmpyihb.acc
llvm.hexagon.V6.vmpyihb.acc.128B
llvm.hexagon.V6.vmpyiowh
llvm.hexagon.V6.vmpyiowh.128B
llvm.hexagon.V6.vmpyiwb
llvm.hexagon.V6.vmpyiwb.128B
llvm.hexagon.V6.vmpyiwb.acc
llvm.hexagon.V6.vmpyiwb.acc.128B
llvm.hexagon.V6.vmpyiwh
llvm.hexagon.V6.vmpyiwh.128B
llvm.hexagon.V6.vmpyiwh.acc
llvm.hexagon.V6.vmpyiwh.acc.128B
llvm.hexagon.V6.vmpyiwub
llvm.hexagon.V6.vmpyiwub.128B
llvm.hexagon.V6.vmpyiwub.acc
llvm.hexagon.V6.vmpyiwub.acc.128B
llvm.hexagon.V6.vmpyowh
llvm.hexagon.V6.vmpyowh.128B
llvm.hexagon.V6.vmpyowh.64.acc
llvm.hexagon.V6.vmpyowh.64.acc.128B
llvm.hexagon.V6.vmpyowh.rnd
llvm.hexagon.V6.vmpyowh.rnd.128B
llvm.hexagon.V6.vmpyowh.rnd.sacc
llvm.hexagon.V6.vmpyowh.rnd.sacc.128B
llvm.hexagon.V6.vmpyowh.sacc
llvm.hexagon.V6.vmpyowh.sacc.128B
llvm.hexagon.V6.vmpyub
llvm.hexagon.V6.vmpyub.128B
llvm.hexagon.V6.vmpyub.acc
llvm.hexagon.V6.vmpyub.acc.128B
llvm.hexagon.V6.vmpyubv
llvm.hexagon.V6.vmpyubv.128B
llvm.hexagon.V6.vmpyubv.acc
llvm.hexagon.V6.vmpyubv.acc.128B
llvm.hexagon.V6.vmpyuh
llvm.hexagon.V6.vmpyuh.128B
llvm.hexagon.V6.vmpyuh.acc
llvm.hexagon.V6.vmpyuh.acc.128B
llvm.hexagon.V6.vmpyuhe
llvm.hexagon.V6.vmpyuhe.128B
llvm.hexagon.V6.vmpyuhe.acc
llvm.hexagon.V6.vmpyuhe.acc.128B
llvm.hexagon.V6.vmpyuhv
llvm.hexagon.V6.vmpyuhv.128B
llvm.hexagon.V6.vmpyuhv.acc
llvm.hexagon.V6.vmpyuhv.acc.128B
llvm.hexagon.V6.vmux
llvm.hexagon.V6.vmux.128B
llvm.hexagon.V6.vnavgb
llvm.hexagon.V6.vnavgb.128B
llvm.hexagon.V6.vnavgh
llvm.hexagon.V6.vnavgh.128B
llvm.hexagon.V6.vnavgub
llvm.hexagon.V6.vnavgub.128B
llvm.hexagon.V6.vnavgw
llvm.hexagon.V6.vnavgw.128B
llvm.hexagon.V6.vnormamth
llvm.hexagon.V6.vnormamth.128B
llvm.hexagon.V6.vnormamtw
llvm.hexagon.V6.vnormamtw.128B
llvm.hexagon.V6.vnot
llvm.hexagon.V6.vnot.128B
llvm.hexagon.V6.vor
llvm.hexagon.V6.vor.128B
llvm.hexagon.V6.vpackeb
llvm.hexagon.V6.vpackeb.128B
llvm.hexagon.V6.vpackeh
llvm.hexagon.V6.vpackeh.128B
llvm.hexagon.V6.vpackhb.sat
llvm.hexagon.V6.vpackhb.sat.128B
llvm.hexagon.V6.vpackhub.sat
llvm.hexagon.V6.vpackhub.sat.128B
llvm.hexagon.V6.vpackob
llvm.hexagon.V6.vpackob.128B
llvm.hexagon.V6.vpackoh
llvm.hexagon.V6.vpackoh.128B
llvm.hexagon.V6.vpackwh.sat
llvm.hexagon.V6.vpackwh.sat.128B
llvm.hexagon.V6.vpackwuh.sat
llvm.hexagon.V6.vpackwuh.sat.128B
llvm.hexagon.V6.vpopcounth
llvm.hexagon.V6.vpopcounth.128B
llvm.hexagon.V6.vprefixqb
llvm.hexagon.V6.vprefixqb.128B
llvm.hexagon.V6.vprefixqh
llvm.hexagon.V6.vprefixqh.128B
llvm.hexagon.V6.vprefixqw
llvm.hexagon.V6.vprefixqw.128B
llvm.hexagon.V6.vrdelta
llvm.hexagon.V6.vrdelta.128B
llvm.hexagon.V6.vrmpybub.rtt
llvm.hexagon.V6.vrmpybub.rtt.128B
llvm.hexagon.V6.vrmpybub.rtt.acc
llvm.hexagon.V6.vrmpybub.rtt.acc.128B
llvm.hexagon.V6.vrmpybus
llvm.hexagon.V6.vrmpybus.128B
llvm.hexagon.V6.vrmpybus.acc
llvm.hexagon.V6.vrmpybus.acc.128B
llvm.hexagon.V6.vrmpybusi
llvm.hexagon.V6.vrmpybusi.128B
llvm.hexagon.V6.vrmpybusi.acc
llvm.hexagon.V6.vrmpybusi.acc.128B
llvm.hexagon.V6.vrmpybusv
llvm.hexagon.V6.vrmpybusv.128B
llvm.hexagon.V6.vrmpybusv.acc
llvm.hexagon.V6.vrmpybusv.acc.128B
llvm.hexagon.V6.vrmpybv
llvm.hexagon.V6.vrmpybv.128B
llvm.hexagon.V6.vrmpybv.acc
llvm.hexagon.V6.vrmpybv.acc.128B
llvm.hexagon.V6.vrmpyub
llvm.hexagon.V6.vrmpyub.128B
llvm.hexagon.V6.vrmpyub.acc
llvm.hexagon.V6.vrmpyub.acc.128B
llvm.hexagon.V6.vrmpyub.rtt
llvm.hexagon.V6.vrmpyub.rtt.128B
llvm.hexagon.V6.vrmpyub.rtt.acc
llvm.hexagon.V6.vrmpyub.rtt.acc.128B
llvm.hexagon.V6.vrmpyubi
llvm.hexagon.V6.vrmpyubi.128B
llvm.hexagon.V6.vrmpyubi.acc
llvm.hexagon.V6.vrmpyubi.acc.128B
llvm.hexagon.V6.vrmpyubv
llvm.hexagon.V6.vrmpyubv.128B
llvm.hexagon.V6.vrmpyubv.acc
llvm.hexagon.V6.vrmpyubv.acc.128B
llvm.hexagon.V6.vror
llvm.hexagon.V6.vror.128B
llvm.hexagon.V6.vroundhb
llvm.hexagon.V6.vroundhb.128B
llvm.hexagon.V6.vroundhub
llvm.hexagon.V6.vroundhub.128B
llvm.hexagon.V6.vrounduhub
llvm.hexagon.V6.vrounduhub.128B
llvm.hexagon.V6.vrounduwuh
llvm.hexagon.V6.vrounduwuh.128B
llvm.hexagon.V6.vroundwh
llvm.hexagon.V6.vroundwh.128B
llvm.hexagon.V6.vroundwuh
llvm.hexagon.V6.vroundwuh.128B
llvm.hexagon.V6.vrsadubi
llvm.hexagon.V6.vrsadubi.128B
llvm.hexagon.V6.vrsadubi.acc
llvm.hexagon.V6.vrsadubi.acc.128B
llvm.hexagon.V6.vsathub
llvm.hexagon.V6.vsathub.128B
llvm.hexagon.V6.vsatuwuh
llvm.hexagon.V6.vsatuwuh.128B
llvm.hexagon.V6.vsatwh
llvm.hexagon.V6.vsatwh.128B
llvm.hexagon.V6.vsb
llvm.hexagon.V6.vsb.128B
llvm.hexagon.V6.vscattermh
llvm.hexagon.V6.vscattermh.128B
llvm.hexagon.V6.vscattermh.add
llvm.hexagon.V6.vscattermh.add.128B
llvm.hexagon.V6.vscattermhq
llvm.hexagon.V6.vscattermhq.128B
llvm.hexagon.V6.vscattermhw
llvm.hexagon.V6.vscattermhw.128B
llvm.hexagon.V6.vscattermhw.add
llvm.hexagon.V6.vscattermhw.add.128B
llvm.hexagon.V6.vscattermhwq
llvm.hexagon.V6.vscattermhwq.128B
llvm.hexagon.V6.vscattermw
llvm.hexagon.V6.vscattermw.128B
llvm.hexagon.V6.vscattermw.add
llvm.hexagon.V6.vscattermw.add.128B
llvm.hexagon.V6.vscattermwq
llvm.hexagon.V6.vscattermwq.128B
llvm.hexagon.V6.vsh
llvm.hexagon.V6.vsh.128B
llvm.hexagon.V6.vshufeh
llvm.hexagon.V6.vshufeh.128B
llvm.hexagon.V6.vshuffb
llvm.hexagon.V6.vshuffb.128B
llvm.hexagon.V6.vshuffeb
llvm.hexagon.V6.vshuffeb.128B
llvm.hexagon.V6.vshuffh
llvm.hexagon.V6.vshuffh.128B
llvm.hexagon.V6.vshuffob
llvm.hexagon.V6.vshuffob.128B
llvm.hexagon.V6.vshuffvdd
llvm.hexagon.V6.vshuffvdd.128B
llvm.hexagon.V6.vshufoeb
llvm.hexagon.V6.vshufoeb.128B
llvm.hexagon.V6.vshufoeh
llvm.hexagon.V6.vshufoeh.128B
llvm.hexagon.V6.vshufoh
llvm.hexagon.V6.vshufoh.128B
llvm.hexagon.V6.vsubb
llvm.hexagon.V6.vsubb.128B
llvm.hexagon.V6.vsubb.dv
llvm.hexagon.V6.vsubb.dv.128B
llvm.hexagon.V6.vsubbnq
llvm.hexagon.V6.vsubbnq.128B
llvm.hexagon.V6.vsubbq
llvm.hexagon.V6.vsubbq.128B
llvm.hexagon.V6.vsubbsat
llvm.hexagon.V6.vsubbsat.128B
llvm.hexagon.V6.vsubbsat.dv
llvm.hexagon.V6.vsubbsat.dv.128B
llvm.hexagon.V6.vsubcarry
llvm.hexagon.V6.vsubcarry.128B
llvm.hexagon.V6.vsubh
llvm.hexagon.V6.vsubh.128B
llvm.hexagon.V6.vsubh.dv
llvm.hexagon.V6.vsubh.dv.128B
llvm.hexagon.V6.vsubhnq
llvm.hexagon.V6.vsubhnq.128B
llvm.hexagon.V6.vsubhq
llvm.hexagon.V6.vsubhq.128B
llvm.hexagon.V6.vsubhsat
llvm.hexagon.V6.vsubhsat.128B
llvm.hexagon.V6.vsubhsat.dv
llvm.hexagon.V6.vsubhsat.dv.128B
llvm.hexagon.V6.vsubhw
llvm.hexagon.V6.vsubhw.128B
llvm.hexagon.V6.vsububh
llvm.hexagon.V6.vsububh.128B
llvm.hexagon.V6.vsububsat
llvm.hexagon.V6.vsububsat.128B
llvm.hexagon.V6.vsububsat.dv
llvm.hexagon.V6.vsububsat.dv.128B
llvm.hexagon.V6.vsubububb.sat
llvm.hexagon.V6.vsubububb.sat.128B
llvm.hexagon.V6.vsubuhsat
llvm.hexagon.V6.vsubuhsat.128B
llvm.hexagon.V6.vsubuhsat.dv
llvm.hexagon.V6.vsubuhsat.dv.128B
llvm.hexagon.V6.vsubuhw
llvm.hexagon.V6.vsubuhw.128B
llvm.hexagon.V6.vsubuwsat
llvm.hexagon.V6.vsubuwsat.128B
llvm.hexagon.V6.vsubuwsat.dv
llvm.hexagon.V6.vsubuwsat.dv.128B
llvm.hexagon.V6.vsubw
llvm.hexagon.V6.vsubw.128B
llvm.hexagon.V6.vsubw.dv
llvm.hexagon.V6.vsubw.dv.128B
llvm.hexagon.V6.vsubwnq
llvm.hexagon.V6.vsubwnq.128B
llvm.hexagon.V6.vsubwq
llvm.hexagon.V6.vsubwq.128B
llvm.hexagon.V6.vsubwsat
llvm.hexagon.V6.vsubwsat.128B
llvm.hexagon.V6.vsubwsat.dv
llvm.hexagon.V6.vsubwsat.dv.128B
llvm.hexagon.V6.vswap
llvm.hexagon.V6.vswap.128B
llvm.hexagon.V6.vtmpyb
llvm.hexagon.V6.vtmpyb.128B
llvm.hexagon.V6.vtmpyb.acc
llvm.hexagon.V6.vtmpyb.acc.128B
llvm.hexagon.V6.vtmpybus
llvm.hexagon.V6.vtmpybus.128B
llvm.hexagon.V6.vtmpybus.acc
llvm.hexagon.V6.vtmpybus.acc.128B
llvm.hexagon.V6.vtmpyhb
llvm.hexagon.V6.vtmpyhb.128B
llvm.hexagon.V6.vtmpyhb.acc
llvm.hexagon.V6.vtmpyhb.acc.128B
llvm.hexagon.V6.vunpackb
llvm.hexagon.V6.vunpackb.128B
llvm.hexagon.V6.vunpackh
llvm.hexagon.V6.vunpackh.128B
llvm.hexagon.V6.vunpackob
llvm.hexagon.V6.vunpackob.128B
llvm.hexagon.V6.vunpackoh
llvm.hexagon.V6.vunpackoh.128B
llvm.hexagon.V6.vunpackub
llvm.hexagon.V6.vunpackub.128B
llvm.hexagon.V6.vunpackuh
llvm.hexagon.V6.vunpackuh.128B
llvm.hexagon.V6.vxor
llvm.hexagon.V6.vxor.128B
llvm.hexagon.V6.vzb
llvm.hexagon.V6.vzb.128B
llvm.hexagon.V6.vzh
llvm.hexagon.V6.vzh.128B
llvm.hexagon.Y2.dccleana
llvm.hexagon.Y2.dccleaninva
llvm.hexagon.Y2.dcinva
llvm.hexagon.Y2.dczeroa
llvm.hexagon.Y4.l2fetch
llvm.hexagon.Y5.l2fetch
llvm.hexagon.circ.ldb
llvm.hexagon.circ.ldd
llvm.hexagon.circ.ldh
llvm.hexagon.circ.ldub
llvm.hexagon.circ.lduh
llvm.hexagon.circ.ldw
llvm.hexagon.circ.stb
llvm.hexagon.circ.std
llvm.hexagon.circ.sth
llvm.hexagon.circ.sthhi
llvm.hexagon.circ.stw
llvm.hexagon.mm256i.vaddw
llvm.hexagon.prefetch
llvm.mips.absq.s.ph
llvm.mips.absq.s.qb
llvm.mips.absq.s.w
llvm.mips.add.a.b
llvm.mips.add.a.d
llvm.mips.add.a.h
llvm.mips.add.a.w
llvm.mips.addq.ph
llvm.mips.addq.s.ph
llvm.mips.addq.s.w
llvm.mips.addqh.ph
llvm.mips.addqh.r.ph
llvm.mips.addqh.r.w
llvm.mips.addqh.w
llvm.mips.adds.a.b
llvm.mips.adds.a.d
llvm.mips.adds.a.h
llvm.mips.adds.a.w
llvm.mips.adds.s.b
llvm.mips.adds.s.d
llvm.mips.adds.s.h
llvm.mips.adds.s.w
llvm.mips.adds.u.b
llvm.mips.adds.u.d
llvm.mips.adds.u.h
llvm.mips.adds.u.w
llvm.mips.addsc
llvm.mips.addu.ph
llvm.mips.addu.qb
llvm.mips.addu.s.ph
llvm.mips.addu.s.qb
llvm.mips.adduh.qb
llvm.mips.adduh.r.qb
llvm.mips.addv.b
llvm.mips.addv.d
llvm.mips.addv.h
llvm.mips.addv.w
llvm.mips.addvi.b
llvm.mips.addvi.d
llvm.mips.addvi.h
llvm.mips.addvi.w
llvm.mips.addwc
llvm.mips.and.v
llvm.mips.andi.b
llvm.mips.append
llvm.mips.asub.s.b
llvm.mips.asub.s.d
llvm.mips.asub.s.h
llvm.mips.asub.s.w
llvm.mips.asub.u.b
llvm.mips.asub.u.d
llvm.mips.asub.u.h
llvm.mips.asub.u.w
llvm.mips.ave.s.b
llvm.mips.ave.s.d
llvm.mips.ave.s.h
llvm.mips.ave.s.w
llvm.mips.ave.u.b
llvm.mips.ave.u.d
llvm.mips.ave.u.h
llvm.mips.ave.u.w
llvm.mips.aver.s.b
llvm.mips.aver.s.d
llvm.mips.aver.s.h
llvm.mips.aver.s.w
llvm.mips.aver.u.b
llvm.mips.aver.u.d
llvm.mips.aver.u.h
llvm.mips.aver.u.w
llvm.mips.balign
llvm.mips.bclr.b
llvm.mips.bclr.d
llvm.mips.bclr.h
llvm.mips.bclr.w
llvm.mips.bclri.b
llvm.mips.bclri.d
llvm.mips.bclri.h
llvm.mips.bclri.w
llvm.mips.binsl.b
llvm.mips.binsl.d
llvm.mips.binsl.h
llvm.mips.binsl.w
llvm.mips.binsli.b
llvm.mips.binsli.d
llvm.mips.binsli.h
llvm.mips.binsli.w
llvm.mips.binsr.b
llvm.mips.binsr.d
llvm.mips.binsr.h
llvm.mips.binsr.w
llvm.mips.binsri.b
llvm.mips.binsri.d
llvm.mips.binsri.h
llvm.mips.binsri.w
llvm.mips.bitrev
llvm.mips.bmnz.v
llvm.mips.bmnzi.b
llvm.mips.bmz.v
llvm.mips.bmzi.b
llvm.mips.bneg.b
llvm.mips.bneg.d
llvm.mips.bneg.h
llvm.mips.bneg.w
llvm.mips.bnegi.b
llvm.mips.bnegi.d
llvm.mips.bnegi.h
llvm.mips.bnegi.w
llvm.mips.bnz.b
llvm.mips.bnz.d
llvm.mips.bnz.h
llvm.mips.bnz.v
llvm.mips.bnz.w
llvm.mips.bposge32
llvm.mips.bsel.v
llvm.mips.bseli.b
llvm.mips.bset.b
llvm.mips.bset.d
llvm.mips.bset.h
llvm.mips.bset.w
llvm.mips.bseti.b
llvm.mips.bseti.d
llvm.mips.bseti.h
llvm.mips.bseti.w
llvm.mips.bz.b
llvm.mips.bz.d
llvm.mips.bz.h
llvm.mips.bz.v
llvm.mips.bz.w
llvm.mips.ceq.b
llvm.mips.ceq.d
llvm.mips.ceq.h
llvm.mips.ceq.w
llvm.mips.ceqi.b
llvm.mips.ceqi.d
llvm.mips.ceqi.h
llvm.mips.ceqi.w
llvm.mips.cfcmsa
llvm.mips.cle.s.b
llvm.mips.cle.s.d
llvm.mips.cle.s.h
llvm.mips.cle.s.w
llvm.mips.cle.u.b
llvm.mips.cle.u.d
llvm.mips.cle.u.h
llvm.mips.cle.u.w
llvm.mips.clei.s.b
llvm.mips.clei.s.d
llvm.mips.clei.s.h
llvm.mips.clei.s.w
llvm.mips.clei.u.b
llvm.mips.clei.u.d
llvm.mips.clei.u.h
llvm.mips.clei.u.w
llvm.mips.clt.s.b
llvm.mips.clt.s.d
llvm.mips.clt.s.h
llvm.mips.clt.s.w
llvm.mips.clt.u.b
llvm.mips.clt.u.d
llvm.mips.clt.u.h
llvm.mips.clt.u.w
llvm.mips.clti.s.b
llvm.mips.clti.s.d
llvm.mips.clti.s.h
llvm.mips.clti.s.w
llvm.mips.clti.u.b
llvm.mips.clti.u.d
llvm.mips.clti.u.h
llvm.mips.clti.u.w
llvm.mips.cmp.eq.ph
llvm.mips.cmp.le.ph
llvm.mips.cmp.lt.ph
llvm.mips.cmpgdu.eq.qb
llvm.mips.cmpgdu.le.qb
llvm.mips.cmpgdu.lt.qb
llvm.mips.cmpgu.eq.qb
llvm.mips.cmpgu.le.qb
llvm.mips.cmpgu.lt.qb
llvm.mips.cmpu.eq.qb
llvm.mips.cmpu.le.qb
llvm.mips.cmpu.lt.qb
llvm.mips.copy.s.b
llvm.mips.copy.s.d
llvm.mips.copy.s.h
llvm.mips.copy.s.w
llvm.mips.copy.u.b
llvm.mips.copy.u.d
llvm.mips.copy.u.h
llvm.mips.copy.u.w
llvm.mips.ctcmsa
llvm.mips.div.s.b
llvm.mips.div.s.d
llvm.mips.div.s.h
llvm.mips.div.s.w
llvm.mips.div.u.b
llvm.mips.div.u.d
llvm.mips.div.u.h
llvm.mips.div.u.w
llvm.mips.dlsa
llvm.mips.dotp.s.d
llvm.mips.dotp.s.h
llvm.mips.dotp.s.w
llvm.mips.dotp.u.d
llvm.mips.dotp.u.h
llvm.mips.dotp.u.w
llvm.mips.dpa.w.ph
llvm.mips.dpadd.s.d
llvm.mips.dpadd.s.h
llvm.mips.dpadd.s.w
llvm.mips.dpadd.u.d
llvm.mips.dpadd.u.h
llvm.mips.dpadd.u.w
llvm.mips.dpaq.s.w.ph
llvm.mips.dpaq.sa.l.w
llvm.mips.dpaqx.s.w.ph
llvm.mips.dpaqx.sa.w.ph
llvm.mips.dpau.h.qbl
llvm.mips.dpau.h.qbr
llvm.mips.dpax.w.ph
llvm.mips.dps.w.ph
llvm.mips.dpsq.s.w.ph
llvm.mips.dpsq.sa.l.w
llvm.mips.dpsqx.s.w.ph
llvm.mips.dpsqx.sa.w.ph
llvm.mips.dpsu.h.qbl
llvm.mips.dpsu.h.qbr
llvm.mips.dpsub.s.d
llvm.mips.dpsub.s.h
llvm.mips.dpsub.s.w
llvm.mips.dpsub.u.d
llvm.mips.dpsub.u.h
llvm.mips.dpsub.u.w
llvm.mips.dpsx.w.ph
llvm.mips.extp
llvm.mips.extpdp
llvm.mips.extr.r.w
llvm.mips.extr.rs.w
llvm.mips.extr.s.h
llvm.mips.extr.w
llvm.mips.fadd.d
llvm.mips.fadd.w
llvm.mips.fcaf.d
llvm.mips.fcaf.w
llvm.mips.fceq.d
llvm.mips.fceq.w
llvm.mips.fclass.d
llvm.mips.fclass.w
llvm.mips.fcle.d
llvm.mips.fcle.w
llvm.mips.fclt.d
llvm.mips.fclt.w
llvm.mips.fcne.d
llvm.mips.fcne.w
llvm.mips.fcor.d
llvm.mips.fcor.w
llvm.mips.fcueq.d
llvm.mips.fcueq.w
llvm.mips.fcule.d
llvm.mips.fcule.w
llvm.mips.fcult.d
llvm.mips.fcult.w
llvm.mips.fcun.d
llvm.mips.fcun.w
llvm.mips.fcune.d
llvm.mips.fcune.w
llvm.mips.fdiv.d
llvm.mips.fdiv.w
llvm.mips.fexdo.h
llvm.mips.fexdo.w
llvm.mips.fexp2.d
llvm.mips.fexp2.w
llvm.mips.fexupl.d
llvm.mips.fexupl.w
llvm.mips.fexupr.d
llvm.mips.fexupr.w
llvm.mips.ffint.s.d
llvm.mips.ffint.s.w
llvm.mips.ffint.u.d
llvm.mips.ffint.u.w
llvm.mips.ffql.d
llvm.mips.ffql.w
llvm.mips.ffqr.d
llvm.mips.ffqr.w
llvm.mips.fill.b
llvm.mips.fill.d
llvm.mips.fill.h
llvm.mips.fill.w
llvm.mips.flog2.d
llvm.mips.flog2.w
llvm.mips.fmadd.d
llvm.mips.fmadd.w
llvm.mips.fmax.a.d
llvm.mips.fmax.a.w
llvm.mips.fmax.d
llvm.mips.fmax.w
llvm.mips.fmin.a.d
llvm.mips.fmin.a.w
llvm.mips.fmin.d
llvm.mips.fmin.w
llvm.mips.fmsub.d
llvm.mips.fmsub.w
llvm.mips.fmul.d
llvm.mips.fmul.w
llvm.mips.frcp.d
llvm.mips.frcp.w
llvm.mips.frint.d
llvm.mips.frint.w
llvm.mips.frsqrt.d
llvm.mips.frsqrt.w
llvm.mips.fsaf.d
llvm.mips.fsaf.w
llvm.mips.fseq.d
llvm.mips.fseq.w
llvm.mips.fsle.d
llvm.mips.fsle.w
llvm.mips.fslt.d
llvm.mips.fslt.w
llvm.mips.fsne.d
llvm.mips.fsne.w
llvm.mips.fsor.d
llvm.mips.fsor.w
llvm.mips.fsqrt.d
llvm.mips.fsqrt.w
llvm.mips.fsub.d
llvm.mips.fsub.w
llvm.mips.fsueq.d
llvm.mips.fsueq.w
llvm.mips.fsule.d
llvm.mips.fsule.w
llvm.mips.fsult.d
llvm.mips.fsult.w
llvm.mips.fsun.d
llvm.mips.fsun.w
llvm.mips.fsune.d
llvm.mips.fsune.w
llvm.mips.ftint.s.d
llvm.mips.ftint.s.w
llvm.mips.ftint.u.d
llvm.mips.ftint.u.w
llvm.mips.ftq.h
llvm.mips.ftq.w
llvm.mips.ftrunc.s.d
llvm.mips.ftrunc.s.w
llvm.mips.ftrunc.u.d
llvm.mips.ftrunc.u.w
llvm.mips.hadd.s.d
llvm.mips.hadd.s.h
llvm.mips.hadd.s.w
llvm.mips.hadd.u.d
llvm.mips.hadd.u.h
llvm.mips.hadd.u.w
llvm.mips.hsub.s.d
llvm.mips.hsub.s.h
llvm.mips.hsub.s.w
llvm.mips.hsub.u.d
llvm.mips.hsub.u.h
llvm.mips.hsub.u.w
llvm.mips.ilvev.b
llvm.mips.ilvev.d
llvm.mips.ilvev.h
llvm.mips.ilvev.w
llvm.mips.ilvl.b
llvm.mips.ilvl.d
llvm.mips.ilvl.h
llvm.mips.ilvl.w
llvm.mips.ilvod.b
llvm.mips.ilvod.d
llvm.mips.ilvod.h
llvm.mips.ilvod.w
llvm.mips.ilvr.b
llvm.mips.ilvr.d
llvm.mips.ilvr.h
llvm.mips.ilvr.w
llvm.mips.insert.b
llvm.mips.insert.d
llvm.mips.insert.h
llvm.mips.insert.w
llvm.mips.insv
llvm.mips.insve.b
llvm.mips.insve.d
llvm.mips.insve.h
llvm.mips.insve.w
llvm.mips.lbux
llvm.mips.ld.b
llvm.mips.ld.d
llvm.mips.ld.h
llvm.mips.ld.w
llvm.mips.ldi.b
llvm.mips.ldi.d
llvm.mips.ldi.h
llvm.mips.ldi.w
llvm.mips.lhx
llvm.mips.lsa
llvm.mips.lwx
llvm.mips.madd
llvm.mips.madd.q.h
llvm.mips.madd.q.w
llvm.mips.maddr.q.h
llvm.mips.maddr.q.w
llvm.mips.maddu
llvm.mips.maddv.b
llvm.mips.maddv.d
llvm.mips.maddv.h
llvm.mips.maddv.w
llvm.mips.maq.s.w.phl
llvm.mips.maq.s.w.phr
llvm.mips.maq.sa.w.phl
llvm.mips.maq.sa.w.phr
llvm.mips.max.a.b
llvm.mips.max.a.d
llvm.mips.max.a.h
llvm.mips.max.a.w
llvm.mips.max.s.b
llvm.mips.max.s.d
llvm.mips.max.s.h
llvm.mips.max.s.w
llvm.mips.max.u.b
llvm.mips.max.u.d
llvm.mips.max.u.h
llvm.mips.max.u.w
llvm.mips.maxi.s.b
llvm.mips.maxi.s.d
llvm.mips.maxi.s.h
llvm.mips.maxi.s.w
llvm.mips.maxi.u.b
llvm.mips.maxi.u.d
llvm.mips.maxi.u.h
llvm.mips.maxi.u.w
llvm.mips.min.a.b
llvm.mips.min.a.d
llvm.mips.min.a.h
llvm.mips.min.a.w
llvm.mips.min.s.b
llvm.mips.min.s.d
llvm.mips.min.s.h
llvm.mips.min.s.w
llvm.mips.min.u.b
llvm.mips.min.u.d
llvm.mips.min.u.h
llvm.mips.min.u.w
llvm.mips.mini.s.b
llvm.mips.mini.s.d
llvm.mips.mini.s.h
llvm.mips.mini.s.w
llvm.mips.mini.u.b
llvm.mips.mini.u.d
llvm.mips.mini.u.h
llvm.mips.mini.u.w
llvm.mips.mod.s.b
llvm.mips.mod.s.d
llvm.mips.mod.s.h
llvm.mips.mod.s.w
llvm.mips.mod.u.b
llvm.mips.mod.u.d
llvm.mips.mod.u.h
llvm.mips.mod.u.w
llvm.mips.modsub
llvm.mips.move.v
llvm.mips.msub
llvm.mips.msub.q.h
llvm.mips.msub.q.w
llvm.mips.msubr.q.h
llvm.mips.msubr.q.w
llvm.mips.msubu
llvm.mips.msubv.b
llvm.mips.msubv.d
llvm.mips.msubv.h
llvm.mips.msubv.w
llvm.mips.mthlip
llvm.mips.mul.ph
llvm.mips.mul.q.h
llvm.mips.mul.q.w
llvm.mips.mul.s.ph
llvm.mips.muleq.s.w.phl
llvm.mips.muleq.s.w.phr
llvm.mips.muleu.s.ph.qbl
llvm.mips.muleu.s.ph.qbr
llvm.mips.mulq.rs.ph
llvm.mips.mulq.rs.w
llvm.mips.mulq.s.ph
llvm.mips.mulq.s.w
llvm.mips.mulr.q.h
llvm.mips.mulr.q.w
llvm.mips.mulsa.w.ph
llvm.mips.mulsaq.s.w.ph
llvm.mips.mult
llvm.mips.multu
llvm.mips.mulv.b
llvm.mips.mulv.d
llvm.mips.mulv.h
llvm.mips.mulv.w
llvm.mips.nloc.b
llvm.mips.nloc.d
llvm.mips.nloc.h
llvm.mips.nloc.w
llvm.mips.nlzc.b
llvm.mips.nlzc.d
llvm.mips.nlzc.h
llvm.mips.nlzc.w
llvm.mips.nor.v
llvm.mips.nori.b
llvm.mips.or.v
llvm.mips.ori.b
llvm.mips.packrl.ph
llvm.mips.pckev.b
llvm.mips.pckev.d
llvm.mips.pckev.h
llvm.mips.pckev.w
llvm.mips.pckod.b
llvm.mips.pckod.d
llvm.mips.pckod.h
llvm.mips.pckod.w
llvm.mips.pcnt.b
llvm.mips.pcnt.d
llvm.mips.pcnt.h
llvm.mips.pcnt.w
llvm.mips.pick.ph
llvm.mips.pick.qb
llvm.mips.preceq.w.phl
llvm.mips.preceq.w.phr
llvm.mips.precequ.ph.qbl
llvm.mips.precequ.ph.qbla
llvm.mips.precequ.ph.qbr
llvm.mips.precequ.ph.qbra
llvm.mips.preceu.ph.qbl
llvm.mips.preceu.ph.qbla
llvm.mips.preceu.ph.qbr
llvm.mips.preceu.ph.qbra
llvm.mips.precr.qb.ph
llvm.mips.precr.sra.ph.w
llvm.mips.precr.sra.r.ph.w
llvm.mips.precrq.ph.w
llvm.mips.precrq.qb.ph
llvm.mips.precrq.rs.ph.w
llvm.mips.precrqu.s.qb.ph
llvm.mips.prepend
llvm.mips.raddu.w.qb
llvm.mips.rddsp
llvm.mips.repl.ph
llvm.mips.repl.qb
llvm.mips.sat.s.b
llvm.mips.sat.s.d
llvm.mips.sat.s.h
llvm.mips.sat.s.w
llvm.mips.sat.u.b
llvm.mips.sat.u.d
llvm.mips.sat.u.h
llvm.mips.sat.u.w
llvm.mips.shf.b
llvm.mips.shf.h
llvm.mips.shf.w
llvm.mips.shilo
llvm.mips.shll.ph
llvm.mips.shll.qb
llvm.mips.shll.s.ph
llvm.mips.shll.s.w
llvm.mips.shra.ph
llvm.mips.shra.qb
llvm.mips.shra.r.ph
llvm.mips.shra.r.qb
llvm.mips.shra.r.w
llvm.mips.shrl.ph
llvm.mips.shrl.qb
llvm.mips.sld.b
llvm.mips.sld.d
llvm.mips.sld.h
llvm.mips.sld.w
llvm.mips.sldi.b
llvm.mips.sldi.d
llvm.mips.sldi.h
llvm.mips.sldi.w
llvm.mips.sll.b
llvm.mips.sll.d
llvm.mips.sll.h
llvm.mips.sll.w
llvm.mips.slli.b
llvm.mips.slli.d
llvm.mips.slli.h
llvm.mips.slli.w
llvm.mips.splat.b
llvm.mips.splat.d
llvm.mips.splat.h
llvm.mips.splat.w
llvm.mips.splati.b
llvm.mips.splati.d
llvm.mips.splati.h
llvm.mips.splati.w
llvm.mips.sra.b
llvm.mips.sra.d
llvm.mips.sra.h
llvm.mips.sra.w
llvm.mips.srai.b
llvm.mips.srai.d
llvm.mips.srai.h
llvm.mips.srai.w
llvm.mips.srar.b
llvm.mips.srar.d
llvm.mips.srar.h
llvm.mips.srar.w
llvm.mips.srari.b
llvm.mips.srari.d
llvm.mips.srari.h
llvm.mips.srari.w
llvm.mips.srl.b
llvm.mips.srl.d
llvm.mips.srl.h
llvm.mips.srl.w
llvm.mips.srli.b
llvm.mips.srli.d
llvm.mips.srli.h
llvm.mips.srli.w
llvm.mips.srlr.b
llvm.mips.srlr.d
llvm.mips.srlr.h
llvm.mips.srlr.w
llvm.mips.srlri.b
llvm.mips.srlri.d
llvm.mips.srlri.h
llvm.mips.srlri.w
llvm.mips.st.b
llvm.mips.st.d
llvm.mips.st.h
llvm.mips.st.w
llvm.mips.subq.ph
llvm.mips.subq.s.ph
llvm.mips.subq.s.w
llvm.mips.subqh.ph
llvm.mips.subqh.r.ph
llvm.mips.subqh.r.w
llvm.mips.subqh.w
llvm.mips.subs.s.b
llvm.mips.subs.s.d
llvm.mips.subs.s.h
llvm.mips.subs.s.w
llvm.mips.subs.u.b
llvm.mips.subs.u.d
llvm.mips.subs.u.h
llvm.mips.subs.u.w
llvm.mips.subsus.u.b
llvm.mips.subsus.u.d
llvm.mips.subsus.u.h
llvm.mips.subsus.u.w
llvm.mips.subsuu.s.b
llvm.mips.subsuu.s.d
llvm.mips.subsuu.s.h
llvm.mips.subsuu.s.w
llvm.mips.subu.ph
llvm.mips.subu.qb
llvm.mips.subu.s.ph
llvm.mips.subu.s.qb
llvm.mips.subuh.qb
llvm.mips.subuh.r.qb
llvm.mips.subv.b
llvm.mips.subv.d
llvm.mips.subv.h
llvm.mips.subv.w
llvm.mips.subvi.b
llvm.mips.subvi.d
llvm.mips.subvi.h
llvm.mips.subvi.w
llvm.mips.vshf.b
llvm.mips.vshf.d
llvm.mips.vshf.h
llvm.mips.vshf.w
llvm.mips.wrdsp
llvm.mips.xor.v
llvm.mips.xori.b
llvm.nvvm.add.rm.d
llvm.nvvm.add.rm.f
llvm.nvvm.add.rm.ftz.f
llvm.nvvm.add.rn.d
llvm.nvvm.add.rn.f
llvm.nvvm.add.rn.ftz.f
llvm.nvvm.add.rp.d
llvm.nvvm.add.rp.f
llvm.nvvm.add.rp.ftz.f
llvm.nvvm.add.rz.d
llvm.nvvm.add.rz.f
llvm.nvvm.add.rz.ftz.f
llvm.nvvm.atomic.add.gen.f.cta
llvm.nvvm.atomic.add.gen.f.sys
llvm.nvvm.atomic.add.gen.i.cta
llvm.nvvm.atomic.add.gen.i.sys
llvm.nvvm.atomic.and.gen.i.cta
llvm.nvvm.atomic.and.gen.i.sys
llvm.nvvm.atomic.cas.gen.i.cta
llvm.nvvm.atomic.cas.gen.i.sys
llvm.nvvm.atomic.dec.gen.i.cta
llvm.nvvm.atomic.dec.gen.i.sys
llvm.nvvm.atomic.exch.gen.i.cta
llvm.nvvm.atomic.exch.gen.i.sys
llvm.nvvm.atomic.inc.gen.i.cta
llvm.nvvm.atomic.inc.gen.i.sys
llvm.nvvm.atomic.load.add.f32
llvm.nvvm.atomic.load.add.f64
llvm.nvvm.atomic.load.dec.32
llvm.nvvm.atomic.load.inc.32
llvm.nvvm.atomic.max.gen.i.cta
llvm.nvvm.atomic.max.gen.i.sys
llvm.nvvm.atomic.min.gen.i.cta
llvm.nvvm.atomic.min.gen.i.sys
llvm.nvvm.atomic.or.gen.i.cta
llvm.nvvm.atomic.or.gen.i.sys
llvm.nvvm.atomic.xor.gen.i.cta
llvm.nvvm.atomic.xor.gen.i.sys
llvm.nvvm.bar.sync
llvm.nvvm.bar.warp.sync
llvm.nvvm.barrier
llvm.nvvm.barrier.n
llvm.nvvm.barrier.sync
llvm.nvvm.barrier.sync.cnt
llvm.nvvm.barrier0
llvm.nvvm.barrier0.and
llvm.nvvm.barrier0.or
llvm.nvvm.barrier0.popc
llvm.nvvm.bitcast.d2ll
llvm.nvvm.bitcast.f2i
llvm.nvvm.bitcast.i2f
llvm.nvvm.bitcast.ll2d
llvm.nvvm.ceil.d
llvm.nvvm.ceil.f
llvm.nvvm.ceil.ftz.f
llvm.nvvm.compiler.error
llvm.nvvm.compiler.warn
llvm.nvvm.cos.approx.f
llvm.nvvm.cos.approx.ftz.f
llvm.nvvm.d2f.rm
llvm.nvvm.d2f.rm.ftz
llvm.nvvm.d2f.rn
llvm.nvvm.d2f.rn.ftz
llvm.nvvm.d2f.rp
llvm.nvvm.d2f.rp.ftz
llvm.nvvm.d2f.rz
llvm.nvvm.d2f.rz.ftz
llvm.nvvm.d2i.hi
llvm.nvvm.d2i.lo
llvm.nvvm.d2i.rm
llvm.nvvm.d2i.rn
llvm.nvvm.d2i.rp
llvm.nvvm.d2i.rz
llvm.nvvm.d2ll.rm
llvm.nvvm.d2ll.rn
llvm.nvvm.d2ll.rp
llvm.nvvm.d2ll.rz
llvm.nvvm.d2ui.rm
llvm.nvvm.d2ui.rn
llvm.nvvm.d2ui.rp
llvm.nvvm.d2ui.rz
llvm.nvvm.d2ull.rm
llvm.nvvm.d2ull.rn
llvm.nvvm.d2ull.rp
llvm.nvvm.d2ull.rz
llvm.nvvm.div.approx.f
llvm.nvvm.div.approx.ftz.f
llvm.nvvm.div.rm.d
llvm.nvvm.div.rm.f
llvm.nvvm.div.rm.ftz.f
llvm.nvvm.div.rn.d
llvm.nvvm.div.rn.f
llvm.nvvm.div.rn.ftz.f
llvm.nvvm.div.rp.d
llvm.nvvm.div.rp.f
llvm.nvvm.div.rp.ftz.f
llvm.nvvm.div.rz.d
llvm.nvvm.div.rz.f
llvm.nvvm.div.rz.ftz.f
llvm.nvvm.ex2.approx.d
llvm.nvvm.ex2.approx.f
llvm.nvvm.ex2.approx.ftz.f
llvm.nvvm.f2h.rn
llvm.nvvm.f2h.rn.ftz
llvm.nvvm.f2i.rm
llvm.nvvm.f2i.rm.ftz
llvm.nvvm.f2i.rn
llvm.nvvm.f2i.rn.ftz
llvm.nvvm.f2i.rp
llvm.nvvm.f2i.rp.ftz
llvm.nvvm.f2i.rz
llvm.nvvm.f2i.rz.ftz
llvm.nvvm.f2ll.rm
llvm.nvvm.f2ll.rm.ftz
llvm.nvvm.f2ll.rn
llvm.nvvm.f2ll.rn.ftz
llvm.nvvm.f2ll.rp
llvm.nvvm.f2ll.rp.ftz
llvm.nvvm.f2ll.rz
llvm.nvvm.f2ll.rz.ftz
llvm.nvvm.f2ui.rm
llvm.nvvm.f2ui.rm.ftz
llvm.nvvm.f2ui.rn
llvm.nvvm.f2ui.rn.ftz
llvm.nvvm.f2ui.rp
llvm.nvvm.f2ui.rp.ftz
llvm.nvvm.f2ui.rz
llvm.nvvm.f2ui.rz.ftz
llvm.nvvm.f2ull.rm
llvm.nvvm.f2ull.rm.ftz
llvm.nvvm.f2ull.rn
llvm.nvvm.f2ull.rn.ftz
llvm.nvvm.f2ull.rp
llvm.nvvm.f2ull.rp.ftz
llvm.nvvm.f2ull.rz
llvm.nvvm.f2ull.rz.ftz
llvm.nvvm.fabs.d
llvm.nvvm.fabs.f
llvm.nvvm.fabs.ftz.f
llvm.nvvm.floor.d
llvm.nvvm.floor.f
llvm.nvvm.floor.ftz.f
llvm.nvvm.fma.rm.d
llvm.nvvm.fma.rm.f
llvm.nvvm.fma.rm.ftz.f
llvm.nvvm.fma.rn.d
llvm.nvvm.fma.rn.f
llvm.nvvm.fma.rn.ftz.f
llvm.nvvm.fma.rp.d
llvm.nvvm.fma.rp.f
llvm.nvvm.fma.rp.ftz.f
llvm.nvvm.fma.rz.d
llvm.nvvm.fma.rz.f
llvm.nvvm.fma.rz.ftz.f
llvm.nvvm.fmax.d
llvm.nvvm.fmax.f
llvm.nvvm.fmax.ftz.f
llvm.nvvm.fmin.d
llvm.nvvm.fmin.f
llvm.nvvm.fmin.ftz.f
llvm.nvvm.fns
llvm.nvvm.i2d.rm
llvm.nvvm.i2d.rn
llvm.nvvm.i2d.rp
llvm.nvvm.i2d.rz
llvm.nvvm.i2f.rm
llvm.nvvm.i2f.rn
llvm.nvvm.i2f.rp
llvm.nvvm.i2f.rz
llvm.nvvm.isspacep.const
llvm.nvvm.isspacep.global
llvm.nvvm.isspacep.local
llvm.nvvm.isspacep.shared
llvm.nvvm.istypep.sampler
llvm.nvvm.istypep.surface
llvm.nvvm.istypep.texture
llvm.nvvm.ldg.global.f
llvm.nvvm.ldg.global.i
llvm.nvvm.ldg.global.p
llvm.nvvm.ldu.global.f
llvm.nvvm.ldu.global.i
llvm.nvvm.ldu.global.p
llvm.nvvm.lg2.approx.d
llvm.nvvm.lg2.approx.f
llvm.nvvm.lg2.approx.ftz.f
llvm.nvvm.ll2d.rm
llvm.nvvm.ll2d.rn
llvm.nvvm.ll2d.rp
llvm.nvvm.ll2d.rz
llvm.nvvm.ll2f.rm
llvm.nvvm.ll2f.rn
llvm.nvvm.ll2f.rp
llvm.nvvm.ll2f.rz
llvm.nvvm.lohi.i2d
llvm.nvvm.match.all.sync.i32p
llvm.nvvm.match.all.sync.i64p
llvm.nvvm.match.any.sync.i32
llvm.nvvm.match.any.sync.i64
llvm.nvvm.membar.cta
llvm.nvvm.membar.gl
llvm.nvvm.membar.sys
llvm.nvvm.move.double
llvm.nvvm.move.float
llvm.nvvm.move.i16
llvm.nvvm.move.i32
llvm.nvvm.move.i64
llvm.nvvm.move.ptr
llvm.nvvm.mul.rm.d
llvm.nvvm.mul.rm.f
llvm.nvvm.mul.rm.ftz.f
llvm.nvvm.mul.rn.d
llvm.nvvm.mul.rn.f
llvm.nvvm.mul.rn.ftz.f
llvm.nvvm.mul.rp.d
llvm.nvvm.mul.rp.f
llvm.nvvm.mul.rp.ftz.f
llvm.nvvm.mul.rz.d
llvm.nvvm.mul.rz.f
llvm.nvvm.mul.rz.ftz.f
llvm.nvvm.mul24.i
llvm.nvvm.mul24.ui
llvm.nvvm.mulhi.i
llvm.nvvm.mulhi.ll
llvm.nvvm.mulhi.ui
llvm.nvvm.mulhi.ull
llvm.nvvm.prmt
llvm.nvvm.ptr.constant.to.gen
llvm.nvvm.ptr.gen.to.constant
llvm.nvvm.ptr.gen.to.global
llvm.nvvm.ptr.gen.to.local
llvm.nvvm.ptr.gen.to.param
llvm.nvvm.ptr.gen.to.shared
llvm.nvvm.ptr.global.to.gen
llvm.nvvm.ptr.local.to.gen
llvm.nvvm.ptr.shared.to.gen
llvm.nvvm.rcp.approx.ftz.d
llvm.nvvm.rcp.rm.d
llvm.nvvm.rcp.rm.f
llvm.nvvm.rcp.rm.ftz.f
llvm.nvvm.rcp.rn.d
llvm.nvvm.rcp.rn.f
llvm.nvvm.rcp.rn.ftz.f
llvm.nvvm.rcp.rp.d
llvm.nvvm.rcp.rp.f
llvm.nvvm.rcp.rp.ftz.f
llvm.nvvm.rcp.rz.d
llvm.nvvm.rcp.rz.f
llvm.nvvm.rcp.rz.ftz.f
llvm.nvvm.read.ptx.sreg.clock
llvm.nvvm.read.ptx.sreg.clock64
llvm.nvvm.read.ptx.sreg.ctaid.w
llvm.nvvm.read.ptx.sreg.ctaid.x
llvm.nvvm.read.ptx.sreg.ctaid.y
llvm.nvvm.read.ptx.sreg.ctaid.z
llvm.nvvm.read.ptx.sreg.envreg0
llvm.nvvm.read.ptx.sreg.envreg1
llvm.nvvm.read.ptx.sreg.envreg10
llvm.nvvm.read.ptx.sreg.envreg11
llvm.nvvm.read.ptx.sreg.envreg12
llvm.nvvm.read.ptx.sreg.envreg13
llvm.nvvm.read.ptx.sreg.envreg14
llvm.nvvm.read.ptx.sreg.envreg15
llvm.nvvm.read.ptx.sreg.envreg16
llvm.nvvm.read.ptx.sreg.envreg17
llvm.nvvm.read.ptx.sreg.envreg18
llvm.nvvm.read.ptx.sreg.envreg19
llvm.nvvm.read.ptx.sreg.envreg2
llvm.nvvm.read.ptx.sreg.envreg20
llvm.nvvm.read.ptx.sreg.envreg21
llvm.nvvm.read.ptx.sreg.envreg22
llvm.nvvm.read.ptx.sreg.envreg23
llvm.nvvm.read.ptx.sreg.envreg24
llvm.nvvm.read.ptx.sreg.envreg25
llvm.nvvm.read.ptx.sreg.envreg26
llvm.nvvm.read.ptx.sreg.envreg27
llvm.nvvm.read.ptx.sreg.envreg28
llvm.nvvm.read.ptx.sreg.envreg29
llvm.nvvm.read.ptx.sreg.envreg3
llvm.nvvm.read.ptx.sreg.envreg30
llvm.nvvm.read.ptx.sreg.envreg31
llvm.nvvm.read.ptx.sreg.envreg4
llvm.nvvm.read.ptx.sreg.envreg5
llvm.nvvm.read.ptx.sreg.envreg6
llvm.nvvm.read.ptx.sreg.envreg7
llvm.nvvm.read.ptx.sreg.envreg8
llvm.nvvm.read.ptx.sreg.envreg9
llvm.nvvm.read.ptx.sreg.gridid
llvm.nvvm.read.ptx.sreg.laneid
llvm.nvvm.read.ptx.sreg.lanemask.eq
llvm.nvvm.read.ptx.sreg.lanemask.ge
llvm.nvvm.read.ptx.sreg.lanemask.gt
llvm.nvvm.read.ptx.sreg.lanemask.le
llvm.nvvm.read.ptx.sreg.lanemask.lt
llvm.nvvm.read.ptx.sreg.nctaid.w
llvm.nvvm.read.ptx.sreg.nctaid.x
llvm.nvvm.read.ptx.sreg.nctaid.y
llvm.nvvm.read.ptx.sreg.nctaid.z
llvm.nvvm.read.ptx.sreg.nsmid
llvm.nvvm.read.ptx.sreg.ntid.w
llvm.nvvm.read.ptx.sreg.ntid.x
llvm.nvvm.read.ptx.sreg.ntid.y
llvm.nvvm.read.ptx.sreg.ntid.z
llvm.nvvm.read.ptx.sreg.nwarpid
llvm.nvvm.read.ptx.sreg.pm0
llvm.nvvm.read.ptx.sreg.pm1
llvm.nvvm.read.ptx.sreg.pm2
llvm.nvvm.read.ptx.sreg.pm3
llvm.nvvm.read.ptx.sreg.smid
llvm.nvvm.read.ptx.sreg.tid.w
llvm.nvvm.read.ptx.sreg.tid.x
llvm.nvvm.read.ptx.sreg.tid.y
llvm.nvvm.read.ptx.sreg.tid.z
llvm.nvvm.read.ptx.sreg.warpid
llvm.nvvm.read.ptx.sreg.warpsize
llvm.nvvm.reflect
llvm.nvvm.rotate.b32
llvm.nvvm.rotate.b64
llvm.nvvm.rotate.right.b64
llvm.nvvm.round.d
llvm.nvvm.round.f
llvm.nvvm.round.ftz.f
llvm.nvvm.rsqrt.approx.d
llvm.nvvm.rsqrt.approx.f
llvm.nvvm.rsqrt.approx.ftz.f
llvm.nvvm.sad.i
llvm.nvvm.sad.ui
llvm.nvvm.saturate.d
llvm.nvvm.saturate.f
llvm.nvvm.saturate.ftz.f
llvm.nvvm.shfl.bfly.f32
llvm.nvvm.shfl.bfly.i32
llvm.nvvm.shfl.down.f32
llvm.nvvm.shfl.down.i32
llvm.nvvm.shfl.idx.f32
llvm.nvvm.shfl.idx.i32
llvm.nvvm.shfl.sync.bfly.f32
llvm.nvvm.shfl.sync.bfly.i32
llvm.nvvm.shfl.sync.down.f32
llvm.nvvm.shfl.sync.down.i32
llvm.nvvm.shfl.sync.idx.f32
llvm.nvvm.shfl.sync.idx.i32
llvm.nvvm.shfl.sync.up.f32
llvm.nvvm.shfl.sync.up.i32
llvm.nvvm.shfl.up.f32
llvm.nvvm.shfl.up.i32
llvm.nvvm.sin.approx.f
llvm.nvvm.sin.approx.ftz.f
llvm.nvvm.sqrt.approx.f
llvm.nvvm.sqrt.approx.ftz.f
llvm.nvvm.sqrt.f
llvm.nvvm.sqrt.rm.d
llvm.nvvm.sqrt.rm.f
llvm.nvvm.sqrt.rm.ftz.f
llvm.nvvm.sqrt.rn.d
llvm.nvvm.sqrt.rn.f
llvm.nvvm.sqrt.rn.ftz.f
llvm.nvvm.sqrt.rp.d
llvm.nvvm.sqrt.rp.f
llvm.nvvm.sqrt.rp.ftz.f
llvm.nvvm.sqrt.rz.d
llvm.nvvm.sqrt.rz.f
llvm.nvvm.sqrt.rz.ftz.f
llvm.nvvm.suld.1d.array.i16.clamp
llvm.nvvm.suld.1d.array.i16.trap
llvm.nvvm.suld.1d.array.i16.zero
llvm.nvvm.suld.1d.array.i32.clamp
llvm.nvvm.suld.1d.array.i32.trap
llvm.nvvm.suld.1d.array.i32.zero
llvm.nvvm.suld.1d.array.i64.clamp
llvm.nvvm.suld.1d.array.i64.trap
llvm.nvvm.suld.1d.array.i64.zero
llvm.nvvm.suld.1d.array.i8.clamp
llvm.nvvm.suld.1d.array.i8.trap
llvm.nvvm.suld.1d.array.i8.zero
llvm.nvvm.suld.1d.array.v2i16.clamp
llvm.nvvm.suld.1d.array.v2i16.trap
llvm.nvvm.suld.1d.array.v2i16.zero
llvm.nvvm.suld.1d.array.v2i32.clamp
llvm.nvvm.suld.1d.array.v2i32.trap
llvm.nvvm.suld.1d.array.v2i32.zero
llvm.nvvm.suld.1d.array.v2i64.clamp
llvm.nvvm.suld.1d.array.v2i64.trap
llvm.nvvm.suld.1d.array.v2i64.zero
llvm.nvvm.suld.1d.array.v2i8.clamp
llvm.nvvm.suld.1d.array.v2i8.trap
llvm.nvvm.suld.1d.array.v2i8.zero
llvm.nvvm.suld.1d.array.v4i16.clamp
llvm.nvvm.suld.1d.array.v4i16.trap
llvm.nvvm.suld.1d.array.v4i16.zero
llvm.nvvm.suld.1d.array.v4i32.clamp
llvm.nvvm.suld.1d.array.v4i32.trap
llvm.nvvm.suld.1d.array.v4i32.zero
llvm.nvvm.suld.1d.array.v4i8.clamp
llvm.nvvm.suld.1d.array.v4i8.trap
llvm.nvvm.suld.1d.array.v4i8.zero
llvm.nvvm.suld.1d.i16.clamp
llvm.nvvm.suld.1d.i16.trap
llvm.nvvm.suld.1d.i16.zero
llvm.nvvm.suld.1d.i32.clamp
llvm.nvvm.suld.1d.i32.trap
llvm.nvvm.suld.1d.i32.zero
llvm.nvvm.suld.1d.i64.clamp
llvm.nvvm.suld.1d.i64.trap
llvm.nvvm.suld.1d.i64.zero
llvm.nvvm.suld.1d.i8.clamp
llvm.nvvm.suld.1d.i8.trap
llvm.nvvm.suld.1d.i8.zero
llvm.nvvm.suld.1d.v2i16.clamp
llvm.nvvm.suld.1d.v2i16.trap
llvm.nvvm.suld.1d.v2i16.zero
llvm.nvvm.suld.1d.v2i32.clamp
llvm.nvvm.suld.1d.v2i32.trap
llvm.nvvm.suld.1d.v2i32.zero
llvm.nvvm.suld.1d.v2i64.clamp
llvm.nvvm.suld.1d.v2i64.trap
llvm.nvvm.suld.1d.v2i64.zero
llvm.nvvm.suld.1d.v2i8.clamp
llvm.nvvm.suld.1d.v2i8.trap
llvm.nvvm.suld.1d.v2i8.zero
llvm.nvvm.suld.1d.v4i16.clamp
llvm.nvvm.suld.1d.v4i16.trap
llvm.nvvm.suld.1d.v4i16.zero
llvm.nvvm.suld.1d.v4i32.clamp
llvm.nvvm.suld.1d.v4i32.trap
llvm.nvvm.suld.1d.v4i32.zero
llvm.nvvm.suld.1d.v4i8.clamp
llvm.nvvm.suld.1d.v4i8.trap
llvm.nvvm.suld.1d.v4i8.zero
llvm.nvvm.suld.2d.array.i16.clamp
llvm.nvvm.suld.2d.array.i16.trap
llvm.nvvm.suld.2d.array.i16.zero
llvm.nvvm.suld.2d.array.i32.clamp
llvm.nvvm.suld.2d.array.i32.trap
llvm.nvvm.suld.2d.array.i32.zero
llvm.nvvm.suld.2d.array.i64.clamp
llvm.nvvm.suld.2d.array.i64.trap
llvm.nvvm.suld.2d.array.i64.zero
llvm.nvvm.suld.2d.array.i8.clamp
llvm.nvvm.suld.2d.array.i8.trap
llvm.nvvm.suld.2d.array.i8.zero
llvm.nvvm.suld.2d.array.v2i16.clamp
llvm.nvvm.suld.2d.array.v2i16.trap
llvm.nvvm.suld.2d.array.v2i16.zero
llvm.nvvm.suld.2d.array.v2i32.clamp
llvm.nvvm.suld.2d.array.v2i32.trap
llvm.nvvm.suld.2d.array.v2i32.zero
llvm.nvvm.suld.2d.array.v2i64.clamp
llvm.nvvm.suld.2d.array.v2i64.trap
llvm.nvvm.suld.2d.array.v2i64.zero
llvm.nvvm.suld.2d.array.v2i8.clamp
llvm.nvvm.suld.2d.array.v2i8.trap
llvm.nvvm.suld.2d.array.v2i8.zero
llvm.nvvm.suld.2d.array.v4i16.clamp
llvm.nvvm.suld.2d.array.v4i16.trap
llvm.nvvm.suld.2d.array.v4i16.zero
llvm.nvvm.suld.2d.array.v4i32.clamp
llvm.nvvm.suld.2d.array.v4i32.trap
llvm.nvvm.suld.2d.array.v4i32.zero
llvm.nvvm.suld.2d.array.v4i8.clamp
llvm.nvvm.suld.2d.array.v4i8.trap
llvm.nvvm.suld.2d.array.v4i8.zero
llvm.nvvm.suld.2d.i16.clamp
llvm.nvvm.suld.2d.i16.trap
llvm.nvvm.suld.2d.i16.zero
llvm.nvvm.suld.2d.i32.clamp
llvm.nvvm.suld.2d.i32.trap
llvm.nvvm.suld.2d.i32.zero
llvm.nvvm.suld.2d.i64.clamp
llvm.nvvm.suld.2d.i64.trap
llvm.nvvm.suld.2d.i64.zero
llvm.nvvm.suld.2d.i8.clamp
llvm.nvvm.suld.2d.i8.trap
llvm.nvvm.suld.2d.i8.zero
llvm.nvvm.suld.2d.v2i16.clamp
llvm.nvvm.suld.2d.v2i16.trap
llvm.nvvm.suld.2d.v2i16.zero
llvm.nvvm.suld.2d.v2i32.clamp
llvm.nvvm.suld.2d.v2i32.trap
llvm.nvvm.suld.2d.v2i32.zero
llvm.nvvm.suld.2d.v2i64.clamp
llvm.nvvm.suld.2d.v2i64.trap
llvm.nvvm.suld.2d.v2i64.zero
llvm.nvvm.suld.2d.v2i8.clamp
llvm.nvvm.suld.2d.v2i8.trap
llvm.nvvm.suld.2d.v2i8.zero
llvm.nvvm.suld.2d.v4i16.clamp
llvm.nvvm.suld.2d.v4i16.trap
llvm.nvvm.suld.2d.v4i16.zero
llvm.nvvm.suld.2d.v4i32.clamp
llvm.nvvm.suld.2d.v4i32.trap
llvm.nvvm.suld.2d.v4i32.zero
llvm.nvvm.suld.2d.v4i8.clamp
llvm.nvvm.suld.2d.v4i8.trap
llvm.nvvm.suld.2d.v4i8.zero
llvm.nvvm.suld.3d.i16.clamp
llvm.nvvm.suld.3d.i16.trap
llvm.nvvm.suld.3d.i16.zero
llvm.nvvm.suld.3d.i32.clamp
llvm.nvvm.suld.3d.i32.trap
llvm.nvvm.suld.3d.i32.zero
llvm.nvvm.suld.3d.i64.clamp
llvm.nvvm.suld.3d.i64.trap
llvm.nvvm.suld.3d.i64.zero
llvm.nvvm.suld.3d.i8.clamp
llvm.nvvm.suld.3d.i8.trap
llvm.nvvm.suld.3d.i8.zero
llvm.nvvm.suld.3d.v2i16.clamp
llvm.nvvm.suld.3d.v2i16.trap
llvm.nvvm.suld.3d.v2i16.zero
llvm.nvvm.suld.3d.v2i32.clamp
llvm.nvvm.suld.3d.v2i32.trap
llvm.nvvm.suld.3d.v2i32.zero
llvm.nvvm.suld.3d.v2i64.clamp
llvm.nvvm.suld.3d.v2i64.trap
llvm.nvvm.suld.3d.v2i64.zero
llvm.nvvm.suld.3d.v2i8.clamp
llvm.nvvm.suld.3d.v2i8.trap
llvm.nvvm.suld.3d.v2i8.zero
llvm.nvvm.suld.3d.v4i16.clamp
llvm.nvvm.suld.3d.v4i16.trap
llvm.nvvm.suld.3d.v4i16.zero
llvm.nvvm.suld.3d.v4i32.clamp
llvm.nvvm.suld.3d.v4i32.trap
llvm.nvvm.suld.3d.v4i32.zero
llvm.nvvm.suld.3d.v4i8.clamp
llvm.nvvm.suld.3d.v4i8.trap
llvm.nvvm.suld.3d.v4i8.zero
llvm.nvvm.suq.array.size
llvm.nvvm.suq.channel.data.type
llvm.nvvm.suq.channel.order
llvm.nvvm.suq.depth
llvm.nvvm.suq.height
llvm.nvvm.suq.width
llvm.nvvm.sust.b.1d.array.i16.clamp
llvm.nvvm.sust.b.1d.array.i16.trap
llvm.nvvm.sust.b.1d.array.i16.zero
llvm.nvvm.sust.b.1d.array.i32.clamp
llvm.nvvm.sust.b.1d.array.i32.trap
llvm.nvvm.sust.b.1d.array.i32.zero
llvm.nvvm.sust.b.1d.array.i64.clamp
llvm.nvvm.sust.b.1d.array.i64.trap
llvm.nvvm.sust.b.1d.array.i64.zero
llvm.nvvm.sust.b.1d.array.i8.clamp
llvm.nvvm.sust.b.1d.array.i8.trap
llvm.nvvm.sust.b.1d.array.i8.zero
llvm.nvvm.sust.b.1d.array.v2i16.clamp
llvm.nvvm.sust.b.1d.array.v2i16.trap
llvm.nvvm.sust.b.1d.array.v2i16.zero
llvm.nvvm.sust.b.1d.array.v2i32.clamp
llvm.nvvm.sust.b.1d.array.v2i32.trap
llvm.nvvm.sust.b.1d.array.v2i32.zero
llvm.nvvm.sust.b.1d.array.v2i64.clamp
llvm.nvvm.sust.b.1d.array.v2i64.trap
llvm.nvvm.sust.b.1d.array.v2i64.zero
llvm.nvvm.sust.b.1d.array.v2i8.clamp
llvm.nvvm.sust.b.1d.array.v2i8.trap
llvm.nvvm.sust.b.1d.array.v2i8.zero
llvm.nvvm.sust.b.1d.array.v4i16.clamp
llvm.nvvm.sust.b.1d.array.v4i16.trap
llvm.nvvm.sust.b.1d.array.v4i16.zero
llvm.nvvm.sust.b.1d.array.v4i32.clamp
llvm.nvvm.sust.b.1d.array.v4i32.trap
llvm.nvvm.sust.b.1d.array.v4i32.zero
llvm.nvvm.sust.b.1d.array.v4i8.clamp
llvm.nvvm.sust.b.1d.array.v4i8.trap
llvm.nvvm.sust.b.1d.array.v4i8.zero
llvm.nvvm.sust.b.1d.i16.clamp
llvm.nvvm.sust.b.1d.i16.trap
llvm.nvvm.sust.b.1d.i16.zero
llvm.nvvm.sust.b.1d.i32.clamp
llvm.nvvm.sust.b.1d.i32.trap
llvm.nvvm.sust.b.1d.i32.zero
llvm.nvvm.sust.b.1d.i64.clamp
llvm.nvvm.sust.b.1d.i64.trap
llvm.nvvm.sust.b.1d.i64.zero
llvm.nvvm.sust.b.1d.i8.clamp
llvm.nvvm.sust.b.1d.i8.trap
llvm.nvvm.sust.b.1d.i8.zero
llvm.nvvm.sust.b.1d.v2i16.clamp
llvm.nvvm.sust.b.1d.v2i16.trap
llvm.nvvm.sust.b.1d.v2i16.zero
llvm.nvvm.sust.b.1d.v2i32.clamp
llvm.nvvm.sust.b.1d.v2i32.trap
llvm.nvvm.sust.b.1d.v2i32.zero
llvm.nvvm.sust.b.1d.v2i64.clamp
llvm.nvvm.sust.b.1d.v2i64.trap
llvm.nvvm.sust.b.1d.v2i64.zero
llvm.nvvm.sust.b.1d.v2i8.clamp
llvm.nvvm.sust.b.1d.v2i8.trap
llvm.nvvm.sust.b.1d.v2i8.zero
llvm.nvvm.sust.b.1d.v4i16.clamp
llvm.nvvm.sust.b.1d.v4i16.trap
llvm.nvvm.sust.b.1d.v4i16.zero
llvm.nvvm.sust.b.1d.v4i32.clamp
llvm.nvvm.sust.b.1d.v4i32.trap
llvm.nvvm.sust.b.1d.v4i32.zero
llvm.nvvm.sust.b.1d.v4i8.clamp
llvm.nvvm.sust.b.1d.v4i8.trap
llvm.nvvm.sust.b.1d.v4i8.zero
llvm.nvvm.sust.b.2d.array.i16.clamp
llvm.nvvm.sust.b.2d.array.i16.trap
llvm.nvvm.sust.b.2d.array.i16.zero
llvm.nvvm.sust.b.2d.array.i32.clamp
llvm.nvvm.sust.b.2d.array.i32.trap
llvm.nvvm.sust.b.2d.array.i32.zero
llvm.nvvm.sust.b.2d.array.i64.clamp
llvm.nvvm.sust.b.2d.array.i64.trap
llvm.nvvm.sust.b.2d.array.i64.zero
llvm.nvvm.sust.b.2d.array.i8.clamp
llvm.nvvm.sust.b.2d.array.i8.trap
llvm.nvvm.sust.b.2d.array.i8.zero
llvm.nvvm.sust.b.2d.array.v2i16.clamp
llvm.nvvm.sust.b.2d.array.v2i16.trap
llvm.nvvm.sust.b.2d.array.v2i16.zero
llvm.nvvm.sust.b.2d.array.v2i32.clamp
llvm.nvvm.sust.b.2d.array.v2i32.trap
llvm.nvvm.sust.b.2d.array.v2i32.zero
llvm.nvvm.sust.b.2d.array.v2i64.clamp
llvm.nvvm.sust.b.2d.array.v2i64.trap
llvm.nvvm.sust.b.2d.array.v2i64.zero
llvm.nvvm.sust.b.2d.array.v2i8.clamp
llvm.nvvm.sust.b.2d.array.v2i8.trap
llvm.nvvm.sust.b.2d.array.v2i8.zero
llvm.nvvm.sust.b.2d.array.v4i16.clamp
llvm.nvvm.sust.b.2d.array.v4i16.trap
llvm.nvvm.sust.b.2d.array.v4i16.zero
llvm.nvvm.sust.b.2d.array.v4i32.clamp
llvm.nvvm.sust.b.2d.array.v4i32.trap
llvm.nvvm.sust.b.2d.array.v4i32.zero
llvm.nvvm.sust.b.2d.array.v4i8.clamp
llvm.nvvm.sust.b.2d.array.v4i8.trap
llvm.nvvm.sust.b.2d.array.v4i8.zero
llvm.nvvm.sust.b.2d.i16.clamp
llvm.nvvm.sust.b.2d.i16.trap
llvm.nvvm.sust.b.2d.i16.zero
llvm.nvvm.sust.b.2d.i32.clamp
llvm.nvvm.sust.b.2d.i32.trap
llvm.nvvm.sust.b.2d.i32.zero
llvm.nvvm.sust.b.2d.i64.clamp
llvm.nvvm.sust.b.2d.i64.trap
llvm.nvvm.sust.b.2d.i64.zero
llvm.nvvm.sust.b.2d.i8.clamp
llvm.nvvm.sust.b.2d.i8.trap
llvm.nvvm.sust.b.2d.i8.zero
llvm.nvvm.sust.b.2d.v2i16.clamp
llvm.nvvm.sust.b.2d.v2i16.trap
llvm.nvvm.sust.b.2d.v2i16.zero
llvm.nvvm.sust.b.2d.v2i32.clamp
llvm.nvvm.sust.b.2d.v2i32.trap
llvm.nvvm.sust.b.2d.v2i32.zero
llvm.nvvm.sust.b.2d.v2i64.clamp
llvm.nvvm.sust.b.2d.v2i64.trap
llvm.nvvm.sust.b.2d.v2i64.zero
llvm.nvvm.sust.b.2d.v2i8.clamp
llvm.nvvm.sust.b.2d.v2i8.trap
llvm.nvvm.sust.b.2d.v2i8.zero
llvm.nvvm.sust.b.2d.v4i16.clamp
llvm.nvvm.sust.b.2d.v4i16.trap
llvm.nvvm.sust.b.2d.v4i16.zero
llvm.nvvm.sust.b.2d.v4i32.clamp
llvm.nvvm.sust.b.2d.v4i32.trap
llvm.nvvm.sust.b.2d.v4i32.zero
llvm.nvvm.sust.b.2d.v4i8.clamp
llvm.nvvm.sust.b.2d.v4i8.trap
llvm.nvvm.sust.b.2d.v4i8.zero
llvm.nvvm.sust.b.3d.i16.clamp
llvm.nvvm.sust.b.3d.i16.trap
llvm.nvvm.sust.b.3d.i16.zero
llvm.nvvm.sust.b.3d.i32.clamp
llvm.nvvm.sust.b.3d.i32.trap
llvm.nvvm.sust.b.3d.i32.zero
llvm.nvvm.sust.b.3d.i64.clamp
llvm.nvvm.sust.b.3d.i64.trap
llvm.nvvm.sust.b.3d.i64.zero
llvm.nvvm.sust.b.3d.i8.clamp
llvm.nvvm.sust.b.3d.i8.trap
llvm.nvvm.sust.b.3d.i8.zero
llvm.nvvm.sust.b.3d.v2i16.clamp
llvm.nvvm.sust.b.3d.v2i16.trap
llvm.nvvm.sust.b.3d.v2i16.zero
llvm.nvvm.sust.b.3d.v2i32.clamp
llvm.nvvm.sust.b.3d.v2i32.trap
llvm.nvvm.sust.b.3d.v2i32.zero
llvm.nvvm.sust.b.3d.v2i64.clamp
llvm.nvvm.sust.b.3d.v2i64.trap
llvm.nvvm.sust.b.3d.v2i64.zero
llvm.nvvm.sust.b.3d.v2i8.clamp
llvm.nvvm.sust.b.3d.v2i8.trap
llvm.nvvm.sust.b.3d.v2i8.zero
llvm.nvvm.sust.b.3d.v4i16.clamp
llvm.nvvm.sust.b.3d.v4i16.trap
llvm.nvvm.sust.b.3d.v4i16.zero
llvm.nvvm.sust.b.3d.v4i32.clamp
llvm.nvvm.sust.b.3d.v4i32.trap
llvm.nvvm.sust.b.3d.v4i32.zero
llvm.nvvm.sust.b.3d.v4i8.clamp
llvm.nvvm.sust.b.3d.v4i8.trap
llvm.nvvm.sust.b.3d.v4i8.zero
llvm.nvvm.sust.p.1d.array.i16.trap
llvm.nvvm.sust.p.1d.array.i32.trap
llvm.nvvm.sust.p.1d.array.i8.trap
llvm.nvvm.sust.p.1d.array.v2i16.trap
llvm.nvvm.sust.p.1d.array.v2i32.trap
llvm.nvvm.sust.p.1d.array.v2i8.trap
llvm.nvvm.sust.p.1d.array.v4i16.trap
llvm.nvvm.sust.p.1d.array.v4i32.trap
llvm.nvvm.sust.p.1d.array.v4i8.trap
llvm.nvvm.sust.p.1d.i16.trap
llvm.nvvm.sust.p.1d.i32.trap
llvm.nvvm.sust.p.1d.i8.trap
llvm.nvvm.sust.p.1d.v2i16.trap
llvm.nvvm.sust.p.1d.v2i32.trap
llvm.nvvm.sust.p.1d.v2i8.trap
llvm.nvvm.sust.p.1d.v4i16.trap
llvm.nvvm.sust.p.1d.v4i32.trap
llvm.nvvm.sust.p.1d.v4i8.trap
llvm.nvvm.sust.p.2d.array.i16.trap
llvm.nvvm.sust.p.2d.array.i32.trap
llvm.nvvm.sust.p.2d.array.i8.trap
llvm.nvvm.sust.p.2d.array.v2i16.trap
llvm.nvvm.sust.p.2d.array.v2i32.trap
llvm.nvvm.sust.p.2d.array.v2i8.trap
llvm.nvvm.sust.p.2d.array.v4i16.trap
llvm.nvvm.sust.p.2d.array.v4i32.trap
llvm.nvvm.sust.p.2d.array.v4i8.trap
llvm.nvvm.sust.p.2d.i16.trap
llvm.nvvm.sust.p.2d.i32.trap
llvm.nvvm.sust.p.2d.i8.trap
llvm.nvvm.sust.p.2d.v2i16.trap
llvm.nvvm.sust.p.2d.v2i32.trap
llvm.nvvm.sust.p.2d.v2i8.trap
llvm.nvvm.sust.p.2d.v4i16.trap
llvm.nvvm.sust.p.2d.v4i32.trap
llvm.nvvm.sust.p.2d.v4i8.trap
llvm.nvvm.sust.p.3d.i16.trap
llvm.nvvm.sust.p.3d.i32.trap
llvm.nvvm.sust.p.3d.i8.trap
llvm.nvvm.sust.p.3d.v2i16.trap
llvm.nvvm.sust.p.3d.v2i32.trap
llvm.nvvm.sust.p.3d.v2i8.trap
llvm.nvvm.sust.p.3d.v4i16.trap
llvm.nvvm.sust.p.3d.v4i32.trap
llvm.nvvm.sust.p.3d.v4i8.trap
llvm.nvvm.swap.lo.hi.b64
llvm.nvvm.tex.1d.array.grad.v4f32.f32
llvm.nvvm.tex.1d.array.grad.v4s32.f32
llvm.nvvm.tex.1d.array.grad.v4u32.f32
llvm.nvvm.tex.1d.array.level.v4f32.f32
llvm.nvvm.tex.1d.array.level.v4s32.f32
llvm.nvvm.tex.1d.array.level.v4u32.f32
llvm.nvvm.tex.1d.array.v4f32.f32
llvm.nvvm.tex.1d.array.v4f32.s32
llvm.nvvm.tex.1d.array.v4s32.f32
llvm.nvvm.tex.1d.array.v4s32.s32
llvm.nvvm.tex.1d.array.v4u32.f32
llvm.nvvm.tex.1d.array.v4u32.s32
llvm.nvvm.tex.1d.grad.v4f32.f32
llvm.nvvm.tex.1d.grad.v4s32.f32
llvm.nvvm.tex.1d.grad.v4u32.f32
llvm.nvvm.tex.1d.level.v4f32.f32
llvm.nvvm.tex.1d.level.v4s32.f32
llvm.nvvm.tex.1d.level.v4u32.f32
llvm.nvvm.tex.1d.v4f32.f32
llvm.nvvm.tex.1d.v4f32.s32
llvm.nvvm.tex.1d.v4s32.f32
llvm.nvvm.tex.1d.v4s32.s32
llvm.nvvm.tex.1d.v4u32.f32
llvm.nvvm.tex.1d.v4u32.s32
llvm.nvvm.tex.2d.array.grad.v4f32.f32
llvm.nvvm.tex.2d.array.grad.v4s32.f32
llvm.nvvm.tex.2d.array.grad.v4u32.f32
llvm.nvvm.tex.2d.array.level.v4f32.f32
llvm.nvvm.tex.2d.array.level.v4s32.f32
llvm.nvvm.tex.2d.array.level.v4u32.f32
llvm.nvvm.tex.2d.array.v4f32.f32
llvm.nvvm.tex.2d.array.v4f32.s32
llvm.nvvm.tex.2d.array.v4s32.f32
llvm.nvvm.tex.2d.array.v4s32.s32
llvm.nvvm.tex.2d.array.v4u32.f32
llvm.nvvm.tex.2d.array.v4u32.s32
llvm.nvvm.tex.2d.grad.v4f32.f32
llvm.nvvm.tex.2d.grad.v4s32.f32
llvm.nvvm.tex.2d.grad.v4u32.f32
llvm.nvvm.tex.2d.level.v4f32.f32
llvm.nvvm.tex.2d.level.v4s32.f32
llvm.nvvm.tex.2d.level.v4u32.f32
llvm.nvvm.tex.2d.v4f32.f32
llvm.nvvm.tex.2d.v4f32.s32
llvm.nvvm.tex.2d.v4s32.f32
llvm.nvvm.tex.2d.v4s32.s32
llvm.nvvm.tex.2d.v4u32.f32
llvm.nvvm.tex.2d.v4u32.s32
llvm.nvvm.tex.3d.grad.v4f32.f32
llvm.nvvm.tex.3d.grad.v4s32.f32
llvm.nvvm.tex.3d.grad.v4u32.f32
llvm.nvvm.tex.3d.level.v4f32.f32
llvm.nvvm.tex.3d.level.v4s32.f32
llvm.nvvm.tex.3d.level.v4u32.f32
llvm.nvvm.tex.3d.v4f32.f32
llvm.nvvm.tex.3d.v4f32.s32
llvm.nvvm.tex.3d.v4s32.f32
llvm.nvvm.tex.3d.v4s32.s32
llvm.nvvm.tex.3d.v4u32.f32
llvm.nvvm.tex.3d.v4u32.s32
llvm.nvvm.tex.cube.array.level.v4f32.f32
llvm.nvvm.tex.cube.array.level.v4s32.f32
llvm.nvvm.tex.cube.array.level.v4u32.f32
llvm.nvvm.tex.cube.array.v4f32.f32
llvm.nvvm.tex.cube.array.v4s32.f32
llvm.nvvm.tex.cube.array.v4u32.f32
llvm.nvvm.tex.cube.level.v4f32.f32
llvm.nvvm.tex.cube.level.v4s32.f32
llvm.nvvm.tex.cube.level.v4u32.f32
llvm.nvvm.tex.cube.v4f32.f32
llvm.nvvm.tex.cube.v4s32.f32
llvm.nvvm.tex.cube.v4u32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4f32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4s32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4u32.f32
llvm.nvvm.tex.unified.1d.array.level.v4f32.f32
llvm.nvvm.tex.unified.1d.array.level.v4s32.f32
llvm.nvvm.tex.unified.1d.array.level.v4u32.f32
llvm.nvvm.tex.unified.1d.array.v4f32.f32
llvm.nvvm.tex.unified.1d.array.v4f32.s32
llvm.nvvm.tex.unified.1d.array.v4s32.f32
llvm.nvvm.tex.unified.1d.array.v4s32.s32
llvm.nvvm.tex.unified.1d.array.v4u32.f32
llvm.nvvm.tex.unified.1d.array.v4u32.s32
llvm.nvvm.tex.unified.1d.grad.v4f32.f32
llvm.nvvm.tex.unified.1d.grad.v4s32.f32
llvm.nvvm.tex.unified.1d.grad.v4u32.f32
llvm.nvvm.tex.unified.1d.level.v4f32.f32
llvm.nvvm.tex.unified.1d.level.v4s32.f32
llvm.nvvm.tex.unified.1d.level.v4u32.f32
llvm.nvvm.tex.unified.1d.v4f32.f32
llvm.nvvm.tex.unified.1d.v4f32.s32
llvm.nvvm.tex.unified.1d.v4s32.f32
llvm.nvvm.tex.unified.1d.v4s32.s32
llvm.nvvm.tex.unified.1d.v4u32.f32
llvm.nvvm.tex.unified.1d.v4u32.s32
llvm.nvvm.tex.unified.2d.array.grad.v4f32.f32
llvm.nvvm.tex.unified.2d.array.grad.v4s32.f32
llvm.nvvm.tex.unified.2d.array.grad.v4u32.f32
llvm.nvvm.tex.unified.2d.array.level.v4f32.f32
llvm.nvvm.tex.unified.2d.array.level.v4s32.f32
llvm.nvvm.tex.unified.2d.array.level.v4u32.f32
llvm.nvvm.tex.unified.2d.array.v4f32.f32
llvm.nvvm.tex.unified.2d.array.v4f32.s32
llvm.nvvm.tex.unified.2d.array.v4s32.f32
llvm.nvvm.tex.unified.2d.array.v4s32.s32
llvm.nvvm.tex.unified.2d.array.v4u32.f32
llvm.nvvm.tex.unified.2d.array.v4u32.s32
llvm.nvvm.tex.unified.2d.grad.v4f32.f32
llvm.nvvm.tex.unified.2d.grad.v4s32.f32
llvm.nvvm.tex.unified.2d.grad.v4u32.f32
llvm.nvvm.tex.unified.2d.level.v4f32.f32
llvm.nvvm.tex.unified.2d.level.v4s32.f32
llvm.nvvm.tex.unified.2d.level.v4u32.f32
llvm.nvvm.tex.unified.2d.v4f32.f32
llvm.nvvm.tex.unified.2d.v4f32.s32
llvm.nvvm.tex.unified.2d.v4s32.f32
llvm.nvvm.tex.unified.2d.v4s32.s32
llvm.nvvm.tex.unified.2d.v4u32.f32
llvm.nvvm.tex.unified.2d.v4u32.s32
llvm.nvvm.tex.unified.3d.grad.v4f32.f32
llvm.nvvm.tex.unified.3d.grad.v4s32.f32
llvm.nvvm.tex.unified.3d.grad.v4u32.f32
llvm.nvvm.tex.unified.3d.level.v4f32.f32
llvm.nvvm.tex.unified.3d.level.v4s32.f32
llvm.nvvm.tex.unified.3d.level.v4u32.f32
llvm.nvvm.tex.unified.3d.v4f32.f32
llvm.nvvm.tex.unified.3d.v4f32.s32
llvm.nvvm.tex.unified.3d.v4s32.f32
llvm.nvvm.tex.unified.3d.v4s32.s32
llvm.nvvm.tex.unified.3d.v4u32.f32
llvm.nvvm.tex.unified.3d.v4u32.s32
llvm.nvvm.tex.unified.cube.array.level.v4f32.f32
llvm.nvvm.tex.unified.cube.array.level.v4s32.f32
llvm.nvvm.tex.unified.cube.array.level.v4u32.f32
llvm.nvvm.tex.unified.cube.array.v4f32.f32
llvm.nvvm.tex.unified.cube.array.v4s32.f32
llvm.nvvm.tex.unified.cube.array.v4u32.f32
llvm.nvvm.tex.unified.cube.level.v4f32.f32
llvm.nvvm.tex.unified.cube.level.v4s32.f32
llvm.nvvm.tex.unified.cube.level.v4u32.f32
llvm.nvvm.tex.unified.cube.v4f32.f32
llvm.nvvm.tex.unified.cube.v4s32.f32
llvm.nvvm.tex.unified.cube.v4u32.f32
llvm.nvvm.texsurf.handle
llvm.nvvm.texsurf.handle.internal
llvm.nvvm.tld4.a.2d.v4f32.f32
llvm.nvvm.tld4.a.2d.v4s32.f32
llvm.nvvm.tld4.a.2d.v4u32.f32
llvm.nvvm.tld4.b.2d.v4f32.f32
llvm.nvvm.tld4.b.2d.v4s32.f32
llvm.nvvm.tld4.b.2d.v4u32.f32
llvm.nvvm.tld4.g.2d.v4f32.f32
llvm.nvvm.tld4.g.2d.v4s32.f32
llvm.nvvm.tld4.g.2d.v4u32.f32
llvm.nvvm.tld4.r.2d.v4f32.f32
llvm.nvvm.tld4.r.2d.v4s32.f32
llvm.nvvm.tld4.r.2d.v4u32.f32
llvm.nvvm.tld4.unified.a.2d.v4f32.f32
llvm.nvvm.tld4.unified.a.2d.v4s32.f32
llvm.nvvm.tld4.unified.a.2d.v4u32.f32
llvm.nvvm.tld4.unified.b.2d.v4f32.f32
llvm.nvvm.tld4.unified.b.2d.v4s32.f32
llvm.nvvm.tld4.unified.b.2d.v4u32.f32
llvm.nvvm.tld4.unified.g.2d.v4f32.f32
llvm.nvvm.tld4.unified.g.2d.v4s32.f32
llvm.nvvm.tld4.unified.g.2d.v4u32.f32
llvm.nvvm.tld4.unified.r.2d.v4f32.f32
llvm.nvvm.tld4.unified.r.2d.v4s32.f32
llvm.nvvm.tld4.unified.r.2d.v4u32.f32
llvm.nvvm.trunc.d
llvm.nvvm.trunc.f
llvm.nvvm.trunc.ftz.f
llvm.nvvm.txq.array.size
llvm.nvvm.txq.channel.data.type
llvm.nvvm.txq.channel.order
llvm.nvvm.txq.depth
llvm.nvvm.txq.height
llvm.nvvm.txq.num.mipmap.levels
llvm.nvvm.txq.num.samples
llvm.nvvm.txq.width
llvm.nvvm.ui2d.rm
llvm.nvvm.ui2d.rn
llvm.nvvm.ui2d.rp
llvm.nvvm.ui2d.rz
llvm.nvvm.ui2f.rm
llvm.nvvm.ui2f.rn
llvm.nvvm.ui2f.rp
llvm.nvvm.ui2f.rz
llvm.nvvm.ull2d.rm
llvm.nvvm.ull2d.rn
llvm.nvvm.ull2d.rp
llvm.nvvm.ull2d.rz
llvm.nvvm.ull2f.rm
llvm.nvvm.ull2f.rn
llvm.nvvm.ull2f.rp
llvm.nvvm.ull2f.rz
llvm.nvvm.vote.all
llvm.nvvm.vote.all.sync
llvm.nvvm.vote.any
llvm.nvvm.vote.any.sync
llvm.nvvm.vote.ballot
llvm.nvvm.vote.ballot.sync
llvm.nvvm.vote.uni
llvm.nvvm.vote.uni.sync
llvm.nvvm.wmma.m16n16k16.load.a.col.f16
llvm.nvvm.wmma.m16n16k16.load.a.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.a.row.f16
llvm.nvvm.wmma.m16n16k16.load.a.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.b.col.f16
llvm.nvvm.wmma.m16n16k16.load.b.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.b.row.f16
llvm.nvvm.wmma.m16n16k16.load.b.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.f32
llvm.nvvm.wmma.m16n16k16.load.c.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.stride.f32
llvm.nvvm.wmma.m16n16k16.load.c.row.f16
llvm.nvvm.wmma.m16n16k16.load.c.row.f32
llvm.nvvm.wmma.m16n16k16.load.c.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.row.stride.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.store.d.col.f16
llvm.nvvm.wmma.m16n16k16.store.d.col.f32
llvm.nvvm.wmma.m16n16k16.store.d.col.stride.f16
llvm.nvvm.wmma.m16n16k16.store.d.col.stride.f32
llvm.nvvm.wmma.m16n16k16.store.d.row.f16
llvm.nvvm.wmma.m16n16k16.store.d.row.f32
llvm.nvvm.wmma.m16n16k16.store.d.row.stride.f16
llvm.nvvm.wmma.m16n16k16.store.d.row.stride.f32
llvm.nvvm.wmma.m32n8k16.load.a.col.f16
llvm.nvvm.wmma.m32n8k16.load.a.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.a.row.f16
llvm.nvvm.wmma.m32n8k16.load.a.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.b.col.f16
llvm.nvvm.wmma.m32n8k16.load.b.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.b.row.f16
llvm.nvvm.wmma.m32n8k16.load.b.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.f32
llvm.nvvm.wmma.m32n8k16.load.c.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.stride.f32
llvm.nvvm.wmma.m32n8k16.load.c.row.f16
llvm.nvvm.wmma.m32n8k16.load.c.row.f32
llvm.nvvm.wmma.m32n8k16.load.c.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.row.stride.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.store.d.col.f16
llvm.nvvm.wmma.m32n8k16.store.d.col.f32
llvm.nvvm.wmma.m32n8k16.store.d.col.stride.f16
llvm.nvvm.wmma.m32n8k16.store.d.col.stride.f32
llvm.nvvm.wmma.m32n8k16.store.d.row.f16
llvm.nvvm.wmma.m32n8k16.store.d.row.f32
llvm.nvvm.wmma.m32n8k16.store.d.row.stride.f16
llvm.nvvm.wmma.m32n8k16.store.d.row.stride.f32
llvm.nvvm.wmma.m8n32k16.load.a.col.f16
llvm.nvvm.wmma.m8n32k16.load.a.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.a.row.f16
llvm.nvvm.wmma.m8n32k16.load.a.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.b.col.f16
llvm.nvvm.wmma.m8n32k16.load.b.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.b.row.f16
llvm.nvvm.wmma.m8n32k16.load.b.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.f32
llvm.nvvm.wmma.m8n32k16.load.c.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.stride.f32
llvm.nvvm.wmma.m8n32k16.load.c.row.f16
llvm.nvvm.wmma.m8n32k16.load.c.row.f32
llvm.nvvm.wmma.m8n32k16.load.c.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.row.stride.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.store.d.col.f16
llvm.nvvm.wmma.m8n32k16.store.d.col.f32
llvm.nvvm.wmma.m8n32k16.store.d.col.stride.f16
llvm.nvvm.wmma.m8n32k16.store.d.col.stride.f32
llvm.nvvm.wmma.m8n32k16.store.d.row.f16
llvm.nvvm.wmma.m8n32k16.store.d.row.f32
llvm.nvvm.wmma.m8n32k16.store.d.row.stride.f16
llvm.nvvm.wmma.m8n32k16.store.d.row.stride.f32
llvm.ppc.addf128.round.to.odd
llvm.ppc.altivec.crypto.vcipher
llvm.ppc.altivec.crypto.vcipherlast
llvm.ppc.altivec.crypto.vncipher
llvm.ppc.altivec.crypto.vncipherlast
llvm.ppc.altivec.crypto.vpermxor
llvm.ppc.altivec.crypto.vpmsumb
llvm.ppc.altivec.crypto.vpmsumd
llvm.ppc.altivec.crypto.vpmsumh
llvm.ppc.altivec.crypto.vpmsumw
llvm.ppc.altivec.crypto.vsbox
llvm.ppc.altivec.crypto.vshasigmad
llvm.ppc.altivec.crypto.vshasigmaw
llvm.ppc.altivec.dss
llvm.ppc.altivec.dssall
llvm.ppc.altivec.dst
llvm.ppc.altivec.dstst
llvm.ppc.altivec.dststt
llvm.ppc.altivec.dstt
llvm.ppc.altivec.lvebx
llvm.ppc.altivec.lvehx
llvm.ppc.altivec.lvewx
llvm.ppc.altivec.lvsl
llvm.ppc.altivec.lvsr
llvm.ppc.altivec.lvx
llvm.ppc.altivec.lvxl
llvm.ppc.altivec.mfvscr
llvm.ppc.altivec.mtvscr
llvm.ppc.altivec.stvebx
llvm.ppc.altivec.stvehx
llvm.ppc.altivec.stvewx
llvm.ppc.altivec.stvx
llvm.ppc.altivec.stvxl
llvm.ppc.altivec.vabsdub
llvm.ppc.altivec.vabsduh
llvm.ppc.altivec.vabsduw
llvm.ppc.altivec.vaddcuq
llvm.ppc.altivec.vaddcuw
llvm.ppc.altivec.vaddecuq
llvm.ppc.altivec.vaddeuqm
llvm.ppc.altivec.vaddsbs
llvm.ppc.altivec.vaddshs
llvm.ppc.altivec.vaddsws
llvm.ppc.altivec.vaddubs
llvm.ppc.altivec.vadduhs
llvm.ppc.altivec.vadduws
llvm.ppc.altivec.vavgsb
llvm.ppc.altivec.vavgsh
llvm.ppc.altivec.vavgsw
llvm.ppc.altivec.vavgub
llvm.ppc.altivec.vavguh
llvm.ppc.altivec.vavguw
llvm.ppc.altivec.vbpermq
llvm.ppc.altivec.vcfsx
llvm.ppc.altivec.vcfux
llvm.ppc.altivec.vclzlsbb
llvm.ppc.altivec.vcmpbfp
llvm.ppc.altivec.vcmpbfp.p
llvm.ppc.altivec.vcmpeqfp
llvm.ppc.altivec.vcmpeqfp.p
llvm.ppc.altivec.vcmpequb
llvm.ppc.altivec.vcmpequb.p
llvm.ppc.altivec.vcmpequd
llvm.ppc.altivec.vcmpequd.p
llvm.ppc.altivec.vcmpequh
llvm.ppc.altivec.vcmpequh.p
llvm.ppc.altivec.vcmpequw
llvm.ppc.altivec.vcmpequw.p
llvm.ppc.altivec.vcmpgefp
llvm.ppc.altivec.vcmpgefp.p
llvm.ppc.altivec.vcmpgtfp
llvm.ppc.altivec.vcmpgtfp.p
llvm.ppc.altivec.vcmpgtsb
llvm.ppc.altivec.vcmpgtsb.p
llvm.ppc.altivec.vcmpgtsd
llvm.ppc.altivec.vcmpgtsd.p
llvm.ppc.altivec.vcmpgtsh
llvm.ppc.altivec.vcmpgtsh.p
llvm.ppc.altivec.vcmpgtsw
llvm.ppc.altivec.vcmpgtsw.p
llvm.ppc.altivec.vcmpgtub
llvm.ppc.altivec.vcmpgtub.p
llvm.ppc.altivec.vcmpgtud
llvm.ppc.altivec.vcmpgtud.p
llvm.ppc.altivec.vcmpgtuh
llvm.ppc.altivec.vcmpgtuh.p
llvm.ppc.altivec.vcmpgtuw
llvm.ppc.altivec.vcmpgtuw.p
llvm.ppc.altivec.vcmpneb
llvm.ppc.altivec.vcmpneb.p
llvm.ppc.altivec.vcmpneh
llvm.ppc.altivec.vcmpneh.p
llvm.ppc.altivec.vcmpnew
llvm.ppc.altivec.vcmpnew.p
llvm.ppc.altivec.vcmpnezb
llvm.ppc.altivec.vcmpnezb.p
llvm.ppc.altivec.vcmpnezh
llvm.ppc.altivec.vcmpnezh.p
llvm.ppc.altivec.vcmpnezw
llvm.ppc.altivec.vcmpnezw.p
llvm.ppc.altivec.vctsxs
llvm.ppc.altivec.vctuxs
llvm.ppc.altivec.vctzlsbb
llvm.ppc.altivec.vexptefp
llvm.ppc.altivec.vgbbd
llvm.ppc.altivec.vlogefp
llvm.ppc.altivec.vmaddfp
llvm.ppc.altivec.vmaxfp
llvm.ppc.altivec.vmaxsb
llvm.ppc.altivec.vmaxsd
llvm.ppc.altivec.vmaxsh
llvm.ppc.altivec.vmaxsw
llvm.ppc.altivec.vmaxub
llvm.ppc.altivec.vmaxud
llvm.ppc.altivec.vmaxuh
llvm.ppc.altivec.vmaxuw
llvm.ppc.altivec.vmhaddshs
llvm.ppc.altivec.vmhraddshs
llvm.ppc.altivec.vminfp
llvm.ppc.altivec.vminsb
llvm.ppc.altivec.vminsd
llvm.ppc.altivec.vminsh
llvm.ppc.altivec.vminsw
llvm.ppc.altivec.vminub
llvm.ppc.altivec.vminud
llvm.ppc.altivec.vminuh
llvm.ppc.altivec.vminuw
llvm.ppc.altivec.vmladduhm
llvm.ppc.altivec.vmsummbm
llvm.ppc.altivec.vmsumshm
llvm.ppc.altivec.vmsumshs
llvm.ppc.altivec.vmsumubm
llvm.ppc.altivec.vmsumuhm
llvm.ppc.altivec.vmsumuhs
llvm.ppc.altivec.vmulesb
llvm.ppc.altivec.vmulesh
llvm.ppc.altivec.vmulesw
llvm.ppc.altivec.vmuleub
llvm.ppc.altivec.vmuleuh
llvm.ppc.altivec.vmuleuw
llvm.ppc.altivec.vmulosb
llvm.ppc.altivec.vmulosh
llvm.ppc.altivec.vmulosw
llvm.ppc.altivec.vmuloub
llvm.ppc.altivec.vmulouh
llvm.ppc.altivec.vmulouw
llvm.ppc.altivec.vnmsubfp
llvm.ppc.altivec.vperm
llvm.ppc.altivec.vpkpx
llvm.ppc.altivec.vpksdss
llvm.ppc.altivec.vpksdus
llvm.ppc.altivec.vpkshss
llvm.ppc.altivec.vpkshus
llvm.ppc.altivec.vpkswss
llvm.ppc.altivec.vpkswus
llvm.ppc.altivec.vpkudus
llvm.ppc.altivec.vpkuhus
llvm.ppc.altivec.vpkuwus
llvm.ppc.altivec.vprtybd
llvm.ppc.altivec.vprtybq
llvm.ppc.altivec.vprtybw
llvm.ppc.altivec.vrefp
llvm.ppc.altivec.vrfim
llvm.ppc.altivec.vrfin
llvm.ppc.altivec.vrfip
llvm.ppc.altivec.vrfiz
llvm.ppc.altivec.vrlb
llvm.ppc.altivec.vrld
llvm.ppc.altivec.vrldmi
llvm.ppc.altivec.vrldnm
llvm.ppc.altivec.vrlh
llvm.ppc.altivec.vrlw
llvm.ppc.altivec.vrlwmi
llvm.ppc.altivec.vrlwnm
llvm.ppc.altivec.vrsqrtefp
llvm.ppc.altivec.vsel
llvm.ppc.altivec.vsl
llvm.ppc.altivec.vslb
llvm.ppc.altivec.vslh
llvm.ppc.altivec.vslo
llvm.ppc.altivec.vslv
llvm.ppc.altivec.vslw
llvm.ppc.altivec.vsr
llvm.ppc.altivec.vsrab
llvm.ppc.altivec.vsrah
llvm.ppc.altivec.vsraw
llvm.ppc.altivec.vsrb
llvm.ppc.altivec.vsrh
llvm.ppc.altivec.vsro
llvm.ppc.altivec.vsrv
llvm.ppc.altivec.vsrw
llvm.ppc.altivec.vsubcuq
llvm.ppc.altivec.vsubcuw
llvm.ppc.altivec.vsubecuq
llvm.ppc.altivec.vsubeuqm
llvm.ppc.altivec.vsubsbs
llvm.ppc.altivec.vsubshs
llvm.ppc.altivec.vsubsws
llvm.ppc.altivec.vsububs
llvm.ppc.altivec.vsubuhs
llvm.ppc.altivec.vsubuws
llvm.ppc.altivec.vsum2sws
llvm.ppc.altivec.vsum4sbs
llvm.ppc.altivec.vsum4shs
llvm.ppc.altivec.vsum4ubs
llvm.ppc.altivec.vsumsws
llvm.ppc.altivec.vupkhpx
llvm.ppc.altivec.vupkhsb
llvm.ppc.altivec.vupkhsh
llvm.ppc.altivec.vupkhsw
llvm.ppc.altivec.vupklpx
llvm.ppc.altivec.vupklsb
llvm.ppc.altivec.vupklsh
llvm.ppc.altivec.vupklsw
llvm.ppc.bpermd
llvm.ppc.cfence
llvm.ppc.dcba
llvm.ppc.dcbf
llvm.ppc.dcbi
llvm.ppc.dcbst
llvm.ppc.dcbt
llvm.ppc.dcbtst
llvm.ppc.dcbz
llvm.ppc.dcbzl
llvm.ppc.divde
llvm.ppc.divdeu
llvm.ppc.divf128.round.to.odd
llvm.ppc.divwe
llvm.ppc.divweu
llvm.ppc.fmaf128.round.to.odd
llvm.ppc.get.texasr
llvm.ppc.get.texasru
llvm.ppc.get.tfhar
llvm.ppc.get.tfiar
llvm.ppc.is.decremented.ctr.nonzero
llvm.ppc.lwsync
llvm.ppc.mtctr
llvm.ppc.mulf128.round.to.odd
llvm.ppc.qpx.qvfabs
llvm.ppc.qpx.qvfadd
llvm.ppc.qpx.qvfadds
llvm.ppc.qpx.qvfcfid
llvm.ppc.qpx.qvfcfids
llvm.ppc.qpx.qvfcfidu
llvm.ppc.qpx.qvfcfidus
llvm.ppc.qpx.qvfcmpeq
llvm.ppc.qpx.qvfcmpgt
llvm.ppc.qpx.qvfcmplt
llvm.ppc.qpx.qvfcpsgn
llvm.ppc.qpx.qvfctid
llvm.ppc.qpx.qvfctidu
llvm.ppc.qpx.qvfctiduz
llvm.ppc.qpx.qvfctidz
llvm.ppc.qpx.qvfctiw
llvm.ppc.qpx.qvfctiwu
llvm.ppc.qpx.qvfctiwuz
llvm.ppc.qpx.qvfctiwz
llvm.ppc.qpx.qvflogical
llvm.ppc.qpx.qvfmadd
llvm.ppc.qpx.qvfmadds
llvm.ppc.qpx.qvfmsub
llvm.ppc.qpx.qvfmsubs
llvm.ppc.qpx.qvfmul
llvm.ppc.qpx.qvfmuls
llvm.ppc.qpx.qvfnabs
llvm.ppc.qpx.qvfneg
llvm.ppc.qpx.qvfnmadd
llvm.ppc.qpx.qvfnmadds
llvm.ppc.qpx.qvfnmsub
llvm.ppc.qpx.qvfnmsubs
llvm.ppc.qpx.qvfperm
llvm.ppc.qpx.qvfre
llvm.ppc.qpx.qvfres
llvm.ppc.qpx.qvfrim
llvm.ppc.qpx.qvfrin
llvm.ppc.qpx.qvfrip
llvm.ppc.qpx.qvfriz
llvm.ppc.qpx.qvfrsp
llvm.ppc.qpx.qvfrsqrte
llvm.ppc.qpx.qvfrsqrtes
llvm.ppc.qpx.qvfsel
llvm.ppc.qpx.qvfsub
llvm.ppc.qpx.qvfsubs
llvm.ppc.qpx.qvftstnan
llvm.ppc.qpx.qvfxmadd
llvm.ppc.qpx.qvfxmadds
llvm.ppc.qpx.qvfxmul
llvm.ppc.qpx.qvfxmuls
llvm.ppc.qpx.qvfxxcpnmadd
llvm.ppc.qpx.qvfxxcpnmadds
llvm.ppc.qpx.qvfxxmadd
llvm.ppc.qpx.qvfxxmadds
llvm.ppc.qpx.qvfxxnpmadd
llvm.ppc.qpx.qvfxxnpmadds
llvm.ppc.qpx.qvgpci
llvm.ppc.qpx.qvlfcd
llvm.ppc.qpx.qvlfcda
llvm.ppc.qpx.qvlfcs
llvm.ppc.qpx.qvlfcsa
llvm.ppc.qpx.qvlfd
llvm.ppc.qpx.qvlfda
llvm.ppc.qpx.qvlfiwa
llvm.ppc.qpx.qvlfiwaa
llvm.ppc.qpx.qvlfiwz
llvm.ppc.qpx.qvlfiwza
llvm.ppc.qpx.qvlfs
llvm.ppc.qpx.qvlfsa
llvm.ppc.qpx.qvlpcld
llvm.ppc.qpx.qvlpcls
llvm.ppc.qpx.qvlpcrd
llvm.ppc.qpx.qvlpcrs
llvm.ppc.qpx.qvstfcd
llvm.ppc.qpx.qvstfcda
llvm.ppc.qpx.qvstfcs
llvm.ppc.qpx.qvstfcsa
llvm.ppc.qpx.qvstfd
llvm.ppc.qpx.qvstfda
llvm.ppc.qpx.qvstfiw
llvm.ppc.qpx.qvstfiwa
llvm.ppc.qpx.qvstfs
llvm.ppc.qpx.qvstfsa
llvm.ppc.set.texasr
llvm.ppc.set.texasru
llvm.ppc.set.tfhar
llvm.ppc.set.tfiar
llvm.ppc.sqrtf128.round.to.odd
llvm.ppc.subf128.round.to.odd
llvm.ppc.sync
llvm.ppc.tabort
llvm.ppc.tabortdc
llvm.ppc.tabortdci
llvm.ppc.tabortwc
llvm.ppc.tabortwci
llvm.ppc.tbegin
llvm.ppc.tcheck
llvm.ppc.tend
llvm.ppc.tendall
llvm.ppc.trechkpt
llvm.ppc.treclaim
llvm.ppc.tresume
llvm.ppc.truncf128.round.to.odd
llvm.ppc.tsr
llvm.ppc.tsuspend
llvm.ppc.ttest
llvm.ppc.vsx.lxvd2x
llvm.ppc.vsx.lxvd2x.be
llvm.ppc.vsx.lxvl
llvm.ppc.vsx.lxvll
llvm.ppc.vsx.lxvw4x
llvm.ppc.vsx.lxvw4x.be
llvm.ppc.vsx.stxvd2x
llvm.ppc.vsx.stxvd2x.be
llvm.ppc.vsx.stxvl
llvm.ppc.vsx.stxvll
llvm.ppc.vsx.stxvw4x
llvm.ppc.vsx.stxvw4x.be
llvm.ppc.vsx.xsmaxdp
llvm.ppc.vsx.xsmindp
llvm.ppc.vsx.xvcmpeqdp
llvm.ppc.vsx.xvcmpeqdp.p
llvm.ppc.vsx.xvcmpeqsp
llvm.ppc.vsx.xvcmpeqsp.p
llvm.ppc.vsx.xvcmpgedp
llvm.ppc.vsx.xvcmpgedp.p
llvm.ppc.vsx.xvcmpgesp
llvm.ppc.vsx.xvcmpgesp.p
llvm.ppc.vsx.xvcmpgtdp
llvm.ppc.vsx.xvcmpgtdp.p
llvm.ppc.vsx.xvcmpgtsp
llvm.ppc.vsx.xvcmpgtsp.p
llvm.ppc.vsx.xvcvdpsp
llvm.ppc.vsx.xvcvdpsxws
llvm.ppc.vsx.xvcvdpuxws
llvm.ppc.vsx.xvcvhpsp
llvm.ppc.vsx.xvcvspdp
llvm.ppc.vsx.xvcvsphp
llvm.ppc.vsx.xvcvsxdsp
llvm.ppc.vsx.xvcvsxwdp
llvm.ppc.vsx.xvcvuxdsp
llvm.ppc.vsx.xvcvuxwdp
llvm.ppc.vsx.xvdivdp
llvm.ppc.vsx.xvdivsp
llvm.ppc.vsx.xviexpdp
llvm.ppc.vsx.xviexpsp
llvm.ppc.vsx.xvmaxdp
llvm.ppc.vsx.xvmaxsp
llvm.ppc.vsx.xvmindp
llvm.ppc.vsx.xvminsp
llvm.ppc.vsx.xvrdpip
llvm.ppc.vsx.xvredp
llvm.ppc.vsx.xvresp
llvm.ppc.vsx.xvrspip
llvm.ppc.vsx.xvrsqrtedp
llvm.ppc.vsx.xvrsqrtesp
llvm.ppc.vsx.xvtstdcdp
llvm.ppc.vsx.xvtstdcsp
llvm.ppc.vsx.xvxexpdp
llvm.ppc.vsx.xvxexpsp
llvm.ppc.vsx.xvxsigdp
llvm.ppc.vsx.xvxsigsp
llvm.ppc.vsx.xxextractuw
llvm.ppc.vsx.xxinsertw
llvm.ppc.vsx.xxleqv
llvm.r600.cube
llvm.r600.ddx
llvm.r600.ddy
llvm.r600.dot4
llvm.r600.group.barrier
llvm.r600.implicitarg.ptr
llvm.r600.kill
llvm.r600.rat.store.typed
llvm.r600.read.global.size.x
llvm.r600.read.global.size.y
llvm.r600.read.global.size.z
llvm.r600.read.local.size.x
llvm.r600.read.local.size.y
llvm.r600.read.local.size.z
llvm.r600.read.ngroups.x
llvm.r600.read.ngroups.y
llvm.r600.read.ngroups.z
llvm.r600.read.tgid.x
llvm.r600.read.tgid.y
llvm.r600.read.tgid.z
llvm.r600.read.tidig.x
llvm.r600.read.tidig.y
llvm.r600.read.tidig.z
llvm.r600.recipsqrt.clamped
llvm.r600.recipsqrt.ieee
llvm.r600.store.stream.output
llvm.r600.store.swizzle
llvm.r600.tex
llvm.r600.texc
llvm.r600.txb
llvm.r600.txbc
llvm.r600.txf
llvm.r600.txl
llvm.r600.txlc
llvm.r600.txq
llvm.s390.efpc
llvm.s390.etnd
llvm.s390.lcbb
llvm.s390.ntstg
llvm.s390.ppa.txassist
llvm.s390.sfpc
llvm.s390.tabort
llvm.s390.tbegin
llvm.s390.tbegin.nofloat
llvm.s390.tbeginc
llvm.s390.tdc
llvm.s390.tend
llvm.s390.vaccb
llvm.s390.vacccq
llvm.s390.vaccf
llvm.s390.vaccg
llvm.s390.vacch
llvm.s390.vaccq
llvm.s390.vacq
llvm.s390.vaq
llvm.s390.vavgb
llvm.s390.vavgf
llvm.s390.vavgg
llvm.s390.vavgh
llvm.s390.vavglb
llvm.s390.vavglf
llvm.s390.vavglg
llvm.s390.vavglh
llvm.s390.vbperm
llvm.s390.vceqbs
llvm.s390.vceqfs
llvm.s390.vceqgs
llvm.s390.vceqhs
llvm.s390.vchbs
llvm.s390.vchfs
llvm.s390.vchgs
llvm.s390.vchhs
llvm.s390.vchlbs
llvm.s390.vchlfs
llvm.s390.vchlgs
llvm.s390.vchlhs
llvm.s390.vcksm
llvm.s390.verimb
llvm.s390.verimf
llvm.s390.verimg
llvm.s390.verimh
llvm.s390.verllb
llvm.s390.verllf
llvm.s390.verllg
llvm.s390.verllh
llvm.s390.verllvb
llvm.s390.verllvf
llvm.s390.verllvg
llvm.s390.verllvh
llvm.s390.vfaeb
llvm.s390.vfaebs
llvm.s390.vfaef
llvm.s390.vfaefs
llvm.s390.vfaeh
llvm.s390.vfaehs
llvm.s390.vfaezb
llvm.s390.vfaezbs
llvm.s390.vfaezf
llvm.s390.vfaezfs
llvm.s390.vfaezh
llvm.s390.vfaezhs
llvm.s390.vfcedbs
llvm.s390.vfcesbs
llvm.s390.vfchdbs
llvm.s390.vfchedbs
llvm.s390.vfchesbs
llvm.s390.vfchsbs
llvm.s390.vfeeb
llvm.s390.vfeebs
llvm.s390.vfeef
llvm.s390.vfeefs
llvm.s390.vfeeh
llvm.s390.vfeehs
llvm.s390.vfeezb
llvm.s390.vfeezbs
llvm.s390.vfeezf
llvm.s390.vfeezfs
llvm.s390.vfeezh
llvm.s390.vfeezhs
llvm.s390.vfeneb
llvm.s390.vfenebs
llvm.s390.vfenef
llvm.s390.vfenefs
llvm.s390.vfeneh
llvm.s390.vfenehs
llvm.s390.vfenezb
llvm.s390.vfenezbs
llvm.s390.vfenezf
llvm.s390.vfenezfs
llvm.s390.vfenezh
llvm.s390.vfenezhs
llvm.s390.vfidb
llvm.s390.vfisb
llvm.s390.vfmaxdb
llvm.s390.vfmaxsb
llvm.s390.vfmindb
llvm.s390.vfminsb
llvm.s390.vftcidb
llvm.s390.vftcisb
llvm.s390.vgfmab
llvm.s390.vgfmaf
llvm.s390.vgfmag
llvm.s390.vgfmah
llvm.s390.vgfmb
llvm.s390.vgfmf
llvm.s390.vgfmg
llvm.s390.vgfmh
llvm.s390.vistrb
llvm.s390.vistrbs
llvm.s390.vistrf
llvm.s390.vistrfs
llvm.s390.vistrh
llvm.s390.vistrhs
llvm.s390.vlbb
llvm.s390.vll
llvm.s390.vlrl
llvm.s390.vmaeb
llvm.s390.vmaef
llvm.s390.vmaeh
llvm.s390.vmahb
llvm.s390.vmahf
llvm.s390.vmahh
llvm.s390.vmaleb
llvm.s390.vmalef
llvm.s390.vmaleh
llvm.s390.vmalhb
llvm.s390.vmalhf
llvm.s390.vmalhh
llvm.s390.vmalob
llvm.s390.vmalof
llvm.s390.vmaloh
llvm.s390.vmaob
llvm.s390.vmaof
llvm.s390.vmaoh
llvm.s390.vmeb
llvm.s390.vmef
llvm.s390.vmeh
llvm.s390.vmhb
llvm.s390.vmhf
llvm.s390.vmhh
llvm.s390.vmleb
llvm.s390.vmlef
llvm.s390.vmleh
llvm.s390.vmlhb
llvm.s390.vmlhf
llvm.s390.vmlhh
llvm.s390.vmlob
llvm.s390.vmlof
llvm.s390.vmloh
llvm.s390.vmob
llvm.s390.vmof
llvm.s390.vmoh
llvm.s390.vmslg
llvm.s390.vpdi
llvm.s390.vperm
llvm.s390.vpklsf
llvm.s390.vpklsfs
llvm.s390.vpklsg
llvm.s390.vpklsgs
llvm.s390.vpklsh
llvm.s390.vpklshs
llvm.s390.vpksf
llvm.s390.vpksfs
llvm.s390.vpksg
llvm.s390.vpksgs
llvm.s390.vpksh
llvm.s390.vpkshs
llvm.s390.vsbcbiq
llvm.s390.vsbiq
llvm.s390.vscbib
llvm.s390.vscbif
llvm.s390.vscbig
llvm.s390.vscbih
llvm.s390.vscbiq
llvm.s390.vsl
llvm.s390.vslb
llvm.s390.vsldb
llvm.s390.vsq
llvm.s390.vsra
llvm.s390.vsrab
llvm.s390.vsrl
llvm.s390.vsrlb
llvm.s390.vstl
llvm.s390.vstrcb
llvm.s390.vstrcbs
llvm.s390.vstrcf
llvm.s390.vstrcfs
llvm.s390.vstrch
llvm.s390.vstrchs
llvm.s390.vstrczb
llvm.s390.vstrczbs
llvm.s390.vstrczf
llvm.s390.vstrczfs
llvm.s390.vstrczh
llvm.s390.vstrczhs
llvm.s390.vstrl
llvm.s390.vsumb
llvm.s390.vsumgf
llvm.s390.vsumgh
llvm.s390.vsumh
llvm.s390.vsumqf
llvm.s390.vsumqg
llvm.s390.vtm
llvm.s390.vuphb
llvm.s390.vuphf
llvm.s390.vuphh
llvm.s390.vuplb
llvm.s390.vuplf
llvm.s390.vuplhb
llvm.s390.vuplhf
llvm.s390.vuplhh
llvm.s390.vuplhw
llvm.s390.vupllb
llvm.s390.vupllf
llvm.s390.vupllh
llvm.wasm.catch
llvm.wasm.current.memory
llvm.wasm.get.ehselector
llvm.wasm.get.exception
llvm.wasm.grow.memory
llvm.wasm.landingpad.index
llvm.wasm.lsda
llvm.wasm.mem.grow
llvm.wasm.mem.size
llvm.wasm.memory.grow
llvm.wasm.memory.size
llvm.wasm.rethrow
llvm.wasm.throw
llvm.x86.3dnow.pavgusb
llvm.x86.3dnow.pf2id
llvm.x86.3dnow.pfacc
llvm.x86.3dnow.pfadd
llvm.x86.3dnow.pfcmpeq
llvm.x86.3dnow.pfcmpge
llvm.x86.3dnow.pfcmpgt
llvm.x86.3dnow.pfmax
llvm.x86.3dnow.pfmin
llvm.x86.3dnow.pfmul
llvm.x86.3dnow.pfrcp
llvm.x86.3dnow.pfrcpit1
llvm.x86.3dnow.pfrcpit2
llvm.x86.3dnow.pfrsqit1
llvm.x86.3dnow.pfrsqrt
llvm.x86.3dnow.pfsub
llvm.x86.3dnow.pfsubr
llvm.x86.3dnow.pi2fd
llvm.x86.3dnow.pmulhrw
llvm.x86.3dnowa.pf2iw
llvm.x86.3dnowa.pfnacc
llvm.x86.3dnowa.pfpnacc
llvm.x86.3dnowa.pi2fw
llvm.x86.3dnowa.pswapd
llvm.x86.addcarry.u32
llvm.x86.addcarry.u64
llvm.x86.addcarryx.u32
llvm.x86.addcarryx.u64
llvm.x86.aesni.aesdec
llvm.x86.aesni.aesdec.256
llvm.x86.aesni.aesdec.512
llvm.x86.aesni.aesdeclast
llvm.x86.aesni.aesdeclast.256
llvm.x86.aesni.aesdeclast.512
llvm.x86.aesni.aesenc
llvm.x86.aesni.aesenc.256
llvm.x86.aesni.aesenc.512
llvm.x86.aesni.aesenclast
llvm.x86.aesni.aesenclast.256
llvm.x86.aesni.aesenclast.512
llvm.x86.aesni.aesimc
llvm.x86.aesni.aeskeygenassist
llvm.x86.avx.addsub.pd.256
llvm.x86.avx.addsub.ps.256
llvm.x86.avx.blendv.pd.256
llvm.x86.avx.blendv.ps.256
llvm.x86.avx.cmp.pd.256
llvm.x86.avx.cmp.ps.256
llvm.x86.avx.cvt.pd2.ps.256
llvm.x86.avx.cvt.pd2dq.256
llvm.x86.avx.cvt.ps2dq.256
llvm.x86.avx.cvtt.pd2dq.256
llvm.x86.avx.cvtt.ps2dq.256
llvm.x86.avx.dp.ps.256
llvm.x86.avx.hadd.pd.256
llvm.x86.avx.hadd.ps.256
llvm.x86.avx.hsub.pd.256
llvm.x86.avx.hsub.ps.256
llvm.x86.avx.ldu.dq.256
llvm.x86.avx.maskload.pd
llvm.x86.avx.maskload.pd.256
llvm.x86.avx.maskload.ps
llvm.x86.avx.maskload.ps.256
llvm.x86.avx.maskstore.pd
llvm.x86.avx.maskstore.pd.256
llvm.x86.avx.maskstore.ps
llvm.x86.avx.maskstore.ps.256
llvm.x86.avx.max.pd.256
llvm.x86.avx.max.ps.256
llvm.x86.avx.min.pd.256
llvm.x86.avx.min.ps.256
llvm.x86.avx.movmsk.pd.256
llvm.x86.avx.movmsk.ps.256
llvm.x86.avx.ptestc.256
llvm.x86.avx.ptestnzc.256
llvm.x86.avx.ptestz.256
llvm.x86.avx.rcp.ps.256
llvm.x86.avx.round.pd.256
llvm.x86.avx.round.ps.256
llvm.x86.avx.rsqrt.ps.256
llvm.x86.avx.vpermilvar.pd
llvm.x86.avx.vpermilvar.pd.256
llvm.x86.avx.vpermilvar.ps
llvm.x86.avx.vpermilvar.ps.256
llvm.x86.avx.vtestc.pd
llvm.x86.avx.vtestc.pd.256
llvm.x86.avx.vtestc.ps
llvm.x86.avx.vtestc.ps.256
llvm.x86.avx.vtestnzc.pd
llvm.x86.avx.vtestnzc.pd.256
llvm.x86.avx.vtestnzc.ps
llvm.x86.avx.vtestnzc.ps.256
llvm.x86.avx.vtestz.pd
llvm.x86.avx.vtestz.pd.256
llvm.x86.avx.vtestz.ps
llvm.x86.avx.vtestz.ps.256
llvm.x86.avx.vzeroall
llvm.x86.avx.vzeroupper
llvm.x86.avx2.gather.d.d
llvm.x86.avx2.gather.d.d.256
llvm.x86.avx2.gather.d.pd
llvm.x86.avx2.gather.d.pd.256
llvm.x86.avx2.gather.d.ps
llvm.x86.avx2.gather.d.ps.256
llvm.x86.avx2.gather.d.q
llvm.x86.avx2.gather.d.q.256
llvm.x86.avx2.gather.q.d
llvm.x86.avx2.gather.q.d.256
llvm.x86.avx2.gather.q.pd
llvm.x86.avx2.gather.q.pd.256
llvm.x86.avx2.gather.q.ps
llvm.x86.avx2.gather.q.ps.256
llvm.x86.avx2.gather.q.q
llvm.x86.avx2.gather.q.q.256
llvm.x86.avx2.maskload.d
llvm.x86.avx2.maskload.d.256
llvm.x86.avx2.maskload.q
llvm.x86.avx2.maskload.q.256
llvm.x86.avx2.maskstore.d
llvm.x86.avx2.maskstore.d.256
llvm.x86.avx2.maskstore.q
llvm.x86.avx2.maskstore.q.256
llvm.x86.avx2.mpsadbw
llvm.x86.avx2.packssdw
llvm.x86.avx2.packsswb
llvm.x86.avx2.packusdw
llvm.x86.avx2.packuswb
llvm.x86.avx2.padds.b
llvm.x86.avx2.padds.w
llvm.x86.avx2.paddus.b
llvm.x86.avx2.paddus.w
llvm.x86.avx2.pblendvb
llvm.x86.avx2.permd
llvm.x86.avx2.permps
llvm.x86.avx2.phadd.d
llvm.x86.avx2.phadd.sw
llvm.x86.avx2.phadd.w
llvm.x86.avx2.phsub.d
llvm.x86.avx2.phsub.sw
llvm.x86.avx2.phsub.w
llvm.x86.avx2.pmadd.ub.sw
llvm.x86.avx2.pmadd.wd
llvm.x86.avx2.pmovmskb
llvm.x86.avx2.pmul.hr.sw
llvm.x86.avx2.pmulh.w
llvm.x86.avx2.pmulhu.w
llvm.x86.avx2.psad.bw
llvm.x86.avx2.pshuf.b
llvm.x86.avx2.psign.b
llvm.x86.avx2.psign.d
llvm.x86.avx2.psign.w
llvm.x86.avx2.psll.d
llvm.x86.avx2.psll.q
llvm.x86.avx2.psll.w
llvm.x86.avx2.pslli.d
llvm.x86.avx2.pslli.q
llvm.x86.avx2.pslli.w
llvm.x86.avx2.psllv.d
llvm.x86.avx2.psllv.d.256
llvm.x86.avx2.psllv.q
llvm.x86.avx2.psllv.q.256
llvm.x86.avx2.psra.d
llvm.x86.avx2.psra.w
llvm.x86.avx2.psrai.d
llvm.x86.avx2.psrai.w
llvm.x86.avx2.psrav.d
llvm.x86.avx2.psrav.d.256
llvm.x86.avx2.psrl.d
llvm.x86.avx2.psrl.q
llvm.x86.avx2.psrl.w
llvm.x86.avx2.psrli.d
llvm.x86.avx2.psrli.q
llvm.x86.avx2.psrli.w
llvm.x86.avx2.psrlv.d
llvm.x86.avx2.psrlv.d.256
llvm.x86.avx2.psrlv.q
llvm.x86.avx2.psrlv.q.256
llvm.x86.avx2.psubs.b
llvm.x86.avx2.psubs.w
llvm.x86.avx2.psubus.b
llvm.x86.avx2.psubus.w
llvm.x86.avx512.add.pd.512
llvm.x86.avx512.add.ps.512
llvm.x86.avx512.broadcastmb.128
llvm.x86.avx512.broadcastmb.256
llvm.x86.avx512.broadcastmb.512
llvm.x86.avx512.broadcastmw.128
llvm.x86.avx512.broadcastmw.256
llvm.x86.avx512.broadcastmw.512
llvm.x86.avx512.cmp.pd.128
llvm.x86.avx512.cmp.pd.256
llvm.x86.avx512.cmp.pd.512
llvm.x86.avx512.cmp.ps.128
llvm.x86.avx512.cmp.ps.256
llvm.x86.avx512.cmp.ps.512
llvm.x86.avx512.cvtsi2sd64
llvm.x86.avx512.cvtsi2ss32
llvm.x86.avx512.cvtsi2ss64
llvm.x86.avx512.cvttsd2si
llvm.x86.avx512.cvttsd2si64
llvm.x86.avx512.cvttsd2usi
llvm.x86.avx512.cvttsd2usi64
llvm.x86.avx512.cvttss2si
llvm.x86.avx512.cvttss2si64
llvm.x86.avx512.cvttss2usi
llvm.x86.avx512.cvttss2usi64
llvm.x86.avx512.cvtusi2ss
llvm.x86.avx512.cvtusi642sd
llvm.x86.avx512.cvtusi642ss
llvm.x86.avx512.dbpsadbw.128
llvm.x86.avx512.dbpsadbw.256
llvm.x86.avx512.dbpsadbw.512
llvm.x86.avx512.div.pd.512
llvm.x86.avx512.div.ps.512
llvm.x86.avx512.exp2.pd
llvm.x86.avx512.exp2.ps
llvm.x86.avx512.fpclass.pd.128
llvm.x86.avx512.fpclass.pd.256
llvm.x86.avx512.fpclass.pd.512
llvm.x86.avx512.fpclass.ps.128
llvm.x86.avx512.fpclass.ps.256
llvm.x86.avx512.fpclass.ps.512
llvm.x86.avx512.gather.dpd.512
llvm.x86.avx512.gather.dpi.512
llvm.x86.avx512.gather.dpq.512
llvm.x86.avx512.gather.dps.512
llvm.x86.avx512.gather.qpd.512
llvm.x86.avx512.gather.qpi.512
llvm.x86.avx512.gather.qpq.512
llvm.x86.avx512.gather.qps.512
llvm.x86.avx512.gather3div2.df
llvm.x86.avx512.gather3div2.di
llvm.x86.avx512.gather3div4.df
llvm.x86.avx512.gather3div4.di
llvm.x86.avx512.gather3div4.sf
llvm.x86.avx512.gather3div4.si
llvm.x86.avx512.gather3div8.sf
llvm.x86.avx512.gather3div8.si
llvm.x86.avx512.gather3siv2.df
llvm.x86.avx512.gather3siv2.di
llvm.x86.avx512.gather3siv4.df
llvm.x86.avx512.gather3siv4.di
llvm.x86.avx512.gather3siv4.sf
llvm.x86.avx512.gather3siv4.si
llvm.x86.avx512.gather3siv8.sf
llvm.x86.avx512.gather3siv8.si
llvm.x86.avx512.gatherpf.dpd.512
llvm.x86.avx512.gatherpf.dps.512
llvm.x86.avx512.gatherpf.qpd.512
llvm.x86.avx512.gatherpf.qps.512
llvm.x86.avx512.mask.add.sd.round
llvm.x86.avx512.mask.add.ss.round
llvm.x86.avx512.mask.cmp.sd
llvm.x86.avx512.mask.cmp.ss
llvm.x86.avx512.mask.compress.b.128
llvm.x86.avx512.mask.compress.b.256
llvm.x86.avx512.mask.compress.b.512
llvm.x86.avx512.mask.compress.d.128
llvm.x86.avx512.mask.compress.d.256
llvm.x86.avx512.mask.compress.d.512
llvm.x86.avx512.mask.compress.pd.128
llvm.x86.avx512.mask.compress.pd.256
llvm.x86.avx512.mask.compress.pd.512
llvm.x86.avx512.mask.compress.ps.128
llvm.x86.avx512.mask.compress.ps.256
llvm.x86.avx512.mask.compress.ps.512
llvm.x86.avx512.mask.compress.q.128
llvm.x86.avx512.mask.compress.q.256
llvm.x86.avx512.mask.compress.q.512
llvm.x86.avx512.mask.compress.w.128
llvm.x86.avx512.mask.compress.w.256
llvm.x86.avx512.mask.compress.w.512
llvm.x86.avx512.mask.conflict.d.128
llvm.x86.avx512.mask.conflict.d.256
llvm.x86.avx512.mask.conflict.d.512
llvm.x86.avx512.mask.conflict.q.128
llvm.x86.avx512.mask.conflict.q.256
llvm.x86.avx512.mask.conflict.q.512
llvm.x86.avx512.mask.cvtdq2ps.512
llvm.x86.avx512.mask.cvtpd2dq.128
llvm.x86.avx512.mask.cvtpd2dq.512
llvm.x86.avx512.mask.cvtpd2ps
llvm.x86.avx512.mask.cvtpd2ps.512
llvm.x86.avx512.mask.cvtpd2qq.128
llvm.x86.avx512.mask.cvtpd2qq.256
llvm.x86.avx512.mask.cvtpd2qq.512
llvm.x86.avx512.mask.cvtpd2udq.128
llvm.x86.avx512.mask.cvtpd2udq.256
llvm.x86.avx512.mask.cvtpd2udq.512
llvm.x86.avx512.mask.cvtpd2uqq.128
llvm.x86.avx512.mask.cvtpd2uqq.256
llvm.x86.avx512.mask.cvtpd2uqq.512
llvm.x86.avx512.mask.cvtps2dq.128
llvm.x86.avx512.mask.cvtps2dq.256
llvm.x86.avx512.mask.cvtps2dq.512
llvm.x86.avx512.mask.cvtps2pd.512
llvm.x86.avx512.mask.cvtps2qq.128
llvm.x86.avx512.mask.cvtps2qq.256
llvm.x86.avx512.mask.cvtps2qq.512
llvm.x86.avx512.mask.cvtps2udq.128
llvm.x86.avx512.mask.cvtps2udq.256
llvm.x86.avx512.mask.cvtps2udq.512
llvm.x86.avx512.mask.cvtps2uqq.128
llvm.x86.avx512.mask.cvtps2uqq.256
llvm.x86.avx512.mask.cvtps2uqq.512
llvm.x86.avx512.mask.cvtqq2pd.512
llvm.x86.avx512.mask.cvtqq2ps.128
llvm.x86.avx512.mask.cvtqq2ps.256
llvm.x86.avx512.mask.cvtqq2ps.512
llvm.x86.avx512.mask.cvtsd2ss.round
llvm.x86.avx512.mask.cvtss2sd.round
llvm.x86.avx512.mask.cvttpd2dq.128
llvm.x86.avx512.mask.cvttpd2dq.512
llvm.x86.avx512.mask.cvttpd2qq.128
llvm.x86.avx512.mask.cvttpd2qq.256
llvm.x86.avx512.mask.cvttpd2qq.512
llvm.x86.avx512.mask.cvttpd2udq.128
llvm.x86.avx512.mask.cvttpd2udq.256
llvm.x86.avx512.mask.cvttpd2udq.512
llvm.x86.avx512.mask.cvttpd2uqq.128
llvm.x86.avx512.mask.cvttpd2uqq.256
llvm.x86.avx512.mask.cvttpd2uqq.512
llvm.x86.avx512.mask.cvttps2dq.512
llvm.x86.avx512.mask.cvttps2qq.128
llvm.x86.avx512.mask.cvttps2qq.256
llvm.x86.avx512.mask.cvttps2qq.512
llvm.x86.avx512.mask.cvttps2udq.128
llvm.x86.avx512.mask.cvttps2udq.256
llvm.x86.avx512.mask.cvttps2udq.512
llvm.x86.avx512.mask.cvttps2uqq.128
llvm.x86.avx512.mask.cvttps2uqq.256
llvm.x86.avx512.mask.cvttps2uqq.512
llvm.x86.avx512.mask.cvtudq2ps.512
llvm.x86.avx512.mask.cvtuqq2pd.512
llvm.x86.avx512.mask.cvtuqq2ps.128
llvm.x86.avx512.mask.cvtuqq2ps.256
llvm.x86.avx512.mask.cvtuqq2ps.512
llvm.x86.avx512.mask.div.sd.round
llvm.x86.avx512.mask.div.ss.round
llvm.x86.avx512.mask.expand.b.128
llvm.x86.avx512.mask.expand.b.256
llvm.x86.avx512.mask.expand.b.512
llvm.x86.avx512.mask.expand.d.128
llvm.x86.avx512.mask.expand.d.256
llvm.x86.avx512.mask.expand.d.512
llvm.x86.avx512.mask.expand.pd.128
llvm.x86.avx512.mask.expand.pd.256
llvm.x86.avx512.mask.expand.pd.512
llvm.x86.avx512.mask.expand.ps.128
llvm.x86.avx512.mask.expand.ps.256
llvm.x86.avx512.mask.expand.ps.512
llvm.x86.avx512.mask.expand.q.128
llvm.x86.avx512.mask.expand.q.256
llvm.x86.avx512.mask.expand.q.512
llvm.x86.avx512.mask.expand.w.128
llvm.x86.avx512.mask.expand.w.256
llvm.x86.avx512.mask.expand.w.512
llvm.x86.avx512.mask.fixupimm.pd.128
llvm.x86.avx512.mask.fixupimm.pd.256
llvm.x86.avx512.mask.fixupimm.pd.512
llvm.x86.avx512.mask.fixupimm.ps.128
llvm.x86.avx512.mask.fixupimm.ps.256
llvm.x86.avx512.mask.fixupimm.ps.512
llvm.x86.avx512.mask.fixupimm.sd
llvm.x86.avx512.mask.fixupimm.ss
llvm.x86.avx512.mask.fpclass.sd
llvm.x86.avx512.mask.fpclass.ss
llvm.x86.avx512.mask.getexp.pd.128
llvm.x86.avx512.mask.getexp.pd.256
llvm.x86.avx512.mask.getexp.pd.512
llvm.x86.avx512.mask.getexp.ps.128
llvm.x86.avx512.mask.getexp.ps.256
llvm.x86.avx512.mask.getexp.ps.512
llvm.x86.avx512.mask.getexp.sd
llvm.x86.avx512.mask.getexp.ss
llvm.x86.avx512.mask.getmant.pd.128
llvm.x86.avx512.mask.getmant.pd.256
llvm.x86.avx512.mask.getmant.pd.512
llvm.x86.avx512.mask.getmant.ps.128
llvm.x86.avx512.mask.getmant.ps.256
llvm.x86.avx512.mask.getmant.ps.512
llvm.x86.avx512.mask.getmant.sd
llvm.x86.avx512.mask.getmant.ss
llvm.x86.avx512.mask.max.sd.round
llvm.x86.avx512.mask.max.ss.round
llvm.x86.avx512.mask.min.sd.round
llvm.x86.avx512.mask.min.ss.round
llvm.x86.avx512.mask.mul.sd.round
llvm.x86.avx512.mask.mul.ss.round
llvm.x86.avx512.mask.padds.b.128
llvm.x86.avx512.mask.padds.b.256
llvm.x86.avx512.mask.padds.b.512
llvm.x86.avx512.mask.padds.w.128
llvm.x86.avx512.mask.padds.w.256
llvm.x86.avx512.mask.padds.w.512
llvm.x86.avx512.mask.paddus.b.128
llvm.x86.avx512.mask.paddus.b.256
llvm.x86.avx512.mask.paddus.b.512
llvm.x86.avx512.mask.paddus.w.128
llvm.x86.avx512.mask.paddus.w.256
llvm.x86.avx512.mask.paddus.w.512
llvm.x86.avx512.mask.pmov.db.128
llvm.x86.avx512.mask.pmov.db.256
llvm.x86.avx512.mask.pmov.db.512
llvm.x86.avx512.mask.pmov.db.mem.128
llvm.x86.avx512.mask.pmov.db.mem.256
llvm.x86.avx512.mask.pmov.db.mem.512
llvm.x86.avx512.mask.pmov.dw.128
llvm.x86.avx512.mask.pmov.dw.256
llvm.x86.avx512.mask.pmov.dw.512
llvm.x86.avx512.mask.pmov.dw.mem.128
llvm.x86.avx512.mask.pmov.dw.mem.256
llvm.x86.avx512.mask.pmov.dw.mem.512
llvm.x86.avx512.mask.pmov.qb.128
llvm.x86.avx512.mask.pmov.qb.256
llvm.x86.avx512.mask.pmov.qb.512
llvm.x86.avx512.mask.pmov.qb.mem.128
llvm.x86.avx512.mask.pmov.qb.mem.256
llvm.x86.avx512.mask.pmov.qb.mem.512
llvm.x86.avx512.mask.pmov.qd.128
llvm.x86.avx512.mask.pmov.qd.256
llvm.x86.avx512.mask.pmov.qd.512
llvm.x86.avx512.mask.pmov.qd.mem.128
llvm.x86.avx512.mask.pmov.qd.mem.256
llvm.x86.avx512.mask.pmov.qd.mem.512
llvm.x86.avx512.mask.pmov.qw.128
llvm.x86.avx512.mask.pmov.qw.256
llvm.x86.avx512.mask.pmov.qw.512
llvm.x86.avx512.mask.pmov.qw.mem.128
llvm.x86.avx512.mask.pmov.qw.mem.256
llvm.x86.avx512.mask.pmov.qw.mem.512
llvm.x86.avx512.mask.pmov.wb.128
llvm.x86.avx512.mask.pmov.wb.256
llvm.x86.avx512.mask.pmov.wb.512
llvm.x86.avx512.mask.pmov.wb.mem.128
llvm.x86.avx512.mask.pmov.wb.mem.256
llvm.x86.avx512.mask.pmov.wb.mem.512
llvm.x86.avx512.mask.pmovs.db.128
llvm.x86.avx512.mask.pmovs.db.256
llvm.x86.avx512.mask.pmovs.db.512
llvm.x86.avx512.mask.pmovs.db.mem.128
llvm.x86.avx512.mask.pmovs.db.mem.256
llvm.x86.avx512.mask.pmovs.db.mem.512
llvm.x86.avx512.mask.pmovs.dw.128
llvm.x86.avx512.mask.pmovs.dw.256
llvm.x86.avx512.mask.pmovs.dw.512
llvm.x86.avx512.mask.pmovs.dw.mem.128
llvm.x86.avx512.mask.pmovs.dw.mem.256
llvm.x86.avx512.mask.pmovs.dw.mem.512
llvm.x86.avx512.mask.pmovs.qb.128
llvm.x86.avx512.mask.pmovs.qb.256
llvm.x86.avx512.mask.pmovs.qb.512
llvm.x86.avx512.mask.pmovs.qb.mem.128
llvm.x86.avx512.mask.pmovs.qb.mem.256
llvm.x86.avx512.mask.pmovs.qb.mem.512
llvm.x86.avx512.mask.pmovs.qd.128
llvm.x86.avx512.mask.pmovs.qd.256
llvm.x86.avx512.mask.pmovs.qd.512
llvm.x86.avx512.mask.pmovs.qd.mem.128
llvm.x86.avx512.mask.pmovs.qd.mem.256
llvm.x86.avx512.mask.pmovs.qd.mem.512
llvm.x86.avx512.mask.pmovs.qw.128
llvm.x86.avx512.mask.pmovs.qw.256
llvm.x86.avx512.mask.pmovs.qw.512
llvm.x86.avx512.mask.pmovs.qw.mem.128
llvm.x86.avx512.mask.pmovs.qw.mem.256
llvm.x86.avx512.mask.pmovs.qw.mem.512
llvm.x86.avx512.mask.pmovs.wb.128
llvm.x86.avx512.mask.pmovs.wb.256
llvm.x86.avx512.mask.pmovs.wb.512
llvm.x86.avx512.mask.pmovs.wb.mem.128
llvm.x86.avx512.mask.pmovs.wb.mem.256
llvm.x86.avx512.mask.pmovs.wb.mem.512
llvm.x86.avx512.mask.pmovus.db.128
llvm.x86.avx512.mask.pmovus.db.256
llvm.x86.avx512.mask.pmovus.db.512
llvm.x86.avx512.mask.pmovus.db.mem.128
llvm.x86.avx512.mask.pmovus.db.mem.256
llvm.x86.avx512.mask.pmovus.db.mem.512
llvm.x86.avx512.mask.pmovus.dw.128
llvm.x86.avx512.mask.pmovus.dw.256
llvm.x86.avx512.mask.pmovus.dw.512
llvm.x86.avx512.mask.pmovus.dw.mem.128
llvm.x86.avx512.mask.pmovus.dw.mem.256
llvm.x86.avx512.mask.pmovus.dw.mem.512
llvm.x86.avx512.mask.pmovus.qb.128
llvm.x86.avx512.mask.pmovus.qb.256
llvm.x86.avx512.mask.pmovus.qb.512
llvm.x86.avx512.mask.pmovus.qb.mem.128
llvm.x86.avx512.mask.pmovus.qb.mem.256
llvm.x86.avx512.mask.pmovus.qb.mem.512
llvm.x86.avx512.mask.pmovus.qd.128
llvm.x86.avx512.mask.pmovus.qd.256
llvm.x86.avx512.mask.pmovus.qd.512
llvm.x86.avx512.mask.pmovus.qd.mem.128
llvm.x86.avx512.mask.pmovus.qd.mem.256
llvm.x86.avx512.mask.pmovus.qd.mem.512
llvm.x86.avx512.mask.pmovus.qw.128
llvm.x86.avx512.mask.pmovus.qw.256
llvm.x86.avx512.mask.pmovus.qw.512
llvm.x86.avx512.mask.pmovus.qw.mem.128
llvm.x86.avx512.mask.pmovus.qw.mem.256
llvm.x86.avx512.mask.pmovus.qw.mem.512
llvm.x86.avx512.mask.pmovus.wb.128
llvm.x86.avx512.mask.pmovus.wb.256
llvm.x86.avx512.mask.pmovus.wb.512
llvm.x86.avx512.mask.pmovus.wb.mem.128
llvm.x86.avx512.mask.pmovus.wb.mem.256
llvm.x86.avx512.mask.pmovus.wb.mem.512
llvm.x86.avx512.mask.pmultishift.qb.128
llvm.x86.avx512.mask.pmultishift.qb.256
llvm.x86.avx512.mask.pmultishift.qb.512
llvm.x86.avx512.mask.psubs.b.128
llvm.x86.avx512.mask.psubs.b.256
llvm.x86.avx512.mask.psubs.b.512
llvm.x86.avx512.mask.psubs.w.128
llvm.x86.avx512.mask.psubs.w.256
llvm.x86.avx512.mask.psubs.w.512
llvm.x86.avx512.mask.psubus.b.128
llvm.x86.avx512.mask.psubus.b.256
llvm.x86.avx512.mask.psubus.b.512
llvm.x86.avx512.mask.psubus.w.128
llvm.x86.avx512.mask.psubus.w.256
llvm.x86.avx512.mask.psubus.w.512
llvm.x86.avx512.mask.range.pd.128
llvm.x86.avx512.mask.range.pd.256
llvm.x86.avx512.mask.range.pd.512
llvm.x86.avx512.mask.range.ps.128
llvm.x86.avx512.mask.range.ps.256
llvm.x86.avx512.mask.range.ps.512
llvm.x86.avx512.mask.range.sd
llvm.x86.avx512.mask.range.ss
llvm.x86.avx512.mask.reduce.pd.128
llvm.x86.avx512.mask.reduce.pd.256
llvm.x86.avx512.mask.reduce.pd.512
llvm.x86.avx512.mask.reduce.ps.128
llvm.x86.avx512.mask.reduce.ps.256
llvm.x86.avx512.mask.reduce.ps.512
llvm.x86.avx512.mask.reduce.sd
llvm.x86.avx512.mask.reduce.ss
llvm.x86.avx512.mask.rndscale.pd.128
llvm.x86.avx512.mask.rndscale.pd.256
llvm.x86.avx512.mask.rndscale.pd.512
llvm.x86.avx512.mask.rndscale.ps.128
llvm.x86.avx512.mask.rndscale.ps.256
llvm.x86.avx512.mask.rndscale.ps.512
llvm.x86.avx512.mask.rndscale.sd
llvm.x86.avx512.mask.rndscale.ss
llvm.x86.avx512.mask.scalef.pd.128
llvm.x86.avx512.mask.scalef.pd.256
llvm.x86.avx512.mask.scalef.pd.512
llvm.x86.avx512.mask.scalef.ps.128
llvm.x86.avx512.mask.scalef.ps.256
llvm.x86.avx512.mask.scalef.ps.512
llvm.x86.avx512.mask.scalef.sd
llvm.x86.avx512.mask.scalef.ss
llvm.x86.avx512.mask.sqrt.sd
llvm.x86.avx512.mask.sqrt.ss
llvm.x86.avx512.mask.sub.sd.round
llvm.x86.avx512.mask.sub.ss.round
llvm.x86.avx512.mask.vcvtph2ps.128
llvm.x86.avx512.mask.vcvtph2ps.256
llvm.x86.avx512.mask.vcvtph2ps.512
llvm.x86.avx512.mask.vcvtps2ph.128
llvm.x86.avx512.mask.vcvtps2ph.256
llvm.x86.avx512.mask.vcvtps2ph.512
llvm.x86.avx512.mask.vpshldv.d.128
llvm.x86.avx512.mask.vpshldv.d.256
llvm.x86.avx512.mask.vpshldv.d.512
llvm.x86.avx512.mask.vpshldv.q.128
llvm.x86.avx512.mask.vpshldv.q.256
llvm.x86.avx512.mask.vpshldv.q.512
llvm.x86.avx512.mask.vpshldv.w.128
llvm.x86.avx512.mask.vpshldv.w.256
llvm.x86.avx512.mask.vpshldv.w.512
llvm.x86.avx512.mask.vpshrdv.d.128
llvm.x86.avx512.mask.vpshrdv.d.256
llvm.x86.avx512.mask.vpshrdv.d.512
llvm.x86.avx512.mask.vpshrdv.q.128
llvm.x86.avx512.mask.vpshrdv.q.256
llvm.x86.avx512.mask.vpshrdv.q.512
llvm.x86.avx512.mask.vpshrdv.w.128
llvm.x86.avx512.mask.vpshrdv.w.256
llvm.x86.avx512.mask.vpshrdv.w.512
llvm.x86.avx512.mask.vpshufbitqmb.128
llvm.x86.avx512.mask.vpshufbitqmb.256
llvm.x86.avx512.mask.vpshufbitqmb.512
llvm.x86.avx512.maskz.fixupimm.pd.128
llvm.x86.avx512.maskz.fixupimm.pd.256
llvm.x86.avx512.maskz.fixupimm.pd.512
llvm.x86.avx512.maskz.fixupimm.ps.128
llvm.x86.avx512.maskz.fixupimm.ps.256
llvm.x86.avx512.maskz.fixupimm.ps.512
llvm.x86.avx512.maskz.fixupimm.sd
llvm.x86.avx512.maskz.fixupimm.ss
llvm.x86.avx512.maskz.vpshldv.d.128
llvm.x86.avx512.maskz.vpshldv.d.256
llvm.x86.avx512.maskz.vpshldv.d.512
llvm.x86.avx512.maskz.vpshldv.q.128
llvm.x86.avx512.maskz.vpshldv.q.256
llvm.x86.avx512.maskz.vpshldv.q.512
llvm.x86.avx512.maskz.vpshldv.w.128
llvm.x86.avx512.maskz.vpshldv.w.256
llvm.x86.avx512.maskz.vpshldv.w.512
llvm.x86.avx512.maskz.vpshrdv.d.128
llvm.x86.avx512.maskz.vpshrdv.d.256
llvm.x86.avx512.maskz.vpshrdv.d.512
llvm.x86.avx512.maskz.vpshrdv.q.128
llvm.x86.avx512.maskz.vpshrdv.q.256
llvm.x86.avx512.maskz.vpshrdv.q.512
llvm.x86.avx512.maskz.vpshrdv.w.128
llvm.x86.avx512.maskz.vpshrdv.w.256
llvm.x86.avx512.maskz.vpshrdv.w.512
llvm.x86.avx512.max.pd.512
llvm.x86.avx512.max.ps.512
llvm.x86.avx512.min.pd.512
llvm.x86.avx512.min.ps.512
llvm.x86.avx512.mul.pd.512
llvm.x86.avx512.mul.ps.512
llvm.x86.avx512.packssdw.512
llvm.x86.avx512.packsswb.512
llvm.x86.avx512.packusdw.512
llvm.x86.avx512.packuswb.512
llvm.x86.avx512.permvar.df.256
llvm.x86.avx512.permvar.df.512
llvm.x86.avx512.permvar.di.256
llvm.x86.avx512.permvar.di.512
llvm.x86.avx512.permvar.hi.128
llvm.x86.avx512.permvar.hi.256
llvm.x86.avx512.permvar.hi.512
llvm.x86.avx512.permvar.qi.128
llvm.x86.avx512.permvar.qi.256
llvm.x86.avx512.permvar.qi.512
llvm.x86.avx512.permvar.sf.512
llvm.x86.avx512.permvar.si.512
llvm.x86.avx512.pmaddubs.w.512
llvm.x86.avx512.pmaddw.d.512
llvm.x86.avx512.pmul.hr.sw.512
llvm.x86.avx512.pmulh.w.512
llvm.x86.avx512.pmulhu.w.512
llvm.x86.avx512.prol.d.128
llvm.x86.avx512.prol.d.256
llvm.x86.avx512.prol.d.512
llvm.x86.avx512.prol.q.128
llvm.x86.avx512.prol.q.256
llvm.x86.avx512.prol.q.512
llvm.x86.avx512.prolv.d.128
llvm.x86.avx512.prolv.d.256
llvm.x86.avx512.prolv.d.512
llvm.x86.avx512.prolv.q.128
llvm.x86.avx512.prolv.q.256
llvm.x86.avx512.prolv.q.512
llvm.x86.avx512.pror.d.128
llvm.x86.avx512.pror.d.256
llvm.x86.avx512.pror.d.512
llvm.x86.avx512.pror.q.128
llvm.x86.avx512.pror.q.256
llvm.x86.avx512.pror.q.512
llvm.x86.avx512.prorv.d.128
llvm.x86.avx512.prorv.d.256
llvm.x86.avx512.prorv.d.512
llvm.x86.avx512.prorv.q.128
llvm.x86.avx512.prorv.q.256
llvm.x86.avx512.prorv.q.512
llvm.x86.avx512.psad.bw.512
llvm.x86.avx512.pshuf.b.512
llvm.x86.avx512.psll.d.512
llvm.x86.avx512.psll.q.512
llvm.x86.avx512.psll.w.512
llvm.x86.avx512.pslli.d.512
llvm.x86.avx512.pslli.q.512
llvm.x86.avx512.pslli.w.512
llvm.x86.avx512.psllv.d.512
llvm.x86.avx512.psllv.q.512
llvm.x86.avx512.psllv.w.128
llvm.x86.avx512.psllv.w.256
llvm.x86.avx512.psllv.w.512
llvm.x86.avx512.psra.d.512
llvm.x86.avx512.psra.q.128
llvm.x86.avx512.psra.q.256
llvm.x86.avx512.psra.q.512
llvm.x86.avx512.psra.w.512
llvm.x86.avx512.psrai.d.512
llvm.x86.avx512.psrai.q.128
llvm.x86.avx512.psrai.q.256
llvm.x86.avx512.psrai.q.512
llvm.x86.avx512.psrai.w.512
llvm.x86.avx512.psrav.d.512
llvm.x86.avx512.psrav.q.128
llvm.x86.avx512.psrav.q.256
llvm.x86.avx512.psrav.q.512
llvm.x86.avx512.psrav.w.128
llvm.x86.avx512.psrav.w.256
llvm.x86.avx512.psrav.w.512
llvm.x86.avx512.psrl.d.512
llvm.x86.avx512.psrl.q.512
llvm.x86.avx512.psrl.w.512
llvm.x86.avx512.psrli.d.512
llvm.x86.avx512.psrli.q.512
llvm.x86.avx512.psrli.w.512
llvm.x86.avx512.psrlv.d.512
llvm.x86.avx512.psrlv.q.512
llvm.x86.avx512.psrlv.w.128
llvm.x86.avx512.psrlv.w.256
llvm.x86.avx512.psrlv.w.512
llvm.x86.avx512.pternlog.d.128
llvm.x86.avx512.pternlog.d.256
llvm.x86.avx512.pternlog.d.512
llvm.x86.avx512.pternlog.q.128
llvm.x86.avx512.pternlog.q.256
llvm.x86.avx512.pternlog.q.512
llvm.x86.avx512.rcp14.pd.128
llvm.x86.avx512.rcp14.pd.256
llvm.x86.avx512.rcp14.pd.512
llvm.x86.avx512.rcp14.ps.128
llvm.x86.avx512.rcp14.ps.256
llvm.x86.avx512.rcp14.ps.512
llvm.x86.avx512.rcp14.sd
llvm.x86.avx512.rcp14.ss
llvm.x86.avx512.rcp28.pd
llvm.x86.avx512.rcp28.ps
llvm.x86.avx512.rcp28.sd
llvm.x86.avx512.rcp28.ss
llvm.x86.avx512.rsqrt14.pd.128
llvm.x86.avx512.rsqrt14.pd.256
llvm.x86.avx512.rsqrt14.pd.512
llvm.x86.avx512.rsqrt14.ps.128
llvm.x86.avx512.rsqrt14.ps.256
llvm.x86.avx512.rsqrt14.ps.512
llvm.x86.avx512.rsqrt14.sd
llvm.x86.avx512.rsqrt14.ss
llvm.x86.avx512.rsqrt28.pd
llvm.x86.avx512.rsqrt28.ps
llvm.x86.avx512.rsqrt28.sd
llvm.x86.avx512.rsqrt28.ss
llvm.x86.avx512.scatter.dpd.512
llvm.x86.avx512.scatter.dpi.512
llvm.x86.avx512.scatter.dpq.512
llvm.x86.avx512.scatter.dps.512
llvm.x86.avx512.scatter.qpd.512
llvm.x86.avx512.scatter.qpi.512
llvm.x86.avx512.scatter.qpq.512
llvm.x86.avx512.scatter.qps.512
llvm.x86.avx512.scatterdiv2.df
llvm.x86.avx512.scatterdiv2.di
llvm.x86.avx512.scatterdiv4.df
llvm.x86.avx512.scatterdiv4.di
llvm.x86.avx512.scatterdiv4.sf
llvm.x86.avx512.scatterdiv4.si
llvm.x86.avx512.scatterdiv8.sf
llvm.x86.avx512.scatterdiv8.si
llvm.x86.avx512.scatterpf.dpd.512
llvm.x86.avx512.scatterpf.dps.512
llvm.x86.avx512.scatterpf.qpd.512
llvm.x86.avx512.scatterpf.qps.512
llvm.x86.avx512.scattersiv2.df
llvm.x86.avx512.scattersiv2.di
llvm.x86.avx512.scattersiv4.df
llvm.x86.avx512.scattersiv4.di
llvm.x86.avx512.scattersiv4.sf
llvm.x86.avx512.scattersiv4.si
llvm.x86.avx512.scattersiv8.sf
llvm.x86.avx512.scattersiv8.si
llvm.x86.avx512.sqrt.pd.512
llvm.x86.avx512.sqrt.ps.512
llvm.x86.avx512.sub.pd.512
llvm.x86.avx512.sub.ps.512
llvm.x86.avx512.vcomi.sd
llvm.x86.avx512.vcomi.ss
llvm.x86.avx512.vcvtsd2si32
llvm.x86.avx512.vcvtsd2si64
llvm.x86.avx512.vcvtsd2usi32
llvm.x86.avx512.vcvtsd2usi64
llvm.x86.avx512.vcvtss2si32
llvm.x86.avx512.vcvtss2si64
llvm.x86.avx512.vcvtss2usi32
llvm.x86.avx512.vcvtss2usi64
llvm.x86.avx512.vfmadd.f32
llvm.x86.avx512.vfmadd.f64
llvm.x86.avx512.vfmadd.pd.512
llvm.x86.avx512.vfmadd.ps.512
llvm.x86.avx512.vfmaddsub.pd.512
llvm.x86.avx512.vfmaddsub.ps.512
llvm.x86.avx512.vpdpbusd.128
llvm.x86.avx512.vpdpbusd.256
llvm.x86.avx512.vpdpbusd.512
llvm.x86.avx512.vpdpbusds.128
llvm.x86.avx512.vpdpbusds.256
llvm.x86.avx512.vpdpbusds.512
llvm.x86.avx512.vpdpwssd.128
llvm.x86.avx512.vpdpwssd.256
llvm.x86.avx512.vpdpwssd.512
llvm.x86.avx512.vpdpwssds.128
llvm.x86.avx512.vpdpwssds.256
llvm.x86.avx512.vpdpwssds.512
llvm.x86.avx512.vpermi2var.d.128
llvm.x86.avx512.vpermi2var.d.256
llvm.x86.avx512.vpermi2var.d.512
llvm.x86.avx512.vpermi2var.hi.128
llvm.x86.avx512.vpermi2var.hi.256
llvm.x86.avx512.vpermi2var.hi.512
llvm.x86.avx512.vpermi2var.pd.128
llvm.x86.avx512.vpermi2var.pd.256
llvm.x86.avx512.vpermi2var.pd.512
llvm.x86.avx512.vpermi2var.ps.128
llvm.x86.avx512.vpermi2var.ps.256
llvm.x86.avx512.vpermi2var.ps.512
llvm.x86.avx512.vpermi2var.q.128
llvm.x86.avx512.vpermi2var.q.256
llvm.x86.avx512.vpermi2var.q.512
llvm.x86.avx512.vpermi2var.qi.128
llvm.x86.avx512.vpermi2var.qi.256
llvm.x86.avx512.vpermi2var.qi.512
llvm.x86.avx512.vpermilvar.pd.512
llvm.x86.avx512.vpermilvar.ps.512
llvm.x86.avx512.vpmadd52h.uq.128
llvm.x86.avx512.vpmadd52h.uq.256
llvm.x86.avx512.vpmadd52h.uq.512
llvm.x86.avx512.vpmadd52l.uq.128
llvm.x86.avx512.vpmadd52l.uq.256
llvm.x86.avx512.vpmadd52l.uq.512
llvm.x86.avx512.vpshld.d.128
llvm.x86.avx512.vpshld.d.256
llvm.x86.avx512.vpshld.d.512
llvm.x86.avx512.vpshld.q.128
llvm.x86.avx512.vpshld.q.256
llvm.x86.avx512.vpshld.q.512
llvm.x86.avx512.vpshld.w.128
llvm.x86.avx512.vpshld.w.256
llvm.x86.avx512.vpshld.w.512
llvm.x86.avx512.vpshrd.d.128
llvm.x86.avx512.vpshrd.d.256
llvm.x86.avx512.vpshrd.d.512
llvm.x86.avx512.vpshrd.q.128
llvm.x86.avx512.vpshrd.q.256
llvm.x86.avx512.vpshrd.q.512
llvm.x86.avx512.vpshrd.w.128
llvm.x86.avx512.vpshrd.w.256
llvm.x86.avx512.vpshrd.w.512
llvm.x86.bmi.bextr.32
llvm.x86.bmi.bextr.64
llvm.x86.bmi.bzhi.32
llvm.x86.bmi.bzhi.64
llvm.x86.bmi.pdep.32
llvm.x86.bmi.pdep.64
llvm.x86.bmi.pext.32
llvm.x86.bmi.pext.64
llvm.x86.cldemote
llvm.x86.clflushopt
llvm.x86.clrssbsy
llvm.x86.clwb
llvm.x86.clzero
llvm.x86.directstore32
llvm.x86.directstore64
llvm.x86.flags.read.u32
llvm.x86.flags.read.u64
llvm.x86.flags.write.u32
llvm.x86.flags.write.u64
llvm.x86.fxrstor
llvm.x86.fxrstor64
llvm.x86.fxsave
llvm.x86.fxsave64
llvm.x86.incsspd
llvm.x86.incsspq
llvm.x86.int
llvm.x86.invpcid
llvm.x86.llwpcb
llvm.x86.lwpins32
llvm.x86.lwpins64
llvm.x86.lwpval32
llvm.x86.lwpval64
llvm.x86.mmx.emms
llvm.x86.mmx.femms
llvm.x86.mmx.maskmovq
llvm.x86.mmx.movnt.dq
llvm.x86.mmx.packssdw
llvm.x86.mmx.packsswb
llvm.x86.mmx.packuswb
llvm.x86.mmx.padd.b
llvm.x86.mmx.padd.d
llvm.x86.mmx.padd.q
llvm.x86.mmx.padd.w
llvm.x86.mmx.padds.b
llvm.x86.mmx.padds.w
llvm.x86.mmx.paddus.b
llvm.x86.mmx.paddus.w
llvm.x86.mmx.palignr.b
llvm.x86.mmx.pand
llvm.x86.mmx.pandn
llvm.x86.mmx.pavg.b
llvm.x86.mmx.pavg.w
llvm.x86.mmx.pcmpeq.b
llvm.x86.mmx.pcmpeq.d
llvm.x86.mmx.pcmpeq.w
llvm.x86.mmx.pcmpgt.b
llvm.x86.mmx.pcmpgt.d
llvm.x86.mmx.pcmpgt.w
llvm.x86.mmx.pextr.w
llvm.x86.mmx.pinsr.w
llvm.x86.mmx.pmadd.wd
llvm.x86.mmx.pmaxs.w
llvm.x86.mmx.pmaxu.b
llvm.x86.mmx.pmins.w
llvm.x86.mmx.pminu.b
llvm.x86.mmx.pmovmskb
llvm.x86.mmx.pmulh.w
llvm.x86.mmx.pmulhu.w
llvm.x86.mmx.pmull.w
llvm.x86.mmx.pmulu.dq
llvm.x86.mmx.por
llvm.x86.mmx.psad.bw
llvm.x86.mmx.psll.d
llvm.x86.mmx.psll.q
llvm.x86.mmx.psll.w
llvm.x86.mmx.pslli.d
llvm.x86.mmx.pslli.q
llvm.x86.mmx.pslli.w
llvm.x86.mmx.psra.d
llvm.x86.mmx.psra.w
llvm.x86.mmx.psrai.d
llvm.x86.mmx.psrai.w
llvm.x86.mmx.psrl.d
llvm.x86.mmx.psrl.q
llvm.x86.mmx.psrl.w
llvm.x86.mmx.psrli.d
llvm.x86.mmx.psrli.q
llvm.x86.mmx.psrli.w
llvm.x86.mmx.psub.b
llvm.x86.mmx.psub.d
llvm.x86.mmx.psub.q
llvm.x86.mmx.psub.w
llvm.x86.mmx.psubs.b
llvm.x86.mmx.psubs.w
llvm.x86.mmx.psubus.b
llvm.x86.mmx.psubus.w
llvm.x86.mmx.punpckhbw
llvm.x86.mmx.punpckhdq
llvm.x86.mmx.punpckhwd
llvm.x86.mmx.punpcklbw
llvm.x86.mmx.punpckldq
llvm.x86.mmx.punpcklwd
llvm.x86.mmx.pxor
llvm.x86.monitorx
llvm.x86.movdir64b
llvm.x86.mwaitx
llvm.x86.pclmulqdq
llvm.x86.pclmulqdq.256
llvm.x86.pclmulqdq.512
llvm.x86.ptwrite32
llvm.x86.ptwrite64
llvm.x86.rdfsbase.32
llvm.x86.rdfsbase.64
llvm.x86.rdgsbase.32
llvm.x86.rdgsbase.64
llvm.x86.rdpid
llvm.x86.rdpkru
llvm.x86.rdpmc
llvm.x86.rdrand.16
llvm.x86.rdrand.32
llvm.x86.rdrand.64
llvm.x86.rdseed.16
llvm.x86.rdseed.32
llvm.x86.rdseed.64
llvm.x86.rdsspd
llvm.x86.rdsspq
llvm.x86.rdtsc
llvm.x86.rdtscp
llvm.x86.rstorssp
llvm.x86.saveprevssp
llvm.x86.seh.ehguard
llvm.x86.seh.ehregnode
llvm.x86.seh.lsda
llvm.x86.seh.recoverfp
llvm.x86.setssbsy
llvm.x86.sha1msg1
llvm.x86.sha1msg2
llvm.x86.sha1nexte
llvm.x86.sha1rnds4
llvm.x86.sha256msg1
llvm.x86.sha256msg2
llvm.x86.sha256rnds2
llvm.x86.slwpcb
llvm.x86.sse.cmp.ps
llvm.x86.sse.cmp.ss
llvm.x86.sse.comieq.ss
llvm.x86.sse.comige.ss
llvm.x86.sse.comigt.ss
llvm.x86.sse.comile.ss
llvm.x86.sse.comilt.ss
llvm.x86.sse.comineq.ss
llvm.x86.sse.cvtpd2pi
llvm.x86.sse.cvtpi2pd
llvm.x86.sse.cvtpi2ps
llvm.x86.sse.cvtps2pi
llvm.x86.sse.cvtss2si
llvm.x86.sse.cvtss2si64
llvm.x86.sse.cvttpd2pi
llvm.x86.sse.cvttps2pi
llvm.x86.sse.cvttss2si
llvm.x86.sse.cvttss2si64
llvm.x86.sse.ldmxcsr
llvm.x86.sse.max.ps
llvm.x86.sse.max.ss
llvm.x86.sse.min.ps
llvm.x86.sse.min.ss
llvm.x86.sse.movmsk.ps
llvm.x86.sse.pshuf.w
llvm.x86.sse.rcp.ps
llvm.x86.sse.rcp.ss
llvm.x86.sse.rsqrt.ps
llvm.x86.sse.rsqrt.ss
llvm.x86.sse.sfence
llvm.x86.sse.stmxcsr
llvm.x86.sse.ucomieq.ss
llvm.x86.sse.ucomige.ss
llvm.x86.sse.ucomigt.ss
llvm.x86.sse.ucomile.ss
llvm.x86.sse.ucomilt.ss
llvm.x86.sse.ucomineq.ss
llvm.x86.sse2.clflush
llvm.x86.sse2.cmp.pd
llvm.x86.sse2.cmp.sd
llvm.x86.sse2.comieq.sd
llvm.x86.sse2.comige.sd
llvm.x86.sse2.comigt.sd
llvm.x86.sse2.comile.sd
llvm.x86.sse2.comilt.sd
llvm.x86.sse2.comineq.sd
llvm.x86.sse2.cvtpd2dq
llvm.x86.sse2.cvtpd2ps
llvm.x86.sse2.cvtps2dq
llvm.x86.sse2.cvtsd2si
llvm.x86.sse2.cvtsd2si64
llvm.x86.sse2.cvtsd2ss
llvm.x86.sse2.cvttpd2dq
llvm.x86.sse2.cvttps2dq
llvm.x86.sse2.cvttsd2si
llvm.x86.sse2.cvttsd2si64
llvm.x86.sse2.lfence
llvm.x86.sse2.maskmov.dqu
llvm.x86.sse2.max.pd
llvm.x86.sse2.max.sd
llvm.x86.sse2.mfence
llvm.x86.sse2.min.pd
llvm.x86.sse2.min.sd
llvm.x86.sse2.movmsk.pd
llvm.x86.sse2.packssdw.128
llvm.x86.sse2.packsswb.128
llvm.x86.sse2.packuswb.128
llvm.x86.sse2.padds.b
llvm.x86.sse2.padds.w
llvm.x86.sse2.paddus.b
llvm.x86.sse2.paddus.w
llvm.x86.sse2.pause
llvm.x86.sse2.pmadd.wd
llvm.x86.sse2.pmovmskb.128
llvm.x86.sse2.pmulh.w
llvm.x86.sse2.pmulhu.w
llvm.x86.sse2.psad.bw
llvm.x86.sse2.psll.d
llvm.x86.sse2.psll.q
llvm.x86.sse2.psll.w
llvm.x86.sse2.pslli.d
llvm.x86.sse2.pslli.q
llvm.x86.sse2.pslli.w
llvm.x86.sse2.psra.d
llvm.x86.sse2.psra.w
llvm.x86.sse2.psrai.d
llvm.x86.sse2.psrai.w
llvm.x86.sse2.psrl.d
llvm.x86.sse2.psrl.q
llvm.x86.sse2.psrl.w
llvm.x86.sse2.psrli.d
llvm.x86.sse2.psrli.q
llvm.x86.sse2.psrli.w
llvm.x86.sse2.psubs.b
llvm.x86.sse2.psubs.w
llvm.x86.sse2.psubus.b
llvm.x86.sse2.psubus.w
llvm.x86.sse2.ucomieq.sd
llvm.x86.sse2.ucomige.sd
llvm.x86.sse2.ucomigt.sd
llvm.x86.sse2.ucomile.sd
llvm.x86.sse2.ucomilt.sd
llvm.x86.sse2.ucomineq.sd
llvm.x86.sse3.addsub.pd
llvm.x86.sse3.addsub.ps
llvm.x86.sse3.hadd.pd
llvm.x86.sse3.hadd.ps
llvm.x86.sse3.hsub.pd
llvm.x86.sse3.hsub.ps
llvm.x86.sse3.ldu.dq
llvm.x86.sse3.monitor
llvm.x86.sse3.mwait
llvm.x86.sse41.blendvpd
llvm.x86.sse41.blendvps
llvm.x86.sse41.dppd
llvm.x86.sse41.dpps
llvm.x86.sse41.insertps
llvm.x86.sse41.mpsadbw
llvm.x86.sse41.packusdw
llvm.x86.sse41.pblendvb
llvm.x86.sse41.phminposuw
llvm.x86.sse41.ptestc
llvm.x86.sse41.ptestnzc
llvm.x86.sse41.ptestz
llvm.x86.sse41.round.pd
llvm.x86.sse41.round.ps
llvm.x86.sse41.round.sd
llvm.x86.sse41.round.ss
llvm.x86.sse42.crc32.32.16
llvm.x86.sse42.crc32.32.32
llvm.x86.sse42.crc32.32.8
llvm.x86.sse42.crc32.64.64
llvm.x86.sse42.pcmpestri128
llvm.x86.sse42.pcmpestria128
llvm.x86.sse42.pcmpestric128
llvm.x86.sse42.pcmpestrio128
llvm.x86.sse42.pcmpestris128
llvm.x86.sse42.pcmpestriz128
llvm.x86.sse42.pcmpestrm128
llvm.x86.sse42.pcmpistri128
llvm.x86.sse42.pcmpistria128
llvm.x86.sse42.pcmpistric128
llvm.x86.sse42.pcmpistrio128
llvm.x86.sse42.pcmpistris128
llvm.x86.sse42.pcmpistriz128
llvm.x86.sse42.pcmpistrm128
llvm.x86.sse4a.extrq
llvm.x86.sse4a.extrqi
llvm.x86.sse4a.insertq
llvm.x86.sse4a.insertqi
llvm.x86.ssse3.pabs.b
llvm.x86.ssse3.pabs.d
llvm.x86.ssse3.pabs.w
llvm.x86.ssse3.phadd.d
llvm.x86.ssse3.phadd.d.128
llvm.x86.ssse3.phadd.sw
llvm.x86.ssse3.phadd.sw.128
llvm.x86.ssse3.phadd.w
llvm.x86.ssse3.phadd.w.128
llvm.x86.ssse3.phsub.d
llvm.x86.ssse3.phsub.d.128
llvm.x86.ssse3.phsub.sw
llvm.x86.ssse3.phsub.sw.128
llvm.x86.ssse3.phsub.w
llvm.x86.ssse3.phsub.w.128
llvm.x86.ssse3.pmadd.ub.sw
llvm.x86.ssse3.pmadd.ub.sw.128
llvm.x86.ssse3.pmul.hr.sw
llvm.x86.ssse3.pmul.hr.sw.128
llvm.x86.ssse3.pshuf.b
llvm.x86.ssse3.pshuf.b.128
llvm.x86.ssse3.psign.b
llvm.x86.ssse3.psign.b.128
llvm.x86.ssse3.psign.d
llvm.x86.ssse3.psign.d.128
llvm.x86.ssse3.psign.w
llvm.x86.ssse3.psign.w.128
llvm.x86.subborrow.u32
llvm.x86.subborrow.u64
llvm.x86.tbm.bextri.u32
llvm.x86.tbm.bextri.u64
llvm.x86.tpause
llvm.x86.umonitor
llvm.x86.umwait
llvm.x86.vcvtph2ps.128
llvm.x86.vcvtph2ps.256
llvm.x86.vcvtps2ph.128
llvm.x86.vcvtps2ph.256
llvm.x86.vgf2p8affineinvqb.128
llvm.x86.vgf2p8affineinvqb.256
llvm.x86.vgf2p8affineinvqb.512
llvm.x86.vgf2p8affineqb.128
llvm.x86.vgf2p8affineqb.256
llvm.x86.vgf2p8affineqb.512
llvm.x86.vgf2p8mulb.128
llvm.x86.vgf2p8mulb.256
llvm.x86.vgf2p8mulb.512
llvm.x86.wbinvd
llvm.x86.wbnoinvd
llvm.x86.wrfsbase.32
llvm.x86.wrfsbase.64
llvm.x86.wrgsbase.32
llvm.x86.wrgsbase.64
llvm.x86.wrpkru
llvm.x86.wrssd
llvm.x86.wrssq
llvm.x86.wrussd
llvm.x86.wrussq
llvm.x86.xabort
llvm.x86.xbegin
llvm.x86.xend
llvm.x86.xgetbv
llvm.x86.xop.vfrcz.pd
llvm.x86.xop.vfrcz.pd.256
llvm.x86.xop.vfrcz.ps
llvm.x86.xop.vfrcz.ps.256
llvm.x86.xop.vfrcz.sd
llvm.x86.xop.vfrcz.ss
llvm.x86.xop.vpcomb
llvm.x86.xop.vpcomd
llvm.x86.xop.vpcomq
llvm.x86.xop.vpcomub
llvm.x86.xop.vpcomud
llvm.x86.xop.vpcomuq
llvm.x86.xop.vpcomuw
llvm.x86.xop.vpcomw
llvm.x86.xop.vpermil2pd
llvm.x86.xop.vpermil2pd.256
llvm.x86.xop.vpermil2ps
llvm.x86.xop.vpermil2ps.256
llvm.x86.xop.vphaddbd
llvm.x86.xop.vphaddbq
llvm.x86.xop.vphaddbw
llvm.x86.xop.vphadddq
llvm.x86.xop.vphaddubd
llvm.x86.xop.vphaddubq
llvm.x86.xop.vphaddubw
llvm.x86.xop.vphaddudq
llvm.x86.xop.vphadduwd
llvm.x86.xop.vphadduwq
llvm.x86.xop.vphaddwd
llvm.x86.xop.vphaddwq
llvm.x86.xop.vphsubbw
llvm.x86.xop.vphsubdq
llvm.x86.xop.vphsubwd
llvm.x86.xop.vpmacsdd
llvm.x86.xop.vpmacsdqh
llvm.x86.xop.vpmacsdql
llvm.x86.xop.vpmacssdd
llvm.x86.xop.vpmacssdqh
llvm.x86.xop.vpmacssdql
llvm.x86.xop.vpmacsswd
llvm.x86.xop.vpmacssww
llvm.x86.xop.vpmacswd
llvm.x86.xop.vpmacsww
llvm.x86.xop.vpmadcsswd
llvm.x86.xop.vpmadcswd
llvm.x86.xop.vpperm
llvm.x86.xop.vprotb
llvm.x86.xop.vprotbi
llvm.x86.xop.vprotd
llvm.x86.xop.vprotdi
llvm.x86.xop.vprotq
llvm.x86.xop.vprotqi
llvm.x86.xop.vprotw
llvm.x86.xop.vprotwi
llvm.x86.xop.vpshab
llvm.x86.xop.vpshad
llvm.x86.xop.vpshaq
llvm.x86.xop.vpshaw
llvm.x86.xop.vpshlb
llvm.x86.xop.vpshld
llvm.x86.xop.vpshlq
llvm.x86.xop.vpshlw
llvm.x86.xrstor
llvm.x86.xrstor64
llvm.x86.xrstors
llvm.x86.xrstors64
llvm.x86.xsave
llvm.x86.xsave64
llvm.x86.xsavec
llvm.x86.xsavec64
llvm.x86.xsaveopt
llvm.x86.xsaveopt64
llvm.x86.xsaves
llvm.x86.xsaves64
llvm.x86.xsetbv
llvm.x86.xtest
llvm.xcore.bitrev
llvm.xcore.checkevent
llvm.xcore.chkct
llvm.xcore.clre
llvm.xcore.clrpt
llvm.xcore.clrsr
llvm.xcore.crc32
llvm.xcore.crc8
llvm.xcore.edu
llvm.xcore.eeu
llvm.xcore.endin
llvm.xcore.freer
llvm.xcore.geted
llvm.xcore.getet
llvm.xcore.getid
llvm.xcore.getps
llvm.xcore.getr
llvm.xcore.getst
llvm.xcore.getts
llvm.xcore.in
llvm.xcore.inct
llvm.xcore.initcp
llvm.xcore.initdp
llvm.xcore.initlr
llvm.xcore.initpc
llvm.xcore.initsp
llvm.xcore.inshr
llvm.xcore.int
llvm.xcore.mjoin
llvm.xcore.msync
llvm.xcore.out
llvm.xcore.outct
llvm.xcore.outshr
llvm.xcore.outt
llvm.xcore.peek
llvm.xcore.setc
llvm.xcore.setclk
llvm.xcore.setd
llvm.xcore.setev
llvm.xcore.setps
llvm.xcore.setpsc
llvm.xcore.setpt
llvm.xcore.setrdy
llvm.xcore.setsr
llvm.xcore.settw
llvm.xcore.setv
llvm.xcore.sext
llvm.xcore.ssync
llvm.xcore.syncr
llvm.xcore.testct
llvm.xcore.testwct
llvm.xcore.waitevent
llvm.xcore.zext
fmin
fminl
sinf
gen-tti-dummy-pass
Translate ACL Printf
kernel_arg_type_qual
Fixup extractvalue pairs
intel_reqd_workgroup_walk_order
(unknown)
  Default target: 
  Host CPU: 
number
string
////////
\\\\\\\\\\\\\\\\2)
!"#$
)*+,
N3iga11SyntaxErrorE
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
8 .@
8@.`
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
pppp
8 .@
8@.`
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
pppp
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
,I .@
,I@.`
,I`.
,I .
,I@.
,I`.
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
$K %
$K@$
$K`$
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
lyRoundedDivSqrtCorrectlyRoundedFloatRoundingMode
athOptimizationsUnsafeMathOptimiacePrivateMemoryUseScratchSpacePGreaterThan2GBBuGreaterThan4GBBuhConstantsEnablePushConstantsEnaHasBufferOffsetArg
balOffsetsByZeroreplaceGlobalOffSIMDMode
forcePixelShaderoNotAbortOnSpillpixelShaderDoNotComponentPackingdisableVertexComages
PreferBindlessImeMathRefactoringdisableMathRefacworkGroupWalkOrder
ferLocationIndexbufferLocationInferLocationCountbufferLocationCoType
NumberOfFunctioninlineSamplersMDdSubGroupsNumberCompiledSubGrouplers
hasInlineVmeSampprivateMemoryPerWI
ctToDirectCalleeindirectToDirectssSpaces
m_OpenCLArgAddreAccessQualifiersm_OpenCLArgAccesm_OpenCLArgTypesypes
m_OpenCLArgBaseTrgTypeQualifiersm_OpenCLArgTypeQm_OpenCLArgNamespushableAddresses
dBuffers
MaxNumberOfPushefferSlot
tantBufferOffsettBufferGRFOffsetsimplePushInfoArr
Used
simplePushBufferhAnalysisWIInfospushAnalysisWIInirectBufferIndexDrawIndirectBufftateDisabledMaskBlendStateDisablBlendingDisabledDualSourceBlendiForceEnableSimd32
blendToFillEnabled
hasVersionedLoopetiveInterpolanthasNonPerspetiveOptimizationModeblendOptimizatiomaxWorkGroupSizederSecondCompileComputeShaderSecl_ResWidthHeightruntimeVal_ResWiount
runtimeVal_LoopCnstantBufferSizeruntimeVal_ConstultipleSIMDModesallowMultipleSIMcheduler
forcedVISAPreRASirection
EnableTextureIndEnableSamplerIndsamplerStateStride
samplerStateOffset
textureStateStritextureStateOffsinlineDynConstants
inlineDynTextureeConstantBuffersineGlobalBuffersinlineGlobalBuffogramBinaryInfosGlobalPointerProPushConstantSizeMinNOSPushConstagramScopeOffsetsinlineProgramScoertexHeaderInputerOutput
UseBindlessImageourcesNotAliasedstatefullResourcSMemorySizePerWItotalTLSMemorySiglobalDataUniform
GlobalDataAccesshasGlobalDataAccNormalizedCoordsinterpolationModPointerBufferIndex
nteeAddressSpacePointeeAddressSpPointeeBufferInd
pler_initializer__translate_samp__builtin_spirv_
size
hint
_air.read_textureair.write_texturair.get_array_size
t_num_mip_levelsair.get_num_mip__num_samples.i32air.get_num_samp_samples_textureum_samples_depthlate_clamped_lodair.calculate_clte_unclamped_lodair.calculate_unhannel_data_typeair.get_channel_et_channel_orderture
air.get_null_texair.get_null_depth
.is_null_textureair.is_null_textair.is_null_depth
air.fence_texturexplicit_textureair.atomic_load_air.extract_bitsair.reverse_bitsair.fast_fmedian3
identifier_depthair.get_unique_ishuffle_rotate_up
ffle_rotate_downshuffle_rotate_dive_threads_maskactive_threads_mis_helper_threadterpolate_centercentroid
terpolate_sampleterpolate_offset_icb
igc.air.indirect_pso
_sample_positionair.get_sample_p
__FastRelaxedMat
.indirect_bufferair.indirect_bufinfo
air.struct_type_n_function_tableair.intersectiontrol_point_inputair.patch_controndirect_constantair.indirect_conair.command_bufft_command_bufferair.indirect_comr_pipeline_stateair.render_pipele_pipeline_stateair.compute_pipee_function_tableair.visible_func.imageblock_dataair.imageblock_dlification_countair.amplification_id
nter
air.function_poimageblock_masterair.imageblock_mata_size
_type_align_sizeair.arg_type_aliair.location_indair.arg_type_namair.arg_type_sizster_order_groupair.raster_orderair.render_target
ndirect_argumentair.indirect_arg
NSt3__117bad_function_callE
eric
air.lgamma_r.genlag_begin_marker__flag_begin_mar__flag_end_marke_compute_commandair.set_barrier_.dyld_flat_tableair.dyld_flat_ta
e_in_grid_originair.get_global_id
_local_linear_idair.get_local_li
air.kernel
air.vertex
air.version
air.language_version
air.compile_options
air.location_index
air.read
air.write
air.read_write
air.sample
air.buffer_size
air.arg_type_name
air.arg_type_size
air.arg_type_align_size
air.arg_name
air.emulation_argument
ests
early_fragment_tair.fragment_input
ay_index
air.viewport_arrd_origin
air.stage_in_gri_instance_strideair.tessellationposition_in_gridair.threadgroup_age_in_grid_sizeaccessible_inputair.inaccessiblesellation_factorair.inside_tesseint_index_bufferair.control_poin_per_threadgroupair.simdgroups_pair.quadgroups_pair.edge_tessellgrid
air.threads_per_air.base_instancair.buffer_stridrget_array_indexion_factor_scaleex_buffer_offsetair.patch_index_dex_in_simdgroupair.thread_indexdex_in_quadgrouparycentric_coordair.barycentric_osition_in_patchair.position_in_r_command_bufferair.render_commadgroups_per_gridair.threadgroupsds_per_simdgroupair.thread_positx_in_threadgroupe_command_bufferair.compute_comm_execution_widthair.thread_execu.default_uniformair.default_unifair.vertex_inputair.front_facingair.primitive_idair.sample_mask_in
.depth_unchangedair.depth_unchanair.clip_distancair.depth_greateair.vertex_outpuair.partitioningch_control_point_work_group_sizeair.max_work_grove_double_enableair.compile.nati.denorms_disablee.denorms_enableast_math_disablefast_math_disabl
.loop.peel.countspv.loop.peel.cop.iterations.maxspv.loop.iterati
-fast-relaxed-math-optimizations-unsafe-math-opt-no-signed-zeros-denorms-are-zero
-finite-math-only
-relaxed-builtinimage1d_buffer_timage2d_buffer_taa_t
ray_msaa_depth_tth_t
image2d_msaa_dep2d_array_depth_timage2d_array_deenqueuedLocalSiz
ltin_IB_to_localin_IB_to_private
ffffff
eue_kernel_basicue_kernel_vaargsel_events_vaargsel
__builtin_IB_kmp_
ivre
precompiled_s32dprecompiled_u32d
iled_s32divrem_siled_u32divrem_s__igcbuiltin_sp_di
b0$IY
2$IB
(CUUd
P$v`
clang version 4.0.1 #
cs)s
c+s1
       
ELzA
E`XB
C8QM_A
A45n0
PV~5
dPB0
1KpTd]
,A1PA
nx:0
L&SHT
t,>b&
T>b8
>b3
T>b/
WdPB0
1KpTd]A
$;KPT
7<{
[M"0OM
T>q!
B?5 
N"QA
#>bV
@A4S
J"8Me
K"8Mu
DdK
#>rR
#>bQ
#5nO
#>b1
#uoC
WdPB0
1KpTd]a
$;KPT
7<{
,A5P
3PAT
$;K0
"8Mu
#7of
LfsHT
#>bN
#8n9
#>bk
T>q!
B?5 
@A4S
J"8Me
K"8Mu
#wo_
#vo3
"8Mu
#9o7
#>bR
#yo+
T>q!Sn
#zmK
B?5 
DdL
#zoS
#>b1
#&sHG
#>bO
WdPB0
1KpTd]
A0PAT
\@Jp
,AtC
WdPB0
`aA
$c0s
XT#0OM
#vo:
#7oa
"0OM
 )>
#>bb
#>bI
=1@3
B?5 
#xnG
#8Me
#8Me
U#QA
a@#Q
B?5 
B?5 
2Y^#8M
#>bi
#0OM
WdPB0
1KpTd]
,A1PA
+2(!
@+ v
BX(e
24J0K
D7dpE
2LRPB
+2(!
A+ v
2lX0K
WdPB0
H7PATa`"]
&Tb
B+ v
Pm0PA n
Tc!5
ba5
lC+ v
Gm2
B?5 
@ITP
#8Me
#8M
#>r0h
T>q!
Dd4
z@$8M
 )>
#8Mu
 )>
S#8M
T>q!
T>q!
Q#QA
B?5 
#ynS
#>bj
Xi@#
r@$QA
 )>
$8Mu
#>bW
#8Me
 )>
Y9@3
d@$QA
m9NT
B?5 
Y#8M
#F%IG
 )>
B?5 
#{nl
#w~.
#8Mu
B?5 
c!@ H
WdPB0
1KpTd]
%DQm`\
,AtC
WdPB0
$c0s
|7dpE
%DQ7a\
`. b
7<y
1hA\
`. b
1hAy2
Td]
%DQ#b\
`. b
7<e
pC`&d0
,A+Td
%DQwb\
`. b
,A.T
0PA 
FF+ v
~!(!
0PA 
fAmhf
F+ v
3:`0
@$0OM
$8Me
#>rD
T>q!
#>r0j
T>q!
B?5 
Dt5
#V/@
#>rB
$8Mu
V$8Mu
$8Mu
%8Me
v@$8M
#&;P
@A4S
#>r[b
T>q!
#7@Y
Dtid
T>q!
`@$QA
 )>
Xp@$8M
B?5 
#f;`
$0OM
 )>
Dd}
#v;`
B?5 
 )>
XZ$QA
#|~.
#F/P
#>b|
#>rNd`
%0OM
%0OM
#6-0
 )>
/P9Q
%8Me
#8~f
B?5 
u~aj
B?5 
#v9@
;@IG
&8Mu
$8Me
LV=p
 )>
809Q
T>q!
;@IT
B?5 
f@$Q
 )>
j@$8Mu
#G0!
B?5 
#>r'
}ce`
B?5 
PV~5
dPBP
1KPTd
D4`A
L7LTPC
nX20
T>q!
 )>b+
t,>b&
tD>r
A4>b.
#vRD
WdPBP
1KPTd
+2(!
V0*0
2PAh
#VsHT
#>b7
#umE
#5n.
#>b8
#>b+GD0>
 )>
O"8M
WdPBP
1KPTd
+2(!
V0*0
2PAh
,AsC
WdPBP
TdU
#wmI
M[W"
Dd4
#>b5
#wo7
L6c8
>q!
J"8Me
#9mAID0>
#ym.
#>b8
#>bK
#:mF
K"8M
>q!
#yo6
"8Me
 )>
#wnWID0>
#voa
WdPBP
1KPTd
Bcg
L>bB
 )>
#>b,
#>b3
#>bA
 )>
#8nt
X#0OM
}[[#8M
#0OM
[^#Q
Q#8M
#5}
#>be
Ddz
WdPBP
1KPTd
2$H0K
a$sVP
20K0K
2PAD
2LR0K@
ZdLsV
,A6P
+2(!
0%/@0
h0PAhe`
F]2
L#8Me
 )>
#>b5
#>ba
@A4S
#8M
 )>
R#8M
#9mg
>r"h
>q!
#>bi
#|nu
>q!
LwAY
#>bK
Xk@$0OM
#8Me
#>bh
#>bU
#>bz
c!@ H
WdPBP
1KPTd
+2(!
2PAh
,AsC
WdPBP
TdUC
+2(!
5PAh
\7dpE
@EV]
tCI@A
%@b
nB+ v
7,a
WdPBP
sVP
WdPBP
=pcA=r
C+ v
A0KP
7dpE
Bs0PADu
"PPC
ldDJ
 Cp&32
&:RB
7dpE
K}0PAD
'PPC
r+`0
WdPBP
V0.Z
]pe
E+ v
7,#
 C 2
@$0OM
#9oi
0ITP
>rKd
>q!
>q!S
@%8M
f@$8M
Gp^B
>q!
$8Me
V.0E
&0OM
#>b_
 )>
#wnY
 )>
>q!
6809
 )>
#f+@
-@ITP
#5m[q
@%QA
>q!
#F,@
qA@3
>rGe`
 )>
U$8M
#7@Y
#}}%
$8Me
f)`9
#>bb
 )>
PD0>
Dd@
>rAb
>q!
y@%QA
]$0OM
>r@k
>q!
 )>
#9nL
,0IT
#&-0
$0OM
0ITP
#>bx
@%8Me
    
$;KPT
LVRHT
#um@
T>q!
!8Mu
 )>r
A4>b5
tD>b0
#64HT`1
    
A0PAT
f`rP
vTHT
#xmZ
#>b<
#6oi
#5m6
#>bh
T>q!
"8Me
#>bT
#uoE
D>b2
 )>
#>b]
#voe
#>bQ
    
A0PAT
f`rP
,AtC
wdPB0
#>b<
#>b,
#xmt
y)@3
#<mc
@A4S
L"8Mu
"8Mu
&sH
#>bO
#xnz
L=oHJDL
"8Me
#>b[
 )>
#>bD
#|n;
#>blLDL
"0OM
"8Mu
#>b0
#=ms
"8Me
    
A0PAT
0PA 
D 7
`. b
X-!
30\(B0
D7dpG
XA9h
2LRP
;2(!
RB+ v
2lX0K
bp![}
 )>
#>bA
#>b;
#>bI
#>b2
#wn>
#vt\N
L>bl
#zmnNDL
#yn|
nJLDL
X#0OM
#{nD
>b`
 )>
    
B0PAT
$;KPT
f`{P
,AtC
wdPB0
$c0sf
hP>1
Td]
J7PAda@.
a0PA
B<D
bA5
;2(!
Pm0PA n
D+ v
'CL7
O#8Mu
#8~(
#V&IG
#|oA
!1NT
i@$8Me
#:muPDL
#>bj
#gS!
T>q!
 )>
>q!S
#>r#
#8oG
>q!S
 )>
T>q!
#<ni
#>bf
#>bg
~@$0OM
n[d@
#>b`
j@$8Mu
|@$8Mu
@$0OM
    
PV~5P
n >301(B0
7dpG
,A1PA
;2(!
fA+ v
BX(e
24J0K
C:7
,A5P
3PAT
$;K0
Tb!%
aa%
f`.Q
7<h
X\!
|7dpG
XAhh
`. b
wdPB0
o0PA
xdaGXd
#f``R
;2(!
0*s2
P*t2
30T)B0
P{0PA |
E+ v
F!(a
c2`0
u2CL7
7dpG
0PAd
0PAT
T*T
D 7
:Y`7W
X0gt@0
,A.T
0PA 
 2pp
B0K 
!301*B0
0PAd
Di!
1Jf`
;2(!
+@ITP
#>b`
;`IG
@$0OM
$8Me
DdF
#>rf
#unp
#>rg
#5m_
}[S#
T>q!
>A&QA
 )>
$8Me
%8Mu
f:@E
]$0OM
$8Mu
#>b~
[_s9
l@4 
LF-`ITP
T>q!
>rNe`
@A4S
N`IT
 )>
HN[v@$8Mu
#v?0
 )>
#>rSf
#uN_
@%8M
~Uc`
 )>
#>r[b
T>q!
#>r=
J@IG
@%8M
0ITP
%8Mu
y}Mb
T>q!
_[p@
I0IT
#f>@
#>r>h
T>q!
#f;0
X?Au9
#WR!
#V-P
;0IT
#&/@IG
#u}[(
%8Me
%8Me
L&-@
#wQ!
#7!!
m\PDL
#wr!
#&; 
JPIT
&I0MN
#>r(
z@s9
$0OM
OpIG
X:A&8Me
>r"h
T>q!
#>rEg
#F>`I
$8Mu
-A59
w}9``
#>rhn
T>q!
z@$QA
^$QA
g@$QA
$8Me
&K`ITP
#6__
    
,A1P
L7hRPC
VRHT
#&SH
#FSHG
3`>b=
!0OM
    
,A1P
f`mP
2$H0K
&THT
,>ba
#6o-
#>bC
XL"8Me
#>b3
#>bR
 )>
#vmW
Dd+
>q!
    
,A1P
f`mP
2$H0K
Bcg
#>b;
#>bk
#>bt
#8mpID0>
#wnZ
#yoj
>q!S
#>bI
#;ox
>q!
#zm=
 )>
#xmC
O"QA
#>b1
#>by
L"8M
"8M
#>b?
m2GD0>
#>b8
    
,A1P
@+ v
,AsC
wdPBP
TdU#
XA.h
A+ v
7,#
hP#!
#zm;
>q!
#8Me
#8o{
#vnq
#5nT
#xoA
#:mb
i1@3
L>bi
>q!
#vmE
#>bB
#8m?
#>bU
`@"Q
_#QA
>by
Ddd
    
,A1P
;2(!
2PAh
Z(B0
47dpG
@EV5p
tC9HA
;2(!
5PAh
wdPBP
]|RU
B+ v
s_P
7dpG
#uot
Yv@$8M
[l@#8
@$QA
|@$8
#8Me
#>b\
y@$QA
 )>
MD0>
#0OM
[x@$0OM
) IT
#:mi
Hm[}
>q!
 )>
#>b[
#7mq
#7o?
    
PV~5P
,A1P
2$H0K
1|A,
Bcg
0E%@0
2LR0K@
f`=1
2XU0Kp
J5PAD
D 7
TdU
7PADa
 400
cA?
;2(!
h0PAhe`
&#hP3"
 C0#
D 7
A0K 
U+BL7
30_)B0
 4:0
eA_
;2(!
|0PAhy`
&3hP3#
 C03
 4?0@a
fAo
7f`}S
;2(!
0PAh
&;hP
*TdU*
)T@>w
D 7
 "W@
v>@IG
@%8M
>q!
neOD0>
#>bR
>q!
Ho[i
*A&0OM
Xs@$0OM
)@IT
Xj@$
 )>
#fIPIT
#>bFMD0>
>q!
t3b`
OD0>
+PMN
 )>
#>bk
/ IT
v*@IG
#>rC
*`ITP
>r,h
>q!
$8Me
) IT
<@ITP
@A4S
#>bg
#V80
#F>`
 )>
#>bH
#V:@I
#w0!
#5^_
"A%Q
[(A&
#>rOd
%8Me
@$8M
u}Ab
>q!
<0IT
#v9 
59@3
$0OM
$8Me
#7mu
#<mq
9@IT
TD0>
 )>
$0OM
%8Me
#8Me
#680
#;n`
f< I
#5][
IpIT
#un_
QD0>
#vm_
< IG
@%8M
%8Me
; IT
$0OM
H`ITP
 )>
9 IT
v<pIG
#6][
#u^[
Dt8e`
%0OM
9 MN
f@$8
B?5 U
p+F=c
b0$IY
= UD0
@0D"
P$v`
wchar_sizeclang version 7.0.0 
 3C@
intomnipotent charSimple C/C++ TBAA
r6J
_ (511bp!
D2b`!
,5n%
"MND0Dd
!8MU
1He
H!QAM
H!QAm[J!QA
0&aLN
precompiled_u32divrem_spGenISA_uitof_rtzGenISA_fma_rtzGenISA_mul_rtzGenISA_add_rtz7.0.0x86_64-pc-windows-msvcprecompiled_u32divrem_sp.cl
b0$IY
= UD0
@0D"
P$v`
wchar_sizeclang version 7.0.0 
 3C@
intomnipotent charSimple C/C++ TBAA
C0b`!
F1HGd<HDL
Dvm 
@A4S
D7m3
G!8M
[H!8M
!8Me%
!8MU
0HK`
I!QA}[J!QA
M[L!Q
0vo
precompiled_s32divrem_spGenISA_uitof_rtzGenISA_fma_rtzGenISA_mul_rtzGenISA_add_rtz7.0.0x86_64-pc-windows-msvcprecompiled_s32divrem_sp.cl
b0$IY
`B L
P$v`
PIC Levelclang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)
3C@
   B
g@QA
g0bp
B0K@T
t!.
hb&`
'a0P
b0$IY
P$v`
clang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)#
cs)s
c+s1
5@4F
intomnipotent charSimple C/C++ TBAA
Q6F
)TUt
B2b`!
SA$5
1K T
"MND0Dd
D!8MU[D!8Me
D!8Mu
F!8M
j?C-
= UD0
b0$IY
P$v`
clang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)#
cs)s
c+s1
5P>Dc
intomnipotent charSimple C/C++ TBAA
1bp!
fR\NT
1HGd'HDL
,v0H
VA\Nt
AHGT
D5m$
)@0A
j?C-
2D$H
`B L
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
TDT,
V?EFU
HxA@
XxA@
L0!
(T(L
pa`0
a7@0K
2H]P
NB7@0
2L]0
2PY0
`207
D`PA
Z0#0
LM@P
Tp+\D
OnpA@!
NU4,p
AP73
|37a0
pCp7`0
T@;Zds7xA@
B@-4*
!@!0
!`!0
f+`P
0w}&
#(5nP
>n[
Ddi
#(5m
)R9S}
~"II
V?EFU
6408A
n(lA
.f
p A1-
&@0K
$.Pj
2TV0
@EPd8
@GnP
Vd&[
@\.P
/C3`0
5#2h0
hX /
3xA@
hX0:
*lxG
pC ?`0
,A+T
BPx#?Z
?aP{C?:
B@*4*
4p?[
V0=YP
#(5n
0@f
Lf0\Hc
>r1JI
>b`
v0`Hc
)R9S
#VK@
2D$H
`B L
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
*llvm.identS
v67%(
TDT,
P>5P
@xA@
PxA@
PxA@
2$MP
l,`P
np^Cf
2|^py
#`0P
@E@Kd`
\XF+
f.P%s3ZB
n(L'J
:`PA
;`PA
|gT`>;
!`la
)BPB
 zAx
C0KP
`PB
%AB\
Dth
#(v~(
@D&>
fHpH
@D:m
^[(A"
D?q=N
4Cn[
08m
08o
v0`Hc
)R9S
SA5P
PqT50
HxA@
XxA@
hxA@
lxA@
^A+0
RDAM
$pA@
\d0p
BpAD
"@!H
5!F@P
BPEp
599K
`*E0
@"^@0Kp
[h`.Xi
:kf
r5-W
DaD
37h0
@@;T0
BpAD
r0K 
*LHK
?TFh0
FPur?|
BP!!FZ
)T0
dK`0
!8-0
Z1b 
+BPB
!`Tb
ZAg 
0;+BPB
&6j`0
pC0k`0
!p70
mT0r;
E@"7*`
pCpr`P
!x90
vnTPv;
pX r
!.T#
!x;0
vw`0
P"gwZ
s\!Wr<
a4T#
s}@s~
M[e@
6+p
0@f
>~[
r[qA
~^[p
@DuM
@Du]
0:n
0:o
@Dum
0;m
d4>m
0;n
FX`P
SMtK
,VipH
flpH
~MKI
7`"B
YLa(
%=|)r
(=|)r
&"$_
{S&x"B
&=|)r
&]|)r
uC&p
s{-p
q34H&
Y|d""_
'"$_
#E*g
&DP0
#E*g
s+%8R
%]|)r
%]|)r
X\py
(=|)r
K'8R
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
TDT,
v+Lv
l+P[`
6,_+Hx
*BQm
*^Td
*r^a
*BhA
*Ism
f%~*
w*JNY
$m*W
?f*~LM
'l_*
\*lBt
6O*^Q
L*]kt
&t?*
<*Pe{
4*bC
BD^'*ylc
*DHP
(@hn
(@hn
(@`H
(@hq
(@`b
(@@I
(@@b
(@Pl
(@hi
(@X[
(@@b
(@h@
(@pV
(@@b
(@@t
Sh%Q
R4eS8
R"ER&
S<%TDeTH
TP%UTeUX
VbEVf
WrEWv
tJg0"8
o LG&
tFb0"8
o0Pg$
#uFb0"8
o@Tg$
duFb0"8
oPXg$
uFb0"8
ujb0"8
'vLb0"8
hvLb0"8
vLb0"8
vLb0"8
+wLb0"8
lw~b0"8
wPb0"8
b0"8
b0"8
b0"8
 }Zb0"8
}Zb0"8
 ~Zb0"8
~\b0"8
Bc0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
2QK'2
bQNn2
rQO/2
QR12
QS12
QV12
QW12
"RZ"3
b3xA
J-0-
J-P-
"8)@M
`H+0
.0QH
GaG7d
V r;K
0Pa 
2@K0
('r`0
HA-.
HJ+ 
,A5P
.PHYi
DLo/0a
h1lC
Tp~Z
`/0QD
i0Pa
.0aA}
v`c0
/0aA
xv0"
v0b
obMK
@0K
vj`H
I('auD
@DW&
~0KI
0'auD
0@f
@D;}n
v0\Hsa
f~p
)R9S
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
A#66
%QZP
2(IP
2HMP
 5Bd
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
A#66
(~@X@
;K`T
2LU0
9('auD
B17
5`8K0T
,A1P
@pb0
F}B7
xIYpp
o3ODH
BPFpu
%0J
2$H0
PH-p
,ASH
6/ |
1('auD
5P8K0T
FqB7
2 I`
2I~m
2D$H
`@R
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
ksi{#
c+s1c
XA/h
20KPB)\
B0K 
^ PC
D0KP
r0K 
KX81
%('auD
@-S~
#(5}
`]LDH
)R9So
)R9S}
@akk!
V0\Hc
7Dd
t$r
f0@f 
_>m/
`HV$
2D$H
 0BXe`!P
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
KP4Y
/HAL
_a*&
?c_a'G
5^!B
fa6]Q
\QJ'
g*e[
ls1[
lo0Z1
Ya[j
Yq/R
m5-Y
9gtXA
|d8X1.
W1_f
WAZ#z
 $ x@
 <nx@
 twy@
 l5z@
 dcz@
 $d{@
 xw{@
 (#|@
 |*|@
 hf|@
 ds|@
 h$}@
 h-}@
g+dVA
TA_sG
n1tS
p(8S
p*SA
*&-R17v"
QQFZ
/jkQQ
;aQQ
`?7Q
s-Q!F
)tzP
(;iPa
+w8P
i80P
%&(P
  '{@
 l4{@
 8a{@
 |#|@
 |>|@
 4o|@
 4w|@
 d-}@
 08}@
 l=}@
 |b}@
 xg}@
 hl}@
 (q}@
 <z}@
T    D
(@@@@
)@@@@
Xb0"
Bb0"
Bb0"
Bb0"
Db0"
db0"
Fb0"
Fb0"
Fb0"
Fb0"
Fb0"
Fb0"
Hb0"
Nb0"
Nb0"
Nb0"
Pb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
`D0V
(ag"2
`D0V
`D0V
`D0V
4!j$2
`D0V
8aj$2
`D0V
`D0V
`D0V
d!kd2
`D0V
hak(2
`D0V
`D0V
`D0V
t!n)2
`D0V
xan)2
`D0V
`D0V
`D0V
!o+2
`D0V
ao+2
`D0V
`D0V
`D0V
!r+2
`D0V
ar+2
`D0V
`D0V
`D0V
!s+2
`D0V
as+2
`D0V
`D0V
`D0V
!v+2
`D0V
av+2
`D0V
`D0V
`D0V
$"w 3
Ff0" 
Ff0" 
hf0" 
Jf0" 
Jf0" 
Jf0" 
Lf0" 
f0" 
Lj/e
Rf0" 
AMr/e
Rf0" 
Mz/e
Rf0" 
Tf0" 
Tf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
0Xf0" 
0Xf0" 
1Xf0" +
1Xf0" 
2Xf0" 
2Xf0" 
3Xf0" +
3Xf0" 
4Xf0" 
4Xf0" 
5Xf0" +
5Xf0" 
6Xf0" 
6Xf0" 
7Xf0" +
7Xf0" 
8Xf0" 
8Xf0" 
9Xf0" +
9Bh0" 
A;bP
@PA
n8@3
&.1bB 
TpZX
1aB 
-(``A
EMX7P
.0q
J- B`A
@(tZ
fK+ 
2HQP
x7-!
2PYp
2h]0
.?LX
ws3bP
wu5bP
3YqBB\
B3 E
+~m
 LNd
05o
0@f
et_sub_group_idv_Z16get_sub_groubindless_image2dess_image_cube_tbindless_image_cage_cube_array_tage_cube_depth_te2d_msaa_depth_te2d_array_msaa_ts_image2d_msaa_t_depth_t
_array_t
bindless_image1d_t
bindless_image3d
uiltin_IB_atomic__builtin_IB_atoirv_OpenCL_sqrt_v_OpenCL_sqrt_cr
opencl.clk_eventblock_descriptorstruct.__block_d 
_IB_media_block___builtin_IB_med_IB_vme_send_fbr_IB_vme_send_ime_IB_vme_send_sicvme_send_sic_newvme_send_fbr_new
__builtin_IB_to_
B_work_group_any__builtin_IB_wor
DDD@DDDV
pwGDl
pwGDpww
//////
zODD
DD@DD
{{{{{{{{{{{{{{{{{{{{{{{{
}}}}}}}}}}}}}}}}}}}}}}}}
&&&&&&&&&&&&&&&&&&&&&&&&
St12out_of_range
////////////////
........................
DesiredTypeName =
dLoadConstVCallstypeCheckedLoadCssumeConstVCallstypeTestAssumeCoheckedLoadVCallstypeCheckedLoadVem_or_argmemonlyinaccessiblemem_ccessiblememonlyinaccessiblememoEligibleToImportnotEligibleToImpenceable_or_nulldereferenceable_x86_vectorcallccsanitize_addressvirtualConstPropally_initializedexternally_initilocal_unnamed_addr
sanitize_hwaddress
returnDoesNotAlias
ally
available_externalls
typeTestAssumeVCarameter
DITemplateValuePateTypeParameterDITemplateTypePaDILexicalBlockFiDISubroutineTypeDIGlobalVariableDIImportedEntityriableExpressiondwarfAddressSpac
splitDebugInlining
llvm.vectorizer.llvm.global_ctorllvm.global_dtor
0000000000000000
nstrument_target__llvm_profile_i
8OST
""""""""""""""""
St20bad_array_new_length
St9bad_alloc
St12length_error
St11logic_error
St9exception
O8TS
m_personality_v0__gxx_wasm_persocessCLRExceptionProcessCLRExceptt_eh_personalityrust_eh_personal__CxxFrameHandler3
_except_handler3_except_handler4personality_seh0__gxx_personalit__gcc_personality_v0
dler
__C_specific_han__gnat_eh_person_personality_sj0c_personality_v0__objc_personali 
llvm.loop.unroll.
liveOnEntry
objc_storeStrongobjc_destroyWeakloadWeakRetainedobjc_loadWeakRetnretainedPointerobjc_unretainedPetainAutoreleaseobjc_retainAutorunretainedObjectobjc_unretainedOc_retainedObjectobjc_retainedObjtoreleasePoolPopobjc_autoreleasetain_autoreleaseobjc_retain_autoleaseReturnValueobjc_retainBlockPoolPush
Optimization Remark Emitter
ll_graph_profilellvm_call_graph_m_linker_optionsllvm_linker_optignu_unique_objecndirect_functiongnu_indirect_fun
ariable_pointersthread_local_var_local_variablesd_local_zerofillthread_local_zerters
lazy_symbol_poinular
thread_local_regpointers
non_lazy_symbol_cstring_literalsliteral_pointers
ckprotectorcheckstackprotectorchnt.group.barrierinvariant.group.arm.thread.point4.thread.pointeraarch64.thread.pe.ss
avx512.broadcastavx512.mask.sqrt.p
.mask.pbroadcastavx512.mask.pbro
avx512.kortestz.w
avx512.kortestc.avx512.mask.pcmp2.mask.fpclass.pavx512.mask.fpclavx512.mask.cmp.avx512.mask.ucmpavx512.cvtb2maskavx512.cvtw2maskavx512.cvtd2maskavx512.cvtq2maskssse3.pabs.b.128ssse3.pabs.w.128ssse3.pabs.d.128avx512.mask.pabsavx512.mask.pmaxu
avx512.mask.pmin512.pmulu.dq.512avx512.pmulu.dq.2.mask.pmulu.dq.avx512.mask.pmulavx512.pmul.dq.512
.dq.
avx.cvtdq2.pd.256
avx.cvtdq2.ps.25avx512.cvtusi2sd2.mask.cvtdq2pd.avx512.mask.cvtd.mask.cvtudq2pd.avx512.mask.cvtuavx.cvt.ps2.pd.256
sk.cvtudq2ps.128sk.cvtudq2ps.256sk.cvtuqq2pd.128sk.cvtuqq2pd.256q2ps.128
q2ps.256
q2pd.128
avx512.mask.cvtqq2pd.256
s2pd.128
avx512.mask.cvtps2pd.256
avx512.mask.loadu.
nd.load.
avx512.mask.expa.compress.store.avx512.mask.compsse42.crc32.64.8avx.vbroadcast.s512.vbroadcast.savx512.vbroadcasavx512.mask.pmovsx
avx.vbroadcastf128
2.vbroadcasti128avx2.vbroadcastiavx512.mask.shuf.i
.mask.broadcastfavx512.mask.broa.mask.broadcastiavx512.pbroadcasmask.broadcast.sgnr.
avx512.mask.pali512.mask.valign.avx512.mask.valiavx512.psll.dq.5avx512.psrl.dq.5avx.vinsertf128.avx512.mask.insert
avx2.vinserti128avx.vextractf128avx2.vextracti128
ract
avx512.mask.vext.df.
avx512.mask.perm.di.
2.mask.vpermil.pavx512.mask.vperf.d.
2.mask.pshufl.w.2.mask.pshufh.w.512.mask.movddupavx512.mask.movdhdup
avx512.mask.movsldup
512.mask.punpcklavx512.mask.punp512.mask.unpckl.avx512.mask.unpc512.mask.punpckh512.mask.unpckh.avx512.mask.pandn.
avx512.mask.por.avx512.mask.pxoravx512.mask.and.avx512.mask.andnavx512.mask.xor.avx512.mask.paddavx512.mask.psubl.
avx512.mask.add.avx512.mask.div.avx512.mask.mul.avx512.mask.sub.avx512.mask.max.avx512.mask.min.avx512.mask.lzcnt.
avx512.mask.psllavx512.mask.psrlavx512.mask.psraavx512.mask.move.s
avx512.mask.pavgdd.s
avx512.mask.vfma2.maskz.vfmadd.savx512.maskz.vfm2.mask3.vfmadd.savx512.mask3.vfm2.mask3.vfmsub.s.mask3.vfnmsub.savx512.mask3.vfndd.p
2.mask.vfnmadd.pavx512.mask.vfnm2.mask.vfnmsub.p2.mask3.vfmadd.p2.mask3.vfmsub.p.mask3.vfnmsub.p2.maskz.vfmadd.pmask.vfmaddsub.paddsub.p
subadd.p
2.mask.pternlog.avx512.mask.pter.maskz.pternlog.avx512.maskz.ptedd52
avx512.mask.vpma2.maskz.vpmadd52avx512.maskz.vpmmask.vpermi2var.mask.vpermt2var.rmt2var.
avx512.maskz.vpe2.mask.vpdpbusd..maskz.vpdpbusd..mask.vpdpbusds.maskz.vpdpbusds.2.mask.vpdpwssd..maskz.vpdpwssd..mask.vpdpwssds.maskz.vpdpwssds.
age Info SectionObjective-C Imag, __objc_catlist__DATA, __objc_cectorizer.unroll512.mask.vfmadd.add.
sub.
2.mask3.vfnmsub..mask.vfmaddsub.maskz.vfmaddsub.mask3.vfmaddsub.mask3.vfmsubadd.512.mask.pcmpeq.512.mask.pcmpgt.f.b.
avx512.mask.pshud2dq.256
d2ps.256
sk.cvttpd2dq.256avx512.mask.cvttsk.cvttps2dq.128sk.cvttps2dq.256var.
mask.pmul.hr.sw.h.w.
2.mask.pmulhu.w.2.mask.pmaddw.d.avx512.mask.pmadmask.pmaddubs.w.2.mask.packsswb.avx512.mask.pack2.mask.packssdw.2.mask.packuswb.2.mask.packusdw.b
mask.vpermilvar..d
2.mask.dbpsadbw.avx512.mask.dbps512.mask.vpshld.avx512.mask.vpsh512.mask.vpshrd.avx512.mask.prorv.
avx512.mask.prol512.mask.storeu.512.mask.store.pe.b.
e.w.
e.d.
e.q.
Debug Info Version
eritance
DIFlagVirtualInhtipleInheritanceDIFlagMultipleInePassByReferenceDIFlagTypePassByirectVirtualBaseDIFlagIndirectVigram
DIFlagMainSubproDIFlagStaticMembgLValueReferenceDIFlagLValueRefegRValueReferenceDIFlagRValueRefegTypePassByValuelagObjectPointerDIFlagObjectPoinbjcClassCompleteDIFlagObjcClassCingleInheritanceDIFlagSingleInhentroducedVirtualDIFlagIntroducedBlockByrefStructDIFlagBlockByrefDIFlagAppleBlockDIFlagArtificialDIFlagPrototyped-?:\,[]{}#&*!|>'"%@`
tion_entry_countsynthetic_functifunction_entry_c.
////////.
JJJJJJJ
JJJJJJJJJJJ
JJJJ@
?,,?
??,?
////:
////////w
JJJJJJJ
JJJJJJJJJJJ
JJJJC
??????
???????
++++
++++
..D...E
..T...D
..D...D
..D...D
..D.
MMLL[
MMLL[
MMLL[
LLLLMMMMMM
MMLL[
MMLL[
MMLL[
MMLL[
LLLLMMMMLLL
LLLLMMMMLLL
LLLLMMMMLL
MMLL[
LLLLMMMMLLLLMMMMML
MMLL[
MMLL[
MMMD
LLLLMMMMLLL
LLLLMMMMLL
MMMD
LLLLMMMMLL
MMMD
...D...D...D...D...D...D..D
,,,,YYYY;;;;JJJJ,,,
,,,,YYYY;;;;JJJJ,,,
,,,,,,,
,,,,,,,
,,,,,,,
YYJJ;;,,JJ;;YYJJ;;,,JJ;;U99
YYJJ;;,,JJ;;YYJJ;;,,JJ;;U99
zzzz
zzzz
;;;;JJJJ;;;;JJJJUD
,,,,YYYY;;;;JJJJU99
;;;;JJJJ;;;;JJJJUD
,,,,YYYY;;;;JJJJU
,,,,YYYY;;;;JJJJ@
PD33PD33PD33PDDDPDDDPDDDPD33PD33PD33P4
PD33PD33PD33PDDDPDDDPDDDPD33PD33PD33PD4
PD33PDDDPD33P4
PD33PDDDPD33PD4
,,,,,,,
zzzzzzz
;;;;;;;;zzz
;;;;J,,JJ;;JJ;;JJ,,JJ;;JJ;;J;,,
zzzzJJJ,;JJ
YYYYYYY
JJJJJJJ
JJJJJJJ
,,,,JJJ
,,,,,,,
;,,;YJJY,YY,J;;J;,,
;,,;YJJYJ;;J,,,,JJJJ;;;;;,,;YJJYJ;;J,,,,JJJJ;;;;;,,;YJJYJ;;J;,,;YJJYJ;;J;,,
,,,,;JJ
,,,,,,,,,,,
{{{{
----KKK
B|||C
 K.D0L.D [.D [.D0
GB,,,
|L|CJ
[BJzJ
L|LC
BYzY
[{[BJzJ
L|LCYzY
[{[B
BzYz
{[{B
[BL|LCYzY
[{[BJzJ
L|LCYzY
[{[B|L|C
BzYz
{[{B0
Bzzz
|||C0
|<|C;z
B|||C0
B|||C0
 K.D0L.D [.D [.D3
JJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLL;;;;<<<<====
zzJz{{K{||L|YYYYZZZZ[[[[,,,,----
YYYYZZZZ[[[[YYYYZZZZ[[[[JJJ
JJJJ.
zzzz
,,,,;;
YYY"
JJJJYJJYYJJYJJJJYJJYYJJYJ;;J;;;;J;;J;;;;J;;JJ;;J,,,,,,,
))))
!!#!#
""""""""""""""
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%
""""""""""""""""""
"""""
##########
''''''
((((
((((((((((((((((
((((((((
))))))))
))))))))
))))))))
*****
**********
******
,---
0000
0000000000000000000100
||||
)*1111101
ccccccccc
round.towardzerofpexcept.maytrapMaxInternalCountMaxFunctionCountllvm.compiler.us
z>----------------
                                                                                
[0;30m
[0;31m
[0;32m
[0;33m
[0;34m
[0;35m
[0;36m
[0;37m
[0;1;30m
[0;1;31m
[0;1;32m
[0;1;33m
[0;1;34m
[0;1;35m
[0;1;36m
[0;1;37m
[0;40m
[0;41m
[0;42m
[0;43m
[0;44m
[0;45m
[0;46m
[0;47m
[0;1;40m
[0;1;41m
[0;1;42m
[0;1;43m
[0;1;44m
[0;1;45m
[0;1;46m
[0;1;47m
e_reference_typeDW_TAG_rvalue_ree_type_parameterDW_TAG_template_DW_TAG_with_stmtDW_TAG_base_typeDW_TAG_file_typeDW_TAG_try_blockDW_TAG_namespaceDW_TAG_conditionDW_TAG_type_unit_value_parameterified_parametersDW_TAG_unspecifi_subroutine_typeDW_TAG_subroutin_dwarf_procedureDW_TAG_dwarf_pro_imported_moduleDW_TAG_imported_lined_subroutineDW_TAG_inlined_sr_to_member_typeDW_TAG_ptr_to_mecess_declarationDW_TAG_access_deG_reference_typeDW_TAG_referenceG_structure_typeDW_TAG_structureG_interface_typeDW_TAG_interfaceG_template_aliasG_immutable_typeDW_TAG_immutableG_class_templateDW_TAG_class_temTAG_pointer_typeDW_TAG_pointer_tTAG_compile_unitDW_TAG_compile_uTAG_common_blockDW_TAG_common_blTAG_variant_partDW_TAG_variant_pTAG_partial_unitDW_TAG_partial_uTAG_coarray_typeDW_TAG_coarray_tTAG_dynamic_typeDW_TAG_dynamic_tTAG_format_labelDW_TAG_format_lalock
DW_TAG_lexical_btype
DW_TAG_subrange_item
DW_TAG_namelist_DW_TAG_volatile_DW_TAG_restrict_unit
rted_declarationenumeration_typeDW_TAG_enumeratiformal_parameterDW_TAG_formal_pacommon_inclusionDW_TAG_common_inunspecified_typegeneric_subrangeDW_TAG_generic_sDW_TAG_entry_point
DW_TAG_string_type
DW_TAG_inheritance
DW_TAG_catch_block
DW_TAG_packed_tyDW_TAG_thrown_tyDW_TAG_shared_tyDW_TAG_array_typDW_TAG_class_typDW_TAG_union_typDW_TAG_const_typDW_TAG_enumeratoDW_TAG_subprogratemplate
DW_TAG_function_DW_TAG_skeleton_l_site_parameterDW_TAG_call_siteDW_TAG_MIPS_loopDW_TAG_atomic_tyD_Delphi_variantDW_TAG_BORLAND_DRLAND_Delphi_setND_Delphi_stringBORLAND_propertyDW_TAG_BORLAND_pG_APPLE_propertyDW_TAG_APPLE_proDW_TAG_GNU_call_site
l_parameter_packDW_TAG_GNU_forma_GNU_const_indexDW_OP_GNU_const_OP_LLVM_fragmentDW_OP_LLVM_fragmpush_tls_addressDW_OP_GNU_push_t_cfa
DW_OP_call_framealue
DW_OP_implicit_vndex
DW_OP_GNU_addr_iform_tls_addressDW_OP_form_tls_aimplicit_pointerDW_OP_implicit_ph_object_addressDW_OP_push_objecDW_OP_deref_sizeDW_OP_const_typeDW_OP_deref_typeDW_OP_plus_uconsDW_OP_xderef_sizDW_OP_stack_valuDW_OP_entry_valuDW_OP_regval_typDW_OP_xderef_typDW_OP_reinterpreATE_signed_fixedDW_ATE_signed_fiE_packed_decimalDW_ATE_packed_deE_numeric_stringDW_ATE_numeric_sE_unsigned_fixedDW_ATE_unsigned__imaginary_floatDW_ATE_imaginaryDW_ATE_signed_char
loat
DW_ATE_complex_fchar
DW_ATE_decimal_fITY_pure_virtualDW_VIRTUALITY_puRTUALITY_virtualDW_VIRTUALITY_viDW_VIRTUALITY_none
GLE_RenderScriptDW_LANG_GOOGLE_Rript
DW_LANG_RenderScG_ObjC_plus_plusDW_LANG_ObjC_pluG_C_plus_plus_03DW_LANG_C_plus_pG_C_plus_plus_11G_C_plus_plus_14G_Mips_AssemblerDW_LANG_Mips_AssG_BORLAND_DelphiDW_LANG_BORLAND_DW_LANG_Pascal83DW_LANG_Fortran77
DW_LANG_Fortran90
DW_LANG_Fortran0LANG_C_plus_plusDW_CC_LLVM_Win64DW_CC_LLVM_AAPCSDW_CC_LLVM_Swiftfastcall
DW_CC_BORLAND_ms_BORLAND_stdcallDW_CC_BORLAND_st_LLVM_vectorcallDW_CC_LLVM_vecto_LLVM_X86_64SysVDW_CC_LLVM_X86_6_LLVM_X86RegCallDW_CC_LLVM_X86ReBORLAND_safecallDW_CC_BORLAND_saBORLAND_msreturnBORLAND_thiscallDW_CC_BORLAND_thBORLAND_fastcallDW_CC_BORLAND_faLLVM_PreserveAllDW_CC_LLVM_Presend_fastcall_i386DW_CC_GNU_borlans_sh
DW_CC_GNU_renesascal
DW_CC_BORLAND_pa_VFP
enCL
DW_CC_GDB_IBM_OpCC_pass_by_valueDW_CC_pass_by_vaass_by_referenceDW_CC_pass_by_reLVM_IntelOclBiccDW_CC_LLVM_IntelLVM_SpirFunctionDW_CC_LLVM_SpirFLVM_OpenCLKernelDW_CC_LLVM_OpenCLVM_PreserveMostMACINFO_end_fileDW_MACINFO_end_fCINFO_start_fileDW_MACINFO_startCINFO_vendor_extDW_MACINFO_vendoDW_MACINFO_undefDW_MACINFO_defin
N3iga10FatalErrorE
St13runtime_error
\\\\\\\\
::::::::::::::::::::::::
************************
????????????????????????
""""""""
<<<<<<<<<<<<<<<<<<<<<<<<
>>>>>>>>>>>>>>>>>>>>>>>>
||||||||||||||||||||||||
OnlyVertexShaderIGC::PositionOnlO
7.0.0
St12out_of_range
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
8 .@
8@.`
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
pppp
8 .@
8@.`
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
pppp
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
L ( 
L ( 
L * 
A` 
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
,I .@
,I@.`
,I`.
,I .
,I@.
,I`.
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
$K %
$K@$
$K`$
e'7d@
vX6E@
1FE#@
TgTgA
2d2dA
WWWWA
q8q8A
cTcTA
8T8TA
2424A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%A
"T"TA
%C%CA
6T6TA
5f5fA
&R&RA
4!4!A
8e8eA
d%d%
Xx!C
!B##
!4!4
V#V#
&T&T
#1#1
!#!#
    
 " "
0000
0303
@@@@
@D@D
PPPP
PUPU
PUPU
````
oIo<P
CTNI&
^^^^ ^^^^^^^^^
^O;LLP
UL[!
#<(-278
K8@,v
~.jz
nZv2
 (08@HPX`hpx
 (08
4M^x
5.5555_
5.5555_
5.5555_
Sjp:s=
````
4Jqw}$
````
?A????C
JLJJJJN
:<::::>:
####M
 (    E
####M
2..::
:4::::6
&&&&
&&&&&&&
'''''
'''''''
''''''''''}--
3)-#9=1A'?!%;
||j 
NSt3__117bad_function_callE
gggg
`[````]
ffff
XSXXXXU
+Dg:
FFFFFFFF
FFFF7
p|||
||||||||||||||||||||t
||||||||||||||
|||y|||
air.kernel
air.vertex
air.version
air.language_version
air.compile_options
air.location_index
air.read
air.write
air.read_write
air.sample
air.buffer_size
air.arg_type_name
air.arg_type_size
air.arg_type_align_size
air.arg_name
air.emulation_argument
#####################################
KKKKKKKKKKKKKKKKKK6KKKKKKKKKKKKKEK2:0
4..99
9299996D
C:CCCC<
njey
okkvv
vqvvvvs
)=-#
')''''+SI
MOMMMMQ
KCCPP
PIPPPPM&
2##cc
c-cccc7
N))PP
PRPPPPT

9Tam
F+((
!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
:===
8 8#8(8+8.8184
...........................
..........
!$'*-06<
Zzdv
/c///e///////g///////////////i
Y[YYY]YYYYYYY_YYYYYYYYYYYYYYYaX_
Y[YYY]YYYYYYY_YYYYYYYYYYYYYYYaX_
,+K7
\fpz
6@NF
:nnn
nnnnnnnnnnnnnnnnnnnnj
nnnnnnnnnnnnnn
nnnRnnn
933>>
>7>>>>;
@@@@@
Ljs}
gggg
n--uu
uluuuup*
l llll(
-------+--
TTTTTTTTTTT5TTTTTTTT
-Fdk{
6@NF
9ESK
6@NF
3322(
9AIQ
+6RAAAAAC
OU[a
J''LL
LNLLLLPA@
hhhhhhhhhhhhhhhh
.GZm
@@@@
5P/k
wwwwwwwwwwwwwwww88aw88awwww
cwcwww
wwwwwwwww''w
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww''HN
1//33
3533337
>>>>
<88>>
>@>>>>B
9--22
252222h
9NbW
9NbW
??????????
??????????????????????2
7277774
!,7"
!!!!
oiitt
tmttttqZ
BBBB
..17
++.4
<0VE
 (    A
,O%@
mmmmmmmmmmmmmmmmmmmmmmmmmmmmm
!777
4444
SE_G
II_IKIIIIM
@KU_hq
#####################################
Z2_d
]))EEr
b0$IY
2$IB
(CUUd
P$v`
clang version 4.0.1 #
cs)s
c+s1
       
ELzA
E`XB
C8QM_A
A45n0
PV~5
dPB0
1KpTd]
,A1PA
nx:0
L&SHT
t,>b&
T>b8
>b3
T>b/
WdPB0
1KpTd]A
$;KPT
7<{
[M"0OM
T>q!
B?5 
N"QA
#>bV
@A4S
J"8Me
K"8Mu
DdK
#>rR
#>bQ
#5nO
#>b1
#uoC
WdPB0
1KpTd]a
$;KPT
7<{
,A5P
3PAT
$;K0
"8Mu
#7of
LfsHT
#>bN
#8n9
#>bk
T>q!
B?5 
@A4S
J"8Me
K"8Mu
#wo_
#vo3
"8Mu
#9o7
#>bR
#yo+
T>q!Sn
#zmK
B?5 
DdL
#zoS
#>b1
#&sHG
#>bO
WdPB0
1KpTd]
A0PAT
\@Jp
,AtC
WdPB0
`aA
$c0s
XT#0OM
#vo:
#7oa
"0OM
 )>
#>bb
#>bI
=1@3
B?5 
#xnG
#8Me
#8Me
U#QA
a@#Q
B?5 
B?5 
2Y^#8M
#>bi
#0OM
WdPB0
1KpTd]
,A1PA
+2(!
@+ v
BX(e
24J0K
D7dpE
2LRPB
+2(!
A+ v
2lX0K
WdPB0
H7PATa`"]
&Tb
B+ v
Pm0PA n
Tc!5
ba5
lC+ v
Gm2
B?5 
@ITP
#8Me
#8M
#>r0h
T>q!
Dd4
z@$8M
 )>
#8Mu
 )>
S#8M
T>q!
T>q!
Q#QA
B?5 
#ynS
#>bj
Xi@#
r@$QA
 )>
$8Mu
#>bW
#8Me
 )>
Y9@3
d@$QA
m9NT
B?5 
Y#8M
#F%IG
 )>
B?5 
#{nl
#w~.
#8Mu
B?5 
c!@ H
WdPB0
1KpTd]
%DQm`\
,AtC
WdPB0
$c0s
|7dpE
%DQ7a\
`. b
7<y
1hA\
`. b
1hAy2
Td]
%DQ#b\
`. b
7<e
pC`&d0
,A+Td
%DQwb\
`. b
,A.T
0PA 
FF+ v
~!(!
0PA 
fAmhf
F+ v
3:`0
@$0OM
$8Me
#>rD
T>q!
#>r0j
T>q!
B?5 
Dt5
#V/@
#>rB
$8Mu
V$8Mu
$8Mu
%8Me
v@$8M
#&;P
@A4S
#>r[b
T>q!
#7@Y
Dtid
T>q!
`@$QA
 )>
Xp@$8M
B?5 
#f;`
$0OM
 )>
Dd}
#v;`
B?5 
 )>
XZ$QA
#|~.
#F/P
#>b|
#>rNd`
%0OM
%0OM
#6-0
 )>
/P9Q
%8Me
#8~f
B?5 
u~aj
B?5 
#v9@
;@IG
&8Mu
$8Me
LV=p
 )>
809Q
T>q!
;@IT
B?5 
f@$Q
 )>
j@$8Mu
#G0!
B?5 
#>r'
}ce`
B?5 
PV~5
dPBP
1KPTd
D4`A
L7LTPC
nX20
T>q!
 )>b+
t,>b&
tD>r
A4>b.
#vRD
WdPBP
1KPTd
+2(!
V0*0
2PAh
#VsHT
#>b7
#umE
#5n.
#>b8
#>b+GD0>
 )>
O"8M
WdPBP
1KPTd
+2(!
V0*0
2PAh
,AsC
WdPBP
TdU
#wmI
M[W"
Dd4
#>b5
#wo7
L6c8
>q!
J"8Me
#9mAID0>
#ym.
#>b8
#>bK
#:mF
K"8M
>q!
#yo6
"8Me
 )>
#wnWID0>
#voa
WdPBP
1KPTd
Bcg
L>bB
 )>
#>b,
#>b3
#>bA
 )>
#8nt
X#0OM
}[[#8M
#0OM
[^#Q
Q#8M
#5}
#>be
Ddz
WdPBP
1KPTd
2$H0K
a$sVP
20K0K
2PAD
2LR0K@
ZdLsV
,A6P
+2(!
0%/@0
h0PAhe`
F]2
L#8Me
 )>
#>b5
#>ba
@A4S
#8M
 )>
R#8M
#9mg
>r"h
>q!
#>bi
#|nu
>q!
LwAY
#>bK
Xk@$0OM
#8Me
#>bh
#>bU
#>bz
c!@ H
WdPBP
1KPTd
+2(!
2PAh
,AsC
WdPBP
TdUC
+2(!
5PAh
\7dpE
@EV]
tCI@A
%@b
nB+ v
7,a
WdPBP
sVP
WdPBP
=pcA=r
C+ v
A0KP
7dpE
Bs0PADu
"PPC
ldDJ
 Cp&32
&:RB
7dpE
K}0PAD
'PPC
r+`0
WdPBP
V0.Z
]pe
E+ v
7,#
 C 2
@$0OM
#9oi
0ITP
>rKd
>q!
>q!S
@%8M
f@$8M
Gp^B
>q!
$8Me
V.0E
&0OM
#>b_
 )>
#wnY
 )>
>q!
6809
 )>
#f+@
-@ITP
#5m[q
@%QA
>q!
#F,@
qA@3
>rGe`
 )>
U$8M
#7@Y
#}}%
$8Me
f)`9
#>bb
 )>
PD0>
Dd@
>rAb
>q!
y@%QA
]$0OM
>r@k
>q!
 )>
#9nL
,0IT
#&-0
$0OM
0ITP
#>bx
@%8Me
    
$;KPT
LVRHT
#um@
T>q!
!8Mu
 )>r
A4>b5
tD>b0
#64HT`1
    
A0PAT
f`rP
vTHT
#xmZ
#>b<
#6oi
#5m6
#>bh
T>q!
"8Me
#>bT
#uoE
D>b2
 )>
#>b]
#voe
#>bQ
    
A0PAT
f`rP
,AtC
wdPB0
#>b<
#>b,
#xmt
y)@3
#<mc
@A4S
L"8Mu
"8Mu
&sH
#>bO
#xnz
L=oHJDL
"8Me
#>b[
 )>
#>bD
#|n;
#>blLDL
"0OM
"8Mu
#>b0
#=ms
"8Me
    
A0PAT
0PA 
D 7
`. b
X-!
30\(B0
D7dpG
XA9h
2LRP
;2(!
RB+ v
2lX0K
bp![}
 )>
#>bA
#>b;
#>bI
#>b2
#wn>
#vt\N
L>bl
#zmnNDL
#yn|
nJLDL
X#0OM
#{nD
>b`
 )>
    
B0PAT
$;KPT
f`{P
,AtC
wdPB0
$c0sf
hP>1
Td]
J7PAda@.
a0PA
B<D
bA5
;2(!
Pm0PA n
D+ v
'CL7
O#8Mu
#8~(
#V&IG
#|oA
!1NT
i@$8Me
#:muPDL
#>bj
#gS!
T>q!
 )>
>q!S
#>r#
#8oG
>q!S
 )>
T>q!
#<ni
#>bf
#>bg
~@$0OM
n[d@
#>b`
j@$8Mu
|@$8Mu
@$0OM
    
PV~5P
n >301(B0
7dpG
,A1PA
;2(!
fA+ v
BX(e
24J0K
C:7
,A5P
3PAT
$;K0
Tb!%
aa%
f`.Q
7<h
X\!
|7dpG
XAhh
`. b
wdPB0
o0PA
xdaGXd
#f``R
;2(!
0*s2
P*t2
30T)B0
P{0PA |
E+ v
F!(a
c2`0
u2CL7
7dpG
0PAd
0PAT
T*T
D 7
:Y`7W
X0gt@0
,A.T
0PA 
 2pp
B0K 
!301*B0
0PAd
Di!
1Jf`
;2(!
+@ITP
#>b`
;`IG
@$0OM
$8Me
DdF
#>rf
#unp
#>rg
#5m_
}[S#
T>q!
>A&QA
 )>
$8Me
%8Mu
f:@E
]$0OM
$8Mu
#>b~
[_s9
l@4 
LF-`ITP
T>q!
>rNe`
@A4S
N`IT
 )>
HN[v@$8Mu
#v?0
 )>
#>rSf
#uN_
@%8M
~Uc`
 )>
#>r[b
T>q!
#>r=
J@IG
@%8M
0ITP
%8Mu
y}Mb
T>q!
_[p@
I0IT
#f>@
#>r>h
T>q!
#f;0
X?Au9
#WR!
#V-P
;0IT
#&/@IG
#u}[(
%8Me
%8Me
L&-@
#wQ!
#7!!
m\PDL
#wr!
#&; 
JPIT
&I0MN
#>r(
z@s9
$0OM
OpIG
X:A&8Me
>r"h
T>q!
#>rEg
#F>`I
$8Mu
-A59
w}9``
#>rhn
T>q!
z@$QA
^$QA
g@$QA
$8Me
&K`ITP
#6__
    
,A1P
L7hRPC
VRHT
#&SH
#FSHG
3`>b=
!0OM
    
,A1P
f`mP
2$H0K
&THT
,>ba
#6o-
#>bC
XL"8Me
#>b3
#>bR
 )>
#vmW
Dd+
>q!
    
,A1P
f`mP
2$H0K
Bcg
#>b;
#>bk
#>bt
#8mpID0>
#wnZ
#yoj
>q!S
#>bI
#;ox
>q!
#zm=
 )>
#xmC
O"QA
#>b1
#>by
L"8M
"8M
#>b?
m2GD0>
#>b8
    
,A1P
@+ v
,AsC
wdPBP
TdU#
XA.h
A+ v
7,#
hP#!
#zm;
>q!
#8Me
#8o{
#vnq
#5nT
#xoA
#:mb
i1@3
L>bi
>q!
#vmE
#>bB
#8m?
#>bU
`@"Q
_#QA
>by
Ddd
    
,A1P
;2(!
2PAh
Z(B0
47dpG
@EV5p
tC9HA
;2(!
5PAh
wdPBP
]|RU
B+ v
s_P
7dpG
#uot
Yv@$8M
[l@#8
@$QA
|@$8
#8Me
#>b\
y@$QA
 )>
MD0>
#0OM
[x@$0OM
) IT
#:mi
Hm[}
>q!
 )>
#>b[
#7mq
#7o?
    
PV~5P
,A1P
2$H0K
1|A,
Bcg
0E%@0
2LR0K@
f`=1
2XU0Kp
J5PAD
D 7
TdU
7PADa
 400
cA?
;2(!
h0PAhe`
&#hP3"
 C0#
D 7
A0K 
U+BL7
30_)B0
 4:0
eA_
;2(!
|0PAhy`
&3hP3#
 C03
 4?0@a
fAo
7f`}S
;2(!
0PAh
&;hP
*TdU*
)T@>w
D 7
 "W@
v>@IG
@%8M
>q!
neOD0>
#>bR
>q!
Ho[i
*A&0OM
Xs@$0OM
)@IT
Xj@$
 )>
#fIPIT
#>bFMD0>
>q!
t3b`
OD0>
+PMN
 )>
#>bk
/ IT
v*@IG
#>rC
*`ITP
>r,h
>q!
$8Me
) IT
<@ITP
@A4S
#>bg
#V80
#F>`
 )>
#>bH
#V:@I
#w0!
#5^_
"A%Q
[(A&
#>rOd
%8Me
@$8M
u}Ab
>q!
<0IT
#v9 
59@3
$0OM
$8Me
#7mu
#<mq
9@IT
TD0>
 )>
$0OM
%8Me
#8Me
#680
#;n`
f< I
#5][
IpIT
#un_
QD0>
#vm_
< IG
@%8M
%8Me
; IT
$0OM
H`ITP
 )>
9 IT
v<pIG
#6][
#u^[
Dt8e`
%0OM
9 MN
f@$8
B?5 U
p+F=c
b0$IY
= UD0
@0D"
P$v`
wchar_sizeclang version 7.0.0 
 3C@
intomnipotent charSimple C/C++ TBAA
r6J
_ (511bp!
D2b`!
,5n%
"MND0Dd
!8MU
1He
H!QAM
H!QAm[J!QA
0&aLN
precompiled_u32divrem_spGenISA_uitof_rtzGenISA_fma_rtzGenISA_mul_rtzGenISA_add_rtz7.0.0x86_64-pc-windows-msvcprecompiled_u32divrem_sp.cl
b0$IY
= UD0
@0D"
P$v`
wchar_sizeclang version 7.0.0 
 3C@
intomnipotent charSimple C/C++ TBAA
C0b`!
F1HGd<HDL
Dvm 
@A4S
D7m3
G!8M
[H!8M
!8Me%
!8MU
0HK`
I!QA}[J!QA
M[L!Q
0vo
precompiled_s32divrem_spGenISA_uitof_rtzGenISA_fma_rtzGenISA_mul_rtzGenISA_add_rtz7.0.0x86_64-pc-windows-msvcprecompiled_s32divrem_sp.cl
b0$IY
`B L
P$v`
PIC Levelclang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)
3C@
   B
g@QA
g0bp
B0K@T
t!.
hb&`
'a0P
b0$IY
P$v`
clang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)#
cs)s
c+s1
5@4F
intomnipotent charSimple C/C++ TBAA
Q6F
)TUt
B2b`!
SA$5
1K T
"MND0Dd
D!8MU[D!8Me
D!8Mu
F!8M
j?C-
= UD0
b0$IY
P$v`
clang version 4.0.1 (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-clang 3621e01986d729d27ffa6d8cc3e2020357cc420b) (ssh://nnopencl-git-01.inn.intel.com/home/git/repo/opencl_qa-llvm 26ebe8b7270e331f307f8d763aa5dd076abb0335)#
cs)s
c+s1
5P>Dc
intomnipotent charSimple C/C++ TBAA
1bp!
fR\NT
1HGd'HDL
,v0H
VA\Nt
AHGT
D5m$
)@0A
j?C-
2D$H
`B L
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
TDT,
V?EFU
HxA@
XxA@
L0!
(T(L
pa`0
a7@0K
2H]P
NB7@0
2L]0
2PY0
`207
D`PA
Z0#0
LM@P
Tp+\D
OnpA@!
NU4,p
AP73
|37a0
pCp7`0
T@;Zds7xA@
B@-4*
!@!0
!`!0
f+`P
0w}&
#(5nP
>n[
Ddi
#(5m
)R9S}
~"II
V?EFU
6408A
n(lA
.f
p A1-
&@0K
$.Pj
2TV0
@EPd8
@GnP
Vd&[
@\.P
/C3`0
5#2h0
hX /
3xA@
hX0:
*lxG
pC ?`0
,A+T
BPx#?Z
?aP{C?:
B@*4*
4p?[
V0=YP
#(5n
0@f
Lf0\Hc
>r1JI
>b`
v0`Hc
)R9S
#VK@
2D$H
`B L
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
*llvm.identS
v67%(
TDT,
P>5P
@xA@
PxA@
PxA@
2$MP
l,`P
np^Cf
2|^py
#`0P
@E@Kd`
\XF+
f.P%s3ZB
n(L'J
:`PA
;`PA
|gT`>;
!`la
)BPB
 zAx
C0KP
`PB
%AB\
Dth
#(v~(
@D&>
fHpH
@D:m
^[(A"
D?q=N
4Cn[
08m
08o
v0`Hc
)R9S
SA5P
PqT50
HxA@
XxA@
hxA@
lxA@
^A+0
RDAM
$pA@
\d0p
BpAD
"@!H
5!F@P
BPEp
599K
`*E0
@"^@0Kp
[h`.Xi
:kf
r5-W
DaD
37h0
@@;T0
BpAD
r0K 
*LHK
?TFh0
FPur?|
BP!!FZ
)T0
dK`0
!8-0
Z1b 
+BPB
!`Tb
ZAg 
0;+BPB
&6j`0
pC0k`0
!p70
mT0r;
E@"7*`
pCpr`P
!x90
vnTPv;
pX r
!.T#
!x;0
vw`0
P"gwZ
s\!Wr<
a4T#
s}@s~
M[e@
6+p
0@f
>~[
r[qA
~^[p
@DuM
@Du]
0:n
0:o
@Dum
0;m
d4>m
0;n
FX`P
SMtK
,VipH
flpH
~MKI
7`"B
YLa(
%=|)r
(=|)r
&"$_
{S&x"B
&=|)r
&]|)r
uC&p
s{-p
q34H&
Y|d""_
'"$_
#E*g
&DP0
#E*g
s+%8R
%]|)r
%]|)r
X\py
(=|)r
K'8R
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
TDT,
v+Lv
l+P[`
6,_+Hx
*BQm
*^Td
*r^a
*BhA
*Ism
f%~*
w*JNY
$m*W
?f*~LM
'l_*
\*lBt
6O*^Q
L*]kt
&t?*
<*Pe{
4*bC
BD^'*ylc
*DHP
(@hn
(@hn
(@`H
(@hq
(@`b
(@@I
(@@b
(@Pl
(@hi
(@X[
(@@b
(@h@
(@pV
(@@b
(@@t
Sh%Q
R4eS8
R"ER&
S<%TDeTH
TP%UTeUX
VbEVf
WrEWv
tJg0"8
o LG&
tFb0"8
o0Pg$
#uFb0"8
o@Tg$
duFb0"8
oPXg$
uFb0"8
ujb0"8
'vLb0"8
hvLb0"8
vLb0"8
vLb0"8
+wLb0"8
lw~b0"8
wPb0"8
b0"8
b0"8
b0"8
 }Zb0"8
}Zb0"8
 ~Zb0"8
~\b0"8
Bc0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
`b0"8
2QK'2
bQNn2
rQO/2
QR12
QS12
QV12
QW12
"RZ"3
b3xA
J-0-
J-P-
"8)@M
`H+0
.0QH
GaG7d
V r;K
0Pa 
2@K0
('r`0
HA-.
HJ+ 
,A5P
.PHYi
DLo/0a
h1lC
Tp~Z
`/0QD
i0Pa
.0aA}
v`c0
/0aA
xv0"
v0b
obMK
@0K
vj`H
I('auD
@DW&
~0KI
0'auD
0@f
@D;}n
v0\Hsa
f~p
)R9S
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
A#66
%QZP
2(IP
2HMP
 5Bd
2D$H
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
A#66
(~@X@
;K`T
2LU0
9('auD
B17
5`8K0T
,A1P
@pb0
F}B7
xIYpp
o3ODH
BPFpu
%0J
2$H0
PH-p
,ASH
6/ |
1('auD
5P8K0T
FqB7
2 I`
2I~m
2D$H
`@R
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
ksi{#
c+s1c
XA/h
20KPB)\
B0K 
^ PC
D0KP
r0K 
KX81
%('auD
@-S~
#(5}
`]LDH
)R9So
)R9S}
@akk!
V0\Hc
7Dd
t$r
f0@f 
_>m/
`HV$
2D$H
 0BXe`!P
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
yyqs{
ck9K
qIsssIs
{k{A{k+{9K
lnJP
KP4Y
/HAL
_a*&
?c_a'G
5^!B
fa6]Q
\QJ'
g*e[
ls1[
lo0Z1
Ya[j
Yq/R
m5-Y
9gtXA
|d8X1.
W1_f
WAZ#z
 $ x@
 <nx@
 twy@
 l5z@
 dcz@
 $d{@
 xw{@
 (#|@
 |*|@
 hf|@
 ds|@
 h$}@
 h-}@
g+dVA
TA_sG
n1tS
p(8S
p*SA
*&-R17v"
QQFZ
/jkQQ
;aQQ
`?7Q
s-Q!F
)tzP
(;iPa
+w8P
i80P
%&(P
  '{@
 l4{@
 8a{@
 |#|@
 |>|@
 4o|@
 4w|@
 d-}@
 08}@
 l=}@
 |b}@
 xg}@
 hl}@
 (q}@
 <z}@
T    D
(@@@@
)@@@@
Xb0"
Bb0"
Bb0"
Bb0"
Db0"
db0"
Fb0"
Fb0"
Fb0"
Fb0"
Fb0"
Fb0"
Hb0"
Nb0"
Nb0"
Nb0"
Pb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
Tb0"
`D0V
(ag"2
`D0V
`D0V
`D0V
4!j$2
`D0V
8aj$2
`D0V
`D0V
`D0V
d!kd2
`D0V
hak(2
`D0V
`D0V
`D0V
t!n)2
`D0V
xan)2
`D0V
`D0V
`D0V
!o+2
`D0V
ao+2
`D0V
`D0V
`D0V
!r+2
`D0V
ar+2
`D0V
`D0V
`D0V
!s+2
`D0V
as+2
`D0V
`D0V
`D0V
!v+2
`D0V
av+2
`D0V
`D0V
`D0V
$"w 3
Ff0" 
Ff0" 
hf0" 
Jf0" 
Jf0" 
Jf0" 
Lf0" 
f0" 
Lj/e
Rf0" 
AMr/e
Rf0" 
Mz/e
Rf0" 
Tf0" 
Tf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
Xf0" 
Xf0" 
Xf0" +
Xf0" 
0Xf0" 
0Xf0" 
1Xf0" +
1Xf0" 
2Xf0" 
2Xf0" 
3Xf0" +
3Xf0" 
4Xf0" 
4Xf0" 
5Xf0" +
5Xf0" 
6Xf0" 
6Xf0" 
7Xf0" +
7Xf0" 
8Xf0" 
8Xf0" 
9Xf0" +
9Bh0" 
A;bP
@PA
n8@3
&.1bB 
TpZX
1aB 
-(``A
EMX7P
.0q
J- B`A
@(tZ
fK+ 
2HQP
x7-!
2PYp
2h]0
.?LX
ws3bP
wu5bP
3YqBB\
B3 E
+~m
 LNd
05o
0@f
')+-/13579;=?ACEGIKMOQSUWY[]n'/
<<<<H<<<<Y
EEEEEELEEEEEEESEEEEEEEEEEEEEEEE
oljn
....)GDBF
{{B{j{{{{v
----------------------
-----------
uuuu#
DDDDD
(*AAAAAAAAAAAAAAAA1
 ,"$.0
@,26
*4(8
:B<>DF.0
22QG
I((KK
KMKKKKO
U}}.++
../++
%,%%%%F
,.6 
*2//
yuu{{
{}{{{{
K==MM
MOMMMMQ
`ZZbb
bdbbbbf
PKPPPPM$
####
6U6U6UUUUUUUUUU666UUUUUUU
UUUUUUUUUUUUUU[U@
$+$$$$I
(0((((
NUNNNNf

(*((((,
_[[aa
acaaaae
NAAPP
PRPPPPT
BBBBB
4N4)&
(2((((4
\&\\\\*1'
0)0000-
.VV2**
=')
-!O>
ZZZZ
GJGGGGL3//
<<6<H<<<<JLI
KVKKKKXOL3
NN3NVNNNN[
bbbb#
1111
wwwwwwwww
\\\\"UU
RRRRRRRRR]a
C9'
;;';=;;;;??;;
8~__
+8IL\r~
 "    $(
"$""""&
DDD@DDDV
pwGDl
pwGDpww
//////
zODD
DD@DD
%%%%%%%!%%%%%%%%%%%%%%%#
%%%%%%%!%%%%%%%%%%%%%%%#
)!)))#)))))))')))))))))))))))%
OOOOO1OO11
'*******%****)
VVVVV
VV``
%%%%%%%!%%%%%%%%%%%%%%%#
)#)))!)))))))%)))))))))))))))'
`cf9il
<?oBrEux{~
%%%%%%%
%%%%%%%%%%%%%%%
"&*.5GKT
/377;?GKOS
$$$$$$$$
&$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$
 (08@
"%5*-0
HN6T
$`<
iiiiiii
iiiii
iiiiiiiiiiiiiiiiiiiiiiiiiiiii
xz|~
^^^^^^^^^^
7=+C
-86$G
13/7<95;
FuFFF
@DoooooooooooooHL
%\D\\\H
%
2?4)y
F{Q\gk
*******
#;E?EEEAEEEEEEECEEEEEEEEEEEEEEE=
/-919993999999959999999999999997
&CI4L)P/
3333333357
DGJY
_behk
8;>A
/a<aaa>aaaaaaa@aaaaaaaaaaaaaaa1
0^?^^^A^^^^^^^C^^^^^^^^^^^^^^^2#
0AZFZZZKZZZZZZZPZZZZZZZZZZZZZZZU
7,.024
#*1111111111111C111111J1111Q1111111111111111111111111111111111111111111111111111X
P8:P=@
;?CGKOSW[_cgkosw
\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\
\\\\
/)))))))))))))))))))))8
4;iiiiiiiiiiiiii
iiiii@
$1YY
DRJV
%xx1
e,CeeW
!(gg`
8TTL
 *tti
)Bhh\
yyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
y-9yy
ytyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyE
 "$&(*,.02468:<>@BDFHJLNPRTV
+-/13579;
1111
11111111151O
<OOS
0 $(,
z&fj
nVr2
FMV`
5BO\g
$-6?HQZclu~

666666
6666666A666666666666666I
&2JN>W
,&,,,.,,,,,,,0#
8>888@8888888B888888888888888D/
DVDDDXDDDDDDDZDDDDDDDDDDDDDDDRDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDT;
PhPPPjPPPPPPPlPPPPPPPPPPPPPPPnPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPpG
\~\\\
\\\\\\\
\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
hhhhhhh
hhhhhhhhhhhhhhh
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
IN+V
MM#)
::::::
::::::::::::::::"
TTTTTTTTTTTTTTTTTTTT
T!2;TTTTTTTTTTTTTTDTTTYTTTb
'GGGGGGGGGGGGGGGGGGGGGG9
44444
St20bad_array_new_length
St9bad_alloc
St12length_error
St11logic_error
St9exception
OOOO!%
OOOO!
1NNcM
F[ep
syylr
9JJ;@
27<AFKP
UZ_di
*JJJJJJJJJJJJJJJJJJJJ2JJJJJJJJJJJJ
uuuuuuuuuuuuuu
uuuuu@u@
FJNRVZ
,$39$?C
$$(P
<83G
    
  {{{{{{{{{{{{{{{{  
%+!:
.9!]OU
l]]Yk
_YYU^
>>>>>>>>>>>>>>(>>>>>>>4>>>>>4{
<<<<<<<<<<<<<<<<<<<<S<<<<<<<<<<<<<<<<<<<<<<%
1--33
3533337
#((((((((((((((
RRRRRRRRRRRRRRRRRRRRRRR
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
RR RR
RRRR
RRRRRRRRRRR&,R2R8RRRRRRRRRRRRRRRRRRR>RRRRRRRRRRRRRRDI
RRRR
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRNRRRRRRwRRRR}RRRRRRRRRRRRRRRRRRRRRRRRRRRR
RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
RRRRRRRRRRRRR
RRRRRRRRRR
TeeQO
#9>+
&.S]8.#
%!!''
')''''+
@@@@@@@@@@@@
Q
ie`t
Tccccccccc^cTcccccccccccc
ccccccccccccccccccccccccccccccccccccccXX
55gcc
jff
i8b  
    
7,,
77.**
686666:
ii[XX
(1:<GPZcx
11R--
660--
)QQ  
    
  zzzzzzzzzzzzzzzz  
<FEEFEE
FEEFEE
FEE`EEFEE`EE
 #&)
,/258;>ADGJMPSVY
liveOnEntry
Optimization Remark Emitter
G&,5ER
.,,,
0JHHH
$   
rohooo
E'''
u(((
!!!1'
iYYY
<SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSC
IIIIII
RII\
FFDDd
B111
    
  JJJJJJJJJJJJJJJJ  
x$$$
KKff
dddddd
eeeeeeT
TTTTTTq
+###
aiii

ff7N
N!!!
!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!+
!!!!!!!!!!!!!!!!!!!!!!!
!!!!
!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!
[[[aaagggmsssmmyyy






?E&&(
"$""""&

dddddddd
!(*.0,2
0aC{L(eeeee
eee-eeeeeee/eee1e36
-058;@E**JOT
:L\v
YYYYYYY
YYYY
36WY
Y!$9
'*<25J
JJJJJJJ
JJJJ
8;>HJ
!*U7UG
CCCC
CCCCCCC-$
&@Z 
 PV]dsy
'2CS
/5A_
!0?HQ`o~
'2>HS
<<<<<<<<<<<<<
))XXXX9
44XXXX
IXXXXXXXXXXXXX0&
---!
$+4;BKR[d
 '.;BI`g
#*1:CMX
$1YY
++++++MQ+++++++++++++++++++++++++++++++++++++U


 ,oo
++++#
kkkk
;;;;
+XXXX
JOV\cisy
*7@Qbo|:EP**
+29@G
J#JJJJ*
:44??
?8????<
7B:BBB4E;
?99DD
D=DDDDA
4969992MC
GAALL
LELLLLI
%I(III"RH
LFFQQ
QJQQQQN
%I(III"08(C
:66<<
<><<<<@
e=^^^
^^!!^^r^^^
$0<HT`lx
////
yyyy#
HHHH
yyyy#
HHHH
yyyy#
HHHH
EEEE#
++++#
II}III
;;;;;;;;;
;;;;;
;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-?:\,[]{}#&*!|>'"%@`
")HKUekx{
)+))))-1'
)##++
+-++++/:4=@CFlILO
////////.
JJJJJJJ
JJJJJJJJJJJ
JJJJ@
?,,?
??,?
////:
////////w
JJJJJJJ
JJJJJJJJJJJ
JJJJC
??????
???????
++++
++++
..D...E
..T...D
..D...D
..D...D
..D.
MMLL[
MMLL[
MMLL[
LLLLMMMMMM
MMLL[
MMLL[
MMLL[
MMLL[
LLLLMMMMLLL
LLLLMMMMLLL
LLLLMMMMLL
MMLL[
LLLLMMMMLLLLMMMMML
MMLL[
MMLL[
MMMD
LLLLMMMMLLL
LLLLMMMMLL
MMMD
LLLLMMMMLL
MMMD
...D...D...D...D...D...D..D
,,,,YYYY;;;;JJJJ,,,
,,,,YYYY;;;;JJJJ,,,
,,,,,,,
,,,,,,,
,,,,,,,
YYJJ;;,,JJ;;YYJJ;;,,JJ;;U99
YYJJ;;,,JJ;;YYJJ;;,,JJ;;U99
zzzz
zzzz
;;;;JJJJ;;;;JJJJUD
,,,,YYYY;;;;JJJJU99
;;;;JJJJ;;;;JJJJUD
,,,,YYYY;;;;JJJJU
,,,,YYYY;;;;JJJJ@
PD33PD33PD33PDDDPDDDPDDDPD33PD33PD33P4
PD33PD33PD33PDDDPDDDPDDDPD33PD33PD33PD4
PD33PDDDPD33P4
PD33PDDDPD33PD4
,,,,,,,
zzzzzzz
;;;;;;;;zzz
;;;;J,,JJ;;JJ;;JJ,,JJ;;JJ;;J;,,
zzzzJJJ,;JJ
YYYYYYY
JJJJJJJ
JJJJJJJ
,,,,JJJ
,,,,,,,
;,,;YJJY,YY,J;;J;,,
;,,;YJJYJ;;J,,,,JJJJ;;;;;,,;YJJYJ;;J,,,,JJJJ;;;;;,,;YJJYJ;;J;,,;YJJYJ;;J;,,
,,,,;JJ
,,,,,,,,,,,
{{{{
----KKK
B|||C
 K.D0L.D [.D [.D0
GB,,,
|L|CJ
[BJzJ
L|LC
BYzY
[{[BJzJ
L|LCYzY
[{[B
BzYz
{[{B
[BL|LCYzY
[{[BJzJ
L|LCYzY
[{[B|L|C
BzYz
{[{B0
Bzzz
|||C0
|<|C;z
B|||C0
B|||C0
 K.D0L.D [.D [.D3
JJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLLJJJJKKKKLLLL;;;;<<<<====
zzJz{{K{||L|YYYYZZZZ[[[[,,,,----
YYYYZZZZ[[[[YYYYZZZZ[[[[JJJ
JJJJ.
zzzz
,,,,;;
YYY"
JJJJYJJYYJJYJJJJYJJYYJJYJ;;J;;;;J;;J;;;;J;;JJ;;J,,,,,,,
))))
!!#!#
""""""""""""""
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%
""""""""""""""""""
"""""
##########
''''''
((((
((((((((((((((((
((((((((
))))))))
))))))))
))))))))
*****
**********
******
,---
0000
0000000000000000000100


BEHK-NQTW0
ilZ]`3'
or6cu
${<~?f)*1111101
==)-
&$&&&&(
B@BBBBD
+-1/111
!!!!
,.,,,,0
/))11
1311115-&
,/,,,,2M
,&,,,,(
'4AN[hu
'4AN[hu
EEEE#
EEEE#
EEEE#
EEEE#
EEEE#
BGBBBBu
fl6r<x
ccccccccc
W\_2+
8K_T
8K_T 


"%(+.
:=C@
   ...
CKEW
4444O
3A333T
49<7
!(:H
&=HVdoz
                                                                                
=CO\`
=CO\`
[0;30m
[0;31m
[0;32m
[0;33m
[0;34m
[0;35m
[0;36m
[0;37m
[0;1;30m
[0;1;31m
[0;1;32m
[0;1;33m
[0;1;34m
[0;1;35m
[0;1;36m
[0;1;37m
[0;40m
[0;41m
[0;42m
[0;43m
[0;44m
[0;45m
[0;46m
[0;47m
[0;1;40m
[0;1;41m
[0;1;42m
[0;1;43m
[0;1;44m
[0;1;45m
[0;1;46m
[0;1;47m
#'+/37;?
!%)-159=AEIMQUY]aeimquy}
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
#&*.2hhhhhhhhh6:>BFIMQUY]ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhe
6"68
#-7HYj{
N3iga10FatalErrorE
St13runtime_error
+1%>5
'$-0*.(
"%(H)
258;>
 #&h
ILORU
Z]`cf
!$'*-
%(+.1oI
"%(+.
&),/2!f
X[^ad
ux{~
147:=4+
 #&)
,++((
VY\_b1(
 #&4
69<?B
DGJMP1(
 #&xo
adgjmI@
258;>vm
_behkvm
_behk
UX[^a1(
 #&4
69<?B
DGJMPJA
369<?xo
adgjmI@
258;>
]`cfi#
,/258
,/258
>ADGJ
 #&)
69<?B
 #&YP
BEHKN
147:=
147:=
69<?B
 #&YP
BEHKN
"%(E&
 #&)
&-4>ELr@
#*18?FMT[bip
2:BJRZbjr
!(/6>IP\f
JRZbjrz
#(/4;@IQY`
EIOSY]ci
 #&),/2;DGJMVY
&*.2
)$7$$$
$$$$$$$
$$$$$$$$$$$$$$$
..2:CKS
'*2:B
#*18?FMT[bipN3iga11SyntaxErrorE
!"#$
)*+,
llvm.
aarch64
amdgcn
hexagon
mips
nvvm
r600
s390
xcore
null-pointer-is-valid
true
wasm
not_intrinsic
llvm.addressofreturnaddress
llvm.adjust.trampoline
llvm.annotation
llvm.assume
llvm.bitreverse
llvm.bswap
llvm.canonicalize
llvm.ceil
llvm.clear_cache
llvm.codeview.annotation
llvm.convert.from.fp16
llvm.convert.to.fp16
llvm.copysign
llvm.coro.alloc
llvm.coro.begin
llvm.coro.destroy
llvm.coro.done
llvm.coro.end
llvm.coro.frame
llvm.coro.free
llvm.coro.id
llvm.coro.noop
llvm.coro.param
llvm.coro.promise
llvm.coro.resume
llvm.coro.save
llvm.coro.size
llvm.coro.subfn.addr
llvm.coro.suspend
llvm.cos
llvm.ctlz
llvm.ctpop
llvm.cttz
llvm.dbg.addr
llvm.dbg.declare
llvm.dbg.label
llvm.dbg.value
llvm.debugtrap
llvm.donothing
llvm.eh.dwarf.cfa
llvm.eh.exceptioncode
llvm.eh.exceptionpointer
llvm.eh.return.i32
llvm.eh.return.i64
llvm.eh.sjlj.callsite
llvm.eh.sjlj.functioncontext
llvm.eh.sjlj.longjmp
llvm.eh.sjlj.lsda
llvm.eh.sjlj.setjmp
llvm.eh.sjlj.setup.dispatch
llvm.eh.typeid.for
llvm.eh.unwind.init
llvm.exp
llvm.exp2
llvm.expect
llvm.experimental.constrained.cos
llvm.experimental.constrained.exp
llvm.experimental.constrained.exp2
llvm.experimental.constrained.fadd
llvm.experimental.constrained.fdiv
llvm.experimental.constrained.fma
llvm.experimental.constrained.fmul
llvm.experimental.constrained.frem
llvm.experimental.constrained.fsub
llvm.experimental.constrained.log
llvm.experimental.constrained.log10
llvm.experimental.constrained.log2
llvm.experimental.constrained.nearbyint
llvm.experimental.constrained.pow
llvm.experimental.constrained.powi
llvm.experimental.constrained.rint
llvm.experimental.constrained.sin
llvm.experimental.constrained.sqrt
llvm.experimental.deoptimize
llvm.experimental.gc.relocate
llvm.experimental.gc.result
llvm.experimental.gc.statepoint
llvm.experimental.guard
llvm.experimental.patchpoint.i64
llvm.experimental.patchpoint.void
llvm.experimental.stackmap
llvm.experimental.vector.reduce.add
llvm.experimental.vector.reduce.and
llvm.experimental.vector.reduce.fadd
llvm.experimental.vector.reduce.fmax
llvm.experimental.vector.reduce.fmin
llvm.experimental.vector.reduce.fmul
llvm.experimental.vector.reduce.mul
llvm.experimental.vector.reduce.or
llvm.experimental.vector.reduce.smax
llvm.experimental.vector.reduce.smin
llvm.experimental.vector.reduce.umax
llvm.experimental.vector.reduce.umin
llvm.experimental.vector.reduce.xor
llvm.fabs
llvm.floor
llvm.flt.rounds
llvm.fma
llvm.fmuladd
llvm.frameaddress
llvm.fshl
llvm.fshr
llvm.gcread
llvm.gcroot
llvm.gcwrite
llvm.get.dynamic.area.offset
llvm.icall.branch.funnel
llvm.init.trampoline
llvm.instrprof.increment
llvm.instrprof.increment.step
llvm.instrprof.value.profile
llvm.invariant.end
llvm.invariant.start
llvm.launder.invariant.group
llvm.lifetime.end
llvm.lifetime.start
llvm.load.relative
llvm.localaddress
llvm.localescape
llvm.localrecover
llvm.log
llvm.log10
llvm.log2
llvm.longjmp
llvm.masked.compressstore
llvm.masked.expandload
llvm.masked.gather
llvm.masked.load
llvm.masked.scatter
llvm.masked.store
llvm.maxnum
llvm.memcpy
llvm.memcpy.element.unordered.atomic
llvm.memmove
llvm.memmove.element.unordered.atomic
llvm.memset
llvm.memset.element.unordered.atomic
llvm.minnum
llvm.nearbyint
llvm.objectsize
llvm.pcmarker
llvm.pow
llvm.powi
llvm.prefetch
llvm.ptr.annotation
llvm.read_register
llvm.readcyclecounter
llvm.returnaddress
llvm.rint
llvm.round
llvm.sadd.with.overflow
llvm.setjmp
llvm.sideeffect
llvm.siglongjmp
llvm.sigsetjmp
llvm.sin
llvm.smul.with.overflow
llvm.sqrt
llvm.ssa.copy
llvm.ssub.with.overflow
llvm.stackguard
llvm.stackprotector
llvm.stackrestore
llvm.stacksave
llvm.strip.invariant.group
llvm.thread.pointer
llvm.trap
llvm.trunc
llvm.type.checked.load
llvm.type.test
llvm.uadd.with.overflow
llvm.umul.with.overflow
llvm.usub.with.overflow
llvm.va_copy
llvm.va_end
llvm.va_start
llvm.var.annotation
llvm.write_register
llvm.xray.customevent
llvm.xray.typedevent
llvm.aarch64.clrex
llvm.aarch64.crc32b
llvm.aarch64.crc32cb
llvm.aarch64.crc32ch
llvm.aarch64.crc32cw
llvm.aarch64.crc32cx
llvm.aarch64.crc32h
llvm.aarch64.crc32w
llvm.aarch64.crc32x
llvm.aarch64.crypto.aesd
llvm.aarch64.crypto.aese
llvm.aarch64.crypto.aesimc
llvm.aarch64.crypto.aesmc
llvm.aarch64.crypto.sha1c
llvm.aarch64.crypto.sha1h
llvm.aarch64.crypto.sha1m
llvm.aarch64.crypto.sha1p
llvm.aarch64.crypto.sha1su0
llvm.aarch64.crypto.sha1su1
llvm.aarch64.crypto.sha256h
llvm.aarch64.crypto.sha256h2
llvm.aarch64.crypto.sha256su0
llvm.aarch64.crypto.sha256su1
llvm.aarch64.dmb
llvm.aarch64.dsb
llvm.aarch64.get.fpcr
llvm.aarch64.hint
llvm.aarch64.isb
llvm.aarch64.ldaxp
llvm.aarch64.ldaxr
llvm.aarch64.ldxp
llvm.aarch64.ldxr
llvm.aarch64.neon.abs
llvm.aarch64.neon.addhn
llvm.aarch64.neon.addp
llvm.aarch64.neon.cls
llvm.aarch64.neon.fabd
llvm.aarch64.neon.facge
llvm.aarch64.neon.facgt
llvm.aarch64.neon.faddv
llvm.aarch64.neon.fcvtas
llvm.aarch64.neon.fcvtau
llvm.aarch64.neon.fcvtms
llvm.aarch64.neon.fcvtmu
llvm.aarch64.neon.fcvtns
llvm.aarch64.neon.fcvtnu
llvm.aarch64.neon.fcvtps
llvm.aarch64.neon.fcvtpu
llvm.aarch64.neon.fcvtxn
llvm.aarch64.neon.fcvtzs
llvm.aarch64.neon.fcvtzu
llvm.aarch64.neon.fmax
llvm.aarch64.neon.fmaxnm
llvm.aarch64.neon.fmaxnmp
llvm.aarch64.neon.fmaxnmv
llvm.aarch64.neon.fmaxp
llvm.aarch64.neon.fmaxv
llvm.aarch64.neon.fmin
llvm.aarch64.neon.fminnm
llvm.aarch64.neon.fminnmp
llvm.aarch64.neon.fminnmv
llvm.aarch64.neon.fminp
llvm.aarch64.neon.fminv
llvm.aarch64.neon.fmulx
llvm.aarch64.neon.frecpe
llvm.aarch64.neon.frecps
llvm.aarch64.neon.frecpx
llvm.aarch64.neon.frintn
llvm.aarch64.neon.frsqrte
llvm.aarch64.neon.frsqrts
llvm.aarch64.neon.ld1x2
llvm.aarch64.neon.ld1x3
llvm.aarch64.neon.ld1x4
llvm.aarch64.neon.ld2
llvm.aarch64.neon.ld2lane
llvm.aarch64.neon.ld2r
llvm.aarch64.neon.ld3
llvm.aarch64.neon.ld3lane
llvm.aarch64.neon.ld3r
llvm.aarch64.neon.ld4
llvm.aarch64.neon.ld4lane
llvm.aarch64.neon.ld4r
llvm.aarch64.neon.pmul
llvm.aarch64.neon.pmull
llvm.aarch64.neon.pmull64
llvm.aarch64.neon.raddhn
llvm.aarch64.neon.rbit
llvm.aarch64.neon.rshrn
llvm.aarch64.neon.rsubhn
llvm.aarch64.neon.sabd
llvm.aarch64.neon.saddlp
llvm.aarch64.neon.saddlv
llvm.aarch64.neon.saddv
llvm.aarch64.neon.scalar.sqxtn
llvm.aarch64.neon.scalar.sqxtun
llvm.aarch64.neon.scalar.uqxtn
llvm.aarch64.neon.sdot
llvm.aarch64.neon.shadd
llvm.aarch64.neon.shll
llvm.aarch64.neon.shsub
llvm.aarch64.neon.smax
llvm.aarch64.neon.smaxp
llvm.aarch64.neon.smaxv
llvm.aarch64.neon.smin
llvm.aarch64.neon.sminp
llvm.aarch64.neon.sminv
llvm.aarch64.neon.smull
llvm.aarch64.neon.sqabs
llvm.aarch64.neon.sqadd
llvm.aarch64.neon.sqdmulh
llvm.aarch64.neon.sqdmull
llvm.aarch64.neon.sqdmulls.scalar
llvm.aarch64.neon.sqneg
llvm.aarch64.neon.sqrdmulh
llvm.aarch64.neon.sqrshl
llvm.aarch64.neon.sqrshrn
llvm.aarch64.neon.sqrshrun
llvm.aarch64.neon.sqshl
llvm.aarch64.neon.sqshlu
llvm.aarch64.neon.sqshrn
llvm.aarch64.neon.sqshrun
llvm.aarch64.neon.sqsub
llvm.aarch64.neon.sqxtn
llvm.aarch64.neon.sqxtun
llvm.aarch64.neon.srhadd
llvm.aarch64.neon.srshl
llvm.aarch64.neon.sshl
llvm.aarch64.neon.sshll
llvm.aarch64.neon.st1x2
llvm.aarch64.neon.st1x3
llvm.aarch64.neon.st1x4
llvm.aarch64.neon.st2
llvm.aarch64.neon.st2lane
llvm.aarch64.neon.st3
llvm.aarch64.neon.st3lane
llvm.aarch64.neon.st4
llvm.aarch64.neon.st4lane
llvm.aarch64.neon.subhn
llvm.aarch64.neon.suqadd
llvm.aarch64.neon.tbl1
llvm.aarch64.neon.tbl2
llvm.aarch64.neon.tbl3
llvm.aarch64.neon.tbl4
llvm.aarch64.neon.tbx1
llvm.aarch64.neon.tbx2
llvm.aarch64.neon.tbx3
__builtin_IB_get_simd_id
llvm.aarch64.neon.tbx4
llvm.aarch64.neon.uabd
llvm.aarch64.neon.uaddlp
llvm.aarch64.neon.uaddlv
llvm.aarch64.neon.uaddv
llvm.aarch64.neon.udot
llvm.aarch64.neon.uhadd
llvm.aarch64.neon.uhsub
llvm.aarch64.neon.umax
llvm.aarch64.neon.umaxp
llvm.aarch64.neon.umaxv
llvm.aarch64.neon.umin
llvm.aarch64.neon.uminp
llvm.aarch64.neon.uminv
llvm.aarch64.neon.umull
llvm.aarch64.neon.uqadd
llvm.aarch64.neon.uqrshl
llvm.aarch64.neon.uqrshrn
llvm.aarch64.neon.uqshl
llvm.aarch64.neon.uqshrn
llvm.aarch64.neon.uqsub
llvm.aarch64.neon.uqxtn
llvm.aarch64.neon.urecpe
llvm.aarch64.neon.urhadd
llvm.aarch64.neon.urshl
llvm.aarch64.neon.ursqrte
llvm.aarch64.neon.ushl
llvm.aarch64.neon.ushll
llvm.aarch64.neon.usqadd
llvm.aarch64.neon.vcopy.lane
llvm.aarch64.neon.vcvtfp2fxs
llvm.aarch64.neon.vcvtfp2fxu
llvm.aarch64.neon.vcvtfp2hf
llvm.aarch64.neon.vcvtfxs2fp
llvm.aarch64.neon.vcvtfxu2fp
llvm.aarch64.neon.vcvthf2fp
llvm.aarch64.neon.vsli
llvm.aarch64.neon.vsri
llvm.aarch64.sdiv
llvm.aarch64.sisd.fabd
llvm.aarch64.sisd.fcvtxn
llvm.aarch64.stlxp
llvm.aarch64.stlxr
llvm.aarch64.stxp
llvm.aarch64.stxr
llvm.aarch64.udiv
llvm.amdgcn.alignbit
llvm.amdgcn.alignbyte
llvm.amdgcn.atomic.dec
llvm.amdgcn.atomic.inc
llvm.amdgcn.break
llvm.amdgcn.buffer.atomic.add
llvm.amdgcn.buffer.atomic.and
llvm.amdgcn.buffer.atomic.cmpswap
llvm.amdgcn.buffer.atomic.or
llvm.amdgcn.buffer.atomic.smax
llvm.amdgcn.buffer.atomic.smin
llvm.amdgcn.buffer.atomic.sub
llvm.amdgcn.buffer.atomic.swap
llvm.amdgcn.buffer.atomic.umax
llvm.amdgcn.buffer.atomic.umin
llvm.amdgcn.buffer.atomic.xor
llvm.amdgcn.buffer.load
llvm.amdgcn.buffer.load.format
llvm.amdgcn.buffer.store
llvm.amdgcn.buffer.store.format
llvm.amdgcn.buffer.wbinvl1
llvm.amdgcn.buffer.wbinvl1.sc
llvm.amdgcn.buffer.wbinvl1.vol
llvm.amdgcn.class
llvm.amdgcn.cos
llvm.amdgcn.cubeid
llvm.amdgcn.cubema
llvm.amdgcn.cubesc
llvm.amdgcn.cubetc
llvm.amdgcn.cvt.pk.i16
llvm.amdgcn.cvt.pk.u16
llvm.amdgcn.cvt.pk.u8.f32
llvm.amdgcn.cvt.pknorm.i16
llvm.amdgcn.cvt.pknorm.u16
llvm.amdgcn.cvt.pkrtz
llvm.amdgcn.dispatch.id
llvm.amdgcn.dispatch.ptr
llvm.amdgcn.div.fixup
llvm.amdgcn.div.fmas
llvm.amdgcn.div.scale
llvm.amdgcn.ds.bpermute
llvm.amdgcn.ds.fadd
llvm.amdgcn.ds.fmax
llvm.amdgcn.ds.fmin
llvm.amdgcn.ds.permute
llvm.amdgcn.ds.swizzle
llvm.amdgcn.else
llvm.amdgcn.else.break
llvm.amdgcn.end.cf
llvm.amdgcn.exp
llvm.amdgcn.exp.compr
llvm.amdgcn.fcmp
llvm.amdgcn.fdiv.fast
llvm.amdgcn.fdot2
llvm.amdgcn.fmad.ftz
llvm.amdgcn.fmed3
llvm.amdgcn.fmul.legacy
llvm.amdgcn.fract
llvm.amdgcn.frexp.exp
llvm.amdgcn.frexp.mant
llvm.amdgcn.groupstaticsize
llvm.amdgcn.icmp
llvm.amdgcn.if
llvm.amdgcn.if.break
llvm.amdgcn.image.atomic.add.1d
llvm.amdgcn.image.atomic.add.1darray
llvm.amdgcn.image.atomic.add.2d
llvm.amdgcn.image.atomic.add.2darray
llvm.amdgcn.image.atomic.add.2darraymsaa
llvm.amdgcn.image.atomic.add.2dmsaa
llvm.amdgcn.image.atomic.add.3d
llvm.amdgcn.image.atomic.add.cube
llvm.amdgcn.image.atomic.and.1d
llvm.amdgcn.image.atomic.and.1darray
llvm.amdgcn.image.atomic.and.2d
llvm.amdgcn.image.atomic.and.2darray
llvm.amdgcn.image.atomic.and.2darraymsaa
llvm.amdgcn.image.atomic.and.2dmsaa
llvm.amdgcn.image.atomic.and.3d
llvm.amdgcn.image.atomic.and.cube
llvm.amdgcn.image.atomic.cmpswap.1d
llvm.amdgcn.image.atomic.cmpswap.1darray
llvm.amdgcn.image.atomic.cmpswap.2d
llvm.amdgcn.image.atomic.cmpswap.2darray
llvm.amdgcn.image.atomic.cmpswap.2darraymsaa
llvm.amdgcn.image.atomic.cmpswap.2dmsaa
llvm.amdgcn.image.atomic.cmpswap.3d
llvm.amdgcn.image.atomic.cmpswap.cube
llvm.amdgcn.image.atomic.dec.1d
llvm.amdgcn.image.atomic.dec.1darray
llvm.amdgcn.image.atomic.dec.2d
llvm.amdgcn.image.atomic.dec.2darray
llvm.amdgcn.image.atomic.dec.2darraymsaa
llvm.amdgcn.image.atomic.dec.2dmsaa
llvm.amdgcn.image.atomic.dec.3d
llvm.amdgcn.image.atomic.dec.cube
llvm.amdgcn.image.atomic.inc.1d
llvm.amdgcn.image.atomic.inc.1darray
llvm.amdgcn.image.atomic.inc.2d
llvm.amdgcn.image.atomic.inc.2darray
llvm.amdgcn.image.atomic.inc.2darraymsaa
llvm.amdgcn.image.atomic.inc.2dmsaa
llvm.amdgcn.image.atomic.inc.3d
llvm.amdgcn.image.atomic.inc.cube
llvm.amdgcn.image.atomic.or.1d
llvm.amdgcn.image.atomic.or.1darray
llvm.amdgcn.image.atomic.or.2d
llvm.amdgcn.image.atomic.or.2darray
llvm.amdgcn.image.atomic.or.2darraymsaa
llvm.amdgcn.image.atomic.or.2dmsaa
llvm.amdgcn.image.atomic.or.3d
llvm.amdgcn.image.atomic.or.cube
llvm.amdgcn.image.atomic.smax.1d
llvm.amdgcn.image.atomic.smax.1darray
llvm.amdgcn.image.atomic.smax.2d
llvm.amdgcn.image.atomic.smax.2darray
llvm.amdgcn.image.atomic.smax.2darraymsaa
llvm.amdgcn.image.atomic.smax.2dmsaa
llvm.amdgcn.image.atomic.smax.3d
llvm.amdgcn.image.atomic.smax.cube
llvm.amdgcn.image.atomic.smin.1d
llvm.amdgcn.image.atomic.smin.1darray
llvm.amdgcn.image.atomic.smin.2d
llvm.amdgcn.image.atomic.smin.2darray
llvm.amdgcn.image.atomic.smin.2darraymsaa
llvm.amdgcn.image.atomic.smin.2dmsaa
packed_double4
llvm.amdgcn.image.atomic.smin.3d
llvm.amdgcn.image.atomic.smin.cube
llvm.amdgcn.image.atomic.sub.1d
llvm.amdgcn.image.atomic.sub.1darray
llvm.amdgcn.image.atomic.sub.2d
llvm.amdgcn.image.atomic.sub.2darray
llvm.amdgcn.image.atomic.sub.2darraymsaa
llvm.amdgcn.image.atomic.sub.2dmsaa
llvm.amdgcn.image.atomic.sub.3d
llvm.amdgcn.image.atomic.sub.cube
llvm.amdgcn.image.atomic.swap.1d
llvm.amdgcn.image.atomic.swap.1darray
llvm.amdgcn.image.atomic.swap.2d
llvm.amdgcn.image.atomic.swap.2darray
llvm.amdgcn.image.atomic.swap.2darraymsaa
llvm.amdgcn.image.atomic.swap.2dmsaa
llvm.amdgcn.image.atomic.swap.3d
llvm.amdgcn.image.atomic.swap.cube
llvm.amdgcn.image.atomic.umax.1d
llvm.amdgcn.image.atomic.umax.1darray
llvm.amdgcn.image.atomic.umax.2d
llvm.amdgcn.image.atomic.umax.2darray
llvm.amdgcn.image.atomic.umax.2darraymsaa
llvm.amdgcn.image.atomic.umax.2dmsaa
llvm.amdgcn.image.atomic.umax.3d
llvm.amdgcn.image.atomic.umax.cube
llvm.amdgcn.image.atomic.umin.1d
llvm.amdgcn.image.atomic.umin.1darray
llvm.amdgcn.image.atomic.umin.2d
llvm.amdgcn.image.atomic.umin.2darray
llvm.amdgcn.image.atomic.umin.2darraymsaa
llvm.amdgcn.image.atomic.umin.2dmsaa
llvm.amdgcn.image.atomic.umin.3d
llvm.amdgcn.image.atomic.umin.cube
llvm.amdgcn.image.atomic.xor.1d
llvm.amdgcn.image.atomic.xor.1darray
llvm.amdgcn.image.atomic.xor.2d
llvm.amdgcn.image.atomic.xor.2darray
llvm.amdgcn.image.atomic.xor.2darraymsaa
llvm.amdgcn.image.atomic.xor.2dmsaa
llvm.amdgcn.image.atomic.xor.3d
llvm.amdgcn.image.atomic.xor.cube
llvm.amdgcn.image.gather4.2d
llvm.amdgcn.image.gather4.2darray
llvm.amdgcn.image.gather4.b.2d
llvm.amdgcn.image.gather4.b.2darray
llvm.amdgcn.image.gather4.b.cl.2d
llvm.amdgcn.image.gather4.b.cl.2darray
llvm.amdgcn.image.gather4.b.cl.cube
llvm.amdgcn.image.gather4.b.cl.o.2d
llvm.amdgcn.image.gather4.b.cl.o.2darray
llvm.amdgcn.image.gather4.b.cl.o.cube
llvm.amdgcn.image.gather4.b.cube
llvm.amdgcn.image.gather4.b.o.2d
llvm.amdgcn.image.gather4.b.o.2darray
llvm.amdgcn.image.gather4.b.o.cube
llvm.amdgcn.image.gather4.c.2d
llvm.amdgcn.image.gather4.c.2darray
llvm.amdgcn.image.gather4.c.b.2d
llvm.amdgcn.image.gather4.c.b.2darray
llvm.amdgcn.image.gather4.c.b.cl.2d
llvm.amdgcn.image.gather4.c.b.cl.2darray
llvm.amdgcn.image.gather4.c.b.cl.cube
llvm.amdgcn.image.gather4.c.b.cl.o.2d
llvm.amdgcn.image.gather4.c.b.cl.o.2darray
llvm.amdgcn.image.gather4.c.b.cl.o.cube
llvm.amdgcn.image.gather4.c.b.cube
llvm.amdgcn.image.gather4.c.b.o.2d
llvm.amdgcn.image.gather4.c.b.o.2darray
llvm.amdgcn.image.gather4.c.b.o.cube
llvm.amdgcn.image.gather4.c.cl.2d
llvm.amdgcn.image.gather4.c.cl.2darray
llvm.amdgcn.image.gather4.c.cl.cube
llvm.amdgcn.image.gather4.c.cl.o.2d
llvm.amdgcn.image.gather4.c.cl.o.2darray
llvm.amdgcn.image.gather4.c.cl.o.cube
llvm.amdgcn.image.gather4.c.cube
llvm.amdgcn.image.gather4.c.l.2d
llvm.amdgcn.image.gather4.c.l.2darray
llvm.amdgcn.image.gather4.c.l.cube
llvm.amdgcn.image.gather4.c.l.o.2d
llvm.amdgcn.image.gather4.c.l.o.2darray
llvm.amdgcn.image.gather4.c.l.o.cube
llvm.amdgcn.image.gather4.c.lz.2d
llvm.amdgcn.image.gather4.c.lz.2darray
llvm.amdgcn.image.gather4.c.lz.cube
llvm.amdgcn.image.gather4.c.lz.o.2d
air-propagate-assumptions
llvm.amdgcn.image.gather4.c.lz.o.2darray
llvm.amdgcn.image.gather4.c.lz.o.cube
llvm.amdgcn.image.gather4.c.o.2d
llvm.amdgcn.image.gather4.c.o.2darray
llvm.amdgcn.image.gather4.c.o.cube
llvm.amdgcn.image.gather4.cl.2d
llvm.amdgcn.image.gather4.cl.2darray
llvm.amdgcn.image.gather4.cl.cube
llvm.amdgcn.image.gather4.cl.o.2d
llvm.amdgcn.image.gather4.cl.o.2darray
llvm.amdgcn.image.gather4.cl.o.cube
llvm.amdgcn.image.gather4.cube
llvm.amdgcn.image.gather4.l.2d
llvm.amdgcn.image.gather4.l.2darray
llvm.amdgcn.image.gather4.l.cube
llvm.amdgcn.image.gather4.l.o.2d
llvm.amdgcn.image.gather4.l.o.2darray
llvm.amdgcn.image.gather4.l.o.cube
llvm.amdgcn.image.gather4.lz.2d
llvm.amdgcn.image.gather4.lz.2darray
llvm.amdgcn.image.gather4.lz.cube
llvm.amdgcn.image.gather4.lz.o.2d
llvm.amdgcn.image.gather4.lz.o.2darray
llvm.amdgcn.image.gather4.lz.o.cube
llvm.amdgcn.image.gather4.o.2d
llvm.amdgcn.image.gather4.o.2darray
llvm.amdgcn.image.gather4.o.cube
llvm.amdgcn.image.getlod.1d
llvm.amdgcn.image.getlod.1darray
llvm.amdgcn.image.getlod.2d
llvm.amdgcn.image.getlod.2darray
llvm.amdgcn.image.getlod.3d
llvm.amdgcn.image.getlod.cube
llvm.amdgcn.image.getresinfo.1d
llvm.amdgcn.image.getresinfo.1darray
llvm.amdgcn.image.getresinfo.2d
llvm.amdgcn.image.getresinfo.2darray
llvm.amdgcn.image.getresinfo.2darraymsaa
llvm.amdgcn.image.getresinfo.2dmsaa
llvm.amdgcn.image.getresinfo.3d
llvm.amdgcn.image.getresinfo.cube
llvm.amdgcn.image.load.1d
llvm.amdgcn.image.load.1darray
llvm.amdgcn.image.load.2d
air.perspective
llvm.amdgcn.image.load.2darray
llvm.amdgcn.image.load.2darraymsaa
llvm.amdgcn.image.load.2dmsaa
llvm.amdgcn.image.load.3d
llvm.amdgcn.image.load.cube
llvm.amdgcn.image.load.mip.1d
llvm.amdgcn.image.load.mip.1darray
llvm.amdgcn.image.load.mip.2d
llvm.amdgcn.image.load.mip.2darray
llvm.amdgcn.image.load.mip.3d
llvm.amdgcn.image.load.mip.cube
llvm.amdgcn.image.sample.1d
llvm.amdgcn.image.sample.1darray
llvm.amdgcn.image.sample.2d
llvm.amdgcn.image.sample.2darray
llvm.amdgcn.image.sample.3d
llvm.amdgcn.image.sample.b.1d
llvm.amdgcn.image.sample.b.1darray
llvm.amdgcn.image.sample.b.2d
llvm.amdgcn.image.sample.b.2darray
llvm.amdgcn.image.sample.b.3d
llvm.amdgcn.image.sample.b.cl.1d
error: backend compiler failed build.
llvm.amdgcn.image.sample.b.cl.1darray
llvm.amdgcn.image.sample.b.cl.2d
llvm.amdgcn.image.sample.b.cl.2darray
llvm.amdgcn.image.sample.b.cl.3d
llvm.amdgcn.image.sample.b.cl.cube
llvm.amdgcn.image.sample.b.cl.o.1d
llvm.amdgcn.image.sample.b.cl.o.1darray
llvm.amdgcn.image.sample.b.cl.o.2d
llvm.amdgcn.image.sample.b.cl.o.2darray
llvm.amdgcn.image.sample.b.cl.o.3d
llvm.amdgcn.image.sample.b.cl.o.cube
llvm.amdgcn.image.sample.b.cube
Indirect ICB Propagaion
llvm.amdgcn.image.sample.b.o.1d
llvm.amdgcn.image.sample.b.o.1darray
llvm.amdgcn.image.sample.b.o.2d
llvm.amdgcn.image.sample.b.o.2darray
llvm.amdgcn.image.sample.b.o.3d
llvm.amdgcn.image.sample.b.o.cube
FCmpPaternMatch
llvm.amdgcn.image.sample.c.1d
llvm.amdgcn.image.sample.c.1darray
llvm.amdgcn.image.sample.c.2d
llvm.amdgcn.image.sample.c.2darray
if.else
llvm.amdgcn.image.sample.c.3d
llvm.amdgcn.image.sample.c.b.1d
const-prop with shader-const replacement
llvm.amdgcn.image.sample.c.b.1darray
llvm.amdgcn.image.sample.c.b.2d
Hoist FMul in Loop Pass
llvm.amdgcn.image.sample.c.b.2darray
Custom Unsafe Optimization Pass
llvm.amdgcn.image.sample.c.b.3d
HoistFMulInLoopPass
llvm.amdgcn.image.sample.c.b.cl.1d
.seg2
llvm.amdgcn.image.sample.c.b.cl.1darray
IGC Custom Loop Opt
llvm.amdgcn.image.sample.c.b.cl.2d
IGC Loop canonicalization
llvm.amdgcn.image.sample.c.b.cl.2darray
.backedge
llvm.amdgcn.image.sample.c.b.cl.3d
llvm.loop
llvm.amdgcn.image.sample.c.b.cl.cube
IGC loop canonicalization
llvm.amdgcn.image.sample.c.b.cl.o.1d
Pass promotes indirect addrspace resource access to direct addrspace
llvm.amdgcn.image.sample.c.b.cl.o.1darray
PromoteResourceToDirectAS
llvm.amdgcn.image.sample.c.b.cl.o.2d
igc-promote-stateless-to-bindless
llvm.amdgcn.image.sample.c.b.cl.o.2darray
copysign
llvm.amdgcn.image.sample.c.b.cl.o.3d
copysignl
llvm.amdgcn.image.sample.c.b.cl.o.cube
fabsf
llvm.amdgcn.image.sample.c.b.cube
llvm.amdgcn.image.sample.c.b.o.1d
fminf
llvm.amdgcn.image.sample.c.b.o.1darray
fmax
llvm.amdgcn.image.sample.c.b.o.2d
fmaxl
callees
costmodel-reduxcost
Undefined temporary symbol
Load/Store operand is not a pointer type
new_entry
readNone: 
expected section directive before assembly directive
-nocopyprop
Symbol name with unsupported characters
Resolve atomic built-ins
fast_math_enable
lsr-insns-cost
Add instruction count to a LSR cost model
llvm.hexagon.C4.nbitsclri
targetlibinfo
__stack_chk_fail
brackets expression not supported on this target
you must specify a stack pointer offset
.symtab
unable to evaluate offset to undefined symbol '
__builtin_IB_atomic_or_global_i32
Allocation failed
Explicit load/store type does not match pointee type of pointer operand
packed_uint
object_map_buf
All llvm.experimental.deoptimize declarations must have the same calling convention
end of file in global variable name
llvm.genx.GenISA.fcmpxchgatomicstructured
 data registers written
Src2HorzStride
llvm.arm.cdp2
llvm.hexagon.A2.abssat
llvm.hexagon.C4.nbitsclr
Target Library Information
__sync_fetch_and_max_4
__atomic_fetch_nand_8
unmatched .ifs or .elses
expected function id within range [0, UINT_MAX)
unexpected token in variant, expected ')'
register can't be represented in SEH unwind info
<unknown>:
Access size field must be a constant
rel32@hi
 Sym:
.gfids$y
, bit: 
Expected token before separator in datalayout string
num_work_groups_x
expected ')' in address space
globalSize
DeviceEnqueueFuncsResolution
__builtin_IB_get_group_id
fast_math_disable
Function Pass Manager
storing unsized types is not allowed
DICompileUnit not listed in llvm.dbg.cu
llvm.genx.GenISA.PullCentroidBarys
!DIEnumerator(
__svml_exp8
.lshr.outer.true.branch
_ret
 registers read back
SG3(0x
jip label invalid
undefined label
llvm.amdgcn.image.sample.d.cl.o.3d
llvm.arm.cdp
llvm.arm.neon.vrecps
llvm.hexagon.A2.absp
llvm.hexagon.A2.vminub
llvm.hexagon.C4.fastcorner9.not
, notEligibleToImport: 
__fixtfsi
__unordsf2
__sync_fetch_and_max_1
__atomic_fetch_xor_16
Invalid TYPE table
.sleb128
.addrsig
unexpected token in '.comm' or '.lcomm' directive
function id already allocated
invalid token in expression
a handler attribute must begin with '@'
expected region type after '.data_region' directive
bfrev@
unexpected token in '.version' directive
.rel
undefined .align directive, value size '
dtprel@ha
gotpcrel32@hi
 Size:
section_types_dwo
.xdata
S_ATTR_DEBUG
TooCostly
 <unknown operation 
, relbf: 
, info: 
Preferred alignment cannot be less than the ABI alignment
pass-remarks-analysis
__builtin_IB_atomic_or_global_i16
texture_buffer
Cannot load/store from pointer
llvm.
__builtin_spirv_BuiltInGlobalInvocationId
error: 
air.intersection
packed_uint2
indirect calls are not supported
float2x2
va_arg requires operand with first class type
<Invalid operator> 
BasicBlockPass Manager
invalid thrown type
Enclosing function does not use GC.
Stored value type does not match pointer operand type!
!dbg attachment of global variable must be a DIGlobalVariableExpression
invalid value for llvm.ident metadata entry operand(the operand should be a string)
Addr_Flag_RA
DebugCounter Error: 
Map Name: 
Allocation failed
vfabsf
llvm.pow.f32
__svml_exp2
SIMD8
sample gradient
returns new value
 address registers written
Src2TernaryImm
sg8h
FDIV
__atomic_exchange_8
CantFullUnrollAsDirectedRuntimeTripCount
implicit type on src should be omitted
invalid instruction option
llvm.amdgcn.image.sample.c.lz.o.1d
llvm.amdgcn.image.sample.d.cl.o.2darray
llvm.amdgcn.log.clamp
llvm.amdgcn.wwm
llvm.arm.neon.vcvtnu
llvm.arm.neon.vrecpe
llvm.arm.smlawt
llvm.hexagon.A2.abs
llvm.hexagon.A2.subh.l16.sat.ll
llvm.hexagon.A2.vminh
llvm.hexagon.A4.vcmpheqi
llvm.hexagon.C4.fastcorner9
__exp10f
__umodqi3
__powixf2
__fixxfdi
__floatundisf
__gttf2
__sync_fetch_and_add_4
__sync_fetch_and_nand_2
__atomic_fetch_xor_4
__atomic_fetch_nand_4
.fill
.iflt
.cv_filechecksumoffset
.exitm
.warning
.ds.s
expected absolute expression
expected identifier in directive
unexpected token after '.bundle_lock' directive option
unexpected token in '.cv_file' directive
pointless default value for required parameter '
 * $$
invalid modifier '
unknown flag
section '
.objc_meth_var_types
ignoring directive .load for now
invalid '.zerofill' directive size, can't be less than zero
__string_object
unknown platform name
entry size must be positive
expected 'unique'
flushsampler@
.globl
, Index:
Allocation failed
dtprel@l
LDPLT
TYPEINDEX
 PaddingPoliciesMask:
<MCInst 
.debug_loc
.debug$H
.drectve
S_THREAD_LOCAL_VARIABLE_POINTERS
S_ATTR_SELF_MODIFYING_CODE
Unfinished frame!
!DILocation(
 weak
 exact
inrange 
(callee: ^
wpdRes: (kind: 
llvm.loop.interleave.count
Invalid ABI alignment, must be a power of 2
NoDebug
pass-remarks-missed
Dominator Tree Construction
bindless_sampler_t
num_work_groups_y
__builtin_IB_atomic_cmpxchg_global_i16
opencl.enable.FP_CONTRACT
SLOTGRP_LO
EXTRACTVAL: Invalid instruction with 0 indices
Ensures single precision divide and sqrt are correctly rounded
enqueuedLocalSize
deviceEnqueuePreferedWorkgroupMultiple
BorderColorB
error decoding SIMD size from descriptor
packed_uchar
expected three operands to shufflevector
local
__builtin_spirv_OpEnqueueKernel
mainFunc
__builtin_IB_get_local_id_x
rgba8unorm
__builtin_IB_copyNDRangeTondrange
MaxNumOfInputSignatureEntries
unknown
if.end
cleanuppad
malloccall
BasicBlock Pass Manager
 (has loop)
'allocsize' 
invalid thrown types list
ptrtoint not supported for non-integral pointers
llvm.gcroot parameter #1 must either be a pointer alloca, or argument #2 must be a non-null constant.
gc.statepoint must read and write all memory to preserve reordering restrictions required by safepoint semantics
Store operand must be a pointer.
PtrToInt type mismatch
members of llvm.used must be named
incorrect number of operands in llvm.ident metadata
  Host CPU: 
rng-seed
  %7.4f (%5.1f%%)
llvm.hexagon.A4.vcmpbgtui
question-mark
tilde
/var/tmp/
greater-than-sign
statvfs
stpncpy
strtoull
vsscanf
vacoshf
__svml_cosf8
CISA SAMPLER ISA_SAMPLE/ISA_LOAD instruction only accepts non-zero channel masks.
Unaligned Oword Block Read Sampler Cache
SIMD16
_aligned
unmonitor
sample compare
1H (1 Oword accessed in high half of GRF)
no return value
sampler 
sg8l
: PC 
Else
math.fdiv
Enable LSR phi elimination
lsr-exp-narrow
[NumUses=
Allows loops to be peeled when the dynamic trip count is known to be low.
Unable to unroll loop as directed by unroll(enable) pragma because unrolled size is too large.
src1: immediate supported here on ternary instruction.
expected 'b' (branch control)
syntax error in region (width)
expected }
iga_disassemble* call uses deprecated options  (hex_floats or print_pc); see newest iga.h header file for updated fields
llvm.amdgcn.image.sample.c.d.cl.cube
llvm.amdgcn.image.sample.c.lz.cube
llvm.amdgcn.image.sample.cd.o.2d
llvm.amdgcn.image.sample.d.cl.o.2d
llvm.amdgcn.image.sample.lz.o.cube
llvm.amdgcn.lerp
llvm.amdgcn.s.waitcnt
llvm.amdgcn.writelane
llvm.arm.neon.aesimc
llvm.arm.neon.vcvtns
llvm.arm.neon.vpadd
llvm.arm.neon.vraddhn
llvm.arm.neon.vtbx1
llvm.arm.smlawb
llvm.arm.uadd8
llvm.bpf.pseudo
llvm.hexagon.A2.maxu
llvm.hexagon.A2.subh.l16.sat.hl
llvm.hexagon.A2.vadduhs
llvm.hexagon.A2.vminb
llvm.hexagon.A4.cmpbeqi
llvm.hexagon.C2.cmpgtu
llvm.hexagon.C4.cmpneqi
llvm.genx.GenISA.floatatomicraw
umulH@
Detected conflicting code assumptions. Program may have undefined behavior, or compiler may have internal error.
__muloti4
__moddi3
__gcc_qsub
__powisf2
__gcc_qtos
__fixdfsi
__floatsixf
__floatunsitf
__gesf2
__gtsf2
__llvm_memset_element_unordered_atomic_4
__sync_fetch_and_add_1
__sync_fetch_and_or_8
__sync_fetch_and_xor_16
__atomic_load
__atomic_exchange_2
__atomic_fetch_sub_8
__atomic_fetch_xor_1
__atomic_fetch_nand_2
higher
.8byte
.p2alignl
.incbin
.ifgt
.space
.cv_stringtable
.cfi_restore
.err
.dcb.s
.ds.l
expected identifier after '.ifdef'
expected '=' after formal parameter identifier
 in directive
non-local symbol required
unexpected token in '
invalid bundle alignment size (expected between 0 and 30)
is_stmt value not 0 or 1
expected file number in '.cv_file' directive
expected symbol name
missing parameter qualifier for '
expression is not a constant value
unexpected expression in align
unexpected symbol modifier following '@'
CmpXchgFail
.seh_handlerdata
expected comma in directive
invalid '.secrel32' directive offset, can't be less than zero or greater than std::numeric_limits<uint32_t>::max()
.data_region
.mod_term_func
.objc_meta_class
.ios_version_min
unexpected token in '.dump' or '.load' directive
.secure_log_unique specified multiple times
__thread_bss
__thread_ptr
__protocol
invalid OS update version number
tvos
.note
expected '%<type>' or "<type>"
invalid metadata symbol
Unnamed pass: implement Pass::getPassName()
.rela
FK_Data_Sub_4
.byte
IndirectCallOptimization
  Symbols:[
' begins
image1d_buffer
DTPREL
TLVPPAGEOFF
tlsldo
tprel@highest
got@tlsgd@l
LDGOT
Check for input errors
MCCVInlineLineTableFragment
 Inst:
Analyze aggregate arguments
General options
__debug_gnu_pubn
__LLVM_FAULTMAPS
.debug_gnu_pubtypes
.debug_line.dwo
.stack_sizes
__builtin_IB_atomic_xchg_global_i32
.subsection
lazy_symbol_pointers
S_LAZY_DYLIB_SYMBOL_POINTERS
S_THREAD_LOCAL_VARIABLES
S_ATTR_LIVE_SUPPORT
stack allocation size is not a multiple of 8
asterisk
avr_intrcc 
target datalayout = "
<temporary!> 
!DILabel(
notail 
swifterror 
 contract
 No predecessors!
 <<NULL ALIASEE>>
, flags: (
, returnDoesNotAlias: 
, bitMask: 
__builtin_IB_atomic_cmpxchg_global_i64
Objective-C Class Properties
palignr
Unknown specifier in datalayout string
__builtin_IB_atomic_min_global_i16
DIFlagSingleInheritance
CSK_MD5
pattern
File
DeletedBBs:
__builtin_IB_get_num_groups
use of undefined value '@
patch_index_buffer_offset
__builtin_IB_atomic_inc_global_i16
bindless_image1d_buffer_t
texturecube_array
MoveStaticAllocasPass
PtrDstToInt
Old-style alloca with a non-pointer type
Never resolved function from blockaddress
Invalid multiple synchronization scope names blocks
igc-break-const-expr
Invalid value
_igc_bif_%s_%s
true
__ocl_dbg_gid
imageDataType
expected end of struct constant
Add implicit args to all functions in the module and adjusts call to these functions
__builtin_IB_get_default_device_queue
BestStage1
error: backend compiler failed build.
packed_ulong
igc-device-enqueue-func-analysis
packed_half
packed_uint3
packed_ushort
_Z45get_kernel_preferred_work_group_size_multiple
air.vertex_id
air.stage_in_grid_size
cond_dim2_true
__builtin_spirv_OpGetKernelLocalSizeForSubgroupCount
__builtin_IB_get_local_id_y
invalid forward reference to function as global value!
AirFastFlagPropagationResolve
round
float2x3
half4x3
input
captured value is null
Colects read-write textures indexes and removes texture fences
acc3
GenStrengthReduction
flattenSmallSwitch
PromoteStatelessToBindless
addrspacecast
landingpad
mallocsize
remark
' on Loop '
... Pass execution timing report ...
External
Function arguments must have first-class types!
' does not apply to function returns
' does not apply to functions!
invalid reference flags
subprogram declarations must not have a compile unit
Instruction has a name, but provides a void value!
inttoptr not supported for non-integral pointers
inalloca isn't on the last argument!
llvm.gcroot parameter #2 must be a constant.
gc.relocate: vector relocates to vector and pointer to pointer
 label and !dbg attachment
CatchSwitchInst handlers must be catchpads
atomic memory access' operand must have a power-of-two size
zext source and destination must both be a vector or neither
PtrToInt result must be integral
cannot guarantee tail call due to mismatched varargs
invalid llvm.used member
llvm.ident
: See: 
  Default target: 
_Znwm
-Tps
__sinpif
fflush
        -----     
musleabihf
,#tls
backspace
exclamation-mark
right-curly-bracket
TEMPDIR
DW_TAG_enumerator
P%d's number of elements(%d) is not valid: %s
Constant Immediate operands are not allowed to be used as destination operands.
DW_TAG_common_inclusion
preserve_mostcc
attributes
sprintf
sinhl
llvm.genx.GenISA.atomiccounterinc
strncmp
strtold
unsetenv
llvm.genx.GenISA.discard
vlogbf
vcoshf
__svml_cos4
llvm.genx.GenISA.fcmpxchgatomicrawA64
Data type of the second source of ADDR_ADD should be WORD or BYTE.
MT2R_BS
DWord Scattered Read
Dword Scattered Read Constant Cache
L3 implies L1 flush
a64 byte scattering write
 aligned
7046
monitor event
 with Per-Coarse Pixel PS outputs enable
sample override LOD
sample load mcs auxilary data
1L (1 Oword accessed in low half of GRF)
 (SLM)
ReturnDataControl
AtomicIntegerOp
.bti[
ExDescAddrSubRegNum
nop doesn't support Switch option (dropping)
Src0ChanSel
Src2RegFile
sg4x2
 after kernel end
The call instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the call instruction. If none of the channels jump into the subroutine, the call instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
When SPF is on, the predication control must be scalar.
The following section describes JIP, the jump offset, for DevHSW+.
JIP can be an immediate or register value. When a jump occurs, this value is added to IP pre-increment. For DevHSW+, in GEN binary, JIP is at location src1 and src0 must be null. The GRF register must be put (for example, by the assembler) at dst location.
Format: [(pred)] call (exec_size) dst JIP
Format: [(pred)] call (exec_size) dst JIP
else
line
fdiv
The maximum number of SCEV checks allowed for Loop Distribution for loop marked with #pragma loop distribute(enable)
The cost threshold for partial loop unrolling
unroll-allow-partial
flat-loop-tripcount-threshold
p2align directive with no operand(s) is ignored
Threshold to use for inner loop when doing unroll and jam.
) accessing GED_
Align1 not available on this platform
N3 is obsolete; use M8 in execution offset: e.g. op (4|M8) ...
jmpi must have (W) specified (automatically adding)
expected destination type
invalid region horizontal stride
 must be an immediate label
iga_assemble call uses deprecated options  (error_on_compact_fail or autoset_deps); see newest iga.h header file for updated fields
llvm.amdgcn.image.sample.c.cd.cl.o.3d
llvm.amdgcn.image.sample.c.cl.o.1darray
llvm.amdgcn.image.sample.c.d.cl.3d
llvm.amdgcn.image.sample.c.l.2d
llvm.amdgcn.image.sample.c.lz.3d
llvm.amdgcn.image.sample.cd.3d
llvm.amdgcn.image.sample.cd.o.1darray
llvm.amdgcn.image.sample.cube
llvm.amdgcn.image.sample.d.cl.o.1darray
llvm.amdgcn.image.sample.l.o.1darray
llvm.amdgcn.image.sample.lz.o.3d
llvm.amdgcn.image.store.mip.1darray
llvm.amdgcn.ldexp
llvm.amdgcn.rsq.clamp
llvm.amdgcn.s.sleep
llvm.amdgcn.udot4
llvm.amdgcn.wqm.vote
llvm.arm.ldc
llvm.arm.neon.aese
llvm.arm.neon.vabs
llvm.arm.neon.vcvtmu
llvm.arm.neon.vld3lane
llvm.arm.neon.vpadalu
llvm.arm.neon.vqrdmulh
llvm.arm.neon.vqsubu
llvm.arm.neon.vshifts
llvm.arm.neon.vtbl4
llvm.arm.set.fpscr
llvm.arm.smlatt
llvm.arm.ssat
llvm.arm.uadd16
llvm.arm.usada8
llvm.bpf.load.word
llvm.hexagon.A2.addpsat
llvm.hexagon.A2.maxp
llvm.hexagon.A2.satb
llvm.hexagon.A2.subh.l16.ll
llvm.hexagon.A2.sxtw
llvm.hexagon.A2.vaddubs
llvm.hexagon.A2.vcmpbgtu
llvm.hexagon.A2.vmaxw
llvm.hexagon.A2.vsubhs
llvm.hexagon.A4.cmpbeq
llvm.hexagon.A4.orn
llvm.hexagon.A4.vcmpbgti
llvm.hexagon.A6.vcmpbeq.notany.128B
llvm.hexagon.C2.cmpgtp
llvm.hexagon.C2.vitpack
llvm.hexagon.C4.cmpneq
__exp10
scoped-noalias
value-tracking
__ashlti3
__ashrti3
__mulosi4
__udivsi3
__modhi3
__adddf3
__subxf3
__divxf3
__gnu_h2f_ieee
__truncxfsf2
__fixsfdi
DIFlagIntroducedVirtual
__fixunsxfsi
__floatsisf
__floattidf
__floatunsidf
__eqsf2
__netf2
__lesf2
domtree
__llvm_memcpy_element_unordered_atomic_16
__llvm_memset_element_unordered_atomic_1
__sync_val_compare_and_swap_16
__sync_lock_test_and_set_8
__sync_fetch_and_and_1
__sync_fetch_and_or_2
__sync_fetch_and_xor_4
bindless_image_cube_t
__sync_fetch_and_min_4
__sync_fetch_and_umin_8
__atomic_store_2
__atomic_exchange
__atomic_fetch_add_1
__atomic_fetch_sub_2
__atomic_fetch_or_2
Invalid calling convention ID
expected string constant
invalid hexdecimal number
unterminated string constant
redefinition of '
.string
.4byte
.balignw
.weak_definition
.abort
.bundle_align_mode
.ifeq
.ifdef
.endif
.cv_linetable
imageArrSize
.cfi_def_cfa_register
.cfi_restore_state
.macros_off
.endmacro
.dc.l
.dcb.d
.ds.b
DualPatch
parsed instruction: [
expected comma after first string for '.ifeqs' directive
macros cannot be nested more than 
<instantiation>
Wrong number of arguments
unexpected token in directive
'.fill' directive with negative size has no effect
packed_ushort4
expected string in '.include' directive
Could not find incbin file '
expected identifier in '.irpc' directive
unmatched '.endr' directive
file 0 not supported prior to DWARF-5
line number less than zero in '.loc' directive
unknown sub-directive in '.loc' directive
air.threads_per_quadgroup
unexpected token in '.cv_loc' directive
Line number less than zero in '.cv_inline_linetable' directive
unexpected token in '.cfi_signal_frame'
macro '
' is not defined
.warning argument must be a string
literal value out of range for directive
Legalize Global Value Usages
.even
invalid octal escape sequence (out of range)
' (already modified)
igc-air-function-attribute-update
.secidx
.seh_endchained
.weak
indirect_command_buffer
newest
.fix2.addrspacecast
.dump
.tbss
.fvmlib_init0
.literal8
.objc_class_vars
.objc_instance_vars
.static_data
.watchos_version_min
unable to emit indirect symbol attribute for: 
unexpected token in '.subsections_via_symbols' directive
__data
.previous without corresponding .section
invalid '.tbss' alignment, can't be lessthan zero
BlendToDiscard
__la_symbol_ptr
__mod_term_func
__cls_refs
__meta_class
__thread_vars
invalid OS update specifier, comma expected
platform name expected
.version
.data.
Mergeable section must specify the type
llvm_linker_options
Linkage must be 'comdat'
SCC (
expected a '@' in the name
Cannot represent a difference across sections
This instruction shall not have a TBAA access tag!
FK_GPRel_4
FK_SecRel_4
FK_Data_Sub_1
Disabled
.ascii
.quad
Fragment can't be larger than a bundle size
<MCAssembler
GenX CodeGen module
filechecksums_end
opencl_vec_type_hint
.group
.bundle_unlock forbidden when bundling is disabled
<<none>>
TLSLD
TLVP
ABS8
prel31
high
got@ha
tprel@high
11ocl_image1d
got@tprel@l
got@dtprel@ha
IMGREL
GPREL
FUNCTION
 Offset:
MCOrgFragment
MCPaddingFragment
 MaxBytesToEmit:
                
 Signed:
11ocl_image2d
Inst:(
names_begin
__debug_abbrev
__debug_pubnames
__debug_rnglists
__LLVM_STACKMAPS
.debug_info
.debug_pubtypes
.apple_objc
.debug_abbrev.dwo
.llvm_stackmaps
__builtin_IB_atomic_sub_local_i32
addr_sec
Cannot evaluate subsection number
 Fragments:[
      
,comdat
mach-o section specifier has invalid attribute
4byte_literals
non_lazy_symbol_pointers
symbol_stubs
coalesced
S_16BYTE_LITERALS
S_THREAD_LOCAL_ZEROFILL
[:<:]]
__builtin_IB_atomic_max_local_u32
all .cv_loc directives for a function must be in the same section
Chained unwind areas can't have handlers!
frame offset must be less than or equal to 240
EmitRawText called on an MCStreamer that doesn't support it,  something must not be fully mc'ized
!<unknown kind #
dllimport 
<null operand!>
source_filename = "
 = { 
DW_TAG_null
!DILexicalBlock(
!DIGlobalVariable(
 addrspace(
musttail 
 within 
          to 
 nsz
33IGIL_EnqueueKernelWithLocalParams9ocl_queueiPijPvjS0_S0_jS0_j9ndrange_ti12ocl_clkevent
 umax
; <label>:
thread_local 
alias 
 = typeid: (name: "
 ; guid = 
, funcFlags: (
14enqueue_marker9ocl_queuejPKU3AS412ocl_clkeventPU3AS412ocl_clkevent
, wpdResolutions: (
, alignLog2: 
, byArg: (kind: 
null-pointer-is-valid
max.cond
Broken module found, compilation aborted!
^arm\.neon\.vst([1234]|[234]lane)\.v[a-z0-9]*$
empty-set
Sized aggregate specification in datalayout string
Unknown mangling specifier in datalayout string
Invalid preferred alignment, must be a 16bit integer
12read_imageui14ocl_image2d_ro11ocl_samplerDv2_fS_S_
DIFlagPrototyped
DIFlagRValueReference
DIFlagTypePassByReference
DIFlagIndirectVirtualBase
igc-dp-to-fp-load-store
ignoring invalid debug info in 
Pass
String
Insert, 
(no_name)
__builtin_IB_atomic_and_global_i16
local_size_y
num_work_groups_z
stage_in_grid_origin_z
Calculate liveness based on LiveVars
bindless_image2d_msaa_depth_t
air.
__builtin_IB_atomic_dec_global_i16
texture2d_ms
found end of file while parsing summary entry
llvm.dbg.cu
__builtin_IB_atomic_cmpxchg_local_i16
cannot load symbol cmc_load_and_compile
opencl.kernels
opencl.used.optional.core.features
init_spinlock_var.end
Bitwidth for integer type out of range
Never resolved value found in function
ResolveOCLAtomics
 (Producer: '
EXTRACTVAL: Invalid type
Inserted value type doesn't match aggregate type
GTPIN_IGC_OCL Error: Fail to find a free BTI for GT-Pin surface %d
musttail call in non-varargs function
ProcessBuiltinMetaData
vmeMbBlockType
deviceEnqueueGetObjectId
syncBuffer
__ocl_dbg_grid
constBase
const_reg_qword
Analyzes CallGraphSCC
igc-add-implicit-gid
air64-apple-macosx
BorderColorA
IGC::PositionOnlyVertexShader
__builtin_IB_get_max_workgroup_size
insertvalue operand must be aggregate type
packed_double
__builtin_IB_get_block_simd_size
packed_char
packed_uchar2
packed_long
register regioning restriction warning: ExecSize == Src.W && Src.H != 0 && Src.V != Src.W * Src.H (vertical misalignment)
see Programmer's Reference Manual (Restriction 2.2)
packed_short
State Register
packed_int
Output the .llvm generated from TransformBlocks pass
air.arg_type_name
constant
packed_float
_Z41get_kernel_max_sub_group_size_for_ndrange
air.thread_index_in_threadgroup
expected unsigned integer
__builtin_spirv_OpGetKernelNDrangeMaxSubGroupSize
air.read
max-work-group-size
UserDefined
igc-block-transform
air.sampler_state
__builtin_IB_get_local_id_y
sat_exp
Enqueue param is not a struct
r8unorm
srgba8unorm
AirEmulateArgumentBuffers
NDRange type mismatch
float4x4
47intel_work_group_vme_mb_multi_bidir_check_16x16PU3AS3jjjjDv2_ihhi14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
bool
enqueue_kernel signature does not match
LegalizeResourcePointer
MaxNumOfOutputSignatureEntries
Check unresolved builtin functions
pointer_buf
Translate AIR
PreprocessMetadata
air.center
igc-custom-safe-opt
fatal flex scanner internal error--end of buffer missed
address model
globalPtrArgMappingBuf
Print BasicBlock IR
cmpxchg
bitcast
insertvalue
__thread_data
warning
.size
; Delta: 
 ***
' on Region '
pass
function_entry_count
-dumpVisaOptions
) attempted to be registered!
Offset not zero at the point of scalar access
Argument value does not match function argument type!
Invalid user of intrinsic instruction!
Attribute '
Attributes 'optsize and optnone' are incompatible!
' only applies to functions!
inlined-at should be a location
invalid vtable holder
invalid global variable ref
invalid unit type
Unexpected metadata round-trip through values
Only PHI nodes may reference their own value!
fpmath accuracy must have float type
Invalid bitcast
Duplicate integer as switch case
Attribute 'sret' cannot be used for vararg call arguments!
info argument of llvm.coro.begin must refer to an initialized constant
llvm.gcroot parameter #1 must be an alloca.
safepoints should have unique landingpads
gc.relocate: relocated value must be a gc pointer
calls to experimental_deoptimize must be followed by a return
conflicting debug info for argument
gc.statepoint number of deoptimization arguments must be positive
CatchSwitchInst cannot have empty handler list
Logical operators must have same type for operands and result!
atomic memory access' size must be byte-sized
cmpxchg instructions failure argument shall be no stronger than the success argument
ZExt only produces an integer
UIToFP result must be FP or FP vector
PtrToInt source must be pointer
Unwind edges out of a catch must have the same unwind dest as the parent catchswitch
cannot guarantee tail call due to mismatched parameter types
The landingpad instruction should have a consistent result type inside a function.
wrong initalizer for intrinsic global variable
invalid ID operand in module flag (expected metadata string)
expected a Function or null
INVALID
*no default*
: CommandLine Error: Option '
 positional argument
 [options]
(unknown)
Collect information related to vertex shader
__debug_cu_index
__builtin_IB_atomic_add_local_i32
xdg-open
armv6kz
armv7-m
xdot|xdot.py
skel_string
__powl_finite
enable-coldcc-stress-test
Miscellaneous Ungrouped Timers
elfiamcu
musleabi
armv8-a
(Twine 
!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
slash
equals-sign
right-brace
 prologue 
"can't happen" -- you found a bug
TEMP
' for 
DW_TAG_unspecified_parameters
DW_TAG_constant
attributes #
mem_fence
zeroinitializer
llvm.genx.GenISA.add.pair
swiftcc
33IGIL_EnqueueKernelWithLocalParams9ocl_queueiPijPvjS1_S1_jS1_j9ndrange_ti12ocl_clkevent
amdgpu_kernel
qsort
rintl
Allocation failed
putc_unlocked
realpath
rintf
setbuf
stat64
strcoll
strlen
llvm.genx.GenISA.broadcastMessagePhaseV
xyzw
!DIDerivedType(
uname
spill
vsprintf
alias
vlog1pf
llvm.genx.GenISA.dwordatomicstructured
intel_ocl_bicc
llvm.pow.f64
__builtin_IB_atomic_max_global_u16
llvm.ctlz.
MT1W_US
MT2R_A64_US
MTRA_TA
OWord Dual Block Read
Media Block Write
Oword Dual Block Read Constant Cache
MessageType
byte scattering write
global fence
 instruction data
a64 byte gathering read
7075
 unaligned
7155
stride offset meaningless when override not set
disabled
monitor
.f16
PerCoarsePixelPSOutputs
invalid sampler SIMD mode
sample+LOD bias
sample_gather4_po
sample_ld_mcs
sample 8x8
DataElements:MDC_A64_DB_OW
hdc_
surface 
ChannelDisableMask:MDC_CMASK
AtomicOp:MDC_AOP
integer pre-decrement (returns pre-decrement value)
integer compare and swap (non-64b)
per-slot offset in payload
 to surface 
DstRegFile
ex_desc register not supported on this platform for this instruction
Src0SubRegNum
DepCtrl
src%d: unsupported region for translation to align16 encoding
Src0MathMacroExt
src%d: align1 ternary is not supported on this platform.
src1: immediate operand in ternary align1 must be src0 or src2
on <v;h> region w must be Region::WI_INVALID
FlagModifier
cbl128
 before kernel start
register regioning restriction warning: Vertical stride must be used to cross GRF boundaries.
see Programmer's Reference Manual (Restriction 2.8)
The addc instruction performs component-wise addition of src0 and src1 and stores the results in dst; it also stores the carry into acc.
If the operation produces a carry out, 0x00000001 is stored in acc, else 0x00000000 is stored in acc.
Format:
[(pred)] addc[.cmod] (exec_size) dst src0 src1
Bit Field Insert 2
Call
The dph instruction performs a four-wide homogeneous dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every fourth element of src0 (post-source-swizzle if present) is forced to 1.0f.
Use the dp4 instruction to do a four-wide dot product that includes all elements of src0 and src1.
Format:
[(pred)] dph[.cmod] (exec_size) dst src0 src1
The fbl instruction counts component-wise the number of LSB 0 bits before the first 1 bit in src0, storing that number in dst.
Format:
[(pred)] fbl (exec_size) dst src0
If src0 contains no 1 bits, store 0xFFFFFFFF in dst.
The jmpi instruction redirects program execution to an index offset relative to the post-incremented instruction pointer. The index is a signed integer value, with positive or zero integers for forward jumps, and negative integers for backward jumps. In GEN binary, index is at location src1. The ip register must be put (for example, by the assembler) at the dst and src0 locations. Predication is allowed to provide conditional jump with a scalar condition. As the execution size is 1, the first channel of PMASK (flags post prediction control and negate) is used to determine whether the jump is taken or not. If the condition is false, the jump is not taken and execution continues with the next instruction.
Note: Unlike other flow control instructions, the offset used by jmpi is relative to the incremented instruction pointer rather than the IP value for the instruction itself.
Format:
[(pred)] jmpi (1) index {NoMask}
An index of 0 does nothing, continuing execution with the next instruction.
An index of -16 (if the jmpi instruction is in native format) or -8 (if the jmpi instruction is in compact format) is an infinite loop on the jmpi instruction.
Multiply Add
Exponential (E^src0)
.cfi_startproc
__builtin_IB_simd_media_block_write_16_h
unroll-threshold
unexpected token in '.ifb' directive
Set the max unroll count for full unrolling, for testing purposes
llvm.genx.GenISA.vmeSendSIC
__builtin_IB_simd_media_block_write_8_b
expected identifier
 in '
__builtin_IB_sub_group_reduce_OpGroupIAdd
unroll-and-jam-count
IGIL_calc_sub_group_count_for_ndrange
unsupported Align16 ternary destination (unsupported SIMD)
GED reports error (
unconvertible ternary align16 operand
(integral) division by zero
Atomic mot supported on given platform
N2 is obsolete; use M4 in execution offset: e.g. op (4|M4) ...
default_register_type
expected flag subregister
use 
implicit type on dst should be omitted
noacc
syntax error in region (horizontal stride)
Message Descriptor is typeless
jmpi
out of dynamic memory in yyensure_buffer_stack()
instruction option
llvm.amdgcn.image.sample.c.cd.cl.2d
llvm.amdgcn.image.sample.c.cd.cl.o.2darray
llvm.amdgcn.image.sample.c.cd.o.cube
llvm.amdgcn.image.sample.c.cl.o.1d
llvm.amdgcn.image.sample.c.d.2d
llvm.amdgcn.image.sample.c.d.cl.2darray
llvm.amdgcn.image.sample.c.d.o.1d
llvm.amdgcn.image.sample.c.l.1darray
llvm.amdgcn.image.sample.c.l.o.3d
llvm.amdgcn.image.sample.c.lz.2darray
llvm.amdgcn.image.sample.c.o.2d
llvm.amdgcn.image.sample.cd.2darray
llvm.amdgcn.image.sample.cd.cl.o.1darray
llvm.amdgcn.image.sample.cd.o.1d
llvm.amdgcn.image.sample.cl.3d
llvm.amdgcn.image.sample.cl.o.cube
llvm.amdgcn.image.sample.d.cl.2d
llvm.amdgcn.image.sample.d.cl.o.1d
llvm.amdgcn.image.sample.d.o.cube
llvm.amdgcn.image.sample.l.o.1d
llvm.amdgcn.image.sample.lz.2darray
llvm.amdgcn.image.sample.lz.o.2darray
llvm.amdgcn.image.store.1darray
llvm.amdgcn.image.store.mip.1d
llvm.amdgcn.init.exec.from.input
llvm.amdgcn.kill
llvm.amdgcn.ps.live
llvm.amdgcn.rsq
llvm.amdgcn.s.getpc
llvm.amdgcn.s.sendmsghalt
llvm.amdgcn.set.inactive
llvm.amdgcn.udot2
llvm.amdgcn.workitem.id.x
llvm.amdgcn.wqm
llvm.arm.dbg
llvm.arm.ldaexd
llvm.arm.mcrr
llvm.arm.neon.aesd
llvm.arm.neon.sha1su1
llvm.arm.neon.vabdu
llvm.arm.neon.vcvtfp2fxu
llvm.arm.neon.vcvtms
llvm.arm.neon.vld1x2
llvm.arm.neon.vld3dup
llvm.arm.neon.vmins
llvm.arm.neon.vpadals
llvm.arm.neon.vqadds
llvm.arm.neon.vqneg
llvm.arm.neon.vqshiftnu
llvm.arm.neon.vqsubs
llvm.arm.neon.vrintz
llvm.arm.neon.vshiftins
llvm.arm.neon.vst3
llvm.arm.neon.vtbl3
llvm.arm.qsax
llvm.arm.sel
llvm.arm.smlabt
llvm.arm.smlatb
llvm.arm.smulbt
llvm.arm.space
llvm.arm.stcl
llvm.arm.sxtb16
llvm.arm.undefined
llvm.arm.usad8
llvm.arm.vcvtr
llvm.bpf.load.half
llvm.hexagon.A2.addh.h16.sat.lh
llvm.hexagon.A2.addp
llvm.hexagon.A2.combine.hh
llvm.hexagon.A2.max
llvm.hexagon.A2.negsat
llvm.hexagon.A2.sat
llvm.hexagon.A2.subh.h16.ll
llvm.hexagon.A2.subh.l16.hl
llvm.hexagon.A2.svavghs
llvm.hexagon.A2.sxth
llvm.hexagon.A2.vabshsat
llvm.hexagon.A2.vaddub
llvm.hexagon.A2.vavguh
llvm.hexagon.A2.vcmpbeq
llvm.hexagon.A2.vmaxb
llvm.hexagon.A2.vmaxuw
llvm.hexagon.A2.vnavgwcr
llvm.hexagon.A2.vsubh
llvm.hexagon.A2.zxtb
llvm.hexagon.A4.boundscheck
llvm.hexagon.A4.cmphgti
llvm.hexagon.A4.modwrapu
llvm.hexagon.A4.round.rr
llvm.hexagon.A4.vcmpbgt
llvm.hexagon.A4.vrmaxuw
llvm.hexagon.A6.vcmpbeq.notany
llvm.hexagon.C2.cmpeq
llvm.hexagon.C2.cmpgti
llvm.hexagon.C2.muxir
llvm.hexagon.C2.tfrrp
llvm.hexagon.C4.cmpltei
llvm.hexagon.C4.cmplteui
amdgpu_hs
enable-tbaa
enable-scoped-noalias
overdefined
dom-conditions-max-uses
InstrStatitic
__ashlsi3
dereferenceable_or_null
__ashrsi3
inreg
__muldi3
noalias
__udivqi3
noimplicitfloat
nonnull
__negdi2
Allocation failed
__subsf3
readonly
__divsf3
KMPLOCK
-debug
Invalid bit width, must be a 24bit integer
sspstrong
__extendsftf2
Debug Info Version
__trunctfhf2
swifterror
__trunctfxf2
zeroext
DIFlagMultipleInheritance
igc-legalization
__fixunsdfdi
uselistorder
__fixunstfdi
function
__floatditf
typeTestAssumeVCalls
 (hotness: 
!AnalysisFPCommute
__floatuntixf
indir
__nesf2
uniqueRetVal
__lttf2
ppc_fp128
__gcc_qle
__builtin_IB_get_enqueued_local_size
__llvm_memcpy_element_unordered_atomic_4
stage_in_grid_origin_y
__llvm_memmove_element_unordered_atomic_8
global_offset_z
__sync_val_compare_and_swap_4
tess_instance_stride
virtual_binding_table_ps
local_size_x
__sync_fetch_and_sub_8
product
__sync_fetch_and_and_16
depth2d_ms
depthcube_array
sampler
__sync_fetch_and_nand_16
GenOptLegalizer
__sync_fetch_and_min_1
bindless_image2d_array_t
__sync_fetch_and_umin_2
align
__atomic_store
tracepoint
igc-move-static-allocas
__atomic_compare_exchange_8
cmc_free_compile_info
__atomic_fetch_add_16
opencl.compiler.ext.options
__atomic_fetch_and_16
Expected a single module
__atomic_fetch_or_16
Alias and aliasee types don't match
__atomic_fetch_nand_1
__imp_
unterminated comment
Invalid alignment value
unterminated single quote
Operand bundles found with no consumer
unexpected token
Personality function mismatch
.ascii
INSERTVAL: Invalid array index
.2byte
Explicit gep type does not match pointee type of pointer operand
.align32
Expect function block
.p2alignw
Legalization Pass
.private_extern
work_group_size_hint
.common
LegalizeFunctionSignatures
.irpc
less-precise-fpmad
no-nans-fp-math
igc-process-builtin-metaData
.ifnc
stageInGridSize
.else
deviceEnqueueParentEvent
.cv_func_id
smpSnapWA
.cv_def_range
imageNumMipLevels
.cfi_def_cfa_offset
const_reg_fp32
.cfi_lsda
numWorkGroups
.cfi_window_save
pixel_phase
igc.functions
.dc.b
vector
.dcb
BorderColorG
qnan
entry
.print
Low Precision Opt
 not currently supported for this target
expected string parameter for '.ifeqs' directive
basic_string
unexpected token in '.endif' directive
xga8
ulong4
packed_ulong4
unexpected token in macro instantiation
long4
out of range literal value
uchar4
 in '.org' directive
char4
unexpected token in '.zero' directive
ushort4
.abort '
short4
unexpected token in '.incbin' directive
uint4
expected comma in '.irp' directive
half4
packed_half4
int4
MD5 checksum specified, but no file number
float4
file number less than one in '.loc' directive
air.location_index
air.arg_type_size
global
unexpected token in '.cv_func_id' directive
igc-low-precision-opt
line number less than zero in '.cv_loc' directive
air.thread_position_in_threadgroup
File id less than zero in '.cv_inline_linetable' directive
igc-emulate-argument-buffers
 in '.cfi_startproc' directive
cond_dim3_true
igc.read_only_array
expected identifier in '.purgem' directive
__TessNumControlPoints
.error argument must be a string
air.emulation
unknown relocation name
_tmp
unexpected expression in _emit
__builtin_IB_get_local_id_x
xmmword ptr 
denorm_or_zero
.fix1.addrspacecast
__builtin_IB_is_normalized_coords
byte ptr 
air.sampler_states
expected ']' in brackets expression
.section
.symidx
rgb9e5
.seh_endproc
rg16snorm
.seh_pushframe
instance_acceleration_structure
expected comdat type such as 'discard' or 'largest' after protection bits
LowPrecisionOpt Pass
float4x3
half2x4
you must specify one or both of @unwind or @except
packed_bool4
.lsym
air.arg_unused
.secure_log_unique
output
.destructor
igc-air-legalize-resource-addrspace
.literal16
TessInputControlPointCount
.objc_class
igc-check-unresolved-builtin-functions
Pass walks through sampler uses and detects sampler to texture mappings, and converts Sample to SampleL instructions.
AirResolveInlineSamplerWA
.picsymbol_stub
igc-translate-air
.tlv
igc-metadata-schema-wrapper
expected identifier in .indirect_symbol directive
air.no_perspective
Custom Pass Optimization
igc-gen-specific-pattern
__const
Gen strength reduction
__TEXT
register range
unexpected token in '.tbss' directive
igc-custom-loop-opt
unexpected token in '.zerofill' directive
Metadata Utils Wrapper
__fvmlib_init0
switch
__literal8
sdiv
__class_vars
zext
IGC Int Type Legalizer
call
__static_data
selected values for vector select must be vectors
invalid OS minor version number, integer expected
GenXCodeGenModule
alias.scope
.data.rel
disable debug output
.subsection
Print IR after each pass
.tbss.
note
 -*- '
img_access_float_coords
 Analyses:
GenXFunctionGroupAnalysis
 /EXPORT:
-fullIRVerify
unexpected token in '.type' directive
floatatomicraw@
non-global-value-max-name-size
Type size nodes must be constants!
igc-metadata-utils-wrapper
.llvm_addrsig
FK_Data_4
FK_GPRel_1
unmaterialized function cannot have metadata
FK_SecRel_1
Only global arrays can have appending linkage!
FK_Data_Add_4
Attribute 'sret' is not on first or second parameter!
Enabled
Attributes 'byval', 'inalloca', 'inreg', 'nest', and 'sret' are incompatible!
.code64
swifterror value when used in a callsite should be marked with swifterror attribute
-noreassoc
' (at offset '
invalid template parameter
non-zero initializer found in virtual section
line specified with no file
invalid type ref
strtab_end
PHI nodes must have at least one entry.  If the block is dead, the PHI should be removed!
Segment for file '
AS_SECURE_LOG_FILE
-nolocalraroundrobin
Symbol: 
.bundle_align_mode cannot be changed once set
Range types must match instruction type!
Called function is not pointer to function type!
intel_reqd_workgroup_walk_order
MetaData Utils Wrapper
alignment of arg 0 of memory intrinsic must be 0 or a power of 2
tlscall
llvm.invariant.end parameter #2 must be a constant integer
SIZE
gc.relocate operand #3 must be integer offset
igc-purgeMetaDataUtils-import
masked_load: return must match pointer type
invalid llvm.dbg.
got@l
gc.statepoint number of arguments to underlying call must be constant integer
tprel@h
gc.relocate connected to wrong gc.statepoint
tprel@highera
EH pad must be jumped to via an unwind edge
dtprel@highesta
Alloca array size must have integer type
got@dtprel@l
GEP base pointer is not a vector or a vector of pointers
got@tlsld@ha
atomicrmw instructions cannot be unordered.
16ocl_image1darray
Type too small for SExt
UIToFP source and dest vector length mismatch
SIToFP source and dest vector length mismatch
' cannot be used in assignment expr
IntToPtr Vector width mismatch
MCFillFragment
Invalid operand types for ICmp instruction
17ocl_image1dbuffer
SampleCmpToDiscard
 Alignment:
EH pads can't handle each other's exceptions
       
Alias must point to a definition
<MCFragment 
module flag identifiers must be unique (or of 'require' type)
unable to evaluate offset for variable '
Imm:
%Y-%m-%d %H:%M:%S
__common
debug_names_begin
help-list-hidden
types_begin
error - option can never match, because another positional argument will match an unbounded number of values, and this option does not require a value!
section_line_str
must be specified at least once!
__debug_aranges
  Type "
.gcc_except_table
view-background
Execute graph viewer in the background. Creates tmp file litter.
.debug_names
.debug_info.dwo
iwmmxt
xscale
invalid
.debug_cu_index
.debug$T
Unsupported required sub group size
Mismatched bundle_lock/unlock directives
,#write
v5te
Mark empty blocks after deSSA
BlockCoalescing
info-output-file
mach-o section specifier uses an unknown section type
20ocl_image2dmsaadepth
cstring_literals
spir64
literal_pointers
windows
mod_term_funcs
gnuabin32
S_INTERPOSING
25ocl_image2darraymsaadepth
decI:"
__builtin_IB_atomic_max_local_i32
printing of statistics for each inlined function
S_ATTR_STRIP_STATIC_SYMS
live_support
xdigit
parent function id not introduced by .cv_func_id or .cv_inline_site_id
Not all chained regions terminated!
16ocl_image2ddepth
SPIR to IGC metadata translator
vmeSendFBR@
, Sym=
; Function Attrs: 
right-square-bracket
 gc "
REG_BADPAT
hidden 
REG_BADBR
", "
__builtin_IB_atomic_inc_local_i32
Can't redirect stderr to stdout
__builtin_IB_atomic_dec_local_i32
 [null]
!DIBasicType(
!DICompileUnit(
DW_TAG_inlined_subroutine
!DITemplateTypeParameter(
DW_TAG_packed_type
 = !{
DW_TAG_imported_unit
18IGIL_EnqueueKernel9ocl_queuejPvjS_S_jS_j9ndrange_ti12ocl_clkevent
DW_TAG_function_template
          catch 
DW_AT_ordering
 unwind 
DW_AT_containing_type
 nnan
DW_AT_calling_convention
 nsw
igc-spir-metadata-translation
 max
DW_AT_trampoline
DW_AT_elemental
global 
DW_AT_dwo_name
28IGIL_EnqueueKernelWithEvents9ocl_queuejPvjS_S_jS_jiPi9ndrange_tiiPKU3AS412ocl_clkeventPU3AS412ocl_clkevent12ocl_clkevent
DW_AT_call_data_value
", hash: (
DW_AT_MIPS_has_inlines
guid: 
DW_AT_GNU_call_site_value
, aliasee: 
DW_AT_BORLAND_Delphi_class
, noRecurse: 
DW_AT_APPLE_isa
args: (
DW_OP_const2s
Layout
DW_OP_div
, resByArg: (
stack-probe-size
DW_OP_lit11
pmovsx
DW_OP_lit27
ctpop.trunc
DW_OP_reg11
__builtin_IB_atomic_sub_global_i16
DW_OP_reg27
11read_imagei14ocl_image2d_ro11ocl_samplerDv2_fS_S_
printf
Pointer preferred alignment must be a power of 2
DW_OP_breg27
Unexpected trailing characters after mangling specifier in datalayout string
DW_OP_form_tls_address
Invalid address space, must be a 24bit integer
DW_OP_GNU_addr_index
Invalid address space, must be a 24-bit integer
DIFlagProtected
DIFlagArtificial
DW_LANG_Pascal83
DIFlagStaticMember
DW_LANG_C_plus_plus_03
DIFlagMainSubprogram
DW_CC_normal
11read_imagef20ocl_image2d_depth_ro11ocl_samplerDv2_fS_S_
DW_CC_LLVM_X86_64SysV
pass-remarks
R_WEBASSEMBLY_FUNCTION_INDEX_LEB
) in 
!Analysis
mme2
Hotness
MT0W_OWDB
Roots: 
MT1R_A64_SB
11read_imagef20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
MT_CC_OWB
virtual_binding_table_cs
__builtin_IB_get_stage_in_grid_origin
11read_imagei20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
Translate ACL printf
Untyped Atomic Integer Operation
global_size_z
LiveVarsAnalysis
base_instance
msaa_sample_pattern_offset
virtual_binding_table_hs
__builtin_IB_atomic_xor_local_i16
expected 'global' or 'constant'
bindless_image_cube_depth_t
12read_imageui20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
texture2d
bindless_image_cube_array_t
depth2d_array
11read_imagef26ocl_image2d_array_depth_ro11ocl_samplerDv4_fDv2_fS0_
resTy
texture1d_array
texture1d
igc-livenessanalysis
vararg
ICLLP
11read_imagef14ocl_image3d_ro11ocl_samplerDv4_fS_S_
opencl.ocl.version
expected '{' here
e-p:64:64:64
LivenessAnalysis
Invalid vector length
Invalid empty synchronization scope names block
Invalid function comdat ID
11read_imagei14ocl_image3d_ro11ocl_samplerDv4_fS_S_
igc-translate-acl-printf
Explicit gep operator type does not match pointee type of pointer operand
Malformed global initializer set
Advanced DCE on loop
Callee is not of pointer to function type
Fast math flags indicator set for call with no FMF
Explicit call type does not match pointee type of callee operand
12read_imageui14ocl_image3d_ro11ocl_samplerDv4_fS_S_
INSERTVAL: Invalid instruction with 0 indices
Expected ')' in syncscope
Invalid function metadata: incoming forward references
igc-loop-dce
Invalid record
Incompatible epoch: Bitcode '
Could not find function in stream
12write_imagei14ocl_image3d_woDv4_iS_
vector
_igc_bif_%s_%s_size
Types Legalization Pass
Remove dead recurisive PHINode
ProcessFuncAttributes
unsafe-fp-math
__builtin_IB_AllocLocalMemPool
12write_imagei14ocl_image3d_rwDv4_iS_
localMemStatelessWindowSize
expected number in address space
deviceEnqueueDefaultDeviceQueue
__ocl_dbg_lid
imageHeigt
imageOrder
imageNumSamples
12write_imagei16ocl_image2darrayDv4_iS_
Translate ACL Printf
DstAddrSubRegNum
uniform
visaStackCall
igc-add-implicit-args
sample_phase
12write_imagei16ocl_image2d_array_woDv4_iS_
offset
expected basic block name in blockaddress
UserFunction
Operand::Kind::?
RestStage2
EightPatch
12write_imagei20ocl_image2d_array_rwDv4_iS0_
LOCAL_FIRST_FIT_BC_RA
ulong
packed_ulong2
double
12write_imagei20ocl_image2d_array_woDv4_iiS0_
long
constexpr requires integer operands
uchar
LowerGEPForPrivMem
packed_ushort2
char
Accumulator
enable-fmax-fmin-plus-zero
uint
packed_uint4
29intel_work_group_vme_mb_queryPU3AS3jDv2_iS1_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
half
packed_half2
29intel_work_group_vme_mb_queryPU3AS3jDv2_iS1_14ocl_image2d_roS2_11ocl_sampler
float
missing required field 'value'
air.arg_type_align_size
Controls count of merged loads
air.thread_execution_width
air.thread_index_in_quadgroup
air.threads_per_simdgroup
12DoMultiQueryPU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_samplerj
air.buffer
air.instance_id
air.base_instance
memopt-merge-store
threads_per_grid_end
air.read_write
AIR Conversion
37intel_work_group_vme_mb_multi_query_8PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_sampler
MaxNumOfOutputSignatureEntries
invalid type for null constant
AirMsaaSamplePattern
Controls count of merged stores
igc-legalize-global-value-usages
__builtin_IB_get_local_id_z
denorm_or_zero_end
37intel_work_group_vme_mb_multi_query_4PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_roS3_11ocl_sampler
Enable fmax/fmin + 0.0f flag
Logic Xor
rg11b10
igc.internal_symbol
Air Function Attribute Update
air-fast-flag-propagation-mark-pass
41intel_work_group_vme_mb_multi_check_16x16PU3AS3jjjjDv2_ii14ocl_image2d_roS2_S2_11ocl_sampler
rgba16snorm
rg8unorm
error decoding instruction
half3x2
half4x4
visible_function_table
39intel_work_group_vme_mb_multi_check_8x8PU3AS3jjjjDv2_iDv4_i14ocl_image2d_roS3_S3_11ocl_sampler
packed_bool
float2x4
float3x3
struct.ndrange_t
air.global_bindings
air.fragment
air.hull
47intel_work_group_vme_mb_multi_bidir_check_16x16PU3AS3jjjjDv2_ihhi14ocl_image2d_roS2_S2_S2_11ocl_sampler
HullShaderForcedDispatchMask
expected 'unwind' after catchswitch scope
Trivial greedy live range reduction to reduce register pressure for special cases.
IGC Memory Optimization, the 2nd
igc-air-samplers
air-rw-texture-analysis
for arguments marked with raster_order_group, emit sendc
45intel_work_group_vme_mb_multi_bidir_check_8x8PU3AS3jjjjDv2_ihhS1_14ocl_image2d_roS2_S2_S2_11ocl_sampler
Workaround pass used to fix functionality of special cases
subb
igc-air-metadata-parse
igc-memopt2
Custom Const-prop Pass
GenUpdateCB
fatal flex scanner internal error--no action found
IGCIndirectICBPropagaion
Flatten Small Switch
unary send prohibits src1 argument
Unsafe Optimizations Pass
endif
Custom Loop Versioning
Pass promotes stateless accesses to bindless accesses
Binary Instruction seen with illegal int type. Legalization support missing. Inst opcode:%d
Print Function IR
srem
store
fpext
ptrtoint
ashr
extractvalue
vISA_encoderFile
true
invariant.group
error
vISA_setFFID
print-after
filter-print-funcs
IRInstrsAfter
' is not initialized.
*** IR Dump Before 
Executing Pass '
' on Module '
time-passes
ModulePass Manager
synthetic_function_entry_count
firstbitShi@
running pass 
unexpected token
Allocation failed
Struct tag metadata must have either 3 or 4 operands
Cycle detected in struct path
Functions cannot return aggregate values!
Calling convention does not support varargs or perfect forwarding!
Function declaration shouldn't have a personality routine
function must have a single !prof attachment
Global is marked as dllimport, but not external
Attributes 'byval', 'inalloca', 'nest', 'sret', 'nocapture', 'returned', 'swiftself', and 'swifterror' do not apply to return values!
inalloca isn't on the last parameter!
Attribute 'optnone' requires 'noinline'!
Attributes 'zeroext and signext' are incompatible!
Attribute 'swifterror' only applies to parameters with pointer type!
expected string with name of the !prof annotation
location requires a valid scope
invalid subrange count
invalid composite elements
invalid checksum
invalid global variable list
invalid subprogram declaration
subprogram definitions must have a compile unit
invalid static data member declaration
Expected valid value
PHI node entries do not match predecessors!
Instruction not embedded in basic block!
Cannot invoke an intrinsic other than donothing, patchpoint, statepoint, coro_resume or coro_destroy
fpmath takes one operand!
align takes one operand!
Instruction does not dominate all uses!
Intervals are not in order
Switch constants must all be same type as switch value!
Incorrect number of arguments passed to called function!
swifterror argument for call has mismatched parameter
Funclet bundle operands should correspond to a FuncletPadInst
Intrinsic name not mangled correctly for type arguments! Should be: 
element size of the element-wise unordered atomic memory intrinsic must be a constant int
incorrect alignment of the source argument
llvm.localescape only accepts static allocas
gc.relocate must return a pointer or a vector of pointers
gc.statepoint: insufficient arguments
gc.relocate: statepoint derived index doesn't fall within the 'gc parameters' section of the statepoint call
masked_store: mask must be vector
experimental_deoptimize return type must match caller return type
 intrinsic expression
dbg intrinsic without variable
gc.statepoint doesn't support wrapping non-void vararg functions yet
gc.statepoint number of deoptimization arguments must be constant integer
CleanupReturnInst needs to be provided a CleanupPad
CatchSwitchInst must unwind to an EH block which is not a landingpad.
A single unwind edge may only enter one EH pad
Logical operators only work with integral types!
Load cannot have Release ordering
Non-atomic load cannot have SynchronizationScope specified
Invalid indices for GEP pointer type!
cmpxchg instructions cannot be unordered.
Argument value type does not match pointer operand type!
ZExt only operates on integer
FPToUI result must be integer or integer vector
UIToFP source must be integer or integer vector
fptrunc source and destination must both be a vector or neither
DestTy too small for FPExt
AddrSpaceCast must be between different address spaces
Unwind edges out of a funclet pad must have the same unwind dest
Invalid operand types for FCmp instruction
cannot guarantee tail call due to mismatched parameter counts
Select values must have same type as select instruction!
LandingPadInst needs at least one clause or to be a cleanup.
'common' global must have a zero initializer!
wrong type for intrinsic global variable
unrecognized named metadata node in the llvm.dbg namespace
invalid behavior operand in module flag (unexpected constant)
expected a MDNode triple
expected an integer constant
USAGE: -spilloffset <offset>
0x%08x / 0x%08x = %.2f%%
' value invalid for integer argument!
= *unknown option value*
help-hidden
Display the version of this program
'.  Try: '
Must specify at least 
does not allow a value! '
 [subcommand]
LLVM (http://llvm.org/):
Optimized build
smax
ScalarEvolution-based Alias Analysis
Running 'Graphviz' program... 
.debug_abbrev
simdSetMessagePhase@
simdSetMessagePhaseV@
Seed for the random number generator
namespac_begin
armv2a
armv5t
v6t2
llvm.genx.GenISA.IEEE.Divide
__isoc99_scanf
__log2l_finite
storestructured2@
Cannot initialize MC for unknown object file format.
llvm.genx.GenISA.MediaBlockRectangleRead
typedmemoryfence@
   ---Wall Time---
misc
x86_64
ananas
linux
rtems
gnueabi
musl
ferror
decUI:"
uhex:"
out of range number
digit
punct
alert
form-feed
right-parenthesis
full-stop
seven
less-than-sign
underscore
vertical-line
LLVM IR Parsing
brackets ([ ]) not balanced
invalid character range
REG_ASSERT
*** unknown regexp error code ***
-darwin
" doesn't exist!
Cannot open file '
llvm-symbolizer
DW_TAG_pointer_type
DW_TAG_union_type
DW_TAG_set_type
DW_TAG_base_type
DW_TAG_const_type
__builtin_IB_atomic_cmpxchg_global_f32
appending
18IGIL_EnqueueKernel9ocl_queuejPvjS0_S0_jS0_j9ndrange_ti12ocl_clkevent
constant bigger than 128 bits detected!
DW_TAG_module
alignstack
Bitcode Writer
arm_aapcscc
ptx_device
x86_64_sysvcc
Can't open 
cxx_fast_tlscc
!DIExpression(
hhvmcc
28IGIL_EnqueueKernelWithEvents9ocl_queuejPvjS0_S0_jS0_jiPi9ndrange_tiiPU3AS4K12ocl_clkeventPU3AS4S3_S3_
amdgpu_ls
amdgpu_ps
Value: [null]
argmemonly
putc
sideeffect 
readlink
; uselistorder directives
rint
MetaData
PATH
llvm.genx.GenISA.add.rtz
stat
strcasecmp
!DISubroutineType(
!DILexicalBlockFile(
llvm.genx.GenISA.broadcastMessagePhase
strtod
!DIObjCProperty(
strtol
tmpfile
llvm.genx.GenISA.createMessagePhasesNoInit
.lshr.outer.merge.lo
pseudo_kill
vfscanf
DW_TAG_GNU_formal_parameter_pack
vsnprintf
, addrspace(
vexpf
 volatile
llvm.genx.GenISA.dp4a.uu
vtanf
arm_apcscc
vsinhf
DW_AT_use_location
__svml_sinf4
llvm.genx.GenISA.evaluateSampler
__svml_cos2
__svml_pow8
thread_local(initialexec) 
__svml_powf16
preserve_allcc
11read_imagef20ocl_image2d_depth_ro11ocl_samplerDv2_fS1_S1_
R_WEBASSEMBLY_SECTION_OFFSET_I32
llvm.genx.GenISA.f32tof16.rtz
        
!AnalysisAliasing
MT0R_OWDB
MT1R_T
MT1A_TA4x2
MT1A_A64_UI4x2
MT2R_A64_SB
MT_CC_DWS
MTRR_TS
MT1A_UF
Unaligned OWord Block Read
Untyped Surface Read
Untyped Surface Write
A64 Block Read
Unaligned Oword Block Read Constant Cache
Untyped Atomic Float Operation
constant unaligned oword block read
unsupported DCRO op
aligned_store_block
byte gathering read
off (return immediately)
global_fence
 all L3 data
 texture data
DWord
7089
a64 dword gathering read
7072
7040
MSD1W_A64_OWDB
7130
7161
, and 
typed_sgh
enabled
urb dword read
signal event
MessageTypeRC
half-precision not supported on render target read
 of high SIMD8
Subop
SlotGroupSelect
12484
SIMD[1:0]
 16b
sample override lod
sample gather4+compare
sample max
sample ld2 multi-sample wide
sample unorm+killpix
sample_8x8
Xlen
Fill 2 bytes per DW
included
DE8 (8 data elements per addr.)
DataElements:MDC_A64_DB_HW
 enabled
atomic_fcas
atomic_xor
atomic_iipdec
signed-integer max
unsigned-integer min
SG8L
PerSlotOffsetPresent
a64 dual block read/write unsupported
igc-phielimination
PredCtrl
DstDataType
Src0VertStride
ExMsgDesc
DstAddrImm
Src0RegNum
%s: %s%d number out of range
DebugCtrl
unsupported opcode
src%d: unsupported source operand kind (malformed IR)
Src1ChanSel
Src0SrcMod
Src1RepCtrl
Src2MathMacroExt
Src0TernaryImm
global memory
SrcModifier
 */ 
store as send must have a null dst
-<ERR>
ga32
abl128
DE(0x
OWs(0x
CMaskUW(0x
 targets
register regioning restriction warning: If vertical stride and horizontal stride are 0, width must be 1.
see Programmer's Reference Manual (Restriction 2.6)
ushort3
Instruction Pointer
Addition with Carry
The avg instruction performs component-wise integer average of src0 and src1 and stores the results in dst. An integer average uses integer upward rounding. It is equivalent to increment one to the addition of src0 and src1 and then apply an arithmetic right shift to this intermediate value.
Format:
The avg instruction performs component-wise integer average of src0 and src1 and stores the results in dst. An integer average uses integer upward rounding. It is equivalent to increment one to the addition of src0 and src1 and then apply an arithmetic right shift to this intermediate value.
bfi2
call
Compare
The cont instruction disables execution for the subset of channels for the remainder of the current loop iteration. Channels remain disabled until right before the while instuction or right before the condition check code block for the while instruction. If all enabled channels hit this instruction, jump to the instruction referenced by JIP where execution continues.
UIP should always reference the loop's associated while instruction. JIP should point to the last instruction of the inner most conditional block if the cont instruction is inside a conditional block. In case of the break instruction directly under the loop, the JIP and the UIP are the same.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] cont (exec_size) JIP UIP
The dp3 instruction performs a three-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every fourth element of src0 (post-source-swizzle if present) is not involved in the computation.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
The dp4 instruction includes all four elements of each vector in the dot product. The dp2 instruction includes the first two elements of each vector in the dot product.
Format:
[(pred)] dp3[.cmod] (exec_size) dst src0 src1
Dot Product Homogeneous
f32to16
Find First Bit from LSB Side
Jump Indexed
The lzd instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is zero, store 32 in dst.
Format:
[(pred)] lzd[.cmod] (exec_size) dst src0
Whether to distribute into a loop that may not be if-convertible by the loop vectorizer
__builtin_IB_simd_media_block_write_8_h
 in use 
vector
llvm.genx.GenISA.vaMinMaxFilter
expected ')' in extractvalue constantexpr
unroll-count
__builtin_IB_simd_media_block_write_8_l
' instead of '
llvm.genx.GenISA.vmeSendIME2
Unroll loops with run-time trip counts
 Use -asm-macro-max-nesting-depth to increase this limit.
Unrolled size limit for loops with an unroll(full) or unroll_count pragma.
HYBRID_RA
llvm.loop.unroll.count
DCL_DSCntrlPtInputVec@
FullUnrollAsDirectedTooLarge
__builtin_IB_get_image_bti
.  Unrolling instead 
'.fill' directive with size greater than 8 has been truncated to 8
DCL_GSsystemValue@
'.fill' directive pattern has been truncated to 32-bits
39intel_work_group_vme_mb_multi_check_8x8PU3AS3jjjjDv2_iDv4_i14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
: unsupported opcode on this platform
unsupported Align16 Dst.ChEn (only .xyzw supported)
unsupported Align16 ternary destination for SIMD{8,16} (must be .xywz)
swizzle X could not be retrieved
(line 
Region::INVALID
src%d: converting Align16 to Align1 (bits will re-assemble to Align1)
register number out of bounds
right operand to operator must be integral
non-branching operations may not reference symbols
duplicate instruction options
H1 is obsolete; use M0 in execution offset: e.g. op (16|M0) ...
N1 is obsolete; use M0 in execution offset: e.g. op (4|M0) ...
invalid default execution size; must be 1, 2, 4, 8, 16, 32
expected predication control
Unexpected flag register number
deprecated flag modifier syntax: 
immediate offset is out of range; must be in [
expected >
acc2
acc9
syntax error in source region
expected ,
NaN payload value overflows
extended message descriptor is typeless
local_size_buf
out of dynamic memory in yy_get_next_buffer()
call instructions may not have an alignment
address offset out of bounds for message type (>
missing %s argument
expected %d data registers
invalid state
WARNING: 
llvm.amdgcn.image.sample.c.cd.2darray
llvm.amdgcn.image.sample.c.cd.cl.1darray
llvm.amdgcn.image.sample.c.cd.cl.o.1d
llvm.amdgcn.image.sample.c.cd.cl.o.2d
llvm.amdgcn.image.sample.c.cd.o.1darray
llvm.amdgcn.image.sample.c.cd.o.3d
llvm.amdgcn.image.sample.c.cl.2darray
llvm.amdgcn.image.sample.c.cl.cube
llvm.amdgcn.image.sample.c.cl.o.cube
llvm.amdgcn.image.sample.c.d.1darray
llvm.amdgcn.image.sample.c.d.cl.1darray
llvm.amdgcn.image.sample.c.d.cl.2d
llvm.amdgcn.image.sample.c.d.cl.o.2darray
llvm.amdgcn.image.sample.c.d.cube
llvm.amdgcn.image.sample.c.d.o.3d
llvm.amdgcn.image.sample.c.l.1d
llvm.amdgcn.image.sample.c.l.o.1d
llvm.amdgcn.image.sample.c.l.o.2darray
llvm.amdgcn.image.sample.c.lz.2d
63intel_sub_group_avc_ime_evaluate_with_single_reference_streamin14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
llvm.amdgcn.image.sample.c.lz.o.3d
llvm.amdgcn.image.sample.c.o.1darray
llvm.amdgcn.image.sample.cd.1d
llvm.amdgcn.image.sample.cd.2d
llvm.amdgcn.image.sample.cd.cl.2darray
llvm.amdgcn.image.sample.cd.cl.o.1d
llvm.amdgcn.image.sample.cd.cl.o.cube
llvm.amdgcn.image.sample.cd.cube
llvm.amdgcn.image.sample.cl.1d
llvm.amdgcn.image.sample.cl.2darray
llvm.amdgcn.image.sample.cl.o.2d
llvm.amdgcn.image.sample.cl.o.3d
llvm.amdgcn.image.sample.d.2darray
llvm.amdgcn.image.sample.d.cl.1darray
llvm.amdgcn.image.sample.d.cl.cube
66intel_sub_group_avc_ime_evaluate_with_single_reference_streaminout14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
llvm.amdgcn.image.sample.d.o.1darray
llvm.amdgcn.image.sample.d.o.3d
llvm.amdgcn.image.sample.l.2darray
llvm.amdgcn.image.sample.l.cube
llvm.amdgcn.image.sample.l.o.cube
llvm.amdgcn.image.sample.lz.2d
llvm.amdgcn.image.sample.lz.o.1darray
llvm.amdgcn.image.sample.lz.o.2d
llvm.amdgcn.image.sample.o.2darray
llvm.amdgcn.image.store.1d
llvm.amdgcn.image.store.2dmsaa
llvm.amdgcn.image.store.cube
llvm.amdgcn.image.store.mip.cube
llvm.amdgcn.init.exec
llvm.amdgcn.kernarg.segment.ptr
52intel_sub_group_avc_ref_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ref_payload_t
llvm.amdgcn.mov.dpp
llvm.amdgcn.msad.u8
llvm.amdgcn.rcp.legacy
llvm.amdgcn.readlane
llvm.amdgcn.s.dcache.inv.vol
llvm.amdgcn.s.decperflevel
llvm.amdgcn.s.memtime
llvm.amdgcn.s.sendmsg
llvm.amdgcn.sbfe
llvm.amdgcn.sdot8
llvm.amdgcn.tbuffer.store
llvm.amdgcn.ubfe
llvm.amdgcn.wave.barrier
llvm.amdgcn.workgroup.id.z
llvm.amdgcn.workitem.id.z
54intel_sub_group_avc_sic_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_sic_payload_t
llvm.arm.crc32ch
llvm.arm.crc32w
llvm.arm.hint
llvm.arm.ldaex
llvm.arm.ldrex
llvm.arm.mcr2
llvm.arm.mrrc
llvm.arm.mrrc2
llvm.arm.neon.sha1h
llvm.arm.neon.sha1su0
llvm.arm.neon.sha256su1
llvm.arm.neon.vabds
llvm.arm.neon.vcls
llvm.arm.neon.vcvtfp2fxs
llvm.arm.neon.vcvthf2fp
llvm.arm.neon.vhaddu
llvm.arm.neon.vld1
llvm.arm.neon.vld2dup
llvm.arm.neon.vld3
llvm.arm.neon.vmaxnm
llvm.arm.neon.vminnm
llvm.arm.neon.vmullu
llvm.arm.neon.vmulp
llvm.arm.neon.vpmaxu
llvm.arm.neon.vqabs
llvm.arm.neon.vqmovns
llvm.arm.neon.vqmovnu
llvm.arm.neon.vqrshifts
llvm.arm.neon.vqshiftnsu
llvm.arm.neon.vqshiftu
_Z12get_group_idj
llvm.arm.neon.vrintm
llvm.arm.neon.vrintx
llvm.arm.neon.vrsqrte
llvm.arm.neon.vrsubhn
llvm.arm.neon.vst1x3
llvm.arm.neon.vst2lane
llvm.arm.neon.vtbl1
llvm.arm.neon.vtbl2
llvm.arm.qadd
llvm.arm.qasx
llvm.arm.sadd16
llvm.arm.sasx
llvm.arm.shsax
llvm.arm.smlabb
llvm.arm.smlaldx
igc-builtin-import
llvm.arm.smlsldx
llvm.arm.smulbb
llvm.arm.smulwt
llvm.arm.smusdx
llvm.arm.ssub8
llvm.arm.stc2l
llvm.arm.strexd
llvm.arm.sxtab16
llvm.arm.uhasx
llvm.arm.uhsub8
llvm.arm.uqsax
llvm.arm.uqsub8
llvm.arm.usub16
llvm.arm.uxtb16
llvm.bpf.load.byte
BIImport
llvm.hexagon.A2.addh.h16.lh
llvm.hexagon.A2.addh.h16.sat.hl
llvm.hexagon.A2.addh.l16.sat.hl
llvm.hexagon.A2.addi
llvm.hexagon.A2.andir
llvm.hexagon.A2.asrh
llvm.hexagon.A2.combineii
llvm.hexagon.A2.combinew
llvm.hexagon.A2.minu
llvm.hexagon.A2.negp
llvm.hexagon.A2.orir
llvm.hexagon.A2.roundsat
llvm.hexagon.A2.sub
llvm.hexagon.A2.subh.h16.lh
llvm.hexagon.A2.subh.h16.sat.ll
_Z14enqueue_kernel
llvm.hexagon.A2.svaddh
llvm.hexagon.A2.svavgh
llvm.hexagon.A2.svsubuhs
llvm.hexagon.A2.sxtb
llvm.hexagon.A2.tfrp
llvm.hexagon.A2.vabsh
llvm.hexagon.A2.vaddh
llvm.hexagon.A2.vaddhs
llvm.hexagon.A2.vavghcr
llvm.hexagon.A2.vavgubr
llvm.hexagon.A2.vavgw
llvm.hexagon.A2.vavgwr
llvm.hexagon.A2.vcmpweq
llvm.hexagon.A2.vconj
llvm.hexagon.A2.vmaxuh
MCSOptimization
llvm.hexagon.A2.vnavgh
llvm.hexagon.A2.vnavgw
llvm.hexagon.A2.vrsadub
llvm.hexagon.A2.vsubb.map
llvm.hexagon.A2.vsubw
llvm.hexagon.A2.xorp
llvm.hexagon.A4.bitsplit
llvm.hexagon.A4.bitspliti
llvm.hexagon.A4.cmpbgtui
llvm.hexagon.A4.cmphgt
llvm.hexagon.A4.combineri
llvm.hexagon.A4.cround.rr
llvm.hexagon.A4.rcmpneq
llvm.hexagon.A4.round.ri.sat
llvm.hexagon.A4.vcmpbeqi
Convert builtin functions from OpenCL to common GenISA
llvm.hexagon.A4.vcmpwgti
llvm.hexagon.A4.vrmaxuh
llvm.hexagon.A4.vrminuw
llvm.hexagon.A5.vaddhubs
llvm.hexagon.C2.any8
llvm.hexagon.C2.bitsset
llvm.hexagon.C2.cmpgeui
llvm.hexagon.C2.cmpgt
llvm.hexagon.C2.cmpltu
llvm.hexagon.C2.muxii
llvm.hexagon.C2.orn
llvm.hexagon.C2.tfrpr
llvm.hexagon.C4.and.andn
llvm.hexagon.C4.cmplte
llvm.hexagon.C4.cmplteu
CoordX
any4h
amdgpu_cs
CoordY
.lshr.merge.inner.lo
alwaysinline
floatColor
 add
(offset: 
BadAssumption
ColorX
Invalid weak external
__ashldi3
ColorY
__lshrti3
PAL[
__ashrdi3
ColorZ
.lshr.merge.inner.hi
cvtu
__mulodi4
ColorW
__divdi3
DW_OP_lit15
__udivhi3
Inconsistent use of image!
__modqi3
nontemporal
__modti3
__builtin_IB_OCL_1d_ldui
__umodti3
loop_header_weight
__addsf3
__builtin_IB_OCL_1darr_ldui
.lshr.inner.true.branch
Invalid pointer size of 0 bytes
__subtf3
__builtin_IB_OCL_2d_ldui
__multf3
DW_OP_breg15
__divdf3
__builtin_IB_OCL_2darr_ldui
fmaf
DW_OP_breg11
__powidf2
__builtin_IB_OCL_3d_ldui
__extendxftf2
DW_OP_stack_value
__extendsfdf2
__builtin_IB_OCL_1d_ld
.lshr.inner.false.branch
DIFlagAppleBlock
__trunctfsf2
__builtin_IB_OCL_1darr_ld
DIFlagObjcClassComplete
DW_ATE_ASCII
__fixsfti
__builtin_IB_OCL_2d_ld
__fixxfsi
__fixxfti
noduplicates
__builtin_IB_OCL_2darr_ld
__fixunssfti
DIFlagPublic
__fixunsdfti
__builtin_IB_OCL_3d_ld
.ashr.outer.merge.lo
_AUTO_GENERATED_IF_LABEL_
__floatsidf
__builtin_IB_OCL_2d_ldmcs
__floatdidf
' in -pass-remarks: 
__floattisf
__builtin_IB_OCL_2darr_ldmcs
__floatunsisf
__gcc_utoq
__builtin_IB_OCL_2d_ld2dms
__floatuntisf
afterRemoveRedundantLabels
__floatuntitf
__builtin_IB_OCL_2darr_ld2dms
.ashr.outer.merge.hi
verify-dom-info
__gcc_qne
__builtin_IB_OCL_2d_ld2dmsui
__ltsf2
Line
__gcc_qlt
__builtin_IB_OCL_2darr_ld2dmsui
Column
MT_SC_OWUB
__gcc_qgt
__builtin_IB_OCL_1d_sample_l
__llvm_memcpy_element_unordered_atomic_1
stage_in_grid_size_y
__llvm_memcpy_element_unordered_atomic_8
__builtin_IB_OCL_1darr_sample_l
.ashr.outer.true.branch
enqueued_local_size_y
__llvm_memset_element_unordered_atomic_2
__builtin_IB_OCL_2d_sample_l
__sync_val_compare_and_swap_1
global_size_x
__sync_val_compare_and_swap_8
__builtin_IB_OCL_2darr_sample_l
__sync_lock_test_and_set_4
A64 Untyped Atomic Float Operation
__sync_fetch_and_add_2
__builtin_IB_OCL_3d_sample_l
__sync_fetch_and_sub_2
__sync_fetch_and_sub_16
__builtin_IB_OCL_1d_sample_d
.ashr.merge.inner.lo
__sync_fetch_and_or_4
__builtin_IB_OCL_1darr_sample_d
__sync_fetch_and_xor_2
bindless_image2d_depth_t
__sync_fetch_and_nand_1
__builtin_IB_OCL_2d_sample_d
__sync_fetch_and_nand_8
.dcti
ffsl
__builtin_IB_OCL_2darr_sample_d
__sync_fetch_and_umax_8
texture2d_ms_array
__sync_fetch_and_min_2
__builtin_IB_OCL_3d_sample_d
.ashr.merge.inner.hi
pagedir="TL";
__sync_fetch_and_umin_16
__builtin_IB_OCL_1d_sample_lui
__atomic_load_8
air.kernel
__atomic_store_1
__builtin_IB_OCL_1darr_sample_lui
__atomic_store_16
7122
__atomic_exchange_4
__builtin_IB_OCL_2d_sample_lui
__atomic_compare_exchange_2
__atomic_compare_exchange_16
__builtin_IB_OCL_2darr_sample_lui
.ashr.inner.true.branch
opencl.spir.version
__atomic_fetch_sub_4
__builtin_IB_OCL_3d_sample_lui
__atomic_fetch_and_4
Unify
__atomic_fetch_or_1
__builtin_IB_OCL_1d_sample_dui
attribute group has no attributes
DataSize
__atomic_fetch_xor_8
__builtin_IB_OCL_1darr_sample_dui
llvm.genx.GenISA.setMessagePhaseX.legacy
Invalid function argument type
__builtin_IB_OCL_2d_sample_dui
invalid hexadecimal floating-point constant: expected exponent part 'p'
expected ')' after thread local model
invalid binary number
__builtin_IB_OCL_2darr_sample_dui
Invalid constant reference
Invalid constant type
invalid character in input
__builtin_IB_OCL_3d_sample_dui
The maximum nesting depth allowed for assembly macros.
sample_resinfo
Recursive use of '
__builtin_IB_write_1d_ui
.equ
Explicit invoke type is not a function type
.asciz
__builtin_IB_write_1darr_ui
.u2f.outer.merge
EXTRACTVAL: Invalid array index
.quad
__builtin_IB_write_2d_ui
.double
7.0.0')
.balign
__builtin_IB_write_2darr_ui
.p2align
Fill all 4 bytes per DW
Unexpected end of file
__builtin_IB_write_3d_ui
.no_dead_strip
GTPIN_IGC_OCL Error: Failed to call GTPIN_IGC_OCL_UpdateKernelInfo
.reference
__builtin_IB_write_2d_f
.u2f.outer.true.branch
//.kernel_reordering_info_end
.include
__builtin_IB_write_2darr_f
.rep
Types Legalization pass
.endr
__builtin_IB_frnd_ne
logical XOR
.ifle
__builtin_IB_ftoh_rtn
.ifc
Set Functions' linkage and attributes
.ifnes
__builtin_IB_ftoh_rtp
.u2f.inner.merge.hi
localMemStatelessWindowStartAddr
.skip
__builtin_IB_ftoh_rtz
.stabs
vmeSadAdjustMode
.cv_loc
__builtin_IB_dtoh_rtn
expected end of sequential type
CondModifier
.cv_fpo_data
__builtin_IB_dtoh_rtp
.cfi_endproc
const_reg_word
.cfi_adjust_cfa_offset
__builtin_IB_dtoh_rtz
.u2f.inner.merge.lo
privateBase
.cfi_same_value
__builtin_IB_dtof_rtn
.cfi_undefined
AddImplictArgs
.macros_on
__builtin_IB_dtof_rtp
.endm
no compact form
.error
__builtin_IB_dtof_rtz
moduleHash
.dc.d
__builtin_IB_dtoi8_rtn
.u2f.inner.true.branch
CorrectlyRoundedDivSqrt
.dcb.l
__builtin_IB_dtoi8_rtp
.ds.p
__builtin_IB_dtoi8_rte
.ds.x
bti 
__builtin_IB_dtoi16_rtn
unexpected token at start of statement
unknown directive
__builtin_IB_dtoi16_rtp
.u2f.rounding.merge.hi
expected ')' in insertvalue constantexpr
expected comma after first string for '.ifnes' directive
__builtin_IB_dtoi16_rte
unexpected token in '.else' directive
packed_double3
Encountered a .endif that doesn't follow an .if or .else
__builtin_IB_dtoi32_rtn
.endmacro
sc32
cannot mix positional and keyword arguments
__builtin_IB_dtoi32_rtp
' in macro '
packed_long3
unbalanced parentheses in macro argument
__builtin_IB_dtoi32_rte
.u2f.roudning.branch
packed_uchar4
invalid floating point literal
__builtin_IB_dtoi64_rtn
alignment directive can never be satisfied in this many bytes, ignoring maximum bytes expression
packed_char3
unexpected token in '.fill' directive
__builtin_IB_dtoi64_rtp
expected '(' in logical constantexpr
invalid operand type combination for instruction
alignment not supported on this target
__builtin_IB_dtoi64_rte
unexpected token in '.abort' directive
packed_short3
' detected. Assembly stopping.
__builtin_IB_dtoui8_rtn
IGC 64-bit ops emulation
Message Control
negative count has no effect
__builtin_IB_dtoui8_rtp
.endr
packed_int3
expected End of Statement
__builtin_IB_dtoui8_rte
expected end of statement
invalid option for '.bundle_lock' directive
__builtin_IB_dtoui16_rtn
unexpected token in '.file' directive
packed_float3
source specified, but no file number
__builtin_IB_dtoui16_rtp
igc-emu64ops
__constant
column position less than zero in '.loc' directive
__builtin_IB_dtoui16_rte
isa number not a constant value
air.sample
file number less than one
__builtin_IB_dtoui32_rtn
file number already allocated
Single Precision Float to Half Precision Float
air.stage_in_grid_origin
__builtin_IB_dtoui32_rtp
file number less than one in '
air.threadgroups_per_grid
column position less than zero in '.cv_loc' directive
__builtin_IB_dtoui32_rte
EstimateFunctionSize
Atomic
Expected End of Statement
__builtin_IB_dtoui64_rtn
.eh_frame
wrapper
unsupported encoding.
__builtin_IB_dtoui64_rtp
' should be last one in the list of parameters.
Reciprocal (Multiplicative Inverse): 1/src0
 is not a valid parameter qualifier for '
__builtin_IB_dtoui64_rte
unexpected '
igc-air-conversion
unexpected token in '.purgem' directive
__builtin_IB_itof_rtn
Estimate Function Sizes
TessInputControlPointCount
expected end of statement in '.warning' directive
__builtin_IB_itof_rtp
expression must be relocatable
This is a generic pass for builtins custom-lowering.
' directive with negative repeat count has no effect
__builtin_IB_itof_rtz
constant expression type mismatch
The rndz instruction takes component-wise floating point round-to-zero operation of src0 with results in two pieces - a downward rounded integral float results stored in dst and the round-to-zero increments stored in the rounding increment bits. The round-to-zero increment must be added to the results in dst to create the final round-to-zero values to emulate the round-to-zero operation, commonly known as the truncate() function. The final results are the one of the two closest integral float values to the input values that is nearer to zero.
Format:
[(pred)] rndz[.cmod] (exec_size) dst src0
 + $$
__builtin_IB_uitof_rtn
qword ptr 
denorm_exp_loop
ymmword ptr 
__builtin_IB_uitof_rtp
unexpected backslash at end of string
Pass legalizes texture and sampler addrspaces from GLOBAL/CONSTANT to indirect
invalid variant '
__builtin_IB_uitof_rtz
LocalIdLocation@
struct._sampler_t
unexpected modifier on variable reference
__builtin_IB_itofp64_rtn
.data
AirFastFlagPropagationMark
__builtin_IB_itofp64_rtp
.endef
__flag_end_marker
.safeseh
__builtin_IB_itofp64_rtz
.fix1.bitcast
rgba16unorm
.seh_handler
__builtin_IB_uitofp64_rtn
.seh_savereg
r16unorm
.seh_endprologue
__builtin_IB_uitofp64_rtp
expected string in directive
invalid addressing mode on dst
labs
__builtin_IB_uitofp64_rtz
associative
half2x3
cannot make section associative with .linkonce
__builtin_IB_frnd_pi
case value is not a constant integer
register number is too high
__builtin_IB_frnd_ni
.desc
bool3
.subsections_via_symbols
__builtin_IB_frnd_zi
air.kernel
syntax error in constant expression
.zerofill
__builtin_IB_native_cosf
.constructor
Loop Exit Canonicalization Pass
.dyld
__builtin_IB_native_cosh
Fix invalid addrspacecast-relevant patterns
HSEntry
.mod_init_func
__builtin_IB_native_sinf
.objc_cat_inst_meth
igc-workaround-FP16Div
.objc_class_names
__builtin_IB_native_sinh
.objc_inst_meth
src0 must be a register
.objc_meth_var_names
__builtin_IB_native_exp2f
.objc_string_object
igc-translate-air-builtins
.static_const
__builtin_IB_native_exp2h
igc-addrspacecast-fix
ResolveExternalVisibleFunctionName
.tvos_version_min
__builtin_IB_native_log2f
unexpected token in '.desc' directive
air.interpolation_function
non-local symbol required in directive
__builtin_IB_native_log2h
directive '.lsym' is unsupported
LastPatternMatch Pass
ignoring directive .dump for now
__builtin_IB_native_sqrtf
__text
literal is out of bounds for type %s
__datacoal_nt
__builtin_IB_native_sqrth
Fixup extractvalue pairs
logicalAndToBranch
unexpected token in '.secure_log_unique' directive
__builtin_IB_native_sqrtd
igc-hoist-fmul-in-loop-pass
EarlyOutPatterns
__DATA
__builtin_IB_popcount_1u32
expected section name after comma in '.zerofill' directive
unsupported platform
sqrtf
__builtin_IB_popcount_1u16
__cstring
igc-scalarize
__fvmlib_init1
__builtin_IB_popcount_1u8
catchswitch
fsub
__nl_symbol_ptr
__builtin_IB_native_powrf
__category
atomicrmw
__cls_meth
__builtin_IB_fma
__message_refs
icmp
__selector_strs
__builtin_IB_fmah
-cl-kernel-arg-info
both values to select must have same type
__thread_init
__builtin_IB_bfi
invalid OS update version number, integer expected
__builtin_IB_ibfe
previous definition is here
prof
watchos
__builtin_IB_ubfe
__builtin_spirv_BuiltInGlobalInvocationID
Allocation failed
.symver
__builtin_IB_bfrev
.internal
Print IR after specified passes
.cg_profile
__builtin_IB_fmax
__builtin_spirv_BuiltInWorkgroupId
DeltaInstrCount
Group section must specify the type
__builtin_IB_fmin
nobits
*** IR Dump After 
llvm_odrtab
__builtin_IB_HMAX
DWARF2 only supports one section per compilation unit
' on Call Graph Nodes '
expected the entry size
__builtin_IB_HMIN
invalid linkage
mark-readonly-load
__unnamed_
__builtin_IB_dmin
unique id is too large
expected symbol type in directive
module (
__builtin_IB_dmax
expected a comma
safepoint-ir-verifier-print-only
-dumpRPE
__builtin_IB_mul_rtz_f64
' can not be undefined in a subtraction expression
break
llabs
__builtin_IB_mul_rtz_f32
-enableWriteFusion
FK_Data_1
Function context does not match Module context!
__builtin_IB_fma_rtz_f64
FK_PCRel_4
Function takes metadata but isn't an intrinsic
FK_GPRel_2
__builtin_IB_fma_rtz_f32
FK_TPRel_4
!dbg attachment points at wrong subprogram for function
FK_SecRel_2
__builtin_IB_add_rtz_f64
implicit_arg_desc
More than one parameter has attribute nest!
FK_Data_Sub_2
__builtin_IB_add_rtz_f32
Default for platform
Attributes 'minsize and optnone' are incompatible!
Disable
__builtin_IB_thread_group_barrier
FunctionGroup analysis
 argument is out of bounds
.asciz
__builtin_IB_thread_group_barrier_signal
.long
.note.GNU-stack
fragment covers entire variable
__builtin_IB_thread_group_barrier_wait
invalid number of bytes
invalid vector, expected one element of type subrange
__builtin_IB_memfence
cannot have fixups in virtual section!
invalid imported entity list
sleb128 and uleb128 expressions must be absolute
__builtin_IB_flush_sampler_cache
compile units must be distinct
cannot have column info without line info
__builtin_IB_typedmemfence
checksum_offset
function-local metadata used outside a function
filechecksums_begin
__builtin_IB_simd_lane_id
-noroundrobin
as-secure-log-file-name
Instruction has null operand!
__builtin_IB_vme_send_ime
llvm-mc (based on LLVM 7.0.0)
nonnull applies only to load instructions, use attributes for calls or invokes
__builtin_IB_vme_send_fbr
Reference to undefined temporary symbol 
Unfinished range!
.bundle_lock forbidden when bundling is disabled
__builtin_IB_vme_send_sic
Indirectbr operand must have pointer type!
__builtin_IB_vme_send_fbr_new
<<invalid>>
Function has metadata parameter but isn't an intrinsic
Multiple gc-transition operand bundles
__builtin_IB_vme_send_sic_new
NTPOFF
info argument of llvm.coro.begin must refer to either a struct or an array
TLSGD
__builtin_IB_vme_send_ime_new_uint4_uint8
Lowers GEP into primitive ones
llvm.init_trampoline parameter #2 must resolve to a function.
TLVPPAGE
__builtin_IB_vme_send_ime_new_uint8_uint8
GOTPAGEOFF
safepoint block should be well formed
WEAKREF
__builtin_IB_vme_send_ime_new_uint4_uint4
target2
gc.relocate: relocating a pointer shouldn't change its address space
tlsdescseq
__builtin_IB_vme_send_ime_new_uint8_uint4
diff16
calls to experimental_deoptimize must be followed by a return of the value computed by experimental_deoptimize
__builtin_IB_set_message_phase_legacy_dw
igc-gen-ir-lowering
gc.statepoint ID must be a constant integer
tocbase
__builtin_IB_set_message_phase_legacy_uw
dtpmod
gc.statepoint too few arguments according to length fields
tprel@ha
__builtin_IB_set_message_phase_legacy_ub
gc.statepoint mismatch in number of call args
EH pad cannot be in entry block.
dtprel@h
__builtin_IB_set_message_phase_legacy
dtprel@highera
Shifts only work with integral types!
got@tprel
__builtin_IB_create_message_phases
Gen Simplification
Store cannot have Acquire ordering
got@tlsgd
__builtin_IB_create_message_phases_uint2
got@tlsld@l
First cmpxchg operand must be a pointer.
tlsld
__builtin_IB_create_message_phases_uint4
HI16
Type too small for ZExt
GDPLT
__builtin_IB_create_message_phases_uint8
FPToUI source and dest vector length mismatch
gotpcrel32@lo
rel32@lo
__builtin_IB_create_message_phases_no_init
' could not be evaluated in a subtraction expression
PtrToInt Vector width mismatch
<MCFixup
__builtin_IB_create_message_phases_no_init_uint2
MCDataFragment
CatchPadInst needs to be in a function with a personality.
MCRelaxableFragment
__builtin_IB_create_message_phases_no_init_uint4
MCLEBFragment
cannot guarantee tail call due to mismatched return types
Dummy Pass for GenTTIImpl
__builtin_IB_create_message_phases_no_init_uint8
 BundlePadding:
LandingPadInst needs to be in a function with a personality.
 ValueSize:
__builtin_IB_get_message_phase_dw
GeometryShaderLowering
Alias should have private, internal, linkonce, weak, linkonce_odr, weak_odr, or external linkage!
 NumValues:
__builtin_IB_get_message_phase_dw_uint2
sampleBptr@
invalid value for 'max' module flag (expected constant integer)
 InstSize:
__builtin_IB_get_message_phase_dw_uint4
APInt(
__builtin_IB_get_message_phase_dw_uint8
Expr:(
__eh_frame
__builtin_IB_get_message_phase_uq
__DWARF
= *cannot print option value*
__apple_names
__builtin_IB_get_message_phase_uq_uint2
' registered more than once!
__swift_ast
__builtin_IB_get_message_phase_uq_uint4
16ocl_image2darray
15ocl_image2dmsaa
 -help
__debug_pubtypes
__builtin_IB_get_message_phase_uq_uint8
section_str_off
SUBCOMMAND '
__debug_ranges
__builtin_IB_set_message_phase_dw
llvm.used
copysignf
__llvm_stackmaps
__builtin_IB_set_message_phase_dw_uint2
.rodata.cst16
__builtin_IB_get_local_lock
Allocation failed
__builtin_IB_set_message_phase_dw_uint4
.debug_gnu_pubnames
.debug_str
__builtin_IB_set_message_phase_dw_uint8
__builtin_IB_atomic_add_global_i32
__builtin_IB_atomic_sub_global_i32
14ocl_image3d
Total_RA
__builtin_IB_get_message_phase_uw
GRF_Local_RA
llvm.genx.
Allocation failed
__builtin_IB_get_message_phase_uw_uint2
armv2
.llvm_faultmaps
__builtin_IB_get_message_phase_uw_uint4
.debug$S
armv5tej
__builtin_IB_get_message_phase_uw_uint8
.pdata
.sxdata
__builtin_IB_set_message_phase_uw
value evaluated as 
This file format doesn't support weak aliases.
__builtin_IB_set_message_phase_uw_uint2
__builtin_IB_atomic_min_global_i32
armv8.4-a
      
__builtin_IB_set_message_phase_uw_uint4
,#alloc
armv7k
,#exclude
__builtin_IB_set_message_phase_uw_uint8
 for section 
Collect information related to hull shader
0123456789_.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
__builtin_IB_get_message_phase_ub
mach-o section specifier requires a segment and section separated by a comma
  ---Mem---
mach-o section specifier of type 'symbol_stubs' requires a size specifier
__builtin_IB_get_message_phase_ub_uint2
S_REGULAR
nvptx64
S_CSTRING_LITERALS
__builtin_IB_get_message_phase_ub_uint4
__builtin_IB_atomic_min_local_f32
macosx
S_NON_LAZY_SYMBOL_POINTERS
__builtin_IB_get_message_phase_ub_uint8
mod_init_funcs
mesa3d
S_MOD_TERM_FUNC_POINTERS
__builtin_IB_set_message_phase_ub
25ocl_image2d_msaa_depth
iterBarriers
S_DTRACE_DOF
__builtin_IB_set_message_phase_ub_uint2
smallstring:"
thread_local_variables
thread_local_variable_pointers
__builtin_IB_set_message_phase_ub_uint4
S_ATTR_NO_TOC
__builtin_IB_set_message_phase_ub_uint8
0123456789
space
debug
__builtin_IB_get_message_phase
unsupported directive in streamer
function id not introduced by .cv_func_id or .cv_inline_site_id
__builtin_IB_get_message_phase_uint2
.seh_ directive must appear within an active frame
End of a chained region outside a chained region!
__builtin_IB_get_message_phase_uint4
offset is not a multiple of 16
quotation-mark
gen-tti-dummy-pass
__builtin_IB_get_message_phase_uint8
If present, PushMachFrame must be the first UOP
help
four
__builtin_IB_set_message_phase
 = type 
commercial-at
define 
__builtin_IB_set_message_phase_uint2
Check individual type of instructions
REG_0x%x
 personality 
__builtin_IB_set_message_phase_uint4
REG_ESUBREG
REG_EPAREN
dllexport 
__builtin_IB_set_message_phase_uint8
alignstack 
REG_INVARG
 comdat
__builtin_IB_broadcast_message_phase_ub
igc-cleartessfactors
__builtin_IB_broadcast_message_phase_ub_uint2
Program could not be executed
distinct 
__builtin_IB_broadcast_message_phase_ub_uint4
Unable to find target for this triple (no targets are registered)
!DISubrange(
DW_TAG_label
__builtin_IB_broadcast_message_phase_ub_uint8
!DIFile(
DW_TAG_variant
!DISubprogram(
__builtin_IB_broadcast_message_phase_uw
24IGIL_EnqueueKernelShared9ocl_queuejPvjS0_S0_jS0_jiPi9ndrange_tii12ocl_clkevent
DW_TAG_file_type
!DILocalVariable(
__builtin_IB_broadcast_message_phase_uw_uint2
type: 
DW_TAG_namespace
%"type 
__builtin_IB_broadcast_message_phase_uw_uint4
<badref> = 
DW_TAG_skeleton_unit
 atomic
__builtin_IB_broadcast_message_phase_uw_uint8
DW_TAG_BORLAND_Delphi_variant
          filter 
__builtin_IB_broadcast_message_phase_dw
ClearTessFactors
DW_AT_string_length
inalloca 
__builtin_IB_broadcast_message_phase_dw_uint2
__builtin_IB_atomic_xchg_global_i64
DW_AT_accessibility
 arcp
__builtin_IB_broadcast_message_phase_dw_uint4
 nuw
DW_AT_identifier_case
DW_AT_segment
__builtin_IB_broadcast_message_phase_dw_uint8
DW_AT_entry_pc
 min
__builtin_IB_broadcast_message_phase_uq
Layout blocks
DW_AT_threads_scaled
; Error: Block without parent!
__builtin_IB_broadcast_message_phase_uq_uint2
externally_initialized 
DW_AT_str_offsets_base
, section "
__builtin_IB_broadcast_message_phase_uq_uint4
thread_local(localexec) 
DW_AT_call_tail_call
__builtin_IB_broadcast_message_phase_uq_uint8
 = module: (
DW_AT_MIPS_linkage_name
__builtin_IB_simd_set_message_phase_ub
igc-layout
DW_AT_body_end
(module: ^
__builtin_IB_simd_set_message_phase_ub_uint2
, dsoLocal: 
DW_AT_BORLAND_property_implements
, insts: 
__builtin_IB_simd_set_message_phase_ub_uint4
DW_AT_GNU_dwo_id
DW_AT_LLVM_config_macros
, hotness: 
__builtin_IB_simd_set_message_phase_ub_uint8
vFuncId: (
DW_OP_deref
, summary: (
__builtin_IB_simd_set_message_phase_uw
, sizeM1BitWidth: 
DW_OP_rot
, inlineBits: 
__builtin_IB_simd_set_message_phase_uw_uint2
DW_OP_neg
DW_OP_xor
DW_OP_gt
__builtin_IB_simd_set_message_phase_uw_uint4
profile-sample-accurate
DW_OP_lit7
min-legal-vector-width
__builtin_IB_simd_set_message_phase_uw_uint8
cvtps2pd
DW_OP_lit23
abs.cond
__builtin_IB_simd_set_message_phase_dw
IGC Load Shrink
DW_OP_reg7
clang.arc.retainAutoreleasedReturnValueMarker
__builtin_IB_simd_set_message_phase_dw_uint2
.p0i8
DW_OP_reg23
vpmovm2
__builtin_IB_simd_set_message_phase_dw_uint4
full-set
use-dbg-addr
target-cpu
__builtin_IB_simd_set_message_phase_dw_uint8
Missing alignment specification for pointer in datalayout string
DW_OP_breg23
Invalid index size of 0 bytes
__builtin_IB_simd_set_message_phase_uq
igc-ldshrink
DW_OP_push_object_address
Unknown mangling in datalayout string
__builtin_IB_simd_set_message_phase_uq_uint2
DW_OP_xderef_type
Trailing separator in datalayout string
__builtin_IB_simd_set_message_phase_uq_uint4
sanitize_address
DIFlagZero
DW_ATE_unsigned_fixed
__builtin_IB_simd_set_message_phase_uq_uint8
DIFlagBlockByrefStruct
DW_LANG_Cobol74
DIFlagExplicit
__builtin_IB_simd_get_message_phase_uw
DW_LANG_OpenCL
DIFlagReserved
__builtin_IB_simd_get_message_phase_uw_uint2
DIFlagBitField
DW_LANG_BLISS
DIFlagTypePassByValue
__builtin_IB_simd_get_message_phase_uw_uint4
DIFlagTrivial
DW_CC_BORLAND_thiscall
CSK_SHA1
__builtin_IB_simd_get_message_phase_uw_uint8
DW_CC_LLVM_SpirFunction
iterY
Enable missed optimization remarks from passes whose name match the given regular expression
__builtin_IB_simd_get_message_phase_uq
ceil
ignoring debug info with an invalid version (
__builtin_IB_simd_get_message_phase_uq_uint2
Breakpoint
!Failure
__builtin_IB_simd_get_message_phase_uq_uint4
MSD0W_HWB
MT0R_DWS
^(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$
__builtin_IB_simd_get_message_phase_uq_uint8
Verify dominator info (time consuming)
MT1W_MB
PendUpdates:
__builtin_IB_extract_mv_and_sad
(badref), 
MT2W_US
(no_name)(
__builtin_IB_cmp_sads
switch
__builtin_IB_get_global_size
MT0A_UI
__builtin_IB_simdMediaRegionCopy
stage_in_grid_origin_x
stage_in_grid_size_x
DWord Scattered Write
__builtin_IB_ieee_sqrt
global_offset_y
enqueued_local_size_x
A64 Untyped Surface Read
__builtin_IB_ieee_divide
work_dim
local_size_z
Typed Atomic Operation
__builtin_IB_ieee_divide_f64
-fasterRA
tess_factor_scale
const_load_block
__builtin_IB_va_erode_64x4
7030
__builtin_IB_va_dilate_64x4
bindless_image_cube_array_depth_t
7067
__builtin_IB_va_minmaxfilter_16x4_SLM
bindless_image2d_array_msaa_depth_t
depth2d
__builtin_IB_va_convolve_16x4_SLM
Expected '!' here
texture3d
HWordOffset
__builtin_IB_va_convolve_16x1
texture2d_array
bindless_image2d_msaa_t
19316
__builtin_IB_va_convolve_16x4
a64 dword scattering write
accessTy
33440
__builtin_IB_va_minmax
air.fragment
7126
__builtin_IB_va_centroid
explicit pointee type should be a function type
Move static allocas to entry basic block of the function
7149
__builtin_IB_va_boolcentroid
cmc_load_and_compile
cannot load symbol cmc_free_compile_info
atomic 32-bit counter
__builtin_IB_va_boolsum
opencl.compiler.options
opencl.used.extensions
44779
__builtin_IB_WaveBallot
llvm.global.annotations
llvm.linker.options
__builtin_IB_samplepos
Expected a constant
.lo8ds
__builtin_IB_dp4a_ss
Unknown attribute kind (
Invalid type
target-features
__builtin_IB_dp4a_uu
LastRenderTargetSelect
Invalid value name
simd8 high
__builtin_IB_dp4a_su
Invalid instruction with no BB
Invalid function metadata: outgoing forward refs
sample_gather4
__builtin_IB_dp4a_us
expected '('
Insufficient operands to call
sample_min
mcsl
INSERTVAL: Invalid struct index
Invalid type for value
sample_
mcsh
Invalid cast
EXTRACTVAL: Invalid struct index
 using sampler index 
imcsl
Expect SubBlock
' Reader: 'LLVM 
MDC_IAR
imcsh
pointers to void are invalid - use i8* instead
Invalid bitcode wrapper header
_incoherent
gradXZ
vec_type_hint
 A32
gradYZ
 256b blocks
igc-legalize-function-signatures
atomic_float?
gradXY
Set builtin MetaData
none
logical AND
gradYY
invalid function return type
KMPLOCK
atomic_irsub
gradXX
stageInGridOrigin
map::at:  key not found
_sgh
gradYX
deviceEnqueueMaxWorkgroupSize
deviceEnqueueGetBlockSimdSize
oword aligned
__precompiled_udiv
smpNormalized
vmeSubpixelMode
ExecSize
__precompiled_udiv2
imageDepth
BranchCtrl
__precompiled_udiv3
bufferOffset
const_reg_dword
dst has inconvertible region for Align16 encoding
__precompiled_udiv4
payloadHeader
globalBase
__precompiled_udiv8
vector
igc-callgraphscc-analysis
Src1VertStride
__precompiled_udiv16
invalid array element type: 
Invalid user defined function being processed: 
Src1MathMacroExt
__precompiled_umod
metadata
IGCMetadata
src%d: unsupported region for Align16 encoding
__precompiled_umod2
BorderColorR
localSize
12write_imagei16ocl_image2d_array_rwDv4_iS_
__precompiled_umod3
(sat)
 msc:
__precompiled_umod4
' to '
simd
<Region::INVALID>
__precompiled_umod8
not a send
__precompiled_umod16
dst must be GRF for load
Invalid Pass 
a32c
__precompiled_sdiv
double3
packed_double2
xsc64
__precompiled_sdiv2
fcmp requires floating point operands
ulong3
__precompiled_sdiv3
long3
packed_long2
__precompiled_sdiv4
uchar3
packed_uchar3
__precompiled_sdiv8
char3
packed_char2
igc-device-enqueue-func-resolution
__precompiled_sdiv16
expected ')' in constantexpr
getelementptr vector index has a wrong number of elements
__precompiled_smod
short3
packed_short2
Fix the usage of GetBufferPtr, no combination of GetBufferPtr and GetResourcePtr
__precompiled_smod2
%s_%s
uint3
Flow Control
__precompiled_smod3
int3
packed_int2
Perform component-wise arithmetic right shift of the bits in src0 by the shift count indicated in src1, storing the results in dst. If src0 has a signed type, insert copies of src0's sign bit in the number of MSBs indicated by the shift count. Otherwise insert 0 bits.
[Pre-DevBDW]: The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
[DevBDW+]: In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
For positive values, this operation is src0 / 2shiftCount and for negative values, this operation is src0 / 2shiftCount - 1.
Format:
[(pred)] asr[.cmod] (exec_size) dst src0 src1
If src0 is -1, the result is -1 regardless of the shift count.
For unsigned src0 types, asr and shr produce the same result.
__precompiled_smod4
expected ')' after comdat var
half3
__precompiled_smod8
float3
packed_float2
Count Bits Set
__precompiled_smod16
const
__global
The dp2 instruction performs a two-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst. This instruction is similar to dp4 except that every third and fourth element of src0 (post-source-swizzle if present) are not involved in the computation.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
The dp4 instruction includes all four elements of each vector in the dot product. The dp3 instruction includes the first three elements of each vector in the dot product.
Format:
[(pred)] dp2[.cmod] (exec_size) dst src0 src1
precompiled_u32divrem
air.amplification_count
air.arg_name
f16to32
precompiled_s32divrem
missing required field 'language'
air.position_in_patch
Halt
precompiled_u32divrem_sp
air.threads_per_grid
air.threads_per_threadgroup
The lrp instruction takes component-wise multiplication of src0 and src1, and adds the result to the component-wise multiplication of src2 and (1 - src0), and then stores the final results in dst.
Format:
[(pred)] lrp[.cmod] (exec_size) dst src0 src1 src2
precompiled_s32divrem_sp
Emulate Argument Buffers
MathFC[3:0]
__igcbuiltin_dp_add
llvm.memcpy.p
.emulation.
Integer Divide with Quotient and Remainder. The quotient goes in the destination register; the remainder goes in the following register.
__igcbuiltin_dp_sub
invalid use of function-local name
thread_index_in_threadgroup_end
Natural log: ln(src0)
__igcbuiltin_dp_fma
MaxNumOfPatchConstantSignatureEntries
AIR conversion to IGC
Square Root
__igcbuiltin_dp_mul
air.visible
ConstSampler
__igcbuiltin_dp_div
air.hull
AirArgumentPropagation
Round Up
__igcbuiltin_dp_cmp
invalid linkage for function definition
AirPropagateAssumptions
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 6-bit immediate, imm6. The lower 4bits of the <ex_desc> specifies the SFID for the message. The MSb of the message descriptor, the EOT field, always comes from bit 127 of the instruction word, which is the MSb of imm6. A thread must terminate with a send instruction with EOT turned on.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
Thread managed memory coherency: A special usage of using non-null <dest> is to support write-commit signaling for memory write service by the Data Port Write unit. If <post_dest> is not null for a memory write request, the Data Port along with the Data Cache or Render Cache will wait until all the posted writes for the request have reached the coherent domain before sending back to the requesting thread an empty message to <dest> register. A memory write reaching the coherent domain, also referred to as reaching the global observable state, means that subsequent read to the same memory location, no matter which thread issues the read, must return the data of the write.
The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
__igcbuiltin_dp_to_int32
denorm_exp
while
__igcbuiltin_dp_to_uint32
__builtin_IB_get_snap_wa_reqd
__builtin_IB_get_local_id_z
The endif instruction terminates an if/else/endif block of code. It restores execution to the channels that were active prior to the if/else/endif block.
The endif instruction is also used to hop out of nested conditionals by jumping to the end of the next outer conditional block when all channels are disabled.
The following table describes the 32-bit JIP. In GEN binary, JIP is at location src1 and must be of type D (signed DWord integer). JIP must be an immediate operand, it is a signed 32-bit number. This value is added to IP pre-increment.
Format:
endif JIP
__igcbuiltin_int32_to_dp
__air_sampler_state_static
cubeMapCoordArray
Reciprocal Macro for IEEE754-compliant fdiv
__igcbuiltin_uint32_to_dp
expected '{' in function body
air-fast-flag-propagation-resolve-pass
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
The following table describes the 32-bit jump target offset JIP. JIP is a signed 32-bit number, added to IP pre-increment, and should point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing. In GEN binary, JIP is at location src1 and must be of type D (signed dword integer).
Format:
[(pred)] while (exec_size) JIP
__igcbuiltin_dp_to_sp
__flag_begin_marker
rg11b10f
The csel instruction selectively moves components in src0 or src1 to the dst based on the result of the compare of src2 with zero. If the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst. The csel instruction provides the function of a cmp followed by sel. The instruction must not be used if cmpn is required. The instruction does not update the flag register.
The comparison follows the same rule as cmp instruction for that data type.
When Access Mode is Align1, accumulator may be used as source or destination.
Format:
csel (exec_size) dst src0 src1 src2
__igcbuiltin_sp_to_dp
rg16unorm
rgba8snorm
expected ',' after branch condition
__igcbuiltin_dp_sqrt
primitive_acceleration_structure
r8snorm
: unexpected format for basic instruction
__igcbuiltin_sp_div
expected ',' after case value
half3x4
%s: 0x%02X: invalid arf register
Remainder
float4x2
half2x2
src%d.Rgn should have %s for binary normal form
igc-memopt
packed_bool3
expected a send operand type
__precompiled_convert_f64_to_f16
bool2
air.render_target
NaN payload must be nonzero for snan
DPEmuFlag
expected 'unwind' in cleanupret
voidProgram
Uncompacted
DPEmufp16tofp32
LegalizeStructLoadStores
TessellationShaderDomain
N8 is obsolete; use M28 in execution offset: e.g. op (4|M28) ...
DPEmusext
HSOutputControlPointCount
MaxNumOfPatchConstantSignatureEntries
 (defined 
DPEmuzext
Workaround for FP16div optimization causing a overflow
Pass walks through kernel and checks if there remains any unresolved air builtin function, in which case it is flagged as an error.
subfunction is out of bounds
DPEmuTrunc
expected ',' in logical operation
AirRasterOrderGroups
expected [
DPEmuCmp
Translate AIR Builtins
Translate AI
igc-fix-resource-ptr
DPEmuFabs
air.visible_function_references
Air Metadata Schema Wrapper
expected source operand
PreCompiledFuncImport
air.flat
air.centroid
literal must be integral for type 
igc-precompiled-import
reducedIndex
TrivialLocalMemoryOpsElimination
clause argument must be a constant
ptrVec2ptrScl
expected 'tail call', 'musttail call', or 'notail call'
NanHandling
ld/st operation name
GEP_lane
if.then
GenSpecificPattern
scratch index is out of bounds
scalar
.seg1
igc-loop-canonicalization
parse error
assembled.vect
stored value and pointer type do not match
FixResourcePtrPass
igc-extractvalue-pair-fixup
__destructor
vISA_IsaAssembly
resume
catchpad
fadd
udiv
urem
load
trunc
fptrunc
sitofp
inttoptr
select
lshr
shufflevector
fix-fast-math-flags
cycleCounter@
unknown
_Z13get_global_idj
tbaa.struct
unpredictable
irr_loop
singlethread
dwordatomicstructured@
Structure
Details
Print IR before specified passes
print-after-all
When printing IR for print-[before|after]{-all} always print a module IR
IRSizeChange
IRInstrsBefore
 on module '
Pass '
- Corruption of the global PassRegistry
' is not preserving '
 Free these instances
'...
' on Function '
Used
FunctionPass Manager
Module Pass Manager
Mark readonly load
branch_weights
,data
unique id must be positive
Allocation failed
MarkReadOnlyLoadPass
) in function (
BISECT: 
Two passes with the same argument (-
-emitLocation
Allocation failed
symbol '
Offset entries must be constants!
Could not find TBAA parent in struct type node
Access tag metadata must have either 4 or 5 operands
Malformed struct tag metadata: base and access-type should be non-null and point to Metadata nodes
Offset must be constant integer
' does not have terminator!
# formal arguments must match # of arguments for function type!
Calling convention requires void return type
Calling convention does not allow sret
Referencing personality function in another module!
function declaration may not have a !prof attachment
function must have a single !dbg attachment
DISubprogram attached to more than one function
Only global variables can have appending linkage!
GlobalValue with DLLImport Storage is dso_local!
Global is referenced in a different module!
Global is used by function in a different module
Cannot have multiple 'sret' parameters!
Cannot have multiple 'swifterror' parameters!
Attributes 'readnone and inaccessiblemem_or_argmemonly' are incompatible!
Attributes 'noinline and alwaysinline' are incompatible!
number of elements
Attributes 'sret and returned' are incompatible!
Attribute 'byval' only applies to parameters with pointer type!
indirect-call-optimization
swifterror value should be the second operand when used by stores
first operand should not be null
Invalid operand for global metadata!
All nodes should be resolved!
fragment is larger than or outside of variable
Count must either be a signed constant or a DIVariable
DWARF address space only applies to pointer or reference types
invalid file
invalid template params
invalid checksum length
invalid enum type
invalid retained type
invalid macro ref
invalid containing type
subprogram definitions must be distinct
FixDeadVisibleFunctions
anonymous module
missing global variable type
invalid imported entity
anonymous macro
Basic Block does not have terminator!
PHI node has multiple entries for the same basic block with different incoming values!
Function return type does not match operand type of return inst!
Terminator found in the middle of a basic block!
Use of instruction is not an instruction!
Cannot take the address of an intrinsic!
Referencing global in another module!
fpmath requires a floating point result!
nonnull applies only to pointer types
align applies only to load instructions, use attributes for calls or invokes
invalid !dbg metadata attachment
image2d
The upper limit must be an integer!
Intervals are overlapping
dereferenceable, dereferenceable_or_null take one operand!
Branch condition is not 'i1' type!
Called function must be a pointer!
Called function requires more parameters than were provided!
swifterror argument for call has mismatched alloca
swifterror argument should come from an alloca or parameter
Multiple deopt operand bundles
Expected exactly one funclet bundle operand
Intrinsic has incorrect argument type!
Callsite was not defined with variable arguments!
addr
isvolatile argument of memory intrinsics must be a constant int
incorrect alignment of the destination argument
image3d
size argument of memory use markers must be a constant integer
multiple calls to llvm.localescape in one function
gc.result operand #1 must be from a statepoint
wrong number of arguments
gc.relocate operand #2 must be integer offset
gc.relocate: statepoint derived index out of bounds
gc.statepoint: number of deoptimization arguments must be a constant integer
gc.relocate: statepoint base index doesn't fall within the 'gc parameters' section of the statepoint call
masked_load: mask must be vector
masked_load: vector mask must be same length as data
experimental_guard must have exactly one "deopt" operand bundle
experimental_deoptimize must have exactly one "deopt" operand bundle
invalid rounding mode argument
 intrinsic variable
 variable and !dbg attachment
image2d_array_msaa
gc.statepoint callee must be of function pointer type
gc.statepoint mismatch in number of vararg call args
gc.statepoint call argument does not match wrapped function type
gc.statepoint number of transition arguments must be positive
gc.result connected to wrong gc.statepoint
The resume instruction should have a consistent result type inside a function.
CatchSwitchInst not the first non-PHI instruction in the block.
CatchSwitchInst has an invalid parent.
Catchswitch cannot unwind to one of its catchpads
EH pad cannot handle exceptions raised within it
Integer arithmetic operators must have same type for operands and result!
Floating-point arithmetic operators must have same type for operands and result!
Cannot allocate unsized type
loading unsized types is not allowed
atomic load operand must have integer, pointer, or floating point type!
breakdown-intrinsics
Non-atomic store cannot have SynchronizationScope specified
GEP indexes must be integers
All GEP indices should be of integer type
cmpxchg instructions must be atomic.
atomicrmw instructions must be atomic.
atomicrmw operand must have integer type!
trunc source and destination must both be a vector or neither
DestTy too big for Trunc
sext source and destination must both be a vector or neither
FPToUI source must be FP or FP vector
FPToSI result must be integer or integer vector
UIToFP source and dest must both be vector or scalar
SIToFP result must be FP or FP vector
FPTrunc only produces an FP
fpext source and destination must both be a vector or neither
igc-error-check
IntToPtr type mismatch
AddrSpaceCast result must be a pointer
CleanupPadInst has an invalid parent.
Bogus funclet pad use
Both operands to ICmp instruction are not of the same type!
Both operands to FCmp instruction are not of the same type!
PHI node operands are not the same type as the result!
cannot use musttail call with inline asm
bitcast following musttail call must use the call
Invalid operands for select instruction!
Invalid shufflevector operands!
Invalid InsertValueInst operands!
Filter operand is not an array of constants!
Global variable initializer type does not match global variable type!
invalid linkage for intrinsic global variable
_alloca
Aliasee should be either GlobalValue or ConstantExpr
Alias cannot point to an interposable alias
invalid requirement on flag, flag does not have the required value
invalid behavior operand in module flag (expected constant integer)
invalid value for 'append'-type module flag (expected a metadata node)
'Linker Options' named metadata no longer supported
Advanced Memory Optimization
sampleinfoptr@
sampleptr@
may only occur zero or one times!
>...
' is invalid value for boolean argument! Try 0 or 1
    -
 (default: 
Display list of available options (-help-list-hidden for more)
Display available options (-help-hidden for more)
print-all-options
version
error - this positional option will never be matched, because it does not Require a value, and a cl::ConsumeAfter option is active!
: Unknown command line argument '
This argument does not take a value.
Instead, it consumes any positional arguments until the next recognized option.
: Not enough positional command line arguments specified!
 positional arguments: See: 
multi-valued option specified with ValueDisallowed modifier!
  This option category has no options.
USAGE: 
SUBCOMMANDS:
OPTIONS:
igc-fix-alignment
Inconvertible error value. An error has occurred that could not be converted to a known std::error_code. Please file a bug.
LLVM ERROR: 
LLVM ERROR: out of memory
Error: 
Trying 'open' program... 
Graphviz
.rodata.cst32
_ZnamSt11align_val_t
_Znwj
_ZnwjRKSt9nothrow_t
_ZnwjSt11align_val_t
LLT_invalid
seed
Allocation failed
.debug_str.dwo
aarch64
armv4t
armv6
armv7-r
.debug_tu_index
image2d_array_t
.shl.outer.merge.lo
storerawvector_indexed@
__log2f_finite
llvm.genx.GenISA.LocalSizeLocation
__memmove_chk
__builtin_IB_atomic_min_global_u32
__nvvm_reflect
Reg Pressure Estimate
__sinpi
__builtin_IB_atomic_min_global_f32
__builtin_IB_atomic_min_local_i32
 for appending!
  Total Execution Time: %5.4f seconds (%5.4f wall clock)
   --User+System--
Total
typedwrite@
mips64el
sparcv9
hsail64
renderscript64
freebsd
kfreebsd
solaris
minix
cuda
amdhsa
gnueabihf
eabihf
android
feof
__builtin_IB_atomic_max_global_f32
stringref:"
char:"
decULL:"
decLL:"
invalid number
IO failure on output stream: 
blank
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ 
ABCDEFGHIJKLMNOPQRSTUVWXYZ
newline
percent-sign
left-parenthesis
hyphen
period
three
semicolon
__builtin_IB_atomic_or_local_i32
reverse-solidus
circumflex-accent
left-curly-bracket
__builtin_IB_atomic_xor_global_i32
wavebarrier@
invalid collating element
trailing backslash (\)
REG_EBRACK
braces not balanced
REG_ERANGE
repetition-operator operand invalid
empty (sub)expression
Write Bitcode
_bb 
TMPDIR
__builtin_IB_atomic_dec_global_i32
TERM
Error waiting for child process
Executable "
/dev/null
Cannot dup2
Disable symbolizing crash backtraces.
DW_TAG_imported_declaration
DW_TAG_member
DW_TAG_structure_type
DW_TAG_typedef
DW_TAG_inheritance
DW_TAG_ptr_to_member_type
DW_TAG_catch_block
DW_TAG_with_stmt
Null bytes are not allowed in names
bitwidth for integer type out of range!
available_externally
module asm "
local_unnamed_addr
extern_weak
__builtin_IB_atomic_cmpxchg_local_f32
 xchg
.shl.inner.false.branch
DW_TAG_common_block
acq_rel
seq_cst
asm 
LLVM7.0.0
__builtin_IB_atomic_sub_global_i64
x86_vectorcallcc
spir_func
Metadata: slot = 
llvm.genx.GenISA.WaveInverseBallot
ptx_kernel
target triple = "
amdgpu_es
__builtin_IB_atomic_min_global_i64
x86_regcallcc
strcat
byval
putchar_unlocked
ghccc
realloc
llvm.genx.GenISA.WaveShuffleIndex
__builtin_IB_atomic_min_global_f64
remove
rename
setitimer
snprintf
REG_ESPACE
DW_TAG_array_type
llvm.genx.GenISA.atomiccounterpredec
__builtin_IB_atomic_max_global_u64
pread
.shl.inner.true.branch
puts
pwrite
llvm.genx.GenISA.WavePrefix
x86_64-apple-darwin22.1.0
reallocf
__builtin_IB_atomic_and_global_i64
rewind
llvm.genx.GenISA.WorkGroupAny
rmdir
roundl
scanf
avr_signalcc 
setvbuf
__builtin_IB_atomic_xor_global_i64
sscanf
!GenericDINode(
statvfs64
stpcpy
image2d_msaa_t
llvm.genx.GenISA.bfi
strcmp
__builtin_IB_atomic_dec_global_i64
!DICompositeType(
strncasecmp
strncat
 instructions of 3 src (mad/pln) are compacted.
strspn
!DINamespace(
strtok
__builtin_IB_atomic_cmpxchg_global_f64
strtok_r
llvm.genx.GenISA.cmpxchgatomicstructured
!DIImportedEntity(
strxfrm
times
toascii
__builtin_IB_atomic_add_local_i16
truncl
unlink
llvm.genx.GenISA.createMessagePhasesV
vfprintf
] unwind 
vscanf
__builtin_IB_atomic_sub_local_i16
to caller
INVALID opcode 
vceilf
llvm.sqrt.f32
llvm.genx.GenISA.dp4a.su
llvm.exp.f32
__builtin_IB_atomic_xchg_local_i16
llvm.log.f32
sspreq
llvm.log10.f32
image2d_array_msaa_t
llvm.cos.f32
 nand
vacosf
__builtin_IB_atomic_min_global_u16
vatanf
llvm.genx.GenISA.eu.thread.id
vasinhf
CheckInstrTypes
__svml_sin8
__svml_sinf16
__builtin_IB_atomic_min_local_i16
llvm.sin.f64
external 
__svml_cosf4
__svml_pow4
umax
__svml_powf8
__builtin_IB_atomic_min_local_f16
__svml_exp4
__builtin_IB_atomic_max_global_i16
R_WEBASSEMBLY_MEMORY_ADDR_LEB
R_WEBASSEMBLY_GLOBAL_INDEX_LEB
R_WEBASSEMBLY_FUNCTION_OFFSET_I32
Number of source1 GRFs must be between 1 and 32
GED VERSION: 
!Passed
single
mme5
MSD0R_HWB
MT0R_OWUB
MT0W_OWB
MT0W_BS
MT1R_MB
MT1A_TA
MT1W_TS
MT1A_A64_UI
MT1W_A64_SB
MT2R_US
MT2W_BS
MT_CC_OWDB
MT_RTW
MTR_MB
MT0R_US
MT1A_UF4x2
Scratch Block Write
OWord Block Read
OWord Dual Block Write
Transpose Read
Typed Surface Read
Typed Atomic Integer Operation SIMD4x2
A64 Scattered Read
A64 Untyped Atomic Integer Operation SIMD4x2
Oword Block Read Constant Cache
__builtin_IB_atomic_or_local_i16
Render Target Read
A64 Untyped Atomic Float Add
__builtin_IB_atomic_xor_global_i16
MType
constant oword block read
constant dword gathering read
7084
aligned_load_block
7032
oword dual block read decode not supported
oword dual block write decode not supported
dword scattering write
Commit
slm_fence
SLM fence
FLush L1
L3 Flush Targets
hword scratch block write
OWord
7091
7086
Byte with Status Return
a64 scattering write
QWord
7074
7037
7036
MSD1R_A64_OWDB
__builtin_IB_atomic_cmpxchg_global_f16
a64 float atomic
float atomic
untyped
7167
media block 
override
skip
typed
7099
7103
ChannelMaskEnable
 with per-slot offset enabled
MSDUR_DWS
signal
spinlock
GatewayOpcode
unsupported RC op
full-precision
half-precision
 replicated SIMD16
.hi8ds
unknown write subop
unknown read subop
.psp
.lrts
.sgh
SIMD[2]
simd8h
simd16 high
igc-resolve-atomics
sample load
sample_lod
sample info
sample_gather4_c
sample derivatives+compare
sample_max
sample load with lod forced to 0
sample_ld2dms_w
sample multi-sample without mcs
sample_unorm_killpix
sample unorm for media
sample unorm+killpix for media
SamplerIndex
Rlen
unsupported sfid
BreakConstantExprPass
DataElements:MDC_DB_OW
Fill 1 byte per DW
field should be 
absent
stateless
must have 0xFF or 0xFD BTI
DE2 (2 data elements per addr.)
DE4 (4 data elements per addr.)
 A64
 (SSO)
untyped_store
no channels enabled
DataElements:MDC_A64_DS
atomic_fmin
 (unknown float op)
igc-correctly-rounded-div-sqrt
atomic_and
logical OR
integer increment
integer decrement
integer subtract
atomic_smax
unsigned-integer max
atomic_umin
 (high slot group)
SG4x2
SlotGroup:MDC_SG2
 (in owords)
oword unaligned
dual block
kernel
invalid vector element type
AccessMode
MaskCtrl
FlagSubRegNum
Saturate
ExecutionDataType
Src1RegFile
Src0DataType
ExDescRegFile
DstAddrMode
Align1 dst math macro unsupported on this platform.
dst: unsupported destination operand kind/addrMode (malformed IR)
src%d: unsupported source operand kind/addrMode (malformed IR)
align16 ternary dst must be to GRF
%s: invalid register name for this platform
DstSubRegNum
Implicit Global Id Pass - Add parameters for debugging
GED_EncodeIns failed: %s
null pointer
invalid interpreter
src%d source modifier not supported (invalid IR)
Src1SubRegNum
Src1AddrSubRegNum
Src1Width
Src1HorzStride
SrcDataType
src%d: mixed types require :f and :hf (or vice versa)
Src2ChanSel
Src2SubRegNum
src%d: invalid operand kind
 wr:
 from scratch offset 0x
INVALID BTI
MathMacroExt
dst region is not binary normal
on <h> region w must be Region::WI_INVALID
/* [
 // 
 from #
__builtin_IB_get_prefered_workgroup_multiple
no mapping for descriptors
unsupported format kind (for now)
an operand is indirect
store needs binary send with non-null src1
a64c
surf
xga64
xbl128
bl128
PackedData
HW64(0x
rgba
CMaskUW
Resolve device enqueue functions
: numeric label targets the middle of an instruction
expected comma after getelementptr's type
register regioning restriction warning: ExecSize <= Src.W (partial row)
see Programmer's Reference Manual (Restriction 2.1)
register regioning restriction warning: SIMD1 requires vertical and horiztonal to be 0 (scalar region access)
see Programmer's Reference Manual (Restriction 2.5)
getelementptr index must be an integer
Math Macro
Stack Pointer
Debug
The add instruction performs component-wise addition of src0 and src1 and stores the results in dst.
Addition of two floating-point numbers follows rules in add (IEEE mode) or add (ALT mode).
Format:
[(pred)] add[.cmod] (exec_size) dst src0 src1
Use a source modifier with add to implement subtraction.
addc
Arithmetic Shift Right
Average
bfi1
The bfi1 instruction is the first instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi1 instruction component-wise generates mask with control from src0 and src1 and stores the results in dst. The mask is used in the bfi2 instruction to generate the final result of bfi.
Create a bit mask corresponding to the bit field width and offset in src0 and src1. Store the bit mask in dst. The mask has all bits in the bit field set to 1 and all other bits as 0.
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi1 (exec_size) dst src0 src1
No accumulator access, implicit or explicit.
A SIMD16 instruction is not allowed.
The bfrev instruction component-wise reverses all the bits in src0 and stores the results in dst.
Format:
[(pred)] bfrev (exec_size) dst src0
The brc instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if all channels are branched away.
UIP should reference the instruction where all channels are expected to come together. JIP should reference the end of the innermost conditional block.
In GEN binary, JIP and UIP are at location src1 when immediates and at location src0 when reg64, where reg64 is accessed as paired DWord (regioning being <2;2,1>). The ip register must be used (for example, by the assembler) as dst. When offsets are immediate, src0 must be null.
Format:
[(pred)] brc (exec_size) JIP UIP
Break
The break instruction is used to early-out from the inner most loop, or early out from the inner most switch block.
When used in a loop, upon execution, the break instruction terminates the loop for all execution channels enabled. If all the enabled channels hit the break instruction, jump to the instruction referenced by JIP. JIP should be the offset to the end of the inner most conditional or loop block, UIP should be the offset to the while instruction of the loop block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] break (exec_size) JIP UIP
cbit
The cmpn instruction performs component-wise special-NaN comparison of src0 and src1 and stores the results in the selected flag register and in dst. It takes component-wise subtraction of src0 and src1, evaluating the conditional signals including NS based on the conditional modifier, and storing the conditional flag bits in bit-packed form in the destination flag register and all bits of dst channels. If the dst is not null, for the enabled channels, then all bits of the destination channel will contain the flag value for the channel. When the instruction operates on packed word format, one general register may store up to 16 such comparison results. In DWord format, one general register may store up to 8 results.
A conditional modifier must be specified; the conditional modifier field cannot be 0000b. More information about the conditional signals used is in the Creating Conditional Flags section.
For each enabled channel 0b or 1b is assigned to the appropriate flag bit and 0/all zeros or all ones (e.g, byte 0xFF, word 0xFFFF, DWord 0xFFFFFFFF) is assigned to dst.
Min/Max instructions use cmpn to select the destination from the input sources (see the Min Max of Floating Point Numbers section for details).
Format:
[(pred)] cmpn[.cmod] (exec_size) dst src0 src1
Continue
Dot Product 2
Dot Product 3
__get_kernel_preferred_work_group_multiple_impl
The endif instruction terminates an if/else/endif block of code. It restores execution to the channels that were active prior to the if/else/endif block.
The endif instruction is also used to hop out of nested conditionals by jumping to the end of the next outer conditional block when all channels are disabled.
The following table describes the 16-bit JIP. In GEN binary, JIP is at location src1 and must be of type W (signed word integer). JIP must be an immediate operand, it is a signed 16-bit number. This value is added to IP pre-increment.
Format:
endif JIP
The f16to32 instruction converts the half precision float in src0 to single precision float and storing in dst.
Because this instruction does not have a 16-bit floating-point type, the source data type must be Word (W). The destination type must be F (Float).
Format:
[(pred)] f16to32[.cmod] (exec_size) dst src0
Find First Bit from MSB Side
halt
The Illegal Opcode Exception Enable flag in cr0.1 is normally set so the normal processing of an illegal opcode is to transfer control to the System Routine.
Instruction dispatch treats any unused 8-bit opcode (including bit 7 of the instruction, reserved for future opcode expansion) as if it is the illegal opcode.
The illegal opcode is zero because that byte value is more likely than most to be read via a wayward instruction pointer.
The illegal instruction is an instruction only in the same way that a NULL pointer in software is a pointer. Both are special values indicating invalid instances.
Format:
illegal
jmpi
Linear Interpolation
Leading Zero Detection
mach
The mach instruction performs DWord integer multiply-accumulate operation and outputs the high DWord (bits 63:32). For each enabled channel, this instruction multiplies the DWord in src1 with the high word of the DWord in src0, left shifts the result by 16 bits, adds it with the corresponding accumulator values, and keeps the whole 64-bit result in the accumulator. It then stores the high DWord (bits 63:32) of the results in dst.
This instruction is intended to be used to emulate 32-bit DWord integer multiplication by using the large number of bits available in the accumulator. For example, the following four instructions perform vector multiplication of two 32-bit signed integer sources from r2 and r3 and store the resulting vectors with the high 32 bits in r5 and the low 32 bits in r6.
mul (8) acc0:d r2.0<8;8,1>:d r3.0<8;8,1>:d //All channels must be enabled
mach (8) rTemp<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d //All channels must be enabled
mov (8) r5.0<1>:d rTemp<8;8,1>:d // High 32 bits
mov (8) r6.0<1>:d acc0:d // Low 32 bits
The mul and mach instructions must have all channels enabled. The first mov should have channel enable from the destHI of IMUL, the second mov should have the channel enable from the destLO of IMUL. As mach is used to generate part of the 64-bit DWord integer results, saturation modifier should not be used. In fact, saturation modifier should not be used for any of these four instructions. Source and destination operands must be DWord integers. Source and destination must be of the same type, signed integer or unsigned integer. If dst is UD, src0 and src1 may be UD and/or D. However, if any of src0 and src1 is D, source modifier (abs) must be present to convert it to match with dst. If dst is D, src0 and src1 must also be D. They cannot be UD as it may cause unexpected overflow because the computed results are limited to 64 bits.
Format:
[(pred)] mach[.cmod] (exec_size) dst src0 src1
The math instruction performs extended math function on the components in src0, or src0 and src1, and write the output to the channels of dst. The type of extended math function are based on the FC[3:0] encoding in the table below.
Format:
[(pred)] math (exec_size) dst src0 src1 <FC>
math.cos
math.exp
__builtin_spirv_OpGetKernelNDrangeSubGroupCount
Output
pointer
symbol-relocation-cleanup
in formulae referencing 
directional label undefined
LSR has identified the following interesting factors and types: 
__builtin_spirv_OpGetKernelPreferredWorkGroupSizeMultiple
LSR is examining the following uses:
__builtin_IB_simd_media_block_write_2_l
unroll-partial-threshold
write_only
Don't allow loop unrolling to simulate more than this number ofiterations when checking full unroll profitability
llvm.genx.GenISA.vmeSendFBR2
unroll-max-count
__builtin_spirv_OpGetKernelMaxNumSubgroups
unroll-full-max-count
Encountered a .elseif that doesn't follow an .if or  an .elseif
Set the unroll peeling count, for testing purposes
__builtin_IB_simd_media_block_write_2_b
unroll-runtime
LOCAL_FIRST_FIT_RA
The max of trip count upper bound that is considered in unrolling
TransformBlocks Pass
pragma-unroll-threshold
llvm.genx.GenISA.wavebarrier
unroll-allow-peeling
' does not exist for macro '
Enqueue and re-visit child loops in the loop PM after unrolling. This shouldn't typically be needed as child loops (or their clones) were already visited.
__builtin_IB_media_block_read
llvm.loop.unroll.runtime.disable
Enqueue param is not set
loop-unroll
UnrollAsDirectedTooLarge
Unable to fully unroll loop as directed by unroll pragma because unrolled size is too large.
DCL_DSPatchConstInputVec@
TripMultiple
invalid alignment value
 time(s).
Device enqueue invoke param is not a function
Allows loops to be unroll-and-jammed.
__builtin_IB_sub_group_reduce_OpGroupUMax
unroll-and-jam-threshold
block_simd_size
IGC Memory Optimization
unable to decompact
unsupported pseudo op (sub function of 
IGA INTERNAL ERROR: 
converting unary/binary Align16 dst to equivalent Align1
unexpected Align1Ternary in current platform
unsupported Align16 ternary destination for SIMD4 (must be .xywz or .{x,y,z,w})
invalid dst implicit accumulator reference (in ChEn)
%s: invalid register file
GED reports invalid value for 
GED reports invalid field for 
invalid register file in src%d
invalid addressing mode in src%d
Invalid result type for LLVM function
invalid SIMD width
old-style access to mme via acc (use mme%d for acc%d)
right operand to operator must be floating point (append a .0 to force floating point)
left operand to operator must be integral
NaN payload overflows
branching operands may not perform arithmetic on labels
NoPreempt not supported on given platform
ignoring unsupported instruction option {Switch}
EOT is only allowed on send instructions
NoMask goes precedes predication as (W) for WrEn: e.g. (W) op (..) ...   or    (W&f0.0) op (..) ..
Q3 is obsolete; use M16 in execution offset: e.g. op (8|M16) ...
Q4 is obsolete; use M24 in execution offset: e.g. op (8|M24) ...
N7 is obsolete; use M24 in execution offset: e.g. op (4|M24) ...
expected instruction, block, or EOF
expected SIMD width (integral value)
label redefinition 
invalid mnemonic
scalar_buf
expected operation subfunction
unexpected subfunction for op
expected flag modifier function
deprecated flag modifier syntax (omit the brackets)
invalid destination register number (%s only has %d registers on this platform)
expected indirect address offset
destination region argument
invalid destination region
subregister out of bounds for data type
old-style math macro register (use mme)
acc6
acc8
unbound identifier
%s.Src%d region should be implicit
invalid region vertical stride
unknown argument number for an object
syntax error in region (vertical stride)
hex literal too big for type
expected extended send descriptor
immediate descriptor expression must be integral
52intel_sub_group_avc_ime_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t
INTERNAL ERROR: parsing float literal
yyset_column called with no buffer
input in flex scanner failed
invalid message
malformed register range (high register must be >= low)
expected offset
surface index is out of bounds
unary store (stp) not supported yet
expected %d address registers
.seg3
encode error
invalid object
expected ',' after cmpxchg address
llvm.amdgcn.image.sample.c.b.o.cube
llvm.amdgcn.image.sample.c.cd.1darray
llvm.amdgcn.image.sample.c.cd.2d
llvm.amdgcn.image.sample.c.cd.cl.1d
return
llvm.amdgcn.image.sample.c.cd.cl.3d
llvm.amdgcn.image.sample.c.cd.cl.cube
llvm.amdgcn.image.sample.c.cd.cl.o.1darray
join
llvm.amdgcn.image.sample.c.cd.cube
llvm.amdgcn.image.sample.c.cd.o.1d
llvm.amdgcn.image.sample.c.cd.o.2darray
pseudo_fcall
llvm.amdgcn.image.sample.c.cl.1darray
llvm.amdgcn.image.sample.c.cl.2d
llvm.amdgcn.image.sample.c.cl.3d
pseudo_exit
llvm.amdgcn.image.sample.c.cl.o.2darray
llvm.amdgcn.image.sample.c.cl.o.3d
llvm.amdgcn.image.sample.c.d.1d
pseudo_fc_ret
llvm.amdgcn.image.sample.c.d.3d
llvm.amdgcn.image.sample.c.d.cl.1d
62intel_sub_group_avc_ime_evaluate_with_dual_reference_streamout14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
sada2
llvm.amdgcn.image.sample.c.d.cl.o.1darray
llvm.amdgcn.image.sample.c.d.cl.o.2d
llvm.amdgcn.image.sample.c.d.cl.o.cube
llvm.amdgcn.image.sample.c.d.o.2d
llvm.amdgcn.image.sample.c.d.o.2darray
llvm.amdgcn.image.sample.c.d.o.cube
llvm.amdgcn.image.sample.c.l.3d
llvm.amdgcn.image.sample.c.l.cube
llvm.amdgcn.image.sample.c.l.o.2d
llvm.amdgcn.image.sample.c.lz.1d
llvm.amdgcn.image.sample.c.lz.1darray
__local
llvm.amdgcn.image.sample.c.lz.o.2d
llvm.amdgcn.image.sample.c.lz.o.2darray
llvm.amdgcn.image.sample.c.o.1d
pseudo_sada2
llvm.amdgcn.image.sample.c.o.3d
llvm.amdgcn.image.sample.c.o.cube
llvm.amdgcn.image.sample.cd.1darray
send
llvm.amdgcn.image.sample.cd.cl.1darray
llvm.amdgcn.image.sample.cd.cl.2d
llvm.amdgcn.image.sample.cd.cl.cube
sends
llvm.amdgcn.image.sample.cd.cl.o.2darray
llvm.amdgcn.image.sample.cd.cl.o.3d
61intel_sub_group_avc_ime_evaluate_with_dual_reference_streamin14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
llvm.amdgcn.image.sample.cd.o.3d
llvm.amdgcn.image.sample.cd.o.cube
llvm.amdgcn.image.sample.cl.2d
pseudo_store_be_fp
llvm.amdgcn.image.sample.cl.o.1d
llvm.amdgcn.image.sample.cl.o.1darray
llvm.amdgcn.image.sample.cl.o.2darray
pseudo_caller_save
llvm.amdgcn.image.sample.d.1darray
llvm.amdgcn.image.sample.d.2d
llvm.amdgcn.image.sample.d.cl.1d
pseudo_callee_save
llvm.amdgcn.image.sample.d.cl.3d
pseudo_callee_restore
lifetime
llvm.amdgcn.image.sample.d.cube
llvm.amdgcn.image.sample.d.o.1d
llvm.amdgcn.image.sample.d.o.2darray
DebugInfoPlaceholder
llvm.amdgcn.image.sample.l.1darray
llvm.amdgcn.image.sample.l.2d
llvm.amdgcn.image.sample.l.3d
pseudo_or
llvm.amdgcn.image.sample.l.o.2darray
llvm.amdgcn.image.sample.l.o.3d
llvm.amdgcn.image.sample.lz.1darray
pseudo_not
llvm.amdgcn.image.sample.lz.cube
llvm.amdgcn.image.sample.lz.o.1d
64intel_sub_group_avc_ime_evaluate_with_dual_reference_streaminout14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
scaled untyped surface read
llvm.amdgcn.image.sample.o.1darray
llvm.amdgcn.image.sample.o.2d
llvm.amdgcn.image.sample.o.cube
scaled A64 untyped surface read
llvm.amdgcn.image.store.2darray
llvm.amdgcn.image.store.2darraymsaa
llvm.amdgcn.image.store.3d
scaled untyped surface write
llvm.amdgcn.image.store.mip.2darray
llvm.amdgcn.image.store.mip.3d
llvm.amdgcn.implicitarg.ptr
scaled A64 scattered write
llvm.amdgcn.interp.p1
llvm.amdgcn.interp.p2
work_group_size_hint(
unrecognized DC2 message
llvm.amdgcn.mbcnt.hi
llvm.amdgcn.mbcnt.lo
llvm.amdgcn.mqsad.u32.u8
render target read
llvm.amdgcn.queue.ptr
llvm.amdgcn.rcp
llvm.amdgcn.readfirstlane
llvm.amdgcn.s.barrier
llvm.amdgcn.s.dcache.inv
llvm.amdgcn.s.dcache.wb.vol
llvm.amdgcn.s.incperflevel
llvm.amdgcn.s.memrealtime
54intel_sub_group_avc_ref_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ref_payload_t
unaligned oword block read
llvm.amdgcn.sad.u16
llvm.amdgcn.sad.u8
llvm.amdgcn.sdot4
dword scattered read
llvm.amdgcn.sin
llvm.amdgcn.tbuffer.load
llvm.amdgcn.trig.preop
hword block read
llvm.amdgcn.unreachable
llvm.amdgcn.update.dpp
llvm.amdgcn.workgroup.id.y
byte scattered read
llvm.amdgcn.workitem.id.y
memory fence
hword block write
llvm.arm.crc32b
llvm.arm.crc32cb
llvm.arm.crc32h
hword aligned block write
llvm.arm.dsb
llvm.arm.get.fpscr
llvm.arm.isb
dword scattered write
llvm.arm.ldc2l
llvm.arm.ldcl
llvm.arm.mcr
unrecognized DC0 message
llvm.arm.mrc
llvm.arm.mrc2
52intel_sub_group_avc_sic_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_sic_payload_t
scratch write
llvm.arm.neon.sdot
llvm.arm.neon.sha1c
llvm.arm.neon.sha1p
transpose read
llvm.arm.neon.sha256h2
llvm.arm.neon.sha256su0
llvm.arm.neon.udot
untyped atomic operation
llvm.arm.neon.vacgt
llvm.arm.neon.vbsl
llvm.arm.neon.vcvtau
media block read
llvm.arm.neon.vcvtfxs2fp
llvm.arm.neon.vcvtfxu2fp
intel_reqd_workgroup_walk_order(
typed atomic operation
llvm.arm.neon.vcvtpu
llvm.arm.neon.vhadds
llvm.arm.neon.vhsubu
untyped atomic float add
llvm.arm.neon.vld1x4
llvm.arm.neon.vld2
llvm.arm.neon.vld2lane
media block write (non-iecp)
llvm.arm.neon.vld4dup
llvm.arm.neon.vld4lane
llvm.arm.neon.vmaxu
atomic counter operation simd4x2
llvm.arm.neon.vmullp
llvm.arm.neon.vmulls
_Z17get_global_offsetj
a64 gathering read
llvm.arm.neon.vpaddlu
llvm.arm.neon.vpmaxs
llvm.arm.neon.vpminu
a64 untyped atomic operation
llvm.arm.neon.vqdmulh
llvm.arm.neon.vqdmull
llvm.arm.neon.vqmovnsu
a64 block read
llvm.arm.neon.vqrshiftnsu
llvm.arm.neon.vqrshiftnu
llvm.arm.neon.vqshiftns
a64 untyped atomic float add
llvm.arm.neon.vqshiftsu
a64 untyped surface write
a64 scattered write
llvm.arm.neon.vrhaddu
llvm.arm.neon.vrinta
llvm.arm.neon.vrintp
llvm.arm.neon.vrshifts
llvm.arm.neon.vrshiftu
llvm.arm.neon.vrsqrts
.sat
llvm.arm.neon.vst1
llvm.arm.neon.vst1x2
llvm.arm.neon.vst2
llvm.arm.neon.vst4
llvm.arm.neon.vst4lane
get_sub_group_id
, resLen=
llvm.arm.neon.vtbx3
llvm.arm.neon.vtbx4
llvm.arm.qadd8
, extMsgLen=
llvm.arm.qsub16
llvm.arm.qsub8
llvm.arm.sadd8
llvm.arm.shadd8
llvm.arm.shasx
llvm.arm.shsub8
llvm.arm.smladx
llvm.arm.smlald
Does pattern matching
llvm.arm.smlsdx
llvm.arm.smlsld
llvm.arm.smuadx
llvm.arm.smultt
llvm.arm.smulwb
llvm.arm.smusd
llvm.arm.ssax
llvm.arm.ssub16
llvm.arm.stc2
llvm.arm.stlexd
llvm.arm.strex
llvm.arm.uhadd16
llvm.arm.uhadd8
llvm.arm.uhsub16
llvm.arm.uqadd8
llvm.arm.uqasx
llvm.arm.uqsub16
llvm.arm.usat16
llvm.arm.usax
llvm.arm.uxtab16
Align1}
llvm.arm.vcvtru
CodeGenPatternMatchPass
llvm.hexagon.A2.addh.h16.hh
llvm.hexagon.A2.addh.h16.hl
llvm.hexagon.A2.addh.h16.sat.hh
llvm.hexagon.A2.addh.l16.hl
llvm.hexagon.A2.addh.l16.ll
llvm.hexagon.A2.addh.l16.sat.ll
acc1
llvm.hexagon.A2.addsp
llvm.hexagon.A2.and
llvm.hexagon.A2.aslh
llvm.hexagon.A2.combine.lh
llvm.hexagon.A2.combine.ll
__enqueue_kernel_vaargs
llvm.hexagon.A2.min
llvm.hexagon.A2.minp
llvm.hexagon.A2.neg
llvm.hexagon.A2.notp
llvm.hexagon.A2.or
llvm.hexagon.A2.orp
llvm.hexagon.A2.satub
llvm.hexagon.A2.satuh
llvm.hexagon.A2.subh.h16.hl
llvm.hexagon.A2.subh.h16.sat.hl
llvm.hexagon.A2.subh.h16.sat.lh
KillPixel
tdr0
llvm.hexagon.A2.subri
llvm.hexagon.A2.subsat
llvm.hexagon.A2.svadduhs
unknown architecture reg
llvm.hexagon.A2.svsubh
llvm.hexagon.A2.svsubhs
llvm.hexagon.A2.swiz
llvm.hexagon.A2.tfrih
llvm.hexagon.A2.tfril
llvm.hexagon.A2.tfrsi
llvm.hexagon.A2.vabswsat
llvm.hexagon.A2.vaddb.map
===> Materialize Failure: 
llvm.hexagon.A2.vaddws
llvm.hexagon.A2.vavgh
llvm.hexagon.A2.vavgub
.acc
llvm.hexagon.A2.vavguw
llvm.hexagon.A2.vavguwr
llvm.hexagon.A2.vavgwcr
//.declare 
llvm.hexagon.A2.vcmphgt
llvm.hexagon.A2.vcmphgtu
llvm.hexagon.A2.vcmpwgtu
r (spilled)
llvm.hexagon.A2.vmaxub
a (spilled)
postDiscard
f (spilled)
llvm.hexagon.A2.vminuw
llvm.hexagon.A2.vminw
llvm.hexagon.A2.vnavghr
Base=r
llvm.hexagon.A2.vraddub
llvm.hexagon.A2.vraddub.acc
llvm.hexagon.A2.vrsadub.acc
llvm.hexagon.A2.vsububs
llvm.hexagon.A2.vsubuhs
llvm.hexagon.A2.xor
 rf=
llvm.hexagon.A4.andn
llvm.hexagon.A4.andnp
loop-gating
 type=
llvm.hexagon.A4.cmpbgti
llvm.hexagon.A4.cmpbgtu
llvm.hexagon.A4.cmpheqi
llvm.hexagon.A4.cmphgtui
llvm.hexagon.A4.combineir
llvm.hexagon.A4.cround.ri
 words
llvm.hexagon.A4.rcmpeq
llvm.hexagon.A4.rcmpeqi
llvm.hexagon.A4.round.ri
 (a0.
llvm.hexagon.A4.tlbmatch
llvm.hexagon.A4.vcmpbeq.any
igc-pixel-shader-addmask
 (spilled -> 
llvm.hexagon.A4.vcmphgtui
llvm.hexagon.A4.vcmpweqi
llvm.hexagon.A4.vrmaxh
 Type=
llvm.hexagon.A4.vrminh
llvm.hexagon.A4.vrminuh
llvm.hexagon.A4.vrminw
 Input
llvm.hexagon.C2.and
llvm.hexagon.C2.andn
llvm.hexagon.C2.bitsclri
llvm.hexagon.C2.cmpeqp
llvm.hexagon.C2.cmpgei
BuiltinsConverterFunction
llvm.hexagon.C2.cmpgtup
llvm.hexagon.C2.cmplt
llvm.hexagon.C2.mux
all4h
llvm.hexagon.C2.not
llvm.hexagon.C2.or
llvm.hexagon.C2.pxfer.map
llvm.hexagon.C2.xor
llvm.hexagon.C4.and.and
llvm.hexagon.C4.and.orn
any16h
VISA Legalizer
any32h
igc-pixel-shader-lowering
all2h
_copysign
all8h
Recognize reduction patterns.
Target Transform Information
all16h
all32h
, readOnly: 
anyv
tbaa
allv
Scoped NoAlias Alias Analysis
f0.0
undefined
Lower discard intrinsics
constant<
typeTestRes: (kind: 
, singleImplName: "
__ashlhi3
igc-lower-discard
AS =
bool
__ashrhi3
  { 
__mulsi3
__multi3
none
PixelShaderLowering
min.cond
mem_fence
__divti3
pseudo_kill
spill
ctlz.trunc
fill
__modsi3
(abs)
-(abs)
Lower Discard
llvm.loop.vectorize.
__negsi2
Illegal or unimplemented ISA opcode 
optsize
__gcc_qadd
__subdf3
 at byte position 
bitset set argument out of range
Missing alignment specification in datalayout string
__gcc_qmul
be_fp
be_sp
ABI alignment specification must be >0 for non-aggregate types
StackCall
Missing size specification for pointer in datalayout string
Spill candidate 
fmal
 intf:
Target
not a number, or does not fit in an unsigned int
(Liverange is local starting at line #
__extenddftf2
 and ending at line #
Scope
 --- spilled
sanitize_thread
--max RP: 
__truncxfhf2
--avg # neighbors: 
__truncdfsf2
--max # neighbors: 
PositionDepAnalysis
__gcc_qtod
round-robin
__fixsfsi
first-fit
 BCR
DIFlagObjectPointer
 graph coloring
__fixdfti
--# variables: 
Caller save size: 
__fixtfdi
 bytes for fcall at cisa id 
SetMathPrecisionForPositionOutput
Callee save size: 
DIFlagFixedEnum
 bytes
__fixunsdfsi
Total frame size: 
predicate
DIFlagThunk
src0
__fixunstfsi
src1
__fixunstfti
src2
__AUTO_GENERATED_ELSE_LABEL__
Def not found for use 
PreRA rematerialize flag
) at CISA offset 
Enable optimization analysis remarks from passes whose name match the given regular expression
, src line 
__floatdixf
=== Uses with reaching def - Flags ===
static-func-full-module-prefix
=== Uses with reaching def - Address ===
Invalid regular expression '
=== Uses with reaching def - GRF ===
LineTablesOnly
(Use -nolocalra switch for accurate results of uses without reaching defs)
__floatunsixf
=== Variables used but never defined ===
byteArray
 (General)
igc-pre-ra-remat-flag
 (Address)
Name
 (Flag)
__floatuntidf
--address RA iteration 
afterRemoveUnreachableBlocks
Address_RA
DebugLoc
--flag RA iteration 
__gcc_qeq
Flag_RA
__nedf2
--hybrid RA--
after_doCFGStructurizer
--skip hybrid RA due to high pressure: 
Use LivenessAnalysis to calculate register pressure
=== Register Allocation ===
Delete, 
Function: 
__ltdf2
Kernel: 
afterProcessGoto
--GRF RA iteration 
(no name)
__floatundidf
--split local send--
__gtdf2
--enable failSafe RA
LABEL__
--rematerialize
igc-registerestimator
--global send split
stage_in_grid_size_z
--# variables spilled: 
__llvm_memcpy_element_unordered_atomic_2
--current spill size: 
LABEL__EMPTYBB
Spill_GRF
use of undefined type named '
Local RA used 
__llvm_memmove_element_unordered_atomic_4
 GRFs
__llvm_memmove_element_unordered_atomic_16
__MERGED_FRET_EXIT_BLOCK_f
: (Pred: 
RegisterEstimator
 Succ: 
global_size_y
__sync_val_compare_and_swap_2
max pressure: 
VCE_SAVE
 inst(s)
unknown target property
Dcl %s is Default32Bit but assignment is not Even aligned
use of undefined summary '^
's LRA assignment 
__sync_lock_test_and_set_16
 doesnt interfere with 
UnknownKernel
Start verification for kernel: 
SimplifyConstant
) is split
base_vertex
__sync_fetch_and_sub_4
) and 
Succs: 
) are overlapping with incompatible emask but not masked as interfering
non-struct types may not be recursive
) use overlapping physical assignments but not marked as interfering
__sync_fetch_and_and_8
End verification for kenel: 
__sync_fetch_and_or_1
Default16Bit
digraph UnknownKernel
Default32Bit
PromoteConstant
Default64Bit
llvm.genx.GenISA.ldmsptr16bit
NonDefault
__sync_fetch_and_xor_8
Undetermined
digraph 
-----
unknown selection kind
DefaultPredicateMask
expected '=' in global variable
(size = 
__sync_fetch_and_max_2
, spill cost = 
__sync_fetch_and_max_8
, degree = 
PruneUnusedArguments
bindless_image2d_array_msaa_t
wait
__sync_fetch_and_umax_16
page= "80.5, 110";
mem_fence
expected ':' at start of summary entry
pseudo_kill
__sync_fetch_and_umin_1
spill
__sync_fetch_and_umin_4
fill
--trivial RA
This is an analysis pass for pulling constants for short shaders 
Allocated 100% GRF ranges without graph coloring.
resID
--local RA--
__atomic_load_16
--round-robin 
    <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
BCR 
An alias or ifunc must have pointer type
invalid linkage type for alias
--first-fit 
__atomic_exchange_1
Total GRF ranges: 
</TD></TR>
GRF ranges allocated by local RA: 
Analyse shader to determine push const threshold
% allocated by local RA
Undoing local RA assignments
__atomic_compare_exchange_4
    <TABLE BORDER="0" CELLBORDER="0" CELLSPACING="0">
unknown global variable property!
__atomic_fetch_add_8
__atomic_fetch_sub_1
<TR><TD ALIGN="LEFT"><FONT color="
dynamicBufferOffset.bufferId
e-p:32:32:32
__atomic_fetch_and_8
</FONT></TD></TR>
invalid use of parameter-only attribute on a function
bool
__atomic_exchange_16
__atomic_fetch_xor_2
</TD></TR>
ConstantBufferIndexedWithInstanceId
__sync_fetch_and_max_16
__atomic_fetch_nand_16
none
Could not find leader
sqrt
.ashr.inner.false.branch
invalid hexadecimal floating-point constant: expected at least one exponent digit
//.kernel 
promotes the values to be arguments
invalid octal number
single quote way too long
//.stepping 
alignment is not a power of two
Callee is not a pointer type
bool
missing expression
//.options 
igc-push-analysis
Callee is not a pointer
.equiv
//.RA type
none
Expected '(' in syncscope
===== LVN =====
.value
Number of instructions removed: 
.long
insertCallReturnVar
//.spill size 
callReturn
PushAnalysis
===== Bank conflicts =====
Insufficient function protos
Found 
.align
 conflicts (
//.spill flag store 
 locals, 
void type only allowed for function results
 globals) in kernel: 
stack alignment is not a power of two
 // $
.org
.zero
before.
Scalarizer in codegen
after.
Malformed block
cleanMessageHeader
.symbol_resolver
renameRegister
//.arg_
newLocalDefHoisting
unexpected ellipsis in argument list for 
newLocalCopyPropagation
.comm
sendFusion
.lcomm
cselPeepHoleOpt
.code
optimizeLogicOperation
igc-scalarizer-in-codegen
HWConformityChk
types-legalization-pass
preRA_Schedule
.irp
regAlloc
removeLifetimeOps
argument can not have void type
countBankConflicts
expected '...' at end of argument list for musttail call in varargs function
removeRedundMov
.ifge
removeEmptyBlocks
.end_code
insertFallThroughJump
Scalarizer in Codegen
reassignBlockIDs
igc-process-func-attributes
evalAddrExp
.ifeqs
FoldAddrImmediate
// Bank Conflict Statistics: 
chkRegBoundary
invalid element type for struct
localSchedule
.elseif
NoDD
.end
HWWorkaround
// --  BAD: 
insertInstLabels
GenX Register Pressure Analysis
insertHashMovs
vmeSearchPathType
insertDummyCompactInst
.cv_file
mergeScalarInst
encoder line %d: unsupported GED setter %s (%s)
lowerMadSequence
invalid array element type
.ifne
ifCvt
.cv_filechecksums
dumpPayload
normalizeRegion
igc-RegisterPressureEstimate
checkBarrierUsage
const_reg_byte
createR0Copy
.cfi_def_cfa
initializePayload
EL, 
cleanupBindless
multiple definition of local value named '
countGRFUsage
.cfi_personality
splitVariables
.cfi_remember_state
changeMoveType
EH, 
reRAPostSchedule
RegisterPressureEstimate
accSubPostSchedule
BuiltinCallGraphAnalysis
.cfi_register
reassociateConst
split4GRFVars
 is not of type '
addFFIDProlog
expected end of constant
loadThreadPayload
.purgem
insertFenceBeforeEOT
insertScratchReadBeforeEOT
IGC PreRA Scheduler
mapOrphans
air.vertex
_UIP
.dc.a
             === Local Definition Hoisting Optimization ===
GOOD
Number of defs hoisted: 
expected comma in block address expression
             === Message Header Optimization ===
.dc.x
 is reduced from 
.dcb.b
 to 
 instructions. 
igc-PreRAScheduler
% instructions of this kernel are removed.
llvm.genx.GenISA.uaddc
%s_optreport.txt
.ds.d
ffid_prolog_end
expected 'to' in constantexpr cast
             === Merge Scalar Optimization ===
expected ')' at end of constantexpr cast
Number of optimized bundles:
Lower GEP of Private Memory to Register Pass
Number of instructions saved:
.addrsig_sym
powf
__builtin_IB_memcpy_generic_to_private
wait
invalid use of pseudo-symbol '.' as a label
mem_fence
TRIVIAL_BC_RA
pseudo_kill
TRIVIAL_RA
spill
unexpected token in '.ifc' directive
fill
expected string parameter for '.ifnes' directive
C:\Intel\nodd.txt
LOCAL_ROUND_ROBIN_BC_RA
__builtin_IB_memcpy_private_to_generic
Total
Encountered a .else that doesn't follow  an .if or an .elseif
expected comma in compare constantexpr
expected ')' in compare constantexpr
LOCAL_ROUND_ROBIN_RA
invalid argument identifier for formal argument
HYBRID_BC_RA
__builtin_IB_memcpy_private_to_private
packed_long4
bool
too many positional arguments
GRAPH_COLORING_RR_BC_RA
nuw only applies to integer operations
' directive
unknown token in expression
GRAPH_COLORING_RR_RA
none
__builtin_IB_memcpy_global_to_private
packed_char4
maximum bytes expression exceeds alignment and has no effect
GRAPH_COLORING_SPILL_RR_BC_RA
12write_imagei14ocl_image3d_woDv4_iiS0_
parameter named '
unable to emit symbol attribute
GRAPH_COLORING_SPILL_RR_RA
__builtin_IB_memcpy_private_to_global
packed_short4
.abort detected. Assembly stopping.
bool
UNKNOWN_RA
inrange keyword may not appear on pointer operand
expected string in '.incbin' directive
skip is negative
Can't find src file
__builtin_IB_memcpy_constant_to_private
none
packed_int4
Fix Inst Size for:
expected identifier in '.irp' directive
split into: 
's live in: 
global values must be constants
expected two operands to extractelement
's live in size: 
unexpected token after expression in '.bundle_align_mode' directive
's live out: 
label_cf_
's live out size: 
__builtin_IB_memcpy_private_to_constant
PreRegAlloc
packed_float4
explicit path specified, but no file number
SP_GRF
TM_GRF
missing required field 'count'
SP_MSG
unexpected token in '.loc' directive
FL_MSG
unassigned file number in '.loc' directive
FL_GRF
FL_Send
__builtin_IB_memcpy_local_to_private
DCL_HSControlPointID@
tmp_shl_dst_bti
unsupported directive '.stabs'
tmp_shl_y_offset
tmp_shl
'checksumkind' and 'checksum' must be provided together
missing required field 'baseType'
expected function id in '
expected 'within' identifier in '.cv_inline_site_id' directive
__builtin_IB_memcpy_private_to_local
air.threadgroup_position_in_grid
unassigned file number in '
Switch
expected '(' here
expected SourceField in '.cv_inline_linetable' directive
expected SourceLineNum in '.cv_inline_linetable' directive
bool
NoDDChk
__builtin_IB_to_local
air.indirect_buffer
.debug_frame
NoMask
expected metadata operand
none
expected ')' here
%s.asm
' has multiple parameters named '
Fail to open 
SpillMemOffset
__builtin_IB_to_private
isGlobalSizeGT0
' in file, no current macro definition
Compacted
invalid type for undef constant
.error directive invoked in source file
.warning directive invoked in source file
NoSrcDepSet
AsmName
Resolve generic address space
ArgSize
air-builtin-handler
RetValSize
unexpected token in .reloc directive
perThreadInputSize
Serialize
Extern
 of struct initializer doesn't match struct element type
Callable
no matching '.endmacro' in definition
Caller
literal value not a power of two greater then zero
Composable
illegal
Entry
igc-gas-resolve
Input
denorm_exp_loop_end
Input_Output
xword ptr 
NoWidening
Wrong input variable is used
'builtin' attribute not valid on function
ONLY ADDC AND SUBB are supported by this API
invalid function linkage type
Destination for Arithmetic Instruction is NULL
invalid escape sequence (unrecognized character)
BuiltinR0
smov
BuiltinA0
Resolve compiler predefeind constants
BuiltinA0Dot2
expected 'inlined_at' identifier in '.cv_inline_site_id' directive
hw_tid
expected symbol variant after '@'
samplerHeader
' disagree
Number of parameters does not match
expected ')' in parentheses expression
LINE: 
Reciprocal Square Root Macro for IEEE754-compliant rsqt
FUNCTION: 
.bss
CHECK_NUM_OPNDS
igc-predefined-constant-resolve
Insert markers around builtin calls marked with fast flag
.secrel32
NEGABS
bfrev
expected instruction opcode
thread_x
.seh_proc
thread_y
.seh_startchained
local_id_x
bfi1
local_id_y
group_id_x
r16snorm
group_id_y
.seh_savexmm
group_id_z
group_count_x
expected '[' with switch table
group_count_y
bfi2
conflicting section flags 'b' and 'd'.
retval
one_only
hw_id
discard
color
unrecognized COMDAT type '
global_data_base
bitset test argument out of range
expected ']' at end of block list
before.remat
same_size
after.remat
expected @unwind or @except
Skip block with instructions 
expected SIMD width
Skip block with rp 
OPTPre
Before scheduling, 
bool4
After scheduling for presssure, 
.indirect_symbol
After scheduling for latency, 
math
[---] 
expected '[' in catchpad/cleanuppad
the max pressure is 
.previous
Max pressure instructions are: 
.secure_log_reset
schedule reverted due to mischeduling.
schedule not committed due to no change.
schedule committed for latency.
loop-exit-canonicalization
the pressure is increased to 
.cstring
schedule committed with reduced pressure.
the reduced pressure is 
expected '[' with catchswitch labels
schedule reverted, 
.linker_option
%s.bb%d.schedule
.literal4
rndd
UpdateOptPre
 ... 
FP16DivWorkaround
+++++++++++ 
.objc_category
 empty cycles 
rndz
 +++++++++++
expected ',' in arithmetic operation
nodes
expected 'within' after catchpad
 Prio:
.objc_message_refs
 Earl:
mach
 Occu:
OPTPost
%s.bb%d.dag.dot
error: 
digraph DAG {
.objc_symbols
#CCCCCC
addc
#FFEE99
expected ',' after select value
#FFFFFF
.thread_init_func
[label="
.ident
dp4a
, style="filled", fillcolor="
AIR to IGC metadata parser
%d->%d
indirect symbol not in a symbol pointer or stub section
mulh
orange
expected '[' in phi value list
grey
expected ',' after insertelement value
expected string in '.dump' or '.load' directive
,color="
cmpn
Check SIMD32 Profitability for OpenCL
%s.bb%d.nodes
CodeGenContext Wrapper
__const_coal
malformed load/store mnemonic suffix
,type="
change section name to "
%s.%s.dot
.popsection without corresponding .pushsection
size = "80, 100";
// Nodes
simd32-profit
unexpected token in '.secure_log_reset' directive
[shape=record, label="{ID : 
invalid '.tbss' directive size, can't be less thanzero
 PRIORITY : 
succeeded
store operand must be a pointer
 ETIME : 
load operand must be a pointer to a first class type
Label: 
invalid '.zerofill' directive alignment, can't be less than zero
unknown region type in '.data_region' directive
} "];
Simd32Profitability
// Edges
Scalarize functions
__dyld
Number of operands mismatch between CISA instruction description and value passed in.
ONE OF THE OPERANDS IS NULL!
unreachable
temp.isa
__literal4
Could not open %s
__mod_init_func
Cannot open file %s
vISA_UniqueLabels
isaasmListFile.txt
TimeStatsCounter Start/Stop
ScalarizeFunction
.visaasm
__class
.errors.txt
vISA_dumpNewSyntax
 errors in vISA files.
fptoui
Please see error report written to the file 
frem
Found a total of 
__module_info
vISA_OutputvISABinaryName
time-stats-counter
__static_const
igc-int-type-legalizer
T252
select values cannot have token type
T255
false
OS minor version number required, comma expected
word
invalid OS minor version number
dword
vISA_InitPayload
qword
.demoted.zext
oword
2GRF
vISA_clearScratchWritesBeforeEOT
byte
section_prefix
.rodata
(abs)
struct_arg_offset
debug-pass
(-abs)
Demote type safely
print pass details when it is executed
.hidden
reserved0
vISA_setStartBreakPoint
function names
.tdata.
Section cannot specifiy a group name while also acting as a member of the last group
vISA_HashVal
igc-type-demote
sgid
progbits
vISA_dumpPayload
Made Modification '
line
Verify if there is a pass dependency cycle.
expected '@<type>', '%<type>' or "<type>"
vISA_3DOption
mulh
Detect non-uniform usage of textures and samplers and check if they may be assumed uniform.
Workaround fmax/fmin
expected metadata symbol
-dumpPassesLocation
rndd
firstbitLo@
rndu
ProfileSummary
rnde
SubroutineInliner
rndz
unsupported attribute in '.type' directive
sad2
UniformAssumptions
rsqrt
<<null function>>
RectListOptimization
reserved1C
A @@ version cannot be undefined
reserved1D
floatatomicstructured@
reserved1E
Access tag nodes must have the number of operands that is a multiple of 3!
Bitwidth between the offsets and struct type entries must match
powl
VariableReuseAnalysis
cfl-steens-aa
Access bit-width not the same as description bit-width
cbit
FK_Data_2
addr_add
Invalid struct return type!
arg_desc
FK_PCRel_8
setp
-nofoldaddrimmed
Compute-once pass that provides a translation table for mapping attributes for LLVM values
movs
funcThen
FK_TPRel_8
-nomac
func
GlobalValue with private or internal linkage must be dso_local!
label
FK_Data_Add_2
FK_Data_Add_8
call
-disableStructurizer
oword_ld
TranslationTable
oword_st
Changes indirect calls to direct calls if possible
media_ld
Enable
media_st
-ALTMode
gather
Wrong types for attribute: 
scatter
.code32
reserved3b
.zero
oword_ld_unaligned
-nolvn
reserved3d
Split loads/stores of big (or 3-element) vectors into smaller ones.
reserved3e
first operand should be 'function_entry_count' or 'synthetic_function_entry_count'
reserved3f
scope points into the type hierarchy
sample
.weak
sample_unorm
invalid pointer to member type
load
thread_group_size_hint
invalid .org offset '
-forceSamplerHeader
fminmax
igc-vectorpreprocess
igc-fix-dead-visible-functions
non-zero initializer found in section '
bfrev
-disableMixMode
addc
invalid retained nodes list
subb
Padding cannot exceed 255 bytes
gather4_typed
           
scatter4_typed
-noalign1ternary
va_skl_plus
VectorPreProcess
read_write
ifcall
strtab_begin
faddr
-noFP64bRegion
file
Instruction has bogus parent pointer!
linetable_end
reserved53
Instruction returns a non-scalar type!
vme_ime
As secure log file name (initialized from AS_SECURE_LOG_FILE env variable)
vme_sic
split
vme_fbr
Referencing function in another module!
vme_idm
fpmath accuracy not a positive number!
reserved58
Unterminated .bundle_lock when changing a section
barrier
align metadata value must be an i64!
sampler_cache_flush
GenIR Lowering
fence
raw_send
-nofailsafera
reserved5E
scalarize
yield
image2d_depth
reserved60
reserved61
-nosplitllr
reserved62
Call parameter type does not match function signature!
reserved63
reserved64
DTPOFF
reserved65
GOTOFF
reserved66
elt0
fcall
image2d_msaa_depth
fret
GOTNTPOFF
switchjmp
-TotalGRFNum
sad2add
element size of the element-wise atomic memory intrinsic must be a power of 2
plane
TPREL
goto
tlsdesc
sample_3d
-enableBCR
load_3d
elt1
gather4_3d
image1d_array
info_3d
SECREL32
rt_write_3d
-nopresched
urb_write_3d
gc.statement: number of call arguments must be constant integer
typed_atomic
llvm.localrecover first argument must be function defined in this module
gather4_scaled
sbrel
scatter4_scaled
-dumpSchedule
reserved76
elt2
reserved77
image2d_array_depth
gather_scaled
diff32
scatter_scaled
-noDD-lookback
raw_sends
llvm.dbg.
lifetime
highesta
sbarrier
got@h
dword_atomic
-dump-noSrcDep
sqrtm
Elt0
divm
image2d_array_msaa_depth
tprel@l
-noWAWSubregHazardAvoidance
dp4a
CleanupReturnInst must unwind to an EH block which is not a landingpad.
RESERVED_0
reserved_1c
tprel@highesta
reserved_1d
-HWThreadNumberPerEU
reserved_1e
Elt1
reserved_3B
Breakdown intrinsics into simpler operations to enable better optimization
reserved_3D
dtprel@highest
reserved_3E
-nobxmlencoder
reserved_3F
igc-wa-fminmax
reserved_53
got@dtprel
reserved_58
got@dtprel@h
samplr_cache_flush
-printasmcount
reserved_5e
Elt2
reserved_60
BreakdownIntrinsicPass
reserved_61
got@tlsld@h
reserved_62
-genIsaasmList
reserved_63
Invalid binary operation!
reserved_64
GEP is not of right type for indices!
reserved_65
GDGOT
reserved_66
-isaasmNamesOutputFile
3d_sample
Process vector loads/stores for explicit vISA variable layout
3d_load
3d_gather4
-uniqueLabels
3d_info
-decodedbg
3d_rt_write
DestTy too big for FPTrunc
3d_urb_write
igc-shuffle-simplification
reserved_76
Common symbol '
reserved_77
-initializePayload
va_convolve_2d
igc-vectorprocess
va_minmax
Error Check
va_minmaxfilter
MCCompactEncodedInstFragment
va_erode
-noFFIDProlog
va_dilate
Invalid predicate in FCmp instruction!
va_boolcentroid
MCDwarfCallFrameFragment
va_centroid
MCSymbolIdFragment
va_convolve_1d_v
MCCVDefRangeTableFragment
va_convolve_1d_h
VectorProcess
va_convolve_1pixel
igc-address-space-alias-analysis
va_floodfill
 (emit nops)
va_lbpcreation
-hashmovs1
va_lbpcorrelation
'common' global may not be marked constant!
va_correlationsearch
 bytes)
va_hdc_convolve_2d
 Fixups:[
va_hdc_minmaxfilter
-dumpToCurrentDir
va_hdc_erode
IntToPtr2
va_hdc_dilate
MCDummyFragment
va_hdc_lbpcorrelation
 IsInsertionPoint:
va_hdc_lbpcreation
-stepping
va_hdc_convolve_1d_h
splitDouble
va_hdc_convolve_1d_v
 RangeEnd:
va_hdc_convolve_1pixel
14ocl_image2d
svm_block_ld
Reg:
svm_block_st
vptrcast
svm_gather
setMessagePhase@
svm_scatter
must occur exactly one time!
svm_atomic
__ustring
svm_gather4scaled
' value invalid for uint argument!
svm_scatter4scaled
igc-agg-arg
__debug_names
Usage: -stop-noSrcDep-at <NUMBER>
vCastload
kernel_
AggregateArgumentsAnalysis
attr 
__apple_types
"cm"
USAGE: missing number of gen binaries that will be patched.
"3d"
 -help'
"cs"
__debug_line_str
.decl P
__debug_frame
v_type=P 
USAGE: -decodedbg <dbg filename>
num_elts=
.decl A
v_type=A 
Fix the alignment of loads and stores according to OpenCL rules
__debug_loc
__debug_inlined
.decl S
USAGE: -setFFID <ffid>
 v_type=S
LLVM
 num_elts=
 v_name=
.decl T
__debug_tu_index
debug-counter
Comma separated list of debug counter skip and count
 v_type=T
igc-collect-vertex-shader-properties
.parameter 
Multiple errors:
.input 
 offset=
NULL
.decl 
Writing '
'... 
 v_type=G
.debug_pubnames
 alias=<
.version 
IR_Build
.global_function 
Lower inputs outputs for vertex shader
.kernel 
.debug_macinfo
.funcdecl 
.apple_names
/// VISA Predefined Variables
.apple_namespaces
// .decl V
simdShuffleDown@
// .decl T
Allocation failed
.kernel_attr Target=
.debug_types.dwo
Illegal or unimplemented CISA instruction (opcode, type): (
GRF_Hybrid_RA
igc-vertex-shader-lowering
 /// $
.debug_rnglists.dwo
preRA_Scheduling
armv4
arm64
thumb
_global
section_info_dwo
section_abbrev_dwo
array::at
skel_loc
.signal
VB_Create_Var
.wait
VB_IR_Construction
armv7ve
.any
19ocl_image2d_msaa
.all
 is out of range.
always-inline
svm_
ComputeShaderLowering
block_
sec_end
<MCSection
disable-nounwind-inference
.unaligned
v8m.base
atomic
20ocl_image2darraymsaa
gather4scaled
,#execinstr
scatter4scaled
..., 
print-wia-check
v7-m
.function 
,unique,
FILE 
track-memory
LOC 
%9lld  
raw_sendc 
   ---User Time---
raw_send 
mach-o section specifier requires a section whose length is between 1 and 16 characters
raw_sendsc.
igc-collect-hull-shader-properties
raw_sends.
Debug wia-check analysis
eot.
powerpc64
S_ZEROFILL
start 
notinit
end 
cloudabi
S_8BYTE_LITERALS
pixel_null_mask.
S_LITERAL_POINTERS
cps.
malloc_cont
divS.
WIAnalysis: 
__builtin_IB_atomic_max_global_i32
S_MOD_INIT_FUNC_POINTERS
illegal
31x31
gnux32
15x15
interposing
 4x16
16byte_literals
 1x16
Lower inputs outputs for hull shader
 1x1
Args: 
8_connect
thread_local_zerofill
4_connect
disable-inlined-alloca-merging
 31x31
basic
 15x15
vaBoolSum@
.mod
verbose
<RTI>
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
strip_static_syms
  unknown 
no_dead_strip
<ST>
self_modifying_code
<LRTW>
Callee
<CPS>
<PS>
31ocl_image2d_array_msaa_depth
Kernel Header / Declare Errors: 
this directive must appear between .cfi_startproc and .cfi_endproc directives
AlwaysInline
Instruction / Operand / Region Errors: 
label%d's name index(%d) is not valid
__builtin_IB_atomic_and_global_i32
S%d's name index(%d) is not valid
Starting a function before ending the previous one!
S%d's number of elements(%d) is not vaild
 with cost=
T%d's name index(%d) is not valid
T%d's number of elements(%d) is not valid
frame register and offset can be set at most once
Input V%d is out of bound [%d, %d)
stack allocation size must be non-zero
Input V%d = [%d, %d) intersects with V%d = [%d, %d)
exp2
Explicit input %d must not follow an implicit input %d
       ; preds =
Input %d points to an invalid variable(%d)
ampersand
Input %d's size(%d) does not agree with its variable (V%d)'s
solidus
Input%d points to an invalid sampler index(%d)
 Off=
Input%d points to an invalid/predefined surface index(%d)
eight
Input%d's size(%d) does not agree with its surface's
igc-hull-shader-lowering
Input%d has invalid operand class(%d)
; Materializable
Invalid opcode, value: 
 in other contexts
vISA instruction not supported on this platform
CISA instruction uses an illegal execution size.
 align 
CISA instruction uses an illegal predicate value.
21ocl_image2darraydepth
 Error in CISA variable decl: 
REG_NOMATCH
V%d's name index(%d) is not valid: %s
REG_ECTYPE
V%d's type(%s) is not legal: %s
dso_local 
V%d's number of elements(%d) is out of range: %s
protected 
V%d's alias offset must be zero when it is not aliased: %s
Write relative block frequency to function summary 
Circular alias detected, alias index: %d
Aliased variable aliases to an invalid alias index. Variable count: %d. invalid index: %d. %s
__builtin_IB_atomic_inc_global_i32
Variable decl's alias offset exceeds the bounds of the aliased variable decl allocation size: %s
inteldialect 
V%d's variable alignment is not a valid alignment value: %s
26ocl_image2d_array_depth
V%d's alias index must point to a valid CISA variable index between 0 and %d. Currently points to invalid index V%d: %s
spill
 Error in address variable decl: 
, { 
A%d's name index(%d) is not valid: %s
; ModuleID = '
Max possible address registers are 16 on BDW+: %s
fill
 Error in predicate variable decl: 
P%d's name index(%d) is not valid: %s
/-------------------------------------------!!!KERNEL HEADER ERRORS FOUND!!!-------------------------------------------\
Value: 
/--------------------------------------------!!!INSTRUCTION ERROR FOUND!!!---------------------------------------------\
             === Binary Compaction ===
Error in CISA routine with name: 
 Uses(
Error Message: 
Legal CISA region width parameter values: {1, 2, 4, 8, 16}.
DW_TAG_entry_point
DW_TAG_access_declaration
DW_TAG_friend
DW_TAG_namelist
Diagnostics: 
 Instruction variables' decls: 
 BB:
 Violating Instruction: 
__builtin_IB_atomic_cmpxchg_global_i32
\----------------------------------------------------------------------------------------------------------------------/
checksumkind: 
ADDRESSOF Operand decl... are those even allowed>
end of file in COMDAT variable name
invalid value number (too large)!
Immediate operand: 
DW_TAG_subrange_type
Operand type: 
!DIModule(
 unable to print.
!DITemplateValueParameter(
unknown operand?
                               
More than 1 kernel attribute defined SLMSize
__builtin_IB_atomic_cmpxchg_local_i32
Operand modifier for non-general and non-indirect operands must be MODIFIER_NONE.
!DIMacroFile(
Only arithmetic modifiers should be used with arithmetic instruction general or indirect operands.
linkonce_odr
unwind
Only logical modifiers should be used with logical instruction general or indirect operands.
DW_TAG_rvalue_reference_type
Boolean types for immediate (constant literals) operands are disallowed.
DW_TAG_thrown_type
Variable V%d is not declaired in CISA symtab.
tail 
Not allowed to write to a read only variable
WIAnalysis
CISA region has width of 0
__builtin_IB_atomic_add_global_i64
Invalid execution size
          cleanup
Horizontal Stride should not be 0 for a destination operand.
unordered
monotonic
release
There's no reason, to set the vertical stride or width of a destination operand. They are ignored.
DW_AT_stmt_list
Horizontal Stride should not be REGION_NULL
 void
Legal CISA region horizontal stride parameter values: {0, 1, 2, 4}.
, ...
Execution size must be greater than width.
WIAnalysis provides work item dependency info
Legal CISA region vertical stride parameter values: {0, 1, 2, 4, 8, 16, 32}.
 reassoc
CISA operand region access out of 2 GRF boundary (within %d bytes): %d
 ninf
CISA operand accesses more than 2 GRF due to mis-alignment: start byte offset = %d, end byte offset = %d
fastcc
coldcc
x86_fastcallcc
WARNING: CISA region and offset cause an out of bounds byte access: 
DW_AT_decl_file
An access should not exceed the declared allocation size: 
DW_AT_lower_bound
  The access fails the following check to determine correct bounds (see CISA manual section 5.1 Region-based Addressing):
 inbounds
  (row_offset * GRF_SIZE + col_offset) + (((i * v_stride) + (j * h_stride)) * type_size) <= type_size * num_elements:
igc-wi-analysis
__builtin_IB_atomic_min_global_u64
) + (((
 xor
) + (
arm_aapcs_vfpcc
msp430_intrcc
)) * 
DW_AT_description
) <= 
 syncscope("
Violating Instruction: 
 ; (
For 3 source operand instructions, the destination operand's horizontal stride must be 1.
spir_kernel
LRP instruction only supports sources and destination of type F.
consecu
For 3 source operand instructions, region must be either scalar or contiguous
__builtin_IB_atomic_max_global_i64
Aliased variable aliases to an invalid alias index. Variable count: %d. invalid index: %d
constant 
Raw operand should be GRF-aligned: Raw offset is %d
win64cc
A CISA raw operand's offset field must be within the allocated operand size. Raw offset is %d, allocated number of elements is %d
DW_AT_call_all_calls
Execution size for a flag copy mov instruction should be 1, as it is a scalar copy.
DW_AT_main_subprogram
dst operand type for a flag copy mov instruction should be UD/UW/UB.
ifunc 
dst operand type for a flag copy mov instruction should be greater than or equal to the size of the src0 operand's type size.
anyregcc
saturation is not allowed for dst operands of a flag copy mov instruction
p_conse
predication is not allowed for dst operands of a flag copy mov instruction
__builtin_IB_atomic_max_global_f64
Destination operand of CISA MOVS instruction only supports general and indirect operands.
path: "
Source0 operand of CISA MOVS instruction only supports general, indirect, and immediate operands.
x86_intrcc
Destination operand of CISA SETP instruction only supports predicate operands.
DW_AT_MIPS_allocatable_dopetype
Source0 operand of CISA SETP instruction only supports general, indirect, and immediate operands.
name: "
FMINMAX opext must be either 0x0 or 0x1 (min or max).
, summaries: (
Destination operand of CISA SEL instruction only supports general and indirect operands.
amdgpu_vs
Source0 operand of CISA SEL instruction only supports general, indirect, and immediate operands.
strided
Source1 operand of CISA SEL instruction only supports general, indirect, and immediate operands.
__builtin_IB_atomic_or_global_i64
Illegal Move Instruction Opcode: %d, %s.
, refs: (
Illegal Synchronization Instruction Opcode: %d, %s.
amdgpu_gs
Illegal Scalar Control Flow Instruction Opcode: %d, %s.
DW_AT_BORLAND_Delphi_destructor
CISA ISA_VME_IME instruction uses illegal stream mode.
<placeholder or erroneous Constant>
CISA ISA_VME_IME instruction uses illegal search ctrl.
, calls: (
CISA ISA_VME_IME uses undeclared surface.
CISA ISA_VME_SIC uses undeclared surface.
random 
CISA ISA_VME_FBR uses undeclared surface.
__builtin_IB_atomic_inc_global_i64
FBRMbMode operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
, offset: 
FBRSubMbShape operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
builtin
FBRSubPredMode operand of CISA VME_FBR instrution should be either a general, indirect, or immediate operand.
iterX
Number of message source GRFs must be between 1 and 15
DW_AT_APPLE_omit_frame_ptr
Number of message destination GRFs must be between 0 and 16
, sizeM1: 
desc operand of CISA RAW_SEND instrution should be either a general, indirect, or immediate operand.
convergent
Number of source0 GRFs must be between 1 and 32
Special const prop for SLM
, typeIdInfo: (
Number of message destination GRFs must be between 0 and 32
, byte: 
Valid range for num_out parameter of URB write is [1,8]
allocsize(
Valid range for global_offset parameter of URB write is [0,2047]
DW_OP_skip
Only execution size of 8 is supported for URB write
11read_imagef14ocl_image2d_ro11ocl_samplerDv2_fS_S_
11read_imagef20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
Invalid encoding for register file
probe-stack
Illegal Miscellaneous Flow Instruction Opcode: %d, %s.
minsize
Destination of CISA arithmetic instruction should be general or indirect operand.
igc-slmconstprop
Illegal destination modifier for CISA arithmetic instruction.
__builtin_IB_atomic_add_global_i16
%s does not support saturation
%s does not support saturation on integer types.
nocapture
Only mul/add/mad/div/inv/sqrtm/sqrt/divm are allowed to use double precision floating point operands.
DW_OP_lit31
%s only supports single and half float type
ctpop
%s only supports single float type
%s only supports integer and single precision float types
norecurse
%s only supports integer type
Custom Pass for Position-Only Shader
lzd only supports UD type
DW_OP_reg15
%s only support D/UD dst type
lane
sad2/sad2add only supports W/UW dst type.
noreturn
%s only supports single UD type
DW_OP_reg31
%s has illegal dst type
optforfuzzing
unsupported source modifier for arithmetic instruction
DW_OP_breg7
source in arithmetic instruction must be general, indirect, or immediate
Use llvm.dbg.addr for all local variables
Arithmetic instructions that use single or double precision or half float types must use the same type for all of their operannds: dst(%s) and src%d(%s).
igc-remove-nonposition-output
immediate src%d has %d type, and it must have integer type
__builtin_IB_atomic_xchg_global_i16
sad2/sad2add only supports B/UB types for src0 and src1; W/UW for src2 (sad2add). src%d has invalid type.
Pointer ABI alignment must be a power of 2
mul/div does not support Q/UQ types for src%d
returns_twice
ieee div does not support types for src%d, other than F/DF
DW_OP_breg31
ieee sqrt does not support types for src%d, other than F/DF
Zero width native integer type in datalayout string
%s src0 and src1 only supports single UD type
Expected mangling specifier in datalayout string
lrp only supports general/immediate operands
Common ISA Logic instrutions are not allowed to have address operands.
remove non-position output in vertex shader
Operand type of logic operantion for predicate operands should all be BOOL (ie if one operand is BOOL they all have to be BOOL).
Address space 0 can never be non-integral
ror/rol does not support i8/i64 types
Invalid preferred alignment, must be a power of 2
fbl/fbh/cbit does not support Q/UQ type.
safestack
Predicate can not be used in logic operantion for predicate operands.
DW_ATE_boolean
All operands of logic instructions must be of integral type! opnd %d has float type %d
number of bits must be a byte width multiple
All operands of logic instructions must be of integral type! opnd %d has unknow type %d
DW_ATE_packed_decimal
CISA compare instruction destination only supports a predicate operand.
DIFlagPrivate
CISA compare instruction sources do not support address or predicate operands.
debug_loc
CISA address instruction destination only supports an address operand.
__builtin_IB_atomic_min_global_f16
CISA ADDR_ADD instruction sources do not support predicate operands.
DIFlagVirtual
Can not take the address of a pre-defined variable
uwtable
Can not take the address of a pre-defined surface
DW_LANG_Ada95
DIFlagVector
CISA SAMPLER ISA_SAMPLE_UNORM instruction only accepts non-zero channel masks.
DIFlagLValueReference
CISA SAMPLER ISA_SAMPLE_UNORM instruction uses undeclared sampler.
exactmatch
Surface T0 (the SLM surface) is not allowed for the SAMPLER instruction ISA_SAMPLE_UNORM.
vectorized
CISA SAMPLER instruction ISA_SAMPLE_UNORM uses undefined surface.
__builtin_IB_atomic_min_local_u16
__builtin_IB_atomic_max_global_f16
u_offset operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
DIFlagNoReturn
v_offset operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
u_delta operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
DW_CC_pass_by_value
v_delta operand of CISA SAMPLER ISA_SAMPLE_UNORM instrution should be either a general, indirect, or immediate operand.
DW_LANG_C11
CISA SAMPLER SAMPLE/LOAD instruction uses undeclared sampler.
Surface T0 (the SLM surface) is not allowed for the SAMPLER instruction ISA_SAMPLE/ISA_LOAD.
name
CISA SAMPLER instruction ISA_SAMPLE/ISA_LOAD uses undefined surface.
simd8
FullDebug
Illegal SIMD mode used in ISA_SAMPLE/ISA_LOAD inst.
Enable optimization remarks from passes whose name match the given regular expression
Pixel Null Mask Enable only valid for SKL+
L_AUTO_k
CPS LOD Compensation Enable must be disabled unless SIMD mode is simd8* or simd16*
R_WEBASSEMBLY_MEMORY_ADDR_SLEB
CPS LOD Compensation Enable is only supported for sample, sample_b, sample_b_c, sample_c and LOD
L_AUTO_f
beforeRemoveRedundantLabels
CISA SAMPLER AVS instruction only accepts non-zero channel masks.
 at line 
CISA VA MINMAXFILTER instruction uses undeclared sampler.
GED ERROR: 
Surface T0 (the SLM surface) is not allowed for the SAMPLER AVS instruction.
simd16
CISA VA instruction MINMAX uses undefined surface.
!Missed
u_offset operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
__builtin_IB_atomic_max_local_i16
v_offset operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
mme0
u_delta operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
mme6
v_delta operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
Function
u2d operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
Args
groupid operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
branchFunnel
verticalBlockNumber operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
cntrl for CISA SAMPLER AVS intruction should be a value 0-3 (8/16bit full/chrominance down sample).
__builtin_IB_atomic_max_local_u16
v2d operand of CISA SAMPLER AVS instrution should be either a general, indirect, or immediate operand.
Inorder PostDominator Tree: 
execMode for CISA SAMPLER AVS intruction should be a value 0-3 (16x4, 8x4, 16x8, or 4x4).
x86_fp80
iefbypass operand of CISA SAMPLER AVS instruction should be either a general, indirect, or immediate operand.
MT1R_A64_B
Surface T0 (the SLM surface) is not allowed for VA instructions.
MT1R_US
u_offset operand of CISA MINMAX instrution should be either a general, indirect, or immediate operand.
(badref)
v_offset operand of CISA MINMAX instrution should be either a general, indirect, or immediate operand.
token
CISA VA instruction MINMAXFILTER uses undefined surface.
u_offset operand of CISA MINMAXFILTER instrution should be either a general, indirect, or immediate operand.
__builtin_IB_get_stage_in_grid_size
v_offset operand of CISA MINMAXFILTER instrution should be either a general, indirect, or immediate operand.
MT_MEMFENCE
CISA VA VA CENTROID/BOOLCENTROID instruction MINMAX uses undefined surface.
__builtin_IB_get_local_size
u_offset operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
MT1A_A64_UF
v_offset operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
expected function name in blockaddress
v_size operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
Byte Scattered Read
h_size operand of CISA VA CENTROID/BOOLCENTROID instrution should be either a general, indirect, or immediate operand.
enqueued_local_size_z
CISA VA CONVOLVE/ERODE/DILATE instruction uses undeclared sampler.
.debug_abbrev_begin
CISA VA CONVOLVE/ERODE/DILATE instruction MINMAX uses undefined surface.
__AUTO_GENERATED_DUMMY_LAST_BB
u_offset operand of CISA CONVOLVE/ERODE/DILATE instrution should be either a general, indirect, or immediate operand.
Typed Atomic Counter Operation
v_offset operand of CISA CONVOLVE/ERODE/DILATE instrution should be either a general, indirect, or immediate operand.
global_offset_x
Invalid VA sub-opcode: %d.
A64 Block Write
Surface T0 (the SLM surface) is not allowed for VA++ instructions.
expected top-level entity
CISA VA++ instruction LBP Correlation uses undefined surface.
Media Block Read Sampler Cache
u_offset operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
virtual_binding_table_ds
v_offset operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
vector
Disparity operand of CISA LBP Correlation instrution should be either a general, indirect, or immediate operand.
virtual_binding_table_vs
CISA VA++ instruction uses undeclared sampler.
CISA VA++ instruction uses undefined surface.
base_patch
u_offset operand of CISA VA++ instrution should be either a general, indirect, or immediate operand.
7041
v_offset operand of CISA VA++ instrution should be either a general, indirect, or immediate operand.
expected '=' after name
Invalid mode field for CISA VA++ instruction. Only 4x16, 1x16, and 1x1 (in the case of 1 pixel convolve) are supported.
load_block
CISA LBP Creation VA++ instruction uses undefined surface.
u_offset operand of CISA LBP Creation VA++ instrution should be either a general, indirect, or immediate operand.
info_string
v_offset operand of CISA LBP Creation VA++ instrution should be either a general, indirect, or immediate operand.
aligned oword block write
Invalid mode field for CISA LBP Creation VA++ instruction. Only 5x5, 3x3, or both modes are supported.
7066
Pixel direction v-mask left of CISA VA++ FloodFill instruction only supports general, indirect, and immediate operands.
depthcube
Pixel direction v-mask right of CISA VA++ FloodFill instruction only supports general, indirect, and immediate operands.
on (wait for fence commit)
loop_count of Common ISA sample instrution is invalid type.
expected comdat keyword
u_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
 flushing
v_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
depth2d_ms_array
CISA VA++ instruction Correlation search operand verticalOrigin can only be of operand class general, indirect, or immediate.
func_begin
CISA VA++ instruction Correlation search operand horizontalOrigin can only be of operand class general, indirect, or immediate.
texturecube
CISA VA++ instruction Correlation search operand xDirectionSize can only be of operand class general, indirect, or immediate.
invalid BTI for fence (must be 0x0 or 0xFE)
CISA VA++ instruction Correlation search operand yDirectionSize can only be of operand class general, indirect, or immediate.
bindless_image2d_t
CISA VA++ instruction Correlation search operand xDirectionSearchSize can only be of operand class general, indirect, or immediate.
7027
CISA VA++ instruction Correlation search operand yDirectionSearchSize can only be of operand class general, indirect, or immediate.
Metadata id is already used
u_offset of Common ISA HDC INSTRUCTION should not be address or predicate operand.
SubType
v_offset of Common ISA HDC instruction should not be address or predicate operand.
bindless_image1d_t
CISA VA++ instruction uses invalid output pixel size.
func_end
CISA VA++ instruction uses invalid mode.
bindless_image1d_array_t
disparity of Common ISA HDC LBPCORRELATION should not be address or predicate operand.
7034
CISA VA++ instruction uses undefined destination surface.
needBufferOffset
x_offset of Common ISA HDC instruction should not be address or predicate operand.
a64 dual block 
y_offset of Common ISA HDC instruction should not be address or predicate operand.
expected comma after alias or ifunc's type
Invalid VA++ sub-opcode: %d.
 hword
Illegal Sampler Instruction Opcode: %d, %s.
Illegal SIMD CF Instruction Opcode: %d, %s.
<stdin>
MEDIA_LD modifier must be 0-5 not %d
MEDIA_ST modifier must be 0-3 not %d
7143
Surface T0 (the SLM surface) is not allowed for MEDIA_LD/MEDIA_ST
CISA dataport instruction uses an undeclared surface.
MEDIA_LD/MEDIA_ST plane must be in the range [0, 3]: %d
forward reference and definition of global have different types
MEDIA_LD/MEDIA_ST block width must be in the range [1, 32]: %d
7048
MEDIA_LD/MEDIA_ST block height must be in the range [1, 64]: %d
libigcmc.so
MEDIA_LD only supports objects that fit into a single dataport transaction where block width <= 64 bytes and size <= 256 bytes. Block width: %d. Block height: %d
module_begin
MEDIA_ST only supports objects that fit into a single dataport transaction where block width <= 64 bytes and size <= 256 bytes. Block width: %d. Block height: %d
atomic 32-bit integer (slot group high)
x_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
MSDUW_DWS
y_offset of Common ISA Meida LD/ST instrution should not be address or predicate operand.
-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v24:32:32-v32:32:32-v48:64:64-v64:64:64-v96:128:128-v128:128:128-v192:256:256-v256:256:256-v512:512:512-v1024:1024:1024-n8:16:32
OWORD_LD*/OWORD_ST size must be in the range [0, 3] (ie, OWord block size must be 1/2/4/8. OWord block size: %d
44777
Surface T0 (the SLM surface) is not allowed for OWORD_LD*/OWORD_ST
cannot have an attribute group reference in an attribute group
Offset of Common ISA OWORD LD/ST instrutions should not be address or predicate operands.
unmonitor event
Incorrect element size for Gather/Scatter CISA inst.
Linker Options
global_offset of Common ISA gather/scatter instrution should not be address or predicate operand.
module_end
At least one channel must be enabled for TYPED GATEHR4/SCATTER4
Invalid global variable comdat ID
Surface T0/T5 (the SLM surface) is not allowed for TYPED SCATTTER4/GATHER4
.simd16
CISA dataport TYPED SCATTTER4/GATHER4 instruction uses an undeclared surface.
Invalid TYPE table: Only named structs can be forward referenced
Invalid DWORD ATOMIC sub op.
.simd8
src0 in ISA_DWORD_ATOMIC inst must be V0 for INC/DEC/PREDEC.
expected 32-bit integer (too large)
src1 in ISA_DWORD_ATOMIC inst must be V0 for non CMPXCHG operations.
.cpo
Illegal dataport Instruction Opcode: %d, %s.
exp2l
Raw Operand %s has incorrect type %s
line_table_start
EXPLICIT
Invalid multiple blocks
LOCAL_SIZE
simd32/64
GROUP_COUNT
Invalid gep with no operands
LOCAL_ID
ReturnFormat
PSEUDO_INPUT
-noLocalSplit
sample compare+LOD bias
Fast-math-flags specified for call without floating-point scalar or vector return type
section_line
nomod
Explicit call type is not a function type
modified
sample gather4+pixel offset
Explicit invoke type does not match pointee type of callee operand
bottom
sample with lod forced to 0
top_mod
expected metadata or 'addrspace'
bottom_mod
sample_ld2dms
reserved
INSERTVAL: Invalid type
igc.input.ir
sample_deinterlace
sample_flush
Invalid ID
unsupported DC2 op
expected index
2 OWords
Trying to materialize functions before seeing function blocks
Intel OpenCL 
' vs current: '
RGBA
_simd
0000
Invalid bitcode signature
16-full
16-downsampled
expected '(' in call
8-full
A64 
8-downsampled
reqd_work_group_size
debug_end
/System/Library/Frameworks/OpenCL.framework/Resources/
invalid MDC_SM3
Legalize calls to functions/subroutines and their signatures
newKernel
igc.device.enqueue
M1_NM
 with return
M2_NM
IndirectlyCalled
M3_NM
section_info
M4_NM
no-infs-fp-math
M5_NM
atomic_iadd
M6_NM
referenced-indirectly
M7_NM
atomic_smin
M8_NM
forward references to non-struct type
sample_b
SimdMode:MDC_SM2R
sample_l
PrivateMemStatelessSize
sample_c
section_abbrev
sample_d
SG8U
sample_b_c
DualHeader
sample_l_c
deviceEnqueueEventPool
sample4
preserve-nan
resinfo
12write_imagei14ocl_image3d_rwDv4_iS0_
sampleinfo
GED unable to compact instruction
sample+killpix
smpAddress
sample4_c
dwarf_frame
sample4_po
imageSrgbOrder
sample4_po_c
DstMathMacroExt
sample_d_c
imageWidth
sample_lz
Src0Width
sample_c_lz
instruction expected to be numbered '%
load_lz
DescRegFile
load_2dms_w
printfBuffer
load_mcs
debug_range
convolve
OL, 
minmax
Src0AddrSubRegNum
minmaxfilter
erode
operand has invalid math macro register
dilate
vector elements must have integer, pointer or floating point type
boolcentroid
centroid
legacy
CONV_1D_HORIZONTAL
section_debug_loc
CONV_1D_VERTICAL
coarse_phase
CONV_1PIXEL
Src1SrcMod
FLOOD_FILL
 undefined reference to `jmp()' 
LBP_CREATION
invalid region vertical stride on src1
LBP_CORRELATION
expected constraint string
CORRELATION_SEARCH
invalid region vertical stride on src0
HDC_CONVOLVE_2D
size
HDC_MIN_MAX_FILTER
text_begin
HDC_ERODE
Src2SrcMod
HDC_DILATE
kernel.asm
HDC_LBP_CORRELATION
type
HDC_LBP_CREATION
HDC_CONVOLVE_1D_H
expected '(' after constantexpr cast
HDC_CONVOLVE_1D_V
h:INVALID
HDC_CONVOLVE_1P
UNDEFINED
.debug_info_begin
CM_Y16_FORMAT
SinglePatch
CM_Y8_FORMAT
CM_5x5_mode
CM_3x3_mode
CM_BOTH_mode
invalid indices for extractvalue
CM_16_FULL
igc-priv-mem-to-reg
CM_16_DOWN_SAMPLE
CM_8_FULL
.debug_info_end
CM_8_DOWN_SAMPLE
CM_AVS_16x4
__builtin_IB_get_object_id
CM_AVS_INVALID
CM_AVS_16x8
CM_MMF_16x4
expected '(' in compare constantexpr
CM_MMF_INVALID
xsc8
CM_MMF_16x1
double2
CM_MMF_1x1
.debug_abbrev_begin
CM_MINMAX_ENABLE
packed_ulong3
CM_MAX_ENABLE
cubl128
CM_MIN_ENABLE
ulong2
CM_ED_64x4
CM_ED_32x4
expected ')' in binary constantexpr
CM_ED_64x1
BTS_SLM_A32
CM_ED_32x1
long2
CM_CONV_16x4
.debug_abbrev_end
CM_CONV_INVALID
HWSB
CM_CONV_16x1
CM_CONV_1x1
uchar2
igc-threadcombining
OutputAsmPath
xchg
memopt-merge-load
cmpxchg
char2
minsint
Dwarf Version
maxsint
packed_ushort3
fcmpwr
DeviceEnqueueFuncsAnalysis
ushort2
Null
base element of getelementptr must be sized
Flag Register
short2
ICLLP
short
gen11
Thread Dependency Register
gen11lp
uint2
expected three operands to insertelement
Logic And
int2
$dup
packed_half3
none
The bfi2 instruction is the second instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi2 instruction component-wise performs the bitfield insert operation on src1 and src2 based on the mask in src0.
Use the mask in src0 to take a bit field value from the low bits of src1 and combine it with the value from src2 (so src2 provides all bits other than those masked out and replaced by the bit field value). Store the result in dst.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi2 (exec_size) dst src0 src1 src2
USAGE: Unrecognized option "
half2
Branch Diverging
unrecognized platform string: 
missing required field 'scope'
USAGE: GenX_IR <InputFilename.isa> {Option List}
calla
Converts a CISA file into Gen binary or assembly
float2
Options :
    -output
The cmp instruction performs component-wise comparison of src0 and src1 and stores the results in the selected flag register and in dst. It takes component-wise subtraction of src0 and src1, evaluating the conditional code (excluding NS signal) based on the conditional modifier, and storing the conditional bits in bit-packed form in the destination flag register and all bits of dst channels. If the dst is not null, for the enabled channels, then all bits of the destination channel will contain the flag value for the channel. When the instruction operates on packed word format, one general register may store up to 16 such comparison results. In DWord format, one general register may store up to 8 results.
A conditional modifier must be specified; the conditional modifier field cannot be 0000b. The comparison does not use the NS (NaN source) signals, as described in the Creating Conditional Flags section. Accordingly the conditional modifier should not be .u (unordered).
For each enabled channel 0b or 1b is assigned to the appropriate flag bit and 0/all zeros or all ones (e.g, byte 0xFF, word 0xFFFF, DWord 0xFFFFFFFF) is assigned to dst.
When any source type is floating-point, the cmp instruction obeys the rules described in the tables in the Floating Point Modes section of the Data Types chapter.
Format:
[(pred)] cmp[.cmod] (exec_size) dst src0 src1
- Emit target assembly code to a file.
Double Precision Floating Point Immediate Data Move
    -noschedule
air.raster_order_group
- Turn off code scheduling.
    -nocompaction
missing required field 'filename'
- Turn off binary compaction.
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive before entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving at the else instruction are redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by JIP. The jump target should be the the matching endif instruction for that conditional block.
The following table describes the 16-bit JIP. In GEN binary, JIP is at location src1 and must be of type W (signed word integer). JIP must be an immediate operand, it is a signed 16-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
Format:
else (exec_size) JIP
    -dumpcommonisa
air.amplification_id
- Emit CISA assembly.
.ptrcast
USAGE: GenX_IR <InputFilename.visaasm> {Option List}
air.thread_index_in_simdgroup
Converting a CISA assembly file into CISA binary file
    -outputCisaBinaryName <CISABinaryName>
air.patch_id
- name for the CISA binary file.
An if instruction starts an if/endif or an if/else/endif block of code. It restricts execution within the conditional block to only those channels that were enabled via the predicate control.
Each if instruction must have a matching endif instruction and may have up to one matching else instruction before the matching endif.
If all channels are inactive (for the if/endif or if/else/endif block), a jump is performed to the instruction referenced by JIP. This jump must be to right after the matching else instruction when present, or otherwise to the matching endif instruction of the conditional block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] if (exec_size) JIP UIP
vISA_DumpPasses
missing required field 'type'
vISA_DumpPassesLocation
Line
vISA_DumpDot
air.thread_position_in_grid
vISA_DumpDotAll
.off
VISA_FullIRVerify
air.base_vertex
vISA_dumpVISAOptions
The mad instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The conditional modifier and saturation (.sat) must not be used when src1 or src2 are dwords.
Format:
[(pred)] mad[.cmod] (exec_size) dst src0 src1 src2
vISA_dumpVISAOptionsAll
air.emulation_argument
vISA_Debug
Cosine function. cos(src0)
vISA_DebugConsoleDump
main
vISA_Gtpin
Floating-Point Divide function. src0/src1
vISA_EmitLocation
air.struct_type_info
vISA_dumpRPE
.zext
vISA_dumpLiveness
air.write
vISA_EnableAlways
Integer Remainder only
vISA_EnableSendFusion
globalSizeUnavaliable
vISA_EnableWriteFusion
src0^src1
vISA_EnableAtomicFusion
floating point constant does not have type '
vISA_LocalCopyProp
Sine function. sin(src0)
vISA_LocalFlagOpt
MaxNumOfInputSignatureEntries
vISA_LocalMACopt
.concat
vISA_LocalCleanMessageHeader
movi
vISA_LocalRenameRegister
Do nothing. The nop instruction takes an instruction dispatch but performs no operation. It can be used for assembly patching in memory, or to insert a delay in the program sequence.
Format:
vISA_LocalDefHoist
AirInlineBuiltins
vISA_FoldAddrImmed
Plane
vISA_enableCSEL
packed'ness of initializer and type don't match
vISA_OptReport
rnde
vISA_MergeScalar
UserSubroutine
vISA_EnableMACOpt
.trunc
vISA_EnableDCE
__builtin_IB_get_group_id
vISA_DisableleHFOpt
Select
vISA_enableUnsafeCP_DF
AirFunctionBuilder
vISA_EnableStructurizer
vISA_StructurizeCF
expected function name
vISA_EnableScalarJmp
The subb instruction performs component-wise subtraction of src0 and src1 and stores the results in dst, it also stores the borrow into acc.
If the operation produces a borrow (src0 < src1), write 0x00000001 to acc, else write 0x00000000 to acc.
Format:
[(pred)] subb[.cmod] (exec_size) dst src0 src1
vISA_enableCleanupBindless
igc-air-function-builder
vISA_EnableSplitVariables
.legal
vISA_ChangeMoveType
movi
vISA_accSubstitution
csel
vISA_doAccSubAfterSchedule
rsqrt_chan
vISA_ifCvt
The halt instruction temporarily suspends execution for all enabled compute channels. Upon execution, the enabled channels are sent to the instruction at (IP + UIP), if all channels are enabled at HALT, jump to the instruction at (IP + JIP).
If the halt instruction is not inside any conditional code block, the values of JIP and UIP should be the same. If the halt instruction is inside a conditional code block, the UIP should be the end of the program and the JIP should be the end of the inner most conditional code block.
The UIP must point to a HALT Instruction.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate and dst must be null.
Format:
[(pred)] halt (exec_size) JIP UIP
vISA_LVN
vISA_numGeneralAcc
The madm instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The source and destination operands have a higher precision carried in the exponent for this operation. The madm instruction is used for macro operations, where precision is accumulated over several instructions. This accumulation requires the exponent to increase by 2 extra bits across multiple madm operations.
Refer to Macros Defined in 'Math' Section for usage and restrictions of this operation.
Format:
[(pred)] madm[.cmod] (exec_size) dst src0 src1 src2
vISA_reassociate
unordered_map::at: key not found
vISA_unsafeMath
.promote
vISA_split4GRFVar
AIR Function Attribute Update
vISA_noSrc1Byte
Perform component-wise logical right shift with zero insertion of the bits in src0 by the shift count indicated in src1, storing the results in dst. Insert zero bits in the number of MSBs indicated by the shift count.
src0 and dst can have different types and can be signed or unsigned.
Note: For word and DWord operands, the accumulators have 33 bits.
Note: For unsigned src0 types, shr and asr produce the same result.
In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
Format:
[(pred)] shr[.cmod] (exec_size) dst src0 src1
vISA_expandPlane
Resolve fast flag markers to operand attributes
vISA_FImmToHFImm
The call instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the call instruction. If none of the channels jump into the subroutine, the call instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
When SPF is on, the predication control must be scalar.
The following section describes JIP, the jump offset, for DevSKL+.
JIP can be an immediate or register value. When a jump occurs, this value is added to IP pre-increment. In GEN binary, JIP is at location src1 and src0 must be null. The GRF register must be put (for example, by the assembler) at dst location.
Format: [(pred)] call (exec_size) dst JIP
Format: [(pred)] call (exec_size) dst JIP
vISA_cacheSamplerHeader
expected '=' after instruction name
vISA_forceSamplerHeader
The sendsc instruction has the same behavior as the sends instruction except the following.
sendsc first checks the dependent threads inside the Thread Dependency Register. There are up to 8 dependent threads in the TDR register. The sendsc instruction executes only when all the dependent threads in the TDR register are retired.
Wait for dependencies in the TDR Register to clear, then send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sendsc (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
vISA_noncoherentStateless
rgb10a2
vISA_enablePreemption
VISA_EnableBarrierInstCounterBits
dp4a
vISA_forceFPMAD
ThreadCombining
vISA_DisableMixMode
rg8snorm
vISA_DisableHFMath
SFID
vISA_ForceMixMode
expected ',' after true destination
vISA_UseSends
at pc 
vISA_doAlign1Ternary
intersection_function_table
vISA_loadThreadPayload
.soften
vISA_foldEOTtoPrevSend
void
vISA_hasRNEandDenorm
error decoding instruction: SEND dst ARF
vISA_forceNoFP64bRegioning
half3x3
vISA_alignBindlessSampler
swizzle Y could not be retrieved
vISA_RoundRobin
expected '[' with indirectbr
vISA_PrintRegUsage
 (line 
vISA_IPA
float3x4
vISA_LocalRA
.sclr
vISA_LocalRARoundRobin
float3x2
vISA_ForceSpills
invalid ChOff
vISA_NoIndirectForceSpills
packed_bool2
vISA_AbortOnSpill
 must be a constant integer expression
vISA_VerifyRA
not enough parameters specified for call
vISA_LocalBankConflictReduction
nan is deprecated, us snan(...) or qnan(...)
vISA_FailSafeRA
air.location
vISA_FlagSpillCodeCleanup
.elt
vISA_GRFSpillCodeCleanup
air.vertex
vISA_SpillSpaceCompression
Atomic mutually exclusive with Switch
vISA_ConsiderLoopInfoInRA
air.external_initializations
vISA_ReserveR0
H2 is obsolete; use M16 in execution offset: e.g. op (16|M16) ...
vISA_SpiltLLR
expected 'within' after catchswitch
vISA_EnableGlobalScopeAnalysis
N4 is obsolete; use M12 in execution offset: e.g. op (4|M12) ...
vISA_LocalDeclareSplitInGlobalRA
HullShaderDispatchMode
vISA_DisableSpillCoalescing
.lsext
vISA_GlobalSendVarSplit
vISA_NoRemat
expected default register type
vISA_ForceRemat
greedy-live-range-reduction
vISA_SpillMemOffset
invalid predication control
vISA_ReservedGRFNum
expected 'within' after cleanuppad
vISA_TotalGRFNum
saturation flag goes on destination operand: e.g. op (..) (sat)dst ...
vISA_GRFNumToUse
AIR Samplers
vISA_RATrace
.rsext
vISA_FastSpill
AirRWModification
vISA_AbortOnSpillThreshold
 for this function
vISA_enableBCR
air-raster-order-groups
vISA_hierarchicaIPA
expected a0
vISA_VerifyAugmentation
expected 'to' after cast value
vISA_LocalScheduling
expected subregister
vISA_preRA_Schedule
exp2f
vISA_preRA_ScheduleForce
.shl
vISA_preRA_ScheduleCtrl
access granularity too small for data type
vISA_preRA_ScheduleRPThreshold
expected |
vISA_DumpSchedule
AIR Metadata Parse
vISA_DumpDagDot
invalid region width
vISA_EnableNoDD
RetValSize
vISA_DebugNoDD
expected source type
vISA_NoDDLookBack
igc-const-prop
vISA_EnableNoSrcDep
.lshr
vISA_EnableNoSrcDepScen1
phi node must have first class type
vISA_EnableNoSrcDepScen2
Extern
vISA_DumpNoSrcDep
expected 
vISA_stopNoSrcDepSetAt
out of dynamic memory in yy_scan_bytes()
vISA_FuseTypedWrites
IGC::PositionOnlyVertexShader
vISA_ReorderDPSendToDifferentBti
54intel_sub_group_avc_ime_evaluate_with_single_reference14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
vISA_WAWSubregHazardAvoidance
NAN handling
vISA_useMultiThreadedLatencies
IGC Type Legalizer
vISA_SchedulerWindowSize
LogicalAndToBranch
vISA_UnifiedSendCycle
element count must have integer type
vISA_HWThreadNumberPerEU
igc-custom-unsafe-opt-pass
vISA_NoAtomicSend
invalid %s
vISA_ReadSuppressionDepth
globalArgBuf
vISA_Compaction
invalid argument
vISA_BXMLEncoder
vISA_IGAEncoder
igc-type-legalizer
vISA_outputToFile
igc-promote-resources-to-direct-addrspace
vISA_SymbolReg
floor
vISA_PrintASMCount
-cl-std=CL1.2
vISA_GenerateBinary
vISA_GeneratevISABInary
Print Module IR
broadcastMessagePhase@
indirectbr
invoke
cleanupret
catchret
vISA_GenIsaAsmList
fmul
fdiv
vISA_IsaasmNamesFileUsed
alloca
vISA_StripComments
fence
getelementptr
sext
vISA_NumGenBinariesWillBePatched
fptosi
uitofp
Fix FMF for APIs that are using legacy IR
vISA_GetvISABinaryName
fcmp
vISA_LabelStr
extractelement
insertelement
visaStackCall
vISA_DecodeDbg
Fix Fast Math Flags
vector select condition element type must be i1
vector select requires selected vectors to have the same vector length as select condition
select condition must be i1 or <n x i1>
vISA_NoVerifyvISA
vISA_isParseMode
explicit_arg_num
vISA_GetFreeGRFInfo
fpmath
range
make.implicit
vISA_clearHDCWritesBeforeEOT
absolute_symbol
associated
gc-transition
vISA_addFFIDProlog
__builtin_spirv_BuiltInLocalInvocationId
Print PassManager debugging information
Arguments
print pass arguments to pass to 'opt'
Executions
print pass name before it is executed
print-before
vISA_GenerateDebugInfo
print-before-all
Print IR before each pass
print-module-scope
vISA_InsertHashMovs
Only print IR for functions whose name match this for all print-[before|after][-all] options
size-info
: IR instruction count changed from 
VISA_AsmFileNameUser
Releasing pass '
Running pass '
basic block
vISA_HashVal1
Required Passes:
Error: Required pass not found! Possible causes:
- Pass misconfiguration (e.g.: missing macros)
vISA_AddKernelID
Pass Arguments: 
 -- '
' is the last user of following pass instances.
vISA_dumpToCurrentDir
 Freeing Pass '
' on BasicBlock '
assumeCond
vISA_DumpCompilerStats
Required
Preserved
 Uninitialized Pass
vISA_Stepping
Time each pass, printing elapsed time for each on exit
vISA_Platform
img_access_int_coords
-dumpPassesAll
firstbitHi@
symbol is not in a section: 
 -export:
,DATA
-dotAll
RtLibUseGOT
expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '%<type>' or "<type>"
function_type
Maximum optimization to perform
function (
basic block (
NOT 
-dumpDebugConsoleOutput
Pass::print not implemented for pass: '
floatatomicrawA64@
NumFunctions
Multiple symbol versions defined for 
-dumpLiveness
Struct tag nodes must have an odd number of operands!
Struct tag nodes have a string as their first operand
Incorrect field entry in struct type node!
Offsets must be increasing!
Member size entries must be constants!
Old-style TBAA is no longer allowed, use struct-path TBAA instead
-enableAtomicFusion
Immutability tag on struct tag metadata must be a constant
Immutability part of the struct tag metadata must be either 0 or 1
Access type node must be a valid scalar type
-noflagopt
Did not see access type in access path!
Basic Block in function '
Functions may not have common linkage
-nomsgheaderopt
Attribute after last parameter!
Attribute 'builtin' can only be applied to a callsite.
endIndirectCallBB
-nodefhoist
Function takes token but isn't an intrinsic
Functions returns a token but isn't an intrinsic
function declaration may not have a !dbg attachment
-disablecsel
Entry block to function must not have predecessors!
blockaddress may not be used with the entry block!
function !dbg attachment must be a subprogram
-nomergescalar
Global is external, but doesn't have external or weak linkage!
huge alignment values are unsupported
Declaration may not be in a Comdat!
-dce
GlobalValue with non default visibility must be dso_local!
Global is referenced by parentless instruction!
funcElse
-enableUnsafeCP_DF
More than one parameter has attribute returned!
Incompatible argument and return types for 'returned' attribute
Cannot have multiple 'swiftself' parameters!
-noStructurize
Attributes 'readnone and writeonly' are incompatible!
Attributes 'readonly and writeonly' are incompatible!
Attributes 'readnone and inaccessiblememonly' are incompatible!
-noSplitVariables
Attribute 'jumptable' requires 'unnamed_addr'
element size
Attributes 'inalloca and readonly' are incompatible!
-noAccSub
Attributes 'byval' and 'inalloca' do not support unsized types!
Attribute 'swifterror' only applies to parameters with pointer to pointer type!
thread_group_size
-noifcvt
 argument must refer to an integer parameter
swifterror value can only be loaded and stored from, or as a swifterror argument!
!prof annotations should have no less than 2 operands
-numGeneralAcc
second operand should not be null
expected integer argument to function_entry_count
Expected no forward declarations!
-unsafeMath
invalid expression
missing variable
invalid tag
-nosrc1byte
invalid scope
invalid base type
Simplify return types and bodies of dead visible functions
-noSamplerHeaderCache
class/union requires a filename
discriminator can only appear on variant part
invalid subroutine type ref
-ncstateless
invalid filename
invalid enum list
invalid retained type list
-enableBarrierInstCounterBits
invalid imported entity ref
invalid macro list
invalid subroutine type
-disableHFMath
invalid retained nodes, expected DILocalVariable or DILabel
-forceMixMode
sub_group_size
-nosends
invalid local scope
invalid scope ref
missing global variable name
-noLoadPayload
label requires a valid scope
invalid scope for imported entity
invalid macinfo type
-hasRNEandDenorm
function-local metadata not in basic block
function-local metadata used in wrong function
PHINode should have one entry for each predecessor of its parent basic block!
-alignBS
Operand is null
Found return instr that returns non-void in Function of void return type!
image1d
-printregusage
Invalid use of metadata!
Instruction referencing instruction not embedded in a basic block!
Instruction operands must be first-class values!
-nolocalra
Referring to a basic block in another function!
Referring to an argument in another function!
Cannot take the address of an inline asm!
-forcespills
invalid fpmath accuracy!
Ranges are only for loads, calls and invokes!
align applies only to pointer types
-abortonspill
align metadata value must be a power of 2!
alignment is larger that implementation defined limit
intel_reqd_sub_group_size
-nolocalBCR
It should have at least one range!
The lower limit must be an integer!
Range must not be empty!
-disableFlagSpillClean
dereferenceable, dereferenceable_or_null apply only to pointer types
dereferenceable, dereferenceable_or_null apply only to load instructions, use attributes for calls or invokes
dereferenceable, dereferenceable_or_null metadata value must be an i64!
-reserveR0
Indirectbr destinations must all have pointer type!
The unwind destination does not have an exception handling instruction!
Called function is not the same type as the call!
-enableGlobalScopeAnalysis
speculatable attribute may not apply to call sites
inalloca argument for call has mismatched alloca
image2d_msaa
-globalSendVarSplit
Function has token parameter but isn't an intrinsic
Return type cannot be token for indirect call!
Multiple funclet operand bundles
-forceremat
Intrinsic functions should never be defined!
Intrinsic has incorrect return type!
Intrinsic was not defined with variable arguments!
-reservedGRFNum
is_zero_undef argument of bit counting intrinsics must be a constant int
invalid llvm.dbg.declare intrinsic call 1
alignment of arg 1 of memory intrinsic must be 0 or a power of 2
-GRFNumToUse
constant length must be a multiple of the element size in the element-wise atomic memory intrinsic
-ratrace
PurgeMetaDataUtilsImport
-abortonspillthreshold
invalid arguments to llvm.prefetch
llvm.stackprotector parameter #2 must resolve to an alloca.
llvm.localescape used outside of entry block
-oldIPA
idx argument of llvm.localrecover must be a constant int
gc.statepoint support for inline assembly unimplemented
gc.result result type does not match wrapped callee
-noschedule
gc relocate should be linked to a statepoint
gc relocate is incorrectly tied to the statepoint
gc.relocate: statepoint base index out of bounds
-presched
gc.statepoint: mismatch in number of call arguments
gc.statepoint: number of transition arguments must be a constant integer
image2d_array
-presched-rp
eh.exceptionpointer argument must be a catchpad
masked_load: must return a vector
masked_load: pass through and data type must match
-dumpDagDot
masked_store: vector mask must be same length as data
experimental_guard cannot be invoked
experimental_deoptimize cannot be invoked
-debug-noDD
invalid arguments for constrained FP intrinsic
invalid exception behavior argument
 intrinsic address/value
-enable-noSrcDep
 intrinsic requires a !dbg attachment
mismatched subprogram between llvm.dbg.
PurgeMetaDataUtilsPass
-disable-noSrcDep-scen2
gc.statepoint number of patchable bytes must be a constant integer
gc.statepoint number of patchable bytes must be positive
gc.statepoint number of arguments to underlying call must be positive
-stop-noSrcDep-at
gc.statepoint flags must be constant integer
unknown flag used in gc.statepoint flags argument
gc.statepoint number of transition arguments must be constant integer
-nodpsendreorder
illegal use of statepoint token
gc.result or gc.relocate are the only value uses of a gc.statepoint
ResumeInst needs to be in a function with a personality.
-dontUseMultiThreadedLatencies
CatchReturnInst needs to be provided a CatchPad
CatchSwitchInst needs to be in a function with a personality.
sampler_t
-unifiedSendCycle
Block containing LandingPadInst must be jumped to only by the unwind edge of an invoke.
Block containg CatchPadInst must be jumped to only by its catchswitch.
A cleanupret must exit its cleanup
-noAtomicSend
Both operands to a binary operator are not of the same type!
Integer arithmetic operators only work with integral types!
Floating-point arithmetic operators only work with floating-point types!
-nocompaction
Shift return type must be same as operands!
Allocation instruction pointer not in the stack address space!
Load operand must be a pointer.
-IGAEncoder
Atomic load must specify explicit alignment
-output
14ocl_image1d
-symbolreg
Atomic store must specify explicit alignment
atomic store operand must have integer, pointer, or floating point type!
GEP into unsized type!
-binary
Vector GEP result width doesn't match operand's
Invalid GEP index vector width
fence instructions may only have acquire, release, acq_rel, or seq_cst ordering.
-dumpisavarnames
cmpxchg operand must have integer or pointer type
Expected value type does not match pointer operand type!
First atomicrmw operand must be a pointer.
-stripcomments
Trunc only operates on integer
Trunc only produces integer
double type is not supported on this platform
-numGenBinariesWillBePatched
SExt only operates on integer
SExt only produces an integer
FPToUI source and dest must both be vector or scalar
-outputCisaBinaryName
FPToSI source and dest must both be vector or scalar
FPToSI source must be FP or FP vector
FPToSI source and dest vector length mismatch
-asmNameUser
SIToFP source and dest must both be vector or scalar
SIToFP source must be integer or integer vector
FPTrunc only operates on FP
-encoderStatisticsFile
FPExt only operates on FP
FPExt only produces an FP
20ocl_image1d_array
-noverifyCISA
IntToPtr source must be an integral
IntToPtr result must be a pointer
AddrSpaceCast source must be a pointer
-rerapostschedule
CleanupPadInst needs to be in a function with a personality.
CleanupPadInst not the first non-PHI instruction in the block.
FuncletPadInst must not be nested within itself
-setA0toTdrForSendc
CatchPadInst needs to be directly nested in a CatchSwitchInst.
CatchPadInst not the first non-PHI instruction in the block.
Invalid predicate in ICmp instruction!
-setFFID
PHI nodes not grouped at top of basic block!
PHI nodes cannot have token type!
Address space alias analysis
-replaceIndirectCallWithJmpi
cannot guarantee tail call due to mismatched calling conv
cannot guarantee tail call due to mismatched ABI impacting function attributes
musttail call result must be returned
-setstartbp
Invalid extractelement operands!
Invalid insertelement operands!
Invalid ExtractValueInst operands!
-hashmovs
LandingPadInst not the first non-PHI instruction in the block.
Catch operand does not have pointer type!
all indices passed to llvm.localrecover must be less than the number of arguments passed ot llvm.localescape in the parent function
-easyisaasm
'common' global may not be in a Comdat!
-addKernelID
21ocl_image1d_buffer
-dumpPayload
Aliasee cannot be NULL!
Alias and aliasee types should match!
Aliases cannot form a cycle
-timestats
comdat global value has private linkage
invalid requirement on flag, flag is not present in module
incorrect number of operands in module flag
invalid value for 'require' module flag (expected metadata pair)
invalid value for 'require' module flag (first value operand should be a string)
wchar_size metadata requires constant integer argument
-platform
WorkaroundAnalysis Pass
USAGE: Directory to dump VISA passes into
igc-agg-arg-analysis
<MCOperand 
Resolve aggregate arguments
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
USAGE: -TotalGRFNum <regNum>
%.9lu
: for the -
 option: 
USAGE: -presched-ctrl <ctrl>
    =
 -   
USAGE: -noDD-lookback <NUM>
Generic Options
help-list
Display list of all available options
USAGE: -schedulerwindow <window-size>
print-options
Print non-default options after command line parsing
Print all option values after command line parsing
USAGE: -HWThreadNumberPerEU <num>
inconsistency in registered CommandLine options
Cannot specify more than one option with cl::ConsumeAfter!
' is all messed up!
USAGE: File Name with isaasm paths.
: Did you mean '-
ResolveAggregateArguments
USAGE: -asmNameUser <FILE>
: Too many positional arguments specified!
Can specify at most 
requires a value!
USAGE: -encoderStatisticsFile <reloc file>
not enough values!
' value invalid for floating point argument!
OVERVIEW: 
USAGE: File Name with isaasm paths. 
 <subcommand> -help" to get more help on a specific subcommand
USAGE: -hashmovs hi32 lo32
 version 
7.0.0
20ocl_image2d_array
USAGE: missing stepping string. 
 does not have an = in it
 is not a number
 is not a registered counter
Trip multiple is 
llvm.genx.GenISA.GradientX
Error
Multiple errors
simdMediaBlockRead@
Trying 'xdg-open' program... 
timers.
Running 'xdot.py' program... 
dot|fdp|neato|twopi|circo
-Nfontname=Courier
-Gsize=7.5,10
_ZnamSt11align_val_tRKSt9nothrow_t
.debug_ranges
Optimizer
HW_Conformity
llvm.genx.GenISA.IEEE.Sqrt
Misc_opts
  Graph Coloring
.apple_types
SmallVector capacity overflow during allocation
error: 
.debug_str_offsets
simdMediaRegionCopy@
armv3
armv3m
Scheduling
5TEJ
Compaction
VB_Append_Instruction
armv5te
armv6k
armv6t2
VB_Create_Operand
v6kz
armv6-m
armv7-a
liveness
v7ve
armv7e-m
7E-M
v7em
armv8.1-a
__builtin_IB_atomic_xchg_local_i32
Inliner for always_inline functions
__exp10l_finite
IGA_Encoding
__exp2l_finite
A No-Op Barrier Pass
__expl_finite
llvm.genx.GenISA.LocalIdLocation
__isoc99_sscanf
Try to propagate nonnull argument attributes from callsites to caller functions.
__log2_finite
storestructured1@
__log10l_finite
Stop inferring nounwind attribute during function-attrs pass
__logl_finite
section_str_off_dwo
.tls$
Deduce function attributes
__memset_chk
storestructured3@
__sinhl_finite
Dead Global Elimination
llvm.genx.GenISA.MediaBlockRead
Cannot initialize MC for non-Windows COFF object files.
__sqrt_finite
StringRef llvm::getTypeName() [DesiredTypeName = llvm::InnerAnalysisManagerProxy<FunctionAnalysisManager, Module>]
25ocl_image2d_array_msaa
Enable -time-passes memory tracking (this may be slow)
File to append -stats and -timer output to
Error opening info-output-file '
   --System Time--
Maximum block frequency, expressed as a percentage of caller's entry frequency, for a call site to be considered cold for enablingcoldcc
  --- Name ---
globalopt
__builtin_IB_atomic_min_local_u32
mach-o section specifier cannot have a stub size specified because it does not have type 'symbol_stubs'
aarch64_be
mips64
riscv64
.init
le64
amdil64
wasm64
darwin
dragonfly
fuchsia
isnull
netbsd
openbsd
haiku
malloc_ret_null
nvcl
next
contiki
amdpal
gnuabi64
Global Variable Optimizer
code16
eabi
__builtin_IB_atomic_max_global_u32
ipconstprop
uitof_rtn@
Function Integration/Inlining
free_it
thread_local_regular
cstring:"
std::string:"
formatv:"
inliner-function-import-stats
decUL:"
decL:"
vaBoolCentroid@
thread_local_init_function_pointers
pure_instructions
S_ATTR_PURE_INSTRUCTIONS
alnum
alpha
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
cntrl
Cannot find option named '
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
lower
print
NoDefinition
upper
0123456789ABCDEFabcdef
 will not be inlined into 
__builtin_IB_atomic_max_local_f32
NotInlined
vertical-tab
Inlined
carriage-return
 with cost=always
 (threshold=
__builtin_IB_atomic_and_local_i32
NeverInline
number-sign
dollar-sign
apostrophe
 because it should never be inlined (cost=never)
plus-sign
comma
hyphen-minus
 because too costly to inline (cost=
zero
five
IncreaseCostInOtherContexts
nine
colon
20ocl_image2d_depth
 increases the cost of inlining 
left-square-bracket
backslash
circumflex
parse
grave-accent
left-brace
Clear tessellation factors
irparse
__builtin_IB_atomic_xor_local_i32
llvm_regexec() failed to match
invalid regular expression
REG_ECOLLATE
invalid character class
REG_EESCAPE
invalid backreference number
write-relbf-to-summary
parentheses not balanced
REG_EBRACE
invalid repetition count(s)
Invalid encoding
out of memory
REG_BADRPT
REG_EMPTY
ThinLTO
invalid argument to regex routine
Unexpected anonymous function when writing summary
pseudo_kill
generic
write-bitcode
-%%%%%%
0123456789abcdef
-%%%%%%.
24IGIL_EnqueueKernelShared9ocl_queuejPvjS_S_jS_jiPi9ndrange_tii12ocl_clkevent
Default
Child timed out but wouldn't die
Child timed out
 (core dumped)
Size: 
posix_spawn failed
Couldn't fork
!DIGlobalVariableExpression(
disable-symbolication
operands: {
tag: 
DW_TAG_class_type
DW_TAG_enumeration_type
DW_TAG_formal_parameter
DW_TAG_lexical_block
Metadata: function = 
DW_TAG_compile_unit
DW_TAG_string_type
DW_TAG_subroutine_type
inalloca
14enqueue_marker9ocl_queuejPU3AS4K12ocl_clkeventPU3AS4S0_
cold
strdup
 instructions are compacted.
strcspn
dereferenceable
llvm.genx.GenISA.bfrev
DW_TAG_reference_type
DW_TAG_namelist_item
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_try_block
DW_TAG_variant_part
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_dwarf_procedure
DW_TAG_restrict_type
DW_TAG_interface_type
DW_TAG_imported_module
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_condition
DW_TAG_shared_type
DW_TAG_type_unit
DW_TAG_template_alias
DW_TAG_coarray_type
DW_TAG_generic_subrange
DW_TAG_dynamic_type
DW_TAG_atomic_type
DW_TAG_call_site
DW_TAG_call_site_parameter
DW_TAG_immutable_type
DW_TAG_MIPS_loop
DW_TAG_format_label
DW_TAG_class_template
DW_TAG_GNU_template_template_param
DW_TAG_GNU_template_parameter_pack
DW_TAG_GNU_call_site
DW_TAG_GNU_call_site_parameter
DW_TAG_APPLE_property
DW_TAG_BORLAND_property
DW_TAG_BORLAND_Delphi_string
DW_TAG_BORLAND_Delphi_dynamic_array
DW_TAG_BORLAND_Delphi_set
DW_AT_sibling
DW_AT_location
DW_AT_name
DW_AT_byte_size
DW_AT_bit_offset
DW_AT_bit_size
DW_AT_low_pc
DW_AT_high_pc
DW_AT_language
DW_AT_discr
DW_AT_discr_value
DW_AT_visibility
DW_AT_import
DW_AT_common_reference
DW_AT_comp_dir
DW_AT_const_value
DW_AT_default_value
DW_AT_inline
DW_AT_is_optional
DW_AT_producer
DW_AT_prototyped
DW_AT_return_addr
DW_AT_start_scope
DW_AT_bit_stride
DW_AT_upper_bound
DW_AT_abstract_origin
DW_AT_address_class
DW_AT_artificial
DW_AT_base_types
DW_AT_count
DW_AT_data_member_location
DW_AT_decl_column
DW_AT_decl_line
DW_AT_declaration
DW_AT_discr_list
DW_AT_encoding
DW_AT_external
DW_AT_frame_base
DW_AT_friend
DW_AT_macro_info
DW_AT_namelist_item
DW_AT_priority
DW_AT_specification
DW_AT_static_link
DW_AT_type
DW_AT_variable_parameter
DW_AT_virtuality
DW_AT_vtable_elem_location
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_byte_stride
DW_AT_use_UTF8
DW_AT_extension
DW_AT_ranges
DW_AT_call_column
DW_AT_call_file
DW_AT_call_line
DW_AT_binary_scale
DW_AT_decimal_scale
DW_AT_small
DW_AT_decimal_sign
DW_AT_digit_count
DW_AT_picture_string
DW_AT_mutable
DW_AT_explicit
DW_AT_object_pointer
DW_AT_endianity
DW_AT_pure
DW_AT_recursive
DW_AT_signature
DW_AT_data_bit_offset
DW_AT_const_expr
DW_AT_enum_class
DW_AT_linkage_name
DW_AT_string_length_bit_size
DW_AT_string_length_byte_size
DW_AT_rank
DW_AT_addr_base
DW_AT_rnglists_base
DW_AT_dwo_id
DW_AT_reference
DW_AT_rvalue_reference
DW_AT_macros
DW_AT_call_all_source_calls
DW_AT_call_all_tail_calls
DW_AT_call_return_pc
DW_AT_call_value
DW_AT_call_origin
DW_AT_call_parameter
DW_AT_call_pc
DW_AT_call_target
DW_AT_call_target_clobbered
DW_AT_call_data_location
DW_AT_noreturn
DW_AT_alignment
DW_AT_export_symbols
strncpy
inaccessiblememonly
strnlen
end of file in string constant
strndup
inlinehint
strtof
% instructions of this kernel are compacted.
llvm.genx.GenISA.cmpSADs
constant bigger than 64 bits detected!
declare
jumptable
strtoll
naked
strtoul
wait
!DIMacro(
nobuiltin
tanhl
llvm.genx.GenISA.createMessagePhases
system
noduplicate
tmpfile64
unnamed_addr
11read_imagef14ocl_image2d_ro11ocl_samplerDv2_fS1_S1
noinline
truncf
llvm.genx.GenISA.createMessagePhasesNoInitV
ungetc
nonlazybind
mem_fence
undef
utime
noredzone
valloc
utimes
nocf_check
vprintf
llvm.genx.GenISA.cycleCounter
fill
optnone
strcpy
wcslen
acquire
readnone
llvm.genx.GenISA.dp4a.ss
llvm.fabs.f32
returned
vsqrtf
vfloorf
signext
 fast
speculatable
11read_imagei14ocl_image2d_ro11ocl_samplerDv2_fS1_S1_
sret
vlogf
x86_stdcallcc
vlog10f
llvm.genx.GenISA.dp4a.us
x86_thiscallcc
vsinf
strictfp
vcosf
.lshr.outer.merge.hi
llvm.sin.f32
shadowcallstack
vasinf
llvm.genx.GenISA.eu.id
sanitize_hwaddress
 afn
 umin
vtanhf
sanitize_memory
 and
vatanhf
swiftself
__svml_sin4
llvm.genx.GenISA.eu.thread.pause
__svml_sin2
writeonly
__svml_sinf8
 preds = 
12read_imageui14ocl_image2d_ro11ocl_samplerDv2_fS1_S1_
opaque
 out of 
llvm.genx.GenISA.extractMVAndSAD
__svml_cos8
largest
thread_local(localdynamic) 
__svml_cosf16
samesize
__svml_pow2
 sub
webkit_jscc
llvm.cos.f64
__svml_powf4
llvm.genx.GenISA.fcmpxchgatomicraw
addrspace(
vexpm1f
flags
__svml_expf4
label%d
critical
R_WEBASSEMBLY_TABLE_INDEX_SLEB
R_WEBASSEMBLY_TABLE_INDEX_I32
R_WEBASSEMBLY_MEMORY_ADDR_I32
R_WEBASSEMBLY_TYPE_INDEX_LEB
typeCheckedLoadVCalls
typeTestAssumeConstVCalls
Use full module build paths in the profile counter names for static functions.
static-func-strip-dirname-prefix
Strip specified level of directory name from source path in the profile counter name for static functions.
HandleLoadStoreInstructionsPass
/AppleInternal/Library/BuildRoots/1db8ea6b-8e8d-11ee-9041-cedaeb4cabe2/Library/Caches/com.apple.xbs/Sources/GPUDriversIntel/igc/gfx-driver/Source/visa/iga/GEDLibrary/GED_internal/Source/ged/xcoder/ged_ins.cpp
MapRawBytes
 is not yet implemented
unsat
beforeRemoveUnreachableBlocks
mme1
mme3
mme4
mme7
nomme
MT0R_OWB
singleImpl
MT0R_BS
MT0_MEMFENCE
MT0W_DWS
uniformRetVal
MT1A_UI
MT1A_UI4x2
MT1R_TS
virtualConstProp
MT1A_TC
MT1A_TC4x2
MT1R_A64_US
fp128
MT1W_A64_B
MT1W_A64_US
__builtin_IB_atomic_max_local_f16
x86_mmx
MT2W_A64_US
MT2W_A64_SB
MT_CC_OWUB
zext
MT_SC_MB
MT_RSI
MT_RTR
store
MTW_MB
MTRW_TS
MT0W_US
Can't read textual IR with a Context that discards named Values
MT1A_A64_UF4x2
Scratch Block Read
__builtin_IB_atomic_and_local_i16
use of undefined type '%
Memory Fence
OWord Block Write
Byte Scattered Write
use of undefined comdat '$
Untyped Atomic Integer Operation SIMD4x2
Media Block Read
Typed Atomic Integer Operation
use of undefined metadata '!
Typed Atomic Counter Operation SIMD4x2
Typed Surface Write
A64 Untyped Atomic Integer Operation
use of undefined type id summary '^
A64 Untyped Surface Write
A64 Scattered Write
11read_imagei20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS2_
expected 'module asm'
Read Surface Info
Render Target Write
Untyped Atomic Operation
expected '=' after target triple
A64 Untyped Atomic Float Operation SIMD4x2
expected '=' after target datalayout
12read_imageui20ocl_image2d_array_ro11ocl_samplerDv4_fDv2_fS0_
expected '=' after source_filename
bits set in undefined field
unaligned_const_load_block
expected ']' at end of list
7043
const_load
LegacySimdMode
expected 'type' after '='
7028
aligned oword block read
store_block
expected 'type' after name
20862
7029
7033
variable expected to be numbered '%
7068
dword gathering read
7069
expected '=' here
sync_
synchronized 
__builtin_IB_atomic_inc_local_i16
expected comdat type
L1Flush
Flush L3
redefinition of comdat '$
 r/w data
 constant data
Expected '{' here
7049
hword scratch block read
ChannelMode
unexpected type in metadata definition
7031
unsupported dc0 op
__builtin_IB_atomic_dec_local_i16
Expected 'gv', 'module', or 'typeid' at the start of summary entry
7070
7073
a64 byte scattering with status return message
expected '(' at start of summary entry
a64 qword gathering read
a64 qword scattering write
7071
unexpected summary kind
7038
HWord aligned unsupported on this platform
7039
symbol with local linkage must have default visibility
 read
 write
11read_imagef26ocl_image2d_array_depth_ro11ocl_samplerDv4_fDv2_fS2_
invalid aliasee
 oword
 block
7118
explicit pointee type doesn't match operand's pointee type
a64 untyped atomic int32
DataWidth
redefinition of global '@
7137
untyped atomic int32
invalid type for global variable
mlen == 0 on write
 with vertical line stride 
__builtin_IB_atomic_cmpxchg_local_f16
expected global section string
7087
7090
7109
expected attribute group id
atomic 32-bit integer
7113
unsupported DC1 op
expected end of attribute group
urb dword 
masked 
44778
unterminated attribute group
unsupported URB op
URBOpcode
11read_imagef14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
invalid use of attribute on a function
wait for event
unsupported GTWY op
unknown render target op
global variable reference must have pointer type
FP32
FP16
.f32
' defined with type '
 SIMD16
.rep16
 of low SIMD8
expected integer
 SIMD8
.???
init_spinlock_var.start
expected localdynamic, initialexec or localexec
PerSamplePS
 with Per-Sample Pixel PS outputs enable
; last render target
expected '(' in address space
SLOTGRP_HI
 slot group high
invalid use of function-only attribute
simd32
invalid SIMD mode
simd16h
invalid use of attribute on return type
dso_location and DLL-StorageClass mismatch
11read_imagei14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
expected metadata after comma
sample compare+override LOD
sample_ld
sample gather4
huge alignments are not supported yet
sample res info
sample_info
sample_killpix
expected ')'
sample_gather4_po_c
sample gather4 pixel offset+compare
sample min
expected metadata or 'align'
sample compare+with lod forced to 0
sample_ld_lz
Break constant expressions into instruction sequences
'allocsize' indices can't refer to the same parameter
sample load multi-sample
sample_ld2ds
sample unorm
Expected synchronization scope name
sample deinterlace
sample_unorm_media
sample_unorm_killpix_media
Expected ordering on atomic instruction
sampler cache flush
SamplerMessageType
Mlen
expected ',' as start of index list
end of thread
unsupported TS op
12read_imageui14ocl_image3d_ro11ocl_samplerDv4_fS1_S1_
expected '>' at end of packed struct
4 OWords
8 OWords
this message requires a header (and it's absent)
basic block pointers are invalid
DataElements:MDC_DWS_DS
SimdMode:MDC_SM2
Header
pointer to this type is invalid
scratch
bti[
expected '*' in address space
DataElements:MDC_DS
DE1 (1 data element per addr.)
expected ',' in argument list
A32 
 (coherent stateless)
 (incoherent stateless)
non-musttail call
DataElements:MDC_DB_HW
untyped_load
channel mask must have one element not disabled
expected ')' at end of argument list
SimdMode:MDC_SM3
this message forbids a header (and it's included)
atomic_fmax
expected ',' in input list
fp-compare and swap 
expected '(' in operand bundle
12write_imagei14ocl_image3d_woDv4_iS0_
operand bundle set must not be empty
atomic_icas
64b integer compare and swap
atomic_or
invalid type for function argument
atomic_store
atomic_iinc
atomic_idec
argument name invalid in function type
integer add
atomic_isub
commuted integer subtract
redefinition of type
signed-integer min
atomic_umax
grid
expected '>' in packed struct
typed_load
typed_store
expected '}' at end of struct
invalid slot group value
SlotGroup:MDC_SG3
GlobalUrbOffset
expected 'x' after element count
included (two register header)
 HWords from scratch base
hword unaligned
zero element vector is illegal
Perform analysis and apply optimization to combine number of software threads
size too large for vector
// File: 
failed to allocate memory for kernel binary
MathFC
GED failed to create instruction template
ChannelOffset
use of undefined value '%
PredInv
FlagRegNum
AccWrCtrl
' is not a basic block
DstHorzStride
src0: unsupported type for ternary align1 encoding
Src1DataType
instructions returning void cannot have a name
Src0HorzStride
Src0RegFile
long long
instruction forward referenced with type '
MsgDesc
DescRegNum
DstChanEn
expected value token
dst region should be %s
DstRegNum
Src0AddrMode
expected end of packed struct
Src0AddrImm
Src1RegNum
constant vector must not be empty
ThreadCtrl
NoPreempt not supported on this platform (dropping)
12write_imagei20ocl_image2d_array_woDv4_iS0_
vector element #
uip label invalid
cyclic dependency
expected end of array constant
invalid field
invalid value
other error
array element #
Src1AddrMode
src%d: unexpected register on this platform
Src1AddrImm
expected comma in inline asm expression
invalid region width on src1
invalid region horizontal stride on src1
ImplicitGlobalId
expected '(' in block address expression
invalid region width on src0
invalid region horizontal stride on src0
Src0RepCtrl
expected ')' in block address expression
Src2DataType
Src2RepCtrl
Src2RegNum
cannot take blockaddress inside a declaration
src%d: math macro operands require Align16
referenced value is not a basic block
__builtin_IB_get_event_pool
snan
, rd:
, to 
invalid cast opcode for cast from '
:Type::INVALID
MathMacroExt::INVALID
expected '(' in extractvalue constantexpr
on <h> region v must be Region::VT_INVALID
InstOpt
extractvalue operand must be aggregate type
|ChannelOffset
]: #
__builtin_IB_get_parent_event
expected '(' in insertvalue constantexpr
12write_imagei16ocl_image2d_array_woDv4_iiS_
expected comma in insertvalue constantexpr
has reg descs
src0 must be GRF
dst must be null for store
descriptor SIMD size mismatches instruction ExecSize
invalid indices for insertvalue
src0 is null (doesn't fit operand mapping)
insertvalue operand and field disagree in type: '
a32o
a64o
scratch
double4
xga32
xsc32
compare operands must have the same type
ga32c
xbl256
xubl128
icmp requires pointer or integer operands
sbl256
expected comma in binary constantexpr
Analyzes device enqueue functions
operands of constexpr must have same type
HW64
nsw only applies to integer operations
HWSB(0x
ScratchOffset
CMask
constexpr requires fp operands
expected comma in logical constantexpr
CMask(0x
expected ')' in logical constantexpr
12write_imagei14ocl_image3d_woDv4_iiS_
constexpr requires integer or integer vector operands
expected '(' in constantexpr
GRAPH_COLORING_SPILL_FF_BC_RA
not a macro instruction
src type is not binary normal form
register regioning restriction warning: ExecSize * sizeof(Type) exceeds 2 GRF
see Programmer's Reference Manual (Restriction 1.1)
register regioning restriction warning: SIMD1 requires horizontal stride of 0 (scalar region access)
see Programmer's Reference Manual (Restriction 2.4)
base of getelementptr must be a pointer
GRAPH_COLORING_SPILL_FF_RA
ushort
null
Index
invalid getelementptr indices
Channel Enable
expected three operands to select
Control Register
Notification Register
invalid operands to shufflevector
Timestamp Register
invalid extractelement operands
Addition
TransformBlocksOutput
invalid insertelement operands
The and instruction performs component-wise logic AND operation between src0 and src1 and stores the results in dst.
Register source operands can use source modifiers:
[Pre-DevBDW]: Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the AND operation.
[DevBDW+]: Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a AND (NOT b) to be calculated with one instruction.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Format:
Source modifier is not allowed if source is an accumulator.
expected comdat variable
Bit Field Extract
Component-wise extract a bit field from src2 using the bit field width from src0 and the bit field offset from src1. Store the extracted bit field value in the low bits of dst and sign extend (if D type) or zero extend (if UD type).
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
If offset + width > 32 then the extracted bit field is bits offset to 31 of src2, extracting only 32 - offset bits, less than width as the bit field cannot extend past the MSB of the source value. Otherwise extract width bits extending from bit positions offset to offset + width - 1.
Format:
[(pred)] bfe (exec_size) dst src0 src1 src2
Bit Field Insert 1
comdat cannot be unnamed
bfrev
Bit Field Reverse
Branch Converging
expected metadata type
The brd instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if any channels are branched away.
In GEN binary, JIP is at location src1 when immediate and at location src0 when reg32, where reg32 is accessed as a scalar DWord. The ip register must be used (for example, by the assembler) as dst.
Format:
[(pred)] brd (exec_size) JIP
break
__get_kernel_work_group_size_impl
missing required field 'tag'
Call Absolute
The calla instruction jumps to a subroutine. It can be predicated or non-predicated. If non-predicated, all enabled channels jump to the subroutine. If predicated, only the channels enabled by PMask jump to the subroutine; the rest of the channels move to the next instruction after the calla instruction. If none of the channels jump into the subroutine, the calla instruction is treated as a nop.
In case of a jump, the call instruction stores the return IP onto the first DWord of the destination register and stores the CallMask in the second DWord of the destination register.
If SPF is ON, none of the PcIP are updated.
When SPF is on, the predication control must be scalar.
The difference between calla and call is that calla uses JIP as the IP value rather than adding it to the IP value.
Format: [(pred)] calla (exec_size) dst JIP
The cbit instruction counts component-wise the total bits set in src0 and stores the resulting counts in dst.
Format:
[(pred)] cbit (exec_size) dst src0
missing required field 'name'
cmpn
Compare NaN
cont
unsigned enumerator with negative value
The dim instruction moves the 64-bit immediate value into enabled channels of dst.
Format:
[(pred)] dim[.cmod] (exec_size) dst src0
missing required field 'types'
Dot Product 4
The dp4 instruction performs a four-wide dot product on four-tuple vector basis and storing the same scalar result per four tuple to all four channels in dst.
The dot product of two vectors of equal length is the sum of the products of each pair of corresponding elements.
Format:
[(pred)] dp4[.cmod] (exec_size) dst src0 src1
12DoMultiQueryPU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_samplerj
missing required field 'directory'
endif
End If
Half Precision Float to Single Precision Float
missing 'distinct', required for !DICompileUnit
The f32to16 instruction converts the single precision float in src0 to half precision float and storing in the lower word of each channel in dst.
Because this instruction does not have a 16-bit floating-point type, the destination data type must be Word (W).
Format:
[(pred)] f32to16[.cmod] (exec_size) dst src0
If src0 is unsigned, the fbh instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is signed and positive, the fbh instruction counts component-wise the leading zeros from src0 and stores the resulting counts in dst.
If src0 is signed and negative, the fbh instruction counts component-wise the leading ones from src0 and stores the resulting counts in dst.
Format:
[(pred)] fbh (exec_size) dst src0
If src0 is zero, store 0xFFFFFFFF in dst.
If src0 is signed and is -1 (0xFFFFFFFF), store 0xFFFFFFFF in dst.
missing required field 'file'
Fraction
The frc instruction computes, component-wise, the truncate-to-minus-infinity fractional values of src0 and stores the results in dst. The results, in the range of [0.0, 1.0], are the fractional portion of the source data. The result is in the range [0.0, 1.0] irrespective of the rounding mode. Floating-point fraction computation follows the rules in the following tables, based on the current floating-point mode.
Format:
[(pred)] frc[.cmod] (exec_size) dst src0
The halt instruction temporarily suspends execution for all enabled compute channels. Upon execution, the enabled channels are sent to the instruction at (IP + UIP), if all channels are enabled at HALT, jump to the instruction at (IP + JIP).
If the halt instruction is not inside any conditional code block, the values of JIP and UIP should be the same. If the halt instruction is inside a conditional code block, the UIP should be the end of the program and the JIP should be the end of the inner most conditional code block.
The UIP must point to a HALT Instruction.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 16-bit instruction pointer offsets. Both the JIP and UIP are signed 16-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at location src1 and must be of type W (signed word integer).
Format:
[(pred)] halt (exec_size) JIP UIP
missing required field 'discriminator'
illegal
Illegal
_Z38get_kernel_sub_group_count_for_ndrange
missing required field 'line'
The line instruction computes a component-wise line equation (v = p * u + q where u, v are vectors and p, q are scalars) of src0 and src1 and stores the results in dst. src1 is the input vector u. src0 provides input scalars p and q, where p is the scalar value based on the region description of src0 and q is the scalar value implied from src0 region. Specifically, q is the fourth component of the 4-tuple (128-bit aligned) that p belongs to.
Format:
[(pred)] line[.cmod] (exec_size) dst src0 src1
invalid DWARF op '
Multiply Accumulate
The mac instruction takes component-wise multiplication of src0 and src1, adds the results with the corresponding accumulator values, and then stores the final results in dst.
Format:
[(pred)] mac[.cmod] (exec_size) dst src0 src1
Multiply Accumulate High
element too large, limit is 
math
Extended Math Function
missing required field 'var'
missing required field 'expr'
37intel_work_group_vme_mb_multi_query_8PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
invalid metadata-value-metadata roundtrip
loop-distribute-non-if-convertible
__builtin_IB_simd_media_block_read_8_l
Address of 
functions are not values, refer to them as pointers
__builtin_IB_simd_media_block_write_4_h
be_sp
, Offsets={
invalid type for inline asm constraint string
, widest fixup type: 
---- AliasMap ----
, all-fixups-outside-loop
floating point constant invalid for type
 , add offset 
llvm.genx.GenISA.vaMinMax
__builtin_IB_simd_media_block_write_1_l
null must be a pointer type
LSR is examining the following fixup sites:
unexpected token in '.if' directive
The cost threshold for loop unrolling
invalid empty array initializer
' not defined
llvm.genx.GenISA.vmeSendFBR
unroll-max-percent-threshold-boost
invalid type for none constant
unroll-max-iteration-count-to-analyze
__builtin_IB_simd_media_block_write_4_l
The maximum 'boost' (represented as a percentage >= 100) applied to the threshold when aggressively unrolling a loop due to the dynamic cost savings. If completely unrolling a loop will reduce the total runtime from X to Y, we boost the loop unroll threshold to DefaultThreshold*std::min(MaxPercentThresholdBoost, X/Y). This limit avoids excessive code bloat.
initializer with struct type has wrong # elements
Use this unroll count for all loops including those with unroll_count pragma values, for testing purposes
unexpected token in '.ifdef'
37intel_work_group_vme_mb_multi_query_4PU3AS3jjjDv2_jDv2_iS2_14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
element 
Set the max unroll count for partial and runtime unrolling, fortesting purposes
__builtin_IB_simd_media_block_write_1_b
unroll-peel-count
expected a basic block
llvm.genx.GenISA.vmeSendIME
 levels deep.
Allows loops to be partially unrolled until -unroll-threshold loop size is reached.
invalid linkage for function declaration
Allow generation of a loop remainder (extra iterations) when unrolling a loop.
assembler local symbol '
unroll-allow-remainder
function expected to be numbered '%
unroll-max-upperbound
__builtin_IB_simd_media_block_write_4_b
llvm.genx.GenISA.vmeSendSIC2
expected '(' in function argument list
unexpected token in '.elseif' directive
missing value for required parameter '
If the runtime tripcount for the loop is lower than the threshold, the loop is considered as flat and will be less aggressively unrolled.
functions with 'sret' argument must return void
  Aliasee: 
__builtin_IB_simd_media_block_write_16_b
unroll-remainder
invalid forward reference to function '
unroll-revisit-child-loops
CatchAllDebugLine@
Allow the loop remainder to be unrolled.
expected '(' in binary constantexpr
invalid redefinition of function '
redefinition of function '@
41intel_work_group_vme_mb_multi_check_16x16PU3AS3jjjjDv2_ii14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
type of definition and forward reference of '@
GRAPH_COLORING_FF_BC_RA
DCL_DSInputTessFactor@
Unroll loops
redefinition of argument '%
__builtin_IB_media_block_write
alignment must be a power of 2
Unable to fully unroll loop as directed by unroll(full) pragma because loop has a runtime trip count.
function body requires at least one basic block
Unable to unroll loop the number of times directed by unroll_count pragma because remainder loop is restricted (that could architecture specific or because the loop contains a convergent instruction) and so must have an unroll count that divides the loop trip multiple of 
GRAPH_COLORING_FF_RA
DifferentUnrollCountFromDirected
expected '=' after instruction id
UnrollCount
DCL_GSinputVec@
__builtin_IB_sub_group_reduce_OpGroupSMax
found end of file when expecting more instructions
allow-unroll-and-jam
destination register ARF access requires {Switch} ThreadCtrl
Use this unroll count for all loops including those with unroll_and_jam_count pragma values, for testing purposes
expected fcmp predicate (e.g. 'oeq')
llvm.genx.GenISA.vaErode
expected icmp predicate (e.g. 'eq')
Preserve NAN (default false)
value doesn't match function result type '
ArgSize
branch condition must have 'i1' type
Total
SyncFC
unexpected padding at end of kernel
error decoding instruction (no compacted form)
GED error decoding instruction
expected ',' after switch condition
: invalid operation format
: invalid operation format
dst: unsupported Align16 ChEn; only <1> (.xyzw) supported
switch condition must have integer type
dst has wrong region for binary normal form
invalid reg file on dst
unsupported Align16 ternary destination for SIMD2 (must be .xywz or .{xy,zw} for :df)
duplicate case value in switch
Align16 branches not supported
dst: invalid math macro register (from ChEn)
%s: %s%d: invalid register number 
expected ',' after indirectbr address
swizzle Z could not be retrieved
swizzle W could not be retrieved
converted_ndrange
indirectbr address must have pointer type
src%d: inconvertible align16 operand
src%d: invalid addressing mode
src%d: macro instructions must be Align16 for this platform.
expected 'to' in invoke
expected 'unwind' in invoke
expected ChOff
expected )
expected '(' (start of execution size info)
unexpected operand type for send
argument is not of expected type '
expected constant integer expression
argument to operator must be integral
left operand to operator must be floating point (append a .0 to force floating point)
invoke instructions may not have an alignment
qnan
snan
bare qnan and snan tokens deprecated (pass in a valid payload)
expected 'from' after cleanupret
NoDDChk not supported on given platform
NoDDClr not supported on given platform
NoSrcDep not supported on given platform
expected 'caller' in cleanupret
Atomic mutually exclusive with NoPreempt
Compacted mutually exclusive with Uncompacted/NoCompact
Uncomapcted/NoCompact mutually exclusive with Compacted
expected 'to' in catchret
Q1 is obsolete; use M0 in execution offset: e.g. op (8|M0) ...
Q2 is obsolete; use M8 in execution offset: e.g. op (8|M8) ...
_local
expected scope value for catchswitch
N5 is obsolete; use M16 in execution offset: e.g. op (4|M16) ...
N6 is obsolete; use M20 in execution offset: e.g. op (4|M20) ...
expected ']' after catchswitch labels
default_execution_size
expected 'caller' in catchswitch
unexpected directive name
integer literal too large
on line 
expected scope value for catchpad
expected flag register
45intel_work_group_vme_mb_multi_bidir_check_8x8PU3AS3jjjjDv2_ihhS1_14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler
expected scope value for cleanuppad
conditional modifier follows execution mask info: e.g. op (16|M0)  (le)f0.0 ...
unexpected . (expected execution size)
invalid subfunction
invalid operand type for instruction
src0 must be a notification register
expected '\n', ';', or EOF
expected ]
instruction requires integer or integer vector operands
flag register must be same for predication and flag modifier
invalid destination register
expected address subregister
icmp requires integer operands
expected .
expected address register subregister
pointer_arg_map_buf
expected ',' after select condition
send operand subregisters have no effect and are deprecated syntax
send operand region has no effect and is deprecated syntax
expected math macro register (e.g. .mme0, ..., .mme7, or .nomme)
expected ',' after vaarg operand
acc4
acc5
acc7
expected ',' after extract value
this doesn't support regioning
unexpected |
source modifier unsupported on this op
expected ',' after shuffle mask
expected ;
expected ',' after shuffle value
52intel_sub_group_avc_ime_evaluate_with_dual_reference14ocl_image2d_ro14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
invalid shufflevector operands
subregister out of bounds
register access granularity too small type
immediate integer floating point literals must be in hex or binary (e.g. 0x7F800000:f)
expected ']' in phi value list
invalid send destination register
this form of indirect (r3[a0.0,16]) is invalid for send dst operand; use regular form: r[a0.0,16]
obj_id
'catch' clause has an invalid type
MergeURBWrites
igc-code-gen-context-wrapper
CodeGen Context Wrapper
out of dynamic memory in yy_scan_buffer()
bad buffer in yy_scan_bytes()
yyset_lineno called with no buffer
fatal error - scanner input buffer overflow
fast-math-flags specified for call without floating-point scalar or vector return type
scalarParamBuf
platform does not support packed (unary) send
unhandled ld/st operation kind
invalid address model for this message
invalid register range
malformed register range
surface offset
expected comma after load's type
surface index
expected surface index
invalid address model
atomic load must have explicit non-zero alignment
address range includes header (extra reg), but format does not allow for it
atomic load cannot use Release ordering
expected ',' after store operand
unknown error
out of memory
decode error
version mismatch
store operand must be a first class value
invalid error code
0.15.17
atomic store must have explicit non-zero alignment
atomic store cannot use Acquire ordering
cont
failed to allocate
ERROR: 
expected ',' after cmpxchg cmp operand
llvm.amdgcn.image.sample.c.b.o.3d
cmpxchg cannot be unordered
llvm.amdgcn.image.sample.c.cd.1d
cmpxchg failure argument shall be no stronger than the success argument
call
cmpxchg failure ordering cannot include release semantics
llvm.amdgcn.image.sample.c.cd.3d
cmpxchg operand must be a pointer
casted_ptr
compare value and pointer type do not match
llvm.amdgcn.image.sample.c.cd.cl.2darray
new value and pointer type do not match
goto
cmpxchg operand must be a first class value
64intel_sub_group_avc_ime_evaluate_with_single_reference_streamout14ocl_image2d_ro14ocl_image2d_ro11ocl_sampler33intel_sub_group_avc_ime_payload_t
expected binary operation in atomicrmw
__intel_calc_kernel_local_size_for_sub_group_count
expected ',' after atomicrmw address
llvm.amdgcn.image.sample.c.cd.cl.o.cube
atomicrmw cannot be unordered
atomicrmw operand must be a pointer
llvm.amdgcn.image.sample.c.cd.o.2d
atomicrmw value and pointer type do not match
__intel_calc_kernel_max_num_subgroups
atomicrmw operand must be an integer
llvm.amdgcn.image.sample.c.cl.1d
atomicrmw operand must be power-of-two byte-sized integer
pseudo_fret
fence cannot be unordered
64intel_sub_group_avc_ime_evaluate_with_single_reference_streamout14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t
fence cannot be monotonic
OpEnqueueKernel signature does not match
expected comma after insertvalue operand
llvm.amdgcn.image.sample.c.cl.o.2d
value has no uses
pseudo_fc_call
value only has one use
llvm.amdgcn.image.sample.c.cube
wrong number of indexes, expected 
invoke function should not be null
expected non-empty list of uselistorder indexes
llvm.amdgcn.image.sample.c.d.2darray
expected '}' here
sad2
expected >= 2 uselistorder indexes
expected distinct uselistorder indexes in range [0, size)
Fail parent kernel lookup: possible closed self-enqueue
expected uselistorder indexes to change the order
llvm.amdgcn.image.sample.c.d.cl.o.1d
expected uselistorder directive
expected comma in uselistorder directive
llvm.amdgcn.image.sample.c.d.cl.o.3d
expected comma in uselistorder_bb directive
_dispatch_
expected function name in uselistorder_bb
llvm.amdgcn.image.sample.c.d.o.1darray
invalid function forward reference in uselistorder_bb
invalid declaration in uselistorder_bb
62intel_sub_group_avc_ime_evaluate_with_dual_reference_streamout14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t
invalid numeric label in uselistorder_bb
capture
expected basic block name in uselistorder_bb
llvm.amdgcn.image.sample.c.l.2darray
invalid basic block in uselistorder_bb
line
expected basic block in uselistorder_bb
llvm.amdgcn.image.sample.c.l.o.1darray
expected ':' here
local_ptr
expected 'path' here
llvm.amdgcn.image.sample.c.l.o.cube
expected ',' here
expected 'hash' here
Output
expected 'name' here
.block_struct
expected 'summary' here
llvm.amdgcn.image.sample.c.lz.o.1darray
expected 'typeTestRes' here
pseudo_mad
expected 'kind' here
llvm.amdgcn.image.sample.c.lz.o.cube
unexpected TypeTestResolution kind
.block_descriptor
expected 'sizeM1BitWidth' here
llvm.amdgcn.image.sample.c.o.2darray
expected ':'
wait
expected optional TypeTestResolution field
63intel_sub_group_avc_ime_evaluate_with_single_reference_streamin14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
expected 'wpdResolutions' here
parent calls for invoke are not set
expected 'offset' here
llvm.amdgcn.image.sample.cd.cl.1d
expected 'wpdRes' here
sendc
unexpected WholeProgramDevirtResolution kind
llvm.amdgcn.image.sample.cd.cl.3d
expected optional WholeProgramDevirtResolution field
Fail parent call lookup: possible closed self-enqueue
expected 'byArg here
llvm.amdgcn.image.sample.cd.cl.o.2d
unexpected WholeProgramDevirtResolution::ByArg kind
sendsc
expected optional whole program devirt field
__private
expected 'args' here
unknown_type
expected name or guid tag
llvm.amdgcn.image.sample.cd.o.2darray
expected 'summaries' here
expected summary type
llvm.amdgcn.image.sample.cl.1darray
expected 'insts' here
llvm.loop.unroll.enable
expected optional function summary field
llvm.amdgcn.image.sample.cl.cube
expected 'aliasee' here
pseudo_restore_be_fp
expected ':' in funcFlags
61intel_sub_group_avc_ime_evaluate_with_dual_reference_streamin14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
expected '(' in funcFlags
llvm.loop.unroll.full
expected function flag type
llvm.amdgcn.image.sample.d.1d
expected ')' in funcFlags
pseudo_caller_restore
expected ':' in calls
llvm.amdgcn.image.sample.d.3d
expected '(' in calls
Disable loop unroll on retry
expected 'callee' in call
llvm.amdgcn.image.sample.d.cl.2darray
expected relbf
Find interesting constants
expected ')' in call
inline.visaasm
expected ')' in calls
igc-disable-loop-unroll
invalid call edge hotness
llvm.amdgcn.image.sample.d.cl.o.cube
expected ':' in refs
intrinsic
expected '(' in refs
llvm.amdgcn.image.sample.d.o.2d
expected ')' in refs
DisableLoopUnrollOnRetry
expected '(' in typeIdInfo
llvm.amdgcn.image.sample.l.1d
invalid typeIdInfo list type
pseudo_and
expected ')' in typeIdInfo
66intel_sub_group_avc_ime_evaluate_with_single_reference_streaminout14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t51intel_sub_group_avc_ime_single_reference_streamin_t
expected 'guid' here
block_motion_estimate_intel
expected 'linkage' here
llvm.amdgcn.image.sample.l.o.2d
expected 'notEligibleToImport' here
pseudo_xor
expected 'live' here
llvm.amdgcn.image.sample.lz.1d
expected 'dsoLocal' here
block_advanced_motion_estimate_check_intel
expected 'module' here
llvm.amdgcn.image.sample.lz.3d
expected module ID
gateway
expected GV ID
nounwind
expected type
block_advanced_motion_estimate_bidirectional_check_intel
expected field label here
llvm.amdgcn.image.sample.o.1d
column
scaled A64 scatter read
scope
llvm.amdgcn.image.sample.o.3d
inlinedAt
erode_2d_intel
invalid field '
llvm.amdgcn.image.store.2d
field '
scaled byte scattered read
' cannot be specified more than once
64intel_sub_group_avc_ime_evaluate_with_dual_reference_streaminout14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ime_payload_t49intel_sub_group_avc_ime_dual_reference_streamin_t
value for '
dilate_2d_intel
' too large, limit is 
llvm.amdgcn.image.store.mip.2d
' cannot be null
scaled A64 untyped surface write
llvm.amdgcn.implicit.buffer.ptr
header
min_filter_2d_intel
operands
llvm.amdgcn.interp.mov
expected DWARF tag
scaled byte scattede write
invalid DWARF tag
max_filter_2d_intel
' cannot be empty
llvm.amdgcn.loop
count
render target write
lowerBound
llvm.amdgcn.mqsad.pk.u16.u8
expected signed integer
convolve_2d_intel
' too small, limit is 
llvm.amdgcn.qsad.pk.u16.u8
value
unrecognized RT message
isUnsigned
52intel_sub_group_avc_ref_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_ref_payload_t
expected 'true' or 'false'
minmax_2d_intel
encoding
llvm.amdgcn.rsq.legacy
expected DWARF type attribute encoding
thread spawner
invalid DWARF type attribute encoding
llvm.amdgcn.s.dcache.wb
baseType
centroid_2d_intel
extraData
llvm.amdgcn.s.getreg
dwarfAddressSpace
oword block read
expected debug info flag
reqd_work_group_size(
invalid debug info flag flag '
bool_centroid_2d_intel
elements
llvm.amdgcn.sad.hi.u8
runtimeLang
oword dual block read
vtableHolder
llvm.amdgcn.sdot2
templateParams
bool_sum_2d_intel
identifier
llvm.amdgcn.sffbh
discriminator
unrecognized DCC message
expected DWARF language
54intel_sub_group_avc_ref_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ref_payload_t
invalid DWARF language
convolve_1d_intel
types
llvm.amdgcn.udot8
expected DWARF calling convention
hword aligned block read
invalid DWARF calling convention
llvm.amdgcn.workgroup.id.x
filename
convolve_pixel_intel
directory
UnifiedReturnBlock
checksumkind
igc-find-interesting-constants
checksum
source
lbp_image_intel
invalid checksum kind
llvm.arm.clrex
language
oword block write
producer
llvm.arm.crc32cw
isOptimized
lbp_correlation_intel
runtimeVersion
llvm.arm.dmb
splitDebugFilename
oword dual block write
emissionKind
54intel_sub_group_avc_sic_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_sic_payload_t
enums
floodfill_intel
retainedTypes
llvm.arm.ldc2
globals
byte scattered write
imports
llvm.arm.ldrexd
macros
correlation_search_intel
dwoId
llvm.arm.mcrr2
splitDebugInlining
scratch read
debugInfoForProfiling
intel_reqd_sub_group_size(
gnuPubnames
__builtin_IB_media_block_rectangle_read
expected emission kind
llvm.arm.neon.aesmc
invalid emission kind
dp_pi
linkageName
llvm.arm.neon.sha1m
isLocal
Analyzes extenstion functions arguments
isDefinition
llvm.arm.neon.sha256h
scopeLine
untyped surface read
containingType
52intel_sub_group_avc_sic_evaluate_with_dual_reference14ocl_image2d_roS_S_11ocl_sampler33intel_sub_group_avc_sic_payload_t
virtuality
igc-extension-arg-analysis
virtualIndex
llvm.arm.neon.vacge
thisAdjustment
untyped atomic operation simd4x2
unit
llvm.arm.neon.vcvtas
declaration
SIMD16 is expected
retainedNodes
llvm.arm.neon.vcvtfp2hf
thrownTypes
typed surface read
expected DWARF virtuality code
invalid DWARF virtuality code
ExtensionArgAnalysis
exportSymbols
llvm.arm.neon.vcvtps
expected DWARF macinfo type
typed atomic operation simd4x2
invalid DWARF macinfo type
llvm.arm.neon.vhsubs
configMacros
Resolves extension function
includePath
llvm.arm.neon.vld1x3
isysroot
untyped surface write
expr
igc-extension-funcs-resolution
setter
llvm.arm.neon.vld4
getter
atomic counter operation
entity
llvm.arm.neon.vmaxs
print-summary-global-ids
ExtensionFuncsResolution
Print the global id for each value when reading the module summary
llvm.arm.neon.vminu
Expected a single module
typed surface write
llvm.bitcode
vec_type_hint(
Corrupted bitcode
__builtin_IB_vme_mb_block_type
Abbreviation starts with an Array or a Blob
llvm.arm.neon.vpaddls
Array element type can't be an Array or a Blob
a64 untyped surface read
Array op not second to last
llvm.arm.neon.vpmins
Array element type has to be an encoding of a type
__builtin_IB_vme_subpixel_mode
Fixed or VBR abbrev record with size > MaxChunkData
llvm.arm.neon.vqaddu
Abbrev record with no operands
a64 untyped atomic operation simd4x2
Invalid abbrev number
_Z12get_local_idj
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._
__builtin_IB_vme_sad_adjust_mode
import-full-type-definitions
llvm.arm.neon.vqrshiftns
Import full type definitions for ThinLTO.
a64 block write
disable-ondemand-mds-loading
llvm.arm.neon.vqrshiftu
Force disable the lazy-loading on-demand of metadata when loading bitcode for importing.
__builtin_IB_vme_search_path_type
Corrupted Metadata block
llvm.arm.neon.vqshifts
Invalid metadata: fwd refs into function blocks
Find Interesting Constants
Invalid record: metadata strings layout
Invalid record: metadata strings with no strings
__builtin_IB_vme_helper_get_handle
Invalid record: metadata strings corrupt offset
llvm.arm.neon.vrhadds
Invalid record: metadata strings bad length
unrecognized DC1 message
Invalid record: metadata strings truncated chars
llvm.arm.neon.vrintn
Invalid metadata attachment
__builtin_IB_vme_helper_get_as
Conflicting METADATA_KIND records
llvm.arm.neon.vrshiftn
METADATA_NAME not followed by METADATA_NAMED_NODE
Invalid record: Unsupported version of DISubrange
__builtin_spirv_BuiltInSubgroupId
Alignment value is too large
Analyzes extension functions
Can't lazyload MD
llvm.arm.neon.vshiftu
Type mismatch in constant table!
llvm.global_ctors
llvm.arm.neon.vst1x4
llvm.global_dtors
igc-extension-funcs-analysis
Linking globals named '
llvm.arm.neon.vst3lane
': can only link appending global with another appending global!
 // 
Appending variables with different element types!
printf.strings
Appending variables linked with different const'ness!
ExtensionFuncsAnalysis
Appending variables with different alignment need to be linked!
llvm.arm.neon.vtbx2
Appending variables with different visibility need to be linked!
, msgLen=
Appending variables with different unnamed_addr need to be linked!
llvm.arm.qadd16
Appending variables with different section name need to be linked!
GenericAddressAnalysis
Linking two modules of different data layouts: '
llvm.arm.qsub
' is '
, barrier
' whereas '
Built-in function pass
Linking two modules of different target triples: 
GenericAddressDynamicResolution
.text
.balign 2
.thumb
llvm.arm.shadd16
.text
.balign 4
.arm
linking module flags '
llvm.arm.shsub16
': IDs have conflicting override values
LocalLoadBlock
': IDs have conflicting behaviors
llvm.arm.smlad
': IDs have conflicting values
': does not have the required value
vector
Linking COMDATs named '
GlobalPrivateLoadBlock
': invalid selection kinds!
llvm.arm.smlsd
': noduplicates has been violated!
': ExactMatch violated!
llvm.arm.smuad
': SameSize violated!
localLoad
': COMDAT key involves incomputable alias size.
llvm.arm.smultb
': GlobalVariable required for data dependent selection!
': symbol multiply defined!
Allocation failed
globalOrPrivateLoad
DFSIn: 
llvm.arm.ssat16
 DFSOut: 
Abstract Scope
llvm.arm.stc
Children ...
CmpWindowLowerBound
live-debug-variables
llvm.arm.stlex
Enable the live debug variables pass
Allocation failed
CodeGenPatternMatch
********** DEBUG VARIABLES **********
CmpWindowUpperBound
llvm.arm.uasx
 ind
llvm.arm.uhsax
 Loc
isPtrInWindow
llvm.arm.uqadd16
 @[ 
use-segment-set-for-physregs
PreBIImportAnalysis
Use segment set for the computation of the live ranges of physregs.
localWindowEnd
********** MACHINEINSTRS **********
llvm.arm.usat
EMPTY
Align1, 
-phi
llvm.arm.usub8
Resolves image height, width, depth functions
 weight:
UnifiedRetVal
Clean updater: 
dynamic texture folding
Null updater.
CC Tuple
 updater with gap = 
igc-image-func-resolution
, last start = 
llvm.hexagon.A2.add
  Area 1:
null
  Spills:
llvm.hexagon.A2.addh.h16.ll
  Area 2:
ImageFuncResolution
%08X
llvm.hexagon.A2.addh.h16.sat.ll
acc0
  Alive in blocks: 
__enqueue_kernel_basic
  Killed by:
__builtin_IB_get_image_height
 No instructions.
llvm.hexagon.A2.addsat
    #
regalloc=... not currently supported with -O0
llvm.hexagon.A2.andp
Live Variable Analysis
__builtin_IB_get_image_width
livevars
llvm.hexagon.A2.combine.hl
Can't print out MachineBasicBlock because parent MachineFunction
dbg0
 is null
PrimIdLocation
__builtin_IB_get_image_depth
<ir-block badref>
llvm.hexagon.A2.maxup
%ir-block.
address-taken
llvm.hexagon.A2.minup
landing-pad
__builtin_IB_get_image_num_mip_levels
align 
llvm.hexagon.A2.not
; predecessors: 
__enqueue_kernel_events_vaargs
successors: 
__builtin_IB_get_image_channel_data_type
0x%08x
llvm.hexagon.A2.sath
%.2f%%
liveins: 
llvm.hexagon.A2.subh.h16.hh
__builtin_IB_get_image_channel_order
llvm.hexagon.A2.subh.h16.sat.hh
; Irreducible loop header weight: 
%bb.
%08X
__builtin_IB_get_image_srgb_channel_order
view-machine-block-freq-propagation-dags
llvm.hexagon.A2.subp
Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.
do not display graphs.
llvm.hexagon.A2.svaddhs
fraction
__builtin_IB_get_image_array_size
display a graph using the fractional block frequency representation.
llvm.hexagon.A2.svnavgh
integer
display a graph using the raw integer fractional block frequency representation.
enqueue_IB_kernel
display a graph using the real profile count if available.
__builtin_IB_get_image_num_samples
view-block-layout-with-bfi
llvm.hexagon.A2.tfr
Pop up a window to show a dag displaying MBP layout and associated block frequencies of the CFG.
print-machine-bfi
llvm.hexagon.A2.tfrpi
Print the machine block frequency info.
__builtin_IB_get_address_mode
static-likely-prob
llvm.hexagon.A2.vabsw
branch probability threshold in percentageto be considered very likely
profile-likely-prob
DiscardRet
branch probability threshold in percentage to be considered very likely when profile is available
Analyzes image height, width, depth functions
verify-machine-dom-info
llvm.hexagon.A2.vaddw
Verify machine dominator info (time consuming)
.noacc
=============================--------------------------------
llvm.hexagon.A2.vavghr
Inorder Dominator Tree: 
igc-image-func-analysis
DFSNumbers invalid: 
llvm.hexagon.A2.vavguhr
 slow queries.
cl::location(x) specified more than once!
 <<exit node>>
ImageFuncsAnalysis
llvm.hexagon.A2.vcmpheq
Frame Objects:
Base=
  fi#
llvm.hexagon.A2.vcmpwgt
-ExtSLM
dead
llvm.hexagon.A2.vmaxh
variable sized
igc-dynamic-texture-folding
size=
CC Tuple list: 
, align=
localToChar
, fixed
llvm.hexagon.A2.vminuh
, at location [SP
.declare 
align-all-functions
llvm.hexagon.A2.vnavghcr
Force the alignment of all functions.
movedLocal
no-realign-stack
llvm.hexagon.A2.vnavgwr
# Machine code for function 
Base=a
Function Live Ins: 
Loop Gating Optimization
 in 
charToLocal
# End machine code for function 
llvm.hexagon.A2.vsubub
 ElementSize=
Jump Tables:
llvm.hexagon.A2.vsubws
Constant Pool:
GenSLM.LocalMemPoolOnGetMemPoolPtr
  cp#
llvm.hexagon.A2.zxth
FailedISel
 size=
IsSSA
Pixel shader lowering pass
Legalized
mempoolcast
NoPHIs
llvm.hexagon.A4.cmpbgt
NoVRegs
 alias=
RegBankSelected
llvm.hexagon.A4.cmpheq
Selected
localSLM
TracksLiveness
llvm.hexagon.A4.cmphgtu
Allocation failed
 align=
%jump-table.
GatingSimilarSamples
MachineFunction Printer
Resolve inline local variables/buffers
llvm.hexagon.A4.ornp
frame-setup 
llvm.hexagon.A4.rcmpneqi
frame-destroy 
igc-resolve-inline-locals
nnan 
llvm.hexagon.A4.round.rr.sat
ninf 
nsz 
CC Tuple list end. 
arcp 
InlineLocalsResolutionPass
contract 
llvm.hexagon.A4.vcmphgti
afn 
 (spilled)
reassoc 
llvm.hexagon.A4.vcmpwgtui
UNKNOWN
Analyzes OpenCL printf calls
 [sideeffect]
llvm.hexagon.A4.vrmaxw
 [mayload]
 Input_Output
 [maystore]
igc-conv-ocl-to-common
 [isconvergent]
igc-opencl-printf-analysis
 [alignstack]
llvm.hexagon.C2.all8
 [attdialect]
 Output
 [inteldialect]
llvm.hexagon.C2.bitsclr
:[reguse
OpenCLPrintfAnalysis
:[regdef
llvm.hexagon.C2.cmpeqi
:[regdef-ec
:[clobber
This is the pixel shader lowering pass 
:[imm
write_offset
:[mem
llvm.hexagon.C2.cmpgtui
:[??
wany4h
llvm.hexagon.C2.mask
end_offset
llvm.hexagon.C2.muxri
any2h
CoordZ
buffer_ptr
llvm.hexagon.C2.vmux
any8h
llvm.hexagon.C4.and.or
bblockJoin
Dynamic Texture Folding
coalesce moves coming payloads, insert and extract element
write_offset_true
llvm.genx.GenISA.floatatomicrawA64
write_offset_false
llvm.genx.GenISA.floatatomicstructured
Cycle found in TBAA metadata.
write_offset_ptr
 tiedto:$
Type-Based Alias Analysis
 debug-location 
llvm.genx.GenISA.flushsampler
 :: 
image2d_array_msaa_depth_t
 line no:
write_error_string
 indirect
Loop at depth 
llvm.genx.GenISA.fma.rtz
 containing: 
notconstant<
<header>
bblockFalseJoin
<latch>
typeTests: (
<exiting>
llvm.genx.GenISA.fsat
print-regmask-num-regs
Number of registers to limit to when printing regmask operands in IR dumps. unlimited = -1
printf_ret_val
%subreg.
constantrange<
target-flags(
llvm.genx.GenISA.ftof.rtn
<unknown>) 
LLVM_OVERRIDE_PRODUCER
<unknown target flag>
to_float
<unknown bitmask target flag>
Unable to determine comdat of alias!
<mcsymbol 
llvm.genx.GenISA.ftof.rtp
%fixed-stack.
%stack.
ptrBC
<badref>
input module has no datalayout
implicit-def 
llvm.genx.GenISA.ftof.rtz
implicit 
CoalescingEngine
def 
Resolves OpenCL printf calls
internal 
__lshrdi3
dead 
llvm.genx.GenISA.ftoi.rte
killed 
undef 
igc-opencl-printf-resolution
early-clobber 
__lshrsi3
debug-use 
llvm.genx.GenISA.ftoi.rtn
renamable 
__mulqi3
.subreg
OpenCLPrintfResolution
(tied-def 
inaccessiblemem_or_argmemonly
%const.
llvm.genx.GenISA.ftoi.rtp
target-index(
bool
<unknown>
OCL IGC-Internal-ERRORERROR!!!: Non-OCL is not supposed to reach here!
__mulhi3
blockaddress(
llvm.genx.GenISA.ftoui.rte
<regmask
__divqi3
 and 
Resolves private memory allocation
 more...
__divsi3
 ...
llvm.genx.GenISA.ftoui.rtn
liveout(
<cfi directive>
igc-private-mem-resolution
intrinsic(@
__divhi3
intrinsic(
llvm.genx.GenISA.ftoui.rtp
pred(
__udivdi3
volatile 
PrivateMemoryResolution
non-temporal 
__lshrhi3
dereferenceable 
llvm.genx.GenISA.gather4Cptr
invariant 
Analyzes the presence of private memory allocation
load 
__udivti3
store 
sample multiversioning
 on 
.hoist
 from 
igc-private-mem-usage-analysis
 into 
__umoddi3
stack
llvm.genx.GenISA.gather4POptr
none
jump-table
PrivateMemoryUsageAnalysis
constant-pool
__umodsi3
call-entry 
llvm.genx.GenISA.gather4ptr
call-entry &
__addxf3
custom 
Creates annotations for OpenCL program-scope structures
, align 
^arm\.neon\.vld([1234]|[234]lane)\.v[a-z0-9]*$
, !tbaa 
llvm.genx.GenISA.getEnqueuedLocalSize
, !alias.scope 
image2d_msaa_depth_t
, !noalias 
igc-programscope-constant-analysis
, !range 
__addtf3
, addrspace 
llvm.genx.GenISA.getGlobalSize
same_value 
__mulsf3
remember_state 
ProgramScopeConstantAnalysisPass
restore_state 
__mulxf3
offset 
llvm.genx.GenISA.getGridOrigin
def_cfa_register 
def_cfa_offset 
def_cfa 
__muldf3
rel_offset 
llvm.genx.GenISA.getGridSize
adjust_cfa_offset 
__divtf3
restore 
cast
escape 
__umodhi3
0x%02x
llvm.genx.GenISA.getGroupId
undefined 
SurfaceUsage
register 
Resolves references to inline constants
window_save 
__gcc_qdiv
<unserializable cfi directive>
llvm.genx.GenISA.getLocalId
%dwarfreg.
code sinking
<badreg>
igc-programscope-constant-resolve
syncscope("
__gcc_dtoq
llvm.genx.GenISA.getLocalSize
not_atomic
SLMSize
consume
ProgramScopeConstantResolutionPass
%ir.
__gcc_stoq
enable-subreg-liveness
llvm.genx.GenISA.getMessagePhase
Enable subregister liveness tracking.
__gnu_f2h_ieee
TargetCustom
Replace calls to instrinsics which are not supported by the codegen
FixedStack
Invalid ABI alignment, must be a 16bit integer
Stack
llvm.genx.GenISA.getMessagePhaseV
FESPSize
JumpTable
igc-replace-unsupported-intrinsics
ConstantPool
__truncdfhf2
GlobalValueCallEntry
llvm.genx.GenISA.getMessagePhaseX
ExternalSymbolCallEntry
__truncxfdf2
stress-regalloc
memcpy_vsrc
llvm.genx.GenISA.gather4POCptr
Limit all regclasses to N registers
llvm.genx.GenISA.getMessagePhaseXV
join-liveintervals
Coalesce copies (default=true)
memcpy_vdst
terminal-rule
__trunctfdf2
Apply the terminal rule
llvm.genx.GenISA.getSR0
join-splitedges
__fixdfdi
Coalesce copies on split edges (default=subtarget)
memcpy
join-globalcopies
__powitf2
Coalesce copies that span blocks (default=subtarget)
llvm.genx.GenISA.getSimdGroupSize
verify-coalescing
DIFlagFwdDecl
Verify machine instrs before and after register coalescing
memcpy_src
Data
be_fp
Anti
igc-sample-multiversioning
Out 
CodeHoisting
Ord 
memcpy_dst
 Latency=
__fixunssfdi
 Reg=
llvm.genx.GenISA.hw.thread.id
 Barrier
_AUTO_LABEL_
 Memory
memcpy_rem
 Artificial
__fixunssfsi
 Weak
llvm.genx.GenISA.ibfe
 Cluster
__fixunsxfdi
EntrySU
ExitSU
DIFlagVirtualInheritance
llvm.genx.GenISA.icmpxchgatomicraw
  # preds left       : 
image2d_depth_t
  # succs left       : 
.post
  # weak preds left  : 
__fixunsxfti
  # weak succs left  : 
llvm.genx.GenISA.icmpxchgatomicrawA64
  # rdefs left       : 
__floatsitf
  Latency            : 
.body
  Depth              : 
__floatdisf
  Height             : 
llvm.genx.GenISA.icmpxchgatomictyped
  Predecessors:
variable
  Successors:
Scoreboard:
__gcc_itoq
%bb.
llvm.genx.GenISA.imulH
__floattixf
Berd
memset_vdst
invalid
__gcc_qtou
stackmap-version
llvm.genx.GenISA.intatomicraw
Specify the stackmap encoding version (default = 3)
typeCheckedLoadConstVCalls
disable-sched-hazard
memset
Disable hazard detection during preRA scheduling
__floattitf
$noreg
llvm.genx.GenISA.intatomicrawA64
Code Hoisting
physreg
memset_dst
:sub(
__floatunditf
schedmodel
llvm.genx.GenISA.intatomictyped
Use TargetSchedModel for latency lookup
allOnes
scheditins
memset_rem
Use InstrItineraryData for latency lookup
__floatundixf
Remove unreachable machine basic blocks
llvm.genx.GenISA.is.uniform
unreachable-mbb-elimination
__eqdf2
memmove.post
0.41 (982f76f)
llvm.genx.GenISA.itof.rtn
before_doCFGStructurizer
i128
memmove.true
__eqtf2
llvm.genx.GenISA.itof.rtp
__gedf2
memmove.false
f128
__gcc_qge
ppcf128
llvm.genx.GenISA.itof.rtz
isVoid
beforeProcessGoto
memmmove
glue
__getf2
x86mmx
llvm.genx.GenISA.ldmcsptr
v1i1
__ledf2
v2i1
memmove
v4i1
llvm.genx.GenISA.globalSync
v8i1
llvm.genx.GenISA.ldmsptr
v16i1
__EXIT_BB
v32i1
ReplaceUnsupportedIntrinsics
v64i1
__letf2
v128i1
Sample Multiversioning
v512i1
Collect GS Properties
v1024i1
Allocates UAV and SRV numbers to kernel arguments
v1i8
__gcc_qunord
v2i8
llvm.genx.GenISA.ldptr
v4i8
LABEL__EMPTYBB__
v8i8
igc-resource-allocator
v16i8
__unordtf2
v32i8
llvm.genx.GenISA.ldraw.indexed
v64i8
__llvm_memmove_element_unordered_atomic_1
v128i8
ResourceAllocatorPass
v256i8
extractelement
v1i16
llvm.genx.GenISA.ldrawvector.indexed
v2i16
image2d_array_depth_t
v4i16
Set llvm fast math flags according to compiler options
v8i16
__llvm_memmove_element_unordered_atomic_2
v16i16
llvm.genx.GenISA.ldstructured
v32i16
__llvm_memset_element_unordered_atomic_8
v64i16
igc-set-fast-math-flags
v128i16
_Unwind_Resume
v1i32
llvm.genx.GenISA.lodptr
v2i32
v4i32
SetFastMathFlags
v8i32
__llvm_memset_element_unordered_atomic_16
v16i32
llvm.genx.GenISA.memoryfence
v32i32
__sync_lock_test_and_set_1
v64i32
__builtin_IB_sub_group_barrier
v1i64
__unorddf2
v2i64
llvm.genx.GenISA.mov.identity
v4i64
%s.%03d.%s.dump
v8i64
__builtin_IB_get_simd_size
v16i64
__sync_lock_test_and_set_2
v32i64
llvm.genx.GenISA.movcr
v1i128
collectgeometryshaderproperties
v1f32
__builtin_IB_get_simd_id
v2f32
__sync_fetch_and_sub_1
v2f16
llvm.genx.GenISA.movflag
v4f16
Preds: 
v8f16
__builtin_IB_simd_shuffle
v4f32
__sync_fetch_and_add_16
v8f32
llvm.genx.GenISA.mul.pair
v16f32
__sync_fetch_and_and_2
v1f64
__builtin_IB_simd_shuffle_us
v2f64
expected '=' after deplibs
v4f64
llvm.genx.GenISA.mul.rtz
v8f64
%s.%03d.%s.dot
Metadata
__builtin_IB_simd_shuffle_f
Untyped
__sync_fetch_and_and_4
ExceptRef
llvm.genx.GenISA.pair.to.ptr
disable-demotion
__sync_fetch_and_or_16
Clone multicolor basic blocks but do not demote cross scopes
__builtin_IB_simd_shuffle_h
disable-cleanups
__fixtfti
Do not remove implausible terminators or other similar cleanups
llvm.genx.GenISA.patchInstanceId
demote-catchswitch-only
Demote catchswitch BBs only (for wasm EH)
__builtin_IB_simd_shuffle_b
adce-remove-control-flow
__sync_fetch_and_xor_1
adce-remove-loops
llvm.genx.GenISA.ptr.to.pair
adce
__sync_fetch_and_nand_4
Aggressive Dead Code Elimination
__builtin_IB_simd_shuffle_df
callsite-splitting-duplication-threshold
__sync_fetch_and_add_8
Only allow instructions before a call, if their cost is below DuplicationThreshold
llvm.genx.GenISA.readsurfaceinfoptr
consthoist-with-block-frequency
// Setup
Enable the use of the block frequency analysis to reduce the chance to execute const materialization more frequently than without hoisting.
__builtin_IB_simd_shuffle_down
Simple constant propagation
size = "80.0, 
constprop
handling and lowering for data available across functions and dylibs
cvp-dont-process-adds
CollectGeometryShaderProperties
Value Propagation
__builtin_IB_simd_shuffle_down_us
correlated-propagation
__sync_fetch_and_umax_4
.lhs.trunc
llvm.genx.GenISA.rsq
.rhs.trunc
Dead Code Elimination
__builtin_IB_simd_shuffle_down_uc
enable-dse-partial-overwrite-tracking
__sync_fetch_and_umax_2
Enable partial-overwrite tracking in DSE
llvm.genx.GenISA.sampleBCptr
enable-dse-partial-store-merging
__sync_fetch_and_min_8
Enable partial store merging in DSE
__builtin_IB_simd_block_read_1_global
expected end of metadata node
Dead Store Elimination
llvm.genx.GenISA.sampleBptr
early-cse
kernel_arg_access_qual
Controls which instructions are removed
__builtin_IB_simd_block_read_2_global
Early CSE
__sync_fetch_and_min_16
Early CSE w/ MemorySSA
llvm.genx.GenISA.sampleCptr
early-cse-memssa
__atomic_load_1
__Buffer_Typed_DIM_Resource
__builtin_IB_simd_block_read_4_global
__1D_DIM_Resource
__atomic_load_4
__1D_ARRAY_DIM_Resource
llvm.genx.GenISA.sampleDCptr
__2D_DIM_Resource
 [shape=plaintext, label=<
__2D_ARRAY_DIM_Resource
__builtin_IB_simd_block_read_8_global
__3D_DIM_Resource
__atomic_load_2
__Cube_DIM_Resource
llvm.genx.GenISA.sampleDptr
__Cube_ARRAY_DIM_Resource
__atomic_store_4
__builtin_IB_simd_block_read_1_global_h
__sync_fetch_and_umax_1
Warning: File name not specified with the -dump-opt-llvm option.
llvm.genx.GenISA.sampleKillPix
Old LLVM IR (possibly from legacy binary) :  not supported!
<TR><TD ALIGN="CENTER">
<origin>
__builtin_IB_simd_block_read_2_global_h
Parsing llvm module failed!
__atomic_store_8
-cmc
llvm.genx.GenISA.sampleLCptr
-instcombine-code-sinking=0
twoScalar
__builtin_IB_simd_block_read_4_global_h
gpu_64-applecl-macosx
__atomic_compare_exchange_1
runtime.cligc64.bc
llvm.genx.GenISA.sampleLptr
<TR><TD>
__builtin_IB_simd_block_read_8_global_h
Error loading the Generic builtin resource
__atomic_compare_exchange
Error lazily loading bitcode for generic builtins,is bitcode the right version and correctly formed?
llvm.genx.GenISA.sampleinfoptr
Error loading the Generic builtin module from buffer
__atomic_fetch_add_2
ci-15.36-xxxxx
__builtin_IB_simd_block_read_16_global_h
vector
forward reference and definition of alias have different types
-cl-replace-global-offsets-by-zero
llvm.genx.GenISA.sampleptr
-cl-kernel-debug-enable
black
-cl-include-sip-csr
__builtin_IB_simd_block_read_1_global_b
-cl-include-sip-kernel-debug
__atomic_fetch_add_4
-cl-include-sip-kernel-local-debug
llvm.genx.GenISA.setMessagePhase
-cl-intel-use-32bit-ptr-arith
__atomic_fetch_sub_16
-cl-intel-greater-than-4GB-buffer-required
__builtin_IB_simd_block_read_2_global_b
-cl-intel-has-buffer-offset-arg
__atomic_fetch_and_2
-cl-intel-gtpin-rera
llvm.genx.GenISA.setMessagePhaseV
-cl-intel-no-prera-scheduling
-cl-intel-use-bindless-buffers
__builtin_IB_simd_block_read_4_global_b
-cl-intel-use-bindless-images
__atomic_fetch_and_1
-cl-fp32-correctly-rounded-divide-sqrt
llvm.genx.GenISA.setMessagePhaseX
-cl-no-subgroup-ifp
__atomic_fetch_or_4
-cl-uniform-work-group-size
__builtin_IB_simd_block_read_8_global_b
compilation error
llvm.genx.GenISA.resinfoptr
 -filetype=spv
llvm.genx.GenISA.setMessagePhaseXV
 -platform=
    </TABLE>
-dumpvisa
__builtin_IB_simd_block_read_16_global_b
 -dumpvisa
__atomic_fetch_or_8
global-data-resolution-pass
basic_string
chunkPtr
SmallVector capacity overflow during allocation
__builtin_IB_simd_block_read_1_global_l
Allocation failed
bindless_image3d_t
float2int-max-integer-bw
llvm.genx.GenISA.setMessagePhase.legacy
Max integer bitwidth to consider in float2int(default=64)
    </TABLE>>];
Base: 
__builtin_IB_simd_block_read_2_global_l
 Offset: 
 -> 
 Length: 
llvm.genx.GenISA.simdBlockRead
enable-pre
enable-load-pre
__builtin_IB_simd_block_read_4_global_l
max-recurse-depth
invalid hexadecimal floating-point constant: expected at least one significand digit
Max recurse depth (default = 1000)
llvm.genx.GenISA.simdBlockReadBindless
read
__builtin_IB_simd_block_read_8_global_l
.pre
.pre-phi
llvm.genx.GenISA.simdBlockWrite
LoadClobbered
invalid decimal number
load of type 
__builtin_IB_simd_block_write_1_global
Type
invalid use of parameter-only attribute
 not eliminated
llvm.genx.GenISA.simdBlockWriteBindless
 in favor of 
//.platform 
OtherAccess
__builtin_IB_simd_block_write_2_global
 because it is clobbered by 
invalid hexadecimal number
ClobberedBy
llvm.genx.GenISA.simdGetMessagePhase
LoadElim
highest
 eliminated
__builtin_IB_simd_block_write_4_global
InfavorOfValue
asm-macro-max-nesting-depth
Global Value Numbering
llvm.genx.GenISA.simdGetMessagePhaseV
LoadPRE
//.CISA version 
load eliminated by PRE
__builtin_IB_simd_block_write_8_global
gvn-max-hoisted
tlsgd
Max number of instructions to hoist (default unlimited = -1)
llvm.genx.GenISA.simdLaneId
gvn-hoist-max-bbs
Constant Coalescing
Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)
__builtin_IB_simd_block_write_1_global_h
gvn-hoist-max-depth
.set
Hoist instructions from the beginning of the BB up to the maximum specified depth (default = 100, unlimited = -1)
llvm.genx.GenISA.simdMediaBlockRead
gvn-hoist-max-chain-length
//.instCount 
Maximum length of dependent chains to hoist (default = 10, unlimited = -1)
__builtin_IB_simd_block_write_2_global_h
invalid reassignment of non-absolute variable '
.sink
llvm.genx.GenISA.simdMediaBlockWrite
irce-loop-size-cutoff
.byte
irce-print-changed-loops
__builtin_IB_simd_block_write_4_global_h
irce-print-range-checks
dereferenceable bytes must be non-zero
irce-max-exit-prob-reciprocal
llvm.genx.GenISA.simdMediaRegionCopy
irce-skip-profitability-checks
//.GRF count 
irce-allow-unsigned-latch
__builtin_IB_simd_block_write_8_global_h
InductiveRangeCheck:
.short
  Kind: 
llvm.genx.GenISA.simdSetMessagePhase
  Begin: 
.octa
  Step: 
__builtin_IB_simd_block_write_16_global_h
  End: 
.float
  CheckUse: 
llvm.genx.GenISA.simdSetMessagePhaseV
 Operand: 
//.spill GRF ref count 
RANGE_CHECK_UNKNOWN
__builtin_IB_simd_block_write_1_global_b
RANGE_CHECK_UPPER
.single
RANGE_CHECK_LOWER
llvm.genx.GenISA.simdShuffleDown
RANGE_CHECK_BOTH
.balignl
llvm.loop.unroll.disable
__builtin_IB_simd_block_write_2_global_b
verify-indvars
invalid assignment to '
Verify the ScalarEvolution result after running indvars
llvm.genx.GenISA.simdSize
replexitval
//.spill flag load 
Choose the strategy to replace exit value in IndVarSimplify
__builtin_IB_simd_block_write_4_global_b
never
//.kernel_reordering_info_start
never replace exit value
GlobalDataResolutionPass
cheap
igc-constant-coalescing
only replace exit value when the cost is cheap
__builtin_IB_simd_block_write_8_global_b
always
.lazy_reference
always replace exit value whenever possible
llvm.genx.GenISA.source.value
indvars-post-increment-ranges
//id
byte_offset
byte_size
kind
implicit_kind
Use post increment control-dependent ranges in IndVarSimplify
__builtin_IB_simd_block_write_16_global_b
disable-lftr
.global
Disable Linear Function Test Replace optimization
llvm.genx.GenISA.storeraw.indexed
.int
.weak_reference
Remove redundant instructions
__builtin_IB_simd_block_write_1_global_l
instsimplify
pointers to void are invalid; use i8* instead
jump-threading-threshold
llvm.genx.GenISA.storerawvector.indexed
Max block size to duplicate for jump threading
read_only
jump-threading-implication-search-threshold
__builtin_IB_simd_block_write_2_global_l
The number of predecessors to search for a stronger condition to use to thread over a weaker condition
.weak_def_can_be_hidden
print-lvi-after-jump-threading
llvm.genx.GenISA.storestructured1
Print the LazyValueInfo cache after JumpThreading
.code16
thread-pre-split
__builtin_IB_simd_block_write_4_global_l
.rept
.thr_comm
llvm.genx.GenISA.storestructured2
.thread
Failed to decode binary for asm output. Please report the issue and try disabling IGA disassembler for now.
.split-lp
__builtin_IB_simd_block_write_8_global_l
select.unfold
.code16gcc
Jump Threading
llvm.genx.GenISA.storestructured3
jump-threading
.bundle_lock
LVI for function '
__builtin_IB_simd_media_block_read_1
.globl
disable-licm-promotion
llvm.genx.GenISA.storestructured4
Disable memory promotion in LICM pass
// Text representation might not be correct
licm-max-num-uses-traversed
__builtin_IB_simd_media_block_read_2
Max num uses visited for identifying load invariance in loop using invariant start (default = 8)
.bundle_unlock
.promoted
llvm.genx.GenISA.sub.pair
Loop Invariant Code Motion
CE: 
licm
__builtin_IB_simd_media_block_read_4
InstSunk
.ifnb
Inst
llvm.genx.GenISA.subslice.id
.split.loop.exit
.end_kernel
funclet
__builtin_IB_simd_media_block_read_8
.ifb
.lcssa
llvm.genx.GenISA.threadgroupbarrier
Hoisted
.ifndef
hoisting 
__builtin_IB_simd_media_block_read_1_h
LoadWithLoopInvariantAddressCondExecuted
argument attributes invalid in function type
failed to hoist load with loop-invariant address because load is conditionally executed
llvm.genx.GenISA.threadgroupbarrier.signal
LoadWithLoopInvariantAddressInvalidated
// -- GOOD: 
failed to move load with loop-invariant address because the loop may invalidate its value
__builtin_IB_simd_media_block_read_2_h
PromoteLoopAccessesToScalar
.ifnotdef
Moving accesses to memory location out of the loop
llvm.genx.GenISA.threadgroupbarrier.wait
sink-freq-percent-threshold
.file
Do not sink instructions that require cloning unless they execute less than this percent of the time.
__builtin_IB_simd_media_block_read_4_h
max-uses-for-sinking
.loc
Do not sink instructions that have too many uses.
llvm.genx.GenISA.typedmemoryfence
Delete dead loops
// --   OK: 
loop-deletion
__builtin_IB_simd_media_block_read_8_h
loop-prefetch-writes
.line
Prefetch write addresses
llvm.genx.GenISA.typedread
prefetch-distance
.cv_inline_linetable
Number of instructions to prefetch ahead
__builtin_IB_simd_media_block_read_16_h
min-prefetch-stride
llvm.genx.GenISA.slice.id
Min stride to add prefetches
llvm.genx.GenISA.typedwrite
max-prefetch-iters-ahead
// Line 
Max number of iterations to prefetch ahead
__builtin_IB_simd_media_block_read_1_b
loop-distribute-verify
.cv_inline_site_id
Turn on DominatorTree and LoopInfo verification after Loop Distribution
Cleans up symbols and relocation that are not longer needed due to various optimizations
__builtin_IB_simd_media_block_read_2_b
loop-distribute-scev-check-threshold
The maximum number of SCEV checks allowed for Loop Distribution
llvm.genx.GenISA.uavSerializeAll
loop-distribute-scev-check-threshold-with-pragma
__builtin_IB_simd_media_block_read_4_b
enable-loop-distribute
.cfi_sections
Enable the new, experimental LoopDistribution Pass
llvm.genx.GenISA.uavSerializeOnResID
llvm.genx.GenISA.vaBoolCentroid
llvm.genx.GenISA.vaBoolSum
llvm.genx.GenISA.vaConvolve
use-lir-code-size-heurs
.cfi_offset
.dc.s
Use loop idiom recognition code size heuristics when compilingwith -Os/-Oz
__builtin_IB_simd_media_block_read_8_b
memset_pattern16
invalid use of a non-first-class type
expected string
loop-interchange-threshold
llvm.genx.GenISA.ubfe
Interchange if you gain more than this number
write
runtime-check-per-loop-load-elim
__builtin_IB_simd_media_block_read_16_b
Max number of memchecks allowed per eliminated load on average
.cfi_rel_offset
loop-load-elimination-scev-check-threshold
llvm.genx.GenISA.uitof.rtn
The maximum number of SCEV checks allowed for Loop Load Elimination
.cfi_escape
loop-predication-enable-iv-truncation
__builtin_IB_simd_media_block_read_1_l
loop-predication-enable-count-down-loop
.cfi_signal_frame
loop-predication-skip-profitability-checks
llvm.genx.GenISA.uitof.rtp
loop-predication-latch-probability-scale
OH, 
scale factor for the latch probability. Value should be greater than 1. Lower values are ignored
__builtin_IB_simd_media_block_read_2_l
reroll-num-tolerated-failed-matches
.cfi_return_column
The maximum number of failures to tolerate during fuzzy matching. (default: 400)
llvm.genx.GenISA.uitof.rtz
rotation-max-header-size
.macro
The default maximum header size for automatic loop rotation
__builtin_IB_simd_media_block_read_4_l
Rotate Loops
.uleb128
loop-rotate
llvm.genx.GenISA.umulH
enable-lsr-phielim
BAD,
llvm.genx.GenISA.usubb
DebugInfoPass
Narrow LSR complex solution using expectation of registers number
__builtin_IB_simd_media_block_write_1
lsr-filter-same-scaled-reg
.reloc
Narrow LSR search space by filtering non-optimal formulae with the same ScaledReg and Scale
GOOD,
reg(
__builtin_IB_simd_media_block_write_2
**error: HasBaseReg**
 reg
 IV mul
, PostIncLoop=
, Offset=
.noaltmacro
.dcb.x
**error: !HasBaseReg**
*reg(
imm(
__builtin_IB_simd_media_block_write_4
 instruction
llvm.genx.GenISA.vaCentroid
llvm.genx.GenISA.vaConvolveGRF.16x4
llvm.genx.GenISA.vaDilate
, with addrec cost 
__builtin_IB_simd_media_block_write_8
, plus 
.dc.w
 base add
LSR Use: Kind=
.dcb.w
.ds.w
 scale cost
__builtin_IB_simd_media_block_write_1_h
 imm cost
Basic
Special
.extern
.altmacro
 setup cost
llvm.genx.GenISA.vaConvolveGRF.16x1
UserInst=
cannot take address of numeric label after the function is defined
, OperandValToReplace=
ICmpZero
 in addrspace(
__builtin_IB_simd_media_block_write_2_h
SymbolRelocationCleanup
pragma-unroll-and-jam-threshold
     
Unrolled size limit for loops with an unroll_and_jam(full) or unroll_count pragma.
__builtin_IB_sub_group_reduce_OpGroupSMin
loop-unswitch-threshold
invalid symbol redefinition
Max loop size to unswitch
DCL_HSOutputCntrlPtInputVec@
licm-versioning-invariant-threshold
General
idiv
math.idiv
IDIV
math.inv
iqot
math.iqot
IQOT
Integer Quotient only
irem
math.irem
IREM
math.log
math.pow
rsqt
math.rsqt
RSQT
Reciprocal Square Root: 1/sqt(src)
math.sin
math.sqt
Move
The mov instruction moves the components in src0 into the channels of dst. If src0 and dst are of different types, format conversion is performed. If src0 is a scalar immediate, the immediate value is loaded into enabled channels of dst.
A mov with the same source and destination type, no source modifier, and no saturation is a raw move. A packed byte destination region (B or UB type with HorzStride == 1 and ExecSize > 1) can only be written using raw move.
When denorm mode is flush to zero, a raw mov instruction with saturation modifier will not flush the denorm input or output to zero (Denorm is preserved).
Format: [(pred)] mov[.cmod] (exec_size) dst src0
A mov instruction with a source modifier always copies a denorm source value to a denorm destination value
(in the manner of a raw move).
There is no direct conversion from B/UB to DF or DF to B/UB. Use two instructions and a word or DWord intermediate type.
Move Indexed
The movi instruction performs a fast component-wise indexed move for subfields from src0 to dst. The source
operand must be an indirectly-addressed register. All channels of the source operand share the same register
number, which is provided by the register field of the first address subregister, with a possible immediate
register offset. The register fields of the subsequent address subregisters are ignored by hardware. The
subregister number of a source channel is provided by the subregister field of the corresponding address
subregister, with a possible immediate subregister offset.
The destination register may be either a directly-addressed or an indirectly-addressed register.
This instruction effectively performs a subfield shuffling from one register to another. Up to eight
subfields can be selected by an instruction.
Format: [(pred)] movi (exec_size) dst src0
HW Implementation Details:
The source register is calculated by adding the register portion of the first index register with the
register portion of the address immediate, a0.0[11:5] + addr_imm[9:5]
For byte movi, byte0 of the destination is selected by (a0.0[4:0]), byte1 is selected by (a0.1[4:0]), ...,
and byte7 is selected by (a0.7[4:0]). The rest of the bytes are undefined.
For word movi, byte0 of the destination is selected by (a0.0[4:1] & 0), byte1 is selected by (a0.0[4:1]
& 1), byte2 is selected by (a0.1[4:1] & 0), byte3 is selected by (a0.1[4:1] & 1), ..., and byte15
is selected by (a0.7[4:1] & 1). The rest of the bytes are undefined.
For DWord or float movi, byte0 of the destination is selected by (a0.0[4:2] & 00b), byte1 is selected
by (a0.0[4:2] & 01b), byte2 is selected by (a0.0[4:2] & 10b), byte3 is selected by (a0.0[4:2] &
11b), byte4 is selected by (a0.1[4:2] & 00b), byte5 is selected by (a0.1[4:2] & 01b), ..., byte31
is selected by (a0.7[4:2] & 11b).
For all 3 conditions above, a0.n[4:0] = a0.n[4:0] + addr_imm[4:0].
Multiply
The mul instruction performs component-wise multiplication of src0 and src1 and stores the results in dst.
When both src0 and src1 are of type D or UD, only the low 16 bits of each element of src1 are used. The accumulator maintains full 48-bit precision. The macro described in the mach instruction should be used to obtain the full precision 64-bit multiplication result.
Multiplication of two floating-point numbers follows the rules in mul - Multiply [Pre-DevBDW] or mul - Multiply [Pre-DevBDW]) based on the applicable floating-point mode.
Format:
[(pred)] mul[.cmod] (exec_size) dst src0 src1
No Operation
Logic Not
The not instruction performs logical NOT operation (or one's complement) of src0 and storing the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
A register source operand can use a source modifier:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the NOT operation.
Format:
[(pred)] not[.cmod] (exec_size) dst src0
Logic Or
The or instruction performs component-wise logic OR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the OR operation.
Format:
[(pred)] or[.cmod] (exec_size) dst src0 src1
The pln instruction computes a component-wise plane equation (w = p*u+q*v+r where u/v/w are vectors and p/q/r are scalars) of src0 and src1 and stores the results in dst. src1 is the input vector u.
src0 provides input scalars p, q, and r, where p is the scalar value based on the region description of src0 and q and r are the scalar values implied from the src0 region. Specifically, q is the second component and r is the fourth component of the 4-tuple (128-bit aligned) that p belongs to.
Format:
[(pred)] pln[.cmod] (exec_size) dst src0 src1
Return
Return execution to the code sequence that called a subroutine.
The ret instruction can be predicated or non-predicated. If non-predicated, all channels jump to the return IP in the first channel of src0 and restore CallMask from the second channel of src0. If predicated, the enabled channels jump to the return IP from the first channel of src0 and the corresponding bits in the CallMask are cleared to zero; if all CallMask bits are zero after the ret instruction, then execution jumps to the return IP from the first channel of src0.
When SPF is on, the predication control must be scalar.
Format:
[(pred)] ret (exec_size) null src0
rndd
Round Down
The rndd instruction takes component-wise floating point downward rounding (to the integral float number closer to negative infinity) of src0 and storing the rounded integral float results in dst. This is commonly referred to as the floor() function.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rndd[.cmod] (exec_size) dst src0
Round to Nearest or Even
The rnde instruction takes component-wise floating point round-to-even operation of src0 with results in two pieces - a downward rounded integral float results stored in dst and the round-to-even increments stored in the rounding increment bits. The round-to-even increment must be added to the results in dst to create the final round-to-even values to emulate the round-to-even operation, commonly known as the round() function. The final results are the one of the two integral float values that is nearer to the input values. If the neither possibility is nearer, the even alternative is chosen.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rnde[.cmod] (exec_size) dst src0
rndu
The rndu instruction takes component-wise floating point upward rounding (to the integral float number closer to positive infinity) of src0, commonly known as the ceiling() function.
Each result follows the rules in the following tables based on the floating-point mode.
Format:
[(pred)] rndu[.cmod] (exec_size) dst src0
rndz
Round to Zero
sad2
Sum of Absolute Difference 2
The sad2 instruction takes source data channels from src0 and src1 in groups of 2-tuples. For each 2-tuple, it computes the sum-of-absolute-difference (SAD) between src0 and src1 and stores the scalar result in the first channel of the 2-tuple in dst.
The results are also stored in the accumulator register. The destination operand and the accumulator maintain 16 bits per channel precision.
The destination register must be aligned to even word (DWord). The even words in the destination region will contain the correct data. The odd words are also written but with undefined values.
Format:
[(pred)] sad2[.cmod] (exec_size) dst src0 src1
sada2
Sum of Absolute Difference Accumulate 2
The sada2 instruction takes source data channels from src0 and src1 in groups of 2-tuples. For each 2-tuple, it computes the sum-of-absolute-difference (SAD) between src0 and src1, adds the intermediate result with the accumulator value corresponding to the first channel, and stores the scalar result in the first channel of the 2-tuple in dst.
The destination operand and the accumulator maintain 16 bits per channel precision. Higher precision (guide bits) stored in the accumulator allows up to 64 rounds of sada2 instructions to be issued back to back without overflowing the accumulator.
The destination register must be aligned to even word (DWord). The even words in the destination region will contain the correct data. The odd words are also written but with undefined values.
Format:
[(pred)] sada2[.cmod] (exec_size) dst src0 src1
The sel instruction selectively moves the components in src0 or src1 into the channels of dst based on the predication. On a channel by channel basis, if the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst.
As the predication is used to select the two sources, it is not included in the evaluation of WrEn. The predicate clause is mandatory if cmod is omitted/0000b. If both predication and the conditional modifier are omitted, the results are undefined.
If the conditional modifier is specified (not 0000b, a compare is performed and the resulting condition flag is used for the sel instruction. Conditional modifiers .ge and .l follow the cmpn rules, and all other conditional modifiers follow the cmp rules. Predication is not allowed in this mode.
A sel instruction with cmod .l is used to emulate a MIN instruction.
A sel instruction with cmod .ge is used to emulate a MAX instruction.
For a sel instruction with a .l or .ge conditional modifier, if one source is NaN and the other not NaN, the non-NaN source is the result. If both sources are NaNs, the result is NaN. For all other conditional modifiers, if either source is NaN then src1 is selected.
A sel instruction without a conditional modifier always copies a denorm source value to a denorm destination value (in the manner of a raw move). This applies even if the source modifies are set on the sel instruction sources.
The sel instruction uses any conditional modifier internally and does not update the flag register if a conditional modifier is used.
A sel instruction with a conditional modifier flushes any selected denorm source value to a zero destination value.
Format:
(pred) sel[.cmod] (exec_size) dst src0 src1
send
Send Message
sendc
Conditional Send Message
The sendc instruction has the same behavior as the send instruction except the following.
sendc first checks the dependent threads inside the Thread Dependency Register. There are up to 8 dependent threads in the TDR register. The sendc instruction executes only when all the dependent threads in the TDR register are retired.
Wait for dependencies in the TDR Register to clear, then send a message stored in registers starting at src to a shared function identified by exdesc along with control from desc with a general register writeback location at dst.
Format:
[(pred)] sendc (exec_size) dst src0 exdesc desc
Shift Left
Perform component-wise logical left shift of the bits in src0 by the shift count indicated in src1, storing the results in dst, inserting zero bits in the number of LSBs indicated by the shift count.
Hardware detects overflow properly and uses it to perform any saturation operation on the result, as long as the shifted result is within 33 bits. Otherwise, the result is undefined.
Note: For word and DWord operands, the accumulators have 33 bits.
The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
Format:
[(pred)] shl[.cmod] (exec_size) dst src0 src1
Shift Right
Perform component-wise logical right shift with zero insertion of the bits in src0 by the shift count indicated in src1, storing the results in dst. Insert zero bits in the number of MSBs indicated by the shift count.
src0 and dst can have different types and can be signed or unsigned.
Note: For word and DWord operands, the accumulators have 33 bits.
Note: For unsigned src0 types, shr and asr produce the same result.
The shift count is taken from the low five bits of src1, regardless of the src1 type and treated as an unsigned integer in the range 0 to 31.
Format:
[(pred)] shr[.cmod] (exec_size) dst src0 src1
subb
Integer Subtraction with Borrow
wait
Wait Notification
The wait instruction evaluates the value of the notification count register nreg. If nreg is zero, thread execution is suspended and the thread is put in 'wait_for_notification' state. If nreg is not zero (i.e., one or more notifications have been received), nreg is decremented by one and the thread continues executing on the next instruction. If a thread is in the 'wait_for_notification' state, when a notification arrives, the notification count register is incremented by one. As the notification count register becomes nonzero, the thread wakes up to continue execution and at the same time the notification register is decremented by one. If only one notification arrived, the notification register value becomes zero. However, during the above mentioned time period, it is possible that more notifications may arrive, making the notification register nonzero again.
When multiple notifications are received, software must use wait instructions to decrement notification count registers for each notification.
Notification register n0.0:ud is for thread to thread communication (via the Message Gateway shared function) and n0.1:ud for host to thread communication (through MMIO registers). See the Message Gateway chapter for thread-thread communication and the Debug chapter for host-to-thread communication.
Format:
wait (exec_size) nreg
While
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
The following table describes the 16-bit jump target offset JIP. JIP is a signed 16-bit number, added to IP pre-increment, and should point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing. In GEN binary, JIP is at location src1 and must be of type W (signed word integer).
Format:
[(pred)] while (exec_size) JIP
The xor instruction performs component-wise logic XOR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is numeric, optionally changing a source value s to -s, abs(s), or -abs(s) before the XOR operation.
Format:
[(pred)] xor[.cmod] (exec_size) dst src0 src1
The bfi1 instruction is the first instruction in a two-instruction macro for bfi (Bit Field Insert).
The bfi1 instruction component-wise generates mask with control from src0 and src1 and stores the results in dst. The mask is used in the bfi2 instruction to generate the final result of bfi.
Create a bit mask corresponding to the bit field width and offset in src0 and src1. Store the bit mask in dst. The mask has all bits in the bit field set to 1 and all other bits as 0.
The width and offset values are from the low five bits of src0 and src1 respectively, or src0 & 0x1f and src1 & 0x1f.
If width is zero, the result is zero.
The bfi macro has four source operands: src0 - bit field width in low five bits, src1 - bit field offset/starting bit position in low five bits, src2 - bit field value to insert, using only the number of least significant bits given by width in src0, and src3 - overall value into which the bit field is inserted, providing all bits other than the inserted bits for the result value.
bfi dst src0 src1 src2 src3
// Translates to these two instructions:
bfi1 dst src0 src1
bfi2 dst dst src2 src3
Format:
[(pred)] bfi1 (exec_size) dst src0 src1
No accumulator access, implicit or explicit.
The brc instruction redirects the execution forward or backward to the instruction pointed by (current IP + offset). The jump will occur if all channels are branched away.
UIP should reference the instruction where all channels are expected to come together. JIP should reference the end of the innermost conditional block.
In GEN binary, JIP and UIP use locations src1 and src0 respectively when immediate and location src0 when reg64, where reg64 is accessed as paired DWord (regioning being <2;2,1>). dst must be IP. When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] brc (exec_size) JIP UIP
The break instruction is used to early-out from the inner most loop, or early out from the inner most switch block.
When used in a loop, upon execution, the break instruction terminates the loop for all execution channels enabled. If all the enabled channels hit the break instruction, jump to the instruction referenced by JIP. JIP should be the offset to the end of the inner most conditional or loop block, UIP should be the offset to the while instruction of the loop block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] break (exec_size) JIP UIP
The cont instruction disables execution for the subset of channels for the remainder of the current loop iteration. Channels remain disabled until right before the while instuction or right before the condition check code block for the while instruction. If all enabled channels hit this instruction, jump to the instruction referenced by JIP where execution continues.
UIP should always reference the loop's associated while instruction. JIP should point to the last instruction of the inner most conditional block if the cont instruction is inside a conditional block. In case of the break instruction directly under the loop, the JIP and the UIP are the same.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer). When the offsets are immediate, src0 regfile must be immediate.
Format:
[(pred)] cont (exec_size) JIP UIP
Conditional Select
The csel instruction selectively moves components in src0 or src1 to the dst based on the result of the compare of src2 with zero. If the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst. The csel instruction provides the function of a cmp followed by sel. The instruction must not be used if cmpn is required. The instruction does not update the flag register.
The comparison follows the same rule as cmp instruction for that data type.
Format:
csel (exec_size) dst src0 src1 src2
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive prior to entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving the else instruction will be redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by  <JIP>. The jump target should be the matching endif instruction for that conditional block.
The following table describes the 32-bit <JIP>. In GEN binary, <JIP> is at location <src1> and must be of type D (signed dword integer). <JIP> must be an immediate operand, it is a signed 32-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
If the <branch_ctrl> bit is set, then the <JIP> points to the first join instruction within the else block and <UIP> points to the endif instruction. If the <branch_ctrl> bit is not set,  <JIP> and <UIP>, both point to endif.
Format:
else (exec_size) JIP  UIP  branch_ctrl
An else instruction must not be followed by any instruction requiring register indirect access on source operands
If all channels are redirected (by else or before else), relative jump is performed to the location specified by <JIP> + 1.
goto
Goto
The goto instruction directs the instruction pointer to the offset specified by the UIP offset or to the next IP based on the BranchCtrl bit in the instruction. The active channels that are predicated on this instruction will take the IP + UIP path when BranchCtrl is set else the channels take IP + 1. The active channels that are not predicated on this instruction will be made inactive and waiting to be joined at the join IP. The join IP is IP + UIP when BranchCtrl is clear else it is the next IP.
When there are no active channels the instruction pointer will move to IP + JIP.
The goto instruction is used in conjunction with a join instruction. A goto deactivates some channels that are reactivated at some program-specified join instruction. See the join instruction for the activation rules.
The goto and join instructions enable unstructured program control flow. These instructions must be used with additional care where dangling channels can result without proper compiler checks, meaning that it is expected that programs will navigate through these paths to reactivate the channels. Hardware does not provide native checks or reconvergence.
The following table describes the two 32-bit instruction pointer offsets. Both the JIP and UIP are signed 32-bit numbers, added to IP pre-increment. In GEN binary, JIP and UIP are at locations src0 and src1 and must be of type DW (signed DWord integer).
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] goto (exec_size) JIP UIP branch_ctrl
An if instruction starts an if/endif or an if/else/endif block of code. It restricts execution within the conditional block to only those channels that were enabled via the predicate control.
Each if instruction must have a matching endif instruction and may have up to one matching else instruction before the matching endif.
If all channels are inactive (for the if/endif or if/else/endif block), a jump is performed to the instruction referenced by JIP. This jump must be to right after the matching else instruction when present, or otherwise to the matching endif instruction of the conditional block.
If SPF is ON, the UIP must be used to update IP; JIP is not used in this case.
The following table describes the 32-bit exit code <JIP> and <UIP>. If <branch_ctrl> is set, then the JIP points to the first join instruction within the if block. If <branch_ctrl> is not set, <JIP> should point to the instruction right after the matching else instruction if it exsits, otherwise <JIP> should point to the endif instruction. <UIP> should always point to the endif instruction. When a jump occurs, this value is added to IP pre-increment. In GEN instruction binary, <JIP> and <UIP> are at location <src0> & <src1> and must be of type D (signed dword integer).
Format:
[(pred)] if (exec_size JIP UIP <branch_ctrl>
join
Join
The join instruction makes the inactive channels active at the join IP if those channels are predicated. Any deactivated channels due to a goto instruction match the join IP are activated (qualified with predicates at join). If no IP is matched at this join, the program goes to the next IP with the active channels which followed the program path up to the join instruction. If no active channels are present after executing the join instruction, the program jumps to the offset specified by JIP instead of next IP.
The join instruction is used in conjunction with a goto instruction. The join activates channels that are deactivated by the goto instruction. See the goto instruction for the deactivation rules.
The goto and join instructions enable unstructured program control flow. These instructions must be used with additional care where dangling channels can result without proper compiler checks, meaning that it is expected that programs will navigate through these paths to reactivate the channels. Hardware does not provide native checks or reconvergence.
The following table describes the 32-bit JIP. In GEN binary, JIP is at location src1 and must be of type D (signed DWord integer). JIP must be an immediate operand and is a signed 32-bit number. This value is added to IP pre-increment.
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] join (exec_size) JIP
An index of 0 is an infinite loop.
The mach instruction performs DWord integer multiply-accumulate operation and outputs the high DWord (bits 63:32). For each enabled channel, this instruction multiplies the DWord in src0 with the high word of the DWord in src1, left shifts the result by 16 bits, adds it with the corresponding accumulator values, and keeps the whole 64-bit result in the accumulator. It then stores the high DWord (bits 63:32) of the results in dst. This instruction is intended to be used to emulate 32-bit DWord integer multiplication by using the large number of bits available in the accumulator. For example, the following instructions perform vector multiplication of two 32-bit signed integer sources from r2 and r3 and store the resulting vectors with the high 32 bits in r5 and the low 32 bits in r6.
mul (8) acc0:d r2.0<8;8,1>:d r3.0<16;8,2>:uw
mach (8) r5.0<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d
mov (8) r6.0<1>:d acc0:d // Low 32 bits.
Here is a different example including negation. An added preliminary mov is required for source modification on src1.
mov (8) r3.0<1>:d -r3<8;8,1>:d
mul (8) acc0:d r2.0<8;8,1>:d r3.0<16;8,2>:uw
mach (8) r5.0<1>:d r2.0<8;8,1>:d r3.0<8;8,1>:d // High 32 bits
mov (8) r6.0<1>:d acc0:d // Low 32 bits.
The mach should have channel enable from the destHI of IMUL, the mov should have the channel enable from the destLO of IMUL. As mach is used to generate part of the 64-bit DWord integer results, saturation modifier should not be used. In fact, saturation modifier should not be used for any of these four instructions. Source and destination operands must be DWord integers. Source and destination must be of the same type, signed integer or unsigned integer. If dst is UD, src0 and src1 may be UD and/or D. However, if any of src0 and src1 is D, source modifier (abs) must be present to convert it to match with dst. If dst is D, src0 and src1 must also be D. They cannot be UD as it may cause unexpected overflow because the computed results are limited to 64 bits.
Format:
[(pred)] mach[.cmod] (exec_size) dst src0 src1
madm
Multiply Add for Macro
invm
math.invm
INVM
rsqtm
math.rsqtm
RSQTM
The mov instruction moves the components in src0 into the channels of dst. If src0 and dst are of different types, format conversion is performed. If src0 is a scalar immediate, the immediate value is loaded into enabled channels of dst.
A mov with the same source and destination type, no source modifier, and no saturation is a raw move. A packed byte destination region (B or UB type with HorzStride == 1 and ExecSize > 1) can only be written using raw move.
When denorm mode is flush to zero, a raw mov instruction with saturation modifier will not flush the denorm input or output to zero (Denorm is preserved).
Format: [(pred)] mov[.cmod] (exec_size) dst src0
A mov instruction with a source modifier always copies a denorm source value to a denorm destination value
(in the manner of a raw move).
There is no direct conversion from B/UB to DF or DF to B/UB. Use two instructions and a word or DWord intermediate type.
There is no direct conversion from B/UB to Q/UQ or Q/UQ to B/UB. Use two instructions and a word or DWord intermediate integer type.
There is no direct conversion from HF to DF or DF to HF. Use two instructions and F (Float) as an intermediate type.
There is no direct conversion from HF to Q/UQ or Q/UQ to HF. Use two instructions and F (Float) or a word integer type or a DWord integer type as an intermediate type.
The mul instruction performs component-wise multiplication of src0 and src1 and stores the results in dst. When multiplying integer datatypes, if src0 is DW and src1 is W, irrespective of the destination datatype, the accumulator maintains full 48-bit precision. This is required to handle the macro for 32x32 multiplication. The macro described in the mach instruction should be used to obtain the full precision 64-bit multiplication results.
Note: A 32x32 multiply operation is handled natively, without a macro. When operating in this mode, the resulting 64-bit data is packed, unlike the macro, where the lower and upper 32 bits of the result are written to different general registers by two separate instructions. Refer to the macro description for details.
When multiplying integer data types, if one of the sources is a DW, the resulting full precision data is stored in the accumulator. However, if the destination data type is either W or DW, the low bits of the result are written to the destination register and the remaining high bits are discarded. This results in undefined Overflow and Sign flags. Therefore, conditional modifiers and saturation (.sat) cannot be used in this case.
Format:
[(pred)] mul[.cmod] (exec_size) dst src0 src1
The not instruction performs logical NOT operation (or one's complement) of src0 and storing the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
A register source operand can use a source modifier:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). Such a source modifier is not particularly useful with the not instruction, as it changes the effect of not to just copying bits.
Format:
[(pred)] not[.cmod] (exec_size) dst src0
The or instruction performs component-wise logic OR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a OR (NOT b) to be calculated with one instruction.
Format:
[(pred)] or[.cmod] (exec_size) dst src0 src1
The sel instruction selectively moves the components in src0 or src1 into the channels of dst based on the predication. On a channel by channel basis, if the channel condition is true, data in src0 is moved into dst. Otherwise, data in src1 is moved into dst.
As the predication is used to select the two sources, it is not included in the evaluation of WrEn. The predicate clause is mandatory if cmod is omitted/0000b. If both predication and the conditional modifier are omitted, the results are undefined.
If the conditional modifier is specified (not 0000b, a compare is performed and the resulting condition flag is used for the sel instruction. Conditional modifiers .ge and .l follow the cmpn rules, and all other conditional modifiers follow the cmp rules. Predication is not allowed in this mode.
A sel instruction with cmod .l is used to emulate a MIN instruction.
A sel instruction with cmod .ge is used to emulate a MAX instruction.
For a sel instruction with a .l or .ge conditional modifier, if one source is NaN and the other not NaN, the non-NaN source is the result. If both sources are NaNs, the result is NaN. For all other conditional modifiers, if either source is NaN then src1 is selected.
A sel instruction without a conditional modifier always copies a denorm source value to a denorm destination value (in the manner of a raw move). This applies even if the source modifies are set on the sel instruction sources.
The sel instruction uses any conditional modifier internally and does not update the flag register if a conditional modifier is used.
A sel instruction with cmod or source modifier will flush denorm to zero, depending on the denorm mode bit; a sel instruction without cmod and source modifier will retain denorm.
Format:
(pred) sel[.cmod] (exec_size) dst src0 src1
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 6-bit immediate, imm6. The lower 4bits of the <ex_desc> specifies the SFID for the message. The MSb of the message descriptor, the EOT field, always comes from bit 127 of the instruction word, which is the MSb of imm6. A thread must terminate with a send instruction with EOT turned on.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals. <dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined. If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null. If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off. The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware). The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases. The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
Thread managed memory coherency: A special usage of using non-null <dest> is to support write-commit signaling for memory write service by the Data Port Write unit. If <post_dest> is not null for a memory write request, the Data Port along with the Data Cache or Render Cache will wait until all the posted writes for the request have reached the coherent domain before sending back to the requesting thread an empty message to <dest> register. A memory write reaching the coherent domain, also referred to as reaching the global observable state, means that subsequent read to the same memory location, no matter which thread issues the read, must return the data of the write.
Perform component-wise logical left shift of the bits in src0 by the shift count indicated in src1, storing the results in dst, inserting zero bits in the number of LSBs indicated by the shift count.
Hardware detects overflow properly and uses it to perform any saturation operation on the result, as long as the shifted result is within 33 bits. Otherwise, the result is undefined.
Note: For word and DWord operands, the accumulators have 33 bits.
In QWord mode, the shift count is taken from the low six bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 63. Otherwise the shift count is taken from the low five bits of src1 regardless of the src1 type and treated as an unsigned integer in the range 0 to 31. The operation uses QWord mode if src0 or dst has the Q or UQ type but not if src1 is the only operand with the Q or UQ type.
Format:
[(pred)] shl[.cmod] (exec_size) dst src0 src1
smov
Scattered Move
The smov instruction moves the components in src0 into dst.
For each enabled channel, copy src0 to dst. The immediate is used to selectively enable channels without using flags.
When predication is enabled, the predicate mask is not generated from the flags. Instead, the immediate is used to mask the execution mask. If any channel is enabled as a result of this masking, the instruction is executed.
When predication is not enabled, the immediate masks the execution mask. This provides flexibility to mask out any channel with an immediate.
Format:
[(pred)] smov[.cmod] (exec_size) dst src0 src1
When predication is disabled, the immediate provides the flexibility to perform a select operation without the use of flags.
When predication is enabled, the usage model provides flexibility to select any bit in the flag registers for predication for execution size of 1.
The xor instruction performs component-wise logic XOR operation between src0 and src1 and stores the results in dst.
This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers should be used.
Register source operands can use source modifiers:
Any source modifier is logical, optionally changing a source value s to ~s (inverting all source bits). This capability allows expressions like a XOR (NOT b) to be calculated with one instruction.
Format:
[(pred)] xor[.cmod] (exec_size) dst src0 src1
The mac instruction takes component-wise multiplication of src0 and src1, adds the results with the corresponding accumulator values, and then stores the final results in dst.
Format:
[(pred)] mac[.cmod] (exec_size) dst src0 src1
When source and destination datatypes are different, the implied datatype for the accumulator operand is always the destination datatype.
Send a message stored in GRF starting at <src> to a shared function identified by <ex_desc> along with control from <desc> with a GRF writeback location at <dest>.
The send instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The send instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src> is the lead GRF register for request. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend mesage descriptor field <ex_desc> contains the target function ID. WrEn is forwarded to the target function in the message sideband.
The extended message descriptor field <ex_desc> also contains the extended function control field to be sent to the Target Shared Function over message sideband.
The send instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 29 bits of <reg32a> are used.
<ex_desc> is a 32-bit immediate, imm32. The lower 4bits of the <ex_desc> specifies the SFID for the message. The bit5 of the extended message descriptor, the EOT field, always comes from bit 127 of the instruction word. A thread must terminate with a send instruction with EOT turned on. The higher 16bits, bit31:16 specify the 16bit extended function control field. Interpretation of the extended function control signals is subject to the target external function.
<src> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for the source.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals. <dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined. If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null. If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off. The subregister number, horizontal stride, destination mask and type fields of <dest> are always valid and are used in part to generate on the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware). The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'send' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases. The destination dependency control, {NoDDClr}, can be used in this instruction. This allows software to control the destination dependencies for multiple 'read'-type messages similar to that for multiple instructions using EU execution pipeline. As send does not check register dependencies for the post destination, {NoDDChk} should not be used for this instruction.
sends
Split Send Message
The sends instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The sends instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src0> and <src1> are the lead GRF registers for the first and second block of the request respectively. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers corresponding to src0) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend message descriptor field <ex_desc> contains the target function ID, the Extended Message Length (the number of consecutive GRF registers corresponding to src1) and the extended function control signals. WrEn is forwarded to the target function in the message sideband.
The sends instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 31 bits of <reg32a> are used.
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 only. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:16 specify the 16bit extended function control. Interpretation of the extended function control signals is subject to the target external function.</ex_desc></ex_desc></ex_desc></ex_desc>
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 or a 32bit scalar register, <reg32a>. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:12 specify the 20bit extended function control. Interpretation of the extended function control signals is subject to the target external function. The scalar register <reg32a> is selected when SelReg32ExDesc is set, ExDesc.RegNum[3:0] provides the addressing for reg32a for extended message descriptor. This selects one of the index sub registers. Subregisters selected are always aligned to dword. This implies, the even index subregisters must be used.</reg32a></ex_desc></ex_desc></ex_desc></reg32a></ex_desc>
Function control is now extended to 20 bits as specified in the below definition.
<src0> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<src1> is a 256-bit aligned GRF register or a null register. It serves as the leading GRF register for the second block of the request when it is not a null register. It is required that the second block of GRFs does not overlap with the first block. If it is a null register the Extended Message Length must be 0. The sum of Message Length and Extended Message Length must not be greater than 15 on SKL.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for both the sources.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The destination type field is always valid and is used to generate the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The address immediates for indirect sources and destination must be oword aligned.
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'sends' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
NoDDClr and NoDDChk must not be used for send instruction.
Send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sends (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
sendsc
Conditional Split Send Message
The while instruction marks the end of a do-while block. The instruction first evaluates the loop termination condition for each channel based on the current channel enables and the predication flags specified in the instruction. If any channel has not terminated, a branch is taken to a destination address specified in the instruction, and the loop continues for those channels. Otherwise, execution continues to the next instruction.ld point to the first instruction with the do label of the do-while block of code. It should be a negative number for the backward referencing.
If SPF is ON, none of the PcIP are updated.
Format:
[(pred)] while (exec_size) JIP
The sends instruction performs data communication between a thread and external function units, including shared functions (Sampler, Data Port Read, Data Port Write, URB, and Message Gateway) and some fixed functions (e.g. Thread Spawner, who also have an unique Shared Function ID). The sends instruction adds an entry to the EU's message request queue. The request message is stored in a block of contiguous GRF registers. The response message, if present, will be returned to a block of contiguous GRF registers. The return GRF writes may be in any order depending on the external function units. <src0> and <src1> are the lead GRF registers for the first and second block of the request respectively. <dest> is the lead GRF register for response. The message descriptor field <desc> contains the Message Length (the number of consecutive GRF registers corresponding to src0) and the Response Length (the number of consecutive GRF registers). It also contains the header present bit, and the function control signals. The extend message descriptor field <ex_desc> contains the target function ID, the Extended Message Length (the number of consecutive GRF registers corresponding to src1) and the extended function control signals. WrEn is forwarded to the target function in the message sideband.
The sends instruction is the only way to terminate a thread. When the EOT (End of Thread) bit of <ex_desc> is set, it indicates the end of thread to the EU, the Thread Dispatcher and, in most cases, the parent fixed function.
Message descriptor field <desc> can be a 32-bit immediate, imm32, or a 32-bit scalar register, <reg32a>. GEN restricts that the 32-bit scalar register <reg32a> must be the leading dword of the address register. It should be in the form of a0.0<0;1,0>:ud. When <desc> is a register operand, only the lower 31 bits of <reg32a> are used.
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 only. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:16 specify the 16bit extended function control. Interpretation of the extended function control signals is subject to the target external function.</ex_desc></ex_desc></ex_desc></ex_desc>
Extended Message descriptor field <ex_desc> can be a 32-bit immediate, imm32 or a 32bit scalar register, <reg32a>. The bits3:0 of the <ex_desc> specifies the SFID for the message.The EOT field always comes from bit127 of the instruction word, which is the bit5 of <ex_desc>. A thread must terminate with a sends instruction with EOT turned on. The bits9:6 of <ex_desc> specify the extended message length and bits31:12 specify the 20bit extended function control. Interpretation of the extended function control signals is subject to the target external function. The scalar register <reg32a> is selected when SelReg32ExDesc is set, ExDesc.RegNum[3:0] provides the addressing for reg32a for extended message descriptor. This selects one of the index sub registers. Subregisters selected are always aligned to dword. This implies, the even index subregisters must be used.</reg32a></ex_desc></ex_desc></ex_desc></reg32a></ex_desc>
Function control is now extended to 20 bits as specified in the below definition.
Function control is now extended to 20 bits as specified in the below definition.
The sum of Message Length and Extended Message Length must not be greater than 31.
<src0> is a 256-bit aligned GRF register. It serves as the leading GRF register of the request.
<src1> is a 256-bit aligned GRF register or a null register. It serves as the leading GRF register for the second block of the request when it is not a null register. It is required that the second block of GRFs does not overlap with the first block. If it is a null register the Extended Message Length must be 0. The sum of Message Length and Extended Message Length must not be greater than 15 on SKL.
The source dependency control, {NoSrcDepSet} is used to control the setting of source dependency for both the sources.
<dest> serves for two purposes: to provide the leading GRF register location for the response message if present, and to provide parameters to form the channel enable sideband signals.
<dest> signals whether there is a response to the message request. It can be either a null register, a direct-addressed GRF register or a register-indirect GRF register. Otherwise, hardware behavior is undefined.
If <dest> is null, there is no response to the request. Meanwhile, the Response Length field in <desc> must be 0. Certain types of message requests, such as memory write (store) through the Data Port, do not want response data from the function unit. If so, the posted destination operand can be null.
If <dest> is a GRF register, the register number is forwarded to the shared function. In this case, the target function unit must send one or more response message phases back to the requesting thread. The number of response message phases must match the Response Length field in <desc>, which of course cannot be zero. For some cases, it could be an empty return message. An empty return message is defined as a single phase message with all channel enables turned off.
The destination type field is always valid and is used to generate the WrEn. This is true even if <dest> is a null register (this is an exception for null as for most cases these fields are ignored by hardware).
The address immediates for indirect sources and destination must be oword aligned.
The 16-bit channel enables of the message sideband are formed based on the WrEn. Interpretation of the channel enable sideband signals is subject to the target external function. In general for a 'sends' instruction with return messages, they are used as the destination dword write mask for the GRF registers starting at <dest>. For a message that has multiple return phases, the same set of channel enable signals applies to all the return phases.
NoDDClr and NoDDChk must not be used for send instruction.
Send a message stored in GRF locations starting at <src0> followed by <src1> to a shared function identified by <ex_desc> along with control from <desc> and <ex_desc> with a GRF writeback location at <dest>.
Format:
[(pred)] sends (exec_size) <dest> <src0> <src1> <ex_desc> <desc>
Dot Product 4 Accumulate
DP4A is a packed four-wide integer dot product and accumulate operation.
Each source's 32-bit channel value is treated as four element vector of 8-bit integer values.
The operation performs a 32-bit precision dot product of those four bytes and adds it with a 32-bit accumulator (typically a GRF, not necessarily an acc# reg).
Format: [(pred)] dp4a (exec_size) dst src0 src1 src2
EXAMPLE (SIMD1 for simplicity):
mov  (1) r1.0:d  0x0102037F:d // (char4)(0x1,0x2,0x3,0x7F)
mov  (1) r2.0:d  50:d
dp4a (1) r3.0:d  r2:d r1:d r1:d
// r3.0 = 50 + (0x1*0x1 + 0x2*0x2 + 0x3*0x3 + 0x7F*0x7F)
//      = 50 + (1 + 4 + 9 + 16129)
//      = 16193
The else instruction is an optional statement within an if/else/endif block of code. It restricts execution within the else/endif portion to the opposite set of channels enabled under the if/else portion. Channels which were inactive prior to entering the if/endif block remain inactive throughout the entire block.
All enabled channels upon arriving the else instruction will be redirected to the matching endif. If all channels are redirected (by else or before else), a relative jump is performed to the location specified by  <JIP>. The jump target should be the matching endif instruction for that conditional block.
The following table describes the 32-bit <JIP>. In GEN binary, <JIP> is at location <src1> and must be of type D (signed dword integer). <JIP> must be an immediate operand, it is a signed 32-bit number and is intended to be forward referencing. This value is added to IP pre-increment.
If the <branch_ctrl> bit is set, then the <JIP> points to the first join instruction within the else block and <UIP> points to the endif instruction. If the <branch_ctrl> bit is not set,  <JIP> and <UIP>, both point to endif.
Format:
else (exec_size) JIP  UIP  branch_ctrl
An else instruction must not be followed by any instruction requiring register indirect access on source operands
The mad instruction takes component-wise multiplication of src1 and src2, adds the results with the corresponding src0 values, and then stores the final results in dst.
The conditional modifier and saturation (.sat) must not be used when src1 or src2 are dwords.
Plane and Linear Interpolation instructions are removed. The following macros must be used to emulate Plane and Linear Interpolation operations.
Plane Instruction Emulation
The below plane instruction
pln (16) r20.0<1>:f r10.4<0;1,0>:f r4.0<8;8,1>:f
is emulated as below
mad (8) acc0<1>:nf r10.7<0;1,0>:f r4.0<8;8,1>:f r10.4<0;1,0>:f
mad (8) r20.0<1>:f acc0<8;8,1>:nf r5.0<8;8,1>:f r10.5<0;1,0>:f
mad (8) acc0<1>:nf r10.7<0;1,0>:f r6.0<8;8,1>:f r10.4<0;1,0>:f
mad (8) r21.0<1>:f acc0<8;8,1>:nf r7.0<8;8,1>:f r10.5<0;1,0>:f
In case of SIMD8 pln instruction only the first pair of mad instructions are used.
Linear Interpolation Instruction Emulation
The below lrp instruction
lrp (16) r40.0<1>:f r10.0<8;8,1>:f r20.0<8;8,1>:f r30.0<8;8,1>:f
is emulated as below
mad (8) acc0<1>:nf r30.0<8;8,1>:f r10.0<8;8,1>:f r20.0<8;8,1>:f
mad (8) r40.0<1>:f acc0<8;8,1>:nf -r10.0<8;8,1>:f r30.0<8;8,1>:f
mad (8) acc0<1>:nf r31.0<8;8,1>:f r11.0<8;8,1>:f r21.0<8;8,1>:f
mad (8) r41.0<1>:f acc0<8;8,1>:nf -r11.0<8;8,1>:f r31.0<8;8,1>:f
In case of SIMD8 lrp instruction only the first pair of mad instructions are used.
Format:
[(pred)] mad[.cmod] (exec_size) dst src0 src1 src2
The math instruction performs extended math function on the components in src0, or src0 and src1, and write the output to the channels of dst. The type of extended math function are based on the FC[3:0] encoding in the table below.
Format:
[(pred)] math.<FC> (exec_size) dst src0 src1
Rotate Left
Perform component-wise logical rotate left operation of the bits in src0 by the rotate count indicated in src1, storing the result in dst. src0 and src1 are treated as unsigned numbers with only the bits within the specified datatype used during this operation. This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers are supported. Extra precision bits available in accumulator are ignored during this operation and only the bits within the specified datatype are used.
src0 and dst must be of same datatype precision.
Format: [(pred)] rol[.cmod] (exec_size) dst src0 src1
Rotate Right
Perform component-wise logical rotate right operation of the bits in src0 by the rotate count indicated in src1, storing the result in dst. src0 and src1 are treated as unsigned numbers with only the bits within the specified datatype used during this operation. This operation does not produce sign or overflow conditions. Only the .e/.z or .ne/.nz conditional modifiers are supported. Extra precision bits available in accumulator are ignored during this operation and only the bits within the specified datatype are used.
src0 and dst must be of same datatype precision.
Format: [(pred)] ror[.cmod] (exec_size) dst src0 src1
LoopVersioningLICM's minimum allowed percentageof possible invariant instructions per loop
__builtin_IB_sub_group_reduce_OpGroupUMin
licm-versioning-max-depth-threshold
invalid '.comm' or '.lcomm' directive alignment, can't be less than zero
LoopVersioningLICM's threshold for maximum allowed loop nest/depth
DCL_HSPatchConstInputVec@
llvm.mem.parallel_loop_access
unexpected token in '.include' directive
likely-branch-weight
__builtin_IB_sub_group_reduce_OpGroupFAdd
Weight of the branch likely to be taken (default = 2000)
unlikely-branch-weight
DCL_HSinputVec@
Weight of the branch unlikely to be taken (default = 1)
kernel_arg_type
guards-predicate-pass-branch-weight
__builtin_IB_sub_group_reduce_OpGroupFMax
The probability of a guard failing is assumed to be the reciprocal of this value (default = 1 << 20)
Could not find include file '
deopt
DCL_ShaderInputVec@
MemCpy Optimization
Count is negative
memcpyopt
__builtin_IB_sub_group_reduce_OpGroupFMin
newgvn-vn
unexpected token in '.endr' directive
Controls which instructions are value numbered
DCL_SystemValue@
newgvn-phi
Invalid line no
Controls which instructions we create phi of ops for
__builtin_IB_sub_group_scan_OpGroupIAdd
enable-store-refinement
no matching '.endr' in definition
enable-phi-of-ops
DCL_input@
spp-all-backedges
expected comma in '.irpc' directive
spp-counted-loop-trip-width
__builtin_IB_sub_group_scan_OpGroupSMax
spp-split-backedge
invalid '.comm' or '.lcomm' directive size, can't be less than zero
spp-no-entry
DCL_inputVec@
spp-no-call
spp-no-backedge
__builtin_IB_sub_group_scan_OpGroupUMax
unexpected token in '.irpc' directive
spp-print-liveset
EndPrimitive@
spp-print-liveset-size
spp-print-base-pointers
__builtin_IB_sub_group_scan_OpGroupSMin
spp-rematerialization-threshold
negative file number
rs4gc-clobber-non-live
EnqueuedLocalSizeLocation@
rs4gc-allow-statepoint-with-no-deopt-info
Align16
__builtin_IB_sub_group_scan_OpGroupUMin
nullptr
in '
GetBufferPtr@
__llvm_deoptimize
inconsistent use of MD5 checksums
Sparse Conditional Constant Propagation
__builtin_IB_sub_group_scan_OpGroupFAdd
sccp
expected '!' here
sroa-random-shuffle-slices
GetPixelMask@
sroa-strict-inbounds
Can't analyze slices for alloca: 
__builtin_IB_sub_group_scan_OpGroupFMax
  A pointer to this alloca escaped by:
unexpected token in '.line' directive
Slices of alloca: 
GlobalDataAccess@
.sroa.
is_stmt value not the constant value of 0 or 1
 slice #
__builtin_IB_sub_group_scan_OpGroupFMin
 (splittable)
 for .file directives
  used by: 
GlobalSizeLocation@
sroa_raw_cast
sroa_raw_idx
BlockReadLocal not supported!
sroa_cast
isa number less than zero
sroa_idx
GradientX@
sroa
expected checksum kind in '.cv_file' directive
load.ext
BlockWriteLocal not supported!
endian_shift
unexpected token in '.bundle_unlock' directive
insert
GradientXfine@
.shift
xOffset
.ext
.insert
Symbol Relocation Analysis provides info needed to generate symbol and relocation entries
load.trunc
---- InsEltMap ----
.expand
yOffset
blend
expected integer in '
oldload
GradientYfine@
copyload
isplat
simdSize
vsplat
unexpected token in '.cv_inline_site_id' directive
.fca
GridOriginLocation@
.gep
unknown sub-directive in '.cv_loc' directive
.load
simdLaneId16
.sroa.speculated
missing 'distinct', required for !DISubprogram when 'isDefinition'
.sroa.speculate.load.
GridSizeLocation@
.sroa.speculate.load.true
.sroa.speculate.load.false
simdLaneId
SROA
unexpected token in '.cv_linetable' directive
Scalar Replacement Of Aggregates
GroupIdLocation@
unexpected tokens
disable-separate-const-offset-from-gep
Shuffle not supported in SIMD32
Do not separate the constant offset from a GEP instruction
Expected an identifier
reassociate-geps-verify-no-dead-code
GsCutControlHeader@
Verify this pass produces no dead code
NoDDClr
uglygep
simdShuffle
enable-nontrivial-unswitch
 in '.cv_fpo_data' directive
Forcibly enables non-trivial loop unswitching rather than following the configuration passed into the pass.
GsStreamHeader@
unswitch-threshold
expected identifier in '.macro' directive
The cost threshold for unswitching a loop.
Shuffle Down not supported in SIMD32
.split
expected line number after 'inlined_at'
bonus-inst-threshold
HSURBPatchHeaderRead@
Control the number of bonus instructions (default = 1)
BreakPoint
keep-loops
simdShuffleDown
Preserve canonical loop structure (default = true)
Vararg parameter '
switch-to-lookup
IEEE_Divide@
Convert switches to lookup tables (default = false)
  Root Value : 
forward-switch-cond
Block reads not supported in SIMD32
Forward switch condition to phi ops (default = false)
macro defined with named parameters which are not used in macro body, possible positional parameter found in body which will have no effect
sink-common-insts
IEEE_Sqrt@
Sink common instructions (default = false)
AccWrEn
merge
Block writes not supported in SIMD32
simplifycfg
' is already defined
Simplify the CFG
InitDiscardMask@
spec-exec-max-speculation-cost
unexpected token in '.end' directive
Speculative execution is not applied to basic blocks where the cost of the instructions to speculatively execute exceeds this limit.
SIMD Media Block Read not supported in SIMD32
spec-exec-max-not-hoisted
integer constant must have integer type
Speculative execution is not applied to basic blocks where the number of instructions that would not be speculatively executed exceeds this limit.
InnerScalarTessFactors@
spec-exec-only-if-divergent-target
NoCompact
Speculative execution is applied only to targets with divergent branches, even if the pass was configured to apply only to all targets.
SIMD Media Block Write not supported in SIMD32
structurizecfg-skip-uniform-regions
.err encountered
Force whether the StructurizeCFG pass skips uniform regions
Interpolant@
lpad
expression is negative
lpad.phi
width argument supplied to intel_media_block_read*() must be constant.
expected relocation name
_crit_edge
Interpolate@
Break critical edges in CFG
NoPreempt
break-crit-edges
height argument supplied to intel_media_block_read*() must be constant.
cstr
expected comma
strlen
Interpolate2@
strchr
expected double quoted string after .print
strncmp
width argument supplied to intel_media_block_write*() must be constant.
strncpy
GradientY@
__memcpy_chk
IsHelperInvocation@
memchr
memcmp
height argument supplied to intel_media_block_write*() must be constant.
putchar
expected identifier in '.addrsig_sym' directive
chari
igc-symbols-relocation-analysis
puts
       
fputc
intel_media_block_read
fputc_unlocked
dword ptr 
fputs
LocalSizeLocation@
fputs_unlocked
malloc
intel_media_block_write
calloc
word ptr 
fgetc_unlocked
MediaBlockRead@
fgets_unlocked
enable-noalias-to-md-conversion
width for 
Convert noalias attributes to metadata during inlining.
unassigned file number: 
preserve-alignment-assumptions-during-inlining
MediaBlockRectangleRead@
Convert align attributes to assumptions during inlining.
kernel_arg_type_qual
savedstack
*() must be <= 
.exit
while in macro instantiation
ptrint
MediaBlockWrite@
maskedptr
' (no symbols present)
maskcond
height for 
FastStage1
: argument 
OUTPUT@
.lpad-body
csel
eh.lpad-body
 bytes wide 
thinlto_src_module
invalid variant on expression '
------- Dumping inliner stats for [
OUTPUTGS@
] -------
expected '(' after operator
-- List of inlined functions:
*() attempt of 
Inlined 
' with wrong type!
imported 
OUTPUTGS2@
not imported 
.text
function [
 bytes.  Must be <= 
: #inlines = 
, #inlines_to_importing_module = 
OWordPtr@
-- Summary:
---- Multi-value Alias (value in both AliasMap & InsEltMap) ----
All functions: 
 bytes.
, imported functions: 
.type
inlined functions
OuterScalarTessFactors@
all functions
imported functions inlined anywhere
_uc*() widths must be quad pixel aligned.
imported functions
.scl
imported functions inlined into importing module
OutputTessControlPoint@
, remaining
.linkonce
non-imported functions inlined anywhere
_us*() widths must be dual pixel aligned.
non-imported functions
unable to create block named '
non-imported functions inlined into importing module
OutputTessFactors@
% of 
verify-loop-lcssa
Resolves sub group functions
Verify loop lcssa form (time consuming)
.rva
lcssa
PHASE_INPUT@
Loop-Closed SSA Form Pass
.seh_pushreg
cond
igc-sub-group-func-resolution
.noexc
.seh_stackalloc
PHASE_OUTPUT@
.lr.ph
binary size is too small
.preheader
SubGroupFuncsResolution
.outer
.seh_setframe
loop-simplify
PatchConstantOutput@
Canonicalize natural loops
unexpected token in section switching directive
unroll-runtime-epilog
invariant.load
Allow runtime unrolled loops to be unrolled with epilog instead of prolog.
.def
unroll-verify-domtree
PixelPositionX@
Verify domtree after unrolling
FullyUnrolled
p%d:32:32:32
completely unrolled loop with 
cbit
 iterations
SymbolRelocation Analysis
Peeled
  Root Value: 
 peeled loop by 
p%d:
PeelCount
half4x2
 with a breakout at trip 
PullCentroidBarys@
BreakoutTrip
PartialUnrolled
-p%d:32:32:32
unrolled loop by a factor of 
same_contents
 trips per branch
PullSampleIndexBarys@
 with run-time trip count
' is already linkonce
unroll-peel-max-count
Tries to convert stateless to statefull accesses
Max average trip count which will cause loop peeling.
PixelPositionY@
unroll-force-peel-count
PullSnappedBarys@
Force a peel count regardless of profiling information.
kernel_arg_base_type
.peel.begin
igc-stateless-to-statefull-resolution
.peel.next
invalid '.rva' directive offset, can't be less than -2147483648 or greater than 2147483647
.peel.newph
QuadPrefix@
.peel
you must specify an offset on the stack
unroll-runtime-multi-exit
StatelessToStatefull
Allow runtime unrolling for loops with multiple exits, when epilog is generated
.alt_entry
.new
ROUNDNE@
.unr-lcssa
.epil.preheader
Emit linker warnings to user
.prol.preheader
expected @code
.prol.loopexit
RTDualBlendSource@
xtraiter
.pushsection
lcmp.mod
undefined-references
unroll_iter
too many arguments specified
niter
RTWrite@
.nsub
.ncmp
undefined reference to `
epil
.popsection
prol
RenderTargetRead@
.iter
 [aliasee]
.cmp
.unr
.const_data
.epilog-lcssa
RenderTargetReadSampleFreq@
.loopexit
loop-version-annotate-no-alias
Add no-alias annotation for instructions that are disambiguated by memchecks
.const
RuntimeValue@
Lower SwitchInst's to branches
.fvmlib_init1
lowerswitch
UndefinedReferencesPass
NewDefault
expected 'from' after catchret
NodeBlock
SampleOffsetX@
Pivot
rndu
LeafBlock
Resolve WG built-in
SwitchLeaf
.lazy_symbol_pointer
mem2reg
SampleOffsetY@
Promote Memory to Register
.non_lazy_symbol_pointer
verify-predicateinfo
igc-wg-resolution
Verify PredicateInfo in legacy printer pass.
.objc_cat_cls_meth
predicateinfo-rename
SetDebugReg@
Controls which variables are renamed with predicateinfo
rnde
phi-node-folding-threshold
WGFuncResolution
Control the amount of phi node folding to perform (default = 2)
.thread_local_variable_pointer
simplifycfg-dup-ret
SetStream@
Duplicate return instructions into unconditional branches
.objc_cls_meth
simplifycfg-sink-common
cmpDim
Sink common instructions down to the end block
.end_data_region
simplifycfg-hoist-cond-stores
StackAlloca@
Hoist conditional stores if an unconditional store precedes
simplifycfg-merge-cond-stores
tmpOffsetR0
Hoist conditional stores even if an unconditional store does not precede - hoist multiple conditional stores into a single predicated store
.objc_cls_refs
simplifycfg-merge-cond-stores-aggressively
kernel_arg_addr_space
When merging conditional stores, do so even if the resultant basic blocks are unlikely to be if-converted as a result
       
speculate-one-expensive-inst
offsetR0
Allow exactly one expensive instruction to be speculatively executed
.objc_selector_strs
max-speculation-depth
URBReadOutput@
Limit maximum recursion depth when calculating costs of speculatively executed instructions
.old
groupId
or.cond
.objc_protocol
not.cond
URBWrite@
and.cond
.symbol_stub
.sink.split
globalOffset
switch.edge
expected ',' after compare value
.fold.split
UpdateDiscardMask@
magicptr
kernel_arg_name
infloop
numGroups
switch.early.test
.tdata
spec.store.select
VirtualBindingTableBaseLocation@
spec.select
.macosx_version_min
.critedge
grid_origin
brmerge
.alt_entry must preceed symbol definition
.mux
WaveAll@
condstore.split
madm
simplifycfg.merge
grid_size
switch.selectcmp
.build_version
switch.select
WaveBallot@
no-jump-tables
unexpected token in '.indirect_symbol' directive
switch.lookup
Resolves work item functions
switch.tableidx
.objc_module_info
switch.hole_check
WaveClustered@
switch.maskindex
switch.shifted
igc-wi-func-resolution
switch.lobit
unexpected token in '.lsym' directive
switch.table.
WaveInverseBallot@
switch.idx.cast
 [aliasee]  
switch.idx.mult
WIFuncResolution
switch.offset
__textcoal_nt
switch.cast
WavePrefix@
switch.shiftamt
out of dynamic memory in yy_create_buffer()
switch.downshift
__builtin_IB_get_global_offset
switch.masked
unexpected token in '.section' directive
switch.tableidx.zext
WaveShuffleIndex@
switch.gep
section "
switch.load
__builtin_IB_get_work_dim
inverted.cmp
'filter' clause has an invalid type
indvars
WorkGroupAny@
iv.rem
invalid type for alloca
.urem
__builtin_IB_get_sync_buffer
.udiv
" is deprecated
enable-double-float-shrink
add_pair@
Enable unsafe double to float shrinking for math lib calls
.secure_log_unique used but AS_SECURE_LOG_FILE environment variable unset.
endptr
Analyzes work item functions
strchr
URBRead@
strrchr
add_rtz@
strcmpload
else
strlenfirst
igc-wi-func-analysis
strpbrk
can't open secure log file: 
strstr
atomiccounterinc@
memchr.bounds
expected segment name after '.zerofill' directive
memchr.bits
WIFuncsAnalysis
memchr
expected identifier after '.section' directive
lhsc
atomiccounterpredec@
lhsv
while
rhsc
Sets a limit on unrolling metadata to control compile time
rhsv
chardiff
apple.cl.arg_metadata
memcmp
---- Phi-Var Isolations ----
real
igc-clamp-loop-unroll
imag
__constructor
cabs
 (function: 
reciprocal
igc-workaround
square
ClampLoopUnroll
isinf
__bss
log2
vISA_GenerateISAASM
log10
expected string in '
logmul
Converts 3d images access to 2d array image accesses where possible
bfi@
tanf
broadcastMessagePhaseV@
tanl
vISA_DumpIsaVarNames
cttz
igc-3d-to-2darray
ctlz
__literal16
isdigittmp
cmpSADs@
isdigit
__OBJC
isascii
Image3dToImage2darray
__cat_inst_meth
cmpxchgatomicstructured@
iprintf
vISA_DumpvISA
converts get_local_size() to get_enqueued_local_size()
leninc
__cat_cls_meth
siprintf
createMessagePhases@
fiprintf
__inst_meth
__sincospif_stret
igc-rewrite-local-size
__sincospi_stret
unexpected token in '.end_data_region' directive
sincospi
createMessagePhasesNoInit@
sinpi
vISA_ISAASMNamesFile
cospi
RewriteLocalSize
instcombine
__instance_vars
simplify-libcalls
createMessagePhasesNoInitV@
folded strlen(select) to select of constants
Var isolated : 
disable-basicaa
srem
NoAlias
VISA_AsmFileName
MustAlias
createMessagePhasesV@
MayAlias
__symbol_stub
PartialAlias
urem
External Alias Analysis
__picsymbol_stub
external-aa
vISA_CISAbinary
Function Alias Analysis Results
invalid OS major version number, integer expected
sext
alias-set-saturation-threshold
va_arg
The maximum number of pointers may-alias sets may contain before degradation
discard@
  AliasSet[
vISA_PlatformIsSet
must
addconv
invalid OS major version number
 alias, 
dp4a_ss@
No access 
 used while targeting 
Ref       
diff.neg
Mod       
__symbols
Mod/Ref   
dp4a_su@
[volatile] 
vISA_ReRAPostSchedule
 forwarding to 
.not
Pointers: 
overriding previous version directive
    
dp4a_us@
 Unknown instructions: 
version number required, comma expected
Alias Set Tracker: 
 alias sets for 
vISA_setA0toTdrForSendc
 pointer values.
dp4a_uu@
verify-assumption-cache
.data.rel.ro
Enable verification of assumption cache
notmask
Assumption in scanned function not in cache
 in '.build_version' directive
Assumption Cache Tracker
assumption-cache-tracker
Leader : 
basicaa-recphi
.masked
basicaa
.protected
Basic Alias Analysis (stateless AA impl)
eu_id@
view-block-freq-propagation-dags
vISA_replaceIndirectCallWithJmpi
Pop up a window to show a dag displaying how block frequencies propagation through the CFG.
and.shrunk
view-bfi-func-name
.local
The option to specify the name of the function whose CFG will be displayed.
eu_thread_id@
view-hot-freq-percent
.fini_array.
An integer in percent used to specify the hot blocks/edges to be displayed in red: a block or edge whose frequency is no less than the max frequency of the function multiplied by this percent.
bitfield
pgo-view-counts
print pass structure before run()
A boolean option to show CFG dag or text with block profile counts and branch probabilities right after PGO profile annotation step. The profile counts are computed using branch probabilities from the runtime profile data and block frequency propagation algorithm. To view the raw counts from the profile, use option -pgo-view-raw-counts instead. To limit graph display to only one function, use filtering option -view-bfi-func-name.
eu_thread_pause@
do not show.
vISA_InsertDummyCompactInst
graph
notlhs
show a graph.
.preinit_array.
text
evaluateSampler@
show in text.
init_array
print-bfi
notrhs
Print the block frequency info.
preinit_array
print-bfi-func-name
extractMVAndSAD@
The option to specify the name of the function whose block frequency info is printed.
vISA_easyIsaasm
BlockFrequencyDAGs
.demorgan
block-frequency-info: 
fini_array
: float = 
f32tof16_rtz@
, int = 
llvm_call_graph_profile
, count = 
igc-instcombine-guard-widening-window
, irr_loop_header_weight = 
.weakref
Block Frequency Analysis
fcmpxchgatomicraw@
block-freq
vISA_dumpTimer
error opening file '
How wide an instruction window to bypass looking for another guard
' for writing!
unknown section type
 done. 
fcmpxchgatomicrawA64@
digraph "
    
blendv
digraph unnamed {
vISA_clearAccBeforeEOT
label="
fcmpxchgatomicstructured@
Node
Resource indirection pass
 [shape=record,
exec
label="{
invalid group name
}"];
-dot
color="red"
expected commma
Unknown
thunk
 -> Node
llvm.module.flags
 node
label="%.1f%%"
expected STT_<TYPE_IN_UPPER_CASE>, '#<type>', '@<type>', '%<type>' or "<type>"
,color="red"
nest
print-bpi
opt-bisect-limit
Print the branch probability info.
-dumpVisaOptionsAll
print-bpi-func-name
unexpected token in '.ident' directive
The option to specify the name of the function whose branch probability info is printed.
nvptx-f32ftz
---- Branch Probabilities ----
expected group name
-gtpin
edge 
expected integer count in '.cg_profile' directive
 probability is 
unmaskedload
 [HOT edge]
NumCounts
Branch Probability Analysis
Maximum size for the name of non-global values.
branch-prob
No relocation available to represent this relative expression
Inclusion-Based CFL Alias Analysis
.splatinsert
cfl-anders-aa
Base nodes must have at least two operands
Unification-Based CFL Alias Analysis
-enableSendFusion
.strtab
Invalidating all non-preserved analyses for: 
.splat
Invalidating analysis: 
cosl
Call graph node for function: '
sampler_t
Call graph node <<null function>>
coalesce moves coming from phi nodes
castvec
>>  #uses=
.llvm.call-graph-profile
.symtab_shndxr
  CS<
fma_rtz@
> calls 
Size expression must be absolute.
function '
tmpcast
external node
-nomacopt
No call graph has been built!
fsat@
CallGraph Construction
FK_Data_8
basiccg
max-cg-scc-iterations
FK_PCRel_2
CallGraph Pass Manager
ftof_rtn@
Call Graph SCC Pass Manager
-noregrenaming
size-info
.lobit
Print CallGraph IR
FK_PCRel_1
Printing <null> Function
ftof_rtp@
acos
FK_GPRel_8
asin
.mask
atan
FK_DTPRel_8
atan2
ftof_rtz@
acosf
-optreport
asinf
atanf
FK_DTPRel_4
atan2f
ftoi_rte@
cosh
FK_SecRel_8
ceilf
.unshifted
coshf
llvm intrinsics cannot be defined!
expf
ftoi_rtn@
fmod
-disableHFOpt
fmodf
.idx
logf
FK_Data_Add_1
log10f
ftoi_rtp@
roundf
DeSSA
sinh
.sext
sinhf
Disable emission of the extended flags in .loc directives.
tanh
ftoui_rte@
tanhf
-noScalarJmp
__acos_finite
.add
__acosf_finite
dwarf-extended-loc
__asin_finite
ftoui_rtn@
__asinf_finite
__atan2_finite
to.ptr
__atan2f_finite
Attributes 'readnone and readonly' are incompatible!
__cosh_finite
ftoui_rtp@
__coshf_finite
-accSubPostSchedule
__exp_finite
.ptr
__expf_finite
NO_APP
__exp2_finite
gather4Cptr@
__exp2f_finite
.short
__log_finite
.conv
__logf_finite
FK_Data_Sub_8
__log10_finite
gather4POCptr@
__log10f_finite
.weak
__pow_finite
sadd
__powf_finite
-no4GRFSplit
__sinh_finite
gather4POptr@
__sinhf_finite
expected relocatable expression
sadd.result
expected assembly-time absolute expression
da-delinearize
gather4ptr@
Try to delinearize array references.
-expandPlane
 Empty
sadd.overflow
 Any
unsupported subtraction of qualified symbol
 Point is <
image
Collect information related to domain shader
 Distance is 
umul
*X + 
 bytes
*Y = 
getGlobalSize@
 Line is 
-enablePreemption
enable-unsafe-globalsmodref-alias-results
umul.value
Globals Alias Analysis
unable to write NOP sequence of 
globals-aa
getGridOrigin@
IV Users for loop 
  Sections:[
    
 with backedge-taken count 
.cast
 (post-inc with loop 
getEnqueuedLocalSize@
 in  
getGridSize@
Printing <null> User
igc-resource-indirection-pass
icp-remaining-percent-threshold
.val
The percentage threshold against remaining unpromoted indirect call count for the promotion
    
icp-total-percent-threshold
getGroupId@
The percentage threshold against total count for the promotion
' is not a divisor of padding size '
icp-max-prom
storemerge
Max number of promotions for a single indirect call callsite
<stdin>
inline-threshold
getLocalId@
Control the amount of inlining to perform (default = 225)
-foldEOT
inlinehint-threshold
.sub
Threshold for inlining functions with inline hint
unable to write nop sequence of 
inline-cold-callsite-threshold
getLocalSize@
Threshold for inlining cold callsites
linetable_begin
inlinecold-threshold
.unpack
Threshold for inlining functions with cold attribute
local variable requires a valid scope
hot-callsite-threshold
getMessagePhase@
Threshold for hot callsites 
Allocation failed
locally-hot-callsite-threshold
.repack
Threshold for locally hot callsites 
-noipa
cold-callsite-rel-freq
getMessagePhaseV@
Maxmimum block frequency, expressed as a percentage of caller's entry frequency, for a callsite to be cold in the absence of profile information.
igc-collect-domain-shader-properties
hot-callsite-rel-freq
suba
Minimum block frequency, expressed as a multiple of caller's entry frequency, for a callsite to be hot in the absence of profile information.
inline-cost-full
getMessagePhaseX@
Compute the full inline cost of a call site even when the cost exceeds the threshold.
inconsistent use of embedded source
      NumConstantArgs: 
subc
      NumConstantOffsetPtrArgs: 
-noindirectforcespills
      NumAllocaArgs: 
getMessagePhaseXV@
      NumConstantPtrCmps: 
 redeclared as different type
      NumConstantPtrDiffs: 
mulconv
      NumInstructionsSimplified: 
.comment
      NumInstructions: 
getSR0@
      SROACostSavings: 
-verifyra
      SROACostSavingsLost: 
igc-instcombine-max-num-phis
      LoadEliminationCost: 
Emitting values inside a locked bundle is forbidden
      ContainsNoDuplicateCall: 
getSimdGroupSize@
      Cost: 
.bundle_unlock without matching lock
      Threshold: 
Maximum number phis to handle in intptr/ptrint folding
inline-cost
A Bundle can only have one Subtarget.
 has uninlinable pattern and cost is not fully computed
globalSync@
 is recursive and allocates too much stack space. Cost is not fully computed
-noloopra
Lazy Branch Probability Analysis
lazy-branch-prob
Empty bundle-locked group is forbidden
Lazy Block Frequency Analysis
hw_thread_id@
lazy-block-freq
Lazy Value Information Analysis
lazy-value-info
Intervals are contiguous
; LatticeVal for: '
ibfe@
' is: 
-nospillcleanup
' in BB: '
.shrunk
available-load-scan-limit
-noremat
Use this to specify the default maximum number of instructions to scan backward from a given instruction, when searching for available loaded value
image1d_t
force-vector-width
Lower inputs outputs for domain shader
Sets the SIMD width. Zero is autoselect.
extract
force-vector-interleave
INDNTPOFF
Sets the vectorization interleave count. Zero is autoselect.
icmpxchgatomicrawA64@
runtime-memory-check-threshold
-spilloffset
When performing memory disambiguation checks at runtime do not generate more than this number of comparisons (default = 8).
extract.t
memory-check-merge-threshold
GOTTPOFF
Maximum number of comparisons done when trying to merge runtime memory checks. (default = 100)
icmpxchgatomictyped@
max-dependences
TLSLDM
Maximum number of dependences collected by loop-access analysis (default = 100)
narrow
enable-mem-access-versioning
inlinable function call in a function with debug info must have a !dbg location
Enable symbolic stride memory access versioning
imulH@
store-to-load-forwarding-conflict-detection
Resource Indirection Pass
Enable conflict detection in loop-access analysis
not.
enable-mssa-loop-dependency
TPOFF
Enable MemorySSA dependency for loop pass manager
intatomicraw@
<unnamed loop>
PAGE
verify-loop-info
.inv
Verify loop info (time consuming)
GOTPAGE
 (loop: 
intatomicrawA64@
; Preheader:
-verifyaugmentation
; Loop:
.Elt
Printing <null> block
PAGEOFF
; Exit blocks
intatomictyped@
Natural Loop Information
GOT_PREL
loops
.lhs
<deleted loop>
GOTPCREL
<deleted>
is_uniform@
Loop Pass Manager
-presched-ctrl
Print Loop IR
.rhs
LCSSA Verifier
target1
lcssa-verification
itof_rtn@
Loop Pass Manager
igc-domain-shader-lowering
memdep-block-scan-limit
.extract
The number of instructions to scan in a block in memory dependency analysis (default = 100)
diff8
memdep-block-number-limit
itof_rtp@
The number of blocks to scan during memory dependency analysis (default = 1000)
-enable-noDD
memdep
Memory Dependence Analysis
hlo8
memssa-check-limit
itof_rtz@
The maximum number of stores/phis MemorySSAwill consider trying to walk past (default = 100)
higha
verify-memoryssa
instcombine-visit
Verify MemorySSA in legacy printer pass.
masked_store: storee must match pointer type
 = MemoryDef(
ldmcsptr@
 = MemoryPhi(
-disable-noSrcDep-scen1
MemoryUse(
Controls which instructions are visited
Memory SSA
highera
memoryssa
ldmsptr@
force-summary-edges-cold
toc@l
Force all edges in the function summary to cold
igc-expensive-combines
None.
toc@ha
all-non-critical
ldmsptr16bit@
All non-critical edges.
-nofuse-typedWrites
All edges.
Enable expensive instruction combines
llvm.compiler.used
toc@h
Module Summary Analysis
ldptr@
module-summary-analysis
tprel@higha
ObjC-ARC-Based Alias Analysis
igc-instcombine-maxarray-size
objc-arc-aa
icmpxchgatomicraw@
enable-objc-arc-opts
ldraw_indexed@
enable/disable all ARC Optimizations
-schedulerwindow
opt-remark-emitter
Maximum array size considered when doing a combine
PHITransAddr: null
tprel@higher
PHITransAddr: 
image2d_t
  Input #
/// Inlined ASM
 is 
igc-instcombine-lower-dbg-declare
.phi.trans.insert
dtprel@higher
Phi Values Analysis
ldstructured@
phi-values
-readSuppressionDepth
Post-Dominator Tree Construction
phitmp
postdomtree
dtprel@higha
profile-summary-cutoff-hot
lodptr@
A count is hot if it exceeds the minimum count to reach this percentile of total counts.
got@tprel@h
profile-summary-cutoff-cold
trunc
A count is cold if it is below the minimum count to reach this percentile of total counts.
EH pad jumps through a cycle of pads
profile-sample-accurate
memoryfence@
If the sample profile is accurate, we will mark all un-sampled callsite as cold. Otherwise, treat un-sampled callsites as if we have no profile.
Advanced Code Motion
profile-summary-huge-working-set-size-threshold
The code working set size is considered huge if the number of blocks required to reach the -profile-summary-cutoff-hot percentile exceeds this count.
got@tprel@ha
Desired percentile exceeds the maximum cutoff
mov_identity@
Profile summary info
got@tlsgd@h
profile-summary-info
SmallVector capacity overflow during allocation
<Function Return>
got@tlsld
 => 
movcr@
-dumpcommonisa
Region tree:
Allocation failed
End region tree
got@tlsgd@ha
verify-region-info
movflag@
Verify region info (time consuming)
PCREL
print-region-style
igcinstcombine
style of printing regions
dtprel@high
print no details
mul_pair@
-disableIGASyntax
print regions in detail with block_iterator
.offs
LO16
print regions in detail with element_iterator
mul_rtz@
scalar-evolution-max-iterations
/// End Inlined ASM
Maximum number of iterations SCEV will symbolically execute a constant derived loop
verify-scev
ldrawvector_indexed@
Verify ScalarEvolution's backedge taken counts (slow)
pair_to_ptr@
verify-scev-maps
GOTREL
Verify no dangling value in ScalarEvolution's ExprValueMap (slow)
not_intrinsic
scev-mulops-inline-threshold
IEGOT
Threshold for inlining multiplication operands into a SCEV
patchInstanceId@
scev-addops-inline-threshold
rel64
Threshold for inlining addition operands into a SCEV
llvm.genx.GenISA.CatchAllDebugLine
scalar-evolution-max-scev-compare-depth
expression could not be evaluated
Maximum depth of recursive SCEV complexity comparisons
ptr_to_pair@
scalar-evolution-max-scev-operations-implication-depth
-CISAbinary
Maximum depth of recursive SCEV operations implication analysis
llvm.genx.GenISA.DCL.DSCntrlPtInputVec
scalar-evolution-max-value-compare-depth
Allocation failed
Maximum depth of recursive value complexity comparisons
readsurfaceinfoptr@
scalar-evolution-max-arith-depth
 Value:
Maximum depth of recursive arithmetics
llvm.genx.GenISA.DCL.DSInputTessFactor
scalar-evolution-max-constant-evolving-depth
MCAlignFragment
Maximum depth of recursive constant evolving
resinfoptr@
scalar-evolution-max-cast-depth
-getfreegrfinfo
Maximum depth of recursive SExt/ZExt/Trunc
llvm.genx.GenISA.DCL.DSPatchConstInputVec
scalar-evolution-max-add-rec-size
 Kind:
Max coefficients in AddRec during evolving
rsq@
(trunc 
MCDwarfFragment
(zext 
llvm.genx.GenISA.DCL.GSinputVec
(sext 
AddrSpaceCast vector pointer number of elements mismatch
sampleBCptr@
-clearAccBeforeEOT
nuw><
llvm.genx.GenISA.DCL.GSsystemValue
nsw><
-generateDebugInfo
nw><
image3d_t
 umax 
INTEL_PATCH_PRIVATE_MEMORY_SIZE
 smax 
llvm.genx.GenISA.DCL.HSControlPointID
<nuw>
 HasInstructions:
<nsw>
sampleCptr@
 /u 
-insertDummyCompactInst
sizeof(
llvm.genx.GenISA.DCL.HSOutputCntrlPtInputVec
alignof(
 LayoutOrder:
offsetof(
sampleDCptr@
***COULDNOTCOMPUTE***
 Contents:[
Classifying expressions for: 
llvm.genx.GenISA.DCL.HSPatchConstInputVec
  -->  
User-defined operators should not live outside of a pass!
 U: 
sampleDptr@
 S: 
Advanced MemOpt
Exits: 
llvm.genx.GenISA.DCL.HSinputVec
<<Unknown>>
LoopDispositions: { 
sampleKillPix@
Determining loop execution counts for: 
 AddrDelta:
Trip Count Changed!
llvm.genx.GenISA.DCL.ShaderInputVec
Old: 
musttail call must precede a ret with an optional bitcast
New: 
sampleLCptr@
Delta: 
-compilerStats
Equal predicate: 
llvm.genx.GenISA.DCL.SystemValue
 == 
 LineDelta:
 Added Flags: 
sampleLptr@
<nusw>
 RangeStart:
<nssw>
llvm.genx.GenISA.DCL.input
scalar-evolution
invalid compile unit
Variant
USAGE: -numGeneralAcc <accNum>
Invariant
Computable
llvm.genx.GenISA.DCL.inputVec
Loop 
<multiple exits> 
USAGE: -reservedGRFNum <regNum>
backedge-taken count is 
EmitPass
Unpredictable backedge-taken count. 
llvm.genx.GenISA.EndPrimitive
Loop 
FPImm:
max backedge-taken count is 
USAGE: -GRFNumToUse <regNum>
, actual taken count either this or zero.
<MCInst #
Unpredictable max backedge-taken count. 
llvm.genx.GenISA.EnqueuedLocalSizeLocation
Predicated backedge-taken count is 
USAGE: -abortonspillthreshold <threshold>
 Predicates:
setMessagePhaseV@
Unpredictable predicated backedge-taken count. 
__gcc_except_tab
llvm.genx.GenISA.GetBufferPtr
Scalar Evolution Analysis
__compact_unwind
__apple_namespac
setMessagePhaseX@
scev-aa
USAGE: -presched-rp <threshold>
USAGE: -unifiedSendCycle <cycle>
scevgep
llvm.genx.GenISA.GetPixelMask
.iv.next
__LD
setMessagePhaseXV@
indvar
__apple_objc
indvar.next
llvm.genx.GenISA.GlobalDataAccess
vector-library
setMessagePhaseX_legacy@
Vector functions library
No vector functions library
Accelerate
llvm.genx.GenISA.GlobalSizeLocation
objc_begin
Accelerate framework
??2@YAPAXI@Z
??2@YAPEAX_KAEBUnothrow_t@std@@@Z
setMessagePhase_legacy@
simdBlockRead@
SVML
__debug_info
Intel SVML library
Display all available options
??2@YAPAXIABUnothrow_t@std@@@Z
??2@YAPEAX_K@Z
??3@YAXPEAX@Z
??3@YAXPEAX_K@Z
Label String is not provided for the -uniqueLabels option.
llvm.genx.GenISA.GradientXfine
llvm.genx.GenISA.GradientY
??3@YAXPAX@Z
__debug_line
__debug_str_offs
??3@YAXPAXABUnothrow_t@std@@@Z
image1d_array_t
??3@YAXPAXI@Z
V = 
??3@YAXPEAXAEBUnothrow_t@std@@@Z
simdBlockWrite@
??_U@YAPAXI@Z
??_V@YAXPAXI@Z
??_V@YAXPEAX@Z
encoderStatistics.csv
UNDEFINED 
false
??_U@YAPAXIABUnothrow_t@std@@@Z
llvm.genx.GenISA.GradientYfine
??_U@YAPEAX_K@Z
__debug_str
??_U@YAPEAX_KAEBUnothrow_t@std@@@Z
simdBlockWriteBindless@
??_V@YAXPAX@Z
__debug_macinfo
??_V@YAXPAXABUnothrow_t@std@@@Z
llvm.genx.GenISA.GridOriginLocation
' specified.
simdGetMessagePhase@
??_V@YAXPEAXAEBUnothrow_t@std@@@Z
_ZdaPv
USAGE: -hashmovs1 hi32 lo32
unordered_map::at: key not found
??_V@YAXPEAX_K@Z
llvm.genx.GenISA.GridSizeLocation
_IO_getc
debug_macinfo
_IO_putc
__llvm_faultmaps
_ZdaPvRKSt9nothrow_t
llvm.genx.GenISA.GroupIdLocation
llvm.genx.GenISA.GsCutControlHeader
simdLaneId@
_ZdaPvSt11align_val_t
.rodata.cst8
_ZdaPvSt11align_val_tRKSt9nothrow_t
_ZdaPvj
_ZdaPvm
_ZdlPv
_ZdlPvSt11align_val_t
.rodata.cst4
.debug_line
_ZdlPvRKSt9nothrow_t
_ZdlPvSt11align_val_tRKSt9nothrow_t
jit_time.txt
llvm.genx.GenISA.GsStreamHeader
_ZdlPvj
 does not end with -skip or -count
Counters and values:
_ZdlPvm
simdMediaBlockWrite@
_Znaj
__debug_gnu_pubt
_ZnajRKSt9nothrow_t
llvm.genx.GenISA.HSURBPatchHeaderRead
_ZnajSt11align_val_t
.debug_line_str
_ZnajSt11align_val_tRKSt9nothrow_t
_Znam
I = 
_ZnamRKSt9nothrow_t
_ZnwjSt11align_val_tRKSt9nothrow_t
_ZnwmRKSt9nothrow_t
llvm.genx.GenISA.InitDiscardMask
simdSize@
_ZnwmSt11align_val_t
Running '
' program... 
--spartan
dotty
Running 'dotty' program... 
Error: Couldn't find a usable graph viewer program:
  Tried '
Remember to erase graph file: 
neato
twopi
circo
_ZnwmSt11align_val_tRKSt9nothrow_t
Included from 
warning: 
note: 
remark: 
__acosh_finite
.debug_rnglists
__acoshf_finite
llvm.genx.GenISA.InnerScalarTessFactors
__acoshl_finite
.debug_addr
__acosl_finite
GRF_Global_RA
__asinl_finite
.debug_loc.dwo
__atan2l_finite
llvm.genx.GenISA.Interpolant
__atanh_finite
simdBlockReadBindless@
__atanhf_finite
slice_id@
__atanhl_finite
  Interference
__coshl_finite
llvm.genx.GenISA.Interpolate
__cospi
.debug_str_offsets.dwo
__cospif
source_value@
__cxa_atexit
.rdata
__cxa_guard_abort
llvm.genx.GenISA.Interpolate2
__cxa_guard_acquire
.debug_aranges
__cxa_guard_release
storeraw_indexed@
__exp10_finite
Encode+Emit
__exp10f_finite
llvm.genx.GenISA.IsHelperInvocation
storestructured4@
__sqrtf_finite
Subsection number out of range
__sqrtl_finite
llvm.genx.GenISA.MediaBlockWrite
__stpcpy_chk
8.1-A
v8.1a
armv8.2-a
8.2-A
v8.2a
armv8.3-a
8.3-A
v8.3a
8.4-A
v8.4a
armv8-r
armv8-m.base
8-M.Baseline
armv8-m.main
8-M.Mainline
v8m.main
iwmmxt2
armv7s
v6-m
v7-a
v7-r
v7e-m
v8-a
v8.1-a
v8.2-a
v8.3-a
v8.4-a
v8-r
v8-m.base
v8-m.main
__stpncpy_chk
sub_pair@
__strcpy_chk
enable-nonnull-arg-prop
__strdup
llvm.genx.GenISA.OUTPUT
__strncpy_chk
'.fill' directive with negative repeat count has no effect
__strndup
subslice_id@
__strtok_r
.section
access
llvm.genx.GenISA.OUTPUTGS
acosh
.linkonce
acoshf
threadgroupbarrier@
acoshl
functionattrs
acosl
llvm.genx.GenISA.OUTPUTGS2
asinh
asinhf
threadgroupbarrier_signal@
asinhl
.shl.outer.merge.hi
asinl
llvm.genx.GenISA.OWordPtr
atan2l
0x7000001e
atanh
threadgroupbarrier_wait@
atanhf
globaldce
atanhl
llvm.genx.GenISA.OuterScalarTessFactors
atanl
unsupported type 0x
atof
Enable stress test of coldcc by adding calling conv to all internal functions.
atoi
atol
llvm.genx.GenISA.OutputTessControlPoint
atoll
mach-o section specifier requires a segment whose length is between 1 and 16 characters
bcmp
typedread@
bcopy
coldcc-rel-freq
bzero
llvm.genx.GenISA.OutputTessFactors
cabsf
,none,
cabsl
calloc
unknown
cbrt
llvm.genx.GenISA.PHASE.INPUT
cbrtf
regular
cbrtl
uaddc@
ceill
newgv
chmod
llvm.genx.GenISA.PHASE.OUTPUT
chown
mach-o section specifier has a malformed stub size
clearerr
uavSerializeAll@
closedir
S_4BYTE_LITERALS
coshl
llvm.genx.GenISA.PatchConstantOutput
ctermid
aarch64
exp10
uavSerializeOnResID@
exp10f
isneg
exp10l
llvm.genx.GenISA.PixelPositionX
expl
8byte_literals
expm1
image1d_buffer_t
expm1f
.shl.outer.true.branch
expm1l
llvm.genx.GenISA.PixelPositionY
fclose
S_SYMBOL_STUBS
fdopen
ffsll
uitof_rtp@
fgetc
S_COALESCED
fgetc_unlocked
llvm.genx.GenISA.PullSampleIndexBarys
fgetpos
nacl
msvc
itanium
cygnus
coreclr
simulator
macho
fgets
uitof_rtz@
fgets_unlocked
Interprocedural constant propagation
fileno
llvm.genx.GenISA.PullSnappedBarys
flockfile
S_GB_ZEROFILL
floorl
inline
empty
flsl
llvm.genx.GenISA.QuadPrefix
flsll
rope:
fmodl
usubb@
fopen
S_LAZY_SYMBOL_POINTERS
fopen64
llvm.genx.GenISA.ROUNDNE
fprintf
S_THREAD_LOCAL_REGULAR
fread
basic statistics
fread_unlocked
free
llvm.genx.GenISA.RTDualBlendSource
frexp
S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
frexpf
[:>:]]
frexpl
no_toc
fscanf
llvm.genx.GenISA.RTWrite
fseek
Enable inliner stats for imported functions
fseeko
vaCentroid@
fseeko64
.shl.merge.inner.lo
fsetpos
llvm.genx.GenISA.RenderTargetRead
fstat
ubfe@
fstat64
vaConvolve@
fstatvfs
fstatvfs64
llvm.genx.GenISA.RenderTargetReadSampleFreq
ftell
S_ATTR_NO_DEAD_STRIP
ftello
vaConvolveGRF_16x1@
ftello64
S_ATTR_SOME_INSTRUCTIONS
ftrylockfile
llvm.genx.GenISA.RuntimeValue
funlockfile
S_ATTR_LOC_RELOC
fwrite
vaConvolveGRF_16x4@
fwrite_unlocked
 because its definition is unavailable
getc
llvm.genx.GenISA.SampleOffsetX
getc_unlocked
S_ATTR_EXT_RELOC
getchar
vaDilate@
getchar_unlocked
invalid symbol redefinition
getenv
llvm.genx.GenISA.SampleOffsetY
getitimer
.seh_* directives are not supported on this target
getlogin_r
vaErode@
getpwnam
 inlined into 
gets
llvm.genx.GenISA.SetDebugReg
gettimeofday
starting new .cfi frame before finishing the previous one
htonl
vaMinMax@
htons
Don't know what kind of handler this is!
lchown
llvm.genx.GenISA.SetStream
ldexp
ldexpf
vaMinMaxFilter@
ldexpl
Threshold
log10l
llvm.genx.GenISA.StackAlloca
log1p
 not inlined into 
log1pf
image2d_buffer_t
log1pl
.shl.merge.inner.hi
log2f
llvm.genx.GenISA.URBRead
log2l
register save offset is not 8 byte aligned
logb
vmeSendFBR2@
logbf
logbl
llvm.genx.GenISA.URBReadOutput
logl
, threshold=
lstat
vmeSendIME@
lstat64
, Addend=
malloc
llvm.genx.GenISA.URBWrite
memalign
 = comdat 
memccpy
vmeSendIME2@
mempcpy
Not inlining. Cost of inlining 
memrchr
llvm.genx.GenISA.UpdateDiscardMask
mkdir
, FixupSection=
mktime
vmeSendSIC@
modf
modff
llvm.genx.GenISA.VirtualBindingTableBaseLocation
modfl
Parse IR
nearbyint
vmeSendSIC2@
nearbyintf
 prefix 
nearbyintl
llvm.genx.GenISA.WaveAll
ntohl
 section "
ntohs
bitcode-mdindex-threshold
open
<empty name> 
open64
llvm.genx.GenISA.WaveBallot
opendir
low-line
pclose
wait
perror
Number of metadatas above which we emit an index to enable lazy-loading
popen
llvm.genx.GenISA.WaveClustered
posix_memalign
[Regular LTO]
__svml_expf8
UNDEFINED_
__svml_expf16
) ; guid = 
llvm.exp.f64
llvm.genx.GenISA.firstbitHi
__svml_log2
DW_AT_deleted
DW_AT_defaulted
DW_AT_loclists_base
DW_AT_MIPS_loop_begin
DW_AT_MIPS_tail_loop_begin
DW_AT_MIPS_epilog_begin
DW_AT_MIPS_loop_unroll_factor
DW_AT_MIPS_software_pipeline_depth
DW_AT_MIPS_stride
DW_AT_MIPS_abstract_name
DW_AT_MIPS_clone_origin
DW_AT_MIPS_stride_byte
DW_AT_MIPS_stride_elem
DW_AT_MIPS_ptr_dopetype
DW_AT_MIPS_assumed_shape_dopetype
DW_AT_MIPS_assumed_size
DW_AT_sf_names
DW_AT_src_info
DW_AT_mac_info
DW_AT_src_coords
DW_AT_body_begin
DW_AT_GNU_vector
DW_AT_GNU_template_name
DW_AT_GNU_odr_signature
DW_AT_GNU_all_call_sites
DW_AT_GNU_macros
DW_AT_GNU_dwo_name
DW_AT_GNU_ranges_base
DW_AT_GNU_addr_base
DW_AT_GNU_pubnames
DW_AT_GNU_pubtypes
DW_AT_GNU_discriminator
DW_AT_BORLAND_property_read
DW_AT_BORLAND_property_write
DW_AT_BORLAND_property_index
DW_AT_BORLAND_property_default
DW_AT_BORLAND_Delphi_unit
DW_AT_BORLAND_Delphi_record
DW_AT_BORLAND_Delphi_metaclass
DW_AT_BORLAND_Delphi_constructor
DW_AT_BORLAND_Delphi_anonymous_method
DW_AT_BORLAND_Delphi_interface
DW_AT_BORLAND_Delphi_ABI
DW_AT_BORLAND_Delphi_return
DW_AT_BORLAND_Delphi_frameptr
DW_AT_BORLAND_closure
DW_AT_LLVM_include_path
DW_AT_LLVM_isysroot
DW_AT_APPLE_optimized
DW_AT_APPLE_flags
DW_AT_APPLE_block
DW_AT_APPLE_major_runtime_vers
DW_AT_APPLE_runtime_class
DW_AT_APPLE_property_name
DW_AT_APPLE_property_getter
DW_AT_APPLE_property_setter
DW_AT_APPLE_property_attribute
DW_AT_APPLE_objc_complete_type
DW_AT_APPLE_property
DW_OP_addr
DW_OP_const1u
DW_OP_const1s
DW_OP_const2u
DW_OP_const4u
DW_OP_const4s
DW_OP_const8u
DW_OP_const8s
DW_OP_constu
DW_OP_consts
DW_OP_dup
DW_OP_drop
DW_OP_over
DW_OP_pick
DW_OP_swap
DW_OP_xderef
DW_OP_abs
DW_OP_and
DW_OP_minus
DW_OP_mod
DW_OP_mul
DW_OP_not
DW_OP_or
DW_OP_plus
DW_OP_plus_uconst
DW_OP_shl
DW_OP_shr
DW_OP_shra
DW_OP_bra
DW_OP_eq
DW_OP_ge
DW_OP_le
DW_OP_lt
DW_OP_ne
DW_OP_lit0
DW_OP_lit1
DW_OP_lit2
DW_OP_lit3
DW_OP_lit4
DW_OP_lit5
DW_OP_lit6
DW_OP_lit8
DW_OP_lit9
DW_OP_lit10
DW_OP_lit12
DW_OP_lit13
DW_OP_lit14
DW_OP_lit16
DW_OP_lit17
DW_OP_lit18
DW_OP_lit19
DW_OP_lit20
DW_OP_lit21
DW_OP_lit22
DW_OP_lit24
DW_OP_lit25
DW_OP_lit26
DW_OP_lit28
DW_OP_lit29
DW_OP_lit30
DW_OP_reg0
DW_OP_reg1
DW_OP_reg2
DW_OP_reg3
DW_OP_reg4
DW_OP_reg5
DW_OP_reg6
DW_OP_reg8
DW_OP_reg9
DW_OP_reg10
DW_OP_reg12
DW_OP_reg13
DW_OP_reg14
DW_OP_reg16
DW_OP_reg17
DW_OP_reg18
DW_OP_reg19
DW_OP_reg20
DW_OP_reg21
DW_OP_reg22
DW_OP_reg24
DW_OP_reg25
DW_OP_reg26
DW_OP_reg28
DW_OP_reg29
DW_OP_reg30
DW_OP_breg0
DW_OP_breg1
DW_OP_breg2
DW_OP_breg3
DW_OP_breg4
DW_OP_breg5
DW_OP_breg6
DW_OP_breg8
DW_OP_breg9
DW_OP_breg10
DW_OP_breg12
DW_OP_breg13
DW_OP_breg14
DW_OP_breg16
DW_OP_breg17
DW_OP_breg18
DW_OP_breg19
DW_OP_breg20
DW_OP_breg21
DW_OP_breg22
DW_OP_breg24
DW_OP_breg25
DW_OP_breg26
DW_OP_breg28
DW_OP_breg29
DW_OP_breg30
DW_OP_regx
DW_OP_fbreg
DW_OP_bregx
DW_OP_piece
DW_OP_deref_size
DW_OP_xderef_size
DW_OP_nop
DW_OP_call2
DW_OP_call4
DW_OP_call_ref
DW_OP_call_frame_cfa
DW_OP_bit_piece
DW_OP_implicit_value
DW_OP_implicit_pointer
DW_OP_addrx
DW_OP_constx
DW_OP_entry_value
DW_OP_const_type
DW_OP_regval_type
DW_OP_deref_type
DW_OP_convert
DW_OP_reinterpret
DW_OP_GNU_push_tls_address
DW_OP_GNU_const_index
DW_OP_LLVM_fragment
DW_ATE_address
DW_ATE_complex_float
DW_ATE_float
DW_ATE_signed
DW_ATE_signed_char
DW_ATE_unsigned
DW_ATE_unsigned_char
DW_ATE_imaginary_float
DW_ATE_numeric_string
DW_ATE_edited
DW_ATE_signed_fixed
DW_ATE_decimal_float
DW_ATE_UTF
DW_ATE_UCS
DW_VIRTUALITY_none
DW_VIRTUALITY_virtual
DW_VIRTUALITY_pure_virtual
DW_LANG_C89
DW_LANG_C
DW_LANG_Ada83
DW_LANG_C_plus_plus
DW_LANG_Cobol85
DW_LANG_Fortran77
DW_LANG_Fortran90
DW_LANG_Modula2
DW_LANG_Java
DW_LANG_C99
DW_LANG_Fortran95
DW_LANG_PLI
DW_LANG_ObjC
DW_LANG_ObjC_plus_plus
DW_LANG_UPC
DW_LANG_D
DW_LANG_Python
DW_LANG_Go
DW_LANG_Modula3
DW_LANG_Haskell
DW_LANG_C_plus_plus_11
DW_LANG_OCaml
DW_LANG_Rust
DW_LANG_Swift
DW_LANG_Julia
DW_LANG_Dylan
DW_LANG_C_plus_plus_14
DW_LANG_Fortran03
DW_LANG_Fortran08
DW_LANG_RenderScript
DW_LANG_Mips_Assembler
DW_LANG_GOOGLE_RenderScript
DW_LANG_BORLAND_Delphi
DW_CC_program
DW_CC_nocall
DW_CC_pass_by_reference
DW_CC_GNU_renesas_sh
DW_CC_GNU_borland_fastcall_i386
DW_CC_BORLAND_safecall
DW_CC_BORLAND_stdcall
DW_CC_BORLAND_pascal
DW_CC_BORLAND_msfastcall
DW_CC_BORLAND_msreturn
DW_CC_BORLAND_fastcall
DW_CC_LLVM_vectorcall
DW_CC_LLVM_Win64
DW_CC_LLVM_AAPCS
DW_CC_LLVM_AAPCS_VFP
DW_CC_LLVM_IntelOclBicc
DW_CC_LLVM_OpenCLKernel
DW_CC_LLVM_Swift
DW_CC_LLVM_PreserveMost
DW_CC_LLVM_PreserveAll
DW_CC_LLVM_X86RegCall
DW_CC_GDB_IBM_OpenCL
DW_MACINFO_define
DW_MACINFO_undef
DW_MACINFO_start_file
DW_MACINFO_end_file
DW_MACINFO_vendor_ext
__svml_log4
test
__svml_log8
hhvm_ccc
__svml_logf4
llvm.genx.GenISA.firstbitLo
__svml_logf8
 = gv: (
__svml_logf16
.implicit_
llvm.log.f64
linkage: 
wchar_size
llvm.genx.GenISA.firstbitShi
fwrite$UNIX2003
, live: 
fputs$UNIX2003
NONE
fabs
54intel_sub_group_avc_ime_evaluate_with_single_reference14ocl_image2d_roS_11ocl_sampler33intel_sub_group_avc_ime_payload_t
fabsl
getobjectidMappingBuf
fmin
iga api: unsupported platform
fminl
decoding error: %s
fmaxf
halt
llvm.amdgcn.image.sample.c.b.o.2darray
llvm.hexagon.C4.nbitsset
llvm.hexagon.C4.or.and
llvm.hexagon.C4.or.andn
llvm.hexagon.C4.or.or
llvm.hexagon.C4.or.orn
llvm.hexagon.F2.conv.d2df
llvm.hexagon.F2.conv.d2sf
llvm.hexagon.F2.conv.df2d
llvm.hexagon.F2.conv.df2d.chop
llvm.hexagon.F2.conv.df2sf
llvm.hexagon.F2.conv.df2ud
llvm.hexagon.F2.conv.df2ud.chop
llvm.hexagon.F2.conv.df2uw
llvm.hexagon.F2.conv.df2uw.chop
llvm.hexagon.F2.conv.df2w
llvm.hexagon.F2.conv.df2w.chop
llvm.hexagon.F2.conv.sf2d
llvm.hexagon.F2.conv.sf2d.chop
llvm.hexagon.F2.conv.sf2df
llvm.hexagon.F2.conv.sf2ud
llvm.hexagon.F2.conv.sf2ud.chop
llvm.hexagon.F2.conv.sf2uw
llvm.hexagon.F2.conv.sf2uw.chop
llvm.hexagon.F2.conv.sf2w
llvm.hexagon.F2.conv.sf2w.chop
llvm.hexagon.F2.conv.ud2df
llvm.hexagon.F2.conv.ud2sf
llvm.hexagon.F2.conv.uw2df
llvm.hexagon.F2.conv.uw2sf
llvm.hexagon.F2.conv.w2df
llvm.hexagon.F2.conv.w2sf
llvm.hexagon.F2.dfclass
llvm.hexagon.F2.dfcmpeq
llvm.hexagon.F2.dfcmpge
llvm.hexagon.F2.dfcmpgt
llvm.hexagon.F2.dfcmpuo
llvm.hexagon.F2.dfimm.n
llvm.hexagon.F2.dfimm.p
llvm.hexagon.F2.sfadd
llvm.hexagon.F2.sfclass
llvm.hexagon.F2.sfcmpeq
llvm.hexagon.F2.sfcmpge
llvm.hexagon.F2.sfcmpgt
llvm.hexagon.F2.sfcmpuo
llvm.hexagon.F2.sffixupd
llvm.hexagon.F2.sffixupn
llvm.hexagon.F2.sffixupr
llvm.hexagon.F2.sffma
llvm.hexagon.F2.sffma.lib
llvm.hexagon.F2.sffma.sc
llvm.hexagon.F2.sffms
llvm.hexagon.F2.sffms.lib
llvm.hexagon.F2.sfimm.n
llvm.hexagon.F2.sfimm.p
llvm.hexagon.F2.sfmax
llvm.hexagon.F2.sfmin
llvm.hexagon.F2.sfmpy
llvm.hexagon.F2.sfsub
llvm.hexagon.L2.loadrb.pbr
llvm.hexagon.L2.loadrb.pci
llvm.hexagon.L2.loadrb.pcr
llvm.hexagon.L2.loadrd.pbr
llvm.hexagon.L2.loadrd.pci
llvm.hexagon.L2.loadrd.pcr
llvm.hexagon.L2.loadrh.pbr
llvm.hexagon.L2.loadrh.pci
llvm.hexagon.L2.loadrh.pcr
llvm.hexagon.L2.loadri.pbr
llvm.hexagon.L2.loadri.pci
llvm.hexagon.L2.loadri.pcr
llvm.hexagon.L2.loadrub.pbr
llvm.hexagon.L2.loadrub.pci
llvm.hexagon.L2.loadrub.pcr
llvm.hexagon.L2.loadruh.pbr
llvm.hexagon.L2.loadruh.pci
llvm.hexagon.L2.loadruh.pcr
llvm.hexagon.L2.loadw.locked
llvm.hexagon.L4.loadd.locked
llvm.hexagon.M2.acci
llvm.hexagon.M2.accii
llvm.hexagon.M2.cmaci.s0
llvm.hexagon.M2.cmacr.s0
llvm.hexagon.M2.cmacs.s0
llvm.hexagon.M2.cmacs.s1
llvm.hexagon.M2.cmacsc.s0
llvm.hexagon.M2.cmacsc.s1
llvm.hexagon.M2.cmpyi.s0
llvm.hexagon.M2.cmpyr.s0
llvm.hexagon.M2.cmpyrs.s0
llvm.hexagon.M2.cmpyrs.s1
llvm.hexagon.M2.cmpyrsc.s0
llvm.hexagon.M2.cmpyrsc.s1
llvm.hexagon.M2.cmpys.s0
llvm.hexagon.M2.cmpys.s1
llvm.hexagon.M2.cmpysc.s0
llvm.hexagon.M2.cmpysc.s1
llvm.hexagon.M2.cnacs.s0
llvm.hexagon.M2.cnacs.s1
llvm.hexagon.M2.cnacsc.s0
llvm.hexagon.M2.cnacsc.s1
llvm.hexagon.M2.dpmpyss.acc.s0
llvm.hexagon.M2.dpmpyss.nac.s0
llvm.hexagon.M2.dpmpyss.rnd.s0
llvm.hexagon.M2.dpmpyss.s0
llvm.hexagon.M2.dpmpyuu.acc.s0
llvm.hexagon.M2.dpmpyuu.nac.s0
llvm.hexagon.M2.dpmpyuu.s0
llvm.hexagon.M2.hmmpyh.rs1
llvm.hexagon.M2.hmmpyh.s1
llvm.hexagon.M2.hmmpyl.rs1
llvm.hexagon.M2.hmmpyl.s1
llvm.hexagon.M2.maci
llvm.hexagon.M2.macsin
llvm.hexagon.M2.macsip
llvm.hexagon.M2.mmachs.rs0
llvm.hexagon.M2.mmachs.rs1
llvm.hexagon.M2.mmachs.s0
llvm.hexagon.M2.mmachs.s1
llvm.hexagon.M2.mmacls.rs0
llvm.hexagon.M2.mmacls.rs1
llvm.hexagon.M2.mmacls.s0
llvm.hexagon.M2.mmacls.s1
llvm.hexagon.M2.mmacuhs.rs0
llvm.hexagon.M2.mmacuhs.rs1
llvm.hexagon.M2.mmacuhs.s0
llvm.hexagon.M2.mmacuhs.s1
llvm.hexagon.M2.mmaculs.rs0
llvm.hexagon.M2.mmaculs.rs1
llvm.hexagon.M2.mmaculs.s0
llvm.hexagon.M2.mmaculs.s1
llvm.hexagon.M2.mmpyh.rs0
llvm.hexagon.M2.mmpyh.rs1
llvm.hexagon.M2.mmpyh.s0
llvm.hexagon.M2.mmpyh.s1
llvm.hexagon.M2.mmpyl.rs0
llvm.hexagon.M2.mmpyl.rs1
llvm.hexagon.M2.mmpyl.s0
llvm.hexagon.M2.mmpyl.s1
llvm.hexagon.M2.mmpyuh.rs0
llvm.hexagon.M2.mmpyuh.rs1
llvm.hexagon.M2.mmpyuh.s0
llvm.hexagon.M2.mmpyuh.s1
llvm.hexagon.M2.mmpyul.rs0
llvm.hexagon.M2.mmpyul.rs1
llvm.hexagon.M2.mmpyul.s0
llvm.hexagon.M2.mmpyul.s1
llvm.hexagon.M2.mpy.acc.hh.s0
llvm.hexagon.M2.mpy.acc.hh.s1
llvm.hexagon.M2.mpy.acc.hl.s0
llvm.hexagon.M2.mpy.acc.hl.s1
llvm.hexagon.M2.mpy.acc.lh.s0
llvm.hexagon.M2.mpy.acc.lh.s1
llvm.hexagon.M2.mpy.acc.ll.s0
llvm.hexagon.M2.mpy.acc.ll.s1
llvm.hexagon.M2.mpy.acc.sat.hh.s0
llvm.hexagon.M2.mpy.acc.sat.hh.s1
llvm.hexagon.M2.mpy.acc.sat.hl.s0
llvm.hexagon.M2.mpy.acc.sat.hl.s1
llvm.hexagon.M2.mpy.acc.sat.lh.s0
llvm.hexagon.M2.mpy.acc.sat.lh.s1
llvm.hexagon.M2.mpy.acc.sat.ll.s0
llvm.hexagon.M2.mpy.acc.sat.ll.s1
llvm.hexagon.M2.mpy.hh.s0
llvm.hexagon.M2.mpy.hh.s1
llvm.hexagon.M2.mpy.hl.s0
llvm.hexagon.M2.mpy.hl.s1
llvm.hexagon.M2.mpy.lh.s0
llvm.hexagon.M2.mpy.lh.s1
llvm.hexagon.M2.mpy.ll.s0
llvm.hexagon.M2.mpy.ll.s1
llvm.hexagon.M2.mpy.nac.hh.s0
llvm.hexagon.M2.mpy.nac.hh.s1
llvm.hexagon.M2.mpy.nac.hl.s0
llvm.hexagon.M2.mpy.nac.hl.s1
llvm.hexagon.M2.mpy.nac.lh.s0
llvm.hexagon.M2.mpy.nac.lh.s1
llvm.hexagon.M2.mpy.nac.ll.s0
llvm.hexagon.M2.mpy.nac.ll.s1
llvm.hexagon.M2.mpy.nac.sat.hh.s0
llvm.hexagon.M2.mpy.nac.sat.hh.s1
llvm.hexagon.M2.mpy.nac.sat.hl.s0
llvm.hexagon.M2.mpy.nac.sat.hl.s1
llvm.hexagon.M2.mpy.nac.sat.lh.s0
llvm.hexagon.M2.mpy.nac.sat.lh.s1
llvm.hexagon.M2.mpy.nac.sat.ll.s0
llvm.hexagon.M2.mpy.nac.sat.ll.s1
llvm.hexagon.M2.mpy.rnd.hh.s0
llvm.hexagon.M2.mpy.rnd.hh.s1
llvm.hexagon.M2.mpy.rnd.hl.s0
llvm.hexagon.M2.mpy.rnd.hl.s1
llvm.hexagon.M2.mpy.rnd.lh.s0
llvm.hexagon.M2.mpy.rnd.lh.s1
llvm.hexagon.M2.mpy.rnd.ll.s0
llvm.hexagon.M2.mpy.rnd.ll.s1
llvm.hexagon.M2.mpy.sat.hh.s0
llvm.hexagon.M2.mpy.sat.hh.s1
llvm.hexagon.M2.mpy.sat.hl.s0
llvm.hexagon.M2.mpy.sat.hl.s1
llvm.hexagon.M2.mpy.sat.lh.s0
llvm.hexagon.M2.mpy.sat.lh.s1
llvm.hexagon.M2.mpy.sat.ll.s0
llvm.hexagon.M2.mpy.sat.ll.s1
llvm.hexagon.M2.mpy.sat.rnd.hh.s0
llvm.hexagon.M2.mpy.sat.rnd.hh.s1
llvm.hexagon.M2.mpy.sat.rnd.hl.s0
llvm.hexagon.M2.mpy.sat.rnd.hl.s1
llvm.hexagon.M2.mpy.sat.rnd.lh.s0
llvm.hexagon.M2.mpy.sat.rnd.lh.s1
llvm.hexagon.M2.mpy.sat.rnd.ll.s0
llvm.hexagon.M2.mpy.sat.rnd.ll.s1
llvm.hexagon.M2.mpy.up
llvm.hexagon.M2.mpy.up.s1
llvm.hexagon.M2.mpy.up.s1.sat
llvm.hexagon.M2.mpyd.acc.hh.s0
llvm.hexagon.M2.mpyd.acc.hh.s1
llvm.hexagon.M2.mpyd.acc.hl.s0
llvm.hexagon.M2.mpyd.acc.hl.s1
llvm.hexagon.M2.mpyd.acc.lh.s0
llvm.hexagon.M2.mpyd.acc.lh.s1
llvm.hexagon.M2.mpyd.acc.ll.s0
llvm.hexagon.M2.mpyd.acc.ll.s1
llvm.hexagon.M2.mpyd.hh.s0
llvm.hexagon.M2.mpyd.hh.s1
llvm.hexagon.M2.mpyd.hl.s0
llvm.hexagon.M2.mpyd.hl.s1
llvm.hexagon.M2.mpyd.lh.s0
llvm.hexagon.M2.mpyd.lh.s1
llvm.hexagon.M2.mpyd.ll.s0
llvm.hexagon.M2.mpyd.ll.s1
llvm.hexagon.M2.mpyd.nac.hh.s0
llvm.hexagon.M2.mpyd.nac.hh.s1
llvm.hexagon.M2.mpyd.nac.hl.s0
llvm.hexagon.M2.mpyd.nac.hl.s1
llvm.hexagon.M2.mpyd.nac.lh.s0
llvm.hexagon.M2.mpyd.nac.lh.s1
llvm.hexagon.M2.mpyd.nac.ll.s0
llvm.hexagon.M2.mpyd.nac.ll.s1
llvm.hexagon.M2.mpyd.rnd.hh.s0
llvm.hexagon.M2.mpyd.rnd.hh.s1
llvm.hexagon.M2.mpyd.rnd.hl.s0
llvm.hexagon.M2.mpyd.rnd.hl.s1
llvm.hexagon.M2.mpyd.rnd.lh.s0
llvm.hexagon.M2.mpyd.rnd.lh.s1
llvm.hexagon.M2.mpyd.rnd.ll.s0
llvm.hexagon.M2.mpyd.rnd.ll.s1
llvm.hexagon.M2.mpyi
llvm.hexagon.M2.mpysmi
llvm.hexagon.M2.mpysu.up
llvm.hexagon.M2.mpyu.acc.hh.s0
llvm.hexagon.M2.mpyu.acc.hh.s1
llvm.hexagon.M2.mpyu.acc.hl.s0
llvm.hexagon.M2.mpyu.acc.hl.s1
llvm.hexagon.M2.mpyu.acc.lh.s0
llvm.hexagon.M2.mpyu.acc.lh.s1
llvm.hexagon.M2.mpyu.acc.ll.s0
llvm.hexagon.M2.mpyu.acc.ll.s1
llvm.hexagon.M2.mpyu.hh.s0
llvm.hexagon.M2.mpyu.hh.s1
llvm.hexagon.M2.mpyu.hl.s0
llvm.hexagon.M2.mpyu.hl.s1
llvm.hexagon.M2.mpyu.lh.s0
llvm.hexagon.M2.mpyu.lh.s1
llvm.hexagon.M2.mpyu.ll.s0
llvm.hexagon.M2.mpyu.ll.s1
llvm.hexagon.M2.mpyu.nac.hh.s0
llvm.hexagon.M2.mpyu.nac.hh.s1
llvm.hexagon.M2.mpyu.nac.hl.s0
llvm.hexagon.M2.mpyu.nac.hl.s1
llvm.hexagon.M2.mpyu.nac.lh.s0
llvm.hexagon.M2.mpyu.nac.lh.s1
llvm.hexagon.M2.mpyu.nac.ll.s0
llvm.hexagon.M2.mpyu.nac.ll.s1
llvm.hexagon.M2.mpyu.up
llvm.hexagon.M2.mpyud.acc.hh.s0
llvm.hexagon.M2.mpyud.acc.hh.s1
llvm.hexagon.M2.mpyud.acc.hl.s0
llvm.hexagon.M2.mpyud.acc.hl.s1
llvm.hexagon.M2.mpyud.acc.lh.s0
llvm.hexagon.M2.mpyud.acc.lh.s1
llvm.hexagon.M2.mpyud.acc.ll.s0
llvm.hexagon.M2.mpyud.acc.ll.s1
llvm.hexagon.M2.mpyud.hh.s0
llvm.hexagon.M2.mpyud.hh.s1
llvm.hexagon.M2.mpyud.hl.s0
llvm.hexagon.M2.mpyud.hl.s1
llvm.hexagon.M2.mpyud.lh.s0
llvm.hexagon.M2.mpyud.lh.s1
llvm.hexagon.M2.mpyud.ll.s0
llvm.hexagon.M2.mpyud.ll.s1
llvm.hexagon.M2.mpyud.nac.hh.s0
llvm.hexagon.M2.mpyud.nac.hh.s1
llvm.hexagon.M2.mpyud.nac.hl.s0
llvm.hexagon.M2.mpyud.nac.hl.s1
llvm.hexagon.M2.mpyud.nac.lh.s0
llvm.hexagon.M2.mpyud.nac.lh.s1
llvm.hexagon.M2.mpyud.nac.ll.s0
llvm.hexagon.M2.mpyud.nac.ll.s1
llvm.hexagon.M2.mpyui
llvm.hexagon.M2.nacci
llvm.hexagon.M2.naccii
llvm.hexagon.M2.subacc
llvm.hexagon.M2.vabsdiffh
llvm.hexagon.M2.vabsdiffw
llvm.hexagon.M2.vcmac.s0.sat.i
llvm.hexagon.M2.vcmac.s0.sat.r
llvm.hexagon.M2.vcmpy.s0.sat.i
llvm.hexagon.M2.vcmpy.s0.sat.r
llvm.hexagon.M2.vcmpy.s1.sat.i
llvm.hexagon.M2.vcmpy.s1.sat.r
llvm.hexagon.M2.vdmacs.s0
llvm.hexagon.M2.vdmacs.s1
llvm.hexagon.M2.vdmpyrs.s0
llvm.hexagon.M2.vdmpyrs.s1
llvm.hexagon.M2.vdmpys.s0
llvm.hexagon.M2.vdmpys.s1
llvm.hexagon.M2.vmac2
llvm.hexagon.M2.vmac2es
llvm.hexagon.M2.vmac2es.s0
llvm.hexagon.M2.vmac2es.s1
llvm.hexagon.M2.vmac2s.s0
llvm.hexagon.M2.vmac2s.s1
llvm.hexagon.M2.vmac2su.s0
llvm.hexagon.M2.vmac2su.s1
llvm.hexagon.M2.vmpy2es.s0
llvm.hexagon.M2.vmpy2es.s1
llvm.hexagon.M2.vmpy2s.s0
llvm.hexagon.M2.vmpy2s.s0pack
llvm.hexagon.M2.vmpy2s.s1
llvm.hexagon.M2.vmpy2s.s1pack
llvm.hexagon.M2.vmpy2su.s0
llvm.hexagon.M2.vmpy2su.s1
llvm.hexagon.M2.vraddh
llvm.hexagon.M2.vradduh
llvm.hexagon.M2.vrcmaci.s0
llvm.hexagon.M2.vrcmaci.s0c
llvm.hexagon.M2.vrcmacr.s0
llvm.hexagon.M2.vrcmacr.s0c
llvm.hexagon.M2.vrcmpyi.s0
llvm.hexagon.M2.vrcmpyi.s0c
llvm.hexagon.M2.vrcmpyr.s0
llvm.hexagon.M2.vrcmpyr.s0c
llvm.hexagon.M2.vrcmpys.acc.s1
llvm.hexagon.M2.vrcmpys.s1
llvm.hexagon.M2.vrcmpys.s1rp
llvm.hexagon.M2.vrmac.s0
llvm.hexagon.M2.vrmpy.s0
llvm.hexagon.M2.xor.xacc
llvm.hexagon.M4.and.and
llvm.hexagon.M4.and.andn
llvm.hexagon.M4.and.or
llvm.hexagon.M4.and.xor
llvm.hexagon.M4.cmpyi.wh
llvm.hexagon.M4.cmpyi.whc
llvm.hexagon.M4.cmpyr.wh
llvm.hexagon.M4.cmpyr.whc
llvm.hexagon.M4.mac.up.s1.sat
llvm.hexagon.M4.mpyri.addi
llvm.hexagon.M4.mpyri.addr
llvm.hexagon.M4.mpyri.addr.u2
llvm.hexagon.M4.mpyrr.addi
llvm.hexagon.M4.mpyrr.addr
llvm.hexagon.M4.nac.up.s1.sat
llvm.hexagon.M4.or.and
llvm.hexagon.M4.or.andn
llvm.hexagon.M4.or.or
llvm.hexagon.M4.or.xor
llvm.hexagon.M4.pmpyw
llvm.hexagon.M4.pmpyw.acc
llvm.hexagon.M4.vpmpyh
llvm.hexagon.M4.vpmpyh.acc
llvm.hexagon.M4.vrmpyeh.acc.s0
llvm.hexagon.M4.vrmpyeh.acc.s1
llvm.hexagon.M4.vrmpyeh.s0
llvm.hexagon.M4.vrmpyeh.s1
llvm.hexagon.M4.vrmpyoh.acc.s0
llvm.hexagon.M4.vrmpyoh.acc.s1
llvm.hexagon.M4.vrmpyoh.s0
llvm.hexagon.M4.vrmpyoh.s1
llvm.hexagon.M4.xor.and
llvm.hexagon.M4.xor.andn
llvm.hexagon.M4.xor.or
llvm.hexagon.M4.xor.xacc
llvm.hexagon.M5.vdmacbsu
llvm.hexagon.M5.vdmpybsu
llvm.hexagon.M5.vmacbsu
llvm.hexagon.M5.vmacbuu
llvm.hexagon.M5.vmpybsu
llvm.hexagon.M5.vmpybuu
llvm.hexagon.M5.vrmacbsu
llvm.hexagon.M5.vrmacbuu
llvm.hexagon.M5.vrmpybsu
llvm.hexagon.M5.vrmpybuu
llvm.hexagon.M6.vabsdiffb
llvm.hexagon.M6.vabsdiffub
llvm.hexagon.S2.addasl.rrri
llvm.hexagon.S2.asl.i.p
llvm.hexagon.S2.asl.i.p.acc
llvm.hexagon.S2.asl.i.p.and
llvm.hexagon.S2.asl.i.p.nac
llvm.hexagon.S2.asl.i.p.or
llvm.hexagon.S2.asl.i.p.xacc
llvm.hexagon.S2.asl.i.r
llvm.hexagon.S2.asl.i.r.acc
llvm.hexagon.S2.asl.i.r.and
llvm.hexagon.S2.asl.i.r.nac
llvm.hexagon.S2.asl.i.r.or
llvm.hexagon.S2.asl.i.r.sat
llvm.hexagon.S2.asl.i.r.xacc
llvm.hexagon.S2.asl.i.vh
llvm.hexagon.S2.asl.i.vw
llvm.hexagon.S2.asl.r.p
llvm.hexagon.S2.asl.r.p.acc
llvm.hexagon.S2.asl.r.p.and
llvm.hexagon.S2.asl.r.p.nac
llvm.hexagon.S2.asl.r.p.or
llvm.hexagon.S2.asl.r.p.xor
llvm.hexagon.S2.asl.r.r
llvm.hexagon.S2.asl.r.r.acc
llvm.hexagon.S2.asl.r.r.and
llvm.hexagon.S2.asl.r.r.nac
llvm.hexagon.S2.asl.r.r.or
llvm.hexagon.S2.asl.r.r.sat
llvm.hexagon.S2.asl.r.vh
llvm.hexagon.S2.asl.r.vw
llvm.hexagon.S2.asr.i.p
llvm.hexagon.S2.asr.i.p.acc
llvm.hexagon.S2.asr.i.p.and
llvm.hexagon.S2.asr.i.p.nac
llvm.hexagon.S2.asr.i.p.or
llvm.hexagon.S2.asr.i.p.rnd
llvm.hexagon.S2.asr.i.p.rnd.goodsyntax
llvm.hexagon.S2.asr.i.r
llvm.hexagon.S2.asr.i.r.acc
llvm.hexagon.S2.asr.i.r.and
llvm.hexagon.S2.asr.i.r.nac
llvm.hexagon.S2.asr.i.r.or
llvm.hexagon.S2.asr.i.r.rnd
llvm.hexagon.S2.asr.i.r.rnd.goodsyntax
llvm.hexagon.S2.asr.i.svw.trun
llvm.hexagon.S2.asr.i.vh
llvm.hexagon.S2.asr.i.vw
llvm.hexagon.S2.asr.r.p
llvm.hexagon.S2.asr.r.p.acc
llvm.hexagon.S2.asr.r.p.and
llvm.hexagon.S2.asr.r.p.nac
llvm.hexagon.S2.asr.r.p.or
llvm.hexagon.S2.asr.r.p.xor
llvm.hexagon.S2.asr.r.r
llvm.hexagon.S2.asr.r.r.acc
llvm.hexagon.S2.asr.r.r.and
llvm.hexagon.S2.asr.r.r.nac
llvm.hexagon.S2.asr.r.r.or
llvm.hexagon.S2.asr.r.r.sat
llvm.hexagon.S2.asr.r.svw.trun
llvm.hexagon.S2.asr.r.vh
llvm.hexagon.S2.asr.r.vw
llvm.hexagon.S2.brev
llvm.hexagon.S2.brevp
llvm.hexagon.S2.cabacencbin
llvm.hexagon.S2.cl0
llvm.hexagon.S2.cl0p
llvm.hexagon.S2.cl1
llvm.hexagon.S2.cl1p
llvm.hexagon.S2.clb
llvm.hexagon.S2.clbnorm
llvm.hexagon.S2.clbp
llvm.hexagon.S2.clrbit.i
llvm.hexagon.S2.clrbit.r
llvm.hexagon.S2.ct0
llvm.hexagon.S2.ct0p
llvm.hexagon.S2.ct1
llvm.hexagon.S2.ct1p
llvm.hexagon.S2.deinterleave
llvm.hexagon.S2.extractu
llvm.hexagon.S2.extractu.rp
llvm.hexagon.S2.extractup
llvm.hexagon.S2.extractup.rp
llvm.hexagon.S2.insert
llvm.hexagon.S2.insert.rp
llvm.hexagon.S2.insertp
llvm.hexagon.S2.insertp.rp
llvm.hexagon.S2.interleave
llvm.hexagon.S2.lfsp
llvm.hexagon.S2.lsl.r.p
llvm.hexagon.S2.lsl.r.p.acc
llvm.hexagon.S2.lsl.r.p.and
llvm.hexagon.S2.lsl.r.p.nac
llvm.hexagon.S2.lsl.r.p.or
llvm.hexagon.S2.lsl.r.p.xor
llvm.hexagon.S2.lsl.r.r
llvm.hexagon.S2.lsl.r.r.acc
llvm.hexagon.S2.lsl.r.r.and
llvm.hexagon.S2.lsl.r.r.nac
llvm.hexagon.S2.lsl.r.r.or
llvm.hexagon.S2.lsl.r.vh
llvm.hexagon.S2.lsl.r.vw
llvm.hexagon.S2.lsr.i.p
llvm.hexagon.S2.lsr.i.p.acc
llvm.hexagon.S2.lsr.i.p.and
llvm.hexagon.S2.lsr.i.p.nac
llvm.hexagon.S2.lsr.i.p.or
llvm.hexagon.S2.lsr.i.p.xacc
llvm.hexagon.S2.lsr.i.r
llvm.hexagon.S2.lsr.i.r.acc
llvm.hexagon.S2.lsr.i.r.and
llvm.hexagon.S2.lsr.i.r.nac
llvm.hexagon.S2.lsr.i.r.or
llvm.hexagon.S2.lsr.i.r.xacc
llvm.hexagon.S2.lsr.i.vh
llvm.hexagon.S2.lsr.i.vw
llvm.hexagon.S2.lsr.r.p
llvm.hexagon.S2.lsr.r.p.acc
llvm.hexagon.S2.lsr.r.p.and
llvm.hexagon.S2.lsr.r.p.nac
llvm.hexagon.S2.lsr.r.p.or
llvm.hexagon.S2.lsr.r.p.xor
llvm.hexagon.S2.lsr.r.r
llvm.hexagon.S2.lsr.r.r.acc
llvm.hexagon.S2.lsr.r.r.and
llvm.hexagon.S2.lsr.r.r.nac
llvm.hexagon.S2.lsr.r.r.or
llvm.hexagon.S2.lsr.r.vh
llvm.hexagon.S2.lsr.r.vw
llvm.hexagon.S2.packhl
llvm.hexagon.S2.parityp
llvm.hexagon.S2.setbit.i
llvm.hexagon.S2.setbit.r
llvm.hexagon.S2.shuffeb
llvm.hexagon.S2.shuffeh
llvm.hexagon.S2.shuffob
llvm.hexagon.S2.shuffoh
llvm.hexagon.S2.storerb.pbr
llvm.hexagon.S2.storerb.pci
llvm.hexagon.S2.storerb.pcr
llvm.hexagon.S2.storerd.pbr
llvm.hexagon.S2.storerd.pci
llvm.hexagon.S2.storerd.pcr
llvm.hexagon.S2.storerf.pbr
llvm.hexagon.S2.storerf.pci
llvm.hexagon.S2.storerf.pcr
llvm.hexagon.S2.storerh.pbr
llvm.hexagon.S2.storerh.pci
llvm.hexagon.S2.storerh.pcr
llvm.hexagon.S2.storeri.pbr
llvm.hexagon.S2.storeri.pci
llvm.hexagon.S2.storeri.pcr
llvm.hexagon.S2.storew.locked
llvm.hexagon.S2.svsathb
llvm.hexagon.S2.svsathub
llvm.hexagon.S2.tableidxb.goodsyntax
llvm.hexagon.S2.tableidxd.goodsyntax
llvm.hexagon.S2.tableidxh.goodsyntax
llvm.hexagon.S2.tableidxw.goodsyntax
llvm.hexagon.S2.togglebit.i
llvm.hexagon.S2.togglebit.r
llvm.hexagon.S2.tstbit.i
llvm.hexagon.S2.tstbit.r
llvm.hexagon.S2.valignib
llvm.hexagon.S2.valignrb
llvm.hexagon.S2.vcnegh
llvm.hexagon.S2.vcrotate
llvm.hexagon.S2.vrcnegh
llvm.hexagon.S2.vrndpackwh
llvm.hexagon.S2.vrndpackwhs
llvm.hexagon.S2.vsathb
llvm.hexagon.S2.vsathb.nopack
llvm.hexagon.S2.vsathub
llvm.hexagon.S2.vsathub.nopack
llvm.hexagon.S2.vsatwh
llvm.hexagon.S2.vsatwh.nopack
llvm.hexagon.S2.vsatwuh
llvm.hexagon.S2.vsatwuh.nopack
llvm.hexagon.S2.vsplatrb
llvm.hexagon.S2.vsplatrh
llvm.hexagon.S2.vspliceib
llvm.hexagon.S2.vsplicerb
llvm.hexagon.S2.vsxtbh
llvm.hexagon.S2.vsxthw
llvm.hexagon.S2.vtrunehb
llvm.hexagon.S2.vtrunewh
llvm.hexagon.S2.vtrunohb
llvm.hexagon.S2.vtrunowh
llvm.hexagon.S2.vzxtbh
llvm.hexagon.S2.vzxthw
llvm.hexagon.S4.addaddi
llvm.hexagon.S4.addi.asl.ri
llvm.hexagon.S4.addi.lsr.ri
llvm.hexagon.S4.andi.asl.ri
llvm.hexagon.S4.andi.lsr.ri
llvm.hexagon.S4.clbaddi
llvm.hexagon.S4.clbpaddi
llvm.hexagon.S4.clbpnorm
llvm.hexagon.S4.extract
llvm.hexagon.S4.extract.rp
llvm.hexagon.S4.extractp
llvm.hexagon.S4.extractp.rp
llvm.hexagon.S4.lsli
llvm.hexagon.S4.ntstbit.i
llvm.hexagon.S4.ntstbit.r
llvm.hexagon.S4.or.andi
llvm.hexagon.S4.or.andix
llvm.hexagon.S4.or.ori
llvm.hexagon.S4.ori.asl.ri
llvm.hexagon.S4.ori.lsr.ri
llvm.hexagon.S4.parity
llvm.hexagon.S4.stored.locked
llvm.hexagon.S4.subaddi
llvm.hexagon.S4.subi.asl.ri
llvm.hexagon.S4.subi.lsr.ri
llvm.hexagon.S4.vrcrotate
llvm.hexagon.S4.vrcrotate.acc
llvm.hexagon.S4.vxaddsubh
llvm.hexagon.S4.vxaddsubhr
llvm.hexagon.S4.vxaddsubw
llvm.hexagon.S4.vxsubaddh
llvm.hexagon.S4.vxsubaddhr
llvm.hexagon.S4.vxsubaddw
llvm.hexagon.S5.asrhub.rnd.sat.goodsyntax
llvm.hexagon.S5.asrhub.sat
llvm.hexagon.S5.popcountp
llvm.hexagon.S5.vasrhrnd.goodsyntax
llvm.hexagon.S6.rol.i.p
llvm.hexagon.S6.rol.i.p.acc
llvm.hexagon.S6.rol.i.p.and
llvm.hexagon.S6.rol.i.p.nac
llvm.hexagon.S6.rol.i.p.or
llvm.hexagon.S6.rol.i.p.xacc
llvm.hexagon.S6.rol.i.r
llvm.hexagon.S6.rol.i.r.acc
llvm.hexagon.S6.rol.i.r.and
llvm.hexagon.S6.rol.i.r.nac
llvm.hexagon.S6.rol.i.r.or
llvm.hexagon.S6.rol.i.r.xacc
llvm.hexagon.S6.vsplatrbp
llvm.hexagon.S6.vtrunehb.ppp
llvm.hexagon.S6.vtrunohb.ppp
llvm.hexagon.V6.extractw
llvm.hexagon.V6.extractw.128B
llvm.hexagon.V6.hi
llvm.hexagon.V6.hi.128B
llvm.hexagon.V6.lo
llvm.hexagon.V6.lo.128B
llvm.hexagon.V6.lvsplatb
llvm.hexagon.V6.lvsplatb.128B
llvm.hexagon.V6.lvsplath
llvm.hexagon.V6.lvsplath.128B
llvm.hexagon.V6.lvsplatw
llvm.hexagon.V6.lvsplatw.128B
llvm.hexagon.V6.pred.and
llvm.hexagon.V6.pred.and.128B
llvm.hexagon.V6.pred.and.n
llvm.hexagon.V6.pred.and.n.128B
llvm.hexagon.V6.pred.not
llvm.hexagon.V6.pred.not.128B
llvm.hexagon.V6.pred.or
llvm.hexagon.V6.pred.or.128B
llvm.hexagon.V6.pred.or.n
llvm.hexagon.V6.pred.or.n.128B
llvm.hexagon.V6.pred.scalar2
llvm.hexagon.V6.pred.scalar2.128B
llvm.hexagon.V6.pred.scalar2v2
llvm.hexagon.V6.pred.scalar2v2.128B
llvm.hexagon.V6.pred.xor
llvm.hexagon.V6.pred.xor.128B
llvm.hexagon.V6.shuffeqh
llvm.hexagon.V6.shuffeqh.128B
llvm.hexagon.V6.shuffeqw
llvm.hexagon.V6.shuffeqw.128B
llvm.hexagon.V6.vS32b.nqpred.ai
llvm.hexagon.V6.vS32b.nqpred.ai.128B
llvm.hexagon.V6.vS32b.nt.nqpred.ai
llvm.hexagon.V6.vS32b.nt.nqpred.ai.128B
llvm.hexagon.V6.vS32b.nt.qpred.ai
llvm.hexagon.V6.vS32b.nt.qpred.ai.128B
llvm.hexagon.V6.vS32b.qpred.ai
llvm.hexagon.V6.vS32b.qpred.ai.128B
llvm.hexagon.V6.vabsb
llvm.hexagon.V6.vabsb.128B
llvm.hexagon.V6.vabsb.sat
llvm.hexagon.V6.vabsb.sat.128B
llvm.hexagon.V6.vabsdiffh
llvm.hexagon.V6.vabsdiffh.128B
llvm.hexagon.V6.vabsdiffub
llvm.hexagon.V6.vabsdiffub.128B
llvm.hexagon.V6.vabsdiffuh
llvm.hexagon.V6.vabsdiffuh.128B
llvm.hexagon.V6.vabsdiffw
llvm.hexagon.V6.vabsdiffw.128B
llvm.hexagon.V6.vabsh
llvm.hexagon.V6.vabsh.128B
llvm.hexagon.V6.vabsh.sat
llvm.hexagon.V6.vabsh.sat.128B
llvm.hexagon.V6.vabsw
llvm.hexagon.V6.vabsw.128B
llvm.hexagon.V6.vabsw.sat
llvm.hexagon.V6.vabsw.sat.128B
llvm.hexagon.V6.vaddb
llvm.hexagon.V6.vaddb.128B
llvm.hexagon.V6.vaddb.dv
llvm.hexagon.V6.vaddb.dv.128B
llvm.hexagon.V6.vaddbnq
llvm.hexagon.V6.vaddbnq.128B
llvm.hexagon.V6.vaddbq
llvm.hexagon.V6.vaddbq.128B
llvm.hexagon.V6.vaddbsat
llvm.hexagon.V6.vaddbsat.128B
llvm.hexagon.V6.vaddbsat.dv
llvm.hexagon.V6.vaddbsat.dv.128B
llvm.hexagon.V6.vaddcarry
llvm.hexagon.V6.vaddcarry.128B
llvm.hexagon.V6.vaddclbh
llvm.hexagon.V6.vaddclbh.128B
llvm.hexagon.V6.vaddclbw
llvm.hexagon.V6.vaddclbw.128B
llvm.hexagon.V6.vaddh
llvm.hexagon.V6.vaddh.128B
llvm.hexagon.V6.vaddh.dv
llvm.hexagon.V6.vaddh.dv.128B
llvm.hexagon.V6.vaddhnq
llvm.hexagon.V6.vaddhnq.128B
llvm.hexagon.V6.vaddhq
llvm.hexagon.V6.vaddhq.128B
llvm.hexagon.V6.vaddhsat
llvm.hexagon.V6.vaddhsat.128B
llvm.hexagon.V6.vaddhsat.dv
llvm.hexagon.V6.vaddhsat.dv.128B
llvm.hexagon.V6.vaddhw
llvm.hexagon.V6.vaddhw.128B
llvm.hexagon.V6.vaddhw.acc
llvm.hexagon.V6.vaddhw.acc.128B
llvm.hexagon.V6.vaddubh
llvm.hexagon.V6.vaddubh.128B
llvm.hexagon.V6.vaddubh.acc
llvm.hexagon.V6.vaddubh.acc.128B
llvm.hexagon.V6.vaddubsat
llvm.hexagon.V6.vaddubsat.128B
llvm.hexagon.V6.vaddubsat.dv
llvm.hexagon.V6.vaddubsat.dv.128B
llvm.hexagon.V6.vaddububb.sat
llvm.hexagon.V6.vaddububb.sat.128B
llvm.hexagon.V6.vadduhsat
llvm.hexagon.V6.vadduhsat.128B
llvm.hexagon.V6.vadduhsat.dv
llvm.hexagon.V6.vadduhsat.dv.128B
llvm.hexagon.V6.vadduhw
llvm.hexagon.V6.vadduhw.128B
llvm.hexagon.V6.vadduhw.acc
llvm.hexagon.V6.vadduhw.acc.128B
llvm.hexagon.V6.vadduwsat
llvm.hexagon.V6.vadduwsat.128B
llvm.hexagon.V6.vadduwsat.dv
llvm.hexagon.V6.vadduwsat.dv.128B
llvm.hexagon.V6.vaddw
llvm.hexagon.V6.vaddw.128B
llvm.hexagon.V6.vaddw.dv
llvm.hexagon.V6.vaddw.dv.128B
llvm.hexagon.V6.vaddwnq
llvm.hexagon.V6.vaddwnq.128B
llvm.hexagon.V6.vaddwq
llvm.hexagon.V6.vaddwq.128B
llvm.hexagon.V6.vaddwsat
llvm.hexagon.V6.vaddwsat.128B
llvm.hexagon.V6.vaddwsat.dv
llvm.hexagon.V6.vaddwsat.dv.128B
llvm.hexagon.V6.valignb
llvm.hexagon.V6.valignb.128B
llvm.hexagon.V6.valignbi
llvm.hexagon.V6.valignbi.128B
llvm.hexagon.V6.vand
llvm.hexagon.V6.vand.128B
llvm.hexagon.V6.vandnqrt
llvm.hexagon.V6.vandnqrt.128B
llvm.hexagon.V6.vandnqrt.acc
llvm.hexagon.V6.vandnqrt.acc.128B
llvm.hexagon.V6.vandqrt
llvm.hexagon.V6.vandqrt.128B
llvm.hexagon.V6.vandqrt.acc
llvm.hexagon.V6.vandqrt.acc.128B
llvm.hexagon.V6.vandvnqv
llvm.hexagon.V6.vandvnqv.128B
llvm.hexagon.V6.vandvqv
llvm.hexagon.V6.vandvqv.128B
llvm.hexagon.V6.vandvrt
llvm.hexagon.V6.vandvrt.128B
llvm.hexagon.V6.vandvrt.acc
llvm.hexagon.V6.vandvrt.acc.128B
llvm.hexagon.V6.vaslh
llvm.hexagon.V6.vaslh.128B
llvm.hexagon.V6.vaslh.acc
llvm.hexagon.V6.vaslh.acc.128B
llvm.hexagon.V6.vaslhv
llvm.hexagon.V6.vaslhv.128B
llvm.hexagon.V6.vaslw
llvm.hexagon.V6.vaslw.128B
llvm.hexagon.V6.vaslw.acc
llvm.hexagon.V6.vaslw.acc.128B
llvm.hexagon.V6.vaslwv
llvm.hexagon.V6.vaslwv.128B
llvm.hexagon.V6.vasrh
llvm.hexagon.V6.vasrh.128B
llvm.hexagon.V6.vasrh.acc
llvm.hexagon.V6.vasrh.acc.128B
llvm.hexagon.V6.vasrhbrndsat
llvm.hexagon.V6.vasrhbrndsat.128B
llvm.hexagon.V6.vasrhbsat
llvm.hexagon.V6.vasrhbsat.128B
llvm.hexagon.V6.vasrhubrndsat
llvm.hexagon.V6.vasrhubrndsat.128B
llvm.hexagon.V6.vasrhubsat
llvm.hexagon.V6.vasrhubsat.128B
llvm.hexagon.V6.vasrhv
llvm.hexagon.V6.vasrhv.128B
llvm.hexagon.V6.vasruhubrndsat
llvm.hexagon.V6.vasruhubrndsat.128B
llvm.hexagon.V6.vasruhubsat
llvm.hexagon.V6.vasruhubsat.128B
llvm.hexagon.V6.vasruwuhrndsat
llvm.hexagon.V6.vasruwuhrndsat.128B
llvm.hexagon.V6.vasruwuhsat
llvm.hexagon.V6.vasruwuhsat.128B
llvm.hexagon.V6.vasrw
llvm.hexagon.V6.vasrw.128B
llvm.hexagon.V6.vasrw.acc
llvm.hexagon.V6.vasrw.acc.128B
llvm.hexagon.V6.vasrwh
llvm.hexagon.V6.vasrwh.128B
llvm.hexagon.V6.vasrwhrndsat
llvm.hexagon.V6.vasrwhrndsat.128B
llvm.hexagon.V6.vasrwhsat
llvm.hexagon.V6.vasrwhsat.128B
llvm.hexagon.V6.vasrwuhrndsat
llvm.hexagon.V6.vasrwuhrndsat.128B
llvm.hexagon.V6.vasrwuhsat
llvm.hexagon.V6.vasrwuhsat.128B
llvm.hexagon.V6.vasrwv
llvm.hexagon.V6.vasrwv.128B
llvm.hexagon.V6.vassign
llvm.hexagon.V6.vassign.128B
llvm.hexagon.V6.vassignp
llvm.hexagon.V6.vassignp.128B
llvm.hexagon.V6.vavgb
llvm.hexagon.V6.vavgb.128B
llvm.hexagon.V6.vavgbrnd
llvm.hexagon.V6.vavgbrnd.128B
llvm.hexagon.V6.vavgh
llvm.hexagon.V6.vavgh.128B
llvm.hexagon.V6.vavghrnd
llvm.hexagon.V6.vavghrnd.128B
llvm.hexagon.V6.vavgub
llvm.hexagon.V6.vavgub.128B
llvm.hexagon.V6.vavgubrnd
llvm.hexagon.V6.vavgubrnd.128B
llvm.hexagon.V6.vavguh
llvm.hexagon.V6.vavguh.128B
llvm.hexagon.V6.vavguhrnd
llvm.hexagon.V6.vavguhrnd.128B
llvm.hexagon.V6.vavguw
llvm.hexagon.V6.vavguw.128B
llvm.hexagon.V6.vavguwrnd
llvm.hexagon.V6.vavguwrnd.128B
llvm.hexagon.V6.vavgw
llvm.hexagon.V6.vavgw.128B
llvm.hexagon.V6.vavgwrnd
llvm.hexagon.V6.vavgwrnd.128B
llvm.hexagon.V6.vcl0h
llvm.hexagon.V6.vcl0h.128B
llvm.hexagon.V6.vcl0w
llvm.hexagon.V6.vcl0w.128B
llvm.hexagon.V6.vcombine
llvm.hexagon.V6.vcombine.128B
llvm.hexagon.V6.vd0
llvm.hexagon.V6.vd0.128B
llvm.hexagon.V6.vdd0
llvm.hexagon.V6.vdd0.128B
llvm.hexagon.V6.vdealb
llvm.hexagon.V6.vdealb.128B
llvm.hexagon.V6.vdealb4w
llvm.hexagon.V6.vdealb4w.128B
llvm.hexagon.V6.vdealh
llvm.hexagon.V6.vdealh.128B
llvm.hexagon.V6.vdealvdd
llvm.hexagon.V6.vdealvdd.128B
llvm.hexagon.V6.vdelta
llvm.hexagon.V6.vdelta.128B
llvm.hexagon.V6.vdmpybus
llvm.hexagon.V6.vdmpybus.128B
llvm.hexagon.V6.vdmpybus.acc
llvm.hexagon.V6.vdmpybus.acc.128B
llvm.hexagon.V6.vdmpybus.dv
llvm.hexagon.V6.vdmpybus.dv.128B
llvm.hexagon.V6.vdmpybus.dv.acc
llvm.hexagon.V6.vdmpybus.dv.acc.128B
llvm.hexagon.V6.vdmpyhb
llvm.hexagon.V6.vdmpyhb.128B
llvm.hexagon.V6.vdmpyhb.acc
llvm.hexagon.V6.vdmpyhb.acc.128B
llvm.hexagon.V6.vdmpyhb.dv
llvm.hexagon.V6.vdmpyhb.dv.128B
llvm.hexagon.V6.vdmpyhb.dv.acc
llvm.hexagon.V6.vdmpyhb.dv.acc.128B
llvm.hexagon.V6.vdmpyhisat
llvm.hexagon.V6.vdmpyhisat.128B
llvm.hexagon.V6.vdmpyhisat.acc
llvm.hexagon.V6.vdmpyhisat.acc.128B
llvm.hexagon.V6.vdmpyhsat
llvm.hexagon.V6.vdmpyhsat.128B
llvm.hexagon.V6.vdmpyhsat.acc
llvm.hexagon.V6.vdmpyhsat.acc.128B
llvm.hexagon.V6.vdmpyhsuisat
llvm.hexagon.V6.vdmpyhsuisat.128B
llvm.hexagon.V6.vdmpyhsuisat.acc
llvm.hexagon.V6.vdmpyhsuisat.acc.128B
llvm.hexagon.V6.vdmpyhsusat
llvm.hexagon.V6.vdmpyhsusat.128B
llvm.hexagon.V6.vdmpyhsusat.acc
llvm.hexagon.V6.vdmpyhsusat.acc.128B
llvm.hexagon.V6.vdmpyhvsat
llvm.hexagon.V6.vdmpyhvsat.128B
llvm.hexagon.V6.vdmpyhvsat.acc
llvm.hexagon.V6.vdmpyhvsat.acc.128B
llvm.hexagon.V6.vdsaduh
llvm.hexagon.V6.vdsaduh.128B
llvm.hexagon.V6.vdsaduh.acc
llvm.hexagon.V6.vdsaduh.acc.128B
llvm.hexagon.V6.veqb
llvm.hexagon.V6.veqb.128B
llvm.hexagon.V6.veqb.and
llvm.hexagon.V6.veqb.and.128B
llvm.hexagon.V6.veqb.or
llvm.hexagon.V6.veqb.or.128B
llvm.hexagon.V6.veqb.xor
llvm.hexagon.V6.veqb.xor.128B
llvm.hexagon.V6.veqh
llvm.hexagon.V6.veqh.128B
llvm.hexagon.V6.veqh.and
llvm.hexagon.V6.veqh.and.128B
llvm.hexagon.V6.veqh.or
llvm.hexagon.V6.veqh.or.128B
llvm.hexagon.V6.veqh.xor
llvm.hexagon.V6.veqh.xor.128B
llvm.hexagon.V6.veqw
llvm.hexagon.V6.veqw.128B
llvm.hexagon.V6.veqw.and
llvm.hexagon.V6.veqw.and.128B
llvm.hexagon.V6.veqw.or
llvm.hexagon.V6.veqw.or.128B
llvm.hexagon.V6.veqw.xor
llvm.hexagon.V6.veqw.xor.128B
llvm.hexagon.V6.vgathermh
llvm.hexagon.V6.vgathermh.128B
llvm.hexagon.V6.vgathermhq
llvm.hexagon.V6.vgathermhq.128B
llvm.hexagon.V6.vgathermhw
llvm.hexagon.V6.vgathermhw.128B
llvm.hexagon.V6.vgathermhwq
llvm.hexagon.V6.vgathermhwq.128B
llvm.hexagon.V6.vgathermw
llvm.hexagon.V6.vgathermw.128B
llvm.hexagon.V6.vgathermwq
llvm.hexagon.V6.vgathermwq.128B
llvm.hexagon.V6.vgtb
llvm.hexagon.V6.vgtb.128B
llvm.hexagon.V6.vgtb.and
llvm.hexagon.V6.vgtb.and.128B
llvm.hexagon.V6.vgtb.or
llvm.hexagon.V6.vgtb.or.128B
llvm.hexagon.V6.vgtb.xor
llvm.hexagon.V6.vgtb.xor.128B
llvm.hexagon.V6.vgth
llvm.hexagon.V6.vgth.128B
llvm.hexagon.V6.vgth.and
llvm.hexagon.V6.vgth.and.128B
llvm.hexagon.V6.vgth.or
llvm.hexagon.V6.vgth.or.128B
llvm.hexagon.V6.vgth.xor
llvm.hexagon.V6.vgth.xor.128B
llvm.hexagon.V6.vgtub
llvm.hexagon.V6.vgtub.128B
llvm.hexagon.V6.vgtub.and
llvm.hexagon.V6.vgtub.and.128B
llvm.hexagon.V6.vgtub.or
llvm.hexagon.V6.vgtub.or.128B
llvm.hexagon.V6.vgtub.xor
llvm.hexagon.V6.vgtub.xor.128B
llvm.hexagon.V6.vgtuh
llvm.hexagon.V6.vgtuh.128B
llvm.hexagon.V6.vgtuh.and
llvm.hexagon.V6.vgtuh.and.128B
llvm.hexagon.V6.vgtuh.or
llvm.hexagon.V6.vgtuh.or.128B
llvm.hexagon.V6.vgtuh.xor
llvm.hexagon.V6.vgtuh.xor.128B
llvm.hexagon.V6.vgtuw
llvm.hexagon.V6.vgtuw.128B
llvm.hexagon.V6.vgtuw.and
llvm.hexagon.V6.vgtuw.and.128B
llvm.hexagon.V6.vgtuw.or
llvm.hexagon.V6.vgtuw.or.128B
llvm.hexagon.V6.vgtuw.xor
llvm.hexagon.V6.vgtuw.xor.128B
llvm.hexagon.V6.vgtw
llvm.hexagon.V6.vgtw.128B
llvm.hexagon.V6.vgtw.and
llvm.hexagon.V6.vgtw.and.128B
llvm.hexagon.V6.vgtw.or
llvm.hexagon.V6.vgtw.or.128B
llvm.hexagon.V6.vgtw.xor
llvm.hexagon.V6.vgtw.xor.128B
llvm.hexagon.V6.vinsertwr
llvm.hexagon.V6.vinsertwr.128B
llvm.hexagon.V6.vlalignb
llvm.hexagon.V6.vlalignb.128B
llvm.hexagon.V6.vlalignbi
llvm.hexagon.V6.vlalignbi.128B
llvm.hexagon.V6.vlsrb
llvm.hexagon.V6.vlsrb.128B
llvm.hexagon.V6.vlsrh
llvm.hexagon.V6.vlsrh.128B
llvm.hexagon.V6.vlsrhv
llvm.hexagon.V6.vlsrhv.128B
llvm.hexagon.V6.vlsrw
llvm.hexagon.V6.vlsrw.128B
llvm.hexagon.V6.vlsrwv
llvm.hexagon.V6.vlsrwv.128B
llvm.hexagon.V6.vlut4
llvm.hexagon.V6.vlut4.128B
llvm.hexagon.V6.vlutvvb
llvm.hexagon.V6.vlutvvb.128B
llvm.hexagon.V6.vlutvvb.nm
llvm.hexagon.V6.vlutvvb.nm.128B
llvm.hexagon.V6.vlutvvb.oracc
llvm.hexagon.V6.vlutvvb.oracc.128B
llvm.hexagon.V6.vlutvvb.oracci
llvm.hexagon.V6.vlutvvb.oracci.128B
llvm.hexagon.V6.vlutvvbi
llvm.hexagon.V6.vlutvvbi.128B
llvm.hexagon.V6.vlutvwh
llvm.hexagon.V6.vlutvwh.128B
llvm.hexagon.V6.vlutvwh.nm
llvm.hexagon.V6.vlutvwh.nm.128B
llvm.hexagon.V6.vlutvwh.oracc
llvm.hexagon.V6.vlutvwh.oracc.128B
llvm.hexagon.V6.vlutvwh.oracci
llvm.hexagon.V6.vlutvwh.oracci.128B
llvm.hexagon.V6.vlutvwhi
llvm.hexagon.V6.vlutvwhi.128B
llvm.hexagon.V6.vmaskedstorenq
llvm.hexagon.V6.vmaskedstorenq.128B
llvm.hexagon.V6.vmaskedstorentnq
llvm.hexagon.V6.vmaskedstorentnq.128B
llvm.hexagon.V6.vmaskedstorentq
llvm.hexagon.V6.vmaskedstorentq.128B
llvm.hexagon.V6.vmaskedstoreq
llvm.hexagon.V6.vmaskedstoreq.128B
llvm.hexagon.V6.vmaxb
llvm.hexagon.V6.vmaxb.128B
llvm.hexagon.V6.vmaxh
llvm.hexagon.V6.vmaxh.128B
llvm.hexagon.V6.vmaxub
llvm.hexagon.V6.vmaxub.128B
llvm.hexagon.V6.vmaxuh
llvm.hexagon.V6.vmaxuh.128B
llvm.hexagon.V6.vmaxw
llvm.hexagon.V6.vmaxw.128B
llvm.hexagon.V6.vminb
llvm.hexagon.V6.vminb.128B
llvm.hexagon.V6.vminh
llvm.hexagon.V6.vminh.128B
llvm.hexagon.V6.vminub
llvm.hexagon.V6.vminub.128B
llvm.hexagon.V6.vminuh
llvm.hexagon.V6.vminuh.128B
llvm.hexagon.V6.vminw
llvm.hexagon.V6.vminw.128B
llvm.hexagon.V6.vmpabus
llvm.hexagon.V6.vmpabus.128B
llvm.hexagon.V6.vmpabus.acc
llvm.hexagon.V6.vmpabus.acc.128B
llvm.hexagon.V6.vmpabusv
llvm.hexagon.V6.vmpabusv.128B
llvm.hexagon.V6.vmpabuu
llvm.hexagon.V6.vmpabuu.128B
llvm.hexagon.V6.vmpabuu.acc
llvm.hexagon.V6.vmpabuu.acc.128B
llvm.hexagon.V6.vmpabuuv
llvm.hexagon.V6.vmpabuuv.128B
llvm.hexagon.V6.vmpahb
llvm.hexagon.V6.vmpahb.128B
llvm.hexagon.V6.vmpahb.acc
llvm.hexagon.V6.vmpahb.acc.128B
llvm.hexagon.V6.vmpahhsat
llvm.hexagon.V6.vmpahhsat.128B
llvm.hexagon.V6.vmpauhb
llvm.hexagon.V6.vmpauhb.128B
llvm.hexagon.V6.vmpauhb.acc
llvm.hexagon.V6.vmpauhb.acc.128B
llvm.hexagon.V6.vmpauhuhsat
llvm.hexagon.V6.vmpauhuhsat.128B
llvm.hexagon.V6.vmpsuhuhsat
llvm.hexagon.V6.vmpsuhuhsat.128B
llvm.hexagon.V6.vmpybus
llvm.hexagon.V6.vmpybus.128B
llvm.hexagon.V6.vmpybus.acc
llvm.hexagon.V6.vmpybus.acc.128B
llvm.hexagon.V6.vmpybusv
llvm.hexagon.V6.vmpybusv.128B
llvm.hexagon.V6.vmpybusv.acc
llvm.hexagon.V6.vmpybusv.acc.128B
llvm.hexagon.V6.vmpybv
llvm.hexagon.V6.vmpybv.128B
llvm.hexagon.V6.vmpybv.acc
llvm.hexagon.V6.vmpybv.acc.128B
llvm.hexagon.V6.vmpyewuh
llvm.hexagon.V6.vmpyewuh.128B
llvm.hexagon.V6.vmpyewuh.64
llvm.hexagon.V6.vmpyewuh.64.128B
llvm.hexagon.V6.vmpyh
llvm.hexagon.V6.vmpyh.128B
llvm.hexagon.V6.vmpyh.acc
llvm.hexagon.V6.vmpyh.acc.128B
llvm.hexagon.V6.vmpyhsat.acc
llvm.hexagon.V6.vmpyhsat.acc.128B
llvm.hexagon.V6.vmpyhsrs
llvm.hexagon.V6.vmpyhsrs.128B
llvm.hexagon.V6.vmpyhss
llvm.hexagon.V6.vmpyhss.128B
llvm.hexagon.V6.vmpyhus
llvm.hexagon.V6.vmpyhus.128B
llvm.hexagon.V6.vmpyhus.acc
llvm.hexagon.V6.vmpyhus.acc.128B
llvm.hexagon.V6.vmpyhv
llvm.hexagon.V6.vmpyhv.128B
llvm.hexagon.V6.vmpyhv.acc
llvm.hexagon.V6.vmpyhv.acc.128B
llvm.hexagon.V6.vmpyhvsrs
llvm.hexagon.V6.vmpyhvsrs.128B
llvm.hexagon.V6.vmpyieoh
llvm.hexagon.V6.vmpyieoh.128B
llvm.hexagon.V6.vmpyiewh.acc
llvm.hexagon.V6.vmpyiewh.acc.128B
llvm.hexagon.V6.vmpyiewuh
llvm.hexagon.V6.vmpyiewuh.128B
llvm.hexagon.V6.vmpyiewuh.acc
llvm.hexagon.V6.vmpyiewuh.acc.128B
llvm.hexagon.V6.vmpyih
llvm.hexagon.V6.vmpyih.128B
llvm.hexagon.V6.vmpyih.acc
llvm.hexagon.V6.vmpyih.acc.128B
llvm.hexagon.V6.vmpyihb
llvm.hexagon.V6.vmpyihb.128B
llvm.hexagon.V6.vmpyihb.acc
llvm.hexagon.V6.vmpyihb.acc.128B
llvm.hexagon.V6.vmpyiowh
llvm.hexagon.V6.vmpyiowh.128B
llvm.hexagon.V6.vmpyiwb
llvm.hexagon.V6.vmpyiwb.128B
llvm.hexagon.V6.vmpyiwb.acc
llvm.hexagon.V6.vmpyiwb.acc.128B
llvm.hexagon.V6.vmpyiwh
llvm.hexagon.V6.vmpyiwh.128B
llvm.hexagon.V6.vmpyiwh.acc
llvm.hexagon.V6.vmpyiwh.acc.128B
llvm.hexagon.V6.vmpyiwub
llvm.hexagon.V6.vmpyiwub.128B
llvm.hexagon.V6.vmpyiwub.acc
llvm.hexagon.V6.vmpyiwub.acc.128B
llvm.hexagon.V6.vmpyowh
llvm.hexagon.V6.vmpyowh.128B
llvm.hexagon.V6.vmpyowh.64.acc
llvm.hexagon.V6.vmpyowh.64.acc.128B
llvm.hexagon.V6.vmpyowh.rnd
llvm.hexagon.V6.vmpyowh.rnd.128B
llvm.hexagon.V6.vmpyowh.rnd.sacc
llvm.hexagon.V6.vmpyowh.rnd.sacc.128B
llvm.hexagon.V6.vmpyowh.sacc
llvm.hexagon.V6.vmpyowh.sacc.128B
llvm.hexagon.V6.vmpyub
llvm.hexagon.V6.vmpyub.128B
llvm.hexagon.V6.vmpyub.acc
llvm.hexagon.V6.vmpyub.acc.128B
llvm.hexagon.V6.vmpyubv
llvm.hexagon.V6.vmpyubv.128B
llvm.hexagon.V6.vmpyubv.acc
llvm.hexagon.V6.vmpyubv.acc.128B
llvm.hexagon.V6.vmpyuh
llvm.hexagon.V6.vmpyuh.128B
llvm.hexagon.V6.vmpyuh.acc
llvm.hexagon.V6.vmpyuh.acc.128B
llvm.hexagon.V6.vmpyuhe
llvm.hexagon.V6.vmpyuhe.128B
llvm.hexagon.V6.vmpyuhe.acc
llvm.hexagon.V6.vmpyuhe.acc.128B
llvm.hexagon.V6.vmpyuhv
llvm.hexagon.V6.vmpyuhv.128B
llvm.hexagon.V6.vmpyuhv.acc
llvm.hexagon.V6.vmpyuhv.acc.128B
llvm.hexagon.V6.vmux
llvm.hexagon.V6.vmux.128B
llvm.hexagon.V6.vnavgb
llvm.hexagon.V6.vnavgb.128B
llvm.hexagon.V6.vnavgh
llvm.hexagon.V6.vnavgh.128B
llvm.hexagon.V6.vnavgub
llvm.hexagon.V6.vnavgub.128B
llvm.hexagon.V6.vnavgw
llvm.hexagon.V6.vnavgw.128B
llvm.hexagon.V6.vnormamth
llvm.hexagon.V6.vnormamth.128B
llvm.hexagon.V6.vnormamtw
llvm.hexagon.V6.vnormamtw.128B
llvm.hexagon.V6.vnot
llvm.hexagon.V6.vnot.128B
llvm.hexagon.V6.vor
llvm.hexagon.V6.vor.128B
llvm.hexagon.V6.vpackeb
llvm.hexagon.V6.vpackeb.128B
llvm.hexagon.V6.vpackeh
llvm.hexagon.V6.vpackeh.128B
llvm.hexagon.V6.vpackhb.sat
llvm.hexagon.V6.vpackhb.sat.128B
llvm.hexagon.V6.vpackhub.sat
llvm.hexagon.V6.vpackhub.sat.128B
llvm.hexagon.V6.vpackob
llvm.hexagon.V6.vpackob.128B
llvm.hexagon.V6.vpackoh
llvm.hexagon.V6.vpackoh.128B
llvm.hexagon.V6.vpackwh.sat
llvm.hexagon.V6.vpackwh.sat.128B
llvm.hexagon.V6.vpackwuh.sat
llvm.hexagon.V6.vpackwuh.sat.128B
llvm.hexagon.V6.vpopcounth
llvm.hexagon.V6.vpopcounth.128B
llvm.hexagon.V6.vprefixqb
llvm.hexagon.V6.vprefixqb.128B
llvm.hexagon.V6.vprefixqh
llvm.hexagon.V6.vprefixqh.128B
llvm.hexagon.V6.vprefixqw
llvm.hexagon.V6.vprefixqw.128B
llvm.hexagon.V6.vrdelta
llvm.hexagon.V6.vrdelta.128B
llvm.hexagon.V6.vrmpybub.rtt
llvm.hexagon.V6.vrmpybub.rtt.128B
llvm.hexagon.V6.vrmpybub.rtt.acc
llvm.hexagon.V6.vrmpybub.rtt.acc.128B
llvm.hexagon.V6.vrmpybus
llvm.hexagon.V6.vrmpybus.128B
llvm.hexagon.V6.vrmpybus.acc
llvm.hexagon.V6.vrmpybus.acc.128B
llvm.hexagon.V6.vrmpybusi
llvm.hexagon.V6.vrmpybusi.128B
llvm.hexagon.V6.vrmpybusi.acc
llvm.hexagon.V6.vrmpybusi.acc.128B
llvm.hexagon.V6.vrmpybusv
llvm.hexagon.V6.vrmpybusv.128B
llvm.hexagon.V6.vrmpybusv.acc
llvm.hexagon.V6.vrmpybusv.acc.128B
llvm.hexagon.V6.vrmpybv
llvm.hexagon.V6.vrmpybv.128B
llvm.hexagon.V6.vrmpybv.acc
llvm.hexagon.V6.vrmpybv.acc.128B
llvm.hexagon.V6.vrmpyub
llvm.hexagon.V6.vrmpyub.128B
llvm.hexagon.V6.vrmpyub.acc
llvm.hexagon.V6.vrmpyub.acc.128B
llvm.hexagon.V6.vrmpyub.rtt
llvm.hexagon.V6.vrmpyub.rtt.128B
llvm.hexagon.V6.vrmpyub.rtt.acc
llvm.hexagon.V6.vrmpyub.rtt.acc.128B
llvm.hexagon.V6.vrmpyubi
llvm.hexagon.V6.vrmpyubi.128B
llvm.hexagon.V6.vrmpyubi.acc
llvm.hexagon.V6.vrmpyubi.acc.128B
llvm.hexagon.V6.vrmpyubv
llvm.hexagon.V6.vrmpyubv.128B
llvm.hexagon.V6.vrmpyubv.acc
llvm.hexagon.V6.vrmpyubv.acc.128B
llvm.hexagon.V6.vror
llvm.hexagon.V6.vror.128B
llvm.hexagon.V6.vroundhb
llvm.hexagon.V6.vroundhb.128B
llvm.hexagon.V6.vroundhub
llvm.hexagon.V6.vroundhub.128B
llvm.hexagon.V6.vrounduhub
llvm.hexagon.V6.vrounduhub.128B
llvm.hexagon.V6.vrounduwuh
llvm.hexagon.V6.vrounduwuh.128B
llvm.hexagon.V6.vroundwh
llvm.hexagon.V6.vroundwh.128B
llvm.hexagon.V6.vroundwuh
llvm.hexagon.V6.vroundwuh.128B
llvm.hexagon.V6.vrsadubi
llvm.hexagon.V6.vrsadubi.128B
llvm.hexagon.V6.vrsadubi.acc
llvm.hexagon.V6.vrsadubi.acc.128B
llvm.hexagon.V6.vsathub
llvm.hexagon.V6.vsathub.128B
llvm.hexagon.V6.vsatuwuh
llvm.hexagon.V6.vsatuwuh.128B
llvm.hexagon.V6.vsatwh
llvm.hexagon.V6.vsatwh.128B
llvm.hexagon.V6.vsb
llvm.hexagon.V6.vsb.128B
llvm.hexagon.V6.vscattermh
llvm.hexagon.V6.vscattermh.128B
llvm.hexagon.V6.vscattermh.add
llvm.hexagon.V6.vscattermh.add.128B
llvm.hexagon.V6.vscattermhq
llvm.hexagon.V6.vscattermhq.128B
llvm.hexagon.V6.vscattermhw
llvm.hexagon.V6.vscattermhw.128B
llvm.hexagon.V6.vscattermhw.add
llvm.hexagon.V6.vscattermhw.add.128B
llvm.hexagon.V6.vscattermhwq
llvm.hexagon.V6.vscattermhwq.128B
llvm.hexagon.V6.vscattermw
llvm.hexagon.V6.vscattermw.128B
llvm.hexagon.V6.vscattermw.add
llvm.hexagon.V6.vscattermw.add.128B
llvm.hexagon.V6.vscattermwq
llvm.hexagon.V6.vscattermwq.128B
llvm.hexagon.V6.vsh
llvm.hexagon.V6.vsh.128B
llvm.hexagon.V6.vshufeh
llvm.hexagon.V6.vshufeh.128B
llvm.hexagon.V6.vshuffb
llvm.hexagon.V6.vshuffb.128B
llvm.hexagon.V6.vshuffeb
llvm.hexagon.V6.vshuffeb.128B
llvm.hexagon.V6.vshuffh
llvm.hexagon.V6.vshuffh.128B
llvm.hexagon.V6.vshuffob
llvm.hexagon.V6.vshuffob.128B
llvm.hexagon.V6.vshuffvdd
llvm.hexagon.V6.vshuffvdd.128B
llvm.hexagon.V6.vshufoeb
llvm.hexagon.V6.vshufoeb.128B
llvm.hexagon.V6.vshufoeh
llvm.hexagon.V6.vshufoeh.128B
llvm.hexagon.V6.vshufoh
llvm.hexagon.V6.vshufoh.128B
llvm.hexagon.V6.vsubb
llvm.hexagon.V6.vsubb.128B
llvm.hexagon.V6.vsubb.dv
llvm.hexagon.V6.vsubb.dv.128B
llvm.hexagon.V6.vsubbnq
llvm.hexagon.V6.vsubbnq.128B
llvm.hexagon.V6.vsubbq
llvm.hexagon.V6.vsubbq.128B
llvm.hexagon.V6.vsubbsat
llvm.hexagon.V6.vsubbsat.128B
llvm.hexagon.V6.vsubbsat.dv
llvm.hexagon.V6.vsubbsat.dv.128B
llvm.hexagon.V6.vsubcarry
llvm.hexagon.V6.vsubcarry.128B
llvm.hexagon.V6.vsubh
llvm.hexagon.V6.vsubh.128B
llvm.hexagon.V6.vsubh.dv
llvm.hexagon.V6.vsubh.dv.128B
llvm.hexagon.V6.vsubhnq
llvm.hexagon.V6.vsubhnq.128B
llvm.hexagon.V6.vsubhq
llvm.hexagon.V6.vsubhq.128B
llvm.hexagon.V6.vsubhsat
llvm.hexagon.V6.vsubhsat.128B
llvm.hexagon.V6.vsubhsat.dv
llvm.hexagon.V6.vsubhsat.dv.128B
llvm.hexagon.V6.vsubhw
llvm.hexagon.V6.vsubhw.128B
llvm.hexagon.V6.vsububh
llvm.hexagon.V6.vsububh.128B
llvm.hexagon.V6.vsububsat
llvm.hexagon.V6.vsububsat.128B
llvm.hexagon.V6.vsububsat.dv
llvm.hexagon.V6.vsububsat.dv.128B
llvm.hexagon.V6.vsubububb.sat
llvm.hexagon.V6.vsubububb.sat.128B
llvm.hexagon.V6.vsubuhsat
llvm.hexagon.V6.vsubuhsat.128B
llvm.hexagon.V6.vsubuhsat.dv
llvm.hexagon.V6.vsubuhsat.dv.128B
llvm.hexagon.V6.vsubuhw
llvm.hexagon.V6.vsubuhw.128B
llvm.hexagon.V6.vsubuwsat
llvm.hexagon.V6.vsubuwsat.128B
llvm.hexagon.V6.vsubuwsat.dv
llvm.hexagon.V6.vsubuwsat.dv.128B
llvm.hexagon.V6.vsubw
llvm.hexagon.V6.vsubw.128B
llvm.hexagon.V6.vsubw.dv
llvm.hexagon.V6.vsubw.dv.128B
llvm.hexagon.V6.vsubwnq
llvm.hexagon.V6.vsubwnq.128B
llvm.hexagon.V6.vsubwq
llvm.hexagon.V6.vsubwq.128B
llvm.hexagon.V6.vsubwsat
llvm.hexagon.V6.vsubwsat.128B
llvm.hexagon.V6.vsubwsat.dv
llvm.hexagon.V6.vsubwsat.dv.128B
llvm.hexagon.V6.vswap
llvm.hexagon.V6.vswap.128B
llvm.hexagon.V6.vtmpyb
llvm.hexagon.V6.vtmpyb.128B
llvm.hexagon.V6.vtmpyb.acc
llvm.hexagon.V6.vtmpyb.acc.128B
llvm.hexagon.V6.vtmpybus
llvm.hexagon.V6.vtmpybus.128B
llvm.hexagon.V6.vtmpybus.acc
llvm.hexagon.V6.vtmpybus.acc.128B
llvm.hexagon.V6.vtmpyhb
llvm.hexagon.V6.vtmpyhb.128B
llvm.hexagon.V6.vtmpyhb.acc
llvm.hexagon.V6.vtmpyhb.acc.128B
llvm.hexagon.V6.vunpackb
llvm.hexagon.V6.vunpackb.128B
llvm.hexagon.V6.vunpackh
llvm.hexagon.V6.vunpackh.128B
llvm.hexagon.V6.vunpackob
llvm.hexagon.V6.vunpackob.128B
llvm.hexagon.V6.vunpackoh
llvm.hexagon.V6.vunpackoh.128B
llvm.hexagon.V6.vunpackub
llvm.hexagon.V6.vunpackub.128B
llvm.hexagon.V6.vunpackuh
llvm.hexagon.V6.vunpackuh.128B
llvm.hexagon.V6.vxor
llvm.hexagon.V6.vxor.128B
llvm.hexagon.V6.vzb
llvm.hexagon.V6.vzb.128B
llvm.hexagon.V6.vzh
llvm.hexagon.V6.vzh.128B
llvm.hexagon.Y2.dccleana
llvm.hexagon.Y2.dccleaninva
llvm.hexagon.Y2.dcinva
llvm.hexagon.Y2.dczeroa
llvm.hexagon.Y4.l2fetch
llvm.hexagon.Y5.l2fetch
llvm.hexagon.circ.ldb
llvm.hexagon.circ.ldd
llvm.hexagon.circ.ldh
llvm.hexagon.circ.ldub
llvm.hexagon.circ.lduh
llvm.hexagon.circ.ldw
llvm.hexagon.circ.stb
llvm.hexagon.circ.std
llvm.hexagon.circ.sth
llvm.hexagon.circ.sthhi
llvm.hexagon.circ.stw
llvm.hexagon.mm256i.vaddw
llvm.hexagon.prefetch
llvm.mips.absq.s.ph
llvm.mips.absq.s.qb
llvm.mips.absq.s.w
llvm.mips.add.a.b
llvm.mips.add.a.d
llvm.mips.add.a.h
llvm.mips.add.a.w
llvm.mips.addq.ph
llvm.mips.addq.s.ph
llvm.mips.addq.s.w
llvm.mips.addqh.ph
llvm.mips.addqh.r.ph
llvm.mips.addqh.r.w
llvm.mips.addqh.w
llvm.mips.adds.a.b
llvm.mips.adds.a.d
llvm.mips.adds.a.h
llvm.mips.adds.a.w
llvm.mips.adds.s.b
llvm.mips.adds.s.d
llvm.mips.adds.s.h
llvm.mips.adds.s.w
llvm.mips.adds.u.b
llvm.mips.adds.u.d
llvm.mips.adds.u.h
llvm.mips.adds.u.w
llvm.mips.addsc
llvm.mips.addu.ph
llvm.mips.addu.qb
llvm.mips.addu.s.ph
llvm.mips.addu.s.qb
llvm.mips.adduh.qb
llvm.mips.adduh.r.qb
llvm.mips.addv.b
llvm.mips.addv.d
llvm.mips.addv.h
llvm.mips.addv.w
llvm.mips.addvi.b
llvm.mips.addvi.d
llvm.mips.addvi.h
llvm.mips.addvi.w
llvm.mips.addwc
llvm.mips.and.v
llvm.mips.andi.b
llvm.mips.append
llvm.mips.asub.s.b
llvm.mips.asub.s.d
llvm.mips.asub.s.h
llvm.mips.asub.s.w
llvm.mips.asub.u.b
llvm.mips.asub.u.d
llvm.mips.asub.u.h
llvm.mips.asub.u.w
llvm.mips.ave.s.b
llvm.mips.ave.s.d
llvm.mips.ave.s.h
llvm.mips.ave.s.w
llvm.mips.ave.u.b
llvm.mips.ave.u.d
llvm.mips.ave.u.h
llvm.mips.ave.u.w
llvm.mips.aver.s.b
llvm.mips.aver.s.d
llvm.mips.aver.s.h
llvm.mips.aver.s.w
llvm.mips.aver.u.b
llvm.mips.aver.u.d
llvm.mips.aver.u.h
llvm.mips.aver.u.w
llvm.mips.balign
llvm.mips.bclr.b
llvm.mips.bclr.d
llvm.mips.bclr.h
llvm.mips.bclr.w
llvm.mips.bclri.b
llvm.mips.bclri.d
llvm.mips.bclri.h
llvm.mips.bclri.w
llvm.mips.binsl.b
llvm.mips.binsl.d
llvm.mips.binsl.h
llvm.mips.binsl.w
llvm.mips.binsli.b
llvm.mips.binsli.d
llvm.mips.binsli.h
llvm.mips.binsli.w
llvm.mips.binsr.b
llvm.mips.binsr.d
llvm.mips.binsr.h
llvm.mips.binsr.w
llvm.mips.binsri.b
llvm.mips.binsri.d
llvm.mips.binsri.h
llvm.mips.binsri.w
llvm.mips.bitrev
llvm.mips.bmnz.v
llvm.mips.bmnzi.b
llvm.mips.bmz.v
llvm.mips.bmzi.b
llvm.mips.bneg.b
llvm.mips.bneg.d
llvm.mips.bneg.h
llvm.mips.bneg.w
llvm.mips.bnegi.b
llvm.mips.bnegi.d
llvm.mips.bnegi.h
llvm.mips.bnegi.w
llvm.mips.bnz.b
llvm.mips.bnz.d
llvm.mips.bnz.h
llvm.mips.bnz.v
llvm.mips.bnz.w
llvm.mips.bposge32
llvm.mips.bsel.v
llvm.mips.bseli.b
llvm.mips.bset.b
llvm.mips.bset.d
llvm.mips.bset.h
llvm.mips.bset.w
llvm.mips.bseti.b
llvm.mips.bseti.d
llvm.mips.bseti.h
llvm.mips.bseti.w
llvm.mips.bz.b
llvm.mips.bz.d
llvm.mips.bz.h
llvm.mips.bz.v
llvm.mips.bz.w
llvm.mips.ceq.b
llvm.mips.ceq.d
llvm.mips.ceq.h
llvm.mips.ceq.w
llvm.mips.ceqi.b
llvm.mips.ceqi.d
llvm.mips.ceqi.h
llvm.mips.ceqi.w
llvm.mips.cfcmsa
llvm.mips.cle.s.b
llvm.mips.cle.s.d
llvm.mips.cle.s.h
llvm.mips.cle.s.w
llvm.mips.cle.u.b
llvm.mips.cle.u.d
llvm.mips.cle.u.h
llvm.mips.cle.u.w
llvm.mips.clei.s.b
llvm.mips.clei.s.d
llvm.mips.clei.s.h
llvm.mips.clei.s.w
llvm.mips.clei.u.b
llvm.mips.clei.u.d
llvm.mips.clei.u.h
llvm.mips.clei.u.w
llvm.mips.clt.s.b
llvm.mips.clt.s.d
llvm.mips.clt.s.h
llvm.mips.clt.s.w
llvm.mips.clt.u.b
llvm.mips.clt.u.d
llvm.mips.clt.u.h
llvm.mips.clt.u.w
llvm.mips.clti.s.b
llvm.mips.clti.s.d
llvm.mips.clti.s.h
llvm.mips.clti.s.w
llvm.mips.clti.u.b
llvm.mips.clti.u.d
llvm.mips.clti.u.h
llvm.mips.clti.u.w
llvm.mips.cmp.eq.ph
llvm.mips.cmp.le.ph
llvm.mips.cmp.lt.ph
llvm.mips.cmpgdu.eq.qb
llvm.mips.cmpgdu.le.qb
llvm.mips.cmpgdu.lt.qb
llvm.mips.cmpgu.eq.qb
llvm.mips.cmpgu.le.qb
llvm.mips.cmpgu.lt.qb
llvm.mips.cmpu.eq.qb
llvm.mips.cmpu.le.qb
llvm.mips.cmpu.lt.qb
llvm.mips.copy.s.b
llvm.mips.copy.s.d
llvm.mips.copy.s.h
llvm.mips.copy.s.w
llvm.mips.copy.u.b
llvm.mips.copy.u.d
llvm.mips.copy.u.h
llvm.mips.copy.u.w
llvm.mips.ctcmsa
llvm.mips.div.s.b
llvm.mips.div.s.d
llvm.mips.div.s.h
llvm.mips.div.s.w
llvm.mips.div.u.b
llvm.mips.div.u.d
llvm.mips.div.u.h
llvm.mips.div.u.w
llvm.mips.dlsa
llvm.mips.dotp.s.d
llvm.mips.dotp.s.h
llvm.mips.dotp.s.w
llvm.mips.dotp.u.d
llvm.mips.dotp.u.h
llvm.mips.dotp.u.w
llvm.mips.dpa.w.ph
llvm.mips.dpadd.s.d
llvm.mips.dpadd.s.h
llvm.mips.dpadd.s.w
llvm.mips.dpadd.u.d
llvm.mips.dpadd.u.h
llvm.mips.dpadd.u.w
llvm.mips.dpaq.s.w.ph
llvm.mips.dpaq.sa.l.w
llvm.mips.dpaqx.s.w.ph
llvm.mips.dpaqx.sa.w.ph
llvm.mips.dpau.h.qbl
llvm.mips.dpau.h.qbr
llvm.mips.dpax.w.ph
llvm.mips.dps.w.ph
llvm.mips.dpsq.s.w.ph
llvm.mips.dpsq.sa.l.w
llvm.mips.dpsqx.s.w.ph
llvm.mips.dpsqx.sa.w.ph
llvm.mips.dpsu.h.qbl
llvm.mips.dpsu.h.qbr
llvm.mips.dpsub.s.d
llvm.mips.dpsub.s.h
llvm.mips.dpsub.s.w
llvm.mips.dpsub.u.d
llvm.mips.dpsub.u.h
llvm.mips.dpsub.u.w
llvm.mips.dpsx.w.ph
llvm.mips.extp
llvm.mips.extpdp
llvm.mips.extr.r.w
llvm.mips.extr.rs.w
llvm.mips.extr.s.h
llvm.mips.extr.w
llvm.mips.fadd.d
llvm.mips.fadd.w
llvm.mips.fcaf.d
llvm.mips.fcaf.w
llvm.mips.fceq.d
llvm.mips.fceq.w
llvm.mips.fclass.d
llvm.mips.fclass.w
llvm.mips.fcle.d
llvm.mips.fcle.w
llvm.mips.fclt.d
llvm.mips.fclt.w
llvm.mips.fcne.d
llvm.mips.fcne.w
llvm.mips.fcor.d
llvm.mips.fcor.w
llvm.mips.fcueq.d
llvm.mips.fcueq.w
llvm.mips.fcule.d
llvm.mips.fcule.w
llvm.mips.fcult.d
llvm.mips.fcult.w
llvm.mips.fcun.d
llvm.mips.fcun.w
llvm.mips.fcune.d
llvm.mips.fcune.w
llvm.mips.fdiv.d
llvm.mips.fdiv.w
llvm.mips.fexdo.h
llvm.mips.fexdo.w
llvm.mips.fexp2.d
llvm.mips.fexp2.w
llvm.mips.fexupl.d
llvm.mips.fexupl.w
llvm.mips.fexupr.d
llvm.mips.fexupr.w
llvm.mips.ffint.s.d
llvm.mips.ffint.s.w
llvm.mips.ffint.u.d
llvm.mips.ffint.u.w
llvm.mips.ffql.d
llvm.mips.ffql.w
llvm.mips.ffqr.d
llvm.mips.ffqr.w
llvm.mips.fill.b
llvm.mips.fill.d
llvm.mips.fill.h
llvm.mips.fill.w
llvm.mips.flog2.d
llvm.mips.flog2.w
llvm.mips.fmadd.d
llvm.mips.fmadd.w
llvm.mips.fmax.a.d
llvm.mips.fmax.a.w
llvm.mips.fmax.d
llvm.mips.fmax.w
llvm.mips.fmin.a.d
llvm.mips.fmin.a.w
llvm.mips.fmin.d
llvm.mips.fmin.w
llvm.mips.fmsub.d
llvm.mips.fmsub.w
llvm.mips.fmul.d
llvm.mips.fmul.w
llvm.mips.frcp.d
llvm.mips.frcp.w
llvm.mips.frint.d
llvm.mips.frint.w
llvm.mips.frsqrt.d
llvm.mips.frsqrt.w
llvm.mips.fsaf.d
llvm.mips.fsaf.w
llvm.mips.fseq.d
llvm.mips.fseq.w
llvm.mips.fsle.d
llvm.mips.fsle.w
llvm.mips.fslt.d
llvm.mips.fslt.w
llvm.mips.fsne.d
llvm.mips.fsne.w
llvm.mips.fsor.d
llvm.mips.fsor.w
llvm.mips.fsqrt.d
llvm.mips.fsqrt.w
llvm.mips.fsub.d
llvm.mips.fsub.w
llvm.mips.fsueq.d
llvm.mips.fsueq.w
llvm.mips.fsule.d
llvm.mips.fsule.w
llvm.mips.fsult.d
llvm.mips.fsult.w
llvm.mips.fsun.d
llvm.mips.fsun.w
llvm.mips.fsune.d
llvm.mips.fsune.w
llvm.mips.ftint.s.d
llvm.mips.ftint.s.w
llvm.mips.ftint.u.d
llvm.mips.ftint.u.w
llvm.mips.ftq.h
llvm.mips.ftq.w
llvm.mips.ftrunc.s.d
llvm.mips.ftrunc.s.w
llvm.mips.ftrunc.u.d
llvm.mips.ftrunc.u.w
llvm.mips.hadd.s.d
llvm.mips.hadd.s.h
llvm.mips.hadd.s.w
llvm.mips.hadd.u.d
llvm.mips.hadd.u.h
llvm.mips.hadd.u.w
llvm.mips.hsub.s.d
llvm.mips.hsub.s.h
llvm.mips.hsub.s.w
llvm.mips.hsub.u.d
llvm.mips.hsub.u.h
llvm.mips.hsub.u.w
llvm.mips.ilvev.b
llvm.mips.ilvev.d
llvm.mips.ilvev.h
llvm.mips.ilvev.w
llvm.mips.ilvl.b
llvm.mips.ilvl.d
llvm.mips.ilvl.h
llvm.mips.ilvl.w
llvm.mips.ilvod.b
llvm.mips.ilvod.d
llvm.mips.ilvod.h
llvm.mips.ilvod.w
llvm.mips.ilvr.b
llvm.mips.ilvr.d
llvm.mips.ilvr.h
llvm.mips.ilvr.w
llvm.mips.insert.b
llvm.mips.insert.d
llvm.mips.insert.h
llvm.mips.insert.w
llvm.mips.insv
llvm.mips.insve.b
llvm.mips.insve.d
llvm.mips.insve.h
llvm.mips.insve.w
llvm.mips.lbux
llvm.mips.ld.b
llvm.mips.ld.d
llvm.mips.ld.h
llvm.mips.ld.w
llvm.mips.ldi.b
llvm.mips.ldi.d
llvm.mips.ldi.h
llvm.mips.ldi.w
llvm.mips.lhx
llvm.mips.lsa
llvm.mips.lwx
llvm.mips.madd
llvm.mips.madd.q.h
llvm.mips.madd.q.w
llvm.mips.maddr.q.h
llvm.mips.maddr.q.w
llvm.mips.maddu
llvm.mips.maddv.b
llvm.mips.maddv.d
llvm.mips.maddv.h
llvm.mips.maddv.w
llvm.mips.maq.s.w.phl
llvm.mips.maq.s.w.phr
llvm.mips.maq.sa.w.phl
llvm.mips.maq.sa.w.phr
llvm.mips.max.a.b
llvm.mips.max.a.d
llvm.mips.max.a.h
llvm.mips.max.a.w
llvm.mips.max.s.b
llvm.mips.max.s.d
llvm.mips.max.s.h
llvm.mips.max.s.w
llvm.mips.max.u.b
llvm.mips.max.u.d
llvm.mips.max.u.h
llvm.mips.max.u.w
llvm.mips.maxi.s.b
llvm.mips.maxi.s.d
llvm.mips.maxi.s.h
llvm.mips.maxi.s.w
llvm.mips.maxi.u.b
llvm.mips.maxi.u.d
llvm.mips.maxi.u.h
llvm.mips.maxi.u.w
llvm.mips.min.a.b
llvm.mips.min.a.d
llvm.mips.min.a.h
llvm.mips.min.a.w
llvm.mips.min.s.b
llvm.mips.min.s.d
llvm.mips.min.s.h
llvm.mips.min.s.w
llvm.mips.min.u.b
llvm.mips.min.u.d
llvm.mips.min.u.h
llvm.mips.min.u.w
llvm.mips.mini.s.b
llvm.mips.mini.s.d
llvm.mips.mini.s.h
llvm.mips.mini.s.w
llvm.mips.mini.u.b
llvm.mips.mini.u.d
llvm.mips.mini.u.h
llvm.mips.mini.u.w
llvm.mips.mod.s.b
llvm.mips.mod.s.d
llvm.mips.mod.s.h
llvm.mips.mod.s.w
llvm.mips.mod.u.b
llvm.mips.mod.u.d
llvm.mips.mod.u.h
llvm.mips.mod.u.w
llvm.mips.modsub
llvm.mips.move.v
llvm.mips.msub
llvm.mips.msub.q.h
llvm.mips.msub.q.w
llvm.mips.msubr.q.h
llvm.mips.msubr.q.w
llvm.mips.msubu
llvm.mips.msubv.b
llvm.mips.msubv.d
llvm.mips.msubv.h
llvm.mips.msubv.w
llvm.mips.mthlip
llvm.mips.mul.ph
llvm.mips.mul.q.h
llvm.mips.mul.q.w
llvm.mips.mul.s.ph
llvm.mips.muleq.s.w.phl
llvm.mips.muleq.s.w.phr
llvm.mips.muleu.s.ph.qbl
llvm.mips.muleu.s.ph.qbr
llvm.mips.mulq.rs.ph
llvm.mips.mulq.rs.w
llvm.mips.mulq.s.ph
llvm.mips.mulq.s.w
llvm.mips.mulr.q.h
llvm.mips.mulr.q.w
llvm.mips.mulsa.w.ph
llvm.mips.mulsaq.s.w.ph
llvm.mips.mult
llvm.mips.multu
llvm.mips.mulv.b
llvm.mips.mulv.d
llvm.mips.mulv.h
llvm.mips.mulv.w
llvm.mips.nloc.b
llvm.mips.nloc.d
llvm.mips.nloc.h
llvm.mips.nloc.w
llvm.mips.nlzc.b
llvm.mips.nlzc.d
llvm.mips.nlzc.h
llvm.mips.nlzc.w
llvm.mips.nor.v
llvm.mips.nori.b
llvm.mips.or.v
llvm.mips.ori.b
llvm.mips.packrl.ph
llvm.mips.pckev.b
llvm.mips.pckev.d
llvm.mips.pckev.h
llvm.mips.pckev.w
llvm.mips.pckod.b
llvm.mips.pckod.d
llvm.mips.pckod.h
llvm.mips.pckod.w
llvm.mips.pcnt.b
llvm.mips.pcnt.d
llvm.mips.pcnt.h
llvm.mips.pcnt.w
llvm.mips.pick.ph
llvm.mips.pick.qb
llvm.mips.preceq.w.phl
llvm.mips.preceq.w.phr
llvm.mips.precequ.ph.qbl
llvm.mips.precequ.ph.qbla
llvm.mips.precequ.ph.qbr
llvm.mips.precequ.ph.qbra
llvm.mips.preceu.ph.qbl
llvm.mips.preceu.ph.qbla
llvm.mips.preceu.ph.qbr
llvm.mips.preceu.ph.qbra
llvm.mips.precr.qb.ph
llvm.mips.precr.sra.ph.w
llvm.mips.precr.sra.r.ph.w
llvm.mips.precrq.ph.w
llvm.mips.precrq.qb.ph
llvm.mips.precrq.rs.ph.w
llvm.mips.precrqu.s.qb.ph
llvm.mips.prepend
llvm.mips.raddu.w.qb
llvm.mips.rddsp
llvm.mips.repl.ph
llvm.mips.repl.qb
llvm.mips.sat.s.b
llvm.mips.sat.s.d
llvm.mips.sat.s.h
llvm.mips.sat.s.w
llvm.mips.sat.u.b
llvm.mips.sat.u.d
llvm.mips.sat.u.h
llvm.mips.sat.u.w
llvm.mips.shf.b
llvm.mips.shf.h
llvm.mips.shf.w
llvm.mips.shilo
llvm.mips.shll.ph
llvm.mips.shll.qb
llvm.mips.shll.s.ph
llvm.mips.shll.s.w
llvm.mips.shra.ph
llvm.mips.shra.qb
llvm.mips.shra.r.ph
llvm.mips.shra.r.qb
llvm.mips.shra.r.w
llvm.mips.shrl.ph
llvm.mips.shrl.qb
llvm.mips.sld.b
llvm.mips.sld.d
llvm.mips.sld.h
llvm.mips.sld.w
llvm.mips.sldi.b
llvm.mips.sldi.d
llvm.mips.sldi.h
llvm.mips.sldi.w
llvm.mips.sll.b
llvm.mips.sll.d
llvm.mips.sll.h
llvm.mips.sll.w
llvm.mips.slli.b
llvm.mips.slli.d
llvm.mips.slli.h
llvm.mips.slli.w
llvm.mips.splat.b
llvm.mips.splat.d
llvm.mips.splat.h
llvm.mips.splat.w
llvm.mips.splati.b
llvm.mips.splati.d
llvm.mips.splati.h
llvm.mips.splati.w
llvm.mips.sra.b
llvm.mips.sra.d
llvm.mips.sra.h
llvm.mips.sra.w
llvm.mips.srai.b
llvm.mips.srai.d
llvm.mips.srai.h
llvm.mips.srai.w
llvm.mips.srar.b
llvm.mips.srar.d
llvm.mips.srar.h
llvm.mips.srar.w
llvm.mips.srari.b
llvm.mips.srari.d
llvm.mips.srari.h
llvm.mips.srari.w
llvm.mips.srl.b
llvm.mips.srl.d
llvm.mips.srl.h
llvm.mips.srl.w
llvm.mips.srli.b
llvm.mips.srli.d
llvm.mips.srli.h
llvm.mips.srli.w
llvm.mips.srlr.b
llvm.mips.srlr.d
llvm.mips.srlr.h
llvm.mips.srlr.w
llvm.mips.srlri.b
llvm.mips.srlri.d
llvm.mips.srlri.h
llvm.mips.srlri.w
llvm.mips.st.b
llvm.mips.st.d
llvm.mips.st.h
llvm.mips.st.w
llvm.mips.subq.ph
llvm.mips.subq.s.ph
llvm.mips.subq.s.w
llvm.mips.subqh.ph
llvm.mips.subqh.r.ph
llvm.mips.subqh.r.w
llvm.mips.subqh.w
llvm.mips.subs.s.b
llvm.mips.subs.s.d
llvm.mips.subs.s.h
llvm.mips.subs.s.w
llvm.mips.subs.u.b
llvm.mips.subs.u.d
llvm.mips.subs.u.h
llvm.mips.subs.u.w
llvm.mips.subsus.u.b
llvm.mips.subsus.u.d
llvm.mips.subsus.u.h
llvm.mips.subsus.u.w
llvm.mips.subsuu.s.b
llvm.mips.subsuu.s.d
llvm.mips.subsuu.s.h
llvm.mips.subsuu.s.w
llvm.mips.subu.ph
llvm.mips.subu.qb
llvm.mips.subu.s.ph
llvm.mips.subu.s.qb
llvm.mips.subuh.qb
llvm.mips.subuh.r.qb
llvm.mips.subv.b
llvm.mips.subv.d
llvm.mips.subv.h
llvm.mips.subv.w
llvm.mips.subvi.b
llvm.mips.subvi.d
llvm.mips.subvi.h
llvm.mips.subvi.w
llvm.mips.vshf.b
llvm.mips.vshf.d
llvm.mips.vshf.h
llvm.mips.vshf.w
llvm.mips.wrdsp
llvm.mips.xor.v
llvm.mips.xori.b
llvm.nvvm.add.rm.d
llvm.nvvm.add.rm.f
llvm.nvvm.add.rm.ftz.f
llvm.nvvm.add.rn.d
llvm.nvvm.add.rn.f
llvm.nvvm.add.rn.ftz.f
llvm.nvvm.add.rp.d
llvm.nvvm.add.rp.f
llvm.nvvm.add.rp.ftz.f
llvm.nvvm.add.rz.d
llvm.nvvm.add.rz.f
llvm.nvvm.add.rz.ftz.f
llvm.nvvm.atomic.add.gen.f.cta
llvm.nvvm.atomic.add.gen.f.sys
llvm.nvvm.atomic.add.gen.i.cta
llvm.nvvm.atomic.add.gen.i.sys
llvm.nvvm.atomic.and.gen.i.cta
llvm.nvvm.atomic.and.gen.i.sys
llvm.nvvm.atomic.cas.gen.i.cta
llvm.nvvm.atomic.cas.gen.i.sys
llvm.nvvm.atomic.dec.gen.i.cta
llvm.nvvm.atomic.dec.gen.i.sys
llvm.nvvm.atomic.exch.gen.i.cta
llvm.nvvm.atomic.exch.gen.i.sys
llvm.nvvm.atomic.inc.gen.i.cta
llvm.nvvm.atomic.inc.gen.i.sys
llvm.nvvm.atomic.load.add.f32
llvm.nvvm.atomic.load.add.f64
llvm.nvvm.atomic.load.dec.32
llvm.nvvm.atomic.load.inc.32
llvm.nvvm.atomic.max.gen.i.cta
llvm.nvvm.atomic.max.gen.i.sys
llvm.nvvm.atomic.min.gen.i.cta
llvm.nvvm.atomic.min.gen.i.sys
llvm.nvvm.atomic.or.gen.i.cta
llvm.nvvm.atomic.or.gen.i.sys
llvm.nvvm.atomic.xor.gen.i.cta
llvm.nvvm.atomic.xor.gen.i.sys
llvm.nvvm.bar.sync
llvm.nvvm.bar.warp.sync
llvm.nvvm.barrier
llvm.nvvm.barrier.n
llvm.nvvm.barrier.sync
llvm.nvvm.barrier.sync.cnt
llvm.nvvm.barrier0
llvm.nvvm.barrier0.and
llvm.nvvm.barrier0.or
llvm.nvvm.barrier0.popc
llvm.nvvm.bitcast.d2ll
llvm.nvvm.bitcast.f2i
llvm.nvvm.bitcast.i2f
llvm.nvvm.bitcast.ll2d
llvm.nvvm.ceil.d
llvm.nvvm.ceil.f
llvm.nvvm.ceil.ftz.f
llvm.nvvm.compiler.error
llvm.nvvm.compiler.warn
llvm.nvvm.cos.approx.f
llvm.nvvm.cos.approx.ftz.f
llvm.nvvm.d2f.rm
llvm.nvvm.d2f.rm.ftz
llvm.nvvm.d2f.rn
llvm.nvvm.d2f.rn.ftz
llvm.nvvm.d2f.rp
llvm.nvvm.d2f.rp.ftz
llvm.nvvm.d2f.rz
llvm.nvvm.d2f.rz.ftz
llvm.nvvm.d2i.hi
llvm.nvvm.d2i.lo
llvm.nvvm.d2i.rm
llvm.nvvm.d2i.rn
llvm.nvvm.d2i.rp
llvm.nvvm.d2i.rz
llvm.nvvm.d2ll.rm
llvm.nvvm.d2ll.rn
llvm.nvvm.d2ll.rp
llvm.nvvm.d2ll.rz
llvm.nvvm.d2ui.rm
llvm.nvvm.d2ui.rn
llvm.nvvm.d2ui.rp
llvm.nvvm.d2ui.rz
llvm.nvvm.d2ull.rm
llvm.nvvm.d2ull.rn
llvm.nvvm.d2ull.rp
llvm.nvvm.d2ull.rz
llvm.nvvm.div.approx.f
llvm.nvvm.div.approx.ftz.f
llvm.nvvm.div.rm.d
llvm.nvvm.div.rm.f
llvm.nvvm.div.rm.ftz.f
llvm.nvvm.div.rn.d
llvm.nvvm.div.rn.f
llvm.nvvm.div.rn.ftz.f
llvm.nvvm.div.rp.d
llvm.nvvm.div.rp.f
llvm.nvvm.div.rp.ftz.f
llvm.nvvm.div.rz.d
llvm.nvvm.div.rz.f
llvm.nvvm.div.rz.ftz.f
llvm.nvvm.ex2.approx.d
llvm.nvvm.ex2.approx.f
llvm.nvvm.ex2.approx.ftz.f
llvm.nvvm.f2h.rn
llvm.nvvm.f2h.rn.ftz
llvm.nvvm.f2i.rm
llvm.nvvm.f2i.rm.ftz
llvm.nvvm.f2i.rn
llvm.nvvm.f2i.rn.ftz
llvm.nvvm.f2i.rp
llvm.nvvm.f2i.rp.ftz
llvm.nvvm.f2i.rz
llvm.nvvm.f2i.rz.ftz
llvm.nvvm.f2ll.rm
llvm.nvvm.f2ll.rm.ftz
llvm.nvvm.f2ll.rn
llvm.nvvm.f2ll.rn.ftz
llvm.nvvm.f2ll.rp
llvm.nvvm.f2ll.rp.ftz
llvm.nvvm.f2ll.rz
llvm.nvvm.f2ll.rz.ftz
llvm.nvvm.f2ui.rm
llvm.nvvm.f2ui.rm.ftz
llvm.nvvm.f2ui.rn
llvm.nvvm.f2ui.rn.ftz
llvm.nvvm.f2ui.rp
llvm.nvvm.f2ui.rp.ftz
llvm.nvvm.f2ui.rz
llvm.nvvm.f2ui.rz.ftz
llvm.nvvm.f2ull.rm
llvm.nvvm.f2ull.rm.ftz
llvm.nvvm.f2ull.rn
llvm.nvvm.f2ull.rn.ftz
llvm.nvvm.f2ull.rp
llvm.nvvm.f2ull.rp.ftz
llvm.nvvm.f2ull.rz
llvm.nvvm.f2ull.rz.ftz
llvm.nvvm.fabs.d
llvm.nvvm.fabs.f
llvm.nvvm.fabs.ftz.f
llvm.nvvm.floor.d
llvm.nvvm.floor.f
llvm.nvvm.floor.ftz.f
llvm.nvvm.fma.rm.d
llvm.nvvm.fma.rm.f
llvm.nvvm.fma.rm.ftz.f
llvm.nvvm.fma.rn.d
llvm.nvvm.fma.rn.f
llvm.nvvm.fma.rn.ftz.f
llvm.nvvm.fma.rp.d
llvm.nvvm.fma.rp.f
llvm.nvvm.fma.rp.ftz.f
llvm.nvvm.fma.rz.d
llvm.nvvm.fma.rz.f
llvm.nvvm.fma.rz.ftz.f
llvm.nvvm.fmax.d
llvm.nvvm.fmax.f
llvm.nvvm.fmax.ftz.f
llvm.nvvm.fmin.d
llvm.nvvm.fmin.f
llvm.nvvm.fmin.ftz.f
llvm.nvvm.fns
llvm.nvvm.i2d.rm
llvm.nvvm.i2d.rn
llvm.nvvm.i2d.rp
llvm.nvvm.i2d.rz
llvm.nvvm.i2f.rm
llvm.nvvm.i2f.rn
llvm.nvvm.i2f.rp
llvm.nvvm.i2f.rz
llvm.nvvm.isspacep.const
llvm.nvvm.isspacep.global
llvm.nvvm.isspacep.local
llvm.nvvm.isspacep.shared
llvm.nvvm.istypep.sampler
llvm.nvvm.istypep.surface
llvm.nvvm.istypep.texture
llvm.nvvm.ldg.global.f
llvm.nvvm.ldg.global.i
llvm.nvvm.ldg.global.p
llvm.nvvm.ldu.global.f
llvm.nvvm.ldu.global.i
llvm.nvvm.ldu.global.p
llvm.nvvm.lg2.approx.d
llvm.nvvm.lg2.approx.f
llvm.nvvm.lg2.approx.ftz.f
llvm.nvvm.ll2d.rm
llvm.nvvm.ll2d.rn
llvm.nvvm.ll2d.rp
llvm.nvvm.ll2d.rz
llvm.nvvm.ll2f.rm
llvm.nvvm.ll2f.rn
llvm.nvvm.ll2f.rp
llvm.nvvm.ll2f.rz
llvm.nvvm.lohi.i2d
llvm.nvvm.match.all.sync.i32p
llvm.nvvm.match.all.sync.i64p
llvm.nvvm.match.any.sync.i32
llvm.nvvm.match.any.sync.i64
llvm.nvvm.membar.cta
llvm.nvvm.membar.gl
llvm.nvvm.membar.sys
llvm.nvvm.move.double
llvm.nvvm.move.float
llvm.nvvm.move.i16
llvm.nvvm.move.i32
llvm.nvvm.move.i64
llvm.nvvm.move.ptr
llvm.nvvm.mul.rm.d
llvm.nvvm.mul.rm.f
llvm.nvvm.mul.rm.ftz.f
llvm.nvvm.mul.rn.d
llvm.nvvm.mul.rn.f
llvm.nvvm.mul.rn.ftz.f
llvm.nvvm.mul.rp.d
llvm.nvvm.mul.rp.f
llvm.nvvm.mul.rp.ftz.f
llvm.nvvm.mul.rz.d
llvm.nvvm.mul.rz.f
llvm.nvvm.mul.rz.ftz.f
llvm.nvvm.mul24.i
llvm.nvvm.mul24.ui
llvm.nvvm.mulhi.i
llvm.nvvm.mulhi.ll
llvm.nvvm.mulhi.ui
llvm.nvvm.mulhi.ull
llvm.nvvm.prmt
llvm.nvvm.ptr.constant.to.gen
llvm.nvvm.ptr.gen.to.constant
llvm.nvvm.ptr.gen.to.global
llvm.nvvm.ptr.gen.to.local
llvm.nvvm.ptr.gen.to.param
llvm.nvvm.ptr.gen.to.shared
llvm.nvvm.ptr.global.to.gen
llvm.nvvm.ptr.local.to.gen
llvm.nvvm.ptr.shared.to.gen
llvm.nvvm.rcp.approx.ftz.d
llvm.nvvm.rcp.rm.d
llvm.nvvm.rcp.rm.f
llvm.nvvm.rcp.rm.ftz.f
llvm.nvvm.rcp.rn.d
llvm.nvvm.rcp.rn.f
llvm.nvvm.rcp.rn.ftz.f
llvm.nvvm.rcp.rp.d
llvm.nvvm.rcp.rp.f
llvm.nvvm.rcp.rp.ftz.f
llvm.nvvm.rcp.rz.d
llvm.nvvm.rcp.rz.f
llvm.nvvm.rcp.rz.ftz.f
llvm.nvvm.read.ptx.sreg.clock
llvm.nvvm.read.ptx.sreg.clock64
llvm.nvvm.read.ptx.sreg.ctaid.w
llvm.nvvm.read.ptx.sreg.ctaid.x
llvm.nvvm.read.ptx.sreg.ctaid.y
llvm.nvvm.read.ptx.sreg.ctaid.z
llvm.nvvm.read.ptx.sreg.envreg0
llvm.nvvm.read.ptx.sreg.envreg1
llvm.nvvm.read.ptx.sreg.envreg10
llvm.nvvm.read.ptx.sreg.envreg11
llvm.nvvm.read.ptx.sreg.envreg12
llvm.nvvm.read.ptx.sreg.envreg13
llvm.nvvm.read.ptx.sreg.envreg14
llvm.nvvm.read.ptx.sreg.envreg15
llvm.nvvm.read.ptx.sreg.envreg16
llvm.nvvm.read.ptx.sreg.envreg17
llvm.nvvm.read.ptx.sreg.envreg18
llvm.nvvm.read.ptx.sreg.envreg19
llvm.nvvm.read.ptx.sreg.envreg2
llvm.nvvm.read.ptx.sreg.envreg20
llvm.nvvm.read.ptx.sreg.envreg21
llvm.nvvm.read.ptx.sreg.envreg22
llvm.nvvm.read.ptx.sreg.envreg23
llvm.nvvm.read.ptx.sreg.envreg24
llvm.nvvm.read.ptx.sreg.envreg25
llvm.nvvm.read.ptx.sreg.envreg26
llvm.nvvm.read.ptx.sreg.envreg27
llvm.nvvm.read.ptx.sreg.envreg28
llvm.nvvm.read.ptx.sreg.envreg29
llvm.nvvm.read.ptx.sreg.envreg3
llvm.nvvm.read.ptx.sreg.envreg30
llvm.nvvm.read.ptx.sreg.envreg31
llvm.nvvm.read.ptx.sreg.envreg4
llvm.nvvm.read.ptx.sreg.envreg5
llvm.nvvm.read.ptx.sreg.envreg6
llvm.nvvm.read.ptx.sreg.envreg7
llvm.nvvm.read.ptx.sreg.envreg8
llvm.nvvm.read.ptx.sreg.envreg9
llvm.nvvm.read.ptx.sreg.gridid
llvm.nvvm.read.ptx.sreg.laneid
llvm.nvvm.read.ptx.sreg.lanemask.eq
llvm.nvvm.read.ptx.sreg.lanemask.ge
llvm.nvvm.read.ptx.sreg.lanemask.gt
llvm.nvvm.read.ptx.sreg.lanemask.le
llvm.nvvm.read.ptx.sreg.lanemask.lt
llvm.nvvm.read.ptx.sreg.nctaid.w
llvm.nvvm.read.ptx.sreg.nctaid.x
llvm.nvvm.read.ptx.sreg.nctaid.y
llvm.nvvm.read.ptx.sreg.nctaid.z
llvm.nvvm.read.ptx.sreg.nsmid
llvm.nvvm.read.ptx.sreg.ntid.w
llvm.nvvm.read.ptx.sreg.ntid.x
llvm.nvvm.read.ptx.sreg.ntid.y
llvm.nvvm.read.ptx.sreg.ntid.z
llvm.nvvm.read.ptx.sreg.nwarpid
llvm.nvvm.read.ptx.sreg.pm0
llvm.nvvm.read.ptx.sreg.pm1
llvm.nvvm.read.ptx.sreg.pm2
llvm.nvvm.read.ptx.sreg.pm3
llvm.nvvm.read.ptx.sreg.smid
llvm.nvvm.read.ptx.sreg.tid.w
llvm.nvvm.read.ptx.sreg.tid.x
llvm.nvvm.read.ptx.sreg.tid.y
llvm.nvvm.read.ptx.sreg.tid.z
llvm.nvvm.read.ptx.sreg.warpid
llvm.nvvm.read.ptx.sreg.warpsize
llvm.nvvm.reflect
llvm.nvvm.rotate.b32
llvm.nvvm.rotate.b64
llvm.nvvm.rotate.right.b64
llvm.nvvm.round.d
llvm.nvvm.round.f
llvm.nvvm.round.ftz.f
llvm.nvvm.rsqrt.approx.d
llvm.nvvm.rsqrt.approx.f
llvm.nvvm.rsqrt.approx.ftz.f
llvm.nvvm.sad.i
llvm.nvvm.sad.ui
llvm.nvvm.saturate.d
llvm.nvvm.saturate.f
llvm.nvvm.saturate.ftz.f
llvm.nvvm.shfl.bfly.f32
llvm.nvvm.shfl.bfly.i32
llvm.nvvm.shfl.down.f32
llvm.nvvm.shfl.down.i32
llvm.nvvm.shfl.idx.f32
llvm.nvvm.shfl.idx.i32
llvm.nvvm.shfl.sync.bfly.f32
llvm.nvvm.shfl.sync.bfly.i32
llvm.nvvm.shfl.sync.down.f32
llvm.nvvm.shfl.sync.down.i32
llvm.nvvm.shfl.sync.idx.f32
llvm.nvvm.shfl.sync.idx.i32
llvm.nvvm.shfl.sync.up.f32
llvm.nvvm.shfl.sync.up.i32
llvm.nvvm.shfl.up.f32
llvm.nvvm.shfl.up.i32
llvm.nvvm.sin.approx.f
llvm.nvvm.sin.approx.ftz.f
llvm.nvvm.sqrt.approx.f
llvm.nvvm.sqrt.approx.ftz.f
llvm.nvvm.sqrt.f
llvm.nvvm.sqrt.rm.d
llvm.nvvm.sqrt.rm.f
llvm.nvvm.sqrt.rm.ftz.f
llvm.nvvm.sqrt.rn.d
llvm.nvvm.sqrt.rn.f
llvm.nvvm.sqrt.rn.ftz.f
llvm.nvvm.sqrt.rp.d
llvm.nvvm.sqrt.rp.f
llvm.nvvm.sqrt.rp.ftz.f
llvm.nvvm.sqrt.rz.d
llvm.nvvm.sqrt.rz.f
llvm.nvvm.sqrt.rz.ftz.f
llvm.nvvm.suld.1d.array.i16.clamp
llvm.nvvm.suld.1d.array.i16.trap
llvm.nvvm.suld.1d.array.i16.zero
llvm.nvvm.suld.1d.array.i32.clamp
llvm.nvvm.suld.1d.array.i32.trap
llvm.nvvm.suld.1d.array.i32.zero
llvm.nvvm.suld.1d.array.i64.clamp
llvm.nvvm.suld.1d.array.i64.trap
llvm.nvvm.suld.1d.array.i64.zero
llvm.nvvm.suld.1d.array.i8.clamp
llvm.nvvm.suld.1d.array.i8.trap
llvm.nvvm.suld.1d.array.i8.zero
llvm.nvvm.suld.1d.array.v2i16.clamp
llvm.nvvm.suld.1d.array.v2i16.trap
llvm.nvvm.suld.1d.array.v2i16.zero
llvm.nvvm.suld.1d.array.v2i32.clamp
llvm.nvvm.suld.1d.array.v2i32.trap
llvm.nvvm.suld.1d.array.v2i32.zero
llvm.nvvm.suld.1d.array.v2i64.clamp
llvm.nvvm.suld.1d.array.v2i64.trap
llvm.nvvm.suld.1d.array.v2i64.zero
llvm.nvvm.suld.1d.array.v2i8.clamp
llvm.nvvm.suld.1d.array.v2i8.trap
llvm.nvvm.suld.1d.array.v2i8.zero
llvm.nvvm.suld.1d.array.v4i16.clamp
llvm.nvvm.suld.1d.array.v4i16.trap
llvm.nvvm.suld.1d.array.v4i16.zero
llvm.nvvm.suld.1d.array.v4i32.clamp
llvm.nvvm.suld.1d.array.v4i32.trap
llvm.nvvm.suld.1d.array.v4i32.zero
llvm.nvvm.suld.1d.array.v4i8.clamp
llvm.nvvm.suld.1d.array.v4i8.trap
llvm.nvvm.suld.1d.array.v4i8.zero
llvm.nvvm.suld.1d.i16.clamp
llvm.nvvm.suld.1d.i16.trap
llvm.nvvm.suld.1d.i16.zero
llvm.nvvm.suld.1d.i32.clamp
llvm.nvvm.suld.1d.i32.trap
llvm.nvvm.suld.1d.i32.zero
llvm.nvvm.suld.1d.i64.clamp
llvm.nvvm.suld.1d.i64.trap
llvm.nvvm.suld.1d.i64.zero
llvm.nvvm.suld.1d.i8.clamp
llvm.nvvm.suld.1d.i8.trap
llvm.nvvm.suld.1d.i8.zero
llvm.nvvm.suld.1d.v2i16.clamp
llvm.nvvm.suld.1d.v2i16.trap
llvm.nvvm.suld.1d.v2i16.zero
llvm.nvvm.suld.1d.v2i32.clamp
llvm.nvvm.suld.1d.v2i32.trap
llvm.nvvm.suld.1d.v2i32.zero
llvm.nvvm.suld.1d.v2i64.clamp
llvm.nvvm.suld.1d.v2i64.trap
llvm.nvvm.suld.1d.v2i64.zero
llvm.nvvm.suld.1d.v2i8.clamp
llvm.nvvm.suld.1d.v2i8.trap
llvm.nvvm.suld.1d.v2i8.zero
llvm.nvvm.suld.1d.v4i16.clamp
llvm.nvvm.suld.1d.v4i16.trap
llvm.nvvm.suld.1d.v4i16.zero
llvm.nvvm.suld.1d.v4i32.clamp
llvm.nvvm.suld.1d.v4i32.trap
llvm.nvvm.suld.1d.v4i32.zero
llvm.nvvm.suld.1d.v4i8.clamp
llvm.nvvm.suld.1d.v4i8.trap
llvm.nvvm.suld.1d.v4i8.zero
llvm.nvvm.suld.2d.array.i16.clamp
llvm.nvvm.suld.2d.array.i16.trap
llvm.nvvm.suld.2d.array.i16.zero
llvm.nvvm.suld.2d.array.i32.clamp
llvm.nvvm.suld.2d.array.i32.trap
llvm.nvvm.suld.2d.array.i32.zero
llvm.nvvm.suld.2d.array.i64.clamp
llvm.nvvm.suld.2d.array.i64.trap
llvm.nvvm.suld.2d.array.i64.zero
llvm.nvvm.suld.2d.array.i8.clamp
llvm.nvvm.suld.2d.array.i8.trap
llvm.nvvm.suld.2d.array.i8.zero
llvm.nvvm.suld.2d.array.v2i16.clamp
llvm.nvvm.suld.2d.array.v2i16.trap
llvm.nvvm.suld.2d.array.v2i16.zero
llvm.nvvm.suld.2d.array.v2i32.clamp
llvm.nvvm.suld.2d.array.v2i32.trap
llvm.nvvm.suld.2d.array.v2i32.zero
llvm.nvvm.suld.2d.array.v2i64.clamp
llvm.nvvm.suld.2d.array.v2i64.trap
llvm.nvvm.suld.2d.array.v2i64.zero
llvm.nvvm.suld.2d.array.v2i8.clamp
llvm.nvvm.suld.2d.array.v2i8.trap
llvm.nvvm.suld.2d.array.v2i8.zero
llvm.nvvm.suld.2d.array.v4i16.clamp
llvm.nvvm.suld.2d.array.v4i16.trap
llvm.nvvm.suld.2d.array.v4i16.zero
llvm.nvvm.suld.2d.array.v4i32.clamp
llvm.nvvm.suld.2d.array.v4i32.trap
llvm.nvvm.suld.2d.array.v4i32.zero
llvm.nvvm.suld.2d.array.v4i8.clamp
llvm.nvvm.suld.2d.array.v4i8.trap
llvm.nvvm.suld.2d.array.v4i8.zero
llvm.nvvm.suld.2d.i16.clamp
llvm.nvvm.suld.2d.i16.trap
llvm.nvvm.suld.2d.i16.zero
llvm.nvvm.suld.2d.i32.clamp
llvm.nvvm.suld.2d.i32.trap
llvm.nvvm.suld.2d.i32.zero
llvm.nvvm.suld.2d.i64.clamp
llvm.nvvm.suld.2d.i64.trap
llvm.nvvm.suld.2d.i64.zero
llvm.nvvm.suld.2d.i8.clamp
llvm.nvvm.suld.2d.i8.trap
llvm.nvvm.suld.2d.i8.zero
llvm.nvvm.suld.2d.v2i16.clamp
llvm.nvvm.suld.2d.v2i16.trap
llvm.nvvm.suld.2d.v2i16.zero
llvm.nvvm.suld.2d.v2i32.clamp
llvm.nvvm.suld.2d.v2i32.trap
llvm.nvvm.suld.2d.v2i32.zero
llvm.nvvm.suld.2d.v2i64.clamp
llvm.nvvm.suld.2d.v2i64.trap
llvm.nvvm.suld.2d.v2i64.zero
llvm.nvvm.suld.2d.v2i8.clamp
llvm.nvvm.suld.2d.v2i8.trap
llvm.nvvm.suld.2d.v2i8.zero
llvm.nvvm.suld.2d.v4i16.clamp
llvm.nvvm.suld.2d.v4i16.trap
llvm.nvvm.suld.2d.v4i16.zero
llvm.nvvm.suld.2d.v4i32.clamp
llvm.nvvm.suld.2d.v4i32.trap
llvm.nvvm.suld.2d.v4i32.zero
llvm.nvvm.suld.2d.v4i8.clamp
llvm.nvvm.suld.2d.v4i8.trap
llvm.nvvm.suld.2d.v4i8.zero
llvm.nvvm.suld.3d.i16.clamp
llvm.nvvm.suld.3d.i16.trap
llvm.nvvm.suld.3d.i16.zero
llvm.nvvm.suld.3d.i32.clamp
llvm.nvvm.suld.3d.i32.trap
llvm.nvvm.suld.3d.i32.zero
llvm.nvvm.suld.3d.i64.clamp
llvm.nvvm.suld.3d.i64.trap
llvm.nvvm.suld.3d.i64.zero
llvm.nvvm.suld.3d.i8.clamp
llvm.nvvm.suld.3d.i8.trap
llvm.nvvm.suld.3d.i8.zero
llvm.nvvm.suld.3d.v2i16.clamp
llvm.nvvm.suld.3d.v2i16.trap
llvm.nvvm.suld.3d.v2i16.zero
llvm.nvvm.suld.3d.v2i32.clamp
llvm.nvvm.suld.3d.v2i32.trap
llvm.nvvm.suld.3d.v2i32.zero
llvm.nvvm.suld.3d.v2i64.clamp
llvm.nvvm.suld.3d.v2i64.trap
llvm.nvvm.suld.3d.v2i64.zero
llvm.nvvm.suld.3d.v2i8.clamp
llvm.nvvm.suld.3d.v2i8.trap
llvm.nvvm.suld.3d.v2i8.zero
llvm.nvvm.suld.3d.v4i16.clamp
llvm.nvvm.suld.3d.v4i16.trap
llvm.nvvm.suld.3d.v4i16.zero
llvm.nvvm.suld.3d.v4i32.clamp
llvm.nvvm.suld.3d.v4i32.trap
llvm.nvvm.suld.3d.v4i32.zero
llvm.nvvm.suld.3d.v4i8.clamp
llvm.nvvm.suld.3d.v4i8.trap
llvm.nvvm.suld.3d.v4i8.zero
llvm.nvvm.suq.array.size
llvm.nvvm.suq.channel.data.type
llvm.nvvm.suq.channel.order
llvm.nvvm.suq.depth
llvm.nvvm.suq.height
llvm.nvvm.suq.width
llvm.nvvm.sust.b.1d.array.i16.clamp
llvm.nvvm.sust.b.1d.array.i16.trap
llvm.nvvm.sust.b.1d.array.i16.zero
llvm.nvvm.sust.b.1d.array.i32.clamp
llvm.nvvm.sust.b.1d.array.i32.trap
llvm.nvvm.sust.b.1d.array.i32.zero
llvm.nvvm.sust.b.1d.array.i64.clamp
llvm.nvvm.sust.b.1d.array.i64.trap
llvm.nvvm.sust.b.1d.array.i64.zero
llvm.nvvm.sust.b.1d.array.i8.clamp
llvm.nvvm.sust.b.1d.array.i8.trap
llvm.nvvm.sust.b.1d.array.i8.zero
llvm.nvvm.sust.b.1d.array.v2i16.clamp
llvm.nvvm.sust.b.1d.array.v2i16.trap
llvm.nvvm.sust.b.1d.array.v2i16.zero
llvm.nvvm.sust.b.1d.array.v2i32.clamp
llvm.nvvm.sust.b.1d.array.v2i32.trap
llvm.nvvm.sust.b.1d.array.v2i32.zero
llvm.nvvm.sust.b.1d.array.v2i64.clamp
llvm.nvvm.sust.b.1d.array.v2i64.trap
llvm.nvvm.sust.b.1d.array.v2i64.zero
llvm.nvvm.sust.b.1d.array.v2i8.clamp
llvm.nvvm.sust.b.1d.array.v2i8.trap
llvm.nvvm.sust.b.1d.array.v2i8.zero
llvm.nvvm.sust.b.1d.array.v4i16.clamp
llvm.nvvm.sust.b.1d.array.v4i16.trap
llvm.nvvm.sust.b.1d.array.v4i16.zero
llvm.nvvm.sust.b.1d.array.v4i32.clamp
llvm.nvvm.sust.b.1d.array.v4i32.trap
llvm.nvvm.sust.b.1d.array.v4i32.zero
llvm.nvvm.sust.b.1d.array.v4i8.clamp
llvm.nvvm.sust.b.1d.array.v4i8.trap
llvm.nvvm.sust.b.1d.array.v4i8.zero
llvm.nvvm.sust.b.1d.i16.clamp
llvm.nvvm.sust.b.1d.i16.trap
llvm.nvvm.sust.b.1d.i16.zero
llvm.nvvm.sust.b.1d.i32.clamp
llvm.nvvm.sust.b.1d.i32.trap
llvm.nvvm.sust.b.1d.i32.zero
llvm.nvvm.sust.b.1d.i64.clamp
llvm.nvvm.sust.b.1d.i64.trap
llvm.nvvm.sust.b.1d.i64.zero
llvm.nvvm.sust.b.1d.i8.clamp
llvm.nvvm.sust.b.1d.i8.trap
llvm.nvvm.sust.b.1d.i8.zero
llvm.nvvm.sust.b.1d.v2i16.clamp
llvm.nvvm.sust.b.1d.v2i16.trap
llvm.nvvm.sust.b.1d.v2i16.zero
llvm.nvvm.sust.b.1d.v2i32.clamp
llvm.nvvm.sust.b.1d.v2i32.trap
llvm.nvvm.sust.b.1d.v2i32.zero
llvm.nvvm.sust.b.1d.v2i64.clamp
llvm.nvvm.sust.b.1d.v2i64.trap
llvm.nvvm.sust.b.1d.v2i64.zero
llvm.nvvm.sust.b.1d.v2i8.clamp
llvm.nvvm.sust.b.1d.v2i8.trap
llvm.nvvm.sust.b.1d.v2i8.zero
llvm.nvvm.sust.b.1d.v4i16.clamp
llvm.nvvm.sust.b.1d.v4i16.trap
llvm.nvvm.sust.b.1d.v4i16.zero
llvm.nvvm.sust.b.1d.v4i32.clamp
llvm.nvvm.sust.b.1d.v4i32.trap
llvm.nvvm.sust.b.1d.v4i32.zero
llvm.nvvm.sust.b.1d.v4i8.clamp
llvm.nvvm.sust.b.1d.v4i8.trap
llvm.nvvm.sust.b.1d.v4i8.zero
llvm.nvvm.sust.b.2d.array.i16.clamp
llvm.nvvm.sust.b.2d.array.i16.trap
llvm.nvvm.sust.b.2d.array.i16.zero
llvm.nvvm.sust.b.2d.array.i32.clamp
llvm.nvvm.sust.b.2d.array.i32.trap
llvm.nvvm.sust.b.2d.array.i32.zero
llvm.nvvm.sust.b.2d.array.i64.clamp
llvm.nvvm.sust.b.2d.array.i64.trap
llvm.nvvm.sust.b.2d.array.i64.zero
llvm.nvvm.sust.b.2d.array.i8.clamp
llvm.nvvm.sust.b.2d.array.i8.trap
llvm.nvvm.sust.b.2d.array.i8.zero
llvm.nvvm.sust.b.2d.array.v2i16.clamp
llvm.nvvm.sust.b.2d.array.v2i16.trap
llvm.nvvm.sust.b.2d.array.v2i16.zero
llvm.nvvm.sust.b.2d.array.v2i32.clamp
llvm.nvvm.sust.b.2d.array.v2i32.trap
llvm.nvvm.sust.b.2d.array.v2i32.zero
llvm.nvvm.sust.b.2d.array.v2i64.clamp
llvm.nvvm.sust.b.2d.array.v2i64.trap
llvm.nvvm.sust.b.2d.array.v2i64.zero
llvm.nvvm.sust.b.2d.array.v2i8.clamp
llvm.nvvm.sust.b.2d.array.v2i8.trap
llvm.nvvm.sust.b.2d.array.v2i8.zero
llvm.nvvm.sust.b.2d.array.v4i16.clamp
llvm.nvvm.sust.b.2d.array.v4i16.trap
llvm.nvvm.sust.b.2d.array.v4i16.zero
llvm.nvvm.sust.b.2d.array.v4i32.clamp
llvm.nvvm.sust.b.2d.array.v4i32.trap
llvm.nvvm.sust.b.2d.array.v4i32.zero
llvm.nvvm.sust.b.2d.array.v4i8.clamp
llvm.nvvm.sust.b.2d.array.v4i8.trap
llvm.nvvm.sust.b.2d.array.v4i8.zero
llvm.nvvm.sust.b.2d.i16.clamp
llvm.nvvm.sust.b.2d.i16.trap
llvm.nvvm.sust.b.2d.i16.zero
llvm.nvvm.sust.b.2d.i32.clamp
llvm.nvvm.sust.b.2d.i32.trap
llvm.nvvm.sust.b.2d.i32.zero
llvm.nvvm.sust.b.2d.i64.clamp
llvm.nvvm.sust.b.2d.i64.trap
llvm.nvvm.sust.b.2d.i64.zero
llvm.nvvm.sust.b.2d.i8.clamp
llvm.nvvm.sust.b.2d.i8.trap
llvm.nvvm.sust.b.2d.i8.zero
llvm.nvvm.sust.b.2d.v2i16.clamp
llvm.nvvm.sust.b.2d.v2i16.trap
llvm.nvvm.sust.b.2d.v2i16.zero
llvm.nvvm.sust.b.2d.v2i32.clamp
llvm.nvvm.sust.b.2d.v2i32.trap
llvm.nvvm.sust.b.2d.v2i32.zero
llvm.nvvm.sust.b.2d.v2i64.clamp
llvm.nvvm.sust.b.2d.v2i64.trap
llvm.nvvm.sust.b.2d.v2i64.zero
llvm.nvvm.sust.b.2d.v2i8.clamp
llvm.nvvm.sust.b.2d.v2i8.trap
llvm.nvvm.sust.b.2d.v2i8.zero
llvm.nvvm.sust.b.2d.v4i16.clamp
llvm.nvvm.sust.b.2d.v4i16.trap
llvm.nvvm.sust.b.2d.v4i16.zero
llvm.nvvm.sust.b.2d.v4i32.clamp
llvm.nvvm.sust.b.2d.v4i32.trap
llvm.nvvm.sust.b.2d.v4i32.zero
llvm.nvvm.sust.b.2d.v4i8.clamp
llvm.nvvm.sust.b.2d.v4i8.trap
llvm.nvvm.sust.b.2d.v4i8.zero
llvm.nvvm.sust.b.3d.i16.clamp
llvm.nvvm.sust.b.3d.i16.trap
llvm.nvvm.sust.b.3d.i16.zero
llvm.nvvm.sust.b.3d.i32.clamp
llvm.nvvm.sust.b.3d.i32.trap
llvm.nvvm.sust.b.3d.i32.zero
llvm.nvvm.sust.b.3d.i64.clamp
llvm.nvvm.sust.b.3d.i64.trap
llvm.nvvm.sust.b.3d.i64.zero
llvm.nvvm.sust.b.3d.i8.clamp
llvm.nvvm.sust.b.3d.i8.trap
llvm.nvvm.sust.b.3d.i8.zero
llvm.nvvm.sust.b.3d.v2i16.clamp
llvm.nvvm.sust.b.3d.v2i16.trap
llvm.nvvm.sust.b.3d.v2i16.zero
llvm.nvvm.sust.b.3d.v2i32.clamp
llvm.nvvm.sust.b.3d.v2i32.trap
llvm.nvvm.sust.b.3d.v2i32.zero
llvm.nvvm.sust.b.3d.v2i64.clamp
llvm.nvvm.sust.b.3d.v2i64.trap
llvm.nvvm.sust.b.3d.v2i64.zero
llvm.nvvm.sust.b.3d.v2i8.clamp
llvm.nvvm.sust.b.3d.v2i8.trap
llvm.nvvm.sust.b.3d.v2i8.zero
llvm.nvvm.sust.b.3d.v4i16.clamp
llvm.nvvm.sust.b.3d.v4i16.trap
llvm.nvvm.sust.b.3d.v4i16.zero
llvm.nvvm.sust.b.3d.v4i32.clamp
llvm.nvvm.sust.b.3d.v4i32.trap
llvm.nvvm.sust.b.3d.v4i32.zero
llvm.nvvm.sust.b.3d.v4i8.clamp
llvm.nvvm.sust.b.3d.v4i8.trap
llvm.nvvm.sust.b.3d.v4i8.zero
llvm.nvvm.sust.p.1d.array.i16.trap
llvm.nvvm.sust.p.1d.array.i32.trap
llvm.nvvm.sust.p.1d.array.i8.trap
llvm.nvvm.sust.p.1d.array.v2i16.trap
llvm.nvvm.sust.p.1d.array.v2i32.trap
llvm.nvvm.sust.p.1d.array.v2i8.trap
llvm.nvvm.sust.p.1d.array.v4i16.trap
llvm.nvvm.sust.p.1d.array.v4i32.trap
llvm.nvvm.sust.p.1d.array.v4i8.trap
llvm.nvvm.sust.p.1d.i16.trap
llvm.nvvm.sust.p.1d.i32.trap
llvm.nvvm.sust.p.1d.i8.trap
llvm.nvvm.sust.p.1d.v2i16.trap
llvm.nvvm.sust.p.1d.v2i32.trap
llvm.nvvm.sust.p.1d.v2i8.trap
llvm.nvvm.sust.p.1d.v4i16.trap
llvm.nvvm.sust.p.1d.v4i32.trap
llvm.nvvm.sust.p.1d.v4i8.trap
llvm.nvvm.sust.p.2d.array.i16.trap
llvm.nvvm.sust.p.2d.array.i32.trap
llvm.nvvm.sust.p.2d.array.i8.trap
llvm.nvvm.sust.p.2d.array.v2i16.trap
llvm.nvvm.sust.p.2d.array.v2i32.trap
llvm.nvvm.sust.p.2d.array.v2i8.trap
llvm.nvvm.sust.p.2d.array.v4i16.trap
llvm.nvvm.sust.p.2d.array.v4i32.trap
llvm.nvvm.sust.p.2d.array.v4i8.trap
llvm.nvvm.sust.p.2d.i16.trap
llvm.nvvm.sust.p.2d.i32.trap
llvm.nvvm.sust.p.2d.i8.trap
llvm.nvvm.sust.p.2d.v2i16.trap
llvm.nvvm.sust.p.2d.v2i32.trap
llvm.nvvm.sust.p.2d.v2i8.trap
llvm.nvvm.sust.p.2d.v4i16.trap
llvm.nvvm.sust.p.2d.v4i32.trap
llvm.nvvm.sust.p.2d.v4i8.trap
llvm.nvvm.sust.p.3d.i16.trap
llvm.nvvm.sust.p.3d.i32.trap
llvm.nvvm.sust.p.3d.i8.trap
llvm.nvvm.sust.p.3d.v2i16.trap
llvm.nvvm.sust.p.3d.v2i32.trap
llvm.nvvm.sust.p.3d.v2i8.trap
llvm.nvvm.sust.p.3d.v4i16.trap
llvm.nvvm.sust.p.3d.v4i32.trap
llvm.nvvm.sust.p.3d.v4i8.trap
llvm.nvvm.swap.lo.hi.b64
llvm.nvvm.tex.1d.array.grad.v4f32.f32
llvm.nvvm.tex.1d.array.grad.v4s32.f32
llvm.nvvm.tex.1d.array.grad.v4u32.f32
llvm.nvvm.tex.1d.array.level.v4f32.f32
llvm.nvvm.tex.1d.array.level.v4s32.f32
llvm.nvvm.tex.1d.array.level.v4u32.f32
llvm.nvvm.tex.1d.array.v4f32.f32
llvm.nvvm.tex.1d.array.v4f32.s32
llvm.nvvm.tex.1d.array.v4s32.f32
llvm.nvvm.tex.1d.array.v4s32.s32
llvm.nvvm.tex.1d.array.v4u32.f32
llvm.nvvm.tex.1d.array.v4u32.s32
llvm.nvvm.tex.1d.grad.v4f32.f32
llvm.nvvm.tex.1d.grad.v4s32.f32
llvm.nvvm.tex.1d.grad.v4u32.f32
llvm.nvvm.tex.1d.level.v4f32.f32
llvm.nvvm.tex.1d.level.v4s32.f32
llvm.nvvm.tex.1d.level.v4u32.f32
llvm.nvvm.tex.1d.v4f32.f32
llvm.nvvm.tex.1d.v4f32.s32
llvm.nvvm.tex.1d.v4s32.f32
llvm.nvvm.tex.1d.v4s32.s32
llvm.nvvm.tex.1d.v4u32.f32
llvm.nvvm.tex.1d.v4u32.s32
llvm.nvvm.tex.2d.array.grad.v4f32.f32
llvm.nvvm.tex.2d.array.grad.v4s32.f32
llvm.nvvm.tex.2d.array.grad.v4u32.f32
llvm.nvvm.tex.2d.array.level.v4f32.f32
llvm.nvvm.tex.2d.array.level.v4s32.f32
llvm.nvvm.tex.2d.array.level.v4u32.f32
llvm.nvvm.tex.2d.array.v4f32.f32
llvm.nvvm.tex.2d.array.v4f32.s32
llvm.nvvm.tex.2d.array.v4s32.f32
llvm.nvvm.tex.2d.array.v4s32.s32
llvm.nvvm.tex.2d.array.v4u32.f32
llvm.nvvm.tex.2d.array.v4u32.s32
llvm.nvvm.tex.2d.grad.v4f32.f32
llvm.nvvm.tex.2d.grad.v4s32.f32
llvm.nvvm.tex.2d.grad.v4u32.f32
llvm.nvvm.tex.2d.level.v4f32.f32
llvm.nvvm.tex.2d.level.v4s32.f32
llvm.nvvm.tex.2d.level.v4u32.f32
llvm.nvvm.tex.2d.v4f32.f32
llvm.nvvm.tex.2d.v4f32.s32
llvm.nvvm.tex.2d.v4s32.f32
llvm.nvvm.tex.2d.v4s32.s32
llvm.nvvm.tex.2d.v4u32.f32
llvm.nvvm.tex.2d.v4u32.s32
llvm.nvvm.tex.3d.grad.v4f32.f32
llvm.nvvm.tex.3d.grad.v4s32.f32
llvm.nvvm.tex.3d.grad.v4u32.f32
llvm.nvvm.tex.3d.level.v4f32.f32
llvm.nvvm.tex.3d.level.v4s32.f32
llvm.nvvm.tex.3d.level.v4u32.f32
llvm.nvvm.tex.3d.v4f32.f32
llvm.nvvm.tex.3d.v4f32.s32
llvm.nvvm.tex.3d.v4s32.f32
llvm.nvvm.tex.3d.v4s32.s32
llvm.nvvm.tex.3d.v4u32.f32
llvm.nvvm.tex.3d.v4u32.s32
llvm.nvvm.tex.cube.array.level.v4f32.f32
llvm.nvvm.tex.cube.array.level.v4s32.f32
llvm.nvvm.tex.cube.array.level.v4u32.f32
llvm.nvvm.tex.cube.array.v4f32.f32
llvm.nvvm.tex.cube.array.v4s32.f32
llvm.nvvm.tex.cube.array.v4u32.f32
llvm.nvvm.tex.cube.level.v4f32.f32
llvm.nvvm.tex.cube.level.v4s32.f32
llvm.nvvm.tex.cube.level.v4u32.f32
llvm.nvvm.tex.cube.v4f32.f32
llvm.nvvm.tex.cube.v4s32.f32
llvm.nvvm.tex.cube.v4u32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4f32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4s32.f32
llvm.nvvm.tex.unified.1d.array.grad.v4u32.f32
llvm.nvvm.tex.unified.1d.array.level.v4f32.f32
llvm.nvvm.tex.unified.1d.array.level.v4s32.f32
llvm.nvvm.tex.unified.1d.array.level.v4u32.f32
llvm.nvvm.tex.unified.1d.array.v4f32.f32
llvm.nvvm.tex.unified.1d.array.v4f32.s32
llvm.nvvm.tex.unified.1d.array.v4s32.f32
llvm.nvvm.tex.unified.1d.array.v4s32.s32
llvm.nvvm.tex.unified.1d.array.v4u32.f32
llvm.nvvm.tex.unified.1d.array.v4u32.s32
llvm.nvvm.tex.unified.1d.grad.v4f32.f32
llvm.nvvm.tex.unified.1d.grad.v4s32.f32
llvm.nvvm.tex.unified.1d.grad.v4u32.f32
llvm.nvvm.tex.unified.1d.level.v4f32.f32
llvm.nvvm.tex.unified.1d.level.v4s32.f32
llvm.nvvm.tex.unified.1d.level.v4u32.f32
llvm.nvvm.tex.unified.1d.v4f32.f32
llvm.nvvm.tex.unified.1d.v4f32.s32
llvm.nvvm.tex.unified.1d.v4s32.f32
llvm.nvvm.tex.unified.1d.v4s32.s32
llvm.nvvm.tex.unified.1d.v4u32.f32
llvm.nvvm.tex.unified.1d.v4u32.s32
llvm.nvvm.tex.unified.2d.array.grad.v4f32.f32
llvm.nvvm.tex.unified.2d.array.grad.v4s32.f32
llvm.nvvm.tex.unified.2d.array.grad.v4u32.f32
llvm.nvvm.tex.unified.2d.array.level.v4f32.f32
llvm.nvvm.tex.unified.2d.array.level.v4s32.f32
llvm.nvvm.tex.unified.2d.array.level.v4u32.f32
llvm.nvvm.tex.unified.2d.array.v4f32.f32
llvm.nvvm.tex.unified.2d.array.v4f32.s32
llvm.nvvm.tex.unified.2d.array.v4s32.f32
llvm.nvvm.tex.unified.2d.array.v4s32.s32
llvm.nvvm.tex.unified.2d.array.v4u32.f32
llvm.nvvm.tex.unified.2d.array.v4u32.s32
llvm.nvvm.tex.unified.2d.grad.v4f32.f32
llvm.nvvm.tex.unified.2d.grad.v4s32.f32
llvm.nvvm.tex.unified.2d.grad.v4u32.f32
llvm.nvvm.tex.unified.2d.level.v4f32.f32
llvm.nvvm.tex.unified.2d.level.v4s32.f32
llvm.nvvm.tex.unified.2d.level.v4u32.f32
llvm.nvvm.tex.unified.2d.v4f32.f32
llvm.nvvm.tex.unified.2d.v4f32.s32
llvm.nvvm.tex.unified.2d.v4s32.f32
llvm.nvvm.tex.unified.2d.v4s32.s32
llvm.nvvm.tex.unified.2d.v4u32.f32
llvm.nvvm.tex.unified.2d.v4u32.s32
llvm.nvvm.tex.unified.3d.grad.v4f32.f32
llvm.nvvm.tex.unified.3d.grad.v4s32.f32
llvm.nvvm.tex.unified.3d.grad.v4u32.f32
llvm.nvvm.tex.unified.3d.level.v4f32.f32
llvm.nvvm.tex.unified.3d.level.v4s32.f32
llvm.nvvm.tex.unified.3d.level.v4u32.f32
llvm.nvvm.tex.unified.3d.v4f32.f32
llvm.nvvm.tex.unified.3d.v4f32.s32
llvm.nvvm.tex.unified.3d.v4s32.f32
llvm.nvvm.tex.unified.3d.v4s32.s32
llvm.nvvm.tex.unified.3d.v4u32.f32
llvm.nvvm.tex.unified.3d.v4u32.s32
llvm.nvvm.tex.unified.cube.array.level.v4f32.f32
llvm.nvvm.tex.unified.cube.array.level.v4s32.f32
llvm.nvvm.tex.unified.cube.array.level.v4u32.f32
llvm.nvvm.tex.unified.cube.array.v4f32.f32
llvm.nvvm.tex.unified.cube.array.v4s32.f32
llvm.nvvm.tex.unified.cube.array.v4u32.f32
llvm.nvvm.tex.unified.cube.level.v4f32.f32
llvm.nvvm.tex.unified.cube.level.v4s32.f32
llvm.nvvm.tex.unified.cube.level.v4u32.f32
llvm.nvvm.tex.unified.cube.v4f32.f32
llvm.nvvm.tex.unified.cube.v4s32.f32
llvm.nvvm.tex.unified.cube.v4u32.f32
llvm.nvvm.texsurf.handle
llvm.nvvm.texsurf.handle.internal
llvm.nvvm.tld4.a.2d.v4f32.f32
llvm.nvvm.tld4.a.2d.v4s32.f32
llvm.nvvm.tld4.a.2d.v4u32.f32
llvm.nvvm.tld4.b.2d.v4f32.f32
llvm.nvvm.tld4.b.2d.v4s32.f32
llvm.nvvm.tld4.b.2d.v4u32.f32
llvm.nvvm.tld4.g.2d.v4f32.f32
llvm.nvvm.tld4.g.2d.v4s32.f32
llvm.nvvm.tld4.g.2d.v4u32.f32
llvm.nvvm.tld4.r.2d.v4f32.f32
llvm.nvvm.tld4.r.2d.v4s32.f32
llvm.nvvm.tld4.r.2d.v4u32.f32
llvm.nvvm.tld4.unified.a.2d.v4f32.f32
llvm.nvvm.tld4.unified.a.2d.v4s32.f32
llvm.nvvm.tld4.unified.a.2d.v4u32.f32
llvm.nvvm.tld4.unified.b.2d.v4f32.f32
llvm.nvvm.tld4.unified.b.2d.v4s32.f32
llvm.nvvm.tld4.unified.b.2d.v4u32.f32
llvm.nvvm.tld4.unified.g.2d.v4f32.f32
llvm.nvvm.tld4.unified.g.2d.v4s32.f32
llvm.nvvm.tld4.unified.g.2d.v4u32.f32
llvm.nvvm.tld4.unified.r.2d.v4f32.f32
llvm.nvvm.tld4.unified.r.2d.v4s32.f32
llvm.nvvm.tld4.unified.r.2d.v4u32.f32
llvm.nvvm.trunc.d
llvm.nvvm.trunc.f
llvm.nvvm.trunc.ftz.f
llvm.nvvm.txq.array.size
llvm.nvvm.txq.channel.data.type
llvm.nvvm.txq.channel.order
llvm.nvvm.txq.depth
llvm.nvvm.txq.height
llvm.nvvm.txq.num.mipmap.levels
llvm.nvvm.txq.num.samples
llvm.nvvm.txq.width
llvm.nvvm.ui2d.rm
llvm.nvvm.ui2d.rn
llvm.nvvm.ui2d.rp
llvm.nvvm.ui2d.rz
llvm.nvvm.ui2f.rm
llvm.nvvm.ui2f.rn
llvm.nvvm.ui2f.rp
llvm.nvvm.ui2f.rz
llvm.nvvm.ull2d.rm
llvm.nvvm.ull2d.rn
llvm.nvvm.ull2d.rp
llvm.nvvm.ull2d.rz
llvm.nvvm.ull2f.rm
llvm.nvvm.ull2f.rn
llvm.nvvm.ull2f.rp
llvm.nvvm.ull2f.rz
llvm.nvvm.vote.all
llvm.nvvm.vote.all.sync
llvm.nvvm.vote.any
llvm.nvvm.vote.any.sync
llvm.nvvm.vote.ballot
llvm.nvvm.vote.ballot.sync
llvm.nvvm.vote.uni
llvm.nvvm.vote.uni.sync
llvm.nvvm.wmma.m16n16k16.load.a.col.f16
llvm.nvvm.wmma.m16n16k16.load.a.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.a.row.f16
llvm.nvvm.wmma.m16n16k16.load.a.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.b.col.f16
llvm.nvvm.wmma.m16n16k16.load.b.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.b.row.f16
llvm.nvvm.wmma.m16n16k16.load.b.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.f32
llvm.nvvm.wmma.m16n16k16.load.c.col.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.col.stride.f32
llvm.nvvm.wmma.m16n16k16.load.c.row.f16
llvm.nvvm.wmma.m16n16k16.load.c.row.f32
llvm.nvvm.wmma.m16n16k16.load.c.row.stride.f16
llvm.nvvm.wmma.m16n16k16.load.c.row.stride.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m16n16k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m16n16k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m16n16k16.store.d.col.f16
llvm.nvvm.wmma.m16n16k16.store.d.col.f32
llvm.nvvm.wmma.m16n16k16.store.d.col.stride.f16
llvm.nvvm.wmma.m16n16k16.store.d.col.stride.f32
llvm.nvvm.wmma.m16n16k16.store.d.row.f16
llvm.nvvm.wmma.m16n16k16.store.d.row.f32
llvm.nvvm.wmma.m16n16k16.store.d.row.stride.f16
llvm.nvvm.wmma.m16n16k16.store.d.row.stride.f32
llvm.nvvm.wmma.m32n8k16.load.a.col.f16
llvm.nvvm.wmma.m32n8k16.load.a.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.a.row.f16
llvm.nvvm.wmma.m32n8k16.load.a.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.b.col.f16
llvm.nvvm.wmma.m32n8k16.load.b.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.b.row.f16
llvm.nvvm.wmma.m32n8k16.load.b.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.f32
llvm.nvvm.wmma.m32n8k16.load.c.col.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.col.stride.f32
llvm.nvvm.wmma.m32n8k16.load.c.row.f16
llvm.nvvm.wmma.m32n8k16.load.c.row.f32
llvm.nvvm.wmma.m32n8k16.load.c.row.stride.f16
llvm.nvvm.wmma.m32n8k16.load.c.row.stride.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m32n8k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m32n8k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m32n8k16.store.d.col.f16
llvm.nvvm.wmma.m32n8k16.store.d.col.f32
llvm.nvvm.wmma.m32n8k16.store.d.col.stride.f16
llvm.nvvm.wmma.m32n8k16.store.d.col.stride.f32
llvm.nvvm.wmma.m32n8k16.store.d.row.f16
llvm.nvvm.wmma.m32n8k16.store.d.row.f32
llvm.nvvm.wmma.m32n8k16.store.d.row.stride.f16
llvm.nvvm.wmma.m32n8k16.store.d.row.stride.f32
llvm.nvvm.wmma.m8n32k16.load.a.col.f16
llvm.nvvm.wmma.m8n32k16.load.a.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.a.row.f16
llvm.nvvm.wmma.m8n32k16.load.a.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.b.col.f16
llvm.nvvm.wmma.m8n32k16.load.b.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.b.row.f16
llvm.nvvm.wmma.m8n32k16.load.b.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.f32
llvm.nvvm.wmma.m8n32k16.load.c.col.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.col.stride.f32
llvm.nvvm.wmma.m8n32k16.load.c.row.f16
llvm.nvvm.wmma.m8n32k16.load.c.row.f32
llvm.nvvm.wmma.m8n32k16.load.c.row.stride.f16
llvm.nvvm.wmma.m8n32k16.load.c.row.stride.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.col.col.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.col.row.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.col.row.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.row.col.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.row.col.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f16
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f32
llvm.nvvm.wmma.m8n32k16.mma.row.row.f16.f32.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f16
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f16.satfinite
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f32
llvm.nvvm.wmma.m8n32k16.mma.row.row.f32.f32.satfinite
llvm.nvvm.wmma.m8n32k16.store.d.col.f16
llvm.nvvm.wmma.m8n32k16.store.d.col.f32
llvm.nvvm.wmma.m8n32k16.store.d.col.stride.f16
llvm.nvvm.wmma.m8n32k16.store.d.col.stride.f32
llvm.nvvm.wmma.m8n32k16.store.d.row.f16
llvm.nvvm.wmma.m8n32k16.store.d.row.f32
llvm.nvvm.wmma.m8n32k16.store.d.row.stride.f16
llvm.nvvm.wmma.m8n32k16.store.d.row.stride.f32
llvm.ppc.addf128.round.to.odd
llvm.ppc.altivec.crypto.vcipher
llvm.ppc.altivec.crypto.vcipherlast
llvm.ppc.altivec.crypto.vncipher
llvm.ppc.altivec.crypto.vncipherlast
llvm.ppc.altivec.crypto.vpermxor
llvm.ppc.altivec.crypto.vpmsumb
llvm.ppc.altivec.crypto.vpmsumd
llvm.ppc.altivec.crypto.vpmsumh
llvm.ppc.altivec.crypto.vpmsumw
llvm.ppc.altivec.crypto.vsbox
llvm.ppc.altivec.crypto.vshasigmad
llvm.ppc.altivec.crypto.vshasigmaw
llvm.ppc.altivec.dss
llvm.ppc.altivec.dssall
llvm.ppc.altivec.dst
llvm.ppc.altivec.dstst
llvm.ppc.altivec.dststt
llvm.ppc.altivec.dstt
llvm.ppc.altivec.lvebx
llvm.ppc.altivec.lvehx
llvm.ppc.altivec.lvewx
llvm.ppc.altivec.lvsl
llvm.ppc.altivec.lvsr
llvm.ppc.altivec.lvx
llvm.ppc.altivec.lvxl
llvm.ppc.altivec.mfvscr
llvm.ppc.altivec.mtvscr
llvm.ppc.altivec.stvebx
llvm.ppc.altivec.stvehx
llvm.ppc.altivec.stvewx
llvm.ppc.altivec.stvx
llvm.ppc.altivec.stvxl
llvm.ppc.altivec.vabsdub
llvm.ppc.altivec.vabsduh
llvm.ppc.altivec.vabsduw
llvm.ppc.altivec.vaddcuq
llvm.ppc.altivec.vaddcuw
llvm.ppc.altivec.vaddecuq
llvm.ppc.altivec.vaddeuqm
llvm.ppc.altivec.vaddsbs
llvm.ppc.altivec.vaddshs
llvm.ppc.altivec.vaddsws
llvm.ppc.altivec.vaddubs
llvm.ppc.altivec.vadduhs
llvm.ppc.altivec.vadduws
llvm.ppc.altivec.vavgsb
llvm.ppc.altivec.vavgsh
llvm.ppc.altivec.vavgsw
llvm.ppc.altivec.vavgub
llvm.ppc.altivec.vavguh
llvm.ppc.altivec.vavguw
llvm.ppc.altivec.vbpermq
llvm.ppc.altivec.vcfsx
llvm.ppc.altivec.vcfux
llvm.ppc.altivec.vclzlsbb
llvm.ppc.altivec.vcmpbfp
llvm.ppc.altivec.vcmpbfp.p
llvm.ppc.altivec.vcmpeqfp
llvm.ppc.altivec.vcmpeqfp.p
llvm.ppc.altivec.vcmpequb
llvm.ppc.altivec.vcmpequb.p
llvm.ppc.altivec.vcmpequd
llvm.ppc.altivec.vcmpequd.p
llvm.ppc.altivec.vcmpequh
llvm.ppc.altivec.vcmpequh.p
llvm.ppc.altivec.vcmpequw
llvm.ppc.altivec.vcmpequw.p
llvm.ppc.altivec.vcmpgefp
llvm.ppc.altivec.vcmpgefp.p
llvm.ppc.altivec.vcmpgtfp
llvm.ppc.altivec.vcmpgtfp.p
llvm.ppc.altivec.vcmpgtsb
llvm.ppc.altivec.vcmpgtsb.p
llvm.ppc.altivec.vcmpgtsd
llvm.ppc.altivec.vcmpgtsd.p
llvm.ppc.altivec.vcmpgtsh
llvm.ppc.altivec.vcmpgtsh.p
llvm.ppc.altivec.vcmpgtsw
llvm.ppc.altivec.vcmpgtsw.p
llvm.ppc.altivec.vcmpgtub
llvm.ppc.altivec.vcmpgtub.p
llvm.ppc.altivec.vcmpgtud
llvm.ppc.altivec.vcmpgtud.p
llvm.ppc.altivec.vcmpgtuh
llvm.ppc.altivec.vcmpgtuh.p
llvm.ppc.altivec.vcmpgtuw
llvm.ppc.altivec.vcmpgtuw.p
llvm.ppc.altivec.vcmpneb
llvm.ppc.altivec.vcmpneb.p
llvm.ppc.altivec.vcmpneh
llvm.ppc.altivec.vcmpneh.p
llvm.ppc.altivec.vcmpnew
llvm.ppc.altivec.vcmpnew.p
llvm.ppc.altivec.vcmpnezb
llvm.ppc.altivec.vcmpnezb.p
llvm.ppc.altivec.vcmpnezh
llvm.ppc.altivec.vcmpnezh.p
llvm.ppc.altivec.vcmpnezw
llvm.ppc.altivec.vcmpnezw.p
llvm.ppc.altivec.vctsxs
llvm.ppc.altivec.vctuxs
llvm.ppc.altivec.vctzlsbb
llvm.ppc.altivec.vexptefp
llvm.ppc.altivec.vgbbd
llvm.ppc.altivec.vlogefp
llvm.ppc.altivec.vmaddfp
llvm.ppc.altivec.vmaxfp
llvm.ppc.altivec.vmaxsb
llvm.ppc.altivec.vmaxsd
llvm.ppc.altivec.vmaxsh
llvm.ppc.altivec.vmaxsw
llvm.ppc.altivec.vmaxub
llvm.ppc.altivec.vmaxud
llvm.ppc.altivec.vmaxuh
llvm.ppc.altivec.vmaxuw
llvm.ppc.altivec.vmhaddshs
llvm.ppc.altivec.vmhraddshs
llvm.ppc.altivec.vminfp
llvm.ppc.altivec.vminsb
llvm.ppc.altivec.vminsd
llvm.ppc.altivec.vminsh
llvm.ppc.altivec.vminsw
llvm.ppc.altivec.vminub
llvm.ppc.altivec.vminud
llvm.ppc.altivec.vminuh
llvm.ppc.altivec.vminuw
llvm.ppc.altivec.vmladduhm
llvm.ppc.altivec.vmsummbm
llvm.ppc.altivec.vmsumshm
llvm.ppc.altivec.vmsumshs
llvm.ppc.altivec.vmsumubm
llvm.ppc.altivec.vmsumuhm
llvm.ppc.altivec.vmsumuhs
llvm.ppc.altivec.vmulesb
llvm.ppc.altivec.vmulesh
llvm.ppc.altivec.vmulesw
llvm.ppc.altivec.vmuleub
llvm.ppc.altivec.vmuleuh
llvm.ppc.altivec.vmuleuw
llvm.ppc.altivec.vmulosb
llvm.ppc.altivec.vmulosh
llvm.ppc.altivec.vmulosw
llvm.ppc.altivec.vmuloub
llvm.ppc.altivec.vmulouh
llvm.ppc.altivec.vmulouw
llvm.ppc.altivec.vnmsubfp
llvm.ppc.altivec.vperm
llvm.ppc.altivec.vpkpx
llvm.ppc.altivec.vpksdss
llvm.ppc.altivec.vpksdus
llvm.ppc.altivec.vpkshss
llvm.ppc.altivec.vpkshus
llvm.ppc.altivec.vpkswss
llvm.ppc.altivec.vpkswus
llvm.ppc.altivec.vpkudus
llvm.ppc.altivec.vpkuhus
llvm.ppc.altivec.vpkuwus
llvm.ppc.altivec.vprtybd
llvm.ppc.altivec.vprtybq
llvm.ppc.altivec.vprtybw
llvm.ppc.altivec.vrefp
llvm.ppc.altivec.vrfim
llvm.ppc.altivec.vrfin
llvm.ppc.altivec.vrfip
llvm.ppc.altivec.vrfiz
llvm.ppc.altivec.vrlb
llvm.ppc.altivec.vrld
llvm.ppc.altivec.vrldmi
llvm.ppc.altivec.vrldnm
llvm.ppc.altivec.vrlh
llvm.ppc.altivec.vrlw
llvm.ppc.altivec.vrlwmi
llvm.ppc.altivec.vrlwnm
llvm.ppc.altivec.vrsqrtefp
llvm.ppc.altivec.vsel
llvm.ppc.altivec.vsl
llvm.ppc.altivec.vslb
llvm.ppc.altivec.vslh
llvm.ppc.altivec.vslo
llvm.ppc.altivec.vslv
llvm.ppc.altivec.vslw
llvm.ppc.altivec.vsr
llvm.ppc.altivec.vsrab
llvm.ppc.altivec.vsrah
llvm.ppc.altivec.vsraw
llvm.ppc.altivec.vsrb
llvm.ppc.altivec.vsrh
llvm.ppc.altivec.vsro
llvm.ppc.altivec.vsrv
llvm.ppc.altivec.vsrw
llvm.ppc.altivec.vsubcuq
llvm.ppc.altivec.vsubcuw
llvm.ppc.altivec.vsubecuq
llvm.ppc.altivec.vsubeuqm
llvm.ppc.altivec.vsubsbs
llvm.ppc.altivec.vsubshs
llvm.ppc.altivec.vsubsws
llvm.ppc.altivec.vsububs
llvm.ppc.altivec.vsubuhs
llvm.ppc.altivec.vsubuws
llvm.ppc.altivec.vsum2sws
llvm.ppc.altivec.vsum4sbs
llvm.ppc.altivec.vsum4shs
llvm.ppc.altivec.vsum4ubs
llvm.ppc.altivec.vsumsws
llvm.ppc.altivec.vupkhpx
llvm.ppc.altivec.vupkhsb
llvm.ppc.altivec.vupkhsh
llvm.ppc.altivec.vupkhsw
llvm.ppc.altivec.vupklpx
llvm.ppc.altivec.vupklsb
llvm.ppc.altivec.vupklsh
llvm.ppc.altivec.vupklsw
llvm.ppc.bpermd
llvm.ppc.cfence
llvm.ppc.dcba
llvm.ppc.dcbf
llvm.ppc.dcbi
llvm.ppc.dcbst
llvm.ppc.dcbt
llvm.ppc.dcbtst
llvm.ppc.dcbz
llvm.ppc.dcbzl
llvm.ppc.divde
llvm.ppc.divdeu
llvm.ppc.divf128.round.to.odd
llvm.ppc.divwe
llvm.ppc.divweu
llvm.ppc.fmaf128.round.to.odd
llvm.ppc.get.texasr
llvm.ppc.get.texasru
llvm.ppc.get.tfhar
llvm.ppc.get.tfiar
llvm.ppc.is.decremented.ctr.nonzero
llvm.ppc.lwsync
llvm.ppc.mtctr
llvm.ppc.mulf128.round.to.odd
llvm.ppc.qpx.qvfabs
llvm.ppc.qpx.qvfadd
llvm.ppc.qpx.qvfadds
llvm.ppc.qpx.qvfcfid
llvm.ppc.qpx.qvfcfids
llvm.ppc.qpx.qvfcfidu
llvm.ppc.qpx.qvfcfidus
llvm.ppc.qpx.qvfcmpeq
llvm.ppc.qpx.qvfcmpgt
llvm.ppc.qpx.qvfcmplt
llvm.ppc.qpx.qvfcpsgn
llvm.ppc.qpx.qvfctid
llvm.ppc.qpx.qvfctidu
llvm.ppc.qpx.qvfctiduz
llvm.ppc.qpx.qvfctidz
llvm.ppc.qpx.qvfctiw
llvm.ppc.qpx.qvfctiwu
llvm.ppc.qpx.qvfctiwuz
llvm.ppc.qpx.qvfctiwz
llvm.ppc.qpx.qvflogical
llvm.ppc.qpx.qvfmadd
llvm.ppc.qpx.qvfmadds
llvm.ppc.qpx.qvfmsub
llvm.ppc.qpx.qvfmsubs
llvm.ppc.qpx.qvfmul
llvm.ppc.qpx.qvfmuls
llvm.ppc.qpx.qvfnabs
llvm.ppc.qpx.qvfneg
llvm.ppc.qpx.qvfnmadd
llvm.ppc.qpx.qvfnmadds
llvm.ppc.qpx.qvfnmsub
llvm.ppc.qpx.qvfnmsubs
llvm.ppc.qpx.qvfperm
llvm.ppc.qpx.qvfre
llvm.ppc.qpx.qvfres
llvm.ppc.qpx.qvfrim
llvm.ppc.qpx.qvfrin
llvm.ppc.qpx.qvfrip
llvm.ppc.qpx.qvfriz
llvm.ppc.qpx.qvfrsp
llvm.ppc.qpx.qvfrsqrte
llvm.ppc.qpx.qvfrsqrtes
llvm.ppc.qpx.qvfsel
llvm.ppc.qpx.qvfsub
llvm.ppc.qpx.qvfsubs
llvm.ppc.qpx.qvftstnan
llvm.ppc.qpx.qvfxmadd
llvm.ppc.qpx.qvfxmadds
llvm.ppc.qpx.qvfxmul
llvm.ppc.qpx.qvfxmuls
llvm.ppc.qpx.qvfxxcpnmadd
llvm.ppc.qpx.qvfxxcpnmadds
llvm.ppc.qpx.qvfxxmadd
llvm.ppc.qpx.qvfxxmadds
llvm.ppc.qpx.qvfxxnpmadd
llvm.ppc.qpx.qvfxxnpmadds
llvm.ppc.qpx.qvgpci
llvm.ppc.qpx.qvlfcd
llvm.ppc.qpx.qvlfcda
llvm.ppc.qpx.qvlfcs
llvm.ppc.qpx.qvlfcsa
llvm.ppc.qpx.qvlfd
llvm.ppc.qpx.qvlfda
llvm.ppc.qpx.qvlfiwa
llvm.ppc.qpx.qvlfiwaa
llvm.ppc.qpx.qvlfiwz
llvm.ppc.qpx.qvlfiwza
llvm.ppc.qpx.qvlfs
llvm.ppc.qpx.qvlfsa
llvm.ppc.qpx.qvlpcld
llvm.ppc.qpx.qvlpcls
llvm.ppc.qpx.qvlpcrd
llvm.ppc.qpx.qvlpcrs
llvm.ppc.qpx.qvstfcd
llvm.ppc.qpx.qvstfcda
llvm.ppc.qpx.qvstfcs
llvm.ppc.qpx.qvstfcsa
llvm.ppc.qpx.qvstfd
llvm.ppc.qpx.qvstfda
llvm.ppc.qpx.qvstfiw
llvm.ppc.qpx.qvstfiwa
llvm.ppc.qpx.qvstfs
llvm.ppc.qpx.qvstfsa
llvm.ppc.set.texasr
llvm.ppc.set.texasru
llvm.ppc.set.tfhar
llvm.ppc.set.tfiar
llvm.ppc.sqrtf128.round.to.odd
llvm.ppc.subf128.round.to.odd
llvm.ppc.sync
llvm.ppc.tabort
llvm.ppc.tabortdc
llvm.ppc.tabortdci
llvm.ppc.tabortwc
llvm.ppc.tabortwci
llvm.ppc.tbegin
llvm.ppc.tcheck
llvm.ppc.tend
llvm.ppc.tendall
llvm.ppc.trechkpt
llvm.ppc.treclaim
llvm.ppc.tresume
llvm.ppc.truncf128.round.to.odd
llvm.ppc.tsr
llvm.ppc.tsuspend
llvm.ppc.ttest
llvm.ppc.vsx.lxvd2x
llvm.ppc.vsx.lxvd2x.be
llvm.ppc.vsx.lxvl
llvm.ppc.vsx.lxvll
llvm.ppc.vsx.lxvw4x
llvm.ppc.vsx.lxvw4x.be
llvm.ppc.vsx.stxvd2x
llvm.ppc.vsx.stxvd2x.be
llvm.ppc.vsx.stxvl
llvm.ppc.vsx.stxvll
llvm.ppc.vsx.stxvw4x
llvm.ppc.vsx.stxvw4x.be
llvm.ppc.vsx.xsmaxdp
llvm.ppc.vsx.xsmindp
llvm.ppc.vsx.xvcmpeqdp
llvm.ppc.vsx.xvcmpeqdp.p
llvm.ppc.vsx.xvcmpeqsp
llvm.ppc.vsx.xvcmpeqsp.p
llvm.ppc.vsx.xvcmpgedp
llvm.ppc.vsx.xvcmpgedp.p
llvm.ppc.vsx.xvcmpgesp
llvm.ppc.vsx.xvcmpgesp.p
llvm.ppc.vsx.xvcmpgtdp
llvm.ppc.vsx.xvcmpgtdp.p
llvm.ppc.vsx.xvcmpgtsp
llvm.ppc.vsx.xvcmpgtsp.p
llvm.ppc.vsx.xvcvdpsp
llvm.ppc.vsx.xvcvdpsxws
llvm.ppc.vsx.xvcvdpuxws
llvm.ppc.vsx.xvcvhpsp
llvm.ppc.vsx.xvcvspdp
llvm.ppc.vsx.xvcvsphp
llvm.ppc.vsx.xvcvsxdsp
llvm.ppc.vsx.xvcvsxwdp
llvm.ppc.vsx.xvcvuxdsp
llvm.ppc.vsx.xvcvuxwdp
llvm.ppc.vsx.xvdivdp
llvm.ppc.vsx.xvdivsp
llvm.ppc.vsx.xviexpdp
llvm.ppc.vsx.xviexpsp
llvm.ppc.vsx.xvmaxdp
llvm.ppc.vsx.xvmaxsp
llvm.ppc.vsx.xvmindp
llvm.ppc.vsx.xvminsp
llvm.ppc.vsx.xvrdpip
llvm.ppc.vsx.xvredp
llvm.ppc.vsx.xvresp
llvm.ppc.vsx.xvrspip
llvm.ppc.vsx.xvrsqrtedp
llvm.ppc.vsx.xvrsqrtesp
llvm.ppc.vsx.xvtstdcdp
llvm.ppc.vsx.xvtstdcsp
llvm.ppc.vsx.xvxexpdp
llvm.ppc.vsx.xvxexpsp
llvm.ppc.vsx.xvxsigdp
llvm.ppc.vsx.xvxsigsp
llvm.ppc.vsx.xxextractuw
llvm.ppc.vsx.xxinsertw
llvm.ppc.vsx.xxleqv
llvm.r600.cube
llvm.r600.ddx
llvm.r600.ddy
llvm.r600.dot4
llvm.r600.group.barrier
llvm.r600.implicitarg.ptr
llvm.r600.kill
llvm.r600.rat.store.typed
llvm.r600.read.global.size.x
llvm.r600.read.global.size.y
llvm.r600.read.global.size.z
llvm.r600.read.local.size.x
llvm.r600.read.local.size.y
llvm.r600.read.local.size.z
llvm.r600.read.ngroups.x
llvm.r600.read.ngroups.y
llvm.r600.read.ngroups.z
llvm.r600.read.tgid.x
llvm.r600.read.tgid.y
llvm.r600.read.tgid.z
llvm.r600.read.tidig.x
llvm.r600.read.tidig.y
llvm.r600.read.tidig.z
llvm.r600.recipsqrt.clamped
llvm.r600.recipsqrt.ieee
llvm.r600.store.stream.output
llvm.r600.store.swizzle
llvm.r600.tex
llvm.r600.texc
llvm.r600.txb
llvm.r600.txbc
llvm.r600.txf
llvm.r600.txl
llvm.r600.txlc
llvm.r600.txq
llvm.s390.efpc
llvm.s390.etnd
llvm.s390.lcbb
llvm.s390.ntstg
llvm.s390.ppa.txassist
llvm.s390.sfpc
llvm.s390.tabort
llvm.s390.tbegin
llvm.s390.tbegin.nofloat
llvm.s390.tbeginc
llvm.s390.tdc
llvm.s390.tend
llvm.s390.vaccb
llvm.s390.vacccq
llvm.s390.vaccf
llvm.s390.vaccg
llvm.s390.vacch
llvm.s390.vaccq
llvm.s390.vacq
llvm.s390.vaq
llvm.s390.vavgb
llvm.s390.vavgf
llvm.s390.vavgg
llvm.s390.vavgh
llvm.s390.vavglb
llvm.s390.vavglf
llvm.s390.vavglg
llvm.s390.vavglh
llvm.s390.vbperm
llvm.s390.vceqbs
llvm.s390.vceqfs
llvm.s390.vceqgs
llvm.s390.vceqhs
llvm.s390.vchbs
llvm.s390.vchfs
llvm.s390.vchgs
llvm.s390.vchhs
llvm.s390.vchlbs
llvm.s390.vchlfs
llvm.s390.vchlgs
llvm.s390.vchlhs
llvm.s390.vcksm
llvm.s390.verimb
llvm.s390.verimf
llvm.s390.verimg
llvm.s390.verimh
llvm.s390.verllb
llvm.s390.verllf
llvm.s390.verllg
llvm.s390.verllh
llvm.s390.verllvb
llvm.s390.verllvf
llvm.s390.verllvg
llvm.s390.verllvh
llvm.s390.vfaeb
llvm.s390.vfaebs
llvm.s390.vfaef
llvm.s390.vfaefs
llvm.s390.vfaeh
llvm.s390.vfaehs
llvm.s390.vfaezb
llvm.s390.vfaezbs
llvm.s390.vfaezf
llvm.s390.vfaezfs
llvm.s390.vfaezh
llvm.s390.vfaezhs
llvm.s390.vfcedbs
llvm.s390.vfcesbs
llvm.s390.vfchdbs
llvm.s390.vfchedbs
llvm.s390.vfchesbs
llvm.s390.vfchsbs
llvm.s390.vfeeb
llvm.s390.vfeebs
llvm.s390.vfeef
llvm.s390.vfeefs
llvm.s390.vfeeh
llvm.s390.vfeehs
llvm.s390.vfeezb
llvm.s390.vfeezbs
llvm.s390.vfeezf
llvm.s390.vfeezfs
llvm.s390.vfeezh
llvm.s390.vfeezhs
llvm.s390.vfeneb
llvm.s390.vfenebs
llvm.s390.vfenef
llvm.s390.vfenefs
llvm.s390.vfeneh
llvm.s390.vfenehs
llvm.s390.vfenezb
llvm.s390.vfenezbs
llvm.s390.vfenezf
llvm.s390.vfenezfs
llvm.s390.vfenezh
llvm.s390.vfenezhs
llvm.s390.vfidb
llvm.s390.vfisb
llvm.s390.vfmaxdb
llvm.s390.vfmaxsb
llvm.s390.vfmindb
llvm.s390.vfminsb
llvm.s390.vftcidb
llvm.s390.vftcisb
llvm.s390.vgfmab
llvm.s390.vgfmaf
llvm.s390.vgfmag
llvm.s390.vgfmah
llvm.s390.vgfmb
llvm.s390.vgfmf
llvm.s390.vgfmg
llvm.s390.vgfmh
llvm.s390.vistrb
llvm.s390.vistrbs
llvm.s390.vistrf
llvm.s390.vistrfs
llvm.s390.vistrh
llvm.s390.vistrhs
llvm.s390.vlbb
llvm.s390.vll
llvm.s390.vlrl
llvm.s390.vmaeb
llvm.s390.vmaef
llvm.s390.vmaeh
llvm.s390.vmahb
llvm.s390.vmahf
llvm.s390.vmahh
llvm.s390.vmaleb
llvm.s390.vmalef
llvm.s390.vmaleh
llvm.s390.vmalhb
llvm.s390.vmalhf
llvm.s390.vmalhh
llvm.s390.vmalob
llvm.s390.vmalof
llvm.s390.vmaloh
llvm.s390.vmaob
llvm.s390.vmaof
llvm.s390.vmaoh
llvm.s390.vmeb
llvm.s390.vmef
llvm.s390.vmeh
llvm.s390.vmhb
llvm.s390.vmhf
llvm.s390.vmhh
llvm.s390.vmleb
llvm.s390.vmlef
llvm.s390.vmleh
llvm.s390.vmlhb
llvm.s390.vmlhf
llvm.s390.vmlhh
llvm.s390.vmlob
llvm.s390.vmlof
llvm.s390.vmloh
llvm.s390.vmob
llvm.s390.vmof
llvm.s390.vmoh
llvm.s390.vmslg
llvm.s390.vpdi
llvm.s390.vperm
llvm.s390.vpklsf
llvm.s390.vpklsfs
llvm.s390.vpklsg
llvm.s390.vpklsgs
llvm.s390.vpklsh
llvm.s390.vpklshs
llvm.s390.vpksf
llvm.s390.vpksfs
llvm.s390.vpksg
llvm.s390.vpksgs
llvm.s390.vpksh
llvm.s390.vpkshs
llvm.s390.vsbcbiq
llvm.s390.vsbiq
llvm.s390.vscbib
llvm.s390.vscbif
llvm.s390.vscbig
llvm.s390.vscbih
llvm.s390.vscbiq
llvm.s390.vsl
llvm.s390.vslb
llvm.s390.vsldb
llvm.s390.vsq
llvm.s390.vsra
llvm.s390.vsrab
llvm.s390.vsrl
llvm.s390.vsrlb
llvm.s390.vstl
llvm.s390.vstrcb
llvm.s390.vstrcbs
llvm.s390.vstrcf
llvm.s390.vstrcfs
llvm.s390.vstrch
llvm.s390.vstrchs
llvm.s390.vstrczb
llvm.s390.vstrczbs
llvm.s390.vstrczf
llvm.s390.vstrczfs
llvm.s390.vstrczh
llvm.s390.vstrczhs
llvm.s390.vstrl
llvm.s390.vsumb
llvm.s390.vsumgf
llvm.s390.vsumgh
llvm.s390.vsumh
llvm.s390.vsumqf
llvm.s390.vsumqg
llvm.s390.vtm
llvm.s390.vuphb
llvm.s390.vuphf
llvm.s390.vuphh
llvm.s390.vuplb
llvm.s390.vuplf
llvm.s390.vuplhb
llvm.s390.vuplhf
llvm.s390.vuplhh
llvm.s390.vuplhw
llvm.s390.vupllb
llvm.s390.vupllf
llvm.s390.vupllh
llvm.wasm.catch
llvm.wasm.current.memory
llvm.wasm.get.ehselector
llvm.wasm.get.exception
llvm.wasm.grow.memory
llvm.wasm.landingpad.index
llvm.wasm.lsda
llvm.wasm.mem.grow
llvm.wasm.mem.size
llvm.wasm.memory.grow
llvm.wasm.memory.size
llvm.wasm.rethrow
llvm.wasm.throw
llvm.x86.3dnow.pavgusb
llvm.x86.3dnow.pf2id
llvm.x86.3dnow.pfacc
llvm.x86.3dnow.pfadd
llvm.x86.3dnow.pfcmpeq
llvm.x86.3dnow.pfcmpge
llvm.x86.3dnow.pfcmpgt
llvm.x86.3dnow.pfmax
llvm.x86.3dnow.pfmin
llvm.x86.3dnow.pfmul
llvm.x86.3dnow.pfrcp
llvm.x86.3dnow.pfrcpit1
llvm.x86.3dnow.pfrcpit2
llvm.x86.3dnow.pfrsqit1
llvm.x86.3dnow.pfrsqrt
llvm.x86.3dnow.pfsub
llvm.x86.3dnow.pfsubr
llvm.x86.3dnow.pi2fd
llvm.x86.3dnow.pmulhrw
llvm.x86.3dnowa.pf2iw
llvm.x86.3dnowa.pfnacc
llvm.x86.3dnowa.pfpnacc
llvm.x86.3dnowa.pi2fw
llvm.x86.3dnowa.pswapd
llvm.x86.addcarry.u32
llvm.x86.addcarry.u64
llvm.x86.addcarryx.u32
llvm.x86.addcarryx.u64
llvm.x86.aesni.aesdec
llvm.x86.aesni.aesdec.256
llvm.x86.aesni.aesdec.512
llvm.x86.aesni.aesdeclast
llvm.x86.aesni.aesdeclast.256
llvm.x86.aesni.aesdeclast.512
llvm.x86.aesni.aesenc
llvm.x86.aesni.aesenc.256
llvm.x86.aesni.aesenc.512
llvm.x86.aesni.aesenclast
llvm.x86.aesni.aesenclast.256
llvm.x86.aesni.aesenclast.512
llvm.x86.aesni.aesimc
llvm.x86.aesni.aeskeygenassist
llvm.x86.avx.addsub.pd.256
llvm.x86.avx.addsub.ps.256
llvm.x86.avx.blendv.pd.256
llvm.x86.avx.blendv.ps.256
llvm.x86.avx.cmp.pd.256
llvm.x86.avx.cmp.ps.256
llvm.x86.avx.cvt.pd2.ps.256
llvm.x86.avx.cvt.pd2dq.256
llvm.x86.avx.cvt.ps2dq.256
llvm.x86.avx.cvtt.pd2dq.256
llvm.x86.avx.cvtt.ps2dq.256
llvm.x86.avx.dp.ps.256
llvm.x86.avx.hadd.pd.256
llvm.x86.avx.hadd.ps.256
llvm.x86.avx.hsub.pd.256
llvm.x86.avx.hsub.ps.256
llvm.x86.avx.ldu.dq.256
llvm.x86.avx.maskload.pd
llvm.x86.avx.maskload.pd.256
llvm.x86.avx.maskload.ps
llvm.x86.avx.maskload.ps.256
llvm.x86.avx.maskstore.pd
llvm.x86.avx.maskstore.pd.256
llvm.x86.avx.maskstore.ps
llvm.x86.avx.maskstore.ps.256
llvm.x86.avx.max.pd.256
llvm.x86.avx.max.ps.256
llvm.x86.avx.min.pd.256
llvm.x86.avx.min.ps.256
llvm.x86.avx.movmsk.pd.256
llvm.x86.avx.movmsk.ps.256
llvm.x86.avx.ptestc.256
llvm.x86.avx.ptestnzc.256
llvm.x86.avx.ptestz.256
llvm.x86.avx.rcp.ps.256
llvm.x86.avx.round.pd.256
llvm.x86.avx.round.ps.256
llvm.x86.avx.rsqrt.ps.256
llvm.x86.avx.vpermilvar.pd
llvm.x86.avx.vpermilvar.pd.256
llvm.x86.avx.vpermilvar.ps
llvm.x86.avx.vpermilvar.ps.256
llvm.x86.avx.vtestc.pd
llvm.x86.avx.vtestc.pd.256
llvm.x86.avx.vtestc.ps
llvm.x86.avx.vtestc.ps.256
llvm.x86.avx.vtestnzc.pd
llvm.x86.avx.vtestnzc.pd.256
llvm.x86.avx.vtestnzc.ps
llvm.x86.avx.vtestnzc.ps.256
llvm.x86.avx.vtestz.pd
llvm.x86.avx.vtestz.pd.256
llvm.x86.avx.vtestz.ps
llvm.x86.avx.vtestz.ps.256
llvm.x86.avx.vzeroall
llvm.x86.avx.vzeroupper
llvm.x86.avx2.gather.d.d
llvm.x86.avx2.gather.d.d.256
llvm.x86.avx2.gather.d.pd
llvm.x86.avx2.gather.d.pd.256
llvm.x86.avx2.gather.d.ps
llvm.x86.avx2.gather.d.ps.256
llvm.x86.avx2.gather.d.q
llvm.x86.avx2.gather.d.q.256
llvm.x86.avx2.gather.q.d
llvm.x86.avx2.gather.q.d.256
llvm.x86.avx2.gather.q.pd
llvm.x86.avx2.gather.q.pd.256
llvm.x86.avx2.gather.q.ps
llvm.x86.avx2.gather.q.ps.256
llvm.x86.avx2.gather.q.q
llvm.x86.avx2.gather.q.q.256
llvm.x86.avx2.maskload.d
llvm.x86.avx2.maskload.d.256
llvm.x86.avx2.maskload.q
llvm.x86.avx2.maskload.q.256
llvm.x86.avx2.maskstore.d
llvm.x86.avx2.maskstore.d.256
llvm.x86.avx2.maskstore.q
llvm.x86.avx2.maskstore.q.256
llvm.x86.avx2.mpsadbw
llvm.x86.avx2.packssdw
llvm.x86.avx2.packsswb
llvm.x86.avx2.packusdw
llvm.x86.avx2.packuswb
llvm.x86.avx2.padds.b
llvm.x86.avx2.padds.w
llvm.x86.avx2.paddus.b
llvm.x86.avx2.paddus.w
llvm.x86.avx2.pblendvb
llvm.x86.avx2.permd
llvm.x86.avx2.permps
llvm.x86.avx2.phadd.d
llvm.x86.avx2.phadd.sw
llvm.x86.avx2.phadd.w
llvm.x86.avx2.phsub.d
llvm.x86.avx2.phsub.sw
llvm.x86.avx2.phsub.w
llvm.x86.avx2.pmadd.ub.sw
llvm.x86.avx2.pmadd.wd
llvm.x86.avx2.pmovmskb
llvm.x86.avx2.pmul.hr.sw
llvm.x86.avx2.pmulh.w
llvm.x86.avx2.pmulhu.w
llvm.x86.avx2.psad.bw
llvm.x86.avx2.pshuf.b
llvm.x86.avx2.psign.b
llvm.x86.avx2.psign.d
llvm.x86.avx2.psign.w
llvm.x86.avx2.psll.d
llvm.x86.avx2.psll.q
llvm.x86.avx2.psll.w
llvm.x86.avx2.pslli.d
llvm.x86.avx2.pslli.q
llvm.x86.avx2.pslli.w
llvm.x86.avx2.psllv.d
llvm.x86.avx2.psllv.d.256
llvm.x86.avx2.psllv.q
llvm.x86.avx2.psllv.q.256
llvm.x86.avx2.psra.d
llvm.x86.avx2.psra.w
llvm.x86.avx2.psrai.d
llvm.x86.avx2.psrai.w
llvm.x86.avx2.psrav.d
llvm.x86.avx2.psrav.d.256
llvm.x86.avx2.psrl.d
llvm.x86.avx2.psrl.q
llvm.x86.avx2.psrl.w
llvm.x86.avx2.psrli.d
llvm.x86.avx2.psrli.q
llvm.x86.avx2.psrli.w
llvm.x86.avx2.psrlv.d
llvm.x86.avx2.psrlv.d.256
llvm.x86.avx2.psrlv.q
llvm.x86.avx2.psrlv.q.256
llvm.x86.avx2.psubs.b
llvm.x86.avx2.psubs.w
llvm.x86.avx2.psubus.b
llvm.x86.avx2.psubus.w
llvm.x86.avx512.add.pd.512
llvm.x86.avx512.add.ps.512
llvm.x86.avx512.broadcastmb.128
llvm.x86.avx512.broadcastmb.256
llvm.x86.avx512.broadcastmb.512
llvm.x86.avx512.broadcastmw.128
llvm.x86.avx512.broadcastmw.256
llvm.x86.avx512.broadcastmw.512
llvm.x86.avx512.cmp.pd.128
llvm.x86.avx512.cmp.pd.256
llvm.x86.avx512.cmp.pd.512
llvm.x86.avx512.cmp.ps.128
llvm.x86.avx512.cmp.ps.256
llvm.x86.avx512.cmp.ps.512
llvm.x86.avx512.cvtsi2sd64
llvm.x86.avx512.cvtsi2ss32
llvm.x86.avx512.cvtsi2ss64
llvm.x86.avx512.cvttsd2si
llvm.x86.avx512.cvttsd2si64
llvm.x86.avx512.cvttsd2usi
llvm.x86.avx512.cvttsd2usi64
llvm.x86.avx512.cvttss2si
llvm.x86.avx512.cvttss2si64
llvm.x86.avx512.cvttss2usi
llvm.x86.avx512.cvttss2usi64
llvm.x86.avx512.cvtusi2ss
llvm.x86.avx512.cvtusi642sd
llvm.x86.avx512.cvtusi642ss
llvm.x86.avx512.dbpsadbw.128
llvm.x86.avx512.dbpsadbw.256
llvm.x86.avx512.dbpsadbw.512
llvm.x86.avx512.div.pd.512
llvm.x86.avx512.div.ps.512
llvm.x86.avx512.exp2.pd
llvm.x86.avx512.exp2.ps
llvm.x86.avx512.fpclass.pd.128
llvm.x86.avx512.fpclass.pd.256
llvm.x86.avx512.fpclass.pd.512
llvm.x86.avx512.fpclass.ps.128
llvm.x86.avx512.fpclass.ps.256
llvm.x86.avx512.fpclass.ps.512
llvm.x86.avx512.gather.dpd.512
llvm.x86.avx512.gather.dpi.512
llvm.x86.avx512.gather.dpq.512
llvm.x86.avx512.gather.dps.512
llvm.x86.avx512.gather.qpd.512
llvm.x86.avx512.gather.qpi.512
llvm.x86.avx512.gather.qpq.512
llvm.x86.avx512.gather.qps.512
llvm.x86.avx512.gather3div2.df
llvm.x86.avx512.gather3div2.di
llvm.x86.avx512.gather3div4.df
llvm.x86.avx512.gather3div4.di
llvm.x86.avx512.gather3div4.sf
llvm.x86.avx512.gather3div4.si
llvm.x86.avx512.gather3div8.sf
llvm.x86.avx512.gather3div8.si
llvm.x86.avx512.gather3siv2.df
llvm.x86.avx512.gather3siv2.di
llvm.x86.avx512.gather3siv4.df
llvm.x86.avx512.gather3siv4.di
llvm.x86.avx512.gather3siv4.sf
llvm.x86.avx512.gather3siv4.si
llvm.x86.avx512.gather3siv8.sf
llvm.x86.avx512.gather3siv8.si
llvm.x86.avx512.gatherpf.dpd.512
llvm.x86.avx512.gatherpf.dps.512
llvm.x86.avx512.gatherpf.qpd.512
llvm.x86.avx512.gatherpf.qps.512
llvm.x86.avx512.mask.add.sd.round
llvm.x86.avx512.mask.add.ss.round
llvm.x86.avx512.mask.cmp.sd
llvm.x86.avx512.mask.cmp.ss
llvm.x86.avx512.mask.compress.b.128
llvm.x86.avx512.mask.compress.b.256
llvm.x86.avx512.mask.compress.b.512
llvm.x86.avx512.mask.compress.d.128
llvm.x86.avx512.mask.compress.d.256
llvm.x86.avx512.mask.compress.d.512
llvm.x86.avx512.mask.compress.pd.128
llvm.x86.avx512.mask.compress.pd.256
llvm.x86.avx512.mask.compress.pd.512
llvm.x86.avx512.mask.compress.ps.128
llvm.x86.avx512.mask.compress.ps.256
llvm.x86.avx512.mask.compress.ps.512
llvm.x86.avx512.mask.compress.q.128
llvm.x86.avx512.mask.compress.q.256
llvm.x86.avx512.mask.compress.q.512
llvm.x86.avx512.mask.compress.w.128
llvm.x86.avx512.mask.compress.w.256
llvm.x86.avx512.mask.compress.w.512
llvm.x86.avx512.mask.conflict.d.128
llvm.x86.avx512.mask.conflict.d.256
llvm.x86.avx512.mask.conflict.d.512
llvm.x86.avx512.mask.conflict.q.128
llvm.x86.avx512.mask.conflict.q.256
llvm.x86.avx512.mask.conflict.q.512
llvm.x86.avx512.mask.cvtdq2ps.512
llvm.x86.avx512.mask.cvtpd2dq.128
llvm.x86.avx512.mask.cvtpd2dq.512
llvm.x86.avx512.mask.cvtpd2ps
llvm.x86.avx512.mask.cvtpd2ps.512
llvm.x86.avx512.mask.cvtpd2qq.128
llvm.x86.avx512.mask.cvtpd2qq.256
llvm.x86.avx512.mask.cvtpd2qq.512
llvm.x86.avx512.mask.cvtpd2udq.128
llvm.x86.avx512.mask.cvtpd2udq.256
llvm.x86.avx512.mask.cvtpd2udq.512
llvm.x86.avx512.mask.cvtpd2uqq.128
llvm.x86.avx512.mask.cvtpd2uqq.256
llvm.x86.avx512.mask.cvtpd2uqq.512
llvm.x86.avx512.mask.cvtps2dq.128
llvm.x86.avx512.mask.cvtps2dq.256
llvm.x86.avx512.mask.cvtps2dq.512
llvm.x86.avx512.mask.cvtps2pd.512
llvm.x86.avx512.mask.cvtps2qq.128
llvm.x86.avx512.mask.cvtps2qq.256
llvm.x86.avx512.mask.cvtps2qq.512
llvm.x86.avx512.mask.cvtps2udq.128
llvm.x86.avx512.mask.cvtps2udq.256
llvm.x86.avx512.mask.cvtps2udq.512
llvm.x86.avx512.mask.cvtps2uqq.128
llvm.x86.avx512.mask.cvtps2uqq.256
llvm.x86.avx512.mask.cvtps2uqq.512
llvm.x86.avx512.mask.cvtqq2pd.512
llvm.x86.avx512.mask.cvtqq2ps.128
llvm.x86.avx512.mask.cvtqq2ps.256
llvm.x86.avx512.mask.cvtqq2ps.512
llvm.x86.avx512.mask.cvtsd2ss.round
llvm.x86.avx512.mask.cvtss2sd.round
llvm.x86.avx512.mask.cvttpd2dq.128
llvm.x86.avx512.mask.cvttpd2dq.512
llvm.x86.avx512.mask.cvttpd2qq.128
llvm.x86.avx512.mask.cvttpd2qq.256
llvm.x86.avx512.mask.cvttpd2qq.512
llvm.x86.avx512.mask.cvttpd2udq.128
llvm.x86.avx512.mask.cvttpd2udq.256
llvm.x86.avx512.mask.cvttpd2udq.512
llvm.x86.avx512.mask.cvttpd2uqq.128
llvm.x86.avx512.mask.cvttpd2uqq.256
llvm.x86.avx512.mask.cvttpd2uqq.512
llvm.x86.avx512.mask.cvttps2dq.512
llvm.x86.avx512.mask.cvttps2qq.128
llvm.x86.avx512.mask.cvttps2qq.256
llvm.x86.avx512.mask.cvttps2qq.512
llvm.x86.avx512.mask.cvttps2udq.128
llvm.x86.avx512.mask.cvttps2udq.256
llvm.x86.avx512.mask.cvttps2udq.512
llvm.x86.avx512.mask.cvttps2uqq.128
llvm.x86.avx512.mask.cvttps2uqq.256
llvm.x86.avx512.mask.cvttps2uqq.512
llvm.x86.avx512.mask.cvtudq2ps.512
llvm.x86.avx512.mask.cvtuqq2pd.512
llvm.x86.avx512.mask.cvtuqq2ps.128
llvm.x86.avx512.mask.cvtuqq2ps.256
llvm.x86.avx512.mask.cvtuqq2ps.512
llvm.x86.avx512.mask.div.sd.round
llvm.x86.avx512.mask.div.ss.round
llvm.x86.avx512.mask.expand.b.128
llvm.x86.avx512.mask.expand.b.256
llvm.x86.avx512.mask.expand.b.512
llvm.x86.avx512.mask.expand.d.128
llvm.x86.avx512.mask.expand.d.256
llvm.x86.avx512.mask.expand.d.512
llvm.x86.avx512.mask.expand.pd.128
llvm.x86.avx512.mask.expand.pd.256
llvm.x86.avx512.mask.expand.pd.512
llvm.x86.avx512.mask.expand.ps.128
llvm.x86.avx512.mask.expand.ps.256
llvm.x86.avx512.mask.expand.ps.512
llvm.x86.avx512.mask.expand.q.128
llvm.x86.avx512.mask.expand.q.256
llvm.x86.avx512.mask.expand.q.512
llvm.x86.avx512.mask.expand.w.128
llvm.x86.avx512.mask.expand.w.256
llvm.x86.avx512.mask.expand.w.512
llvm.x86.avx512.mask.fixupimm.pd.128
llvm.x86.avx512.mask.fixupimm.pd.256
llvm.x86.avx512.mask.fixupimm.pd.512
llvm.x86.avx512.mask.fixupimm.ps.128
llvm.x86.avx512.mask.fixupimm.ps.256
llvm.x86.avx512.mask.fixupimm.ps.512
llvm.x86.avx512.mask.fixupimm.sd
llvm.x86.avx512.mask.fixupimm.ss
llvm.x86.avx512.mask.fpclass.sd
llvm.x86.avx512.mask.fpclass.ss
llvm.x86.avx512.mask.getexp.pd.128
llvm.x86.avx512.mask.getexp.pd.256
llvm.x86.avx512.mask.getexp.pd.512
llvm.x86.avx512.mask.getexp.ps.128
llvm.x86.avx512.mask.getexp.ps.256
llvm.x86.avx512.mask.getexp.ps.512
llvm.x86.avx512.mask.getexp.sd
llvm.x86.avx512.mask.getexp.ss
llvm.x86.avx512.mask.getmant.pd.128
llvm.x86.avx512.mask.getmant.pd.256
llvm.x86.avx512.mask.getmant.pd.512
llvm.x86.avx512.mask.getmant.ps.128
llvm.x86.avx512.mask.getmant.ps.256
llvm.x86.avx512.mask.getmant.ps.512
llvm.x86.avx512.mask.getmant.sd
llvm.x86.avx512.mask.getmant.ss
llvm.x86.avx512.mask.max.sd.round
llvm.x86.avx512.mask.max.ss.round
llvm.x86.avx512.mask.min.sd.round
llvm.x86.avx512.mask.min.ss.round
llvm.x86.avx512.mask.mul.sd.round
llvm.x86.avx512.mask.mul.ss.round
llvm.x86.avx512.mask.padds.b.128
llvm.x86.avx512.mask.padds.b.256
llvm.x86.avx512.mask.padds.b.512
llvm.x86.avx512.mask.padds.w.128
llvm.x86.avx512.mask.padds.w.256
llvm.x86.avx512.mask.padds.w.512
llvm.x86.avx512.mask.paddus.b.128
llvm.x86.avx512.mask.paddus.b.256
llvm.x86.avx512.mask.paddus.b.512
llvm.x86.avx512.mask.paddus.w.128
llvm.x86.avx512.mask.paddus.w.256
llvm.x86.avx512.mask.paddus.w.512
llvm.x86.avx512.mask.pmov.db.128
llvm.x86.avx512.mask.pmov.db.256
llvm.x86.avx512.mask.pmov.db.512
llvm.x86.avx512.mask.pmov.db.mem.128
llvm.x86.avx512.mask.pmov.db.mem.256
llvm.x86.avx512.mask.pmov.db.mem.512
llvm.x86.avx512.mask.pmov.dw.128
llvm.x86.avx512.mask.pmov.dw.256
llvm.x86.avx512.mask.pmov.dw.512
llvm.x86.avx512.mask.pmov.dw.mem.128
llvm.x86.avx512.mask.pmov.dw.mem.256
llvm.x86.avx512.mask.pmov.dw.mem.512
llvm.x86.avx512.mask.pmov.qb.128
llvm.x86.avx512.mask.pmov.qb.256
llvm.x86.avx512.mask.pmov.qb.512
llvm.x86.avx512.mask.pmov.qb.mem.128
llvm.x86.avx512.mask.pmov.qb.mem.256
llvm.x86.avx512.mask.pmov.qb.mem.512
llvm.x86.avx512.mask.pmov.qd.128
llvm.x86.avx512.mask.pmov.qd.256
llvm.x86.avx512.mask.pmov.qd.512
llvm.x86.avx512.mask.pmov.qd.mem.128
llvm.x86.avx512.mask.pmov.qd.mem.256
llvm.x86.avx512.mask.pmov.qd.mem.512
llvm.x86.avx512.mask.pmov.qw.128
llvm.x86.avx512.mask.pmov.qw.256
llvm.x86.avx512.mask.pmov.qw.512
llvm.x86.avx512.mask.pmov.qw.mem.128
llvm.x86.avx512.mask.pmov.qw.mem.256
llvm.x86.avx512.mask.pmov.qw.mem.512
llvm.x86.avx512.mask.pmov.wb.128
llvm.x86.avx512.mask.pmov.wb.256
llvm.x86.avx512.mask.pmov.wb.512
llvm.x86.avx512.mask.pmov.wb.mem.128
llvm.x86.avx512.mask.pmov.wb.mem.256
llvm.x86.avx512.mask.pmov.wb.mem.512
llvm.x86.avx512.mask.pmovs.db.128
llvm.x86.avx512.mask.pmovs.db.256
llvm.x86.avx512.mask.pmovs.db.512
llvm.x86.avx512.mask.pmovs.db.mem.128
llvm.x86.avx512.mask.pmovs.db.mem.256
llvm.x86.avx512.mask.pmovs.db.mem.512
llvm.x86.avx512.mask.pmovs.dw.128
llvm.x86.avx512.mask.pmovs.dw.256
llvm.x86.avx512.mask.pmovs.dw.512
llvm.x86.avx512.mask.pmovs.dw.mem.128
llvm.x86.avx512.mask.pmovs.dw.mem.256
llvm.x86.avx512.mask.pmovs.dw.mem.512
llvm.x86.avx512.mask.pmovs.qb.128
llvm.x86.avx512.mask.pmovs.qb.256
llvm.x86.avx512.mask.pmovs.qb.512
llvm.x86.avx512.mask.pmovs.qb.mem.128
llvm.x86.avx512.mask.pmovs.qb.mem.256
llvm.x86.avx512.mask.pmovs.qb.mem.512
llvm.x86.avx512.mask.pmovs.qd.128
llvm.x86.avx512.mask.pmovs.qd.256
llvm.x86.avx512.mask.pmovs.qd.512
llvm.x86.avx512.mask.pmovs.qd.mem.128
llvm.x86.avx512.mask.pmovs.qd.mem.256
llvm.x86.avx512.mask.pmovs.qd.mem.512
llvm.x86.avx512.mask.pmovs.qw.128
llvm.x86.avx512.mask.pmovs.qw.256
llvm.x86.avx512.mask.pmovs.qw.512
llvm.x86.avx512.mask.pmovs.qw.mem.128
llvm.x86.avx512.mask.pmovs.qw.mem.256
llvm.x86.avx512.mask.pmovs.qw.mem.512
llvm.x86.avx512.mask.pmovs.wb.128
llvm.x86.avx512.mask.pmovs.wb.256
llvm.x86.avx512.mask.pmovs.wb.512
llvm.x86.avx512.mask.pmovs.wb.mem.128
llvm.x86.avx512.mask.pmovs.wb.mem.256
llvm.x86.avx512.mask.pmovs.wb.mem.512
llvm.x86.avx512.mask.pmovus.db.128
llvm.x86.avx512.mask.pmovus.db.256
llvm.x86.avx512.mask.pmovus.db.512
llvm.x86.avx512.mask.pmovus.db.mem.128
llvm.x86.avx512.mask.pmovus.db.mem.256
llvm.x86.avx512.mask.pmovus.db.mem.512
llvm.x86.avx512.mask.pmovus.dw.128
llvm.x86.avx512.mask.pmovus.dw.256
llvm.x86.avx512.mask.pmovus.dw.512
llvm.x86.avx512.mask.pmovus.dw.mem.128
llvm.x86.avx512.mask.pmovus.dw.mem.256
llvm.x86.avx512.mask.pmovus.dw.mem.512
llvm.x86.avx512.mask.pmovus.qb.128
llvm.x86.avx512.mask.pmovus.qb.256
llvm.x86.avx512.mask.pmovus.qb.512
llvm.x86.avx512.mask.pmovus.qb.mem.128
llvm.x86.avx512.mask.pmovus.qb.mem.256
llvm.x86.avx512.mask.pmovus.qb.mem.512
llvm.x86.avx512.mask.pmovus.qd.128
llvm.x86.avx512.mask.pmovus.qd.256
llvm.x86.avx512.mask.pmovus.qd.512
llvm.x86.avx512.mask.pmovus.qd.mem.128
llvm.x86.avx512.mask.pmovus.qd.mem.256
llvm.x86.avx512.mask.pmovus.qd.mem.512
llvm.x86.avx512.mask.pmovus.qw.128
llvm.x86.avx512.mask.pmovus.qw.256
llvm.x86.avx512.mask.pmovus.qw.512
llvm.x86.avx512.mask.pmovus.qw.mem.128
llvm.x86.avx512.mask.pmovus.qw.mem.256
llvm.x86.avx512.mask.pmovus.qw.mem.512
llvm.x86.avx512.mask.pmovus.wb.128
llvm.x86.avx512.mask.pmovus.wb.256
llvm.x86.avx512.mask.pmovus.wb.512
llvm.x86.avx512.mask.pmovus.wb.mem.128
llvm.x86.avx512.mask.pmovus.wb.mem.256
llvm.x86.avx512.mask.pmovus.wb.mem.512
llvm.x86.avx512.mask.pmultishift.qb.128
llvm.x86.avx512.mask.pmultishift.qb.256
llvm.x86.avx512.mask.pmultishift.qb.512
llvm.x86.avx512.mask.psubs.b.128
llvm.x86.avx512.mask.psubs.b.256
llvm.x86.avx512.mask.psubs.b.512
llvm.x86.avx512.mask.psubs.w.128
llvm.x86.avx512.mask.psubs.w.256
llvm.x86.avx512.mask.psubs.w.512
llvm.x86.avx512.mask.psubus.b.128
llvm.x86.avx512.mask.psubus.b.256
llvm.x86.avx512.mask.psubus.b.512
llvm.x86.avx512.mask.psubus.w.128
llvm.x86.avx512.mask.psubus.w.256
llvm.x86.avx512.mask.psubus.w.512
llvm.x86.avx512.mask.range.pd.128
llvm.x86.avx512.mask.range.pd.256
llvm.x86.avx512.mask.range.pd.512
llvm.x86.avx512.mask.range.ps.128
llvm.x86.avx512.mask.range.ps.256
llvm.x86.avx512.mask.range.ps.512
llvm.x86.avx512.mask.range.sd
llvm.x86.avx512.mask.range.ss
llvm.x86.avx512.mask.reduce.pd.128
llvm.x86.avx512.mask.reduce.pd.256
llvm.x86.avx512.mask.reduce.pd.512
llvm.x86.avx512.mask.reduce.ps.128
llvm.x86.avx512.mask.reduce.ps.256
llvm.x86.avx512.mask.reduce.ps.512
llvm.x86.avx512.mask.reduce.sd
llvm.x86.avx512.mask.reduce.ss
llvm.x86.avx512.mask.rndscale.pd.128
llvm.x86.avx512.mask.rndscale.pd.256
llvm.x86.avx512.mask.rndscale.pd.512
llvm.x86.avx512.mask.rndscale.ps.128
llvm.x86.avx512.mask.rndscale.ps.256
llvm.x86.avx512.mask.rndscale.ps.512
llvm.x86.avx512.mask.rndscale.sd
llvm.x86.avx512.mask.rndscale.ss
llvm.x86.avx512.mask.scalef.pd.128
llvm.x86.avx512.mask.scalef.pd.256
llvm.x86.avx512.mask.scalef.pd.512
llvm.x86.avx512.mask.scalef.ps.128
llvm.x86.avx512.mask.scalef.ps.256
llvm.x86.avx512.mask.scalef.ps.512
llvm.x86.avx512.mask.scalef.sd
llvm.x86.avx512.mask.scalef.ss
llvm.x86.avx512.mask.sqrt.sd
llvm.x86.avx512.mask.sqrt.ss
llvm.x86.avx512.mask.sub.sd.round
llvm.x86.avx512.mask.sub.ss.round
llvm.x86.avx512.mask.vcvtph2ps.128
llvm.x86.avx512.mask.vcvtph2ps.256
llvm.x86.avx512.mask.vcvtph2ps.512
llvm.x86.avx512.mask.vcvtps2ph.128
llvm.x86.avx512.mask.vcvtps2ph.256
llvm.x86.avx512.mask.vcvtps2ph.512
llvm.x86.avx512.mask.vpshldv.d.128
llvm.x86.avx512.mask.vpshldv.d.256
llvm.x86.avx512.mask.vpshldv.d.512
llvm.x86.avx512.mask.vpshldv.q.128
llvm.x86.avx512.mask.vpshldv.q.256
llvm.x86.avx512.mask.vpshldv.q.512
llvm.x86.avx512.mask.vpshldv.w.128
llvm.x86.avx512.mask.vpshldv.w.256
llvm.x86.avx512.mask.vpshldv.w.512
llvm.x86.avx512.mask.vpshrdv.d.128
llvm.x86.avx512.mask.vpshrdv.d.256
llvm.x86.avx512.mask.vpshrdv.d.512
llvm.x86.avx512.mask.vpshrdv.q.128
llvm.x86.avx512.mask.vpshrdv.q.256
llvm.x86.avx512.mask.vpshrdv.q.512
llvm.x86.avx512.mask.vpshrdv.w.128
llvm.x86.avx512.mask.vpshrdv.w.256
llvm.x86.avx512.mask.vpshrdv.w.512
llvm.x86.avx512.mask.vpshufbitqmb.128
llvm.x86.avx512.mask.vpshufbitqmb.256
llvm.x86.avx512.mask.vpshufbitqmb.512
llvm.x86.avx512.maskz.fixupimm.pd.128
llvm.x86.avx512.maskz.fixupimm.pd.256
llvm.x86.avx512.maskz.fixupimm.pd.512
llvm.x86.avx512.maskz.fixupimm.ps.128
llvm.x86.avx512.maskz.fixupimm.ps.256
llvm.x86.avx512.maskz.fixupimm.ps.512
llvm.x86.avx512.maskz.fixupimm.sd
llvm.x86.avx512.maskz.fixupimm.ss
llvm.x86.avx512.maskz.vpshldv.d.128
llvm.x86.avx512.maskz.vpshldv.d.256
llvm.x86.avx512.maskz.vpshldv.d.512
llvm.x86.avx512.maskz.vpshldv.q.128
llvm.x86.avx512.maskz.vpshldv.q.256
llvm.x86.avx512.maskz.vpshldv.q.512
llvm.x86.avx512.maskz.vpshldv.w.128
llvm.x86.avx512.maskz.vpshldv.w.256
llvm.x86.avx512.maskz.vpshldv.w.512
llvm.x86.avx512.maskz.vpshrdv.d.128
llvm.x86.avx512.maskz.vpshrdv.d.256
llvm.x86.avx512.maskz.vpshrdv.d.512
llvm.x86.avx512.maskz.vpshrdv.q.128
llvm.x86.avx512.maskz.vpshrdv.q.256
llvm.x86.avx512.maskz.vpshrdv.q.512
llvm.x86.avx512.maskz.vpshrdv.w.128
llvm.x86.avx512.maskz.vpshrdv.w.256
llvm.x86.avx512.maskz.vpshrdv.w.512
llvm.x86.avx512.max.pd.512
llvm.x86.avx512.max.ps.512
llvm.x86.avx512.min.pd.512
llvm.x86.avx512.min.ps.512
llvm.x86.avx512.mul.pd.512
llvm.x86.avx512.mul.ps.512
llvm.x86.avx512.packssdw.512
llvm.x86.avx512.packsswb.512
llvm.x86.avx512.packusdw.512
llvm.x86.avx512.packuswb.512
llvm.x86.avx512.permvar.df.256
llvm.x86.avx512.permvar.df.512
llvm.x86.avx512.permvar.di.256
llvm.x86.avx512.permvar.di.512
llvm.x86.avx512.permvar.hi.128
llvm.x86.avx512.permvar.hi.256
llvm.x86.avx512.permvar.hi.512
llvm.x86.avx512.permvar.qi.128
llvm.x86.avx512.permvar.qi.256
llvm.x86.avx512.permvar.qi.512
llvm.x86.avx512.permvar.sf.512
llvm.x86.avx512.permvar.si.512
llvm.x86.avx512.pmaddubs.w.512
llvm.x86.avx512.pmaddw.d.512
llvm.x86.avx512.pmul.hr.sw.512
llvm.x86.avx512.pmulh.w.512
llvm.x86.avx512.pmulhu.w.512
llvm.x86.avx512.prol.d.128
llvm.x86.avx512.prol.d.256
llvm.x86.avx512.prol.d.512
llvm.x86.avx512.prol.q.128
llvm.x86.avx512.prol.q.256
llvm.x86.avx512.prol.q.512
llvm.x86.avx512.prolv.d.128
llvm.x86.avx512.prolv.d.256
llvm.x86.avx512.prolv.d.512
llvm.x86.avx512.prolv.q.128
llvm.x86.avx512.prolv.q.256
llvm.x86.avx512.prolv.q.512
llvm.x86.avx512.pror.d.128
llvm.x86.avx512.pror.d.256
llvm.x86.avx512.pror.d.512
llvm.x86.avx512.pror.q.128
llvm.x86.avx512.pror.q.256
llvm.x86.avx512.pror.q.512
llvm.x86.avx512.prorv.d.128
llvm.x86.avx512.prorv.d.256
llvm.x86.avx512.prorv.d.512
llvm.x86.avx512.prorv.q.128
llvm.x86.avx512.prorv.q.256
llvm.x86.avx512.prorv.q.512
llvm.x86.avx512.psad.bw.512
llvm.x86.avx512.pshuf.b.512
llvm.x86.avx512.psll.d.512
llvm.x86.avx512.psll.q.512
llvm.x86.avx512.psll.w.512
llvm.x86.avx512.pslli.d.512
llvm.x86.avx512.pslli.q.512
llvm.x86.avx512.pslli.w.512
llvm.x86.avx512.psllv.d.512
llvm.x86.avx512.psllv.q.512
llvm.x86.avx512.psllv.w.128
llvm.x86.avx512.psllv.w.256
llvm.x86.avx512.psllv.w.512
llvm.x86.avx512.psra.d.512
llvm.x86.avx512.psra.q.128
llvm.x86.avx512.psra.q.256
llvm.x86.avx512.psra.q.512
llvm.x86.avx512.psra.w.512
llvm.x86.avx512.psrai.d.512
llvm.x86.avx512.psrai.q.128
llvm.x86.avx512.psrai.q.256
llvm.x86.avx512.psrai.q.512
llvm.x86.avx512.psrai.w.512
llvm.x86.avx512.psrav.d.512
llvm.x86.avx512.psrav.q.128
llvm.x86.avx512.psrav.q.256
llvm.x86.avx512.psrav.q.512
llvm.x86.avx512.psrav.w.128
llvm.x86.avx512.psrav.w.256
llvm.x86.avx512.psrav.w.512
llvm.x86.avx512.psrl.d.512
llvm.x86.avx512.psrl.q.512
llvm.x86.avx512.psrl.w.512
llvm.x86.avx512.psrli.d.512
llvm.x86.avx512.psrli.q.512
llvm.x86.avx512.psrli.w.512
llvm.x86.avx512.psrlv.d.512
llvm.x86.avx512.psrlv.q.512
llvm.x86.avx512.psrlv.w.128
llvm.x86.avx512.psrlv.w.256
llvm.x86.avx512.psrlv.w.512
llvm.x86.avx512.pternlog.d.128
llvm.x86.avx512.pternlog.d.256
llvm.x86.avx512.pternlog.d.512
llvm.x86.avx512.pternlog.q.128
llvm.x86.avx512.pternlog.q.256
llvm.x86.avx512.pternlog.q.512
llvm.x86.avx512.rcp14.pd.128
llvm.x86.avx512.rcp14.pd.256
llvm.x86.avx512.rcp14.pd.512
llvm.x86.avx512.rcp14.ps.128
llvm.x86.avx512.rcp14.ps.256
llvm.x86.avx512.rcp14.ps.512
llvm.x86.avx512.rcp14.sd
llvm.x86.avx512.rcp14.ss
llvm.x86.avx512.rcp28.pd
llvm.x86.avx512.rcp28.ps
llvm.x86.avx512.rcp28.sd
llvm.x86.avx512.rcp28.ss
llvm.x86.avx512.rsqrt14.pd.128
llvm.x86.avx512.rsqrt14.pd.256
llvm.x86.avx512.rsqrt14.pd.512
llvm.x86.avx512.rsqrt14.ps.128
llvm.x86.avx512.rsqrt14.ps.256
llvm.x86.avx512.rsqrt14.ps.512
llvm.x86.avx512.rsqrt14.sd
llvm.x86.avx512.rsqrt14.ss
llvm.x86.avx512.rsqrt28.pd
llvm.x86.avx512.rsqrt28.ps
llvm.x86.avx512.rsqrt28.sd
llvm.x86.avx512.rsqrt28.ss
llvm.x86.avx512.scatter.dpd.512
llvm.x86.avx512.scatter.dpi.512
llvm.x86.avx512.scatter.dpq.512
llvm.x86.avx512.scatter.dps.512
llvm.x86.avx512.scatter.qpd.512
llvm.x86.avx512.scatter.qpi.512
llvm.x86.avx512.scatter.qpq.512
llvm.x86.avx512.scatter.qps.512
llvm.x86.avx512.scatterdiv2.df
llvm.x86.avx512.scatterdiv2.di
llvm.x86.avx512.scatterdiv4.df
llvm.x86.avx512.scatterdiv4.di
llvm.x86.avx512.scatterdiv4.sf
llvm.x86.avx512.scatterdiv4.si
llvm.x86.avx512.scatterdiv8.sf
llvm.x86.avx512.scatterdiv8.si
llvm.x86.avx512.scatterpf.dpd.512
llvm.x86.avx512.scatterpf.dps.512
llvm.x86.avx512.scatterpf.qpd.512
llvm.x86.avx512.scatterpf.qps.512
llvm.x86.avx512.scattersiv2.df
llvm.x86.avx512.scattersiv2.di
llvm.x86.avx512.scattersiv4.df
llvm.x86.avx512.scattersiv4.di
llvm.x86.avx512.scattersiv4.sf
llvm.x86.avx512.scattersiv4.si
llvm.x86.avx512.scattersiv8.sf
llvm.x86.avx512.scattersiv8.si
llvm.x86.avx512.sqrt.pd.512
llvm.x86.avx512.sqrt.ps.512
llvm.x86.avx512.sub.pd.512
llvm.x86.avx512.sub.ps.512
llvm.x86.avx512.vcomi.sd
llvm.x86.avx512.vcomi.ss
llvm.x86.avx512.vcvtsd2si32
llvm.x86.avx512.vcvtsd2si64
llvm.x86.avx512.vcvtsd2usi32
llvm.x86.avx512.vcvtsd2usi64
llvm.x86.avx512.vcvtss2si32
llvm.x86.avx512.vcvtss2si64
llvm.x86.avx512.vcvtss2usi32
llvm.x86.avx512.vcvtss2usi64
llvm.x86.avx512.vfmadd.f32
llvm.x86.avx512.vfmadd.f64
llvm.x86.avx512.vfmadd.pd.512
llvm.x86.avx512.vfmadd.ps.512
llvm.x86.avx512.vfmaddsub.pd.512
llvm.x86.avx512.vfmaddsub.ps.512
llvm.x86.avx512.vpdpbusd.128
llvm.x86.avx512.vpdpbusd.256
llvm.x86.avx512.vpdpbusd.512
llvm.x86.avx512.vpdpbusds.128
llvm.x86.avx512.vpdpbusds.256
llvm.x86.avx512.vpdpbusds.512
llvm.x86.avx512.vpdpwssd.128
llvm.x86.avx512.vpdpwssd.256
llvm.x86.avx512.vpdpwssd.512
llvm.x86.avx512.vpdpwssds.128
llvm.x86.avx512.vpdpwssds.256
llvm.x86.avx512.vpdpwssds.512
llvm.x86.avx512.vpermi2var.d.128
llvm.x86.avx512.vpermi2var.d.256
llvm.x86.avx512.vpermi2var.d.512
llvm.x86.avx512.vpermi2var.hi.128
llvm.x86.avx512.vpermi2var.hi.256
llvm.x86.avx512.vpermi2var.hi.512
llvm.x86.avx512.vpermi2var.pd.128
llvm.x86.avx512.vpermi2var.pd.256
llvm.x86.avx512.vpermi2var.pd.512
llvm.x86.avx512.vpermi2var.ps.128
llvm.x86.avx512.vpermi2var.ps.256
llvm.x86.avx512.vpermi2var.ps.512
llvm.x86.avx512.vpermi2var.q.128
llvm.x86.avx512.vpermi2var.q.256
llvm.x86.avx512.vpermi2var.q.512
llvm.x86.avx512.vpermi2var.qi.128
llvm.x86.avx512.vpermi2var.qi.256
llvm.x86.avx512.vpermi2var.qi.512
llvm.x86.avx512.vpermilvar.pd.512
llvm.x86.avx512.vpermilvar.ps.512
llvm.x86.avx512.vpmadd52h.uq.128
llvm.x86.avx512.vpmadd52h.uq.256
llvm.x86.avx512.vpmadd52h.uq.512
llvm.x86.avx512.vpmadd52l.uq.128
llvm.x86.avx512.vpmadd52l.uq.256
llvm.x86.avx512.vpmadd52l.uq.512
llvm.x86.avx512.vpshld.d.128
llvm.x86.avx512.vpshld.d.256
llvm.x86.avx512.vpshld.d.512
llvm.x86.avx512.vpshld.q.128
llvm.x86.avx512.vpshld.q.256
llvm.x86.avx512.vpshld.q.512
llvm.x86.avx512.vpshld.w.128
llvm.x86.avx512.vpshld.w.256
llvm.x86.avx512.vpshld.w.512
llvm.x86.avx512.vpshrd.d.128
llvm.x86.avx512.vpshrd.d.256
llvm.x86.avx512.vpshrd.d.512
llvm.x86.avx512.vpshrd.q.128
llvm.x86.avx512.vpshrd.q.256
llvm.x86.avx512.vpshrd.q.512
llvm.x86.avx512.vpshrd.w.128
llvm.x86.avx512.vpshrd.w.256
llvm.x86.avx512.vpshrd.w.512
llvm.x86.bmi.bextr.32
llvm.x86.bmi.bextr.64
llvm.x86.bmi.bzhi.32
llvm.x86.bmi.bzhi.64
llvm.x86.bmi.pdep.32
llvm.x86.bmi.pdep.64
llvm.x86.bmi.pext.32
llvm.x86.bmi.pext.64
llvm.x86.cldemote
llvm.x86.clflushopt
llvm.x86.clrssbsy
llvm.x86.clwb
llvm.x86.clzero
llvm.x86.directstore32
llvm.x86.directstore64
llvm.x86.flags.read.u32
llvm.x86.flags.read.u64
llvm.x86.flags.write.u32
llvm.x86.flags.write.u64
llvm.x86.fxrstor
llvm.x86.fxrstor64
llvm.x86.fxsave
llvm.x86.fxsave64
llvm.x86.incsspd
llvm.x86.incsspq
llvm.x86.int
llvm.x86.invpcid
llvm.x86.llwpcb
llvm.x86.lwpins32
llvm.x86.lwpins64
llvm.x86.lwpval32
llvm.x86.lwpval64
llvm.x86.mmx.emms
llvm.x86.mmx.femms
llvm.x86.mmx.maskmovq
llvm.x86.mmx.movnt.dq
llvm.x86.mmx.packssdw
llvm.x86.mmx.packsswb
llvm.x86.mmx.packuswb
llvm.x86.mmx.padd.b
llvm.x86.mmx.padd.d
llvm.x86.mmx.padd.q
llvm.x86.mmx.padd.w
llvm.x86.mmx.padds.b
llvm.x86.mmx.padds.w
llvm.x86.mmx.paddus.b
llvm.x86.mmx.paddus.w
llvm.x86.mmx.palignr.b
llvm.x86.mmx.pand
llvm.x86.mmx.pandn
llvm.x86.mmx.pavg.b
llvm.x86.mmx.pavg.w
llvm.x86.mmx.pcmpeq.b
llvm.x86.mmx.pcmpeq.d
llvm.x86.mmx.pcmpeq.w
llvm.x86.mmx.pcmpgt.b
llvm.x86.mmx.pcmpgt.d
llvm.x86.mmx.pcmpgt.w
llvm.x86.mmx.pextr.w
llvm.x86.mmx.pinsr.w
llvm.x86.mmx.pmadd.wd
llvm.x86.mmx.pmaxs.w
llvm.x86.mmx.pmaxu.b
llvm.x86.mmx.pmins.w
llvm.x86.mmx.pminu.b
llvm.x86.mmx.pmovmskb
llvm.x86.mmx.pmulh.w
llvm.x86.mmx.pmulhu.w
llvm.x86.mmx.pmull.w
llvm.x86.mmx.pmulu.dq
llvm.x86.mmx.por
llvm.x86.mmx.psad.bw
llvm.x86.mmx.psll.d
llvm.x86.mmx.psll.q
llvm.x86.mmx.psll.w
llvm.x86.mmx.pslli.d
llvm.x86.mmx.pslli.q
llvm.x86.mmx.pslli.w
llvm.x86.mmx.psra.d
llvm.x86.mmx.psra.w
llvm.x86.mmx.psrai.d
llvm.x86.mmx.psrai.w
llvm.x86.mmx.psrl.d
llvm.x86.mmx.psrl.q
llvm.x86.mmx.psrl.w
llvm.x86.mmx.psrli.d
llvm.x86.mmx.psrli.q
llvm.x86.mmx.psrli.w
llvm.x86.mmx.psub.b
llvm.x86.mmx.psub.d
llvm.x86.mmx.psub.q
llvm.x86.mmx.psub.w
llvm.x86.mmx.psubs.b
llvm.x86.mmx.psubs.w
llvm.x86.mmx.psubus.b
llvm.x86.mmx.psubus.w
llvm.x86.mmx.punpckhbw
llvm.x86.mmx.punpckhdq
llvm.x86.mmx.punpckhwd
llvm.x86.mmx.punpcklbw
llvm.x86.mmx.punpckldq
llvm.x86.mmx.punpcklwd
llvm.x86.mmx.pxor
llvm.x86.monitorx
llvm.x86.movdir64b
llvm.x86.mwaitx
llvm.x86.pclmulqdq
llvm.x86.pclmulqdq.256
llvm.x86.pclmulqdq.512
llvm.x86.ptwrite32
llvm.x86.ptwrite64
llvm.x86.rdfsbase.32
llvm.x86.rdfsbase.64
llvm.x86.rdgsbase.32
llvm.x86.rdgsbase.64
llvm.x86.rdpid
llvm.x86.rdpkru
llvm.x86.rdpmc
llvm.x86.rdrand.16
llvm.x86.rdrand.32
llvm.x86.rdrand.64
llvm.x86.rdseed.16
llvm.x86.rdseed.32
llvm.x86.rdseed.64
llvm.x86.rdsspd
llvm.x86.rdsspq
llvm.x86.rdtsc
llvm.x86.rdtscp
llvm.x86.rstorssp
llvm.x86.saveprevssp
llvm.x86.seh.ehguard
llvm.x86.seh.ehregnode
llvm.x86.seh.lsda
llvm.x86.seh.recoverfp
llvm.x86.setssbsy
llvm.x86.sha1msg1
llvm.x86.sha1msg2
llvm.x86.sha1nexte
llvm.x86.sha1rnds4
llvm.x86.sha256msg1
llvm.x86.sha256msg2
llvm.x86.sha256rnds2
llvm.x86.slwpcb
llvm.x86.sse.cmp.ps
llvm.x86.sse.cmp.ss
llvm.x86.sse.comieq.ss
llvm.x86.sse.comige.ss
llvm.x86.sse.comigt.ss
llvm.x86.sse.comile.ss
llvm.x86.sse.comilt.ss
llvm.x86.sse.comineq.ss
llvm.x86.sse.cvtpd2pi
llvm.x86.sse.cvtpi2pd
llvm.x86.sse.cvtpi2ps
llvm.x86.sse.cvtps2pi
llvm.x86.sse.cvtss2si
llvm.x86.sse.cvtss2si64
llvm.x86.sse.cvttpd2pi
llvm.x86.sse.cvttps2pi
llvm.x86.sse.cvttss2si
llvm.x86.sse.cvttss2si64
llvm.x86.sse.ldmxcsr
llvm.x86.sse.max.ps
llvm.x86.sse.max.ss
llvm.x86.sse.min.ps
llvm.x86.sse.min.ss
llvm.x86.sse.movmsk.ps
llvm.x86.sse.pshuf.w
llvm.x86.sse.rcp.ps
llvm.x86.sse.rcp.ss
llvm.x86.sse.rsqrt.ps
llvm.x86.sse.rsqrt.ss
llvm.x86.sse.sfence
llvm.x86.sse.stmxcsr
llvm.x86.sse.ucomieq.ss
llvm.x86.sse.ucomige.ss
llvm.x86.sse.ucomigt.ss
llvm.x86.sse.ucomile.ss
llvm.x86.sse.ucomilt.ss
llvm.x86.sse.ucomineq.ss
llvm.x86.sse2.clflush
llvm.x86.sse2.cmp.pd
llvm.x86.sse2.cmp.sd
llvm.x86.sse2.comieq.sd
llvm.x86.sse2.comige.sd
llvm.x86.sse2.comigt.sd
llvm.x86.sse2.comile.sd
llvm.x86.sse2.comilt.sd
llvm.x86.sse2.comineq.sd
llvm.x86.sse2.cvtpd2dq
llvm.x86.sse2.cvtpd2ps
llvm.x86.sse2.cvtps2dq
llvm.x86.sse2.cvtsd2si
llvm.x86.sse2.cvtsd2si64
llvm.x86.sse2.cvtsd2ss
llvm.x86.sse2.cvttpd2dq
llvm.x86.sse2.cvttps2dq
llvm.x86.sse2.cvttsd2si
llvm.x86.sse2.cvttsd2si64
llvm.x86.sse2.lfence
llvm.x86.sse2.maskmov.dqu
llvm.x86.sse2.max.pd
llvm.x86.sse2.max.sd
llvm.x86.sse2.mfence
llvm.x86.sse2.min.pd
llvm.x86.sse2.min.sd
llvm.x86.sse2.movmsk.pd
llvm.x86.sse2.packssdw.128
llvm.x86.sse2.packsswb.128
llvm.x86.sse2.packuswb.128
llvm.x86.sse2.padds.b
llvm.x86.sse2.padds.w
llvm.x86.sse2.paddus.b
llvm.x86.sse2.paddus.w
llvm.x86.sse2.pause
llvm.x86.sse2.pmadd.wd
llvm.x86.sse2.pmovmskb.128
llvm.x86.sse2.pmulh.w
llvm.x86.sse2.pmulhu.w
llvm.x86.sse2.psad.bw
llvm.x86.sse2.psll.d
llvm.x86.sse2.psll.q
llvm.x86.sse2.psll.w
llvm.x86.sse2.pslli.d
llvm.x86.sse2.pslli.q
llvm.x86.sse2.pslli.w
llvm.x86.sse2.psra.d
llvm.x86.sse2.psra.w
llvm.x86.sse2.psrai.d
llvm.x86.sse2.psrai.w
llvm.x86.sse2.psrl.d
llvm.x86.sse2.psrl.q
llvm.x86.sse2.psrl.w
llvm.x86.sse2.psrli.d
llvm.x86.sse2.psrli.q
llvm.x86.sse2.psrli.w
llvm.x86.sse2.psubs.b
llvm.x86.sse2.psubs.w
llvm.x86.sse2.psubus.b
llvm.x86.sse2.psubus.w
llvm.x86.sse2.ucomieq.sd
llvm.x86.sse2.ucomige.sd
llvm.x86.sse2.ucomigt.sd
llvm.x86.sse2.ucomile.sd
llvm.x86.sse2.ucomilt.sd
llvm.x86.sse2.ucomineq.sd
llvm.x86.sse3.addsub.pd
llvm.x86.sse3.addsub.ps
llvm.x86.sse3.hadd.pd
llvm.x86.sse3.hadd.ps
llvm.x86.sse3.hsub.pd
llvm.x86.sse3.hsub.ps
llvm.x86.sse3.ldu.dq
llvm.x86.sse3.monitor
llvm.x86.sse3.mwait
llvm.x86.sse41.blendvpd
llvm.x86.sse41.blendvps
llvm.x86.sse41.dppd
llvm.x86.sse41.dpps
llvm.x86.sse41.insertps
llvm.x86.sse41.mpsadbw
llvm.x86.sse41.packusdw
llvm.x86.sse41.pblendvb
llvm.x86.sse41.phminposuw
llvm.x86.sse41.ptestc
llvm.x86.sse41.ptestnzc
llvm.x86.sse41.ptestz
llvm.x86.sse41.round.pd
llvm.x86.sse41.round.ps
llvm.x86.sse41.round.sd
llvm.x86.sse41.round.ss
llvm.x86.sse42.crc32.32.16
llvm.x86.sse42.crc32.32.32
llvm.x86.sse42.crc32.32.8
llvm.x86.sse42.crc32.64.64
llvm.x86.sse42.pcmpestri128
llvm.x86.sse42.pcmpestria128
llvm.x86.sse42.pcmpestric128
llvm.x86.sse42.pcmpestrio128
llvm.x86.sse42.pcmpestris128
llvm.x86.sse42.pcmpestriz128
llvm.x86.sse42.pcmpestrm128
llvm.x86.sse42.pcmpistri128
llvm.x86.sse42.pcmpistria128
llvm.x86.sse42.pcmpistric128
llvm.x86.sse42.pcmpistrio128
llvm.x86.sse42.pcmpistris128
llvm.x86.sse42.pcmpistriz128
llvm.x86.sse42.pcmpistrm128
llvm.x86.sse4a.extrq
llvm.x86.sse4a.extrqi
llvm.x86.sse4a.insertq
llvm.x86.sse4a.insertqi
llvm.x86.ssse3.pabs.b
llvm.x86.ssse3.pabs.d
llvm.x86.ssse3.pabs.w
llvm.x86.ssse3.phadd.d
llvm.x86.ssse3.phadd.d.128
llvm.x86.ssse3.phadd.sw
llvm.x86.ssse3.phadd.sw.128
llvm.x86.ssse3.phadd.w
llvm.x86.ssse3.phadd.w.128
llvm.x86.ssse3.phsub.d
llvm.x86.ssse3.phsub.d.128
llvm.x86.ssse3.phsub.sw
llvm.x86.ssse3.phsub.sw.128
llvm.x86.ssse3.phsub.w
llvm.x86.ssse3.phsub.w.128
llvm.x86.ssse3.pmadd.ub.sw
llvm.x86.ssse3.pmadd.ub.sw.128
llvm.x86.ssse3.pmul.hr.sw
llvm.x86.ssse3.pmul.hr.sw.128
llvm.x86.ssse3.pshuf.b
llvm.x86.ssse3.pshuf.b.128
llvm.x86.ssse3.psign.b
llvm.x86.ssse3.psign.b.128
llvm.x86.ssse3.psign.d
llvm.x86.ssse3.psign.d.128
llvm.x86.ssse3.psign.w
llvm.x86.ssse3.psign.w.128
llvm.x86.subborrow.u32
llvm.x86.subborrow.u64
llvm.x86.tbm.bextri.u32
llvm.x86.tbm.bextri.u64
llvm.x86.tpause
llvm.x86.umonitor
llvm.x86.umwait
llvm.x86.vcvtph2ps.128
llvm.x86.vcvtph2ps.256
llvm.x86.vcvtps2ph.128
llvm.x86.vcvtps2ph.256
llvm.x86.vgf2p8affineinvqb.128
llvm.x86.vgf2p8affineinvqb.256
llvm.x86.vgf2p8affineinvqb.512
llvm.x86.vgf2p8affineqb.128
llvm.x86.vgf2p8affineqb.256
llvm.x86.vgf2p8affineqb.512
llvm.x86.vgf2p8mulb.128
llvm.x86.vgf2p8mulb.256
llvm.x86.vgf2p8mulb.512
llvm.x86.wbinvd
llvm.x86.wbnoinvd
llvm.x86.wrfsbase.32
llvm.x86.wrfsbase.64
llvm.x86.wrgsbase.32
llvm.x86.wrgsbase.64
llvm.x86.wrpkru
llvm.x86.wrssd
llvm.x86.wrssq
llvm.x86.wrussd
llvm.x86.wrussq
llvm.x86.xabort
llvm.x86.xbegin
llvm.x86.xend
llvm.x86.xgetbv
llvm.x86.xop.vfrcz.pd
llvm.x86.xop.vfrcz.pd.256
llvm.x86.xop.vfrcz.ps
llvm.x86.xop.vfrcz.ps.256
llvm.x86.xop.vfrcz.sd
llvm.x86.xop.vfrcz.ss
llvm.x86.xop.vpcomb
llvm.x86.xop.vpcomd
llvm.x86.xop.vpcomq
llvm.x86.xop.vpcomub
llvm.x86.xop.vpcomud
llvm.x86.xop.vpcomuq
llvm.x86.xop.vpcomuw
llvm.x86.xop.vpcomw
llvm.x86.xop.vpermil2pd
llvm.x86.xop.vpermil2pd.256
llvm.x86.xop.vpermil2ps
llvm.x86.xop.vpermil2ps.256
llvm.x86.xop.vphaddbd
llvm.x86.xop.vphaddbq
llvm.x86.xop.vphaddbw
llvm.x86.xop.vphadddq
llvm.x86.xop.vphaddubd
llvm.x86.xop.vphaddubq
llvm.x86.xop.vphaddubw
llvm.x86.xop.vphaddudq
llvm.x86.xop.vphadduwd
llvm.x86.xop.vphadduwq
llvm.x86.xop.vphaddwd
llvm.x86.xop.vphaddwq
llvm.x86.xop.vphsubbw
llvm.x86.xop.vphsubdq
llvm.x86.xop.vphsubwd
llvm.x86.xop.vpmacsdd
llvm.x86.xop.vpmacsdqh
llvm.x86.xop.vpmacsdql
llvm.x86.xop.vpmacssdd
llvm.x86.xop.vpmacssdqh
llvm.x86.xop.vpmacssdql
llvm.x86.xop.vpmacsswd
llvm.x86.xop.vpmacssww
llvm.x86.xop.vpmacswd
llvm.x86.xop.vpmacsww
llvm.x86.xop.vpmadcsswd
llvm.x86.xop.vpmadcswd
llvm.x86.xop.vpperm
llvm.x86.xop.vprotb
llvm.x86.xop.vprotbi
llvm.x86.xop.vprotd
llvm.x86.xop.vprotdi
llvm.x86.xop.vprotq
llvm.x86.xop.vprotqi
llvm.x86.xop.vprotw
llvm.x86.xop.vprotwi
llvm.x86.xop.vpshab
llvm.x86.xop.vpshad
llvm.x86.xop.vpshaq
llvm.x86.xop.vpshaw
llvm.x86.xop.vpshlb
llvm.x86.xop.vpshld
llvm.x86.xop.vpshlq
llvm.x86.xop.vpshlw
llvm.x86.xrstor
llvm.x86.xrstor64
llvm.x86.xrstors
llvm.x86.xrstors64
llvm.x86.xsave
llvm.x86.xsave64
llvm.x86.xsavec
llvm.x86.xsavec64
llvm.x86.xsaveopt
llvm.x86.xsaveopt64
llvm.x86.xsaves
llvm.x86.xsaves64
llvm.x86.xsetbv
llvm.x86.xtest
llvm.xcore.bitrev
llvm.xcore.checkevent
llvm.xcore.chkct
llvm.xcore.clre
llvm.xcore.clrpt
llvm.xcore.clrsr
llvm.xcore.crc32
llvm.xcore.crc8
llvm.xcore.edu
llvm.xcore.eeu
llvm.xcore.endin
llvm.xcore.freer
llvm.xcore.geted
llvm.xcore.getet
llvm.xcore.getid
llvm.xcore.getps
llvm.xcore.getr
llvm.xcore.getst
llvm.xcore.getts
llvm.xcore.in
llvm.xcore.inct
llvm.xcore.initcp
llvm.xcore.initdp
llvm.xcore.initlr
llvm.xcore.initpc
llvm.xcore.initsp
llvm.xcore.inshr
llvm.xcore.int
llvm.xcore.mjoin
llvm.xcore.msync
llvm.xcore.out
llvm.xcore.outct
llvm.xcore.outshr
llvm.xcore.outt
llvm.xcore.peek
llvm.xcore.setc
llvm.xcore.setclk
llvm.xcore.setd
llvm.xcore.setev
llvm.xcore.setps
llvm.xcore.setpsc
llvm.xcore.setpt
llvm.xcore.setrdy
llvm.xcore.setsr
llvm.xcore.settw
llvm.xcore.setv
llvm.xcore.sext
llvm.xcore.ssync
llvm.xcore.syncr
llvm.xcore.testct
llvm.xcore.testwct
llvm.xcore.waitevent
llvm.xcore.zext
sinf
sinl
cosf
sqrtl
floorf
Convert load/store on doubles into store/loads on i32 or float types
WAFMinFMax
igc-advmemopt
llvm.metadata
11ocl_image3d
AlignmentAnalysisPass
simdGetMessagePhaseV@
USAGE: missing platform string. 
number
string
7.0.0
