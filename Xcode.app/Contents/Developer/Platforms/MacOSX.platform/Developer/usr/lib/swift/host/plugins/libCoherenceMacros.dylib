ySay
SaySSG
ySSG
ySay
_SS4nametSg
_SS4namet
CoherenceMacros
Mergeable
MergeableIVar
    var unknownProperties = UnknownProperties()
struct ObservableDifference
.ObservableDifference?
struct MutatingAction
.MutatingAction?
struct Partial: PartialCRDT
    }
    mutating func merge(delta: Self) -> Bool {
      guard canMerge(delta: delta) else { return false }
      return true
    }
    func canMerge(delta: Self) -> Bool {
      if let otherField = delta.
?.canMerge(delta: otherField) == false { return false }
      return true
    }
    func visitReferences(_ visitor: ReferenceVisitor) {
?.visitReferences(visitor)
    }
    init(from decoder: CRDecoder) throws {
      fatalError()
    }
    func encode(to encoder: CREncoder) throws {
      fatalError()
    }
 != nil, let other = delta.
?.merge(delta: other)
      }
      else {
        
mutating func merge(_ other: Self)
    unknownProperties.merge(other.unknownProperties)
func actionUndoingDifference(from other: Self) -> MutatingAction?
.actionUndoingDifference(from: other.
        
    if
    {
      return MutatingAction(
    }
    return nil
mutating func apply(_ action: MutatingAction?)
    guard let action else { return }
func hasDelta(from other: Self) -> Bool
.hasDelta(from: other.
) { return true }
    return unknownProperties.hasDelta(from: other.unknownProperties)
func copy(renamingReferences: [CRKeyPath:CRKeyPath]? = nil) -> Self
    var copy = self
.copy(renamingReferences: renamingReferences)
    copy.unknownProperties = unknownProperties.copy(renamingReferences: renamingReferences)
    return copy
func visitReferences(_ visitor: ReferenceVisitor)
.visitReferences(visitor)
    unknownProperties.visitReferences(visitor)
.needToFinalizeTimestamps() ||
func needToFinalizeTimestamps() -> Bool
      unknownProperties.needToFinalizeTimestamps()
.finalizeTimestamps(context)
mutating func finalizeTimestamps(_ context: CRContext)
    unknownProperties.finalizeTimestamps(context)
var minEncodingVersion: CRCodableVersion
    var version = unknownProperties.minEncodingVersion
    if version == .version3 { return version }
    version = max(version, 
.minEncodingVersion)
    return version
.observableDifference(from: other.
, with: referenceDifferencer)
    {
      return ObservableDifference(
func observableDifference(from other: Self, with referenceDifferencer: ReferenceDifferencer?) -> ObservableDifference?
    let container = try encoder.keyedContainer()
    try container.encode(
func encode(to encoder: CREncoder) throws
    try unknownProperties.encode(to: container)
init(from decoder: CRDecoder) throws
    let container = try decoder.keyedContainer()
    
    
    var allKeys = try Set(container.allKeys())
    allKeys.remove("
    
    let keysAndValues = try allKeys.compactMap {
      if let subdecoder = container.decoder(forKey: $0) {
        return ($0, try AnyCRDT(from: subdecoder))
      }
      return nil
    }
    unknownProperties = UnknownProperties(try Dictionary(keysAndValues, uniquingKeysWith: { _, _ in
      throw CRCodingError.malformedData("Duplicate key decoding '
    if let subdecoder = container.decoder(forKey: "
(from: subdecoder)
    }
    else {
      throw CRCodingError.malformedData("Missing value for '
.delta(context, from: other.
    {
      return Partial(
func delta(_ context: CRContext, from other: Self) -> Partial?
    if let otherField = delta.
.canMerge(delta: otherField) { return false }
func canMerge(delta: Partial) -> Bool
    return true
    guard canMerge(delta: delta) else { return false }
.merge(delta: otherField) }
mutating func merge(delta: Partial) -> Bool
future reported an error, but wait cannot throw
swift_task_escalate
_Z19voucher_needs_adoptP9voucher_s
__tsan_acquire
__tsan_release
swift_task_enterThreadLocalContext
swift_task_exitThreadLocalContext
name
ivar
typeName
hasInitializer
CoherenceMacros
Mergeable
MergeableIVar
ySay
SaySSG
ySSG
ySay
_SS4nametSg
_SS4namet
    var unknownProperties = UnknownProperties()
struct ObservableDifference
.ObservableDifference?
struct MutatingAction
.MutatingAction?
struct Partial: PartialCRDT
    }
    mutating func merge(delta: Self) -> Bool {
      guard canMerge(delta: delta) else { return false }
      return true
    }
    func canMerge(delta: Self) -> Bool {
      if let otherField = delta.
?.canMerge(delta: otherField) == false { return false }
      return true
    }
    func visitReferences(_ visitor: ReferenceVisitor) {
?.visitReferences(visitor)
    }
    init(from decoder: CRDecoder) throws {
      fatalError()
    }
    func encode(to encoder: CREncoder) throws {
      fatalError()
    }
 != nil, let other = delta.
?.merge(delta: other)
      }
      else {
        
mutating func merge(_ other: Self)
    unknownProperties.merge(other.unknownProperties)
func actionUndoingDifference(from other: Self) -> MutatingAction?
.actionUndoingDifference(from: other.
        
    if
    {
      return MutatingAction(
    }
    return nil
mutating func apply(_ action: MutatingAction?)
    guard let action else { return }
func hasDelta(from other: Self) -> Bool
.hasDelta(from: other.
) { return true }
    return unknownProperties.hasDelta(from: other.unknownProperties)
func copy(renamingReferences: [CRKeyPath:CRKeyPath]? = nil) -> Self
    var copy = self
.copy(renamingReferences: renamingReferences)
    copy.unknownProperties = unknownProperties.copy(renamingReferences: renamingReferences)
    return copy
func visitReferences(_ visitor: ReferenceVisitor)
.visitReferences(visitor)
    unknownProperties.visitReferences(visitor)
.needToFinalizeTimestamps() ||
func needToFinalizeTimestamps() -> Bool
      unknownProperties.needToFinalizeTimestamps()
.finalizeTimestamps(context)
mutating func finalizeTimestamps(_ context: CRContext)
    unknownProperties.finalizeTimestamps(context)
var minEncodingVersion: CRCodableVersion
    var version = unknownProperties.minEncodingVersion
    if version == .version3 { return version }
    version = max(version, 
.minEncodingVersion)
    return version
.observableDifference(from: other.
, with: referenceDifferencer)
    {
      return ObservableDifference(
func observableDifference(from other: Self, with referenceDifferencer: ReferenceDifferencer?) -> ObservableDifference?
    let container = try encoder.keyedContainer()
    try container.encode(
func encode(to encoder: CREncoder) throws
    try unknownProperties.encode(to: container)
init(from decoder: CRDecoder) throws
    let container = try decoder.keyedContainer()
    
    
    var allKeys = try Set(container.allKeys())
    allKeys.remove("
    
    let keysAndValues = try allKeys.compactMap {
      if let subdecoder = container.decoder(forKey: $0) {
        return ($0, try AnyCRDT(from: subdecoder))
      }
      return nil
    }
    unknownProperties = UnknownProperties(try Dictionary(keysAndValues, uniquingKeysWith: { _, _ in
      throw CRCodingError.malformedData("Duplicate key decoding '
    if let subdecoder = container.decoder(forKey: "
(from: subdecoder)
    }
    else {
      throw CRCodingError.malformedData("Missing value for '
.delta(context, from: other.
    {
      return Partial(
func delta(_ context: CRContext, from other: Self) -> Partial?
    if let otherField = delta.
.canMerge(delta: otherField) { return false }
func canMerge(delta: Partial) -> Bool
    return true
    guard canMerge(delta: delta) else { return false }
.merge(delta: otherField) }
mutating func merge(delta: Partial) -> Bool
future reported an error, but wait cannot throw
swift_task_escalate
_Z19voucher_needs_adoptP9voucher_s
__tsan_acquire
__tsan_release
swift_task_enterThreadLocalContext
swift_task_exitThreadLocalContext
name
ivar
typeName
hasInitializer
