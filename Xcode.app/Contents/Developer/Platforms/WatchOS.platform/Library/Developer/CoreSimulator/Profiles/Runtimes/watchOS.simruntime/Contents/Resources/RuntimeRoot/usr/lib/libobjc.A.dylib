*** NXCreateHashTable: invalid style
*** NXCreateHashTable: bug
*** hashtable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isEqual(x, y) is TRUE but hash(x) != hash (y)
*** NXCreateMapTable: invalid creation parameters
*** NXMapInsert: invalid key: -1
**** NXMapInsert: bug
**** NXMapRemove: incorrect table
**** NXMapRemove: bug
NXMapTable %p (%p) has invalid key/value pair %p->%p (%p)
table %p, buckets %p, count %u, nbNucketsMinusOne %u, prototype %p (hash %p, isEqual %p, free %p)
%u invalid keys in table
*** maptable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isEqual(x, y) is TRUE but hash(x) != hash (y)
CACHES: new empty buckets at %p (capacity %zu)
Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.
%s %p, SEL %p, isa %p, cache %p, buckets %p, mask 0x%x, occupied 0x%x
receiver
unused
%s %zu bytes, buckets %zu bytes
selector '%s'
isa '%s'
CACHES: not collecting; objc_msgSend in progress
CACHES: COLLECTING %zu bytes (%zu allocations, %zu collections)
CACHES: %4d slots: %4d caches, %6zu bytes
CACHES:      total: %4zu caches, %6zu bytes
task_threads failed (result 0x%x)
CXX: calling C++ constructors for class %s
class_respondsToMethod
class_lookupMethod
invalid selector (null)
__objc_dupclass
Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.
"%s"%s,
%s%s,
CXX: calling C++ destructors for class %s
objc[%d]: %s
The function %s is obsolete. Do not use it. Set a breakpoint on _objc_warn_deprecated to find the culprit.
objc[%d]: HALTED
... %s
unexpected call into objc exception typeinfo vtable %d
EXCEPTIONS: %s through frame [ip=%p sp=%p] for exception %p
unwinding
searching
EXCEPTIONS: throwing %p (object %p, a %s)
EXCEPTIONS: rethrowing current exception
EXCEPTIONS: handling exception %p at %p
EXCEPTIONS: finishing handler
EXCEPTIONS: skipping catch(?)
EXCEPTIONS: catch(id)
EXCEPTIONS: catch(%s)
EXCEPTIONS: skipping catch(%s)
EXCEPTIONS: releasing completed exception %p (object %p, a %s)
EXCEPTIONS: terminating
__objc_selrefs
__objc_msgrefs
__objc_classrefs
__objc_superrefs
__objc_classlist
__objc_stublist
__objc_nlclslist
__objc_catlist
__objc_catlist2
__objc_nlcatlist
__objc_protolist
__objc_protorefs
__objc_init_func
__objc_init_offs
__objc_imageinfo
INITIALIZE: thread %p: blocking until +[%s initialize] completes
INITIALIZE: thread %p: skipping trivial +[%s initialize] in fork() child process
INITIALIZE: thread %p: refusing to call +[%s initialize] in fork() child process because it may have been in progress when fork() was called
+[%s initialize] may have been in progress in another thread when fork() was called.
+[%s initialize] may have been in progress in another thread when fork() was called. We cannot safely call it or ignore it in the fork() child process. Crashing instead. Set a breakpoint on objc_initializeAfterForkError to debug.
INITIALIZE: thread %p: calling +[%s initialize]
INITIALIZE: thread %p: finished +[%s initialize]
INITIALIZE: thread %p: +[%s initialize] threw an exception
thread-safe class init in objc runtime is buggy!
pthread_mutex_lock failed (%d)
pthread_mutex_unlock failed (%d)
INITIALIZE: thread %p: %s is fully +initialized
pthread_cond_broadcast failed (%d)
thread is not initializing this class!
INITIALIZE: thread %p: class %s will be marked as fully +initialized after superclass +[%s initialize] completes
thread is already initializing this class!
pthread_cond_wait failed (%d)
LOAD: class '%s' scheduled for +load
LOAD: category '%s(%s)' scheduled for +load
LOAD: class '%s' unscheduled for +load
LOAD: category '%s(%s)' unscheduled for +load
LOAD: +[%s load]
LOAD: +[%s(%s) load]
LOAD: %d categories still waiting for +load
Swift requested that class %p be ignored, but libobjc does not support that.
FUTURE: found %p already in use for %s
_objc_flush_caches
B16@?0#8
the image is for iOS simulator
PREOPTIMIZATION: reading classes manually from %s because %s
CLASS: found %d classes during launch
IMAGE TIMES: first time tasks
IMAGE TIMES: fix up selector references
IMAGE TIMES: discover classes
IMAGE TIMES: remap classes
VTABLES: repairing %zu unsupported vtable dispatch call sites in %s
IMAGE TIMES: fix up objc_msgSend_fixup
PROTOCOLS: Skipping reading protocols in image: %s
IMAGE TIMES: discover protocols
IMAGE TIMES: fix up @protocol references
IMAGE TIMES: discover categories
Swift class %s with a metadata initializer is not allowed to be non-lazy
IMAGE TIMES: realize non-lazy classes
Swift class is not allowed to be future
IMAGE TIMES: realize future classes
PREOPTIMIZATION: honoring preoptimized selectors in %s
PREOPTIMIZATION: IGNORING preoptimized selectors in %s
PREOPTIMIZATION: %zu selector references not pre-optimized
PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted
PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered
PREOPTIMIZATION: %zu protocol references not pre-optimized
Swift class extensions and categories on Swift classes are not allowed to have +load methods
method_exchangeImplementations
objc_registerProtocol: protocol '%s' was already registered!
objc_registerProtocol: protocol '%s' was not allocated with objc_allocateProtocol!
protocol_addProtocol: modified protocol '%s' is not under construction!
protocol_addProtocol: added protocol '%s' is still under construction!
protocol_addMethodDescription: protocol '%s' is not under construction!
protocol_addProperty: protocol '%s' is not under construction!
<stub class %p>
<lazily named class %p>
Memory corruption in class list.
INITIALIZE: thread %p: setInitialized(%s)
RAW ISA:  %s%s%s
 (meta)
 (inherited)
Lazily named class %p with no lazy name handler registered
Lazily named class %p wasn't named by lazy name handler
*** Can't set ivar layout for already-registered class '%s'
*** Can't set weak ivar layout for already-registered class '%s'
CLASS: realizing class '%s' (duplicate of %s) %p %p
objc_registerClassPair: class '%s' was already registered!
objc_registerClassPair: class '%s' was not allocated with objc_allocateClassPair!
objc_readClassPair for class %s changed %p to %p
objc_disposeClassPair: class '%s' was not allocated with objc_allocateClassPair!
objc_disposeClassPair: class '%s' is a metaclass, not a class!
objc_disposeClassPair: class '%s' still has subclasses, including '%s'!
tagged pointers are disabled
tag index %u is invalid
tag index %u used for two different classes (was %p %s, now %p %s)
INITIALIZE: %d/%d (%g%%) successful by-name metaclass lookups
INITIALIZE: %d/%d (%g%%) successful secondary metaclass lookups
INITIALIZE: %d/%d (%g%%) successful shared cache metaclass lookups
INITIALIZE: %d/%d (%g%%) successful dyld closure metaclass lookups
no class for metaclass %p
FUTURE: using %p instead of %p for %s
CLASS: realizing class '%s'%s %p %p #%u %s%s
(swift)
(pre-stable swift)
NSCF
__CF
NSConstantString
NSSimpleCString
IVARS: DEBUG: forcing ivars for class '%s' to slide (instanceStart %zu -> %zu)
IVARS: sliding ivars for class %s (superclass was %u bytes, now %u)
IVARS:    offset %u -> %u for %s (size %u, align %u)
CLASS: methodizing class '%s' %s
(meta)
CUSTOM AWZ
CUSTOM RR
CUSTOM Core
%s: %s%s%s
CLASS: attaching %d categories to%s class '%s'%s
 existing
attachCategories
FUTURE: reserving %p for %s
CLASS: IGNORING class '%s' with missing weak-linked superclass
Can't complete future class request for '%s' because the real class is too big.
%.2f ms: %s
PROTOCOLS: protocol at %p is %s  (duplicate of %p)
PROTOCOLS: protocol at %p is %s
CLASS: IGNORING category ???(%s) %p with missing weak-linked target class
CLASS: found category %c%s(%s)
CLASS: calling Swift metadata initializer for class '%s' (%p)
_method_setImplementation
_TtP
_TtC
Swift
%.*s.%.*s
_Tt%cs%zu%.*s%s
_Tt%c%zu%.*s%zu%.*s%s
Attempt to use unknown class %p.
RESOLVE: method %c[%s %s] dynamically resolved to %p
RESOLVE: +[%s resolveInstanceMethod:%s] returned YES, but no new implementation of %c[%s %s] was found
nonmeta class %s (%p) unexpectedly not realized
RESOLVE: +[%s resolveClassMethod:%s] returned YES, but no new implementation of %c[%s %s] was found
addMethods_finish
setSuperclass
_TtCs12_SwiftObject
link error: class '%s' not found.
class `%s' not linked into application
Cannot find range %#lx..%#lx
objc4
classRxSigning
classRoSigningFaults
Malloc
DYLD
NSZombiesEnabled
OBJC_
OBJC_HELP=
OBJC_PRINT_OPTIONS=
OBJC_DEBUG_POOL_DEPTH=
DYLD_INSERT_LIBRARIES
OBJC_DEBUG_POOL_ALLOCATION
MallocStackLogging
MallocStackLoggingNoCompact
libgmalloc
preoptimizedCaches
Objective-C runtime debugging. Set variable=YES to enable.
OBJC_HELP: describe available environment variables
OBJC_HELP is set
OBJC_PRINT_OPTIONS: list which options are set
OBJC_PRINT_OPTIONS is set
%s: %s
%s is set
REPLACED: %c[%s %s]  %s%s  (IMP was %p (%s), now %p (%s))
by category 
%c[%s %s]: unrecognized selector sent to instance %p (no message forward handler is installed)
mutation detected during 'for(... in ...)'  enumeration of object %p.
OBJC_PRINT_IMAGES
log image and library names as they are loaded
OBJC_PRINT_IMAGE_TIMES
measure duration of image loading steps
OBJC_PRINT_LOAD_METHODS
log calls to class and category +load methods
OBJC_PRINT_INITIALIZE_METHODS
log calls to class +initialize methods
OBJC_PRINT_RESOLVED_METHODS
log methods created by +resolveClassMethod: and +resolveInstanceMethod:
OBJC_PRINT_CLASS_SETUP
log progress of class and category setup
OBJC_PRINT_PROTOCOL_SETUP
log progress of protocol setup
OBJC_PRINT_IVAR_SETUP
log processing of non-fragile ivars
OBJC_PRINT_VTABLE_SETUP
log processing of class vtables
OBJC_PRINT_VTABLE_IMAGES
print vtable images showing overridden methods
OBJC_PRINT_CACHE_SETUP
log processing of method caches
OBJC_PRINT_FUTURE_CLASSES
log use of future classes for toll-free bridging
OBJC_PRINT_PREOPTIMIZATION
log preoptimization courtesy of dyld shared cache
OBJC_PRINT_CXX_CTORS
log calls to C++ ctors and dtors for instance variables
OBJC_PRINT_EXCEPTIONS
log exception handling
OBJC_PRINT_EXCEPTION_THROW
log backtrace of every objc_exception_throw()
OBJC_PRINT_ALT_HANDLERS
log processing of exception alt handlers
OBJC_PRINT_REPLACED_METHODS
log methods replaced by category implementations
OBJC_PRINT_DEPRECATION_WARNINGS
warn about calls to deprecated runtime functions
OBJC_PRINT_POOL_HIGHWATER
log high-water marks for autorelease pools
OBJC_PRINT_CUSTOM_CORE
log classes with custom core methods
OBJC_PRINT_CUSTOM_RR
log classes with custom retain/release methods
OBJC_PRINT_CUSTOM_AWZ
log classes with custom allocWithZone methods
OBJC_PRINT_RAW_ISA
log classes that require raw pointer isa fields
OBJC_DEBUG_UNLOAD
warn about poorly-behaving bundles when unloaded
OBJC_DEBUG_FRAGILE_SUPERCLASSES
warn about subclasses that may have been broken by subsequent changes to superclasses
OBJC_DEBUG_NIL_SYNC
warn about @synchronized(nil), which does no synchronization
OBJC_DEBUG_NONFRAGILE_IVARS
capriciously rearrange non-fragile ivars
OBJC_DEBUG_ALT_HANDLERS
record more info about bad alt handler use
OBJC_DEBUG_MISSING_POOLS
warn about autorelease with no pool in place, which may be a leak
halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools
OBJC_DEBUG_DUPLICATE_CLASSES
halt when multiple classes with the same name are present
OBJC_DEBUG_DONT_CRASH
halt the process by exiting instead of crashing
OBJC_DEBUG_POOL_DEPTH
log fault when at least a set number of autorelease pages has been allocated
OBJC_DEBUG_SCRIBBLE_CACHES
scribble the IMPs in freed method caches
OBJC_DEBUG_SCAN_WEAK_TABLES
scan the weak references table continuously in the background - set OBJC_DEBUG_SCAN_WEAK_TABLES_INTERVAL_NANOSECONDS to set scanning interval (default 1000000)
OBJC_DISABLE_VTABLES
disable vtable dispatch
OBJC_DISABLE_PREOPTIMIZATION
disable preoptimization courtesy of dyld shared cache
OBJC_DISABLE_TAGGED_POINTERS
disable tagged pointer optimization of NSNumber et al.
OBJC_DISABLE_TAG_OBFUSCATION
disable obfuscation of tagged pointers
OBJC_DISABLE_NONPOINTER_ISA
disable non-pointer isa fields
OBJC_DISABLE_INITIALIZE_FORK_SAFETY
disable safety checks for +initialize after fork
OBJC_DISABLE_FAULTS
disable os faults
OBJC_DISABLE_PREOPTIMIZED_CACHES
disable preoptimized caches
OBJC_DISABLE_AUTORELEASE_COALESCING
disable coalescing of autorelease pool pointers
OBJC_DISABLE_AUTORELEASE_COALESCING_LRU
disable coalescing of autorelease pool pointers using look back N strategy
OBJC_DISABLE_CLASSRX_SIGNING_ENFORCEMENT
disable class_rx_t pointer signing enforcement
OBJC_DEBUG_CLASS_RX_SIGNING
warn about class_rx_t pointer signing mismatches
OBJC_DISABLE_CLASS_RO_FAULTS
disable os faults for class_ro_t pointer signing mismatches
PREOPTIMIZATION: using dyld selector opt
.cxx_construct
.cxx_destruct
<null selector>
NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug
id2data fastcache is buggy
id2data cache is buggy
id2data is buggy
Object: SubtypeUntil: end of type encountered prematurely
Protocol
objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects
IMAGES: processing %u newly-mapped images...
IMAGES: loading image for %s%s%s%s%s
 (bundle)
 (replacement)
 (has class properties)
 (preoptimized)
%s has un-signed class_ro_t pointers, but the main executable was compiled with class_ro_t pointer signing enabled
IMAGES: processing 1 newly-unmapped image...
IMAGES: unloading image for %s%s%s
PREOPTIMIZATION: honoring preoptimized header info at %p for %s
__OBJC
__DATA
__DATA_CONST
__DATA_DIRTY
__AUTH
vm_allocate trampolines failed (%d)
vm_remap trampolines failed (%d)
Trampoline block %p, requested invalid index %lu
/usr/lib/libobjc-trampolines.dylib
couldn't dlopen libobjc-trampolines.dylib: %s
Impl
Start
__TEXT
_objc_blockTrampoline
couldn't dlsym %s
Cannot form weak reference to instance (%p) of class %s. It is possible that this object was over-released, or is in the process of deallocation.
__weak variable at %p holds %p instead of %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.
bad weak table at %p. This may be a runtime bug or a memory error somewhere else.
Attempted to unregister unknown __weak variable at %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.
_objc_rootFinalize called with garbage collection off
+[%s %s]: unrecognized selector sent to instance %p
-[%s %s]: unrecognized selector sent to instance %p
+[NSObject instanceMethodSignatureForSelector:] not available without CoreFoundation
+[NSObject methodSignatureForSelector:] not available without CoreFoundation
-[NSObject methodSignatureForSelector:] not available without CoreFoundation
attempt to allocate object of class '%s' failed
autorelease pool page %p corrupted
  magic     0x%08x 0x%08x 0x%08x 0x%08x
  should be 0x%08x 0x%08x 0x%08x 0x%08x
  pthread   %p
  should be %p
AUTORELEASE!
MISSING POOLS: (%p) Object %p of class %s autoreleased with no pool in place - just leaking - break on objc_autoreleaseNoPool() to debug
Invalid or prematurely-freed autorelease pool %p.
Invalid or prematurely-freed autorelease pool %p. Set a breakpoint on objc_autoreleasePoolInvalid to debug. Proceeding anyway because the app is old. Memory errors are likely.
POOL HIGHWATER: new high water mark of %u pending releases for thread %p:
POOL HIGHWATER: extra sequential autoreleases of objects: %u
POOL HIGHWATER:     %s
##############
AUTORELEASE POOLS for thread %p
%llu releases pending.
[%p]  ................  PAGE (placeholder)
[%p]  ################  POOL (placeholder)
[%p]  ................  PAGE %s %s %s
(full)
(hot)
(cold)
[%p]  ################  POOL %p
[%p]  %#16lx  %s  autorelease count %u
[%p]  %#16lx  %s
Starting background scan of weak references.
pthread_create failed with error %d (%s)
ObjC weak reference scanner
OBJC_DEBUG_SCAN_WEAK_TABLES_INTERVAL_NANOSECONDS
Weak reference at %p contains %p, should contain %p
Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)
v28@?0^v8B16^B20
preoptimized header_info missing for %s (%p %p %p)
(by OBJC_DISABLE_PREOPTIMIZATION)
bad objc preopt version (want %d, got %d)
(dyld shared cache is absent or out of date)
PREOPTIMIZATION: is DISABLED %s
PREOPTIMIZATION: is ENABLED (version %d)
zPLR
zPLR
Object
__IncompleteProtocol
Protocol
__NSUnrecognizedTaggedPointer
NSObject
initialize
retain
release
load
alloc
allocWithZone:
autorelease
_tryRetain
_isDeallocating
retainCount
allowsWeakReference
retainWeakReference
self
class
isKindOfClass:
respondsToSelector:
resolveInstanceMethod:
resolveClassMethod:
conformsTo:
descriptionForInstanceMethod:
descriptionForClassMethod:
name
isEqual:
hash
copyWithZone:
mutableCopyWithZone:
copy
dealloc
init
doesNotRecognizeSelector:
selector
description
superclass
isMemberOfClass:
isSubclassOfClass:
isAncestorOfObject:
instancesRespondToSelector:
conformsToProtocol:
isFault
isProxy
instanceMethodForSelector:
methodForSelector:
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
instanceMethodSignatureForSelector:
methodSignatureForSelector:
forwardInvocation:
forwardingTargetForSelector:
debugDescription
zone
mutableCopy
TQ,R
T#,R
T@"NSString",R,C
finalize
_setWeaklyReferenced
@16@0:8
v16@0:8
B24@0:8@16
^{objc_method_description=:*}24@0:8:16
r*16@0:8
Q16@0:8
Vv16@0:8
#16@0:8
B24@0:8#16
B24@0:8:16
B16@0:8
^?24@0:8:16
v24@0:8:16
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
v24@0:8@16
@24@0:8^{_NSZone=}16
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
*** NXCreateHashTable: invalid style
*** NXCreateHashTable: bug
*** hashtable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isEqual(x, y) is TRUE but hash(x) != hash (y)
*** NXCreateMapTable: invalid creation parameters
*** NXMapInsert: invalid key: -1
**** NXMapInsert: bug
**** NXMapRemove: incorrect table
**** NXMapRemove: bug
*** maptable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isEqual(x, y) is TRUE but hash(x) != hash (y)
CACHES: new empty buckets at %p (capacity %zu)
Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.
%s %p, SEL %p, isa %p, cache %p, buckets and mask 0x%lx, occupied 0x%x
receiver
unused
%s %zu bytes, buckets %zu bytes
selector '%s'
isa '%s'
CACHES: not collecting; objc_msgSend in progress
CACHES: COLLECTING %zu bytes (%zu allocations, %zu collections)
CACHES: %4d slots: %4d caches, %6zu bytes
CACHES:      total: %4zu caches, %6zu bytes
task_threads failed (result 0x%x)
CXX: calling C++ constructors for class %s
class_respondsToMethod
class_lookupMethod
invalid selector (null)
__objc_dupclass
Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.
"%s"%s,
%s%s,
CXX: calling C++ destructors for class %s
objc[%d]: %s
The function %s is obsolete. Do not use it. Set a breakpoint on _objc_warn_deprecated to find the culprit.
objc[%d]: HALTED
... %s
unexpected call into objc exception typeinfo vtable %d
EXCEPTIONS: %s through frame [ip=%p sp=%p] for exception %p
unwinding
searching
EXCEPTIONS: throwing %p (object %p, a %s)
EXCEPTIONS: rethrowing current exception
EXCEPTIONS: handling exception %p at %p
EXCEPTIONS: finishing handler
EXCEPTIONS: skipping catch(?)
EXCEPTIONS: catch(id)
EXCEPTIONS: catch(%s)
EXCEPTIONS: skipping catch(%s)
EXCEPTIONS: releasing completed exception %p (object %p, a %s)
EXCEPTIONS: terminating
__objc_selrefs
__objc_msgrefs
__objc_classrefs
__objc_superrefs
__objc_classlist
__objc_stublist
__objc_nlclslist
__objc_catlist
__objc_catlist2
__objc_nlcatlist
__objc_protolist
__objc_protorefs
__objc_init_func
__objc_init_offs
__objc_imageinfo
INITIALIZE: thread %p: blocking until +[%s initialize] completes
INITIALIZE: thread %p: skipping trivial +[%s initialize] in fork() child process
INITIALIZE: thread %p: refusing to call +[%s initialize] in fork() child process because it may have been in progress when fork() was called
+[%s initialize] may have been in progress in another thread when fork() was called.
+[%s initialize] may have been in progress in another thread when fork() was called. We cannot safely call it or ignore it in the fork() child process. Crashing instead. Set a breakpoint on objc_initializeAfterForkError to debug.
INITIALIZE: thread %p: calling +[%s initialize]
INITIALIZE: thread %p: finished +[%s initialize]
INITIALIZE: thread %p: +[%s initialize] threw an exception
thread-safe class init in objc runtime is buggy!
pthread_mutex_lock failed (%d)
pthread_mutex_unlock failed (%d)
INITIALIZE: thread %p: %s is fully +initialized
pthread_cond_broadcast failed (%d)
thread is not initializing this class!
INITIALIZE: thread %p: class %s will be marked as fully +initialized after superclass +[%s initialize] completes
thread is already initializing this class!
pthread_cond_wait failed (%d)
LOAD: class '%s' scheduled for +load
LOAD: category '%s(%s)' scheduled for +load
LOAD: class '%s' unscheduled for +load
LOAD: category '%s(%s)' unscheduled for +load
LOAD: +[%s load]
LOAD: +[%s(%s) load]
LOAD: %d categories still waiting for +load
Swift requested that class %p be ignored, but libobjc does not support that.
FUTURE: found %p already in use for %s
_objc_flush_caches
B16@?0#8
the image is for iOS simulator
PREOPTIMIZATION: reading classes manually from %s because %s
CLASS: found %d classes during launch
IMAGE TIMES: first time tasks
IMAGE TIMES: fix up selector references
IMAGE TIMES: discover classes
IMAGE TIMES: remap classes
PROTOCOLS: Skipping reading protocols in image: %s
IMAGE TIMES: discover protocols
IMAGE TIMES: fix up @protocol references
IMAGE TIMES: discover categories
Swift class %s with a metadata initializer is not allowed to be non-lazy
IMAGE TIMES: realize non-lazy classes
Swift class is not allowed to be future
IMAGE TIMES: realize future classes
PREOPTIMIZATION: honoring preoptimized selectors in %s
PREOPTIMIZATION: IGNORING preoptimized selectors in %s
PREOPTIMIZATION: %zu selector references not pre-optimized
PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted
PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered
PREOPTIMIZATION: %zu protocol references not pre-optimized
Swift class extensions and categories on Swift classes are not allowed to have +load methods
method_exchangeImplementations
objc_registerProtocol: protocol '%s' was already registered!
objc_registerProtocol: protocol '%s' was not allocated with objc_allocateProtocol!
protocol_addProtocol: modified protocol '%s' is not under construction!
protocol_addProtocol: added protocol '%s' is still under construction!
protocol_addMethodDescription: protocol '%s' is not under construction!
protocol_addProperty: protocol '%s' is not under construction!
<stub class %p>
<lazily named class %p>
Memory corruption in class list.
INITIALIZE: thread %p: setInitialized(%s)
RAW ISA:  %s%s%s
 (meta)
 (inherited)
Lazily named class %p with no lazy name handler registered
Lazily named class %p wasn't named by lazy name handler
*** Can't set ivar layout for already-registered class '%s'
*** Can't set weak ivar layout for already-registered class '%s'
CLASS: realizing class '%s' (duplicate of %s) %p %p
objc_registerClassPair: class '%s' was already registered!
objc_registerClassPair: class '%s' was not allocated with objc_allocateClassPair!
objc_readClassPair for class %s changed %p to %p
objc_disposeClassPair: class '%s' was not allocated with objc_allocateClassPair!
objc_disposeClassPair: class '%s' is a metaclass, not a class!
objc_disposeClassPair: class '%s' still has subclasses, including '%s'!
tagged pointers are disabled
tag index %u is invalid
tag index %u used for two different classes (was %p %s, now %p %s)
INITIALIZE: %d/%d (%g%%) successful by-name metaclass lookups
INITIALIZE: %d/%d (%g%%) successful secondary metaclass lookups
INITIALIZE: %d/%d (%g%%) successful shared cache metaclass lookups
INITIALIZE: %d/%d (%g%%) successful dyld closure metaclass lookups
no class for metaclass %p
FUTURE: using %p instead of %p for %s
CLASS: realizing class '%s'%s %p %p #%u %s%s
(swift)
(pre-stable swift)
OS_object
NSCF
__CF
NSConstantString
NSSimpleCString
IVARS: DEBUG: forcing ivars for class '%s' to slide (instanceStart %zu -> %zu)
IVARS: sliding ivars for class %s (superclass was %u bytes, now %u)
IVARS:    offset %u -> %u for %s (size %u, align %u)
CLASS: methodizing class '%s' %s
(meta)
CUSTOM AWZ
CUSTOM RR
CUSTOM Core
%s: %s%s%s
CLASS: attaching %d categories to%s class '%s'%s
 existing
attachCategories
FUTURE: reserving %p for %s
CLASS: IGNORING class '%s' with missing weak-linked superclass
Can't complete future class request for '%s' because the real class is too big.
%.2f ms: %s
PROTOCOLS: protocol at %p is %s  (duplicate of %p)
PROTOCOLS: protocol at %p is %s
CLASS: IGNORING category ???(%s) %p with missing weak-linked target class
CLASS: found category %c%s(%s)
CLASS: calling Swift metadata initializer for class '%s' (%p)
_method_setImplementation
_TtP
_TtC
Swift
%.*s.%.*s
_Tt%cs%zu%.*s%s
_Tt%c%zu%.*s%zu%.*s%s
Attempt to use unknown class %p.
RESOLVE: method %c[%s %s] dynamically resolved to %p
RESOLVE: +[%s resolveInstanceMethod:%s] returned YES, but no new implementation of %c[%s %s] was found
nonmeta class %s (%p) unexpectedly not realized
RESOLVE: +[%s resolveClassMethod:%s] returned YES, but no new implementation of %c[%s %s] was found
addMethods_finish
setSuperclass
_TtCs12_SwiftObject
link error: class '%s' not found.
class `%s' not linked into application
Cannot find range %#lx..%#lx
objc4
classRxSigning
classRoSigningFaults
Malloc
DYLD
NSZombiesEnabled
OBJC_
OBJC_HELP=
OBJC_PRINT_OPTIONS=
OBJC_DEBUG_POOL_DEPTH=
DYLD_INSERT_LIBRARIES
OBJC_DEBUG_POOL_ALLOCATION
MallocStackLogging
MallocStackLoggingNoCompact
libgmalloc
preoptimizedCaches
Objective-C runtime debugging. Set variable=YES to enable.
OBJC_HELP: describe available environment variables
OBJC_HELP is set
OBJC_PRINT_OPTIONS: list which options are set
OBJC_PRINT_OPTIONS is set
%s: %s
%s is set
REPLACED: %c[%s %s]  %s%s  (IMP was %p (%s), now %p (%s))
by category 
%c[%s %s]: unrecognized selector sent to instance %p (no message forward handler is installed)
mutation detected during 'for(... in ...)'  enumeration of object %p.
OBJC_PRINT_IMAGES
log image and library names as they are loaded
OBJC_PRINT_IMAGE_TIMES
measure duration of image loading steps
OBJC_PRINT_LOAD_METHODS
log calls to class and category +load methods
OBJC_PRINT_INITIALIZE_METHODS
log calls to class +initialize methods
OBJC_PRINT_RESOLVED_METHODS
log methods created by +resolveClassMethod: and +resolveInstanceMethod:
OBJC_PRINT_CLASS_SETUP
log progress of class and category setup
OBJC_PRINT_PROTOCOL_SETUP
log progress of protocol setup
OBJC_PRINT_IVAR_SETUP
log processing of non-fragile ivars
OBJC_PRINT_VTABLE_SETUP
log processing of class vtables
OBJC_PRINT_VTABLE_IMAGES
print vtable images showing overridden methods
OBJC_PRINT_CACHE_SETUP
log processing of method caches
OBJC_PRINT_FUTURE_CLASSES
log use of future classes for toll-free bridging
OBJC_PRINT_PREOPTIMIZATION
log preoptimization courtesy of dyld shared cache
OBJC_PRINT_CXX_CTORS
log calls to C++ ctors and dtors for instance variables
OBJC_PRINT_EXCEPTIONS
log exception handling
OBJC_PRINT_EXCEPTION_THROW
log backtrace of every objc_exception_throw()
OBJC_PRINT_ALT_HANDLERS
log processing of exception alt handlers
OBJC_PRINT_REPLACED_METHODS
log methods replaced by category implementations
OBJC_PRINT_DEPRECATION_WARNINGS
warn about calls to deprecated runtime functions
OBJC_PRINT_POOL_HIGHWATER
log high-water marks for autorelease pools
OBJC_PRINT_CUSTOM_CORE
log classes with custom core methods
OBJC_PRINT_CUSTOM_RR
log classes with custom retain/release methods
OBJC_PRINT_CUSTOM_AWZ
log classes with custom allocWithZone methods
OBJC_PRINT_RAW_ISA
log classes that require raw pointer isa fields
OBJC_DEBUG_UNLOAD
warn about poorly-behaving bundles when unloaded
OBJC_DEBUG_FRAGILE_SUPERCLASSES
warn about subclasses that may have been broken by subsequent changes to superclasses
OBJC_DEBUG_NIL_SYNC
warn about @synchronized(nil), which does no synchronization
OBJC_DEBUG_NONFRAGILE_IVARS
capriciously rearrange non-fragile ivars
OBJC_DEBUG_ALT_HANDLERS
record more info about bad alt handler use
OBJC_DEBUG_MISSING_POOLS
warn about autorelease with no pool in place, which may be a leak
halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools
OBJC_DEBUG_DUPLICATE_CLASSES
halt when multiple classes with the same name are present
OBJC_DEBUG_DONT_CRASH
halt the process by exiting instead of crashing
OBJC_DEBUG_POOL_DEPTH
log fault when at least a set number of autorelease pages has been allocated
OBJC_DEBUG_SCRIBBLE_CACHES
scribble the IMPs in freed method caches
OBJC_DEBUG_SCAN_WEAK_TABLES
scan the weak references table continuously in the background - set OBJC_DEBUG_SCAN_WEAK_TABLES_INTERVAL_NANOSECONDS to set scanning interval (default 1000000)
OBJC_DISABLE_VTABLES
disable vtable dispatch
OBJC_DISABLE_PREOPTIMIZATION
disable preoptimization courtesy of dyld shared cache
OBJC_DISABLE_TAGGED_POINTERS
disable tagged pointer optimization of NSNumber et al.
OBJC_DISABLE_TAG_OBFUSCATION
disable obfuscation of tagged pointers
OBJC_DISABLE_NONPOINTER_ISA
disable non-pointer isa fields
OBJC_DISABLE_INITIALIZE_FORK_SAFETY
disable safety checks for +initialize after fork
OBJC_DISABLE_FAULTS
disable os faults
OBJC_DISABLE_PREOPTIMIZED_CACHES
disable preoptimized caches
OBJC_DISABLE_AUTORELEASE_COALESCING
disable coalescing of autorelease pool pointers
OBJC_DISABLE_AUTORELEASE_COALESCING_LRU
disable coalescing of autorelease pool pointers using look back N strategy
OBJC_DISABLE_CLASSRX_SIGNING_ENFORCEMENT
disable class_rx_t pointer signing enforcement
OBJC_DEBUG_CLASS_RX_SIGNING
warn about class_rx_t pointer signing mismatches
OBJC_DISABLE_CLASS_RO_FAULTS
disable os faults for class_ro_t pointer signing mismatches
PREOPTIMIZATION: using dyld selector opt
.cxx_construct
.cxx_destruct
<null selector>
NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug
id2data fastcache is buggy
id2data cache is buggy
id2data is buggy
Object: SubtypeUntil: end of type encountered prematurely
Protocol
objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects
IMAGES: processing %u newly-mapped images...
IMAGES: loading image for %s%s%s%s%s
 (bundle)
 (replacement)
 (has class properties)
 (preoptimized)
%s has un-signed class_ro_t pointers, but the main executable was compiled with class_ro_t pointer signing enabled
IMAGES: processing 1 newly-unmapped image...
IMAGES: unloading image for %s%s%s
PREOPTIMIZATION: honoring preoptimized header info at %p for %s
__OBJC
__DATA
__DATA_CONST
__DATA_DIRTY
__AUTH
vm_allocate trampolines failed (%d)
vm_remap trampolines failed (%d)
Trampoline block %p, requested invalid index %lu
/usr/lib/libobjc-trampolines.dylib
couldn't dlopen libobjc-trampolines.dylib: %s
Impl
Start
__TEXT
_objc_blockTrampoline
couldn't dlsym %s
Cannot form weak reference to instance (%p) of class %s. It is possible that this object was over-released, or is in the process of deallocation.
__weak variable at %p holds %p instead of %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.
bad weak table at %p. This may be a runtime bug or a memory error somewhere else.
Attempted to unregister unknown __weak variable at %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.
_objc_rootFinalize called with garbage collection off
+[%s %s]: unrecognized selector sent to instance %p
-[%s %s]: unrecognized selector sent to instance %p
+[NSObject instanceMethodSignatureForSelector:] not available without CoreFoundation
+[NSObject methodSignatureForSelector:] not available without CoreFoundation
-[NSObject methodSignatureForSelector:] not available without CoreFoundation
attempt to allocate object of class '%s' failed
/usr/lib/swift/libswiftCore.dylib
swift_retain
swift_release
autorelease pool page %p corrupted
  magic     0x%08x 0x%08x 0x%08x 0x%08x
  should be 0x%08x 0x%08x 0x%08x 0x%08x
  pthread   %p
  should be %p
AUTORELEASE!
MISSING POOLS: (%p) Object %p of class %s autoreleased with no pool in place - just leaking - break on objc_autoreleaseNoPool() to debug
Invalid or prematurely-freed autorelease pool %p.
Invalid or prematurely-freed autorelease pool %p. Set a breakpoint on objc_autoreleasePoolInvalid to debug. Proceeding anyway because the app is old. Memory errors are likely.
POOL HIGHWATER: new high water mark of %u pending releases for thread %p:
POOL HIGHWATER: extra sequential autoreleases of objects: %u
POOL HIGHWATER:     %s
##############
AUTORELEASE POOLS for thread %p
%llu releases pending.
[%p]  ................  PAGE (placeholder)
[%p]  ################  POOL (placeholder)
[%p]  ................  PAGE %s %s %s
(full)
(hot)
(cold)
[%p]  ################  POOL %p
[%p]  %#16lx  %s  autorelease count %u
[%p]  %#16lx  %s
Starting background scan of weak references.
pthread_create failed with error %d (%s)
ObjC weak reference scanner
OBJC_DEBUG_SCAN_WEAK_TABLES_INTERVAL_NANOSECONDS
Weak reference at %p contains %p, should contain %p
Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)
v28@?0^v8B16^B20
preoptimized header_info missing for %s (%p %p %p)
(by OBJC_DISABLE_PREOPTIMIZATION)
bad objc preopt version (want %d, got %d)
(dyld shared cache is absent or out of date)
PREOPTIMIZATION: is DISABLED %s
PREOPTIMIZATION: is ENABLED (version %d)
Object
__IncompleteProtocol
Protocol
__NSUnrecognizedTaggedPointer
NSObject
initialize
retain
release
load
alloc
allocWithZone:
autorelease
_tryRetain
_isDeallocating
retainCount
allowsWeakReference
retainWeakReference
self
class
isKindOfClass:
respondsToSelector:
resolveInstanceMethod:
resolveClassMethod:
conformsTo:
descriptionForInstanceMethod:
descriptionForClassMethod:
name
isEqual:
hash
copyWithZone:
mutableCopyWithZone:
copy
_noteAssociatedObjects
dealloc
init
doesNotRecognizeSelector:
selector
description
superclass
isMemberOfClass:
isSubclassOfClass:
isAncestorOfObject:
instancesRespondToSelector:
conformsToProtocol:
isFault
isProxy
instanceMethodForSelector:
methodForSelector:
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
instanceMethodSignatureForSelector:
methodSignatureForSelector:
forwardInvocation:
forwardingTargetForSelector:
debugDescription
zone
mutableCopy
TQ,R
T#,R
T@"NSString",R,C
finalize
_setWeaklyReferenced
@16@0:8
v16@0:8
B24@0:8@16
^{objc_method_description=:*}24@0:8:16
r*16@0:8
Q16@0:8
Vv16@0:8
#16@0:8
B24@0:8#16
B24@0:8:16
B16@0:8
^?24@0:8:16
v24@0:8:16
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
v24@0:8@16
@24@0:8^{_NSZone=}16
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
