%W
% W
%"W
%$W
%&W
%(W
%*W
%,W
%.W
%0W
%2W
%4W
%6W
%8W
%:W
%<W
%>W
%@W
%BW
%DW
%FW
%HW
%JW
%LW
%NW
%PW
%RW
%TW
%VW
%XW
%ZW
%\W
%^W
%`W
%bW
%dW
%fW
%hW
%jW
%lW
%nW
%pW
%rW
%tW
%vW
%xW
%zW
%|W
%~W
B31CLMicroLocationWifiScanStrategy
N13CLWifiScanner21IWifiScanningStrategyE
NSt3__110__function6__funcIN12_GLOBAL__N_124LocalizerChannelIteratorENS_9allocatorIS3_EEFNS_6vectorIiNS4_IiEEEEvEEE
NSt3__110__function6__baseIFNS_6vectorIiNS_9allocatorIiEEEEvEEE
N12_GLOBAL__N_124LocalizerChannelIteratorE
NSt3__110__function6__funcIZN31CLMicroLocationWifiScanStrategy9Recording19makeChannelIteratorENS_6vectorI35CLMicroLocationWiFiChannelHistogramNS_9allocatorIS5_EEEEE3$_0NS6_IS9_EEFNS4_IiNS6_IiEEEEvEEE
ZN31CLMicroLocationWifiScanStrategy9Recording19makeChannelIteratorENSt3__16vectorI35CLMicroLocationWiFiChannelHistogramNS1_9allocatorIS3_EEEEE3$_0
NSt3__120__shared_ptr_emplaceIN13CLWifiScanner16WifiScanSettingsENS_9allocatorIS2_EEEE
40CLMicroLocationFingerprintDatabaseSource
N37CLMicroLocationFingerprintDataSources24IInterruptibleDataSourceE
N20CLMicroLocationUtils16PerSourceWeightsIdEE
N20CLMicroLocationUtils7WeightsIdEE
N20CLMicroLocationUtils16PerSourceWeightsIbEE
N20CLMicroLocationUtils7WeightsIbEE
NSt3__110__function6__funcIZN25CLMicroLocationAlgorithms7details46createWeightedEuclideanJaccardDistanceFunctionERK25CLMicroLocationDictionaryRKNS_6bitsetILm7EEERKNS3_32FingerprintDistanceFunctionUsageERKNS_8optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_0NS_9allocatorISJ_EEFdRK26CLMicroLocationFingerprintSO_EEE
NSt3__110__function6__baseIFdRK26CLMicroLocationFingerprintS4_EEE
ZN25CLMicroLocationAlgorithms7details46createWeightedEuclideanJaccardDistanceFunctionERK25CLMicroLocationDictionaryRKNSt3__16bitsetILm7EEERKNS0_32FingerprintDistanceFunctionUsageERKNS4_8optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_0
NSt3__110__function6__funcIZN25CLMicroLocationAlgorithms7details33createFingerprintDistanceFunctionENS2_31FingerprintDistanceFunctionTypeERK25CLMicroLocationDictionarybbbNS3_32FingerprintDistanceFunctionUsageERKNS_8optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_1NS_9allocatorISE_EEFdRK26CLMicroLocationFingerprintSJ_EEE
ZN25CLMicroLocationAlgorithms7details33createFingerprintDistanceFunctionENS_31FingerprintDistanceFunctionTypeERK25CLMicroLocationDictionarybbbNS0_32FingerprintDistanceFunctionUsageERKNSt3__18optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_1
NSt3__110__function6__funcIZN25CLMicroLocationAlgorithms7details33createFingerprintDistanceFunctionENS2_31FingerprintDistanceFunctionTypeERK25CLMicroLocationDictionarybbbNS3_32FingerprintDistanceFunctionUsageERKNS_8optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_2NS_9allocatorISE_EEFdRK26CLMicroLocationFingerprintSJ_EEE
ZN25CLMicroLocationAlgorithms7details33createFingerprintDistanceFunctionENS_31FingerprintDistanceFunctionTypeERK25CLMicroLocationDictionarybbbNS0_32FingerprintDistanceFunctionUsageERKNSt3__18optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_2
NSt3__110__function6__funcIZN25CLMicroLocationAlgorithms7details33createFingerprintDistanceFunctionENS2_31FingerprintDistanceFunctionTypeERK25CLMicroLocationDictionarybbbNS3_32FingerprintDistanceFunctionUsageERKNS_8optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_3NS_9allocatorISE_EEFdRK26CLMicroLocationFingerprintSJ_EEE
ZN25CLMicroLocationAlgorithms7details33createFingerprintDistanceFunctionENS_31FingerprintDistanceFunctionTypeERK25CLMicroLocationDictionarybbbNS0_32FingerprintDistanceFunctionUsageERKNSt3__18optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_3
NSt3__110__function6__funcIZN25CLMicroLocationAlgorithms7details33createFingerprintDistanceFunctionENS2_31FingerprintDistanceFunctionTypeERK25CLMicroLocationDictionarybbbNS3_32FingerprintDistanceFunctionUsageERKNS_8optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_4NS_9allocatorISE_EEFdRK26CLMicroLocationFingerprintSJ_EEE
ZN25CLMicroLocationAlgorithms7details33createFingerprintDistanceFunctionENS_31FingerprintDistanceFunctionTypeERK25CLMicroLocationDictionarybbbNS0_32FingerprintDistanceFunctionUsageERKNSt3__18optionalI34CLMicroLocationAnchorAppearanceMapEEE3$_4
25CLLaplacianKernelFunction
16CLKernelFunction
27CLEuclideanDistanceFunction
18CLDistanceFunction
34CLEuclideanSquaredDistanceFunction
24CLGaussianKernelFunction
27CLExponentialKernelFunction
23CLUniformKernelFunction
NSt3__110__function6__funcIPFfRK24CLDistanceMatrixTemplateI24CLSymmetricMatrixStorageIfEENS_4pairImmEES9_S9_ENS_9allocatorISB_EESA_EE
NSt3__110__function6__baseIFfRK24CLDistanceMatrixTemplateI24CLSymmetricMatrixStorageIfEENS_4pairImmEES9_S9_EEE
PFfRK24CLDistanceMatrixTemplateI24CLSymmetricMatrixStorageIfEENSt3__14pairImmEES7_S7_E
FfRK24CLDistanceMatrixTemplateI24CLSymmetricMatrixStorageIfEENSt3__14pairImmEES7_S7_E
NSt3__110__function6__funcIZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_0NS_9allocatorIS5_EEFvNS_8functionIFbvEEEEEE
ZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_0
NSt3__110__function6__funcIZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_1NS_9allocatorIS5_EEFvNS_8functionIFbvEEEEEE
ZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_1
NSt3__110__function6__funcIZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_2NS_9allocatorIS5_EEFvNS_8functionIFbvEEEEEE
ZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_2
NSt3__110__function6__funcIZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_3NS_9allocatorIS5_EEFvNS_8functionIFbvEEEEEE
ZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_3
NSt3__110__function6__funcIZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_4NS_9allocatorIS5_EEFvNS_8functionIFbvEEEEEE
ZN26CLMicroLocationMaintenanceC1ER23CLMicroLocationDatabaseE3$_4
39CLMicroLocationNearestNeighborAlgorithm
34CLMicroLocationDendrogramAlgorithm
30CLMicroLocationKMeansAlgorithm
N25CLMicroLocationAlgorithms8ILearnerE
N20CLMicroLocationProto17BleLeechedBeaconsE
N20CLMicroLocationProto8WiFiRssiE
N20CLMicroLocationProto9DirectionE
N20CLMicroLocationProto8UwbRangeE
N20CLMicroLocationProto9WiFiRangeE
N20CLMicroLocationProto23ATVAirplayBluetoothRssiE
N20CLMicroLocationProto20HomeKitBluetoothRssiE
N20CLMicroLocationProto11MeasurementE
N20CLMicroLocationProto11FingerprintE
N20CLMicroLocationProto17ClusterRecordingsE
N20CLMicroLocationProto14AnchorMetadataE
N20CLMicroLocationProto16AnchorAppearanceE
N20CLMicroLocationProto23anchorAppearancesVectorE
N20CLMicroLocationProto5ModelE
N20CLMicroLocationProto16BundleIdFeaturesE
N20CLMicroLocationProto19LocalizationRequestE
N20CLMicroLocationProto16RecordingRequestE
N20CLMicroLocationProto9AppLaunchE
N20CLMicroLocationProto14SiriInvocationE
N20CLMicroLocationProto11BacklightOnE
N20CLMicroLocationProto23BatteryChargerConnectedE
N20CLMicroLocationProto9StepCountE
N20CLMicroLocationProto15ForcedRecordingE
N20CLMicroLocationProto14FirstWakeOfDayE
N20CLMicroLocationProto16HomeKitAccessoryE
N20CLMicroLocationProto12HomeKitSceneE
N20CLMicroLocationProto22NowPlayingOutputDeviceE
N20CLMicroLocationProto10NowPlayingE
N20CLMicroLocationProto14RecordingEventE
N20CLMicroLocationProto15ChannelAndCountE
N20CLMicroLocationProto13WifiHistogramE
N20CLMicroLocationProto13ConfigurationE
N20CLMicroLocationProto13RapportDeviceE
?N37CLMicroLocationFingerprintDataSources24IInterruptibleDataSource18CancelledExceptionE
NSt3__110__function6__funcIZN22CLMicroLocationLearnerC1ERNS2_16ILearnerDelegateER23CLMicroLocationDatabaseE3$_0NS_9allocatorIS7_EEFvNS_8functionIFbvEEEEEE
NSt3__110__function6__baseIFvNS_8functionIFbvEEEEEE
ZN22CLMicroLocationLearnerC1ERNS_16ILearnerDelegateER23CLMicroLocationDatabaseE3$_0
NSt3__110__function6__funcIPF39CLMicroLocationFingerprintConfigurationvENS_9allocatorIS4_EES3_EE
NSt3__110__function6__baseIF39CLMicroLocationFingerprintConfigurationvEEE
PF39CLMicroLocationFingerprintConfigurationvE
F39CLMicroLocationFingerprintConfigurationvE
NSt3__110__function6__funcIZN22CLMicroLocationLearner18learnFromModelTypeENS_8functionIFbvEEEN20CLMicroLocationProto15Model_ModelTypeEP19NSMutableDictionaryE4$_11NS_9allocatorISA_EEF39CLMicroLocationFingerprintConfigurationvEEE
ZN22CLMicroLocationLearner18learnFromModelTypeENSt3__18functionIFbvEEEN20CLMicroLocationProto15Model_ModelTypeEP19NSMutableDictionaryE4$_11
N5boost6detail15sp_counted_baseE
N5boost16exception_detail10clone_implINS0_19error_info_injectorISt16invalid_argumentEEEE
N5boost16exception_detail19error_info_injectorISt16invalid_argumentEE
NSt3__110__function6__funcIZN24CLMicroLocationAnalyticsC1ERNS2_18IAnalyticsDelegateER23CLMicroLocationDatabaseE3$_0NS_9allocatorIS7_EEFvNS_8functionIFbvEEEEEE
ZN24CLMicroLocationAnalyticsC1ERNS_18IAnalyticsDelegateER23CLMicroLocationDatabaseE3$_0
333333
?ffffff
N20CLMicroLocationUtils14ConstantWeightIdEE
0123456789ABCDEF1
33CLMicroLocationNullSpaceAlgorithm
N25CLMicroLocationAlgorithms10ILocalizerE
NSt3__110__function6__funcIPFdRKNS_8multisetIdNS_4lessIdEENS_9allocatorIdEEEEENS5_ISB_EEFdS7_EEE
NSt3__110__function6__baseIFdNS_8multisetIdNS_4lessIdEENS_9allocatorIdEEEEEEE
PFdRKNSt3__18multisetIdNS_4lessIdEENS_9allocatorIdEEEEE
FdRKNSt3__18multisetIdNS_4lessIdEENS_9allocatorIdEEEEE
fffffff
D20CLMicroLocationLogic
NSt3__120__shared_ptr_emplaceI31CLMicroLocationWifiScanStrategyNS_9allocatorIS1_EEEE
NSt3__110__function6__funcIPFNS_8functionIFNS_6vectorIiNS_9allocatorIiEEEEvEEENS3_I35CLMicroLocationWiFiChannelHistogramNS4_IS9_EEEEENS4_ISD_EESC_EE
NSt3__110__function6__baseIFNS_8functionIFNS_6vectorIiNS_9allocatorIiEEEEvEEENS3_I35CLMicroLocationWiFiChannelHistogramNS4_IS9_EEEEEEE
PFNSt3__18functionIFNS_6vectorIiNS_9allocatorIiEEEEvEEENS1_I35CLMicroLocationWiFiChannelHistogramNS2_IS7_EEEEE
FNSt3__18functionIFNS_6vectorIiNS_9allocatorIiEEEEvEEENS1_I35CLMicroLocationWiFiChannelHistogramNS2_IS7_EEEEE
25CLMicroLocationDictionary
N5boost6detail17sp_counted_impl_pINS_6random23mersenne_twister_engineIjLm32ELm624ELm397ELm31ELj2567483615ELm11ELj4294967295ELm7ELj2636928640ELm15ELj4022730752ELm18ELj1812433253EEEEE
N5boost9exceptionE
NSt3__110__function6__funcIZN26CLMicroLocationFingerprintC1ERKNS_18unordered_multisetIN20CLMicroLocationProto11MeasurementENS2_15HashMeasurementENS2_20PredicateMeasurementENS_9allocatorIS5_EEEERK39CLMicroLocationFingerprintConfigurationRKNS_8optionalIN5boost5uuids4uuidEEEE3$_3NS8_ISN_EEFbRKS5_EEE
NSt3__110__function6__baseIFbRKN20CLMicroLocationProto11MeasurementEEEE
ZN26CLMicroLocationFingerprintC1ERKNSt3__118unordered_multisetIN20CLMicroLocationProto11MeasurementENS_15HashMeasurementENS_20PredicateMeasurementENS0_9allocatorIS3_EEEERK39CLMicroLocationFingerprintConfigurationRKNS0_8optionalIN5boost5uuids4uuidEEEE3$_3
NSt3__110__function6__funcIZN26CLMicroLocationFingerprintC1ERKNS_18unordered_multisetIN20CLMicroLocationProto11MeasurementENS2_15HashMeasurementENS2_20PredicateMeasurementENS_9allocatorIS5_EEEERK39CLMicroLocationFingerprintConfigurationRKNS_8optionalIN5boost5uuids4uuidEEEE3$_1NS8_ISN_EEFbRKS5_EEE
ZN26CLMicroLocationFingerprintC1ERKNSt3__118unordered_multisetIN20CLMicroLocationProto11MeasurementENS_15HashMeasurementENS_20PredicateMeasurementENS0_9allocatorIS3_EEEERK39CLMicroLocationFingerprintConfigurationRKNS0_8optionalIN5boost5uuids4uuidEEEE3$_1
41CLMicroLocationFingerprintStdVectorSource
N30CLMicroLocationDatabaseColumns20InvalidDatabaseValueE
N5boost6detail17basic_unlockedbufINSt3__115basic_stringbufIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEcEE
N5boost6detail16basic_pointerbufIcNSt3__115basic_stringbufIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEEE
N5boost5uuids4uuidE
NSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE
NSt3__121__basic_string_commonILb1EEE
40CLHistogramHypothesisTestUnlockEstimator
18CLIUnlockEstimator
23CLAlwaysUnlockEstimator
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?333333
?333333
?333333
?ffffff
?p@KW
drjg
?333333
?ffffff
?333333
?ffffff
t?ffffff
Br?333333
e?ffffff
Db?333333
c`]?
fHU?ffffff
T?333333
SweG?ffffff
PD?333333
 wA?ffffff
=?333333
h:;9?
+5?ffffff
S/?333333
(?ffffff
?333333
?ffffff
?333333
t><K
?ffffff
?333333
?ffffff
?333333
>ffffff
_>Y1\
>333333
>ffffff
>333333
>333333 @
>ffffff @
_>Y1\
_>Y1\
>333333!@T
>ffffff!@T
>333333"@
>ffffff"@T
>333333#@
>ffffff#@T
>333333
>ffffff
>333333
>ffffff
>333333
>ffffff
>333333
>ffffff
>333333
>ffffff
>333333
>ffffff
>ffffff
>333333
>ffffff
>333333
>ffffff
>333333
>333333
_>Y1\
?333333
_>Y1\
pX*?333333
?8?ffffff
_#IP?
<HOa?
qh?333333
nv?ffffff
?333333
?ffffff
?ffffff
?333333
@ILP
?ffffff
?333333
@F"4
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?ffffff
?333333
?333333 @Z
?ffffff @Z
?333333!@Z
?ffffff!@Z
?333333"@Z
?ffffff"@Z
?333333#@Z
?ffffff#@Z
$@35CLPhonePeerRangingDecisionProcessor
30CLPeerRangingDecisionProcessor
@33CLMacPeerRangingDecisionProcessor
NSt3__120__shared_ptr_emplaceI37CLPredictedWalkDistanceBoutRecorderDbNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceIN10CLMobility21GaitMetricsRecorderDbENS_9allocatorIS2_EEEE
NSt3__120__shared_ptr_emplaceI27CLWalkingSpeedCalRecorderDbNS_9allocatorIS1_EEEE
22CLWorkoutClassifierCNN
:18CMSensorFusionMekf
23CMSensorFusionInterface
32CLCoarseCellTilesManagerExternal
33CLICoarseCellTilesManagerExternal
^R@fffff&2@
J@33333
]@fffff
Z@fffff&E@
L9@fffff&`@
H@q=
(LU@
6@B`
^F@33333#]@
,G@{
|_@R
nJ@q=
_@q=
D@333333E@
~_@33333sD@\
(<D@
8@ffffff9@
p=J;@
^@33333
]R`)@K
?A/E
__'o
@*G%1
@BCt
a_'o
@)G%1
@BCt
u]g"
H+{5
__'o
@~5g
?)G%1
??Ct
s]g"
H+{5
`_'o
@~5g
?+G%1
?ACt
v]g"
H+{5
?enm
?g(EF
`_'o
?+G%1
?@Ct
Yp;#
B}z}
?$g!G
?46CLLogNormalNormalHypothesisTestUnlockEstimator
26CLStationaryCycleStopModel
 @18CLNatalieWalkModel
@j@30CLExerciseMinuteBurstEstimator
NSt3__110__function6__funcIZN30CLExerciseMinuteBurstEstimator22computeExerciseMinutesEvE3$_0NS_9allocatorIS3_EEFvRK31CLExerciseMinuteIntensitySampledEEE
NSt3__110__function6__baseIFvRK31CLExerciseMinuteIntensitySampledEEE
ZN30CLExerciseMinuteBurstEstimator22computeExerciseMinutesEvE3$_0
15CLSwimDataStore
19CLSwimDataInterface
14CLMedianFilterIdE
NSt3__110__function6__funcIZNK15CLSwimDataStore16getStrokesPerLapE15CLSwimStyleTypeiE3$_2NS_9allocatorIS4_EEFbRK11CLSwimEntryEEE
NSt3__110__function6__baseIFbRK11CLSwimEntryEEE
ZNK15CLSwimDataStore16getStrokesPerLapE15CLSwimStyleTypeiE3$_2
r@17CLTileSyncManager
18CLITileSyncManager
_52CLStreamingAwareLocationProviderLocalGPSStateMachine
NSt3__110__function6__funcIZN52CLStreamingAwareLocationProviderLocalGPSStateMachine41setWorkoutStateBasedOnMotionCompatibilityEdE3$_0NS_9allocatorIS3_EEFvdEEE
ZN52CLStreamingAwareLocationProviderLocalGPSStateMachine41setWorkoutStateBasedOnMotionCompatibilityEdE3$_0
NSt3__110__function6__funcIZN52CLStreamingAwareLocationProviderLocalGPSStateMachine26handleNewRemoteMotionStateERKN23CLLocationProvider_Type14MotionDetectedERKdS8_E3$_1NS_9allocatorIS9_EEFvdEEE
ZN52CLStreamingAwareLocationProviderLocalGPSStateMachine26handleNewRemoteMotionStateERKN23CLLocationProvider_Type14MotionDetectedERKdS5_E3$_1
333333
?26CLHealthAssessmentNotifier
10CLNotifierIN31CLHealthAssessmentNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceI28CLParkinsonsResultRecorderDbNS_9allocatorIS1_EEEE
N31CLHealthAssessmentNotifier_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN31CLHealthAssessmentNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
?333gff%@
26CLStreamedLocationProvider
N31CLStreamedLocationProvider_Type6ClientE
16CLNotifierClientIN23CLLocationProvider_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
>aqx
M=19CLNatalieDanceModel
CLHRSEAV
24CLSensorFusionServiceSPU
NSt3__120__shared_ptr_emplaceI14FastPathDeviceNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_pointerIP26CLActivityLoggerSizePolicyNS_10shared_ptrI22CLActivityLoggerPolicyE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI22CLActivityLoggerPolicyE27__shared_ptr_default_deleteIS1_26CLActivityLoggerSizePolicyEE
NSt3__120__shared_ptr_pointerIP25CLActivityLoggerMsgPolicyNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI25CLActivityLoggerMsgPolicyE27__shared_ptr_default_deleteIS1_S1_EE
NSt3__120__shared_ptr_pointerIP26CLActivityLoggerRatePolicyNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI26CLActivityLoggerRatePolicyE27__shared_ptr_default_deleteIS1_S1_EE
19CLFenceSubscription
23CLTransientSubscriptionI19CLFenceSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI19CLFenceSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR19CLFenceSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase14messageHandlerI19CLFenceSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI19CLFenceSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI19CLFenceSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
>NSt3__120__shared_ptr_emplaceI27CLHarvestControllerExternalNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI19CLHarvestControllerNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI20CLMonitorGpsExternalNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI12CLMonitorGpsNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI25CLPolicyProactiveExternalNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI17CLPolicyProactiveNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI20CLPolicyTripExternalNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI12CLPolicyTripNS_9allocatorIS1_EEEE
31CLFenceMonitorWifiLogicExternal
32CLIFenceMonitorWifiLogicExternal
?18CLOdometerNotifier
10CLNotifierIN23CLOdometerNotifier_Type12NotificationENS0_16NotificationDataEccE
N23CLOdometerNotifier_Type6ClientE
16CLNotifierClientIN23CLOdometerNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_pointerIP21CLElevationRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI21CLElevationRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
NSt3__120__shared_ptr_pointerIP20CLActivityAggregatorI22CLSignificantElevationN12CLActivityDB22NoDataProtectionPolicyEENS_10shared_ptrIS5_E27__shared_ptr_default_deleteIS5_S5_EENS_9allocatorIS5_EEEE
NSt3__110shared_ptrI20CLActivityAggregatorI22CLSignificantElevationN12CLActivityDB22NoDataProtectionPolicyEEE27__shared_ptr_default_deleteIS5_S5_EE
NSt3__120__shared_ptr_emplaceIN23CLOdometerNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N23CLOdometerNotifier_Type16NotificationDataE
NSt3__120__shared_ptr_pointerIP19CLMaxMetsRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI19CLMaxMetsRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
NSt3__120__shared_ptr_pointerIP29CLMaxMetsProcessingRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI29CLMaxMetsProcessingRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
NSt3__120__shared_ptr_emplaceI18CLVO2MaxInputCacheNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI18CLVO2MaxInputStoreNS_9allocatorIS1_EEEE
vHGB(knN55CLStreamingAwareLocationProviderPassthroughStateMachine
?22CLCalorieSwimmingModel
@fffff
@<@A
24CLActiveConfigRecorderDb
20CLActivityRecorderDbI13ConfigSummaryN12CLActivityDB22NoDataProtectionPolicyEE
15CLNameValuePair
20CLMonitorGpsExternal
N21CLMonitorGpsInterface8ExternalE
14CLFileDownload
NSt3__110__function6__funcIZN23CLMicroLocationPowerLogC1ER23CLMicroLocationDatabaseE3$_0NS_9allocatorIS5_EEFvNS_8functionIFbvEEEEEE
ZN23CLMicroLocationPowerLogC1ER23CLMicroLocationDatabaseE3$_0
26CLMoveMinuteEstimatorYouth
/n3?
24CLSedentaryTimerNotifier
10CLNotifierIN29CLSedentaryTimerNotifier_Type12NotificationENS0_16NotificationDataEccE
25CLStandPlusMinuteProtocol
N29CLSedentaryTimerNotifier_Type6ClientE
16CLNotifierClientIN29CLSedentaryTimerNotifier_Type12NotificationENS0_16NotificationDataEccE
20CLNotifierClientBase
NSt3__120__shared_ptr_pointerIP26CLSedentaryAlarmRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI26CLSedentaryAlarmRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
NSt3__120__shared_ptr_emplaceIN29CLSedentaryTimerNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N29CLSedentaryTimerNotifier_Type16NotificationDataE
BehaviorOverrideAge
BehaviorOverrideGender
BehaviorOverrideHeight
BehaviorOverrideWeight
BehaviorOverridePal
BehaviorOverrideVO2Max
BehaviorOverrideMetMinPercentile
BehaviorOverrideMetMinCount
BehaviorOverrideWorkout
BehaviorOverrideHKWorkout
BehaviorOverrideThresholdConvergenceMinimumDayCount
BehaviorOverrideThresholdConvergenceMaximumDayCount
22CLYogaWorkoutStopModel
30CLMotionStateObserverCompanion
33CLNetworkLocationProviderExternal
34CLINetworkLocationProviderExternal
10BasicMutex
5Mutex
11NonCopyable
16CLDaemonSettings
NSt3__120__shared_ptr_pointerIP16CLDaemonSettingsN12_GLOBAL__N_112null_deleterENS_9allocatorIS1_EEEE
N12_GLOBAL__N_112null_deleterE
N13CLPreferences10OtherPrefsE
13CLPreferences
zDNSt3__120__shared_ptr_emplaceIN28CLBarometerCalibration_Types35CLBarometerCalibrationCompanionDataENS_9allocatorIS2_EEEE
@13CLDaemonCache
zt?{
zt?21CLSensorFusionService
36CLFitnessYouthGenericWorkoutOverride
.@17CLPersistentStore
17CLHomeKitProvider
10CLNotifierIN22CLHomeKitProvider_Type12NotificationENS0_16NotificationDataEccE
N22CLHomeKitProvider_Type6ClientE
16CLNotifierClientIN22CLHomeKitProvider_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN22CLHomeKitProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
N22CLHomeKitProvider_Type16NotificationDataE
19CLHarvestController
N24CLHarvestSystemInterface10ControllerE
N24CLHarvestSystemInterface13StatusMonitorE
N24CLHarvestSystemInterface15SourceRegistrarE
N24CLHarvestSystemInterface13ConfigurationE
N21CLMonitorGpsInterface11GpsReceiverE
18CLTelephonyService
10CLNotifierIN23CLTelephonyService_Type12NotificationENS0_16NotificationDataEccE
N23CLTelephonyService_Type6ClientE
16CLNotifierClientIN23CLTelephonyService_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN23CLTelephonyService_Type16NotificationDataENS_9allocatorIS2_EEEE
N23CLTelephonyService_Type16NotificationDataE
 B27CLTreadmillWorkoutStopModel
@13CLWifiService
10CLNotifierIN18CLWifiService_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
21CLWifiServiceExternal
N13CLWifiService9IExternalE
N18CLWifiService_Type6ClientE
16CLNotifierClientIN18CLWifiService_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
N18CLWifiService_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN18CLWifiService_Type16NotificationDataENS_9allocatorIS2_EEEE
N18CLWifiService_Type7RegInfoE
&@ff
19CLCalorieController
28CLFitnessControllerInterface
k@)\
OscarActivityForceCodeTransition
OscarStepCountingForceCodeTransition
5CLSPU
N25CLManagedLocationDatabaseI24CLNrCellLocationDatabaseN23CLTelephonyService_Type6NrCellEE8ExternalE
N25CLManagedLocationDatabaseI24CLNrCellLocationDatabaseN23CLTelephonyService_Type6NrCellEE9IExternalE
54CLStreamingAwareLocationProviderNoLocalGPSStateMachine
13CLMotionState
10CLNotifierIN18CLMotionState_Type12NotificationENS0_16NotificationDataEccE
N18CLMotionState_Type6ClientE
16CLNotifierClientIN18CLMotionState_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN18CLMotionState_Type16NotificationDataENS_9allocatorIS2_EEEE
N18CLMotionState_Type16NotificationDataE
12CLFileUpdate
25CLGyroCalibrationDatabase
10CLNotifierIN30CLGyroCalibrationDatabase_Type12NotificationENS0_16NotificationDataEccE
N30CLGyroCalibrationDatabase_Type6ClientE
16CLNotifierClientIN30CLGyroCalibrationDatabase_Type12NotificationENS0_16NotificationDataEccE
N30CLGyroCalibrationDatabase_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN30CLGyroCalibrationDatabase_Type16NotificationDataENS_9allocatorIS2_EEEE
?16CLTransitMacTile
NSt3__120__shared_ptr_pointerIP7NSErrorZN21CLObjNotificationDataIS1_EC1ES2_EUlS2_E_NS_9allocatorIS1_EEEE
ZN21CLObjNotificationDataI7NSErrorEC1EPS0_EUlS2_E_
19CLCompanionNotifier
10CLNotifierIN24CLCompanionNotifier_Type12NotificationENS0_16NotificationDataEcNS0_16RegistrationInfoEE
N24CLCompanionNotifier_Type16NotificationDataE
N24CLCompanionNotifier_Type16RegistrationInfoE
32CLOutdoorCyclingActiveStateModel
25CLWorkoutActiveStateModel
NSt3__110__function6__funcIZNK32CLOutdoorCyclingActiveStateModel27computeHisoricalGPSStats1HzERKN24CLWorkoutPredictorInputs5ItemsERKS3_E3$_0NS_9allocatorIS9_EEFvRK15CLOdometerEntryEEE
ZNK32CLOutdoorCyclingActiveStateModel27computeHisoricalGPSStats1HzERKN24CLWorkoutPredictorInputs5ItemsERKS0_E3$_0
25CLNoSqliteConnectionError
16CLSqliteDatabase
NSt3__115basic_stringbufIcNS_11char_traitsIcEENS_9allocatorIcEEEE
14CLDaemonStatus
10CLNotifierIN19CLDaemonStatus_Type12NotificationENS0_16NotificationDataEccE
N19CLDaemonStatus_Type6ClientE
16CLNotifierClientIN19CLDaemonStatus_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN19CLDaemonStatus_Type16NotificationDataENS_9allocatorIS2_EEEE
N19CLDaemonStatus_Type16NotificationDataE
?Va3
?Ef.py
v.L@
z$@{
29CLNetworkLocationRequesterALS
26CLNetworkLocationRequester
?18CLLocationDatabase
24CLVO2MaxOutputRecorderDb
20CLActivityRecorderDbI12VO2MaxOutputN12CLActivityDB22NoDataProtectionPolicyEE
19CMGyroBiasEstimator
@18CLTimeZoneDatabase
17CLPolygonDatabase
19CLNatalieDummyModel
NSt3__120__shared_ptr_pointerIP26CLCalorieCalisthenicsModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_26CLCalorieCalisthenicsModelEE
NSt3__120__shared_ptr_pointerIP22CLCalorieClimbingModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_22CLCalorieClimbingModelEE
NSt3__120__shared_ptr_pointerIP27CLNatalieCrossTrainingModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_27CLNatalieCrossTrainingModelEE
NSt3__120__shared_ptr_pointerIP19CLNatalieCycleModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_19CLNatalieCycleModelEE
NSt3__120__shared_ptr_pointerIP19CLNatalieDanceModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_19CLNatalieDanceModelEE
NSt3__120__shared_ptr_pointerIP25CLCalorieDownhillSkiModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_25CLCalorieDownhillSkiModelEE
NSt3__120__shared_ptr_pointerIP19CLNatalieDummyModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_19CLNatalieDummyModelEE
NSt3__120__shared_ptr_pointerIP24CLNatalieEllipticalModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_24CLNatalieEllipticalModelEE
NSt3__120__shared_ptr_pointerIP27CLNatalieHighIntensityModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_27CLNatalieHighIntensityModelEE
NSt3__120__shared_ptr_pointerIP31CLCalorieOutdoorWheelchairModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_31CLCalorieOutdoorWheelchairModelEE
NSt3__120__shared_ptr_pointerIP24CLNataliePedestrianModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_24CLNataliePedestrianModelEE
NSt3__120__shared_ptr_pointerIP20CLNatalieRowingModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_20CLNatalieRowingModelEE
NSt3__120__shared_ptr_pointerIP22CLNatalieSemiStatModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_22CLNatalieSemiStatModelEE
NSt3__120__shared_ptr_pointerIP32CLCalorieSemiStatWheelchairModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_32CLCalorieSemiStatWheelchairModelEE
NSt3__120__shared_ptr_pointerIP27CLNatalieStairClimbingModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_27CLNatalieStairClimbingModelEE
NSt3__120__shared_ptr_pointerIP29CLNatalieStationaryCycleModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_29CLNatalieStationaryCycleModelEE
NSt3__120__shared_ptr_pointerIP22CLCalorieSwimmingModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_22CLCalorieSwimmingModelEE
NSt3__120__shared_ptr_pointerIP28CLCalorieWheelchairPushModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_28CLCalorieWheelchairPushModelEE
NSt3__120__shared_ptr_pointerIP18CLCalorieYogaModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_18CLCalorieYogaModelEE
NSt3__120__shared_ptr_pointerIP32CLCalorieFunctionalStrengthModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_32CLCalorieFunctionalStrengthModelEE
NSt3__120__shared_ptr_pointerIP20CLCalorieTaiChiModelNS_10shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalieModelInterfaceE27__shared_ptr_default_deleteIS1_20CLCalorieTaiChiModelEE
?13CLTimeManager
10CLNotifierIN18CLTimeManager_Type12NotificationENS0_16NotificationDataEccE
N18CLTimeManager_Type6ClientE
16CLNotifierClientIN18CLTimeManager_Type12NotificationENS0_16NotificationDataEccE
N18CLTimeManager_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN18CLTimeManager_Type16NotificationDataENS_9allocatorIS2_EEEE
4@20CLLocationController
N25CLLocationController_Type6ClientE
NSt3__110__function6__funcIZN20CLLocationControllerC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0NS_9allocatorIS5_EEFvRKN27CLGnssAvailabilityPredictor6OutputEEEE
NSt3__110__function6__baseIFvRKN27CLGnssAvailabilityPredictor6OutputEEEE
ZN20CLLocationControllerC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0
@22CLWifiLocationProvider
N27CLWifiLocationProvider_Type6ClientE
NSt3__120__shared_ptr_emplaceI41CLWifiLocation5GHzChannelSelectionServiceNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI45CLNoCacheLookupWifiAccessPointLocationServiceNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI18CLBatchedLocationsNS_9allocatorIS1_EEEE
@23CLNatalieModelInterface
kMostRecentWorkoutEventWorkoutType
kMostRecentWorkoutEventLocationType
com.apple.locationd.bundle-/System/Library/LocationBundles/MotionCalibration.bundle
21CLMotionStateMediator
10CLNotifierIN26CLMotionStateMediator_Type12NotificationENS0_16NotificationDataEccE
23CLIndoorOutdoorProtocol
N26CLMotionStateMediator_Type6ClientE
16CLNotifierClientIN26CLMotionStateMediator_Type12NotificationENS0_16NotificationDataEccE
20CMFiniteStateMachine
30CLWorkoutPredictorSourceBufferIN28CLMotionCoprocessorInterface11MotionStateEE
36CLWorkoutPredictorSourcePreprocessorIN28CLMotionCoprocessorInterface11MotionStateEE
29CLWorkoutPredictorSourcesImplI36CLWorkoutPredictorSourceFromNotifierI22CLElevationChangeEntryES0_I15CLCatherineDataE43CLWorkoutPredictorExternallyActivatedSourceI15CLOdometerEntryES0_I16CLStepCountEntryES0_I24CLExtendedStepCountEntryES5_IN24CLWorkoutClassifier_Type25CLWorkoutClassifierResultEE30CLWorkoutPredictorSourceBufferISD_ES5_IN30CLWorkoutPredictorTurnDetector4TurnEES0_I11CLSwimEntryESF_I31CLWorkoutPredictorWatchPressureESF_I20CLExerciseMinuteDataES5_IN27CLCyclingStateDetector_Type13CyclingResultEES5_IN28CLMotionCoprocessorInterface20Tier1CyclingFeaturesEEE
25CLWorkoutPredictorSources
43CLWorkoutPredictorExternallyActivatedSourceIN28CLMotionCoprocessorInterface20Tier1CyclingFeaturesEE
30CLWorkoutPredictorSourceBufferIN28CLMotionCoprocessorInterface20Tier1CyclingFeaturesEE
36CLWorkoutPredictorSourcePreprocessorIN28CLMotionCoprocessorInterface20Tier1CyclingFeaturesEE
43CLWorkoutPredictorExternallyActivatedSourceIN27CLCyclingStateDetector_Type13CyclingResultEE
30CLWorkoutPredictorSourceBufferIN27CLCyclingStateDetector_Type13CyclingResultEE
36CLWorkoutPredictorSourcePreprocessorIN27CLCyclingStateDetector_Type13CyclingResultEE
30CLWorkoutPredictorSourceBufferI20CLExerciseMinuteDataE
36CLWorkoutPredictorSourcePreprocessorI20CLExerciseMinuteDataE
30CLWorkoutPredictorSourceBufferI31CLWorkoutPredictorWatchPressureE
36CLWorkoutPredictorSourcePreprocessorI31CLWorkoutPredictorWatchPressureE
36CLWorkoutPredictorSourceFromNotifierI11CLSwimEntryE
30CLWorkoutPredictorSourceBufferI11CLSwimEntryE
36CLWorkoutPredictorSourcePreprocessorI11CLSwimEntryE
43CLWorkoutPredictorExternallyActivatedSourceIN30CLWorkoutPredictorTurnDetector4TurnEE
30CLWorkoutPredictorSourceBufferIN30CLWorkoutPredictorTurnDetector4TurnEE
36CLWorkoutPredictorSourcePreprocessorIN30CLWorkoutPredictorTurnDetector4TurnEE
30CLWorkoutPredictorSourceBufferIN24CLWorkoutClassifier_Type25CLWorkoutClassifierResultEE
36CLWorkoutPredictorSourcePreprocessorIN24CLWorkoutClassifier_Type25CLWorkoutClassifierResultEE
43CLWorkoutPredictorExternallyActivatedSourceIN24CLWorkoutClassifier_Type25CLWorkoutClassifierResultEE
36CLWorkoutPredictorSourceFromNotifierI24CLExtendedStepCountEntryE
30CLWorkoutPredictorSourceBufferI24CLExtendedStepCountEntryE
36CLWorkoutPredictorSourcePreprocessorI24CLExtendedStepCountEntryE
36CLWorkoutPredictorSourceFromNotifierI16CLStepCountEntryE
30CLWorkoutPredictorSourceBufferI16CLStepCountEntryE
36CLWorkoutPredictorSourcePreprocessorI16CLStepCountEntryE
43CLWorkoutPredictorExternallyActivatedSourceI15CLOdometerEntryE
30CLWorkoutPredictorSourceBufferI15CLOdometerEntryE
36CLWorkoutPredictorSourcePreprocessorI15CLOdometerEntryE
36CLWorkoutPredictorSourceFromNotifierI15CLCatherineDataE
30CLWorkoutPredictorSourceBufferI15CLCatherineDataE
36CLWorkoutPredictorSourcePreprocessorI15CLCatherineDataE
36CLWorkoutPredictorSourceFromNotifierI22CLElevationChangeEntryE
30CLWorkoutPredictorSourceBufferI22CLElevationChangeEntryE
36CLWorkoutPredictorSourcePreprocessorI22CLElevationChangeEntryE
NSt3__120__shared_ptr_emplaceI40CLNonInterruptingTimerWithPowerAssertionNS_9allocatorIS1_EEEE
NSt3__110__function6__funcIZN21CLMotionStateMediatorC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0NS_9allocatorIS5_EEFvN23CLWorkoutPredictor_Type12NotificationENS8_16NotificationDataEEEE
NSt3__110__function6__baseIFvN23CLWorkoutPredictor_Type12NotificationENS2_16NotificationDataEEEE
ZN21CLMotionStateMediatorC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0
NSt3__110__function6__funcIZN21CLMotionStateMediatorC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_1NS_9allocatorIS5_EEFvdEEE
NSt3__110__function6__baseIFvdEEE
ZN21CLMotionStateMediatorC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_1
N16CLMotionNotifier14SiloDispatcherIN28CLMotionCoprocessorInterface16NotificationDataEEE
NSt3__110__function6__funcIZN21CLMotionStateMediatorC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_2NS_9allocatorIS5_EEFbbEEE
NSt3__110__function6__baseIFbbEEE
ZN21CLMotionStateMediatorC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_2
NSt3__120__shared_ptr_emplaceIN26CLMotionStateMediator_Type16NotificationDataENS_9allocatorIS2_EEEE
N26CLMotionStateMediator_Type16NotificationDataE
NSt3__120__shared_ptr_pointerIP21CLMotionStateOverrideNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI21CLMotionStateOverrideE27__shared_ptr_default_deleteIS1_S1_EE
18CLLocationProvider
10CLNotifierIN23CLLocationProvider_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
22CLCellLocationDatabase
NSt3__110__function6__funcIZNK31CLWorkoutPredictorTier2Smoother24calculateAveragePressureEddE3$_0NS_9allocatorIS3_EEFvRK31CLWorkoutPredictorWatchPressureEEE
NSt3__110__function6__baseIFvRK31CLWorkoutPredictorWatchPressureEEE
ZNK31CLWorkoutPredictorTier2Smoother24calculateAveragePressureEddE3$_0
NSt3__110__function6__funcIZNK31CLWorkoutPredictorTier2Smoother31areEnoughExerciseMinutesPresentEiE3$_1NS_9allocatorIS3_EEFvRK20CLExerciseMinuteDataEEE
NSt3__110__function6__baseIFvRK20CLExerciseMinuteDataEEE
ZNK31CLWorkoutPredictorTier2Smoother31areEnoughExerciseMinutesPresentEiE3$_1
el?H
b`MO
Mb`?
@22CLWifiLocationDatabase
@25CLNetworkLocationProvider
10CLNotifierIN30CLNetworkLocationProvider_Type12NotificationENS0_16NotificationDataEccE
N30CLNetworkLocationProvider_Type6ClientE
16CLNotifierClientIN30CLNetworkLocationProvider_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN30CLNetworkLocationProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
N30CLNetworkLocationProvider_Type16NotificationDataE
N23CLTelephonyService_Type4CellE
N23CLTelephonyService_Type8CdmaCellE
N23CLTelephonyService_Type7LteCellE
N23CLTelephonyService_Type6NrCellE
28CLPersistentSubscriptionBase
NSt3__123enable_shared_from_thisI28CLPersistentSubscriptionBaseEE
@34CLExerciseMinuteIntensityEstimator
25CLExerciseMinuteEstimator
38CLExerciseMinuteIntensityEstimatorBase
27CLAccessoryLocationProvider
N32CLAccessoryLocationProvider_Type6ClientE
NSt3__110__function6__funcIZN27CLAccessoryLocationProviderC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0NS_9allocatorIS5_EEFvb14CLLocationTypeEEE
NSt3__110__function6__baseIFvb14CLLocationTypeEEE
ZN27CLAccessoryLocationProviderC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0
NSt3__110__function6__funcIZN27CLAccessoryLocationProvider24registerForNotificationsEvE3$_1NS_9allocatorIS3_EEFvRK19CLMapsRouteHintDataEEE
ZN27CLAccessoryLocationProvider24registerForNotificationsEvE3$_1
@13CLDaemonStats
28CLFilteredLocationController
N23CLLastConfidentLocation9INotifierE
N33CLFilteredLocationController_Type6ClientE
N23CLLocationProvider_Type16NotificationDataE
A27CLRegionPreloadManifestTile
14CLPlatformInfo
x?31CLFitnessYouthBriskWalkOverride
26CLFitnessYouthTypeOverride
21CLPedestrianStopModel
18CLWorkoutStopModel
?10CLCompass6
N16CLMotionNotifier26SingleSamplePollDispatcherIN15CLAccelerometer6SampleEEE
N16CLMotionNotifier26SingleSamplePollDispatcherIN14CLDeviceMotion6SampleEEE
NSt3__120__shared_ptr_emplaceI40CLHarvestPassKitPaymentUsageNotificationNS_9allocatorIS1_EEEE
30CLWifiLocationProviderExternal
N22CLWifiLocationProvider9IExternalE
NSt3__120__shared_ptr_emplaceI30CLWifiLocationProviderExternalNS_9allocatorIS1_EEEE
26CLBTLEFenceManagerConcrete
333333
ffffff
?NSt3__110__function6__funcIZN27CLGnssAvailabilityPredictorC1EPU30objcproto19CLIntersiloUniverse11objc_objectNS_8functionIFvRKNS2_6OutputEEEEE3$_0NS_9allocatorISB_EEFv32CLAmbientLightDecisionTreeOutputdEEE
NSt3__110__function6__baseIFv32CLAmbientLightDecisionTreeOutputdEEE
ZN27CLGnssAvailabilityPredictorC1EPU30objcproto19CLIntersiloUniverse11objc_objectNSt3__18functionIFvRKNS_6OutputEEEEE3$_0
34CLExerciseMinuteThresholdEstimator
NSt3__110__function6__funcIZN34CLExerciseMinuteThresholdEstimator22computeExerciseMinutesEvE3$_0NS_9allocatorIS3_EEFvRK31CLExerciseMinuteIntensitySampledEEE
ZN34CLExerciseMinuteThresholdEstimator22computeExerciseMinutesEvE3$_0
NSt3__120__shared_ptr_pointerIP15CLSkiRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI15CLSkiRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
23CLOdometerNotifierWatch
32CLCyclingWorkoutDistanceProtocol
14CLNotifierBase
15CLClientManager
10CLNotifierIN20CLClientManager_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
N19CLInUseLevelTracker8DelegateE
`OzkA
N15CLClientManager40PersistentSubscriptionPersistenceBackendE
N28CLPersistentSubscriptionBase18PersistenceBackendE
N20CLClientManager_Type6ClientE
16CLNotifierClientIN20CLClientManager_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
NSt3__120__shared_ptr_emplaceI19CLInUseLevelTrackerNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI29CLVisitMonitoringSubscriptionNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI18CLPushSubscriptionNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceIN20CLClientManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N20CLClientManager_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceI17CLSLCSubscriptionNS_9allocatorIS1_EEEE
N20CLClientManager_Type4NameE
NSt3__120__shared_ptr_emplaceIN15CLClientManager40PersistentSubscriptionPersistenceBackendENS_9allocatorIS2_EEEE
N20CLClientManager_Type7RegInfoE
30CLVO2MaxRetrocomputeRecorderDb
20CLActivityRecorderDbI25VO2MaxRetrocomputeHistoryN12CLActivityDB22NoDataProtectionPolicyEE
23CLTileFileWithTraversal
NSt3__120__shared_ptr_emplaceIN28CLBarometerCalibration_Types34CLBarometerCalibrationLocationDataENS_9allocatorIS2_EEEE
17CLCarrierSettings
10CLNotifierIN22CLCarrierSettings_Type12NotificationENS0_16NotificationDataEccE
N22CLCarrierSettings_Type6ClientE
16CLNotifierClientIN22CLCarrierSettings_Type12NotificationENS0_16NotificationDataEccE
N22CLCarrierSettings_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN22CLCarrierSettings_Type16NotificationDataENS_9allocatorIS2_EEEE
30CLFitnessTrackingNotifierWatch
?N4swan19RouteSmootherConfigE
N8cnconfig12ConfigLoaderILj256EEE
NSt3__114basic_ifstreamIcNS_11char_traitsIcEEEE
NSt3__113basic_filebufIcNS_11char_traitsIcEEEE
N5boost16bad_lexical_castE
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_16bad_lexical_castEEEEE
N5boost16exception_detail19error_info_injectorINS_16bad_lexical_castEEE
N5boost6detail17basic_unlockedbufINSt3__115basic_streambufIcNS2_11char_traitsIcEEEEcEE
N5boost6detail16basic_pointerbufIcNSt3__115basic_streambufIcNS2_11char_traitsIcEEEEEE
N8cnmatrix8CNMatrixILj6ELj1EdEE
N8cnmatrix12CNMatrixBaseIdEE
N8cnmatrix8CNMatrixILj6ELj6EdEE
N12CLParticleMM30CLParticleMapMatcherFilterBaseE
24CLNrCellLocationDatabase
>23CLElevationSubscription
23CLTransientSubscriptionI23CLElevationSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI23CLElevationSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR23CLElevationSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI23CLElevationSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI23CLElevationSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI23CLElevationSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
34CLWatchOrientationSettingsNotifier
10CLNotifierIN39CLWatchOrientationSettingsNotifier_Type12NotificationENS0_16NotificationDataEccE
N39CLWatchOrientationSettingsNotifier_Type6ClientE
16CLNotifierClientIN39CLWatchOrientationSettingsNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN39CLWatchOrientationSettingsNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N39CLWatchOrientationSettingsNotifier_Type16NotificationDataE
>@27CLNatalieStairClimbingModel
20CLPolicyTripExternal
N21CLPolicyTripInterface8ExternalE
>16CMOnBodyDetector
27CLSensorFusionServiceLegacy
UUUUUU
39CLCorrectiveCompensatedLocationProvider
N44CLCorrectiveCompensatedLocationProvider_Type6ClientE
31CLDelegatingCallbackDropManager
21CLCallbackDropManager
NSt3__120__shared_ptr_emplaceIiNS_9allocatorIiEEEE
N23CLLocationProvider_Type7RegInfoE
?26CLCachedLocationController
N16CLIRouteListener9INotifierE
10CLNotifierIN31CLCachedLocationController_Type12NotificationENS0_16NotificationDataEccE
N31CLCachedLocationController_Type6ClientE
16CLNotifierClientIN31CLCachedLocationController_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN31CLCachedLocationController_Type16NotificationDataENS_9allocatorIS2_EEEE
N31CLCachedLocationController_Type16NotificationDataE
vq+A
@NSt3__120__shared_ptr_pointerIP30CLWorkloadCalibratorRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI30CLWorkloadCalibratorRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
27CLOdometerNotifierCompanion
N5boost16exception_detail10clone_implINS0_19error_info_injectorISt13runtime_errorEEEE
N5boost16exception_detail19error_info_injectorISt13runtime_errorEE
N5boost16exception_detail10clone_baseE
v@UUUUUU
?ffffff
StrideCalibrationLastCalibration
StrideCalibrationLastCalibrationAttempt
LastStrideCalibrationConverge
CLAV
24CLMapRouteHintController
25CLFitnessTrackingNotifier
10CLNotifierIN30CLFitnessTrackingNotifier_Type12NotificationENS0_16NotificationDataEccE
N30CLFitnessTrackingNotifier_Type6ClientE
16CLNotifierClientIN30CLFitnessTrackingNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN30CLFitnessTrackingNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N30CLFitnessTrackingNotifier_Type16NotificationDataE
>21CLSkiDataSubscription
23CLTransientSubscriptionI21CLSkiDataSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLSkiDataSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR21CLSkiDataSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLSkiDataSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI21CLSkiDataSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI21CLSkiDataSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
y@29CMAccelerometerProcessorWatch
>14CLFenceManager
10CLNotifierIN19CLFenceManager_Type12NotificationENS0_16NotificationDataEcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE
N19CLFenceManager_Type6ClientE
16CLNotifierClientIN19CLFenceManager_Type12NotificationENS0_16NotificationDataEcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE
NSt3__120__shared_ptr_emplaceIN19CLFenceManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N19CLFenceManager_Type16NotificationDataE
C25CLMotionAlarmSubscription
23CLTransientSubscriptionI25CLMotionAlarmSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI25CLMotionAlarmSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR25CLMotionAlarmSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI25CLMotionAlarmSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI25CLMotionAlarmSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI25CLMotionAlarmSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
SavedInitialMotionCalsToWatch
22CLMotionSyncStoreWatch
18CLFenceMonitorCell
=?NSt3__110__function6__funcIZN20CLWifiTileBlobsTable20saveWifiTileBlobDataERK20CLWifiTileBlobsEntryNS_8optionalIPN16CLWifiTileParser22MemoryMappedFileHandleEEEE3$_0NS_9allocatorISB_EEFvP12sqlite3_blobEEE
NSt3__110__function6__baseIFvP12sqlite3_blobEEE
ZN20CLWifiTileBlobsTable20saveWifiTileBlobDataERK20CLWifiTileBlobsEntryNSt3__18optionalIPN16CLWifiTileParser22MemoryMappedFileHandleEEEE3$_0
NSt3__110__function6__funcIZN20CLWifiTileBlobsTable16findMacAddressesERKNS_6vectorI12CLMacAddressNS_9allocatorIS4_EEEEiiiE3$_3NS5_ISA_EEFvP12sqlite3_blobEEE
ZN20CLWifiTileBlobsTable16findMacAddressesERKNSt3__16vectorI12CLMacAddressNS0_9allocatorIS2_EEEEiiiE3$_3
NSt3__110__function6__funcIZN20CLWifiTileBlobsTable22serializeTileDataForXYERK10WifiTileXYE3$_4NS_9allocatorIS6_EEFvP12sqlite3_blobEEE
ZN20CLWifiTileBlobsTable22serializeTileDataForXYERK10WifiTileXYE3$_4
20CLWorkoutStopModelHR
B@,F]k
19CLSwimAlgController
N10CLMobility22BoutBoundaryRecorderDbE
20CLActivityRecorderDbIN10CLMobility12BoutBoundaryEN12CLActivityDB22NoDataProtectionPolicyEE
N10CLMobility20BoutBoundaryDelegateE
StrideCalAWD0
StrideCalAWD1
12CLMonitorGps
N25CLHarvestMonitorInterface3GpsE
>25CLNatalimetrySubscription
23CLTransientSubscriptionI25CLNatalimetrySubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI25CLNatalimetrySubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR25CLNatalimetrySubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI25CLNatalimetrySubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI25CLNatalimetrySubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI25CLNatalimetrySubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
21CLMotionAlarmNotifier
10CLNotifierIN18CLMotionAlarm_Type12NotificationENS0_16NotificationDataEccE
N18CLMotionAlarm_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN18CLMotionAlarm_Type16NotificationDataENS_9allocatorIS2_EEEE
26CLCdmaCellLocationDatabase
"!"!"
%/<=:3+
1A<9/)
-?>;/0*
!;4340#(!
5<:.$
!:IJ?2 $
#4DL@43
-:9?.
"'--&'
27CLSimulatedLocationProvider
N32CLSimulatedLocationProvider_Type6ClientE
>16CLMotionNotifier
27CLWalkingSpeedCalRecorderDb
20CLActivityRecorderDbI21WalkingSpeedStrideCalN12CLActivityDB22NoDataProtectionPolicyEE
33WalkingStrideCalReportingDelegate
NSt3__120__shared_ptr_pointerIP10CLSettingsNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI10CLSettingsE27__shared_ptr_default_deleteIS1_S1_EE
B24CLNatalieEllipticalModel
#@18CLVO2MaxInputCache
20CLActivityRecorderDbI11VO2MaxInputN12CLActivityDB22NoDataProtectionPolicyEE
28CLSensorFusionService6AxisAP
23CLVO2MaxAlertRecorderDb
20CLActivityRecorderDbI11VO2MaxAlertN12CLActivityDB22NoDataProtectionPolicyEE
18CLSensorRecorderDb
20CLActivityRecorderDbI26CLSensorRecorderDataPacketN12CLActivityDB22NoDataProtectionPolicyEE
?333333
?ffffff
|a2U
30CLKappaQualifierAlgBlockResult
24CLKappaQualifierAlgBlock
22CLNonInterruptingTimer
45CLICachedLookupWifiAccessPointLocationService
45CLNoCacheLookupWifiAccessPointLocationService
21CLGestureSubscription
23CLTransientSubscriptionI21CLGestureSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLGestureSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR21CLGestureSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLGestureSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
DmWSl
rsS?
?#vCZOM
?jO1
?PD9TYL
y6u=
{&@v
@ffffff
?WBz 
?WyD
\JTcl
?v>L
?,pR=
?b}e
 VpD
?w+o
I2Qe
?P:u
?,GL<
?J!!
<-fT
OEyN
?wR#g
?b+7
ZD66
?xOz
?eZ-z
?yA@
?.X/N
?bN=Q
?yRu#8b
?bQ\x
?3SA
?,GL<
?L[Rv
Ufqv7
?M!D
;CWT
?52e
??!=
?`oa
?bFF
}JP\
?^h!
?({I
?lB[
?>!=
?aoa
?>!=
?aoa
?w-J
0:MI
~~La
?=!=
?boa
?"H<
zE3p
?4(m;x
??u4
?".z
?>!=
?aoa
?\om
wp59
?~_K
?b/{
?T1Y
?IMq9
?"yX*
Yns8e
,:t87
4*7)
?>!=
?aoa
% t5
?)^x)
?0Bs1u
?d%{+
?NmBj
?D#?#Y
?L"O;"
?=N1
?|b,
??!=
?`oa
?hS+
0vh*X
,~^}
` nd
?.R#
?>!=
?aoa
F*ZG
?k$(
~T>N
?.R#
` nd
?dKD
?D,is
?R@M.
?F}y
?]AC
?;v@
J-QZ
?#F1
?~]}
?;tWYq
(5r%
?[hl
?'c%
?lNm"_0
?53$
??jp'Ja
(5r%
O1}8<
?f/Py-
?\TT
?Vc.
?0O?e
% t5
?plf
?dp{
-Gpi#
?v\=
?e/Py-
?+NLu
?Rts
?19$
?3Pd
?7+`;
UM$
,~^}
Ph^$
?d:ds
?" F
?1S.
?A!wI
=V;>
?0S:
?VXL
?Sp3
,~^}
?v{ 
pT@@
?b5v
?UGHP
2BD*
eQQ3
?|MWW
?p5Ym
?HeSI
._&P
$STN
?=.;
?zV,
?vN1
?qG5@
?!<`
6}tc
?=/(
?"j3
9n:c
?&>d
?Fg2
?`|5
?sa[
z%(/
?.v6`
xU3X
?bq5;
Lf:X
0IjO1
569,@
rK34
,~^}
$STN
?,Y^
?m5Q
?9-C
?#g
?D~U
569,@
I-e-
?~,29n
?m5Q
?<eL
?~>$
? _Ju
<[Mh
Q07l
?,^t
{=iU
?F<K
?<`@
?Sb!
4)0*g
?w[(y
?bt,
?~,29n
eQQ3
?|MWW
?"tw
_~*E
?Rje
?\+5W
(V?}
=I,Q
"y[mA
nCRI
?bnE\
?<#uG
?r|,E
?Fp|
?^3;K
?pQa
?e1&u`
Q#3z
?/eq
?b5v
|ilj5
?J!2
K!NJ
?sam
?ndh
?k`\
?:o%
_ir9
?~j@-
i=2I
fn.
?=.;
?9,g/
"y[mA
nCRI
?c:Kk
?jD+
?3Pd
?u"oVm
?jmc
)_a
??^Es
`C1x
?n}P
?ZpXn
?F)J
DK7/
?fvi
cARD
yAGpY
?[B0}
`hue
?3Ok
wY"9
?m2?
q[\}
0IjO1
f>D(
KNSp
?qQ4
yn|12
OlH}
?ZMxDf
?Bqz
5];>
i}:L
?qG5@
?T"`
?^j#
?r|,E
?AGLD[I
{fmiJ
?/~9
Cjc'N
i}:L
A(]!
O9@Q
?D~U
??^Es
?; v
A(]!
K!NJ
?tbq
?%%l
^U^k
^7vq
_ir9
?~j@-
??#jd
?bnE\
?<#uG
?#b!f
?nX>56}
eOuc
?0v4a
rCF9
?z@-
?2]th(
??^Es
&9@`:
EAiv
?Crk
?PZ=
?U_U
?VAU
?8,=
?bnE\
?<#uG
?ry(a
?%%l
?pIw
?;HP
? W?C|
?hdS
UsXP
?'ei
UcNxV
_ir9
?~j@-
?~oK."
?v_x
??^Es
?%5Fm
"y[mA
nCRI
?S<y1
?pz~
?7NE,
?0P-
?}w]
?8i,)PM
?RpCbN
d?Apb
?Bqz
h*V6q
?]~M
?*3(
CvuD
?Pv"
?ndh
L+?h
?``4
st{Z
?f8e
&9@`:
?e1&u`
?4HV8
97=
eOuc
?0v4a
?U+0
}146
?RdC>
<Z;0D
st{Z
kHU%
?Rje
?\+5W
?O7z
D$:/
RBFj
Z{s+
?Crk
;"KT
=Of7
?F,O
?>YU
?~"W
?VOX
?jRu
?x!)
?y<P
_]:q
?L/r
?+<.~
"N)H
t+{S
kHU%
I6 9U
?OUY
?bUM
?}~D
|Q;[
?\tC
kHU%
?5Q3
? :z
CvuD
?XrMq
pg^m
?+N2
<X:/
?QG+
x-1\n
?HQE^
]9tz
?('6@h}
?Q}#
_ir9
?~j@-
?XrMq
rCF9
?l36k 
xC&<
?>Th
?XrMq
i}:L
?o<t
?+^!
?~"W
dR=&
?oOCP
?Bqz
RBFj
Z{s+
?tN}
?JQE^
KrYw
?I1G
oJT#
eOuc
?0v4a
?jRu
37wB
?v=1,b
?{~E+EI
?S=#.N|
?HQE^
?^Dt){
k*GV
?(;
dR=&
nP1J
?5@Xy
?L/r
?,d8
?dv
?ln,,E
W\g<
?0A6;
Dc*J
?HQE^
vBoc
?rX"
??!q
?owhF
l!aq
?X7&
?JQE^
? ;\
?>'F\
?Ecto
?U[QR
Iv,N
pj,]
?~"W
GS'9
?5Q3
nP1J
?6YFY
(IaD
?8i,)PM
?4Q3
?rUuW
ea;b(
?Ecto
?tHI
}146
.hJ-
?n}P
?PO@g
L+?h
?":W
?Z:i
?&)B,W
?J>5
?*OTD
aWw=
?sMh
?zQ#D
?2z#
?+<.~
L+?h
?}Mi
?^J#
st{Z
!Rb$
[271
?{U{
?L=>\(
t|qdg
?c|s
PstX
1U'r
E"8f
6qnp
.Fz[
+g=
?Z\z
?X7&
?LB
?K`g:
?j?1
+g=
?sMP
?s;a
?r 
?R3&
5^\}
?|bk
6*]R
r>:)
r>:)
?G"D%
?*L"3G
?E;J
?LVo
?`y++
?2q$G-
r>:)
Z5{bg
?vly
?:zy
?4B^P
?X t
l3_J
?LN4f
s_ES
(IaD
?|l,S4
?4Q3
?=|M
?Pld
?R0CQ
rQ'J"
?im)
?n,c
vBoc
?6fZ_
Z5{bg
?Ot_
?6,
?Jqm
7b;k
a)j{m
1@om
OlH}
?KR]56w
W1HM
?Eo5
?j]L
]64o
?b_P
?6w6
?fUK
?07:
?VJb&
:giu
?gIp
?w7rF
?S32
?X&y{
5^\}
? J,O
?n|v
C1O@
?PC>
SpC<
?`MPK
?,>=8
?9hUb
?v9{4M`
a\2q
-S=|F
?D*A
lG:h
?woq
?_H<b
?4<v
CqV.
cDJK
?SGH
?2GR'
?Cu/J
N@A*
784=
?l.aq
WzG#
B\n"
?~a*
?6iq5
tOGn
?r.G
qU:c
& `m
?l><
?FLy
~WUv
+,Aw
?$S2
?J:o
?N:i
?Y82
?C;[72
?^bR
`LKo
?x_M
N3`p
?zz}_'
?H0i
?UAG
?V_\
?Q'|1z%
? x/
?es&YK
?M*]
_b.i
?9?V(
?z>8
?J-I%
?[i[
?fD^
?xCO
?=^4
?4 4;
?:["
?pOx-BD
?R*|
?z)s
`%CX
?1o36n
?fFQ8
?.;j
?74
w'{%
?E?=
?(\V
qSQ-D
?\jw
Jz0b
?G3Sl
?lUz
?RL
?G3Sl
?4aR
?3xE7o
?X #
6i&9
?*(k
? %=
?onh
?"#/
?jUt=
?mh!3
mSRF
?*VT!
Viz$$
?zeT
?XzC
6* T
?+Hu
?tX.8
wORd
?,;sx
?KTM
0H  
?S)`Q1j
?*BR
?$gX{
?z~(VqJ
?6Qu
?n%yf
?":Oa$
?JXb
?[9!\1
&A.8
?j'c
?D-*d
?8uZ
?v=)
{UT<
?U3
f)8v
?l4-
?]!QV
p%lX
?/(k~
?B)o8E
?Ms5
?l-4 
?trr
?*:*
?"'U9
?\9&Z
?WR3;
D-C6
?ZTGGZ
?j(8!
?_z=P
<7~<
{p`O
]CS|
v-,Yz
?ryx
?-Rf>fl
?Xe%
?0Rv
?^'2)
?ffffff
?333333
?333333
?333333
MbP?
19CLCatherineNotifier
10CLNotifierIN24CLCatherineNotifier_Type12NotificationENS0_16NotificationDataEccE
N24CLCatherineNotifier_Type6ClientE
16CLNotifierClientIN24CLCatherineNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN24CLCatherineNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N24CLCatherineNotifier_Type16NotificationDataE
26CLExerciseMinuteRecorderDb
20CLActivityRecorderDbI20CLExerciseMinuteDataN12CLActivityDB22NoDataProtectionPolicyEE
?ADDED
REMOVED
16CLIoHidInterface
N16CLIoHidInterface6DeviceE
?10CLCompass7
21CMDeviceMotionVisitor
N20CMDeviceMotionReport7VisitorE
NSt3__120__shared_ptr_emplaceIN16CLIoHidInterface6DeviceENS_9allocatorIS2_EEEE
Affffff
FallStatsSensorKitLoggingEnabled
FallStatsTapToRadarAllowedFall
FallStatsTapToRadarAllowedNearFall
FallStatsBackgroundSensorDataLoggingEnabled
FallStatsBackgroundAWDLoggingEnabled
FallStatsEnabled
FallStatsPressureEnabled
AnomalyDetectorEnabledKey
StatsRateLimitLastZeroed
StatsRateLimitCounter
ServerCleanUpFileStalenessThreshold
@ServerCleanUpTimerFireInterval
FallCyclingImpactGravityVarianceThreshold
=FallCyclingImpactCrownVarianceThreshold
FallCyclingImpactMaxAbsYThreshold
FallCyclingDistanceTraveledPostImpactThreshold
FallCyclingEpochsDetectedPostImpactThreshold
FallRefereeOperatingModeOverride
FallAllDayStateMachineOperatingModeOverride
FallCyclingStateMachineEnabledOverride
FallAllDayStateMachineEnabledOverride
14CLFallNotifier
10CLNotifierIN19CLFallNotifier_Type12NotificationEN12CLFall_Types16ImpactStreamDataEccE
N19CLFallNotifier_Type6ClientE
16CLNotifierClientIN19CLFallNotifier_Type12NotificationEN12CLFall_Types16ImpactStreamDataEccE
FallStatsSensorRecordingEnabled
AnomalyMotionInternalTest
FallOffWristLookbackBeforeImpactStartOfIntervalKey
FallOffWristLookbackBeforeImpactEndOfIntervalKey
FallOnWristAfterImpactStartOfIntervalKey
FallOnWristAfterImpactEndOfIntervalKey
$@FallLockedLookbackBeforeImpactStartOfIntervalKey
FallLockedLookbackBeforeImpactEndOfIntervalKey
FallMinimumOffChargerDurationKey
FallDelayBeforeShuttingDownAlgorithmsAfterLastClientDisconnect
FallAdditionalProfileLoggingEnabled
FallDelayBeforeBeforeReportingImpactCancelReason
FallDelayBeforeSendingSPUConfiguration
FallDelayBeforeWristAndChargerGating
FallOdometerHistorySize
FallStatsHeartRateEnabled
FallOffWristLoggingInterval
FallFullMslLoggingInSensorKitEnabled
NSt3__120__shared_ptr_emplaceIN12CLFall_Types16ImpactStreamDataENS_9allocatorIS2_EEEE
N12CLFall_Types16ImpactStreamDataE
N28CLMotionCoprocessorInterface16NotificationDataE
10CLMatrix3dIfE
?22CLSidebandSubscription
23CLTransientSubscriptionI22CLSidebandSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI22CLSidebandSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR22CLSidebandSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase14messageHandlerI22CLSidebandSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
A9CLCompass
N16CLMotionNotifier18CallbackDispatcherIbEE
@333C
@X9tB
@15CLEmergencyEED2
NSt3__120__shared_ptr_pointerIP15CLEmergencyEED2ZNS1_C1EPU30objcproto19CLIntersiloUniverse11objc_objectPU40objcproto29CLClientManagerPublicProtocol11objc_objectNS_8functionIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEENS_10shared_ptrI14CLEmergencyAWDEENS7_IFN4GNSS14DaemonLocationEvEEEE3$_0NS_9allocatorIS1_EEEE
ZN15CLEmergencyEED2C1EPU30objcproto19CLIntersiloUniverse11objc_objectPU40objcproto29CLClientManagerPublicProtocol11objc_objectNSt3__18functionIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEENS4_10shared_ptrI14CLEmergencyAWDEENS5_IFN4GNSS14DaemonLocationEvEEEE3$_0
NSt3__110__function6__funcIZN15CLEmergencyEED2C1EPU30objcproto19CLIntersiloUniverse11objc_objectPU40objcproto29CLClientManagerPublicProtocol11objc_objectNS_8functionIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEENS_10shared_ptrI14CLEmergencyAWDEENS7_IFN4GNSS14DaemonLocationEvEEEE3$_1NS_9allocatorISN_EEFRKNS2_6ConfigEvEEE
NSt3__110__function6__baseIFRKN15CLEmergencyEED26ConfigEvEEE
ZN15CLEmergencyEED2C1EPU30objcproto19CLIntersiloUniverse11objc_objectPU40objcproto29CLClientManagerPublicProtocol11objc_objectNSt3__18functionIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEENS4_10shared_ptrI14CLEmergencyAWDEENS5_IFN4GNSS14DaemonLocationEvEEEE3$_1
NSt3__110__function6__funcIZN15CLEmergencyEED2C1EPU30objcproto19CLIntersiloUniverse11objc_objectPU40objcproto29CLClientManagerPublicProtocol11objc_objectNS_8functionIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEENS_10shared_ptrI14CLEmergencyAWDEENS7_IFN4GNSS14DaemonLocationEvEEEE3$_2NS_9allocatorISN_EEFvP6NSDataPP19NSMutableURLRequestEEE
NSt3__110__function6__baseIFvP6NSDataPP19NSMutableURLRequestEEE
ZN15CLEmergencyEED2C1EPU30objcproto19CLIntersiloUniverse11objc_objectPU40objcproto29CLClientManagerPublicProtocol11objc_objectNSt3__18functionIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEENS4_10shared_ptrI14CLEmergencyAWDEENS5_IFN4GNSS14DaemonLocationEvEEEE3$_2
NSt3__110__function6__funcIZN15CLEmergencyEED27sendAdrEvE3$_3NS_9allocatorIS3_EEFvNS2_10NumberTypeEP13NSURLResponseP7NSErrorEEE
NSt3__110__function6__baseIFvN15CLEmergencyEED210NumberTypeEP13NSURLResponseP7NSErrorEEE
ZN15CLEmergencyEED27sendAdrEvE3$_3
22CLWorkoutClassifierGBT
20CLRunningBufferStatsIfE
16CLRunningMaximumIfE
B17CLCompassDatabase
10CLNotifierIN22CLCompassDatabase_Type12NotificationENS0_16NotificationDataEccE
N22CLCompassDatabase_Type6ClientE
16CLNotifierClientIN22CLCompassDatabase_Type12NotificationENS0_16NotificationDataEccE
N22CLCompassDatabase_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN22CLCompassDatabase_Type16NotificationDataENS_9allocatorIS2_EEEE
?31CLFitnessYouthHeartRateOverride
?24CLRowingWorkoutStopModel
mBN8cnmatrix8CNMatrixILj40ELj3EdEE
N8cnmatrix8CNMatrixILj1ELj3EdEE
N8cnmatrix8CNMatrixILj3ELj1EdEE
N8cnmatrix8CNMatrixILj40ELj40EdEE
N8cnmatrix8CNMatrixILj3ELj3EdEE
N8cnmatrix8CNMatrixILj20ELj3EdEE
N8cnmatrix8CNMatrixILj20ELj20EdEE
N8cnmatrix8CNMatrixILj1ELj1EiEE
N8cnmatrix12CNMatrixBaseIiEE
N8cnmatrix8CNMatrixILj3ELj1EiEE
N8cnmatrix11CNSubMatrixILj1ELj1ELj3ELj1EdEE
N8cnmatrix8CNMatrixILj6665ELj1EdEE
N8cnmatrix11CNSubMatrixILj3ELj1ELj1ELj1EdEE
N8cnmatrix8CNMatrixILj308ELj1EdEE
N8cnmatrix8CNMatrixILj1ELj1EdEE
N8cnmatrix8CNMatrixILj1ELj20EiEE
N8cnmatrix11CNSubMatrixILj1ELj20ELj3ELj1EdEE
N8cnmatrix8CNMatrixILj2645ELj1EdEE
31CLAttitudeDependentKFCalibrator
19CLCompassCalibrator
10CLVector3dIjE
?13CLPlosMatcher
5CLLog
NSt3__120__shared_ptr_pointerIP19CLCircularLogBufferNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI19CLCircularLogBufferE27__shared_ptr_default_deleteIS1_S1_EE
10CLSettings
v@aTR'
<wXv@
_>Y1\
?,am
1ZGUC?
QhG@
l@b2U0*
S?`TJd
GPwV=5
f@33
GO@32CLSwimDistanceEstimatorOpenWater
Hn?^
A28CLCalorieWheelchairPushModel
18CLCalorieYogaModel
=UUUUUU
?18CLSensorFusionMekf
14CLSensorFusion
@27CLNatalieHighIntensityModel
>21CLRangingSubscription
23CLTransientSubscriptionI21CLRangingSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLRangingSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR21CLRangingSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLRangingSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
Z&@'1
%@29CLNatalieStationaryCycleModel
N16CLBinaryLogTypes5AccelE
N16CLBinaryLogTypes10BinaryDataE
N16CLBinaryLogTypes12GyroOscarEmuE
N16CLBinaryLogTypes11GyroBiasFitE
N16CLBinaryLogTypes6GyroDtE
N16CLBinaryLogTypes7CompassE
N16CLBinaryLogTypes18CompassCalibrationE
N16CLBinaryLogTypes8PressureE
N16CLBinaryLogTypes29PressureFilteredNoTemperatureE
N16CLBinaryLogTypes12DeviceMotionE
N16CLBinaryLogTypes17MotionStateUpdateE
N16CLBinaryLogTypes12BTConnectionE
N16CLBinaryLogTypes15SessionOverrideE
N16CLBinaryLogTypes20EnhancedDeviceMotionE
N16CLBinaryLogTypes16NonlinearBiasFitE
N16CLBinaryLogTypes18OnsetHeartRateDataE
N16CLBinaryLogTypes12StrideCalBinE
N16CLBinaryLogTypes21CalorimetryPauseEventE
N16CLBinaryLogTypes8OdometerE
N16CLBinaryLogTypes8MetsInfoE
N16CLBinaryLogTypes9FallStatsE
N16CLBinaryLogTypes10FallConfigE
N16CLBinaryLogTypes9FallStateE
N16CLBinaryLogTypes16FallDataAccel800E
N16CLBinaryLogTypes14FallSensorDataILi3EEE
N16CLBinaryLogTypes15FallDataGyro200E
N16CLBinaryLogTypes19FallDataQuaternion6E
N16CLBinaryLogTypes14FallSensorDataILi4EEE
N16CLBinaryLogTypes14FallWristStateE
N16CLBinaryLogTypes36FallFalsePositiveSuppressionFeaturesE
N16CLBinaryLogTypes12FallDataHgalE
N16CLBinaryLogTypes28StepCadenceToStrideLengthBinE
N16CLBinaryLogTypes13MotionLoiDataE
N16CLBinaryLogTypes20OdometerWithAltitudeE
N16CLBinaryLogTypes30OdometerWithAltitudeAndRadiansE
N16CLBinaryLogTypes13AccelOscarEmuE
N16CLBinaryLogTypes19GyroBiasAndVarianceE
N16CLBinaryLogTypes16CompassAlignmentE
N16CLBinaryLogTypes16PressureOscarEmuE
N16CLBinaryLogTypes22StreamingHeartRateDataE
@31CLCalorieOutdoorWheelchairModel
;20CMDeviceMotionInputs
(-DT
?26CLMotionActivityLiteClient
HCff
?333?
L?fff?
?333?
L?fff?
@ff&@333@
Y@fff@33s@
@NSt3__119basic_ostringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
34CLFitnessTrackingNotifierCompanion
22CLTilesManagerExternal
23CLITilesManagerExternal
15CLSkiController
VO2MaxCloudKitSyncEngineMetadata
36CLVO2MaxCloudKitSyncEngineMetadataDb
20CLActivityRecorderDbI32VO2MaxCloudKitSyncEngineMetadataN12CLActivityDB22NoDataProtectionPolicyEE
34CLExerciseMinuteSustainedEstimator
NSt3__110__function6__funcIZN34CLExerciseMinuteSustainedEstimator22computeExerciseMinutesEvE3$_0NS_9allocatorIS3_EEFvRK31CLExerciseMinuteIntensitySampledEEE
ZN34CLExerciseMinuteSustainedEstimator22computeExerciseMinutesEvE3$_0
NSt3__110__function6__funcINS_6__bindIM26CLExerciseMinuteControllerFvRKN22CLExerciseMinute_Types14ExerciseMinuteEEJPS3_RKNS_12placeholders4__phILi1EEEEEENS_9allocatorISG_EEFvS7_EEE
NSt3__110__function6__baseIFvRKN22CLExerciseMinute_Types14ExerciseMinuteEEEE
NSt3__16__bindIM26CLExerciseMinuteControllerFvRKN22CLExerciseMinute_Types14ExerciseMinuteEEJPS1_RKNS_12placeholders4__phILi1EEEEEE
NSt3__118__weak_result_typeIM26CLExerciseMinuteControllerFvRKN22CLExerciseMinute_Types14ExerciseMinuteEEEE
NSt3__115binary_functionIP26CLExerciseMinuteControllerRKN22CLExerciseMinute_Types14ExerciseMinuteEvEE
@@18CLSwimAlgSimulator
?333333
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_8geometry21empty_input_exceptionEEEEE
N5boost16exception_detail19error_info_injectorINS_8geometry21empty_input_exceptionEEE
N5boost8geometry21empty_input_exceptionE
N5boost8geometry23invalid_input_exceptionE
N5boost8geometry9exceptionE
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_8geometry19turn_info_exceptionEEEEE
N5boost16exception_detail19error_info_injectorINS_8geometry19turn_info_exceptionEEE
N5boost8geometry19turn_info_exceptionE
14CLDaemonClient
N27CLTransientSubscriptionBase8DelegateE
N28CLPersistentSubscriptionBase10ConnectionE
NSt3__110__function6__funcIZN14CLDaemonClient25addPersistentSubscriptionI17CLSLCSubscriptionEEvvEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
NSt3__110__function6__baseIFvP14CLDaemonClientNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient25addPersistentSubscriptionI17CLSLCSubscriptionEEvvEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient25addPersistentSubscriptionI29CLVisitMonitoringSubscriptionEEvvEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient25addPersistentSubscriptionI29CLVisitMonitoringSubscriptionEEvvEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient25addPersistentSubscriptionI18CLPushSubscriptionEEvvEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient25addPersistentSubscriptionI18CLPushSubscriptionEEvvEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI19CLFenceSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI19CLFenceSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI22CLLocationSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI22CLLocationSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI21CLHeadingSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI21CLHeadingSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI21CLRangingSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI21CLRangingSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI23CLARKitHintSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
23CLARKitHintSubscription
23CLTransientSubscriptionI23CLARKitHintSubscriptionE
ZN14CLDaemonClient15addSubscriptionI23CLARKitHintSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI28CLPlaceInferenceSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI28CLPlaceInferenceSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI25CLNatalimetrySubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI25CLNatalimetrySubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI28CLSedentaryTimerSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI28CLSedentaryTimerSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI23CLStepCountSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI23CLStepCountSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI25CLMotionAlarmSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI25CLMotionAlarmSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI22CLOdometerSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI22CLOdometerSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI28CLExerciseMinuteSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI28CLExerciseMinuteSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI23CLElevationSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI23CLElevationSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI18CLFallSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI18CLFallSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI28CLMotionActivitySubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI28CLMotionActivitySubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI21CLWorkoutSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI21CLWorkoutSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI25CLMotionStateSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI25CLMotionStateSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI21CLSkiDataSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI21CLSkiDataSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI22CLSwimDataSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI22CLSwimDataSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI22CLSidebandSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI22CLSidebandSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI21CLGestureSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI21CLGestureSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI27CLActivityAlarmSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI27CLActivityAlarmSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI29CLOnBodyDetectionSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI29CLOnBodyDetectionSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI19CLKappaSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI19CLKappaSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI27CLIndoorOutdoorSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI27CLIndoorOutdoorSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient15addSubscriptionI20CLVO2MaxSubscriptionEEvbEUlPS2_NS_10shared_ptrI19CLConnectionMessageEEE_NS_9allocatorIS9_EEFvS5_S8_EEE
ZN14CLDaemonClient15addSubscriptionI20CLVO2MaxSubscriptionEEvbEUlPS_NSt3__110shared_ptrI19CLConnectionMessageEEE_
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_0NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_0
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_1NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_1
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_2NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_2
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_3NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_3
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_4NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_4
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_5NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_5
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_6NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_6
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_7NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_7
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_8NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_8
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE3$_9NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE3$_9
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_10NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_10
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_11NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_11
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_12NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_12
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_13NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_13
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_14NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_14
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_15NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_15
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_16NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_16
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_17NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_17
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_18NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_18
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_19NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_19
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_20NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_20
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_21NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_21
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_22NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_22
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_23NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_23
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_24NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_24
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_25NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_25
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_26NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_26
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_27NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_27
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_28NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_28
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_29NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_29
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_30NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_30
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_31NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_31
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_32NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_32
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_33NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_33
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_34NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_34
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_35NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_35
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_36NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_36
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_37NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_37
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_38NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_38
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_39NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_39
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_40NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_40
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_41NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_41
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_42NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_42
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_43NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_43
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_44NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_44
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_45NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_45
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_46NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_46
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_47NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_47
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_48NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_48
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_49NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_49
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_50NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_50
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_51NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_51
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_52NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_52
NSt3__110__function6__funcIZN14CLDaemonClient18populateHandlerMapEvE4$_53NS_9allocatorIS3_EEFvPS2_NS_10shared_ptrI19CLConnectionMessageEEEEE
ZN14CLDaemonClient18populateHandlerMapEvE4$_53
NSt3__120__shared_ptr_emplaceI19CLConnectionMessageNS_9allocatorIS1_EEEE
24CLBundleLocationProvider
NSt3__120__shared_ptr_pointerIP18CLBatchedLocationsNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI18CLBatchedLocationsE27__shared_ptr_default_deleteIS1_S1_EE
N16CLMotionNotifier10DispatcherE
N16CLMotionNotifier18CallbackDispatcherIN15CLAccelerometer6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN6CLGyro6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN6CLGyro11TemperatureEEE
N16CLMotionNotifier18CallbackDispatcherIN14CLMagnetometer6SampleEEE
N16CLMotionNotifier18CallbackDispatcherIN10CLPressure6SampleEEE
N16CLMotionNotifier14SiloDispatcherIN10CLMobility14SPUGaitMetricsEEE
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_7bad_getEEEEE
N5boost16exception_detail19error_info_injectorINS_7bad_getEEE
N5boost7bad_getE
NSt3__120__shared_ptr_emplaceINS_6vectorI15CLNADMarqueeAppNS_9allocatorIS2_EEEENS3_IS5_EEEE
36CLDaemonEmergencyEnablementAssertion
SentInitialMotionCalsToWatch
26CLMotionSyncStoreCompanion
NSt3__120__shared_ptr_emplaceIN22CLMotionSyncStore_Type16NotificationDataENS_9allocatorIS2_EEEE
?333333
?18CLBluetoothService
10CLNotifierIN23CLBluetoothService_Type12NotificationENS0_16NotificationDataEccE
N23CLBluetoothService_Type6ClientE
16CLNotifierClientIN23CLBluetoothService_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN23CLBluetoothService_Type16NotificationDataENS_9allocatorIS2_EEEE
N23CLBluetoothService_Type16NotificationDataE
@23CLSensorFusion9AxisMekf
28CLMotionCoprocessorInterface
20CLStepCountInterface
33CLMotionCoprocessorAlarmInterface
17CLOnBodyInterface
22CLNatalimetryInterface
25CLSedentaryAlarmInterface
19CLOdometerInterface
18CLCompassInterface
19CLSkiAlarmInterface
32CLTier1WorkoutDetectionInterface
40CLVisualLocalizationPropagationInterface
20CLAltimeterInterface
29CLAmbientLightSensorInterface
19CLGyroBiasInterface
ForceAPOnBodyDetection
16CLOnBodyNotifier
10CLNotifierIN21CLOnBodyNotifier_Type12NotificationENS0_16NotificationDataEccE
N21CLOnBodyNotifier_Type6ClientE
16CLNotifierClientIN21CLOnBodyNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN21CLOnBodyNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
?333333
 E@333333:@
@?-C
;E@T
MbP?
>@22CLDualModeKalmanFilter
N14CLKalmanFilter16KalmanTuningInfoE
N14CLKalmanFilter16KalmanParametersE
14CLKalmanFilter
L=ff&?
333333
z>28CLPlaceInferenceSubscription
23CLTransientSubscriptionI28CLPlaceInferenceSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI28CLPlaceInferenceSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR28CLPlaceInferenceSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase14messageHandlerI28CLPlaceInferenceSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
>26CLMotionStateObserverWatch
NSt3__120__shared_ptr_emplaceIN26CLMotionStateObserver_Type16NotificationDataENS_9allocatorIS2_EEEE
N26CLMotionStateObserver_Type16NotificationDataE
30CLOutdoorCycleWorkoutStopModel
C@29CLPressureCalibrationDatabase
10CLNotifierIN34CLPressureCalibrationDatabase_Type12NotificationENS0_16NotificationDataEccE
N34CLPressureCalibrationDatabase_Type6ClientE
16CLNotifierClientIN34CLPressureCalibrationDatabase_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN34CLPressureCalibrationDatabase_Type16NotificationDataENS_9allocatorIS2_EEEE
N34CLPressureCalibrationDatabase_Type16NotificationDataE
25CLGyroBiasEstimatorClient
p}<@{
0@NSt3__110__function6__funcIZN26CLLocationFilterControllerC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0NS_9allocatorIS5_EEFvRK19CLMapsRouteHintDataEEE
NSt3__110__function6__baseIFvRK19CLMapsRouteHintDataEEE
ZN26CLLocationFilterControllerC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0
21CLWifiFenceCalculator
@u@26CLSignificantChangeManager
N31CLSignificantChangeManager_Type6ClientE
V3fff?
@33s?
?17CLGestureNotifier
44CLAccelerometerIntegrationSamplingDispatcher
N16CLMotionNotifier18CallbackDispatcherIN17CLRestingNotifier16NotificationDataEEE
26CLSensorFusionService9Axis
v@24CLCoarseCellTilesManager
10CLNotifierIN29CLCoarseCellTilesManager_Type12NotificationENS0_16NotificationDataEccE
39CLITileDownloadSchedulingClientDelegate
N29CLCoarseCellTilesManager_Type6ClientE
16CLNotifierClientIN29CLCoarseCellTilesManager_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN29CLCoarseCellTilesManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N29CLCoarseCellTilesManager_Type16NotificationDataE
22CLWifiTileEntriesCache
23CILWifiTileEntriesCache
24CLWifiTileEntriesNoCache
?14CLDtwPrototype
 @:F
>20CLEarGestureNotifier
N16CLMotionNotifier18CallbackDispatcherIN17CLGestureNotifier16NotificationDataEEE
14CLMotionRandom
18CLMotionArc4Random
26CLActivityLoggerSizePolicy
NSt3__120__shared_ptr_pointerIP22CLActivityLoggerWriterNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI22CLActivityLoggerWriterE27__shared_ptr_default_deleteIS1_S1_EE
5@ffffff8@
$@20CLNatalieInputBufferI24CLExtendedStepCountEntryE
14CLNatalieInputI24CLExtendedStepCountEntryE
LAUU
19CLMagneticAccessory
10CLNotifierIN24CLMagneticAccessory_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN24CLMagneticAccessory_Type16NotificationDataENS_9allocatorIS2_EEEE
N24CLMagneticAccessory_Type16NotificationDataE
?333?
C29CLKappaQualifierAlgBaroResult
23CLKappaQualifierAlgBaro
NSt3__120__shared_ptr_emplaceI29CLKappaQualifierAlgBaroResultNS_9allocatorIS1_EEEE
LastKeyboardDisconnect
20CLKeyboardCoverState
?32CLVO2MaxStagingSummaryRecorderDb
20CLActivityRecorderDbI20VO2MaxStagingSummaryN12CLActivityDB22NoDataProtectionPolicyEE
Q8?20CLCalorieTaiChiModel
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
?333@ff
A333A
`AffvAff
Bff"B
-B333B
?333?
B30CLKappaQualifierAlgPulseResult
24CLKappaQualifierAlgPulse
NSt3__120__shared_ptr_emplaceI30CLKappaQualifierAlgPulseResultNS_9allocatorIS1_EEEE
>13CLSkiNotifier
10CLNotifierIN18CLSkiNotifier_Type12NotificationENS0_16NotificationDataEccE
N18CLSkiNotifier_Type6ClientE
16CLNotifierClientIN18CLSkiNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN18CLSkiNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N18CLSkiNotifier_Type16NotificationDataE
>N5CMMsl18FallWriterDelegateE
N5CMMsl6Writer8DelegateE
kCMActivityAlarmId
kCMActivityAlarmTrigger
kCMActivityAlarmDuration
kCMPressureBiasId
14CMFFTProcessor
31CLVisualLocalizationPropagation
 @10CLHRSETile
A26CLFenceDataDownloadManager
10CLNotifierIN31CLFenceDataDownloadManager_Type12NotificationENS0_16NotificationDataEccE
N31CLFenceDataDownloadManager_Type6ClientE
16CLNotifierClientIN31CLFenceDataDownloadManager_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN31CLFenceDataDownloadManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N31CLFenceDataDownloadManager_Type16NotificationDataE
VO2MaxPowerBudgetEstimatorQueryLookbackInterval
NSt3__110__function6__funcIZN28CLVO2MaxPowerBudgetEstimator13queryWorkoutsEdddE3$_0NS_9allocatorIS3_EEFvbNS_6vectorIN26CLHKHealthStoreAccessUtils11CLHKWorkoutENS4_IS8_EEEEEEE
NSt3__110__function6__baseIFvbNS_6vectorIN26CLHKHealthStoreAccessUtils11CLHKWorkoutENS_9allocatorIS4_EEEEEEE
ZN28CLVO2MaxPowerBudgetEstimator13queryWorkoutsEdddE3$_0
?27CLFenceAuthorizationManager
10CLNotifierIN32CLFenceAuthorizationManager_Type12NotificationENS0_16NotificationDataEccE
N32CLFenceAuthorizationManager_Type6ClientE
16CLNotifierClientIN32CLFenceAuthorizationManager_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN32CLFenceAuthorizationManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N32CLFenceAuthorizationManager_Type16NotificationDataE
@14CLFenceMonitor
10CLNotifierIN19CLFenceMonitor_Type12NotificationENS0_16NotificationDataEcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE
N19CLFenceMonitor_Type6ClientE
16CLNotifierClientIN19CLFenceMonitor_Type12NotificationENS0_16NotificationDataEcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE
N23CLFenceMonitorCell_Type6ClientE
N23CLFenceMonitorWifi_Type6ClientE
NSt3__110__function6__funcINS_6__bindIM14CLFenceMonitorFviRKN18CLWifiService_Type12NotificationERKNS4_16NotificationDataEEJRPS3_RKNS_12placeholders4__phILi1EEERKNSG_ILi2EEERKNSG_ILi3EEEEEENS_9allocatorISQ_EEFviS7_SA_EEE
NSt3__110__function6__baseIFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEEE
NSt3__16__bindIM14CLFenceMonitorFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEJRPS1_RKNS_12placeholders4__phILi1EEERKNSE_ILi2EEERKNSE_ILi3EEEEEE
NSt3__118__weak_result_typeIM14CLFenceMonitorFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEEE
NSt3__110__function6__funcIZN14CLFenceMonitor20getRequiredTechLevelERKN19CLFenceManager_Type5FenceERKN19CLFenceMonitorLogic21FenceMonitoringStatusERK16CLDaemonLocationE3$_0NS_9allocatorISE_EEFbS6_SD_EEE
NSt3__110__function6__baseIFbRKN19CLFenceManager_Type5FenceERK16CLDaemonLocationEEE
ZN14CLFenceMonitor20getRequiredTechLevelERKN19CLFenceManager_Type5FenceERKN19CLFenceMonitorLogic21FenceMonitoringStatusERK16CLDaemonLocationE3$_0
NSt3__110__function6__funcIZN14CLFenceMonitor20getRequiredTechLevelERKN19CLFenceManager_Type5FenceERKN19CLFenceMonitorLogic21FenceMonitoringStatusERK16CLDaemonLocationE3$_1NS_9allocatorISE_EEFbS6_SD_EEE
ZN14CLFenceMonitor20getRequiredTechLevelERKN19CLFenceManager_Type5FenceERKN19CLFenceMonitorLogic21FenceMonitoringStatusERK16CLDaemonLocationE3$_1
NSt3__110__function6__funcIZN14CLFenceMonitor20getRequiredTechLevelERKN19CLFenceManager_Type5FenceERKN19CLFenceMonitorLogic21FenceMonitoringStatusERK16CLDaemonLocationE3$_2NS_9allocatorISE_EEFbS6_SD_EEE
ZN14CLFenceMonitor20getRequiredTechLevelERKN19CLFenceManager_Type5FenceERKN19CLFenceMonitorLogic21FenceMonitoringStatusERK16CLDaemonLocationE3$_2
NSt3__120__shared_ptr_emplaceIN19CLFenceMonitor_Type16NotificationDataENS_9allocatorIS2_EEEE
N19CLFenceMonitor_Type16NotificationDataE
18CLFenceMonitorWifi
NSt3__110__function6__funcINS_6__bindIM18CLFenceMonitorWifiFviRKN18CLWifiService_Type12NotificationERKNS4_16NotificationDataEEJRPS3_RKNS_12placeholders4__phILi1EEERKNSG_ILi2EEERKNSG_ILi3EEEEEENS_9allocatorISQ_EEFviS7_SA_EEE
NSt3__16__bindIM18CLFenceMonitorWifiFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEJRPS1_RKNS_12placeholders4__phILi1EEERKNSE_ILi2EEERKNSE_ILi3EEEEEE
NSt3__118__weak_result_typeIM18CLFenceMonitorWifiFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEEE
NSt3__110__function6__funcIZN18CLFenceMonitorWifi21calculateAPsForFencesERKNS_3mapIN19CLFenceManager_Type5FenceEbNS_4lessIS5_EENS_9allocatorINS_4pairIKS5_bEEEEEERNS3_IS5_iS7_NS8_INS9_ISA_iEEEEEERNS_6vectorIN18CLWifiService_Type11AccessPointENS8_ISM_EEEESP_RKSO_iRbE3$_0NS8_IST_EEFvRSA_EEE
NSt3__110__function6__baseIFvRKN19CLFenceManager_Type5FenceEEEE
ZN18CLFenceMonitorWifi21calculateAPsForFencesERKNSt3__13mapIN19CLFenceManager_Type5FenceEbNS0_4lessIS3_EENS0_9allocatorINS0_4pairIKS3_bEEEEEERNS1_IS3_iS5_NS6_INS7_IS8_iEEEEEERNS0_6vectorIN18CLWifiService_Type11AccessPointENS6_ISK_EEEESN_RKSM_iRbE3$_0
14CLSkiSimulator
28CLSedentaryTimerSubscription
23CLTransientSubscriptionI28CLSedentaryTimerSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI28CLSedentaryTimerSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR28CLSedentaryTimerSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI28CLSedentaryTimerSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI28CLSedentaryTimerSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI28CLSedentaryTimerSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
26CLGeomagneticModelProvider
10CLNotifierIN31CLGeomagneticModelProvider_Type12NotificationENS0_16NotificationDataEccE
N31CLGeomagneticModelProvider_Type6ClientE
16CLNotifierClientIN31CLGeomagneticModelProvider_Type12NotificationENS0_16NotificationDataEccE
N31CLGeomagneticModelProvider_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN31CLGeomagneticModelProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
C20CLAWDMetricCollector
21CLMetricCollectorBase
KA27CLSignalEnvironmentProvider
10CLNotifierIN32CLSignalEnvironmentProvider_Type12NotificationENS0_16NotificationDataEccE
N32CLSignalEnvironmentProvider_Type6ClientE
16CLNotifierClientIN32CLSignalEnvironmentProvider_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN32CLSignalEnvironmentProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
N32CLSignalEnvironmentProvider_Type16NotificationDataE
N22CLWifiLocationDatabase8WifiDataE
30CLStairStepperWorkoutStopModel
Y@333333
?ffffff
>fff@
339B
Afff@17CLNatalieRunModel
k:17CLRestingNotifier
29CLUnifiedCellLocationProvider
N34CLUnifiedCellLocationProviderLogic21ICellLocationProviderE
N34CLUnifiedCellLocationProvider_Type6ClientE
25CLLteCellLocationDatabase
?50CLSensorCalibrationStaticDetectorMotionCoprocessor
33CLSensorCalibrationStaticDetector
38CLSensorCalibrationStaticDetectorAccel
17CLRunningVector3dIdE
10CLVector3dIdE
36CLFunctionalStrengthMotionClassifier
23CLSensorFusionServiceAP
N16CLMotionNotifier18CallbackDispatcherIN14CLCompass_Type6SampleEEE
@17CLSwimPersistence
20CLActivityRecorderDbI11CLSwimEntryN12CLActivityDB22NoDataProtectionPolicyEE
WorkoutPredictorSessionId
18CLWorkoutPredictor
NSt3__110__function6__funcIZN18CLWorkoutPredictor19bringupStopDetectorINS2_10EMuteAlertEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS8_16NotificationDataEE_NS_9allocatorISB_EEFvS9_SA_EEE
ZN18CLWorkoutPredictor19bringupStopDetectorINS_10EMuteAlertEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS5_16NotificationDataEE_
NSt3__110__function6__funcIZN18CLWorkoutPredictor19bringupStopDetectorINS2_14ELabelerUpdateEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS8_16NotificationDataEE_NS_9allocatorISB_EEFvS9_SA_EEE
ZN18CLWorkoutPredictor19bringupStopDetectorINS_14ELabelerUpdateEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS5_16NotificationDataEE_
NSt3__110__function6__funcIZN18CLWorkoutPredictorC1ER25CLWorkoutPredictorSourcesNS_8functionIFvN23CLWorkoutPredictor_Type12NotificationENS6_16NotificationDataEEEENS_10shared_ptrI22CLNonInterruptingTimerEEP23CLIndoorOutdoorProtocolE3$_0NS_9allocatorISG_EEFbbEEE
ZN18CLWorkoutPredictorC1ER25CLWorkoutPredictorSourcesNSt3__18functionIFvN23CLWorkoutPredictor_Type12NotificationENS4_16NotificationDataEEEENS2_10shared_ptrI22CLNonInterruptingTimerEEP23CLIndoorOutdoorProtocolE3$_0
NSt3__110__function6__funcIZN18CLWorkoutPredictorC1ER25CLWorkoutPredictorSourcesNS_8functionIFvN23CLWorkoutPredictor_Type12NotificationENS6_16NotificationDataEEEENS_10shared_ptrI22CLNonInterruptingTimerEEP23CLIndoorOutdoorProtocolE3$_1NS_9allocatorISG_EEFbbEEE
ZN18CLWorkoutPredictorC1ER25CLWorkoutPredictorSourcesNSt3__18functionIFvN23CLWorkoutPredictor_Type12NotificationENS4_16NotificationDataEEEENS2_10shared_ptrI22CLNonInterruptingTimerEEP23CLIndoorOutdoorProtocolE3$_1
NSt3__110__function6__funcIZN18CLWorkoutPredictorC1ER25CLWorkoutPredictorSourcesNS_8functionIFvN23CLWorkoutPredictor_Type12NotificationENS6_16NotificationDataEEEENS_10shared_ptrI22CLNonInterruptingTimerEEP23CLIndoorOutdoorProtocolE3$_2NS_9allocatorISG_EEFbbEEE
ZN18CLWorkoutPredictorC1ER25CLWorkoutPredictorSourcesNSt3__18functionIFvN23CLWorkoutPredictor_Type12NotificationENS4_16NotificationDataEEEENS2_10shared_ptrI22CLNonInterruptingTimerEEP23CLIndoorOutdoorProtocolE3$_2
NSt3__110__function6__funcIZN18CLWorkoutPredictor19bringupStopDetectorINS2_26EStartReminderDelayExpiredEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS8_16NotificationDataEE_NS_9allocatorISB_EEFvS9_SA_EEE
ZN18CLWorkoutPredictor19bringupStopDetectorINS_26EStartReminderDelayExpiredEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS5_16NotificationDataEE_
NSt3__110__function6__funcIZN18CLWorkoutPredictor19bringupStopDetectorINS2_19ELocationTypeUpdateEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS8_16NotificationDataEE_NS_9allocatorISB_EEFvS9_SA_EEE
ZN18CLWorkoutPredictor19bringupStopDetectorINS_19ELocationTypeUpdateEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS5_16NotificationDataEE_
NSt3__110__function6__funcIZN18CLWorkoutPredictor19bringupStopDetectorINS2_18EPreferenceChangedEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS8_16NotificationDataEE_NS_9allocatorISB_EEFvS9_SA_EEE
ZN18CLWorkoutPredictor19bringupStopDetectorINS_18EPreferenceChangedEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS5_16NotificationDataEE_
NSt3__110__function6__funcIZN18CLWorkoutPredictor19bringupStopDetectorINS2_19EUserStartedWorkoutEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS8_16NotificationDataEE_NS_9allocatorISB_EEFvS9_SA_EEE
ZN18CLWorkoutPredictor19bringupStopDetectorINS_19EUserStartedWorkoutEEEvPKT_EUlN23CLWorkoutPredictor_Type12NotificationENS5_16NotificationDataEE_
NSt3__110__function6__funcIZN18CLWorkoutPredictor26bringupActiveStateDetectorEvE3$_3NS_9allocatorIS3_EEFvN23CLWorkoutPredictor_Type12NotificationENS6_16NotificationDataEEEE
ZN18CLWorkoutPredictor26bringupActiveStateDetectorEvE3$_3
NSt3__110__function6__funcIZN18CLWorkoutPredictor14bringupLabelerEvE3$_4NS_9allocatorIS3_EEFvN23CLWorkoutPredictor_Type12NotificationENS6_16NotificationDataEEEE
ZN18CLWorkoutPredictor14bringupLabelerEvE3$_4
12CLCoverState
-@N10CLMobility21GaitMetricsRecorderDbE
20CLActivityRecorderDbIN10CLMobility11GaitMetricsEN12CLActivityDB22NoDataProtectionPolicyEE
N10CLMobility19GaitMetricsDelegateE
27CLNatalieCrossTrainingModel
333333
?N25CLManagedLocationDatabaseI22CLWifiLocationDatabaseNS0_8WifiDataEE8ExternalE
N25CLManagedLocationDatabaseI22CLWifiLocationDatabaseNS0_8WifiDataEE9IExternalE
N25CLManagedLocationDatabaseI22CLCellLocationDatabaseN23CLTelephonyService_Type4CellEE8ExternalE
N25CLManagedLocationDatabaseI22CLCellLocationDatabaseN23CLTelephonyService_Type4CellEE9IExternalE
?333333
?ffffff
?CLAdaptiveExerciseMinuteThresholdUpdaterLastUpdateTime
N25CLManagedLocationDatabaseI26CLCdmaCellLocationDatabaseN23CLTelephonyService_Type8CdmaCellEE8ExternalE
N25CLManagedLocationDatabaseI26CLCdmaCellLocationDatabaseN23CLTelephonyService_Type8CdmaCellEE9IExternalE
29CLMaxMetsProcessingRecorderDb
20CLActivityRecorderDbI17MaxMetsProcessingN12CLActivityDB22NoDataProtectionPolicyEE
N25CLManagedLocationDatabaseI25CLLteCellLocationDatabaseN23CLTelephonyService_Type7LteCellEE8ExternalE
N25CLManagedLocationDatabaseI25CLLteCellLocationDatabaseN23CLTelephonyService_Type7LteCellEE9IExternalE
L@333@
@32CLCalorieFunctionalStrengthModel
44CLStreamingAwareLocationProviderStateMachine
23CLDataProtectionManager
10CLNotifierIN28CLDataProtectionManager_Type12NotificationENS0_16NotificationDataEccE
N28CLDataProtectionManager_Type6ClientE
16CLNotifierClientIN28CLDataProtectionManager_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN28CLDataProtectionManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N28CLDataProtectionManager_Type16NotificationDataE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI23CLARKitHintSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR23CLARKitHintSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase14messageHandlerI23CLARKitHintSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
pH@<
;;pN<
pg*;
C,-;
?333?\
?333?
B`e;
 ABc
_)K;
*>,<
}A.@
""  
,)*+
((''
&!16CLPowerAssertion
22CLStatusBarIconManager
10CLNotifierIN27CLStatusBarIconManager_Type12NotificationENS0_16NotificationDataEccE
N27CLStatusBarIconManager_Type6ClientE
16CLNotifierClientIN27CLStatusBarIconManager_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN27CLStatusBarIconManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N27CLStatusBarIconManager_Type16NotificationDataE
22CLDaemonInUseAssertion
21CLDaemonGenericClient
32CLStreamingAwareLocationProvider
N44CLStreamingAwareLocationProviderStateMachine8DelegateE
N32CLStreamingAwareLocationProvider12TimerWrapperE
N44CLStreamingAwareLocationProviderStateMachine5TimerE
N37CLStreamingAwareLocationProvider_Type6ClientE
N23CLLocationProvider_Type6ClientE
NSt3__120__shared_ptr_emplaceIN23CLLocationProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
36CLGeoFeatureAccess3dBuildingGeometry
NSt3__110__function6__funcIZN36CLGeoFeatureAccess3dBuildingGeometry23buildingsWithinDistanceERNS_6vectorINS2_25ExtrudedBuildingFootprintENS_9allocatorIS4_EEEERKdSA_SA_E3$_0NS5_ISB_EEFPU37objcproto26GEOMapFeatureAccessRequest11objc_objectU13block_pointerFvP7NSErrorEEEE
ZN36CLGeoFeatureAccess3dBuildingGeometry23buildingsWithinDistanceERNSt3__16vectorINS_25ExtrudedBuildingFootprintENS0_9allocatorIS2_EEEERKdS8_S8_E3$_0
28CLWifiServerResponseListener
39CLNetworkLocationServerResponseListener
25CLServiceLocationProvider
N30CLServiceLocationProvider_Type6ClientE
@36CLFitnessYouthOutdoorCyclingOverride
033333
@333333
C@24CLNataliePedestrianModel
NSt3__120__shared_ptr_pointerIP17CLNatalieRunModelNS_10shared_ptrI33CLNataliePedestrianModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI33CLNataliePedestrianModelInterfaceE27__shared_ptr_default_deleteIS1_17CLNatalieRunModelEE
NSt3__120__shared_ptr_pointerIP18CLNatalieWalkModelNS_10shared_ptrI33CLNataliePedestrianModelInterfaceE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI33CLNataliePedestrianModelInterfaceE27__shared_ptr_default_deleteIS1_18CLNatalieWalkModelEE
@28CLCompanionNotifierCompanion
25CLEarGestureClientManager
N16CLMotionNotifier18CallbackDispatcherIN20CLEarGestureNotifier16NotificationDataEEE
17CLSqliteStatement
27CLSqliteFinalizingStatement
26CLSqliteResettingStatement
N15CLMASettingsMap8RootNodeE
N15CLMASettingsMap8NodeBaseE
NSt3__123enable_shared_from_thisIN15CLMASettingsMap8RootNodeEEE
N15CLMASettingsMap10BranchNodeE
NSt3__123enable_shared_from_thisIN15CLMASettingsMap10BranchNodeEEE
N15CLMASettingsMap8LeafNodeE
NSt3__120__shared_ptr_pointerIPN15CLMASettingsMap8RootNodeENS_10shared_ptrIS2_E27__shared_ptr_default_deleteIS2_S2_EENS_9allocatorIS2_EEEE
NSt3__110shared_ptrIN15CLMASettingsMap8RootNodeEE27__shared_ptr_default_deleteIS2_S2_EE
NSt3__120__shared_ptr_pointerIPN15CLMASettingsMap10BranchNodeENS_10shared_ptrIS2_E27__shared_ptr_default_deleteIS2_S2_EENS_9allocatorIS2_EEEE
NSt3__110shared_ptrIN15CLMASettingsMap10BranchNodeEE27__shared_ptr_default_deleteIS2_S2_EE
NSt3__120__shared_ptr_pointerIPN15CLMASettingsMap8LeafNodeENS_10shared_ptrIS2_E27__shared_ptr_default_deleteIS2_S2_EENS_9allocatorIS2_EEEE
NSt3__110shared_ptrIN15CLMASettingsMap8LeafNodeEE27__shared_ptr_default_deleteIS2_S2_EE
23CLStepCountSubscription
23CLTransientSubscriptionI23CLStepCountSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI23CLStepCountSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR23CLStepCountSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI23CLStepCountSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI23CLStepCountSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI23CLStepCountSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
26CLCalorieCalisthenicsModel
WorkoutSessionMetricsSubmissionTimerDelaySeconds
WorkoutSessionMinSessionLengthSeconds
P@21CLLoiLocationProvider
N26CLLoiLocationProvider_Type6ClientE
NSt3__120__shared_ptr_emplaceIN10CLMobility22BoutBoundaryRecorderDbENS_9allocatorIS2_EEEE
NSt3__120__shared_ptr_emplaceIN10CLMobility21BoutMetricsRecorderDbENS_9allocatorIS2_EEEE
NSt3__120__shared_ptr_emplaceI21CLStepCountRecorderDbNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceIN10CLMobility22HealthKitQueryDelegateENS_9allocatorIS2_EEEE
N10CLMobility14SPUGaitMetricsE
18CLPushSubscription
24CLPersistentSubscriptionI18CLPushSubscriptionE
NSt3__110__function6__funcIZN28CLPersistentSubscriptionBase14messageHandlerI18CLPushSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR18CLPushSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN28CLPersistentSubscriptionBase14messageHandlerI18CLPushSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
>18CLFallSubscription
23CLTransientSubscriptionI18CLFallSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI18CLFallSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR18CLFallSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase14messageHandlerI18CLFallSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI18CLFallSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI18CLFallSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
>36CLBackgroundWorkoutEscalationManager
@@35CLExerciseMinuteWheelChairEstimator
GyroCalibrationMinBatteryLevel
GyroCalibrationStaticWait
GyroCalibrationMinimumInterval
GyroCalibrationDoubleCalInterval
GyroCalibrationOutOfBoxTimeout
GyroCalibrationUrgentMinBatteryLevel
GyroCalibrationUrgentStaticWait
GyroCalibrationUrgentAttemptMinimumInterval
GyroCalibrationRetryCalInterval
GyroCalibrationLastCalibration
GyroCalibrationLastUnpluggedCalibration
LongestDurationWithoutCal
29CLSensorCalibrationController
10CLNotifierIN34CLSensorCalibrationController_Type12NotificationENS0_16NotificationDataEccE
N34CLSensorCalibrationController_Type6ClientE
16CLNotifierClientIN34CLSensorCalibrationController_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN34CLSensorCalibrationController_Type16NotificationDataENS_9allocatorIS2_EEEE
N34CLSensorCalibrationController_Type16NotificationDataE
N6CLGyro11TemperatureE
40CLNonInterruptingTimerWithPowerAssertion
u=)\
?333?
L?fff?
?30CLKappaQualifierAlgAudioResult
24CLKappaQualifierAlgAudio
NSt3__120__shared_ptr_emplaceI30CLKappaQualifierAlgAudioResultNS_9allocatorIS1_EEEE
VO2MaxPowerBudgetEstimatorQueryLookbackInterval
>kPriority
kConfigId
kAppBundleIdentifier
kStudyId
kParameterDictionary
>27CLIndoorOutdoorSubscription
23CLTransientSubscriptionI27CLIndoorOutdoorSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI27CLIndoorOutdoorSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR27CLIndoorOutdoorSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI27CLIndoorOutdoorSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI27CLIndoorOutdoorSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI27CLIndoorOutdoorSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
HB16CLOutdoorMatcher
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_19bad_optional_accessEEEEE
N5boost16exception_detail19error_info_injectorINS_19bad_optional_accessEEE
N5boost19bad_optional_accessE
20CLVO2MaxSubscription
23CLTransientSubscriptionI20CLVO2MaxSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI20CLVO2MaxSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR20CLVO2MaxSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI20CLVO2MaxSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
@o@23CLMicroLocationNotifier
10CLNotifierIN28CLMicroLocationNotifier_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
N35CLMicroLocationBackgroundActivities29IBackgroundActivitiesDelegateE
N22CLMicroLocationLearner16ILearnerDelegateE
N24CLMicroLocationAnalytics18IAnalyticsDelegateE
N20CLMicroLocationLogic14ILogicDelegateE
N24CLMicroLocationLocalizer18ILocalizerDelegateE
N19CLWifiServiceClient9IReceiverE
NSt3__120__shared_ptr_emplaceIN28CLMicroLocationNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N28CLMicroLocationNotifier_Type16NotificationDataE
N28CLMicroLocationNotifier_Type7RegInfoE
NSt3__120__shared_ptr_emplaceIN2CL5Wifi15Types15WifiScanHistoryENS_9allocatorIS4_EEEE
NSt3__120__shared_ptr_emplaceIN2CL5Wifi15Types8WifiScanENS_9allocatorIS4_EEEE
N2CL5Wifi15Types16ElevationHistoryE
NSt3__120__shared_ptr_emplaceIN2CL5Wifi15Types16HeartbeatMetricsENS_9allocatorIS4_EEEE
b@ffffff
C@19CLKappaSubscription
23CLTransientSubscriptionI19CLKappaSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI19CLKappaSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR19CLKappaSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase14messageHandlerI19CLKappaSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI19CLKappaSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI19CLKappaSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
 @ff&@
,@333@
@@ffF@
L@33S@
`@fff@
l@33s@
NSt3__117bad_function_callE
NSt3__110__function6__funcIZN19CLCyclingStateUtils24getGPSDeltaDistanceStateERK24CLWorkoutPredictorInputsRKNS3_5ItemsEE3$_0NS_9allocatorIS9_EEFvRK15CLOdometerEntryEEE
NSt3__110__function6__baseIFvRK15CLOdometerEntryEEE
ZN19CLCyclingStateUtils24getGPSDeltaDistanceStateERK24CLWorkoutPredictorInputsRKNS0_5ItemsEE3$_0
NSt3__110__function6__funcIZN19CLCyclingStateUtils12dumpGPSStateERK24CLWorkoutPredictorInputsE3$_1NS_9allocatorIS6_EEFvRK15CLOdometerEntryEEE
ZN19CLCyclingStateUtils12dumpGPSStateERK24CLWorkoutPredictorInputsE3$_1
26CLWifiTileAccessPointEntry
27CLIWifiTileAccessPointEntry
4@NSt3__110__function6__funcIZN21CLEmergencyControllerC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0NS_9allocatorIS5_EEFvbEEE
ZN21CLEmergencyControllerC1EPU30objcproto19CLIntersiloUniverse11objc_objectE3$_0
23CLOutdoorMatchingEngine
NSt3__120__shared_ptr_emplaceI36CLGeoFeatureAccess3dBuildingGeometryNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI16CLOutdoorMatcherNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI13CLPlosMatcherNS_9allocatorIS1_EEEE
ANSt3__110__function6__funcINS_6__bindIRFN5boost8geometry5model3boxINS5_5pointIdLm2ENS4_2cs20spherical_equatorialINS4_6degreeEEEEEEEmNS_10shared_ptrINS_6vectorI15CLNADMarqueeAppNS_9allocatorISG_EEEEEEEJRKNS_12placeholders4__phILi1EEERSK_EEENSH_IST_EEFSD_mEEE
NSt3__110__function6__baseIFN5boost8geometry5model3boxINS4_5pointIdLm2ENS3_2cs20spherical_equatorialINS3_6degreeEEEEEEEmEEE
NSt3__16__bindIRFN5boost8geometry5model3boxINS3_5pointIdLm2ENS2_2cs20spherical_equatorialINS2_6degreeEEEEEEEmNS_10shared_ptrINS_6vectorI15CLNADMarqueeAppNS_9allocatorISE_EEEEEEEJRKNS_12placeholders4__phILi1EEERSI_EEE
NSt3__118__weak_result_typeIPFN5boost8geometry5model3boxINS3_5pointIdLm2ENS2_2cs20spherical_equatorialINS2_6degreeEEEEEEEmNS_10shared_ptrINS_6vectorI15CLNADMarqueeAppNS_9allocatorISE_EEEEEEEEE
NSt3__115binary_functionImNS_10shared_ptrINS_6vectorI15CLNADMarqueeAppNS_9allocatorIS3_EEEEEEN5boost8geometry5model3boxINSA_5pointIdLm2ENS9_2cs20spherical_equatorialINS9_6degreeEEEEEEEEE
N5boost8geometry5index6detail5rtree9iterators22query_iterator_wrapperImNS3_10allocatorsINSt3__19allocatorImEEmNS1_9quadraticILm8ELm4EEENS0_5model3boxINSC_5pointIdLm2ENS0_2cs20spherical_equatorialINS0_6degreeEEEEEEENS3_23node_variant_static_tagEEENS4_22spatial_query_iteratorImNS3_7optionsISB_NS3_18insert_default_tagENS3_26choose_by_content_diff_tagENS3_17split_default_tagENS3_13quadratic_tagESL_EENS2_10translatorINS7_8functionIFSK_mEEENS1_8equal_toImEEEESK_SM_NS2_10predicates17spatial_predicateISJ_NS11_12contains_tagELb0EEEEEEE
N5boost8geometry5index6detail5rtree9iterators19query_iterator_baseImNS3_10allocatorsINSt3__19allocatorImEEmNS1_9quadraticILm8ELm4EEENS0_5model3boxINSC_5pointIdLm2ENS0_2cs20spherical_equatorialINS0_6degreeEEEEEEENS3_23node_variant_static_tagEEEEE
28CLMotionActivitySubscription
23CLTransientSubscriptionI28CLMotionActivitySubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI28CLMotionActivitySubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR28CLMotionActivitySubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI28CLMotionActivitySubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI28CLMotionActivitySubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI28CLMotionActivitySubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
A19CLAutopauseProvider
10CLNotifierIN24CLAutopauseProvider_Type12NotificationENS0_16NotificationDataEccE
N24CLAutopauseProvider_Type6ClientE
16CLNotifierClientIN24CLAutopauseProvider_Type12NotificationENS0_16NotificationDataEccE
24CLFitnessControllerYouth
36CLGenericFitnessMinuteEstimatorYouth
NSt3__120__shared_ptr_emplaceI31CLFitnessYouthBriskWalkOverrideNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI37CLFitnessYouthElevationCreditOverrideNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI31CLFitnessYouthHeartRateOverrideNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI36CLFitnessYouthOutdoorCyclingOverrideNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI36CLFitnessYouthGenericWorkoutOverrideNS_9allocatorIS1_EEEE
N@10CLTileFile
21CLPeerRangingNotifier
10CLNotifierIN26CLPeerRangingNotifier_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
28CLPeerRangingManagerDelegate
N26CLPeerRangingNotifier_Type6ClientE
16CLNotifierClientIN26CLPeerRangingNotifier_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
N26CLPeerRangingNotifier_Type7RegInfoE
NSt3__110__function6__funcINS_6__bindIM21CLPeerRangingNotifierFviRKN18CLWifiService_Type12NotificationERKNS4_16NotificationDataEEJRPS3_RKNS_12placeholders4__phILi1EEERKNSG_ILi2EEERKNSG_ILi3EEEEEENS_9allocatorISQ_EEFviS7_SA_EEE
NSt3__16__bindIM21CLPeerRangingNotifierFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEJRPS1_RKNS_12placeholders4__phILi1EEERKNSE_ILi2EEERKNSE_ILi3EEEEEE
NSt3__118__weak_result_typeIM21CLPeerRangingNotifierFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEEE
NSt3__120__shared_ptr_emplaceIN26CLPeerRangingNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N26CLPeerRangingNotifier_Type16NotificationDataE
F14CLTilesManager
10CLNotifierIN19CLTilesManager_Type12NotificationENS0_16NotificationDataEccE
N19CLTilesManager_Type6ClientE
16CLNotifierClientIN19CLTilesManager_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN19CLTilesManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N19CLTilesManager_Type16NotificationDataE
NSt3__111__end_stateIcEE
NSt3__16__nodeIcEE
NSt3__120__shared_ptr_pointerIPNS_13__empty_stateIcEENS_10shared_ptrIS2_E27__shared_ptr_default_deleteIS2_S2_EENS_9allocatorIS2_EEEE
NSt3__110shared_ptrINS_13__empty_stateIcEEE27__shared_ptr_default_deleteIS2_S2_EE
NSt3__113__empty_stateIcEE
NSt3__116__owns_one_stateIcEE
NSt3__115__has_one_stateIcEE
NSt3__120__l_anchor_multilineIcEE
NSt3__120__r_anchor_multilineIcEE
NSt3__115__word_boundaryIcNS_12regex_traitsIcEEEE
NSt3__111__lookaheadIcNS_12regex_traitsIcEEEE
NSt3__123__match_any_but_newlineIcEE
NSt3__118__match_char_icaseIcNS_12regex_traitsIcEEEE
NSt3__120__match_char_collateIcNS_12regex_traitsIcEEEE
NSt3__112__match_charIcEE
NSt3__116__back_ref_icaseIcNS_12regex_traitsIcEEEE
NSt3__118__back_ref_collateIcNS_12regex_traitsIcEEEE
NSt3__110__back_refIcEE
NSt3__120__bracket_expressionIcNS_12regex_traitsIcEEEE
NSt3__128__begin_marked_subexpressionIcEE
NSt3__126__end_marked_subexpressionIcEE
NSt3__16__loopIcEE
NSt3__117__owns_two_statesIcEE
NSt3__117__repeat_one_loopIcEE
NSt3__111__alternateIcEE
NSt3__121__empty_non_own_stateIcEE
NSt3__111__match_anyIcEE
19CLNatalieCycleModel
2w-!
va@Y
Bva@
hva@
%eva@
Mva@
A@Ef.p
ua@T
A@Ef.p
ua@Y
hva@T
Wxa@1
&]xa@
pOxa@!Y
A@34
bxa@h
Mxa@k
fxa@
A@ZH
rxa@
xa@x~Q
A@|a2U
xa@V
Mxa@
A@|a2U
xa@1
A@oF
WIxa@
oxa@
A@%]3
fxa@
Dxa@
Dxa@
oxa@
{HH6@-
DH6@?;
H6@_
\@}\
I6@g
I6@g
DH6@
I6@b
\@pB!
lG6@
\@p^
jG6@
G6@j
\@<g
VI6@@
ng_I6@
I6@h
\@p^
jG6@
G6@ 
\@4,F]kG6@c
C5%YG6@
'H6@
\@I*S
AH6@
\@79|
\@79|
\@1C
 F6@
F6@JA
F6@nO
$@M-G6@
uG6@
jH6@q
1"QH6@
\@Dm
FAH6@
\@H1@
G6@D
\@>v
()H6@
H6@L5
G6@D4
G6@8
G6@B{
\@qt
jH6@
Y@;U
Y@B'
Y@zl
~NA~
Y@h?RD
Y@HN&n
Y@0+
?i8en
Y@#N'
?o/i
Y@]5
Y@vq
Y@|{
?i8en
Y@0+
Y@3Q
?Pmp"
Y@3Q
/K;5
?|Bv
Y@^,
Y@pA
Y@E-
Y@tE)!X
Y@%?
Y@<L
Y@Hlw
Y@4K
?^gC
Y@BC
Y@Ab
Y@Ab
l_^@z5@i
-v_^@3
=?@*
v;?@
ip[`^@
;?@2
M`^@
,AF<?@;
`^@!
y<?@
kC`^@M
x$^>?@
n`^@
y>?@s+
X`^@
1??@
'`^@C
??@T
lu_^@
l_^@
v;?@;
1??@k:!t_^@
~NA~:?@
9?@PT6
_^@dY0
G9?@
8?@Y
_^@<
r8?@
`^@r1
q8?@
8?@QMI
_^@v
_^@8f
:?@k:!t_^@r1
q8?@
`^@i7
`^@{J
=8?@
`^@QMI
9?@K
`^@d${
9?@TR'
`^@B
E:?@
4f:?@
``^@
_^@>>!;o;?@
_^@i7
%:?@\
^^@jN^d
 :?@
^^@^
:?@"
^^@V
^^@-x
:?@G<
^^@^
k:?@G<
9?@"
_!s9?@
Ss^^@
&N:?@P
b^^@l
:?@:>Z
1^^@
4:?@
^^@0g
]^@G
D9?@
]^@{
Cr29?@
G9?@
#^^@
#9?@
 ^^@
99?@
(^^@
[;^^@
8?@N
\^^@
O^^@
)9?@
^^@l
]^@d
^8?@&
^^@n
b8?@=
 ^^@/3l
vMHk^^@
gA8?@O
Z^^@
h8?@
^^@X
]^@/3l
vMHk^^@X
s8?@
^^@L
7?@1
j7?@Z
77?@
^^@"
6?@>!;oc^^@
M6?@j
65?@9B
^^@O
w8?@>!;oc^^@
65?@9B
w8?@>
]^@9
O4?@
5]^@
:v4?@
K]^@(
4?@?
4?@H
]^@}$%=5?@
5?@N*
5?@.
'H]^@h
W5?@ep
:]^@
u7O5?@i
2]^@T
r5?@
6]^@
5?@u<f
2]^@
5?@D
]^@~
5?@>
O4?@H
5?@.
I]^@
2?@Q
y]^@
]^@C
f2?@
4?@t
4]^@g
d4?@t
4]^@
]^@4
:?@C
T^^@IK
^^@O
]^@<
<?@+
]^@Vc
kc<?@r3
Q<?@n
]^@Dm
FA<?@
+<?@O
]^@t
5=(<?@O
T^^@
=?@T
]@W|C
C@=I
C@=I
]@#LQ.
C@a3
]@z7
]@Ov3
]@Ov3
]@`w
]@>x
C@q!
]@5B?S
C@q!
]@5B?S
]@S?o*R
C@-wf
C@F'K
C@5C
TmH@h
@Afg
;mH@$
l ]llH@'jin
1lH@
FlH@
y7lH@
@5*p
,lH@
@UN{J
kH@H
@$(~
kH@O$
kH@Id
lH@,
$[]N
[X7lH@
lH@p&
xlH@_
Q+LmH@
xnH@h
kH@_
xnH@S
@"lxz
Gp#e
@t^c
krH@
1>rH@xak
-rH@
rH@[
qH@3P
lqH@B
?QqH@#
qH@TpxAD
?QqH@
I@u<f
I@+N
I@u=
I@]6:
I@]6:
I@gH
I@,~SX
I@,~SX
E|'f
I@Yk(
*2: 
I@1|DL
I@&TpxAD
I@&5
I@~6r
3g}b!@
_!@K
X!@#
W!@9~
Z!@T
I@^+
$^!@
W!@T
b!@K
I@W'g(
sCSV!@
I@W]
jJR!@h
T!@^
9T!@
I@W]
jJR!@
I@W'g(
M!@Uh 
tN!@
0R!@E
WV!@
I@/o
jW!@
yU!@w
nkS!@
Q!@m
I@ca
M!@E
I@/o
jW!@
iW!@
P!@z
;P!@e
M!@!
iQ!@B
I@zpw
nS!@
uRW!@
iW!@e
XI!@
I!@0
J!@gs
Cr2q
GS!@]
XI!@
GS!@
I@QKs+
wakN!@
L!@J
.H!@
I@jm
kI!@SX
.H!@
wakN!@J
M@y>
2@Swe
M@7R
M@mV}
M@bi
2@x*
M@t#,*
2@O"
2@uw
2@?
iN^d
M@$a
M@z9
2@p%;6
=$|o
b@zpw
b@:A
b@['.
b@TpxAD
lXSY
b@Q29
b@B$C
b@Q29
b@h>
b@h>
b@VW
b@VW
/9@3
/9@<
T29@3
Mb49@#
Mb49@
.;9@
K@bg
49@i
K@NG
49@b
K@?6
K@NG
.;9@
/9@j0
T.9@
,9@K
09@|
K@'P
19@{
K@W#
229@
K@W#
229@
7R@ )"
c7R@
3@TW>
%9`W
zk7R@
3@TW>
4R@d
2@IJz
Z4R@
4R@\U
4R@9(a
2@'.
2@!t
4R@MHk:
2@IJz
Z4R@9(a
2@!t
~1;?@
;?@P
b<?@
;?@Ym
_u>@
-;?@
c\qq>@
b<?@Ym
_u>@/
[<<?@
=?@8
~=?@8
z<?@#
[<<?@8
=?@8
>@W=`
2=?@y[
uT5A<?@S
;?@y[
=?@S
;?@5]Ot]
bF<?@
bF<?@
>@?p
:?@K
::?@Zc
^-wf:?@Zc
|:?@_
:?@o,(
u:?@
a:?@
:?@D
5:?@e
:?@Zc
:?@e
+;?@
;?@Qj/
8;?@IJz
>@#i7
d:tz
t:?@1
t:?@
>@#i7
;?@1
\n08?@_
7?@6:
>@2U0*
7?@M
b7?@
r7?@
>@. 
4`8?@Na
b7?@
>@. 
8?@_
"i7:?@
'9?@
'9?@
Q<?@
X^^@
;?@
=?@4
hW=?@4
;?@
g{^^@
#:?@
7:?@
o:?@
%VF#_^@
F;?@
^^@U
e;?@
W^^@
W^^@
#:?@
%VF#_^@
=?@GV~
]@tF
C@` 
]@PVW
]@tF
]@PVW
D@l^
@_Cp\
@['.
@_Cp\
=@rN
=@oG8-x
=@m7
=@4,F]k
=@ta
G@Ec
+MJA
G@,e
t{Ic
B@"S>
;4,F]
B@E,b
B@E,b
t{Ic
x>T
0&T
9@fk}
QFT
iOT
Yg|T
bdT
9@fk}
<0?Z
C@cE
<0?Z
t`D@
j`D@
B_D@
B_D@
`D@.
D@g*
D@X7
8/N|
D@A(
D@B&
hZbe4
S?o*R
6sHj
B@uYLl>
B@YQ
B@9_
B@9_
,cC7
):x^
|\x^
]L3y^
SVy^
Yfy^
B@%<
B@N
B@dx
B@Dl
!Uz^
B@qqTn
!Uz^
B@>[
B@>[
B@F(
B@@Q
B@F(
,+MJA
g)YNB
@@in
@@4GV~
@@BC
@@n3
@@n3
;15CLSkiRecorderDb
20CLActivityRecorderDbI10CLSkiEntryN12CLActivityDB22NoDataProtectionPolicyEE
14CLWifiTileFile
?DR#?
8?@j??c
;T9m<LP
zlK;
`<Ox
=K;e
s-=K
lt=9
>6Z^
x0=;R}=4
m">W
}O=d
Cy>1
>! />
vR>\
r>l&
{>;5
>RFL>B
iA=a
=ZfQ>I
>5EP>
FallStatsTapToRadarDelay
40CLWifiLocation5GHzChannelDefaultSelector
34CLIWifiLocation5GHzChannelSelector
42CLWifiLocation5GHzChannelTimeBasedSelector
41CLWifiLocation5GHzChannelSelectionService
38CLIWifiLocationChannelSelectionService
?333333
@333333
@ffffff
17CLOnBodyNotifier7
19CLFallImpactMetrics
B21CLAutopauseCalculator
27CLTransientSubscriptionBase
>24CLCompanionNotifierWatch
N29CLCompanionNotifierWatch_Type6ClientE
N24CLCompanionNotifier_Type6ClientE
16CLNotifierClientIN24CLCompanionNotifier_Type12NotificationENS0_16NotificationDataEcNS0_16RegistrationInfoEE
NSt3__120__shared_ptr_emplaceIN24CLCompanionNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
17CLSLCSubscription
24CLPersistentSubscriptionI17CLSLCSubscriptionE
NSt3__110__function6__funcIZN28CLPersistentSubscriptionBase14messageHandlerI17CLSLCSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR17CLSLCSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN28CLPersistentSubscriptionBase14messageHandlerI17CLSLCSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
b*J@k
M@\z
S@t9
tdV@u
K]@ 
)c@!3I
`fp@
#l@ffff
;q@G
@9W
18CLTileParsingError
29CLGeoMapFeatureAccessGeometry
NSt3__120__shared_ptr_pointerIP9CLMapRoadNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110__function6__funcIZNK29CLGeoMapFeatureAccessGeometry26getGeoMapFeatureRoadObjectERKNS_10shared_ptrI9CLMapRoadEEE3$_0NS_9allocatorIS8_EEFPU37objcproto26GEOMapFeatureAccessRequest11objc_objectU13block_pointerFvP7NSErrorEEEE
ZNK29CLGeoMapFeatureAccessGeometry26getGeoMapFeatureRoadObjectERKNSt3__110shared_ptrI9CLMapRoadEEE3$_0
NSt3__110__function6__funcIZNK29CLGeoMapFeatureAccessGeometry19roadsWithinDistanceERNS_4listIN13CLMapGeometry19DistanceQueryResultENS_9allocatorIS5_EEEERK10CLMapCrumbdbE3$_1NS6_ISD_EEFPU37objcproto26GEOMapFeatureAccessRequest11objc_objectU13block_pointerFvP7NSErrorEEEE
ZNK29CLGeoMapFeatureAccessGeometry19roadsWithinDistanceERNSt3__14listIN13CLMapGeometry19DistanceQueryResultENS0_9allocatorIS3_EEEERK10CLMapCrumbdbE3$_1
NSt3__110__function6__funcIZNK29CLGeoMapFeatureAccessGeometry19roadsAtIntersectionER10CLMapCrumbPNS_4listIN13CLMapGeometry23IntersectionQueryResultENS_9allocatorIS7_EEEESB_bRKNS_10shared_ptrI9CLMapRoadEEbddRdE3$_2NS8_ISI_EEFPU37objcproto26GEOMapFeatureAccessRequest11objc_objectU13block_pointerFvP7NSErrorEEEE
ZNK29CLGeoMapFeatureAccessGeometry19roadsAtIntersectionER10CLMapCrumbPNSt3__14listIN13CLMapGeometry23IntersectionQueryResultENS2_9allocatorIS5_EEEES9_bRKNS2_10shared_ptrI9CLMapRoadEEbddRdE3$_2
NSt3__110__function6__funcIZNK29CLGeoMapFeatureAccessGeometry19roadsAtIntersectionER10CLMapCrumbPNS_4listIN13CLMapGeometry23IntersectionQueryResultENS_9allocatorIS7_EEEESB_bRKNS_10shared_ptrI9CLMapRoadEEbddRdE3$_3NS8_ISI_EEFPU37objcproto26GEOMapFeatureAccessRequest11objc_objectU13block_pointerFvP7NSErrorEEEE
ZNK29CLGeoMapFeatureAccessGeometry19roadsAtIntersectionER10CLMapCrumbPNSt3__14listIN13CLMapGeometry23IntersectionQueryResultENS2_9allocatorIS5_EEEES9_bRKNS2_10shared_ptrI9CLMapRoadEEbddRdE3$_3
NSt3__120__shared_ptr_emplaceIN35CLGeoMapFeatureAccessGeometryCommon17RoadWithDirectionENS_9allocatorIS2_EEEE
NSt3__110__function6__funcIZNK29CLGeoMapFeatureAccessGeometry18moveOnRoadInternalEddRKNS_4listIN13CLMapGeometry8RoadInfoENS_9allocatorIS5_EEEERNS4_19DistanceQueryResultEiE3$_4NS6_ISD_EEFPU37objcproto26GEOMapFeatureAccessRequest11objc_objectU13block_pointerFvP7NSErrorEEEE
ZNK29CLGeoMapFeatureAccessGeometry18moveOnRoadInternalEddRKNSt3__14listIN13CLMapGeometry8RoadInfoENS0_9allocatorIS3_EEEERNS2_19DistanceQueryResultEiE3$_4
Bff*B
0V@}?5^
@Dio
714CLPressureBias
10CLNotifierIN19CLPressureBias_Type12NotificationENS0_16NotificationDataEccE
N19CLPressureBias_Type6ClientE
16CLNotifierClientIN19CLPressureBias_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN19CLPressureBias_Type16NotificationDataENS_9allocatorIS2_EEEE
N19CLPressureBias_Type16NotificationDataE
>OscarActivity
LogMotionStateReplay
LogGyro
OscarStepCounting
ISPUpdateInterval
OscarPredictionInterval
OscarLogLevel
ProactiveRevisitTime
UserConfig
OscarDisableDynamicBias
OscarGyroBiasXOffset
OscarGyroBiasYOffset
OscarGyroBiasZOffset
OscarGyroBiasErrorOffset
OscarGyroBiasErrorOffest
35CLSidebandOverrideMotionCoprocessor
18CLSidebandOverride
33CLMotionStateSimMotionCoprocessor
16CLMotionStateSim
38CLMotionStateYouthSimMotionCoprocessor
21CLMotionStateYouthSim
39CLSidebandSensorFusionMotionCoprocessor
22CLSidebandSensorFusion
19CLMotionCoprocessor
N24CMMotionCoprocessorReply7VisitorE
v?(X
,C|&@
?UUUUUU
@gDio
32CLDistributedSensingSubscription
?32CLCalorieSemiStatWheelchairModel
9CLDEMTile
O@vO
h2P@
+QW@w-!
XAX@
Y@17CLOdometerQuality
21CLHeadingSubscription
23CLTransientSubscriptionI21CLHeadingSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLHeadingSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR21CLHeadingSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLHeadingSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
31CLVO2MaxStagingOutputRecorderDb
20CLActivityRecorderDbI19VO2MaxStagingOutputN12CLActivityDB22NoDataProtectionPolicyEE
21CLElevationRecorderDb
20CLActivityRecorderDbI22CLSignificantElevationN12CLActivityDB22NoDataProtectionPolicyEE
@17CLPolicyProactive
N24CLHarvestPolicyInterface9ProactiveE
?24CLTileDownloaderExternal
25CLITileDownloaderExternal
14FastPathDevice
19NoopTileSyncManager
>20CLDaemonHealthClient
29CLOnBodyDetectionSubscription
23CLTransientSubscriptionI29CLOnBodyDetectionSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI29CLOnBodyDetectionSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR29CLOnBodyDetectionSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI29CLOnBodyDetectionSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI29CLOnBodyDetectionSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI29CLOnBodyDetectionSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
6?KY6?
>22CLOdometerSubscription
23CLTransientSubscriptionI22CLOdometerSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI22CLOdometerSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR22CLOdometerSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI22CLOdometerSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
k>33
?ff&?333?
L?fff?
?fff@
IAfffA
4B33;BffBB
?fff@
IAfffA
4B33;BffBB
Q8>=
u>)\
?333?
L?fff?
u=)\
?ff&?333?
?333?
?333?
L?fff?
HB27CLKappaQualifierAlgZgResult
21CLKappaQualifierAlgZg
&>e-E?
?)b,>
?)b,>
 &>FPE?
 &>FPE?
?ky"
?zS!>
O;ns$
E<9l
@$S:
<gKQ
NSt3__120__shared_ptr_emplaceI27CLKappaQualifierAlgZgResultNS_9allocatorIS1_EEEE
f@CLDE
?ffffff
d@-C
@w+A23CLDigitalElevationModel
N23CLDigitalElevationModel19CLDEMAltitudeFilterE
NSt3__110__function6__funcIZN12_GLOBAL__N_116registerActivityI26CLMicroLocationMaintenanceZN35CLMicroLocationBackgroundActivities24registerForXPCActivitiesENS_8optionalINS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKN33CLMicroLocationXPCActivityHelpers11XPCCriteriaEEEEEEE3$_0EEvSJ_RNS5_29IBackgroundActivitiesDelegateERNS_6vectorINS_10unique_ptrINSG_15XPCRegistrationENS_14default_deleteISS_EEEENSB_ISV_EEEESM_T0_EUlNSG_11XPCActivityEE_NSB_IS11_EEFvS10_EEE
NSt3__110__function6__baseIFvN33CLMicroLocationXPCActivityHelpers11XPCActivityEEEE
NSt3__110__function6__funcIZN35CLMicroLocationBackgroundActivities14ActivityRunnerIN33CLMicroLocationXPCActivityHelpers11XPCActivityE26CLMicroLocationMaintenanceEC1ES5_RS6_EUlvE_NS_9allocatorIS9_EEFbvEEE
NSt3__110__function6__baseIFbvEEE
ZN35CLMicroLocationBackgroundActivities14ActivityRunnerIN33CLMicroLocationXPCActivityHelpers11XPCActivityE26CLMicroLocationMaintenanceEC1ES2_RS3_EUlvE_
ZN12_GLOBAL__N_116registerActivityI26CLMicroLocationMaintenanceZN35CLMicroLocationBackgroundActivities24registerForXPCActivitiesENSt3__18optionalINS3_8functionIFvRKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERKN33CLMicroLocationXPCActivityHelpers11XPCCriteriaEEEEEEE3$_0EEvSH_RNS2_29IBackgroundActivitiesDelegateERNS3_6vectorINS3_10unique_ptrINSE_15XPCRegistrationENS3_14default_deleteISQ_EEEENS9_IST_EEEESK_T0_EUlNSE_11XPCActivityEE_
NSt3__110__function6__funcIZN12_GLOBAL__N_116registerActivityI24CLMicroLocationAnalyticsZN35CLMicroLocationBackgroundActivities24registerForXPCActivitiesENS_8optionalINS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKN33CLMicroLocationXPCActivityHelpers11XPCCriteriaEEEEEEE3$_1EEvSJ_RNS5_29IBackgroundActivitiesDelegateERNS_6vectorINS_10unique_ptrINSG_15XPCRegistrationENS_14default_deleteISS_EEEENSB_ISV_EEEESM_T0_EUlNSG_11XPCActivityEE_NSB_IS11_EEFvS10_EEE
NSt3__110__function6__funcIZN35CLMicroLocationBackgroundActivities14ActivityRunnerIN33CLMicroLocationXPCActivityHelpers11XPCActivityE24CLMicroLocationAnalyticsEC1ES5_RS6_EUlvE_NS_9allocatorIS9_EEFbvEEE
ZN35CLMicroLocationBackgroundActivities14ActivityRunnerIN33CLMicroLocationXPCActivityHelpers11XPCActivityE24CLMicroLocationAnalyticsEC1ES2_RS3_EUlvE_
ZN12_GLOBAL__N_116registerActivityI24CLMicroLocationAnalyticsZN35CLMicroLocationBackgroundActivities24registerForXPCActivitiesENSt3__18optionalINS3_8functionIFvRKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERKN33CLMicroLocationXPCActivityHelpers11XPCCriteriaEEEEEEE3$_1EEvSH_RNS2_29IBackgroundActivitiesDelegateERNS3_6vectorINS3_10unique_ptrINSE_15XPCRegistrationENS3_14default_deleteISQ_EEEENS9_IST_EEEESK_T0_EUlNSE_11XPCActivityEE_
NSt3__110__function6__funcIZN12_GLOBAL__N_116registerActivityI22CLMicroLocationLearnerZN35CLMicroLocationBackgroundActivities24registerForXPCActivitiesENS_8optionalINS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKN33CLMicroLocationXPCActivityHelpers11XPCCriteriaEEEEEEE3$_2EEvSJ_RNS5_29IBackgroundActivitiesDelegateERNS_6vectorINS_10unique_ptrINSG_15XPCRegistrationENS_14default_deleteISS_EEEENSB_ISV_EEEESM_T0_EUlNSG_11XPCActivityEE_NSB_IS11_EEFvS10_EEE
NSt3__110__function6__funcIZN35CLMicroLocationBackgroundActivities14ActivityRunnerIN33CLMicroLocationXPCActivityHelpers11XPCActivityE22CLMicroLocationLearnerEC1ES5_RS6_EUlvE_NS_9allocatorIS9_EEFbvEEE
ZN35CLMicroLocationBackgroundActivities14ActivityRunnerIN33CLMicroLocationXPCActivityHelpers11XPCActivityE22CLMicroLocationLearnerEC1ES2_RS3_EUlvE_
ZN12_GLOBAL__N_116registerActivityI22CLMicroLocationLearnerZN35CLMicroLocationBackgroundActivities24registerForXPCActivitiesENSt3__18optionalINS3_8functionIFvRKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERKN33CLMicroLocationXPCActivityHelpers11XPCCriteriaEEEEEEE3$_2EEvSH_RNS2_29IBackgroundActivitiesDelegateERNS3_6vectorINS3_10unique_ptrINSE_15XPCRegistrationENS3_14default_deleteISQ_EEEENS9_IST_EEEESK_T0_EUlNSE_11XPCActivityEE_
NSt3__110__function6__funcIZN12_GLOBAL__N_116registerActivityI23CLMicroLocationPowerLogZN35CLMicroLocationBackgroundActivities24registerForXPCActivitiesENS_8optionalINS_8functionIFvRKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEERKN33CLMicroLocationXPCActivityHelpers11XPCCriteriaEEEEEEE3$_3EEvSJ_RNS5_29IBackgroundActivitiesDelegateERNS_6vectorINS_10unique_ptrINSG_15XPCRegistrationENS_14default_deleteISS_EEEENSB_ISV_EEEESM_T0_EUlNSG_11XPCActivityEE_NSB_IS11_EEFvS10_EEE
NSt3__110__function6__funcIZN35CLMicroLocationBackgroundActivities14ActivityRunnerIN33CLMicroLocationXPCActivityHelpers11XPCActivityE23CLMicroLocationPowerLogEC1ES5_RS6_EUlvE_NS_9allocatorIS9_EEFbvEEE
ZN35CLMicroLocationBackgroundActivities14ActivityRunnerIN33CLMicroLocationXPCActivityHelpers11XPCActivityE23CLMicroLocationPowerLogEC1ES2_RS3_EUlvE_
ZN12_GLOBAL__N_116registerActivityI23CLMicroLocationPowerLogZN35CLMicroLocationBackgroundActivities24registerForXPCActivitiesENSt3__18optionalINS3_8functionIFvRKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERKN33CLMicroLocationXPCActivityHelpers11XPCCriteriaEEEEEEE3$_3EEvSH_RNS2_29IBackgroundActivitiesDelegateERNS3_6vectorINS3_10unique_ptrINSE_15XPCRegistrationENS3_14default_deleteISQ_EEEENS9_IST_EEEESK_T0_EUlNSE_11XPCActivityEE_
27CLVehicleConnectionNotifier
10CLNotifierIN32CLVehicleConnectionNotifier_Type12NotificationENS0_16NotificationDataEccE
N32CLVehicleConnectionNotifier_Type6ClientE
16CLNotifierClientIN32CLVehicleConnectionNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN32CLVehicleConnectionNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N32CLVehicleConnectionNotifier_Type16NotificationDataE
Zw+?(
Zwk?
TXA{
17CLMotionSyncStore
10CLNotifierIN22CLMotionSyncStore_Type12NotificationENS0_16NotificationDataEccE
N22CLMotionSyncStore_Type16NotificationDataE
27CLLocationAwarenessProvider
10CLNotifierIN32CLLocationAwarenessProvider_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
N32CLLocationAwarenessProvider_Type6ClientE
16CLNotifierClientIN32CLLocationAwarenessProvider_Type12NotificationENS0_16NotificationDataEcNS0_7RegInfoEE
N32CLLocationAwarenessProvider_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN32CLLocationAwarenessProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
N32CLLocationAwarenessProvider_Type7RegInfoE
24CLFitnessMachineNotifier
10CLNotifierIN29CLFitnessMachineNotifier_Type12NotificationENS0_16NotificationDataEccE
N29CLFitnessMachineNotifier_Type6ClientE
16CLNotifierClientIN29CLFitnessMachineNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN29CLFitnessMachineNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N29CLFitnessMachineNotifier_Type16NotificationDataE
13CLMapGeometry
37CLFitnessYouthElevationCreditOverride
37CLPredictedWalkDistanceBoutRecorderDb
20CLActivityRecorderDbI32CLPredictedWalkDistanceBoutEntryN12CLActivityDB22NoDataProtectionPolicyEE
22P6MWDReportingDelegate
12CLMapMatcher
NSt3__120__shared_ptr_pointerIP18CLSimpleMapMatcherNS_10shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS1_18CLSimpleMapMatcherEE
NSt3__120__shared_ptr_pointerIP18CLScoredMapMatcherNS_10shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS1_18CLScoredMapMatcherEE
NSt3__120__shared_ptr_pointerIP20CLParticleMapMatcherNS_10shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS1_20CLParticleMapMatcherEE
NSt3__120__shared_ptr_pointerIP13CLPlosMatcherNS_10shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS1_13CLPlosMatcherEE
NSt3__120__shared_ptr_pointerIP16CLOutdoorMatcherNS_10shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI12CLMapMatcherE27__shared_ptr_default_deleteIS1_16CLOutdoorMatcherEE
18CLSimpleMapMatcher
833&@
@fffff
@18CLScoredMapMatcher
26CLCellTilesManagerExternal
27CLICellTilesManagerExternal
R@20CLParticleMapMatcher
@33&@
@336@
@33&@
"@13CLPencilState
10CLNotifierIN18CLPencilState_Type12NotificationENS0_16NotificationDataEccE
N18CLPencilState_Type6ClientE
16CLNotifierClientIN18CLPencilState_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN18CLPencilState_Type16NotificationDataENS_9allocatorIS2_EEEE
N18CLPencilState_Type16NotificationDataE
23CLMapMatchingEngineBase
19CLMapMatchingEngine
NSt3__120__shared_ptr_emplaceI39CLGeoMapFeatureAccessGeometryPedestrianNS_9allocatorIS1_EEEE
NSt3__118basic_stringstreamIcNS_11char_traitsIcEENS_9allocatorIcEEEE
12CLAppMonitor
10CLNotifierIN17CLAppMonitor_Type12NotificationENS0_16NotificationDataEccE
N17CLAppMonitor_Type6ClientE
16CLNotifierClientIN17CLAppMonitor_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN17CLAppMonitor_Type16NotificationDataENS_9allocatorIS2_EEEE
N17CLAppMonitor_Type16NotificationDataE
21CMStrideCalRecorderDb
20CLActivityRecorderDbI16CLStrideCalEntryN12CLActivityDB22NoDataProtectionPolicyEE
LogMotionStateReplay
21CLMotionStateObserver
10CLNotifierIN26CLMotionStateObserver_Type12NotificationENS0_16NotificationDataEccE
N26CLMotionStateObserver_Type6ClientE
16CLNotifierClientIN26CLMotionStateObserver_Type12NotificationENS0_16NotificationDataEccE
NSt3__110__function6__funcIZN24CLWifiTileDataRepository30saveWifiTileAccessPointEntriesERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6chrono10time_pointIN2cl6chrono19CFAbsoluteTimeClockENSB_8durationIeNS_5ratioILl1ELl1EEEEEEEE3$_0NS6_ISL_EEFvRKN19CLTilesManager_Type10TileHeaderEijjEEE
NSt3__110__function6__baseIFvRKN19CLTilesManager_Type10TileHeaderEijjEEE
ZN24CLWifiTileDataRepository30saveWifiTileAccessPointEntriesERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEENS0_6chrono10time_pointIN2cl6chrono19CFAbsoluteTimeClockENS9_8durationIeNS0_5ratioILl1ELl1EEEEEEEE3$_0
+?33
Ga=fff?
l@33s?
 Aff&?
Affffff
22CLLocationSubscription
23CLTransientSubscriptionI22CLLocationSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI22CLLocationSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR22CLLocationSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase14messageHandlerI22CLLocationSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI22CLLocationSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI22CLLocationSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__120__shared_ptr_pointerIP17CLPersistentTimerNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI17CLPersistentTimerE27__shared_ptr_default_deleteIS1_S1_EE
N16CLMotionNotifier14SiloDispatcherIN14CLCompass_Type6SampleEEE
N14CLCompass_Type6SampleE
B22CLSwimWorkoutStopModel
18CLCellTilesManager
10CLNotifierIN23CLCellTilesManager_Type12NotificationENS0_16NotificationDataEccE
N23CLCellTilesManager_Type6ClientE
16CLNotifierClientIN23CLCellTilesManager_Type12NotificationENS0_16NotificationDataEccE
12CLEntryCacheINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE16CLDaemonLocationE
16CLEntryCacheBase
NSt3__120__shared_ptr_emplaceIN23CLCellTilesManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N23CLCellTilesManager_Type16NotificationDataE
27CLAutopauseProviderConcrete
NSt3__120__shared_ptr_emplaceIN24CLAutopauseProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
N24CLAutopauseProvider_Type16NotificationDataE
MotionCalibration
com.apple.locationd.bundle-/System/Library/LocationBundles/MotionCalibration.bundle
14CLDeviceMotion
29CLSensorFusionService6AxisSPU
29CLSensorFusionService9AxisSPU
>21CLWorkoutSubscription
23CLTransientSubscriptionI21CLWorkoutSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLWorkoutSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR21CLWorkoutSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI21CLWorkoutSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI21CLWorkoutSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI21CLWorkoutSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
26CLActivityLoggerRatePolicy
@ffffff
22CLFlexibleMedianFilterIdE
30CLExerciseMinuteEstimatorYouth
yE>Q6
FallUserMetricsUploadIntervalSeconds
@WalkingSteadinessHKQueryIntervalSeconds
@WalkingSteadinessHKMaxIgnoredQueryErrors
21CLFallUserInfoMetrics
22CLFallFieldMetricsBase
18CLWifiTilesManager
10CLNotifierIN23CLWifiTilesManager_Type12NotificationENS0_16NotificationDataEccE
15CLITilesManager
NSt3__120__shared_ptr_emplaceIN23CLWifiTilesManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N23CLWifiTilesManager_Type16NotificationDataE
11CLBinaryLog
16CLBinaryLogTypes
25CLActivityLoggerMsgPolicy
22CLActivityLoggerPolicy
/>24CLAutopauseProviderDummy
?14CLMedianFilterIfE
>@21CLNatalimetryNotifier
10CLNotifierIN26CLNatalimetryNotifier_Type12NotificationENS0_16NotificationDataEccE
33CLGenericFitnessEstimatorProtocol
N26CLNatalimetryNotifier_Type6ClientE
16CLNotifierClientIN26CLNatalimetryNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__110__function6__funcIN38CLCalorimetryDMFeatureSourceController12fDanceSourceMUlbE_ENS_9allocatorIS3_EEFbbEEE
N38CLCalorimetryDMFeatureSourceController12fDanceSourceMUlbE_E
34CLNatalieExternallyActivatedSourceI28CLCalorimetryDanceDMFeaturesE
14CLNatalieInputI28CLCalorimetryDanceDMFeaturesE
20CLNatalieInputBufferI28CLCalorimetryDanceDMFeaturesE
NSt3__110__function6__funcIN38CLCalorimetryDMFeatureSourceController10fFSTSourceMUlbE_ENS_9allocatorIS3_EEFbbEEE
N38CLCalorimetryDMFeatureSourceController10fFSTSourceMUlbE_E
34CLNatalieExternallyActivatedSourceI41CLCalorimetryFunctionalStrengthDMFeaturesE
14CLNatalieInputI41CLCalorimetryFunctionalStrengthDMFeaturesE
20CLNatalieInputBufferI41CLCalorimetryFunctionalStrengthDMFeaturesE
NSt3__110__function6__funcIN38CLCalorimetryDMFeatureSourceController13fRowingSourceMUlbE_ENS_9allocatorIS3_EEFbbEEE
N38CLCalorimetryDMFeatureSourceController13fRowingSourceMUlbE_E
34CLNatalieExternallyActivatedSourceI29CLCalorimetryRowingDMFeaturesE
14CLNatalieInputI29CLCalorimetryRowingDMFeaturesE
20CLNatalieInputBufferI29CLCalorimetryRowingDMFeaturesE
NSt3__110__function6__funcIN38CLCalorimetryDMFeatureSourceController10fGeneratorMUlN31CLCalorimetryDMFeatureGenerator4TypeENS3_8FeaturesEE_ENS_9allocatorIS6_EEFvS4_S5_EEE
NSt3__110__function6__baseIFvN31CLCalorimetryDMFeatureGenerator4TypeENS2_8FeaturesEEEE
N38CLCalorimetryDMFeatureSourceController10fGeneratorMUlN31CLCalorimetryDMFeatureGenerator4TypeENS0_8FeaturesEE_E
20CLNatalieInputBufferIN26CLMotionStateMediator_Type22MediatedMotionActivityEE
NSt3__110__function6__funcIN21CLNatalimetryNotifier17fDMFeatureSourcesMUlbE_ENS_9allocatorIS3_EEFvbEEE
NSt3__110__function6__baseIFvbEEE
N21CLNatalimetryNotifier17fDMFeatureSourcesMUlbE_E
NSt3__120__shared_ptr_pointerIP23CLNatalimetryRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI23CLNatalimetryRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
NSt3__120__shared_ptr_pointerIP26CLExerciseMinuteRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI26CLExerciseMinuteRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
NSt3__120__shared_ptr_emplaceI19CLMaxMetsRecorderDbNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI29CLMaxMetsProcessingRecorderDbNS_9allocatorIS1_EEEE
NSt3__120__shared_ptr_emplaceI23CLVO2MaxAlertRecorderDbNS_9allocatorIS1_EEEE
27CLNatalieSourceFromNotifierI15CLOdometerEntryE
27CLNatalieSourceFromNotifierI22CLElevationChangeEntryE
20CLNatalieInputBufferI22CLElevationChangeEntryE
27CLNatalieSourceFromNotifierI28CLCoarseElevationChangeEntryE
14CLNatalieInputI28CLCoarseElevationChangeEntryE
20CLNatalieInputBufferI28CLCoarseElevationChangeEntryE
27CLNatalieSourceFromNotifierI15CLCatherineDataE
14CLNatalieInputI15CLCatherineDataE
20CLNatalieInputBufferI15CLCatherineDataE
27CLNatalieSourceFromNotifierI16CLStepCountEntryE
14CLNatalieInputI16CLStepCountEntryE
20CLNatalieInputBufferI16CLStepCountEntryE
14CLNatalieInputIN26CLMotionStateMediator_Type22MediatedMotionActivityEE
27CLNatalieSourceFromNotifierI11CLSwimEntryE
14CLNatalieInputI11CLSwimEntryE
20CLNatalieInputBufferI11CLSwimEntryE
27CLNatalieSourceFromNotifierI21_CLFitnessMachineDataE
14CLNatalieInputI21_CLFitnessMachineDataE
20CLNatalieInputBufferI21_CLFitnessMachineDataE
NSt3__120__shared_ptr_pointerIP19CLNatalieModelInputNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI19CLNatalieModelInputE27__shared_ptr_default_deleteIS1_S1_EE
N16CLMotionNotifier14SiloDispatcherIN14CLDeviceMotion6SampleEEE
N14CLDeviceMotion6SampleE
NSt3__120__shared_ptr_emplaceIN26CLNatalimetryNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N26CLNatalimetryNotifier_Type16NotificationDataE
A22CLCalorieClimbingModel
N@ffffff*
Q=@fffff
a@fffff
`@fffff
9b@33333
m`@333333
33333
 @HP
s;V@333333L
`c@33333
f@33333
L;@{
p=J:@
V@fffff&=@
uS@`
.8@J
@@L7
A`eQ@
&@33333
fffff
V~D@
s(S?@
zT<@d;
W'@j
K7)O
 %vmo
 @33333s1@33333
X@Nb
+Z@33333s3@fffff
(<Y@~
g$2@
P2@R
u=1@XSY
*Ral! P
~VV@J
|?5^
3*A@7
PSA@
QI-5
333333(
36@R
a\@ffffff\@
A@}?5^
33333sL@333333M@\
0@)\
0@fffff&O
333333
333333e
|?5^
ffffff0
0@5^
333333
@K@ffffffL@
ffffff-
+'@C
6@J
6@X9
v>6@b
`\@9
Mbp4@/
+wS@
nZ@=
QHQ@fffff.T@
8@fffff
\N@F
 P8@
@fffff
GAE@
?333333!@
@fffff6`@
33333
.eB19CLGyroBiasEstimator
10CLVector3dIfE
17CLRunningVector3dIfE
NSt3__110__function6__funcIZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_5NS_9allocatorIS3_EEFbPN16CLMotionNotifier18CallbackDispatcherIN6CLGyro6SampleEEEEEE
NSt3__110__function6__baseIFbPN16CLMotionNotifier18CallbackDispatcherIN6CLGyro6SampleEEEEEE
ZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_5
NSt3__110__function6__funcIZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_2NS_9allocatorIS3_EEFvPN16CLMotionNotifier18CallbackDispatcherIN6CLGyro6SampleEEEEEE
NSt3__110__function6__baseIFvPN16CLMotionNotifier18CallbackDispatcherIN6CLGyro6SampleEEEEEE
ZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_2
N7CLUtils10RAIIHelperIN16CLMotionNotifier18CallbackDispatcherIN6CLGyro6SampleEEEEE
NSt3__110__function6__funcIZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_6NS_9allocatorIS3_EEFbPN16CLMotionNotifier18CallbackDispatcherIN6CLGyro11TemperatureEEEEEE
NSt3__110__function6__baseIFbPN16CLMotionNotifier18CallbackDispatcherIN6CLGyro11TemperatureEEEEEE
ZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_6
NSt3__110__function6__funcIZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_3NS_9allocatorIS3_EEFvPN16CLMotionNotifier18CallbackDispatcherIN6CLGyro11TemperatureEEEEEE
NSt3__110__function6__baseIFvPN16CLMotionNotifier18CallbackDispatcherIN6CLGyro11TemperatureEEEEEE
ZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_3
N7CLUtils10RAIIHelperIN16CLMotionNotifier18CallbackDispatcherIN6CLGyro11TemperatureEEEEE
NSt3__110__function6__funcIZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_7NS_9allocatorIS3_EEFbPN16CLMotionNotifier18CallbackDispatcherIN14CLMagnetometer6SampleEEEEEE
NSt3__110__function6__baseIFbPN16CLMotionNotifier18CallbackDispatcherIN14CLMagnetometer6SampleEEEEEE
ZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_7
NSt3__110__function6__funcIZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_4NS_9allocatorIS3_EEFvPN16CLMotionNotifier18CallbackDispatcherIN14CLMagnetometer6SampleEEEEEE
NSt3__110__function6__baseIFvPN16CLMotionNotifier18CallbackDispatcherIN14CLMagnetometer6SampleEEEEEE
ZN19CLGyroBiasEstimator34registerInputNotificationsInternalEvE3$_4
N7CLUtils10RAIIHelperIN16CLMotionNotifier18CallbackDispatcherIN14CLMagnetometer6SampleEEEEE
NSt3__110__function6__funcIZN19CLGyroBiasEstimator39prepareSPUGyroBiasAndVarianceDispatcherEvE3$_9NS_9allocatorIS3_EEFbPN16CLMotionNotifier18CallbackDispatcherIN28CLMotionCoprocessorInterface19GyroBiasAndVarianceEEEEEE
NSt3__110__function6__baseIFbPN16CLMotionNotifier18CallbackDispatcherIN28CLMotionCoprocessorInterface19GyroBiasAndVarianceEEEEEE
ZN19CLGyroBiasEstimator39prepareSPUGyroBiasAndVarianceDispatcherEvE3$_9
NSt3__110__function6__funcIZN19CLGyroBiasEstimator39prepareSPUGyroBiasAndVarianceDispatcherEvE3$_8NS_9allocatorIS3_EEFvPN16CLMotionNotifier18CallbackDispatcherIN28CLMotionCoprocessorInterface19GyroBiasAndVarianceEEEEEE
NSt3__110__function6__baseIFvPN16CLMotionNotifier18CallbackDispatcherIN28CLMotionCoprocessorInterface19GyroBiasAndVarianceEEEEEE
ZN19CLGyroBiasEstimator39prepareSPUGyroBiasAndVarianceDispatcherEvE3$_8
N7CLUtils10RAIIHelperIN16CLMotionNotifier18CallbackDispatcherIN28CLMotionCoprocessorInterface19GyroBiasAndVarianceEEEEE
N16CLMotionNotifier18CallbackDispatcherIN28CLMotionCoprocessorInterface19GyroBiasAndVarianceEEE
EnablePmOnBodyDetection
ForceNoThrottlingOnBody
17CLOnBodyNotifier6
24CMAccelerometerProcessor
N16CLMotionNotifier20SiloBufferDispatcherIN15CLAccelerometer6SampleEEE
N15CLAccelerometer6SampleE
N21CLOnBodyNotifier_Type16NotificationDataE
30CLCompassBiasClusteringMinDiam
18CLClusterAlgorithmI23CLCompassDatabaseRecordE
23CLCompassBiasClustering
NSt3__120__shared_ptr_pointerIPNS_6vectorI23CLCompassDatabaseRecordNS_9allocatorIS2_EEEENS_10shared_ptrIS5_E27__shared_ptr_default_deleteIS5_S5_EENS3_IS5_EEEE
NSt3__110shared_ptrINS_6vectorI23CLCompassDatabaseRecordNS_9allocatorIS2_EEEEE27__shared_ptr_default_deleteIS5_S5_EE
NSt3__120__shared_ptr_pointerIP20CLCompassBiasClusterNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI20CLCompassBiasClusterE27__shared_ptr_default_deleteIS1_S1_EE
25CLVO2MaxSummaryRecorderDb
20CLActivityRecorderDbI13VO2MaxSummaryN12CLActivityDB22NoDataProtectionPolicyEE
20CLCompassBiasCluster
15CLSimpleClusterI23CLCompassDatabaseRecordE
27CLSensorCalibrationDatabase
@20CLNatalieRowingModel
14CLEmergencyAML
NSt3__120__shared_ptr_pointerIP14CLEmergencyAMLZNS1_C1EPU30objcproto19CLIntersiloUniverse11objc_objectPU40objcproto29CLClientManagerPublicProtocol11objc_objectNS_8functionIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEENS_10shared_ptrI14CLEmergencyAWDEENS7_IFN4GNSS14DaemonLocationEvEEEE3$_0NS_9allocatorIS1_EEEE
ZN14CLEmergencyAMLC1EPU30objcproto19CLIntersiloUniverse11objc_objectPU40objcproto29CLClientManagerPublicProtocol11objc_objectNSt3__18functionIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEENS4_10shared_ptrI14CLEmergencyAWDEENS5_IFN4GNSS14DaemonLocationEvEEEE3$_0
@25CLMotionStateSubscription
23CLTransientSubscriptionI25CLMotionStateSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI25CLMotionStateSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR25CLMotionStateSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI25CLMotionStateSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI25CLMotionStateSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI25CLMotionStateSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
CLVO2MaxPreconditionCheckerTimeOfLastEstimate
CLVO2MaxPreconditionCheckerTimeOfLastWorkout
<9CLLogBase
9CLGSMTile
23CLKeyLatLonTileTemplateIN19CLTilesManager_Type23KeyLatLonIndexEntry_GSMENS0_18KeyLatLonEntry_GSMEE
10CLCDMATile
23CLKeyLatLonTileTemplateIN19CLTilesManager_Type24KeyLatLonIndexEntry_CDMAENS0_19KeyLatLonEntry_CDMAEE
9CLLTETile
23CLKeyLatLonTileTemplateIN19CLTilesManager_Type23KeyLatLonIndexEntry_LTEENS0_18KeyLatLonEntry_LTEEE
?43CLDaemonBBTimeFreqTransferCallbackAssertion
@VO2MaxPowerBudgetEstimatorQueryLookbackInterval
24CLSensorRecorderNotifier
10CLNotifierIN29CLSensorRecorderNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_pointerIPhNS_14default_deleteIA_hEENS_9allocatorIhEEEE
NSt3__114default_deleteIA_hEE
N29CLSensorRecorderNotifier_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN29CLSensorRecorderNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
24CLBTLEBeaconProviderMock
N23CLBTLEBeaconRegion_Type6RegionE
NSt3__120__shared_ptr_emplaceIN25CLBTLEBeaconProvider_Type16NotificationDataENS_9allocatorIS2_EEEE
?333?
B28CLKappaQualifierAlgGPSResult
22CLKappaQualifierAlgGPS
NSt3__120__shared_ptr_emplaceI28CLKappaQualifierAlgGPSResultNS_9allocatorIS1_EEEE
18CLBTLEFenceManager
10CLNotifierIN23CLBTLEFenceManager_Type12NotificationENS0_16NotificationDataEcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE
N23CLBTLEFenceManager_Type6ClientE
16CLNotifierClientIN23CLBTLEFenceManager_Type12NotificationENS0_16NotificationDataEcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE
N23CLBTLEBeaconRegion_Type15MonitoredRegionE
N23CLBTLEFenceManager_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN23CLBTLEFenceManager_Type16NotificationDataENS_9allocatorIS2_EEEE
24CLSpringTrackingNotifier
10CLNotifierIN29CLSpringTrackingNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_pointerIP25CLSpringTrackerRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI25CLSpringTrackerRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
N29CLSpringTrackingNotifier_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN29CLSpringTrackingNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
25CLSpringTrackerRecorderDb
20CLActivityRecorderDbI20CLSpringTrackerEntryN12CLActivityDB22NoDataProtectionPolicyEE
$@28CLBTLEBeaconProviderConcrete
?fffff
>@N12CLParticleMM28CLPedestrianMapMatcherFilterE
@33&@
@336@
@33&@
$@14CLGpsAssistant
10CLNotifierIN19CLGpsAssistant_Type12NotificationENS0_16NotificationDataEccE
20CLRunningBufferStatsIdE
NSt3__120__shared_ptr_emplaceIN19CLGpsAssistant_Type16NotificationDataENS_9allocatorIS2_EEEE
N19CLGpsAssistant_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN28CLBarometerCalibration_Types30CLBarometerCalibrationWifiDataENS_9allocatorIS2_EEEE
ParkinsonsResultPersistence
28CLParkinsonsResultRecorderDb
20CLActivityRecorderDbI16ParkinsonsResultN12CLActivityDB22NoDataProtectionPolicyEE
NSt3__110__function6__baseIFbPvbEEE
20CLBTLEBeaconProvider
10CLNotifierIN25CLBTLEBeaconProvider_Type12NotificationENS0_16NotificationDataEccE
N25CLBTLEBeaconProvider_Type6ClientE
16CLNotifierClientIN25CLBTLEBeaconProvider_Type12NotificationENS0_16NotificationDataEccE
N25CLBTLEBeaconProvider_Type16NotificationDataE
16CLDarwinNotifier
10CLNotifierIN21CLDarwinNotifier_Type12NotificationENS0_16NotificationDataEccE
N21CLDarwinNotifier_Type6ClientE
16CLNotifierClientIN21CLDarwinNotifier_Type12NotificationENS0_16NotificationDataEccE
N21CLDarwinNotifier_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN21CLDarwinNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
?39CLGeoMapFeatureAccessGeometryPedestrian
NSt3__110shared_ptrI9CLMapRoadE27__shared_ptr_default_deleteIS1_S1_EE
NSt3__110__function6__funcIZNK39CLGeoMapFeatureAccessGeometryPedestrian23roadsWithinDistanceLiteERNS_6vectorINS_10shared_ptrI9CLMapRoadEENS_9allocatorIS6_EEEERK10CLMapCrumbdbE3$_0NS7_ISE_EEFPU37objcproto26GEOMapFeatureAccessRequest11objc_objectU13block_pointerFvP7NSErrorEEEE
NSt3__110__function6__baseIFPU37objcproto26GEOMapFeatureAccessRequest11objc_objectU13block_pointerFvP7NSErrorEEEE
ZNK39CLGeoMapFeatureAccessGeometryPedestrian23roadsWithinDistanceLiteERNSt3__16vectorINS0_10shared_ptrI9CLMapRoadEENS0_9allocatorIS4_EEEERK10CLMapCrumbdbE3$_0
@33&@
@336@
@33&@
25CLPolicyProactiveExternal
N26CLPolicyProactiveInterface8ExternalE
NSt3__120__shared_ptr_emplaceI12TimerWrapperNS_9allocatorIS1_EEEE
12TimerWrapper
33CLBeaconFenceAuthorizationManager
10CLNotifierIN38CLBeaconFenceAuthorizationManager_Type12NotificationENS0_16NotificationDataEcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE
N38CLBeaconFenceAuthorizationManager_Type6ClientE
16CLNotifierClientIN38CLBeaconFenceAuthorizationManager_Type12NotificationENS0_16NotificationDataEcNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEE
NSt3__120__shared_ptr_emplaceIN38CLBeaconFenceAuthorizationManager_Type16NotificationDataENS_9allocatorIS2_EEEE
N38CLBeaconFenceAuthorizationManager_Type16NotificationDataE
=26CLBTLERangeManagerConcrete
N26CLBTLERangeManagerConcrete16RegisteredRegionE
18CLBTLERangeManager
10CLNotifierIN23CLBTLERangeManager_Type12NotificationENS0_16NotificationDataEcNSt3__14listIN23CLBTLEBeaconRegion_Type15MonitoredRegionENS3_9allocatorIS6_EEEEE
N23CLBTLERangeManager_Type6ClientE
16CLNotifierClientIN23CLBTLERangeManager_Type12NotificationENS0_16NotificationDataEcNSt3__14listIN23CLBTLEBeaconRegion_Type15MonitoredRegionENS3_9allocatorIS6_EEEEE
NSt3__14listIN23CLBTLEBeaconRegion_Type15MonitoredRegionENS_9allocatorIS2_EEEE
N23CLBTLERangeManager_Type16NotificationDataE
NSt3__120__shared_ptr_emplaceIN23CLBTLERangeManager_Type16NotificationDataENS_9allocatorIS2_EEEE
|a2U
|a2U
|a2U
|a2U
21CLWorkoutClassifierLR
19CLWorkoutClassifier
333333
?333?11CLTurnState
10CLNotifierIN16CLTurnState_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_emplaceIN16CLTurnState_Type16NotificationDataENS_9allocatorIS2_EEEE
N16CLTurnState_Type16NotificationDataE
Q8>\
24CMTemperatureFitReceiver
CLSE
26CLSwimDistanceEstimatorLap
23CLSwimDistanceEstimator
b*J@k
M@\z
S@t9
tdV@u
K]@ 
)c@!3I
`fp@
#l@ffff
;q@G
@9W
@CLHR
44CLHighResolutionSignalEnvironmentDataManager
27CLHarvestControllerExternal
N28CLHarvestControllerInterface8ExternalE
38CLHarvestPassKitNotificationRegistrant
24CLPersistentTimerWrapper
N24CLHarvestSystemInterface5TimerE
NSt3__120__shared_ptr_pointerIP24CLPersistentTimerWrapperNS_10shared_ptrIN24CLHarvestSystemInterface5TimerEE27__shared_ptr_default_deleteIS5_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrIN24CLHarvestSystemInterface5TimerEE27__shared_ptr_default_deleteIS2_24CLPersistentTimerWrapperEE
`P@Y
tI&@[
5< m
Mb@?
@333333
A19CLKappaServerClient
@MinSessionLengthAWD
0A26CLSedentaryAlarmRecorderDb
20CLActivityRecorderDbI20CLSedentaryAlarmDataN12CLActivityDB22NoDataProtectionPolicyEE
28CLDaemonSpringTrackingClient
937CLSensorFusionService3AxisDynamicGyro
#@q=
;,{@;T
i;'4
:<IkO<
d<yvz<
<yvz<
d<IkO<
i;,{@;
12CLPolicyTrip
N24CLHarvestPolicyInterface4TripE
@28CLEllipticalWorkoutStopModel
14CLNatalieInputI22CLElevationChangeEntryE
25CLCalorieDownhillSkiModel
0?13CLSqliteError
23CLMemoryMappedFileError
32CLWifiAccessPointLocationService
33CLIWifiAccessPointLocationService
25CLIWifiTileSearchDelegate
NSt3__120__shared_ptr_emplaceI32CLWifiAccessPointLocationServiceNS_9allocatorIS1_EEEE
23CLNatalimetryRecorderDb
20CLActivityRecorderDbI13CLNatalieDataN12CLActivityDB22NoDataProtectionPolicyEE
PFbPvbE
FbPvbE
>28CLExerciseMinuteSubscription
23CLTransientSubscriptionI28CLExerciseMinuteSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI28CLExerciseMinuteSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR28CLExerciseMinuteSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI28CLExerciseMinuteSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI28CLExerciseMinuteSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI28CLExerciseMinuteSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
17CLEmergencyAction
NSt3__110__function6__funcIZN16CLEmergencyActorC1EPU30objcproto19CLIntersiloUniverse11objc_objectNS_8functionIFvbEEEE3$_0NS_9allocatorIS8_EEFRKNS2_17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEE
NSt3__110__function6__baseIFRKN16CLEmergencyActor17NetworkAndSimInfoEN23CLTelephonyService_Type11SimInstanceEEEE
ZN16CLEmergencyActorC1EPU30objcproto19CLIntersiloUniverse11objc_objectNSt3__18functionIFvbEEEE3$_0
NSt3__110__function6__funcIZN16CLEmergencyActorC1EPU30objcproto19CLIntersiloUniverse11objc_objectNS_8functionIFvbEEEE3$_1NS_9allocatorIS8_EEFN4GNSS14DaemonLocationEvEEE
NSt3__110__function6__baseIFN4GNSS14DaemonLocationEvEEE
ZN16CLEmergencyActorC1EPU30objcproto19CLIntersiloUniverse11objc_objectNSt3__18functionIFvbEEEE3$_1
NSt3__110__function6__funcIZN29CLWorkoutSecondaryClassifiersC1ER24CLWorkoutPredictorInputsE3$_0NS_9allocatorIS5_EEFbbEEE
ZN29CLWorkoutSecondaryClassifiersC1ER24CLWorkoutPredictorInputsE3$_0
26CLWifiTilesManagerExternal
27CLIWifiTilesManagerExternal
@20CLAvengerZoneMonitor
N10CLMobility21BoutMetricsRecorderDbE
20CLActivityRecorderDbIN10CLMobility11BoutMetricsEN12CLActivityDB22NoDataProtectionPolicyEE
N10CLMobility19BoutMetricsDelegateE
19CLMaxMetsRecorderDb
20CLActivityRecorderDbI7MaxMetsN12CLActivityDB22NoDataProtectionPolicyEE
25CLTileSyncManagerExternal
N17CLTileSyncManager9IExternalE
?22CLNatalieSemiStatModel
333333
?33CLNataliePedestrianModelInterface
?30CLWorkloadCalibratorRecorderDb
20CLActivityRecorderDbI25CLWorkloadCalibratorEntryN12CLActivityDB22NoDataProtectionPolicyEE
22CLSwimDataSubscription
23CLTransientSubscriptionI22CLSwimDataSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI22CLSwimDataSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR22CLSwimDataSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI22CLSwimDataSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI22CLSwimDataSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI22CLSwimDataSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
29CLVisitMonitoringSubscription
24CLPersistentSubscriptionI29CLVisitMonitoringSubscriptionE
NSt3__110__function6__funcIZN28CLPersistentSubscriptionBase14messageHandlerI29CLVisitMonitoringSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
NSt3__110__function6__baseIFvR29CLVisitMonitoringSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN28CLPersistentSubscriptionBase14messageHandlerI29CLVisitMonitoringSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
35CLVO2MaxSessionAttributesRecorderDb
20CLActivityRecorderDbI23VO2MaxSessionAttributesN12CLActivityDB22NoDataProtectionPolicyEE
?37CLDaemonLocationIndependenceAssertion
32CLDaemonGnssDisablementAssertion
iond.executable-ocationd.bundle-
37CLNetworkLocationRequesterALSExternal
38CLINetworkLocationRequesterALSExternal
KappaSOSTimeoutSeconds
KappaParameterSelect
ConfigHorizontalDecelThreshold
ConfigImpactThreshold
KappaRecordingSeq
KappaAlertOnTrigger
KappaCollectPrivateData
KappaBypassDriving
KappaRecordSorter
KappaDisableCAEvents
KappaDeleteRecordings
KappaRotateUUIDCount
KappaRateLimitingMaxCount
KappaCollectionTimeoutSeconds
KappaUploadTimeoutSeconds
ConfigAcceptanceRate
?KappaDisable
KappaFilterGPS
KappaForceSensor
KappaShouldUploadRecordings
KappaShouldWriteMetadataFiles
KappaRecordAudio
ConfigQualifierPulseThreshold
ConfigQualifierBaroThresholds
ConfigQualifierAudioThresholds
ConfigQualifierZgThresholds
ConfigQualifierGpsThresholds
8ConfigDisable
Legacy
15CLKappaNotifier
10CLNotifierIN20CLKappaNotifier_Type12NotificationENS0_16NotificationDataEccE
28CLKappaRecordingSortListener
N20CLKappaNotifier_Type6ClientE
16CLNotifierClientIN20CLKappaNotifier_Type12NotificationENS0_16NotificationDataEccE
N16CLMotionNotifier14SiloDispatcherIN24CMMotionCoprocessorReply18CompassCalibrationEEE
NSt3__120__shared_ptr_emplaceIN20CLKappaNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N20CLKappaNotifier_Type16NotificationDataE
>30CLTransitTilePreloaderExternal
31CLITransitTilePreloaderExternal
22CLVehicleStateNotifier
10CLNotifierIN27CLVehicleStateNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__110__function6__funcINS_6__bindIM22CLVehicleStateNotifierFviRKN18CLWifiService_Type12NotificationERKNS4_16NotificationDataEEJRPS3_RKNS_12placeholders4__phILi1EEERKNSG_ILi2EEERKNSG_ILi3EEEEEENS_9allocatorISQ_EEFviS7_SA_EEE
NSt3__16__bindIM22CLVehicleStateNotifierFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEJRPS1_RKNS_12placeholders4__phILi1EEERKNSE_ILi2EEERKNSE_ILi3EEEEEE
NSt3__118__weak_result_typeIM22CLVehicleStateNotifierFviRKN18CLWifiService_Type12NotificationERKNS2_16NotificationDataEEEE
NSt3__120__shared_ptr_emplaceIN27CLVehicleStateNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N27CLVehicleStateNotifier_Type16NotificationDataE
16CLCoarseCellTile
23CLKeyLatLonTileTemplateIN19CLTilesManager_Type30KeyLatLonIndexEntry_CoarseCellENS0_25KeyLatLonEntry_CoarseCellEE
23CLAppRecommendationTile
25CLSpatialDataTileTemplateIN19CLTilesManager_Type27AppRecommendationIndexEntryENS0_22AppRecommendationEntryEE
NSt3__110__function6__funcIZ13wrap_receiverPN19CLWifiServiceClient9IReceiverEE3$_0NS_9allocatorIS5_EEFviRKN18CLWifiService_Type12NotificationERKNS8_16NotificationDataEEEE
Z13wrap_receiverPN19CLWifiServiceClient9IReceiverEE3$_0
SELECT * FROM StepCountHistory ORDER BY startTime ASC
21CLStepCountRecorderDb
20CLActivityRecorderDbI16CLStepCountEntryN12CLActivityDB22NoDataProtectionPolicyEE
N10CLMobility17PedometerDelegateE
NSt3__110__function6__funcIPFbPvbENS_9allocatorIS4_EES3_EE
19CLStepCountNotifier
10CLNotifierIN24CLStepCountNotifier_Type12NotificationENS0_16NotificationDataEccE
N24CLStepCountNotifier_Type6ClientE
16CLNotifierClientIN24CLStepCountNotifier_Type12NotificationENS0_16NotificationDataEccE
NSt3__120__shared_ptr_pointerIP21CLStepCountRecorderDbNS_10shared_ptrIS1_E27__shared_ptr_default_deleteIS1_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI21CLStepCountRecorderDbE27__shared_ptr_default_deleteIS1_S1_EE
14CLNatalieInputI15CLOdometerEntryE
20CLNatalieInputBufferI15CLOdometerEntryE
NSt3__120__shared_ptr_emplaceIN24CLStepCountNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N24CLStepCountNotifier_Type16NotificationDataE
?N16CLMotionNotifier14SiloDispatcherIN28CLBarometerCalibration_Types26CMKFFilteredPressureSampleEEE
N28CLBarometerCalibration_Types26CMKFFilteredPressureSampleE
NSt3__120__shared_ptr_emplaceIN28CLBarometerCalibration_Types34CLBarometerCalibrationPressureDataENS_9allocatorIS2_EEEE
NSt3__120__shared_ptr_emplaceIN28CLBarometerCalibration_Types28CLBarometerCalibrationKFDataENS_9allocatorIS2_EEEE
27CLActivityAlarmSubscription
23CLTransientSubscriptionI27CLActivityAlarmSubscriptionE
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase19subscriptionHandlerI27CLActivityAlarmSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvbRK15CLNameValuePairEEUlRS4_SA_E_NS_9allocatorISJ_EEFvSI_SA_EEE
NSt3__110__function6__baseIFvR27CLActivityAlarmSubscriptionNS_10shared_ptrI19CLConnectionMessageEEEEE
ZN27CLTransientSubscriptionBase19subscriptionHandlerI27CLActivityAlarmSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvbRK15CLNameValuePairEEUlRS1_S8_E_
NSt3__110__function6__funcIZN27CLTransientSubscriptionBase14messageHandlerI27CLActivityAlarmSubscriptionEENS_8functionIFvRT_NS_10shared_ptrI19CLConnectionMessageEEEEEMS6_FvSA_EEUlRS4_SA_E_NS_9allocatorISG_EEFvSF_SA_EEE
ZN27CLTransientSubscriptionBase14messageHandlerI27CLActivityAlarmSubscriptionEENSt3__18functionIFvRT_NS2_10shared_ptrI19CLConnectionMessageEEEEEMS4_FvS8_EEUlRS1_S8_E_
14CLSwimNotifier
10CLNotifierIN19CLSwimNotifier_Type12NotificationENS0_16NotificationDataEccE
N19CLSwimNotifier_Type6ClientE
16CLNotifierClientIN19CLSwimNotifier_Type12NotificationENS0_16NotificationDataEccE
N16CLMotionNotifier14SiloDispatcherIN6CLGyro6SampleEEE
N6CLGyro6SampleE
N16CLMotionNotifier14SiloDispatcherIN15CLAccelerometer6SampleEEE
N16CLMotionNotifier14SiloDispatcherIN6CLGyro11TemperatureEEE
NSt3__120__shared_ptr_emplaceIN19CLSwimNotifier_Type16NotificationDataENS_9allocatorIS2_EEEE
N19CLSwimNotifier_Type16NotificationDataE
?d`X
u2A$
com.apple.Msl.DefaultsQueue
com.apple.MotionSensorLogging
N5CMMsl7ALSDataE
N5CMMsl14ARSessionStateE
N5CMMsl5AccelE
N5CMMsl8Accel800E
N5CMMsl10AccelBatchE
N5CMMsl12AccelGestureE
N5CMMsl8AccelGpsE
N5CMMsl13AccelOscarEmuE
N5CMMsl17AccelerometerPaceE
N5CMMsl14AccessoryAccelE
N5CMMsl20AccessoryAccelConfigE
N5CMMsl15AccessoryConfigE
N5CMMsl21AccessoryDeviceMotionE
N5CMMsl27AccessoryDeviceMotionConfigE
N5CMMsl13AccessoryGyroE
N5CMMsl23AccessoryGyroCachedBiasE
N5CMMsl19AccessoryGyroConfigE
N5CMMsl17AccessoryGyroGYTTE
N5CMMsl20AccessoryInEarStatusE
N5CMMsl13AccessoryProxE
N5CMMsl23AccessoryProxSensorDropE
N5CMMsl21AccessoryProxTempCompE
N5CMMsl24AccessoryProximityConfigE
N5CMMsl26AccessoryStepDetectorDebugE
N5CMMsl13AccessoryWakeE
N5CMMsl18AccessoryWakeDebugE
N5CMMsl11AirpodEventE
N5CMMsl16AnchorCorrectionE
N5CMMsl18AppleCV3DSLAMStateE
N5CMMsl26AudioAccessoryDeviceMotionE
N5CMMsl21AuxiliaryDeviceMotionE
N5CMMsl15AveragedALSDataE
N5CMMsl12BTConnectionE
N5CMMsl13BasebandSpeedE
N5CMMsl15BioMotionAnchorE
N5CMMsl19BioMotionAnchorPoseE
N5CMMsl23BioMotionClassificationE
N5CMMsl32BioMotionLinkLengthFitParametersE
N5CMMsl31BioMotionOnlineLinkLengthUpdateE
N5CMMsl13BioMotionPoseE
N5CMMsl22BioMotionPredictedPoseE
N5CMMsl25BioMotionPropagatedAnchorE
N5CMMsl21BleedToZeroCorrectionE
N5CMMsl11BodyMetricsE
N5CMMsl15BraveHeartAccelE
N5CMMsl22BraveHeartDeviceMotionE
N5CMMsl21BraveHeartNatalieDataE
N5CMMsl21BraveHeartVO2MaxInputE
N5CMMsl22BraveHeartWorkoutEventE
N5CMMsl17CV3DPredictedPoseE
N5CMMsl13CV3DSLAMStateE
N5CMMsl21CalorimetryPauseEventE
N5CMMsl22CatherineHealthKitDataE
N5CMMsl15ClefCalibrationE
N5CMMsl20ClefCalibrationPointE
N5CMMsl15ClefMeasurementE
N5CMMsl15ClefTemperatureE
N5CMMsl21CoarseElevationChangeE
N5CMMsl7CompassE
N5CMMsl16CompassAlignmentE
N5CMMsl18CompassCalibrationE
N5CMMsl25CompassCalibrationAttemptE
N5CMMsl18CompassConstraintsE
N5CMMsl17CompassCorrectionE
N5CMMsl39ConstrainedIntegratorModelPredictedPoseE
N5CMMsl25ConstrainedIntegratorPoseE
N5CMMsl27CoprocessorReplyGaitMetricsE
N5CMMsl17CourseConstraintsE
N5CMMsl16CourseCorrectionE
N5CMMsl12DeviceMotionE
N5CMMsl20DeviceMotionAlwaysOnE
N5CMMsl22DeviceMotionCorrectionE
N5CMMsl22DeviceMotionCovarianceE
N5CMMsl9DoubleTapE
N5CMMsl15ElevationChangeE
N5CMMsl14EmergencyStateE
N5CMMsl20EnhancedDeviceMotionE
N5CMMsl8FacePoseE
N5CMMsl37FallDetectionActivityClassifierReplayE
N5CMMsl21FallDetectionDetectorE
N5CMMsl33FallDetectionGyroControllerReplayE
N5CMMsl20FallDetectionRefereeE
N5CMMsl19FallDetectionReplayE
N5CMMsl25FallDetectionStateMachineE
N5CMMsl29FallDetectionWristStateReplayE
N5CMMsl18FallDistanceReplayE
N5CMMsl36FallFalsePositiveSuppressionFeaturesE
N5CMMsl12FallMetaDataE
N5CMMsl11FallSnippetE
N5CMMsl9FallStateE
N5CMMsl9FallStatsE
N5CMMsl17FirstStepFeaturesE
N5CMMsl17FrequencyResponseE
N5CMMsl28FusedBioMotionClassificationE
N5CMMsl16GaitCycleSegmentE
N5CMMsl26GaitCycleSegmentationStateE
N5CMMsl15GeomagneticDataE
N5CMMsl18GravityConstraintsE
N5CMMsl17GravityCorrectionE
N5CMMsl4GyroE
N5CMMsl19GyroBiasAndVarianceE
N5CMMsl19GyroBiasConstraintsE
N5CMMsl18GyroBiasCorrectionE
N5CMMsl21GyroBiasEstimateErrorE
N5CMMsl11GyroBiasFitE
N5CMMsl26GyroCalibrationDataFactoryE
N5CMMsl38GyroCalibrationDataNonlinearNonFactoryE
N5CMMsl21GyroCalibrationSampleE
N5CMMsl30GyroCalibrationSampleNonlinearE
N5CMMsl11GyroCompassE
N5CMMsl6GyroDtE
N5CMMsl26GyroFactoryCalibrationDataE
N5CMMsl7GyroGpsE
N5CMMsl12GyroOscarEmuE
N5CMMsl15GyroTemperatureE
N5CMMsl20InEarAdditionalStateE
N5CMMsl13InEarBaselineE
N5CMMsl15InEarBaseliningE
N5CMMsl16InEarConstraintsE
N5CMMsl12InEarOpenLidE
N5CMMsl12InEarOpticalE
N5CMMsl12InEarSessionE
N5CMMsl15InEarTransitionE
N5CMMsl20InEarTransitionEntryE
N5CMMsl26InterpolatedAccessoryAccelE
N5CMMsl21IntersiloNSCodingDataE
N5CMMsl4ItemE
N5CMMsl17JitterBufferLevelE
N5CMMsl18JointLinkModelPoseE
N5CMMsl27JointLinkModelPredictedPoseE
N5CMMsl12KappaTriggerE
N5CMMsl17KappaTriggerDebugE
N5CMMsl20LSLHeadingEstimationE
N5CMMsl16LocationOscarEmuE
N5CMMsl30MLBasedBioMotionClassificationE
N5CMMsl22MagneticAccessoryType1E
N5CMMsl22MagneticAccessoryType2E
N5CMMsl12MagnetometerE
N5CMMsl17MagnetometerResetE
N5CMMsl8MetsInfoE
N5CMMsl19MobilityBoutMetricsE
N5CMMsl33ModelBasedBioMotionClassificationE
N5CMMsl14MotionActivityE
N5CMMsl20MotionActivityReplayE
N5CMMsl17MotionGPSLocationE
N5CMMsl10MotionHintE
N5CMMsl14MotionLocationE
N5CMMsl13MotionLoiDataE
N5CMMsl17MotionStateUpdateE
N5CMMsl21MotionWifiAssociationE
N5CMMsl18MotionWifiLocationE
N5CMMsl13MovementStatsE
N5CMMsl30MovementStatsGravityProjectionE
N5CMMsl19MovementStatsSignalE
N5CMMsl11NatalieDataE
N5CMMsl16NonlinearBiasFitE
N5CMMsl7ODTPoseE
N5CMMsl8OdometerE
N5CMMsl20OdometerWithAltitudeE
N5CMMsl18OnsetHeartRateDataE
N5CMMsl13PearlAttitudeE
N5CMMsl14PencilTipForceE
N5CMMsl11PencilTouchE
N5CMMsl4PoseE
N5CMMsl9PoseStateE
N5CMMsl29PredictedRelativeDeviceMotionE
N5CMMsl8PressureE
N5CMMsl19PressureCalibrationE
N5CMMsl19PressureCompensatedE
N5CMMsl16PressureFilteredE
N5CMMsl26PressureFiltered1HzLowPassE
N5CMMsl29PressureFilteredNoTemperatureE
N5CMMsl11PressureGpsE
N5CMMsl16PressureOscarEmuE
N5CMMsl16PropagatedAnchorE
N5CMMsl4ProxE
N5CMMsl8RawAudioE
N5CMMsl19RelDMInSystemConfigE
N5CMMsl37RelativeDeviceMotionComplexTransitionE
N5CMMsl36RelativeDeviceMotionCorrelatedMotionE
N5CMMsl28RelativeDeviceMotionInternalE
N5CMMsl26RelativeGravityConstraintsE
N5CMMsl25RelativeGravityCorrectionE
N5CMMsl12RotationRateE
N5CMMsl30SPUPlaybackExampleDeviceMotionE
N5CMMsl35SPUPlaybackExampleMotionStateUpdateE
N5CMMsl15SessionOverrideE
N5CMMsl17SignalEnvironmentE
N5CMMsl24SitStandDetectorFeaturesE
N5CMMsl49SitStandDetectorPosteriorBufferStatsForSitToStandE
N5CMMsl49SitStandDetectorPosteriorBufferStatsForStandToSitE
N5CMMsl26SitStandDetectorTransitionE
N5CMMsl18SoundPressureLevelE
N5CMMsl12SpatialEventE
N5CMMsl15SteadinessEventE
N5CMMsl30SteadinessModelBalanceFeaturesE
N5CMMsl40SteadinessModelContinuousWalkingFeaturesE
N5CMMsl35SteadinessModelGaitBaselineFeaturesE
N5CMMsl21SteadinessModelResultE
N5CMMsl41SteadinessModelTemporalDispersionFeaturesE
N5CMMsl38SteadinessModelTemporalEntropyFeaturesE
N5CMMsl28StepCadenceToStrideLengthBinE
N5CMMsl14StepCountEntryE
N5CMMsl22StepLikelihoodFeaturesE
N5CMMsl22StreamingHeartRateDataE
N5CMMsl12StrideCalBinE
N5CMMsl9TapAcceptE
N5CMMsl9TapDetectE
N5CMMsl31TempestPoCAuxiliaryDeviceMotionE
N5CMMsl29TempestPoCListenerOrientationE
N5CMMsl9TimestampE
N5CMMsl13TouchOscarEmuE
N5CMMsl14UltraFastAccelE
N5CMMsl14UserStudyEventE
N5CMMsl13VIOEstimationE
N5CMMsl7VIOPoseE
N5CMMsl13VIOReplayPoseE
N5CMMsl11VO2MaxInputE
N5CMMsl12VO2MaxOutputE
N5CMMsl18VehicularFlagsDataE
N5CMMsl14VibrationEventE
N5CMMsl17VisionCompassBiasE
N5CMMsl18VisualLocalizationE
N5CMMsl37VisualLocalizationAttitudeConstraintsE
N5CMMsl36VisualLocalizationAttitudeCorrectionE
N5CMMsl22VisualStateMeasurementE
N5CMMsl22WalkingDetectionResultE
N5CMMsl31WalkingSteadinessClassificationE
N5CMMsl17WatchOnWristStateE
N5CMMsl24WatchOrientationSettingsE
N5CMMsl13WifiScanEntryE
N5CMMsl15WifiScanResultsE
N5CMMsl12WorkoutEventE
N5CMMsl22WorkoutRecorderALSDataE
N5CMMsl20WorkoutRecorderAccelE
N5CMMsl23WorkoutRecorderAccel800E
N5CMMsl26WorkoutRecorderBodyMetricsE
N5CMMsl33WorkoutRecorderCompassCalibrationE
N5CMMsl24WorkoutRecorderElevationE
N5CMMsl28WorkoutRecorderHealthKitInfoE
N5CMMsl24WorkoutRecorderHeartRateE
N5CMMsl27WorkoutRecorderMagnetometerE
N5CMMsl23WorkoutRecorderOdometerE
N5CMMsl23WorkoutRecorderPressureE
N5CMMsl27WorkoutRecorderRotationRateE
N5CMMsl33WorkoutRecorderWatchOnWristStatusE
N5CMMsl39WorkoutRecorderWatchOrientationSettingsE
N5CMMsl30WorkoutRecorderWifiScanResultsE
N5CMMsl27WorkoutRecorderWorkoutEventE
N5CMMsl22ZeroVelocityCorrectionE
com.apple.MotionSensorLogging
com.apple.MotionSensorLogging
@(#)PROGRAM:locationd  PROJECT:CoreLocation-2665.0.3
>NSt3__120__shared_ptr_emplaceI10CLSettingsNS_9allocatorIS1_EEEE
GyroCalibrationForceDoubleEntry
38CLGyroCalibrationDatabaseLocalMultiRun
1475
EnableGyroLinearCalibration
30CLGyroCalibrationDatabaseLocal
N16CLMotionNotifier14SiloDispatcherIN10CLPressure6SampleEEE
N10CLPressure6SampleE
N16CLMotionNotifier20SiloBufferDispatcherIN28CLMotionCoprocessorInterface16NotificationDataEEE
N16CLMotionNotifier14SiloDispatcherIN14CLMagnetometer6SampleEEE
N14CLMagnetometer6SampleE
N24CMMotionCoprocessorReply18CompassCalibrationE
O36CLGyroCalibrationDatabaseLocalShared
NSt3__120__shared_ptr_emplaceI18CLMotionArc4RandomNS_9allocatorIS1_EEEE
>25CLWorkoutRecorderSettings
19CLRecordingSettings
@34CLGyroCalibrationDatabaseLocalBase
MA23CLCompassDatabaseDaemon
27CLCompassDatabaseController
NSt3__120__shared_ptr_pointerIP23CLCompassBiasClusteringNS_10shared_ptrI30CLCompassBiasClusteringMinDiamE27__shared_ptr_default_deleteIS4_S1_EENS_9allocatorIS1_EEEE
NSt3__110shared_ptrI30CLCompassBiasClusteringMinDiamE27__shared_ptr_default_deleteIS1_23CLCompassBiasClusteringEE
30CLGyroBiasEstimatorClientLocal
@32CLGeomagneticModelProviderDaemon
39CLGyroCalibrationDatabaseLocalNonlinear
18CLCoverStateDaemon
18CLMotionHintLogger
10CLNotifierIN23CLMotionHintLogger_Type12NotificationENS0_16NotificationDataEccE
^@25CLDrivingRecorderSettings
36CLGyroCalibrationDatabaseLocalLinear
!std::isinf(min_dist)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MachineLearning/CLHierarchicalClustering.mm
CLHierarchicalClustering
!distanceThresholdVector.empty()
getClusterLabels
minNumClusters>0
cl::chrono::CFAbsoluteTimeClock::time_point CLMicroLocationWifiScanStrategy::getExpectedNextScanEndTime(cl::chrono::CFAbsoluteTimeClock::time_point, cl::chrono::CFAbsoluteTimeClock::duration) const
Next scan expected to take %{public}.3Lfs (ending at %{public}0.3fs). Expected time that the scan timer will end: %{public}.03fs
cl::chrono::secondsf CLMicroLocationWifiScanStrategy::getScanDelay(std::optional<WifiNotificationResults>) const
No wifi results so issue a scan with initial delay of %{public}0.3Lfs
Got a scan error so returning a scan delay of %{public}0.3Lfs
Got a scan busy error so returning a scan delay of %{public}0.3Lfs
Returning scan delay: %{public}0.3Lfs
virtual std::shared_ptr<CLWifiScanner::WifiScanSettings> CLMicroLocationWifiScanStrategy::getNextScanSettings(cl::chrono::CFAbsoluteTimeClock::time_point, std::optional<WifiNotificationResults>)
Not enough time for another scan
Setting channels to scan: %{private}s
MicroLocationsLocalizing80211ScanType
MicroLocationsLocalizing80211Modes
MicroLocationsLocalizingScanLowPriority
MicroLocationsLocalizingWifiMaxAgeFirstScan
MicroLocationsRecording80211ScanType
MicroLocationsRecording80211Modes
MicroLocationsRecordingScanLowPriority
MicroLocationsRecordingWifiMaxAgeFirstScan
MicroLocationsRecordingInitialDelay
MicroLocationsWifiMaxAgeNextScan
MicroLocationsWifiBusyRetryDelay
MicroLocationsWifiErrorRetryDelay
bool (anonymous namespace)::isGoodUwbRange(CLMicroLocationProto::UwbRange)
Bad uwb range, range %{public}.2f, type %{public}d
RecordingTimestamp
MicroLocationMeasurements
 WHERE RecordingUUID in ( SELECT RecordingUUID FROM 
MicroLocationRecordingEvents
MicroLocationModels
GenerationTimestamp
MicroLocationConfiguration
MicroLocationRapport
CLMicroLocationDatabase::CLMicroLocationDatabase(std::string)
Failed to connect to database
openTransaction
CLSqliteTransaction CLMicroLocationDatabase::openTransaction()
#Warning Attempt to call %s without a backing database
No valid connection to microlocation database.
void CLMicroLocationDatabase::dropTables()
#Warning Attempt to drop tables without a backing database
uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable(const char *const)
#Warning Attempt to call numEntriesFromTriggerTable without a backing database
#Warning Unable to get column count from trigger table
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationDatabase.mm
bool CLMicroLocationDatabase::deleteDataOlderThan(std::chrono::minutes)
#Warning Attempt to deleteDataOlderThan without a backing database
MicroLocation database has no connection. %{public}s
MicroLocation database sqlite error. %{public}s
bool CLMicroLocationDatabase::deleteUnneededModels(uint32_t)
#Warning Attempt to deleteUnneededModels without a backing database
void CLMicroLocationDatabase::connectIfNecessary()
#Warning Failed to connect to database
bool CLMicroLocationDatabase::freeDatabaseSpace()
#Warning Attempt to freeDatabaseSpace() without a backing database
auto CLMicroLocationDatabase::deleteDataOlderThan(std::chrono::minutes)::(anonymous class)::operator()(const std::string &) const
Deleting microlocation data older than %.3Lf days
Error getting a prepared statement
Error binding to statement for sql %{private}s
MicroLocationsDatabaseSelectionLimit
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationMeasurementTable, MemberFn = std::vector<CLMicroLocationMeasurementTable::Entry> (CLMicroLocationMeasurementTable::*)(const std::string &, const std::string &, const std::string &, unsigned int), Args = <const std::string &, const std::string &, const std::string &, unsigned int &>]
#Warning Attempt to query %{public}s without a backing database
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationMeasurementTable, MemberFn = unsigned int (CLMicroLocationMeasurementTable::*)(const std::string &, const std::string &), Args = <const std::string &, const std::string &>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationModelTable, MemberFn = std::vector<CLMicroLocationModelTable::Entry> (CLMicroLocationModelTable::*)(), Args = <>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationModelTable, MemberFn = std::optional<CLMicroLocationModelTable::Entry> (CLMicroLocationModelTable::*)(CLMicroLocationProto::Model_ModelType), Args = <CLMicroLocationProto::Model_ModelType &>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::vector<std::string> (CLMicroLocationRecordingEventsTable::*)(unsigned int), Args = <unsigned int &>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationMeasurementTable, MemberFn = std::vector<CLMicroLocationMeasurementTable::Entry> (CLMicroLocationMeasurementTable::*)(const std::vector<boost::uuids::uuid> &, unsigned int), Args = <const std::vector<boost::uuids::uuid> &, unsigned int &>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::vector<CLMicroLocationRecordingEventsTable::Entry> (CLMicroLocationRecordingEventsTable::*)(const std::vector<boost::uuids::uuid> &, unsigned int), Args = <const std::vector<boost::uuids::uuid> &, unsigned int &>]
MicroLocationsLearningRecordingLimit
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::vector<CLMicroLocationRecordingEventsTable::Entry> (CLMicroLocationRecordingEventsTable::*)(const std::vector<CLMicroLocationProto::RecordingEventType> &, unsigned int, const std::string &), Args = <const std::vector<CLMicroLocationProto::RecordingEventType> &, unsigned int &, const std::string &>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::vector<CLMicroLocationRecordingEventsTable::Entry> (CLMicroLocationRecordingEventsTable::*)(const std::string &, const std::string &, unsigned int), Args = <const std::string &, const std::string &, unsigned int &>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRecordingEventsTable, MemberFn = std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>> (CLMicroLocationRecordingEventsTable::*)(), Args = <>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationConfigurationTable, MemberFn = std::optional<CLMicroLocationConfigurationTable::Entry> (CLMicroLocationConfigurationTable::*)(const std::string &), Args = <const std::string &>]
auto CLMicroLocationDatabase::select(MemberFn, Args &&...) [Table = CLMicroLocationRapportTable, MemberFn = std::vector<CLMicroLocationRapportTable::Entry> (CLMicroLocationRapportTable::*)(const std::string &, const std::string &, unsigned int), Args = <const std::string &, const std::string &, unsigned int &>]
uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationMeasurementTable]
#Warning Attempt to get numEntries without a backing database
MicroLocationsMeasurementTableMaxRows
!std::isnan(freePercent) && freePercent >= 0 && freePercent <= 1.0
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationDatabase.h
minimumNumRowsFree
MicroLocationsDatabaseFreeSpacePercentage
uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationRecordingEventsTable]
MicroLocationsRecordingEventsTableMaxRows
uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationModelTable]
MicroLocationsModelTableMaxRows
uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationConfigurationTable]
MicroLocationsConfigurationTableMaxRows
uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMicroLocationRapportTable]
MicroLocationsRapportTableMaxRows
void CLMicroLocationRapportTable::initTable()
Database is not connected so we can't intialize our CLMicroLocationRapportTable
Sucessfully created table if necessary: %s
bool CLMicroLocationRapportTable::insertOrReplace(const std::vector<CLMicroLocationRapportTable::Entry> &)
Failed to execute statement. %{public}s
std::vector<CLMicroLocationRapportTable::Entry> CLMicroLocationRapportTable::selectBetweenTimes(const std::string &, const std::string &, uint32_t)
bool CLMicroLocationRapportTable::deleteOldestRows(uint64_t)
RTLOIType
Device
std::vector<CLMicroLocationRapportTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)
Data Source Cancelled at index 
fFingerprintCache optional is empty, database likely changed since data source construction
perSourceParams.get(key.c_str(), weightsDict)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationAlgorithms.mm
createPerSourceWeights
onesided_jaccard
configuration.get("onesided_jaccard", weightsDict)
createOneSidedWeights
jaccard_scale_factor
distanceFunctionConfiguration.get("jaccard_scale_factor", jaccard_scale_factor)
createWeightedEuclideanJaccardDistanceFunction
e2j_kernel_thr
distanceFunctionConfiguration.get("e2j_kernel_thr", e2jKernelThr)
per_source_params
distanceFunctionConfiguration.get("per_source_params", perSourceParams)
value_scale_factor
euclidean_weight
jaccard_pos_weight
jaccard_neg_weight
jaccard_threshold
params.get("jaccard_threshold", jaccard_threshold)
createFingerprintDistanceFunction
params.get("jaccard_scale_factor", jaccard_scale_factor)
tanimoto_base
params.get("tanimoto_base", tanimoto_base)
static_cast<uint32_t>(learnerType) < static_cast<uint32_t>(LearnerType::kAlgorithmCount)
createLearner
static_cast<uint32_t>(localizerType) < static_cast<uint32_t>(LocalizerType::kAlgorithmCount)
createLocalizer
dict.get("type", primitiveType)
createKernelFunction
primitiveType < static_cast<uint32_t>(KernelFunctionType::kTypeCount)
sigma
dict.get("sigma", sigma)
power
dict.get("power", power)
static_cast<uint32_t>(type) < static_cast<uint32_t>(LinkageFunctionType::kTypeCount)
createLinkageFunction
MicroLocationsMeasurementProcessingWifiRssiEnable
MicroLocationsMeasurementProcessingBleLeechEnable
MicroLocationsMeasurementProcessingUwbRangingEnable
dict.get("wifi", wifi)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationUtils.h
fromConfiguration
dict.get("ble", ble)
dict.get("uwb", uwb)
virtual T CLMicroLocationUtils::PerSourceWeights<double>::operator[](const CLMicroLocationProto::Measurement &) const [T = double]
Datatype not supported
virtual T CLMicroLocationUtils::PerSourceWeights<bool>::operator[](const CLMicroLocationProto::Measurement &) const [T = bool]
CLLaplacianKernelFunction
CLKernelFunction.h
sigma > 0.0
CLDistanceFunction.h
a.size() == b.size()
CLGaussianKernelFunction
CLExponentialKernelFunction
power > 0.0
CLUniformKernelFunction
void CLMicroLocationConfigurationTable::initTable()
bool CLMicroLocationConfigurationTable::insertOrReplace(const std::vector<CLMicroLocationConfigurationTable::Entry> &)
std::optional<CLMicroLocationConfigurationTable::Entry> CLMicroLocationConfigurationTable::getMostRecentWifiChannelHistogramForLOIType(const std::string &)
#Warning Table is not valid so we can't get the most recent wifi channel histogram
AND 
ConfigurationType
bool CLMicroLocationConfigurationTable::deleteOldestRows(uint64_t)
Configuration
std::vector<CLMicroLocationConfigurationTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)
com.apple.MicroLocation.Maintenance
ageOfOldestRecordingDays
numModels
numModelsDeleted
numRecordingEvents
numRecordingEventsDeleted
numMeasurements
numMeasurementsDeleted
numConfigurations
numConfiguationsDeleted
numRapportEntries
numRapportEntriesDeleted
maintenanceRunTime
void CLMicroLocationMaintenance::deleteOldEntries()
Did %{public}s delete old data
MicroLocation database sqlite error. error: %{public}s
void CLMicroLocationMaintenance::deleteUnneededModels()
Did %{public}s delete unneeded models
void CLMicroLocationMaintenance::freeDatabaseSpace()
Did %{public}s free database space
MicroLocationsRecordingPurgeAge
MicroLocationsNumModelsToKeep
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationNearestNeighborAlgorithm.mm
MicroLocationsMaximumNearestNeighbors
!clusterDistanceThresholdVector.empty()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationDendrogramAlgorithm.mm
pruneDistanceThreshold <= *std::min_element(clusterDistanceThresholdVector.begin(), clusterDistanceThresholdVector.end())
fingerprintVector.size() > 0
MicroLocationsClusterDistanceThresholdVector
MicroLocationsPruneDistanceThreshold
MicroLocationsLinkageFunction
virtual CLMicroLocationModel CLMicroLocationKMeansAlgorithm::learn(const CLMicroLocationFingerprintVector &, CLMicroLocationProto::Model::ModelType, size_t, const CLMicroLocationAnchorAppearanceMap &) const
error in mean shift algorithm
numberOfClusters > 0
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationKMeansAlgorithm.mm
learn
numberOfClusters == initialClusterCenters.size()
error in kmeans algorithm
numberOfClusters == clusterCenters.size()
minClusterLabel < numberOfClusters
MicroLocationsUseKMeansClusterCenters
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/proto/gen-cpp/microlocation.pb.cc
CHECK failed: (&from) != (this): 
CLMicroLocationProto.BleLeechedBeacons
CLMicroLocationProto.WiFiRssi
CLMicroLocationProto.Direction
CLMicroLocationProto.UwbRange
CLMicroLocationProto.WiFiRange
CLMicroLocationProto.ATVAirplayBluetoothRssi
CLMicroLocationProto.HomeKitBluetoothRssi
CLMicroLocationProto.Measurement
CLMicroLocationProto.Fingerprint
CLMicroLocationProto.ClusterRecordings
CLMicroLocationProto.AnchorMetadata
CLMicroLocationProto.AnchorAppearance
CLMicroLocationProto.anchorAppearancesVector
CLMicroLocationProto.Model
CLMicroLocationProto.BundleIdFeatures
CLMicroLocationProto.LocalizationRequest
CLMicroLocationProto.RecordingRequest
CLMicroLocationProto.AppLaunch
CLMicroLocationProto.SiriInvocation
CLMicroLocationProto.BacklightOn
CLMicroLocationProto.BatteryChargerConnected
CLMicroLocationProto.StepCount
CLMicroLocationProto.ForcedRecording
CLMicroLocationProto.FirstWakeOfDay
CLMicroLocationProto.HomeKitAccessory
CLMicroLocationProto.HomeKitScene
CLMicroLocationProto.NowPlayingOutputDevice
CLMicroLocationProto.NowPlaying
CLMicroLocationProto.RecordingEvent
CLMicroLocationProto.ChannelAndCount
CLMicroLocationProto.WifiHistogram
CLMicroLocationProto.Configuration
CLMicroLocationProto.RapportDevice
set_devicetype
::CLMicroLocationProto::UwbRange_DeviceType_IsValid(value)
::CLMicroLocationProto::HomeKitBluetoothRssi_DeviceType_IsValid(value)
set_hapversion
::CLMicroLocationProto::HomeKitBluetoothRssi_HAPVersion_IsValid(value)
/System/Volumes/Data/SWE/iOS/BuildRoots/BuildRoot903/Applications/Xcode.app/Contents/Developer/Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator8.3.Internal.sdk/usr/local/include/google/protobuf/repeated_field.h
CHECK failed: (index) < (size()): 
set_anchorstatus
::CLMicroLocationProto::AnchorStatus_IsValid(value)
set_generationalgorithm
::CLMicroLocationProto::Model_GenerationAlgorithm_IsValid(value)
set_modeltype
::CLMicroLocationProto::Model_ModelType_IsValid(value)
set_type
::CLMicroLocationProto::ConfigurationType_IsValid(value)
down_cast
common.h
f == NULL || dynamic_cast<To>(f) != NULL
static CLMicroLocationProto::Model CLMicroLocationModel::toProtobuf(const CLMicroLocationModel &)
Got nullptr from CLMicroLocationProto add_anchors
static CLMicroLocationModel CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Model &)
#Warning The protobuf fingerprint does not have a valid cluster label uuid
#Warning The protobuf fingerprint is using a deprecated uint64 cluster label
#Warning The protobuf fingerprint does not have a cluster identifer
#Warning The protobuf cluster recording does not have a valid cluster label uuid
#Warning The protobuf cluster recording does not have a valid recording uuid
newClusterIterAndBool.second
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationModel.mm
mapIdentifiers
maxDistanceBelowPersistenceThreshold
minDistanceAbovePersistenceThreshold
void CLMicroLocationModel::mapIdentifiersFromOldModelAndPruneNoiseClusters(const CLMicroLocationModel &, const std::vector<CLMicroLocationAnchor> &, const std::vector<CLMicroLocationAnchor> &, NSMutableDictionary *)
Model has become invalid after pruning clusters with absolute size threshold
MicroLocationsClusterPersistenceDistanceThreshold
MicroLocationsClusterSizeThreshold
MicroLocationsClusterSizeRatio
void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType)
#Warning Tried to run learning, but learning is disabled
#Warning Tried to run learning, but database is not valid
domain
cancelled
inserted
runTime
learnCounter
com.apple.MicroLocation.ModelLearning
com.apple.MicroLocation.ModelLOITypes
foundHome
foundWork
foundAirPlay
%@%@
minClusterRfSize
maxClusterRfSize
avgClusterRfSize
void CLMicroLocationLearner::updateClusterRfDistanceMetrics(NSMutableDictionary *, CLMicroLocationModel &)
Model cluster RF sizes %@: %f (min), %f(max), %f (mean)
minClusterRfDistance
maxClusterRfDistance
avgClusterRfDistance
Model cluster RF distances %@: %f (min), %f(max), %f (mean)
std::vector<CLMicroLocationAnchor> CLMicroLocationLearner::updateAllowedAnchorDevicesList(CLMicroLocationLearner::ShouldCancelFunction, const std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const std::vector<CLMicroLocationAnchor> &, const cl::chrono::CFAbsoluteTimeClock::time_point &)
Allowed Anchors logic disabled in settings
Allowed Anchors have no recording triggers!
#Warning shouldCancel is True, Allowed anchors not updated
com.apple.MicroLocation.Anchors
numAddedBleDevices
numAddedUwbDevices
numRemovedBleDevices
numRemovedUwbDevices
numRecognizedBleDevices
numRecognizedUwbDevices
numPendingBleDevices
numPendingUwbDevices
void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto::Model::ModelType, NSMutableDictionary *)
#Warning No recording events for model type %{public}d
got sufficient recording triggers, will ignore prior cluster number in learning
ageOfOldModel
#Warning Fingerprint vector empty for model type %d at iteration %d
numFingerprints
numFingerprintsBounded
ageOfOldestFingerprint
ageOfOldestFingerprintBounded
ageOfNewestFingerprint
maxFingerprintDuration
minFingerprintDuration
avgFingerprintDuration
maxFingerprintSize
minFingerprintSize
avgFingerprintSize
maxWifiFingerprintSize
minWifiFingerprintSize
avgWifiFingerprintSize
maxBleFingerprintSize
minBleFingerprintSize
avgBleFingerprintSize
maxUwbFingerprintSize
minUwbFingerprintSize
avgUwbFingerprintSize
numSourcesWifi
numSourcesWifiBounded
numSourcesBle
numSourcesBleBounded
numSourcesUwb
numSourcesUwbBounded
numFingerprintsPrunedInIteration%u
portionFingerprintsPrunedInIteration%u
numClustersPrunedIteration%u
portionClustersPrunedIteration%u
#Warning Learning cancelled because %{private}s
set model to stable
Configuration_Default
Configuration_Candidate
configSelect
numNewBleSourcesBounded
numNewUwbSourcesBounded
numRemovedBleSourcesBounded
numRemovedUwbSourcesBounded
numClusters
numOldClusters
numClustersDiff
numMatchingClustersInt
portionMatchingClusters
numFingerprintsInCluster%zu
numFingerprintsInRemainingClusters
numFingerprintsInSmallestCluster
Model generated successfully for type %{public}d
#Warning Model was not generated properly. Inserted: %{public,bool}d
No models were generated for model type %{public}d
MicroLocationsEnableLearning
MicroLocationsEnableSamplingForLearningAnalyticsOnInternal
MicroLocationsSamplingRateForLearningAnalytics
MicroLocationsFingerprintDistanceFunctionType
MicroLocationsAllowedAnchorsEnable
MicroLocationsAllowedAnchorsMaxEnableTimeDBPercentage
MicroLocationsAllowedAnchorsMaxDisableTimeDBPercentage
MicroLocationsNumberOfModelIterations
MicroLocationsLearnerAlgorithm
MicroLocationsMinimumNumberOfRecordingsInStableModel
MicroLocationsMinimumNumberOfDaysWithRecordingsInStableModel
MicroLocationsAdaptiveAnchorsEnable
MicroLocationsFingerprintDataSource
MicroLocationsMaximumNumberOfClustersForLearningAnalytics
 DataType:
 Status:
 New:
 Removed:
/dev/urandom
sha1 too many bytes
void boost::uuids::detail::sha1::process_byte(unsigned char)
/System/Volumes/Data/SWE/iOS/BuildRoots/BuildRoot903/Applications/Xcode.app/Contents/Developer/Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator8.3.Internal.sdk/usr/local/include/boost/uuid/sha1.hpp
Not enough elements in call to seed.
shared_ptr.hpp
bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationModelTable::Entry]
#Warning Can't insert because the database is invalid
bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationModelTable]
%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem
com.apple.MicroLocation.Analytics
histogramTotalChannelCount
localizationChannelCount
localizationChannelUtilization
MicroLocationsLocalizingTopChannels
CFGetTypeID(cfType) == CFArrayGetTypeID()
MicroLocationsNumberDaysToAnalyzeWiFiChannels
bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationConfigurationTable::Entry]
bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationConfigurationTable]
modelTypeIndex < recordingEventsForModel.size()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationSettings.mm
getRecordingEventsForModelType
kMicroLocationConfigurationSelect
getFingerprintDistanceFunctionParamsForType
MicroLocationsRecordingEventsForModel
primitiveTypeToSettingType
MicroLocationsAllowedAnchorsSupportedDataTypes
CFGetTypeID(cfType) == CFNumberGetTypeID()
didConvert
MicroLocationsUseAlternativeSetting
MicroLocationsCombinedEuclideanJaccardParams
{"jaccard_threshold" : 0.75, "jaccard_scale_factor" : 20.0}
MicroLocationsWeightedEuclideanJaccardParams
{"jaccard_scale_factor":1.0,"e2j_kernel_thr":0.5,"per_source_params": {"value_scale_factor" :{"wifi":0.05,"ble":0.025,"uwb":0.15}, "euclidean_weight":{"wifi":3.0,"ble":3.0,"uwb":50.0}, "jaccard_pos_weight":{"wifi":2.0,"ble":2.0,"uwb":2.0},"jaccard_neg_weight":{"wifi":1.0,"ble":5.0,"uwb":10.0},"onesided_jaccard":{"wifi":true,"ble":false,"uwb":false}}}
MicroLocationsTanimotoBaseParams
void CLMicroLocationMeasurementTable::initTable()
Database is not connected so we can't intialize our table
RecordingUUID
bool CLMicroLocationMeasurementTable::insertOrReplace(const std::vector<Entry> &)
(SELECT 
EventType
 AND HEX(
Event
) NOT LIKE 
'080111________________1A021002%'
std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectLearningMeasurementsByLOITypeBetweenTimes(const std::string &, const std::string &, const std::string &, uint32_t)
std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &, uint32_t)
!recordingUUIDs.empty()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationMeasurementTable.mm
selectMeasurementsFromRecordingUUIDs
bool CLMicroLocationMeasurementTable::deleteOldestRows(uint64_t)
ScanMCTimestamp
uint32_t CLMicroLocationMeasurementTable::numLocalizationScansBetweenTimes(const std::string &, const std::string &)
#Warning Table is not valid so we can't numLocalizationScansBetweenTimes
SELECT COUNT(DISTINCT 
uint32_t CLMicroLocationMeasurementTable::numRecordingScansBetweenTimes(const std::string &, const std::string &)
#Warning Table is not valid so we can't numRecordingScansBetweenTimes
) LIKE 
ScanCFTimestamp
std::vector<CLMicroLocationMeasurementTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)
signedValue >= 0
signedValue <= std::numeric_limits<IntType>::max()
LocalizationScan
com.apple.MicroLocation.Localization
bleFingerprintSize
bleFingerprintSizeBounded
uwbFingerprintSize
uwbFingerprintSizeBounded
maxClusterProbability
nullspaceClusterProbability
wifiFingerprintSize
wifiFingerprintSizeBounded
localizationTriggerEvent
localizationTriggerEventCount
localizationRunTime
LocalizationProcessing
com.apple.microlocation.localization.triggers
void CLMicroLocationLocalizer::localize()
Localizer has invalid model, reporting empty results.
Localizer doesn't have any valid measurements to use, reporting empty results.
#Warning Skipping model type %{private}d because it is invalid
Localizer doesn't have minimum number of measurements to use for modelType:%{private}u, reporting empty results.
#Warning microlocation probability vector should sum to 1.0 %{public}f
com.apple.locationd.microlocation.reload-models
{vector<CLMicroLocationLocalizer::ModelAndIds, std::allocator<CLMicroLocationLocalizer::ModelAndIds>>=^{ModelAndIds}^{ModelAndIds}{__compressed_pair<CLMicroLocationLocalizer::ModelAndIds *, std::allocator<CLMicroLocationLocalizer::ModelAndIds>>=^{ModelAndIds}}}8@?0
void CLMicroLocationLocalizer::reloadModels()
time to load models, %{public}.3lf
void CLMicroLocationLocalizer::reloadModels(std::vector<ModelAndIds> (^)())
CLMicroLocationLocalizer: Reloaded a new model
#Warning CLMicroLocationLocalizer: Told to reload the model but it is invalid. Not changing current model
MicroLocationsLocalizerAlgorithm
MicroLocationsMinimumMicroLocationProbabilityForLocalization
auto CLMicroLocationLocalizer::reloadModels()::(anonymous class)::operator()() const
auto CLMicroLocationLocalizer::localize()::(anonymous class)::operator()(auto, const auto &) const [currentSum:auto = double, result:auto = CLMicroLocationResultInternal]
#Warning microlocation probability should be non-negative %{public}f
static_cast<uint32_t>(type) < static_cast<uint32_t>(DataSourceType::kTypeCount)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationFingerprintDataSources.mm
com.apple.locationd.
void CLMicroLocationXPCActivityHelpers::XPCActivity::setState(xpc_activity_state_t)
#Warning Unable to mark activity as %{public}ld. current state is %{public}ld
auto CLMicroLocationXPCActivityHelpers::XPCRegistration::XPCRegistration(std::string, const CLMicroLocationXPCActivityHelpers::XPCCriteria &, CLMicroLocationXPCActivityHelpers::XPCActivityHandler)::(anonymous class)::operator()(xpc_activity_t) const
Checking in for %{public}s
configuration.type() == CLMicroLocationProto::WIFI_HISTOGRAM
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationWiFiChannelHistogramAnalyzer.mm
histogramFromProtobuf
x.datatype() == y.datatype()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationFingerprintDistanceFunction.mm
computeDifference
double CLMicroLocationFingerprintDistanceFunction::weightedEuclideanJaccardDistance(const CLMicroLocationFingerprint &, const CLMicroLocationFingerprint &, double, double, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<bool> &, const CLMicroLocationUtils::Technologies &, const std::optional<CLMicroLocationAnchorAppearanceMap> &)
euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!
e2jKernelThr>0 && e2jKernelThr<=1.0
weightedEuclideanJaccardDistance
bitset test argument out of range
ii >= 0 && ii < size()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationFingerprintVector.mm
static std::optional<CLMicroLocationProto::BleLeechedBeacons> CLMicroLocationProtobufHelper::protobufFromNativeImpl(const CLMicroLocationBleWrapperForCBDevice &)
Invalid CBDevice IDS UUID
Undefined Model
com.apple.magicalmoments
MAGICAL_MOMENTS
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationProtobufHelper.mm
modelTypeFromString
localizationRequest
appLaunch
siriInvocation
backlightOn
batteryChargerConnected
forcedRecording
firstWakeOfDay
homekitAccessory
homekitScene
nowPlaying
recordingRequest
triggerInvalid
std::vector<CLWifiService_Type::AccessPoint> CLMicroLocationScanBuffer::pruneAps(cl::chrono::CFAbsoluteTimeClock::time_point, cl::chrono::CFAbsoluteTimeClock::duration)
Pruned %{public}ld AP measurements, buffer size %{public}ld
model.isValid()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationNullSpaceAlgorithm.mm
localize
MicroLocationsNullSpaceDistanceReductionFunction
MicroLocationsNullSpaceKernelFunction
{"type" : 2, "sigma" : 0.625, "power" : 3.0}
static_cast<uint32_t>(type) < static_cast<uint32_t>(ReducerFunctionType::kTypeCount)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationAlgorithms.h
createReducerFunction
minimumValueSorted
CLReducerFunction.h
container.size()>0
minimumValue
meanValue
maximumValueSorted
maximumValue
firstQuartileValueSorted
medianValueSorted
truncatedMeanValueSorted
numElements>0
fCurrentTransaction
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationRecorder.mm
recordMeasurementBatch
recordEvent
bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationRecordingEventsTable::Entry]
bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationRecordingEventsTable]
bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationMeasurementTable::Entry]
bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationMeasurementTable]
newState == ScanningState::Localizing || newState == ScanningState::Recording
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationLogic.mm
advance
void CLMicroLocationLogic::State::advance(CLMicroLocationLogic::State::ScanningState)
Advanced from %{public}s to %{public}s
reverse
void CLMicroLocationLogic::State::reverse()
Reversed from %{public}s to %{public}s
void CLMicroLocationLogic::State::updateWifiScanStrategiesIfNecessary()
Updating localizing scan strategy
NotScanning
Localizing
Recording
void CLMicroLocationLogic::State::setSpectatingEnabled(bool)
Spectating set to %{public}s
not running
void CLMicroLocationLogic::State::setBleSpyscanSessionRunning(bool)
BLE spyscan session set to %{public}s
stopped
void CLMicroLocationLogic::State::setRangingSessionRunning(bool)
Ranging session set to %{public}s
bool CLMicroLocationLogic::State::isNiSessionStateResumedForRequiredPeriod(cl::chrono::CFAbsoluteTimeClock::duration) const
Ni Session is in state %{public}d for the last  %{public}0.3Lfs
Uwb range buffer
virtual CLMicroLocationLogic::~CLMicroLocationLogic()
CLMicroLocationLogic: DTOR
void CLMicroLocationLogic::reloadSettings()
CLMicroLocationLogic: Settings updated so updating wifi strategies, allowed anchor models, and checking enabled flags
void CLMicroLocationLogic::startRecordingOrLocalizingIfAppropriate(const CLMicroLocationProto::RecordingEvent &)
Not recording or localizing since we're not enabled
CLMicroLocationLogic: startRecordingOrLocalizingIfAppropriate Recording parameters: localize: %d, record: %d
Spectating disabled
Already localizing
Localizing blacked out
No valid models
Recording interrupted due to localization request
Low power mode
Already recording
Recording blacked out
Localization in progress, recording enqueued
void CLMicroLocationLogic::startLocalizing(const CLMicroLocationProto::RecordingEvent &, cl::chrono::secondsf)
Localization started
void CLMicroLocationLogic::stopLocalizing()
Localization stopped
Popped a queued recording trigger
void CLMicroLocationLogic::startRecording(const CLMicroLocationProto::RecordingEvent &)
Recording started
com.apple.microlocation.recording.triggers
recordingTriggerEvent
recordingTriggerEventCount
void CLMicroLocationLogic::updateLocalizerAndRecorderInternalBuffersWithLeechedDevices()
Read BLE spyscan buffer in Logic!. read %lu measruements
not available
BLE spyscan buffer overflow
UWB range buffer overflow
void CLMicroLocationLogic::updateLocalizerAndRecorderInternalBufferWithUwbRanges()
uwb cached scan, read %{public}lu measurements
meas index: %{public}d, deviceId: %{private}s, range: %{private}f, age: %{public}f
void CLMicroLocationLogic::stopRecording()
Recording stopped
onRecordingTimerStopped
homeKitScanPolicy
Model Type %{private}d disabled in settings
void CLMicroLocationLogic::startBleSpyscanSessionIfStopped()
BLE spyscan session already running
Start BLE spyscan session
void CLMicroLocationLogic::stopBleSpyscanSessionIfRunning()
Stopping BLE spyscan session
BLE spyscan session already stopped
void CLMicroLocationLogic::startRapportSessionIfStopped()
Rapport, rapport session already running
Rapport, start rapport session
void CLMicroLocationLogic::stopRapportSessionIfRunning()
Rapport, stopping rapport session
Rapport, rapport session already stopped
void CLMicroLocationLogic::updateSpectating()
Already spectating
Start spectating
Not enabled, stop spectating
Not enabled, will not start spectating
No model types supported in state %{public}s, stop spectating
No model types supported in state %{public}s, will not start spectating
void CLMicroLocationLogic::updateModelsInMemory()
Spectating enabled and no model loaded yet. Trying to reload the model
Spectating disabled and has model loaded. Trying to purge the model
updateModelsInMemory, no need to update models, ignore
void CLMicroLocationLogic::startRangingSessionIfStopped()
ranging session already running
start a ranging session
void CLMicroLocationLogic::stopRangingSessionIfRunning()
stop a ranging session
ranging session already stopped
void CLMicroLocationLogic::updateRangingSession()
Not enabled
No model type supported in state %{public}s
recordingDuration
void CLMicroLocationLogic::onResetLocationData()
Got request to reset Location data. Dropping microlocation tables
void CLMicroLocationLogic::onForceRecordNotification(cl::chrono::CFAbsoluteTimeClock::time_point)
Force Recording received
void CLMicroLocationLogic::onFirstWakeOfDay(cl::chrono::CFAbsoluteTimeClock::time_point)
First Wake of Day received
void CLMicroLocationLogic::onDisplayState(cl::chrono::CFAbsoluteTimeClock::time_point, CLMicroLocationLogic::DisplayState)
Display state on received
Display state off received
void CLMicroLocationLogic::onModelGenerated(CLMicroLocationProto::Model::ModelType)
Models have been regenerated. Telling localizer to refresh model
onModelGenerated, told to refresh model, ignore, no model loaded yet
,domain,
,isStable,
,numberOfMicroLocations,
,microLocationId,
,probability,
,number of WiFi devices, 
,number of BLE devices, 
,number of UWB devices, 
virtual void CLMicroLocationLogic::onMicroLocationsLocalized(const CLMicroLocationMeasurementInternal &)
Localizer results,%{private}s
void CLMicroLocationLogic::reloadWifiChannelHistogram()
Don't have a current wifi channel histogram for this LOI type %{private}s
Reloaded wifi channel histogram
void CLMicroLocationLogic::updateEnabled()
Enabled state: microlocations defaults enabled: %{public}d; location services enabled: %{public}d; significant locations enabled: %{public}d; overall enabled: %{public}d
MicroLocations have been disabled. Clients will no longer get notifications until we are enabled again.
MicroLocations are now re-enabled. Clients should begin getting notifications again
void CLMicroLocationLogic::onKeybagUnlocked()
Keybag is unlocked. Possibly will update in memory models
void CLMicroLocationLogic::setUwbRangingIgnoredIfNiSessionNotResumed()
Setting all UWB measurements as ignored since NI, Session is not resumed for long enough
MicroLocationsLocalizingDurationMinimum
MicroLocationsRecordingDuration
MicroLocationsWifiTimestampJitterThreshold
MicroLocationsBleScanBufferSize
MicroLocationsUwbRangeBufferSize
MicroLocationsRapportMonitorMaxEntries
MicroLocationsAnchorDeviceModelAllowedList
AppleTV
AudioAccessory1
MacPro
AudioAccessory5
MacMini
iMac
set_localizationrequesttype
::CLMicroLocationProto::LocalizationRequestType_IsValid(value)
set_recordingrequesttype
::CLMicroLocationProto::RecordingRequestType_IsValid(value)
MicroLocationsAppLaunchReasonRecordingAllowedList
com.apple.SpringBoard.transitionReason.homescreen
MicroLocationsLocalizingBacklightOnInitialScanDelay
MicroLocationsLocalizingBlackoutDuration
MicroLocationsRecordingBlackoutDuration
MicroLocationsMaximumAgeForValidity
MicroLocationsMinimumNumberOfMeasurementsForFingerprint
MicroLocationsLocalizingDurationMaximumIncrements
MicroLocationsLocalizeWithRecordingMeasurements
MicroLocationsBleScanMaximalAgeForValidity
MicroLocationsUwbRangeMaximalAgeForValidity
MicroLocationsHomeKitScanDutyCycle
MicroLocationsEnabledModelTypes
CFGetTypeID(cfType) == CFBooleanGetTypeID()
MicroLocationsScanBleLeechedBeaconsRSSIEnabled
MicroLocationsRapportUsageEnabled
MicroLocationsScanUWBRangeEnabled
MicroLocationsLocalizingDurationIncrement
MicroLocationsEnabled
MicroLocationsUwbRangeLocalizationIgnoreOnNiSuspendEnable
MicroLocationsUwbRangeLocalizationMinValidSessionTime
micro
CLEventsBuffer<CLMicroLocationProto::Measurement, double, ProtoMeasurementGetTime>::CLEventsBuffer(size_t) [Event = CLMicroLocationProto::Measurement, Time = double, CallableEventGetTime = ProtoMeasurementGetTime]
Initialize EventsBuffer
CLEventsBuffer<CLMicroLocationProto::Measurement, double, ProtoMeasurementGetTime>::CLEventsBuffer(size_t, std::string) [Event = CLMicroLocationProto::Measurement, Time = double, CallableEventGetTime = ProtoMeasurementGetTime]
Initialize EventsBuffer %s
set_recordingeventtype
::CLMicroLocationProto::RecordingEventType_IsValid(value)
void CLEventsBuffer<CLMicroLocationProto::Measurement, double, ProtoMeasurementGetTime>::truncateBuffer() [Event = CLMicroLocationProto::Measurement, Time = double, CallableEventGetTime = ProtoMeasurementGetTime]
EventsBuffer %s: size before truncation %lu
channel: 
 count: 
nsObject != nullptr && [nsObject isKindOfClass:[NSDictionary class]]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationSettingsTypes.mm
CLMicroLocationDictionary
MicroLocationSettings
void CLMicroLocationErrorHandling::reportError(const std::string &)
Microlocation error report: %s
errorType
void CLMicroLocationErrorHandling::reportError(NSString *)
Microlocation error report: %@
com.apple.MicroLocation.ErrorCases
CLMicroLocationFingerprintConfiguration &CLMicroLocationFingerprintConfiguration::updateAnchorsFromVector(const std::vector<CLMicroLocationAnchor> &)
Allowed Anchors, fingerprint configuration updated from vector
Allowed Anchors, fingerprint configuration not updated since setting is disabled
CLMicroLocationFingerprint::CLMicroLocationFingerprint(const CLMicroLocationProto::Fingerprint &)
#Warning The protobuf fingerprint does not have a valid recording uuid
size(dataType) <= maximumNumberOfMeasurements
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationFingerprint.mm
removeExceedingMeasurements
!multiSet.empty()
CLMicroLocationFingerprint
configuration.fMinimumScanTimeDifference < configuration.fMaximumScanTimeDifference
createVector
!recordingTriggers.empty()
static std::vector<CLMicroLocationFingerprint> CLMicroLocationFingerprint::createVector(const std::vector<CLMicroLocationMeasurementTable::Entry> &, const std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationFingerprintConfiguration &)
A measurement's recording UUID does not have a corresponding event entry
fingerprintVector.size() <= 1
create
measVector.size() == uniqueMeasurementSet.size()
convertDoubleVectorToFingerprint
MicroLocationsMinimumScanTimeDifferenceForFingerprintMeasurements
MicroLocationsMaximumScanTimeDifferenceForFingerprintMeasurements
MicroLocationsMinimumDurationForFingerprint
MicroLocationsMaximumNumberOfWifiRssiMeasurementsForFingerprint
MicroLocationsMinimumBleDurationForFingerprint
MicroLocationsMaximumNumberOfBleRssiMeasurementsForFingerprint
MicroLocationsMinimumUwbRangeDurationForFingerprint
MicroLocationsMaximumNumberOfUwbRangeMeasurementsForFingerprint
void CLMicroLocationRecordingEventsTable::initTable()
Sucessfully created table if necessary: %{private}s
bool CLMicroLocationRecordingEventsTable::insertOrReplace(const std::vector<Entry> &)
Failed to bind on INSERT OR REPLACE with sql %{private}s
std::vector<std::string> CLMicroLocationRecordingEventsTable::selectAllLOITypes(uint32_t)
#Warning Table is not valid so we can't select all LOIs
std::vector<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::selectRecordingEventsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &, uint32_t)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationRecordingEventsTable.mm
selectRecordingEventsFromRecordingUUIDs
) FROM 
std::vector<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::selectRecordingEventTriggersForLearningMeasurements(const std::vector<CLMicroLocationProto::RecordingEventType> &, uint32_t, const std::string &)
!eventTypes.empty()
selectRecordingEventTriggersForLearningMeasurements
bool CLMicroLocationRecordingEventsTable::deleteOldestRows(uint64_t)
ReceivedTimestamp
std::vector<CLMicroLocationRecordingEventsTable::Entry> CLMicroLocationRecordingEventsTable::selectRecordingEventsBetweenTimes(const std::string &, const std::string &, uint32_t)
cl::chrono::CFAbsoluteTimeClock::time_point CLMicroLocationRecordingEventsTable::selectOldestRecordingTimestamp()
std::vector<CLMicroLocationRecordingEventsTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t, const std::string &)
CLMicroLocationFingerprintStdVectorSource::CLMicroLocationFingerprintStdVectorSource(CLMicroLocationFingerprintDataSources::ShouldCancelFunction, CLMicroLocationFingerprintDataSources::ConfigurationLoaderFunction, const std::vector<CLMicroLocationRecordingEventsTable::Entry> &, CLMicroLocationDatabase &)
Data source cancelled learning
bool CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationRapportTable::Entry]
bool CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationRapportTable]
CLMicroLocationAnchorAppearanceMap::CLMicroLocationAnchorAppearanceMap(const CLMicroLocationProto::anchorAppearancesVector &)
#Warning The protobuf Anchor Appearance struct does not have a valid device ID
CLMicroLocationProto::anchorAppearancesVector CLMicroLocationAnchorAppearanceMap::toProtobuf() const
MicroLocationsAdaptiveAnchorsNumDaysToKeepEnabled
MicroLocationsAdaptiveAnchorsNumValidDaysForPurging
MicroLocationsAdaptiveAnchorsMaxEntriesInAppearanceMap
void CLMicroLocationModelTable::initTable()
#Warning Database is not connected so we can't intialize our table
Failed to create table: %{public}s
Sucessfully created table if necessary: %{public}s
bool CLMicroLocationModelTable::insertOrReplace(const std::vector<Entry> &)
#Warning Table is not valid so we can't insert or replace
Failed to bind on INSERT OR REPLACE for sql %{private}s
Failed to execute statement. %{private}s
#Warning Table is not valid so we can't select all
 AND 
std::vector<CLMicroLocationModelTable::Entry> CLMicroLocationModelTable::getMostRecentModels()
#Warning Table is not valid so we can't get the most recent model
std::optional<CLMicroLocationModelTable::Entry> CLMicroLocationModelTable::getMostRecentModelOfModelType(CLMicroLocationProto::Model::ModelType)
ModelType
ModelUUID
 in 
bool CLMicroLocationModelTable::deleteUnneededModels(uint32_t)
#Warning Table is not valid so we can't deleteUnneededModels()
Keeping %{public}d models per model type
 DESC 
 LIMIT 
bool CLMicroLocationModelTable::deleteOldestRows(uint64_t)
#Warning Table is not valid so we can't deleteOldestRows
 IN (
Model
RowId
 DESC LIMIT 
) ORDER BY 
std::vector<CLMicroLocationModelTable::Entry> (anonymous namespace)::selectEntries(CLSqliteDatabase &, const std::string &, uint32_t)
Error converting database values. %{public}s
text
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationDatabaseColumns.h
convert
blob
Unable to parse protobuf
auto CLMicroLocationModelTable::deleteUnneededModels(uint32_t)::(anonymous class)::operator()(const std::string &) const
VALUES (
deltaDays < 0 && "deltaDays must be negative"
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationTimeUtils.mm
getStartOfDayDeltaDaysAgo
deltaDays <= 0 && "deltaDays must be non positive"
getTimeDeltaDaysAgo
virtual UnlockResult CLHistogramHypothesisTestUnlockEstimator::estimate(const std::vector<RangeMeasurement> &, double)
WRTT: rangeThreshold %{private}f resulted in 0 unlock probability, not unlocking
WRTT: Range %{private}f resulted in 0 unlock probability, skipping range
double (anonymous namespace)::getHistogramProbability(double, const std::map<double, double> &)
Measurement %{private}f outside of histogram range
bool CLPeerRangingDecisionProcessor::shouldUnlock(const std::vector<RangeMeasurement> &)
WRTT: Estimating shouldUnlock with unlockThreshold: %f
estimator != nullptr && "unlock estimator must be allocated"
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/PeerRanging/CLPeerRangingDecisionProcessor.mm
filterRangesAndEstimateUnlock
virtual double CLPhonePeerRangingDecisionProcessor::getUnlockThreshold()
WRTT: Unexpected hardware %{public}d in getUnlockThreshold
virtual std::unique_ptr<CLIUnlockEstimator> CLPhonePeerRangingDecisionProcessor::getUnlockEstimator()
WRTT, Using CLHistogramHypothesisTestUnlockEstimator with phone unlock histograms
virtual double CLMacPeerRangingDecisionProcessor::getUnlockThreshold()
WRTT, Received DeviceType iPhone in CLMacPeerRangingDecisionProcessor
WRTT, Target does NOT require range correction. Target Type: %u
WRTT, Target requires range correction. Target Type: %u
CLPredictedWalkDistanceServiceCompanionSilo
-[CLPredictedWalkDistanceServiceCompanion beginService]
Starting up CLPredictedWalkDistanceServiceCompanion
P6MWDMinHoursPerDay
P6MWDPredictionInterval
kP6MWDNextEstimateTime
-[CLPredictedWalkDistanceServiceCompanion scheduleEstimate]
com.apple.locationd.P6MWD
%{public}s: Registering XPC Activity with nextEstimateTime=(%{public}.2f) and delay=(%{public}lld)
CLPredictedWalkDistanceServiceCompanion
-[CLPredictedWalkDistanceServiceCompanion scheduleEstimate]_block_invoke
XPC_CHECK_IN: Setting up %{public}s activity with a delay of %{public}lld seconds
P6MWDAggregationTimeInterval
-[CLPredictedWalkDistanceServiceCompanion setUpAggregationOnTimer]_block_invoke
Aggregating bout records
-[CLPredictedWalkDistanceServiceCompanion onP6MWDActivity:]
Preparing to make weekly 6MWD prediction
-[CLPredictedWalkDistanceServiceCompanion getSixMinuteWalkDistancePrediction:]
Estimate should not be made now. %{public}s is in the future (%{public}.2f). Resetting!
P6MWDActivityHistoryDuration
-[CLPredictedWalkDistanceServiceCompanion getSixMinuteWalkDistancePrediction:]_block_invoke
Bout query failed due to device lock
Retrieved %{public}lu bout records
CLNatalimetryNotifier
Retrieved demographics: age=%{private}.0f, height=%{private}.2f, weight=%{private}.1f
No remote StepCadenceToStrideLength table, error:%s
Parsing remote StepCadenceToStrideLength table
v32@?0@"NSArray"8@"NSDate"16@"NSError"24
No StepCadenceToStrideLength table, error:%{public}s
Parsing StepCadenceToStrideLength table
WalkingSpeedCal query failed due to device lock
Retrieved %{public}lu walkingSpeedCal records
HealthKit queries from %{public}.0f to %{public}.0f
HealthKit Activity Summary query failed due to device lock
HealthKit Activity Summary query encountered error,%{public}ld
Retrieved activity summary... startDate: %{private}@, endDate: %{private}@, Flights climbed: %{private}f, Step count: %{private}f, Exercise minutes: %{private}f
v32@?0@"HKActivitySummaryQuery"8@"NSArray"16@"NSError"24
HealthKit Workout query failed due to device lock
HealthKit Workout query encountered error,%{public}ld
Found workout... Type: %{private}lu, indoor: %{private}d, startTime: %{private}f, endTime: %{private}f
v32@?0@"HKSampleQuery"8@"NSArray"16@"NSError"24
HealthKit Stand Hour query failed due to device lock
HealthKit Stand Hour query encountered error,%{public}ld
Retrieved sample... Stand hour: %{private}f, startTime: %{private}@, endTime: %{private}@
HealthKit Flights query failed due to device lock
HealthKit Flights query encountered error,%{public}ld
Retrieved sample... Flights climbed: %{private}f, startDate: %{private}@, endDate: %{private}@ from %{private}@
Watch4
Flights from series 4 watch observed, consider only phone flights
iPhone
Attempting to defer activity
Failed to mark activity as deferred. Current state is %{public}ld
At least one required query failed due to device lock. Rescheduling the activity to try again soon.
Hours for day %{private}f - %{private}f, %f (%f)
Using cadenceStrideLengthOffset of %{private}.3f
p6MWD lastResetTime, %f
Weekly p6MWD estimate unavailable, status %{public}d
-[CLPredictedWalkDistanceServiceCompanion completeActivity:withNextEstimateTime:]
Failed to mark %{public}s activity as Done. Current state is %{public}ld
-[CLPredictedWalkDistanceServiceCompanion writeToHealthKitPrediction:estimateTime:earliestTimeUsed:calibrationStatus:]
Writing predicted 6MWD to HealthKit, startTime: %{public}f, endTime: %{public}f, prediction: %{private}f, calibrationStatus: %{private}d, earliestTimeUsed: %{private}f
-[CLPredictedWalkDistanceServiceCompanion writeToHealthKitPrediction:estimateTime:earliestTimeUsed:calibrationStatus:]_block_invoke
saveObjects failed to insert a 6MWD sample, error, %{public}@
saveObjects successfully pushed 6MWD update
-[CLPredictedWalkDistanceServiceCompanion receivePredictedWalkDistanceBout:]
Received message in CLPredictedWalkDistanceServiceCompanion
Received bout from watch...,startTime,%{private}f,endTime,%{private}f
Gait Metrics unavailable, likely because device is locked.
-[CLPredictedWalkDistanceServiceCompanion onUserInfoUpdate:data:]
CLPredictedWalkDistanceServiceCompanion: Received user info update
#Warning Unhandled notification type, %d
-[CLPredictedWalkDistanceServiceCompanion sendAnalyticsWeeklyEstimate:strideCalInfo:walkingWorkoutPaceStats:runningWorkoutPaceStats:userInfo:]
Not sending analytics, no IHA permission
-[CLPredictedWalkDistanceServiceCompanion sendAnalyticsWeeklyEstimate:strideCalInfo:walkingWorkoutPaceStats:runningWorkoutPaceStats:userInfo:]_block_invoke
Prediction history query failed due to device lock
Prediction history query encountered error,%{public}ld
com.apple.CoreMotion.6MWD.WeeklyEstimate
weeklyEstimateStatus
numBouts
numBoutsTimeWStepsGreater300
numBoutsTimeWStepsGreater330
pRaw
pSpeed
pActivity
pDistance
userGender
userAge_bin
userHeight_bin
userWeight_bin
numWatchPedometerGPSCalibrations
numWalkingSpeedCalibrations
userStdDevEstimate
userRatioMeanSignedVarMeanAbsVar
percentLast13WeeksWithEstimate
slopeLast13Weeks
timeSinceFirstAvailable
numDaysWithSufficientWearTime
avgStepsPerDayLast4Weeks
avgFlightsPerDayLast4Weeks
numWalkingWorkoutsLast4Weeks
avgPaceWalkingWorkoutsLast4Weeks
avgPaceRunningWorkoutsLast4Weeks
void CLActivityAggregator<CLPredictedWalkDistanceBoutEntry>::setExpirationRule(CFTimeInterval) [T = CLPredictedWalkDistanceBoutEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<CLPredictedWalkDistanceBoutEntry>::aggregateRecords() [T = CLPredictedWalkDistanceBoutEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLPredictedWalkDistanceBoutEntry>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLPredictedWalkDistanceBoutEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
(--inf,inf)
(--inf,
,inf)
virtual void CMSensorFusionMekf::initializeAttitude()
initialized down,%u,q.x,%f,q.y,%f,q.z,%f,q.w,%f, withAvgGrav, %d
bool CMSensorFusionMekf::initializeState(const CMVector3d &, const CMVector3d &, float)
initializeState MaxInitialDiffUnity failed,magnitude,%f
initializeState northAndGravity failed
invalid initial covariance !(P > 0), using default
virtual void CMSensorFusionMekf::feedQuiescent(CMDeviceMotionInputs::QuiescentState, uint64_t)
invalid quiescentState kInMotion, ignoring quiescent
const CMVectorBufferBase::Element &CMVectorBufferBase<float, 3>::operator[](const size_t) const [T = float, N = 3]
Assertion failed: i < size(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 45,out of buffer range %zu.
CoarseCellTilesManager
CLCoarseCellTilesManagerExternal::CLCoarseCellTilesManagerExternal(CLCoarseCellTilesManager *, id<CLIntersiloUniverse>)
TileMgr, coarse, Timer allocation failure, #CloneMe
CLCoarseCellTilesManager::onClientNotification
CLCoarseCellTilesManager::onDataProtectionNotification
CLCoarseCellTilesManager::onCompanionNotification
CLCoarseCellTilesManager::onStatusNotification
double CLLogNormalNormalHypothesisTestUnlockEstimator::getScaleFactor(size_t, double) const
Error in numberOfMeasurements,%zu
Error in rangeIndex calculation, rangeIndex,%d
Error in index calculation, tableIndex,%d
kCMLogItemCodingKeyTimestamp
virtual CLWorkoutPredictor_Type::WorkoutStopDetectionEvent CLStationaryCycleStopModel::update(const CLWorkoutPredictorInputs &)
HRStop detect in indoor cycle model during state,%{public}d
IndoorCycleStop,state,%d,headingCnt,%d,longStd,%f,shortStd,%f,exertionDelta,%f,exertionLow,%d,vm,%f,fromBaseline,%f,inLikely,%d,steps,%d,combinedCnt,%d,deltaH,%f
WalkModelMetsScale
virtual CLMetsInfo CLNatalieWalkModel::computeWorkRateMETS(const CLNatalieModelInput &)
Walk, WorkRate, %f, distance(m), %f, duration(s), %f, userMets, %f, fMetsScaling, %f, endTime, %f, currentPace, %f, isStroller, %d, userMetsStrollerCorrected, %f, truthMets, %f, truthMetsStrollerCorrected, %f
Walk, WorkRate, Grade type, %d, vertical speed %f, interval %f, workrate %f, userMets %f, userMets + grade, %f, percent grade, %f, truthMets, %f, truthMets + grade, %f
virtual CLMetsInfo CLNatalieWalkModel::computeFitnessMachineMETS(const CLNatalieModelInput &)
Walk,fitness machine,computeTime,%.3f,startTime,%.3f,wr,%f,vertSpeed,%f,userMets,%f,truthMets,%f
00000000-0000-0000-0000-000000000000
bool CLSwimDataStore::reloadStateFromPersistentStore()
Historical-Distributions, loiUuid, %s, style, %d, poolLength, %f, median, %f, mean, %f, stddev, %f, min, %f, max, %f, samples, %d, prctile10, %f, prctile90, %f, uuid, %s
Historical median turns per session, median, %f, Nsessions, %lu
Did not successfully load state from db! CMError, %d
bool CLSwimDataStore::setFirstEntry()
Set first session entry
bool CLSwimDataStore::setupSessionPersistence()
Cannot yet set first swim session entry
void CLSwimDataStore::setCurrentLOI(NSArray *)
Got %d swimming LOIs.
Checking swimming LOI with id '%s'.
Found swimming distributions for LOI with id '%s'.
fSwimLocation == kCMSwimWorkoutLocationPool
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Swimming/CLSwimDataStore.mm
addTurn
swimStyle == distribution.style
updateDistribution
addLap
void CLSwimDataStore::persistSwimEntry(const CLSwimEntry &)
Deferring lap persistence.
Failure to store lap due to database inaccessibility.
Failure to store lap due to time rollback, startTime, %f, > endTime, %f
kSYDictionaryObjectSyncIDKey
-[CLTileSyncSyChange setChangeType:]
@GtsSync, Unexpected change type, %{public}ld, set, #CloneMe
-[CLTileSyncSySerializer dataFromChange:]
@GtsSync, CsSerial, dataFromChange, isKind, %{public}d
-[CLTileSyncSySerializer changeFromData:ofType:]
@GtsWarn, GizmoSync, changeFromData, %ld, #CloneMe
-[CLTileSyncDelegate service:startSession:error:]
@GtsFlow, CS, startSession, 2, timeout, %{public}.0f
-[CLTileSyncDelegate service:sessionEnded:error:]
@GtsFlow, CS, endSession, 6
-[CLTileSyncDelegate serviceDidPairDevice:]
@GtsSync, CsService, serviceDidPairDevice, state, %{public}c
-[CLTileSyncDelegate serviceDidUnpairDevice:]
@GtsSync, CsService, serviceDidUnpairDevice, state, %{public}c
-[CLTileSyncDelegate service:encounteredError:context:]
@GtsSync, CsError, 2, service, %{public}s, underlying, %{public}s
-[CLTileSyncDelegate syncSession:enqueueChanges:error:]
@GtsSync, CsSession, enqueue failed
@GtsFlow, CS, enqueueComplete, 4
-[CLTileSyncDelegate syncSession:applyChanges:completion:]
@GtsSync, CsSession, applyChanges, %{public}lu
@GtsSync, CsSession, More than 1 incoming change, %{public}lu, #CloneMe
-[CLTileSyncDelegate syncSession:didEndWithError:]
@GtsSync, CsError, 0, didEndWithError, %{public}s, underlying, %{public}s
@GtsFlow, CS, sessionDidEnd, 5, error, %{public}d, synctrap, %{public}d
@GtsFlow, PS, syncDidCompleteTx, 2
-[CLTileSyncDelegate syncSession:resetDataStoreWithError:]
@GtsSync, CsSession, resetDataStoreWithError
-[CLTileSyncDelegate service:willSwitchFromPairingID:toPairingID:]
@GtsSync, CsService, willSwitchPairing, old, %{public}s, new, %{public}s
-[CLTileSyncDelegate service:didSwitchFromPairingID:toPairingID:]
@GtsSync, CsService, didSwitchPairing, old, %{public}s, new, %{public}s
-[CLTileSyncDelegate syncCoordinator:beginSyncSession:]
@GtsSync, PsCoord, beginSyncSession, %{public}lu
Full
Reunion
Unknown
-[CLTileSyncDelegate syncCoordinator:beginSyncSession:]_block_invoke
@GtsFlow, PS, handleSyncTrapTurn%s, 1
@GtsFlow, PS, syncDidCompleteTx, 2, skipped
-[CLTileSyncDelegate syncCoordinator:didInvalidateSyncSession:]
@GtsSync, PsCoord, didInvalidateSyncSession, %{public}d
@GtsFlow, PS, didInvalidateSession, 3, restriction, %{public}d
-[CLTileSyncDelegate syncCoordinatorDidChangeSyncRestriction:]
@GtsSync, PsCoord, syncCoordinatorDidChangeSyncRestriction, %{public}d
-[CLTileSyncDelegate syncCoordinatorDidChangeSyncRestriction:]_block_invoke
@GtsSync, PsCoord, RestrictionUnknown, %{public}ld, #CloneMe
-[CLTileSyncDelegate initialSyncStateObserver:initialSyncDidCompleteForPairingIdentifier:]
@GtsSync, PsObserver, initialSyncDidCompleteForPairingID
-[CLTileSyncDelegate initialSyncStateObserver:syncDidCompleteForPairingIdentifier:]
@GtsSync, PsObserver, syncDidCompleteForPairingID
@GtsFlow, PS, syncDidCompleteRx, 4
-[CLTileSyncDelegate initialSyncStateObserver:syncDidResetForPairingIdentifier:]
@GtsSync, PsObserver, syncDidResetForPairingID
-[CLTileSyncDelegate initialSyncStateObserverClientCanRetryFailedRequests:]
@GtsSync, PsObserver, initialSyncStateObserverClientCanRetryFailedRequests
void CLTileSyncAWD::loadMetrics(CFAbsoluteTime)
@GtsAwd, plist, error, load, %{public}lu
@GtsAwd, plist, clear, %{public}.1f, thresh, %{public}.0f, last, %{public}.1f
@GtsAwd, plist, error, time, %{public}.1f, now, %.1f
loadcache
void CLTileSyncAWD::startSession(CFAbsoluteTime)
@GtsAwd, started, %{public}d
endsync
void CLTileSyncAWD::tilesRequested(CFAbsoluteTime, int)
@GtsAwd, request, tiles, %{public}d, total, %{public}d, sessions, %{public}d
void CLTileSyncAWD::tileSynced(CFAbsoluteTime, int)
@GtsAwd, serialized, %{public}d, totalmb, %{public}.1f
report
void CLTileSyncAWD::weekLongLogging(const char *, CFAbsoluteTime)
@GtsAwd, snap, %{public}s, sessions, %{public}d, empty, %{public}d, completed, %{public}d, errored, %{public}d, requested, %{public}d, synced, %{public}d, sizemb, %{public}.1f, week, %{public}d, %{public}.1f, sinceweekly, %{public}0.1f, reset, %{public}d, lastSave, %{public}0.1f, %{public}0.1f
assert
fExternal->isCompanion() || fExternal->isWatch()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTileSyncManager.mm
CLTileSyncManager
ManifestRate
QwsPeriod
CLTileSyncManager::CLTileSyncManager(CLITilesManager *, id<CLIntersiloUniverse>, std::unique_ptr<IExternal>, std::shared_ptr<CLWifiAccessPointLocationService>)
@GtsInit, CG, %{public}d, %{public}d, rate, %{public}0.0f, state, %{public}d, %{public}d, %{public}c, canDownload, %{public}d
CLTileSyncManager::CLTileSyncManager(CLITilesManager *, id<CLIntersiloUniverse>, std::unique_ptr<IExternal>, std::shared_ptr<CLWifiAccessPointLocationService>)_block_invoke
@GtsTimer, fired, %{public}s
Timer
virtual CLTileSyncManager::~CLTileSyncManager()
@GtsMgr, dtor
com.apple.pairedsync.locationd
bool CLTileSyncManager::psInitialize()
@GtsInit, PsObjects failed, C, %{public}d, O, %{public}d
com.apple.private.alloy.location.wifitilesync
bool CLTileSyncManager::csInitialize()
@GtsInit, CsObjects failed
void CLTileSyncManager::csRelease()
@GtsMgr, release
void CLTileSyncManager::csResume()
@GtsSync, CsError, 1, resume, %{public}s
bool CLTileSyncManager::handleSyncTrapTurn(bool)
@GtsMgr, xSyncTrap, canDownload
@GtsSync, since last switched, hours, %{public}0.1f, days, %{public}0.1f
@GtsMgr, xSyncTrap, days inactive, %{public}0.1f, thresh, %{public}0.1f, pending, %{public}d
@GtsFlow, CS, setNeedsReset, 1, BeginPair, state, %{public}c, %{public}c, queuewas, %{public}ld, inactive, %{public}0.1f
void CLTileSyncManager::handleRestrictionChange(bool)
@GtsSync, PsCoord, RestrictionLimitPush
@GtsSync, PsCoord, RestrictionNone
@GtsMgr, restriction, state was, %{public}c, now, %{public}c, restricted, %{public}d
CS Session
NSDictionary *CLTileSyncManager::handleStartSession(NSDictionary *)
@GtsWarn, GizmoSync, handleStartSession, #CloneMe
kCLTileSyncControlRequest
Control
Request
GizmoReq
NSDictionary *CLTileSyncManager::handleStartSessionCompanion(NSDictionary *)
@GtsMgr, Mismatching keys, syncId, %{public}s, request, %{public}s
@GtsMgr, Crossing sessions, %{public}c, #CloneMe
kCLTileSyncControlManifestDict
@GtsManif, CompTx, %{public}ld
@GtsMgr, Unexpected Companion startSession flow, type, %{public}c, #CloneMe
@GtsSync, CsService, startSession, %{public}c, mdin, %{public}ld, queue, %{public}ld, mdout, %{public}ld
CsErrorShort
CsErrorLong
bool CLTileSyncManager::handleSessionDidEnd(bool)
@GtsMgr, handleSessionDidEnd, error, %{public}d, %{public}d, change, %{public}c, pending, %{public}d, psActive, %{public}d, syncState, %{public}c, queue, %{public}ld, exchanged, %{public}d
std::tuple<bool, bool, bool> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)
@GtsManif, CompRx, %{public}ld, queue, %{public}lu, metadata
@GtsManif, BadId, enqueueC, %{private}s, #CloneMe
Assert Failed, %s, %d, %s
@GtsManif, CompReply, %{private}s, have, %{public}d
@GtsFlow, CS, metadataX, 3
@GtsFlow, CS, enqueueChanges, 3, Manifest, %{public}c
@GtsFlow, CS, enqueueChanges, 3, TileData, %{public}c, queue, %{public}ld
@GtsSync, CsSession, %{public}c, llsw, %{private}.2lf, %{private}.2lf, queue, %{public}ld
@GtsFlow, CS, enqueueChanges, 3, SyncTrap
@GtsFlow, CS, enqueueChanges, 3, Unexpected change type, %{public}c
@GtsSync, enqueue return, change, %{public}d, complete, %{public}d, large, %{public}d
std::tuple<bool, bool, bool> CLTileSyncManager::handleEnqueueChangesGizmo(NSDictionary *)
void CLTileSyncManager::handleApplyChanges(CLTileSyncSyChange *)
@GtsWarn, GizmoSync, handleApplyChanges, #CloneMe
@GtsMgr, change, syncId, %{public}s, type, %{public}ld
kCLTileSyncObjectDataKey
kCLTileSyncObjectSyncTimestampKey
@GtsCont, change with no data!!!
void CLTileSyncManager::handleSyncTrapEnd()
@GtsMgr, SyncTrapEnd, oldstate, %{public}c
ClosePS
void CLTileSyncManager::handleWillSwitch(NSUUID *)
@GtsMgr, willSwitch, new, %{public}s, days inactive, %{public}0.1f
void CLTileSyncManager::handlePairingSwitch(bool, bool)
@GtsMgr, handlePairSwitch, ids ,%{public}d, %{public}d, resume/suspend, %{public}c, state, %{public}c, %{public}c, restricted, %{public}d, inactive, %{public}0.1f
void CLTileSyncManager::handleServiceError()
@GtsSync, CsSync, handleServiceError, %{public}c
Indexed
void CLTileSyncManager::handleFirstUnlockGizmo()
@GtsGiz, reclearing
void CLTileSyncManager::handleNearbyCompanion()
@GtsMgr, Nearby, queue, %{public}lu, sessionErrors, %{public}d
Nearby
void CLTileSyncManager::handleToggleResetCompanion(int)_block_invoke
@GtsCont, ToggleReset, %{public}d, queuewas, %{public}ld
void CLTileSyncManager::handleToggleResetGizmo(int)
@GtsGiz, reclear pending
virtual void CLTileSyncManager::handleTileAdded(const char *, double, double)
@GtsCont, %{public}s, llsw, %{private}.2lf, %{private}.2lf
void CLTileSyncManager::addTileSync(CLTileFile *)
@GtsPair, skipevent, add, blocking sync state, %{public}c
@GtsCont, replaceadd, llsw, %{private}.2lf, %{private}.2lf, size, %{public}ld
@GtsCont, add, llsw, %{private}.2lf, %{private}.2lf, size, %{public}ld, current, {public}%d
void CLTileSyncManager::setManifestFire(const char *, CFTimeInterval)
@GtsTimer, direct, skip
@GtsTimer, nextfire, %{public}.0f, %{public}s, state, %{public}c
virtual void CLTileSyncManager::sendCompanionManifest(const char *)
@GtsManif, return, not companion
@GtsManif, skip, direct
@GtsManif, check, %{public}s, state, %{public}d, %{public}c, %{public}lu, sync, %{public}lu
@GtsManif, skip, %{public}s, state, %{public}d, sync, %{public}d
Syncing
@GtsFlow, CS, setHasChanges, 1, SendManifest
void CLTileSyncManager::createManifestInSyChange(bool)
@GtsManif, PrepTx, %{public}s, tiles, %{public}lu, %d, currentOnly, %{public}d
@GtsManif, entry, %{private}s, gentime, %{public}.1f
sendEventToGizmo
bool CLTileSyncManager::sendEventToGizmo(TileId &)
@GtsCont, addlost, llsw, %{private}.2lf, %{private}.2lf
Unable to send #tile, it is missing
v24@?0^v8Q16
@GtsComp, add, llsw, %{private}.2lf, %{private}.2lf, tile_x, %{private}d, tile_y, %{private}d, tilesize, %{public}ld, queue, %{public}lu
tileIdToAdd.tileType == CLTilesManager_Type::TileType::WIFI_Location
addTile
void CLTileSyncManager::addTile(const TileId &, NSData *, const CFAbsoluteTime &)
@GtsLock, drop add on LS off
@GtsSync, drop older add, timestamp, %{public}0.1f, toggle/reset, %{public}0.1f
@GtsError, Adding non-Wifi tile, %{public}d, #CloneMe
Failed writing tile to file, %{private}s
@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, sync, size, %{public}lu, unprot size, %{public}lu
@GtsLock, add, llsw, %{private}.2lf, %{private}.2lf, mapsize, %{public}ld
WifiPosition
Generic
SYDictionaryObject
/System/Library/PrivateFrameworks/CompanionSync.framework/CompanionSync
TileSyncAwd
PSYSyncCoordinator
/System/Library/PrivateFrameworks/PairedSync.framework/PairedSync
PSYInitialSyncStateObserver
SYService
CLAutoOSTransaction::CLAutoOSTransaction(const char *, CLAutoOSTransaction::LoggingPolicy)
com.apple.locationd.Utility
CLAutoOSTransaction::~CLAutoOSTransaction()
os_transaction releasing: (%p) %@
GeneralCLX
%@ %@
elevationAscended
elevationDescended
gradeType
verticalSpeed
rawGradeType
source
Uphill
Flat
Downhill
(unknown: %i)
Phone
Watch
estimatedVo2Max
variance
filteredVo2Max
eligibleForHealthKit
eligibleForCalorimetry
numWorkoutsContrToEstimate
estimatedHRResponseParam
estimatedHRRecoveryParam
LocationSourceState::Workout == fLocationSourceState
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Streaming/CLStreamingAwareLocationProviderLocalGPSStateMachine.mm
changeWorkoutState
com.apple.locationd.CLStreamingAwareLocationProviderLocalGPSStateMachine.changeWorkoutState
workoutForceGPSOn
newWorkoutState
localGPSRestricted
timeSinceWorkoutStarted
isInWorkout()
setWorkoutStateBasedOnMotionCompatibility
CLHealthAssessmentNotifierSilo
-[CLHealthAssessmentNotifierAdapter beginService]
CLHealthAssessmentNotifier starting up
__null != self.notifier
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/HealthAssessment/CLHealthAssessmentNotifier.mm
kMonitorKinesiasHasData
kMonitorKinesiasStart
kMonitorKinesiasExpiration
Loaded monitoring period start: %{public}f expiration date: %{public}f
kMonitorKinesiasLastProcessed
Resume sensor recording on service start
kMonitorKinesiasProcessingDelay
-[CLHealthAssessmentNotifierAdapter setupService]
fSensorRecorderQueryTimer.nextFireTime, %{public}f
-[CLHealthAssessmentNotifierAdapter teardownService]
Tearing down service
-[CLHealthAssessmentNotifierAdapter updateSensorRecorderSubscription]_block_invoke
Subscribing to Sensor Recorder: Accel Rate %{public}d Gyro Rate %{public}d
Unable to set sample rate for accel to %{public}d.
Unable to set sample rate for gyro to %{public}d.
fSensorRecorderSubscribeTimer.nextFireTime, %{public}f
-[CLHealthAssessmentNotifierAdapter updateSensorRecorderSubscription]
Stop renewing sensorRecorder subscription
-[CLHealthAssessmentNotifierAdapter processDataWithMaxDuration:endTime:]
Remaining duration to process = %{public}lf
Processed data up to max duration = %{public}lf, endTime = %{public}lf, total duration processed = %{public}lf
-[CLHealthAssessmentNotifierAdapter processNextIntervalWithRemainingDurationToProcess:endTime:updateCanContinue:]
DB not accessible, cannot process data
Updating start time to %{public}f based on last processed time
No processing to do, remainingDurationToProcess=%{public}f, endTime=%{public}f, updateStartTime=%{public}f
No valid period, marking up to %{public}f as processed
Requesting sensorRecorder data from %{public}f to %{public}f
Received accel data
Received gyro data
No new records from sensorRecorder, advancing startUpdateTime from %{public}f to %{public}f
No new records from sensorRecorder, updateStartTime is up to date (%{public}f)
New records read, accel = %{public}d, gyro = %{public}d, duration processed = %{public}lf
-[CLHealthAssessmentNotifierAdapter addMonitoringPeriodFrom:until:]
Updated monitoring period to %{public}f - %{public}f
-[CLHealthAssessmentNotifierAdapter stopMonitoring]
Stop monitoring, set period to %{public}f - %{public}f
-[CLHealthAssessmentNotifierAdapter aggregateRecords]
fAggregateRecordsTimer.nextFireTime, %{public}f
Closing down CLHealthAssessmentNotifier, past timeout period for stored data
CLHealthAssessmentNotifier
time
score
likelihood
strength
tremorScore
void CLHealthAssessmentNotifier::resultReady(NSDictionary *, CLHealthAssessment_Types::DataType)
Skipping partially empty period, saw %{public}.1f of %{public}.1f epochs in period
WARNING: DB not accessible, results for period from %{public}f to %{public}f may be lost.
Persisting result for period ending %{public}f
bool CLHealthAssessmentNotifier::recordHealthAssessmentData(CLHealthAssessment_Types::DataType, CFTimeInterval)
Add new monitoring period %{public}f - %{public}f
Extend existing monitoring period %{public}f - %{public}f
bool CLHealthAssessmentNotifier::aggregateRecords()
Aggregating records for fParkinsonsResultPersistence
bool CLHealthAssessmentNotifier::getNextValidPeriod(CFAbsoluteTime *, CFAbsoluteTime *, NSTimeInterval)
Checking from %{public}.2f
No valid monitoring periods seen
Selecting monitoring period: %{public}f - %{public}f
Found two consecutive onWrist events, skipping later one
Full on wrist period seen, %{public}0.f - %{public}0.f
No valid on wrist periods seen
Valid period returned, %{public}0.f - %{public}0.f
void CLHealthAssessmentNotifier::onWatchOrientationSettingsNotification(int, const CLWatchOrientationSettingsNotifier_Type::Notification &, const CLWatchOrientationSettingsNotifier_Type::NotificationData &)
Watch wrist state updated,onwrist,%{public}d
com.apple.locationd.Motion
com.apple.locationd.Core
CLHealthAssessmentNotifier::onWatchOrientationSettingsNotification
activity
void CLActivityAggregator<ParkinsonsResult>::setExpirationRule(CFTimeInterval) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
Programmer error, this expiration rule with time %{public}fis not valid.
void CLActivityRecorderDb<ParkinsonsResult>::addSuspectRecord(const T &) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
Maximum number of entries exceeded, throwing out oldest entry.
long CLActivityAggregator<ParkinsonsResult>::aggregateRecords() [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
Aggregating records start %f, count ~%d
Aggregating records stop %f, count ~%d
#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d
int CLActivityRecorderDb<ParkinsonsResult>::estimateRecordsNeeded(const CLAggregationRules &) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
#Warning No expiration rule was added so the number of records will be unbounded.
virtual void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
%{public}s; client %{public}d does not exist
_INTERSILO_UNIT_TEST
sizeof(Object_T) == podContainer.serialized.length
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Intersilo/CLCppContainer.h
operator()
virtual bool CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
%{public}s; notification %{public}s not found
virtual void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
%s; listing clients, num clients: %zu
FallMetMinuteTable
FallMetMinuteComputeTime
CLStreamedLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Streaming/CLStreamedLocationProvider.mm
-[CLStreamedLocationProviderAdapter beginService]
EnableMultiClientStreaming
Streamed location provider
CLLocationStreamingConnectionManager
registerForNotificationInternal
unregisterForNotificationInternal
void CLStreamedLocationProvider::logGPS(const CLLocationProvider_Type::NotificationData &)
Streamed,timestamp,%.3lf,timestampGps,%.3lf,odometer,%.3lf,deltaDist,%.3lf,deltaDistUnc,%.3lf,lat,%.8lf,lon,%.8lf,hunc,%.3lf,alt,%.3lf,vunc,%.3lf,speed,%.3lf,sunc,%.3lf,course,%.3lf,cunc,%.3lf
v16@?0@"NSDictionary"8
v32@?0@"NSDictionary"8@"NSDictionary"16@"NSError"24
targetDevice != nullptr
registerForStreamingClientNotifications
v24@?0@"NSDictionary"8@"NSDictionary"16
v16@?0@"NSError"8
fDisablementAssertionCount >= 0
takeDisablementAssertion
fDisablementAssertionCount > 0
releaseDisablementAssertion
fEmergencyEnablementAssertionCount >= 0
takeEmergencyEnablementAssertion
fEmergencyEnablementAssertionCount > 0
releaseEmergencyEnablementAssertion
-[CLStreamedLocationProviderAssertion takeAssertion]
-[CLStreamedLocationProviderAssertion releaseAssertion]
CLStreamedLocationProviderServerDiscoverer.workQueue
CLStreamedLocationProviderServerDiscoverer.requestQueue
v16@?0@"RPCompanionLinkDevice"8
Unknown Model
Unknown Name
CLStreamedLocationProvider
virtual bool CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]
virtual bool CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]
virtual void CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::removeClient(int) [Notification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]
virtual bool CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]
virtual void CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::listClients() [Notification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]
motion
natalieFeatures
-[ALMotionState writeTo:]
ALMotionState.m
self->_motion != nil
mounted
turn
isVehicular
isMoving
kTypeDrivingMounted
kTypeDrivingOrWalkingSlow
kTypeCyclingSeat
kTypeCyclingChassis
kTypeCyclingArm
kTypeCyclingTorso
kTypeDrivingSeat
kTypeDrivingArm
kTypeDrivingStowed
kTypeRunningLeg
kTypeRunningArm
kTypeWalkingLeg
kTypeWalkingArm
kTypeSemiStationaryPocket
kTypeSemiStationaryArm
kTurnStateUnknown
kTurnStateStatic
kTurnStateTurning
gsp10-ssl.apple.com
gs-loc.apple.com
iphone-ld.apple.com
1.2.840.113635.100.6.27.35
configuration.apple.com
cl5.apple.com
cl4.apple.com
cl3.apple.com
cl2.apple.com
ingest.apple-studies.com
ingest.stg.apple-studies.com
+[CLCertificatePinningHelper URLSession:didReceiveChallenge:completionHandler:]
#VerifyHost result,%{private}u
CLCertificatePinningHelperResult VerifyHost(NSString *, SecTrustRef)
#Warning No pinning rule for host %{private}s
#Warning Empty pinning rule for host %{private}s
Can't SecTrustEvaluate returned the error (%{private}ld) : %{private}@
recordId
startTime
pacebin
kvalue
kvalueTrack
endTime
distance
steps
session
speed
timestamp
regularEntry
floorsAscended
floorsDescended
void CLWorkoutEscalationMetrics::sendEventToCoreAnalytics()
Not sending escalation event to CoreAnalytics, no IHA permission
Not sending escalation event to CoreAnalytics, invalid escalation time recorded %d
com.apple.CoreMotion.FitnessEscalation
escType
workoutLocation
escTime
escToWorkout
firedTime
didWake
kAlarmTypeReminder
kAlarmTypeFinal
kAlarmTypeReset
kAlarmTypeActiveReminder
kAlarmTypeDrivingReminder
kAlarmTypeDeskReminder
kAlarmTypeTestSedentary
kAlarmTypeTestActive
void CLWorkoutAlertMetrics::sendEventToCoreAnalytics()
Not sending alert event to CoreAnalytics, no IHA permission
Not sending alert event to CoreAnalytics, invalid escalation time recorded %d
com.apple.CoreMotion.FitnessAlert
alertWorkoutType
acceptedWorkoutType
alertActiveTime
alertStatus
GyroOnly
6Axis
9Axis
9AxisWithNorthReference
BuildGYTT
3AxisDynamicGyro
6AxisThrottledGyro
CLDeviceMotionProperties<DeviceMotion=%@>
virtual CLMetsInfo CLNatalieDanceModel::computeMETS(const CLNatalieModelInput &)
Dance,metsWR,%f,metsHR,%f,truthMets,%f,userMets,%f,endTime,%f,danceWrMets,%f,motionIntensity,%d,hrDrift,%f,wrWeight,%f,metsSource,%d,accelZ,%f,vm,%f,hr,%f,hrIntensity,%d,rotationRate,%f
float CLNatalieDanceModel::computeWRRegression(const CLNatalieModelInput &) const
iz,%f,w,%f,cr,%f,weight,%f,height,%f,wr,%f
fVectorMagnitude
fIQRX
fIQRY
fIQRZ
fMachineFrequency
fEpochType
fStanding
kInvalidEpoch
K2560MsType
k10240MsType
void CLHrseTileAvailability::clearAvlCache()
HRSE,clear AVL status cache
bool CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)
#Warning,HRSE,isTileAvailableBasedOnAvlFile,availability file is not valid,fNeedToDownloadAvlFile,%{public}d
HRSE,isTileAvailableBasedOnAvlFile,Reading,%{public}s
#Error,HRSE,isTileAvailableBasedOnAvlFile,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d
#Warning,HRSE,isTileAvailableBasedOnAvlFile,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d
HRSE,isTileAvailableBasedOnAvlFile,input latitude, %{private}.3lf, below minimum acceptable latitude, %{private}d
HRSE,isTileAvailableBasedOnAvlFile,input latitude, %{private}.3lf, beyond maximum acceptable latitude, %{private}d
#Warning,HRSE,isTileAvailableBasedOnAvlFile,avl byte index,%{public}d,is larger than the data available in the availabilty file,fNeedToDownloadAvlFile,%{public}d
#Warning,HRSE,isTileAvailableBasedOnAvlFile,unable to get data byte,fNeedToDownloadAvlFile,%{public}d
HRSE,isTileAvailableBasedOnAvlFile,unexpected case,fNeedToDownloadAvlFile,%{public}d
HRSE,isTileAvailableBasedOnAvlFile,isTileAvailable,%{public}d,fNeedToDownloadAvlFile,%{public}d
bool CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()
HRSE,checkAvlFileValidityAndSetDownloadFlag,fNeedToDownloadAvlFile,%{public}d
#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file does not exist,fNeedToDownloadAvlFile,%{public}d
HRSE,checkAvlFileValidityAndSetDownloadFlag,Reading,%{public}s
#Error,HRSE,checkAvlFileValidityAndSetDownloadFlag,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d
#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d
#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file version does not match expected,fNeedToDownloadAvlFile,%{public}d
#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file has expired,fNeedToDownloadAvlFile,%{public}d
HRSE,checkAvlFileValidityAndSetDownloadFlag,reached end of function,fNeedToDownloadAvlFile,%{public}d
static bool CLHrseTileAvailability::readAvlHelper(FILE *, unsigned char *, CLHrseTileAvailability::CLHRSETileAvailability &, size_t &, size_t &)
#Error,HRSE,readAvlHelper,invalid availability file
#Error,HRSE,readAvlHelper,null buffer
#Error,HRSE,readAvlHelper,fseek returned non-zero
#Error,HRSE,readAvlHelper,did not synchronize to tile header_string
#Error,HRSE,readAvlHelper,invalid availability file - header string
#Error,HRSE,readAvlHelper,invalid availability file - invalid header string
#Error,HRSE,readAvlHelper,invalid availability file - version
#Error,HRSE,readAvlHelper,invalid availability file - headerLength
#Error,HRSE,readAvlHelper,invalid availability file - minLat
#Error,HRSE,readAvlHelper,invalid availability file - maxLat
#Error,HRSE,readAvlHelper,invalid availability file - binsize
#Error,HRSE,readAvlHelper,coarse avl file is not 0.05 deg by 0.05 deg,spacing unexpected,%{public}.1f,re-download needed
#Error,HRSE,readAvlHelper,invalid availability file - timestamp
#Error,HRSE,readAvlHelper,invalid availability file - expiration age
#Error,HRSE,readAvlHelper,invalid availability file - data size
#Error,HRSE,readAvlHelper,invalid availability file - crc
HRSE,readAvlHelper,vers,%{private}d,headerLen,%{private}d,minLat,%{private}d,maxLat,%{private}d,binsize,%{private}.7f,timestamp,%{private}.1f,expirationAge,%{private}d,dataSizeBytes,%{private}d,crc,%{private}d
void CLStandPlusMinuteEstimator::computeTimezoneOffset()
StandPlus,time zone change,clearing everything,old,%d,new,%d
void CLStandPlusMinuteEstimator::feed(const CLStandMinuteInputData &)
StandPlus,ignoring calorimetry input
StandPlus,maxReached,sedentaryTimer
void CLStandPlusMinuteEstimator::feedSedentaryTimerAlarm(const CLSedentaryAlarmData &)
void CLStandPlusMinuteEstimator::checkAndFireReset()
StandPlus,no hour earned
StandPlus,empty minute buffer,forcing minute from early stand hour,startTime,%{public}f,firedTime,%{public}f
StandPlus,firing stand hour immediately,firedTime,%f
void CLStandPlusMinuteEstimator::checkAndFireResetWithMinute(const CLStandPlusMinute &)
StandPlus,forcing reset from early stand minute,endTime,%{public}f
StandPlus,forcing minute from early stand hour,%{public}f,endTime,%{public}f
void CLStandPlusMinuteEstimator::checkAndFireReminder()
StandPlus,no reminder %d,hour earned %d
StandPlus,firing reminder immediately,firedTime,%f
void CLStandPlusMinuteEstimator::sendAlarm(const CLSedentaryAlarmData) const
StandPlus,enforced alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d
void CLStandPlusMinuteEstimator::addMinute(const CLStandPlusMinute &)
StandPlus,minuteAdded,startTime,%{public}f,endTime,%{public}f
StandPlus,maxReached,minutes,startTime,%{public}f
gender
heightM
weightKG
vo2max
hrmin
hrmax
hronset
kGenderMale
kGenderFemale
virtual void CLSensorFusionServiceSPU::start()
Fast path has been initialized,serviceRef,%{public}p
virtual void CLSensorFusionServiceSPU::stop()
Fast path closed,serviceRef,%{public}p
static bool CLSensorFusionServiceSPU::populateDeviceMotion(IOHIDEventRef, uint32_t, CLSensorFusionService::Sample &)
#Warning Device motion event ref invalid
Bad device motion report,type,%d,size,%lu
Unexpected device motion report type %{public}d, returning
type
confidence
mountedState
mountedConfidence
isStanding
tilt
exitState
estExitTime
isVehicleConnected
kTypeUnknown
kTypeFrozen
kTypeStatic
kTypeMoving
kTypeWalking
kTypeDriving
kTypeCycling
kTypeSemiStationary
kTypeRunning
kTypeMovingCoarse
kTypeInVehicleFrozen
kTypeInVehicleStatic
kTypeWalkingSlow
kTypeVehicularInHand
kTypeDrivingOther
kTypeCyclingLeg
kTypeStationaryCycling
kTypeCalisthenics
kTypeElliptical
kTypeCrossTraining
kTypeStairClimbing
kTypeRowing
kTypeYoga
kTypeDancing
kTypePushingWheelchair
kTypeIndoorRunning
kTypeGolfing
kTypeIndoorWalking
kTypeSwimming
kTypeSummer
kTypeOutdoorWheelchair
kTypeFunctionalStrength
kTypeCoolDown
kTypeCoreTraining
kTypeTaiChi
kTypePilates
kConfidenceLow
kConfidenceMedium
kConfidenceHigh
kNotMounted
kMounted
kNoDetection
kExitPreheat
kExitDetected
overrideAction
-[ALActivityOverrideMsg writeTo:]
ALActivityOverrideMsg.m
self->_activity != nil
kOverrideActionNone
kOverrideActionClear
kOverrideActionSet
activityOverrideMsg
bodyMetrics
motionState
stepCountData
sessionCatherineData
jacksonData
strideCalData
sedentaryAlarmData
allDayHeartRate
fitnessTracking
idsStatus
stairClimbingModel
rowingModel
exerciseMinute
elevation
coarseElevation
calorieData
natalieData
sedentaryAlarmDataDeprecated
strideCalDataDeprecated
calorieDataDeprecated
coarseElevationDeprecated
elevationDeprecated
workoutEventDeprecated
ActLogger
MsgEnableBitMask
CLActivityLoggerWriter::CLActivityLoggerWriter(NSString *)
MsgEnabledBitMask is %s
MsgRateMask
bool CLActivityLoggerWriter::open()
CLActivityLoggerWriter open log file filePath is %s, file is %p.
bool CLActivityLoggerWriter::logData(PBCodable *)
CLActivityLoggerWriter logData, prepare to log %d bytes
CLActivityLoggerWriter failed to log data: %{public}s
virtual CLFenceSubscription::~CLFenceSubscription()
ending metric session (LocationMonitorSession) for %{public}s
iB: ending metric session (BeaconMonitorSession) for %s
com.apple.locationd.region_proxy_service
com.apple.locationd.region_while_nearby
com.apple.location.region_polygonal
com.apple.location.region_aggressive
com.apple.location.region_low_power
com.apple.locationd.region_fence_handoff
com.apple.locationd.significant_region
kCLConnectionMessageMonitoringNearby
kCLConnectionMessagePolygonalVerticesCountKey
kCLConnectionMessagePolygonalVerticesKey
kCLConnectionMessageLowPowerFenceKey
void CLFenceSubscription::handleRequestRegionMonitoring(bool, const CLNameValuePair &)
Client %{public}s does not have the appopriate entitlement to act as an emergency service
#Warning Couldn't get value for key %{private}s, %{private}s/%{private}s
Client %{public}s does not have appropriate entitlement to act as a proxy service to %{public}s
#Warning #FenceHandoff %{public}s does not have the appopriate entitlement for fence handoff service
Client %{public}s does not have appropriate entitlement to use significant
Client %{public}s does not have appropriate entitlement to use low power fence
starting metric session (LocationMonitorSession) for %{public}s
Adding geographic fence [%{public}s]/%{public}s/%{private}s
Removing geographic fence [%{public}s]/%{public}s/%{private}s
Client %{public}s does not have appropriate entitlement to use polygonal regions
Client %{public}s does not have appropriate entitlement to monitor while nearby
Adding geographic polygonal fence [%{public}s]/%{public}s/%{private}s
Number of vertices received doesn't match stored, %{public}d, %{public}lu
Number of vertices received invalid, %{public}d, monitoring
Removing geographic polygonal fence [%{public}s]/%{public}s/%{private}s
ending metric session (BeaconMonitorSession) for %s
starting metric session (BeaconMonitorSession) for %s
kCLConnectionMessageProximityUUIDKey
kCLConnectionMessageMajorKey
kCLConnectionMessageMinorKey
kCLConnectionMessageRegionDefinitionKey
kCLConnectionMessageNotifyEntryStateOnDisplayKey
Invalid beacon region request [%{public}s]/%{public}s/%{public}s.
void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)
#Warning Couldn't get value for key %{private}s, %{public}s/%{private}s
kCLClientRegionSignificant
kCLClientRegionCircular
Fence: requesting, %{public}s for, [%s]/%s/%s
Fence: requesting, kCLClientRegionPolygonal for, [%s]/%s/%s
iB: requesting, kCLClientRegionBeacon for, [%s]/%s/%s
void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFenceManager_Type::NotificationData &)
Fence: kNotificationRegionStateRequest, failed to populateGeographicRegion, %s
kNotificationFenceState
kNotificationRegionStateRequest
Fence: received, %s, %s, state, %d, %s
Fence: unknown state, %{public}d
kCLConnectionMessageEventKey
Notifying client of fence %{private}s for %{public}s/%{private}s (location <%{private}+.8f,%{private}+.8f> acc %{public}.2f type %{public}d, sinceLast,%{private}.1f, fence,%{private}d,%{private}d,%{private}d,%{private}d,%{private}d, motion,%{private}d,%{private}d,%{private}d,%{private}d)
Fence: received, kNotificationFenceNotAuthorized
Fence: kNotificationFenceNotAuthorized, failed to populate fence
#Notice Fence: kNotificationFenceNotAuthorized, bundle not authorized for location, %{public}s, fence, %{public}s
Fence: received, kNotificationFenceFailure
#Warning Can't populate fence, %s
#Warning Couldn't populate alternate region
kCLConnectionMessageAlternateRegionKey
No alternate region available
kCLConnectionMessageRegionWatchdogSinceLast
void CLFenceSubscription::onBTLEFenceNotification(int, const CLBTLEFenceManager_Type::Notification &, const CLBTLEFenceManager_Type::NotificationData &)
@iB: Sending kCLConnectionMessageRegionMonitoringError for region,'%{public}s/%{private}s'.
@iB: Sending kCLConnectionMessageRegionMonitoringSetupCompleted for region,'%{public}s/%{private}s'.
@iB: Sending kCLConnectionMessageRegionState for region,'%{public}s/%{private}s'.
@iB: Sending kCLConnectionMessageRegionMonitoring for region,'%{public}s/%{private}s'.
Unsupported region transition state,%{public}d will not be reported.
CLFenceSubscription::onFenceNotification
CLFenceSubscription::onBTLEFenceNotification
{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}ddddddddiiidQiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}8@?0
VO2MaxPowerBudgetEstimatorQueryLookbackInterval
VO2MaxOutOfSessionEstimateHoldoffInterval
VO2MaxOutOfSessionEstimateTimeSinceLastWorkoutHoldOffInterval
VO2MaxPowerBudgetEstimatorBudgetAllowance
VO2MaxPowerBudgetEstimatorZeroBudgetRefreshInterval
SensitiveWalkingEscalationRulesLookbackTimeInSeconds
SensitiveWalkingEscalationRulesActiveTimeInSeconds
SensitiveWalkingEscalationRulesActiveSpeedInMPH
VO2MaxDeescalatorMaxEscalationTimeSeconds
VO2MaxDeescalatorMaxPercentBadSamples
VO2MaxDeescalatorDisableWRCheck
VO2MaxDeescalatorDisableHRCheck
VO2MaxDeescalatorDisableGPSCheck
VO2MaxDeescalatorDisableSessionStatsCheck
VO2MaxDeescalatorDisableIODisambiguationCheck
CLActivityLoggerAdapterSilo
activityLog.pb
CMActivityLog
CLActivityLogger::CLActivityLogger(id<CLIntersiloUniverse>)
CLActivityLogger being constructed.
NanoLifestyleEnableFitnessDataCollectionSettingDidChangeNotification
com.apple.managedconfiguration.defaultsdidchange
void CLActivityLogger::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)
CLActivityLogger, kNotificationActivityOverride,overrideAction,%d,activity{State,%d,Confidence,%d,MountedState,%d,MountedConfidence,%d,exitState,%d,estExitTime,%f,startTime,%f}
CLActivityLogger,log kNotificationActivityOverride:%s
#Warning CLActivityLogger, Unhandled notification %d
void CLActivityLogger::onFitnessDataCollectionSettingChangedNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
CLActivityLogger, dataCollection setting changed
CLActivityLogger::onFitnessDataCollectionSettingChangedNotification
CLActivityLogger::onMotionStateMediatorNotification
CLMotionDefaultsWrite<int>::CLMotionDefaultsWrite(const char *, const T &) [T = int]
motion default,%s,set,%d,value,%s
CLMotionDefaultsWrite<bool>::CLMotionDefaultsWrite(const char *, const T &) [T = bool]
CLMotionDefaultsWrite<double>::CLMotionDefaultsWrite(const char *, const T &) [T = double]
CLMotionDefaultsWrite<unsigned short>::CLMotionDefaultsWrite(const char *, const T &) [T = unsigned short]
CLMotionDefaultsWrite<float>::CLMotionDefaultsWrite(const char *, const T &) [T = float]
CLHarvestControllerSilo
+[CLHarvesterService isSupported]_block_invoke
Harvest is not supported in multiuser mode
Harvest is not supported in diagnostics mode
CLHarvesterService is supported, %{public}d
-[CLHarvesterService constructMonitors]
Service attempting to construct monitors without controller
_harvestController
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Harvester/Service/CLHarvesterService.mm
-[CLHarvesterService constructPolicies]
_monitorGps
-[CLHarvesterService constructSubHarvesters]
Service attempting to construct subharvesters without controller
Service attempting to construct subharvesters without gps monitor
Service attempting to construct subharvesters without policies
/var/root/Library/Caches/locationd/harvest/
persistHarvestData
com.apple.locationd.harvester
/var/root/Library/Caches/locationd/streaming_archives/
endpointSelector
locationClassifier
com.apple.locationd.harvest.contribute
com.apple.locationd.harvest.introspection
classifier
requestStore
-[CLHarvesterService listener:shouldAcceptNewConnection:]
received connection request
BOOL connectionHasEntitlement(NSXPCConnection *, NSString *)
connecting process isn't entitled, they shall not pass %{public}@
CLOdometerNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Odometer/CLOdometerNotifier.mm
-[CLOdometerNotifierAdapter beginService]
CLOdometerNotifier
WorkoutSignificantElevation
MotionCalibration
Cycling
Elevation
CyclingSpectator
CoarseElevation
SignificantElevation
ElevationSpectator
MotionOdometer
action
Registration
Unregistration
client
notification
notificationClientCount
notificationString
void CLOdometerNotifier::logClient(int, const CLOdometerNotifier_Type::Notification &, bool)
%{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}d, %{public}s, %{public}d, %{public}s, %{public}s
void CLOdometerNotifier::setUpDbUpdateFinishedHandler()_block_invoke
SignificantElevation,startTime,%{public}.3f,endTime,%{public}.3f,ascended,%{private}d,descended,%{private}d
v56@?0{CLSignificantElevation=i[16C]ddII}8
bool CLOdometerNotifier::checkAuthorization() const
Motion calibration system service is disabled.
LocationBundles/
bundle
Odometer
Pressure
void CLActivityAggregator<CLSignificantElevation>::setExpirationRule(CFTimeInterval) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual bool CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
long CLActivityAggregator<CLSignificantElevation>::aggregateRecords() [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLSignificantElevation>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::listClients() [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLMaxMetsEstimator::estimateMaxMets(CFAbsoluteTime, uint32_t)
Unable to retrieve the earliest calorie record. MaxMets will not be calculated.
persistMaxMets - startDayTimestamp: %{public}f, endTime: %{public}f, sevenDaysAgoToReferenceTime: %{public}f
persistMaxMets - Adjusted startDayTimestamp: %{public}f
Fetch of Calorimetry data failed. MaxMets will not be calculated. Error: %{public}u
Fetch of Met Minutes data returned no records. MaxMets will not be calculated.
persistMaxMets - metMinutes.size(): %{public}lu
persistMaxMets - Finished window. sumMets: %f, numRecords: %hu
persistMaxMets - meanMets: %f, maxMetsForDay: %f
CLDistributedSensingServiceSilo
CLVO2MaxCloudKitManagerSilo
CoreLocation
CloudKitForVO2Max
-[CLVO2MaxCloudKitManager beginService]
Not starting up CLVO2MaxCloudKitManager because it is not enabled
Starting up CLVO2MaxCloudKitManager
VO2MaxOutputZone
VO2MaxInputZone
VO2MaxCloudKitMaxSessionsForUpload
Max sessions for each CloudKit upload: %{public}d
VO2MaxCloudKitMinTimeBetweenForcedFetches
Min time between forced fetches from CloudKit if no metadata updates: %{public}f
com.apple.vo2max
VO2MaxCloudKitDailyStatsTimerInterval
VO2Max CloudKit daily stats time interval: %{public}f
-[CLVO2MaxCloudKitManager endService]
Shutting down CLVO2MaxCloudKitManager
-[CLVO2MaxCloudKitManager saveRetrocomputedOutputs]
Attempt to save retrocomputed outputs to CloudKit failed
VO2MaxCloudKitManagerNextActivityTime
-[CLVO2MaxCloudKitManager setUpSyncActivity]
%{public}s is too far in the future (%{public}.2f). Resetting!
com.apple.vo2max.CloudKitManager
%{public}s: Registering XPC Activity with nextPreprocessingTime=(%{public}.2f) and delay=(%{public}lld)
CLVO2MaxCloudKitManager
-[CLVO2MaxCloudKitManager setUpSyncActivity]_block_invoke
XPC_CHECK_IN: %{public}s: Overwriting previous delay (%{public}lld) with a new delay of %{public}lld seconds
XPC_CHECK_IN: %{public}s activity already scheduled with a delay of %{public}lld seconds
Failed to mark %{public}s activity as Continue. Current state is %{public}ld
-[CLVO2MaxCloudKitManager resetSyncActivity:withDelay:]
%{public}s: Resetting next activity time to: %{public}.1f
Failed to mark activity as Done. Current state is %{public}ld
-[CLVO2MaxCloudKitManager onSyncActivity:]
Invalid xpc activity.
Unexpected activity state: %ld
-[CLVO2MaxCloudKitManager handleSyncUpload:]
Checking for more unsynced local data to upload
No sync engine metadata available, so attempting to upload all local data
Sync engine metadata available, so attempting to upload unsynced local data
VO2MaxCloudKitLastForcedFetch
Forcing fetch from CloudKit. secondsSinceMetadataUpdate: %{public}f, secondsSinceLastForcedFetch: %{public}f, buffer: %{public}d
VO2MaxRetrocompute
-[CLVO2MaxCloudKitManager validateAccount]_block_invoke
Error determining account status: %{public}@
iCloud account is not available, status: %{public}ld
iCloud account for container %{public}@ doesn't support device to device encryption
Error getting user record: %{public}@
iCloud account has changed. Due to testing override, will not delete local VO2Max data but will still delete sync engine metadata.
iCloud account has changed. Deleting sync engine metadata and local VO2Max data.
Will attempt to initialize the sync engine if/after device has been unlocked.
v24@?0@"CKRecordID"8@"NSError"16
v24@?0@"CKAccountInfo"8@"NSError"16
VO2MaxCloudKitKeepLocalDataOnAccountChange
-[CLVO2MaxCloudKitManager setUserRecordIDName:]
Setting userRecordIDName to %{private}@
kCloudKitUserRecordId
-[CLVO2MaxCloudKitManager updateDeviceUnlocked:]
Device has been unlocked. Will now initialize the sync engine.
-[CLVO2MaxCloudKitManager getCKSyncEngineMetadata]
Loaded sync engine metadata, length = %{public}lu
-[CLVO2MaxCloudKitManager initializeSyncEngine]_block_invoke
Sync engine fetch complete for output records: %{public}@
Sync engine fetch complete for input records: %{public}@
-[CLVO2MaxCloudKitManager createVO2MaxOutputZone]
Creating VO2MaxOutputs zone
-[CLVO2MaxCloudKitManager createVO2MaxInputZone]
Creating VO2MaxInputs zone
-[CLVO2MaxCloudKitManager deleteZone:]
Deleting zone with zoneID = %{public}@
-[CLVO2MaxCloudKitManager addRecordIDsForSessionId:shouldUploadToOutputZone:shouldUploadToInputZone:]
Adding sessionId %{public}@ to RecordIDs for sync engine to save to VO2MaxOutputZone
Adding sessionId %{public}@ to RecordIDs for sync engine to save to VO2MaxInputZone
Sync engine uninitialized, so not adding sessionId %{public}@ to RecordIDs for sync engine to save
-[CLVO2MaxCloudKitManager bulkUploadRecordIDsShouldReupload:shouldUploadToOutputZone:shouldUploadToInputZone:shouldThrottle:]
Hit the max of %{public}d sessions per CloudKit upload. Will check for more data later.
Done adding sessions to sync
-[CLVO2MaxCloudKitManager createCKRecordForOutput:]
Failed to retrieve VO2MaxSessionAttributes for CKRecordID: %{public}@
Failed to decode output record from system fields data: %{public}@
VO2MaxOutput
Unable to get output due to device being locked, clearing the sync engine and will try again later.
Completed fetch of output proto; duration: %{public}f
sessionData
-[CLVO2MaxCloudKitManager updateOutputSystemFields:outputRecord:]
Failed to retrieve VO2MaxSessionAttributes for CKRecord with ID: %{public}@
Saving output metadata %s
-[CLVO2MaxCloudKitManager handleFetchedOutputRecord:]
Unable to persist fetched output due to device being locked, clearing the sync engine and will try again later.
Completed save of output proto; duration: %{public}f
-[CLVO2MaxCloudKitManager createCKRecordForInput:]
Failed to decode input record from system fields data: %{public}@
VO2MaxInput
Unable to get input due to device being locked, clearing the sync engine and will try again later.
Completed fetch of input proto; duration: %{public}f
-[CLVO2MaxCloudKitManager updateInputSystemFields:inputRecord:]
Saving input metadata %s
-[CLVO2MaxCloudKitManager handleFetchedInputRecord:]
Unable to persist fetched input due to device being locked, clearing the sync engine and will try again later.
Completed save of input proto; duration: %{public}f
-[CLVO2MaxCloudKitManager handleServerRecordChanged:]
CloudKit provided server record of unexpected type: %{public}@
Expected server record is missing from error after failed record save
-[CLVO2MaxCloudKitManager handleUnknownItem:]
CloudKit provided record of unexpected type: %{public}@
-[CLVO2MaxCloudKitManager handleZoneNotFound:]
Will not attempt to save unexpected zone: %{public}@
-[CLVO2MaxCloudKitManager handleZoneDeleted:]
Delete reported for unexpected zone: %{public}@
-[CLVO2MaxCloudKitManager handleZonePurge:]
Will not attempt to purge unexpected zone: %{public}@
-[CLVO2MaxCloudKitManager sendDailyStatsToPhone]
VO2MaxCloudKitDailyCounts,Not sending analytics, no IHA permission
Attempting to send ids message from watch to phone for VO2Max CloudKit daily stats
CLCompanionNotifier
-[CLVO2MaxCloudKitManager syncEngine:didSaveRecordZone:]
Successfully saved CKRecordZone %{public}@
-[CLVO2MaxCloudKitManager syncEngine:didDeleteRecordZoneWithID:]
Sync engine reports successful deletion of CKRecordZone with zoneID: %{public}@. Will recreate zone and reupload local data.
-[CLVO2MaxCloudKitManager syncEngine:failedToSaveRecordZone:error:]
Failed to save CKRecordZone: %{public}@, error = %{public}@
-[CLVO2MaxCloudKitManager syncEngine:failedToDeleteRecordZoneWithID:error:]
Sync engine reports failure to delete CKRecordZone: %{public}@, zoneID = %{public}@. This is unexpected, as we should not be deleting any zones
-[CLVO2MaxCloudKitManager syncEngine:zoneWithIDChanged:]
Sync engine reports that CKRecordZone with identifier %{public}@ changed
-[CLVO2MaxCloudKitManager syncEngine:zoneWithIDWasDeleted:]
Sync engine reports that CKRecordZone with identifier %{public}@ was deleted
-[CLVO2MaxCloudKitManager syncEngine:zoneWithIDWasPurged:]
Sync engine reports that CKRecordZone with identifier %{public}@ was purged
-[CLVO2MaxCloudKitManager syncEngine:recordToSaveForRecordID:]
Sync engine is asking for CKRecord with ID %{public}@
Returning output CKRecord: %@
Returning input CKRecord: %@
RecordID associated with unexpected zone: %{public}@
-[CLVO2MaxCloudKitManager syncEngine:didSaveRecord:]
Sync engine saved CKRecord with CKRecordID %{public}@, record = %{private}@
CloudKit reporting saved record of unexpected type: %{public}@
-[CLVO2MaxCloudKitManager syncEngine:failedToSaveRecord:error:]
Sync engine failed to save CKRecord: error domain = %{public}@, code = %{public}ld, error = %{public}@, record = %{private}@
-[CLVO2MaxCloudKitManager syncEngine:didDeleteRecordWithID:]
Sync engine deleted CKRecord with CKRecordID %{public}@
-[CLVO2MaxCloudKitManager syncEngine:failedToDeleteRecordWithID:error:]
Sync engine failed to delete CKRecord: error domain = %{public}@, code = %{public}ld, error = %{public}@, recordID = %{public}@
-[CLVO2MaxCloudKitManager syncEngine:shouldFetchChangesForZoneID:]
Sync engine asking if it should fetch changes for %{public}@
Answering sync engine shouldFetchChangesForZone = %{public}d for zone: %{public}@
-[CLVO2MaxCloudKitManager syncEngine:didFetchRecord:]
Sync engine fetched CKRecord with CKRecordID %{public}@, record = %{private}@
Fetched record of unexpected type: %{public}@
-[CLVO2MaxCloudKitManager syncEngine:recordWithIDWasDeleted:recordType:]
Sync engine unexpectedly fetched deletion of CKRecord with CKRecordID %{public}@ of type %{public}@
-[CLVO2MaxCloudKitManager syncEngine:didUpdateMetadata:]
Received updated metadata from sync engine, length = %{public}lu
VO2Max
com.apple.aps.locationd.vo2max.cloudkit
void CLNavModeEstimator::logStateChange(CLNavModeClassification, CLNavModeClassification) const
Changed from %s to %s:,
bool hasValidSpeedEstimate(const CLDaemonLocation &)
#Warning Latest speed is %lf but no information about speed uncertainty
!both
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Indoor/CLNavModeEstimator.mm
feedActivityState
Uninitialized
RecentlyVehicular
RecentlyPedestrian
std::string cl::to_string(CLNavModeClassification)
CLNavModeClassification
unknown enum 
virtual CLMetsInfo CLCalorieSwimmingModel::computeMETS(const CLNatalieModelInput &)
startTime,%f,endTime,%f,numberOfStrokes,%d,strokeType,%d,epochMets,%f,timestamp,%f,speed,%f,metSource,%d,strokeLength,%f,strokeRate,%f,entryStartTime,%f,entryEndTime,%f,distance,%f,scaledMets,%f,historicalTurnsPerSession,%f
tileType
tileX
tileY
isAllowOverCellular
secKey
ERROR
WARNING
STATUS
INFO
VERBOSE
Direct
SENSOR
FENCE
LocationServicesEnabledIn8.0
AuthorizationPromptMapDisplayEnabled
GestureServiceEnabled
LocationServicesAvailable
PrivateMode
com.apple.locationd/Prefs
com.apple.ManagedConfiguration.profileListChanged
com.apple.locationd.DumpDiagnostics
com.apple.locationd.notbackedup
com.apple.carrier
NSLocationUsageDescription
NSLocationAlwaysUsageDescription
NSLocationWhenInUseUsageDescription
NSLocationAlwaysAndWhenInUseUsageDescription
NSLocationTemporaryUsageDescriptionDictionary
NSLocationDefaultAccuracyReduced
NSLocationInterestZones
WKWatchOnly
WKRunsIndependentlyOfCompanionApp
gpsUtcLeapSeconds
CFRunLoopRef CLCommonGetRunLoop()
***no run loop available***
void CLCommonSetRunLoop(CFRunLoopRef)
Changing CLCommon's runloop after it was already established
#Warning Setting CLCommon's runloop after it was already established
CLCommonSetRunLoop, %p
int CLCommonCopyFile(const char *, const char *)
cannot open source file: %{public}s, errno %{public}d
cannot open target file: %{public}s, errno %{public}d
error reading source file: %{public}s
error writing target file: %{public}s
int CLCommonBzipFile(const char *, const char *)
cannot open compression stream: %{public}s, bzerror %{public}d
error writing target file: %{public}s, bzerror: %{public}d
error closing target file: %{public}s, bzerror: %{public}d
decompress:%@
bool CLCommonGzipDecompressFile(const char *, const char *)
CLCommonGzipDecompressFile, can't stat, %{public}s
CLCommonGzipDecompressFile, from, %s, to, %s, size, %llu, cTime, %.1lf, isOK, %d
CLCommonGzipDecompressFile, can't open, file_path_to, %{public}s, errno %{public}d
CLCommonGzipDecompressFile, can't open, file_path_from, %{public}s, errno, %{public}d
CLCommonGzipDecompressFile, error reading source file: %{public}s, errno, %{public}d, read, %{public}d
CLCommonGzipDecompressFile, can't write, %{public}s, errno, %{public}d, write, %{public}zu
CLCommonGzipDecompressFile, from, %s, to, %s, isOK, %d, fileSize, %llu, totalReadBytes, %u, totalWrittenBytes, %u, compression, %.4lf
compress:%@
%a, %d %b %Y %T %Z
int CLCommonGetTimeFromHttpHeaderAndRtt(CFDictionaryRef, const CFTimeInterval *, CFAbsoluteTime *)
http date string is converted to timestamp %.3f and adjusted to %.3f by %.3fs RTT (%.3fs diff from systime)
en_US
%.3f
Oct 20 2021 01:04:12
%b %d %Y %H:%M:%S
GpsNetworkCtrl
bool CLCommonIsGpsNetworkTestMode()
GPS_NETWORK: enabled %d found %d
Boolean CLCommonCompareLocationEqualityClientWithTimeCheck(const CLClientLocation *, const CLClientLocation *, bool)
CLCommonCompareLocationEqualityClient compared two coordinates that were identical other than their reference frames: (%lf, %lf, %d) (%lf, %lf, %d)
/System/Library/LocationBundles/LocationPromptUI.bundle
/System/Library/LocationBundles/LocationFenceSync.bundle
CLBundleKeyValueCache::instance()->isSystemService(bundlePath)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Utilities/CLCommon.mm
CLCommonIsBundleLocationdInternalSystemService
bool CLCommonGetFileTimestamps(const char *, CFAbsoluteTime *, CFAbsoluteTime *, CFAbsoluteTime *, off_t *)
#Warning CLCommonGetFileTimestamps, failed to stat file, %s, ret, %d
void CLCommonDeleteFileIfExists(const char *)
TILE: delete file, %s
TILE: stat, %s, ret, %d, mtime, %lu, ctime, %lu, size, %lld
TILE: unlink, %s, ret, %d
bool CLCommonSetFileProtectionClass(const char *, int)
CLCommonSetFileProtectionClass,sFilename==nullptr
CLCommonSetFileProtectionClass,open,errno,%{public}d
#Warning,CLCommonSetFileProtectionClass,%s,oldPc,%{public}d,newPc,%{public}d,ret,%{public}d,errno,%{public}d
CLCommonSetFileProtectionClass,%s,oldPc,%{public}d,newPc,%{public}d,ret,%{public}d
kCLClientRegistrationResultAllowedAlways
kCLClientRegistrationResultAllowedWhenInUse
kCLClientRegistrationResultFailedUserDenied
kCLClientRegistrationResultFailedBlocklisted
kCLClientRegistrationResultFailedUnavailable
kCLClientRegistrationResultRequiresAgent
kCLClientRegistrationResultMissing
kCLClientRegistrationResultAllowedAlwaysProvisionally
kCLClientAuthorizationStatusNotDetermined
kCLClientAuthorizationStatusRestricted
kCLClientAuthorizationStatusDenied
kCLClientAuthorizationStatusAuthorizedAlways
kCLClientAuthorizationStatusAuthorizedWhenInUse
__TEXT
Binary Images:
armv6
armv7
unknown
%16p - %lld %c%s %s <
> %s
ActiveConfig
SELECT * from ActiveConfig
CREATE UNIQUE INDEX IF NOT EXISTS ix_ActiveConfig_studyId ON ActiveConfig(studyId)
SELECT * FROM ActiveConfig ORDER BY priority DESC, startTime DESC LIMIT 1
DELETE FROM ActiveConfig
REPLACE INTO ActiveConfig (startTime, priority, configId, bundleIdentifier, studyId, parameterDictionary) VALUES (?, ?, ?, ?, ?, ?)
ALTER TABLE ActiveConfig ADD COLUMN 
UPDATE ActiveConfig SET 
priority
configId
studyId
parameterDictionary
CLActivityRecorderDb<ConfigSummary>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = ConfigSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<ConfigSummary>::setDatabaseAccessible() [T = ConfigSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<ConfigSummary>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = ConfigSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<ConfigSummary>::sanitizeAndStoreRecordUL(const T &, bool) [T = ConfigSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
AdvertisementBufferOnly
DefaultNotOptedInDisableAdvertisementBuffer
DefaultNotOptedInEnableOneAdvertisementBuffer
DefaultNotOptedInEnableTwoAdvertisementBuffer
DefaultOptedInEnableOneAdvertisementBuffer
DefaultOptedInEnableTwoAdvertisementBuffer
HawkeyeLowEnergyScan
AggressiveLowScan
AggressiveScan
BTFindingLowScan
BTFindingMediumScan
BTFindingHighScan
void CLNavigationSession::start()
HARVEST NAVIGATION SESSION: start navigation session
void CLNavigationSession::stop()
HARVEST NAVIGATION SESSION: stop navigation session, identifier, %s, duration, %.3f, automtiveActivityDuration, %.3f, isVehicleConnectedDuration, %.3f, gpsDuration, %.3f, proactiveGpsDuration, %.3f, mapsUsed, %d, batteryStates, %lu, beggining, level, %f, charging, %d, end, level, %f, charging, %d
void CLNavigationSession::startAutomotiveActivity()
HARVEST NAVIGATION SESSION: start automotive activity
void CLNavigationSession::stopAutomotiveActivity()
HARVEST NAVIGATION SESSION: stop automotive activity
void CLNavigationSession::startVehicleConnected()
HARVEST NAVIGATION SESSION: start vehicle connected
void CLNavigationSession::stopVehicleConnected()
HARVEST NAVIGATION SESSION: stop vehicle connected
static bool CLNameValuePair::encodeBase64(const void *, unsigned long, std::string &)
processed %p %d to (%s)
CLNameValuePair::CLNameValuePair()
could not create new mutable dictionary
CLNameValuePair::CLNameValuePair(CFDictionaryRef)
CLNameValuePair::CLNameValuePair(const CLNameValuePair &)
CLNameValuePair &CLNameValuePair::operator=(const CLNameValuePair &)
Memory
bool CLNameValuePair::writeDataToFile(const char *, CFDataRef, CLNameValuePair::CLNVPDataProtection) const
Could not create NSURL for file: %{public}s
Could not write data to disk %{public}s, %{public}s
virtual bool CLNameValuePair::saveToFile(const char *) const
Could not serialize data for file %{public}s
virtual void CLNameValuePair::clearInternal(const CFStringRef, int)
key %{public}s does not have element %{public}d in array of size %{public}ld
key %{public}s does not have element %{public}d in non-array type %{public}lu
virtual bool CLNameValuePair::get(CFStringRef, bool &, int) const
Unsupported type at %@:%@ (domain:key)
virtual bool CLNameValuePair::get(CFStringRef, uint16_t &, int) const
virtual bool CLNameValuePair::get(CFStringRef, short &, int) const
virtual bool CLNameValuePair::get(CFStringRef, uint32_t &, int) const
virtual bool CLNameValuePair::get(CFStringRef, int64_t &, int) const
virtual bool CLNameValuePair::get(CFStringRef, int &, int) const
virtual bool CLNameValuePair::get(CFStringRef, long &, int) const
virtual bool CLNameValuePair::get(CFStringRef, double &, int) const
virtual bool CLNameValuePair::get(CFStringRef, CLNameValuePair &, int) const
virtual bool CLNameValuePair::get(CFStringRef, std::string &, int) const
virtual bool CLNameValuePair::get(CFStringRef, CFArrayRef &) const
type IDs do not match for key %{public}s - %{public}lu vs %{public}lu
virtual bool CLNameValuePair::get(CFStringRef, CFDataRef &, int) const
virtual bool CLNameValuePair::get(CFStringRef, CFStringRef &, int) const
virtual bool CLNameValuePair::get(CFStringRef, const char *&, unsigned int &, int) const
virtual bool CLNameValuePair::copyInternal(CFStringRef, CFTypeRef &, int) const
specified index is out of range for key %{public}s (%{public}d of %{public}ld)
specified index %{public}d not applicable to type %{public}lu for key %{public}s
virtual bool CLNameValuePair::set(CFStringRef, const bool &)
could not create cf type for key %{public}s
virtual bool CLNameValuePair::set(CFStringRef, const uint16_t &)
virtual bool CLNameValuePair::set(CFStringRef, const short &)
virtual bool CLNameValuePair::set(CFStringRef, const uint32_t &)
virtual bool CLNameValuePair::set(CFStringRef, const int64_t &)
virtual bool CLNameValuePair::set(CFStringRef, const int &)
virtual bool CLNameValuePair::set(CFStringRef, const long &)
virtual bool CLNameValuePair::set(CFStringRef, const double &)
virtual bool CLNameValuePair::set(CFStringRef, const char *)
virtual bool CLNameValuePair::set(CFStringRef, const CLNameValuePair &)
virtual bool CLNameValuePair::insert(CFStringRef, const bool &)
virtual bool CLNameValuePair::insert(CFStringRef, const uint16_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const short &)
virtual bool CLNameValuePair::insert(CFStringRef, const uint32_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const int64_t &)
virtual bool CLNameValuePair::insert(CFStringRef, const int &)
virtual bool CLNameValuePair::insert(CFStringRef, const long &)
virtual bool CLNameValuePair::insert(CFStringRef, const double &)
virtual bool CLNameValuePair::insert(CFStringRef, const char *)
virtual bool CLNameValuePair::insert(CFStringRef, const CLNameValuePair &)
virtual bool CLNameValuePair::serializeBinary(CFDataRef *) const
could not create write stream
could not open write stream
could not write data, error code, %{public}ld, error domain, %{public}s
unknown error
virtual bool CLNameValuePair::deserialize(const CFDataRef)
could not create intermediate property list - %{public}ld (%{public}s)
virtual void CLNameValuePair::print() const
<empty>
static void CLNameValuePair::printKeyValue(const void *, const void *, void *)
%s = <dictionary (%ld entries)>:
%s = %s
%s = %0.6f
%s = %d
%s = <unhandled value type %lu>
type ID does not match - %lu vs %lu
%s = <dictionary (%ld entries)>:
%s = %s
%s = %0.6f
%s = %d
%s = <unhandled value type %lu>
%s[%d]
static bool CLNameValuePair::fromCfType(const CFTypeRef, short &)
could not get value
static bool CLNameValuePair::fromCfType(const CFTypeRef, int64_t &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, int &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, long &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, double &)
type IDs do not match - %{public}lu vs %{public}lu
static bool CLNameValuePair::fromCfType(const CFTypeRef, std::string &)
could not convert to C string
can't convert %{public}u data bytes
#Warning type IDs do not match - %{public}lu
static bool CLNameValuePair::fromCfType(const CFTypeRef, CFStringRef &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, const char *&, unsigned int &)
static bool CLNameValuePair::fromCfType(const CFTypeRef, CLNameValuePair &)
CLMonitorGpsExternal::onGpsNotification
CLMonitorGpsExternal::onAccessoryNotification
v32@?0@"NSURL"8@"NSURLResponse"16@"NSError"24
CLHttpRequest
CLDownloadOSTransaction
https
http
void CLMicroLocationPowerLog::logMetrics(std::optional<ObserverPowerLogFunction>) const
PowerLog is not enabled so not writing microlocation metrics
FootprintsMetricsStart
FootprintsMetricsEnd
FootprintsNumChannelsAt50msDwell
FootprintsNumChannelsAt110msDwell
FootprintsTotalDurationActiveScansSecs
FootprintsTotalDurationPassiveScansSecs
FootprintsActiveScanDutyCycle
FootprintsPassiveScanDutyCycle
FootprintsTotalDurationWPHomeKitSecs
FootprintsTotalDurationWPAirplaySoloSecs
Footprints
Wrote microlocation metrics to power log: %{private}s
MicroLocationsPowerLogEnabled
MicroLocationsLocalizingWifiDutyCyclePercentage
MicroLocationsRecordingWifiDutyCyclePercentage
+[CLFallHealthKitManager recordFallEventInHealthKit:]
HKHealthStore, health data not available
event has not response
event should not be logged in HK with response %i
_HKPrivateFallActionRequested
+[CLFallHealthKitManager recordFallEventInHealthKit:]_block_invoke
HKHealthStore, saveObjects failed on, %@
Fall event successfully pushed to HKHealthStore
CLSedentaryTimerNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/SedentaryTimer/CLSedentaryTimerNotifier.mm
-[CLSedentaryTimerNotifierAdapter beginService]
-[CLSedentaryTimerNotifierAdapter syncgetStartTimerForClient:andOptions:]
[SedentaryTimerTriage] SedentaryAlarm, syncgetStartTimerForClient starting timer for client,%{public}@!
-[CLSedentaryTimerNotifierAdapter syncgetStopTimerForClient:]
[SedentaryTimerTriage] SedentaryAlarm, syncgetStopTimerForClient stopping timer for client,%{public}@!
-[CLSedentaryTimerNotifierAdapter syncgetSedentaryAlarmData:since:]
[SedentaryTimerTriage] SedentaryAlarm, syncgetSedentaryAlarmData with start time,%{public}f!
CLSedentaryTimerNotifier
v32@?0d8d16i24B28
v16@?0@"NSNotification"8
SedentaryTimerAggregateInterval
CLActivityLogger
v40@?0{CLSedentaryAlarmData=ddiBd}8
com.apple.locationd.sedentarytimer
CMError CLSedentaryTimerNotifier::startTimer(const std::string &, NSDictionary *)
SedentaryAlarm,Error starting,client,%{public}s,fitness tracking,%{public}d
SedentaryAlarm,Error starting,client,%{public}s,armed,%{public}d
SedentaryAlarm,startDate sent that doesn't align with the wall hour,%f,minuteOffset,%ld,secondOffset,%ld
SedentaryAlarm,START,client,%s,offset,%d,period,%d,reminder,%d,autoReschedule,%d,startDate,%f
CMError CLSedentaryTimerNotifier::stopTimer(const std::string &)
SedentaryAlarm,STOP
com.apple.locationd
void CLSedentaryTimerNotifier::onSedentaryAlarm(const CFAbsoluteTime, const CFAbsoluteTime, const CLSedentaryAlarmType, const bool)
SedentaryAlarm,STOP,fitness tracking,%d
SedentaryAlarm,InVehicleReminder,now,%.3f,motionStateTime,%.3f
StandPlus,aop alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d
void CLSedentaryTimerNotifier::onFitnessTrackingNotification(int, const CLFitnessTrackingNotifier_Type::Notification &, const CLFitnessTrackingNotifier_Type::NotificationData &)
Activity mode from %{public}d to %{public}d
StandPlus, running stand minute estimator
StandPlus, stopping stand minute estimator
virtual void CLSedentaryTimerNotifier::onStandPlusBucket(const CLStandPlusBucket)
StandPlus,bucketStart,%{public}f,bucketEnd,%{public}f,count,%{public}d
virtual void CLSedentaryTimerNotifier::onStandPlusBucket(const CLStandPlusBucket)_block_invoke
HKHealthStore, StandPlus, saveObjects failed on, %{error}@, for startBucket, %{public}f
StandPlus successfully pushed to HKHealthStore, startBucket, %{public}f
v20@?0B8@"NSError"12
virtual void CLSedentaryTimerNotifier::onStoreSedentaryAlarm(CLSedentaryAlarmData)
StandPlus,warning,time went backward,alreadyLogged,%{public}f,new,%{public}f
StandPlus,warning,attempting to log bad alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d,count,%{public}d,countReset,%{public}d
SedentaryTimerActiveWindow
SedentaryTimerActiveThreshold
SedentaryTimerStepCountThreshold
SedentaryTimerPushCountThreshold
CLSedentaryTimerNotifier::onFitnessTrackingNotification
CLSedentaryTimerNotifier::onMotionStateObserverNotification
CLSedentaryTimerNotifier::onNatalimetryNotification
void CLActivityAggregator<CLSedentaryAlarmData>::setExpirationRule(CFTimeInterval) [T = CLSedentaryAlarmData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<CLSedentaryAlarmData>::aggregateRecords() [T = CLSedentaryAlarmData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLSedentaryAlarmData>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLSedentaryAlarmData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLActivityRecorderDb<CLSedentaryAlarmData>::addSuspectRecord(const T &) [T = CLSedentaryAlarmData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
Gender
Height
Weight
Vo2max
MetMinPercentile
MetMinCount
Workout
HKWorkout
BackgroundAWDLoggingEnabled
FallRandomBucket
virtual void CLMotionStateObserverCompanion::receiveMotionStateUpdate(NSData *)
MotionStateObserver, Invalid data received.
void CLMotionStateObserverCompanion::startSessionTimer()_block_invoke
MotionStateObserver, Timing out session since we have not heard a response in %f seconds.
void CLMotionStateObserverCompanion::startSessionTimer()
MotionStateObserver, Starting update timer.
void CLMotionStateObserverCompanion::stopSessionAndTimer()
void CLMotionStateObserverCompanion::trackVehicularConfidenceStateMachine()
MotionStateObserver,VehicularTracking,STOP
MotionStateObserver,VehicularTracking,MotionState,startTime,%.3f,activityType,%d,vehicularConfidence,%d
CMActivityAlarm *CLMotionStateObserverCompanion::createActivityAlarm(const CMActivityAlarmTrigger, const float)
MotionStateObserver,VehicularTracking,setActivityAlarm,%d,duration,%0.3f
void CLMotionStateObserverCompanion::onActivityAlarm(CMActivityAlarm *)
MotionStateObserver,VehicularTracking,onActivityAlarm,%d
nPairs
lsest
sumest
fPal
securityKey
generationTimeSecs
expirationAgeSecs
DEPRECATED_fingerprints
fingerprints
marketId
-[CLKeychainItemWrapper initWithIdentifier:keyType:]
nil identifier given to CLKeychainItemWrapper
-[CLKeychainItemWrapper dictionaryToSecItemFormat:]
nil dictionary passed for converstion
Conversion of dictionary without kSecValueData key requested.
-[CLKeychainItemWrapper secItemFormatToDictionary:]
nil dictionary passed for retrieving keychain item
Expected keychain item not found.
NetworkLocationProvider
CLNetworkLocationProvider::onStatusNotification
CLNetworkLocationProvider::onManagerNotification
CLNetworkLocationProvider::onCompanionNotification
CLNetworkLocationProvider::onDataProtectionNotification
CLNetworkLocationProvider::onTelephonyNotification
CL::Wifi1::Policies::NotifyClients::Output CL::Wifi1::Policies::NotifyClients::HandleEvent::operator()(const Events::Client::UpdateTimer &) const
@WifiFlow, reissue, time, %{public}.1f, last, %{public}.1f
@WifiFlow, inter-locreq state update per update timer event, staging, %{public}s, current, %{public}s
@WifiFlow, reissue, invalid location, #CloneMe
CL::Wifi1::Policies::NotifyClients::Output CL::Wifi1::Policies::NotifyClients::HandleEvent::operator()(const Events::Wifi::Wsb &) const
WsbCalc, filter, live, %{public}lu, groups, %{public}lu
CL::Wifi1::Policies::NotifyClients::Output CL::Wifi1::Policies::NotifyClients::HandleEvent::operator()(const Events::ReprocessWifiScanBuffer &) const
WsbCalc, filter, reproc, %{public}lu, groups, %{public}lu
CL::Wifi1::Policies::NotifyClients::Output CL::Wifi1::Policies::NotifyClients::HandleEvent::operator()(const Events::Network::AlsError &) const
@WifiFlow, alsreply, aps, error, tag, %{public}d
static CLDaemonLocationPrivate CL::Wifi1::Policies::NotifyClients::HandleEvent::populateLocationPrivate(const CLDaemonLocation, const double &)
Wifi,undulation,%{public}lf, model, %{public}d
static CL::Wifi1::Policies::NotifyClients::Output CL::Wifi1::Policies::NotifyClients::HandleEvent::processLocationComputation(const CL::Wifi1::Policies::NotifyClients::Input &, bool)
@WifiFlow, inter-locreq state update, staging, %{public}s, current, %{public}s
wifiLocType
apsInSolution
error == 0
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/CSI/CLMachThreadSupport.mm
lock
<unnamed>
virtual void BasicMutex::lock()
#Warning TIMEOUT: Waited %f seconds to aquire lock '%s' (%p)
info->fCount >= 0
(info->fCount == 0) || (info->fOwner == curThread)
(info->fCount > 0) || (info->fOwner == __null)
virtual void BasicMutex::unlock()
#Warning TIMEOUT: Held lock '%s' (%p) for %f seconds
info->fCount > 0
unlock
void CMTremorDetection::checkForGap(CFAbsoluteTime)
Resetting detector, %.1f seconds without a gyro sample
kCLLocationStreamingMessageTypeRequestLocation
kCLLocationStreamingMessageGranularityKey
kCLLocationStreamingMessageIncludeMotionKey
kCLLocationStreamingMessageInFitnessSessionKey
kCLLocationStreamingMessageActivityTypeAirborneKey
kCLLocationStreamingMessageEmergencyEnablementKey
kCLLocationStreamingMessageMapMatching
com.apple.locationd.rapport.event
kCLLocationStreamingMessageTypeLocation
kCLLocationStreamingMessageLocationKey
kCLLocationStreamingMessageLocationPrivateKey
kCLLocationStreamingMessageLocationInternalKey
com.apple.locationd.rapport.availability-interest
com.apple.locationd.rapport.stream-request
com.apple.locationd.rapport.stream-event
kCLLocationSTreamingMessageRapportDeviceIDKey
kCLLocationStreamingMessageRapportLocationStreamingActionKey
kCLLocationStreamingMessageRapportHasGPSKey
kCLLocationStreamingMessageRapportIsPhoneKey
kCLLocationStreamingMessageRapportIsPadKey
kCLLocationStreamingMessageTypeAliveAgain
kCLLocationStreamingMessageTypeSetMotionAlarm
kCLLocationStreamingMessageMotionAlarmStateKey
kCLLocationStreamingMessageTypeMotionAlarmUpdate
kCLLocationStreamingMessageInMotionKey
CLLocationStreamingConnectionManagerSilo
BTPipe
v16@?0@"<CLLocationStreamingConnectionManagerClientProtocol>"8
kCLLocationStreamingMessageKeyPayload
kCLLocationStreamingMessageKeyType
kCLLocationStreamingMessageKeyVersion
com.apple.private.alloy.location.stream
v24@?0@"IDSService"8@"NSError"16
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Streaming/CLLocationStreamingConnectionManager.mm
-[CLLocationStreamingConnectionManager service:account:identifier:didSendWithSuccess:error:]
virtual bool CLPreferences::serialize(CFDataRef *) const
***not supported***
virtual bool CLPreferences::serializeBinary(CFDataRef *) const
virtual bool CLPreferences::deserialize(const CFDataRef)
virtual void CLPreferences::print() const
<empty>
virtual void CLPreferences::merge(const CLPreferences &, bool)
virtual bool CLPreferences::loadFromFile(const char *)
virtual bool CLPreferences::saveToFile(const char *) const
virtual bool CLPreferences::saveToBinaryFile(const char *) const
virtual void CLPreferences::setInternal(const CFStringRef, const CFTypeRef)
Attempt to set key %{public}s for read-only preferences %{public}s/%{public}s!
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLPreferences.mm
containsInternal
OtherPref
-[CLBarometerCalibrationSourceCompanion enableSource]
Enabling companion data source
Altimeter
static void CLDaemonCache::shutdownInstance()
could not store cached data 
CLDaemonCache
ClearLocationCache
CLDaemonCache::CLDaemonCache(id<CLIntersiloUniverse>)
#Warning clearing location cache
CLVO2MaxServiceSilo
-[CLVO2MaxService beginService]
Not starting up CLVO2MaxService because it is not enabled
Starting up CLVO2MaxService
-[CLVO2MaxService endService]
Shutting down CLVO2MaxService
-[CLVO2MaxService sendRetroComputeAnalytics]
Retro-compute, not sending analytics, no IHA permission
com.apple.VO2MaxRetroCompute
age_bin
biologicalSex
currentAlgVersion
reasonIneligible
status
estimateAverageDelta
estimateVariabilityDelta
highPercentileEstimateDelta
meanPercentileDelta
newEstimateN
numUpdatedEstimatesTotal
removeEstimateN
Succesfully accessed history table, sent Core Analytics event
VO2MaxRetrocomputeNextPreprocessingTime
-[CLVO2MaxService scheduleRetrocomputePreprocessing]
com.apple.locationd.VO2Max.RetrocomputePreprocessing
-[CLVO2MaxService scheduleRetrocomputePreprocessing]_block_invoke
XPC_CHECK_IN: VO2MaxRetrocomputePreProcessing already scheduled with a delay of %{public}lld seconds
Failed to mark VO2MaxRetrocomputePreProcessing activity as Continue. Current state is %{public}ld
-[CLVO2MaxService resetRetrocomputePreProcessingActivity:withDelay:]
-[CLVO2MaxService onRetrocomputePreprocessingActivity:]
Preparing to execute VO2MaxRetrocomputePreProcessing
Unexpected VO2MaxRetrocomputePreProcessing activity state: %ld
-[CLVO2MaxService queryVO2MaxRetrocomputeStatusWithReply:]
Error querying VO2MaxRetrocomputeHistory: %u
Queried VO2MaxRetrocomputeHistory for algVersion = %d and received %s
-[CLVO2MaxService executeRetrocomputePreprocessing:]
Will not attempt retrocompute pre-processing, status: %{public}d, algVersion: %{public}d
VO2MaxRetrocomputeHistory query failed due to device lock
Will not attempt retrocompute pre-processing, no age set
-[CLVO2MaxService executeRetrocomputePreprocessing:]_block_invoke
HealthKit VO2Max query failed due to device lock
HealthKit VO2Max query encountered error,%{public}ld
ml/(kg*min)
Retrieved sample... VO2Max: %{private}f, startTime: %{private}@, endTime: %{private}@, metadata: %{private}@, sourceRevision: %{private}@
Will not attempt to retrocompute sample due to missing metadata
Attempting to defer VO2MaxRetrocomputePreProcessing activity
Failed to mark VO2MaxRetrocomputePreProcessing activity as deferred. Current state is %{public}ld
-[CLVO2MaxService markXpcActivityDone:]
Failed to mark activity as done. Current state is %{public}ld
-[CLVO2MaxService retrocomputeForSamples:withRetrocomputeHistory:]
There are no VO2Max HealthKit samples to retrocompute
Retrocompute encountered HealthKit sample with no SessionAttributes for sessionId %{private}@
-[CLVO2MaxService getIndexInHealthKitSamples:forSessionAttributes:withStartIndex:]
CLVO2MaxService::getIndexInHealthKitSamples - sessionId: %{private}@, startIndex: %{public}d, index: %{public}zu
CLVO2MaxService::getIndexInHealthKitSamples - index not found for sessionId: %{private}@, startIndex: %{public}d
-[CLVO2MaxService retrocomputeSession:withHealthKitSample:withRetrocomputeHistory:]
Query for historical summaries failed due to device lock
Query for staged summaries failed due to device lock
Query for pre-existing summaries for current session failed due to device lock
Stopping pre-processing due to age unexpectedly no longer being set after the initial check. Will retry later.
VO2MaxRetrocomputeEstimateTestAddend
For testing purposes, incrementing VO2Max estimate by %{public}f units
Retrocompute result for sessionId %{private}@: old estimate: %{private}f, new estimate: %{private}f
-[CLVO2MaxService updateRetrocomputeHistory:withResult:]
Updating VO2MaxRetrocomputeHistory: startTime,%{private}f,algVersion,%{private}d,status,%{private}d,lastSessionTimestamp,%{private}f,lastSessionId,%{private}@,firstSampleDate,%{private}f,lastSampleDate,%{private}f,lastSampleDatePrevAlg,%{private}f,meanDelta,%{private}f,meanPercentileDelta,%{private}f,numUpdatedEstimates,%{private}d,numNewEstimates,%{private}d,numLostEstimates,%{private}d
-[CLVO2MaxService updateRetrocomputeHistoryPostProcessing:]
Unable to query for staging output due to device lock
VO2MaxRetrocomputeMinPrevAlgSampleInterval
VO2MaxRetrocomputeMinEstimatesUpdatedRatio
VO2MaxRetrocomputeMinMeanDelta
VO2MaxRetrocomputeHistory data checks: prevAlgSampleInterval,%{private}f,minPrevAlgSampleInterval,%{private}f,estimatesUpdatedRatio,%{private}f,minEstimatesUpdatedRatio,%{private}f,meanDelta,%{private}f,minMeanDelta,%{private}f,failedDataCheck,%{private}d,oldRetrocomputeStatus,%{public}d,newRetrocomputeStatus,%{public}d
-[CLVO2MaxService triggerRetrocompute:]
Retrocompute triggered
Unable to query for staging output: %d
No staging data found
-[CLVO2MaxService saveStagingOutputToHealthKit:activity:]
Adding retrocomputed sample to HKHealthStore: %{public}@
-[CLVO2MaxService saveStagingOutputToHealthKit:activity:]_block_invoke
Retrocomputed VO2Max sample failed to push to HKHealthStore, %{public}@
Retrocomputed VO2Max sample successfully pushed to HKHealthStore
-[CLVO2MaxService onRetrocomputeHealthKitSampleSavedWithStartTime:activity:]
Will retry retrocompute trigger due to unexpected state. fPendingHealthKitWrites count: %{public}lu, expected sample startTime: %{private}f, actual sample startTime: %{private}f
Failed to update retrocompute history record with lastTimestampToHealthKit (%{private}f). Will attempt to proceed with remaining HealthKit writes.
-[CLVO2MaxService promoteStagingData:]
Could not promote staging data: %d
com.apple.locationd.VO2Max.RetrocomputeRetryTrigger
-[CLVO2MaxService retryTriggerRetrocompute]
Setting up %{public}s activity
-[CLVO2MaxService retryTriggerRetrocompute]_block_invoke
-[CLVO2MaxService onRetryTriggerRetrocompute:]
-[CLVO2MaxService handleRetryTriggerRetrocompute:]
Retrying retrocompute trigger already succeeded, cancelling activity
Unable to query for retrocompute history due to device lock
Will not attempt to retry retrocompute trigger, status: %{public}d, algVersion: %{public}d
Giving up attempting to retry retrocompute trigger
com.apple.locationd.VO2Max.RetrocomputeRetryHealthKitDelete
Retrying retrocompute trigger
-[CLVO2MaxService deleteHealthKitSamples:]
Attempting to delete samples without estimates in HKHealthStore
Unable to fetch sessions without estimates
No sessions to delete from HKHealthStore
-[CLVO2MaxService retryHealthKitDeleteSamples]
Setting up activity to attempt deleting sessions without estimates from HKHealthStore
-[CLVO2MaxService retryHealthKitDeleteSamples]_block_invoke
Failed to mark activity as Continue. Current state is %{public}ld
-[CLVO2MaxService onRetryHealthKitDeleteSamples:]
-[CLVO2MaxService handleRetryHealthKitDeleteSamples:]
HealthKit samples without an estimate have been deleted, cancelling activity
Attempting to retry deleting HealthKit samples without an estimate
Giving up attempting to delete HealthKit samples without an estimate
-[CLVO2MaxService deleteSessionsFromHealthKit:withRetry:]
Deleting session %@ from HKHealthStore
-[CLVO2MaxService deleteSessionsFromHealthKit:withRetry:]_block_invoke
Delete HK Sessions,success,%d,deletedObjectCount,%lu,error,%@
Successfully deleted samples from HKHealthStore
v28@?0B8Q12@"NSError"20
No sessions found without estimates to delete from HKHealthStore
-[CLVO2MaxService onUserInfoUpdate:data:]
CLVO2MaxService: Received user info update. IsAgeSet,%{public}d,Age,%{private}f,BiologicalSex,%{private}d,IsHeightSet,%{public}d,Height,%{private}f,IsWeightSet,%{public}d,Weight,%{private}f
CLSensorFusionService::CLSensorFusionService(int)
Starting device motion service %{public}d
DeviceMotionUseThrottledInterval
DeviceMotionAccelerometerUpdateInterval
DeviceMotionGyroUpdateInterval
DeviceMotionCompassUpdateInterval
GyroUpdateInterval,%{public}.4f,AccelerometerUpdateInterval,%{public}.4f
DumpGyroCalibrationDatabaseOnDeviceMotionStart
CLSensorFusionService::CLSensorFusionService(int)_block_invoke
Dumped gyro cal database with id %@
virtual CLSensorFusionService::~CLSensorFusionService()
Stopping device motion service %{public}#x
void CLSensorFusionService::updateSensorStatus(const CLSensorFusionService::SensorStatus &)
Set device motion sensor status %{public}ld
void CLSensorFusionService::logSample(const CLSensorFusionService::Sample *)
[CLSensorFusionService] q.x,%10.10f,q.y,%10.10f,q.z,%10.10f,q.w,%10.10f,userAccel.x,%10.10f,userAccel.y,%10.10f,userAccel.z,%10.10f,rotationRate.x,%10.10f,rotationRate.y,%10.10f,rotationRate.z,%10.10f,magneticField.x,%10.10f,magneticField.y,%10.10f,magneticField.z,%10.10f,heading,%.3f,accuracy,%.3f,level,%{public}d,variant,%{public}d,mode,%{public}d,status,%{public}#02x,clientID,%{public}llu,timestamp,%{public}lf,now,%{public}lf,latency,%{public}lf
virtual CLMotionActivity::TypeYouth CLFitnessYouthGenericWorkoutOverride::doOverride(CLMotionActivity::TypeYouth, const CLNatalieModelInput &)
Overriding youth type for generic workout, beginTime, %f, before, %{public}d, after, %{public}d
void CLMapDataUtil::CovarInvDet::init(const double &, const double &, const double &, const double &)
invalid inputs
void CLMapDataUtil::CovarInvDet::calcInvAndDet()
fVarEast <= 0.0
fVarNorth <= 0.0
fVarEastNorth < 0.0
CLMM, Unexpected determinant of 0
void CLMapDataUtil::CovarInvDet::calculateScoreAndVarFactor(CLMapDataUtil::MapMatcherScore &) const
determinant <= 0.0
/Library/Caches/locationd/
root
static std::string CLPersistentStore::getMutableStorePath(CLPersistentStoreType)
no mutable store path for type, %{public}d
could not get mutable store path for type, %{public}d
/System/Library/Frameworks/CoreLocation.framework/Support/
/System/Library/Frameworks/CoreLocation.framework
/Library/locationd/
virtual bool CLPersistentStore::refresh()
Store %s is configured for in-memory mode - not refreshing and marking the store as unmodified
#Warning persistent store %s has been modified - refreshing will lose changes
virtual bool CLPersistentStore::store()
#Warning data set %s is not changeable - not storing
Store %s is configured for in-memory mode - not storing and marking the store as unmodified
%s stored to disk %s
callback != __null
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLPersistentStore.mm
setStoreInterval
virtual void CLPersistentStore::setStoreInterval(const CFTimeInterval &, CLSiloBlock)
scheduling to auto-store %s every %.3fs
disabling auto-store for %s
WPHomeKitScanDutyCycle
CLHomeKitProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/HomeKitProvider/CLHomeKitProvider.mm
-[CLHomeKitProviderAdapter beginService]
CLHomeKitProvider
void CLHomeKitProvider::startScan(CLHomeKitProvider::ScanningPolicy)
#Warning Got a request for a scan but no one is interested. Ignoring
void CLHomeKitProvider::onHomeKitDeviceFound(NSUUID *, CLHomeKitProvider_Type::HAPVersion, NSData *, int, cl::chrono::CFAbsoluteTimeClock::time_point, CLHomeKitProvider_Type::HomeKitType)
found device %{private}@, data: %{private}@, rssi: %{private}d, type: %{private}d
#Warning Got a device notification but not device data
HomeKit Power Notification
HomeKit Scan Notification
HomeKit Buffered Scan Notification
FED4
Utility
getWPHomeKitType
Invalid Configuration Number
 (out of range [
]): 
Invalid Compatible Version
 got 
 expected 
Invalid Global State Number
Invalid Accessory Category Identifier
Invalid Advertising Interval and Length
Invalid Remaining Length
 got: 
 expected: 
Invalid Status Flags
Invalid Type
 exptected: 
Invalid Company Identifier
Valid
virtual void CLNotifier<CLHomeKitProvider_Type::Notification, CLHomeKitProvider_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLHomeKitProvider_Type::Notification, NotificationData_T = CLHomeKitProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLHomeKitProvider_Type::Notification, CLHomeKitProvider_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLHomeKitProvider_Type::Notification, NotificationData_T = CLHomeKitProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
bool (anonymous namespace)::addToScanCache(std::vector<CLHomeKitProvider_Type::HomeKitDevice> &, NSUUID *, NSData *, int, cl::chrono::CFAbsoluteTimeClock::time_point, CLHomeKitProvider_Type::HomeKitType) [HomeKitType = (anonymous namespace)::HomeKitServiceData]
#Warning Found invalid HomeKit device. Data length was invalid
#Warning Found invalid HomeKit device: %{private}s
bool (anonymous namespace)::addToScanCache(std::vector<CLHomeKitProvider_Type::HomeKitDevice> &, NSUUID *, NSData *, int, cl::chrono::CFAbsoluteTimeClock::time_point, CLHomeKitProvider_Type::HomeKitType) [HomeKitType = (anonymous namespace)::HomeKitManufacturerData]
virtual void CLNotifier<CLHomeKitProvider_Type::Notification, CLHomeKitProvider_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLHomeKitProvider_Type::Notification, NotificationData_T = CLHomeKitProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLHomeKitProvider_Type::Notification, CLHomeKitProvider_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLHomeKitProvider_Type::Notification, NotificationData_T = CLHomeKitProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLHomeKitProvider_Type::Notification, CLHomeKitProvider_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLHomeKitProvider_Type::Notification, NotificationData_T = CLHomeKitProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLHomeKitProvider_Type::Notification, CLHomeKitProvider_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLHomeKitProvider_Type::Notification, NotificationData_T = CLHomeKitProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLHomeKitProvider_Type::Notification, CLHomeKitProvider_Type::NotificationData, char, char>::listClients() [Notification_T = CLHomeKitProvider_Type::Notification, NotificationData_T = CLHomeKitProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
LastPrune
HarvestPruneTimer
HarvestUnlockTimer
CLHarvestController-upload
CLHarvestController-prune
LatitudeMin
LatitudeMax
LongitudeMin
LongitudeMax
Rules
Default
EnableHarvestingForLocationSimulation
virtual bool CLHarvestController::isHarvestingAllowedForLocationSimulation() const
EnableHarvestingForLocationSimulation not set to True.
http://localhost:8008
CLAppleCollectionServer_Realtime
Collection endpoint for: %s  set to : %s. Should be localhost:8008
v288@?0{CLVehicleConnection=dd[256c]d}8
virtual bool CLHarvestController::isPosHarvestingEligible(const CLDaemonLocation &) const
Pos harvesting not eligible as gps harvetsing is ineligible
!notFound
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Harvester/Controller/CLHarvestController.mm
updateClientAuthorization
v24@?0{shared_ptr<CLSubHarvester>=^{CLSubHarvester}^{__shared_weak_count}}8
Connected
Disconnected
CFAbsoluteTime CLHarvestController::getNextUploadTime()
getNextUploadTime: min time: %f
HarvesterMetricsUUID
%@%ld%ld
com.apple.locationd.bundle-/System/Library/LocationBundles/AltimeterHarvest.bundle
com.apple.locationd.bundle-/System/Library/LocationBundles/TraceHarvest.bundle
com.apple.locationd.bundle-/System/Library/LocationBundles/IonosphereHarvest.bundle
CLHarvestController::onPruneTimer
CLHarvestController::onUploadTimer
kCLTelephonyServiceConnectedNotification
kCLTelephonyServiceDisconnectedNotification
kCLTelephonyServiceResetNotification
kBundleIDUnavailable
kBundleVersionUnavailable
SUPL
kDataStatusNotification
kCellInfoNotification
kCellMonitorRefreshResultNotification
kCallStatusChangeNotification
kAtLeastOneVoiceCallInProgress
kNoVoiceCallInProgress
CLTelephonyServiceSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/TelephonyService/CLTelephonyService.mm
-[CLTelephonyServiceAdapter beginService]
-1 != fNotificationAsInt
operator int
CLTelephonyService::CLTelephonyService(id<CLIntersiloUniverse>)
CELL_LOC: fHardwareType, %d
notifyAllClients
CLTelephonyService.mm
[expected containsObject:(NSString *)notification]
!notificationInfo
bool CLTelephonyService::dumpLog(const char *)
currently not connected to telephony service
bool CLTelephonyService::resetModem(const char *)
virtual bool CLTelephonyService::getIsRegisteredOnCell()
Registration status: %d
virtual bool CLTelephonyService::getRegistrationStatus(CFStringRef &)
Serving
Neighbor
Detected
Invalid
GSMCompact
UMTS
UTRAN
CDMA1x
CDMAEVDO
CDMAHybrid
SCDMA
bool CLTelephonyService::getRadioAccessTechnology(CFStringRef &)
bool CLTelephonyService::getServingOperator(std::string &)
bool CLTelephonyService::getServingProviderFromCarrierBundle(std::string &)
virtual bool CLTelephonyService::getServingMcc(int &)
virtual bool CLTelephonyService::getServingMnc(int &)
virtual bool CLTelephonyService::getServingCellLacCi(int &, int &)
bool CLTelephonyService::getSignalStrength(int &)
bool CLTelephonyService::getActiveCall(bool &)
kLte
kPseudoLte
UnknownMode
kIdle
i8@?0
CFStringRef (anonymous namespace)::NotificationMap::notificationFromInt(int)_block_invoke
Request to decode unknown integer %d is a programmer error. fSize %d
notificationFromInt_block_invoke
r^{__CFString=}8@?0
virtual void CLNotifier<CLTelephonyService_Type::Notification, CLTelephonyService_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLTelephonyService_Type::Notification, NotificationData_T = CLTelephonyService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLTelephonyService_Type::Notification, CLTelephonyService_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLTelephonyService_Type::Notification, NotificationData_T = CLTelephonyService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLTelephonyService_Type::Notification, CLTelephonyService_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLTelephonyService_Type::Notification, NotificationData_T = CLTelephonyService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTelephonyService_Type::Notification, CLTelephonyService_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLTelephonyService_Type::Notification, NotificationData_T = CLTelephonyService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTelephonyService_Type::Notification, CLTelephonyService_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLTelephonyService_Type::Notification, NotificationData_T = CLTelephonyService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTelephonyService_Type::Notification, CLTelephonyService_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLTelephonyService_Type::Notification, NotificationData_T = CLTelephonyService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLTelephonyService_Type::Notification, CLTelephonyService_Type::NotificationData, char, char>::listClients() [Notification_T = CLTelephonyService_Type::Notification, NotificationData_T = CLTelephonyService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual CLWorkoutPredictor_Type::WorkoutStopDetectionEvent CLTreadmillWorkoutStopModel::update(const CLWorkoutPredictorInputs &)
IndoorPedStop,state,%d,headingCnt,%d,stepCount,%d,zeroStepCount,%d,likelyExitCount,%d,longStd,%f,shortStd,%f,rails,%d,currentSteps,%d,vm,%f,recentZeroSteps,%d,exertionDelta,%f,exertionIsLow,%d,headingDelta,%f
CLWifiServiceSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/WifiService/CLWifiService.mm
-[CLWifiServiceAdapter beginService]
CLWifiService
60:c5:47:4f:51:1d
60:c5:47:4d:cd:6f
60:c5:47:4f:51:1c
CLWifiService internal state
WifiExcludedAp
CLWifiService::CLWifiService(id<CLIntersiloUniverse>, std::unique_ptr<IExternal>)
WifiService, gExcludedAP, %{public}s
CLWifiService scanning
this->fDispatchQueue != __null
WifiService, ctor, fDpcSource is NULL
WifiMaxAge
WifiPassiveScansOnly
WifiService, passive scans only
WsbClients, timer, %{public}0.f
virtual bool CLWifiService::unregisterForNotificationInternal(const CLWifiService_Type::Notification &)
WRTT: no active listeners
virtual bool CLWifiService::getPower(bool &)
WifiService, getPower, fDpcSource is NULL
void CLWifiService::wsbReportClientMetrics(const char *, int, bool)
WsbMetric, clients, %{public}s, delta, %{public}.1f
com.apple.clx.wsb.clients
duration
active:fake
active:fences
active:off
WsbMetric, regmode, %{public}s, duration, %{public}.1f
com.apple.clx.wsb.regmode
mode
active
submode
rollover:all
rollover:partial
rollover:off
rollover
profile:dynamic
profile:standard
profile
client:
WsbMetric, regmode, total, duration, %{public}.1f
total
WsbMetric, regmode, subminute
WsbClients, status, holdoff, clients, %{public}d, samplescan, %{public}d
WsbClients, status, reportonly, clients, %{public}d, dummyscan, %{public}d
void CLWifiService::wsbConfirmClientCounts(const char *)
WsbClients, mismatch, %{public}s, %{public}d, %{public}d, #CloneMe
void CLWifiService::setExitAndEntryScanNetworks(const std::vector<CLWifiService_Type::AccessPoint> &, const std::vector<CLWifiService_Type::AccessPoint> &)
setExitAndEntryScanNetworks, entry, %lu, exit, %lu
void CLWifiService::onWsbAnalyticsTimer()
WsbTimer, first, %{public}d
WsbClients, status, start
timer
CLWifiService::onDpcSource
Proximity
{ScanStats=III[13I]}8@?0
{ScanResult=d{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}}8@?0
virtual bool CLNotifier<CLWifiService_Type::Notification, CLWifiService_Type::NotificationData, char, CLWifiService_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLWifiService_Type::Notification, NotificationData_T = CLWifiService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLWifiService_Type::RegInfo]
virtual bool CLNotifier<CLWifiService_Type::Notification, CLWifiService_Type::NotificationData, char, CLWifiService_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLWifiService_Type::Notification, NotificationData_T = CLWifiService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLWifiService_Type::RegInfo]
virtual void CLNotifier<CLWifiService_Type::Notification, CLWifiService_Type::NotificationData, char, CLWifiService_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLWifiService_Type::Notification, NotificationData_T = CLWifiService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLWifiService_Type::RegInfo]
void CLNotifier<CLWifiService_Type::Notification, CLWifiService_Type::NotificationData, char, CLWifiService_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLWifiService_Type::Notification, NotificationData_T = CLWifiService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLWifiService_Type::RegInfo]
virtual void CLNotifier<CLWifiService_Type::Notification, CLWifiService_Type::NotificationData, char, CLWifiService_Type::RegInfo>::removeClient(int) [Notification_T = CLWifiService_Type::Notification, NotificationData_T = CLWifiService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLWifiService_Type::RegInfo]
virtual bool CLNotifier<CLWifiService_Type::Notification, CLWifiService_Type::NotificationData, char, CLWifiService_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLWifiService_Type::Notification, NotificationData_T = CLWifiService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLWifiService_Type::RegInfo]
virtual void CLNotifier<CLWifiService_Type::Notification, CLWifiService_Type::NotificationData, char, CLWifiService_Type::RegInfo>::listClients() [Notification_T = CLWifiService_Type::Notification, NotificationData_T = CLWifiService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLWifiService_Type::RegInfo]
OverrideUserMetsWithMets
OverrideRawTruthMetsWithMets
virtual void CLCalorieController::pause()
pause
virtual void CLCalorieController::resume()
resume
std::vector<CLCalorieUpdate> CLCalorieController::updateCalorimetry(CFAbsoluteTime)
METS consumed,startTime,%.3f,computeTime,%.3f,now,%.3f,activity,%d,userMets,%f,wrMets,%f,rawTruthMets,%f,avgTruthMets,%f,basalMets,%f,duration,%lf,stored,%d,%s,rawHRMets,%f,rawFMMets,%f,totalCalories,%lld,basalCalories,%lld,VectorMag,%f,pushCount,%d,activityWithoutOverride,%d,isStanding,%d,isMotionOverrideSet,%d
Popping out an activity since there's no activity associated with current time.  This shouldn't happen
float CLCalorieController::sanitizeMets(float, float)
MET spike,%f,setting to basal,%f
In-human MET spike,%f,setting to upper bound,%f
NatalimetryMaxDelay
CLSPU
CLSPU::CLSPU(bool)
spuLogLevel,%d
LogCompassCalibration
LogCompass
IgnoreDynamicGyroBiasEstimator
ConsumeBasebandSpeedInActivity
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Utilities/CLSPU.mm
sendCommandPayload
virtual bool CLSPU::sendCommandPayload(const void *, size_t)
Trying to send CMA command,datalen,%zu
configureMotionCoprocessor
virtual bool CLSPU::configureMotionCoprocessor(bool)
Sending new config to SPU:enableActivity,%{private}u,enableStepCounting,%{private}u,enableOnBodyDetection,%{private}u,activityForceCodeTransition,%{private}u,stepCountingForceCodeTransition,%{private}u,enableThreshold,%{private}u,disableDynamicBias,%{public}u,ignoreDynamicBias,%{public}u,ispEnable,%{public}u,ispMode,%{public}u,ISPUpdateIntervalOverride,%{public}f,stickyIsp,%{public}d,logLevel,%{public}d,enableCoarseElevation,%{private}d,proactiveRevisitTime,%{public}u,fallStatsMode,%{private}u,sensorRecordingActive,%{private}u,simulateEvent,%{private}u,userStudyPressureDataCollection,%{private}u,detectorEnabled,%{private}u,lastAckedAopTimestamp,%{public}llu,gateDynamicBiasOnChargerStatus,%{private}u,supportsOISImprovements,%{private}u
Sending initial configuration.
Failed to configure motion coprocessor
CompassCalibration
void CLSPU::retrieveCachedCompassCalibration()
[CompassCalibration] no persistent calibration found
Scale
[CompassCalibration] logging initial persisted calibration: bias.x,%.2f,.y,%.2f,.z,%.2f,radius,%.2f,level,%d,quality,%.2f,cftime,%.3f
[CompassCalibration] stale persistent calibration,%@
[CompassCalibration] restoring calibration,%@
virtual void CLSPU::visitHello(const CMMotionCoprocessorReply::Hello *)
SPU rejected configuration. resending.
virtual void CLSPU::visitCompassCalibration(const CMMotionCoprocessorReply::CompassCalibration *)
[CompassCalibration] bias.x,%f,.y,%f,.z,%f,scale.x,%f,.y,%f,.z,%f,quality,%{public}f,cost,%{public}f,coverage,%{public}f,earthDiffRatio,%{public}f,pose.x,%f,.y,%f,.z,%f,level,%{public}d,saturations,%{public}d,hasConsistency,%{public}d,apAwake,%{public}d,planarity,%{public}f,temperature,%{public}f,minTemperatureSinceLastCal,%{public}f,maxTemperatureSinceLastCal,%{public}f,avgTemperatureSinceLastCal,%{public}f
[CompassCalibration] persisting calibration,%@
[CompassCalibration] clearing persistent calibration
virtual void CLSPU::visitSensorBuffer(const CMMotionCoprocessorReply::SensorBuffer *)
data type %u,received and reconstructed
Receiving first Sensor Buffer packet since process start, seq %u
Sensor Buffer packet drop detected. AP is expecting %u, but got %u
void CLSPU::setFallModels(const CMSPUFall_Types::FallModel &, const CMSPUFall_Types::FallModel &, const CMSPUFall_Types::FallModel &)
Sending fallModel Command.
bool CLSPU::setFastAccelConfig(uint16_t, uint16_t)
Commanding fast accel config BW %{public}u, FSR %{public}u
virtual void CLSPU::visitMagnetometerReset(const CMMotionCoprocessorReply::MagnetometerReset *)
MagnetometerReset,timestamp,%{public}f,timeSinceLastRemagTrigger,%llu,timeSinceLastRemag,%llu,triggerCount,%llu,exitingSaturation,%{public}d,extendedSaturation,%{public}d,shiftInSaturation,%{public}d,fSuccessFlag,%{public}d
bool CLSPUReportReconstructor<CLSPU::PackedSensorBuffer>::reconstruct(const U *) [T = CLSPU::PackedSensorBuffer, U = CMMotionCoprocessorReply::SensorBuffer]
Out of order segments,U::kType,%{public}u,fLastSegment,%{public}u,packet->fSegment,%{public}u
Bad size,packet->fSize,%{public}u
CLManagedLocationDatabase<CLNrCellLocationDatabase, CLTelephonyService_Type::NrCell>::CLManagedLocationDatabase(std::string, bool, std::unique_ptr<IExternal>, std::string) [Database = CLNrCellLocationDatabase, DataType = CLTelephonyService_Type::NrCell]
int declinationCalc(const float, const float, const float, const float, GeomagneticData *)
WMM initialization encountered an error
WMM evaluation encountered an error
geomagnetic model invalid near poles (%f, %f, %f)
int E0000(int, int *, float, float, float, float, float *, float *, float *, float *)
could not open geomagnetic data file %s (%{public}s)
geomagnetic data file appears to be empty
%d%d%f%f%f%f
geomagnetic data file appears to have invalid dimensions
supplied date (%{public}f) outside valid range (epoch=%{public}f)
LogMotionStateReplay
CLMotionStateSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Context/CLMotionState.mm
-[CLMotionStateAdapter beginService]
CLMotionState
DisableMotionStateNotify
CLMotionState::CLMotionState(id<CLIntersiloUniverse>)
DisableMotionStateNotifyDefaultsWrite,%d
virtual bool CLMotionState::registerForNotificationInternal(const CLMotionState_Type::Notification &)
DOMINANT ACTIVITY: start monitoring dominant activity
virtual bool CLMotionState::unregisterForNotificationInternal(const CLMotionState_Type::Notification &)
DOMINANT ACTIVITY: stop monitoring dominant activity
virtual void CLNotifier<CLMotionState_Type::Notification, CLMotionState_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLMotionState_Type::Notification, NotificationData_T = CLMotionState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLMotionState_Type::Notification, CLMotionState_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMotionState_Type::Notification, NotificationData_T = CLMotionState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionState_Type::Notification, CLMotionState_Type::NotificationData>::removeClient(int) [Notification_T = CLMotionState_Type::Notification, NotificationData_T = CLMotionState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionState_Type::Notification, CLMotionState_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMotionState_Type::Notification, NotificationData_T = CLMotionState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionState_Type::Notification, CLMotionState_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLMotionState_Type::Notification, NotificationData_T = CLMotionState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionState_Type::Notification, CLMotionState_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMotionState_Type::Notification, NotificationData_T = CLMotionState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionState_Type::Notification, CLMotionState_Type::NotificationData>::listClients() [Notification_T = CLMotionState_Type::Notification, NotificationData_T = CLMotionState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLPredictedWalkDistanceBoutDetector::handleMotionActivityNotification(const CLMotionActivity &)
Walking bout ended due to exceeding max duration without stepNotifications
Activity type is %{private}s (%{private}d), conf, %{private}d, raw activity type %{private}s (%{private}d), raw conf, %{private}d, mounted, %{private}d, startTime, %f
void CLPredictedWalkDistanceBoutDetector::handleStepCountNotification(const CLStepCountEntry &)
Received stepCountEntry, startTime, %{private}f, count, %{private}d, activeTime, %{private}f, distance, %{private}f, firstStepTime, %{private}f, distanceSource, %{private}d
Ignoring step count while in wheelchair mode
Saw time go backwards
Saw step count go backwards
Unexpected large jump in steps, %{public}d new steps, %{public}.1f seconds delay since last entry, stopping bout
Possibly missing step count entries, %{public}d new steps, %{public}.1f seconds delay since last entry
Unexpected large jump in steps, %{public}d new steps, %{public}.1f seconds delay since last entry
Walking bout ended due to exceeding max duration without steps
Walking bout has ended due to exceeding the max duration
StepCountEntry with steps but no firstStepTime
StepCountEntry with steps but activeTime doesn't advance
Potential walking bout identified... fBoutStartTime: %{public}f
Missing previous epoch before an epoch with steps
Extending bout...,deltaSteps,%d,dist,%.3f,activeTime,%.3f
void CLPredictedWalkDistanceBoutDetector::stopBout()
Timestamp comparisons... firstStepCountTime:%{private}f, lastStepCountTime:%{private}f, trimmedBoutStartTime:%{private}f, trimmedBoutEndTime:%{private}f
void CLPredictedWalkDistanceBoutDetector::assembleAndReportBout(const std::list<P6MWDStepEntry> &, P6MWDBoutType) const
type,%{public}d,boutStart,%{public}f,boutEnd,%{public}f,steps,%{public}d,distance,%{public}f,activeTime,%{public}f,gpsSteps,%{public}d,gpsDistance,%{public}f,report,%{public}d
bool CLPredictedWalkDistanceBoutDetector::shouldReportBout(const CLPredictedWalkDistanceBoutEntry &) const
Discarding bout since it does not meet minimum timeWithSteps requirement
void CLPredictedWalkDistanceBoutDetector::handleUserInfoUpdate(const CLBodyMetrics &)
CLPredictedWalkDistanceBoutDetector: Received user info (%s)
CLPredictedWalkDistanceBoutDetector: Ending walking bout due to wheelchair (%{public}.2f)
CLFileUpdate
CLFileUpdate::CLFileUpdate(id<CLIntersiloUniverse>, CLFileUpdate::OnUpdated, void *)_block_invoke
CLFU,data reachability is not available - not downloading %s
CLFU,downloading from %s to %s
#Warning,CLFU,could not download from %s to %s
CLFileUpdate::CLFileUpdate(id<CLIntersiloUniverse>, CLFileUpdate::OnUpdated, void *)
CLFU,registered for kNotificationCompanionConnectionUpdate
void CLFileUpdate::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
CLFU,onCompanionNotification, notification, %d
CLFU,fCompanionIsNearby,%d,fDownloadDst,%s
void CLFileUpdate::scheduleDownload()
CLFU,no download source set - not downloading
CLFU,we are now on wifi, downloading %s aggressively (period %.3f)
CLFU,last %s downloaded over %.3f seconds ago (%.3f), starting a download now
CLFU,last %s downloaded less than %.3f seconds ago (%.3f), scheduling download for %.3f (%.3f away)
CLFU,cannot verify existence of %s, re-downloading
CLFU,scheduled download %s is after %.3f deadline (%.3f after) - overriding
CLFU,Throttling download %s due to retry delay, scheduling download for %.3f (%.3f away)
void CLFileUpdate::onDownloaded(CLFileDownload *, bool)
CLFU,could not rename %{public}s to %{public}s,%{public}d
CLFU,download completed to %s
CLFU,newly downloaded %s file is now %s (time %.3f)
#Warning,CLFU, could not get modified time for %{public}s
#Warning,CLFU, could not download from %s to %s
CLFU,data reachability is not available - not retrying %s
CLFU,retry count %{public}d, will re-download for %s after delay of %f
virtual bool CLFileUpdate::setUpdateSource(const char *, const char *, const CFTimeInterval &)
#Warning,CLFU,%{public}s downloading in progress, cannot change update settings
CLFU,%{public}s download timeout must be greater than 0. Forcing to 30 seconds.
FileUpdate.
.temp
CLFU,could not create path %{public}s
virtual bool CLFileUpdate::setUpdateRate(const CFTimeInterval &, const CFTimeInterval &)
#Warning,CLFU, update rate %.3fs is shorter than WiFi update rate %.3fs - overriding WiFi update rate
CLFU,file %s update rate set to %.3fs, %.3fs
virtual void CLFileUpdate::cancelUpdate()
CLFU,unregistered for kNotificationCompanionConnectionUpdate for %s
CLFU,stopping download of %s
bool CLFileUpdate::getFileModifiedTime(CFAbsoluteTime &)
CLFU,destination stat failed,%{public}s,%{public}d
bool CLFileUpdate::checkForDownloadTimeout()
CLFU,download of %s not yet timed out. Blocking current download request
CLFU,current download of %s has timed out, canceling
CLFileUpdate::onDownloaded
CLFileUpdate::onStatusNotification
CLFileUpdate::onCompanionNotification
CLGyroCalibrationDatabaseSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/SensorCalibration/CLGyroCalibrationDatabase.mm
-[CLGyroCalibrationDatabaseLocationdAdapter beginService]
virtual bool CLGyroCalibrationDatabase::getGyroStats(CLMotionTypeRotationRate &, CLMotionTypeRotationRate &, CLMotionTypeRotationRate &, bool)
Warning: Not implemented.
virtual int CLGyroCalibrationDatabase::getMaxDynamicTemperature()
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGyroCalibrationDatabase_Type::Notification, CLGyroCalibrationDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLGyroCalibrationDatabase_Type::Notification, NotificationData_T = CLGyroCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLTransitMacTile-Mutex
pInput != nullptr
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTransitMacTile.mm
traverseTileFile
virtual bool CLTransitMacTile::traverseTileFile(FILE *, const CLTileFile::TraverseDetails &)
TransitMac, Traversing transit mac tile
TransitMac, Transit mac tile size = %lu
TransitMac, failed to allocate transit mac tile
TransitMac, failed to decode transit mac tile protobuf, encrypted=%{public}lu
TransitMac, failed to get fields in transit mac tile
TransitMac, ver,%d, x, %d, y, %d, generated, %.01lf, age, %.01f, ageThresh, %d, numOfMacs, %lu
outMacAddresses != nullptr
extractTransitMacAddresses
bool CLTransitMacTile::extractTransitMacAddresses(std::vector<uint64_t> *, std::vector<CLTilesManager_Type::TransitMac> *)
TransitMac, Searching transit mac tile
TransitMac, failed to open tile file, %s
TransitMac, failed to read tile file, %s
TransitMac, failed to parse tile file, %s
TransitMac, empty tile??, %s
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/PeerRanging/CLPeerRangingManager.mm
!isIMac
CLPeerRangingManager::CLPeerRangingManager(CLPeerRangingManagerDelegate &, bool, bool, bool, bool, bool)
!isMacPro
!isIPhone
WRTT: device type,%{public}d
void CLPeerRangingManager::requestRanging(const CLPeerRangeRequest &)
WRTT: request while wifi is off!
WRTT: mgr received request as initiator, timeout, %{public}lf [s]
WRTT: mgr received request as target
void CLPeerRangingManager::cancelRanging(const CLPeerRangeRequest &)
WRTT: mgr received cancel session
void CLPeerRangingManager::onTimerFired()
WRTT: timed out
void CLPeerRangingManager::onWifiPower(bool)
WRTT: WiFi power %{public}s
NSData *CLPeerRangingManager::findKeyID(const CLMacAddress &)
#Warning Multiple Peers in request with matching mac address, %{private}s
void CLPeerRangingManager::onWifiRangeMeasurements(const std::vector<CLWifiRangeResult> &)
WRTT: RTT measurements for %{public}ld peer(s)
WRTT: unexpected status code %{public}d (%{public}#x)
WRTT: error status code %{public}d (%{public}#x) reported from WiFi, report kCLErrorPrivateRangingLowLevelError
WRTT: unknown status code %{public}d (%{public}#x)
WRTT: no individual measurements in burst
WRTT,range %{public}lu of %{public}lu,%{private}f,core,%{private}d
WRTT, decisionProcessor in CLPeerRangingManager is not allocated
void CLPeerRangingManager::onWifiError(NSString *, NSInteger, const std::vector<CLRangingPeerInternal> &)
WRTT: recieved Wifi error %{public}ld for %{public}ld peers
errorCode && "Should only be called when we have an error"
onWifiError
CLLocationDerivedSpeedEstimator.mm
Use -initWithSilo:
Invalid parameter not satisfying: %@
universe
-[CLLocationDerivedSpeedEstimator initInUniverse:]
%s, %d, %s, %d
CLLocationDerivedSpeedEstimator
dndwd
-[CLLocationDerivedSpeedEstimator startWsbClient]
startWsbClient
-[CLLocationDerivedSpeedEstimator stopWsbClient]
stopWsbClient
-[CLLocationDerivedSpeedEstimator _onScanTimer]
VEHICULAR: start extra scan
speedestimator
CLWifiLocationProvider
-[CLLocationDerivedSpeedEstimator _feedLocation:]
VEHICULAR: leeched location, %s
VEHICULAR: disqualified leeched location, type, %d
VEHICULAR: location timestamp out of order
VEHICULAR: disqualified leeched location, horizontal accuracy, %f
VEHICULAR: disqualified leeched location, age, %f
VEHICULAR: qualified leeched location, type, %d
VEHICULAR: first qualifying location
VEHICULAR: renew previous location older than age of %f seconds
VEHICULAR: previous location, type, %d, %s
VEHICULAR: distanceMoved, %f, elapsedTime, %f
VEHICULAR: drop leeched location within %f sec
VEHICULAR: accept qualified leeched location, type, %d
VEHICULAR: outlier, conservativeSpeed, %f, effectiveSpeed, %f, speedUncertainty, %f, distanceMoved, %f, elapsedTime, %f, type, %d
VEHICULAR: vehicular speed detected, consecutive observations, %d, elapsedTime, %f, lastElapsedTime, %f, delta, %f
VEHICULAR: conservativeSpeed, %f, effectiveSpeed, %f, speedUncertainty, %f, distanceMoved, %f, elapsedTime, %f, type, %d
-[CLLocationDerivedSpeedEstimator handleMotionStateNotification:]
MotionState, %s, type, %d, conf, %d, mounted, %d, startTime, %f
VEHICULAR: vehicularStartTime, %f, seq, %d
VEHICULAR: vehicularLastNoHintsTime, %f
VEHICULAR: skipping LatencyMetrics, seenNonVehicularState, %d
VEHICULAR: reset vehicular latency measures
-[CLLocationDerivedSpeedEstimator onWifiServiceNotification:data:]
VEHICULAR: notification ScanCache received %d
VEHICULAR: wifi associated state, %d
VEHICULAR: received unhandled WifiService notification %d
-[CLLocationDerivedSpeedEstimator onMotionStateNotification:data:]
VEHICULAR: received unhandled notification %d
ShowActivityVehicular
ShowActivityVehicularMounted
Activity
{CLWifiLocationUpdateRequest=iiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}diBBiidddddiBBi{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}8@?0
CLCompanionNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Companion/CLCompanionNotifier.mm
-[CLCompanionNotifierAdapter beginService]
CompanionStateSyncInterval
CLDataProtectionManager
v20@?0S8@"NSData"12
iPhone5
iPhone6
iPhone8,4
Watch1
iPhone10,1
iPhone10,2
iPhone10,3
iPhone5,1
iPhone5,2
iPhone5,3
iPhone5,4
iPhone6,1
iPhone6,2
iPhone7,1
iPhone7,2
iPhone8,1
iPhone8,2
iPhone9,1
iPhone9,2
void CLCompanionNotifier::sendCompanionMessage(CLCompanionNotifier_Type::Type, NSData *, IDSMessagePriority, BOOL, BOOL, BOOL, CFTimeInterval, BOOL) const
Sending message,type,%d,size,%lu,priority,%ld,fireAndForget,%d,encrypt,%d,bypassConnectionCheck,%d,timeout,%f,nonWaking,%d
void CLCompanionNotifier::setStateSyncTimer(bool)
timer interval,%f
void CLCompanionNotifier::connectionUpdate(bool)
IDS connection update,status,%d,prevDisconnection,%f,modelID,%s,uniqueIDOverride,%s,localDeviceID,%s
-[CLCompanionNotifierAdapter(isSupported) beginService]
companion idsService (beginService) %p
com.apple.private.alloy.location.motion
CLCompanionNotifier::onDataProtectionNotification
CLCompanionNotifier::onFitnessTrackingNotification
CLCompanionNotifier::onMotionStateObserverNotification
Transport
virtual void CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]
void CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]
virtual void CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::removeClient(int) [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]
virtual bool CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]
virtual bool CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]
virtual bool CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]
virtual void CLNotifier<CLCompanionNotifier_Type::Notification, CLCompanionNotifier_Type::NotificationData, char, CLCompanionNotifier_Type::RegistrationInfo>::listClients() [Notification_T = CLCompanionNotifier_Type::Notification, NotificationData_T = CLCompanionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLCompanionNotifier_Type::RegistrationInfo]
virtual CLWorkoutPredictor_Type::WorkoutActiveStateEvent CLOutdoorCyclingActiveStateModel::update(const CLWorkoutPredictorInputs &)
Cycling active state model failure to get cycling result, %f
void CLOutdoorCyclingActiveStateModel::doPause(const CLOutdoorCyclingActiveStateModel::ETick *)
CLOutdoorCyclingActiveStateModel,pausing,nominalPauseStates,%d,fastPauseWithTier1Prob,%d,pauseHistGPSOverride,%d,countTier1Override,%d,%s
void CLOutdoorCyclingActiveStateModel::doResume(const CLOutdoorCyclingActiveStateModel::ETick *)
CLOutdoorCyclingActiveStateModel,resuming,nominalResumeStates,%d,fastResumeWithTier1Prob,%d,resumeHistGPSOverride,%d,countTier1Override,%d,%s
const T &CMQueue<CLOutdoorCyclingActiveStateModel::CycleStateResultForPauseResume>::operator[](const size_t) const [T = CLOutdoorCyclingActiveStateModel::CycleStateResultForPauseResume]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLSqliteErrorHandlers.h
handleSqlErrorCode_SQLITE_ERROR
handleSqlErrorCode_SQLITE_INTERNAL
handleSqlErrorCode_SQLITE_PERM
handleSqlErrorCode_SQLITE_ABORT
handleSqlErrorCode_SQLITE_BUSY
handleSqlErrorCode_SQLITE_LOCKED
handleSqlErrorCode_SQLITE_NOMEM
handleSqlErrorCode_SQLITE_READONLY
handleSqlErrorCode_SQLITE_INTERRUPT
handleSqlErrorCode_SQLITE_IOERR
handleSqlErrorCode_SQLITE_CORRUPT
handleSqlErrorCode_SQLITE_NOTFOUND
handleSqlErrorCode_SQLITE_FULL
handleSqlErrorCode_SQLITE_CANTOPEN
handleSqlErrorCode_SQLITE_PROTOCOL
handleSqlErrorCode_SQLITE_EMPTY
handleSqlErrorCode_SQLITE_SCHEMA
handleSqlErrorCode_SQLITE_TOOBIG
handleSqlErrorCode_SQLITE_CONSTRAINT
handleSqlErrorCode_SQLITE_MISMATCH
handleSqlErrorCode_SQLITE_MISUSE
handleSqlErrorCode_SQLITE_NOLFS
handleSqlErrorCode_SQLITE_AUTH
handleSqlErrorCode_SQLITE_FORMAT
handleSqlErrorCode_SQLITE_RANGE
handleSqlErrorCode_SQLITE_NOTADB
handleSqlErrorCode_SQLITE_NOTICE
handleSqlErrorCode_SQLITE_WARNING
handleSqlErrorCode_SQLITE_ROW
handleSqlErrorCode_SQLITE_DONE
handleSqlErrorCode_SQLITE_ERROR_MISSING_COLLSEQ
handleSqlErrorCode_SQLITE_ERROR_RETRY
handleSqlErrorCode_SQLITE_ERROR_SNAPSHOT
handleSqlErrorCode_SQLITE_IOERR_READ
handleSqlErrorCode_SQLITE_IOERR_SHORT_READ
handleSqlErrorCode_SQLITE_IOERR_WRITE
handleSqlErrorCode_SQLITE_IOERR_FSYNC
handleSqlErrorCode_SQLITE_IOERR_DIR_FSYNC
handleSqlErrorCode_SQLITE_IOERR_TRUNCATE
handleSqlErrorCode_SQLITE_IOERR_FSTAT
handleSqlErrorCode_SQLITE_IOERR_UNLOCK
handleSqlErrorCode_SQLITE_IOERR_RDLOCK
handleSqlErrorCode_SQLITE_IOERR_DELETE
handleSqlErrorCode_SQLITE_IOERR_BLOCKED
handleSqlErrorCode_SQLITE_IOERR_NOMEM
handleSqlErrorCode_SQLITE_IOERR_ACCESS
handleSqlErrorCode_SQLITE_IOERR_CHECKRESERVEDLOCK
handleSqlErrorCode_SQLITE_IOERR_LOCK
handleSqlErrorCode_SQLITE_IOERR_CLOSE
handleSqlErrorCode_SQLITE_IOERR_DIR_CLOSE
handleSqlErrorCode_SQLITE_IOERR_SHMOPEN
handleSqlErrorCode_SQLITE_IOERR_SHMSIZE
handleSqlErrorCode_SQLITE_IOERR_SHMLOCK
handleSqlErrorCode_SQLITE_IOERR_SHMMAP
handleSqlErrorCode_SQLITE_IOERR_SEEK
handleSqlErrorCode_SQLITE_IOERR_DELETE_NOENT
handleSqlErrorCode_SQLITE_IOERR_MMAP
handleSqlErrorCode_SQLITE_IOERR_GETTEMPPATH
handleSqlErrorCode_SQLITE_IOERR_CONVPATH
handleSqlErrorCode_SQLITE_IOERR_VNODE
handleSqlErrorCode_SQLITE_IOERR_AUTH
handleSqlErrorCode_SQLITE_IOERR_BEGIN_ATOMIC
handleSqlErrorCode_SQLITE_IOERR_COMMIT_ATOMIC
handleSqlErrorCode_SQLITE_IOERR_ROLLBACK_ATOMIC
handleSqlErrorCode_SQLITE_LOCKED_SHAREDCACHE
handleSqlErrorCode_SQLITE_LOCKED_VTAB
handleSqlErrorCode_SQLITE_BUSY_RECOVERY
handleSqlErrorCode_SQLITE_BUSY_SNAPSHOT
handleSqlErrorCode_SQLITE_CANTOPEN_NOTEMPDIR
handleSqlErrorCode_SQLITE_CANTOPEN_ISDIR
handleSqlErrorCode_SQLITE_CANTOPEN_FULLPATH
handleSqlErrorCode_SQLITE_CANTOPEN_CONVPATH
handleSqlErrorCode_SQLITE_CANTOPEN_DIRTYWAL
handleSqlErrorCode_SQLITE_CORRUPT_VTAB
handleSqlErrorCode_SQLITE_CORRUPT_SEQUENCE
handleSqlErrorCode_SQLITE_READONLY_RECOVERY
handleSqlErrorCode_SQLITE_READONLY_CANTLOCK
handleSqlErrorCode_SQLITE_READONLY_ROLLBACK
handleSqlErrorCode_SQLITE_READONLY_DBMOVED
handleSqlErrorCode_SQLITE_READONLY_CANTINIT
handleSqlErrorCode_SQLITE_READONLY_DIRECTORY
handleSqlErrorCode_SQLITE_ABORT_ROLLBACK
handleSqlErrorCode_SQLITE_CONSTRAINT_CHECK
handleSqlErrorCode_SQLITE_CONSTRAINT_COMMITHOOK
handleSqlErrorCode_SQLITE_CONSTRAINT_FOREIGNKEY
handleSqlErrorCode_SQLITE_CONSTRAINT_FUNCTION
handleSqlErrorCode_SQLITE_CONSTRAINT_NOTNULL
handleSqlErrorCode_SQLITE_CONSTRAINT_PRIMARYKEY
handleSqlErrorCode_SQLITE_CONSTRAINT_TRIGGER
handleSqlErrorCode_SQLITE_CONSTRAINT_UNIQUE
handleSqlErrorCode_SQLITE_CONSTRAINT_VTAB
handleSqlErrorCode_SQLITE_CONSTRAINT_ROWID
handleSqlErrorCode_SQLITE_NOTICE_RECOVER_WAL
handleSqlErrorCode_SQLITE_NOTICE_RECOVER_ROLLBACK
handleSqlErrorCode_SQLITE_WARNING_AUTOINDEX
handleSqlErrorCode_SQLITE_AUTH_USER
handleSqlErrorCode_SQLITE_OK_LOAD_PERMANENTLY
handleSqlErrorCode_UNDEFINED
Count
Counts
ROWID
void CLSqliteDatabase::logStmtStatus(sqlite3_stmt *, bool)
Query: %s, full table scans: %d, sorts: %d, File: %s
TableName
SoftwareVersion
SerialNumber
TableInfo
DatabaseIdentifier
SELECT * FROM DatabaseIdentifier;
INSERT INTO DatabaseIdentifier (uuid) VALUES ("
_encryptedA
_encryptedB
_encryptedC
file::memory:?cache=shared
factory
factory_minimum
_unencrypted
consolidated
gyroCal
timezone
sensorRecorder
lockCache
table
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLSqliteDatabase.mm
handleSqlError
DROP INDEX 
DROP TRIGGER 
IncrementRowCount
DecrementRowCount
Increment
Decrement
INSERT
CREATE TRIGGER IF NOT EXISTS 
RowCount
 AFTER 
 FOR EACH ROW BEGIN
 UPDATE 
 SET 
1 WHERE rowid=1; END
 VALUES (
SELECT sql FROM 
sqlite_master
 WHERE 
=? AND 
SELECT name FROM 
 WHERE name='
PRAGMA table_info(
PRAGMA foreign_key_list(
_tmp
CREATE TEMPORARY TABLE 
 SELECT 
dstName
backupToFile
SELECT 
INSERT 
OR REPLACE 
INTO 
) VALUES (?
WHERE 
(*fConnectionMutex).__assertOwned()
prepareStatementNoCache
cacheStatement
BEGIN TRANSACTION
END TRANSACTION
fTransactionCount == 0
int CLSqliteDatabase::endTransaction()
ROLLBACK TRANSACTION
rollback
No valid connection to CLSqliteDatabase database.
no database
sqlite3_step()
sqlite3_reset()
com.apple.locationd.CLSqliteDatabase.vacuum
pragma page_count;
pragma freelist_count;
main
VACUUM
pragma incremental_vacuum(
IncrementalVacuum
pragma auto_vacuum;
pragma auto_vacuum = 2;
pragma auto_vacuum = 0;
pragma foreign_keys = 
INTEGER
FLOAT
BLOB
TEXT
, PRIMARY KEY (
, FOREIGN KEY(
) REFERENCES 
 ON DELETE 
 ON UPDATE 
SELECT indexInfo.name FROM pragma_index_list('
') AS indexList, pragma_index_info(indexList.name) AS indexInfo
getCurrentErrorMessage
No database
 PRIMARY KEY
 AUTOINCREMENT
NO ACTION
RESTRICT
SET NULL
SET DEFAULT
CASCADE
CleanShutdown
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/DaemonStatus/CLDaemonStatus.mm
-[CLDaemonStatusStateTracker initWithQueue:identifier:state:]
DaemonStatus
batteryData
reachability
thermalLevel
airplaneMode
batterySaverModeEnabled
restrictedMode
-[CLDaemonStatusStateTracker updateState:]
_CLDaemonStatusStateTrackerState
CLDaemonStatusSilo
-[CLDaemonStatusAdapter beginService]
CLDaemonStatus
com.apple.locationd.MetricHeartbeat
CLDaemonStatus::CLDaemonStatus(id<CLIntersiloUniverse>)_block_invoke
failed to set MetricHeartbeat activity as DONE.  current state is %{public}ld
locationd
void CLDaemonStatus::isStartFromUncleanShutdown()
locationd was started after an unclean shutdown
void CLDaemonStatus::airplaneModeChanged()
airplane mode not supported on non-embedded
void CLDaemonStatus::onPowerNotification(io_service_t, natural_t, void *)
system has powered on
#warning No sleep state tranaction on has powered on
system can sleep request
system entering sleep
Sleep transaction grace timer still pending on will sleep
Already holding sleep state transaction on will sleep
CLDaemonStatus.sleeping
system will power on
system exiting sleep
#warning No sleep state tranaction on will not sleep
none
FamilyCode
void CLDaemonStatus::notifyMetricHeartbeat()
MetricHeartbeat, notify
void CLDaemonStatus::migrationPerformed()
Notifying clients that migration is being performed
CLDaemonStatus::onPowerNotification
virtual void CLNotifier<CLDaemonStatus_Type::Notification, CLDaemonStatus_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLDaemonStatus_Type::Notification, NotificationData_T = CLDaemonStatus_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLDaemonStatus_Type::Notification, CLDaemonStatus_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLDaemonStatus_Type::Notification, NotificationData_T = CLDaemonStatus_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLDaemonStatus_Type::Notification, CLDaemonStatus_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLDaemonStatus_Type::Notification, NotificationData_T = CLDaemonStatus_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDaemonStatus_Type::Notification, CLDaemonStatus_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLDaemonStatus_Type::Notification, NotificationData_T = CLDaemonStatus_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDaemonStatus_Type::Notification, CLDaemonStatus_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLDaemonStatus_Type::Notification, NotificationData_T = CLDaemonStatus_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDaemonStatus_Type::Notification, CLDaemonStatus_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLDaemonStatus_Type::Notification, NotificationData_T = CLDaemonStatus_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLDaemonStatus_Type::Notification, CLDaemonStatus_Type::NotificationData, char, char>::listClients() [Notification_T = CLDaemonStatus_Type::Notification, NotificationData_T = CLDaemonStatus_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
TypeKey
ConfidenceKey
MountedStateKey
MountedConfidenceKey
StandingKey
TiltKey
TimestampKey
VehicleConnectedKey
ExitStateKey
ExtExitTimeKey
StartTimeKey
RawTypeKey
kRawConfidenceKey
MacAddressKey
SsidKey
RssiKey
ChannelKey
AgeKey
ScanTimestampKey
ApplePersonalHotspotKey
ModeKey
macAddress
ssid
rssi
channel
scanTimestamp
isApplePersonalHotspot
void CLCellLocationMetrics::sendMetrics()
UclpMetric, celltileusage, attempts, %{public}d, als, %{public}d, tiles, %{public}d, unknown, %{public}d, alsreq, %{public}d, alscells, %{public}d, nCurrent, %{public}d, kbCurrent, %{public}.1f, nNeighbor, %{public}d, kbNeighbor, %{public}.01f
com.apple.clx.cellloc.celltileusage
attempts
alsrequests
alsreturned
numdownloadcurrent
kbcurrent
numdownloadneighbor
kbneighbor
void CLCellLocationMetrics::locationAttempt(int, int, int, CFAbsoluteTime)
@Celltileusage, attempt, %{public}d, als, %{public}d, tiles, %{public}d, unknown, %{public}d
void CLCellLocationMetrics::alsReply(int, CFAbsoluteTime)
@Celltileusage, als, %{public}d, cells, %{public}d
void CLCellLocationMetrics::tileDownloaded(bool, int, CFAbsoluteTime)
@Celltileusage, download, isCurrent, %{public}d, size, %{public}d, nCurrent, %{public}d, kbCurrent, %{public}.1f, nNeighbor, %{public}d, kbNeighbor, %{public}.01f
CLFenceMonitorDatabase::CLFenceMonitorDatabase(const CLSqliteDatabase::SqliteProperties &, const CLSqliteDatabase::ColumnInfo *)
Fence: No access to state DB
void CLFenceMonitorDatabase::clearLocationData()
Fence: state No access to DB
bool CLFenceMonitorDatabase::storeFenceState(const CLFenceManager_Type::Fence &, CLFenceManager_Type::FenceStatus)
Fence: state Invalid for DB
Fence: state store, %{private}lld, %{private}d, %{private}s
) VALUES (?, ?)
#Warning Fence: state couldn't bind statement (bundle ID %{public}s, name %{private}s)
bool CLFenceMonitorDatabase::removeFenceState(const CLFenceManager_Type::Fence &)
Fence: state remove, %{private}lld, %{private}s
#Warning Fence: state couldn't bind statement for deleting (bundle ID %{public}s, name %{private}s)
bool CLFenceMonitorDatabase::scrubFenceStates(const std::vector<CLFenceManager_Type::Fence> &)
Fence: state can't scrub DB
Fence: state scrub, remaining, %{public}lu
 NOT IN (
CLFenceManager_Type::FenceStatus CLFenceMonitorDatabase::getFenceState(const CLFenceManager_Type::Fence &)
Fence: state couldn't bind state [%{public}s]/%{public}s/%{private}s
Fence: state doesn't exist [%{public}s]/%{public}s/%{private}s
Fence: state error in retrieving for [%{public}s/%{public}s/%{private}s
Fence: state get, %{private}lld, %{private}d, %{private}s
double CLPredictedWalkDistanceUtils::calcCadenceStrideLengthOffset(const std::vector<P6MWDStrideCal> &, float, float, float, const std::vector<P6MWDStrideCal> &, const std::vector<WalkingSpeedStrideCal> &, CLPredictedWalkDistanceUtils::StrideCalInfo &)
Type,WatchCals,binCadenceCenter,%{private}.2f,binState,%{private}d,binValue,%{private}.3f,predictedStrideLength,%{private}.3f
numCalsWatch,%d,offsetWatch,%.3f
Type,PhoneCals,binCadenceCenter,%{private}.2f,binState,%{private}d,binValue,%{private}.3f,predictedStrideLength,%{private}.3f
numCalsPhone,%d,offsetPhone,%.3f
Type,WalkingSpeed,binCadenceCenter,%{private}.2f,binState,%{private}d,binValue,%{private}.3f,predictedStrideLength,%{private}.3f
numCalsWalkingSpeed,%d,offsetWalkingSpeed,%.3f
CMError CLPredictedWalkDistanceUtils::calculateWalkingSpeedStridecals(const CLPredictedWalkDistanceBoutEntry &, CLMobility::GaitMetricsDelegate *, WalkingStrideCalReportingDelegate *)
Looking for metrics during bout,startTime,%{private}f,endTime,%{private}f,steps,%{private}u,metrics,%{private}lu
startTime,%.3f,walkingSpeed,%.3f
startTime,%.3f,walkingSpeed,%.4f,stepLength,%.4f,segmentSteps,%d,segmentCadence,%.4f,segmentEpochCadenceSD,%d,cycleTime,%.3f
Writing walkingSpeedCal,startTime,%{public}.3f,endTime,%{public}.3f,cadenceWatch,%{public}.3f,cadenceGaitCycle,%{public}.3f,meanWalkingSpeed,%{public}.3f,gaitCycleYield,%{public}.3f
NatalimetryUserInfoAge
NatalimetryUserInfoHeightM
NatalimetryUserInfoWeightKG
NatalimetryUserInfoGender
NatalimetryUserInfoBiologicalSex
NatalimetryUserInfoHrmin
NatalimetryUserInfoHrmax
NatalimetryUserInfoPal
NatalimetryUserInfoRunVo2max
NatalimetryUserCondition
NatalimetryUserInfoBetaBlockerUse
NatalimetryAdaptiveExericseMinuteThreshold
NatalimetryUserInfoVo2max
static float CLNatalieModelInput::computeDerivedVo2max(const CLBodyMetrics)
Derived Vo2max, %.1f, Revised Vo2max, %.1f, Minimum Vo2max, %.1f, Beta Blocker Use, %d, Beta Blocker Vo2max, %.1f
static float CLNatalieModelInput::estimateHRmin(const CLBodyMetrics &)
Estimated HRmin, %.1f 
void CLNatalieModelInput::setTime(CFAbsoluteTime)
ModelInput, Larger than expected gap between begin and end ts.  Setting end ts to some sane default. (%f, %f)
ModelInput, Event time, %.2f, GPS sample time, %.2f, distance, %.2f, speed, %.2f, altitude, %.2f
Act Dur(s), %.2f, Step Dur(s), %.2f, Step Counts, %d, Step Begin, %.2f, Step End, %.2f, distance, %.2f, Speed, %.2f, Grade type, %d, vertical speed, %.2f, HR, %f, HRConf, %f, coarse elevation, %d
void CLNatalieModelInput::updateBodyMetrics(const CLBodyMetrics &)
ModelInput,gender,%d,height,%f,weight,%f,vo2max,%f,age,%f,hrmin,%f,hrmax,%f,hronset,%f,pal,%f,condition,%d,runVo2max,%f,betaBlockerUse,%d,biologicalSex,%d,isAgeSet,%d,isHeightSet,%d,isWeightSet,%d,adaptiveEMThresh,%f
static CLHKBiologicalSex CLNatalieModelInput::intToBiologicalSex(int)
Unsupported CLHKBiologicalSex value: %{private}d
Direct_deprecated
HARMAN
MIB2
CLU4_MMX2_VW
CLU4_MMX2_SK
CLU4_MMX2_SE
+[CLAccessoryObserverHelper isDenyListAccessory:name:model:serialNumber:firmware:hardwareRevision:]
Rejecting accessory on deny list: HARMAN
VOLKSWAGEN AG
MIB STD
1.0.0
EP.2015.1
Rejecting accessory on deny list: Volkswagen AG, 1.0.0
SKODA AUTO a.s.
SEAT S.A.
2.0.0
Rejecting accessory on deny list: Volkswagen AG, 2.0.0
BENTLEY
AISIN
CLU5_
Rejecting accessory on deny list: BENTLEY
GpsAccessory
https://gs-loc.apple.com/clls/wloc
-[ALSLocationDelegate requester:didReceiveResponse:forRequest:]
@AlsFlow, reply, tag, %{public}d, wifi, rtt, %{public}.1f, aps, %{public}lu, type, %{public}d
cdma
scdma
multiple
@AlsFlow, reply, tag, %{public}d, cell, rtt, %{public}.1f, %{public}s, %{public}d
didReceiveResponse
-[ALSLocationDelegate requester:didReceiveResponse:forRequest:]_block_invoke
AlsCell, cdma, rx, %{public}lu
AlsCell, cdma, %{public}d, unknown, %{private}s
AlsCell, cdma, %{public}d, valid, %{private}s, location, %{private}s
AlsCell, lte, rx, %{public}lu
AlsCell, lte, %{public}d, unknown, %{private}s
AlsCell, lte, %{public}d, valid, %{private}s, location, %{private}s
AlsCell, nr, rx, %{public}lu
AlsCell, nr, %{public}d, unknown, %{private}s
AlsCell, nr, %{public}d, valid, %{private}s, location, %{private}s
AlsCell, gsm, unbatched, %{public}lu
AlsWifi, unbatched, %{public}lu
-[ALSLocationDelegate requesterDidFinish:]
Unknown pbrequester object received in delegate callback
requesterDidFinish
AlsRequester, didFinish, payload, %lu, outstanding, %ld
-[ALSLocationDelegate requester:didFailWithError:]
@AlsFlow, reply, tag, %{public}d, error, rtt, %{public}.1lf, code, %{public}ld
query: received error for unknown requester type (tag %{public}d)
didFailWithError
AlsRequester, didFailWithError, code, %s, outstanding, %ld
-[ALSLocationDelegate finished:]
AlsRequester, finished, outstanding, %ld
-[ALSLocationDelegate processCells:inRange:timeReceived:requestType:tag:]
AlsCell, gsm, rx, %{public}lu
-[ALSLocationDelegate processCells:inRange:timeReceived:requestType:tag:]_block_invoke
AlsCell, gsm, %{public}lu, unknown, %{private}s
AlsCell, gsm, %{public}lu, valid, %{private}s, location, %{private}s
-[ALSLocationDelegate processScdmaCells:inRange:timeReceived:requestType:tag:]
AlsCell, scdma, rx, %{public}lu
-[ALSLocationDelegate processScdmaCells:inRange:timeReceived:requestType:tag:]_block_invoke
AlsCell, scdma, %{public}lu, unknown, %{private}s
AlsCell, scdma, %{public}lu, valid, %{private}s, location, %{private}s
-[ALSLocationDelegate processWireless:inRange:timeReceived:requestType:tag:surroundingWifiBands:]
AlsWifi, rx, %{public}lu
AlsWifi, unknown, %{private}s, %{public}lu, hasInfoMask, %{public}d, infoMask, 0x%{public}x
AlsWifi, valid, location, %{private}s, %{public}lu, %{private}s, score, %{public}d, channel, %{public}d, alt, %{public}.2lf, reach, %{public}d, hasInfoMask, %{public}d, infoMask, 0x%{public}x, type, %{public}d
AppleLocationServer
AppleLocationServerTimeout
AppleLocationServerRequestLog
AppleLocationServerResponseLog
CLNetworkLocationRequesterALS::CLNetworkLocationRequesterALS(const CLNetworkLocationRequester::Listener &, id<CLIntersiloUniverse>, std::unique_ptr<CLINetworkLocationRequesterALSExternal>)
AlsInit, server, %{private}s, override, %{public}d, timeout, %{public}d, log request/response, %{public}d, %{public}d
final
virtual int CLNetworkLocationRequesterALS::queryLocation(const CLDaemonLocation &, int)
query: queryLocation, location, %14.8lf, %14.8lf, timeout, %d
CLAppleLocationServiceNearbyRequestWifiBands
CLAppleLocationServer
Connection
close
queryLocation
query: queryLocation, tag, %d, location, %14.8lf, %14.8lf, timeout, %d, payload, %lu, reachability, %d, bands, %{public}@
@AlsFlow, request, tag, %{public}d, location, %{private}0.2lf, %{private}0.2lf, server, %{private}s, override, %{public}d, reach, %{public}d, watch, %{public}d
virtual int CLNetworkLocationRequesterALS::unifiedQuery(const std::vector<CLTelephonyService_Type::Cell> &, const std::vector<CLTelephonyService_Type::ScdmaCell> &, const std::vector<CLTelephonyService_Type::CdmaCell> &, const std::vector<CLTelephonyService_Type::LteCell> &, const std::vector<CLTelephonyService_Type::NrCell> &, const std::vector<CLMacAddress> &, const CLNetworkLocationRequest_Type::CLNetworkLocationRequestConfig &, int)
AlsWifi, tx, %{public}lu, %{public}lu, surronding, %{public}d, max, %{public}d
@AlsFlow, server, %{private}s, tag, %{public}d, override, %{public}d, reach, %{public}d, watch, %{public}d
unifiedQuery
@AlsFlow, request, tag, %{public}d, wifi, %{public}lu, surrounding, %{public}lu, bands, %{public}@
@AlsFlow, request, tag, %{public}d, cell, gsm, %{public}lu, lte, %{public}lu, cdma, %{public}lu, nr, %{public}lu, surrounding, %{public}lu
ALSLocationRequest *CLNetworkLocationRequesterALS::createUnifiedQueryRequest(const std::vector<CLTelephonyService_Type::Cell> &, const std::vector<CLTelephonyService_Type::ScdmaCell> &, const std::vector<CLTelephonyService_Type::CdmaCell> &, const std::vector<CLTelephonyService_Type::LteCell> &, const std::vector<CLTelephonyService_Type::NrCell> &, const std::vector<CLMacAddress> &, const CLNetworkLocationRequest_Type::CLNetworkLocationRequestConfig &)
AlsCell, query, cdma, %{public}lu, gsm, %{public}lu, scdma, %{public}lu, lte, %{public}lu, nr, %{public}lu, max, %{public}d
#Warning query: don't have derivedMcc - using %d
query: Adding single derivedMcc %d
query: Adding multi derivedMcc %d
AlsCell, cdma, query, %{public}d, key, %{private}s
AlsCell, cdma, dropping, %{public}u, key, %{private}s, #CloneMe
AlsCell, gsm, query, %{public}d, key, %{private}s
AlsCell, gsm, dropping, %{public}u, key, %{private}s, #CloneMe
AlsCell, scdma, query, %{public}d, key, %{private}s
AlsCell. scdma, dropping, %{public}u, key, %{private}s, #CloneMe
AlsCell, lte, query, %{public}d, key, %{private}s
AlsCell. lte, dropping, %{public}u, key, %{private}s, #CloneMe
AlsCell, nr, query, %{public}d, key, %{private}s
AlsCell. nr, dropping, %{public}u, key, %{private}s, #CloneMe
AlsWifi, query, %{private}s, %{public}d
AlsWifi, dropping, %{private}s, %{public}u, #CloneMe
k2dot4GHZ
k5GHZ
fListener.silo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Network/CLNetworkLocationRequester.h
onCellLocationSeries
 MCC=
 Derived=
 AND SID=
 AND NID=
 AND BSID=
 AND ZONEID=
 AND PNOFFSET=
 AND RSCP=
 AND ECN0=
 AND BANDCLASS=
 AND CHANNEL=
 AND SectorID='
Network
onLocationError
onNearbyError
onFinished
onWifiLocationSeriesComplete
virtual int CLNetworkLocationRequester::unifiedQuery(const std::vector<CLTelephonyService_Type::Cell> &, const std::vector<CLTelephonyService_Type::ScdmaCell> &, const std::vector<CLTelephonyService_Type::CdmaCell> &, const std::vector<CLTelephonyService_Type::LteCell> &, const std::vector<CLTelephonyService_Type::NrCell> &, const std::vector<CLMacAddress> &, const CLNetworkLocationRequest_Type::CLNetworkLocationRequestConfig &, int)
Unimplemented CDMA NetworkLocationRequester
virtual int CLNetworkLocationRequester::queryLocation(const CLDaemonLocation &, int)
nearby data query not supported
Band Class 
BSID 
RAT 
CellType 
Channel 
MCC 
MNC 
NID 
PN offset 
SID 
Zone ID 
Sector ID 
ltmOffset 
dayLightSaving 
derivedMccNum 
derivedMCC 
%03d,%03d,0x%x,0x%x
 AND MNC=
 AND TAC=
 AND CI=
 AND UARFCN=
 AND PID=
 AND BANDINFO=
 AND DEPLOYMENTTYPE=
 AND BANDWIDTH=
 AND NRARFCN=
 AND SCS=
 AND GSCN=
onResponse
static double CLLocationCalculator::calculateWifiVerticalAccuracy(const std::vector<WifiAccessPoint> &, double)
WifiCalc, zaxis, calculate uncertainty, empty accessPointWithWeights
WifiCalc, zaxis, calculate uncertainty, num accessPointWithWeights, %{private}d
WifiCalc, zaxis, calculate uncertainty, accessPointsWithValidWeights is empty
WifiCalc, zaxis, calculate uncertainty, num accessPointsWithValidWeights, %{private}d
WifiCalc, zaxis, calculate uncertainty, dSumWeightV, %{private}.2f, dSumWeightVSquare, %{private}.2f, dSumWeightedDeviation, %{private}.2f, altVarianceDivisor, %{private}.2f
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Utilities/CLLocationCalculator.mm
values.size() == weights.size()
static double CLLocationCalculator::findWeightedMedian(const std::vector<double> &, const std::vector<double> &)
values.size() > 0
static bool CLLocationCalculator::detectMultiModalDistribution(const std::vector<WifiAccessPoint> &)
WifiCalc, zaxis, MultiModal, detection failed
WifiCalc, zaxis, MultiModal, detected, max cluster centers, %{public}0.3f, %{public}0.3f, max weight, %{public}0.3f
static void CLLocationCalculator::rejectOutlierAltitudes(const std::vector<WifiAccessPoint> &, std::vector<WifiAccessPoint> &)
WifiCalc, zaxis, reject outlier, num input accessPointWithWeights, %{private}d
WifiCalc, zaxis, reject outlier, accessPointsWithValidWeights is empty
WifiCalc, zaxis, reject outlier, num accessPointsWithValidWeights, %{private}d
WifiCalc, zaxis, reject outlier, medianAltitude, %{private}.2f, maxDeviationFromMedian, %{private}.2f, maxNumApsToReject, %{private}.1f, maxWeightsToReject, %{private}.2f
static std::map<std::string, int> CLLocationCalculator::filterWifiApsBasedOnRssiCriteria(const std::map<std::string, int> &, bool &)
WifiCalc, zaxis, all aps filtered out due to weak rssi, add them back to yield a fix
static std::vector<CLWifiAPLocation> CLLocationCalculator::filterWifiApsBasedOnVerticalUncCriteria(const std::vector<CLWifiAPLocation> &, bool &)
WifiCalc, zaxis, num input aps, %lu, num valid unc aps, %lu
WifiCalc, zaxis, validUncApCollection is empty
WifiCalc, zaxis, all aps were non-slam, add them back to yield a fix
static void CLLocationCalculator::calculateWifiCentroidAltitude(const std::map<std::string, int> *, const std::vector<CLWifiAPLocation> &, double &, double &, CFAbsoluteTime, int &, double &, bool &, unsigned int &, CLLocationCalculator::ZaxisDebuggingData &)
WifiCalc, zaxis, apCollection is empty
WifiCalc, zaxis, validRssiApCollection is empty
@WifiCalc, zaxis, num accessPointsToUseInCalculation, %{private}lu
WifiCalc, est, %{private}0.3f, vunc, %{public}0.1f, numInputAps, %lu, numApsUsed, %lu, isSLAM, %d
WifiCalc, zaxis, isMultimodal, %{private}d
WifiCalc, zaxis, num aps after outlier rejection, %lu
WifiCalc, zaxis, maxRssi, %d
calculateWifiCentroidRssiMaxreach
CLLocationCalculator.mm
allScannedWifiApsMacToRssiVertical->size() >= apCollectionVertical.size()
static void CLLocationCalculator::calculateWifiCentroidRssiMaxreach(const std::map<std::string, int> *, const std::vector<CLWifiAPLocation> &, const std::vector<CLWifiAPLocation> &, unsigned int, unsigned int, unsigned int, double, unsigned int &, unsigned int &, double &, const CLDaemonLocation &, CLDaemonLocation &, CFAbsoluteTime, int &, double &, bool &, unsigned int &, CLLocationCalculator::ZaxisDebuggingData &, double)
WifiCalc, zaxis, inf unc
WifiCalc, zaxis, invalid signleshot alt, %{private}.2f, unc, %{private}.2f
WifiCalc, zaxis, invalid vertical accuracy!
static void CLLocationCalculator::calculateWifiCentroidLatLon(const std::vector<CLWifiAPLocation> &, unsigned int, unsigned int, unsigned int, double, unsigned int &, unsigned int &, double &, const CLDaemonLocation &, CLDaemonLocation &, CFAbsoluteTime, double)
#Warning WIFI_LOC: filtered by location hint, ap, %s, hint, %s
#Warning WIFI_LOC: revert hint, %lu, %lu
WifiCalc, b360repr, min, %{public}.1lf, max, %{public}.1lf
WifiCalc, outlieriter, %{public}d, dropped, %{public}d, verified, %{public}d
WifiCalc, counts, %{public}ld, %{public}ld, %{public}ld, %{public}ld, verified, %{public}d, hint, %{public}.1f, %{public}d
WifiCalc, invalid estimatedWorstCaseErrorMeters, estimatedWorstCaseErrorMeters, %{public}0.1f, hunc, %{public}0.1f, #Warning
WifiCalc, est, %{public}.1f, %{private}0.3f, %{private}0.3f, hunc, %{public}0.1f, estWorstError, %{public}0.1f, n, %{public}d, x, %{public}d
WifiCalc, b360repr, %{private}14.8lf, %{private}14.8lf
Altitude
VerticalAccuracy
Course
Confidence
Score
Reach
ClearDatabaseTablesByAge
void CLLocationDatabase::prepareStatements()
#Warning Overriding clear tables by age to %d for %s
 WHERE rowid=
bool CLLocationDatabase::getLocation(const sqlite3_int64 &, CLDaemonLocation &) const
could not bind
Could not prepare cached insert statement
could not bind %.3f <%+.8f,%+.8f> %.2f
UPDATE OR REPLACE 
=?, 
bool CLLocationDatabase::setLocation(const sqlite3_int64 &, const CLDaemonLocation &)
Could not prepare cached update statement
failed to setLocation, numModRows, %d, %s
bool CLLocationDatabase::clearLocation(const sqlite3_int64 &)
Can't clear location for read-only database
could not bind %{public}lld
static void CLLocationDatabase::clearLocations(CLSqliteDatabase &, const CLSqliteDatabase::SqliteProperties &, const std::string &)
Can't clear locations in read-only database
static void CLLocationDatabase::clearLocationsByAge(const CFTimeInterval &, CLSqliteDatabase &, const CLSqliteDatabase::SqliteProperties &, const std::string &)
Can't clear locations by age in read-only database
 < ? OR 
 > ?
Clearing locations older than %.3f from %s
%lld total entries deleted
Performing incremental vacuum on %s
VO2MaxHistory
DELETE FROM VO2MaxHistory WHERE estimatedVo2Max IS NULL OR startTime < ?
SELECT * from VO2MaxHistory ORDER BY id ASC
VO2MaxHistory, DB not accessible
CMError CLVO2MaxOutputRecorderDb::querySinceTime(CFAbsoluteTime, std::vector<VO2MaxOutput> &, bool, int) const
SELECT * FROM VO2MaxHistory WHERE estimatedVo2Max IS NOT NULL AND eligibleForHealthKit = 1 AND startTime > ? ORDER BY startTime DESC LIMIT ?
SELECT * FROM VO2MaxHistory WHERE estimatedVo2Max IS NOT NULL AND startTime > ? ORDER BY startTime DESC LIMIT ?
CMError CLVO2MaxOutputRecorderDb::queryBySessionId(unsigned char *, std::vector<VO2MaxOutput> &) const
SELECT * from VO2MaxHistory WHERE sessionId = ?
SELECT COUNT(*) FROM VO2MaxHistory
DELETE FROM VO2MaxHistory
DELETE FROM VO2MaxHistory WHERE startTime > ?
UPDATE VO2MaxHistory SET startTime = startTime + ?
SELECT * FROM VO2MaxHistory ORDER BY id DESC LIMIT 1
ALTER TABLE VO2MaxHistory ADD COLUMN 
UPDATE VO2MaxHistory SET 
 = 1;
CLActivityRecorderDb<VO2MaxOutput>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxOutput>::setDatabaseAccessible() [T = VO2MaxOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxOutput>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxOutput>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CMGyroBiasEstimator::reset(const uint64_t)
CMGyroBiasEstimator::reset: cold start
CMGyroBiasEstimator::reset: warm start [%f < %f]
CMGyroBiasEstimator::reset: dbias.x,%.2e,.y,%.2e,.z,%.2e,P.x,%.2e,.y,%.2e,.z,%.2e
virtual void CMGyroBiasEstimator::biasFitReset()
CMGyroBiasEstimator: biasFitReset
void CMGyroBiasEstimator::notifyClients(uint64_t)
CMGyroBiasEstimator::feedGyro: converged!
const CMVector<T, N> CMVectorBufferBase<float, 3>::variance(size_t, size_t) const [T = float, N = 3]
Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 210,variance() on empty buffer.
T &CMVector<unsigned long long, 3>::operator[](const size_t) [T = unsigned long long, N = 3]
CLTimeZoneDatabase
bool CLTimeZoneDatabase::getTimeZoneAndDistance(const CLDaemonLocation &, std::string &, double &)
Couldn't get time zone for point <%+.8f,%+.8f>
Point <%+.8f,%+.8f> not in any time zone polygon; closest polygon is %f meters away; default time zone is %s, but we're not using it
Not in any polygons; falling back to closest nearby time zone ID %lld (distance %f, %ld possibilities)
Point <%+.8f,%+.8f> not in any time zone polygon; default time zone is %s, but we're not using it
#Warning Point <%+.8f,%+.8f> in multiple time zone polygons
Could not get time zone name for zone ID %{public}lld
CLBarometerCalibrationSource.mm
Expected delegate to conform to CLBarometerCalibrationSourceClient
zoneIdentifier
authMask
correctiveCompensationMask
zoneType
latitude
longitude
radius
phenolicLocation
serviceMaskOperator
provenance
clearClient
-[CLCompanionSyncInterestZone writeTo:]
CLCompanionSyncInterestZone.m
nil != self->_zoneIdentifier
BoundingBoxes
MinimumLatitude
MaximumLatitude
MinimumLongitude
MaximumLongitude
Names
ZoneName
Points
ZoneID
PointID
properties.readOnly
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Utilities/CLPolygonDatabase.mm
CLPolygonDatabase
bool CLPolygonDatabase::polygonsAndDistancesForPointWithUncertainty(const double &, const double &, const double &, std::vector<std::pair<sqlite3_int64, double>> &, const bool &)
Couldn't get list of candidates for point <%+.8f,%+.8f>
Couldn't determine if point <%+.8f,%+.8f> is in polygon %lld
bool CLPolygonDatabase::polygonCandidatesForPointWithUncertainty(const double &, const double &, const double &, std::vector<sqlite3_int64> &)
Getting polygons for point <%+.8f,%+.8f> acc %.2f
#Warning fBoundingBoxesSelectNearbyStatement not available - rtree module missing or db unavailable
#Warning Ignoring bogus location <%+.8f,%+.8f>
Could not bind <%+.8f,%+.8f> - <%+.8f,%+.8f>
bool CLPolygonDatabase::getPolygonName(const sqlite3_int64 &, std::string &)
#Warning fNamesSelectStatement not available - rtree module missing or db unavailable
Could not bind %{public}lld
Could not get polygon name
#Warning No entry in names table for polygon ID %lld
bool CLPolygonDatabase::getPolygonId(const std::string &, sqlite3_int64 &)
#Warning fNamesSelectOnNameStatement not available - rtree module missing or db unavailable
#Warning Could not bind %s
#Warning Polygon %s not found in names table
bool CLPolygonDatabase::polygonsForName(const std::string &, std::vector<sqlite3_int64> &)
bool CLPolygonDatabase::pointInPolygon(const std::string &, const double &, const double &, bool &, double &)
#Warning No bounding box found for polygon %s
bool CLPolygonDatabase::pointInPolygon(const sqlite3_int64 &, const double, const double, bool &, double &)
#Warning fPointsSelectStatement not available - rtree module missing or db unavailable
#Warning Could not bind %lld
#Warning No points data found for polygon Id %lld
 ORDER BY 
>=? AND 
<=? AND 
bool CLPolygonDatabase::getPolygonBoundingBox(sqlite3_int64 &, double &, double &, double &, double &)
#Warning fBoundingBoxesSelectStatement not available - rtree module missing or db unavailable
#Warning Could not bind polygon ID %lld
#Warning No bounding box found for polygon ID %lld
fForceAssistedCyclingOverrideToTrue
virtual CLMetsInfo CLNatalieDummyModel::computeMETS(const CLNatalieModelInput &)
Dummy, Static, step count: %d, step distance: %f, activity: %d, type: %d, vm: %f
CLTimeManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/TimeManager/CLTimeManager.mm
-[CLTimeManagerAdapter beginService]
CLTimeManager
Sending along GPS time %.2f to CoreTime
void CLTimeManager::setGpsTime(uint64_t)
virtual void CLNotifier<CLTimeManager_Type::Notification, CLTimeManager_Type::NotificationData>::removeClient(int) [Notification_T = CLTimeManager_Type::Notification, NotificationData_T = CLTimeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTimeManager_Type::Notification, CLTimeManager_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLTimeManager_Type::Notification, NotificationData_T = CLTimeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTimeManager_Type::Notification, CLTimeManager_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLTimeManager_Type::Notification, NotificationData_T = CLTimeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTimeManager_Type::Notification, CLTimeManager_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLTimeManager_Type::Notification, NotificationData_T = CLTimeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLTimeManager_Type::Notification, CLTimeManager_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLTimeManager_Type::Notification, NotificationData_T = CLTimeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLTimeManager_Type::Notification, CLTimeManager_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLTimeManager_Type::Notification, NotificationData_T = CLTimeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLTimeManager_Type::Notification, CLTimeManager_Type::NotificationData>::listClients() [Notification_T = CLTimeManager_Type::Notification, NotificationData_T = CLTimeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
LocationController
CLLocationControllerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/LocationController/CLLocationController.mm
-[CLLocationControllerAdapter beginService]
-[CLLocationControllerAdapter emergencyStateChange:]
-[CLLocationControllerAdapter setRealTimeHarvestTriggered:]
BaroAlt,Realtime harvest,not supported
controller
CLLocationController::CLLocationController(id<CLIntersiloUniverse>)
buildCFAbsoluteTime,%{public}.0f
RescalePipelinedRadiusForComparisonOnly
DynamicLocationProviders
ForcedHorizontalAccuracy
DisableIntegrityMonitoring
Integrity Monitoring is Disabled
GpsWifiKeepAlive
GpsWifiKeepAlive is no longer supported! If you want to leave all providers actively subscribed to, set DynamicLocationProviders to false
UseLocationKFAsDefaultProvider
UseLocationKFAsDefaultProvider is set
EnableMapMatching
CLMM,EnableMapMatching,%{public}d
ForceMapMatching
CLMM,ForceMapMatching,%{public}d
GpsConformanceTestMode
Warning: Conformance mode is enabled, this disables client based GPS applications.
GPS Conformance Mode
NotifyAllLocations
dynamic location providers,%{public}d,accuracy,%{public}.2f,gps test mode,%{public}d,always notify,%{public}d
UseKfWhenSimulationActive
Applying KF to simulated locations for internal testing
location derived speed estimator enabled,%{public}d
could not create tech status run loop source
could not create check active run loop source
CLHarvesterService
virtual bool CLLocationController::registerForNotification(int, const CLLocationProvider_Type::Notification &)
#wigo,on,CLLocationController,%{public}d,%{public}s
virtual bool CLLocationController::registerForNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::RegInfo &)
#wigo,on,LocationController,%{public}d,%{public}s
virtual bool CLLocationController::registerForNotificationInternal(const CLLocationProvider_Type::Notification &)
CLIENT:registerForNotificationInternal,notification,%{public}d,%{public}s,granularity,%{public}d
Before register,required granularity,%{public}d,active granularity,%{public}d
BATCH:unsupported platform
CLMM,RunMapMatching is turned on
registering notification,%{public}d,location provider,%{public}s
@WsbReg, kNotificationWifiLocationBatched unsupported
CLIENT:registerForNotificationInternal,propagate,desiredAccuracy,%{public}.1lf,name,%{public}s,active,%{public}d,operating mode,%{public}d
virtual bool CLLocationController::unregisterForNotificationInternal(const CLLocationProvider_Type::Notification &)
CLIENT:unregisterForNotificationInternal,notification,%{public}d,%{public}s,granularity,%{public}d
Unregistered for notification,%{public}d,new required location granularity,%{public}d
After unregister,required granularity,%{public}d,active granularity,%{public}d
CLMM,RunMapMatching is turned off
unregistering notification,%{public}d,with,location provider,%{public}s
unregistering notification,%{public}d,location provider,%{public}s
CLIENT:unregisterForNotificationInternal,propagate,desiredAccuracy,%{public}.1lf,name,%{public}s,active,%{public}d
void CLLocationController::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Device going to sleep,stop location unavailable timer
Device wake setting location unavailable timer to fire at %{public}.3f
#Warning,Unhandled status notification,%{public}u
void CLLocationController::onWifiServiceNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
void CLLocationController::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
Local
virtual void CLLocationController::start()
@ClxVersion, Init, os, %{public}s, model, %{private}s, build, %{public}s, triage, %{public}d
CLSimulatedLocationProvider
virtual void CLLocationController::shutdown()
shutting down %{public}s location provider
void CLLocationController::signalTechStatusChanged()
#techstatus,signalling
void CLLocationController::startLocation(const CLLocationController::Granularity &)
Starting all location providers up to threshold,%{public}d,desiredAccuracy,%{public}.1lf
Not starting location provider,%{public}s,fRequiredLocationGranularity,%{public}d,fActiveLocationGranularity,%{public}d
void CLLocationController::stopLocation(const CLLocationController::Granularity &)
Stopping all location providers above threshold %{public}d
void CLLocationController::stopLessDesirableProviders(const CLLocationController::DynamicLocationProvider &, bool)
Stopping all location providers that are worse than kDynamicLocationProvider %{public}d
got better location provider,%{public}d,NOT stopping worse location provider,%{public}d,isAccessorySpecialCase,1
got better location provider,%{public}d,NOT stopping worse location provider,%{public}d
got better location provider,%{public}d,stopping worse location provider,%{public}d
void CLLocationController::restartLessDesirableProviders(const CLLocationController::DynamicLocationProvider &)
lost location from kDynamicLocationProvider,%{public}d,restarting all worse providers
restarting worse location provider kDynamicLocationProvider,%{public}d
void CLLocationController::startLocation(CLLocationController::LocationProvider)
#Warning,startLocation when provider is None
CLIENT:startLocation,registerForNotification,start reg info,client,%{public}p,desiredAccuracy,%{public}.1lf,name,%{public}s
#Warning, starting already active provider
registering location provider,%{public}s,as a bystander only
@ClxProvider, start, %{public}s, desiredAccuracy, %{public}.1f
WlpReg, 1, loccontroller
UclpReg, 1, loccontroller
void CLLocationController::stopLocation(CLLocationController::LocationProvider)
#Warning,stopLocation when provider is None
Unregistering %s location provider as bystander
@ClxProvider, stop, %{private}s, desiredAccuracy, %{public}.1f
WlpReg, 0, loccontroller
UclpReg, 0, loccontroller
void CLLocationController::onLocationUnavailableTimer()
catch-all location unavailable timer fired
Location unavailable timer fired,required granularity is none,ignoring
#Warning,Location unavailable fired while sleeping
bool CLLocationController::notifyLocationUnavailable(CLLocationController::LocationProvider)
could not find provider from list
Got location unavailable notification for non-active provider,%{public}s,ignoring
Got location unavailable notification for location provider,%{public}s
provider,%{public}s,still available,lat,%{private}.7lf,lon,%{private}.7lf,lifespan,%{public}.1lf,age,%{public}.3fs
No location is available from any provider,notifying clients
bool CLLocationController::shouldUseWifiWhileGpsConverging(const CFAbsoluteTime, const ProvidersMap::iterator, const ProvidersMap::iterator) const
Ignored: GPS warmup,runtime,%{public}.1fs,thresh,%{public}.1fs,age,%{public}.1fs,thresh,%{public}.1fs,gacc,%{public}.1fm,wacc,%{public}fm
bool CLLocationController::shouldNotify(CFAbsoluteTime, CLLocationController::LocationProvider, const CLLocationProvider_Type::NotificationData &)
#Warning,shouldNotify when provider is None
Got,lat,%{private}.7f,lon,%{private}.7f,for non-active location provider,%{public}s,ignoring
#Warning,Got future,lat,%{private}.7f,lon,%{private}.7f,from provider,%{public}s,age,%{public}.3fs,correcting to,%{public}.3fs
expiredLocation,provider,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,age,%{public}.3fs,lifespan,%{public}.1fs
current most confident provider,%{public}s,conf,%{public}d
#Warning,new,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with confident,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,age,%{public}.3f,distance,%{public}.2f,discarding
#Warning,new,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with current,%{public}s lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,notifying
new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,coarser and agrees with current,%{public}s, lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding
#Warning,new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with current,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding
new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,coarser than current,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding
got accessory,stopping everything less preferred,isShifted,%{public}d,isPropagatedSolution,%{public}d
(none)
changing to provider,%{public}s,from,%{public}s
bool CLLocationController::isLocationTypeSupported(CLLocationType)
unsupported location type,%{public}d
bool CLLocationController::notifyLocation(CLLocationController::LocationProvider, const CLLocationProvider_Type::NotificationData &)
location rejected by IM,locationType,%{public}d,lat,%{private}.7lf,lon,%{private}.7lf
location rejected by KF,%{public}d,lat,%{private}.7lf,lon,%{private}.7lf
CL-filtered
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,LocationTimestamp,%.3f,Age,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,SpeedAccuracy,%.3f,CourseAccuracy,%.1f,timestampGps,%.3lf,integrity,%d,referenceFrame,%d,rawReferenceFrame,%d
#Warning not notifying location with location derived speed
Notifying using location KF,but no location available
CL-mapmatched
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,LocationTimestamp,%.3f,Age,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,SpeedAccuracy,%.3f,CourseAccuracy,%.1f,timestampGps,%.3lf,integrity,%d
DEM,query,%{private}.7f,%{private}.7f,HorUnc,%{public}.2lf,Type,%{public}d,%{public}s,Alt,%{private}.2f,AltUnc,%{public}.2f,GroundAlt,%{public}.2lf,GroundAltUnc,%{public}.2lf,Undulation,%{private}.3lf,UndulationModel,%{public}d,
@ClxClient, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, speed, %{private}.1f, course, %{private}.1f, type, %{public}d, alt, %{private}.1f, altunc, %{public}.1f,ellipsoidalAlt,%{private}.1f,speedUnc,%{private}.1f,courseUnc,%{private}.1f,signalEnv,%{private}d,timestamp,%{public}.3f
client, null
ClxMetric, islands, %{private}s, %{private}s
com.apple.clx.islands
provider
flow
island
null
client, sentinel
sentinel
CLLoiLocationProvider
void CLLocationController::onEmergencyStateChange(CLEmergencyState)
BaroAlt,LocCtrlOnEmergencyStateChange,isEmergency,%{public}d
void CLLocationController::publishPropagatedCoordinates(CLLocationProvider_Type::NotificationData &)
%{public}.1lf,DeadReckoning,%{public}s,%{public}.2lf,Propagating solution,lastGPSTime,%{public}.2lf,lastAccessoryTime,%{public}.2lf
virtual void CLLocationController::notifyClientsWithData(const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &, bool, int, bool)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,LocationTimestamp,%.3f,Age,%.3f,timestampGps,%.3lf,floor,%d,SpeedAccuracy,%.3lf,CourseAccuracy,%.1lf,integrity,%d,rawLat,%.7lf,rawLon,%.7lf,rawCourse,%.2f,refFrame,%d,rawRefFrame,%d,propagated,%d,gnssContent,%d,signalEnv,%d
#Warning,Notifying clients of an already-expired location,age,%{public}.3f
void CLLocationController::gpsOdometerHelper(const CLLocationProvider_Type::NotificationData &)
GPSODOM,timestamp,%{public}.3lf,timestampGps,%{public}.3lf,odometer,%{public}.3lf,deltaDist,%{public}.3lf,deltaDistUnc,%{public}.3lf,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.1lf,alt,%{private}.3lf,vunc,%{public}.1lf,speed,%{public}.3lf,sunc,%{public}.3lf,course,%{public}.3lf,cunc,%{public}.3lf
CL-unfiltered
void CLLocationController::notifyUnfilteredLocation(const CLLocationProvider_Type::NotificationData &)
CL-prefiltered
void CLLocationController::notifyPrefilteredLocation(const CLLocationProvider_Type::NotificationData &)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%{public}d,%{public}s,Speed,%{public}.2f,Course,%{public}.2f,Confidence,%{public}d,Lifespan,%{public}.3f,LocationTimestamp,%{public}.3f,Age,%{public}.3f,Altitude,%{private}.3f,AltitudeAccuracy,%{public}.3f,SpeedAccuracy,%{public}.3f,CourseAccuracy,%{public}.1f,timestampGps,%{public}.3lf,integrity,%{public}d,undulation,%{private}.3lf,undulationModel,%{public}d,referenceFrame,%d,rawReferenceFrame,%d
void CLLocationController::onAccessoryNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
Accessory,propagated on-device GPS,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.1lf
bool CLLocationController::getActiveTechs(std::set<int> &)
Wifi2 provider active, but pipelined not activated
Indoor provider active, but pipelined not activated
GPSController indicates hardware active while client is not active
#techstatus,enquired,sz,%{public}zu,gpsClientActive,%{public}d,gpsHwActive,%{public}d
virtual void CLLocationController::setSimulationEnabled(bool)
Setting simulation to %{public}d for all location providers
void CLLocationController::sendTechStatusNotification()
#techstatus,posting notification
void CLLocationController::checkActiveProviders()
Notifying clients of providers active update to %{public}d
void CLLocationController::clearAllLocationData()
#Warning,Clearing all location data from the controller
void CLLocationController::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
#Warning,Location Services reset,clearing local cache
@ClxNotify, LpReset, 0
#Warning,Location Services state changed,clearing local cache
float CLLocationController::getDesiredAccuracy()
CLIENT:hasClients,%{public}d,hasFineClients,%{public}d,hasCoarseClients,%{public}d,desiredAccuracy,%{public}.1lf
void CLLocationController::handleStateEvent(NegativeEvent, bool)
@ClxEvent, %{public}s, %{public}d, delta, %{public}.1f
void CLLocationController::checkStateLogging()
@ClxVersion, Timer, os, %{public}s, model, %{private}s, build, %{public}s, triage, %{public}d
@ClxSnapshot, %{public}s, %{public}d, last, %{public}.1f, delta, %{public}.1f
void CLLocationController::predictedGnssAvailabilityCallback(const CLGnssAvailabilityPredictor::Output &)
CLLocationController,gnssPredictedAvailability,%{public}d,probability,%{public}.3f,timestamp,%{public}.3f
CLLocationController::onStatusNotification
CLLocationController::onWifiServiceNotification
CLLocationController::onClientNotification
CLLocationController::onDataProtectionNotification
CLLocationController::onBluetoothNotification
CLLocationController::onCompanionNotification
CLLocationController::sendTechStatusNotification
CLLocationController::checkActiveProviders
WifiOff
ApSleep
Locked
NoReach
Unassociated
Airplane
ToggleOff
BatterySaver
BtOff
BtDisconnect
CGApart
CLLocationController::onWifiNotification
CLLocationController::onAccessoryNotification
CLLocationController::onSimulatedNotification
CLWifiLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/CLWifiLocationProvider.mm
-[CLWifiLocationProviderAdapter beginService]
-[CLWifiLocationProviderAdapter emergencyStateChange:]
notifier adapter received emergency state %s
+[CLWifiLocationProviderAdapter isSupported]
@ClxWifi, supported, %{public}d
wifi
ClearAls
CLWifiLocationProvider::CLWifiLocationProvider(id<CLIntersiloUniverse>, std::shared_ptr<IExternal>, std::shared_ptr<CLWifiAccessPointLocationService>)
WlpMetric, ClearAls
virtual bool CLWifiLocationProvider::registerForNotificationInternal(const CLLocationProvider_Type::Notification &)
@WifiLogic, entry, register, notification, %{public}s, lsb, %{public}d, %{public}d, %{public}d
@WifiLoc, miscregister, %{public}s
@WifiEntry, register for odometer notification
virtual bool CLWifiLocationProvider::unregisterForNotificationInternal(const CLLocationProvider_Type::Notification &)
@WifiLogic, entry, unregister, notification, %{public}s, lsb, %{public}d, %{public}d, %{public}d
@WifiLoc, miscunregister, %{public}s
@WifiEntry, unregister for odometer notification
@WifiEntry, noregistrants
void CLWifiLocationProvider::onClientTimer()
@WifiLogic, entry, clienttimer
void CLWifiLocationProvider::onWsbTimer()
@WifiLogic, entry, wsbtimer
bool CLWifiLocationProvider::requestLocationUpdate(const CLWifiLocationUpdateRequest &)
@WifiLogic, entry, requestLocationUpdate, %{public}s
void CLWifiLocationProvider::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
@WifiLogic, entry, wifiNotify, %{public}s
void CLWifiLocationProvider::onOdometerNotification(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNotifier_Type::NotificationData &)
@WifiLogic, entry, odometer, %{public}d,
received odometer update entry,startTime,%{public}lf,elevationAscended,%{public}u,elevationDescended,%{public}u,now,%{public}.lf
#Warning,received invalid elevation entry,startTime,%{public}lf,elevationAscended,%{public}u,elevationDescended,%{public}u
void CLWifiLocationProvider::onMotionNotification(int, const CLMotionState_Type::Notification &, const CLMotionState_Type::NotificationData &)
@WifiLogic, entry, motion
void CLWifiLocationProvider::onSignalEnvironmentNotification(int, const CLSignalEnvironmentProvider_Type::Notification &, const CLSignalEnvironmentProvider_Type::NotificationData &)
@WifiLogic, entry, signalEnvironment
void CLWifiLocationProvider::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
@WifiLogic, entry, clientNotify
void CLWifiLocationProvider::onNetworkLocationNotification(int, const CLNetworkLocationProvider_Type::Notification &, const CLNetworkLocationProvider_Type::NotificationData &)
@WifiLogic, entry, alsNotify
void CLWifiLocationProvider::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
@WifiLogic, entry, reach, %{public}d
@WifiLogic, entry, batterysaver, %{public}d
@WifiLogic, entry, wake
@WifiLogic, entry, heartbeat
void CLWifiLocationProvider::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
@WifiLogic, entry, companionnearby, %{public}d
void CLWifiLocationProvider::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
@WifiLogic, entry, locationNotify
void CLWifiLocationProvider::handleEmergencyStateChange(CLEmergencyState)
@WifiLogic, entry, emergencyState
wifi1Event
CLWifiLocationProvider::HandleEventResults CLWifiLocationProvider::handleEvent(CL::Wifi1::Events::EventUnion)
@WifiLogic, handleInput, %{public}s
CLWifiLocationProvider::HandleEventResults CLWifiLocationProvider::handleLogicOutput(CL::Wifi1::Output)
@WifiLogic, decision, newUpdate, didStart, %{public}d
@WsbReproc, reason, %{public}s
@WifiLogic, decision, reprocWsb
@WifiLogic, decision, alsreq
@WifiLogic, decision, alswsb, aps, %{public}lu
normal
default
value of didStartScan being reset to false after successfully beginning a scan
@WifiLogic, decision, scanreq, didStart, %{public}d
ajoffpowon
powoffajon
@WifiLogic, decision, wifipower, %{public}s
@WifiLogic, decision, tiledl, %{private}.02f, %{private}.02f
@WifiLogic, decision, timer, %{public}.1f, reIssue, %{public}d
@WifiLogic, decision, timer, cancel
@WifiLogic, decision, wsbtimer, %{public}.1f
@ClxWifi, Fix, 0, ll, N/A
@WifiLogic, decision, notifyUnavail
WiFi
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Confidence,%d,TTF,%.3f,sinceReg,%.3f,Confirmed,%d,Altitude,%.2f,VerticalAccuracy,%.2lf,locationSimulated,%d,notifiedLocationAge,%f,integrity,%d
@ClxWifi, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, course, -1.0, alt, %{private}.1f, altunc, %{public}.1f, time, %{public}.1f
@WifiLogic, decision, notifyLoc
!batchedLocations.empty()
handleLogicOutput
notifying clients of %{public}ld batched wifi locations
WsbCalc, notify, %{public}lu
@WifiLogic, decision, notifyBatched
void CLWifiLocationProvider::scheduleNextTimer(CFAbsoluteTime, CFTimeInterval)
@WifiFlow, nexttimer, %{public}d
@WifiFlow, nexttimer, off
LOCATION
fIsQueryLocationServer
fIsSlowDownScansWhileAssociated
IsFeedInCPIScans
fIsQueryAllAPs
fIsInjectingScanResults
fIsUseNetworkLocationProvider
IgnoreSignalEnvironment
void errorOnDeprecatedDefaultWrites()
%s is deprecated. setting this has no effect
fWifiScanForcedInterval
fMinIntervalBetweenLocationRequests
fMinIntervalBetweenScanCalculations
fScanTypeStage1
fScanTypeStage2
Position
None
Wifi::ScanReady
Wifi::ScanError
Wifi::ScanBusy
Wifi::Power
Wifi::LinkStatus
Wifi::Roam
Wifi::Scan
Wifi::Wsb
System::Privacy
System::Reachability
System::CoarseMotion
System::BatterySaverMode
System::DeviceWake
System::CompanionNearby
System::SignalEnvironment
System::LeechLocation
System::MetricHeartbeat
System::Elevation
Network::AlsError
Network::AlsFinished
Network::AlsRequestResult
Network::AlsAllUnknown
Client::EmergencyState
Client::LocationRequest
Client::Registration
Client::Unregistration
Client::UpdateTimer
Client::WsbTimer
ReprocessWifiScanBuffer
forced_return
forced_return.hpp
Location_deprecated
static void CLUnifiedCellLocationProviderLogic::computeCellLocation(CLUnifiedCellLocationProviderLogic::ICellLocationProvider *, const char *, const CLCellVector &, const CLDaemonLocation &, const CFAbsoluteTime)
CellFlow, compute, cells, %{public}zu, spectators, %{public}d, last, %{public}.1lf, type, %{public}d
nocells
CellMatch, invalid cell, %{public}s, #CloneMe
CellMatch, ignoring cell, %{private}s
exact
CellMatch, best network, %{public}s, %{private}s, location, %{private}s
CellMatch, best tile, %{public}s, location, %{private}s
network
CellMatch, prefer, %{private}s, %{public}s, levels, %{public}s, %{public}s, als, %{public}d
@CellFlow, match, %{private}s, %{public}s, %{public}s, rat, %{public}s, needsAls, %{public}d
@CellFlow, counts, in, %{public}lu, sortIn, %{public}lu, sortOut, %{public}lu, shouldQuery, %{public}d
CellMatch, preferred cell matches, in ascending order, %{private}s, %{private}s
UclpMetric, fixattempt, %{public}s, %{public}s, %{public}s, acc, %{private}.0f, %{public}s, %{public}s, submit10, %{public}d
com.apple.clx.cellloc.fixattempt
reason
match
CellFlow, fix, %{private}s, acc, %{private}.0f, %{public}s, %{public}s, %{public}s, %{public}s, notify, %{public}d, deploymentType, %{public}d, %{public}s
cell, null
cell, sentinel
reference frame is not properly set
confidence is not properly set
@ClxCell, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, course, -1.0, key, %{private}s, type, %{public}d
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Confidence,%d,Lifespan,%.3f,SubType,%s,MatchLevel,%d,cell,%s,Transmit,%d,integrity,%d
cellMatch
@CellLoc, tiledl, cells, %{public}lu, gsm, %{public}d, cdma, %{public}d, lte, %{public}d
CellLoc, requestDownload, GSM, %.8f, %.8f, seckey, %llu
CellLoc, requestDownload, CDMA, %.8f, %.8f, seckey, %llu
CellLoc, requestDownload, LTE, %.8f, %.8f, seckey, %llu
@ClxCell, Fix, 0, ll, N/A, Unknown, %{private}s, querying, %{public}d
alsquery
nr cell nofix
CellFlow, skipreqwifi, locationclients, %{public}d
recalc
static bool CLUnifiedCellLocationProviderLogic::isAlsQueriable(CLTelephonyService_Type::RadioAccessTechnology)
CellLoc, Invalid rat, %{public}d, %{public}s, #CloneMe
aValid == bValid
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Cell/CLUnifiedCellLocationProviderLogic.mm
aLoc.type == bLoc.type
aCell.isGsmOrCdma() == bCell.isGsmOrCdma()
aCell.isLte() == bCell.isLte()
MotionStateMediator
CLMotionStateOverride
CLMotionStateOverride::CLMotionStateOverride(id<CLIntersiloUniverse>)
Workout, Taking power assertion due to session start.
CLMotionStateOverride::~CLMotionStateOverride()
Workout, Releasing power assertion due to session end.
void CLMotionStateOverride::updateWorkout(const CMWorkoutEvent)
Workout, Releasing power assertion due to a session pause event.
Workout, Taking power assertion due to a session resume event.
ResumeWorkout
CLMotionStateMediatorSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Workout/CLMotionStateMediator.mm
-[CLMotionStateMediatorAdapter beginService]
-[CLMotionStateMediatorAdapter didExitGeoFence]
#gfc didExitGeoFence() received in adapter
-[CLMotionStateMediatorAdapter didTimeoutGeoFence]
#gfc didTimeout() received in adapter
CLMotionStateMediator
ForceOtherWorkoutOverride
ForceWorkoutLocationType
ForceMaxSecondsForWorkoutLocationTypeDisambiguation
EnableForcedWorkoutLocationUpdatesFromSPI
NumAllowedIndoorOutdoorNotificationsPerHour
MuteWorkoutAlertsForSecondsAfterUserDismissal
EnableALSActiveScansAOP
VO2MaxEstimatePowerBudget
SensitiveEscalationPowerAssertion
CLWorkoutPredictor_SensitiveEscalation
CLWorkoutPredictor
com.apple.CoreMotion.WorkoutEscalation
AutoPauseTestHaptic
void CLMotionStateMediator::notifyClients(const CLMotionCoprocessorInterface::NotificationData *, bool)
IndoorOutdoor detector running without turn detector.
void CLMotionStateMediator::startStopDeviceMotionBasedOnWorkout(CLWorkoutPredictor_Type::DeviceMotionToggleInfo)
Enabled device motion.
Disabled device motion.
Starting turn detector
Stopping turn detector
virtual void CLMotionStateMediator::controlWifiScans(bool)
Wifi timer already existed, reinitializing.
Starting Wifi Scans.
virtual void CLMotionStateMediator::controlWifiScans(bool)_block_invoke
Triggering Wifi Scan.
motionworkout
Stopping Wifi Scans.
virtual void CLMotionStateMediator::startIndoorOutdoorSession(const CLIndoorOutdoorProtocol::IndoorOutdoorSettings &)
IndoorOutdoor, starting indoorOutdoor
virtual void CLMotionStateMediator::stopIndoorOutdoorSession()
IndoorOutdoor, stopping indoorOutdoor
virtual void CLMotionStateMediator::onIndoorOutdoorUpdate(const CLIndoorOutdoorProtocol::IndoorOutdoorEvent &, bool)
IndoorOutdoor,new location type,%{public}ld,confidence,%{public}ld,probability,%{public}f
void CLMotionStateMediator::issueUserNotificationForIndoorOutdoorIfAllowed(CLMotionStateMediator_Type::IndoorOutdoorUpdate, CLMotionStateMediator_Type::IndoorOutdoorUpdate)
IndoorOutdoor, issuing notification old (%s, %s) new (%s, %s)
Old indoor/outdoor state
%s, %s, %s New
%s, %s, %s
IndoorOutdoorState
Indoor
Outdoor
Medium
High
void CLMotionStateMediator::addClientForPrepareSessionEnd(id<CLMotionStateMediatorClientProtocol>, CMWorkoutType)
Workout, Receiving addClientForPrepareSessionEnd after client list has been deleted!
void CLMotionStateMediator::removeClientForPrepareSessionEnd(id<CLMotionStateMediatorClientProtocol>, CMWorkoutType)
Workout, Receiving removeClientForPrepareSessionEnd after client list has been deleted!
Workout, Client for PrepareSessionEnd of session type %d does not exist!
void CLMotionStateMediator::prepareForSessionEnd(CMWorkoutType)
Workout, Prepared session client, end for session, %d, duration (s), %f, success, %d
void CLMotionStateMediator::overrideActivity(CLMotionStateMediator_Type::WorkoutSettings)
#gfc started workout, starting geofence with radius %{public}f
void CLMotionStateMediator::clearActivityOverride(CLMotionStateMediator_Type::WorkoutSettings)
#gfc stopped workout, stopping geofence
void CLMotionStateMediator::setWorkoutSuggestedStopTimeout(CFTimeInterval)
Workout,Setting suggested stop timeout for workout,%f
void CLMotionStateMediator::userDismissedWorkoutAlert()
User dismissed current workout alert.
void CLMotionStateMediator::didExitGeoFence()
#gfc didExit recieved in msm, stopping, current workout in session %{public}d
void CLMotionStateMediator::didTimeoutGeoFence()
#gfc didTimeout recieved in msm, stopping, current workout in session %{public}d
Workout Detected (
walk.falsePositive
walk.total
run.falsePositive
run.total
other.falsePositive
other.total
cycling.falsePositive
cycling.total
unsupported.falsePositive
unsupported.total
void CLMotionStateMediator::onWorkoutPredictorUpdate(CLWorkoutPredictor_Type::Notification, CLWorkoutPredictor_Type::NotificationData)
Unsupported escalation type reported for metrics, %d
void CLMotionStateMediator::onOdometerNotification(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNotifier_Type::NotificationData &)
MotionStateMediator received unhandled odometer notification, %d
void CLMotionStateMediator::onWatchOrientationSettingsNotification(int, const CLWatchOrientationSettingsNotifier_Type::Notification &, const CLWatchOrientationSettingsNotifier_Type::NotificationData &)
Watch orientation settings updated,crown,%{public}d,wrist,%{public}d
void CLMotionStateMediator::onDaemonStatus(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Battery connected state %{public}d
onDaemonStatus
void CLMotionStateMediator::onMotionStateObserverNotification(int, const CLMotionStateObserver_Type::Notification &, const CLMotionStateObserver_Type::NotificationData &)
VehicularConfidence,%{public}d
onMotionStateObserverNotification
v16@?0@?<{ScanResult=d{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}}@?>8
v16@?0@"CLClientManagerAuthorizationContext"8
void CLMotionStateMediator::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
Received an authorization notification %{public}d. Checking bundle permissions.
void CLMotionStateMediator::onTier1CyclingFeaturesActivate()
Enabling tier1 cycling features message sending
void CLMotionStateMediator::onTier1CyclingFeaturesDeactivate()
Disabling tier1 cycling features message sending
CLMotionStateMediator::onMotionCoprocessorData
CLMotionStateMediator::onOldMotionCoprocessorData
CLMotionStateMediator::onActivePedStateCoprocessorData
CLMotionStateMediator::onWatchElevationCoprocessorData
CLMotionStateMediator::onAveragedAlsData
CLMotionStateMediator::onTier1CyclingFeaturesData
CLMotionStateMediator::onCalorimetryNotification
CLMotionStateMediator::onSkiNotification
CLMotionStateMediator::onWatchOrientationSettingsNotification
CLMotionStateMediator::onDaemonStatus
CLMotionStateMediator::onCatherineNotification
CLMotionStateMediator::onFitnessTrackingNotification
CLMotionStateMediator::onMotionStateObserverNotification
CLMotionStateMediator::onLocationNotification
CLMotionStateMediator::onClientManagerNotification
CLMotionStateMediator::onDataProtectionNotification
CLMotionStateMediator::onDeviceMotionData
CLMotionStateMediator::onWifiNotification
CLMotionStateMediator::onOdometerNotification
virtual bool CLWorkoutPredictorSourceFromNotifier<CLSwimEntry>::enable() const [Data_T = CLSwimEntry]
activate src %s
Swim
virtual bool CLWorkoutPredictorSourceFromNotifier<CLSwimEntry>::disable() const [Data_T = CLSwimEntry]
deactivate src %s
void CLWorkoutPredictorSourceBuffer<CLSwimEntry>::add(const T &) [T = CLSwimEntry]
time rollback on add, newItemTime, %f, lastItemTime, %f
virtual CLWorkoutPredictorSourceFromNotifier<CLExtendedStepCountEntry>::~CLWorkoutPredictorSourceFromNotifier() [Data_T = CLExtendedStepCountEntry]
disable message src %s
ExtendedStepCount
virtual bool CLWorkoutPredictorSourceFromNotifier<CLExtendedStepCountEntry>::enable() const [Data_T = CLExtendedStepCountEntry]
virtual bool CLWorkoutPredictorSourceFromNotifier<CLExtendedStepCountEntry>::disable() const [Data_T = CLExtendedStepCountEntry]
void CLWorkoutPredictorSourceBuffer<CLExtendedStepCountEntry>::add(const T &) [T = CLExtendedStepCountEntry]
virtual bool CLWorkoutPredictorSourceFromNotifier<CLStepCountEntry>::enable() const [Data_T = CLStepCountEntry]
StepCount
virtual bool CLWorkoutPredictorSourceFromNotifier<CLStepCountEntry>::disable() const [Data_T = CLStepCountEntry]
void CLWorkoutPredictorSourceBuffer<CLStepCountEntry>::add(const T &) [T = CLStepCountEntry]
virtual bool CLWorkoutPredictorSourceFromNotifier<CLCatherineData>::enable() const [Data_T = CLCatherineData]
virtual bool CLWorkoutPredictorSourceFromNotifier<CLCatherineData>::disable() const [Data_T = CLCatherineData]
void CLWorkoutPredictorSourceBuffer<CLCatherineData>::add(const T &) [T = CLCatherineData]
virtual CLWorkoutPredictorSourceFromNotifier<CLElevationChangeEntry>::~CLWorkoutPredictorSourceFromNotifier() [Data_T = CLElevationChangeEntry]
virtual bool CLWorkoutPredictorSourceFromNotifier<CLElevationChangeEntry>::enable() const [Data_T = CLElevationChangeEntry]
virtual bool CLWorkoutPredictorSourceFromNotifier<CLElevationChangeEntry>::disable() const [Data_T = CLElevationChangeEntry]
void CLWorkoutPredictorSourceBuffer<CLElevationChangeEntry>::add(const T &) [T = CLElevationChangeEntry]
bool CLElevationGradeEstimator::estimateGrade(const CLElevationChangeEntry &, CLElevationChangeEntry &)
Input, Elevation, time stamp, %.2lf, elevationAscended, %d, elevationDescended, %d, source, %d
Input, Elevation, beyond time window, buffer size, %lu, deltaTime, %f
Input, Elevation, Online grade estimation regime change, time start, %.2lf, elevationAscended, %d, elevationDescended, %d,input_altitude, %.4f, Prediction Error, %.4f
Input, Elevation, Online grade estimation, gradeType, %d, time start, %.2lf, altitude delta, %.2f, vspeed, %.2f, fParam_m, %f, fParam_b, %f,fTimeBufferFront, %f,fTimeBufferBack, %f, elevationAscended, %d, elevationDescended, %d, input_altitude, %.4f
Input, Elevation, Hardware gradeTypeFilter, gradeType, %d, vspeed, %.4f
Calorimetry
{shared_ptr<CLMotionStateOverride>=^{CLMotionStateOverride}^{__shared_weak_count}}8@?0
CLWorkoutPredictorSourceFromNotifier<CLElevationChangeEntry>::CLWorkoutPredictorSourceFromNotifier(id<CLIntersiloUniverse>, CFTimeInterval, CFTimeInterval) [Data_T = CLElevationChangeEntry]
enable message src %s
CLWorkoutPredictorSourceFromNotifier<CLExtendedStepCountEntry>::CLWorkoutPredictorSourceFromNotifier(id<CLIntersiloUniverse>, CFTimeInterval, CFTimeInterval) [Data_T = CLExtendedStepCountEntry]
CLMotionStateMediator::onWorkoutPredictorUpdate
virtual void CLMotionNotifier::SiloDispatcher<CLDeviceMotion::Sample>::dispatchData(int, const void *, size_t) [T = CLDeviceMotion::Sample]
virtual void CLNotifier<CLMotionStateMediator_Type::Notification, CLMotionStateMediator_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLMotionStateMediator_Type::Notification, NotificationData_T = CLMotionStateMediator_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLMotionStateMediator_Type::Notification, CLMotionStateMediator_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMotionStateMediator_Type::Notification, NotificationData_T = CLMotionStateMediator_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLWorkoutPredictorSourceBuffer<CLWorkoutPredictorTurnDetector::Turn>::add(const T &) [T = CLWorkoutPredictorTurnDetector::Turn]
void CLWorkoutPredictorSourceBuffer<CLWorkoutPredictorWatchPressure>::add(const T &) [T = CLWorkoutPredictorWatchPressure]
void CLWorkoutPredictorSourceBuffer<CLMotionCoprocessorInterface::Tier1CyclingFeatures>::add(const T &) [T = CLMotionCoprocessorInterface::Tier1CyclingFeatures]
void CLWorkoutPredictorSourceBuffer<CLExerciseMinuteData>::add(const T &) [T = CLExerciseMinuteData]
virtual void CLNotifier<CLMotionStateMediator_Type::Notification, CLMotionStateMediator_Type::NotificationData>::removeClient(int) [Notification_T = CLMotionStateMediator_Type::Notification, NotificationData_T = CLMotionStateMediator_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionStateMediator_Type::Notification, CLMotionStateMediator_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMotionStateMediator_Type::Notification, NotificationData_T = CLMotionStateMediator_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionStateMediator_Type::Notification, CLMotionStateMediator_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLMotionStateMediator_Type::Notification, NotificationData_T = CLMotionStateMediator_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionStateMediator_Type::Notification, CLMotionStateMediator_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMotionStateMediator_Type::Notification, NotificationData_T = CLMotionStateMediator_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionStateMediator_Type::Notification, CLMotionStateMediator_Type::NotificationData>::listClients() [Notification_T = CLMotionStateMediator_Type::Notification, NotificationData_T = CLMotionStateMediator_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
-[CLLocationProviderAdapter updateNotification:withRegistrationInfo:forClient:]
Failed to updateRegistrationInfoForClient %p (%d)
-[CLLocationProviderAdapter register:forNotification:distanceFilter:]
Failed to registerForFilteredLocation %{public}p (%{public}d, %{public}d, %{public}f)
LocationProviders
bool CLLocationProvider::checkEnable(const char *)
#Warning provider %s disabled - will run but not send locations to clients
 Location Provider (%s) set to (%d)
virtual bool CLLocationProvider::registerForNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::RegInfo &)
CLIENT: registerForNotification, register for notification, %d, %s, desiredAccuracy, %.1lf, operatingMode, %d
virtual bool CLLocationProvider::registerForFilteredLocation(int, const CLLocationProvider_Type::Notification &, const double &)
Wrong registration method called!
virtual bool CLLocationProvider::updateRegistrationInfoForClient(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::RegInfo &)
CLIENT: updateRegistrationInfoForClient, client, %d, notification, %d, %s, from desiredAccuracy, %.1lf, to, %.1lf
CLIENT: updateRegistrationInfoForClient, client, %d, notification, %d, %s, no notification
Restored-
virtual bool CLLocationProvider::getNotification(const CLLocationProvider_Type::Notification &, CLLocationProvider_Type::NotificationData &)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,LocationTimestamp,%.3f,Age,%.3f,Lifespan,%.3f,
virtual void CLLocationProvider::notifyClientsWithData(const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &, bool, int, bool)
Ignoring location for %s
Provider %s is notifying clients (type=%d) of an invalid position (<%+.8f,%+.8f>)
Provider %s is notifying clients (type=%d) of an invalid altitude %.2f (accuracy %.2f)
Provider %s is notifying clients (type=%d) of a <0,0> position
#Warning Should not be sending coarse and fine notifications directly
Sending location unavailable notification through for %s
virtual void CLLocationProvider::sendSimulatedLocation(const CLDaemonLocation &)
Sending through simulated location for %s
enabled
disabled
virtual void CLLocationProvider::setSimulationEnabled(bool)
Simulation is now %s for %s
Notifying
Simulation
virtual void CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]
void CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]
private.HomeKit.accessory.accessoryUUID
private.HomeKit.accessory.serviceType
private.HomeKit.accessory.characteristicType
private.HomeKit.accessory.source
private.HomeKit.accessory.stateString
private.HomeKit.accessory.serviceUUID
private.HomeKit.accessory.serviceGroupUUID
private.HomeKit.accessory.roomUUID
private.HomeKit.scene.actionSetUUID
private.HomeKit.scene.actionSetName
private.HomeKit.scene.actionSetType
private.HomeKit.scene.clientName
private.HomeKit.scene.source
private.HomeKit.scene.homeName
shouldTriggerLocalizationScan
shouldTriggerRecordingScan
UARFCN
CLCellLocationDatabase::CLCellLocationDatabase(const char *, const CLSqliteDatabase::SqliteProperties &, double)
#Warning Database is not valid; not initializing
bool CLCellLocationDatabase::getLocation(const CLTelephonyService_Type::Cell &, sqlite3_int64 &)
failed to bind %{public}s
INSERT OR REPLACE INTO 
) VALUES (?, ?, ?, ?, ?, ?)
bool CLCellLocationDatabase::setLocation(const CLTelephonyService_Type::Cell &, const CLDaemonLocation &)
CELL_LOC: fInsertStatement [%s]
bool CLCellLocationDatabase::getLocation(sqlite3_int64, CLTelephonyService_Type::Cell &) const
DisableAutostartSwimPressureCheck
CLWorkoutPredictorTier2Smoother::CLWorkoutPredictorTier2Smoother(const CLMotionActivity &, const CLWorkoutPredictorInputs &)
Tier2Smoother, tracking alternate walk escalation
void CLWorkoutPredictorTier2Smoother::setRapidWalkingDetectionEnabled(bool)
Tier2Smoother, set rapid walking detection, %{public}d
void CLWorkoutPredictorTier2Smoother::evaluateTier2ClassifierBuffer()
Tier2Smoother attemped de-escalating due to Unknown calls in Tier 2 Classifier
float CLWorkoutPredictorTier2Smoother::calculateAveragePressure(CFAbsoluteTime, CFAbsoluteTime) const
Tier2Smoother swimcheck, insufficient samples in range start %{public}f, end %{public}f, num %zu
bool CLWorkoutPredictorTier2Smoother::isWaterOccludedOrPressureDeltaPresent(const CLWorkoutPredictorTier2Smoother::ESwimDetected *) const
Tier2Smoother swimcheck,waterOccluded,%{public}d,startTime,%{public}f,averageNow,%{public}f,,averageHistorical,%{public}f
Tier2Smoother swimcheck, failed to get first entry
bool CLWorkoutPredictorTier2Smoother::areEnoughExerciseMinutesPresent(const int) const
Tier2Smoother, bypassing exercise minute requirements for sustained walking
Tier2Smoother,passed unknown threshold of %d
Tier2Smoother,briskCheck,startTime,%{public}f,endTime,%{public}f,numExerciseMinutes,%{public}u,threshold,%{public}d
void CLWorkoutPredictorTier2Smoother::evaluateTier1ClassifierBuffer()
Tier2Smoother attempted de-escalating due to no Running calls in Tier 1 Classifier
void CLWorkoutPredictorTier2Smoother::checkPedestrianStop()
Tier2Smoother,ped auto-stop detected,%{public}d,ped de-escalation from exercise minutes,%{public}d
CLWorkoutClassifier_Type::Confidence CLWorkoutPredictorTier2Smoother::getWorkoutConfidenceForPatternedMotion() const
Tier2Smoother,WorkoutPauseFlags,flagLastEpochsUnknown,%d,flagNoPatternInTier1,%d,flagNoCurrentStateInLastEpochs,%d
void CLWorkoutPredictorTier2Smoother::resetPedestrianStopDetector(const T *) [T = CLWorkoutPredictorTier2Smoother::EWalkEscalation]
Tier2Smoother, resetting pedestrian stop detector FSM
void CLWorkoutPredictorTier2Smoother::resetPedestrianStopDetector(const T *) [T = CLWorkoutPredictorTier2Smoother::EAltWalkEscalation]
const T &CMQueue<CMWorkoutType>::operator[](const size_t) const [T = CMWorkoutType]
const T &CMQueue<CMMotionContext::MotionState>::operator[](const size_t) const [T = CMMotionContext::MotionState]
const T &CMQueue<CLWorkoutPredictorTier2Smoother::CyclingDescalationEntry>::operator[](const size_t) const [T = CLWorkoutPredictorTier2Smoother::CyclingDescalationEntry]
BarometerRebaseSignificantElevation
absElevation
absSignificantElevation
biasUncertainty
maxOf2Uncertainty
-[CLBarometerCalibrationBiasEstimator getAbsoluteAltitudeUncertainty]
%s,%f,%s,%f,%s,%f,%s,%f
-[CLBarometerCalibrationBiasEstimator updateEstimatedWeatherWithCumulativeAscendingDelta:andDescendingDelta:andIosTimestamp:]
weatherEstimateWithRebase is %f weatherEstimateFromSigElevation is %f timestamp is %f cumulativeAscendingDelta is %f cumulativeDescendingDelta is %f
-[CLBarometerCalibrationBiasEstimator centroidOfLocationVector:]
new centroid: latitude %f, longitude %f
-[CLBarometerCalibrationBiasEstimator updatePressureUncertaintyWithTime:andLat:andLon:]
updated pressure uncertainty due to distance %f by %f uncertainty now is %f
updated bias location latitude %f longitude %f
updated visit status for bias estimator, %d, step count timestamp, %f, current time, %f
updated weather drift due to time, %f, sig elev state, %d, inVisit, %d
updated pressure uncertainty due to time: timestamp %f _biasTimestamp %f _biasUncertaintyTimestamp %f by %f uncertainty now is %f
-[CLBarometerCalibrationBiasEstimator updateBiasUncertaintyWithPressure:andTime:andLat:andLon:]
term1 %f, dElevationdPresureSA(pmeas) %f std::abs(_pressureUncertainty) %f pmeas %f
term2 %f, slopeDiffDElevationDPressureSA(pbias) %f std::abs(pressure - _biasPressure) %f
term3 %f, slopeDiffDElevationDPressureSA(pmeas) %f std::abs(_pressureUncertainty %f
total bias uncertainty %f
-[CLBarometerCalibrationBiasEstimator updateElevationBiasFromDEMBetweenBetweenStartTime:andEndTime:]
pressure too far from reference data
individual bias calculated from DEM: %f, DEM timestamp %f,  DEM altitude %f, DEM uncertainty %f, pressure timestamp %f, pressure altitude %f
pressure height rebase to type %d new bias is %f new bias uncertainty is %f old baroAlt is %f old refAlt is %f old baroUncertainty is %f old refUncertainty is %f weatherEstimateInMeter is %f calculated from track start at %f end at %f DEMpoints %d underDEMPoints %d
-[CLBarometerCalibrationBiasEstimator updateElevationBiasBetweenStartTime:andEndTime:]
track is too old, don't rebase, startTime %f, endTime %f
companion data found, altitude %f, timestamp %f
pressure too far from companion data
individual bias calculated: %f, companion timestamp %f,  companion altitude %f, pressure timestamp %f, pressure altitude %f
pressure height rebase to type %d new bias is %f new bias uncertainty is %f old baroAlt is %f old refAlt is %f old baroUncertainty is %f old refUncertainty is %f weatherEstimateInMeter is %f calculated from track start at %f end at %f
new bias calculated from companion is %f, average baroAlt %f, average companion alt %f, average pressure %f, timestamp %f
individual bias error: reference Uncertainty < 0 and no DEMS, location timestamp %f, location altitude %f, location DEMS %f
individual location data: type %d location timestamp %f pressure timestamp %f location altitude %f pressure altitude %f location verticalUncertainty %f horizontalUncertainty %f lat %f lon %f current bias %f track start at %f end at %f isPrefilteredLocation %d fSlope %f maxAbsSlope %f fSpeed %f fSpeedAccuracy %f fEnvironment %d fMatchQuality %d altitude %f verticalAccuracy %f rawAltitude %f rawVerticalAccuracy %f
individual bias calculated: %f, location timestamp %f, pressure timestamp %f, location altitude %f, DEM altitude %f, pressure altitude %f
cross entropy of type %d is %f calculated from baroAlt is %f refAlt is %f baroUncertainty is %f refUncertainty is %f track start at %f end at %f
endTrackTime
-[CLBarometerCalibrationBiasEstimator rebaseSignificantElevationWithEndTime:]
significant elevation rebase: %s,%f
-[CLBarometerCalibrationBiasEstimator updateVisitState:arrivalTime:departureTime:]
received entry visit, shouldTakeMax updated to, %d, timestamp, %f
inVisit
demAvailableInTrack
rebaseSource
firstRebaseSinceLocationdStart
forcedGPSRecently
altitudeError_binned
timeToFirstRebase_binned
referenceUncertainty_binned
uncertainty_binned
timeSinceVisitEntry_binned
correction_binned
distanceSinceLastRebase_binned
timeSinceLastRebase_binned
inOutdoorWorkout
@"NSMutableDictionary"8@?0
duration_binned
uncertaintyAtEntry_binned
uncertaintyAtRebase_binned
timeFromEnterToRebase_binned
correctionAtRebase_binned
altitudeErrorAtRebase_binned
referenceUncertaintyAtRebase_binned
NULL
-[CLBarometerCalibrationBiasEstimator saveBiasInfo]
saving rebase info to cache, timestamp %f, bias, %f, uncertainty, %f, weather estimate, %f, sig elevation, %f, pressure, %f
-[CLBarometerCalibrationBiasEstimator retrieveBiasInfo]
recovering from locationd crash, timestamp %f, bias, %f, uncertainty, %f, weather, %f, sig elev, %f, pressure, %f
state is too old to be recovered
com.apple.Motion.Altimeter.Rebase_Test
com.apple.Motion.Altimeter.VisitExit
CLBarometerCalibration_Timestamp
CLBarometerCalibratio_Bias
CLBarometerCalibration_Uncertainty
CLBarometerCalibration_Weather
CLBarometerCalibration_SignificantElevation
CLBarometerCalibration_BiasPressure
map::at:  key not found
FallUserMaxMets
void CLWifiLocationUpdateRequest::reset()
WifiFlow, reset, last, %{public}d
void CLWifiLocationUpdateRequest::updateStep(CLWifiLocationUpdateRequest::Step, CFAbsoluteTime, CLWifiLocationUpdateRequest::DoneReason)
WifiStep, same, %{public}s
WifiFlow, step, %{public}s, from, %{public}s, donereason, %{public}s
0.5s
WlpMetric, request, %{public}s, %{public}s, done, %{public}s, fix, %{public}s, tt, %{public}s, %{public}s, durint, %{public}s, %{public}s, als, %{public}d
com.apple.clx.wifiloc.request
requester
ttsf
interval
daily
lowpower
clientupdate
emergency
prepare
initialscan
finalscan
done
inprogress
override
cancel
atypical
intial
busy
error
suppressed
exhausted
weak
strong
Request, type, 
 lowPriority, 
 requester, 
 numOfRequestedScans, 
 timestamp, 
nofix
nextstage
scanbusy
scanfail
reset
static void CLWifiLocationUpdateRequest::logLocationRequestOutcome(CLWifiLocationUpdateRequest::Outcome)
@WifiFlow, outcome, %{public}s
InfoMask
CLWifiLocationDatabase::CLWifiLocationDatabase(const char *, const CLSqliteDatabase::SqliteProperties &, double)
read only database - not creating bounding boxes, tableName, %s
platform does not support WiFi location monitoring - not creating bounding boxes, tableName, %s
 VALUES 
(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);
SELECT ROWID FROM 
 ASC LIMIT ?
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Network/CLWifiLocationDatabase.mm
truncatePastLimit
 WHERE ROWID=?
void CLWifiLocationDatabase::truncatePastLimit(int64_t)
failed to execute statement properly
) VALUES (?,?,?,?,?,?)
 / 2.0 
 ORDER BY Score DESC LIMIT 
std::vector<CLWifiAPLocation> CLWifiLocationDatabase::getNearbyWifisForFence(double, double, double, int, int, bool, double)
Unknown WiFi AP. %s
No valid WiFi AP location. %s
Coarse wifi query fence key, %d, aps, %ld
uint32_t CLWifiLocationDatabase::count()
invalid return value getting size of WifiLocation table
 IS NULL OR 
 = '' 
CellLocationLocal
CellLocation
ScdmaCellLocationLocal
ScdmaCellLocation
CdmaCellLocationLocal
CdmaCellLocation
LteCellLocationLocal
LteCellLocation
NrCellLocationLocal
NrCellLocation
CLNetworkLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Network/CLNetworkLocationProvider.mm
-[CLNetworkLocationProviderAdapter beginService]
CLNetworkLocationProvider
NetworkProvider
UseEVDOTransmittedLocations
CLNetworkLocationProvider::CLNetworkLocationProvider(id<CLIntersiloUniverse>, std::unique_ptr<CLINetworkLocationProviderExternal>, std::shared_ptr<CLWifiAccessPointLocationService>)
NETWORK: fIsUseEVDOTransmittedLocations = %d
IsExponentialRetryTimer
NETWORK: fIsExponentialRetryTimer, %d
NetworkLocationServerRefreshInterval
fServerRefreshInterval, %.1lf
NetworkLocationDebugSQLQueries
CLDaemonSettings::instance()->get("NetworkLocationDebugSQLQueries", debugSqlQueries) == false
Scheduling purge for %.3f and checking every %.3fs for older than %.3fs
NetworkLocationPurgeTimer
void CLNetworkLocationProvider::getMetric(CLDaemonStats_Type::LocationNetworkQueries &)
NETWORK: stats: cellsQueried, %d, wifisQueried, %d, locationsQueried, %d, totalRequests, %d, totalRequestsSuccessful, %d
void CLNetworkLocationProvider::rescheduleOnReachability()
NETWORK: check reschedule, fQueryRetries, %d, sinceLastRetry, %.1lf
rescheduleOnReachability
bool CLNetworkLocationProvider::getLocation_GSM(const CLTelephonyService_Type::Cell &, CLDaemonLocation &)
cell %03d %03d 0x%x 0x%x is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> %.2fm apart - using local
CELL_LOC: cell, %s, has local, but no remote - querying
CELL_LOC: found, %d, server, %d, cell, %s, location, %s
bool CLNetworkLocationProvider::getLocation_SCDMA(const CLTelephonyService_Type::ScdmaCell &, CLDaemonLocation &)
CELL_LOC: scdma, found, %d, server, %d, cell, %s, location, %s
bool CLNetworkLocationProvider::getLocation_CELL(const CLCell &, CLDaemonLocation &)
CELL_LOC: failed get location for, %s
CLNetworkLocationProvider::BestMatchLevel CLNetworkLocationProvider::getBestMatchLocation(const CLCell &, CLDaemonLocation &)
CELL_LOC: best match cell, %s, bestMatch, %d
CLNetworkLocationProvider::BestMatchLevel CLNetworkLocationProvider::getBestMatchLocation_SCDMA(const CLTelephonyService_Type::ScdmaCell &, CLDaemonLocation &)
CELL_LOC: SCDMA full match 0, %s, %s
CELL_LOC: SCDMA match 1, %s, %s
CELL_LOC: SCDMA match 2, %s, %s
CELL_LOC: SCDMA match 3, %s, %s
CELL_LOC: SCDMA match 4, %s, %s
CELL_LOC: SCDMA NO MATCH, %s
CLNetworkLocationProvider::BestMatchLevel CLNetworkLocationProvider::getBestMatchLocation_GSM(const CLTelephonyService_Type::Cell &, CLDaemonLocation &)
CELL_LOC: GSM full match 0, %s, %s
CELL_LOC: GSM match 1, %s, %s
CELL_LOC: GSM match 2, %s, %s
CELL_LOC: GSM match 3, %s, %s
CELL_LOC: GSM match 4, %s, %s
CELL_LOC: GSM NO MATCH, %s
CLNetworkLocationProvider::BestMatchLevel CLNetworkLocationProvider::getBestMatchLocation_LTE(const CLTelephonyService_Type::LteCell &, CLDaemonLocation &)
CELL_LOC: LTE full match 0, %s, %s
CELL_LOC: LTE match 1, %s, %s
CELL_LOC: LTE match 2, %s, %s
CELL_LOC: LTE match 3, %s, %s
CELL_LOC: LTE match 4, %s, %s
CELL_LOC: LTE NO MATCH, %s
CLNetworkLocationProvider::BestMatchLevel CLNetworkLocationProvider::getBestMatchLocation_NR(const CLTelephonyService_Type::NrCell &, CLDaemonLocation &)
CELL_LOC: NR full match 0, %s, %s
CELL_LOC: NR match 1, %s, %s
CELL_LOC: NR match 2, %s, %s
CELL_LOC: NR match 3, %s, %s
CELL_LOC: NR match 4, %s, %s
CELL_LOC: NR NO MATCH, %s
CLNetworkLocationProvider::BestMatchLevel CLNetworkLocationProvider::getBestMatchLocation_CDMA(const CLTelephonyService_Type::CdmaCell &, CLDaemonLocation &)
CELL_LOC: match 8 (%s)
CELL_LOC: match 5.1 (%s)
CELL_LOC: match 7 (%s)
CELL_LOC: match 4.1 (%s)
CELL_LOC: match 4.2 (%s)
CELL_LOC: match 3 (%s)
CELL_LOC: match 2 (%s)
CELL_LOC: match 1 (%s)
CELL_LOC: match sector location, %s, location, %s
CELL_LOC: avoid using transmitted locations
CELL_LOC: NO MATCH (%s)
bool CLNetworkLocationProvider::getLocation_CDMA(const CLTelephonyService_Type::CdmaCell &, CLDaemonLocation &)
CELL_LOC: found in DB (%s) loc (%lf %lf) acc (%lf)
CELL_LOC: cell %03d %03d 0%03d %03d %03d is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> %.2fm apart - using local
CELL_LOC: cell, %s, has local, but no remote - not querying, server doesn't server these
CELL_LOC: cell, %s, has local, but no remote -  pending query
bool CLNetworkLocationProvider::getLocation_LTE(const CLTelephonyService_Type::LteCell &, CLDaemonLocation &)
CELL_LOC: cell, [%s], is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> %.2fm apart - using local
CELL_LOC: cell, %s, has local, but no remote -  querying
bool CLNetworkLocationProvider::getLocation_NR(const CLTelephonyService_Type::NrCell &, CLDaemonLocation &)
CELL_LOC: cell, [%s], is local <%+.8f, %+.8f> remote <%+.8f %+.8f> %.2fm apart - using local
bool CLNetworkLocationProvider::setLocation_CDMA(const CLTelephonyService_Type::CdmaCell &, const CLDaemonLocation &)
CELL_LOC: cell (%s) is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> only %.2fm apart - not storing locally
CELL_LOC: cell (%s) is local at <%+.8f,%+.8f>
#Warning Location Services disabled, not storing location entry
bool CLNetworkLocationProvider::setLocation_GSM(const CLTelephonyService_Type::Cell &, const CLDaemonLocation &)
cell %03d %03d 0x%x 0x%x is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> only %.2fm apart - not storing locally
cell %03d %03d 0x%x 0x%x is local at <%+.8f,%+.8f>
bool CLNetworkLocationProvider::setLocation_SCDMA(const CLTelephonyService_Type::ScdmaCell &, const CLDaemonLocation &)
scdma cell %03d %03d 0x%x 0x%x is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> only %.2fm apart - not storing locally
scdma cell %03d %03d 0x%x 0x%x is local at <%+.8f,%+.8f>
bool CLNetworkLocationProvider::setLocation_LTE(const CLTelephonyService_Type::LteCell &, const CLDaemonLocation &)
CELL_LOC: distance, %.1lf, not storing locally, %s, location, %s
CELL_LOC: distance, %.1lf, override local location, %s, location, %s
bool CLNetworkLocationProvider::setLocation_NR(const CLTelephonyService_Type::NrCell &, const CLDaemonLocation &)
int CLNetworkLocationProvider::queryLocations(const std::vector<CLTelephonyService_Type::Cell> &, const std::vector<CLTelephonyService_Type::ScdmaCell> &, const std::vector<CLTelephonyService_Type::CdmaCell> &, const std::vector<CLTelephonyService_Type::LteCell> &, const std::vector<CLTelephonyService_Type::NrCell> &, const std::vector<CLMacAddress> &, bool, bool, const CLNetworkLocationRequest_Type::CLNetworkLocationRequestConfig &)
@AlsFlow, query, in, cells, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, wifi, %{public}lu, cache, %{public}d, piggyback, %{public}d
@AlsFlow, query, skip, private
@AlsFlow, query, skip, bigswitch
@AlsFlow, query, skip, connectivity
CELL_LOC: cdma cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: cdma cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: cdma cell, %s, re-querying
CELL_LOC: gsm cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: gsm cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: gsm cell, %s, re-querying
CELL_LOC: scdma cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: scdma cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: scdma cell, %s, re-querying
CELL_LOC: lte cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: lte cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: lte cell, %s, re-querying
CELL_LOC: nr cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: nr cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: nr cell, %s, re-querying
AlsWifi, query, in, %{public}lu, paths, %{public}d, %{public}d, %{public}d, out, %{public}lu
@AlsFlow, query, made, %{public}d, cells, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, wifi, %{public}lu, nearby, %{public}d
AlsWifi, pending, %{private}s, from, %{public}.3f, %{public}.3fs
AlsWifi, clearpending, %{public}ld, #CloneMe
#Warning CELL_LOC: %ld pending gsm cells, clearing
CELL_LOC: pending gsm cell, %s, from, %.3f, %.3f, ago)
#Warning CELL_LOC: %ld pending scdma cells, clearing
CELL_LOC: pending scdma cell, %s, from, %.3f, %.3f, ago)
#Warning CELL_LOC: %ld pending cdma cells, clearing
CELL_LOC: pending cdma cell, %s, from, %.3f, %.3f, ago)
#Warning CELL_LOC: %ld pending lte cells, clearing
CELL_LOC: pending lte cell, %s, from, %.3f, %.3f, ago)
#Warning CELL_LOC: %ld pending nr cells, clearing
CELL_LOC: pending nr cell, %s, from, %.3f, %.3f, ago)
void CLNetworkLocationProvider::requeryLocations()
@AlsFlow, requery, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, items, fQueryRetries, %{public}d, fLastRetryTimestamp, %{public}.1lf
#Warning NETWORK: in private location mode; not querying for unknown cells or unknown wifis
#Warning NETWORK: Location Services disabled, not querying location
requeryLocations
NETWORK: re-querying cells, %lu, %lu, %lu, %lu, %lu, wifis, %lu, retry count, %d
bool CLNetworkLocationProvider::isBroadConnection()
Nlp, isBroadConnection, %{public}d, reachability, %{public}d, dataAccessTech, %{public}ld, %{public}ld
int CLNetworkLocationProvider::queryNearbys(const CLDaemonLocation &, const std::vector<int> &)
#Warning in private location mode; not querying for unknown cells or unknown wifis
#Warning Location Services disabled, not querying location
@AlsFlow, querynearby, skip, connectivity
queryNearbys
void CLNetworkLocationProvider::onLocationRequesterCellLocationSeries(CLNetworkLocationRequester *, bool, CLNetworkLocationRequester::RequestType, int)
CELL_LOC: start sequence, This, %p
CELL_LOC: beginning cell database
CELL_LOC: ending cell database (%lu cells still pending)
Network-Cell
void CLNetworkLocationProvider::onLocationRequesterScdmaCellLocation(CLNetworkLocationRequester *, const CLTelephonyService_Type::ScdmaCell &, const CLDaemonLocation &, CLNetworkLocationRequester::RequestType, int)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,LAC,0x%x,CI,0x%x,Confidence,%d,Count,%d,lock,%d
void CLNetworkLocationProvider::onLocationRequesterScdmaCellLocationUnknown(CLNetworkLocationRequester *, const CLTelephonyService_Type::ScdmaCell &, CLNetworkLocationRequester::RequestType, int)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,LAC,0x%x,CI,0x%x,
void CLNetworkLocationProvider::onLocationRequesterCellLocation(CLNetworkLocationRequester *, const CLTelephonyService_Type::Cell &, const CLDaemonLocation &, CLNetworkLocationRequester::RequestType, int)
void CLNetworkLocationProvider::onLocationRequesterCellLocationUnknown(CLNetworkLocationRequester *, const CLTelephonyService_Type::Cell &, CLNetworkLocationRequester::RequestType, int)
void CLNetworkLocationProvider::onLocationRequesterCdmaCellLocation(CLNetworkLocationRequester *, const CLTelephonyService_Type::CdmaCell &, const CLDaemonLocation &, CLNetworkLocationRequester::RequestType, int)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,SID,%03d,NID,%03d,BSID,%03d,Confidence,%d,Count,%d,lock,%d
CELL_LOC: server response cell(%s) loc (%lf %lf) acc(%lf)
void CLNetworkLocationProvider::onLocationRequesterCdmaCellLocationUnknown(CLNetworkLocationRequester *, const CLTelephonyService_Type::CdmaCell &, CLNetworkLocationRequester::RequestType, int)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,SID,%03d,NID,%03d,BSID,%03d
void CLNetworkLocationProvider::onLocationRequesterLteCellLocation(CLNetworkLocationRequester *, const CLTelephonyService_Type::LteCell &, const CLDaemonLocation &, CLNetworkLocationRequester::RequestType, int)
CELL_LOC: server response lte cell, %s, location, %s
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,TAC,0x%x,CI,0x%x,Confidence,%d,Count,%d,lock,%d
NETWORK: pending, known, before, %lu, cell, %s
NETWORK: pending, known, after, %lu, cell, %s
void CLNetworkLocationProvider::onLocationRequesterLteCellLocationUnknown(CLNetworkLocationRequester *, const CLTelephonyService_Type::LteCell &, CLNetworkLocationRequester::RequestType, int)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,TAC,0x%x,CI,0x%x,
NETWORK: pending, unknown, before, %lu, cell, %s
NETWORK: pending, unknown, after, %lu, cell, %s
void CLNetworkLocationProvider::onLocationRequesterNrCellLocation(CLNetworkLocationRequester *, const CLTelephonyService_Type::NrCell &, const CLDaemonLocation &, CLNetworkLocationRequester::RequestType, int)
CELL_LOC: server response nr cell, %s, location, %s
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,TAC,0x%x,CI,0x%llx,Confidence,%d,Count,%d,lock,%d
void CLNetworkLocationProvider::onLocationRequesterNrCellLocationUnknown(CLNetworkLocationRequester *, const CLTelephonyService_Type::NrCell &, CLNetworkLocationRequester::RequestType, int)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,TAC,0x%x,CI,0x%llx,
void CLNetworkLocationProvider::onLocationRequesterWifiLocationSeriesComplete(CLNetworkLocationRequester *, const std::vector<CLAlsWifiAccessPoint> &, const std::vector<CLAlsWifiAccessPoint> &, CLNetworkLocationRequester::RequestType, int, CLNetworkLocationRequest_Type::CLAlsWifiBand)
AlsWifi, seriesComplete, known, %{public}lu, unknown, %{public}lu
!isNearbyQuery
onLocationRequesterWifiLocationSeriesComplete
fenceKeys.size() > 0
AlsWifi, seriesComplete, tags remain, %{private}zu, keys, %{private}zu
Extra 5GHz #als response, mac, %s, channel, %d, isNearbyQuery, %d, fDataProtectionEnabled, %d
Partial numer of ALS aps saved
#Warning Location Services disabled, not storing location entries
void CLNetworkLocationProvider::onLocationRequesterResponse(CLNetworkLocationRequester *, const CFTimeInterval &, CFDictionaryRef, CLNetworkLocationRequester::RequestType, int)
NETWORK: stats: onLocationRequesterResponse, %d
void CLNetworkLocationProvider::onLocationRequesterLocationError(CLNetworkLocationRequester *, CLNetworkLocationRequester::RequestType, int)
#Notice NETWORK: no response from server, reachability, %{public}d, queryRetries, %{public}d
queryFailed
NETWORK: data reachability is not available - not retrying
no.data.reachability
NETWORK: retry query, %d, %d
retry.query
NETWORK: retry count %d exceeded %d - not retrying
max.retries
void CLNetworkLocationProvider::onLocationRequesterNearbyError(CLNetworkLocationRequester *, CLNetworkLocationRequester::RequestType, int)
NETWORK: query failed for nearbys - not retrying
void CLNetworkLocationProvider::onLocationRequesterFinished(CLNetworkLocationRequester *, CLNetworkLocationRequester::RequestType, int)
NETWORK: query: finished, tag, %d, cells, %d, wifis, %d
onLocationRequesterFinished
void CLNetworkLocationProvider::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
NETWORK: onStatusNotification, kNotificationReachability, from, %d, to, %d
@ClxLink, reach, %{public}d, last, %{public}d, retries, %{public}d
void CLNetworkLocationProvider::trimPendingQueries()
trimming pending gsm, %lu, scdma, %lu, cdma, %lu, lte, %lu, wifis, %lu, nr, %lu, to, %d
int CLNetworkLocationProvider::query(const std::vector<CLTelephonyService_Type::Cell> &, const std::vector<CLTelephonyService_Type::ScdmaCell> &, const std::vector<CLTelephonyService_Type::CdmaCell> &, const std::vector<CLTelephonyService_Type::LteCell> &, const std::vector<CLTelephonyService_Type::NrCell> &, const std::vector<CLMacAddress> &, const CLNetworkLocationRequest_Type::CLNetworkLocationRequestConfig &)
@AlsFlow, query, internal, cells, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, wifi, %{public}lu, skipnearby, %{public}d
query
query, broadDataConnection, %d, timeout, %d
queryLoc
void CLNetworkLocationProvider::onManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
#Warning Location Services reset, clearing all local cache
#Warning Location Services disabled, clearing all local cache
void CLNetworkLocationProvider::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
onCompanionNotification, notification, %d
@ClxLink, Nearby, %{public}d
void CLNetworkLocationProvider::handleDataProtectionStatusChanged(CLDataProtectionManager_Type::DataAvailability)
Data protection is now %s
void CLNetworkLocationProvider::onTelephonyNotification(int, const CLTelephonyService_Type::Notification &, const CLTelephonyService_Type::NotificationData &)
Nlp, received %{public}s
clearAlsDatabaseEntries
void CLNetworkLocationProvider::clearDatabaseEntriesByAge(CFTimeInterval)
Purging entries older than %.2fs.
onRetryTimer
void CLNetworkLocationProvider::onRetryTimer()
NETWORK: onRetryTimer, %s, %p, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, %lu
bool CLNetworkLocationProvider::isRetryTimerNeeded()
NETWORK: areQueryRetriesNeeded, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, %lu, currentRetry, %d, sinceRetrySequenceStart, %.2lf, needed, %d
void CLNetworkLocationProvider::scheduleRetryTimer(const char *)
NETWORK: scheduleRetryTimer, retry timer already scheduled
scheduleRetryTimer
NETWORK: scheduleRetryTimer, %s, %p, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, %lu, timerInterval, %.1lf, isTimerNeeded, %d
void CLNetworkLocationProvider::cancelRetryTimer(const char *)
NETWORK: cancelRetryTimer, %s, %p, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, %lu
NETWORK: cancelRetryTimer, no retry timer
void CLNetworkLocationProvider::resetRetryCounters(const char *)
NETWORK: resetRetryCounters, sinceLastReset, %.1lf
NETWORK: resetRetryCounters, %s, %p, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, sinceLastReset, %.1lf
resetRetryCounters
/lockCache_encryptedA.db
-journal
-shm
-wal
CLNetworkLocationProvider::onLocationRequesterCellLocationSeries
CLNetworkLocationProvider::onLocationRequesterCellLocation
CLNetworkLocationProvider::onLocationRequesterCellLocationUnknown
CLNetworkLocationProvider::onLocationRequesterWifiLocationSeriesComplete
CLNetworkLocationProvider::onLocationRequesterResponse
CLNetworkLocationProvider::onLocationRequesterLocationError
CLNetworkLocationProvider::onLocationRequesterNearbyError
CLNetworkLocationProvider::onLocationRequesterFinished
CLNetworkLocationProvider::onLocationRequesterCdmaCellLocation
CLNetworkLocationProvider::onLocationRequesterCdmaCellLocationUnknown
CLNetworkLocationProvider::onLocationRequesterLteCellLocation
CLNetworkLocationProvider::onLocationRequesterLteCellLocationUnknown
CLNetworkLocationProvider::onLocationRequesterNrCellLocation
CLNetworkLocationProvider::onLocationRequesterNrCellLocationUnknown
CLNetworkLocationProvider::onLocationRequesterScdmaCellLocation
CLNetworkLocationProvider::onLocationRequesterScdmaCellLocationUnknown
NetworkLocationPurgeThreshold
NetworkLocationPurgeInterval
NetworkLocationFirstPurge
CLNetworkLocationProvider::onPurgeTimer
 AND LAC=
 AND PSC=
this->isCdma()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Utilities/CLCell.h
cdmaCell
this->isGsm()
gsmCell
this->isScdma()
scdmaCell
this->isLte()
lteCell
this->isNr()
nrCell
void CLTelephonyService_Type::CdmaCell::applyDerivedMcc()
#Warning ignoring second MCC %d %d
GeoFencing
virtual void CLNotifier<CLNetworkLocationProvider_Type::Notification, CLNetworkLocationProvider_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLNetworkLocationProvider_Type::Notification, NotificationData_T = CLNetworkLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLNetworkLocationProvider_Type::Notification, CLNetworkLocationProvider_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLNetworkLocationProvider_Type::Notification, NotificationData_T = CLNetworkLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNetworkLocationProvider::cleanPendingListByAge(Container &, CFTimeInterval, CFAbsoluteTime) [Container = std::map<CLTelephonyService_Type::Cell, double>]
NETWORK: cleaning, curEntryAge, %.1lf, ageThreshold, %.1lf
void CLNetworkLocationProvider::cleanPendingListByAge(Container &, CFTimeInterval, CFAbsoluteTime) [Container = std::map<CLTelephonyService_Type::ScdmaCell, double>]
void CLNetworkLocationProvider::cleanPendingListByAge(Container &, CFTimeInterval, CFAbsoluteTime) [Container = std::map<CLTelephonyService_Type::CdmaCell, double>]
void CLNetworkLocationProvider::cleanPendingListByAge(Container &, CFTimeInterval, CFAbsoluteTime) [Container = std::map<CLTelephonyService_Type::LteCell, double>]
void CLNetworkLocationProvider::cleanPendingListByAge(Container &, CFTimeInterval, CFAbsoluteTime) [Container = std::map<CLTelephonyService_Type::NrCell, double>]
void CLNetworkLocationProvider::cleanPendingListByAge(Container &, CFTimeInterval, CFAbsoluteTime) [Container = std::map<CLMacAddress, double>]
void CLManagedLocationDatabase<CLCellLocationDatabase, CLTelephonyService_Type::Cell>::onDataAvailable() [Database = CLCellLocationDatabase, DataType = CLTelephonyService_Type::Cell]_block_invoke
Failed to find entry from in-memory database, table, %{public}s, type %{public}s, rowid, %{public}lld
Failed to save entry to persisted database, table %{public}s
v32@?0r^v8r^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16q24
void CLManagedLocationDatabase<CLCellLocationDatabase, CLTelephonyService_Type::Cell>::onDataAvailable() [Database = CLCellLocationDatabase, DataType = CLTelephonyService_Type::Cell]
Failed to migrate in-memory database to persisted.
Successfully migrated %u rows from in-memory database to persisted for table %s
void CLManagedLocationDatabase<CLCdmaCellLocationDatabase, CLTelephonyService_Type::CdmaCell>::onDataAvailable() [Database = CLCdmaCellLocationDatabase, DataType = CLTelephonyService_Type::CdmaCell]_block_invoke
void CLManagedLocationDatabase<CLCdmaCellLocationDatabase, CLTelephonyService_Type::CdmaCell>::onDataAvailable() [Database = CLCdmaCellLocationDatabase, DataType = CLTelephonyService_Type::CdmaCell]
void CLManagedLocationDatabase<CLLteCellLocationDatabase, CLTelephonyService_Type::LteCell>::onDataAvailable() [Database = CLLteCellLocationDatabase, DataType = CLTelephonyService_Type::LteCell]_block_invoke
void CLManagedLocationDatabase<CLLteCellLocationDatabase, CLTelephonyService_Type::LteCell>::onDataAvailable() [Database = CLLteCellLocationDatabase, DataType = CLTelephonyService_Type::LteCell]
void CLManagedLocationDatabase<CLNrCellLocationDatabase, CLTelephonyService_Type::NrCell>::onDataAvailable() [Database = CLNrCellLocationDatabase, DataType = CLTelephonyService_Type::NrCell]_block_invoke
void CLManagedLocationDatabase<CLNrCellLocationDatabase, CLTelephonyService_Type::NrCell>::onDataAvailable() [Database = CLNrCellLocationDatabase, DataType = CLTelephonyService_Type::NrCell]
virtual void CLNotifier<CLNetworkLocationProvider_Type::Notification, CLNetworkLocationProvider_Type::NotificationData>::removeClient(int) [Notification_T = CLNetworkLocationProvider_Type::Notification, NotificationData_T = CLNetworkLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLNetworkLocationProvider_Type::Notification, CLNetworkLocationProvider_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLNetworkLocationProvider_Type::Notification, NotificationData_T = CLNetworkLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLNetworkLocationProvider_Type::Notification, CLNetworkLocationProvider_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLNetworkLocationProvider_Type::Notification, NotificationData_T = CLNetworkLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLNetworkLocationProvider_Type::Notification, CLNetworkLocationProvider_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLNetworkLocationProvider_Type::Notification, NotificationData_T = CLNetworkLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLNetworkLocationProvider_Type::Notification, CLNetworkLocationProvider_Type::NotificationData>::listClients() [Notification_T = CLNetworkLocationProvider_Type::Notification, NotificationData_T = CLNetworkLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
persistence && !fPersistence
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLPersistentSubscription.mm
setPersistence
{PersistentSubscriptionIdentifier={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{type_index=^{type_info}}}8@?0
SteadinessModelFusion::Result CLMobility::SteadinessModelFusion::runSteadinessModel(CFAbsoluteTime, const std::vector<BoutMetrics> &, const CLBodyMetrics &) const
CLMobility::ModelFusion::Result,classificationEnd,%{public}.2f,rawSteadiness,%{public}.2f,walkingSteadiness,%{public}.2f,successfulModelCount,%{public}lu
double CLMobility::SteadinessModelFusion::fuseLikelihoods(const std::vector<FusionLikelihoods> &) const
fuseLikelihoods using mean log odds fusion rule, modelLikelihoods count,%{public}lu
No component models to fuse likelihoods
Unexpected model likelihood OK,%{public}.2f and/or NotOK,%{public}.2f
virtual void CLExerciseMinuteIntensityEstimator::feedNatalie(double, const CLNatalieModelInput &)
CLExerciseMinuteIntensityEstimator::feedNatalie called, rawMets, %f
virtual void CLExerciseMinuteIntensityEstimator::feedBodyMetrics(const CLBodyMetrics &)
CLExerciseMinuteIntensityEstimator::feedBodyMetrics called
CLExerciseMinuteIntensityEstimator::feedBodyMetrics, threshold, %f, scalingFactor, %f, thresholdSource, %d
void CLExerciseMinuteIntensityEstimator::updateSampleBuffer(double, const CLNatalieModelInput &)
Invalid timestamps, natalieModelInput computeTime is less than the duration, computeTime, %.3f, duration, %.3f
Time rolled back, bufferEndTime, %.3f, newSampleStartTime, %.3f
bool CLExerciseMinuteIntensityEstimatorBase::operateOnWindow(CFTimeInterval, CFAbsoluteTime &, const CLExerciseMinuteIntensitySample *&, std::function<void (const CLExerciseMinuteIntensitySample &, CFTimeInterval)>) const
operateOnWindow - windowStartTime is outside of our intensity buffer, windowStartTime, %.3f, bufferStartTime, %.3f
operateOnWindow - our window is incomplete, this indicates there is a logic error.
void CLGyroBiasAWDAggregator::createCache()
Creating daemon cache for AWD metrics
GyroBiasAWDStats
void CLGyroBiasAWDAggregator::loadCache()
Loading daemon cache for AWD metrics
bool CLGyroBiasAWDAggregator::loadCache(NSDictionary *)
imageCaptures,[%d,%d,%d,%d,%d,%d],endConditions,[%d,%d,%d,%d,%d,%d],biasChanges,[%d,%d,%d,%d,%d,%d,%d,%d],minDuration,%llu,maxDuration,%llu,meanDuration,%llu,minTemperature,%5.2f,maxTemperature,%5.2f
void CLGyroBiasAWDAggregator::storeCache()
Saving daemon cache for AWD metrics
EndConditions
ImageCaptures
Corrections
Durations
Temperatures
pty.nmea
CLAccessoryLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Accessory/CLAccessoryLocationProvider.mm
-[CLAccessoryLocationProviderAdapter beginService]
accessory
geomapfeatureaccess
ephemeris/
CLAccessoryLocationProvider::CLAccessoryLocationProvider(id<CLIntersiloUniverse>)
could not create path %{public}s
StarkNmeaPipeEnabled
IgnoreAccessoryLocations
IgnoreAccessoryLocations,%{public}d
EnableAccessoryNMEAScreening
EnableAccessoryNMEAScreening,%{public}d
registered for app client notifications
virtual CLAccessoryLocationProvider::~CLAccessoryLocationProvider()
unregistered for app client notifications
virtual bool CLAccessoryLocationProvider::registerForNotificationInternal(const CLLocationProvider_Type::Notification &)
EnableAccessoryNMEAScreening,0,airborne,1
PauseExternalLocation,1
virtual bool CLAccessoryLocationProvider::unregisterForNotificationInternal(const CLLocationProvider_Type::Notification &)
EnableAccessoryNMEAScreening,1,airborne,0
PauseExternalLocation,0
void CLAccessoryLocationProvider::registerForNotifications()
registered for unfiltered location notifications
registered for propagated location notifications
void CLAccessoryLocationProvider::unregisterForNotifications()
unregistered for unfiltered location notifications
unregistered for propagated location notifications
NMEA
CLGpsAssistant
void CLAccessoryLocationProvider::startLocation()
Accessory,StartLocation,IgnoreAccessoryLocation,%{public}d
void CLAccessoryLocationProvider::sendReferenceTime()
#Warning no reference time available, not sending reference time
void CLAccessoryLocationProvider::sendReferenceLocation()
#Warning location services is disabled, not sending reference location
#Warning no reference location available, not sending reference location
void CLAccessoryLocationProvider::sendReferenceEphemeris()
#Warning ephemeris %s not available
could not create input stream for ephemeris file, %{public}s
could not create data from file %{public}s
void CLAccessoryLocationProvider::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#Warning received an unknown location notification %d
void CLAccessoryLocationProvider::openNmeaPipe()
Unable to open nmea fifo FD %d %s.
void CLAccessoryLocationProvider::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
CLAccessoryAWD,%{public}.1lf,NmeaScreener reset
CL-AccessoryPropagated
void CLAccessoryLocationProvider::sendPropagatedLocation(const CLLocationProvider_Type::NotificationData &)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Speed,%.2f,Course,%.2f,timestampGps,%.2lf,GgaOnly,integrity,%d
void CLAccessoryLocationProvider::updateLocationAppStatus(const std::string, const bool)
CLAccessoryAWD,%{public}.1lf,machContTime,%{public}.1lf,onApp,newApp,%{private}s
void CLAccessoryLocationProvider::onAppNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)
CLAccessoryAWD,%{public}.1lf,machContTime,%{public}.1lf,onApp,ReceivedAppNotification,%{public}d,%{private}s
void CLAccessoryLocationProvider::onBatteryNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
CLAccessoryAWD,%{public}.1lf,ReceivedBatteryNotification,connected,%{public}d,type,%{public}d
void CLAccessoryLocationProvider::onNavigationStateChange(const CLClientNavigationState)
CLAccessoryAWD,%{public}.1lf,RouteListener,navstate,%{public}d
CLAccessoryLocationProvider::onEphemerisUpdated
CLAccessoryLocationProvider::onLocationNotification
CLAccessoryLocationProvider::onTimeNotification
CLAccessoryLocationProvider::onClientManagerNotification
CLAccessoryLocationProvider::onAppNotification
CLAccessoryLocationProvider::onBatteryNotification
static void CLDaemonStats::shutdownInstance()
could not store stats data 
stats
CLDaemonStats
EnableLocationAccessorySessionDebugLog
CLTelephonyService
CLAccessoryLocationProvider
v16@?0q8
CLBluetoothService
static void CLDaemonStats::fetchLocationSystemStateWithReply(id<CLIntersiloUniverse>, void (^)(const CLDaemonStats_Type::LocationSystemState &))_block_invoke
location system state, cell available, %d, wifi available, %d, passcode locked, %d, airplane mode enabled, %d, accessory connected, %d, reachability, %d, powered, %d, gpsCoexWifi, %d, gpsCoexBt, %d
Location Stats
void CLDaemonStats::submitMetric(const CLDaemonStats_Type::LocationServicesState &)
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,enabled,%d,event,%d
void CLDaemonStats::submitMetric(const CLDaemonStats_Type::LocationServicesApproval &)
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,bundleIdApproved,%s,approved,%d,authorization,%d,
void CLDaemonStats::submitMetric(const CLDaemonStats_Type::LocationUpdateSession &)
The sum of the delivered locations by type (%d) does not equal the delivered locations counter (%d).
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,cellAvailable,%d,wifiAvailable,%d,passcodeLocked,%d,airplaneMode,%d,reachability,%d,accessoryConnected,%d,powered,%d,gpsCoexWifi,%d,gpsCoexBt,%d,timestampEnd,%.3f,duration,%.3f,desiredAccuracy,%.2f,achievedAccuracy,%.2f,ttff,%.3f,ttffGps,%.3f,achievedSpeed,%.2f,autoStopped,%d,deferredLocations,0,deliveredLocations,%d,deliveredLocationsByType,%s,deliveredLocationsByTypeFraction,%s,sdeliveredLocationsUndefined,%d,deliveredLocationsUndefinedFraction,%.4f,validDeliveredLocationsByType,%d
com.apple.locationd.LocationUpdateSession
valid
bundleId
cellAvailable
wifiAvailable
passcodeLocked
accessoryConnected
powered
gpsCoexWifi
gpsCoexBt
desiredAccuracy
achievedAccuracy
ttff
ttffGps
achievedSpeed
autoStopped
deliveredLocations
deliveredLocationsUnknown
deliveredLocationsUnknownFraction
deliveredLocationsGps
deliveredLocationsGpsFraction
deliveredLocationsNmea
deliveredLocationsNmeaFraction
deliveredLocationsAccessory
deliveredLocationsAccessoryFraction
deliveredLocationsWifi1
deliveredLocationsWifi1Fraction
deliveredLocationsSkyhook
deliveredLocationsSkyhookFraction
deliveredLocationsCell
deliveredLocationsCellFraction
deliveredLocationsLac
deliveredLocationsLacFraction
deliveredLocationsMcc
deliveredLocationsMccFraction
deliveredLocationsGpsCoarse
deliveredLocationsGpsCoarseFraction
deliveredLocationsIndoor
deliveredLocationsIndoorFraction
deliveredLocationsWifi2
deliveredLocationsWifi2Fraction
deliveredLocationsCompensated
deliveredLocationsCompensatedFraction
deliveredLocationsLoiOverride
deliveredLocationsLoiOverrideFraction
deliveredLocationsUndefined
deliveredLocationsUndefinedFraction
validDeliveredLocationsByType
void CLDaemonStats::submitMetric(const CLDaemonStats_Type::LocationMonitorSession &)
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,fenceRadiusMin,%.2f,fenceRadiusMax,%.2f,numFences,%d,numFencesRemoved,%d,slc,%d,
void CLDaemonStats::submitMetric(const CLDaemonStats_Type::LocationMonitorTrigger &)
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,cellAvailable,%d,wifiAvailable,%d,passcodeLocked,%d,airplaneMode,%d,eventType,%d,eventRadius,%.2f,eventDistance,%.2f,eventLatency,%.3f,eventMask,0x%x,sinceLast,%{private}.1f,fenceType,%{private}d,fenceAPs,%{private}d,boundedFenceAps,%{private}d,totalAPs,%{private}d,conservative,%{private}d,emergency,%{private}d,polygonal,%{private}d,throttled,%{private}d,inVehicle,%{private}d,driving,%{private}d,static,%{private}d,pedestrian,%{private}d
kUnknownMethod
kMSBased
kMSAssisted
kStandalone
kMSAssistedPreferred
kMSBasedPreferred
kOTDOA
kECID
kAFLT
kEOTD
kNoPosition
UnhandledMethod
kUnknownSession
kControlPlane
kUserPlane
kSIP
kAML
kEED
kWlanControlPlane
kWlanUserPlane
kEED1_5
kEED2
kUnknownProtocol
kRRLP
kRRC
kLPP
kLPPe
kIS801
kTextSMS
kBinarySMS
kHTTPS
UnhandledProtocol
kWifi
UnhandledRAT
kUnknownReportType
kSingleshot
kPeriodic
kAreaEvent
UnhandledReport
kSuccess
kAborted
kTimeout
kProtocolError
kNetworkAbort
kNoAssistance
kNotEnoughSatellites
kMethodNotSupported
kBasebandAbort
kBasebandDisconnect
kEmergencyCallEnd
kOverridden
kBadState
kCarrierUpdate
kOperatorUpdate
kConnSSLFail
kConnGenericFail
kConnReadFail
kConnGetFdFail
kConnWriteFail
kVersionMismatch
kDecodeError
kInvalidSessionId
kHslpAddressMismatch
kSuplNotAllowed
kAlreadyInSession
kUnknownError
kNotInCellularEmergency
kInvalidSMS
kRoamingNotSupported
kPhoneNumberUnavailable
kOutsideCoverageArea
kWlanMethodNotSupported
kWlanMeasNotAvailable
kWlanSessionTimeout
kWlanErrorUndefined
UnhandledError
kHELOUsageUnknown
kHELOUsageUsed
kHELOUsageUnused
UnhandledHELOUsage
kInvalid
kDisabled
kEnabled
kNotSupported
kUnknown
UnhandledTandemCapability
kUnknownAvailability
kUnavailable
kNativeNumberOnly
kCompanionNumberOnly
kNativeAndCompanion
UnhandledPhoneNumberAvailability
kCommTypeUnknown
kCommTypeVoice
kCommTypeText
UnhandledCommunicationType
kAbortCauseTypeBbInvalid
kAbortCauseTypeBbUnknown
kAbortCauseTypeBbNetwork
kAbortCauseTypeBbGaurdTimeout
kAbortCauseTypeBbRATLoss
kAbortCauseTypeBbEmgModeEnd
kAbortCauseTypeBbCPOverride
kAbortCauseTypeBbEndOfPeriodic
kAbortCauseTypeApUnknown
kAbortCauseTypeApTimeout
kAbortCauseTypeApSessionOverride
kAbortCauseTypeApEmgModeEnd
UnhandledAbortCauseType
kNormalDialer
kLockscreenDialer
kSosUnknown
kSosMultiPress
kSosClaw
kSosButtonHold
kSosFallDetection
kSosEcg
EmergencyLocation
void CLDaemonStats::submitMetric(const CLDaemonStats_Type::MainHarvesterMetrics &)
metric.valid,%d,metric.timestamp,%.3f,metric.metricsIdentifier,%s,metric.reachabilityNotifications,%u,metric.batteryNotifications,%u,metric.thermalNotifications,%u,metric.locationNotifications,%u,metric.rawGpsNotifications,%u,metric.validatedGpsNotifications,%u,metric.managerNotifications,%u,metric.durationMinimumUploadRequirementsMet,%.3f,metric.durationMinimumUploadRequirementsNotMet,%.3f
MotionTriggerMaxPrototypes
void CLDaemonStats::submitMetric(const CLDaemonStats_Type::MotionTrigger &)
Max prototypes overriden to %d
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,timestampEnd,%.3f,duration,%.3f,motionType,%d,numTriggers,%d,prototypes,%zu,%s
void CLDaemonStats::submitMetric(const CLDaemonStats_Type::MotionPedometerCalibration &)
metric.valid,%d,metric.timestamp,%.3f,step,%d,distance,%.2f,timeLength,%.2f,score,%.2f,trackdistance,%.2f,kfactor,%.2f,kfactorupdated,%.2f
CLTilesManager
CLLocationController
CLCompanionActivityAWDAggregator
LocationMetrics
Client
Emergency
Gnss
FilteredLocationController
CLFilteredLocationControllerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLFilteredLocationController.mm
-[CLFilteredLocationControllerAdapter beginService]
filtered
virtual bool CLFilteredLocationController::unregisterForNotificationInternal(const CLLocationProvider_Type::Notification &)
CLIENT: Clearing cached notification for %d
virtual bool CLFilteredLocationController::registerForNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::RegInfo &)
CLIENT: %d, registerForNotification, distanceFilter, %.1lf, checkInterval, %.1lf, sleepProof, %d, operatingMode, %d
CLIENT: register for notification, %d, %s
virtual bool CLFilteredLocationController::unregisterForNotification(int, const CLLocationProvider_Type::Notification &)
CLIENT: unregister for notification, %d, %s, wasRegistered, %d
virtual bool CLFilteredLocationController::shouldNotifyClient(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &, const char &, CLLocationProvider_Type::RegInfo &)
<%+.8f,%+.8f> is stale from %.3fs ago, not using for distance filtering
distance filter %.2f not exceeded by <%+.8f,%+.8f> and <%+.8f,%+.8f> (distance %.2f)
regular
fine
coarse
void CLFilteredLocationController::onLocationTimer()
Now registered for %s location notifications, operating mode %d
no more location clients - not re-registering
void CLFilteredLocationController::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
leaving location as it would turn on in %.3fs anyway
turning off location requests and re-scheduling for %.3fs later
Best
Fine
Coarse
void CLFilteredLocationController::logRequiredNotificationLevel(bool)
@ClxClient, accuracy, %{public}d, %{public}d, %{public}d, level, %{public}s, reg?, %{public}d
kNotificationLocation
kNotificationLocationCoarse
kNotificationLocationFine
void CLFilteredLocationController::checkMinimumDistanceFilter()
CLIENT: notification, %s, clients, %lu, distanceFilter, %.1lf, sleepProof, %d
#Warning Ignoring request for sleep-proof location updates with no check interval
CLIENT: distanceFilter, %.1lf, fDistanceFilter, %.1lf
minimum distance unchanged from %.3f, still requesting location at %.3f (%.3fs away)
minimum distance changed to %.3f from %.3f
scheduling location requests for %.3fs later
no location currently available, starting it immediately
wake interval unchanged from %.3f, still waking at %.3f (%.3fs away)
wake interval changed to %.3f from %.3f
void CLFilteredLocationController::onManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
#Warning Location Services reset, clearing local cache
#Warning Location Services state changed, clearing local cache
virtual void CLFilteredLocationController::lastConfidentLocationNotification(const CLDaemonLocation &)
Cached location,%.8lf,%.8lf,HorAcc,%.1lf,Type,%s,Confidence,%d,Timestamp,%.3f,Lifespan,%.3f,Age,%.3f,integrity,%d
No valid last confident location
CLFilteredLocationController
CLFilteredLocationController::onLocationNotification
CLFilteredLocationController::onManagerNotification
void CLNmeaScreener::ExternalLocationData::fillData(const CLLocationProvider_Type::NotificationData &)
CLNmeaScreener,type,%d,lat,%{private}.8lf,lon,%{private}.8lf,timestampGPS,%.1lf,machContTime,%.1lf,fHorizontalUncertainty,%.1lf
CLNmeaScreener::CLNmeaScreener(CLNmeaScreener::NMEAScreenerCallback)
CLNmeaScreener,fSimulatorMode,1
void CLNmeaScreener::updateExternalLocation(const CLLocationProvider_Type::NotificationData &)
%s,invalid location input,type,%d
CLRegionPreloadManifestTile-Mutex
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLRegionPreloadManifestTile.mm
virtual bool CLRegionPreloadManifestTile::traverseTileFile(FILE *, const CLTileFile::TraverseDetails &)
Traversing preload manifest file
Preload manifest tile size = %lu
failed to allocate transit tile
failed to decode transit tile protobuf, encrypted=%{public}lu tile=%{public}s
failed to get fields in manifest
ver,%d,x,%d,y,%d,generated,%.01lf,age,%.01f,ageThresh,%d
Reading new market, {%.06lf,%.06lf}, {%.06lf,%.06lf}
Adding new tile to market, [%.06lf,%.06lf]
loaded transit tile %s with %lu regions
CLRegionPreloadManifestTile(
super=
, numMarkets=
IsSimulator
%@ %@ (%@)
<null>
<name>
<version>
<build>
hw.model
IOPlatformExpertDevice
IOPlatformSerialNumber
NotAvailable
CLPlatformInfo::Provider CLPlatformInfo::getProviders()_block_invoke
unknown hardware type %{private}d
watch-companion
ReleaseType
NonUI
InternalBuild
GpsForcePlosSupport
bool CLPlatformInfo::supportsPLOS()
#Warning PLOS: ignoring hw. forceSupport,%d
StoreDemoMode
com.apple.demo-settings
GpsForceSupportOutdoorMatching
bool CLPlatformInfo::supportsOutdoorMatching()
#Warning OBM, ignoring hw. forceSupport,%d
static CLPlatformInfo::MotionProviders CLPlatformInfo::motionProviders()
Unsupported HW type %d; file a radar to CoreMotion Factory | 1.0
compass
CLPlatformInfo::MotionCapabilities CLPlatformInfo::queryMotionCaps()
Unsupported HW type %{private}d; file a radar to CoreMotion Factory | 1.0
3kmXfug8VcxLI5yEmsqQKw
static bool CLPlatformInfo::inDiagnosticsMode()_block_invoke
Booted in to diagnostics mode
supportsBBTimeFreqTransfer
supportsGnssTrackingSkyMap
supportsGnssDisablementAssertion
externalLocationDisablementAllowed
FProgramNumber
static double CLFitnessYouthBriskWalkOverride::bestSpeed(const CLNatalieModelInput &)
beginTime, %{public}f, distanceSource, %{public}d, bestSpeed, %{public}f, pedSpeed, %{public}f, uncalibratedSpeed, %{public}f, currentCadence,%{public}f
virtual CLMotionActivity::TypeYouth CLFitnessYouthBriskWalkOverride::doOverride(CLMotionActivity::TypeYouth, const CLNatalieModelInput &)
Overriding youth type for brisk walk, beginTime, %f, before, %{public}d, after, %{public}d, speed, %{public}f, speedThreshold, %{public}f
Overriding youth type for nonzero speed, beginTime, %f, before, %{public}d, after, %{public}d, speed, %{public}f
bool CLMapMatcherOperatingPolicy::CLMapMatcherOperatingRegions::canMapMatch(const CLSignalEnvironmentProvider_Type::SignalEnvironmentType, const CLClientLocationCoordinate &)
CLMM,MA-OTA,MM disabled for this country
CLMM,MA-OTA,initialCheck,signalEnv,%{public}d,isSEOk,%{public}d,size,%{public}d,isPolygonOK,%{public}d,size,%{public}d,isInsideSkippedPolygon,%{public}d,size,%{public}d,dtSinceLastMMStateChangedBasedOnSE,%{public}.1lf,mmStateBasedOnSE,%{public}d
CLMM,MA-OTA,seStateChanged,prevSEState,%{public}d,newSEState,%{public}d
CLMM,MA-OTA,seCheck,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d,early return due to failed se check - polygon not checked)
CLMM,MA-OTA,polygonCheck,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d,inside,%{private}s
CLMM,MA-OTA,polygonCheck,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d,early return due to failed polygon check - skipregion not checked)
CLMM,MA-OTA,skipRegionCheck,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d,inside,%{private}s
CLMM,MA-OTA,final,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d
void CLMapMatcherOperatingPolicy::CLMapMatcherOperatingDynamics::determineOperatingDynamics(const CLDaemonLocation &, const CLDaemonLocationPrivate &, const CLMotionActivity &, const CLMotionActivity::Type &, const std::string &, const CLSignalEnvironmentProvider_Type::SignalEnvironmentType, const CLClientLocationCoordinate &)
CLMM,%{public}.1lf,operatingDynamics,overwriting machContinuousTime,machContinuousTime,%{public}.1lf
CLMM,%{public}.1lf,operatingDynamics,not matching,non-terrestrial speedMps,%{public}.2lf,threshold,%{public}.1lf
CLMM,%{public}.1lf,operatingDynamics,pedestrian matching,routehints,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,vehicle matching,routehints,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,cycle matching,routehints,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,sticking to last dynamics,%{public}d,timeInCurrentMode,%{public}.1lf
CLMM,%{public}.1lf,operatingDynamics,pedestrian matching,walking dynamics,speed,%{public}.2lf,wasRecentlyWalking,%{public}d,motion,%{public}d,fitness,%{public}d
CLMM,%{public}.1lf,operatingDynamics,cycling matching,cycling dynamics,speed,%{public}.2lf,wasRecentlyCycling,%{public}d,motion,%{public}d,fitness,%{public}d
CLMM,%{public}.1lf,operatingDynamics,vehicle matching,vehicle dynamics,speed,%{public}.2lf,wasRecentlyDriving,%{public}d
CLMM,%{public}.1lf,operatingDynamics,pedestrian matching,wasRecentlyWalking,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,vehicle matching,wasRecentlyDriving,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,cycle matching,wasRecentlyCycling,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,vehicle matching,highSpeed,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics, activity based pedestrian map-matching not allowed,%{public}d, or country not supported,%{private}s, setting unknown
CLMM,%{public}.1lf,operatingDynamics, pedestrian map-matching not allowed, setting unknown
CLMM,%{public}.1lf,operatingDynamics, activity based cycling map-matching not allowed,%{public}d, or country not supported,%{private}s, setting unknown
CLMM,%{public}.1lf,operatingDynamics, cycling map-matching not allowed, setting unknown
CLMM,%{public}.1lf,operatingDynamics,fDynamics,%{public}d,dynamics,%{public}d,currentCountry,%{private}s
void CLALSIndoorOutdoorDetector::feedALSScanResult(const CLALSLuxResult &)
IndoorOutdoor,ALSScan,lux,%{public}.0f,t,%{public}f
float CLALSIndoorOutdoorDetector::computeOutdoorProbability()
IndoorOutdoor,ALSResult,outputProb,%{public}.2f,rawProb,%{public}.2f,meanLux,%{public}.2f,stdLux,%{public}.2f,n,%{public}d,elevation,%{public}.2f,hasLatLon,%{public}d
CLSensorMonitorSilo
CLBeaconMonitorDatabase::CLBeaconMonitorDatabase(const CLSqliteDatabase::SqliteProperties &, const CLSqliteDatabase::ColumnInfo *)
iB: state No access to state DB
BeaconStatus
void CLBeaconMonitorDatabase::clearLocationData()
iB: state No access to DB
bool CLBeaconMonitorDatabase::storeFenceState(const CLBTLEBeaconRegion_Type::MonitoredRegion &, CLBTLEBeaconRegion_Type::RegionStates)
iB: state Invalid for DB
iB: state store, %{private}lld, %{private}d, %{private}s
#Warning iB: state Couldn't bind statement for store (%{private}s)
bool CLBeaconMonitorDatabase::removeFenceState(const CLBTLEBeaconRegion_Type::MonitoredRegion &)
iB: state remove, %{private}lld, %{private}s
#Warning iB: state couldn't bind statement for deleting (%{private}s)
bool CLBeaconMonitorDatabase::scrubFenceStates(const std::vector<CLBTLEBeaconRegion_Type::MonitoredRegion> &)
iB: state can't scrub DB
iB: state scrub, remaining, %{public}lu
CLBTLEBeaconRegion_Type::RegionStates CLBeaconMonitorDatabase::getFenceState(const CLBTLEBeaconRegion_Type::MonitoredRegion &)
iB: state couldn't bind (%{private}s)
iB: state doesn't exist (%{private}s)
iB: state Error in retrieving state for %{private}s
iB: state get, %{private}lld, %{private}d, %{private}s
com.apple.CoreMotion.MagnetometerReset
successFlag
!_enabled
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Transit/CLRouteListener.mm
-[CLRouteListener enable]
CLC: Enabled
-[CLRouteListener disable]
#Warning CLC: Disable CLRouteListener when already disabled, shutdown?
CLC: Disable
-[CLRouteListener navigationListener:didUpdateRouteSummary:]
CLC: Received a route, %{public}d,%{public}d,%{public}d,%{public}d
#Warning CLC: Starting route without an appoximate location
-[CLRouteListener navigationListener:didUpdateTransitSummary:]
CLC: Received a transit route
-[CLRouteListener navigationListener:didUpdateGuidanceState:]
CLC: Received a state change, %{public}d,%{public}d,%{public}d,%{public}d
-[CLRouteListener logRoute:]
CLC: Route type        : %{private}d, %{private}@
Has origin
CLC: Route origin      : %{public}s
Has destination
CLC: Route destination : %{public}s
CLC: Route dest name   : %{private}@
CLC: Route travel time : %{private}.01lf
-[CLRouteListener logTransitRoute:]
CLC: Transit Stop:
CLC:     ID  : %{private}llu
CLC:     LAT : %{private}lf
CLC:     LON : %{private}lf
CLC: Transit Link:
CLC:     DEP : %{private}lf
CLC:     ARR : %{private}lf
CLC:     Stop From :
CLC:         ID  : %{private}llu
CLC:         LAT : %{private}lf
CLC:         LON : %{private}lf
CLC:     Stop To :
-[CLRouteListener logState:]
CLC: Guidance Level   : %{public}@
CLC: Navigation State : %{public}@
CLC: Transport Type   : %{private}@
-[CLRouteListener onDarwinNotification:data:]
CLC: navigation stopped
CLClientNavigationState GEONavigationStateToCLClientNavigationState(const GEONavigationState)
CLC: Received a unsupported GEONavigationState, %d
AUTOMOBILE
TRANSIT
WALKING
BICYCLE
UNKNOWN_TRANSPORT_TYPE
FERRY
RIDESHARE
NONE
PREPARE_TO_TRAVEL
TRACKING
TURN_BY_TURN
NOT_NAVIGATING
PROCEEDING_TO_ROUTE
ON_ROUTE
OFF_ROUTE
BAD_ROUTE
RECALCULATING
END_OF_ROUTE
END_OF_SEGMENT
OUTSIDE_NAVIGABLE_AREA
DumpCompassCalibrationDatabaseOnCompassStart
CompassInterval
CompassIgnoreGyro
CLCompass6::CLCompass6()
Legacy compass, interval (%{public}.3f) gyro (%{public}d)
virtual void CLCompass6::start(bool)
Legacy compass started. Cover attached %{public}d
%.0f
virtual void CLCompass6::start(bool)_block_invoke
Dumped compass cal database with id %@
Compass is requesting device motion with mode %{public}#x
virtual void CLCompass6::stop()
Legacy compass stopped.
static void CLCompass6::onMagnetometerData(const CLMagnetometer::Sample *, void *)
Notify after %{public}.3f seconds of no event.
CompassAlignment
Type,%s,compassJustAlignedToStableField,%d,timestamp,%20.20f
Type,%s,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f
notified clients. sampleCount,%d,compass.compass.calibrationLevel,%d,compass.timestamp,%f
markets
associatedStoreIdentifiers
muid
resultProviderIdentifier
void CLWorkoutActiveStateDetector::updateModel()
CLWorkoutActiveStateDetector,sending event %d
void CLWorkoutActiveStateDetector::feedExternalActiveState(bool, CFAbsoluteTime)
CLWorkoutActiveStateDetector,sending external active state %d
void CLWorkoutActiveStateDetector::setWorkoutType(CMWorkoutType)
CLWorkoutActiveStateDetector,setting workout type to,%{public}ld
CLWorkoutActiveStateDetector,workout type didn't change,%{public}ld
virtual CLWifiService_Type::AssociationState CLWifiLocationProviderExternal::getAssociatedState(bool) const
WIFI_LOC: failed to get power state
virtual bool CLWifiLocationProviderExternal::startWifiScan(CLWifiService_Type::ScanType, bool, bool, std::string, const std::optional<CLWifiService_Type::Channels> &) const
@WifiFlow, scanreq, %{public}s, %{public}s, result, %{public}d
CLWifiLocationProvider::onWifiNotification
CLWifiLocationProvider::onClientNotification
CLWifiLocationProvider::onNetworkLocationNotification
CLWifiLocationProvider::onStatusNotification
CLWifiLocationProvider::onCompanionNotification
CLWifiLocationProvider::onMotionNotification
CLWifiLocationProvider::onLocationNotification
CLWifiLocationProvider::onSignalEnvironmentNotification
CLWifiLocationProvider::onOdometerNotification
nCatherine
nVeryLowCatherine
nLowCatherine
nHighCatherine
nVeryHighCatherine
nGoodCatherine
nInterpolatedCatherine
nSampleAndHoldCatherine
minGoodCatherine
maxGoodCatherine
meanCatherine
meanGoodCatherine
firstCatherine
firstCatherineStartTime
longestDropout
totalDropoutTime
nDropout
onsetReason
onsetCatherine
userMaxCatherine
persistedMinHR
kOnsetNotSet
kOnsetElevated
kOnsetActive
kOnsetNotElevated
kOnsetTimeout
CLBTLEFenceManagerConcrete::CLBTLEFenceManagerConcrete(id<CLIntersiloUniverse>)
#Warning Overriding FenceStartDelay,%{private}.2f
iB: Scheduling initialization delay,%{private}.2f, silo,%{private}p
void CLBTLEFenceManagerConcrete::unlockedInitialize()
iB: Already initialized
btle_fence_installed
btle_fence_uninstalled
virtual void CLBTLEFenceManagerConcrete::requestRegionState(const CLBTLEBeaconRegion_Type::MonitoredRegion &)
iB: Region,%{private}s, has state,%{private}d
#Warning Unable to find region,%{private}s, in the cache
#Warning Authorization error,%{public}d, while requesting state for region,%{private}s
virtual void CLBTLEFenceManagerConcrete::simulateBeaconEvent(const std::string &, int, int, CLBTLEBeaconRegion_Type::RegionStates)
@iB: Simulating Beacon : %s.%d.%d  RegionState : %d
@iB: Simulating Beacon : beacon notification sent
void CLBTLEFenceManagerConcrete::onAuthorizationNotification(int, const CLBeaconFenceAuthorizationManager_Type::Notification &, const CLBeaconFenceAuthorizationManager_Type::NotificationData &)
Unable to monitor the zone for region,%{private}s
#Warning iB: state kNotificationFenceResume, before first unlock
iB: Already resumed monitoring for fence,%{private}s
Unable to unmonitor the zone for fence,%{private}s
iB: state kNotificationFenceSuspend, before first unlock
iB: Fence,%{private}s, is not being monitored, the suspension request will be ignored
btle_fence_resume
btle_fence_suspend
void CLBTLEFenceManagerConcrete::onBeaconNotification(int, const CLBTLEBeaconProvider_Type::Notification &, const CLBTLEBeaconProvider_Type::NotificationData &)
#Warning iB: state changed before first unlock
void CLBTLEFenceManagerConcrete::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
iB: Warning data can't be cleared yet
virtual bool CLBTLEFenceManagerConcrete::registerForNotification(int, const CLBTLEFenceManager_Type::Notification &, const std::string &)
iB: Pending notification for fence,%{private}s, state,%{private}d, has expired
void CLBTLEFenceManagerConcrete::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
iB: state kNotificationDeviceUnlockedSinceBoot, from, %{public}d, to, %{public}d, start, %{public}d
void CLBTLEFenceManagerConcrete::createStateDatabase(const char *)
iB: createStateDatabase, fStateDatabase, %{private}p, fDeviceUnlockedSinceBoot, %{public}d, reason, %{public}s
CLBTLEFenceManagerConcrete::onDataProtectionNotification
CLBTLEFenceManagerConcrete::onClientManagerNotification
CLBTLEFenceManagerConcrete::onAuthorizationNotification
CLBTLEFenceManagerConcrete::onBeaconNotification
CLBTLEFenceManagerConcrete::onDaemonStatusNotification
Pending iBeacon notification
void CLGnssAvailabilityPredictor::ALSProcessor::measurementInput(const CLAmbientLightDecisionTreeOutput, const CFTimeInterval)
AmbientLightDecisionTreeOutput,%{public}d
ALSProcessor,FilterReset,timestamp,%{public}.2f,lastTimestamp,%{public}.2f
userMets
truthMets
userMetsSource
truthMetsSource
metsFM
kFitnessMachine
WifiTileBlobs
CLWifiTileHeaderDatabase::CLWifiTileHeaderDatabase(const std::string &, const std::string &)
not connected to wifi #tile header table
No connection to database when attempting to open transaction.
bool CLWifiTileHeaderDatabase::saveWifiTileHeader(const CLWifiTileHeaderEntry &, std::optional<CLWifiTileParser::MemoryMappedFileHandle *>)
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
bool CLWifiTileHeaderDatabase::deleteByTileXY(const WifiTileXY &)
 = ? AND 
 = ? 
std::optional<CLWifiTileHeaderEntry> CLWifiTileHeaderDatabase::selectByTileXY(const WifiTileXY &)
int CLWifiTileHeaderDatabase::countTileHeaders()
failed to select count(*) from wifi #tile header table
isTimestampColumn
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Network/CLWifiTileHeaderDatabase.mm
updateTimestampByTileXY
bool CLWifiTileHeaderDatabase::updateTimestampByTileXY(cl::chrono::CFAbsoluteTimeClock::time_point, const WifiTileXY &, const std::string &)
 = ? WHERE 
 = ?
@TileList, touch, ignoring, 0, #CloneMe
failed to update timestamp of #tile header
std::optional<cl::chrono::CFAbsoluteTimeClock::time_point> CLWifiTileHeaderDatabase::selectAccessTimestampByTileXY(const WifiTileXY &)
std::vector<CLWifiTileHeaderEntry> CLWifiTileHeaderDatabase::selectAll()
SELECT NAME FROM sqlite_master WHERE type='table' AND name LIKE 'wifi_tile_%'
static std::unique_ptr<CLSqliteDatabase> CLWifiTileHeaderDatabase::connectAndCreateTableIfNotExistsIfNecessary(const std::string &, const CLSqliteDatabase::ColumnInfo *, const CLSqliteDatabase::SqliteProperties &)
failed to connect to wifi #tile header database
failed to connect to wifi #tile heeaders table
successfully created wifi #tile headers table
TileX
TileY
SouthwestLatitude
SouthwestLongitude
DeltaLatitude
DeltaLongitude
MinimumAltitude
MaximumAltitude
ExpirationAge
Version
Flags
NumberOfIndexEntries
AccessTimestamp
GizmoSyncTimestamp
NumberOfInputPoints
void CLSkiDataStore::setupFirstEntry()
Setting up first session entry
v24@?0{shared_ptr<std::vector<CLElevationChangeEntry>>=^v^{__shared_weak_count}}8
v24@?0{shared_ptr<std::vector<CLCoarseElevationChangeEntry>>=^v^{__shared_weak_count}}8
virtual void CLOdometerNotifierWatch::updatePhoneWorkoutElevationSubscription(bool)_block_invoke
Enabling kNotificationOdometerUpdateElevation from companion
Disabling kNotificationOdometerUpdateElevation from companion
virtual void CLOdometerNotifierWatch::registerForCyclingWorkoutDistanceUpdates(id<CLOdometerNotifierClientProtocol>)
Added client for cycling workout distance updates
virtual void CLOdometerNotifierWatch::unregisterForCyclingWorkoutDistanceUpdates(id<CLOdometerNotifierClientProtocol>)
Removed client from cycling workout distance updates
void CLOdometerNotifierWatch::updateCoarseElevationSubscription()
CoarseElevation,phone,1,watch,1
CoarseElevation,src,phone,0,watch,1
CoarseElevation,src,phone,1,watch,0
CoarseElevation,src,phone,0,watch,0
virtual void CLOdometerNotifierWatch::updateOdometerState()
Updating odometer state, authorized, %{public}d, has active clients, %{public}d, cycling distance controller, %{public}d
streaming odometer
void CLOdometerNotifierWatch::updateStateOnAuthorization(bool)
Update location authorization, current, %{public}d, new, %{public}d
void CLOdometerNotifierWatch::enableGPS()
Enable GPS; Start GPS subscription
void CLOdometerNotifierWatch::disableGPS()
Disable GPS; Stop GPS subscription
void CLOdometerNotifierWatch::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
watch:notifying elevation entry from phone
void CLOdometerNotifierWatch::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
Location batch notification size %{public}ld
#Warning Received unhandled location provider notification, %{public}d
static bool CLOdometerNotifierWatch::updateOdometerWithEntry(CLOdometerEntry &, double &, CLOdometerEntry &, CFAbsoluteTime)
Incoming odometer, %{private}.8f
#Warning Current odometer sample fails time check. Gps,%{public}.2lf,%{public}.2lf,startTime,%{public}.2lf,%{public}.2lf,odometer,%{private}.2lf,%{private}.2lf
Source may have reset. Gps,%{public}.2lf,%{public}.2lf,startTime,%{public}.2lf,%{public}.2lf,odometer,%{private}.2lf,%{private}.2lf
Odometer source change,previous,%{private}lf,current,%{private}lf,previousType,%{public}d,type,%{public}d
void CLOdometerNotifierWatch::notifyLocation(const CLDaemonLocation &, const CLDaemonLocationPrivate &)
Drop entry! distance, %{private}.8f, startTime, %{public}.8f, gps altitude, %{private}.8f, odometer, %{private}.8f, accuracy, %{public}.8f, gpsSpeed, %{private}.8f, gpsSpeedAccuracy, %{public}.8f, timestampGps, %{public}.8f, rawSpeed, %{private}.8f, originDevice, %{public}d, locationType: %{public}d
Notifying odometer clients, distance, %{private}.8f, startTime, %{public}.8f, gps altitude, %{private}.8f, odometer, %{private}.8f, accuracy, %{public}.8f, gpsSpeed, %{private}.8f, gpsSpeedAccuracy, %{public}.8f, timestampGps, %{public}.8f, rawSpeed, %{private}.8f, originDevice, %{public}d, locationType, %{public}d, groundAltitude, %{private}.8f, groundAltitudeUncertainty, %{public}.8f, smoothedGPSAltitude, %{private}.8f, smoothedGPSAltitudeUncertainty, %{public}.8f, gpsCourseRadians, %{private}.8f, gpsCourseAccuracy, %{public}.8f
PressureSensorSettlingTime
ElevationSourceTimeoutInterval
LogAllDayElevationFromAllSources
CLOdometerNotifierWatch::onCompanionNotification
CLOdometerNotifierWatch::onMotionStateMediatorNotification
CLOdometerNotifierWatch::onLocationNotification
CLOdometerNotifierWatch::onSignalEnvironmentNotification
CLCoarseElevationChangeEntry CLCoarseElevationFusion::feedSample(const CLCoarseElevationChangeEntry &)
onCoarseElevation,startTime,%.3f,ascended,%d,source,%d,fused,startTime,%.3f,ascended,%d,source,%d
auto CLOdometerNotifierWatch::notifyElevation(std::shared_ptr<CLElevationVector>)::(anonymous class)::operator()(const CLElevationChangeEntry &) const
watch:notifying elevation entry from watch
{vector<CLOdometerEntry, std::allocator<CLOdometerEntry>>=^{CLOdometerEntry}^{CLOdometerEntry}{__compressed_pair<CLOdometerEntry *, std::allocator<CLOdometerEntry>>=^{CLOdometerEntry}}}8@?0
bool CLWorkoutPredictorTier2Classifier::update(const CLWorkoutPredictorDMInput &, CLWorkoutClassifier_Type::CLWorkoutClassifierResult &)
CNNWorkoutClass,%d
GBTWorkoutClass,%d
LRWorkoutClass,%d
Tier2WorkoutClass,%d,CMWorkoutType,%ld,SmoothedCMWorkoutType,%ld,startTime,%f
void CLWorkoutPredictorTier2Classifier::setDeviceOrientation(const CLGizmoOrientation &)
DeviceOrientation,%d,%d
avgInterCalibrationTime
pctTurnsRejected
avgLapCorrection
numLaps
numLapInsertions
numLapsForConvergence
pctStrokesFailCurvature
pctStrokesFailMA
pctStrokesFailAccel
static void CLMetricCollectorBase::logStats(const CLSwimSessionStats &)
SessionStats,%s,%f,%s,%f,%s,%u,%s,%u,%s,%u,%s,%f,%s,%u,%s,%u,%s,%u,%s,%u,%s,%u,%s,%u
!_inTransaction
%s:%d: assertion failure in %s
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLClientManager_Unified.mm
-[CLClientManagerStateTracker initWithQueue:identifier:state:]
ClientManager
locationServicesEnabledStatus
locationRestricted
-[CLClientManagerStateTracker updateState:]
allStates
_CLClientManagerStateTrackerState
v8@?0
v16@?0^v8
static void CLClientManager::shutdownInstance()_block_invoke
could not store clients data
LocationManager
MotionActivityLite
InUseAssertion
LocationIndependenceAssertion
kCLConnectionMessageBBTimeFreqTransferAssert
kCLConnectionMessageGnssDisablementAssertReq
EmergencyEnablementAssertion
LaunchdManagedClients
!fUserEventAgentConnection
handleNewConnectionWithFirstMsg
void CLClientManager::handleNewConnectionWithFirstMsg(CLConnection *, std::shared_ptr<CLConnectionMessage>)
UserEventAgent connected (from %{public}s)
SpringTracking
DistributedSensing
void CLClientManager::createDaemonClient(CLConnection *, std::shared_ptr<CLConnectionMessage>)
Client %{public}s connected with message name %{public}s
CLTypeRegistrationResult CLClientManager::getClientStaticRegistrationResult(const CLClientManager_Type::Name &)
#Error no bundle ID or bundle path found - denying %{public}s
platform does not support system service, %{public}s, required capabilities.
bool CLClientManager::bigSwitchEnabledForClient(const std::string &)
location disabled system-wide, denying executable %{public}s
location emergency-enablement explicitly benefits %{public}s, not denying
location emergency-enabled with explicit beneficiaries, denying executable %{public}s
inflightAuthRequestIsNilClientKeyUnknown
CLTypeRegistrationResult CLClientManager::getClientEffectiveRegistrationResult(const CLClientManager_Type::Name &)
getClientEffectiveRegistrationResult, %{public}s, %{public}s, %{public}s, CLClientRegistrationResult, %{public}s, CLCommonLocationServicesEnabled, %{public}d
ProvisionalMonitoring
TemporaryAuthorization
void CLClientManager::checkVisitMonitoringStopped()
Couldn't get keys for client dictionary
void CLClientManager::checkSignificantLocationChangeStopped()
bool CLClientManager::mayTakeProcessAssertion(CLDaemonClient *)
mayTakeProcessAssertion,%d,background,%d,slc,%d
CLClientManager_Type::ClientState CLClientManager::getAggregateLocationAppInfo(CLDaemonClient *, bool)
client, '%s', app's client cnt, %d, active, %d, spectator, %d, batchEnabled, %d, desiredAccuracy, %.2f, distanceFilter, %.2f
ClientRemoved
void CLClientManager::cacheStatusOfClients()
Couldn't get keys for client dictionary, deauthorizing all clients
void CLClientManager::checkLocationServicesEnabledState(const std::string &, bool)
GPS_NETWORK: currentStatus(%d) isGpsControlledByNetwork(%d)
InUseLevel
clientStatus
IncidentalUseMode
void CLClientManager::getIncidentalUseMode(const CLClientManager_Type::Name &, void (^)(CLClientIncidentalUseMode))
#IncidentalUseMode able to get client's incidental use mode
#IncidentalUseMode  returning with value:%d
bool CLClientManager::setIncidentalUseMode(CLClientIncidentalUseMode, const CLClientManager_Type::Name &)
#IncidentalUseMode able to SET client's incidental use mode:%d
LocationButtonUseMode
granted
markClientTemporaryAuthorizationGranted
void CLClientManager::markClientEmergencyEnablementTransition(bool, const std::string &)
#CLEEA Emergency clients %d %s 1
#CLEEA adding emergency client,%{public}s
#CLEEA First emergency client connected
#CLEEA %{public}s is still an emergency client
#CLEEA removing emergency client,%{public}s
#CLEEA Last emergency client disconnected
com.apple.locationd.CLEEA
CLEmergencyController
ServiceMaskOperator
v28@?0@"NSString"8@"NSDictionary"16i24
void CLClientManager::markAlwaysAuthorizationUsedForClient(const CLClientManager_Type::Name &)
Considering whether to mark client, %s, for always power use
Not marking client %s as having used Always-powers (not Always authorized (%s))
!basePath.empty()
migrateLegacySLCSubscriptions
significant.plist
void CLClientManager::checkAppInstallationStatus()
could not retrieve bundle IDs
CLAppMonitor
CLClientManager
v24@?0@"NSArray"8@"NSArray"16
void CLClientManager::handleAppInstallationStatus(NSArray<NSString *> *, NSArray<NSString *> *)
installation check found %ld uninstalled apps (amongst %ld bundle IDs)
%s is missing
%s has been missing for %.3fs (safe harbor thershold: %.3fs)
updated AppUninstallTimer; next timer will fire in %.3fs
void CLClientManager::ensureTechnologyEnabled(CLClientManagerTechnology, CLDaemonClient *)
ImproveAccuracyNotification object not created for technology, %{public}s
DARmap.plist
void CLClientManager::reduceAccuracy(const CLClientLocation &, CLClientManagerReduceAccuracyReplyBlock)
DAR: could not read map file %{public}s
q24@?0@8@16
DAR map: %s
DAR map sorted keys: %s
void CLClientManager::reduceAccuracy(const CLClientLocation &, CLClientManagerReduceAccuracyReplyBlock)_block_invoke
DAR: original location: %.8f, %.8f, %.2f
DAR:  reduced location: %.8f, %.8f, %.2f
v192@?0{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}8d184
#Warning DAR: applying default quantization %f
DAR: applying new quantization %f based on ap count %d
v12@?0i8
DAR: applying cached quantization %f
iter != fGenericClients.end()
destroyGenericClient
void CLClientManager::destroyGenericClient(CLConnection *)
Client %{public}s disconnected
bool CLClientManager::wakeupLaunchdManagedClient(const std::string &)
Sending kCLConnectionMessageWakeClient for %{public}s to client '%{public}s'
kCLConnectionMessageClientNameKey
kCLConnectionMessageWakeClient
#Warning Can't find /usr/libexec/UserEventAgent connection for waking Client: <%s>
CLCM.AllowPromptRecording
version
com.apple.
global
kAuthorizationDecisionsConfirmationToken
com.apple.locationd.archived_authorization_decisions
kAuthorizationDecisionsNeedsMigration
com.apple.locationd.client.intermediation
ClientKey
Challenger
OnDeckDuration
nobody
CorrectiveCompensationEnabled
/System/Library/LocationBundles
/AppleInternal/Library/LocationBundles
void CLClientManager::enumerateBundles()_block_invoke
Setting client for bundle path %s
C16@?0r*8
v32@?0@"NSString"8Q16^B24
BeaconRegionTimeStarted
BeaconRegionTimeStopped
FenceTimeStarted
FenceTimeStopped
RangeTimeStarted
RangeTimeStopped
SignificantTimeStarted
SignificantTimeStopped
LocationTimeStarted
LocationTimeStopped
BackgroundLocationTimeStarted
BackgroundLocationTimeStopped
VisitTimeStarted
VisitTimeStopped
RemoteLocationTimeStarted
RemoteLocationTimeStopped
MicroLocationTimeStarted
MicroLocationTimeStopped
RemoteFenceTimeStarted
RemoteFenceTimeStopped
ReceivingLocationInformationTimeStarted
ReceivingLocationInformationTimeStopped
NonPersistentSignificantTimeStarted
NonPersistentSignificantTimeStopped
PushTimeStarted
PushTimeStopped
startKey && stopKey
getKeysForServiceType
NSLocationUsageDescriptionCarplay
com.apple.corelocation.CoreLocationRepromptAlwaysAuthPromptPlugin
LocationCount
LOCATION_REPROMPT_ALWAYS_TITLE
LOCATION_CLIENT_PERMISSION_REPROMPT_OTHER
LOCATION_CLIENT_PERMISSION_WHENINUSE_ONLY_BUTTON
LOCATION_CLIENT_PERMISSION_KEEP_ALWAYS_BUTTON
com.apple.corelocation.CLWatchOSTemporaryPreciseAuthPromptBundle
LOCATION_CLIENT_PERMISSION_PLAIN_WHEN_IN_USE_TITLE
LOCATION_CLIENT_PERMISSION_ONETIME_BUTTON
LOCATION_CLIENT_PERMISSION_WHENINUSE_BUTTON
LOCATION_CLIENT_PERMISSION_NEVER_BUTTON
LOCATION_CLIENT_PERMISSION_PLAIN_TITLE_FOR_LOCATION_BUTTONS
LOCATION_CLIENT_PERMISSION_EXPLANATION_FOR_LOCATION_BUTTONS
LOCATION_CLIENT_PERMISSION_ALLOW_LOCATION_BUTTONS
LOCATION_CLIENT_PERMISSION_DENY_LOCATION_BUTTONS
PRECISE_ON_PILL_BUTTON_TITLE
PreciseButtonOnTitle
PRECISE_OFF_PILL_BUTTON_TITLE
PreciseButtonOffTitle
com.apple.corelocation.CLWatchOSWhenInUseAuthPromptBundle
LOCATION_CLIENT_PERMISSION_WHENINUSE
LOCATION_CLIENT_PERMISSION_WHENINUSE_UNTIL_TOMORROW_BUTTON
LOCATION_CLIENT_PERMISSION_TITLE_FOR_LOCATION_BUTTONS
LOCATION_CLIENT_PERMISSION_UPGRADE_WHENINUSE_ALWAYS
LOCATION_CLIENT_PERMISSION_KEEP_WHENINUSE_BUTTON
LOCATION_CLIENT_PERMISSION_ALWAYS_BUTTON
LOCATION_CLIENT_PERMISSION_TEMPORARY_PRECISE_TITLE
LOCATION_CLIENT_PERMISSION_TEMPORARY_PRECISE_YES_BUTTON
LOCATION_CLIENT_PERMISSION_TEMPORARY_PRECISE_NO_BUTTON
UserLocationIsPrecise
LOCATION_CLIENT_PERMISSION_INCIDENTAL_USE_MODE_TITLE
LOCATION_CLIENT_PERMISSION_INCIDENTAL_USE_MODE_YES_BUTTON
LOCATION_CLIENT_PERMISSION_INCIDENTAL_USE_MODE_NO_BUTTON
LOCATION_CLIENT_PERMISSION_INCIDENTAL_USE_MODE_PURPOSE
com.apple.springboard
App asked us not to show prompts
Restrictions are enabled.  Changing authorization isn't allowed
App asked us too many times to show big switch re-enable prompt.
App is already presenting the user with an authorization prompt
CLTypeRegistrationResult CLClientManager::requestClientAuthorization(CLDaemonClient *, CLClientManager_Type::AuthorizationRequest, NSDictionary *)
#AuthPrompt Unrecognized/invalid request type: %{public}d
com.apple.reminders
com.apple.weather
com.apple.locationd.bundle-/System/Library/PrivateFrameworks/Weather.framework
Authorization
InterestZones
Type
Latitude
Longitude
Radius
Provenance
PromptedSettings
AuthorizationUpgradeAvailable
SyncedAuthorizationDecisionOnGizmo
AuthorizationConflictResolutionDuringAdd
com.apple.locationd.authsync
NSArray *CLClientManager::getDeltaSyncObjectsForClientsWithFirstAuthorizationDecisionOnGizmo()
#authsync getDeltaSyncObjectsForClientsWithFirstAuthorizationDecisionOnGizmo couldn't get keys for client dictionary
stopTime
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLClientManager.mm
updateRemoteClientUsage
void CLClientManager::synchronizeAuthorizationChangeTypeAdd(const std::string &, const char *, uint32_t, std::optional<uint32_t>, bool, const std::string &)
#authsync addObject: %{public}s %{public}u %{public}u %{public}d
void CLClientManager::synchronizeAuthorizationChangeTypeDelete(const std::string &, const std::string &)
#authsync deleteObject: %{public}s
void CLClientManager::sendResetNotification()
#authsync sending kNotificationReset to the watch
void CLClientManager::receiveResetNotification()
#authsync received kNotificationReset from the companion
com.apple.locationd.bundle-/System/Library/PrivateFrameworks/FindMyDevice.framework
CLClientManagerSilo
-[CLClientManagerAdapter beginService]
*nobody*
com.apple.Maps
lastWifiImproveAccuracyNotification
WifiImproveAccuracyNotificationInterval
lastBluetoothImproveAccuracyNotification
BluetoothImproveAccuracyNotificationInterval
CLClientManager::ImproveAccuracyNotification::ImproveAccuracyNotification(CLClientManagerTechnology)
last improve accuracy notification for %s, %f, retry interval, %f
Wifi
Bluetooth
void CLClientManager::ImproveAccuracyNotification::clear()
clear %s improve accuracy notification
v16@?0@"CLClientManagerStateTracker"8
clients
CLClientAuthorizationCache
CLStatusBarIconManager
CLZoneRelevanceMonitor
CLCapabilityMonitor
CLWifiTilesManager
v16@?0@"CLSettingsDictionary"8
ResetIdentifiers
ResetRetrialCount
CLClientManager::CLClientManager(id<CLIntersiloUniverse>)
ResetRetrialCount exhausted.
#authsync initializing sync store
CLAuthSyncManager
CLUsageSyncManager
#authsync isWatch: %{public}d, isCompanion: %{public}d
com.apple.locationd/Restrictions
DisableAppInstallationChecks
CLClientManager::UninstalledExpirationTimeInterval
NumEnablePromptsPerApplication
#warning Maximum location services enabled prompts per application overridden to %{public}d
UnsubscribeGraceDuration
Client unsubscription grace duration overridden to %{public}f
ClientKeysToFault
Will fault consumption score increases for %s
com.apple.locationd.registration
v32@?0{unique_ptr<CLConnection, CLConnectionDeleter>={__compressed_pair<CLConnection *, CLConnectionDeleter>=^{CLConnection}}}8{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}16
airplane mode enabled, %d.
failed to fetch airplane mode state.
/System/Library/PrivateFrameworks/iAdCore.framework
/Applications/AdSheet.app
/System/Library/Frameworks/Twitter.framework
/System/Library/Frameworks/Weibo.framework
/System/Library/Frameworks/Facebook.framework
/System/Library/SocialServices/Twitter.socialplugin
/System/Library/SocialServices/Weibo.socialplugin
/System/Library/SocialServices/Facebook.socialplugin
/System/Library/Frameworks/Social.framework/XPCServices/com.apple.twitter.xpc
/System/Library/Frameworks/Social.framework/XPCServices/com.apple.weibo.xpc
/System/Library/Frameworks/Social.framework/XPCServices/com.apple.facebook.xpc
Removing entry for bundle path %{public}s if present
/System/Library/PrivateFrameworks/Weather.framework
com.apple.Shoebox
/System/Library/PrivateFrameworks/PassKitCore.framework
com.apple.Passbook
/System/Library/PrivateFrameworks/Parsec.framework
/System/Library/PrivateFrameworks/CoreParsec.framework
#warning Can't migrate "%{public}s" to "%{public}s": client already exists with an auth of "%{public}d"
BundleId
BundlePath
Executable
Can't migrate "%{public}s" to "%{public}s": NVP failure
Migrated "%{public}s" to "%{public}s"
"%{public}s" not found, skipping migration
nullptr == fCrashGraceAssertionTimer
prepareForReconnectionOfClients
void CLClientManager::prepareForReconnectionOfClients()
#warning Can't get clients for filing crash-grace CLInUseAssertions
#warning Can't get client state for key:%{public}s to file crash-grace CLInUseAssertions
Client %s had ongoing background location, taking temporary crash-grace CLInUseAssertion
crash-grace
com.apple.locationd.client.statistics
SupportedAuthorizationMask
TimeMissing
com.apple.locationd.bundle-/System/Library/LocationBundles/WifiCalling.bundle
B16@?0r^v8
AggNoAlwaysApps
AggNoChosenCCOn
AggNoSSDisabled
AggNoIUEligible
AggNoIUDenied
AuthMask
CCStatus
IUMode
@"NSDictionary"8@?0
void CLClientManager::sendAppStatusNotification()_block_invoke
Sending app status change notification
void CLClientManager::handleDisconnection(CLConnection *)
Got disconnection for unknown client
iter != fDaemonClients.end()
handleDaemonClientDisconnection
void CLClientManager::handleDaemonClientDisconnection(CLConnection *)
!fAppUninstallationTimer
~CLClientManager
CLClientManager.unsubscribeGrace
CLClientManager.privacyReset
void CLClientManager::resetClients()
Skipping Reset, already in progress.
#warning location services settings are frozen by restrictions - resetting
resetting and disconnecting all clients from daemon
reset identifiers saved to settings
Registered
CFDictionaryRef CLClientManager::copyClients()_block_invoke
Client record is nil in CLClientManager::copyClients for clientKey %{public}@
v32@?0@8@16^B24
void CLClientManager::updateClientAllowableAuthorizationMask(const CLClientManager_Type::Name &, CLLocationDictionaryUtilitiesAuthorizationMask, bool)
Client %s allowable mask (%lu) no longer contains authorization level (%lu) downgrading to (%lu)
Client %{public}s missing for authorization update, but didn't we just create it?
Purpose
LocationDesiredAccuracy
LocationTechnologiesInUse
LocationDistanceFilter
BatchEnabled
void CLClientManager::setClientState(const CLClientManager_Type::Name &, const CLClientManager_Type::ClientState &)
currently %{public}lu non-system location clients
com.apple.locationd.bundle-/System/Library/LocationBundles/AppleWatchFaces.bundle
RemoteUsage
bool CLClientManager::setClientServiceActiveAtTime(const std::string &, CLClientServiceType, bool, bool, double, CLClientManager::Device)
#Warning, new start time for %s is after it's stored time
Service: key, %s, type, %s, active, %d
void CLClientManager::markClientServiceUsed(const CLClientManager_Type::Name &, CLClientServiceType)
Service: name, %s, type, %s, marked as used
void CLClientManager::clearAllClientsRemoteLocation()
couldn't get keys for client dictionary
void CLClientManager::clearClientRegions(const std::string &)
clearing regions for client '%s'
void CLClientManager::clearClientSignificantLocationChange(const std::string &)
clearing significant location change for client '%s'
AuthorizationRegisterTime
void CLClientManager::setClientMissingTime(const std::string &, const CFAbsoluteTime &)
How can an app be missing if we don't have an entry for it?
ScreenLock enabled
Squatting threshold(15 min) expired
bool CLClientManager::hasAuthorizedClients()
bool CLClientManager::getClientBackgroundIndicatorEnabled(const CLClientManager_Type::Name &)
#Error no bundle ID or bundle path found - enabling background indicator %{public}s
BackgroundIndicatorEnabled
LOCATION_CLIENT_PERMISSION_MESSAGE_REDUCED
LOCATION_CLIENT_PERMISSION_MESSAGE
CFStringRef CLClientManager::copyClientPurposeForRegistrationResult(const CLClientManager_Type::Name &, CLClientRegistrationResult, bool)
Requesting client (%{public}s) purpose for unsupported registration type %{public}d
purpose string from %s's bundle: '%s'
purpose string from %s's property: '%s'
LOCATION_ACCURACY
wapi
IMPROVE_LOCATION_ACCURACY_WLAN
IMPROVE_LOCATION_ACCURACY_WIFI
IMPROVE_LOCATION_ACCURACY_BLUETOOTH
SETTINGS
LOCATION_DISABLED
LOCATION_DISABLED_SETTINGS
LOCATION_DISABLED_CANCEL
bool CLClientManager::createAndPostClientPrefsNotification(const CLClientManager_Type::Name &, CLClientManager_Type::AuthorizationRequest)
Could not create client prefs notification for %{public}s
Could not create runloop source for client prefs notification for %{public}s
CLTypeAuthorizationStatus CLClientManager::registrationResultToAuthorizationStatus(const CLTypeRegistrationResult &)
unknown registsration result %{public}d
void CLClientManager::setClientBackgroundIndicator(const CLClientManager_Type::Name &, bool, const char *)
Setting executable: %{public}s, bundle: %{public}s, bundle path: %{public}s background indicator to %{public}d
void CLClientManager::setClientAuthorization(const CLClientManager_Type::Name &, CLClientAuthorizationStatus, CLClientCorrectiveCompensation, const char *, const char *, bool)
location services settings are frozen by restrictions - denying %{public}s
Never(because_invalid)
Invalid(Unset)
Never
WhenInUse
Always
Setting executable: %{public}s, bundle: %{public}s, bundle path: %{public}s authorization to %{public}d (%{public}s)
bool CLClientManager::getNonSystemLocationClientKey(std::string &)
retrieved empty non-system location client key
void CLClientManager::checkRestrictions(bool)
Location services available %d; parental controls enabled %d (refresh %d)
#warning location is restricted; freezing client states
location is not restricted
AppSwitcherQuitAppTime
TrialPeriodBegin
TrialPeriodNeedsReprompt
NSArray *CLClientManager::resetIdentifiersForRegisteredClients()
No registered clients for kNotificationReset.
Found regsietred client for kNotificationReset with empty resetIdentifier
Skip un-tracked resetIdentifier: %s
SBParentalControlsCapabilities
SBParentalControlsEnabled
bool CLClientManager::areParentalControlsEnabled(bool)
NameValuePair::get failed despite our bounds checking
location
bool CLClientManager::checkServiceStopped(const std::string &, CLClientServiceType)
#warning %{public}s time started exists (%{public}.2f), but time stopped (%{public}.2f) doesn't exist or is earlier for %{public}s - setting to %{public}.2f
void CLClientManager::checkLocationStopped(bool)
Resuming client '%s'
locationd-resume-on-crash
Failed to resume '%{public}s': init failure
#warning Failed to resume '%{public}s': assertion not acquired
Non-app client is was a background client?
void CLClientManager::scheduleAppStatusEvent()
Scheduling pending app status event
void CLClientManager::checkRegionsStopped()
CLBTLEFenceManager
CLFenceManager
#warning %{public}s region time started exists (%{public}.2f), but time stopped (%{public}.2f) doesn't exist or is earlier for %{public}s - setting to %{public}.2f
void CLClientManager::checkRangeStopped()
stop range for client '%s'
void CLClientManager::getAggregateRangeAppInfo(CLDaemonClient *, bool, bool &)
client, '%s', app's client cnt, %d, active, %d
void CLClientManager::markSystemServicesAsAuthorized()
com.apple.locationd.client.prompt.response
RequestType
Dismissed
The user dismissed the prompt
false
onClientUserNotification
Allowed
Disallowed
void CLClientManager::onClientUserNotification(CFOptionFlags)
#AuthPrompt Received response (%{public}d) for invalid/unrecognized response type (%{public}d)
Special
GrantedStatus
void CLClientManager::openPreferences(const char *const)
open preferences with url, %{public}s
Couldn't create Preferences URL, %{public}s
void CLClientManager::openPreferences(const char *const)_block_invoke
could not launch Preferences
prefs:root=Privacy&path=LOCATION
void CLClientManager::onClientPrefsNotification(CFOptionFlags)
#warning no user response to client %{public}s (flags 0x%{public}lx)
void CLClientManager::onImproveAccuracyPrefsNotification(CFOptionFlags)
ImproveAccuracyNotification object not created for notification, %{public}p
prefs:root=WIFI
prefs:root=Bluetooth
#warning no user response for improve accuracy prefs notification %{public}s (flags 0x%{public}lx)
void CLClientManager::onResetTimer()
ResetTimer fired
Reset registration and completion reporting is un-balanced. Completion not reported for clients: %@
Reset registration and completion reporting is balanced for all clients.
#reset-retry completing pending reset.
#reset-retry - service with identifier: %@ never checked in to retry handling reset after crash
static bool CLClientManager::getClientNameFromAuditToken(const audit_token_t, CLClientManager_Type::Name &)
Setting executable %s
Setting bundle ID %s and executable %s
com.apple.locationd.darwin_notification
void CLClientManager::onDarwinNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNotifier_Type::NotificationData &)
Unknown notification: %{public}d
com.apple.locationd.carrier_notification
void CLClientManager::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)
AppMonitor notification, %d, %s, pid, %d, bundleId, %s
Deleting entry for %s
'%{public}s' task suspended: removing client
Trial period #reprompt disarmed by foregrounded app
void CLClientManager::onWifiServiceNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
wifi power state, %d.
wifi enabled
void CLClientManager::onBluetoothServiceNotification(int, const CLBluetoothService_Type::Notification &, const CLBluetoothService_Type::NotificationData &)
bluetooth power state, %d.
bluetooth enabled
locScoreInfo/
com.apple.webapp
com.apple.AdSheet
com.apple.AdSheetPad
com.apple.AdSheetPhone
com.apple.CarPlayApp
/System/Library/PrivateFrameworks/Assistant.framework
/System/Library/PrivateFrameworks/AOSNotification.framework
/System/Library/LocationBundles/LocationPerformance.bundle
/System/Library/LocationBundles/LocationdInternal.bundle
void CLClientManager::performMigration()
Removing entry for bundle ID %{public}s if present
com.apple.locationd.bundle-/System/Library/LocationBundles/AppGenius.bundle
#warning bundle path, '%{public}s', does not exist on disk;  clearing.
AuthMigrate(%{public}s): Authorization mask contains Always but not WhenInUse
Authorized
AuthMigrate(%{public}s): Skipping: no Authorized key
AuthMigrate(%{public}s): Preserving Authorization over Authorized
AuthMigrate(%{public}s): Y => Always
AuthMigrate(%{public}s): N => Never
AuthMigrate(%{public}s): Authorization mask already available
AuthMigrate(%{public}s): Imputing default supported authorization mask
Unable to save clients list after migration, data loss due to crash possible
StandAloneWatchAppAuthorization
bool CLClientManager::updateStaticAuthorizationMaskForClientWithCompensation(const CLClientManager_Type::Name &, const char *, CLLocationDictionaryUtilitiesAuthorizationMask, CLClientCorrectiveCompensation, bool, bool)
#warning New authMask %{public}lu for client %{public}s implicitly extends its supported mask (%{public}d) until next connection & slide
ConsumptionPeriodBegin
NextConsumptionThresholdScore
NextNextConsumptionThresholdScore
TransientInfoPayloadTimestamp
TransientInfoPayloadHasWIU
TransientInfoPayloadInUseness
TransientInfoPayloadHasPrecise
setTemporaryAuthorizationStatusInfoForClient
double CLClientManager::setOrChangeAppClipAuthorizationTime(const CLClientManager_Type::Name &, double)
#appclip setting for bundle ID %s
void CLClientManager::registerAnalyticsCollectActivity()
Registering coreanalytics activity
com.apple.locationd.CLClientManager.coreanalytics
void CLClientManager::registerAnalyticsCollectActivity()_block_invoke
coreanalytics activity run
coreanalytics activity check-in
v16@?0@"NSObject<OS_xpc_object>"8
bool CLClientManager::considerPromptingForIncidentalUse(NSString *)
#IncidentalPrompt skip prompting. No client for incidental prompt
void CLClientManager::resetNotificationConsumedForIdentifier(NSString *)
Reset registration and completion reporting is un-balanced. Completion of Reset reported for unregistered identifier: %@
Completion reported back for all Reset registered clients
Registration : Zone already exists.
Registration : Invalid lat/lon.
PhenolicLocation
AuthZone registration failed. Invalid ZoneType.
ZoneRegistration
setRelevance : Zone not found.
Relevant
deleteZone : Zone not found.
B16@?0@"NSString"8
(zoneProvenance == kCLClientInterestZoneProvenanceTypeSyncedInfoPlist || zoneProvenance == kCLClientInterestZoneProvenanceTypeInfoPlist)
registerAndReconcileInfoPlistZone
InfoPlistZoneRegistration
bool CLClientManager::registerAndReconcileInfoPlistZone(const std::string &, const std::string &, NSDictionary *, CLClientInterestZoneProvenanceType, NSDictionary *)_block_invoke
#pla #reconcile SyncedInfoPlistZone:%@ collapsed to :%@
v24@?0@"NSString"8@"NSString"16
isSyncedInfoPlistZone
void CLClientManager::restartZoneRelevanceMonitoringForAllClients()
#pla restarting zone relevance-monitoring. clients.plist is empty
Core
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
com.apple.locationd.Legacy
v24@?0@8@"NSError"16
kCLClientRegistrationResultFailedUnverified != registrationResult
determineClientServiceTypeMasks
Failure detected after the point of no return!
RESET
TOGGLE
clpla_companion_
clpla_gizmo_
Notifier
CLClientManager::onDarwinNotification
CLClientManager::onCarrierNotification
CLClientManager::onStatusNotification
CLClientManager::onRestrictionsChangedNotification
CLClientManager::onAppMonitorNotification
CLClientManager::onDaemonStatusNotification
CLClientManager::onWifiServiceNotification
CLClientManager::onBluetoothServiceNotification
CLClientManager::onStatusBarNotification
CFStringRef _copyDisplayNameFromBundlePath(CFStringRef)
#warning could not get localized string '%{public}s'!
could not get UN localized bundle name from bundle at '%{public}s'; soup cannot be given to them.
Beacon
Circular
Ranging
PersistentSLC
Location
BackgroundLocation
RemoteLocation
MicroLocation
RemoteCircular
ReceivingLocationInformation
NonPersistentSLC
CorrectiveCompensation
UsageIndicatorDiscretion
OnBehalfRegionMonitoring
Push
kCLClientServiceMax != service
serviceForRegion
void thunkDeliverCFUserNotificationUnified(CFUserNotificationRef, CFOptionFlags)_block_invoke
#AuthPrompt #Thunk InflightAuthPromptRequest has unexpected state
WifiLocationProvider
UsageSyncManager
GnssController
PrivacyManager
FenceAuthorizationManager
TrackingAvoidanceService
SignificantVisitManager
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLClientManager.h
getOrCreatePersistentSubscriptionForClient
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLMotionActivityLiteClient]
Client %{public}s connected
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDaemonInUseAssertion]
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDaemonLocationIndependenceAssertion]
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDaemonBBTimeFreqTransferCallbackAssertion]
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDaemonGnssDisablementAssertion]
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDaemonEmergencyEnablementAssertion]
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDaemonHealthClient]
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDaemonSpringTrackingClient]
void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDistributedSensingSubscription]
virtual void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClientManager_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]
%s; client %d has deregistered, not notifying %s
void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClientManager_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]
%{public}s; unknown client %{public}d
com.apple.locationd.Support
Support
virtual void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClientManager_Type::RegInfo>::removeClient(int) [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]
virtual bool CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClientManager_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]
virtual bool CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClientManager_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]
virtual bool CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClientManager_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]
virtual void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClientManager_Type::RegInfo>::listClients() [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]
%s; already shutdown; not listing clients
%s; clients, id: %d, notification: %d
static bool CLRunningTrackDetector::detectRunningTrack(const std::vector<swan::RouteSmootherEpoch> &, bool &)
CLRS,CLRTD,too few points to detect
CLRS,CLRTD,failed to convert input points to enu coordinates
CLRS,CLRTD,loopStartIndex,%lu,loopEndIndex,%lu,out of enuCoordinates size,%lu
CLRS,CLRTD,loop detected from,%.1lf,to,%.1lf
static bool CLRunningTrackDetector::convertLLA2ENU(const std::vector<swan::RouteSmootherEpoch> &, std::vector<std::array<double, 3>> &)
CLRS,CLRTD,Warning,Could not convert LLA Coordinate %{private}.7lf,%{private}.7lf to ENU
static bool CLRunningTrackDetector::isRunningTrackByDistToCenter(const std::vector<std::array<double, 3>> &)
CLRS,CLRTD,Not enough points to detect loop
CLRS,CLRTD,non-track detected,numOutOfBoundaryPoints,%d,numOfPoints,%lu
CLRS,CLRTD,track detected,numOutOfBoundaryPoints,%d,numOfPoints,%lu
VO2MaxRetrocomputeHistory
SELECT * FROM VO2MaxRetrocomputeHistory WHERE algVersion = ? LIMIT 1
INSERT INTO VO2MaxRetrocomputeHistory (startTime, algVersion, status, firstSampleDate, lastSampleDate, lastSessionTimestamp, lastSessionId, meanDelta, lastSampleDatePrevAlg, numUpdatedEstimates, numNewEstimates, numLostEstimates, numLostEstimatesAfterLastSession, firstSummaryDate, lastTimestampToHealthKit, meanPercentileDelta, highPercentileMaxDelta, estimateVariabilityDelta, unavailableReasons) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
UPDATE VO2MaxRetrocomputeHistory SET startTime = ?, algVersion =?, status = ?, firstSampleDate = ?, lastSampleDate = ?, lastSessionTimestamp = ?, lastSessionId = ?, meanDelta = ?, lastSampleDatePrevAlg = ?, numUpdatedEstimates = ?, numNewEstimates = ?, numLostEstimates = ?, numLostEstimatesAfterLastSession = ?, firstSummaryDate = ?, lastTimestampToHealthKit = ?, meanPercentileDelta = ?, highPercentileMaxDelta = ?, estimateVariabilityDelta = ?, unavailableReasons = ? WHERE id = ?
DELETE FROM VO2MaxRetrocomputeHistory
virtual void CLVO2MaxRetrocomputeRecorderDb::deleteAllRecordsUL()
[VO2MaxRetrocomputeHistory] Database inaccessible, unable to delete records.
ALTER TABLE VO2MaxRetrocomputeHistory ADD COLUMN 
UPDATE VO2MaxRetrocomputeHistory SET 
algVersion
firstSampleDate
lastSampleDate
lastSessionTimestamp
lastSessionId
meanDelta
lastSampleDatePrevAlg
numUpdatedEstimates
numNewEstimates
numLostEstimates
numLostEstimatesAfterLastSession
firstSummaryDate
lastTimestampToHealthKit
highPercentileMaxDelta
unavailableReasons
CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::setDatabaseAccessible() [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
kCMVehicleStateDataCodingKeyTimeRange
kCMVehicleStateDataCodingKeyDeviceId
kCMVehicleStateDataCodingKeyState
kCMVehicleStateDataCodingKeyHints
%@,<startDate %@, endDate %@, deviceId %@, state %@, hints %@>
CLSignificantVisitManagerSilo
CLSignificantVisitManagerMemoryOnlyPersistence
significantVisitInterest
significantVisitAuth
CLSignificantVisitManager
CLRoutineMonitor
-[CLSignificantVisitManager ensureStop]
#slv Stop monitoring or leeching
B24@?0@8@"NSDictionary"16
interest
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLSignificantVisitManager.mm
-[CLSignificantVisitManager actOnPendingDeleteForClientKey:]
visit
-[CLSignificantVisitManager notifyClientsOfVisit:]
CLApplicationLifecycleManager
-[CLSignificantVisitManager checkForMonitoring]
#slv Invalid interest type
SpoofSignificantVisit
Accuracy
ArrivalTimestamp
DepartureTimestamp
DetectionTimestamp
void *CLTileFileWithTraversal::mmapTile(size_t &, int &)
TILE: mmapTile, prefer local file name because it exists, %s
TILE: mmapTile, can't open, %s, errno, %d, %s
TILE: can't stat, %s, errno, %d, %s
TILE: can't stat, %{public}s, errno, %{public}d, %{public}s
TILE: mmap file size changed, %{public}s, size before mmap, %{public}ld, size after mmap, %{public}lld
TILE: mmap failed, %s, size, %lld, errno, %d, %s
bool CLTileFileWithTraversal::fileGetNextSection(CLTileFileWithTraversal::CLMappedFile &, CLTilesManager_Type::SectionHeader &)
TILE: corrupt header, fileGetNextSection, size, %zd, readto, %lld, %d
virtual bool CLTileFileWithTraversal::traverseTileFile(FILE *, const CLTileFile::TraverseDetails &)
TILE: traverseTileFile, start, message, %s, isHeadersOnly, %d, isBinarySearch, %d, macAddressToSearch, %012llx
TILE: traverseTileFile, can't open tile
TILE: traverseTileFile, file is empty
TILE: thisSection, message, %s, readBytes, %lu, section, signature, 0x%x, sectionId, %d, sizeBytes, %d, headerSizeBytes, %d, name, %s
TILE: Invalid section signature, readBytes, %lu, section, signature, 0x%x, sectionId, %d, sizeBytes, %d
TILE: invalid tile file, bad allocation size, totalBytesInSection, %lu, maxAllocationSize, %lu
TILE: failed to allocate memory for, %lu
TILE: failed to read pSectionH, %lu, %lu
TILE: section, signature, 0x%x, sectionId, %d, headerSizeBytes, %u, sizeBytes, %u
TILE: ERROR: failed to fseek to, currentFileOffset, %lu, %u
TILE: traverseTileFile, done
virtual void CLTileFileWithTraversal::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &)
TILE: CLTileFile, sectionId, %d, %s
virtual void CLTileFileWithTraversal::onTraversingTileHeader(const CLTilesManager_Type::TileHeader &)
TILE: tile, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, altitude, %f,  minAltitude, %f, maxAltitude, %f, numOfInputPoints, %d, generationTime, %.1f, expirationAge, %d, %d, age, %.1lf
virtual void CLTileFileWithTraversal::onTraversingTileHeaderKeyLatLon(const CLTilesManager_Type::TileHeaderKeyLatLon &)
TILE: onTraversingTileHeaderKeyLatLon, tileid, %s
TILE: tile.keylatlon, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, generationTime, %.1f, expirationAge, %d, age, %.1lf, sec_key, %016llx
virtual void CLTileFileWithTraversal::onTraversingTileHeaderLocation(const CLTilesManager_Type::TileHeaderLocation &)
TILE: tile.location, tileid, %s, serverName, %s
TILE: tile.location, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, generationTime, %.1f, expirationAge, %d, age, %.1lf
virtual void CLTileFileWithTraversal::onTraversingTileIndexHeader(const CLTilesManager_Type::TileIndexMacHeader &)
TILE: tileMacIndexHeader, headerSizeBytes, %u, tileMacIndexHeader, entrySizeInBytes, %u, numOfEntries, %u
virtual void CLTileFileWithTraversal::onTraversingTileIndexEntry(const CLTilesManager_Type::AccessPointIndexEntry &)
TILE: idx, %3u, mac,%x:%x:%x:%x:%x:%x, offset, %u
virtual void CLTileFileWithTraversal::onTraversingTileAPTableHeader(const CLTilesManager_Type::TileAccessPointTable &)
TILE: tileAccessPointTable, headerSizeBytes, %u, tileAccessPointTable, entrySizeInBytes, %u, numOfEntries, %u
virtual void CLTileFileWithTraversal::onTraversingTileAPTableEntry(const CLTilesManager_Type::AccessPointEntry &)
TILE: mac, %3u, mac,%x:%x:%x:%x:%x:%x, y, %3d, x, %3d, loc, %14.10lf, %14.10lf
void *CLTileFileWithTraversal::readDataEntries(FILE *, const CLTilesManager_Type::SectionHeader &, unsigned int, unsigned int, unsigned int)
TILE: read data, sectionId, %d, entriesOffset, %u, entriesNumToRead, %u
TILE: ERROR: failed to skip entries pre read, %u, ret, %d
TILE: ERROR: failed to read bytes, %u, %u
-[CLBarometerCalibrationSourceLocation onLocationNotification:data:]
location last altitude %.3lf last time %.3lf last location time %.3lf,indoorConfidence,%{private}.3lf, outdoorConfidence,%{private}.3lf,PositionOutdoorState,%{private}u,mapMatchType,%{private}u
underDEM, %d, altitude, %f, uncertainty, %f, demAltitude, %f, demUncertainty, %f, threshold, %f
good DEM data: location altitude state is %u
location altitude state %u
CLLocalization
com.apple.language.changed
static void CLLocalization::onLanguageChanged(CFNotificationCenterRef, void *, CFStringRef, const void *, CFDictionaryRef)
language changed - refreshing
.GlobalPreferences
AppleLanguages
CFDictionaryRef CLLocalization::copyStringsDictionaryForBundle(CFBundleRef, CFStringRef)
could not use english as default language
#Warning could not get localizations array from bundle
#Warning could not get localizations for preferred languages
#Warning no localizations for preferred languages
getting '%s' localized strings for '%s'
strings
#Warning could not get resource URL for %s
could not create input stream for %{public}s
could not deserialize data from URL for %{public}s, error, %{public}s
InfoPlist
CFStringRef CLLocalization::copyStringFromBundle(CFBundleRef, CFStringRef, CLLocalization::FallbackBehavior)
#Warning issue retrieving localized strings for bundle '%s'
key %{public}s does not contain a string value
CFStringRef CLLocalization::copyString(CFStringRef)
no corresponding string for %{public}s
CFStringRef CLLocalization::copyStringsDictString(CFStringRef)
CLCarrierSettingsSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/CarrierSettings/CLCarrierSettings.mm
-[CLCarrierSettingsAdapter beginService]
CLCarrierSettings
void CLCarrierSettings::onTelephonyNotification(int, const CLTelephonyService_Type::Notification &, const CLTelephonyService_Type::NotificationData &)
virtual void CLCarrierSettings::setInternal(const CFStringRef, const CFTypeRef)
should not write to carrier bundle
CLCarrierSettings::onTelephonyNotification
virtual void CLNotifier<CLCarrierSettings_Type::Notification, CLCarrierSettings_Type::NotificationData>::removeClient(int) [Notification_T = CLCarrierSettings_Type::Notification, NotificationData_T = CLCarrierSettings_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCarrierSettings_Type::Notification, CLCarrierSettings_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCarrierSettings_Type::Notification, NotificationData_T = CLCarrierSettings_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCarrierSettings_Type::Notification, CLCarrierSettings_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLCarrierSettings_Type::Notification, NotificationData_T = CLCarrierSettings_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCarrierSettings_Type::Notification, CLCarrierSettings_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCarrierSettings_Type::Notification, NotificationData_T = CLCarrierSettings_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCarrierSettings_Type::Notification, CLCarrierSettings_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCarrierSettings_Type::Notification, NotificationData_T = CLCarrierSettings_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCarrierSettings_Type::Notification, CLCarrierSettings_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLCarrierSettings_Type::Notification, NotificationData_T = CLCarrierSettings_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCarrierSettings_Type::Notification, CLCarrierSettings_Type::NotificationData>::listClients() [Notification_T = CLCarrierSettings_Type::Notification, NotificationData_T = CLCarrierSettings_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
OverrideFitnessTrackingChargerWithType
NanoLifestylePrivacyPreferencesChangedNotification
NanoLifestyleSessionTrackerAppPreferencesChangedNotification
virtual bool CLFitnessTrackingNotifierWatch::isDeviceActivated() const
#SystemState, Overriding device activation status check.
#SystemState, Unable to query pairing id, suspending activity tracking.
#SystemState, Unable to obtain pairing id, suspending activity tracking.
C5DDE5DD-2FF7-4735-80A3-0108488556DE
EnableFitnessTracking
com.apple.nanolifestyle.privacy
virtual bool CLFitnessTrackingNotifierWatch::isFitnessTrackingEnabled() const
#SystemState, Failed to get fitness tracking state in Bridge->Motion&Fitness. It may not have been set yet. Assuming default.
#SystemState, Fitness tracking is disabled, suspending activity tracking.
virtual void CLFitnessTrackingNotifierWatch::notifyClients()
#SystemState, Watch, Enabled, %{public}d, DeviceActivated, %{public}d, OnCharger, %{public}d
void CLFitnessTrackingNotifierWatch::pairingStateChanged(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
#SystemState, Pairing state changed
void CLFitnessTrackingNotifierWatch::onBatteryNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
#SystemState, OverrideChargerType, %{public}d, NotifyChargerType, %{public}d
#SystemState, Device on-charger, suspending activity tracking.
#SystemState, Un-handled notification,%{public}d
NLPredictedActivityStartEnableNotification
NLPredictedActivityEndEnableNotification
void CLFitnessTrackingNotifierWatch::updateActivityMoveMode()
CM Activity Move Mode,%{public}d
void CLFitnessTrackingNotifierWatch::updateSatellitePairingState()
CM Satellite Pairing State,%{public}d
AlwaysOnMotionSensorLogging
CLFitnessTrackingNotifier::fitnessTrackingStateChanged
CLFitnessTrackingNotifierWatch::nanoLifestyleSessionTrackerAppPreferencesChanged
CLFitnessTrackingNotifierWatch::nanoLifestyleEnableFitnessDataCollectionSettingChanged
CLFitnessTrackingNotifierWatch::pairingStateChanged
NRPairedDeviceRegistryDeviceDidPairDarwinNotification
NRPairedDeviceRegistryDeviceDidUnpairDarwinNotification
CLFitnessTrackingNotifierWatch::activityMoveModeChanged
HKActivityMoveModeDidUpdateNotification
/System/Library/PrivateFrameworks/HealthKit.framework/HealthKit
CLFitnessTrackingNotifierWatch::onBatteryNotification
HKActivityMoveModeDefaultsKey
locationFingerprint
EnablePerEpochSmoothLogOutput
EnableMapMatchingBeforeSmoothing
EnableCornerDetectionDuringSmoothing
EnableRunningTrackDetectionDuringSmoothing
EnableMapMatchingAfterSmoothing
EnableReSmoothingAfterMapMatching
void CLRouteSmoother::readDefaultSettings()
CLRS,EnableMapMatchingBeforeSmoothing,%{public}d,EnableMapMatchingAfterSmoothing,%{public}d,EnableReSmoothingAfterMapMatching,%{public}d,EnablePerEpochSmoothLogOutput,%{public}d,this->fEnableCornerDetectionDuringSmoothing_,%{public}d,this->fEnableRunningTrackDetectionDuringSmoothing_,%{public}d
CLRouteSmoother.smoothPoints
CLSmootherErrorCode CLRouteSmoother::smoothPoints(dispatch_queue_t, std::vector<swan::RouteSmootherEpoch> &, std::vector<CLClientLocation> &, CLMotionActivity::Type)
CLRS,Starting smoother for workoutActivity,%{public}u
PreMM
PreSmt
CLRS,CLMM mapMatching before smoothing failed
PostMM
CLRS,smoother returned error
PostSmt
CLRS,CLMM mapMatching after smoothing failed
PostMMRe
CLRS,resmoother returned error
CLSmootherErrorCode CLRouteSmoother::smoothPointsInternal(dispatch_queue_t, std::string, std::vector<swan::RouteSmootherEpoch> &, CLMotionActivity::Type)
CLRS,Smoothing,%{public}s,dataCount,%{public}zu,workout,%{public}u
CLRS,too few points to smooth
CLRS,CLCF,corner detection started
CLRS,CLCF,corner detection failed
CLRS,CLCF,Corner found,index,%{public}d,lat,%{private}.7f,lon,%{private}.7f
CLRS,CLCF,corner detection completed,dataCount,%{public}zu,elapsedTime,%{public}lld,msec
CLRS,CLCF,corner detection disabled
CLRS,gap detection started
CLRS,gap found,index,%{public}d,time,%{public}.1lf,gap,%{public}.1lf,lat,%{private}.7f,lon,%{private}.7f
CLRS,CLRTD,running track detection started
CLRS,CLRTD,Running track detection failed
CLRS,CLRTD,running track detection completed,dataCount,%{public}zu,elapsedTime,%{public}lld,msec
CLRS,CLRTD,Running track detected!
CLRS,CLRTD,running track detection disabled
CLRS,input data contains Null Island or non-positive horizontal uncertainty. Will not attempt to smooth.
CLRS,smoother is unhealthy
CLRS,Indexing error,startToOutput,%zu,endToOutput,%zu,smoothedSegment,%zu
CLRS,smoothed segment,#%{public}zu,dataCount,%{public}zu,elapsedTime,%{public}lld,msec
CLRS,smoothing all segments completed,segmentCount,%{public}zu,elapsedTime,%{public}lld,msec
CLRS,Smoother,type,%{public}s,dataCount,%{public}zu,elapsedTime,%{public}lld,msec,workout,%{public}u
Smooth
bool CLRouteSmoother::mapMatchPoints(std::string, const CLMotionActivity::Type, std::vector<swan::RouteSmootherEpoch> &)
CLRS,CLMM mapMatching,%{public}s,workout,%{public}u,dataCount,%{public}zu
CLRS,CLMM,Unsupported activity type
CLRS,CLMM,Failed to create geometry pointer
CLRS,CLMM,Failed to create mapmatcher pointer
aPriori
aPosteriori
CLRS,CLMM,type,%{public}s,dataCount,%{public}zu,elapsedTime,%{public}lld,msec,workout,%{public}u
RouteSmoother
void outputPerEpochLog(const std::vector<swan::RouteSmootherEpoch> &, const std::string)
CLRS,%{public}.1lf,%s,latitude,%{private}.8lf,longitude,%{private}.8lf,altitude,%{private}.2lf,speed,%{public}.2lf,course,%{public}.2lf,hunc,%{public}.2lf,vunc,%{public}.2lf,speedUnc,%{public}.2lf,courseUnc,%{public}.2lf,signalEnvironment,%{public}d
ConfigLoader: could not open config file, using default values
input_locationd_data_file
Invalid input_locationd_data_file
vertical_process_noise_sigma_mps2
desired_lag_per_environment_array
horizontal_process_noise_sigma_mps2_unknown
horizontal_process_noise_sigma_mps2_walking
horizontal_process_noise_sigma_mps2_running
horizontal_process_noise_sigma_mps2_cycling
horizontal_process_noise_sigma_mps2_swimming
horizontal_process_noise_sigma_mps2_golfing
horizontal_process_noise_sigma_mps2_downhillskiing
horizontal_process_noise_sigma_mps2_outdoorwheelchair
workout_type
walking
running
cycling
swimming
golfing
downhillskiing
outdoorwheelchair
velocity_uncertainty_scale_factor
vertical_speed_limit_mps
minimum_driving_speed_that_requires_speed_uncertainty_floor_mps
minimum_driving_speed_uncertainty_mps
speed_uncertainty_threshold_multiplier
course_uncertainty_threshold_rad
ConfigLoader: "%s" loaded value "%s"
ConfigLoader: "%s" using default value "%s"
bad lexical cast: source type value could not be interpreted as target
INFINITY
infinity
ConfigLoader: Too many entries for "%s"
ConfigLoader: "%s" could not cast value #%d from "%s"
ConfigLoader: "%s" loaded value #%d "%s"
ConfigLoader: "%s" could not be parsed
token_iterator.hpp
valid_
increment
swan::WorkoutType convertCLMotionActivityToWorkoutType(const CLMotionActivity::Type &)
CLRS,Unhandled CLMotionActivity workout type,%d
TransposeDataFootprint
cnmatrix.h
scratch != nullptr
lead_dim > 0
bool fillCrumb(CLMapGeometryPtr, const swan::RouteSmootherEpoch &, const CLMotionActivity::Type, CLMapCrumb &)
CLRS,CLMM,fillCrumb,Null Island
CLRS,CLMM,China shift returned false
swan::SignalEnvironment convertCLClientSignalEnvironmentTypeToSignalEnvironment(const CLClientSignalEnvironmentType &)
CLRS,Unhandled CLClient signal environment type
CLClientSignalEnvironmentType convertSignalEnvironmentToCLClientSignalEnvironmentType(const swan::SignalEnvironment)
CLRS,Unhandled signal environment type
VO2MaxAlertBlackoutDuration
VO2MaxRepeatAlertWindow
VO2MaxAlertHistoricalEstimateWindow
VO2MaxAlertMaxHistoricalEstimates
VO2MaxAlertMinDaysWithEstimate
VO2MaxAlertMinWorkoutsContrToEstimate
VO2MaxAlertMinEstimatesSinceAlgChange
CLVO2MaxAlertEvaluator::CLVO2MaxAlertEvaluator(std::shared_ptr<CLVO2MaxAlertRecorderDb>)
VO2MaxAlert,fAlertBlackoutDuration,%{private}.3f,fRepeatAlertWindow,%{private}.3f,fHistoricalEstimateWindow,%{private}.3f,fMaxHistoricalEstimatesForAlert,%{private}d,fMinDaysWithEstimate,%{private}d,fMinEstimatesSinceAlgChange,%{private}d
void CLVO2MaxAlertEvaluator::feedBodyMetrics(const CLBodyMetrics &)
VO2MaxAlert,gender,%{private}d,age,%{private}f,biologicalSex,%{private}d
VO2MaxAlertResult CLVO2MaxAlertEvaluator::evaluateForAlert(CFAbsoluteTime, CFTimeInterval)
VO2MaxAlert,HistoricalEstimateBiasAdjustment,startTime,%{public}.3f,estimatedVO2Max,%{public}.3f,biasAdjustment,%{public}.3f
VO2MaxAlert,ageOutOfRange,%{public}d,age,%{private}.3f,inBlackoutPeriod,%{public}d,mostRecentAlertStartTime,%{private}.3f,alertBlackoutDuration,%{private}.3f,estimateTime,%{public}.3f, sufficientDaysWithEstimate,%{public}d,queryFromTime,%{public}.3f,numberOfEstimates,%{public}lu,countDaysWithEstimate,%{public}d,numWorkoutsContrToLatestEstimate,%{public}d,sufficientEstimatesSinceAdaptiveModel,%{public}d, earliestTimestampSinceAdaptiveModel,%{public}.3f,countEstimatesSinceAdaptiveModel,%{public}d,earliestTimestampSinceHunterC,%{public}.3f,latestVO2Max,%{private}.3f,lowClassificationThreshold,%{private}.3f, shouldTriggerAlert,%{private}d,isRepeatAlert,%{private}d,repeatAlertWindow,%{private}.3f
CFAbsoluteTime CLVO2MaxAlertEvaluator::getEarliestStartTimeSinceAlgorithmVersion(VO2MaxAlgorithmVersion) const
VO2MaxAlert,Unexpectedly not able to retrieve a session record since algorithm version %{public}.3d
bool CLVO2MaxAlertEvaluator::assessWhetherLow(const std::vector<VO2MaxOutput> &) const
VO2MaxAlert,estimateTime,%{public}.3f,isCurrentEstimateLow,%{private}d,isRecentActivityLow,%{private}d,weightedAvg,%{private}.3f,std,%{private}.3f,lowAlertThreshold,%{private}.3f
NRARFCN
CLNrCellLocationDatabase::CLNrCellLocationDatabase(const char *, const CLSqliteDatabase::SqliteProperties &, double)
bool CLNrCellLocationDatabase::getLocation(const CLTelephonyService_Type::NrCell &, sqlite3_int64 &)
CELL_LOC: failed to bind %s
bool CLNrCellLocationDatabase::setLocation(const CLTelephonyService_Type::NrCell &, const CLDaemonLocation &)
CELL_CEN: adding cell, %s, rowid, %lld
bool CLNrCellLocationDatabase::getLocation(sqlite3_int64, CLTelephonyService_Type::NrCell &) const
CLPredictedWalkDistanceServiceWatchSilo
-[CLPredictedWalkDistanceServiceWatch beginService]
Starting up CLPredictedWalkDistanceServiceWatch
-[CLPredictedWalkDistanceServiceWatch onAddBout:]
Attempting to send ids message from watch to phone
-[CLPredictedWalkDistanceServiceWatch onUserInfoUpdate:data:]
CLPredictedWalkDistanceServiceWatch: Received user info update
CLElevationSubscription
kCLConnectionMessageSignificantElevationUpdate
kCLConnectionMessageFilteredElevationUpdate
kCLConnectionMessageSignificantElevationDeltaQuery
kCLConnectionMessageAbsoluteAltitudeUpdate
void CLElevationSubscription::handleRequestSignificantElevationUpdate(bool, const CLNameValuePair &)
SignificantElevation subscription changed, %s, %p, %d
#Warning Failed to subscribe to significant elevation updates.
void CLElevationSubscription::handleRequestFilteredElevationUpdate(bool, const CLNameValuePair &)
#Warning Failed to subscribe to filtered elevation updates.
void CLElevationSubscription::handleMessageSignificantElevationDeltaQuery(std::shared_ptr<CLConnectionMessage>)
Programmer error: Wrong parameters were passed.
CLDaemonClient.OdometerNotifier.SignificantElevationDeltaQuery
v16@?0@"CMSignificantElevationSample"8
com.apple.locationd.absolute_altimeter
bool CLElevationSubscription::isQualifiedForAbsoluteAltitude(CMError &)
%{public}s is not entitled for motion updates
void CLElevationSubscription::handleRequestAbsoluteAltitudeUpdate(bool, const CLNameValuePair &)
AbsoluteAltitude subscription changed, %s, %p, %d
#Warning Failed to subscribe to absolute altitude updates.
CLElevationSubscription::onOdometerUpdate
CLWatchOrientationSettingsNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/WatchOrientationSettings/CLWatchOrientationSettingsNotifier.mm
-[CLWatchOrientationSettingsNotifierAdapter beginService]
CLWatchOrientationSettingsNotifier
CLWatchOrientationSettingsNotifier::CLWatchOrientationSettingsNotifier(id<CLIntersiloUniverse>)
Watch Orientation,Orientation Notifier Instantiated
virtual void CLWatchOrientationSettingsNotifier::shutdown()
Watch Orientation,Orientation Notifier is shutting down.
virtual bool CLWatchOrientationSettingsNotifier::registerForNotificationInternal(const CLWatchOrientationSettingsNotifier_Type::Notification &)
Watch Orientation,Added client for %d, count %d
virtual bool CLWatchOrientationSettingsNotifier::unregisterForNotificationInternal(const CLWatchOrientationSettingsNotifier_Type::Notification &)
Watch Orientation,Removed client for %d, count %d
invertUI
com.apple.nano
void CLWatchOrientationSettingsNotifier::queryOrientationSettings()
Watch Orientation,Crown orientation setting key is invalid, defaulting to crown on right (not inverted)
wornOnRightArm
Watch Orientation,Wrist orientation setting key is invalid, defaulting to left wrist
Watch Orientation,crown,%{public}d,wrist,%{public}d
com.apple.nano.invertUIChangedNotification
com.apple.nano.wristOrientationChangedNotification
void CLWatchOrientationSettingsNotifier::onWristStateChange(CLWatchOrientationSettingsNotifier_Type::WristState)
Watch wrist state %{public}d
CLWatchOrientationSettingsNotifier::onOrientationSettingsChanged
virtual void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
EnableStepperLoadCal
EnableStepperHRModel
StairModelMetsScale
StepperVO2MaxScalingFactor
CLNatalieStairClimbingModel::CLNatalieStairClimbingModel()
Stair Climbing, load calibration, %d, HR mode, %d, mets scaling factor, %f, VO2max scaling factor, %f
virtual CLMetsInfo CLNatalieStairClimbingModel::computeMETS(const CLNatalieModelInput &)
Stair Climbing, Work Rate Model, timestamp, %f, step frequency, %f, WRMETS, %f, sinceLastGood, %f
Stair Climbing, HR Rate Model, timestamp, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, METS, %f
Stair Climbing, timestamp, %f, HRMETs, %f, WRMETs, %f, calibrationValue, %f, loadCalStatus, %d
Stair Climbing, timestamp, %f, finalMETS, %f, fMetsScaling, %f
virtual void CLPolicyTripExternal::applyBundleId(CLTracksHarvestDataType::HarvestData &)
#warning: error serializing json data, error, %s
-[CLDiagnosticManager beginService]
#diagnosticManager beginService
-[CLDiagnosticManager endService]
#diagnosticManager endService
-[CLDiagnosticManager registerFileForCollection:]
Add file to #diagnosticManager: %{public}@
Trying to register a nil NSURL
-[CLDiagnosticManager unregisterFileForCollection:]
Remove file to #diagnosticManager: %{public}@
Trying to unregister a nil NSURL
-[CLDiagnosticManager copyRegisteredFilesWithHandler:]
Client requested #diagnosticManager file copy to dest: %@
diagnosticManager trying to copy file: %@
-[CLDiagnosticManager listener:shouldAcceptNewConnection:]
#diagnosticManager received new XPC Connection request
Why didn't we get a connection?
com.apple.locationd.diagnostic
-[CLDiagnosticManager listener:shouldAcceptNewConnection:]_block_invoke
#diagnosticManager Interruption handler called
#diagnosticManager Invalidation handler called
#diagnosticManager Resuming XPC Connection: %@
-[CLDiagnosticManager fileManager:shouldCopyItemAtURL:toURL:]
#diagnosticManager fileManager asking if should copy from %@ to %@
Trying to move a file that is not in our cache directory: %@
Library
Logs
CrashReporter
yyyy-MM-dd_HH-mm-ss
CMIirFilter::CMIirFilter(const CMIirFilterParams *)
Assertion failed: (fIirFilterParams != __null) && (fIirFilterParams->filterOrder <= kMaxFilterOrder), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMIirFilter.cpp, line 20,IirFilterParams,%p,filterOrder,%d,maxFilterOrder,%d.
void CMOnBodyDetector::printParameters() const
configuration: low band = [%d %d] high band [%d %d]
configuration: classifierMinLowPower = %f, classifierMaxLowPower = %f, classifierMaxHighPower = %f
configuration: theta = [%.2f %.2f %.2f %.2f %.2f %.2f]
configuration: oddsThreshold = %f, medianFilterSize = %zu, confidenceThreshold = %f, useHysteresis = %d, useAngleOverride = %d, angleMetricThreshold = %f
CLOnBodyNotifier_Type::CLOnBodyDetectionResult CMOnBodyDetector::detect()
Accel saturation detected, forcing OnBody.
void CMQueue<bool>::setCapacity(size_t) [T = bool]
Assertion failed: fHeadAndSize.fSize == 0 && fHeadAndSize.fHead == 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMQueue.h, line 90,size,%u,head,%u.
const T &CMQueue<bool>::operator[](const size_t) const [T = bool]
virtual void CLSensorFusionServiceLegacy::applicationStateChanged(bool)
Application state changed, %d
virtual void CLSensorFusionServiceLegacy::feedGyroData(const CLGyro::Sample *)
Large time gap, %lf
Reset while backgrounded
compass-calibration
CFDataRef CLMagnetometerCoexistenceLocal::copyCompassCalibrationData()
Invalid cpas data.
The cpas data is not a CFData type.
BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()
#Warning Cpas data is NULL.
#Warning Cpas pointer is NULL.
Unexpected cpas version: %u.
Original serial number data is NULL.
Original serial number pointer is NULL.
AppleH4CamIn
BackCameraSerialNumber
Invalid back camera serial number data.
Incorrect back camera serial number length. Actual length %ld. Expected length %lu.
Current serial number data is NULL.
BackCameraModuleFocusActuatorID
NSNumber *CLMagnetometerCoexistenceLocal::cameraVcmId()
Bailing while checking VCM actuator ID.
VCM actuator ID data type %d does not match expected type %d
NSData *CLMagnetometerCoexistenceLocal::sanitizedCompassCalibrationData()
#Warning CPAS data is NULL.
#Warning CPAS pointer is NULL.
CLLocationCorrectiveCompensatorSilo
-[CLLocationCorrectiveCompensator snapLocation:withReply:]_block_invoke
#compensation GeoLocation coarseMetaData: %@
#compensation GeoLocation coarseMetaData encoding failed, error, %@
com.apple.locationd.ccmetric
Distance
GeoResultCode
v24@?0@"GEOLocation"8q16
northWestLatitude
northWestLongitude
southEastLatitude
southEastLongitude
tiles
CLZoneRelevanceMonitorSilo
/System/Library/LocationBundles/PLAMonitor.bundle
starting
stopping
%@%@%@
secondary-%f-%zu
CLLocationStreamerSilo
Active location client on remote device
Remote device is considering this device as a location source
CLLocationStreamer
kCLLocationStreamerLastAliveAgainMessageTimestamp
LocationStreamerMotionOverride
CLLocationStreamer::RollingPowerAssertion
CLCorrectiveCompensatedLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLCorrectiveCompensatedLocationProvider.mm
-[CLCorrectiveCompensatedLocationProviderAdapter beginService]
correctiveCompensated
CLLocationCorrectiveCompensator
virtual bool CLCorrectiveCompensatedLocationProvider::registerForNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::RegInfo &)
#cclp registering for un-supported notification: %s
CCLP.CorrectiveCompensationInterval
CCLP.ApparentCorrectiveCompensationInterval
CCLP.CorrectiveCompensationClaimsOriginalAccuracy
CCLP.ClockAlignmentTestModeEnabled
CCLP.EnableClockAlignment
void CLCorrectiveCompensatedLocationProvider::refreshSettings()
#cclp CorrectiveCompensationInterval changed. Reset CompensationTimer.
#warning #cclp ApparentCorrectiveCompensationInterval greater than CorrectiveCompensationInterval
#cclp ApparentCorrectiveCompensationInterval changed. Reset ApparentCompensationTimer.
CFTimeInterval CLCorrectiveCompensatedLocationProvider::computeNextFireDelayToMaximizeAlignment()
#cclp: Clock Alignment disabled by default settings. Using default CC interval
#cclp: Clock Alignment disabled. Either TestMode should be enabled or CompensationInterval should be 15m. Check #compensation #settings
#cclp: next fire delay: %f
void CLCorrectiveCompensatedLocationProvider::onCompensationTimer()
#cclp CompensationTimer fired at : %f
void CLCorrectiveCompensatedLocationProvider::onUpdateLastReceivedLocationTimer()
#cclp #warning UpdateLastReceivedLocationTimer handler early return. LastReceivedLocation is invalid.
fCompensationTimer.nextFireDelay == 1.7976931348623157e+308
notifyClientsWithData
void CLCorrectiveCompensatedLocationProvider::onSimulationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#cclp Simulation %s
#cclp CompensationTimer not scheduled and not subscribed to FLC
void CLCorrectiveCompensatedLocationProvider::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#cclp received location notification for un-supported notification: %s
#cclp skip notification: %s. CompensationTimer scheduled
#cclp skip notification: %s. UpdateLastReceivedLocationTimer scheduled
#cclp #warning invalid location. skip snapping
void CLCorrectiveCompensatedLocationProvider::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)_block_invoke
#cclp Encoded coarse meta data available
#cclp Simulation started. Random next fire delay: %f
v28@?0@"CLLocation"8B16@"NSData"20
CLCorrectiveCompensatedLocationProvider
CLCorrectiveCompensatedLocationProvider::onSimulationNotification
CLCorrectiveCompensatedLocationProvider::onLocationNotification
com.apple.locationd.bundle-/System/Library/LocationBundles/Traffic.bundle
CLCachedLocationControllerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Transit/CLCachedLocationController.mm
-[CLCachedLocationControllerAdapter beginService]
CLCachedLocationController
CachedLocationController
Traffic
CLCachedLocationController::CLCachedLocationController(id<CLIntersiloUniverse>)
CLC: Init power state: off
Active
stateToString
void CLCachedLocationController::setStateAndUpdateDebounceTimout(CLCachedLocationController_Type::CachedLocationState, CFTimeInterval)
CLC: Debounce changed to %{private}lf [s]
CLC: Already in state %{private}s, %{private}lf
CLC: Cached Location changed state from %{private}s to %{private}s
void CLCachedLocationController::onTransitDebounceTimer()
CLC: Debounce timer fired, stopping
virtual void CLCachedLocationController::onStartTransitRoute(CFTimeInterval, const CLClientLocationCoordinate &)
CLC: Received start route
virtual void CLCachedLocationController::onEndTransitRoute()
CLC: Received end route
void CLCachedLocationController::onLocationUpdateNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
CLC: Received unknown notification, %{public}d
void CLCachedLocationController::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
CLC: Recevied kNotificationAuthorization for %{private}s
CLC: Received Location Services status %{public}d
#Warning CLC: Received unknown notification, %{public}d
void CLCachedLocationController::resumeForException(CLCachedLocationController::CacheException)
CLC: Resume for exception, %{public}#x, oldExceptions %{public}#x
CLC: Resume
void CLCachedLocationController::suspendForException(CLCachedLocationController::CacheException)
CLC: Suspend for exception, %{public}#x, oldExceptions %{public}#x
CLC: Suspend
CLCachedLocationController::onClientManagerNotification
CLCachedLocationController::onAppMonitorNotification
CLCachedLocationController::onLocationUpdateNotification
virtual void CLNotifier<CLCachedLocationController_Type::Notification, CLCachedLocationController_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCachedLocationController_Type::Notification, NotificationData_T = CLCachedLocationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCachedLocationController_Type::Notification, CLCachedLocationController_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLCachedLocationController_Type::Notification, NotificationData_T = CLCachedLocationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCachedLocationController_Type::Notification, CLCachedLocationController_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLCachedLocationController_Type::Notification, NotificationData_T = CLCachedLocationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCachedLocationController_Type::Notification, CLCachedLocationController_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCachedLocationController_Type::Notification, NotificationData_T = CLCachedLocationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCachedLocationController_Type::Notification, CLCachedLocationController_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLCachedLocationController_Type::Notification, NotificationData_T = CLCachedLocationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCachedLocationController_Type::Notification, CLCachedLocationController_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCachedLocationController_Type::Notification, NotificationData_T = CLCachedLocationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCachedLocationController_Type::Notification, CLCachedLocationController_Type::NotificationData, char, char>::listClients() [Notification_T = CLCachedLocationController_Type::Notification, NotificationData_T = CLCachedLocationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLTileDownloadSchedulingServiceSilo
com.apple.locationd.TileDownloadWifiReachability
com.apple.locationd.TileDownloadCellReachability
-[CLTileDownloadSchedulingService requestForSchedulingTileDownload:]
#tiledownloadscheduler, add client, count, %ld
#tiledownloadscheduler, warning, client is re-subscribing
-[CLTileDownloadSchedulingService stopListeningForForScheduledTileDownload:]
#tiledownloadscheduler, client unsubscribe, count, %{public}ld
-[CLTileDownloadSchedulingService scheduleDownloadsWithWifiConnectivity]_block_invoke
#tiledownloadscheduler, callback, %{public}d
#tiledownloadscheduler, run, wifi connectivity, client count, %{public}ld
#tiledownloadscheduler, failed to mark activity as done. current state, %{public}ld
-[CLTileDownloadSchedulingService scheduleDownloadsWithCellularConnectivity]_block_invoke
#tiledownloadscheduler, run, cellular connectivity, client count, %{public}ld
void CLPressureQualityController::reset(const CLPressureQualityController::EInWorkout *)
PressureQualityController::reset::%d => %d
void CLPressureQualityController::setResult(const T *) [T = CLPressureQualityController::EInWorkout]
PressureQualityController::setResult::%d => %d
void CLPressureQualityController::setResult(const T *) [T = CLPressureQualityController::ETransition]
double CLMobility::SteadinessModelBalance::runSteadinessModel(const CLMobility::SteadinessModelBalancePrior_Generated::Features &) const
CLMobility::SteadinessModelBalance::Features,intermediateBoutsAsymmetryPercentageMedian,%{private}.3f,intermediateBoutsAsymmetryPercentageCv,%{private}.3f,intermediateBoutsDoubleSupportPercentageMedian,%{private}.3f,intermediateBoutsDoubleSupportPercentageStd,%{private}.3f
Rejection: CLMobilitySteadinessModelBalance missing required feature inputs
CLMobility::SteadinessModelBalancePrior_Generated::Features CLMobility::SteadinessModelBalance::extractFeatures(CFAbsoluteTime, const std::vector<BoutMetrics> &) const
SteadinessModelBalance::extractFeatures,classificationTime,%{public}.2f,numBouts,%{public}lu,doubleSupportPercentages,%{public}lu,asymmetryPercentages,%{public}lu
kCMStrideCalDataContainerKeyTrack
kCMStrideCalDataContainerKeySession
kCMStrideCalDataContainerKeyGradient
kCMStrideCalDataContainerKeyGradientValidity
%@,Track,%@,Session,%@,Gradient,%0.6f,GradientValid,%ld
float CLWorkloadCalibrator::computeCalibrationValue(const CLNatalieModelInput *, const CFAbsoluteTime, const float, const float, bool &)
WorkloadCalibration, timestamp, %f, HRMETs, %f, WRMETs, %f, calibrationValue, %f, calibratedMets, %f
void CLWorkloadCalibrator::bootstrapCalibrationValueFromDb()
Workload Calibrator, DB Delete Records Before, expirationTime, %f
Workload Calibrator, DB Get All Records By Activity Type And Maximum Standard Deviation, activityType, %u, standardDeviation, %f
Workload Calibrator, Bootstraping Calibration, Value, %f
void CLWorkloadCalibrator::persistCalibration(const float, const float)
Workload Calibrator, DB Insert, activityType, %u, valueAverage, %f, standardDeviation, %f, entry.startTime, %f
Workload Calibrator, DB Delete Keep Last N, kMaximumDbHistorySize, %lu, activityType, %u
Workload Calibrator, DB Update, activityType, %u, valueAverage, %f, standardDeviation, %f, entry.startTime, %f
virtual void CLOdometerNotifierCompanion::updateOdometerState()
Taking gps odometer power assertion.
Releasing gps odometer power assertion.
void CLOdometerNotifierCompanion::updateStateOnAuthorization(bool)
void CLOdometerNotifierCompanion::enableGPS()
#wigo,on,OdometerNotifierCompanion
void CLOdometerNotifierCompanion::disableGPS()
#wigo,off,OdometerNotifierCompanion
void CLOdometerNotifierCompanion::notifyCoarseElevation(std::shared_ptr<CLCoarseElevationVector>)
onCoarseElevation,startTime,%{public}f,ascended,%{private}d,source,%{private}d
void CLOdometerNotifierCompanion::notifyLocation(const CLDaemonLocation &, const CLDaemonLocationPrivate &)
Odometer(GPS),%{public}f,%{private}f,%{public}f,%{private}f,%{private}f
void CLOdometerNotifierCompanion::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#Warning Received unhandled location notification, %{public}d
CLOdometerNotifierCompanion::onLocationNotification
CLATVAirplayMonitorSilo
-[CLATVAirplayMonitor startScan]
Bluetooth is OFF, ignoring request to scan
v16@?0@"<CLATVAirplayMonitorClientProtocol>"8
-[CLATVAirplayMonitor airPlaySolo:foundDevice:withData:]
Found device %{private}s withData: %{private}s
Found a device but its UUID is nil
WPPuckTypeAirPlaySoloAdvertisingData
No IP address provided. Ignoring device
Not enough data provided for advertisement data. Ignoring
WPPuckTypeAirPlaySoloRSSI
WPPuckTypeAirPlaySoloAdvertisingChannel
-[CLATVAirplayMonitor airPlaySoloStartedScanning:]
AirPlaySolo started scanning
-[CLATVAirplayMonitor airPlaySoloStoppedScanning:]
AirPlaySolo stopped scanning
-[CLATVAirplayMonitor airPlaySolo:failedToStartScanningWithError:]
Failed to start AirPlaySolo scanning. %{public}@
invalid uuid string
void boost::uuids::string_generator::throw_invalid() const
/System/Volumes/Data/SWE/iOS/BuildRoots/BuildRoot903/Applications/Xcode.app/Contents/Developer/Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator8.3.Internal.sdk/usr/local/include/boost/uuid/string_generator.hpp
0123456789abcdefABCDEF
ElevationLabel
void CLSignificantElevationEstimator::init()
init %s, %s
void CLSignificantElevationEstimator::reset()
Resetting significant elevation %s, %s
biasOfSigElevation
preAbsSigElevation
curAbsSigElevation
rebaseTime
void CLSignificantElevationEstimator::rebaseAbsSignificantElevation(double)
void CLSignificantElevationEstimator::updateWithVisit(CFAbsoluteTime, uint32_t, uint32_t, CLElevationSource, bool)
significant elevation break frequency change, inVisit, %d, resetCheck, %d
ReferenceAltitude
ElevationStartTime
ElevationEndTime
AscendedElevation
DescendedElevation
BufferedAscendedElevation
BufferedTimeStamp
AscendingState
ElevationDeviceSource
EpochTime
UpdateTime
cumulativeAltitudeFilterResetChange
weatherChangeEstimate
weatherBias
%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%d,%s,%s,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f
Time
void CLSignificantElevationEstimator::bufferCurrentElevation(CFAbsoluteTime, double)
%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%s,%s,%f
-[CMStrideCalibrator initInUniverse:stepCountDb:]
Not companion or watch. Returning.
AutomaticStrideCalibration,Pass,CreatingDaemonCacheForCalibrationBins
AutomaticStrideCalibration,Success,AllChecksPassed
-[CMStrideCalibrator setSession:]
setSession,oldSession,%ld,newSession,%ld
-[CMStrideCalibrator addLatestCalData:]
A new calData is added: %s
-[CMStrideCalibrator checkForLocationStateTransition]
ForcingLocationDueToGizmoRequest,session,%ld,%s
StepRunNotification,Pass,LeechingLocation,Steps,%d
StepRunNotification,Pass,AttemptingToForceLocation,Steps,%d
[self outOfSession]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/StrideCalibration/CMStrideCalibrator.mm
-[CMStrideCalibrator attemptForcedLocation]
AttemptForcedLocation,Fail,NotSufficientTimeSinceLastCalibrationSuccess,TimeSinceLastCalibrationSuccess,%0.3f
AttemptForcedLocation,Fail,NotSufficientTimeSinceLastCalibrationAttempt,TimeSinceLastCalibrationAttempt,%0.3f
AttemptForcedLocation,Fail,NotSufficientTimeSinceLastConverged,TimeSinceLastCalibrationAttempt,%0.3f
AttemptForcedLocation,Success,AllChecksPassed
-[CMStrideCalibrator quitForcedLocationState]
Terminated forced calibration.
-[CMStrideCalibrator fsm:didTransitionFromState:toState:]
LocationStateOld,%d,LocationStateNew,%d
-[CMStrideCalibrator fsm:didUpdateLocationAtTime:]
TrackClose,Pass,LocationTimeout,TimeSinceLastPosition,%0.3f
TrackClose,Pass,ForcedNotSufficientSteps,Steps,%d
TrackClose,Pass,EnabledNotSufficientSteps,Steps,%d
-[CMStrideCalibrator checkValidTrack:associatedEntry:]
TrackCalibration,Fail,Pedometer distance is zero,startTime,%f,endTime,%f
ZeroDistance
TrackCalibration,Fail,rawSpeed %f out of bounds,startTime,%f,endTime,%f
SpeedOutOfBounds
TrackCalibration,Fail,KFactorOutOfBounds,%s,KFactor,%0.4f,RawSpeed,%f,startTime,%f,endTime,%f
GainOutOfBounds
SessionMetrics,Fail,Pedometer,GainOutOfBounds,DistanceFusion,%0.6f,startTime,%f,endTime,%f
SessionMetrics,Fail,GPS,GainOutOfBounds,DistanceFusion,%0.6f,startTime,%f,endTime,%f
-[CMStrideCalibrator updateCalibrationBins:]
CalData, %s, stepEntryEpochTime, %f
GradientOutOfBounds
SessionMetrics,Fail,Gradient,DistanceFusion,startTime,%f,endTime,%f
FloorsAscended,%d,FloorsDescended,%d
Yay!
fTilesMap.find(tileId) != fTilesMap.end()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTilesMap.mm
unprotectedErase
unprotectedAdd
void CLDemTileAvailability::clearAvlCache()
DEM,clear AVL status cache
bool CLDemTileAvailability::isTileAvailableBasedOnAvlFile(double, double)
#Warning,DEM,availability file is not valid,fNeedToDownloadAvlFile,%{public}d
#Error,DEM,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d
DEM,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d
DEM,input latitude, %{private}.3lf, below minimum acceptable latitude, %{private}d
DEM,input latitude, %{private}.3lf, beyond maximum acceptable latitude, %{private}d
#Warning,DEM,avl byte index,%{public}d,is larger than the data available in the availabilty file,fNeedToDownloadAvlFile,%{public}d
#Warning,DEM,Invalid CLDEM availability file - unable to get data byte,fNeedToDownloadAvlFile,%{public}d
DEM,Unexpected case,fNeedToDownloadAvlFile,%{public}d
DEM,isTileAvailable,%{public}d,fNeedToDownloadAvlFile,%{public}d
bool CLDemTileAvailability::checkAvlFileValidityAndSetDownloadFlag()
DEM,fNeedToDownloadAvlFile,%{public}d
#Warning,DEM,availability file does not exist,fNeedToDownloadAvlFile,%{public}d
#Warning,DEM,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d
DEM,availability file version does not match expected,fNeedToDownloadAvlFile,%{public}d
DEM,availability file has expired,fNeedToDownloadAvlFile,%{public}d
DEM,end of checkAvlFileValidityAndSetDownloadFlag function reached,fNeedToDownloadAvlFile,%{public}d
static bool CLDemTileAvailability::readAvlHelper(FILE *, unsigned char *, CLDemTileAvailability::CLDEMTileAvailabilityData &, size_t &, size_t &)
DEM,fseek returned non-zero
#Warning,DEM,Invalid CLDEM availability file - header string
#Warning,DEM,Invalid CLDEM availability file - invalid header string
#Warning,DEM,Invalid CLDEM availability file - version
#Warning,DEM,Invalid CLDEM availability file - headerLength
#Warning,DEM,Invalid CLDEM availability file - minLat
#Warning,DEM,Invalid CLDEM availability file - maxLat
#Warning,DEM,Invalid CLDEM availability file - binsize
#Warning,DEM,coarse avl file is not 0.1 deg by 0.1 deg,spacing unexpected,%{public}.1f,re-download needed
#Warning,DEM,Invalid CLDEM availability file - timestamp
#Warning,DEM,Invalid CLDEM availability file - expiration age
#Warning,DEM,Invalid CLDEM availability file - data size
#Warning,DEM,Invalid CLDEM availability file - crc
DisableMapMatchingRouteHints
CLMapRouteHintController::CLMapRouteHintController()
CLMM, DisableMapMatchingRouteHints, %{public}d
void CLMapRouteHintController::addObserver(std::string, dispatch_queue_t, std::function<void (const CLMapsRouteHintData &)>)
CLMM,RouteHints,addObserver,%s,size,%lu
void CLMapRouteHintController::removeObserver(std::string)
CLMM,RouteHints,removeObserver,%s,size,%lu
void CLMapRouteHintController::updateMapRouteHint(CLClientLocationRouteHintType, CLClientLocationRouteHintType, std::vector<CLMapsRouteHint> &)
CLMM,RouteHints,updateMapRouteHint,%{public}d,routingType,%{public}d,stepType,%{public}d
CLFitnessTrackingNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/FitnessTracking/CLFitnessTrackingNotifier.mm
-[CLFitnessTrackingNotifierAdapter beginService]
CLFitnessTrackingNotifier
AllowUnactivatedFitnessTracking
virtual bool CLFitnessTrackingNotifier::unregisterForNotificationInternal(const CLFitnessTrackingNotifier_Type::Notification &)
Unknown notification during unregistration: %{public}d
Fitness
virtual void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::NotificationData>::listClients() [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLUsageSyncManagerSilo
com.apple.private.alloy.location.usage
kCLUsageSyncPairedDeviceID
kCLUsageSyncMessageTypeKey
kCLUsageSyncMessageDataKey
kCLUsageSyncMessageUsageUpdateKey
kCLUsageSyncClientKey
kCLUsageSyncMessageResyncResponseKey
kCLUsageSyncMessageResyncRequestKey
kCLUsageSyncResyncRequestQueueIdentifierKey
kCLUsageSyncUsageKey
usage-
com.apple.location.AggregateLocationIconApp
kCLUsageSyncResyncResponseQueueIdentifierKey
kCLUsageSyncMessagePromptKey
NRPairedDeviceRegistry
/System/Library/PrivateFrameworks/NanoRegistry.framework/NanoRegistry
NRPairedDeviceRegistryDeviceDidUnpairNotification
NRPairedDeviceRegistryDeviceDidPairNotification
NRPairedDeviceRegistryDeviceDidBecomeActive
NRPairedDeviceRegistryDeviceDidBecomeInactive
NRDevicePropertyPairingID
NRDevicePropertySerialNumber
kCLConnectionMessageSkiDataUpdate
kCLConnectionMessageSkiDataQuery
void CLSkiDataSubscription::handleRequestSkiDataUpdate(bool, const CLNameValuePair &)
SkiData subscription changed, %s, %p, %d
#Warning Failed to subscribe to ski updates.
void CLSkiDataSubscription::handleMessageSkiDataQuery(std::shared_ptr<CLConnectionMessage>)
CLDaemonClient.SkiNotifierQuery
void CLSkiDataSubscription::handleMessageSkiDataQuery(std::shared_ptr<CLConnectionMessage>)_block_invoke
Query: id, %llu, session, %s, source, %s, count: %lu
CLSkiDataSubscription::onSkiNotification
void DPPoint::convertLatLon()
Lat/lon is out of range for conversion.
void DouglasPeuckerPolygonSimplify(PointList &, const PointList &, double, int, int)
Input to Douglas-Peucker algorithm must have at least one vertex.
double curveSegmentCompare(const PointList &, int, int, SimplifyType, int &)
DynamicProgramArea distance is not implemented
void DynamicProgramPolygonSimplify(PointList &, const PointList &, double, SimplifyType)
#Warning Never achieved the desired simplification. Using the original curve.
Programming error. Number of points in backtrack do not match expected (1).
Programming error. Number of points in backtrack do not match expected (2): %{public}d, %{public}d
CLTimeZoneManager.MaximumTimeZoneChangeSpeed
CLTimeZoneManager.MaximumTimeZoneChangeAccuracy
CLTimeZoneManager.StartDelay
CLTimeZoneManager.MaxLocationDelay
CLTimeZoneManager.MaxFailures
CLTimeZoneManager.MinimumRetryDelay
CLTimeZoneManager.MaximumRetryDelay
CLTimeZoneManager.MaximumVerifyInterval
CLTimeZoneManager.MaximumCheckInterval
CLTimeZoneManager.EarlyCheckProportion
CLTimeZoneManager.ContinuousLocationDuration
CLTimeZoneManager.ReportPreviousTimezoneInterval
CLTimeZoneManager.ReachabilityRetryInterval
Etc/GMT
CLTimeZoneManagerSilo
TimeZone
PreviousTimeZone
CLTimeZoneManager::CLTimeZoneManager(id<CLIntersiloUniverse>)
Loaded previous time zone %s
TimeZoneManager.ActiveModeTimer
AutomaticTimeZoneUpdateNeeded
void CLTimeZoneManager::setStartTimer(const CFTimeInterval &)
Setting start timer to fire after %.2fs
void CLTimeZoneManager::setActiveModeTimer(const CFTimeInterval &)
Setting active mode timer to fire at %.2f (%.2fs away)
void CLTimeZoneManager::setContinuousLocationTimer(const CFTimeInterval &)
Setting continuous location timer to fire after %.2fs
void CLTimeZoneManager::onReachabilityTimer()
ReachabilityTimer fired
void CLTimeZoneManager::onContinuousLocationTimer()
Continuous location timer fired
#Warning Failed to get any fix while in continuous location mode
void CLTimeZoneManager::checkStatus()
Location services are disabled; stopping automatic time zone
Time Zone system service disabled; stopping automatic time zone
TimeZoneBorderDistance
TimeZoneBorderDistanceTimestamp
Automatic time zone starting in passive mode
Automatic time zone starting in active mode
Automatic time zone disabled
void CLTimeZoneManager::startActive()
Starting automatic time zone in active mode
Already have previous border distance and timestamp
void CLTimeZoneManager::enterActiveMode()
Entering active location mode
void CLTimeZoneManager::exitActiveMode()
Exiting active location mode
void CLTimeZoneManager::startPassive()
Starting automatic time zone in passive mode
void CLTimeZoneManager::stop()
#Notice Stopping automatic time zone
bool CLTimeZoneManager::shouldSetSystemTimeZone(const std::string &, const CLDaemonLocation &, double &)
We ran point-in-polygon on a location we threw out anyway!
Current time zone %s not in database; changing time because of acceptable location accuracy %.3f
#Warning Distance from previous time zone's border is %.3f; accuracy of position is %.3f
bool CLTimeZoneManager::setSystemTimeZone(const std::string &)
Telling timed the time zone is "%s".
bool CLTimeZoneManager::setTimeZoneIfAppropriate(const std::string &, const CLDaemonLocation &)
#Warning bystander location, used to set time zone, billed to 'TimeZone' system service
#Notice Potentially setting system time zone to %s based on <%{private}+.8lf,%{private}+.8lf> acc %.2f timestamp %.2f confidence %d
#Notice Potentially setting system time zone to %{public}s
Potentially setting system time zone to %s based on <%{private}+.8lf,%{private}+.8lf> acc %.2f timestamp %.2f confidence %d
void CLTimeZoneManager::handleNewLocation(const CLDaemonLocation &, bool)
#Warning Received invalid location for time zone
#Warning Disregarding location with accuracy: %.1f (> %.1f)
Received invalid location <%{private}+.8f,%{private}+.8f> for time zone
#Warning Disregarding location for timezone with speed: %.1f (> %.1f)
#Notice Handling new location <%{private}+.8lf,%{private}+.8lf>, acc %.2f, timestamp %.2f, lifespan %.2f, confidence %d
Distance travelled from last point is %.3lf; previous point's distance from border was %.3lf
We've travelled outside our "fence".
#Warning Couldn't get time zone for location <%{private}+.8lf,%{private}+.8lf>
Time zone from database was %s
#Warning Not using <%{private}+.8lf,%{private}+.8lf> (timestamp %.2f) because interval has not elapsed
We're still inside our last "fence".
we've previously confirmed our timezone
Distance travelled from last unconfirmed point is %.3lf; previous point's distance from border was %.3lf; acc is %.3lf
time zone confirmed (horizontalAccuracy has improved faster than we've moved)
#Warning we can't possibly confirm our timezone, uncertainty too large
we can't optimize, find out if this position confirms our location
Unconfirmed border distance is <= 0 yet we have an unconfirmed timezone label.
void CLTimeZoneManager::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Got data mode change notification; entering continuous location mode
Got data mode change notification, but haven't exceeded reachability interval(%.3f s).  Will try again in %.3f s
Got airplane entered notification
Got airplane mode exited notification; entering continuous location mode
void CLTimeZoneManager::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
Got new time zone location: %d
#Warning Ignoring expired location <%{private}+.8f, %{private}.8f>, acc %.2f, timestamp %.2f, lifespan %.2f
#Warning Ignoring unsure location <%{private}+.8f, %{private}.8f>, acc %.2f, timestamp %.2f, lifespan %.2f, confidence %d
#Warning Ignoring inaccurate location <%{private}+.8f, %{private}.8f>, acc %.2f
#Warning Ignoring borderline location <%{private}+.8f, %{private}.8f>, acc %.2f
Got kNotificationLocationUnavailable
Got kNotificationServiceAuthorization
#Warning Got unknown notification %d
#Warning received unknown notification %s from telephony service
void CLTimeZoneManager::onLocationTimeZoneActiveNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
Automatic time is now in mode %d
void CLTimeZoneManager::onManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
#Warning location status reset; removing all clients
void CLTimeZoneManager::onImmediateCheckNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
Got immediate check notification
void CLTimeZoneManager::enterContinuousLocationMode(CLTimeZoneManager::ContinuousLocationMode, bool)
Transition from continuous active to continuous active with retry
Already in continuous location mode; not re-entering
Location services are disabled; not starting continuous location
Time Zone system service disabled; not starting continuous location
In bystander-only mode; not starting continuous location
Entering continuous location mode
Timezone is not confirmed.
void CLTimeZoneManager::exitContinuousLocationMode()
Not in continuous location mode; not exiting
Exiting continuous location mode
void CLTimeZoneManager::locationFailed(bool)
Not registered for location or fine location; ignoring location failure
Got location unavailable while in continuous location mode; ignoring location failure
AutomaticTimeZoneUpdateFailed
#Warning Location failed for time zone (exiting continuous mode %d; failure count now %d)
Maximum failure count not exceeded; retrying in %.2f seconds
Exceeded maximum failures; not retrying for %.2f seconds
CLTimeZoneManager::onSettingsNotification
CLTimeZoneManager::onLocationNotification
CLTimeZoneManager::onStatusNotification
CLTimeZoneManager::onManagerNotification
CLTimeZoneManager::onActiveModeTimer
CLTimeZoneManager::onImmediateCheckNotification
/System/Library/PrivateFrameworks/CoreTime.framework/CoreTime
CLTimeZoneManager::onLocationTimeZoneActiveNotification
TMLocationTimeZoneActiveNotification
TMSetSourceUnavailable
TMSourceLocation
TMIsAutomaticTimeZoneEnabled
TMSetSourceAvailable
TMSetSourceTimeZone
TMIsTimeZoneConfirmed
CLFenceManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLFenceManager.mm
-[CLFenceManagerAdapter beginService]
kCLConnectionMessageNameKey
kCLConnectionMessageOnBehalfOfKey
kCLConnectionMessageRegionTypeKey
kCLConnectionMessageLatitudeKey
kCLConnectionMessageLongitudeKey
kCLConnectionMessageRadiusKey
kCLConnectionMessageReferenceFrameKey
kCLConnectionMessageNotifyOnEntryKey
kCLConnectionMessageNotifyOnExitKey
kCLConnectionMessageConservativeEntry
kCLConnectionMessageEmergencyKey
kCLConnectionMessageDeviceIDKey
kCLConnectionMessageHandoffTagKey
FenceStartDelay
void CLFenceManager::init()
Overriding fence start delay to %{private}.2f
FenceShowTriggerDialog
setting FenceStartShowDialog to %{private}d
FenceManagerStart
void CLFenceManager::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Fence: Start after unclean shutdown
void CLFenceManager::start(bool)
Fence: Starting fence monitoring
Fence: Already started fence monitoring
virtual void CLFenceManager::shutdown()
Fence: CLFenceManager, shutdown
void CLFenceManager::resetFenceMonitoring_nl()
Fence: resetFenceMonitoring_nl
void CLFenceManager::startMonitoringAllFences_nl(bool, bool)
Fence: startMonitoringAllFences_nl
Starting to monitor all %{public}ld authorized fences
void CLFenceManager::startMonitoringFences_nl(const std::vector<CLFenceManager_Type::Fence> &)
Fence: startMonitoringFences_nl
void CLFenceManager::stopMonitoringFences_nl(const std::vector<CLFenceManager_Type::Fence> &, bool)
Fence: stopMonitoringFences_nl
void CLFenceManager::maintenanceActiveRateLimiters()
Fence: erasing dormant bucket %{private}s
Fence: Number of buckets,%{public}lu,%{public}lu
bool CLFenceManager::addFence(const CLFenceManager_Type::Fence &)
Fence:Add sending kNotificationFenceSetupCompleted - existed, fence, %{private}s
#Warning monitoring for identical pre-existing fence hasn't started yet
com.apple.locationd.bundle-/System/Library/PrivateFrameworks/BulletinBoard.framework
com.apple.locationd.bundle-/System/Library/PrivateFrameworks/FMF.framework
com.apple.locationd.bundle-/System/Library/LocationBundles/RemindersAlerts.bundle
com.apple.locationd.bundle-/System/Library/LocationBundles/Wea.bundle
com.apple.locationd.bundle-/AppleInternal/Library/Frameworks/CoreAutomationDevice.framework
com.apple.locationd.bundle-/AppleInternal/Library/LocationBundles/FenceTester.bundle
com.apple.locationd.bundle-/System/Library/LocationBundles/LocationFenceSync.bundle
Fence: fence not added, too many fences, %{private}s, %{private}lu, %{private}u
Fence: monitoring is not supported on this platform; not adding fence %{private}s/%{private}s
Not adding fence %{private}s/%{private}s because coordinate is invalid
canPerformMonitoringForFence is true, fence, %{private}s
canPerformMonitoringForFence is false, fence, %{private}s
Adding fence %{private}s
Fence:Fail sending kNotificationFenceFailure, fence, %{private}s
Fence:Add sending kNotificationFenceSetupCompleted, fence, %{private}s
bool CLFenceManager::removeFence(const CLFenceManager_Type::Fence &)
Fence:Remove fence %{public}s/%{private}s
void CLFenceManager::requestRegionState(const CLFenceManager_Type::Fence &)
Fence: requestRegionState, %{private}s/%{private}s, registered, %{public}d, authorized, %{public}d
Fence: requestRegionState, fence, %{private}s/%{private}s, status, %{private}d, %{private}s
Fence: requestRegionState, fence, %{private}s/%{private}s, not authorized
Fence: requestRegionState, fence, %{private}s/%{private}s, not registered
Fence: requestRegionState, fence, %{private}s/%{private}s, error.
void CLFenceManager::requestAllHandoffTags()
#FenceHandoff fence manager doing requestAllHandoffTags
void CLFenceManager::fenceStatusChanged(const CLFenceMonitor_Type::Notification &, const CLFenceManager_Type::Fence &, const CLFenceManager_Type::FenceStatus &, const CLFenceManager_Type::FenceStatus &, const CLDaemonLocation &)
Fence:Status fence, %{private}s, status, %{private}s, isIssueNotification, %{public}d, fenceAge, %{public}.1lf, StopTime, %{private}.1lf, StartTime, %{private}.1lf
Fence: fence, %{private}s, new status, %{private}s, bundleId, %{private}s, not authorized, avoiding notification
void CLFenceManager::addPendingFenceEntryExitNotification(CFAbsoluteTime, const CLFenceManager_Type::Fence &, const CLFenceManager_Type::FenceStatus &, const CLDaemonLocation &)
pending, transition, %{private}s, fence, %{private}s, timestamp, %{private}.1lf
void CLFenceManager::addPendingFenceStateNotification(CFAbsoluteTime, const CLFenceManager_Type::Fence &, const CLFenceManager_Type::FenceStatus &, const CLFenceManager_Type::Notification &)
pending, state, %{private}s, fence, %{private}s, timestamp, %{private}.1lf
void CLFenceManager::pendingFenceMaintenanceOnClientRegistration(CFAbsoluteTime, CLFenceManager_Type::FenceStatus, int, const std::string &)
#Warning Fence: avoid notifyFenceEntryExitForAuthorizedFence, fence, %s, status, %s, searchStatus, %s, client, %d, timestamp,%.1lf
notifyFenceEntryExitForAuthorizedFence,fence,%{private}s,fenceStatus,%{private}s,searchStatus %{private}s,client,%{public}d
#Warning Fence: avoid sendFenceStatusNotification, fence, %{private}s, status, %{private}s, searchStatus, %{private}s, client, %{public}d, timestamp,%{public}.1lf
sendFenceStatusNotification,fence,%{private}s,fenceStatus,%{private}s,searchStatus %{private}s,client,%{public}d
((status == CLFenceManager_Type::kFenceStatusInside) || (status == CLFenceManager_Type::kFenceStatusOutside))
notifyFenceEntryExitForAuthorizedFence
entered
exited
 (all)
bool CLFenceManager::notifyFenceEntryExitForAuthorizedFence(const CLFenceManager_Type::Fence &, const CLFenceManager_Type::FenceStatus &, const CLDaemonLocation &, int)
Fence: Sending %{private}s notification for [%{public}s]/%{private}s/%{private}s to client %{public}d%{private}s, sinceLast,%{private}.1f, type,%{private}d,%{private}d,%{private}d,%{private}d,%{private}d, motion,%{private}d,%{private}d,%{private}d,%{private}d
void CLFenceManager::notifyFenceStateForAuthorizedFence(const CLFenceManager_Type::Fence &, const CLFenceManager_Type::FenceStatus &, const CLFenceManager_Type::Notification &, int)
Fence: Sending state notification (requested: %{private}d) for [%{public}s]/%{private}s/%{private}s to client %{public}d%{private}s
void CLFenceManager::notifyAndLaunchClientForAuthorizedFenceOnEntryExit(const CLFenceManager_Type::Fence &, const CLFenceManager_Type::FenceStatus &, const CLDaemonLocation &)
#Warning Invalid fence status, %d
ENTER
EXIT
Fence Trigger
data.lastStatus != CLFenceManager_Type::kFenceStatusUnknown
onMonitorNotification
void CLFenceManager::onDataDownloadNotification(int, const CLFenceDataDownloadManager_Type::Notification &, const CLFenceDataDownloadManager_Type::NotificationData &)
Fence: Got data downloaded notification for [%{public}s]/%{public}s/%{private}s
#Warning Fence: Got data download failure notification for [%{public}s]/%{private}s/%{private}s
Fence: Got data download invalidated notification
void CLFenceManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
Fence: Got kNotificationLocationServicesStatus, enabled, %{public}d, StopTime, %{public}.1lf, StartTime, %{public}.1lf
#Warning Got unknown client notification %{public}d
void CLFenceManager::onAuthorizationNotification(int, const CLFenceAuthorizationManager_Type::Notification &, const CLFenceAuthorizationManager_Type::NotificationData &)
Fence: Got fence addition notification for %{public}ld fences
Fence [%{public}s]/%{public}s/%{private}s is authorized
onAuthorizationNotification
#Warning throttle fine fence usage by client [%{public}s]/%{public}s, %{private}s
Fence [%{public}s]/%{public}s/%{private}s is not authorized
Fence: Got fence removal notification for %{public}ld fences
Fence: Got fence reset notification
void CLFenceManager::onMotionStateNotification(int, const CLMotionState_Type::Notification &, const CLMotionState_Type::NotificationData &)
Received motion state,static,%{private}d,walking,%{private}d,driving,%{private}d,inVehicle,%{private}d
Unhandled notification %{public}d
CLFenceManager::onClientNotification
CLFenceManager::onMonitorNotification
CLFenceManager::onStartTimer
CLFenceManager::onDaemonStatusNotification
CLFenceManager::onMotionStateNotification
CLFenceManager::onDataDownloadNotification
CLFenceManager::onAuthorizationNotification
Pending geofence notification
virtual void CLNotifier<CLFenceManager_Type::Notification, CLFenceManager_Type::NotificationData, char, std::string>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLFenceManager_Type::Notification, NotificationData_T = CLFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
void CLNotifier<CLFenceManager_Type::Notification, CLFenceManager_Type::NotificationData, char, std::string>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLFenceManager_Type::Notification, NotificationData_T = CLFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
{vector<CLFenceManager_Type::Fence, std::allocator<CLFenceManager_Type::Fence>>=^{Fence}^{Fence}{__compressed_pair<CLFenceManager_Type::Fence *, std::allocator<CLFenceManager_Type::Fence>>=^{Fence}}}8@?0
virtual bool CLNotifier<CLFenceManager_Type::Notification, CLFenceManager_Type::NotificationData, char, std::string>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFenceManager_Type::Notification, NotificationData_T = CLFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual void CLNotifier<CLFenceManager_Type::Notification, CLFenceManager_Type::NotificationData, char, std::string>::removeClient(int) [Notification_T = CLFenceManager_Type::Notification, NotificationData_T = CLFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLFenceManager_Type::Notification, CLFenceManager_Type::NotificationData, char, std::string>::clientRegistered(int, const Notification_T &) [Notification_T = CLFenceManager_Type::Notification, NotificationData_T = CLFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLFenceManager_Type::Notification, CLFenceManager_Type::NotificationData, char, std::string>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLFenceManager_Type::Notification, NotificationData_T = CLFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual void CLNotifier<CLFenceManager_Type::Notification, CLFenceManager_Type::NotificationData, char, std::string>::listClients() [Notification_T = CLFenceManager_Type::Notification, NotificationData_T = CLFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
CLMotionAlarmNotifier
kCLConnectionMessageMotionAlarmFire
kCLConnectionMessageMotionAlarmRegister
kCLConnectionMessageMotionAlarmUnregister
kCLConnectionMessageMotionAlarmAcknowledge
kCLConnectionMessageMotionAlarmLaunchRemoteApplication
com.apple.locationd.motion_alarms
v20@?0@"CMMotionAlarm"8i16
void CLMotionAlarmSubscription::handleRequestMotionAlarmFire(bool, const CLNameValuePair &)
Motion alarm fire subscription changed, %s, %p, %d
static NSString *CLMotionAlarmSubscription::bundleIdForClient(CLClientManager_Type::Name)
Unable to find bundle identifier!
MotionAlarm
{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}8@?0
kCLConnectionMessageSubscribeKey
void CLMotionStateUtils::logChange(const CLMotionActivity &, const CLMotionActivity &, const char *)
MotionState,Motion,From,%d,To,%d,conf,%d,Mounted,From,%d,To,%d,conf,%d,tilt,%.1f,exitC,%d,exitTime,%f,startTime,%f,timestamp,%f,standing,%d,rawMotionType,%d,rawConfidence,%d,motionHint,%d,bbHint,%d,wifiHint,%d,btHint,%d,gpsHint,%d,drivingStowedLikelihoodSum,%f,drivingArmLikelihoodSum,%f,ssLikelihoodSum,%f,tag,workoutDetectionType,%d,workoutDetectionTime,%f,workoutEscalationTime,%lld, YouthMotionState, %d, %s
MotionSyncFireIntervalInSeconds
CLMotionSyncStoreWatch::CLMotionSyncStoreWatch(id<CLIntersiloUniverse>)
MotionSyncSendCalsFireIntervalInSeconds set to %f seconds.
CLMotionSyncStoreWatch::CLMotionSyncStoreWatch(id<CLIntersiloUniverse>)_block_invoke
Timer fired.
virtual void CLMotionSyncStoreWatch::deviceUnlocked()
unlocked
void CLMotionSyncStoreWatch::updateCalibrations()
Watch retrieved calibrations and saved them in memory, current version, %d
void CLMotionSyncStoreWatch::sendMotionCalsToCompanion()
%s, current version, %d, timestamp, %lf
void CLMotionSyncStoreWatch::persistCachedValues()
Watch did not persist Motion Cals, waiting until unlock, current version, %d, isDeviceCurrentlyUnlocked, %d
Begin persisting calibrations to disk on watch, current version, %d.
Persisted a reset Motion Cals
Finished setting user profile on watch = %s
Persisted raw speed to kValue bins
Persisted step cadence to stride length bins
Completed persistence of motion cals to disk on watch. %s
virtual void CLMotionSyncStoreWatch::receiveMotionCals(NSDictionary *)
Watch received motion calibrations from companion, %s, version, %d, timestamp, %lf, udid, %s
void CLMotionSyncStoreWatch::onUserInfoNotification(int, const CLNatalimetryNotifier_Type::Notification &, const CLNatalimetryNotifier_Type::NotificationData &)
user info notification
void CLMotionSyncStoreWatch::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)
Workout session ended on watch.
#Warning Unhandled notification %d
void CLMotionSyncStoreWatch::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
notification, %d
Unhandled notification
virtual void CLMotionSyncStoreWatch::rawSpeedToKValueBinsHaveChanged()
raw speed to kValue bins updated
virtual void CLMotionSyncStoreWatch::stepCadenceToStrideLengthBinsHaveChanged()
step cadence to stride length bins updated
void CLMotionSyncStoreWatch::doRestoreBackupMotionCals(const CLMotionSyncStoreWatch::EDeviceUnlocked *)
restore backup motion cals
void CLMotionSyncStoreWatch::doConnected(const CLMotionSyncStoreWatch::ECompanionConnected *)
connected
void CLMotionSyncStoreWatch::doUpdateMotionCals(const CLMotionSyncStoreWatch::EMotionCalsUpdated *)
updating motion cals
void CLMotionSyncStoreWatch::doRestoreBackupMotionCalsArbitrate(const CLMotionSyncStoreWatch::EDeviceUnlocked *)
restore and arbitrate
void CLMotionSyncStoreWatch::doBufferMotionCalsFromCompanion(const CLMotionSyncStoreWatch::ECalibrationFromCompanion *)
Buffered motion cals from companion
void CLMotionSyncStoreWatch::doDisconnected(const CLMotionSyncStoreWatch::ECompanionDisconnected *)
disconnected
void CLMotionSyncStoreWatch::doArbitrateMotionCals(const CLMotionSyncStoreWatch::ECalibrationFromCompanion *)
arbitrateMotionCals
void CLMotionSyncStoreWatch::restoreBackupMotionCals()
Restored backup calibrations, %s, version, %d, timestamp, %lf
motionCals[kCalibrationUDID]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/MotionSync/CLMotionSyncStoreWatch.mm
updateCalsBasedOnResult
currentMotionCals[kCalibrationUDID]
arbitrateMotionCals
CLMotionSyncStoreWatch::ArbitrateResult CLMotionSyncStoreWatch::arbitrateMotionCals(NSDictionary *, NSDictionary *) const
No buffered Motion Cals, no arbitration
Ignoring update.  Phone Motion Cals UDID %s is different from current UDID %s, but version %d is not larger than current version %d
Buffered Motion Cals, version, %d, timestamp, %lf, udid, %s, Current Motion Cals, version, %d, timestamp, %lf, udid, %s, result, %d
void CLMotionSyncStoreWatch::scheduleFastSendToCompanion()
schedule send to companion
CLMotionSyncStoreWatch::onMotionStateMediatorNotification
CLMotionSyncStoreWatch::onUserInfoNotification
CLMotionSyncStoreWatch::onCompanionNotification
CLFenceMonitorCell
bool CLFenceMonitorCell::lacMonitoringSufficient(const CLFenceManager_Type::Fence &, const CLDaemonLocation &)
Fence: distance = %.2f; compare = %.2f
not 
Fence: LAC monitoring is %ssufficient for %s/%s
bool CLFenceMonitorCell::cellMonitoringSufficient(const CLFenceManager_Type::Fence &, const CLDaemonLocation &)
distance = %.2f; compare = %.2f
Fence: no allowing wifi monitor for, %.1lf, fence, %s
Cell monitoring is %ssufficient for %s/%s
Fence_deprecated
request
scan
live
reproc
static std::vector<Types::ComputedLocation> CL::Wifi1::Policies::PositionCalculation::HandleEvent::processScanGroups(cl::chrono::CFAbsoluteTimeClock::time_point, const CLWifiService_Type::AccessPointGroups &, const std::vector<CLWifiAPLocation> &, Types::WsbPassType)
@WsbCalc, groups, %{public}lu, %{public}s
ap.hasValidLocation()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/Logic/Policies/CLWifiPositionCalculation.mm
processScanGroups
@WsbLoc, fix, aps, %{public}d, %{public}lu, reproc, %{public}d, time, %{public}.1f, ll, %{private}.7f, %{private}.7f, hAcc, %{public}.1f
WsbMetric, fix, aps, %{public}d, age, %{public}0.1f, %{public}s
com.apple.clx.wsb.fix
pass
@WsbLoc, none, aps, %{public}lu, reproc, %{public}d, time, %{public}.3f
WsbCalc, computed, %{public}d, of, %{public}lu, %{public}s
WsbMetric, groupresult, %{public}s, %{public}d
com.apple.clx.wsb.groupresult
groupResult
numInGroup
static Types::ComputedLocation CL::Wifi1::Policies::PositionCalculation::HandleEvent::computePosition(const std::map<std::string, int> *, const std::vector<CLWifiAPLocation> &, const std::vector<CLWifiAPLocation> &, const CLDaemonLocation &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point, CLWifiAltitudeKalmanFilter *, const CL::Wifi1::Types::ElevationHistory *, CLLocationCalculator::ZaxisDebuggingData &)
@WifiAps, compute, %{public}lu, used, %{public}u, used_vert, %{public}u, hint, %{public}d
WifiCalc, zaxis, isWsb, %{public}d
WifiCalc, zaxis input kalmanFilter, initialized, %{public}s, relative altitude, %{private}.6f, wifiAltUncAve, %{private}.6f, alt_k_k, %{private}.6f, alt_k1_k, %{private}.6f, cov_k_k, %{private}.6f, cov_k1_k, %{private}.6f, process noise variance, stable, %{private}.6f, unstable, %{private}.6f, measurement variance, %{private}.6f, timestamp, propagate, %{private}.3lf, update, %{private}.3lf, relative altitude timestamp, %{private}.3lf, wifi time interval, %{private}.6f, relative altitude time interval, %{private}.6f, altitude change during baro outage, %{private}.6f
WifiCalc, zaxis input elevation, size, %{public}d, relative altitude, %{private}.6f, timestamp, %{public}.3lf, elevation steady, %{public}s
WifiCalc, zaxis input elevation empty, stop filter
WifiCalc, zaxis, reported invalid alt, %{private}.2f, unc, %{private}.2f
Types::ComputedLocation CL::Wifi1::Policies::PositionCalculation::HandleEvent::updateSingleShotLocation(const char *, CLWifiAltitudeKalmanFilter *) const
WlpMetric, fixaps, %{public}d, trigger, %{public}s, used, %{public}d, out, %{public}d, pct, %{public}d
com.apple.clx.wifiloc.fixaps
fixaps
outliers
MultiAP
wifi, null
wifi, sentinel
@WifiFlow, compute, %{public}u, hacc, %{public}.1f, vaps, %{public}u, vacc, %{public}.1f, conf, %{public}d, reason, %{public}s
static
WlpMetric, fixerror, %{public}.1f, agetype, %{public}s, dt, %{public}.1f, %{public}d, ratio, %{public}.1f
com.apple.clx.wifiloc.fixerror
agebin
truth
bothbad
timebad
placebad
WlpMetric, fixerror, %{public}s
gizmo
bool CL::Wifi1::Policies::PositionCalculation::HandleEvent::isLocationAccuracySufficient(const Types::ComputedLocation &, float) const
@WifiFlow, sufficiency, %{public}d, %{public}s
_ZAxis
_LatLon
void CL::Wifi1::Policies::PositionCalculation::logWifiApLocations(const std::vector<CLWifiAPLocation> &, const std::vector<CLWifiAPLocation> &)
WifiCalc, input AP, %{public}d, %{private}s, %{private}.7f, %{private}.7f, hacc, %{public}.6f, reach, %{public}d, altitude, %{private}.2f, vacc, %{public}.2f, rssi, %{public}d, channel, %{public}d, scan timestamp, %{public}.3lf, query timestamp, %{public}.3lf, %{private}s
CLFenceDatabase::CLFenceDatabase(const CLSqliteDatabase::SqliteProperties &, const CLSqliteDatabase::ColumnInfo *, bool)
Fence: No access to DB
FenceHandOffDeviceId
GeoFences
HandoffFences
bool CLFenceDatabase::addFence(const CLFenceManager_Type::Fence &, int, int &)
Fence: addFence, %{private}s, key, %{public}d
Fence: attempting to add fence to db without a key
DesiredAccuracy
SetupComplete
MonitorFlags
OnBehalfBundleId
ReferenceFrame
FenceForeignKey
HandoffTag
HandoffFenceEnablementStatus
DeviceIdIndex
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
#Warning Fence: Couldn't bind statement for adding fence (bundle ID %{public}s, name %{private}s, deviceId %{public}s)
FenceIndex
INSERT OR IGNORE INTO 
HandoffStatus
) VALUES (?,?)
bool CLFenceDatabase::removeFence(const CLFenceManager_Type::Fence &, int &)
Fence: Removing fence %{public}s/%{private}s
#Warning Fence: Couldn't bind statement for deleting fence (bundle ID %{public}s, name %{private}s)
Fence: No vertices removed for key %{public}d
bool CLFenceDatabase::removeAllFencesForBundleIncludingOnBehalf(const std::string &, const std::vector<int> &)
#Warning Fence: Couldn't bind statement for deleting fences for bundle ID %{public}s
DeviceId
 INNER JOIN 
bool CLFenceDatabase::getAllFences(std::vector<CLFenceManager_Type::Fence> &)
Fence: Couldn't get fences from database
Fence: fetched fence, %{private}s
fence.fenceKey != CLFenceManager_Type::kFenceKeyNotSet
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLFenceDatabase.mm
getAllFences
Fence: Error in retrieving fences from database
bool CLFenceDatabase::getFence(const std::string &, const std::string &, const std::string &, CLFenceManager_Type::Fence &)
Fence: Couldn't bind fence [%{public}s]/%{public}s/%{public}s
fetched fence, %{private}s
getFence
Fence: Fence doesn't exist [%{public}s]/%{public}s/%{private}s
Fence: Error in retrieving fence key from database for [%{public}s/%{public}s/%{private}s
bool CLFenceDatabase::getFencesForBundle(const std::string &, std::vector<CLFenceManager_Type::Fence> &)
Fence: Couldn't bind bundle ID %{public}s
fetched bundle fence, %{private}s
getFencesForBundle
Fence: Error in retrieving fences from database for bundle ID %{public}s
bool CLFenceDatabase::getFencesForBundleIncludingOnBehalf(const std::string &, std::vector<CLFenceManager_Type::Fence> &)
fetched bundle or onbehalf fence, %{private}s
getFencesForBundleIncludingOnBehalf
Fence: Error in retrieving fences from database for bundle or onbehalf ID %{public}s
bool CLFenceDatabase::isFenceRegistered(const std::string &, const std::string &, const std::string &)
int CLFenceDatabase::getPrimaryKeyForFence(const CLFenceManager_Type::Fence &)
int CLFenceDatabase::numFencesForBundle(const std::string &)
#Warning Fence: Couldn't get number of fences for bundle ID %{public}s
 EXCEPT 
=? WHERE 
bool CLFenceDatabase::resetHandoffStatus()
Fence: resetHandoffStatus unable to bind
void CLFenceDatabase::lastDownloadTimeChanged(const std::string &, const std::string &, const std::string &, const double)
Fence: Recording [%{public}s]/%{public}s/%{private}s last download time change to %{public}.2f
#Warning Fence: Couldn't update last download time for %{public}s/%{private}s in database
void CLFenceDatabase::markDataDownloadInvalid()
Fence: Marking all fence data download times as invalid
void CLFenceDatabase::markDataDownloadInvalidForBundleAndOnBehalf(const std::string &, const std::string &)
Fence: invalidate download date for, %{public}s
UPDATE OR IGNORE 
Fence: failed to bind bundleId, %{public}s
bool CLFenceDatabase::getBundleIds(std::vector<std::string> &)
Fence: Couldn't get bundle IDs from database
Fence: Error in retrieving bundle IDs from database
bool CLFenceDatabase::getAllBundleIdIncludingOnBehalfOfBundleId(std::unordered_set<std::string> &)
) VALUES (?)
void CLFenceDatabase::initDeviceIdTable()
Fence: #FenceHandoff Unable to initDeviceIdTable
void CLFenceDatabase::setUniqueKeysToFenceForeignKeyColumn()
Fence: Setting fence keys values for existing fences
 = rowid
Fences
void CLFenceDatabase::initHandoffTag()
Fence: Unable to bind default handoff tag
void CLFenceDatabase::setFenceEnablementStatus(CLFenceHandoffManager_Type::FenceHandoffEnablementStatus)
Fence: Unable to bind default enablement status
void CLFenceDatabase::initDeviceIdIndex()
Fence: Unable to bind default deviceId index
 WHERE length(
) > 512
value
CLWifiTileBlobsTable::CLWifiTileBlobsTable(const std::string &, const std::string &)
@TileData, CLWifiTileBlobsTable, not connected to wifi #tile header table
 = ? LIMIT 1;
bool CLWifiTileBlobsTable::saveWifiTileBlobData(const CLWifiTileBlobsEntry &, std::optional<CLWifiTileParser::MemoryMappedFileHandle *>)
@TileData, saveWifiTileBlobData, not connected to wifi #tile blobs table
) VALUES (?, ?, ?, ?, ?)
std::optional<CLWifiTileBlobsEntry> CLWifiTileBlobsTable::selectBlobDataByTileXY(const WifiTileXY &)
@TileData, selectBlobDataByTileXY, not connected to wifi #tile data table
bool CLWifiTileBlobsTable::deleteBlobDataByTileXY(const WifiTileXY &)
@TileData, deleteBlobDataByTileXY, not connected to wifi #tile blob data table
std::vector<std::optional<CLTilesManager_Type::AccessPointEntry>> CLWifiTileBlobsTable::findMacAddresses(const std::vector<CLMacAddress> &, int, int, int)
Failed to read wifi tile successfully
results.size() == targetMacs.size()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Network/CLWifiTileBlobsTable.mm
findMacAddresses
 = ?;
static std::unique_ptr<CLSqliteDatabase> CLWifiTileBlobsTable::connectAndCreateTableIfNotExistsIfNecessary(const std::string &, const CLSqliteDatabase::ColumnInfo *, const CLSqliteDatabase::SqliteProperties &)
TileDataOffsetBytes
SizeOfTileDataBytes
TileData
bool CLGyroCalibrationUtils::isGYTTVersionValid(NSData *, UInt16 *)
GYTT data not long enough to get version properly
Invalid version parameter.
gyro
gyro-temp-table
GYTTOverride
bool CLGyroCalibrationUtils::copyGYTTData(NSData **)
Service doesn't exist
No optional GYTT data found
Cannot get GYTT property
GYTT data %@
Invalid GYTT parameter data.
void CLGyroCalibrationUtils::readFactoryGYTT(std::vector<std::pair<float, CLMotionTypeRotationRate>> &)
Failed to read GYTT.
GYTT version (%{public}u) does not match expected version (%{public}u)
Attempting GYTT recovery!
After recovery, GYTT version (%{public}u) still does not match expected version (%{public}u)
Invalid GYTT temperature %{public}f
Reading GYTT point %zu: %f,%f,%f,%f
Skipping GYTT point %zu: %f,%f,%f,%f
%zu GYTT points found
bool CLWorkoutLabeler::startTier2SmootherIfNecessary()
Started Tier2 smoother.
void CLWorkoutLabeler::stopTier2Smoother()
Stopped Tier2 smoother.
void CLWorkoutLabeler::update()
Tier2Smoothed,%d,Confidence,%d
kElevationSourcePhone
kElevationSourceWatch
virtual CLWorkoutPredictor_Type::WorkoutStopDetectionEvent CLWorkoutStopModelHR::update(const CLWorkoutPredictorInputs &)
n,%lu,baseline,%f,counter,%f,t,%f,exertion,%f,baseThreshold,%f,lowExertionThreshold,%f,accelVectorMagnitude,%f,HRStop
HRModel,stopping workout,baseline,%{private}f,restingHeartRate,%{private}f
CLTransitMacTileDataProviderSilo
-[CLTransitMacTileDataProvider beginService]
TransitMac: service begin
-[CLTransitMacTileDataProvider endService]
TransitMac: service end
SpoofTransitMacQuery
-[CLTransitMacTileDataProvider onDarwinNotifierNotification:data:]
TransitMac: spoofing a query
MacAddress
-[CLTransitMacTileDataProvider onDarwinNotifierNotification:data:]_block_invoke
TransitMac: result, %lu
TransitMac, result, mac, %s
{vector<unsigned long long, std::allocator<unsigned long long>>=^Q^Q{__compressed_pair<unsigned long long *, std::allocator<unsigned long long>>=^Q}}8@?0
machineFrequency
virtual CLSwimAlgResultFlags CLSwimAlgController::processFusion(const CLSwimFusionInput &, CLSwimEntry &)
Stroke detected,timestamp,%.3f,count,%lu,startTime,%f,isSwim,%d,style,%d
Turn detected,timestamp,%f,startTime,%f,isSwimming,%d
void CLSwimAlgController::feedOdometer(const CLOdometerNotifier_Type::NotificationData &)
[SwimOdom] Received an odometer update,distance,%lf,accuracy,%lf,speed,%lf,rawspeed,%lf,odometer,%lf,gpsSpeedAccuracy,%lf,timestampGps,%lf
bool CLSwimAlgController::commitLaps(std::vector<CLSwimDetectedLap> &, CLMotionTypeTimestamp)
New lap entry, identifier, %llu, uuid, %s, sourceId, %s, startTime, %f, endTime, %f, timestamp, %f, pace, %f, distance, %f, paceSource, %d, style, %d, numberOfStrokes, %d, totalLaps, %d, inserted, %d, segment, %d
New lap entry, failed to get and log new lap entry after adding to db.
void CLSwimAlgController::logDistributionParameters(CLSwimStyleType, CLMotionTypeTimestamp, CLMotionTypeTimestamp, CLSwimStrokesPerTurnDistribution) const
style,%d,currentTimestamp,%f,turnTimestamp,%f,turnStartTime,%f,mean,%f,stddev,%f,min,%f,max,%f,median,%f,samples,%d,prctile10,%f,prctile90,%f
const T &CMQueue<CLSwimFusionInput>::operator[](const size_t) const [T = CLSwimFusionInput]
const T &CMQueue<CLSwimAlgController::BufferedStroke>::operator[](const size_t) const [T = CLSwimAlgController::BufferedStroke]
MobilityWalkingBoutHistory
virtual void CLMobility::BoutBoundaryRecorderDb::deleteBoundary(int)
Deleting boundary from db: id=%{public}d
virtual CMError CLMobility::BoutBoundaryRecorderDb::queryBoundariesInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<BoutBoundary> &)
MobilityWalkingBoutHistory not accessible
virtual void CLMobility::BoutBoundaryRecorderDb::addBoundary(CLMobility::BoutBoundary &)
Wrote boundary to db: id=%{public}d, startTime=%{public}.2f
Inserted boundary (startTime=%{public}f) is not the latest boundary (startTime=%{public}f)
virtual bool CLMobility::BoutBoundaryRecorderDb::getTimeRangeOfAllBoundaries(CFAbsoluteTime &, CFAbsoluteTime &)
MobilityWalkingBoutHistory Encountered an error getting earliest record
MobilityWalkingBoutHistory Encountered an error getting latest record
DELETE FROM MobilityWalkingBoutHistory WHERE id = ?
DELETE FROM MobilityWalkingBoutHistory WHERE startTime > ?
DELETE FROM MobilityWalkingBoutHistory
DELETE FROM MobilityWalkingBoutHistory WHERE startTime < ?
SELECT * from MobilityWalkingBoutHistory ORDER BY startTime ASC
SELECT COUNT(*) FROM MobilityWalkingBoutHistory
SELECT * FROM MobilityWalkingBoutHistory WHERE startTime >= ? and endTime > 0 and endTime <= ? ORDER BY startTime ASC
SELECT * FROM MobilityWalkingBoutHistory ORDER BY id DESC LIMIT 1
SELECT * FROM MobilityWalkingBoutHistory ORDER BY endTime DESC LIMIT 1
SELECT * FROM MobilityWalkingBoutHistory ORDER BY startTime ASC LIMIT 1
INSERT INTO MobilityWalkingBoutHistory (startTime, endTime, stepCount, workoutType, terminationReason, boundaryType) VALUES (?, ?, ?, ?, ?, ?)
UPDATE MobilityWalkingBoutHistory SET startTime = startTime + ?
UPDATE MobilityWalkingBoutHistory SET startTime = ?, endTime = ?, stepCount = ?, workoutType = ?, terminationReason = ?, boundaryType = ? WHERE id = ?
ALTER TABLE MobilityWalkingBoutHistory ADD COLUMN 
UPDATE MobilityWalkingBoutHistory SET 
CLActivityRecorderDb<CLMobility::BoutBoundary>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLMobility::BoutBoundary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLMobility::BoutBoundary>::setDatabaseAccessible() [T = CLMobility::BoutBoundary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLMobility::BoutBoundary>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::BoutBoundary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLMobility::BoutBoundary>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLMobility::BoutBoundary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
displacement
CLStrideCalibrationSessionMetrics::CLStrideCalibrationSessionMetrics(CFTimeInterval, int32_t)
SessionMetrics,Start
-[CMStrideCalibrationStats endSessionMetrics:]
SessionMetrics,End,Summary,DistanceFusionSuccess,%0.6f,DistanceFusionOther,%0.6f,DistanceFusionGPS,%0.6f,DistanceFusionPedometer,%0.6f,DistanceFusionGradient,%0.6f,DistanceFusionGain,%0.6f,DistanceFusionSpeed,%0.6f,DistanceFusionLength,%0.6f,startTime,%0.6f,endTime,%0.6f
NoFailReason
Gradient
Gain
Speed
Length
Other
Success
Fail
-[CMStrideCalibrationStats awdLogDistance:status:description:]
SessionMetrics,%s,%s,%s,DistanceFusion,%0.4f
-[CMStrideCalibrationStats awdMotionFitnessStrideCalibration:]
Trying to send track with startTime %f. a %u b %u a == b %d
Trying to send track with startTime %f. now %f 2 %f 1 %f
const T &CMQueue<double>::operator[](const size_t) const [T = double]
Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMQueue.h, line 244,i,%zu,capacity,%u.
-[CLOSTransaction initWithDescription:]
-[CLOSTransaction dealloc]
os_transaction released: (%p) %@
clTimer
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLPersistentTimer.mm
-[CLPersistentTimerInternal initWithFireTime:timeInterval:serviceIdentifier:wakeDevice:clTimer:silo:minimumEarlyFireProportion:]
-[CLPersistentTimerInternal setTimerWithInterval:]
setTimerWithInterval, %s, interval, %.1lf
interval, %s, %.5lf, flooring to 1.0, interval
setTimerWithInterval, %s, interval, DBL_MAX
!_pcTimer
-[CLPersistentTimerInternal dealloc]
_clTimer
-[CLPersistentTimerInternal timerFired:]
timerFired: timer, _clTimer, %s, %p, %p
-[CLPersistentTimerInternal invalidate]
Scheduling invalidation, %s, %p
-[CLPersistentTimerInternal invalidate]_block_invoke
invalidate, %s, %p
void CLPersistentTimer::setNextFireDate(CFAbsoluteTime)
setNextFireDate, %s, %.1lf
void CLPersistentTimer::timerFired()
timerFired, fIdentifier, %s, f, %p
void CLPersistentTimer::invalidate()
Invalidate, %s
StationaryLocationHarvest
CLMonitorGps::CLMonitorGps(id<CLIntersiloUniverse>, std::shared_ptr<CLMonitorGpsInterface::External>, std::shared_ptr<CLHarvestSystemInterface::Controller>, std::shared_ptr<CLMonitorGpsInterface::GpsReceiver>)
StationaryLocationHarvest enabled
IgnoreVehicularSpeed
ignore vehicular speed
void CLMonitorGps::gpsHarvesting(bool)
HARVEST: starting gps harvesting.
HARVEST: stopping gps harvesting.
virtual bool CLMonitorGps::isGpsHarvestingEligible(const CLDaemonLocation &) const
invalid/stale location (age %.3fs) - ignoring
not harvesting yet; GPS warming count is %d < %d
%d consecutive clamps at <%+.8f,%+.8f> - not harvesting
virtual void CLMonitorGps::initHarvesting()
getting GPS notifications
virtual void CLMonitorGps::onGpsNotification(int, const CLLocationProvider_Type::Notification, const CLLocationProvider_Type::NotificationData &)
Location is spoofed, do not harvest
#Warning,invalid,type,%{public}d,lat,%{private}.7f,lon,%{private}.7f
Got GPS location simulation %s notification
GPS dropped out for %.3fs while warming - resetting count (from %d)
location is clamped at <%+.8f,%+.8f> acc %.2f - count %d
on gps notification. Pos harvesting not eligible
CLLoiLocationOverride
void CLLoiLocationOverride::onLoiLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#loiOverride received LOI location,lat,%{private}.7f,lon,%{private}.7f,hunc,%{public}.2f,timestamp,%{public}.3f,sourceAccuracy,%{public}d
#loiOverride LOI location is not valid anymore.
void CLLoiLocationOverride::updateWiFiAssociationState(BOOL)
#loiOverride update WiFi association state,isWiFiAssociated,%{public}s,last association time,%{public}.3f,LOI location timestamp,%{public}.3f
const CLDaemonLocation CLLoiLocationOverride::getBestLocation(const CLDaemonLocation &)
#loiOverride using Loi Location
BOOL CLLoiLocationOverride::shouldUseLoiLocation(const CLDaemonLocation &)
#loiOverride no valid current location.
#loiOverride location is not Wifi1 or Cell.
#loiOverride location source accuracy is not High to overide location.
#loiOverride the spread of the LOI is larger than the location fix.
#loiOverride locations are not sufficiently proximate.
#loiOverride WiFi is not associated to overide Wifi1 locations.
BOOL CLLoiLocationOverride::areLocationsSufficientlyProximate(const CLDaemonLocation &, const CLDaemonLocation &)
#loiOverride totalUncertainty,%{public}.8lf,distanceBetweenLocations,%{public}.8lf
#loiOverride LOI location is not sufficiently proximate, uncertainty bubbles don't touch.
#loiOverride LOI location is not sufficiently proximate, does not meet distance threshold.
#loiOverride LOI location is sufficiently proximate.
const CLDaemonLocation CLLoiLocationOverride::fuseLocations(const CLDaemonLocation &, const CLDaemonLocation &)
#loiOverride LOI location,%{private}.8lf,%{private}.8lf,HorAcc,%{public}.1lf,Type,%{public}s,Confidence,%{public}d,Timestamp,%{public}.3f,Lifespan,%{public}.3f,integrity,%{public}d,verticalAcc,%{public}.1lf,altitude,%{private}.1lf
#loiOverride filtered location,%{private}.8lf,%{private}.8lf,HorAcc,%{public}.1lf,Type,%{public}s,Confidence,%{public}d,Timestamp,%{public}.3f,Lifespan,%{public}.3f,integrity,%{public}d,verticalAcc,%{public}.1lf,altitude,%{private}.1lf
#loiOverride Fused location,%{private}.8lf,%{private}.8lf,HorAcc,%{public}.1lf,Type,%{public}s,Confidence,%{public}d,Timestamp,%{public}.3f,Lifespan,%{public}.3f,integrity,%{public}d,verticalAcc,%{public}.1lf,altitude,%{private}.1lf
com.apple.locationd.CLLoiLocationOverride
incomingLocationType
incomingLocationSignalEnvironmentType
incomingLocationHorizontalAccuracy
loiLocationHorizontalAccuracy
incomingLocationDistanceToLoi
isValidLoi
isLoiHighAccuracy
isIncomingLocationValidLocationType
isIncomingLocationGreaterUncertainty
isDistanceLessThanThreshold
isHorizontalAccuracyOverlapping
isWifiAssociated
isOverriding
CLLoiLocationOverride::onLoiLocationNotification
kCLConnectionMessageNatalimetryCalibrationPromptsNeeded
kCLConnectionMessageNatalimetryResetCalibration
kCLConnectionMessageWorkoutMetsQuery
void CLNatalimetrySubscription::onNatalimetryUpdate(int, const CLNatalimetryNotifier_Type::Notification &, const CLNatalimetryNotifier_Type::NotificationData &)
Error in calorie update, %s, %p
bool CLNatalimetrySubscription::isNatalimetryCalibrationAuthorized()
void CLNatalimetrySubscription::handleRequestNatalimetryUpdate(bool, const CLNameValuePair &)
Calorie subscription changed, %d, %s, %p
void CLNatalimetrySubscription::handleMessageNatalimetryQuery(std::shared_ptr<CLConnectionMessage>)
CLDaemonClient.NatalimetryQuery
Error querying calorie data, %{public}d
void CLNatalimetrySubscription::handleMessageNatalimetryCalibrationPromptsNeeded(std::shared_ptr<CLConnectionMessage>)
Calibration prompt, isConnectedToCompanion: %d, promptsNeeded: %ld.
void CLNatalimetrySubscription::handleMessageNatalimetryResetCalibration(std::shared_ptr<CLConnectionMessage>)
Resetting calibration.
void CLNatalimetrySubscription::handleMessageNatalimetryGetUserProfile(std::shared_ptr<CLConnectionMessage>)
Getting user profile, %@, %s, %p
void CLNatalimetrySubscription::handleMessageNatalimetrySetUserProfile(std::shared_ptr<CLConnectionMessage>)
Setting user profile, %{private}@, %s, %p
bool CLNatalimetrySubscription::isEntitledForNatalimetry()
#Warning Client failed entitlement check for calorimetry, %s, %p
void CLNatalimetrySubscription::handleQueryWorkoutMetsForSessionId(std::shared_ptr<CLConnectionMessage>)
WorkoutMets,query,empty request
CLDaemonClient.WorkoutMetsQueryForSessionId
void CLNatalimetrySubscription::handleQueryWorkoutMetsForSessionId(std::shared_ptr<CLConnectionMessage>)_block_invoke
Error querying workout mets, %{public}d
Workout Mets Query Result: %@
v20@?0@"CMWorkoutMetsData"8i16
com.apple.locationd.userprofile
bool CLNatalimetrySubscription::isEntitledForUserInfoAccess()
#Warning Client %s does not have appropriate entitlement to access user info spi
CLNatalimetrySubscription::onNatalimetryUpdate
CLMotionAlarmNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/MotionAlarm/CLMotionAlarmNotifier.mm
-[CLMotionAlarmNotifierAdapter beginService]
virtual void CLMotionAlarmNotifier::shutdown()
Shutting down alarm notifier.
bool CLMotionAlarmNotifier::registerClient(CLClientManager_Type::Name *, id<CLMotionAlarmNotifierClientProtocol>)
Invalid name.
Unable to create client bundle identifier.
Registering client: %{private}@.
bool CLMotionAlarmNotifier::unregisterClient(CLClientManager_Type::Name *)
Unregistering client: %{private}@.
bool CLMotionAlarmNotifier::registerAlarm(CMMotionAlarm *, CLMotionAlarmReplyHandler)
Registering alarm for client: %{private}@, name: %{private}@.
Invalid alarm to add!
Alarm already exists for client, firing: %{private}@, name: %{private}@.
Updating alarm for client: %{private}@, name: %{private}@.
Failed to update or insert alarm for client: %{private}@ name: %{private}@.
Alarm construction failed!
Failed to remove alarm entry for id: %llu.
Construction of alarm failed for client: %{private}@ name: %{private}@.
bool CLMotionAlarmNotifier::unregisterAlarm(CMMotionAlarm *, CLMotionAlarmReplyHandler)
Unregistering alarm for client: %{private}@, name: %{private}@.
Invalid alarm to remove!
Unable to find alarm to remove!
Failed to remove activity alarm entry for id: %llu.
bool CLMotionAlarmNotifier::acknowledgeAlarm(CMMotionAlarm *, CLMotionAlarmReplyHandler)
Acknowledging alarm for client: %{private}@, name: %{private}@.
Invalid alarm to acknowledge!
Unable to find alarm entry to acknowledge!
Unable to acknowledge alarm in state: %@ for client: %{private}@ name: %{private}@, id: %llu.
Preconditions have been violated and we have a repeating activity alarm!
Setting alarm to %@ for client: %{private}@, id: %llu.
bool CLMotionAlarmNotifier::removeAllAlarmsForBundle(NSString *)
Removing all alarms for client: %{private}@.
bool CLMotionAlarmNotifier::addTimeAlarm(NSString *, NSString *, uint64_t, uint32_t, bool)
Time alarm already exists for id: %llu.
Saving persistent alarm for client: %{private}@, id: %llu, duration: %u, repeats: %d, fire: %f.
bool CLMotionAlarmNotifier::removeTimeAlarm(uint64_t)
Unable to find persistent alarm for id: %llu.
Removing persistent alarm for id: %llu.
com.apple.locationd.MotionAlarm_%llu
bool CLMotionAlarmNotifier::addClassATimerAlarm(NSString *, NSString *, uint64_t, uint32_t, bool)
Class A timer alarm already exists for id: %llu.
bool CLMotionAlarmNotifier::addClassATimerAlarm(NSString *, NSString *, uint64_t, uint32_t, bool)_block_invoke
bool CLMotionAlarmNotifier::removeClassATimerAlarm(uint64_t)
Removing Class A timer alarm for id: %llu.
bool CLMotionAlarmNotifier::addActivityAlarm(NSString *, NSString *, uint64_t, CMMotionAlarmType, uint32_t)
Invalid trigger type!
Unable to create activity alarm key.
Activity alarm already exists for id: %llu.
Failed to create activity alarm for client: %{private}@, id: %llu.
Saving activity alarm for client: %{private}@, id: %llu, trigger: %d duration: %u.
bool CLMotionAlarmNotifier::removeActivityAlarm(uint64_t)
Unable to find activity alarm for id: %llu.
Removing activity alarm for id: %llu.
bool CLMotionAlarmNotifier::restoreAlarms()
Unable to access database after first unlock!
Restoring alarms: %lu.
Removing expired alarms: %lu.
void CLMotionAlarmNotifier::onActivityAlarmFired(CMActivityAlarm *, NSError *)
Invalid alarm timer.
Invalid alarm identifier.
Activity alarm timer fired: %llu.
Activity alarm is pending acknowledgment. Not firing alarm.
void CLMotionAlarmNotifier::onPersistentTimerFired(CLPersistentTimer *)
Unexpected alarm identifier.
Persistent timer fired id: %llu.
Persistent timer is pending acknowledgment. Not firing alarm.
void CLMotionAlarmNotifier::onClassATimerActivity(xpc_activity_t, uint64_t)
Invalid alarm activity.
Class A timer fired id: %llu.
void CLMotionAlarmNotifier::incrementState(CMMotionAlarm *)
Alarm state is rolling over for alarm: %llu.
void CLMotionAlarmNotifier::fireAlarmWithRetry(uint64_t)
Unable to find alarm for id: %llu.
void CLMotionAlarmNotifier::fireAlarmWithRetry(CMMotionAlarm *)
Invalid fire state: %@.
Previous alarm state: %@, current state: %@.
Maximum launch attempts reached for: %{private}@.
Failed to update state for the alarm: %llu!
void CLMotionAlarmNotifier::fireAlarmOnClient(CMMotionAlarm *)
Will not fire due to invalid fire state, current state: %@.
Firing alarm on client: %@, current state: %@.
Unable to fire alarm on client, client is not registered: %@, current state: %@.
void CLMotionAlarmNotifier::setupRetryTimerForAlarm(CMMotionAlarm *)_block_invoke
Re-firing alarm: %llu.
bool CLMotionAlarmNotifier::isApplicationInstalled(NSString *)
Application %{private}@ installed: %d.
bool CLMotionAlarmNotifier::launchRemoteApplication(NSString *, CLMotionAlarmLaunchHandler)
Application %{private}@ sending remote app launch.
bool CLMotionAlarmNotifier::launchApplication(NSString *)
Launching application: %{private}@.
watchkitextension
bool CLMotionAlarmNotifier::launchWatchApplicationForCompanion(NSString *)
Unable to find watch application for companion: %{private}@.
Launching watch application: %{private}@ for companion: %{private}@.
bool CLMotionAlarmNotifier::isBundleValid(NSString *)
Invalid alarm bundle identifier!
void CLMotionAlarmNotifier::onDataProtectionManagerNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
Device unlocked since boot: %{private}s.
CLMotionAlarmNotifier::onAppMonitorNotification
CLMotionAlarmNotifier::onDataProtectionManagerNotification
CLMotionAlarmNotifier::onCompanionNotification
CLMotionAlarmNotifier::onPersistentTimerFired
SPCompanionConnection
/System/Library/PrivateFrameworks/SockPuppetGizmo.framework/SockPuppetGizmo
virtual void CLNotifier<CLMotionAlarm_Type::Notification, CLMotionAlarm_Type::NotificationData>::removeClient(int) [Notification_T = CLMotionAlarm_Type::Notification, NotificationData_T = CLMotionAlarm_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionAlarm_Type::Notification, CLMotionAlarm_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMotionAlarm_Type::Notification, NotificationData_T = CLMotionAlarm_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionAlarm_Type::Notification, CLMotionAlarm_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLMotionAlarm_Type::Notification, NotificationData_T = CLMotionAlarm_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionAlarm_Type::Notification, CLMotionAlarm_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMotionAlarm_Type::Notification, NotificationData_T = CLMotionAlarm_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionAlarm_Type::Notification, CLMotionAlarm_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLMotionAlarm_Type::Notification, NotificationData_T = CLMotionAlarm_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLMotionAlarm_Type::Notification, CLMotionAlarm_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMotionAlarm_Type::Notification, NotificationData_T = CLMotionAlarm_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionAlarm_Type::Notification, CLMotionAlarm_Type::NotificationData>::listClients() [Notification_T = CLMotionAlarm_Type::Notification, NotificationData_T = CLMotionAlarm_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
BSID
ZONEID
BANDCLASS
CHANNEL
PNOFFSET
CLCdmaCellLocationDatabase::CLCdmaCellLocationDatabase(const char *, const CLSqliteDatabase::SqliteProperties &, double)
virtual CLCdmaCellLocationDatabase::~CLCdmaCellLocationDatabase()
Delete CLCdmaCellLocationDatabase
bool CLCdmaCellLocationDatabase::getLocation(const CLTelephonyService_Type::CdmaCell &, sqlite3_int64 &)
GET could not bind %d %d %d %d %d %d %d %d %d
bool CLCdmaCellLocationDatabase::setLocation(const CLTelephonyService_Type::CdmaCell &, const CLDaemonLocation &)
SET could not bind %d %d %d %d %d %d %d %d %d
bool CLCdmaCellLocationDatabase::getLocation(sqlite3_int64, CLTelephonyService_Type::CdmaCell &) const
getCell SID %d NID %d
bool CLGeoidModel::_static_check_dma_index(int)
Bad index into kkDefenseMappingAgencyTenByTenGeoid.
bool CLGeoidModel::getUndulationFromDefenseMappingAgency10by10Geoid(double, double, float &)
#Warning Input latitude = %.9lf is out of possible range
longitude %.9lf is not valid.
latitude %.9lf is not valid.
strokePower
strokeAmp
strokeFrequency
CLSimulatedLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Simulation/CLSimulatedLocationProvider.mm
-[CLSimulatedLocationProviderAdapter beginService]
simulated
com.fitbit.FitbitMobile
com.aliphcom.armstrong
com.aliphcom.upopen
com.getpebble.pebbletime
com.getpebble.ios
com.garmin.connect.mobile
com.strava.stravaride
com.nike.nikeplus-gps
RunKeeperPro
CLCompanionActivityAWDAggregatorSilo
-[CLCompanionActivityAWDAggregator beginService]
data is available
data is NOT available
CompanionAWD
CompanionActivityCacheStoreInterval
com.apple.locationd.motionfitnessdailytokenchanged
MotionFitnessDailyToken
mobile
CompanionActivityHKQueryInterval
-[CLCompanionActivityAWDAggregator runQueries]
Encrypted:%d State:%d Health:%d
-[CLCompanionActivityAWDAggregator querySources]_block_invoke
query encountered error,%{public}ld
#Warning No step count / workouts
v32@?0@"HKSourceQuery"8@"NSSet"16@"NSError"24
-[CLCompanionActivityAWDAggregator queryWatchWorkouts]_block_invoke
workouts: %lu, Minutes:%f
v24@?0{pair<unsigned long, double>=Qd}8
-[CLCompanionActivityAWDAggregator queryWorkouts:endDate:workoutsHandler:]_block_invoke
-[CLCompanionActivityAWDAggregator queryWatchDailyStepCount]_block_invoke
%s steps:%f
v32@?0{vector<double, std::allocator<double>>=^d^d{__compressed_pair<double *, std::allocator<double>>=^d}}8
-[CLCompanionActivityAWDAggregator queryPhoneDailyStepCount]_block_invoke
%s Steps:%f, Hours:%d
-[CLCompanionActivityAWDAggregator queryStepCount:endDate:sources:stepCountHandler:]_block_invoke
v24@?0@"HKStatistics"8^B16
v32@?0@"HKStatisticsCollectionQuery"8@"HKStatisticsCollection"16@"NSError"24
-[CLCompanionActivityAWDAggregator queryWatchStandHours]_block_invoke
%s count:%zu
v16@?0Q8
-[CLCompanionActivityAWDAggregator queryStandHours:endDate:standHoursHandler:]_block_invoke
-[CLCompanionActivityAWDAggregator queryPhoneFlightsClimbed]_block_invoke
%s Count:%zu
-[CLCompanionActivityAWDAggregator queryFlightsClimbed:endDate:flightsClimbedHandler:]_block_invoke
v32@?0@"HKStatisticsQuery"8@"HKStatistics"16@"NSError"24
-[CLCompanionActivityAWDAggregator queryPhoneStaticTime]_block_invoke
day:%s duration:%f
All queries finished succssfully
v16@?0d8
v16@?0@"NSArray"8
kAccessoryModelKey
kCompanionStepsPerDayKey
kHoursActiveKey
kMinutesActiveKey
kWatchStepsPerDayKey
kWatchNonPedWorkoutsKey
kWatchNonPedWorkoutMinutesKey
kIphoneStaticnessKey
kCoarseLocationLatKey
kCoarseLocationLongKey
kFlightsClimbedKey
kCompanionAWDUUIDKey
kCompanionAWDUUIDTimestampKey
kWearableTypeKey
kWearableActiveKey
kWatchConnectivityKey
kWatchConnectedTimeKey
kFitnessAppUserKey
ssize_t CLMotionNotifier::numberOfClients(int)
Unknown notification %d
ssize_t CLMotionNotifier::numberOfSpectators(int)
CFTimeInterval CLMotionNotifier::minimumUpdateInterval(int)
bool CLMotionNotifier::addDispatcherPrivate(int, CLMotionNotifier::Dispatcher *, const CFTimeInterval &)
Requested update interval cannot be == 0.0 and dispatcher cannot be NULL. Use interval < 0.0 for spectator.
CLMotionNotifier::addDispatcherPrivate UpdateInterval is zero!
CLMotionNotifier::addDispatcherPrivate Added dispatcher for notification:%d, Update Interval:%f(%.1fHz)
void CLMotionNotifier::updateSamplePeriods(int)
CLMotionNotifier::updateSamplePeriod UpdateInterval:%f
CLAuthSyncManagerSilo
com.apple.private.alloy.location.auth
kCLMigrationSyncInProgress
MigrationSyncComplete
kCLDeltaSyncInProgress
kCLSyncedToggleNotification
kCLToggleNotificationOnCompanion
kCLToggleNotificationOnGizmo
MissingSyncStoreStateOnDisk
GizmoUpdateToFortune
MigrationSync
 TOGGLE
AUTH
SyncState
v32@?0@"CLCompanionSyncAuthObject"8Q16^B24
com.apple.identityservices.error
SYErrorDomain
NMSErrorDomain
RESET-Collision
FailedDeltaSyncSession
PendingDeltaSync
DeltaSyncCompletion
com.apple.locationd.bundle-
iPhoneSimulator
watchSimulator
ResetNotification
LSToggleConflictResolutionDuringAdd
ReceivedLSToggleNotification
SendingLSToggleNotification
AuthorizationAdd
Device is disconnected
kCLVersionOfLastFullSync
FullSyncVersionMismatch
!session.isSending
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/AuthSync/CLAuthSyncManager.mm
-[CLAuthSyncManager service:startSession:error:]
-[CLAuthSyncManager service:sessionEnded:error:]
!session.isResetSync
-[CLAuthSyncManager syncSession:enqueueChanges:error:]
-[CLAuthSyncManager syncSession:applyChanges:completion:]
SYSessionReasonResetFromCompanion
SYServiceOptionDiskBufferProtectionClass
MIGRATION_SYNC_RESET_VERSION_NUMBERS
_NRDevicePropertyBluetoothIdentifier
NRDevicePropertyLocalPairingDataStorePath
NRDevicePropertySystemBuildVersion
NRDevicePropertyName
CLWalkingSpeedCalRecorderDb
virtual CMError CLWalkingSpeedCalRecorderDb::queryCalsInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<WalkingSpeedStrideCal> &) const
Database not accessible
WalkingSpeedStrideCal
INSERT INTO WalkingSpeedStrideCal (startTime, endTime, cadenceWatch, cadenceGaitCycle, meanWalkingSpeed, gaitCycleYield) VALUES (?, ?, ?, ?, ?, ?)
DELETE FROM WalkingSpeedStrideCal WHERE id <= ?
SELECT * FROM WalkingSpeedStrideCal ORDER BY startTime DESC LIMIT 1
SELECT COUNT(*) FROM WalkingSpeedStrideCal
SELECT * FROM WalkingSpeedStrideCal WHERE startTime BETWEEN ? and ? ORDER BY startTime DESC
virtual void CLWalkingSpeedCalRecorderDb::prepareSQLStatements()
cadenceWatch
cadenceGaitCycle
meanWalkingSpeed
gaitCycleYield
CLActivityRecorderDb<WalkingSpeedStrideCal>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = WalkingSpeedStrideCal, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<WalkingSpeedStrideCal>::setDatabaseAccessible() [T = WalkingSpeedStrideCal, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<WalkingSpeedStrideCal>::sanitizeAndStoreRecordUL(const T &, bool) [T = WalkingSpeedStrideCal, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
/System/Library/Frameworks/CoreMotion.framework/Support
static void CLMotionCore::create()
Could not get parent thread parameters
Motion runloop ref still not set!
Could not get scheduling parameters for motion thread, error = %{public}d
wrapRunLoopWithAutoreleasePoolHandler
CLMotionCore.mm
count > 0
com.apple.CoreMotion.MotionThread
com.apple.CoreMotion
MotionThreadPriority
static void *CLMotionCore::runMotionThread(void *)
could not create runloop source
_CFRunLoopSetPerCalloutAutoreleasepoolEnabled() returned a value of, %{private}d.
v16@?0^{__CFRunLoopTimer=}8
static void *CLMotionCore::runMotionThread(void *)_block_invoke
Ping timer fired, resetting watchdog
Motion thread deadlock watchdog after %d petting
com.apple.CoreMotion.ThreadDeadlockCount
%@.%@
Failed to create watchdog timer
Motion thread exiting
com.apple.locationpushd.pushregistration
-[CLLocationPushRegistrar connect]_block_invoke
Location Push Registrar XPC invalidation handler
Location Push Registrar XPC interruption handler
v24@?0@"NSData"8@"NSError"16
EnableEllipticalLoadCal
EllipticalModelMetsScale
EllipticalModelSwitchMargin
CLNatalieEllipticalModel::CLNatalieEllipticalModel()
Ellptical, Load Calibration Enabled status, %d, WR-HR switch margin, %f
virtual CLMetsInfo CLNatalieEllipticalModel::computeMETS(const CLNatalieModelInput &)
Elliptical, Linear Regression, timestamp, %f, duration, %f, stepcount, %d, steprate, %f, resistance, %f, weight, %f, feature2, %f, mets, %f
Elliptical, DT Regression, timestamp, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, METS, %f
Elliptical, METs, timestamp, %f, hrMets, %f, wrMets, %f, calibrationValue, %f, calibrated wrMets, %f, HR-WR diff, %f, mets, %f, metsSource, %d, fMetsScaling, %f, loadCalStatus, %d
Accel
INSERT INTO VO2MaxInputHistory (uuid, startTime, mets, metSource, hr, hrConfidence, gradeType, grade, gps, strideCal, workoutType, cadence, pace, stroller, hrTime) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
virtual void CLVO2MaxInputCache::insertRecordUL(const VO2MaxInput &, bool)
Unable to insert VO2Max Input record.
CLVO2MaxInputCache
SELECT * from VO2MaxInputHistory WHERE uuid = ?
CMError CLVO2MaxInputCache::getEntries(unsigned char *, std::vector<VO2MaxInput> &) const
Unable to get entries for uuid %{public}s
DELETE from VO2MaxInputHistory WHERE startTime < ?
long CLVO2MaxInputCache::aggregateRecordsInternal(const CLAggregationRules &, CFAbsoluteTime)
Unable to purge records.
Completed delete of aged-out input records; duration: %{public}f
DELETE FROM VO2MaxInputHistory WHERE uuid IN (SELECT sah.sessionId FROM VO2MaxSessionAttributesHistory sah WHERE startTime < ? and sah.inputCloudKitSystemFields IS NOT NULL)
Unable to purge VO2MaxInputHistory records from sessions already synced to CloudKit.
Completed delete of synced input records; duration: %{public}f
Completed reduce free pages after VO2MaxInputHistory deletes; duration: %{public}f
void CLVO2MaxInputCache::trimTableIfExceedingMaxRecordCount()
Completed fetch of input record count; duration: %{public}f
DELETE FROM VO2MaxInputHistory WHERE uuid IN (SELECT uuid FROM VO2MaxInputHistory ORDER BY startTime ASC LIMIT ?)
Unable to purge VO2MaxInputHistory records from oldest sessions after exceeding max record count.
Completed fetch of input record count after delete after exceeding max record count; duration: %{public}f
Completed delete of VO2MaxInputHistory records from oldest sessions after exceeding max record count; duration: %{public}f
SELECT COUNT(id) FROM VO2MaxInputHistory
VO2MaxInputHistory
DELETE FROM VO2MaxInputHistory
 ADD COLUMN 
SELECT COUNT(name) FROM sqlite_master WHERE type='index' AND name = 'VO2MaxInputHistoryUuidIndex'
void CLVO2MaxInputCache::createIndexOnUuidIfNecessary()
Index VO2MaxInputHistoryUuidIndex already exists; not re-creating
CREATE INDEX VO2MaxInputHistoryUuidIndex ON VO2MaxInputHistory (uuid)
Unable to create index VO2MaxInputHistoryUuidIndex
Index VO2MaxInputHistoryUuidIndex created successfully
SELECT * from VO2MaxInputHistory
SELECT * from VO2MaxInputHistory ORDER BY rowid DESC LIMIT 1
CMError CLVO2MaxInputCache::queryVO2MaxInputSince(const VO2MaxInput, std::vector<VO2MaxInput> &) const
History not accessible
Non-existent query record, returning all records.
SELECT * FROM VO2MaxInputHistory WHERE id >= ? ORDER BY id ASC
Error querying records.
CMError CLVO2MaxInputCache::queryBySessionId(unsigned char *, std::vector<VO2MaxInput> &) const
VO2MaxInputHistory, DB not accessible
SELECT COUNT(*) from VO2MaxInputHistory WHERE uuid = ?
bool CLVO2MaxInputCache::saveFetchedSession(unsigned char *, NSData *, const std::vector<VO2MaxInput> &)
Unable to save fetched input data from CloudKit. Device is locked and we are unable to open the database
DELETE FROM VO2MaxInputHistory WHERE uuid = ?
INSERT INTO VO2MaxSessionAttributesHistory (startTime, sessionId, meanMaxMets, prior, hardwareType, betaBlockerUse, algorithmVersion, outputCloudKitSystemFields, inputCloudKitSystemFields) VALUES (0, ?, -1, -1, 0, 0, 0, NULL, ?)
UPDATE VO2MaxSessionAttributesHistory SET inputCloudKitSystemFields = ? WHERE sessionId = ?
Unable to delete out-of-date VO2MaxInputHistory records
Unable to save synced VO2MaxSummaryInput records
Unable to update synced VO2MaxSessionAttributes record
Unable to insert synced VO2MaxSessionAttributes record
strideCal
stroller
CLActivityRecorderDb<VO2MaxInput>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxInput>::setDatabaseAccessible() [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxInput>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxInput>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxInput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLSensorFusionService6AxisAP::applicationStateChanged(bool)
virtual void CLSensorFusionService6AxisAP::feedGyroData(const CLGyro::Sample *)
VO2MaxAlertHistory
DELETE FROM VO2MaxAlertHistory WHERE startTime < ?
SELECT * from VO2MaxAlertHistory ORDER BY startTime ASC
SELECT COUNT(*) FROM VO2MaxAlertHistory
DELETE FROM VO2MaxAlertHistory
DELETE FROM VO2MaxAlertHistory WHERE startTime > ?
UPDATE VO2MaxAlertHistory SET startTime = startTime + ?
INSERT INTO VO2MaxAlertHistory (startTime) VALUES (?)
SELECT * FROM VO2MaxAlertHistory ORDER BY id DESC LIMIT 1
ALTER TABLE VO2MaxAlertHistory ADD COLUMN 
UPDATE VO2MaxAlertHistory SET 
CLActivityRecorderDb<VO2MaxAlert>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxAlert>::setDatabaseAccessible() [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxAlert>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxAlert>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxAlert, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLSensorRecorderDb
Data
Meta
SensorRecorderCacheSizeBytes
CLSensorRecorderDb::CLSensorRecorderDb(bool, const std::string, CLSensorRecorder_Types::DataType)
SensorRecorderCacheSizeBytes, %d
SensorRecorderType, %s
2245.4.99
virtual void CLSensorRecorderDb::prepareSQLStatements()
Detected incompatible sensor table, purging Sensor Recorder data
Device is locked and we are unable to open the database
 WHERE dataId = 0
SensorRecorderAccelData
SensorRecorderAccelMeta
SensorRecorderGyroData
SensorRecorderGyroMeta
SensorRecorderPressureData
SensorRecorderPressureMeta
void CLSensorRecorderDb::deleteTablesFromLegacyDatabase()
Unable to open legacy database; failed to drop obsolete tables
CLSensorRecorderDb::storeToDb
void CLSensorRecorderDb::storeToDb(bool)
Flushing to memory. %zu, %zu
 (startTime, timestamp, dataId, offset, size, movement) VALUES (?, ?, ?, ?, ?, ?)
Unable to insert meta data.
 (data) VALUES (?)
Unable to insert data.
Unable to get last accel data id.
 SET dataId = ? WHERE dataId = 0
Unable to update meta records dataId.
 WHERE id = ?
bool CLSensorRecorderDb::getSensorRecordMeta(uint64_t, CLSensorRecorderSensorMeta *)
Database is inaccessible
bool CLSensorRecorderDb::getSensorRecordData(CLSensorRecorderSensorData &, uint64_t) const
Invalid query, both data id and meta id are 0
 WHERE id >= ? ORDER BY id ASC
bool CLSensorRecorderDb::getSensorRecordMetaSinceId(uint64_t, CLSensorRecorderSensorMeta *)
 WHERE startTime >= ? ORDER BY id ASC LIMIT 1
 WHERE startTime < ? ORDER BY id DESC LIMIT 1
CLActivityDB::ActivityCode CLSensorRecorderDb::getSensorRecordMetaIdsBounds(CFAbsoluteTime, CFAbsoluteTime, CLSensorRecorderSensorMeta *, CLSensorRecorderSensorMeta *) const
Database upper and/or lower time bound query failed to bind.
Database upper and/or lower time bound query failed.
bool CLSensorRecorderDb::getSensorRecordMetaIds(CFAbsoluteTime, CFAbsoluteTime, NSMutableArray *)
Data request failed because db is not accessible.
Non-empty, endTime in memory, %d, current time, %f, endTime, %f, first entry startTime, %f, 
Data requested is in memory.  Writing incremental data out to disk.
 WHERE ? <= id AND id <= ? ORDER BY id ASC
SELECT dataId FROM 
 WHERE startTime < ? ORDER BY dataId DESC LIMIT 1
 WHERE id < ?
 WHERE dataId < ?
dataId
offset
movement
CLActivityRecorderDb<CLSensorRecorderDataPacket>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSensorRecorderDataPacket, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLSensorRecorderDataPacket>::setDatabaseAccessible() [T = CLSensorRecorderDataPacket, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
dataLength < row.length
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/SensorRecorder/CLSensorRecorderDb.mm
formatFromStatement
virtual void CLActivityRecorderDb<CLSensorRecorderDataPacket>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLSensorRecorderDataPacket, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLVO2MaxModel::deriveClusters(const std::vector<VO2MaxModelInput> &, std::vector<uint32_t> &)
VO2Max,Clustering failed
void CLVO2MaxModel::logClusters(std::vector<VO2MaxSummary> &)
AlgoName,AdaptiveOutdoorPedestrianModel,ts,%.9f,duration,%.9f,size,%lld,hr min.,%f,hr max.,%f,hrMean,%f,hrConfMean,%f,hrCadenceMean,%f,vo2Mean,%f,speedMean,%f,gradeMean,%f,hrVariance,%f,hrConfVariance,%f,vo2Variance,%f,speedVariance,%f,gradeVariance,%f,cadenceMean,%f,vo2MaxModelSource,%d
void CLVO2MaxModel::AdaptiveOutdoorPedestrianModel::estimateVO2Max(const std::vector<VO2MaxModelInput> &, const std::vector<VO2MaxSummary> &, float, const CLBodyMetrics &, double, CLVO2MaxModel::Result &, CFAbsoluteTime) const
VO2Max,AdaptiveOutdoorPedestrianModel,ComputePriors,age,%{private}f,biologicalSex,%{private}u,height,%{private}f,weight,%{private}f,maxMets,%{private}f,efficiency,%{private}f,priorVO2Max,%{private}f,modelPriorCoefficient_a,%{private}f,modelPriorCoefficient_b,%{private}f
clusterIdx < kMaxNumClusters || inputIdx < modelInput.size()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/FunctionalCapacity/VO2Max/Models/CLVO2MaxAdaptiveOutdoorPedestrianModel.mm
populateClusters
double CLVO2MaxModel::AdaptiveOutdoorPedestrianModel::computeWeightedMedianOfResiduals(const std::vector<VO2MaxSummary> &, double, CFAbsoluteTime) const
AlgoName,AdaptiveOutdoorPedestrianModel,numHistoricalResiduals,%ld,median,%f
double CLVO2MaxModel::AdaptiveOutdoorPedestrianModel::computeLongitudinalEstimate(const std::vector<VO2MaxSummary> &, double, double, double, uint32_t &) const
VO2Max,AdaptiveOutdoorPedestrianModel,Longitudinal Estimate,numClusters,%lu,numClustersContr,%u,numWorkoutsContr,%u,medianResidual,%f,hrMin,%f,hrMax,%f,meanResidual,%f,clusterResidualBoundsMax,%f
auto CLVO2MaxModel::AdaptiveOutdoorPedestrianModel::computeLongitudinalEstimate(const std::vector<VO2MaxSummary> &, double, double, double, uint32_t &)::(anonymous class)::operator()(const VO2MaxSummary &) const
VO2Max,AdaptiveOutdoorPedestrianModel,Longitudinal Estimate,ts,%.9f,size,%lld,hrMin,%f,hrMax,%f,hrMean,%f,vo2Mean,%f,hrConfidenceMean,%f,gradeMean,%f,oneMinusFHR,%f,residual,%f,failHistResidCheck,%d,confidence,%f,sessionType,%d
static bool CLCombinedFencesList::removeFenceFromCombinedList(std::list<CLFenceManager_Type::CombinedFence> &, const std::string &, const std::string &)
remove %{public}s/%{private}s from %{private}s, remaining fences, %{public}lu
Fence: kill combinedFence, %{private}s, remaining fences, %{public}lu
static bool CLCombinedFencesList::addFenceToCombinedList(std::list<CLFenceManager_Type::CombinedFence> &, const CLFenceManager_Type::Fence &, bool)
FenceCal: combine fine fence, distance, %{private}.1lf, %{private}s
FenceCal: combine large fences, distance, %{private}.1lf, %{private}s
FenceCal: combine non-fine non-large fence, distance, %{private}.1lf, %{private}s
FenceCal: creating a new combined fence for, %{private}s
FenceCal: adding to, %{private}s, isExit, %{private}d
static bool CLCombinedFencesList::finalizeCombinedFencesList(std::list<CLFenceManager_Type::CombinedFence> &)
FenceCal: No fences
double CLFenceManager_Type::CombinedFence::distanceTo(double, double) const
#Warning Fence: why is this used?, %{private}s, %{private}lf
bool CLFenceManager_Type::CombinedFence::removeFence(const std::string &, const std::string &, const std::string &)
Fence: fence, %{private}s, became empty
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLCombinedFence.mm
addFence
CombinedFence
CLOldWifiScanner::WifiConfiguration::WifiConfiguration(CLWifiService_Type::ScanType, CLOldWifiScanner::WifiConfiguration::PassiveActiveType, CLOldWifiScanner::WifiConfiguration::PriorityType, cl::chrono::secondsf, std::vector<CLWifiService_Type::Notification>, cl::chrono::secondsf, cl::chrono::secondsf)
#Warning %p Scan delay of %Lf secs is invalid. Setting to the minimum of %Lf secs
CLOldWifiScanner::CLOldWifiScanner(id<CLIntersiloUniverse>, CLOldWifiScanner::ScanningPolicy)
%p INITIAL isWifiPowered=%d
void CLOldWifiScanner::start()
%p Start monitor for active scanning
void CLOldWifiScanner::stop()
%p Stop monitor for active scanning
void CLOldWifiScanner::onTimerTrigger()
%p TIMER TRIGGERED
void CLOldWifiScanner::scheduleNextScan(cl::chrono::secondsf)
%p WIFI EXECUTING IMMEDIATELY, now=%f nextRequestTime=%f
%p WIFI SCAN SCHEDULED FOR %f
TimeRemaining
void CLNonInterruptingTimer::setTotalTime(CFTimeInterval)
NonInterruptingTimer, %s, totalTime, %.2f
void CLNonInterruptingTimer::persistTime()
NonInterruptingTimer, %s, persist
virtual void CLNonInterruptingTimer::startTimer()
NonInterruptingTimer, %s, startTimer
virtual void CLNonInterruptingTimer::stopTimer()
NonInterruptingTimer, %s, stopTimer
virtual CLGestureSubscription::~CLGestureSubscription()
ending metric session (MotionTrigger) for %{public}s
GestureDetected
GestureCanceled
void CLGestureSubscription::onEarGestureNotification(const CLEarGestureNotifier::CMEarGestureData &)
Sent ear gesture message (prototype %{private}s)
ignoring metric for phone pick-up
counting metric for non-phone pick-up
starting metric session (MotionTrigger) for %{public}s
void CLGestureSubscription::handleRequestGesture(bool, const CLNameValuePair &)
Received Gesture request,client,%{public}s,subscribe,%{public}d
kCLConnectionMessagePriorityKey
Priority not set
Got gesture subscription request, priority = %{public}d, Client = %{public}s
void CLGestureSubscription::handleRequestGesture(bool, const CLNameValuePair &)_block_invoke
#Warning CLDaemonClient got ear gesture callback after destruction... ignoring
v28@?0{?=[16c]i}8
Got gesture unsubscription request, Client = %{public}s
EarGesture
kTypeWorkout
kTypeMachineWorkout
slope.x,%f,slope.y,%f,slope.z,%f,intercept.x,%f,intercept.y,%f,intercept.z,%f,
CLCatherineNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Catherine/CLCatherineNotifier.mm
-[CLCatherineNotifierAdapter beginService]
CLCatherineNotifier
virtual void CLCatherineNotifier::shutdown()
CLCatherineNotifier is shutting down.
virtual bool CLCatherineNotifier::registerForNotificationInternal(const CLCatherineNotifier_Type::Notification &)
CatherineNotifier Added client for %d, count %d
virtual bool CLCatherineNotifier::unregisterForNotificationInternal(const CLCatherineNotifier_Type::Notification &)
CatherineNotifier Removed client for %d, count %d
HeartRate
virtual void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCatherineNotifier_Type::Notification, CLCatherineNotifier_Type::NotificationData>::listClients() [Notification_T = CLCatherineNotifier_Type::Notification, NotificationData_T = CLCatherineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLExerciseMinuteRecorderDb
DELETE FROM ExerciseMinuteHistory WHERE startTime < ?
virtual long CLExerciseMinuteRecorderDb::aggregateRecords(const CLAggregationRules &)
ExerciseMinute, Failed to expire records.
SELECT * FROM ExerciseMinuteHistory ORDER BY startTime ASC
CMError CLExerciseMinuteRecorderDb::queryExerciseMinuteDataSince(CLExerciseMinuteData &, std::vector<CLExerciseMinuteData> &) const
ExerciseMinute, DB not accessible.
ExerciseMinute, DB UUID un-initialized
SELECT * FROM ExerciseMinuteHistory WHERE id >= ? ORDER BY id ASC LIMIT ?
ExerciseMinute, Potential DB reset / roll back, returning all records to clients,mru.recordId,%d,record.recordId,%d
SELECT COUNT(*) FROM ExerciseMinuteHistory
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/ExerciseMinute/CLExerciseMinuteRecorderDb.mm
ExerciseMinuteHistory
INSERT INTO ExerciseMinuteHistory (startTime) VALUES (?)
SELECT * FROM ExerciseMinuteHistory ORDER BY startTime DESC LIMIT 1
virtual void CLExerciseMinuteRecorderDb::prepareSQLStatements()
ExerciseMinute, Device is locked and we are unable to open the database
DELETE FROM ExerciseMinuteHistory
DELETE FROM ExerciseMinuteHistory WHERE startTime > ?
virtual void CLExerciseMinuteRecorderDb::deleteRecordsAfterInsertUL(const CLExerciseMinuteData &)
ExerciseMinute, Failed to delete records
UPDATE ExerciseMinuteHistory SET startTime = startTime + ?
virtual void CLExerciseMinuteRecorderDb::shiftRecordsByUL(CFTimeInterval)
ExerciseMinute, Failed to shift records
CLActivityRecorderDb<CLExerciseMinuteData>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLExerciseMinuteData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLExerciseMinuteData>::setDatabaseAccessible() [T = CLExerciseMinuteData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLExerciseMinuteData>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLExerciseMinuteData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CFRunLoopGetCurrent() == CLMotionCore::instance()->getMotionRunLoop()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/IO/CLIoHidInterface.mm
addDevice
void CLIoHidInterface::addDevice(std::shared_ptr<CLIoHidInterface::Device>)
[CLIoHidInterface] Adding new Device with usage pair {%{public}d, %{public}d}
initializeHidIfNecessary
HighFrequency
void CLIoHidInterface::initializeHidIfNecessary()
[CLIoHidInterface] Could not create event system client. All bets are off
PreserveTimestamp
[CLIoHidInterface] Event system client initialized successfully
closeHid
void CLIoHidInterface::closeHid()
[CLIoHidInterface] Hid interface closed
refreshDeviceServiceRefs
void CLIoHidInterface::refreshDeviceServiceRefs(const IOHIDServiceClientRef)
[CLIoHidInterface] Refreshing service refs
PrimaryUsagePage
PrimaryUsage
[CLIoHidInterface] Check service ref %{private}p with usage pair {%{public}d, %{public}d} as a potential match
invalidateDeviceServiceRefs
void CLIoHidInterface::invalidateDeviceServiceRefs()
[CLIoHidInterface] Invalidating hid service refs
setPropertyIoHid
bool CLIoHidInterface::setPropertyIoHid(IOHIDServiceClientRef, CFStringRef, CFTypeRef)
[CLIoHidInterface] Property can not be set for null hidServiceRef
[CLIoHidInterface] IOHIDServiceClientSetProperty() returned false
applyAllDirtyDeviceProperties
void CLIoHidInterface::applyAllDirtyDeviceProperties()
[CLIoHidInterface] Apply all dirty device properties
[CLIoHidInterface] Service for device with usage pair {%{public}d, %{public}d} is not ready
successfully
unsuccessfully
[CLIoHidInterface] Property for usage pair {%{public}d, %{public}d}: {%{public}@ = %{public}@} was set %{public}s
[CLIoHidInterface] Could not set all properties. Setting timer to fire %{public}f seconds from now
[CLIoHidInterface] Could not set all properties after too many retries. Giving up.
setMatchingForDevices
void CLIoHidInterface::setMatchingForDevices()
[CLIoHidInterface] Prox: remove set matching multiple
[CLIoHidInterface] Adding match entry for usage pair {%{public}d, %{public}d}
[CLIoHidInterface] Setting matching multiple for %{public}lu events
void CLIoHidInterface::onEvent(void *, void *, IOHIDEventRef)
[CLIoHidInterface] Received null sender
[CLIoHidInterface] Got null event,sender %{private}p,registryID %{public}llx
[CLIoHidInterface] Fetching historical events
[CLIoHidInterface] Did not fetch historical events
void CLIoHidInterface::onEventSystemReset(void *)
[CLIoHidInterface] It looks like our HID event system just become available (again)
void CLIoHidInterface::onServiceRegistration(void *, IOHIDServiceClientRef)
[CLIoHidInterface] New IOHIDServiceClientRef for usage pair {%{public}d, %{public}d} just became available.
void CLIoHidInterface::onServiceRemoval(void *, IOHIDServiceClientRef)
[CLIoHidInterface] onServiceRemoval - IOHIDServiceClientRef for service %{private}p with usage pair {%{public}d, %{public}d} and property %{private}@ will be removed.
[CLIoHidInterface] onServiceRemoval - successfully switch to service %{private}p with usage pair {%{public}d, %{public}d} and property %{private}@.
[CLIoHidInterface] onServiceRemoval - no available alternatives
setCallback
setProperty
virtual void CLIoHidInterface::Device::setProperty(NSString *, id)
[CLIoHidInterface] Could not set property value for %{public}@
copyProperty
copyEvent
eventType > 0
ReportInterval
initializeServiceRef
bool CLIoHidInterface::Device::initializeServiceRef()
[CLIoHidInterface] Service for usage pair {%{public}d, %{public}d} is not ready
getServiceRef
updateServiceRef
void CLIoHidInterface::Device::updateServiceRef(IOHIDServiceClientRef, bool)
[CLIoHidInterface] Failed to stop streaming from the old service before switching to the new one
[CLIoHidInterface] Device,usagePage,%{public}d,usage,%{public}d,hidserviceref,old,%{private}p,new,%{private}p
[CLIoHidInterface] Service ref with usage pair {%{public}d, %{public}d} is %{private}p
static bool CLIoHidInterface::Device::serviceMatchesProperties(IOHIDServiceClientRef, NSDictionary<NSString *,id> *)
[CLIoHidInterface] Checking matching property %{public}@ = %{private}@ for service ref %{private}p
[CLIoHidInterface] Invalid matching property %{public}@ = %{public}@ for service ref %{private}p
[CLIoHidInterface] Property mismatch! %{public}@ = %{public}@ for service ref %{private}p
void CLIoHidInterface::Device::print() const
[CLIoHidInterface] Device,hidUsagePage,%{public}d,hidUsage,%{public}d,hasCallback,%{public}d,serviceRef,%{private}p
void CLIoHidInterface::Device::printProperties() const
[CLIoHidInterface] 
Property: %{public}@ = %{public}@,dirty,%{public}d
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/Notifiers/Compass/CLCompass7.mm
CLCompass7
virtual void CLCompass7::start(bool)
Compass for AOP started. CoverAttached %{public}d
virtual void CLCompass7::stop()
Compass for AOP stopped.
void CLCompass7::setDeviceMotionServiceUpdateInterval(const CFTimeInterval &)
Setting compass update interval to %{public}f
void CLCompass7::startTurnOffTimer()
Could not create turn-off timer
Keeping compass on for %{public}.0f seconds
static void CLCompass7::onDeviceMotionServiceIohidEvent(void *, void *, void *, IOHIDEventRef)
GyroCompass
CLMotionTypeCompass CLCompass7::populateMotionType(const CMDeviceMotionReport::Compass &, const CFTimeInterval &)
Type,%s,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,calibrated.x,%.8f,.y,%.8f,.z,%.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1f,level,%d,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,visualLocalizationCorrection,%d,initalized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,north,%d,visualLocalization,%d,timestamp,%f
void CLCompass7::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
visionARSessionState.state,%d
ClientName
com.apple.NanoMaps
com.apple.SOS
SOSNewtonTriggersEmergencySOSKey
FallDetectionOptInTime
CLFallNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Fall/CLFallNotifier.mm
-[CLFallNotifierAdapter beginService]
yyyyMMdd_HH-mm-ss
CoreMotionDebug_AnomalyData_%@.bin
+[CLFallNotifierSysdiagnoseLogCollector writeAnomalyInfoToFileWithLastFallEvent:writeMask:fallNotifierConfig:stateLogger:statsLogger:sensorsLogger:pressureLogger:heartRateLogger:wristStateLogger:odometerLogger:falsePositiveSuppressionFeaturesLogger:hgalLogger:logDirectory:logFilePrefix:]
Logging anomaly info in file [%s] [%s]
/var/root/Library/Caches/locationd/logs/newtonStats
newtonState
newtonStats
newtonSensors
pressure
heartRate
wristState
odometer
falsePositiveSuppressionFeatures
hgal
Logging anomaly info done packing file
+[CLFallNotifierSysdiagnoseLogCollector writeOtherFallLoggerData:otherLoggerDirectory:otherLoggerFilePrefix:destinationLogger:]
Dumping [%s]
FallForceIHAOptIn
com.apple.sensorkitd
NSDictionary *CLFallNotifier::moveFallStatsToFile(NSFileHandle *)
Unable to get contents of logging directory, error: %{public}@
v16@?0@"CLFallLogger"8
void CLFallNotifier::simulateEvent(CMFallEventType)
Simulating event: %{public}lu.
void CLFallNotifier::setHgalCaptureMode(uint8_t)
Changing hgal capture mode: %{public}u.
upstream
void CLFallNotifier::onClientFallEventSubscriptionRequest(const CLFall_Types::ImpactEvent &)
CLFitnessTrackingAllDayAWD: Increasing NumRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingWorkoutRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingtRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningWorkoutRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumHikingWorkoutRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumHikingFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseAutomaticActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseAutomaticActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseAutomaticActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseAutomaticActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseAutomaticActionRequested
Notifier - Received SOS Call initiated Callback
Notifier - Received SOS Call canceled Callback
Notifier - Received SOS Call ended Callback
Notifier - Received a SOS Call Ended Callback with no SOS Call timestamp!
Notifier - Logging SOS Call Placed
Notifier - Received SOS Call failed Callback
void CLFallNotifier::checkAndNotifyClientsWithData(CLFall_Types::ImpactEvent &, bool)
Fall detection feature is disabled, avoided dispatching event
No client was connected when event needed to be dispatched
FallStatsRequestors
LastFallAlertTime
CLFallNotifier::Config CLFallNotifier::generateConfig(CMSPUFall_Types::SimulatedType) const
config{ mode=%{public}d, sensorRecordingEnabled=%{public}d, sensorRecordingActive=%{public}d, simulateEvent=%{public}d, userStudyPressureDataCollection=%{public}d, detectorEnabled=%{public}d, lastReplyAopTimestamp=%{public}llu -> variables{ enableFallStats=%{public}d, alwaysOn=%{public}d, supportsFallStatsModeBW190=%{public}d, supportsFallStatsModeBW400=%{public}d, optin=%{public}d, age=%{private}d, underRateLimit=%{public}d, shouldLogSensorData=%{public}d},keys{ FallStatsEnabled=%{public}d, FallStatsSensorRecordingEnabled=%{public}d}
CMMotionCoprocessorCommand::Configure::FallStatsConfig CLFallNotifier::updateConfig(CMSPUFall_Types::SimulatedType)
Enabling Sensor Recorder
Disabling Sensor Recorder
CLFitnessTrackingAllDayAWD: Updating didEnableBackgroundAllDayAnomalyDetection %d
void CLFallNotifier::updateRateLimitCounter(NSTimeInterval)
Clearing fall stats rate limit counter, was %f out of %d allowed
Fall stats rate limit counter incremented by %f for a total %f out of %d allowed
void CLFallNotifier::checkDebugProfilePresence()
Checking debug profile presence
void CLFallNotifier::scheduleMetMinuteStatsCompute()
MaxMETs, on charger, setting timer interval to %f
MaxMETs, off charger, setting timer interval to %f
CLFallNotifier
FallMetMinuteStatsComputeInterval
FallMetMinuteStatsComputeIntervalOffCharger
CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)_block_invoke
CLFallImpactMetrics: Logging impact at time %llu
CLFitnessTrackingAllDayAWD: Logging impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging outdoor cycling impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging outdoor walking impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging outdoor running impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging hiking impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging other workout impact cancelation reason 0x%llx
v24@?0Q8r^{CLFallImpactMetrics=^^?ddQCiiiiiqfQQQ}16
Unregistering for HR Notifications
Fail safe sensor recording handler
isADLImpact
v24@?0@"NSDictionary"8r^v16
Received fall buffer flush packet
v12@?0C8
v40@?0C8d12Q20r*28I36
CLFallNotifier::CLFallNotifier(id<CLIntersiloUniverse>)
StatsRateLimitCounter set to %f
void CLFallNotifier::enableSensorRecording()
Setting up sensor recording
void CLFallNotifier::enableSensorRecording()_block_invoke
Releasing sensor data collection OS transaction
v40@?0@"NSDate"8@"NSDate"16@"NSDictionary"24@"NSDictionary"32
StatsRateLimitInterval
Time moved backwards. Reset timer immediately.
Setting next fire time for stats rate limiter (%f)
void CLFallNotifier::disableSensorRecording()
Tearing down sensor recording to server.
virtual void CLFallNotifier::shutdown()
Releasing power assertion due to Fall Notifier destruction.
void CLFallNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)
Received a workout event of type: %ld, with workout of type: %ld, workout state: %ld and healthkit workout of type: %ld
CLFitnessTrackingAllDayAWD: Updating end stats with workout type: %ld, start time: %ld, end time: %ld
void CLFallNotifier::onOdometerUpdate(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNotifier_Type::NotificationData &)
Logging odometer to logger.
Logging odometer for user studies.
Logging odometer to SensorKit.
void CLFallNotifier::logFallStats(const CLFall_Types::ImpactEvent &)
Impact does not meet logging threshold requirement, will disregard stats.
Impact stats logged in previous state, will disregard duplicate logging.
Taking power assertion due to significant impact event subscription.
Fall Stats triggered high resolution sensor read
Setting fail safe timer for 180s.
High impact event HR subscription.
Logging impact stats to logger.
Logging impact stats for user studies.
Logging impact stats to AWD
Logging impact stats to CoreAnalytics
Logging impact stats to SensorKit.
void CLFallNotifier::logFallState(const CLFall_Types::ImpactEvent &)
Impact does not meet logging threshold requirement, will disregard state.
Logging impact update to logger.
Logging impact update for user studies.
Logging impact stats to Msl sink.
void CLFallNotifier::logWristState(const CLFall_Types::WristState &)
Logging on-wrist state update to logger.
Logging wrist state update for user studies.
Logging on-wrist state update to Msl sink.
void CLFallNotifier::logUserAge(const float)
Logging age group to AWD and CoreAnalytics
void CLFallNotifier::flushLoggerManager()
Releasing power assertion
CMCrownUpDown
CMTimestamp
CMIsFallDetectionFeatureEnabled
CMFallDetectionShouldEnableFallDetection
CMImpactMaxAccelNormAlertThreshold
CMImpactMaxAccelNormLoggingStatsThreshold
CMImpactMaxAccelNormLoggingHeartRateThreshold
CMImpactMaxAccelNormLoggingHighResolutionSensorDataThreshold
CMTripFallPosteriorRatioDetectionThreshold
CMSlipFallPosteriorRatioDetectionThreshold
CMOtherFallPosteriorRatioDetectionThreshold
CMTripNearFallPosteriorRatioDetectionThreshold
CMSlipNearFallPosteriorRatioDetectionThreshold
CMOtherNearFallPosteriorRatioDetectionThreshold
CMMetMinutePercentileActual
CMMetMinutePercentile90
CMMetMinutePercentile95
CMMetMinutePercentile98
CMWorkoutType
CMIsNearFall
isFallDetectionFeatureEnabled
downstream
void CLFallNotifier::onImpactDataAccel800(const CLMotionCoprocessorInterface::NotificationData *, unsigned int)
Receiving Accel800
void CLFallNotifier::onImpactDataHgal(const CLMotionCoprocessorInterface::NotificationData *, unsigned int)
Receiving Hgal
void CLFallNotifier::onImpactDataGyro200(const CLMotionCoprocessorInterface::NotificationData *)
Receiving sensor data due to high impact
Receiving Gyro200
void CLFallNotifier::onImpactDataQuaternion6(const CLMotionCoprocessorInterface::NotificationData *)
Receiving DeviceMotion100
Creating sensor data collection OS transaction
com.apple.locationd.fall.logging
void CLFallNotifier::onFalsePositiveSuppressionFeatures(const CLMotionCoprocessorInterface::NotificationData *)
Logging false positive suppression features.
type,
,bins,
void CLFallNotifier::onFeatureDistributionMaxAccelNorm(const CLMotionCoprocessorInterface::NotificationData *)
Logging Max Accel Norm feature distribution to awd.
void CLFallNotifier::onFeatureDistributionJerkVectorMagnitude(const CLMotionCoprocessorInterface::NotificationData *)
Logging Jerk Vector Magnitude feature distribution to awd.
void CLFallNotifier::onFeatureDistributionMaxAbsXYZ(const CLMotionCoprocessorInterface::NotificationData *)
Logging Max Abs XYZ feature distribution to awd.
void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)
Received reason for canceling (impact:%{public}llu, operatingMode:%{public}u, reason:0x%{public}llx)
ImpactStart
         reason: %s
ImpactReplacedBecauseOfNewImpact
ImpactCanceledBecauseOfMaxAccelNorm
ImpactCanceledBecauseOfOtherHardThresholds
ImpactCanceledBecauseOfMultiPeaks
ImpactCanceledBecauseOfNaiveBayes
ImpactCanceledBecauseOfCyclingImpactThresholds
ImpactCanceledBecauseOfExistingAlert
ImpactCanceledBecauseOfDisabledStateMachine
AlertCanceledBecauseOfHighFrequencyFFT
AlertCanceledBecauseOfLowFrequencyFFT
AlertCanceledBecauseOfDecimatedLowFrequencyFFT
AlertCanceledBecauseOfFFT
AlertCanceledBecauseOfPeaksIQR
AlertCanceledBecauseOfOffBody
AlertCanceledBecauseOfRepetitiveMotion
AlertCanceledBecauseOfAbsenceOfQuiessence
AlertCanceledBecauseOfOffWristPre
AlertCanceledBecauseOfOffWristPost
AlertCanceledBecauseOfFeatureDisabled
AlertCanceledBecauseOfOnCharger
AlertCanceledBecauseOfAlreadyGatedBefore
AlertCanceledBecauseOfSimilarPeaks
AlertCanceledBecauseOfLockedNoMotionBeforeImpact
AlertCanceledBecauseOfReferee
AlertCanceledBecauseStand
AlertCanceledBecauseActive
AlertCanceledBecauseSteps
AlertCanceledBecauseOfDistanceTraveledPostImpact
AlertCanceledBecauseOfDistanceCyclingPostImpact
RecoveryCanceledBecauseOfReferee
SOSCanceledBecauseUserResponse
SOSCanceledBecauseOffWrist
SOSCanceledBecauseStand
SOSCanceledBecauseActive
SOSCanceledBecauseSteps
SOSCanceledBecauseAbsenceOfLongLie
SOSCanceledBecauseOfReferee
SOSCallConsidered
SOSCallScheduled
SOSCallPlaced
Dropping reason for canceling because of untracked operating mode
Logging reason for canceling in AWD
CLFitnessTrackingAllDayAWD: Increasing NumImpactReplacedBecauseOfNewImpact
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfMaxAccelNorm
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfOtherHardThresholds
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfMultiPeaks
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfNaiveBayes
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfExistingAlert
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfCyclingImpactThresholds
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfDisabledStateMachine
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledAggregate
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfHighFrequencyFFT
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfLowFrequencyFFT
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDecimatedLowFrequencyFFT
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfFFT
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfPeaksIQR
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffBody
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfRepetitiveMotion
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfAbsenceOfQuiessence
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffWristPre
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffWristPost
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledAggregate
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfFeatureDisabled
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOnCharger
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfAlreadyGatedBefore
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfSimilarPeaks
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfLockedNoMotionBeforeImpact
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfReferee
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseStand
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseActive
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseSteps
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDistanceTraveledPostImpact
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDistanceCyclingPostImpact
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledOtherAggregate
CLFitnessTrackingAllDayAWD: Increasing NumRecoveryCanceledBecauseOfReferee
CLFitnessTrackingAllDayAWD: Increasing NumRecoveryCanceledAggregate
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseUserResponse
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseOffWrist
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseStand
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseActive
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseSteps
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseAbsenceOfLongLie
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledAggregate
MaxAccelNormThreshold
UserAgeBin
UserMaxMets
numFallAlerts
numRecoveryEvents
numUserResponseConfirmedActionRequested
numUserResponseConfirmedNoActionRequested
numUserResponseDismissed
numUserResponseRejected
numUserResponseAutomaticActionRequested
numImpactReplacedBecauseOfNewImpact
numImpactCanceledBecauseOfMaxAccelNorm
numImpactCanceledBecauseOfOtherHardThresholds
numImpactCanceledBecauseOfMultiPeaks
numImpactCanceledBecauseOfNaiveBayes
numImpactCanceledBecauseOfCyclingImpactThresholds
numImpactCanceledBecauseOfExistingAlert
numImpactCanceledBecauseOfDisabledStateMachine
numImpactCanceledAggregate
numAlertCanceledBecauseOfHighFrequencyFFT
numAlertCanceledBecauseOfLowFrequencyFFT
numAlertCanceledBecauseOfDecimatedLowFrequencyFFT
numAlertCanceledBecauseOfFFT
numAlertCanceledBecauseOfPeaksIQR
numAlertCanceledBecauseOfOffBody
numAlertCanceledBecauseOfRepetitiveMotion
numAlertCanceledBecauseOfAbsenceOfQuiessence
numAlertCanceledBecauseOfOffWristPre
numAlertCanceledBecauseOfOffWristPost
numAlertCanceledAggregate
numAlertCanceledBecauseOfFeatureDisabled
numAlertCanceledBecauseOfAlreadyGatedBefore
numAlertCanceledBecauseOfOnCharger
numAlertCanceledBecauseOfSimilarPeaks
numAlertCanceledBecauseOfLockedNoMotionBeforeImpact
numAlertCanceledBecauseOfReferee
numAlertCanceledBecauseStand
numAlertCanceledBecauseActive
numAlertCanceledBecauseSteps
numAlertCanceledBecauseOfDistanceTraveledPostImpact
numAlertCanceledBecauseOfDistanceCyclingPostImpact
numAlertCanceledOtherAggregate
numRecoveryCanceledBecauseOfReferee
numRecoveryCanceledAggregate
numSOSCanceledBecauseUserResponse
numSOSCanceledBecauseOffWrist
numSOSCanceledBecauseStand
numSOSCanceledBecauseActive
numSOSCanceledBecauseSteps
numSOSCanceledBecauseAbsenceOfLongLie
numSOSCanceledBecauseOfReferee
numSOSCanceledAggregate
numSOSCallConsidered
numSOSCallScheduled
numSOSCallPlaced
numOutdoorCyclingFallAlerts
numOutdoorCyclingRecoveryEvents
numOutdoorCyclingUserResponseConfirmedActionRequested
numOutdoorCyclingUserResponseConfirmedNoActionRequested
numOutdoorCyclingUserResponseDismissed
numOutdoorCyclingUserResponseRejected
numOutdoorCyclingUserResponseAutomaticActionRequested
numOutdoorWalkingFallAlerts
numOutdoorWalkingRecoveryEvents
numOutdoorWalkingUserResponseConfirmedActionRequested
numOutdoorWalkingUserResponseConfirmedNoActionRequested
numOutdoorWalkingUserResponseDismissed
numOutdoorWalkingUserResponseRejected
numOutdoorWalkingUserResponseAutomaticActionRequested
numOutdoorRunningFallAlerts
numOutdoorRunningRecoveryEvents
numOutdoorRunningUserResponseConfirmedActionRequested
numOutdoorRunningUserResponseConfirmedNoActionRequested
numOutdoorRunningUserResponseDismissed
numOutdoorRunningUserResponseRejected
numOutdoorRunningUserResponseAutomaticActionRequested
numHikingFallAlerts
numHikingRecoveryEvents
numHikingUserResponseConfirmedActionRequested
numHikingUserResponseConfirmedNoActionRequested
numHikingUserResponseDismissed
numHikingUserResponseRejected
numHikingUserResponseAutomaticActionRequested
void CLFallNotifier::onImpactDataStart(const CLMotionCoprocessorInterface::NotificationData *)
An Impact sequence just started.
void CLFallNotifier::onPressureData(const CLMotionCoprocessorInterface::NotificationData *)
Receiving Pressure
watchkitapp
void CLFallNotifier::onHeartRateNotification(int, const CLCatherineNotifier_Type::Notification &, const CLCatherineNotifier_Type::NotificationData &)
Received post event HR : %f
onWatchOrientationSettingsNotification
void CLFallNotifier::logInternalState()
CLFallNotifier Logging Internal State:
CMFallInternalNotifierState::CMFallDefaults: %{private}@
CMFallInternalNotifierState::CMFallConfiguration: %{private}@
CMFallInternalNotifierState::CMFallState: %{private}@
CMFallInternalNotifierState::CMFallOptInsAndProfiles: %{private}@
CMFallInternalNotifierState::CMFallFieldMetrics: %{private}@
CMFallInternalNotifierState::CMFallHDSCollection: %{private}@
CMFallInternalMetricState: (%{private}lu)
    %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@
void CLFallNotifier::onDarwinNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNotifier_Type::NotificationData &)
Received sysdiagnose event
Additional logging profile installed - Subject UUID: %{public}@
Logging anomaly info...
Received daemon settings notification
Received managed configuration change notification
void CLFallNotifier::selectFallModels()
Failed to get user mets percentile.
Could not select model based in provided features - Falling back to defaults
LastGatedAnomalyAOPTimestamp
%lld
LastFallAdditionalProfileLoggingEnabled
SOSNewtonStateChangedNotification
CLFallNotifier::onFallStatsData
CLFallNotifier::onFallEventData
CLFallNotifier::onImpactDataAccel800
CLFallNotifier::onImpactDataHgal
CLFallNotifier::onImpactDataGyro200
CLFallNotifier::onImpactDataQuaternion6
CLFallNotifier::onImpactDataStart
CLFallNotifier::onFalsePositiveSuppressionFeatures
CLFallNotifier::onFeatureDistributionMaxAccelNorm
CLFallNotifier::onFeatureDistributionJerkVectorMagnitude
CLFallNotifier::onFeatureDistributionMaxAbsXYZ
CLFallNotifier::onFallCancelReason
CLFallNotifier::onPressureData
CLFallNotifier::onFallDistance
CLFallNotifier::onWatchOrientationNotification
CLFallNotifier::onAppMonitorNotification
CLFallNotifier::onHeartRateNotification
CLFallNotifier::onUserInfoNotification
CLFallNotifier::onDataProtectionNotification
CLFallNotifier::onWatchOrientationSettingsNotification
CLFallNotifier::onMotionStateMediatorNotification
CLFallNotifier::onOdometerUpdate
CLFallNotifier::onBatteryNotification
CLFallNotifier::onDataCollectionChangedNotification
CLFallNotifier::onDarwinNotification
virtual void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]
B8@?0
virtual void CLMotionNotifier::SiloDispatcher<CLMotionCoprocessorInterface::NotificationData>::dispatchData(int, const void *, size_t) [T = CLMotionCoprocessorInterface::NotificationData]
SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d
virtual void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::removeClient(int) [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::clientRegistered(int, const Notification_T &) [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFallNotifier_Type::Notification, CLFall_Types::ImpactStreamData>::listClients() [Notification_T = CLFallNotifier_Type::Notification, NotificationData_T = CLFall_Types::ImpactStreamData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CMChoreaDetection::checkForGap(CFAbsoluteTime)
Resetting detector, %.1f seconds without an accel sample
Resetting detector, %.1f seconds without a tremor score
const T &CMQueue<CMTremorDetection::SensorSample>::operator[](const size_t) const [T = CMTremorDetection::SensorSample]
kCLConnectionMessageSidebandOverride
void CLSidebandSubscription::handleMessageSidebandOverride(std::shared_ptr<CLConnectionMessage>)
Invalid message recieved from framework.
void CLSidebandSubscription::handleMessageSidebandSensorFusionEnable(std::shared_ptr<CLConnectionMessage>)
[SidebandSensorFusion] Wrong parameters were passed!
[SidebandSensorFusion] Request failed,enabled,%{public}d,snoop,%{public}d,latency,%{public}d,success,%{public}d
CLCompass
ForceResetCompassOnChargingEvent
CompassForceCoverAttach
CLCompass::CLCompass()
Registered for keyboard state notifications
Registered for charging events.
Retrieved cached cover state timestamp,%f
Registered for cover state notifications
virtual CFTimeInterval CLCompass::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
Could not create timer
void CLCompass::startCompass()
Cover attached,%d,forced,%d
CLCompass_Type::CompassCoexSource CLCompass::checkForCompassCoexSource()
Keyboard coexSource,%d
closed
static void CLCompass::onCoverState(const bool *, void *)
Cover %s
connected
disconnected
void CLCompass::updateKeyboardState(bool)
Keyboard %s
CLPlatformInfo::isRunningInLocationd()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/Notifiers/Compass/CLCompass.mm
void CLCompass::onDaemonStatus(const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Resetting compass on charging event,charging,%d
CLCompassCalculator::CLCompassCalculator(const CFTimeInterval &, bool, bool)
using attitude dependent KF calibrator
CompassIgnoreDatabase
compass ignoring database (%d)
CompassManualCalibration
CompassOffsetManualX
CompassOffsetManualY
CompassOffsetManualZ
compass using manual bias (%.3f/%.3f/%.3f)
CompassIgnoreCalibration
compass ignoring calibration (%d)
CompassInputFilter
compass input filter is using (%zuu) samples
CompassOutputFilterSize
CompassOutputFilterScale
compass heading output filter samples (%d) scale (%f)
apple compass calculator, sample rate (%.3f) ignoreDatabase (%d) manual (%d)
bool CLCompassCalculator::feedMagnetometerData(const CLMotionTypeMagneticField &)
XYDevice not stable. %d, %d, %.3f, Clearing search buffers.
storing new compass calibration, magneticField (%+.3f,%+.3f,%+.3f), bias (%+.3f/%+.3f/%+.3f), level (%d) magnitude (%+.3f) inclination (%+.3f)
bool CLCompassCalculator::getCompassData(CLMotionTypeCompass &)
rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroHeadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, deltaFiltered, %.3f
#Warning Heading  %.2f, is not in bound [0 360]
void CLCompassCalculator::updateInterferenceChecks()
magnitude max threshold exceeded (%+.3f), resetting calibration
magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
void CLCompassCalculator::feedCompassDatabaseNotificationWithData(int, const CLCompassDatabase_Type::Notification &, const CLCompassDatabase_Type::NotificationData &)
CompassDB restored bias (%+.3f/%+.3f/%+.3f)
2.4GHz
5GHz
dual-band
connectionStatus
pairedModelId
https://gateway.icloud.com/eedservice/Device/LIS/Update
https://gateway.icloud.com/eedservice/Device/ADR/Update
void CLEmergencyEED2::SimConfig::addPartnerCert(const std::string &, const std::string &, CLEmergencyEED2::PartnerCertMap &)
#Warning #EED2Cfg,inst,%{public}d,unable to convert base64 string to SecCertificateRef for partner %{private}s
#Warning #EED2Cfg,inst,%{public}d,found duplicate certifacte for partner %{partner}s
#EED2Cfg,inst,%{public}d,added cert for partner %{private}s
EEDIntermediateCert
void CLEmergencyEED2::SimConfig::loadSettingsFromDefaults()
#Warning #EED2Cfg,inst,%{public}d,overriding intermediate cert to %{private}s
EEDLISURL
#Warning #EED2Cfg,inst,%{public}d,overriding LIS URL to %{private}s
EEDADRURL
#Warning #EED2Cfg,inst,%{public}d,overriding ADR URL to %{private}s
EEDForceEnable
#Warning #EED2Cfg,inst,%{public}d,force enabling EED
EEDPartnerCerts
void CLEmergencyEED2::SimConfig::readPartnerCertDefault(CLEmergencyEED2::PartnerCertMap &)
#Warning #EED2Cfg,partner certificate default overriding certs from other sources
#Warning #EED2Cfg,inst,%{public}d,unable to retrieve partner IDs from default
#EED2Cfg,inst,%{public}d,reading %{public}d partner certs from default
#Warning #EED2Cfg,inst,%{public}d,unable to read cert data for partner %{private}s
CLEmergencyEED2::PartnerCertMap CLEmergencyEED2::SimConfig::getValidatedPartnerCerts(const CLEmergencyEED2::PartnerCertMap &) const
#EED2Cfg,unable to convert intermediate cert data to SecCertificateRef
EEDUseTestCertPolicy
Test
Prod
#EED2Cfg,inst,%{public}d,configured to use %{public}s ADR cert policy
1.2.840.113635.100.6.2.3
1.2.840.113635.100.15.4
1.2.840.113635.100.15.1
#EED2Cfg,failed to create ADR cert validation policy
#EED2Cfg,partner certificate is valid,partner ID,%{public}s,partner cert,%{public}s
#EED2Cfg,invalid partner certificate found,partner ID,%{public}s,partner cert,%{public}s
bool CLEmergencyEED2::SimConfig::validatePartnerCertificate(SecPolicyRef, SecCertificateRef, const std::string &, const std::string &) const
#EED2Cfg,unable to convert partner cert data to SecCertificateRef,partner ID,%{public}s
#EED2Cfg,partner ID does not match common name in cert,partner ID,%{public}s,common name,%{public}s
#EED2Cfg,failed to create trust object when validating ADR cert,partner ID,%{public}s,err,%{public}d
#EED2Cfg,failed to disable network use for trust eval,partner ID,%{public}s,err,%{public}d
#EED2Cfg,ADR certificate validation failed,partner ID,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s
GpsSimulatorTestMode
CLEmergencyEED2::Config::Config()
#Warning #EED2Cfg EED2 is disabled due to simulator mode
#Warning #EED2Cfg EED2 is disabled due to conformance mode
EEDSendFullADR
bool CLEmergencyEED2::Config::updateEmergencySettings(const CLEmergencyController::LocationSettings &)
#EED2Cfg ignoring emergency settings for unexpected inst %{public}d
bool CLEmergencyEED2::Config::updateEmergencySim(const CLEmergencyAction::SimInstance)
#EED2Cfg keeping previous active inst %{public}d
#EED2Cfg ignoring unexpected inst %{public}d
#EED2Cfg active inst changed to %{public}d
bool CLEmergencyEED2::Config::updateBaaSettings(const CLEmergencyAction::SimInstance, const CLEmergencyEED2::BAASettings &, const CLEmergencyEED2::BAASettings &)
#EED2Cfg ignoring BAA settings for unexpected inst %{public}d
bool CLEmergencyEED2::Config::isEnabled() const
#EED2Cfg unexpected inst %{public}d is active
bool CLEmergencyEED2::Config::shouldDisplayEEDUI() const
#EED2Cfg EED enabled for sim %{public}d operator
#EED2Cfg EED enabled for sim %{public}d carrier
be displayed
not be displayed
#EED2Cfg EED UI should %{public}s
bool CLEmergencyEED2::Config::shouldRequestBaaCerts() const
#EED2Cfg BAA enabled for sim %{public}d operator
#EED2Cfg BAA enabled for sim %{public}d carrier
#EED2Cfg BAA cert requests %{public}s
const CLEmergencyEED2::SimConfig &CLEmergencyEED2::Config::getOperatorSimConfig() const
#EED2Cfg EED2 config for inst %{public}d wasn't created on construction
carrier
const CLEmergencyEED2::SimConfig &CLEmergencyEED2::Config::getSimConfig(CLEmergencyAction::SimInstance, std::string) const
#EED2Cfg EED2 carrier config for inst %{public}d wasn't created on construction
#EED2Cfg EED2 operator config for inst %{public}d wasn't created on construction
operator
const CLEmergencyEED2::SimConfig &CLEmergencyEED2::Config::getSimConfigForBaa() const
#EED2Cfg requested sim config for BAA when not enabled
#EED2 state machine
BAAResetCache
Enabled
ADREnabled
DSAEnabled
LISURL
ADRURL
FirstLISPOSTDelay
PeriodicLISPOSTDelay
InitialADRPOSTTimeout
IntermediateCert
PartnerInfo
PartnerID
ADRCert
Disabled
EEDEnabledOnly
CertValidityPeriod
NoCertRequestWindow
NoCertRetryWindow
CertAvailableRequestWindowMin
CertAvailableRequestWindowMax
CertAvailableRetryWindow
Enter
Exit
ConfigChange
EmergencyStateChange
EmergencyCallStatusChange
CachedLocationUpdate
SendFixTimeout
SendAdrTimeout
AdrDataChanged
AdrDataRetrievalException
SessionAssertReleased
CanSendADRTimeout
AuthorizationChanged
LISResponseReceived
LISResponseTimeout
EventUnknown
Idle
Session
StateUnknown
Native
Companion
virtual void CLEmergencyEED2::handleEmergencyStateChange(CLEmergencyState)
#EED2 active inst changed to %{public}d
void CLEmergencyEED2::handleAuthorizationStatusChange(CLAuthorizationStatus)
#EED2,#DSA,authorization status has not changed,status,%{public}d
#EED2,#DSA,authorization status changed for SOS bundle,status,%{public}d
CLEmergencyEED2::State CLEmergencyEED2::handler_Disabled(CLEmergencyEED2::Event)
#Warning #EED2 SendFixTimeout fired while Disabled
#Warning #EED2 SendAdrTimeout fired while Disabled
#Warning #EED2 SessionAssertReleased fired in Disabled state
#Warning #EED2 CanSendADRTimeout fired while Disabled
#EED2 LIS Response timer timedout. Submit AWD report with failure
#EED2 LIS Response timer timedout when no notifications were expected
CLEmergencyEED2::State CLEmergencyEED2::handler_Idle(CLEmergencyEED2::Event)
#Warning #EED2 SendFixTimeout fired while Idle
#Warning #EED2 SendAdrTimeout fired while Idle
#Warning #EED2 SessionAssertReleased fired in Idle state
#Warning #EED2 CanSendADRTimeout fired while Idle
#EED2 LIS response timer timedout. Submit AWD report with failure
#EED2 LIS response timer timedout when no notifications were expected
CLEmergencyEED2::State CLEmergencyEED2::handler_Session(CLEmergencyEED2::Event)
#EED2 Submitting previous session AWD report before starting new session
#EED2 allowed to send ADR data immediately
fetching DSA for EED2
#EED2 session assertion active during Session Exit,clearing
#Warning #EED2 unexpectedly disabled during active emergency call
#EED2 delaying Session Exit due to session assertion
#EED2 EmergencyCallStatusChange,no ongoing call,cancel CanSendADRTimeout
#EED2 EmergencyCallStatusChange,ADR allowed immediately
#EED2 EmergencyCallStatusChange,subsequent emergency call ongoing,restart CanSendADRTimeout
#EED2 EmergencyCallStatusChange,subsequent emergency call ongoing,ADR allowed immediately
#EED2 EmergencyCallStatusChange,sending ADR immediately
#EED2 CachedLocationUpdate,triggering ADR send
#EED2 delaying sending updated ADR data until timer fires or we fetch all ADR data
#EED2 CanSendADRTimeout,ADR sending already allowed
#EED2 CanSendADRTimeout,no ongoing emergency call
#EED2 CanSendADRTimeout,ongoing emergency call,allow ADR
#Warning #EED2 LIS Timeout while in Session. Ignoring it
bool CLEmergencyEED2::copyCachedKey(NSString *, SecKeyRef *)
#EED2,#Sec,failed to copy key from keychain,response,%{public}d
bool CLEmergencyEED2::deleteCachedKey(NSString *)
#EED2,#Sec,failed to delete key from keychain,response,%{public}d
bool CLEmergencyEED2::cacheKey(NSString *, NSString *, SecKeyRef)
#EED2,#Sec,failed to add key to keychain,response,%{public}d
bool CLEmergencyEED2::copyCachedCert(NSString *, SecCertificateRef *)
#EED2,#Sec,failed to copy cert from keychain,response,%{public}d
bool CLEmergencyEED2::deleteCachedCert(NSString *)
#EED2,#Sec,failed to delete cert,response,%{public}d
bool CLEmergencyEED2::cacheCert(NSString *, NSString *, SecCertificateRef)
#EED2,#Sec,failed to add cert to keychain,response,%{public}d
void CLEmergencyEED2::loadCachedBaaInfo()
#EED2,#BAA,loading cached info
com.apple.locationd.BAA.key
#EED2,#BAA,unable to retrieve BAA private key from keychain
com.apple.locationd.BAA.leafCert
#EED2,#BAA,unable to retrieve BAA leaf cert from keychain
com.apple.locationd.BAA.intCert
#EED2,#BAA,unable to retrieve BAA intermediate cert from keychain
#EED2,#BAA,following info missing in keychain,private key,%{public}d,leaf cert,%{public}d,intermediate cert,%{public}d
BaaNextCertRequestTime
#EED2,#BAA,cache did not contain next BAA cert request time
void CLEmergencyEED2::writeCachedBaaInfo()
#EED2,#BAA,writing info to disk
#EED2,#BAA,unable to delete existing BAA private key
#EED2,#BAA,failed to add BAA private key to keychain
#EED2,#BAA,unable to delete existing BAA leaf cert
#EED2,#BAA,failed to add BAA leaf cert to keychain
#EED2,#BAA,unable to delete existing BAA intermediate cert
#EED2,#BAA,failed to add BAA intermediate cert to keychain
void CLEmergencyEED2::deleteCachedBaaInfo()
#EED2,#BAA,deleting cached info
DaemonStartup
ConfigChanged
SessionStart
PostSuccessfulCertRequest
PostFailedCertRequest
ReasonUnknown
void CLEmergencyEED2::checkBaaCertRequestStatus(CLEmergencyEED2::CertRequestStatusCheckReason)
#EED2,#BAA,there is a cert request outstanding already,no need to do anything until we get a response
#EED2,#BAA,no need to start XPC activity
#EED2,#BAA,need to stop XPC activity due to device settings
#EED2,#BAA,need to start XPC activity
#EED2,#BAA,next cert request time changed so (re)starting XPC activity
#EED2,#BAA,need to request cert immediately for ongoing session
#EED2,#BAA,scheduling next cert request
bool CLEmergencyEED2::checkNextCertRequestTime(CLEmergencyEED2::CertRequestStatusCheckReason)
#EED2,#BAA,shouldn't be checking next cert request time during SessionStart
#Warning #EED2,#BAA,next cert request time places us beyond expiration of current cert so modifying
#EED2,#BAA,updated next cert request time
void CLEmergencyEED2::registerBaaCertRequestActivity()
#EED2,#BAA,requesting of BAA certs not allowed by config,not starting XPC activity
BAAGracePeriod
#EED2,#BAA,registering BAA cert request activity,delay,%{public}lld,gracePeriod,%{public}lld
com.apple.locationd.BAA
void CLEmergencyEED2::registerBaaCertRequestActivity()_block_invoke
#EED2,#BAA,cert request activity handler triggered with unexpected state %{public}d
#EED2,#BAA,cert request activity handler triggered
void CLEmergencyEED2::unregisterBaaCertRequestActivity()
#EED2,#BAA,unregistering BAA cert request activity
void CLEmergencyEED2::sendLocation()
#EED2 attempted to send location when not enabled
#EED2 sending message for native number
#EED2 native number is empty, not sending message
#EED2 sending message for companion number
#EED2 companion number is empty or device supports alternate account, not sending message
void CLEmergencyEED2::sendLocation(CLEmergencyEED2::NumberType, const std::string &)
#EED2 no fix available to send in LIS payload, not sending
internal
#EED2 can't POST message due to invalid URL session
#EED2 POSTing LIS data for %{public}s number message %{public}d
call_ID
session_start_time
medium
Voice
Text
static NSDictionary *CLEmergencyEED2::createLocationDict(const GNSS::DaemonLocation &)
#EED2,location is not valid so not creating location dict
hunc
altitude
vunc
message_ID
Unavailable
sim_bundle_id
operator_bundle_id
sim_country
operator_country
product_type
release_type
trigger_type
void CLEmergencyEED2::postMessage(CLEmergencyEED2::NumberType, NSDictionary *, const GNSS::DaemonLocation &)
#EED2 failed to serialize LIS dict into JSON
POST
v32@?0@"NSData"8@"NSURLResponse"16@"NSError"24
static NSData *CLEmergencyEED2::getSerializedJsonData(NSDictionary *)
#EED2,getSerializedJsonData,dict is nil
#EED2,getSerializedJsonData,failed to serialize dict into JSON,domain,%{public}s,code,%{public}d
application/json
content-type
content-length
x-eed-payload-version
x-mme-client-info
x-eed-baa-signature
void CLEmergencyEED2::addHeadersToUrlRequest(NSData *, NSMutableURLRequest **) const
#EED2,#BAA,added header x-eed-baa-signature : %{public}s
x-eed-baa-leaf-cert
#EED2,#BAA,added header x-eed-baa-leaf-cert : %{public}s
x-eed-baa-int-cert-1
#EED2,#BAA,added header x-eed-baa-int-cert-1 : %{public}s
#EED2,#BAA,POST body
#EED2,#BAA,addHeadersToUrlRequest,cert not available
EED2EnvHeader
#Warning #EED2,sending environment override header for %{private}s
x-eed-environment
EEDDemoHeader
#Warning #EED2,sending demo header for %{private}s
x-eed-demo
X-Responding-Instance
X-Apple-Request-UUID
X-Apple-Jingle-Correlation-Key
void CLEmergencyEED2::handleHttpsResponse(CLEmergencyEED2::NumberType, uint32_t, const GNSS::DaemonLocation &, NSURLResponse *, NSError *)
#EED2, messageID is not part of pending messageID!
#EED2 POST for %{public}s number message %{public}d succeeded with response code %{public}d
#EED2 POST for %{public}s number message %{public}d failed with response code %{public}d
#EED2 POST was determined to be outside coverage area
#EED2 POST for %{public}s number message %{public}d failed with error code,%{public}d,domain,%{public}@,reason,%{public}@
void CLEmergencyEED2::startCanSendADRTimeout()
#EED2 startCanSendADRTimeout called when timeout is already running, ignoring
#EED2 startCanSendADRTimeout
void CLEmergencyEED2::cancelCanSendADRTimeout()
#EED2 cancelCanSendADRTimeout
void CLEmergencyEED2::sendAdr()
#EED2,sendAdr,attempted to send ADR when not enabled
#EED2,sendAdr,ignoring ADR send request,not allowed to send ADR data at this time
#EED2,sendAdr,ignoring ADR send request,not finished gathering ADR data
#EED2,sendAdr,neither native nor companion number available so not sending ADR
#EED2,sendAdr,no location available so not sending ADR
#EED2,sendAdr,failed to send
void CLEmergencyEED2::handleAdrResponse(CLEmergencyEED2::NumberType, NSURLResponse *, NSError *)
#EED2,ADR POST for %{public}s number succeeded with response code %{public}d
#EED2,ADR POST for %{public}s number failed with response code %{public}d
#EED2,ADR POST was determined to be outside coverage area
#EED2,ADR POST for %{public}s number failed with error code,%{public}d,domain,%{public}@,reason,%{public}@
virtual uint32_t CLEmergencyEED2::getErrorCodePriority(Emergency::SessionErrorCode)
#Warning #EED2 unexpected error code
unordered_map::at: key not found
!name.empty()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/GPS/CLStateMachine.h
CLStateMachine
h && "invalid handler"
setStateHandler
void CLStateMachine<CLEmergencyEED2>::setStateHandler(CLStateMachine::State, CLStateMachine::StateHandler) [T = CLEmergencyEED2]
%sstate,%d,%s
handler && "invalid handler"
handleEvent
fIniitalized && "must call initialize(state) first"
CLStateMachine::State CLStateMachine<CLEmergencyEED2>::handleEvent(CLStateMachine::Event) [T = CLEmergencyEED2]
%scurrent_state,%s,event,%s
handlerFn != std::end(state_handlers)
newState == oldState
%sNested invocation of state machine
%snewState,%s
%soldState,%s,event,%s
retState == oldState
%snewState,%s,event,%s
retState == newState
void CLStateMachine<CLEmergencyEED2>::cancelTimeoutEvent(CLStateMachine::Event) [T = CLEmergencyEED2]
%scancel timer,event,%s
#Warning,%s,cancel timer,notFound, event,%s
void CLStateMachine<CLEmergencyEED2>::setTimeoutEvent(CLStateMachine::Event, double) [T = CLEmergencyEED2]
%sInvoking timers without callback queue set
setTimeoutEvent
%sCannot start timer, event, %{public}s, timeOutSec, %{public}.2f
%scannot create timer, event, %{public}s
%sevent,%s,timeout,%.2f
rat, 
, numAlsRequests, 
, numCellsRequested, 
com.apple.clx.alsrequests
NumRequests
NumRequestsBounded
NumTower
CellRequestsWithDifferentRats
CellRequestsWithDifferentRatsBounded
WifiRequests
WifiRequestsBounded
WifiNumAps
WifiNumSurroundingAps
NR5G
bool CLCachedLocationScanMode::setScanMode(CachedLocationScanPowerMode)
Already correct power mode, %d
Changing cached location power mode from %d to %d
stage1+5GHz
stage2+5GHz
CLCompassAccuracy::CLCompassAccuracy(const float, const float, const size_t, const size_t, const bool)
mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd), coverAttached (%d)
void CLCompassAccuracy::init(const float, const float, const size_t, const size_t)
mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd)
CLCompassDatabaseSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Compass/CLCompassDatabase.mm
-[CLCompassDatabaseLocationdAdapter beginService]
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCompassDatabase_Type::Notification, CLCompassDatabase_Type::NotificationData, char, char>::listClients() [Notification_T = CLCompassDatabase_Type::Notification, NotificationData_T = CLCompassDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLThreshold::init(const float &, const float &, const float &, const unsigned int, const unsigned int, const unsigned int, const float &, const bool)
sample rate (%.3f) observation rate (%.3f) observation threshold (%.3f) deviation count threshold (%d) standard deviation threshold (%.3f)
bool CLThreshold::update(const float &)
threshold (%f) was exceeded with observed value (%f) and base value (%f) and standard deviation (%f) and count of (%d)
virtual CLMotionActivity::TypeYouth CLFitnessYouthHeartRateOverride::doOverride(CLMotionActivity::TypeYouth, const CLNatalieModelInput &)
Overriding youth type for heart rate, beginTime, %f, before, %{public}d, after, %{public}d, fhr,%{public}f
virtual CLWorkoutPredictor_Type::WorkoutStopDetectionEvent CLRowingWorkoutStopModel::update(const CLWorkoutPredictorInputs &)
HRStop detect in rowing model during state,%{public}d
RowStop,state,%d,rowCounter,%d,headingCounter,%d,epochsInExit,%d,longStd,%f,shortStd,%f,isRow,%d,isRowHistory,%d,isRowUnf,%d
const T &CMQueue<CLRowingWorkoutStopModel::RowMotionDetector::Features>::operator[](const size_t) const [T = CLRowingWorkoutStopModel::RowMotionDetector::Features]
static std::optional<Decisions::WifiTileDownloadRequest> CL::Wifi1::Policies::TileRequest::HandleEvent::defaultDecisionLogic(const CL::Wifi1::Policies::TileRequest::Input &)
WifiFlow, cpitile, %{public}d, didfix, %{public}d, battsaver, %{public}d, sigenv, %{public}d, aps, %{public}ld, hacc, %{public}0.1f, scanAge, %{public}d
n <= 65
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/GyroBiasEstimator/CLGyroBiasFitter.cpp
computeLinearFit
buffer.capacity() == std::max<size_t>(1, n * (n - 1))
bool CLSmootherCornerFinder::findCorners(const std::vector<swan::RouteSmootherEpoch> &, std::vector<int> &)
CLRS,CLCF,Could not convert LLA Coordinate %.7lf,%.7lf to ECEF
CLRS,CLCF,Could not convert ECEF Coordinate %.3lf,%.3lf,%.3lf to ENU
CLRS,CLCF,No corners found, input segment too short.
CNMatrix
nr >= 0
nc >= 0
SetMatrixSize
cnmatrixbase.h
this->max_num_rows_ >= num_rows
this->max_num_cols_ >= num_cols
AllocateMemoryBacking
this->allocated_data_
data_ != __null
idx >= 0
idx < num_elements_
operator=
this->max_num_rows_ >= A.num_rows_
this->max_num_cols_ >= A.num_cols_
FastResize
in_nr >= 0
in_nr <= max_nr
in_nc >= 0
in_nc <= max_nc
strcmp(c, ":") == 0
cnsubmatrix.h
A.num_rows_ == B.num_rows_
A.num_cols_ == B.num_cols_
&(A) != &(C)
&(B) != &(C)
Multiply
Subtract
this->num_rows_ == A.num_rows_
this->num_cols_ == A.num_cols_
&A != &Acopy
&A != &Work
&A != &U
&A != &S
&A != &V
&Acopy != &Work
&Acopy != &U
&Acopy != &S
&Acopy != &V
&Work != &U
&Work != &S
&Work != &V
&U != &S
&U != &V
&S != &V
ne >= 1
ne >= 3*minnrnc + maxnrnc
ne >= 5*minnrnc
Acopy.max_num_rows_ >= nrA
Acopy.max_num_cols_ >= ncA
U.max_num_rows_ >= nrA
U.max_num_cols_ >= nrA
S.max_num_rows_ >= nrA
S.max_num_cols_ >= ncA
V.max_num_rows_ >= ncA
V.max_num_cols_ >= ncA
Error using Svd: input argument %d invalid in gesvd.
Error using Svd: gesvd failed to converge on %d superdiagonals.
Warning: Svd optimal workspace size %u is greater than provided workspace size %u; performance may suffer.
info == 0
TransposeInPlace
A.max_num_rows_ >= A.num_cols_
A.max_num_cols_ >= A.num_rows_
strcmp(r, ":") == 0
Norm
Acopy.num_elements_ >= A.num_elements_
Error using Norm: invalid %s-norm.
-inf
ret == 1
SingularValues
S.max_num_rows_ >= minnrnc
S.max_num_cols_ >= 1
a.num_rows_ == 1 || a.num_cols_ == 1
b.num_rows_ == 1 || b.num_cols_ == 1
a.num_elements_ == b.num_elements_
Transpose
&(A) != &(B)
private.HomeKit.DuetEvent.triggerLocalizationScan
private.HomeKit.DuetEvent.triggerRecordingScan
self.cdRegistration != nullptr
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Duet/CLDuetMonitor.mm
-[CLDuetRegistration registerCallback]
Registered with CoreDuet for %{private}@ with predicate %{private}@
-[CLDuetRegistration deregisterCallback]
Deregistered with CoreDuet for %{private}@ with predicate %{private}@
clduetEventTypeToString
CLDuetEventTypeAudioOutputRouteConnected
CLDuetEventTypeBluetoothConnected
CLDuetEventTypeDeviceFirstWakeOfDay
CLDuetEventTypeForegroundApp
CLDuetEventTypeHomeKitAppView
CLDuetEventTypeHomeKitAccessory
CLDuetEventTypeHomeKitScene
CLDuetEventTypeNowPlaying
CLDuetEventTypeMicroLocations
%@/%@/%lu
com.apple.locationd.CLDuetMonitor
CLDuetMonitorSilo
+[CLDuetMonitor isSupported]_block_invoke
CLDuetMonitor: not supported on this platform because CoreDuet.framework is not present
registration != nullptr
-[CLDuetMonitor registerClient:forEvent:withPredicate:]
Added %{private}@ client to the list of listeners for event type %{private}ld with predicate %{private}@
self.registeredEvents[regId] == nullptr
-[CLDuetMonitor registerWithDuetForEvent:andPredicate:]
-[CLDuetMonitor registerWithDuetForEvent:andPredicate:]_block_invoke
Received callback for %{public}@
-[CLDuetMonitor stopMonitoringEvent:withPredicate:forClient:]
Client %{private}@ is not registered for event %{public}ld
-[CLDuetMonitor keypathForEvent:]
-[CLDuetMonitor predicateForEvent:withKeyPath:]
event != nullptr
-[CLDuetMonitor eventTypeFromNSNumber:]
eventType < CLDuetEventTypeCount && eventType >= CLDuetEventTypeUnknown
-[CLDuetMonitor notifyClient:ofEvent:withValue:]
-[CLDuetMonitor notifyClient:ofForegroundAppWithValue:]
#Warning The app dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetForegroundApp class
bundleId or launchReason were nil so not processing this notification
-[CLDuetMonitor notifyClient:ofHomeKitScene:]
#Warning The scene dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetHomeKitScene class
some of the expected keys were not found, so not processing this notification. %{private}@
-[CLDuetMonitor notifyClient:ofHomeKitAccessory:]
#Warning The accessory dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetHomeKitAccessory class
some of the expected keys were not found so not processing this notification. %{private}@
-[CLDuetMonitor notifyClient:ofHomeKitAppView:]
#Warning The app view dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetHomeKitAppView class
-[CLDuetMonitor notifyClient:ofNowPlaying:]
#Warning The Now Playing dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetNowPlaying class
(self.%@.value != NULL) AND (self.%@.value.%@ IN %@)
(self.%@.value != NULL) AND NOT (self.%@.value.%@ IN %@)
self.%@.value = %@
void CMLinearTemperatureFit::feedGyroTemperature(float)
Assertion failed: temperature != 3.40282347e+38F, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMLinearTemperatureFit.cpp, line 45,temperature,%f.
void CLHKHealthStoreAccessUtils::queryWorkouts(CFAbsoluteTime, CFAbsoluteTime, CLHKHealthStoreAccessUtils::WorkoutHandlerFunction)
void CLHKHealthStoreAccessUtils::queryWorkouts(CFAbsoluteTime, CFAbsoluteTime, CLHKHealthStoreAccessUtils::WorkoutHandlerFunction)_block_invoke
Workout query, %@
CLBarometerCalibrationSilo
BarometerCalibrationEnableFeature
BarometerCalibrationLogLoi
-[CLBarometerCalibration registerClient:forNotification:]
registerClient: notification %ld is not supported
Location: 
time,%f,lat,%f,long,%f,
-[CLBarometerCalibration logBuffers]
GPS: 
Pressure: 
time,%f,pressure,%f,temp,%f,
-[CLBarometerCalibration onOdometerNotification:data:]
received odometer notification, startTime %f, elevationAscended %u, elevationDescended %u, failure mode %u, source %u
BarometerWet
-[CLBarometerCalibration onMotionStateObserverNotification:data:]
motion state observer updates, time %f, activityType %d, predictedWorkoutType %d
inOutdoorWorkout %d
-[CLBarometerCalibration updateCompanionConnected:]
companion connected updated: %d
-[CLBarometerCalibration updateWetState]
wet state updated to %d
-[CLBarometerCalibration setupAltimeterReleaseTimer]_block_invoke
destructing Altimeter context
-[CLBarometerCalibration onVisit:]
received visit for altimeter, inVisit, %d, arrival date, %f, departure date, %f, current time, %f
deviceWet
isCompanionConnected
timeElapsedSinceLastClientRegistered_binned
-[CLBarometerCalibration fetchVisitStatusAtStart]_block_invoke
error fetching visits
retrieved visits, last visit type was, %d, lat, %f, lon, %f
-[CLBarometerCalibration fetchLoiFromId:atTimestamp:]_block_invoke
Received error when fetching LOI from visit, LOI id %@
LOI id %@, elevation, %f, uncertainty, %f, visit entry time, %f, current timestamp, %f
loiAltitudeError_binned
loiAltitudeUncertainty_binned
altitudeUncertainty_binned
LOI visit entry, timestamp, %f, current timestamp, %f, loi altitude, %f, loi altitude uncertainty, %f, altimeter, %f, altimeter uncertainty, %f
AbsoluteAltitudeEnabled
com.apple.Motion.Altimeter.RegisterClient
com.apple.Motion.Altimeter.VisitEntry
{array<std::deque<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>, 7>=[7{deque<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>>={__split_buffer<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *>>=^^v^^v^^v{__compressed_pair<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> **, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *>>=^^v}}Q{__compressed_pair<unsigned long, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>>=Q}}]}8@?0
bool CLMotionAlarmDatabase::isDbAccessible() const
Database is not accessible.
bool CLMotionAlarmDatabase::upsertAlarm(CMMotionAlarm *)
Unable to update alarm because bundleId or name is empty.
SELECT id, state, duration, type, repeats, bundleId, name FROM MotionAlarm
SELECT id, state, duration, type, repeats, bundleId, name FROM MotionAlarm WHERE bundleId = ?
NSArray<CMMotionAlarm *> *CLMotionAlarmDatabase::alarmsFromStatement(sqlite3_stmt *) const
Unable to iterate through all rows for getAllAlarms!
SELECT id, state, duration, type, repeats, bundleId, name FROM MotionAlarm WHERE id = ?
SELECT id, state, duration, type, repeats, bundleId, name FROM MotionAlarm WHERE 1 = 1 AND bundleId = ? AND name = ?
DELETE FROM MotionAlarm WHERE 1 = 1 AND bundleId = ? AND name = ?
void CLMotionAlarmDatabase::prepareDatabase()
Unable to prepare due to invalid database.
CREATE UNIQUE INDEX IF NOT EXISTS ix_MotionAlarm_bundeId_name ON MotionAlarm(bundleId, name)
Successfully created database
INSERT INTO MotionAlarm (state, duration, type, repeats, bundleId, name) VALUES (?, ?, ?, ?, ?, ?)
UPDATE MotionAlarm SET state = ?, duration = ?, type = ?, repeats = ? WHERE 1 = 1 AND id = ? AND bundleId = ? AND name = ?
state
repeats
void CLAttitudeDependentKFCalibrator::init()
RotationStability buffer not set.
virtual void CLAttitudeDependentKFCalibrator::setBias(const CLVector3d<float> &, const CLMotionTypeCompassCalibrationLevel &, const CLVector3d<float> &, const CLClientQuaternion *)
Could not set bias retrieved from database
setting bias (%.3f/%.3f/%.3f) level (%d)
void CLAttitudeDependentKFCalibrator::resetInternal(const CLVector3d<float> &, const CLMatrix3d<float> &, CLMotionTypeCompassCalibrationLevel)
reset internal. levels-data(%d %d %d), pScale=%.3f 
virtual void CLAttitudeDependentKFCalibrator::reset()
compass calibrator reset
void CLAttitudeDependentKFCalibrator::resetCalibration(const CLVector3d<float> &, const CLMatrix3d<float> &)
Resetting calibrator states.
bool CLAttitudeDependentKFCalibrator::resync(float, bool, bool, bool, float, float, float, const CLVector3d<float> &, float, float, float, const CLVector3d<float> &)
Resync after long coasting with mag drift. mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), Age(%d,%d)
DRIFT DETECTED. numBad=%d,s=%.3f,delH(%.3f,%d,%.3f), expectedVec (%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d),deltaTime(%.3f)
fBackupInfoSet(%d), syncAge(%d)
Likely bad resync. Backup.
RESYNC Rejected. numBad=%d,mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), syncAge(%d)
numBad(%d), delH(%.3f), coastVec(%.3f/%.3f/%.3f), expectedVec(%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d)
bool CLAttitudeDependentKFCalibrator::handleInterference(const CLVector3d<float> &, const CLVector3d<float> &, bool, bool)
Coasting vector not set.
Prolonged high magDiff. Likely bad calibration. Resetting.
Extremely high magnitude.  magDiff (%.3f), magnitude (%.3f), calibrated (%.3f/%.3f/%.3f), coastVector (%.3f/%.3f/%.3f),coastingTime,%.3f,magDiffVar,%.3f,resetInternal,%d
Likely bad database lookup. Resetting. 
******* scale(%.3f),cAge(%d), magDiff(%.3f), dHeading(%.3f), deltaAngle(%.3f), numBad(%d), calInc(%.3f), incDiffIsStable(%d)
Steep inclination. Likely bad interference or bad database lookup. Resetting. 
Interference is gone.
**INTERFERENCE-1 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
**INTERFERENCE-0 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
void CLAttitudeDependentKFCalibrator::handleDivergence(const CLVector3d<float> &)
Divergence!!! Resetting.
int CLAttitudeDependentKFCalibrator::calcCalibrationLevel(const CLVector3d<float> &)
new internal estimates (%.3f %.3f %.3f)
taking new estimates, Internal. fIsCoasting (%d)
new estimates denied, fIsCoasting (%d)
taking new estimates, reached database. (%d)
new esitmates disagree with database. (%d,%d,%.3f)
calibrated, first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
taking new estimates, fIsCoasting (%d)
estimates improved.(%.3f/%.3f/%.3f), numImprov=%d 
new estimates needed, fIsCoasting (%d)
first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
bool CLAttitudeDependentKFCalibrator::sanityCheck(unsigned int *, CLMotionTypeCompassCalibrationLevel, float &)
new estimates calculated, converged(%d %d %d) Var (%.3f %.3f %.3f), remain (%.3f), level (%d), num=%d 
void CLAttitudeDependentKFCalibrator::resetAfterCoasting()
Bad heading divergence for too long. Prompt user to re-calibrate.
Waiting too long for internal re-calibration. Prompt user.
Waiting too long for high magnitude interference to go away. Exit coasting.
Coasting for too long. Exit coasting.
virtual void CLAttitudeDependentKFCalibrator::referenceAttitudeChanged(bool, const CLMotionTypeMagneticField &)
fCoastingVecPrint: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f
virtual void CLAttitudeDependentKFCalibrator::addSample(const CLVector3d<float> &, const CLClientQuaternion *, const CFTimeInterval &)
Attitude data not set.
Compass-withFusion
Type,%s,Updating reference frame.
Updating during coasting, fIsResetInternal(%d)
BACKUP resync coasting vector
resync coasting vector. rotM,%.3f,rotV,%.3f
device status: (smooth static) = (%d %d), rotM,%.3f,rotV,%.3f, q.x,%.3f,q.y,%.3f,q.z,%.3f,q.w,%.3f)
coasting vector is mature, no more updating
numSamplesSkipped (%d), deltaQ (%.3f/%.3f/%.3f/%.3f), deltaReadingM (%.3f)
void CLAttitudeDependentKFCalibrator::setCalibrationValues()
bias.x,%.3f,bias.y,%.3f,bias.z,%.3f,scale.x,%.5f,scale.y,%.5f,scale.z,%.5f,extF.x,%.3f,extF.y,%.3f,extF.z,%.3f
void CLAttitudeDependentKFCalibrator::setCoastingVector(bool)
set coasting vector (%.3f/%.3f/%.3f), levels (%d %d) conv(%d %d %d) age (%d) syncAge (%d) DueTo (%d)
void CLAttitudeDependentKFCalibrator::enterCoasting()
enters coasting
void CLAttitudeDependentKFCalibrator::exitCoasting()
exits coasting
CLPlosMatcher::CLPlosMatcher(CLMapGeometryPtr, const std::string &)
PLOS:kLowestElevationInDegrees,%.2f,kTallestBuildingHeight,%.2f,kLargestDistance,%.2f
GpsForcePlos
PLOS,GpsForcePlos,%d
virtual bool CLPlosMatcher::match(CLMapCrumb &)
PLOS, cannot estimate nav mode, disabling
PLOS, non-pedestrian, not matching
PLOS: no mapGeometry!
PLOS: no geometry!
#Warning PLOS: buildingsWithinDistance,%lf returned false!
#Warning PLOS: buildings.size() %ld > 500. too many buildings. Aborting
PLOS: no candidate svs for time %{public}lf
#Warning PLOS: polyPoint == candidatePoint
PLOS: unexpected to not find SV, %{public}d in fSvPlosMap!
static std::tuple<double, double, double> CLPlosMatcher::getSearchParameters(const CLMapCrumb &)
#Warning PLOS: majorAxis,%lf < minorAxis,%lf
#Warning PLOS: Clamping majorAxis,minorAxis,%fm
optional.hpp
this->is_initialized()
+[CLSuggestedActionManager(IsSupported) isSupported]_block_invoke
%{public}s not supported on this device type
CLSuggestedActionManagerSilo
LogLegacyRadar
LogFile
LogFileDirectory
LogFilePrefix
LogFileFlush
ShowError
LogFence
LogBufferSize
LogShowUI
LogFileLevel
LogBufferLevel
LogConsoleLevel
LogStackLevel
LogLocations
LogLocationsFile
LogLocationsFlush
.log
com.apple.locationd.log.compression
vlog
CLLog.mm
newFullContentLength == fullContentLength
'\n' == buffer[fullContentLength - 1]
%s,%s,Time,%08.3f,Function,"%s",
%s,%s,Time,%08.3f,
Level
RotationEnabled
LogLevel
%s,%s,logging locations to %s%s
NOTICE
CLLog
 and flushing immediately
 no flush
%s,%s,logging locations to an internal buffer with capacity %d
.bz2
%s,%s,Failed to move aside log file %s (%d)
.log.bz2
%s/%s
Failed to delete log
%s,%s,Rotation path is too long, could not delete old logs.
%s,%s,Failed to write %s
%s,%s,could not open locations log %s, errno %d
Unplugged!
void CLLog::logHeader()
CoreLocation-%s
locationd was compiled on %s at %s
Oct 20 2021
01:03:27
%s @ system model %s / version %s
/usr/libexec/locationd @ system model %s / version %s
IOPlatformSerialNumber: %s
Begin settings dump (read at construction of CLSettings or upon darwin notification 'com.apple.locationd/prefs')
End settings dump
com.apple.timed
%s,%s,dumping internal buffer
LogNatalimetry
LogCalorimetry
/cache_encryptedC.db
cache
.plist.log
%s,%s,could not copy %s log
%s,%s,could not dump log file
%s,%s,Time,%08.3f,%d
0x%08lx %s + %lu
STACK
%s,%s,Time,%08.3f,%d
0x%08lx 0x%08lx + %lu
%s,%s,Time,%08.3f,%d
0x%08lx
PaceFusion_Epoch_Time
PaceFusion_Epoch_PedometerPace
PaceFusion_Epoch_PedometerPaceUncalibrated
PaceFusion_Epoch_SmoothOdometerPace
PaceFusion_Epoch_SmoothShortOdometerPace
PaceFusion_Epoch_LongMeanOdometerPace
PaceFusion_Epoch_ShortMeanOdometerPace
PaceFusion_Epoch_PaceResetTime
PaceFusion_Epoch_FinalFusedPace
PaceFusion_Epoch_OdometerPaceQuality
PaceFusion_Epoch_MeanPaceState
PaceFusion_Epoch_PaceFusionOutput
PaceFusion_Epoch_DoRequestPureGpsOdometerPace
PaceFusion_Epoch_IsPureGpsOdometerPaceAvailable
PaceFusion_Epoch_PureGpsOdometerPace
PaceFusion_Epoch_PureGpsOdometerPaceResetTime
double CLPedometerPaceFusion::computeFusedPace(CFAbsoluteTime, const CLExtendedStepCountEntry &, CLPedometerPaceFusion::PaceSignalQuality, const bool)
%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f
double CLPedometerPaceFusion::computeMeanPace(const T_buffer &, CFAbsoluteTime, CFAbsoluteTime) const [T_buffer = CLNatalieInput<CLOdometerEntry>]
Odometer failed to compute a mean pace.
double CLPedometerPaceFusion::getOdometerDistance(const T_buffer &, CFAbsoluteTime, CFAbsoluteTime) const [T_buffer = CLNatalieInput<CLOdometerEntry>]
Time didn't move! time,%{public}f
TCONV,mach_get_times failed
kern.wake_abs_time
bool CLUtils::LiveTimeConverter::getLastWakeUpMachAbsoluteTime(CFTimeInterval &)
TCONV,error occurred, no mib to wake_abs_time conversion
TCONV,mib filled to %zu
TCONV,Error occurred when get wake_abs_time,%{errno}d
TCONV,GetLastWakeUpMachAbsoluteTime success,machAbs,%{public}llu,floatInterval,%{public}.6lf
bool CLUtils::LiveTimeConverter::getLastWakeUpTime(CLUtils::WakeUpTime &)
TCONV,Getting last wake up time failed
TCONV,invalid deltaContAbsSec
TCONV,invalid deltaCfAbsSec
TCONV,mach_get_times,machAbs,%{public}llu,machCont,%{public}llu,tv_sec,%{public}ld,tv_nsec,%{public}ld,deltaContAbs,%{public}.6lf,deltaCfAbs,%{public}.6lf,lastWakeAbs,%{public}.6lf,machNow,%{public}.6lf,machContNow,%{public}.6lf,sysNow,%{public}.6lf
bool CLUtils::LiveTimeConverter::isMachTimeAfterCachedLastWakeUpTime(const CFTimeInterval &)
TCONV,Cannot get wakeTime or MachTime before sleep,machAbs,%{public}.6lf,wakeTime,%{public}.6lf
bool CLUtils::LiveTimeConverter::deltaMachContinuousMachAbsolute_RealTime(CFTimeInterval &)
TCONV,UpdateLastWakeUpTime failed
bool CLUtils::LiveTimeConverter::deltaCFAbsTimeMachAbsTime_RealTime(CFTimeInterval &)
bool CLUtils::LiveTimeConverter::convertMachAbsoluteToMachContinuous_RealTime(const CFTimeInterval &, CFTimeInterval &)
TCONV,Failed in getting the offset between mach continuous time and mach absolute time
TCONV,Failed in getting the offset between CF time and mach time
bool CLUtils::LiveTimeConverter::convertCFAbsoluteToMachAbsolute_RealTime(const CFAbsoluteTime &, CFTimeInterval &)
void CLUtils::cleanupFilesOlderThan(NSString *, CFAbsoluteTime)
Deleting all files in %{private}@
Cleaning up files older than %.0f [s] in %{private}@
skipping directory %@
void CLVO2MaxPreprocessor::logSinglePairStats(const CLVO2MaxPreprocessor::PairStats &, const CLVO2MaxPreprocessor::PairStats &, const VO2MaxInput &, const double) const
pairNumber,%d,startTime,%f,mets,%f,hr,%f,hrConfidence,%f,gradeType,%d,grade,%f,hasGPS,%d,hasStrideCal,%d,metSource,%d,workoutType,%d,warmupOK,%d,gradeOK,%d,metDeltaOK,%d,metsAboveMin,%d,metSourceOK,%d,hrOK,%d,cadence,%f,workoutLengthOK,%d,pace,%f,paceOK,%d,strollerOK,%d,percentGradeSigma,%.6f,percentWalkingOK,%d,metsAboveAdaptiveAlgMin,%d,pairOKForClustering,%d,pairOKForAdaptiveModel,%d,isStroller,%d
virtual CLSwimDistanceEstimator::Estimates CLSwimDistanceEstimatorOpenWater::estimate() const
Session distance estimate,odometer,%lf,generic stroke lengths,%lf
CLCircularLogBuffer
virtual CLMetsInfo CLCalorieWheelchairPushModel::computeMETS(const CLNatalieModelInput &)
WheelchairPush, computeTime, %f, metsFromPushes, %.1f, Push Count, %d, pushEM, %.1f
virtual CLMetsInfo CLCalorieYogaModel::computeMETS(const CLNatalieModelInput &)
Yoga,metsWR,%f,metsHR,%f,truthMets,%f,truthMetsSrc,%d,userMets,%f,userMetsSrc,%d
LogSensorFusion
CLSensorFusionMekf::CLSensorFusionMekf(const CFTimeInterval &, const CFTimeInterval &, bool)
Doing crude accel measurement update.
rotBufferSize, %zu, accelBufferSize, %zuu, peakCount, %d, fMaxStd, %.3f
gyroDt, %.4f, doAccelCheck, %d
virtual void CLSensorFusionMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)
omegaMag6, %.3f, omega, %.3f, %.3f, %.3f
[AppleQuaternion] x,%f,y,%f,z,%f,w,%f,timestamp,%f
virtual void CLSensorFusionMekf::feedGyroBias(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &)
[Bias,Var] bias.x,%f,bias.y,%f,bias.z,%f,var.x,%f,var.y,%f,var.z,%f
virtual void CLSensorFusionMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)
[Accelerometer6] x,%.4f,y,%.4f,z,%.4f,lpf, %.4f, %.4f, %.4f, timestamp,%lf
[RotationRate6X] %.3f, %.3f, %.3f, %.3f, %.3f
rotating and going through.
it's been too long. go through.
grabing gravity, %.4f, %.4f, %.4f
std, %.3f, %.3f, %.3f, mag, %.3f, dot, %.3f, leftover, %.3f
sum, %.3f, %.3f, %.3f, dot, %.3f, leftover, %.3f
===========Skip ahead.
Skip ahead------.
Taking another look.
using mean accel
accM, (%.4f, %.4f, %.4f), mag, %.3f
Doing some crude updates to catch up.
[KalmanFilterStates] %f,%f,%f,%f,%f,%f,%f
IOHIDCompasssResetDAC
virtual CLMetsInfo CLNatalieHighIntensityModel::computeMETS(const CLNatalieModelInput &)
High Intensity, CR DT Regression, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, METS, %f
bool CLVO2MaxEstimationDeescalator::checkMaxTimeLimitReached() const
Deescalation event for background VO2Max estimation, max time limit reached
bool CLVO2MaxEstimationDeescalator::checkIfIndoors() const
Deescalation event for background VO2Max estimation, location is not outdoors
bool CLVO2MaxEstimationDeescalator::checkVO2MaxSessionStats() const
Deescalation event for background VO2Max estimation, session stats, duration,%.3f,totalBadSeconds,%.3f,preconditionFailed,%d
bool CLVO2MaxEstimationDeescalator::checkDataStatsInvalidity() const
Deescalation event for background VO2Max estimation, pair stats, countTotalSamples,%d,countBadHR,%d,countBadWR,%d,countBadGPS,%d,countBadSamples,%d
void CLVO2MaxEstimationDeescalator::feedVO2MaxSessionStats(const VO2MaxSessionStats &)
VO2SessionStatus,duration,%.3f,totalGoodSeconds,%.3f,totalBadSeconds,%.3f,timeElapsed,%.3f,preConditionFailed,%d
empty
size
nonhex
static CLMacAddress CLMacAddress::newFromMalformedMac(const std::string &, const std::string &)
#Warning malformed mac address error, %{public}s, %{private}s
ff:ff:ff:ff:ff:ff
multibyte
colons
-[CLAvailabilityRegionChangeMonitor initWithSilo:andMonitorRegion:andOnRegionChangedCallback:]
#availabilityregionmonitor, monitor initialize, country code, %{private}@, token, %{public}d
-[CLAvailabilityRegionChangeMonitor onGeoCountryCodeChangeNotification:andMonitorRegion:]
#availabilityregionmonitor, last, %{private}@, new, %{private}@, token, %{public}d, entered, %{private}d, exited, %{private}d
void CLWorkoutPredictorSourceBuffer<CLCatherineData>::logItem(const CLCatherineData &) [T = CLCatherineData]
HeartRate,%f,hr,%f,conf,%f
void CLWorkoutPredictorSourceBuffer<CLStepCountEntry>::logItem(const CLStepCountEntry &) [T = CLStepCountEntry]
Steps,%f,pace,%f,cadence,%f,count,%d
void CLWorkoutPredictorSourceBuffer<CLExtendedStepCountEntry>::logItem(const CLExtendedStepCountEntry &) [T = CLExtendedStepCountEntry]
ExtendedSteps,%f,firstStepTime,%f,lastStepTime,%f,rawPace,%f,incrementalSteps,%u,odometerSpeed,%f
void CLWorkoutPredictorSourceBuffer<CLOdometerEntry>::logItem(const CLOdometerEntry &) [T = CLOdometerEntry]
Odometer,%f,rawSpeed,%f,speed,%f,speedAccuracy,%f,startTime,%f
void CLWorkoutPredictorSourceBuffer<CLElevationChangeEntry>::logItem(const CLElevationChangeEntry &) [T = CLElevationChangeEntry]
Elevation,%f,ascended,%d,descended,%d,gradeType,%d,verticalSpeed,%f,startTime,%f,source,%d
void CLWorkoutPredictorSourceBuffer<CLWorkoutPredictorWatchPressure>::logItem(const CLWorkoutPredictorWatchPressure &) [T = CLWorkoutPredictorWatchPressure]
WatchPressure,startTime,%f,averagePressure,%f,failureState,%d
void CLWorkoutPredictorSourceBuffer<CLMotionCoprocessorInterface::MotionState>::logItem(const CLMotionCoprocessorInterface::MotionState &) [T = CLMotionCoprocessorInterface::MotionState]
Activity,%f,type,%u,standing,%d,angeX,%f,vectorMag,%f,strokeAmp,%f,strokePwr,%f,strokeFreq,%f,machineFreq,%f,pushVectorMag,%f,epochType,%d
void CLWorkoutPredictorSourceBuffer<CLWorkoutClassifier_Type::CLWorkoutClassifierResult>::logItem(const CLWorkoutClassifier_Type::CLWorkoutClassifierResult &) [T = CLWorkoutClassifier_Type::CLWorkoutClassifierResult]
Activity2,%f,result,%lu,startTime,%f
void CLWorkoutPredictorSourceBuffer<CLWorkoutPredictorTurnDetector::Turn>::logItem(const CLWorkoutPredictorTurnDetector::Turn &) [T = CLWorkoutPredictorTurnDetector::Turn]
Turn,%f,%f,%f,%f
void CLWorkoutPredictorSourceBuffer<CLSwimEntry>::logItem(const CLSwimEntry &) [T = CLSwimEntry]
Swim,startTime,%f,strokes,%d,style,%d
void CLWorkoutPredictorSourceBuffer<CLExerciseMinuteData>::logItem(const CLExerciseMinuteData &) [T = CLExerciseMinuteData]
ExerciseMinute,%.3f
void CLWorkoutPredictorSourceBuffer<CLCyclingStateDetector_Type::CyclingResult>::logItem(const CLCyclingStateDetector_Type::CyclingResult &) [T = CLCyclingStateDetector_Type::CyclingResult]
CyclingState,%.3f,state,%d
void CLWorkoutPredictorSourceBuffer<CLMotionCoprocessorInterface::Tier1CyclingFeatures>::logItem(const CLMotionCoprocessorInterface::Tier1CyclingFeatures &) [T = CLMotionCoprocessorInterface::Tier1CyclingFeatures]
Tier1CyclingFeatures,%.3f,isArmConstrained,%d,accelXPowerSum,%f,grav90th_100Hz,%f,cyclingProbability,%f,pedEnergyVertical,%f
virtual CLRangingSubscription::~CLRangingSubscription()
iB: ending metric session (BeaconRangingSession) for %s
void CLRangingSubscription::onBTLERangeNotification(int, const CLBTLERangeManager_Type::Notification &, const CLBTLERangeManager_Type::NotificationData &)
#Warning Unknown range notification received, %{public}d
iB: Unable to find ranged region,%{private}s.
#Warning Sending kCLConnectionMessageRangingError for region,%{private}s with error,%{public}d.
kCLConnectionMessageBeaconsKey
@iB: Sending kCLConnectionMessageRanging for region,%{private}s, with beacons,%{public}d.
kCLConnectionMessageRegionsKey
kCLConnectionMessageIdentifierKey
void CLRangingSubscription::handleRequestRanging(bool, const CLNameValuePair &)
Client %{public}s is attempting ranging as a proxy service to %{public}s
com.apple.locationd.ranging
Ranging any region,%{public}s, requires an entitlement.
Unable to parse ranged region,%{public}d.
#Warning Unable to subscribe to ranging.
void CLRangingSubscription::startRanging_nl()
Starting ranging for regions,%lu.
iB: start metric session (BeaconRangingSession) for %s
iB: update ranged regions (BeaconRangingSession) for %s
#Warning There are no regions to range.
void CLRangingSubscription::stopRanging_nl()
Stopping ranging.
CLRangingSubscription::onBTLERangeNotification
CLCyclingStateDetector_Type::CyclingResult CLCyclingStateDetector::determineCyclingState(const CLWorkoutPredictorInputs &, const CLWorkoutPredictorInputs::Items &)
CyclingStateDetector,state,%d,hasGPS,%d,hasStep,%d,hasElevation,%d,hasHR,%d,stepsRaw,%u,stepsQual,%u,gpsSpeed,%f,rawGPSSpeed,%f,hr,%f,hrConf,%f,grade,%f,pedSpeed,%f,wrHrMetDiscordanceStatus,%d,hasTier1,%d,tier1Type,%d,hasStepsQual,%d,cycleState,%d,isArmConstrained,%d,tier1CyclingProbability,%f,accelXPowerSum,%f,grav90th_100Hz,%f,avgWRMets,%f,HRMets,%f,fhr,%f,isDriving,%f,roadNoise,%f,gpsDeltaDistanceState,%d,gpsDeltaDist,%f,verticalSpeed,%f,vehicularAccel,%d,speedBufferLen,%zu,tier1Smooth,%f,pedEnergyVertical,%f
StatCycleModelMetsScale
virtual CLMetsInfo CLNatalieStationaryCycleModel::computeMETS(const CLNatalieModelInput &)
Stationary Cycle, Begin Time, %f, End Time, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, duration(s), %f, weight(kg), %f, METS, %f, HRstaleness, %f
Stationary Cycle, computeTime, %.3f, hrMets, %f, fmMets, %f, userMets, %f, Duration, %f, truthMets, %f
STATUS,SENSOR,Time,%.3lf,Type,AccelOscarEmu,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,GyroOscarEmu,x,%20.20f,y,%20.20f,z,%20.20f,sampleNum,%d,fsync,%d,timestamp,%20.20lf
i-index(%{public}d)!=kSize(%{public}d)
virtual bool CLBinaryLogTypes::NonlinearBiasFit::decode(const uint8_t *, const int, const int)
virtual bool CLBinaryLogTypes::FallConfig::decode(const uint8_t *, const int, const int)
virtual bool CLBinaryLogTypes::FallStats::decode(const uint8_t *, const int, const int)
virtual bool CLBinaryLogTypes::FallState::decode(const uint8_t *, const int, const int)
virtual bool CLBinaryLogTypes::FallFalsePositiveSuppressionFeatures::decode(const uint8_t *, const int, const int)
STATUS,SENSOR,Time,%.3lf,Type,GyroBias,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d
STATUS,SENSOR,Time,%.3lf,Type,GyroBiasFit,slope.x,%20.20f,slope.y,%20.20f,slope.z,%20.20f,intercept.x,%20.20f,intercept.y,%20.20f,intercept.z,%20.20f, lastMiniCal,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,GyroDt,dt,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,Compass,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,CompassAlignment,compassJustAlignedToStableField,%d,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,DeviceMotion,q.x,%20.20f,q.y,%20.20f,q.z,%20.20f,q.w,%20.20f,userAccel.x,%20.20f,userAccel.y,%20.20f,userAccel.z,%20.20f,rotationRate.x,%20.20f,rotationRate.y,%20.20f,rotationRate.z,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,magneticFieldCalibrationLevel,%d,heading,%.3f,trueheading,%.3f,accuracy,%.3f,variant,%d,mode,%d,clientID,%#02x,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,visualLocalizationCorrection,%d,initialized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,north,%d,visualLocalization,%d,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,MotionStateUpdate,motionStateUpdate:Motion,%d,conf,%d,Mounted,%d,MountedConf,%d,exitState,%d,turn,%d,isVehicular,%d,isMoving,%d,seq,%d,startTime,%f,timestamp,%f,startTimeUL,%llu,nowUL,%llu -- caltype,%d,vm,%f,standing,%d,machinefrequency,%f,strokefrequency,%f,strokeAmplitude,%f,strokepower,%f
STATUS,SENSOR,Time,%.3lf,Type,Pressure,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,PressureOscarEmu,pressure,%20.20f,temperature,%20.20f,timestamp,%20.20lf
STATUS,SENSOR,Time,%.3lf,Type,PressureFilteredNoTemperature,pressure,%20.20f,timestamp,%llu
STATUS,SENSOR,Time,%.3lf,Type,CompassCalibration,bias.x,%.8f,.y,%.8f,.z,%.8f,scale.x,%.8f,.y,%.8f,.z,%.8f,quality,%.8f,cost,%.8f,coverage,%.8f,earthDiffRatio,%.8f,pose.x,%.8f,.y,%.8f,.z,%.8f,level,%d,timestamp,%20.20f
STATUS,SENSOR,Time,%.3lf,Type,BTConnection,startTime,%.3lf,endTime,%.3lf,connected,%d
STATUS,SENSOR,Time,%.3lf,Type,SessionOverride,sessionType,%d,timestamp,%.3lf
STATUS,SENSOR,Time,%.3lf,Type,CLDeviceMotion,q.x,%20.20f,q.y,%20.20f,q.z,%20.20f,q.w,%20.20f,userAccel.x,%20.20f,userAccel.y,%20.20f,userAccel.z,%20.20f,rotationRate.x,%20.20f,rotationRate.y,%20.20f,rotationRate.z,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,magneticFieldCalibrationLevel,%d,timestamp,%20.20f,doingBiasEstimation,%d,doingYawCorrection,%d,type,%d
temperatures,%f,%f,%f,%f,%f,%f,%f,overlap,%f,error,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d,%03d
STATUS,SENSOR,Time,%.3lf,Type,CLNonlinearGyroBiasFit,fits,%s
STATUS,SENSOR,Time,%.3lf,Type,OnsetHeartRateData,dataSource,%u,interpolation,%u,HeartRate,%f,confidence,%f,error,%d,timestamp,%.3lf,startTime,%.3lf,sinceLastGood,%.3lf,mode,%u
STATUS,SENSOR,Time,%.3lf,Type,StreamingHeartRateData,dataSource,%u,interpolation,%u,HeartRate,%f,confidence,%f,error,%d,timestamp,%.3lf,startTime,%.3lf,sinceLastGood,%.3lf,mode,%u
STATUS,SENSOR,Time,%.3lf,Type,Odometer,startTime,%.3lf,accuracy,%.3lf,distance,%.3lf,gpsAltitude,%.3lf,speed,%.3lf,rawSpeed,%.3lf,odometer,%.3lf,gpsSpeedAccuracy,%.3lf,timestampGPS,%.3lf,origin,%d,quality,%d
STATUS,SENSOR,Time,%.3lf,Type,StrideCalBin,bin,%d,begin,%.3lf,end,%.3lf,state,%d,kValue,%.3lf
STATUS,SENSOR,Time,%.3lf,Type,CaloriemetryPauseEvent,pause,%d
STATUS,SENSOR,Time,%.3lf,Type,MetsInfo,mets,%f,metsHR,%f,metsWR,%f,source,%u,metsDiff,%f
STATUS,SENSOR,systemHardware,%d,defaultsUserStudyFallStatsEnabled,%d,defaultsUserStudyPressureDataCollection,%d,defaultsIsSensorRecordingEnabled,%d,defaultsDetectorEnabled,%d,defaultsAnomalyMotionInternalTest,%d,spuConfigSensorTestModeEnabled,%d,spuConfigSensorRecordingEnabled,%d,spuConfigLastReplyAopTimestamp,%llu,spuConfigFallStatsMode,%d,spuConfigSensorRecordingActive,%d,spuConfigSimulateEvent,%d,spuConfigUserStudyPressureDataCollection,%d,spuConfigDetectorEnabled,%d,spuConfigSensorTestModeEnabled,%d
buffer too short to host all data (line:%i)
LOG,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,operatingMode,%d,aopTsNow,%llu,aopTsSensor,%llu,peakTimestamp,%llu,fallType,%hhd,isFall,%hhu,isNearFall,%d,simulated,%hhu,crown,%hhd,seq,%u,trialCount,%u
LOG,Time,%.3lf,Type,FallStatsFeatures,timestamp,%f,version,%d,operatingMode,%d,aopTsNow,%llu,aopTsSensor,%llu,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,maxAccelNorm,%f,accelPathLength,%f,minInertialZ,%f,minInertialZHighFreq,%f,crownVariance,%f,gravityVariance,%f,medianAbsGravityY,%f,abruptGravityChangeAngle,%f,jerkVectorMagMax,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,poseAtImpact,%f,tiltAngle,%f,swingAngle,%f,pathLengthHarmonicMean,%f,pathLengthDecorrelation,%f,pathLengthDelaySpread,%f,accelPathLengthWithPeak,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f,extrapolatedMaxMinusMin,%f,extrapolatedMaxAccelNorm,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f,extrapolatedMaxMinusMin,%f,extrapolatedMaxAccelNorm,%f,poseAtImpact,%f,tiltAngle,%f,swingAngle,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f,extrapolatedMaxMinusMin,%f,extrapolatedMaxAccelNorm,%f,poseAtImpact,%f,tiltAngle,%f,swingAngle,%f,isNearFall,%d
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f,extrapolatedMaxMinusMin,%f,extrapolatedMaxAccelNorm,%f,poseAtImpact,%f,tiltAngle,%f,swingAngle,%f,isNearFall,%d,pathLengthHarmonicMean,%f,pathLengthDecorrelation,%f,pathLengthDelaySpread,%f,accelPathLengthWithPeak,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f,extrapolatedMaxMinusMin,%f,extrapolatedMaxAccelNorm,%f,poseAtImpact,%f,tiltAngle,%f,swingAngle,%f,isNearFall,%d,pathLengthHarmonicMean,%f,pathLengthDecorrelation,%f,pathLengthDelaySpread,%f,accelPathLengthWithPeak,%f,minInertialZHighFreq,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f,extrapolatedMaxMinusMin,%f,extrapolatedMaxAccelNorm,%f,poseAtImpact,%f,tiltAngle,%f,swingAngle,%f,isNearFall,%d,pathLengthHarmonicMean,%f,pathLengthDecorrelation,%f,pathLengthDelaySpread,%f,accelPathLengthWithPeak,%f,minInertialZHighFreq,%f,operatingMode,%d
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f,extrapolatedMaxMinusMin,%f,extrapolatedMaxAccelNorm,%f,poseAtImpact,%f,tiltAngle,%f,swingAngle,%f,isNearFall,%d,pathLengthHarmonicMean,%f,pathLengthDecorrelation,%f,pathLengthDelaySpread,%f,accelPathLengthWithPeak,%f,minInertialZHighFreq,%f,operatingMode,%d,gravityVariance,%f,crownVariance,%f
STATUS,SENSOR,Time,%.3lf,Type,FallStats,timestamp,%f,version,%d,seq,%u,trialCount,%u,crown,%hhd,aopTsNow,%llu,aopTsSensor,%llu,magMax,%f,xMin,%f,xMax,%f,yMin,%f,yMax,%f,zMin,%f,zMax,%f,xZCTime,%f,yZCTime,%f,zZCTime,%f,jerkVectorMagMax,%f,xJerkScalarMagMax,%f,yJerkScalarMagMax,%f,zJerkScalarMagMax,%f,peakTimestamp,%llu,accelPathLength,%f,minInertialZ,%f,angleChangePreImpact,%f,angleChangePostImpact,%f,maxAngleChangePreImpact,%f,maxAngleChangePostImpact,%f,sumDeltaAngles,%f,posteriorRatio,%f,fallType,%hhd,isFall,%hhu,simulated,%hhu,maxMinusMin,%f,maxAccelNorm,%f,extrapolatedMaxMinusMin,%f,extrapolatedMaxAccelNorm,%f,poseAtImpact,%f,tiltAngle,%f,swingAngle,%f,isNearFall,%d,pathLengthHarmonicMean,%f,pathLengthDecorrelation,%f,pathLengthDelaySpread,%f,accelPathLengthWithPeak,%f,minInertialZHighFreq,%f,operatingMode,%d,gravityVariance,%f,crownVariance,%f,medianAbsGravityY,%f,abruptGravityChangeAngle,%f
STATUS,SENSOR,Time,%.3lf,Type,FallState,timestamp,%f,aopTsNow,%llu,aopTsSensor,%llu,isFall,%d,state,%d,response,%d,resolution,%d
STATUS,SENSOR,Time,%.3lf,Type,FallState,timestamp,%f,aopTsNow,%llu,aopTsSensor,%llu,isFall,%d,state,%d,response,%d,resolution,%d,sosCallTimestamp,%f,sosState,%d
STATUS,SENSOR,Time,%.3lf,Type,FallState,timestamp,%f,aopTsNow,%llu,aopTsSensor,%llu,isFall,%d,state,%d,response,%d,resolution,%d,sosCallTimestamp,%f,sosState,%d,fallAlertSentFromReferee,%d
unsupported
FallDataAccel800
approxAopTs
FallDataGyro200
aopTs
FallDataHgal
STATUS,SENSOR,Time,%.3lf,Type,%s,timestamp,%f,%s,%llu,x,%f,y,%f,z,%f
FallDataQuaternion6
STATUS,SENSOR,Time,%.3lf,Type,%s,timestamp,%f,%s,%llu,qx,%f,qy,%f,qz,%f,qw,%f
STATUS,SENSOR,Time,%.3lf,Type,FallWristState,timestamp,%f,notificationTimestamp,%llu,onWrist,%d,onWristSensor,%d,onWristConfidence,%d,isOnCharger,%d,isForcedOnWristEnabled,%d,isWristDetectionEnabled,%d
STATUS,SENSOR,Time,%.3lf,Type,FallFalsePositiveSuppressionFeatures,timestamp,%f,aopTsNow,%llu,aopTsSensor,%llu,aopTsImpact,%llu,seq,%d,sumHighQPeaksInHighFreqFFT,%f,sumHighQPeaksInLowFreqFFT,%f,sumHighQPeaksInDecLowFreqFFT,%f,nPeaks,%i,normalizedIQR,%f,repetitiveMotion,%d,version=%d,repetitiveMotionStartTs,%llu,repetitiveMotionEndTs,%llu
STATUS,SENSOR,Time,%.3lf,Type,FallFalsePositiveSuppressionFeatures,timestamp,%f,aopTsNow,%llu,aopTsSensor,%llu,aopTsImpact,%llu,seq,%d,sumHighQPeaksInHighFreqFFT,%f,sumHighQPeaksInLowFreqFFT,%f,sumHighQPeaksInDecLowFreqFFT,%f,nPeaks,%i,normalizedIQR,%f,repetitiveMotion,%d,version=%d
STATUS,SENSOR,Time,%.3lf,Type,FallFalsePositiveSuppressionFeatures,timestamp,%f,aopTsNow,%llu,aopTsSensor,%llu,aopTsImpact,%llu,seq,%d,sumHighQPeaksInHighFreqFFT,%f,sumHighQPeaksInLowFreqFFT,%f,sumHighQPeaksInDecLowFreqFFT,%f,nPeaks,%i,normalizedIQR,%f,version=%d
STATUS,SENSOR,Time,%.3lf,Type,StepCadenceToStrideLengthBin,bin,%d,begin,%.3lf,end,%.3lf,state,%d,strideLength,%.3lf
STATUS,SENSOR,Time,%.3lf,Type,MotionLoiData,longitude,%f,latitude,%f,departureDate,%.3lf,arrivalDate,%.3lf,horizontalAccuracy,%.3lf,confidence,%d
STATUS,SENSOR,Time,%.3lf,Type,OdometerWithAltitudeAndRadians,startTime,%.3lf,accuracy,%.3lf,distance,%.3lf,gpsAltitude,%.3lf,speed,%.3lf,rawSpeed,%.3lf,odometer,%.3lf,gpsSpeedAccuracy,%.3lf,timestampGPS,%.3lf,origin,%d,quality,%d,groundAltitude,%.3lf,groundAltitudeUncertainty,%.3lf,smoothedGPSAltitude,%.3lf,smoothedGPSAltitudeUncertainty,%.3lf,gpsCourseRadians,%.3lf,gpsCourseAccuracy,%.3lf
Below 30mph
Above 30mph
Undefined
0 to 15mph
15 to 30mph
30 to 45mph
45 to 60mph
Above 60mph
getSize
CLBinaryLogTypes.h
false && "changing version requires setting kSize accordingly"
bool CLBinaryLogTypes::FallSensorData<3>::decodeSubclassObject(const uint8_t *, const int, const int, CLBinaryLogTypes::LogType) [N = 3]
bool CLBinaryLogTypes::FallSensorData<4>::decodeSubclassObject(const uint8_t *, const int, const int, CLBinaryLogTypes::LogType) [N = 4]
sessionId
inputs
virtual CLMetsInfo CLCalorieOutdoorWheelchairModel::computeMETS(const CLNatalieModelInput &)
OutdoorWheelchair, beginTime, %f, endTime, %f, duration(s), %f,gpsSpeed,%.2f, gpsAvail, %d, elevAvail, %d, pushVM,%.1f, verticalSpeed, %.3f, gradeType, %d, metsFromGps,%.1f, metsFromPushes, %.1f, mets, %.1f
const T &CMQueue<CMOQuaternion>::operator[](const size_t) const [T = CMOQuaternion]
CLDeviceMotionAWDAggregator::CLDeviceMotionAWDAggregator()
Starting up CLDeviceMotionAWDAggregator
void CLDeviceMotionAWDAggregator::updateCalibrationStats(const CMMotionCoprocessorReply::CompassCalibration)
Received compass saturation,%d,timestamp,%f,meanDeltaTimeSaturations,%d
void CLDeviceMotionAWDAggregator::createCache(const CLDaemonStats_Type::CompassSaturations &)
Creating daemon cache for AWD CompassSaturations metric
CompassSaturations
void CLDeviceMotionAWDAggregator::loadCache(CLDaemonStats_Type::CompassSaturations &)
Loading daemon cache for Compass Saturations AWD metrics
bool CLDeviceMotionAWDAggregator::loadCache(CLDaemonStats_Type::CompassSaturations &, NSDictionary *)
saturations,%d,meanTimeMsec,%d,intensity,[%d %d],maxQuality,%f,deltaBias,%d,deltaRadius,%d,attachments,%d
Failed to load cache for AWD metrics %{private}@
void CLDeviceMotionAWDAggregator::storeCache(const CLDaemonStats_Type::CompassSaturations &)
Saving daemon cache for CompassSaturations AWD metrics
#Warning daemon cache does not exist!
void CLDeviceMotionAWDAggregator::createCache(const CLDaemonStats_Type::MotionGyroDaily &)
Creating daemon cache for AWD MotionGyroDaily metric
MotionGyroDaily
void CLDeviceMotionAWDAggregator::loadCache(CLDaemonStats_Type::MotionGyroDaily &)
Loading daemon cache for MotionGyroDaily AWD metrics
bool CLDeviceMotionAWDAggregator::loadCache(CLDaemonStats_Type::MotionGyroDaily &, NSDictionary *)
magnitude,%d,activeMins,%d
void CLDeviceMotionAWDAggregator::storeCache(const CLDaemonStats_Type::MotionGyroDaily &)
Saving daemon cache for MotionGyroDaily AWD metrics
void CLDeviceMotionAWDAggregator::newCoverAttach()
New cover attachment,total,%d
static void CLDeviceMotionAWDAggregator::onCoverState(const bool *, void *)
Cover open,%d
static void CLDeviceMotionAWDAggregator::onKeyboardState(const bool *, void *)
Keyboard attached,%d
NumSaturations
BetweenSaturations
Intensities
MaxQuality
DeltaCalibrations
NumCoverAttach
PreviousCalibration
CurrentCalibration
PreviousSaturationTime
SumDeltaSaturations
GyroMagnitude
ActiveMins
uint16_t(header.endian)
uint16_t(header.headerLen)
header.warnVersion
uint16_t(header.xtraVersion)
header.cksum
header.fileSize
header.fileGpsWeek
header.fileMsec
header.dataGpsWeek
header.dataGpsMsec
uint16_t(header.lengthOfFitIntervalsInHours)
uint16_t(header.numFitGps)
uint16_t(header.contentMask)
header.glonassGpsWeek
header.glonassGpsMsec
uint16_t(header.numHoursInGloFitInterval)
uint16_t(header.numGloFits)
header.sp3file
header.sp3fileglonass
uint16_t(alm.prn)
uint16_t(alm.health)
alm.eccentircity
uint32_t(alm.toa)
alm.deltai
alm.omegadot
alm.sqrtA
alm.omega0
alm.omegaArgPer
alm.M0
alm.Af0
alm.Af1
alm.weekNumber
uint32_t(alm.prn)
uint32_t(alm.health)
alm.toa
uint16_t(alm.svSlotNumber)
uint16_t(alm.svType)
alm.tau_na
alm.longAsending
alm.inclCorrect
alm.orbitEcc
alm.perigee
alm.firstAscend
alm.dracCorrect
uint16_t(alm.dracRate)
uint16_t(alm.freqNum)
alm.nan4
alm.dracRate
int16_t(alm.freqNum)
alm.na
alm.n4
gpsalm.prn
bool CLParseXtra::readGpsAlmanac(std::istream &, CLParseXtra::GpsAlmanacInt &, CLParseXtra::Endian)
#Warning failed to read [%{public}s]
gpsalm.health
gpsalm.eccentircity
gpsalm.toa
gpsalm.deltai
gpsalm.omegadot
gpsalm.sqrtA
gpsalm.omega0
gpsalm.omegaArgPer
gpsalm.M0
gpsalm.Af0
gpsalm.Af1
gpsalm.weekNumber
gloalm.health
bool CLParseXtra::readGlonassAlmanac(std::istream &, CLParseXtra::GlonassAlmanacInt &, CLParseXtra::Endian)
gloalm.svType
gloalm.svSlotNumber
gloalm.tau_na
gloalm.longAsending
gloalm.inclCorrect
gloalm.orbitEcc
gloalm.perigee
gloalm.firstAscend
gloalm.dracCorrect
gloalm.dracRate
gloalm.freqNum
gloalm.nan4
bool CLParseXtra::readXtraHeader(std::istream &, CLParseXtra::XtraHeader &)
#Warning, PLOS: can't open file 
#Warning PLOS: endian
header.headerLen
header.xtraVersion
header.lengthOfFitIntervalsInHours
header.numFitGps
header.contentMask
header.numHoursInGloFitInterval
header.numGloFits
#Warning PLOS: sp3file
#Warning PLOS: sp3fileglonass
#Warning PLOS: header
bool CLParseXtra::readXtraData(std::istream &, CLParseXtra::GpsAlmanacXtraVector &, CLParseXtra::GlonassAlmanacXtraVector &, CLParseXtra::XtraHeader &)
#Warning PLOS_XTRA: header
PLOS: eof
#Warning PLOS: id
#Warning PLOS: id,%{public}d,dataSize,%{public}d
#Warning PLOS: GPS ALM
GpsAlmancInt:
#Warning PLOS: GLO ALM
GlonassAlmancInt:
CLParseXtra::CLParseXtra(std::string)
PLOS: seting xtra file %{public}s
void CLParseXtra::parse()
PLOS: XTRA: fPopulated,%{public}d,fParseError,%{public}d. nothing to do
#Warning XTRA: can't open [%{public}s]
#Warning PLOS: failed to parse [%{public}s]
Xtraheader:
PLOS:%{public}s
GpsAlmanac:
GlonassAlmanac:
std::vector<CLParseXtra::SvInfo> CLParseXtra::getVisibleSvs(const double, const double *, const float)
gpsWeek,%{public}d,gpsSec,%{public}d,gloDay,%{public}d,gloSec,%{public}lf
PLOS:svid,%{public}d,el,%{public}.2lf,az,%{public}.2lf,retval,%{public}d
static bool CLParseXtra::read_from_file(std::istream &, DataType &, CLParseXtra::Endian) [DataType = unsigned char]
#Warning eof,n,%{public}ld,requested,%{public}ld
static bool CLParseXtra::read_from_file(std::istream &, DataType &, CLParseXtra::Endian) [DataType = unsigned short]
static bool CLParseXtra::read_from_file(std::istream &, DataType &, CLParseXtra::Endian) [DataType = unsigned int]
MotionActivityLite/kCLConnectionMessageMotionActivityUpdate
virtual void CLMotionActivityLiteClient::handleMessage(std::shared_ptr<CLConnectionMessage>)
bool CLMotionActivityLiteClient::isAuthorizedForMotionActivityLite(CMError &)
ActivityLite not available unable to service request,connection,%s,pid,%d,this,%p
ActivityLite client failed entitlement check,connection,%s,pid,%d,this,%p
void CLMotionActivityLiteClient::handleMessageMotionActivityUpdate(std::shared_ptr<CLConnectionMessage>)
Received MotionActivityUpdate request
Received MotionActivityUpdate subscription,%{public}u
CLMotionActivityLiteClient::onMotionActivityNotification
com.apple.locationd.CLElevationAWDAggregator
void CLElevationAWDAggregator::update(const FlightFailureState, int8_t, float, CFAbsoluteTime, const CMMotionContext::ActivitySession, uint32_t, uint32_t)_block_invoke
Step counter update time rolled back, previousTime, %{public}f, newTime, %{public}f
void CLElevationAWDAggregator::updateSessionStatus(const CLMotionStateMediator_Type::WorkoutEvent)_block_invoke
CLElevationAWDAggregator user started workout.
void CLElevationAWDAggregator::updateStairSpeedSegment(const CLElevationFlightSegment &)_block_invoke
Flight segment update time rolled back, previousEndTime, %{public}f, newStartTime, %{public}f
void CLElevationAWDAggregator::updateGyroEscalationState(CFAbsoluteTime, float, float, bool, uint32_t)_block_invoke
Gyro escalation update time rolled back, previousTime, %{public}f, newTime, %{public}f
com.apple.Motion.Flights
isGyroOn
watchOrientation
ageGroup
hasStairSpeed
isAscending
numFlights
workoutGroupType
com.apple.Motion.StairSpeed
elevationChange
exceededLengthThreshold
exceededProbabilityThreshold
exceededRateThreshold
hasAtLeast2mElevChange
hasFlightReported
isRejected
isWithinRateLimit
lengthOfClimb
probability
stairSpeed
stairSpeedMAD
com.apple.Motion.PressureKFGyroEscalation
hasMetDailyQuota
hasWorkoutPedIndoor
hasWorkoutPedOutdoor
hasWorkoutOtherIndoor
hasWorkoutOtherOutdoor
hasWorkoutHiking
hasWorkoutSwimming
hasWorkoutCycling
numEscalations
totalTimeEscalated
-[CLCompanionTransport initWithSilo:iDSService:]
IDSService CLCompanionTransport is nil!
Creating CLCompanionTransport
-[CLCompanionTransport updateIDSStatus]
Fitness: Companion model is %s
true
-[CLCompanionTransport updateIDSStatusAndNotify]
prevConnectedState,%s,currConnectedState,%s
-[CLCompanionTransport sendMessage:type:priority:fireAndForget:encrypt:bypassConnectionCheck:timeout:nonWaking:]
Sending protobuf ID:%s size: %lu type: %d over IDSService - Status %d, md5 %s
No device locally connected - Ignore sending data
-[CLCompanionTransport receivedMessage:data:identifierString:]
Received message ID:%s, type:%d, size %lu, md5 %s
Unexpected message received while disconnected. Updating status.
-[CLCompanionTransport service:account:incomingData:fromID:context:]
Received data over IDSService size : %ld
-[CLCompanionTransport service:account:incomingUnhandledProtobuf:fromID:context:]
Received unhandled protobuf ID:%s, size:%lu
-[CLCompanionTransport service:account:identifier:didSendWithSuccess:error:]
Service sent data with ID:%s with success %d error %s
-[CLCompanionTransport service:account:identifier:hasBeenDeliveredWithContext:]
Service data ack on otherside with ID:%s
%02x
PRTTSampleTemperature
PRTTSamplePressure
std::deque<CLMotionTypePressure> CLRobustSlopeEstimator::computePRTT()
%s,%f,%s,%f
CLPressureStats CLRobustSlopeEstimator::computeStats(int)
CLRobustSlopeEstimator given only %zd bins
PopSampleTime
CalibrationBinCount
void CLRobustSlopeEstimator::addPoint(const CLPressure::Sample *)
%s,%f,%s,%d
CalibrationSampleTime
CalibrationSamplePressure
CalibrationSampleTemperature
CalibrationTemperatureRate
%s,%f,%s,%f,%s,%f,%s,%f,%s,%d
CompassCalibrationLoggerEnabled
com.apple.CoreMotion.CompassCalibration
isAPAwake
previousCalibrationTemperature
timeSinceLastCalibration
biasShift
isSaturation
previousCalibrationQuality
previousCalibrationLevel
minTempSinceLastCal
maxTempSinceLastCal
avgTempSinceLastCal
void CLCompassCalibrationLogger::alertLastCal(bool)
[CLCompassCalibrationLogger] Last CompassCalibration: bias.x,%.2f,.y,%.2f,.z,%.2f,radius,%.2f,level,%d,quality,%.2f,cost,%.2f,coverage,%.2f,saturations,%d,consistency,%d,apAwake,%d,cftime,%.3f
Uncalibrated
Loose3D
B:%.0f,%.0f,%.0f
R:%.0f Cost:%.1f
Plan:%.2f Cov:%.1f
%s Q:%.1f
Bias  [%.2f,%.2f,%.2f]
Radius  %.2f
Cost  %.2f
Planarity  %.2f
Coverage  %.2f
Level  %s
Quality  %.2f
Consistency  %d
AP Awake  %d
Cur Compass Cal
New Compass Cal
No Compass Cal Since locationd Start
activityType
mets
metSource
meanAngleX
energyMagnitude
metsHR
metsWR
kWorkRate
kHeartRate
kCalibratedWorkRate
kDefaultValue
com.apple.tcc.access.changed
virtual bool CLFitnessTrackingNotifierCompanion::isDeviceActivated() const
#SystemState, Device is not activated, suspending activity tracking.
virtual bool CLFitnessTrackingNotifierCompanion::isFitnessTrackingEnabled() const
#SystemState, Failed to get TCC for motion, suspending activity tracking.
virtual void CLFitnessTrackingNotifierCompanion::notifyClients()
#SystemState, Companion, Enabled, %{public}d, DeviceActivated, %{public}d
CleanupInterval
CLTilesManagerExternal::CLTilesManagerExternal(CLTilesManager *, id<CLIntersiloUniverse>)
TileMgr, Timer allocation failure, #CloneMe
CLSuggestedActionManager
CLTilesManager::onStoreFrontDidChangeNotification
CLTilesManager::onClientNotification
CLTilesManager::onDataProtectionNotification
CLTilesManager::onCompanionNotification
CLTilesManager::onStatusNotification
CLTilesManager::onLocationNotification
void CLSkiController::doStartSession(const CLSkiController::EStartOfWorkout *)
Session started
void CLSkiController::doEndSession(const CLSkiController::EEndOfWorkout *)
Session ended
void CLSkiController::doRun(const CLSkiController::EInRun *)
Run started
void CLSkiController::doLowPower(const CLSkiController::ELift *)
transitioning to low power mode: start of lift
void CLSkiController::doLowPower(const CLSkiController::ESedentaryTimeout *)
transitioning to low power mode: sedentary
void CLSkiController::finalizeRun()
Run stopped
last elevation entry not found
last odometer entry not found
End of run stats,startTime,%lf,endTime,%lf,runDistance,%f,runElevationDescent,%f,runAvgSpeed,%f,runMaxSpeed,%f,runSlope,%f
virtual void CLSkiController::resume()
resuming tracking
SkiElevation
SkiOdometer
void CLSkiController::logElevationRateBuffer()
ElevationBuffer%s
void CLSkiController::updateElevationRateBuffer()
adding ElevationRate, %f
bool CLSkiController::processInputsAndTransition()
State from, %d, event, %d, to, %d
Skyhook
GPS-coarse
pipelined
WiFi2
Compensated
LoiOverride
CLTypeLocation, 
, type, 
, latitude, 
, longitude, 
, altitude, 
, hAcc, 
, vAcc, 
, course, 
, speed, 
, timstamp, 
, lifespan, 
, confidence, 
, ll, 
<error>
static bool CMOQuaternion::northAndGravity(CMVector<float, 3>, CMVector<float, 3>, CMVector<float, 3>, const float *, CMOQuaternion &, CMMatrix<float, 3> &)
n and g are too close %f
Assertion failed: lambda2 != 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMOQuaternion.cpp, line 213,invalid weights.
kappa zero!
T &CMVector<float, 3>::operator[](const size_t) [T = float, N = 3]
Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMVector.h, line 277,invalid index %zu >= %zu.
T CMVector<float, 3>::operator[](const size_t) const [T = float, N = 3]
Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMVector.h, line 271,invalid index %zu >= %zu.
T CMMatrix<float, 3>::operator[](size_t) const [T = float, M = 3, N = 3]
Assertion failed: ldx < M*N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 84,invalid element %zu >= %zu.
T &CMMatrix<float, 3>::operator()(size_t, size_t) [T = float, M = 3, N = 3]
Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 77,invalid row %zu > %zu.
Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 78,invalid col %zu > %zu.
T CMMatrix<float, 3>::operator()(size_t, size_t) const [T = float, M = 3, N = 3]
Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 70,invalid row %zu > %zu.
Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 71,invalid col %zu > %zu.
INSERT INTO VO2MaxCloudKitSyncEngineMetadata (startTime, lastUpdateTime, metadata) VALUES (?, ?, ?)
SELECT * FROM VO2MaxCloudKitSyncEngineMetadata ORDER BY id DESC LIMIT 1
UPDATE VO2MaxCloudKitSyncEngineMetadata SET startTime = ?, lastUpdateTime = ?, metadata = ? WHERE id = ?
ALTER TABLE VO2MaxCloudKitSyncEngineMetadata ADD COLUMN 
UPDATE VO2MaxCloudKitSyncEngineMetadata SET 
metadata
CLActivityRecorderDb<VO2MaxCloudKitSyncEngineMetadata>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxCloudKitSyncEngineMetadata, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxCloudKitSyncEngineMetadata>::setDatabaseAccessible() [T = VO2MaxCloudKitSyncEngineMetadata, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxCloudKitSyncEngineMetadata>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxCloudKitSyncEngineMetadata, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxCloudKitSyncEngineMetadata>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxCloudKitSyncEngineMetadata, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
idx (%tu) is out of range (%tu)
locationId
macs
modes
CLVO2MaxInputCollector::strideCalConverged
CLExerciseMinuteController::CLExerciseMinuteController(CLGenericFitnessEstimatorProtocol *)
CLExerciseMinuteController::CLExerciseMinuteController called
void CLExerciseMinuteController::feedNatalie(double, const CLNatalieModelInput &)
CLExerciseMinuteController::feedNatalie called, rawMets, %f
void CLExerciseMinuteController::feedBodyMetrics(const CLBodyMetrics &)
CLExerciseMinuteController::feedBodyMetrics called
void CLExerciseMinuteController::recordExerciseMinute(const CLExerciseMinute_Types::ExerciseMinute &)
ExerciseMinute, adjustedStartTime, %{public}.3f, startTime, %{public}.3f, averageIntensity, %{private}f, awardMode, %{public}d, inWorkoutSession, %{public}d, hasElevationCredit, %{public}d, duplicate, %{public}d
bool CLExerciseMinuteController::updateExerciseMinuteMap(const CLExerciseMinute_Types::ExerciseMinute &)
Purging ExerciseMinute, adjustedStartTime, %{public}.3f, startTime, %{public}.3f, averageIntensity, %{private}f, awardMode, %{public}d, inWorkoutSession, %{public}d, hasElevationCredit, %{public}d
ExerciseMinutes
CLSubHarvesterAltimeter
CLSubHarvesterIonosphere
Cell
CLSubHarvesterApp
CLSubHarvesterCell
CLSubHarvesterIndoor
CLSubHarvesterTracks
CLSubHarvesterPass
CLSubHarvesterPressure
CLSubHarvesterPoi
CLSubHarvesterRealtime
CLSubHarvesterTrace
CLSubHarvesterWifi
CLSubHarvesterAvenger
kCLSubHarvesterAltimeter
kCLSubHarvesterIonosphere
std::string subHarvesterIdentifierToString(CLSubHarvesterIdentifier)
Unknown SubHarvester requesting description string
void CLMobility::BoutDetector::handleUserInfoUpdate(const CLBodyMetrics &)
BoutDetector (%{public}s): Received user info (%s)
void CLMobility::BoutDetector::startBout(CFAbsoluteTime)
BoutDetector (%{public}s): bout already in progress (%{public}.2f), cannot start bout at startTime %{public}.2f
BoutDetector (%{public}s): Identified potential walking bout... marking as in progress (start: %{public}.2f)
void CLMobility::BoutDetector::extendBout(CFAbsoluteTime)
BoutDetector (%{public}s): Cannot extend bout, no bout in progress
BoutDetector (%{public}s): ExtendingBout,startTime,%{public}.2f,duration,%{public}.2f
void CLMobility::BoutDetector::stopBout(CLMobility::BoutTerminationReason)
BoutDetector (%{public}s): Cannot stop bout, no bout in progress
BoutDetector (%{public}s): zero-length bout (%{public}.2f). Ignoring.
BoutDetector (%{public}s): duration is negative. Time likely rolled back. startTime,%{public}.2f,endTime,%{public}.2f
BoutDetector (%{public}s): exceeded max duration. Should not be possible. startTime,%{private}.3f,endTime,%{private}.3f
BoutDetector (%{public}s): Failed to write new bout %{public}.2f
gaitMetrics
void CLMobility::BoutDetector::checkBoutEndWithPacketTime(CFAbsoluteTime, CLMobility::PacketType)
BoutDetector (%{public}s): Ending bout (%{public}.2f) due to maxTimeSinceEndOfBout from %{public}s time (%{public}.2f)
void CLMobility::BoutDetector::checkTimeRollback(CFAbsoluteTime)
BoutDetector (%{public}s): Ending bout (%{public}.2f) due to timeRollback time (%{public}.2f)
void CLMobility::BoutDetector::checkMaxBoutDuration(CFAbsoluteTime)
BoutDetector (%{public}s): Ending bout (%{public}.2f) due to maxBoutDuration (%{public}.2f)
CLSwimAlgSimulator::CLSwimAlgSimulator(CLSwimDataStore *, float)
CLSwimAlgSimulator Instantiated
SimulateSwimmingStyle
SimulateSwimmingLapInsertion
virtual CLSwimAlgResultFlags CLSwimAlgSimulator::processFusion(const CLSwimFusionInput &, CLSwimEntry &)
Simulated stroke
Simulated turn
lastStatus, 
, started, 
, monitoring settled, 
, activeTech, 
, lastDistance, 
, lastTechCheckDis, 
, lastLocCheck, 
, settledInsideStatus, 
static bool CLFenceMonitorLogic::isSimplePolygon(const std::vector<CLClientLocationCoordinate> &)
Input is not valid: %{public}s
static bool CLFenceMonitorLogic::isCompliant(const CLFenceManager_Type::Fence &)
Only check polygonal fences, %{private}lu
static CLFenceManager_Type::FenceStatus CLFenceMonitorLogic::getStatusFromLocation(const CLDaemonLocation &, const CLFenceManager_Type::Fence &, const CLFenceMonitorLogic::FenceMonitoringStatus &, const double, const bool, CLDistanceCalc &)
Fence: location, why are you unknown?, %{private}s
unsupported location type
getStatusFromLocation, %{private}s, fix, %c%c%c%c%c, isWifiPowered, %{public}d,  effectiveDistance, %{public}.2lf, distance, %{public}.1f, entryRadius, %{private}.1f, exitRadius, %{private}.1f, adjDist, %{private}.1lf, adjHorAcc, %{private}.1lf, origHorAcc, %{public}.1lf
Fence status changed to Inside, distToCenter, %{private}.1lf, %{private}s
Fence status changed to Outside, distToCenter, %{private}.1lf, %{private}s
Fence status remained unchanged, distToCenter, %{private}.1lf, %{private}s
one-AP
2+AP
static bool CLFenceMonitorLogic::shouldIgnoreLocation(const CFAbsoluteTime, CFAbsoluteTime &, int &, CLDaemonLocation &, const CLDaemonLocation &, const CLDaemonLocation &, const int, const bool, const bool, const bool)
Fence: location treated as new continuous session
requested
wifi off
good
leashed
last location old
other leashed
other type
Fence: Ignoring location, %{private}s, type, %{public}d, hacc, %{public}.1f, conf, %{public}d, integ, %{public}d, fixCnt, %{private}d, counter, %{private}d
Fence: Accepting location, %{private}s, type, %{public}d, hacc, %{public}.1f, conf, %{public}d, integ, %{public}d, fixCnt, %{private}d, counter, %{private}d
double distanceToNearestPointOnPolygon(const CLClientLocationCoordinate &, const std::vector<CLClientLocationCoordinate> &, bool)
Attempting to calculate distance to an invalid polygon, %{public}lu
Fence: distance to nearest point %{private}.02lf (%{private}d)
void boost::geometry::detail::throw_on_empty_input(const Geometry &) [Geometry = boost::geometry::model::polygon<boost::geometry::model::point<double, 2, boost::geometry::cs::spherical_equatorial<boost::geometry::degree>>, true, true>]
/System/Volumes/Data/SWE/iOS/BuildRoots/BuildRoot903/Applications/Xcode.app/Contents/Developer/Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator8.3.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/throw_on_empty_input.hpp
Boost.Geometry Empty-Input exception
first != last
Geometry is valid
Geometry has too few points
Geometry has wrong topological dimension
Geometry is defined as closed but is open
Geometry has spikes
Geometry has invalid self-intersections
Geometry has wrong orientation
Geometry has interior rings defined outside the outer boundary
Geometry has nested interior rings
Geometry has disconnected interior
Multi-polygon has intersecting interiors
Geometry has duplicate (consecutive) points
Box has corners in wrong order
Geometry has point(s) with invalid coordinate(s)
front
!boost::empty(rng)
find_different_from_first
has_spikes.hpp
. A spike point was found with apex at 
has_valid_self_turns.hpp
! boost::empty(turns)
special_cases
segment.hpp
!is_pole1 && !is_pole2
compute_box_corners
lon1 <= lon2
contains_pi_half
! math::equals(a1, a2)
static OutputIterator boost::geometry::detail::overlay::get_turn_info<boost::geometry::detail::overlay::assign_null_policy>::apply(const Point1 &, const Point1 &, const Point1 &, const Point2 &, const Point2 &, const Point2 &, bool, bool, bool, bool, const TurnInfo &, const IntersectionStrategy &, const RobustPolicy &, OutputIterator) [AssignPolicy = boost::geometry::detail::overlay::assign_null_policy, Point1 = boost::geometry::model::point<double, 2, boost::geometry::cs::spherical_equatorial<boost::geometry::degree>>, Point2 = boost::geometry::model::point<double, 2, boost::geometry::cs::spherical_equatorial<boost::geometry::degree>>, TurnInfo = boost::geometry::detail::overlay::turn_info<boost::geometry::model::point<double, 2, boost::geometry::cs::spherical_equatorial<boost::geometry::degree>>, boost::geometry::segment_ratio<double>>, IntersectionStrategy = boost::geometry::strategy::intersection::spherical_segments<>, RobustPolicy = boost::geometry::detail::no_rescale_policy, OutputIterator = std::back_insert_iterator<std::deque<boost::geometry::detail::overlay::turn_info<boost::geometry::model::point<double, 2, boost::geometry::cs::spherical_equatorial<boost::geometry::degree>>, boost::geometry::segment_ratio<double>>>>]
/System/Volumes/Data/SWE/iOS/BuildRoots/BuildRoot903/Applications/Xcode.app/Contents/Developer/Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator8.3.Internal.sdk/usr/local/include/boost/geometry/algorithms/detail/overlay/get_turn_info.hpp
segment_ratio.hpp
lhs.denominator() != 0
rhs.denominator() != 0
assign_point
get_turn_info.hpp
index < info.count
arrival != 0
Boost.Geometry Turn exception: 
i <= boost::size(rng)
. A self-intersection point was found at 
; method: 
; operations: 
; segment IDs {source, multi, ring, segment}: 
are_holes_inside
polygon.hpp
tit->operations[1].seg_id.ring_index != -1
add_edge
complement_graph.hpp
v1 != m_vertices.end()
v2 != m_vertices.end()
state_transition
lifecycle
CLDaemonClient::CLDaemonClient(CLConnection *, CLClientManager *, id<CLIntersiloUniverse>)
Couldn't get information from PID %{public}u
bool CLDaemonClient::init()
Failed to become client of CLClientManager
RttBurstSize
WRTT: overriding burst size to %{public}d
fRttBurstSize <= kCLMaxNumberOfMeasurementsInBurst
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLDaemonClient.mm
init
CLDisableAuthorizationRequests
LocationManager/kCLConnectionMessageRegistration
kCLConnectionMessageAllowsLocationPrompts
kCLConnectionMessageShowLocationPrompt
kCLConnectionMessagePurpose
kCLConnectionMessageIsActuallyAWatchKitExtension
kCLConnectionMessageProxyForRemoteClient
kCLConnectionMessageRequestAuthorization
kCLConnectionMessageRequestTemporaryPrecise
kCLConnectionMessageMarkAsHavingReceivedLocation
kCLConnectionMessageMatchInfoEnabled
kCLConnectionMessageGroundAltitudeEnabled
kCLConnectionMessageFusionInfoEnabled
kCLConnectionMessageRegisterAsLocationClient
kCLConnectionMessageFetchEstimatedLocationAtDate
kCLConnectionMessagePeerRanging
kCLConnectionMessageVehicleHeading
kCLConnectionMessageVehicleSpeed
kCLConnectionMessageRequestMicroLocation
kCLConnectionMessageRequestMicroLocationRecordingScan
kCLConnectionMessageGmm
kCLConnectionMessagePressureBias
kCLConnectionMessageGyroBiasEstimation
kCLConnectionMessageHasRunMiniCal
kCLConnectionMessageStartMiniCal
kCLConnectionMessageSetUrgentCalFlag
kCLConnectionMessageCatherineData
kCLConnectionMessageVehicleConnectionMostRecent
kCLConnectionMessageVehicleStateIsAvailable
kCLConnectionMessageVehicleStateMostRecentVehicleConnection
kCLConnectionMessageVehicleStateMostRecentInVehicle
kCLConnectionMessageVehicleStateIsVehicle
kCLConnectionMessageVehicularState
kCLConnectionMessageVehicularOperatorState
kCLConnectionMessageHealthAssessmentRecordTypeForDurationKey
kCLConnectionMessageHealthAssessmentParkinsonsResultQuery
kCLConnectionMessageMovementDisorderLastProcessedDate
kCLConnectionMessageMovementDisorderMonitorKinesiasExpirationDate
kCLConnectionMessageSensorRecorderAuthorized
kCLConnectionMessageSensorRecorderSensorAvailable
kCLConnectionMessageSensorRecorderGetMetaByID
kCLConnectionMessageSensorRecorderGetMetaSinceID
kCLConnectionMessageSensorRecorderGetMetasByDateRange
kCLConnectionMessageSensorRecorderGetDataByID
kCLConnectionMessageSensorRecorderRecordFor
kCLConnectionMessageSensorRecorderWriteSensorDataToFileByDateRange
kCLConnectionMessageSensorRecorderSetSensorSampleRate
kCLConnectionMessageDeviceHasOriginalCamera
kCLConnectionMessageCameraVcmActuatorId
kCLConnectionMessageCompassCalibrationData
kCLConnectionMessageFitnessMachineData
kCLConnectionMessagePredictedWalkDistanceReset
kCLConnectionMessageWriteDbToFile
kCLConnectionMessageTriggerVO2MaxRetrocompute
kCLConnectionMessageVO2MaxRetrocomputeStatusQuery
v24@?0{shared_ptr<CLConnectionMessage>=^{CLConnectionMessage}^{__shared_weak_count}}8
kCLConnectionMessageVehicleSpeedKey
void CLDaemonClient::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
Sending,vehicle speed,to client,%{public}s,time,%{public}.3lf,speed,%{private}.3lf
kCLConnectionMessageVehicleHeadingKey
Sending,vehicle heading,to client,%{public}s,time,%{public}.3lf,heading,%{private}.3lf
Got active change notification; updating requests
void CLDaemonClient::sendPeerRangesAndErrors(const std::vector<CLPeerRangingResult> &, const std::vector<CLPeerRangingError> &)
WRTT: Send PeerRanges, %{public}ld, Errors, %{public}ld
peers && "Error code has to go with a peer"
sendPeerRangingErrors
[errors count] == [peers count] && "Number of peers and errors has to be same"
void CLDaemonClient::sendPeerRangingErrors(NSArray<NSError *> *, NSArray<_CLRangingPeer *> *)
WRTT: send Errors (%{public}lu) to client '%s'
kCLConnectionMessageErrorsKey
kCLConnectionMessageRangingPeersKey
void CLDaemonClient::sendPeerRangingRequestProcessed(bool, NSArray *)
WRTT: processed request processed, isStart,%{public}d, nPeers,%{public}lu
!rangeResults.empty()
sendPeerRangeResults
void CLDaemonClient::sendPeerRangeResults(const std::vector<CLPeerRangingResult> &)
WRTT: send Results (%{public}ld) to client '%s'
WRTT: Sending PeerRanging info to client '%{private}s'
void CLDaemonClient::onGyroBiasEstimatorNotification(const CLMotionTypeGyroBiasAndVariance &)
Sent gyro bias estimation message
void CLDaemonClient::onGmmNotification(int, const CLGeomagneticModelProvider_Type::Notification &, const CLGeomagneticModelProvider_Type::NotificationData &)
Received GMM notification %d
void CLDaemonClient::onPressureBias(int, const CLPressureBias_Type::Notification &, const CLPressureBias_Type::NotificationData &)
Unexpected notification in onPressureBias,notification,%d
void CLDaemonClient::onManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
'%{public}s' received unknown notification: %{public}d
not entitled
virtual bool CLDaemonClient::isEntitled(const std::string &)
%s is %s for %s
void CLDaemonClient::setAuthorizationContext(CLClientManagerAuthorizationContext *)
client authorized; sending out cached message %s
client authorized but no longer interested in cached message %s; discarding cache
#Warning %s is still not authorized for %s, dropping
kCLClientRegistrationResultFailedUnverified != fAuthorizationContext.registrationResult
setAuthorizationContext
UIBackgroundModes
void CLDaemonClient::assessClientCapabilities()
PID %u either doesn't specify UIBackgroundModes, or SB timed out fetching them
client '%s' supports background location
kCLConnectionMessageStatusKey
kCLConnectionMessageCompensationKey
kCLConnectionMessageAuthorizedForWidgetUpdatesKey
kCLConnectionMessageLocation
kCLConnectionMessageSignificantLocationChange
void CLDaemonClient::sendDeniedErrorMessage()
Sending denied error message to %s
kCLConnectionMessageCompensatedLocation
kCLConnectionMessageBundleIdentifierKey
kCLConnectionMessageBundlePathKey
kCLConnectionMessageClientSDKKey
com.apple.locationd.effective_bundle
void CLDaemonClient::handleMessageRegistration(std::shared_ptr<CLConnectionMessage>)
#Warning Client '%{public}s' does not have required entitlement '%{public}s' to set effective bundle identifier, '%{public}s', or effective bundle, '%{public}s'
Client '%{public}s' is setting effective bundle identifier to '%{public}s'
com.apple.webapp-
Client '%{public}s' is attempting to masquerade as uninstalled app with effective bundle identifier '%{public}s'
Client '%{public}s' is a plugin, auto-masquerading as its containing app
Could not access bundle for masquerading client %{public}s
%{public}s is creating a CLLocationManager, but does not have any NSLocation*UsageDescription keys
kCLConnectionMessagePurposeKey
void CLDaemonClient::handleMessagePurpose(std::shared_ptr<CLConnectionMessage>)
void CLDaemonClient::handleMessageIsActuallyAWatchKitExtension(std::shared_ptr<CLConnectionMessage>)
Unentitled entity '%{public}s' trying to tell us they are WatchKit
kCLConnectionMessageEnabledKey
Setting client, %s, is actually a WatchKit extension, %d
void CLDaemonClient::handleMessageProxyForRemoteClient(std::shared_ptr<CLConnectionMessage>)
void CLDaemonClient::handleMessageMarkAsHavingReceivedLocation(std::shared_ptr<CLConnectionMessage>)
Unentitled entity '%{public}s' trying to mark itself as having received location?!
kCLConnectionMessagePromptResponseKey
com.apple.locationd.prompt_content_control
kCLConnectionMessagePurposeIdentifierKey
Info.plist is missing the %@ key
Info.plist value for %@ key is not a dictionary
The purposeKey provided isn't present in the app's Info.plist dictionary of temporary usage descriptions
The purposeKey provided names an entry in Info.plist which isn't a string
UsageDescription
App is in the background
Requested authorization level isn't supported by the app
App is requesting authorization prompt while the screen is locked
Outstanding authorization prompt detected.
App's authorization status is not yet determined. App needs to ask for authorization before asking for temporary precise upgrade.
The user has already made a decision about the app's authorization
com.apple.locationd.private_info
void CLDaemonClient::handleMessageMatchInfoEnabled(std::shared_ptr<CLConnectionMessage>)
Client %s is setting match info enabled to %d
void CLDaemonClient::handleMessageGroundAltitudeEnabled(std::shared_ptr<CLConnectionMessage>)
void CLDaemonClient::handleMessageFusionInfoEnabled(std::shared_ptr<CLConnectionMessage>)
com.apple.locationd.prompt_behavior
void CLDaemonClient::handleMessageAllowsLocationPrompts(std::shared_ptr<CLConnectionMessage>)
Client %{public}s does not have appropriate entitlement to change prompt behaviour
Client %s is setting location prompt allowed to %d
void CLDaemonClient::handleMessageShowLocationPrompt(std::shared_ptr<CLConnectionMessage>)
Client %s is setting location prompt show to %d
void CLDaemonClient::handleMessageRegisterAsLocationClient(std::shared_ptr<CLConnectionMessage>)
Client %{public}s is registering as a location client and will show up in Settings
com.apple.locationd.stored_location
Not entitled.
Not authorized.
kCLConnectionMessageFetchEstimatedLocationDateKey
void CLDaemonClient::handleMessageFetchEstimatedLocationAtDate(std::shared_ptr<CLConnectionMessage>)
Error checking date parameter
Invalid parameters.
CLDaemonClient
kCLConnectionMessageFetchEstimatedLocationLocationKey
v24@?0@"CLLocation"8@"NSError"16
Not supported.
void CLDaemonClient::handleMessageUnknown(std::shared_ptr<CLConnectionMessage>)
handleMessagePeerRanging
void CLDaemonClient::handleMessagePeerRanging(std::shared_ptr<CLConnectionMessage>)
handleMessageVehicleSpeed
void CLDaemonClient::handleMessageVehicleSpeed(std::shared_ptr<CLConnectionMessage>)
handleMessageVehicleHeading
void CLDaemonClient::handleMessageVehicleHeading(std::shared_ptr<CLConnectionMessage>)
handleMessageGyroBiasEstimation
void CLDaemonClient::handleMessageGyroBiasEstimation(std::shared_ptr<CLConnectionMessage>)
handleMessageGmm
void CLDaemonClient::handleMessageGmm(std::shared_ptr<CLConnectionMessage>)
handleMessagePressureBias
void CLDaemonClient::handleMessagePressureBias(std::shared_ptr<CLConnectionMessage>)
com.apple.locationd.peer_ranging
bool CLDaemonClient::isEntitledForPeerRanging()
WRTT: client %s does not have appropriate entitlement to access SPI
void CLDaemonClient::handleRequestPeerRanging(bool, const CLNameValuePair &)
WRTT: daemon client received request,client,%s,subscribe,%{public}d
WRTT: Incorrect data type for ranging peers
WRTT: Exception while decoding peers
kCLConnectionMessageRangingPeerInitiatorKey
kCLConnectionMessageRangingPeerTimeoutKey
WRTT: peer %{private}#llX, timeout %{puclic}lf, len(keyID) %{private}lu
WRTT: Client '%s' registered for PeerRanging notifications
WRTT: Client '%s' unregistered from PeerRanging notifications
com.apple.locationd.activity
virtual bool CLDaemonClient::isAuthorizedForMotionActivity()
#Warning Client %s did not pass entitlement/tcc checks.
bool CLDaemonClient::isAuthorizedForSensorRecorder()
Client %s did not pass entitlement/tcc checks.
Client %s cannot access sensor recorder, invalid target.
void CLDaemonClient::handleMessageVehicleConnectionMostRecent(std::shared_ptr<CLConnectionMessage>)
#Warning Client %s does not have appropriate entitlement to access motion activity spi
CLVehicleConnectionNotifier
void CLDaemonClient::handleMessageVehicleStateMostRecentInVehicle(std::shared_ptr<CLConnectionMessage>)
#Warning Client %s does not have access to motion activity spi because the platform is not supported
void CLDaemonClient::handleMessageVehicleStateIsVehicle(std::shared_ptr<CLConnectionMessage>)
#Warning Client %{public}s does not have appropriate entitlement to access motion activity SPI
Error checking IsVehicle with device address and type!
v12@?0B8
void CLDaemonClient::handleMessageVehicularOperatorState(std::shared_ptr<CLConnectionMessage>)
#Warning Client %{public}s does not have access to vehicular state SPI because the platform is not supported
CLVehicleStateNotifier
Cannot find vehicle state proxy
void CLDaemonClient::handleMessageVehicularState(std::shared_ptr<CLConnectionMessage>)
#Warning Client %s does not have access to vehicular state spi because the platform is not supported
v24@?0Q8Q16
void CLDaemonClient::handleRequestGyroBiasEstimation(bool, const CLNameValuePair &)
CLDaemonClient received GyroBiasEstimation request,client,%{public}s,subscribe,%{public}d
kCLConnectionMessageBuildGYTTKey
isBuildingGYTT not set
CLGyroCalibrationDatabase
CLDaemonClient got gyro bias estimation subscription request,isBuildingGYTT,%{public}d
v16@?0r^{?={?=fff}{?=fff}B}8
CLDaemonClient got gyro bias estimation unsubscription request
void CLDaemonClient::handleRequestGmm(bool, const CLNameValuePair &)
Received GMM request,client,%{public}s,subscribe,%{public}d
void CLDaemonClient::handleRequestPressureBias(bool, const CLNameValuePair &)
Recieved pressure bias estimation request.,client,%s,subscribe,%d
void CLDaemonClient::handleMessageFitnessMachineData(std::shared_ptr<CLConnectionMessage>)
Error receiving data from fitness machine
CLDaemonClient.FitnessMachineData
void CLDaemonClient::handleMessageHasRunMiniCal(std::shared_ptr<CLConnectionMessage>)
com.apple.locationd.catherine_provider
bool CLDaemonClient::isEntitledToProvideCatherine()
Client %{public}s does not have appropriate entitlement to access catherine provider SPI
void CLDaemonClient::handleMessageCatherineData(std::shared_ptr<CLConnectionMessage>)
kCLConnectionMessageCatherineDataKey
#Warning Packet contains nil catherine data
com.apple.locationd.rebuild_gytt
bool CLDaemonClient::isEntitledForMiniCal()
#Warning Client %s does not have appropriate entitlement to run miniCal
void CLDaemonClient::handleMessageStartMiniCal(std::shared_ptr<CLConnectionMessage>)
CLSensorCalibrationController
com.apple.developer.health-movement-disorder
bool CLDaemonClient::isAuthorizedForHealthAssessment(CMError &)
#Warning HealthAssessment,Client failed entitlement check, %{public}s, %{public}d, %{public}p
#Warning HealthAssessment,Client failed authorization check, %{public}s, %{public}d, %{public}p
void CLDaemonClient::handleMessageHealthAssessmentParkinsonsResultQuery(std::shared_ptr<CLConnectionMessage>)
Programmer error: Wrong parameters were passed!
void CLDaemonClient::handleMessageSensorRecorderGetMetasByDateRange(std::shared_ptr<CLConnectionMessage>)_block_invoke
(%f, %f), %d records returned
void CLDaemonClient::handleMessageSensorRecorderGetDataByID(std::shared_ptr<CLConnectionMessage>)
Allocating mmap buffer.
CLDaemonClient.SensorRecorderAccel
mmap failure.  errno %d
Did not successfully allocate buffer for sensor recorder.  Returning CMErrorNotAvailable
void CLDaemonClient::handleMessageSensorRecorderGetDataByID(std::shared_ptr<CLConnectionMessage>)_block_invoke
Requesting id, %llu, meta id, %llu
void CLDaemonClient::handleMessageSetUrgentCalFlag(std::shared_ptr<CLConnectionMessage>)
void CLDaemonClient::handleMessagePredictedWalkDistanceReset(std::shared_ptr<CLConnectionMessage>)
PredictedWalkDistanceResetDate
void CLDaemonClient::handleMessageWriteDbToFile(std::shared_ptr<CLConnectionMessage>)
Client %{public}s does not have appropriate motion entitlement.
CLCompassDatabase
fatEgg
v16@?0@"NSString"8
com.apple.locationd.vehicle_data
bool CLDaemonClient::isEntitledForVehicleData()
#Warning Client %s does not have appropriate entitlement to access vehicle data SPI
void CLDaemonClient::handleRequestVehicleSpeed(bool, const CLNameValuePair &)
Received VehicleSpeed request,client,%s,subscribe,%d
client '%s' subscribing to vehicle speed
client '%s' unsubscribing from vehicle speed
void CLDaemonClient::handleRequestVehicleHeading(bool, const CLNameValuePair &)
Received VehicleHeading request,client,%s,subscribe,%d
client '%s' subscribing to vehicle heading
client '%s' unsubscribing from vehicle heading
void CLDaemonClient::handleTriggerVo2MaxRetrocompute(std::shared_ptr<CLConnectionMessage>)
Received request to trigger VO2Max retrocompute
CLVO2MaxService
void CLDaemonClient::handleMessageVO2MaxRetrocomputeStatusQuery(std::shared_ptr<CLConnectionMessage>)
Received request to query VO2Max retrocompute status
v20@?0@"CMVO2MaxRetrocomputeState"8i16
kCLConnectionMessageGesture
kCLConnectionMessageMotionActivityUpdate
kCLConnectionMessageMotionActivityQuery
kCLConnectionMessageMotionActivityAvailable
kCLConnectionMessageActivityAlarmStart
kCLConnectionMessageActivityAlarmAvailable
kCLConnectionMessageStartStepCountAvailable
kCLConnectionMessageStepCountQuery
kCLConnectionMessageFloorCountAvailable
kCLConnectionMessagePaceAndCadenceAPIAvailable
EmergencyEnablementAssertion/kCLConnectionMessage
LocationIndependenceAssertion/kCLConnectionMessage
kCLConnectionMessageStepCountReset
kCLConnectionMessageOdometerSuitabilityUpdate
kCLConnectionMessageSedentaryTimerIsAvailable
kCLConnectionMessageSedentaryTimerIsArmed
kCLConnectionMessageSedentaryTimerStart
kCLConnectionMessageSedentaryTimerStop
kCLConnectionMessageSedentaryTimerQuery
kCLConnectionMessageSedentaryTimerAlarm
kCLConnectionMessageOnBodyDetection
kCLConnectionMessageOnBodyDetectionParams
kCLConnectionMessageSidebandSensorFusionEnable
kCLConnectionMessageNatalimetryUpdate
kCLConnectionMessageNatalimetryAvailable
kCLConnectionMessageNatalimetryQuery
Health/kCLConnectionMessageMetMinutesQuery
kCLConnectionMessageNatalimetryGetUserProfile
kCLConnectionMessageNatalimetrySetUserProfile
kCLConnectionMessageExerciseMinuteQuery
kCLConnectionMessageExerciseMinuteUpdate
kCLConnectionMessageWorkoutStart
kCLConnectionMessageWorkoutStop
kCLConnectionMessageWorkoutEvent
kCLConnectionMessageFallStatsAvailable
kCLConnectionMessageFallStatsSetEnabled
kCLConnectionMessageFallStatsSendStats
kCLConnectionMessageFallStatsGetConfig
kCLConnectionMessageAnomalyEvent
kCLConnectionMessageAnomalyEventCompleted
kCLConnectionMessageAnomalyEventCompletedMostRecent
kCLConnectionMessageAnomalyEventEnabled
SpringTracking/kCLConnectionMessageSpringTrackerStart
SpringTracking/kCLConnectionMessageSpringTrackerStop
kCLConnectionMessageKappaStatsAvailable
kCLConnectionMessageKappaSendCommand
kCLConnectionMessageKappaSendAPCommand
kCLConnectionMessageKappaSendConfig
kCLConnectionMessageKappaSendAPConfig
kCLConnectionMessageKappaGetStateRequest
kCLConnectionMessageKappaGetState
kCLConnectionMessageKappaStatsSendToUrl
kCLConnectionMessageIndoorOutdoorUpdate
kCLConnectionMessageIndoorOutdoorLastKnownState
kCLConnectionMessageBBTimeFreqTransferAssertError
kCLConnectionMessageBBTimeFreqTransferMeasurement
kCLConnectionMessageGNSSHeatMap
kCLConnectionMessageGnssDisablementAssertRsp
kCLConnectionMessageLocationUnavailable
kCLConnectionMessageSignificantLocationVisit
kCLConnectionMessageLocationPush
CLDC.%p.%s
com.apple.developer.health.fall-detection
kTCCServiceFallDetection
virtual bool CLDaemonClient::isAuthorizedForFallDetection()
Client %s did pass Fall Detection entitlement/tcc checks.
Client %s did not pass Fall Detection entitlement/tcc checks.
modifySubscription
virtual bool CLDaemonClient::modifySubscription(const char *const, bool)
Client %{public}s (%{public}p) is %{public}ssubscribing to notification %{public}s
kCLConnectionMessageAuthorizationStatus
kCLConnectionMessageRegionMonitoring
kCLConnectionMessageRegionState
kCLConnectionMessageRegionMonitoringError
kCLConnectionMessageRegionMonitoringResponseDelayed
kCLConnectionMessageRegionMonitoringNoLocationWatchdog
kCLConnectionMessageRegionMonitoringSetupCompleted
kCLConnectionMessageRangingError
kCLConnectionMessagePeerRangingRequestProcessed
kCLConnectionMessagePeerRangingError
kCLConnectionMessageBatch
kCLConnectionMessageAutopauseStatus
kCLConnectionMessageRanging
CLDaemonClient::onLocationNotification
CLDaemonClient::onPeerRangeNotification
Generic_deprecated
CLDaemonClient::onManagerNotification
com.apple.locationd.Position
NSData *CLRangingPeerInternal::getSecureRangingKeyID() const
WRTT: No key when retrieving data
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/PeerRanging/CLRangingPeerInternal.h
Gyro
SIMULATOR_ROOT
CLEligibleMasqueraders
Routine
Motion
CLDaemonClient::onGmmNotification
CLDaemonClient::onPressureBias
os_transaction created: (%p) %@
CLFitnessMachineNotifier
Health
PredictedWalkDistance
Fall
kCLConnectionMessage
subscriptionPtr
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLDaemonClient.h
getOrCreatePersistentSubscription
subscriptionPtr && subscriptionPtr->isValid()
result
getOrCreateSubscription
getSubscriptionIfExists_internal
[key length] == kCLMaxNumberOfBytesInSecureKey
CLRangingPeerInternal
CLRangingPeerInternal::CLRangingPeerInternal(uint64_t, NSData *, int)
WRTT: peer without a key
TileId(
type=
, typeStr=
, corner=(
, tileY=
, tileX=
, skey=
, path=
isValid()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTileId.mm
operator<
o.isValid()
std::string TileId::getServerFileName() const
TmmFile, name, path, %s, servername, %s
CLBundleLocationProvider::CLBundleLocationProvider(const char *, id<CLIntersiloUniverse>, CFStringRef, CFStringRef)
#BLP attempting to create bundle location provider with NULL bundle path and NULL bundle identifier
#BLP bundle path does not exist, %{public}s
#BLP no application installed backed by bundle identifier, %{public}s
CLClientRef CLBundleLocationProvider::createClient()
BLP: Need a bundle path or a bundle identifier.
BLP: Couldn't create client for bundle path %{public}s
void CLBundleLocationProvider::registerForAppropriateLocationAccuracy()
BLP: Registering with desired accuracy %d (%s)
BLP: Location distance filter is now %.2f (%s)
BLP: Stopping location updates (%s)
#Warning BLP: CLBundleLocationProvider does not support spectators (%s)
BLP: Bystander distance filter is now %.2f (%s)
BLP: Stopping bystander location updates (%s)
@WsbBundle, %{public}s, clients, %{public}ld, numActive, %{public}d
BLP: starting wifi location batch, bundleId, %s
BLP: stopping wifi location batch, bundleId, %s
BLP: starting BystanderPreLoiOverride, bundleId, %s
BLP: stopping BystanderPreLoiOverride, bundleId, %s
Locations
void CLBundleLocationProvider::handleClientEvent(CLClientRef, CLClientEvent, id)
#Warning Could not get location from location event (%s)
#Warning BLP: Could not get authorization status (%s)
bundleIdentifier, %@, bundlePath, %@
LocationsPrivate
CLMobilityWalkingBoutService
ctor
CLGyroCalibrationDatabase is not available.
TrustedLux
void CLMotionLogger::onLoiNotification(CLVisit *, CMMotionContext::Confidence)_block_invoke
Error retrieving LOIs. %{public}@
No LOIs near
void CLMotionLogger::onLoiNotification(CLVisit *, CMMotionContext::Confidence)
Received an LOI notification:longitude,%f,lattitude,%f,
departureDate,%f,arrivalDate,%f,
horizontalAccuracy,%f,confidence,%d
concha
history
MotionLoggerPostWorkoutLoggingInterval
CLMotionDefaultsWrite<unsigned int>::CLMotionDefaultsWrite(const char *, const T &) [T = unsigned int]
Accessory
DeviceMotion
UNKNOWN
virtual void CLMotionNotifier::SiloDispatcher<CLMobility::SPUGaitMetrics>::dispatchData(int, const void *, size_t) [T = CLMobility::SPUGaitMetrics]
CLFitnessTrackingAllDayAWD
void CLFitnessTrackingAllDayAWD::updateImpactCancelationReason(const uint64_t)
CLFitnessTrackingAllDayAWD: Updating impact cancelation reason 0x%llx
void CLFitnessTrackingAllDayAWD::updateOutdoorCyclingWorkoutImpactCancellationReason(const uint64_t)
CLFitnessTrackingAllDayAWD: Updating outdoor cycling cancelation reason 0x%llx
void CLFitnessTrackingAllDayAWD::updateOutdoorWalkingImpactCancellationReason(const uint64_t)
CLFitnessTrackingAllDayAWD: Updating outdoor walking cancelation reason 0x%llx
void CLFitnessTrackingAllDayAWD::updateOutdoorRunningImpactCancellationReason(const uint64_t)
CLFitnessTrackingAllDayAWD: Updating outdoor running cancelation reason 0x%llx
void CLFitnessTrackingAllDayAWD::updateHikingWorkoutImpactCancellationReason(const uint64_t)
CLFitnessTrackingAllDayAWD: Updating hiking cancelation reason 0x%llx
void CLFitnessTrackingAllDayAWD::updateOtherWorkoutImpactCancellationReason(const uint64_t)
CLFitnessTrackingAllDayAWD: Updating other workout cancelation reason 0x%llx
+[CLNewAppDiscovery(IsSupported) isSupported]
Not supported on this platform because ManagedConfiguration.framework is not present
New app discovery support: %{public}d
CLNewAppDiscoveryEnable
CLNewAppDiscoverySilo
CLAppTileDataProvider
CLNewAppDiscovery
CLNADSurface
-[CLNewAppDiscovery beginService]
setup: can install apps, %d
setup: max age allowed, %u
setup: done registering for leeched location
setup: service not enabled, not registering for leeched location
setup: cannot install apps, not registering for leeched location
-[CLNewAppDiscovery onLocation:]
location received: not usable, not suggesting
location received: forwarding to controller
fetching, marquees, submitting: %{private}lf, %{private}lf, %{private}lf
-[CLNewAppDiscovery onLocation:]_block_invoke
fetching: marquees, error, %{private}s
fetching: marquees, success, %{private}lu
fetching: marquees, exiting
fetching: marquees, using cached entries
fetching: lois, submitting: %{private}lf, %{private}lf, %{private}lf
fetching: lois, error, %{private}s
fetching: lois, success, %{private}lu
fetching, lois, exiting
fetching, lois, submitted: %{private}lf, %{private}lf, %{private}lf
fetching, lois, using cached entries
fetching: all done, entered notify handler
decision: fetching error, not suggesting
no fetching, using cached versions
-[CLNewAppDiscovery isServiceEnabledViaGeoCountryOverrides]
loading key %{private}s GEO network overrides, %{private}d
-[CLNewAppDiscovery onRegionChangeNotification]
service disabled via network override
void onLocationNotification_bounce(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &, void *)
location received: register: type, %{private}d, lat, %{private}lf, long, %{private}lf, %{private}lf
location received: done: type, %{private}d, lat, %{private}lf, long, %{private}lf, %{private}lf
unexpected location notification type received: %{private}d
destroy.hpp
(&l == &rtree::get<leaf>(*m_current_node))&&("invalid pointers")
boost::bad_get: failed value get using boost::get
(&n == &rtree::get<internal_node>(*m_current_node))&&("invalid pointers")
CLSimulationControllerSilo
com.apple.locationd.simulation
SimulatedLocationLatitude
SimulatedLocationLongitude
SimulatedLocationAccuracy
SimulatedLocationType
SimulatedLocationAltitude
SimulatedLocationAltitudeAccuracy
InterpretLifeSpanAsCourseAccuracyInSimulation
CLSimulationController::CLSimulationController(id<CLIntersiloUniverse>)
SimulationController,InterpretLifeSpanAsCourseAccuracyInSimulation,%{public}d
Options
LocationDeliveryBehavior
LocationRepeatBehavior
LocationInterval
LocationSpeed
LocationIntermediateDistance
CLSimulationController
kCLConnectionMessageCircularRegionKey
v16@?0@?<{vector<CLFenceManager_Type::Fence, std::allocator<CLFenceManager_Type::Fence>>=^{Fence}^{Fence}{__compressed_pair<CLFenceManager_Type::Fence *, std::allocator<CLFenceManager_Type::Fence>>=^{Fence}}}@?>8
void CLSimulationController::notifySimulatedLocation_nl(CLDaemonLocation)
@ClxSimulated, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, course, -1.0, time, %{public}.1f
Considering location type for location delivery
CLGnssProvider will be use as location provider
CLNmeaProvider
CLCellLocationProvider
MapMatcher
virtual CLDaemonEmergencyEnablementAssertion::~CLDaemonEmergencyEnablementAssertion()
#CLEEA Releasing EmergencyEnablementAssertion on behalf of %{public}s with reason %{public}s
void CLDaemonEmergencyEnablementAssertion::handleMessageEmergencyEnablementAssertion(std::shared_ptr<CLConnectionMessage>)
#warning EmergencyEnablementAssertion already taken by %{public}s
com.apple.locationd.emergency_enabler
#warning #CLEEA Not entitled as emergency enabler... ignoring EmergencyEnablementAssertion taken by %{public}s
#CLEEA EmergencyEnablementAssertion taken by %{public}s malformed: lacking required argument(s)
#CLEEA Assertion requested with no reason... ignoring EmergencyEnablementAssertion taken by %{public}s
#CLEEA Taking EmergencyEnablementAssertion on behalf of %{public}s with reason %{public}s
bool CLDaemonEmergencyEnablementAssertion::isEntitled(const std::string &)
CLMotionSyncStoreCompanion::CLMotionSyncStoreCompanion(id<CLIntersiloUniverse>)
CLMotionSyncStoreCompanion::CLMotionSyncStoreCompanion(id<CLIntersiloUniverse>)_block_invoke
Timer fired on companion,currentMotionCalsVersion,%d
user
void CLMotionSyncStoreCompanion::onPalUpdateNotification(int, const CLNatalimetryNotifier_Type::Notification &, const CLNatalimetryNotifier_Type::NotificationData &)
void CLMotionSyncStoreCompanion::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
void CLMotionSyncStoreCompanion::sendMotionCalsToWatch()
Phone converted RawSpeedToKValueTable to StrideCalibrationBins to comply with Watch (Major:%d Minor:%d).
Companion sent calibrations to watch: %s
virtual void CLMotionSyncStoreCompanion::deviceUnlocked()
Device is now unlocked.
void CLMotionSyncStoreCompanion::restoreBackupMotionCals()
Clearing a stale vo2max of 0 value.
Loaded Motion Cals from backup: fMotionCals, %s, current version, %d
No motion cal backup file was found at path: %s. Restore PAL.
void CLMotionSyncStoreCompanion::doRestoreBackupMotionCals(const CLMotionSyncStoreCompanion::EDeviceUnlocked *)
restoring backup motion cals
void CLMotionSyncStoreCompanion::doConnected(const CLMotionSyncStoreCompanion::EWatchConnected *)
quickswitch protocol %d
void CLMotionSyncStoreCompanion::doUpdatePAL(const CLMotionSyncStoreCompanion::EPalUpdated *)
PAL is updated from %f to %f
PAL not loaded or changed.
void CLMotionSyncStoreCompanion::doRestoreBackupArbitrate(const CLMotionSyncStoreCompanion::EDeviceUnlocked *)
Restore & Arbitrate
void CLMotionSyncStoreCompanion::doBufferMotionCalsFromWatch(const CLMotionSyncStoreCompanion::ECalibrationFromWatch *)
processing motion cals received from watch
void CLMotionSyncStoreCompanion::doDisconnected(const CLMotionSyncStoreCompanion::EWatchDisconnected *)
void CLMotionSyncStoreCompanion::doArbitrateMotionCals(const CLMotionSyncStoreCompanion::ECalibrationFromWatch *)
arbitration
void CLMotionSyncStoreCompanion::restoreBackupPal()
restore pal
Loaded Motion Cals from PAL: fMotionCals, %s, current version, %d.
void CLMotionSyncStoreCompanion::persistCachedValues()
Asked to persist Motion Cals, current version, %d, isDeviceCurrentlyUnlocked, %d
Companion did not persist Motion Cals, waiting until next unlock, current version, %d, isDeviceCurrentlyUnlocked, %d
Companion persisted calibrations to disk, fMotionCals = %s
virtual void CLMotionSyncStoreCompanion::receiveMotionCals(NSDictionary *)
Companion received calibrations from watch: %s
void CLMotionSyncStoreCompanion::clearMotionCalibrations()
clearing motion calibrations
#Warning Failed to retreive default raw speed to kValue bins.
#Warning Failed to retreive default step cadence to stride length bins.
CLMotionSyncStoreCompanion::ArbitrateResult CLMotionSyncStoreCompanion::arbitrateMotionCals(NSDictionary *, NSDictionary *) const
Buffered: version, %d, UDID, %s, timestamp, %lf, Current: version, %d, UDID, %s, timestamp, %lf, result, %d
void CLMotionSyncStoreCompanion::scheduleFastSendToWatch()
Scheduled send to watch.
CLMotionSyncStoreCompanion::onPalUpdateNotification
CLMotionSyncStoreCompanion::onCompanionNotification
user.plist
-[CLStepDistanceEstimator updateEntryDistanceAndPace:]
#Warning Step count went backwards (%u -> %u). locationd starting? Motion Co-processor reboot?
startTime,%f,timestamp,%f,firstStepTime,%f,lastStepTime,%f,stepsDelta,%u,calibratedDistanceDelta,%f,calibratedPace,%f,rawStrideLength,%f,activeTimeDelta,%f,rawPaceCurrent,%f,rawPaceActive,%f,rawPaceDidJump,%d,stepCadenceCurrent,%f,stepCadenceActive,%f,kValue,%f,pedometerArmConstrainedState,%d,strideLengthFromStepCadence,%f,useStrideLengthFromStepCadence,%d,pushCount,%u,falseStepsSuppressed,%d
Pedometer
CLBluetoothServiceSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/BluetoothService/CLBluetoothService.mm
-[CLBluetoothServiceAdapter beginService]
virtual void CLNotifier<CLBluetoothService_Type::Notification, CLBluetoothService_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLBluetoothService_Type::Notification, NotificationData_T = CLBluetoothService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLBluetoothService_Type::Notification, CLBluetoothService_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLBluetoothService_Type::Notification, NotificationData_T = CLBluetoothService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLBluetoothService_Type::Notification, CLBluetoothService_Type::NotificationData>::removeClient(int) [Notification_T = CLBluetoothService_Type::Notification, NotificationData_T = CLBluetoothService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLBluetoothService_Type::Notification, CLBluetoothService_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLBluetoothService_Type::Notification, NotificationData_T = CLBluetoothService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLBluetoothService_Type::Notification, CLBluetoothService_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLBluetoothService_Type::Notification, NotificationData_T = CLBluetoothService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLBluetoothService_Type::Notification, CLBluetoothService_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLBluetoothService_Type::Notification, NotificationData_T = CLBluetoothService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLBluetoothService_Type::Notification, CLBluetoothService_Type::NotificationData>::listClients() [Notification_T = CLBluetoothService_Type::Notification, NotificationData_T = CLBluetoothService_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLSensorFusion9AxisMekf::CLSensorFusion9AxisMekf(const CFTimeInterval &, const CFTimeInterval &, const CFTimeInterval &, bool)
rotBufferSize9, %zu, accelBufferSize, %zuu, peakCount, %d, compassBufferSize, %zu
gyroDt9, %.4f, doAccelCheck, %d
virtual void CLSensorFusion9AxisMekf::reset()
fAccelBuffer,size,%zu
virtual void CLSensorFusion9AxisMekf::feedGyroData(const double &, const double &, const double &, const CFTimeInterval &)
omegaMag9, %.3f, omega, %.3f, %.3f, %.3f
[AppleQuaternion9] x,%f,y,%f,z,%f,w,%f,timestamp,%f
virtual void CLSensorFusion9AxisMekf::feedGyroBias(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &)
virtual void CLSensorFusion9AxisMekf::feedAccelerometerData(const double &, const double &, const double &, const CFTimeInterval &)
[Accelerometer9] x,%f,y,%f,z,%f,timestamp,%lf
[RotationRate9] %.3f, %.3f, %.3f, %.3f
[KalmanFilterStates9] %f,%f,%f,%f,%f,%f,%f
void CLSensorFusion9AxisMekf::doAccelerometerMeasurementUpdate(double *, double)
[KalmanFilterStates9-AccelUpdate] %f,%f,%f,%f,%f,%f,%f
virtual bool CLSensorFusion9AxisMekf::feedCompassData(const CLMotionTypeCompass &, const bool &, const bool &, const CFTimeInterval &)
[CompassIntoKF] timestamp,%f,calibration level %d, compassHasAlignedToStableField %d, useMagneticRefX %d
[CompassIntoKF] fLastAccelTime,%f
[CompassIntoKF] magneticFieldAdjusted!
rotAroundGrav, %.3f, sum, %.3f
[CompassIntoKF] omegaMag, %.3f, omegaVar, %.3f
FieldDiff, %.3f, %.3f, %.3f, %.3f
Aborted yawUpdate.
Checking again for magField. checkcount, %d
fCorrected, %.3f, %.3f, %.3f
[!!!CompassInertialReference] x,%f,y,%f,z,%f,calibrationLevel,%d,timestamp,%lf
Warning: Compass outputs field magnitude 0.
[!!!CompassInertialReference] x,%f,y,%f,z,%f
UpdatingYaw!
[Magnetometer9] x,%f,y,%f,z,%f,timestamp,%lf
Warning: Hey! Compass outputs field magnitude 0.
float CLSensorFusion9AxisMekf::doCompassMeasurementUpdate(double *, double, int, bool)
[ExpectedCompass] %f,%f,%f,%f
[TrueCompass] %f,%f,%f,%d,%f
[MagCCross] %f,%f,%f,%f,%f,%f,%f,%f,%f,%f
[MagCorrectionDX] %f,%f,%f,angle,%.3f,sumRot,%.3f,%f
static void CLMotionCoprocessorInterface::create(bool)
CLMotionCoprocessorInterface supported but not created.
notindb
CL::Wifi1::Policies::WifiApLookup::Output CL::Wifi1::Policies::WifiApLookup::HandleEvent::lookupMacAddresses(const std::unordered_set<CLMacAddress> &, const std::optional<CLMacAddress> &, const CLDaemonLocation, CL::Wifi1::Policies::WifiApLookup::HandleEvent::Sources) const
@WifiAps, lookiter, %{private}s, %{private}.7f, %{private}.7f, hacc, %{public}1.f, reach, %{public}d, altitude, %{private}.1f, vacc, %{public}.1f
@WifiAps, lookiter, %{private}s, %{public}s
tilesals
alsonly
WlpMetric, aplookup, %{public}d, %{public}d, sources, %{public}s, als, %{public}d, tiles, %{public}d, invalid, %{public}d, unknown, %{public}d
com.apple.clx.wifiloc.aplookup
sources
scanApsBin
tracker && !fClientKey.empty() && !fReason.empty()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLInUseLevelTracker.mm
Assertion
Process state from RunningBoard
Decaying in-use status from process state
CLClientManager_Type::ClientInUseLevel::NotInUse != assertedInUseLevel
getAssertedInUseLevelForClient
(assertionLevel > CLClientManager_Type::ClientInUseLevel::NotInUse) && (assertionLevel < CLClientManager_Type::ClientInUseLevel::Count)
markBalancedClientInUseTransition
newCount >= 0
decrementCountForLevel
CLAvengerScanner
LogOnBody
CLOnBodyNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/OnBody/CLOnBodyNotifier.mm
-[CLOnBodyNotifierAdapter beginService]
CLOnBodyNotifier
virtual void CLNotifier<CLOnBodyNotifier_Type::Notification, CLOnBodyNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLOnBodyNotifier_Type::Notification, NotificationData_T = CLOnBodyNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLOnBodyNotifier_Type::Notification, CLOnBodyNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLOnBodyNotifier_Type::Notification, NotificationData_T = CLOnBodyNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLOnBodyNotifier_Type::Notification, CLOnBodyNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLOnBodyNotifier_Type::Notification, NotificationData_T = CLOnBodyNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLOnBodyNotifier_Type::Notification, CLOnBodyNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLOnBodyNotifier_Type::Notification, NotificationData_T = CLOnBodyNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLOnBodyNotifier_Type::Notification, CLOnBodyNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLOnBodyNotifier_Type::Notification, NotificationData_T = CLOnBodyNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLOnBodyNotifier_Type::Notification, CLOnBodyNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLOnBodyNotifier_Type::Notification, NotificationData_T = CLOnBodyNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLOnBodyNotifier_Type::Notification, CLOnBodyNotifier_Type::NotificationData>::listClients() [Notification_T = CLOnBodyNotifier_Type::Notification, NotificationData_T = CLOnBodyNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
bool CLDualModeKalmanFilter::update(const CLDaemonLocation &, CLDaemonLocation &)
#Warning,KF:invalid update,null island
#Warning,KF:invalid update,hunc<=0
KF:Attempting update,type,%{public}d,lat,%{private}.7f,lon,%{private}.7f,hunc,%{public}.1f,alt,%{private}.3f,vunc,%{public}.3f,conf,%{public}d
KF:Single AP,Dual input rejection,lat,%{private}.7f,lon,%{private}.7f
KF:input should not be rejected after a hard reset
airTravelMode,ltn
KF:Dual rejection,type,%{public}d,lat,%{private}.7f,lon,%{private}.7f,blunder detected
intervalOfInterest,ltn
#Warning,KF:longTermStatic should not fail if longTermNormal succeeded
unexpected,ltn
staticAssumed,lts
notStatic,ltn
bool CLDualModeKalmanFilter::debugPrint(const CLDaemonLocation &, const CLDaemonLocation &, const char *)
KF:Dual,%{public}.3f,%{public}d,%{public}d,%{public}d,%{private}.7f,%{private}.8f,%{private}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}s
KF:calcTPTQ failed
KF:calc_dNdE failed
KF:boundLatitude failed
KF:boundLongitude failed
bool CLKalmanFilter::updateMotion(const CFAbsoluteTime &, const CLMotionActivity::Type &, const CLMotionActivity::Confidence &)
KF:updateMotion failed unexpectedly
KF:Prediction failed
propagation for motion
KF:re-init,uncertainty growth>%{public}.0lf
motion update
activeCellUpdate complete
bool CLKalmanFilter::zupt()
KF:ZUPT failed
KF:ZUPT innovation update failed
KF:updateP failed
zupt, vn update
ZUPT, ve update
bool CLKalmanFilter::update(const CLDaemonLocation &, CLDaemonLocation &, bool &, bool)
KF:P is not dimensioned
KF:x is not dimensioned
lts rejected by distance check
KF:too many consecutive update rejections,KF reset
KF:update with same cell location ignored
KF:increment num rejections by half
KF:re-init,dT>%{public}.0lf
KF:non-GPS within %{public}.1f of GPS,ignoring.
KF:diverged compared to med/high conf WiFi,resetting
KF:seedTheFilter failed
prediction
KF:Transition,coarse GPS to WiFi,hunc bumped,%{public}.1f
KF:computePht_and_hPht failed
KF:sigma2_v <= 0
KF:diverged,%{public}.3lf,reseeding,inputType,%{public}d,lat,v2,%{public}.1lf
KF:reseed,type,%{public}d,%{private}.7lf,%{private}.7lf,%{private}.3lf,hunc,%{public}.1lf,vunc,%{public}.1lf,conf,%{public}d
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,lat,v2,%{public}.1lf
KF:Input is not consistent with prior input. Filter reseeding.
KF:lat innovation update failed
lat update
KF:sanityTestP failed
KF:diverged,%{public}.3lf,reseeding,inputType,%{public}d,lon,v2,%{public}.1lf
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,lon,v2,%{public}.1lf
KF:Input is not consistent with prior input,filter reseeding
KF:lon innovation update failed
lon update
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,vn,v2,%{public}.1lf
KF:vn innovation update failed
vn update
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,ve,v2,%{public}.1lf
KF:ve innovation update failed
ve update
Applying uncertainty floor to stop averaging
KF:Not applying the uncertainty floor
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,alt,v2,%.1lf
KF:getResult failed
KF:Filter corrobarated by type,rejects now allowed
KF:Filter corrobarated by position,rejects now allowed
bool CLKalmanFilter::areRejectedLocationsConsistentAndIndependent()
KF:rejected cell and wifi locations are consistent,filter should reset
KF:rejected cell and coarse-gps locations are consistent,filter should reset
KF:rejected wifi and coarse-gps locations are consistent,filter should reset
bool CLKalmanFilter::sanityTestP()
KF:diagonal element of P < 0
bool CLKalmanFilter::getResult(CLDaemonLocation &, bool)
bool CLKalmanFilter::applyInnovation(const double &, const std::vector<double> &, const double &, const double &, std::vector<double> &)
KF:dN == 0
KF:x is not dimensioned, innovation not applied
KF:k is not dimensioned, innovation not applied
bool CLKalmanFilter::boundLatitude(double &)
KF:latRads,%{private}.7f,out of bounds
bool CLKalmanFilter::boundLongitude(double &)
KF:lonRads,%{private}.7f,out of bounds
bool CLKalmanFilter::seedTheFilter(CLDaemonLocation &)
KF:seedTheFilter,hunc<=0
KF:init P failed
bool CLKalmanFilter::computePht_and_hPht(const std::vector<double> &, const unsigned int &, std::vector<double> &, double &)
#Warning,KF:Pht is not dimensioned
KF:h_index exceeds bounds
bool CLKalmanFilter::updateP(std::vector<double> &, std::vector<double> &, const unsigned int &)
#Warning,KF:P is not dimensioned
KF:k is not dimensioned
bool CLKalmanFilter::initP(std::vector<double> &, const double &, const double &)
KF:initP,hunc <= 0
KF:initP,speedUnc <= 0
#Warning,P was not dimensioned
bool CLKalmanFilter::setQ(const bool &, std::vector<double> &, const CLKalmanFilter::KalmanTuningInfo &, const double &)
KF:dT < 0
KF:tuning invalid
#Warning,KF:Q was not dimensioned
KF:tuning invalid, beta == 0
bool CLKalmanFilter::predictAhead(const CFAbsoluteTime &)
KF:fKalman.dN == 0.0 || fKalman.dE == 0.0
bool CLKalmanFilter::calcTPTQ(const double &, const bool &, std::vector<double> &, std::vector<double> &, const CLKalmanFilter::KalmanTuningInfo &, double &, double &)
#Warning,Q is not dimensioned
KF:beta is zero
KF:setQ failed
#Warning,KF:P is not symmetric
static bool CLKalmanFilter::isLocationTypeNotFiltered(CLLocationType)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Utilities/CLKalmanFilter.cpp
isLocationTypeNotFiltered
bool CLKalmanFilter::debugPrint(const char *, double)
%%1:KF:,2:lts-or-ltn,3:timestamp(s),4:inType,5:outType,6:motionState,7:latitude(deg),8:longitude(deg),9:altitude(m),10:speed(km/hr),11:course(deg),12:hunc(m),13:vunc(m),14:sunc(m/s),15:cunc(deg),16:v_standardized^2
KF:,lt%{public}c,%{public}.3f,%{public}d,%{public}d,%{public}d,%{private}.7f,%{private}.7f,%{private}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}s
update
void CLMobility::WalkingBoutExtractor::handleUserInfoUpdate(const CLBodyMetrics &)
BoutExtractor: Received user info (%s)
void CLMobility::WalkingBoutExtractor::handleSPUGaitMetrics(const CLMobility::SPUGaitMetrics &)
GaitMetrics,startTime,%{public}.2f,timestamp,%{public}llu,walkingSpeed,%{private}.3f,doubleSupportPercentage,%{private}.3f,stepLength,%{private}.3f,asymmetryProbability,%{private}.3f,deviceSide,%{private}hhu,cycleTime,%{private}.3f
GaitMetrics::segmentsRejected,startTime,%{public}.2f,isSwingStanceCycle,%{private}hhu,isNotRunning,%{private}hhu,isFeasibleWalkingSpeed,%{private}hhu,isPendular,%{private}hhu,isSufficientVerticalTwist,%{private}hhu,isCadenceConcordant,%{private}hhu,userHeight,%{private}.2f,isHeightSet,%{public}d,userWeight,%{private}.2f,isWeightSet,%{public}d,
void CLMobility::WalkingBoutExtractor::handleWorkoutSessionOverride(const CLWorkoutUpdate &)
BoutExtractor: Received workout override
bool CLMobility::WalkingBoutExtractor::getTimeRangeToProcess(CFAbsoluteTime &, CFAbsoluteTime &)
BoutExtractor: Unable to get time range to process
BoutExtractor: No bouts in db
Currently in workout predictedType %{public}u activityType %{public}u since (%{public}.2f)
BoutExtractor: All bouts deferred
BoutExtractor: Returned time range to process (%{public}.2f) to (%{public}.2f)
CMError CLMobility::WalkingBoutExtractor::processBouts(CFAbsoluteTime, CFAbsoluteTime, std::vector<HealthKitWorkout>, std::vector<ProcessedBoutResult> &)
BoutExtractor: Checking for bouts from %{public}.2f to %{public}.2f
BoutExtractor: Deferring bout processing. Bouts unavailable.
BoutExtractor: No bouts found.
BoutExtractor: Defering bout processing. Gait Metrics unavailable, likely because device is locked.
BoutExtractor: Defering processing bout (%{public}.2f). Pedometer unavailable.
CLMobility::BoutMetrics,startTime,%{public}.2f,endTime,%{public}.2f,stepCount,%{public}u,walkingSpeed,%{private}.2f,walkingSpeedIsValid,%{public}d,doubleSupportPercentage,%{private}.1f,doubleSupportPercentageIsValid,%{public}d,stepLength,%{private}.2f,stepLengthIsValid,%{public}d,asymmetryProbabilityPercentage,%{private}.0f,asymmetryProbabilityPercentageIsValid,%{public}d,invalidGradePct,%{public}.2f,numGaitMetrics,%{public}d,deviceSide,%{private}s,userHeight,%{private}.2f,isHeightSet,%{private}d,userWeight,%{private}.2f,isWeightSet,%{private}d
CLMobility::BoutMetrics CLMobility::WalkingBoutExtractor::evaluateBout(const CLMobility::BoutBoundary &, const std::vector<GaitMetrics> &, const std::vector<CLStepCountEntry> &)
BoutExtractor: Evaluating Bout -- startTime,%{public}.2f,endTime,%{public}.2f,numberOfGaitMetrics,%{public}lu,numberOfStepCountEntries,%{public}lu
User setting changed mid bout... very weird
User body metric setting changed mid bout from userHeight,%{private}.2f, userWeight,%{private}.2f to userHeight,%{private}.2f, userWeight,%{private}.2f
BoutExtractor: Discarding bout (%{public}.2f) due to insufficient steps: %u
BoutExtractor: Discarding bout (%{public}.2f) due to too much invalid grade. invalidGradePct,%{public}.2f%%,gradeAvailability,%{public}.2f%%
BoutExtractor: Discarding bout (%{public}.2f) due to ineligible workout type: %u
#warning One or more of GaitMetrics rejection counters hit capacity, Bout (%{public}.2f) segment rejection will undercount
WalkingBoutExtractor::MetricAndStatus CLMobility::WalkingBoutExtractor::calculateBoutMetric(CLMobility::QuantityTypeIdentifier, const std::vector<float> &, int) const
BoutExtractor: Discarding %s due to no gait metrics
Unexpected CLMobility::QuantityTypeIdentifier %d
BoutExtractor: Discarding %s due to insufficient gait metrics (%{public}lu/%{public}d)
BoutExtractor: Discarding (%{public}s) due to insufficient gait metrics yield: %{public}.4f
void CLMobility::WalkingBoutExtractor::updateBoundariesWithWorkouts(std::vector<BoutBoundary> &, const std::vector<HealthKitWorkout> &) const
BoutExtractor: Error, unsorted bouts.
BoutExtractor: Error, unsorted workouts.
CMMobilityMetrics::DeviceSide CLMobility::WalkingBoutExtractor::calculateBoutSidedness(const std::vector<DeviceSide> &) const
Bout DeviceSide: %s (left=%.4f, right=%.4f)
WalkingBoutExtractor::PoincareMetrics CLMobility::WalkingBoutExtractor::computePoincareMetrics(const std::vector<float> &) const
Does not meet minimum number of samples criteria for Poincare, size: %lu
double CLMobility::WalkingBoutExtractor::computeEntropy(const std::vector<float> &, const float) const
Does not meet minimum number of samples criteria for Entropy, size: %lu
void CLMobility::StepBoutDetector::handleStepCountNotification(const CLStepCountEntry &)
BoutDetector (%{public}s): Initializing StepCountEntry %{public}.2f
BoutExtractor: Received StepCountEntry -- startTime,%.2f,deltaSteps,%d
BoutDetector (%{public}s): Step count rolled back. boutInProgress, %{public}d, curStepCount, %{private}u, prevStepCount, %{private}u, curStepTime, %{public}.2f, prevStepTime, %{public}.2f
BoutDetector (%{public}s): Active time rolled back. boutInProgress, %{public}d, curActiveTime, %{private}.2f, prevActiveTime, %{private}.2f, curStepTime, %{public}.2f, prevStepTime, %{public}.2f
BoutDetector(%{public}s): #warning, invalid firstStepTime (%{public}.2f)) at start of bout (%{public}.2f)). timestamp=%{public}.2f
BoutDetector(%{public}s): #warning, lastStepTime (%{public}.2f) exceeds startTime (%{public}.2f)). {timestamp=%{public}.2f, activeTime=%{public}.2f, prevStartTime=%{public}.2f}, prevTimestamp=%{public}.2f}, prevActiveTime=%{public}.2f}
ValueInName,%@,ValueOutName,%@,Bin,%02lu,%@,RetrievedValueOut,%f
v32@?0@"CMPedometerBin"8Q16^B24
-[CMPedometerTable updateBinsWithValueOut:valueIn:alpha:]
binIndex %{public}lu invalid
%s,Updated,With,%s,%0.4f,%s,%0.4f,Alpha,%0.4f,NativeBinIndex,%lu,OldBinStatus,%s,NewBinStatus,%s
v32@?0@"CMStrideCalibrationData"8Q16^B24
Nautilus_Precision
com.apple.store.Jolly
Fence, 
, refFrame, 
, distance, 
, eFistance, 
, lDown, 
, time, 
, ctime, 
, flags, 
, key, 
, throttled, 
, polygon, 
{ "vertices": [ 
{"latitude": 
, "longitude": 
, {"latitude":
,"longitude":
 ] }
\b(?:ms|m/s|mail\s?stop)(?:\s*:)?\s#?(((?:\d+-)[a-z]*\d+[a-z]*)|((?:\d+-)[a-z0-9]*)|([a-z]*\d+[a-z]*))\b
\b(?:piso|niveau|floor|fl|fl.|lv|lvl|level)\s(\d+)\b
\b(?:c p|cp|cas(?:e|ier) postal(?:e?)|postfach|po box|box|p o box|p\s*\.\s*o\s*\.\s*box)\s+(?:#|no\s+)?(\d+)\b
^(\d+)\s(?:po box|p o box|p\s*\.\s*o\s*\.\s*box)(?!\s[a-z]\s)
(\b((suite|suit|ste|stes|apartment|app|apt|bureau|unit|apto|flat|cube)\.?(\s|[.]|-))|#\s*)#?((?:\d+|\S+-\S+|\w?\d*\w?)\b(?:\s*&\s*(?:\d+|\S+-\S+|\w?\d*\w?))?)
(\b(suite|suit|ste|apartment|app|apt|bureau|unit|apto|flat)\s+#)(\d+[a-z]{0,2})\b
\b(frnt)\s*(\d+)\b
(\b((building|bldg)\.?(\s|[.]|-)))#?((?:\d+|\S+-\S+|\w?\d*\w?)\b(?:\s*&\s*(?:\d+|\S+-\S+|\w?\d*\w?))?)
(\b(building|bldg)[\s|\s#])(\d+[a-z]{0,2})\b
(\b((room|office)\.?(\s|[.]|-)))#?((?:\d+|\S+-\S+|\w?\d*\w?)\b(?:\s*&\s*(?:\d+|\S+-\S+|\w?\d*\w?))?)
(\b(room|office))(\d+[a-z]{0,2})\b
\b(?:north|south|east|west)\swing\b
CLPlaceInferenceSubscription::CLPlaceInferenceSubscription(CLTransientSubscriptionBase::Delegate *, id<CLIntersiloUniverse>, CLClientManagerAuthorizationContext *, const CLClientManager_Type::Name &)_block_invoke
#dsa client '%{public}s' starts receiving CLPlaceInferenceSubscription updates
void CLPlaceInferenceSubscription::initializePlaceInferencesOptions(_CLFidelityPolicy)
#dsa Please update initializePlaceInferencesOptions
void CLPlaceInferenceSubscription::startFetchingRTPlaceInferencesWithOptions()_block_invoke
#dsa RECEIVED RESPONSE in handler %{public}lu mapItems, error: %{public}@ in startFetchingRTPlaceInferencesWithOptions
#dsa mecard returned error %@
v24@?0@"NSDictionary"8@"NSError"16
void CLPlaceInferenceSubscription::getMeCardAddressFromCachedContacts(NSArray<CLLocation *> *, CLCallbackDropper, _CLPlaceInference *)
#dsa %{private}@ address is %{public}.2f away from current location 
#dsa adding mecard address %{private}@,deviation,%{public}.2f
#dsa no valid address in contacts.skip sending dsa %lu
void CLPlaceInferenceSubscription::enumerateOverAddressDictionaryAndSendInferredResults(NSDictionary<NSNumber *,NSArray<NSString *> *> *, NSError *, CLCallbackDropper, NSArray<CLLocation *> *, _CLPlaceInference *)_block_invoke
#dsa address type in mecard is %@, %{private}@, %@{private}
#dsa geocode returned error %@
void CLPlaceInferenceSubscription::fetchFormattedAddressAndSendResults(_CLPlaceInference *, NSString *, CLCallbackDropper)_block_invoke
#dsa fetchformattedaddress returned error %@
void CLPlaceInferenceSubscription::sendUpdatedEmergencyPlaceInference(_CLPlaceInference *, NSArray<NSString *> *, NSString *)
#dsa meCardAddress  %{private}@
#dsa fetchformattedaddress received %{private}@, updated address in placemark  %{private}@, address in mecard %{private}@
double CLPlaceInferenceSubscription::calculateDistanceBetweenLocations(CLLocation *, NSArray<CLLocation *> *)
#dsa mecard geodetic location,lat,%{private}.7f,lon,%{private}.7f,currentlat,%{private}.7f,currentlon,%{private}.7f,distance,%{public}.2f
NSMutableArray<_CLPlaceInference *> *CLPlaceInferenceSubscription::processRoutineResponseForEmergency(NSArray<RTPlaceInference *> *, NSArray<CLLocation *> *)
#dsa invalid usertype and sourcetype, confidence,%{public}.2f,last confidence,%{public}.2f,loisource,%{public}@,userType,%d
#dsa invalid hunc, confidence,%{public}.2f,last confidence,%{public}.2f,loisource,%{public}@,userType,%d
#dsa invalid confidence, confidence,%{public}.2f,last confidence,%{public}.2f,loisource,%{public}@,userType,%d
#dsa zone of confusion,dropping dsa,current confidence,%{public}.2f,last confidence,%{public}.2f,confidenceinpercent,%{public}.2f,loisource,%{public}@,userType,%d
#dsa mapitem's geodetic location ,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f, currentlat,%{private}.7f,currentlon,%{private}.7f,currentacc,%{public}.2f,dist,%{public}.2f, currconf,%{public}.2f,loisource,%{public}@
#dsa updated mapItem after cross-check ,maplat,%{private}.7f,maplon,%{private}.7f,updatedacc,%{public}.2f,origacc,%{public}.2f, usertype,%{public}d, placeType,%{public}d,inferredconf,%{public}.2f
#dsa did not meet the emergecy confidence and distance requirement,distance,%{public}.2f,confidence,%{public}.2f
placeinference
kCLConnectionMessagePlaceInferencePlaceInferenceKey
kCLConnectionMessagePlaceInferencePlaceInferenceFallbackLocationKey
com.apple.locationd.place_inference
com.apple.locationd.emergencyplace_inference
kCLConnectionMessagePlaceInferenceFidelityPolicyKey
void CLPlaceInferenceSubscription::handleRequestPlaceInference(std::shared_ptr<CLConnectionMessage>)
#dsa client '%{public}s' not authorized for location; not starting yet in handleRequestPlaceInference
#dsa client '%{public}s' not authorized for Emergency Fidelity policy
kCLConnectionMessagePlaceInference
kCLConnectionMessagePlaceInferenceStop
void CLPlaceInferenceSubscription::shutDownCurrentSessionWithReason(const char *)
#dsa client '%{public}s %{public}s'; stopping place inference location and wifi scans
authorization status changed for location
lost precise location authorization
void CLPlaceInferenceSubscription::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#dsa received unhandled notification %{public, location:CLLocationProvider_Type::Notification}d In onLocationNotification
void CLPlaceInferenceSubscription::onWifiServiceNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
#dsa empty accessPoints, %{pubic}s
#dsa received unhandled notification %{public, CLWifiService_Type::Notification}d In onWifiServiceNotification
CLPlaceInferenceSubscription::onLocationNotification
CLPlaceInferenceSubscription::onWifiServiceNotification
Name
Thoroughfare
SubThoroughfare
City
SubLocality
State
SubAdministrativeArea
CountryCode
Country
InlandWater
Ocean
FormattedAddressLines
_CLPlaceInferenceUserSpecificPlaceType userSpecificPlaceTypeFromRTUserType(RTPlaceInferenceUserSpecificPlaceType)
#dsa Please update userSpecificPlaceTypeFromRTUserType
_CLPlaceInferencePlaceType placeInferencePlaceTypeFromRTPlaceType(RTPlaceInferencePlaceType)
#dsa Please update placeInferencePlaceTypeFromRTPlaceType
Inferred
MeCard
User
kCLConnectionMessagePlaceInferenceError
kCLConnectionMessagePlaceInferenceResult
void CLMotionStateObserverWatch::stopSessionAndTimer()
MotionStateObserver, Disabling update timer.
void CLMotionStateObserverWatch::sendSessionUpdate()
MotionStateObserver, Sending session update, user type, %d, predicted type, %d
virtual void CLMotionStateObserverWatch::handleCompanionNotification(const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
MotionStateObserver,RemoteState,startTime,%.3f,activityType,%d,vehicularConfidence,%d
CLMotionStateObserverWatch::onMotionStateMediatorNotification
kCLHarvestStatus
kCLHarvestLocation
kCLHarvestGpsLocation
kCLHarvestMotionState
kCLHarvestTelephony
kCLHarvestPassKit
kCLHarvestLeechedVisit
kCLHarvestWifi
clientKey
operationType
vectorClocks
interestZones
-[CLCompanionSyncAuthObject writeTo:]
CLCompanionSyncAuthObject.m
nil != self->_clientKey
UPDATE
DELETE
CLPressureCalibrationDatabaseSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/SensorCalibration/CLPressureCalibrationDatabase.mm
-[CLPressureCalibrationDatabaseAdapter beginService]
CLPressureCalibrationDatabase
KeepAllSensorCalibrationRoundsInDb
PressureCalibration
virtual void CLPressureCalibrationDatabase::startCalibration(bool)
Starting pressure calibration, user initiated, %d
Pressure dispatcher was expected to be null.
fPoints.empty() || fPoints.rbegin()->round >= 0
beginRun
virtual void CLPressureCalibrationDatabase::endRun()
temperatureOffsetCoefficient,%f,medianAbsoluteDeviation,%f,minTemp,%d,maxTemp,%d,valid,%d
virtual void CLPressureCalibrationDatabase::teardown()
Stopped pressure calibration
SELECT Round, TemperatureOffsetCoefficient, MedianAbsoluteDeviation FROM PressureCalibration WHERE Round IN (SELECT DISTINCT Round FROM PressureCalibration ORDER BY Round DESC LIMIT ?) ORDER BY Round
void CLPressureCalibrationDatabase::loadFromDatabase()
SQL error: %s
IOPropertyMatch
static void CLPressureCalibrationDatabase::readFactoryData(CLMotionTypePressureBiasFit &)
Cannot get SPPO property
data not long enough to get version properly
SPPO version (%u) does not match expected versions (%u, %u)
factory calibrated temperature from syscfg: %f
Warning: factory calibrated temperature (%f) is not within acceptable bounds: [%f, %f], using default: %f
Warning: using default factory calibrated temperature: %f
DELETE FROM PressureCalibration WHERE Round <= ?
Round
TemperatureOffsetCoefficient
MedianAbsoluteDeviation
fPoints.empty() || fPoints.rbegin()->round < fPendingPoint.round
updatePoints
static bool CLPressureCalibrationDatabase::computeMedianTemperatureOffsetCoefficient(const std::vector<TemperatureOffsetCoefficientRound>, CLMotionTypePressureBiasFit &)
size of tco list (%lu) is less than minimum (%d) required for median computation
void CLPressureCalibrationDatabase::onPressureData(const CLPressure::Sample *)
pressure,%f,temperature,%f,timestamp,%f
CLPressureCalibrationDatabase::onPressureData
name
pressure-offset-calibration
getMedianInPlace
CMPressureUtilities.h
size > 0
virtual void CLNotifier<CLPressureCalibrationDatabase_Type::Notification, CLPressureCalibrationDatabase_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLPressureCalibrationDatabase_Type::Notification, NotificationData_T = CLPressureCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLPressureCalibrationDatabase_Type::Notification, CLPressureCalibrationDatabase_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLPressureCalibrationDatabase_Type::Notification, NotificationData_T = CLPressureCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLPressureCalibrationDatabase_Type::Notification, CLPressureCalibrationDatabase_Type::NotificationData>::removeClient(int) [Notification_T = CLPressureCalibrationDatabase_Type::Notification, NotificationData_T = CLPressureCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPressureCalibrationDatabase_Type::Notification, CLPressureCalibrationDatabase_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLPressureCalibrationDatabase_Type::Notification, NotificationData_T = CLPressureCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPressureCalibrationDatabase_Type::Notification, CLPressureCalibrationDatabase_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLPressureCalibrationDatabase_Type::Notification, NotificationData_T = CLPressureCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPressureCalibrationDatabase_Type::Notification, CLPressureCalibrationDatabase_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLPressureCalibrationDatabase_Type::Notification, NotificationData_T = CLPressureCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLPressureCalibrationDatabase_Type::Notification, CLPressureCalibrationDatabase_Type::NotificationData>::listClients() [Notification_T = CLPressureCalibrationDatabase_Type::Notification, NotificationData_T = CLPressureCalibrationDatabase_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLCapabilityMonitorSilo
-[CLCapabilityMonitor setSupervised:]
supervised capability changed from, %d, to, %d
v32@?0@"ACAccount"8Q16^B24
v24@?0@"ACAccountType"8@"NSError"16
-[CLCapabilityMonitor setICloudManagedAppleID:]
iCloud managed apple ID capability changed from, %d, to, %d
com.apple.education
v32@?0@"MCPayload"8Q16^B24
-[CLCapabilityMonitor setInstalledEducationProfile:]
installed education profile capability changed from, %d, to, %d
-[CLCapabilityMonitor setITunesManagedAppleID:]
iTunes managed apple ID capability changed from, %d, to, %d
-[CLCapabilityMonitor onDarwinNotification:data:]
received unhandled notification, %{public}d
CLNONEDU
CLSupervised
CLNonSupervised
CLInstalledProfileEducation
CLNonManagedAppleID
CLHeadingCompass
CLSystemCustomization
v24@?0@"<CLCapabilityMonitorClientProtocol>"8^B16
std::optional<CL::Wifi1::Decisions::AlsRequest> CL::Wifi1::Policies::AlsQuery::HandleEvent::defaultAlsRequestLogicUsedWhenComputingLocation(const CL::Wifi1::Policies::AlsQuery::Input &, const std::optional<CLWifiService_Type::ScanType> &) const
proceed #alsquery eval due to 5GHz scan, since_last_query_secs, %d
blocking #alsquery, too soon, since_last_query_secs, %d
#alsquery number of aps in scan history, %lu
allknown
nonstandard
watch
unknownassociated
sufficient
knownratio
defer5Ghz
unknownratio
#alsquery, do_query, %d, reason, %s
@WifiFlow, alsrequest, %{public}d, %{public}s, aps, %{public}lu, type, %{public}d, vni, %{public}ld, %{public}ld, %{public}ld
#alsquery, create_request, %lu, use_cache, %d, query_nearbys, %d, config, %{public}s
static std::optional<Decisions::AlsRequestForWsb> CL::Wifi1::Policies::AlsQuery::HandleEvent::shouldQueryForWsb(const CL::Wifi1::Policies::AlsQuery::Input &, Types::WsbPassType)
WsbAls, query, %{public}d, %{public}s, unknown, %{public}ld
EnableAlwaysOnActivityContext
CLLocationFilterController::CLLocationFilterController(id<CLIntersiloUniverse>)
registered for kNotificationContext
registered for kNotificationContextSpectator
MapMatchingGeometryType
CLMM,MapMatchingGeometryType,%{public}s
CLLocationFilterController
CLMM, PlatformSupportsMapMatching, %{public}d
OBM,fPlatformSupportsOutdoorMatching,%{public}d
EnableNMEAMapMatching
CLMM, EnableNMEAMapMatching, %{public}d
EnableVerboseMapMatching
CLMM, EnableVerboseMapMatching, %{public}d
ObmVerboseLogging
PLOS, ObmVerboseLogging, %{public}d
MapMatchingNetworkUsageThermalLevelHighThreshold
CLMM, MapMatchingNetworkUsageThermalLevelHighThreshold, %{public}d
MapMatchingNetworkUsageThermalLevelLowThreshold
CLMM, MapMatchingNetworkUsageThermalLevelLowThreshold, %{public}d
GroundAltitudeLookUpEnabled
DEM,GroundAltitudeLookUpEnabled,%{public}d
CLDigitalElevationModel
void CLLocationFilterController::adjustLocationUncertaintyForAppleMapsDrivingUseCase(CLDaemonLocation &)
Raven,%.2lf,Client location horizontal unc modified from,%.2lf,to,%.2lf
void CLLocationFilterController::setMapMatchingRouteHint(const CLMapsRouteHintData &)
CLMM,RouteHints,CLLocationFilterController,setMapMatchingRouteHint, %{public}d
void CLLocationFilterController::onMotionNotification(int, const CLMotionState_Type::Notification &, const CLMotionState_Type::NotificationData &)
#Warning unexpected kNotificationMovementCoarse
Unhandled case
Going to sleep. Not providing motion state, %{public}d, to the location KF
CLMM, MotionState,type,%{public}d,confidence,%{public}d,mountedState,%{public}d,mountedConfidence,%{public}d
OBM, MotionState,type,%{public}d,confidence,%{public}d,mountedState,%{public}d,mountedConfidence,%{public}d
#Warning Unknown notification %{public}d
void CLLocationFilterController::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
device entering sleep - no longer has active cell
device wake - checking for corresponding sleep
#Warning wake detected with no prior sleep known, sending unknown motion to location KF at time, %{public}.3lf
CLMM,Battery notification,level,%{public}.2lf,charged,%{public}d,connected,%{public}d,wasConnected,%{public}d
void CLLocationFilterController::onSignalEnvironmentNotification(int, const CLSignalEnvironmentProvider_Type::Notification &, const CLSignalEnvironmentProvider_Type::NotificationData &)
priorSignalEnvironment,%{public}d,newSignalEnvironment,%{public}d,fidelity,%{public}d
void CLLocationFilterController::updateAirborneActivity(const bool)
CLMM,isAirborne,%{public}d
void CLLocationFilterController::onMapMatcherStopped()
CLMM,onMapMatcherStopped,timer triggered
CLMM,onMapMatcherStopped,road tiles cleared from process memory
CLLocationFilterController::onMotionNotification
CLLocationFilterController::onDaemonStatusNotification
CLLocationFilterController::onSignalEnvironmentNotification
{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}8@?0
static void CLWifiFenceCalculator::initStaticGlobals()
FenceCal: init globals
WifiFenceCalculatorDebug
FenceCal: Overriding WifiFenceCalculatorDebug =%d
WifiFenceCalculatorDebugVerbose
FenceCal: Overriding WifiFenceCalculatorDebugVerbose =%d
WifiFenceCalculatorMinNumAPs
FenceCal: Overriding WifiFenceCalculatorMinNumAPs =%d
WifiFenceCalculatorSTDFactorMeters
FenceCal: Overriding WifiFenceCalculatorSTDFactorMeters = %5.1lf
WifiFenceCalculatorRadiusFactor
FenceCal: Overriding WifiFenceCalculatorRadiusFactor = %5.1lf
WifiFenceCalculatorMaxFenceRadius
FenceCal: Overriding WifiFenceCalculatorMaxFenceRadius = %5.1lf
WifiFenceCalculatorMaxChosenAPs
FenceCal: Overriding WifiFenceCalculatorMaxChosenAPs = %d
WifiFenceCalculatorMaxApsPerTileFactor
FenceCal: Overriding WifiFenceCalculatorMaxApsPerTileFactor = %lf
WifiFenceCalculatorSignificantScoreUpdateThresh
FenceCal: Overriding WifiFenceCalculatorSignificantScoreUpdateThresh = %lf
WifiFenceCalculatorGroupWeightForExit
FenceCal: Overriding WifiFenceCalculatorGroupWeightForExit = %d
WifiFenceCalculatorMinApsPerFence
FenceCal: Overriding WifiFenceCalculatorMinApsPerFence = %d
WifiFenceCalculatorDefaultMaxChannelSetSize
FenceCal: Overriding WifiFenceCalculatorDefaultMaxChannelSetSize = %d
WifiFenceCalculatorDefaultChannelFilter
FenceCal: Overriding WifiFenceCalculatorDefaultChannelFilter = %d
WifiFenceCalculatorAPsScoreFilter
FenceCal: Overriding WifiFenceCalculatorAPsScoreFilter = %d
CLWifiFenceCalculator::CLWifiFenceCalculator(unsigned int, int)
FenceCal: fMaxChannelSetSize, %{private}d, kMaxChannel, %{private}d, fChannelFilter, 0x%{private}X, fDefaultChannelFilter, 0x%{private}X
bool CLWifiFenceCalculator::calculateScore(CLWifiFenceCalculator::Score &)
bad CLStandardNormalDistribution(%{public}lf) = %{public}lf
bool CLWifiFenceCalculator::addScore()
FenceCal: Adding score, fence, %{private}20s, score, %{private}.8lf, min, %{private}.8lf, avg, %{private}.8lf, max, %{private}.8lf, scores, %{private}lu, aps, %{private}zu
#Warning fChosenAPs is empty
bool CLWifiFenceCalculator::calculate(CLWifiAccessPointLocationService &, const CLFenceManager_Type::CombinedFence &, bool, bool)
FenceCal: start calculate fence, %{private}-24s, C, center, %{private}.8lf, %{private}.8lf, radius, %{private}.8lf, isMonitorForExit, %{private}d
FenceCal: really bad fence, %{private}s
FenceCal: limit ePNO fence size, fence, %{private}s, fMaxRadius, %{private}.1lf
Invalid fence name, %{private}s, latitude, %{private}lf, longitude, %{private}lf, radius, %{private}lf
FenceCal: tile, y, %d, x, %d, index, %d, distanceFromCenter, %5.5lf, maxApsPerTile, %d, ApsFactor, %.5lf
FenceCal: fetched, %{public}ld, APs, forceFetchingExpectedAps, %{public}d
FenceCal: expectedAp, %{private}s
tileIndex < fTiles.size()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLWifiFenceCalculator.mm
calculate
FenceCal: ap2Tile, %s, maxApsPerTile, %2d, left, %4d, top, %4d, tile, %4d, mac, %-24s, numAPs %4zu
FenceCal: chosen, %{private}lu, expected, %{private}lu, fence, %{private}s
FenceCal: calTile, %2zu : %3d / %3zu, %.8lf, %.8lf, FF0000FF
static bool CLWifiFenceCalculator::addAPToOutput(const CLWifiAPLocation &, bool, std::map<CLMacAddress, CLWifiAPLocation> &, std::map<CLMacAddress, CLWifiAPLocation> &, unsigned int, const std::map<CLMacAddress, CLWifiAPLocation> &, unsigned int, const char *)
FenceCal: avoid adding moving AP as an exit AP, %{private}s
FenceCal: adding non-2GHz, reason: %{private}s, %{private}s
FenceCal: Adding AP, reason, %s, channelFilter, 0x%08x, isExit, %d, currentCount, %zu, apsBudget, %u , mac, %s, hAcc, %.2lf, channel, %d, location, %12.8lf, %12.8lf, added, %d
static unsigned int CLWifiFenceCalculator::calculateChannelHistogram(const std::vector<CLWifiFenceCalculator> &, CLWifiFenceCalculator::ChannelHistogram &)
FenceCal: isAddChannel, %d, maxChannelSetSize, %d, totalAps, %.0lf, channelHistogram, sorted, channel, %2d, weight, %.3lf
FenceCal: addedChannels, %{private}d, channelFilter, 0x%{private}08x, totalWeight, %{private}.3lf
static bool CLWifiFenceCalculator::calculateGroup(CLWifiAccessPointLocationService &, std::vector<CLWifiFenceCalculator> &, const unsigned int, const std::vector<CLWifiService_Type::AccessPoint> &, std::optional<CLWifiService_Type::AccessPoint>, std::map<CLFenceManager_Type::Fence, int> &, std::map<CLMacAddress, CLWifiAPLocation> &, std::map<CLMacAddress, CLWifiAPLocation> &, const CLDaemonLocation &, double)
FenceCal: calculateGroup, start, group size, %zu, apsBudget, %u, currentlySeen, %zu, minScoreThresh, %.4lf
FenceCal: channelFilter, 0x%{private}08X,countNumOfSetBits,%{private}d
fencecalculator timestamp is 0
associated
CurrentlySeen
FenceCal: before devaluing, apLocation, %{private}s
FenceCal: devaluing, distanceToExpectedApLocation, %{private}.1lf, distanceToFenceCenter, %{private}.1lf
FenceCal: after devaluing, apLocation, %{private}s
FenceCal: devaluing, fence, %{private}s, result.fChosenAPs, %{private}lu, isExit, %{private}d
FenceCal: fence, %s, group pass, %3d, currentWeight, %3d, %3d, score, %+.4lf, newScore, %+.4lf, minScoreThresh, %+.4lf, totalChosenAps, %d, apsBudget, %d
FenceCal: fence, %s, group pass, %3d, currentWeight, %3d, %3d, upgrading score from, %.4lf, to, %.4lf, from, %4zu, to, %4zu, APs, index, %2d, totalChosenAps, %d, apsBudget, %d
FenceCal: fence, %s, score too close, currentScore, %lf, newScore, %lf, significantUpdateThresh, %lf, updating next step to, %d
FenceCal: passNum, %d, commitedAPs, %d, totalChosenAps, %d, numOfAps, %zu
FenceCal: group result, %{private}30s, totalChosenAps, %{private}4d, apsBudget, %{private}4d, index, %{private}4zu , %{private}4zu, aps, %{private}4zu, %{private}4zu, score, %{private}.2lf, index, %{private}4d, dbgCounter, %{private}4d
FenceCal: group result, %{private}30s, can't be monitored
#Warning FenceCal: no score for, %{private}s, fChosenAps, %{public}4zu
FenceCal: chosenScore, %-16s, fChosenScoreIndex, %4d, numOfAps, %4zu, %4zu, score, %.2lf
FenceCal: topping, %{public}zu, apsBudget, %{private}u
FenceCal: Topping, %{private}s, fChosenScoreIndex, %{private}d, total, %{private}zu
FenceCal: topping, from APs, %{private}zu, to APs, %{private}zu
FenceCal: finised topping, %{private}zu, apsBudget, %{private}u
FenceCal: fence, %s, isExit, %d, fChosenScoreIndex, %d, fChosenAPs, %zu, fChosenAPsScores, %zu, canBeMonitored, %d, canBeMonitoredInGroup, %d, numOfExitFences, %u
FenceCal: calculateGroup, end, return val, isOK, %d, numOfFences, %zu, numOfExitFences, %d, combinedCanMonitor, %d, combinedCanMonitorGroup, %d, combinedCanMonitorExitGroup, %d
Return entry AP, index, %2zu, %2zu, %s
Return exit AP, index, %2zu, %2zu, %s
static void CLWifiFenceCalculator::sortCalculatorGroup(const CLDaemonLocation &, std::vector<CLWifiFenceCalculator> &)
FenceCal: fDistanceFromCurrentLocation, %{private}.2lf, %{private}s
calculateWeightedScore
CLWifiFenceCalculator.mm
uncertainty > 0.0f
score > -1.0f
const CLWifiFenceCalculator::Score &CLWifiFenceCalculator::getChosenGroupScore() const
dCOLLECT: no chosen score, was calculateGroup called?
SignificantChangeManager
CLSignificantChangeManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLSignificantChangeManager.mm
-[CLSignificantChangeManagerAdapter beginService]
FenceManager
SLCAwarenessParameters
SLCShowUI
CLSignificantChangeManager::CLSignificantChangeManager(id<CLIntersiloUniverse>)
#SLC gSLCShowUI, %d
SLCConsolidateTriggersEnabled
#SLC fIsConsolidateTriggersEnabled, %d
SLCConsolidatedTriggersTimeInterval
#SLC fConsolidatedTriggersTimeInterval, %.1lf
#SLC failed to allocate, fConsolidatedTrigger
void CLSignificantChangeManager::handleSignificantLocationChange(CLDaemonLocation)
#SLC handleSignificantLocationChange, distance, %.1lf, timeDelta, %.1lf, maxFactor, %.1lf
#SLC <%+.8f,%+.8f> acc %.2f timestamp %.2f is stale, discarding
#SLC <%+.8f,%+.8f> acc %.2f moved only %.2fm from previous significant location <%+.8f,%+.8f> acc %.2f, discarding
#SLC Lifespan of previous significant location <%+.8f,%+.8f> acc %.2f has not expired (timestamp %.2f, lifespan %.2f), discarding <%+.8f,%+.8f> acc %.2f
#SLC Timestamp %.2f of previous significant location <%+.8f,%+.8f> is less than %.2f seconds ago; discarding <%+.8f,%+.8f> acc %.2f
#Warning #SLC Location <%+.8f,%+.8f> acc %.2f is too far (distance %.2f) from previous location <%+.8f,%+.8f> acc %.2f from %.3fs ago, discarding
#SLC avoiding too frequent SLC notificaitons, age, %.1f, prev location, <%+.8f,%+.8f>, acc, %.2lf, new location, <%+.8f,%+.8f>, acc, %.2f
#SLC issue notificaiton, distance, %.1lf
#SLC got first location, sending SLC notification
#SLC no location change
#SLC reporting a location change
#SLC new location is not useful
slcUpdate
hAcc
secondsSinceLastSLC
SignificantChange
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Lifespan,%.2f,LocationType,%d,PrevLocation,%+.8f,%+.8f,%.2f,Distance,%.2f,DeltaTime,%.3f,
void CLSignificantChangeManager::onStartSLC(CLPersistentTimer *)
#SLC Booting up
void CLSignificantChangeManager::refreshSettings()
#SLC onSettingsNotification
SpoofSignificantLocationChange
Timestamp
HorizontalAccuracy
#SLC Spoofing a Significant Location Change: %s
void CLSignificantChangeManager::onConsolidatedTrigger()
#SLC ignore, onConsolidatedTrigger, shutdown?
#SLC onConsolidatedTrigger, calling requestLocationUpdate
CLSignificantChangeManager
CLSignificantChangeManager::onClientNotification
CLSignificantChangeManager::onAwarenessNotification
bool CMSensorFusionSwimMekf::initializeAttitude(const CMVector3d &, const CMVector3d &, float)
northAndGravity failed
invalid initializeDown covariance !(P > 0), reseting
const CMVectorBufferBase::Element CMVectorBufferBase<float, 3>::mean(size_t, size_t) const [T = float, N = 3]
Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 93,mean() on empty buffer.
bool CMFactoredMatrix<float, 3>::factor(const CMMatrix<T, N, N> &) [T = float, N = 3]
D(%zu) <= 0 non-positive definite matrix!
T &CMFactoredMatrix<float, 3>::UnitaryUpperTriangularMatrix::operator()(size_t, size_t) [T = float, N = 3]
Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 209,invalid col %zu > %zu.
Assertion failed: col > row, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 210,invalid element %zu <= %zu.
T &CMFactoredMatrix<float, 3>::DiagonalMatrix::operator()(size_t) [T = float, N = 3]
Assertion failed: row < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 163,invalid row %zu > %zu.
CMVectorBufferBase::Element CMVectorBufferBase<float, 3>::back() const [T = float, N = 3]
Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 145,back() on empty buffer.
T CMFactoredMatrix<float, 3>::UnitaryUpperTriangularMatrix::operator()(size_t, size_t) const [T = float, N = 3]
Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 203,invalid col %zu > %zu.
Assertion failed: col > row, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 204,invalid element %zu <= %zu.
T CMFactoredMatrix<float, 3>::DiagonalMatrix::operator()(size_t) const [T = float, N = 3]
Assertion failed: row < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 158,invalid row %zu > %zu.
void CMFactoredMatrix<float, 3>::thorntonTemporalUpdate(CMMatrix<T, N, N> &, const CMVector<T, N> &) [T = float, N = 3]
D[%zu] <= 0, matrix ! positive definite
bool CMFactoredMatrix<float, 3>::solve(CMVector<T, N> &) const [T = float, N = 3]
D[%zu] == 0, semidefinite matrix!
CMVector<T, N> CMFactoredMatrix<float, 3>::biermanObservationalUpdate(const CMMatrix<T, P, N> &, const CMVector<T, P> &, const CMVector<T, P> &) [T = float, N = 3, P = 3]
%zu: alpha <= 0, matrix ! positive definite
T CMQueue<float>::getComparison(int (*)(const T, const T), size_t) const [T = float]
Assertion failed: n > 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMQueue.h, line 191,.
CLApplicationLifecycleManagerSilo
+[CLApplicationLifecycleManagerAdapter isSupported]_block_invoke
ALM: not supported on this platform because FrontBoardServices.framework is not present
ALM: not supported on this platform because AssertionServices.framework is not present
locationd.fence
void CLApplicationLifecycleManager::launchApplication(const std::string &, CLClientServiceTypeMask)
%s doesn't have a bundle ID; not going to bug SpringBoard.
ALM: %{private}s isn't running; launching...
CLLaunchOptionsLocation
void CLApplicationLifecycleManager::launchApplication(const std::string &, CLClientServiceTypeMask)_block_invoke
#Warning Couldn't launch application %s (%s)
v24@?0@"BSProcessHandle"8@"NSError"16
void CLApplicationLifecycleManager::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)
notification, %d, %s, pid, %d, bundleId, %s
#Warning unhandled app monitor notification, %d, %s
void CLApplicationLifecycleManager::onDataProtectionManagerNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
ALM: device unlocked since boot, %{private}s, application launch capability, %{private}sabled
CLApplicationLifecycleManager::onAppMonitorNotification
CLApplicationLifecycleManager::onDataProtectionManagerNotification
bool CLKappaPulseTimeAligner::feedFastAccel(const CMMotionCoprocessorReply::KappaSensorDataFastAccel &)
accel queue full @ %lld, %llu; reset; DM queue size %u
accel gap %llu reset
cannot interpolate because dT %llu large
void CLKappaPulseTimeAligner::feedDM(const CMMotionCoprocessorReply::KappaSensorDataDeviceMotion &)
DM queue full, reset; DM time: %llu
bool CLKappaPulseTimeAligner::alignAccelDM()
old accel %llu vs DM %llu, discarding
old DM %llu old vs accel %llu, discarding
alignAccelDM precondition violation
old dT idx %u, dist_before %llu, dist_after %llu
void CLKappaPulseTimeAligner::reset()
reset accel pre alignment queue %llu ~ %llu
reset DM pre alignment queue %llu ~ %llu
const T &CMQueue<CMMotionCoprocessorReply::KappaSensorDataDeviceMotion>::operator[](const size_t) const [T = CMMotionCoprocessorReply::KappaSensorDataDeviceMotion]
%02X
saved
CLGestureNotifier
GestureRecognitionAccelerometerInterval
GestureRecognitionEnableDynamicAccelerometerRate
CLGestureNotifier::CLGestureNotifier()
Enable dynamic accelerometer rate = %{public}d
.dat
void CLGestureNotifier::setGestureClassifier(const std::string &)_block_invoke
Using prototype: %{private}s
void CLGestureNotifier::startDetectingGestures()
Not starting gesture detection since requested accelerometer interval < 0
No accelerometer; not detecting gestures
Gesture prototype was not setup. Using default prototype
void CLGestureNotifier::stopDetectingGestures()
virtual void CLGestureNotifier::numberOfSpectatorsChanged(int, size_t)
CLSensorFusionService9Axis::CLSensorFusionService9Axis(bool, int, bool)
9-axis sensor fusion is not supported on this platform.  Returning.
virtual void CLSensorFusionService9Axis::useNorthRef(bool)
North reference overridden as %{public}d by first client
virtual void CLSensorFusionService9Axis::feedCompassData(const CLCompass_Type::Sample *)
correctedCompassExt, %.3f, %.3f, %.3f, %u, %u
VehicularHints
StateSourcesVehicle
StateSourcesOperator
StateSourcesCompounded
StartDND
DNDTriggered
StartDWR
DWRTriggered
TransitionDND
TransitionDWR
EndDND
DNDDWRCleared
EndDWR
CLCoarseCellTilesManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLCoarseCellTilesManager.mm
-[CLCoarseCellTilesManagerAdapter beginService]
+[CLCoarseCellTilesManagerAdapter isSupported]
CLCoarseCellTilesManager is not supported in diagnostics mode
CLCoarseCellTilesManager::isSupportedTileType(tileType)
-[CLCoarseCellTilesManagerAdapter requestCellTileDownloadByType:lat:lon:seckey:]
CLCoarseCellTilesManager
AncientTilesThreshold
CLCoarseCellTilesManager::CLCoarseCellTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLICoarseCellTilesManagerExternal>, std::optional<CLTilesSetCollection>)
TILE: fMaxTileDataAge, %.1lf
CellTilesActive
TileCoarse, isActive, %{public}d
MTimeModificationPeriod
TILE: MTimeModificationPeriod, %.1lf
CellTilesServerUrl
CLTilesSetCollection CLCoarseCellTilesManager::initializeProductionTilesSetCollection()
TILE: fDefaultCellTilesServerUrl, %{private}s, overridden, %{public}d
/6/v1
/7/v1
/8/v1
/11/v1
TILE: mkdir, %s, ret, %d
/coarse-gsm
CLCoarseGsmTileServer
/coarse-cdma
CLCoarseCdmaTileServer
/coarse-lte
CLCoarseLteTileServer
/coarse-nr
CLCoarseNrTileServer
virtual void CLCoarseCellTilesManager::shutdown()
TILE: CLCoarseCellTilesManager::shutdown
void CLCoarseCellTilesManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
TileCoarse, unexpected, dataprotection, %{public}d
TileCoarse, kNotificationEncryptedDataAvailability, %d, changed, %d
void CLCoarseCellTilesManager::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
TileCoarse, unexpected, status, %{public}d
TileCoarse, kNotificationReachability, %{public}d, was, %{public}d
void CLCoarseCellTilesManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
TileCoarse, kNotificationReset
TileCoarse, kNotificationLocationServicesStatus, %{public}d
TileCoarse, #CacheDelete kNotificationSoftwareUpdateStorageRecovery
void CLCoarseCellTilesManager::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
TileCoarse, unexpected, companion, %{public}d
void CLCoarseCellTilesManager::onCleanupAgedTiles()
TileCoarse, Cleanup
CLCoarseCellTilesManager::traverseAllTilesSets
void CLCoarseCellTilesManager::traverseAllTilesSets(const char *, CLCoarseCellTilesManager::CLTileManagerTraverseTilesSetBlock)
TILE: performing, sAction, %s, tilesSet, %s
void CLCoarseCellTilesManager::listAvailableFilesAllTypes(CFAbsoluteTime)
TileCoarse, listAvailableFilesAllTypes, indexed, %{public}d
indexTiles
TileCoarse, clear on index
TileCoarse, listAvailableFilesAllTypes, done
bool CLCoarseCellTilesManager::indexTiles(CLTilesSet &, CFAbsoluteTime)
TileCoarse, indexTiles, rootDirectory, %{public}s, name, %{public}s
TileCoarse, indexTiles, can't open dir, %{public}s, #CloneMe
TileCoarse, indexTiles, absoluteFilename, '%{public}s', d_type, %{public}d
TileCoarse, indexTiles, invalid filename  %{public}s
TileCoarse, convert to class C, first unlock, %{public}s, files, %{public}d
TileCoarse, indexTiles, failed to stat file, %{public}s, ret, %{public}d, #CloneMe
@TileList, %{public}s, add, llsw, %{private}.2lf, %{private}.2lf, index, size, %{public}lu
TileCoarse, indexTiles, done, %{public}s, size, %{public}lu, unprotected, %{public}lu
void CLCoarseCellTilesManager::predownloadTiles(CFAbsoluteTime)
TileCoarse, skip predownload, fIndexedAvailableFiles, %{public}d, fIsActive, %{public}d
predownloadTiles (Coarse)
bool CLCoarseCellTilesManager::requestDownload(CLTilesManager_Type::TileType, double, double, sec_key_t, CFAbsoluteTime)
@TileError, RequestID, ll, %{private}.3lf, %{private}.3lf, tid, %d, %d, %d
TileDl, requestDownload, type, %{public}d, %{public}s, location, %{private}14.8lf, %{private}14.8lf, id, %{private}s, updated, %{public}d, reachbility, %{public}d
@TileSched, coarsecell, set, %{public}d
bool CLCoarseCellTilesManager::checkDownloadSchedule(CFAbsoluteTime)
@TileDl, coarse, failed criteria
static void CLCoarseCellTilesManager::tileDownloadCallback(CLFileDownload *, bool, void *)_block_invoke
TileDl, tileDownloadedCallback, success, %{public}d
coarseCellTileDownloaded
void CLCoarseCellTilesManager::tileDownloadCompleted(CLFileDownload *, bool, void *)
@TileReq, %{public}s, downloaded, llsw, %{private}.2lf, %{private}.2lf, success, %{public}d, NSURLErrorCode, %{public}d
tileDownloadCompleted
@TileDl, tileDecompressionCompleted, tile, %{private}s, decompress done, success, %{public}d, NSURLErrorCode, %{public}d, tileDoesNotExist, %{public}d, reachability, %{public}d, validId, %{public}d, locked, %{public}d, fileSize, %{public}d
@TileError, DecompressionID
gotTile
success
protection
download
@TileList, %{public}s, add, llsw, %{private}.2lf, %{private}.2lf, download, size, %{public}lu
@TileReq, %{public}s, add, llsw, %{private}.2lf, %{private}.2lf, download, size, %{public}lu
@TileError, tile not on download list, #CloneMe
void CLCoarseCellTilesManager::sendNotificationTileWasDownloaded(bool, const CLTileFile &, const CLTilesSet &, unsigned int)
@TileDl, kNotificationTileWasDownloaded, tileid, %{private}s, tileHeaderParsed, %{public}d, tileType, %{public}d, serverUrl, %{private}s, serverFilename, %{private}s, absoluteLocalFilename, %{private}s
refreshTilesDataIfNeeded
void CLCoarseCellTilesManager::refreshTilesDataIfNeeded()_block_invoke
bool CLCoarseCellTilesManager::getLocationByCellFromTile(CLTileFile *, const CLCell &, CLCoarseCellTilesManager::SearchContext &, CLDaemonLocation &)
TILE: getLocationByCellFromTile, searching, sec_key, %016llX, %s
TILE: getLocationByCellFromTile, in tile, accessible, %d, %s
TILE: no lac tile for, %s
TILE: getLocationByCellFromTile, isFound, %d, locationd, %s
bool CLCoarseCellTilesManager::getLocationByCell(const CLCell &, const CLDaemonLocation &, CLCoarseCellTilesManager::SearchContext &, CLDaemonLocation &)
TILE: getLocationByCell, index is not available, can't search tiles (locationd launched when device was locked?), fDataProtectionEnabled, %d
TILE: no tiles for, %s
CoarseTile, getLocationByCell, un-supported cell type, %{private}s, #CloneMe
TILE: getLocationByCell, search for LAC
TILE: getLocationByCell, LAC tiles for, %s, are not active
TILE: getLocationByCell, search for LAC, isFound, %d
clearLocationInformationCoarseCell
void CLCoarseCellTilesManager::clearLocationInformation()
TileCoarse, %{public}s
isSupportedTileType(type)
removeAllTiles
elapsed
void CLCoarseCellTilesManager::removeAllTiles(bool, CLTilesManager_Type::TileType)
TileCoarse, %{public}s, removeAllTiles, size, %{public}lu
@TileList, %{public}s, delete, llsw, %{private}.2lf, %{private}.2lf, all, size, %{public}lu
TileCoarse, removeAllTiles, end, name, %{public}s, size, %{public}lu, unprot size, %{public}lu
void CLCoarseCellTilesManager::deleteAgedTiles(CFAbsoluteTime)_block_invoke
TileCoarse, deleteAgedTiles, dispatch, %{public}s
TileCoarse, deleteAgedTiles, start, name, %{public}s, size, %{public}lu
deleteAgedTiles
void CLCoarseCellTilesManager::agedTileDeleter(CLTilesSet &, CFAbsoluteTime)
TILE: deleteAgedTiles, tileDataAge, %.1lf, %.1lf, corrupt, %d, isDelete, %d, tile, %s
corrupt
@TileList, %{public}s, delete, llsw, %{private}.2lf, %{private}.2lf, %{public}s, size, %{public}lu
@TileList, %{public}s, delete, llsw, %{private}.2lf, %{private}.2lf, limits, size, %{public}lu
TileCoarse, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu, name, %{private}s
tiles_cell
https://cl2.apple.com
isSupportedTileType(tileType)
createTileFileObject
std::tuple<bool, CLTileFile *> CLCoarseCellTilesManager::createTileFileObject(CLTilesManager_Type::TileType, const std::string &, const std::string &, CFAbsoluteTime)
@TileList, %{public}s, readerror, dir, %{public}s, file, %{public}s, #CloneMe
lister
@TileList, %{public}s, create, llsw, %{private}.2lf, %{private}.2lf, size, %{public}lu
updateTileRelevancy
void CLCoarseCellTilesManager::updateTileRelevancy()_block_invoke
TILE: tiles, %s, not active
TILE: updating mtime, %d, type, %d, tileid, %s
CoarseTile, Invalid tile id!, #CloneMe
virtual void CLCoarseCellTilesManager::onScheduledTileDownloadsCallback(CLTileDownloadReachabilityRequirement)
@TileSched, coarsecell, called, %{public}ld
virtual void CLNotifier<CLCoarseCellTilesManager_Type::Notification, CLCoarseCellTilesManager_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCoarseCellTilesManager_Type::Notification, NotificationData_T = CLCoarseCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCoarseCellTilesManager_Type::Notification, CLCoarseCellTilesManager_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLCoarseCellTilesManager_Type::Notification, NotificationData_T = CLCoarseCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCoarseCellTilesManager_Type::Notification, CLCoarseCellTilesManager_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLCoarseCellTilesManager_Type::Notification, NotificationData_T = CLCoarseCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCoarseCellTilesManager_Type::Notification, CLCoarseCellTilesManager_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCoarseCellTilesManager_Type::Notification, NotificationData_T = CLCoarseCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCoarseCellTilesManager_Type::Notification, CLCoarseCellTilesManager_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLCoarseCellTilesManager_Type::Notification, NotificationData_T = CLCoarseCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCoarseCellTilesManager_Type::Notification, CLCoarseCellTilesManager_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCoarseCellTilesManager_Type::Notification, NotificationData_T = CLCoarseCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCoarseCellTilesManager_Type::Notification, CLCoarseCellTilesManager_Type::NotificationData, char, char>::listClients() [Notification_T = CLCoarseCellTilesManager_Type::Notification, NotificationData_T = CLCoarseCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLPrototypeSet::addSampleToSubset(const CLDtwSample &, int, int, float &, float &, const char *&, double &)
#Warning Cost of match %{public}f exceeds max of %{public}f allowed for prototype %{public}s
void CLPrototypeSet::readFromFile(const char *)
#Warning Could not open prototype file
#Warning Error reading magic number or number (%{public}x) does not match expected number (0x%{public}x)
#Warning Error reading number of prototypes
#Warning Error reading name length of prototype %{public}d
#Warning Error reading name of prototype %{public}d
#Warning Error reading rawName length of prototype %{public}d
#Warning Error reading rawName of prototype %{public}d
#Warning Error reading max distance
You are reading an older prototype file.
#Warning Error reading number of accelerometer samples for prototype %{public}d
#Warning Error reading %{public}d accelerometer samples for prototype %{public}d
#Warning Could not initialize prototype instance %{public}d
-[CMStrideCalLocationFSM requestTransitionToLocationState:]
fLocationState %d state %d
v16@?0@"CalibrationTrack"8
LogProx
CLEarGestureNotifier
EnableEarGesture
CLEarGestureNotifier::CLEarGestureNotifier()
Ear gesture disabled on this platform because BKSHIDServicesRequestProximityDetectionMode is not present
Ear gesture enabled: %{public}d
EarGestureIgnoreProx
Ignoring prox: %{public}d
EarGestureMaxProxBeforeMotionInterval
Max prox before motion interval = %{private}f
EarGestureMaxMotionBeforeProxInterval
Max motion before prox interval = %{private}f
void CLEarGestureNotifier::startDetectingGestures()
Starting ear gesture detection
Setting prox mode to PassiveMonitoring. Starting detection.
void CLEarGestureNotifier::stopDetectingGestures()
Setting prox mode to none. Stopping ear gesture detection.
void CLEarGestureNotifier::hasBlankedScreenOrIsLockedUpdated()
Has blanked screen = %{public}d, Is locked = %{public}d
Screen is blanked and device is locked. Stopping gesture detection.
Screen is unblanked or device is not locked. Starting gesture detection if necessary.
virtual void CLEarGestureNotifier::numberOfSpectatorsChanged(int, size_t)
%@.%@.%@
void CLEarGestureNotifier::checkEndPoseInReadyState(const CLAccelerometer::Sample *)
endPose,%{public}.2f,%{public}.2f,%{public}.2f,tilt,%{public}.2f,timestamp,%{public}.3f
Failed end pose sanity check. Set state to %{public}s
FailedEndPoseCheck
Sending gesture notification. Matched prototype name, %{private}s
MatchFound
void CLEarGestureNotifier::detectCancelAfterSend(const CLAccelerometer::Sample *)
Sending gesture notification. Gesture cancelled due to unlikely end pose, %{public}.2f, %{public}.2f, %{public}.2f
CancelledPose
Sending gesture notification. Gesture cancelled due to high dynamics, %{public}.3f, %{public}.3f, %{public}.3f
CancelledDynamics
Waiting for Motion
Detected Motion Waiting For Prox
Ready To Send Notification
Sent Notification
static void CLEarGestureNotifier::onGestureNotification(const CLGestureNotifier::NotificationData *, void *)
Readying gesture notification. Ignoring prox
Setting prox mode to PassiveEngaged. Ready to send notification.
Readying gesture notification. Prox triggered before motion. dt = %{public}.3f
ProxToEarGestureDelta
Setting prox mode to PassiveEngaged. Motion waiting for prox.
Set timer for %{private}f seconds.
static void CLEarGestureNotifier::onTimer(CFRunLoopTimerRef, void *)
Gesture timer expired. State = %{public}s
Timer fired while in state %{public}s.
Setting prox mode to PassiveMonitoring. Prox timer expired.
ProxTimerExpired
CLEmergencyState::CLEmergencyState(CLEmergencyState::CLCTEmergencyMode, bool)
#EmergCon,CLEmergencyState,SimInstance is KSimNone
Sim_#
_Status_#
_Medium_#
_Transport_#
_CallType_#
kSim1
kSim2
kSimNone
kSetup
kCLEEA
kEEM
kVoice
kText
kEmergency
kNormal
virtual bool CLActivityLoggerSizePolicy::shouldILog(NSData *)
currentSize is %llu, log msg size is %lu
Log msg size exceeds limit %d, skip loging %lu bytes
Log size exceeded %llu, skip log of %lu bytes
static int CLVO2MaxClassifier::getIndexFromAge(int)
Invalid parameter in getIndexFromAge: %{private}d
double CLVO2MaxClassifier::alertThresholdForSexAndAge(CLHKBiologicalSex, int) const
Invalid parameter, cannot calculate an alert threshold
double CLVO2MaxClassifier::lowClassificationThresholdForSexAndAge(CLHKBiologicalSex, int) const
CLDebugBytes::CLDebugBytes(const char *)
Bytes: construct, name, %s
void CLDebugBytes::clear()
Bytes: clear, name, %s
void CLDebugBytes::log(const std::string &, CLDaemonStatus_Type::Reachability)
Bytes: log, name, %s, m, %s, s, %d, r, %d, t, %d, ts, %d, reachability, %d
PedestrianStepCountBuffer
std::vector<CLStepDistanceFusionResult> CLStepDistanceFusion::feedStepCountEntry(const CLExtendedStepCountEntry &)
StepCount, %f, %f, %d, %f, %f, %u, %f, %f, %f, %f, %d
deltaCount
deltaDist(m)
calPed
fused
totalDist(m)
usedGps
pace(s/m)
StepDistancePedometerFusedPace
rawGps
StepDistanceFinalFusedPace
StepDistanceUsedOdometerPace
odometerPaceStdError
pedometerPaceStdError
residual
output
tolerance
activeTime
averageActivePace
ratio
vehicular
firstStepTime
lastStepTime
pedometerArmConstrainedState
distanceSource
unified,%s,%0.3f,%s,%u,%s,%u,%s,%s,%0.2f,%s,%0.2f,%s,%0.2f,%s,%0.2f,%s,%s,%0.2f,%s,%0.2f,%s,%0.2f,%s,%u,%s,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%u,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.3f,%s,%0.4f,%s,%0.2f,%s,%u,%s,%0.3f,%s,%0.3f,%s,%d,%s,%d
rawDistance
calDistance
odomDistance
fusedDistance
odometerDistanceForSlowPaceCheckWindow
pedometerRawDistanceForSlowPaceCheckWindow
odometerError
rawPace
calPace
odomPace
fusedPace
#Warning Potential StepDistanceFusion error. File a radar if you are not walking/running in place. %s, %f, %s, %u, %s, %u, %s, %f, %s, %f, %s, %f, %s, %f, %s, %f, %s, %f, %s, %d, %s, %f, %s, %f, %s, %f, %s, %f
#Warning Inconsistency found between steps and clock. Ignoring.
void CLStepDistanceFusion::feedSession(const CLMotionStateMediator_Type::MotionOverride &)
action,%d,type,%d
bool CLStepDistanceFusion::isOdometerQualityUsable(CFAbsoluteTime, bool)
Classifying %lu odometer entries
OdometerQuality,%d,MostRecentOdometerEntry,timestamp,%.3lf,timestampGps,%.3lf,odometer,%.3lf,deltaDist,%.3lf,deltaDistUnc,%.3lf
bool CLStepDistanceFusion::getOdometerDistance(CFAbsoluteTime, CFAbsoluteTime, double &) const
#Warning Time rolled back! t1,%{public}f,t2,%{public}f
bool CLStepDistanceFusion::shouldUseOdometerPace(CFAbsoluteTime, bool, bool, double &, double &)
StepCountBuffer lookup time not successful,%0.3f
bool CLStepDistanceFusion::updateVehicularStateMachine(double, double, double)
How can we generate pedometer distance with no time at all?
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/StepCount/CLStepDistanceFusion.mm
updateVehicularStateMachine
virtual void CLNatalieInput<CLExtendedStepCountEntry>::update(CFAbsoluteTime) [Data_T = CLExtendedStepCountEntry]
void CLPedestrianWorkoutStopDetectorFSM::feedStepCountEntry(const CFAbsoluteTime, const uint32_t, const float, const bool)
PedestrianStop,timestamp,%0.3f,statePrev,%d,state,%d,stepCountDiff,%d,activeTimeDiff,%0.3f,isStroller,%d,stepCadenceSmallWindow,%0.3f,strollerFractionSmallWindow,%0.3f,stepCadenceLargeWindow,%0.3f,strollerFractionLargeWindow,%0.3f,fTimeSinceRunTimer,%zd,isFrontSmallWindowActiveInLargeWindow,%d
const T &CMQueue<CLPedestrianWorkoutStopDetectorFSM::LimitedStepCountEntry>::operator[](const size_t) const [T = CLPedestrianWorkoutStopDetectorFSM::LimitedStepCountEntry]
CLMagneticAccessorySilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/Notifiers/CLMagneticAccessory.mm
-[CLMagneticAccessoryAdapter beginService]
CLMagneticAccessory
com.apple.system.powersources.source
ConnectedMagneticAccessoryPowerInduction
IOPSCopyExternalPowerAdapterDetails
/System/Library/Frameworks/IOKit.framework/IOKit
virtual void CLNotifier<CLMagneticAccessory_Type::Notification, CLMagneticAccessory_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLMagneticAccessory_Type::Notification, NotificationData_T = CLMagneticAccessory_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLMagneticAccessory_Type::Notification, CLMagneticAccessory_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMagneticAccessory_Type::Notification, NotificationData_T = CLMagneticAccessory_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMagneticAccessory_Type::Notification, CLMagneticAccessory_Type::NotificationData>::removeClient(int) [Notification_T = CLMagneticAccessory_Type::Notification, NotificationData_T = CLMagneticAccessory_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMagneticAccessory_Type::Notification, CLMagneticAccessory_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMagneticAccessory_Type::Notification, NotificationData_T = CLMagneticAccessory_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMagneticAccessory_Type::Notification, CLMagneticAccessory_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLMagneticAccessory_Type::Notification, NotificationData_T = CLMagneticAccessory_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMagneticAccessory_Type::Notification, CLMagneticAccessory_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMagneticAccessory_Type::Notification, NotificationData_T = CLMagneticAccessory_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMagneticAccessory_Type::Notification, CLMagneticAccessory_Type::NotificationData>::listClients() [Notification_T = CLMagneticAccessory_Type::Notification, NotificationData_T = CLMagneticAccessory_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
GyroBiasLoggerDailyReportTimeout
GyroBiasLoggerBiasEstimationTimeout
GyroBiasLoggerMinTimeBetweenFitSessions
com.apple.CoreMotion.GyroCalibrationDatabaseUpdate
timeBetweenDatabaseUpdates
com.apple.CoreMotion.GyroBiasFit
timeBetweenFits
timeSinceLastMiniCal
com.apple.CoreMotion.GyroBiasEstimationOutOfBoxExperience
outOfBoxFirstConvergedTemperature
outOfBoxTimeToFirstConvergedBiasEstimate
com.apple.CoreMotion.GyroBiasDailyStatistics
dailyMinObservedTemperature
dailyMaxObservedTemperature
dailyBiasEstimationPercentageUsingFitInterpolation
dailyBiasEstimationPercentageUsingFitExtrapolation
dailyMaxTimeBetweenGyroBiasEstimations
dailyMaxTimeBetweenNonlinearFits
dailyMaxTimeBetweenDataBaseUpdates
dailyMinBiasEstimateTemperature
dailyMaxBiasEstimateTemperature
com.apple.CoreMotion.GyroBiasDailyDelta
dailyChangeInInterceptX
dailyChangeInInterceptY
dailyChangeInInterceptZ
com.apple.CoreMotion.GyroBiasEstimationTemperature
gyroBiasEstimationTemperature
temperatureDistanceFromFit
com.apple.CoreMotion.OISDailyStatistics
dailyMinGyroBiasError
dailyMaxGyroBiasError
dailyMinGyroTemperature
dailyMaxGyroTemperature
hrConfidence
grade
hasGPS
hasStrideCal
workoutType
cadence
pace
isStroller
hrTime
Available
ScanReady
ScanError
ScanErrorBusy
LinkStatus
Roam
BgExit
BgEntry
TrackingAvailable
ScanCache
PeerRanging
NetworkCritical
Harvest2GhzSet1
Harvest2GhzSet2
Harvest5GhzSet1
Harvest5GhzSet2
Harvest5GhzSet3
Cached
Channel
Fast
Stage1
Stage2
Normal
CustomScanParameters
Stage1_5GHz
bool CLWifiService_Type::isLocationScanTypeOn5GHzBand(CLWifiService_Type::ScanType)
@WifiService_Type, unsupported scan type %{public}d
virtual void CLKappaQualifierAlgBaroResult::log()
[Baro] TPQ summary,%d,A,%f,B,%llu,C,%f,D,%f,E,%lu,F,%d,G,%llu,H,%f,I,%d,J,%d,K,%f,L,%f,M,%f,config-1,%f,config-2,%f,config-3,%f
baro-A
baro-B
baro-C
baro-D
baro-E
baro-F
baro-G
baro-H
baro-I
baro-J
baro-K
baro-L
baro-M
baro-config-1
baro-config-2
baro-config-3
virtual void CLKappaQualifierAlgBaroResult::recordCA(NSMutableDictionary *)
baro (%f, %f, %f, %lu, %u, %f, %f, %f, %f) (%d, %d, %d, %d, %d, %d, %d, %d, %d)
baro_A
baro_C
baro_D
baro_E
baro_F
baro_H
baro_I
baro_J
baro_M
void CLKappaQualifierAlgBaro::setConfig(const struct CLKappaQualifierAlgBaroConfig &)
baro config %f, %f, %f
bool CLKappaQualifierAlgBaro::determinedRate(uint64_t)
Baro, error, rate outside possible range, %lu
Baro, calculatedRate, %lu
virtual void CLKappaQualifierAlgBaro::reset()
Baro, resetting algorithm
CLKeyboardCoverState
void CLKeyboardCoverState::registerForKeyboardUpdates()
registering for keyboard updates
IOServiceFirstMatch
IOServiceTerminate
void CLKeyboardCoverState::registerForKeyboardUpdates()_block_invoke
#Warning Failed to register for keyboard updates. Could not register for notifications from  AppleHIDKeyboardEventDriverV2 service and IOAccessoryIDBusHIDDevice service (for kIOFirstMatchNotification and kIOTerminatedNotification).
#Warning Failed to register for keyboard updates. Could not create KeyboardConnectNotificationPort and KeyboardConnectNotificationPort
void CLKeyboardCoverState::unregisterForKeyboardUpdates()
unregistering for keyboard updates
RequiresCompassResetOnConnect
AppleHIDKeyboardEventDriverV2
IOAccessoryIDBusHIDDevice
-[CMStrideCalibrationDatabase initWithSilo:]
StrideCalDb init
-[CMStrideCalibrationDatabase initWithSilo:]_block_invoke
Finished insertion startTime %f
v112@?0{?=idIdddddiiddid}8
-[CMStrideCalibrationDatabase addEntry:]
insertion startTime %f
-[CMStrideCalibrationDatabase isCalibrationConvergedStdForBinWithSpeed:]
Speed,%f,KFactorStd,%0.4f
-[CMStrideCalibrationDatabase isCalibrationConvergedMedianForSpeed:]
Median kValue pacebin with rawSpeed %f: %f
void CLActivityRecorderDb<CLStrideCalEntry>::addSuspectRecord(const T &) [T = CLStrideCalEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
VO2MaxStagingSummaryHistory
DELETE FROM VO2MaxStagingSummaryHistory WHERE sessionId = ?
void CLVO2MaxStagingSummaryRecorderDb::deleteRecordsForSessionId(unsigned char *)
Deleting VO2MaxStagingSummaryHistory records from db where sessionId = %{public}s
SELECT * from VO2MaxStagingSummaryHistory ORDER BY startTime ASC
CMError CLVO2MaxStagingSummaryRecorderDb::queryInTimeRange(const CFAbsoluteTime, const CFAbsoluteTime, std::vector<VO2MaxStagingSummary> &) const
VO2MaxStagingSummaryHistory, DB not accessible
SELECT * FROM VO2MaxStagingSummaryHistory WHERE pointCount > 0 AND startTime > ? and startTime < ? ORDER BY startTime DESC
DELETE FROM VO2MaxStagingSummaryHistory
INSERT INTO VO2MaxStagingSummaryHistory (startTime, workoutType, sessionId, durationInSeconds, pointCount, hrMax, hrMin, meanHr, meanVo2, meanSpeed, meanGrade, meanHrConfidence, meanHrCadenceAgreement, meanCadence, vo2MaxModelSource, sessionType) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
meanHr
meanVo2
meanSpeed
meanGrade
meanHrConfidence
meanHrCadenceAgreement
meanCadence
CLActivityRecorderDb<VO2MaxStagingSummary>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxStagingSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxStagingSummary>::setDatabaseAccessible() [T = VO2MaxStagingSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxStagingSummary>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxStagingSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
-[CMStrideCalibrator(DataInput) onLocationNotification:data:]
#Warning Received unhandled notification, %d
virtual CLMetsInfo CLCalorieTaiChiModel::computeMETS(const CLNatalieModelInput &)
TaiChi,baselineMets,%.1f,metsHR,%.1f,metsWR,%.1f,userMets,%.1f,userMetsSource,%d
virtual void CLKappaQualifierAlgPulseResult::log()
[Pulse] TPQ summary,%d,A,%f,B,%f,C,%llu,D,%llu,E,%d,config-1,%f
pulse-A
pulse-B
pulse-C
pulse-D
pulse-E
pulse-config-1
virtual void CLKappaQualifierAlgPulseResult::recordCA(NSMutableDictionary *)
pulse (%f, %f, %d) (%d, %d, %d)
pulse_A
pulse_B
pulse_E
void CLKappaQualifierAlgPulse::setConfig(const struct CLKappaQualifierAlgPulseConfig &)
pulse config %f
feedFastAccel
CLKappaQualifierAlgPulse.mm
timeAligner.getAlignmentReady()
virtual void CLKappaQualifierAlgPulse::reset()
Pulse alg: reset
CMVectorBufferBase::Element CMVectorBufferBase<float, 3>::front() const [T = float, N = 3]
Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 139,front() on empty buffer.
CMVectorBufferBase::Element &CMVectorBufferBase<float, 3>::operator[](const size_t) [T = float, N = 3]
Assertion failed: i < size(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 39,out of buffer range %zu.
CLSkiNotifier
SimulateSkiWorkout
CLSkiNotifier::CLSkiNotifier(id<CLIntersiloUniverse>)_block_invoke
Ski Record update: startTime %lf, endTime %lf, runDistance %f, runElevationDescent %f, runAvgSpeed %f, runMaxSpeed %f
v104@?0{CLSkiEntry=Q[16C][16C]ddddddd}8
virtual bool CLSkiNotifier::registerForNotificationInternal(const CLSkiNotifier_Type::Notification &)
virtual bool CLSkiNotifier::unregisterForNotificationInternal(const CLSkiNotifier_Type::Notification &)
CLSkiNotifier::onMotionStateMediatorNotification
CLSkiNotifier::onOdometerNotification
Skiing
virtual void CLNotifier<CLSkiNotifier_Type::Notification, CLSkiNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLSkiNotifier_Type::Notification, NotificationData_T = CLSkiNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLSkiNotifier_Type::Notification, CLSkiNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSkiNotifier_Type::Notification, NotificationData_T = CLSkiNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSkiNotifier_Type::Notification, CLSkiNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLSkiNotifier_Type::Notification, NotificationData_T = CLSkiNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSkiNotifier_Type::Notification, CLSkiNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSkiNotifier_Type::Notification, NotificationData_T = CLSkiNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSkiNotifier_Type::Notification, CLSkiNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLSkiNotifier_Type::Notification, NotificationData_T = CLSkiNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSkiNotifier_Type::Notification, CLSkiNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSkiNotifier_Type::Notification, NotificationData_T = CLSkiNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSkiNotifier_Type::Notification, CLSkiNotifier_Type::NotificationData>::listClients() [Notification_T = CLSkiNotifier_Type::Notification, NotificationData_T = CLSkiNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
kCLMotionTypeGeomagneticModelDataXKey
kCLMotionTypeGeomagneticModelDataYKey
kCLMotionTypeGeomagneticModelDataZKey
kCLMotionTypeGeomagneticModelDataMagnitudeKey
kCLMotionTypeGeomagneticModelDataHorizontalKey
kCLMotionTypeGeomagneticModelDataDeclinationKey
kCLMotionTypeGeomagneticModelDataInclinationKey
kCLMotionTypeGeomagneticModelDataTimestampKey
kCLBiasXKey
kCLBiasYKey
kCLBiasZKey
kCLVarianceXKey
kCLVarianceYKey
kCLVarianceZKey
KCLDoingBiasEstimationKey
virtual CMFFTProcessor::~CMFFTProcessor()
CMFFTProcessor is being cleaned up.  Subsequent calls to CMAccelerometerProcessor::computeFrequencyFeatures will lead to undefined behavior.
static int CMFFTProcessor::idxCeil(scalar_32)
Assertion failed: arg >= 0.f && arg <= static_cast<scalar_32>(2147483647), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMFFTProcessor.cpp, line 52,arg,%f.
static float CMFFTProcessor::getSum(int, int, const FrequencyData *)
Assertion failed: start < end, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMFFTProcessor.cpp, line 74,start,%d,end,%d.
bool CLSubHarvester::baseUploadRequirementsMet()
%s not ready to upload: invalid reachability. Have %d and need %d
LastUploadTime
CLDMVisionServiceSilo
RTRoutineManager
CLRoutineMonitorSilo
LocationBundles/Routine.bundle
com.apple.locationd.routine
SLVAwarenessParameters
v32@?0@"NSNumber"8@"NSMutableArray"16^B24
-[CLRoutineMonitor startMonitoringVisitsForClient:]
#slv telling routined to start visit monitoring
-[CLRoutineMonitor startMonitoringVisitsForClient:]_block_invoke
#slv received visit from routined, visit, %@, error, %@
v24@?0@"RTVisit"8@"NSError"16
visits
-[CLRoutineMonitor stopMonitoringVisitsForClient:]
#slv telling routined to stop visit monitoring
-[CLRoutineMonitor startLeechingVisitsForClient:]
#slv Telling routined to start visit leeching
-[CLRoutineMonitor startLeechingVisitsForClient:]_block_invoke
#slv Received leeched visit from routined, visit, %@, error, %@
-[CLRoutineMonitor stopLeechingVisitsForClient:]
#slv Telling routined to stop visit leeching
-[CLRoutineMonitor startLeechingLowConfidenceVisitsForClient:]
#slv Telling routined to start low confidence visit leeching
-[CLRoutineMonitor startLeechingLowConfidenceVisitsForClient:]_block_invoke
#slv Received leeched low confidence visit from routined, visit, %@, error, %@
#slv Got unexpceted error from routined, error, %@
-[CLRoutineMonitor stopLeechingLowConfidenceVisitsForClient:]
#slv Telling routined to stop low confidence visit leeching
-[CLRoutineMonitor addLocation:]
dropping duplicate location, %{private}@
received location, %{private}@
#warning in-memory cache has exceeded threshold of %{public}lu, removing oldest fix
-[CLRoutineMonitor onClientManagerNotification:data:]
received unhandled notification %{public, location:CLClientManager_Type::Notification}d
-[CLRoutineMonitor onLocationNotification:data:]
received unhandled notification %{public, location:CLLocationProvider_Type::Notification}d
-[CLRoutineMonitor flush]
flushing routine data
-[CLRoutineMonitor checkAuthorization]
Location services are disabled; stopping routine data collection
Routine system service disabled; stopping routine data collection
-[CLRoutineMonitor listener:shouldAcceptNewConnection:]
LocationServer received incoming connection
Why didn't we get a connection
-[CLRoutineMonitor listener:shouldAcceptNewConnection:]_block_invoke
Connection interrupted
Connection invalidated
-[CLRoutineMonitor startUpdatingLocation]
start updating location
-[CLRoutineMonitor stopUpdatingLocation]
stop updating location
-[CLRoutineMonitor startWakeRoutinedTimer]
start wakeRoutinedTimer
-[CLRoutineMonitor stopWakeRoutinedTimer]
stop wakeRoutinedTimer
-[CLRoutineMonitor onWakeRoutinedTimer]
wake routined
-[CLRoutineMonitor setDiminishedMode:]
entering diminished mode; starting data collection
exiting diminished mode; stopping data collection
-[CLRoutineMonitor startMonitoringScenarioTriggerOfType:forClient:]
#scenarioTrigger Telling routined to start monitoring trigger of type, %lu
-[CLRoutineMonitor startMonitoringScenarioTriggerOfType:forClient:]_block_invoke
#scenarioTrigger Received trigger of type %lu from routined, error %@
#scenarioTrigger Got error from routined, error, %@
v24@?0@"RTScenarioTrigger"8@"NSError"16
-[CLRoutineMonitor stopMonitoringScenarioTriggerOfType:forClient:]
#scenarioTrigger Telling routined to stop monitoring trigger of type, %lu
v32@?0@"NSArray"8@"NSError"16^B24
EstimatedLocationAtDateEnabled
fetchEstimatedLocationAtDate is disabled
CLHRSETile-Mutex
virtual void CLHRSETile::clear()
TILE: clear, tile, %sd
CLFenceDataDownloadManager
FenceDownloadTimer
virtual CLFenceDataDownloadManager::~CLFenceDataDownloadManager()
Fence: delete CLFenceDataDownloadManager
void CLFenceDataDownloadManager::addFencesForDataDownload(const std::vector<CLFenceManager_Type::Fence> &)
Fence: Adding %{public}ld fences for download
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLFenceDataDownloadManager.mm
addFencesForDataDownload
Adding fence to download, %{private}s
Fence: Already have fence data, download age %{private}.1f
Fence: Adding fence to download, restored fence, %{private}s
Fence: first fence added, enable download timer
void CLFenceDataDownloadManager::removeFencesForDataDownload(const std::vector<CLFenceManager_Type::Fence> &)
Fence: Removing %{public}ld fences for download
Removing fence from download, [%{private}s]/%{private}s/%{private}s
Fence: last fence removed, disabled download timer
void CLFenceDataDownloadManager::refreshDataForFence(const CLFenceManager_Type::Fence &)
Fence: refreshDataForFence, %{private}s
void CLFenceDataDownloadManager::removeAllFencesForDataDownload()
Fence: Removing all fences for download, fences, %{public}lu
void CLFenceDataDownloadManager::checkDownloadState()
Fence: avoid download check, isLocationServicesEnabled, %{public}d
Fence: no reachability, download not possible
Download error too fresh, avoid new downloads, dt, %{private}.1lf
checkDownloadState, currentQueries, %{private}d, numCombined, %{private}lu, reachability, %{public}d,%{public}d,%{public}d
avoiding more concurrent downloads, %{private}d, max, %{private}d
already downloading fence, %{private}s
Fence: request tile download, %{private}s
Fence: Urgent refresh, %{private}s
fence, %{private}s, is fresh for reachability, %{public}d,%{public}d,%{public}d, age, %{public}.1lf, thresh, %{public}.1lf
Fence: request ALS/tile download, tag, %{public}d, %{private}s, need refresh, %{public}d,%{public}d,%{public}d, age, %{public}.1lf, num %{public}d, %{public}d, isUrgentDownload, %{public}d
#Warning Fence: can't start query
checkDownloadState, currentNumOfQueries, %{public}d, newNumOfQueries, %{public}d, numOfStartedQueries, %{public}d, nSmall, %{public}d, nLarge, %{public}d
void CLFenceDataDownloadManager::networkQueryDone(int, bool, int, int)
Fence: networkQueryDone,tag,%{public}d,isSuccess,%{public}d,numOfAps,%{public}d,numOfCells,%{public}d,key,%{public}d,%{public}d,%{private}s
networkQueryDone, newNumOfQueries, %{public}u, isAvoidUpcomingFenceDownloads, %{public}d, doesTagBelongToFence, %{public}d
void CLFenceDataDownloadManager::onNetworkLocationNotification(int, const CLNetworkLocationProvider_Type::Notification &, const CLNetworkLocationProvider_Type::NotificationData &)
#Warning Got unknown notification %{public}d
void CLFenceDataDownloadManager::onFenceDownloadTimer(CLPersistentTimer *)
Fence: ignore onFenceDownloadTimer, shutdown?
Fence: onFenceDownloadTimer, since last, %{private}.1lf
void CLFenceDataDownloadManager::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Fence: kNotificationReachability, notification, %{private}d, reachability, from, %{private}d, to, %{private}d
Unhandled reachability notification
Fence: kNotificationMigration
void CLFenceDataDownloadManager::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
Fence: kNotificationCompanionConnectionUpdate, isNearby, from, %{public}d, to, %{public}d
CLFenceDataDownloadManager::onNetworkLocationNotification
CLFenceDataDownloadManager::onStatusNotification
CLFenceDataDownloadManager::onCompanionNotification
CLFenceDataDownloadManager::onFenceDownloadTimer
virtual void CLNotifier<CLFenceDataDownloadManager_Type::Notification, CLFenceDataDownloadManager_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLFenceDataDownloadManager_Type::Notification, NotificationData_T = CLFenceDataDownloadManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLFenceDataDownloadManager_Type::Notification, CLFenceDataDownloadManager_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLFenceDataDownloadManager_Type::Notification, NotificationData_T = CLFenceDataDownloadManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFenceDataDownloadManager_Type::Notification, CLFenceDataDownloadManager_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLFenceDataDownloadManager_Type::Notification, NotificationData_T = CLFenceDataDownloadManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFenceDataDownloadManager_Type::Notification, CLFenceDataDownloadManager_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFenceDataDownloadManager_Type::Notification, NotificationData_T = CLFenceDataDownloadManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFenceDataDownloadManager_Type::Notification, CLFenceDataDownloadManager_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLFenceDataDownloadManager_Type::Notification, NotificationData_T = CLFenceDataDownloadManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFenceDataDownloadManager_Type::Notification, CLFenceDataDownloadManager_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLFenceDataDownloadManager_Type::Notification, NotificationData_T = CLFenceDataDownloadManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFenceDataDownloadManager_Type::Notification, CLFenceDataDownloadManager_Type::NotificationData, char, char>::listClients() [Notification_T = CLFenceDataDownloadManager_Type::Notification, NotificationData_T = CLFenceDataDownloadManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
VO2MaxPowerBudgetEstimatorBudgetRefreshTime
VO2MaxPowerBudgetEstimatorTimeOfLastVO2MaxSessionEstimate
CLVO2MaxPowerBudgetEstimator::CLVO2MaxPowerBudgetEstimator(id<CLIntersiloUniverse>, CLVO2MaxPowerBudgetEstimator::PowerBudgetEstimateHandler)_block_invoke
VO2MaxPowerBudgetEstimator, budgetRefreshTimer fire
void CLVO2MaxPowerBudgetEstimator::scheduleBudgetRefresh(CFTimeInterval)
VO2MaxPowerBudgetEstimator, scheduling next budget refresh, time, %.2f
void CLVO2MaxPowerBudgetEstimator::updateTimer()
VO2MaxPowerBudgetEstimator, updating budgetRefreshTimer, delay, %.2f
CFTimeInterval CLVO2MaxPowerBudgetEstimator::getSensitiveEscalationHoldoffInterval() const
VO2MaxPowerBudgetEstimator, getting sensitiveEscalationHoldoffInterval, %.2f
void CLVO2MaxPowerBudgetEstimator::feedVO2MaxEstimate(VO2MaxResult)
VO2MaxPowerBudgetEstimator, zeroing budget on VO2MaxEstimate, now, %{public}.2f, nextRefreshTime, %{public}.2f
void CLVO2MaxPowerBudgetEstimator::feedWorkoutStopEvent(CLMotionStateMediator_Type::WorkoutEvent)
VO2MaxPowerBudgetEstimator, zeroing budget on workout stop event, now, %{public}.2f, nextRefreshTime, %{public}.2f
void CLVO2MaxPowerBudgetEstimator::feedEncryptedDataAvailability(bool)
VO2MaxPowerBudgetEstimator, encrypted data available notification, isAvailable, %d
void CLVO2MaxPowerBudgetEstimator::kickoffHKQuery()
VO2MaxPowerBudgetEstimator, kicking off historical data query, startTime, %{public}.2f, endTime, %{public}.2f
void CLVO2MaxPowerBudgetEstimator::evaluateQueryResults(CFTimeInterval, CFTimeInterval, std::vector<CLHKHealthStoreAccessUtils::CLHKWorkout>, CFTimeInterval)_block_invoke
VO2MaxPowerBudgetEstimator, new budget awarded on HK query and VO2Max results, startTime, %{public}.2f, endTime, %{public}.2f, budget, %{public}.2f, now, %{public}.2f, nextRefreshTime, %{public}.2f
VO2MaxPowerBudgetEstimator, zeroing budget on HK query and VO2Max results, startTime, %{public}.2f, endTime, %{public}.2f, now, %{public}.2f, nextRefreshTime, %{public}.2f
bool CLVO2MaxPowerBudgetEstimator::isWorkoutPowerAvailable(const std::vector<CLHKHealthStoreAccessUtils::CLHKWorkout> &) const
VO2MaxPowerBudgetEstimator, Workout query returned empty
VO2MaxPowerBudgetEstimator, Workouts query result, startTime, %{public}.2f, endTime, %{public}.2f, hkWorkoutType, %{private}d, isPedestrian, %{private}d, isIndoorWorkout, %{private}d, calories, %{private}.2f
VO2MaxPowerBudgetEstimator, Workouts query last result, startTime, %{public}.2f, endTime, %{public}.2f, hkWorkoutType, %{private}d, isPedestrian, %{private}d, isIndoorWorkout, %{private}d, calories, %{private}.2f
auto CLVO2MaxPowerBudgetEstimator::queryWorkouts(CFAbsoluteTime, CFAbsoluteTime, CFTimeInterval)::(anonymous class)::operator()(bool, std::vector<CLHKHealthStoreAccessUtils::CLHKWorkout>) const
VO2MaxPowerBudgetEstimator, Workout query failed, startTime, %{public}.2f, endTime, %{public}.2f
VO2MaxPowerBudgetEstimator, Workout query succeeded, startTime, %{public}.2f, endTime, %{public}.2f
CLPressureStatsCollector
_LastUpdate
_MeanAbsPErr
_VarPErr
_DeltaPressure
_DeltaTemperature
_TCO
_MedianAbsDevOfTCO
_FlightOfStairs
_FactoryTime
_LastAwdSubmission
CLPressureStatsCollectorSilo
-[CLPressureStatsCollector saveFeaturesToCache:]
[CLPressureStatsCollector] A new record saved to cache.plist
-[CLPressureStatsCollector cleanCache]
[CLPressureStatsCollector] cache.plist reset
-[CLPressureStatsCollector submitAWDMetric]
[CLPressureStatsCollector] AWD values staged
virtual void CLMotionNotifier::SiloDispatcher<CLPressure::Sample>::dispatchData(int, const void *, size_t) [T = CLPressure::Sample]
CLFenceAuthorizationManager
CLFenceAuthorizationManager::CLFenceAuthorizationManager(id<CLIntersiloUniverse>)
void CLFenceAuthorizationManager::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Fence: sMessage, %{public}s, fFenceDatabase is NULL
this->fFenceDatabase
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLFenceAuthorizationManager.mm
onStatusNotification
Fence: Got kNotificationAirplaneMode, airplaneMode, %d, %d
kNotificationMigration
Fence: Got kNotificationMigration
void CLFenceAuthorizationManager::fenceHandedOffToCompanion(int)
Fence: #FenceHandoff fenceHandedOffToCompanion: no fence before the first unlock
void CLFenceAuthorizationManager::handedOffFenceRemovedFromCompanion(int)
Fence: #FenceHandoff handedOffFenceRemovedFromCompanion: no fence before the first unlock
onClientNotification
void CLFenceAuthorizationManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
kNotificationUninstallation
kNotificationAuthorization
#Warning Could not retrieve fences from database for client %{public}s
kNotificationAuthorization, %lu, fences for, exec, %{public}s, bundleId, %{public}s, bundlePath, %{public}s, clientKey, %{public}s
Fence: Removing denied fences,%{public}lu, for bundle,%{public}s.
Fence: Adding authorized fences,%{public}lu, for bundle,%{public}s.
kNotificationReset
#Warning Reset received; sending reset notification
kNotificationLocationServicesStatus
Location services is now %{public}s; sending reset notification
void CLFenceAuthorizationManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
Fence: notification, kNotificationEncryptedDataAvailability, data.availability, %{public}d, unlockedSinceBoot, from, %{public}d, to, %{public}d, isStartMonitoring, %{public}d
kNotificationEncryptedDataAvailability
void CLFenceAuthorizationManager::updateAuthorizedClients()
Fence: updateAuthorizedClients, can't add fence before the first unlock
Fence: updateAuthorizedClients, locationServicesEnabled, %{public}d
checkClientStatus, %{public}s
bool CLFenceAuthorizationManager::addFence(const CLFenceManager_Type::Fence &)
Fence: addFence, can't add fence before the first unlock
Fence
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Add,1,BundleId,%s,Name,%s,
Adding fence to db, %{private}s
bool CLFenceAuthorizationManager::removeFence(const CLFenceManager_Type::Fence &)
Fence: removeFence, can't remove fence before the first unlock
Removing fence %{public}s/%{private}s
bool CLFenceAuthorizationManager::getFence(const std::string &, const std::string &, const std::string &, CLFenceManager_Type::Fence &)
Fence: getFence, can't add/remove fence before the first unlock
bool CLFenceAuthorizationManager::removeFences(const std::string &)
Fence: removeFences, can't remove fence before the first unlock
Removing all fences for %{public}s
numFences
int CLFenceAuthorizationManager::numFences(const std::string &, bool)
void CLFenceAuthorizationManager::getAuthorizedFences(std::vector<CLFenceManager_Type::Fence> &, bool)
Fence: getAuthorizedFences, no region monitoring before the first unlock
getAuthorizedFences
Location services are disabled; no monitored fences
Retrieved %{public}ld fences from database
%{public}s/%{private}s is not authorized; removing from authorized fences list
(*iter).hasFenceKey()
void CLFenceAuthorizationManager::getFencesForBundle(const std::string &, std::vector<CLFenceManager_Type::Fence> &)
Fence: getFencesForBundle, no region monitoring before the first unlock
void CLFenceAuthorizationManager::getAllFencesForBundle(const std::string &, std::vector<CLFenceManager_Type::Fence> &)
Fence: getAllFencesForBundle, no region monitoring before the first unlock
void CLFenceAuthorizationManager::isFenceRegisteredAndAuthorized(const CLFenceManager_Type::Fence &, bool &, bool &)
Fence: isFenceRegisteredAndAuthorized, no region monitoring before the first unlock
isFenceRegisteredAndAuthorized, [%{public}s]/%{public}s/%{private}s, isRegistered, %d, isAuthorized, %d
void CLFenceAuthorizationManager::lastDownloadTimeChanged(const std::string &, const std::string &, const std::string &, const double &)
Fence: lastDownloadTimeChanged, no region monitoring before the first unlock
void CLFenceAuthorizationManager::markDataDownloadInvalid()
Fence: markDataDownloadInvalid, no region monitoring before the first unlock
bool CLFenceAuthorizationManager::hasMonitoredFences(const std::string &)
Fence: hasMonitoredFences, no region monitoring before the first unlock
%{public}d fences for %{public}s; authorized %{public}d
void CLFenceAuthorizationManager::checkClientStatusInternal(const std::string &, bool)
%{public}s: hasMonitoredFences %{public}d, monitoringAdded %{public}d airplane %{public}d
%{public}s is now a fence client, airplane, %{public}d
%{public}s is no longer a fence client, airplane, %{public}d
void CLFenceAuthorizationManager::createFenceDatabase(const char *)
Fence: createFenceDatabase, fFenceDatabase, %{private}p, fWasUnlockedSinceBoot, %{public}d, reason, %{public}s
FenceHandoffInitialized
CLFenceAuthorizationManager::onClientNotification
CLFenceAuthorizationManager::onStatusNotification
CLFenceAuthorizationManager::onDataProtectionNotification
virtual void CLNotifier<CLFenceAuthorizationManager_Type::Notification, CLFenceAuthorizationManager_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLFenceAuthorizationManager_Type::Notification, NotificationData_T = CLFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLFenceAuthorizationManager_Type::Notification, CLFenceAuthorizationManager_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLFenceAuthorizationManager_Type::Notification, NotificationData_T = CLFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFenceAuthorizationManager_Type::Notification, CLFenceAuthorizationManager_Type::NotificationData>::removeClient(int) [Notification_T = CLFenceAuthorizationManager_Type::Notification, NotificationData_T = CLFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFenceAuthorizationManager_Type::Notification, CLFenceAuthorizationManager_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFenceAuthorizationManager_Type::Notification, NotificationData_T = CLFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFenceAuthorizationManager_Type::Notification, CLFenceAuthorizationManager_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLFenceAuthorizationManager_Type::Notification, NotificationData_T = CLFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFenceAuthorizationManager_Type::Notification, CLFenceAuthorizationManager_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLFenceAuthorizationManager_Type::Notification, NotificationData_T = CLFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFenceAuthorizationManager_Type::Notification, CLFenceAuthorizationManager_Type::NotificationData>::listClients() [Notification_T = CLFenceAuthorizationManager_Type::Notification, NotificationData_T = CLFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
LastFenceActivityTimestamp
FenceMonitor
FenceMonitorAlwaysOn
FenceMonitorWatchdog
CLFenceMonitor
FenceUseCellPositioning
CLFenceMonitor::CLFenceMonitor(id<CLIntersiloUniverse>)
Fence: Overriding cell positioning usage to %{private}d
FenceUseWifiPositioning
Fence: Overriding WiFi positioning usage to %{private}d
FenceUseGpsPositioning
Fence: Overriding GPS positioning usage to %{private}d
FenceUsePipelinePositioning
Fence: Overriding Pipeline positioning usage to %{private}d
FenceUseContinuousPositioning
Fence: Overriding continuous positioning usage to %{private}d
FenceIssueDelayedTriggers
Fence: Overriding FenceIssueDelayedTriggers to %{private}d
FenceContinousTrackingInterval
Fence: Overriding fWakeIntervalSeconds, %{private}.1lf
FenceMonitorDelayedTriggerCountMax
Fence: Overriding fDelayedTriggerCountMax, %{private}d
FenceMonitorDelayedTriggerIntervalSeconds
Fence: Overriding fDelayedTriggerIntervalSeconds, %{private}.1lf
FenceMonitorIsConsolidateTriggersEnabled
Fence: Overriding fIsConsolidateTriggersEnabled, %{private}d
FenceMonitorConsolidatedTriggersTimeInterval
Fence: Overriding fConsolidatedTriggersTimeInterval, %{private}.1lf
FenceMonitorIsScheduleContTrackingWakes
Fence: Overriding fIsScheduleContTrackingWakes, %{private}d
FenceMonitorIsTriggerOnTether
Fence: Overriding fIsTriggerOnTether, %{private}d
FenceMonitorUseActivityAlarm
Fence: fIsUseActivityAlarm, %{private}d, activityAlarmAvailable, %{private}d
FenceTrigger
FenceTriggerDeAss
FenceContTrack
FenceLocWatchdog
FenceSettledTimer
Fence: failed to allocate, fConsolidatedTrigger
Fence: can't check airplane mode
~CLFenceMonitor
void CLFenceMonitor::startMonitoringFences(const std::vector<CLFenceManager_Type::Fence> &)
Fence: startMonitoringFences, fences, %{public}lu, status, %{private}s
fence.hasFenceKey()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLFenceMonitor.mm
startMonitoringFences
void CLFenceMonitor::restartMonitoringForAllFences()
Fence: restartMonitoringForAllFences
void CLFenceMonitor::stopMonitoringFences(const std::vector<CLFenceManager_Type::Fence> &, bool)
Fence: stopMonitoringFences, fences, %{public}lu
void CLFenceMonitor::startMonitoring(const CLFenceManager_Type::Fence &, const CLFenceMonitorLogic::FenceMonitoringStatus &, bool)
Fence: startMonitoring, fence, %{private}s
inFence.hasFenceKey()
startMonitoring
void CLFenceMonitor::updateSubscriptions(const size_t, const size_t)
Fence: registerForNotification, location, numOfFencesOld, %{private}lu, numOfFenceNew, %{private}lu
Nautilus_AlwaysOn
#wigo,on,FenceAlwaysOn
Fence: unregisterForNotification, location, numOfFencesOld, %{private}lu, numOfFenceNew, %{private}lu
#wigo,off,FenceAlwaysOn
void CLFenceMonitor::startEmergencyAcquisition()
Start emergency acquisition, %{public}d
Stopped emergency acquisition
Started emergency acquisition
void CLFenceMonitor::stopEmergencyAcquisition()
Stop emergency acquisition, %{public}d
void CLFenceMonitor::stopMonitoringAFenceNow(const CLFenceManager_Type::Fence &, bool)
Fence:Stop stopMonitoringNow, fence, %{public}s/%{private}s
iter2 != fNearbyAllowedFences.end()
stopMonitoringAFenceNow
Fence: state stopMonitoringAFenceNow, before first unlock
Fence: stopMonitoringNow, no such fence, %{private}s
void CLFenceMonitor::startMonitoringNow(const CLFenceManager_Type::Fence &, const CLFenceMonitorLogic::FenceMonitoringStatus &)
Fence: startMonitoringNow, fence, %{private}s, status, %{private}s
cFence.hasFenceKey()
startMonitoringNow
Fence: startMonitoringNow, fence, %{private}s, is already in fMonitoredFences
Fence: crirital error!
Fence: Location services is disabled; not starting monitoring for %{private}s/%{private}s
Fence: state, retrieved %{private}d
#Warning Fence: state startMonitoringNow, before first unlock
Fence: request scan, no current location
Fence: filtered fLastLocation, %{private}s
Fence: request scan, current location, %{private}s
Started monitoring, %{private}s, monitoringStatus, %{private}s
Fence:Start Started monitoring fence %{public}s/%{private}s (<%{private}+.8f,%{private}+.8f>, radius %{public}.3f, active tech %{private}d), numFences, %{public}zu, unlocked, %{public}d
Fence:Poly, %{public}s, %{public}d, %{public}d, %{publice}d, %{private}s
Fence: fence is already monitored, %{private}s
void CLFenceMonitor::handleMonitoringDataChanged(const CLFenceManager_Type::Fence &)
Fence: Got monitoring data changed for %{private}s/%{private}s
MonitoringTechOptions CLFenceMonitor::getAvailableTech()
Fence: location services is disabled, no tech available
MonitoringTechOptions CLFenceMonitor::getRequiredTechLevel(const CLFenceManager_Type::Fence &, const CLFenceMonitorLogic::FenceMonitoringStatus &, const CLDaemonLocation &)
fence, %{private}s, requiredTech, %{private}s, fine, %{private}d, large, %{private}d
void CLFenceMonitor::adjustTechLevel(const CLFenceManager_Type::Fence &, CLFenceMonitorLogic::FenceMonitoringStatus &, MonitoringTechOptions, bool)
adjustTechLevel, fence, %{private}s, newOptions, %{private}s, availableTech, %{private}s, statusChanged, %{private}d
Stopping tech 0x%{private}x (active is 0x%{private}x) for %{public}s/%{private}s
Starting tech 0x%{private}x (active is 0x%{private}x) for %{public}s/%{private}s
Fence: fence, %{private}s, newTech, %{private}s, status, %{private}s
bool CLFenceMonitor::shouldIgnoreLocation(const CLDaemonLocation &)
Fence: handleLocation, Ignoring cell or LAC position as per defaults
Fence: handleLocation, Ignoring WiFi position as per defaults
Fence: handleLocation, Ignoring GPS position as per defaults
Fence: handleLocation, Ignoring Pipeline position as per defaults
void CLFenceMonitor::handleLocation(const CLDaemonLocation &)
Fence: handleLocation, location, %{private}s, services, %{private}d, airplane, %{private}d, connected, %{private}d
Fence: cancelLocationWatchdog, num fences, %{public}lu, location type, %{private}s
Fence: Handling location, %{private}+.8f, %{private}+.8f, acc, %{private}.2f, timestamp, %{private}.1lf
request a scan to comfirm cell location, fences, %{public}lu
cancelLocationWatchdog, wifi off, minDistance, %{private}lf
Fence: requesting a scan, numOfFencesNeedScan, %{public}d, minDistanceToFence, %{private}.1lf
handleLocation.cell2wifi
Fence: avoid a scan, numOfFencesNeedScan, %{public}d, minDistanceToFence, %{private}.1lf
fenceUpdate
horizontalAccuracy
numOfDispatchedChecks
minDistanceToFence
Fence: Dispatch continuous engagement
void CLFenceMonitor::handleLocationFence(const CLDaemonLocation &, const CLFenceManager_Type::Fence &)
#Warning Fence: Attempt to handle location <%{private}+.8f,%{private}+.8f> acc %{public}.2f for non-present fence %{public}s/%{private}s
Processing location when not supposed to
void CLFenceMonitor::handleLocationMonitoredFence(const CLDaemonLocation &, const CLFenceManager_Type::Fence &, CLFenceMonitorLogic::FenceMonitoringStatus &)
Fence: invalidate EPNO exit trigger time
Fence: %{private}s, filtering unwanted, %{private}s, nofitication, has not achieved settled state yet
Fence: %{private}s, filtering unwanted, %{private}s, nofitication, never achieved settled state for entry notification
Fence: fenceUpdate, %{private}s, bundle, %{private}s, type, %{private}-16s, loc, %{private}12.7lf, %{private}12.7lf, acc, %{public}4.0lf, distance, %{private}9.0lf, tech, %{private}4s%{private}s, trans, %{private}d, state, %{private}d, cont, %{private}d, fence, %{private}12.8lf, %{private}12.8lf, %{private}.1lf, %{private}.1lf, sCount, %{private}d, %{private}d, trig, %{private}d, %{private}d, sinceLastLoc, %{private}.1lf, events, 0x%{private}08x, status, %{private}-10s => %{private}-10s, settled state, %{private}s ==> %{private}s, cantShiftButNeedTo, %{private}d, sinceLastTransition, %{private}.1lf
handleLocationMonitoredFence
void CLFenceMonitor::notifyClientsWithFenceEvent(CLFenceMonitor_Type::Notification, CLFenceMonitor_Type::NotificationData &)
#Warning Fence: state changed before first unlock
void CLFenceMonitor::handleNoWifiApsArea()
Fence: handleNoWifiApsArea, recalculated, %{public}d, fMinDistanceToFence, %{private}.1lf, fMinDistanceToFenceTimestamp, %{private}.1lf
checkPostponeContinuousTracking
void CLFenceMonitor::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
Fence: Ignoring expired location <%{private}+.8f, %{private}.8f>, acc %{public}.2f, timestamp %{public}.2f, lifespan %{public}.2f
Fence: Ignoring old location, type, %{public}d, age, %{public}.1f
#Warning Fence: Got unknown location notification %{public}d
void CLFenceMonitor::onCellMonitorNotification(int, const CLFenceMonitor_Type::Notification &, const CLFenceMonitor_Type::NotificationData &)
#Warning Fence: Cell monitoring is disabled; ignoring cell monitor notification %{public}d
Fence: Got kNotificationTriggerReceived from cell
cell.kNotificationTriggerReceived
Fence: Got kNotificationDelayTriggerReceived from cell
Fence: Got cell kNotificationMonitoringAvailable, available, %{public}d
cell.kNotificationMonitoringAvailable
#Warning Got unknown cell monitor notification %{public}d
void CLFenceMonitor::onWifiMonitorNotification(int, const CLFenceMonitor_Type::Notification &, const CLFenceMonitor_Type::NotificationData &)
#Warning WiFi monitoring is disabled; ignoring cell monitor notification %{public}d
Fence: Got kNotificationTriggerReceived from WIFI, cancelDelayedDeAssociationTrigger, %{public}d
Fence: setting EPNO exit trigger time
wifi.kNotificationTriggerReceived
Fence: Got kNotificationDelayTriggerReceived from WIFI
Fence: Got WiFi kNotificationMonitoringAvailable, available, %{public}d
wifi.kNotificationMonitoringAvailable
Fence: Got kNotificationReCheckContinuousEngagement
Fence: Got kNotificationFenceDownloadRequest
#Warning Fence: Got unknown WiFi monitor notification %{public}d
void CLFenceMonitor::engageContinuousTrackingIfNeeded()
Fence: location services disabled, no continous tracking, %{public}d, isAirplaneMode, %{public}d, cConnected, %{public}d
Fence: FenceMonitorWifi needs tracking
Fence: engageContinuousTrackingIfNeeded, isEngageContinousTracking, %{public}d, numOfMonitoredFences, %{public}d, %{public}d
engageContinuousTrackingIfNeeded, timeToNextTimer, %{public}lf
engageContinuousTrackingIfNeeded
kNotificationCompanionConnectionUpdate
void CLFenceMonitor::updateCompanionConnectedState(bool)
Stop monitoring, nearby
cl_fence_handoff
#Warning Unhandled notification %{public}d
void CLFenceMonitor::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Fence: Got kNotificationAirplaneMode, airplaneMode, %{public}d
kNotificationAirplaneMode
Fence: Got kNotificationBattery, level, %{private}lf, charged, %{private}d, connected, %{private}d, wasConnected, %{private}d
kNotificationBattery
Fence: tether triggers are disabled
com.apple.clx.geofence.heartbeat
wifiScans
epnoCalculations
epnoEntryEvents
epnoExitEvents
wakes
assertions
setTimers
gpsDenied
gpsSessions
gpsDuration
watchdogsArmed
watchdogsFired
watchdogsLong
locationEnabled
locationToggled
wifiEnabled
wifiToggled
airplaneEnabled
airplaneToggled
anyFences
anyFineFences
anyLargeFences
anyEmergencyFences
fences
fenceAdditions
fenceRemovals
fenceEntries
fenceExits
fenceHandoffEntries
fenceHandoffExits
locationsClient
locationsGps
locationsIndoor
locationsWifi2
locationsWifi
locationsCell
#Warning Fence: unknown notification, %{public}d
void CLFenceMonitor::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
Fence: Got kNotificationPower, isWifiPowered, %{public}d
scan result, count, wait, %{public}d, retry, %{public}d, error
Fence: monitor, got kNotificationScan, result, %{private}lu, time, %{private}.1lf, age, %{private}.1lf, numFences, %{public}lu, locationCount, %{public}d, %{public}d
Fence: no reachability, expedite watchdog, %{public}.1lf
Fence: skip urgent, watchdog already active, %{public}d,%{public}d, %{public}d
Fence: startScan, requesting a scan due to an error / empty scan, fScanRetryCounter, %{public}d
onWifiNotification
Fence: expedite location watchdog due to empty / error scan , %{public}d, %{public}d, kUrgentWatchdogActivation, %{public}.1lf
void CLFenceMonitor::triggerReceived(const char *, bool)
Fence: triggerReceived, reason, %{private}s, schedule, %{private}p, pending, %{private}d, watchdogNeeded, %{private}d, %{private}d
void CLFenceMonitor::triggerReceivedNow()
Fence: triggerReceivedNow, isWifiPowered, %{public}d, isLocationEnabled, %{public}d, numOfFences, %{public}lu, airplane, %{public}d, connected, %{private}d, watchdogNeeded, %{private}d, minDist, %{private}.1lf, %{private}.1lf, minDistNextWake, %{private}.1lf
Fence: Trigger received; performing WiFi scan, minDistanceToFence, %{private}.1lf
Fence: Trigger received; schedule watchdog for GPS, minDistanceToFence, %{private}.1lf
Fence: ignoring trigger event
static bool CLFenceMonitor::canPerformMonitoringForFence(const CLFenceManager_Type::Fence &, CLFenceManager_Type::Fence &)
Fence: Cannot monitor %{public}s/%{private}s because the radius is too large, suggesting, %{private}.1lf
void CLFenceMonitor::requestScan()
Fence: need a scan, count, %{public}d, %{public}d, dt_scan, %{private}.1lf, dt_watchdog, %{private}.1lf, interval, %{private}.1lf, needWatchdog, %{public}d
requestScan
Fence: startScan, requesting a receovery scan
requestScan.recovery
void CLFenceMonitor::scheduleLocationWatchdog(CFTimeInterval)
Fence: scheduleLocationWatchdog, at %{private}.1lf, in, %{private}.1lf, seconds
Fence: scheduleLocationWatchdog, ignore, shutdown?
void CLFenceMonitor::cancelLocationWatchdog()
Fence: loc watchdog cancel, count, %{public}d, %{public}d, client, %{public}p
Fence: cancelLocationWatchdog
Fence: cancelLocationWatchdog, ignore, shutdown?
void CLFenceMonitor::onLocationWatchdogExpired(CLPersistentTimer *)
loc watchdog expired, count, %{public}d, %{public}d
Fence: onLocationWatchdogExpired, since last, %{private}.1lf, isLocationEnabled, %{public}d, last scan, %{private}.1lf, fIsWaitingForLocationCount, %{public}d, sinceLastGpsSession, %{private}.1lf, %{private}.1lf, sinceLastContTimer, %{private}.1lf, %{private}.1lf, fScanRetryCounter, %{public}d
onLocationWatchdogExpired
sinceLastGpsSession
kSecondsBetweenGPSSessions
sinceLastContTimer
void CLFenceMonitor::handleNoLocationForExtendedDuration(const CFAbsoluteTime, const CFTimeInterval)
#Warning Fence: watchdog fired: %{private}.1lf, %{private}.1lf
void CLFenceMonitor::onDelayedTriggerTimer(CLPersistentTimer *)
Fence: onDelayedTriggerTimer, sleep period, %{private}.1lf, isLocationEnabled, %{public}d, count, %{public}d, %{public}d, sinceLastTrigger, %{private}.1lf
onDelayedTriggerTimer
void CLFenceMonitor::onDeAssTriggerTimer(CLPersistentTimer *)
Fence: onDeAssTriggerTimer, sleep period, %{private}.1lf, isLocationEnabled, %{public}d, count, %{public}d, %{public}d, sinceLastTrigger, %{private}.1lf
onDeAssTriggerTimer
void CLFenceMonitor::onContinousTrackingTimer(CLPersistentTimer *)
Fence: onContinousTrackingTimer, sleep period, %{private}.1lf, isLocationEnabled, %{public}d, sinceLastTrigger, %{private}.1lf
onContinousTrackingTimer
void CLFenceMonitor::clearLocationData(bool)
Fence: Warning data can't be cleared yet
virtual void CLFenceMonitor::shutdown()
Fence: CLFenceMonitor, shutdown
void CLFenceMonitor::onConsolidatedTrigger()
Fence: ignore, onConsolidatedTrigger, shutdown?
Fence: onConsolidatedTrigger, calling triggerReceivedNow
void CLFenceMonitor::requestWifiLocationUpdate(const char *)
Fence: request update, reason, %{private}s
geofence
CLFenceManager_Type::FenceStatus CLFenceMonitor::getCurrentFenceState(const CLFenceManager_Type::Fence &, const bool)
Fence: requestRegionState, %{private}s/%{private}s
#Warning Fence: requestRegionState, %{public}s/%{public}s, NOT FOUND, %{public}d, %{public}d
bool CLFenceMonitor::scrubFenceStates(const std::vector<CLFenceManager_Type::Fence> &)
#Warning Fence: state scrub prior unlock
void CLFenceMonitor::createActivityAlarm(const char *)
Fence: createActivityAlarm, %{private}s, %{private}p, fIsUseActivityAlarm, %{private}d
void CLFenceMonitor::createActivityAlarm(const char *)_block_invoke
Fence: activityAlarmHandler, %{private}p, %{private}s, trigger, %{private}d
activityAlarmHandler
createActivityAlarm-cleanup
void CLFenceMonitor::releaseActivityAlarm(const char *)
Fence: releaseActivityAlarm, %{private}s, %{private}p
void CLFenceMonitor::monitorSettled(bool)
Fence: start monitoring scenario trigger settled
Fence: stop monitoring scenario trigger settled
void CLFenceMonitor::onScenarioTrigger(RTScenarioTrigger *)
Fence: received scenario trigger, %{private}s
void CLFenceMonitor::onSettledTimerExpired(CLPersistentTimer *)
Fence: settled timer expired
void CLFenceMonitor::handleSettled()
Fence: dispatch, handleSettled, fence, %{private}s, monitoringStarted, %{public}d, monitoringSettled, %{public}d
CFTimeInterval CLFenceMonitor::shouldStartGps(const CFAbsoluteTime, const CFTimeInterval, const CFTimeInterval)
Fence: allowed gps time %{private}.1lf
void CLFenceMonitor::stopGps(const CFAbsoluteTime)
Fence: unregister gps client, %{private}p
#wigo,off,Fence
Fence: discarding old gps session, %{public}.1lf
Fence: adding gps session, %{public}.1lf
void CLFenceMonitor::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
Fence: state kNotificationDeviceUnlockedSinceBoot, from, %{public}d, to, %{public}d, start, %{public}d
kNotificationDeviceUnlockedSinceBoot
void CLFenceMonitor::createStateDatabase(const char *)
Fence: createStateDatabase, fStateDatabase, %{private}p, fDeviceUnlockedSinceBoot, %{public}d, reason, %{public}s
CLFenceMonitor::onBluetoothNotification
CLFenceMonitor::onLocationNotification
CLFenceMonitor::onCellMonitorNotification
CLFenceMonitor::onWifiMonitorNotification
CLFenceMonitor::onDataProtectionNotification
CLFenceMonitor::onStatusNotification
CLFenceMonitor::onDelayedTriggerTimer
CLFenceMonitor::onDeAssTriggerTimer
CLFenceMonitor::onContinousTrackingTimer
CLFenceMonitor::onLocationWatchdogExpired
CLFenceMonitor::onSettledTimerExpired
(Unknown)
(Inside)
(Outside)
(Invalid)
(No)
(Yes)
virtual void CLNotifier<CLFenceMonitor_Type::Notification, CLFenceMonitor_Type::NotificationData, char, std::string>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLFenceMonitor_Type::Notification, NotificationData_T = CLFenceMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
void CLNotifier<CLFenceMonitor_Type::Notification, CLFenceMonitor_Type::NotificationData, char, std::string>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLFenceMonitor_Type::Notification, NotificationData_T = CLFenceMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual void CLNotifier<CLFenceMonitor_Type::Notification, CLFenceMonitor_Type::NotificationData, char, std::string>::removeClient(int) [Notification_T = CLFenceMonitor_Type::Notification, NotificationData_T = CLFenceMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLFenceMonitor_Type::Notification, CLFenceMonitor_Type::NotificationData, char, std::string>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFenceMonitor_Type::Notification, NotificationData_T = CLFenceMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLFenceMonitor_Type::Notification, CLFenceMonitor_Type::NotificationData, char, std::string>::clientRegistered(int, const Notification_T &) [Notification_T = CLFenceMonitor_Type::Notification, NotificationData_T = CLFenceMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLFenceMonitor_Type::Notification, CLFenceMonitor_Type::NotificationData, char, std::string>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLFenceMonitor_Type::Notification, NotificationData_T = CLFenceMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual void CLNotifier<CLFenceMonitor_Type::Notification, CLFenceMonitor_Type::NotificationData, char, std::string>::listClients() [Notification_T = CLFenceMonitor_Type::Notification, NotificationData_T = CLFenceMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
CLFenceMonitorWifi
FenceWiFiScanOnWake
CLFenceMonitorWifi::CLFenceMonitorWifi(id<CLIntersiloUniverse>)
WIFI_LOC: Overriding fPerformScanOnWake = %{private}d
WIFI_LOC: Overriding fIsUseNetworkLocationProvider = %{private}d
Fence: failed to determine airplane mode
virtual void CLFenceMonitorWifi::shutdown()
Fence: CLFenceMonitorWifi, shutdown
void CLFenceMonitorWifi::setAirplaneAndConnectedMode(bool, bool)
Fence: airplane mode is now, %{public}d, was, %{public}d
Fence: companion connected is now, %{public}d, was, %{public}d
entry
exit
bool CLFenceMonitorWifi::startMonitoring(const CLFenceManager_Type::Fence &, bool)
Fence: Starting to monitor %{private}s/%{private}s for %{private}s
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLFenceMonitorWifi.mm
bool CLFenceMonitorWifi::stopMonitoring(const CLFenceManager_Type::Fence &)
Fence: Stopping monitoring for %{private}s/%{private}s
void CLFenceMonitorWifi::handleMonitoringDataChanged(const CLFenceManager_Type::Fence &)
Fence: Got monitoring data changed for %{private}s/%{private}s; recalculating
bool CLFenceMonitorWifi::recalculateIfNeeded()
isRecalculate, %{private}d, fIsRecalculationPending, %{private}d, sinceLastRecalculationTrigger, %{private}.1lf
Fence: power assertion no longer needed
void CLFenceMonitorWifi::recalculate()
Fence: recalculate, take power assertion
recalculate
Fence: ignore recalculation, shut down?
void CLFenceMonitorWifi::resetConsecutiveExits()
Fence: resetConsecutiveExits start, %{public}.1lf, count, %{public}d
void CLFenceMonitorWifi::recalculateNow()
Fence: ignoring recalculateNow, shut down?
Fence: Recalculating monitored WiFis for %{private}ld monitored fences, %{public}d,%{public}d
Fence: No visible APs to use for fence calculation
Fence: Including %{private}ld visible APs in fence calculation
Fence: avoid fence calculateAPsForFences, numOfFences, %{private}lu, airplane, %{public}d
Fence: isWifiTrackingAvailable is false
Fence: fIsContinuousMonitoringNeeded, %{private}d
Fence: considered in leash, %{private}d
Fence: considered not in leash, %{private}d
Fence: exit sequence is too long, reset, sinceSequenceStart, %{private}.1lf, %{private}.1lf
Fence: Setting %{private}ld background scan entry networks
Fence: Setting %{private}ld background scan exit networks
Fence: recalculate, release power assertion
void CLFenceMonitorWifi::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
Fence: Device woke; sending trigger
Fence: Device is about to go to sleep
Fence: WiFi just lost (from %{private}d to %{private}d); sending trigger, aboutToSleep, %{private}d, recentlyWoke, %{private}d,
Disconnection
Fence: about to sleep or recently woke without WoW, ignoring, kNotificationReachability
Fence: WiFi just connected (from %{private}d to %{private}d); sending trigger, aboutToSleep, %{private}d, recentlyWoke, %{private}d,
void CLFenceMonitorWifi::takePowerAssertionIfNeeded_nl(bool, const char *)
Fence: take power assertion, reason, %{private}s, airplane, %{private}d
Fence: power assertion not needed, reason, %{private}s, airplane, %{private}d, isMonitoringFences, %{private}d
CLFenceMonitorWifi::onStatusNotification
{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}8@?0
db != nullptr
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLSqliteTransaction.mm
CLSqliteTransaction
BEGIN EXCLUSIVE TRANSACTION
void CLSqliteTransaction::beginTransaction()
#sqlitetransaction, begin exclusive transaction failed
COMMIT
void CLSqliteTransaction::commit()
#sqlitetransaction, commit failed
void CLSqliteTransaction::rollback()
rollback #sqlitetransaction
#sqlitetransaction, rollback transaction failed
Path unavailable
void CLSedentaryTimerSubscription::onSedentaryTimerAlarm(int, const CLSedentaryTimerNotifier_Type::Notification &, const CLSedentaryTimerNotifier_Type::NotificationData &)
com.apple.locationd.sedentary_timer
bool CLSedentaryTimerSubscription::isEntitledForSedentaryTimer()
#Warning SedentaryAlarm,Failed entitlement check,%{public}s
void CLSedentaryTimerSubscription::handleMessageSedentaryTimerStart(std::shared_ptr<CLConnectionMessage>)
[SedentaryTimerTriage] SedentaryAlarm, handling SedentaryTimerStart message!
[SedentaryTimerTriage] SedentaryAlarm, is not qualified!
SedentaryAlarm,Failed to start,nil dictionary
void CLSedentaryTimerSubscription::handleMessageSedentaryTimerStop(std::shared_ptr<CLConnectionMessage>)
[SedentaryTimerTriage] SedentaryAlarm, handling SedentaryTimerStop message!
void CLSedentaryTimerSubscription::handleMessageSedentaryTimerQuery(std::shared_ptr<CLConnectionMessage>)
SedentaryAlarm,Failed to query,nil dictionary
void CLSedentaryTimerSubscription::handleRequestSedentaryTimerAlarm(bool, const CLNameValuePair &)
SedentaryAlarm,subscription changed, %d, %s, %p
CLSedentaryTimerSubscription::onSedentaryTimerAlarm
scanready
registrant
CLGeomagneticModelProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Compass/CLGeomagneticModelProvider.mm
-[CLGeomagneticModelProviderLocationdAdapter beginService]
CLGeomagneticModelProvider
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::removeClient(int) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGeomagneticModelProvider_Type::Notification, CLGeomagneticModelProvider_Type::NotificationData>::listClients() [Notification_T = CLGeomagneticModelProvider_Type::Notification, NotificationData_T = CLGeomagneticModelProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
const T &CMQueue<CLSwimStrokeCounter::VectorSample>::operator[](const size_t) const [T = CLSwimStrokeCounter::VectorSample]
com.apple.locationd.CLSEUnzipQueue
https://cl3.apple.com/1/v2/
clsef.bin.gz
clsef.bin
CLSignalEnvironmentProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/SignalEnvironment/CLSignalEnvironmentProvider.mm
-[CLSignalEnvironmentProviderAdapter beginService]
+[CLSignalEnvironmentProviderAdapter(IsSupported) isSupported]_block_invoke
CLSignalEnvironmentProvider is supported: %{public}d
CLSignalEnvironmentProvider
SignalEnvServerUrl
CLSignalEnvironmentProvider::CLSignalEnvironmentProvider(id<CLIntersiloUniverse>)
CLSE, server, %{public}s, overridden, 1
CLSE, server, %{public}s, overridden, 0
virtual bool CLSignalEnvironmentProvider::registerForNotificationInternal(const CLSignalEnvironmentProvider_Type::Notification &)
CLSE, Client registered for notification %{public}d
virtual bool CLSignalEnvironmentProvider::unregisterForNotificationInternal(const CLSignalEnvironmentProvider_Type::Notification &)
CLSE, Client unregistered for notification %{public}d
void CLSignalEnvironmentProvider::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#Error,CLSE,onLocationNotification,null CSE pointer
#Error,CLSE,onLocationNotification,null HRSE pointer
CLSE,fromSignalEnv,%{public}d,toSignalEnv,%{public}d,fromSignalEnvFidelityLevel,%{public}d,toSignalEnvFidelityLevel,%{public}d
void CLSignalEnvironmentProvider::downloadFileIfNeeded()
CLSE,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf
CLSE,could not setUpdateSource AVL file updater
CLSE,could not setUpdateRate AVl file updater
void CLSignalEnvironmentProvider::onSignalEnvironmentUpdated(CLFileUpdate *, CLFileUpdate::UpdateStatus)
CLSE,download status,NONE
CLSE,download status,STARTED
CLSE,download status,COMPLETED
CLSE,downloaded,%{public}s
#Warning,Cannot set protection class for CLSE downloaded file,%{public}s
void CLSignalEnvironmentProvider::onSignalEnvironmentUpdated(CLFileUpdate *, CLFileUpdate::UpdateStatus)_block_invoke
CLSE,decompressed,%{public}s,to,%{public}s
#Warning,Cannot set protection class for CLSE decompressed file,%{public}s
CLSE,download status,FAILED
CLSE,download request failed,%{public}s,retryMultiplier,%{public}d
CLSE,download status,%{public}d
CLSignalEnvironmentProvider::onSignalEnvironmentUpdated
CLSignalEnvironmentProvider::onLocationNotification
virtual void CLNotifier<CLSignalEnvironmentProvider_Type::Notification, CLSignalEnvironmentProvider_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLSignalEnvironmentProvider_Type::Notification, NotificationData_T = CLSignalEnvironmentProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLSignalEnvironmentProvider_Type::Notification, CLSignalEnvironmentProvider_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSignalEnvironmentProvider_Type::Notification, NotificationData_T = CLSignalEnvironmentProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSignalEnvironmentProvider_Type::Notification, CLSignalEnvironmentProvider_Type::NotificationData>::removeClient(int) [Notification_T = CLSignalEnvironmentProvider_Type::Notification, NotificationData_T = CLSignalEnvironmentProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSignalEnvironmentProvider_Type::Notification, CLSignalEnvironmentProvider_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSignalEnvironmentProvider_Type::Notification, NotificationData_T = CLSignalEnvironmentProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSignalEnvironmentProvider_Type::Notification, CLSignalEnvironmentProvider_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLSignalEnvironmentProvider_Type::Notification, NotificationData_T = CLSignalEnvironmentProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSignalEnvironmentProvider_Type::Notification, CLSignalEnvironmentProvider_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSignalEnvironmentProvider_Type::Notification, NotificationData_T = CLSignalEnvironmentProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSignalEnvironmentProvider_Type::Notification, CLSignalEnvironmentProvider_Type::NotificationData>::listClients() [Notification_T = CLSignalEnvironmentProvider_Type::Notification, NotificationData_T = CLSignalEnvironmentProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLManagedLocationDatabase<CLWifiLocationDatabase, CLWifiLocationDatabase::WifiData>::onDataAvailable() [Database = CLWifiLocationDatabase, DataType = CLWifiLocationDatabase::WifiData]_block_invoke
void CLManagedLocationDatabase<CLWifiLocationDatabase, CLWifiLocationDatabase::WifiData>::onDataAvailable() [Database = CLWifiLocationDatabase, DataType = CLWifiLocationDatabase::WifiData]
CLWeatherServiceSilo
-[CLWeatherService localLocationForecastUpdatedForConditions:]
received weather updated with nill weather conditions
WFWeatherPressureComponent
NWKWFWeatherForecastTimeComponent
virtual CLWorkoutPredictor_Type::WorkoutStopDetectionEvent CLStairStepperWorkoutStopModel::update(const CLWorkoutPredictorInputs &)
HRStop detect in stairclimber model during state,%{public}d
StairStop,state,%d,onCnt,%d,longStd,%f,shortStd,%f,exertionDelta,%f,exertionLow,%d,machineFreq,%f,on,%d,offCnt,%d,headCnt,%d,eDiff,%f,maxH,%f
void CLIndoorOutdoorDetector::overrideMaxAllowedSecondsForIndoorOutdoorDetector(const CFTimeInterval)
MaxAllowedSecondsForIndoorOutdoorDetector was forced to %f seconds
void CLIndoorOutdoorDetector::forceLocationType(CMWorkoutLocationType)
Location type was forced to %ld
void CLIndoorOutdoorDetector::startSession(const CLIndoorOutdoorProtocol::IndoorOutdoorSettings &)
IndoorOutdoor,starting session,currentState,%ld,disableDistance,%{public}d,forceLocation,%{public}ld,overrideSeconds,%{public}f
void CLIndoorOutdoorDetector::stopSession()
IndoorOutdoor,last state,time,%f,new location type,%ld,confidence,%ld,probability,%f
void CLIndoorOutdoorDetector::update()
IndoorOutdoor,TimeExceeded,maxAllowed,%f,timePassed,%f,locType,%d,distance,%f,outdoorProbability,%f
IndoorOutdoor,update,old probability,%{public}f,confidence,%{public}ld,state,%{public}ld,new probability,%{public}f,gpsOutdoor,%{public}f,wifiIndoor,%{public}f,alsOutdor,%{public}f,confidence,%{public}ld,state,%{public}ld
IndoorOutdoor,probabilities,llr,%{public}f,discordant,%{public}f,timeSinceStart,%{public}f,totalDistance,%{public}f,gpsOutdoor,%{public}f,wifiIndoor,%{public}f,alsOutdoor,%{public}f,probability,%{public}f,confidence,%{public}ld,location,%{public}ld
CLIndoorOutdoorProtocol::IndoorOutdoorResult CLIndoorOutdoorDetector::getResultFromProbability(float) const
IndoorOutdoor, low confidence estimate,probability,%{public}f
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Wifi::Power &) const
WifiTimer, set, power, now
wifiPowerEvent.isPoweredOff()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/Logic/Policies/CLScheduleClientUpdateTimerPolicy.mm
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Wifi::Scan &) const
WifiTimer, set, scan, %{public}d
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Wifi::ScanBusy &) const
WifiTimer, set, scanbusy, %{public}d
@EmerWarn, ScanErrorBusy, %{public}s, retry in, %{pupblic}lld, reqtype, %{public}d
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Wifi::ScanError &) const
WifiTimer, set, scanerror, %{public}d
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Client::UpdateTimer &) const
WifiTimer, nextscan, %{public}d, timer
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Wifi::LinkStatus &) const
WifiTimer, set, linkstatus, now
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Wifi::Wsb &) const
@WsbTimer, buffer, %{public}d
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::System::CoarseMotion &) const
@WifiTimer, set, motion, %{public}d
@WifiTimer, skip, motion
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Network::AlsRequestResult &) const
WsbAls, resulttag, %{public}d, wsbtag, %{public}d, delay, %{public}d, set, %{public}d
@WsbTimer, alsresult, %{public}d
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Network::AlsFinished &) const
WifiTimer, set, alsreply, now
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::System::Reachability &) const
@WsbTimer, reach, %{public}d
WifiTimer, set, reach, now
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::System::DeviceWake &) const
WifiTimer, set, wake, now
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Client::LocationRequest &) const
@WifiTimer, set, locreq, %{public}d
@WifiTimer, set, suppressed, %{public}d
@WifiTimer, skip, locreq, %{public}d, %{public}d
CL::Wifi1::Policies::ScheduleClientUpdateTimer::Output CL::Wifi1::Policies::ScheduleClientUpdateTimer::HandleEvent::operator()(const Events::Client::WsbTimer &) const
@WsbTimer, fired, 0
RunModelMetsScale
RunVMThreshold
virtual CLMetsInfo CLNatalieRunModel::computeWorkRateMETS(const CLNatalieModelInput &)
Run, WorkRate, %f, distance(m), %f, duration(s), %f, mets, %f, fMetsScaling, %f, endTime, %f, currentPace, %f, isStroller, %d, metsStrollerCorrected, %f
Run, WorkRate, Grade type, %d, vertical speed %f, interval %f, workrate %f, mets %f, mets + grade %f, percent grade %f
Run, WorkRate, energy, %.1f,mets from intensity, %.1f
Run,WorkRate,finalUserMets,%f,finalTruthMets,%f
virtual CLMetsInfo CLNatalieRunModel::computeFitnessMachineMETS(const CLNatalieModelInput &)
Run,fitness machine,computeTime,%.3f,startTime,%.3f,wr,%f,vertSpeed,%f,userMets,%f,truthMets,%f
CLRestingNotifier
CLRemoteMotionAlarmSilo
UnifiedCellLocationProvider
CLUnifiedCellLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Cell/CLUnifiedCellLocationProvider.mm
-[CLUnifiedCellLocationProviderAdapter beginService]
+[CLUnifiedCellLocationProviderAdapter(IsSupported) isSupported]
@ClxCell, supported, %{public}d
UnifiedCell
cell
CLUnifiedCellLocationProvider::CLUnifiedCellLocationProvider(id<CLIntersiloUniverse>)
@ClxCell, enabled, %{public}d
CellLocDelayedCellLocationPropagationTimer
virtual CLUnifiedCellLocationProvider::~CLUnifiedCellLocationProvider()
CellLoc, delete CLUnifiedCellLocationProvider
virtual bool CLUnifiedCellLocationProvider::registerForNotificationInternal(const CLLocationProvider_Type::Notification &)
CellLoc, registerForNotificationInternal, notification, %{public}d
virtual bool CLUnifiedCellLocationProvider::unregisterForNotificationInternal(const CLLocationProvider_Type::Notification &)
CellLoc, unregisterForNotificationInternal, notification, %{public}d
virtual void CLUnifiedCellLocationProvider::shutdown()
CellLoc, shutdown
refresh
void CLUnifiedCellLocationProvider::refreshCellState(const char *)
@CellFlow, refresh, %{public}s
virtual void CLUnifiedCellLocationProvider::logCellRefreshOutcome(const char *)
@CellFlow, outcome, %{public}s, UclpMetric
com.apple.clx.cellloc.outcome
trigger
outcome
virtual CLNetworkLocationProvider::BestMatchLevel CLUnifiedCellLocationProvider::getCellFromTilesManager(const CLCell &, CLDaemonLocation &)
CellLoc, getCellFromTilesManager, isFound, %{public}d, cell, %{private}s, location, %{private}s
virtual void CLUnifiedCellLocationProvider::setCellLocationPropagationTimer(const char *, CFAbsoluteTime, CFTimeInterval)
CellFlow, timer, %{public}s, %{public}.0f
virtual bool CLUnifiedCellLocationProvider::updateCellRefreshResults(const CLCell &, const CLDaemonLocation &)
CellFlow, skipnotify, in, %{public}d, new, %{public}d, retval, %{public}d, cell, %{public}d, latlon, %{public}d
virtual void CLUnifiedCellLocationProvider::handleLocationFailed(const char *)
@ClxCell, Fix, 0, ll, N/A, %{public}s
CLCellTilesManager
virtual void CLUnifiedCellLocationProvider::requestWiFiLocationUpdate(const char *)
CellFlow, requestWifiLocationUpdate, reason, %{public}s
uclp
void CLUnifiedCellLocationProvider::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
Cell, kNotificationReset
Cell, kNotificationLocationServicesStatus
wake
void CLUnifiedCellLocationProvider::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
UclpMetric, heartbeat, registrants, %{public}d, requests, %{public}d, infonotify, %{public}d, monitor, %{public}d
com.apple.clx.cellloc.heartbeat
registrants
requests
infonotify
monitor
UclpMetric, regperiod, %{public}d
com.apple.clx.cellloc.regperiod
heartbeat
void CLUnifiedCellLocationProvider::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
CellLoc, onCompanionNotification, notification, %{public}d, Tiles
void CLUnifiedCellLocationProvider::onTelephonyNotification(int, const CLTelephonyService_Type::Notification &, const CLTelephonyService_Type::NotificationData &)
@CellFlow, ctnotify, %{public}s, havedata, %{public}d
telNotification
CellFlow, outcome, LS Off
disconnect
CellService, unknown, %{public}s
@CellFlow, skipcalc, clients, %{public}d, get, %{public}s
void CLUnifiedCellLocationProvider::onDelayedCellPropagationTimer(CLPersistentTimer *)
CellLoc, ignore timer
CellFlow, timer, cancel, -1
void CLUnifiedCellLocationProvider::onNetworkLocationNotification(int, const CLNetworkLocationProvider_Type::Notification &, const CLNetworkLocationProvider_Type::NotificationData &)
CellQuery, notify, %{public}d
CellQuery, fail, acc, %{public}.1f, empty, %{public}d
alserror
CellQuery, response
CellQuery, no client
void CLUnifiedCellLocationProvider::clearCurrentCells(const char *)
CellFlow, clearcells, %{public}s
CLUnifiedCellLocationProvider
CLUnifiedCellLocationProvider::onStatusNotification
CLUnifiedCellLocationProvider::onTelephonyNotification
CLUnifiedCellLocationProvider::onNetworkLocationNotification
CLUnifiedCellLocationProvider::onClientNotification
CLUnifiedCellLocationProvider::onCompanionNotification
CLUnifiedCellLocationProvider::onTileDownloadNotification
CLUnifiedCellLocationProvider::onDelayedCellPropagationTimer
CLLteCellLocationDatabase::CLLteCellLocationDatabase(const char *, const CLSqliteDatabase::SqliteProperties &, double)
bool CLLteCellLocationDatabase::getLocation(const CLTelephonyService_Type::LteCell &, sqlite3_int64 &)
bool CLLteCellLocationDatabase::setLocation(const CLTelephonyService_Type::LteCell &, const CLDaemonLocation &)
bool CLLteCellLocationDatabase::getLocation(sqlite3_int64, CLTelephonyService_Type::LteCell &) const
0 && "Invalid trigger type."
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/DeviceMotion/CLSensorCalibrationStaticDetector.mm
CLSensorCalibrationStaticDetectorMotionCoprocessor
CLSensorCalibrationStaticDetectorAccel
trigger != kTriggerTypeMoving || duration == 0.
LogGyroCalibrationStaticDetectorAccelState
void CLSensorCalibrationStaticDetectorAccel::processStaticMoving(bool, CLMotionTypeTimestamp)
moving,%d,now,%f
void CLSensorCalibrationStaticDetectorAccel::fire()
CLSensorCalibrationStaticDetectorAccel::fire()
readyX == readyY && readyX == readyZ
onAccelerometerData
void CLSensorCalibrationStaticDetectorAccel::onAccelerometerData(const CLAccelerometer::Sample *, unsigned int)
RawAccelerometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f
FilteredAccelerometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,readyX,%d
Variance,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,Moving,%d
CLSensorCalibrationStaticDetectorAccel::onAccelerometerData
Accepted
Rejected
Replaced
AcceptedAndInsertMissing
std::vector<CLSwimDetectedLap> CLSwimLapDetect::addTurn(CLSwimDetectedTurn)
(stddev samples) w/ turn, %f, %d, w/o turn, %f, %d, threshold, %f, %f
Turn, %s, Time, %f, Total Strokes, %d, Current Strokes, %d, Style, %d, Result, %d
Converged,freestyle,%d,backstroke,%d,breaststroke,%d,butterfly,%d
bool CLSwimLapDetect::convergedHistoricalSessionTurns(CLSwimDetectedTurn, CLSwimStrokesPerTurnDistribution &) const
searchMedian, %f, historicalDistributionCount, %lu, historicalMatchingDistributionCount, %lu
std::pair<float, float> CLSwimLapDetect::getLapStrokeThreshold(CLSwimDetectedTurn) const
distribution,localLimits,min,%f,max,%f
distribution,historicalSessionLimits,min,%d,max,%f
distribution,lastGood-populationLimits,min,%d,max,%f
0.f <= val && val <= 1.f
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Swimming/CLSwimLapDetect.cpp
prctile
std::vector<CLSwimDataInterface::StrokeEntry> CLSwimLapDetect::getStrokesInLap(float &, CLSwimDetectedLap) const
lap detected with one or less strokes,strokes,%lu,lapType,%d
FSTMotionType CLFunctionalStrengthMotionClassifier::classifyMotion(const CLFunctionalStrengthDMIntermediateFeatures &)
FST DM Features, startTime, %f, accelMag, %f, inertialAccelZMag, %f, rotationalAccelZMag, %f, rotationToAccelCorrelation, %f, pctDominanceCrownPlane, %f, gravityX, %f, pBody, %f, FSTMotionType, %d
FSTMotionType CLFunctionalStrengthMotionClassifier::classifyByLikelihoodBody(const float)
FSTMotionClassifier, classifyByLikelihoodBody, FSTMotionType, %d, pBody, %f
bool CLFunctionalStrengthMotionClassifier::containsBodyMotion(const float, const float, const float)
FSTMotionClassifier, containsBodyMotion, %d, isNotDominantlyPlanar, %d, isBodyRangeAccelZMag, %d, isModerateBodyLikelihood, %d
GyroBias
void CLSensorFusionServiceAP::onBiasAndVariance(const CLMotionTypeGyroBiasAndVariance)_block_invoke
Type,%s,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d
merge_azimuth_ranges
merged=
, mergedRange 
CLPlosPolygon::AzimuthRangeSet CLPlosPolygon::blockedAzimuth(const CLPlosPolygon::Point &, const CLPlosPolygon::Polygon &)
az_prev is not initialized before usage
blockedAzimuth
origin 
, point 
, az,
, prev point,
merging start range 
 and end range 
blockedRanges has following contents:
getClosestPointOnPolygon
point,
, prev_point,
, point_iter,
, distanceSqr,
,min distance,
,closest,
,minClosestPoint,
std::vector<CLPlosPolygon::Particle> CLPlosPolygon::sampleExteriorPoints(const CLPlosPolygon::PolygonReal2D &, const float &, const float &)
#Warning, PLOS: invalid outside offset %{public}f
#Warning, PLOS: bad poly, bad!
std::vector<CLPlosPolygon::Particle> CLPlosPolygon::sampleParticlesOnPolygon(const CLPlosPolygon::PolygonReal2D &, float)
#Warning, PLOS: invalid step size %{public}f
#Warning, PLOS: miniscule edge!
CLPlosPolygon::PolygonReal2D CLPlosPolygon::inflatePolygon(const CLPlosPolygon::PolygonReal2D &, float)
#Warning, PLOS: invalid distance %{public}F
#Warning, PLOS: invalid polygon size %{public}d
#Warning, PLOS: edge too small!
Verbose
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Client::UpdateTimer &) const
WifiTimer, reissue, %{public}d, force, %{public}d, time, %{public}d, %{public}.1f, %{public}.1f, %{public}.1f, place, %{public}d, %{public}d
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Wifi::Power &) const
@EmerTick, wifi, %{public}.1f
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Wifi::Scan &) const
WifiFlow, scanreply, warn, ToggleOff
@EmerTick, scanreply, %{public}.1f
@EmerFlow, ScanReply, %{public}s, aps, %{public}lu, tte, %{public}.1f
@EmerWarn, unexpected state, onWifiNotification, %{public}d, #CloneMe
@EmerTick, scanreply5ghz, %{public}.1f
ScanReply5GHzWithAlsReply
ScanReply5GHzWithPendingAls
@EmerFlow, %{public}s, %{public}s, aps, %{public}lu, tte, %{public}.1f
@EmerWarn, ignore scan, %{public}s
WifiFlow, scanreply, warn, pre-privacy, %{public}d, scan, %{public}d, privacy, %{public}d
@WifiFlow, scanreply, aps, %{public}lu, type, %{public}s, lastused, %{public}d, use, %{public}d, history, %{public}ld, lsbclients, %{public}d, %{public}d, %{public}d, reqtype, %{public}s
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Wifi::ScanError &) const
WifiFlow, scanreply, warn, error
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Wifi::ScanBusy &) const
WifiFlow, scanreply, warn, busy
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Wifi::Wsb &) const
@WsbGroup, add, %{public}lu, aps, %{public}lu, time, %{public}.1f
WsbMetric, scanaps, %{public}lu
com.apple.clx.wsb.scanaps
@WsbGroup, last, %{public}lu, aps, %{public}lu, time, %{public}.1f
@WsbDiscard, privacy, %{public}.1f, aps, %{public}ld, delta, %{public}.1f
WsbMetric, groupresult, privacy, %{public}d
discard
discard:privacy
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::System::Privacy &) const
@WsbDiscard, privacy, %{public}.1f, aps, %{public}ld
@EmerTick, toggle, %{public}.1f
@EmerFlow, ToggleOn, %{public}.1f
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Network::AlsRequestResult &) const
@WifiFlow, alsreply, aps, 0, tag, -1
WsbMetric, als, %{public}s, %{public}s, %{public}ld
com.apple.clx.wsb.als
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Network::AlsFinished &) const
@WifiFlow, alsreply, aps, %{public}d, tag, %{public}d
EmerCheck, als, top, highinteg, %{public}d, emer, %{public}d, state, %{public}d
@EmerTick, alsreply, %{public}.1f
@EmerFlow, AlsReply, aps, %{public}d, tag, %{public}d, queryType, %{public}d, tte, %{public}.1f
@EmerTick, preliminaryAlsReplyTick, %{public}.1f
ScanRequest5GHzWithAlsReply
@EmerFlow, %{public}s, aps, %{public}d, tag, %{public}d, queryType, %{public}d, tte, %{public}.1f
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Network::AlsAllUnknown &) const
WsbAls, reply, 0
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Client::LocationRequest &) const
WlpMetric, locreq, %{public}s, dt, %{public}d
com.apple.clx.wifiloc.locreq
locreq
delta
WifiFlow, locreq, skip, WifiOff
@WifiFlow, locreq, %{public}s, %{public}s, current, %{public}s
@WifiFlow, platform not support 5GHz, revert to default inter-locreq state
@WifiFlow, inter-locreq state per request type, %{private}s, current %{public}s, staging %{public}s
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::System::MetricHeartbeat &) const
WlpMetric, heartbeat, requesters, %{public}d, aware, %{public}d, gf, %{public}d, slc, %{public}d, speedest, %{public}d, cpi, %{public}d, registrant, %{public}d, scanready, %{public}d, emer, %{public}d, timer, %{public}d, other, %{public}d
WlpMetric, heartbeat, locreqtypes, %{public}d, cpi, %{public}d, lowpower, %{public}d, clientupdate, %{public}d, emergency, %{public}d, other, %{public}d
WlpMetric, heartbeat, scanreqtypes, %{public}d%{public}s, other, %{public}d
WlpMetric, heartbeat, empty scans per scanreqtypes %{public}s
WlpMetric, heartbeat, misc, %{public}d, alsAps, %{public}d, fixes, %{public}d, scanErrors, %{public}d, scanBusys, %{public}d
com.apple.clx.wifiloc.requesters
com.apple.clx.wifiloc.requesttypes
com.apple.clx.wifiloc.scantypes
com.apple.clx.wifiloc.fixapcountperscantype
scantype
fixApsBucketed
wifiFixes
WlpMetric, heartbeat, scanreqtype, %{public}s, fix ap count per bucket %{public}s
com.apple.clx.wifiloc.heartbeat
beats
alsAps
fixes
scanErrors
scanBusys
WlpMetric, clients, beat, %{public}d, sum, %{public}d, bin, %{public}d
com.apple.clx.wifiloc.clients
WlpMetric, locreq, heartbeat, dt, %{public}d
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Client::Registration &) const
WlpMetric, clients, reg, %{public}d, sum, %{public}d, bin, %{public}d
register
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Client::Unregistration &) const
WlpMetric, clients, unreg, %{public}d, sum, %{public}d, bin, %{public}d
unregister
@WifiFlow, reset inter-locreq state, current, %{public}s, staging, %{public}s
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::Client::EmergencyState &) const
@EmerFlow, StateChange, wasEmer, %{public}d, nowEmer, %{public}d
@EmerTick, on, %{public}.1f
@EmerFlow, RequestWifiOn
@EmerFlow, Off, any, %{public}.1f, sufficient, %{public}.1f
@EmerFlow, RequestWifiOff
CL::Wifi1::Policies::PrePositionCalculationStateUpdate::Output CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::operator()(const Events::ReprocessWifiScanBuffer &) const
WsbReproc, pass, %{public}d, groups, %{public}ld
@WsbReproc, inrange, %{public}.1f, count, %{public}d
@WsbDiscard, age, %{public}.1f, aps, %{public}d, delta, %{public}d
WsbMetric, groupresult, aged, %{public}d
discard:aged
Emer
Frozen
Static
Assoc
InvalidAssoc
cl::chrono::secondsf CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::selectNextScanInterval(CLMotionActivity::Type, bool) const
WifiTimer, nextscan, %{public}d, haveLoc, %{public}d, codepath, %{public}s
static void CL::Wifi1::Policies::PrePositionCalculationStateUpdate::HandleEvent::removeOldApsFromWifiScanHistory(cl::chrono::CFAbsoluteTimeClock::time_point, std::shared_ptr<Types::WifiScanHistory>)
remove old APs from scan history, count, %{public}ld, max_secs, %{public}lld
void CL::Wifi1::Types::WifiScanHistory::addScan(const CL::Wifi1::Types::WifiScan &)
@WifiAps, history, %{public}lu, add, %{public}lu
SignificantTimeChangeNotification
CLRunningAggregatorAWDSilo
CLSwimPersistence
SELECT * FROM SwimDistributions ORDER BY id DESC
INSERT INTO SwimDistributions (loiUuid, poolLength, style, mean, median, min, max, stddev, samples, prctile10, prctile90, uuid) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
bool CLSwimPersistence::insertDistribution(const CLSwimStrokesPerTurnDistribution &)
Unable to persist swim distribution
recordsToRetain < maxRecords
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Swimming/CLSwimPersistence.mm
purgeDistributions
DELETE From SwimDistributions WHERE id <= (SELECT MAX(id) From SwimDistributions) - ?
void CLSwimPersistence::purgeDistributions(int, int)
Unable to purge old records.
SELECT COUNT(*) FROM SwimDistributions
int CLSwimPersistence::countDistributions() const
Unable to get the number of distributions
DELETE FROM SwimDistributions
void CLSwimPersistence::deleteAllDistributions()
Unable to delete all distributions!
SELECT * from SwimHistory ORDER by rowid DESC limit ?
CMError CLSwimPersistence::getEntries(int, std::vector<CLSwimEntry> &) const
CLSwimPersistence,getEntries,unable to get entries,numberOfRecords,%d
SELECT * from SwimHistory WHERE uuid = ?
CMError CLSwimPersistence::getEntries(unsigned char *, std::vector<CLSwimEntry> &) const
CLSwimPersistence,unable to get entries for uuid %{public}s
SELECT * from SwimHistory WHERE id >= ?
CMError CLSwimPersistence::querySince(const CLSwimEntry &, std::vector<CLSwimEntry> &) const
CLSwimPersistence, querySince, failed to bind id in query, %{public}llu
CMError CLSwimPersistence::getMostRecentLap(CLSwimEntry &) const
#Warning returning default entry after querying empty db for most recent lap
DELETE from SwimHistory WHERE startTime < ?
long CLSwimPersistence::aggregateRecordsInternal(const CLAggregationRules &, CFAbsoluteTime)
CLSwimPersistence, aggregateRecordsInternal, unable to purge records.
SELECT * from SwimHistory
SwimHistory
SwimDistributions
SELECT * from SwimHistory ORDER BY rowid DESC LIMIT 1
DELETE FROM SwimHistory
INSERT INTO SwimHistory (uuid, startTime, endTime, timestamp, pace, distance, poolLength, entryType, style, numberOfStrokes, totalLaps, segment) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
virtual void CLSwimPersistence::insertRecordUL(const CLSwimEntry &, bool)
CLSwimPersistance, unable to insert swim record.
poolLength
entryType
style
numberOfStrokes
totalLaps
segment
loiUuid
median
stddev
samples
prctile10
prctile90
CLActivityRecorderDb<CLSwimEntry>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSwimEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLSwimEntry>::setDatabaseAccessible() [T = CLSwimEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLSwimEntry>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLSwimEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLSwimEntry>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLSwimEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLWorkoutPredictor::CLWorkoutPredictor(CLWorkoutPredictorSources &, CLWorkoutPredictor_Type::OnWorkoutPrediction, std::shared_ptr<CLNonInterruptingTimer>, CLIndoorOutdoorProtocol *)
Workout Predictor - Saved session id found, sending de-escalation: %s
bool CLWorkoutPredictor::getSessionIdFromCache(uuid_t &) const
Workout Predictor - Retrieving session id: %s
void CLWorkoutPredictor::saveSessionIdInCache(const uuid_t &) const
Workout Predictor - Saving session id: %s to daemon cache.
void CLWorkoutPredictor::clearSessionIdInCache() const
Workout Predictor - Clearing session id from daemon cache.
void CLWorkoutPredictor::feedMotionStateUpdate(const CLWorkoutPredictorActivity &)
New AP escalation detected for workout type, %{public}ld, with startTime, %{public}f
Current state of Workout Predictor: %{public}d
int CLWorkoutPredictor::getDelayInEpochsForStartRemindersForLabel(CMWorkoutType) const
Failed to get workout start reminder delay for workout type: %ld.
void CLWorkoutPredictor::checkDeescalationAndSignal(CLWorkoutClassifier_Type::CLWorkoutClassifierResult &)
Workout Predictor Deescalating,shouldMute,%{public}d,startAlertEnabled,%{public}d,tier2,%{public}lu,backgroundDeescalate,%{public}d,isTrackingAltWalk,%{public}d,vehicular,%{public}d,supportedAlertType,%{public}d
bool CLWorkoutPredictor::isWaitingForIndoorOutdoorDisambiguation(const CLWorkoutPredictor::ELabelerUpdate *) const
isWaitingForIndoorOutdoorDisambiguation,%{public}d,permission,%{public}d,enabled,%{public}d
DeviceSupportsCyclingAutoStartReminders
bool CLWorkoutPredictor::isSameWorkout(const CLWorkoutPredictor::ELabelerUpdate *const) const
Checking if resuming the same workout: previous=%{public}ld new=%{public}ld
Checking to see if we should retract stop alert. Workout is the same.
bool CLWorkoutPredictor::isSameLocation(const CLWorkoutPredictor::ELocationTypeUpdate *const) const
Checking if resuming in the same location: previous=%{public}ld new=%{public}ld
void CLWorkoutPredictor::enterConfirmStopRetraction(const CLWorkoutPredictor::ELabelerUpdate *const)
User started activity again. Check to see if we should retract stop alert. Bringing up indoor/outdoor detector.
void CLWorkoutPredictor::enterLabelAvailable_waitForIndoorOutdoor(const CLWorkoutPredictor::ELabelerUpdate *)
Transitioned to kLabelAvailable state, wait for indoor/outdoor.
void CLWorkoutPredictor::enterLabelAvailable(const CLWorkoutPredictor::ELabelerUpdate *)
Transitioned to kLabelAvailable state.
void CLWorkoutPredictor::enterWorkoutStarted(const CLWorkoutPredictor::EStartReminderDelayExpired *)
Transitioned to kWorkoutStarted.
void CLWorkoutPredictor::enterWorkoutStoppedAfterStartConfirmation(const CLWorkoutPredictor::EStopDetected *)
Transitioned to kWorkoutStopped (stop was detected after start confirmation).
void CLWorkoutPredictor::muteStartAlert(const CLWorkoutPredictor::EMuteAlert *)
Start alerts will be muted for %{public}f seconds for type %{public}ld.
void CLWorkoutPredictor::updateIndoorOutdoorState(const CLWorkoutPredictor::ELocationTypeUpdate *)
Received indoor/outdoor update.
void CLWorkoutPredictor::workoutConfirmedLocationUpdate(const CLWorkoutPredictor::ELocationTypeUpdate *)
Received indoor/outdoor disambiguation for a one button workout, new location update %{public}ld
void CLWorkoutPredictor::updateLabel_teardownIndoorOutdoor(const CLWorkoutPredictor::ELabelerUpdate *)
Updating label startTime to %{public}f and tearing down indoor/outdoor.
void CLWorkoutPredictor::updateLabel(const CLWorkoutPredictor::ELabelerUpdate *)
Updating label to %{public}ld.
void CLWorkoutPredictor::enterWorkoutConfirmedStopEnabled(const CLWorkoutPredictor::EUserStartedWorkout *)
User confirmed start of a workout (and stop is enabled).
void CLWorkoutPredictor::doUserStartedWorkout(const CLWorkoutPredictor::EUserStartedWorkout *)
User confirmed start of a workout.
User started workout based on prediction.
User started workout (%{public}ld) that differs from prediction (%{public}ld).
void CLWorkoutPredictor::bringupActiveStateDetector()
Trying to bringup ActiveStateDetector
Trying to bringup ActiveStateDetector,but already running
Bringing up ActiveStateDetector
void CLWorkoutPredictor::teardownActiveStateDetector()
Trying to tear down ActiveStateDetector
Tearing down ActiveStateDetector
void CLWorkoutPredictor::feedUserWorkoutStop()
Workout, Error stopping, no active workouts
void CLWorkoutPredictor::feedActivePedStateUpdate(const CMActivePedStateEntry &)
ActiveStateDetector should be active?
void CLWorkoutPredictor::feedSkiUpdate(bool)
CMWorkoutType CLWorkoutPredictor::updateWorkoutTypeForOneButtonWorkouts(CMWorkoutType)
Indoor/outdoor detector unable to disambiguate location for walking
Indoor/outdoor detector unable to disambiguate location for running
Called updateWorkoutTypeForOneButtonWorkouts when not in a one button workout
Updated workout type for one button workout to %{public}ld
void CLWorkoutPredictor::bringupLabeler()
Bringing up WorkoutLabeler
void CLWorkoutPredictor::teardownLabeler()
Tearing down labeler
void CLWorkoutPredictor::teardownStopDetector()
Tearing down stop detector
void CLWorkoutPredictor::onTier2ClassifierActivate()
Bringing up Tier2 Classifier
void CLWorkoutPredictor::onTier2ClassifierDeactivate()
Tear down tier2 classifier
void CLWorkoutPredictor::onTurnDetectorDeactivate()
Trying to tear down TurnDetector,%d
void CLWorkoutPredictor::onTurnDetectorActivate()
Trying to bring up TurnDetector,%d
void CLWorkoutPredictor::bringupIndoorOutdoor()
Bringing up Indoor/Outdoor detector,isActive,%{public}d
void CLWorkoutPredictor::teardownIndoorOutdoor()
Teardown indoor/outdoor,isActive,%{public}d
bool CLWorkoutPredictor::triggerWorkoutLocationUpdateForUserStartedWorkouts(CMWorkoutLocationType)
Forced location signal, new workout location: %zd
Cannot force location signal; isValidWorkoutForLocationTbd: %d, IsLocationTbd: %d, fEnableForcedWorkoutLocationUpdatesFromSPI: %d
void CLWorkoutPredictor::checkIfOneButtonWorkoutAndBringupIndoorOutdoor()
Entering a one button workout
void CLWorkoutPredictor::enterWorkoutStoppedBeforeStartConfirmation(const T *) [T = CLWorkoutPredictor::EDeescalate]
Transitioned to kInit (stop was detected prior to start confirmation).
void CLWorkoutPredictor::teardown(const T *) [T = CLWorkoutPredictor::EDeescalate]
Tearing down. Resetting workout prediction.
void CLWorkoutPredictor::teardownAndNotifyDeEscalation(const T *) [T = CLWorkoutPredictor::EPreferenceChanged]
Tearing down. Resetting workout prediction. Notifying clients.
void CLWorkoutPredictor::teardown(const T *) [T = CLWorkoutPredictor::EPreferenceChanged]
void CLWorkoutPredictor::teardownAndNotifyDeEscalation(const T *) [T = CLWorkoutPredictor::EStartReminderDelayExpired]
void CLWorkoutPredictor::teardown(const T *) [T = CLWorkoutPredictor::EStartReminderDelayExpired]
void CLWorkoutPredictor::enterWorkoutStoppedBeforeStartConfirmation(const T *) [T = CLWorkoutPredictor::EStopDetected]
void CLWorkoutPredictor::teardown(const T *) [T = CLWorkoutPredictor::EStopDetected]
void CLWorkoutPredictor::partialTeardownWhenStopIsDisabled(const T *) [T = CLWorkoutPredictor::EPreferenceChanged]
Tearing down for StopDisabled
void CLWorkoutPredictor::bringupStopDetector(const T *) [T = CLWorkoutPredictor::EMuteAlert]
Bringing up StopDetector
userWorkoutType: fStopDetector->setWorkoutType(%ld,%ld)
predictedWorkoutType: fStopDetector->setWorkoutType(%ld,%ld)
void CLWorkoutPredictor::retractStopAlert(const T *const) [T = CLWorkoutPredictor::ELabelerUpdate]
Retracting stop alert.
!uuid_is_null(fCurrentPrediction.sessionId)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Workout/Prediction/Algorithm/CLWorkoutPredictor.mm
retractStopAlert
void CLWorkoutPredictor::teardownCheckingLocationForStopRetractionState(const T *const) [T = CLWorkoutPredictor::ELabelerUpdate]
Tearing down StopDetector and IndoorOutdoor detector.
void CLWorkoutPredictor::bringupStopDetector(const T *) [T = CLWorkoutPredictor::ELabelerUpdate]
void CLWorkoutPredictor::retractStopAlert(const T *const) [T = CLWorkoutPredictor::ELocationTypeUpdate]
void CLWorkoutPredictor::teardownCheckingLocationForStopRetractionState(const T *const) [T = CLWorkoutPredictor::ELocationTypeUpdate]
void CLWorkoutPredictor::partialTeardownWhenStopIsDisabled(const T *) [T = CLWorkoutPredictor::EMuteAlert]
activating
deactivating
auto CLWorkoutPredictor::CLWorkoutPredictor(CLWorkoutPredictorSources &, CLWorkoutPredictor_Type::OnWorkoutPrediction, std::shared_ptr<CLNonInterruptingTimer>, CLIndoorOutdoorProtocol *)::(anonymous class)::operator()(bool) const
Workout Predictor is %s GPS
void CLWorkoutPredictor::teardown(const T *) [T = CLWorkoutPredictor::EUserEndedWorkout]
void CLWorkoutPredictor::resetMuteStartAlert(const T *) [T = CLWorkoutPredictor::EStartReminderDelayExpired]
Resetting mute alerts for start
void CLWorkoutPredictor::bringupStopDetector(const T *) [T = CLWorkoutPredictor::EStartReminderDelayExpired]
void CLWorkoutPredictor::teardownAndNotifyDeEscalation(const T *) [T = CLWorkoutPredictor::EMuteAlert]
void CLWorkoutPredictor::teardown(const T *) [T = CLWorkoutPredictor::EMuteAlert]
void CLWorkoutPredictor::bringupStopDetector(const T *) [T = CLWorkoutPredictor::ELocationTypeUpdate]
void CLWorkoutPredictor::bringupStopDetector(const T *) [T = CLWorkoutPredictor::EPreferenceChanged]
void CLWorkoutPredictor::bringupStopDetector(const T *) [T = CLWorkoutPredictor::EUserStartedWorkout]
void CLWorkoutPredictor::partialTeardownWhenStopIsDisabled(const T *) [T = CLWorkoutPredictor::EUserStartedWorkout]
void CLWorkoutPredictor::resetMuteStartAlert(const T *) [T = CLWorkoutPredictor::EUserStartedWorkout]
CLCoverState
void CLCyclingWorkoutDistanceController::feedWorkoutEvent(const CLMotionStateMediator_Type::WorkoutEvent &)
CLCyclingWorkoutDistanceController, received event, %{public}ld, workout, %{public}ld, current state, %{public}d
CLCyclingWorkoutDistanceController, state after workout event, %{public}d
void CLCyclingWorkoutDistanceController::toggleGps(bool)
CLCyclingWorkoutDistanceController, toggling gps, %{public}d
void CLCyclingWorkoutDistanceController::sendOdometerData(const std::vector<CLOdometerEntry> &) const
CLCyclingWorkoutDistanceController, notifying clients with num updates, %{public}lu, start, %{public}f, end, %{public}f
CLCyclingWorkoutDistanceController, sending update, %{public}f
const T &CMQueue<unsigned long long>::operator[](const size_t) const [T = unsigned long long]
CLSkiNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Skiing/CLSkiNotifierAdapter.mm
-[CLSkiNotifierAdapter beginService]
-[CLContextManagerAbsoluteAltimeter initWithUniverse:delegate:withBuffer:withSourceAggregator:]
Absolute Altimeter Context created
AbsoluteAltimetryWifi
AbsoluteAltimetryGPS
registering for phone detailed connection updates on watch
-[CLContextManagerAbsoluteAltimeter setupTimers]_block_invoke
unsubscribing from Wifi notifications
unsubscribing from GPS notifications
-[CLContextManagerAbsoluteAltimeter sourceUpdated:]
absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source timestamp %f this should be one shot
-[CLContextManagerAbsoluteAltimeter forceGPSIfUnderground]
checking if DEM underground, latest alt timestamp %f, latest abs alt %f
Altimeter, power assertion GPS underground
forcing GPS, detected underground, altitude %f, DEM %f, DEM source %d, time, %f
-[CLContextManagerAbsoluteAltimeter calculateAndSendAltitudeFromCompanion]
absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source %d, timestamp %f
-[CLContextManagerAbsoluteAltimeter calculateAndSendAltitudeFromLocation]
GPS too far from DEM, not updating altitude
-[CLContextManagerAbsoluteAltimeter forceLocationAtTime:]
will not force Wifi/GPS, phone connected %d, phone has pressure %d, and sensor is dry
Altimeter, power assertion Wifi
subscribing to Wifi notifications %f
Altimeter, power assertion GPS
subscribing to GPS notifications %f
-[CLContextManagerAbsoluteAltimeter filteredElevation:withTimestamp:]
latest KF pressure %f
average KF elevation %f, average timestamp %f
-[CLContextManagerAbsoluteAltimeter wetStateUpdated:]
absolute altimeter wet state updated to %d
absolute altimeter: watch wet, forcing location
-[CLContextManagerAbsoluteAltimeter calculateAndSendAltitudeFromBaro]
bias age is %f
absolute altitude corrected %f, absolute altitude before correction %f, weather %f, timestamp %f
absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source %d, timestamp, %f, bias uncertainty, %f
-[CLContextManagerAbsoluteAltimeter chooseUncertaintyDuringWorkout:withAltitude:atTime:]
in outdoor workout: location buffer empty, pressure timestamp, %f
discrepancy between DEM and altiude in workout, discrepancy, %f, DEM, %f, altitude, %f, pressure timestamp, %f, location timestamp, %f
-[CLContextManagerAbsoluteAltimeter onCompanionConnectionNotification:data:]
received phone connection updates, is phone connected %d, does phone have pressure sensor %d
GaitMetricsHistory
virtual CMError CLMobility::GaitMetricsRecorderDb::queryGaitMetricsInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<GaitMetrics> &)
GaitMetricsHistory not accessible
virtual bool CLMobility::GaitMetricsRecorderDb::mostRecentGaitMetrics(CLMobility::GaitMetrics &)
[GaitMetricsHistory] Database inaccessible, unable to query
[GaitMetricsHistory] Most recent gait metrics: No recent records in database
[GaitMetricsHistory] Most recent gait metrics: Query error
[GaitMetricsHistory] Most recent gait metrics: unexpected return type
DELETE FROM GaitMetricsHistory WHERE startTime > ?
DELETE FROM GaitMetricsHistory
DELETE FROM GaitMetricsHistory WHERE startTime < ?
SELECT * from GaitMetricsHistory ORDER BY startTime ASC
SELECT COUNT(*) FROM GaitMetricsHistory
SELECT * FROM GaitMetricsHistory WHERE startTime BETWEEN ? and ? ORDER BY startTime ASC
SELECT * FROM GaitMetricsHistory ORDER BY id DESC LIMIT 1
INSERT INTO GaitMetricsHistory (startTime, timestamp, walkingSpeed, doubleSupportPercentage, stepLength, deviceSide, asymmetryProbability, segmentsRejectedByIsSwingStanceCycle, segmentsRejectedByIsNotRunning, segmentsRejectedByIsFeasibleWalkingSpeed, segmentsRejectedByIsPendular, cycleTime, segmentsRejectedByIsSufficientVerticalTwist, segmentsRejectedByIsCadenceConcordant, userHeight, isHeightSet, userWeight, isWeightSet) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
UPDATE GaitMetricsHistory SET startTime = startTime + ?
virtual void CLMobility::GaitMetricsRecorderDb::insertRecordUL(const CLMobility::GaitMetrics &, bool)
[GaitMetricsRecorderDb] Inserting record %{public}f
ALTER TABLE GaitMetricsHistory ADD COLUMN 
UPDATE GaitMetricsHistory SET 
asymmetryProbability
cycleTime
CLActivityRecorderDb<CLMobility::GaitMetrics>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLMobility::GaitMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLMobility::GaitMetrics>::setDatabaseAccessible() [T = CLMobility::GaitMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLMobility::GaitMetrics>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::GaitMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLMobility::GaitMetrics>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLMobility::GaitMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CellLocationCounts
CellLocationBoxes
CellLocationLocalCounts
CellLocationLocalBoxes
CdmaCellLocationCounts
CdmaCellLocationBoxes
CdmaCellLocationLocalCounts
CdmaCellLocationLocalBoxes
WifiLocation
WifiLocationCounts
WifiLocationBoxes
WifiLocationLocal
WifiLocationLocalCounts
WifiLocationLocalBoxes
CellLocationHarvest
CellLocationHarvestCounts
CdmaCellLocationHarvest
CdmaCellLocationHarvestCounts
WifiLocationHarvest
WifiLocationHarvestCounts
WtwLocationHarvest
WtwLocationHarvestCounts
LocationHarvest
LocationHarvestCounts
CompassSettings
void SqliteDatabase_Helper_dropObsoleteTablesFromConsolidatedDatabase()
consolidated database not valid; unable to drop obsolete tables
AppHarvest
AppHarvestCounts
CdmaCellNeighborsLocationHarvest
CdmaCellNeighborsLocationHarvestCounts
CellNeighborsLocationHarvest
CellNeighborsLocationHarvestCounts
IndoorLocationHarvest
IndoorLocationHarvestCounts
IndoorWifiHarvest
IndoorWifiHarvestCounts
IndoorHarvest
IndoorHarvestCounts
LteCellLocationHarvest
LteCellLocationHarvestCounts
LteCellNeighborsLocationHarvest
LteCellNeighborsLocationHarvestCounts
PassHarvest
PassHarvestCounts
PoiHarvestLocation
PoiHarvestLocationCounts
PoiHarvestMUID
PoiHarvestMUIDCounts
PoiHarvestWifi
PoiHarvestWifiCounts
PressureLocationHarvest
PressureLocationHarvestCounts
PressurePressureHarvest
PressurePressureHarvestCounts
SCDMACounts
ScdmaCellNeighborsLocationHarvest
ScdmaCellNeighborsLocationHarvestCounts
TraceHarvest
TraceHarvestCounts
void SqliteDatabase_Helper_dropObsoleteTablesFromClassBDatabase()
Class B database not valid; unable to drop obsolete tables
Database
virtual CLMetsInfo CLNatalieCrossTrainingModel::computeMETS(const CLNatalieModelInput &)
Cross Training, Compendium METS, METS, %f
double CLHRMaxEstimator::getEstimatedHRMax(const CLBodyMetrics &, CLHRMaxFeatures &) const
HRMaxEstimator,vo2MaxObservedHRMax,%{private}f,ageAndBetaBlockerPredictedHrMax,%{private}f,hrMaxCeiling,%{private}f,estimatedHRMax,%{private}f
double CLHRMaxEstimator::getObservedHRMaxFromVO2MaxClusters(bool) const
HRMaxEstimator,clusterHrMean,%{private}f,vo2MaxModelSource,%{private}d
HRMaxEstimator,observedHRMax,%{private}f
CLAvengerObservationReporterServiceSilo
CLAvengerObservationReporterService
CLGnssProviderSilo
-[CLGnssProviderAdapter init]
CLGnssProviderStub.mm
-[CLGnssProviderAdapter beginService]
-[CLGnssProviderAdapter endService]
-[CLGnssProviderAdapter resetControlPlaneStatus]
-[CLGnssProviderAdapter syncgetControlPlaneStatusReport:]
-[CLGnssProviderAdapter syncgetActiveGnssBands:]
-[CLGnssProviderAdapter cacheEmergencyAWDStatistics:]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/GPS/CLGnssProviderStub.mm
-[CLGnssProviderAdapter syncgetIonosphereParameters:]
-[CLGnssProviderAdapter emergencyStateChange:]
-[CLGnssProviderAdapter emergencySettingsChange:withReason:]
-[CLGnssProviderAdapter shouldLockoutNilr:]
addClient
CLManagedLocationDatabase<CLWifiLocationDatabase, CLWifiLocationDatabase::WifiData>::CLManagedLocationDatabase(std::string, bool, std::unique_ptr<IExternal>, std::string) [Database = CLWifiLocationDatabase, DataType = CLWifiLocationDatabase::WifiData]
CLManagedLocationDatabase<CLCellLocationDatabase, CLTelephonyService_Type::Cell>::CLManagedLocationDatabase(std::string, bool, std::unique_ptr<IExternal>, std::string) [Database = CLCellLocationDatabase, DataType = CLTelephonyService_Type::Cell]
Creating managed location database %s (count triggers %d, use cache %d)
Data protection is enabled, creating in-memory database for table %s
Persistent database failed to create despite data protection not enabled. Falling back to in-memory database
fDatabase && fDatabase->isDatabaseValid()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Utilities/CLManagedLocationDatabase.h
CLManagedLocationDatabase
fInMemoryTransaction == nullptr
beginInMemoryTransaction
-InMemoryDatabase
float CLAdaptiveExerciseMinuteThresholdUpdater::update(const CLBodyMetrics &)
ExerciseMinuteThresholdUpdater, begin tracking elapsed time for updates
ExerciseMinuteThresholdUpdater, could not get records from VO2MaxOutputStore, CMError, %d
ExerciseMinuteThresholdUpdater, no vo2max records found for update
ExerciseMinuteThresholdUpdater, previousValue, %{private}f, targetValue, %{private}f, lastVo2max, %{private}f, updateValue, %{private}f, daysElapsed, %{public}f
CLManagedLocationDatabase<CLCdmaCellLocationDatabase, CLTelephonyService_Type::CdmaCell>::CLManagedLocationDatabase(std::string, bool, std::unique_ptr<IExternal>, std::string) [Database = CLCdmaCellLocationDatabase, DataType = CLTelephonyService_Type::CdmaCell]
MaxMetsProcessingHistory
SELECT * from MaxMetsProcessingHistory ORDER BY startTime ASC
SELECT COUNT(*) FROM MaxMetsProcessingHistory
DELETE FROM MaxMetsProcessingHistory WHERE endTime < ?
SELECT * FROM MaxMetsProcessingHistory ORDER BY id DESC LIMIT 1
UPDATE MaxMetsProcessingHistory SET startTime = ?, endTime = ?, maxMets = ?, lastUpdateTime = ? WHERE id = ?
DELETE FROM MaxMetsProcessingHistory
DELETE FROM MaxMetsProcessingHistory WHERE startTime > ?
UPDATE MaxMetsProcessingHistory SET startTime = startTime + ?, endTime = endTime + ?, lastUpdateTime = lastUpdateTime + ?
INSERT INTO MaxMetsProcessingHistory (startTime, endTime, maxMets, lastUpdateTime) VALUES (?, ?, ?, ?)
ALTER TABLE MaxMetsProcessingHistory ADD COLUMN 
UPDATE MaxMetsProcessingHistory SET 
lastUpdateTime
CLActivityRecorderDb<MaxMetsProcessing>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = MaxMetsProcessing, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<MaxMetsProcessing>::setDatabaseAccessible() [T = MaxMetsProcessing, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<MaxMetsProcessing>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = MaxMetsProcessing, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<MaxMetsProcessing>::sanitizeAndStoreRecordUL(const T &, bool) [T = MaxMetsProcessing, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLManagedLocationDatabase<CLLteCellLocationDatabase, CLTelephonyService_Type::LteCell>::CLManagedLocationDatabase(std::string, bool, std::unique_ptr<IExternal>, std::string) [Database = CLLteCellLocationDatabase, DataType = CLTelephonyService_Type::LteCell]
virtual CLMetsInfo CLCalorieFunctionalStrengthModel::computeMETS(const CLNatalieModelInput &)
FST, FSTMotionType, %d, metsHR, %f, useHR, %d, userMets, %f, truthMets, %f, endTime, %f, semiStatMets, %f, userMetSource, %d, isWalking, %d, isTypeStatic, %d
CLDataProtectionManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/DataProtectionManager/CLDataProtectionManager.mm
-[CLDataProtectionManagerAdapter beginService]
-[CLDataProtectionManagerAdapter postDataAvailability]
client of CLDataProtectionManager is requesting a re-broadcast of data availability
DataProtectionManager
void CLDataProtectionManager::postDataAvailability()
#dataprotection postDataAvailability, %{public}d
virtual void CLNotifier<CLDataProtectionManager_Type::Notification, CLDataProtectionManager_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLDataProtectionManager_Type::Notification, NotificationData_T = CLDataProtectionManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLDataProtectionManager_Type::Notification, CLDataProtectionManager_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLDataProtectionManager_Type::Notification, NotificationData_T = CLDataProtectionManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLDataProtectionManager_Type::Notification, CLDataProtectionManager_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLDataProtectionManager_Type::Notification, NotificationData_T = CLDataProtectionManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDataProtectionManager_Type::Notification, CLDataProtectionManager_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLDataProtectionManager_Type::Notification, NotificationData_T = CLDataProtectionManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDataProtectionManager_Type::Notification, CLDataProtectionManager_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLDataProtectionManager_Type::Notification, NotificationData_T = CLDataProtectionManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDataProtectionManager_Type::Notification, CLDataProtectionManager_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLDataProtectionManager_Type::Notification, NotificationData_T = CLDataProtectionManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLDataProtectionManager_Type::Notification, CLDataProtectionManager_Type::NotificationData, char, char>::listClients() [Notification_T = CLDataProtectionManager_Type::Notification, NotificationData_T = CLDataProtectionManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
kCLConnectionMessageARSessionState
kCLConnectionMessageVIOEstimation
kCLConnectionMessageVLLocalizationResult
com.apple.locationd.trusted_ARKit_hinter
void CLOnBodyNotifier_Type::Params::init()
No parameters for on body is available for %s
void CLOnBodyNotifier_Type::Params::log() const
Parameters: theta0, %f, theta1, %f, theta2, %f, theta3, %f, theta4, %f, theta5, %f, minLowPower, %f, maxLowPower, %f, maxHighPower, %f, lowBandStart, %d, lowBandStop, %d, highbandStart, %d, highBandStop, %d, wakeThreshold, %f, oddsThreshold, %f, medianFilterSize, %u, confidenceThreshold, %f, useHysteresis, %d, useAngleOverride, %d, angleMetricThreshold, %f
static CLOnBodyNotifier_Type::Params CLOnBodyNotifier_Type::Params::getParams(NSDictionary *, NSString *)
Using the manufacturer specific parameters (%s): %s
Using the default parameters: %s
#Warning Using the hardcoded parameters
static bool CLOnBodyNotifier_Type::Params::isValid(NSDictionary *)
Invalid parameters received:
%{public}s
SteadinessModel::Result CLMobility::SteadinessModelContinuousWalking::runSteadinessModel(CFAbsoluteTime, const CLMobility::SteadinessModelContinuousWalking_Generated::Features &, const std::vector<BoutMetrics> &, const CLBodyMetrics &) const
Rejection: ModelContinuousWalking missing required feature inputs
CLMobility::SteadinessModelContinuousWalking::Result,hkEndTime,%{public}.2f,likelihoodOK,%{public}.2f,likelihoodNotOK,%{public}.2f,rawSteadiness,%{private}.2f,rejectionStatus,%{public}d,numValidBouts7Days,%{private}d,numValidBouts28Days,%{private}d
CLMobility::SteadinessModelContinuousWalking::Features,allBoutsBoutDurationCv,%{private}.2f,allBoutsBoutDurationMedian,%{private}.2f,allBoutsCycleTimeCv,%{private}.2f,intermediateBoutsWalkingSpeedMedian,%{private}.2f,intermediateBoutsWalkingSpeedMedianSqrtheightnorm,%{private}.2f,intermediateBoutsWalkingSpeedCv,%{private}.2f,intermediateBoutsCycleTimeCv,%{private}.2f,intermediateBoutsStepLengthMedian,%{private}.2f,intermediateBoutsStepLengthMedianHeightnorm,%{private}.2f,intermediateBoutsDoubleSupportPercentageMedian,%{private}.2f,shortBoutsWalkingSpeedMedian,%{private}.2f,shortBoutsWalkingSpeedMedianSqrtheightnorm,%{private}.2f,shortBoutsStepLengthMedianHeightnorm,%{private}.2f,shortBoutsCycleTimeMedian,%{private}.2f,shortBoutsDoubleSupportPercentageMedian,%{private}.2f,shortBoutsWalkingSpeedCv,%{private}.2f,shortBoutsCycleTimeCv,%{private}.2f,shortBoutsStepLengthCv,%{private}.2f,longBoutsWalkingSpeedCountRatioLog,%{private}.2f
CLMobility::SteadinessModelContinuousWalking_Generated::Features CLMobility::SteadinessModelContinuousWalking::extractFeatures(CFAbsoluteTime, const std::vector<BoutMetrics> &, const CLBodyMetrics &) const
SteadinessModelContinuousWalking::extractFeatures,classificationTime,%{public}.2f,numBouts,%{public}lu,numIntermediateWalkingSpeeds,%{public}lu,numIntermediateDST,%{public}lu,numIntermediateStepLengths,%{public}lu,numDurations,%{public}lu,numCycleTimes,%{public}lu,numIntermediateCycleTimes,%{public}lu,numShortWalkingSpeeds,%{public}lu,numShortDST,%{public}lu,numShortStepLengths,%{public}lu,numShortCycleTimes,%{public}lu,numLongBouts,%{public}lu,numAllBouts,%{public}lu
com.apple.locationd.%s.%lx
bool CLPowerAssertion::takePowerAssertion(std::string)
Took, inc ref, %d, %s, thisReason, %s
%@(%s)
Took
%s, %s
bool CLPowerAssertion::releasePowerAssertion()
Release power assertion, %s, heldFor, %.2lf
Release power assertion, dec ref, %d, %s
sessionAttributes
estimate
summaries
StatusBarIconManager
CLStatusBarIconManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/StatusBarIcon/CLStatusBarIconManager.mm
-[CLStatusBarIconManagerAdapter beginService]
CLStatusBarIconSwitchSyncNotification
StatusBarIconStates
com.apple.locationd.StatusBarIconManager
ShowSystemServices
void CLStatusBarIconManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
sbim: Got client notification
void CLStatusBarIconManager::sendStatusBarIconNotification()
sbim: Posting status bar icon visibility change notification
SystemService
void CLStatusBarIconManager::handleReset()
Clearing status bar icon enabled states
CLStatusBarIconManager_Type::StatusBarIconState CLStatusBarIconManager::iconState()
#sbim: E911 is active; forcing icon on.
CLStatusBarIconManager::onClientNotification
Application
Bundle
FindMyiPhone
CoreRoutine
BundleUnsupported
EmergencyService
LocationdInternalSystemService
Inactive
RequestingLocationInformation
virtual void CLNotifier<CLStatusBarIconManager_Type::Notification, CLStatusBarIconManager_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLStatusBarIconManager_Type::Notification, NotificationData_T = CLStatusBarIconManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLStatusBarIconManager_Type::Notification, CLStatusBarIconManager_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLStatusBarIconManager_Type::Notification, NotificationData_T = CLStatusBarIconManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLStatusBarIconManager_Type::Notification, CLStatusBarIconManager_Type::NotificationData>::removeClient(int) [Notification_T = CLStatusBarIconManager_Type::Notification, NotificationData_T = CLStatusBarIconManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLStatusBarIconManager_Type::Notification, CLStatusBarIconManager_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLStatusBarIconManager_Type::Notification, NotificationData_T = CLStatusBarIconManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLStatusBarIconManager_Type::Notification, CLStatusBarIconManager_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLStatusBarIconManager_Type::Notification, NotificationData_T = CLStatusBarIconManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLStatusBarIconManager_Type::Notification, CLStatusBarIconManager_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLStatusBarIconManager_Type::Notification, NotificationData_T = CLStatusBarIconManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLStatusBarIconManager_Type::Notification, CLStatusBarIconManager_Type::NotificationData>::listClients() [Notification_T = CLStatusBarIconManager_Type::Notification, NotificationData_T = CLStatusBarIconManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
v32@?0@8Q16^B24
(localCapabilitiesCache.count != 0)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Utilities/CLLocationDictionaryUtilities.mm
_CLLocationDictionaryUtilitiesHasCapability
_valid == __objc_no
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLDaemonInUseAssertion.mm
-[CLDaemonInUseAssertionAdapter dealloc]
InUseAssertion/kCLConnectionMessage
void CLDaemonInUseAssertion::handleMessageInUseAssertion(std::shared_ptr<CLConnectionMessage>)
#warning InUseAssertion already taken by %{public}s
com.apple.locationd.usage_oracle
#warning #CLIUA Not entitled as usage oracle... ignoring InUseAssertion taken by %{public}s
kCLConnectionMessageAssertionLevelKey
#CLIUA InUseAssertion taken by %{public}s malformed: lacking required argument
#CLIUA Neither bundleIdentifier nor bundlePath specified... ignoring InUseAssertion taken by %{public}s
#CLIUA Assertion requested with no reason... ignoring InUseAssertion taken by %{public}s
fInUseAssertionContainer == nullptr
handleMessageInUseAssertion_block_invoke
v16@?0@"CLCppContainer"8
entitled
bool CLDaemonInUseAssertion::isEntitled(const std::string &)
StreamingAwareLocationProvider
CLStreamingAwareLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Streaming/CLStreamingAwareLocationProvider.mm
-[CLStreamingAwareLocationProviderAdapter beginService]
Streaming aware location provider
CLRemoteMotionAlarm
ForceStreamingBehaviorNoLocalGPS
virtual bool CLStreamingAwareLocationProvider::unregisterForNotificationInternal(const CLLocationProvider_Type::Notification &)
Stream clearing cached notification for %d
setLocationRegistration
virtual void CLStreamingAwareLocationProvider::setStepCountRegistration(bool)
Turning on step count notifications
Turning off step count notifications
CLStreamingAwareLocationProvider::onStepCountNotification
CLStreamingAwareLocationProvider::onLocalLocationNotification
CLStreamingAwareLocationProvider::onStreamedLocationNotification
CLStreamingAwareLocationProvider::onMotionStateMediatorNotification
CLStreamingAwareLocationProvider::onManagerNotification
CL::Wifi1::Policies::NewReprocessWsbRequest::Output CL::Wifi1::Policies::NewReprocessWsbRequest::HandleEvent::operator()(const Events::Client::WsbTimer &) const
WsbReproc, timer
CL::Wifi1::Policies::NewReprocessWsbRequest::Output CL::Wifi1::Policies::NewReprocessWsbRequest::HandleEvent::operator()(const Events::Network::AlsFinished &) const
WsbAls, reply, %{public}d
virtual void CLGeoFeatureAccess3dBuildingGeometry::provideCacheHint(const CLMapCrumb &, double)_block_invoke
#Warning,CLMM,provideCacheHint,building,error:%{public}lld (%{public}@) "%{private}@"
v16@?0@"GEOMapFeatureBuilding"8
bool CLGeoFeatureAccess3dBuildingGeometry::buildingsWithinDistance(CLGeoFeatureAccess3dBuildingGeometry::ExtrudedFootprintsList &, const double &, const double &, const double &)
#WarningCLMM,query failed (buildingsWithinDistance)
void CLWifiServerResponseListener::beginSeries()
TILE: beginSeries
void CLWifiServerResponseListener::endSeries()
TILE: endSeries, size, %lu
TILE: endSeries, checking tile, count, %u,  localLocation, %14.8lf, %14.8lf
TILES: requestDownload, %.8f, %.8f
virtual void CLWifiServerResponseListener::onWifiAlsResponse(const std::vector<CLAlsWifiAccessPoint>, bool)
@WifiAps, als, %{public}lu, isNearby, %{public}d
TILE: macAddressResolved, invalid hash value, %s
NSString *bundlePathFromServiceName(const char *)
attempting to create service location provider with NULL service name
virtual CLMotionActivity::TypeYouth CLFitnessYouthOutdoorCyclingOverride::doOverride(CLMotionActivity::TypeYouth, const CLNatalieModelInput &)
Overriding youth type for outdoor cycling , beginTime, %f, before, %{public}d, after, %{public}d, speed, %{public}f
SqliteDatabaseManager
_SqliteDatabaseUseSecureDelete
_SqliteDatabaseUseIncrementalVacuum
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLSqliteDatabaseManager.mm
openDatabase
int CLSqliteDatabaseManager::openDatabase(CLSqliteDatabase::SqliteProperties, const std::string &, sqlite3 *&)
Attempted to open an encrypted database
pragma page_size = 4096;
pragma journal_mode=WAL;
pragma secure_delete = 
pragma cache_size = 5;
pragma cache_size = 50;
pragma cache_spill = 500;
pragma recursive_triggers = true;
_SqliteTrace
Walk
virtual CLMetsInfo CLNataliePedestrianModel::computeMETS(const CLNatalieModelInput &)
Pedestrian, Using %s model
SteadinessModel::Result CLMobility::SteadinessModelGaitBaseline::runSteadinessModel(CFAbsoluteTime, const SteadinessModelGaitBaseline_Generated::Features &, const std::vector<BoutMetrics> &, const CLBodyMetrics &) const
Rejection: SteadinessModelGaitBaseline missing required feature inputs
CLMobility::SteadinessModelGaitBaseline::Result,hkEndTime,%{public}.2f,likelihoodOK,%{public}.2f,likelihoodNotOK,%{public}.2f,rawSteadiness,%{public}.2f,rejectionStatus,%{public}d,numValidBouts7Days,%{private}d,numValidBouts28Days,%{private}d
CLMobility::SteadinessModelGaitBaseline::Features,balancePrior,%{private}.3f,intermediateBoutsStepLengthQ95Heightnorm,%{private}.3f,intermediateBoutsWalkingSpeedQ95Sqrtheightnorm,%{private}.3f,height,%{private}.2f
CLMobility::SteadinessModelGaitBaseline_Generated::Features CLMobility::SteadinessModelGaitBaseline::extractFeatures(CFAbsoluteTime, const std::vector<BoutMetrics> &, const CLBodyMetrics &, double) const
SteadinessModelGaitBaseline::extractFeatures,classificationTime,%{public}.2f,numBouts,%{public}lu,numIntermediateWalkingSpeeds,%{public}lu,numIntermediateStepLengths,%{public}lu
SteadinessModel::Result CLMobility::SteadinessModelTemporalEntropy::runSteadinessModel(CFAbsoluteTime, const CLMobility::SteadinessModelEntropy_Generated::Features &, const std::vector<BoutMetrics> &, const CLBodyMetrics &) const
Rejection: ModelTemporalEntropy missing required feature inputs
CLMobility::SteadinessModelTemporalEntropy::Result,hkEndTime,%{public}.2f,likelihoodOK,%{public}.2f,likelihoodNotOK,%{public}.2f,rawSteadiness,%{private}.2f,rejectionStatus,%{public}d,numValidBouts7Days,%{private}d,numValidBouts28Days,%{private}d
CLMobility::SteadinessModelTemporalEntropy::Features,allBoutsMinGaitMetrics21StepLengthEntropyMeanLog,%{private}.2f,allBoutsMinGaitMetrics21CycleTimeEntropyMeanLog,%{private}.2f,allBoutsMinGaitMetrics21CycleTimeEntropy5thTo95thLog,%{private}.2f,allBoutsMinGaitMetrics21CycleTimeEntropyP5Log,%{private}.2f,allBoutsMinGaitMetrics21StepLengthPoincareSd1P5Log,%{private}.2f,allBoutsMinGaitMetrics21StepLengthPoincareSd1P95Log,%{private}.2f,allBoutsMinGaitMetrics21StepLengthPoincareSd2P5Log,%{private}.2f,allBoutsMinGaitMetrics21StepLengthPoincareSd2MeanLog,%{private}.2f,allBoutsMinGaitMetrics21CycleTimePoincareSd1P5Log,%{private}.2f,allBoutsMinGaitMetrics21CycleTimePoincareSd2P5Log,%{private}.2f
CLMobility::SteadinessModelEntropy_Generated::Features CLMobility::SteadinessModelTemporalEntropy::extractFeatures(CFAbsoluteTime, const std::vector<BoutMetrics> &) const
SteadinessModelTemporalEntropy::extractFeatures,classificationTime,%{public}.2f,numBouts,%{public}lu,numStepLengthEntropy,%{public}lu,cycleTimeEntropy,%{public}lu
AltitudeMinReportIntervalInSeconds
CompanionConnectionKeepAliveInterval
CLBarometerCalibration
CLCompanionNotifierCompanion
virtual void CLCompanionNotifierCompanion::receiveCompanionMessage(CLCompanionNotifier_Type::Type, NSData *)
Received message,type,%d,size,%lu
#Warning Error deserializing session override: %s
CLStepCountNotifier
CLRunningAggregatorAWD
CLMotionSyncStore
CLMotionStateObserver
supported watch connected, phone subscribes to absolute altitude updates
CLKappaNotifier
void CLCompanionNotifierCompanion::onOdometerNotification(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNotifier_Type::NotificationData &)
#Warning error serializing Odometer(GPS) entry
#Warning error serializing Odometer(Elevation) entry
#Warning error serializing Odometer(Coarse Elevation) entry
virtual void CLCompanionNotifierCompanion::stateSync(bool)
supported watch disconnected, phone unsubscribes from absolute altitude updates
virtual void CLCompanionNotifierCompanion::handleStateSyncTimerExpiry()
Time to the last received message from Watch is %lf. Lost connection to Watch.
void CLCompanionNotifierCompanion::checkAndToggleSpectatorSources()
#Warning Spectator subscriptions expired
void CLCompanionNotifierCompanion::toggleCoarseElevationSource(bool)
coarse elevation src,enable,%d,elevationSpectator,%d,fitnessTracking,%d
void CLCompanionNotifierCompanion::onAbsoluteAltitudeUpdate(CLBarometerCalibrationAbsoluteAltitude *)
phone, not sending altitude to watch, uncertainty %f
#Warning error serializing Absolute Altitude entry
sending altimeter data to watch: timestamp %f, altitude %f, accuracy %f, precision %f, status info %lu
CLCompanionNotifierCompanion::onOdometerNotification
Enabling
Disabling
void CLEarGestureClientManager::setEnabledInternal(bool)
%{public}s ear gesture
EarGesture_Prototype_Msgs_1
EarGesture_Prototypes_Siri_1
void CLEarGestureClientManager::removeClientInternal(const void *)
Removing client %{private}p
Unknown client instance %{private}p
void CLEarGestureClientManager::addClientInternal(const void *, int, CLEarGestureClientManager::Handler)
Adding client %{private}p with priority %{public}d
void CLEarGestureClientManager::refreshDispatcherIfNecessaryInternal()
Registering for ear gesture notifications
Unregistering for ear gesture notifications
void CLEarGestureClientManager::updateEnabledStatusForTopClient()
Ear Gesture EnabledForTopClient: %{public}d (%{public}s)
SiriCalled
KeyboardCalled
MessagesTranscriptCalled
MessagesSpringBoardCalled
PriorityNotSupported!
static void CLEarGestureClientManager::onEarGesture(const CLEarGestureNotifier::NotificationData *, void *)
Dispatching ear gesture to instance %{private}p from prototype %{private}s
sqlite3_finalize()
sqlite3_clear_bindings()
bool PropagationDataHistory::shallPropagateAccessory(const CFTimeInterval)
%.1lf,DeadReckoning,%.2lf,fLastPASCDVelocityNotificationTime,%.2lf,fLastAccessoryLocation,%.2lf,fLastGPSLocationTime,%.2lf,fLastGPSPropagationTime,%.2lf
not saved
void PropagationDataHistory::saveData(const CLLocationProvider_Type::NotificationData &)
%.1lf,DeadReckoning,%s,%s,time,%.1lf,machCont,%.1lf,%{private}.8lf,%{private}.8lf
CL2dLocationLatCodingKey
CL2dLocationLonCodingKey
static std::shared_ptr<RootNode> CLMASettingsMap::RootNode::create(const std::string &)
#SettingsMap,create,root,%{private}s
std::shared_ptr<BranchNode> CLMASettingsMap::RootNode::addBranch(const std::string &)
#SettingsMap,addBranch,root,%{private}s,failed to get shared this
#SettingsMap,addBranch,root,%{private}s,branch,%{private}s,failed to create branch
#SettingsMap,addBranch,root,%{private}s,branch,%{private}s,successful
static std::shared_ptr<BranchNode> CLMASettingsMap::BranchNode::create(const std::string &, std::weak_ptr<NodeBase>, std::weak_ptr<RootNode>)
#SettingsMap,create,branch,%{private}s,parent and/or root is empty
#SettingsMap,create,branch,%{private}s,parent,%{private}s,root,%{private}s
std::shared_ptr<BranchNode> CLMASettingsMap::BranchNode::addBranch(const std::string &)
#SettingsMap,addBranch,branch,%{private}s,failed to get shared this
#SettingsMap,addBranch,branch,%{private}s,subBranch,%{private}s,root is empty
#SettingsMap,addBranch,branch,%{private}s,root,%{private}s,subBranch,%{private}s,failed to create branch
#SettingsMap,addBranch,branch,%{private}s,root,%{private}s,subBranch,%{private}s,successful
std::shared_ptr<LeafNode> CLMASettingsMap::BranchNode::addLeaf(const std::string &, CLMASettingsMap::NodeBase::DataType)
#SettingsMap,addLeaf,branch,%{private}s,failed to get shared this
#SettingsMap,addLeaf,branch,%{private}s,leaf,%{private}s,root is empty
#SettingsMap,addLeaf,branch,%{private}s,root,%{private}s,leaf,%{private}s,failed to create leaf
#SettingsMap,addLeaf,branch,%{private}s,root,%{private}s,leaf,%{private}s,successful
static std::shared_ptr<LeafNode> CLMASettingsMap::LeafNode::create(const std::string &, CLMASettingsMap::NodeBase::DataType, std::weak_ptr<NodeBase>, std::weak_ptr<RootNode>)
#SettingsMap,create,leaf,%{private}s,parent and/or root is empty
#SettingsMap,create,leaf,%{private}s,parent,%{private}s,root,%{private}s,type,%{private}d
kCLConnectionMessageStepCountUpdate
kCLConnectionMessagePedometerEvent
kCLConnectionMessageStepCountRecordQuery
kCLConnectionMessageStrideCalibrationDump
kCLConnectionMessagePedometerCalibrationQuery
void CLStepCountSubscription::onPedometerNotification(int, const CLStepCountNotifier_Type::Notification &, const CLStepCountNotifier_Type::NotificationData &)
%@ -> %s
Error in step count update
Sending pedometer event,%ld,eventTime,%.3f,%s
OdometerSuitability values,startDate,%.8f,suitableForRunning,%d,suitableForWalking,%d
void CLStepCountSubscription::handleRequestStepCountUpdate(bool, const CLNameValuePair &)
StepCount subscription changed, %s, %p, %d
Cannot subscribe to step count updates, step counting is not available
Cannot subscribe to step count updates as step counting is not enabled
void CLStepCountSubscription::handleRequestPedometerEvent(bool, const CLNameValuePair &)
PedometerEvent subscription changed, %s, %p, %d
void CLStepCountSubscription::handleRequestOdometerSuitabilityUpdate(bool, const CLNameValuePair &)
OdometerSuitabilityUpdate subscription changed, %s, %p, %d
void CLStepCountSubscription::handleMessageStepCountQuery(std::shared_ptr<CLConnectionMessage>)
query for step count was received but step counts were not available
Error querying step count data
com.apple.locationd.natalimetry
void CLStepCountSubscription::handleMessageStepCountRecordQuery(std::shared_ptr<CLConnectionMessage>)
CLDaemonClient.StepCountRecordQuery
Error querying pedometer data, %{public}d
void CLStepCountSubscription::handleMessageStepCountReset(std::shared_ptr<CLConnectionMessage>)
Step count reset failed as it was not available!
void CLStepCountSubscription::handleMessageStrideCalibrationDump(std::shared_ptr<CLConnectionMessage>)
CLDaemonClient received StrideCalibrationDump request,client,%s
Step count notifier not available
v16@?0@"CMStrideCalibrationHistory"8
Cannot find step count proxy
void CLStepCountSubscription::handleMessagePedometerCalibrationQuery(std::shared_ptr<CLConnectionMessage>)
received request for remote pedometer calibrations
void CLStepCountSubscription::handleMessagePedometerCalibrationQuery(std::shared_ptr<CLConnectionMessage>)_block_invoke
Requested calibration type not recognized
No remote pedometer calibrations available
received request for pedometer calibrations
No pedometer calibrations available
CLStepCountSubscription::onPedometerNotification
void CLGenericFitnessMinuteEstimatorYouth::slideActivityWindowYouth(CFTimeInterval, const CLMotionStateMediator_Type::MediatedMotionActivity &)
#Warning FitnessMinuteEstimatorYouth (%{public}s), Invalid timestamps - ignored the epoch, epochStartTime:%{public}.3f, epochDuration:%{public}.3f
#Warning FitnessMinuteEstimatorYouth (%{public}s), Time rolled back, past back:%{public}.3f, current epochStartTime:%{public}.3f
Moving
Exercise
NoCredit
virtual CLMetsInfo CLCalorieCalisthenicsModel::computeMETS(const CLNatalieModelInput &)
Calisthenics (HIIT), METS, %f, %d, truthMETS, %f, %d
com.apple.CLWorkoutSessionMetrics
void CLWorkoutSessionMetrics::handleWorkoutEvent(const CLMotionStateMediator_Type::WorkoutEvent &)_block_invoke
Richard 1
Richard 2
void CLWorkoutSessionMetrics::queryVO2Max()_block_invoke
CLWorkoutSessionMetrics, no VO2Max records found at start of workout session
bool CLWorkoutSessionMetrics::processMetrics()
Discarding workout CA event, session uuid at end of session does not match uuid collected
Discarding workout CA event, invalid session duration %d
Discarding workout CA event, duration %d does not meet kWorkoutSessionMinSessionLength
Discarding workout CA event, invalid total epochs %d
com.apple.CoreMotion.FitnessSession
sessionDuration
otherWorkoutLabel
pctSessionGPSSourcePhone
pctSessionGPSSourceWatch
exerciseMinuteThreshold
exerciseMinutes
averageWorkoutIntensity
workoutStartType
autoStartEnabled
autoPauseEnabled
autoStopEnabled
numberOfStopAlerts
numStopAlertStopModel
numStopAlertSteps
numStopAlertOffWrist
numStopAlertOnCharger
numStopAlertHeartRate
numStopAlertTurns
numStopAlertTier2Classification
numStopAlertConnectedToVehicleBluetooth
numStopAlertVehicleSpeed
numStopAlertExitedGeoFence
numStopAlertVehicleSpeedArmConstrained
numStopAlertHRHeading
numStopAlertDelayedPreferenceChange
numStopAlertUnsupportedWorkoutType
sourceOfExerciseMinuteThreshold
companionAvailable
idsAvailability
hrSource
eVO2Max
loadCalibrationUtilization
PALEstimationStatus
pctPedestrianGPSAvailable
pctPedestrianCalibrated
workoutElevationError
CLMotionDefaultsWrite<long long>::CLMotionDefaultsWrite(const char *, const T &) [T = long long]
CLLoiLocationProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Loi/CLLoiLocationProvider.mm
-[CLLoiLocationProviderAdapter beginService]
+[CLLoiLocationProviderAdapter(IsSupported) isSupported]
@ClxLoi, supported, %{public}d
virtual void CLLoiLocationProvider::shutdown()
#loip stop leeching visits
virtual bool CLLoiLocationProvider::registerForNotificationInternal(const CLLocationProvider_Type::Notification &)
@ClxLoi, registerForNotificationInternal, notification, %{public}d
#loip register to leech visits
virtual bool CLLoiLocationProvider::unregisterForNotificationInternal(const CLLocationProvider_Type::Notification &)
@ClxLoi, unregisterForNotificationInternal, notification, %{public}d
void CLLoiLocationProvider::onVisit(CLVisit *)
#loip cannot request LOI location for a nil visit
void CLLoiLocationProvider::updateLoiFromVisit(CLVisit *)
#loip cannot request LOI location for a nil LOI identifier
#loip skip requesting Loi location as routine monitor is not up
void CLLoiLocationProvider::updateLoiFromVisit(CLVisit *)_block_invoke
#loip unsupported location accuracy type, %lu
v24@?0@"RTLocationOfInterest"8@"NSError"16
void CLLoiLocationProvider::notifyLocation()
#loip,notify LOI location,lat,%{private}.7f,lon,%{private}.7f,hunc,%{public}.2f,altitude,%{private}.2f,vunc,%{public}.2f,confidence,%{public}d,integrity,%{public}lu,sourceAccuracy,%{public}lu
void CLLoiLocationProvider::notifyLocationUnavailable()
#loip notify LOI location unavailable
LoiPosition
void CLMapMatcherNetworkUsage::log() const
CLMM,AllowNetworkUsage,%{public}d,batterySaverMode,%{public}d,thermalVoteToAllow,%{public}d,signalEnv,%{public}d,isMapsForeground,%{public}d,thermalLevel,%{public}d,currentBatteryLevel,%{public}.2lf
CLMobilityWalkingBoutServiceSilo
-[CLMobilityWalkingBoutService beginService]
Starting up CLMobilityWalkingBoutService
-[CLMobilityWalkingBoutService endService]
Shutting down CLMobilityWalkingBoutService
-[CLMobilityWalkingBoutService onStepCountNotification:data:]
CLMobilityWalkingBoutService: Received unexpected type %{public}d
-[CLMobilityWalkingBoutService onUserInfoUpdate:data:]
CLMobilityWalkingBoutService: Received user info update
-[CLMobilityWalkingBoutService onSPUGaitMetrics:]
This device is not expected to support Gait Metrics. Please file a radar: rdar://component/1021534
com.apple.locationd.Mobility.ProcessBouts
-[CLMobilityWalkingBoutService onMobilityProcessBoutsActivity:]
Invalid xpc activity (%s).
-[CLMobilityWalkingBoutService onMobilityProcessBoutsActivity:]_block_invoke
BoutService: Data sources unavailable, did not process bouts (%s)
Failed to mark (%s) activity as done. Current state is %{public}ld
Unexpected activity (%s) state: %ld
-[CLMobilityWalkingBoutService onMobilityClassificationActivity:]
Invalid xpc classification activity.
com.apple.locationd.Mobility.Classification
-[CLMobilityWalkingBoutService onMobilityClassificationActivity:]_block_invoke
Failed to mark activity (%s) as done. Current state is %{public}ld
v16@?0B8B12
-[CLMobilityWalkingBoutService onDataCollectionRequested:]_block_invoke
BoutService: Mobility data requested
BoutService: Data sources unavailable, did not process bouts onDataCollectionRequested
BoutService: Data requested, but unable to query outstanding bouts. CMError: %d
-[CLMobilityWalkingBoutService onAggregationTimer]_block_invoke
BoutService: Unable to process BoutMetrics pre-aggregation, CMError: %d
CLMobilityWalkingBoutService: Aggregating WalkingBout, GaitMetrics, BoutMetrics records
-[CLMobilityWalkingBoutService checkForBoutsReadyToProcessWithCompletion:]_block_invoke
BoutService: HK queried for workouts from (%{public}.2f) to (%{public}.2f)
v36@?0i8{vector<HealthKitWorkout, std::allocator<HealthKitWorkout>>=^{HealthKitWorkout}^{HealthKitWorkout}{__compressed_pair<HealthKitWorkout *, std::allocator<HealthKitWorkout>>=^{HealthKitWorkout}}}12
-[CLMobilityWalkingBoutService handleBoutResults:]
CLMobilityWalkingBoutService: Sending %lu bout metrics to %d client(s)
Bout metrics result, startTime, %.2f, endTime, %.2f, stepCount, %d
-[CLMobilityWalkingBoutService classifySteadinessWithCompletion:]
#warning: HealthKit: Walking Steadiness unavailable
#warning: Classification already in progress
steadinessClassificationNextClassificationTime
Checking for historical samples -- setting classification time in the past: (%{public}.2f)
Trying to classify a time period in the future (%{public}.2f)
Missing Database UUID
-[CLMobilityWalkingBoutService classifySteadinessWithCompletion:]_block_invoke
No steps detected, despite the presense of MobilityBoutMetrics
Most recent classification is OK, resetting previous notification %{private}.2f
Finished Classification: data sources unavailable
Height not set, increasing minimum delay before next classification
Finishing Classification: nextClassificationTime=%{}.2f, nextFireInterval=%{}.2f
v112@?0B8{vector<HealthKitQuantitySample, std::allocator<HealthKitQuantitySample>>=^{HealthKitQuantitySample}^{HealthKitQuantitySample}{__compressed_pair<HealthKitQuantitySample *, std::allocator<HealthKitQuantitySample>>=^{HealthKitQuantitySample}}}12i36{vector<HealthKitQuantitySample, std::allocator<HealthKitQuantitySample>>=^{HealthKitQuantitySample}^{HealthKitQuantitySample}{__compressed_pair<HealthKitQuantitySample *, std::allocator<HealthKitQuantitySample>>=^{HealthKitQuantitySample}}}40{vector<HealthKitQuantitySample, std::allocator<HealthKitQuantitySample>>=^{HealthKitQuantitySample}^{HealthKitQuantitySample}{__compressed_pair<HealthKitQuantitySample *, std::allocator<HealthKitQuantitySample>>=^{HealthKitQuantitySample}}}64{vector<HealthKitCategorySample, std::allocator<HealthKitCategorySample>>=^{HealthKitCategorySample}^{HealthKitCategorySample}{__compressed_pair<HealthKitCategorySample *, std::allocator<HealthKitCategorySample>>=^{HealthKitCategorySample}}}88
-[CLMobilityWalkingBoutService checkForHistoricalComputeTrigger:]
checkForHistoricalComputeTrigger: NO, height is unset
checkForHistoricalComputeTrigger: NO, ClassB database inaccessible
checkForHistoricalComputeTrigger: NO, nextClassificationTime already set (%{public}.2f)
checkForHistoricalComputeTrigger: YES, attempting classification
-[CLMobilityWalkingBoutService sendAnalyticsBoutMetrics:]
BoutService: Not authorized to submit analytics without IHA
com.apple.CoreMotion.Mobility.WalkingBout
extraCount
boutNumGaitMetrics
boutWorkoutType
boutStepCount
boutDuration
boutTerminationReason
boutDeviceSide
boutNumGaitMetrics_bin
boutDuration_bin
boundaryType
cycleTimeMean
stepLengthEntropy
stepLengthPoincareSD1
stepLengthPoincareSD2
cycleTimeEntropy
cycleTimePoincareSD1
cycleTimePoincareSD2
userPAL_bin
metricAsymmetryPercentage
metricDoubleSupportPercentage
metricStepLength
metricWalkingSpeed
isValidAsymmetryPercentage
isValidDoubleSupportPercentage
isValidStepLength
isValidWalkingSpeed
isValidStepLengthEntropy
isValidCycleTimeEntropy
numSegmentsRejectedByIsCadenceConcordant
numSegmentsRejectedByIsFeasibleWalkingSpeed
numSegmentsRejectedByIsNotRunning
numSegmentsRejectedByIsPendular
numSegmentsRejectedByIsSufficientVerticalTwist
numSegmentsRejectedByIsSwingStanceCycle
isAccepted
rejectedDueToGrade
rejectedDueToNumberOfGaitMetrics
rejectedDueToWorkout
rejectedDueToGaitMetricsYield
-[CLMobilityWalkingBoutService sendAnalyticsSteadinessResult:]
BoutService: Sending WalkingSteadiness to %d client(s)
BoutService: Not authorized to submit steadiness analytics without IHA
com.apple.CoreMotion.Mobility.SteadinessClassificationV3
userBMI_bin
userSex
userIsHeightSet
userIsWeightSet
userIsAgeSet
classificationSteadinessScoreIsValid
classificationUnadjustedScore
classificationSteadinessScore
steadinessScore_bin
classificationIsHistoricalCompute
classificationRejectionStatusClassifier
classificationAppliedBoutMetricCorrections
numValidStepBouts7Days
numValidStepBouts28Days
daysWithSufficientStepBouts7Days
daysWithSufficientStepBouts28Days
dailySteps30daysMax
dailyFlights30daysMax
dailySteps7daysMean
dailySteps30daysMean
dailyFlights30daysMean
inputNumFallsInQueryPeriod
classificationRejectionStatusModelContinuousWalking
classificationRejectionStatusModelEntropy
classificationRejectionStatusModelGaitBaseline
errorStatusClassifier
errorDataSourcesUnavailable
notificationWrittenToHealthKit
notificationUserHasOnboarded
notificationEventType
notificationPercentOK
notificationPercentLow
notificationPercentVeryLow
notificationIsBlockoutPeriodLow
notificationIsBlockoutPeriodVeryLow
notificationIsSampleRecent
-[CLMobilityWalkingBoutService setUpClassificationActivityWithDeferral:]
%{public}s: Registering XPC Activity with nextClassificationTime=(%{public}.2f) and delay=(%{public}lld)
-[CLMobilityWalkingBoutService setUpClassificationActivityWithDeferral:]_block_invoke
XPC_CHECK_IN: Initializing %{public}s activity with delay %{public}lld
XPC_CHECK_IN: Checking in on XPC  %{public}s activity, previous delay (%{public}lld), new delay (%{public}lld)
-[CLMobilityWalkingBoutService setUpProcessBoutsActivity]_block_invoke
BoutService: Data processing timer fired (%{public}ld)
MobilityAggregationInterval
-[CLMobilityWalkingBoutService registerForMobilityBoutMetrics:]
BoutService: Registered new BoutMetrics client %@. Current client count: %d
-[CLMobilityWalkingBoutService unregisterForMobilityBoutMetrics:]
BoutService: Unregistered BoutMetrics client %@. Current client count: %d
-[CLMobilityWalkingBoutService registerForWalkingSteadiness:]
BoutService: Registered new WalkingSteadiness client %@. Current client count: %d
-[CLMobilityWalkingBoutService unregisterForWalkingSteadiness:]
BoutService: Unregistered new WalkingSteadiness client %@. Current client count: %d
Mobility
Steadiness
long CLActivityAggregator<CLMobility::BoutBoundary>::aggregateRecords() [T = CLMobility::BoutBoundary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLMobility::BoutBoundary>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLMobility::BoutBoundary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<CLMobility::GaitMetrics>::aggregateRecords() [T = CLMobility::GaitMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLMobility::GaitMetrics>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLMobility::GaitMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<CLMobility::BoutMetrics>::aggregateRecords() [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLMobility::BoutMetrics>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLActivityAggregator<CLMobility::BoutBoundary>::setExpirationRule(CFTimeInterval) [T = CLMobility::BoutBoundary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLActivityAggregator<CLMobility::GaitMetrics>::setExpirationRule(CFTimeInterval) [T = CLMobility::GaitMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLActivityAggregator<CLMobility::BoutMetrics>::setExpirationRule(CFTimeInterval) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
MslEnable
MslFile
MslFlushTimeout
MslLogger.Enable
MslLogger.FileSize
MslLogger.FileTimeInterval
MslLogger.FilesToKeep
MslLogger.Directory
MslLogger
MslLogger.Prefix
MslLogger.Ext
MslLogger.FlushTimeout
static void CMMsl::Logger::create()
Failed to open MslLogger
void CLObsoleteMotionDefaultsWrite(const char *)
Legacy motion setting found '%{public}s'. Clearing.
Failed to clear legacy motion setting: '%{public}s'. Stale profile?
CLMotionDefaultsWrite<std::string>::CLMotionDefaultsWrite(const char *, const T &) [T = std::string]
{'type':%lu, 'uuid':'%s', 'matchedIndex':%u, 'sequence':%u, 'error':%u}
CLAvengerScannerSilo
-[CLAvengerScanner beginService]
CLAvengerScanner: begin service
Uknown
CLAvengerScanner aggressive scan
CLAvengerScanner long aggressive scan coexImpacted
CLAvengerScanner long aggressive scan
ScanType
StartMonitor
StopMonitor
Aggressive
AggressiveLong
HELE
StartBTFinding
StopBTFinding
StartWatchADVBuffer
StopWatchADVBuffer
scanCount
scanType
com.apple.locationd.avengerscanner.scantypechange
requestCount
com.apple.locationd.avengerscanner.clientrequests
numSwitchToAgressiveScan
count_submission
com.apple.locationd.avengerscanner.aggressivescan
AvengerScannerAnalyticsTimer
lastRequestTime
registrationState
void CLFenceAnalytics::countFenceRemovals(const CLFenceManager_Type::Fence &)
Something went wrong with num fences
kCLConnectionMessageAnomalyDetectionSimulateEvent
kCLConnectionMessageSetHgalCaptureMode
bool CLFallSubscription::sanityCheckForFall(std::shared_ptr<CLConnectionMessage>)
#Warning Client %{public}s does not have appropriate motion entitlement.
void CLFallSubscription::handleRequestAnomalyEventCompletedUpdate(bool, const CLNameValuePair &)
Received AnomalyEventCompletedUpdate request,client,%s,subscribe,%d
%s is not authorized for Fall Detection updates
void CLFallSubscription::handleMessageAnomalyEventCompletedMostRecent(std::shared_ptr<CLConnectionMessage>)
Received MessageAnomalyEventCompletedMostRecent message,client,%s
void CLFallSubscription::handleMessageAnomalyEventEnabled(std::shared_ptr<CLConnectionMessage>)
Received MessageAnomalyEventEnabled message,client,%s
void CLFallSubscription::handleRequestAnomalyEvent(bool, const CLNameValuePair &)
Anomaly Detection subscription changed, %{public}s, %{private}p, %{public}d
CLFallSubscription::onFallNotification
bsid
zoneid
bandclass
pnoffset
durationInSeconds
pointCount
hrMin
hrMax
hrMean
hrConfidenceMean
hrCadenceAgreementMean
vo2Mean
speedMean
gradeMean
cadenceMean
hrVariance
hrConfidenceVariance
hrCadenceAgreementVariance
vo2Variance
speedVariance
gradeVariance
vo2MaxModelSource
sessionType
void CLBackgroundWorkoutEscalationManager::update(const CLWorkoutPredictorInputs &)
Background escalation manager consuming more power than workout alerts
Background escalation manager not consuming more power than workout alerts
void CLBackgroundWorkoutEscalationManager::onEscalationAndLabelUpdate(CFAbsoluteTime, CMWorkoutType)
Background escalation manager already tracking escalation
Background escalation manager starting to track escalation
bool CLBackgroundWorkoutEscalationManager::shouldDeescalate() const
Background escalation manager should deescalate,hasBudget,%{public}d,hasPermission,%{public}d
void CLBackgroundWorkoutEscalationManager::stopTrackingEscalation()
Background escalation manager stopped tracking escalation
virtual void CLExerciseMinuteWheelChairEstimator::feedNatalie(double, const CLNatalieModelInput &)
ExerciseMinute,ComputeTime,%.3f,awardedExerciseMinuteMode,%d,fBurstBufferCount,%.3f,fBurstBufferDuration,%.3f,fPushBufferCount,%.3f,fPushBufferDuration,%.3f,BurstModelDuration,%.3f,BurstModelCount,%.3f,BurstModelThreshold,%d,ThresholdModelDuration,%.3f,ThresholdModelCount,%.3f,ThresholdModelThreshold,%d,CoverageModelDuration,%.3f,CoverageModelCount,%.3f,CoverageModelThreshold,%d
sectorid
bool CLAssistedCyclingDetector::detect(const CLNatalieModelInput &)
AssistedCyclingDetector,beginTime,%f,endTime,%f,bufferSize,%d,totalSamplesAboveVO2MaxThreshold,%d,totalSamplesAboveVAMThreshold,%d,totalSamplesAboveDiscordanceThreshold,%d,totalSamplesNonexertion,%d,medianAccelVectorMagnitude,%f,assistedCyclingOverridden,%d,isMotionOverrideSet,%d,isAssistedOverrideTimedOut,%d,isNewCurrentSessionId,%d,isSessionDurationOk,%d
AssistedCyclingOverrideState,endTime,%f,previousOverride,%d,currentOverride,%d,totalSamplesAboveVO2MaxThreshold,%d,totalSamplesAboveVAMThreshold,%d,totalSamplesAboveDiscordanceThreshold,%d,totalSamplesNonexertion,%d,medianAccelVectorMagnitude,%f,isAssistedOverrideTimedOut,%d,isNewCurrentSessionId,%d,isSessionDurationOk,%d
CLSensorCalibrationControllerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/SensorCalibration/CLSensorCalibrationController.mm
-[CLSensorCalibrationControllerAdapter beginService]
com.apple.CoreMotion.GyroCalibration
CLSensorCalibrationController::CLSensorCalibrationController(id<CLIntersiloUniverse>)
fStaticWait,%{public}f,fMinimumInterval,%{public}f,fDoubleCalInterval,%{public}f,fOutOfBoxTimeout,%{public}f,fMinBatteryLevel,%{public}f,fRetryCalInterval,%{public}f,fUrgentStaticWait,%{public}f,fUrgentMinBatteryLevel,%{public}f,fUrgentAttemptMinimumInterval,%{public}f,fUrgentCalScheduled,%{public}d,fLastCalibration,%{public}g,fLongestDurationWithoutCal,%{public}.0f
bool CLSensorCalibrationController::start(bool)
fState,%{public}d
start
UrgentFlag
MotionSensorCalibration
!fGyroDispatcher
!fPowerAssertion.isPowerAssertionTaken()
!fStaticReady
fUrgentCalScheduled || fUserInitiatedCalibration
UrgentCal.Start
RegularCal.Start
Thermal virus not supported for x86 yet
com.apple.CoreMotion.gyrocal.start
void CLSensorCalibrationController::tryStartCalibration()
Calibration is already running
never
BatteryReady,%{public}d,ThermalReady,%{public}d,DisplayReady,%{public}d,StaticReady,%{public}d,MinimumIntervalReady,%{public}d,UrgentMiniCalScheduled,%{public}d,timeToIntervalReady,%{public}.0f,sinceLastCal,%{public}s,sinceLastUnpluggedCalAttempt,%{public}s,ChargerFamily,%{public}x,ChargerCloaked,%{public}u
Still waiting for long wait timer
timeToIntervalReady > 0
tryStartCalibration
Starting long wait timer for %{public}llu seconds
void CLSensorCalibrationController::tryStartCalibration()_block_invoke
Long wait timer trigger.
fStaticAlarmDuration != 0.
Resetting static timer. Wait duration changed %{public}f -> %{public}f
Still waiting for static timer of %{public}f
!fStaticAlarm
Starting static timer for %{public}f
Static timer fired
Avoiding calibration during charging
No coex; calibration runtime = %.0f sec
BatteryDisconnected
Movement
Thermal
Shutdown
Charging
void CLSensorCalibrationController::abort(CLSensorCalibrationController_Type::AbortReason)
CLSensorCalibrationController aborted,reason,%{public}d,%{public}s
Ignoring abort for user initiated calibration
abort
!fTempController
!fMovingAlarm
UrgentCal.Abort
RegularCal.Abort
void CLSensorCalibrationController::teardown(bool)
Stopped sensor calibration, fState, %{public}d, successful, %{public}d
stop
FinishFlag
VirusRunTime.PluggedIn
VirusRunTime.OnBattery
Scheduling double calibration,fLastCalibration,%{public}f,expectedNextCalibration,%{public}f
UrgentCal.Finish
RegularCal.Finish
Scheduling retry calibration after previous aborted run,fLastCalibration,%{public}f,expectedNextCalibration,%{public}f
com.apple.CoreMotion.gyrocal.abort
teardown
void CLSensorCalibrationController::onGyroTemperature(const CLGyro::Temperature *)
state,%{public}d,temperature,%{public}f
Warning: Bad state,%{public}d
void CLSensorCalibrationController::onTimer()
state,%{public}d,elapsed,%{public}f
fState == kWaitingForHysteresis || fState == kRunning
onTimer
void CLSensorCalibrationController::forceBatteryUpdate(double, bool)
level,%{public}f,connected,%{public}d
void CLSensorCalibrationController::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)_block_invoke
Warning: Unexpected notification %{public}d
void CLSensorCalibrationController::setUrgentCalFlag(bool)
UrgentFlag,%{public}d
UrgentCal.Request
Sensors
CLSensorCalibrationController::onStatusNotification
CLSensorCalibrationController::onUrgentMiniCal
virtual void CLNotifier<CLSensorCalibrationController_Type::Notification, CLSensorCalibrationController_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLSensorCalibrationController_Type::Notification, NotificationData_T = CLSensorCalibrationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLSensorCalibrationController_Type::Notification, CLSensorCalibrationController_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSensorCalibrationController_Type::Notification, NotificationData_T = CLSensorCalibrationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLMotionNotifier::SiloDispatcher<CLGyro::Temperature>::dispatchData(int, const void *, size_t) [T = CLGyro::Temperature]
virtual void CLNotifier<CLSensorCalibrationController_Type::Notification, CLSensorCalibrationController_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLSensorCalibrationController_Type::Notification, NotificationData_T = CLSensorCalibrationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSensorCalibrationController_Type::Notification, CLSensorCalibrationController_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSensorCalibrationController_Type::Notification, NotificationData_T = CLSensorCalibrationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSensorCalibrationController_Type::Notification, CLSensorCalibrationController_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLSensorCalibrationController_Type::Notification, NotificationData_T = CLSensorCalibrationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSensorCalibrationController_Type::Notification, CLSensorCalibrationController_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSensorCalibrationController_Type::Notification, NotificationData_T = CLSensorCalibrationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSensorCalibrationController_Type::Notification, CLSensorCalibrationController_Type::NotificationData, char, char>::listClients() [Notification_T = CLSensorCalibrationController_Type::Notification, NotificationData_T = CLSensorCalibrationController_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
[notification: %d, globalAuth: %d]
[clientKey: %@, auth: %d, clear: %d]
Can't have a scan of no channels
Duty cycle percentage should be between 0 and 1
Duty cycle is NaN
virtual void CLKappaQualifierAlgAudioResult::log()
[Audio] TPQ summary,%d,A,%d,B,%f,C,%f,D,%f,E,%f,F,%f,G,%f,H,%f,I,%f,J,%f,K,%f,L,%d,M,%d,N,%d,O,%d,config-1,%d,config-2,%f,config-3,%d,config-4,%d,config-5,%f,config-6,%f,config-7,%f,config-8,%f,config-9,%f,config-10,%f,config-11,%f,config-12,%f
audio-A
audio-B
audio-C
audio-D
audio-E
audio-F
audio-G
audio-H
audio-I
audio-J
audio-K
audio-L
audio-M
audio-N
audio-O
audio-config-1
audio-config-2
audio-config-3
audio-config-4
audio-config-5
audio-config-6
audio-config-7
audio-config-8
audio-config-9
audio-config-10
audio-config-11
audio-config-12
virtual void CLKappaQualifierAlgAudioResult::recordCA(NSMutableDictionary *)
audio (%f, %f, %f, %f, %f, %f) (%d, %d, %d, %d, %d, %d) (%d %d %d %d)
audio_C
audio_D
audio_G
audio_H
audio_J
audio_K
audio_L
audio_M
audio_N
audio_O
void CLKappaQualifierAlgAudio::setConfig(const struct CLKappaQualifierAlgAudioConfig &)
audio config %d, %f, %d, %d, %f, %f, %f, %f, %f, %f, %f, %f
static void CLGeoMapAccessTileLoader::setTileMemoryCacheAndCountLimits()
CLMM, memory cache and tile count limit already set
CLMM,GEOTileLoader memory cache,%d,tile count limit,%d
com.apple.CLContextConfigurationManager
bool CLContextConfigurationManager::getParameterWithDefault(NSString *, double &)_block_invoke
[Dynamic Config] Error querying DB.
[Dynamic Config] No records in DB.
[Dynamic Config] Received parameter string %@.
bool CLContextConfigurationManager::getParameterWithDefault(NSString *, double &)
[Dynamic Config] No valid configuration found, parameter %@ left unchanged.
[Dynamic Config] Value for key %@ set on disk, returning.
[Dynamic Config] Configuration doesn't modify parameter %@.
[Dynamic Config] Sanity check failed for key %@ with retrieved value %{private}@.
[Dynamic Config] Overriding %@ to %{private}f
CMError CLContextConfigurationManager::insertNewConfig(const NSDictionary<NSString *,id> *)
[Dynamic Config] Invalid config received: %{private}@
[Dynamic Config] Valid config received: %{private}@
[Dynamic Config] Nil value received for one or more fields.
CMError CLContextConfigurationManager::insertNewConfig(const NSDictionary<NSString *,id> *)_block_invoke
[Dynamic Config] Ignoring duplicate config %@.
[Dynamic Config] Parameter dictionary is empty, returning.
[Dynamic Config] Error serializing parameter dictionary, error: %@
[Dynamic Config] Inserted config with ID %{public}@
bool CLContextConfigurationManager::isParameterSafe(NSString *, id)
[Dynamic Config] No bounds defined for parameter %@. Defined bounds are %@
[Dynamic Config] Out of bounds: Parameter %@ cannot be set to %@
bool CLContextConfigurationManager::isConfigValid(const NSDictionary<NSString *,id> *)
[Dynamic Config] Invalid configuration: too few keys.
[Dynamic Config] Invalid configuration: key %@ not found.
NSDictionary *CLContextConfigurationManager::stringToDictionary(NSString *)
[Dynamic Config] Parse error: %@, error: %@
void CLIndoorOutdoorSubscription::handleRequestIndoorOutdoorUpdate(bool, const CLNameValuePair &)
IndoorOutdoor, Subscription changed, %s, %p, %d
void CLIndoorOutdoorSubscription::handleMessageIndoorOutdoorLastKnownState(std::shared_ptr<CLConnectionMessage>)_block_invoke
IndoorOutdoor, most recent update at %f, type %ld, sending %@
v32@?0{IndoorOutdoorUpdate=dqq}8
void CLIndoorOutdoorSubscription::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)
CLIndoorOutdoorSubscription::onMotionStateMediatorNotification
CLWifiService_Type::AccessPointVector CL::Wifi1::Types::WifiScanHistory::removeAgedAccessPoints(cl::chrono::CFAbsoluteTimeClock::time_point, cl::chrono::secondsf)
@WifiAps, remove, %{private}s, age, %{public}d
@WifiAps, history, %{public}lu, aged, %{public}lu, thresh, %{public}d
CL::Wifi1::Types::AssociatedAp::AssociatedAp(const CLWifiService_Type::AccessPoint)
Initializing with invalid channel, %d
CL::Wifi1::Types::AssociatedAp::AssociatedAp(const std::optional<CLWifiService_Type::AccessPoint> &)
_centroidInfoIsAvailable
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/Logic/CLWifi1Types.mm
isMovingAp
void CL::Wifi1::Types::HeartbeatMetrics::recordBucketedFixApsCountPerScanRequestTypes(std::string, int)
WifiAps, fix ap count per scan type, invalid bucket index, %{public}d, # of fix APs, %{public}d
CLMobility::SteadinessSuppression_Generated::Features CLMobility::SteadinessSuppression::extractFeatures(CFAbsoluteTime, double, const std::vector<HealthKitQuantitySample> &, const std::vector<HealthKitQuantitySample> &, const SteadinessModelContinuousWalking_Generated::Features &)
CLMobility::SteadinessSuppression::Features,walkingSteadiness,%{private}.2f,allBoutsBoutDurationSecCv,%{private}.2f,intermediateBoutsDoubleSupportPercentageMedian,%{private}.2f,dailySteps30daysMax,%{private}.2f,dailyFlights30daysMax,%{private}.2f,dailySteps7daysMean,%{private}.2f
GpsForceOutdoorMatching
ObmAllowPositionOverride
ObmSearchRadius
ObmMinHorizontalUncertaintyAmidstBuildings
ObmAverageBuildingHeightForUncertaintyBump
ObmBumpHorizontalUncertaintyAmidstBuildings
ObmMinBuildingsForUncBump
CLOutdoorMatcher::CLOutdoorMatcher(CLMapGeometryPtr, const std::string &)
OBM,GpsForceOutdoorMatching,%{public}d,ObmAllowPositionOverride,%{public}d,fBumpHorizontalUncertaintyAmidstBuildings,%{public}d,fMinBuildingsForBump,%{public}u,fSearchRadiusInMeters,%{public}f,fMinHorizontalUncertaintyAmidstBuildings,%{public}f,fMinAverageBuildingHeightForUncertaintyBump,%{public}f
CLOutdoorMatcher::CLOutdoorMatcher(std::shared_ptr<CLGeoFeatureAccess3dBuildingGeometry>, const std::string &)
OBM, forcing building geometry
virtual bool CLOutdoorMatcher::match(CLMapCrumb &)
#Warning, OBM, cannot estimate nav mode, disabling
OBM, non-pedestrian, not matching
#Warning, OBM, no mapGeometry!
#Warning, OBM, no geometry!
#Warning, OBM, buildingsWithinDistance,%{public}lf returned false!
OBM, %{private}.13lf,%{private}.13lf,numbuildings,%{public}zu,radius,%{public}lf
#Warning, OBM, buildings.size() %{public}ld > 500. too many buildings. Aborting
OBM,averageBuildingHeight,%{public}.2lf,fNeighborhoodCharacter.type,%{public}d
OBM, not in any building
OBM, %{private}.13lf,%{private}.13lf,building,%{public}zu
OBM, a-priori,%{private}.6lf,%{private}.6lf,hacc,%{public}.2lf,a-posteriori,hacc,%{public}.2lf
#Warning, OBM, no building but point in building!
OBM, initialSize,%{public}ld,finalSize,%{public}ld
#Warning, OBM, no exterior particles remaining
OBM,particleCourse,%{public}.2lf,crumbCourse,%{public}.2lf,deltaCourse,%{public}.2lf,particle,%{public}.6lf,%{public}.6lf,crumb,%{public}.6lf,%{public}.6lf,deltaPos,%{public}.6lf,%{public}.6lf,score,%{public}.5lg,bestScore,%{public}.5lg,varFactor,%{public}.5lg
#Warning, OBM, LonLat conversion failed,point,%{public}lf,%{public}lf
OBM, inflatedHacc, %{public}.2lf, fMinHorizontalUncertaintyAmidstBuildings, %{public}.2lf. choosing max
OBM, a-priori,%{private}.6lf,%{private}.6lf,course,%{public}.2lf,hacc,%{public}.2lf,a-posteriori,%{private}.6lf,%{private}.6lf,course,%{public}.2lf,hacc,%{public}.2lf,bestScore,%{public}.6lg,bestLonLat,%{public}.6lf,%{public}.6lf,bestCourseInDegrees,%{public}.2lf,fAllowPositionOverride,%{public}d,
void CLOutdoorMatcher::setObservationCovarMatrix(CLMapCrumb &)
OBM, a11,%{public}.5lf,a12,%{public}.5lf,a22,%{public}.5lf,a33,%{public}.5lf
virtual void CLOutdoorMatcher::updateLocation(const CLDaemonLocation &, const CLDaemonLocationPrivate &)
OBM,update
virtual void CLOutdoorMatcher::updateMotion(const CLMotionActivity &)
Attempted to access the value of an uninitialized optional object.
lacID
arfcn
accuracy
locationType
verticalAccuracy
reach
infoMask
numberOfSurroundingCells
appBundleId
numberOfSurroundingCdmaCells
numberOfSurroundingCdmaEvdoCells
numberOfSurroundingLteCells
numberOfSurroundingScdmaCells
numberOfSurroundingNr5GCells
surroundingWifiBands
cellTower
wirelessAP
cdmaCellTower
lteCellTower
scdmaCellTower
nr5GCellTower
-[CLVO2MaxSubscriptionAdapter onRetrocomputeStatusUpdate:]
Attempting to notify nil retrocompute state
kCLConnectionMessageVO2MaxRetrocomputeStatusUpdate
void CLVO2MaxSubscription::handleRequestVO2MaxRetrocomputeStatusUpdate(bool, const CLNameValuePair &)
VO2Max Retrocompute Status, Subscription changed, %s, %p, %d
cellID
tacID
uarfcn
idx (%lu) is out of range (%lu)
needCellsTowers
numberOfSurroundingWifis
technology
wifiGranularity
wifiBands
wifiAltitudeScale
kRadioAccessTechnologyGSM
kRadioAccessTechnologyGSMCompact
kRadioAccessTechnologyUTRAN
kRadioAccessTechnologyCDMA1x
kRadioAccessTechnologyCDMAEVDO
kRadioAccessTechnologyCDMAHybrid
kRadioAccessTechnologyLTE
kRadioAccessTechnologySCDMA
kRadioAccessTechnologyNR5G
kGranularityFine
kGranularityCoarse
kGranularityNearby
kWifiAltitudeScaleNone
kWifiAltitudeScale10toThe2
Track: Type %d, startTime: %lf, stopTime: %lf, Coordinates: <%lf, %lf>
CLBarometerCalibrationContextManager.mm
Expected delegate to conform to CLBarometerCalibrationContextClient
MicroLocationNotifier
CLMicroLocationNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationNotifier.mm
-[CLMicroLocationNotifierAdapter beginService]
virtual void CLMicroLocationNotifier::stopRapportSession()
Rapport, unregister rapport session
virtual void CLMicroLocationNotifier::startRapportSession()
Rapport, register rapport session
Rapport, rapport session activation error:
device name unavailable
IDS Identifier unavailable - device not buffered to monitor
Model type unavailable  - device not buffered to monitor
CLMicroLocationNotifier
virtual void CLMicroLocationNotifier::shutdown()
MicroLocation: shutdown
void CLMicroLocationNotifier::startClients()
MicroLocations not supported on this platform
void CLMicroLocationNotifier::startClients()_block_invoke
Updating Significant Locations from Auth Cache Notification
com.apple.locationd.MicroLocationAction-localize
com.apple.locationd.MicroLocationAction-purge
CLATVAirplayMonitor
CLDuetMonitor
virtual void CLMicroLocationNotifier::startSpectating()
Recording event %{public}d not enabled
Registering for app launch notifications
Registering for first wake of day events
Registering for forced recordings
com.apple.locationd.MicroLocationAction-record
Home control suggestion enabled, %{public}d
Registering for HomeKit Accessory notifications
Registering for HomeKit Scene notifications
Registering for notifications of battery state
Registering for notifications of screen wake
Registering for Now Playing notifications
virtual void CLMicroLocationNotifier::stopSpectating()
Unregistering for app launch notifications
Unregistering for first wake of day events
Unregistering for Siri invocations
Unregistering for forced recordings
Unregistering for HomeKit Accessory notifications
Unregistering for HomeKit Scene notifications
Unregistering for notifications of battery state
Unregistering for notifications of screen wake
Unregistering for Now Playing notifications
NotificationMicroLocation
Client request
Current microlocation
Recording scan request
virtual void CLMicroLocationNotifier::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
Location services are disabled, ignore WiFi scan result
Received wifi notification %{public}d with scan type %{public}d
#Warning Received unknown wifi service notification %{public}d
Darwin
Daemon settings
startScanning
virtual void CLMicroLocationNotifier::startScanning(CLMicroLocationLogic::ILogicDelegate::ScanActivity)
Not scanning Wifi RSSI because it's not enabled
Not scanning Wifi RTT because it's not enabled
Not scanning HomeKit because it's not enabled
Not scanning for Apple TVs because it's not enabled
void CLMicroLocationNotifier::startWifiRssiScanning(CLMicroLocationLogic::ILogicDelegate::ScanActivity)
Wifi is powered off - not scanning
void CLMicroLocationNotifier::startHomeKitScanning()
HomeKit is powered off - not scanning
virtual void CLMicroLocationNotifier::startBleSpyscanSession()
Register for spyscan beacons
v16@?0@"CBDevice"8
Device lost: %@
CBDiscovery activation error:
virtual void CLMicroLocationNotifier::startBleSpyscanSession()_block_invoke
CBDiscovery activated successfully
virtual void CLMicroLocationNotifier::stopBleSpyscanSession()
Unregister spyscan beacons
Daemon status
Battery
Restricted power mode
Battery saver mode
Display
void CLMicroLocationNotifier::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
#Warning Received unhandled daemon status notification %d
Notification center
Force localization
Force record
Purge
void CLMicroLocationNotifier::onNotificationCenterNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
#Warning Got a notification center notification that we weren't expecting: %s
HomeKit
Power
Scan
Buffered scan
void CLMicroLocationNotifier::onHomeKitNotification(int, const CLHomeKitProvider_Type::Notification &, const CLHomeKitProvider_Type::NotificationData &)
Received unhandled homekit notification
virtual void CLMicroLocationNotifier::cancelRecordingTimer()
Recording timer cancelled
void CLMicroLocationNotifier::stopRecordingTimer()
Recording timer stopped
v32@?0{BundleIdFeatures=^^?Bi[1I]}8
CoreDuet
onForegroundAppLaunched
onFirstWakeOfDay
onHomeKitScene
onHomeKitAccesory
onNowPlaying
v32@?0@"NSNumber"8@"NSArray"16^B24
v32@?0@"NSNumber"8@"NSDictionary"16^B24
v24@?0@"NSArray"8@"NSError"16
results.size()>0
duetEventsFromMeasurement
numberOfWifiDevices
numberOfBleDevices
numberOfUwbDevices
_DKMicroLocationNumberOfDevices
void CLMicroLocationNotifier::saveEventsToDuetStream(NSArray<_DKEvent *> *)_block_invoke
#Warning Unable to save localization results to duet. %{private}s
Successfully logged to duet
void CLMicroLocationNotifier::clearDuetStream()
Deleting all entries in the MicroLocation CoreDuet event stream
void CLMicroLocationNotifier::clearDuetStream()_block_invoke
#Warning Unable to clear MicroLocation CoreDuet Event Stream. %{private}s
Deleted %{public}lu events from MicroLocation Event Stream
v24@?0Q8@"NSError"16
DataProtection
Data available
void CLMicroLocationNotifier::onDataProtectionManagerNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
Got a data protection notification we weren't registered for: %{public}d
Microlocation
CLMicroLocationNotifier::onDarwinNotification
CLMicroLocationNotifier::onDataProtectionManagerNotification
CLMicroLocationNotifier::onDaemonStatusNotification
CLMicroLocationNotifier::onHomeKitNotification
CLMicroLocationNotifier::onNotificationCenterNotification
MicroLocationsAppDenyList
CFGetTypeID(cfType) == CFStringGetTypeID()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationSettings.h
CFValueToNativeValue
com.apple.springboard.app-switcher
com.apple.mobilephone
com.apple.findmy
com.apple.gamecenter
com.apple.facetime
com.apple.camera
com.apple.AppStore
com.apple.mobiletimer
com.apple.purplebuddy
com.apple.Preferences
com.apple.MobileAddressBook
com.apple.VoiceMemos
com.apple.Bridge
com.apple.MobileStore
com.apple.TapToRadar
com.apple.mobilesafari
com.apple.mobilemail
com.apple.MobileSMS
com.apple.quicklook.quicklookd
com.apple.airplaydiagnostics.app.EmbeddedAirPlayDiagnostics
com.apple.tips
MicroLocationsScanWifiRSSIEnabled
MicroLocationsScanWifiRTTEnabled
MicroLocationsScanHomeKitEnabled
MicroLocationsScanATVEnabled
other
home
work
airplay
MicroLocationsVersion
1.0.11
set_datatype
microlocation.pb.h
::CLMicroLocationProto::DataType_IsValid(value)
virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]
void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]
virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::removeClient(int) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]
virtual bool CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]
virtual bool CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]
virtual bool CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]
virtual void CLNotifier<CLMicroLocationNotifier_Type::Notification, CLMicroLocationNotifier_Type::NotificationData, char, CLMicroLocationNotifier_Type::RegInfo>::listClients() [Notification_T = CLMicroLocationNotifier_Type::Notification, NotificationData_T = CLMicroLocationNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLMicroLocationNotifier_Type::RegInfo]
CL::Wifi1::Policies::FilterScanHistory::Output CL::Wifi1::Policies::FilterScanHistory::HandleEvent::selectApsForLocationComputation(const CL::Wifi1::Policies::FilterScanHistory::Input &) const
@WifiFlow, aps, history, %{public}lu, fresh, %{public}llu, 2ghz, %{public}llu, 5ghz, %{public}llu, agethresh, %{public}llu,
cdmaEvdoTower
macID
-[ALSWirelessAP writeTo:]
ALSWirelessAP.m
nil != self->_macID
Market, Bounds
, nwLat, 
, nwLon, 
, seLat, 
, seLon, 
void CLTileDownloadPolicy::receivedDownloadFailedAt(CFAbsoluteTime)
TileDl, backoff, count, %{public}d, time, %{public}0.1f
FF00FF00
FF0051DC
ffff0000
ff13458b
ffffff00
ff006400
ff00fc7c
ffff00ff
ff008cff
FF9F6FEF
FFFE8CB1
FF781E78
ff0000ff
FF00FFFF
AFFAFAFF
7F00FF00
7F0000FF
FF12FAFA
FF12FADA
FF12FAC5
FF12FA8D
FF12FA6A
FF35FA12
FF2DDC0E
FF22AA0A
FF198306
FF105503
yellow
darkyellow
orange
darkorange
asparagus
lime
darkgreen
bool CLParticleMapMatcherCommon::SolutionPropagator::findTunnelEndPoint(double, CLGpsAssistant_Type::TunnelEndPositionAssistance &, CLMapGeometryPtr, bool)
CLMM,no TEPA,isTunnel,%d,isSnapUsable,%d,lastAssistanceTime,%.1lf
CLMM,%.2lf,no TEPA, shifted coordinates
CLMM,TEPA,outgoing reached max iterations,%d
CLMM,no TEPA,multi-outbound,%d
CLMM,TEPA,incoming reached max iterations,%d
CLMM,no TEPA,multi-inbound,%d
CLMM,%.1lf,TEPA,ell,%{private}.7lf,%{private}.7lf,sll,%{private}.7lf,%{private}.7lf,alt,%.1lf,vUnc,%.1lf,length,%.2lf,distFromCurrentParticle,%.1lf,iterCountOut,%d,iterCountIn,%d
bool CLParticleMapMatcherCommon::SolutionPropagator::propagateSolution(CLDaemonLocation &, CLMapGeometryPtr, bool)
CLMM,%.2lf,NotPropagating,isTunnel,%d,isSnapUsable,%d,particleTime,%.2lf,particleTimeOut,%.1lf,speed,%.2lf,speedTime,%.2lf,speedTimeOut,%.1lf,speedLimit,%.1lf
CLMM,%.2lf,NotPropagating, shifting is required but accessory is outputting  unshifted coordinates
CLMM,%.2lf,NotPropagating,time lower than particleTime, %.2lf
CLMM,%.2lf,limit distance to propagate,orig,%.1lf,new,%.1lf
CLMM,NotPropagating,roadsAtIntersection returned false
CLMM,NotPropagating,multi-outbound,%lu,intersection within the distance,%.2lf, needed to be travelled returned
CLMM,NotPropagating,moveOnRoad returned false
CLMM,NotPropagating,NULL road
CLMM,NotPropagating,solution moved away from tunnel
CLMM,%.2lf,Propagating,lat,%.8lf,lon,%.8lf,course,%.8lf,speed,%.1lf,speedLimit,%.1lf
bool CLParticleMapMatcherCommon::StuckAtEndOfRoad::isStuckAtEndOfRoad(const bool)
#Warning CLMM, %.1lf,detected stuck,alongTrackRawToSnap,%.1lf,deltaPosChange,%.1lf,deltaSnapChange,%.1lf,thresholdDiff,%.1lf
CLMM, %.1lf,isMovingAway,%d,deltaPosChange,%.1lf,deltaSnapChange,%.1lf,thresholdDiff,%.1lf
CLFenceVertexDatabase::CLFenceVertexDatabase(const CLSqliteDatabase::SqliteProperties &, const CLSqliteDatabase::ColumnInfo *)
Fence: No access to vertices DB
Vertices
bool CLFenceVertexDatabase::addVertices(const std::vector<CLClientLocationCoordinate> &, int)
Fence: addVertices, key, %{public}d, num %{public}lu
Fence: attempting to add vertices to db without a key
) VALUES (?, ?, ?)
#Warning Fence: Couldn't bind statement for adding vertices (key %{public}d
bool CLFenceVertexDatabase::removeVertices(int)
Fence: Removing vertices, key, %{public}d
#Warning Fence: Couldn't bind statement for deleting vertices (key %{public}d
bool CLFenceVertexDatabase::getVertices(int, std::vector<CLClientLocationCoordinate> &)
Fence: Couldn't bind foreignKey %{public}d
Fence: Couldn't get vertices from database
Fence: Error in retrieving vertices from database for foreignKey %{public}d
AvengerScannerLongAggressiveScanNonCoexImpactedDuration
AvengerScannerLongAggressiveScanCoexImpactedDuration
bool CLKappaSubscription::sanityChecksForKappa(std::shared_ptr<CLConnectionMessage>)
Client %{private}s does not have appropriate motion entitlement.
Client %{private}s is not available on this platform.
void CLKappaSubscription::handleMessageKappaSendCommand(std::shared_ptr<CLConnectionMessage>)
use handleMessageKappaSendConfig to update the configuration
void CLKappaSubscription::handleMessageKappaSendAPCommand(std::shared_ptr<CLConnectionMessage>)
received AP command %d
invalid AP command
void CLKappaSubscription::handleRequestKappaGetStateUpdate(bool, const CLNameValuePair &)
kCLConnectionMessageKappaSubscriptionTypeKey
invalid item specified for kappa request
CLKappaSubscription::onKappaNotification
gpsStartTime%d,%.4f,gpsRawSpeed%d,%.4f,gpsDist%d,%.4f
macModes
CLEmergencyControllerAdapterSilo
CLEmergencyController::CLEmergencyController(id<CLIntersiloUniverse>)_block_invoke
#Warning #EmergCon call connect timeout fired
kNoCall
kActive
kHeld
kSending
kRinging
kDisconnecting
kDisconnected
void CLEmergencyController::registerObserver(id<CLEmergencyClientProtocol>)
#EmergCon #Warning inst0 settings find returned null
#EmergCon #Warning inst1 settings find returned null
locked
unlocked
void CLEmergencyController::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
#EmergCon,onDaemonStatusNotification,kNotificationLockScreen,display [%{public}s]
void CLEmergencyController::createTransaction()
#EmergCon Creating new transaction without releasing previous one
#EmergCon Creating os transaction CLEmergency
CLEmergency
void CLEmergencyController::releaseTransaction()
#EmergCon Release os transaction CLEmergency
#EmergCon Attempt to release transaction that was already released
void CLEmergencyController::setCLEEA(bool)
#EmergCon setCLEEA,Current,%d,New,%d,ignoring
#EmergCon setCLEEA,Current,%d,New,%d
kNone
kCellular
kEcbm
kLteEcbm
kCLEmergencyEnablementAssertion
kCellularS
kEcbmS
kLteEcbmS
kWifiS
kPresumedCellularEmergency
kCellularText
kCellularTextS
kWifiText
kWifiTextS
UnknownState
void CLEmergencyController::unpickAirPlayRoutes()_block_invoke
#EmergCon,error unpicking AirPlay routes,%{public}@
#EmergCon,successfully unpicked AirPlay routes
void CLEmergencyController::enterEmergency()
#EmergCon,EnterEmergency
#EmgContext,repeating current settings for sim 1,%{private}s
#EmgContext,repeating current settings for sim 2,%{private}s
void CLEmergencyController::exitEmergency()
#EmergCon,ExitEmergency
void CLEmergencyController::newState(CLEmergencyController::EmergencyState)
#EmergCon,newState,ignoring,fEmergencyStateOld,%d,state,%d
newState
void CLEmergencyController::updateEmergencyState()
#EmergCon,updateEmergencyState,emergency call not active but CT in voice emergency
newStateClass
emergencyenablementassertion
void CLEmergencyController::updateCleeaEmergencyState(CLEmergencyController::EmergencyState)
#EmergCon,updateCleeaEmergencyState,state,%d
#EmergCon,skipping updateEmergencyState, do not clear telephony determined emergency state
void CLEmergencyController::initCallConnectTimeout()
#EmergCon setting call connect timeout for %{public}f s
void CLEmergencyController::clearCallConnectTimeout()
#EmergCon clearing call connect timeout
void CLEmergencyController::createLongEemTimeout()_block_invoke
#EmergCon,longEemTimeout,longer than expected EEM detected
EEMTimeout
void CLEmergencyController::createLongEemTimeout()
#EmergCon,createLongEemTimeout,started timer for %{public}f
#EmergCon,createLongEemTimeout,timer already exists
void CLEmergencyController::clearLongEemTimeout()
#EmergCon,clearLongEemTimeout,timer cleared
#EmergCon,clearLongEemTimeout,no timer exists
simSlot
communicationType
callTriggerType
callDuration
emergencyModeRat
ratType
simBundleId1
operatorCountry1
operatorBundleId1
simBundleId2
operatorCountry2
operatorBundleId2
com.apple.locationd.emergency.long_eem
std::string CLEmergencyController::getBundleId(CLEmergencyController::SimInstance, CLEmergencyController::BundleType)
#EmergCon,getBundleId,unexpected bundle type
void CLEmergencyController::sendObserversNilrLockoutStatus(bool)
#EmergCon NILR %{public}s
#EmergCon NILR already %{public}s
EnableCPIDuringEmergencyMode
EnableEarlyReturnDuringEmergencyMode
AllowOTDOADuringEmergencyMode
DelayEmergencyUntilCallConnects
ControlPlane
UserPlane
AugmentedEmergencyAction
EnableMSAssisted
EnableAdditionalAssistedConstellations
Glonass
Beidou
Galileo
Qzss
Sbas
LPPRel13WlanMeas
LPPRel13LocationSource
ScanResultConfig
EnableRssi
CDMA
ProvideHELOUnsolicited
MeasurementTimeStampSource
SuplFlags
SuplHSLPServerAddress
SuplCARootCert
SuplUdpPortConfig
CLEmergencyController::onDaemonStatusNotification
CLEmergencyController::onClientNotification
ins,
,Location
,enableCpiDuringEmergencyMode,
,enableEarlyReturnDuringEmergencyMode,
,allowOTDOADuringEmergencyMode,
,EmergencyLocation,
,SUPL,
,BAA,
ControlPlane,
,ControlPlaneCdma,
,UserPlane,
,Action,
HslpAddress,
,HslpCARootCert,
,port,
,udpPortConfig,
,suplFlags,
,allowNonEmergencySupl,
,allowSuplWithoutEmergencyNotification,
,allowHslpMismatch,
,allowHslpWildCard,
,allowNonConformingEslpAddress,
#EED2,#BAA,Disabled,
,EEDEnabledOnly,
,CertValidityPeriod,
,NoCertRequestWindow,
,NoCertRetryWindow,
,CertAvailableRequestWindowMin,
,CertAvailableRequestWindowMax,
,CertAvailableRetryWindow,
enableMSAssisted,
,glonass,
,beidou,
,galileo,
,qzss,
,lppRel13MeasSettings,
,enableLocationSource,
device-based
network-assisted
static std::string CLEmergencyController::LocationSettings::Emergency::Settings::toString(CLEmergencyController::LocationSettings::Emergency::Settings::ConstellationUsage)
undefined constellation usage %d
undefined
enable,
,apConfig,
,enableRssi,
ServingApOnly
AllScannedAPs
static std::string CLEmergencyController::LocationSettings::Emergency::Settings::apConfigToString(CLEmergencyController::LocationSettings::Emergency::Settings::AccessPointConfig)
#wlan,apConfigToString,undefined AccessPointConfig,%d
provideHELOUnsolicited,
,timeStampSource,
Cdma
static std::string CLEmergencyController::LocationSettings::Emergency::measTimeStampSourceToString(CLEmergencyController::LocationSettings::Emergency::MeasurementTimeStampSource)
undefined MeasurementTimeStampSource,%d
#AML,
,#EED2,
,#EED2-sim,
smsAddress,
,sendBinarySms,
,smsDestinationPort,
,httpsAddress,
,firstFixDelay,
,multipleSmsEnabled,
,maxFixDelay,
,minFixDelay,
enabled,
,adrEnabled,
,lisUrl,
,adrUrl,
,firstLisPostDelay,
,periodicLisPostDelay,
,initialAdrPostTimeout,
,intermediateCert,
,dsaEnabled,
,partnerInfoVec,[
partnerId,
,adrCert,
{LocationSettings=iBBBBB{Emergency={Settings=Iiiiii{LPPRel13MeasSettings=IiI}I}{CDMASettings=Bi}{Settings=Iiiiii{LPPRel13MeasSettings=IiI}I}{VerticalUncertaintySettings=Bd}{AugmentedAction={AML={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BI{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}dBdd}{EED2=BB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}ddd{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}B{vector<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo, std::allocator<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo>>=^{PartnerInfo}^{PartnerInfo}{__compressed_pair<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo *, std::allocator<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo>>=^{PartnerInfo}}}}{EED2=BB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}ddd{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}B{vector<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo, std::allocator<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo>>=^{PartnerInfo}^{PartnerInfo}{__compressed_pair<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo *, std::allocator<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo>>=^{PartnerInfo}}}}}}{SuplSettings={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}SI(?=I{?=b1b1b1b1b1})}{BAA=BBiiiiii}{BAA=BBiiiiii}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}8@?0
{CLEmergencyState=iiiii}8@?0
CLOutdoorMatchingEngine
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MapMatching/CLOutdoorMatchingEngine.mm
fOutdoorMatcher
plos
CLOutdoorMatchingEngine::CLOutdoorMatchingEngine(id<CLIntersiloUniverse>)
PLOS, fPlatformSupportsPlosEstimation, %{public}d
virtual bool CLOutdoorMatchingEngine::match(CLDaemonLocation &, CLDaemonLocationPrivate &)
PLOS,%.3lf,fillCrumb false
PLOS: match returned false!
virtual void CLOutdoorMatchingEngine::setForceNetworkUsage(bool)
OBM, ForceNetworkUsage %{public}d
virtual void CLOutdoorMatchingEngine::setDisallowNetworkUsage(bool)
OBM, DisallowNetworkUsage %{public}d
void CLOutdoorMatchingEngine::onGpsNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
handling notification %{public}s
CLOutdoorMatchingEngine::onGpsNotification
void CLNADController::updateMarqueeApps(std::shared_ptr<std::vector<CLNADMarqueeApp>>, const CLNADLocationEvent &, double)
rtree: insert, adamId %{private}u, centroid %{private}lf, %{private}lf, %{private}s
updateIdleBBox
CLNADController.mm
fMarqueeApps != nullptr
fMarqueeAppsRTree != nullptr
bool CLNADController::updateIdleBBox()
idle bbox: no marquee apps, %{private}s
idle bbox: empty box, inside %{private}u's bbox: %{private}s
idle bbox: %{private}s
ilde box: all app's bboxes
idle bbox: marquee app fetch bbox, %{private}s
bool CLNADController::isNearAnyLois()
loi, precondition failed, not checking lois, nullptr
loi, empty loi, returning not near loi without checking
loi, nearby, %{private}lf, %{private}lf, type, %{private}lu, visit count, %{private}lu
bool CLNADController::shouldSuggest()
decision: in cool down, not suggesting, last suggestion, %{private}lf
decision: in idle box, not suggesting, box, %{private}lf, %{private}lf, %{private}lf, %{private}lf
suggest
fLois != nullptr
bool CLNADController::suggest()
decision: not in any app's bounding box, not suggesting
decision: near loi, not suggesting
rtree: traversing: adamId, %{private}u, %{private}s
decision: not inside any marquee app nearby bounding box, not suggesting, %{private}lf, %{private}lf
filter: %{private}u, above age limit: %{private}u, %{private}u
filter: %{private}u, installed
filter: %{private}u, recently suggested
filter: %{private}u, app not nearby, centroid, %{private}lf, %{private}lf
present: suggested %{private}u, done, at %{private}lf, %{private}lf
decision: suggested %{private}u, done, at %{private}lf, %{private}lf
decision: nothing to suggest, done, at %{private}lf, %{private}lf
void CLNADController::pruneSuggestionRecord()
maint: prune suggestion record, before, load factor, %{private}f, bucket ct, %{private}lu, size, %{private}lu
maint: prune suggestion record, after, load factor, %{private}f, bucket ct, %{private}lu, size, %{private}lu
POLYGON(
range.hpp
i < boost::size(rng)
apply
normalize_spheroidal_coordinates.hpp
math::smaller(constants::min_longitude(), longitude)
! math::larger(longitude, constants::max_longitude())
irange
irange.hpp
first <= last
pack_create.hpp
(detail::is_valid(indexable))&&("Indexable is invalid")
normalize_spheroidal_box_coordinates.hpp
! math::larger(longitude1, longitude2)
! math::smaller(longitude1, constants::min_longitude())
! math::larger(longitude2 - longitude1, constants::period())
range_of_boxes.hpp
! math::larger(lon_min, lon_max)
! math::larger(lon_max, constants::max_longitude())
! math::smaller(lon_min, constants::min_longitude())
! math::larger(max_gap_left, max_gap_right)
! math::larger(max_gap_right, constants::max_longitude())
! math::smaller(max_gap_left, constants::min_longitude())
max_interval_gap.hpp
queue.top().is_start_event()
per_level
(0 < std::distance(first, last) && static_cast<std::size_t>(std::distance(first, last)) == values_count)&&("unexpected parameters")
(values_count <= parameters.get_max_elements())&&("too big number of elements")
check_capacity
varray.hpp
(s <= v.capacity())&&("size too big")
per_level_packets
(subtree_counts.minc <= values_count)&&("too small number of elements")
(m_initialized)&&("uninitialized envelope accessed")
dereference
(m_values)&&("not dereferencable")
spatial_query.hpp
equals
query_iterators.hpp
(p)&&("iterators can't be compared")
operator->
scoped_ptr.hpp
px != 0
operator*
auto CLNADController::updateIdleBBox()::(anonymous class)::operator()(const CLNADMarqueeApp &) const
idle bbox: %{private}u, %{private}s
void CLMotionActivitySubscription::handleRequestMotionActivityUpdate(bool, const CLNameValuePair &)
Received MotionActivityUpdate request,client,%s,subscribe,%d
Cannot subscribe to motion activity updates, motion activity is not available
void CLMotionActivitySubscription::handleMessageMotionActivityQuery(std::shared_ptr<CLConnectionMessage>)
query for motion activity was received but motion activity is not available
CLDaemonClient.MotionActivityQuery
CLMotionActivitySubscription::onMotionActivityNotification
void CLTransitTilePreloader::makeRequestIfNeeded(bool, const CLDaemonLocation &, const CFAbsoluteTime &)
Request region preload manifest, no manifest
isStart,%d,manifest,%d,LastTime,%lf,LastLat,%.05lf,LastLon,%.05lf
Request region preload manifest, update
Found a preload region %s
void CLTransitTilePreloader::requestDownloadManifest(const bool, const CFAbsoluteTime &)
Requesting download of preload manifest, allowCell,%d
void CLTransitTilePreloader::requestDownloadWifiTile(const bool, const CLDaemonLocation &, const CFAbsoluteTime &)
Request tiles at lat,%.06lf,lon,%.06lf, allowCell,%d
CLAutopauseProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Autopause/CLAutopauseProvider.mm
-[CLAutopauseProviderAdapter beginService]
CLAutopauseProvider
virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::removeClient(int) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLAutopauseProvider_Type::Notification, CLAutopauseProvider_Type::NotificationData>::listClients() [Notification_T = CLAutopauseProvider_Type::Notification, NotificationData_T = CLAutopauseProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLFitnessControllerYouth::processEpoch(CLMotionStateMediator_Type::MediatedMotionActivity, const CLNatalieModelInput &)
startTime, %{public}.3f, rawActivity, %{public}d, overridenActivity, %{public}d
void CLFitnessControllerYouth::processQueue()
#Warning Popping out an activity since there's no activity associated with current time.  This shouldn't happen
DontSkip
InProgress
WifiNotPowered
Attempts
LowPriority
TileHeader
TileIndex_Mac
TileAccessPointTable
TileHeaderLocation
TileHeaderKeyLatLon
TileKeyLatLonIndex
TileKeyLatLonEntriesTable
TileApplicationsIndex
TileApplicationsEntries
TileApplicationsRegionalEntries
?unknown?
mcc, 
, mnc, 
, lac, 
, subY, 
, subX, 
, hUnc, 
, offset, 
, ci, 
, tac, 
, sid, 
, bsid, 
TileDownloadCoolOffPeriod
static void CLTileFile::initStaticGlobals()
TileFile, fTileDownloadCoolOffPeriod, %{public}.1lf
TileDownloadExtendedCoolOffPeriod
TileFile, fTileDownloadExtendedCoolOffPeriod, %{public}.1lf
TileForceExpirationPeriod
TileFile, fTileForceExpirationPeriod, %{public}.1lf
TileMinExpirationPeriod
TileFile, fTileMinExpirationPeriod, %{public}.1lf
bool CLTileFile::hasDataExpired(CFAbsoluteTime, bool, float)
@TileQueue, hasDataExpired, %{public}d, isLargeConnectivity, %{public}d, fExpirationAge, %{public}d, dataExpirationPeriod, %{public}.1lf, dataAge, %{public}.1lf, tile, %{private}s
bool CLTileFile::canRequestBasedOnAttempts(bool, float, CFAbsoluteTime)
TileFile, canRequestBasedOnAttempts, tile, %{private}s, age, %{public}.1lf, needs to be refreshed - retry
1st/Re-Try
TileFile, canRequestBasedOnAttempts, tile, %{private}s, age, %{public}.1lf, expirationAge, %d
Aged
TileFile, canRequestBasedOnAttempts, tile, %{private}s, sinceLastDownload, %{public}.1lf, %{public}d, needs to be refreshed, TileDoesNotExistOnTheServer
DoesntExist
Empty
@TileDl, %{public}s, attempts, llsw, %{private}.2lf, %{private}.2lf, lastSuccess, %{public}d, existsOnServer, %{public}d, sinceLastDownload, %{public}.1lf, cooloff1, %{public}d, cooloff2, %{public}d, cooloff3, %{public}d, expired, %{public}d, path, %{private}s
bool CLTileFile::startDownloading(const std::string &, CLFileDownload *)
TileFile, startDownloading, tile, %{private}s, localFilename, %{public}s, tempFilename, %{public}s
TileFile, startDownloading, failed to download without a downloadRequest, %{private}s, #CloneMe
TileFile, startDownloading, tile is already being downloaded, %{private}s, #CloneMe
TileFile, startDownloading, tile, %{private}s, started, %{public}d, strFileUrl, %{private}s
virtual bool CLTileFile::decompress(unsigned int &)
TileFile, decompress, failed to move, %{public}s, %{public}s, errno, %{public}d, %{public}s, #CloneMe
TileFile, decompress, from, %{public}s, to, %{public}s, failed, errno, %{public}d, %{public}s, #CloneMe
TileFile, decompress, in, %{public}.6lf, seconds, size, %{public}u, to, %{public}u, tile, %{private}s
TileFile, decompress, from, %{public}s, to, %{public}s, failed, %{public}u byte file, #CloneMe
TileFile, decompress, file is not compressed, %{private}s
bool CLTileFile::generateUniqueFileName(const std::string &)
TileFile, generateUniqueFileName, trying, %{public}s, tile, %{private}s
TileFile, generateUniqueFileName, end, localFilename, %{public}s, temp, %{public}s
void CLTileFile::deleteFile()
TileFile, deleteFile, unlink, %{public}s
void CLTileFile::deleteTempFile()
TileFile, deleteTempFile, unlink, %{public}s
bool CLTileFile::onDownloadCompleted(bool, bool, CFAbsoluteTime)
TileFile, onDownloadCompleted, success, %{public}d, fDownloadRequest, %{public}p, tileDoesNotExist, %{public}d, details, %{public}s
TileFile, copy from, %{public}s, to, %{public}s, start
CLTileFile::onDownloadCompleted
TileFile, onDownloadCompleted, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, tile, %{private}s
TileFile, onDownloadCompleted, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, type, %{public}d, %{public}s, #CloneMe
TileFile, tile, %{private}s, download failed, #CloneMe
TileFile, failed to move from, %{public}s, to, %{public}s, errno, %{public}d, %{public}s, #CloneMe
void CLTileFile::setLocalfilename(const char *)
TileFile, setLocalfilename, localFilename, %{public}s, tempFilename, %{public}s
void CLTileFileUtility::initTileIdWithLatitudeAndLongitude(TileId &, double, double, double, double, sec_key_t)
TileFile, Delta lat/lon zero, %{public}d, %{public}d, #CloneMe
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTileFile.mm
void CLTileFile::extractPropertiesFromTileHeader(CLTilesManager_Type::TileType, const CLWifiTileHeaderEntry &, CFAbsoluteTime)
bool CLTileFile::extractTileIdFromFile(const char *, const char *, CLTilesManager_Type::TileType, bool, CFAbsoluteTime)
TileFile,: extractTileIdFromFile, prefer local file name because it exists, %{public}s
extractTileIdFromFile
TileFile, extractTileIdFromFile, directory, %{public}s, filename, %{public}s, absFilename, %{public}s, type, %{public}d, isHeadersOnly, %{public}d
TileFile, extractTileIdFromFile, failed, %{public}s, #CloneMe
TileFile, extractTileIdFromFile, failed to open file, %{public}s, errno, %{public}d, %{public}s, #CloneMe
TileFile, extractTileIdFromFile, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, dLat, %{public}.5lf, dLon, %{public}.5lf
TileFile, extractTileIdFromFile, invalid hash value for, %{private}s, #CloneMe
TileFile, extractTileIdFromFile, read tileid from file, %{private}s
TileFile, extractTileIdFromFile, read, absFilenameParams, %{public}s
bool CLTileFile::readTileFileByFileName(const std::string &, const CLTileFile::TraverseDetails &)
TileFile, readTileFileByFileName, start, file, %{public}s, isHeadersOnly, %{public}d, isBinarySearch, %d
TileFile, readTileFileByFileName, reading input from stdin
TileFile, failed to open, %{public}s, errno, %{public}d, %{public}s, #CloneMe
TileFile, readTileFileByFileName, done, file, %{public}s, isHeadersOnly, %{public}d, isBinarySearch, %{public}d, isOK, %{public}d
static bool CLTileFile::setProtectionClass(const char *, CLTileFile::ProtectionClass)
TileFile,filename==nullptr
TileFile,setProtectionClass,failed,protectionClass,%{public}d,#CloneMe
TileFile,setProtectionClass,failed,%{public}s,protectionClass,%{public}d
bool CLTileFile::setProtectionClass(CLTileFile::ProtectionClass)
TileFile, setProtectionClass, tile, %{private}s, newClass, %{public}d, curClass, %{public}d
TileFile, setProtectionClass, invalid protectionClass, %{public}d, #CloneMe
bool CLTileFile::lockTile(bool)
@TileList, %{public}s, %{public}s, llsw, %{private}.2lf, %{private}.2lf, Class%{public}c
bool CLTileFile::unlockTile()
@TileList, %{public}s, unlocked, llsw, %{private}.2lf, %{private}.2lf, ClassC
CLTileFile::ProtectionClass CLTileFile::getProtectionClass()
TileFile, getProtectionClass, failed to open, %{public}s
TileFile, getProtectionClass, failed to set protection class, %{public}d, #CloneMe
bool CLTileFile::doesLocationIntersectWithTile(const CLDaemonLocation &, float)
TileFile, no location / coordinates, tile, %{private}s, scaledLocation, %{private}.8lf, %{private}.8lf, #CloneMe
TileFile, doesLocationIntersectWithTile, distance, %{public}.1lf, deltas, %{public}.1lf, %{public}.1lf
bool CLTileFile::touchMTime(const CFAbsoluteTime &, const CFAbsoluteTime &)
@TileList, %{public}s, touch, ignoring, %{public}.2lf, #CloneMe
@TileList, %{public}s, touch, llsw, %{private}.2lf, %{private}.2lf
void CLTileFile::savePersistentPropertiesToFile()
TileFile, saving, %{public}s
void CLTileFile::loadPersistentPropertiesFromFile(const std::string &)
TileFile, paramsFileExist, %{public}d, loading, %{public}s, accessTimestamp, %{public}.1lf
void CLTileFile::setSkipDownloadReason(char)
@TileReq, %{public}s, skip, llsw, %{private}.2lf, %{private}.2lf, reason, %{public}s, last, %{public}s
atime
stime
CLTileFile(
tileId=
, localFilename=
, tempFilename=
virtual bool CLTileFile::TEST_testBinarySearch(const char *)
This instance has no : TEST_testBinarySearch
CLPeerRangingNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/PeerRanging/CLPeerRangingNotifier.mm
-[CLPeerRangingNotifierAdapter beginService]
CLPeerRangingNotifier
-[CLPeerRangingNotifierAdapter(CLPeerRangingNotifierProtocol) newRequest:]
WRTT: No peer range notifier.
-[CLPeerRangingNotifierAdapter(CLPeerRangingNotifierProtocol) cancelRequest:]
PeerRangeRequestTimeout
NotificationPeerRanging
CLPeerRangingNotifier::onTimer
virtual void CLNotifier<CLPeerRangingNotifier_Type::Notification, CLPeerRangingNotifier_Type::NotificationData, char, CLPeerRangingNotifier_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLPeerRangingNotifier_Type::Notification, NotificationData_T = CLPeerRangingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLPeerRangingNotifier_Type::RegInfo]
void CLNotifier<CLPeerRangingNotifier_Type::Notification, CLPeerRangingNotifier_Type::NotificationData, char, CLPeerRangingNotifier_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLPeerRangingNotifier_Type::Notification, NotificationData_T = CLPeerRangingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLPeerRangingNotifier_Type::RegInfo]
virtual void CLNotifier<CLPeerRangingNotifier_Type::Notification, CLPeerRangingNotifier_Type::NotificationData, char, CLPeerRangingNotifier_Type::RegInfo>::removeClient(int) [Notification_T = CLPeerRangingNotifier_Type::Notification, NotificationData_T = CLPeerRangingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLPeerRangingNotifier_Type::RegInfo]
virtual bool CLNotifier<CLPeerRangingNotifier_Type::Notification, CLPeerRangingNotifier_Type::NotificationData, char, CLPeerRangingNotifier_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLPeerRangingNotifier_Type::Notification, NotificationData_T = CLPeerRangingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLPeerRangingNotifier_Type::RegInfo]
virtual bool CLNotifier<CLPeerRangingNotifier_Type::Notification, CLPeerRangingNotifier_Type::NotificationData, char, CLPeerRangingNotifier_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLPeerRangingNotifier_Type::Notification, NotificationData_T = CLPeerRangingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLPeerRangingNotifier_Type::RegInfo]
virtual bool CLNotifier<CLPeerRangingNotifier_Type::Notification, CLPeerRangingNotifier_Type::NotificationData, char, CLPeerRangingNotifier_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLPeerRangingNotifier_Type::Notification, NotificationData_T = CLPeerRangingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLPeerRangingNotifier_Type::RegInfo]
virtual void CLNotifier<CLPeerRangingNotifier_Type::Notification, CLPeerRangingNotifier_Type::NotificationData, char, CLPeerRangingNotifier_Type::RegInfo>::listClients() [Notification_T = CLPeerRangingNotifier_Type::Notification, NotificationData_T = CLPeerRangingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLPeerRangingNotifier_Type::RegInfo]
CLTilesManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTilesManager.mm
-[CLTilesManagerAdapter beginService]
+[CLTilesManagerAdapter isSupported]
CLTilesManager is not supported in diagnostics mode
CLTilesManager::isSupportedTileType(tileType)
-[CLTilesManagerAdapter requestTileDownloadByType:lat:lon:seckey:details:]
-[CLTilesManagerAdapter requestTileDownloadByType:path:details:]
MaxDownloadListSize
CLTilesManager::CLTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLITilesManagerExternal>, std::optional<CLTilesSetCollection>)
TILE: fDefaultMaxDownloadListSize, %d
initialize
CLTilesManager::CLTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLITilesManagerExternal>, std::optional<CLTilesSetCollection>)_block_invoke
TILE: registered, tilesSet, %s
TmmMgr, ctor
TILE: fMinEncryptionGracePeriod, %.2lf
@TileEvent, all, locked, %{public}d
ExpiredLocationTimer
Small
Large
AppTilesActive
CLTilesSetCollection CLTilesManager::initializeProductionTilesSetCollection()
TILE: isAppTilesActive, %d
TilePreloadManifestTilesActive
TILE: isTilePreloadManifestActive, %d
DEMTilesServerUrl
TILE: defaultDemTilesServerUrl, %{private}s, overridden, %{public}d
HrseTilesServerUrl
TILE: defaultHrseTilesServerUrl, %{private}s, overridden, %{public}d
TilePreloadManifestServerUrl
TILE: defaultTilePreloadManifestServerUrl, %{private}s, overridden, %{public}d
TransitMacServerUrl
TILE: defaultTransitMacTilesServerUrl, %{private}s, overridden, %{public}d
MaxTileAge
TILE: fDefaultMaxTileAge, %.1lf
TILE: fDefaultMaxTileDataAge, %.1lf
EncryptionGracePeriod
TILE: fDefaultEncryptionGracePeriod, %.1lf
MaxNumOfTiles
TILE: fMaxNumOfTiles, %d
DisableTilesWhileLocked
TILE: fDefaultDisableTilesWhileLocked, %d
NumOfSurroundingCirclesDEM
TILE: DEM,fDefaultNumOfSurroundingCirclesDEM, %d
NumOfSurroundingCirclesHrse
TILE: HRSE,fDefaultNumOfSurroundingCirclesHrse, %d
CLDemTileServer
CLHrseTileServer
CLAppTileServer
CLTransitTileServer
CLTransitMacTileServer
void CLTilesManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
TILE: onDataProtectionNotification, %p, notification, %d
TILE: onDataProtectionNotification, kNotificationEncryptedDataAvailability, was, %d, now, %d, availability, %d
onDataProtectionNotification
TILE: updateProtectionClass, skip on unlock
onDataProtectionNotification.cleanUnknownCache
void CLTilesManager::onCleanupAgedTiles()
TILE: onCleanupAgedTiles, %p
onCleanupAgedTiles
clearLocationInformationTiles
void CLTilesManager::clearLocationInformation()
TILE: %{public}s
void CLTilesManager::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
onCompanionNotification, notification, %d, Tiles
void CLTilesManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
TILE: onClientNotification, %p, notification, %d
TILE: kNotificationReset
TILE: kNotificationLocationServicesStatus, areLocationServicesEnabled, %d
TILE: location services off, remove all the tiles
TILE: #CacheDelete kNotificationSoftwareUpdateStorageRecovery
void CLTilesManager::deleteAgedDownloadItems(std::map<TileId, std::unique_ptr<CLTileFile>> &, CFAbsoluteTime)
TILE: deleteAgedDownloadItems, start
@TileReq, %{public}s, rmlist, llsw, %{private}.2lf, %{private}.2lf, aged, size, %{public}ld
TilesManager, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu
void CLTilesManager::agedTileDeleter(CLTilesSet &, CFAbsoluteTime)
TILE: deleteAgedTiles, age, %.1lf, %.1lf, tileDataAge, %.1lf, %.1lf, corrupt, %d, isDelete, %d, tile, %s
TILE: deleteAgedTiles, too many tiles, %lu, tile, %s
TilesManager, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu, name, %{private}s
void CLTilesManager::deleteAgedTilesForTilesSet(CLTilesSet &, CFAbsoluteTime)
TILE: deleteAgedTiles, start, name, %s, size, %lu
CLTilesManager::traverseAllTilesSets
void CLTilesManager::traverseAllTilesSets(const char *, CLTilesManager::CLTileManagerTraverseTilesSetBlock)
void CLTilesManager::deleteAgedTiles(CFAbsoluteTime)_block_invoke
TILE: dispatch, deleteAgedTiles, for, %s
void CLTilesManager::deleteAgedTiles(CFAbsoluteTime)
TILE: deleteAgedTiles, fTilesToDownload
void CLTilesManager::cancelAllDownloads()
TILE: cancelAllDownloads, planned, %lu
void CLTilesManager::removeAllTiles(bool, CLTilesManager_Type::TileType)
TILE: removeAllTiles, cleaning map, %d, %s
TILE: removeAllTiles, end, name, %s, size, %lu, unprot size, %lu, downloadSize, %lu
listTilesDirectory
bool CLTilesManager::listTilesDirectory(const std::string &, CLTilesManager_Type::TileType, CFAbsoluteTime)
TILE: listTilesDirectory, tileType, %d, %s
bool CLTilesManager::listAvailableFilesAllTypes(CFAbsoluteTime)
TILE: listAvailableFilesAllTypes, start
TILE: listAvailableFilesAllTypes, can't list tiles while locked, wait for unlock
B24@?0r*8I16B20
bool CLTilesManager::listAvailableFilesAllTypes(CFAbsoluteTime)_block_invoke
TILE: convert to class B, first unlock, %s
TILE: convert to class C, first unlock, %s
listerSetClass
listAvailableFilesAllTypes
@TileEvent, %{public}s, indexed, %{public}lu
TILE: listAvailableFilesAllTypes, done
bool CLTilesManager::listAvailableFilesByLister(const char *, CLTilesSet &, CLTilesManager::CLTileManagerFilesListerBlock)
TILE: listAvailableFilesByLister, reason, %s, rootDirectory, %s, name, %s
TileMgr, listAvailableFilesByLister, reason, %{public}s, can't open dir, %{public}s, #CloneMe
TILE: listAvailableFilesByLister, start
TILE: listAvailableFilesByLister, found tile file, filesNum, %u, absoluteFilename, '%s', d_type, %d
bool CLTilesManager::listAvailableFiles(const std::string &, CLTilesManager_Type::TileType, CFAbsoluteTime)
TileMgr, listAvailableFiles, can't open dir, %{public}s
TILE: listAvailableFiles, start
TILE: listAvailableFiles, found tile file, filesNum, %u, absoluteFilename, '%s', d_type, %d
TileMgr, listAvailableFiles, failed to stat file, %{public}s, ret, %{public}d, #CloneMe
index
TILE: listAvailableFiles, end
void CLTilesManager::refreshTilesDataIfNeeded()_block_invoke
TILE: refreshTilesDataIfNeeded, isTileDataExpired, %d, isShouldBeDownloaded, %d, tile, %s
void CLTilesManager::checkDownloadSchedule(CFAbsoluteTime)
TILE: checkDownloadSchedule, location services disabled - no tile downloads
TILE: checkDownloadSchedule, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: checkDownloadSchedule, no tiles while locked
TILE: checkDownloadSchedule, no data connectivity, avoiding downloads
TILE: checkDownloadSchedule, no download on none broadband cellular connections
TILE: checkDownloadSchedule, checking, numOfActiveDownloads, %u, small, %d, large, %d
TILE: checkDownloadSchedule, numOfActiveDownloads, %d, not scheduling more
TILE: checkDownloadSchedule, both download requests are already in use
TILE: checkDownloadSchedule, both download requests null, shutdown?
TILE: checkDownloadSchedule, isLocationValid, %d, isDeviceLocked, %d
TILE: checkDownloadSchedule, lastLocation, %s
CLTilesManager::isSupportedTileType(tile->getTileType())
checkDownloadSchedule
TILE: checkDownloadSchedule, isShouldDownload is not true, exists on server, %d
TILE: checkDownloadSchedule, rule, isCurrent, isAllowCellularIfCurrent,  IsOkToDownloadRealtime, %s
TILE: checkDownloadSchedule, rule, isCurrent, fDownloadCurrentTileOverCell, IsOkToDownloadRealtime, %s
TILE: checkDownloadSchedule, rule, isCurrent, IsOkToDownloadLarge, %s
TILE: checkDownloadSchedule, rule, isAllowCellularIfNotCurrent, IsOkToDownloadRealtime, %s
TILE: checkDownloadSchedule, rule, IsOkToDownloadLarge, %s
TILE: checkDownloadSchedule, isShouldDownload, %d, isAllowDownload, %d, isCurrentTile, %d, isAllowCellular, %d, check, %s, details, %s
TILE: checkDownloadSchedule, chose, downloadState, %s
TILE: checkDownloadSchedule, started downloading, numOfActiveDownloads, %d, tile, %s
startDownloading
getTile
isCurrentTile
isAllowCellular
@TileReq, %{public}s, start, llsw, %{private}.2lf, %{private}.2lf, reach, %{public}d, url, %{private}s
TILE: checkDownloadSchedule, numOfActiveDownloads, %d, tilesToDownload, %lu, small, %d, large, %d
TILE: checkDownloadSchedule, NoActiveDownloads
tileDownloaded
void CLTilesManager::tileDownloadCompleted(CLFileDownload *, bool, void *)
TILE: tileDownloadCompleted, tile, %s, download done, success, %d, NSURLErrorCode, %d, tileDoesNotExist, %d, reachability, %d, locked, %d, fileSize, %d
TileMgr, where did this download request come from?, download, %{public}p, #CloneMe
void CLTilesManager::tileDecompressionCompleted(CLFileDownload *, bool, void *, CFAbsoluteTime)
TileMgr, tileDecompressionCompleted, nullptr in fTilesDownload, #CloneMe
TileMgr, tileDecompressionCompleted, no tile for download, %{public}p, #CloneMe
tileDecompressionCompleted
TILE: tileDecompressionCompleted, tile, %s, decompress done, tileDownloadWasSuccessful, %d, NSURLErrorCode, %d, tileDoesNotExist, %d, reachability, %d
TILE: tileDecompressionCompleted, tile, %s, reachability, %d, isLocked, %d, downloadDuration, %.1lf, downloadState, %s, progress, s, %d, l, %d
TILE: tileDecompressionCompleted, replacing from, %s
TILE: tileDecompressionCompleted, replacing to, %s
TileMgr, tileDecompressionCompleted, where the file, was it deleted, %{private}s, #CloneMe
TILE: tileDecompressionCompleted, added, tileid, %s, tilesMap.size, %lu
void CLTilesManager::sendNotificationTileWasDownloaded(bool, const CLTileFile &, const CLTilesSet &)
TILE: kNotificationTileWasDownloaded, tileid, %s, tileHeaderParsed, %d, tileType, %d, serverUrl, %s, serverFilename, %s, absoluteLocalFilename, %s
static void CLTilesManager::_tileDownloadCompleted(CLFileDownload *, bool, void *)
TILE: _tileDownloadCompleted, success, %d
static void CLTilesManager::_tileDownloadCompleted(CLFileDownload *, bool, void *)_block_invoke
unsigned int CLTilesManager::getNumOfActiveDownloads()
TILE: getNumOfActiveDownloads, tile, %s, is being downloaded, %d, total, %d, download, %p
requestDownload
bool CLTilesManager::requestDownload(CLTilesManager_Type::TileType, double, double, sec_key_t, const std::string &, const CLTileFileDownloadDetails &, CFAbsoluteTime)
TILE: requestDownload, type, %d, %s, not active
TILE: requestDownload, type, %d, %s, location, %14.8lf, %14.8lf, id, %s, reachbility, %d, details, %s
@TileDl, %{public}s, request, llsw, %{private}.2lf, %{private}.2lf
TILE: requestDownload, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: requestDownload, ignoring request, no sec_key
TILE: requestDownload, tileId=%s isAlreadyDownloaded, %d, isBeingDownloaded, %d, shouldDownloadedBasedOnPermissions, %d
TILE: requestDownload, tileid, %s, already available, isUpdateMTimestamp, %d, isShouldBeRefreshed, %d, isBeingDownloaded, %d
TILE: requestDownload, refresh download, %s
TILE: requestDownload, tileid, %s, will be downloaded, details, %s
TILE: requestDownload, tileid, %s, is locked will be redownloaded, details, %s, allowRedownload, %d, isAddToDownloadList, %d
TILE: requestDownload, tileid, %.8lf, %8lf, will be downloaded, details, %s
ForceDownloadDEMTiles
TILE: DEM,fForceDownloadDEMTiles, %d
TILE: DEM, skip, tile is not available based on availability file
TILE: HRSE, skip, tile is not available based on availability file
@TileReq, %{public}s, onlist, llsw, %{private}.2lf, %{private}.2lf, center, size, %{public}ld
TILE: requestDownload, out of boundaries, y, %d, x, %d, tile_y, %d, tile_x, %d, neighbourTileID, %s
TILE: requestDownload, y, %d, x, %d, tile_y, %d, tile_x, %d, neighbourTileID, %s
TILE: requestDownload, adding neighbour, %s
@TileReq, %{public}s, onlist, llsw, %{private}.2lf, %{private}.2lf, neighbor, size, %{public}ld
getRawTileFile
CLTileFile *CLTilesManager::getRawTileFile(const CLTilesManager_Type::TileType &, const double &, const double &, std::string &, bool &, bool &)
TILE: getTileFile, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: getTileFile, tile, %s, isAvailable, %d, isFileAccessible, %d
TILE: getTileFile, tileid, %s, not available
deleteTileFile
bool CLTilesManager::deleteTileFile(const CLTilesManager_Type::TileType &, const char *)
TileMgr, deleteTileFile, tileType, %{public}d, %{private}s, localPathToFile, %{public}s, #CloneMe
TILE: deleteTileFile, deleting, tileid, %s
this->fTilesToDownload.find(tileIdToDownload) == this->fTilesToDownload.end()
addToDownloadList
bool CLTilesManager::addToDownloadList(std::unique_ptr<CLTileFile>, const TileId &, const CLTileFileDownloadDetails &)
TILE: addToDownloadList, added, %s, fTilesToDownload.size, %lu
void CLTilesManager::updateProtectionClass(const char *, const CLDaemonLocation &, bool)
#Warning TILE: updateProtectionClass, called on when not locked
void CLTilesManager::updateProtectionClass(const char *, const CLDaemonLocation &, bool)_block_invoke
TileMgr, updateProtectionClass, start, %s, reason, %s, isAboutToLock, %d, locationAge, %.1lf, doLocCheck, %d, sizes, %lu, %lu, knownLocation, %s
TileMgr, tile ptr is NULL, #CloneMe
TileMgr, updateProtectionClass, failed unlocking tileid, %{private}s, size, %{public}lu, #CloneMe
TileMgr, updateProtectionClass, unable to lock tile, locking tileid, %{private}s, #CloneMe
TILE: updateProtectionClass, location moved, locking tileid, %s
TileMgr, updateProtectionClass, unable to lock tile, locking tileid, %{pricate}s, #CloneMe
TileMgr, %{public}s, locking, %{public}d, lock, %{public}d, unlock, %{public}d, size, %{public}lu
TILE: updateProtectionClass, clearing unprotected map
TileMgr, Unable to lock all unprotected files!, #CloneMe
TILE: updateProtectionClass, end, %s, total, %lu, numOfUnProtectedTiles, %d
@TileEvent, %{public}s, locking, %{public}d, readable, %{public}lu
updateProtectionClass
TILE: updateProtectionClass, done, isAboutToLock, %d, numOfUnProtectedTiles, %d
void CLTilesManager::scheduleExpiredLocationTimer(const char *)
TILE: scheduleExpiredLocationTimer, no valid location
TILE: scheduleExpiredLocationTimer, reason, %s, locationAge, %.1lf, secondsFromNow, %.1lf, lastKnownLocation, %s
void CLTilesManager::cancelExpiredLocationTimer()
TILE: cancelExpiredLocationTimer
void CLTilesManager::onExpiredLocationTimerFired()
TILE: onExpiredLocationTimerFired, isLocked, %d
TILE: onExpiredLocationTimerFired
onExpiredLocationTimerFired
void CLTilesManager::onPCTimerFired(CLPersistentTimer *)
TILE: onPCTimerFired
void CLTilesManager::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
TILE: onLocationNotification, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: onLocationNotification, ignore leech when LS off
TILE: onLocationNotification, fLastLocationDownloadCheckTimestamp, %.1lf, isForceLocationCheck, %d, fLastLocationProtectionCheckTimestamp, %.1f, leech location, %s
onLocationNotification
TILE: onLocationNotification, unknown notificaiton, %d, %s
void CLTilesManager::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
TileMgr, onStatusNotification, unknown notification, %{public}d, #CloneMe
void CLTilesManager::cleanUpDownloadList(CFAbsoluteTime)
TILE: cleanUpDownloadList, start, isLocked, %d
TILES: cleanUpDownloadList, download list is too large, %lu
TILE: cleanUpDownloadList, tileid, %s, available on disc, no need to download
TILE: cleanUpDownloadList, done,  isLocked, %d, cleanedFiles, %u
virtual void CLTilesManager::shutdown()
TILE: CLTilesManager::shutdown
void CLTilesManager::getTileStats(CLDaemonStats_Type::LocationNetworkQueries &)
TILE: stats: getTileStats, demTilesDownloaded, %d
TILE: stats: getTileStats, hrseTilesDownloaded, %d
resetStats
getTilesSet
CLTilesSet &CLTilesManager::getTilesSet(CLTilesManager_Type::TileType)
TileMgr, invalid tileType, %{public}d, #CloneMe
https://cl3.apple.com/3/v2
https://cl3.apple.com/2/v1
predownloadTilesForLocation
location.horizontalAccuracy > 0.0
void CLTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)
updateTileLocationRelevancy
void CLTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)_block_invoke
TILE: location not relevant
TILE: updating dem neighbor mtime, %d, type, %d, tileid, %s
Invalid dem neighbor tile id!
TILE: updating HRSE neighbor mtime, %d, type, %d, tileid, %s
Invalid HRSE neighbor tile id!
TileMgr, Invalid tile id!, #CloneMe
bool CLTilesManager::getAppAvailabilityForArea(double, double, float, CLTilesManager::SearchContext &, std::list<AppAvailability> &, bool)
TILE: getAppAvailabilityForArea, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: getAppAvailabilityForArea, tiles, %d, %s, are not active on this device
TILE: getAppAvailabilityForArea, loc, %.8lf, %.8lf, radius, %.3f
TILE: getAppAvailabilityForArea, tile, %s
TILE: getAppAvailabilityForArea, ctile, %s
TILE: already been searched
TILE: getAppAvailabilityForArea, y, %d, x, %d, ntile, %s
TILE: getAppAvailabilityForArea, appRecommendation, %lu, %s, loc, %.10lf, %.10lf, span, %.10lf, %.10lf
143441
std::string CLTilesManager::composeFullAppTilesServerUrl()
TILE: fullAppTilesServerUrl, %s
void CLTilesManager::storeFrontDidChange()
TILE: onStoreFrontDidChangeNotification, new fServerUrl, %s
void CLTilesManager::enableAppTilesDownload(bool)
TILE: shouldEnableAppTiles, %d, fAppTilesEnabled, %d
pMarkets != nullptr
getRegionPreloadManifest
bool CLTilesManager::getRegionPreloadManifest(std::vector<CLMarketRegion> *)
Get manifest tile, %lu
tilesSet.fTilesMap.size() == 1 && "Why do we have more than one, we only want one"
resultMacAddresses != nullptr
getTransitMacAddresses
bool CLTilesManager::getTransitMacAddresses(std::vector<uint64_t> *, double, double, std::vector<CLTilesManager_Type::TransitMac> *)
TransitMac: getTransitMacAddresses, tile exists, %s
([0-9]{8})
adsf
tiles_hrse
tiles_app_v2
https://cl5.apple.com/
tiles_preload_manifest
https://cl2.apple.com/9/v2
tiles_transit_mac
https://corelocation.s3.amazonaws.com/tr/v1
std::tuple<bool, CLTileFile *> CLTilesManager::createTileFileObject(CLTilesManager_Type::TileType, const std::string &, const std::string &, CFAbsoluteTime)
void CLTilesManager::lockTileIfNeeded(CLTileFile *, CLTilesSet &, CFAbsoluteTime, const char *)
TILE: tileDecompressionCompleted, added to unprotected list, tileid, %s, size, %lu
TILE: tileDecompressionCompleted, unable to unlock, tileid, %s, size, %lu
@TileList, %{public}s, add, llsw, %{private}.2lf, %{private}.2lf, %{public}s, size, %{public}lu, 
TILE: tileDecompressionCompleted, unlocked tile type, tileid, %s, unlocked, %d
cldavl.avl
clhrseavl.avl
CLTilesManager::onPCTimerFired
.plist
tileFileDownloadDetails
, cellIfCurrent, 
, cellIfNotCurrent, 
, redownload, 
, timeout, 
, numNeighbors, 
, timestamp, 
, age, 
, decompress, 
sw_cor, 
, adamId, 
, radiusIns, 
, rankIns, 
, rankUnIns, 
, touristApp, 
, marqueeApp, 
.ignore
virtual void CLNotifier<CLTilesManager_Type::Notification, CLTilesManager_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLTilesManager_Type::Notification, NotificationData_T = CLTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLTilesManager_Type::Notification, CLTilesManager_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLTilesManager_Type::Notification, NotificationData_T = CLTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLTilesManager_Type::Notification, CLTilesManager_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLTilesManager_Type::Notification, NotificationData_T = CLTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTilesManager_Type::Notification, CLTilesManager_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLTilesManager_Type::Notification, NotificationData_T = CLTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTilesManager_Type::Notification, CLTilesManager_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLTilesManager_Type::Notification, NotificationData_T = CLTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTilesManager_Type::Notification, CLTilesManager_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLTilesManager_Type::Notification, NotificationData_T = CLTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLTilesManager_Type::Notification, CLTilesManager_Type::NotificationData, char, char>::listClients() [Notification_T = CLTilesManager_Type::Notification, NotificationData_T = CLTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
static float CLNatalieCycleModel::computeHRMets(float, const CLNatalieModelInput &)
Cycle, CR DT Regression, %f, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, duration(s), %f, weight(kg), %f, METS, %f
virtual CLMetsInfo CLNatalieCycleModel::computeMETS(const CLNatalieModelInput &)
Cycle, GPS speed at time, %f, %f is too high,  set to maximum default, %f
Cycle, Uphill vertical speed at time, %f, %f is too high, set to maximum default %f
Cycle, WR Linear Regression, %f, %f, Grade type, %d, GPS Speed, %f, Vertical Speed, %f, Duration(s), %f, Weight(kg), %f, WR METS, %f
Cycle, Model switcher input availability, StartTime, %f, EndTime, %f, ModelSwitcherInputCase, %d, gradeType, %d, hspeed, %f, vspeed, %f, isCatherineAvailable, %d, isCatherineReliable, %d, isGpsAvailable, %d, HRstaleness, %f
Cycle, Fused, %f, %f, HR METS, %f, WR METS, %f, Fused User METS, %f, Grade type, %d, GPS Speed, %f, Vertical Speed, %f, Duration(s), %f, Weight(kg), %f, Steps, %d, ModelSwitcherInputCase, %d, distance, %f, altitude, %f, HRstaleness, %f, HR, %f, userMetSource, %d, Fused Truth METs, %f, truthMetSource, %d, isAssistedCycling, %d
static float CLNatalieCycleModel::computeWRMETS(const float, const float, const float)
Cycle, RollingResistance,%f,gravity,%f,wind,%f
static float CLNatalieCycleModel::computeLinearRegressionWR(float, float, const CLNatalieModelInput &)
Cycle, totalWR,%f,startTime,%f,endTime,%f
, lat, 
, lon, 
, alt, 
, acc, 
, vacc, 
, channel, 
, score, 
, reach, 
, rssi, 
, qTime, 
, sTime, 
, flg, -
CLWifiAPLocation.cpp
fScore != UNINITIALIZED_SCORE
TilesSetGlobalProperties
entry != fTileRootDirectories.end()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTilesSetGlobalProperties.mm
getRootDirectoryForTileType
Tokyo-1
Tokyo-2
Tokyo-3
Hong Kong-1
Hong Kong-2
Hong Kong-3
Hong Kong-4
Singapore-1
Singapore-2
Singapore-3
Singapore-4
Singapore-5
Singapore-6
Singapore-7
Shanghai-1
Shanghai-2
Shanghai-3
Shanghai-4
Shanghai-5
Shanghai-6
Shanghai-7
Shanghai-8
Shanghai-9
Shanghai-10
Beijing-1
Beijing-2
Beijing-3
Beijing-4
Beijing-5
Beijing-6
Beijing-7
Beijing-8
Beijing-9
Paris-1
Paris-2
London-1
London-2
London-3
London-4
London-5
London-6
London-7
Frankfurt-1
Frankfurt-2
Frankfurt-3
Frankfurt-4
Frankfurt-5
Frankfurt-6
Stockholm-1
Stockholm-2
Stockholm-3
Sydney-1
Sydney-2
Sydney-3
Sydney-4
Dubai-1
Dubai-2
Dubai-3
Mumbai-1
Mumbai-2
Cairo-1
Cairo-2
Cairo-3
Cairo-4
Cairo-5
Cairo-6
Cairo-7
Cairo-8
Shanghai-11
Shanghai-12
Beijing-10
Beijing-11
Barcelona-1
Barcelona-2
Houston-1
Seattle-1
LasVegas-1
LasVegas-2
Miami-1
Denver-1
NY-1
Chicago-1
Chicago-2
Chicago-3
Chicago-4
SF-1
SF-2
SJ-1
SJ-2
SJ-3
SJ-4
SJ-5
Atlanta-1
Atlanta-2
Atlanta-3
BarometerCalibrationEnableSanctionedPolygons
SkiHistory
DELETE FROM SkiHistory WHERE startTime < ?
SELECT * from SkiHistory ORDER BY id ASC
SELECT COUNT(*) FROM SkiHistory
(silo && handler) || (!silo && !handler)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Skiing/CLSkiRecorderDb.mm
setInsertHandler
DELETE FROM SkiHistory
DELETE FROM SkiHistory WHERE startTime > ?
UPDATE SkiHistory SET startTime = startTime + ?
INSERT INTO SkiHistory (sessionId, startTime, endTime, runDistance, runAvgSpeed, runMaxSpeed, runSlope, runElevationDescent) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
SELECT * FROM SkiHistory ORDER BY startTime DESC LIMIT 1
SELECT * from SkiHistory WHERE sessionId = ?
CMError CLSkiRecorderDb::getEntries(unsigned char *, std::vector<CLSkiEntry> &) const
Unable to get entries for sessionId %{public}s
SELECT * from SkiHistory WHERE id >= ?
CMError CLSkiRecorderDb::querySince(const CLSkiEntry &, std::vector<CLSkiEntry> &) const
Failed to bind id in query, %{public}llu
SELECT * from SkiHistory ORDER BY id DESC LIMIT 1
SELECT * FROM SkiHistory ORDER by id DESC limit ?
CMError CLSkiRecorderDb::getEntries(int, std::vector<CLSkiEntry> &) const
Unable to get entries
runDistance
runAvgSpeed
runMaxSpeed
runSlope
runElevationDescent
CLActivityRecorderDb<CLSkiEntry>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSkiEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLSkiEntry>::setDatabaseAccessible() [T = CLSkiEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLSkiEntry>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLSkiEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
mac, 
static void CLWifiTileFile::initStaticGlobals()
TILE: running initStaticGlobals
kMinimumSupportedTilesVersion
TILE: fMinimumSupportedTilesVersion, %d
CLWifiTileFile-Mutex
virtual void CLWifiTileFile::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &)
TILE: CLWifiTileFile, sectionId, %d, %s
TILE: tileMacIndexHeader, entrySizeInBytes, %u
TILE: headers only, avoid reading SectionID_TileIndex_Mac
TILE: headers only, avoid reading SectionID_TileAccessPointTable
virtual void CLWifiTileFile::onTraversingTileIndexEntry(const CLTilesManager_Type::AccessPointIndexEntry &)
TILE: idx, %3lu, %3u, mac, %s, offset, %u
virtual void CLWifiTileFile::onTraversingTileAPTableEntry(const CLTilesManager_Type::AccessPointEntry &)
TILE: mac, %3u, mac,%x:%x:%x:%x:%x:%x, y, %3d, x, %3d, loc, %14.10lf, %14.10lf, unc, %.1lf, reach, %.1lf
bool CLWifiTileFile::binarySearchAP(CLTilesManager_Type::AccessPointEntry *, unsigned int, const CLTileFile::TraverseDetails &, const CLTilesManager_Type::TileAccessPointTable &)
TILE: binarySearchAP, match, %012llx, %012llx
bool CLWifiTileFile::binarySearchIndex(const CLTilesManager_Type::AccessPointIndexEntryVector &, const CLTileFile::TraverseDetails &, unsigned int &, unsigned int &)
WifiTile, binarySearchIndex, ==================> indexFailed <==================, size, %{public}4lu, a, %{public}4lu, b, %{public}4lu, c, %{public}4lu,  A, %{public}012llx,  S, %{public}012llx, B, %{public}012llx, #CloneMe
TILE: binarySearchIndex, indexFound, isFound, %d, wasSearched, %d, size, %4lu, a, %4lu, b, %4lu, c, %4lu, searchAr, %4u, A, %012llx,  S, %012llx, B, %012llx
virtual bool CLWifiTileFile::traverseTileFile(FILE *, const CLTileFile::TraverseDetails &)
TILE: traverseTileFile, message, %s, isHeadersOnly, %d, isBinarySearch, %d, macAddressToSearch, %012llx, cachedIndex, %d
TILE: traverseTileFile, indexVector cached, seek to the APs table, %lld
TILE: traverseTileFile, re-using cached index vector
TILE: traverseTileFile, searched index, A, %012llx, mac, %012llx, B, %012llx, indexSize, %lu, halting search
WifiTile, Invalid section signature, readBytes, %{public}lu, section, signature, 0x%{public}x, sectionId, %{public}d, sizeBytes, %{public}d, #CloneMe
WifiTile, message, %{public}s, readBytes, %{public}lu, section, signature, 0x%{public}x, sectionId, %{public}d, sizeBytes, %{public}d, headerSizeBytes, %{public}d, sectionId, %{public}d, #CloneMe
WifiTile, traverseTileFile, invalid tile file, bad allocation size, bytesToAllocate, %{public}lu, maxAllocationSize, %{public}lu, #CloneMe
TILE: skip section, message, %s, signature, 0x%x, sectionId, %d, sizeBytes, %d, headerSizeBytes, %d
WifiTile, failed to allocate memory for, %{public}lu, #CloneMe
WifiTile, failed to read, %{public}lu, %{public}lu, #CloneMe
this->fCurrentIndexVector != __null
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLWifiTileFile.mm
TILE: searched index, A, %012llx, mac, %012llx, B, %012llx, indexSize, %lu, halting search
TILE: searched index, A, %012llx, mac, %012llx, B, %012llx, indexSize, %lu
TILE: headers only, avoid reading the APs
TILE: unknown section : %d
TILE: traverseTileFile, finished traversing, file, index entries, %lu, apEntries, %lu
-[CLFallTap2Radar initInUniverse:]
Initializing CLFallTap2Radar instance
-[CLFallTap2Radar dealloc]
Tearing down CLFallTap2Radar instance
/var/mobile/Library/locationd/CMFallSnippetData-%i.log
/var/mobile/Library/locationd/CMFallSnippetMeta-%i.json
-Apple Internal-
An impact was detected in the background
-Apple Internal-
You experienced a fall%@
 yesterday
-Apple Internal-
A fall was misdetected
-Apple Internal-
A fall was detected in the background
-Apple Internal-
A fall was detected
com.apple.locationd.fall.tap2radar
Would you help and file a radar with sensor data?
File a radar, I fell
Do not file a radar, I did not fall
File a radar, I did not fall
File a radar
-[CLFallTap2Radar trigger:metaData:start:end:response:resolution:isNearFall:isFallSubmissionAllowed:isNearFallSubmissionAllowed:]_block_invoke
CFUserNotificationReceiveResponse returned %d at time %f.
tap-to-radar://new?Title=T2R%%20True%%20fall%%20detection&Description=This%%20is%%20auto%%20filled,%%20please%%20add%%20details&Classification=Serious%%20Bug&Reproducibility=Not%%20Applicable&ComponentName=CoreMotion%%20Fall%%20Detection&ComponentVersion=Tap-To-Radar&Attachments=%%2Fvar%%2Fmobile%%2FLibrary%%2Flocationd%%2FCMFallSnippetData-%i.log,%%2Fvar%%2Fmobile%%2FLibrary%%2Flocationd%%2FCMFallSnippetMeta-%i.json&Keywords=FallTruePositive&AutoDiagnostics=watch&ComponentID=1076782
tap-to-radar://new?Title=T2R%%20False%%20fall%%20detection&Description=This%%20is%%20auto%%20filled,%%20please%%20add%%20details&Classification=Serious%%20Bug&Reproducibility=Not%%20Applicable&ComponentName=CoreMotion%%20Fall%%20Detection&ComponentVersion=Tap-To-Radar&Attachments=%%2Fvar%%2Fmobile%%2FLibrary%%2Flocationd%%2FCMFallSnippetData-%i.log,%%2Fvar%%2Fmobile%%2FLibrary%%2Flocationd%%2FCMFallSnippetMeta-%i.json&Keywords=FallFalsePositive&AutoDiagnostics=watch&ComponentID=1076782
tap-to-radar://new?Title=T2R%%20Background%%20True%%20fall%%20detection&Description=This%%20is%%20auto%%20filled,%%20please%%20add%%20details&Classification=Serious%%20Bug&Reproducibility=Not%%20Applicable&ComponentName=CoreMotion%%20Fall%%20Detection&ComponentVersion=Tap-To-Radar&Attachments=%%2Fvar%%2Fmobile%%2FLibrary%%2Flocationd%%2FCMFallSnippetData-%i.log,%%2Fvar%%2Fmobile%%2FLibrary%%2Flocationd%%2FCMFallSnippetMeta-%i.json&Keywords=FallBackgroundTrueDetection&AutoDiagnostics=watch&ComponentID=1076782
tap-to-radar://new?Title=T2R%%20Background%%20False%%20fall%%20detection&Description=This%%20is%%20auto%%20filled,%%20please%%20add%%20details&Classification=Serious%%20Bug&Reproducibility=Not%%20Applicable&ComponentName=CoreMotion%%20Fall%%20Detection&ComponentVersion=Tap-To-Radar&Attachments=%%2Fvar%%2Fmobile%%2FLibrary%%2Flocationd%%2FCMFallSnippetData-%i.log,%%2Fvar%%2Fmobile%%2FLibrary%%2Flocationd%%2FCMFallSnippetMeta-%i.json&Keywords=FallBackgroundFalseDetection&AutoDiagnostics=watch&ComponentID=1076782
CLFallTap2Radar::trigger received default response
CLFallTap2Radar::trigger received alternate response for near fall.
CLFallTap2Radar::trigger received alternate response
CLFallTap2Radar::trigger received cancel response
wasEmergencyCallPlaced
isBackgroundDetected
isTruePositive
isFalsePositive
Collected Sensor Data
Your age, high-precision motion data (such as accel, gryo, odometer, raw pressure, wrist state, impact force, activity level, workout and navigation information) and heart rate data from up to 1 minute before and after the fall was detected, emergency call, and your response to this TTR will be sent with a sysdiagnose to the radar.
CLFallTap2Radar::trigger not opening tap2radar
std::optional<CLWifiService_Type::Channels> CLIWifiLocation5GHzChannelSelector::recommendedChannels()
@WifiChannel, receive channel %{public}d recommendation from 5GHz selector
void CLWifiLocation5GHzChannelTimeBasedSelector::updateAlsQueryTopChannels()
@WifiChannel, time-based 5GHz, query latest ALS channels %{public}s
virtual std::optional<CLWifiService_Type::Channels> CLWifiLocation5GHzChannelTimeBasedSelector::recommendedChannelsImpl()
@WifiChannel, time-based 5GHz, fill the extra %{public}d channel(s) from preset
@WifiChannel, time-based 5GHz, trim channel recommendation down to %{public}lu candidates
bool CLWifiLocation5GHzChannelTimeBasedSelector::resetTopChannelsBasedOnScanResult(const CL::Wifi1::Events::Wifi::Scan &)
@WifiChannel, time-based 5GHz, reset channel selector due to no APs
virtual std::optional<CLWifiLocationChannelSelectionService_Type::ChannelRecommendation> CLWifiLocation5GHzChannelSelectionService::recommendedChannels(CLWifiService_Type::ScanType)
@WifiChannel, apply, time-based 5GHz channel selector overrides, %{public}s
@WifiChannel, apply, default 5GHz channel selector overrides, %{public}s
rawCoordinateLatitude
rawCoordinateLongitude
LogBinaryPedometerCalibrationTables
RawSpeedToKValueTable
RawSpeed
KValue
-[CMPedometerTableRawSpeedToKValue logBins]_block_invoke
-[CMPedometerTableRawSpeedToKValue updateBinsWithTrack:]
%s,Updated,With,%s,%0.4f,%s,%0.4f,Alpha,%0.4f,%s
CLWifiScanner::CLWifiScanner(id<CLIntersiloUniverse>, std::shared_ptr<IWifiScanningStrategy>)
%s INITIAL isWifiPowered=%d
void CLWifiScanner::start()
%s Start monitor for active scanning
void CLWifiScanner::stop()
%s Stop monitor for active scanning
void CLWifiScanner::onTimerTriggered()
%s WIFI TIMER TRIGGERED
%s WIFI SCAN SETTINGS EMPTY, TIMER RACE?
void CLWifiScanner::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
%s WIFI POWER NOTIFICATION RECEIVED, power=%d nextFire=%f
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Utilities/CLWifiScanner.mm
%s WIFI IGNORING NOTIFICATION, cached=%d scantype=%d
void CLWifiScanner::scheduleNextScan(std::shared_ptr<WifiScanSettings>)
%s WIFI EXECUTING IMMEDIATELY, now=%f nextRequestTime=%f
%s WIFI SCAN SCHEDULED FOR %f
%s WIFI SCAN EFFECTIVELY NOT SCHEDULED
bool CLWifiScanner::requestScan(std::shared_ptr<WifiScanSettings>)
%s WIFI IS POWERED OFF - NOT ISSUING SCAN REQUEST
CLWifiScanner::onWifiNotification
{ScanParameters=iii{vector<int, std::allocator<int>>=^i^i{__compressed_pair<int *, std::allocator<int>>=^i}}{duration<long long, std::ratio<1, 1000>>=q}{duration<long long, std::ratio<1, 1>>=q}BB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}c}8@?0
virtual void CLOnBodyNotifier7::startOnBodyDetection()
Registering with Motion Coprocessor
virtual void CLOnBodyNotifier7::stopOnBodyDetection()
Unregistering with Motion Coprocessor
void CLOnBodyNotifier7::onMotionCoprocessorData(const CLMotionCoprocessorInterface::NotificationData *)
onBodyStatusData->onBodyStatus,%d,onBodyStatusData->confidence,%d,onBodyStatusData->timestamp,%f
CLOnBodyNotifier7::onMotionCoprocessorData
impactCanceledBecauseOfMaxAccelNorm
void CLFallImpactMetrics::processImpactCancelReason(CLFallImpactMetrics::ImpactContext &, CLFallImpactMetrics::ImpactCandidateEvent &, CLFallImpactMetrics::AlertCandidateEvent &, CLFallImpactMetrics::SOSCandidateEvent &) const
CLFallImpactMetrics: Setting %s for impact at %f
impactCanceledBecauseOfOtherHardThresholds
impactCanceledBecauseOfMultiPeaks
impactCanceledBecauseOfNaiveBayes
impactReplacedBecauseOfNewImpact
impactCanceledBecauseOfCyclingImpactThresholds
alertCanceledBecauseOfFFT
alertCanceledBecauseOfPeaksIQR
alertCanceledBecauseOfOffWristPre
alertCanceledBecauseOfOffWristPost
alertCanceledBecauseOfFeatureDisabled
alertCanceledBecauseOfOnCharger
alertCanceledBecauseOfAlreadyGatedBefore
alertCanceledBecauseOfLockedNoMotionBeforeImpact
alertCanceledBecauseOfReferee
alertCanceledBecauseStand
alertCanceledBecauseActive
alertCanceledBecauseSteps
sosCanceledBecauseUserResponse
sosCanceledBecauseOffWrist
sosCanceledBecauseStand
sosCanceledBecauseActive
sosCanceledBecauseSteps
sosCanceledBecauseAbsenceOfLongLie
sosCallConsidered
sosCallScheduled
sosCallPlaced
ResponseConfirmedActionRequested
void CLFallImpactMetrics::processUserResponse(CLFallImpactMetrics::SOSCandidateEvent &) const
CLFallImpactMetrics: Setting isUser%s for impact at %f
ResponseConfirmedNoActionRequested
ResponseDismissed
ResponseRejected
ResponseAutomaticActionRequested
virtual void CLFallImpactMetrics::sendEventToCoreAnalytics() const
CA - Events about to be created, isImpactCandidateEvent=%d, isAlertCandidateEvent=%d, isSOSCandidateEvent=%d
com.apple.CoreMotion.FallImpactCandidate
isFallImpact
isFallAlert
isSOSConsidered
isSOSCallPlaced
userCancelledSOS
algCancelledSOS
jerkVectorMagnitude
com.apple.CoreMotion.FallAlertCandidate
eventDuration
fallDistanceCentimeter
staticTimestampBeforePeak
staticTimestampAfterPeak
com.apple.CoreMotion.FallSOSCandidate
AutopauseRequiredDuration
static bool CLAutopauseCalculator::isLocationTypeSupported(CLLocationType)
Unknown whether or not provider %{public}d is a candidate for autopause
void CLAutopauseCalculator::aggregation(CLAutopauseCalculator::AggregateCoord &, const std::deque<CoordAndMotion> &)
PKAUTOPAUSE MEAN coord: %f %f %f %f %f %f %f %d %d 
ForceWatchToSubscribeToAltitudeUpdates
virtual void CLCompanionNotifierWatch::receiveCompanionMessage(CLCompanionNotifier_Type::Type, NSData *)
Received companion message,type,%d,size,%lu
#Warning error serializing OdometerCyclingData
#Warning error deserializing OdometerElevationData
#Warning error deserializing CoarseElevationData
#Warning error deserializing Absolute Altitude update
Watch received absolute altitude update, timestamp, %f, altitude, %f, accuracy %f, precision, %f, status, %d
kTypeKappaCollect dont collect
virtual bool CLCompanionNotifierWatch::registerForNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::RegistrationInfo &)
Registering for companion notification type %d
Last Overridden Session,%ld, Registration Info Overridden Session,%ld
virtual bool CLCompanionNotifierWatch::unregisterForNotification(int, const CLCompanionNotifier_Type::Notification &)
Unregistering for companion notification type %d
virtual void CLCompanionNotifierWatch::handleStateSyncTimerExpiry()
Sync state with Companion
void CLCompanionNotifierWatch::sendLastOverriddenSession() const
#Warning Error serializing session override (%ld): %s
void CLCompanionNotifierWatch::checkAndToggleSpectatorSubscriptions()
void CLCompanionNotifierWatch::toggleCoarseElevationSubscription(bool)
coarse elevation sub,enable,%d,transport,%d,subsCompleted,%d,unlockSinceBoot,%d,fitnessTracking,%d,numClients,%d
5GHzDefaultSelector
5GHzTimeBasedSelector
powerBudget
distanceThreshold
includePrivateData
com.apple.locationd.slc_configurer
kCLConnectionMessageSLCDistanceKey
kCLConnectionMessageSLCPowerBudgetKey
void CLSLCSubscription::sendSignificantLocationChange(const CLLocationProvider_Type::NotificationData &)
Sending #SLC <%{private}+.8f,%{private}+.8f> acc %{private}.2f for %{public}s
v24@?0d8d16
CLSLCSubscription::onSLCNotification
CLSLCSubscription::onFLNotification
fileHandle != nullptr
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLWifiTileParser.mm
parseWifiTile
fileHandle->isOpen()
Not enough data left to read block of size 
 in wifi tile: 
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MapMatching/CLGeoMapFeatureAccessGeometry.mm
CLGeoMapFeatureAccessGeometry
void CLGeoMapFeatureAccessGeometry::provideCacheHint(double, double, double)_block_invoke
#Warning CLMM,provideCacheHint reported error:%{public}lld (%{public}@) "%{private}@"
GEOMapFeatureRoad *CLGeoMapFeatureAccessGeometry::getGeoMapFeatureRoadObject(const CLMapRoadPtr &) const
#Warning CLMM, query failed (getGeoMapFeatureRoadObject)
#Warning CLMM, getGeoMapFeatureRoadObject, GEOMapFeatureRoad id,%{private}lld,has less than two coordinate,%{public}ld
%.1lf,getGeoMapFeatureRoadObject Unable to find roads
virtual bool CLGeoMapFeatureAccessGeometry::roadsWithinDistance(CLMapGeometry::DistanceQueryResultList &, const CLMapCrumb &, double, bool) const
#Warning CLMM, query failed (roadsWithinDistance)
#Warning CLMM, makeRoadFromGEOMapFeatureRoad returned nullptr
#Warning CLMM, interpolateOnRoad returned false
virtual bool CLGeoMapFeatureAccessGeometry::roadsAtIntersection(CLMapCrumb &, CLMapGeometry::IntersectionQueryResultList *, CLMapGeometry::IntersectionQueryResultList *, bool, const CLMapRoadPtr &, bool, double, double, double &) const
#Warning CLMM, input road is nullptr
virtual bool CLGeoMapFeatureAccessGeometry::roadsAtIntersection(CLMapCrumb &, CLMapGeometry::IntersectionQueryResultList *, CLMapGeometry::IntersectionQueryResultList *, bool, const CLMapRoadPtr &, bool, double, double, double &) const_block_invoke
v20@?0@"GEOMapFeatureRoad"8B16
#Warning CLMM, getGeoMapFeatureRoadObject returned nil
#Warning CLMM, outgoing roads query failed (roadsAtIntersection)
#Warning CLMM, incoming roads query failed (roadsAtIntersection)
bool CLGeoMapFeatureAccessGeometry::moveOnRoadInternal(double, double, const CLMapGeometry::RoadInfoList &, CLMapGeometry::DistanceQueryResult &, int) const
#Warning,CLMM, road length is 0.0
#Warning CLMM, GEOMapFeatureRoad id,%{private}lld,has less than two coordinate (moveOnRoadInternal),%{public}ld
#Warning CLMM, GEOMapFeatureRoad id,%{private}lld,startCoordinate is null,%{public}ld
CLMM, query failed (moveOnRoad)
#Warning CLMM,moveOnRoadInternal,interpolateProjections returned false
virtual bool CLGeoMapFeatureAccessGeometry::interpolateOnRoad(CLMapCrumb &, const CLMapRoadPtr &, bool, const double *, int) const
virtual bool CLGeoMapFeatureAccessGeometry::moveOnRouteRoads(double, CLMapGeometry::DistanceQueryResult &, CLMapGeometry::DistanceQueryResultList &, double, int &) const
#Warning,CLMM,input road is nullptr
#Warning,CLMM,GEOMapFeatureRoad id,%{private}lld,has less than two coordinate (moveOnRoadInternal),%{public}ld
CLMM,%.3lf, no more route roads available to cover the distance travelled,index,%d,size,%lu
CLMM,%.3lf, unexpectedly reached to the end of routeRoadList
cl_geo_access_map_feature_geometry_queue
void CLOutdoorCycleWorkoutStopDetector::setStopCounterUpdateRate(const CLWorkoutPredictorInputs &, const CLWorkoutPredictorInputs::Items &)
CLOutdoorCycleWorkoutStopDetector,cyclingSource,%f,%d
Failure to get cycling result, %f
OutdoorCycleStop,state,%d,hasGPS,%d,hasHR,%d,hr,%f,hrConf,%f,stopCounter,%f,fStopCounterUpdateRate,%f,hasTier1,%d,tier1Type,%d,percentNonCycleinBuffer,%f,percentModelTier1Concordant,%f,cyclieState,%d
bool CLOutdoorCycleWorkoutStopDetector::isLowHRExertion(const CLOutdoorCycleWorkoutStopDetector::ENoStepsNoSpeed *) const
OutdoorCycleStop,HRExertionCheck,hrExertion,%f,minHr,%f,maxHr,%f,shouldTransition,%d
VO2MaxMinPreviousEstimatesForHealthKitWrite
CLVO2MaxEstimator::CLVO2MaxEstimator(std::shared_ptr<CLVO2MaxInputCache>, CLVO2MaxEstimator::CacheInputs, std::shared_ptr<CLMaxMetsRecorderDb>, uint32_t)
VO2Max,fMinPreviousEstimatesForHealthKitWrite,%{private}d
void CLVO2MaxEstimator::aggregateHistory()
Beginning aggregation for VO2Max data
Aggregation of VO2Max data complete; input duration: %{public}f, output duration: %{public}f
std::pair<bool, VO2MaxSessionStats> CLVO2MaxEstimator::feedCalorieUpdate(CFAbsoluteTime, double, GradeType, double, bool, double, double, bool)
Completed insert of input record; duration: %{public}f
VO2MaxResult CLVO2MaxEstimator::feedWorkoutEvent(const CLMotionStateMediator_Type::WorkoutEvent &)
VO2Max,workoutEvent,%ld,workoutType,%ld
VO2MaxEstimationStatus CLVO2MaxEstimator::estimateVO2Max(CFAbsoluteTime, VO2MaxResult &)
VO2Max,Failure to estimate,status,%d,workout duration,%.3f,estimate,%f
void CLVO2MaxEstimator::retrocomputeVO2Max(CFAbsoluteTime, const std::vector<VO2MaxInput> &, const std::vector<VO2MaxSummary> &, const CLBodyMetrics &, double, double, CMWorkoutType, CLWorkoutSessionDetails::Type, VO2MaxRetrocomputeSessionResult &)
Will not retrocompute VO2Max due to absense of VO2MaxInputs, workoutEndTime:%{private}f
VO2MaxEstimationStatus CLVO2MaxEstimator::evaluateVO2MaxModel(VO2MaxResult &, std::vector<VO2MaxSummary> &, double &, VO2MaxOutput &, const std::vector<VO2MaxSummary> &, CFAbsoluteTime, double)
VO2Max,vo2MaxEstimationStatus,%{public}d,priorVO2Max,%{private}f,biasAdjustment,%{private}f,longitudinalVO2Max,%{private}f,sessionVO2Max,%{private}f
VO2Max,currentWorkoutType,%ld,hrmin,%f,hrmax,%f,outdoorPedestrianNumPairs,%lu,outdoorPedestrianStatus,%d,outdoorPedestrianSessionStatus,%d,outdoorPedestrianSessionVO2Max,%.5f,outdoorPedestrianEst,%.6f,adaptiveModelNumPairs,%lu,adaptiveModelStatus,%d, adaptiveModelSessionStatus,%d,adaptiveModelSessionVO2Max,%.5f,adaptiveModelEst,%f,adaptiveModelPrior,%f,betaBlockerUse,%d,longitudinalVO2Max,%f,sessionVO2Max,%f,isEscalation,%d,sessionDuration,%.5f,sessionType,%ld,escalationRatio,%f,finalStatus,%d,eligibleForHealthKit,%d,eligibleForCalorimetry,%d,numWorkoutsContrToEstimate,%u
double CLVO2MaxEstimator::getMeanMaxMets()
VO2Max,GetMeanMaxMets,canCalculateMeanMaxMets,%{private}s,meanMaxMets,%{private}.3f
void CLVO2MaxEstimator::evaluatePostSessionPeriod() const
VO2Max,SamplesPostSession,%{public}d,PostSessionDuration,%{public}f,startingHR,%{private}f,HRAfter60s,%{private}f,HRAfter120s,%{private}f
void CLVO2MaxEstimator::logSessionStats(double, VO2MaxEstimationStatus, CFAbsoluteTime)
VO2Max,pctHRSamplesValidMin,%d,pctHRSamplesValidMax,%d,pctHRSamplesWithRecentHR,%d,pctMETSamplesWithValidDelta,%d
VO2Max,longitudinalConsistency,%d,old,%f,new,%f
VO2Max,age,%.2f,biologicalSex,%d,useBetaBlocker,%d,userBMI,%.2f,vo2MaxMean,%.2f,vo2MaxPrior,%.2f,hrMaxObserved,%.2f,hrMaxAgePredicted,%.2f,hrMaxAgeAndMedicationPredicted,%.2f,hrMinBodyMetricsPredicted,%.2f,hrOnset,%.2f,hrRestingObservedOneDay,%.2f,hrRestingObservedSevenDays,%.2f,maxMetsMean,%.2f,maxMetsHigh,%.2f,vo2MaxValue,%.2f,vo2MaxValueAdaptiveModel,%.2f,vo2MaxValueOutdoorPedestrianModel,%.2f,vo2MaxValueOOB,%.2f,vo2MaxValueAdaptiveModelOOB,%.2f,vo2MaxValueOutdoorPedestrianModelOOB,%.2f,efficiency,%.2f,clustersHRMeanPedestrianModel,%.2f,clustersMetsMeanPedestrianModel,%.2f,clustersHRMeanAdaptiveModel,%.2f,clustersMetsMeanAdaptiveModel,%.2f,vo2MaxStDev,%.2f,vo2MaxTrend,%.2f,vo2MaxTrendSingleEst,%.2f,workoutTypeRatioWalk,%.2f,workoutTypeRatioRun,%.2f,workoutTypeRatioHike,%.2f,lookbackNumEstimates,%d,lookbackNumEstimatesAfterUpdate,%d,lookbackNumDaysWithEstimate,%d,lookbackEWMAPlusWeightedStDev,%.2f,numWorkoutsContrToLatestEstimate,%d,pctGPSAvailability,%.2f,pctHeartRateAvailability,%.2f,pctBackgroundEscalation,%.2f,pctHRMax,%.2f,pctHRMin,%.2f,validGradeMean,%.2f,validGradeStd,%.2f,pctGradeAboveAnalyticsThreshold,%.2f,workoutType,%d,sessionType,%d,sessionDuration,%.2f,hrMinSource,%d,vo2MaxEstimationStatus,%d,arbitrationState,%d,limitState,%d
int CLVO2MaxEstimator::getLookbackNumEstimatesAfterUpdate(CFAbsoluteTime, const std::vector<VO2MaxOutput> &) const
VO2Max,Analytics unexpectedly not able to retrieve a session record for the minimum algorithm version with startTime > %{public}.3f
double CLVO2MaxEstimator::getLookbackEWMAPlusWeightedStDev(const std::vector<VO2MaxOutput> &) const
VO2Max,weightedAvg,%{private}.3f,std,%{private}.3f
void CLVO2MaxEstimator::sendAnalytics(CLVO2MaxStats &)
VO2Max,Not sending analytics, no IHA permission
com.apple.CoreMotion.VO2Max.VO2MaxEstimate
useBetaBlocker
vo2MaxMean_bin
vo2MaxPrior_bin
hrMaxObserved
hrMaxAgePredicted
hrMaxAgeAndMedicationPredicted
hrMinBodyMetricsPredicted
hrOnset
hrRestingObservedOneDay
hrRestingObservedSevenDays
maxMetsMean
maxMetsHigh
vo2MaxValue
vo2MaxValueAdaptiveModel
vo2MaxValueOutdoorPedestrianModel
vo2MaxValueOOB
vo2MaxValueAdaptiveModelOOB
vo2MaxValueOutdoorPedestrianModelOOB
efficiency
clustersHRMeanAdaptiveModel
clustersMetsMeanAdaptiveModel
clustersHRMeanPedestrianModel
clustersMetsMeanPedestrianModel
vo2MaxStdDev
vo2MaxTrend
vo2MaxPriorDelta
vo2MaxTrendSingleEst
workoutTypeRatioWalk
workoutTypeRatioRun
workoutTypeRatioHike
lookbackNumEstimates_bin
lookbackNumEstimatesAfterUpdate_bin
lookbackNumDaysWithEstimate_bin
lookbackEWMAPlusWeightedStDev_bin
numWorkoutsContrToLatestEstimate_bin
vo2MaxValue_bin
pctGPSAvailability
pctHeartRateAvailability
pctBackgroundEscalation
pctHRMax
pctHRMin
validGradeMean
validGradeStd
pctGradeAboveAnalyticsThreshold
pctGPSAvailability_bin
pctHeartRateAvailability_bin
pctBackgroundEscalation_bin
pctHRMax_bin
pctHRMin_bin
sessionDuration_bin
hrMinSource
vo2MaxEstimationStatus
arbitrationDecision
cielFloorState
estimateWroteToDb
void CLVO2MaxPreprocessor::log(T &) [T = CLVO2MaxStats]
PreProcessor,PairStats,total,%d,warmup,%d,grade,%d,flat,%d,delta,%d,metsAboveMin,%d,gps,%d,stride,%d,distance,%d,source,%d,hrOK,%d,totalWorkoutLengthOK,%d,totalPaceOK,%d,totalStrollerOK,%d,totalPercentWalkingOK,%d,metsAboveAdaptiveMin,%d,totalGoodForClustering,%d,totalGoodForAdaptiveModel,%d,workoutStartTime,%f,workoutSessionType,%d
BarometerCalibrationBiasEstimationTrackPeriod
-[CLContextManagerBiasEstimationScheduler initWithUniverse:delegate:withBuffer:withSourceAggregator:]
Bias Scheduler Context created
-[CLContextManagerBiasEstimationScheduler sourceUpdated:]
New reference data, starting track, TrackStartTime %f, reference type %d
switched from location track to companion track at time %f
bias too stale, bias age %f, track length is %f
-[CLContextManagerBiasEstimationScheduler sendTrackAndScheduleNextTick:]
Calibration track with start time %f, end time %f will not be submitted because device was wet at %f
Calibration track submitted with start time %f, end time %f
-[CLContextManagerBiasEstimationScheduler wetStateUpdated:]
biasEstimationScheduler, lastWetTimestamp updated to %f
array::at
void CLStandPlusMinuteCalculator::feedBodyMetrics(const CLBodyMetrics &)
StandPlus,clearing buffers from body metrics,old,%{public}d,new,%{public}d
CLStandPlusMinute CLStandPlusMinuteCalculator::calculateStandPlusMinute()
StandPlus,minuteAwarded,startTime,%{public}f,endTime,%{public}f,totalMetTime,%{public}f,totalSteps,%{public}d,metConditionMet,%{public}d,stepConditionMet,%{public}d
Use the designated initializer
CLOdometerAlarmManager
CLPressureBiasSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/SensorCalibration/CLPressureBias.mm
-[CLPressureBiasAdapter beginService]
CLPressureBias
Bias
temp-compensation-table
void CLPressureBias::onDb(int, const CLPressureCalibrationDatabase_Type::Notification &, const CLPressureCalibrationDatabase_Type::NotificationData &)
Unexpected notification from pressure db.notification,%d
pressure-accel-sensitivity
CLPressureBias::onDb
virtual void CLNotifier<CLPressureBias_Type::Notification, CLPressureBias_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLPressureBias_Type::Notification, NotificationData_T = CLPressureBias_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLPressureBias_Type::Notification, CLPressureBias_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLPressureBias_Type::Notification, NotificationData_T = CLPressureBias_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
bool CLPressureBias::readFactoryData(const char *, const char *, T &) [T = CLNonlinearPrtt::Syscfg]
readFactoryData cannot be called without a node or a property
Cannot find pressure registry entry
Failed to create CFString from proprety
Cannot get %s property
%s property is not CFData
%s property too small
bool CLPressureBias::readFactoryData(const char *, const char *, T &) [T = CLPressureInertialCompensation::IORegType]
virtual void CLNotifier<CLPressureBias_Type::Notification, CLPressureBias_Type::NotificationData>::removeClient(int) [Notification_T = CLPressureBias_Type::Notification, NotificationData_T = CLPressureBias_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPressureBias_Type::Notification, CLPressureBias_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLPressureBias_Type::Notification, NotificationData_T = CLPressureBias_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPressureBias_Type::Notification, CLPressureBias_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLPressureBias_Type::Notification, NotificationData_T = CLPressureBias_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPressureBias_Type::Notification, CLPressureBias_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLPressureBias_Type::Notification, NotificationData_T = CLPressureBias_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLPressureBias_Type::Notification, CLPressureBias_Type::NotificationData>::listClients() [Notification_T = CLPressureBias_Type::Notification, NotificationData_T = CLPressureBias_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLMotionCoprocessor::updateMachToWallOffset()
Updating fMachToWallOffset %f, mach time %f, wall time %f, iohidtime %f
Unable to update fMachToWallOffset! %d
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Utilities/CLMotionCoprocessor.mm
issueUnknownMotionState
sendStrideParam
bool CLMotionCoprocessor::sendStrideParam(uint16_t)
Sending userParam: %d
!(fFeatures & Features::kInitialized)
setFeatures
void CLMotionCoprocessor::setFeatures(unsigned int, bool)
predictionInterval,%{public}f,ispUpdateInterval,%{public}f
Warning: dynamic bias estimation disabled!
Warning: manual gyro bias offset [%f %f %f] dps,error,%f
BaroWaterOccluded
finishConfiguration
fFeatures & Features::kInitialized
void CLMotionCoprocessor::finishConfiguration()
sendGyroBiasFitSync
void CLMotionCoprocessor::sendGyroBiasFitSync()
Send gyro bias fit sync
sendGyroBiasFit
hasFeature(Features::kGyroBiasFit)
bool CLMotionCoprocessor::sendGyroBiasFit()
GyroBiasFit,slope.x,%{public}f,.y,%{public}f.z,%{public}f,intercept.x,%{public}f,.y,%{public}f.z,%{public}f,lastMiniCal,%{public}f,hours,%{public}d
Decreasing proactive gyro bias estimation timeout for out of box.
NonlinearBiasFit,%{public}s
sendPressureBiasFitSync
void CLMotionCoprocessor::sendPressureBiasFitSync()
Send pressure bias fit sync
sendGmmDataSync
void CLMotionCoprocessor::sendGmmDataSync()
Send GMM data sync
void CLMotionCoprocessor::sendGmmDataSync()_block_invoke
Warning: No gmm data available
sendGmmData
hasFeature(Features::kCompass)
bool CLMotionCoprocessor::sendGmmData(const CLMotionTypeGeomagneticModelData &)
GeomagneticModelData.magnitude,%f
updateSidebandSensorFusion
void CLMotionCoprocessor::updateSidebandSensorFusion()
[SidebandSensorFusion] Feature not available.
[SidebandSensorFusion] configuring,enableCount,%{public}d,latencyCount,%{public}d,snoopCount,%{public}d
void CLMotionCoprocessor::setActivityOverrideUL(const CMMotionContext::ActivitySession, const CMMotionContext::CMHKWorkoutActivityType)
Setting activityOverride: when in activityType,%d, guarding against unexpected hkActivityType,%d 
Setting activityOverride: %d,hkActivityType,%d
CLMotionCoprocessor
CLMotionCoprocessor.AsyncQueue
SimulatedStepsPerHours
SimulatedStepCountDurationHours
KickOffGyroBiasFit
PressureTemperatureChangeSmallWindow
PressureTemperatureChangeMediumWindow
PressureTemperatureChangeLargeWindow
PressureTemperatureChangeStepsSmallWindow
PressureTemperatureChangeStepsMediumWindow
WaterDetectionAlert
FalseStepSuppressionHighWristRotationAlert
FalseStepSuppressionVehicleAlert
IgnoreGyroBiasFit
GyroNonlinearLogBiasFit
CLMotionCoprocessor::CLMotionCoprocessor(const char *, int, bool)
Proactive gyro calibration disabled.
proactiveRevistTime,%{public}d sec
Kick-Off gyro bias fit using 0-fit
[OscarEmuReplay] Started.
virtual CLMotionCoprocessor::~CLMotionCoprocessor()
[OscarEmuReplay] Stopped
bool CLMotionCoprocessor::setMotionStateYouthSim(bool, uint8_t)
motionstateupdate, calling setMotionStateYouthSim(%d, %hhu)
virtual void CLMotionCoprocessor::visitPong(const CMMotionCoprocessorReply::Pong *)
reply,%d
virtual void CLMotionCoprocessor::visitLog(const CMMotionCoprocessorReply::Log *)
Invalid CMMotionCoprocessorReply::Log structure.
MotionCoprocessor
virtual void CLMotionCoprocessor::visitMotionStateUpdate(const CMMotionCoprocessorReply::MotionStateUpdate *)
Type,%s,motionStateUpdate:Motion,%{public}d,conf,%{public}d,Mounted,%{public}d,MountedConf,%{public}d,exitState,%d,turn,%d,isVehicular,%d,isMoving,%d,seq,%d,motionTypeString,%s,startTime,%{public}f,timestamp,%f,startTimeUL,%lld,nowUL,%lld -- caltype,%d,vm,%f,standing,%d,machinefrequency,%f,strokefrequency,%f,strokeAmplitude,%f,strokepower,%f,meanAngleX,%f,pushVectorMagnitude,%f,rawMotionType,%{public}d,rawConf,%{public}d,rawMotionTypeString,%s,vehicularFlags:%{public}d,motionHint,%d,gpsHint,%d,basebandHint,%d,wifiHint,%d,btHint,%d,drivingStowedLikelihoodSum,%{public}f,drivingArmLikelihoodSum,%{public}f,ssLikelihoodSum,%{public}f,workoutDetectionType,%{public}d,workoutDetectionTime,%{public}f,vehicularConfidence,%{public}d,workoutDetectionTimeUL,%lld,workoutEscalationTime,%lld,MotionYouth,%{public}d,YouthClassificationReason,%{public}d,averageALSLux,%{public}d
After vehicular transition, startTime, %{public}f, rawMotionType, %{public}d, rawConfidence, %{public}d, mounted, %{public}d, mountedConfidence, %{public}d, drivingStowedLikelihoodSum, %{public}f, drivingArmLikelihoodSum, %{public}f, ssLikelihoodSum, %{public}f
virtual void CLMotionCoprocessor::visitStepCountUpdate(const CMMotionCoprocessorReply::StepCountUpdate *)
Timestamp,%f,StepCount,%d,Stride,%0.2f,Ascended,%d,Descended,%d,ElevationUp,%d,ElevationDown,%d,Pace,%f,ActiveTime,%f,DeltaSteps,%d,locationdGpsTime,%20.20f,startTime,%f,currentCadence,%f,FirstStepTime,%f,RelativeTimeOfLastStep,%d,FloorCountingSupported,%d,pedometerArmConstrainedState,%d,FlightState,%d,FlightFailResetUnknown,%d,FlightFailResetWater,%d,FlightFailResetFrozen,%d,FlightFailInOutTrans,%u,FlightFailElevDelta,%u,FlightFailStepsPerElevRate,%u,FlightsFailElevRate,%u,PressureAmplitude,%f,PressureTemperature,%hd,FalseStepDetectorAccelPoseXHigh,%u,FalseStepDetectorAccelVarXYZLow,%u,FalseStepDetectorGyroNumSamplesSufficient,%u,FalseStepDetectorGyroVarXHigh,%u,FalseStepDetectorConsecutiveRequirement,%u,IsVehicularLowConfidence,%u,IsVehicularHighConfidence,%u,FalseStepDetectorConsistentStepsProtection,%u,FalseStepsSuppressed,%u,AverageFilteredPressure,%f,StepCountCurrentlySimulated,%d,DefaultStepsPerHour,%i,DefaultStepDurationHours,%i
virtual void CLMotionCoprocessor::visitStepCountUpdate(const CMMotionCoprocessorReply::StepCountUpdate *)_block_invoke
CSLSStatusOverlayAssertion %sacquired
CSLSStatusOverlayAssertion invalidated
Assertion failed: fStatusBarAssertion, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Utilities/CLMotionCoprocessor.mm, line 1409,We should have created a status bar assertion first.
Time: %0.3f
If unexpected...
screen capture +
sysdiagnose
False Steps
Suppressed
Toggle fall detection status, %d
virtual void CLMotionCoprocessor::visitActivePedStateUpdate(const CMMotionCoprocessorReply::ActivePedStateUpdate *)
Timestamp,%.3f,StartTime,%.3f,ActivePedState,%u
virtual void CLMotionCoprocessor::visitAlarmTrigger(const CMMotionCoprocessorReply::AlarmTrigger *)
trigger,%d,duration,%lld
StepCountOverflow
ActivityQueueOverflow
SedentaryAlarm
UrgentCalRequired
SignificantElevationChange
SkiAlarm
WorkoutDetected
virtual void CLMotionCoprocessor::visitWakeReason(const CMMotionCoprocessorReply::WakeReason *)
MotionWakeReason,%u
(Frequent wakes are most likely caused by enabling AlwaysOnMotionSensorLogging!)
Unkown (
Received bad wake reason from motion coprocessor,reason,%d
OscarWakeReason
MotionWakeReason
virtual void CLMotionCoprocessor::visitOnBodyStatus(const CMMotionCoprocessorReply::OnBodyStatus *)
Type,CLOscar,onBodyStatus,%d,confidence,%d,timestamp,%f
virtual void CLMotionCoprocessor::visitGyroBiasData(const CMMotionCoprocessorReply::GyroBiasData *)
Enabled,%{public}d,Proactive,%{public}u,EndCondition,%{public}hhu,SampleInterval,%{public}d,Temperature,%{public}f,DynamicBias.x,%{public}.3e,.y,%{public}.3e,.z,%{public}.3e,Covariance.x,%{public}.3e,.y,%{public}.3e,.z,%{public}.3e
virtual void CLMotionCoprocessor::visitSedentaryAlarm(const CMMotionCoprocessorReply::SedentaryAlarm *)
Type,CLOscar,SedentaryAlarm:startTime,%f,firedTime,%f,type,%d,didWake,%d
virtual void CLMotionCoprocessor::visitStoredUserInfo(const CMMotionCoprocessorReply::StoredUserInfo *)
Received stored user info from SPU, gender, %d, height(m), %f, weight(kg), %f, vo2max, %f, age, %f, hrmin, %f, hrmax, %f, hronset, %f, pal, %f, condition, %d, runVo2max, %f,betaBlockerUse, %d, biologicalSex, %d, isAgeSet, %d, isHeightSet, %d, isWeightSet, %d, adaptiveExerciseMinuteThreshold, %f
virtual void CLMotionCoprocessor::visitUrgentMiniCal(const CMMotionCoprocessorReply::UrgentMiniCal *)
UrgentMiniCal requested
virtual void CLMotionCoprocessor::visitCoarseElevation(const CMMotionCoprocessorReply::CoarseElevation *)
Coarse elevation,startTime,%f,ascended,%d
<no name>
virtual void CLMotionCoprocessor::visitFirmwareVersion(const CMMotionCoprocessorReply::FirmwareVersion *)
uuid,%s,name,%s
virtual void CLMotionCoprocessor::visitBasebandSpeed(const CMMotionCoprocessorReply::BasebandSpeed *)
Baseband speed,timestamp,%f,startTime,%f,speedThreshold,0x%02hhx,speedRange,0x%02hhx,scaledValue,0x%02x,reserved,0x%02x,speedThresholdStr,%s,speedRangeStr,%s
virtual void CLMotionCoprocessor::visitSkiAlarm(const CMMotionCoprocessorReply::SkiAlarm *)
received SkiAlarm,timestamp,%f
virtual void CLMotionCoprocessor::visitHighResolutionImpactDataStart(const CMMotionCoprocessorReply::HighResolutionImpactDataStart *)
CLMotionCoprocessor::visitHighResolutionImpactDataStart
virtual void CLMotionCoprocessor::visitFlightSegment(const CMMotionCoprocessorReply::FlightSegment *)
visitFlightSegment,now,%{public}llu,start,%{public}llu,end,%{public}llu,rate,%{public}f,probability, %{public}f, elevationChange, %{public}f, regressionMad, %{public}f, isValid, %{public}d, hasAtLeast2mElevChange, %{public}d
virtual void CLMotionCoprocessor::visitKFFilteredPressure(const CMMotionCoprocessorReply::KFFilteredPressure *)
visitKFFilteredPressure nowAP %{public}f nowAOP %{public}llu filteredPressure %{public}f pressureTimestamp %{public}llu, kfElevation %{public}f wallTimePressureCorrected %{public}f wallTimeKFCorrected %{public}f
virtual void CLMotionCoprocessor::visitGyroEscalationState(const CMMotionCoprocessorReply::GyroEscalationState *)
visitGyroEscalationState, timestamp, %{public}f, AopTime, %{public}llu, totalGyroTimeInSec, %{public}f, sessionTimeInSec, %{public}f, isQuotaMet, %{public}d, numEscalations, %{public}u
virtual void CLMotionCoprocessor::visitTier1CyclingFeatures(const CMMotionCoprocessorReply::Tier1CyclingFeatures *)
visitTier1CyclingFeatures,startTime,%{public}f,isArmConstrained,%{public}d,accelXPowerSum,%{public}f,grav90th_100Hz,%{public}f,cyclingProbability,%{public}f,smoothCyclingProbability,%{public}f,roadNoise,%{public}f,pedEnergyVertical,%{public}f
virtual void CLMotionCoprocessor::setActivityAlarm(CMActivityAlarmTrigger, NSTimeInterval)
trigger,%u,duration,%f
virtual void CLMotionCoprocessor::setUserInfo(const CLBodyMetrics &)
Sending user info,fGender,%d,fHeightM,%f,fWeightKG,%f,fVo2Max,%f,fAge,%f,HRMin,%f,HRMax,%f,fHROnset,%f,fPal,%f,fCondition,%d,fRunVo2Max,%f,fBetaBlockerUse,%d,fBiologicalSex,%d,fIsBodyMetricSet,%d ,fAdaptiveExerciseMinuteThreshold,%f
virtual void CLMotionCoprocessor::setUserStrideLengthStepCadencePairWalk(const CLStrideLengthStepCadencePair &)
Sending user info + walk stride length step cadence pair
virtual void CLMotionCoprocessor::setVehicularData(const CLMotionStateUpdate &)
Sending isVehicular %{public}d, vehicularConfidence %{public}d
virtual void CLMotionCoprocessor::setActivityOverride(const CMMotionContext::ActivitySession, const CMMotionContext::CMHKWorkoutActivityType)
MotionStateObserver, Sending down ActivityOverride,session,%d,hkActivityType,%d
handler
setSedentaryAlarmHandler
virtual void CLMotionCoprocessor::setSedentaryAlarmHandler(CLSedentaryAlarmInterface::SedentaryAlarmHandler)
[SedentaryTimerTriage] SedentaryAlarm, setSedentaryAlarmHandler!
virtual void CLMotionCoprocessor::startSedentaryAlarm(const CLSedentaryAlarmParams &)
[SedentaryTimerTriage] SedentaryAlarm, startSedentaryAlarm!
configureOnBodyDetector
bool CLMotionCoprocessor::configureOnBodyDetector(NSDictionary *)
configuring on body detector
virtual void CLMotionCoprocessor::startStopGyroBiasAndVariance(const bool)
CLMotionCoprocessor %{public}s gyro bias and variance updates
virtual void CLMotionCoprocessor::resetTier1WorkoutDetector()
Sending command to reset workout detector.
virtual void CLMotionCoprocessor::updateAlternateEscalationParameters(const CLTier1WorkoutDetectionInterface::EscalationRules &)
Sending updated alternate escalation parameters to the AOP: lookbackTimeInSeconds,%hu,activeTimeInSeconds,%hu,activeSpeedInMPH,%f
Cannot update alternate escalation parameters: lookbackTimeInSeconds,%hu,activeTimeInSeconds,%hu,activeSpeedInMPH,%f
virtual void CLMotionCoprocessor::sendCyclingState(const CMMotionContext::CyclingStateDetectorMessage &)
Sending cycling state,%d
virtual void CLMotionCoprocessor::sendWorkoutPauseResumeTransition(const CMMotionContext::Transition &)
Sending workout pause/resume,%d
virtual void CLMotionCoprocessor::toggleTier1CyclingFeaturesUpdates(bool)
Toggle Tier1CyclingFeatures updates,%{public}d
virtual void CLMotionCoprocessor::sendSkiTransition(const CLSkiTransitions)
Sending ski transition %d
virtual void CLMotionCoprocessor::sendAltimeterCommand(const CLAltimeterInterface::CLAltimeterCommand)
Sending altimeter command to the AOP,%u
virtual void CLMotionCoprocessor::enableALSActiveScans(bool)
Sending update for ALS active scans to the AOP,shouldEnable,%d
B24@?0r^{SpeedData=Cfff}8r^{SpeedData=Cfff}16
sendGpsSpeed
GPS speed
Location derived speed
void CLMotionCoprocessor::sendGpsSpeed(const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
%s accepted, timestamp, %f, speed, %f, speedUnc, %f, speedSource, %d, ageOfEstimation, %f
void CLMotionCoprocessor::onFitnessTrackingNotification(const CLFitnessTrackingNotifier_Type::Notification &, const CLFitnessTrackingNotifier_Type::NotificationData &)
Youth Fitness Mode, %{public}d
void CLMotionCoprocessor::setIsVehicleConnected(bool)
isVehicleConnected,%d
void CLMotionCoprocessor::onVehicleConnection(const CLVehicleConnectionNotifier_Type::Notification &, const CLVehicleConnectionNotifier_Type::NotificationData &)
Received VehicleConnection notification,%d,startTime, %f,endTime,%f
void CLMotionCoprocessor::onPressureBias(int, const CLPressureBias_Type::Notification &, const CLPressureBias_Type::NotificationData &)
pressureBiasFit.fMedianTemperatureOffsetCoefficient,%f,pressureBiasFit.fMedToc_FactoryTemp,%f,fMaxTemp,%f
PressureInertialFit,compensationOnX,%f,compensationOnY,%f,compensationOnZ,%f
Unexpected CLPressureBias notification.notification,%d
void CLMotionCoprocessor::onDarwinNotification(const CLDarwinNotifier_Type::Notification &, const CLDarwinNotifier_Type::NotificationData &)
#Warning Unhandled notification %d.
void CLMotionCoprocessor::onInducedMotionNotification(const CLMotionState_Type::Notification &, const CLMotionState_Type::NotificationData &)
Unhandled notification from CLMotionState in CLMotionCoprocessor.
Sending induced motion: touch, %d, vibe, %d, sum, %d
void CLMotionCoprocessor::onPencilStateNotification(int, const CLPencilState_Type::Notification &, const CLPencilState_Type::NotificationData &)
Resetting compass on pencil state update, isAttached, %d
CLMotionCoprocessor::onPressureBias
CLMotionCoprocessor::onWatchOrientationSettingsNotification
CLMotionCoprocessor::onMotionStateMediatorNotification
CLMotionCoprocessor::onPencilStateNotification
-[CLOdometerAlarmManager handleLocationData:]
BATCH: received locations w/ odometer: %f, %f
#Warning BATCH: odometer ran from %f to %f
#Warning BATCH: Received a location (%s) without an odometer while odometer alarm was set
-[CLOdometerAlarmManager handleOdometerData:]
#Warning BATCH: odometer reset: %.2f
BATCH: received odometer: %f
void (anonymous namespace)::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &, void *)
BATCH: Should not be registered for location
BATCH: Unexpected notification: %{public}d
index < fNumEntries
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Utilities/CLBatchedLocations.cpp
assertNotOutOfBounds
workoutEvent
kDidStart
kDidStop
kWillPause
kWillResume
kSuggestedStart
kSuggestedStop
GOOD
std::tuple<double, double> CLIndoorOutdoorGPSModel::getGpsDeltaDistanceAndHeading(const CFAbsoluteTime) const
IndoorOutdoor[%d][gps-current],[A-%s],timestampGps,%f,odometer,%f,gpsHeadingRad,%f,accuracy,%f[B-%s],timestampGps,%f,odometer,%f,gpsHeadingRad,%f,accuracy,%f[interp],startTime,%f,gpsDistance,%f,gpsHeadingRad,%f
IndoorOutdoor[%d][gps-previous],[A-%s],timestampGps,%f,odometer,%f,gpsHeadingRad,%f,accuracy,%f,[B-%s],timestampGps,%f,odometer,%f,gpsHeadingRad,%f,accuracy,%f,[interp],startTime,%f,gpsDistance,%f,gpsHeadingRad,%f
CLIndoorOutdoorGPSModel::GpsModelResults CLIndoorOutdoorGPSModel::computeProbabilities()
IndoorOutdoor[%d][step],startTime,%f,stepCount,%u,stepDistance,%f,rawStepDistance,%f,
IndoorOutdoor[%d][turn-recv],startTime,%f,gyroHeadingRad,%f
IndoorOutdoor[%d][turn-none],requestedSampleTime,%f
IndoorOutdoor,GPSResult,stepDeltaDistance,%f,gpsDeltaDistance,%f,fResidScalar,%f,fIMUDistanceX,%f,fIMUDistanceY,%f,stepTimestamp,%f,fGpsState,%d,gpsDiscordanceProbability,%f,gpsDiscordanceRawProbability,%f,gpsDiscordance,%f,numValidDiscordanceSamples,%d,llrBufferSumProbability,%f
window0WithinRange
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Workout/Prediction/Algorithm/CLIndoorOutdoorGPSModel.mm
computeScalarDistanceFromFixedQueue
useResult == -1
calculateDirectionResiduals
void CLIndoorOutdoorGPSModel::processSamples(const double, const double, const double, const double, const double, const double, const CFAbsoluteTime, const uint32_t)
in-out-metrics,stepDeltaDistance,%f,gyroHeadingRadians,%f,gpsDeltaDistance,%f,gpsHeadingRadians,%f,bodySum,%f,fTurnEnv,%f,fGPSTurnEnv,%f,fResidScalar,%f,fIMUDistanceX,%f,fIMUDistanceY,%f,fGPSDistanceX,%f,fGPSDistanceY,%f,fGpsWanderLLRBufferSum,%f,fGpsLLRBufferSum,%f,fGpsFixBufferSum,%f,stepTimestamp,%f,fGpsState,%d
const T &CMQueue<int>::operator[](const size_t) const [T = int]
const T &CMQueue<CMVector<double, 2>>::operator[](const size_t) const [T = CMVector<double, 2>]
T CMQueue<double>::getComparison(int (*)(const T, const T), size_t) const [T = double]
const T &CMQueue<CLIndoorOutdoorGPSModel::GpsStepDistancePair>::operator[](const size_t) const [T = CLIndoorOutdoorGPSModel::GpsStepDistancePair]
CLPredictedWalkDistanceEstimate CLPredictedWalkDistanceEstimator::makeEstimate(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLPredictedWalkDistanceBoutEntry>, const std::vector<HealthKitQuantitySample> &, const std::vector<HealthKitQuantitySample> &, const std::vector<HealthKitQuantitySample> &, const std::vector<P6MWDHoursPerDay> &, std::vector<HealthKitWorkout>, const CLBodyMetrics &, double) const
Week,%.0f,Support,%lu,BaseConf,%.3f,Conf+,%.3f,Dist,%.1f,timeWithSteps,%.1f,steps,%d
Saw %d goodWalkWorkouts and %d days of data in current week, 1 workout or at least %.1f days required 
Saw %d days of data in last %d days, at least %.1f required, earliest day with watch use was %.1f
Week,%.0f,meanFlightsPerDay,%.3f,meanStepsPerDay,%.3f,meanExerciseMinutesPerDay,%.3f
pDist,%{private}.0f,pSpeed,%{private}.0f,pSpeed95,%{private}.0f,pActivity,%{private}.0f,maxBout,%{private}.0f,avgActiveTimeInSupport,%{private}.0f,maxRunningDist,%{private}.0f,p6MWD,%{private}.0f
pDist
maxDist
p6MWD based on %{public}s
No p6MWD estimate, insufficient time on wrist
No valid bouts for period ending %{public}.0f
No p6MWD estimate, no activity prediction
No p6MWD estimate, insufficient points for pSpeed
No p6MWD estimate, high uncertainty in speed prediction
No p6MWD estimate, inconsistent estimates
Available p6MWD estimate
Available p6MWD estimate because of workout
P6MWDUserCadences (anonymous namespace)::calculateCadences(const std::vector<CLPredictedWalkDistanceBoutEntry> &)
minCadenceForBouts,%.3f,minCadenceForWorkouts,%.3f,boutsUsed,%d
void (anonymous namespace)::logBouts(double, const std::vector<CLPredictedWalkDistanceBoutEntry> &)
Week,%.0f,boutStart,%.3f,boutEnd,%.3f,dist,%.3f,steps,%d,activeTime,%.3f,workoutType,%d,conf,%.3f,baseConf,%.3f,supportsBout,%.3f
CLDistributedSensingService
DistributedSensing/kCLConnectionMessageDistributedSensingVehicleStateUpdate
virtual CLMetsInfo CLCalorieSemiStatWheelchairModel::computeMETS(const CLNatalieModelInput &)
Semistationary, Wheelchair, %d, metsFromIntensity, %.1f, metsFromPosture, %.1f, userMetsFinal, %.1f, userMetsFromPushes, %.1f, computeTime, %.1f, truthMetsFinal, %.1f, truthMetsFromPushes, %.1f
void CMFiniteStateMachine::signal(uint8_t, const void *)
[FSM] %u,event,%u,transition,from,%u,to,%u
CLDEMTile-Mutex
virtual void CLDEMTile::clear()
CLBundleKeyValueCache
CLSystemService
CLHarvestableSystemService
CLIsFindMyiPhone
CLIsCoreRoutine
CLEmergencyService
CLRequiredCapabilities
kCMCalibrationTrackCodingKeyStart
kCMCalibrationTrackCodingKeyStop
kCMCalibrationTrackCodingKeyDistanceGps
kCMCalibrationTrackCodingKeyDistanceRawPed
kCMCalibrationTrackCodingKeySteps
kCMCalibrationTrackCodingKeyGpsSource
%@,TimeStart,%0.2f,TimeEnd,%0.2f,DistanceGps,%0.2f,DistanceRawPed,%0.2f,Steps,%0.2f,GpsSource,%ld
-[CalTrackFinder init]
initialize
-[CalTrackFinder stop]
CloseTrack,Stop
CL-GPS-UnfilteredMultipleSources
-[CalTrackFinder updateGpsLocationBuffer:gpsSource:]
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Speed,%0.3f,Course,%0.3f,Altitude,%0.3f,VerticalAccuracy,%0.3f,Timestamp,%0.3f,Source,%d
CloseTrack,GpsSourceChange,GpsSourceOld,%ld,GpsSourceNew,%ld
-[CalTrackFinder updateGpsOdometerBuffer:]
Suppressing duplicate GPS Odometer Entry from CalTrack %@
CL-GPS-Filtered
-[CalTrackFinder _filterGpsLocationBuffer]
-[CalTrackFinder _closeTrackCheckGpsLocation]
CloseTrack,GpsLocationEntryTimeOut,TimeSinceLastEntry,%0.2f
-[CalTrackFinder _closeTrackCheckGpsLocationFiltered]
CloseTrack,GpsFilteredHorizontalAccuracyOutOfBounds,HorizontalAccuracy,%0.2f
CloseTrack,GpsFilteredSpeedOutOfBounds,Speed,%0.2f
CloseTrack,NumSamplesMaxGpsFilteredLocation,NumSamples,%d
-[CalTrackFinder _closeTrackCheckGpsOdometer]
CloseTrack,GpsOdometerEntryTimeOut,TimeSinceLastEntry,%0.2f
CloseTrack,DistanceGpsRoughMax,DistanceGpsRough,%0.2f
CloseTrack,TimeSpanMax,Timespan,%0.2f
CloseTrack,NumSamplesMaxGpsOdometer,NumSamples,%d
-[CalTrackFinder _closeTrackCheckPedometer]
CloseTrack,PedometerEntryTimeOut,TimeSinceLastEntry,%0.2f
CloseTrack,NoStepsForTwoPedometerEntries
CloseTrack,PedometerSpeedCurrentZero
CloseTrack,PedometerSpeedCurrentJump,SpeedCurrentPrev,%0.2f,SpeedCurrent,%0.2f,SpeedCurrentJumpPercent,%0.2f
CloseTrack,PedometerArmConstrainedState,%d
CloseTrack,NumSamplesMaxPedometer,NumSamples,%d
-[CalTrackFinder _closeCurrentTrack]
CloseTrack,NumAdditionalPedometerEntriesRemoved,%ld
CloseTrack,TrackMetrics,TimeStartGpsLocationSegment,%0.2f,TimeEndGpsLocationSegment,%0.2f,%s
CloseTrack,Fail,DistanceGpsNotSufficient,DistanceGps,%0.2f
CloseCurrentTrack,Fail,GpsSpeedDiscrepancyDetected,SpeedGpsRawMean,%0.2f,GpsDistanceOverTime,%0.2f,SpeedErrorPercent,%0.2f
CloseTrack,Success
basalMETs
natalies
basalNatalies
bool CLOdometerQuality::cdfCalculator(const std::vector<unsigned int> &, const double &, std::vector<double> &)
noSamples < 1 || hist.empty()
void CLOdometerQuality::classifySamples(std::vector<double> &)
unexpected trained cdf data size issue
OdometerQualityIndicator,%d,r2,%f
void CMFilteredElevationStepHistory::update(const CMElevationSample &, const CMStepCountSample &)
fElevationBuffer timestamp did not move forward, timestamp, %llu
fStepHistory timestamp did not move forward, timestamp, %llu
float CMFilteredElevationStepHistory::elevationBufferMedian() const
Assertion failed: fElevationBuffer.size() > 2, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMFilteredElevationStepHistory.cpp, line 184,fElevationBufferSize,%zu.
T CMQueue<CMElevationSample>::getComparison(int (*)(const T, const T), size_t) const [T = CMElevationSample]
const T &CMQueue<CMElevationSample>::operator[](const size_t) const [T = CMElevationSample]
void CLWorkoutPredictorInputs::logLatestTimes(const std::string &, const std::vector<Type> &) const
logLatestTime for %s
Activity,lastTime,%f
Elevation,lastTime,%f
GPS,lastTime,%f
HR,lastTime,%f
Steps,lastTime,%f
Activity2,lastTime,%f
Activity2Smooth,lastTime,%f
Turns,lastTime,%f
ExtendedSteps,lastTime,%f
Swim,lastTime,%f
WatchPressure,lastTime,%f
CyclingState,lastTime,%f
Tier1CyclingFeatures,lastTime,%f
void CLWorkoutPredictorSourceBuffer<CLWorkoutClassifier_Type::CLWorkoutClassifierResult>::add(const T &) [T = CLWorkoutClassifier_Type::CLWorkoutClassifierResult]
void CLWorkoutPredictorSourceBuffer<CLCyclingStateDetector_Type::CyclingResult>::add(const T &) [T = CLCyclingStateDetector_Type::CyclingResult]
void CLWorkoutPredictorSourceBuffer<CLOdometerEntry>::add(const T &) [T = CLOdometerEntry]
void CLWorkoutPredictorSourceBuffer<CLMotionCoprocessorInterface::MotionState>::add(const T &) [T = CLMotionCoprocessorInterface::MotionState]
void CLWorkoutPredictorSourceBuffer<CLMotionCoprocessorInterface::MotionState>::update(CFAbsoluteTime) [T = CLMotionCoprocessorInterface::MotionState]
time rollback on update, currentTime, %f, lastUpdateTime, %f
void CLWorkoutPredictorSourceBuffer<CLElevationChangeEntry>::update(CFAbsoluteTime) [T = CLElevationChangeEntry]
void CLWorkoutPredictorSourceBuffer<CLCatherineData>::update(CFAbsoluteTime) [T = CLCatherineData]
void CLWorkoutPredictorSourceBuffer<CLOdometerEntry>::update(CFAbsoluteTime) [T = CLOdometerEntry]
void CLWorkoutPredictorSourceBuffer<CLStepCountEntry>::update(CFAbsoluteTime) [T = CLStepCountEntry]
void CLWorkoutPredictorSourceBuffer<CLExtendedStepCountEntry>::update(CFAbsoluteTime) [T = CLExtendedStepCountEntry]
void CLWorkoutPredictorSourceBuffer<CLWorkoutClassifier_Type::CLWorkoutClassifierResult>::update(CFAbsoluteTime) [T = CLWorkoutClassifier_Type::CLWorkoutClassifierResult]
void CLWorkoutPredictorSourceBuffer<CLWorkoutPredictorTurnDetector::Turn>::update(CFAbsoluteTime) [T = CLWorkoutPredictorTurnDetector::Turn]
void CLWorkoutPredictorSourceBuffer<CLSwimEntry>::update(CFAbsoluteTime) [T = CLSwimEntry]
void CLWorkoutPredictorSourceBuffer<CLWorkoutPredictorWatchPressure>::update(CFAbsoluteTime) [T = CLWorkoutPredictorWatchPressure]
void CLWorkoutPredictorSourceBuffer<CLExerciseMinuteData>::update(CFAbsoluteTime) [T = CLExerciseMinuteData]
void CLWorkoutPredictorSourceBuffer<CLCyclingStateDetector_Type::CyclingResult>::update(CFAbsoluteTime) [T = CLCyclingStateDetector_Type::CyclingResult]
void CLWorkoutPredictorSourceBuffer<CLMotionCoprocessorInterface::Tier1CyclingFeatures>::update(CFAbsoluteTime) [T = CLMotionCoprocessorInterface::Tier1CyclingFeatures]
kCLConnectionMessageHeading
VO2MaxStagingHistory
DELETE FROM VO2MaxStagingHistory WHERE sessionId = ?
void CLVO2MaxStagingOutputRecorderDb::deleteRecordsForSessionId(unsigned char *)
Deleting VO2MaxStagingHistory records from db where sessionId = %{public}s
ALTER TABLE VO2MaxStagingHistory ADD COLUMN 
UPDATE VO2MaxStagingHistory SET 
DELETE FROM VO2MaxStagingHistory
INSERT INTO VO2MaxStagingHistory (startTime, workoutType, estimatedVo2Max, durationInSeconds, hrMax, hrMin, sessionId, variance, filteredVo2Max, sessionType, eligibleForHealthKit, eligibleForCalorimetry, numWorkoutsContrToEstimate, estimatedHRResponseParam, estimatedHRRecoveryParam, algorithmVersion, sampleVersion, betaBlockerUse, bundleIdentifier, previousVo2Max) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SELECT * from VO2MaxStagingHistory ORDER BY startTime ASC
CMError CLVO2MaxStagingOutputRecorderDb::querySinceTime(CFAbsoluteTime, std::vector<VO2MaxStagingOutput> &) const
VO2MaxStagingHistory, DB not accessible
SELECT * FROM VO2MaxStagingHistory WHERE estimatedVo2Max IS NOT NULL AND startTime > ? ORDER BY startTime DESC
CMError CLVO2MaxStagingOutputRecorderDb::promoteStagingData() const
Promoting staging data
DELETE FROM VO2MaxHistory WHERE sessionId IN (SELECT sessionId from VO2MaxStagingSummaryHistory)
INSERT INTO VO2MaxHistory SELECT NULL, startTime, workoutType, estimatedVo2Max, durationInSeconds, hrMax, hrMin, sessionId, variance, filteredVo2Max, sessionType, eligibleForHealthKit, eligibleForCalorimetry, numWorkoutsContrToEstimate, estimatedHRResponseParam, estimatedHRRecoveryParam FROM VO2MaxStagingHistory
DELETE FROM VO2MaxSummaryHistory WHERE sessionId IN (SELECT sessionId from VO2MaxStagingSummaryHistory)
INSERT INTO VO2MaxSummaryHistory SELECT NULL, startTime, workoutType, sessionId, durationInSeconds, pointCount, hrMax, hrMin, meanHr, meanVo2, meanSpeed, meanGrade, meanHrConfidence, meanHrCadenceAgreement, meanCadence, vo2MaxModelSource, sessionType FROM VO2MaxStagingSummaryHistory
UPDATE VO2MaxSessionAttributesHistory AS sah SET algorithmVersion = (SELECT sh.algorithmVersion FROM VO2MaxStagingHistory AS sh WHERE sh.sessionId = sah.sessionId) WHERE sah.sessionId in (SELECT sh.sessionId FROM VO2MaxStagingSummaryHistory AS sh)
sampleVersion
bundleIdentifier
previousVo2Max
CLActivityRecorderDb<VO2MaxStagingOutput>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxStagingOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxStagingOutput>::setDatabaseAccessible() [T = VO2MaxStagingOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxStagingOutput>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxStagingOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxStagingOutput>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxStagingOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLTileDownloader::CLTileDownloader(CLTileDownloaderPolicy, CLITileDownloaderExternal *, CLTilesSetCollection *, CLTileDownloadPolicy *)
TileError, connectivity, current, %{public}d, neighbor, %{public}d
TileError, connectivity, neighbor, %{public}d, nonneighbor, %{public}d
TileQueue, %{public}s
bool CLTileDownloader::requestTiles(TileId, CFAbsoluteTime)
TileDl, preindexskip, request, #CloneMe
@TileQueue, usable, %{public}d, tileid, %{private}s
@TileQueue, onlist, tileid, %{private}s
@TileQueue, unreadable, %{public}d, tileid, %{private}s
@TileQueue, queue, 1
@TileQueue, skip, alreadyDownloaded, %{public}d, accessible, %{private}d, inqueue, %{public}d, locked, %{private}d
@TileDl, skipneighbor, %{private}.2lf, %{private}.2lf, locked, %{public}d, dled, %{public}d, pending, %{public}d, outbounds, %{public}d
void CLTileDownloader::addToDownloadList(std::unique_ptr<CLTileFile>, const TileId &, CFAbsoluteTime)
TileDl, preindexskip, addToDownloadList, #CloneMe
fDownloadList.find(tileId) == fDownloadList.end()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTileDownloader.mm
bool CLTileDownloader::areDownloadConditionsMet() const
@TileDl, skipall, first unlock
@TileDl, skipall, on connectivity
@TileDl, skipall, in progress
DlProgress
Refresh
bool CLTileDownloader::canRequestBasedOnAttempts(CLTileFile *, CFAbsoluteTime)
@TileReq, %{public}s, attempts, llsw, %{private}.2lf, %{private}.2lf, isDownload, %{public}d, lastSuccess, %{public}d, existsOnServer, %{public}d, sinceLastDownload, %{public}.1lf, path, %{public}s
void CLTileDownloader::checkAndMakeState(TileId, bool, const char *)
@TileError, %{public}s, nostate, %s, llsw, %{private}.2lf, %{private}.2lf, nlist, %{public}ld, nstate, %{public}lu
@TileDl, %{public}s, makestate, %s, llsw, %{private}.2lf, %{private}.2lf, nlist, %{public}ld, nstate, %{public}lu
TileId CLTileDownloader::downloadNextEligibleTile(CLFileDownload *, CLDaemonLocation, CFAbsoluteTime)
@TileDl, %{public}s, checkNextEligible, tilesToDownload, %{public}lu, tilesCanBeDownloaded, %{public}lu, ncurrent, %{public}d, connectivity, %{public}d, %{public}d, %{public}d, location, %{private}0.1f, %{private}0.1f, %{public}1.f
downloading
@TileReq, %{public}s, start, llsw, %{private}.2lf, %{private}.2lf, allowOverCellular, %{public}d, isCurrentTile, %{public}d, %{private}s
@TileDl, cell, skipall
completed
std::unique_ptr<CLTileFile> CLTileDownloader::downloadCompleted(TileId, bool, bool, CFAbsoluteTime)
@TileDl, %{public}s, completed, llsw, %{private}.2lf, %{private}.2lf, success, %{public}d, nlist, %{public}ld, nstate, %{public}lu, rtt, %{public}.1f
bool CLTileDownloader::shouldRefresh(CLTileFile *, CFAbsoluteTime)
TileDl, preindexskip, refresh, #CloneMe
@TileDl, checkRefresh, llsw, %{private}.2lf, %{private}.2lf, expired, %{public}d, onlist, %{public}d
void CLTileDownloader::deleteAgedDownloads(CFAbsoluteTime)
@TileQueue, deleteAged, startsize, %{public}lu
aged
TileQueue, %{public}s, reqage, llsw, %{private}.2lf, %{private}.2lf, age, %{public}0.1f, time, %{public}0.1f, size, %{public}lu
@TileQueue, deleteAged, %{public}d, endsize, %{public}lu
void CLTileDownloader::cancelAllDownloads()
@TileQueue, cancelAll, size, %lu
void CLTileDownloader::cleanupDownloadList(CFAbsoluteTime)
TileQueue, cleanupList, start, size, %{public}lu, thresh, %{public}d
@TileReq, %{public}s, keeplist, llsw, %{private}.2lf, %{private}.2lf, reasons, dl, %{public}d, retry, %{public}d, onserver, %{public}d, ondisc, %{public}d
TileQueue, cleanupList, done, size, %{public}lu, cleanedFiles, %{public}u
void CLTileDownloader::setReachability(CLDaemonStatus_Type::Reachability)
TileQueue, setReach, %{public}d
void CLTileDownloader::setLockState(bool)
TileQueue, firstUnlock
tileDownloaderPolicy
, currentRequirement, 
, neighborRequirement, 
, nonneighborRequirement, 
, slowCell, 
, redownloadLocked, 
, neighbors, 
, maxlist,
, maxage,
, cooloff, 
, refreshMultiplier, 
CLElevationRecorderDb
virtual long CLElevationRecorderDb::aggregateRecords(const CLAggregationRules &)
Programmer error, we expect an expiration record!
(silo != nullptr && handler != nullptr)||(silo == nullptr && handler == nullptr)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Elevation/CLElevationRecorderDb.mm
setFinishedInsertHandler
ElevationHistory
SELECT * FROM ElevationHistory WHERE ? <= startTime AND endTime <= ? ORDER BY startTime ASC
SELECT * FROM ElevationHistory ORDER BY startTime ASC
DELETE FROM ElevationHistory WHERE startTime < ?
DELETE FROM ElevationHistory
INSERT INTO ElevationHistory (startTime, endTime, elevationAscended, elevationDescended) VALUES (?, ?, ?, ?)
SELECT * FROM ElevationHistory ORDER BY startTime DESC LIMIT 1
UPDATE ElevationHistory SET startTime = startTime + ?, endTime = endTime + ?
virtual void CLElevationRecorderDb::prepareSQLStatements()
virtual void CLElevationRecorderDb::shiftRecordsByUL(CFTimeInterval)
Failed to shift records.
virtual void CLElevationRecorderDb::insertRecordUL(const CLSignificantElevation &, bool)
Error setting elevation offsets.
CLActivityRecorderDb<CLSignificantElevation>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLSignificantElevation>::setDatabaseAccessible() [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLSignificantElevation>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
ProactiveHarvest
ProactiveTimer
CLPolicyProactive.start
ProactiveBatteryLevel
void CLPolicyProactive::extendProactiveAttempt()
#proactive Extending proactive harvesting power assertion. Elapsed proactive time, %0.2f, minimum elapsed interval, %0.2f
!fProactiveHarvestPowerAssertion.isPowerAssertionTaken()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Harvester/Policies/Proactive/CLPolicyProactive.mm
extendProactiveAttempt
Extend
void CLPolicyProactive::proactiveHarvesting(bool)
#proactive Last attempted proactive harvesting %.3fs ago - waiting until %.3fs (%.3fs away) before trying again
proactiveHarvesting
#wigo,on,proactiveHarvest
#wigo,off,proactiveHarvest
virtual void CLPolicyProactive::updatePolicyProactiveFromGps(const CLDaemonLocation &)
#proactive Did not achieve vehicular speed from <%+.8f,%+.8f> in %.3fs, turning off proactive harvesting
virtual void CLPolicyProactive::updatePolicyFromBattery(const CLDaemonStatus_Type::Battery &)
#proactive battery criteria not achieved: battery level too low:required,%.2f,achieved,%.2f
#proactive battery criteria not achieved: battery level dropped: from,%.2f,to,%.2f
#proactive battery criteria achieved
virtual void CLPolicyProactive::updatePolicyFromTrafficTimer()
#proactive GPS timed out (last location <%+.8f,%+.8f> from %.3fs ago), turning off proactive harvesting
#proactive Proactive harvesting is not allowed, ignoring, onProactiveTimer
invalid
WalkingSpeed
DoubleSupportPercentage
StepLength
AsymmetryPercentage
left
right
gaitBout
stepBout
double CLMobility::calculateCV(const std::vector<double> &)
#warning: zero-mean coefficient of variance
bool CLMobility::isMeasurementInRange(CLBodyMetrics, double, CLMobility::QuantityTypeIdentifier)
BoutExtractor: Unexpected type %d, cannot determine ranges
BoutExtractor: Boutwise %{public}s above limit, ignoring (%{private}.3f)
BoutExtractor: Boutwise %{public}s below limit, ignoring (%{private}.3f)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/IO/CLIoHidFastPathDevice.mm
initializeFastPath
bool FastPathDevice::initializeFastPath(NSDictionary *)
[FastPath] Already initialized
[FastPath] Couldn't initialize FastPath due null service ref
[FastPath] Initialization failed,serviceRef,%@,properties,%@
virtual IOHIDEventRef FastPathDevice::copyEvent()
[FastPath] copyEvent Failed (%{public}x)
static std::unique_ptr<CLITileSyncManager> CLITileSyncManager::createProduction(CLWifiTilesManager *, id<CLIntersiloUniverse>, std::shared_ptr<CLWifiAccessPointLocationService>)
Instantiating CLTileSyncManager
Instantiating NoopTileSyncManager
-[CLKappaRecording start:]
Error opening recording %@
Error opening D recording
-[CLKappaRecording cleanup_unencrypted_files]
Could not remove D MSL, error: %@
-[CLKappaRecording beginSort]
Begin sorting (%{public}u, %{public}u, %{public}u, %{public}u, %{public}u) items
Failed to open MSL streams
-[CLKappaRecording sortToListener:]
channel %{public}u sorted timestamp went backward; %{public}llu < %{public}llu, prev %{public}u
Done sorting with (%{public}u, %{public}u, %{public}u, %{public}u, %{public}u) remaining
-[CLKappaRecording moveToCompletedDir:]
error completing recording error = %@
moving recording from %@ to %@
-[CLKappaRecording stopAndKeep:]
stopping a recording that has not been started; noop
Keeping MSL %@, %u B
Deleting MSL %@, %u B
Error removing MSL %@, error: %@
-[CLKappaRecording onRawAudioBatch:size:]
precondition violation: audio frame chopped up! nByte %u
-[CLKappaRecording onGPSItem:]
Dropping too early GPS item with AOP timestamp %llu
Dropping backward GPS item with AOP timestamp %llu
Kappa
CLHealthAssessmentTremorAvailableNotification
Health/kCLConnectionMessageVO2MaxInputsQuery
virtual void CLDaemonHealthClient::handleMessage(std::shared_ptr<CLConnectionMessage>)
bool CLDaemonHealthClient::isAuthorizedForMotionActivity()
com.apple.locationd.metminutes
bool CLDaemonHealthClient::isAuthorizedForMetMinutes(CMError &)
#Warning METMinutes,Client failed entitlement check, %s, %d, %p
void CLDaemonHealthClient::handleMessageMetMinutesQuery(std::shared_ptr<CLConnectionMessage>)
METMinutes,query,empty request
METMinutes,query,error,invalid parameter,%@
CLDaemonClient.MetMinutesQuery
void CLDaemonHealthClient::handleMessageMetMinutesQuery(std::shared_ptr<CLConnectionMessage>)_block_invoke
METMinutes,query,error,%{public}d
METMinutes,query,range,from,%.3f,to,%.3f,count,%lu,response,%@
v20@?0@"NSArray"8i16
com.apple.locationd.vo2max
bool CLDaemonHealthClient::isAuthorizedForVO2Max(CMError &)
VO2MaxData,Client failed entitlement check, %s, %d, %p
void CLDaemonHealthClient::handleMessageVO2MaxInputsQuery(std::shared_ptr<CLConnectionMessage>)
VO2MaxData,query,empty request
void CLDaemonHealthClient::handleMessageVO2MaxInputsQuery(std::shared_ptr<CLConnectionMessage>)_block_invoke
VO2MaxData,query,error,%{public}d
VO2MaxData,query,fromRecordId,%llu,count,%lu,response,%@
-[CLBarometerCalibrationSourceAggregator didUpdateSource:withData:]
companion source updated with timestamp %f, altitude %f, uncertainty %f
OnBodyStatusOverride
 overridden
void CLOnBodyDetectionSubscription::onOnBodyNotification(int, const CLOnBodyNotifier_Type::Notification &, const CLOnBodyNotifier_Type::NotificationData &)
Sent%s onBodyDetection message to %s, %s
com.apple.locationd.on_body_detection
bool CLOnBodyDetectionSubscription::isEntitledForOnBodyDetection()
#Warning Client %s does not have appropriate entitlement to access on body detection SPI
void CLOnBodyDetectionSubscription::handleRequestOnBodyDetection(bool, const CLNameValuePair &)
Received OnBodyDetection request,client,%s,subscribe,%d
void CLOnBodyDetectionSubscription::handleMessageOnBodyDetectionParams(std::shared_ptr<CLConnectionMessage>)
Wrong parameters were passed!
CLOnBodyDetectionSubscription::onOnBodyNotification
meanMaxMets
prior
hardwareType
betaBlockerUse
algorithmVersion
static float CLNatalieHeartRateModel::computeNormMETS(float, float)
HR,fhr,%{private}0.2f,userAge,%{private}0.2f,normalizedMets,%{private}0.2f
kCLConnectionMessageOdometerGpsAvailability
kCLConnectionMessageStartOdometerUpdate
kCLConnectionMessageCyclingWorkoutDistanceUpdate
void CLOdometerSubscription::onOdometerUpdate(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNotifier_Type::NotificationData &)
%@, %s, %p
void CLOdometerSubscription::onCyclingDistanceUpdate(const std::vector<CLOdometerEntry> &)
CyclingDistance, sent datums, %{public}lu, first, %{public}@, last, %{public}@
void CLOdometerSubscription::handleRequestOdometerGpsAvailability(bool, const CLNameValuePair &)
OdometerGpsAvailability subscription changed, %d, %s, %p
void CLOdometerSubscription::handleRequestOdometerUpdate(bool, const CLNameValuePair &)
Odometer subscription changed, %s, %p, %d
void CLOdometerSubscription::handleRequestCyclingWorkoutDistanceUpdate(bool, const CLNameValuePair &)
Cycling Workout Distance subscription changed, %s, %p, %d
CLOdometerSubscription::onOdometerUpdate
CLOdometerSubscription::onNatalimetryUpdate
deltaDistance
deltaDistanceAccuracy
timestampGps
slope
maxAbsSlope
groundAltitude
groundAltitudeUncertainty
virtual void CLKappaQualifierAlgZgResult::log()
[Zg] summary,%d,A,%hu,B,%hu,C,%f,D,%f,E,%f,F,%f,G,%f,H,%hd,I,%hu,J,%d,K,%d,L,%d,config-1,%f,config-2,%f
zg-A
zg-B
zg-C
zg-D
zg-E
zg-F
zg-G
zg-H
zg-I
zg-J
zg-K
zg-L
zg-config-1
zg-config-2
virtual void CLKappaQualifierAlgZgResult::recordCA(NSMutableDictionary *)
zg (%d, %d, %f, %f, %f, %f, %f, %d, %d, %f, %f, %f) (%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)
zg_A
zg_B
zg_C
zg_D
zg_E
zg_F
zg_G
zg_H
zg_I
zg_J
zg_K
zg_L
void CLKappaQualifierAlgZg::setConfig(const struct CLKappaQualifierAlgZgConfig &)
Zg config %f, %f
virtual void CLKappaQualifierAlgZg::reset()
[Zg] algorithm reset
newAccelSampleTime
preAccelSampleTime
virtual void CLKappaQualifierAlgZg::feedFastAccel(const CMMotionCoprocessorReply::KappaSensorDataFastAccel &)
Warning: fast accel timestamp is non-monotonic,%s,%llu,%s,%llu
newDmSampleTime
preDmSampleTime
virtual void CLKappaQualifierAlgZg::feedDM(const CMMotionCoprocessorReply::KappaSensorDataDeviceMotion &)
Warning: DM sample timestamp is non-monotonic,%s,%llu,%s,%llu
!fAngAccelQueue.isEmpty()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Kappa/CLKappaQualifierAlgZg.mm
queryGyroAndAngAccelIdx
void CLKappaZgHardwareProperties::setHardware(CLPlatformInfo::Hardware)
device parameters,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f
const T &CMQueue<CMMotionCoprocessorReply::KappaSensorDataFastAccel>::operator[](const size_t) const [T = CMMotionCoprocessorReply::KappaSensorDataFastAccel]
CLDigitalElevationModelSilo
bool CLDigitalElevationModel::CLDEMAltitudeFilter::update(const double, double, const double, const double, const double, double &, double &)
#Error,DEM,latitude_degs>90.0
#Error,DEM,latitude_degs<-90.0
#Error,DEM,heightDEM<-500
#Error,DEM,heightVariance<=0
#Warning,DEM,deltaT<0,DEM height filter internal_reset
#Warning,DEM,Height filter timed out,DEM height filter internal_reset
DEM,Height filter exceeded maximum change in horizontal position,DEM height filter internal_reset
cldem
bool CLDigitalElevationModel::isUseOfDemInappropriate() const
DEM,isUseOfDemInappropriate,true,fIsAirborne,%{public}d
DEM,isUseOfDemInappropriate,true,TBA,currentTime,%{public}.1lf,TBA machContinuousTime,%{public}.1lf,isCloseToOrAtTunnelBridge,%{public}d,lat,%{private}.8lf,lon,%{private}.8lf
static bool CLDigitalElevationModel::isLatLonOnCurrentTile(const CLDigitalElevationModel::CLDEMTile &, const double, const double)
#Warning,DEM,latitude,%{private}.7lf,out of range
static bool CLDigitalElevationModel::getAltitude(CLDigitalElevationModel::CLDEMTile &, double, double, double &, double &)
#Warning,DEM,current tile is not valid
#Warning,DEM,cellsize == 0
#Warning,DEM,latitude,%{private}.9lf,out of range
#Warning,DEM,latitude,%{private}.9lf,lessThanMin,%{private}.9lf
#Warning,DEM,latitude,%{private}.9lf,exceedsMax,%{private}.9lf
#Warning,DEM,longitude,%{private}.9lf,lessThanMin,%{private}.9lf
#Warning,DEM,longitude,%{private}.9lf,exceedsMax,%{private}.9lf
#Warning,DEM,longitude,%{private}.9lf,invalid,minLongitude,%{private}.9lf
#Warning,DEM,latitude,%{private}.9lf,invalid,minLatitude,%{private}.9lf
#Warning,DEM,longitude,%{private}.9lf,invalid,maxLongitude,%{private}.9lf
#Warning,DEM,latitude,%{private}.9lf,invalid,maxLatitude,%{private}.9lf
#Warning,DEM,invalidIndex,%{public}zu
#Warning,DEM,Reached unexpected case
#Warning,DEM,unexpected noData
bool CLDigitalElevationModel::updateSlopeAndUncertainty(GNSS::DaemonLocation &)
DEM,populateSlope,fail,lat,%{private}.8lf,lon,%{private}.8lf,testLocationLatDegs,%{private}.8lf,testLocationLonDegs,%{private}.8lf
DEM,populateSlope,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%.1lf,centerAltitude,%.1lf,daemonLocation.priv.groundAltitude,%.1lf
DEM,populateSlope,fail,lat,%{private}.6lf,lon,%{private}.6lf,testLatDegs,%{private}.6lf,testLonDegs,%{private}.6lf
bool CLDigitalElevationModel::getAltitude(GNSS::DaemonLocation &, CLDEMReliabilityIndication &, double &, const bool)
DEM,fForceDownloadDEMTiles, %d
#Error,DEM,invalidInput,timestamp,%{public}.1lf,lat,%{private}.8lf,lon,%{private}.8lf
DEM,not on the current in-memory tile,lat,%{private}.7lf,lon,%{private}.7lf,minLat,%{private}.7lf,maxLat,%{private}.7lf,minLon,%{private}.7lf,maxLon,%{private}.7lf
DEM,tile not available
DEM,Need to load tile
DEM,tile download needed
DEM,skipping loadTile query,skipCount,%{public}d
DEM,Tile not loaded yet
DEM,input location undulation,und,%{private}.3lf,model,%{public}d
DEM,update undulation,undOld,%{private}.3lf,undNew,%{private}.3lf,altOld,%{private}.3lf,altNew,%{private}.3lf,
DEM,Alt(m),%{private}.2lf,AltUnc(m),%{public}.2lf,filterAlt(m),%{private}.2lf,filterAltVariance(m^2),%{public}.2lf,RawDemAlt(m),%{private}.2lf,undulation,%{public}.3lf,slope,%{private}.3lf,maxAbsSlope,%{public}.3lf,lat,%{private}.8lf,lon,%{private}.8lf,type,%d
DEM,Alt(m),%{private}.2lf,AltUnc(m),%{public}.2lf,RawDemAlt(m),%{private}.2lf,undulation,%{public}.3lf,slope,%{private}.3lf,maxAbsSlope,%{public}.3lf,lat,%{private}.8lf,lon,%{private}.8lf,type,%d
bool CLDigitalElevationModel::loadTile(double, double, bool &)
DEM,loadTile,lat,%{private}.7lf,lon,%{private}.7lf
DEM,loadTile,CLTilesManager,getTileFile,took,%{public}.1lf
#Warning,Unexpected, this tile should be on disk,%{public}s
static bool CLDigitalElevationModel::calculateCLDEM_CRC(unsigned char *, const size_t, const size_t, unsigned int &)
#Error,DEM,indexCrcInBuffer,%zu,exceeds (bufferSize-4) bytes,%{public}zu
#Error,DEM,Unable to load %{public}s,errno,%{public}d
static bool CLDigitalElevationModel::readCLDEMTileHeaderHelper(FILE *, CLDigitalElevationModel::CLDEMTileFileHeader &, size_t &, size_t &)
#Error,DEM,fseek returned non-zero
#Error,DEM,Invalid CLDEM tile file - header string
#Error,DEM,Invalid CLDEM tile file - version
#Error,DEM,Invalid CLDEM tile file - headerLength
#Warning,DEM,header.dataSizeBytes != header.nrows*header.ncols
DEM,header,vers,%d,headerLen,%d,noDataValue,%d,importance,%d,overlapInPixels,%d,dataElementType,%d,compressionType,%d,expirationAge,%d,timestamp,%.1f,uncertainty_m,%.1f,nrows,%d,ncols,%d,dataSizeBytes,%d,crc,%d,xllcorner,%f,yllcorner,%f,cellsize,%f,maxalt,%f,minalt,%f,medianalt,%f,scaleFactor,%f,meanUndulation,%f
static bool CLDigitalElevationModel::readCLDEMTileFromFile(CLDigitalElevationModel::CLDEMTile &, const std::string &, bool &)
#Error,DEM,Invalid CLDEM tile file - file size does not match headerLength+dataSizeBytes
#Error,DEM,tile is larger than the allowed maximum
#Error,DEM,CLCommonSetFileProtectionClass,fail
#Error,DEM,can't open,%s,errno,%d
#Error,DEM,can't stat,%s,errno,%d
#Error,DEM,mmap,MAP_FAILED,errno,%d
DEM,mmapDem,%s,size,%lld,regfile,%d,m,%p,size,%lu
#Error,mmap failed
#Warning,DEM,calculateCLDEM_CRC returned false unexpectedly
#Error,DEM,Invalid CLDEM,crc fail,calculated,%X,received,%X
DEM,Reading,%{public}s
void CLDigitalElevationModel::onAvlFileUpdated(CLFileUpdate *, CLFileUpdate::UpdateStatus)
DEM,avl download status,NONE
DEM,avl download status,STARTED
DEM,avl download status,COMPLETED
DEM,avl downloaded,%{public}s
#Warning,DEM,Cannot set protection class for DEM avl file,%{public}s
DEM,avl file decompressed,%{public}s,to,%{public}s
#Warning,DEM,Cannot set protection class for DEM decompressed avl file,%{public}s
DEM,is availability file valid,%{public}d
#Warning,DEM,avl download status,FAILED
#Warning,DEM,avl download request failed,%{public}s,retryMultiplier,%{public}d
#Warning,DEM,avl download status,%{public}d
void CLDigitalElevationModel::downloadIfNeeded(const CLDaemonLocation &, const bool, const bool)
DEM,requestDownload, Requesting DEM Tile download,lat,%{private}.7lf,lon,%{private}.7lf
DEM,allowing download request over cell due to poor GNSS signal conditions
DEM,allowing download request over cell due to activity,%d
DemAvlFileUpdatePeriodOverWifi
CFTimeInterval CLDigitalElevationModel::getAvlFileDownloadRateOverWifi() const
DEM,DemAvlFileUpdatePeriodOverWifi,%{public}.1lf
#Warning,DEM,given avl update rate over WiFi is invalid,%{public}.1lf,using default value instead
DemAvlFileUpdatePeriodOverCell
CFTimeInterval CLDigitalElevationModel::getAvlFileDownloadRateOverCell() const
DEM,DemAvlFileUpdatePeriodOverCell,%{public}.1lf
#Warning,DEM,given avl update rate over Cell is invalid,%{public}.1lf,using default value instead
void CLDigitalElevationModel::downloadAvailabilityFile(const CFAbsoluteTime &)
DEM, server, %{public}s, overridden, 1
DEM, server, %{public}s, overridden, 0
DEM,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf
#Warning,DEM,could not setUpdateSource AVL file updater
#Warning,DEM,could not setUpdateRate AVl file updater
void CLDigitalElevationModel::onManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
Notification,%{public}d
CLDigitalElevationModel::onAvlFileUpdated
cldavl.avl.gz
CLDigitalElevationModel::onManagerNotification
MicroLocationsMaintenanceInterval
MicroLocationsAnalyticsInterval
MicroLocationsLearningInterval
MicroLocationsPowerLogInterval
MicroLocationMaintenance
void (anonymous namespace)::registerActivity(const CLMicroLocationXPCActivityHelpers::XPCCriteria &, CLMicroLocationBackgroundActivities::IBackgroundActivitiesDelegate &, std::vector<std::unique_ptr<XPCRegistration>> &, std::optional<ObserverRegistrationFunction>, RunActivity) [WorkT = CLMicroLocationMaintenance, RunActivity = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.mm:101:15)]
Registering for XPC Activity %s
Attempting to run %s but Microlocations are disabled.
CLMicroLocationBackgroundActivities::ActivityRunner<CLMicroLocationXPCActivityHelpers::XPCActivity, CLMicroLocationMaintenance>::~ActivityRunner() [ActivityT = CLMicroLocationXPCActivityHelpers::XPCActivity, WorkT = CLMicroLocationMaintenance]
#Warning Activity runner: Activity didn't complete before the runner was destroyed. Most likely this means there was an exception during the activity. Please check the logs.
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.h
MicroLocationAnalytics
void (anonymous namespace)::registerActivity(const CLMicroLocationXPCActivityHelpers::XPCCriteria &, CLMicroLocationBackgroundActivities::IBackgroundActivitiesDelegate &, std::vector<std::unique_ptr<XPCRegistration>> &, std::optional<ObserverRegistrationFunction>, RunActivity) [WorkT = CLMicroLocationAnalytics, RunActivity = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.mm:119:16)]
auto (anonymous namespace)::registerActivity(const CLMicroLocationXPCActivityHelpers::XPCCriteria &, CLMicroLocationBackgroundActivities::IBackgroundActivitiesDelegate &, std::vector<std::unique_ptr<XPCRegistration>> &, std::optional<ObserverRegistrationFunction>, (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.mm:119:16))::(anonymous class)::operator()(CLMicroLocationXPCActivityHelpers::XPCActivity)::(anonymous class)::operator()()
CLMicroLocationBackgroundActivities::ActivityRunner<CLMicroLocationXPCActivityHelpers::XPCActivity, CLMicroLocationAnalytics>::~ActivityRunner() [ActivityT = CLMicroLocationXPCActivityHelpers::XPCActivity, WorkT = CLMicroLocationAnalytics]
MicroLocationLearning
void (anonymous namespace)::registerActivity(const CLMicroLocationXPCActivityHelpers::XPCCriteria &, CLMicroLocationBackgroundActivities::IBackgroundActivitiesDelegate &, std::vector<std::unique_ptr<XPCRegistration>> &, std::optional<ObserverRegistrationFunction>, RunActivity) [WorkT = CLMicroLocationLearner, RunActivity = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.mm:139:14)]
auto (anonymous namespace)::registerActivity(const CLMicroLocationXPCActivityHelpers::XPCCriteria &, CLMicroLocationBackgroundActivities::IBackgroundActivitiesDelegate &, std::vector<std::unique_ptr<XPCRegistration>> &, std::optional<ObserverRegistrationFunction>, (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.mm:139:14))::(anonymous class)::operator()(CLMicroLocationXPCActivityHelpers::XPCActivity)::(anonymous class)::operator()()
CLMicroLocationBackgroundActivities::ActivityRunner<CLMicroLocationXPCActivityHelpers::XPCActivity, CLMicroLocationLearner>::~ActivityRunner() [ActivityT = CLMicroLocationXPCActivityHelpers::XPCActivity, WorkT = CLMicroLocationLearner]
MicroLocationPowerLog
void (anonymous namespace)::registerActivity(const CLMicroLocationXPCActivityHelpers::XPCCriteria &, CLMicroLocationBackgroundActivities::IBackgroundActivitiesDelegate &, std::vector<std::unique_ptr<XPCRegistration>> &, std::optional<ObserverRegistrationFunction>, RunActivity) [WorkT = CLMicroLocationPowerLog, RunActivity = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.mm:157:15)]
auto (anonymous namespace)::registerActivity(const CLMicroLocationXPCActivityHelpers::XPCCriteria &, CLMicroLocationBackgroundActivities::IBackgroundActivitiesDelegate &, std::vector<std::unique_ptr<XPCRegistration>> &, std::optional<ObserverRegistrationFunction>, (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MicroLocation/CLMicroLocationBackgroundActivities.mm:157:15))::(anonymous class)::operator()(CLMicroLocationXPCActivityHelpers::XPCActivity)::(anonymous class)::operator()()
CLMicroLocationBackgroundActivities::ActivityRunner<CLMicroLocationXPCActivityHelpers::XPCActivity, CLMicroLocationPowerLog>::~ActivityRunner() [ActivityT = CLMicroLocationXPCActivityHelpers::XPCActivity, WorkT = CLMicroLocationPowerLog]
CLVehicleConnectionNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Vehicle/CLVehicleConnectionNotifier.mm
-[CLVehicleConnectionNotifierAdapter beginService]
CLVehicleConnectionNotifier::CLVehicleConnectionNotifier(id<CLIntersiloUniverse>)
CLVehicleConnectionNotifier is being constructed
CLStarkManager
CLVehicleConnectionNotifier::CLVehicleConnectionNotifier(id<CLIntersiloUniverse>)_block_invoke
#fmc CarKit connection status, %{public}d
v20@?0B8@"NSString"12
virtual CLVehicleConnectionNotifier::~CLVehicleConnectionNotifier()
CLVehicleConnectionNotifier is shutting down
void CLVehicleConnectionNotifier::setCarKitConnectionStatus(CLVehicleConnectionNotifier::ConnectionStatus, NSString *)
CarKitConnectionStatus,%d,HandsfreeConnectionStatus,%d,current VehicleConnectionStatus,%d
void CLVehicleConnectionNotifier::postVehicleExitNotification()
#fmc Posting notification upon vehicle exit
#fmc startTime,%f,endTime,%f,exitTime,%f
bool CLVehicleConnectionNotifier::setVehicleConnectionStatus(CLVehicleConnectionNotifier::ConnectionStatus, CLVehicleConnectionNotifier::ConnectionStatus, NSString *)
CarKitConnectionStatus,%d,HandsfreeConnectionStatus,%d,current VehicleConnectionStatus,%d,new VehicleConnectionStatus,%d
CLVehicleConnectionNotifier::onBluetoothNotification
CLVehicleConnectionNotifier::onMotionStateNotification
LastVehicleConnection
virtual void CLNotifier<CLVehicleConnectionNotifier_Type::Notification, CLVehicleConnectionNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLVehicleConnectionNotifier_Type::Notification, NotificationData_T = CLVehicleConnectionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLVehicleConnectionNotifier_Type::Notification, CLVehicleConnectionNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLVehicleConnectionNotifier_Type::Notification, NotificationData_T = CLVehicleConnectionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLVehicleConnectionNotifier_Type::Notification, CLVehicleConnectionNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLVehicleConnectionNotifier_Type::Notification, NotificationData_T = CLVehicleConnectionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLVehicleConnectionNotifier_Type::Notification, CLVehicleConnectionNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLVehicleConnectionNotifier_Type::Notification, NotificationData_T = CLVehicleConnectionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLVehicleConnectionNotifier_Type::Notification, CLVehicleConnectionNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLVehicleConnectionNotifier_Type::Notification, NotificationData_T = CLVehicleConnectionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLVehicleConnectionNotifier_Type::Notification, CLVehicleConnectionNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLVehicleConnectionNotifier_Type::Notification, NotificationData_T = CLVehicleConnectionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLVehicleConnectionNotifier_Type::Notification, CLVehicleConnectionNotifier_Type::NotificationData>::listClients() [Notification_T = CLVehicleConnectionNotifier_Type::Notification, NotificationData_T = CLVehicleConnectionNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
double CLDistanceCalc::calculateDistance(const CLDaemonLocation &, const CLDaemonLocation &)
#Warning refAlt < %.1lf,refAlt,%.1lf,using the min
#Warning refAlt > %.1lf,refAlt,%.1lf,using the max
bool CLDistanceCalc::calc_dNdE(double, double, double &, double &)
latitude,%.7lf,is out of bounds
double CLDistanceCalc::calculateAzimuth(double, double, double, double)
#Warning, same coordinates input
CLMotionSyncStoreSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/MotionSync/CLMotionSyncStore.mm
-[CLMotionSyncStoreAdapter beginService]
-[CLMotionSyncStoreAdapter resetStoredCalibrations]
#Notice Calibrations were successfully cleared.
DebugMotionSync
CLMotionSyncStore::CLMotionSyncStore(id<CLIntersiloUniverse>)_block_invoke
Forcing a raw speed to kValue bins update.
Forcing a step cadence to stride length bins update.
void CLMotionSyncStore::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
Received CLDataProtectionManager_Type %d, data availability %d
CalibrationVersion,
CalibrationUDID,
CalibrationTimestamp,
CMNatalimeterSetUserPal,
CMNatalimeterSetUserVo2max,
CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold,
RawSpeedToKValueTable,
avail
StepCadenceToStrideLengthTable,
CalibrationResetRequested,
CalibrationResetRequested
HasSavedInitialMotionCalsToDisk,
HasSavedInitialMotionCalsToDisk
CalibrationUDID
unset
static void CLMotionSyncStore::setCurrentVersion(NSMutableDictionary *, int)
Setting the current Motion Cals version to, %d
CalibrationVersion
CalibrationTimestamp
static NSMutableArray<CMPedometerBin *> *CLMotionSyncStore::securelyUnarchivePedometerData(NSData *)
Unable to decode pedometer data: %{public}@
CLMotionSyncStore::onDataProtectionNotification
MotionSync
virtual void CLNotifier<CLMotionSyncStore_Type::Notification, CLMotionSyncStore_Type::NotificationData>::removeClient(int) [Notification_T = CLMotionSyncStore_Type::Notification, NotificationData_T = CLMotionSyncStore_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionSyncStore_Type::Notification, CLMotionSyncStore_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMotionSyncStore_Type::Notification, NotificationData_T = CLMotionSyncStore_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionSyncStore_Type::Notification, CLMotionSyncStore_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLMotionSyncStore_Type::Notification, NotificationData_T = CLMotionSyncStore_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionSyncStore_Type::Notification, CLMotionSyncStore_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMotionSyncStore_Type::Notification, NotificationData_T = CLMotionSyncStore_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionSyncStore_Type::Notification, CLMotionSyncStore_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLMotionSyncStore_Type::Notification, NotificationData_T = CLMotionSyncStore_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLMotionSyncStore_Type::Notification, CLMotionSyncStore_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMotionSyncStore_Type::Notification, NotificationData_T = CLMotionSyncStore_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionSyncStore_Type::Notification, CLMotionSyncStore_Type::NotificationData>::listClients() [Notification_T = CLMotionSyncStore_Type::Notification, NotificationData_T = CLMotionSyncStore_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLLocationAwarenessProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Awareness/CLLocationAwarenessProvider.mm
-[CLLocationAwarenessProviderAdapter beginService]
CLLocationAwarenessProvider
SettledLatencyBudget
UnsettledLatencyBudget
SettledRetryRate
UnsettledRetryRate
SettledQueryALS
UnsettledQueryALS
Awareness
AwarenessMinimumTimerChange
AwarenessEarlyFireSlop
Active location session has begun
awareness
CLLocationAwarenessProvider::onWakeTimer
CLLocationAwarenessProvider::onWifiNotification
CLLocationAwarenessProvider::onLocationNotification
CLLocationAwarenessProvider::onClientManagerNotification
virtual bool CLNotifier<CLLocationAwarenessProvider_Type::Notification, CLLocationAwarenessProvider_Type::NotificationData, char, CLLocationAwarenessProvider_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLLocationAwarenessProvider_Type::Notification, NotificationData_T = CLLocationAwarenessProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationAwarenessProvider_Type::RegInfo]
virtual bool CLNotifier<CLLocationAwarenessProvider_Type::Notification, CLLocationAwarenessProvider_Type::NotificationData, char, CLLocationAwarenessProvider_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLLocationAwarenessProvider_Type::Notification, NotificationData_T = CLLocationAwarenessProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationAwarenessProvider_Type::RegInfo]
virtual void CLNotifier<CLLocationAwarenessProvider_Type::Notification, CLLocationAwarenessProvider_Type::NotificationData, char, CLLocationAwarenessProvider_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLLocationAwarenessProvider_Type::Notification, NotificationData_T = CLLocationAwarenessProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationAwarenessProvider_Type::RegInfo]
void CLNotifier<CLLocationAwarenessProvider_Type::Notification, CLLocationAwarenessProvider_Type::NotificationData, char, CLLocationAwarenessProvider_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLLocationAwarenessProvider_Type::Notification, NotificationData_T = CLLocationAwarenessProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationAwarenessProvider_Type::RegInfo]
virtual void CLNotifier<CLLocationAwarenessProvider_Type::Notification, CLLocationAwarenessProvider_Type::NotificationData, char, CLLocationAwarenessProvider_Type::RegInfo>::removeClient(int) [Notification_T = CLLocationAwarenessProvider_Type::Notification, NotificationData_T = CLLocationAwarenessProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationAwarenessProvider_Type::RegInfo]
virtual bool CLNotifier<CLLocationAwarenessProvider_Type::Notification, CLLocationAwarenessProvider_Type::NotificationData, char, CLLocationAwarenessProvider_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLLocationAwarenessProvider_Type::Notification, NotificationData_T = CLLocationAwarenessProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationAwarenessProvider_Type::RegInfo]
virtual void CLNotifier<CLLocationAwarenessProvider_Type::Notification, CLLocationAwarenessProvider_Type::NotificationData, char, CLLocationAwarenessProvider_Type::RegInfo>::listClients() [Notification_T = CLLocationAwarenessProvider_Type::Notification, NotificationData_T = CLLocationAwarenessProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationAwarenessProvider_Type::RegInfo]
CLFitnessMachineNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/FitnessMachine/CLFitnessMachineNotifier.mm
-[CLFitnessMachineNotifierAdapter beginService]
CLFitnessMachineNotifier::onMotionStateMediatorNotification
virtual void CLNotifier<CLFitnessMachineNotifier_Type::Notification, CLFitnessMachineNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLFitnessMachineNotifier_Type::Notification, NotificationData_T = CLFitnessMachineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLFitnessMachineNotifier_Type::Notification, CLFitnessMachineNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLFitnessMachineNotifier_Type::Notification, NotificationData_T = CLFitnessMachineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFitnessMachineNotifier_Type::Notification, CLFitnessMachineNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLFitnessMachineNotifier_Type::Notification, NotificationData_T = CLFitnessMachineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFitnessMachineNotifier_Type::Notification, CLFitnessMachineNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFitnessMachineNotifier_Type::Notification, NotificationData_T = CLFitnessMachineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFitnessMachineNotifier_Type::Notification, CLFitnessMachineNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLFitnessMachineNotifier_Type::Notification, NotificationData_T = CLFitnessMachineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLFitnessMachineNotifier_Type::Notification, CLFitnessMachineNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLFitnessMachineNotifier_Type::Notification, NotificationData_T = CLFitnessMachineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLFitnessMachineNotifier_Type::Notification, CLFitnessMachineNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLFitnessMachineNotifier_Type::Notification, NotificationData_T = CLFitnessMachineNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
static CLMapGeometryPtr CLMapGeometry::create(const std::string &)
CLMapGeometryPtr
void CLMapGeometry::logMapsAPICallCount() const
CLMM,%{public}.1lf,MapsAPICallCount,%{public}d
virtual CLMotionActivity::TypeYouth CLFitnessYouthElevationCreditOverride::doOverride(CLMotionActivity::TypeYouth, const CLNatalieModelInput &)
Overriding youth type for elevation credit, beginTime, %f, before, %{public}d, after, %{public}d
CLPredictedWalkDistanceBoutRecorderDb
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/PredictedWalkDistance/CLPredictedWalkDistanceBoutRecorderDb.mm
virtual CMError CLPredictedWalkDistanceBoutRecorderDb::queryBoutDataInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLPredictedWalkDistanceBoutEntry> &) const
CLPredictedWalkDistanceBoutRecorderDb - DB, not accessible
SELECT * FROM PredictedWalkDistanceBoutHistory WHERE endTime BETWEEN ? and ? ORDER BY startTime ASC
Retrieved %lu records between %.0f and %.0f
DELETE FROM PredictedWalkDistanceBoutHistory WHERE endTime < ?
virtual long CLPredictedWalkDistanceBoutRecorderDb::aggregateRecords(const CLAggregationRules &)
CLPredictedWalkDistanceBoutRecorderDb - Failed to expire records.
PredictedWalkDistanceBoutHistory
INSERT INTO PredictedWalkDistanceBoutHistory (startTime, endTime, stepCount, distance, activeTime, elevationAscended, elevationDescended, stepCountGPS, distanceGPS, boutType) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
UPDATE PredictedWalkDistanceBoutHistory SET startTime = ?, endTime = ?, stepCount = ?, distance = ?, activeTime = ?, elevationAscended = ?, elevationDescended = ?, stepCountGPS = ?, distanceGPS = ?, boutType = ? WHERE id = ?
DELETE FROM PredictedWalkDistanceBoutHistory WHERE id = ?
SELECT * FROM PredictedWalkDistanceBoutHistory ORDER BY startTime DESC LIMIT 1
SELECT COUNT(*) FROM PredictedWalkDistanceBoutHistory
virtual void CLPredictedWalkDistanceBoutRecorderDb::prepareSQLStatements()
CLPredictedWalkDistanceBoutRecorderDb: Device is locked and we are unable to open the database
stepCountGPS
distanceGPS
boutType
CLActivityRecorderDb<CLPredictedWalkDistanceBoutEntry>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLPredictedWalkDistanceBoutEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLPredictedWalkDistanceBoutEntry>::setDatabaseAccessible() [T = CLPredictedWalkDistanceBoutEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLPredictedWalkDistanceBoutEntry>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLPredictedWalkDistanceBoutEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
simple
scored
void CLMobility::HealthKitQueryDelegate::queryWorkoutsInTimeRange(CFAbsoluteTime, CFAbsoluteTime, CLMobility::WorkoutsHandlerFunction)
Workout query, health data is not available.
void CLMobility::HealthKitQueryDelegate::queryWorkoutsInTimeRange(CFAbsoluteTime, CFAbsoluteTime, CLMobility::WorkoutsHandlerFunction)_block_invoke
HealthKit Workout query encountered error,%{public}@
void CLMobility::HealthKitQueryDelegate::queryWalkingSteadiness(CFAbsoluteTime, CFAbsoluteTime, NSUInteger, NSString *, BOOL, CLMobility::QuantityHandlerFunction)
Steadiness query failed, health data unavailable (%{private}f, %{private}f)
Missing Database  UUID
void CLMobility::HealthKitQueryDelegate::queryWalkingSteadiness(CFAbsoluteTime, CFAbsoluteTime, NSUInteger, NSString *, BOOL, CLMobility::QuantityHandlerFunction)_block_invoke
HealthKit Steadiness query failed due to device lock
HealthKit Steadiness query encountered error: %{public}@
Sample did not contain the source UUID metadata
Sample's source UUID %{private}@ did not match dBUUID %{private}@
[WalkingSteadiness] numSamples, %{public}lu, startDate, %{public}@, endDate, %{public}@
void CLMobility::HealthKitQueryDelegate::queryNumFalls(CFAbsoluteTime, CFAbsoluteTime, CLMobility::StatisticHandlerFunction)
Falls query failed, health data unavailable (%{private}f, %{private}f)
void CLMobility::HealthKitQueryDelegate::queryNumFalls(CFAbsoluteTime, CFAbsoluteTime, CLMobility::StatisticHandlerFunction)_block_invoke
HealthKit numFalls query failed due to device lock
HealthKit numFalls query encountered error: %{public}@
[NumFalls] sumQuantity, %{private}d, startDate, %{public}@, endDate, %{public}@
void CLMobility::HealthKitQueryDelegate::queryWalkingSteadinessEvents(CFAbsoluteTime, CFAbsoluteTime, NSString *, CLMobility::CategoryHandlerFunction)
Steadiness Events query failed, health data unavailable (%{private}f, %{private}f)
void CLMobility::HealthKitQueryDelegate::queryWalkingSteadinessEvents(CFAbsoluteTime, CFAbsoluteTime, NSString *, CLMobility::CategoryHandlerFunction)_block_invoke
HealthKit SteadinessEvent query failed due to device lock
HealthKit SteadinessEvent query encountered error: %{public}@
[SteadinessEvent] numSamples, %{public}lu, startDate, %{public}@, endDate, %{public}@
void CLMobility::HealthKitQueryDelegate::_queryLocalDeviceDailyQuantitySum(CFAbsoluteTime, CFAbsoluteTime, HKQuantityType *, CLMobility::QuantityHandlerFunction)
QuantityType %{public}@ query failed, health data unavailable (%{private}f, %{private}f)
void CLMobility::HealthKitQueryDelegate::_queryLocalDeviceDailyQuantitySum(CFAbsoluteTime, CFAbsoluteTime, HKQuantityType *, CLMobility::QuantityHandlerFunction)_block_invoke
HealthKit  %{public}@ query failed due to device lock
HealthKit %{public}@ query encountered error: %{public}@
[%{public}@] daysOfData, %{private}lu, startDate, %{private}@, endDate, %{private}@
v36@?0i8{vector<HealthKitQuantitySample, std::allocator<HealthKitQuantitySample>>=^{HealthKitQuantitySample}^{HealthKitQuantitySample}{__compressed_pair<HealthKitQuantitySample *, std::allocator<HealthKitQuantitySample>>=^{HealthKitQuantitySample}}}12
v16@?0i8i12
v36@?0i8{vector<HealthKitCategorySample, std::allocator<HealthKitCategorySample>>=^{HealthKitCategorySample}^{HealthKitCategorySample}{__compressed_pair<HealthKitCategorySample *, std::allocator<HealthKitCategorySample>>=^{HealthKitCategorySample}}}12
void CLMobility::HealthKitQueryDelegate::querySteadinessHealthKitInputs(CLSilo *, CLMobility::SteadinessHealthKitQueryBounds, NSString *, CLMobility::SteadinessInputsHandler)_block_invoke
Steadiness HealthKit inputs queried success, %{public}d
MobilityQuerySamplesFromAnyDevice
bool CLMobility::HealthKitQueryDelegate::allowSamplesFromAnyDevice() const
#WARNING: Testing mode. Querying HK samples from any device (%s)
void CLGyroCalibrationCache::removeOutliers()
Begin.
Too few points.  End.
temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,1
temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,0
End.
CLScoredMapMatcher::CLScoredMapMatcher(CLMapGeometryPtr, const std::string &)
CLMM, m_fSkipRMSECheckForScalingEntryThresholds,%{public}d
bool CLScoredMapMatcher::shouldOverrideCourseUnc(double &)
CLMM, holdCourseEngaged,%d,fabsCourseDiffWithPriorSnap,%.1lf,rawCourseUnc,%.1lf,newCourseUnc, %.1f
void CLScoredMapMatcher::prefilterCourse(CLMapCrumb &)
%.1lf CLMM, high course rate,course,%.1lf,priorCourse,%.1lf,speed,%.1lf,fabsCourseRate,%.1lf
CLMM, course,%.1lf,courseUnc,%.1lf,lastSnapCourse,%.1lf,speed,%.1lf,acrossTrack,%.1f,onRoad,%d,widthUsed,%.1lf
CLMM, Detected course swing after a recent dismount,intervalSinceDismount,%.1lf
CLMM, holdCourse,engaged, large course diff when static,fabsCourseDiffWithPriorSnap,%.1lf
CLMM, holdCourse,engaged, large course diff at slow speed within one second,fabsCourseDiffWithPriorSnap,%.1lf
CLMM, holdCourse,engaged,%d,speed,%.1lf,distance,%.1lf
CLMM, holdCourse,using prior snap,course,%.1lf,courseUnc,%.1lf,fabsCourseDiff,%.1lf
bool CLScoredMapMatcher::evaluateMatch(const CLMapCrumb &, bool)
CLMM, varFactorCheck,oldOffRoadCount,%d,newOffRoadCount,%d
CLMM, courseCheck,oldOffRoadCount,%d,newOffRoadCount,%d
CLMM, stopSnapping,timeout,dT,%.1lf,threshold1,%.1lf,threshold2,%.1lf,static,%d
CLMM, stopSnapping,distance > %.0lfm,Intersection,%d
CLMM, jumpDistanceCheck,oldOffRoadCount,%d,newOffRoadCount,%.0f
CLMM, stopSnapping,varFactor,%.1lf,threshold,%.1lf
CLMM, stopSnapping,offRoadCount,%d,threshold,%.0f
CLMM, stopSnapping,isAmbiguous,1,acrossTrack,%.1lf,acrossTrackThreshold,%.1lf
CLMM, reseting offRoadCount,%d
CLMM, startSnapping
void CLScoredMapMatcher::calculateScoreAndVarFactor(CLMapDataUtil::CovarInvDet &, const struct CLMapGeometry::DistanceQueryResult &, const CLMapCrumb &, double &, double &, double &, CLMapDataUtil::MapMatcherScore &, bool)
#Warning CLMM, NULL road
CLVO2MaxInputStore::add
std::vector<VO2MaxInput> CLVO2MaxInputStore::add(const VO2MaxInput &)
failed to write VO2MaxInput entry, error %d
std::vector<VO2MaxInput> CLVO2MaxInputStore::getBySessionId(unsigned char *)
Failed to get VO2MaxInput entries for session, error %d
CellTilesManager
CLCellTilesManagerExternal::CLCellTilesManagerExternal(CLCellTilesManager *, id<CLIntersiloUniverse>)
TileMgr, cell, Timer allocation failure, #CloneMe
CLCellTilesManager::onClientNotification
CLCellTilesManager::onDataProtectionNotification
CLCellTilesManager::onCompanionNotification
CLCellTilesManager::onStatusNotification
CLCellTilesManager::onLocationNotification
CLParticleMapMatcher::CLParticleMapMatcher(CLMapGeometryPtr, const std::string &)
CLMM, Constructor, fUseSpeedCheckForDOT,%{public}d,fMaxDistanceForTIntersectionForDOT,%{public}.1lf
void CLParticleMapMatcher::updateCandidate(const CLMapRoadPtr &, bool, double, double, double)
CLMM, Unexpected out of bounds array access attempt
bool CLParticleMapMatcher::assessCandidates()
CLMM, Assessing candidates
CLMM, NULL road, bad candidate
CLMM, interpolateOnRoad returned false, determining mean road position
CLMM, Time,%.1lf,candidate,roadID,%llu,fwd,%d,countAroundMean,%d
CLMM, roadsAtIntersection returned false, searching for connected candidates
CLMM, unexpected incomingCount < 1
CLMM, Time,%.1lf,roadID,%llu,incoming,countAroundMean,%d
CLMM, Time,%.1lf,combinedBest,roadID,%llu,incomingCount,%d,outgoingCount,%d
CLMM, interpolateOnRoad returned false, determining outgoing road position
CLMM, Time,%.1lf,roadID,%llu,no particles after the intersection
CLMM, Time,%.1lf,roadID,%llu,isCombined,%d,isMulti,%d
bool CLParticleMapMatcher::predictionAndUpdate()
#Warning CLMM, Position jump(m),%.1lf,dT(s),%.1lf
CLMM,%.1lf,predictionAndUpdate, distance,%.1lf,distBasedOnSpeed,%.1lf,distBasedOnPos,%.1lf
CLMM, dT2 limited,from,%.1lf,to,%.1lf
#Warning CLMM, unexpected,dT,%.1lf,minMoreThan,0,threshold1,%.1lf,threshold2,%.1lf
CLMM,%{public}.1lf,routeHint,add particle,lat,%{private}.8lf,lon,%{private}.8lf,course,%{public}.3lf,rseg,%{private}lld,fwd,%{public}d
CLMM, railway search, roadsWithinDistance returned false
CLMM, railwayParticle,timestamp,%.3lf,lat,%.8lf,lon,%.8lf,course,%.3lf,rseg,%lld
CLMM, prediction,NrParticles,%d,NrStandard,%d,NrNew,%d,NrPriorIntersectionParticles,%d,NrNewAlternateCandidateNoiseParticles,%d,NrNewFwdIntersectionParticles,%d,NrNewBiasedToPrior,%d,NrNewAmbiguous,%d,NrNewRouteParticles,%d
CLMM, moveOnRoad returned false, standard particles
CLMM, moveOnRoad returned false, prior intersection particles
CLMM, moveOnRoad returned false, fwd intersection particles
CLMM, moveOnRoad returned false, prior snap particles
CLMM, moveOnRoad returned false, alternate ambiguous particles
CLMM, Unexpected particle with snapLat == snapLon == 0
#Warning CLMM, totalScore<=0,%.1lf
bool CLParticleMapMatcher::resample()
CLMM, resample
CLMM, Unexpected number of particles after resampling,%d
bool CLParticleMapMatcher::extractSolution()
CLMM, extractSolution
CLMM, Unexpected bestCount<=0
CLMM, Unexpected no best candidate found
CLMM, Unexpected. There should be an outgoing road
CLMM, Unexpected NULL outgoing road candidate
CLMM, Unexpected outgoing snapLat==snapLon==0
CLMM,Time,%.1lf,snapCourse,%.2lf,outgoingSnapCourse,%.2lf, crumbCourse,%.2lf, outgoingDistanceFromIntersection,%.2lf,outgoingCondition,%d,crumbCourseUnc,%.2lf,significantCourseChange,%d,isCourseAligned,%d, isMeanCandidateAlignedWithCourse,%d
CLMM, Time,%.1lf,exit distance check,distance,%.2lf,exitDistance,%.2lf
CLMM, Time,%.1lf,outgoing condition,%d
CLMM, %.1lf, Using outgoing,incomingID,%lld,outgoingID,%lld
CLMM, %.1lf, Using particle on outgoing,incomingID,%lld,outgoingID,%lld
CLMM, %.1lf, bestParticleRoadID,%lld
CLMM, ambiguous solution not detected,fabsCourseDiff,%.1lf,acrossTrack,%.1lf,ratio,%.3lf,alongTrackToAlt,%.1lf
CLMM, ambiguous solution detected,fabsCourseDiff,%.1lf,acrossTrack,%.1lf,ratio,%.3lf,alongTrackToAlt,%.1lf
%.1lf,CLMM, ambiguity reverted using route-hints
CLMM, ambiguous solution hysteresis
CLMM, dismounted recently,doNotSnapCourse,%d
CLMM, distToNextMulti,%.1lf, distFromPriorCrumb,%.1lf
CLMM, not snapping course,reason,distanceToIntersection,%.1lf
CLMM, not snapping course,reason,at intersection,fabsCourseDifference,%.1lf
CLMM, not snapping course,reason,turning,fabsCourseDifference,%.1lf
CLMM, %.1lf, snapping course, reason, gps course not reliable,%.1lf,fabsCourseDiffWithPriorSnap,%.1lf
CLMM, %.1lf, overwriting unreliable GPS course, static case, priorCourse,%.1lf, newCourse,%.1lf
CLMM, %.1lf, snapping course, reason, gps course flipping at low speeds,%.1lf,fabsCourseDiffWithPriorSnap,%.1lf
CLMM, %.1lf, overwriting unreliable GPS course, low speed case, priorCourse,%.1lf, newCourse,%.1lf
void CLParticleMapMatcher::adjustSolutionforRoadWidth()
CLMM,%{public}.1lf,roadWithAdustment,number of particles are 0
CLMM,%{public}.1lf,roadWithAdustment,snap invalid or frc = 9
CLMM,%{public}.1lf,roadWithAdustment,road is nullptr
CLMM,%{public}.1lf,frc,%{public}d,oneway,%{public}d,roadWidth,%{public}.1lf,acrossTrack,%{public}.3lf
CLMM,%.1lf,roadWidthCorrection,acrossTrack,%.2lf,correction,%.2lf,halfRoadWidth,%.2lf
void CLParticleMapMatcher::performPartialMatching()
CLMM, performPartialMatching
CLMM, skipping partial match, as solution is inside tunnel
CLMM, partial snapping,poorVarFactorCount,%d,weightGPS,%.2lf,weightSnap,%.2lf
bool CLParticleMapMatcher::assessParallelRoadsWithinDist(const double &, const double &, bool &)
CLMM, roadsWithinDistance returned false
#Warning CLMM, Unexpected roadsWithinDistance returned empty list
CLMM, Unexpected NULL road
#Warning CLMM, Unexpected roadsWithinDistance returned only railways
bool CLParticleMapMatcher::prepareSeeding()
CLMM, prepareSeeding
CLMM, Unexpected crumb lat==lon==0
CLMM, Unexpected crumb snapLat==snapLon==0
CLMM, Unexpected maxDistance,%{public}.1lf
CLMM, including railway
bool CLParticleMapMatcher::assessMatchAndNeedForReseed(bool &)
CLMM, assessMatchAndNeedForReseed
CLMM,postEvaluateMatch,%s
CLMM, Reseeding due to varFactor,%.1lf,max,%.1lf
CLMM, Reseeding due to badMatchCount,max,%d
CLMM, Reseeding due to Neff
CLMM, Reseeding due to stuck at dead-end while observations move away
bool CLParticleMapMatcher::reseed()
CLMM, reseed
CLMM, Unexpected number of particles after resampling,%{public}d
virtual bool CLParticleMapMatcher::match(CLMapCrumb &)
CLMM,%.1lf,Unexpected,invalid geometry pointer, mapMatch
CLMM, %.1lf, not matching
CLMM, opportunistic tile download only, favorable GPS conditions
CLMM, opportunistic tile download only, high speed threshold
CLMM, match,%.1lf, allowsNetworkUsage, %d
#Warning CLMM, Time difference between updates is zero. Update ignored.
CLMM, %.1lf,hopping check,connecting roads,%d, current road %lld,prior road %lld
CLMM, %.1lf,hopping check,prior road, %lld, connected to the incoming road, %lld, of the current solution road, %lld
CLMM, %.1lf,hopping between roads detected,reset,%d,priorfullSnapCourse,%.1lf,currentFullSnapCourse,%.1lf,priorId,%llu,currentId,%llu
CLMM, holdCourse engaged but not snapping course
bool CLParticleMapMatcher::runDirectionOfTravelHelper(double, double, double, double &)
CLMM, no DOT, course is not aligned
CLMM, across track too large, not suitable DOT assistance
CLMM, along track too large, not suitable DOT assistance
bool CLParticleMapMatcher::modifyHorizontalUncertainty(CLMapCrumb &)
CLMM,%.1lf,lat,%.8lf,lon,%.8lf,alt,%.2lf,course,%.1lf,snapLat,%.8lf,snapLon,%.8lf,snapCourse,%.1lf,horizontalError,%.2lf,hunc,%.2lf,ratio,%.2lf
virtual bool CLParticleMapMatcher::getDirectionOfTravelAssistance(CLGpsAssistant_Type::DirectionOfTravelAssistance &)
CLMM, no DOT,feedback interval check
CLMM, no DOT,frc,0
CLMM, no DOT, too close to prior intersection
CLMM, no DOT, course not aligned to full snap
CLMM, no DOT, assessParallelRoadsWithinDist returned false, unexpected
CLMM, no DOT, too close to a road with similar course
CLMM, no DOT, too close to next intersection
CLMM, no DOT, too slow when nearing intersection
CLMM, moveOnRoad returned false, DOT particle assistance
CLMM, no DOT, too close large road direction change
CLMM, no DOT, computeSnapCoordinatesFromRawGPSCoordinates lookBehind returned false
CLMM, no DOT, predicted point is too close to intersection
CLMM, Unexpected calculateNewPosUsingAcrossTrack fail
CLMM, no DOT, current particle within the stopDistanceFromIntersection
CLMM, no DOT, computeSnapCoordinatesFromRawGPSCoordinates predicted returned false
CLMM, DOT,%.1lf,lat,%.7lf,lon,%.7lf,course,%.1lf,courseUnc,%.1lf,rw,%.1lf,startLat,%.7lf,startLon,%.7lf,length,%.1lf,speed,%.3lf,isOneWay,%d,isRailWay,%d,isTunnel,%d,isBridge,%d,distFromIntersection,%.1lf,isFreeway,%d,machContinuousTime,%.3lf,lookBehindDistance,%.2lf,type,%d
virtual bool CLParticleMapMatcher::getPosAssistanceForGps(CLGpsAssistant_Type::MapMatchedPositionAssistance &)
CLMM, MMPA,%.1lf,lat,%.7lf,lon,%.7lf,a,%.2lf,b,%.2lf,az,%.3lf,course,%.3lf
virtual bool CLParticleMapMatcher::getTunnelBridgeAssistance(CLGpsAssistant_Type::TunnelBridgeAssistance &)
CLMM, TBA, Invalid time
CLMM, TBA, NULL Island
CLMM, TBA,roadsWithinDistance returns query failed,lat,%{private}.8lf,lon,%{private}.8lf,searchRadius,%{public}.1lf
CLMM, TBA,lat,%{private}.8lf,lon,%{private}.8lf,unc,%{public}.8lf,searchRadius,%{public}.1lf,isCloseToTunnel,%{public}d,isCloseToBridge,%{public}d,isTunnel,%{public}d,isBridge,%{public}d
bool CLParticleMapMatcher::generateRouteHintMeasurement()
CLMM,Unexpected,invalid geometry pointer, generateRouteHint
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,failed as not enough route roads are available
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,route index,%d,is more than number of route roads,%{public}ld
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,routeCourse,%{public}.1lf,is very different than crumb course,%{public}.1lf,rejection,%d
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,routeCourse,%{public}.1lf,is different than crumb course,%{public}.1lf, and rejections are high,rejection,%d
CLMM,%{public}.1lf,routeHints,skipping,moveOnRouteRoads meas,routeCourse,%{public}.1lf,is somewhat different than crumb course,%{public}.1lf
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,course deweighted,unc,%.2lf
CLMM,%{public}.1lf,routeHints,meas,moveOnRouteRoads,ll,%{private}.7lf,%{private}.7lf,course,%{public}.3lf,hunc,%{public}.3lf,cunc,%{public}.3lf,count,%{public}lu
CLMMPED,%{public}.1lf,routeHints, no meas, projection,routeCourse,%{public}.1lf,is very different than crumb course,%{public}.1lf,rejection,%d
CLMM,%{public}.1lf,routeHints,duplicate measurement check,measurementGood,%{public}d,vector,%{public}lu
bool CLParticleMapMatcher::integrateRouteHint()
CLMM,%{public}.1lf,routeHints,used route-hint
void CLVO2MaxOutputStore::addCloudKitSyncEngineMetadata(VO2MaxCloudKitSyncEngineMetadata &)
Unexpected failure attempting to save VO2MaxCloudKitSyncEngineMetadata record
void CLActivityRecorderDb<VO2MaxOutput>::addSuspectRecord(const T &) [T = VO2MaxOutput, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLPencilStateSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/Notifiers/CLPencilState.mm
-[CLPencilStateAdapter beginService]
CLPencilState
virtual void CLNotifier<CLPencilState_Type::Notification, CLPencilState_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLPencilState_Type::Notification, NotificationData_T = CLPencilState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLPencilState_Type::Notification, CLPencilState_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLPencilState_Type::Notification, NotificationData_T = CLPencilState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLPencilState_Type::Notification, CLPencilState_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLPencilState_Type::Notification, NotificationData_T = CLPencilState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPencilState_Type::Notification, CLPencilState_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLPencilState_Type::Notification, NotificationData_T = CLPencilState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPencilState_Type::Notification, CLPencilState_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLPencilState_Type::Notification, NotificationData_T = CLPencilState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLPencilState_Type::Notification, CLPencilState_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLPencilState_Type::Notification, NotificationData_T = CLPencilState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLPencilState_Type::Notification, CLPencilState_Type::NotificationData, char, char>::listClients() [Notification_T = CLPencilState_Type::Notification, NotificationData_T = CLPencilState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
AppleInternalDataCollectionEnabled
static bool CLActivityDbExportAdapter::checkExportEnabled()
CLActivityLogger managed should enable data collection setting is %{public}d.
com.apple.nanolifestyle
#Warning CLActivityLogger Failed to get data collections enabled setting. It may not have been set yet.
CLActivityLogger exporting is disabled MotionMetricsExportInterval, %d, MotionMetricsExportTimerInterval, %d
CLActivityLogger should enable data collection is %{public}d.
void CLActivityDbExportAdapter::startExportTimerIfNeeded()
CLActivityLogger exporting %s is disabled 
CLActivityLogger exporting %s is already enabled 
LastDumped
CLActivityLogger exporting %s: MotionMetricsExportTimerInterval = %d, MotionMetricsExportInterval = %d
Skipping
Dumping
void CLActivityDbExportAdapter::startExportTimerIfNeeded()_block_invoke
CLActivityLogger exporting %s is %f, currentTime is %f, next dumping time is %f, %s
CLActivityLogger exporting %s metrics with OSAWriteLogForSubmission
#Warning CLActivityLogger failed to submit iOS data analysis with type kOSAProblemTypeMotionState
CLActivityLogger exporting timer enabled 
/Library/Managed Preferences/mobile/com.apple.nanolifestyle.plist
int readIntValueForMotionPreferenceKey(const char *)
CLActivityLogger read %s as CFStringRef failed
MotionMetricsExportInterval
MotionMetricsExportTimerInterval
virtual void CLMapMatchingEngineBase::setForceNetworkUsage(bool)
CLMM, ForceNetworkUsage %{public}d
virtual void CLMapMatchingEngineBase::setDisallowNetworkUsage(bool)
CLMM, DisallowNetworkUsage %{public}d
void CLMapMatchingEngineBase::setSignalEnvironment(const CLSignalEnvironmentProvider_Type::SignalEnvironmentInfo)
CLMM,%.1lf,signalEnvironment,%{public}d,name,%{public}s,fidelity,%{public}d
bool CLMapMatchingEngineBase::fillCrumb(const CLDaemonLocation &, const CLDaemonLocationPrivate &, CLMapCrumb &) const
CLMM,%.3lf,applyChinaShift() returned false
virtual bool CLMapMatchingEngineBase::match(CLDaemonLocation &, CLDaemonLocationPrivate &, CLMapCrumb &)
CLMM,%.3lf,null pointers for matcher and geometry
CLMM,%.3lf,match() returned false
NoRouteHintCrumb
CLMM,%.3lf,matchRouteHints() returned false
RouteHintCrumb
CLMM,%.3lf,Using solution with route hints
MapMatchingEngine
fGeometry
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MapMatching/CLMapMatchingEngine.mm
CLMapMatchingEngine
particle
fMatcher
fMatcherRouteHints
UseFullSnap
CLMapMatchingEngine::CLMapMatchingEngine(id<CLIntersiloUniverse>, const std::string &)
CLMM, UseFullSnap, %{public}d
enableDotGpsFeedback
CLMM, enableDotGpsFeedback,%{public}d
EnablePedestrianMapMatching
CLMM, EnablePedestrianMapMatching,%{public}d
fPedestrianGeometry
fPedestrianMMFilter
CLMMPED, PedestrianDirectionOfTravel,%d
EnablePedestrianDirectionOfTravel
CLMMPED,Overwrite,EnablePedestrianDirectionOfTravel,%{public}d
EnableActivityBasedPedestrianDirectionOfTravel
CLMMPED,Overwrite,EnableActivityBasedPedestrianDirectionOfTravel,%{public}d
EnableCyclingMapMatching
CLMM, EnableCyclingMapMatching,%{public}d
fCyclingGeometry
fCyclingMMFilter
CLMMPED, CyclingDirectionOfTravel,%d
EnableCyclingDirectionOfTravel
CLMMPED,Overwrite,EnableCyclingDirectionOfTravel,%{public}d
EnableActivityBasedCyclingDirectionOfTravel
CLMMPED,Overwrite,EnableActivityBasedCyclingDirectionOfTravel,%{public}d
IntegrateRouteHintsInMapMatcher
CLMM, IntegrateRouteHintsInMapMatcher,%{public}d
ForceUserActivity
Walking
Driving
CLMM, ForceActivity,Activity,%{public}d
bool CLMapMatchingEngine::CountryChecker::isDirectionsSupported()
CLMM,Country,%s,supportsTBTFeature,%d
virtual bool CLMapMatchingEngine::match(CLDaemonLocation &, CLDaemonLocationPrivate &)
CLMM,match,nav,%{public}d,forceActivity,%{public}d
CLMM,%.3lf,Unable to fill crumb,no matching
CLMM,%.3lf,Unknown dynamics,no matching,activity,%{public}d,fitness,%{public}d
CLMM,%.3lf,null pointers for pedestrian matcher
CLMM,%.3lf,null pointers for cycling matcher
CLMM,%.3lf,vehicle dynamics,wifi2 fix ignored
CLMM,%.3lf,null pointers for matcher or geometry
CLMM,%.3lf,MMFilter,latency,%.3lf,triggeredByRouteHints,%d,mmtype,%d
CLMM,%{public}.3lf,Match,latency,%{public}.3lf,mmType,%{public}d,usable,%{public}d,amb,%{public}d
void CLMapMatchingEngine::provideDirectionOfTravelAssistance(const CLDaemonLocation &)
CLMM,wantDot,%d,forceDot,%d,isPedestrian,%d,isVehicle,%d,isEureka,%d,isFire,%d,type,%d,isCycling,%d
void CLMapMatchingEngine::provideTunnelBridgeAssistance(const CLDaemonLocation &, CLDaemonLocationPrivate &)
CLMM,TBA,setTunnelBridgeAssistance,lat,%{private}.8lf,lon,%{private}.8lf,isCloseToTunnel,%{public}d,isCloseToBridge,%{public}d,isTunnel,%{public}d,isBridge,%{public}d
void CLMapMatchingEngine::setFullSnapEnabled(bool)
CLMM,FullSnapEnabled,%{public}d
virtual void CLMapMatchingEngine::setForceNetworkUsage(bool)
CLMM,ForceNetworkUsage,%{public}d
virtual void CLMapMatchingEngine::setDisallowNetworkUsage(bool)
CLMM,DisallowNetworkUsage,%{public}d
Rural
Urban
DenseUrban
DenseUrbanCanyon
Foliage
CL::Wifi1::Policies::PostPositionCalculationStateUpdate::Output CL::Wifi1::Policies::PostPositionCalculationStateUpdate::HandleEvent::operator()(const Events::ReprocessWifiScanBuffer &) const
@WsbReproc, remain, groups, %{public}lu, unknownAPs, %{public}lu, pass, %{public}d
output.o.systemState.associatedAp.mac() == fInput.i.eventState.centroidForAssociatedAp->macAddress()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/Logic/Policies/CLWifi1PostPositionCalculationStateUpdate.mm
CL::Wifi1::Policies::PostPositionCalculationStateUpdate::Output CL::Wifi1::Policies::PostPositionCalculationStateUpdate::HandleEvent::operator()(const Events::Network::AlsAllUnknown &) const
WsbAls, unknown, groups, %{public}ld, tags, %{public}d, %{public}d
fInput.i.eventState.batchedComputedLocations.size() == fInput.i.eventState.wsbGroups.size()
CL::Wifi1::Policies::PostPositionCalculationStateUpdate::Output CL::Wifi1::Policies::PostPositionCalculationStateUpdate::HandleEvent::operator()(const Events::Wifi::Wsb &) const
WsbTimer, set, %{public}d, unknown, %{public}ld, wasempty, %{public}d, delay, %{public}d
CL::Wifi1::Policies::PostPositionCalculationStateUpdate::Output CL::Wifi1::Policies::PostPositionCalculationStateUpdate::HandleEvent::operator()(const Events::Client::LocationRequest &) const
@WifiFlow, scanreq inconsistent, pre, %{private}d, post, %{private}d
@WifiFlow, scanreq, suppressed, %{public}d
@EmerTick, scanrequest, %{public}.1f
@EmerFlow, ScanRequest, type, %{public}s, tte, %{public}.1f
static Types::Wsb CL::Wifi1::Policies::PostPositionCalculationStateUpdate::HandleEvent::updateScanBuffer(const CL::Wifi1::Policies::PostPositionCalculationStateUpdate::Input &, const CLWifiService_Type::AccessPointGroups &, bool)
@WsbDiscard, unknown, %{public}.1f, aps, %{public}ld
@WsbDiscard, alsmax, %{public}.1f, aps, %{public}ld
WsbMetric, groupresult, unknownaps, %{public}d
discard:unknownaps
WsbMetric, groupresult, alsmax, %{public}d
discard:alsmax
@WsbReproc, update, groups, %{public}lu, unknownAPs, %{public}lu, deleteTo, %{public}0.1f
static std::tuple<Types::Emergency, CLWifiLocationUpdateRequest, Types::AlsQueryType> CL::Wifi1::Policies::PostPositionCalculationStateUpdate::HandleEvent::updateEmergencyStateCurrentLocationUpdateRequestAndApQueryType(const Types::Emergency &, const CLWifiLocationUpdateRequest &, Types::AlsQueryType, const Types::ComputedLocation &, cl::chrono::CFAbsoluteTimeClock::time_point, bool)
@EmerCheck, top, %{public}d
@EmerCheck, current, %{public}d
@EmerFlow, ScanRequest5GHzWithAlsReply, waiting for 5GHz scan result
@EmerWarn, ScanReply5GHzWithPendingAls, abort waiting for the preliminary ALS response
@EmerCheck, confidence, %{public}d, above threshold
@EmerTick, scanrequest5ghzwithals, %{public}.1f
@EmerFlow, ScanRequest5GHzWithPendingAls, queryType, %{public}d, tte, %{public}.1f
@EmerCheck, support 5GHz, %{public}d
@EmerFlow, Done, alsreply
@EmerWarn, unexpected state, processScanResult, %{public}d, #CloneMe
@EmerTick, anyfix, %{public}.1f
@EmerCheck, switched, %{public}d, aps, %{public}d
@EmerTick, sufficientfix, %{public}.1f
@EmerFlow, Done, conditions
@EmerCheck, returned, %{public}d
CL::Wifi1::Policies::PostPositionCalculationStateUpdate::Output CL::Wifi1::Policies::PostPositionCalculationStateUpdate::HandleEvent::operator()(const Events::Wifi::Scan &) const
#post-wifi-position-calculation-state-update, location update not in progress, will not issue scan
@EmerFlow, ScanRequest5GHzWithPendingAls, type, %{public}s, tte, %{public}.1f
#post-wifi-position-calculation-state-update, #emergency location update in progress, skipping state transition logic
#post-wifi-position-calculation-state-update, previous decision made to skip using wifi scan, skipping state transition logic
#post-wifi-position-calculation-state-update, stop criteria has been satisfied
auto CL::Wifi1::Policies::PostPositionCalculationStateUpdate::HandleEvent::updateEmergencyStateCurrentLocationUpdateRequestAndApQueryType(const Types::Emergency &, const CLWifiLocationUpdateRequest &, Types::AlsQueryType, const Types::ComputedLocation &, cl::chrono::CFAbsoluteTimeClock::time_point, bool)::(anonymous class)::operator()() const
@EmerTick, alsreq, %{public}.1f
@EmerFlow, AlsRequest, queryType, %{public}d, tte, %{public}.1f
fInput.i.eventState.computedLocation.location.horizontalAccuracy == kCLClientLocationInvalid.horizontalAccuracy && fInput.i.eventState.computedLocation.numberOfApsUsedInHorizontalCalculation == 0
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/Logic/Policies/CLWifi1PostPositionCalculationStateUpdate.h
void CLCaloriePalEstimator::setupPalUpdateTimer(bool)
Starting PAL update timer
PalEstimationInterval
void CLCaloriePalEstimator::querySources()_block_invoke
PAL, No step count / workouts from first party sources.
void CLCaloriePalEstimator::estimateDailyStepCount()
PAL,Containers out-of-sync,aborting
PAL,Daily steps,%f,Session type,%lu,startTime,%f,duration,%f,mean mets,%f,in-system steps,%f,met-converted steps,%f
PAL,Day index,%zu,stepCount,%f
LSApplicationProxy *getLSApplicationProxy(CFStringRef)
no app proxy available for %{public}s
CLAppMonitorSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/AppMonitor/CLAppMonitor.mm
-[CLAppMonitorAdapter beginService]
CLAppMonitor::CLAppMonitor(id<CLIntersiloUniverse>)_block_invoke
App foregrounded for %.2fs.  Post %s (%d), pid, %d, bundleId, %s
com.apple.LaunchServices.applicationRegistered
com.apple.LaunchServices.applicationUnregistered
Terminated
BackgroundTaskSuspended
BackgroundRunning
ForegroundRunning
ProcessServer
ForegroundRunningObscured
Unregistered
ForegroundRunningForSomeTime
void CLAppMonitor::onApplicationStateChanged(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
cannot find SBApplicationStateKey
unknown application state %{public}d
failed to retrieve pid
failed to retrieve bundle ID
Post Application State Change Notification, %d, %s, pid, %d, bundleId, %s
bundleIDs
isPlaceholder
void CLAppMonitor::onApplicationRegistered(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
cannot find bundle ID for %{public}d
void CLAppMonitor::onApplicationUnregistered(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
static CLAppMonitor_Type::AppType CLAppMonitor::getAppType(CFStringRef)
#Warning no app type available for %s
System
Internal
com.apple.mobileinstallation.companion_placeholder
static bool CLAppMonitor::isStandAloneWatchApp(const std::string &)
Either not a watch platform or bundleId is empty
CLAppMonitor::onApplicationStateChanged
CLAppMonitor::onApplicationRegistered
CLAppMonitor::onApplicationUnregistered
virtual void CLNotifier<CLAppMonitor_Type::Notification, CLAppMonitor_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLAppMonitor_Type::Notification, NotificationData_T = CLAppMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLAppMonitor_Type::Notification, CLAppMonitor_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLAppMonitor_Type::Notification, NotificationData_T = CLAppMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLAppMonitor_Type::Notification, CLAppMonitor_Type::NotificationData>::removeClient(int) [Notification_T = CLAppMonitor_Type::Notification, NotificationData_T = CLAppMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLAppMonitor_Type::Notification, CLAppMonitor_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLAppMonitor_Type::Notification, NotificationData_T = CLAppMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLAppMonitor_Type::Notification, CLAppMonitor_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLAppMonitor_Type::Notification, NotificationData_T = CLAppMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLAppMonitor_Type::Notification, CLAppMonitor_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLAppMonitor_Type::Notification, NotificationData_T = CLAppMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLAppMonitor_Type::Notification, CLAppMonitor_Type::NotificationData>::listClients() [Notification_T = CLAppMonitor_Type::Notification, NotificationData_T = CLAppMonitor_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLFallImpactEventTracker::trackCancelReason(uint64_t, CMSPUFall_Types::FallCancelReason)
Unable to log impact due to cancel reason not containing kImpactStart 0x%llu
void CLFallImpactEventTracker::updateImpactFeatures(const CLFall_Types::ImpactEvent &)
Could not find impact at time %llu, unable to set impact features
void CLFallImpactEventTracker::updateUserResponse(const uint64_t, const CMSPUFall_Types::FallResponse)
Could not find impact at time %llu, unable to set user response
void CLFallImpactEventTracker::updateFallDistance(const CLFall_Types::FallDistance &)
Could not find impact at time %llu, unable to set fall distance
void CLFallImpactEventTracker::rescheduleFlushTimer(CFAbsoluteTime)
Rescheduling impact reporting in %.2lf seconds
void CLTransitWsbClient::startWsb()
Start active dynamic Wsb
transit
void CLTransitWsbClient::stopWsb()
Stop active dynamic Wsb
void CLTransitWsbClient::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
Received kNotificationPower, isWifiPowered, %d
Received kNotificationScanCache
Unknown notification received, %{public}d
CLTransitWsbClient::onWifiNotification
CMStrideCalRecorderDb
CMStrideCalRecorderDb::CMStrideCalRecorderDb(bool)
CMStrideCalRecorderDb init
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/StrideCalibration/CMStrideCalRecorderDb.mm
void CMStrideCalRecorderDb::deleteRecordsBefore(CFTimeInterval)
StrideCalHistory
SELECT COUNT(*) FROM StrideCalHistory
SELECT * FROM StrideCalHistory ORDER BY startTime ASC
SELECT * FROM StrideCalHistory WHERE pacebin == ? ORDER BY startTime DESC
SELECT * FROM StrideCalHistory WHERE speed > ? AND speed <= ? ORDER BY startTime DESC
DELETE FROM StrideCalHistory WHERE startTime < ?
DELETE FROM StrideCalHistory WHERE startTime > ?
DELETE FROM StrideCalHistory
INSERT INTO StrideCalHistory (startTime, pacebin, kvalue, kvalueTrack, score, endTime, distance, steps, session, speed, percentGrade, gpsSource) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SELECT * FROM StrideCalHistory ORDER BY startTime DESC LIMIT 1
UPDATE StrideCalHistory SET startTime = startTime + ?
virtual void CMStrideCalRecorderDb::prepareSQLStatements()
void CMStrideCalRecorderDb::alterTableIfNecessary()
StrideCalHistory table doesn't even exist
ALTER TABLE StrideCalHistory
UPDATE StrideCalHistory SET 
 = CAST(pacebin AS FLOAT);
gpsSource
virtual void CMStrideCalRecorderDb::deleteRecordsAfterInsertUL(const CLStrideCalEntry &)
virtual void CMStrideCalRecorderDb::shiftRecordsByUL(CFTimeInterval)
virtual void CMStrideCalRecorderDb::insertRecordUL(const CLStrideCalEntry &, bool)
StrideCalDb (%f,%d,%f,%f,%f,%f,%f,%d,%d,%f,%f,%d).
percentGrade
CLActivityRecorderDb<CLStrideCalEntry>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLStrideCalEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLStrideCalEntry>::setDatabaseAccessible() [T = CLStrideCalEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLStrideCalEntry>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLStrideCalEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLMotionStateObserverSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/MotionState/CLMotionStateObserver.mm
-[CLMotionStateObserverAdapter beginService]
void CLMotionStateObserver::startSession(const CLWorkoutUpdate &)
MotionStateObserver, Started session, startTime, %.3f, user type, %s, predicted type, %s, hk activity type, %i
void CLMotionStateObserver::stopSession()
MotionStateObserver, Stopped session, startTime, %.3f, user type, %s, predicted type, %s, hk activity type, %i
void CLMotionStateObserver::updateCoprocessor()
MotionStateObserver, Sending Down ActivityOverride,%ld,startTime,%.3f,activityType,%d,vehicularConfidence,%d
CLMotionStateObserver::onCompanionNotification
CLMotionStateObserver::onFitnessTrackingNotification
CLMotionStateObserver::onMotionStateMediatorNotification
virtual void CLNotifier<CLMotionStateObserver_Type::Notification, CLMotionStateObserver_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLMotionStateObserver_Type::Notification, NotificationData_T = CLMotionStateObserver_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLMotionStateObserver_Type::Notification, CLMotionStateObserver_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLMotionStateObserver_Type::Notification, NotificationData_T = CLMotionStateObserver_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionStateObserver_Type::Notification, CLMotionStateObserver_Type::NotificationData>::removeClient(int) [Notification_T = CLMotionStateObserver_Type::Notification, NotificationData_T = CLMotionStateObserver_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionStateObserver_Type::Notification, CLMotionStateObserver_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLMotionStateObserver_Type::Notification, NotificationData_T = CLMotionStateObserver_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionStateObserver_Type::Notification, CLMotionStateObserver_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLMotionStateObserver_Type::Notification, NotificationData_T = CLMotionStateObserver_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLMotionStateObserver_Type::Notification, CLMotionStateObserver_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLMotionStateObserver_Type::Notification, NotificationData_T = CLMotionStateObserver_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLMotionStateObserver_Type::Notification, CLMotionStateObserver_Type::NotificationData>::listClients() [Notification_T = CLMotionStateObserver_Type::Notification, NotificationData_T = CLMotionStateObserver_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
int CLWifiTileDataRepository::removeAllTileHeaders()
remaining header in db, deleting, x, %{private}d, y, %{private}d
Failed to delete tile header
Failed to delete tile.
bool CLWifiTileDataRepository::deleteByTileId(const TileId &)
runtime error deleting tiles
no sqlite connection error, %{private}s
Failed to successfully read and parse wifi tile header
CLWifiTileHeaderEntry CLWifiTileDataRepository::saveWifiTileAccessPointEntries(const std::string &, cl::chrono::CFAbsoluteTimeClock::time_point)
tile parsing complete, successful, %d
bool CLWifiTileDataRepository::_deleteByTileIdNoTransaction(const TileId &)
deleting tile, x, %{private}d, y, %{private}d, header, %d, tile, %d
!tileHeaderEntry
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/CLWifiTileDataRepository.mm
auto CLWifiTileDataRepository::saveWifiTileAccessPointEntries(const std::string &, cl::chrono::CFAbsoluteTimeClock::time_point)::(anonymous class)::operator()(const CLTilesManager_Type::TileHeader &, int, uint32_t, uint32_t) const
failed to delete previous tile before inserting new one
failed to save tile header
bool CLSwimClassifier::estimatePeriod(int &, float) const
Period Estimate Update,period,%f,confidence,%f,timestamp,%f,startTime,%f
CLSwimStyleType CLSwimClassifier::classify(float)
ClassificationResult,%d,startTime,%f,timestamp,%f
void CLSwimClassifier::setDeviceOrientation(const CLGizmoOrientation &)
Swimming device orientation set,wrist,%d,crown,%d
tier1_0
tier1_1
tier1_2
tier2_0
tier2_1
CLSwimStyleType CLSwimClassifier::runTieredClassifiers(const float (&)[14]) const
Classification,%s,%d,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f
Freestyle
Backstroke
Breaststroke
Butterfly
Mixed
const T &CMQueue<CMVector<float, 3>>::operator[](const size_t) const [T = CMVector<float, 3>]
void DeviceLocationData::fillData(const CLLocationProvider_Type::NotificationData &)
CLAccessoryAWD,%{public}.1lf,DeviceLocationData,type,%{public}d,ll,%{private}.7lf,%{private}.7lf,alt,%{public}.2lf,speed,%{public}.2lf,course,%{public}.2lf,hUnc,%{public}.2lf,vUnc,%{public}.2lf,speedUnc,%{public}.2lf,courseUnc,%{public}.2lf,mct,%{public}.1lf
void CLAccessoryAWD::locationSessionEnd(const CFTimeInterval)
CLAccessoryAWD,%{public}.1lf,locationSession,start,%{public}.1lf,end,%{public}.1lf,duration,%{public}d,sessions,%{public}d
void CLAccessoryAWD::locationSessionStart(const CFTimeInterval)
CLAccessoryAWD,%{public}.1lf,locationSession,start,%{public}.1lf,sessions,%{public}d
void CLAccessoryAWD::updateNavigationAppStats(const CFTimeInterval, const std::string &, const CFTimeInterval &)
CLAccessoryAWD,%{public}.1lf,updateNavigationAppStats,%{public}s,more than allowed location apps open,%{public}d
#Warning,CLAccessoryAWD,%{public}.1lf,updateNavigationAppStats,%{public}s,appStartTime,%{public}.1lf, greater than machContTime,%{public}.1lf
CLAccessoryAWD,%{public}.1lf,updateNavigationAppStats,%{public}s,appLaunchTime,%{public}.1lf,appStartTime,%{public}.1lf,appRunTime,%{public}d
CLLocationSubscription.AutopauseThreshold
!_assertion
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/Subscriptions/CLLocationSubscription.mm
-[CLLocationSubscriptionStatusBarAssertion dealloc]
Status
StatusBarOverride
_assertion
-[CLLocationSubscriptionStatusBarAssertion setDesiredEnablementState:]
-[CLLocationSubscriptionStatusBarAssertion setDesiredEnablementState:]_block_invoke
Completed async acquire of status bar assertion for %{public}s (PID:%{public}d)
Failed async acquire of status bar assertion for %{public}s (PID:%{public}d)
_timeStarted
-[CLLocationSubscriptionStatusBarAssertion submit:]
-[CLLocationSubscriptionSuperStickyAssertion initWithBundleId:pid:]
!_bundleId
-[CLLocationSubscriptionSuperStickyAssertion dealloc]
com.apple.locationd.CLLocationSubscription.session_duration
inForegroundPercent
durationForeground
durationBackground
kCLConnectionMessagePausesLocationUpdatesAutomatically
kCLConnectionMessageAllowsBackgroundLocationUpdates
kCLConnectionMessageShowsBackgroundLocationIndicator
kCLConnectionMessageAllowsMapCorrection
kCLConnectionMessageActivityType
AutoPauseOverride
CLLocationSubscription::CLLocationSubscription(CLTransientSubscriptionBase::Delegate *, id<CLIntersiloUniverse>, CLClientManagerAuthorizationContext *, const CLClientManager_Type::Name &, bool, pid_t)
PAUSE: Override AutoPause to On for all clients
PAUSE: Override AutoPause to On for all clients linked with SDK that predates 6.0
PAUSE: Override AutoPause to Off for all clients
PAUSE: Override AutoPause to None
AutoPauseLogUI
PAUSE: AutoPause log UI Enabled
AutoPauseActivityType
PAUSE: activity type defaulted to %d
EnableProactiveCompass
Proactive compass is %{public}s.
ProactiveCompassStartDelay
Overriding ProactiveCompassStartDelay,%{public}.2f.
virtual CLLocationSubscription::~CLLocationSubscription()
ending metric session (LocationUpdateSession) for %s
void CLLocationSubscription::setBackgroundIndicatorEnabled(bool)
Background indicator enabled for %s is now %d (was %d)
void CLLocationSubscription::setBatching_nl(const bool)
BATCH: client, '%s', batchEnabled, %d
kCLConnectionMessageDesiredAccuracyKey
kCLConnectionMessageDistanceFilterKey
kCLConnectionMessageAlteredAccessoryLocationsKey
kCLConnectionMessageDynamicAccuracyReductionKey
void CLLocationSubscription::handleRequestLocation(bool, const CLNameValuePair &)
client '%s' subscribing to location desiredAccuracy %.2f distanceFilter %.2f dynamicAccuracyReductionEnabled %d allowsAlteredAccessoryLocations %d
client '%{public}s' unsubscribing from location
@ClxClient, unsubscribe, %{public}s
kCLConnectionMessageActivityTypeKey
void CLLocationSubscription::handleMessageActivityType(std::shared_ptr<CLConnectionMessage>)
Couldn't get value for key %{public}s
Client '%s' changed activity type from %d to %d
kCLConnectionMessagePausesLocationUpdatesAutomaticallyKey
void CLLocationSubscription::handleMessagePausesLocationUpdatesAutomatically(std::shared_ptr<CLConnectionMessage>)
Client %s is setting AutoPause to %d
kCLConnectionMessageAllowsBackgroundLocationUpdatesKey
void CLLocationSubscription::handleMessageAllowsBackgroundLocationUpdates(std::shared_ptr<CLConnectionMessage>)
Client %s is setting ContinuousBackgroundLocationRequested to %d
kCLConnectionMessageShowsBackgroundLocationIndicatorKey
void CLLocationSubscription::handleMessageShowsBackgroundLocationIndicator(std::shared_ptr<CLConnectionMessage>)
Client %s is setting ContinuousBackgroundLocationIndicatorForAlwaysEnabled to %d
void CLLocationSubscription::startBatching(CLTypeOdometer, CFAbsoluteTime)
BATCH: startBatching called but we're already batching
BATCH: starting client %s
BATCH: scheduling odometer alarm for %.1f
void CLLocationSubscription::startBatching(CLTypeOdometer, CFAbsoluteTime)_block_invoke
BATCH: Odometer errored (%{public}s) for client (%{public}s)
BATCH: Odometer criterion met, waiting for location event to notify client %s
BATCH: Odometer fired (%.1f,%s) but no longer relevant to us
v32@?0@"CLOdometerAlarm"8d16@"NSError"24
BATCH: scheduling timer for %.1f
BatchAlarm.
void CLLocationSubscription::stopBatching()
BATCH: stopBatching called but we're not batching
BATCH: stopping client %s
kCLConnectionMessageBatchAllowedKey
void CLLocationSubscription::handleMessageBatch(std::shared_ptr<CLConnectionMessage>)
BATCH: client %s disallowed Batch
BATCH: How were we batching if this wasn't supported?
kCLConnectionMessageBatchDistanceKey
kCLConnectionMessageBatchTimeoutKey
BATCH: request (%.1fm, %.1fs) will be based on %.1fm (%.1fs), %.1fs for client %s
BATCH: How were we not updating location?
BATCH: How were we batching accuracy was too low?
BATCH: How were we batching if a distance filter was on?
BATCH: distance or timeout was <= 0 (techincally exit criteria has already been satisfied.)
#Notice Location uncertainty too high to allow deferred updates now
#Warning BATCH: odometer is not running, we have no way to know what distance is relative to
BATCH: scheduled batch exit but not off-boarding
void CLLocationSubscription::handleMessageAllowsMapCorrection(std::shared_ptr<CLConnectionMessage>)
%s with CorrectiveCompensation enabled attempting allowsMapCorrection.
kCLConnectionMessageAllowsMapCorrectionKey
CLMM,Client,'%s',pid,%u,allowsMapCorrection,%d,desiredAccuracy,%lf,kNotificationMapMatching,%d
didPause
willResume
void CLLocationSubscription::sendAutopauseStatusMessage(bool)
PAUSE: AutoPause is overridden to off, reject %s message to client '%s'
locationd paused updates to '%s' at %ld:%ld:%ld %ld-%ld-%ld (%.2f). If you believe this was in error, file a radar with a screenshot and your locationd.log
Autopause
locationd paused updates to '%s' at %.2f. client autopause setting: %d, override setting: %d
PAUSE: Sending %s message to client '%s'
kCLConnectionMessageAutopauseStatusKey
kCLConnectionMessageAutopauseOverrideKey
void CLLocationSubscription::sendBatchDidFinish(int)
BATCH: Not batching but tried to finish with error %{public}d
BATCH: Sending didFinishDeferredUpdatesWithError:%d message to client '%s'
kCLConnectionMessageErrorKey
Ongoing visibility assertion
(!!value) != (!!fVisibilityAssertion)
swapVisibilityAssertion
DaemonClient
visibilityAssertion
void CLLocationSubscription::performProcessAssertion(CLClientProcessAssertionReasons)
#Warning Client,%s, pid,%u, is performing batch without location.
void CLLocationSubscription::releaseProcessAssertion(CLClientProcessAssertionReasons)
Client,%s, pid,%u, is performing batch location, allowing idle sleep.
Client,%s, pid,%u, is not performing batch location, preventing task suspend.
Acquiring
oldValue == nullptr
updateVisibilityAssertion
Releasing
void CLLocationSubscription::updateVisibilityAssertion()_block_invoke
#visibility Completing async release of visibility assertion for %{public}s (PID:%{public}d, ptr:%p)
void CLLocationSubscription::updateVisibilityAssertion()
#visibility For %s (PID:%d)  Background:%s  Started:%s  > Needed:%s  Eligible:%s  Action:%s
void CLLocationSubscription::setActivityType(CLClientActivityType)
%s with CorrectiveCompensation enabled attempting setActivityType
CLLS:%p.%s
void CLLocationSubscription::startLocation_nl()
client '%{public}s' not authorized for location; not starting yet
Client '%{public}s' paused, not starting location
client '%{public}s' authorized for location; starting shortly
client '%{public}s' authorized for location; starting now, desiredAccuracy, %{public}.1lf, distanceFilter, %{public}.1lf, operatingMode %{public}d, dynamicAccuracyReductionEnabled %{public}d, allowsAlteredAccessoryLocations %{public}d, activityType %{public}d
@ClxClient, register, %{public}s, accuracy, %{public}.1lf
com.apple.locationd.spectator
Not registering for location updates for %{public}s; the planets don't align
Not registering for location updates for %{public}s; desiredAccuracy is too high
BATCH: stop because accuracy changed %s
register for notification, %d, %s, desiredAccuracy, %.1f
BATCH: stop because distance filtered %s
starting metric session (LocationUpdateSession) for %s
void CLLocationSubscription::startLocation_nl()_block_invoke
received location system state of LocationUpdateSession for %s
v16@?0r^{LocationSystemState=BBBBBiBii}8
void CLLocationSubscription::stopLocation_nl()
BATCH: stop because stopping location for %s
void CLLocationSubscription::registerForAutopause()
Client %s registered for autopause notifications
'%{public}s' failed to become client of CLAutopauseProvider
void CLLocationSubscription::unregisterForAutopause()
PAUSE: Client '%s' unregistered for autopause notifications
#Warning PAUSE: Unregistering for autopause notification when client '%s' does not exist
void CLLocationSubscription::checkPauseState()
PAUSE: '%s' not a location client (%d), or not authorized (%d).
PAUSE: '%s' overridden to off.
PAUSE: '%s' not allowed to pause.
PAUSE: '%s' not backgrounded right now (%.1f).
PAUSE: now clock %f timestamp %f thresh %f.
PAUSE: client: '%s' type: %d states: veh %d fit %d oth %d
PAUSE: '%s' not changing state wasPaused: %d lastState: %d now clock: %f timestamp: %f thresh: %f.
PAUSE: %s (%p) changed from %d to %d
PAUSE: Pausing client '%s'
PAUSE: Resuming client '%{public}s' (This should be handled on framework side)
v16@?0@"CLLocation"8
/System/Library/PrivateFrameworks/IPTelephony.framework
CLGnssProvider
CoarseMetaData
void CLLocationSubscription::deliverLocationToClient(const CLLocationProvider_Type::NotificationData &)_block_invoke
CoarseMetaData found in nvp. Encoded data size : %lu
BATCH: successfully ended for %s
void updateLocationUpdateSessionWithLocation(const CLClientLocation &, CLDaemonStats_Type::LocationUpdateSession &)
The location type is undefined (%d).
v16@?0r^v8
com.apple.locationd.client.accuracyrelationship
DeliveredLocationCount
DesiredHAccuracy
ReportedHAccuracy
void CLLocationSubscription::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
BATCH: location unavailable caused batch failure
Wiring bug: %{public}d should not notify
Wiring bug: unexpected notification
void CLLocationSubscription::onPauseNotification(int, const CLAutopauseProvider_Type::Notification &, const CLAutopauseProvider_Type::NotificationData &)
PAUSE: %s received pause notification %d
void CLLocationSubscription::onBatchTimer(CLPersistentTimer *)
BATCH: Time criterion met, waiting for location event to notify client %s
void CLLocationSubscription::onProactiveCompass(const CLCompass_Type::Sample *)
Compass calibration achieved (L%{public}d) for client '%{public}s'
void CLLocationSubscription::startProactiveCompass()
Scheduling proactive compass start for client '%{public}s' with delay %{public}.2f
void CLLocationSubscription::startProactiveCompassForReal()
Starting compass proactively for client '%{public}s'
void CLLocationSubscription::startProactiveCompassForReal()_block_invoke
Proactive compass timer fired
void CLLocationSubscription::stopProactiveCompass()
Stopped proactive compass timer for client '%{public}s'
Stopped proactive compass for client '%{public}s'
CLLocationSubscription::onLocationNotification
Compass
CLStreamingAwareLocationProvider
CLLocationSubscription::onBatchTimer
CLLocationSubscription::onPauseNotification
CLLocationSubscription::onProactiveCompass
kCLConnectionMessageError
virtual void CLMotionNotifier::SiloDispatcher<CLCompass_Type::Sample>::dispatchData(int, const void *, size_t) [T = CLCompass_Type::Sample]
bool CLSwimWorkoutStopModel::getCurrentEpoch(const CLWorkoutPredictorInputs &, CLSwimWorkoutStopModel::Epoch &)
SwimStop is unable to get tier2 data!,the last swim time is %{public}f
SwimStop is unable to get activity data!,the last swim time is %{public}f
SwimStop is unable to get turn data!,the last swim time is %{public}f
virtual CLWorkoutPredictor_Type::WorkoutStopDetectionEvent CLSwimWorkoutStopModel::update(const CLWorkoutPredictorInputs &)
SwimStop,startTime,%f,tier2Time,%f,epochCount,%d,epochTier2,%ld,bufferCnt,%d,bufferedPed,%d,bufferedSwim,%d,count,%d,style,%d,lastTime,%f,angle,%f,vectorMag,%f,yaw,%f,sinceTurn,%d
const T &CMQueue<CLSwimWorkoutStopModel::Epoch>::operator[](const size_t) const [T = CLSwimWorkoutStopModel::Epoch]
CLCellTilesManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLCellTilesManager.mm
-[CLCellTilesManagerAdapter beginService]
+[CLCellTilesManagerAdapter isSupported]
CLCellTilesManager is not supported in diagnostics mode
CLCellTilesManager::isSupportedTileType(tileType)
-[CLCellTilesManagerAdapter requestCellTileDownloadByType:lat:lon:seckey:]
CLCellTilesManager::CLCellTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLICellTilesManagerExternal>, std::optional<CLTilesSetCollection>)
TILE: fMaxTileSecurityAge, %.1lf
TILE: fEncryptionGracePeriod, %.1lf
TileCell, isActive, %{public}d
CLTilesSetCollection CLCellTilesManager::initializeProductionTilesSetCollection()
TILE: defaultCellTilesServerUrl, %{private}s, overridden, %{public}d
/3/v1
/4/v1
/5/v1
/gsm
CLGsmTileServer
gsm-known
gsm-unknown
/cdma
CLCdmaTileServer
cdma-known
cdma-unknown
/lte
CLLteTileServer
lte-known
lte-unknown
virtual void CLCellTilesManager::shutdown()
TILE: CLCellTilesManager::shutdown
void CLCellTilesManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
TileCell, unexpected, dataprotection, %{public}d
TileCell, kNotificationEncryptedDataAvailability, %d, changed, %d
void CLCellTilesManager::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
TileCell, unexpected, location, %{public}d, %{public}s
TileCell, kNotificationLocationLeech, fLastLocationDownloadCheckTimestamp, %{public}.1lf, isForceLocationCheck, %{public}d, fLastLocationProtectionCheckTimestamp, %{public}.1f, leech location, %{private}s
void CLCellTilesManager::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
TileCell, unexpected, status, %{public}d
TileCell, kNotificationReachability, %{public}d, was, %{public}d
void CLCellTilesManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
TileCell, kNotificationReset
TileCell, kNotificationLocationServicesStatus, %{public}d
TileCell, #CacheDelete kNotificationSoftwareUpdateStorageRecovery
void CLCellTilesManager::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
TileCell, unexpected, companion, %{public}d
void CLCellTilesManager::onTimerFired(CLPersistentTimer *)
TileCell, Timer, %{public}d, locked, %{public}d
void CLCellTilesManager::onCleanupAgedTiles()
TileCell, Cleanup
CLCellTilesManager::traverseAllTilesSets
void CLCellTilesManager::traverseAllTilesSets(const char *, CLCellTilesManager::CLTileManagerTraverseTilesSetBlock)
void CLCellTilesManager::listAvailableFilesAllTypes(CFAbsoluteTime)
TileCell, listAvailableFilesAllTypes, indexed, %{public}d
TileCell, clear on index
TileCell, listAvailableFilesAllTypes, done
bool CLCellTilesManager::indexTiles(CLTilesSet &, CFAbsoluteTime)
TileCell, indexTiles, rootDirectory, %{public}s, name, %{public}s
TileCell, indexTiles, can't open dir, %{public}s, #CloneMe
TileCell, indexTiles, absoluteFilename, '%{public}s', d_type, %{public}d
TileCell, indexTiles, invalid filename  %{public}s
TileCell, convert to class B, first unlock, %{public}s, files, %{public}d
TileCell, indexTiles, failed to stat file, %{public}s, ret, %{public}d, #CloneMe
TileCell, indexTiles, done, %{public}s, size, %{public}lu, unprotected, %{public}lu
bool CLCellTilesManager::requestDownload(CLTilesManager_Type::TileType, double, double, sec_key_t, CFAbsoluteTime)
TileDl, ignore before first unlock, fDataProtectionEnabled, %{public}d
@TileDl, requestDownload, type, %{public}d, %{private}s, not active
TileDl, requestDownload, type, %{public}d, %{public}s, location, %{private}14.8lf, %{private}14.8lf, id, %{private}s, reachbility, %{public}d
@TileSched, cell, set, %{public}d
bool CLCellTilesManager::checkDownloadSchedule(CFAbsoluteTime)
@TileDl, cell, failed criteria
static void CLCellTilesManager::tileDownloadCallback(CLFileDownload *, bool, void *)_block_invoke
cellTileDownloaded
void CLCellTilesManager::tileDownloadCompleted(CLFileDownload *, bool, void *)
void CLCellTilesManager::sendNotificationTileWasDownloaded(bool, const CLTileFile &, const CLTilesSet &, unsigned int)
@TileDl, kNotificationTileWasDownloaded, tileid, %{private}s, tileHeaderParsed, %{public}d, tileType, %{public}d, serverUrl, %{private}s, serverFilename, %{private}s, absoluteLocalFilename, %{private}s, size, %{public}d, current, %{public}d
void CLCellTilesManager::refreshTilesDataIfNeeded()_block_invoke
bool CLCellTilesManager::getLocationByCellFromTile(CLTileFile *, const CLCell &, CLCellTilesManager::SearchContext &, CLDaemonLocation &)
TILE: no cell tiles for, %s
bool CLCellTilesManager::getLocationByCell(const CLCell &, const CLDaemonLocation &, CLCellTilesManager::SearchContext &, CLDaemonLocation &)
CellTile, getLocationByCell, un-supported cell type, %{private}s, #CloneMe
TILE: getLocationByCell, tiles, %d, are not active on this device
TILE: getLocationByCell, isInKnownCache, %d, isInUnKnownCache, %d
TILE: getLocationByCell, using locationHint, %s
TILE: getLocationByCell, out of boundary, %s
TILE: getLocationByCell, search neighbor, step, %2d, y, %+2d, x, %+2d
TILE: getLocationByCell, search remaining tiles, %s
clearLocationInformationCell
void CLCellTilesManager::clearLocationInformation()
TileCell, %{public}s
label
void CLCellTilesManager::removeAllTiles(bool, CLTilesManager_Type::TileType)
TileCell, %{public}s, removeAllTiles, size, %{public}lu
TILE: removeAllTiles, end, name, %s, size, %lu, unprot size, %lu
void CLCellTilesManager::deleteAgedTiles(CFAbsoluteTime)_block_invoke
TileCell, deleteAgedTiles, dispatch, %{public}s
TileCell, deleteAgedTiles, start, name, %{public}s, size, %{public}lu
void CLCellTilesManager::agedTileDeleter(CLTilesSet &, CFAbsoluteTime)
TileCell, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu, name, %{private}s
void CLCellTilesManager::updateProtectionClass(const char *, const CLDaemonLocation &, bool)
void CLCellTilesManager::updateProtectionClass(const char *, const CLDaemonLocation &, bool)_block_invoke
TILE: updateProtectionClass, start, %s, reason, %s, isAboutToLock, %d, locationAge, %.1lf, doLocCheck, %d, sizes, %lu, %lu, knownLocation, %s
CellTile, tile ptr is NULL, #CloneMe
CellTile, updateProtectionClass, failed unlocking tileid, %{private}s, size, %{public}lu, #CloneMe
CellTile, updateProtectionClass, unable to lock tile, locking tileid, %{private}s, #CloneMe
CellTile, %{public}s, locking, %{public}d, lock, %{public}d, unlock, %{public}d, size, %{public}lu
CellTile, Unable to lock all unprotected files!, #CloneMe
void CLCellTilesManager::lockTileIfNeeded(CLTileFile *, CLTilesSet &, CFAbsoluteTime, const char *)
@TileList, %{public}s, unprotect, llsw, %{private}.2lf, %{private}.2lf, %{public}s, size, %{public}lu
void CLCellTilesManager::scheduleExpiredLocationTimer(const char *)
TileTimer, skip, location, %{public}d
TileTimer, schedule, reason, %s, locationAge, %.1lf, secondsFromNow, %.1lf, lastKnownLocation, %s
void CLCellTilesManager::cancelExpiredLocationTimer()
TileTimer, cancel
std::tuple<bool, CLTileFile *> CLCellTilesManager::createTileFileObject(CLTilesManager_Type::TileType, const std::string &, const std::string &, CFAbsoluteTime)
void CLCellTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)
void CLCellTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)_block_invoke
CellTile, Invalid tile id!, #CloneMe
virtual void CLCellTilesManager::onScheduledTileDownloadsCallback(CLTileDownloadReachabilityRequirement)
@TileSched, cell, called, %{public}ld
CLCellTilesManager::onTimerFired
virtual void CLEntryCache<std::string, CLDaemonLocation>::clear() [Key_T = std::string, DataEntry_T = CLDaemonLocation]
CACHE: name, %s, clear, size, %lu
virtual void CLEntryCache<std::string, CLDaemonLocation>::deleteAgedEntries() [Key_T = std::string, DataEntry_T = CLDaemonLocation]
CACHE: name, %s, deleteAgedEntries, size, %lu
void CLEntryCache<std::string, CLDaemonLocation>::evict() [Key_T = std::string, DataEntry_T = CLDaemonLocation]
CACHE: name, %s, evict, aged, age, %.1lf, size, %lu, %lu, key, %s
CACHE: name, %s, evict, size, age, %.1lf, size, %lu, %lu, key, %s
virtual void CLNotifier<CLCellTilesManager_Type::Notification, CLCellTilesManager_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLCellTilesManager_Type::Notification, NotificationData_T = CLCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLCellTilesManager_Type::Notification, CLCellTilesManager_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLCellTilesManager_Type::Notification, NotificationData_T = CLCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
bool CLEntryCache<std::string, CLDaemonLocation>::getEntry(const Key_T &, DataEntry_T &) [Key_T = std::string, DataEntry_T = CLDaemonLocation]
CACHE: name, %s, getEntry, end, size, %lu, %s, entry, %s
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLEntryCache.h
insertToAgeSet
ret.first != this->fAgeSet.end()
void CLEntryCache<std::string, CLDaemonLocation>::addEntry(const Key_T &, const DataEntry_T &) [Key_T = std::string, DataEntry_T = CLDaemonLocation]
CACHE: name, %s, bad set iterator - recovering, size, %lu, %s
CACHE: name, %s, cache too large, evicting, size, %lu
CACHE: name, %s, addEntry, end, size, %lu, %s, entry, %s
virtual void CLNotifier<CLCellTilesManager_Type::Notification, CLCellTilesManager_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLCellTilesManager_Type::Notification, NotificationData_T = CLCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCellTilesManager_Type::Notification, CLCellTilesManager_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLCellTilesManager_Type::Notification, NotificationData_T = CLCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCellTilesManager_Type::Notification, CLCellTilesManager_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLCellTilesManager_Type::Notification, NotificationData_T = CLCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLCellTilesManager_Type::Notification, CLCellTilesManager_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLCellTilesManager_Type::Notification, NotificationData_T = CLCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLCellTilesManager_Type::Notification, CLCellTilesManager_Type::NotificationData, char, char>::listClients() [Notification_T = CLCellTilesManager_Type::Notification, NotificationData_T = CLCellTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLAutopauseProviderConcrete::CLAutopauseProviderConcrete(id<CLIntersiloUniverse>)
PAUSE: Constructing CLAutopauseProviderConcrete
void CLAutopauseProviderConcrete::startMonitoringPauseState()
PAUSE: Starting auto-pause monitoring.
void CLAutopauseProviderConcrete::stopMonitoringPauseState()
PAUSE: Stopping auto-pause monitoring.
void CLAutopauseProviderConcrete::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
PAUSE: Batched notification response in auto-pause with %zu locations.
void CLAutopauseProviderConcrete::onLocationNotificationHelper(const CLDaemonLocation &)
PAUSE: Pause state changed, notifying - fitness: %d navigation: %d other: %d
void CLAutopauseProviderConcrete::onMotionNotification(int, const CLMotionState_Type::Notification &, const CLMotionState_Type::NotificationData &)
#Warning PAUSE: unexpected notification %d
#Warning PAUSE: Unknown notification %d
void CLAutopauseProviderConcrete::onLocationTimer()
PAUSE: Autopause provider has no location updates for 15 minutes.
void CLAutopauseProviderConcrete::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
PAUSE: got kNotificationSleep.
PAUSE: got kNotificationWake.
CLAutopauseProviderConcrete::onLocationNotification
CLAutopauseProviderConcrete::onMotionNotification
CLAutopauseProviderConcrete::onStatusNotification
Unspecified
Stats
Accelerometer
AopAccel800
AopGyro200
AopQuaternion6
FalsePositiveSuppressionFeatures
WristState
v32@?0@"NSString"8@"NSMutableSet"16^B24
v24@?0@"NSString"8@"CLFallLogger"16
com.apple.CoreMotion.CLFallManager.flush
v16@?0@"NSData"8
+[CLFallLoggerManager encodeBinaryLog:]
bufferLength(%{public}d)!=kSize(%{public}d)
void CLVehicleSpeedFilter::update(const CFAbsoluteTime &, const double &, bool &, double &)
#Warning,SpeedFilter,%{public}.1lf,unexpected,vehicleSpeed < 0
-[CMStrideCalibrator(CLNotifiers) checkLocationAuthorization]
EnableLocationServices,Success,AllChecksPassed
-[CMStrideCalibrator(CLNotifiers) isAuthorizedForLocation]
EnableLocationServices,Fail,PedometerCalibrationLocationServicesDisabled
EnableLocationServices,Success
-[CMStrideCalibrator(Callbacks) onMotionStateMediatorNotification:data:]
StrideCal - Register tracks activity %d, override action, %d, session, %@
void onCompanionNotification_bounce(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &, void *)
hrse
coarse-gsm
coarse-cdma
coarse-lte
preload manifest
transit mac
coarse-nr
static bool CLTilesManagerUtility::isCurrentTile(const CLTileFile *, CFTimeInterval, CLDaemonLocation, CFAbsoluteTime)
@TileDl, isCurrent, %{public}d, inside, %{public}d, %{public}d, locknown, %{public}d, %{public}d, %{public}d, %{public}d, tile, %{private}s, delta, %{public}.02f
static CLTilesSet &CLTilesManagerUtility::getTilesSet(CLTilesManager_Type::TileType, CLTilesSetCollection *)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLTilesManagerUtility.mm
static void CLTilesManagerUtility::deleteIfDuplicate(CLTileFile *, CLTilesSet &, const char *)
@TileList, %{public}s, duplicate, llsw, %{private}.2lf, %{private}.2lf, %{public}s, size, %{public}lu
allocateTile
static std::unique_ptr<CLTileFile> CLTilesManagerUtility::allocateTile(CLTilesManager_Type::TileType, CLTileDownloadPolicy *)
TileMgr, failed to allocate a tile for type, %{public}d, #CloneMe
LogDeviceMotion
CLDeviceMotion
static CLDeviceMotion::CLDeviceMotionNotification CLDeviceMotion::CLMotionTypeDeviceMotionModeToCLDeviceMotionNotification(const CLMotionTypeDeviceMotionMode)
No viable conversion for mode %{public}#x
static CLMotionTypeDeviceMotionMode CLDeviceMotion::CLDeviceMotionNotificationToCLMotionTypeDeviceMotionMode(const int)
No viable conversion for notification %{public}#x
properties != nullptr
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/Notifiers/CLDeviceMotion.mm
addDeviceMotionDispatcher_block_invoke
void CLDeviceMotion::addDeviceMotionDispatcher(CLDeviceMotion::Dispatcher *, CFTimeInterval)_block_invoke
CLDeviceMotion::addDeviceMotionDispatcher adding dispatcher with property: %{public}s
removeDeviceMotionDispatcher_block_invoke
void CLDeviceMotion::removeDeviceMotionDispatcher(CLDeviceMotion::Dispatcher *)_block_invoke
CLDeviceMotion::removeDeviceMotionDispatcher removing dispatcher with property: %{public}s
virtual CFTimeInterval CLDeviceMotion::minimumUpdateIntervalChanged(int, const CFTimeInterval &)
CLDeviceMotion::minimumUpdateIntervalChanged,notification,%{public}d,minimumUpdateInterval,%{public}f
minimumUpdateInterval GyroOnly:%{public}f, 3AxisDynamicGyro:%{public}f, 6Axis:%{public}f, 6AxisThrottledGyro:%{public}f, 9Axis:%{public}f, 9AxisWithNorthReference:%{public}f, 9AxisWithTrueNorthReference:%{public}f, BuildGYTT:%{public}f
virtual void CLDeviceMotion::numberOfClientsChanged(int, size_t, size_t)
CLDeviceMotion::numberOfClientsChanged notification:%{public}d, from:%{public}zu, to:%{public}zu
numberOfClients GyroOnly:%{public}zd, 3AxisDynamicGyro:%{public}zd, 6Axis:%{public}zd, 6AxisThrottledGyro:%{public}zd, 9Axis:%{public}zd, 9AxisWithNorthReference:%{public}zd, 9AxisWithTrueNorthReference:%{public}zd, BuildGYTT:%{public}zd
fSensorFusionService9Axis->isRunning()
numberOfClientsChanged
Device motion mode (%{public}d) not supported, can't process client change
bool CLDeviceMotion::isModeValid(const CLMotionTypeDeviceMotionMode &) const
Unsupported mode (%{public}d). Returning.
Unsupported mode (%{public}d). Compass not found. Returning.
Unsupported mode (%{public}d). Couldn't do DeviceMotion without Gyro. Returning.
void CLDeviceMotion::enableSensorFusionWithMode(const CLMotionTypeDeviceMotionMode &)
Starting device motion, mode=%{public}#x,useAccelerometer=%{public}d,useGyro=%{public}d,useCompass=%{public}d,fUseNorthRef=%{public}d,buildingGYTT=%{public}d
void CLDeviceMotion::disableSensorFusionWithMode(const CLMotionTypeDeviceMotionMode &)
Stopping device motion, mode=%{public}#x
Device motion mode (%{public}d) not supported, unable to disable sensor fusion
void CLDeviceMotion::registerForGeomagneticModelNotification()
Registering for geomagnetic model updates
void CLDeviceMotion::unregisterForGeomagneticModelNotification()
Unregistering for geomagnetic model updates
static void CLDeviceMotion::onGeomagneticModelNotification(int, const CLGeomagneticModelProvider_Type::Notification &, const CLGeomagneticModelProvider_Type::NotificationData &, void *)
Received geomagnetic model, declination,%f,timestamp,%f
CLPlatformInfo::motionCaps().deviceMotion6Service
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/DeviceMotion/CLSensorFusionServiceSPU.h
CLSensorFusionService6AxisSPU
CLPlatformInfo::motionCaps().deviceMotionService
CLSensorFusionService9AxisSPU
ForceOneButtonWorkouts
kCLConnectionMessageSetWorkoutTimeout
kCLConnectionMessageUserDismissedWorkoutAlert
kCLConnectionMessageWorkoutPrompts
kCLConnectionMessageTriggerWorkoutLocationEventForTesting
void CLWorkoutSubscription::handleMessageWorkoutStart(std::shared_ptr<CLConnectionMessage>)
Workout, Duplicate START, %@, %s, %p
Forcing workout from workoutType: %zd, locationType: %zd, to workoutType: %zd, locationType: %zd
Passed an invalid HKWorkoutActivityType of %lu
Workout, STARTING, %@, %s, %p
Unable to start workout, another client has an active workout.
void CLWorkoutSubscription::handleMessageWorkoutStop(std::shared_ptr<CLConnectionMessage>)
No active workouts to stop, requested, %@, %p, %p
Workout, STOPPING, %@, %p, %p
void CLWorkoutSubscription::handleRequestWorkoutEvent(bool, const CLNameValuePair &)
Workout, event subscription changed, %d, %s, %p
void CLWorkoutSubscription::handleMessageSetWorkoutTimeout(std::shared_ptr<CLConnectionMessage>)
No active workouts to set a timeout for!
Workout, setting workout timeout %f.
void CLWorkoutSubscription::handleMessageTriggerWorkoutLocationEventForTesting(std::shared_ptr<CLConnectionMessage>)_block_invoke
No active workouts or defaults write not set to force location updates!
Workout, LOCATION UPDATE FOR TESTING %zd.
void CLWorkoutSubscription::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)
Suppressing workout event for cycling,%ld
Error delivering event, %s, %p
bool CLWorkoutSubscription::isMotionCalibrationAuthorized()
CMCyclingWorkoutAlertsEnabled
CLWorkoutSubscription::onMotionStateMediatorNotification
virtual bool CLActivityLoggerRatePolicy::shouldILog(NSData *)
shouldILog returned %d for tag %d, last %f now %f, threshold is %lu
CLElevationChangeEntry CLWorkoutElevationFusion::feedPhoneBaroElevation(const CLElevationChangeEntry &)
WorkoutElevationFusion,phone source time rolled back, now %f, prev, %f
CLElevationChangeEntry CLWorkoutElevationFusion::feedWatchBaroElevation(const CLElevationChangeEntry &)
WorkoutElevationFusion,watch source time rolled back, now %f, prev, %f
CLElevationChangeEntry CLWorkoutElevationFusion::tick()
WorkoutElevationFusion,unexpected timestamp on source switch,fElevationWatch.startTime,%f
CLElevationChangeEntry CLWorkoutElevationFusion::fuseElevation(CLElevationSource)
WorkoutElevationFusion,source,%d,deltaH,%f
bool CLWorkoutElevationFusion::baroLessVariable(const std::deque<double> &) const
WorkoutElevationFusion,VariabilityCheck,Baro,%f,Source,%f
void CLWorkoutElevationFusion::updateSourceAvailability()
WorkoutElevationFusion,BaroQuality,%d,DEMSourceAvailable,%d,GPSSourceAvailable,%d
void CLWorkoutElevationFusion::logAndClearStatistics(CLMotionActivity::Type)
WorkoutElevationFusion,WorkoutType,%d,BaroGood,%d,BaroUnkDEMAgree,%d,DEMBaroUnk,%d,BaroUnkDEMDisagree,%d,BaroUnkNoDEM,%d,DEMBaroBad,%d,None,%d,GPSBaroGood,%d,GPSBaroUnk,%d,GPSBaroBad,%d,GPSUnvailBaroGood,%d,GPSUnvailBaroUnk,%d,GPSUnvailBaroBad,%d,TransBaroDEM,%d,TransToGPS,%d,TransBaroToNone,%d,TransDEMToNone,%d,TransGPSToNone,%d
bool CLWorkoutElevationFusion::baroAgreesWith(const T &) [T = CLFlexibleMedianFilter<double>]
WorkoutElevationFusion,ResidualCheck,agree,%d,max-min,%f,median,%f,residual,%f
clientDictionary
clientName
archivedPayload
com.apple.locationd.Fall.WalkingSteadinessQuery
CLFallUserInfoMetrics::CLFallUserInfoMetrics(CLSilo *)_block_invoke
void CLFallUserInfoMetrics::queryWalkingSteadinessHK(xpc_activity_t)_block_invoke
Walking steadiness query returned empty for CoreAnalytics
Error querying walking steadiness for CoreAnalytics, %d
virtual void CLFallUserInfoMetrics::sendEventToCoreAnalytics() const
UserInfo health not sent to CoreAnalytics because logging not enabled
com.apple.CoreMotion.FallUserInfo
isFallDetectionAvailable
didEnableAnomalyDetection
didEnableBackgroundAllDayAnomalyDetection
isImproveHealthAndFitnessOptInEnabled
Sending UserInfo to CoreAnalytics
maxAccelNormThreshold
userAgeBin
userMaxMets
userWalkingSteadiness
CLWifiTilesManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLWifiTilesManager.mm
-[CLWifiTilesManagerAdapter beginService]
+[CLWifiTilesManagerAdapter isSupported]
CLWifiTilesManager is not supported in diagnostics mode
CLWifiTilesManager::CLWifiTilesManager(id<CLIntersiloUniverse>, std::unique_ptr<CLIWifiTilesManagerExternal>, std::shared_ptr<CLWifiAccessPointLocationService>, std::optional<CLTilesSetCollection>, std::optional<std::unique_ptr<CLITileSyncManager>>)
WIFITILE: fDefaultMaxDownloadListSize, %d
WIFITILE: MTimeModificationPeriod, %.1lf
@TileEvent, wifi, locked, %d
WifiTilesServerUrl
CLTilesSetCollection CLWifiTilesManager::initializeProductionTilesSetCollection()
TILE: defaultWifiTilesServerUrl, %{private}s, overridden, %{public}d
WIFITILE: fDefaultEncryptionGracePeriod, %.1lf
WIFITILE: fDefaultDisableTilesWhileLocked, %d
CLWifiTileServer
void CLWifiTilesManager::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
WIFITILE: onDataProtectionNotification, %p, notification, %d
WIFITILE: onDataProtectionNotification, kNotificationEncryptedDataAvailability, was, %d, now, %d, availability, %d
WIFITILE: updateProtectionClass, skip on unlock
Unlock
void CLWifiTilesManager::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
clearLocationInformationWifi
virtual void CLWifiTilesManager::clearLocationInformation()
WIFITILE: %{public}s
void CLWifiTilesManager::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
WIFITILE: onClientNotification, %p, notification, %d
WIFITILE: kNotificationReset
WIFITILE: kNotificationLocationServicesStatus, areLocationServicesEnabled, %{public}d
WIFITILE: #CacheDelete kNotificationSoftwareUpdateStorageRecovery
void CLWifiTilesManager::deleteAgedDownloadItems(std::map<TileId, std::unique_ptr<CLTileFile>> &, CFAbsoluteTime)
WIFITILE: deleteAgedDownloadItems, start
tile->getTileType() == CLTilesManager_Type::TileType::WIFI_Location
deleteAgedDownloadItems
WifiTile, deleteAgedDownloadItems, delete, age, %{public}.1lf, %{public}.1lf, tile, %{private}s
@TileReq, wifi, rmlist, llsw, %{private}.2lf, %{private}.2lf, aged, size, %{public}ld
WIFITILE: deleteAgedDownloadItems, deleted, %u, done
void CLWifiTilesManager::deleteTilesExceedingLimits(CFAbsoluteTime)
WIFITILE: deleteAgedTiles, start, name, %s, size, %lu
Missing wifi #tile, x, %{private}d, y, %{private}d, #CloneMe
Deleted wifi #tile isFileExistsOnServer is false. x, %{private}d, y, %{private}d, #CloneMe
@TileList, wifi, delete, llsw, %{private}.2lf, %{private}.2lf, limits, size, %{public}lu
WIFITILE: deleteAgedTiles, end, numOfDeletedTiles, %lu, remain, %lu, name, %s
virtual bool CLWifiTilesManager::isCurrentTile(CLTileFile *)
WIFITILE: isCurrentTile, degreesFromCornerLat, %.8lf, degreesFromCornerLon, %.8lf, inside, %d, %d, isCurrentTile, %d, %d, isCurrentLocationKnown, %d, %s
virtual void CLWifiTilesManager::deleteAgedTiles(CFAbsoluteTime)
WIFITILE: dispatch, deleteAgedTiles, for, %s
WIFITILE: deleteAgedTiles, fTilesToDownload
void CLWifiTilesManager::cancelAllDownloads()
WIFITILE: cancelAllDownloads, planned, %lu
virtual void CLWifiTilesManager::removeAllTiles(bool, CLTilesManager_Type::TileType)
WIFITILE: removeAllTiles, cleaning map, %d, %s
@TileList, wifi, delete, llsw, %{private}.2lf, %{private}.2lf, all, size, %{public}lu
WIFITILE: removeAllTiles, end, name, %s, size, %lu, unprot size, %lu, downloadSize, %lu
void CLWifiTilesManager::populateTilesSet(CFAbsoluteTime)
wifi #tiles, populateTilesSet
@TileEvent, wifi, indexed, %{public}lu
void CLWifiTilesManager::refreshTilesDataIfNeeded()
WIFITILE: refreshTilesDataIfNeeded, isTileDataExpired, %d, isShouldBeDownloaded, %d, tile, %s
@TileSched, wifi, set, %{public}d
void CLWifiTilesManager::checkDownloadSchedule(CLWifiTilesManager::DownloadPriority, CFAbsoluteTime)
WIFITILE: checkDownloadSchedule, wifi off - no tile downloads
WIFITILE: checkDownloadSchedule, location services disabled - no tile downloads
WIFITILE: checkDownloadSchedule, index is not available until first unlock, fDataProtectionEnabled, %{public}d
WIFITILE: checkDownloadSchedule, no data connectivity, avoiding downloads, reachability, %{public}d, companion, %{public}d
WIFITILE: checkDownloadSchedule, no download on none broadband cellular connections
WIFITILE: checkDownloadSchedule, skip, wifion, %{public}d, ls, %{public}d, indexed, %{public}d, protection, %{public}d, lockdisable, %{public}d, reach, %{public}d, companion, %{public}d, broadband, %{public}d
WIFITILE: checkDownloadSchedule, numOfActiveDownloads, %{public}d, not scheduling more
WIFITILE: checkDownloadSchedule, both download requests are already in use
WIFITILE: checkDownloadSchedule, both download requests null, shutdown?
WIFITILE: checkDownloadSchedule, skip, active, %{public}d, inprogress, %{public}d, %{public}d, shutdown, %{public}d, %{public}d
WIFITILE: checkDownloadSchedule, priority, %{public}d, lastLocation, %{private}s
WIFITILE: checkDownloadSchedule, chose, downloadState, %{public}s
WIFITILE: checkDownloadSchedule, started downloading, numOfActiveDownloads, %{public}d, tile, %{private}s
@TileReq, wifi, start, llsw, %{private}.2lf, %{private}.2lf, reach, %{public}d, url, %{private}s
WIFITILE: checkDownloadSchedule, numOfActiveDownloads, %{public}d, tilesToDownload, %{public}lu, small, %{public}d, large, %{public}d
WIFITILE: checkDownloadSchedule, NoActiveDownloads
int CLWifiTilesManager::getDownloadConnectionType(CLTileFile *)
WIFITILE: checkDownloadSchedule, rule, isCurrent, isAllowCellularIfCurrent,  IsOkToDownloadRealtime, %s
WIFITILE: checkDownloadSchedule, rule, isCurrent, fDownloadCurrentTileOverCell, IsOkToDownloadRealtime, %s
WIFITILE: checkDownloadSchedule, rule, isCurrent, IsOkToDownloadLarge, %s
WIFITILE: checkDownloadSchedule, rule, isAllowCellularIfNotCurrent, IsOkToDownloadRealtime, %s
WIFITILE: checkDownloadSchedule, rule, IsOkToDownloadLarge, %s
wifiTileDownloaded
void CLWifiTilesManager::tileDownloadCompleted(CLFileDownload *, bool, void *)
WIFITILE: tileDownloadCompleted, tile, %s, download done, success, %d, NSURLErrorCode, %d, tileDoesNotExist, %d, reachability, %d, locked, %d, fileSize, %d
@TileReq, wifi, downloaded, llsw, %{private}.2lf, %{private}.2lf, success, %{public}d, NSURLErrorCode, %{public}d
WifiTile, where did this download request come from?, download, %{public}p, #CloneMe
void CLWifiTilesManager::tileDecompressionCompleted(CLFileDownload *, bool, void *, CFAbsoluteTime)
Null pointer in fTilesToDownload
WifiTile, tileDecompressionCompleted, no tile for download, %{public}p, #CloneMe
tileRef.getTileType() == CLTilesManager_Type::TileType::WIFI_Location
WIFITILE: tileDecompressionCompleted, tile, %s, decompress done, tileDownloadWasSuccessful, %d, NSURLErrorCode, %d, tileDoesNotExist, %d, reachability, %d
WIFITILE: tileDecompressionCompleted, tile, %s, reachability, %d, isLocked, %d, downloadDuration, %.1lf, downloadState, %s, progress, s, %d, l, %d
WIFITILE: tileDecompressionCompleted, replacing from, %s
WIFITILE: tileDecompressionCompleted, replacing to, %s
WIFITILE: tileDecompressionCompleted, added, tileid, %s, tilesMap.size, %lu
Download
@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, download, size, %{public}lu
void CLWifiTilesManager::sendNotificationTileWasDownloaded(bool, const CLTileFile &, const CLTilesSet &)
WIFITILE: kNotificationTileWasDownloaded, tileid, %s, tileHeaderParsed, %d, tileType, %d, serverUrl, %s, serverFilename, %s, absoluteLocalFilename, %s
static void CLWifiTilesManager::_tileDownloadCompleted(CLFileDownload *, bool, void *)
WIFITILE: _tileDownloadCompleted, success, %d
static void CLWifiTilesManager::_tileDownloadCompleted(CLFileDownload *, bool, void *)_block_invoke
unsigned int CLWifiTilesManager::getNumOfActiveDownloads()
WIFITILE: getNumOfActiveDownloads, tile, %s, is being downloaded, %d, total, %d, download, %p
tileType == CLTilesManager_Type::TileType::WIFI_Location
bool CLWifiTilesManager::requestDownload(CLTilesManager_Type::TileType, double, double, const std::string &, const CLTileFileDownloadDetails &, CFAbsoluteTime)
WIFITILE: requestDownload, type, %d, %s, not active
@TileDl, wifi, request, llsw, %{private}.2lf, %{private}.2lf, currOverCell, %{public}d
TileDl, wifi, %{public}s
WIFITILE: requestDownload, index is not available until first unlock, fDataProtectionEnabled, %d
!tilesSet.fSecKeyActive
WIFITILE: requestDownload, tileId=%s isAlreadyDownloaded, %d, isBeingDownloaded, %d, shouldDownloadedBasedOnPermissions, %d, isAlreadyDownloaded, %d
WIFITILE: requestDownload, tileid, %s, already available, isUpdateMTimestamp, %d, isShouldBeRefreshed, %d, isBeingDownloaded, %d
WIFITILE: requestDownload, refresh download, %s
WIFITILE: requestDownload, tileid, %s, will be downloaded, details, %s, updated, %d
WIFITILE: requestDownload, tileid, %.8lf, %8lf, will be downloaded, details, %s
@TileReq, wifi, onlist, llsw, %{private}.2lf, %{private}.2lf, center, size, %{public}ld
WIFITILE: requestDownload, out of boundaries, y, %d, x, %d, tile_y, %d, tile_x, %d, neighbourTileID, %s
WIFITILE: requestDownload, y, %d, x, %d, tile_y, %d, tile_x, %d, neighbourTileID, %s
WIFITILE: requestDownload, adding neighbour, %s
@TileReq, wifi, onlist, llsw, %{private}.2lf, %{private}.2lf, neighbor, size, %{public}ld
fTilesToDownload.find(tileIdToDownload) == fTilesToDownload.end()
bool CLWifiTilesManager::addToDownloadList(std::unique_ptr<CLTileFile>, const TileId &, const CLTileFileDownloadDetails &)
WIFITILE: addToDownloadList, added, %s, fTilesToDownload.size, %lu
void CLWifiTilesManager::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
WIFITILE: onLocationNotification, ignore leech when LS off
WIFITILE: onLocationNotification, index is not available until first unlock, fDataProtectionEnabled, %{public}d
WIFITILE: onLocationNotification, fLastLocationDownloadCheckTimestamp, %{public}.1lf, isForceLocationCheck, %{public}d, fLastLocationProtectionCheckTimestamp, %{public}.1f, leech location, %{private}s
WIFITILE: onLocationNotification, unknown notificaiton, %d, %s
void CLWifiTilesManager::onStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
WIFITILE: onStatusNotification, kNotificationReachability, from, %d, to, %d
virtual void CLWifiTilesManager::onScheduledTileDownloadsCallback(CLTileDownloadReachabilityRequirement)
@TileSched, wifi, called, %{public}ld
void CLWifiTilesManager::cleanUpDownloadList(CFAbsoluteTime)
WIFITILE: cleanUpDownloadList, start, isLocked, %d
tileFile->getTileType() == CLTilesManager_Type::TileType::WIFI_Location
cleanUpDownloadList
WIFITILE: cleanUpDownloadList, tileid, %s, available on disc, no need to download
WIFITILE: cleanUpDownloadList, done,  isLocked, %d, cleanedFiles, %u
virtual void CLWifiTilesManager::shutdown()
WIFITILE: CLWifiTilesManager::shutdown
virtual CLTilesSet &CLWifiTilesManager::getTilesSet()
WifiTile, invalid tileType, %{private}d, #CloneMe
void CLWifiTilesManager::updateTileLocationRelevancy(const CLDaemonLocation &)
WIFITILE: tiles, %s, not active
WIFITILE: location not relevant
void CLWifiTilesManager::addAnyRawWifiTilesToDatabaseThenDeleteRecursive(CFAbsoluteTime, std::vector<std::string>)
#tiles, data protection enabled, ending side load.
#tiles, finished side-loading raw wifi tiles from disk
#tiles, side loading wifi tile from disk, %{private}s
void CLWifiTilesManager::addAnyRawWifiTilesToDatabaseThenDelete(CFAbsoluteTime)
Side loading already in progress.
void CLWifiTilesManager::addWifiTileToDatabaseAndDelete(const std::string &, CFAbsoluteTime)
#warning, failed to unlock wifi tile, %{private}s
@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, rawfile, size, %{public}lu
RawFile
#warning, failed to save wifi #tile in db, %{private}s
fWifiAccessPointLocationService->fConfirmedCorrectSchemaInUse
discoverWifiTilesAvailable
std::map<TileId, CLTileFile *> CLWifiTilesManager::discoverWifiTilesAvailable(cl::chrono::CFAbsoluteTimeClock::time_point)
Failed to create tile file object, %{private}s
@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, database, size, %{public}lu
WIFITILE: db to map, %lu, %lu
https://cl2.apple.com/1/v1
updateTileFileObject
results.size() == 1
touchMTime
void CLWifiTilesManager::touchMTime(CFAbsoluteTime, CLTileFile *, bool *)
@TileList, wifi, touch, llsw, %{private}.2lf, %{private}.2lf, time, %{public}.1f
static std::vector<std::string> CLWifiTilesManager::listFilesInDirectory(const std::string &)
#warning, failed to read directory, %{private}s
virtual void CLNotifier<CLWifiTilesManager_Type::Notification, CLWifiTilesManager_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLWifiTilesManager_Type::Notification, NotificationData_T = CLWifiTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLWifiTilesManager_Type::Notification, CLWifiTilesManager_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLWifiTilesManager_Type::Notification, NotificationData_T = CLWifiTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
.download
virtual void CLNotifier<CLWifiTilesManager_Type::Notification, CLWifiTilesManager_Type::NotificationData>::removeClient(int) [Notification_T = CLWifiTilesManager_Type::Notification, NotificationData_T = CLWifiTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLWifiTilesManager_Type::Notification, CLWifiTilesManager_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLWifiTilesManager_Type::Notification, NotificationData_T = CLWifiTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLWifiTilesManager_Type::Notification, CLWifiTilesManager_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLWifiTilesManager_Type::Notification, NotificationData_T = CLWifiTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLWifiTilesManager_Type::Notification, CLWifiTilesManager_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLWifiTilesManager_Type::Notification, NotificationData_T = CLWifiTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLWifiTilesManager_Type::Notification, CLWifiTilesManager_Type::NotificationData>::listClients() [Notification_T = CLWifiTilesManager_Type::Notification, NotificationData_T = CLWifiTilesManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
static void CLBinaryLog::create()
creating the BinaryLog instance
creating fInstance = new CLBinaryLog()
CLBinaryLog::CLBinaryLog()
#Notice Logging binary sensor data to %{public}s
com.apple.locationd.binlog.compression
void CLBinaryLog::rotateIfNeeded(const double &)
Failed to determine if log rotation is needed. errno, %{public}d, %{public}s
#Warning Failed to move aside log file %s to %s (%d)
%s,%s,Failed to delete log: %s
(fMutex).__assertOwned()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Logging/CLBinaryLog.mm
open
void CLBinaryLog::open()
#Warning Unable to open %s
LogFileRotationSizeBinary
LogFileStorageCountBinary
%s,%s,Failed to write CLBinaryLog Buffer to disk
%s,%s,Failed to move file %s to %s (%d)
.bin
locationdSensors
logs
virtual bool CLActivityLoggerMsgPolicy::shouldILog(NSData *)
tagEnabled returns %d for tag %d
T CMMatrix<float, 2>::operator[](size_t) const [T = float, M = 2, N = 2]
T CMVector<float, 2>::operator[](const size_t) const [T = float, N = 2]
T &CMMatrix<float, 2>::operator()(size_t, size_t) [T = float, M = 2, N = 2]
CLAutopauseProviderDummy::CLAutopauseProviderDummy(id<CLIntersiloUniverse>)
PAUSE: Autopause not suppored on this platform, constructing CLAutopauseProviderDummy
virtual bool CLAutopauseProviderDummy::registerForNotificationInternal(const CLAutopauseProvider_Type::Notification &)
PAUSE: Client registered for %s
virtual bool CLAutopauseProviderDummy::unregisterForNotificationInternal(const CLAutopauseProvider_Type::Notification &)
PAUSE: Client unregistered for %s
bool CLWorkoutPredictorTurnDetector::accumulateAngleDeltas(const CMVector<float, 2> &, const CMVector<float, 2> &, const CMVector<float, 3> &)
headingCrown,%f,headingFace,%f,bodySum,%f,cx,%f,cy,%f,fx,%f,fy,%f,gx,%f,gy,%f,gz,%f
T &CMVector<float, 2>::operator[](const size_t) [T = float, N = 2]
-[CLBarometerCalibrationSim feedLocationData:data:]
-[CLBarometerCalibrationSim feedLoiData:]
received visit for altimeter, inVisit, %d
CLNatalimetryNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Calorimetry/CLNatalimetryNotifier.mm
-[CLNatalimetryNotifierAdapter beginService]
-[CLNatalimetryNotifierAdapter queryWorkoutMets:withReply:]
queryWorkoutMets nil sessionId
FallStatsEnabled
CLWorkoutRecorder
LogBinaryNatalimetryOutputs
SimulateVo2MaxEstimates
Catherine
FitnessMachine
CLNatalimetryNotifier.OffSiloQueue
ActiveJacksonCalibration
CLNatalimetryNotifier::CLNatalimetryNotifier(id<CLIntersiloUniverse>)
Found vo2max calibration override flag,%d 
NanolifestyleSessionTrackerAppForegroundedNotification
NanolifestyleSessionTrackerAppForegroundedForMachinePairingNotification
CalorieAggregationTimeInterval
com.apple.locationd.Calorimetry.CalorieAggregation
void CLNatalimetryNotifier::setUpAggregationOnTimer()_block_invoke
void CLNatalimetryNotifier::onCalorieAggregationActivity(xpc_activity_t)
Running aggregation for calorie-related tables
void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)
CalorieAggregation: Estimating MaxMets
CalorieAggregation: Aggregating CalorieHistory
CalorieAggregation: Aggregating MaxMetsHistory
CalorieAggregation: Aggregating ExerciseMinuteHistory
CalorieAggregation: Aggregating VO2Max data
bool CLNatalimetryNotifier::deferXpcActivityIfNecessary(xpc_activity_t)
Attempting to defer CalorieAggregation activity
Failed to mark CalorieAggregation activity as deferred. Current state is %{public}ld
void CLNatalimetryNotifier::markXpcActivityDone(xpc_activity_t)
Failed to mark CalorieAggregation activity as done. Current state is %{public}ld
void CLNatalimetryNotifier::setUpdateFinishedHandler()_block_invoke
CalorieHistory,recordId,%d,startTime,%.3f,duration,%f,activityType,%d,userMets,%lf,calories,%lld,basalCalories,%lld,incrementalActiveCalories,%lld,incrementalBasalCalories,%lld
v120@?0{CLNatalieData=i^{__CFString}diBBddqqd[16C]}8q96q104B112B116
ExerciseMinuteHistory,recordId,%{public}d,startTime,%{public}.3f
v32@?0{CLExerciseMinuteData=id^{__CFString}}8
TimeFirstPAL
void CLNatalimetryNotifier::sanitizeUserProfile(NSMutableArray<NSString *> *)
UserProfile, Error in user info,heightM,%f
UserProfile, Error in user info,ageYr,%f
CLBodyMetrics CLNatalimetryNotifier::setUserProfileToBodyMetrics(NSDictionary *, const CLBodyMetrics &, bool) const
UserProfile,runVo2maxVal,%f,runVo2maxFlag,%d,runVo2maxUpdatedFlag,%d,hronsetVo2max,%f,hronsetVo2maxFlag,%d,derivedVo2max,%f,derivedVo2maxFlag,%d,oldVo2max,%f,estimatedVo2max,%f,mergedVo2max,%f,boundedVo2max,%f,doMerge,%d,betaBlockerUseChanged,%d,adaptiveEmThresh,%f
UserProfile, update completed with result, %{private}@
NumActiveCalibrations
float CLNatalimetryNotifier::mergeVo2max(float, float) const
UserProfile, Number of active vo2max calibrations, %d, first PAL estimate at, %.3f, VO2max delta, %f
bool CLNatalimetryNotifier::readFromDisk(CLBodyMetrics &)
UserProfile, read before device unlock
userinfo
HKBiologicalSex
void CLNatalimetryNotifier::resetUserProfileForKeys(NSArray<NSString *> *)
UserProfile, Resetting to defaults for keys, %@
UserProfile, Resetting ActiveVo2Calibration, NumActiveCalibrations, and TimeFirstPAL.
void CLNatalimetryNotifier::resetBodyMetricFieldsForKeys(NSArray<NSString *> *, CLBodyMetrics &)
UserProfile, resetting CLBodyMetrics for keys: %{private}@
bool CLNatalimetryNotifier::persistCachedValues()
UserProfile, Persistent store not yet initialized 
UserCondition
void CLNatalimetryNotifier::readUserProfile()
UserProfile, Unable to read from disk!
void CLNatalimetryNotifier::setActiveVo2maxOverride(bool)
fActiveVo2maxOverride has been set to %d
void CLNatalimetryNotifier::checkAndNotifyGpsAvailability()
GPS availability at time %lf, companion time, %lf, GPS timestamp, %lf, %d
GPS not available at time %lf
CMCaloriePushModelEnabled
void CLNatalimetryNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)
ActivitySpectator,activity{State,%d,Confidence,%d,MountedState,%d,MountedConfidence,%d,exitState,%d,estExitTime,%f,startTime,%f},nataliFeatures{fVectorMagnitude,%f,fEpochType,%d,fStanding,%d,fMachineFrequency,%f,fRowStrokeFrequency,%f,fRowStrokeAmplitude,%f,fRowStrokePower,%f,fPushVectorMagnitude,%f}
Vo2MaxCalLevel
VO2Max, estimate, %{private}.2f, betaBlockerUser, %{private}d, eligibleForHealthKit, %{private}d
Sending sessionId %@ to CLVO2MaxCloudKitManager
void CLNatalimetryNotifier::onCatherineNotification(int, const CLCatherineNotifier_Type::Notification &, const CLCatherineNotifier_Type::NotificationData &)
Received Onset notification from CatherineNotifier (%f bpm)!
Updating min. HR, %f
void CLNatalimetryNotifier::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
UserProfile, Encrypted data availability, was, %d, now, %d, availability, %d
void CLNatalimetryNotifier::onSessionTrackerAppLaunchNotification(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)
Proactively running HR and Odometer
Proactively running HR
void CLNatalimetryNotifier::onStoredUserInfo(const CLMotionCoprocessorInterface::NotificationData *)
UserProfile, Received from SPU, data protection enabled %d
void CLNatalimetryNotifier::onWatchOrientationSettingsNotification(int, const CLWatchOrientationSettingsNotifier_Type::Notification &, const CLWatchOrientationSettingsNotifier_Type::NotificationData &)
Watch orientation settings updated, crown, %{public}d, wrist, %{public}d
void CLNatalimetryNotifier::onFitnessTrackingNotification(int, const CLFitnessTrackingNotifier_Type::Notification &, const CLFitnessTrackingNotifier_Type::NotificationData &)
HKDataCollector, received mode update of %{public}d and starting collectors
Activity Move Mode changed from %{public}d to %{public}d
HKDataCollector, received mode update of %{public}d and stopping collectors
void CLNatalimetryNotifier::refreshMetrics()
UserProfile, Forcing a pal update.
UserProfile, Forcing a vo2max clear.
UserProfile, Forcing a vo2max update.
UserProfile, Forcing a run vo2max clear.
UserProfile, Forcing a run vo2max update.
virtual void CLNatalimetryNotifier::onExerciseMinuteUpdate(const CLGenericFitnessEstimatorProtocol::ExerciseMinuteUpdate &)
ExerciseMinute, startTime, %{public}f
void CLNatalimetryNotifier::startStopDeviceMotion(bool)
Enabled device motion for calorimetry
Disabled device motion for calorimetry
virtual void CLNatalimetryNotifier::onMoveMinuteUpdate(const CLGenericFitnessEstimatorProtocol::MoveMinuteUpdate &)
MoveMinute, startTime, %{public}f
virtual void CLNatalimetryNotifier::onMoveMinuteUpdate(const CLGenericFitnessEstimatorProtocol::MoveMinuteUpdate &)_block_invoke
HKDataCollector, insertDatums failed to insert a move minute with startTime, %{public}f, error, %{public}@
HKDataCollector successfully pushed move minute update with startTime, %{public}f
void CLNatalimetryNotifier::startCalorieCollectors()
HKDataCollector, attempting to start collectors, pushing calories enabled, %{public}d
HKDataCollector, starting active energy collector
void CLNatalimetryNotifier::startCalorieCollectors()_block_invoke
HKDataCollector, failed to get last active energy sample with error %@
v24@?0@"HKQuantityDatum"8@"NSError"16
HKDataCollector, starting basal energy collector
HKDataCollector, failed to get last basal energy sample with error %@
void CLNatalimetryNotifier::stopCalorieCollectors()
HKDataCollector, attempting to stop initialized collectors
HKDataCollector, stopping active energy collector
void CLNatalimetryNotifier::stopCalorieCollectors()_block_invoke
HKDataCollector, failed to finish with completion for active energy, error, %{public}@
HKDataCollector, successfully finished with completion for active energy
HKDataCollector, stopping basal energy collector
HKDataCollector, failed to finish with completion for basal energy, error, %{public}@
HKDataCollector, successfully finished with completion for basal energy
void CLNatalimetryNotifier::storeVO2maxToHealthKit(const VO2MaxResult &) const_block_invoke
HKHealthStore, VO2Max, saveObjects failed on, %{public}@
VO2Max successfully pushed to HKHealthStore
bool CLNatalimetryNotifier::isVO2MaxAlertEnabled() const
Error retrieving cardio fitness notification status, %{public}@
Cardio fitness, notificationState, %{public}ld, notificationUnavailableReasons, %{public}ld
ForceTriggerVO2MaxAlert
void CLNatalimetryNotifier::writeCardioFitnessEventToHealthKit(VO2MaxAlertResult) const_block_invoke
CardioFitnessEvent failed to push to HKHRCardioFitnessStore, startTime, %{public}f, endTime, %{public}f, error, %{public}@
CardioFitnessEvent successfully pushed to HKHRCardioFitnessStore, startTime, %{public}f, endTime, %{public}f
FakeCardioFitnessVO2Max
FakeCardioFitnessThreshold
FakeCardioFitnessEndTime
FakeCardioFitnessStartTime
FakeCardioFitnessIsRepeatAlert
void CLNatalimetryNotifier::writeFakeCardioFitnessEventToHealthKit(bool) const
Forcing a fake VO2Max sample: vo2Max, %{private}.2f, startTime, %{public}f
Forcing a fake Cardio Fitness Event: latestVO2Max, %{private}.2f, lowClassificationThreshold, %{private}.2f, alertPeriodStartTime, %{public}f, alertPeriodEndTime, %{public}f, isRepeatAlert, %{private}d
void CLNatalimetryNotifier::createPushTransaction()
HKDataCollector, attempting to create HistoricalPush transaction before releasing previous one
HKDataCollector, creating HistoricalPush transaction
CLNatalimetryNotifier.HistoricalPush
void CLNatalimetryNotifier::releasePushTransaction()
HKDataCollector, releasing HistoricalPush transaction
HKDataCollector, attempting to release HistoricalPush transaction after it was released
void CLNatalimetryNotifier::handleLastPersistedCalorieDatum(HKDataCollector *, HKQuantityDatum *)
HKDataCollector, handling last persisted value for active energy
HKDataCollector, handling last persisted value for basal energy
HKDataCollector, unknown collector passed!
HKDataCollector, sent last persisted with time %{public}f
HKDataCollector, sent nil last persisted so grabbing earliest record with time %{public}f
HKDataCollector, query range didn't change with last entry %{public}f, setting new
HKDataCollector, completed query with %{public}d iterations
bool CLNatalimetryNotifier::queryCalorimetryDatabase(HKDataCollector *, CFAbsoluteTime, CFAbsoluteTime &) const
HKDataCollector, query from %{public}f to %{public}f returned %{public}lu records with result %{public}d
HKDataCollector, unable to perform incremental calculation since only %{public}lu entries in db
HKDataCollector, backfilled %{public}lld calories, from %{public}f to %{public}f
void CLNatalimetryNotifier::writeDatumsToDataCollector(bool, HKDataCollector *, NSArray<HKQuantityDatum *> *) const_block_invoke
HKDataCollector, failed to insert energy sample, error, %{public}@
HKDataCollector, successfully pushed energy sample
Dance
Rowing
NatalieInputSrc
virtual void CLNatalieInput<CLCalorimetryDanceDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryDanceDMFeatures]
#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.
virtual void CLNatalieInput<CLCalorimetryFunctionalStrengthDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryFunctionalStrengthDMFeatures]
virtual void CLNatalieInput<CLCalorimetryRowingDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryRowingDMFeatures]
AdaptiveExerciseMinuteThresholdMaxPercentIncreasePerDay
AdaptiveExerciseMinuteThresholdMaxPercentDecreasePerDay
CLNatalimetryNotifier::onMotionStateMediatorNotification
CLNatalimetryNotifier::onCatherineNotification
CLNatalimetryNotifier::onDataProtectionNotification
CLNatalimetryNotifier::onCompanionNotification
CLNatalimetryNotifier::onWatchOrientationSettingsNotification
CLNatalimetryNotifier::onFitnessTrackingNotification
CLNatalimetryNotifier::onStoredUserInfo
CLNatalimetryNotifier::onSessionTrackerAppLaunchNotification
CLNatalimetryNotifier::onDeviceMotionData
auto CLMetMinuteEstimator::estimateMetMinutes(CLMotionTimeRange, std::vector<CLNatalieData> &, std::vector<CLMetMinute> &)::(anonymous class)::operator()(const CLNatalieData) const
METMinutes,time rolled back
void CLNatalieSourceFromNotifier<CLOdometerEntry>::startSpectator() [Data_T = CLOdometerEntry]
Start spectator for src %s
virtual void CLNatalieInput<CLOdometerEntry>::update(CFAbsoluteTime) [Data_T = CLOdometerEntry]
virtual bool CLNatalieSourceFromNotifier<CLOdometerEntry>::startActive() [Data_T = CLOdometerEntry]
Activate src %s
virtual bool CLNatalieSourceFromNotifier<CLOdometerEntry>::stopActive() [Data_T = CLOdometerEntry]
Inactivate src %s
void CLNatalieSourceFromNotifier<CLElevationChangeEntry>::startSpectator() [Data_T = CLElevationChangeEntry]
virtual void CLNatalieInput<CLElevationChangeEntry>::update(CFAbsoluteTime)
#Warning Input, elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.
virtual bool CLNatalieSourceFromNotifier<CLElevationChangeEntry>::startActive() [Data_T = CLElevationChangeEntry]
virtual bool CLNatalieSourceFromNotifier<CLElevationChangeEntry>::stopActive() [Data_T = CLElevationChangeEntry]
void CLNatalieSourceFromNotifier<CLCoarseElevationChangeEntry>::startSpectator() [Data_T = CLCoarseElevationChangeEntry]
virtual void CLNatalieInput<CLCoarseElevationChangeEntry>::update(CFAbsoluteTime)
#Warning Input, all-day elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.
virtual bool CLNatalieInput<CLCoarseElevationChangeEntry>::isReady(CFAbsoluteTime)
%s is not ready at, %f, timeout, %f
%s is ready at, %f, timeout, %f
void CLNatalieSourceFromNotifier<CLCatherineData>::startSpectator() [Data_T = CLCatherineData]
virtual void CLNatalieInput<CLCatherineData>::update(CFAbsoluteTime) [Data_T = CLCatherineData]
virtual bool CLNatalieSourceFromNotifier<CLCatherineData>::startActive() [Data_T = CLCatherineData]
virtual bool CLNatalieSourceFromNotifier<CLCatherineData>::stopActive() [Data_T = CLCatherineData]
void CLNatalieSourceFromNotifier<CLStepCountEntry>::startSpectator() [Data_T = CLStepCountEntry]
virtual void CLNatalieInput<CLStepCountEntry>::update(CFAbsoluteTime) [Data_T = CLStepCountEntry]
virtual void CLNatalieInput<CLMotionStateMediator_Type::MediatedMotionActivity>::update(CFAbsoluteTime) [Data_T = CLMotionStateMediator_Type::MediatedMotionActivity]
virtual void CLNatalieInput<CLSwimEntry>::update(CFAbsoluteTime) [Data_T = CLSwimEntry]
virtual bool CLNatalieSourceFromNotifier<CLSwimEntry>::startActive() [Data_T = CLSwimEntry]
virtual bool CLNatalieSourceFromNotifier<CLSwimEntry>::stopActive() [Data_T = CLSwimEntry]
virtual void CLNatalieInput<_CLFitnessMachineData>::update(CFAbsoluteTime) [Data_T = _CLFitnessMachineData]
virtual bool CLNatalieSourceFromNotifier<_CLFitnessMachineData>::startActive() [Data_T = _CLFitnessMachineData]
virtual bool CLNatalieSourceFromNotifier<_CLFitnessMachineData>::stopActive() [Data_T = _CLFitnessMachineData]
void CLActivityAggregator<CLNatalieData>::setExpirationRule(CFTimeInterval) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLActivityAggregator<CLExerciseMinuteData>::setExpirationRule(CFTimeInterval) [T = CLExerciseMinuteData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLActivityAggregator<MaxMets>::setExpirationRule(CFTimeInterval) [T = MaxMets, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<CLNatalieData>::aggregateRecords() [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLNatalieData>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<MaxMets>::aggregateRecords() [T = MaxMets, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<MaxMets>::estimateRecordsNeeded(const CLAggregationRules &) [T = MaxMets, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<CLExerciseMinuteData>::aggregateRecords() [T = CLExerciseMinuteData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLExerciseMinuteData>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLExerciseMinuteData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLActivityRecorderDb<CLExerciseMinuteData>::addSuspectRecord(const T &) [T = CLExerciseMinuteData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLActivityRecorderDb<CLNatalieData>::addSuspectRecord(const T &) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
float CLCalorieClimbingModel::estimateClimbingMETs(CFAbsoluteTime, const CLCoarseElevationChangeEntry &, bool)
Climbing,deltaElevation,%f,ascentDuration,%f,climbingMets,%f,len,%lu
Climbing,epochMets,%f,bufferLength,%lu
Climbing,epochMets,%f,historicalBufferLength,%lu
com.apple.locationd.CoreMotion.CLGyroBiasEstimator
DisableDynamicGyroBias
EnableGyroNonlinearCalibration
CLGyroBiasEstimator::CLGyroBiasEstimator(id<CLIntersiloUniverse>)
[CLGBE] SPU bias NOT available,default,%{public}s
void CLGyroBiasEstimator::setHandlerForInstanceInternal(const void *, const bool, CLGyroBiasEstimator::Handler)
[CLGBE] Client instance %{public}p already unregistered
bool CLGyroBiasEstimator::removeClientInternal(const void *)
[CLGBE] Removing client %{public}p
void CLGyroBiasEstimator::addClientInternal(const void *, const bool, CLGyroBiasEstimator::Handler)
[CLGBE] Adding client %{public}p, sending out cached gyro bias,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f
[CLGBE] Adding client %{public}p, no cached gyro bias available
void CLGyroBiasEstimator::refreshDispatchersIfNecessaryInternal()
[CLGBE] Gyro not available
[CLGBE] SPUEnabled,%{public}d,BuildingGYTT,%{public}d,NumClients,%{public}lu
fSPUBiasAvailable
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/GyroBiasEstimator/CLGyroBiasEstimator.mm
prepareSPUGyroBiasAndVarianceDispatcher
void CLGyroBiasEstimator::feedGyroTemperature(const CLGyro::Temperature *)
[CLGBE] Notifying clients on temperature update,temperature,%{public}f
void CLGyroBiasEstimator::notifyClients(CFTimeInterval)
[CLGBE] GyroBias,time,%{public}f,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,dbias.x,%{public}f,dbias.y,%{public}f,dbias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f,client,%{public}p
void CLGyroBiasEstimator::tryBuildGYTT(CLVector3d<float>, float)
[CLGBE] #Warning Temperature is changing too quickly, clearing GYTT buffers,max,%{public}f,min,%{public}f
[CLGBE] #Warning Could not insert GYTT because bump was detected,variance.x,%{public}f,y,%{public}f,z,%{public}f
void CLGyroBiasEstimator::tryBuildGYTT(CLVector3d<float>, float)_block_invoke
[CLGBE] Bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public}f,temperature,%{public}f
void CLGyroBiasEstimator::feedGyroBiasFit(CLMotionTypeGyroBiasFit)
[CLGBE] Expected linear fit.
[CLGBE] GyroBiasFit,slope.x,%{public}f,slope.y,%{public}f,slope.z,%{public}f,intercept.x,%{public}f,intercept.y,%{public}f,intercept.z,%{public}f,lastMiniCal,%{public}f
void CLGyroBiasEstimator::notifySPUClients(const CLMotionCoprocessorInterface::GyroBiasAndVariance *)
[CLGBE] SPUGyroBias,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f,client,%{public}p
[CLGBE] Ignoring bias estimate during charging
void CLGyroBiasEstimator::notifySPUClients(const CLMotionCoprocessorInterface::GyroBiasAndVariance *)_block_invoke
[CLGBE] SPU bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public}f,temperature,%{public}f
auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispatcher:auto = CLMotionNotifier::CallbackDispatcher<CLGyro::Sample>]
[CLGBE] Registering for gyro notifications
[CLGBE] Unregistering for gyro notifications
auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispatcher:auto = CLMotionNotifier::CallbackDispatcher<CLGyro::Temperature>]
[CLGBE] Registering for gyro temperature notifications
[CLGBE] Unregistering for gyro temperature notifications
auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispatcher:auto = CLMotionNotifier::CallbackDispatcher<CLMagnetometer::Sample>]
[CLGBE] Registering for magnetometer notifications
[CLGBE] Unregistering for magnetometer notifications
auto CLGyroBiasEstimator::prepareSPUGyroBiasAndVarianceDispatcher()::(anonymous class)::operator()(auto *) const [dispatcher:auto = CLMotionNotifier::CallbackDispatcher<CLMotionCoprocessorInterface::GyroBiasAndVariance>]
[CLGBE] Registering for SPU Gyro Bias And Variance
[CLGBE] Removing SPU Gyro Bias And Variance dispatcher
it != fSamples.end()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLRunningBufferStats.h
getMax
getMin
CLOnBodyNotifier6::CLOnBodyNotifier6(id<CLIntersiloUniverse>)
configuration: wake threshold = %f
Registering with daemon status
virtual void CLOnBodyNotifier6::feedParams(NSDictionary *)
void CLOnBodyNotifier6::startOnBodyDetectionHelper(bool)
Registering with CLAccelerometer
Registering throttledDispatcher with CLAccelerometer
void CLOnBodyNotifier6::stopOnBodyDetectionHelper(bool)
Unregistering with CLAccelerometer
Unregistering throttleDispatcher with CLAccelerometer
void CLOnBodyNotifier6::onAccelerometerData(const CLAccelerometer::Sample *, unsigned int)
detection @ %llu : low %f high %f status %d confidence %d odds %.2f
Failed to add throttled dispatcher
void CLOnBodyNotifier6::onThrottledAccelerometerData(const CLAccelerometer::Sample *)
throttled @ %llu: accel = [%.2f %.2f %.2f] = %.2f ? %.2f
Failed to add dispatcher
void CLOnBodyNotifier6::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
kNotificationSleep. Turning off on body detector
kNotificationWake. Turning on on body detector
OnBody
CLOnBodyNotifier6::onDaemonStatusNotification
CLOnBodyNotifier6::onAccelerometerData
CLOnBodyNotifier6::onThrottledAccelerometerData
virtual void CLClusterAlgorithm<CLCompassDatabaseRecord>::buildClusterAroundIndex(const std::list<int> &, int, std::list<int> &, std::list<int> &, float) const [T = CLCompassDatabaseRecord]
Unable to find index (%{public}d) to value on which we want to build a cluster around!  Returning from function.
uploadInterval != UNITIALIZED_INTERVAL
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Harvester/Common/CLHarvestRule.mm
getUploadInterval
fPoweredUploadReachability != Reachability::kReachabilityUnachievable
getUploadReachability
fUnpoweredUploadReachability != Reachability::kReachabilityUnachievable
VO2MaxSummaryHistory
DELETE FROM VO2MaxSummaryHistory WHERE startTime < ?
SELECT * from VO2MaxSummaryHistory ORDER BY startTime ASC
SELECT COUNT(*) FROM VO2MaxSummaryHistory
CMError CLVO2MaxSummaryRecorderDb::querySince(const CFAbsoluteTime, std::vector<VO2MaxSummary> &) const
VO2MaxSummaryHistory, DB not accessible
SELECT * FROM VO2MaxSummaryHistory WHERE pointCount > 0 AND startTime > ? ORDER BY startTime DESC
CMError CLVO2MaxSummaryRecorderDb::querySinceAndFilterByBetaBlockerUse(const CFAbsoluteTime, bool, std::vector<VO2MaxSummary> &) const
SELECT vsh.* FROM VO2MaxSummaryHistory vsh INNER JOIN VO2MaxSessionAttributesHistory vsah ON vsh.sessionId = vsah.sessionId WHERE vsah.betaBlockerUse = ? AND vsh.pointCount > 0 AND vsh.startTime > ? ORDER BY vsh.startTime DESC
CMError CLVO2MaxSummaryRecorderDb::queryInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<VO2MaxSummary> &) const
SELECT * FROM VO2MaxSummaryHistory WHERE pointCount > 0 AND startTime > ? and startTime < ? ORDER BY startTime DESC
CMError CLVO2MaxSummaryRecorderDb::queryBySessionId(unsigned char *, std::vector<VO2MaxSummary> &) const
SELECT * from VO2MaxSummaryHistory WHERE sessionId = ?
void CLVO2MaxSummaryRecorderDb::deleteRecordsForSessionId(unsigned char *)
Deleting VO2MaxSummaryHistory records from db where sessionId = %{public}s
DELETE FROM VO2MaxSummaryHistory
DELETE FROM VO2MaxSummaryHistory WHERE startTime > ?
UPDATE VO2MaxSummaryHistory SET startTime = startTime + ?
SELECT * FROM VO2MaxSummaryHistory ORDER BY id DESC LIMIT 1
ALTER TABLE VO2MaxSummaryHistory ADD COLUMN 
UPDATE VO2MaxSummaryHistory SET 
SELECT COUNT(name) FROM sqlite_master WHERE type='index' AND name = 'VO2MaxSummaryHistorySessionIdIndex'
void CLVO2MaxSummaryRecorderDb::createIndexOnSessionIdIfNecessary()
Index VO2MaxSummaryHistorySessionIdIndex already exists; not re-creating
CREATE INDEX VO2MaxSummaryHistorySessionIdIndex ON VO2MaxSummaryHistory (sessionId)
Unable to create index VO2MaxSummaryHistorySessionIdIndex
Index VO2MaxSummaryHistorySessionIdIndex created successfully
CLActivityRecorderDb<VO2MaxSummary>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxSummary>::setDatabaseAccessible() [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxSummary>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxSummary>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
Cluster Size 
bool CLExerciseMachineHeadingHRBackstop::update(float, const CLWorkoutStopModelHR::Statistics &, int)
HRHBS StopDetected,%{public}f,%{public}f
HRHBS,good,%f,eDiff,%f,degree,%f
RowingModelMetsScale
virtual CLMetsInfo CLNatalieRowingModel::computeMETS(const CLNatalieModelInput &)
Rowing, Speed Model, timestamp, %f, stroke power, %f, strokes amplitude, %f, stroke rate (spm), %f, height (m), %f, gender, %d, speed, %f, strokePowerDM, %f, strokeAmpDM, %f, strokeRateDM, %f, strokeDriveVelocityDM, %f, strokeLengthDM, %f, speedDM, %f, speedLegacy, %f
Rowing, WR Model, timestamp, %f, stroke speed, %f, strokes amplitude, %f, weight (KG), %f, METS, %f, fMetsScaling, %f, METSDM, %f, METSLegacy, %f
AMLFirstFixDelay
bool CLEmergencyAML::SimConfig::updateEmergencySettings(const AugmentedAction::AML &, const std::string &, const std::string &)
#Warning #AMLCfg,inst,%{public}d,overriding first fix delay to %{public}f
AMLMultipleSmsEnabled
#Warning #AMLCfg,inst,%{public}d,overriding enablement of multiple SMS to %{public}d
bool CLEmergencyAML::Config::updateEmergencySettings(const CLEmergencyAction::SimInstance, const CLEmergencyAction::AugmentedAction &, const std::string &, const std::string &)
#AMLCfg ignoring emergency settings for unexpected inst %{public}d
bool CLEmergencyAML::Config::updateEmergencySim(const CLEmergencyAction::SimInstance)
#AMLCfg keeping previous active inst %{public}d
#AMLCfg ignoring unexpected inst %{public}d
#AMLCfg active inst changed to %{public}d
bool CLEmergencyAML::Config::isEnabled()
#AMLCfg unexpected inst %{public}d is active
const CLEmergencyAML::SimConfig &CLEmergencyAML::Config::getSimConfig()
#AMLCfg AML config for inst %{public}d wasn't created on construction
#AML state machine
SMSNotificationReceived
SMSNotificationTimeout
Destination
Binary
DestinationPort
HTTPS
virtual void CLEmergencyAML::handleEmergencyStateChange(CLEmergencyState)
#AML active inst changed to %{public}d
CLEmergencyAML::State CLEmergencyAML::handler_Disabled(CLEmergencyAML::Event)
#Warning #AML SendFixTimeout fired while Disabled
#AML SMS Notification Timeout. Submit AWD report with failure
#AML SMS Notification timer timedout when no notifications were expected
#Warning #AML SessionAssertReleased fired in Disabled state
CLEmergencyAML::State CLEmergencyAML::handler_Idle(CLEmergencyAML::Event)
#Warning #AML SendFixTimeout fired while Idle
#Warning #AML SessionAssertReleased fired in Idle state
CLEmergencyAML::State CLEmergencyAML::handler_Session(CLEmergencyAML::Event)
#AML Submitting previous session AWD report before starting new session
#AML session assertion active during Session Exit,clearing
#Warning #AML unexpectedly disabled during active emergency call
#AML delaying Session Exit due to session assertion
#Warning #AML SMS Timeout while in Session. Ignoring it
bool CLEmergencyAML::shouldSendLocation()
#Warning #AML,shouldSendLocation,cached location is invalid
#AML,shouldSendLocation,sending,last send attempt had no location
#AML,shouldSendLocation,not sending,last send was too recent,tDiff,%{public}f
#AML,shouldSendLocation,sending,lower hunc,previous,%{public}f,current,%{public}f
#AML,shouldSendLocation,sending,location changed significantly,dist,%{public}f
#AML,shouldSendLocation,not sending,no significant changes
void CLEmergencyAML::sendLocation()
#AML attempted to send location when not enabled
#AML,sendLocation,roaming not supported
#AML not sending no fix message
#AML preparing to send SMS message: %{private}s
#Warning #AML attempting to send AML SMS on a device without CoreTelephony
NSString *CLEmergencyAML::createSmsWithLocation(const GNSS::DaemonLocation &)
#AML sending valid fix from time %{public}s
#AML method,%{public}c,lat,%{private}f,lon,%{private}f,acc,%{public}f
A"ML=1;lt=%+.5f;lg=%+.5f;rd=%u;top=%@;lc=95;pm=%c;si=%s;ei=%s;mcc=%d;mnc=%d;ml=
NSString *CLEmergencyAML::createSmsWithoutLocation()
#AML sending no fix message at time %{public}s
A"ML=1;lt=+00.00000;lg=+000.00000;rd=N;top=%@;lc=0;pm=N;si=%s;ei=%s;mcc=%d;mnc=%d;ml=
yyyyMMddHHmmss
char CLEmergencyAML::positioningMethod(CLLocationType)
#Warning #AML Valid location with unknown or obsolete type
NSString *CLEmergencyAML::stringWithAppendedLength(NSString *)
#AML total message length,%{public}d
%@%d
virtual uint32_t CLEmergencyAML::getErrorCodePriority(Emergency::SessionErrorCode)
#Warning #AML unexpected error code
void CLStateMachine<CLEmergencyAML>::setStateHandler(CLStateMachine::State, CLStateMachine::StateHandler) [T = CLEmergencyAML]
CLStateMachine::State CLStateMachine<CLEmergencyAML>::handleEvent(CLStateMachine::Event) [T = CLEmergencyAML]
void CLStateMachine<CLEmergencyAML>::cancelTimeoutEvent(CLStateMachine::Event) [T = CLEmergencyAML]
void CLStateMachine<CLEmergencyAML>::setTimeoutEvent(CLStateMachine::Event, double) [T = CLEmergencyAML]
-[CLHRequestArchive setCount:]
#update-count: archive:%@, oldCount:%d, newCount:%d, oldTotalCount:%d, newTotalCount:%d
conglomerate
allSecondaryCombined
prunedSecondaryCombined
sub_%@
sub_
[self isActiveSubArchive]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Harvester/Collection/CLHRequestStore.m
-[CLHRequestArchive inactiveSubArchives]
self.lastPathComponent BEGINSWITH 'sub_'
primary
self.lastPathComponent BEGINSWITH 'secondary-'
q24@?0@"NSURL"8@"NSURL"16
identifier
count
-home
-work
-main
v16@?0@"CLHRequestArchive"8
homeArchive
workArchive
mainArchive
%@-%@
self.lastPathComponent BEGINSWITH %@
B24@?0@"NSURL"8@"NSError"16
secondary
BOOL _CLHRemoveItemAtURL(NSURL *)
file does not exists. CheckAndRemoveItemAtPath : %@
AWD_PhoneSignificantElevation
AWD_WatchSignificantElevation
CLElevationChangeEntry CLElevationController::elevationUpdatePhone(CLElevationChangeEntry)
WorkoutElevation,onElevationPhone,fusionInput,startTime,%.3f,ascended,%d,descended,%d
WorkoutElevation,onElevationPhone,fusionOutput,startTime,%.3f,ascended,%d,descended,%d
void CLElevationController::elevationUpdateWatch(std::vector<CLElevationChangeEntry>::const_iterator, std::vector<CLElevationChangeEntry> &)
WorkoutElevation,onElevationWatch,fusionInput,startTime,%.3f,ascended,%d,descended,%d,pressureAmplitude,%f,pressureQuality,%d,deltaSteps,%d
WorkoutElevation,onElevationWatch,fusionOutput,startTime,%.3f,ascended,%d,descended,%d
void CLElevationController::updateElevationSubscriptionClient(int)
WorkoutElevation,clients,%d
void CLElevationController::updatePhoneConnectionStatus(bool, bool)
WorkoutElevation,phone connection,prev,%d,curr,%d,elev,%d
CLElevationController::onMotionStateObserverNotification
void CLElevationController::doUnsubscribe(const T *) [T = CLElevationController::ENoActiveClients]
WorkoutElevation,subs,phone,0
void CLElevationController::doWaitToUnsubscribe(const T *) [T = CLElevationController::ESourceUnavailable]
WorkoutElevation,subs,phone,waitingToUnsubscribe
void CLElevationController::doUnsubscribe(const T *) [T = CLElevationController::EWorkoutStop]
void CLElevationController::doSubscribe(const T *) [T = CLElevationController::EClientActive]
WorkoutElevation,subs,phone,1
void CLElevationController::doSubscribe(const T *) [T = CLElevationController::ESourceAvailable]
void CLElevationController::doSubscribe(const T *) [T = CLElevationController::EWorkoutStart]
void CLElevationController::doCancelWaitToUnsubscribe(const T *) [T = CLElevationController::ESourceAvailable]
WorkoutElevation,subs,phone,cancelWaitingToUnsubscribe
void CLElevationController::doUnsubscribe(const T *) [T = CLElevationController::ETimerExpires]
void CLActivityRecorderDb<CLSignificantElevation>::addSuspectRecord(const T &) [T = CLSignificantElevation, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
kCLConnectionMessageMotionState
kCLConnectionMessageMotionStateSim
kCLConnectionMessageMotionStateYouthSim
void CLMotionStateSubscription::handleRequestMotionState(bool, const CLNameValuePair &)
Received MotionState request,client,%s,subscribe,%d
void CLMotionStateSubscription::handleMessageMotionStateSim(std::shared_ptr<CLConnectionMessage>)
void CLMotionStateSubscription::handleMessageMotionStateYouthSim(std::shared_ptr<CLConnectionMessage>)
Failed to override motion state youth. Invalid message received from framework.
CLMotionStateSubscription::onMotionStateNotification
void CLVO2MaxPreconditionChecker::log(bool) const
VO2MaxPrecondition,sessionStart,%d,sessionStartTime,%f,lastEstimateTime,%f,status,%d
void CLWifiAltitudeKalmanFilter::initializeKalmanFilter(const CFAbsoluteTime &, const CFAbsoluteTime &, const double &, const double &, const double &, const double &, const double &)
WifiCalc, zaxis, kalmanFilter, already initialized
WifiCalc, zaxis, kalmanFilter, did not initialize, wifi measurement timestamp %{private}0.3f was negative.
WifiCalc, zaxis, kalmanFilter, did not initialize, relative altitude timestamp %{private}0.3f was negative.
WifiCalc, zaxis, kalmanFilter, initialized, wifi timestamp, %{private}0.3f, relative altitude timestamp, %{private}0.3f, initial altitude, %{private}0.3f, initial uncertainty, %{public}0.3f.
static bool CLWifiAltitudeKalmanFilter::validAltitudeAndUncertainty(const double &, const double &)
WifiCalc, zaxis, invalid uncertainty, %{public}0.3f
WifiCalc, zaxis, invalid altitude, %{private}0.3f
bool CLWifiAltitudeKalmanFilter::propagateAndUpdate(const CFAbsoluteTime &, const CFAbsoluteTime &, const bool &, const double &, const double &, const double &, const bool &)
WifiCalc, zaxis, kalmanFilter, did not propagate and update, not initialized
WifiCalc, zaxis, kalmanFilter, stopping, did not propagate for, %{private}0.3f, seconds
WifiCalc, zaxis, kalmanFilter, stopping, did not update for, %{private}0.3f, seconds
WifiCalc, zaxis, kalmanFilter, stopping, unable to propagate
WifiCalc, zaxis, kalmanFilter, stopping, unable to update
bool CLWifiAltitudeKalmanFilter::getResults(double &, double &) const
WifiCalc, zaxis, kalmanFilter, estimated altitude, %{private}0.3f, uncertainty, %{private}0.3f
bool CLWifiAltitudeKalmanFilter::propagate(const CFAbsoluteTime &, const CFAbsoluteTime &, bool, const double &)
WifiCalc, zaxis, kalmanFilter, did not propagate, filter's propagation timestamp, %{private}0.3f, is larger than current wifi timestamp, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, did not propagate, filter's relative altitude timestamp, %{private}0.3f, is larger than current relative altitude timestamp, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, baro outage time interval, %{private}0.3f, altitude change over outage, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, propagated, timestamp, %{private}0.3f
bool CLWifiAltitudeKalmanFilter::update(const double &, const double &)
WifiCalc, zaxis, kalmanFilter, updated, timestamp, %{private}0.3f
CLAppTileDataProviderErrorDomain
-[CLAppTileDataProvider beginService]
TILE_APP: begin
-[CLAppTileDataProvider beginService]_block_invoke
TILE_APP: Removing request since it timed out, lat, %f, lon, %f, radius, %f.
-[CLAppTileDataProvider endService]
TILE_APP: shutdown
-[CLAppTileDataProvider getAppsForAreaAtLatitude:longitude:radius:includeRegionalApps:marqueeAppsOnly:]
TILE_APP: getAppsForArea, examining %zu candidate grids.
TILE_APP: getAppsForArea, query for exact grid containing lat = %f, lon = %f, gridLat = %f, gridLon = %f
#Warning TILE_APP: getAppsForArea, invalid age rating, lat, %f, lon, %f, adamId, %d
reply
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Tiles/CLAppTileDataProvider.mm
-[CLAppTileDataProvider fetchAppsForAreaAtLatitude:longitude:radius:includeRegionalApps:marqueeAppsOnly:withReply:]
TILE_APP: fetchAppsForArea, tile is available for lat = %f, lon = %f.
TILE_APP: fetchAppsForArea, found %lu apps.
TILE_APP: fetchAppsForArea, tile does not exist on the server for lat = %f, lon = %f.
TILE_APP: fetchAppsForArea, tile is not available for lat = %f, lon = %f. Request for download.
-[CLAppTileDataProvider onTileWasDownloadedNotification:data:]
TILE_APP: onTileWasDownloadedNotification, activeRequests.count = %lu
TILE_APP: onTileWasDownloadedNotification, tile is available (or tile is 404) for lat = %f, lon = %f.
TILE_APP: onTileWasDownloadedNotification, found %lu apps.
#Warning TILE_APP: Got unexpected notification, %d
CMLinearTemperatureFit::CMLinearTemperatureFit(CMTemperatureFitReceiver *)
Assertion failed: receiver, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMLinearTemperatureFit.h, line 27,receiver must not be null..
EmergencyWifiToggleAllowed
CL::Wifi1::Policies::ScanRequest::Output CL::Wifi1::Policies::ScanRequest::HandleEvent::operator()(const Events::Client::EmergencyState &) const
emergency wifi toggle not allowed so skipping check
void CLLastConfidentLocation::onNewLocations(const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
Received kNotificationWifiLocationBatched, num,%u,Size, %lu
Received unknown notification %d
bool CLLastConfidentLocation::isQualifiedAsConfident(const CLDaemonLocation &)
Skipping new location with invalid coordinate
Skipping new location with invalid rawCoordinate
Skipping new location with coordinate in null-island
Skipping new location with rawCoordinate in null-island
bool CLLastConfidentLocation::isPreviousLocationPreferred(const CLDaemonLocation &, bool)
#Warning Last confident location is in future, timestamp,%.03lf
Skipping new location with an older timestamp,%.03lf,cached,%.03lf
Skipping new location, since having recent more confident location
bool CLLastConfidentLocation::isLastConfidentLocationValid()
Last confident location not available
Last confident location too old, maxAge = %.1lf
void CLLastConfidentLocation::notifyConfidentLocationIfNecessary()
Notifying cached location,num,%u,accuracy,%.01lf,timestamp,%.03lf,lifespan,%.04lf
void CLLastConfidentLocation::onCachedLocationControllerNotification(int, const CLCachedLocationController_Type::Notification &, const CLCachedLocationController_Type::NotificationData &)
Received a kNotificationCachedLocationControllerStateUpdate notification, state, %d
Recieved unknown notification %d
CLLastConfidentLocation::onCachedLocationControllerNotification
LogFileRotationSize
LogFileStorageCount
CLLogBase
LogDumpOnUnload
LogDumpOnLoad
static void CLLogBase::onSettingsNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNotifier_Type::NotificationData &, void *)
received unexpected darwin notification
/Library/Logs/CrashReporter/com.apple.locationd
Caches
%s,%s,failed to open %s
CLCellTile-Mutex
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_GSM>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]
TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s
tilestool: mmap, %lu, file, %lu
TEST_testBinarySearch
CLKeyLatLonTileTemplate.h
isFound == isFoundMmap
TILE: result: tilestool: prog, %3lu, %3lu, ===============> isFound, %d, location, %14.8lf, %14.8lf, entry, %s
isFound
TILE: result: tilestool: pass, %d, tests, %lu, %lu
virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_GSM>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]
TILE: index entry, %3lu, %3u, %s
TILE: searched, numOfEntries, %u, offsetEntries, %d
onTraversingSection
offsetEntries + numOfEntries <= entriesHeader.numOfEntries
TILE: avoid data search
TILE: entry, %3lu, %3u, %3lu, %s, loc, %.8lf, %.8lf, delta, %.5lf, %.5lf, grid, %u, %u
TILE: getLocationByKey, isFound, %d, searchedArea, %d, key, %s
bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_GSM>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]
TILE: binarySearchIndex, size, %lu, searchedIndexEntry, %s, %d
TILE: index search, match, %s
TILE: index search, not found
bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_GSM>::binarySearchData(const DataEntry_T *, unsigned int, unsigned int, const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]
TILE: binarySearchData, search data, isFound, %d, numOfCompares, %u
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_GSM>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]
TILE:  getLocationByKey_mmap, key, %s
TILE: getLocationByKey_mmap, failed to mmap, #CloneMe
TILE: pIndexEntries passes valid mmapped region, pIndexEntries:%{private}lu, numOfEntries:%{private}u, atOffset:%{private}lld, %{private}s, %{private}s, %{private}s
TILE: pDataEntries passes valid mmapped region, pDataEntries:%{private}lu, numOfEntries:%{private}u, atOffset:%{private}lld, %{private}s, %{privat}s, %{private}s
TILE: invalid binary search %{private}s in %{private}s, %{private}s, a:%{private}u, b:%{private}u, max:%{private}u, %{private}s
TILE: no index section before entries section, %{private}s, %{private}s
TILE: not found in index, a, %{private}u, b, %{private}u, %{private}s, %{private}s, %{private}s
TILE: unregconized sectionId, %lld, %s, %s
TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s
TileHeader(
tileY=
tileX=
genTime=
search
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_GSM>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]
TILE: getLocationByKey_traverse, key, %s
TILE: getLocationByKey_traverse, prefer local file name because it exists, %s
TILE: getLocationByKey_traverse, isFound, %d, searchedArea, %u, key, %s, entry, %s
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_CDMA>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]
virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_CDMA>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]
bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_CDMA>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]
bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_CDMA>::binarySearchData(const DataEntry_T *, unsigned int, unsigned int, const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_CDMA>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_CDMA>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_LTE>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]
virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_LTE>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]
bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_LTE>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]
bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_LTE>::binarySearchData(const DataEntry_T *, unsigned int, unsigned int, const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_LTE>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_LTE>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]
virtual CLDaemonBBTimeFreqTransferCallbackAssertion::~CLDaemonBBTimeFreqTransferCallbackAssertion()
#wigo,off,CLBBTFTA
kCLBBTFT_Error
Feature not supported
Assertion already taken
com.apple.locationd.bbtimefreqtransfer_callback
missing entitlement: com.apple.locationd.bbtimefreqtransfer_callback
missing bundleID
missing bundlePath
missing reason
empty reason
null beneficiary client key
void CLDaemonBBTimeFreqTransferCallbackAssertion::handleMessageBBTimeFreqTransferAssertion(std::shared_ptr<CLConnectionMessage>)
#wigo,on,CLBBTFTA
kCLBBTFT_currentGpsUtcLeapSecond
kCLBBTFT_upcomingGpsUtcLeapSecond
kCLBBTFT_upcomingGpsUtcLeapSeconUpdateDeltaTimeGPSNsec
kCLBBTFT_possibleGpsUtcLeapSeconUpdateDeltaTimeGPSNsec
kCLBBTFT_messageVersion
kCLBBTFT_timestamp
kCLBBTFT_systemRTCMsec
kCLBBTFT_systemRTCSubMsec
kCLBBTFT_systemRTCUncertaintyMsec
kCLBBTFT_GPSTimeNsec
kCLBBTFT_GPSTimeUncertaintyNsec
kCLBBTFT_clockOffsetPPB
kCLBBTFT_clockOffsetUncertaintyPPB
kCLBBTFT_clockOffsetThermalCorrectionPPB
kCLBBTFT_gpsUtcLeapSecondDictionary
kCLGnssHeatMap_timestamp
kCLGnssHeatMap_elevationBuckets
kCLGnssHeatMap_numAzimuthBuckets
kCLGnssHeatMap_data
CLDaemonBBTimeFreqTransferCallbackAssertion::onLocationControllerNotification
CLDaemonBBTimeFreqTransferCallbackAssertion::handleMeasurementNotification
CLDaemonBBTimeFreqTransferCallbackAssertion::onGnssLocationNotification
Invalid GPS time %.3lf constructed from double
EmergencySettings
EnableCPI
EnableEarlyReturn
AllowOTDOA
SupportsAML
SMSDestination
SMSDestinationPort
HTTPSAddress
FirstFixDelay
MultipleSmsEnabled
MaxFixDelay
MinFixDelay
BinarySMSDisabled
MobileAsset
CarrierBundle
CLTilesSet::CLTilesSet(CLTilesManager_Type::TileType, const std::string &, const std::string &, const std::string &)
TILE: creating directory, %s, ret, %d
CLTilesSetCollection::CLTilesSetCollection()
TilesSet, Initialize CLTilesSetCollection
Invalid TileType value.
Index out of bounds
Mismatch of tile type inserting CLTilesSet.
avgIntensity
kModeThreshold
kModeBurst
kModeCoverage
CLSensorRecorderNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/SensorRecorder/CLSensorRecorderNotifier.mm
-[CLSensorRecorderNotifierAdapter beginService]
CMAccelerometerDataArray
CMGyroDataArray
CMAmbientPressureDataArray
-[CLSensorRecorderAlmanacListener sensorWriter:didReceiveUpdateToConfigurationRequests:]
[Dynamic Config] Error on config insertion: %{public}d
CLSensorRecorderNotifier
SensorRecorderAggregationInterval
SensorRecorderAggregationExpiration
SensorRecorderAccelSamplingRate
SensorRecorderGyroSamplingRate
SensorRecorderPressureSamplingRate
SensorRecorderAccelAlwaysSubscribed
SensorRecorderGyroAlwaysSubscribed
SensorRecorderPressureAlwaysSubscribed
kAccelSampleRate
kGyroSampleRate
kPressureSampleRate
CLSensorRecorderNotifier::CLSensorRecorderNotifier(id<CLIntersiloUniverse>)_block_invoke
Attempting to write accel sample. startTime: %{public}f, timestamp: %{public}llu, dataSize: %{public}d
Attempting to write gyro sample. startTime: %{public}f, timestamp: %{public}llu, dataSize: %{public}d
Attempting to write pressure. startTime: %{public}f, timestamp: %{public}llu, dataSize: %{public}f
Aggregating accel sensor recorder samples.
Aggregating gyro sensor recorder samples.
Aggregating pressure sensor recorder samples.
bool CLSensorRecorderNotifier::recordSensorData(CLSensorRecorder_Types::DataType, CFTimeInterval, bool)
Record %{location:CLSensorRecorder_Types::DataType,public}d data for %{public}f
kAccelBufferSubscriptionOverride
kAccelBufferSubscription
kGyroBufferSubscriptionOverride
kGyroBufferSubscription
kPressureBufferSubscriptionOverride
kPressureBufferSubscription
bool CLSensorRecorderNotifier::setSensorSampleRate(CLSensorRecorder_Types::DataType, unsigned int)
requested sampling rate of %{public}d is greater than the max allowed of %{public}d
Invalid data type.
setting desired accel sampling rate to %dhz
bool CLSensorRecorderNotifier::writeSensorRecordDataToFile(CLSensorRecorder_Types::DataType, NSFileHandle *, CFAbsoluteTime, CFAbsoluteTime)
Error accessing sensor recorder data from %{private}f, %{private}f
Error occurred while retrieving data record %{private}llu
Wrote %lu meta records across %d data containers to %s
void CLSensorRecorderNotifier::updateSubscriptionType(CLSensorRecorder_Types::DataType)
Updating %{location:CLSensorRecorder_Types::DataType,public}d sampling rate %{public}d, fitness tracking enabled, %{public}d
Updated %{location:CLSensorRecorder_Types::DataType,public}d subscription due to invalid time.
Updated %{location:CLSensorRecorder_Types::DataType,public}d subscription override due to invalid time.
void CLSensorRecorderNotifier::onSoftwareUpdateStorageRecovery(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
#CacheDelete - onSoftwareUpdateStorageRecovery - Flushing SensorRecorderDB
%s/CoreMotionDebug_SensorRecorder_%@_accel.dat
void CLSensorRecorderNotifier::writeAccelToDiskTriggeredBySysdiagnose()
Failed to dump sensor recorder (accel) to disk because fileHandle is nil.
SRSensorAccelerometer
/System/Library/Frameworks/SensorKit.framework/SensorKit
/System/Library/PrivateFrameworks/SensorKit.framework/SensorKit
SRSensorGyroscope
SRSensorElevationPressure
ContextConfiguration
SRSensorWriter
SensorRecorder
CLSensorRecorderNotifier::onFitnessTrackingNotification
CLSensorRecorderNotifier::onSysdiagnoseStarted
CLSensorRecorderNotifier::onSoftwareUpdateStorageRecovery
virtual void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLBTLEBeaconProviderMockSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/BTLEBeaconProvider/CLBTLEBeaconProviderMock.mm
-[CLBTLEBeaconProviderMockAdapter beginService]
CLBTLEBeaconProviderMock-Notifier
void CLBTLEBeaconProviderMock::onEventSource()
Attempting to fulfill scan requests,%lu.
Fulfilled scan requests,%d.
Processing events for %lu proximity zones.
Processed %d proximity zone events.
Bluetooth is powered off, no events will be processed.
CLBTLEBeaconProviderMock::onEventSource
virtual void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::listClients() [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
-[CMStrideCalibrationElevationBuffer feedElevationData:]
Elevation, %f, %f, %d, %d
-[CMStrideCalibrationElevationBuffer updateGradient:]
TrackCalibration,%s,CalData,%s,ElevationAscended,%d,ElevationDescended,%d
LocationKey
TripTimestampKey
TripIdKey
RatKey
MccKey
MncKey
ContextKey
BundleIdKey
BundleIdsKey
ModeIndicatorKey
ActiveAccessoryKey
MotionVehicleStateChangedKey
MotionVehicleKey
RawMotionActivityKey
MotionActivityKey
DominantMotionActivityKey
tripTimestamp
tripId
context
bundleIds
modeIndicator
kCMMotionTimeRangeCodingKeyStartDate
kCMMotionTimeRangeCodingKeyEndDate
%@,<startDate %@, endDate %@>
CMMotionTimeRange.mm
timeRange
virtual void CLKappaQualifierAlgGPSResult::log()
[GPS] TPQ summary,A,%d,B,%d,C,%f,D,%f,E,%f,F,%f,G,%f,H,%d,config-1,%f,config-2,%f,config-3,%f
gps-A
gps-B
gps-C
gps-D
gps-E
gps-F
gps-G
gps-H
gps-config-1
gps-config-2
gps-config-3
virtual void CLKappaQualifierAlgGPSResult::recordCA(NSMutableDictionary *)
gps (%f, %f, %f, %f, %f, %f) (%d, %d, %d, %d, %d, %d)
gps_C
gps_D
gps_E
gps_F
gps_G
gps_H
void CLKappaQualifierAlgGPSResult::updateResult(float, float, float, uint64_t)
GPS updateResult %f %f %f %llu
void CLKappaQualifierAlgGPS::interpolateGPS()
GPS queue precondition not met
virtual void CLKappaQualifierAlgGPS::reset()
GPS alg: reset
void CLKappaQualifierAlgGPS::setConfig(const struct CLKappaQualifierAlgGPSConfig &)
gps config %f, %f, %f
const T &CMQueue<CLKappaGpsItem>::operator[](const size_t) const [T = CLKappaGpsItem]
CLBTLEFenceManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLBTLEFenceManager.mm
-[CLBTLEFenceManagerAdapter beginService]
CLBTLEFenceManager-Notifier
virtual void CLNotifier<CLBTLEFenceManager_Type::Notification, CLBTLEFenceManager_Type::NotificationData, char, std::string>::removeClient(int) [Notification_T = CLBTLEFenceManager_Type::Notification, NotificationData_T = CLBTLEFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLBTLEFenceManager_Type::Notification, CLBTLEFenceManager_Type::NotificationData, char, std::string>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLBTLEFenceManager_Type::Notification, NotificationData_T = CLBTLEFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLBTLEFenceManager_Type::Notification, CLBTLEFenceManager_Type::NotificationData, char, std::string>::clientRegistered(int, const Notification_T &) [Notification_T = CLBTLEFenceManager_Type::Notification, NotificationData_T = CLBTLEFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLBTLEFenceManager_Type::Notification, CLBTLEFenceManager_Type::NotificationData, char, std::string>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLBTLEFenceManager_Type::Notification, NotificationData_T = CLBTLEFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual void CLNotifier<CLBTLEFenceManager_Type::Notification, CLBTLEFenceManager_Type::NotificationData, char, std::string>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLBTLEFenceManager_Type::Notification, NotificationData_T = CLBTLEFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
void CLNotifier<CLBTLEFenceManager_Type::Notification, CLBTLEFenceManager_Type::NotificationData, char, std::string>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLBTLEFenceManager_Type::Notification, NotificationData_T = CLBTLEFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual void CLNotifier<CLBTLEFenceManager_Type::Notification, CLBTLEFenceManager_Type::NotificationData, char, std::string>::listClients() [Notification_T = CLBTLEFenceManager_Type::Notification, NotificationData_T = CLBTLEFenceManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
CLSpringTrackingNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/SleepTracker/CLSpringTrackingNotifier.mm
-[CLSpringTrackingNotifierAdapter beginService]
reply != nullptr
-[CLSpringTrackingNotifierAdapter querySinceRecord:withReply:]
CLSpringTrackingNotifier
SpringTrackerWakeHysteresis
void CLSpringTrackingNotifier::setUpdateFinishedHandler()_block_invoke
id,%llu,startTime,%lf,eventType,%ld
com.apple.locationd.lorievent
v64@?0{CLSpringTrackerEntry=Q[16C][16C]dq}8
v24@?0@"CMActivityAlarm"8@"NSError"16
CMError CLSpringTrackingNotifier::startTracking()
Started tracking,duration,%.3f
CMError CLSpringTrackingNotifier::stopTracking()
Stopped tracking
Spring
CLSpringTrackingNotifier::onDataProtectionNotification
void CLActivityAggregator<CLSpringTrackerEntry>::setExpirationRule(CFTimeInterval) [T = CLSpringTrackerEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLActivityRecorderDb<CLSpringTrackerEntry>::addSuspectRecord(const T &) [T = CLSpringTrackerEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<CLSpringTrackerEntry>::aggregateRecords() [T = CLSpringTrackerEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLSpringTrackerEntry>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLSpringTrackerEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
SleepHistory
DELETE FROM SleepHistory WHERE startTime < ?
virtual long CLSpringTrackerRecorderDb::aggregateRecords(const CLAggregationRules &)
Error expiring records.
SELECT * from SleepHistory ORDER BY id ASC
CMError CLSpringTrackerRecorderDb::querySince(const CLSpringTrackerEntry &, std::vector<CLSpringTrackerEntry> &) const
DB UUID un-initialized
SELECT * FROM SleepHistory WHERE id >= ? ORDER BY id ASC
SELECT COUNT(*) FROM SleepHistory
(silo != nullptr && handler != nullptr)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/SleepTracker/CLSpringTrackerRecorderDb.mm
DELETE FROM SleepHistory
DELETE FROM SleepHistory WHERE startTime > ?
UPDATE SleepHistory SET startTime = startTime + ?
INSERT INTO SleepHistory (startTime, eventType) VALUES (?, ?)
SELECT * FROM SleepHistory ORDER BY startTime DESC LIMIT 1
eventType
CLActivityRecorderDb<CLSpringTrackerEntry>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSpringTrackerEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLSpringTrackerEntry>::setDatabaseAccessible() [T = CLSpringTrackerEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLSpringTrackerEntry>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLSpringTrackerEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLBTLEBeaconProviderConcrete-Notifier
CLBTLEBeaconProviderConcrete
BTLEBeaconProvider
BeaconFenceBestEffortScheduleEnabled
CLBTLEBeaconProviderConcrete::CLBTLEBeaconProviderConcrete(id<CLIntersiloUniverse>)
#Warning Overriding BeaconFenceBestEffortScheduleEnabled,%{private}d
BeaconFenceBestEffortInterval
#Warning Overriding BeaconFenceBestEffortInterval,%{private}.2f
com.apple.locationd.beaconprovider
virtual bool CLBTLEBeaconProviderConcrete::addProximityZone(const CLBTLEBeaconProvider_Type::ProximityZone &)
iB: Adding zone,%{private}s
Invalid region definition for zone monitoring
iB: Registering zone,%{private}s, with Bluetooth
virtual bool CLBTLEBeaconProviderConcrete::removeProximityZone(const CLBTLEBeaconProvider_Type::ProximityZone &)
iB: Removing zone,%{private}s
#Warning Unable to remove zone,%{private}s, it wasn't found.
void CLBTLEBeaconProviderConcrete::onZoneDetectionTimer(CLPersistentTimer *)
iB: Zone detection timer woke up
void CLBTLEBeaconProviderConcrete::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
iB: Received a wake event
void CLBTLEBeaconProviderConcrete::unlockedStartScan()
iB: Resuming scan, reference count,%{public}d,lastScan,%{private}.0lf,lastScheduled,%{private}.0lf
iB: Scan is already resumed, reference count,%{public}d,lastScan,%{private}.0lf,lastScheduled,%{private}.0lf
void CLBTLEBeaconProviderConcrete::unlockedStopScan()
iB: Suspending scan, reference count,%{public}d
iB: Scan is already suspended, reference count,%{public}d
void CLBTLEBeaconProviderConcrete::unlockedPostAndClearScanCache()
iB: Posting notification with proximity devices,%{public}lu
void CLBTLEBeaconProviderConcrete::unlockedPerformZoneDetectionWithCache()
iB: Best effort zone,%{private}s, firstExit,%{private}f, now,%{private}f, has not reached exitThreshold,%{private}f
iB: Best effort zone,%{private}s, subject to exit
CLBTLEBeaconProviderConcrete::onDaemonStatusNotification
CLBTLEBeaconProviderConcrete::onZoneDetectionTimer
[key isKindOfClass:[NSString class]]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Harvester/Collection/CLHNetworkController.m
-[CLHUploadRequest URLRequest]_block_invoke
[obj isKindOfClass:[NSString class]]
-[CLHUploadRequest URLRequest]
Request archive and Payload both were nil for upload request
archive
requestCode: %d, itemCount: %lu
CLHNetworkControllerQueue
EEE',' dd MMM yyyy HH':'mm':'ss zzz
Date
bool CLParticleMM::MMSnapData::fillCrumb()
CLMMPED,%{public}.1lf,Unexpected,invalid bestParticle road
CLMMPED,%{public}.1lf,Unexpected,RawGPSScore not available
CLMMPED,%{public}.1lf,Unexpected,unable to determine roadWidth when filling crumb
void CLParticleMM::MMPartialMatcher::getPartialMatchedSolution(CLParticleMM::MMSnapData &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,fRawWeight,%{public}.2lf,fSnapWeight,%{public}.2lf,fTimeInMode,%{public}.2lf,snapType,%{public}d
bool CLParticleMM::MMCandidate::addParticle(const CLParticleMapMatcherCommon::Particle &)
CLMMPED,%{public}.1lf,Unexpected, null road when trying to add particles into candidate
bool CLParticleMM::MMCandidate::shallConsiderOutgoingCandidate(const CLSignalEnvironmentProvider_Type::SignalEnvironmentInfo &) const
CLMMPED,%{public}.1lf,shallConsiderOutgoingCandidate,ambiguityCase,combined,%{public}d,secondBestCombined,%{public}d,sigEnv,%{public}d
CLMMPED,%{public}.1lf,shallConsiderOutgoingCandidate,lowerOutgoingCountCase,course,%{public}.2lf,snapCourse,%{public}.2lf,outgoingSnapCourse,%{public}.2lf,approxCourseOfTurningRoad,%{public}.2lf,turningCourseDiff,%{public}.2lf,outgoingCondition,%{public}d
CLMMPED,%{public}.1lf,shallConsiderOutgoingCandidate,lowerOutgoingCountCase,course,%{public}.2lf,snapCourse,%{public}.2lf,outgoingSnapCourse,%{public}.2lf,isCrumbCourseAlignedWithOutgoing,%{public}d,isCrumbCourseAlignedWithIncoming,%{public}d,sigEnv,%{public}d,outgoingCondition,%{public}d
CLMMPED,%{public}.1lf,shallConsiderOutgoingCandidate,position dependent
CLMMPED,%{public}.1lf,snapCourse,%{public}.2lf,outgoingSnapCourse,%{public}.2lf, crumbCourse,%{public}.2lf, outgoingDistanceFromIntersection,%{public}.2lf,outgoingCondition,%{public}d,crumbCourseUnc,%{public}.2lf,significantCourseChange,%{public}d,isCrumbCourseAlignedWithOutgoing,%{public}d, isCrumbCourseAlignedWithIncoming,%{public}d
bool CLParticleMM::MMCandidateVector::assessCandidates(CLMapGeometryPtr, const CLMapCrumb &)
CLMMPED,%{public}.1lf,Unexpected, geometry is null
CLMMPED,%{public}.1lf,Unexpected, zero candidates,assessCandidates
CLMMPED,%{public}.1lf,unable to determine best particle
CLMMPED,%{public}.1lf,interpolateOnRoad returned false, determining mean road position
CLMMPED,%{public}.1lf,roadsConnected returned false, searching for connected candidates
CLMMPED,%{public}.1lf,interpolateOnRoad returned false, determining outgoing road position
CLMMPED,%{public}.1lf,candidate,ID,%{private}llu,fwd,%{public}d,countArndMean,%{public}d,bestParticleScore,%{public}.9lf,isCombined,%{public}d,isMulti,%{public}d,combinedWith,%{private}llu,fwd,%{public}d,incomingCnt,%{public}lu,outgoingCnt,%{public}d,combinedCnt,%{public}d,bestCombinedCnt,%{public}d,secondBestCombinedCnt,%{public}d,secondCombinedWith,%{private}llu
const CLParticleMM::MMCandidate *const CLParticleMM::MMCandidateVector::getSolutionCandidate() const
CLMMPED,%{public}.1lf,unexpectedly unable to find candidates,getSolutionCandidate
CLMMPED,%{public}.1lf,unexpectedly, best candidate is nullptr
CLMMPED,%{public}.1lf,overrode bestCandidate with alternate,roadID,%{public}lld,bestIncoming,%{public}d,altBestIncoming,%{public}d,bestCombined,%{public}d,altBestCombined,%{public}d
const CLParticleMM::MMCandidate *const CLParticleMM::MMCandidateVector::getBestCandidate() const
CLMMPED,%{public}.1lf,unexpectedly zero candidates,getBestCandidate
bool CLParticleMM::MMCandidateVector::getBestAndAlternateBestCandidate(const CLParticleMM::MMCandidate *&, const CLParticleMM::MMCandidate *&) const
CLMMPED,%{public}.1lf,unexpectedly zero candidates,getAlternateBestCandidate
double CLParticleMM::MMCandidateVector::getBestParticleScoreForAlternateCandidate() const
CLMMPED,%{public}.1lf,unexpectedly zero candidates,getSecondBestCandidate
int CLParticleMM::MMParticleVector::eliminateParticlesWithRoadKey(const CFAbsoluteTime, const CLParticleMapMatcherCommon::RoadKey)
CLMMPED,%{public}.1lf,Unexpected,particle road is null while eliminateParticlesWithRoadKey
bool CLParticleMM::MMParticleVector::computeLikelihoods(const CFAbsoluteTime, bool)
CLMMPED,%{public}.1lf,unable to normalizeLikelihoods, negative/zero totalScore after regular update,%{public}.8lf
bool CLParticleMM::MMParticleVector::computeLikelihoodsAndCSWVector(const CFAbsoluteTime)
CLMMPED,%{public}.1lf,unable to computeLikelihoods
CLMMPED,%{public}.1lf,invalid Neffsum,%{public}.3lf
bool CLParticleMM::MMParticleVector::resample(const CFAbsoluteTime, const int, CLParticleMapMatcherCommon::ParticleVector &)
CLMMPED,%{public}.1lf,unable to compute likelihoods and csw vector
CLMMPED,%{public}.1lf,Unexpected number of particles after resampling,%{public}d
CLMMPED,%{public}.1lf,Resampled,Neff,%{public}lf
bool CLParticleMM::MMFilterData::calculateScoreAndVarFactor(const CLParticleMapMatcherCommon::CLMMMeasurementData &, const CLMapGeometry::DistanceQueryResult &, CLMapDataUtil::MapMatcherScore &)
CLMMPED,%{public}.1lf,Unexpected,NULL road when computing score
bool CLParticleMM::MMFilterData::prepareCandidates(CLMapGeometryPtr, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,Reducing particles to half,speed,%{public}.1lf,static,%{public}d
CLMMPED,%{public}.1lf,Added prior particle,score,%{public}.8lf
CLMMPED,%{public}.1lf,resample failed
CLMMPED,%{public}.1lf,candidate update failed
CLMMPED,%{public}.1lf,assessCandidates failed
CLMMPED,%{public}.1lf,extractSolution failed
bool CLParticleMM::MMFilterData::extractSolution(const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,Unexpected,particle count,0
CLMMPED,%{public}.1lf,Unexpected,candidate count,0
CLMMPED,%{public}.1lf,Unexpected,bestCandidate is nullptr
CLMMPED,%{public}.1lf,Unexpected,particles in candidate,0
CLMMPED,%{public}.1lf,Unexpected,best particle road in best candidate is nullptr
CLMMPED,%{public}.1lf,extractSolution,using outgoing particles,previous,%{public}d
CLMMPED,%{public}.1lf,Unexpected,solutionParticleVector has zero particles
CLMMPED,%{public}.1lf,deweightCourse,courseUnc,%{public}.1lf,deweightUnc,%{public}.1lf
CLMMPED,%{public}.1lf,invalidateCourse,particleIsOnSegementsThatHasSmallCurves,%{public}d,particleInOnSameRoadAsPriorSnap,%{public}d
CLMMPED,%{public}.1lf,Particle is on a curved section of road,%{private}lld,projection,%{public}.2lf,deweightCourse,%{public}d
CLMMPED,%{public}.1lf,invalidated course and recomputed solution,changeInDistance,%{public}.2lf,newChangeInDistance,%{public}.2lf
CLMMPED,%{public}.1lf,Unexpected,newParticle road is nullptr,1
CLMMPED,%{public}.1lf,eliminated outgoing roadKey for local solution,%{public}d
CLMMPED,%{public}.1lf,use new particle, course check, crumbCourseDiffWithNewParticle,%{public}.1lf,crumbCourseDiffWithPreviousParticle,%{public}.1lf
CLMMPED,%{public}.1lf,new particle without the outgoing road accepted,courseIsUnreliable,%{public}d
CLMMPED,%{public}.1lf,not using local solution without outgoing road,%{public}d
CLMMPED,%{public}.1lf,Unexpected,newParticle road is nullptr,2
CLMMPED,%{public}.1lf,Number of particles 0 after eliminating particles on combined road,%{public}d
CLMMPED,%{public}.1lf,Unexpected,best particle road is nullptr
CLMMPED,%{public}.1lf,Unexpected,bestCandidate bestParticle road is nullptr`
CLMMPED,%{public}.1lf,Using outgoing,incomingID,%{private}lld,outgoingID,%{private}lld,score,%{public}.8lf
CLMMPED,%{public}.1lf,Unexpected,unable to calculate score
CLMMPED,%{public}.1lf,Unexpected,unable to fill crumb
CLMMPED,%{public}.1lf,bestParticleRoadID,%{private}lld,score,%{public}.8lf
bool CLParticleMM::MMFilterData::shallUseSnapCourse(const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,not snapping course,reason,distanceToIntersection,%{public}.1lf
CLMMPED,%{public}.1lf,distToNextMulti,%{public}.1lf,distFromPriorCrumb,%{public}.1lf,fabsCourseDiffWithSnap,%{public}.1lf,fabsCourseDiffWithPriorFullSnap,%{public}.1lf
bool CLParticleMM::CLParticleMapMatcherFilterBase::mapMatch(CLMapCrumb &)
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, mapMatch
CLMMPED,%{public}.1lf,unable to compute timeDiff
CLMMPED,%{public}.1lf,not matching, time betwen updates is 0.0
CLMMPED,%{public}.1lf,filterReset, dT, %{public}.1lf
CLMMPED,%{public}.1lf,not matching
CLMMPED,%{public}.1lf,filterReset, assessMatch failed
CLMMPED,%{public}.1lf,filterReset, adjustSolutionforRoadWidth failed
CLMMPED,%{public}.1lf,isSolutionAmbiguous,%{public}d,consecutiveAmbCount,%{public}.1lf
CLMMPED,%{public}.1lf,filterReset, shallReset
CLMMPED,%{public}.1lf,unable to re-initialize filter
bool CLParticleMM::CLParticleMapMatcherFilterBase::prepareSolution(const std::vector<CLParticleMapMatcherCommon::Particle> &, const CLParticleMM::MMSnapData &, CLMapCrumb &, bool, bool, CLParticleMM::MMFilterData &)
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, prepareSolution
CLMMPED,%{public}.1lf,unable to initialize filter
CLMMPED,%{public}.1lf,filterReset, prediction failed
CLMMPED,%{public}.1lf,filterReset, update failed
CLMMPED,%{public}.1lf,using route hints
CLMMPED,%{public}.1lf,filterReset, prepareCandidates failed
void CLParticleMM::CLParticleMapMatcherFilterBase::checkForUserDeviationFromRoute(const std::vector<CLParticleMapMatcherCommon::Particle> &, const CLParticleMM::MMSnapData &, CLParticleMM::MMFilterData &, CLMapCrumb &)
CLMMPED,%{public}.1lf,checkForUserDeviationFromRoute skipped,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,routeHints,solutionDiff,%{public}.2lf,newSolutionDiff,%{public}.2lf,courseDiffNewAndRawSolution,%{public}.2lf,factor,%{public}.5lf,bestParticle,%{private}.8lf,%{private}.8lf,%{public}.3lf,%{private}lld,newBestParticle,%{private}.8lf,%{private}.8lf,%{public}.3lf,%{private}lld
CLMMPED,%{public}.1lf,filter swapped with local filter without routeHints,local,factor,%{public}.5lf,courseDiffNewAndRawSolution,%{public}.2lf
void CLParticleMM::CLParticleMapMatcherFilterBase::checkForSolutionJumpsAndRecomputeSolution(const std::vector<CLParticleMapMatcherCommon::Particle> &, const CLParticleMM::MMSnapData &, CLParticleMM::MMFilterData &, CLMapCrumb &)
CLMMPED,%{public}.1lf,solutionJumpCheck,shouldNotPropagateFromLastSnap,%{public}d,consecutiveAmbiguityEpochCount,%{public}.1lf,deltaAz,%{public}.2lf,courseDiffWithPriorSolution,%{public}.2lf,acrossTrack,%{public}.2lf,bestLL,%{private}.7lf,%{private}.7lf
CLMMPED,%{public}.1lf,solutionJumpCheck,solution replacement failed as returned particle has invalid road
CLMMPED,%{public}.1lf,solutionJumpCheck,solution replaced with previous propagated solution,%{public}.2lf,bestLL,%{private}.7lf,%{private}.7lf,newLL,%{private}.7lf,%{private}.7lf
CLMMPED,%{public}.1lf,solutionJumpCheck,solution replacement failed as unable to fillCrumb
CLMMPED,%{public}.1lf,solution jump detected, recomputing without course,solutionDiff,%{public}.2lf
CLMMPED,%{public}.1lf,course,solutionDiff,%{public}.2lf,newSolutionDiff,%{public}.2lf
CLMMPED,%{public}.1lf,filter swapped with local filter without course, solutionDiffCheck
CLMMPED,%{public}.1lf,filter swapped with local filter without course, courseDiffCheck
CLMMPED,%{public}.1lf,solution jump detected,routeHints are not used
CLMMPED,%{public}.1lf,solution jump detected,verifying routeHints,courseDiffBetweenPriorSolution,%{public}.2lf,distanceDiffBetweenPriorSolution,%{public}.2lf
CLMMPED,%{public}.1lf,solution jump detected,routeHints are OK, skipping recomputation
CLMMPED,%{public}.1lf,solution jump detected, recomputing without routeHints,solutionDiff,%{public}.2lf
CLMMPED,%{public}.1lf,routeHints,solutionDiff,%{public}.2lf,newSolutionDiff,%{public}.2lf
CLMMPED,%{public}.1lf,filter swapped with local filter without routeHints
double CLParticleMM::CLParticleMapMatcherFilterBase::getDistanceTravelled(const CLMapCrumb &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,unexpected, negtive dT,%{public}.1lf
#Warning,CLMMPED,%{public}.1lf,Position jump,%{public}.1lf,dT,%{public}.1lf
CLMMPED,%{public}.1lf,predictionAndUpdate, distance,%{public}.1lf,distBasedOnSpeed,%{public}.1lf,distBasedOnPos,%{public}.1lf
void CLParticleMM::CLParticleMapMatcherFilterBase::updateIntersectionInfo(const CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &, CLParticleMapMatcherCommon::IntersectionInfo &)
CLMMPED,%{public}.1lf,Unexpected, prior or current snap is valid but bestparticle road is null
bool CLParticleMM::CLParticleMapMatcherFilterBase::modifyHorizontalUncertainty(CLParticleMM::MMFilterData &)
CLMMPED,%{public}.1lf,lat,%{private}.8lf,lon,%{private}.8lf,alt,%{public}.2lf,course,%{public}.1lf,snapLat,%{private}.8lf,snapLon,%{private}.8lf,snapCourse,%{public}.1lf,horizontalError,%{public}.2lf,hunc,%{public}.2lf,ratio,%{public}.2lf
bool CLParticleMM::CLParticleMapMatcherFilterBase::moveParticleAndCheckDivergence(const std::string, const std::string, CLParticleMapMatcherCommon::Particle &, const double, const CLMapCrumb &, double &)
CLMMPED,%{public}.1lf,moveParticle,failed,%{public}s,moveDistance,%{public}.1lf
CLMMPED,%{public}.1lf, no DOT,%{public}s,location or course diverged
bool CLParticleMM::CLParticleMapMatcherFilterBase::moveParticle(CFAbsoluteTime, CLParticleMapMatcherCommon::Particle &, double) const
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, moveParticle
CLMMPED,%{public}.1lf,moveParticle,moveOnRoad returned false,roadID,%{private}lld,projection,%{public}.3lf,fwd,%{public}d,moveDistance,%{public}.2lf
CLMMPED,%{public}.1lf,moveParticle,null road
CLMMPED,%{public}.1lf,moveParticle,unexpected particle with snapLat == snapLon == 0
CLMMPED,%{public}.1lf,moveParticle,invalidProjection,%{public}.3lf,roadID,%{private}lld
next
bool CLParticleMM::CLParticleMapMatcherFilterBase::isCloseToMultiOutboundIntersection(CLParticleMapMatcherCommon::Particle, const CLMapCrumb &, const bool, double &) const
CLMMPED,%{public}.1lf,no DOT,too close to %{public}s intersection,dist,%{public}.2lf,speed,%{public}.2lf
CLMMPED,%{public}.1lf,moveParticle failed for %{public}s particle,distance,%{public}.1lf
CLMMPED,%{public}.1lf,no DOT, too close to a %{public}s road with large direction change
bool CLParticleMM::CLParticleMapMatcherFilterBase::getRoadsAtIntersection(const CFAbsoluteTime, const CLMapGeometry::DistanceQueryResult &, CLMapGeometry::ConnectedQueryResultList &)
CLMMPED,Unexpected,invalid geometry pointer, getRoadsAtIntersection
CLMMPED,Unexpected,null road, getRoadsAtIntersection
bool CLParticleMM::findMultiOutboundIntersection(CLMapGeometryPtr, const CLMapGeometry::DistanceQueryResult &, bool, double, CLMapGeometry::ConnectedQueryResultList &)
CLMMPED,Unexpected,invalid geometry pointer, findMultiOutboundIntersection
bool CLParticleMM::CLParticleMapMatcherFilterBase::isHarshDigitizationCaseAtTurns(CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,harshDigitizationCheck skipped,signalEnv,%{public}d
CLMMPED,%{public}.1lf,harshDigitizationCheck skipped,courseDiff,%{public}.3lf,acrossTrack,%{public}.3lf
CLMMPED,%{public}.1lf,Unexpected,invalid road pointer,isHarshDigitizationCaseAtTurns
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer,isHarshDigitizationCaseAtTurns
CLMMPED,%{public}.1lf,findMultiOutboundIntersection returned false, searching for next connected candidates
CLMMPED,%{public}.1lf,findMultiOutboundIntersection returned false, searching for prior connected candidates
CLMMPED,%{public}.1lf,harshDigitizationCheck,road,%{private}lld,isApproachingMulti,%{public}d,justCrossedMulti,%{public}d,nextList,%{public}lu,priorList,%{public}lu,threshold,%{public}.1lf,roadWidth,%{public}.1lf,courseDiff,%{public}.3lf,AT,%{public}.3lf,harshAmb,%{public}d
bool CLParticleMM::CLParticleMapMatcherFilterBase::isSolutionAmbiguous(CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,isSolutionAmbiguous check,already ambiguous
CLMMPED,%{public}.1lf,AverageVarianceFactor,count,%{public}d,vf,%{public}.4lf,avf,%{public}.4lf,avfBuffer,%{public}.4lf,avfBufferCnt,%{public}zu,avfBuffer60,%{public}.4lf,avfBuffer30,%{public}.4lfisUsable,%{public}d,deltaAz,%{public}.2lf,fabsAT,%{public}.2lf,threshold,%{public}.2lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,routeHintsAvailable,1
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,isSnapUsable,0
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,sameAsRawGPS,1
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,isHarshDigitizationCaseAtTurns,1
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1, previous solution was ambiguous and AT,%{public}.1lf,is over scaled threshold,%{public}.1lf,consecutiveAmbCnt,%{public}1lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,averageVarianceFactor,count,%{public}d,vf,%{public}.4lf,avf,%{public}.4lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,lowAcrossTrack,%{public}.1lf,threshold,%{public}.2lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,overridden based on course matching,%{public}.2lf,AT,%{public}.2lf,hunc,%{public}.2lf,threshold,%{public}.2lf
CLMMPED,%{public}.1lf,skipping building checks for unknown roads,%{public}d
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,fewerThan2Buildings,%{public}d
CLMMPED,%{public}.1lf,isSolutionAmbiguous,-1,buildingCount,%{public}d,latitude,%{private}.7lf,longitude,%{private}.7lf,course,%{public}.2lf,rightSideCount,%{public}d,leftSideCount,%{public}d,searchDistance,%{public}.2lf,averageBuildingDirection,%{public}.2lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,buildingNotOnBothSides,rightCount,%{public}d,leftCount,%{public}d
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,buildingOnBothSides but AT too high,rightCount,%{public}d,leftCount,%{public}d,AT,%{public}.1lf,threshold,%{public}.1lf
virtual bool CLParticleMM::CLPedestrianMapMatcherFilter::initialize(CLParticleMM::MMFilterData &)
CLMMPED,%{public}.1lf,initialized called on already intialized filter
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, initialize
CLMMPED,%{public}.1lf,roadsWithinDistance returned false
CLMMPED,%{public}.1lf,roadsWithinDistance returned 0 roads
CLMMPED,%{public}.1lf,Unexpected, NULL road at initialization
CLMMPED,%{public}.1lf,Unexpected,zero particles at initialization
CLMMPED,%{public}.1lf,filter initialized
virtual bool CLParticleMM::CLPedestrianMapMatcherFilter::shallUseNetwork(const CLMapCrumb &)
CLMMPED,%{public}.1lf,allowsNetworkUsage,%{public}d
virtual void CLParticleMM::CLPedestrianMapMatcherFilter::prefilterCourse(CLMapCrumb &, const CLParticleMM::MMSnapData &)
CLMMPED,match,%{public}.1lf,course invalidated as courseUnc was invalid,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,match,%{public}.1lf,invalidCourseInfoUpdatedUsingPreviousEpochInfo,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,courseInvalidated,particle near multioutbound intersection,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,highCourseUncDataReplacedWithPreviousEpochInfo,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,courseInvalidated,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,courseUncFloorApplied,course,%{public}.2lf,courseUnc,%{public}.2lf
virtual double CLParticleMM::CLPedestrianMapMatcherFilter::getProcessNoise(const CLMapCrumb &, const CLParticleMM::MMSnapData &)
int CLParticleMM::CLPedestrianMapMatcherFilter::addRouteHintParticles(CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,routeHint,lat,%{private}.8lf,lon,%{private}.8lf,course,%{public}.3lf,rseg,%{private}lld,fwd,%{public}d
virtual bool CLParticleMM::CLPedestrianMapMatcherFilter::predict(CLMapCrumb &, CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &)
CLMMPED,Unexpected,invalid geometry pointer, predict
CLMMPED,%{public}.1lf,predict called with 0 particles
CLMMPED,%{public}.1lf,prediction,%{public}d,NrParticles,%{public}lu,NrPriorIntersectionParticles,%{public}d,NrNewFwdIntersectionParticles,%{public}d,NrNewBiasedToPrior,%{public}d,NrNewBiasedToPriorOppositeDirection,%{public}d,NrNewAmbiguous,%{public}d,numNewRouteParticles,%{public}d
virtual bool CLParticleMM::CLPedestrianMapMatcherFilter::generateRouteHintMeasurement(const CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, generateRouteHint
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,failed as not enough route roads are available
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,route index,%{public}d,is more than number of route roads,%{public}ld
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,routeCourse,%{public}.1lf,is very different than crumb course,%{public}.1lf,rejection,%{public}d
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,routeCourse,%{public}.1lf,is different than crumb course,%{public}.1lf, and rejections are high,rejection,%{public}d
CLMMPED,%{public}.1lf,routeHints,skipping,moveOnRouteRoads meas,routeCourse,%{public}.1lf,is somewhat different than crumb course,%{public}.1lf
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,course deweighted,unc,%{public}.2lf
CLMMPED,%{public}.1lf,unexpected,routeHints,moving on to next route road,nullptr
CLMMPED,%{public}.1lf,routeHints,moving on to next route road,nextRouteRoadIndex,%{public}d,angleBetweenTwoRoads,%{public}.2lf,length,%{public}.2lf
CLMMPED,%{public}.1lf,routeHints,skipping,moveOnRouteRoads meas,crumb close to intersection and gpsCourse,%{public}.1lf,is matching with next road on route,%{public}.1lf,course,%{public}.1lf,nextCourseDiff,%{public}.1lf,approxCourseOfTurningRoad,%{public}.1lf,turningCourseDiff,%{public}.1lf,courseDiff,%{public}.1lf
CLMMPED,%{public}.1lf,routeHints,meas,moveOnRouteRoads,ll,%{private}.7lf,%{private}.7lf,course,%{public}.3lf,hunc,%{public}.3lf,cunc,%{public}.3lf,count,%{public}lu
CLMMPED,%{public}.1lf,routeHints, no meas, projection,routeCourse,%{public}.1lf,is very different than crumb course,%{public}.1lf,rejection,%{public}d
CLMMPED,%{public}.1lf,routeHints,meas,projection,ll,%{private}.7lf,%{private}.7lf,course,%{public}.3lf,hunc,%{public}.3lf,cunc,%{public}.3lf,count,%{public}lu,confidence,%{public}.4lf
CLMMPED,%{public}.1lf,routeHints,duplicate measurement check,measurementGood,%{public}d,vector,%{public}lu
CLMMPED,%{public}.1lf,routeHints,jump in route hint measurement,%{public}.3lf,rejecting
virtual bool CLParticleMM::CLPedestrianMapMatcherFilter::multiOutboundHelper(CLMapGeometry::DistanceQueryResult &, int &, double, CLMapGeometry::IntersectionQueryResultList &, CLMapGeometry::IntersectionQueryResultList &, double &, double &) const
CLMMPED,Unexpected,invalid geometry pointer, multiOutboundHelper
bool CLParticleMM::CLPedestrianMapMatcherFilter::evaluateMatch(const CLParticleMM::MMSnapData &, const CLParticleMM::MMSnapData &, bool &)
CLMMPED,%{public}.1lf,evaluateMatch,oldOffRoadCount,fabsDeltaAz,%{public}.2lf,priorFabsDeltaAz,%{public}.2lf,atIntersection,%{public}d,varFactor,%{public}.2lf,acrossTrack,%{public}.2lf,isAmbiguous,%{public}d
CLMMPED,%{public}.1lf,varFactorCheck,oldOffRoadCount,%{public}d,newOffRoadCount,%{public}d
CLMMPED,%{public}.1lf,courseCheck,oldOffRoadCount,%{public}d,newOffRoadCount,%{public}d
CLMMPED,%{public}.1lf,stopSnapping,distance > %{public}.0lfm,Intersection,%{public}d
CLMMPED,%{public}.1lf,jumpDistanceCheck,%{public}.1lf,expectedDistanceTravelled,%{public}.1lf,oldOffRoadCount,%{public}d,newOffRoadCount,%{public}d
CLMMPED,%{public}.1lf,evalauteMatch,offRoadCount,%{public}d,projection,%{public}.2lf,delta,%{public}d
CLMMPED,%{public}.1lf,stopSnapping,varFactor,%{public}.1lf,threshold,%{public}.1lf
CLMMPED,%{public}.1lf,stopSnapping,offRoadCount,%{public}d,threshold,%{public}d
CLMMPED,%{public}.1lf,reseting offRoadCount,%{public}d
CLMMPED,%{public}.1lf,startSnapping,shouldStartSnappingOnfrc,frc,%{public}d,name,%{public}s,using tighter-threshold
CLMMPED,%{public}.1lf,startSnapping criteria,distance2,%{public}.1lf,acrossTrack,%{public}.2lf,drms,%{public}.1lf,currentVF,%{public}.3lf,prioVF{public},%.3lf,curSpeed,%{public}.2lf,priorSpeed,%{public}.2lf,curCourse,%{public}.2lf,priorCourse,%{public}.2lf,fabsDeltaAz,%{public}.2lf,priorFabsDeltaAz,%{public}.2lf
CLMMPED,%{public}.1lf,startSnapping
virtual bool CLParticleMM::CLPedestrianMapMatcherFilter::shallReset(const CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,reset,snap coordinate is null island
CLMMPED,%{public}.1lf,reset,solution hopping detected
CLMMPED,%{public}.1lf,Reseeding due to varFactor,%{public}.1lf,max,%{public}.1lf
CLMMPED,%{public}.1lf,Reseeding as unable to match,max,%{public}d
CLMMPED,%{public}.1lf,accumulated snap distance is ~0, %{public}.3lf
CLMMPED,%{public}.1lf,Reseeding due to stuck at dead-end while observations move away, ratioDist, %{public}.3lf
bool CLParticleMM::CLPedestrianMapMatcherFilter::checkForSolutionHopping(const CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,hopping check,connecting roads,%{public}d, current road %{private}lld,prior road %{private}lld
CLMMPED,%{public}.1lf,hopping check,prior road, %{private}lld, connected to the incoming road, %{private}lld, of the current solution road, %{private}lld
CLMMPED,%{public}.1lf,hopping between roads detected,priorfullSnapCourse,%{public}.1lf,currentFullSnapCourse,%{public}.1lf,priorId,%{private}llu,currentId,%{private}llu
virtual bool CLParticleMM::CLPedestrianMapMatcherFilter::adjustSolutionforRoadWidth(CLParticleMM::MMFilterData &)
CLMMPED,%{public}.1lf,roadWithAdustment,number of particles are 0
CLMMPED,%{public}.1lf,roadWithAdustment,snap invalid or frc = 9
CLMMPED,%{public}.1lf,roadWithAdustment,road is nullptr
CLMMPED,%{public}.1lf,frc,%{public}d,oneway,%{public}d,roadWidth,%{public}.1lf,acrossTrack,%{public}.3lf
virtual bool CLParticleMM::CLPedestrianMapMatcherFilter::generateDirectionOfTravelAssistance(const CLParticleMM::MMFilterData &, const CLParticleMM::MMSnapData &)
CLMMPED,%{public}.1lf,Unexpected,invalid bestParticle road,DOT
CLMMPED,%{public}.1lf,Unexpected,invalid timeDiff,DOT
CLMMPED,%{public}.1lf,timeDiff too large,DOT
CLMMPED,%{public}.1lf, no DOT, currentCrumb invalid
CLMMPED,%{public}.1lf, no DOT, priorCrumb invalid
CLMMPED,%{public}.1lf, no DOT,feedback interval check
CLMMPED,%{public}.1lf, no DOT, too close to prior intersection,transitiondetected,%{public}d,dist,%{public}.2lf
CLMMPED,%{public}.1lf, no DOT, course not aligned to full snap
CLMMPED,%{public}.1lf, no DOT, priorCrumb location or course diverged
lookBehindParticle
currentCrumb
Start
CLMMPED,%{public}.1lf, no DOT, computeSnapCoordinatesFromRawGPSCoordinates lookBehind returned false
CLMMPED,%{public}.1lf, no DOT, predicted point is too close to intersection,dist,%{public}.2lf
predictedParticle
CLMMPED,%{public}.1lf, no DOT, current particle within the stopDistanceFromIntersection
lookAheadParticle
Predicted
CLMMPED,%{public}.1lf,DOT,%{public}.1lf,lat,%{private}.7lf,lon,%{private}.7lf,course,%{public}.1lf,courseUnc,%{public}.1lf,rw,%{public}.1lf,startLat,%{private}.7lf,startLon,%{private}.7lf,length,%{public}.1lf,speed,%{public}.3lf,isOneWay,%{public}d,isRailWay,%{public}d,isTunnel,%{public}d,isBridge,%{public}d,distFromIntersection,%{public}.1lf,isFreeway,%{public}d,machContTime,%{public}.3lf,lookBehindDist,%{public}.2lf,type,%{public}d
double CLMapRoad::getHeadingForSegment(const int) const
CLMM,getHeadingForSegment,stored bearing value unavailble,had to be calculated,%{private}lld,index,%{public}d
bool CLParticleMapMatcherCommon::checkDivergence(const CFAbsoluteTime &, double, double, double, const CLMapCrumb &, CLDistanceCalc &, double &)
CLMM,%{public}.1lf, no DOT, course is not aligned
CLMM,%{public}.1lf, across track too large, not suitable DOT assistance
CLMM,%{public}.1lf, along track too large, not suitable DOT assistance
bool CLParticleMapMatcherCommon::determineRouteHintRoadVectors(const CLMapCrumb &, const CLMapGeometryPtr, CLDistanceCalc &, CLMapsRouteHintData &, std::vector<CLMapGeometry::DistanceQueryResult> &, double, bool)
CLMM,%{public}.1lf,routehint timed out or empty, segments,%{public}lu
CLMM,%{public}.1lf,Unexpected,invalid geometry pointer, determineRouteHintRoadVectors
CLMM,%{public}.1lf,routeHint road search,isConnectivityGood,poorConnectivity caused by radar:58817500,%{public}lu,file radar if 58817500 is already fixed
CLMM,%{public}.1lf,routeHint road search,getConnectedRouteSegments,poorConnectivity caused by radar:58817500,%{public}lu,file radar if 58817500 is already fixed
CLMM,%{public}.1lf,routeHints,search, roadsWithinDistance returned false
CLMM,%{public}.1lf,Unexpected, empty road list
CLMM,%{public}.1lf,routeHints,road search, invalid data encountered, same start and end route coords, not using routehints,sLat,%{private}.7lf,sLon,%{private}.7lf,eLat,%{private}.7lf,eLon,%{private}.7lf
CLMM,%{public}.1lf,routeHints,road search,road already present,%{private}lld
CLMM,%{public}.1lf,routeHints,road search,roadList,%{public}lu,routeRoads,%{public}lu,routeID,%{private}lld,matched,%{private}lld
CLMM,%{public}.1lf,routeHints,road search,road already present,start,%{private}lld
CLMM,%{public}.1lf,routeHints,road search,road already present,stop,%{private}lld
#Warning,CLMM,%{public}.1lf,routeHints,unable to find routeHints road,segments,%{public}lu,roadList,%{public}lu
bool CLGeoMapFeatureAccessGeometryCommon::isCoordinateOnRoadVector(CLDistanceCalc &, const double, const double, CLMapRoadPtr, double &, double &)
#Warning CLMM, findClosestPointOnRoad returned false
bool CLGeoAccessCommon::findClosestPointOnRoad(CLDistanceCalc &, const int, const std::vector<GEOLocationCoordinate2D> &, const GEOLocationCoordinate2D &, double &, double &)
CLMM,findClosestPointOnRoad,CoordinateCount is <= 1
std::vector<std::optional<std::tuple<CLTilesManager_Type::AccessPointEntry, WifiTileXY>>> CLWifiTileCacheLogic::findCentroids(const std::vector<CLMacAddress> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point, const CLIWifiTileSearchDelegate *) const
#wifitilecentroids, read cache, %{public}d, in_tiles, %{public}d, not_in_tiles, %{public}d, not_found, %{public}d
macs_to_search_in_tiles.size() == tile_results.size()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/CLWifiTileCacheLogic.mm
findCentroids
#wifitilecentroids, search tiles, searched, %{public}d, found, %{public}d
#wifitilecentroids, write to cache, new size, %{public}du / %{public}du
void CLWifiTileCacheLogic::clear()
#wifitilecentroids, clear cache
time,
,type,
,stepType,
,count,
,id,
,startLL,
,endLL,
void CLMapsRouteHintData::debugOutput() const
CLMM,RouteHints,%s
bool CLMapsRouteHintData::isConnectivityGood() const
CLMM,%.3lf,RouteHints received without proper connections
bool CLMapsRouteHintData::getConnectedRouteSegments() const
CLMM,%.3lf,RouteHints received without proper connections,changing segments from %lu,to,%lu
std::vector<CLWifiService_Type::AccessPoint> CLWifiScanAggregator::getScannedAccessPoints(const CFAbsoluteTime, const CFTimeInterval)
Returning %{public}zu APs
void CLWifiScanAggregator::pruneAggregatedResults(const CFAbsoluteTime)
Scrubbing done,pre,%{public}zu,post,%{public}zu
RoadTilesRadiusInMetersHome
BuildingTilesRadiusInMetersHome
RoadTilesRadiusInMetersWork
BuildingTilesRadiusInMetersWork
RoadTilesRadiusInMetersSchool
BuildingTilesRadiusInMetersSchool
PrecachingTileRefreshPeriod
PrecachingMinimumBatteryLevel
PrecachingXPCDownloadInterval
PrecachingDownloadSizePerSection
PrecachingUploadSizePerSection
PrecachingDownloadTimePerSection
UseInsideOutTileDownload
IsDiskIntensiveActivity
CLGpsAssistantSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/GPS/CLGpsAssistant.mm
-[CLGpsAssistantAdapter beginService]
void CLGpsAssistant::setVehicleSpeedAssistance(const double &, const CLNmeaSCD &)
STARK,SpeedTO,isOffsetValid,%d,offsetUncSecs,%.9g,filteredOffsetSecs,%.4lf,machTime,%.4lf,vehicleTime,%.4lf
void CLGpsAssistant::setVehicleGyroAssistance(const double &, const CLNmeaGCD &)
STARK,GyroTO,isOffsetValid,%d,offsetUncSecs,%.9g,filteredOffsetSecs,%.4lf,machTime,%.4lf,vehicleTime,%.4lf
virtual void CLNotifier<CLGpsAssistant_Type::Notification, CLGpsAssistant_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLGpsAssistant_Type::Notification, NotificationData_T = CLGpsAssistant_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLGpsAssistant_Type::Notification, CLGpsAssistant_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLGpsAssistant_Type::Notification, NotificationData_T = CLGpsAssistant_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGpsAssistant_Type::Notification, CLGpsAssistant_Type::NotificationData>::removeClient(int) [Notification_T = CLGpsAssistant_Type::Notification, NotificationData_T = CLGpsAssistant_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGpsAssistant_Type::Notification, CLGpsAssistant_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLGpsAssistant_Type::Notification, NotificationData_T = CLGpsAssistant_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGpsAssistant_Type::Notification, CLGpsAssistant_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLGpsAssistant_Type::Notification, NotificationData_T = CLGpsAssistant_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLGpsAssistant_Type::Notification, CLGpsAssistant_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLGpsAssistant_Type::Notification, NotificationData_T = CLGpsAssistant_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLGpsAssistant_Type::Notification, CLGpsAssistant_Type::NotificationData>::listClients() [Notification_T = CLGpsAssistant_Type::Notification, NotificationData_T = CLGpsAssistant_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
CLActivityAlarmConcentrator
d24@?0I8d12B20
void CLActivityAlarmConcentrator::removeAlarm(CMActivityAlarmLocal *)
Removing an alarm which has not been added.
Remove
NSTimeInterval CLActivityAlarmConcentrator::alarmHandler(CMActivityAlarmTrigger, NSTimeInterval, bool)
#Warning Invalid trigger.trigger,%u
Wake
Fire
Action
MotionActivityAlarm
BundleID
AlarmTrigger
AlarmDuration
-[CLBarometerCalibrationSourceWifi initWithUniverse:delegate:]
enabling wifi data source
baro
-[CLBarometerCalibrationSourceWifi onWifiServiceNotification:data:]
received wifi scan notification
received wifi scan cache notification
-[CLBarometerCalibrationSourceWifi processActiveScan:]
buffered %zu samples, submitted %zu samples, between %f and %f
hidden
collectionTime
-[CLBarometerCalibrationSourceWifi writeWifiAPToJson:withData:]
Unable to serialize dictionary data to json stream. Error: %@
Unable to write logs to json file! Exception: %{private}@
__objc_no
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/ActivityAlarm/CMActivityAlarmLocal.mm
-[CMActivityAlarmLocal initWithTrigger:duration:onQueue:withHandler:]
trigger,%d,duration,%f
<locationd internal>
-[CMActivityAlarmLocal initWithTrigger:duration:onQueue:forClient:withHandler:]
-[CMActivityAlarmLocal initWithTrigger:duration:onRunLoop:withHandler:]
ActivityAlarm
(startTime, endTime, percentNoObservation, percentDyskinesiaLikely, percentTremorAbsent, percentTremorSlight, percentTremorMild, percentTremorModerate, percentTremorStrong) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
percentNoObservation
percentDyskinesiaLikely
percentTremorAbsent
percentTremorSlight
percentTremorMild
percentTremorModerate
percentTremorStrong
CLActivityRecorderDb<ParkinsonsResult>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<ParkinsonsResult>::setDatabaseAccessible() [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<ParkinsonsResult>::sanitizeAndStoreRecordUL(const T &, bool) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLBTLEBeaconProviderSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/BTLEBeaconProvider/CLBTLEBeaconProvider.mm
-[CLBTLEBeaconProviderAdapter beginService]
CLBTLEBeaconProvider
CLDarwinNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/DarwinNotifier/CLDarwinNotifier.mm
-[CLDarwinNotifierAdapter beginService]
CLDarwinNotifier
virtual bool CLDarwinNotifier::registerForNotificationInternal(const CLDarwinNotifier_Type::Notification &)
Unknown registration requested: %{public}d
virtual bool CLDarwinNotifier::unregisterForNotificationInternal(const CLDarwinNotifier_Type::Notification &)
Unknown unregistration requested: %{public}d
void CLDarwinNotifier::registerForDaemonSettings(bool)
Attempted to re-register for daemon settings while already registered
#Warning Attempted to unregister for daemon settings while not registered
com.apple.locationd.appleAccountDidChange
void CLDarwinNotifier::registerForAppleAccountDidChange(bool)
Attempted to re-register for AppleAccountDidChange while already registered
#Warning Attempted to unregister for AppleAccountDidChange while not registered
virtual void CLNotifier<CLDarwinNotifier_Type::Notification, CLDarwinNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLDarwinNotifier_Type::Notification, NotificationData_T = CLDarwinNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDarwinNotifier_Type::Notification, CLDarwinNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLDarwinNotifier_Type::Notification, NotificationData_T = CLDarwinNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDarwinNotifier_Type::Notification, CLDarwinNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLDarwinNotifier_Type::Notification, NotificationData_T = CLDarwinNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLDarwinNotifier_Type::Notification, CLDarwinNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLDarwinNotifier_Type::Notification, NotificationData_T = CLDarwinNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLDarwinNotifier_Type::Notification, CLDarwinNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLDarwinNotifier_Type::Notification, NotificationData_T = CLDarwinNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLDarwinNotifier_Type::Notification, CLDarwinNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLDarwinNotifier_Type::Notification, NotificationData_T = CLDarwinNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLDarwinNotifier_Type::Notification, CLDarwinNotifier_Type::NotificationData>::listClients() [Notification_T = CLDarwinNotifier_Type::Notification, NotificationData_T = CLDarwinNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
fGEOMapFeatureAccess != nullptr
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/MapMatching/CLGeoMapFeatureAccessGeometryPedestrian.mm
CLGeoMapFeatureAccessGeometryPedestrian
CLGeoMapFeatureAccessGeometryPedestrian::CLGeoMapFeatureAccessGeometryPedestrian(const bool)
CLMM,Watch,Allowing maps stale data
void CLGeoMapFeatureAccessGeometryPedestrian::provideCacheHint(double, double, double)_block_invoke
#Warning,CLMMPED,provideCacheHint reported error:%{public}lld (%{public}@) "%{private}@"
virtual bool CLGeoMapFeatureAccessGeometryPedestrian::roadsWithinDistance(CLMapGeometry::DistanceQueryResultList &, const CLMapCrumb &, double, bool) const
#Warning,CLMMPED,roadsWithinDistanceLite returned false
#Warning,CLMMPED,roadsWithinDistance returned nullptr
#Warning,CLMMPED,findClosestPointOnRoad returned false
#Warning,CLMMPED,interpolateOnRoad returned false
v16@?0@"GEOMapFeatureRoad"8
bool CLGeoMapFeatureAccessGeometryPedestrian::roadsWithinDistanceLite(std::vector<CLMapRoadPtr> &, const CLMapCrumb &, double, bool) const
#Warning,CLMMPED, query failed (roadsWithinDistance)
virtual bool CLGeoMapFeatureAccessGeometryPedestrian::roadsConnected(CLMapGeometry::ConnectedQueryResultList &, const CLMapRoadPtr &, bool, double, double, bool) const
#Warning,CLMMPED, findAllDigitizedRoads returned false
virtual bool CLGeoMapFeatureAccessGeometryPedestrian::roadsAtIntersection(CLMapCrumb &, CLMapGeometry::IntersectionQueryResultList *, CLMapGeometry::IntersectionQueryResultList *, bool, const CLMapRoadPtr &, bool, double, double, double &) const
CLGeoMapFeatureAccessGeometryPedestrian::roadsAtIntersection - Code not implemented
bool CLGeoMapFeatureAccessGeometryPedestrian::findAllDigitizedRoads(CLMapRoadPtr, bool, double, std::vector<CLMapRoadWithDirection> &, bool) const
#Warning,CLMMPED, roadsWithinDistance returned false
#Warning,CLMMPED, roadsWithinDistance returned false, expanded search
CLMM,%.1lf,Unexpected,RoadConnectionsEntry could not be created
CLMM,%{public}.2lf,CLGeoMapFeatureAccessGeometryPedestrian,ConnectedRoads found 0 roads, %{private}lld, totalResults,%{public}lu,roadStartLL,%{private}.7lf,%{private}.7lf,roadEndLL,%{private}.7lf,%{private}.7lf,searchCoordinate,%{private}.7lf,%{private}.7lf
bool CLGeoMapFeatureAccessGeometryPedestrian::moveOnRoadInternal(double, double, const CLMapGeometry::RoadInfoList &, CLMapGeometry::DistanceQueryResult &, int) const
#Warning,CLMMPED,input road is nullptr
#Warning,CLMMPED, road length is 0.0
#Warning,CLMMPED,GEOMapFeatureRoad id,%{private}lld,has less than two coordinate (moveOnRoadInternal),%{public}ld
#Warning,CLMMPED,moveOnRoad,findAllDigitizedRoads returned false
#Warning CLMMPED,moveOnRoadInternal,interpolateProjections returned false
virtual bool CLGeoMapFeatureAccessGeometryPedestrian::interpolateOnRoad(CLMapCrumb &, const CLMapRoadPtr &, bool, const double *, int) const
#Warning CLMM,interpolateOnRoad,interpolateProjections returned false
virtual bool CLGeoMapFeatureAccessGeometryPedestrian::moveOnRouteRoads(double, CLMapGeometry::DistanceQueryResult &, CLMapGeometry::DistanceQueryResultList &, double, int &) const
#Warning CLMMPED,moveOnRouteRoads,interpolateProjections returned false
CLMMPED,%.3lf, no more route roads available to cover the distance travelled,index,%d,size,%lu
CLMMPED,%.3lf, unexpectedly reached to the end of routeRoadList
cl_geo_access_map_feature_geometry_pedestrian_queue
bool CLGeoMapFeatureAccessGeometryCommon::performQuery(CLGeoMapFeatureAccessGeometryCommon::QueryFunction, const dispatch_queue_t &)_block_invoke
#Warning CLMM,GEOMapFeatureAccessRequest reported error:%{public}lld (%{public}@) "%{private}@"
bool CLGeoMapFeatureAccessGeometryCommon::performQuery(CLGeoMapFeatureAccessGeometryCommon::QueryFunction, const dispatch_queue_t &)
#Warning CLMM, GeoMapFeatureAccess query timed out
bool CLGeoAccessCommon::interpolateProjections(CLDistanceCalc &, const CLMapRoadPtr, double, GEOLocationCoordinate2D &, double &)
CLMM, NULL road
CLMM,interpolateProjections,CoordinateCount is 0
CLMM,interpolateProjections,inconsistent array size
CLMM,interpolateProjections,Could not interpolate, incorrect coordinateCount
CLMM,interpolateProjections,Could not interpolate to intended projection
CLMapRoadPtr CLGeoMapFeatureAccessGeometryCommon::makeRoadFromGEOMapFeatureRoad(CLDistanceCalc &, GEOMapFeatureRoad *)
CLMM,GEOMapFeatureRoad is null
#Warning CLMM, GEOMapFeatureRoad id,%{private}lld,has less than two coordinate,%{public}ld
bool CLGeoAccessCommon::getSegmentLengthsAndHeading(CLDistanceCalc &, const int, const GEOLocationCoordinate2D *, std::vector<double> &, std::vector<double> &, double &)
CLMM,getSegmentLengthsAndHeading,CoordinateCount is 0
CLMM,getSegmentLengthsAndHeading,coordArray is nullptr
void CLGeoMapFeatureAccessGeometryCommon::CLGeoRoadConnectionsMap::clearStoredStaleConnections(const CFAbsoluteTime)
CLMM,%{public}.1lf,ClearStoredStaleConnections,szBefore,%{public}d,szAfter,%{public}d
NotSet
IDSQueryInterval
LastIDSQueryTime
void CLEmergencyADR::registerIDSBatchIDQueryActivity()
#ADR,registerIDSBatchIDQueryActivity,Invalid interval value %{public}lld, reset to 0
#ADR,registerIDSBatchIDQueryActivity,Invalid interval value %{public}lld, reset to kIDSQueryInterval value
IDSQueryGracePeriod
#ADR,#registerIDSBatchIDQueryActivity,registering IDS Query activity,interval,%{public}lld,gracePeriod,%{public}lld
com.apple.locationd.emergencyContacts
void CLEmergencyADR::registerIDSBatchIDQueryActivity()_block_invoke
#ADR,registerIDSBatchIDQueryActivity,IDS query activity handler triggered with unexpected state %{public}d
#ADR,registerIDSBatchIDQueryActivity,IDS query activity handler triggered
void CLEmergencyADR::unregisterIDSBatchIDQueryActivity()
#ADR,unregistering IDS batch query activity
void CLEmergencyADR::issueIDSBatchIDQuery()
#ADR,issueIDSBatchQuery,MCProfileConnection class unavailable or Health Data Submission not allowed
#ADR,issueIDSBatchQuery,the device is neither a phone nor a tinker supported watch
void CLEmergencyADR::handleIDSBatchIDQueryResponse(NSDictionary<NSString *,NSNumber *> *, NSString *, NSError *)
#ADR,handleIDSBatchIDQueryResponse,EmergencyContactsMetric nil object
void CLEmergencyADR::cleanupEmergencyContactsMetrics()
#ADR,cleanupEmergencyContactsMetrics,fEmergencyContactsMetric is nil
void CLEmergencyADR::handlePhoneNumberChange(CLEmergencyADR::SimInstance)
#ADR,handlePhoneNumberChange,received phone number update for inst %{public}d
void CLEmergencyADR::handleCompanionNumberChange(const std::string &)
#ADR,handleCompanionNumberChange,companion phone number changed to %{private}s
void CLEmergencyADR::handleCommTypeChange(Emergency::CommunicationType)
#ADR,handleCommTypeChange,comm type changed to %{public}s
void CLEmergencyADR::handleTriggerTypeChange(CLEmergencyADR::EmergencyTriggerType)
#ADR,handleTriggerTypeChange,call trigger type changed to %{public}s
Home
Work
School
Address
bool CLEmergencyADR::sendAdr(CFAbsoluteTime, NSDictionary *, Emergency::CLEmergencySessionReport *, CLEmergencyADR::SendADRResponse) const
#ADR,sendAdr,required input is missing
call_information
caller_location
#ADR,sendAdr,failed to serialize ADR data dict into JSON
#ADR,sendAdr,encrypted ADR data and/or key are nil
#ADR,sendAdr,sending ADR for native number
#ADR,sendAdr,native number is empty, not sending ADR
#ADR,sendAdr,sending ADR for companion number
#ADR,sendAdr,companion number is empty or device supports alternate account, not sending ADR
dsa_availability
did_dsa_change_within_call
tel_alt
device_language
Dialer
Fall Detection
NSDictionary *CLEmergencyADR::createCallerLocationDict(Emergency::CLEmergencySessionReport *) const
#ADR,createCallerLocationDict,ERA disabled
#ADR,createCallerLocationDict,no data available for caller location dict so not sending
#ADR,createCallerLocationDict,invalid placemark
#ADR,createCallerLocationDict,failed to create location dict
full_address
address
NSData *CLEmergencyADR::createAESEncryptedDataAndKey(NSData *, int32_t, NSData **) const
#ADR,createAESEncryptedDataAndKey,data and/or key pointer are nil
#ADR,createAESEncryptedDataAndKey,unsupported AES key length,%{public}d
#ADR,createAESEncryptedDataAndKey,failed to generate AES key,error,%{public}d
#ADR,createAESEncryptedDataAndKey,failed to create AES encrypted data
#ADR,createAESEncryptedDataAndKey,successfully created AES key and encrypted data
NSData *CLEmergencyADR::createAESEncryptedData(NSData *, NSData *) const
#ADR,createAESEncryptedData,data and/or key pointer are nil
#ADR,createAESEncryptedData,unsupported AES key length,%{public}d
#ADR,createAESEncryptedData,failed to generate AES IV,error,%{public}d
#ADR,createAESEncryptedData,failed to encrypt data,error,%{public}d
#ADR,createAESEncryptedData,successfully encrypted data
NSArray *CLEmergencyADR::createWrappedKeyArray(const CLEmergencyEED2::PartnerCertMap &, uint64_t, NSData *, NSData *) const
#ADR,createWrappedKeyArray,hash of encrypted ADR data or key is nil so not computing wrapped keys
#ADR,createWrappedKeyArray,unable to convert cert data to SecCertificateRef for partner %{private}s
#ADR,createWrappedKeyArray,couldn't extract partner key from cert so not creating wrapping key,partner,%{public}s
#ADR,createWrappedKeyArray,failed to encrypt key for partner,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s
#ADR,createWrappedKeyArray,failed to create DER data for partner public key,partner,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s
partner_ID
wrapped_key
NSDictionary *CLEmergencyADR::createAdrDict(const std::string &, CFAbsoluteTime, uint64_t, NSDictionary *, NSData *, NSArray *, NSDictionary *) const
#ADR,createAdrDict,missing required info for forming ADR POST dict
data_version
encrypt_time
data
keys
bool CLEmergencyADR::postAdr(CLEmergencyADR::NumberType, NSDictionary *, Emergency::CLEmergencySessionReport *, CLEmergencyADR::SendADRResponse) const
#ADR,postAdr,failed to serialize ADR dict into JSON
#ADR,postADR,missing NSURLSession
bool CLEmergencyADR::postAdr(CLEmergencyADR::NumberType, NSDictionary *, Emergency::CLEmergencySessionReport *, CLEmergencyADR::SendADRResponse) const_block_invoke
#ADR,postADR,received response for %{public}s number
CLEmergencyADR::EmergencyContactsMetric::EmergencyContactsMetric(CLEmergencyADR *)
#ADR,EmergencyContactsMetric,ADR pointer is null
#ADR,EmergencyContactsMetric,medicalID unavailable or emergency contacts within medicalID unavailable
void CLEmergencyADR::EmergencyContactsMetric::clearIDSQueryTimeout()
#ADR,clearIDSQueryTimeout,timer cleared
#ADR,clearIDSQueryTimeout,no timer exists
void CLEmergencyADR::EmergencyContactsMetric::handleIDSBatchIDQueryResponse(NSDictionary<NSString *,NSNumber *> *, NSString *, NSError *)
#ADR,handleIDSBatchIDQueryResponse,query response is Empty. Early return
#ADR,handleIDSBatchIDQueryResponse,Early return,error:%{public}@
#ADR,handleIDSBatchIDQueryResponse,Received %{public}u responses for service %{public}s
#ADR,handleIDSBatchIDQueryResponse,Number %{private}s supports service %{public}s
#ADR,handleIDSBatchIDQueryResponse,Number %{private}s does not support service %{public}s
#ADR,handleIDSBatchIDQueryResponse,Unhandled status response for number %{private}s for service %{public}s
void CLEmergencyADR::EmergencyContactsMetric::submitIDSQueryCAStats()
#ADR,submitIDSQueryCAStats,adr pointer is nil
simCountry1
simCountry2
numContacts
numValidContacts
numiMessageContacts
numAppleContacts
com.apple.locationd.emergency_contacts
ProactiveHarvesting
ProactiveHarvestingIntervalBypass
LastProactiveTime
CLProactiveBatteryLevel
CLPolicyProactiveExternal::onProactiveHarvestingProviderNotification
CLBTLERSSIRangeCalculator-Mutex
VerboseRangeLoggingEnabled
bool CLBTLERSSIRangeCalculator::getRangeMeasurement(const CLMotionActivity &, CFTimeInterval, CLBTLERSSIRangeCalculator_Type::RangeMeasurement &, const std::string &, const uint16_t &, const uint16_t &)_block_invoke
#Warning Overriding VerboseRangeLoggingEnabled,%{private}d
time,%f,
uuid,%s,
major,%hd,
observable,%d,
range,%d,
unc,%f,
filteredRSSI,%d,
activity,%d,
confidence,%d,
activityFactor,%f,
fFilterPk_pre,%f,
tx,%f,
cntImmediate,%d,
cntNear,%d,
cntMid,%d,
cntFar,%d,
pImmediate,%f,
pNear,%f,
pMid,%f,
pFar,%f,
number rssi,%lu,
rssi,
%f,%d,%d,
bool CLBTLERSSIRangeCalculator::getRangeMeasurement(const CLMotionActivity &, CFTimeInterval, CLBTLERSSIRangeCalculator_Type::RangeMeasurement &, const std::string &, const uint16_t &, const uint16_t &)
iB: %{private}s
CLFallLogger
yyyyMMdd
%@.v%d.%@.%@
-[CLFallLogger _outputStream]
Unable to create directory. There is a file with the same name.
Directory creation failed: %@
File creation failed
CLBeaconFenceDatabase::CLBeaconFenceDatabase()
iB: No access to DB
BeaconFences
void CLBeaconFenceDatabase::cleanDatabase()
Cleaning DB: invalid proximity zone for fence, %{private}s
bool CLBeaconFenceDatabase::addFence(const CLBTLEBeaconRegion_Type::MonitoredRegion &)
iB: Adding fence,%{private}s
Error, invalid proximity zone for fence,%{private}s
BundleIdentifier
Identifier
ProximityUUID
Major
Minor
DefinitionMask
OnBehalfBundleIdentifier
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
#Warning Unable to bind SQL for adding fence,%{private}s
bool CLBeaconFenceDatabase::removeFence(const CLBTLEBeaconRegion_Type::MonitoredRegion &)
iB: Removing fence,%{private}s
#Warning Unable to bind SQL for removing fence,%{private}s
bool CLBeaconFenceDatabase::removeAllFencesForBundleIncludingOnBehalf(const std::string &)
iB: Removing all fences for bundle,%{private}s
=? OR 
#Warning Unable to bind SQL for removing all fences for bundle,%{private}s
SELECT DISTINCT 
bool CLBeaconFenceDatabase::getAllFences(CLBTLEBeaconRegion_Type::MonitoredRegions &)
iB: Retrieving all fences
Unable to get fences from the database
An error was encountered when retrieving fences from the database
bool CLBeaconFenceDatabase::getFencesForBundle(const std::string &, CLBTLEBeaconRegion_Type::MonitoredRegions &)
iB: Retrieving fences for bundle,%{private}s
Unable to bind SQL for retrieving fences for bundle,%{private}s
Unable to get fences from database for bundle,%{private}s
An error was encountered when retrieving fences from the database for bundle,%{private}s
bool CLBeaconFenceDatabase::getFencesForBundleIncludingOnBehalf(const std::string &, CLBTLEBeaconRegion_Type::MonitoredRegions &)
bool CLBeaconFenceDatabase::getFencesForBundleAndOnBehalf(const std::string &, const std::string &, CLBTLEBeaconRegion_Type::MonitoredRegions &)
bool CLBeaconFenceDatabase::getFenceForBundleAndOnBehalf(const std::string &, const std::string &, const std::string &, CLBTLEBeaconRegion_Type::MonitoredRegion &)
iB: Retrieving fence,%{private}s/%{private}s
Unable to bind SQL for retrieving fence,[%{private}s]/%{private}s/%{private}s
Unable to get fence,[%{private}s]/%{private}s/%{private}s, from database
int CLBeaconFenceDatabase::fenceCountForBundle(const std::string &)
Unable to get the fence count for bundle,%{private}s
void CLBeaconFenceDatabase::addOnBehalfBundleIdColumnIfNotExists()
iB: addOnBehalfBundleIdColumnIfNotExists
CLBeaconFenceAuthorizationManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLBeaconFenceAuthorizationManager.mm
-[CLBeaconFenceAuthorizationManagerAdapter beginService]
BeaconFenceAuthorizationManager
CLBeaconFenceAuthorizationManager-Notifier
CLBeaconFenceAuthorizationManager::CLBeaconFenceAuthorizationManager(id<CLIntersiloUniverse>)
Unable to initialize authorization manager with airplane mode status
bool CLBeaconFenceAuthorizationManager::addFence(const CLBTLEBeaconRegion_Type::MonitoredRegion &)
Unable to get fences for bundle,%{private}s. Fence,%{private}s, will not be added
#Warning Bundle,%{public}s, exceeds its fence limit,%{private}d. Fence,%{private}s, will not be added
iB: Added fence,%{private}s, to the database
Unable to add fence,%{private}s, to the database
bool CLBeaconFenceAuthorizationManager::removeFence(const CLBTLEBeaconRegion_Type::MonitoredRegion &)
iB: Removed fence,%{private}s, from the database
#Warning Unable to remove fence,%{private}s, from the database
void CLBeaconFenceAuthorizationManager::onClientManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
iB: Received uninstall for bundle,%{private}s
iB: Received authorization for bundle,%{private}s
iB: Received location services status,%{public}d
void CLBeaconFenceAuthorizationManager::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)
iB: Received airplane status,%{public}d
Unable to update authorization manager with airplane mode status
com.apple.CooLtool
bool CLBeaconFenceAuthorizationManager::unlockedIsOnBehalfBundleAuthorized(std::string)
Empty bundle identifier should not be passed in here
void CLBeaconFenceAuthorizationManager::unlockedSetFenceIconStateForBundle(const std::string &, bool)
iB: Setting icon state,%{public}d, for bundle,%{public}s
void CLBeaconFenceAuthorizationManager::unlockedRemoveAllFencesForBundle(const std::string &)
Unable to remove all fences from the database for bundle,%{public}s
void CLBeaconFenceAuthorizationManager::unlockedNotifyAllWithResumeFences()
#Warning Unable to retrieve all fences from the database
#Warning No fences will be resumed due to exception,%{public}d
void CLBeaconFenceAuthorizationManager::unlockedNotifyResumeFence(const std::string &, const std::string &, const std::string &)
Unable to get fence,[%{public}s]/%{public}s/%{private}s, from the database
#Warning Bundle(s) not authorized, fence,[%{public}s]/%{public}s/%{private}s, will not be resumed
#Warning Fence,[%{public}s]/%{public}s/%{private}s, will not be resumed due to exception,%{public}d
iB: Resuming fence,[%{public}s]/%{public}s/%{private}s
void CLBeaconFenceAuthorizationManager::unlockedNotifyAllWithSuspendFences(bool)
Unable to get all fences from database
void CLBeaconFenceAuthorizationManager::unlockedNotifyBundleAppropriatelyWithFences(const std::string &)
Unable to get fences from database for bundle,%{public}s
Auth
Auth2
Exception
iB: Resuming fences,%{public}lu, for bundle,%{public}s
void CLBeaconFenceAuthorizationManager::unlockedSuspendForException(CLBeaconFenceAuthorizationManager::MonitoringExceptions)
iB: Adding exception,%{public}#x, to stored exceptions %{public}#x
void CLBeaconFenceAuthorizationManager::unlockedResumeForException(CLBeaconFenceAuthorizationManager::MonitoringExceptions)
iB: Removing exception,%{public}#x, from stored exceptions %{public}#x
CLBeaconFenceAuthorizationManager
CLBeaconFenceAuthorizationManager::onBeaconNotification
CLBeaconFenceAuthorizationManager::onClientManagerNotification
CLBeaconFenceAuthorizationManager::onDaemonStatusNotification
virtual void CLNotifier<CLBeaconFenceAuthorizationManager_Type::Notification, CLBeaconFenceAuthorizationManager_Type::NotificationData, char, std::string>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLBeaconFenceAuthorizationManager_Type::Notification, NotificationData_T = CLBeaconFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
void CLNotifier<CLBeaconFenceAuthorizationManager_Type::Notification, CLBeaconFenceAuthorizationManager_Type::NotificationData, char, std::string>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLBeaconFenceAuthorizationManager_Type::Notification, NotificationData_T = CLBeaconFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual void CLNotifier<CLBeaconFenceAuthorizationManager_Type::Notification, CLBeaconFenceAuthorizationManager_Type::NotificationData, char, std::string>::removeClient(int) [Notification_T = CLBeaconFenceAuthorizationManager_Type::Notification, NotificationData_T = CLBeaconFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLBeaconFenceAuthorizationManager_Type::Notification, CLBeaconFenceAuthorizationManager_Type::NotificationData, char, std::string>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLBeaconFenceAuthorizationManager_Type::Notification, NotificationData_T = CLBeaconFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLBeaconFenceAuthorizationManager_Type::Notification, CLBeaconFenceAuthorizationManager_Type::NotificationData, char, std::string>::clientRegistered(int, const Notification_T &) [Notification_T = CLBeaconFenceAuthorizationManager_Type::Notification, NotificationData_T = CLBeaconFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual bool CLNotifier<CLBeaconFenceAuthorizationManager_Type::Notification, CLBeaconFenceAuthorizationManager_Type::NotificationData, char, std::string>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLBeaconFenceAuthorizationManager_Type::Notification, NotificationData_T = CLBeaconFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
virtual void CLNotifier<CLBeaconFenceAuthorizationManager_Type::Notification, CLBeaconFenceAuthorizationManager_Type::NotificationData, char, std::string>::listClients() [Notification_T = CLBeaconFenceAuthorizationManager_Type::Notification, NotificationData_T = CLBeaconFenceAuthorizationManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::string]
ranging_register
virtual bool CLBTLERangeManagerConcrete::registerForNotification(int, const CLBTLERangeManager_Type::Notification &, const CLBTLEBeaconRegion_Type::MonitoredRegions &)
Unable to register with base-class
ranging_unregister
virtual bool CLBTLERangeManagerConcrete::unregisterForNotification(int, const CLBTLERangeManager_Type::Notification &)
#Warning Unable to retrieve registration info for client,%{public}d
void CLBTLERangeManagerConcrete::onBeaconNotification(int, const CLBTLEBeaconProvider_Type::Notification &, const CLBTLEBeaconProvider_Type::NotificationData &)
iB: Received Bluetooth LE power,%{public}d
iB: Notifying region proximityUUID,'%{private}s', major,%{private}d, minor,%{private}d, mask,%{public}d with beacons,%{public}zu
void CLBTLERangeManagerConcrete::onMotionStateNotification(int, const CLMotionState_Type::Notification &, const CLMotionState_Type::NotificationData &)
iB: Received activity update of activity,%{private}d
#Warning Unexpected notification %{public}d
void CLBTLERangeManagerConcrete::unlockedStartIfInterested()
iB: Starting the manager if there's an interest in ranging
iB: There's no interest in ranging, the manager wont be started
iB: The manager is already started
void CLBTLERangeManagerConcrete::unlockedStopIfNotInterested()
iB: Stopping the manager if there's no interest in ranging
iB: There's an interest in ranging, the manager wont be stopped
iB:The manager is already stopped
void CLBTLERangeManagerConcrete::unlockedSuspendForException(CLBTLERangeManagerConcrete::RangingExceptions)
void CLBTLERangeManagerConcrete::unlockedResumeForException(CLBTLERangeManagerConcrete::RangingExceptions)
iB: Removing exception,%{public}#x, from stored exceptions %{public}#x.
CLBTLERangeManagerConcrete::onBeaconNotification
CLBTLERangeManagerConcrete::onMotionStateNotification
CLBTLERangeManagerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLBTLERangeManager.mm
-[CLBTLERangeManagerAdapter beginService]
CLBTLERangeManager-Notifier
CLBTLERangeManager
virtual void CLNotifier<CLBTLERangeManager_Type::Notification, CLBTLERangeManager_Type::NotificationData, char, std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>>::removeClient(int) [Notification_T = CLBTLERangeManager_Type::Notification, NotificationData_T = CLBTLERangeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>]
virtual bool CLNotifier<CLBTLERangeManager_Type::Notification, CLBTLERangeManager_Type::NotificationData, char, std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLBTLERangeManager_Type::Notification, NotificationData_T = CLBTLERangeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>]
virtual bool CLNotifier<CLBTLERangeManager_Type::Notification, CLBTLERangeManager_Type::NotificationData, char, std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>>::clientRegistered(int, const Notification_T &) [Notification_T = CLBTLERangeManager_Type::Notification, NotificationData_T = CLBTLERangeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>]
virtual bool CLNotifier<CLBTLERangeManager_Type::Notification, CLBTLERangeManager_Type::NotificationData, char, std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLBTLERangeManager_Type::Notification, NotificationData_T = CLBTLERangeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>]
virtual void CLNotifier<CLBTLERangeManager_Type::Notification, CLBTLERangeManager_Type::NotificationData, char, std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLBTLERangeManager_Type::Notification, NotificationData_T = CLBTLERangeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>]
void CLNotifier<CLBTLERangeManager_Type::Notification, CLBTLERangeManager_Type::NotificationData, char, std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLBTLERangeManager_Type::Notification, NotificationData_T = CLBTLERangeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>]
virtual void CLNotifier<CLBTLERangeManager_Type::Notification, CLBTLERangeManager_Type::NotificationData, char, std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>>::listClients() [Notification_T = CLBTLERangeManager_Type::Notification, NotificationData_T = CLBTLERangeManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = std::list<CLBTLEBeaconRegion_Type::MonitoredRegion>]
void CLMapCrumb::debugOutput(const std::string)
CLMM,%{public}s,trip,%{public}lld,T,%{public}.1lf,machT,%{public}.2lf,contT,%{public}.2lf,gpsTMs,%{public}d,%{public}d,LL,%{private}.7lf,%{private}.7lf,hunc,%{public}.1lf,alt,%{public}.1lf,vunc,%{public}.1lf,crse,%{public}.1lf,crseUnc,%{public}.1lf,spdKph,%{public}.3lf,spdUncMps,%{public}.1lf,a95,%{public}.1lf,b95,%{public}.1lf,theta,%{public}.1lf,snapLL,%{private}.7lf,%{private}.7lf,snapCrse,%{public}.1lf,fSnapLL,%{private}.7lf,%{private}.7lf,fSnapCrse,%{public}.1lf,pSnapLL,%{private}.7lf,%{private}.7lf,rwSnapLL,%{private}.7lf,%{private}.7lf,rwSnapOfstLL,%{private}.7lf,%{private}.7lf,rwFSnapOfstLL,%{private}.7lf,%{private}.7lf,rwLL,%{private}.7lf,%{private}.7lf,score,%{public}.1lf,ratio,%{public}.1lf,varFac,%{public}.7g,deltaAz,%{public}.3lf,alngTrk,%{public}.3lf,acrsTrk,%{public}.3lf,usable,%{public}d,ambiguous,%{public}d,proj,%{public}.3lf,type,%{public}d,rseg,%{private}lld,frc,%{public}d,fow,%{public}d,road,"%{private}s",activity,%{public}d,actConf,%{public}d,static,%{public}d,staticSetAt,%{public}.1lf,mount,%{public}d,fitness,%{public}d,shifted,%{public}d,propagated,%{public}d,rail,%{public}d,bridge,%{public}d,tunnel,%{public}d,favGPS,%{public}d,gnssCont,%{public}d,locationType,%{public}d,lifespan,%{public}.1lf,rawCourse,%{public}.1lf,sigEnv,%{public}d,sigEnvFid,%{public}d
void CLMapCrumb::condensedDebugOutput(const std::string) const
CLMM,%{public}s,T,%{public}.1lf,usable,%{public}d,ambiguous,%{public}d,LL,%{private}.7lf,%{private}.7lf,crse,%{public}.1lf,snapLL,%{private}.7lf,%{private}.7lf,snapCrse,%{public}.1lf,fSnapLL,%{private}.7lf,%{private}.7lf,fSnapCrse,%{public}.1lf,hunc,%{public}.1lf,alt,%{public}.1lf,vunc,%{public}.1lf,crseUnc,%{public}.1lf,spdMps,%{public}.3lf,spdUncMps,%{public}.1lf,a95,%{public}.1lf,b95,%{public}.1lf,theta,%{public}.1lf,shifted,%{public}d,propagated,%{public}d,rail,%{public}d,bridge,%{public}d,tunnel,%{public}d,locationType,%{public}d,sigEnv,%{public}d,sigEnvFid,%{public}d
trip,%lld
,T,%.1lf
,machT,%.2lf
,contT,%.2lf
,gpsTMs,%d,%d
,LL,%.7lf,%.7lf
,hunc,%.1lf
,alt,%.1lf
,vunc,%.1lf
,crse,%.1lf
,crseUnc,%.1lf
,spdKph,%.3lf
,spdUncMps,%.1lf
,a95,%.1lf
,b95,%.1lf
,theta,%.1lf
,snapLL,%.7lf,%.7lf
,snapCrse,%.1lf
,fSnapLL,%.7lf,%.7lf
,fSnapCrse,%.1lf
,pSnapLL,%.7lf,%.7lf
,rwSnapLL,%.7lf,%.7lf
,rwSnapOfstLL,%.7lf,%.7lf
,rwFSnapOfstLL,%.7lf,%.7lf
,rwLL,%.7lf,%.7lf
,score,%.1lf
,ratio,%.1lf
,varFac,%.7g
,deltaAz,%.3lf
,alngTrk,%.3lf
,acrsTrk,%.3lf
,usable,%d
,ambiguous,%d
,proj,%.3lf
,type,%d
,rseg,%lld
,frc,%d
,fow,%d
,road,"
,activity,%d
,actConf,%d
,static,%d
,staticSetAt,%.1lf
,mount,%d
,fitness,%d
,shifted,%d
,propagated,%d
,rail,%d
,bridge,%d
,tunnel,%d
,favGPS,%d
,gnssCont,%d
,locationType,%d
,lifespan,%.1lf
,rawCourse,%.1lf
void CLMapCrumb::fillSnapSolutionFromRawGPS(CLDistanceCalc &)
CLMM, %{public}.1lf, not matching, unable to compute snap from raw positions
bool CLMapCrumb::computeSnapCoordinatesFromRawGPSCoordinates(CLDistanceCalc &, const std::string, double, double, double &, double &) const
CLMM, %{public}.1lf, null island
CLMM, %{public}.1lf, New Snap Coordinates,%s,inSnapLat,%{private}.8lf,inSnapLon,%{private}.8lf,outSnapLat,%{private}.8lf,outSnapLon,%{private}.8lf
StepCadenceToStrideLengthTable
StepCadence
StrideLength
-[CMPedometerTableStepCadenceToStrideLength logBins]_block_invoke
-[CMPedometerTableStepCadenceToStrideLength updateBinsWithTrack:]
-[CMPedometerTableStepCadenceToStrideLength updateStrideLengthRun]
%s,%sRun,%0.4f
-[CMPedometerTableStepCadenceToStrideLength updateStrideLengthStepCadenceWalk]
%s,%sWalk,%0.4f,%sWalk,%0.4f
CLTransitMacMonitorSilo
-[CLTransitMacMonitor beginService]
#TransitMacMonitor: service begin
CLTransitMacTileDataProvider
CLTransitMacMonitor
-[CLTransitMacMonitor endService]
#TransitMacMonitor: service end
-[CLTransitMacMonitor setCurrentState:]
#TransitMacMonitor: transit state changed from, %{public}lu, to, %{public}lu
-[CLTransitMacMonitor processNewAccessPoints:transitTileResults:]
#TransitMacMonitor: added %{public}d new access point scans, total cache size, %{public}lu
#TransitMacMonitor: no scan history
#TransitMacMonitor: not enough scan history, length, %{public}f
#TransitMacMonitor: transit state, on transit, based on mac, %{private}@, history count, %{public}lu, interval, %{public}f
-[CLTransitMacMonitor onWifiServiceNotification:data:]
#TransitMacMonitor: wifi notification, %{public}d
#TransitMacMonitor: received a wifi scan with %{private}lu access points, but we don't have a location to query tiles
-[CLTransitMacMonitor onWifiServiceNotification:data:]_block_invoke
#TransitMacMonitor: error fetching from CLTransitMacTileDataProvider, %@
-[CLTransitMacMonitor onLocationNotification:data:]
Transit
void CLIntegrityMonitor::crossCheck(const CLDaemonLocation &, const CLDaemonLocation &, double &, bool &, double &)
#Warning deltaTime = %0.3f, but most negative allowed is %0.3lf, resetting Integrity Monitor
bool CLIntegrityMonitor::updateIM(CLDaemonLocation &)
locationType,integrityPrior,%d,integrityNew,%d
location type,%d,not supported
not reliable or very low reliable,locationType,%d,lat,%.8lf,lon,%.8lf
Location rejected by IM,Reason,disagrees with GPS,location type,%d
huncBump,fromHunc,%.1lf,toHunc,%.1lf
Location rejected by IM,Reason,disagrees with high confidence wifi,location type,%d
Location rejected by IM,Reason,low confidence wifi strongly disagrees with cell,location type,%d
CLTurnStateSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Context/CLTurnState.mm
-[CLTurnStateAdapter beginService]
CLTurnState
virtual bool CLTurnState::registerForNotificationInternal(const CLTurnState_Type::Notification &)
Client registered for notification %d
virtual bool CLTurnState::unregisterForNotificationInternal(const CLTurnState_Type::Notification &)
Client unregistered for notification %d
virtual void CLNotifier<CLTurnState_Type::Notification, CLTurnState_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLTurnState_Type::Notification, NotificationData_T = CLTurnState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLTurnState_Type::Notification, CLTurnState_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLTurnState_Type::Notification, NotificationData_T = CLTurnState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLTurnState_Type::Notification, CLTurnState_Type::NotificationData>::removeClient(int) [Notification_T = CLTurnState_Type::Notification, NotificationData_T = CLTurnState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTurnState_Type::Notification, CLTurnState_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLTurnState_Type::Notification, NotificationData_T = CLTurnState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTurnState_Type::Notification, CLTurnState_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLTurnState_Type::Notification, NotificationData_T = CLTurnState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLTurnState_Type::Notification, CLTurnState_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLTurnState_Type::Notification, NotificationData_T = CLTurnState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLTurnState_Type::Notification, CLTurnState_Type::NotificationData>::listClients() [Notification_T = CLTurnState_Type::Notification, NotificationData_T = CLTurnState_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/GyroBiasEstimator/CLNonlinearGyroBiasFitter.cpp
std::is_sorted(samples.begin(), samples.end())
nearestSample
subfitCount <= Fit::kFitSegments - 2
windowFit
CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLCoarseSignalEnvironmentDataManager::getSignalEnvironment(double, double, std::string, bool &)
CLSE,getSignalEnvironment,opening,%{public}s
#Warning,CLSE,getSignalEnvironment,could not open,%{public}s
#Warning,CLSE,getSignalEnvironment,could not read,%{public}s
CLSE,getSignalEnvironment,file has expired - redownload
CLSE,getSignalEnvironment,file version does not match expected
#Warning,CLSE,getSignalEnvironment,latitude,%{private}.9lf,out of range
#Warning,CLSE,getSignalEnvironment,byte index,%{public}d,is larger than the data available in the coarse signal environment binary file
#Warning,CLSE,getSignalEnvironment,invalid coarse signal environment file - unable to get data byte
#Error,CLSE,getSignalEnvironment,unexpected case,potential file corruption
static bool CLCoarseSignalEnvironmentDataManager::readSignalEnvHelper(CLCoarseSignalEnvironmentDataManager::SignalEnvironment &)
#Warning,CLSE,readSignalEnvHelper,fseek returned non-zero
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - header string
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - version
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - headerLength
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - minLat
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - maxLat
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - binsize
#Warning,CLSE,readSignalEnvHelper,coarse signal environment file is not %{public}f deg by %{public}f deg,spacing unexpected,%{public}f,re-download needed
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - timestamp
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - expiration age
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - data size
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - crc
CLTileDownloadSchedulingService
clhrse
static bool CLHighResolutionSignalEnvironmentDataManager::isLatLonValid(const double &, double &)
#Error,HRSE,is latitude finite,%d,is longitude finite,%d
#Error,HRSE,latitude is beyond the valid range,lat,%{private}.7lf
static CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLHighResolutionSignalEnvironmentDataManager::getSignalEnvironmentForTile(CLHighResolutionSignalEnvironmentDataManager::CLHRSETile &, double, double)
#Warning,HRSE,getSignalEnvironmentForTile,invalid tile
#Error,HRSE,getSignalEnvironmentForTile,invalid coordinates,lat,%{private}.7lf,lon,%{private}.7lf
#Warning,HRSE,getSignalEnvironmentForTile,cellsize is zero
#Warning,HRSE,getSignalEnvironmentForTile,latitude,%{private}.9lf,lessThanMin,%{private}.9lf
#Warning,HRSE,getSignalEnvironmentForTile,latitude,%{private}.9lf,exceedsMax,%{private}.9lf
#Warning,HRSE,getSignalEnvironmentForTile,longitude,%{private}.9lf,lessThanMin,%{private}.9lf
#Warning,HRSE,getSignalEnvironmentForTile,longitude,%{private}.9lf,exceedsMax,%{private}.9lf
#Warning,HRSE,getSignalEnvironmentForTile,invalid tile - unable to get data byte
HRSE,getSignalEnvironmentForTile,X,%{private}.7lf,Y,%{private}.7lf,x1,%{private}d,y1,%{private}d,iNibble,%{private}d,iByte,%{private}d,iNibbleInByte,%{private}d,typeNibble,%{private}d
#Error,HRSE,getSignalEnvironmentForTile,unexpected signal environment type detected: %{private}d
HRSE,getSignalEnvironmentForTile,hrseType,%{private}d
ForceDownloadHrseTiles
CLSignalEnvironmentProvider_Type::SignalEnvironmentType CLHighResolutionSignalEnvironmentDataManager::getSignalEnvironment(double, double)
HRSE,getSignalEnvironment,fForceDownloadHrseTiles, %d
#Error,HRSE,getSignalEnvironment,invalid coordinates,lat,%{private}.7lf,lon,%{private}.7lf
HRSE,getSignalEnvironment,not on the current in-memory tile,lat,%{private}.7lf,lon,%{private}.7lf,minLat,%{private}.7lf,maxLat,%{private}.7lf,minLon,%{private}.7lf,maxLon,%{private}.7lf
HRSE,getSignalEnvironment,tile not available
HRSE,getSignalEnvironment,need to load tile
HRSE,getSignalEnvironment,tile download needed,lat,%{private}.7lf,lon,%{private}.7lf,is file needed,%{public}d,is bad tile,%{public}d
HRSE,getSignalEnvironment,skipping loadTile query,skipCount,%{public}d
HRSE,Tile not loaded yet
HRSE,good to go!
HRSE,lat,%{private}.7lf,lon,%{private}.7lf,hrse,%{private}d
bool CLHighResolutionSignalEnvironmentDataManager::loadTile(double, double, bool &, bool &)
HRSE,loadTile,lat,%{private}.7lf,lon,%{private}.7lf
HRSE,loadTile,CLTilesManager,getTileFile,took,%{public}.1lf
#Warning,HRSE,loadTile,unexpected case,this tile should be on disk,%{public}s
#Error,HRSE,loadTile,remove the corrupted tile from disk,%{public}s
static bool CLHighResolutionSignalEnvironmentDataManager::calculateCLHRSE_CRC(unsigned char *, const size_t, const size_t, unsigned int &)
#Error,HRSE,calculateCLHRSE_CRC,indexCrcInBuffer,%{public}zu,exceeds (bufferSize-4) bytes,%{public}zu
static bool CLHighResolutionSignalEnvironmentDataManager::readCLHRSETileHeader(FILE *, CLHighResolutionSignalEnvironmentDataManager::CLHRSETileHeader &, size_t &, size_t &)
#Error,HRSE,readCLHRSETileHeader,fseek returned non-zero
#Error,HRSE,readCLHRSETileHeader,did not synchronize to tile header_string
#Error,HRSE,readCLHRSETileHeader,invalid CLHRSE tile file - header string
#Error,HRSE,readCLHRSETileHeader,invalid CLHRSE tile file - version and headerLength
#Error,HRSE,readCLHRSETileHeader,invalid tile version - expected,%d,got,%d
#Error,HRSE,readCLHRSETileHeader,invalid header length - expected,%d,got,%d
#Error,HRSE,readCLHRSETileHeader,invalid CLHRSE tile file - rest of header
#Warning,HRSE,readCLHRSETileHeader,header.dataSizeBytes != header.nrows * header.ncols
#Error,HRSE,readCLHRSETileHeader,invalid CLHRSE tile file - incorrect headerLength
HRSE,readCLHRSETileHeader,vers,%{private}d,headerLen,%{private}d,compressionType,%{private}d,expirationAge,%{private}d,timestamp,%{private}.1f,nrows,%{private}d,ncols,%{private}d,dataSizeBytes,%{private}d,crc,%{private}d,xllcorner,%{private}.7lf,yllcorner,%{private}.7lf,cellsize,%{private}.7f,buildingMedianHeight,%{private}.7f,buildingMaximumHeight,%{private}.7f
static bool CLHighResolutionSignalEnvironmentDataManager::readCLHRSETile(CLHighResolutionSignalEnvironmentDataManager::CLHRSETile &, const std::string &, bool &)
#Error,HRSE,readCLHRSETile,unable to load file,file path, %{public}s,errno, %{public}d
#Error,HRSE,readCLHRSETile,unable to read file header,file path, %{public}s
#Error,HRSE,readCLHRSETile,fseek returned non-zero,file path, %{public}s
#Error,HRSE,readCLHRSETile,zero file size,file path, %{public}s
#Error,HRSE,readCLHRSETile,invalid file size,file path, %{public}s
#Error,HRSE,readCLHRSETile,file format not supported,file path, %{public}s
#Error,HRSE,readCLHRSETile,tile is larger than the allowed maximum,file path, %{public}s
#Error,HRSE,readCLHRSETile,CLCommonSetFileProtectionClass failed
#Error,HRSE,readCLHRSETile,failed to read tile,file path, %{public}s
#Warning,HRSE,readCLHRSETile,calculateCLHRSE_CRC returned false unexpectedly
#Error,HRSE,readCLHRSETile,invalid CLHRSE,crc fail,calculated,%X,received,%X
void CLHighResolutionSignalEnvironmentDataManager::onAvlFileUpdated(CLFileUpdate *, CLFileUpdate::UpdateStatus)
#Error,HRSE,onAvlFileUpdated,null pointer
HRSE,onAvlFileUpdated,avl download status,NONE
HRSE,onAvlFileUpdated,avl download status,STARTED
HRSE,onAvlFileUpdated,avl download status,COMPLETED
HRSE,onAvlFileUpdated,avl downloaded,%{public}s
#Warning,HRSE,onAvlFileUpdated,Cannot set protection class for HRSE avl file,%{public}s
HRSE,onAvlFileUpdated,avl file decompressed,%{public}s,to,%{public}s
#Warning,HRSE,onAvlFileUpdated,Cannot set protection class for HRSE decompressed avl file,%{public}s
HRSE,onAvlFileUpdated,is availability file valid,%{public}d
#Warning,HRSE,onAvlFileUpdated,avl download status,FAILED
#Warning,HRSE,onAvlFileUpdated,avl download request failed,%{public}s,retryMultiplier,%{public}d
#Warning,HRSE,onAvlFileUpdated,avl download status,%{public}d
void CLHighResolutionSignalEnvironmentDataManager::downloadFileIfNeeded(const CLDaemonLocation &, const bool)
HRSE,downloadFileIfNeeded,needAvailability,%{public}d,needTile,%{public}d
HRSE,downloadFileIfNeeded,download availability file
HRSE,downloadFileIfNeeded,corrupted tile, increase download retry interval to %{public}.5lf seconds
HRSE,requestDownload,requesting HRSE tile download,lat,%{private}.7lf,lon,%{private}.7lf
HRSE,allowing download request over cell due to large horizontal uncertainty, uncertainty,%{public}.5lf, uncertainty threshold,%{public}.5lf
HRSE,downloadFileIfNeeded,tile download finished!
HrseAvlFileUpdatePeriodOverWifi
CFTimeInterval CLHighResolutionSignalEnvironmentDataManager::getAvlFileDownloadRateOverWifi() const
HRSE,HrseAvlFileUpdatePeriodOverWifi,%{public}.1lf
#Warning,HRSE,given avl update rate over WiFi is invalid,%{public}.1lf,using default value instead
HrseAvlFileUpdatePeriodOverCell
CFTimeInterval CLHighResolutionSignalEnvironmentDataManager::getAvlFileDownloadRateOverCell() const
HRSE,HrseAvlFileUpdatePeriodOverCell,%{public}.1lf
#Warning,HRSE,given avl update rate over Cell is invalid,%{public}.1lf,using default value instead
void CLHighResolutionSignalEnvironmentDataManager::downloadAvailabilityFile(const CFAbsoluteTime &)
HRSE, server, %{public}s, overridden, 1
HRSE, server, %{public}s, overridden, 0
HRSE,downloadAvailabilityFile,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf
#Warning,HRSE,downloadAvailabilityFile,could not setUpdateSource AVL file updater
#Warning,HRSE,downloadAvailabilityFile,could not setUpdateRate AVl file updater
void CLHighResolutionSignalEnvironmentDataManager::onManagerNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
CLHighResolutionSignalEnvironmentDataManager::onAvlFileUpdated
clhrseavl.avl.gz
CLHighResolutionSignalEnvironmentDataManager::onManagerNotification
TrafficCrowdsourceRules
CLTrafficCrowdsourceRules
HarvestController
CLHarvestControllerExternal
virtual void CLHarvestControllerExternal::fetchMostRecentConnectionWithReply(void (^)(CLVehicleConnection)) const
fVehicleConnectionNotifier is not initialized, skip fetching mostRecentConnection
HarvestingThermalLevelHighThreshold
HarvestingThermalLevelLowThreshold
IsHarvestAllLocations
MaxHarvestAge
MaxHarvestPointsPer
MaxHarvestPointsPerUpload
DefaultHarvestUploadInterval
void CLHarvestControllerExternal::onGnssNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
Sent unhandled notification 0x%04X (%d)
virtual void CLHarvestControllerExternal::onVisit(CLVisit *)_block_invoke
Received error when fetching LOI at location: %@
CLHarvestControllerExternal::onTelephonyNotification
CLHarvestControllerExternal::onStatusNotification
CLHarvestControllerExternal::onManagerNotification
CLHarvestControllerExternal::onDataProtectionNotification
CLHarvestControllerExternal::onLocationNotification
CLHarvestControllerExternal::onGnssNotification
CLHarvestControllerExternal::onMotionStateNotification
https://gsp10-ssl.apple.com/au
https://gsp10-ssl.apple.com/pds/pd
https://gsp10-ssl.apple.com/hcy/pbcwloc
https://gsp10-ssl.apple.com/incs
https://gsp10-ssl.apple.com/pbu
https://gsp10-ssl.ls.apple.com/hvr/aploc
https://gsp10-ssl.apple.com/psr
https://gsp10-ssl.apple.com/hvr/trc
https://gsp10-carry.ls.apple.com/hvr/alt
https://gsp10-ssl.apple.com/hvr/ion
CLAppleCollectionServer_App
CLAppleCollectionServer_Tracks
CLAppleCollectionServer_CellWifi
CLAppleCollectionServer_Indoor
CLAppleCollectionServer_Pass
CLAppleCollectionServer_Poi
CLAppleCollectionServer_Pressure
CLAppleCollectionServer_Trace
CLAppleCollectionServer_Altimeter
CLAppleCollectionServer_Ionosphere
float CLIndoorOutdoorWifiModel::computeProbability()
IndoorOutdoor,WifiModel,scanRange,%{public}f,distanceTraveled,%{public}f,numAps,%{public}zu,invalidResult,%{public}d,stationaryProbability,%{public}f,wifiRssiModelIndoorProbability,%{public}f
float CLIndoorOutdoorWifiModel::computePercentile(std::vector<int> &, float)
IndoorOutdoor, can't compute percentile on buffer of this size %{public}zu
CLWifi1SettingsWifiService
com.apple.locationd.workout.geofence
/System/Library/LocationBundles/AppleWatchWorkout.bundle
!_inWorkout
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Workout/Prediction/Algorithm/Stop/CLWorkoutGeoFenceController.m
-[CLWorkoutGeoFenceController dealloc]
-[CLWorkoutGeoFenceController startGeoFenceWithRadius:]
#gfc Starting geofence
#gfc Could not start geofence, check authorizations
-[CLWorkoutGeoFenceController stopGeoFence]
#gfc Stopping geofence
-[CLWorkoutGeoFenceController uninstallCurrentFence]
#gfc Installed region exists at stop workout, uninstalling
#gfc Generating temporary region to uninstall just in case
-[CLWorkoutGeoFenceController installFenceWithCenter:]
#gfc Installing fence with radius %f
-[CLWorkoutGeoFenceController cancelTimers]
#gfc Canceling all timers
-[CLWorkoutGeoFenceController onGeoFenceTimerFire]
#gfc Timed out fence monitoring
-[CLWorkoutGeoFenceController onLocationUpdateTimerFire]
#gfc Timed out location updates
-[CLWorkoutGeoFenceController locationManager:didUpdateLocations:]
#gfc Received new location, timestamp %@, time since now %f
#gfc Attempting to install fence
-[CLWorkoutGeoFenceController locationManager:didExitRegion:]
#gfc Exited fence
-[CLWorkoutGeoFenceController locationManager:didFailWithError:]
#gfc Generic failure with error %@
-[CLWorkoutGeoFenceController locationManager:monitoringDidFailForRegion:withError:]
#gfc Monitoring failed with error %@, stopping updates
-[CLWorkoutGeoFenceController locationManager:didStartMonitoringForRegion:]
#gfc Started monitoring
-[CLWorkoutGeoFenceController locationManager:didDetermineState:forRegion:]
#gfc Determined state %ld
-[CLWorkoutGeoFenceController locationManager:didChangeAuthorizationStatus:]
#gfc Received auth update %d
#gfc No longer authorized, stopping geofence
void scheduleTimer(dispatch_source_t *, const uint64_t, CLDispatchSilo *, void (^)(void))
#gfc Scheduling timer with timeout %llu
void cancelTimer(dispatch_source_t *)
#gfc Canceling timer
#gfc Timer existed, canceling now
KappaSubjectUUID
_registrationTimer
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Kappa/CLKappaServer.mm
-[CLKappaServer registerDevice]
KappaHost
https://ingest.apple-studies.com
KappaRegistrationEndpoint
KappaSubmissionEndpoint
KappaStudyID
219833ee-013d-42e5-ae9b-5bc7f73eadeb
KappaAuthorization
TxEKzAIWWLOTGOV2oLOAdJf8RaxBT1ddKkyAijmaknRfHwjqClNofa1ZsVmbA3Ah
28ed3541-9da1-411d-81ae-eb620f6b3a8d
P6SXysm9C4L74u1n1qgi2qXviCBN7mjHcg3HbZtoSrDts2efAUgpPjwfvurpXSWK
KappaCertificate
KappaConfigurationEndpoint
/ingest/v1/config
-[CLKappaServer setupConfigurationTimer]
setup configuration timer
ServerConfigurationTimerFireInterval
_configurationTimerFireInterval %d
configuration
-[CLKappaServer sendConfigurationRequest]_block_invoke
Request for configuration already in progress.
Created request for configuration.
v32@?0@"NSArray"8@"NSArray"16@"NSArray"24
-[CLKappaServer initWithUniverse:logFolder:delegate:]
init CLKappaServer instance
-[CLKappaServer _initializeValueForKey:withDefault:]
-[CLKappaServer reregister]
re-registering with the server
Requesting authorization from server
-[CLKappaServer reregister]_block_invoke
Error parsing authorization response: %@, error: %@
Server response has no subjectId
Server response has no token
registered device, subject UUID: %{private}@, subject Auth: %{private}@
Error requesting authorization from server
-[CLKappaServer _setupSession]
Creating a new server session
kappa
com.apple.locationd.CLKappaServer
Have a HC session; stopping registration timer
Invalid HC URL session
KappaSubjectAuth
-[CLKappaServer enable]
scheduling registration event
_urlSession
-[CLKappaServer upload:metaData:]
Missing or invalid 'type' in metadata
Uploading collection type %@, trigger %@
-[CLKappaServer _encryptData:metaData:]
Missing or invalid 'start' in metadata
Missing or invalid 'end' in metadata
Missing or invalid 'trigger' in metadata
%llu
Error starting HK message, error: %@
Error appending data to HK message, error: %@
Error finalizing HK message, error: %@
Failed to move HK message from %@ to %@, error: %@
-[CLKappaServer _createKeyValuePairsDict:metaData:]
Invalid metadata value type for key: %@, val: %@
-[CLKappaServer URLSession:dataTask:didReceiveData:]
Called back for %@ with task: %@ and data of length: %lu and id: %@
-[CLKappaServer URLSession:task:didCompleteWithError:]
Called back for %@ with task state %ld: %@ and error: %@ and id: %@
HTTP Response, statusCode: %{public}d, filePath: %@, response: header %@, body %@
called back with request type upload
Removed file after upload attempt, filePath: %@
called back with request type configuration
-[CLKappaServer URLSession:downloadTask:didFinishDownloadingToURL:]
Download task completed with task: %@ and task id: %lu and location: %@
Error in download task:%@, statusCode: %ld, error: %@
responseDictionary = %@
Unable to parse response for configuration request, error: %@
Received callback for unexpected download task: %{public}@
-[CLKappaServer URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:]
-[CLKappaServer URLSession:didReceiveChallenge:completionHandler:]
Got called back for %@
void parseTaskDescription(NSString *, NSString **, NSURL **)
CLKappaServer.mm
requestType
requestURL
requestType %@ requestURL %@
%@::%@
CLCell::CLCell(const CLTelephonyService_Type::Cell &, CLTelephonyService_Type::RadioAccessTechnology)
bad RAT for GSM: %{public}s
CLCell::CLCell(const CLTelephonyService_Type::ScdmaCell &, CLTelephonyService_Type::RadioAccessTechnology)
bad RAT for SCDMA: %{public}s
CLCell::CLCell(const CLTelephonyService_Type::CdmaCell &, CLTelephonyService_Type::RadioAccessTechnology)
bad RAT for CDMA: %{public}s
CLCell::CLCell(const CLTelephonyService_Type::LteCell &, CLTelephonyService_Type::RadioAccessTechnology)
bad RAT for LTE: %{public}s
CLCell::CLCell(const CLTelephonyService_Type::NrCell &, CLTelephonyService_Type::RadioAccessTechnology)
bad RAT for NR: %{public}s
Cell, RAT, 
, valid , 
, cellType , 
, Unknow / Invalid Cell
void CLCell::overrideUarfcnPsc(int, int, int, int)
CELL_LOC: override to, %s
bad-key
unsigned long long CLCell::getSecKey() const
CELL_LOC: which cell is that, %s
CELL_LOC: sec_key, 0x%016llX
com.apple.CLFitnessTrackingAWD
void CLFitnessTrackingAWD::describe()
AWD: workout:%d, companion:%d, %s, GPS:%u, HR:%u, Onset:%d, HRUtil:%u, VO2Avail:%d, HRSrc:%d, VO2Cons:%u, PALStat:%d, VO2Stat:%d, loadUtil:%u, strideAvail:%u, walkAvail:%d, runAvail:%d, walkStat:%d, runStat:%d, VO2Grade:%d, idsAvail:%d, defaultUtil:%d, WRHR:%d, PedGPSAvailable:%d, DistTrackUsed:%d, DistTrackInvalidGradient:%d, DistTrackInvalidGain:%d, DistTrackInvalidSpeed:%d, DistTrackInvalidLength:%d, SeshDuration:%d, PedCalibrated:%d, PaceFail:%d, PedMetSourceDiff:%f, PedMetSourceDiff:%f, HrBoundsFail:%d, SeshUp:%d, SeshDown:%d, SeshCaloriesFromGrade:%d, SeshGPSSourcePhone:%d, SeshGPSSourceWatch:%d, ElevationError:%lld, HRSamplesValidMin: %d, HRSamplesValidMax: %d, METSamplesWithRecentHR: %d, METSamplesValidDelta: %d, VO2DeltaPercentage: %d, HRMetPairs: %d
WorkoutElevationFusion,WorkoutType,%d,BaroGood,%d,BaroUnkDEMAgree,%d,DEMBaroUnk,%d,BaroUnkDEMDisagree,%d,BaroUnkNoDEM,%d,DEMBaroBad,%d,None,%d,GPSBaroGood,%d,GPSBaroUnk,%d,GPSBaroBad,%d,GPSUnvailBaroGood,%d,GPSUnvailBaroUnk,%d,GPSUnvailBaroBad,%d
Swimmming: Free:%d, Breast:%d, Butter:%d, Back:%d, Other:%d, Swimming:%d
Auto-pause: Enabled:%d, WillResume:%d, WillPause:%d, ResumeFalse:%d
WorkoutSessionStatistics,isStopAlertEnabled,%d,isStartAlertEnabled,%d,activtyTypeWhenStopDisabled,%d,activityTypeWhenStartDisabled,%d,coarseLocationLat,%lld,coarseLocationLong,%lld,timeSinceLastDetectedStopToWorkoutEnd,%f,numAlertsDetectedStops,%d,numStopAlertRetractions,%d,indoorOutdoorState,%d
NOT 
void CLFitnessTrackingAWD::submitSessionStats()
%sSubmitted session stats; session length, %f
void CLFitnessTrackingAWD::queryHKForWorkoutType()_block_invoke
#Warning HealthKit query error,%ld
#Warning HealthKit Inaccessible error,%ld
B24@?0@"HKWorkout"8@"NSDictionary"16
Setting otherWorkoutLabel: %d
EnableAutoPause
com.apple.nanolifestyle.sessiontrackerapp
EnableWheelchairAWDCollection
operator[]
iterator_range_core.hpp
at >= 0
static_cast<typename base_type::size_type>(at) < size()
CLSedentaryAlarmRecorderDb
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/SedentaryTimer/CLSedentaryAlarmRecorderDb.mm
SedentaryAlarmHistory
SELECT COUNT(*) FROM SedentaryAlarmHistory
SELECT * FROM SedentaryAlarmHistory ORDER BY startTime ASC
DELETE FROM SedentaryAlarmHistory WHERE startTime < ?
DELETE FROM SedentaryAlarmHistory WHERE startTime > ?
DELETE FROM SedentaryAlarmHistory
INSERT INTO SedentaryAlarmHistory (startTime, firedTime, alarmType, didWake) VALUES (?, ?, ?, ?)
SELECT * FROM SedentaryAlarmHistory ORDER BY startTime DESC LIMIT 1
SELECT * FROM SedentaryAlarmHistory WHERE startTime >= ? and startTime < ? ORDER BY startTime ASC
virtual void CLSedentaryAlarmRecorderDb::deleteRecordsAfterInsertUL(const CLSedentaryAlarmData &)
SedentaryAlarm, Failed to delete records
virtual void CLSedentaryAlarmRecorderDb::shiftRecordsByUL(CFTimeInterval)
#Warning SedentaryAlarm, Time rolled back, deleting records in the future
SedentaryAlarm, Failed to shift records
virtual void CLSedentaryAlarmRecorderDb::insertRecordUL(const CLSedentaryAlarmData &, bool)
SedentaryAlarm, Failed to insert record
virtual void CLSedentaryAlarmRecorderDb::sanitizeAndStoreRecordUL(const CLSedentaryAlarmData &, bool)
SedentaryAlarm, Failed to insert record due to failure from reading the most recent entry.
alarmType
CLActivityRecorderDb<CLSedentaryAlarmData>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSedentaryAlarmData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLSedentaryAlarmData>::setDatabaseAccessible() [T = CLSedentaryAlarmData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLSedentaryAlarmData>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLSedentaryAlarmData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
SpringTracking/kCLConnectionMessageSpringTrackerIsTracking
SpringTracking/kCLConnectionMessageSpringTrackerQuery
virtual void CLDaemonSpringTrackingClient::handleMessage(std::shared_ptr<CLConnectionMessage>)
Got unhandled mesage of type %{public}s
CLDaemonClient.SpringTrackingNotifierIsTracking
CLDaemonClient.SpringTrackingNotifierStart
void CLDaemonSpringTrackingClient::handleMessageSpringTrackerStart(std::shared_ptr<CLConnectionMessage>)
Tracking START, %s, %d, %p, %d
CLDaemonClient.SpringTrackingNotifierStop
void CLDaemonSpringTrackingClient::handleMessageSpringTrackerStop(std::shared_ptr<CLConnectionMessage>)
Tracking STOP, %s, %d, %p, %d
void CLDaemonSpringTrackingClient::handleMessageSpringTrackerQuery(std::shared_ptr<CLConnectionMessage>)
Error in query request.
CLDaemonClient.SpringTrackingNotifierQuery
void CLDaemonSpringTrackingClient::handleMessageSpringTrackerQuery(std::shared_ptr<CLConnectionMessage>)_block_invoke
%@, %s, %d, %p
virtual void CLSensorFusionService3AxisDynamicGyro::start()
%{public}s is enabling power conservative device motion for parallax.
virtual void CLSensorFusionService3AxisDynamicGyro::stop()
%{public}s is disabling power conservation for parallax.
virtual void CLSensorFusionService3AxisDynamicGyro::feedAccelerometerData(const CLAccelerometer::Sample *)_block_invoke
Device is stationary and Timeout exceeded, turning off device motion gyro heartbeat and bias estimator.
MaxTripDuration
CLPolicyTrip::CLPolicyTrip(std::shared_ptr<CLPolicyTripInterface::External>, std::shared_ptr<CLHarvestSystemInterface::Controller>, std::shared_ptr<CLHarvestMonitorInterface::Gps>, std::shared_ptr<CLHarvestPolicyInterface::Proactive>)
CLPolicyTrip: duration,%.2fs
void CLPolicyTrip::createNewTripId()
using trip id %s (previous trip duration %.3fs and gap %.3fs)
void CLWorkoutStopDetector::updateChargingState(const CLWorkoutPredictorCharging &)
WorkoutStopDetected,charging,type,%ld
void CLWorkoutStopDetector::didExitGeoFence()
WorkoutStopDetected,geoFence,type,%ld
bool CLWorkoutStopDetector::isConfirmedOffWrist() const
Triggering WorkoutStopDetected, currentTime %f, fLastUnknownOrOffTime %f
void CLWorkoutStopDetector::updateVehicularState(const CLWorkoutPredictorVehicular &)
WorkoutStopDetected,connectedVehicle,type,%ld
void CLWorkoutStopDetector::update()
WorkoutStopDetected,wrist,type,%ld
WorkoutStopDetected,vehicleSpeedConstrainedArm,type,%ld,constrainedState,%d
Failed to get constrainedArm state
WorkoutStopDetected,type,%ld,stopReason,%d,stopTimestamp,%f
static double CLWorkoutStopDetector::getGeoFenceRadiusForGenericWorkout(unsigned long)
CLWorkoutStopDetector,invalid generic workout label received,%lu
void CLWorkoutStopDetector::selectModel(CMWorkoutType, CMWorkoutLocationType, CLWorkoutStopModel::StartType)
CLWorkoutStopDetector::selectModel,type,%{public}ld,location,%{public}ld,startType,%{public}ld
CLWorkoutStopDetector,workout type did not change,not updating models,currentTypeWithLocation,%{public}ld,newTypeWithLocation,%{public}ld
CLWorkoutStopDetector::selectModel,workoutType,%ld,locationType,%ld,typeWithLocation,%ld
CLHLocationClassifier
completionHandler
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Harvester/Collection/CLHLocationClassifier.m
-[CLHLocationClassifier setupWithCompletionHandler:]
Harvester
loiType
loiTypeSource
uncertainty
!fWristStateHistory.empty()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Fall/CLFallWristState.mm
updateChargerAndWristState
!fLockStateHistory.empty()
updateLockState
virtual void CLNatalieInputBuffer<CLCatherineData>::add(const CLCatherineData &) [Data_T = CLCatherineData]
Input, HR = %.8f, timestamp = %.8lf, starttime = %.8lf, source = %d, interpolation = %d, srcName = %s
virtual void CLNatalieInputBuffer<CLOdometerEntry>::add(const CLOdometerEntry &) [Data_T = CLOdometerEntry]
Input, Odometer, time stamp, %.8lf, distance, %.8f, GPS altitude, %.8lf, estimated speed(m/s), %.8lf, odometer, %.8lf, accuracy, %.8lf, speed accuracy, %.8lf, timestampGps, %.8lf, rawSpeed, %.8f, srcName, %s
virtual bool CLNatalieInput<CLElevationChangeEntry>::isReady(CFAbsoluteTime)
Input, Elevation, ready at time, %.2f, no data point
Input, Elevation, not ready at time, %.2f 
Input, Elevation, ready at time, %.2f, nearest data point at time, %.2f
void _CLFitnessMachineData::log() const
Fitness Machine datum,startTime,%.3f,elapsedTime,%.3f,calories,%f,distance,%f,elevationAscended,%f,strideCount,%ld,strokeCount,%ld,floors,%ld,speed,%f,cadence,%f,power,%f,incline,%f,resistance,%f,verticalSpeed,%f
virtual CLMetsInfo CLCalorieDownhillSkiModel::computeMETS(const CLNatalieModelInput &)
Calorie Model, Skiing Compendium METS, METS, %f
CLWifiAccessPointLocationService
WifiTileHeader
WifiLocationSizeLimit
void CLWifiAccessPointLocationService::processDefaultsWrites()
tiles defaults applied, maxTileAccessAge, %.0f, maxTileCount, %du
std::vector<std::optional<std::tuple<CLTilesManager_Type::AccessPointEntry, WifiTileXY>>> CLWifiAccessPointLocationService::_searchTilesForMacs(const std::vector<TileId> &, const std::vector<CLMacAddress> &) const
#tilesearch, num tiles, %{public}d
intermediate_results.find(mac) != intermediate_results.end()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Wifi1/CLWifiAccessPointLocationService.mm
_searchTilesForMacs
expecting equal length, input, %{public}lu, output, %{public}lu
virtual std::map<CLMacAddress, CLWifiAPLocation> CLWifiAccessPointLocationService::findLocationsOfMacAddresses(const std::vector<CLMacAddress> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point) const
@TileSearch, wifi, use ALS results for location hint
findLocationsOfMacAddresses
tile header missing from returned mac, x, %{private}d, y, %{private}d
@TileSearch, wifi, results, searched, %{public}d, in_tiles, %{public}d, ALS, %{public}d
virtual std::vector<std::optional<std::tuple<CLTilesManager_Type::AccessPointEntry, WifiTileXY>>> CLWifiAccessPointLocationService::findCentroidsInTiles(const std::vector<CLMacAddress> &, const CLDaemonLocation &, uint32_t, cl::chrono::CFAbsoluteTimeClock::time_point) const
No Mac addresses found in neighbor list, will search remaining tiles
saveAlsAccessPoints
uint32_t CLWifiAccessPointLocationService::saveAlsAccessPoints(const std::vector<CLAlsWifiAccessPoint> &, const std::vector<int> &, CLNetworkLocationRequest_Type::CLAlsWifiBand, cl::chrono::CFAbsoluteTimeClock::time_point)
@WifiChannel, surroundingWifiBand, %d, # of aps on band, %lu
@WifiAps, dbadd, %{public}lu, was, %{public}u, now, %{public}u, aps, %{public}lu
sqlite error, %{private}s
upgrade-wifi-tiles-schema
NewTile
std::optional<CLWifiTileHeaderEntry> CLWifiAccessPointLocationService::saveWifiTileAccessPointEntries(const std::string &, cl::chrono::CFAbsoluteTimeClock::time_point)
no sqlite connection, %{private}s
memory mapped error, %{private}s
tileId.tileType == CLTilesManager_Type::TileType::WIFI_Location
updateAccessTimestampsIfNecessary
std::vector<std::pair<TileId, bool>> CLWifiAccessPointLocationService::updateAccessTimestampsIfNecessary(const std::set<TileId> &, cl::chrono::CFAbsoluteTimeClock::time_point, cl::chrono::seconds) const
attempted to update timestamp for tile that does not exist, x, %{private}d, y, %{private}d
updateGizmoSyncTimestampForTile
int CLWifiAccessPointLocationService::numberOfInputApsUsedInWifiTileForCoordinate(const CLClientLocationCoordinate &) const
#warning, tile does not exists to query num inputs, x, %{private}d, y, %{private}d
void CLWifiAccessPointLocationService::establishWifiTileDatabaseConnectionsIfNecessary()
failed to establish a valid database connection, expect wifi positioning accuracy to be significantly degraded
fWifiTileDataRepository->isConnected()
dropTilesIfWifiTilesHeaderSchemaChanged
void CLWifiAccessPointLocationService::dropTilesIfWifiTilesHeaderSchemaChanged()
unconditionally removing all #tile tables in favor of new schema
Detected that we had legacy tile tables. Unconditionally dropping all tile headers as well
std::tuple<int, int> CLWifiAccessPointLocationService::errorOnRemainingAndDelete()
remaining entries in als db, deleting, %{private}d
void CLWifiTileQueryLogic::resetScanMisses(const char *)
@TileSearch, wifi, missreset, %{public}s
void CLWifiTileQueryLogic::incrementScanMisses()
@TileSearch, wifi, misscount, %{public}d
Rollover
std::tuple<std::vector<TileId>, std::vector<TileId>, std::vector<TileId>> CLWifiTileQueryLogic::getTilesToSearch(const std::vector<CLWifiTileHeaderEntry> &, const CLDaemonLocation &, cl::chrono::CFAbsoluteTimeClock::time_point)
invalid location provided and complete miss, will not return any tiles to search
@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, 0, completemiss, %{public}d
@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, %{public}d, completemiss, %{public}d
CLWifiTileDataRepository
CLNatalimetryRecorderDb
DELETE FROM NatalieHistory WHERE startTime < ?
virtual long CLNatalimetryRecorderDb::aggregateRecords(const CLAggregationRules &)
DB, Error expiring records.
SELECT * FROM NatalieHistory ORDER BY startTime ASC
CMError CLNatalimetryRecorderDb::queryNatalieDataSince(CLNatalieData &, std::vector<CLNatalieData> &) const
DB, CalorimetryHistory not accessible
DB, UUID un-initialized
SELECT * FROM NatalieHistory WHERE id >= ? ORDER BY id DESC LIMIT ?
Attempting to request data older than 24 hours with queryNatalieDataSince, start, %f
DB, Potential DB reset, returning all records to clients
DB, CalorimetryHistory has rolled back, returning mru to clients,mru.recordId,%d,record.recordId,%d,mru.natalies,%lld,record.natalies,%lld
Calorie history has rolled back!!
CMError CLNatalimetryRecorderDb::queryNatalieData(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLNatalieData> &) const
DB, not accessible
SELECT * FROM NatalieHistory WHERE startTime >= ? and startTime < ? ORDER BY startTime ASC
Attempting to request data older than 24 hours with queryNatalieData, start, %f, end, %f
CMError CLNatalimetryRecorderDb::getWorkoutMets(unsigned char *, CLWorkoutMets &) const
SELECT * from NatalieHistory WHERE sessionUUID = ? ORDER BY startTime ASC
SELECT COUNT(*) FROM NatalieHistory
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Calorimetry/CLNatalimetryRecorderDb.mm
NatalieHistory
INSERT INTO NatalieHistory (startTime, activityType, isStanding, mets, natalies, basalNatalies, overrideSet, truthMets, sessionUUID) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
SELECT * FROM NatalieHistory ORDER BY startTime DESC LIMIT 1
SELECT * FROM NatalieHistory ORDER BY startTime ASC LIMIT 1
virtual void CLNatalimetryRecorderDb::prepareSQLStatements()
DB, Device is locked and we are unable to open the database
void CLNatalimetryRecorderDb::alterTableIfNecessary()
DB, doesn't exist yet.
ALTER TABLE NatalieHistory
UPDATE NatalieHistory SET 
DELETE FROM NatalieHistory
DELETE FROM NatalieHistory WHERE startTime > ?
virtual void CLNatalimetryRecorderDb::deleteRecordsAfterInsertUL(const CLNatalieData &)
DB, Failed to delete records
UPDATE NatalieHistory SET startTime = startTime + ?
virtual void CLNatalimetryRecorderDb::shiftRecordsByUL(CFTimeInterval)
DB, Failed to shift records
void CLNatalimetryRecorderDb::insertNataliesForGap(const CFAbsoluteTime, const CFAbsoluteTime)
DB, Inserting basal calories %f for gap (%lf - %lf, %lfs)
overrideSet
sessionUUID
CLActivityRecorderDb<CLNatalieData>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLNatalieData>::setDatabaseAccessible() [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLNatalieData>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLNatalieData>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLExerciseMinuteSubscription::onNatalimetryUpdate(int, const CLNatalimetryNotifier_Type::Notification &, const CLNatalimetryNotifier_Type::NotificationData &)
ExerciseMinute, error in update
void CLExerciseMinuteSubscription::handleRequestExerciseMinuteUpdate(bool, const CLNameValuePair &)
ExerciseMinute, Subscription changed, %s, %p, %d
void CLExerciseMinuteSubscription::handleMessageExerciseMinuteQuery(std::shared_ptr<CLConnectionMessage>)
ExerciseMinute, Error in query request.
CLDaemonClient.ExerciseMinuteQuery
ExerciseMinute, Error query response, %{public}d, %s, %p
bool CLExerciseMinuteSubscription::isEntitledForNatalimetry()
CLExerciseMinuteSubscription::onNatalimetryUpdate
newPreFiltered
cached
cachedPreFiltered
EED2
NumActions
UnknownAction
static void CLEmergencyActor::logMultiLineString(const std::string &, const std::string &)
%{public}s : %{private}s
#Warning #Actor limiting multi-line string to %{public}d lines
#Actor splitting string (length %{public}d) into %{public}d parts
%{public}s %{public}d of %{public}d : %{private}s
static NSString *CLEmergencyActor::getTruncatedString(NSString *, uint32_t)
#Actor truncated string max length is too small, not enforcing
#Warning #Actor truncated string to %{public}d characters
bool CLEmergencyActor::shouldDisplayEEDUI()
#Actor EED UI should %{public}s
void CLEmergencyActor::handleEmergencyStateChange(CLEmergencyState)
#Actor,handleEmergencyStateChange,pointer was null for %{public}s
void CLEmergencyActor::handleLocationServicesStatusChange(const bool)
#Actor LS unexpectedly turned off during an emergency, still clearing cached location
#Actor clearing cached location due to LS off
void CLEmergencyActor::setupLocationClient()
#Actor registering as client of Location Controller
#Actor already registered as client of Location Controller
#Actor registering as client of WiFi location
#Actor already registered as client of WiFi location
#Actor registering as client of Cell location
#Actor already registered as client of Cell location
void CLEmergencyActor::checkLocationRegistration()
#Actor,checkLocationRegistration,pointer was null for %{public}s
void CLEmergencyActor::registerForLocation()
#Actor registering for location notifications
#Actor registering for WiFi location notification
#Actor registering - WiFi client NULL
#Actor registering for Cell location notification
#Actor registering - Cell client NULL
#Actor attempted to register for location notification without a client
void CLEmergencyActor::unregisterForLocation()
#Actor unregistering for location notifications
#Actor unregistering for WiFi location notifications
#Actor unregistering - WiFi client NULL
#Actor unregistering for Cell location notifications
#Actor unregistering - Cell client NULL
void CLEmergencyActor::modifyNilrHandlingFlags()
#Actor sending lockout NILR
#Actor sending disable NILR lockout
void CLEmergencyActor::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#Warning #Actor received unexpected notification %{public}d
#Actor received new fix
void CLEmergencyActor::updateCachedLocation(const std::string &, const std::string &, const GNSS::DaemonLocation &, GNSS::DaemonLocation &, const CLLocationProvider_Type::Notification &)
#Actor rejected %s location fix as altitude is not usable,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,alt,%{private}.7f,vacc,%{public}.2f,speed,%{private}.1f,course,%{private}.1f,type,%{public}d
#Actor rejected %s location fix as unusable,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,speed,%{private}.1f,course,%{private}.1f,type,%{public}d
#Actor cached %s fix,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,alt,%{private}.7f,vacc,%{public}.2f,speed,%{private}.1f,course,%{private}.1f,type,%{public}d
#Actor,updateCachedLocation,pointer was null for %{public}s
static bool CLEmergencyActor::isLocationUsable(const std::string &, const GNSS::DaemonLocation &)
#Actor %s fix is unusable due to invalid lat,%{private}.7f,lon,%{private}.7f
#Actor %s fix is unusable due to age,%{public}.3f
#Actor %s fix is unusable due to horizontal accuracy,%{public}.2f
#Actor %s fix is unusable due to low integrity,%{public}d
#Actor %s fix is usable
bool CLEmergencyActor::isAltitudeUsable(const std::string &, const GNSS::DaemonLocation &)
#Actor %s received altitude accuracy is not valid,%{public}.2f
#Actor %s received altitude is not valid,%{public}.2f
#Actor %s altitude undulation model is not valid
#Actor %s altitude is unusable due to age,%{public}.3f
#Actor %s altitude is unusable due to low integrity,%{public}d
bool CLEmergencyActor::isCachedLocationBetter(const GNSS::DaemonLocation &)
#Actor new fix is preferred over cached by default
void CLEmergencyActor::onWifiLocationProviderNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#Actor, WiFi location notification received lat,%{private}.7f,lon,%{private}.7f,hacc,%{private}.7f,conf,%{private}d
void CLEmergencyActor::onCellLocationProviderNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#Actor, Cell location notification received lat,%{private}.7f,lon,%{private}.7f,hacc,%{private}.7f
ActorSessionForNonActiveEmergencies
CLEmergencyAction::CLEmergencyAction(id<CLIntersiloUniverse>, CLEmergencyAction::Action, id<CLClientManagerPublicProtocol>, CLEmergencyAction::NetworkAndSimInfoCallback, std::shared_ptr<CLEmergencyAWD>, CLEmergencyAction::LocationCallback)
#Warning #%{public}s allowing session for non-active emergencies
virtual void CLEmergencyAction::handleCompanionNumberChange(const std::string &)
#%{public}s companion phone number changed to %{private}s
void CLEmergencyAction::assertSession(bool)
#%{public}s session assertion is already %{public}s,ignoring
#%{public}s session assertion %{public}s
CLEmergencyActor::onLocationNotification
CLEmergencyActor::onWifiLocationProviderNotification
CLEmergencyActor::onCellLocationProviderNotification
auto CLEmergencyActor::CLEmergencyActor(id<CLIntersiloUniverse>, CLEmergencyController::SendNilrLockoutCallback)::(anonymous class)::operator()() const
#Actor,LocationCallback,returning cached fix
#Warning #Actor,LocationCallback,cached fix is not usable
#Actor,LocationCallback,returning cached prefiltered fix
#Warning #Actor,LocationCallback,cached prefiltered fix is not usable
TrackingAvoidance
CLLocationMulticlientStreamerSilo
#Multiclient Active location client on remote device
v32@?0@"NSDictionary"8@"NSDictionary"16@?<v@?@"NSDictionary"@"NSDictionary"@"NSError">24
void CLWorkoutSecondaryClassifiers::onCyclingDetectorActivate()
Bringing up cycling state detector
void CLWorkoutSecondaryClassifiers::onCyclingDetectorDeactivate()
Tear down cycling state detector
WifiTilesManager
CLWifiTilesManagerExternal::CLWifiTilesManagerExternal(CLWifiTilesManager *, id<CLIntersiloUniverse>)
CLWifiTilesManager::onClientNotification
CLWifiTilesManager::onDataProtectionNotification
CLWifiTilesManager::onStatusNotification
CLWifiTilesManager::onLocationNotification
CLWifiTilesManager::onCompanionNotification
kPrediction
kIndoor
kOutdoor
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLNotifierClientAdapter.mm
-[CLNotifierClientAdapter init]
_client
-[CLNotifierClientAdapter onNotification:withData:]
CLNotifierClientBase: %p
CLMobility::SteadinessAdjustment_Generated::Features CLMobility::SteadinessAdjustment::extractFeatures(CFAbsoluteTime, const std::vector<HealthKitQuantitySample> &, const std::vector<HealthKitQuantitySample> &, const SteadinessModelContinuousWalking_Generated::Features &)
CLMobility::SteadinessAdjustment::Features,allBoutsBoutDurationSecCv,%{private}.2f,dailySteps30daysMean,%{private}.2f,dailyFlights30daysMean,%{private}.2f
const T &CMQueue<float>::operator[](const size_t) const [T = float]
CLAvengerZoneMonitor-Mutex
MobilityBoutMetricsHistory
virtual void CLMobility::BoutMetricsRecorderDb::addBoutMetrics(const CLMobility::BoutMetrics &)
Wrote boutMetrics to db: startTime=%{public}.2f
getTableName() != ""
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/FunctionalCapacity/Mobility/Delegates/CLMobilityBoutMetricsRecorderDb.mm
getBoutMetricsInTimeRange
SELECT * FROM 
 WHERE startTime > ? and startTime <= ? and boundaryType == ? ORDER BY rowid ASC
SELECT * FROM MobilityBoutMetricsHistory WHERE startTime >= ? ORDER BY startTime ASC
INSERT INTO MobilityBoutMetricsHistory ( 
startTime, endTime, stepCount, workoutType, terminationReason, numGaitMetrics, invalidGradePercentage, deviceSide, 
walkingSpeed, doubleSupportPercentage, stepLength, asymmetryPercentage, 
segmentsRejectedByIsSwingStanceCycle, segmentsRejectedByIsNotRunning, segmentsRejectedByIsFeasibleWalkingSpeed, segmentsRejectedByIsPendular, segmentsRejectedByIsSufficientVerticalTwist, segmentsRejectedByIsCadenceConcordant, 
walkingSpeedRejectionStatus, doubleSupportPercentageRejectionStatus, stepLengthRejectionStatus, asymmetryPercentageRejectionStatus, userHeight, isHeightSet, userWeight, isWeightSet, 
boundaryType, cycleTimeMean, stepLengthEntropy, stepLengthPoincareSD1, stepLengthPoincareSD2, cycleTimeEntropy, cycleTimePoincareSD1, cycleTimePoincareSD2  
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
UPDATE MobilityBoutMetricsHistory SET 
startTime = ?, endTime = ?, stepCount = ?, workoutType = ?, terminationReason = ?, numGaitMetrics = ?, invalidGradePercentage = ?, deviceSide = ?, 
walkingSpeed = ?, doubleSupportPercentage = ?, stepLength = ?, asymmetryPercentage = ?, 
segmentsRejectedByIsSwingStanceCycle = ?, segmentsRejectedByIsNotRunning = ?, segmentsRejectedByIsFeasibleWalkingSpeed = ?, segmentsRejectedByIsPendular = ?, segmentsRejectedByIsSufficientVerticalTwist = ?, segmentsRejectedByIsCadenceConcordant = ?, 
walkingSpeedRejectionStatus = ?, doubleSupportPercentageRejectionStatus = ?, stepLengthRejectionStatus = ?, asymmetryPercentageRejectionStatus = ?, userHeight = ?, isHeightSet = ?, userWeight = ?, isWeightSet = ?, boundaryType = ?, cycleTimeMean = ?, stepLengthEntropy = ?, stepLengthPoincareSD1 = ?, stepLengthPoincareSD2 = ?, cycleTimeEntropy = ?, cycleTimePoincareSD1 = ?, cycleTimePoincareSD2 = ? 
WHERE rowid = ?
ALTER TABLE MobilityBoutMetricsHistory ADD COLUMN 
UPDATE MobilityBoutMetricsHistory SET 
 = 0;
SELECT * FROM MobilityBoutMetricsHistory ORDER BY startTime ASC LIMIT 1
stepCount
terminationReason
numGaitMetrics
invalidGradePercentage
deviceSide
walkingSpeed
doubleSupportPercentage
stepLength
asymmetryPercentage
segmentsRejectedByIsSwingStanceCycle
segmentsRejectedByIsNotRunning
segmentsRejectedByIsFeasibleWalkingSpeed
segmentsRejectedByIsPendular
segmentsRejectedByIsSufficientVerticalTwist
segmentsRejectedByIsCadenceConcordant
walkingSpeedRejectionStatus
doubleSupportPercentageRejectionStatus
stepLengthRejectionStatus
asymmetryPercentageRejectionStatus
userHeight
isHeightSet
userWeight
isWeightSet
ActivityInMemoryBufferSize
CLActivityRecorderDb<CLMobility::BoutMetrics>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
Buffer size: %d
:memory:
%s.InMemoryTransaction
bool CLActivityRecorderDb<CLMobility::BoutMetrics>::setDatabaseAccessible() [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
In memory buffer should have been empty! Instead it had a size of %{public}lu.
bool CLActivityRecorderDb<CLMobility::BoutMetrics>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
#Notice %{public}s needs autoincrement migration
AutoIncr
Index
DROP TABLE IF EXISTS 
CREATE TABLE 
INSERT INTO 
) SELECT 
 FROM 
DROP TABLE 
ALTER TABLE 
 RENAME TO 
CREATE INDEX 
 ON 
#Notice %{public}s autoincrement migration succeeded
%{public}s autoincrement migration failed
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Activity/CLActivityRecorderDb.h
aggregateRecords
DELETE FROM 
 WHERE startTime < ?
getAllRecords
SELECT * from 
 ORDER BY id ASC
getEntriesByTimeRange
 WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC
CLActivityRecorderDb::sanitizeAndStoreRecordUL
virtual void CLActivityRecorderDb<CLMobility::BoutMetrics>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLMobility::BoutMetrics, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf
Potential CM database inconsistency, time jump
Entry being recorded has a startTime in the recent past.  Deleting records after %f.
Entry being recorded has a startTime in the substantial past.  Shift records by %f.
Failed to insert record due to failure from reading the most recent entry.
deleteAllRecordsUL
deleteRecordsAfterInsertUL
 WHERE startTime > ?
shiftRecordsByUL
UPDATE 
 SET startTime = startTime + ?
getMostRecentRecordUL
 ORDER BY ROWID DESC LIMIT 1
getNumberOfRecords
SELECT COUNT(*) FROM 
MaxMetsHistory
SELECT * from MaxMetsHistory ORDER BY startTime ASC
SELECT COUNT(*) FROM MaxMetsHistory
CMError CLMaxMetsRecorderDb::queryInTimeRange(const CFAbsoluteTime, const CFAbsoluteTime, std::vector<MaxMets> &) const
MaxMetsHistory, DB not accessible
SELECT * FROM MaxMetsHistory WHERE endTime > ? and startTime <= ? ORDER BY startTime ASC
DELETE FROM MaxMetsHistory WHERE endTime < ?
DELETE FROM MaxMetsHistory
DELETE FROM MaxMetsHistory WHERE startTime > ?
UPDATE MaxMetsHistory SET startTime = startTime + ?, endTime = endTime + ?
INSERT INTO MaxMetsHistory (startTime, endTime, maxMets) VALUES (?, ?, ?)
SELECT * FROM MaxMetsHistory ORDER BY id DESC LIMIT 1
ALTER TABLE MaxMetsHistory ADD COLUMN 
UPDATE MaxMetsHistory SET 
maxMets
CLActivityRecorderDb<MaxMets>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = MaxMets, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<MaxMets>::setDatabaseAccessible() [T = MaxMets, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<MaxMets>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = MaxMets, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<MaxMets>::sanitizeAndStoreRecordUL(const T &, bool) [T = MaxMets, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual bool CLTileSyncManagerExternal::isPairingActive() const
@GtsMgr, nrIsPairingActive, %{public}d
58F7E0B5-513C-49C6-BE68-EACC9107342D
virtual bool CLTileSyncManagerExternal::canWatchDownloadTiles() const
GtsMgr, canDownload, %d
virtual CFTimeInterval CLTileSyncManagerExternal::getWatchInactiveTime() const
@GtsSync, inactive nil
NRDevicePropertyLastInactiveDate
nullptr == _notifier
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Utilities/CLNotifierServiceAdapter.mm
-[CLNotifierServiceAdapter setAdaptedNotifier:]
[self valid]
_notifier
-[CLNotifierServiceAdapter notifierClientNumForCoparty:]
ClientIntegerMap: (
%p = %d
SemiStatVMThreshold
virtual CLMetsInfo CLNatalieSemiStatModel::computeMETS(const CLNatalieModelInput &)
Semistationary, Standing, %d, metsFromIntensity, %.1f, userMetsFromSteps, %.1f, metsFromPosture, %.1f, userMetsFinal, %.1f, computeTime, %.1f, truthMetsFinal, %.1f, truthMetsFromSteps, %.1f, activityType, %d, floor, %f
CLNataliePedestrianModelInterface::CLNataliePedestrianModelInterface()
Pedestrian, metsHrUpperBound, %.1f 
virtual CLMetsInfo CLNataliePedestrianModelInterface::computeMETS(const CLNatalieModelInput &)
Pedestrian, wrMets, %f,  fmMets, %f, hrMets, %f, hrwrDiff, %f, useHrMets, %d, userMets, %f, truthMets, %f
void kf_work(kiss_fft_cpx *, const CMQueue<scalar_32> &, int, const size_t, int, int *, const kiss_fft_cfg)
Error in FFT,p,%d
CLWorkloadCalibratorRecorderDb
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/WorkloadCalibration/CLWorkloadCalibratorRecorderDb.mm
void CLWorkloadCalibratorRecorderDb::deleteRecordsBefore(CFTimeInterval)
WorkloadCalibratorHistory
SELECT COUNT(*) FROM WorkloadCalibratorHistory WHERE activityType == ?
SELECT * FROM WorkloadCalibratorHistory ORDER BY startTime ASC
SELECT * FROM WorkloadCalibratorHistory WHERE activityType == ? AND standardDeviation <= ? ORDER BY startTime ASC
DELETE FROM WorkloadCalibratorHistory WHERE startTime < ?
DELETE FROM WorkloadCalibratorHistory WHERE startTime > ?
DELETE FROM WorkloadCalibratorHistory
INSERT INTO WorkloadCalibratorHistory (activityType, valueAverage, standardDeviation, startTime) VALUES (?, ?, ?, ?)
SELECT * FROM WorkloadCalibratorHistory ORDER BY startTime DESC LIMIT 1
UPDATE WorkloadCalibratorHistory SET startTime = startTime + ?
DELETE FROM WorkloadCalibratorHistory WHERE id not in (SELECT id FROM WorkloadCalibratorHistory ORDER BY id DESC LIMIT ?) AND activityType = ?
UPDATE WorkloadCalibratorHistory SET valueAverage= ?, standardDeviation= ? WHERE startTime = ? AND activityType = ?
virtual void CLWorkloadCalibratorRecorderDb::prepareSQLStatements()
Device is locked and we are unable to open the database.
virtual void CLWorkloadCalibratorRecorderDb::deleteRecordsAfterInsertUL(const CLWorkloadCalibratorEntry &)
Failed to delete records.
virtual void CLWorkloadCalibratorRecorderDb::shiftRecordsByUL(CFTimeInterval)
virtual void CLWorkloadCalibratorRecorderDb::insertRecordUL(const CLWorkloadCalibratorEntry &, bool)
WorkloadCalibratorDb (%d,%f,%f,%f).
valueAverage
standardDeviation
CLActivityRecorderDb<CLWorkloadCalibratorEntry>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLWorkloadCalibratorEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLWorkloadCalibratorEntry>::setDatabaseAccessible() [T = CLWorkloadCalibratorEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLWorkloadCalibratorEntry>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLWorkloadCalibratorEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
AuthContext InUse:%d  RegResult:%d(%d) EffectiveMask:%d  ProvisionalMask:%d
kCLConnectionMessageSwimDataUpdate
kCLConnectionMessageSwimDataQuery
void CLSwimDataSubscription::onSwimNotification(int, const CLSwimNotifier_Type::Notification &, const CLSwimNotifier_Type::NotificationData &)
void CLSwimDataSubscription::handleRequestSwimDataUpdate(bool, const CLNameValuePair &)
SwimData subscription changed, %s, %p, %d
#Warning Failed to subscribe to swim updates.
void CLSwimDataSubscription::handleMessageSwimDataQuery(std::shared_ptr<CLConnectionMessage>)
CLDaemonClient.SwimNotifierQuery
void CLSwimDataSubscription::handleMessageSwimDataQuery(std::shared_ptr<CLConnectionMessage>)_block_invoke
Query: id, %llu, session, %s, db, %s, Response (numel): %lu
CLSwimDataSubscription::onSwimNotification
CLClientAuthorizationCacheSilo
-[CLClientAuthorizationCache syncgetAuthorizationOfClient:forServiceMask:]
syncgetAuthorizationOfClient, %s, forServiceMask, %lx, authorized, %d
-[CLClientAuthorizationCache setClientsAuthorizationMap:]
setClients, %s
kCLConnectionMessageSignificantLocationVisitState
VisitMonitoring
activeType
kCLConnectionMessageSignificantLocationVisitKey
kCLConnectionMessageSignificantLocationVisitStateKey
startDate
kCLConnectionMessageSignificantLocationVisitTypeKey
com.apple.locationd.slv_configurer
void CLVisitMonitoringSubscription::handleMessageSignificantLocationVisitState(std::shared_ptr<CLConnectionMessage>)_block_invoke
#slv: using corrective compensation
#slv: using full precision or lastVisit is nil
fIsValid
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLPersistentSubscription.h
assertValid
-[CLFallServer initInUniverse:]
Initializing CLFallServer instance
ServerRegistrationTimerFireInterval
Overriding registration timer fire interval: %d
ServerLogDirectory
/var/mobile/Library/locationd/Server
ServerHost
https://ingest.apple-studies.com:8443
ServerRegistrationEndpoint
/ingest/v2/register
ServerSubmissionEndpoint
/ingest/v2/submit
ServerStudyID
cf28ffed-271e-416f-9aff-f69bd999885a
ServerAuthorization
RygmpPxtPG5B04FlpFT23YWMnqDhouPM0XANlLy3S3Asl5U6X7hu5eoJTl2CZFeK
ServerCertificate
MIIDjTCCAnWgAwIBAgIEFN2TTjANBgkqhkiG9w0BAQsFADB3MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCUN1cGVydGlubzEXMBUGA1UEChMOQXBwbGUgSW50ZXJuYWwxDzANBgNVBAsTBkhlYWx0aDEdMBsGA1UEAxMUY29tLmFwcGxlLkhlYWx0aERhdGEwHhcNMTcwNDE4MTgzODI4WhcNMTgwNDE4MTgzODI4WjB3MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCUN1cGVydGlubzEXMBUGA1UEChMOQXBwbGUgSW50ZXJuYWwxDzANBgNVBAsTBkhlYWx0aDEdMBsGA1UEAxMUY29tLmFwcGxlLkhlYWx0aERhdGEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDvR2JtAkPdG/BldPRT7EupiMo4ZvLOzztoDeul2awbM9fBU8kc3nlapOi2vooX62cyPJKsqCas465gy4U3JJBMVg/MjshfUIDBb1LQzGtvfYkirdpWOqJ7riQ0Wbe6LLRFD0963JNF1lyMHkf7OqZegIh8c+xGGgd2ynkdivaKOr2d7Qf67y2UarQc+qIgkljsaOugfBr3jsUcO0tE0j9LGOvTZZEZd3ykXUEChIkwGW+QWWd3Indit4ArSMGDjkrltGX88FBWgbPYe8dgjWcE2GkEEWhJFwIiTCHQZFHlizSzY5vyG0mcbgdl/HjbyswUn3kw8CvmSOuzi7YNolypAgMBAAGjITAfMB0GA1UdDgQWBBRaESD5M6MGBsOr4aMdm42SVZwycDANBgkqhkiG9w0BAQsFAAOCAQEAVg1mV0Zf9/o+cAbwvcQgdGIbeUghVdDybkVkeew/3dpdRN/S9k9BTusNL4gNKbRRIjJiESq68rP++8BP7xhIO3EsICFAo/fp87af1EncYIjwh9V6P77V+wnvU8Ehgj9tGj5GhU/o1tmCLmBsJi+uUz8vd7p8S/CbH0wUpe0uov4d79R1DGYrM+fansMd9JnmZfLeGU1sx2q+hEfAZyuSRJEf4+GbgEuthq0aBNC6VeXVmmNqd36at3F9O4DzJiJOZiEHXNYOXiyJYSBEvgKdd23G9tR1Pdqw//0sKv/C4b3FQWowN7uZzJ3SJTrolzpUGlTSy5PPeXsmsL7TKM27uA==
Unable to create log directory, error: %@
-[CLFallServer dealloc]
Tearing down CLFallServer instance
-[CLFallServer _initializeValueForKey:withDefault:]
Overriding %{public}@ to: %{public}@
Overriding %{public}@
-[CLFallServer _registerDevice]
Attempting to register device...
application/octet-stream
Content-Type
Accept
-[CLFallServer _registerDevice]_block_invoke
HTTP Response for Server registration, statusCode: %{public}d
Unable to register subject, statusCode: %{public}ld, error: %@, response: %@
Unable to parse response! Exception: %{private}@
Unable to parse response for register subject, responseDictionary: %@, error: %@
subjectId
token
Successfully registered device, subject UUID: %{private}@, subject Auth: %{private}@
HCSubjectUUID
HCSubjectAuth
-[CLFallServer _enableDataCollection]
Enabling data collection
NULL certificate for %{public}@
newtongm
com.apple.locationd.CLFallServer
Data collection enabled
-[CLFallServer sendData:metaData:start:end:]
Attempting to send data...
X-HDS-Subject-Authorization
Created request for file: %@, task: %@, ingest URL: %@
Data not sent, IsDataCollectionEnabled: %d
-[CLFallServer cleanUp:]
Cleaning up Server files older than %f(s)
Error removing data file, error: %@
Removed %d Server files
%d_%d_newtongm.dat
-[CLFallServer _encryptData:metaData:start:end:]
Error starting Server message, error: %@
Error appending data to Server message, error: %@
Error finalizing Server message, error: %@
Unable to move Server message along side url, error: %@
Successfully encrypted and moved out URL: %{private}@
idx-
-[CLFallServer _createKeyValuePairsDict:metaData:]
Invalid value type for key: %@, val: %@
buildType
-[CLFallServer onDataProtectionManagerNotification:data:]
Received CLDataProtectionManager notification, deviceUnlockedSinceBoot: %d
Cached subject credentials, _subjectUUID: %{private}@, _subjectAuth: %{private}@
-[CLFallServer URLSession:dataTask:didReceiveData:]
Got called back for %@ with task: %@ and data of length: %lu and id: %@
-[CLFallServer URLSession:task:didCompleteWithError:]
Got called back for %@ with task: %@ and error: %@ and id: %@
HTTP Response, statusCode: %{public}d, filePath: %@, response: %@
Unable to remove file after upload attempt, filePath: %@, error: %@
-[CLFallServer URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:]
Got called back for %@ with task: %@ and bytesSent: %lld and totalBytesSent: %lld and totalBytesExpectedToSend: %lld and id: %@
VO2MaxSessionAttributesHistory
DELETE FROM VO2MaxSessionAttributesHistory WHERE startTime < ?
SELECT * from VO2MaxSessionAttributesHistory ORDER BY startTime ASC
SELECT COUNT(*) FROM VO2MaxSessionAttributesHistory
CMError CLVO2MaxSessionAttributesRecorderDb::queryBySessionId(const unsigned char *, std::vector<VO2MaxSessionAttributes> &) const
VO2MaxSessionAttributesHistory, DB not accessible
SELECT MIN(startTime) FROM VO2MaxSessionAttributesHistory WHERE algorithmVersion >= ?
CMError CLVO2MaxSessionAttributesRecorderDb::getSessionsWithClusters(std::vector<VO2MaxSessionAttributes> &, const CFAbsoluteTime) const
SELECT sah.* from VO2MaxSessionAttributesHistory sah WHERE sah.startTime > ? AND EXISTS (SELECT sh.id FROM VO2MaxSummaryHistory sh WHERE sh.sessionId = sah.sessionId)
CMError CLVO2MaxSessionAttributesRecorderDb::queryInTimeRange(const CFAbsoluteTime, const CFAbsoluteTime, std::vector<VO2MaxSessionAttributes> &) const
SELECT * FROM VO2MaxSessionAttributesHistory WHERE startTime >= ? and startTime <= ? ORDER BY startTime ASC
bool CLVO2MaxSessionAttributesRecorderDb::saveFetchedSession(unsigned char *, const VO2MaxSessionAttributes, const std::vector<VO2MaxSummary> &, const VO2MaxOutput &) const
Unable to save fetched output data from CloudKit. Device is locked and we are unable to open the database
DELETE FROM VO2MaxSummaryHistory WHERE sessionId = ?
INSERT INTO VO2MaxSummaryHistory (startTime, workoutType, sessionId, durationInSeconds, pointCount, hrMax, hrMin, meanHr, meanVo2, meanSpeed, meanGrade, meanHrConfidence, meanHrCadenceAgreement, meanCadence, vo2MaxModelSource, sessionType) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
INSERT INTO VO2MaxHistory (startTime, workoutType, estimatedVo2Max, durationInSeconds, hrMax, hrMin, sessionId, variance, filteredVo2Max, sessionType, eligibleForHealthKit, eligibleForCalorimetry, numWorkoutsContrToEstimate, estimatedHRResponseParam, estimatedHRRecoveryParam) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
UPDATE VO2MaxHistory SET startTime = ?, workoutType = ?, estimatedVo2Max = ?, durationInSeconds = ?, hrMax = ?, hrMin = ?, variance = ?, filteredVo2Max = ?, sessionType = ?, eligibleForHealthKit = ?, eligibleForCalorimetry = ?, numWorkoutsContrToEstimate = ?, estimatedHRResponseParam = ?, estimatedHRRecoveryParam = ? WHERE sessionId = ?
INSERT INTO VO2MaxSessionAttributesHistory (startTime, sessionId, meanMaxMets, prior, hardwareType, betaBlockerUse, algorithmVersion, outputCloudKitSystemFields, inputCloudKitSystemFields) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
UPDATE VO2MaxSessionAttributesHistory SET startTime = ?, meanMaxMets = ?, prior = ?, hardwareType = ?, betaBlockerUse = ?, algorithmVersion = ?, outputCloudKitSystemFields = ? WHERE sessionId = ?
Unable to delete out-of-date VO2MaxSummaryHistory records
Unable to save synced VO2MaxSummaryHistory records
Unable to update synced VO2MaxHistory record
Unable to insert synced VO2MaxHistory record
SELECT * from VO2MaxSessionAttributesHistory WHERE sessionId = ?
UPDATE VO2MaxSessionAttributesHistory SET startTime = ?, sessionId = ?, meanMaxMets = ?, prior = ?, hardwareType = ?, betaBlockerUse = ?, algorithmVersion = ?, outputCloudKitSystemFields = ?, inputCloudKitSystemFields = ? WHERE id = ?
DELETE FROM VO2MaxSessionAttributesHistory
DELETE FROM VO2MaxSessionAttributesHistory WHERE startTime > ?
UPDATE VO2MaxSessionAttributesHistory SET startTime = startTime + ?
SELECT * FROM VO2MaxSessionAttributesHistory ORDER BY id DESC LIMIT 1
ALTER TABLE VO2MaxSessionAttributesHistory ADD COLUMN 
UPDATE VO2MaxSessionAttributesHistory SET 
 = NULL;
SELECT COUNT(name) FROM sqlite_master WHERE type='index' AND name = 'VO2MaxSessionAttributesHistorySessionIdIndex'
void CLVO2MaxSessionAttributesRecorderDb::createIndexOnSessionIdIfNecessary()
Index VO2MaxSessionAttributesHistorySessionIdIndex already exists; not re-creating
CREATE INDEX VO2MaxSessionAttributesHistorySessionIdIndex ON VO2MaxSessionAttributesHistory (sessionId)
Unable to create index VO2MaxSessionAttributesHistorySessionIdIndex
Index VO2MaxSessionAttributesHistorySessionIdIndex created successfully
CMError CLVO2MaxSessionAttributesRecorderDb::getSessionsWithoutEstimates(std::vector<VO2MaxSessionAttributes> &) const
SELECT * from VO2MaxSessionAttributesHistory AS sa WHERE NOT EXISTS (SELECT * FROM VO2MaxHistory AS h WHERE sa.sessionId == h.sessionId)
bool CLVO2MaxSessionAttributesRecorderDb::updateSessionsNeedingCloudKitSyncForOutputs() const
UPDATE VO2MaxSessionAttributesHistory AS sa SET outputCloudKitSystemFields = NULL WHERE sa.sessionId IN (SELECT DISTINCT sh.sessionId FROM VO2MaxStagingSummaryHistory AS sh)
outputCloudKitSystemFields
inputCloudKitSystemFields
CLActivityRecorderDb<VO2MaxSessionAttributes>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxSessionAttributes, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxSessionAttributes>::setDatabaseAccessible() [T = VO2MaxSessionAttributes, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<VO2MaxSessionAttributes>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxSessionAttributes, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<VO2MaxSessionAttributes>::sanitizeAndStoreRecordUL(const T &, bool) [T = VO2MaxSessionAttributes, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
void CLDaemonLocationIndependenceAssertion::handleMessageLocationIndependenceAssertion(std::shared_ptr<CLConnectionMessage>)
#warning LocationIndependenceAssertion already taken by %{public}s
com.apple.locationd.independence_declarer
bool CLDaemonLocationIndependenceAssertion::isEntitled(const std::string &)
CLDaemonGnssDisablementAssertion::CLDaemonGnssDisablementAssertion(CLConnection *, id<CLIntersiloUniverse>)
#clgda,daemon,CLDaemonGnssDisablementAssertion()
virtual CLDaemonGnssDisablementAssertion::~CLDaemonGnssDisablementAssertion()
#clgda,daemon,~CLDaemonGnssDisablementAssertion()
void CLDaemonGnssDisablementAssertion::sendAssertionRsp(bool) const
#clgda,daemon,sendAssertionRspWithSuccess
#clgda,daemon,sendAssertionRspWithFailure
kCLGDA_AssertionCompleteStatusKey
virtual void CLDaemonGnssDisablementAssertion::handleMessage(std::shared_ptr<CLConnectionMessage>)
#clgda,daemon,message,%s
com.apple.locationd.gnss-disablement
void CLDaemonGnssDisablementAssertion::handleMessageGnssDisablementAssertion(std::shared_ptr<CLConnectionMessage>)
#clgda,daemon,takenBy,%s,reason,%s
void CLDaemonGnssDisablementAssertion::handleGnssDisablementNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#clgda,daemon,kNotificationGnssDisablementAssertRsp,%d
CLDaemonGnssDisablementAssertion::handleGnssDisablementNotification
com.apple.locationd.executable-
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLClientManager_Type.mm
encodeInUseLevelAsInteger
level < inUseLevelDecodeTable.size() && level >= 0
decodeInUseLevelFromInteger
-[CLMobilityHealthKitWriter initWithDelegate:]
HealthKitWriter: Initializing Mobility HKDataCollectors (%@)
-[CLMobilityHealthKitWriter writeToHealthKitAppleWalkingSteadiness:startDate:endDate:source:]
Writing Steadiness score to HealthKit, startDate: %{public}@, endDate:%{public}@, walkingSteadiness: %{private}f, source: %{public}@
Steadiness Sample missing source metadata
-[CLMobilityHealthKitWriter writeToHealthKitAppleWalkingSteadiness:startDate:endDate:source:]_block_invoke
HealthKitWriter: failed to push steadiness sample to HealthKit, error, %{public}@
HealthKitWriter: successfully pushed steadiness sample to HealthKit, startDate: %{public}@, endDate:%{public}@, walkingSteadiness: %{private}f
-[CLMobilityHealthKitWriter writeSteadinessEvent:startDate:endDate:source:]
Writing Steadiness event to HealthKit, startDate: %{public}@, endDate:%{public}@, eventType: %{private}ld, source: %{public}@
Unsupported event type: none
Steadiness Event missing source metadata
-[CLMobilityHealthKitWriter writeSteadinessEvent:startDate:endDate:source:]_block_invoke
Successfully pushed WalkingSteadinessEvent sample
Failed to insert WalkingSteadinessEvent sample: %{public}@
-[CLMobilityHealthKitWriter _writeToHealthKitType:value:startDate:endDate:metadata:]
HealthKitWriter: Writing %s to HealthKit, startDate: %{public}@, endDate: %{public}@, value: %{private}.2f, metadata: %@
HealthKitWriter: Unexpected QuantityTypeIdentifier %d
HKDataCollector %s was not properly initialized
-[CLMobilityHealthKitWriter _writeToHealthKitType:value:startDate:endDate:metadata:]_block_invoke
HKDataCollector successfully pushed %s sample
HKDataCollector failed to insert a %s sample, error, %{public}@
-[CLMobilityHealthKitWriter isWalkingSteadinessAvailable]
Unable to query onboarding status: %{public}@
HK Walking Steadiness unavailable. reasons=%{public}ld, isLocaleValid=%{public}d, state=%{public}ld
-[CLMobilityHealthKitWriter areWalkingSteadinessNotificationsEnabled]
Unable to query notification status: %{public}@
-[CLMobilityHealthKitWriter dataCollectorDidRequestCollectionThroughDate:completion:]
HealthKitWriter: Data collection requested through date %@
-[CLMobilityHealthKitWriter dataCollectorDidRequestCollectionThroughDate:completion:]_block_invoke
HealthKitWriter: Data collection completion was nil
freq
bool CLKappaNotifier::collectionAuthorized(const struct EventAuthorization *) const
collectionAuthorized = %u
bool CLKappaNotifier::uploadMSLFile(NSString *, NSMutableDictionary *)
Failed to mmap the MSL file %@
collectionUUID
bool CLKappaNotifier::collectionAllowedOnCompanionCollect(const struct EventCompanionCollect *)
Heartbeating UUID %{public}@
collection UUID %{public}@, recording started = %{public}d
bool CLKappaNotifier::startRecording()
start recording
fRecordingUUID = %{public}@, %{public}p
Error starting recording %@
recordingVersion
mslSchemaVersion
systemReleaseType
osVersionBuild
hasSOS
isTruePositiveCandidate
hasPassedTPAlgGps
hasPassedTPAlgAudio
hasPassedTPAlgBaro
hasPassedTPAlgPulse
hasPassedTPAlgZg
horizontalDecelThresholdCoupled
impactThresholdUncoupled
starting recording %@
/var/mobile/Library/locationd/Kappa/
companionConnected
mslSize
pressureMin
pressureMax
const NSString *CLKappaNotifier::stopRecording(bool)
pressure min %f max %f delta %f
hasAudio
drivingTime
collectingTime
ageBin
signalEnvironment
coarseLat
coarseLong
sunElevation
Stopped recording %{public}p, retain count %lu
Stopping a recording without a UUID
Stopping a non-active recording %p
/var/mobile/Library/locationd/Kappa/pending
void CLKappaNotifier::authorizedEntry()
upload timer using %d seconds
upload will not be performed in-system, skipping upload timer setup
Kappa is disabled
void CLKappaNotifier::collectingEntry(const struct EventTimeout *)
setFastAccelConfig failed
requesting location update
void CLKappaNotifier::triggeredEntry(const struct EventAOP *)
setting AOP collection timeout timer at %d seconds
Trigger companion at %{public}llu
void CLKappaNotifier::triggeredEntry(const struct EventAOP *)_block_invoke
tell the companion to trigger
playing alarm haptic
skipping alarm haptic
void CLKappaNotifier::qualifyingEntry()
precondition violation; no recording, or D MSL could was not opened
void CLKappaNotifier::sosWaitEntry()
bypass SOS wait state since SOS events have already occurred and been logged
waiting for sos for %d seconds
void CLKappaNotifier::disabled2authorized(const struct EventAuthorization *)
disabled -> authorized
void CLKappaNotifier::authorized2disabled(const struct EventAuthorization *)
authorized -> disabled
void CLKappaNotifier::authorized2collecting(const struct EventCompanionCollect *)
authorized -> collecting
void CLKappaNotifier::collecting2authorizedTimeout(const struct EventTimeout *)
collecting (timeout) -> authorized
void CLKappaNotifier::collecting2authorizedStop(const struct EventCompanionStop *)
collecting (stop) -> authorized
void CLKappaNotifier::collecting2triggered(const struct EventAOP *)
collecting -> triggered
void CLKappaNotifier::triggered2authorized(const struct EventTimeout *)
triggered -> authorized
void CLKappaNotifier::triggered2qualifying(const struct EventAOP *)
triggered -> qualifying
void CLKappaNotifier::qualifying2waiting(const struct EventTimeout *)
qualifying -> SOS wait
void CLKappaNotifier::qualifying2disabled(const struct EventAuthorization *)
qualifying -> disabled
void CLKappaNotifier::sosWait2disabled(const struct EventAuthorization *)
SOS wait (SOS) -> disabled
void CLKappaNotifier::sosWait2authorized_event(const struct EventSOS *)
SOS wait (SOS Event) -> authorized
void CLKappaNotifier::sosWait2authorized_timeout(const struct EventTimeout *)
SOS wait (timeout) -> authorized
void CLKappaNotifier::setupTriggerParameters()
using trigger parameters uncoupled %f, coupled %f
void CLKappaNotifier::setupFSMTimer()_block_invoke
fFSMTimer handler
void CLKappaNotifier::setupHeartbeatTimer()_block_invoke
fHeartbeatTimer handler
void CLKappaNotifier::dumpUploadQueue()
recording list:
%d %@
recording dictionaries:
dictionary %i
%d %{public}@ = %{public}@
NSDictionary *CLKappaNotifier::moveRecordingToFile(NSFileHandle *)
recordings may not be requested while the device is locked
file handle is nil
system configured for upload of recordings, refusing to obtain manually
bool CLKappaNotifier::coinflip(double) const
coin flip = %f, rbound = %f
int32_t CLKappaNotifier::evaluateTp(CLKappaNotifier::Tpq)
pulse alg result passed
pulse alg forced
gps alg result passed
gps alg forced
baro alg result passed
baro alg forced
zg alg result passed
zg alg forced
audio alg result passed
audio alg forced
configServerVersionNumber
bool CLKappaNotifier::postTriggerUploadFilter()
TPQ 0x%x, order %u (%d, %d, %d, %d, %d) acceptance rate %g
tpq_bitmap
tpq_ar
false positive should be uploaded
void CLKappaNotifier::shouldKeepRecordingFilter()
recording has SOS event, uploading
uploading because the companion will upload
json
bool CLKappaNotifier::saveRecording()
error converting metadata to nsdata
error creating file %@
wrote metadata to path = %@
recordings meta dictionary and files are different sizes
saving recording to the upload queue
saving recording for user study application
discarding %{public}@, not added to upload queue
void CLKappaNotifier::createCAEvent()
trigger (%d) upload (%d) candidate (%d) trigger_type (%d) trigger_bitmap (%d) collecting (%d) driving (%d) tpq_bitmap (%d) config_version (%d) age (%d) biologicalSex (%d) hasSOS (%d)
com.apple.CoreMotion.trigger.perf.metrics
trigger_bitmap
uploaded
candidate
collecting
collected
driving
config_version
minutesUntilEndOfDrive
userAge
eventOrder
static NSData *CLKappaNotifier::mmapDataForFilePath(NSString *, bool)
#Warning could not open file path %{public}@
failed to remove %@; error: %@
void CLKappaNotifier::uploadAllFiles()
deferring upload while collection could be in progress
enabling the server
no recordings to upload
sequenceNumber %u
sequenceNumber
uuid
uploading file = %{public}@, UUID = %{public}@
failed to upload the file
rotating UUID fRecordingSeq (%d) rotateCount (%d) hasSOS (%d)
upload: fDeviceUnlockedSinceBoot = %d, fDeviceUnlocked = %d, fSessionEstablished = %d
void CLKappaNotifier::setupUploadTimer()
skipping upload timer setup, system will not upload recordings
Emergency SOS
KappaLogDirectory
CLKappaNotifier::CLKappaNotifier(id<CLIntersiloUniverse>)
Failed to create log directory %@, error: %@
Created log folder %@
Log folder is %@
recording sequence %d
fServiceLocationClient
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Kappa/CLKappaNotifier.mm
configuration version %d
void CLKappaNotifier::teardownTpQualifiers()
tearing down tpqs
static bool CLKappaNotifier::isAvailable()
(CLKappaNotifier) %d
virtual void CLKappaNotifier::shutdown()
Recording compass calibration stopped.
static float CLKappaNotifier::getAcceptanceRateConfig(uint8_t)
returning defaults write AR for 0x%x = %g
returning server config AR for 0x%x = %g
Invalid server AR config array
returning default AR for 0x%x = %g
void CLKappaNotifier::handleReplyTriggerEvent(const CLMotionCoprocessorInterface::NotificationData *)
got a trigger at %llu, simulated %d, triggerPathBitmap %x, listening %u
forcedSensorConfig
hasAudioAllowed
audioSampleTime
triggerPathBitmap
impactTriggerCoupled
avgDecelTriggerCoupled
impactTriggerUncoupled
avgDecelTriggerUncoupled
deltaTrigger
btHint
void CLKappaNotifier::handleReplyTimeout(const CLMotionCoprocessorInterface::NotificationData *)
kappa timed out
void CLKappaNotifier::handleReplyStreamingFinished(const CLMotionCoprocessorInterface::NotificationData *)
Streaming has finished at %llu
void CLKappaNotifier::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, const CLCompanionNotifier_Type::NotificationData &)
companion nearby %{public}d
companion nearby, but kappa is disabled
void CLKappaNotifier::onMotionStateUpdate(int, const CLMotionState_Type::Notification &, const CLMotionState_Type::NotificationData &)
(onMotionStateUpdate) %p state %d, EventActivity; inVehicle %d, high confidence %d, mounted %d
bool CLKappaNotifier::isAuthorizedForIHA()
isAuthorizedForIHA (simulated) %d
isAuthorizedForIHA  %d
bool CLKappaNotifier::isAuthorizedForDNU()
isAuthorizedForDNU (simulated) %d
isAuthorizedForDNU  %d
virtual void CLKappaNotifier::onSessionEstablished()
HDS session established
virtual void CLKappaNotifier::onUploadFinished(NSString * _Nonnull)
upload finished for file: %@
virtual void CLKappaNotifier::onUploadSuccess(NSString * _Nonnull)
upload successful for file: %@
void CLKappaNotifier::onPressureBias(int, const CLPressureBias_Type::Notification &, const CLPressureBias_Type::NotificationData &)
PressureInertialFit,x,%f,y,%f,z,%f
CLNameValuePair updateOrClearDaemonCacheKeyDictionary(NSDictionary *, CLNameValuePair, std::string, std::string, float, float, float)
%s %g
CLNameValuePair CLKappaNotifier::parseServerDisableConfig(NSDictionary *, CLNameValuePair)
saving KappaDisable = 1
saving KappaDisable = 0
clearing KappaDisable
saving KappaDisable = %d
virtual void CLKappaNotifier::onConfigurationResponse(NSDictionary * _Nonnull)
Received server configuration
%d %@ = %@
server config version
baro threshold
zg threshold
gps threshold
audio threshold
coupled
uncoupled
pulse threshold
acceptance rates
[0x%x] %@
void CLKappaNotifier::onSignalEnvironmentNotification(int, const CLSignalEnvironmentProvider_Type::Notification &, const CLSignalEnvironmentProvider_Type::NotificationData &)
signal environment %u
void CLKappaNotifier::onLocation(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
type = %u, speed = %f accuracy = %f course = %f lat = %f long = %f
Unhandled location notification %{public}d
void CLKappaNotifier::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification &, const CLDataProtectionManager_Type::NotificationData &)
DeviceUnlockedSinceBoot %u
EncryptedDataAvailability %u
void CLKappaNotifier::onUserInfoNotification(int, const CLNatalimetryNotifier_Type::Notification &, const CLNatalimetryNotifier_Type::NotificationData &)
age=%d biologicalSex=%d
void CLKappaNotifier::onEmergencyStateChange(CLEmergencyState)
emergency state is the same %s
emergency state change was %s now is %s
logging active SOS call
void CLKappaNotifier::onEmergencyStateChange(CLEmergencyState)_block_invoke
tell the companion to upload
void CLKappaNotifier::stopCompanionCollect()
Firing companion stop event
void CLKappaNotifier::onCompanionCollect(NSData *)
void CLKappaNotifier::onCompanionTrigger(NSData *)
Companion triggered; forced AOP trigger
Ignoring loopback msg
NOT collecting; ignoring companion trigger
void CLKappaNotifier::onCompanionUpload(NSData *)
Companion will upload %{public}@ with SOS state %{public}u
logging companion SOS call
NOT in SOS wait state; asserting fBypassSOSWait
My collection UUID is different than companion's
void CLKappaNotifier::setIsSimulated(bool)
setIsSimulated
void CLKappaNotifier::setIsSimulatedAuthorized(bool)
setIsSimulatedAuthorized
void CLKappaNotifier::manualModeEnable()
enable manual mode
manual mode already enabled
void CLKappaNotifier::manualModeDisable()
disable manual mode
void CLKappaNotifier::setCustomConfig(const CMMotionCoprocessorCommand::KappaConfig &)
setting one shot custom config: fast accel (%d), accel (%d), pressure (%d), DM (%d), audio (%u), mag (%d)timeout %d
void CLKappaNotifier::simulateAuthorized(bool)
simulate authorized %d current state %d
void CLKappaNotifier::simulateDriving(bool)
simulate driving confidence = %d
KappaRateLimitingCount
void CLKappaNotifier::replenishTokens(bool)
detected cached value larger than the defaults, resetting
updating tokens to %{public}u
token %{public}u
void CLKappaNotifier::simulateTriggered()
simulate triggered
void CLKappaNotifier::forceAudio(bool)
forcing audio %d
void CLKappaNotifier::forcePulse(bool)
forcing pulse %d
void CLKappaNotifier::forceGPS(bool)
forcing gps %d
void CLKappaNotifier::forceZg(bool)
forcing zg %d
void CLKappaNotifier::forceBaro(bool)
forcing baro %d
-[CLKappaNotifierAdapter emergencyStateChange:]
CLKappaNotifierSilo
-[CLKappaNotifierAdapter beginService]
NSString *_initializeValueForKey(NSString *, NSString *)
CLKappaNotifier::onKappaReply
CLKappaNotifier::onDataProtectionNotification
CLKappaNotifier::onLocation
CLKappaNotifier::onMotionStateUpdate
CLKappaNotifier::onPressureBias
CLKappaNotifier::onUserInfoNotification
CLKappaNotifier::onCompanionNotification
CLKappaNotifier::onSignalEnvironmentNotification
Eiger
virtual void CLMotionNotifier::SiloDispatcher<CMMotionCoprocessorReply::CompassCalibration>::dispatchData(int, const void *, size_t) [T = CMMotionCoprocessorReply::CompassCalibration]
virtual void CLNotifier<CLKappaNotifier_Type::Notification, CLKappaNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLKappaNotifier_Type::Notification, NotificationData_T = CLKappaNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLKappaNotifier_Type::Notification, CLKappaNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLKappaNotifier_Type::Notification, NotificationData_T = CLKappaNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void updateOrClearDaemonCacheKey(NSDictionary *, std::string, std::string, T, T) [T = int]
%s %f
void updateOrClearDaemonCacheKeyArray(NSDictionary *, std::string, std::string, uint8_t, const T *, const T *) [T = float]
%s-%i %f
virtual void CLNotifier<CLKappaNotifier_Type::Notification, CLKappaNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLKappaNotifier_Type::Notification, NotificationData_T = CLKappaNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLKappaNotifier_Type::Notification, CLKappaNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLKappaNotifier_Type::Notification, NotificationData_T = CLKappaNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLKappaNotifier_Type::Notification, CLKappaNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLKappaNotifier_Type::Notification, NotificationData_T = CLKappaNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLKappaNotifier_Type::Notification, CLKappaNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLKappaNotifier_Type::Notification, NotificationData_T = CLKappaNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLKappaNotifier_Type::Notification, CLKappaNotifier_Type::NotificationData>::listClients() [Notification_T = CLKappaNotifier_Type::Notification, NotificationData_T = CLKappaNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
fitnessTrackingEnabled
powerSource
kChargerTypeUnknown
kChargerTypeNone
kChargerTypeUsb
kChargerTypeExternal
bool CMAccelerometerProcessor::computeFrequencyFeatures()
Assertion failed: !(ignoreHamming && node->requiresHammingWindow(samples[r]->sampleFreq)), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMAccelerometerProcessor.cpp, line 185,Hamming required but ignored..
const CMRunningBuffer3d<CMAccelerometerProcessor::kNumHighRateAccelSamples> &CMAccelerometerProcessor::accelBuffer(int) const
Developer error. Specified rate does not exist.
static void CLFenceMonitorWifiLogic::calculateAPsForFences(CLWifiAccessPointLocationService &, const std::map<CLFenceManager_Type::Fence, bool> &, std::map<CLFenceManager_Type::Fence, int> &, bool, const CLWifiService_Type::AccessPoint &, const CLDaemonLocation &, std::vector<CLWifiService_Type::AccessPoint> &, std::vector<CLWifiService_Type::AccessPoint> &, const std::vector<CLWifiService_Type::AccessPoint> &, int, bool &, std::function<void (const CLFenceManager_Type::Fence &)>)
Polygonal fence should not be added for wifi monitoring
Fence: combined fences, %{public}lu, fences to, %{public}lu, fences
combinedFence.hasFenceKey()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/Fence/CLFenceMonitorWifiLogic.mm
calculateAPsForFences
Fence: Failed to calculate fence %{private}s
#Warning Fence: combined fence, %{private}s
Fence: Calculator for %{public}s/%{private}s returned %{public}ld desired APs for %{private}s
Fence: Using associated AP %{private}s, channel %{private}d for exit
#Warning Fence: Continuous monitoring is needed in order to supported the monitored fences
WifiFenceCalculator: Adding exit AP, mac, %{private}s, hAcc, %{private}.2lf, channel, %{private}d, location, %{private}12.8lf, %{private}12.8lf, isLocallyAdministered, %{private}d
Fence: WifiFenceCalculator: Skipped non-2GHz AP, channel, %{private}d, mac, %{private}s
WifiFenceCalculator: Adding entry AP, mac, %{private}s, hAcc, %{private}.2lf, channel, %{private}d, location, %{private}12.8lf, %{private}12.8lf
Fence: Fence calculator returned more APs (%{public}zu) than maximum (%{public}d)
#Warning Fence: no visible APs, exitAPs, %{public}lu
Fence: request a download for, %{private}s, fChosenAPs, %{public}lu
Fence: calculateAPsForFences end
bool CLTimeOffsetFilter::update(const double &, const double &, double &, double &)
Estimated,time offset measurement variance(s^2),%.12g
#Warning Unacceptable,time offset measurement variance(s^2),%.12g
Unexpected,state plus measurement covariance < 0.
internalTimeSecs,%.6lf,externalTimeSecs,%.6lf,filteredOffsetSecs,%.6lf,offsetUncertaintySecs,%.9g,R,%.9g,Q,%.9g,v,%.9g,vtest2,%.9g
/System/Library/CoreServices/SystemVersion.plist
ProductVersion
ProductBuildVersion
%@_%@
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Positioning/Transit/CLTransitTilePreloaderExternal.mm
requestTileDownload
CLVehicleStateNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/Vehicle/CLVehicleStateNotifier.mm
-[CLVehicleStateNotifierAdapter beginService]
CLVechileStateNotifier
DisableVehicularFalsePositiveSuppression
com.apple.locationd.bundle-/System/Library/LocationBundles/MotionCalibration.bundle
void CLVehicleStateNotifier::updateLocationAuthorization()_block_invoke
VEHICULAR: Motion calibration system service is disabled.
void CLVehicleStateNotifier::checkAndToggleGPS()
VEHICULAR: Taking power assertion and enabling proactive gps.
vehicular detection
VEHICULAR: Releasing power assertion and disabling proactive gps, loi, %{private}d, stationaryWifi, %{private}d, state, %{private}lu, auth, %{private}d, clients, %{private}d
high
void CLVehicleStateNotifier::onVisit(CLVisit *, CLVehicleStateNotifier_Type::LoiVisitConfidence)
VEHICULAR: visit, confidence, %s, exit
VEHICULAR: visit, confidence, %s, entry
void CLVehicleStateNotifier::onTransitNavigationStateUpdateNotification(int, const CLCachedLocationController_Type::Notification &, const CLCachedLocationController_Type::NotificationData &)
VEHICULAR: Received transit navigation state: %{public}d
void CLVehicleStateNotifier::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
VEHICULAR: WiFi dis-associated, update vehicular state
VEHICULAR: WiFi isStationary, %{private}d
void CLVehicleStateNotifier::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
#Warning VEHICULAR: Received unhandled location notification, %{public}d
void CLVehicleStateNotifier::enterDndLoi(CLLocationCoordinate2D, CLLocationAccuracy)
VEHICULAR: entering DNDLOI, range, %{public}f
void CLVehicleStateNotifier::updateVisitByLocation(const CLClientLocation &)
VEHICULAR: too far from center of DNDLOI
VEHICULAR: skipping repeated nearby location
void CLVehicleStateNotifier::updateFastSuppressionMode(const CLClientLocation &)_block_invoke
VEHICULAR: Error retrieving LOIs. %{public}@
VEHICULAR: No LOIs near fast suppression range
VEHICULAR: recover visit, confidence, high, entry
VEHICULAR: fast suppression range detected
void CLVehicleStateNotifier::updateVehicularDnd()
VEHICULAR: state, %{public}lu, hints, %{public}lu, fpSuppress, %{public}u, dndOverride, %{public}u
com.apple.carexperience.vehiclestate
VEHICULAR: submitted metrics, %@
void CLVehicleStateNotifier::resetVehicularFalsePositiveSuppressionDnd()
VEHICULAR: reset vehicular false positive mitigation states
Mode
VehicularDetection
void CLVehicleStateNotifier::notifyVehicularDnd()
VEHICULAR: Could not post state associated with vehicular state changed notification.
VEHICULAR: Could not post kCMVehicularStateChangedToVehicularNotification.
VEHICULAR: successfully posted notification, %@
CLVehicleStateNotifier::onVehicleConnectionNotification
CLVehicleStateNotifier::onMotionStateUpdate
CLVehicleStateNotifier::onTransitNavigationStateUpdateNotification
CLVehicleStateNotifier::onDaemonStatus
CLVehicleStateNotifier::onLocationNotification
virtual void CLNotifier<CLVehicleStateNotifier_Type::Notification, CLVehicleStateNotifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLVehicleStateNotifier_Type::Notification, NotificationData_T = CLVehicleStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLVehicleStateNotifier_Type::Notification, CLVehicleStateNotifier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLVehicleStateNotifier_Type::Notification, NotificationData_T = CLVehicleStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLVehicleStateNotifier_Type::Notification, CLVehicleStateNotifier_Type::NotificationData>::removeClient(int) [Notification_T = CLVehicleStateNotifier_Type::Notification, NotificationData_T = CLVehicleStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLVehicleStateNotifier_Type::Notification, CLVehicleStateNotifier_Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLVehicleStateNotifier_Type::Notification, NotificationData_T = CLVehicleStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLVehicleStateNotifier_Type::Notification, CLVehicleStateNotifier_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLVehicleStateNotifier_Type::Notification, NotificationData_T = CLVehicleStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLVehicleStateNotifier_Type::Notification, CLVehicleStateNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLVehicleStateNotifier_Type::Notification, NotificationData_T = CLVehicleStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLVehicleStateNotifier_Type::Notification, CLVehicleStateNotifier_Type::NotificationData>::listClients() [Notification_T = CLVehicleStateNotifier_Type::Notification, NotificationData_T = CLVehicleStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
Unrecognized notification
Empty payload, returning
LocationFine
LocationCoarse
LocationSpectator
LocationBystander
LocationLeech
LocationInfo
TechnologyStatus
Navigation
LocationUnavailable
LocationUnfiltered
ControlPlaneRequest
ServiceAuthorization
LocationBatched
MapMatching
SignalQuality
UserPlaneRequest
VehicleSpeed
VehicleHeading
WifiLocationBatched
OdometerBuffered
XtraFileAvailable
GnssMeas
PropagateLocation
LocationPropagated
ActivityTypeFitness
ActivityTypeAirborne
GnssVendorLocation
VisionARSessionState
VisionCompassBias
LocationPrefiltered
HighDesiredAccuracy
FocusedNavigation
GnssAvailabilityPredicted
BasebandTimeFreqTransfer
GnssDisablementStatus
LocationBystanderPreLoiOverride
ExternalLocationDisablement
bool CLLocationProvider_Type::unalterAccessoryLocation(CLClientLocation &, const CLDaemonLocationPrivate &)
ALTERED: original location: %.8f, %.8f, %.2f, %d, %d
ALTERED:  unaltered location: %.8f, %.8f, %.2f, %d, %d
int CLLocationProvider_Type::locationDataToNvpWithOptions(const CLLocationProvider_Type::NotificationData &, CLNameValuePair &, const CLLocationProvider_Type::LocationDataSerializationOptions &)
Failed to convert Coarse MetaData to nvp
IsFitnessMatch
Failed to convert location to nvp
Failed to convert location private to nvp
nrarfcn
gpsAltitude
rawSpeed
gpsSpeedAccuracy
quality
kGood
kMed
kPoor
ReadyToFire
Pending0
Pending1
Pending2
Pending3
Pending4
Pending5
Pending6
Pending7
Pending8
Pending9
Expired
StateMax
CLSmootherMonitorSilo
-[CLSmootherMonitor beginService]
beginService
com.apple.locationd.smoother
-[CLSmootherMonitor endService]
endService
-[CLSmootherMonitor listener:shouldAcceptNewConnection:]
shouldAcceptNewConnection
process is not entitled to use CLLocationSmoother, pid, %{public}d, executable, %{public}s
-[CLSmootherMonitor listener:shouldAcceptNewConnection:]_block_invoke
Connection Interrupted
Connection Invalidated
CLSmootherErrorDomain
CLCoarseCellTile-Mutex
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, CLTilesManager_Type::KeyLatLonEntry_CoarseCell>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CoarseCell]
virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, CLTilesManager_Type::KeyLatLonEntry_CoarseCell>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CoarseCell]
bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, CLTilesManager_Type::KeyLatLonEntry_CoarseCell>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CoarseCell]
bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, CLTilesManager_Type::KeyLatLonEntry_CoarseCell>::binarySearchData(const DataEntry_T *, unsigned int, unsigned int, const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CoarseCell]
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, CLTilesManager_Type::KeyLatLonEntry_CoarseCell>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CoarseCell]
virtual bool CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, CLTilesManager_Type::KeyLatLonEntry_CoarseCell>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CoarseCell]
CLAppRecommendationTile-Mutex
virtual bool CLSpatialDataTileTemplate<CLTilesManager_Type::AppRecommendationIndexEntry, CLTilesManager_Type::AppRecommendationEntry>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::AppRecommendationIndexEntry, DataEntry_T = CLTilesManager_Type::AppRecommendationEntry]
TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s, id, %s
TILE: searched for, location, %.10lf, %.10lf, setLinear, %lu, setIndex, %lu
TILE: not in index, %s, count, %3u, locationd, %.10lf, %.10lf
TILE: result: tilestool: pass, %d, tests, %u, %d
virtual void CLSpatialDataTileTemplate<CLTilesManager_Type::AppRecommendationIndexEntry, CLTilesManager_Type::AppRecommendationEntry>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::AppRecommendationIndexEntry, DataEntry_T = CLTilesManager_Type::AppRecommendationEntry]
TILE: CLSpatialDataTileTemplate, parsing, sectionId, %d, %s
TILE: CLSpatialDataTileTemplate, index, height, %u, width, %u
TILE: index entry, %3lu, %3u, step, %04d, %s
TILE: CLSpatialDataTileTemplate, entries, numOfEntries, %u
TILE: CLSpatialDataTileTemplate, headers only, give up
TILE: entry, %3lu, %3u, %3lu, %s, swLoc, %.8lf, %.8lf
TILE: CLSpatialDataTileTemplate, regionalEntries, numOfEntries, %u
TILE: entry, %3lu, %3u, %3lu, %s
entriesOffset, 
virtual void CLSpatialDataTileTemplate<CLTilesManager_Type::AppRecommendationIndexEntry, CLTilesManager_Type::AppRecommendationEntry>::getEntriesForArea(const double &, const double &, const double &, const double &, bool, bool, std::list<DataEntry_T> &) [IndexEntry_T = CLTilesManager_Type::AppRecommendationIndexEntry, DataEntry_T = CLTilesManager_Type::AppRecommendationEntry]
TILE: getEntriesForArea, input, swLatitude, %.8lf, swLongitude, %.8lf, search, %.8lf, %.8lf, isUseIndex, %d, includeRegionalEntries, %d, entries, %lu
TILE: doesIntersectWithTile, %d, no intersection with the tile
TILE: invalid section, signature, 0x%x, stopping
TILE: getEntriesForArea, invalid tile file, bad allocation size, totalBytesInSection, %lu, maxSectionSize, %lu
TILE: getEntriesForArea, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, genTime, %.2lf, expAge, %d, age, %.2lf
TILE: getEntriesForArea, numEntriesHeight, %d, numEntriesWidth, %d, entrySizeInBytes, %d
TILE: getEntriesForArea, numOfEntries, %d, entrySizeInBytes, %d, numOfLargeEntries, %d
TILE: getEntriesForArea, numOfRegionalEntries, %d, entrySizeInBytes, %d
TILE: getEntriesForArea, asked not to use index
TILE: getEntriesForArea, pIndexEntries, 0x%lx, pEntries, 0x%lx
TILE: getEntriesForArea, line, %d, searched_min_y, %d, %d, searched_min_x, %d, %d, index_y, %d, index_x, %d, entriesOffset, %d
TILE: getEntriesForArea, entryId, %d, isIntersect, %d, examinedEntries, %d, entry, %s
TILE: getEntriesForArea, nothing to search, %s
TILE: getEntriesForArea, examinedEntries, %5u, foundEntries, %5lu, isUseIndex, %d, clocks, %10lu, extra, %3d, %3d
receiver object cannot be null
users of CLWifiServiceClient should not register for kNotificationPower directly
users of CLWifiServiceClient should not register for kNotificationLinkStatus directly
users of CLWifiServiceClient should not register for kNotificationRoam directly
users of CLWifiServiceClient should not unregister for kNotificationPower directly
users of CLWifiServiceClient should not unregister for kNotificationLinkStatus directly
users of CLWifiServiceClient should not unregister for kNotificationRoam directly
void CLWifiServiceClient::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiService_Type::NotificationData &)
notification, %d, kNotificationPower, fIsWifiPowered, %d, data.power, %d
notification, %{public}d, kNotificationLinkStatus/Roam, wasAssociated, %{public}d, isAssociated, %{public}d
CLWifiServiceClient::onWifiNotification
CLStepCountRecorderDb
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/StepCount/CLStepCountRecorderDb.mm
StepCountHistory
INSERT INTO StepCountHistory (startTime, timestamp, count, distance, rawdistance, floorsAscended, floorsDescended, pace, activeTime, firstStepTime, pushCount, workoutType, elevationAscended, elevationDescended, distanceSource, currentCadence) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
SELECT * FROM StepCountHistory ORDER BY startTime DESC LIMIT 1
virtual void CLStepCountRecorderDb::prepareSQLStatements()
void CLStepCountRecorderDb::alterTableIfNecessary()
StepCountHistory table doesn't even exist
ALTER TABLE StepCountHistory
UPDATE StepCountHistory SET 
CLStepDistance CLStepCountRecorderDb::queryStepCount(CFAbsoluteTime, CFAbsoluteTime, CLStepCountRecorderDb::QueryTimeType) const
Assumption failed: startTime (%{public}f) was found to be newer than endTime (%{public}f), queryTimeType %{public}d
#Warning First step time invalid.
CMError CLStepCountRecorderDb::queryStepCountSince(const CLStepCountEntry &, std::vector<CLStepCountEntry> &) const
StepCountHistory not accessible
#Warning DB UUID un-initialized
SELECT * FROM StepCountHistory WHERE id >= ? ORDER BY id ASC LIMIT ?
#Warning Potential DB reset, returning all records to clients
#Warning Step count has rolled back, returning mru to clients,mru.recordId,%d,record.recordId,%d,mru.count,%u,record.count,%u,mru.distance,%f,record.distance,%f,mru.activeTime,%f,record.activeTime,%f,mru.pushCount,%d,record.pushCount,%d
Step count has rolled back!!
virtual CMError CLStepCountRecorderDb::queryStepCountInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<CLStepCountEntry> &) const
SELECT * FROM StepCountHistory WHERE startTime BETWEEN ? and ? ORDER BY startTime ASC
DELETE FROM StepCountHistory
DELETE FROM StepCountHistory WHERE startTime > ?
virtual void CLStepCountRecorderDb::deleteRecordsAfterInsertUL(const CLStepCountEntry &)
Failed to delete records
UPDATE StepCountHistory SET startTime = startTime + ?
virtual void CLStepCountRecorderDb::shiftRecordsByUL(CFTimeInterval)
Failed to shift records
SELECT * FROM StepCountHistory ORDER BY startTime ASC LIMIT 1
SELECT * FROM StepCountHistory WHERE 
 >= ? ORDER BY startTime ASC LIMIT 1
 <= ? ORDER BY startTime DESC LIMIT 1
FirstStepTime
StartTime
bool CLStepCountRecorderDb::searchListUL(CLStepCountRecorderDb::QueryTimeType, CFAbsoluteTime, CLStepCountEntry &, CLStepCountEntry &) const
Failed to search list for %{public}s %{public}f
virtual long CLStepCountRecorderDb::aggregateRecords(const CLAggregationRules &)
Failed to examine the most last record for data aggregation.
Failed to examine the second to last record for data aggregation.
Failed to iterate through records for data aggregation.
Failed to retrieve most recent record for data aggregation.
DELETE FROM StepCountHistory WHERE id = ?
Failed to delete marked records with timestamp of %{public}f
SELECT COUNT(*) FROM StepCountHistory
CLActivityDB::ActivityCode CLStepCountRecorderDb::getCountOffset(uint32_t, int &, CLStepCountEntry &)
Reset requested.  Counts (prev: %d cur:%d). New fOffset (%d).
Reset current step count.  Counts (prev: %d cur:%d). New fOffset (%d).
Oscar restart detected.  Count (prev: %d cur:%d). New fOffset (%d).
An error in step counts is highly likely.  Treating current count as new 0.  Count (prev: %{public}d cur:%{public}d). New fOffset (%{public}d).
CLActivityDB::ActivityCode CLStepCountRecorderDb::getFloorsElevationAndActiveTimeOffset(CLStepCountEntry, CLStepCountEntry)
Reset requested.  New offset (%d, %d, %f).
Reset requested.  New elevation offset (%d, %d).
Locationd restart detected.  New offset (%d, %d, %f).
Locationd restart detected.  New elevation offset (%d, %d).
Oscar restart detected.  New offset (%d, %d, %f).
Oscar restart detected.  New elevation offset (%d, %d).
An error in floor counts is highly likely.  Treating current count as new 0.  New offset (%{public}d, %{public}d, %{public}f).
rawdistance
pushCount
currentCadence
CLActivityRecorderDb<CLStepCountEntry>::CLActivityRecorderDb(const char *, bool, float, const std::string, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLStepCountEntry>::setDatabaseAccessible() [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
bool CLActivityRecorderDb<CLStepCountEntry>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLActivityRecorderDb<CLStepCountEntry>::sanitizeAndStoreRecordUL(const T &, bool) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
CLStepCountNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Shared/StepCount/CLStepCountNotifier.mm
-[CLStepCountNotifierAdapter beginService]
-[CLStepCountNotifierAdapter getPedometerCalibrationBins:withReply:]
PedestrianOdometer
CLStepCountNotifier::CLStepCountNotifier(id<CLIntersiloUniverse>)
CLStepCountNotifier is being constructed
StepCountingDisableAggregation
StepCountingDisableExpiration
StepCountingEmulationTimeRate
StepCountingDetailedLogging
Configuration: speedUpRate %f, aggregationDisabled %d, expirationDisabled %d, detailedLogging %d
virtual CLStepCountNotifier::~CLStepCountNotifier()
CLStepCountNotifier is shutting down
StepCountingAggregateTimerInterval
void CLStepCountNotifier::setUpAggregateOnTimer()_block_invoke
Aggregating records due to timer!
void CLStepCountNotifier::setUpdateFinishedHandler()_block_invoke
StepCount, %f, %d, %f, %d, %d, %d, %d
v160@?0{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}8
void CLStepCountNotifier::update(std::shared_ptr<CLStepCountVector>)
Adding Fused entry, time, %f, count, %d, raw_dist(m), %f, fused_dist(m), %f, cadence(steps/s), %f
CLStepDistance CLStepCountNotifier::query(CFAbsoluteTime &, CFAbsoluteTime &) const
Query (%f, %f): %d, %f, %f, %d, %d, %f
v24@?0{shared_ptr<std::vector<CLStepCountEntry>>=^v^{__shared_weak_count}}8
!pace || isAvailable()
isPaceAndCadenceAPIAvailable
void CLStepCountNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)
step counting overrideActivityType,%lu,
void CLStepCountNotifier::onUserInfoUpdate(int, const CLNatalimetryNotifier_Type::Notification &, const CLNatalimetryNotifier_Type::NotificationData &)
CLStepCountNotifier::onMotionStateMediatorNotification
CLStepCountNotifier::onUserInfoUpdate
CLStepCountNotifier::onActivePedStateCoprocessorData
CLStepCountNotifier::onActivePedStateCoprocessorDataSpectator
void CLActivityAggregator<CLStepCountEntry>::addAggregationRule(CFTimeInterval, CFTimeInterval) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
Programmer error, this rule is not valid (age: %{public}f, interval:%{public}f).
addAggregationRule
CLActivityAggregator.h
fRules.back().timeFromCurrentS < timeFromCurrentS
fRules.back().minimumIntervalS < minimumIntervalS
void CLActivityAggregator<CLStepCountEntry>::setExpirationRule(CFTimeInterval) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
long CLActivityAggregator<CLStepCountEntry>::aggregateRecords() [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
int CLActivityRecorderDb<CLStepCountEntry>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLNotifier<CLStepCountNotifier_Type::Notification, CLStepCountNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLStepCountNotifier_Type::Notification, NotificationData_T = CLStepCountNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLStepCountNotifier_Type::Notification, CLStepCountNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLStepCountNotifier_Type::Notification, NotificationData_T = CLStepCountNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLActivityRecorderDb<CLStepCountEntry>::addSuspectRecord(const T &) [T = CLStepCountEntry, DataProtectionPolicy = CLActivityDB::NoDataProtectionPolicy]
virtual void CLNotifier<CLStepCountNotifier_Type::Notification, CLStepCountNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLStepCountNotifier_Type::Notification, NotificationData_T = CLStepCountNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLStepCountNotifier_Type::Notification, CLStepCountNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLStepCountNotifier_Type::Notification, NotificationData_T = CLStepCountNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLStepCountNotifier_Type::Notification, CLStepCountNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLStepCountNotifier_Type::Notification, NotificationData_T = CLStepCountNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLStepCountNotifier_Type::Notification, CLStepCountNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLStepCountNotifier_Type::Notification, NotificationData_T = CLStepCountNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLStepCountNotifier_Type::Notification, CLStepCountNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLStepCountNotifier_Type::Notification, NotificationData_T = CLStepCountNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
-[CLBarometerCalibrationSourcePressure onKFFilteredPressure:]
received KF filtered pressure from AOP!, now %f filteredPressureTimestamp %f filteredPressure %f kfTimestamp %f kfElevation %f kfPressure %f temperature %f
virtual void CLMotionNotifier::SiloDispatcher<CLBarometerCalibration_Types::CMKFFilteredPressureSample>::dispatchData(int, const void *, size_t) [T = CLBarometerCalibration_Types::CMKFFilteredPressureSample]
void CLActivityAlarmSubscription::onActivityAlarm(int, CMActivityAlarm *, NSError *)
activity alarm triggered. (internal id %d)
activity alarm triggered, but invalidated.  ignoring.  (internal id %d)
void CLActivityAlarmSubscription::handleRequestActivityAlarm(bool, const CLNameValuePair &)
#Warning Activity alarms not available.  Requested alarm will not be listened for.
Primed for activity alarm %d with duration %f (internal id %d)
void CLActivityAlarmSubscription::handleRequestActivityAlarm(bool, const CLNameValuePair &)_block_invoke
#Warning CLDaemonClient got activity alarm callback after destruction... ignoring
Invalidated activity alarm %d with duration %f (internal id %d)
CLSwimNotifierSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Swimming/CLSwimNotifier.mm
-[CLSwimNotifierAdapter beginService]
-[CLSwimNotifierAdapter syncget_prepareSessionEndForSessionType:]
SwimNotifier, Requested finalize before end.
CLSwimNotifier
SwimAggregateTimerInterval
SwimAggregateTimerExpiration
SwimDistributionsByLOI
CLSwimNotifier::CLSwimNotifier(id<CLIntersiloUniverse>)
SwimDistributionsByLOI set to %d
Swim Notifier instantiated
LogSwimming
LogMotionStateReplay and LogSwimming are both set - LogMotionStateReplay takes precedence in the Swim Notifier
SimulateSwimming
virtual void CLSwimNotifier::shutdown()
CLSwimNotifier is shutting down.
virtual bool CLSwimNotifier::registerForNotificationInternal(const CLSwimNotifier_Type::Notification &)
Added client for %d, count %d
void CLSwimNotifier::getLOIsForLocation(CLLocation *)
[LOI] Calling fetchLocationsOfInterestWithinDistance
void CLSwimNotifier::getLOIsForLocation(CLLocation *)_block_invoke
Error retrieving the RT LOIs. %@
[LOI] Found nil locationsOfInterest
void CLSwimNotifier::requestLocation()
[LOI] Registering for location updates
void CLSwimNotifier::turnOnSwimTrackingIfNecessary(const CLMotionStateMediator_Type::MotionOverride &)
SwimController is ready
[SwimOdom] Registering for odometer updates
virtual bool CLSwimNotifier::unregisterForNotificationInternal(const CLSwimNotifier_Type::Notification &)
Removed client for %d, count %d
void CLSwimNotifier::turnOffSwimTrackingIfNecessary()
[SwimOdom] Unregistering for odometer updates
[LOI] Unregistering for location updates
Swim Controller released
void CLSwimNotifier::setupSensorFusion()
swim fusion setup
void CLSwimNotifier::teardownSensorFusion()
swim fusion teardown
fSwimAlg
processSensorFusion
fFusion
processGyroSample
processAccelerometerSample
processGyroTempSample
void CLSwimNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)
Swimming workout started, location, %lu, poolLength, %f
Swimming workout has ended
void CLSwimNotifier::onOdometerNotification(int, const CLOdometerNotifier_Type::Notification &, const CLOdometerNotifier_Type::NotificationData &)
[SwimOdom] Received an odometer update of type: %d
[SwimOdom] Received unhandled notification, %d
void CLSwimNotifier::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)
[LOI] Received a location,lat: %{private}lf, long: %{private}lf, accuracy: %lf, lifespan: %lf, timestamp: %lf
Received unhandled notification, %d
CLSwimNotifier::onMotionStateMediatorNotification
CLSwimNotifier::onWatchOrientationSettingsNotification
CLSwimNotifier::onNataliemetryUpdate
CLSwimNotifier::onOdometerNotification
Swimming
CLSwimNotifier::onLocationNotification
virtual void CLMotionNotifier::SiloDispatcher<CLGyro::Sample>::dispatchData(int, const void *, size_t) [T = CLGyro::Sample]
virtual void CLMotionNotifier::SiloDispatcher<CLAccelerometer::Sample>::dispatchData(int, const void *, size_t) [T = CLAccelerometer::Sample]
virtual void CLNotifier<CLSwimNotifier_Type::Notification, CLSwimNotifier_Type::NotificationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, bool, int, bool) [Notification_T = CLSwimNotifier_Type::Notification, NotificationData_T = CLSwimNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLNotifier<CLSwimNotifier_Type::Notification, CLSwimNotifier_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSwimNotifier_Type::Notification, NotificationData_T = CLSwimNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSwimNotifier_Type::Notification, CLSwimNotifier_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLSwimNotifier_Type::Notification, NotificationData_T = CLSwimNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSwimNotifier_Type::Notification, CLSwimNotifier_Type::NotificationData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSwimNotifier_Type::Notification, NotificationData_T = CLSwimNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSwimNotifier_Type::Notification, CLSwimNotifier_Type::NotificationData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLSwimNotifier_Type::Notification, NotificationData_T = CLSwimNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual bool CLNotifier<CLSwimNotifier_Type::Notification, CLSwimNotifier_Type::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSwimNotifier_Type::Notification, NotificationData_T = CLSwimNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
virtual void CLNotifier<CLSwimNotifier_Type::Notification, CLSwimNotifier_Type::NotificationData, char, char>::listClients() [Notification_T = CLSwimNotifier_Type::Notification, NotificationData_T = CLSwimNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]
void CLMobility::WalkingSteadinessClassifier::handleUserInfoUpdate(const CLBodyMetrics &)
SteadinessClassifier: Received user info (%{public}s)
WalkingSteadinessClassifier::Result CLMobility::WalkingSteadinessClassifier::classify(CFAbsoluteTime, const std::vector<HealthKitQuantitySample> &, bool, int, const std::vector<HealthKitQuantitySample> &, const std::vector<HealthKitQuantitySample> &) const
SteadinessClassifier unable to classify because UserInfo not set
#warning: Attempted a classification despite invalid user age: %{private}.1f. Exiting.
#warning: SteadinessClassifier unable to classify, BoutMetricsDb unavailable
No height set, setting nextClassificationTime to the past for historical compute
SteadinessClassifier: score suppressed.
CLMobility::SteadinessResult,hkStartTime,%{public}.2f,hkEndTime,%{public}.2f,unadjustedScore,%{private}.2f,walkingSteadiness,%{private}.2f,writeToHealthKit,%{public}d,errorStatus,%{public}d,rejectionStatus,%{public}d,nextClassificationTime,%{public}.2f,dataSourcesUnavailable,%{public}d
bool CLMobility::WalkingSteadinessClassifier::correctBoutMetrics(std::vector<BoutMetrics> &) const
Applied bout metrics correction (speeds=%{public}d, stepLengths=%{public}d, doubleSupportPercentages=%{public}d, entropyModelStepLengthFeatures=%{public}d)
bool CLMobility::WalkingSteadinessClassifier::isInsufficientTimeSinceFirstBout(CFAbsoluteTime, CFAbsoluteTime &) const
Insufficient time since first bout (%{public}.2f). Retrying on %{public}.2f
void CLMobility::WalkingSteadinessClassifier::checkInsufficientTimeSinceSteadinessSample(WalkingSteadinessClassifier::Result &, std::vector<HealthKitQuantitySample>) const
SteadinessClassifier unable to classify, insufficient time since previous steadiness endTime, classificationTime=%{public}.2f, previousSteadinessEndTime=%{public}.2f
WalkingSteadinessClassifier::EventResult CLMobility::WalkingSteadinessClassifier::detectSteadinessEvent(std::vector<HealthKitQuantitySample> &, const std::vector<HealthKitCategorySample> &, CFAbsoluteTime, const bool) const
[SteadinessEvent] No steadiness samples, no event detected
[SteadinessEvent] Evaluating %ld sample(s) from (%.2f->%.2f)
[SteadinessEvent] EvaluateRepeatVeryLow: isRepeatVeryLow,%d,durationOK,%.2f,durationVeryLow,%.2f,durationLow,%.2f
[SteadinessEvent] EvaluateRepeatLow: isRepeatLow,%d,durationOK,%.2f,durationVeryLow,%.2f,durationLow,%.2f
[SteadinessEvent] steadinessEvent, %{private}ld, percentLow, %{private}.2f, percentVeryLow, %{private}.2f, mostRecentClassification, %{private}ld, isBlockoutPeriodLow, %{private}d, isBlockoutPeriodVeryLow, %{private}d, isSampleRecent, %{public}d, userOnboardedNotifications, %{private}d, isRepeatVeryLow, %{private}d, isRepeatLow, %{private}d 
std::pair<CFAbsoluteTime, CFAbsoluteTime> CLMobility::WalkingSteadinessClassifier::mostRecentLowAndVeryLowEventTimes(const std::vector<HealthKitCategorySample> &) const
Unexpected event type value: %ld
static double CLMobility::WalkingSteadinessClassifier::doubleSupportBMIBiasCorrection(double, double)
BMI above max threshold, %{private}.2f, setting it to Max threshold, %{private}.2f
BMI below min threshold, %{private}.2f, setting it to Min threshold, %{private}.2f
void CLMobility::WalkingSteadinessClassifier::entropyModelFeatureHeightCorrection(double &, double, double, double) const
Attempted to correct entropy model feature without height being set
com.apple.bluetooth.audio-stream
FilePrefix
FileBasePath
FileSize
FileTimeInterval
FilesToKeep
FileExtension
ProtectionClass
FlushTimeout
/tmp/
alsTrustedLux
super
batch
calibrated
lowerBound
upperBound
accel
sensorTime
arsc
arscString
config
deviceConfiguration
hardwareModel
serialNumber
side
temp
gyroCachedBias
gyttString
base
broken
peak
sensor
conchaDropped
conchaRecovered
iedState
mean
optical
tragusDropped
tragusRecovered
conchaTemp
prescalar
pwrState
tragusTemp
wdtPeriod
oscl
osclString
pdtc
pdtcString
detectedSteps
firstStepFeatures
fsmEndState
fsmStartState
impulseEndTime
impulseStartTime
imuTimestamp
stepLikelihoodFeatures
hostState
s7q8
sensorState
accelDecimated
accelFrontVariance
accelMean
accelNormAutocorr
accelNormMean
accelNormVariance
accelVariance
currentAngleDelta
currentMotionState
lagAtMaxAutocorr
lastBaseline
maxAutocorr
walkingBaseline
widthAtMaxAutocorr
eventTag
correction
lastConvergenceTimestamp
arrivalTimestamp
btcTimestamp
filteredAcceleration
quiescentMode
quiescentNoise
sampleLatency
sensorTimeUponReceival
timeSyncStatus
acceleration
biasCovariance
quaternion
rotationRate
statusDeprecated
userAcceleration
fConnected
fEndTime
fStartTime
reserved
scaledValue
speedRange
speedThreshold
bioMotionTimestamp
pose
runSmoother
velocity
probabilityGenericMotion
probabilityHeadMotion
probabilityPedestrianMotion
probabilityTorsoMotion
centerOfRotationEstVars
centerOfRotationEsts
linkLengthEstVars
linkLengthEsts
positionResidualNormMean
positionResidualNormVar
timestampBegin
timestampEnd
updatedLinkLengthX
updatedLinkLengthY
updatedLinkLengthZ
attitude
modelType
translation
targetTimestamp
withAnchoredStaticPose
adaptiveExerciseMinuteThreshold
condition
runVo2max
deviceMotion
vo2MaxInput
eventTime
rotationMatrix
pause
endDate
hkType
gain
point
tempCalA
tempCalB
tempCalEnabled
tempCalT0
tragus
biasX
biasY
biasZ
calibrationLevel
horizontal
inclination
magneticFieldX
magneticFieldY
magneticFieldZ
magneticHeading
magnitude
trueHeading
compassJustAlignedToStableField
apAwake
cost
coverage
earthDiffRatio
hasConsistency
planarity
poseX
poseY
poseZ
scaleX
scaleY
scaleZ
coverage2d
coverage3d
isPlanar
numberOfSamples
timeSpan
unitDistance
attitudeDelta
calibratedField
doCorrection
isOnSphere
isRotating
isTraversingSphere
predictedField
scale
timerUnitDistanceThreshold
unitDistanceLargeBufferDelta
unitDistanceLargeBufferMax
unitDistanceReference
unitDistanceSmallBufferDelta
unitDistanceThreshold
unitDistanceThresholdApplied
vertical
asymmetryProbabilityEstimate
doubleSupportEstimate
gaitPhase
stepLengthEstimate
walkSpeedEstimate
clientID
magneticFieldCalibrationLevel
quaternionW
quaternionX
quaternionY
quaternionZ
rotationRateX
rotationRateY
rotationRateZ
userAccelerationX
userAccelerationY
userAccelerationZ
variant
visionCompassBias
inQuiescentMode
shouldGyroBeOn
measurement
noisevariance
statevariance
biasvariance
currentMeanAngleY
deltaMeanAngleY
doubleTapCounter
doubleTapStatus
entropyConcha
entropyTragus
tapInterval
doingBiasEstimation
doingYawCorrection
aperture
exposureDuration
failureCode
lidAngle
orientation
poseLibrary
rollValue
sensorCovered
tooDark
cyclingState
cyclingStateSummary
distanceTraveledOverTimeWindow
motionType
abruptGravityChangeAngle
accelPathLength
angleChangePostImpact
angleChangePreImpact
crown
crownVariance
gravityVariance
iostime
isFall
isNearFall
maxAbsX
maxAbsY
maxAbsZ
maxAccelNorm
maxAngleChangePostImpact
maxAngleChangePreImpact
maxJerkVM
maxMinusMin
medianAbsGravityY
minInertialZ
minInertialZHighFreq
multiPeakAccelPathLengthWithPeak
multiPeakPathLengthDecorrelation
multiPeakPathLengthDelaySpread
multiPeakPathLengthHarmonicMean
operatingMode
peakTimestamp
poseAtImpact
posteriorRatio
sumDeltaAngles
swingAngle
tiltAngle
timeto3rdZC
withinCyclingImpactThresholds
withinHardThresholds
gyroOn
consideredAlert
consideredRecovery
consideredSOS
droppedAlert
droppedRecovery
droppedSOS
fallTime
impactOperatingMode
isOtherStateMachineProcessingNearbyImpact
refereeCyclingStateDecision
refereeOperatingMode
alertCanceledBecauseOfAbsenceOfQuiessence
alertCanceledBecauseOfActive
alertCanceledBecauseOfChargerState
alertCanceledBecauseOfCyclingPostImpact
alertCanceledBecauseOfDecimatedLowFrequencyFFT
alertCanceledBecauseOfDistanceTraveledPostImpact
alertCanceledBecauseOfHighFrequencyFFT
alertCanceledBecauseOfLockedNoMotionPre
alertCanceledBecauseOfLowFrequencyFFT
alertCanceledBecauseOfNumberOfPeaksFFT
alertCanceledBecauseOfOffBody
alertCanceledBecauseOfRepetitiveMotion
alertCanceledBecauseOfRetraction
alertCanceledBecauseOfSimilarPeaks
alertCanceledBecauseOfStand
alertCanceledBecauseOfSteps
alertCanceledBecauseOfWristState
alertCanceledBecauseOfWristStatePost
alertCanceledBecauseOfWristStatePre
fallStatsDispatchResetOnAccelSensorTime
fallStatsDispatchRestoredOnAccelSensorTime
hkWorkoutId
impactCanceledBecauseOfExistingAlert
impactNotConsideredBecauseOfCyclingImpactThresholds
impactNotConsideredBecauseOfMaxAccelNormThreshold
impactNotConsideredBecauseOfMultiPeaks
impactNotConsideredBecauseOfNaiveBayesClassifier
impactNotConsideredBecauseOfOtherHardThresholds
leavingImpactBecauseOfNewImpactNewImpact
leavingImpactBecauseOfNewImpactOldImpact
skippedFallStatsSensorTime
skippedGyroSensorTime
sosCanceledBecauseOfAbsenceOfLongLie
sosCanceledBecauseOfActive
sosCanceledBecauseOfStand
sosCanceledBecauseOfSteps
sosConsideredFallTimestamp
sosConsideredIOSTime
sosConsideredSensorTime
workoutId
workoutTransitionPause
workoutTransitionResume
workoutTransitionStart
workoutTransitionStop
conisderedSOS
deltaSteps
didCancelSOS
distanceTraveled
fallAlertUndelayedTimestamp
fromState
gyroMaxMean
isActive
isStand
magnitudeDiffUnity
maxAccelStdAxis
maxNumQuiescentBins
maxNumStaticBins
nominalQuiescentThreshold
normalizedIQR
numActiveBins
numCyclingEpochs
numNonzeroStepEpochs
numPeaks
numQuiescentBins
numSharpPeaks
numStandBins
numStaticBins
onBodyFeature
quiescentThreshold
sentFallAlert
sharpPeaksDelaySpread
sumHighQPeaksInDecLowFreqFFT
sumHighQPeaksInHighFreqFFT
sumHighQPeaksInLowFreqFFT
toState
totalNumStaticBins
absoluteTimestampOfImpact
anyOffWristAfterImpact
aopTimestampOfImpact
continuousLockedBeforeImpact
continuousOffWristBeforeImpact
continuousStaticAndVerticalBeforeImpact
coreMotionWristStateHistoryEndimestamp
coreMotionWristStateHistoryStartTimestamp
coreMotionWristStateHistoryState
gatingEnabled
gatingLockedNoMotionPreImpact
gatingMotionPreImpact
gatingOffWristPostImpact
gatingOffWristPreImpact
gatingOnCharger
hasMotionBeforeImpact
lastChargerState
lastChargerStateDuration
lastChargerStateDurationThreshold
lastCoreMotionWristState
lastCoreMotionWristStateDuration
lastCoreMotionWristStateDurationPostEnd
lastCoreMotionWristStateDurationPostStart
lastCoreMotionWristStateDurationPostThreshold
lastCoreMotionWristStateDurationPreEnd
lastCoreMotionWristStateDurationPreStart
lastLockedStateDurationPreEnd
lastLockedStateDurationPreStart
lastMotionState
lastMotionStateEndTime
lastMotionStateStartTime
lockStateHistoryEndTimestamp
lockStateHistoryStartTimestamp
lockStateHistoryState
motionLookbackBeforeImpactEndOfInterval
motionLookbackBeforeImpactStartOfInterval
motionStateHistoryEndTimestamp
motionStateHistoryStartTimestamp
motionStateHistoryState
relativeTimestampToImpact
afterElevationMedian
beforeElevationMedian
endTimestampOfWindow
impactTimestamp
pressureTimestamp
rangeOfElevationInWindow
startTimestampOfLastInspectedWindow
startTimestampOfWindow
aopTsImpact
aopTsNow
aopTsSensor
nPeaks
repetitiveMotion
repetitiveMotionEndTs
repetitiveMotionStartTs
crownUpDown
fallType
impactMaxAccelNormAlertThreshold
impactMaxAccelNormLoggingHeartRateThreshold
impactMaxAccelNormLoggingHighResolutionSensorDataThreshold
impactMaxAccelNormLoggingStatsThreshold
metMinutePercentile90
metMinutePercentile95
metMinutePercentile98
metMinutePercentileActual
otherFallPosteriorRatioDetectionThreshold
slipFallPosteriorRatioDetectionThreshold
tripFallPosteriorRatioDetectionThreshold
userAgeBucket
accel100
accel800
aopTimestamp
dmAlwaysOn
fallState
fallStats
gyro100
gyro200
meta
odometerEntry
suppressionFeatures
fallAlertSentFromReferee
resolution
response
accelPathLengthWithPeak
extrapolatedMaxAccelNorm
extrapolatedMaxMinusMin
jerkVectorMagMax
magMax
pathLengthDecorrelation
pathLengthDelaySpread
pathLengthHarmonicMean
trialCount
xJerkScalarMagMax
xMax
xMin
xZCTime
yJerkScalarMagMax
yMax
yMin
yZCTime
zJerkScalarMagMax
zMax
zMin
zZCTime
aggAccelZDelta
arcLength
curveDistance
firstLoftAngleDeg
stepResult
horizontalRotationRateMax
impulseMagnitude
isCadenceConcordant
isFeasibleWalkingSpeed
isNotRunning
isPendular
isSufficientVerticalTwist
isSwingStanceCycle
isValid
loftEndTime
loftMagnitude
loftStartTime
pendulumResidual
previousImpulseStartTime
rawLoftSpeed
sqrtMaxAbsLoftAccel
stanceProbability
verticalRotationRateMean
curImpulseStartTime
curLoftEndTime
curLoftStartTime
currentHorzRotRateMax
currentImpulseMagnitude
currentLoftMagnitude
currentMax
currentMin
currentWalkSpeedEstimate
firstLoft
lastZeroTime
loftEndDetected
loftStartDetected
prevLoftStartTime
previousHorzRotRateMax
previousMax
vertRotationRateMean
waitingToConfirmLoft
decimalYear
declination
magnitudeVar
isAvgGrav
sampleNumMod3
subType
triggerEnabled
triggerOn
varianceX
varianceY
varianceZ
allowRelaxedGyroMean
gyroMean
gyroVariance
stillOnAll
temperatureBias
axis
dynamicBiasEstimate
estimateErrorMetric
rawGyroTemperature
subFitError
intercept
lastMiniCal
sample
temperature
fsync
sampleNum
lastSampleId
slowOptical
conchaMinAccepted
newOpenLid
oldOpenLid
tragusMinAccepted
baseline
conchaOpenResponse
filter
minimum
above
below
current
moving
partialin
stable
threshold
upright
upsidedown
last
correlation
deltatip
instability
maximum
from
ringBufferUpdated
runningMinAccepted
codedInvocation
fromName
toName
accelBatch
accelGesture
accelGps
accelOscarEmu
accelerometerPace
accessoryAccel
accessoryAccelConfig
accessoryConfig
accessoryDeviceMotion
accessoryDeviceMotionConfig
accessoryGyro
accessoryGyroCachedBias
accessoryGyroConfig
accessoryGyroGYTT
accessoryInEarStatus
accessoryProx
accessoryProxSensorDrop
accessoryProxTempComp
accessoryProximityConfig
accessoryStepDetectorDebug
accessoryWake
accessoryWakeDebug
airpodEvent
alsData
anchorCorrection
appleCV3DSLAMState
arSessionState
audioAccessoryDeviceMotion
auxiliaryDeviceMotion
averagedALSData
bTConnection
basebandSpeed
bioMotionAnchorPose
bioMotionClassification
bioMotionLinkLengthFitParameters
bioMotionOnlineLinkLengthUpdate
bioMotionPose
bioMotionPredictedPose
bioMotionPropagatedAnchor
bleedToZeroCorrection
braveHeartAccel
braveHeartDeviceMotion
braveHeartNatalieData
braveHeartVO2MaxInput
braveHeartWorkoutEvent
cV3DPredictedPose
calorimetryPauseEvent
catherineHealthKitData
cftime
clefCalibration
coarseElevationChange
compassAlignment
compassCalibration
compassCalibrationAttempt
compassConstraints
compassCorrection
constrainedIntegratorModelPredictedPose
constrainedIntegratorPose
coprocessorReplyGaitMetrics
courseConstraints
courseCorrection
deviceMotionAlwaysOn
deviceMotionCovariance
doubleTap
emergencyState
enhancedDeviceMotion
facePose
fallDetectionActivityClassifierReplay
fallDetectionDetector
fallDetectionGyroControllerReplay
fallDetectionReferee
fallDetectionReplay
fallDetectionStateMachine
fallDetectionWristStateReplay
fallDistanceReplay
fallFalsePositiveSuppressionFeatures
fallSnippet
frequencyResponse
fusedBioMotionClassification
gaitCycleSegment
gaitCycleSegmentationState
geomagneticData
gravityConstraints
gravityCorrection
gyroBiasAndVariance
gyroBiasConstraints
gyroBiasCorrection
gyroBiasEstimateError
gyroBiasFit
gyroCalibrationDataFactory
gyroCalibrationDataNonlinearNonFactory
gyroCalibrationSample
gyroCalibrationSampleNonlinear
gyroCompass
gyroDt
gyroFactoryCalibrationData
gyroGps
gyroOscarEmu
gyroTemperature
inEarAdditionalState
inEarBaseline
inEarBaselining
inEarConstraints
inEarOpenLid
inEarOptical
inEarSession
inEarTransition
inEarTransitionEntry
interpolatedAccessoryAccel
intersiloNSCodingData
jitterBufferLevel
jointLinkModelPose
jointLinkModelPredictedPose
kappaTrigger
kappaTriggerDebug
locationOscarEmu
lslHeadingEstimation
mLBasedBioMotionClassification
magneticAccessoryType1
magneticAccessoryType2
magnetometer
magnetometerReset
metsInfo
mobilityBoutMetrics
modelBasedBioMotionClassification
motionActivity
motionActivityReplay
motionGPSLocation
motionHint
motionLocation
motionLoiData
motionStateUpdate
motionWifiAssociation
motionWifiLocation
movementStats
movementStatsGravityProjection
movementStatsSignal
nonlinearBiasFit
odometerWithAltitude
odtPose
onsetHeartRateData
pearlAttitude
pencilTipForce
pencilTouch
poseState
predictedRelativeDeviceMotion
pressureCalibration
pressureCompensated
pressureFiltered
pressureFiltered1HzLowPass
pressureFilteredNoTemperature
pressureGps
pressureOscarEmu
prox
rawAudio
relDMInSystemConfig
relativeDeviceMotionComplexTransition
relativeDeviceMotionCorrelatedMotion
relativeDeviceMotionInternal
relativeGravityConstraints
relativeGravityCorrection
sessionOverride
sitStandDetectorFeatures
sitStandDetectorPosteriorBufferStatsForSitToStand
sitStandDetectorPosteriorBufferStatsForStandToSit
sitStandDetectorTransitions
spatialEvent
spuPlaybackExampleDeviceMotion
spuPlaybackExampleMotionStateUpdate
steadinessEvent
steadinessModelBalanceFeatures
steadinessModelContinuousWalkingFeatures
steadinessModelGaitBaselineFeatures
steadinessModelResult
steadinessModelTemporalDispersionFeatures
steadinessModelTemporalEntropyFeatures
stepCadenceToStrideLengthBin
stepCountEntry
streamingHeartRateData
strideCalBin
tapAccept
tapDetect
tempestPoCAuxiliaryDeviceMotion
tempestPoCListenerOrientation
touchOscarEmu
ultraFastAccel
userStudyEvent
vibrationEvent
vioEstimation
vioPose
vioReplayPose
visualLocalization
visualLocalizationAttitudeConstraints
visualLocalizationAttitudeCorrection
visualStateMeasurement
vo2MaxOutput
walkingDetectionResult
walkingSteadinessClassification
watchOnWristState
watchOrientationSettings
wifiScanResults
workoutRecorderALSData
workoutRecorderAccel
workoutRecorderAccel800
workoutRecorderBodyMetrics
workoutRecorderCompassCalibration
workoutRecorderElevation
workoutRecorderHealthKitInfo
workoutRecorderHeartRate
workoutRecorderMagnetometer
workoutRecorderOdometer
workoutRecorderPressure
workoutRecorderRotationRate
workoutRecorderWatchOnWristStatus
workoutRecorderWatchOrientationSettings
workoutRecorderWifiScanResults
workoutRecorderWorkoutEvent
zeroVelocityCorrection
level
avgHorizontalDecelMax
avgHorizontalDecelThresholdCoupled
inertialAccel
isMounted
isSimulated
nAccelGap
nFullAccel
nFullDM
nOldAccel
nOldDM
nOldDt
nPrecondition
nUseNearest
numResets
prevQ
rawClampedAccel
shouldTrigger
globalReferenceFrame
locationTimestamp
machContinuousLocationTimestamp
machContinuousTimestamp
polylinesLocation1Latitude
polylinesLocation1Longitude
polylinesLocation2Latitude
polylinesLocation2Longitude
roadID
rotationFromGlobalToCameraFrame
rotationFromGlobalToDeviceFrame
rotationalAccuracyInRadians
course
courseAccuracy
locationLoggingEnabled
speedAccuracy
accessoryType
isAttached
isCharging
exitingSaturation
extendedSaturation
shiftInSaturation
timeSinceLastRemag
timeSinceLastRemagTrigger
triggerCount
metsDiff
asymmetryPercentageIsValid
doubleSupportPercentageIsValid
rejectionStatus
stepLengthIsValid
walkingSpeedIsValid
drivingArmLikelihoodSum
drivingStowedLikelihoodSum
rawConfidence
rawType
ssLikelihoodSum
typeYouth
vehicularBasebandHint
vehicularBtHint
vehicularConfidence
vehicularGpsHint
vehicularMotionHint
vehicularWifiHint
workoutDetectionTime
workoutDetectionType
workoutEscalationTime
outdoorCyclingStateMachineFrom
outdoorCyclingStateMachineTo
workoutLocationType
workoutPause
workoutResume
workoutStart
workoutStop
horzUncSemiMaj
horzUncSemiMajAz
horzUncSemiMin
originDevice
roadClass
undulation
undulationModel
wayForm
event
isPrefilteredLocation
matchQuality
rawAltitude
rawUndulation
rawUndulationModel
rawVerticalAccuracy
arrivalDate
confidenceOfGeoLocation
departureDate
distanceToLoi
hashedLatLong
uncertaintyOfGeoLocation
withinDistance
alsLux
caltype
hidTimestamp
rawIsVehicular
rawMotionType
rowStrokeAmplitude
rowStrokeFrequency
rowStrokePower
standing
vectorMagnitude
vehicleExitState
vehicularFlags
wallStartTime
youthClassificationReason
walkingVariable01
adjustedTimestamp
gravity
rawProjectedSignal
horizontalRotationRateFiltered
verticalRotationRateFiltered
verticalUserAcceleration
walkSpeedFilteredSample
fGpsAvailability
fractionalGrade
errorX
errorY
errorZ
overlap
gpsCourseAccuracy
gpsCourseRadians
smoothedGPSAltitude
smoothedGPSAltitudeUncertainty
dataSource
interpolation
sinceLastGood
focalLength
height
origin
pitch
principlePoint
roll
transform
width
tipForce
pathFlags
pathStage
position
wasCorrected
lastStateTimestamp
qStartW
qStartX
qStartY
qStartZ
qStopW
qStopX
qStopY
qStopZ
rBoresightX
rBoresightY
rBoresightZ
srcTimestamp
useForwardPrediction
inertialX
inertialY
inertialZ
maxTemp
medTocFactoryTemp
medianToc
originalTimestamp
detectionMask
volts
auxHorizontalRotation
auxHorizontalTranslation
auxOmegaInertial_X
auxOmegaInertial_Y
auxOmegaInertial_Z
auxUserAccelInertial_X
auxUserAccelInertial_Y
auxUserAccelInertial_Z
auxVerticalRotation
auxVerticalTranslation
blockHeadTurnFalsePositive
bodyTurnDetectionVerticalRotationSrc
bodyTurnMaximaBaseline
counterBodyTurnAboveBaseline
hasRecentHeadTurn
horizontalRotationSimilarity
horizontalRotationSimilarityBaseline
horizontalRotationSimilarityThreshold
horizontalTranslationSimilarity
horizontalTranslationSimilarityBaseline
horizontalTranslationSimilarityThreshold
inBodyTurn
inComplexTransitionState
inStrongBodyTurn
longBodyTurnCounter
longBodyTurnState
overrideHeadTurn
srcHorizontalRotation
srcHorizontalTranslation
srcOmegaInertial_X
srcOmegaInertial_Y
srcOmegaInertial_Z
srcUserAccelInertial_X
srcUserAccelInertial_Y
srcUserAccelInertial_Z
srcVertToHrzRotRatio
srcVerticalRotation
srcVerticalTranslation
srcYawRotationExtremaBuffer
srcYawRotationMaximaBaseline
verticalRotationSimilarity
verticalRotationSimilarityBaseline
verticalRotationSimilarityThreshold
verticalTranslationSimilarity
verticalTranslationSimilarityBaseline
verticalTranslationSimilarityThreshold
yawRateSimilarity1000ms
yawRateSimilarity200ms
yawRateSimilarityState
auxAvgOmegaAroundGrav2s
auxAvgOmegaAroundGravLong
auxAvgOmegaAroundGravShort
auxAvgOmegaLong
auxAvgOmegaShort
auxHistoricalOmegaStdMax
auxOverSrcYawDiffSum
dotRotGrav
hasUnCorrelatedSrcMotion
inHeadTurnState
inLikelySlowBodyTurnPed
isInCorrelatedActivity
isInCorrelatedMotion
lastHeadTurnStartTime
lastHeadTurnStopTime
lastHeadTurnYawRadians
likelyOnGymMachine
relOmegaMeanLong
relOmegaVarLong
relOmegaVarShort
srcAccumulatedYaw4s
srcAvgOmegaAroundGrav2s
srcAvgOmegaAroundGravLong
srcAvgOmegaAroundGravShort
srcAvgOmegaLong
srcAvgOmegaShort
srcAvgYawBufferSum
srcHistoricalOmegaStdMax
srcRotationAxisAlignment
srcYawBufferLongStd
steadyStatePedestrian
btzDisturbanceDuration
btzIsCurrentlyQuiescent
btzQuiescentDurationLoose
btzQuiescentDurationStrict
btzStaticPoseDuration
centeredBoresight
centeredBoresightInHighDynamics
clientMode
noiseVariance
pinnedBoresight
qHat_W
qHat_X
qHat_Y
qHat_Z
rBoresight_X
rBoresight_Y
rBoresight_Z
rHat_X
rHat_Y
rHat_Z
requestingCamera
stateVariance
tracking1IMU
trackingDisabled
trackingScheme
useRelaxedQuiescenceBounds
vHat_X
vHat_Y
vHat_Z
avgRotationMax
historicalDisturbanceDuration
historicalQuiescenceDuration
instAccelMagDiff
instRotationMax
lpfAccelMagDiff
measNoiseVar
magnitudeRangeInertialVertical
maxAngleBetweenThighAndShinDeg
minAngleBetweenThighAndShinDeg
motionPlanarity
timeToReachMaxThighAndShinAngleThreshold
timeToReachMinThighAndShinAngleThreshold
maxPosterior
meanPosterior
minPosterior
transitionType
isBlockoutPeriodLow
isBlockoutPeriodVeryLow
isSampleRecent
percentLow
percentOK
percentVeryLow
userHasOnboarded
writtenToHealthKit
intermediateBoutsAsymmetryPercentageCv
intermediateBoutsAsymmetryPercentageMedian
intermediateBoutsDoubleSupportPercentageMedian
intermediateBoutsDoubleSupportPercentageStd
allBoutsBoutDurationSecCv
allBoutsBoutDurationSecMedian
allBoutsCycleTimeCv
intermediateBoutsCycleTimeCv
intermediateBoutsCycleTimeMedian
intermediateBoutsStepLengthCv
intermediateBoutsStepLengthMedian
intermediateBoutsStepLengthMedianHeightnorm
intermediateBoutsWalkingSpeedCv
intermediateBoutsWalkingSpeedMedian
intermediateBoutsWalkingSpeedMedianSqrtheightnorm
longBoutsWalkingSpeedCountRatioLog
shortBoutsCycleTimeCv
shortBoutsCycleTimeMedian
shortBoutsDoubleSupportPercentageMedian
shortBoutsStepLengthCv
shortBoutsStepLengthMedianHeightnorm
shortBoutsWalkingSpeedCv
shortBoutsWalkingSpeedMedian
shortBoutsWalkingSpeedMedianSqrtheightnorm
asymmetryPercentageMedian
asymmetryPercentageStd
doubleSupportPercentageMedian
intermediateBoutsStepLengthQ95Heightnorm
intermediateBoutsWalkingSpeedQ95Sqrtheightnorm
modelOutputBalancePrior
stepLengthMedian
stepLengthXWalkingSpeedMedian
walkingSpeedMedian
likelihoodNotOK
likelihoodOK
numDaysWithDataLast30Days
numDaysWithDataLast7Days
numValidBouts28Days
numValidBouts7Days
rawSteadiness
centroidSlopeHeightNormDoubleSupportPercentageCadence
centroidSlopeHeightNormWalkingSpeedStepLength
l2DispersionHeightNormDoubleSupportPercentageCadence
l2DispersionHeightNormWalkingSpeedStepLength
allBoutsCycleTimeEntropy5thTo95th
allBoutsCycleTimeEntropyMean
allBoutsCycleTimePoincareSd1Mean
allBoutsCycleTimePoincareSd1P5
allBoutsCycleTimePoincareSd1P95
allBoutsCycleTimePoincareSd2Mean
allBoutsCycleTimePoincareSd2P5
allBoutsCycleTimePoincareSd2P95
allBoutsMinGaitMetrics21CycleTimeEntropy5thTo95thLog
allBoutsMinGaitMetrics21CycleTimeEntropyMeanLog
allBoutsMinGaitMetrics21CycleTimeEntropyP5Log
allBoutsMinGaitMetrics21CycleTimePoincareSd1P5Log
allBoutsMinGaitMetrics21CycleTimePoincareSd2P5Log
allBoutsMinGaitMetrics21StepLengthEntropyMeanLog
allBoutsMinGaitMetrics21StepLengthPoincareSd1P5Log
allBoutsMinGaitMetrics21StepLengthPoincareSd1P95Log
allBoutsMinGaitMetrics21StepLengthPoincareSd2MeanLog
allBoutsMinGaitMetrics21StepLengthPoincareSd2P5Log
allBoutsStepLengthEntropy5thTo95th
allBoutsStepLengthEntropyMean
allBoutsStepLengthPoincareSd1Mean
allBoutsStepLengthPoincareSd1P5
allBoutsStepLengthPoincareSd1P95
allBoutsStepLengthPoincareSd2Mean
allBoutsStepLengthPoincareSd2P5
allBoutsStepLengthPoincareSd2P95
begin
strideLength
currentPace
falseStepDetectorState
falseStepsSuppressed
isOdometerDistance
isOdometerPace
sourceId
bobbiness
bufferAvgSampleRateHz
concavityDeltaDeg
deltaInertialZVel
horizontalDisplacement
impulseDurationSec
likelihoodRatio
peakiness
thetaPitchFaceDeg
thetaRollFaceDeg
timeSinceLastStepSec
kValue
peakHalfWidth
peakMagnitude
peakTime
tapAcceptStatus
tapCounter
clippedPeakType
direction
peakValue
strideDirection
tapDetectStatus
widthCalculationMethod
auxiliaryIosTimeUncertainty
sensorTimeBeforeAlignment
sentCftime
sourceIosTimeUncertainty
sourceReceiveCftime
sourceReceiveSensorTimestamp
angularVelocityConstraintRps
consumedAuxTimestamp
dthetaNormRad
inBTZ
listenerPitch
listenerRoll
listenerYaw
machAbsTimestamp
receivedAuxTimestamp
touchDetected
accelBias
accelBiasCov
cameraImageResolutionHeight
cameraImageResolutionWidth
cameraIntrinsics
cameraPose
gyroBias
gyroBiasCov
machContinuousOriginTimestamp
orientationCov
originTimestamp
positionCov
trackingState
velocityCov
currentTimestamp
latestInertialTimestamp
latestInertialTimestampMeta
positionX
positionY
positionZ
predictionComputeTimeMeta
predictionTimeMeta
propagationTimeMeta
rotationMatrixElement
hasGps
heartRateConfidence
basebandHint
gpsHint
vehicularData
wifiHint
isDeviceVibrating
compassBias
estimatedBiasUncertainty
estimatedHeading
lslGlobalToDeviceFrameRotationMatrix
lslHeadingAccuracy
lslHeadingConfidence
altitudeOfLocalizedPoseInEcefCoordinate
covariance
horizontalAccuracyOfLocalizedPoseInEcefCoordinate
latitudeOfLocalizedPoseInEcefCoordinate
longitudeOfLocalizedPoseInEcefCoordinate
transformMatrixFromCameraToEcefCoordinate
deltaHeading
gravityZ
meanRotRate
isInitFinished
dataRate
isInterpolated
isMissingSamples
isWalkingFiltered
isWalkingRaw
maxSampleDeltaInSecond
pedEnergyPlane
pedEnergyZ
pedEnergyZByPlane
pedEnergyZPeak
reversedTimestampCounts
thetaYawFaceDeg
appliedBoutMetricCorrections
errorStatus
eventResult
fusionSuccess
hkEndTime
hkStartTime
isHistoricalCompute
modelBalanceFeatures
modelContinuousWalkingFeatures
modelContinuousWalkingResult
modelGaitBaselineFeatures
modelGaitBaselineResult
modelTemporalDispersionFeatures
modelTemporalDispersionResult
modelTemporalEntropyFeatures
modelTemporalEntropyResult
nextClassificationTime
steadinessScore
steadinessScoreIsValid
unadjustedScore
date
isForcedOnWristEnabled
isOnCharger
isWristDetectionEnabled
onWrist
onWristConfidence
onWristSensor
wrist
entryId
entries
restingHeartRate
walkingHeartRateAverage
workoutActivityType
1.2.11
CMMsl.Writer
setFlushTimeoutSeconds_block_invoke
MSLWriter.cpp
(fFd == -1) && ("Writer::setFlushTimeout() must be called before ::open().")
Cannot open Msl file
Cannot seek to end of Msl file
Cannot seek to start of Msl file
Short signature in Msl file
Bad signature in Msl file
Cannot create dispatch_io for Msl file
zstream status? Msl %d
v24@?0B8^{dispatch_data_s=}12i20
Msl dispatch io write error %s
_%Y-%m-%d_%H:%M:%S
fValid
On call to writeItem client should check if the logger was opened
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Framework/MotionSensorLogging/MSLWriterManager.cpp
writeItem
UnhandledSession
kRadioAccessTechnologyUMTS
kRadioAccessTechnologyeHRPD
kRadioAccessTechnologyNR
kRadioAccessTechnologyUnknown
kRadioAccessTechnologyWifi
void Emergency::CLEmergencySessionReport::setPositionSource(const CLDaemonLocation &)
#Warning Valid location with unknown or obsolete type
v8@?0
cohortToNameMap_watchOS.plist
CLDaemonCore
CLDaemonCore::CLDaemonCore()
#Warning multiple instances created - last instance %p
CLSilo.Version
CLSilo.CohortToNameMapFile
CLSilo.CohortToNameMap
CLSilo.NameToCohortMap
CohortToNameMapFile
CohortToNameMap
NameToCohortMap
CLServiceVendor.RecordingTriggersFromByTo
/intersilo_recording
CLServiceVendor.RecordingPathBase
HeartAttackStackshot
IsInternalInstall
IsLocationServicesEnabled
AutoShutdownDelay
ObsoleteDataCheckDelay
CLTimeZoneManager
CLPredictedWalkDistanceServiceWatch
CLSmootherMonitor
EnableMultiClientStreamingServer
CLLocationMulticlientStreamer
CLSensorMonitor
CLInternalService
CLFenceHandoffConnectionManager
%s:%d: assertion failure in %s
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLDaemonCore.mm
startInitialize
static void CLDaemonCore::profileObserverCallback(CFRunLoopObserverRef, CFRunLoopActivity, void *)
#Warning OBSERVER: TIMEOUT: %s => %s RunLoop is really busy time(%.8lf) tdiff(%.8lf)
void CLDaemonCore::installProfileObserver(CFStringRef)
Can't read mach_timebase_info = %{public}d
sTimebaseInfo.denom %d sTimebaseInfo.numer %d
startRun
RunLoopProfileObserver
void CLDaemonCore::startRun(os_activity_scope_state_t)
OBSERVER: ProfileObserver = %d
starting idle shutdown timer of %d seconds
(fMutex).__assertNotOwned()
startCleanup
void CLDaemonCore::startCleanup()
Simulator will skip cleanup
void CLDaemonCore::onShutdownTimer()
linger requested - not shutting down
void CLDaemonCore::scheduleShutdown(int)
no more clients, %d second(s) to auto-shutdown
ObsoleteDataDeleted
void CLDaemonCore::deleteObsoleteData(bool)
Obsolete data has already been deleted; not deleting again
Deleting obsolete data
Obsolete data deleted in %.2f seconds
com.apple.locationd.Legacy
Generic_deprecated
Core
CLDaemonCore::onStatusNotification
Notifier
/System/Library/LaunchDaemons/com.apple.locationd.plist
LaunchEvents
void launchServicesWithLaunchEvents()
no LaunchEvents found
com.apple.xpc.activity
no xpc activities registered
 kCFRunLoopEntry
 kCFRunLoopBeforeTimers
 kCFRunLoopBeforeSources
 kCFRunLoopBeforeWaiting
 kCFRunLoopAfterWaiting
 kCFRunLoopExit
PreviousLocation
WifiLocationNearby
LocationEnabled
cells.plist
cells-local.plist
h-cells.plist
h-wifis.plist
clients-b.plist
c-trained.plist
cells.db
cells.db-journal
wifis.db
wifis.db-journal
cells-local.db
cells-local.db-journal
h-locations.db
h-locations.db-journal
h-cells.db
h-cells.db-journal
h-wifis.db
h-wifis.db-journal
compass.db
compass.db-journal
history.db
history.db-journal
glgps_nvs.bin
void _deleteObsoleteData()
#Notice Deleting %{public}s if present
Deleting obsolete wifi subdirectory
void _deleteObsoleteData()_block_invoke
Deleting %s
Could not delete file %{public}s
SBLastSystemVersion
Motion
int main(int, const char **)
locationd does not take any command-line arguments. Use CFPreferences instead.
CLSettingsManager
CLDaemonSettingsManager
CLGyroCalibrationDatabaseLocationd
CLGeomagneticModelProviderLocationd
CLCompassDatabaseLocationd
Setting location services to %d
01:11:46
LastSystemVersion
EnableLockTimeDebugging
Lock time debugging is enabled
/cache_encryptedA.db
LowWaterLoopProtectionInterval
main.low-water-loop-protection
locationd.log
com.apple.locationd.legacy-logging-dummy-settings
BinaryLogEnable
LogGyro
GyroCalibration
GyroMultiCalibration
virtual bool CLGyroCalibrationDatabaseLocalMultiRun::insert(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &, float, CFAbsoluteTime)
CLGyroCalibrationDatabaseLocalMultiRun insert x,%f,y,%f,z,%f,temperature,%f
fBuilding,%d
virtual bool CLGyroCalibrationDatabaseLocalMultiRun::wipeDatabase()
Wipe database during a build.
DELETE FROM GyroMultiCalibration
virtual void CLGyroCalibrationDatabaseLocalMultiRun::startFactoryGYTT()
CLGyroCalibrationDatabaseLocalMultiRun startFactoryGYTT
virtual bool CLGyroCalibrationDatabaseLocalMultiRun::getLastMiniCalibration(CFAbsoluteTime &) const
CLGyroCalibrationDatabaseLocalMultiRun getLastMiniCalibration
fFit.kind == kCLMotionTypeGyroBiasFitKindLinear
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/SensorCalibration/CLGyroCalibrationDatabaseLocalMultiRun.mm
logFit
void CLGyroCalibrationDatabaseLocalMultiRun::logFit() const
GyroBiasFit: slope,%f,%f,%f,intercept,%f,%f,%f,seconds,%f
com.apple.CoreMotion.GyroCalibration.PostCal
com.apple.CoreMotion.GyroCalibration.PreCal
com.apple.CoreMotion.GyroCalibration.FactoryCal
com.apple.CoreMotion.GyroCalibration.UnknownCal
Intercept.X
Intercept.Y
Intercept.Z
Slope.X
Slope.Y
Slope.Z
TimeSinceLastCal
!fBuilding
initializeWithFactoryData
SELECT MAX(Round) FROM GyroMultiCalibration
SELECT Round, Temperature, BiasX, BiasY, BiasZ FROM GyroMultiCalibration WHERE Round = ? OR (Round > ? AND Round <= ?)
void CLGyroCalibrationDatabaseLocalMultiRun::loadFromDatabase()
SQL error: %{public}s
DELETE FROM GyroMultiCalibration WHERE Round <= ? AND Round <> ?
Temperature
BiasX
BiasY
BiasZ
fPendingPoints.empty() || fPoints.empty() || fPoints.rbegin()->round < fPendingPoints.begin()->round
static void CLGyroCalibrationDatabaseLocalMultiRun::dropTableIfPresent(CLSqliteDatabase &)
Dropping GyroMultiCalibration.
fPoints.empty() || fPoints.rbegin()->round >= kFactoryRound
virtual void CLGyroCalibrationDatabaseLocalMultiRun::beginRun(bool)
fNextRound,%d,fIsUrgentCal,%d
fBuilding
abortRun
endRun
virtual void CLGyroCalibrationDatabaseLocalMultiRun::endRun()
nonFactoryRoundCount,%d,kRoundLimit,%d,roundToRemove,%d,fIsUrgentCal,%d
Ending UrgentCal run, double entering this round
Double entry: nonFactoryRoundCount,%d,kRoundLimit,%d,roundToRemove,%d,secondRoundNum,%d
!v.empty()
getMedians
B24@?0r^{?=fff}8r^{?=fff}16
static bool CLGyroCalibrationDatabaseLocalMultiRun::computeFullBias(const std::vector<BiasTemperatureRound>::const_iterator, const std::vector<BiasTemperatureRound>::const_iterator, const std::deque<BiasTemperatureRound> *, CLMotionTypeGyroBiasFit &)
ComputeFullBias: x,%f,y,%f,z,%f
std::is_sorted(rounds.begin(), rounds.end())
computeIntercept
static bool CLGyroCalibrationDatabaseLocalMultiRun::computeIntercept(const std::vector<BiasTemperatureRound>::const_iterator, const std::vector<BiasTemperatureRound>::const_iterator, const std::deque<BiasTemperatureRound> *, CLMotionTypeGyroBiasFit &)
ComputeIntercept: x,%f,y,%f,z,%f
virtual void CLGyroCalibrationDatabaseLocalMultiRun::startCalibration(bool)
Starting gyro calibration, user initiated, %d
!fDeviceMotionDispatcher
startCalibration
virtual void CLGyroCalibrationDatabaseLocalMultiRun::teardown()
Stopped gyro calibration
Gyro
%s; client %d has deregistered, not notifying %s
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
%{public}s; unknown client %{public}d
com.apple.locationd.Support
Support
%s; already shutdown; not listing clients
%s; clients, id: %d, notification: %d
CLNearbydInterfaceManagerSilo
com.apple.private.alloy.regulatorysync
static std::vector<std::string> CLLegacyFileManager::listFilesWithExt(const std::string &, const std::string &)
Unable to list files at path: %{public}s, error, %{public}@
false
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/ClientManagement/CLInternalService.mm
-[CLIntersiloDelegate setValid:]
CLInternalServiceSilo
-[CLInternalService beginService]
#Spi, beginService
CLGetGroundAltitudeDistThres
com.apple.locationd.synchronous
#Spi , Listener?, %{public}@
-[CLInternalService endService]
#Spi, endService
-[CLInternalService listener:shouldAcceptNewConnection:]_block_invoke
#Spi, Connection interrupted for process %d
#Spi, Connection invalidated for process %d
-[CLInternalService listener:shouldAcceptNewConnection:]
#Spi, New connection by process id %d resumed
MIGResponseSilo
com.apple.locationd.status
-[CLInternalService getAppsUsingLocationWithReplyBlock:]
#Spi, connecting process isn't entitled, they shall not pass
com.apple.locationd.internalservice.errorDomain
-[CLInternalService getTechnologiesInUseWithReplyBlock:]
-[CLInternalService getGnssBandsInUseWithReplyBlock:]
com.apple.locationd.defaults_access
-[CLInternalService setLocationDefaultForKey:andValue:replyBlock:]
#Spi, Setting default %@ from %s
-[CLInternalService getLocationDefaultForKey:replyBlock:]
#Spi, Getting default %@ for %s
com.apple.locationd.time_zone
-[CLInternalService timeZoneForLocation:replyBlock:]
com.apple.locationd.authorizeapplications
-[CLInternalService setAuthorizationStatus:withCorrectiveCompensation:forBundleID:orBundlePath:replyBlock:]
#Spi, Must provide a bundle identifier or bundle path for which to set location authorization status
-[CLInternalService resetAllClientsWithReplyBlock:]
-[CLInternalService getArchivedAuthorizationDecisionsWithReplyBlock:]
-[CLInternalService applyArchivedAuthorizationDecisions:withConfirmationToken:replyBlock:]
com.apple.CoreLocation.PrivateMode
-[CLInternalService setPrivateMode:replyBlock:]
-[CLInternalService getPrivateMode:]
-[CLInternalService setLocationServicesEnabled:replyBlock:]
#Spi, %{public}s is setting location services to %{public}s
-[CLInternalService setAuthorizationPromptMapDisplayEnabled:replyBlock:]
#Spi, %{public}s is setting authorization prompt map display to %{public}s
-[CLInternalService setGestureServiceEnabled:replyBlock:]
#Spi, %s is setting ear gesture service to %s
-[CLInternalService setTemporaryAuthorizationStatusForBundleId:orBundlePath:statusData:replyBlock:]
-[CLInternalService getTemporaryAuthorizationStatusForBundleId:orBundlePath:replyBlock:]
com.apple.locationd.integritycheck
-[CLInternalService modifyOrSetAuthorizationTime:forBundleID:orBundlePath:replyBlock:]
-[CLInternalService triggerExpiredAuthorizationPurgeWithReplyBlock:]
-[CLInternalService pingDaemonWithReplyBlock:]
#Spi, Pinged by external process %s
-[CLInternalService getAuthorizationStatusForBundleID:orBundlePath:replyBlock:]
#Spi, Authorization status for %s is %s
-[CLInternalService getIncidentalUseModeForBundleID:orBundlePath:replyBlock:]_block_invoke
#UsageWin, setting incidentalUseMode to: %d
-[CLInternalService registerCircularInterestZoneWithId:latitude:longitude:radius:serviceMaskOperator:provenanceType:forBundleId:orBundlePath:replyBlock:]
#Spi registerCircularInterestZone, Must provide a bundle identifier or bundle path
-[CLInternalService registerPhenolicInterestZoneWithId:phenolicLocation:serviceMaskOperator:provenanceType:forBundleId:orBundlePath:replyBlock:]
#Spi registerPhenolicInterestZone, Must provide a bundle identifier or bundle path
-[CLInternalService setRelevance:forInterestZoneWithId:registeredForBundleId:orBundlePath:replyBlock:]
#Spi setRelevanceForInterestZone, Must provide a bundle identifier or bundle path
-[CLInternalService deleteInterestZoneWithId:registeredForBundleId:orBundlePath:replyBlock:]
#Spi deleteInterestZoneWithId, Must provide a bundle identifier or bundle path
-[CLInternalService performMigrationWithReplyBlock:]
-[CLInternalService shutdownDaemonWithReplyBlock:]
#Spi, Daemon shutdown requested by %s
-[CLInternalService displayStatisticsWithReplyBlock:]
#Spi, Daemon stats requested by %s
-[CLInternalService dumpLogsWithDescription:replyBlock:]
#Spi, Log dump requested by %s: %@
-[CLInternalService copyLastLogWithReplyBlock:]
#Spi, %s requested to copy locationd's last logs to crash reporter
-[CLInternalService getMonitoredRegionsForBundleID:orBundlePath:replyBlock:]
#Spi, #warning Couldn't get fences for client key %s
kCLConnectionMessageBeaconRegionKey
-[CLInternalService getLocationForBundleID:orBundlePath:dynamicAccuracyReductionEnabled:allowsAlteredAccessoryLocations:replyBlock:]
#Warning #Spi, GetLocation rejected for '%s(%d)': no way to establish effective authorization
#Spi, GetLocation rejected for '%s': insufficient effective authorization
v192@?0@"NSError"8{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16
-[CLInternalService getStatusBarIconState:]
Unexpected iconState: %d
-[CLInternalService setStatusBarIconEnabledForEntityClass:enabled:replyBlock:]
#Spi, %s is setting the status bar icon enabled state for %u to %d
-[CLInternalService getStatusBarIconEnabledForEntityClass:replyBlock:]
#Spi, %s retrieved the status bar icon enabled state for %u
com.apple.locationd.route_hint
-[CLInternalService setMapMatchingRouteHint:routingType:stepType:replyBlock:]
#Spi,RouteHints,setMapMatchingRouteHint,received,%{public}lu,routeType,%{public}d,stepType,%{public}d,source,%{public}s
com.apple.locationd.accessory_location
-[CLInternalService getAccessoryTypeBitSetWithReplyBlock:]
+[CLInternalService getEffectiveClientName:bundlePath:name:]
#Spi, requires entitlement '%{public}@' with bundle identifier '%{public}@' or bundle path '%{public}@'
#Spi, Called for bundle identifier %s
#Spi, Called for bundle path %s
com.apple.locationd.pipelined_diagnostic
-[CLInternalService getPipelinedCacheWithReply:]
/var/mobile/Library/Logs/pipelined
/tiles
/var/root/Library/Caches/com.apple.pipelined
/var/root/Library/Caches/locationd/indoor_tiles
getPipelinedCacheWithReply cancelling previous delete due to new request
_analyticsusers
getPipelinedCacheWithReply FAILED to find root uid and _analyticsusers gid
getPipelinedCacheWithReply destination root path exists, deleting directory now...
getPipelinedCacheWithReply removal of %@ FAILED with error %@
getPipelinedCacheWithReply created destination root path %@
getPipelinedCacheWithReply successfully changed owner of %@ to TTR accessible
getPipelinedCacheWithReply FAILED to change owner of %@ to TTR accessible
getPipelinedCacheWithReply FAILED to create destination root path %@ with error %@
getPipelinedCacheWithReply successfully copied %@ to %@
getPipelinedCacheWithReply FAILED to copy %@ to %@. Check PROTECTION CLASS of the file and device protection state.
getPipelinedCacheWithReply deleting %@ in %llu seconds
-[CLInternalService getPipelinedCacheWithReply:]_block_invoke
getPipelinedCacheWithReply %@ deleted
-[CLInternalService setTemporaryAuthorizationGranted:forBundleID:orBundlePath:orAuditToken:byLocationButton:voiceInteractionEnabled:replyBlock:]
#Spi, Must provide a bundle identifier or bundle path if setting temporay authorization not by LocationButton
-[CLInternalService getActivitiesWithReplyBlock:]
#Spi, #warning _CLDaemonGetActivityAlarms called without support for activity alarms
-[CLInternalService setAuthorizationStatusByType:withCorrectiveCompensation:andZoneIdentifier:forBundleID:orBundlePath:replyBlock:]
-[CLInternalService updateCorrectiveCompensationChoiceForOutstandingPrompt:replyBlock:]
-[CLInternalService setIncidentalUseMode:forBundleID:orBundlePath:replyBlock:]
#Spi, Must provide a bundle identifier or bundle path for which to set incidental use mode
-[CLInternalService setBackgroundIndicatorEnabled:forBundleID:orBundlePath:replyBlock:]
#Spi, both bundle-id and bundle-identifier are either zero-length or nil
CLWeatherService
-[CLInternalService getMicroLocationInternalVersionWithReplyBlock:]
-[CLInternalService getZaxisStatsWithReplyBlock:]
CurrentMCT
GNSSAvailabilityPredictionTime
GNSSAvailabilityPredictionState
GNSSAvailabilityPredictionProbability
ALSDecisionTreeOutputTime
ALSDecisionTreeOutput
LastAltitudeUpdateFromBaro
CurrentBaroAltitude
CurrentBaroAltitudeUnc
Undulation
CalibratedAltitudeFromRefPressureAndDEM
CalibratedAltitudeFromDEMOnly
CalibratedAltitudeUpdateTime
CurrentWiFiAltitudeTimestamp
CurrentWiFiAltitude
CurrentWiFiAltitudeUnc
SensorReplayMode
CLGyroCalibrationDatabaseLocal::CLGyroCalibrationDatabaseLocal(id<CLIntersiloUniverse>)
Removing outliers from database.
virtual bool CLGyroCalibrationDatabaseLocal::insert(const CLMotionTypeRotationRate &, const CLMotionTypeVector3 &, float, CFAbsoluteTime)
Insert into uncached database.
virtual bool CLGyroCalibrationDatabaseLocal::registerForNotificationInternal(const CLGyroCalibrationDatabase_Type::Notification &)
Client registered, caching database
virtual bool CLGyroCalibrationDatabaseLocal::unregisterForNotificationInternal(const CLGyroCalibrationDatabase_Type::Notification &)
No more clients, flushing cache to database
Database should be cached
<=? ORDER BY 
void CLGyroCalibrationDatabaseLocal::insert(const CLMotionTypeRotationRate &, float)
CLGyroCalibrationDatabaseLocal insert x,%{public}f,y,%{public}f,z,%{public}f,temperature,%{public}f
void CLGyroCalibrationDatabaseLocal::cacheEntriesBetweenTemperatures(float, float, CLGyroCalibrationCache &)
void CLGyroCalibrationDatabaseLocal::cacheAllEntries(CLGyroCalibrationCache &)
Reading database into non-empty cache.
void CLGyroCalibrationDatabaseLocal::writeCacheToDatabase()
Attempting to write zero entries to Gyro database.
EnableGyroMultiRunCalibration
static CLGyroCalibrationDatabase *CLGyroCalibrationDatabase::createInUniverse(id<CLIntersiloUniverse>)_block_invoke
Creating GyroCalibrationDatabaseLocal with isNonUI,%{public}u, enableGyroNonlinearCalibration,%{public}u, enableGyroLinearCalibration,%{public}u,enableGyroMultiRunCalibration,%{public}u, gyroNonlinearity,%{public}u, gyroMultiRunCalibration,%{public}u
HardwareType
FallNotifierAvailable
RecordingType
MeanMaxMets
-[CLWorkoutRecording initWithDelegate:universe:settings:]
Offsetting time by %{private}f
-[CLWorkoutRecording start:recentLocation:]
Writing files to %@.
recording
Unable to create writer.
-[CLWorkoutRecording setWorkingDirectory:]
Recording working directory already exists. This should never happen.
Unable to create recording working directory, error: %{public}@
!_workingDirectory
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Utilities/CLWorkoutRecording.mm
-[CLWorkoutRecording recordingURLs]
Adding file to be sent: %@
!_accelerometerDispatcher
-[CLWorkoutRecording setupListeners]
!_deviceMotionDispatcher
!_heartRateObserverClient
!_odometerObserverClient
!_watchOrientationObserverClient
!_natalimetryClient
v24@?0@"NSString"8@16
ActivateALS
!_magnetometerDispatcher
-[CLWorkoutRecording teardownListeners]
Tearing down listeners.
Recording accelerometer stopped.
Recording rotation rate stopped.
Recording magnetometer stopped.
Recording pressure stopped.
Recording fast accelerometer stopped.
-[CLWorkoutRecording makeSafeAbsoluteElevation:]
Offsetting elevation by %{private}f
SensorRecordingActiveAndEnabled
ContainsFastAccelData
PredictedWorkoutType
PredictedWorkoutLocationType
WorkoutActivityType
WorkoutActivityLocationType
InternalInstall
-[CLWorkoutRecording onMotionStateMediatorNotification:data:]
Received: WorkoutEventType: %ld WorkoutType: %ld Location: %ld
CoarseLatitude2
CoarseLongitude2
-[CLWorkoutRecording retrieveCachedCompassCalibration]
ContainsValidCompassCalibration
-[CLWorkoutRecording onWifiScanNotification:data:]_block_invoke
WiFi scan entry,id,%d,rssi,%d,timestamp,%f,isMoving,%{private}d
-[CLWorkoutRecording setupHealthKitQueries]_block_invoke
Failed to query HealthKit for: %{public}@, error: %{public}@
Found HK Sample: %{private}@
WorkoutActivityTypeHK
Wiring bug: received unrequested sample type from HK.
Unable to find HealthKit results for: %{public}@
v48@?0@"HKAnchoredObjectQuery"8@"NSArray"16@"NSArray"24@"HKQueryAnchor"32@"NSError"40
-[CLWorkoutRecording writeStrideCalBins]
RawSpeedToKValue entry,begin,%f,end,%f,kValue,%f,state,%d
StepCadenceToStrideLength entry,begin,%f,end,%f,strideLength,%f,state,%d
-[CLWorkoutRecording deleteWorkingDirectory]
Unable to delete recording working directory, error: %{public}@
WorkoutRecorderElevationOffsetDisable
WorkoutRecorderListenersBodyMetricsDisable
WorkoutRecorderListenersWatchOrientationDisable
WorkoutRecorderListenersWatchOnWristStatusDisable
WorkoutRecorderListenersHealthKitInfoDisable
WorkoutRecorderWifiScanDisable
WorkoutRecorderPressureDisable
kWorkoutRecorderStrideCalBinsDisable
kWorkoutRecorderALSDisable
kWorkoutRecorderLatLongDisable
kWorkoutRecorderMeanMaxMetsDisable
WorkoutRecorderTimeIntervalOffsetMax
WorkoutRecorderTimeIntervalOffsetMin
WorkoutRecorder
WorkoutRecorderRecordingFileSizeMaxBytes
WorkoutRecorderRecordingFileSizeMaxSeconds
WorkoutRecorderRecordingFileCountMax
WorkoutRecorderListenersAccelIntervalSeconds
WorkoutRecorderListenersRotationRateIntervalSeconds
WorkoutRecorderListenersOdometerDisable
WorkoutRecorderListenersWorkoutEventsDisable
kWorkoutRecorderListenersMagIntervalSeconds
virtual void CLMotionNotifier::SiloDispatcher<CLMagnetometer::Sample>::dispatchData(int, const void *, size_t) [T = CLMagnetometer::Sample]
GyroNonlinearTargetExpirationAge
GyroNonlinearMaxExpirationAge
GyroNonlinearFactoryDataAge
GyroNonlinearFlushTimeout
GyroNonlinearFirstPruneTimeout
GyroNonlinearPruneTimeout
LogGyroNonFactoryCalOnStartup
EnableGyroFitRMSError
GyroPointCalibration
DELETE FROM GyroPointCalibration
virtual void CLGyroCalibrationDatabaseLocalShared::startFactoryGYTT()
Start factory GYTT
fDb.tableExists("GyroPointCalibration")
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/SensorCalibration/CLGyroCalibrationDatabaseLocalShared.mm
cacheFactoryIfMissing
fPendingSamples.empty()
void CLGyroCalibrationDatabaseLocalShared::persistFactoryPointsInDatabase(std::vector<Sample> &)
flushPendingError: %{public}s
Factory data persisted in gyro database, %zu samples added.
SELECT Id, Timestamp, Temperature, BiasX, BiasY, BiasZ FROM GyroPointCalibration WHERE Active = ?
void CLGyroCalibrationDatabaseLocalShared::readFactoryDataFromDatabase(std::vector<CLGyroBiasFitter::Sample> &)
%f,%f,%f,%f
Point gyro database load, SQL error: %{public}s
void CLGyroCalibrationDatabaseLocalShared::loadFromDatabase()
void CLGyroCalibrationDatabaseLocalShared::flushPendingSamples()
Point gyro database flushed, %zu samples added.
duration >= 0.
thinPendingSamples
void CLGyroCalibrationDatabaseLocalShared::thinPendingSamples(CFTimeInterval)
Point gyro pending samples thinned.  %zu samples reduced to %zu.
Thinned
Inserted
GyroNonlinearCalibration
ALTER TABLE GyroNonlinearCalibration
TemperatureSpan
void CLGyroCalibrationDatabaseLocalShared::prune()
Point gyro database prune, deleted %zu samples, %zu remain.
 SET Active = 
DELETE FROM GyroPointCalibration WHERE Id = ?
void CLGyroCalibrationDatabaseLocalShared::logGyroNonFactoryCalIfNecessary()
Failed to log gyro non factory cal from db because the temperature range is either unintialized or invalid.
Failed to log gyro non factory cal because the number of samples (%zu) exceeds the max limit (%zu).
MaxAgeOut
Overpopulated
NormalAgeOut
-[CLRecordingTriggerBase initWithDelegate:universe:andSettings:]
Initializing CLRecordingTriggerBase instance
-[CLRecordingTriggerBase startRecording]
Unable to start recording, could not start recording.
!_powerAssertion->isPowerAssertionTaken()
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Utilities/CLRecordingTriggerBase.mm
-[CLRecordingTriggerBase scheduleStopWithHandler:]
Deferred stop already created and scheduled.
Unable to create deferred stop timer, not currently recording.
Scheduling stop for %f seconds in the future.
-[CLRecordingTriggerBase stopRecordingShouldPublish:]
Stopping Recording
Publishing Recording
-[CLWorkoutRecorderTrigger initWithDelegate:andUniverse:]
Initializing CLWorkoutRecorderTrigger instance
-[CLWorkoutRecorderTrigger setupListeners]
Setting up workout recorder trigger listener.
-[CLWorkoutRecorderTrigger teardownListeners]
Tearing down workout recorder trigger listener.
-[CLWorkoutRecorderTrigger onMotionStateMediatorNotification:data:]
Received an AP escalation.
Received an AP de-escalation.
Canceling deferred stop.
com.apple.locationd.CLWorkoutRecorderPublisher
CLWorkoutRecorderPublisherSubjectUUID
CLWorkoutRecorderPublisherSubjectToken
WorkoutRecording
CLWorkoutRecorderPublishedCount
WorkoutRecorderRateLimitingSampling
WorkoutRecorderIntervalCount
WorkoutRecorderTriggerDeferredStopDurationSeconds
WorkoutRecorderPublisherMaxPerUUID
WorkoutRecorderRateLimitingDisable
WorkoutRecorderRateLimitingDisableInternalInstallBypass
WorkoutRecorderSamplingInterval
WorkoutRecorderNumSamplesPerInterval
WorkoutRecorderListenersHeartRateDisable
CLWorkoutRecorderSilo
+[CLWorkoutRecorder isSupported]
isSupported Flags - disable: %d, alwaysOn: %d, iha: %d
-[CLWorkoutRecorder beginService]
Beginning service.
-[CLWorkoutRecorder endService]
Ending service.
-[CLWorkoutRecorder canStartRecording:settings:publisher:]
Unable to start recording, no longer allowed.
Unable to start recording, no working directory.
Unable to start recording, not enough free space in working directory.
Unable to start recording, already recording.
Unable to start recording, no publisher.
Unable to start recording, publisher is not ready to publish.
Unable to start recording, session already being captured.
Not recording, rate limit reached.
Can Start Recording
-[CLWorkoutRecorder didPublishRecording:settings:publisher:]
Deferring publishing of recording until device is unlocked.
Deferring publishing of recording until publisher is created.
Unable to publish recording, no longer allowed.
-[CLWorkoutRecorder acquireTokenWithSettings:publisher:]
Unable to aquire token, no publisher.
Unable to aquire token. Filtered out due to server side sampling rate.
Unable to aquire token due to system side sampling rate.
/WorkoutRecorder
-[CLWorkoutRecorder createWorkingDirectory]
Unable to delete working directory, error: %{public}@
Unable to create working directory, path exists as a file, path: %{public}@
Unable to create working directory, error: %{public}@
-[CLWorkoutRecorder workingDirectoryHasSufficientFreeSpace]
Unable to get free space of working directory. Assuming no free space, path: %{public}@, error: %{public}@
Working directory free space: %{public}@ bytes.
-[CLWorkoutRecorder handleResponse:]
Received configuration: %{private}@
WorkoutRecorderDisable
WorkoutRecorderAlwaysOn
WorkoutRecorderWorkingDirectory
WorkoutRecorderWorkingDirectoryMinSpace
CLPrivacyManagerSilo
DisableCLPrivacyManager
CLPrivacyManager.B
CLPrivacyManager.C
CLPrivacyManager.D
ResetLocationPrivacy
LocationServicesStatus
v16@?0@"NSObject<OS_xpc_object>"8
CLPrivacyManager
[a[0] isEqualToString:@"CLPrivacyManager"]
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Core/PrivacyManager/CLPrivacyManager.mm
-[CLPrivacyManager onActivity:withIdentifier:]
vacuumEncryptionClass
KeepAllSensorCalibrationRoundsInDb
LogGyroFactoryCalOnStartup
virtual NSString *CLGyroCalibrationDatabaseLocalBase::dumpDatabase(NSString *)
Dumping gyro calibration database
%@-%@.db
GyroCalDbFile
static const CLSqliteDatabase::SqliteProperties CLGyroCalibrationDatabaseLocalBase::getSqlProperties()
No gyroCal database file set in preferences. Using the default database.
Using gyroCal database file: %s.
ClusterCompassCalibration
CompassDatabaseMaximumMagnitudeDifference
CompassDatabaseMaximumInclinationDifference
CompassBiasClusteringEnabled
CompassBiasClusteringRadius
CompassBiasTemporalVarianceCheck
CompassCachedEntryLifetime
void CLCompassDatabaseController::init()
Max magnitude difference (%f), Max inclination difference (%f), CompassBiasClusteringEnabled (%d), CompassBiasTemporalVarianceCheck (%d)
CompassDatabaseDaemonClearBiasTimer
bool CLCompassDatabaseController::lookupBias(const CLMotionTypeMagneticField &, const CLMotionTypeAcceleration &, CFAbsoluteTime, CLMotionTypeVector3 &, int &, bool &)
CompassBiasDB, begin lookups
Compass recently calibrated.  Using cached bias: (%f, %f, %f) with level: (%d).
search found: bestfit (%+.3f/%+.3f/%+.3f) bias (%+.3f/%+.3f/%+.3f) level (%d) using magneticField (%+.3f/%+.3f/%+.3f) acceleration (%+.3f/%+.3f/%+.3f) from %d entries. No: %llu. IsCluster: %d, 2D Check,%d
search failure: no result, saw bestfit (%+.3f/%+.3f/%+.3f) bias (%+.3f/%+.3f/%+.3f) level (%d) using magneticField (%+.3f/%+.3f/%+.3f) acceleration (%+.3f/%+.3f/%+.3f) from %d entries
search complete failure: no results from %d entries
void CLCompassDatabaseController::setBias(CLMotionTypeMagneticField, CLMotionTypeVector3, int, float, float)
CompassBiasDB, setBias has novel information, countdown to clustering: %d
CompassBiasDB, setBias is not novel.
NSString *CLCompassDatabaseController::dumpDatabase(NSString *)
Dumping compass database
void CLCompassDatabaseController::clusterBiasEntries()
CompassBiasDB, clusteralgo, started
CompassBiasDB, clusteralgo, finished, numbers of clusters found, %zu,  %d
bool CLCompassDatabaseController::temporalBiasVarianceCheckPassed(CFAbsoluteTime, bool, const CLCompassDatabaseRecord &)
search complete failure: too much variation in bias within a short time period, mean (%.3f) max (%.3f)
bool CLCompassDatabaseController::lookupBiasByCluster(const CLMotionTypeMagneticField &, const CLMotionTypeAcceleration &, bool, CLCompassDatabaseRecord &, float &, unsigned int &, sqlite3_int64 &)
CompassBiasDB, lookup, rowid, %llu, bias, %.3f, %.3f, %.3f, mag, %.3f, %.3f, incl, %.3f, %.3f, magDiff, %.3f, inclDiff, %.3f, score, %.3f, betterMatch, %d
bool CLCompassDatabaseController::lookupBiasIndividually(const CLMotionTypeMagneticField &, const CLMotionTypeAcceleration &, bool, CLCompassDatabaseRecord &, float &, unsigned int &, sqlite3_int64 &)
CompassBiasDB, lookupBiasIndividually
bool CLCompassDatabaseController::findClosestEntry(const CLMotionTypeMagneticField &, const CLMotionTypeAcceleration &, bool, sqlite3_int64 &)
Best fit values (will update timestamp): %llu, %f, %f
void CLCompassDatabaseController::clearBias()
Clearing obsolete bias entries
float CLCompassDatabaseController::compareCalibration(const CLMotionTypeMagneticField &, const CLMotionTypeAcceleration &, bool, const CLCompassDatabaseRecord &, float &, float &)
search comparison: db level (%d) db age (%.3f), db mag (%.3f) est mag (%.3f) delta mag (%.3f), db inc (%.3f) est inc (%.3f) delta inc (%.3f)
CLCompassDatabaseController::onClearBiasTimer
virtual void CLGyroBiasEstimatorClientLocal::registerWithGyroBiasEstimatorPrivate(CLGyroBiasEstimatorClient::CLGyroBiasEstimatorClientCallback, bool, void *)_block_invoke
GyroBias received by DeviceMotion in daemon
GeomagneticModelLocationLifeTime
void CLGeomagneticModelProviderDaemon::setLocation(const CLDaemonLocation &)
#Warning geomagnetic provider received a stale location <%+.8f,%+.8f,%+.3f> @ %.3f
current location is still fresh, geomagnetic data is not re-calculated
geomagnetic information calculated for <%+.8f,%+.8f,%+.3f> @ %.3f, declination %f inclination %f will expire @ %.3f
Compass-Geomagnetic
Type,%s,lat,%+.8f,long,%+.8f,alt,%+.3f,x,%.3f,y,%.3f,z,%.3f,m,%.3f,h,%.3f,dec,%+.3f,inc,%+.3f,
#Warning no geomagnetic information available for <%+.8f,%+.8f,%+.3f>
void CLGeomagneticModelProviderDaemon::loadGeomagneticDataFromCache()
loadGeomagneticDataFromCache already loaded
loadGeomagneticDataFromCache not loading because deauthorized
loadGeomagneticDataFromCache loading
GeomagneticModel
recovered geomagnetic information @ %{public}.3f
void CLGeomagneticModelProviderDaemon::storeGeomagneticDataToCache()
caching geomagnetic information @ %{public}.3f
void CLGeomagneticModelProviderDaemon::startCoarseLocationUpdates()
current location is still fresh, not requesting coarse location for computing geomagnetic data, gmmTimestamp %.1f gmmFreshnessDuration %.1f
avoiding frequent coarse location request for computing geomagnetic data, fLastCoarseLocationRequestTimestamp %.1f minimumLocationRequestInterval %.1f
requesting coarse location for computing geomagnetic data
void CLGeomagneticModelProviderDaemon::stopCoarseLocationUpdates()
stopping coarse location for computing geomagnetic data
virtual bool CLGeomagneticModelProviderDaemon::registerForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)
Client requested notification %d
registered as location spectator to compute geomagnetic data
virtual bool CLGeomagneticModelProviderDaemon::unregisterForNotificationInternal(const CLGeomagneticModelProvider_Type::Notification &)
unregistered as location spectator to compute geomagnetic data
bool CLGeomagneticModelProviderDaemon::getGeomagneticField(const CLDaemonLocation &)
declination calculation failed @ %{public}lf (%{public}f)
void CLGeomagneticModelProviderDaemon::invalidateGeomagneticField()
invalidateGeomagneticField already invalid
invalidateGeomagneticField invalidating
Geomagnetic model data invalidated. Sending notification with timestamp %f
void CLGeomagneticModelProviderDaemon::onClientNotification(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)
location services is now disabled; invalidating geomagnetic field data
CLGeomagneticModelProviderDaemon::onStatusNotification
CLGeomagneticModelProviderDaemon::onClientNotification
CLGeomagneticModelProviderDaemon::onLocationNotification
com.apple.CoreMotion.NonlinearGyro
virtual void CLGyroCalibrationDatabaseLocalNonlinear::startCalibration(bool)
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Shared/Motion/SensorCalibration/CLGyroCalibrationDatabaseLocalNonlinear.mm
virtual void CLGyroCalibrationDatabaseLocalNonlinear::teardown()
virtual void CLGyroCalibrationDatabaseLocalNonlinear::computeFit()
Nonlinear gyro database computed fit.
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/GyroBiasEstimator/CLGyroBiasFitter.h
stratifiedRandomSample
targetStratum * kStrataSize + target < samples.size()
PreviousCoverOpenTimestamp
virtual void CLCoverStateDaemon::setLastCoverStateChangeTimestamp(const CFAbsoluteTime &)
Setting property %s to %f
virtual CFAbsoluteTime CLCoverStateDaemon::getLastCoverStateChangeTimestamp()
Last cover open timestamp = %f
-[CLWorkoutRecorderPublisher initWithDelegate:settings:]
Initializing CLWorkoutRecorderPublisher instance
/var/mobile/Library/locationd/WorkoutRecorder
Unable to delete publishing directory directory, error: %{public}@
Unable to create publishing directory, error: %@
-[CLWorkoutRecorderPublisher publishDataFiles:metadata:startDate:endDate:settings:]
Publishing data files.
Unable to publish, publisher not active.
Unable to send file, unable to create message for server.
ingest
Created request for file: %@, task: %@
-[CLWorkoutRecorderPublisher encryptData:metaData:start:end:]
Error starting message, error: %{public}@
Error appending file to message, file: %{public}@, error: %{public}@
Error finalizing message, error: %{public}@
Unable to move publishing file, error: %@
Successfully created message with UUID: %{private}@, URL: %{public}@
registration
-[CLWorkoutRecorderPublisher sendRegisterRequest]_block_invoke
Registration request already in progress.
Created request for registration.
-[CLWorkoutRecorderPublisher sendConfigurationRequest]_block_invoke
-[CLWorkoutRecorderPublisher subjectUUID]
_subjectUUID cached copy %@
clearing empty uuid saved to cache
-[CLWorkoutRecorderPublisher healthWrapConfiguration]
workout
CLWorkoutRecorderPublisher.mm
-[CLWorkoutRecorderPublisher URLSession:downloadTask:didFinishDownloadingToURL:]
Unable to parse response for register subject, error: %@
Successfully registered device.
Got invalid response from server on registration. subjectId or token nil.
-[CLWorkoutRecorderPublisher handleRegistrationResponse:data:url:didCompleteWithError:]
Unable to register subject, statusCode: %{public}ld, error: %{public}@, response: %{public}@
-[CLWorkoutRecorderPublisher handleConfigurationResponse:data:url:didCompleteWithError:]
Unable to get configuration, statusCode: %{public}ld, error: %{public}@, response: %{public}@
-[CLWorkoutRecorderPublisher handleIngestResponse:data:url:didCompleteWithError:]
Unable to remove file: %{public}@, error: %{public}@
Successfully uploaded file: %@, response: %@
Error when uploading file, file: %{public}@, error: %{public}@, response: %{public}@, responseBody: %{public}@
-[CLWorkoutRecorderPublisher URLSession:task:didCompleteWithError:]
Request completed with task: %@ and error: %@ and id: %@
WorkoutRecorderPublisherAuthorization
JoyrVmlPfjBQSCHspqiWf3vT2dfmqe2ij97pxMwH46stDDAL0PW5COcu3gGJ40B4
WorkoutRecorderPublisherCertificate
WorkoutRecorderPublisherStudyUUID
53681040-29d2-4420-988a-adbdf2f02905
WorkoutRecorderPublisherHost
WorkoutRecorderPublisherRegistrationTimerInterval
WorkoutRecorderPublisherConfigurationTimerInterval
CLMotionHintLoggerSilo
/Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Utilities/CLMotionHintLogger.mm
-[CLMotionHintLoggerAdapter beginService]
MagneticX
MagneticY
MagneticZ
Magnitude
Inclination
MagnitudeStd
InclinationStd
void CLClusterCompassCalibrationTable::setup(bool)
%s table creation.
 DESC
v24@?0Q8Q16
void CLCompassCalibrationTable::setup(bool)
 DESC LIMIT 100
-[CLDrivingRecorderTrigger initWithDelegate:andUniverse:]
Initializing CLDrivingRecorderTrigger instance
-[CLDrivingRecorderTrigger setupListeners]
Setting up driving recorder trigger listener.
-[CLDrivingRecorderTrigger scheduleStart]
Deferred start already scheduled.
Unable to schedule start, currently recording
Scheduling start for %f seconds in the future.
-[CLDrivingRecorderTrigger teardownListeners]
Tearing down driving recorder trigger listener.
-[CLDrivingRecorderTrigger onMotionStateObserverNotification:data:]
Received high confidence driving notification.
Received low confidence driving notification.
DrivingRecorderTriggerDeferredStartDurationSeconds
com.apple.locationd.CLDrivingRecorderPublisher
CLDrivingRecorderPublisherSubjectUUID
CLDrivingRecorderPublisherSubjectToken
DrivingRecording
CLDrivingRecorderPublishedCount
DrivingRecorderRateLimitingSampling
DrivingRecorderIntervalCount
DrivingRecorderTriggerDeferredStopDurationSeconds
DrivingRecorderPublisherMaxPerUUID
DrivingRecorderRateLimitingDisable
DrivingRecorderRateLimitingDisableInternalInstallBypass
DrivingRecorderSamplingInterval
DrivingRecorderNumSamplesPerInterval
DrivingRecorderListenersHeartRateDisable
virtual void CLGyroCalibrationDatabaseLocalLinear::computeFit()
Linear gyro database computed fit.
bleRSSI
bleChannel
discoveryFlags
onP6MWDActivity:
receivePredictedWalkDistanceBout:
setUpAggregationOnTimer
scheduleEstimate
getSixMinuteWalkDistancePrediction:
isWheelchairMode
completeActivity:withNextEstimateTime:
dateByAddingTimeInterval:
syncgetUserProfile
center
state
valueOut
queryRemoteStepCadenceToStrideLengthBinsWithHandler:
queryStepCadenceToStrideLengthBinsWithHandler:
calendarWithIdentifier:
setCalendar:
predicateForActivitySummariesBetweenStartDateComponents:endDateComponents:
_flightsClimbed
countUnit
doubleValueForUnit:
stepCount
appleExerciseTime
minuteUnit
_startDate
_endDate
initWithPredicate:resultsHandler:
executeQuery:
predicateForSamplesWithStartDate:endDate:options:
_predicateForObjectsFromAppleWatches
andPredicateWithSubpredicates:
workoutType
metadata
workoutActivityType
startDate
endDate
totalDistance
_value
workoutEvents
dateInterval
initWithSampleType:predicate:limit:sortDescriptors:resultsHandler:
categoryTypeForIdentifier:
value
quantity
sourceRevision
productType
hasPrefix:
writeToHealthKitPrediction:estimateTime:earliestTimeUsed:calibrationStatus:
sendAnalyticsWeeklyEstimate:strideCalInfo:walkingWorkoutPaceStats:runningWorkoutPaceStats:userInfo:
unitFromString:
quantitySampleWithType:quantity:startDate:endDate:metadata:
getBytes:length:
sendToCoreAnalyticsWeeklyEstimate:
onUserInfoUpdate:data:
fBoutDb
fBoutAggregator
fAggregationTimer
fP6MWDEstimator
fGaitMetricsDb
fPendingWatchBouts
fWalkingSpeedCalDb
fUserInfoClient
fUserInfo
fP6MWDPredictionInterval
fHkHealthStore
init
initWithTimestamp:
fTimestamp
decodeDoubleForKey:
encodeDouble:forKey:
dealloc
allocWithZone:
timestamp
supportsSecureCoding
encodeWithCoder:
initWithCoder:
TB,R
copyWithZone:
_internalLogItem
Td,R,N
syncKey
setSyncKey:
properties
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
TQ,R
T#,R
T@"NSString",R,C
objectIdentifier
sequencer
changeType
T@"NSString",R,N
Tq,R,N
setObjectIdentifier:
setChangeType:
setProperties:
_syncKey
_properties
T@"NSString",&,V_syncKey
T@"NSDictionary",&,V_properties
initWithProperties:
archivedDataWithRootObject:requiringSecureCoding:error:
dataFromChange:
changeFromData:ofType:
dataWithSYObject:
SYObjectWithData:
encodeSYChangeForBackwardCompatibility:protocolVersion:
decodeChangeData:fromProtocolVersion:ofType:
sessionMetadata
setMaxConcurrentMessages:
setDelegate:
setSerializer:
queue
setTargetQueue:
setSessionMetadata:
setPerMessageTimeout:
setFullSessionTimeout:
userInfo
objectForKeyedSubscript:
localizedDescription
UTF8String
count
objectAtIndexedSubscript:
syncDidComplete
UUIDString
activeSyncSession
syncSessionType
sync:
syncRestriction
syncCoordinator:beginSyncSession:
syncCoordinator:didInvalidateSyncSession:
syncCoordinatorDidChangeSyncRestriction:
initialSyncStateObserver:initialSyncDidCompleteForPairingIdentifier:
initialSyncStateObserver:syncDidResetForPairingIdentifier:
initialSyncStateObserver:syncDidCompleteForPairingIdentifier:
initialSyncStateObserverClientCanRetryFailedRequests:
service:startSession:error:
service:sessionEnded:error:
service:incomingData:completion:
service:incomingStream:metadata:completion:
service:encounteredError:context:
service:willPreferSession:overSession:
service:willSwitchFromPairingID:toPairingID:
service:didSwitchFromPairingID:toPairingID:
service:targetDeviceProximityChanged:
service:targetDeviceConnectionChanged:
serviceDidPairDevice:
serviceDidUnpairDevice:
syncSession:enqueueChanges:error:
syncSession:applyChanges:completion:
syncSession:didEndWithError:
syncSession:resetDataStoreWithError:
resetDataStoreForSyncSession:completion:
syncSession:rollbackChangesWithError:
syncSession:restartChanges:
syncSession:successfullySynced:
initWithSyncManager:silo:
fManager
fSilo
fPsSession
arrayWithCapacity:
numberWithInt:
setObject:atIndexedSubscript:
numberWithDouble:
intValue
doubleValue
silo
newTimer
setHandler:
syncCoordinatorWithServiceName:
initWithDelegate:
initWithService:priority:asMasterStore:options:
setDelegate:queue:
setSessionStalenessInterval:
setHasChangesAvailable
resume:
suspend
objectForKey:
isEqualToString:
dictionaryWithObjectsAndKeys:
countByEnumeratingWithState:objects:count:
async:
stringWithUTF8String:
setObject:forKey:
setNextFireDelay:
initWithBytesNoCopy:length:deallocator:
writeToFile:atomically:
initWithDescription:
dictionaryRepresentation
stringWithFormat:
dictionary
numberWithUnsignedInt:
numberWithFloat:
setElevationDescended:
setHasElevationDescended:
hasElevationDescended
gradeType
setGradeType:
setHasGradeType:
hasGradeType
gradeTypeAsString:
StringAsGradeType:
setVerticalSpeed:
setHasVerticalSpeed:
hasVerticalSpeed
rawGradeType
setRawGradeType:
setHasRawGradeType:
hasRawGradeType
rawGradeTypeAsString:
StringAsRawGradeType:
source
setSource:
setHasSource:
hasSource
sourceAsString:
StringAsSource:
readFrom:
writeTo:
copyTo:
mergeFrom:
elevationAscended
setElevationAscended:
elevationDescended
verticalSpeed
_elevationAscended
_elevationDescended
_gradeType
_rawGradeType
_source
_verticalSpeed
_has
TI,N,V_elevationAscended
TB,N
TI,N,V_elevationDescended
Ti,N,V_gradeType
Tf,N,V_verticalSpeed
Ti,N,V_rawGradeType
Ti,N,V_source
setEstimatedVo2Max:
setHasEstimatedVo2Max:
hasEstimatedVo2Max
setVariance:
setHasVariance:
hasVariance
setFilteredVo2Max:
setHasFilteredVo2Max:
hasFilteredVo2Max
setEligibleForHealthKit:
setHasEligibleForHealthKit:
hasEligibleForHealthKit
setEligibleForCalorimetry:
setHasEligibleForCalorimetry:
hasEligibleForCalorimetry
setNumWorkoutsContrToEstimate:
setHasNumWorkoutsContrToEstimate:
hasNumWorkoutsContrToEstimate
setEstimatedHRResponseParam:
setHasEstimatedHRResponseParam:
hasEstimatedHRResponseParam
setEstimatedHRRecoveryParam:
setHasEstimatedHRRecoveryParam:
hasEstimatedHRRecoveryParam
estimatedVo2Max
variance
filteredVo2Max
eligibleForHealthKit
eligibleForCalorimetry
numWorkoutsContrToEstimate
estimatedHRResponseParam
estimatedHRRecoveryParam
_estimatedHRRecoveryParam
_estimatedHRResponseParam
_estimatedVo2Max
_filteredVo2Max
_variance
_numWorkoutsContrToEstimate
_eligibleForCalorimetry
_eligibleForHealthKit
Td,N,V_estimatedVo2Max
Td,N,V_variance
Td,N,V_filteredVo2Max
TB,N,V_eligibleForHealthKit
TB,N,V_eligibleForCalorimetry
TI,N,V_numWorkoutsContrToEstimate
Td,N,V_estimatedHRResponseParam
Td,N,V_estimatedHRRecoveryParam
becameFatallyBlocked:index:
initWithIdentifier:
valid
setValid:
isSupported
getSilo
performSyncOnSilo:invoker:
beginService
endService
registerDelegate:inSilo:
setDelegateEntityName:
register:forNotification:registrationInfo:
unregister:forNotification:
forget:
doAsync:
doAsync:withReply:
syncgetDoSync:
onNotification:withData:
initWithInboundProtocol:outboundProtocol:
universe
setAdaptedNotifier:
notifier
setupService
monitorKinesiasExpiration
updateSensorRecorderSubscription
sensorRecorder
choreaDetectionService
tremorDetectionService
adaptee
setChoreaDetectionService:
setTremorDetectionService:
setFSensorRecorderQueryTimer:
updateSensorRecorderQuery
fSensorRecorderQueryTimer
nextFireTime
setFAggregateRecordsTimer:
aggregateRecords
fAggregateRecordsTimer
setFSensorRecorderSubscribeTimer:
setSensorRecorder:
date
timeIntervalSinceReferenceDate
fSensorRecorderSubscribeTimer
setAccelSampleRate:
setGyroSampleRate:
processDataWithMaxDuration:endTime:
processNextIntervalWithRemainingDurationToProcess:endTime:updateCanContinue:
updateStartTime
lastProcessedTime
setUpdateStartTime:
setLastProcessedTime:
initWithTimeIntervalSinceReferenceDate:
accelerometerDataFromDate:toDate:
gyroDataFromDate:toDate:
startTime
acceleration
feedAccelSample:time:
rotationRate
feedGyroSample:time:
monitorKinesiasStart
anySubscribedToSensorRecorder
teardownService
syncgetResultReady:ForAnalyzer:
addMonitoringPeriodFrom:until:
startUpdatesforAnalyzer:
stopMonitoring
setMonitorKinesiasStart:
setMonitorKinesiasExpiration:
fDyskinesiaSubscribed
fTremorSubscribed
_monitorKinesiasStart
_monitorKinesiasExpiration
_lastProcessedTime
_sensorRecorder
_fSensorRecorderSubscribeTimer
_fSensorRecorderQueryTimer
_fAggregateRecordsTimer
_updateStartTime
_choreaDetectionService
_tremorDetectionService
T@"CLHealthAssessmentChoreaDetectionService",&,N,V_choreaDetectionService
T@"CLHealthAssessmentTremorDetectionService",&,N,V_tremorDetectionService
T@"CMSensorRecorder",&,N,V_sensorRecorder
T@"CLTimer",&,N,V_fSensorRecorderSubscribeTimer
T@"CLTimer",&,N,V_fSensorRecorderQueryTimer
T@"CLTimer",&,N,V_fAggregateRecordsTimer
Td,N,V_updateStartTime
Td,N,V_monitorKinesiasStart
Td,N,V_monitorKinesiasExpiration
Td,N,V_lastProcessedTime
vendor
isServiceEnabled:
floatValue
defaultCenter
postNotificationName:object:userInfo:
sharedInstance
proxyForService:
assertInside
invalidate
initWithClient:
sharedInterface
arrayWithObjects:count:
extendSelectorInfoWithProtocol:bases:
proxyForRecipientObject:inSilo:recipientName:
binaryVersion
sizeOfType
cppObjectPtr
compatibilityInfo
serialized
length
bytes
setCppObjectPtr:
containerWithObject:destructor:binaryVersion:typeSize:
averageIntensity
longValue
updateNotification:withRegistrationInfo:forClient:
register:forNotification:distanceFilter:
shutdown
start
setSimulationEnabled:
sendSimulatedLocation:
sendSimulatedLocationUnavailable
syncgetNotification:data:
syncgetLocation:
syncgetLocationPrivate:
syncgetLocationUnavailable
syncgetIsSimulationEnabled
syncgetName
takeDisablementAssertion
releaseDisablementAssertion
takeEmergencyEnablementAssertion
releaseEmergencyEnablementAssertion
receivedMessageOfType:withPayload:
failedToSendMessage:withError:isFatal:
successfullySentMessage:
pairedDeviceIsNearby:
proxyForService:forClient:
setFireInterval:
initOnQueue:
addClient:
retireClient:
deviceWithEffectiveID:
afterInterval:async:
initWithCapacity:
boolValue
addObject:
findCandidateServersWithCompletion:
numberWithUnsignedInteger:
setObject:forKeyedSubscript:
numberWithBool:
sendRequestID:request:destinationID:options:responseHandler:
setDispatchQueue:
setInvalidationHandler:
setControlFlags:
setDestinationDevice:
destinationDevice
effectiveIdentifier
dictionaryWithObjects:forKeys:count:
registerEventID:options:handler:
activateWithCompletion:
setMessageType:
setPayload:
setPriority:
setIdsOptions:
sendMessage:
initForReadingFromData:error:
decodeObjectOfClass:forKey:
clientLocation
initWithData:
daemonLocationPrivate
mergeIntoDaemonLocation:
setProxy:
takeAssertion
releaseAssertion
initInUniverse:
proxy
_proxy
T@"<CLStreamedLocationProviderProtocol>",&,N,V_proxy
model
name
setDeviceFoundHandler:
setDeviceLostHandler:
nearbyDeviceListener
activeDevices
localDevice
workQ
requestQ
dictionaryWithDictionary:
addEntriesFromDictionary:
probeClients
dispatchQueue
setNearbyDeviceListener:
setWorkQ:
setRequestQ:
setProbeClients:
_nearbyDeviceListener
_workQ
_requestQ
_probeClients
T@"RPCompanionLinkClient",N,V_nearbyDeviceListener
T@"NSObject<OS_dispatch_queue>",N,V_workQ
T@"NSObject<OS_dispatch_queue>",N,V_requestQ
T@"NSMutableArray",N,V_probeClients
setMotion:
setNatalieFeatures:
hasNatalieFeatures
motion
natalieFeatures
_motion
_natalieFeatures
T@"ALCMMotionContextMotionState",&,N,V_motion
T@"ALCLNatalieFeatures",&,N,V_natalieFeatures
mounted
setMounted:
setHasMounted:
hasMounted
mountedAsString:
StringAsMounted:
turn
setTurn:
setHasTurn:
hasTurn
turnAsString:
StringAsTurn:
setIsVehicular:
setHasIsVehicular:
hasIsVehicular
setIsMoving:
setHasIsMoving:
hasIsMoving
isVehicular
isMoving
_mounted
_turn
_isMoving
_isVehicular
Ti,N,V_mounted
Ti,N,V_turn
TB,N,V_isVehicular
TB,N,V_isMoving
TQ,N,V_startTime
protectionSpace
authenticationMethod
host
serverTrust
credentialForTrust:
initialize
knownHosts
setRecordId:
setHasRecordId:
hasRecordId
setPacebin:
setHasPacebin:
hasPacebin
setTimestamp:
setHasTimestamp:
hasTimestamp
setRegularEntry:
setHasRegularEntry:
hasRegularEntry
recordId
setStartTime:
pacebin
kvalue
setKvalue:
kvalueTrack
setKvalueTrack:
score
setScore:
endTime
setEndTime:
distance
setDistance:
steps
setSteps:
session
setSession:
speed
setSpeed:
regularEntry
_endTime
_startTime
_timestamp
_distance
_kvalue
_kvalueTrack
_pacebin
_recordId
_score
_session
_speed
_steps
_regularEntry
Ti,N,V_recordId
Td,N,V_startTime
TI,N,V_pacebin
Tf,N,V_kvalue
Tf,N,V_kvalueTrack
Tf,N,V_score
Td,N,V_endTime
Tf,N,V_distance
Ti,N,V_steps
Ti,N,V_session
Tf,N,V_speed
Td,N,V_timestamp
TB,N,V_regularEntry
floorsAscended
floorsDescended
_floorsAscended
_floorsDescended
TI,N,V_count
Td,N,V_distance
TI,N,V_floorsAscended
TI,N,V_floorsDescended
firedTime
didWake
_firedTime
_didWake
Td,N,V_firedTime
TB,N,V_didWake
Ti,N,V_mode
placeInference
_initWithRTPlaceInference:
fEpochTypeAsString:
StringAsFEpochType:
fVectorMagnitude
setFVectorMagnitude:
fIQRX
setFIQRX:
fIQRY
setFIQRY:
fIQRZ
setFIQRZ:
fMachineFrequency
setFMachineFrequency:
fEpochType
setFEpochType:
fStanding
setFStanding:
_fEpochType
_fIQRX
_fIQRY
_fIQRZ
_fMachineFrequency
_fVectorMagnitude
_fStanding
Tf,N,V_fVectorMagnitude
Tf,N,V_fIQRX
Tf,N,V_fIQRY
Tf,N,V_fIQRZ
Tf,N,V_fMachineFrequency
Ti,N,V_fEpochType
TB,N,V_fStanding
genderAsString:
StringAsGender:
gender
setGender:
heightM
setHeightM:
weightKG
setWeightKG:
vo2max
setVo2max:
setAge:
hrmin
setHrmin:
hrmax
setHrmax:
hronset
setHronset:
setPal:
_age
_gender
_heightM
_hrmax
_hrmin
_hronset
_pal
_vo2max
_weightKG
Ti,N,V_gender
Tf,N,V_heightM
Tf,N,V_weightKG
Tf,N,V_vo2max
Tf,N,V_age
Tf,N,V_hrmin
Tf,N,V_hrmax
Tf,N,V_hronset
Tf,N,V_pal
typeAsString:
StringAsType:
confidence
setConfidence:
setHasConfidence:
hasConfidence
confidenceAsString:
StringAsConfidence:
mountedState
setMountedState:
setHasMountedState:
hasMountedState
mountedStateAsString:
StringAsMountedState:
mountedConfidence
setMountedConfidence:
setHasMountedConfidence:
hasMountedConfidence
mountedConfidenceAsString:
StringAsMountedConfidence:
setIsStanding:
setHasIsStanding:
hasIsStanding
setTilt:
setHasTilt:
hasTilt
exitState
setExitState:
setHasExitState:
hasExitState
exitStateAsString:
StringAsExitState:
setEstExitTime:
setHasEstExitTime:
hasEstExitTime
setHasStartTime:
hasStartTime
setIsVehicleConnected:
setHasIsVehicleConnected:
hasIsVehicleConnected
type
setType:
isStanding
tilt
estExitTime
isVehicleConnected
_estExitTime
_confidence
_exitState
_mountedConfidence
_mountedState
_tilt
_type
_isStanding
_isVehicleConnected
Ti,N,V_type
Ti,N,V_confidence
Ti,N,V_mountedState
Ti,N,V_mountedConfidence
TB,N,V_isStanding
Tf,N,V_tilt
Ti,N,V_exitState
Td,N,V_estExitTime
TB,N,V_isVehicleConnected
overrideActionAsString:
StringAsOverrideAction:
overrideAction
_overrideAction
Ti,N,V_overrideAction
T@"ALCLMotionActivity",&,N,V_activity
setMotionState:
setStepCountData:
setSessionCatherineData:
setJacksonData:
setFitnessTracking:
setStairClimbingModel:
setRowingModel:
setExerciseMinute:
setElevation:
setCoarseElevation:
setCalorieData:
setNatalieData:
setSedentaryAlarmDataDeprecated:
setStrideCalDataDeprecated:
setCalorieDataDeprecated:
setCoarseElevationDeprecated:
setElevationDeprecated:
setWorkoutEventDeprecated:
hasActivityOverrideMsg
hasBodyMetrics
hasMotionState
hasStepCountData
hasSessionCatherineData
hasJacksonData
hasStrideCalData
hasSedentaryAlarmData
hasAllDayHeartRate
hasFitnessTracking
hasIdsStatus
hasStairClimbingModel
hasRowingModel
hasExerciseMinute
hasElevation
hasCoarseElevation
hasCalorieData
hasWorkoutEvent
hasNatalieData
hasSedentaryAlarmDataDeprecated
hasStrideCalDataDeprecated
hasCalorieDataDeprecated
hasCoarseElevationDeprecated
hasElevationDeprecated
hasWorkoutEventDeprecated
motionState
stepCountData
sessionCatherineData
jacksonData
fitnessTracking
stairClimbingModel
rowingModel
exerciseMinute
elevation
coarseElevation
calorieData
natalieData
sedentaryAlarmDataDeprecated
strideCalDataDeprecated
calorieDataDeprecated
coarseElevationDeprecated
elevationDeprecated
workoutEventDeprecated
_activityOverrideMsg
_allDayHeartRate
_bodyMetrics
_calorieData
_calorieDataDeprecated
_coarseElevation
_coarseElevationDeprecated
_elevation
_elevationDeprecated
_exerciseMinute
_fitnessTracking
_idsStatus
_jacksonData
_natalieData
_rowingModel
_sedentaryAlarmData
_sedentaryAlarmDataDeprecated
_sessionCatherineData
_stairClimbingModel
_stepCountData
_strideCalData
_strideCalDataDeprecated
_workoutEventDeprecated
T@"ALActivityOverrideMsg",&,N,V_activityOverrideMsg
T@"ALCLBodyMetrics",&,N,V_bodyMetrics
T@"ALMotionState",&,N,V_motionState
T@"ALCLStepCountEntry",&,N,V_stepCountData
T@"ALCLSessionCatherine",&,N,V_sessionCatherineData
T@"ALCLJacksonData",&,N,V_jacksonData
T@"ALCLStrideCalEntry",&,N,V_strideCalData
T@"ALCLSedentaryAlarmData",&,N,V_sedentaryAlarmData
T@"ALCLAllDayHeartRate",&,N,V_allDayHeartRate
T@"ALCMFitnessTracking",&,N,V_fitnessTracking
T@"ALCLOdometer",&,N,V_odometer
T@"ALCLIDSStatus",&,N,V_idsStatus
T@"ALCLStairClimbingModel",&,N,V_stairClimbingModel
T@"ALCLRowingModel",&,N,V_rowingModel
T@"ALCMExerciseMinute",&,N,V_exerciseMinute
T@"ALCMElevation",&,N,V_elevation
T@"ALCMCoarseElevation",&,N,V_coarseElevation
T@"ALCMCalorieData",&,N,V_calorieData
T@"ALCMWorkoutEvent",&,N,V_workoutEvent
T@"ALCLNatalieDataDeprecated",&,N,V_natalieData
T@"ALCLSedentaryAlarmDataDeprecated",&,N,V_sedentaryAlarmDataDeprecated
T@"ALCLStrideCalEntryDeprecated",&,N,V_strideCalDataDeprecated
T@"ALCMCalorieDataDeprecated",&,N,V_calorieDataDeprecated
T@"ALCMCoarseElevationDeprecated",&,N,V_coarseElevationDeprecated
T@"ALCLElevationDeprecated",&,N,V_elevationDeprecated
T@"ALCMWorkoutEventDeprecated",&,N,V_workoutEventDeprecated
seekToEndOfFile
offsetInFile
initWithClientCoordinate:
unarchivedArrayOfObjectsOfClass:fromData:error:
logData:
logger
setLogger:
_logger
T^v,N,V_logger
stringByAppendingPathComponent:
setActivityOverrideMsg:
activityOverrideMsg
setOverrideAction:
setActivity:
activity
formattedText
assertOutside
notifyPassKitPayment:transaction:info:
constructController
constructMonitors
setEndpointSelector:
initFileURLWithPath:isDirectory:
initWithRootDirectory:classifier:
constructPolicies
constructSubHarvesters
setLastCountryCode:
removeItemAtURL:error:
currentConnection
submitSample:
fetchStateWithReply:
lastCountryCode
_endpointSelector
_classifier
_networkController
_requestStore
_countryCodeNotificationToken
_harvestController
_monitorGps
_policyTrip
_policyProactive
_subHarvesters
_lastCountryCode
T@"NSString",&,N,V_lastCountryCode
querySignificantElevationDeltaFromDate:toDate:withReply:
updatePhoneWorkoutElevationSubscription:
registerForCyclingWorkoutDistanceUpdates:
unregisterForCyclingWorkoutDistanceUpdates:
onCyclingDistanceUpdate:
initWithSignificantElevation:
syncgetAuthorizationContextOfClient:
isAuthorizedForServiceTypeMask:
firstObject
stringByAppendingPathExtension:
registerClient:forNotification:
unregisterClient:forNotification:
onVehicleStateUpdate:
saveInputsAndOutputsForSessionId:
saveRetrocomputedOutputs
onSyncActivity:
receiveVO2MaxCloudKitDailyStatsFromWatch:
initWithZoneName:ownerName:
initWithContainerIdentifier:environment:
initWithContainerID:
cloudKitAccountDidChange:
addObserver:selector:name:object:
validateAccount
resetDailyStats
sendDailyStatsToPhone
setNextFireDelay:interval:
removeObserver:name:object:
addRecordIDsForSessionId:shouldUploadToOutputZone:shouldUploadToInputZone:
initWithUUIDBytes:
updateDeviceUnlocked:
setUpSyncActivity
handleSyncUpload:
getCKSyncEngineMetadata
bulkUploadRecordIDsShouldReupload:shouldUploadToOutputZone:shouldUploadToInputZone:shouldThrottle:
setNeedsToFetchChanges
resetSyncActivity:withDelay:
accountStatus
stopSyncing:
supportsDeviceToDeviceEncryption
containerIdentifier
getUserRecordIDName
recordName
setUserRecordIDName:
shouldKeepLocalDataOnAccountChange
fetchUserRecordIDWithCompletionHandler:
accountInfoWithCompletionHandler:
initWithUTF8String:
initializeSyncEngine
privateCloudDatabase
initWithDatabase:dataSource:metadata:
setApsMachServiceName:
setXpcActivityCriteriaOverrides:
initWithConfiguration:
fetchChangesForZoneIDs:completionHandler:
initWithZoneID:
addRecordZonesToSave:recordZoneIDsToDelete:
initWithRecordName:zoneID:
addRecordIDsToSave:recordIDsToDelete:
initRequiringSecureCoding:
encodeSystemFieldsWithCoder:
finishEncoding
encodedData
initWithUUIDString:
getUUIDBytes:
copy
setRequiresSecureCoding:
finishDecoding
initWithRecordType:recordID:
data
encryptedValuesByKey
recordID
getSystemFieldsFromCKRecord:
inputs
recordType
updateOutputSystemFields:outputRecord:
updateInputSystemFields:inputRecord:
zoneID
zoneName
createVO2MaxOutputZone
createVO2MaxInputZone
sharedConnection
isHealthDataSubmissionAllowed
dataWithBytes:length:
handleZoneDeleted:
domain
code
deleteZone:
handleZonePurge:
createCKRecordForOutput:
createCKRecordForInput:
handleServerRecordChanged:
handleUnknownItem:
handleZoneNotFound:
handleFetchedOutputRecord:
handleFetchedInputRecord:
syncEngine:recordToSaveForRecordID:
syncEngine:didSaveRecord:
syncEngine:failedToSaveRecord:error:
syncEngine:didDeleteRecordWithID:
syncEngine:failedToDeleteRecordWithID:error:
syncEngine:didFetchRecord:
syncEngine:recordWithIDWasDeleted:recordType:
syncEngine:didUpdateMetadata:
syncEngine:didSaveRecordZone:
syncEngine:didDeleteRecordZoneWithID:
syncEngine:failedToFetchChangesForRecordZoneID:error:
syncEngine:failedToSaveRecordZone:error:
syncEngine:failedToDeleteRecordZoneWithID:error:
syncEngine:zoneWithIDChanged:
syncEngine:zoneWithIDWasDeleted:
syncEngine:zoneWithIDWasPurged:
onDataProtectionNotification:data:
syncEngine:shouldFetchChangesForZoneID:
container
syncEngine
.cxx_destruct
.cxx_construct
fInputCache
fInputStore
fStagingOutputStore
fRetrocomputeDb
fFetchChangesForInputZone
fDataProtectionClient
fDeviceUnlocked
fMaxSessionsForUploadThrottling
fMinTimeBetweenForcedFetches
fOutputZoneID
fInputZoneID
fDailyStats
fDailyStatsTimer
fDailyStatsTimerInterval
fDailyStatsStartTime
_container
_syncEngine
T@"CKContainer",R,N,V_container
T@"CKSyncEngine",R,N,V_syncEngine
numberWithUnsignedLongLong:
setTileType:
setHasTileType:
hasTileType
setTileX:
setHasTileX:
hasTileX
setTileY:
setHasTileY:
hasTileY
setIsAllowOverCellular:
setHasIsAllowOverCellular:
hasIsAllowOverCellular
secKey
setSecKey:
setHasSecKey:
hasSecKey
tileType
tileX
tileY
isAllowOverCellular
_secKey
_tileType
_tileX
_tileY
_isAllowOverCellular
TI,N,V_tileType
TI,N,V_tileX
TI,N,V_tileY
TB,N,V_isAllowOverCellular
TQ,N,V_secKey
objectForInfoDictionaryKey:
ageOutStepArray
stepsInWindow
feedStepCountUpdate:
fStepWindow
resolveNewScanTypeWithNewContext:
desiredDefaultScanParameters:
desiredAggressiveDiscoveryScanParameters:
desiredBTFindingDiscoveryScanParameters:
desiredWatchAdvertisementBufferScanParameters:
desiredHawkeyeLowEnergyScanParameters:
desiredCoexFriendlyAggressiveDiscoveryScanParameters:
scanTypeUpdated:
hasActiveAggressiveScan
updateContext:
startedAggressiveDiscoveryScan
stoppedAggressiveDiscoveryScan
startedBTFindingDiscoveryScan
stoppedBTFindingDiscoveryScan
startedHawkeyeLowEnergyScan
stoppedHawkeyeLowEnergyScan
convertCLAvengerScannerPolicyScanTypeToString:
initWithDelegate:platformType:supportsPerTypeDuplicateFilter:
startAggressiveScan
stopAggressiveScan
startCoexFriendlyAggressiveScan
stopCoexFriendlyAggressiveScan
startBTFindingScan
stopBTFindingScan
startWatchAdvertisementBufferScan
stopWatchAdvertisementBufferScan
startHawkeyeLowEnergyScan
stopHawkeyeLowEnergyScan
hasActiveBTFindingScan
optedIn
setOptedIn:
associatedTo2GHzWiFi
setAssociatedTo2GHzWiFi:
wifi2GHzCriticalState
setWifi2GHzCriticalState:
bluetoothAudioActive
setBluetoothAudioActive:
downgradedDuringCoexFriendlyAggressiveDiscoveryScan
totalAdvertisementBuffersAvailable
setTotalAdvertisementBuffersAvailable:
currentScanParameters
currentScanType
_currentContext
_currentScanType
TQ,N
Tq,R,N,V_currentScanType
T{CLAvengerScannerScanParameters=BB},R,N
dataWithContentsOfURL:options:error:
instancesRespondToSelector:
writeToURL:options:error:
initWithMonitorGpsExternal:
accessoryDidConnect:
accessoryDidDisconnect:
_monitorGpsExternal
sessionWithConfiguration:delegate:delegateQueue:
invalidateAndCancel
setTimeoutInterval:
originalRequest
downloadTaskWithRequest:completionHandler:
replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:
absoluteString
scheme
URLSession:didBecomeInvalidWithError:
URLSessionDidFinishEventsForBackgroundURLSession:
URLSession:task:willBeginDelayedRequest:completionHandler:
URLSession:taskIsWaitingForConnectivity:
URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:
URLSession:task:didReceiveChallenge:completionHandler:
URLSession:task:needNewBodyStream:
URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:
URLSession:task:didFinishCollectingMetrics:
URLSession:task:didCompleteWithError:
quantitySampleWithType:quantity:startDate:endDate:device:metadata:
recordFallEventInHealthKit:
T@"CLDispatchSilo",R,D,N
syncgetIsTimerArmed
syncgetStartTimerForClient:andOptions:
syncgetStopTimerForClient:
syncgetSedentaryAlarmData:since:
timeZoneDidChange:
operationQueue
addObserverForName:object:queue:usingBlock:
removeObserver:
setSedentaryAlarmData:
sedentaryAlarmData
setFiredTime:
setDidWake:
currentCalendar
components:fromDate:
minute
second
dateWithTimeIntervalSinceReferenceDate:
quantityTypeForIdentifier:
secondUnit
quantityWithUnit:doubleValue:
quantitySampleWithType:quantity:startDate:endDate:
saveObjects:withCompletion:
integerValue
setSelectionFeatureValue:value:
selectModels
fillTripFallModel:
fillSlipFallModel:
fillOtherFallModel:
fillFallThresholds:
fSelectionFeatures
fTripFallModel
fSlipFallModel
fOtherFallModel
fThresholds
setLsest:
setHasLsest:
hasLsest
setSumest:
setHasSumest:
hasSumest
setFPal:
setHasFPal:
hasFPal
nPairs
setNPairs:
lsest
sumest
fPal
_fPal
_lsest
_nPairs
_sumest
TI,N,V_nPairs
Tf,N,V_lsest
Tf,N,V_sumest
TI,N,V_fPal
setDEPRECATEDFingerprints:
setFingerprints:
setVersion:
setHasVersion:
hasVersion
securityKey
setSecurityKey:
setHasSecurityKey:
hasSecurityKey
setGenerationTimeSecs:
setHasGenerationTimeSecs:
hasGenerationTimeSecs
setExpirationAgeSecs:
setHasExpirationAgeSecs:
hasExpirationAgeSecs
hasDEPRECATEDFingerprints
hasFingerprints
marketId
setMarketId:
setHasMarketId:
hasMarketId
version
generationTimeSecs
expirationAgeSecs
dEPRECATEDFingerprints
fingerprints
_generationTimeSecs
_marketId
_securityKey
_dEPRECATEDFingerprints
_expirationAgeSecs
_fingerprints
_version
Ti,N,V_version
Ti,N,V_tileX
Ti,N,V_tileY
TQ,N,V_securityKey
Td,N,V_generationTimeSecs
Ti,N,V_expirationAgeSecs
TB,R,N
T@"TRANSITPbLocationFingerprintsV1",&,N,V_dEPRECATEDFingerprints
T@"TRANSITPbLocationFingerprints",&,N,V_fingerprints
TQ,N,V_marketId
setBundleId:
setLaunchReason:
initWithBundleId:launchReason:
bundleId
launchReason
_bundleId
_launchReason
T@"NSString",&,N,V_bundleId
T@"NSString",&,N,V_launchReason
setHomeUUID:
setActionSetUUID:
setActionSetName:
setActionSetType:
setClientName:
setTriggerLocalizationScan:
setTriggerRecordingScan:
initWithHomeUUID:actionSetUUID:actionSetName:actionSetType:clientName:source:triggerLocalizationScan:triggerRecordingScan:
homeUUID
actionSetUUID
actionSetName
actionSetType
clientName
triggerLocalizationScan
triggerRecordingScan
_homeUUID
_actionSetUUID
_actionSetName
_actionSetType
_clientName
_triggerLocalizationScan
_triggerRecordingScan
T@"NSString",&,N,V_homeUUID
T@"NSString",&,N,V_actionSetUUID
T@"NSString",&,N,V_actionSetName
T@"NSString",&,N,V_actionSetType
T@"NSString",&,N,V_clientName
T@"NSString",&,N,V_source
T@"NSNumber",&,N,V_triggerLocalizationScan
T@"NSNumber",&,N,V_triggerRecordingScan
setAccessoryUUID:
setAccessoryName:
setServiceName:
setServiceType:
setCharacteristicType:
setServiceUUID:
initWithHomeUUID:accessoryUUID:accessoryName:serviceName:serviceType:characteristicType:clientName:source:serviceUUID:triggerLocalizationScan:triggerRecordingScan:
accessoryUUID
accessoryName
serviceName
serviceType
characteristicType
serviceUUID
_accessoryUUID
_accessoryName
_serviceName
_serviceType
_characteristicType
_serviceUUID
T@"NSString",&,N,V_accessoryUUID
T@"NSString",&,N,V_accessoryName
T@"NSString",&,N,V_serviceName
T@"NSString",&,N,V_serviceType
T@"NSString",&,N,V_characteristicType
T@"NSString",&,N,V_serviceUUID
setViewUUID:
setViewName:
setViewInformation:
initWithHomeUUID:viewUUID:viewName:viewInformation:
viewUUID
viewName
viewInformation
_viewUUID
_viewName
_viewInformation
T@"NSString",&,N,V_viewUUID
T@"NSString",&,N,V_viewName
T@"NSString",&,N,V_viewInformation
setStatus:
setTrack:
setOutputDeviceIDs:
initWithBundleId:status:track:outputDeviceIDs:
status
track
outputDeviceIDs
_status
_track
_outputDeviceIDs
T@"NSNumber",&,N,V_status
T@"NSString",&,N,V_track
T@"NSDictionary",&,N,V_outputDeviceIDs
secItemFormatToDictionary:
initializeKeychainItemWithIdentifier:keyType:
initWithIdentifier:keyType:
keychainItemData
writeToKeychain
resetKeychainItem
dictionaryToSecItemFormat:
setKeychainItemData:
genericPasswordQuery
setGenericPasswordQuery:
_keychainItemData
_genericPasswordQuery
T@"NSMutableDictionary",&,N,V_keychainItemData
T@"NSMutableDictionary",&,N,V_genericPasswordQuery
messageType
payload
priority
idsOptions
protocolVersion
setProtocolVersion:
_protocolVersion
_messageType
_payload
_priority
_idsOptions
T@"NSString",&,N,V_messageType
T@"NSDictionary",&,N,V_payload
Tq,N,V_priority
T@"NSDictionary",&,N,V_idsOptions
Ti,N,V_protocolVersion
withClients:
isDefaultPairedDevice
isNearby
relationship
rapportLinkActive
rapportLink
updateNearbyStatusWithCompanionLinkDevice:didConnect:
setSilo:
setService:
resume
serviceWithIdentifier:completion:
service
addDelegate:queue:
activateRapportLinkIfNecessary
setUnacknowledgedMessages:
setClients:
devices
updateNearbyStatusWithDevices:
removeObject:
packageMessage:
setWithObject:
sendMessage:toDestinations:priority:options:identifier:error:
unacknowledgedMessages
sendEventID:event:destinationID:options:completion:
sendMessageRapport:
removeObjectForKey:
service:account:incomingOpportunisticData:withIdentifier:fromID:context:
service:didSendOpportunisticDataWithIdentifier:toIDs:
service:account:incomingMessage:fromID:context:
service:account:incomingData:fromID:context:
service:account:incomingUnhandledProtobuf:fromID:context:
service:account:incomingResourceAtURL:fromID:context:
service:account:incomingResourceAtURL:metadata:fromID:context:
service:account:incomingPendingMessageOfType:fromID:context:
service:activeAccountsChanged:
service:devicesChanged:
service:nearbyDevicesChanged:
service:connectedDevicesChanged:
service:linkedDevicesChanged:
service:account:identifier:didSendWithSuccess:error:
service:account:identifier:didSendWithSuccess:error:context:
service:account:identifier:sentBytes:totalBytes:
service:account:identifier:hasBeenDeliveredWithContext:
service:account:identifier:fromID:hasBeenDeliveredWithContext:
service:account:inviteReceivedForSession:fromID:
service:account:inviteReceivedForSession:fromID:withOptions:
service:account:inviteReceivedForSession:fromID:withContext:
service:account:receivedGroupSessionParticipantUpdate:
service:account:receivedGroupSessionParticipantDataUpdate:
serviceSpaceDidBecomeAvailable:
serviceAllowedTrafficClassifiersDidReset:
service:didSwitchActivePairedDevice:acknowledgementBlock:
sendMessageIDS:
setRapportLink:
setRapportLinkActive:
clients
pairIsNearby
setPairIsNearby:
_rapportLinkActive
_pairIsNearby
_rapportLink
_unacknowledgedMessages
_clients
_service
T@"RPCompanionLinkClient",&,V_rapportLink
TB,N,V_rapportLinkActive
T@"NSMutableDictionary",&,N,V_unacknowledgedMessages
T@"NSMutableSet",&,N,V_clients
T@"IDSService",&,V_service
TB,N,V_pairIsNearby
onCompanionNotification:data:
initWithUniverse:delegate:
didUpdateSource:withData:
enableSource
disableSource
fCompanionClient
onRetrocomputePreprocessingActivity:
triggerRetrocompute:
deleteHealthKitSamples:
retryHealthKitDeleteSamples
onRetryHealthKitDeleteSamples:
updateRetrocomputeStatus:unavailableReasons:
queryVO2MaxRetrocomputeStatusWithReply:
registerForRetrocomputeStatusUpdates:
unregisterForRetrocomputeStatusUpdates:
onRetrocomputeHealthKitSampleSavedWithStartTime:activity:
onRetrocomputeHealthKitSampleFailed:
onRetryTriggerRetrocompute:
onRetrocomputeStatusUpdate:
setRetrocomputeStatusClients:
scheduleRetrocomputePreprocessing
retrocomputeStatusClients
initWithDouble:
initWithStatus:startDate:endDate:meanDelta:
markXpcActivityDone:
executeRetrocomputePreprocessing:
sendRetroComputeAnalytics
resetRetrocomputePreProcessingActivity:withDelay:
retryTriggerRetrocompute
sortDescriptorWithKey:ascending:
bundleIdentifier
retrocomputeForSamples:withRetrocomputeHistory:
getIndexInHealthKitSamples:forSessionAttributes:withStartIndex:
retrocomputeSession:withHealthKitSample:withRetrocomputeHistory:
updateRetrocomputeHistoryPostProcessing:
persistRetrocomputeResultsToStagingTables:
updateRetrocomputeHistory:withResult:
saveStagingOutputToHealthKit:activity:
setSourceBundleIdentifier:
updateRetrocomputeLastTimestampToHealthKit:
promoteStagingData:
handleRetryTriggerRetrocompute:
deleteSessionsFromHealthKit:withRetry:
handleRetryHealthKitDeleteSamples:
predicateForObjectsWithMetadataKey:allowedValues:
deleteObjectsOfType:predicate:withCompletion:
fDeleteHealthKitSamplesAttempts
fDeleteHealthKitSamplesSuccess
fUpdateRetrocomputedDataAttempts
fUpdateRetrocomputedDataSuccess
fTriggerRetrocomputeInProgress
fPendingHealthKitWrites
_retrocomputeStatusClients
T@"NSMutableSet",&,N,V_retrocomputeStatusClients
currentDirectoryPath
startScanningWithData:
stopScanning
startScanningWithData:forType:
stopScanningForType:
power
UUIDWithString:
identifier
centralManagerDidUpdateState:
centralManager:willRestoreState:
centralManager:didDiscoverPeripheral:advertisementData:RSSI:
centralManager:didConnectPeripheral:
centralManager:didFailToConnectPeripheral:error:
centralManager:didDisconnectPeripheral:error:
centralManager:connectionEventDidOccur:forPeripheral:
centralManager:didUpdateANCSAuthorizationForPeripheral:
initWithProvider:
_homekitProvider
_homekitPower
_cbPower
initWithDelegate:queue:
setNextFireTime:
scanForPeripheralsWithServices:options:
stopScan
fetchActiveOrHeldWithReply:
syncgetDetectedCells:
syncgetIsRegisteredOnCell
syncgetRadioAccessTechnology
fetchSignalStrengthMeasurementsWithReply:
syncgetRegistrationStatus
syncgetCellTransmitStatus
syncgetActiveCall:
syncgetRefreshCellMonitor
syncgetCopyServingOperator:
syncgetCopyServingProvider:
syncgetCopyServingProviderFromCarrierBundle:
syncgetSignalStrength:
syncgetRegistrationInfoDictionary
resetModemWithReason:
dumpLogWithReason:
syncgetServingCells:addNeighborCells:
syncgetServingGsmCell:
sendNotificationToClients:notificationData:
registerForAltAccountProperty
unRegisterForAltAccountProperty
watchDidPair:
fetchIsAssociatedWithReply:
syncgetIsAssociated
fetchIsWifiAvailableWithReply:
syncgetIsWifiTrackingAvailable
syncgetIsWifiPowered
syncgetIsAvailable
programEntryScanNetworks:andExitScanNetworks:
setEntryScanNetworks:andExitScanNetworks:
setScannerEntryScanNetworks:
setScannerExitScanNetworks:
syncgetScanStats
syncgetScanResult
syncgetBackgroundScanCacheResult
fetchScanResultWithReply:
syncgetAssociatedNetwork:
syncgetHostedNetwork:
clearExitAndEntryScanNetworks:
syncgetStartScanWithType:lowPriority:passive:requester:
syncgetStartScanWithType:lowPriority:lowLatency:passive:requester:channels:
syncgetStartScanWithParameters:
syncgetStartRangingWithPeers:andTimeout:
syncgetSetAllowBeingRanged:enable:
setWifiPower:
setBackgroundExitScanCount:
syncgetSetAutoJoin:
syncgetIsWifiPoweredWithStatus:
Td,N,V_kvalue
Td,N,V_kvalueTrack
Td,N,V_score
initWithMotionState:
_motionState
queryMotionStatesWithStartTime:endTime:isFromInternalClient:withReply:
syncgetGyroStatsWithBias:slope:l2Error:isDynamic:deltaBias:deltaSlope:deltaError:isDeltaDynamic:
syncgetMaxDynamicTemperature
startFactoryGYTT
syncgetNonFactoryRoundCount
syncgetSupportsMiniCalibration
syncgetLastMiniCalibration
syncgetInsertWithBias:variance:temperature:timestamp:
dumpDatabase:onCompletion:
syncgetWipeDatabase
syncgetNumTemperatures
unregisterForUpdates:
syncgetSettingsAndRegisterForUpdates:
syncgetSetValue:forKey:withoutNotifying:
flush
refresh
didUpdateSettings:
setSettingsDictionary:
settingsDictionary
updateClientsWithDictionary:
_fDaemonPreferencesChangedNotificationToken
_fMCProfileListChangedForDaemonSettingsNotificationToken
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
registerForNotifications
_onScanTimer
startWsbClient
handleVehicularStateChanged
stopWsbClient
unregisterForNotifications
_invalidateSpeedEstimate
initWithClientLocation:
_feedLocation:
requestLocationUpdateWithParameters:
setCurrentEstimate:
prevLoc
earlierDate:
isEqualToDate:
horizontalAccuracy
timeIntervalSinceNow
setPrevLoc:
timeIntervalSinceDate:
distanceFromLocation:
scanTimer
updateStatusBarLabel
fetchVehicularDndStateAndHintsWithReply:
submitFalseDetectionMetricsWithType:
fetchVehicularFalsePositiveSuppressionStatusWithReply:
logLatencyMetricsInternal
submitLatencyMetrics
updateWsbClient:
handleMotionStateNotification:
onVisit:
onLowConfidenceVisit:
onScenarioTrigger:
feedLocation:
onWifiServiceNotification:data:
onMotionStateNotification:data:
setStatusBarWithLabel:
clearStatusBarColorAndText
currentEstimate
setScanTimer:
_universe
_vehicleStateProxy
_silo
_showActivityVehicular
_showActivityVehicularMounted
_visualIndicatorActive
_seenNonVehicularState
_motionVehicular
_wsbClientStartTime
_wifiServiceClient
_motionStateClient
_vehicularToken
_vehicularHints
_prevVehicularHints
_hintsAvailable
_vehicularStartTime
_vehicularLastNoHintsTime
_vehicularLastBTHintTime
_vehicularLastMotionHintTime
_numMotionExitsWithBT
_lastSeenVehicularTime
_sequentialVehicularIndex
_accelDetectionLatency
_gpsDetectionLatency
_basebandDetectionLatency
_wifiDetectionLatency
_btDetectionLatency
_vehicularDuration
_vehicularDurationExitFromNoHints
_vehicularDurationExitFromLastBTHint
_vehicularDurationLastBTHintFromLastMotionHint
_numConsecutiveVehicularSpeedObservations
_lastElapsedTime
_lastDistanceMoved
_valid
_prevLoc
_scanTimer
_currentEstimate
T{?=ddd},N,V_currentEstimate
T@"CLLocation",&,N,V_prevLoc
T@"CLTimer",&,N,V_scanTimer
TB,N,V_valid
syncgetDeviceUnlockedSinceFirstBoot
initWithSilo:iDSService:
setReceivedMessageHandler:
setConnectionUpdateHandler:
isConnected
pairedDevice
modelIdentifier
sendMessage:type:priority:fireAndForget:encrypt:bypassConnectionCheck:timeout:nonWaking:
operatingSystemVersion
setIdsStatus:
uniqueIDOverride
idsStatus
setPairedModelId:
setConnectionStatus:
pairedDeviceLastSeenTimestamp
initInSilo:withIdentifier:state:
initWithQueue:identifier:state:
initWithQueue:
trackerStateSize
trackerStateTypeName
initInSilo:withIdentifier:
initWithQueue:identifier:
batteryData
setBatteryData:
reachability
setReachability:
thermalLevel
setThermalLevel:
airplaneMode
setAirplaneMode:
batterySaverModeEnabled
setBatterySaverModeEnabled:
restrictedMode
setRestrictedMode:
updateState:
dumpState:withSize:hints:
_state
_identifier
_inTransaction
T{Battery=dBBiBi},N
Ti,N
airplaneModeChanged
fetchIsAirplaneModeEnabledWithReply:
fetchReachabilityWithReply:
fetchIsBatteryConnectedWithReply:
fetchWirelessModemClientCountWithReply:
syncgetAirplaneMode:
syncgetReachability
syncgetHasLingerClients
syncgetIsSleeping
notifyMigrationPerformed
syncgetRegisterPowerKeepAlive:client:dbgMessage:
triggerMetricHeartbeatNotification
syncgetThermalLevel
syncgetBatterySaverMode
hasSuffix:
decodeIntForKey:
decodeBoolForKey:
decodeFloatForKey:
encodeInt:forKey:
encodeBool:forKey:
encodeFloat:forKey:
initWithMotionActivity:
_activity
T{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi},N,V_activity
decodeInt64ForKey:
encodeInt64:forKey:
encodeObject:forKey:
macAddress
ssid
rssi
mode
channel
isApplePersonalHotspot
jsonObject
dataWithJSONObject:options:error:
initWithData:encoding:
initWithAccessPoint:
_isApplePersonalHotspot
_rssi
_mode
_channel
_macAddress
_ssid
TQ,R,N,V_macAddress
T@"NSString",R,C,N,V_ssid
Ti,R,N,V_rssi
Ti,R,N,V_mode
Ti,R,N,V_channel
Td,R,N,V_age
Td,R,N,V_timestamp
TB,R,N,V_isApplePersonalHotspot
setArchive:
initWithArchive:
archive
_archive
T@"CLHRequestArchive",&,N,V_archive
rangeOfString:options:
whitespaceCharacterSet
stringByTrimmingCharactersInSet:
caseInsensitiveCompare:
isString:prefixedBy:
isDenyListAccessory:name:model:serialNumber:firmware:hardwareRevision:
cancel
cellTowers
scdmaCellTowers
cdmaCellTowers
lteCellTowers
nr5GCellTowers
wirelessAPs
objectAtIndex:
hasSid
hasNid
hasMcc
hasBsid
bsid
hasZoneid
zoneid
hasBandclass
bandclass
hasChannel
hasPnoffset
pnoffset
location
accuracy
latitude
longitude
hasAltitude
hasVerticalAccuracy
altitude
verticalAccuracy
tacID
cellID
hasUarfcn
uarfcn
hasPid
hasMnc
hasTacID
hasCellID
hasNrarfcn
nrarfcn
processScdmaCells:inRange:timeReceived:requestType:tag:
processCells:inRange:timeReceived:requestType:tag:
surroundingWifiBandsCount
surroundingWifiBandsAtIndex:
processWireless:inRange:timeReceived:requestType:tag:surroundingWifiBands:
containsObject:
downloadPayloadSize
setFinished:
finished:
processingCellTowers
processingWirelessAPs
finished
lacID
hasArfcn
arfcn
hasPsc
macID
hasLocation
hasInfoMask
infoMask
hasScore
hasReach
reach
requester:didReceiveResponse:forRequest:
requesterDidFinish:
requesterDidCancel:
requester:didFailWithError:
requesterWillSendRequestForEstablishedConnection:callback:
initWithRequester:
addRequesterWithOutstandingRequest:
fRequestersWithOutstandingRequests
fRequester
setLatitude:
setLongitude:
setNeedCellsTowers:
setNumberOfSurroundingWifis:
sharedConfiguration
defaultForKey:defaultValue:
componentsSeparatedByString:
addWifiBands:
setWifiAltitudeScale:
URLWithString:
initWithURL:delegate:queue:
setTag:
setTimeoutSeconds:
setHttpRequestHeaders:
addRequest:
setLogRequestToFile:
setLogResponseToFile:
uploadPayloadSize
setNwActivityDomain:
setNwActivityLabel:
wirelessAPsCount
numberOfSurroundingWifis
cellTowersCount
lteCellTowersCount
cdmaCellTowersCount
nr5GCellTowersCount
numberOfSurroundingCells
numberOfSurroundingCdmaCells
numberOfSurroundingLteCells
numberOfSurroundingNr5GCells
setSid:
setNid:
setBsid:
setZoneid:
setBandclass:
setChannel:
setPnoffset:
setMcc:
addCdmaCellTower:
setMnc:
setLacID:
setCellID:
addCellTower:
addScdmaCellTower:
setTacID:
addLteCellTower:
addNr5GCellTower:
setNumberOfSurroundingCells:
setMacID:
addWirelessAP:
addSurroundingWifiBands:
array
surroundingWifiBands
stringValue
componentsJoinedByString:
wifiBandsCount
wifiBands
_delegate
_sourceEnabled
setZoneIdentifier:
authMask
setAuthMask:
setHasAuthMask:
hasAuthMask
setCorrectiveCompensationMask:
setHasCorrectiveCompensationMask:
hasCorrectiveCompensationMask
setZoneType:
setHasZoneType:
hasZoneType
setHasLatitude:
hasLatitude
setHasLongitude:
hasLongitude
setRadius:
setHasRadius:
hasRadius
setPhenolicLocation:
setHasPhenolicLocation:
hasPhenolicLocation
setServiceMaskOperator:
setHasServiceMaskOperator:
hasServiceMaskOperator
setProvenance:
setHasProvenance:
hasProvenance
clearClient
setClearClient:
setHasClearClient:
hasClearClient
zoneIdentifier
correctiveCompensationMask
zoneType
radius
phenolicLocation
serviceMaskOperator
provenance
_latitude
_longitude
_radius
_authMask
_correctiveCompensationMask
_provenance
_serviceMaskOperator
_phenolicLocation
_zoneIdentifier
_zoneType
_clearClient
T@"NSString",&,N,V_zoneIdentifier
TI,N,V_authMask
TI,N,V_correctiveCompensationMask
TI,N,V_zoneType
Td,N,V_latitude
Td,N,V_longitude
Td,N,V_radius
TI,N,V_phenolicLocation
TI,N,V_serviceMaskOperator
TI,N,V_provenance
TB,N,V_clearClient
syncgetReferenceTime:
syncgetReferenceTime:andError:
setGpsTime:
syncgetActiveTechs:
setGpsAssistantHasClients:forNotification:
setRealTimeHarvestTriggered:
syncgetZaxisStats:
startMonitoringEmergencyState:
setHarvestingEnabled:
retireServiceWithName:
stopMonitoringEmergencyState:
emergencyStateChange:
emergencySettingsChange:withReason:
shouldLockoutNilr:
setWorkoutSuggestedStopTimeout:
addClient:prepareSessionEndForSessionType:
removeClient:prepareSessionEndForSessionType:
userDismissedWorkoutAlert
triggerWorkoutLocationEventForTesting:withReply:
lastKnownIndoorOutdoorStateWithReply:
syncgetActivityOverride
syncget_prepareSessionEndForSessionType:
didExitGeoFence
didTimeoutGeoFence
initWithDelegate:withSilo:
syncgetDataAvailability
stopGeoFence
setWorkoutEvent:
workoutEvent
CLMotionActivityTypeFromCMWorkoutType:
setLocationType:
initWithBytes:length:
localizedStringFromDate:dateStyle:timeStyle:
startGeoFenceWithRadius:
CMWorkoutTypeFromCLMotionActivityType:
getAuthorizationContextOfClient:withReply:
notifierClientNumForCoparty:
locationProvider
retrieveBiasInfo
setBiasInMeters:
getAbsoluteAltitudeUncertainty
setUncertaintyInMeters:
setWeatherEstimateInMeter:
setPreviousCumulativeDeltaIOSTime:
setStatusInfo:
isInVisit
saveBiasInfo
updatePressureUncertaintyWithTime:andLat:andLon:
dElevationDPressureSA:
slopeDiffDElevationDPressureSA:
rebaseSignificantElevationWithEndTime:
sendRebaseAnalyticsWithAltitudeError:andUncertainty:andRefUncertainty:andDemAvailable:andWorkout:andReferenceSource:andCorrection:andDistance:
updateElevationBiasFromDEMBetweenBetweenStartTime:andEndTime:
latestAbsoluteAltitude
inOutdoorWorkout
getLocationSampleAltitudeAndUncertainty:andRefAltitude:andRefUncertainty:
cumulateReference:andRefAltitude:andRefVariance:andBaroElevation:andType:
centroidOfLocationVector:
updateBiasUncertaintyWithPressure:andTime:andLat:andLon:
crossEntropyOfreference:
sendVisitExitAnalyticsWithDuration:andRebaseEvent:andUncertaintyAtEntry:
setDictionary:
isIHAAuthorized
initWithUniverse:delegate:buffers:
copyCurrentBias
updateEstimatedWeatherWithCumulativeAscendingDelta:andDescendingDelta:andIosTimestamp:
updateElevationBiasBetweenStartTime:andEndTime:
updateVisitState:arrivalTime:departureTime:
announceMostRecentForcedGPS:
_dataBuffers
_weatherEstimateInMeter
_biasTimestamp
_previousBiasTimestamp
_bias
_biasPressure
_biasUncertainty
_biasUncertaintyTimestamp
_biasUncertaintyAtRebase
_pressureUncertainty
_distanceTraveled
_distanceSinceLastRebase
_fSignificantElevationEstimatorRebase
_offSetAscendedDelta
_offSetDescendedDelta
_previousCumulativeDeltaIOSTime
_biasLocation
_inVisitStatus
_shouldTakeMaxUncertainty
_lastVisitEntryTime
_locationdStartTime
_lastForcedGpsTime
_uncertaintyAtVisitEntry
_firstRebaseEventInVisit
_lastTimestampSavedRecovery
syncgetLocation_GSM:forCell:
syncgetLocation_SCDMA:forCell:
syncgetLocation_CDMA:forCell:
syncgetLocation_LTE:forCell:
syncgetLocation_CELL:forCell:
setLocation_GSM:forCell:
setLocation_SCDMA:forCell:
setLocation_CDMA:forCell:
setLocation_LTE:forCell:
setLocation_NR:forCell:
syncgetIsBroadConnection
setPrivateMode:
syncgetMetric:
syncgetQueryNearbys:forFenceKeys:
addResponseListener:
removeResponseListener:
resetRetryCounters:
syncgetBestMatchLocation:forCell:
syncgetQueryLocationsForCells:useCache:
syncgetQueryLocationsForWifis:useCache:piggyback:config:
fetchAccessoryBitSetWithReply:
setVehicleSpeedAssistance:vehicleSpeed:
setVehicleGyroAssistance:vehicleGyro:
inputStreamWithURL:
open
hasBytesAvailable
read:maxLength:
appendBytes:length:
close
main
newSharedVendorUniverseWithSilo:
fetchIsCellAvailableWithReply:
fetchDataAvailabilityWithReply:
fetchIsAccessoryConnectedWithReply:
fetchHasConnectedDevicesWithReply:
syncgetTileStats:
syncgetActivityStats
nextFireDelay
resetNotificationConsumedForIdentifier:
isiOSAppOnMac
activePairedDeviceSelectorBlock
getAllDevicesWithArchivedAltAccountDevicesMatching:
onAppUninstallationCheckActivity:
sensorWriterWillStartMonitoring:
sensorWriterDidStopMonitoring:
sensorWriter:didReceiveUpdateToConfigurationRequests:
classForSensorIdentifier:
requestRouteSummary
requestTransitSummary
requestGuidanceState
transportType
hasDestination
logRoute:
travelTime
destination
hasOrigin
origin
logTransitRoute:
guidanceLevel
hasGuidanceLevel
logState:
hasNavigationState
navigationState
hasTransportType
hasDestinationName
destinationName
hasTravelTime
possibleStops
hasStopID
stopID
hasCoordinate
scheduledLinks
hasLineID
lineID
hasScheduledDeparture
scheduledDeparture
hasScheduledArrival
scheduledArrival
hasStopFrom
stopFrom
hasStopTo
stopTo
hasTrackedTransportType
trackedTransportType
navigationListener:didChangeNavigationState:transportType:
navigationListener:didUpdateRouteSummary:
navigationListener:didUpdateTransitSummary:
navigationListener:didUpdateGuidanceState:
navigationListener:didUpdateActiveRouteData:
navigationListener:didUpdateCurrentRoadName:
navigationListener:didUpdateStepIndex:
navigationListener:didUpdateStepNameInfo:
navigationListener:didUpdateRideSelections:
navigationListener:didUpdatePositionFromSign:
navigationListener:didUpdatePositionFromManeuver:
navigationListener:didUpdatePositionFromDestination:
navigationListener:didUpdateNavigationVoiceVolume:
onDarwinNotification:data:
_enabled
_geoNavListener
_lastEtaInSeconds
_lastEtaAbsTime
_lastCoordinate
_parentNotifier
setMarkets:
removeAllObjects
addMarkets:
marketsCount
clearMarkets
marketsAtIndex:
markets
_markets
T@"NSMutableArray",&,N,V_markets
setNCatherine:
setHasNCatherine:
hasNCatherine
setNVeryLowCatherine:
setHasNVeryLowCatherine:
hasNVeryLowCatherine
setNLowCatherine:
setHasNLowCatherine:
hasNLowCatherine
setNHighCatherine:
setHasNHighCatherine:
hasNHighCatherine
setNVeryHighCatherine:
setHasNVeryHighCatherine:
hasNVeryHighCatherine
setNGoodCatherine:
setHasNGoodCatherine:
hasNGoodCatherine
setNInterpolatedCatherine:
setHasNInterpolatedCatherine:
hasNInterpolatedCatherine
setNSampleAndHoldCatherine:
setHasNSampleAndHoldCatherine:
hasNSampleAndHoldCatherine
setMinGoodCatherine:
setHasMinGoodCatherine:
hasMinGoodCatherine
setMaxGoodCatherine:
setHasMaxGoodCatherine:
hasMaxGoodCatherine
setMeanCatherine:
setHasMeanCatherine:
hasMeanCatherine
setMeanGoodCatherine:
setHasMeanGoodCatherine:
hasMeanGoodCatherine
setFirstCatherine:
setHasFirstCatherine:
hasFirstCatherine
setFirstCatherineStartTime:
setHasFirstCatherineStartTime:
hasFirstCatherineStartTime
setLongestDropout:
setHasLongestDropout:
hasLongestDropout
setTotalDropoutTime:
setHasTotalDropoutTime:
hasTotalDropoutTime
setNDropout:
setHasNDropout:
hasNDropout
onsetReason
setOnsetReason:
setHasOnsetReason:
hasOnsetReason
onsetReasonAsString:
StringAsOnsetReason:
setOnsetCatherine:
setHasOnsetCatherine:
hasOnsetCatherine
setUserMaxCatherine:
setHasUserMaxCatherine:
hasUserMaxCatherine
setPersistedMinHR:
setHasPersistedMinHR:
hasPersistedMinHR
nCatherine
nVeryLowCatherine
nLowCatherine
nHighCatherine
nVeryHighCatherine
nGoodCatherine
nInterpolatedCatherine
nSampleAndHoldCatherine
minGoodCatherine
maxGoodCatherine
meanCatherine
meanGoodCatherine
firstCatherine
firstCatherineStartTime
longestDropout
totalDropoutTime
nDropout
onsetCatherine
userMaxCatherine
persistedMinHR
_firstCatherine
_firstCatherineStartTime
_longestDropout
_maxGoodCatherine
_meanCatherine
_meanGoodCatherine
_minGoodCatherine
_nCatherine
_nDropout
_nGoodCatherine
_nHighCatherine
_nInterpolatedCatherine
_nLowCatherine
_nSampleAndHoldCatherine
_nVeryHighCatherine
_nVeryLowCatherine
_onsetCatherine
_onsetReason
_persistedMinHR
_totalDropoutTime
_userMaxCatherine
TI,N,V_nCatherine
TI,N,V_nVeryLowCatherine
TI,N,V_nLowCatherine
TI,N,V_nHighCatherine
TI,N,V_nVeryHighCatherine
TI,N,V_nGoodCatherine
TI,N,V_nInterpolatedCatherine
TI,N,V_nSampleAndHoldCatherine
Tf,N,V_minGoodCatherine
Tf,N,V_maxGoodCatherine
Tf,N,V_meanCatherine
Tf,N,V_meanGoodCatherine
Tf,N,V_firstCatherine
Tf,N,V_firstCatherineStartTime
Tf,N,V_longestDropout
Tf,N,V_totalDropoutTime
TI,N,V_nDropout
Ti,N,V_onsetReason
Tf,N,V_onsetCatherine
Tf,N,V_userMaxCatherine
Tf,N,V_persistedMinHR
userMetsSource
setUserMetsSource:
setHasUserMetsSource:
hasUserMetsSource
userMetsSourceAsString:
StringAsUserMetsSource:
truthMetsSource
setTruthMetsSource:
setHasTruthMetsSource:
hasTruthMetsSource
truthMetsSourceAsString:
StringAsTruthMetsSource:
setMetsFM:
setHasMetsFM:
hasMetsFM
userMets
setUserMets:
truthMets
setTruthMets:
metsFM
_truthMets
_userMets
_metsFM
_truthMetsSource
_userMetsSource
Td,N,V_userMets
Td,N,V_truthMets
Ti,N,V_userMetsSource
Ti,N,V_truthMetsSource
Tf,N,V_metsFM
locationServicesEnabledStatus
setLocationServicesEnabledStatus:
locationRestricted
setLocationRestricted:
setClientsAuthorizationMap:
sendGlobalAuthStatus:
transientAwareRegistrationResult
onCLEmergencyEnablementAssertion:
initWithInUseLevel:registrationResult:transientAwareRegistrationResult:serviceMaskTuple:authorizedForWidgetUpdates:
registrationResult
inUseLevel
isAuthorizedForServiceType:
authorizationContextByANDingServiceMaskTuple:
checkApplications:withReply:
syncgetForegroundApp:
initWithContentsOfFile:
allKeys
sortedArrayUsingComparator:
indexOfObject:inSortedRange:options:usingComparator:
getNumberOfInputApsUsedInWifiTileForCoordinate:withReply:
entityClass:didChangeArrowState:dueToDeauthorization:
boolForKey:defaultValue:
setWithObjects:
unarchivedObjectOfClasses:fromData:error:
errorWithDomain:code:userInfo:
isNonProvisionallyAuthorizedForServiceType:
currentLatchedAbsoluteTimestamp
stringByResolvingSymlinksInPath
enumerateObjectsUsingBlock:
localizedStringWithFormat:
extensionItemForDict:withName:withPayload:
setClientKey:
setOperationType:
addInterestZones:
setNotification:
clientKey
interestZones
startCircularZoneMonitoringForClient:withZoneId:latitude:longitude:radius:
addObject:withSyncSessionReason:
deleteObject:withSyncSessionReason:
sendNotification:
client:didChangeUsageData:
setProvisionalAuthorization:
setClients:significantLocationVisitTo:
takeInUseAssertionForClientKey:reason:assertionLevel:withReply:
wakeUpLaunchdManagedClient:
setClientBackgroundIndicator:enabled:entity:
syncgetLocationClientKeys
fetchLocationClientKeysWithReply:
syncgetNonSystemLocationClientKeys
syncgetNonSystemLocationClientKey
syncgetIsMapsANonSystemLocationClient
setClientAuthorization:zoneIdentifier:status:correctiveCompensation:entity:
appLaunchedByAppLifecycleManager:
checkAppInstallationStatus
appsWithClientKeysAreInstalledOnAPairedDevice:
setAllowableAuthorizationMask:forClientKey:
triggerClearAppClipAuthorizationIfNecessary
setTemporaryAuthorizationStatusInfoForClient:data:
syncgetTemporaryAuthorizationStatusForClient:
syncgetAndSetOrChangeAppClipAuthorizationTime:forClient:
handleProvisionalIntermediationForService:forClientKey:withReply:
updateCorrectiveCompensationChoiceForOutstandingPrompt:
syncgetSetLocationServicesEnabledStatically:withEventSource:
syncgetHasAuthorizedClients
markClientTemporaryAuthorizationGranted:forClientKey:andAuditToken:byLocationButton:voiceInteractionEnabled:
markClientEmergencyEnablementTransition:
markClientEmergencyEnablementTransition:forBeneficiary:
reduceAccuracy:withReply:
syncgetClientStaticRegistrationResult:
syncgetClientEffectiveRegistrationResultWithTransientAwareness:
setClients:regionOfType:to:
setClients:significantLocationChangeTo:
setClients:locationPushTo:
performMigration
setLastLocationSettingsEventSource:
resetClients
markReceivingLocationInformation:
setClient:
setPurpose:forClient:
syncgetCopyClients
syncgetRegistrationResultToAuthorizationStatus:
getIncidentalUseModeForClient:withReply:
registerCircularInterestZoneForClientKey:withId:latitude:longitude:serviceMaskOperator:provenanceType:radius:withReply:
registerPhenolicInterestZoneForClientKey:withId:phenolicLocation:serviceMaskOperator:provenanceType:withReply:
setRelevance:forInterestZoneWithId:registeredForClientKey:withReply:
setRelevance:forInterestZoneWithId:registeredForClientKey:
deleteInterestZoneWithId:registeredForClientKey:withReply:
setIncidentalUseMode:forClient:
syncgetApplyArchivedAuthorizationDecisionsAndDie:unlessTokenMatches:
syncgetArchivedAuthorizationDecisions
checkWeakPersistentClientWithIdentifier:
triggerAnalyticsCollect
onCapabilityChange
setSettingsChangeHandler:
arrayForKey:defaultValue:
intForKey:defaultValue:
setInt:forKey:
setArray:forKey:
startMonitoringCapabilityChangeForClient:
initOnSilo:hour:minute:second:block:
stopMonitoringCapabilityChangeForClient:
addObjectsFromArray:
cl_deepCopy
enumerateKeysAndObjectsUsingBlock:
mutableCopy
allObjects
initWithBundleIdentifier:flags:reason:name:
acquire
syncgetHasMonitoredRegions:
syncgetHasMonitoredFences:
defaultWorkspace
openSensitiveURL:withOptions:
defaultManager
removeItemAtPath:error:
stringWithCString:encoding:
fileExistsAtPath:
considerPerformingAForcedFullSync
null
objectsForKeys:notFoundMarker:
valueForKey:
lastObject
stopCircularZoneMonitoringForClient:withZoneId:
applicationProxyForCompanionIdentifier:
stringByAppendingString:
initWithStartDate:endDate:
decodeIntegerForKey:
encodeInteger:forKey:
timeRange
deviceId
vehicularState
vehicularHints
initWithTimeRange:deviceId:
initWithTimestamp:state:hints:
fTimeRange
fDeviceId
fVehicularState
fVehicularHints
T@"CMMotionTimeRange",R,N
TQ,R,N
departureDate
arrivalDate
compare:
hasArrivalDate
hasDepartureDate
coordinate
detectionDate
_placeInference
initWithCoordinate:horizontalAccuracy:arrivalDate:departureDate:detectionDate:placeInference:
_visitWithVisit:authDate:
connectClient:withKey:
startMonitoringSignificantVisitsForClient:type:
stopMonitoringSignificantVisitsForClient:
simulateVisit:
disconnectClient:
onSignificantLocationVisit:
settingsDidChange:
setClientInterest:
setClientAuthDate:
clientInterest
clientAuthDate
setRecentVisits:
setClientAuthorizationCache:
setRoutineMonitor:
setClientManager:
migrateClientInterestData
interestForClientKey:outInterest:
actOnPendingDeleteForClientKey:
clientAuthorizationCache
setArmed:
checkForMonitoring
notifyWhenCacheIsPopulatedWithReply:
ensureStop
flushAll
flushAuthDates
flushInterest
monitoring
leeching
routineMonitor
startMonitoringVisitsForClient:
setMonitoring:
stopLeechingVisitsForClient:
setLeeching:
startLeechingVisitsForClient:
stopMonitoringVisitsForClient:
recentVisits
predicateWithBlock:
filterUsingPredicate:
keyForClient:
isClientWithKeyInterested:
removeOldVisits
deliverVisit:toClient:
authorizationDateForClientWithKey:
performBlockWhenArmed:
armed
sendVisitsToClient:
clientInterestStoreSetValueForClientKey:parameterKey:value:
removeInterestForClientKey:
clientManager
notifyClientsOfVisit:
launchApplication:requiringAuthForServiceMask:
syncgetAuthorizationOfClient:forServiceMask:
interestTypeForClientKey:outType:
ensureMonitoringWithType:
clientInterestStoreGetValueForClientKey:parameterKey:value:
dictionaryForKey:defaultValue:
doubleForKey:defaultValue:
distantFuture
initWithCoordinate:horizontalAccuracy:arrivalDate:departureDate:detectionDate:
onClientManagerNotification:data:
onInterestStoreTimer
onAuthDateStoreTimer
currentJournalIdentifier
setCurrentJournalIdentifier:
_clientManagerClient
_clientToKey
fSettings
_monitoring
_leeching
_armed
_clientInterest
_clientAuthDate
_clientAuthorizationCache
_recentVisits
_routineMonitor
_clientManager
_currentJournalIdentifier
TB,N,V_monitoring
TB,N,V_leeching
T^v,N,V_clientInterest
T^v,N,V_clientAuthDate
T@"<CLClientAuthorizationCacheProtocol>",&,N,V_clientAuthorizationCache
T@"NSMutableArray",&,N,V_recentVisits
T@"<CLRoutineMonitorServiceProtocol>",&,N,V_routineMonitor
T@"<CLClientManagerPublicProtocol>",&,N,V_clientManager
TB,N,V_armed
TQ,N,V_currentJournalIdentifier
fLocationControllerClient
_currentUnderDEM
propertyListWithStream:options:format:error:
pairingID
supportsCapability:
isWorkoutStartReminderEnabledWhenDeviceIsSatellitePaired:isInMoveTimeMode:withCurrentSetting:
isWorkoutEndReminderEnabledWhenDeviceIsInMoveTimeMode:withCurrentSetting:
isDeviceSatellitePaired
setLocationFingerprints:
addLocationFingerprint:
locationFingerprintsCount
clearLocationFingerprints
locationFingerprintAtIndex:
locationFingerprints
_locationFingerprints
T@"NSMutableArray",&,N,V_locationFingerprints
onMotionStateMediatorNotification:data:
onStepCountNotification:data:
onAddBout:
fMotionStateMediatorClient
fStepCountClient
fBoutDetector
initWithElevationSubscription:
_elevationSubscription
initWithFilteredElevation:
initWithAltitude:accuracy:precision:status:timestamp:
effectiveOnWristState
sensorOnWristState
isDeviceOnCharger
isForceOnWristEnabled
isWristDetectDisabled
onWristMonitor:didUpdateOnWristState:fromState:
setQueue:
activate
registerFileForCollection:
unregisterFileForCollection:
registeredFiles
mobileCrashReporterPath
pathForDate:withBasePath:
fileManager
createDirectoryAtURL:withIntermediateDirectories:attributes:error:
copyItemAtURL:toURL:error:
copyRegisteredFilesWithHandler:
initWithString:
fileManager:shouldCopyItemAtPath:toPath:
fileManager:shouldCopyItemAtURL:toURL:
fileManager:shouldProceedAfterError:copyingItemAtPath:toPath:
fileManager:shouldProceedAfterError:copyingItemAtURL:toURL:
fileManager:shouldMoveItemAtPath:toPath:
fileManager:shouldMoveItemAtURL:toURL:
fileManager:shouldProceedAfterError:movingItemAtPath:toPath:
fileManager:shouldProceedAfterError:movingItemAtURL:toURL:
fileManager:shouldLinkItemAtPath:toPath:
fileManager:shouldLinkItemAtURL:toURL:
fileManager:shouldProceedAfterError:linkingItemAtPath:toPath:
fileManager:shouldProceedAfterError:linkingItemAtURL:toURL:
fileManager:shouldRemoveItemAtPath:
fileManager:shouldRemoveItemAtURL:
fileManager:shouldProceedAfterError:removingItemAtPath:
fileManager:shouldProceedAfterError:removingItemAtURL:
setRegisteredFiles:
setFileManager:
_registeredFiles
_fileManager
T@"NSURL",R,N
T@"NSMutableSet",&,N,V_registeredFiles
T@"NSFileManager",&,N,V_fileManager
resetBytesInRange:
coarseMetadata
fetchCoarseEquivalentForLocation:callbackQueue:callback:
_coarseLocationProvider
initWithGEOCoordinate:
setHorizontalAccuracy:
setReferenceFrame:
setCourse:
latLng
setTiles:
addTiles:
tilesCount
clearTiles
tilesAtIndex:
setNorthWestLatitude:
setHasNorthWestLatitude:
hasNorthWestLatitude
setNorthWestLongitude:
setHasNorthWestLongitude:
hasNorthWestLongitude
setSouthEastLatitude:
setHasSouthEastLatitude:
hasSouthEastLatitude
setSouthEastLongitude:
setHasSouthEastLongitude:
hasSouthEastLongitude
northWestLatitude
northWestLongitude
southEastLatitude
southEastLongitude
tiles
_northWestLatitude
_northWestLongitude
_southEastLatitude
_southEastLongitude
_tiles
Td,N,V_northWestLatitude
Td,N,V_northWestLongitude
Td,N,V_southEastLatitude
Td,N,V_southEastLongitude
T@"NSMutableArray",&,N,V_tiles
bundleWithPath:
initWithEffectiveBundle:delegate:onQueue:
startStopCircularZoneMonitoringForClient:withZoneId:latitude:longitude:radius:shouldStart:
initNearbyAllowedWithCenter:radius:identifier:
setNotifyOnEntry:
setNotifyOnExit:
initWithCenter:radius:identifier:
startMonitoringForRegion:
stopMonitoringForRegion:
_locationManager
substringToIndex:
substringFromIndex:
initWithContentsOfURL:options:error:
setCurrentGranularity:
stopLocation
stopMotionAlarm
sendMotionState
setStreamingConnection:
streamingConnection
setAliveAgainThrottleTimer:
sendAliveAgainMessage
aliveAgainThrottleTimer
resendMotionStateTimer
setResendMotionStateTimer:
unregisterAllLocationNotifications
setEmergencyEnablementAssertionActive:
setLocationUpdatesIncludeMotionState:
reevaluateMotionSubscription
setClientActivityTypeFitnessActive:
setClientActivityTypeAirborneActive:
setClientMapMatchingActive:
currentGranularity
locationUpdatesIncludeMotionState
initWithDaemonLocationPrivate:
initWithDaemonLocation:
motionAlarmActive
isSubscribedForMotion
setIsSubscribedForMotion:
setMotionAlarmActive:
startUpdatingLocationWithGranularity:includeMotion:inFitnessSession:inAirborneSession:emergencyEnablementAssertionActive:hasMapMatching:
startMotionAlarm
onLocationNotification:withData:
onMotionStateNotification:withData:
isClientActivityTypeFitnessActive
isClientActivityTypeAirborneActive
emergencyEnablementAssertionActive
isClientMapMatchingActive
_locationClient
_locationAssertion
_motionAlarmAssertion
_lastMotionActivity
_locationUpdatesIncludeMotionState
_clientActivityTypeFitnessActive
_clientActivityTypeAirborneActive
_motionAlarmActive
_isSubscribedForMotion
_emergencyEnablementAssertionActive
_clientMapMatchingActive
_currentGranularity
_resendMotionStateTimer
_streamingConnection
_aliveAgainThrottleTimer
Ti,N,V_currentGranularity
TB,N,V_locationUpdatesIncludeMotionState
clientActivityTypeFitnessActive
TB,N,GisClientActivityTypeFitnessActive,V_clientActivityTypeFitnessActive
clientActivityTypeAirborneActive
TB,N,GisClientActivityTypeAirborneActive,V_clientActivityTypeAirborneActive
TB,N,V_motionAlarmActive
TB,N,V_isSubscribedForMotion
T@"CLTimer",&,N,V_resendMotionStateTimer
TB,N,V_emergencyEnablementAssertionActive
clientMapMatchingActive
TB,N,GisClientMapMatchingActive,V_clientMapMatchingActive
T@"<CLLocationStreamingConnectionManagerServiceProtocol>",&,N,V_streamingConnection
T@"CLTimer",&,N,V_aliveAgainThrottleTimer
snapLocation:withReply:
initInUniverse:withDelegate:
enable
disable
syncSetNavigationStateChange:
clearLocationData
notifyFromLastInfo
requestForSchedulingTileDownload:
stopListeningForForScheduledTileDownload:
onScheduledTileDownloadWithReachabilityRequirement:
hasRegisteredForWifiConnectivity
scheduleDownloadsWithWifiConnectivity
hasRegisteredForCellularConnectivity
scheduleDownloadsWithCellularConnectivity
setHasRegisteredForWifiConnectivity:
setHasRegisteredForCellularConnectivity:
_hasRegisteredForWifiConnectivity
_hasRegisteredForCellularConnectivity
T@"NSMutableArray",&,N,V_clients
TB,N,V_hasRegisteredForWifiConnectivity
TB,N,V_hasRegisteredForCellularConnectivity
workoutName:
gradient
gradientValidity
initWithTrack:session:
setGradient:
_gradient
_gradientValidity
T@"CalibrationTrack",R,&,N,V_track
Tq,R,N,V_session
Td,N,V_gradient
Tq,R,N,V_gradientValidity
setState:
Tq,N,V_state
initWithTimestamp:RSSI:uuid:ipv4:channel:
RSSI
uuid
ipv4
_RSSI
_ipv4
_uuid
T{time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>>={duration<long double, std::ratio<1, 1>>=D}},R,N,V_timestamp
Ti,R,N,V_RSSI
T@"NSUUID",R,N,V_uuid
TI,R,N,V_ipv4
beginServiceWithAirPlaySolo:
setAirplaySolo:
airplaySolo
setPower:
setScanDeliveryDelayTimer:
sendBufferedScanNotifications
scanDeliveryDelayTimer
setBufferedDevices:
releaseData
removeClient:
getPowerWithCompletion:
bufferedDevices
airPlaySoloDidUpdateState:
airPlaySolo:foundDevice:withData:
airPlaySoloStartedScanning:
airPlaySoloStoppedScanning:
airPlaySolo:failedToStartScanningWithError:
_power
_airplaySolo
_scanDeliveryDelayTimer
_bufferedDevices
T@"WPAirPlaySolo",&,N,V_airplaySolo
TB,N,V_power
T@"CLTimer",&,N,V_scanDeliveryDelayTimer
T@"NSMutableArray",&,N,V_bufferedDevices
logBins
quitForcedLocationState
initWithSilo:
setupCLNotifiers
teardownCLNotifiers
inOutdoorPedestrianSession
checkForLocationStateTransition
isCalibrationConvergedMedianForSpeed:
updateCalibrationBins:
locationState
requestTransitionToLocationState:
outOfSession
isRunningStateInWindow
attemptForcedLocation
isCalibrationConvergedStdForBinWithSpeed:
activityLoggerLogStrideCalEntry:
startLeechingLocation
startGpsOdometerSpectatorUpdates
startElevationSpectatorUpdates
stopLeechingLocation
stopGpsOdometerSpectatorUpdates
stopElevationSpectatorUpdates
startLocationUpdates
startGpsOdometerUpdates
startElevationUpdates
stopLocationUpdates
stopGpsOdometerUpdates
stopElevationUpdates
currentSession
addLatestCalData:
tickleArrow
stop
distanceRawPed
awdLogDistance:status:description:
isRawSpeedValid:
distanceGps
updateGradient:
checkValidTrack:associatedEntry:
isRawSpeedRun:
updateBinsWithTrack:
gpsSource
addEntry:
awdMotionFitnessStrideCalibration:
removeObjectsInArray:
updateUserHeight:
copyHistory
strideCalibrationDatabase:didInsertEntry:
fsm:didTransitionFromState:toState:
fsm:didYieldTrack:
fsm:didUpdateLocationAtTime:
fsm:didUpdateSource:
initInUniverse:stepCountDb:
tick:
fOdometerClient
fServiceLocationProvider
fServiceLocationClient
fClientAuthorizationCache
fStreamingAwareLocationClient
fStreamingAwareProxy
fMotionStateClient
fUniverse
fStopOpportunisticCalibrationTimer
fActivityBuffer
fElevationBuffer
fStepsBuffer
fStats
fDatabase
fStrideCalLocationFSM
fLatestCalDataArray
fStepCountDb
fLastGoodLocFix
fCurrentSession
isMessageOfType:
dataPayload
setDataPayload:
_dataPayload
T@"NSDictionary",&,N,V_dataPayload
message
setMessage:
error
setError:
recoverable
setRecoverable:
_recoverable
_message
_error
T@"CLClientManagerUsageSyncMessage",&,N,V_message
T@"NSError",&,N,V_error
TB,N,V_recoverable
onStatusBarIconChange:
setErrorQueue:
setMessagesWaitingForAck:
setPairedDeviceRegistry:
handleUnpairNotification_bounce:
handlePairNotification_bounce:
handleActiveNotification_bounce:
handleInactiveNotification_bounce:
getActivePairedDevice
valueForProperty:
handleUnpair
handlePair
setPairedDeviceID:
isPaired
requestFullResync
sendAllUsageSyncData
setRetryTimer:
drainErrorQueue
removeDelegate:
pairedDeviceID
handleMessageError:
addMessageToErrorQueue:
_sendMessage:identifier:error:
messageFailedToSend:withError:recoverable:
messagesWaitingForAck
sendMessageWithMessageType:dataPayload:priority:idsOptions:
client:didChangeUsageDataInternal:
onStatusBarIconChangeInternal:
setValue:forKey:
mungedUsageDataForPotentiallyOldUsageData:
handleMessageSendError:identifier:
handleMessageSendSuccessForIdentifier:
handleMessageUsageUpdateWithMessageData:
handleMessageResyncRequestWithMessageData:
handleMessageResyncResponseWithMessageData:
activeDeviceNearbyStatus
setActiveDeviceNearbyStatus:
dirtyUsageSyncState
setDirtyUsageSyncState:
needFullResync
setNeedFullResync:
pairedDeviceRegistry
retryTimerSet
setRetryTimerSet:
retryTimer
errorQueue
_lastStatusBarIconState
_coalescingUpdates
_dirtyUsageSyncState
_needFullResync
_retryTimerSet
_activeDeviceNearbyStatus
_pairedDeviceID
_pairedDeviceRegistry
_retryTimer
_errorQueue
_messagesWaitingForAck
T@"<CLClientManagerPublicProtocol>",R,N
TB,N,V_dirtyUsageSyncState
TB,N,V_needFullResync
T@"NSUUID",&,N,V_pairedDeviceID
T@,&,N,V_pairedDeviceRegistry
TB,N,V_retryTimerSet
T@"CLTimer",&,N,V_retryTimer
T@"NSMutableArray",&,N,V_errorQueue
T@"NSMutableDictionary",&,N,V_messagesWaitingForAck
Ti,N,V_activeDeviceNearbyStatus
setMacs:
macsType
T@"NSMutableArray",&,N,V_macs
convertToSkiEntry:
manager
setManager:
_manager
T^v,N,V_manager
addFence:
removeFence:
requestRegionState:
requestAllHandoffTags
performPendingHandoffFencesSyncToCompanion
fenceHandedOffToCompanion:
handedOffFenceRemovedFromCompanion:
syncgetFences:forKey:
drain
motionAlarmSubscription
fireAlarm:error:
initWithMotionAlarmSubscription:
setMotionAlarmSubscription:
_motionAlarmSubscription
T^v,N,V_motionAlarmSubscription
unregisterClient:
registerAlarm:withReply:
unregisterAlarm:withReply:
acknowledgeAlarm:withReply:
launchRemoteApplication:withReply:
registerClient:adapter:
setKey:
hasKey
setValue:
setHasValue:
hasValue
_key
T@"NSString",&,N,V_key
TI,N,V_value
replaceBytesInRange:withBytes:length:
fetchMacAddressesAmong:nearLatitude:longitude:withReply:
syncgetTransitMacAddressesAmong:nearLatitude:longitude:resultMacAddresses:
initWithMacAddress:
onDarwinNotifierNotification:data:
_darwinNotifierClient
machineFrequency
setMachineFrequency:
_machineFrequency
Tf,N,V_machineFrequency
feedTremor:
onResultAvailable:
feedGyro:
T@"<CLHealthAssessmentResultDelegate>",N,V_delegate
delegate
setSyncRestriction:
_activeSyncSession
_syncRestriction
T@"NSString",R,C,N,V_serviceName
T@"PSYServiceSyncSession",R,N,V_activeSyncSession
T@"<PSYSyncCoordinatorDelegate>",N,V_delegate
TQ,N,V_syncRestriction
setDidComplete:
syncDidFailWithError:
didComplete
setSyncSessionType:
_didComplete
_syncSessionType
TB,N,V_didComplete
TQ,N,V_syncSessionType
requestInitialSyncStateForPairingIdentifier:completion:
requestSyncStateForPairingIdentifier:completion:
startSessionMetricsWithTime:session:
loadLastAWDTimestamps
setStrideCalData:
strideCalData
storeLastAWDTimestamps
endSessionMetrics:
setReadyForSubmission
fSessionMetrics
fHeightCM
fLastAWDTimestamps
_description
_transaction
initWithCString:encoding:
setTimerWithInterval:
bounce_timerFired:
initWithTimeInterval:serviceIdentifier:target:selector:userInfo:
setMinimumEarlyFireProportion:
setDisableSystemWaking:
mainRunLoop
scheduleInRunLoop:
timerFired:
initWithFireTime:timeInterval:serviceIdentifier:wakeDevice:clTimer:silo:minimumEarlyFireProportion:
_pcTimer
_clTimer
_strIdentifier
_serviceIdentifier
_wakeDevice
_timeInterval
_minimumEarlyFireProportion
heartRate
_heartRate
TI,N,V_mode
Tf,N,V_confidence
Tf,N,V_heartRate
initWithStartDate:recordId:activityType:mets:natalies:basalNatalies:sourceId:
adapter
setAdapter:
setName:
_adapter
_name
T@"<CLMotionAlarmNotifierClientProtocol>",&,N,V_adapter
T{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB},N,V_name
launchWatchApplicationForCompanion:
onClassATimerActivity:withAlarmId:
allValues
duration
repeats
alarmId
setAlarmId:
initWithTrigger:duration:onQueue:forClient:withHandler:
allKeysForObject:
unsignedLongLongValue
syncgetIsApplicationInstalledLocally:
dataUsingEncoding:
launchDaemon:
pathExtension
stringByDeletingPathExtension
extensionIdentifieForCompanionApplicationBundleIdentifier:
setStrokeAmp:
setHasStrokeAmp:
hasStrokeAmp
setStrokeFrequency:
setHasStrokeFrequency:
hasStrokeFrequency
strokePower
setStrokePower:
strokeAmp
strokeFrequency
_strokeAmp
_strokeFrequency
_strokePower
Tf,N,V_strokePower
Tf,N,V_strokeAmp
Tf,N,V_strokeFrequency
onDataCollectionChangedNotification
isHealthDataAvailable
loadCache
dateWithTimeIntervalSinceNow:
startOfDayForDate:
NSDateToNSStringKey:
ageOutCache:
setupStoreCacheTimer
setupQueryTimer
NSDictionaryToMotionFitnessDailyStruct:
storeCache:
createUUID
CFAbsoluteTimeToNSStringKey:
MotionFitnessDailyStructToNSDictionary:
createCache
isIDValid:
removeObjectsForKeys:
UUID
defaultCStringEncoding
numberWithLongLong:
unsignedIntValue
longLongValue
initDataDictForDay:
truncateLatLong:
runQueries
resetQueryState
querySources
dateWithTimeInterval:sinceDate:
_productType
queryWatchWorkouts
queryPhoneDailyStepCount
initWithSampleType:samplePredicate:completionHandler:
queryWatchDailyStepCount
queryWorkouts:endDate:workoutsHandler:
queryStepCount:endDate:sources:stepCountHandler:
queryWatchStandHours
predicateForObjectsFromSources:
arrayWithObjects:
setHour:
initWithQuantityType:quantitySamplePredicate:options:anchorDate:intervalComponents:
sumQuantity
enumerateStatisticsFromDate:toDate:withBlock:
setInitialResultsHandler:
queryPhoneFlightsClimbed
queryStandHours:endDate:standHoursHandler:
queryPhoneStaticTime
queryFlightsClimbed:endDate:flightsClimbedHandler:
predicateForObjectsFromDevices:
initWithQuantityType:quantitySamplePredicate:options:completionHandler:
queryStaticTime:endDate:staticTimeHandler:
stationary
onLocationNotification:data:
onAppMonitorNotification:data:
fServiceEnabled
fStoreCacheTimer
fDataCache
fMotionStateProxy
fLocationClient
fCompanionNotifierClient
fAppMonitorClient
fEncryptedDataAvailable
fQueryState
fQueryTimer
fHealthStore
fHKQueryStartDate
fPhoneSources
fWatchSources
fPendingPhoneDailyStepCountQueries
fPendingWatchDailyStepCountQueries
fPendingWatchWorkoutQueries
fPendingWatchStandHoursQueries
fPendingPhoneFlightsClimbedQueries
fPendingPhoneStaticTimeQueries
fBeginStaticTime
fBeginWatchConnectedTime
syncService
setFullSyncObjectsInCompanionQueue:
setFullSyncObjectsInGizmoQueue:
setDeltaSyncObjectsInCompanionQueue:
setDeltaSyncObjectsInGizmoQueue:
setNotificationsInCompanionQueue:
setNotificationsInGizmoQueue:
setPreDaytonaMapping:
setShouldSendMoreDataInCurrentSyncSession:
setShouldConfirmHandlingPairingNotification:
setShouldConfirmHandlingQuickSwitchNotification:
setResetRecoveryMode:
setRecoverySyncInProgress:
setIsThereAWatch:
setIsDeviceNearbyAndConnected:
setIsQuickSwitchInProgress:
setIsConflictResolutionMode:
setCurrentSyncSessionCollidedWithResetSync:
setWatchProductVersion:
setAuthSyncStoreState:
setSyncSessionRetryInterval:
setNumberOfConsecutiveSyncSessionRetries:
setReunionSyncLists:
setReunionSyncListPaths:
updateActivePairedDeviceInfo
setGizmoDeltaSyncObjects:
setGizmoDeltaSyncObjectsWaitingForAck:
setIsQuickSwitchModeOn:
checkSyncStoreStateAfterBoot
setSyncService:
watchProductVersion
updateQuickSwitchMode
prepareToDoMigrationSync
shouldSendResetNotificationDuringMigrationSyncIgnoringCache:
resetSyncStateKeysRetainingResetKeys:
authSyncStoreState
updateSyncStoreState:
fullPathForSyncState
createSyncStoreState
watchNeedsFullSync:
locationServicesToggleAsNotification
gizmoDeltaSyncObjects
watchNeedsDeltaSync:
gizmoDeltaSyncObjectsWaitingForAck
checkSyncStoreState
checkResetNotificationStatus
setPairedDeviceUUID:
pairedDeviceUUID
setFullPathForSyncState:
setIsCorrectiveCompensationSupported:
addVectorClocks:
isCorrectiveCompensationSupported
isSending
reason
isResetSync
wasCancelled
targetIsInProximity
sessionStalenessInterval
numberOfConsecutiveSyncSessionRetries
updateRetrySyncInterval:
currentSyncSessionCollidedWithResetSync
syncSessionRetryInterval
watchMigrationDidEnd
hasNotification
notification
containsString:
mainBundle
executablePath
applyAddMessage:
applyUpdateMessage:
applyDeleteMessage:
vectorClocksCount
vectorClocks
translatedKeyForSimulator:
isDeviceNearbyAndConnected
setNeedsResetSync
nsuuid
checkSyncStoreStateWhenDevicesConnectAfterDisconnection
setActivePairingID:
handlePairing
setFullSyncClientsList:
setReason:
shouldSendMoreDataInCurrentSyncSession
updateReunionSyncListsWithAuthSyncMessageKey:
fullSyncClientsList
applySyncMessage:
endPairedSyncSessionWithError:
handleError:inSyncSession:
fullSyncDidComplete
deltaSyncDidComplete:
isWatchBuildVersionPriorTo:
deviceDidPairNotification:
deviceDidUnpairNotification:
watchMigrationDidStart
handleQuickSwitch
syncReunionSyncList
clearReunionSyncList
updateSyncStoreStateForVersionedKey:withUpdateReason:
checkSyncStoreStateOnCompanion
checkSyncStoreStateAfterQuickSwitch
checkSyncStoreStateAftreRestrictionChange
checkAllNotificationStatuses
handleZeroActiveWatch
handleUnpairing
prepareToDoFullSync
prepareToDoReunionSync
getFullSyncObjects
resetAsNotifcation
migrationSyncResetVersionNumbersNotification
translateCompanionSyncAuthObjectsInPlace:
getTranslatedGizmoKeyForCompanionClient:
isResetNotificationQueued
reunionSyncDidComplete:
fullSyncObjectsInCompanionQueue
fullSyncObjectsInGizmoQueue
deltaSyncObjectsInCompanionQueue
deltaSyncObjectsInGizmoQueue
notificationsInCompanionQueue
notificationsInGizmoQueue
preDaytonaMapping
shouldConfirmHandlingPairingNotification
shouldConfirmHandlingQuickSwitchNotification
resetRecoveryMode
recoverySyncInProgress
isThereAWatch
isQuickSwitchModeOn
isConflictResolutionMode
activePairingID
reunionSyncListPaths
reunionSyncLists
isQuickSwitchInProgress
_shouldConfirmHandlingPairingNotification
_shouldConfirmHandlingQuickSwitchNotification
_shouldSendMoreDataInCurrentSyncSession
_resetRecoveryMode
_recoverySyncInProgress
_isThereAWatch
_isCorrectiveCompensationSupported
_isDeviceNearbyAndConnected
_isQuickSwitchModeOn
_isConflictResolutionMode
_currentSyncSessionCollidedWithResetSync
_isQuickSwitchInProgress
_watchProductVersion
_fullPathForSyncState
_syncService
_fullSyncObjectsInCompanionQueue
_fullSyncObjectsInGizmoQueue
_deltaSyncObjectsInCompanionQueue
_deltaSyncObjectsInGizmoQueue
_gizmoDeltaSyncObjects
_gizmoDeltaSyncObjectsWaitingForAck
_notificationsInCompanionQueue
_notificationsInGizmoQueue
_preDaytonaMapping
_activePairingID
_pairedDeviceUUID
_authSyncStoreState
_fullSyncClientsList
_reunionSyncListPaths
_reunionSyncLists
_syncSessionRetryInterval
_numberOfConsecutiveSyncSessionRetries
T@"NSString",&,N,V_fullPathForSyncState
T@"SYService",&,N,V_syncService
T@"NSMutableArray",&,N,V_fullSyncObjectsInCompanionQueue
T@"NSMutableArray",&,N,V_fullSyncObjectsInGizmoQueue
T@"NSMutableArray",&,N,V_deltaSyncObjectsInCompanionQueue
T@"NSMutableArray",&,N,V_deltaSyncObjectsInGizmoQueue
T@"NSMutableArray",&,N,V_gizmoDeltaSyncObjects
T@"NSMutableArray",&,N,V_gizmoDeltaSyncObjectsWaitingForAck
T@"NSMutableArray",&,N,V_notificationsInCompanionQueue
T@"NSMutableArray",&,N,V_notificationsInGizmoQueue
T@"NSDictionary",&,N,V_preDaytonaMapping
TB,N,V_shouldConfirmHandlingPairingNotification
TB,N,V_shouldConfirmHandlingQuickSwitchNotification
TB,N,V_shouldSendMoreDataInCurrentSyncSession
TB,N,V_resetRecoveryMode
TB,N,V_recoverySyncInProgress
TB,N,V_isThereAWatch
TB,N,V_isCorrectiveCompensationSupported
TB,N,V_isDeviceNearbyAndConnected
TB,N,V_isQuickSwitchModeOn
TB,N,V_isConflictResolutionMode
TB,N,V_currentSyncSessionCollidedWithResetSync
T@"NSUUID",&,N,V_activePairingID
T@"NSUUID",&,N,V_pairedDeviceUUID
TI,N,V_watchProductVersion
T@"NSMutableDictionary",&,N,V_authSyncStoreState
T@"NSMutableArray",&,N,V_fullSyncClientsList
T@"NSMutableDictionary",&,N,V_reunionSyncListPaths
T@"NSMutableDictionary",&,N,V_reunionSyncLists
TB,N,V_isQuickSwitchInProgress
Td,N,V_syncSessionRetryInterval
Tq,N,V_numberOfConsecutiveSyncSessionRetries
processInfo
processName
initWithFormat:
initWithMachServiceName:options:
registerForPushToken:completion:
setLocationPushesActive:forAppBundleIdentifier:completion:
connect
sharedRegistrar
setIdentifier:
setDataIdentifier:
setOffset:
catherine
setAllDayHeartRate:
allDayHeartRate
setMode:
setHeartRate:
maxExerciseMinuteDataEntries
initWithValue:dirty:
dirty
setDirty:
_dirty
T@,R,&,N,V_value
TB,N,V_dirty
arrayWithArray:
initWithLong:
isEqualToDictionary:
unarchivedObjectOfClass:fromData:error:
simulateEvent:
setHgalCaptureMode:
onClientAnomalyEventSubscriptionRequest:
absoluteTimestamp
response
resolution
sosState
operatingMode
setDateFormat:
stringFromDate:
initToDirectory:prefix:rotation:
encodeBinaryLog:
writeOtherFallLoggerData:otherLoggerDirectory:otherLoggerFilePrefix:destinationLogger:
flushToFile
stopLogging
contentsOfDirectoryAtPath:error:
rangeOfString:
pathWithComponents:
dataWithContentsOfFile:
getSysdiagnoseOutputPath
getSysdiagnoseOutputFilename
writeAnomalyInfoToFileWithLastFallEvent:writeMask:fallNotifierConfig:stateLogger:statsLogger:sensorsLogger:pressureLogger:heartRateLogger:wristStateLogger:odometerLogger:falsePositiveSuppressionFeaturesLogger:hgalLogger:logDirectory:logFilePrefix:
currentFilename
fileHandleForReadingAtPath:
copyDataFrom:to:
closeFile
clearAllLogs
clearLogs
setWithSet:
cleanUp:
clearUUID
addLogger:
setLoggingEnabled:
sendData:completion:
logSensorType:data:startTime:timestamp:
logAccel100:startTime:timestamp:
logGyro100:startTime:timestamp:
sendData:metaData:start:end:
trigger:metaData:start:end:response:resolution:isNearFall:isFallSubmissionAllowed:isNearFallSubmissionAllowed:
logOdometer:
isLoggingEnabled
logImpactEvent:
logFallStats:
logImpactEventState:
logFallState:
logWristState:
flushData:userProfile:
cleanUpIncludingDerivedFeatures:
orientation
numberWithChar:
logImpactSensorData:
logAccel800:
logGyro200:
logDeviceMotion:
logFalsePositiveSuppressionFeatures:
logSuppressionFeartures:
logPressure:
encodePressure:
logHeartRate:
encodeHeartRate:
setOrientation:
getUUID
hasPairedModelId
connectionStatus
pairedModelId
_connectionStatus
_pairedModelId
TI,N,V_connectionStatus
T@"NSString",&,N,V_pairedModelId
setFEED2:
fEED2
locationManager:didUpdateToLocation:fromLocation:
locationManager:didUpdateLocations:
locationManager:didUpdateHeading:
locationManagerShouldDisplayHeadingCalibration:
locationManager:didDetermineState:forRegion:
locationManager:didRangeBeacons:inRegion:
locationManager:rangingBeaconsDidFailForRegion:withError:
locationManager:didRangeBeacons:satisfyingConstraint:
locationManager:didFailRangingBeaconsForConstraint:error:
locationManager:didEnterRegion:
locationManager:didExitRegion:
locationManager:didFailWithError:
locationManager:monitoringDidFailForRegion:withError:
locationManager:didChangeAuthorizationStatus:
locationManagerDidChangeAuthorization:
locationManager:didStartMonitoringForRegion:
locationManagerDidPauseLocationUpdates:
locationManagerDidResumeLocationUpdates:
locationManager:didFinishDeferredUpdatesWithError:
locationManager:didVisit:
initWithEED2Pointer:
_fEED2
T^v,V_fEED2
defaultSessionConfiguration
setAllowsCellularAccess:
sessionWithConfiguration:
initWithBase64EncodedString:options:
newAssertionForBundle:withReason:
dataWithLength:
mutableBytes
timeIntervalSince1970
requestWithURL:
setHTTPMethod:
uploadTaskWithRequest:fromData:completionHandler:
stringByReplacingOccurrencesOfString:withString:
setValue:forHTTPHeaderField:
clientInfoHeader
base64EncodedStringWithOptions:
valueForHTTPHeaderField:
statusCode
setBias:withMagneticField:level:magnitude:inclination:
getBiasWithMagneticField:acceleration:
syncgetLookupBiasWithMagneticField:acceleration:bias:level:noResults:
ageOutMotionStateArray
feedMotionStateData:
fActivityWindow
removeAllClients
setCdRegistration:
setContext:
registerCallback
deregisterCallback
cdRegistration
context
registerCallback:
predicate
keyPaths
deregisterCallback:
_context
_cdRegistration
T@"<_CDContext>",&,N,V_context
T@"_CDContextualChangeRegistration",&,N,V_cdRegistration
event
setEvent:
setPredicate:
duetIdentifier
setDuetIdentifier:
withEvent:andPredicate:
_event
_predicate
_duetIdentifier
Tq,N,V_event
T@"_CDContextualPredicate",&,N,V_predicate
T@"NSString",&,N,V_duetIdentifier
setRegisteredEvents:
startMonitoringForegroundAppLaunchForClient:
stopMonitoringForegroundAppLaunchForClient:
startMonitoringAudioOutputRouteConnectedForClient:
stopMonitoringAudioOutputRouteConnectedForClient:
startMonitoringBluetoothConnectedForClient:
stopMonitoringBluetoothConnectedForClient:
startMonitoringHomeKitAppViewForClient:
stopMonitoringHomeKitAppViewForClient:
keypathForEvent:
predicateForEvent:withKeyPath:
stopMonitoringEvent:withPredicate:forClient:
registerClient:forEvent:withPredicate:
registeredEvents
registerWithDuetForEvent:andPredicate:
userContext
notifyClient:ofEvent:withValue:
registrationWithIdentifier:contextualPredicate:dismissalPolicy:deviceSet:mustWake:callback:
eventTypeFromNSNumber:
keyPathForAudioOutputDataDictionary
keyPathForBluetoothDataDictionary
keyPathForFirstWakeupStatus
keyPathForAppDataDictionary
keyPathForHomeKitAppViewDataDictionary
keyPathForHomeKitAccessoryDataDictionary
keyPathForHomeKitSceneDataDictionary
keyPathForNowPlayingDataDictionary
predicateForAudioOutputStatus:
predicateForBluetoothConnectionStatus:
predicateForFirstWakeOfDay
predicateForChangeAtKeyPath:
audioOutputRouteStream
bluetoothIsConnectedStream
userIsFirstBacklightOnAfterWakeup
appInFocusStream
homeKitAppViewStream
homeKitAccessoryControlStream
homeKitSceneStream
notifyClient:ofForegroundAppWithValue:
notifyClient:ofHomeKitScene:
notifyClient:ofHomeKitAccessory:
notifyClient:ofHomeKitAppView:
notifyClient:ofNowPlaying:
appBundleIdKey
appLaunchReasonKey
sceneHomeUUID
sceneClientName
accessoryHomeUUID
accessoryClientName
viewHomeUUID
nowPlayingBundleIdKey
nowPlayingStatusKey
nowPlayingTrackKey
nowPlayingOutputDeviceIDsKey
stopMonitoringEvents:forClient:
streamForEvent:
_registeredEvents
T@"NSMutableDictionary",&,N,V_registeredEvents
predicateForForegroundAppWithPredicateString:withList:
predicateWithFormat:
predicateForKeyPath:withPredicate:
predicateForForegroundAppWithWhiteList:
onOdometerNotification:data:
onMotionStateObserverNotification:data:
onBarometerCalibrationNotification:track:data:
onAbsoluteAltitudeUpdate:
isNotificationSupported:
initWithUniverse:buffers:
initAllDayContextManagers
setupAltimeterReleaseTimer
setInOutdoorWorkout:
fetchVisitStatusAtStart
releaseAllContextManagers
cleanup
initWithUniverse:delegate:withBuffer:withSourceAggregator:
releaseAndClearManager:
initContextManagersForNotification:
uncertaintyInMeters
sendClientRegisterAnalyticsWithCurrentUncertainty:andTime:
setAltimeterReleaseTimer
releaseContextManagersForNotification:
sourceUpdated:
fStartTime
fType
fEndTime
fNotification
copyDataBuffersForTrack:
stringWithString:
appendFormat:
setString:
updateWetState
stepCountElevationNotification:
isInOutdoorWorkout
wetStateUpdated:
fetchLoiFromId:atTimestamp:
didUpdateDataBuffer:
getLastAltitude
setLastAltitude:
getLastAltitudeAccuracy
setLastAltitudeAccuracy:
getLastAltitudeTime
setLastAltitudeTime:
TB,N,GisInOutdoorWorkout
lastAltitude
Td,N,GgetLastAltitude
lastAltitudeAccuracy
Td,N,GgetLastAltitudeAccuracy
lastAltitudeTime
Td,N,GgetLastAltitudeTime
startTrack:
stopTrack:
absoluteAltitudeUpdate:
updateCompanionConnected:
logBuffers
fDataBuffers
_contextManagers
_sourceAggregator
_clientSets
_biasEstimator
_releaseAltimeterContextTimer
_latestAbsoluteAltitude
_lastEstimatedBias
_lastEstimatedBiasTimestamp
_isSensorWet
fMotionStateObserverClient
_wetState
_isCompanionConnected
_prevElevationAscended
_prevElevationDescended
_sameElevationCounter
_routineMonitorProxy
_inVisit
_logLois
_lastAltimeterClientRegisterTime
_fetchRoutineVisitsTimer
_inOutdoorWorkout
_lastAltitude
_lastAltitudeAccuracy
_lastAltitudeTime
TB,N,GisInOutdoorWorkout,V_inOutdoorWorkout
Td,N,GgetLastAltitude,V_lastAltitude
Td,N,GgetLastAltitudeAccuracy,V_lastAltitudeAccuracy
Td,N,GgetLastAltitudeTime,V_lastAltitudeTime
initWithName:type:duration:repeats:alarmId:bundleId:state:
objectEnumerator
initWithBool:
onGeoCountryCodeChangeNotification:andMonitorRegion:
regionChangeCallback
setRegionChangeCallback:
countryCodeNotificationToken
setCountryCodeNotificationToken:
_regionChangeCallback
T@?,C,N,V_regionChangeCallback
Ti,N,V_countryCodeNotificationToken
T@"NSString",C,N,V_lastCountryCode
setSessionId:
setInputs:
addInputs:
inputsCount
clearInputs
inputsAtIndex:
inputsType
hasSessionId
sessionId
_inputs
_sessionId
T@"NSString",&,N,V_sessionId
T@"NSMutableArray",&,N,V_inputs
setIdsService:
updateIDSStatusAndNotify
handleOdometerCyclingSubscribe:service:account:fromID:context:
setProtobufAction:forIncomingRequestsOfType:
handleOdometerCyclingUnsubscribe:service:account:fromID:context:
handleOdometerCyclingData:service:account:fromID:context:
handleOdometerElevationSubscribe:service:account:fromID:context:
handleOdometerElevationUnsubscribe:service:account:fromID:context:
handleOdometerElevationData:service:account:fromID:context:
handleStrideCalDataSubscribe:service:account:fromID:context:
handleStrideCalDataUnsubscribe:service:account:fromID:context:
handleOdometerCoarseElevationSubscribe:service:account:fromID:context:
handleOdometerCoarseElevationUnsubscribe:service:account:fromID:context:
handleOdometerCoarseElevationData:service:account:fromID:context:
handleMotionCalsUpdate:service:account:fromID:context:
handleMotionStateUpdate:service:account:fromID:context:
handleRemoteAppLaunch:service:account:fromID:context:
handleCompanionPingData:service:account:fromID:context:
handleAbsoluteAltitudeUpdate:service:account:fromID:context:
handleAbsoluteAltitudeSubscribe:service:account:fromID:context:
handleCompanionPingDataForAbsoluteAltitude:service:account:fromID:context:
handlePredictedWalkDistanceBout:service:account:fromID:context:
handleKappaCollect:service:account:fromID:context:
handleKappaStop:service:account:fromID:context:
handleKappaTrigger:service:account:fromID:context:
handleKappaUpload:service:account:fromID:context:
handleVO2MaxCloudKitDailyStats:service:account:fromID:context:
setIsConnected:
idsService
setPairedDevice:
updateIDSStatus
setPairedDeviceLastSeenTimestamp:
connectionUpdateHandler
initWithProtobufData:type:isResponse:
sendProtobuf:toDestinations:priority:options:identifier:error:
computeMD5:
receivedMessageHandler
outgoingResponseIdentifier
receivedMessage:data:identifierString:
stringWithCapacity:
_isConnected
_pairedDevice
_pairedDeviceLastSeenTimestamp
_receivedMessageHandler
_connectionUpdateHandler
_idsService
T@"IDSService",&,V_idsService
T@?,C,V_receivedMessageHandler
T@?,C,V_connectionUpdateHandler
TB,V_isConnected
T@"IDSDevice",&,V_pairedDevice
Td,V_pairedDeviceLastSeenTimestamp
activityTypeAsString:
StringAsActivityType:
metSourceAsString:
StringAsMetSource:
setMetsHR:
setHasMetsHR:
hasMetsHR
setMetsWR:
setHasMetsWR:
hasMetsWR
activityType
setActivityType:
mets
setMets:
metSource
setMetSource:
meanAngleX
setMeanAngleX:
energyMagnitude
setEnergyMagnitude:
metsHR
metsWR
_mets
_activityType
_energyMagnitude
_meanAngleX
_metSource
_metsHR
_metsWR
Ti,N,V_activityType
Td,N,V_mets
Ti,N,V_metSource
Tf,N,V_meanAngleX
Tf,N,V_energyMagnitude
Tf,N,V_metsHR
Tf,N,V_metsWR
macsCount
clearMacs
macsAtIndex:
addMacs:
modesCount
clearModes
modesAtIndex:
addModes:
setLocationId:
setHasLocationId:
hasLocationId
macs
setMacs:count:
modes
setModes:count:
locationId
_macs
_modes
_locationId
TQ,N,V_locationId
T^Q,R,N
T^d,R,N
setProvider:
setSpeedAccuracy:
setCourseAccuracy:
initWithCLMotionActivity:
initWithDaemonLocation:rawMotionActivity:motionActivity:dominantMotionActivity:vehicleConnected:vehicleConnectionStateChanged:
initWithMacAddressAsUInt:secureRangingKeyID:
initWithPeer:date:distanceMeters:accuracyMeters:initiator:shouldUnlock:
checkResourceIsReachableAndReturnError:
bundleWithURL:
secureRangingKeyID
dataType
initWithParkinsonsResult:
rate
metaIdentifier
initWithFileDescriptor:
environment
initWithBundleLocationProvider:inSilo:
isValid
provider
_provider
TB,R,N,GisValid
T^v,R,N,V_provider
T@"CLSilo",R,N,V_silo
onMobilityBoutMetrics:
onWalkingSteadinessClassification:
initWithMotionLogger:
_motionLogger
newAssertionWithReason:
initWithMode:
registerNotificationBlock:forProperties:
setProperty:forKey:
unregisterForMobilityBoutMetrics:
registerForMobilityBoutMetrics:
registerForWalkingSteadiness:
startLeechingLowConfidenceVisitsForClient:
stopLeechingLowConfidenceVisitsForClient:
cl_deepMutableCopy
initWithSet:
initWithDictionary:
setTilesManagerProxy:
setAppTileDataProviderProxy:
setRoutineMonitorProxy:
effectiveRestrictedBoolValueForSetting:
setCanInstallApps:
canInstallApps
effectiveValueForSetting:
setMaxAgeAllowed:
maxAgeAllowed
onRegionChangeNotification
initWithSilo:andMonitorRegion:andOnRegionChangedCallback:
isServiceEnabledViaGeoCountryOverrides
isUsableLocation:
appTileDataProviderProxy
fetchAppsForAreaAtLatitude:longitude:radius:includeRegionalApps:marqueeAppsOnly:withReply:
routineMonitorProxy
onLocation:
tilesManagerProxy
_controller
_geoRegionChangeMonitor
_canInstallApps
_maxAgeAllowed
_tilesManagerProxy
_appTileDataProviderProxy
T@"<CLTilesManagerProtocol>",&,N,V_tilesManagerProxy
T@"<CLAppTileDataProviderProtocol>",&,N,V_appTileDataProviderProxy
T@"<CLRoutineMonitorServiceProtocol>",&,N,V_routineMonitorProxy
TB,N,V_canInstallApps
TI,N,V_maxAgeAllowed
ageRating
adamId
effectiveRadiusMetersIfInstalled
isInEmegencyState:
startLocationSimulation
stopLocationSimulation
setSimulationScenario:
appendSimulatedLocations:
clearSimulatedLocations
setLocationDeliveryBehavior:
setLocationRepeatBehavior:
setIntermediateLocationDistance:
setLocationInterval:
setLocationTravellingSpeed:
getFencesForBundleID:withReply:
simulateFenceWithBundleID:andFenceID:eventType:atLocation:
simulateBeaconWithProximityUUID:major:minor:eventType:
setClasses:forSelector:argumentIndex:ofReply:
controller
setController:
T^v,N,V_controller
activeDeviceSelectorBlock
getAllDevicesWithArchivedDevicesMatching:
kValueForRawSpeed:
strideLengthForStepCadence:
isCalibrationAvailableForStepCadence:
computeWalkRunSigma:
updateEntryDistanceAndPace:
_lastEntry
_totalCalibratedDistance
_supportsFirstStepTime
syncgetHasConnectedDevices
scan
initWithHarvesterExternal:
_subHarvesterExternal
defaultBins
binArrayToArchivedData:
archivedDataWithRootObject:
initWithValueOut:begin:end:state:
copyBins
binIndexForValueIn:
isValueInRun:
walkBinCount
upperQuartile
lowerQuartile
begin
subarrayWithRange:
isNativeValueOutAvailableInBinsFromIndex:withLength:
isBin:sameActivityAsBin:
binsDidChange
valueOutForValueIn:
stringByAppendingFormat:
updateNativeBin:withAlpha:valueOut:
updateAdjacentBin:withAlpha:valueOut:nativeBin:
setBins:
kValue
initWithBegin:end:state:kValue:
convertToCMPedometerBins:
convertToCMStrideCalibrationData:
initWithTableName:valueInName:valueOutName:defaultValue:binBoundariesWalk:binBoundariesRun:testMode:
isWalkNativeValueOutAvailable
isRunNativeValueOutAvailable
isValueInValid:
binIntervalForValueIn:
testMode
updateBinsWithValueOut:valueIn:alpha:
_tableName
_valueInName
_valueOutName
_defaultValue
_binBoundariesWalk
_binBoundariesRun
_binBoundaries
_testMode
_persistentStore
_bins
meCardString
setMeCardString:
meCardMapItem
setMeCardMapItem:
T@"NSString",C,N,VmeCardString
T@"CLLocation",C,N,VmeCardMapItem
initWithFidelityPolicy:locations:accessPoints:
fetchFormattedPostalAddressesFromMeCardWithReply:
fetchPlaceInferencesWithOptions:withReply:
_setResponseSilo:
geocodeAddressString:completionHandler:
placemark
fetchFormattedAddress:queue:
userType
placeType
referenceLocation
preferredName
initWithUserType:placeType:placemark:referenceLocation:confidence:preferredName:loiIdentifier:
formattedAddressLines
mecardAddress
userTypeSource
mapItem
thoroughfare
subThoroughfare
locality
subLocality
administrativeArea
subAdministrativeArea
postalCode
ISOcountryCode
country
inlandWater
ocean
loiIdentifier
initWithClientLocation:coarseMetaData:
initWithMac:rssi:channel:age:date:
areasOfInterest
initWithLocation:addressDictionary:region:areasOfInterest:mapItemSource:geoMapItemHandle:meCardAddress:
address
countryCode
geoMapItemHandle
setVectorClocks:
setInterestZones:
clearVectorClocks
vectorClocksAtIndex:
interestZonesCount
clearInterestZones
interestZonesAtIndex:
vectorClocksType
interestZonesType
setHasNotification:
notificationAsString:
StringAsNotification:
operationTypeAsString:
StringAsOperationType:
operationType
_interestZones
_clientKey
_notification
_operationType
_vectorClocks
T@"NSString",&,N,V_clientKey
Ti,N,V_notification
Ti,N,V_operationType
T@"NSMutableArray",&,N,V_vectorClocks
T@"NSMutableArray",&,N,V_interestZones
syncgetForceCacheUpdate
setCapabilityChangeClients:
updateSupervised
updateICloudManagedAppleID
updateITunesManagedAppleID
updateInstalledEducationProfile
updateLocationDictionaryCachedCapabilities
setSupervised:
setICloudManagedAppleID:
setITunesManagedAppleID:
setInstalledEducationProfile:
isSupervised
aa_isPrimaryAccount
aa_isManagedAppleID
accountsWithAccountType:completion:
accountTypeWithIdentifier:completion:
installedProfileIdentifiers
installedProfileWithIdentifier:
payloads
supervised
installedEducationProfile
iCloudManagedAppleID
iTunesManagedAppleID
capabilityChangeClients
hasCapability:
_darwinClient
_supervised
_iCloudManagedAppleID
_iTunesManagedAppleID
_installedEducationProfile
_capabilityChangeClients
TB,N,V_supervised
TB,N,V_iCloudManagedAppleID
TB,N,V_iTunesManagedAppleID
TB,N,V_installedEducationProfile
T@"NSMutableSet",&,N,V_capabilityChangeClients
fetchLastSignificantLocationDistanceAndLatencyWithReply:
simulateSignificantLocationChange:
hasValueForKey:
isNonProvisionallyAuthorizedForServiceTypeMask:
applicationInfoForApplication:
applicationStateForApplication:
optionsWithDictionary:
openApplication:withOptions:completion:
applicationInfoForPID:
string
cl_hexadecimalString
requestCellTileDownloadByType:lat:lon:seckey:
originDeviceToGpsSource:locationType:
feedLocationData:
feedGpsOdometerData:
feedPedometerData:
fLocationState
fTrackFinder
fSource
T@"<CMStrideCalLocationFSMDelegate>",N,V_delegate
Ti,R,N,VfLocationState
numberWithUnsignedChar:
setHasMets:
hasMets
setHasMetSource:
hasMetSource
setHr:
setHasHr:
hasHr
setHrConfidence:
setHasHrConfidence:
hasHrConfidence
setGrade:
setHasGrade:
hasGrade
setHasGPS:
setHasHasGPS:
hasHasGPS
setHasStrideCal:
setHasHasStrideCal:
hasHasStrideCal
setWorkoutType:
setHasWorkoutType:
hasWorkoutType
setCadence:
setHasCadence:
hasCadence
setPace:
setHasPace:
hasPace
setIsStroller:
setHasIsStroller:
hasIsStroller
setHrTime:
setHasHrTime:
hasHrTime
hrConfidence
grade
hasGPS
hasStrideCal
cadence
pace
isStroller
hrTime
_cadence
_grade
_hrTime
_pace
_hrConfidence
_workoutType
_hasGPS
_hasStrideCal
_isStroller
Tf,N,V_mets
Tf,N,V_hr
Tf,N,V_hrConfidence
Td,N,V_grade
TB,N,V_hasGPS
TB,N,V_hasStrideCal
Ti,N,V_workoutType
Td,N,V_cadence
Td,N,V_pace
TB,N,V_isStroller
Td,N,V_hrTime
initWithCLStrideCalEntry:
initWithArray:
fStrideCalDb
T@"<CMStrideCalibrationDatabaseDelegate>",N,V_delegate
authorizeLocationInReplay
checkLocationAuthorization
cleanUp
_insertSample:
logHgal:
fOrderedSample
fImpactEvent
fIncludeDerivedFeatures
fDeviceMotionDispatcher
fGeomagneticModelProviderClient
fDeclination
fVisualLocalizationPropagation
setEnd:
initWithStart:end:
_end
Td,N,V_start
Td,N,V_end
bundlePath
fetchRoutineModeFromLocation:withReply:
fetchLocationsOfInterestAssociatedToIdentifier:withReply:
fetchRecentLocationsOfInterestWithReply:
fetchNextPredictedLocationsOfInterestFromLocation:startDate:timeInterval:withReply:
fetchPredictedLocationsOfInterestOnDate:withReply:
fetchPredictedLocationsOfInterestBetweenStartDate:endDate:withReply:
fetchLocationOfInterestAtLocation:withHandler:
fetchLocationOfInterestAtLocation:withReply:
startMonitoringScenarioTriggerOfType:forClient:
stopMonitoringScenarioTriggerOfType:forClient:
getStoredLocationsBetweenStartTime:endTime:apartFromEachOther:lyingWithinTimeIntervals:withReply:
fetchStoredVisitsWithOptions:withReply:
zipperedStoredLocationsBetweenStartTime:endTime:apartFromEachOther:lyingWithinTimeIntervals:custeredWithVisits:withReply:
fetchEstimatedLocationAtDate:withReply:
fetchEstimatedLocationAtDate:options:withReply:
onWakeRoutinedTimer
initWithMachServiceName:
_setQueue:
connection
setConnection:
listener
setListener:
routineManager
stopMonitoringVisits
setVisitClients:
stopLeechingVisits
setLeechClients:
stopLeechingLowConfidenceVisits
setLowConfidenceVisitLeechClients:
scenarioTriggerClients
stopMonitoringScenarioTriggerOfType:
setScenarioTriggerClients:
setRoutineManager:
visitClients
startMonitoringVisitsWithHandler:
checkDiminishedMode
leechClients
startLeechingVisitsWithHandler:
lowConfidenceVisitLeechClients
startLeechingLowConfidenceVisitsWithHandler:
fetchRoutineModeFromLocation:withHandler:
fetchLocationsOfInterestAssociatedToIdentifier:withHandler:
fetchLocationOfInterestWithIdentifier:withHandler:
fetchLocationsOfInterestWithinDistance:ofLocation:withHandler:
fetchLocationsOfInterestOfType:withHandler:
fetchLocationsOfInterestVisitedSinceDate:withHandler:
fetchNextPredictedLocationsOfInterestFromLocation:startDate:timeInterval:withHandler:
fetchPredictedLocationsOfInterestOnDate:withHandler:
fetchPredictedLocationsOfInterestBetweenStartDate:endDate:withHandler:
setLocations:
setLastLocation:
lastLocation
floor
level
locations
updating
sendLocations
checkAuthorization
addLocation:
setAuthorized:
valueForEntitlement:
processIdentifier
startUpdatingLocation
stopUpdatingLocation
interfaceWithProtocol:
setExportedInterface:
setExportedObject:
didUpdateLocations:
didUpdateLocations:withReply:
setRemoteObjectInterface:
setUpdating:
setInterruptionHandler:
_unboostingRemoteObjectProxy
remoteObjectProxy
authorized
diminishedMode
startWakeRoutinedTimer
stopWakeRoutinedTimer
setDiminishedMode:
startMonitoringScenarioTriggerOfType:withHandler:
fetchPlaceInferencesWithOptions:handler:
fetchFormattedPostalAddressesFromMeCard:
initWithDateInterval:horizontalAccuracy:batchSize:boundingBoxLocation:
enumerateStoredLocationsWithOptions:usingBlock:
initWithDomain:code:userInfo:
fetchEstimatedLocationAtDate:handler:
sendLocationsWithReply:
fetchEstimatedLocationAtDate:options:handler:
listener:shouldAcceptNewConnection:
updatingPredictedApplications
setUpdatingPredictedApplications:
_wakeRoutinedTimer
_serviceLocationProvider
_serviceLocationClient
_filteredLocationClient
_awarenessClient
_awarenessRegInfo
_updating
_updatingPredictedApplications
_authorized
_diminishedMode
_connection
_locations
_lastLocation
_listener
_routineManager
_visitClients
_leechClients
_lowConfidenceVisitLeechClients
_scenarioTriggerClients
T@"NSXPCConnection",&,N,V_connection
T@"NSMutableArray",&,N,V_locations
T@"CLLocation",&,N,V_lastLocation
T@"NSXPCListener",&,N,V_listener
TB,N,V_updating
TB,N,V_updatingPredictedApplications
TB,N,V_authorized
TB,N,V_diminishedMode
T@"RTRoutineManager",&,N,V_routineManager
T@"NSMutableSet",&,N,V_visitClients
T@"NSMutableSet",&,N,V_leechClients
T@"NSMutableSet",&,N,V_lowConfidenceVisitLeechClients
T@"NSMutableDictionary",&,N,V_scenarioTriggerClients
numberWithLong:
disableCollection
getFlightOfStairsIn24Hr
saveFeaturesToCache:
submitAWDMetric
reset
enableCollection
syncgetQueryStartTime:andStopTime:
cleanCache
onDaemonStatus:data:
displayCache
fPressureDispatcher
fStatusClient
fCharging
fK2Detector
fSlopeEstimator
fAllowLogging
fenceMonitor
initWithFenceMonitor:
setFenceMonitor:
_fenceMonitor
T^v,N,V_fenceMonitor
isLocationShiftRequiredForCoordinate:
shiftCoordinate:accuracy:shiftedCoordinate:shiftedAccuracy:
initWithStartDate:firedDate:alarmType:didWake:
fetchGeomagneticModelData:
setMac:
setHasMac:
hasMac
_mac
TQ,N,V_mac
weatherPressure
setWeatherPressure:
_weatherPressure
Tf,N,V_weatherPressure
weatherForecastUpdated:airQualityConditions:hourlyForecasts:dailyForecasts:location:
registerForWeatherUpdates:
unregisterForWeatherUpdates:
didUpdateWeather:
localLocationForecastUpdatedForConditions:
setMotionAlarmClients:
setLastKnownMotionState:
setResendTimer:
sendMotionAlarmRequest
resendTimer
setRevertToUnknownTimer:
revertToUnknownTimer
motionAlarmClients
evaluateMotionAlarmState
lastKnownMotionState
delayRevertToUnknownTimer
_lastKnownMotionState
_motionAlarmClients
_resendTimer
_revertToUnknownTimer
T@"NSMutableSet",&,N,V_motionAlarmClients
Ti,N,V_lastKnownMotionState
T@"CLTimer",&,N,V_resendTimer
T@"CLTimer",&,N,V_revertToUnknownTimer
updateDesiredFireTimeToHour:minute:second:
timer
didUpdateFireTime
setDidUpdateFireTime:
updateNextFireTime
setMinute:
setSecond:
dateFromComponents:
setDay:
dateByAddingComponents:toDate:options:
getAndClearUpdateNextFireTimeHasFired
handleSysTimeChanged
setTimer:
_didUpdateFireTime
_hour
_minute
_second
_nextFireDelay
_timer
T@"CLTimer",&,N,V_timer
T@"CLDispatchSilo",&,N,V_silo
TB,N,V_didUpdateFireTime
Tq,R,N,V_hour
Tq,R,N,V_minute
Tq,R,N,V_second
Td,R,N,V_nextFireDelay
syncgetCompanionOnlyNoGPSRun
clearStepArray
checkForRunningThreshold
onStepNotification:data:
fHasRun
fInSession
workoutLocationTypeFromCMWorkoutType:
transform
queryUsingRecord:withReply:
initWithSkiEntry:
onForcedLocationNotification:data:
onCompanionConnectionNotification:data:
enableSources:forContext:
setupTimers
disableSources:forContext:
teardownTimers
releasePowerAssertions
calculateAndSendAltitudeFromBaro
setAltitude:
capAccuracy:
setAccuracy:
setPrecision:
calculateAndSendAltitudeFromCompanion
calculateAndSendAltitudeFromLocation
forceGPSIfUnderground
setTimerForGPSOff
shouldEnableWifiAtTime:
setTimerForWifiOff
shouldEnableGPSAtTime:
forceLocationAtTime:
filteredElevation:withTimestamp:
biasInMeters
weatherEstimateInMeter
chooseUncertaintyDuringWorkout:withAltitude:atTime:
_locationControllerClient
_lastForcedWifiTime
_lastForcedGPSTime
_lastAltitudeSentTimestamp
_wifiInProgress
_GPSInProgress
_doesCompanionHavePressureSensor
_lastDefaultLevelLogTimestamp
_forceWifiTimer
_forceGPSTimer
_powerAssertionWifi
_powerAssertionGPS
_currentWetState
_currentStatusInfo
_userUnderground
simplifiedLength:threshold:type:
registerForAppMonitorNotification
unregisterForAppMonitorNotification
unregisterForAvengerScanner
determineStateWithContext:
registerForAvengerScanner
initWithAddress:advertisementData:status:reserved:rssi:scanDate:
initWithAdvertisement:location:
setObservationValue:
saveBeaconPayloads:completion:
_avengerScannerProxy
_spFinderInterface
resetControlPlaneStatus
syncgetControlPlaneStatusReport:
syncgetActiveGnssBands:
syncgetIonosphereParameters:
postDataAvailability
setSessionAttributes:
setEstimate:
setSummaries:
addSummaries:
summariesCount
clearSummaries
summariesAtIndex:
summariesType
hasSessionAttributes
hasEstimate
sessionAttributes
estimate
summaries
_estimate
_sessionAttributes
_summaries
T@"CLCKVO2MaxSessionAttributes",&,N,V_sessionAttributes
T@"CLCKVO2MaxEstimate",&,N,V_estimate
T@"NSMutableArray",&,N,V_summaries
syncgetIconState
syncgetStatusBarIconForEntityClass:
setStatusBarIconForEntityClass:visible:
setE911Active:
synchronizeUserDefaultsDomain:keys:
laterDate:
sendMessage:withReplyClassesSync:
remoteDeviceMotionUpdate:atTime:
registerClientForRemoteMotionAlarm:
unregisterClientForRemoteMotionAlarm:
preloadBuildingTilesNear:radius:completionHandler:
sections
height
findBuildingsNear:radius:handler:completionHandler:
initWithPressure:stdDeviation:timestamp:
initWithCompanionNotifierCompanion:
_companionNotifierCompanion
JSONObjectWithData:options:error:
strideCalibratorSetSession:
updateSession:
forceTrigger:
forceUpload:
precision
statusInfo
initWithStepCountSubscription:
stepCountSubscription
setStepCountSubscription:
_stepCountSubscription
T^v,N,V_stepCountSubscription
initWithStartDate:endDate:steps:distance:floorsAscended:floorsDescended:recordID:currentPace:currentCadence:firstStepTime:activeTime:sourceId:isOdometerDistance:isOdometerPace:pushes:workoutType:elevationAscended:elevationDescended:distanceSource:
initWithEventDate:type:
initWithStartDate:suitableForRunning:suitableForWalking:
syncgetEnabled
syncgetDbUUID
numberOfSteps
sourceId
syncgetQueryPedometerDataSince:withResponseArray:
getPedometerBinsAndHistoryWithReply:
dictionaryWithCapacity:
getPedometerCalibrationBins:withReply:
initWithLoiLocationProvider:
_loiLocationProvider
initWithAscending:confidence:dateInterval:labelVisit:limit:
initWithVisit:
_loiIdentifier
visits
referenceFrame
horizontalUncertainty
verticalUncertainty
sourceAccuracy
fetchLocationOfInterestWithIdentifier:withReply:
onMobilityProcessBoutsActivity:
onMobilityClassificationActivity:
onDataCollectionRequested:
unregisterForWalkingSteadiness:
setBoutClients:
setSteadinessClients:
boutClients
steadinessClients
setUpProcessBoutsActivity
setUpClassificationActivityWithDeferral:
checkForHistoricalComputeTrigger:
checkForBoutsReadyToProcessWithCompletion:
classifySteadinessWithCompletion:
handleBoutResults:
writeToHealthKitType:value:startDate:endDate:
writeToHealthKitType:value:startDate:endDate:deviceSide:
sendAnalyticsBoutMetrics:
isWalkingSteadinessAvailable
writeToHealthKitAppleWalkingSteadiness:startDate:endDate:source:
areWalkingSteadinessNotificationsEnabled
sendAnalyticsSteadinessResult:
writeSteadinessEvent:startDate:endDate:source:
BMIFromHeight:weight:
onAggregationTimer
onSPUGaitMetrics:
fBoutBoundaryDb
fBoutBoundaryAggregator
fGaitMetricsAggregator
fBoutMetricsDb
fBoutMetricsAggregator
fPedometerDb
fHKQueryDelegate
fBoutExtractor
fSteadinessClassifier
fClassificationInProgress
fSPUGaitMetricsDispatcher
fHealthKitWriter
_previousBodyMetrics
_boutClients
_steadinessClients
T@"NSMutableSet",&,N,V_boutClients
T@"NSMutableSet",&,N,V_steadinessClients
initWithOwnerInformation:matchedIndex:sequence:error:
initWithNonOwnerInformation:
initUnknown
matchedIndex
sequence
_sequence
_matchedIndex
TQ,R,V_type
T@"NSUUID",R,V_uuid
TI,R,V_matchedIndex
TC,R,V_sequence
TC,R,V_error
startScanningAwaitingResponse
setStartScanningAwaitingResponse:
stopScanningAwaitingResponse
setStopScanningAwaitingResponse:
requestedScanType
setRequestedScanType:
TB,N,VstartScanningAwaitingResponse
TB,N,VstopScanningAwaitingResponse
Tq,N,VrequestedScanType
startMonitoringAvengerAdvertisementsForClient:clientName:
startMonitoringAvengerAdvertisementsForClient:optedIn:clientName:
stopMonitoringAvengerAdvertisementsForClient:
syncgetIsScanning
performTemporaryAggressiveScan:
performTemporaryAggressiveScanForFindMyAccessoryManager:
performTemporaryLongAggressiveScan:
performTemporaryHawkeyeLowEnergyScan:
startBTFindingScan:
stopBTFindingScan:
startWatchAdvertisementBufferScan:
stopWatchAdvertisementBufferScan:
fetchCurrentScanParameters:
onAvengerAdvertisement:address:advertisementData:status:rssi:reserved:channel:reconciledInformation:
onAggressiveScanStarted
onAggressiveScanEnded
onAdvertisementBufferEmptied
didFetchCurrentScanParameters:
weakToStrongObjectsMapTable
getCLAvengerScannerPolicyPlatformType
initializeScanTypeChangeViewsWithZeroValues
initAnalyticsCache
initAnalyticsTimer
nameForClient:
initializeClientRequestsViewsWithZeroValues:
submitClientRequestsEvent:client:scanType:
shouldStartSpecialScan
longAggressiveScanCoexImpactedDuration
longAggressiveScanNonCoexImpactedDuration
convertCLAvengerScannerScanParametersToWPObjectDiscoveryOptions:
submitScanTypeChangeEvent:type:
resetAnalyticsCache
persistAnalyticsCache
onAnalyticsTimerFired:
_centralManager
_hasQueriedNumberOfBuffers
_stateContext
_clientToNameMap
_policy
_systemMonitor
fAnalyticsTimer
fAnalytics
_avengerScannerSettings
initWithObjectsAndKeys:
initWithIdentifier:absoluteTimestamp:updateTimestamp:state:response:resolution:sosState:operatingMode:
updateTimestamp
isAcknowledgement
setYear:
setMonth:
timeZoneForSecondsFromGMT:
setTimeZone:
setHasSid:
setHasNid:
setHasBsid:
setHasZoneid:
setHasBandclass:
setHasPnoffset:
_bandclass
_bsid
_nid
_pnoffset
_sid
_zoneid
Ti,N,V_sid
Ti,N,V_nid
Ti,N,V_bsid
Ti,N,V_zoneid
Ti,N,V_bandclass
Ti,N,V_channel
Ti,N,V_pnoffset
setDurationInSeconds:
setHasDurationInSeconds:
hasDurationInSeconds
setPointCount:
setHasPointCount:
hasPointCount
setHrMin:
setHasHrMin:
hasHrMin
setHrMax:
setHasHrMax:
hasHrMax
setHrMean:
setHasHrMean:
hasHrMean
setHrConfidenceMean:
setHasHrConfidenceMean:
hasHrConfidenceMean
setHrCadenceAgreementMean:
setHasHrCadenceAgreementMean:
hasHrCadenceAgreementMean
setVo2Mean:
setHasVo2Mean:
hasVo2Mean
setSpeedMean:
setHasSpeedMean:
hasSpeedMean
setGradeMean:
setHasGradeMean:
hasGradeMean
setCadenceMean:
setHasCadenceMean:
hasCadenceMean
setHrVariance:
setHasHrVariance:
hasHrVariance
setHrConfidenceVariance:
setHasHrConfidenceVariance:
hasHrConfidenceVariance
setHrCadenceAgreementVariance:
setHasHrCadenceAgreementVariance:
hasHrCadenceAgreementVariance
setVo2Variance:
setHasVo2Variance:
hasVo2Variance
setSpeedVariance:
setHasSpeedVariance:
hasSpeedVariance
setGradeVariance:
setHasGradeVariance:
hasGradeVariance
setVo2MaxModelSource:
setHasVo2MaxModelSource:
hasVo2MaxModelSource
setSessionType:
setHasSessionType:
hasSessionType
durationInSeconds
pointCount
hrMin
hrMax
hrMean
hrConfidenceMean
hrCadenceAgreementMean
vo2Mean
speedMean
gradeMean
cadenceMean
hrVariance
hrConfidenceVariance
hrCadenceAgreementVariance
vo2Variance
speedVariance
gradeVariance
vo2MaxModelSource
sessionType
_cadenceMean
_durationInSeconds
_gradeMean
_gradeVariance
_hrCadenceAgreementMean
_hrCadenceAgreementVariance
_hrConfidenceMean
_hrConfidenceVariance
_hrMax
_hrMean
_hrMin
_hrVariance
_pointCount
_speedMean
_speedVariance
_vo2Mean
_vo2Variance
_sessionType
_vo2MaxModelSource
Td,N,V_durationInSeconds
TQ,N,V_pointCount
Td,N,V_hrMin
Td,N,V_hrMax
Td,N,V_hrMean
Td,N,V_hrConfidenceMean
Td,N,V_hrCadenceAgreementMean
Td,N,V_vo2Mean
Td,N,V_speedMean
Td,N,V_gradeMean
Td,N,V_cadenceMean
Td,N,V_hrVariance
Td,N,V_hrConfidenceVariance
Td,N,V_hrCadenceAgreementVariance
Td,N,V_vo2Variance
Td,N,V_speedVariance
Td,N,V_gradeVariance
Ti,N,V_vo2MaxModelSource
Ti,N,V_sessionType
setSectorid:
hasSectorid
sectorid
_sectorid
T@"NSString",&,N,V_sectorid
setUrgentCalFlag:
syncId
setSyncId:
setMemoryCacheCountLimit:
setMemoryCacheTotalCostLimit:
initWithStartDate:type:confidence:
setArfcn:
setHasArfcn:
setPsc:
setHasPsc:
_arfcn
_lacID
_psc
Ti,N,V_lacID
Ti,N,V_arfcn
Ti,N,V_psc
setHasLocationType:
hasLocationType
setHasAltitude:
setVerticalAccuracy:
setHasVerticalAccuracy:
setHasScore:
setReach:
setHasReach:
setInfoMask:
setHasInfoMask:
locationType
_infoMask
_locationType
_reach
_verticalAccuracy
Ti,N,V_accuracy
Ti,N,V_locationType
Ti,N,V_altitude
Ti,N,V_verticalAccuracy
TI,N,V_score
Ti,N,V_reach
TI,N,V_infoMask
setAppBundleId:
clearSurroundingWifiBands
setHasNumberOfSurroundingCells:
hasNumberOfSurroundingCells
hasAppBundleId
setNumberOfSurroundingCdmaCells:
setHasNumberOfSurroundingCdmaCells:
hasNumberOfSurroundingCdmaCells
setNumberOfSurroundingCdmaEvdoCells:
setHasNumberOfSurroundingCdmaEvdoCells:
hasNumberOfSurroundingCdmaEvdoCells
setNumberOfSurroundingLteCells:
setHasNumberOfSurroundingLteCells:
hasNumberOfSurroundingLteCells
setNumberOfSurroundingScdmaCells:
setHasNumberOfSurroundingScdmaCells:
hasNumberOfSurroundingScdmaCells
setNumberOfSurroundingNr5GCells:
setHasNumberOfSurroundingNr5GCells:
hasNumberOfSurroundingNr5GCells
setSurroundingWifiBands:count:
surroundingWifiBandsAsString:
StringAsSurroundingWifiBands:
appBundleId
numberOfSurroundingCdmaEvdoCells
numberOfSurroundingScdmaCells
_surroundingWifiBands
_appBundleId
_numberOfSurroundingCdmaCells
_numberOfSurroundingCdmaEvdoCells
_numberOfSurroundingCells
_numberOfSurroundingLteCells
_numberOfSurroundingNr5GCells
_numberOfSurroundingScdmaCells
Ti,N,V_numberOfSurroundingCells
T@"NSString",&,N,V_appBundleId
Ti,N,V_numberOfSurroundingCdmaCells
Ti,N,V_numberOfSurroundingCdmaEvdoCells
Ti,N,V_numberOfSurroundingLteCells
Ti,N,V_numberOfSurroundingScdmaCells
Ti,N,V_numberOfSurroundingNr5GCells
setCellTowers:
setWirelessAPs:
setCdmaCellTowers:
setLteCellTowers:
setScdmaCellTowers:
setNr5GCellTowers:
clearCellTowers
cellTowerAtIndex:
clearWirelessAPs
wirelessAPAtIndex:
clearCdmaCellTowers
cdmaCellTowerAtIndex:
clearLteCellTowers
lteCellTowerAtIndex:
scdmaCellTowersCount
clearScdmaCellTowers
scdmaCellTowerAtIndex:
clearNr5GCellTowers
nr5GCellTowerAtIndex:
cellTowerType
wirelessAPType
cdmaCellTowerType
lteCellTowerType
scdmaCellTowerType
nr5GCellTowerType
_cdmaCellTowers
_cellTowers
_lteCellTowers
_nr5GCellTowers
_scdmaCellTowers
_wirelessAPs
T@"NSMutableArray",&,N,V_cellTowers
T@"NSMutableArray",&,N,V_wirelessAPs
T@"NSMutableArray",&,N,V_cdmaCellTowers
T@"NSMutableArray",&,N,V_lteCellTowers
T@"NSMutableArray",&,N,V_scdmaCellTowers
T@"NSMutableArray",&,N,V_nr5GCellTowers
initWithSubscription:
_subscription
setLocation:
setHasMcc:
setHasMnc:
setHasCellID:
setHasTacID:
setUarfcn:
setHasUarfcn:
setHasPid:
_cellID
_location
_mcc
_mnc
_tacID
_uarfcn
Ti,N,V_mcc
Ti,N,V_mnc
Ti,N,V_cellID
Ti,N,V_tacID
T@"ALSLocation",&,N,V_location
Ti,N,V_uarfcn
exceptionWithName:reason:userInfo:
raise
clearWifiBands
wifiBandsAtIndex:
setHasNeedCellsTowers:
hasNeedCellsTowers
setHasNumberOfSurroundingWifis:
hasNumberOfSurroundingWifis
technology
setTechnology:
setHasTechnology:
hasTechnology
technologyAsString:
StringAsTechnology:
wifiGranularity
setWifiGranularity:
setHasWifiGranularity:
hasWifiGranularity
wifiGranularityAsString:
StringAsWifiGranularity:
setWifiBands:count:
wifiBandsAsString:
StringAsWifiBands:
wifiAltitudeScale
setHasWifiAltitudeScale:
hasWifiAltitudeScale
wifiAltitudeScaleAsString:
StringAsWifiAltitudeScale:
requestTypeCode
responseClass
needCellsTowers
_wifiBands
_numberOfSurroundingWifis
_technology
_wifiAltitudeScale
_wifiGranularity
_needCellsTowers
Tq,N,V_latitude
Tq,N,V_longitude
TB,N,V_needCellsTowers
Ti,N,V_numberOfSurroundingWifis
Ti,N,V_technology
Ti,N,V_wifiGranularity
Ti,N,V_radius
T^i,R,N
Ti,N,V_wifiAltitudeScale
initWithContextType:forNotification:startTime:
setFStartTime:
setFEndTime:
setFType:
setFNotification:
fLocationCoordinates
setFLocationCoordinates:
fLocationHorizontalUncertainty
setFLocationHorizontalUncertainty:
_fStartTime
_fEndTime
_fType
_fNotification
_fLocationHorizontalUncertainty
_fLocationCoordinates
Td,N,V_fStartTime
Td,N,V_fEndTime
TQ,N,V_fType
TQ,N,V_fNotification
T{CLLocationCoordinate2D=dd},N,V_fLocationCoordinates
Td,N,V_fLocationHorizontalUncertainty
_altitude
_accuracy
_precision
_statusInfo
Td,N,V_altitude
Td,N,V_accuracy
Td,N,V_precision
TQ,N,V_statusInfo
previousCumulativeDeltaIOSTime
_biasInMeters
_uncertaintyInMeters
Td,N,V_biasInMeters
Td,N,V_uncertaintyInMeters
Td,N,V_weatherEstimateInMeter
TQ,N,V_previousCumulativeDeltaIOSTime
fTrack
setFTrack:
_fTrack
T@"CLBarometerCalibrationTrack",&,N,V_fTrack
requestCurrentMicroLocationForClient:withAdditionalInformation:
requestMicroLocationRecordingScanForClient:withAdditionalInformation:
syncgetMicroLocationInternalVersion:
cppObject
duetMonitorAudioOutputRouteConnected:
duetMonitorBluetoothConnected:
duetMonitorDeviceFirstWakeOfDay:
duetMonitor:foregroundAppDidLaunch:
duetMonitor:homekitSceneDidChange:
duetMonitor:homekitAccessoryDidChange:
duetMonitor:homekitAppViewDidChange:
duetMonitor:nowPlayingDidChange:
clATVAirplayMonitorService:didFindDevices:
initWithMicroLocationNotifier:
_microLocationNotifier
idsDeviceIdentifier
idsDeviceID
deviceFlags
stopMonitoringForClient:
startMonitoringForegroundAppLaunchWithPredicate:forClient:
startMonitoringFirstWakeOfDayForClient:
startMonitoringHomeKitAccessoryForClient:
startMonitoringHomeKitSceneForClient:
startMonitoringNowPlayingForClient:
stopMonitoringForegroundAppLaunchWithPredicate:forClient:
stopMonitoringFirstWakeOfDayForClient:
stopMonitoringHomeKitAccessoryForClient:
stopMonitoringHomeKitSceneForClient:
stopMonitoringNowPlayingForClient:
initWithDictionary:copyItems:
startMonitoringDevicesForClient:
startScan
setDiscoveryFlags:
stopMonitoringDevicesForClient:
initWithLatitude:longitude:
fetchLocationsOfInterestWithinDistance:ofLocation:withReply:
initWithAscending:confidence:dateInterval:limit:
fetchStoredVisitsWithOptions:handler:
entry
exit
predicateForEventsWithStartInDateRangeFrom:to:
orPredicateWithSubpredicates:
isAirPlayVideo
predicateForObjectsWithMetadataKey:andIntegerValue:
playing
predicateForEventsOfMinimumDuration:
nowPlayingStream
eventQueryWithPredicate:eventStreams:offset:limit:sortDescriptors:
setResultType:
knowledgeStore
executeQuery:responseQueue:withCompletion:
unsignedIntegerValue
numberWithUnsignedLong:
probabilityVector
microLocationIsStable
microLocationVisitStream
withUUID:
eventWithStream:startDate:endDate:value:confidence:metadata:
saveObjects:responseQueue:withCompletion:
deleteAllEventsInEventStream:responseQueue:withCompletion:
predicateForForegroundAppWithBlackList:
setCdmaEvdoTowers:
addCdmaEvdoTower:
cdmaEvdoTowersCount
clearCdmaEvdoTowers
cdmaEvdoTowerAtIndex:
cdmaEvdoTowerType
cdmaEvdoTowers
_cdmaEvdoTowers
T@"NSMutableArray",&,N,V_cdmaEvdoTowers
_harvesterExternal
setHasChannel:
_macID
T@"NSString",&,N,V_macID
TI,N,V_channel
URLSession:didReceiveChallenge:completionHandler:
setProcessingCellTowers:
setProcessingWirelessAPs:
Ti,Vtag
Ti,Vtype
Td,Vtimestamp
TB,VprocessingCellTowers
TB,VprocessingWirelessAPs
TB,Vfinished
cStringUsingEncoding:
getSettings:
_otaSettings
initWithState:
setMacModes:
addMacModes:
macModesCount
clearMacModes
macModesAtIndex:
macModes
_macModes
T@"NSString",&,N,V_locationId
T@"NSMutableArray",&,N,V_macModes
shouldDisplayEEDUIWithReply:
sharedAVSystemController
setAttribute:forKey:error:
applicationProxyForItemID:
peerRangeNotifier
newRequest:
cancelRequest:
requestTileDownloadByType:path:details:
enableAppTilesDownload:
syncgetRegionPreloadManifest:
requestTileDownloadByType:lat:lon:seckey:details:
syncgetTileFilePath:latitude:longitude:isFileAccessible:isTileNotExistingOnServer:
syncgetDeleteTileFile:atPath:
syncgetAppAvailabilityForLocation:radius:searchContext:availabilityList:includeRegionalApps:
syncgetListTilesDirectory:type:time:
decimalDigitCharacterSet
invertedSet
rangeOfCharacterFromSet:
startBuffering
stopBuffering
isEntry:
setCurrentVisitLocation:
setCurrentVisitHorizontalUncertainty:
isDeparture:
isInsideSanctionedPolygon:
hasPressureChangeFrom:to:
shouldSubmit:calibrationType:
sendTrackFrom:to:location:horrUnc:type:
currentVisitLocation
shouldTriggerFloorTransitionHarvest:atTime:
timeUserGetCloseToVisitLocation
currentVisitHorizontalUncertainty
duringVisit
setDuringVisit:
lastSLVUpdateTimestamp
lastFloorTransitionUpdateTimestamp
numWorkSubmissions
numUnknownSubmissions
useSanctionedPolygons
_floorTransitionDetector
_duringVisit
_currentVisitHorizontalUncertainty
_currentVisitLocation
TB,N,V_duringVisit
T{CLLocationCoordinate2D=dd},N,V_currentVisitLocation
Td,N,V_currentVisitHorizontalUncertainty
isValidJSONObject:
openURL:configuration:completionHandler:
setRawCoordinateLatitude:
setHasRawCoordinateLatitude:
hasRawCoordinateLatitude
setRawCoordinateLongitude:
setHasRawCoordinateLongitude:
hasRawCoordinateLongitude
rawCoordinateLatitude
rawCoordinateLongitude
_rawCoordinateLatitude
_rawCoordinateLongitude
Td,N,V_rawCoordinateLatitude
Td,N,V_rawCoordinateLongitude
initWithTestMode:
newlineCharacterSet
componentsSeparatedByCharactersInSet:
isBinaryLogging
isWalkCalibrationAvailable
isRunCalibrationAvailable
binIntervalForRawSpeed:
findRoadsFromNextIntersectionOf:handler:completionHandler:
findRoadsFromPreviousIntersectionOf:handler:completionHandler:
findRoadsToNextIntersectionOf:handler:completionHandler:
findRoadsToPreviousIntersectionOf:handler:completionHandler:
shouldStartNewTrack:
sendTrackAndScheduleNextTick:
isRefDataAvailableBetweenStartTime:andEndTime:
_currentTrack
_lastTrackEndTime
_biasEstimationTrackDataBufferSizeSeconds
_biasEstimationTrackPeriodSeconds
_timeSinceLastTrackStart
_waitPeriodSeconds
_currentSource
_trackLengthSecondsForSource
_lastWetStateTimestamp
raise:format:
setOdometerTarget:
setInvalid:
invalid
Td,N,VodometerTarget
T@?,C,N,Vhandler
TB,N,Vinvalid
T@"<CLOdometerAlarmManagerProtocol>",&,N,V_manager
setStatusString:
acquireWithHandler:invalidationHandler:
addAlarm:
removeAlarm:
odometerTarget
sortUsingComparator:
reschedule
lastOdometer
handleOdometer:
firstAlarm
fire:withError:
setLastOdometer:
handleLocationData:
handleOdometerData:
currentlyScheduled
setCurrentlyScheduled:
fAlarms
fGpsClient
Td,N,VlastOdometer
T@"CLOdometerAlarm",N,VcurrentlyScheduled
T@"CLOdometerAlarm",R,N
workoutEventAsString:
StringAsWorkoutEvent:
workoutTypeAsString:
StringAsWorkoutType:
_workoutEvent
Ti,N,V_workoutEvent
T@"NSData",&,N,V_sessionId
decodeInt32ForKey:
encodeInt32:forKey:
initWithStart:stop:distanceGps:distanceRawPed:steps:gpsSource:
setStart:
setStop:
setDistanceGps:
setDistanceRawPed:
setGpsSource:
_gpsSource
_start
_stop
_distanceGps
_distanceRawPed
T@"NSDate",&,N,V_start
T@"NSDate",&,N,V_stop
Td,N,V_distanceGps
Td,N,V_distanceRawPed
Td,N,V_steps
Ti,N,V_gpsSource
initWithOdometerEntry:
dist
gpsOdomEntry
initWithStepEntry:
firstStepTime
lastStepTime
deltaActiveTime
deltaSteps
deltaDist
speedInstant
speedCurrent
stepCadenceCurrent
pedometerArmConstrainedState
pedEntry
_closeCurrentTrack
course
gpsLocationBuffer
setTimeEndGpsLocationSegment:
removeObjectAtIndex:
setTimeStartGpsLocationSegment:
_closeTrackCheckGpsLocation
_filterGpsLocationBuffer
_updateGpsLocationBufferFiltered:
gpsLocationBufferFiltered
_closeTrackCheckGpsLocationFiltered
gpsOdometerBuffer
_closeTrackCheckGpsOdometer
pedometerBuffer
_closeTrackCheckPedometer
_extremaRemovedMean:
initWithCoordinate:altitude:horizontalAccuracy:verticalAccuracy:course:speed:timestamp:
setTimeStart:
setTimeEnd:
reverseObjectEnumerator
simplifiedLength:threshold:
timeStart
timeEnd
removeLastObject
_removeAdditionalInconsistentSpeedPedometerEntries
_calculateTimeStartEndDistanceGpsPed
timeStartGpsLocationSegment
timeEndGpsLocationSegment
_clearBuffers
calTrackHandler
updateGpsLocationBuffer:gpsSource:
updateGpsOdometerBuffer:
updatePedometerBuffer:
setCalTrackHandler:
setGpsLocationBuffer:
setGpsLocationBufferFiltered:
setGpsOdometerBuffer:
setPedometerBuffer:
_calTrackHandler
_gpsLocationBuffer
_gpsLocationBufferFiltered
_gpsOdometerBuffer
_pedometerBuffer
_timeStart
_timeEnd
_timeStartGpsLocationSegment
_timeEndGpsLocationSegment
T@"NSMutableArray",&,V_gpsLocationBuffer
T@"NSMutableArray",&,V_gpsLocationBufferFiltered
T@"NSMutableArray",&,V_gpsOdometerBuffer
T@"NSMutableArray",&,V_pedometerBuffer
T@"NSDate",&,V_timeStart
T@"NSDate",&,V_timeEnd
T@"NSDate",&,V_timeStartGpsLocationSegment
T@"NSDate",&,V_timeEndGpsLocationSegment
Td,V_distanceGps
Td,V_distanceRawPed
Td,V_steps
Ti,V_gpsSource
T@?,C,V_calTrackHandler
setBasalMETs:
setHasBasalMETs:
hasBasalMETs
setBasalNatalies:
setHasBasalNatalies:
hasBasalNatalies
setDuration:
setHasDuration:
hasDuration
basalMETs
natalies
setNatalies:
basalNatalies
_basalNatalies
_duration
_natalies
_basalMETs
Tf,N,V_basalMETs
Tq,N,V_natalies
Tq,N,V_basalNatalies
Td,N,V_duration
stopAndKeep:
cleanup_writers
cleanup_readers
attributesOfItemAtPath:error:
fileSize
cleanup_unencrypted_files
lastPathComponent
moveItemAtPath:toPath:error:
nByte
start:
beginSort
sortToListener:
moveToCompletedDir:
onSortedTimestamp:source:
onMagData:
onAccelerometerData:
onAccelerometer800Data:
onDeviceMotionData:
onAudioRMSData:timestamp:
onRawAudioBatch:size:
onPressureData:
onGPSItem:
onSOS:
onPressureTCO:inertialFit:
onKappaTrigger:isMounted:
onCompassCalibration:
stopTime
isError
_writer
_dWriter
_triggerChannel
_acc800Channel
_dmChannel
_pressureChannel
_rmsChannel
_gpsChannel
_filePath
_iOSTriggerTime
_aopTriggerTime
fIsRecording
fImpactDispatched
fPrevTimetamp
fPrevSortedTimestamp
fNacc800
fNdm
fNpressure
fNrms
fNgps
_isError
_stopTime
T@"NSString",R,N,V_filePath
Td,R,N,V_startTime
Td,R,N,V_stopTime
TC,R,N,V_state
TB,R,N,V_isError
CLMotionTimeRangeFromCMMotionTimeRange:
queryMetMinutesInTimeRange:withReply:
VO2MaxInputFromCMVO2MaxInputs:
queryVO2MaxInputsFromRecord:withReply:
isLocationUsefulForCalibration:
_sources
_clientsForSource
_lastTimestampPressureBuffer
T@"<CLBarometerCalibrationAggregatorClient>",N,V_delegate
initWithOnBodyResult:confidence:timestamp:
setMeanMaxMets:
setHasMeanMaxMets:
hasMeanMaxMets
setPrior:
setHasPrior:
hasPrior
setHardwareType:
setHasHardwareType:
hasHardwareType
setBetaBlockerUse:
setHasBetaBlockerUse:
hasBetaBlockerUse
setAlgorithmVersion:
setHasAlgorithmVersion:
hasAlgorithmVersion
meanMaxMets
prior
hardwareType
betaBlockerUse
algorithmVersion
_meanMaxMets
_prior
_algorithmVersion
_hardwareType
_betaBlockerUse
Td,N,V_meanMaxMets
Td,N,V_prior
TI,N,V_hardwareType
TB,N,V_betaBlockerUse
Ti,N,V_algorithmVersion
isEqualToData:
advertisementData
isEqualToAdvertisement:
advertisement
isEqualToPayload:
scanDate
nextObject
isNewPayload:
beaconPayloadCache
setBeaconPayloadCache:
_beaconPayloadCache
T@"NSMutableArray",&,V_beaconPayloadCache
subscription
initWithOdometerSubscription:
setSubscription:
T^v,N,V_subscription
initWithDistance:startDate:endDate:currentSpeed:averageSpeed:
setGpsAltitude:
setRawSpeed:
setOdometer:
setGpsSpeedAccuracy:
setTimestampGps:
setGroundAltitude:
setGroundAltitudeUncertainty:
setSmoothedGPSAltitude:
setSmoothedGPSAltitudeUncertainty:
setGpsCourseRadians:
setGpsCourseAccuracy:
setHasOdometer:
hasOdometer
setDeltaDistance:
setHasDeltaDistance:
hasDeltaDistance
setDeltaDistanceAccuracy:
setHasDeltaDistanceAccuracy:
hasDeltaDistanceAccuracy
setHasTimestampGps:
hasTimestampGps
setSlope:
setHasSlope:
hasSlope
setMaxAbsSlope:
setHasMaxAbsSlope:
hasMaxAbsSlope
setHasGroundAltitude:
hasGroundAltitude
setHasGroundAltitudeUncertainty:
hasGroundAltitudeUncertainty
odometer
deltaDistance
deltaDistanceAccuracy
timestampGps
slope
maxAbsSlope
groundAltitude
groundAltitudeUncertainty
_deltaDistance
_deltaDistanceAccuracy
_groundAltitude
_groundAltitudeUncertainty
_maxAbsSlope
_odometer
_slope
_timestampGps
Td,N,V_odometer
Td,N,V_deltaDistance
Td,N,V_deltaDistanceAccuracy
Td,N,V_timestampGps
Td,N,V_slope
Td,N,V_maxAbsSlope
Td,N,V_groundAltitude
Td,N,V_groundAltitudeUncertainty
numberWithShort:
initWithDaemonClient:
client
_client
T^v,N,V_client
syncgetAltitude:rel:undulation:feedToAltFilter:
syncgetAltitude:rel:undulation:
clear
updateMotion:conf:
updateAirborneActivity:
updateTunnelBridgeAssistance:
downloadIfNeeded:signalQuality:allowCenterOverCellular:
downloadAvailabilityFile:
cldem
setCldem:
_cldem
T^v,N,V_cldem
dictionaryWithContentsOfFile:
scannerWithString:
scanHexInt:
fetchMostRecentConnectionWithReply:
syncgetMostRecentVehicleConnection
syncgetMostRecentInVehicle
fetchIsDeviceVehicle:deviceType:withReply:
deliverAndReleaseNotification:withFlags:
resetStoredCalibrations
isEqualToArray:
decodeObjectOfClasses:forKey:
feedFitnessMachineData:
convertToCLFitnessMachineData:
predicateForObjectsWithMetadataKey:
predicateForObjectsWithDeviceProperty:allowedValues:
currentCountrySupportsFeature:
setSet:
initWithTimeInterval:sinceDate:
totalEnergyBurned
largeCalorieUnit
applicationProxyForIdentifier:
isApplicationInstalledIncludingPairedDevices:withReply:
syncgetAppType:
applicationType
genreID
applicationIsInstalled:
removedSystemApplications
pluginKitProxyForIdentifier:
bundleURL
containingBundle
bundleContainerURL
initWithObjects:
isStatusBarAssertionAvailable
submit:
backgroundLocationAssertionForPID:
acquireWithHandler:onQueue:
invalidate:
setDesiredEnablementState:
isEnabled
setBackgrounded:
checkAssertion
initWithPid:name:queue:backgrounded:registration:
isMetricValid
_assertion
_pid
_queue
_timeStarted
_startedInBackground
_everBackgrounded
_backgrounded
_registration
_metricValid
metricValid
TB,R,N,GisMetricValid,V_metricValid
setPid:
sessionForBundleID:withURL:type:
startSession:completion:
endSession:completion:
initWithBundleId:pid:
T@"NSString",C,N,V_bundleId
T@"CSLSSession",&,N,V_session
Ti,N,V_pid
inUseLevelIsAtLeast:
releaseAccuracyEnablementAssertionForClient:
takeAccuracyEnablementAssertionForClient:withDesiredAccuracy:
initWithDistance:inUniverse:handler:
hour
month
year
initWithPID:flags:reason:name:
setFlags:
cacheEmergencyAWDStatistics:
syncgetPendingSetBiasCount
loggerDataTypeString:
_addLogger:type:
_forEachLogger:
flushInMemoryDataWithCompletionQueue:completionBlock:
_forEachLoggerWithType:logData:
_forEachLoggerWithType:logItem:
loggerDataTypeFrom:
appendData:
encodeFilteredPressure:
addLogger:toDirectory:prefix:rotation:
logFilteredPressure:
fLoggingEnabled
fLoggers
fQueue
fEventTimes
fLastEvent
fOrientation
loggingEnabled
TB,N,GisLoggingEnabled,SsetLoggingEnabled:,VfLoggingEnabled
T{CLGizmoOrientation=ii},N,VfOrientation
isAuthorizedForLocation
setLength:
readDataOfLength:
setData:
deserializeMeta:fromData:
readMeta:fromHandle:
fBuffer
workoutIsTypeWalking:
workoutIsTypeRunning:
swimWorkoutInstance:
poolLength
genericWorkoutInstance:
workoutLabel
initWithSessionId:type:locationType:startDate:endDate:
setUserInfo:
requestTileDownloadForLat:lon:details:
distantPast
feedPressureData:
feedCumulativeAscendingDelta:andDescendingDelta:andIosTimestamp:
feedLocationData:data:
feedPrefilteredLocationData:data:
feedLoiData:
updatePAL:
pause
refreshMetrics
setActiveVo2maxOverride:
syncgetUserProfileInternal
setUserProfileFromCMNatalimeter:
setUserProfile:merge:
resetUserProfileForKeys:
syncgetQueryNatalieDataSince:records:
syncgetQueryExerciseMinuteDataSince:records:
queryWorkoutMets:withReply:
onCalorieAggregationActivity:
initWithSample:
initWithCLWorkoutMets:
isServiceRunning:
initWithHealthStore:bundleIdentifier:quantityType:
setBodyMetrics:
bodyMetrics
initWithStartDate:duration:
initWithIdentifier:dateInterval:quantity:resumeContext:
insertDatums:device:metadata:completion:
resumeWithCompletion:
finishWithCompletion:
localTimeZone
secondsFromGMT
initWithHealthStore:
notificationStatusWithError:
notificationUnavailableReasons
saveCardioFitnessEventWithValue:threshold:dateInterval:options:completion:
quantityType
isActiveSubArchive
initWithDirectory:requestCode:itemCountThresholdForAutoCleanUp:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
secondaryFileURLs
totalSecondaryPointsUnderAllSubArchives
rotateSecondaryFile
pathForSecondaryData
setSecondaryPath:
initWithFileDescriptor:closeOnDealloc:
setSecondaryFileHandle:
pathForPrimaryData
fileURLWithPath:
getResourceValue:forKey:error:
writeBigEndianFixed32:
primaryDataSize
secondaryDataSize
immutableData
writeData:error:
path
updateCount
fileURLWithPath:isDirectory:
overwritePrimaryData:
setCount:
writeSecondaryData:toField:
writeData:forTag:
secondaryFileHandle
incrementCountBy:
hasMoreData
readTag:type:
readData
stringByDeletingLastPathComponent
inactiveSubArchives
directory
filteredArrayUsingPredicate:
initWithDirectory:requestCode:
initWithDirectory:
initWithDirectory:itemCountThresholdForAutoCleanUp:
totalCountIncludingAllSubArchives
fileCount
mappedDataByDestructivelyCombiningPrimaryAndSecondaryData
overwritePrimaryObject:
mappedPrimaryData
primaryDataExists
writeSecondaryObject:toField:
mappedSecondaryDataByDestructivelyCombiningAllSecondaryData
mappedSecondaryData
pruneSecondaryDataOlderThan:
pruneAndGetSecondaryDataOlderThan:
iterateSecondaryData:forField:withHandler:
generateNewSubArchive
iterateSubArchivesWithHandler:
deleteSubArchiveIfInactive:
eraseAllData
rotationInterval
setRotationInterval:
requestCode
secondaryPath
totalCount
setTotalCount:
_directory
_requestCode
_rotationInterval
_lastRotationTime
_count
_totalCount
_secondaryPath
_secondaryFileHandle
T@"NSString",&,N,V_secondaryPath
T@"NSFileHandle",&,N,V_secondaryFileHandle
TQ,N,V_totalCount
Td,N,V_rotationInterval
TQ,R,V_count
TI,R,V_requestCode
URLByAppendingPathComponent:
initWithClassifier:rootDirectory:basename:requestCode:itemCountThresholdForAutoCleanUp:
writeSecondaryObject:collectedAt:toField:
homeArchive
workArchive
mainArchive
_homeArchive
_workArchive
_mainArchive
T@"CLHRequestArchive",R,V_homeArchive
T@"CLHRequestArchive",R,V_workArchive
T@"CLHRequestArchive",R,V_mainArchive
classifyingStoreForHarvester:enableSubArchiving:itemCountThresholdForAutoCleanUp:
requestArchivesForHarvester:
allArchiveURLs
contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
archiveWithIdentifier:
archiveForHarvester:
archiveForHarvester:withSuffix:
classifyingStoreForHarvester:
classifyingStoreForHarvesterWithSubArchiving:itemCountThresholdForAutoCleanUp:
clearDataForHarvester:
pruneSecondaryDataOlderThan:forHarvester:
pointCountForHarvester:
_rootDir
enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:
_cl_initWithFileDescriptor:
setActiveRequests:
setActiveRequestCleanupTimer:
activeRequestCleanupTimer
activeRequests
indexSet
addIndex:
radiusMeters
handler
removeObjectsAtIndexes:
touristApp
setEffectiveRadiusMetersIfInstalled:
setHeroAppRankInstalled:
setHeroAppRankUnInstalled:
setAdamId:
setAgeRating:
setTouristApp:
setSpanLat:
setSpanLon:
getAppsForAreaAtLatitude:longitude:radius:includeRegionalApps:marqueeAppsOnly:
fIsRegisteredForTileDownload
setFIsRegisteredForTileDownload:
setLat:
setLon:
setRadiusMeters:
setIncludeRegionalApps:
setMarqueeAppsOnly:
includeRegionalApps
marqueeAppsOnly
onTileWasDownloadedNotification:data:
_tilesManagerClient
_fIsRegisteredForTileDownload
_activeRequests
_activeRequestCleanupTimer
TB,N,V_fIsRegisteredForTileDownload
T@"NSMutableArray",N,V_activeRequests
T@"CLTimer",N,V_activeRequestCleanupTimer
heroAppRankInstalled
heroAppRankUnInstalled
spanLat
spanLon
_touristApp
_ageRating
_adamId
_effectiveRadiusMetersIfInstalled
_heroAppRankInstalled
_heroAppRankUnInstalled
_spanLat
_spanLon
TI,N,V_ageRating
TB,N,V_touristApp
TI,N,V_adamId
TI,N,V_effectiveRadiusMetersIfInstalled
TI,N,V_heroAppRankInstalled
TI,N,V_heroAppRankUnInstalled
Td,N,V_spanLat
Td,N,V_spanLon
_includeRegionalApps
_marqueeAppsOnly
_radiusMeters
_lat
_lon
_handler
Td,N,V_lat
Td,N,V_lon
Tf,N,V_radiusMeters
TB,N,V_includeRegionalApps
TB,N,V_marqueeAppsOnly
T@?,C,N,V_handler
shortValue
modeAsString:
StringAsMode:
avgIntensity
setAvgIntensity:
_avgIntensity
Td,N,V_avgIntensity
isSupportedForType:
subscriptionType
classNameForSensorIdentifier:
setNotifier:
setSubscriptionType:
_subscriptionType
_notifier
T^v,V_notifier
Ti,V_subscriptionType
initWithDataType:
setDataSize:
dataWithCapacity:
serializeMeta:toData:
provideSampleBytes:length:
isMonitoring
dataIdentifier
writeMeta:toHandle:
offset
dataSize
writeData:
fileDescriptor
createFileAtPath:contents:attributes:
fileHandleForWritingAtPath:
addProximityZoneEvent:
addProximityScanEvent:
requestScan:
ageOutElevationArray
feedElevationData:
fElevationWindow
setTripTimestamp:
setTripId:
setRat:
setBundleIds:
containsValueForKey:
setModeIndicator:
setActiveAccessory:
setMotionVehicleConnectedStateChanged:
setMotionVehicleConnected:
setRawMotionActivity:
setMotionActivity:
setDominantMotionActivity:
tripTimestamp
tripId
bundleIds
modeIndicator
activeAccessory
motionVehicleConnectedStateChanged
motionVehicleConnected
rawMotionActivity
motionActivity
dominantMotionActivity
initWithTracksData:andLocation:
_motionVehicleConnectedStateChanged
_motionVehicleConnected
_rat
_modeIndicator
_tripTimestamp
_tripId
_bundleIds
_activeAccessory
_rawMotionActivity
_motionActivity
_dominantMotionActivity
T{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB},N,V_location
Td,N,V_tripTimestamp
T@"NSString",C,N,V_tripId
Ti,N,V_rat
Ti,N,V_context
T@"NSString",C,N,V_bundleIds
Ti,N,V_modeIndicator
T@"CLPAccessoryMeta",&,N,V_activeAccessory
TB,N,V_motionVehicleConnectedStateChanged
TB,N,V_motionVehicleConnected
T{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi},N,V_rawMotionActivity
T{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi},N,V_motionActivity
T{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi},N,V_dominantMotionActivity
CMMotionTimeRangeFromCLMotionTimeRange:
fStartDate
fEndDate
T@"NSDate",R,N
queryBundleIdentifiersWithEnteredRegionsWithReply:
addMonitoredRegion:
removeMonitoredRegion:
syncgetMonitoredRegions:forClient:
syncgetIsTracking
syncgetStartTracking
syncgetStopTracking
querySinceRecord:withReply:
initWithSpringEntry:
activityAlarmAvailable
trigger
initWithTrigger:duration:onQueue:withHandler:
initWithPayload:requestTypeCode:endpoint:headers:
setURL:
setHTTPBody:
initWithRequest:endpoint:headers:
initWithPayload:
URLRequest
setRequestTypeCode:
headers
setHeaders:
endpoint
setEndpoint:
endpointSelector
requestArchive
_requestTypeCode
_endpoint
_headers
_requestArchive
T@"NSURLRequest",R
TI,N,V_requestTypeCode
T@"NSDictionary",&,N,V_headers
T@"NSURL",&,N,V_endpoint
T@"CLHEndpointSelector",R,V_endpointSelector
T@"CLHRequestArchive",R,V_requestArchive
setUnderlyingQueue:
underlyingQueue
dataTaskWithRequest:
allHeaderFields
dateFromString:
taskIdentifier
URLSession:dataTask:didReceiveResponse:completionHandler:
URLSession:dataTask:didBecomeDownloadTask:
URLSession:dataTask:didBecomeStreamTask:
URLSession:dataTask:didReceiveData:
URLSession:dataTask:willCacheResponse:completionHandler:
submitRequest:
timeout
setTimeout:
_operationQueue
_activeTasks
_dateFormatter
_timeout
Td,N,V_timeout
T@"CLHEndpointSelector",&,N,V_endpointSelector
T@"<CLHNetworkControllerDelegate>",&,N,V_delegate
setDirectionOfTravelAssistance:
setMapMatchedPositionAssistance:
setTunnelBridgeAssistance:
setTunnelEndPointPositionAssistance:
processActiveScan:
processScanCache:
convertAPToWifiData:
writeJSONObject:toStream:options:error:
writeWifiAPToJson:withData:
activeScanBuffer
lastSubmissionToSourceAggregator
setHasMode:
hasMode
T@"NSString",&,N,V_mac
Td,N,V_mode
setTrigger:
activityAlarmInfo
initWithTrigger:duration:onRunLoop:withHandler:
fire
executable
setExecutable:
fConcentrator
fIsValid
fRunLoop
fHandler
_executable
T@"NSString",C,N,V_executable
syncgetAddProximityZone:
syncgetRemoveProximityZone:
isRoadPedestrianNavigable
walkableSide
isRail
isTunnel
bikeableSide
setAllowNetworkTileLoad:
setFlipNegativeTravelDirectionRoads:
setVisitDoubleTravelDirectionRoadsTwice:
setAllowStaleData:
allowNetworkTileLoad
preloadRoadTilesNear:radius:completionHandler:
coordinateCount
roadID
internalRoadName
isBridge
roadClass
formOfWay
rampType
travelDirection
speedLimitIsMPH
speedLimit
laneCount
coordinates
clearRoadTiles
clearBuildingTiles
clearTransitTiles
clearAllTiles
findRoadsNear:radius:handler:completionHandler:
setFADR:
fADR
batchQueryController:updatedDestinationsStatus:onService:error:
idStatusUpdatedForDestinations:
idStatusUpdatedForDestinations:service:
initWithADRPointer:
_fADR
T^v,V_fADR
initWithLength:
components:fromDate:toDate:options:
subdataWithRange:
setNextFireTime:interval:
_stopLoggingOnQueue
_currentFilename
_shouldRotateToHour:date:
isDate:inSameDayAsDate:
_shouldRotate
propertyForKey:
initToMemory
fileExistsAtPath:isDirectory:
initToFileAtPath:append:
_outputStream
write:maxLength:
logDirectory
fLogDirectory
fLogFilePrefix
fRotation
fOutputStream
fHour
fDate
syncgetAddFence:
syncgetRemoveFence:
syncgetFences:forBundle:
syncgetFences:forBundle:onBehalfOf:
syncgetCanBundle:performFenceOperationFor:
updateStrideLengthRun
updateStrideLengthStepCadenceWalk
binIntervalForStepCadence:
isStepCadenceValid:
setUserHeight:
_userHeight
_strideLengthRun
_strideLengthStepCadencePairWalk
initWithMacAddress:timestamp:
setMacAddress:
TQ,N,V_macAddress
startMonitoringTransitStateForClient:
stopMonitoringTransitStateForClient:
onTransitStateUpdate:
setCurrentState:
setObservedTransitAccessPointsCache:
currentState
observedTransitAccessPointsCache
mostRecentLocation
processNewAccessPoints:transitTileResults:
setMostRecentLocation:
_wifiServiceProxy
_transitMacTileDataProviderProxy
_currentState
_observedTransitAccessPointsCache
_mostRecentLocation
TQ,N,V_currentState
T@"NSMutableArray",&,N,V_observedTransitAccessPointsCache
T@"CLLocation",&,N,V_mostRecentLocation
hasExecutedScheduleFromCellularConnectivity
hasExecutedScheduleFromWifiConnectivity
setHasExecutedScheduleFromCellularConnectivity:
setHasExecutedScheduleFromWifiConnectivity:
initWithUniverse:andDelegate:
scheduleTileDownloadIfNecessary
_hasExecutedScheduleFromCellularConnectivity
_hasExecutedScheduleFromWifiConnectivity
T@"<CLTileDownloadSchedulingServiceProtocol>",&,N,V_proxy
T@"<CLIntersiloUniverse>",&,N,V_universe
TB,N,V_hasExecutedScheduleFromCellularConnectivity
TB,N,V_hasExecutedScheduleFromWifiConnectivity
T^{CLITileDownloadSchedulingClientDelegate=^^?},N,V_delegate
setProductId:
setSoftwareVersion:
meta
initWithHarvesterExternal:andSilo:
updateEndpoint:withKey:
appEndpoint
batchEndpoint
cellWifiEndpoint
indoorEndpoint
passEndpoint
poiEndpoint
pressureEndpoint
traceEndpoint
altimeterEndpoint
ionosphereEndpoint
_appEndpoint
_batchEndpoint
_cellWifiEndpoint
_indoorEndpoint
_passEndpoint
_poiEndpoint
_pressureEndpoint
_traceEndpoint
_altimeterEndpoint
_ionosphereEndpoint
T@"NSURL",R,V_appEndpoint
T@"NSURL",R,V_batchEndpoint
T@"NSURL",R,V_cellWifiEndpoint
T@"NSURL",R,V_indoorEndpoint
T@"NSURL",R,V_passEndpoint
T@"NSURL",R,V_poiEndpoint
T@"NSURL",R,V_pressureEndpoint
T@"NSURL",R,V_traceEndpoint
T@"NSURL",R,V_altimeterEndpoint
T@"NSURL",R,V_ionosphereEndpoint
setFenceIdentifier:
setDesiredAccuracy:
fenceIdentifier
isGeoFenceAuthorizedAndPossible
uninstallCurrentFence
onLocationUpdateTimerFire
cancelTimers
setInstalledRegion:
isMonitoringAvailableForClass:
installedRegion
installFenceWithCenter:
onGeoFenceTimerFire
_geoFenceTimer
_locationUpdateTimer
_regionState
_authorizationStatus
_fenceRadius
_isFenceInstalled
_isAttemptingFenceInstall
_isMonitoringRegion
_inWorkout
_fenceIdentifier
_installedRegion
T@"<CLWorkoutGeoFenceControllerDelegate>",N,V_delegate
T@"NSString",C,N,V_fenceIdentifier
T@"CLRegion",C,N,V_installedRegion
sendConfigurationRequest
downloadTaskWithRequest:
getTasksWithCompletionHandler:
registerDevice
setupConfigurationTimer
_setupSession
_encryptData:metaData:
unsignedShortValue
dataWithContentsOfURL:
requestConfiguration
URLSession:downloadTask:didFinishDownloadingToURL:
_configurationTimer
_configurationURL
_configurationTimerFireInterval
_configurationEndpoint
handleFailureInFunction:file:lineNumber:description:
_isPreferredSource
isWheelchairDataSubmissionAllowed
convertToSpringTrackerEntry:
manufacturer
setMake:
modelNumber
setModel:
firmwareRevision
initWithAccessory:
uncertainty
doesNotRecognizeSelector:
setHomeLocations:
fetchLocationsOfInterestOfType:withReply:
setWorkLocations:
setupWithCompletionHandler:
loiTypeForLocation:
homeLocations
workLocations
_homeLocations
_workLocations
T@"NSArray",&,N,V_homeLocations
T@"NSArray",&,N,V_workLocations
TB,N,Vvalid
numberWithInteger:
typeSource
maxNatalieEntries
initWithStartDate:recordId:sourceId:
substringWithRange:
_updateLocation:
initWithTimeZone:zoneBoundary:
onLocationUpdate:
locationIsInZoneWithLatitude:longitude:horizontalAccuracy:
timeZone
isInZone
wrappedAvengerZoneMonitor
_isInZone
_timeZone
T@"CLLocation",R,V_location
T@"NSString",R,V_timeZone
TB,R,V_isInZone
rapportStreamingLink
setRapportStreamingLink:
rapportDiscoveryLink
setRapportDiscoveryLink:
activeStreamingClients
registerRequestID:options:handler:
toggleLocationUpdates:inFitnessSession:inAirborneSession:emergencyEnablementAssertionActive:
registerRequestHandlers
setActiveStreamingClients:
_rapportDiscoveryLink
_activeStreamingClients
_rapportStreamingLink
T@"RPCompanionLinkClient",&,V_rapportDiscoveryLink
T@"NSMutableSet",&,N,V_activeStreamingClients
T@"RPCompanionLinkClient",&,V_rapportStreamingLink
setHasEndTime:
hasEndTime
locationTypeAsString:
StringAsLocationType:
appendString:
T^{CLNotifierBase=^^?},R,N,V_notifier
effectiveServiceMask
provisionalServiceMask
authorizedForWidgetUpdates
staticServiceMask
_authorizedForWidgetUpdates
_transientAwareRegistrationResult
_registrationResult
_inUseLevel
_staticServiceMask
_effectiveServiceMask
_provisionalServiceMask
TQ,R,N,V_staticServiceMask
TQ,R,N,V_effectiveServiceMask
TQ,R,N,V_provisionalServiceMask
Ti,R,N,V_transientAwareRegistrationResult
Ti,R,N,V_registrationResult
TB,R,N,V_authorizedForWidgetUpdates
Ti,R,N,V_inUseLevel
convertToSwimEntry:
cachePopulationReplyBlocks
setCachePopulationReplyBlocks:
_cachePopulationReplyBlocks
T@"NSDictionary",&,N,V_clients
T@"NSMutableArray",&,N,V_cachePopulationReplyBlocks
_loadSubjectUUID
_registerDevice
_initializeValueForKey:withDefault:
_shouldLogValueForKey:
sharedSession
_saveSubjectUUID:
_saveSubjectAuth:
_enableDataCollection
dataTaskWithRequest:completionHandler:
initWithSubjectUUID:studyUUID:channel:payloadType:certificate:
backgroundSessionConfigurationWithIdentifier:
_encryptData:metaData:start:end:
uploadTaskWithRequest:fromFile:
setTaskDescription:
sortedArrayUsingSelector:
setStartDate:
setEndDate:
_createKeyValuePairsDict:metaData:
setKeyValuePairs:
setPayloadIdentifier:
startWithError:
appendData:error:
finalizeWithError:
_loadSubjectAuth
configuration
taskDescription
initWithBytesNoCopy:length:encoding:freeWhenDone:
onDataProtectionManagerNotification:data:
dataCollectionEnabled
_urlSession
_studyUUID
_subjectUUID
_subjectAuth
_registrationTimer
_registerURL
_ingestURL
_hcConfig
_registrationTimerFireInterval
_logDirectory
_host
_registrationEndpoint
_submissionEndpoint
_studyID
_authorization
_certificate
_responses
_deviceUnlockedSinceBoot
_dataProtectionManagerClient
_dataCollectionEnabled
TB,R,N,V_dataCollectionEnabled
initWithBundleIdentifierOfCompanionApplication:error:
applicationIdentifier
companionApplicationIdentifier
counterpartIdentifiers
percentUnit
categorySampleWithType:value:startDate:endDate:device:metadata:
saveObject:withCompletion:
_writeToHealthKitType:value:startDate:endDate:metadata:
meterUnit
onboardingStatusWithError:
onboardingUnavailableReasons
isLocaleValidOnLocalDevice
isClassificationAvailable
dataCollectorDidRequestCollectionThroughDate:completion:
_healthStore
_featureStatusManager
_dataCollectorWalkingSpeed
_dataCollectorWalkingDoubleSupportPercentage
_dataCollectorWalkingStepLength
_dataCollectorWalkingAsymmetryPercentage
upload:metaData:
reregister
initWithUniverse:logFolder:delegate:
numberWithUnsignedShort:
isDiagnosticSubmissionAllowed
replenishTokens:
manualModeEnable
manualModeDisable
simulateAuthorized:
simulateDriving:
simulateTriggered
reRegisterServer
resetTokenTimer
sendKappaCmd:withPayload:andSize:
setCustomConfig:
syncgetKappaState
forceAudio:
forceGPS:
forceZg:
forcePulse:
forceBaro:
collect:
dontcollect
newCollectCompanion
heartbeatCompanion
_manualUUID
powerSource
setPowerSource:
setHasPowerSource:
hasPowerSource
powerSourceAsString:
StringAsPowerSource:
fitnessTrackingEnabled
setFitnessTrackingEnabled:
_powerSource
_fitnessTrackingEnabled
TB,N,V_fitnessTrackingEnabled
Ti,N,V_powerSource
preferredLanguages
currentLocale
localeIdentifier
writeBigEndianFixed16:
writeBigEndianShortThenString:
initWithVehicleStateNotifier:
_vehicleStateNotifier
fetchVehicularDndOperatorStateWithReply:
fetchVehicularDndStateAndHintsAndOperatorStateWithReply:
resetVehicularFalsePositiveSuppressionDnd
syncgetVehicularDndState
syncgetVehicularDndHints
syncgetVehicularDndOperatorState
setNrarfcn:
setHasNrarfcn:
_nrarfcn
Tq,N,V_cellID
Ti,N,V_nrarfcn
setHasDistance:
hasDistance
setHasAccuracy:
hasAccuracy
setHasGpsAltitude:
hasGpsAltitude
setHasSpeed:
hasSpeed
setHasRawSpeed:
hasRawSpeed
setHasGpsSpeedAccuracy:
hasGpsSpeedAccuracy
quality
setQuality:
setHasQuality:
hasQuality
qualityAsString:
StringAsQuality:
gpsAltitude
rawSpeed
gpsSpeedAccuracy
_gpsAltitude
_gpsSpeedAccuracy
_quality
_rawSpeed
Tf,N,V_accuracy
Tf,N,V_gpsAltitude
Tf,N,V_rawSpeed
Tf,N,V_odometer
Tf,N,V_gpsSpeedAccuracy
Ti,N,V_quality
smoothLocations:useType:
smoothLocations:workoutActivity:handler:
exportedInterface
didSmoothLocations:ofType:
visitMonitorWakeTimerEnabled
setVisitMonitorWakeTimerEnabled:
wifiPowerEnabled
setWifiPowerEnabled:
lastUpdateVisitMonitorWakeTimerDate
setLastUpdateVisitMonitorWakeTimerDate:
_visitMonitorWakeTimerEnabled
_wifiPowerEnabled
_lastUpdateVisitMonitorWakeTimerDate
TB,N,V_visitMonitorWakeTimerEnabled
TB,N,V_wifiPowerEnabled
T@"NSDate",&,N,V_lastUpdateVisitMonitorWakeTimerDate
maxPedometerEntries
setEnabled:
syncgetCopyRawSpeedToKValueBins
syncgetCopyStepCadenceToStrideLengthBins
setRawSpeedToKValueBins:
setStepCadenceToStrideLengthBins:
syncgetRawSpeedToKValueDefaultBins
syncgetStepCadenceToStrideLengthDefaultBins
syncgetIsStrideCalibrationConvergedMedianForSpeed:
resumeCalorimetryAfterPendingStepCountNotifications
initWithCalibrationTracks:rawSpeedToKValueBins:stepCadenceToStrideLengthBins:
setFloorsAscended:
setFloorsDescended:
onKFFilteredPressure:
_kfFilteredPressureDispatcher
_lastPressureBufferTimestamp
clearCalibrations
initWithSwimEntry:
syncgetBiasFit:
setUniverse:
_registerForNotifications
_checkAudioStreamState
_unregisterForNotifications
systemCoexImpact:toState:
_recomputeCoexImpactedStateAndNotifyClients
findMyAppDidBackgroundOrExit
systemWillSleep:
systemConnectivity:isConnected:
systemMetricHeartbeat
initWithUniverse:
coexImpactState
_onAppMonitorNotification:data:
_onDaemonStatusNotification:data:
_onWifiServiceNotification:data:
_appMonitorClient
_daemonStatusClient
_btStreaming
_wifiNetworkCritical
_isCoexImpacted
_isAssociatedTo2GHzWiFi
_audioStreamNotificationToken
T@"<CLIntersiloUniverse>",&,V_universe
T@"<CLDurianSystemMonitorDelegate>",N,V_delegate
Ti,R
initWithSuiteName:
addObserver:forKeyPath:options:context:
removeObserver:forKeyPath:context:
observeValueForKeyPath:ofObject:change:context:
compare:options:
fileSystemRepresentation
initWithSilo:vendor:
setGlobalConfiguration:
rereadConfiguration:
setRecordingTriggerMap:outputPathBase:
ensureServiceIsRunning:
initWithMemoryCapacity:diskCapacity:diskPath:
setSharedURLCache:
setServiceReplacementMap:missBehavior:
pairSupportsRegulatorySync
setPairSupportsRegulatorySync:
fNearbydIfMgrInstance
_pairSupportsRegulatorySync
TB,N,V_pairSupportsRegulatorySync
initWithCalendarIdentifier:
getTechnologiesInUseWithReplyBlock:
getMicroLocationInternalVersionWithReplyBlock:
getZaxisStatsWithReplyBlock:
getGnssBandsInUseWithReplyBlock:
getAppsUsingLocationWithReplyBlock:
setLocationDefaultForKey:andValue:replyBlock:
getLocationDefaultForKey:replyBlock:
timeZoneForLocation:replyBlock:
setGestureServiceEnabled:replyBlock:
triggerExpiredAuthorizationPurgeWithReplyBlock:
setTemporaryAuthorizationStatusForBundleId:orBundlePath:statusData:replyBlock:
getTemporaryAuthorizationStatusForBundleId:orBundlePath:replyBlock:
modifyOrSetAuthorizationTime:forBundleID:orBundlePath:replyBlock:
performMigrationWithReplyBlock:
shutdownDaemonWithReplyBlock:
setAuthorizationStatus:withCorrectiveCompensation:forBundleID:orBundlePath:replyBlock:
setPrivateMode:replyBlock:
getPrivateMode:
setLocationServicesEnabled:replyBlock:
getLocationServicesEnabledWithReplyBlock:
setAuthorizationPromptMapDisplayEnabled:replyBlock:
getAuthorizationPromptMapDisplayEnabledWithReplyBlock:
getGestureServiceEnabledWithReplyBlock:
pingDaemonWithReplyBlock:
getAuthorizationStatusForBundleID:orBundlePath:replyBlock:
getIncidentalUseModeForBundleID:orBundlePath:replyBlock:
getPrecisionPermissionForBundleID:orBundlePath:replyBlock:
displayStatisticsWithReplyBlock:
dumpLogsWithDescription:replyBlock:
copyLastLogWithReplyBlock:
getMonitoredRegionsForBundleID:orBundlePath:replyBlock:
checkAndExerciseAuthorizationForBundleID:orBundlePath:services:replyBlock:
registerCircularInterestZoneWithId:latitude:longitude:radius:serviceMaskOperator:provenanceType:forBundleId:orBundlePath:replyBlock:
registerPhenolicInterestZoneWithId:phenolicLocation:serviceMaskOperator:provenanceType:forBundleId:orBundlePath:replyBlock:
setRelevance:forInterestZoneWithId:registeredForBundleId:orBundlePath:replyBlock:
deleteInterestZoneWithId:registeredForBundleId:orBundlePath:replyBlock:
getLocationForBundleID:orBundlePath:dynamicAccuracyReductionEnabled:allowsAlteredAccessoryLocations:replyBlock:
getGroundAltitudeForBundleID:orBundlePath:location:replyBlock:
resetAllClientsWithReplyBlock:
applyArchivedAuthorizationDecisions:withConfirmationToken:replyBlock:
getArchivedAuthorizationDecisionsWithReplyBlock:
setStatusBarIconEnabledForEntityClass:enabled:replyBlock:
getStatusBarIconEnabledForEntityClass:replyBlock:
getStatusBarIconState:
setMapMatchingRouteHint:routingType:stepType:replyBlock:
getAccessoryTypeBitSetWithReplyBlock:
getPipelinedCacheWithReply:
setTemporaryAuthorizationGranted:forBundleID:orBundlePath:orAuditToken:byLocationButton:voiceInteractionEnabled:replyBlock:
getActivitiesWithReplyBlock:
updateCorrectiveCompensationChoiceForOutstandingPrompt:replyBlock:
setIncidentalUseMode:forBundleID:orBundlePath:replyBlock:
setAuthorizationStatusByType:withCorrectiveCompensation:andZoneIdentifier:forBundleID:orBundlePath:replyBlock:
gyroCalibrationDatabaseSupportsMiniCalibrationWithReplyBlock:
setBackgroundIndicatorEnabled:forBundleID:orBundlePath:replyBlock:
getOscarTimeSyncWithReplyBlock:
notifyWeatherForecast:airQualityConditions:hourlyForecasts:dailyForecasts:latitude:longitude:
currentToken
propertyListWithData:options:format:error:
dataWithPropertyList:format:options:error:
getEffectiveClientName:bundlePath:name:
getIntersiloDelegate
getAsyncResponseSilo
auditToken
subpathsAtPath:
groundAltitudeDistanceThreshold
setGroundAltitudeDistanceThreshold:
_groundAltitudeDistanceThreshold
Td,N,V_groundAltitudeDistanceThreshold
teardownListeners
setWorkingDirectory:
setupListeners
retrieveCachedCompassCalibration
writeWatchOrientation
writeWatchOnWristStatus
writeBodyMetrics
writeHealthKitInfo
writeStrideCalBins
deleteWorkingDirectory
fileURLWithPathComponents:
makeSafeCFAbsoluteTime:
resetBodyMetrics
setupHealthKitQueries
handleBrightnessClientNotification:withValue:
teardownHealthKitQueries
makeSafeAbsoluteElevation:
objectType
sampleType
_beatsPerMinute
stopQuery:
initWithType:predicate:anchor:limit:resultsHandler:
setUpdateHandler:
initWithDelegate:universe:settings:
start:recentLocation:
recordingURLs
onAccelerometer800Data:count:
onCatherineNotification:data:
onWatchOrientationNotification:data:
onMagnetometerData:
onCompassCalibrationData:
onNatalimetryNotification:data:
onWifiScanNotification:data:
_workingDirectory
_accelerometerDispatcher
_accel800Dispatcher
_deviceMotionDispatcher
_heartRateObserverClient
_odometerObserverClient
_watchOrientationObserverClient
_natalimetryClient
_motionStateMediatorClient
_wifiClient
_pressureDispatcher
_brightnessSystemClient
_magnetometerDispatcher
_compassCalibrationDispatcher
_healthKit
_healthKitQueries
_metadata
_watchOrientation
_watchOnWristStatus
_healthKitInfo
_startLocation
_wifiLookupTable
_privacyTimeOffset
_privacyElevationOffset
_privacyPressureOffset
_disablePrivacyElevationOffset
_disableBodyMetrics
_disableWatchOrientation
_disableWatchOnWristStatus
_disableHealthKitInfo
_disableWifiScans
_disablePressure
_disableStrideCalBins
_disableALS
_disableLatLong
_disableHeartRate
_disableMeanMaxMets
fWorkoutRecorderAccelSampleCount
T@"NSArray",R,N
T@"NSDictionary",R,C,N
cancelDeferredStopTimer
canStartRecording:settings:publisher:
getWorkingDirectory
getRecentLocation
publishRecording
initWithDelegate:settings:
didPublishRecording:settings:publisher:
initWithDelegate:universe:andSettings:
initializePowerAssertion
startRecording
scheduleStopWithHandler:
stopRecordingShouldPublish:
handlePublisherResponse:
getDelegate
getUniverse
getDeferredStopTimer
isRecording
_deferredStopTimer
_powerAssertion
_recording
_settings
_publisher
onDeferredStopTimerShouldPublish:
initWithDelegate:andUniverse:
_workoutSession
createWorkingDirectory
workingDirectoryHasSufficientFreeSpace
canPublish
acquireTokenWithSettings:publisher:
publishDataFiles:metadata:startDate:endDate:settings:
attributesOfFileSystemForPath:error:
handleResponse:
T@"CLDispatchSilo",R,N
T@"CLSilo",R,N
T@"CLServiceVendor",R,N
publisher
_deviceUnlocked
_dataProtectionClient
_workoutRecorderTrigger
_drivingRecorderTrigger
_recentLocation
T@"CLDispatchSilo",R,&,D,N
T@"CLWorkoutRecorderPublisher",R,&,N,V_publisher
checkInForActivityWithIdentifier:
scheduleVacuumWithReason:
vacuumAll
retryActivityForEncryptionClass:reason:
onActivity:withIdentifier:
isReadyToVacuumEncryptionClass:
_deferVacuum
_activities
_disabled
lowercaseString
setSessionSendsLaunchEvents:
set_requiresPowerPluggedIn:
encryptData:metaData:start:end:
subjectToken
reregisterDevice
healthWrapConfiguration
appendDataFromFileURL:error:
payloadIdentifier
setSubjectUUID:
setSubjectToken:
sendRegisterRequest
unregisterDevice
subjectUUID
handleIngestResponse:data:url:didCompleteWithError:
handleRegistrationResponse:data:url:didCompleteWithError:
handleConfigurationResponse:data:url:didCompleteWithError:
setHealthWrapConfiguration:
isAutoRegistration
setAutoRegistration:
_subjectUUIDKey
_subjectAuthKey
_subjectToken
_healthWrapConfiguration
_autoRegistration
T@"NSString",C,N
T@"HKHealthWrapMessageConfiguration",C,N,V_healthWrapConfiguration
autoRegistration
TB,N,GisAutoRegistration,V_autoRegistration
onDeferredStartTimer
cancelDeferredStartTimer
scheduleStart
_motionStateObserverClient
_enableVehicularNotifications
_deferredStartTimer
CLPredictedWalkDistanceServiceCompanionProtocol
CLPredictedWalkDistanceServiceCompanionClientProtocol
CLPredictedWalkDistanceServiceCompanion
CMLogItemInternal
CMLogItem
NSSecureCoding
NSCoding
NSCopying
CLTileSyncSyChange
SYChange
NSObject
CLTileSyncSySerializer
SYChangeSerializer
CLTileSyncDelegate
PSYSyncCoordinatorDelegate
PSYInitialSyncStateObserverDelegate
SYServiceDelegate
SYSessionDelegate
ALCMElevation
CLCKVO2MaxEstimate
CLHealthAssessmentNotifierProtocol
CLNotifierServiceProtocol
CLIntersiloServiceProtocol
CLIntersiloProxyDelegateProtocol
CLHealthAssessmentNotifierClientProtocol
CLNotifierServiceClientProtocol
CLIntersiloClientProtocol
CLHealthAssessmentNotifierAdapter
CLHealthAssessmentResultDelegate
IsSupported
CLStreamedLocationProviderProtocol
CLLocationProviderProtocol
CLStreamedLocationProviderClientProtocol
CLLocationProviderClientProtocol
CLStreamedLocationProviderAdapter
CLLocationStreamingConnectionManagerClientProtocol
CLStreamedLocationProviderAssertion
CLStreamedLocationProviderDisablementAssertion
CLStreamedLocationProviderEmergencyEnablementAssertion
CLStreamedLocationProviderServerDiscoverer
ALMotionState
ALCMMotionContextMotionState
CLCertificatePinningHelper
ALCLStrideCalEntry
ALCLStepCountEntry
ALCLSedentaryAlarmData
CLDeviceMotionProperties
RTVisit
ALCLNatalieFeatures
ALCLBodyMetrics
ALCLMotionActivity
ALActivityOverrideMsg
ALActivityLog
CLActivityLoggerProtocol
CLActivityLoggerClientProtocol
CLActivityLoggerAdapter
CLHarvesterProtocol
CLHarvesterClientProtocol
CLHarvesterService
CLOdometerNotifierProtocol
CLOdometerNotifierClientProtocol
CLOdometerNotifierAdapter
CLDistributedSensingServiceProtocol
CLDistributedSensingServiceClientProtocol
CLDistributedSensingService
CLVO2MaxCloudKitManagerProtocol
CLVO2MaxCloudKitManagerClientProtocol
CLVO2MaxCloudKitManager
CKSyncEngineDataSource
TRANSITPbRegionPreloadTile
CMStrideCalibrationStepCountBuffer
CLAvengerScannerPolicy
CLHarvestAccessoryLocationProviderAdapter
CLFileDownloadTaskDelegate
NSURLSessionTaskDelegate
NSURLSessionDelegate
CLFallHealthKitManager
WithSilo
CLSedentaryTimerNotifierProtocol
CLSedentaryTimerNotifierClientProtocol
CLSedentaryTimerNotifierAdapter
CLFallModelSelector
ALCLJacksonData
TRANSITPbTransitTile
CLDuetForegroundApp
CLDuetHomeKitScene
CLDuetHomeKitAccessory
CLDuetHomeKitAppView
CLDuetNowPlaying
CLKeychainItemWrapper
CLLocationStreamingMessage
CLLocationStreamingConnectionManagerServiceProtocol
CLLocationStreamingConnectionManager
IDSServiceDelegate
CLBarometerCalibrationSourceCompanion
CLVO2MaxServiceProtocol
CLVO2MaxServiceClientProtocol
CLVO2MaxService
WPHomeKit
BackwardsCompatible
CLHomeKitProviderProtocol
CLHomeKitProviderClientProtocol
CLHomeKitProviderAdapter
CLHomeKitDelegate
CBCentralManagerDelegate
CLTelephonyServiceProtocol
CLTelephonyServiceClientProtocol
CLTelephonyServiceAdapter
CLWifiServiceProtocol
CLWifiServiceClientProtocol
CLWifiServiceAdapter
ALCLStrideCalEntryDeprecated
CLMotionStateRoutineAdapter
CLMotionStateProtocol
CLMotionStateClientProtocol
CLMotionStateAdapter
CLGyroCalibrationDatabaseProtocol
CLGyroCalibrationDatabaseClientProtocol
CLGyroCalibrationDatabaseLocationdAdapter
CLSettingsManagerProtocol
CLSettingsManagerClientProtocol
CLDaemonSettingsManager
CLLocationDerivedSpeedEstimator
CLRoutineMonitorClientProtocol
CLCompanionNotifierProtocol
CLCompanionNotifierClientProtocol
CLCompanionNotifierAdapter
isSupported
CLDaemonStatusStateTracker
CLDaemonStatusInternal
RadiosPreferencesDelegate
CLDaemonStatusProtocol
CLDaemonStatusClientProtocol
CLDaemonStatusAdapter
CLHarvestDataMotionActivity
CLHarvestDataAccessPoint
CLHarvestScoredRequestArchive
CLAccessoryObserverHelper
BiasEstimation
ALSLocationDelegate
PBSessionRequesterDelegate
CLBarometerCalibrationSource
CLCompanionSyncInterestZone
CLTimeManagerProtocol
CLTimeManagerClientProtocol
CLTimeManagerAdapter
CLLocationControllerProtocol
CLLocationControllerClientProtocol
CLEmergencyClientProtocol
CLLocationControllerAdapter
CLWifiLocationProviderProtocol
CLWifiLocationProviderClientProtocol
CLWifiLocationProviderAdapter
CLMotionStateMediatorProtocol
CLMotionStateMediatorClientProtocol
CLMotionStateMediatorAdapter
CLLocationProviderAdapter
CLBarometerCalibrationBiasEstimator
CLNetworkLocationProviderProtocol
CLNetworkLocationProviderClientProtocol
CLNetworkLocationProviderAdapter
CLAccessoryLocationProviderProtocol
CLAccessoryLocationProviderClientProtocol
CLAccessoryLocationProviderAdapter
CLDaemonStatsFetchLocationSystemStateAdapter
CLFilteredLocationControllerProtocol
CLFilteredLocationControllerClientProtocol
CLFilteredLocationControllerAdapter
CLSensorMonitorProtocol
CLSensorMonitorClientProtocol
CLSensorMonitor
SRSensorWriterSensorConfigurationDelegate
SRSensorWriterDelegate
CLRouteListener
GEONavigationListenerDelegate
TRANSITPbRegionPreloadManifest
ALCLSessionCatherine
ALCMCalorieData
CLClientManagerStateTracker
CLClientManagerProtocol
CLClientManagerPublicProtocol
CLClientManagerClientProtocol
CLClientManagerAdapter
CMVehicleStateData
CLSignificantVisitManagerExtensions
CLSignificantVisitManagerProtocol
CLSignificantVisitManagerClientProtocol
CLSignificantVisitManager
CLClientAuthorizationCacheClientProtocol
CLBarometerCalibrationSourceLocation
CLCarrierSettingsProtocol
CLCarrierSettingsClientProtocol
CLCarrierSettingsAdapter
TRANSITPbLocationFingerprints
CLPredictedWalkDistanceServiceWatchProtocol
CLPredictedWalkDistanceServiceWatchClientProtocol
CLPredictedWalkDistanceServiceWatch
CLAbsoluteAltitudeClientLocal
CLWatchOrientationSettingsNotifierProtocol
CLWatchOrientationSettingsNotifierClientProtocol
CLWatchOrientationSettingsNotifierAdapter
CSLSOnWristMonitorDelegate
CLDiagnosticManagerServiceProtocol
CLDiagnosticManagerClientProtocol
CLDiagnosticManagerXPCServerInterface
CLDiagnosticManager
NSFileManagerDelegate
CLLocationCorrectiveCompensatorProtocol
CLLocationCorrectiveCompensatorClientProtocol
CLLocationCorrectiveCompensator
TRANSITPbRegionPreloadMarket
CLZoneRelevanceMonitorProtocol
CLZoneRelevanceMonitorClientProtocol
CLZoneRelevanceMonitor
CLLocationStreamerServiceProtocol
CLLocationStreamerClientProtocol
CLLocationStreamer
CLCorrectiveCompensatedLocationProviderProtocol
CLCorrectiveCompensatedLocationProviderClientProtocol
CLCorrectiveCompensatedLocationProviderAdapter
////////%0
CLCachedLocationControllerProtocol
CLCachedLocationControllerClientProtocol
CLCachedLocationControllerAdapter
CLTileDownloadSchedulingServiceProtocol
CLTileDownloadSchedulingClientProtocol
CLTileDownloadSchedulingService
CMStrideCalDataContainer
WPAirPlaySolo
CLATVAirplayDevice
CPPObject
CLATVAirplayMonitorServiceProtocol
CLATVAirplayMonitor
CMStrideCalibrator
CMStrideCalibrationDatabaseDelegate
CMStrideCalLocationFSMDelegate
CLFitnessTrackingNotifierProtocol
CLFitnessTrackingNotifierClientProtocol
CLFitnessTrackingNotifierAdapter
CLClientManagerUsageSyncMessage
CLClientManagerUsageSyncMessageError
CLUsageSyncManagerProtocol
CLUsageSyncManagerClientProtocol
CLUsageSyncManager
CLHealthAssessmentResult
TRANSITPbTransitMacTile
CLTimeZoneManagerProtocol
CLTimeZoneManagerClientProtocol
CLTimeZoneManagerAdapter
CLFenceManagerProtocol
CLFenceManagerClientProtocol
CLFenceManagerAdapter
CLMotionAlarmSubscriptionAdapter
CLMotionAlarmNotifierClientProtocol
CLAuthSyncVectorClock
ALCMCoarseElevation
CLTransitMacTileDataProviderProtocol
CLAppTileDataProviderClientProtocol
CLTransitMacTileDataProvider
CLTransitMacTileDataProviderResult
ALCLStairClimbingModel
CLHealthAssessmentChoreaDetectionService
PSYSyncCoordinator
PSYServiceSyncSession
PSYInitialSyncStateObserver
CMStrideCalibrationStats
CLOSTransaction
CLPersistentTimerInternal
ALCLAllDayHeartRate
ClientRegistration
CLMotionAlarmNotifierProtocol
CLMotionAlarmNotifierAdapter
ALCLRowingModel
CLSimulatedLocationProviderProtocol
CLSimulatedLocationProviderClientProtocol
CLSimulatedLocationProviderAdapter
CLCompanionActivityAWDAggregatorServiceProtocol
CLCompanionActivityAWDAggregatorClientProtocol
CLCompanionActivityAWDAggregator
CLAuthSyncManagerProtocol
CLAuthSyncManagerClientProtocol
CLAuthSyncManager
LPPushTokenServerProtocol
CLLocationPushRegistrar
CLCatherineNotifierProtocol
CLCatherineNotifierClientProtocol
CLCatherineNotifierAdapter
CLPropertyValue
CLFallNotifierClientAdapter
CLNatalimetryNotifierClientProtocol
CLFallNotifierProtocol
CLFallNotifierClientProtocol
CLFallNotifierAdapter
CLFallNotifierSysdiagnoseLogCollector
ALCLIDSStatus
CLEmergencyEED2LocManagerDelegate
CLLocationManagerDelegate
CLCompassDatabaseProtocol
CLCompassDatabaseClientProtocol
CLCompassDatabaseLocationdAdapter
CMStrideCalibrationActivityBuffer
CLDuetRegistration
CLDuetMonitorRegistrationId
CLDuetMonitorServiceProtocol
CLDuetMonitor
CLDuetPredicates
CLBarometerCalibrationProtocol
CLBarometerCalibrationClientProtocol
CLBarometerCalibration
CLBarometerCalibrationAggregatorClient
CLBarometerCalibrationContextClient
CLSuggestedActionServiceProtocol
CLSuggestedActionClientProtocol
CLSuggestedActionManager
CLAvailabilityRegionChangeMonitor
CLCKVO2MaxSessionInput
CLCompanionTransport
ALCMCalorieDataDeprecated
TRANSITPbLocationFingerprint
ConversionSupport
Initializers
#` `
CLBundleLocationProviderContext
CLMotionLoggerAdapter
CLMobilityWalkingBoutServiceClientProtocol
???4
CLDeepCopying
CLNewAppDiscoveryServiceProtocol
CLNewAppDiscoveryClientProtocol
CLNewAppDiscovery
CLSimulationControllerProtocol
CLSimulationControllerClientProtocol
CLSimulationXPCServerInterface
CLSimulationLocationProtocol
CLSimulationControllerAdapter
CLStepDistanceEstimator
CLBluetoothServiceProtocol
CLBluetoothServiceClientProtocol
CLBluetoothServiceAdapter
CLSubHarvesterAvengerExternalAdapter
CLOnBodyNotifierProtocol
CLOnBodyNotifierClientProtocol
CLOnBodyNotifierAdapter
CMPedometerTable
CLMeCardEntry
CLPlaceInferenceSubscriptionAdapter
CLCompanionSyncAuthObject
CLPressureCalibrationDatabaseProtocol
CLPressureCalibrationDatabaseClientProtocol
CLPressureCalibrationDatabaseAdapter
CLCapabilityMonitorServiceProtocol
CLCapabilityMonitorClientProtocol
CLCapabilityMonitor
ALCLElevationDeprecated
CLSignificantChangeManagerProtocol
CLSignificantChangeManagerClientProtocol
CLSignificantChangeManagerAdapter
CLApplicationLifecycleManagerProtocol
CLApplicationLifecycleManagerClientProtocol
CLApplicationLifecycleManagerAdapter
NSData_Conversion
CLCoarseCellTilesManagerProtocol
CLCoarseCellTilesManagerClientProtocol
CLCoarseCellTilesManagerAdapter
CMStrideCalLocationFSM
CLMagneticAccessoryProtocol
CLMagneticAccessoryClientProtocol
CLMagneticAccessoryAdapter
CLCKVO2MaxCalorimetryInput
CMStrideCalibrationDatabase
DataInput
CLFallMslSink
CLDMVisionServiceProtocol
CLDMVisionServiceClientProtocol
CLDMVisionService
CLInterval
CLRoutineMonitorServiceProtocol
CLLocationManagerRoutineServerInterface
CLLocationManagerRoutineClientInterface
CLRoutineMonitor
NSXPCListenerDelegate
CLPressureStatsCollectorProtocol
CLPressureStatsCollectorClientProtocol
CLPressureStatsCollector
CLFenceMonitorAdapter
CLGeomagneticModelProviderProtocol
CLGeomagneticModelProviderClientProtocol
CLGeomagneticModelProviderLocationdAdapter
TRANSITPbTransitMac
CLSignalEnvironmentProviderProtocol
CLSignalEnvironmentProviderClientProtocol
CLSignalEnvironmentProviderAdapter
CLWeatherServiceData
CLWeatherServiceProtocol
CLWeatherServiceClientProtocol
CLWeatherService
CLRemoteMotionAlarmServiceProtocol
CLRemoteMotionAlarm
CLUnifiedCellLocationProviderProtocol
CLUnifiedCellLocationProviderClientProtocol
CLUnifiedCellLocationProviderAdapter
CLScheduledEventTracker
CLRunningAggregatorAWDServiceProtocol
CLRunningAggregatorAWDClientProtocol
CLRunningAggregatorAWD
CLSkiNotifierProtocol
CLSkiNotifierClientProtocol
CLSkiNotifierAdapter
CLContextManagerAbsoluteAltimeter
CLPolygonSimplifier
CLAvengerObservationReporterServiceProtocol
CLAvengerObservationReporterClientProtocol
CLAvengerObservationReporterService
CLGnssProviderAdapter
CLDataProtectionManagerProtocol
CLDataProtectionManagerClientProtocol
CLDataProtectionManagerAdapter
CLCKVO2MaxSessionOutput
CLStatusBarIconManagerProtocol
CLStatusBarIconManagerClientProtocol
CLStatusBarIconManagerAdapter
CLDaemonInUseAssertionAdapter
CLStreamingAwareLocationProviderProtocol
CLStreamingAwareLocationProviderAdapter
CLRemoteMotionAlarmClientProtocol
CLCompanionNotifierCompanionAdapter
CLUsageReportCoordinate
CLStepCountSubscriptionAdapter
CLStepCountNotifierClientProtocol
CLLoiLocationProviderRoutineAdapter
CLLoiLocationProviderProtocol
CLLoiLocationProviderClientProtocol
CLLoiLocationProviderAdapter
CLMobilityWalkingBoutServiceProtocol
CLMobilityWalkingBoutService
CLAvengerScannerReconciledInformation
CLAvengerScannerStateContext
CLAvengerScannerServiceProtocol
CLAvengerScannerClientProtocol
CLAvengerScanner
CLAvengerScannerPolicyDelegate
CLDurianSystemMonitorDelegate
ALSCdmaCellTower
CLCKVO2MaxSummary
ALCLSedentaryAlarmDataDeprecated
ALSCdmaEvdoTower
CLSensorCalibrationControllerProtocol
CLSensorCalibrationControllerClientProtocol
CLSensorCalibrationControllerAdapter
CSStoreObjects
SYObject
ALSCellTower
ALSLocation
ALSLocationRequest
ALSLocationResponse
CLVO2MaxSubscriptionAdapter
ALSLteCellTower
ALSNearbyRequest
CLBarometerCalibrationTrack
CLBarometerCalibrationAbsoluteAltitude
CLBarometerCalibrationBiasData
CLBarometerCalibrationContextManager
CLMicroLocationNotifierProtocol
CLMicroLocationNotifierClientProtocol
CLMicroLocationNotifierAdapter
CLMicroLocationIntersiloDelegate
CLDuetMonitorClientProtocol
CLATVAirplayMonitorClientProtocol
_cl_FileDescriptor
ALSNearbyResponse
CLBarometerCalibrationAdapter
ALSWirelessAP
CLALSRequester
CLAvengerScannerSettings
TRANSITPbLocationFingerprintV1
CLEmergencyControllerProtocol
CLEmergencyControllerAdapter
CLAutopauseProviderProtocol
CLAutopauseProviderClientProtocol
CLAutopauseProviderAdapter
CLPeerRangingNotifierProtocol
CLPeerRangingNotifierClientProtocol
CLPeerRangingNotifierAdapter
CLTilesManagerProtocol
CLTilesManagerClientProtocol
CLTilesManagerAdapter
CLContextManagerSignificantLocationVisit
CLFallTap2Radar
CLStreamedLocationInternal
CMPedometerTableRawSpeedToKValue
ALCMCoarseElevationDeprecated
CLContextManagerBiasEstimationScheduler
CLOdometerAlarm
CLPressureBiasProtocol
CLPressureBiasClientProtocol
CLPressureBiasAdapter
CLOdometerAlarmManagerProtocol
CLOdometerAlarmManagerClientProtocol
CLOdometerAlarmManager
ALCMWorkoutEventDeprecated
CLDistributedSensingSubscriptionClient
CalibrationTrack
CMGpsOdometerEntry
CMPedometerEntry
CalTrackFinder
ALCLNatalieDataDeprecated
CLKappaRecording
CLDaemonHealthClientAdapter
CLBarometerCalibrationSourceAggregator
CLBarometerCalibrationSourceClient
CLCKVO2MaxSessionAttributes
CLSubHarvesterAvenger
CLAvengerBeaconPayloadDedupingCache
CLOdometerSubscriptionAdapter
CLStreamedLocationPrivate
CLDaemonClientAdapter
CLDigitalElevationModelPublicProtocol
CLDigitalElevationModelClientProtocol
CLDigitalElevationModelAdapter
CLVehicleConnectionNotifierProtocol
CLVehicleConnectionNotifierPublicProtocol
CLVehicleConnectionNotifierClientProtocol
CLVehicleConnectionNotifierAdapter
CLMotionSyncStoreProtocol
CLMotionSyncStoreClientProtocol
CLMotionSyncStoreAdapter
CLLocationAwarenessProviderProtocol
CLLocationAwarenessProviderClientProtocol
CLLocationAwarenessProviderAdapter
CLFitnessMachineNotifierProtocol
CLFitnessMachineNotifierClientProtocol
CLFitnessMachineNotifierAdapter
CLPencilStateProtocol
CLPencilStateClientProtocol
CLPencilStateAdapter
CLAppMonitorProtocol
CLAppMonitorClientProtocol
CLAppMonitorAdapter
TRANSITPbLocationFingerprintsV1
CLMotionStateObserverProtocol
CLMotionStateObserverClientProtocol
CLMotionStateObserverAdapter
CLLocationSubscriptionStatusBarAssertion
CLLocationSubscriptionVisibilityAssertion
CLLocationSubscriptionSuperStickyAssertion
CLLocationSubscriptionAdapter
CLStreamingAwareLocationProviderClientProtocol
?7////////%0
0/////////-0
CLCellTilesManagerProtocol
CLCellTilesManagerClientProtocol
CLCellTilesManagerAdapter
CLFallLoggerManager
CLNotifiers
Callbacks
CLSensorRecorderSensorMetaSerializer
CLAuthPromptExtensionItem
CLWifiTilesManagerProtocol
CLWifiTilesManagerClientProtocol
CLWifiTilesManagerAdapter
CLBarometerCalibrationSim
CLNatalimetryNotifierProtocol
CLNatalimetryNotifierAdapter
CLCallbackDropNullDelegate
CLHRequestArchive
CLHLocationAwareRequestArchive
CLHRequestStore
CLAuthSerializer
CLAppTileDataProviderProtocol
CLAppTileDataProvider
CLAppTileDataProviderResult
CLAppTileDataProviderRequest
ALCMExerciseMinute
CLSensorRecorderNotifierProtocol
CLSensorRecorderNotifierClientProtocol
CLSensorRecorderNotifierAdapter
CLSensorRecorderAlmanacListener
CLBTLEBeaconProviderMockProtocol
CLBTLEBeaconProviderMockClientProtocol
CLBTLEBeaconProviderMockAdapter
CMStrideCalibrationElevationBuffer
CLHarvestDataTracks
CMMotionTimeRange
CLBTLEFenceManagerProtocol
CLBTLEFenceManagerClientProtocol
CLBTLEFenceManagerAdapter
CLSpringTrackingNotifierProtocol
CLSpringTrackingNotifierClientProtocol
CLSpringTrackingNotifierAdapter
CLHUploadRequest
CLHNetworkController
NSURLSessionDataDelegate
CLGpsAssistantProtocol
CLGpsAssistantClientProtocol
CLGpsAssistantAdapter
CLBarometerCalibrationSourceWifi
TRANSITPbMacModePair
CMActivityAlarmLocal
CLBTLEBeaconProviderProtocol
CLBTLEBeaconProviderClientProtocol
CLBTLEBeaconProviderAdapter
CLDarwinNotifierProtocol
CLDarwinNotifierClientProtocol
CLDarwinNotifierAdapter
CLEmergencyADRIDSBatchQueryDelegate
IDSBatchIDQueryControllerDelegate
CLFallLogger
CLBeaconFenceAuthorizationManagerProtocol
CLBeaconFenceAuthorizationManagerClientProtocol
CLBeaconFenceAuthorizationManagerAdapter
ALSScdmaCellTower
CLBTLERangeManagerProtocol
CLBTLERangeManagerClientProtocol
CLBTLERangeManagerAdapter
CMPedometerTableStepCadenceToStrideLength
CLTransitMacMonitorAccessPoint
CLTransitMacMonitorProtocol
CLTransitMacMonitorClientProtocol
CLTransitMacMonitor
CLTurnStateProtocol
CLTurnStateClientProtocol
CLTurnStateAdapter
CLTileDownloadSchedulingClient
CLHarvestExternalAdapter
CLHEndpointSelector
CLWorkoutGeoFenceController
CLKappaServer
CLDaemonSpringTrackingClientAdapter
CLHLocationClassifier
CLTrackingAvoidanceZoneMonitor
CLLocationMulticlientStreamerServiceProtocol
CLLocationMulticlientStreamerClientProtocol
CLLocationMulticlientStreamer
ALCMWorkoutEvent
CLNotifierClientAdapter
CLNotifierServiceAdapter
CLClientManagerAuthorizationContext
CLClientAuthorizationCacheProtocol
CLClientAuthorizationCache
CLVisitMonitoringSubscriptionExtensions
CLVisitMonitoringSubscriptionAdapter
CLFallServer
CLMobilityHealthKitWriter
CLHealthAssessmentTremorDetectionService
CLKappaNotifierProtocol
CLKappaNotifierClientProtocol
CLKappaNotifierAdapter
ALCMFitnessTracking
CLVehicleStateNotifierRoutineAdapter
CLVehicleStateNotifierTransitMacMonitorAdapter
CLVehicleStateNotifierProtocol
CLVehicleStateNotifierClientProtocol
CLVehicleStateNotifierAdapter
ALSNr5GCellTower
ALCLOdometer
CLSmootherMonitorServiceProtocol
CLSmootherMonitorClientProtocol
CLLocationSmootherServerInterface
CLLocationSmootherClientInterface
CLSmootherMonitor
CLStepCountNotifierProtocol
CLStepCountNotifierAdapter
CLBarometerCalibrationSourcePressure
CLSwimNotifierProtocol
CLSwimNotifierClientProtocol
CLSwimNotifierAdapter
CLSwimNotifierIntersiloDelegate
CLDurianSystemMonitor
DefaultObserver
CLNearbydInterfaceManagerProtocol
CLNearbydInterfaceManagerClientProtocol
CLNearbydInterfaceManagerAdapter
CLIntersiloDelegate
CLInternalServiceSiloProtocol
CLInternalServiceSiloClientProtocol
CLLocationInternalServiceProtocol
CLInternalService
CLWorkoutRecording
CLRecordingTriggerBase
CLWorkoutRecorderTrigger
CLWorkoutRecorderProtocol
CLWorkoutRecorderClientProtocol
CLWorkoutRecorder
CLWorkoutRecorderPublisherDelegate
CLWorkoutRecordingDelegate
CLIntersiloUniverse
CLRecordingTriggerDelegate
CLPrivacyManagerProtocol
CLPrivacyManagerClientProtocol
CLPrivacyManager
CLWorkoutRecorderPublisher
CLMotionHintLoggerProtocol
CLMotionHintLoggerClientProtocol
CLMotionHintLoggerAdapter
CLDrivingRecorderTrigger
v32@0:8@16d24
v44@0:8d16d24d32B40
v32@0:8r^i16r^(NotificationData={CLNatalieData=i^{__CFString}diBBddqqd[16C]}B{CLBodyMetrics=iiffffffffifBfBBB}f{CLExerciseMinuteData=id^{__CFString}}{CLStandMinuteInputData=dIId}{VO2MaxResult=dqdBBBB[16C]Bd}{VO2MaxSessionStats=dfB}d)24
v484@0:8{CLPredictedWalkDistanceEstimate=ddidddddddiiiidddiidddidddddddiidddd}16{StrideCalInfo=iiidddiddd}272{CLRunningStat=idddd}344{CLRunningStat=idddd}384{CLBodyMetrics=iiffffffffifBfBBB}424
v24@0:8r^{CLPredictedWalkDistanceEstimateAnalytics=diiiiffffifffiifffffifffff}16
{shared_ptr<CLPredictedWalkDistanceBoutRecorderDb>="__ptr_"^{CLPredictedWalkDistanceBoutRecorderDb}"__cntrl_"^{__shared_weak_count}}
{unique_ptr<CLActivityAggregator<CLPredictedWalkDistanceBoutEntry>, std::default_delete<CLActivityAggregator<CLPredictedWalkDistanceBoutEntry>>>="__ptr_"{__compressed_pair<CLActivityAggregator<CLPredictedWalkDistanceBoutEntry> *, std::default_delete<CLActivityAggregator<CLPredictedWalkDistanceBoutEntry>>>="__value_"^v}}
@"NSObject<OS_dispatch_source>"
{unique_ptr<CLPredictedWalkDistanceEstimator, std::default_delete<CLPredictedWalkDistanceEstimator>>="__ptr_"{__compressed_pair<CLPredictedWalkDistanceEstimator *, std::default_delete<CLPredictedWalkDistanceEstimator>>="__value_"^{CLPredictedWalkDistanceEstimator}}}
{shared_ptr<CLMobility::GaitMetricsRecorderDb>="__ptr_"^{GaitMetricsRecorderDb}"__cntrl_"^{__shared_weak_count}}
{list<CLPredictedWalkDistanceBoutEntry, std::allocator<CLPredictedWalkDistanceBoutEntry>>="__end_"{__list_node_base<CLPredictedWalkDistanceBoutEntry, void *>="__prev_"^v"__next_"^v}"__size_alloc_"{__compressed_pair<unsigned long, std::allocator<std::__list_node<CLPredictedWalkDistanceBoutEntry, void *>>>="__value_"Q}}
{shared_ptr<CLWalkingSpeedCalRecorderDb>="__ptr_"^{CLWalkingSpeedCalRecorderDb}"__cntrl_"^{__shared_weak_count}}
{unique_ptr<CLNatalimetryNotifier_Type::Client, std::default_delete<CLNatalimetryNotifier_Type::Client>>="__ptr_"{__compressed_pair<CLNatalimetryNotifier_Type::Client *, std::default_delete<CLNatalimetryNotifier_Type::Client>>="__value_"^{Client}}}
{CLBodyMetrics="gender"i"biologicalSex"i"heightM"f"weightKG"f"vo2max"f"age"f"hrmin"f"hrmax"f"hronset"f"pal"f"condition"i"runVo2max"f"betaBlockerUse"B"adaptiveExerciseMinuteThreshold"f"_isAgeSet"B"_isHeightSet"B"_isWeightSet"B}
@"HKHealthStore"
@24@0:8d16
B16@0:8
v24@0:8@16
@24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@24@0:8^{_NSZone=}16
v16@0:8
d16@0:8
B24@0:8@16
#16@0:8
@16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
q16@0:8
v24@0:8q16
@"NSString"
@"NSDictionary"
@32@0:8@16q24
@40@0:8@16q24q32
@"NSData"24@0:8@"<SYChange>"16
@"<SYChange>"32@0:8@"NSData"16q24
@"NSData"24@0:8@"<SYObject>"16
@"<SYObject>"24@0:8@"NSData"16
@"NSData"32@0:8@"<SYChange>"16q24
@"<SYChange>"40@0:8@"NSData"16q24q32
v32@0:8@16@24
v32@0:8@"PSYSyncCoordinator"16@"PSYServiceSyncSession"24
v24@0:8@"PSYSyncCoordinator"16
v32@0:8@"PSYInitialSyncStateObserver"16@"NSUUID"24
v24@0:8@"PSYInitialSyncStateObserver"16
B40@0:8@16@24^@32
v40@0:8@16@24@32
v40@0:8@16@24@?32
v48@0:8@16@24@32@?40
@40@0:8@16@24@32
v28@0:8@16B24
B40@0:8@"SYService"16@"SYSession"24^@32
v40@0:8@"SYService"16@"SYSession"24@"NSError"32
v40@0:8@"SYService"16@"NSData"24@?<v@?B@"NSError">32
v48@0:8@"SYService"16@"NSInputStream"24@"NSDictionary"32@?<v@?B@"NSError">40
v40@0:8@"SYService"16@"NSError"24@"NSDictionary"32
@"SYSession"40@0:8@"SYService"16@"SYSession"24@"SYSession"32
v40@0:8@"SYService"16@"NSUUID"24@"NSUUID"32
v28@0:8@"SYService"16B24
v24@0:8@"SYService"16
I40@0:8@16@?24^@32
B32@0:8@16^@24
v32@0:8@16@?24
I40@0:8@"SYSession"16@?<B@?@"<SYChange>">24^@32
v40@0:8@"SYSession"16@"NSArray"24@?<v@?B@"NSError">32
v32@0:8@"SYSession"16@"NSError"24
B32@0:8@"SYSession"16^@24
v32@0:8@"SYSession"16@?<v@?B@"NSError">24
v32@0:8@"SYSession"16@"NSSet"24
@32@0:8^v16@24
@"CLSilo"
@"PSYServiceSyncSession"
v20@0:8I16
v20@0:8B16
i16@0:8
v20@0:8i16
@20@0:8i16
i24@0:8@16
v20@0:8f16
I16@0:8
f16@0:8
{?="elevationDescended"b1"gradeType"b1"rawGradeType"b1"source"b1"verticalSpeed"b1}
{?="durationInSeconds"b1"estimatedHRRecoveryParam"b1"estimatedHRResponseParam"b1"estimatedVo2Max"b1"filteredVo2Max"b1"hrMax"b1"hrMin"b1"startTime"b1"variance"b1"numWorkoutsContrToEstimate"b1"sessionType"b1"workoutType"b1"eligibleForCalorimetry"b1"eligibleForHealthKit"b1}
v32@0:8@16Q24
v24@0:8r*16
@"CLSilo"16@0:8
v32@0:8@"NSArray"16Q24
v32@0:8@"CLSilo"16@?<v@?>24
v32@0:8@"<CLIntersiloProxyDelegateProtocol>"16@"CLSilo"24
v36@0:8R@16i24@28
v28@0:8R@16i24
v24@0:8R@16
v36@0:8R@"<CLNotifierServiceClientProtocol>"16i24@"CLCppContainer"28
v28@0:8R@"<CLNotifierServiceClientProtocol>"16i24
v24@0:8R@"<CLNotifierServiceClientProtocol>"16
v24@0:8@?16
v32@0:8@?16@?24
B24@0:8@?16
v24@0:8@?<v@?^v>16
v32@0:8@?<v@?^v>16@?<v@?>24
B24@0:8@?<v@?^v>16
v28@0:8i16@20
v28@0:8i16@"CLCppContainer"20
v28@0:8@16i24
v28@0:8@"NSDictionary"16i24
^v16@0:8
v32@0:8d16d24
v40@0:8^d16d24^B32
v24@0:8d16
@"CMSensorRecorder"
@"CLTimer"
@"CLHealthAssessmentChoreaDetectionService"
@"CLHealthAssessmentTremorDetectionService"
v36@0:8i16@20R@28
v36@0:8R@16i24d28
B32@0:8r^i16^v24
B24@0:8^{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16
B24@0:8^v16
v36@0:8i16@"CLCppContainer"20R@"<CLLocationProviderClientProtocol>"28
v36@0:8R@"<CLLocationProviderClientProtocol>"16i24d28
v24@0:8@"CLLocation"16
v36@0:8@16@24B32
v32@0:8@"NSString"16@"NSDictionary"24
v36@0:8@"CLLocationStreamingMessage"16@"NSError"24B32
v24@0:8@"CLLocationStreamingMessage"16
@"<CLStreamedLocationProviderProtocol>"
@"RPCompanionLinkClient"
@"NSObject<OS_dispatch_queue>"
@"NSMutableArray"
@"ALCMMotionContextMotionState"
@"ALCLNatalieFeatures"
{?="startTime"b1"exitState"b1"mounted"b1"mountedConfidence"b1"turn"b1"isMoving"b1"isVehicular"b1}
i40@0:8@16@24@?32
{?="timestamp"b1"pacebin"b1"recordId"b1"regularEntry"b1}
{?="pace"b1"timestamp"b1"recordId"b1}
{?="timestamp"b1}
{?="estExitTime"b1"startTime"b1"confidence"b1"exitState"b1"mountedConfidence"b1"mountedState"b1"tilt"b1"isStanding"b1"isVehicleConnected"b1}
@"ALCLMotionActivity"
@"ALActivityOverrideMsg"
@"ALCLAllDayHeartRate"
@"ALCLBodyMetrics"
@"ALCMCalorieData"
@"ALCMCalorieDataDeprecated"
@"ALCMCoarseElevation"
@"ALCMCoarseElevationDeprecated"
@"ALCMElevation"
@"ALCLElevationDeprecated"
@"ALCMExerciseMinute"
@"ALCMFitnessTracking"
@"ALCLIDSStatus"
@"ALCLJacksonData"
@"ALMotionState"
@"ALCLNatalieDataDeprecated"
@"ALCLOdometer"
@"ALCLRowingModel"
@"ALCLSedentaryAlarmData"
@"ALCLSedentaryAlarmDataDeprecated"
@"ALCLSessionCatherine"
@"ALCLStairClimbingModel"
@"ALCLStepCountEntry"
@"ALCLStrideCalEntry"
@"ALCLStrideCalEntryDeprecated"
@"ALCMWorkoutEvent"
@"ALCMWorkoutEventDeprecated"
v24@0:8@"PBCodable"16
v24@0:8^v16
v40@0:8@"NSString"16@"NSString"24@"NSDictionary"32
@"CLHEndpointSelector"
@"CLHLocationClassifier"
@"CLHNetworkController"
@"CLHRequestStore"
{shared_ptr<CLHarvestController>="__ptr_"^{CLHarvestController}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<CLMonitorGps>="__ptr_"^{CLMonitorGps}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<CLPolicyTrip>="__ptr_"^{CLPolicyTrip}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<CLPolicyProactive>="__ptr_"^{CLPolicyProactive}"__cntrl_"^{__shared_weak_count}}
{vector<std::shared_ptr<CLSubHarvester>, std::allocator<std::shared_ptr<CLSubHarvester>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::shared_ptr<CLSubHarvester> *, std::allocator<std::shared_ptr<CLSubHarvester>>>="__value_"^v}}
v40@0:8@"NSDate"16@"NSDate"24@?<v@?@"CMSignificantElevationSample">32
v24@0:8R@"<CLOdometerNotifierClientProtocol>"16
v24@0:8@?<{vector<CLOdometerEntry, std::allocator<CLOdometerEntry>>=^{CLOdometerEntry}^{CLOdometerEntry}{__compressed_pair<CLOdometerEntry *, std::allocator<CLOdometerEntry>>=^{CLOdometerEntry}}}@?>16
v28@0:8R@"<CLDistributedSensingServiceClientProtocol>"16i24
v24@0:8@"CMVehicleStateData"16
v24@0:8@"NSString"16
v24@0:8@"NSObject<OS_xpc_object>"16
v24@0:8@"NSData"16
@32@0:8@16@24
@"CKRecord"32@0:8@"CKSyncEngine"16@"CKRecordID"24
v32@0:8@"CKSyncEngine"16@"CKRecord"24
v40@0:8@"CKSyncEngine"16@"CKRecord"24@"NSError"32
v32@0:8@"CKSyncEngine"16@"CKRecordID"24
v40@0:8@"CKSyncEngine"16@"CKRecordID"24@"NSError"32
v40@0:8@"CKSyncEngine"16@"CKRecordID"24@"NSString"32
v32@0:8@"CKSyncEngine"16@"NSData"24
v32@0:8@"CKSyncEngine"16@"CKRecordZone"24
v32@0:8@"CKSyncEngine"16@"CKRecordZoneID"24
v40@0:8@"CKSyncEngine"16@"CKRecordZoneID"24@"NSError"32
v40@0:8@"CKSyncEngine"16@"CKRecordZone"24@"NSError"32
v32@0:8r^i16r^{NotificationData=iB}24
v32@0:8@16q24
{VO2MaxCloudKitSyncEngineMetadata=Qdd@}16@0:8
v32@0:8@16B24B28
v32@0:8B16B20B24B28
B32@0:8@16@24
{shared_ptr<CLVO2MaxInputCache>="__ptr_"^{CLVO2MaxInputCache}"__cntrl_"^{__shared_weak_count}}
{shared_ptr<CLVO2MaxInputStore>="__ptr_"^{CLVO2MaxInputStore}"__cntrl_"^{__shared_weak_count}}
{unique_ptr<CLVO2MaxStagingOutputStore, std::default_delete<CLVO2MaxStagingOutputStore>>="__ptr_"{__compressed_pair<CLVO2MaxStagingOutputStore *, std::default_delete<CLVO2MaxStagingOutputStore>>="__value_"^{CLVO2MaxStagingOutputStore}}}
{unique_ptr<CLVO2MaxRetrocomputeRecorderDb, std::default_delete<CLVO2MaxRetrocomputeRecorderDb>>="__ptr_"{__compressed_pair<CLVO2MaxRetrocomputeRecorderDb *, std::default_delete<CLVO2MaxRetrocomputeRecorderDb>>="__value_"^{CLVO2MaxRetrocomputeRecorderDb}}}
{unique_ptr<CLDataProtectionManager_Type::Client, std::default_delete<CLDataProtectionManager_Type::Client>>="__ptr_"{__compressed_pair<CLDataProtectionManager_Type::Client *, std::default_delete<CLDataProtectionManager_Type::Client>>="__value_"^{Client}}}
@"CKRecordZoneID"
{CLVO2MaxCloudKitStats="syncEngineEnabled"B"outputSaveQueuedCount"i"outputSaveAttemptedCount"i"outputSaveSuccessCount"i"outputSaveFailureCount"i"outputFetchSuccessCount"i"outputFetchFailureCount"i"inputSaveQueuedCount"i"inputSaveAttemptedCount"i"inputSaveSuccessCount"i"inputSaveFailureCount"i"inputFetchSuccessCount"i"inputFetchFailureCount"i"forcedFetchRequestedCount"i"secondsOfDataCollection"d}
@"CKContainer"
@"CKSyncEngine"
v24@0:8Q16
{?="secKey"b1"tileType"b1"tileX"b1"tileY"b1"isAllowOverCellular"b1}
v24@0:8r^(NotificationData={CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLExtendedStepCountEntry=d{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLStepCountEntryAddition=ddIddddBd}}{CLPedometerEvent=di}{CLOdometerSuitability=dBB})16
{queue<std::pair<double, unsigned int>, std::deque<std::pair<double, unsigned int>>>="c"{deque<std::pair<double, unsigned int>, std::allocator<std::pair<double, unsigned int>>>="__map_"{__split_buffer<std::pair<double, unsigned int> *, std::allocator<std::pair<double, unsigned int> *>>="__first_"^^v"__begin_"^^v"__end_"^^v"__end_cap_"{__compressed_pair<std::pair<double, unsigned int> **, std::allocator<std::pair<double, unsigned int> *>>="__value_"^^v}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<std::pair<double, unsigned int>>>="__value_"Q}}}
@24@0:8q16
@36@0:8@16q24B32
q88@0:8{CLAvengerScannerPolicyContext=BQQQQQqQBBBBB}16
v88@0:8{CLAvengerScannerPolicyContext=BQQQQQqQBBBBB}16
{CLAvengerScannerScanParameters=BB}16@0:8
@"<CLAvengerScannerPolicyDelegate>"
{CLAvengerScannerPolicyContext="optedIn"B"aggressiveDiscoveryScanCount"Q"coexFriendlyAggressiveDiscoveryScanCount"Q"btFindingDiscoveryScanCount"Q"watchAdvertisementBufferScanCount"Q"hawkeyeLowEnergyScanCount"Q"platformType"q"totalAdvertisementBuffersAvailable"Q"supportsPerTypeDuplicateFilter"B"associatedTo2GHzWiFi"B"wifi2GHzCriticalState"B"bluetoothAudioActive"B"downgradedDuringCoexFriendlyAggressiveDiscoveryScan"B}
v32@0:8@"NSURLSession"16@"NSError"24
v40@0:8@"NSURLSession"16@"NSURLAuthenticationChallenge"24@?<v@?q@"NSURLCredential">32
v24@0:8@"NSURLSession"16
v56@0:8@16@24@32@40@?48
v56@0:8@16@24q32q40q48
v48@0:8@"NSURLSession"16@"NSURLSessionTask"24@"NSURLRequest"32@?<v@?q@"NSURLRequest">40
v32@0:8@"NSURLSession"16@"NSURLSessionTask"24
v56@0:8@"NSURLSession"16@"NSURLSessionTask"24@"NSHTTPURLResponse"32@"NSURLRequest"40@?<v@?@"NSURLRequest">48
v48@0:8@"NSURLSession"16@"NSURLSessionTask"24@"NSURLAuthenticationChallenge"32@?<v@?q@"NSURLCredential">40
v40@0:8@"NSURLSession"16@"NSURLSessionTask"24@?<v@?@"NSInputStream">32
v56@0:8@"NSURLSession"16@"NSURLSessionTask"24q32q40q48
v40@0:8@"NSURLSession"16@"NSURLSessionTask"24@"NSURLSessionTaskMetrics"32
v40@0:8@"NSURLSession"16@"NSURLSessionTask"24@"NSError"32
v24@0:8r^{ImpactEvent={Impact=SCcQCCcBBBCQ{HighFrequencyFeatures={MagnitudeFeatures=ffffff}{JerkFeatures=f}}QfffffffffffffffffffffBCC(?={FeaturesAllDay=}{FeaturesPedestrian=}{FeaturesCycling=})}CCddddC}16
i32@0:8@16@24
i32@0:8^v16d24
i32@0:8@"NSString"16@"NSDictionary"24
i24@0:8@"NSString"16
B24@0:8^{FallModel=[17f][17f][17f][67f][21f][10f][16f][16f][8{LikelihoodRatioInfo=ffC}]}16
B24@0:8^{FallThresholds=ffffffffffiifffffiiiiBBBCCCC}16
@"NSMutableDictionary"
{FallModel="fRatioMaxAbsX"[17f]"fRatioMaxAbsY"[17f]"fRatioMaxAbsZ"[17f]"fRatioMaxJerkVM"[67f]"fRatioMinInertialZ"[21f]"fRatioAccelPathLength"[10f]"fRatioMaxAngleChangePreimpact"[16f]"fRatioMaxAngleChangePostimpact"[16f]"fLikelihoodRatioInfo"[8{LikelihoodRatioInfo="firstBinEdge"f"binSize"f"binNum"C}]}
{FallThresholds="fImpactMaxAccelNormAlertThreshold"f"fImpactMaxAccelNormLoggingStatsThreshold"f"fImpactMaxAccelNormLoggingHeartRateThreshold"f"fImpactMaxAccelNormLoggingHighResolutionSensorDataThreshold"f"fTripFallPosteriorRatioDetectionThreshold"f"fSlipFallPosteriorRatioDetectionThreshold"f"fOtherFallPosteriorRatioDetectionThreshold"f"fTripNearFallPosteriorRatioDetectionThreshold"f"fSlipNearFallPosteriorRatioDetectionThreshold"f"fOtherNearFallPosteriorRatioDetectionThreshold"f"fTotalLongLieThreshold"i"fConsecutiveLongLieThreshold"i"fAlertGatingMotionThreshold"f"fCyclingImpactGravityVarianceThreshold"f"fCyclingImpactCrownVarianceThreshold"f"fCyclingImpactMaxAbsYThreshold"f"fCyclingDistanceTraveledPostImpactThreshold"f"fCyclingEpochsDetectedPostImpactThreshold"i"fOtherWorkoutQuiescenceThresholdLow"i"fOtherWorkoutQuiescenceThresholdHigh"i"fOtherWorkoutConsecutiveLongLieThreshold"i"fOtherWorkoutShouldCancelAlertOnStepsThreshold"B"fOtherWorkoutShouldCancelAlertOnStandThreshold"B"fOtherWorkoutShouldCancelAlertOnActiveThreshold"B"fRefereeOperatingModeOverride"C"fAllDayStateMachineOperatingModeOverride"C"fCyclingStateMachineEnabledOverride"C"fAllDayStateMachineEnabledOverride"C}
{?="fPal"b1"lsest"b1"sumest"b1}
@"TRANSITPbLocationFingerprintsV1"
@"TRANSITPbLocationFingerprints"
{?="generationTimeSecs"b1"marketId"b1"securityKey"b1"expirationAgeSecs"b1"tileX"b1"tileY"b1"version"b1}
@80@0:8@16@24@32@40@48@56@64@72
@"NSNumber"
@104@0:8@16@24@32@40@48@56@64@72@80@88@96
@48@0:8@16@24@32@40
@32@0:8@16r^{__CFString=}24
v32@0:8@16r^{__CFString=}24
v24@0:8R@"<CLLocationStreamingConnectionManagerClientProtocol>"16
v64@0:8@16@24@32@40@48@56
v56@0:8@16@24@32@40@48
v56@0:8@16@24q32@40@48
v52@0:8@16@24@32B40@44
v60@0:8@16@24@32B40@44@52
v56@0:8@16@24@32q40q48
v48@0:8@16@24@32@40
v64@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"NSString"48@"IDSMessageContext"56
v40@0:8@"IDSService"16@"NSString"24@"NSArray"32
v56@0:8@"IDSService"16@"IDSAccount"24@"NSDictionary"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSData"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSProtobuf"32@"NSString"40@"IDSMessageContext"48
v56@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSString"40@"IDSMessageContext"48
v64@0:8@"IDSService"16@"IDSAccount"24@"NSURL"32@"NSDictionary"40@"NSString"48@"IDSMessageContext"56
v56@0:8@"IDSService"16@"IDSAccount"24q32@"NSString"40@"IDSMessageContext"48
v32@0:8@"IDSService"16@"NSSet"24
v32@0:8@"IDSService"16@"NSArray"24
v52@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44
v60@0:8@"IDSService"16@"IDSAccount"24@"NSString"32B40@"NSError"44@"IDSMessageContext"52
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32q40q48
v48@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@40
v56@0:8@"IDSService"16@"IDSAccount"24@"NSString"32@"NSString"40@48
v48@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSDictionary"48
v56@0:8@"IDSService"16@"IDSAccount"24@"IDSSession"32@"NSString"40@"NSData"48
v40@0:8@"IDSService"16@"IDSAccount"24@"IDSGroupSessionParticipantUpdate"32
v24@0:8@"IDSService"16
v40@0:8@"IDSService"16@"IDSDevice"24@?<v@?>32
@"NSMutableSet"
@"IDSService"
v156@0:8i16(NotificationData={CLOdometerEntry=dddddddddiiidddddd}{CLElevationChangeEntry=ddIIidiifCSf}{CLCoarseElevationChangeEntry=dIi}B@{DetailedConnectionInfo=BBiiiB}{CLMotionStateUpdate=dii}{AbsoluteAltitudeUpdate=ddd})20
{unique_ptr<CLCompanionNotifier_Type::Client, std::default_delete<CLCompanionNotifier_Type::Client>>="__ptr_"{__compressed_pair<CLCompanionNotifier_Type::Client *, std::default_delete<CLCompanionNotifier_Type::Client>>="__value_"^{Client}}}
v24@0:8i16I20
v32@0:8d16@24
v24@0:8@?<v@?i>16
v24@0:8@?<v@?@"CMVO2MaxRetrocomputeState"i>16
v24@0:8R@"<CLVO2MaxServiceClientProtocol>"16
v32@0:8d16@"NSObject<OS_xpc_object>"24
v24@0:8@"CMVO2MaxRetrocomputeState"16
I32@0:8r^v16^{VO2MaxRetrocomputeHistory=Qdiiddddd[16C]ddIIIIdddI}24
i36@0:8r^v16r^{VO2MaxSessionAttributes=Qd[16C]ddIBi@@}24i32
I104@0:8r^{VO2MaxSessionAttributes=Qd[16C]ddIBi@@}16{VO2MaxHealthKitSample=ddd[16C]I{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}24^{VO2MaxRetrocomputeHistory=Qdiiddddd[16C]ddIIIIdddI}96
v288@0:8{VO2MaxRetrocomputeSessionResult=[16C]dB{vector<VO2MaxSummary, std::allocator<VO2MaxSummary>>=^{VO2MaxSummary}^{VO2MaxSummary}{__compressed_pair<VO2MaxSummary *, std::allocator<VO2MaxSummary>>=^{VO2MaxSummary}}}{VO2MaxOutput=Q[16C]ddqddd[16C]ddiBBIdd}{VO2MaxHealthKitSample=ddd[16C]I{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}i}16
v296@0:8^{VO2MaxRetrocomputeHistory=Qdiiddddd[16C]ddIIIIdddI}16{VO2MaxRetrocomputeSessionResult=[16C]dB{vector<VO2MaxSummary, std::allocator<VO2MaxSummary>>=^{VO2MaxSummary}^{VO2MaxSummary}{__compressed_pair<VO2MaxSummary *, std::allocator<VO2MaxSummary>>=^{VO2MaxSummary}}}{VO2MaxOutput=Q[16C]ddqddd[16C]ddiBBIdd}{VO2MaxHealthKitSample=ddd[16C]I{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}i}24
I24@0:8^{VO2MaxRetrocomputeHistory=Qdiiddddd[16C]ddIIIIdddI}16
v208@0:8{VO2MaxStagingOutput=Q[16C]ddqddd[16C]ddiBBIddiIB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}d}16@200
v44@0:8{vector<VO2MaxSessionAttributes, std::allocator<VO2MaxSessionAttributes>>=^{VO2MaxSessionAttributes}^{VO2MaxSessionAttributes}{__compressed_pair<VO2MaxSessionAttributes *, std::allocator<VO2MaxSessionAttributes>>=^{VO2MaxSessionAttributes}}}16B40
B24@0:8d16
{vector<VO2MaxStagingOutput, std::allocator<VO2MaxStagingOutput>>="__begin_"^{VO2MaxStagingOutput}"__end_"^{VO2MaxStagingOutput}"__end_cap_"{__compressed_pair<VO2MaxStagingOutput *, std::allocator<VO2MaxStagingOutput>>="__value_"^{VO2MaxStagingOutput}}}
v40@0:8@16q24@32
v24@0:8@"CBCentralManager"16
v32@0:8@"CBCentralManager"16@"NSDictionary"24
v48@0:8@"CBCentralManager"16@"CBPeripheral"24@"NSDictionary"32@"NSNumber"40
v32@0:8@"CBCentralManager"16@"CBPeripheral"24
v40@0:8@"CBCentralManager"16@"CBPeripheral"24@"NSError"32
v40@0:8@"CBCentralManager"16q24@"CBPeripheral"32
@24@0:8^v16
B24@0:8^i16
B28@0:8^v16B24
B24@0:8^{Cell=iiiiiiii}16
v24@0:8@?<v@?@"NSArray">16
@?16@0:8
B36@0:8c16B20B24r*28
B48@0:8c16B20B24B28r*32r^v40
B32@0:8r^v16d24
B28@0:8r^v16B24
B20@0:8B16
v24@0:8@?<v@?B>16
v32@0:8@?<{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}@?>16@?<{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}@?>24
v24@0:8@?<{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}@?>16
@?<{ScanStats=III[13I]}@?>16@0:8
@?<{ScanResult=d{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}}@?>16@0:8
v24@0:8@?<v@?@?<{ScanResult=d{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}}@?>>16
B24@0:8@?<{ScanParameters=iii{vector<int, std::allocator<int>>=^i^i{__compressed_pair<int *, std::allocator<int>>=^i}}{duration<long long, std::ratio<1, 1000>>=q}{duration<long long, std::ratio<1, 1>>=q}BB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}c}@?>16
B24@0:8^B16
{?="timestamp"b1"recordId"b1"regularEntry"b1}
v44@0:8d16d24B32@?36
v44@0:8d16d24B32@?<v@?@"NSMutableArray">36
B72@0:8^{?=fff}16^{?=fff}24^{?=fff}32B40^{?=fff}44^{?=fff}52^{?=fff}60B68
B24@0:8^{?=idd(?={?={?=fff}{?=fff}}{?=B[282c]})}16
B44@0:8r^{?=fff}16r^{?=fff}24f32d36
v32@0:8@"NSString"16@?<v@?@"NSString">24
@24@0:8R@16
@40@0:8@16@24R@32
v24@0:8R@"<CLSettingsManagerClientProtocol>"16
@"NSDictionary"24@0:8R@"<CLSettingsManagerClientProtocol>"16
@"NSDictionary"40@0:8@16@"NSString"24R@"<CLSettingsManagerClientProtocol>"32
v24@0:8@"NSDictionary"16
v24@0:8@"CLVisit"16
v24@0:8@"RTScenarioTrigger"16
B24@0:8r^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16
v24@0:8^(NotificationData={CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}B{DeviceTouchState=Bd}{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB})16
v180@0:8i16{NotificationData=Bc{AssociationState={optional<CLWifiService_Type::AccessPoint>=(?=c{AccessPoint={CLMacAddress=Q}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}iiiddBB})B}}{ScanResult=d{vector<CLWifiService_Type::AccessPoint, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}^{AccessPoint}{__compressed_pair<CLWifiService_Type::AccessPoint *, std::allocator<CLWifiService_Type::AccessPoint>>=^{AccessPoint}}}}BBB{vector<CLWifiRangeResult, std::allocator<CLWifiRangeResult>>=^{CLWifiRangeResult}^{CLWifiRangeResult}{__compressed_pair<CLWifiRangeResult *, std::allocator<CLWifiRangeResult>>=^{CLWifiRangeResult}}}BB}20
v196@0:8i16(NotificationData={CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}B{DeviceTouchState=Bd}{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB})20
{?=ddd}16@0:8
v40@0:8{?=ddd}16
@"<CLIntersiloUniverse>"
@"<CLVehicleStateNotifierProtocol>"
@"NSDate"
{unique_ptr<CLWifiService_Type::Client, std::default_delete<CLWifiService_Type::Client>>="__ptr_"{__compressed_pair<CLWifiService_Type::Client *, std::default_delete<CLWifiService_Type::Client>>="__value_"^{Client}}}
{unique_ptr<CLMotionState_Type::Client, std::default_delete<CLMotionState_Type::Client>>="__ptr_"{__compressed_pair<CLMotionState_Type::Client *, std::default_delete<CLMotionState_Type::Client>>="__value_"^{Client}}}
@"CLLocation"
{?="speed"d"timestamp"d"uncertainty"d}
r*16@0:8
@32@0:8@16^v24
@40@0:8@16^v24@?32
{Battery=dBBiBi}16@0:8
v40@0:8{Battery=dBBiBi}16
B40@0:8^v16Q24^{os_state_hints_s=I*II}32
{_CLDaemonStatusStateTrackerState="batteryData"{Battery="level"d"charged"B"connected"B"chargerType"i"wasConnected"B"chargerFamily"i}"reachability"i"thermalLevel"i"airplaneMode"B"batterySaverModeEnabled"B"restrictedMode"B}
B36@0:8B16Q20@28
v24@0:8@?<v@?q>16
B36@0:8B16Q20@"NSString"28
@136@0:8{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}16
{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}16@0:8
v136@0:8{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}16
{CLMotionActivity="type"i"confidence"i"source"i"mountedState"i"mountedConfidence"i"isStanding"B"tilt"f"timestamp"d"isVehicleConnected"B"exitState"i"estExitTime"d"startTime"d"rawType"i"rawConfidence"i"vehicularFlags"{?="motionHint"b1"gpsHint"b1"basebandHint"b1"wifiHint"b1"btHint"b1}"vehicularConfidence"i"drivingStowedLikelihoodSum"f"drivingArmLikelihoodSum"f"ssLikelihoodSum"f"workoutDetectionType"i"workoutDetectionTime"d"workoutEscalationTime"Q"typeYouth"i}
@88@0:8{AccessPoint={CLMacAddress=Q}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}iiiddBB}16
@"CLHRequestArchive"
B64@0:8@16@24@32@40@48@56
v40@0:8@"PBSessionRequester"16@"PBCodable"24@"PBRequest"32
v24@0:8@"PBSessionRequester"16
v32@0:8@"PBSessionRequester"16@"NSError"24
v32@0:8@"PBSessionRequester"16@?<v@?>24
v56@0:8@16{_NSRange=QQ}24d40i48i52
v64@0:8@16{_NSRange=QQ}24d40i48i52r^v56
@"<CLBarometerCalibrationSourceClient>"
{?="latitude"b1"longitude"b1"radius"b1"authMask"b1"correctiveCompensationMask"b1"provenance"b1"serviceMaskOperator"b1"phenolicLocation"b1"zoneType"b1"clearClient"b1}
B24@0:8^d16
B32@0:8^d16^d24
v24@0:8B16i20
v24@0:8@?<{CLEmergencyState=iiiii}@?>16
v28@0:8@?<{LocationSettings=iBBBBB{Emergency={Settings=Iiiiii{LPPRel13MeasSettings=IiI}I}{CDMASettings=Bi}{Settings=Iiiiii{LPPRel13MeasSettings=IiI}I}{VerticalUncertaintySettings=Bd}{AugmentedAction={AML={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BI{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}dBdd}{EED2=BB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}ddd{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}B{vector<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo, std::allocator<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo>>=^{PartnerInfo}^{PartnerInfo}{__compressed_pair<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo *, std::allocator<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo>>=^{PartnerInfo}}}}{EED2=BB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}ddd{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}B{vector<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo, std::allocator<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo>>=^{PartnerInfo}^{PartnerInfo}{__compressed_pair<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo *, std::allocator<CLEmergencyController::LocationSettings::Emergency::AugmentedAction::EED2::PartnerInfo>>=^{PartnerInfo}}}}}}{SuplSettings={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}SI(?=I{?=b1b1b1b1b1})}{BAA=BBiiiiii}{BAA=BBiiiiii}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}@?>16i24
v24@0:8@?<{CLWifiLocationUpdateRequest=iiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}diBBiidddddiBBi{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}@?>16
v28@0:8@?16i24
v32@0:8R@16q24
v32@0:8R@"<CLMotionStateMediatorClientProtocol>"16q24
v32@0:8q16@?<v@?i>24
v24@0:8@?<v@?{IndoorOutdoorUpdate=dqq}>16
@?<{shared_ptr<CLMotionStateOverride>=^{CLMotionStateOverride}^{__shared_weak_count}}@?>16@0:8
B24@0:8q16
v40@0:8^v16^d24^d32
@40@0:8@16@24^v32
v32@0:8I16I20d24
d24@0:8d16
d56@0:8{ReferencePairedWithPressure={NormalDistribution=dd}{NormalDistribution=dd}i}16
v52@0:8^v16d24d32d40i48
{BiasEstimatorLocation=dd}24@0:8r^v16
v40@0:8d16d24d32
v48@0:8d16d24d32d40
B32@0:8d16d24
v36@0:8B16d20d28
v68@0:8d16d24d32B40B44i48d52d60
v40@0:8d16^v24d32
@"<CLBarometerCalibrationContextClient>"
{unique_ptr<CLSignificantElevationEstimator, std::default_delete<CLSignificantElevationEstimator>>="__ptr_"{__compressed_pair<CLSignificantElevationEstimator *, std::default_delete<CLSignificantElevationEstimator>>="__value_"^{CLSignificantElevationEstimator}}}
{BiasEstimatorLocation="latitude"d"longitude"d}
{RebaseEvent="latitude"f"longitude"f"inVisit"B"demAvailableInTrack"B"forcedGPSRecently"B"rebaseSource"i"inOutdoorWorkout"B"firstRebaseSinceLocationdStart"B"altitudeError_binned"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"timeToFirstRebase_binned"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"referenceUncertainty_binned"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"uncertainty_binned"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"timeSinceVisitEntry_binned"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"timeSinceLastRebase_binned"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"correction_binned"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"distanceSinceLastRebase_binned"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}}
B32@0:8^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16^{Cell=iiiiiiii}24
B32@0:8^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16^{ScdmaCell=iiiiiiii}24
B32@0:8^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16^v24
B32@0:8^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16^{LteCell=iiiiiiiddiiii}24
i32@0:8r^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16r^v24
v24@0:8^{CLNetworkLocationServerResponseListener=^^?}16
i32@0:8^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16r^v24
i28@0:8r^v16B24
i40@0:8r^v16B24B28r^{CLNetworkLocationRequestConfig=i}32
v32@0:8@"CLLocation"16@?<{Cell=iiiiiiii}@?>24
v32@0:8@"CLLocation"16@?<{ScdmaCell=iiiiiiii}@?>24
v32@0:8@"CLLocation"16@?<{CdmaCell=i{vector<int, std::allocator<int>>=^i^i{__compressed_pair<int *, std::allocator<int>>=^i}}iiiiiiiii{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}iii{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}ii}@?>24
v32@0:8@"CLLocation"16@?<{LteCell=iiiiiiiddiiii}@?>24
v32@0:8@"CLLocation"16@?<{NrCell=iiiqiiiddiiiii}@?>24
v24@0:8@"SRSensorWriter"16
v32@0:8@"SRSensorWriter"16@"NSArray"24
#24@0:8@16
v36@0:8@16Q24i32
v40@0:8@16{?=dd}24
v36@0:8@"GEONavigationListener"16Q24i32
v32@0:8@"GEONavigationListener"16@"GEONavigationRouteSummary"24
v32@0:8@"GEONavigationListener"16@"GEONavigationRouteTransitSummary"24
v32@0:8@"GEONavigationListener"16@"GEONavigationGuidanceState"24
v32@0:8@"GEONavigationListener"16@"NSData"24
v32@0:8@"GEONavigationListener"16@"NSString"24
v32@0:8@"GEONavigationListener"16Q24
v32@0:8@"GEONavigationListener"16@"GEONameInfo"24
v32@0:8@"GEONavigationListener"16@"NSArray"24
v40@0:8@"GEONavigationListener"16{?=dd}24
v28@0:8@"GEONavigationListener"16i24
@32@0:8@16^{INotifier=^^?}24
@"GEONavigationListener"
{?="latitude"d"longitude"d}
^{INotifier=^^?}
@24@0:8Q16
{?="generationTimeSecs"b1"expirationAgeSecs"b1"version"b1}
{?="startTime"b1"firstCatherine"b1"firstCatherineStartTime"b1"longestDropout"b1"maxGoodCatherine"b1"meanCatherine"b1"meanGoodCatherine"b1"minGoodCatherine"b1"nCatherine"b1"nDropout"b1"nGoodCatherine"b1"nHighCatherine"b1"nInterpolatedCatherine"b1"nLowCatherine"b1"nSampleAndHoldCatherine"b1"nVeryHighCatherine"b1"nVeryLowCatherine"b1"onsetCatherine"b1"onsetReason"b1"persistedMinHR"b1"totalDropoutTime"b1"userMaxCatherine"b1}
{?="metsFM"b1"metsHR"b1"metsWR"b1"truthMetsSource"b1"userMetsSource"b1}
{_CLClientManagerStateTrackerState="locationServicesEnabledStatus"i"locationRestricted"B}
v176@0:8{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}16
v44@0:8@16@24i32@?36
v36@0:8@?16B24@28
v48@0:8@?16@24i32i36@40
v32@0:8Q16@24
v32@0:8@?16@24
@24@0:8@?16
d32@0:8d16@?24
v40@0:8Q16@24@?32
B28@0:8B16@20
v68@0:8B16@20{?=[8I]}28B60B64
v28@0:8B16@20
i24@0:8@?16
v32@0:8@16i24B28
i20@0:8i16
v72@0:8@16@24d32d40i48i52d56@?64
v52@0:8@16@24i32i36i40@?44
v44@0:8B16@20@28@?36
v36@0:8B16@20@28
v28@0:8i16@?20
v28@0:8@"CLCppContainer"16B24
v44@0:8@"NSString"16@"NSString"24i32@?<v@?@"CLCppContainer">36
v36@0:8@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>16B24@"NSString"28
@"NSSet"16@0:8
v24@0:8@?<v@?@"NSSet">16
v48@0:8@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>16@"NSString"24i32i36@"NSString"40
v24@0:8@"NSArray"16
v32@0:8Q16@"NSString"24
v32@0:8@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>16@"NSData"24
@"NSData"24@0:8@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>16
d32@0:8d16@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>24
v40@0:8Q16@"NSString"24@?<v@?B>32
B28@0:8B16@"NSString"20
v68@0:8B16@"NSString"20{?=[8I]}28B60B64
v28@0:8B16@"NSString"20
v32@0:8@"CLLocation"16@?<v@?@"CLLocation">24
i24@0:8@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>16
v32@0:8@"CLCppContainer"16i24B28
v24@0:8@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>16
v32@0:8@"NSString"16@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>24
@"NSDictionary"16@0:8
v32@0:8@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>16@?<v@?i>24
v72@0:8@"NSString"16@"NSString"24d32d40i48i52d56@?<v@?@"NSError">64
v52@0:8@"NSString"16@"NSString"24i32i36i40@?<v@?@"NSError">44
v44@0:8B16@"NSString"20@"NSString"28@?<v@?@"NSError">36
v36@0:8B16@"NSString"20@"NSString"28
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError">32
v28@0:8i16@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>20
@"NSError"32@0:8@"NSData"16@"NSUUID"24
@"NSData"16@0:8
v24@0:8@?<{PersistentSubscriptionIdentifier={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{type_index=^{type_info}}}@?>16
@40@0:8@16Q24Q32
@"CMMotionTimeRange"
v32@0:8R@16@24
v32@0:8R@"<CLSignificantVisitManagerClientProtocol>"16@"NSString"24
v28@0:8R@"<CLSignificantVisitManagerClientProtocol>"16i24
v24@0:8R@"<CLSignificantVisitManagerClientProtocol>"16
v32@0:8@16R@24
B32@0:8r*16^i24
B40@0:8r*16r*24^i32
B36@0:8r*16r*24i32
v188@0:8i16{NotificationData={Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}Bi}20
{unique_ptr<CLClientManager_Type::Client, std::default_delete<CLClientManager_Type::Client>>="__ptr_"{__compressed_pair<CLClientManager_Type::Client *, std::default_delete<CLClientManager_Type::Client>>="__value_"^{Client}}}
{map<id<CLSignificantVisitManagerClientProtocol>, NSString *, std::less<id<CLSignificantVisitManagerClientProtocol>>, std::allocator<std::pair<const id<CLSignificantVisitManagerClientProtocol>, NSString *>>>="__tree_"{__tree<std::__value_type<id<CLSignificantVisitManagerClientProtocol>, NSString *>, std::__map_value_compare<id<CLSignificantVisitManagerClientProtocol>, std::__value_type<id<CLSignificantVisitManagerClientProtocol>, NSString *>, std::less<id<CLSignificantVisitManagerClientProtocol>>, true>, std::allocator<std::__value_type<id<CLSignificantVisitManagerClientProtocol>, NSString *>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<id<CLSignificantVisitManagerClientProtocol>, NSString *>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<id<CLSignificantVisitManagerClientProtocol>, std::__value_type<id<CLSignificantVisitManagerClientProtocol>, NSString *>, std::less<id<CLSignificantVisitManagerClientProtocol>>, true>>="__value_"Q}}}
@"CLSettingsMirror"
@"<CLClientAuthorizationCacheProtocol>"
@"<CLRoutineMonitorServiceProtocol>"
@"<CLClientManagerPublicProtocol>"
v32@0:8r^i16r^(NotificationData={MediatedMotionActivity=d{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}i{CLNatalieFeatures=fffffffiB}BB[16C]}{MotionOverride=i{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}q{WorkoutSettings=[16C]qq(WorkoutAttrib={SwimAttrib=qd}Q)}}{WorkoutEvent=[16C]qqddqd{CLWorkoutSessionDetails=idqQ}{WorkoutSettings=[16C]qq(WorkoutAttrib={SwimAttrib=qd}Q)}}{IndoorOutdoorUpdate=dqq})24
v32@0:8r^i16r^(NotificationData={CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLExtendedStepCountEntry=d{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLStepCountEntryAddition=ddIddddBd}}{CLPedometerEvent=di}{CLOdometerSuitability=dBB})24
v136@0:8{CLPredictedWalkDistanceBoutEntry=iddIddIIIdiiddddd}16
{unique_ptr<CLMotionStateMediator_Type::Client, std::default_delete<CLMotionStateMediator_Type::Client>>="__ptr_"{__compressed_pair<CLMotionStateMediator_Type::Client *, std::default_delete<CLMotionStateMediator_Type::Client>>="__value_"^{Client}}}
{unique_ptr<CLStepCountNotifier_Type::Client, std::default_delete<CLStepCountNotifier_Type::Client>>="__ptr_"{__compressed_pair<CLStepCountNotifier_Type::Client *, std::default_delete<CLStepCountNotifier_Type::Client>>="__value_"^{Client}}}
{unique_ptr<CLPredictedWalkDistanceBoutDetector, std::default_delete<CLPredictedWalkDistanceBoutDetector>>="__ptr_"{__compressed_pair<CLPredictedWalkDistanceBoutDetector *, std::default_delete<CLPredictedWalkDistanceBoutDetector>>="__value_"^{CLPredictedWalkDistanceBoutDetector}}}
v40@0:8@"CSLSOnWristMonitor"16@"CSLSOnWristState"24@"CSLSOnWristState"32
B40@0:8@16@24@32
B48@0:8@16@24@32@40
B40@0:8@"NSFileManager"16@"NSString"24@"NSString"32
B40@0:8@"NSFileManager"16@"NSURL"24@"NSURL"32
B48@0:8@"NSFileManager"16@"NSError"24@"NSString"32@"NSString"40
B48@0:8@"NSFileManager"16@"NSError"24@"NSURL"32@"NSURL"40
B32@0:8@"NSFileManager"16@"NSString"24
B32@0:8@"NSFileManager"16@"NSURL"24
B40@0:8@"NSFileManager"16@"NSError"24@"NSString"32
B40@0:8@"NSFileManager"16@"NSError"24@"NSURL"32
@"NSFileManager"
v32@0:8@"CLLocation"16@?<v@?@"CLLocation"B@"NSData">24
@"GEOCoarseLocationProvider"
{?="northWestLatitude"b1"northWestLongitude"b1"southEastLatitude"b1"southEastLongitude"b1}
v56@0:8@16@24d32d40d48
v56@0:8@"NSString"16@"NSString"24d32d40d48
v32@0:8@"NSString"16@"NSString"24
v60@0:8@16@24d32d40d48B56
@"CLLocationManager"
v40@0:8i16B20B24B28B32B36
v32@0:8r^i16r^v24
v32@0:8r^i16r^(NotificationData={CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}B{DeviceTouchState=Bd}{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB})24
{unique_ptr<CLLocationController_Type::Client, std::default_delete<CLLocationController_Type::Client>>="__ptr_"{__compressed_pair<CLLocationController_Type::Client *, std::default_delete<CLLocationController_Type::Client>>="__value_"^{Client}}}
{unique_ptr<CLRollingPowerAssertion, std::default_delete<CLRollingPowerAssertion>>="__ptr_"{__compressed_pair<CLRollingPowerAssertion *, std::default_delete<CLRollingPowerAssertion>>="__value_"^{CLRollingPowerAssertion}}}
{unique_ptr<CLMotionActivity, std::default_delete<CLMotionActivity>>="__ptr_"{__compressed_pair<CLMotionActivity *, std::default_delete<CLMotionActivity>>="__value_"^{CLMotionActivity}}}
@"<CLLocationStreamingConnectionManagerServiceProtocol>"
v24@0:8R@"<CLTileDownloadSchedulingClientProtocol>"16
@"CalibrationTrack"
@52@0:8{time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>>={duration<long double, std::ratio<1, 1>>=D}}16i32@36I44i48
{time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>>={duration<long double, std::ratio<1, 1>>=D}}16@0:8
@"NSUUID"
{time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>>="__d_"{duration<long double, std::ratio<1, 1>>="__rep_"D}}
{CLATVAirplayDeviceInternal={time_point<cl::chrono::CFAbsoluteTimeClock, std::chrono::duration<long double>>={duration<long double, std::ratio<1, 1>>=D}}i{uuid=[16C]}Ii}16@0:8
v24@0:8R@"<CLATVAirplayMonitorClientProtocol>"16
@"WPAirPlaySolo"
v128@0:8@16{?=idIdddddiiddid}24
v128@0:8@"CMStrideCalibrationDatabase"16{?=idIdddddiiddid}24
v32@0:8@16i24i28
v32@0:8@"CMStrideCalLocationFSM"16i24i28
v32@0:8@"CMStrideCalLocationFSM"16@"CalibrationTrack"24
v32@0:8@"CMStrideCalLocationFSM"16d24
v28@0:8@"CMStrideCalLocationFSM"16i24
@40@0:8@16{shared_ptr<CLStepCountRecorderDb>=^{CLStepCountRecorderDb}^{__shared_weak_count}}24
B32@0:8@16r^{CLStepDistance=iddiidi}24
{unique_ptr<CLOdometerNotifier_Type::Client, std::default_delete<CLOdometerNotifier_Type::Client>>="__ptr_"{__compressed_pair<CLOdometerNotifier_Type::Client *, std::default_delete<CLOdometerNotifier_Type::Client>>="__value_"^{Client}}}
{unique_ptr<CLServiceLocationProvider_Type::Client, std::default_delete<CLServiceLocationProvider_Type::Client>>="__ptr_"{__compressed_pair<CLServiceLocationProvider_Type::Client *, std::default_delete<CLServiceLocationProvider_Type::Client>>="__value_"^{Client}}}
{unique_ptr<CLStreamingAwareLocationProvider_Type::Client, std::default_delete<CLStreamingAwareLocationProvider_Type::Client>>="__ptr_"{__compressed_pair<CLStreamingAwareLocationProvider_Type::Client *, std::default_delete<CLStreamingAwareLocationProvider_Type::Client>>="__value_"^{Client}}}
@"<CLStreamingAwareLocationProviderProtocol>"
@"CMStrideCalibrationActivityBuffer"
@"CMStrideCalibrationElevationBuffer"
@"CMStrideCalibrationStepCountBuffer"
@"CMStrideCalibrationStats"
@"CMStrideCalibrationDatabase"
@"CMStrideCalLocationFSM"
{shared_ptr<CLStepCountRecorderDb>="__ptr_"^{CLStepCountRecorderDb}"__cntrl_"^{__shared_weak_count}}
@"CLClientManagerUsageSyncMessage"
@"NSError"
v28@0:8i16r^v20
B40@0:8@16^@24^@32
v48@0:8@16@24q32@40
{?="generationTimeSecs"b1"expirationAgeSecs"b1"tileX"b1"tileY"b1"version"b1}
B32@0:8^v16@24
v24@0:8@?<{Fence={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}ddddddddiiidQiiB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{CLStrongPtr<NSUUID *>=@}{vector<CLClientLocationCoordinate, std::allocator<CLClientLocationCoordinate>>=^{?}^{?}{__compressed_pair<CLClientLocationCoordinate *, std::allocator<CLClientLocationCoordinate>>=^{?}}}}@?>16
B24@0:8@"NSString"16
B32@0:8^v16@"NSString"24
v32@0:8@"NSString"16@?<v@?@?<{vector<CLFenceManager_Type::Fence, std::allocator<CLFenceManager_Type::Fence>>=^{Fence}^{Fence}{__compressed_pair<CLFenceManager_Type::Fence *, std::allocator<CLFenceManager_Type::Fence>>=^{Fence}}}@?>>24
v28@0:8@"CMMotionAlarm"16i24
{?="value"b1}
{?="source"b1}
v48@0:8@?16d24d32@?40
v48@0:8@?<{vector<unsigned long long, std::allocator<unsigned long long>>=^Q^Q{__compressed_pair<unsigned long long *, std::allocator<unsigned long long>>=^Q}}@?>16d24d32@?<v@?@"NSArray"@"NSError">40
v21@0:8i16{?=c}20
{unique_ptr<CLDarwinNotifier_Type::Client, std::default_delete<CLDarwinNotifier_Type::Client>>="__ptr_"{__compressed_pair<CLDarwinNotifier_Type::Client *, std::default_delete<CLDarwinNotifier_Type::Client>>="__value_"^{Client}}}
v36@0:8{?=fff}16d28
v40@0:8{ChoreaScore=diffi}16
@"<CLHealthAssessmentResultDelegate>"
@"<PSYSyncCoordinatorDelegate>"
v28@0:8d16i24
v36@0:8d16i24@28
v24@0:8r^{?=idIdddddiiddid}16
{CLStrideCalibrationSessionMetrics="session"i"startTime"d"endTime"d"sumCalibrationDistanceSuccess"d"sumCalibrationDistanceFailOther"d"sumCalibrationDistanceFailGps"d"sumCalibrationDistanceFailPedometer"d"sumCalibrationDistanceFailGradient"d"sumCalibrationDistanceInvalidGain"d"sumCalibrationDistanceInvalidSpeed"d"sumCalibrationDistanceInvalidLength"d"totalDistance"d}
{CMFixedSizeQueue<double, 2>="fHeadAndSize"{?="fHead"S"fSize"S}"fCapacity"I"fBuffer"[8c]"fStorage"{CMQueueStorage<double, 2>="buffer"[8c]}}
@24@0:8r*16
@"NSObject<OS_os_transaction>"
@68@0:8d16d24r*32B40^v44@52d60
@"PCPersistentTimer"
{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}
{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}16@0:8
@"<CLMotionAlarmNotifierClientProtocol>"
{Name="fExecutable"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"fBundlePath"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"fLimitingBundleId"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"fBundleRequiresProxy"B"fSystemService"B"fHarvestableSystemService"B"fBundleId"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"fPluginBundleId"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"fCounterpartBundleId"{basic_string<char, std::char_traits<char>, std::allocator<char>>="__r_"{__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>="__value_"{__rep=""(?="__l"{__long="__cap_"Q"__size_"Q"__data_"*}"__s"{__short=""(?="__size_"C"__lx"c)"__data_"[23c]}"__r"{__raw="__words"[3Q]})}}}"fValidProxyData"B"fWatchKitPlugin"B"fIsAppClip"B}
v32@0:8@?16R@24
v32@0:8@?<{Name={basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BBB}@?>16R@"<CLMotionAlarmNotifierClientProtocol>"24
v32@0:8@"CMMotionAlarm"16@?<v@?@"CMMotionAlarm"i>24
v32@0:8@"NSString"16@?<v@?i>24
v32@0:8@"NSObject<OS_xpc_object>"16Q24
{?="strokeAmp"b1"strokeFrequency"b1}
{MotionFitnessDaily={Metric=Bd{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BIIIIIIIIqqIIB}16@0:8
@184@0:8{MotionFitnessDaily={Metric=Bd{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BIIIIIIIIqqIIB}16
{MotionFitnessDaily={Metric=Bd{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}BIIIIIIIIqqIIB}24@0:8@16
q24@0:8d16
v1396@0:8i16{NotificationData={CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}{CLDaemonLocationPrivate=dddddfffBi{?=dd}diiB{?=ddBB}{?=dd}if{?=dd}ddiBddddddddBB{?=dd}diddddddB{SatelliteReport={vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}}i{AltitudeInfo=dddi}CdddCBi}{shared_ptr<CLBatchedLocations>=^{CLBatchedLocations}^{__shared_weak_count}}{TechnologyStatus=iB}Bdi{?=dddd}{?=dd}{XtraFileAvailable=d{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}i{LocationDerivedSpeed=ddd}{?=dddi}{?=ddddddB[3[3d]]dddQi}{shared_ptr<const gnss::MeasurementData>=^{MeasurementData}^{__shared_weak_count}}i{?=idddddd[5d]ddddii}{CLStrongPtr<NSData *>=@}{PredictedGnssAvailability=iidd}{CLBasebandTimeFreqTransfer=d{CLBasebandSystemClock=Qffdfd}Qf{LeapSecondInfo=sC{LeapSecondChange=Qs}}}{CLGnssDisablementStatus=B}}20
v28@0:8i16{NotificationData=iB}20
v60@0:8i16{NotificationData=i{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}B}20
v40@0:8d16d24@?32
@"<CLMotionStateProtocol>"
{unique_ptr<CLAppMonitor_Type::Client, std::default_delete<CLAppMonitor_Type::Client>>="__ptr_"{__compressed_pair<CLAppMonitor_Type::Client *, std::default_delete<CLAppMonitor_Type::Client>>="__value_"^{Client}}}
v32@0:8@"CLCompanionSyncAuthObject"16@"NSString"24
B20@0:8I16
@"SYService"
v36@0:8B16@20@?28
v32@0:8@"NSString"16@?<v@?@"NSData"@"NSError">24
v36@0:8B16@"NSString"20@?<v@?B>28
@28@0:8@16B24
v20@0:8C16
v24@0:8@"CMAnomalyEvent"16
v128@0:8^{ImpactEvent={Impact=SCcQCCcBBBCQ{HighFrequencyFeatures={MagnitudeFeatures=ffffff}{JerkFeatures=f}}QfffffffffffffffffffffBCC(?={FeaturesAllDay=}{FeaturesPedestrian=}{FeaturesCycling=})}CCddddC}16Q24^{Config={FallStatsConfig=QCCCCCC}B}32@40@48@56@64@72@80@88@96@104@112@120
v40@0:8@"CLLocationManager"16@"CLLocation"24@"CLLocation"32
v32@0:8@"CLLocationManager"16@"NSArray"24
v32@0:8@"CLLocationManager"16@"CLHeading"24
B24@0:8@"CLLocationManager"16
v40@0:8@"CLLocationManager"16q24@"CLRegion"32
v40@0:8@"CLLocationManager"16@"NSArray"24@"CLBeaconRegion"32
v40@0:8@"CLLocationManager"16@"CLBeaconRegion"24@"NSError"32
v40@0:8@"CLLocationManager"16@"NSArray"24@"CLBeaconIdentityConstraint"32
v40@0:8@"CLLocationManager"16@"CLBeaconIdentityConstraint"24@"NSError"32
v32@0:8@"CLLocationManager"16@"CLRegion"24
v32@0:8@"CLLocationManager"16@"NSError"24
v40@0:8@"CLLocationManager"16@"CLRegion"24@"NSError"32
v28@0:8@"CLLocationManager"16i24
v24@0:8@"CLLocationManager"16
v32@0:8@"CLLocationManager"16@"CLVisit"24
v52@0:8{?=fff}16{?=fff}28i40f44f48
v40@0:8{?=fff}16{?=fff}28
B64@0:8{?=fff}16{?=fff}28^{?=fff}40^i48^B56
v24@0:8r^(NotificationData={CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}B{DeviceTouchState=Bd}{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB})16
{vector<std::pair<double, CLMotionActivity::Type>, std::allocator<std::pair<double, CLMotionActivity::Type>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::pair<double, CLMotionActivity::Type> *, std::allocator<std::pair<double, CLMotionActivity::Type>>>="__value_"^v}}
@"<_CDContext>"
@"_CDContextualChangeRegistration"
@32@0:8q16@24
@"_CDContextualPredicate"
v24@0:8R@"<CLDuetMonitorClientProtocol>"16
v32@0:8@"_CDContextualPredicate"16R@"<CLDuetMonitorClientProtocol>"24
v32@0:8q16@24
v40@0:8q16@24R@32
v32@0:8R@16Q24
v32@0:8R@"<CLBarometerCalibrationClientProtocol>"16Q24
v40@0:8Q16@"CLBarometerCalibrationTrack"24@?<{array<std::deque<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>, 7>=[7{deque<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>>={__split_buffer<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *>>=^^v^^v^^v{__compressed_pair<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> **, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *>>=^^v}}Q{__compressed_pair<unsigned long, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>>=Q}}]}@?>32
v24@0:8@"CLBarometerCalibrationAbsoluteAltitude"16
B24@0:8Q16
v24@0:8@"CLBarometerCalibrationTrack"16
@"CLBarometerCalibrationAbsoluteAltitude"16@0:8
@"CLBarometerCalibrationBiasData"16@0:8
v24@0:8^@16
v156@0:8i16(NotificationData={CLOdometerEntry=dddddddddiiidddddd}{CLElevationChangeEntry=ddIIidiifCSf}{CLCoarseElevationChangeEntry=dIi}{CLSignificantElevation=i[16C]ddII})20
v40@0:8i16(NotificationData={CLWorkoutUpdate=diiI}{CLMotionStateUpdate=dii})20
{array<std::deque<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>, 7>="__elems_"[7{deque<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>>="__map_"{__split_buffer<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *>>="__first_"^^v"__begin_"^^v"__end_"^^v"__end_cap_"{__compressed_pair<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> **, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *>>="__value_"^^v}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>>="__value_"Q}}]}
{array<CLBarometerCalibrationContextManager *, 7>="__elems_"[7@"CLBarometerCalibrationContextManager"]}
@"CLBarometerCalibrationSourceAggregator"
[3@"NSMutableSet"]
@"CLBarometerCalibrationBiasEstimator"
@"CLBarometerCalibrationAbsoluteAltitude"
{unique_ptr<CLMotionStateObserver_Type::Client, std::default_delete<CLMotionStateObserver_Type::Client>>="__ptr_"{__compressed_pair<CLMotionStateObserver_Type::Client *, std::default_delete<CLMotionStateObserver_Type::Client>>="__value_"^{Client}}}
@40@0:8@16@24@?32
v60@0:8@16S24q28B36B40B44d48B56
v36@0:8S16@20@28
@"IDSDevice"
{?="timestamp"b1"metsHR"b1"metsWR"b1"recordId"b1}
^Q16@0:8
Q24@0:8Q16
v32@0:8^Q16Q24
^d16@0:8
d24@0:8Q16
v32@0:8^d16Q24
{?="list"^Q"count"Q"size"Q}
{?="list"^d"count"Q"size"Q}
{?="latitude"b1"locationId"b1"longitude"b1}
@24@0:8r^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16
v24@0:8^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16
@192@0:8{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16
@560@0:8{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}192{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}312{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}432B552B556
v216@0:8{BoutMetrics=iddIiIIdCidddddddddddIIIIIIIIIIfBfB}16
v784@0:8{Result={CLBodyMetrics=iiffffffffifBfBBB}BBBiiddddddBBIIB{Result=dd{Features=dddd}{Result=iiiidd{FusionLikelihoods=dd}I}{Features=ddddddddddddddddddd}{Result=iiiidd{FusionLikelihoods=dd}I}{Features=dddddddddd}{Result=iiiidd{FusionLikelihoods=dd}I}{Features=dddd}B}{Features=dddddd}{Features=ddd}{EventResult=BBBdddBBB{SteadinessEvent=ddi}}iB}16
{unique_ptr<CLNADController, std::default_delete<CLNADController>>="__ptr_"{__compressed_pair<CLNADController *, std::default_delete<CLNADController>>="__value_"^{CLNADController}}}
@"CLAvailabilityRegionChangeMonitor"
@"<CLTilesManagerProtocol>"
@"<CLAppTileDataProviderProtocol>"
v44@0:8@16@24C32@36
v44@0:8@16q24q32C40
v24@0:8@"NSURL"16
v32@0:8@"NSString"16@?<v@?@"NSDictionary">24
v44@0:8@"NSString"16@"NSString"24C32@"CLLocation"36
v44@0:8@"NSString"16q24q32C40
{CLExtendedStepCountEntry=d{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLStepCountEntryAddition=ddIddddBd}}24@0:8^{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}16
{CLExtendedStepCountEntry="startTime"d"base"{CLStepCountEntry="timestamp"d"startTime"d"firstStepTime"d"count"I"distance"d"rawDistance"d"floorsAscended"I"floorsDescended"I"currentPace"d"currentCadence"d"activeTime"d"recordId"i"sourceId"^{__CFString}"isOdometerDistance"B"isOdometerPace"B"accelerometerPace"{CLAccelerometerPace="calibrated"d"lowerBound"d"upperBound"d}"pushCount"I"workoutType"I"pedometerArmConstrainedState"C"elevationAscended"I"elevationDescended"I"falseStepDetectorState"(FalseStepDetectorStateUnion="falseStepDetectorState"{FalseStepDetectorState="accelPoseXHigh"b1"accelVarXYZLow"b1"gyroNumSamplesSufficient"b1"gyroVarXHigh"b1"consecutiveRequirement"b1"isVehicularLowConfidence"b1"isVehicularHighConfidence"b1"consistentStepsProtection"b1}"data"C)"falseStepsSuppressed"C"distanceSource"C}"addition"{CLStepCountEntryAddition="totalCalibratedDistance"d"rawPace"d"incrementalSteps"I"incrementalActiveTime"d"firstStepTime"d"lastStepTime"d"odometerSpeed"d"rawPaceDidJump"B"calibratedDistance"d}}
@100@0:8@16@24@32d40{vector<double, std::allocator<double>>=^d^d{__compressed_pair<double *, std::allocator<double>>=^d}}48{vector<double, std::allocator<double>>=^d^d{__compressed_pair<double *, std::allocator<double>>=^d}}72B96
B32@0:8Q16Q24
v40@0:8Q16d24d32
v48@0:8Q16d24d32Q40
Q24@0:8d16
{?=dd}24@0:8d16
{vector<double, std::allocator<double>>="__begin_"^d"__end_"^d"__end_cap_"{__compressed_pair<double *, std::allocator<double>>="__value_"^d}}
{?="authMask"b1"correctiveCompensationMask"b1"notification"b1"clearClient"b1}
v24@0:8R@"<CLCapabilityMonitorClientProtocol>"16
{?="elevationDescended"b1"gradeType"b1"verticalSpeed"b1}
v24@0:8@?<v@?dd>16
v32@0:8@"NSString"16Q24
v44@0:8i16d20d28Q36
i24@0:8i16i20
v24@0:8r^v16
v24@0:8r^(NotificationData={CLOdometerEntry=dddddddddiiidddddd}{CLElevationChangeEntry=ddIIidiifCSf}{CLCoarseElevationChangeEntry=dIi}{CLSignificantElevation=i[16C]ddII})16
@"CalTrackFinder"
@"<CMStrideCalLocationFSMDelegate>"
{?="cadence"b1"grade"b1"hrTime"b1"pace"b1"startTime"b1"gradeType"b1"hr"b1"hrConfidence"b1"metSource"b1"mets"b1"workoutType"b1"hasGPS"b1"hasStrideCal"b1"isStroller"b1}
v120@0:8{?=idIdddddiiddid}16
{CMStrideCalRecorderDb="_vptr$CLActivityRecorderDb"^^?"fDb"{unique_ptr<CLSqliteDatabase, std::default_delete<CLSqliteDatabase>>="__ptr_"{__compressed_pair<CLSqliteDatabase *, std::default_delete<CLSqliteDatabase>>="__value_"^{CLSqliteDatabase}}}"fName"*"fMutex"{BasicMutex="_vptr$Mutex"^^?"info"^{MutexInfo}}"fFatalError"B"fBuffer"{deque<CLStrideCalEntry, std::allocator<CLStrideCalEntry>>="__map_"{__split_buffer<CLStrideCalEntry *, std::allocator<CLStrideCalEntry *>>="__first_"^^{?}"__begin_"^^{?}"__end_"^^{?}"__end_cap_"{__compressed_pair<CLStrideCalEntry **, std::allocator<CLStrideCalEntry *>>="__value_"^^{?}}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<CLStrideCalEntry>>="__value_"Q}}"fInternalRecordCount"i"fSampleInterval"f"fPersistence"i"fPrevEntry"{?="recordId"i"startTime"d"pacebin"I"kvalue"d"kvalueTrack"d"score"d"endTime"d"distance"d"steps"i"session"i"speed"d"percentGrade"d"gpsSource"i"timestamp"d}"fMaxBufferSize"i"fInMemoryTransaction"@"CLOSTransaction""fProtectionPolicy"{NoDataProtectionPolicy=}"fSqlGetCount"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlGetAllAsc"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlGetPacebinDesc"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlGetSpeedRangeDesc"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlDeleteBefore"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlDeleteAfter"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlDeleteAll"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlInsert"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlShiftStartTimes"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fSqlMostRecent"{CLSqliteCachedStatement="fDb"^{CLSqliteDatabase}"fStatement"^{sqlite3_stmt}}"fFinishedInsertSilo"@"CLSilo""fFinishedInsertHandler"@?}
@"<CMStrideCalibrationDatabaseDelegate>"
v32@0:8r^i16r^(NotificationData={CLOdometerEntry=dddddddddiiidddddd}{CLElevationChangeEntry=ddIIidiifCSf}{CLCoarseElevationChangeEntry=dIi}{CLSignificantElevation=i[16C]ddII})24
v40@0:8@16d24Q32
{list<CMMsl::Item *, std::allocator<CMMsl::Item *>>="__end_"{__list_node_base<CMMsl::Item *, void *>="__prev_"^v"__next_"^v}"__size_alloc_"{__compressed_pair<unsigned long, std::allocator<std::__list_node<CMMsl::Item *, void *>>>="__value_"Q}}
{ImpactEvent="fImpact"{Impact="fSeq"S"fTrialCount"C"fCrown"c"fNow"Q"fAge"C"fState"C"fFallType"c"fIsFall"B"fIsNearFall"B"fFallAlertSent"B"fSimulated"C"fTimestamp"Q"fHighFrequencyFeatures"{HighFrequencyFeatures="fMagnitudeFeatures"{MagnitudeFeatures="fXMin"f"fXMax"f"fYMin"f"fYMax"f"fZMin"f"fZMax"f}"fJerkFeatures"{JerkFeatures="fJerkVectorMagMax"f}}"fPeakTimestamp"Q"fAccelPathLength"f"fMinInertialZ"f"fMinInertialZHighFreq"f"fAngleChangePreImpact"f"fAngleChangePostImpact"f"fMaxAngleChangePreImpact"f"fMaxAngleChangePostImpact"f"fSumDeltaAngles"f"fPosteriorRatio"f"fPoseAtImpact"f"fTiltAngle"f"fSwingAngle"f"fAccelPathLengthWithPeak"f"fPathLengthHarmonicMean"f"fPathLengthDecorrelation"f"fPathLengthDelaySpread"f"fGravityVariance"f"fCrownVariance"f"fMedianAbsGravityY"f"fAbruptGravityChangeAngle"f"fFallDistance"f"fHasMotionBeforeImpact"B"fImpactState"C"fOperatingMode"C""(?="featuresAllDay"{FeaturesAllDay=}"featuresPedestrian"{FeaturesPedestrian=}"featuresCycling"{FeaturesCycling=})}"fResponse"C"fResolution"C"fAbsoluteTimestamp"d"fAbsoluteImpactTimestamp"d"fTimestamp"d"fSOSCallTimestamp"d"fFallSOSState"C}
{unique_ptr<CLGeomagneticModelProvider_Type::Client, std::default_delete<CLGeomagneticModelProvider_Type::Client>>="__ptr_"{__compressed_pair<CLGeomagneticModelProvider_Type::Client *, std::default_delete<CLGeomagneticModelProvider_Type::Client>>="__value_"^{Client}}}
{CLVisualLocalizationPropagation="_vptr$CLVisualLocalizationPropagation"^^?"fVlfRotationRateHistory"{CMFixedSizeQueue<CMVector<float, 3>, 400>="fHeadAndSize"{?="fHead"S"fSize"S}"fCapacity"I"fBuffer"[12c]"fStorage"{CMQueueStorage<CMVector<float, 3>, 400>="buffer"[4788c]}}"fVlfTimestampHistory"{CMFixedSizeQueue<unsigned long long, 400>="fHeadAndSize"{?="fHead"S"fSize"S}"fCapacity"I"fBuffer"[8c]"fStorage"{CMQueueStorage<unsigned long long, 400>="buffer"[3192c]}}"fAttitudePropagated"{CMOQuaternion="elements"[4f]}"fAttitudeUncertainty"f"fTimestamp"Q"fAttitudeQuaternion"{CMOQuaternion="elements"[4f]}}
@32@0:8d16d24
v40@0:8d16@24@?32
v32@0:8q16@?24
v48@0:8@16@24d32@?40
v32@0:8Q16R@24
v56@0:8d16d24d32@40@?48
v64@0:8d16d24d32@40@48@?56
v32@0:8@"CLLocation"16@?<v@?q@"NSError">24
v32@0:8@"NSString"16@?<v@?@"NSArray"@"NSError">24
v32@0:8@"NSUUID"16@?<v@?@"RTLocationOfInterest"@"NSError">24
v40@0:8d16@"CLLocation"24@?<v@?@"NSArray"@"NSError">32
v32@0:8q16@?<v@?@"NSArray"@"NSError">24
v24@0:8@?<v@?@"NSArray"@"NSError">16
v48@0:8@"CLLocation"16@"NSDate"24d32@?<v@?@"NSArray"@"NSError">40
v32@0:8@"NSDate"16@?<v@?@"NSArray"@"NSError">24
v40@0:8@"NSDate"16@"NSDate"24@?<v@?@"NSArray"@"NSError">32
v24@0:8R@"<CLRoutineMonitorClientProtocol>"16
v32@0:8@"CLLocation"16@?<v@?@"RTLocationOfInterest"@"NSError">24
v32@0:8Q16R@"<CLRoutineMonitorClientProtocol>"24
v56@0:8d16d24d32@"NSArray"40@?<v@?@"NSArray"@"NSArray">48
v32@0:8@"RTStoredVisitFetchOptions"16@?<v@?@"NSArray"@"NSError">24
v64@0:8d16d24d32@"NSArray"40@"NSArray"48@?<v@?@"NSArray"@"NSArray">56
v32@0:8@"NSDate"16@?<v@?@"CLLocation"@"NSError">24
v40@0:8@"NSDate"16@"RTEstimatedLocationOptions"24@?<v@?@"CLLocation"@"NSError">32
v32@0:8@"RTPlaceInferenceOptions"16@?<v@?@"NSArray"@"NSError">24
v24@0:8@?<v@?@"NSDictionary"@"NSError">16
v32@0:8@"NSArray"16@?<v@?>24
B32@0:8@"NSXPCListener"16@"NSXPCConnection"24
{unique_ptr<CLFilteredLocationController_Type::Client, std::default_delete<CLFilteredLocationController_Type::Client>>="__ptr_"{__compressed_pair<CLFilteredLocationController_Type::Client *, std::default_delete<CLFilteredLocationController_Type::Client>>="__value_"^{Client}}}
{unique_ptr<CLLocationAwarenessProvider_Type::Client, std::default_delete<CLLocationAwarenessProvider_Type::Client>>="__ptr_"{__compressed_pair<CLLocationAwarenessProvider_Type::Client *, std::default_delete<CLLocationAwarenessProvider_Type::Client>>="__value_"^{Client}}}
{RegInfo="settledParameters"{MonitoringParameters="latencyBudget"d"retryRate"d"queryALS"B}"unsettledParameters"{MonitoringParameters="latencyBudget"d"retryRate"d"queryALS"B}}
@"NSXPCConnection"
@"NSXPCListener"
@"RTRoutineManager"
v24@0:8r^{Sample=d{?=ff}}16
v32@0:8r^i16r^(NotificationData={ReachabilityState=iiBB}{Battery=dBBiBi}BBBBiiB)24
v80@0:8{?=ffffffi{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}B}16
{unique_ptr<CLMotionNotifier::Dispatcher, std::default_delete<CLMotionNotifier::Dispatcher>>="__ptr_"{__compressed_pair<CLMotionNotifier::Dispatcher *, std::default_delete<CLMotionNotifier::Dispatcher>>="__value_"^{Dispatcher}}}
{CLK2Detector="fBufPressureRaw"{vector<float, std::allocator<float>>="__begin_"^f"__end_"^f"__end_cap_"{__compressed_pair<float *, std::allocator<float>>="__value_"^f}}"fBufPressureError"{vector<float, std::allocator<float>>="__begin_"^f"__end_"^f"__end_cap_"{__compressed_pair<float *, std::allocator<float>>="__value_"^f}}"fBufTemperatureRaw"{vector<float, std::allocator<float>>="__begin_"^f"__end_"^f"__end_cap_"{__compressed_pair<float *, std::allocator<float>>="__value_"^f}}"fFeatures"{vector<std::vector<float>, std::allocator<std::vector<float>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::vector<float> *, std::allocator<std::vector<float>>>="__value_"^v}}"fCurrentCount"i"fMinTemperature"f"fMaxTemperature"f"fMinPressure"f"fMaxPressure"f}
{CLRobustSlopeEstimator="fLastSampleTime"f"fRunningTemperatureBuffer"{deque<float, std::allocator<float>>="__map_"{__split_buffer<float *, std::allocator<float *>>="__first_"^^f"__begin_"^^f"__end_"^^f"__end_cap_"{__compressed_pair<float **, std::allocator<float *>>="__value_"^^f}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<float>>="__value_"Q}}"fTemperatureBins"{map<int, std::deque<CLPressure::Sample>, std::less<int>, std::allocator<std::pair<const int, std::deque<CLPressure::Sample>>>>="__tree_"{__tree<std::__value_type<int, std::deque<CLPressure::Sample>>, std::__map_value_compare<int, std::__value_type<int, std::deque<CLPressure::Sample>>, std::less<int>, true>, std::allocator<std::__value_type<int, std::deque<CLPressure::Sample>>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<int, std::deque<CLPressure::Sample>>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<int, std::__value_type<int, std::deque<CLPressure::Sample>>, std::less<int>, true>>="__value_"Q}}}"fTemperatureBinCount"{map<int, int, std::less<int>, std::allocator<std::pair<const int, int>>>="__tree_"{__tree<std::__value_type<int, int>, std::__map_value_compare<int, std::__value_type<int, int>, std::less<int>, true>, std::allocator<std::__value_type<int, int>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<int, int>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<int, std::__value_type<int, int>, std::less<int>, true>>="__value_"Q}}}"minBin"i"maxBin"i}
{?="mac"b1}
v56@0:8@"NSDictionary"16@"NSDictionary"24@"NSArray"32@"NSArray"40@"CLLocation"48
v24@0:8R@"<CLWeatherServiceClientProtocol>"16
v24@0:8@"CLWeatherServiceData"16
v24@0:8R@"<CLRemoteMotionAlarmClientProtocol>"16
@56@0:8@16q24q32q40@?48
v40@0:8q16q24q32
@"CLDispatchSilo"
v252@0:8i16(NotificationData={CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLExtendedStepCountEntry=d{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLStepCountEntryAddition=ddIddddBd}}{CLPedometerEvent=di}{CLOdometerSuitability=dBB})20
{deque<std::pair<double, double>, std::allocator<std::pair<double, double>>>="__map_"{__split_buffer<std::pair<double, double> *, std::allocator<std::pair<double, double> *>>="__first_"^^v"__begin_"^^v"__end_"^^v"__end_cap_"{__compressed_pair<std::pair<double, double> **, std::allocator<std::pair<double, double> *>>="__value_"^^v}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<std::pair<double, double>>>="__value_"Q}}
v120@0:8{CLSkiEntry=Q[16C][16C]ddddddd}16@?112
v120@0:8{CLSkiEntry=Q[16C][16C]ddddddd}16@?<v@?@"NSArray">112
@48@0:8@16@24^v32@40
v32@0:8^d16^d24
v40@0:8^d16d24d32
{unique_ptr<CLPowerAssertion, std::default_delete<CLPowerAssertion>>="__ptr_"{__compressed_pair<CLPowerAssertion *, std::default_delete<CLPowerAssertion>>="__value_"^{CLPowerAssertion}}}
d36@0:8@16d24i32
d32@0:8@16d24
v17@0:8{CLAvengerObservationReporterServiceStateContext=B}16
q17@0:8{CLAvengerObservationReporterServiceStateContext=B}16
{CLAvengerObservationReporterServiceStateContext="cameraForegrounded"B}
@"<CLAvengerScannerServiceProtocol>"
@"SPFinderInterface"
@"CLAvengerBeaconPayloadDedupingCache"
B24@0:8^{CLGnssControlPlaneStatusReport=ddddddiiI}16
v192@0:8{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16
B24@0:8^{ThinShellIonosphereParameters=}16
@"CLCKVO2MaxEstimate"
@"CLCKVO2MaxSessionAttributes"
v24@0:8i16B20
v32@0:8I16Q20B28
v32@0:8R@16d24
v32@0:8R@"<CLStreamingAwareLocationProviderClientProtocol>"16d24
v24@0:8R@"<CLStreamingAwareLocationProviderClientProtocol>"16
v28@0:8i16d20
@40@0:8d16d24d32
v24@0:8@?<v@?>16
v24@0:8R@"<CLMobilityWalkingBoutServiceClientProtocol>"16
v32@0:8r^i16r^(NotificationData={CLWorkoutUpdate=diiI}{CLMotionStateUpdate=dii})24
v24@0:8r^{SPUGaitMetrics={GaitMetrics=CCCCCCCCQQfffff}d}16
v40@0:8{vector<CLMobility::ProcessedBoutResult, std::allocator<CLMobility::ProcessedBoutResult>>=^{ProcessedBoutResult}^{ProcessedBoutResult}{__compressed_pair<CLMobility::ProcessedBoutResult *, std::allocator<CLMobility::ProcessedBoutResult>>=^{ProcessedBoutResult}}}16
v76@0:8{CLBodyMetrics=iiffffffffifBfBBB}16
f24@0:8f16f20
{shared_ptr<CLMobility::BoutBoundaryRecorderDb>="__ptr_"^{BoutBoundaryRecorderDb}"__cntrl_"^{__shared_weak_count}}
{unique_ptr<CLActivityAggregator<CLMobility::BoutBoundary>, std::default_delete<CLActivityAggregator<CLMobility::BoutBoundary>>>="__ptr_"{__compressed_pair<CLActivityAggregator<CLMobility::BoutBoundary> *, std::default_delete<CLActivityAggregator<CLMobility::BoutBoundary>>>="__value_"^v}}
{unique_ptr<CLActivityAggregator<CLMobility::GaitMetrics>, std::default_delete<CLActivityAggregator<CLMobility::GaitMetrics>>>="__ptr_"{__compressed_pair<CLActivityAggregator<CLMobility::GaitMetrics> *, std::default_delete<CLActivityAggregator<CLMobility::GaitMetrics>>>="__value_"^v}}
{shared_ptr<CLMobility::BoutMetricsRecorderDb>="__ptr_"^{BoutMetricsRecorderDb}"__cntrl_"^{__shared_weak_count}}
{unique_ptr<CLActivityAggregator<CLMobility::BoutMetrics>, std::default_delete<CLActivityAggregator<CLMobility::BoutMetrics>>>="__ptr_"{__compressed_pair<CLActivityAggregator<CLMobility::BoutMetrics> *, std::default_delete<CLActivityAggregator<CLMobility::BoutMetrics>>>="__value_"^v}}
{shared_ptr<CLMobility::HealthKitQueryDelegate>="__ptr_"^{HealthKitQueryDelegate}"__cntrl_"^{__shared_weak_count}}
{unique_ptr<CLMobility::WalkingBoutExtractor, std::default_delete<CLMobility::WalkingBoutExtractor>>="__ptr_"{__compressed_pair<CLMobility::WalkingBoutExtractor *, std::default_delete<CLMobility::WalkingBoutExtractor>>="__value_"^{WalkingBoutExtractor}}}
{unique_ptr<CLMobility::WalkingSteadinessClassifier, std::default_delete<CLMobility::WalkingSteadinessClassifier>>="__ptr_"{__compressed_pair<CLMobility::WalkingSteadinessClassifier *, std::default_delete<CLMobility::WalkingSteadinessClassifier>>="__value_"^{WalkingSteadinessClassifier}}}
{unique_ptr<CLMotionNotifier::SiloDispatcher<CLMobility::SPUGaitMetrics>, std::default_delete<CLMotionNotifier::SiloDispatcher<CLMobility::SPUGaitMetrics>>>="__ptr_"{__compressed_pair<CLMotionNotifier::SiloDispatcher<CLMobility::SPUGaitMetrics> *, std::default_delete<CLMotionNotifier::SiloDispatcher<CLMobility::SPUGaitMetrics>>>="__value_"^v}}
@"CLMobilityHealthKitWriter"
@36@0:8@16I24C28C32
v36@0:8R@16B24@28
v32@0:8R@"<CLAvengerScannerClientProtocol>"16@"NSString"24
v36@0:8R@"<CLAvengerScannerClientProtocol>"16B24@"NSString"28
v24@0:8R@"<CLAvengerScannerClientProtocol>"16
v76@0:8@16@24@32C40q44@52@60@68
v76@0:8@"NSDate"16@"NSData"24@"NSData"32C40q44@"NSData"52@"NSNumber"60@"CLAvengerScannerReconciledInformation"68
v24@0:8@"CLDurianSystemMonitor"16
v28@0:8@"CLDurianSystemMonitor"16B24
v28@0:8@"CLDurianSystemMonitor"16i24
@"CBCentralManager"
@"CLAvengerScannerStateContext"
@"NSMapTable"
@"CLAvengerScannerPolicy"
@"CLDurianSystemMonitor"
{CLAvengerScannerAnalytics="count_submission"I"numSwitchToAggressiveScan"I"lastRequestTime"d}
@"CLAvengerScannerSettings"
{?="bandclass"b1"bsid"b1"channel"b1"mcc"b1"nid"b1"pnoffset"b1"sid"b1"zoneid"b1}
{?="cadenceMean"b1"durationInSeconds"b1"gradeMean"b1"gradeVariance"b1"hrCadenceAgreementMean"b1"hrCadenceAgreementVariance"b1"hrConfidenceMean"b1"hrConfidenceVariance"b1"hrMax"b1"hrMean"b1"hrMin"b1"hrVariance"b1"pointCount"b1"speedMean"b1"speedVariance"b1"startTime"b1"vo2Mean"b1"vo2Variance"b1"sessionType"b1"vo2MaxModelSource"b1"workoutType"b1}
{?="bandclass"b1"channel"b1"pnoffset"b1}
{?="arfcn"b1"psc"b1}
{?="altitude"b1"confidence"b1"infoMask"b1"locationType"b1"reach"b1"score"b1"verticalAccuracy"b1}
{?="numberOfSurroundingCdmaCells"b1"numberOfSurroundingCdmaEvdoCells"b1"numberOfSurroundingCells"b1"numberOfSurroundingLteCells"b1"numberOfSurroundingNr5GCells"b1"numberOfSurroundingScdmaCells"b1"numberOfSurroundingWifis"b1"wifiAltitudeScale"b1}
@"ALSLocation"
{?="cellID"b1"mcc"b1"mnc"b1"pid"b1"tacID"b1"uarfcn"b1}
^i16@0:8
i24@0:8Q16
v32@0:8^i16Q24
{?="list"^i"count"Q"size"Q}
{?="numberOfSurroundingWifis"b1"radius"b1"technology"b1"wifiAltitudeScale"b1"wifiGranularity"b1"needCellsTowers"b1}
@40@0:8Q16Q24d32
{CLLocationCoordinate2D=dd}16@0:8
v32@0:8{CLLocationCoordinate2D=dd}16
{CLLocationCoordinate2D="latitude"d"longitude"d}
v152@0:8(NotificationData={CLOdometerEntry=dddddddddiiidddddd}{CLElevationChangeEntry=ddIIidiifCSf}{CLCoarseElevationChangeEntry=dIi}{CLSignificantElevation=i[16C]ddII})16
@"CLBarometerCalibrationTrack"
B24@0:8^@16
v24@0:8@"<CLDuetMonitorServiceProtocol>"16
v32@0:8@"<CLDuetMonitorServiceProtocol>"16@"CLDuetForegroundApp"24
v32@0:8@"<CLDuetMonitorServiceProtocol>"16@"CLDuetHomeKitScene"24
v32@0:8@"<CLDuetMonitorServiceProtocol>"16@"CLDuetHomeKitAccessory"24
v32@0:8@"<CLDuetMonitorServiceProtocol>"16@"CLDuetHomeKitAppView"24
v32@0:8@"<CLDuetMonitorServiceProtocol>"16@"CLDuetNowPlaying"24
v32@0:8@"<CLATVAirplayMonitorServiceProtocol>"16@"NSArray"24
@24@0:8^{CLSubHarvesterAltimeterExternal=^^?@@@^{Receiver}}16
^{CLSubHarvesterAltimeterExternal=^^?@@@^{Receiver}}
{?="channel"b1}
d24@0:8@16
{?="latitude"b1"longitude"b1}
v24@0:8R@"<CLEmergencyClientProtocol>"16
v68@0:8i16@20{CLTileFileDownloadDetails=BBBdidBB}28
B48@0:8^v16d24d32^v40
v84@0:8i16d20d28Q36{CLTileFileDownloadDetails=BBBdidBB}44
@52@0:8i16d20d28^B36^B44
B28@0:8i16@20
B48@0:8r^{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16f24^v28^v36B44
B36@0:8@16i24d28
v68@0:8i16@"NSString"20{CLTileFileDownloadDetails=BBBdidBB}28
@"NSString"52@0:8i16d20d28^B36^B44
B28@0:8i16@"NSString"20
B36@0:8@"NSString"16i24d28
B32@0:8{CLLocationCoordinate2D=dd}16
B32@0:8q16Q24
v64@0:8d16d24{CLLocationCoordinate2D=dd}32d48Q56
B28@0:8f16d20
{CLFloorTransitionDetector="fBuffer"{deque<RelativeAltitude, std::allocator<RelativeAltitude>>="__map_"{__split_buffer<RelativeAltitude *, std::allocator<RelativeAltitude *>>="__first_"^^{RelativeAltitude}"__begin_"^^{RelativeAltitude}"__end_"^^{RelativeAltitude}"__end_cap_"{__compressed_pair<RelativeAltitude **, std::allocator<RelativeAltitude *>>="__value_"^^{RelativeAltitude}}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<RelativeAltitude>>="__value_"Q}}"fInTransition"B"fIsBufferFull"B"fLastFloorTransitionTime"d}
B68@0:8@16@24@32@40C48C52B56B60B64
{?="rawCoordinateLatitude"b1"rawCoordinateLongitude"b1}
@20@0:8B16
{map<CLBarometerCalibration_Types::Source, double, std::less<CLBarometerCalibration_Types::Source>, std::allocator<std::pair<const CLBarometerCalibration_Types::Source, double>>>="__tree_"{__tree<std::__value_type<CLBarometerCalibration_Types::Source, double>, std::__map_value_compare<CLBarometerCalibration_Types::Source, std::__value_type<CLBarometerCalibration_Types::Source, double>, std::less<CLBarometerCalibration_Types::Source>, true>, std::allocator<std::__value_type<CLBarometerCalibration_Types::Source, double>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<CLBarometerCalibration_Types::Source, double>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<CLBarometerCalibration_Types::Source, std::__value_type<CLBarometerCalibration_Types::Source, double>, std::less<CLBarometerCalibration_Types::Source>, true>>="__value_"Q}}}
@40@0:8d16@24@?32
@"<CLOdometerAlarmManagerProtocol>"
v24@0:8@"CLOdometerAlarm"16
{unique_ptr<CLGnssProvider_Type::Client, std::default_delete<CLGnssProvider_Type::Client>>="__ptr_"{__compressed_pair<CLGnssProvider_Type::Client *, std::default_delete<CLGnssProvider_Type::Client>>="__value_"^{Client}}}
@"CLOdometerAlarm"
@"NSData"
{?="workoutType"b1}
@24@0:8^{CLDistributedSensingSubscription=^^?^{CLConnection}@@@}16
^{CLDistributedSensingSubscription=^^?^{CLConnection}@@@}
@60@0:8@16@24d32d40d48i56
@152@0:8{CLOdometerEntry=dddddddddiiidddddd}16
{CLOdometerEntry=dddddddddiiidddddd}16@0:8
{CLOdometerEntry="startTime"d"distance"d"accuracy"d"gpsAltitude"d"speed"d"rawSpeed"d"odometer"d"gpsSpeedAccuracy"d"timestampGps"d"quality"i"originDevice"i"type"i"groundAltitude"d"groundAltitudeUncertainty"d"smoothedGPSAltitude"d"smoothedGPSAltitudeUncertainty"d"gpsCourseRadians"d"gpsCourseAccuracy"d}
@248@0:8{CLExtendedStepCountEntry=d{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLStepCountEntryAddition=ddIddddBd}}16
{CLExtendedStepCountEntry=d{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLStepCountEntryAddition=ddIddddBd}}16@0:8
v152@0:8{CLOdometerEntry=dddddddddiiidddddd}16
v248@0:8{CLExtendedStepCountEntry=d{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}{CLStepCountEntryAddition=ddIddddBd}}16
d24@0:8[5d]16
{?="basalNatalies"b1"duration"b1"mets"b1"timestamp"b1"basalMETs"b1"recordId"b1}
@24@0:8r^v16
{CLDaemonLocationPrivate=dddddfffBi{?=dd}diiB{?=ddBB}{?=dd}if{?=dd}ddiBddddddddBB{?=dd}diddddddB{SatelliteReport={vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}}i{AltitudeInfo=dddi}CdddCBi}16@0:8
B24@0:8^{CLKappaRecordingSortListener=^^?}16
I20@0:8B16
v28@0:8Q16i24
v24@0:8r^{KappaSensorDataMag=fffQ}16
v24@0:8r^{KappaSensorDataAccel=fffQ}16
v24@0:8r^{KappaSensorDataFastAccel=fffQ}16
v24@0:8r^{KappaSensorDataDeviceMotion=[4f][3f]Q}16
v28@0:8f16Q20
v28@0:8r*16I24
v24@0:8r^{KappaSensorDataPressure=ffQ}16
v24@0:8r^{CLKappaGpsItem=dddddii}16
v32@0:8r^{PressureBiasFit=C[3C]fff}16r^{PressureInertialFit=Cfff}24
v28@0:8r^{CMKappaImpact=QQQIffffff[3f][3f][4f]BBQ}16B24
v93@0:8{CompassCalibration=CcCCB[3f][3f][3f]fffffffff}16
C16@0:8
^{Writer=^{Delegate}@@@qiq*QQ{z_stream_s=*IQ*IQ*^{internal_state}^?^?^viQQ}}
B1392@0:8{NotificationData={CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}{CLDaemonLocationPrivate=dddddfffBi{?=dd}diiB{?=ddBB}{?=dd}if{?=dd}ddiBddddddddBB{?=dd}diddddddB{SatelliteReport={vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}{vector<CLClientSatelliteInfo, std::allocator<CLClientSatelliteInfo>>=^{?}^{?}{__compressed_pair<CLClientSatelliteInfo *, std::allocator<CLClientSatelliteInfo>>=^{?}}}}i{AltitudeInfo=dddi}CdddCBi}{shared_ptr<CLBatchedLocations>=^{CLBatchedLocations}^{__shared_weak_count}}{TechnologyStatus=iB}Bdi{?=dddd}{?=dd}{XtraFileAvailable=d{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}i{LocationDerivedSpeed=ddd}{?=dddi}{?=ddddddB[3[3d]]dddQi}{shared_ptr<const gnss::MeasurementData>=^{MeasurementData}^{__shared_weak_count}}i{?=idddddd[5d]ddddii}{CLStrongPtr<NSData *>=@}{PredictedGnssAvailability=iidd}{CLBasebandTimeFreqTransfer=d{CLBasebandSystemClock=Qffdfd}Qf{LeapSecondInfo=sC{LeapSecondChange=Qs}}}{CLGnssDisablementStatus=B}}16
v40@0:8Q16{shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>=^{CLBarometerCalibrationData}^{__shared_weak_count}}24
{array<std::deque<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>, 7>=[7{deque<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>>={__split_buffer<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *>>=^^v^^v^^v{__compressed_pair<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> **, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData> *>>=^^v}}Q{__compressed_pair<unsigned long, std::allocator<std::shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationData>>>=Q}}]}24@0:8Q16
{map<unsigned int, CLBarometerCalibrationSource *, std::less<unsigned int>, std::allocator<std::pair<const unsigned int, CLBarometerCalibrationSource *>>>="__tree_"{__tree<std::__value_type<unsigned int, CLBarometerCalibrationSource *>, std::__map_value_compare<unsigned int, std::__value_type<unsigned int, CLBarometerCalibrationSource *>, std::less<unsigned int>, true>, std::allocator<std::__value_type<unsigned int, CLBarometerCalibrationSource *>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<unsigned int, CLBarometerCalibrationSource *>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<unsigned int, std::__value_type<unsigned int, CLBarometerCalibrationSource *>, std::less<unsigned int>, true>>="__value_"Q}}}
[7@"NSMutableSet"]
@"<CLBarometerCalibrationAggregatorClient>"
{?="meanMaxMets"b1"prior"b1"startTime"b1"algorithmVersion"b1"hardwareType"b1"betaBlockerUse"b1}
{?="deltaDistance"b1"deltaDistanceAccuracy"b1"groundAltitude"b1"groundAltitudeUncertainty"b1"maxAbsSlope"b1"odometer"b1"slope"b1"timestampGps"b1}
B44@0:8^v16^i24^d32B40
B40@0:8^v16^i24^d32
v24@0:8i16i20
v64@0:8{TunnelBridgeAssistance=dddddBBBB}16
v32@0:8@?16B24B28
v32@0:8@?<{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}@?>16B24B28
{CLVehicleConnection=dd[256c]d}16@0:8
v40@0:8@16Q24@?32
v24@0:8@?<v@?{CLVehicleConnection=dd[256c]d}>16
v40@0:8@"NSString"16Q24@?<v@?B>32
v32@0:8^{__CFUserNotification=}16Q24
v24@0:8@"CMFitnessMachineData"16
B24@0:8^{__CFString=}16
v32@0:8@"NSString"16@?<v@?B>24
v32@0:8@"NSArray"16@?<v@?@"NSArray"@"NSArray">24
@44@0:8i16@20@28B36i40
@"SBSStatusBarStyleOverridesAssertion"
@28@0:8@16i24
@"CSLSSession"
C20@0:8C16
@20@0:8C16
@24@0:8r^{BinaryData=^^?dS}16
@24@0:8r^{FilteredPressure={FilteredPressure=C[3C]ffQQ}d}16
@24@0:8r^{Pressure={Pressure=C[3C]ffQQ}d}16
@24@0:8r^{CLCatherineData=iiddBdddii}16
v28@0:8@16C24
@44@0:8C16@20@28q36
v28@0:8C16@20
v28@0:8C16r^{BinaryData=^^?dS}20
v24@0:8r^{ImpactData=ddC{?=[4f](?=QQ)}}16
v24@0:8r^{FalsePositiveSuppressionFeatures={FalsePositiveSuppressionFeatures=QQQSfffifiQQ}dd}16
v24@0:8r^{WristState=dd{WristState=iiiQBBB}}16
v44@0:8C16@20d28Q36
v24@0:8r^{FilteredPressure={FilteredPressure=C[3C]ffQQ}d}16
v24@0:8r^{Pressure={Pressure=C[3C]ffQQ}d}16
v24@0:8r^{CLCatherineData=iiddBdddii}16
v24@0:8r^{OdometerEntry=dd{CLOdometerEntry=dddddddddiiidddddd}}16
{CLGizmoOrientation=ii}16@0:8
v24@0:8{CLGizmoOrientation=ii}16
{CLGizmoOrientation="fWrist"i"fCrown"i}
@"NSMutableData"
v72@0:8d16d24{CLTileFileDownloadDetails=BBBdidBB}32
v40@0:8{?=dd}16@?<v@?i>32
v56@0:8{RoutineVisit=ddddd}16
i32@0:8^{CLNatalieData=i^{__CFString}diBBddqqd[16C]}16^v24
i32@0:8^{CLExerciseMinuteData=id^{__CFString}}16^v24
v40@0:8{?=dd}16@?32
v136@0:8{VO2MaxInput=Q[16C]fdffdidBBiqddB}16@?128
v28@0:8@"NSDictionary"16B24
v40@0:8{?=dd}16@?<v@?@"NSArray"i>32
v136@0:8{VO2MaxInput=Q[16C]fdffdidBBiqddB}16@?<v@?@"NSArray"i>128
v32@0:8@"NSUUID"16@?<v@?@"CMWorkoutMetsData"i>24
@32@0:8@16i24i28
v28@0:8@16I24
v36@0:8@16I24@?28
@"NSFileHandle"
@48@0:8@16@24@32i40i44
v36@0:8@16@24I32
@28@0:8i16@20
@28@0:8i16B20i24
@24@0:8i16i20
Q20@0:8i16
@"NSURL"
v52@0:8d16d24f32B36B40@?44
v52@0:8d16d24f32B36B40@?<v@?@"NSArray"@"NSError">44
@44@0:8d16d24f32B36B40
v100@0:8i16{NotificationData=Bi{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}}20
{unique_ptr<CLTilesManager_Type::Client, std::default_delete<CLTilesManager_Type::Client>>="__ptr_"{__compressed_pair<CLTilesManager_Type::Client *, std::default_delete<CLTilesManager_Type::Client>>="__value_"^{Client}}}
B20@0:8i16
v24@0:8@?<{ProximityZoneEvent={ProximityZone={Region=^^?{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}SSi}}{Region=^^?{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}SSi}ii}@?>16
v24@0:8@?<{ProximityScanEvent={list<CLBTLEBeaconProvider_Type::ProximityDevice, std::allocator<CLBTLEBeaconProvider_Type::ProximityDevice>>={__list_node_base<CLBTLEBeaconProvider_Type::ProximityDevice, void *>=^v^v}{__compressed_pair<unsigned long, std::allocator<std::__list_node<CLBTLEBeaconProvider_Type::ProximityDevice, void *>>>=Q}}}@?>16
{deque<CLElevationChangeEntry, std::allocator<CLElevationChangeEntry>>="__map_"{__split_buffer<CLElevationChangeEntry *, std::allocator<CLElevationChangeEntry *>>="__first_"^^{CLElevationChangeEntry}"__begin_"^^{CLElevationChangeEntry}"__end_"^^{CLElevationChangeEntry}"__end_cap_"{__compressed_pair<CLElevationChangeEntry **, std::allocator<CLElevationChangeEntry *>>="__value_"^^{CLElevationChangeEntry}}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::allocator<CLElevationChangeEntry>>="__value_"Q}}
@656@0:8{HarvestData=d{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}iiii{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}iBB{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}{CLMotionActivity=iiiiiBfdBiddii{?=b1b1b1b1b1}ifffidQi}}16{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}480
{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16@0:8
@"CLPAccessoryMeta"
{CLDaemonLocation="padding1"i"suitability"i"coordinate"{?="latitude"d"longitude"d}"horizontalAccuracy"d"altitude"d"verticalAccuracy"d"padding2"d"padding3"d"speed"d"speedAccuracy"d"course"d"courseAccuracy"d"timestamp"d"confidence"i"lifespan"d"type"i"rawCoordinate"{?="latitude"d"longitude"d}"rawCourse"d"floor"i"integrity"I"referenceFrame"i"rawReferenceFrame"i"signalEnvironmentType"i"ellipsoidalAltitude"d"fromSimulationController"B}
@32@0:8{?=dd}16
{?=dd}24@0:8@16
v24@0:8@?<{MonitoredRegion=^^?{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}SSi{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}i}@?>16
v80@0:8{CLSpringTrackerEntry=Q[16C][16C]dq}16@?72
v80@0:8{CLSpringTrackerEntry=Q[16C][16C]dq}16@?<v@?@"NSArray">72
@44@0:8@16I24@28@36
v48@0:8@"NSURLSession"16@"NSURLSessionDataTask"24@"NSURLResponse"32@?<v@?q>40
v40@0:8@"NSURLSession"16@"NSURLSessionDataTask"24@"NSURLSessionDownloadTask"32
v40@0:8@"NSURLSession"16@"NSURLSessionDataTask"24@"NSURLSessionStreamTask"32
v40@0:8@"NSURLSession"16@"NSURLSessionDataTask"24@"NSData"32
v48@0:8@"NSURLSession"16@"NSURLSessionDataTask"24@"NSCachedURLResponse"32@?<v@?@"NSCachedURLResponse">40
@"NSOperationQueue"
@"NSURLSession"
@"NSDateFormatter"
@"<CLHNetworkControllerDelegate>"
v872@0:8d16{?=ddddiiii[50d][50d]}24
v1648@0:8d16{?=diiii[50{?=dddd}]}24
v120@0:8{DirectionOfTravelAssistance=dddddddddBBBBBidd}16
v64@0:8{MapMatchedPositionAssistance=dddddd}16
v136@0:8{TunnelEndPositionAssistance=dddddddddBiBdddd}16
{shared_ptr<CLBarometerCalibration_Types::CLBarometerCalibrationWifiData>=^{CLBarometerCalibrationWifiData}^{__shared_weak_count}}88@0:8{AccessPoint={CLMacAddress=Q}{basic_string<char, std::char_traits<char>, std::allocator<char>>={__compressed_pair<std::basic_string<char>::__rep, std::allocator<char>>={__rep=(?={__long=QQ*}{__short=(?=Cc)[23c]}{__raw=[3Q]})}}}iiiddBB}16
v32@0:8@16r^v24
{CLBarometerCalibrationWiFiActiveScanBuffer="buffer"{unordered_map<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket, std::hash<CLMacAddress>, std::equal_to<CLMacAddress>, std::allocator<std::pair<const CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>>>="__table_"{__hash_table<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, std::__unordered_map_hasher<CLMacAddress, std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, std::hash<CLMacAddress>, std::equal_to<CLMacAddress>, true>, std::__unordered_map_equal<CLMacAddress, std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, std::equal_to<CLMacAddress>, std::hash<CLMacAddress>, true>, std::allocator<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *> *> *[], std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *> *> **, std::__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *> *> *>>>="__value_"^^v"__value_"{__bucket_list_deallocator<std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::allocator<std::__hash_node_base<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *> *>, std::allocator<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *>>>="__value_"{__hash_node_base<std::__hash_node<std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, void *> *>="__next_"^v}}"__p2_"{__compressed_pair<unsigned long, std::__unordered_map_hasher<CLMacAddress, std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, std::hash<CLMacAddress>, std::equal_to<CLMacAddress>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__unordered_map_equal<CLMacAddress, std::__hash_value_type<CLMacAddress, CLBarometerCalibrationWiFiActiveScanBucket>, std::equal_to<CLMacAddress>, std::hash<CLMacAddress>, true>>="__value_"f}}}}
{?="mode"b1}
@44@0:8I16d20@28@?36
@52@0:8I16d20@28r^v36@?44
@44@0:8I16d20^{__CFRunLoop=}28@?36
^{__CFRunLoop=}
B24@0:8r^v16
v48@0:8@"IDSBatchIDQueryController"16@"NSDictionary"24@"NSString"32@"NSError"40
v32@0:8@"NSDictionary"16@"NSString"24
@40@0:8@16@24q32
B32@0:8^q16^@24
@"NSOutputStream"
B40@0:8^v16@24@32
B40@0:8^v16@"NSString"24@"NSString"32
i32@0:8@"NSString"16@"NSString"24
{CLStrideLengthStepCadencePair="strideLength"f"stepCadence"f}
@32@0:8Q16d24
v24@0:8R@"<CLTransitMacMonitorClientProtocol>"16
v32@0:8r^v16@24
@"<CLWifiServiceProtocol>"
@"<CLTransitMacTileDataProviderProtocol>"
@32@0:8@16^{CLITileDownloadSchedulingClientDelegate=^^?}24
^{CLITileDownloadSchedulingClientDelegate=^^?}16@0:8
v24@0:8^{CLITileDownloadSchedulingClientDelegate=^^?}16
@"<CLTileDownloadSchedulingServiceProtocol>"
^{CLITileDownloadSchedulingClientDelegate=^^?}
v32@0:8^@16@24
@"<CLWorkoutGeoFenceControllerDelegate>"
@"CLRegion"
@40@0:8@16@24^{CLKappaServerClient=^^?}32
^{CLKappaServerClient=^^?}
q24@0:8@16
@"NSArray"
@56@0:8@16{CLZoneBoundary_=dddd}24
B40@0:8d16d24d32
{?="endTime"b1"locationType"b1"workoutType"b1}
@24@0:8^{CLNotifierClientBase=^^?}16
^{CLNotifierClientBase=^^?}
v24@0:8^{CLNotifierBase=^^?}16
^{CLNotifierBase=^^?}16@0:8
{map<unsigned long, int, std::less<unsigned long>, std::allocator<std::pair<const unsigned long, int>>>="__tree_"{__tree<std::__value_type<unsigned long, int>, std::__map_value_compare<unsigned long, std::__value_type<unsigned long, int>, std::less<unsigned long>, true>, std::allocator<std::__value_type<unsigned long, int>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<unsigned long, int>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<unsigned long, std::__value_type<unsigned long, int>, std::less<unsigned long>, true>>="__value_"Q}}}
^{CLNotifierBase=^^?}
@48@0:8i16i20i24{CLClientServiceTypeMaskTuple=QQ}28B44
@32@0:8{CLClientServiceTypeMaskTuple=QQ}16
i32@0:8@16Q24
@"CLClientManagerAuthorizationContext"24@0:8@"NSString"16
v32@0:8@"NSString"16@?<v@?@"CLClientManagerAuthorizationContext">24
i32@0:8@"NSString"16Q24
@"HKHealthWrapMessageConfiguration"
v48@0:8d16@24@32@40
v44@0:8i16@20@28@36
v48@0:8i16d20@28@36C44
v44@0:8i16d20@28@36
v52@0:8i16d20@28@36@44
@"<CLMobilityWalkingBoutServiceProtocol>"
@"HKMobilityWalkingSteadinessFeatureStatusManager"
@"HKDataCollector"
v40@0:8{TremorScore=diff}16
v32@0:8i16r^v20i28
v24@0:8^{KappaConfig=iiiiiiI}16
{?="powerSource"b1}
v24@0:8@?<v@?QQ>16
v24@0:8@?<v@?Q>16
v24@0:8@?<v@?QQQ>16
{?="cellID"b1"mcc"b1"mnc"b1"nrarfcn"b1"tacID"b1}
{?="timestampGps"b1"accuracy"b1"distance"b1"gpsAltitude"b1"gpsSpeedAccuracy"b1"quality"b1"rawSpeed"b1"speed"b1}
v36@0:8@16i24@?28
v32@0:8@"NSArray"16@"NSNumber"24
v36@0:8@"NSArray"16i24@?<v@?@"NSArray"@"NSError">28
{CLStepDistance=iddiidi}32@0:8^d16^d24
i176@0:8{CLStepCountEntry=dddIddIIdddi^{__CFString}BB{CLAccelerometerPace=ddd}IICII(FalseStepDetectorStateUnion={FalseStepDetectorState=b1b1b1b1b1b1b1b1}C)CC}16^v168
@"NSArray"16@0:8
v32@0:8q16@?<v@?@"NSArray">24
v24@0:8@?<v@?@"CMStrideCalibrationHistory">16
v24@0:8r^{CMKFFilteredPressureSample=fdffdf}16
{unique_ptr<CLMotionNotifier::SiloDispatcher<CLBarometerCalibration_Types::CMKFFilteredPressureSample>, std::default_delete<CLMotionNotifier::SiloDispatcher<CLBarometerCalibration_Types::CMKFFilteredPressureSample>>>="__ptr_"{__compressed_pair<CLMotionNotifier::SiloDispatcher<CLBarometerCalibration_Types::CMKFFilteredPressureSample> *, std::default_delete<CLMotionNotifier::SiloDispatcher<CLBarometerCalibration_Types::CMKFFilteredPressureSample>>>="__value_"^v}}
v152@0:8{CLSwimEntry=Q[16C][16C]ddddddiiiifffii}16@?144
v152@0:8{CLSwimEntry=Q[16C][16C]ddddddiiiifffii}16@?<v@?@"NSArray">144
v44@0:8i16(NotificationData={ReachabilityState=iiBB}{Battery=dBBiBi}BBBBiiB)20
{unique_ptr<CLDaemonStatus_Type::Client, std::default_delete<CLDaemonStatus_Type::Client>>="__ptr_"{__compressed_pair<CLDaemonStatus_Type::Client *, std::default_delete<CLDaemonStatus_Type::Client>>="__value_"^{Client}}}
@"<CLDurianSystemMonitorDelegate>"
v48@0:8@16@24@32^v40
{unique_ptr<CLNearbydInterfaceManager, std::default_delete<CLNearbydInterfaceManager>>="__ptr_"{__compressed_pair<CLNearbydInterfaceManager *, std::default_delete<CLNearbydInterfaceManager>>="__value_"^{CLNearbydInterfaceManager}}}
v200@0:8{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16@?192
v28@0:8B16@?20
v48@0:8d16@24@32@?40
v48@0:8B16i20@24@32@?40
v48@0:8@16@24Q32@?40
v80@0:8@16d24d32d40i48i52@56@64@?72
v60@0:8@16i24i28i32@36@44@?52
v52@0:8B16@20@28@36@?44
v48@0:8@16@24B32B36@?40
v32@0:8I16B20@?24
v28@0:8I16@?20
v40@0:8@16i24i28@?32
v84@0:8B16@20@28{?=[8I]}36B68B72@?76
v44@0:8i16@20@28@?36
v56@0:8i16i20@24@32@40@?48
v64@0:8@16@24@32@40d48d56
v24@0:8@?<v@?@"NSError"@"NSArray">16
v24@0:8@?<v@?@"NSError"@"NSString">16
v24@0:8@?<v@?@"NSError"@"NSDictionary">16
v40@0:8@"NSString"16@"NSData"24@?<v@?@"NSError">32
v32@0:8@"NSString"16@?<v@?@"NSError"@"NSData">24
v200@0:8{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16@?<v@?@"NSError"@"NSString">192
v28@0:8B16@?<v@?@"NSError">20
v24@0:8@?<v@?@"NSError">16
v48@0:8@"NSString"16@"NSString"24@"NSData"32@?<v@?@"NSError">40
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError"@"NSData">32
v48@0:8d16@"NSString"24@"NSString"32@?<v@?@"NSError"d>40
v48@0:8B16i20@"NSString"24@"NSString"32@?<v@?@"NSError">40
v24@0:8@?<v@?@"NSError"B>16
v24@0:8@?<v@?@"NSError"i>16
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError"i>32
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError"B>32
v32@0:8@"NSString"16@?<v@?@"NSError">24
v40@0:8@"NSString"16@"NSString"24@?<v@?@"NSError"@"NSDictionary">32
v48@0:8@"NSString"16@"NSString"24Q32@?<v@?@"NSError"B>40
v80@0:8@"NSString"16d24d32d40i48i52@"NSString"56@"NSString"64@?<v@?@"NSError">72
v60@0:8@"NSString"16i24i28i32@"NSString"36@"NSString"44@?<v@?@"NSError">52
v52@0:8B16@"NSString"20@"NSString"28@"NSString"36@?<v@?@"NSError">44
v48@0:8@"NSString"16@"NSString"24@"NSString"32@?<v@?@"NSError">40
v48@0:8@"NSString"16@"NSString"24B32B36@?<v@?@"NSError"{?=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}>40
v48@0:8@"NSString"16@"NSString"24@"CLLocation"32@?<v@?@"NSError"{?=dddi}>40
v40@0:8@"NSData"16@"NSUUID"24@?<v@?@"NSError">32
v24@0:8@?<v@?@"NSError"@"NSData">16
v32@0:8I16B20@?<v@?@"NSError">24
v28@0:8I16@?<v@?@"NSError"B>20
v40@0:8@"NSData"16i24i28@?<v@?@"NSError">32
v84@0:8B16@"NSString"20@"NSString"28{?=[8I]}36B68B72@?<v@?@"NSError">76
v28@0:8i16@?<v@?@"NSError">20
v44@0:8i16@"NSString"20@"NSString"28@?<v@?@"NSError">36
v56@0:8i16i20@"NSString"24@"NSString"32@"NSString"40@?<v@?@"NSError">48
v24@0:8@?<v@?@"NSError"QQ>16
v64@0:8@"NSDictionary"16@"NSDictionary"24@"NSArray"32@"NSArray"40d48d56
B40@0:8@16@24^v32
{?=[8I]}16@0:8
B32@0:8@16^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}24
v24@0:8r^{Sample=d{?=fff}}16
v28@0:8r^v16I24
v24@0:8r^{Sample=d{?={?=dddd}{?=fff}{?=fff}{?=fff}iBBBfBBi}{?=f}BIC{Status=S}f}16
v32@0:8r^i16r^(NotificationData={CLCatherineData=iiddBdddii}{CLCatherineHealthKitData=dddi}{CLCatherineRestingData=dddd})24
v32@0:8r^i16r^(NotificationData={CLGizmoOrientation=ii}{WristState=iiiQBBB})24
v24@0:8r^{Sample=d{?=fff}f}16
v24@0:8r^{CompassCalibration=CcCCB[3f][3f][3f]fffffffff}16
@"<CLWorkoutRecordingDelegate>"
{unique_ptr<CMMsl::WriterManager, std::default_delete<CMMsl::WriterManager>>="__ptr_"{__compressed_pair<CMMsl::WriterManager *, std::default_delete<CMMsl::WriterManager>>="__value_"^{WriterManager}}}
{unique_ptr<CLCatherineNotifier_Type::Client, std::default_delete<CLCatherineNotifier_Type::Client>>="__ptr_"{__compressed_pair<CLCatherineNotifier_Type::Client *, std::default_delete<CLCatherineNotifier_Type::Client>>="__value_"^{Client}}}
{unique_ptr<CLWatchOrientationSettingsNotifier_Type::Client, std::default_delete<CLWatchOrientationSettingsNotifier_Type::Client>>="__ptr_"{__compressed_pair<CLWatchOrientationSettingsNotifier_Type::Client *, std::default_delete<CLWatchOrientationSettingsNotifier_Type::Client>>="__value_"^{Client}}}
@"BrightnessSystemClient"
{WristState="onWrist"i"onWristSensor"i"onWristConfidence"i"timestamp"Q"isOnCharger"B"isForcedOnWristEnabled"B"isWristDetectionEnabled"B}
{WorkoutRecorderHealthKitInfo="_vptr$Base"^^?"_restingHeartRate"d"_walkingHeartRateAverage"d"_workoutActivityType"I"_has"{?="restingHeartRate"b1"walkingHeartRateAverage"b1"workoutActivityType"b1}}
@40@0:8@16@24{unique_ptr<CLRecordingSettings, std::default_delete<CLRecordingSettings>>={__compressed_pair<CLRecordingSettings *, std::default_delete<CLRecordingSettings>>=^{CLRecordingSettings}}}32
@"<CLRecordingTriggerDelegate><CLWorkoutRecordingDelegate><CLWorkoutRecorderPublisherDelegate>"
@"CLWorkoutRecording"
{unique_ptr<CLRecordingSettings, std::default_delete<CLRecordingSettings>>="__ptr_"{__compressed_pair<CLRecordingSettings *, std::default_delete<CLRecordingSettings>>="__value_"^{CLRecordingSettings}}}
@"CLWorkoutRecorderPublisher"
[16C]
@"CLDispatchSilo"16@0:8
@"CLServiceVendor"16@0:8
B40@0:8^@16^v24@32
^{CLDaemonLocation=ii{?=dd}ddddddddddidi{?=dd}diIiiidB}16@0:8
B40@0:8^@16^v24@"CLWorkoutRecorderPublisher"32
@"NSURL"16@0:8
@"CLWorkoutRecorderTrigger"
@"CLDrivingRecorderTrigger"
v56@0:8@16@24@32@40^v48
@"<CLWorkoutRecorderPublisherDelegate>"
}lD3
{"msg%{public}.0s":"min_dist should not be infinity", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"distanceThresholdVector must not be empty", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"minNumCluster must be greater than zero", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Next scan expected to take %{public}.3Lfs (ending at %{public}0.3fs). Expected time that the scan timer will end: %{public}.03fs
No wifi results so issue a scan with initial delay of %{public}0.3Lfs
Got a scan error so returning a scan delay of %{public}0.3Lfs
Got a scan busy error so returning a scan delay of %{public}0.3Lfs
Returning scan delay: %{public}0.3Lfs
Not enough time for another scan
Setting channels to scan: %{private}s
Bad uwb range, range %{public}.2f, type %{public}d
Failed to connect to database
#Warning Attempt to call %s without a backing database
#Warning Attempt to drop tables without a backing database
#Warning Attempt to call numEntriesFromTriggerTable without a backing database
#Warning Unable to get column count from trigger table
#Warning Attempt to deleteDataOlderThan without a backing database
MicroLocation database has no connection. %{public}s
MicroLocation database sqlite error. %{public}s
#Warning Attempt to deleteUnneededModels without a backing database
#Warning Failed to connect to database
#Warning Attempt to freeDatabaseSpace() without a backing database
Deleting microlocation data older than %.3Lf days
Error getting a prepared statement
Error binding to statement for sql %{private}s
#Warning Attempt to query %{public}s without a backing database
{"msg%{public}.0s":"Free up database space", "Rows to delete":%{public}llu, "Table name":%{public, location:escape_only}s}
#Warning Attempt to get numEntries without a backing database
{"msg%{public}.0s":"DatabaseFreeSpacePercentage needs to be a valid percentage", "percentage":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Database is not connected so we can't intialize our CLMicroLocationRapportTable
Sucessfully created table if necessary: %s
Failed to execute statement. %{public}s
{"msg%{public}.0s":"Couldn't find key: ", "key":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Couldn't find key: onesided_jaccard", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No jaccard_scale_factor provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No e2j_kernel_thr provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No per_source_params provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No jaccard_threshold provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No tanimoto_base provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"fingerprint distance type not supported", "type":%{public}u, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Invalid algorithm chosen", "enum value":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No type provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No sigma provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No power provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Invalid type chosen", "enum value":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No wifi provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No ble provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No uwb provided in dictionary", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Datatype not supported
#Warning Table is not valid so we can't get the most recent wifi channel histogram
Did %{public}s delete old data
MicroLocation database sqlite error. error: %{public}s
Did %{public}s delete unneeded models
Did %{public}s free database space
{"msg%{public}.0s":"cluster distance threshold must not be empty", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"prune threshold must be less than or equal to clusterDistance threshold", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"fingerprintVector must be non-empty", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"isStable, dendrogram, initialization", "isStableflag":%{public}hhd}
{"msg%{public}.0s":"CFType must be a CFNumber to convert to a double", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
error in mean shift algorithm
error in kmeans algorithm
{"msg%{public}.0s":"isStable, toProtobuf", "isStableflag":%{public}hhd}
Got nullptr from CLMicroLocationProto add_anchors
#Warning The protobuf fingerprint does not have a valid cluster label uuid
#Warning The protobuf fingerprint is using a deprecated uint64 cluster label
#Warning The protobuf fingerprint does not have a cluster identifer
#Warning The protobuf cluster recording does not have a valid cluster label uuid
#Warning The protobuf cluster recording does not have a valid recording uuid
{"msg%{public}.0s":"isStable, fromProtobuf", "isStableFlag":%{public}hhd}
{"msg%{public}.0s":"isStable, getter", "numRecordingsBeforePruning":%{public}ld, "numDaysWithRecordings":%{public}ld, "fIsStable":%{public}hhd}
{"msg%{public}.0s":"mapped cluster identifer already exists", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Model has become invalid after pruning clusters with absolute size threshold
#Warning Tried to run learning, but learning is disabled
#Warning Tried to run learning, but database is not valid
{"msg%{public}.0s":"Learning, completed", "Total Time (sec)":"%{public}.4f"}
Model cluster RF sizes %@: %f (min), %f(max), %f (mean)
Model cluster RF distances %@: %f (min), %f(max), %f (mean)
Allowed Anchors logic disabled in settings
Allowed Anchors have no recording triggers!
#Warning shouldCancel is True, Allowed anchors not updated
{"msg%{public}.0s":"Updating anchors data with recording triggers since last learn event", "numRecordingTrigger since last learn":%{public}lu}
{"msg%{public}.0s":"invalid enableInx for recordingTriggers vector - anchors were not enabled", "recordingTriggers size":%{public}lu, "enableInx":%{public}lu}
{"msg%{public}.0s":"invalid disableInx for recordingTriggers vector - anchors were not disabled", "recordingTriggers size":%{public}lu, "disableInx":%{public}lu}
{"msg%{public}.0s":"Learner updated Anchors:", "List":%{private, location:escape_only}s}
#Warning No recording events for model type %{public}d
{"msg%{public}.0s":"Learning started", "modelType":%{public}d, "algorithmType":%{public}d, "numModelIters":%{public}d, "numRecordingTriggers":%{public}lu}
got sufficient recording triggers, will ignore prior cluster number in learning
{"msg%{public}.0s":"Updating Anchor ID Set", "Num. Rapport Anchor Devices":%{public}lu, "Num Rapport and Measured Anchor Devices":%{public}lu, "Number of recordings since last model":%{public}lu, "Anchor Appearance Map size":%{public}lu}
{"msg%{public}.0s":"operation cancelled", "Activity":%{public, location:escape_only}s}
#Warning Fingerprint vector empty for model type %d at iteration %d
{"msg%{public}.0s":"model", "size":%{private}lu, "numClusters":%{private}lu, "type":%{private}d}
{"msg%{public}.0s":"modelFingerprint", "recordingUUID":%{private, location:escape_only}s, "clusterUUID":%{private, location:escape_only}s, "size":%{private}lu, "duration":%{private}d, "start":%{private}d, "end":%{private}d}
#Warning Learning cancelled because %{private}s
set model to stable
{"msg%{public}.0s":"Microlocation model learned", "numFingerprints after pruning":%{public}lu, "numClusters":%{public}lu, "type":%{public}d, "numAnchors":%{public}lu}
Model generated successfully for type %{public}d
#Warning Model was not generated properly. Inserted: %{public,bool}d
No models were generated for model type %{public}d
#Warning Can't insert because the database is invalid
%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem
{"msg%{public}.0s":"analyzing WiFi channels"}
{"msg%{public}.0s":"no LOI types found"}
{"msg%{public}.0s":"Wifi Channel Histogram generated successfully"}
{"msg%{public}.0s":"#Warning Wifi Channel Histogram was not generated properly", "Inserted":%{public}hhd}
{"msg%{public}.0s":"Wifi Channel Histogram was not generated"}
{"msg%{public}.0s":"CFType must be a CFArrayRef to convert to a const char*", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"CFType must be a CFNumber to convert to an int", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Invalid model index", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Unsupported distance function type", "type":%{public}u, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Failed to get a long value for key", "key":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"CFType must be a CFNumber to convert to an enum", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Unable to get the value from a CFNumber", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Database is not connected so we can't intialize our table
#Warning Table is not valid so we can't numLocalizationScansBetweenTimes
#Warning Table is not valid so we can't numRecordingScansBetweenTimes
{"msg%{public}.0s":"Assigning a negative value to an unsigned type is probably not what you intended", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Trying to assign a value that is bigger than the provided type can hold", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Metrics send, localization trigger count event", "event":%{private, location:escape_only}s}
Localizer has invalid model, reporting empty results.
{"msg%{public}.0s":"Localizer: NI, Ignore UWB measurements value is", "isNiIgnore":%{public}d}
Localizer doesn't have any valid measurements to use, reporting empty results.
#Warning Skipping model type %{private}d because it is invalid
{"msg%{public}.0s":"testFingerprint", "ModelType":%{private}lu, "size":%{private}lu, "WiFi RSSI duration":%{private}d, "start":%{private}d, "end":%{private}d}
Localizer doesn't have minimum number of measurements to use for modelType:%{private}u, reporting empty results.
#Warning microlocation probability vector should sum to 1.0 %{public}f
time to load models, %{public}.3lf
{"msg%{public}.0s":"Allowed Anchors, Localizer updated anchors", "ModelType":%{public}lu}
{"msg%{public}.0s":"Localizer Allowed Anchors:", "ModelType":%{public}lu, "List":%{private, location:escape_only}s}
CLMicroLocationLocalizer: Reloaded a new model
#Warning CLMicroLocationLocalizer: Told to reload the model but it is invalid. Not changing current model
{"msg%{public}.0s":"TimeProfile", "action":%{public, location:escape_only}s, "durationSecs":"%{public}f"}
#Warning microlocation probability should be non-negative %{public}f
#Warning Unable to mark activity as %{public}ld. current state is %{public}ld
Checking in for %{public}s
{"msg%{public}.0s":"Expecting a wifi channel histogram", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!
{"msg%{public}.0s":"configured e2jKernelThr illegal value", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"index out of bounds", "ii":%{public}llu, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Invalid CBDevice IDS UUID
{"msg%{public}.0s":"Can't find a model type that corresponds to string", "string":%{private, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Pruned %{public}ld AP measurements, buffer size %{public}ld
{"msg%{public}.0s":"Cannot localize on invalid model!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"nullspace", "identifier":%{private, location:escape_only}s, "weight":"%{private}f", "phat":"%{private}f", "reducedDistance":"%{private}f"}
{"msg%{public}.0s":"Unsupported reducer function", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"CLMicroLocationRecorder: commiting recording transaction", "Recording UUID":%{public, location:escape_only}s, "Num records":%{public}lu, "Num measurements":%{public}lu}
{"msg%{public}.0s":"Can't advance to this state", "currentState":%{public, location:escape_only}s, "providedNextState":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Advanced from %{public}s to %{public}s
{"msg%{public}.0s":"Can't reverse anymore - already in a terminating state", "currentState":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Reversed from %{public}s to %{public}s
Updating localizing scan strategy
Spectating set to %{public}s
BLE spyscan session set to %{public}s
Ranging session set to %{public}s
{"msg%{public}.0s":"Rapport, setRapportSessionRunning", "session set to":%{public, location:escape_only}s}
Ni Session is in state %{public}d for the last  %{public}0.3Lfs
CLMicroLocationLogic: DTOR
CLMicroLocationLogic: Settings updated so updating wifi strategies, allowed anchor models, and checking enabled flags
{"msg%{public}.0s":"client: request, localization scan", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"client request, recording scan", "client":%{public, location:escape_only}s}
Not recording or localizing since we're not enabled
CLMicroLocationLogic: startRecordingOrLocalizingIfAppropriate Recording parameters: localize: %d, record: %d
{"msg%{public}.0s":"CLMicroLocationLogic::startRecordingOrLocalizingIfAppropriate", "request":%{public}d, "will start recording":%{public}hhd, "reason":%{public, location:escape_only}s, "will start localizing":%{public}hhd, "reason":%{public, location:escape_only}s}
Localization started
{"msg%{public}.0s":"CLMicroLocationLogic: stopLocalizing minimum number of measurments for fingerprint is not met, localization time extended", "Num measurments":%{public}lu, "Minimum num of measurments for fingerprint":%{public}lu, "Localizing counter":%{public}lu, "Maximum localization increments":%{public}lu}
Localization stopped
Popped a queued recording trigger
Recording started
Read BLE spyscan buffer in Logic!. read %lu measruements
{"msg%{public}.0s":"BLE cached scan", "rssi":%{private}d, "uuid":%{private, location:escape_only}s, "model":%{private, location:escape_only}s, "age":%{private}d}
uwb cached scan, read %{public}lu measurements
meas index: %{public}d, deviceId: %{private}s, range: %{private}f, age: %{public}f
Recording stopped
{"msg%{public}.0s":"Should not be stopping recording in this state", "state":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Asking for HomeKit scan type in incorrect state", "state":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Model Type %{private}d disabled in settings
BLE spyscan session already running
Start BLE spyscan session
Stopping BLE spyscan session
BLE spyscan session already stopped
Rapport, rapport session already running
Rapport, start rapport session
Rapport, stopping rapport session
Rapport, rapport session already stopped
Already spectating
Start spectating
Not enabled, stop spectating
Not enabled, will not start spectating
No model types supported in state %{public}s, stop spectating
No model types supported in state %{public}s, will not start spectating
Spectating enabled and no model loaded yet. Trying to reload the model
Spectating disabled and has model loaded. Trying to purge the model
updateModelsInMemory, no need to update models, ignore
ranging session already running
start a ranging session
stop a ranging session
ranging session already stopped
Not enabled
No model type supported in state %{public}s
{"msg%{public}.0s":"Ingested spyscan BLE beacon", "rssi":%{public}d, "model":%{private, location:escape_only}s, "resolving valid":%{public}hhd, "number of ingested scans":%{public}lu}
{"msg%{public}.0s":"Should not be starting a recording in this state", "state":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Got request to reset Location data. Dropping microlocation tables
{"msg%{public}.0s":"batterylevel", "level":"%{private}f", "charged":%{private}d, "connected":%{private}d, "chargerType":%{private}d, "wasConnected":%{private}d, "isNewlyConnected":%{private}d}
{"msg%{public}.0s":"appLaunch", "bundleId":%{private, location:escape_only}s, "launchReason":%{public, location:escape_only}s, "isLongFormVideo":%{public}hhd}
Force Recording received
First Wake of Day received
{"msg%{public}.0s":"HomeKit Scene", "actionSetUUID":%{private, location:escape_only}s, "actionSetName":%{private, location:escape_only}s, "actionSetType":%{private, location:escape_only}s, "clientName":%{private, location:escape_only}s, "source":%{private, location:escape_only}s, "homeName":%{private, location:escape_only}s, "triggerLocalization":%{private}hhd, "triggerRecording":%{private}hhd}
{"msg%{public}.0s":"HomeKit Accessory", "accessoryUUID":%{private, location:escape_only}s, "accessoryState":%{private, location:escape_only}s, "serviceUUID":%{private, location:escape_only}s, "serviceGroupUUID":%{private, location:escape_only}s, "serviceType":%{private, location:escape_only}s, "characteristicType":%{private, location:escape_only}s, "source":%{private, location:escape_only}s, "roomUUID":%{private, location:escape_only}s, "triggerLocalization":%{private}hhd, "triggerRecording":%{private}hhd}
{"msg%{public}.0s":"Now Playing", "bundleId":%{private, location:escape_only}s, "status":%{public}d, "track":%{private, location:escape_only}s, "outputDeviceIDs":%{private, location:escape_only}s}
Display state on received
Display state off received
Models have been regenerated. Telling localizer to refresh model
onModelGenerated, told to refresh model, ignore, no model loaded yet
Localizer results,%{private}s
Don't have a current wifi channel histogram for this LOI type %{private}s
Reloaded wifi channel histogram
{"msg%{public}.0s":"Wifi channel histogram:", "Histogram":%{private, location:escape_only}s}
Enabled state: microlocations defaults enabled: %{public}d; location services enabled: %{public}d; significant locations enabled: %{public}d; overall enabled: %{public}d
MicroLocations have been disabled. Clients will no longer get notifications until we are enabled again.
MicroLocations are now re-enabled. Clients should begin getting notifications again
Keybag is unlocked. Possibly will update in memory models
Setting all UWB measurements as ignored since NI, Session is not resumed for long enough
{"msg%{public}.0s":"CFType must be a CFBoolean to convert to a bool", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"AppleTV detected", "rssi":%{private}d, "uuid":%{private, location:escape_only}s, "ipv4":%{private, location:escape_only}s, "channel":%{private}d}
{"msg%{public}.0s":"HomeKit accessory detected", "timestamp":"%{private}f", "truncatedUUID":%{private, location:escape_only}s, "rssi":%{private}d, "category":%{private}d}
Initialize EventsBuffer
Initialize EventsBuffer %s
EventsBuffer %s: size before truncation %lu
{"msg%{public}.0s":"json string is invalid", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Microlocation error report: %s
Microlocation error report: %@
Allowed Anchors, fingerprint configuration updated from vector
Allowed Anchors, fingerprint configuration not updated since setting is disabled
#Warning The protobuf fingerprint does not have a valid recording uuid
{"msg%{public}.0s":"number of measurements still exceeds maximum", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"This fingerprint does not have any measurements, you have probably done something wrong", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Minimum scan time difference must be less than the maximum", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"No Recording Events provided", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
A measurement's recording UUID does not have a corresponding event entry
{"msg%{public}.0s":"fingerprintVector size is not either zero or one", "size":%{public}llu, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Sucessfully created table if necessary: %{private}s
Failed to bind on INSERT OR REPLACE with sql %{private}s
#Warning Table is not valid so we can't select all LOIs
{"msg%{public}.0s":"No event types passed in", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Data source cancelled learning
{"msg%{public}.0s":"Rapport, rapport monitor exceeded max entries", "IDS":%{private, location:escape_only}s, "Size":%{private}lu}
{"msg%{public}.0s":"Rapport, buffered a found device", "Device IDS identifier":%{private, location:escape_only}s, "CoreRoutine LOI Type":%{public, location:escape_only}s}
{"msg%{public}.0s":"Rapport, rapport monitor buffered bad IDS UUID", "IDS":%{private, location:escape_only}s}
{"msg%{public}.0s":"Rapport, rapport monitor read bad IDS UUID from DB"}
{"msg%{public}.0s":"RapportMonitor getDevicesSinceLearnEventTime", "Backup Entries":%{public}lu, "From time":%{public, location:escape_only}s, "Total number of devices":%{public}lu}
{"msg%{public}.0s":"Rapport, rapport monitor buffered invalid UUID IDS identifier", "IDS Identifier":%{private, location:escape_only}s}
{"msg%{public}.0s":"Rapport, back up rapport monitor data to DB", "Num Entries":%{public}lu}
{"msg%{public}.0s":"Allowed Anchors, New anchor enabled", "Device ID":%{private, location:escape_only}s, "Data Type":%{public}lu, "First seen":%{public}lu}
{"msg%{public}.0s":"Allowed Anchors, anchor removed", "Device ID":%{private, location:escape_only}s, "Data Type":%{public}lu, "Last seen":%{public}lu}
#Warning The protobuf Anchor Appearance struct does not have a valid device ID
{"msg%{public}.0s":"updateSeenAnchors", "Anchors map initial size":%{private}lu, "Received daily IDS ID set size":%{private}lu, "Size with new anchors":%{private}lu, "Size after purging":%{private}lu, "Size after max entries limit":%{private}lu}
#Warning Database is not connected so we can't intialize our table
Failed to create table: %{public}s
Sucessfully created table if necessary: %{public}s
#Warning Table is not valid so we can't insert or replace
Failed to bind on INSERT OR REPLACE for sql %{private}s
Failed to execute statement. %{private}s
#Warning Table is not valid so we can't select all
#Warning Table is not valid so we can't get the most recent model
{"msg%{public}.0s":"Expecting some UUIDs to be passed in", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning Table is not valid so we can't deleteUnneededModels()
Keeping %{public}d models per model type
#Warning Table is not valid so we can't deleteOldestRows
Error converting database values. %{public}s
WRTT: rangeThreshold %{private}f resulted in 0 unlock probability, not unlocking
WRTT: Range %{private}f resulted in 0 unlock probability, skipping range
{"msg%{public}.0s":"WRTT: CLHistogramHypothesisTestUnlockEstimator result", "logRatio":"%{public}f", "scaledLogRatioThreshold":"%{public}f"}
Measurement %{private}f outside of histogram range
WRTT: Estimating shouldUnlock with unlockThreshold: %f
WRTT: Unexpected hardware %{public}d in getUnlockThreshold
WRTT, Using CLHistogramHypothesisTestUnlockEstimator with phone unlock histograms
WRTT, Received DeviceType iPhone in CLMacPeerRangingDecisionProcessor
WRTT, Target does NOT require range correction. Target Type: %u
WRTT, Target requires range correction. Target Type: %u
Starting up CLPredictedWalkDistanceServiceCompanion
%{public}s: Registering XPC Activity with nextEstimateTime=(%{public}.2f) and delay=(%{public}lld)
XPC_CHECK_IN: Setting up %{public}s activity with a delay of %{public}lld seconds
Aggregating bout records
Preparing to make weekly 6MWD prediction
Estimate should not be made now. %{public}s is in the future (%{public}.2f). Resetting!
Bout query failed due to device lock
Retrieved %{public}lu bout records
Retrieved demographics: age=%{private}.0f, height=%{private}.2f, weight=%{private}.1f
No remote StepCadenceToStrideLength table, error:%s
Parsing remote StepCadenceToStrideLength table
No StepCadenceToStrideLength table, error:%{public}s
Parsing StepCadenceToStrideLength table
WalkingSpeedCal query failed due to device lock
Retrieved %{public}lu walkingSpeedCal records
HealthKit queries from %{public}.0f to %{public}.0f
HealthKit Activity Summary query failed due to device lock
HealthKit Activity Summary query encountered error,%{public}ld
Retrieved activity summary... startDate: %{private}@, endDate: %{private}@, Flights climbed: %{private}f, Step count: %{private}f, Exercise minutes: %{private}f
HealthKit Workout query failed due to device lock
HealthKit Workout query encountered error,%{public}ld
Found workout... Type: %{private}lu, indoor: %{private}d, startTime: %{private}f, endTime: %{private}f
HealthKit Stand Hour query failed due to device lock
HealthKit Stand Hour query encountered error,%{public}ld
Retrieved sample... Stand hour: %{private}f, startTime: %{private}@, endTime: %{private}@
HealthKit Flights query failed due to device lock
HealthKit Flights query encountered error,%{public}ld
Retrieved sample... Flights climbed: %{private}f, startDate: %{private}@, endDate: %{private}@ from %{private}@
Flights from series 4 watch observed, consider only phone flights
Attempting to defer activity
Failed to mark activity as deferred. Current state is %{public}ld
At least one required query failed due to device lock. Rescheduling the activity to try again soon.
Hours for day %{private}f - %{private}f, %f (%f)
Using cadenceStrideLengthOffset of %{private}.3f
p6MWD lastResetTime, %f
Weekly p6MWD estimate unavailable, status %{public}d
Failed to mark %{public}s activity as Done. Current state is %{public}ld
Writing predicted 6MWD to HealthKit, startTime: %{public}f, endTime: %{public}f, prediction: %{private}f, calibrationStatus: %{private}d, earliestTimeUsed: %{private}f
saveObjects failed to insert a 6MWD sample, error, %{public}@
saveObjects successfully pushed 6MWD update
Received message in CLPredictedWalkDistanceServiceCompanion
Received bout from watch...,startTime,%{private}f,endTime,%{private}f
Gait Metrics unavailable, likely because device is locked.
CLPredictedWalkDistanceServiceCompanion: Received user info update
#Warning Unhandled notification type, %d
Not sending analytics, no IHA permission
Prediction history query failed due to device lock
Prediction history query encountered error,%{public}ld
initialized down,%u,q.x,%f,q.y,%f,q.z,%f,q.w,%f, withAvgGrav, %d
initializeState MaxInitialDiffUnity failed,magnitude,%f
initializeState northAndGravity failed
invalid initial covariance !(P > 0), using default
invalid quiescentState kInMotion, ignoring quiescent
Assertion failed: i < size(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 45,out of buffer range %zu.
TileMgr, coarse, Timer allocation failure, #CloneMe
CL: CLCoarseCellTilesManager::onClientNotification
{"msg%{public}.0s":"CLCoarseCellTilesManager::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCoarseCellTilesManager::onDataProtectionNotification
{"msg%{public}.0s":"CLCoarseCellTilesManager::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCoarseCellTilesManager::onCompanionNotification
{"msg%{public}.0s":"CLCoarseCellTilesManager::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCoarseCellTilesManager::onStatusNotification
{"msg%{public}.0s":"CLCoarseCellTilesManager::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Error in numberOfMeasurements,%zu
Error in rangeIndex calculation, rangeIndex,%d
Error in index calculation, tableIndex,%d
HRStop detect in indoor cycle model during state,%{public}d
IndoorCycleStop,state,%d,headingCnt,%d,longStd,%f,shortStd,%f,exertionDelta,%f,exertionLow,%d,vm,%f,fromBaseline,%f,inLikely,%d,steps,%d,combinedCnt,%d,deltaH,%f
Walk, WorkRate, %f, distance(m), %f, duration(s), %f, userMets, %f, fMetsScaling, %f, endTime, %f, currentPace, %f, isStroller, %d, userMetsStrollerCorrected, %f, truthMets, %f, truthMetsStrollerCorrected, %f
Walk, WorkRate, Grade type, %d, vertical speed %f, interval %f, workrate %f, userMets %f, userMets + grade, %f, percent grade, %f, truthMets, %f, truthMets + grade, %f
Walk,fitness machine,computeTime,%.3f,startTime,%.3f,wr,%f,vertSpeed,%f,userMets,%f,truthMets,%f
Historical-Distributions, loiUuid, %s, style, %d, poolLength, %f, median, %f, mean, %f, stddev, %f, min, %f, max, %f, samples, %d, prctile10, %f, prctile90, %f, uuid, %s
Historical median turns per session, median, %f, Nsessions, %lu
Did not successfully load state from db! CMError, %d
Set first session entry
Cannot yet set first swim session entry
{"msg%{public}.0s":"Invalid pool length update."}
{"msg%{public}.0s":"Unsupported mid-session location change", "old":%{public}ld, "new":%{public}ld}
{"msg%{public}.0s":"Unexpected mid-session pool length change", "old":"%{public}f", "new":"%{public}f"}
{"msg%{public}.0s":"Unexpected lap counts, skipping in-memory laps.", "persisted laps":%{public}d, "in-memory laps":%{public}d}
Got %d swimming LOIs.
Checking swimming LOI with id '%s'.
Found swimming distributions for LOI with id '%s'.
Deferring lap persistence.
Failure to store lap due to database inaccessibility.
Failure to store lap due to time rollback, startTime, %f, > endTime, %f
@GtsSync, Unexpected change type, %{public}ld, set, #CloneMe
@GtsSync, CsSerial, dataFromChange, isKind, %{public}d
@GtsWarn, GizmoSync, changeFromData, %ld, #CloneMe
@GtsFlow, CS, startSession, 2, timeout, %{public}.0f
@GtsFlow, CS, endSession, 6
@GtsSync, CsService, serviceDidPairDevice, state, %{public}c
@GtsSync, CsService, serviceDidUnpairDevice, state, %{public}c
@GtsSync, CsError, 2, service, %{public}s, underlying, %{public}s
@GtsSync, CsSession, enqueue failed
@GtsFlow, CS, enqueueComplete, 4
@GtsSync, CsSession, applyChanges, %{public}lu
@GtsSync, CsSession, More than 1 incoming change, %{public}lu, #CloneMe
@GtsSync, CsError, 0, didEndWithError, %{public}s, underlying, %{public}s
@GtsFlow, CS, sessionDidEnd, 5, error, %{public}d, synctrap, %{public}d
@GtsFlow, PS, syncDidCompleteTx, 2
@GtsSync, CsSession, resetDataStoreWithError
@GtsSync, CsService, willSwitchPairing, old, %{public}s, new, %{public}s
@GtsSync, CsService, didSwitchPairing, old, %{public}s, new, %{public}s
@GtsSync, PsCoord, beginSyncSession, %{public}lu
@GtsFlow, PS, handleSyncTrapTurn%s, 1
@GtsFlow, PS, syncDidCompleteTx, 2, skipped
@GtsSync, PsCoord, didInvalidateSyncSession, %{public}d
@GtsFlow, PS, didInvalidateSession, 3, restriction, %{public}d
@GtsSync, PsCoord, syncCoordinatorDidChangeSyncRestriction, %{public}d
@GtsSync, PsCoord, RestrictionUnknown, %{public}ld, #CloneMe
@GtsSync, PsObserver, initialSyncDidCompleteForPairingID
@GtsSync, PsObserver, syncDidCompleteForPairingID
@GtsFlow, PS, syncDidCompleteRx, 4
@GtsSync, PsObserver, syncDidResetForPairingID
@GtsSync, PsObserver, initialSyncStateObserverClientCanRetryFailedRequests
@GtsAwd, plist, error, load, %{public}lu
@GtsAwd, plist, clear, %{public}.1f, thresh, %{public}.0f, last, %{public}.1f
@GtsAwd, plist, error, time, %{public}.1f, now, %.1f
@GtsAwd, started, %{public}d
@GtsAwd, request, tiles, %{public}d, total, %{public}d, sessions, %{public}d
@GtsAwd, serialized, %{public}d, totalmb, %{public}.1f
@GtsAwd, snap, %{public}s, sessions, %{public}d, empty, %{public}d, completed, %{public}d, errored, %{public}d, requested, %{public}d, synced, %{public}d, sizemb, %{public}.1f, week, %{public}d, %{public}.1f, sinceweekly, %{public}0.1f, reset, %{public}d, lastSave, %{public}0.1f, %{public}0.1f
{"msg%{public}.0s":"Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
@GtsInit, CG, %{public}d, %{public}d, rate, %{public}0.0f, state, %{public}d, %{public}d, %{public}c, canDownload, %{public}d
@GtsTimer, fired, %{public}s
@GtsMgr, dtor
@GtsInit, PsObjects failed, C, %{public}d, O, %{public}d
@GtsInit, CsObjects failed
@GtsMgr, release
@GtsSync, CsError, 1, resume, %{public}s
@GtsMgr, xSyncTrap, canDownload
@GtsSync, since last switched, hours, %{public}0.1f, days, %{public}0.1f
@GtsMgr, xSyncTrap, days inactive, %{public}0.1f, thresh, %{public}0.1f, pending, %{public}d
@GtsFlow, CS, setNeedsReset, 1, BeginPair, state, %{public}c, %{public}c, queuewas, %{public}ld, inactive, %{public}0.1f
@GtsSync, PsCoord, RestrictionLimitPush
@GtsSync, PsCoord, RestrictionNone
@GtsMgr, restriction, state was, %{public}c, now, %{public}c, restricted, %{public}d
@GtsWarn, GizmoSync, handleStartSession, #CloneMe
@GtsMgr, Mismatching keys, syncId, %{public}s, request, %{public}s
@GtsMgr, Crossing sessions, %{public}c, #CloneMe
@GtsManif, CompTx, %{public}ld
@GtsMgr, Unexpected Companion startSession flow, type, %{public}c, #CloneMe
@GtsSync, CsService, startSession, %{public}c, mdin, %{public}ld, queue, %{public}ld, mdout, %{public}ld
@GtsMgr, handleSessionDidEnd, error, %{public}d, %{public}d, change, %{public}c, pending, %{public}d, psActive, %{public}d, syncState, %{public}c, queue, %{public}ld, exchanged, %{public}d
@GtsManif, CompRx, %{public}ld, queue, %{public}lu, metadata
@GtsManif, BadId, enqueueC, %{private}s, #CloneMe
Assert Failed, %s, %d, %s
@GtsManif, CompReply, %{private}s, have, %{public}d
@GtsFlow, CS, metadataX, 3
@GtsFlow, CS, enqueueChanges, 3, Manifest, %{public}c
@GtsFlow, CS, enqueueChanges, 3, TileData, %{public}c, queue, %{public}ld
@GtsSync, CsSession, %{public}c, llsw, %{private}.2lf, %{private}.2lf, queue, %{public}ld
@GtsFlow, CS, enqueueChanges, 3, SyncTrap
@GtsFlow, CS, enqueueChanges, 3, Unexpected change type, %{public}c
@GtsSync, enqueue return, change, %{public}d, complete, %{public}d, large, %{public}d
@GtsWarn, GizmoSync, handleApplyChanges, #CloneMe
@GtsMgr, change, syncId, %{public}s, type, %{public}ld
@GtsCont, change with no data!!!
@GtsMgr, SyncTrapEnd, oldstate, %{public}c
@GtsMgr, willSwitch, new, %{public}s, days inactive, %{public}0.1f
@GtsMgr, handlePairSwitch, ids ,%{public}d, %{public}d, resume/suspend, %{public}c, state, %{public}c, %{public}c, restricted, %{public}d, inactive, %{public}0.1f
@GtsSync, CsSync, handleServiceError, %{public}c
@GtsGiz, reclearing
@GtsMgr, Nearby, queue, %{public}lu, sessionErrors, %{public}d
@GtsCont, ToggleReset, %{public}d, queuewas, %{public}ld
@GtsGiz, reclear pending
@GtsCont, %{public}s, llsw, %{private}.2lf, %{private}.2lf
@GtsPair, skipevent, add, blocking sync state, %{public}c
@GtsCont, replaceadd, llsw, %{private}.2lf, %{private}.2lf, size, %{public}ld
@GtsCont, add, llsw, %{private}.2lf, %{private}.2lf, size, %{public}ld, current, {public}%d
@GtsTimer, direct, skip
@GtsTimer, nextfire, %{public}.0f, %{public}s, state, %{public}c
@GtsManif, return, not companion
@GtsManif, skip, direct
@GtsManif, check, %{public}s, state, %{public}d, %{public}c, %{public}lu, sync, %{public}lu
@GtsManif, skip, %{public}s, state, %{public}d, sync, %{public}d
@GtsFlow, CS, setHasChanges, 1, SendManifest
@GtsManif, PrepTx, %{public}s, tiles, %{public}lu, %d, currentOnly, %{public}d
@GtsManif, entry, %{private}s, gentime, %{public}.1f
@GtsCont, addlost, llsw, %{private}.2lf, %{private}.2lf
Unable to send #tile, it is missing
@GtsComp, add, llsw, %{private}.2lf, %{private}.2lf, tile_x, %{private}d, tile_y, %{private}d, tilesize, %{public}ld, queue, %{public}lu
@GtsLock, drop add on LS off
@GtsSync, drop older add, timestamp, %{public}0.1f, toggle/reset, %{public}0.1f
@GtsError, Adding non-Wifi tile, %{public}d, #CloneMe
Failed writing tile to file, %{private}s
@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, sync, size, %{public}lu, unprot size, %{public}lu
@GtsLock, add, llsw, %{private}.2lf, %{private}.2lf, mapsize, %{public}ld
os_transaction created: (%p) %@
os_transaction releasing: (%p) %@
{"msg%{public}.0s":"#Stream Changing state", "new state":%{public, location:CLStreamingAwareLocationProviderLocalGPSStateMachine::LocationSourceState}lld, "old state":%{public, location:CLStreamingAwareLocationProviderLocalGPSStateMachine::LocationSourceState}lld}
{"msg%{public}.0s":"#Stream Cannot set workout state when overall source state isn't Workout.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Stream Changing workout state", "new state":%{public, location:CLStreamingAwareLocationProviderLocalGPSStateMachine::WorkoutState}lld, "old state":%{public, location:CLStreamingAwareLocationProviderLocalGPSStateMachine::WorkoutState}lld}
{"msg%{public}.0s":"#Stream Clearing motion sample data"}
{"msg%{public}.0s":"#Stream Setting motion alarm state", "enabled":%{public}d}
{"msg%{public}.0s":"#Stream Starting providers", "state":%{public, location:CLStreamingAwareLocationProviderLocalGPSStateMachine::LocationSourceState}lld, "workoutState":%{public, location:CLStreamingAwareLocationProviderLocalGPSStateMachine::WorkoutState}lld, "workoutForceGPSOn":%{public}hhd}
{"msg%{public}.0s":"#Stream Determining state", "current state":%{public, location:CLStreamingAwareLocationProviderLocalGPSStateMachine::LocationSourceState}lld}
{"msg%{public}.0s":"#Stream Received motion rich location notification", "source":%{public, location:CLStreamingAwareLocationProviderStateMachine::LocationSource}lld, "notification":%{public, location:CLLocationProvider_Type::Notification}lld, "motion data":%{public, location:CLLocationProvider_Type::MotionDetected}lld, "timestamp":"%{public}f"}
{"msg%{public}.0s":"#Stream Workout change", "currentWorkout":%{public}ld, "workoutStarted":%{public}hhd}
{"msg%{public}.0s":"#Stream Motion alarm fired", "detected motion":%{public, location:CLLocationProvider_Type::MotionDetected}lld}
{"msg%{public}.0s":"#Stream This function must only be called in workout scenarios.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Stream In pedestrian workout, Motion compatible?", "remote motion":%{public, location:CLLocationProvider_Type::MotionDetected}lld, "sample time_s":"%{public}.09f", "now_s":"%{public}.09f", "prefer remote":%{public}hhd, "prefer local":%{public}hhd}
{"msg%{public}.0s":"#Stream Scheduling timer for motion confidence", "now_s":"%{public}.09f", "fire time_s":"%{public}.09f", "delta_s":"%{public}.09f"}
{"msg%{public}.0s":"#Stream Reconsidering forced GPS state"}
{"msg%{public}.0s":"#Stream Reconsidering motion compatibility"}
CLHealthAssessmentNotifier starting up
Loaded monitoring period start: %{public}f expiration date: %{public}f
Resume sensor recording on service start
fSensorRecorderQueryTimer.nextFireTime, %{public}f
Tearing down service
Subscribing to Sensor Recorder: Accel Rate %{public}d Gyro Rate %{public}d
Unable to set sample rate for accel to %{public}d.
Unable to set sample rate for gyro to %{public}d.
fSensorRecorderSubscribeTimer.nextFireTime, %{public}f
Stop renewing sensorRecorder subscription
Remaining duration to process = %{public}lf
Processed data up to max duration = %{public}lf, endTime = %{public}lf, total duration processed = %{public}lf
DB not accessible, cannot process data
Updating start time to %{public}f based on last processed time
No processing to do, remainingDurationToProcess=%{public}f, endTime=%{public}f, updateStartTime=%{public}f
No valid period, marking up to %{public}f as processed
Requesting sensorRecorder data from %{public}f to %{public}f
Received accel data
Received gyro data
No new records from sensorRecorder, advancing startUpdateTime from %{public}f to %{public}f
No new records from sensorRecorder, updateStartTime is up to date (%{public}f)
New records read, accel = %{public}d, gyro = %{public}d, duration processed = %{public}lf
Updated monitoring period to %{public}f - %{public}f
Stop monitoring, set period to %{public}f - %{public}f
fAggregateRecordsTimer.nextFireTime, %{public}f
Closing down CLHealthAssessmentNotifier, past timeout period for stored data
Skipping partially empty period, saw %{public}.1f of %{public}.1f epochs in period
WARNING: DB not accessible, results for period from %{public}f to %{public}f may be lost.
Persisting result for period ending %{public}f
Add new monitoring period %{public}f - %{public}f
Extend existing monitoring period %{public}f - %{public}f
Aggregating records for fParkinsonsResultPersistence
Checking from %{public}.2f
No valid monitoring periods seen
Selecting monitoring period: %{public}f - %{public}f
Found two consecutive onWrist events, skipping later one
Full on wrist period seen, %{public}0.f - %{public}0.f
No valid on wrist periods seen
Valid period returned, %{public}0.f - %{public}0.f
Watch wrist state updated,onwrist,%{public}d
CL: CLHealthAssessmentNotifier::onWatchOrientationSettingsNotification
{"msg%{public}.0s":"CLHealthAssessmentNotifier::onWatchOrientationSettingsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Programmer error, this expiration rule with time %{public}fis not valid.
{"msg%{public}.0s":"CL database error, record contains invalid time", "invalid time":%{public}d, "name":%{public, location:escape_only}s}
Maximum number of entries exceeded, throwing out oldest entry.
Aggregating records start %f, count ~%d
Aggregating records stop %f, count ~%d
#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d
#Warning No expiration rule was added so the number of records will be unbounded.
{"msg%{public}.0s":"CL database error", "CFAbsoluteTimeGetCurrent":%{public}d}
%{public}s; client %{public}d does not exist
Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly
{"msg%{public}.0s":"The total size of the POD types on the 2 architectures is expected to be the same.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
%{public}s; notification %{public}s not found
CL: notifyClientsWithData (Fallback)
{"msg%{public}.0s":"notifyClientsWithData", "event":%{public, location:escape_only}s, "name":%{public, location:escape_only}s, "notification":%{public}lld}
%s; client %d has deregistered, not notifying %s
%{public}s; unknown client %{public}d
%s; already shutdown; not listing clients
%s; listing clients, num clients: %zu
%s; clients, id: %d, notification: %d
{"msg%{public}.0s":"MaxMETs,Empty MET minutes input."}
{"msg%{public}.0s":"MaxMETs,Invalid MET minute input.", "MRU time_s":"%{private}.09f", "Input time_s":"%{private}.09f"}
{"msg%{public}.0s":"MaxMETs,Invalid MET minute input.", "MET Minute time_s":"%{private}.09f", "MET value":%{private}d}
{"msg%{public}.0s":"Processed mets values", "count":%{private}d, "index":%{private}d, "mets value":"%{private}f", "start time_s":"%{private}.09f", "end time_s":"%{private}.09f"}
{"msg%{public}.0s":"MaxMETs,Invalid MET minute table", "table size":%{private}ld, "compute time_s":"%{private}.09f"}
{"msg%{public}.0s":"MaxMETs,Failed to persist MET minutes stats"}
{"msg%{public}.0s":"MaxMETs,Failed to persist MET minutes stats compute time"}
{"msg%{public}.0s":"MaxMETs,Failed to receive correct MET minutes from plist."}
{"msg%{public}.0s":"MaxMETs,Failed to receive correct MET minutes stats compute time."}
{"msg%{public}.0s":"#Stream Refreshing location request"}
{"msg%{public}.0s":"#Stream Unexpected registration", "notification":%{public, location:CLLocationProvider_Type::Notification}lld, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Streamed,timestamp,%.3lf,timestampGps,%.3lf,odometer,%.3lf,deltaDist,%.3lf,deltaDistUnc,%.3lf,lat,%.8lf,lon,%.8lf,hunc,%.3lf,alt,%.3lf,vunc,%.3lf,speed,%.3lf,sunc,%.3lf,course,%.3lf,cunc,%.3lf
{"msg%{public}.0s":"#Stream #Multiclient attempting to create retry discovery timer while another one still exists"}
{"msg%{public}.0s":"#Multiclient registering a server", "effectiveID":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient failed to find any already-discovered device with ID", "id":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Stream #Multiclient looking for candidate streaming sources"}
{"msg%{public}.0s":"#Multiclient candidate device", "deviceID":%{public, location:escape_only}s, "hasGPS?":%{public}hhd, "isIphone":%{public}hhd, "isIpad":%{public}hhd}
{"msg%{public}.0s":"#Multiclient selected an iPhone", "deviceID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient selected an iPad", "deviceID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient selected a non-iOS device", "deviceID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream #Multiclient failed to find any usable device, retrying", "nextFireInterval":"%{public}f"}
{"msg%{public}.0s":"#Stream #Multiclient want to get best possible accuracy, and will request from nearby devices"}
{"msg%{public}.0s":"#Stream #Multiclient no longer need to stream because granularity no longer Best"}
{"msg%{public}.0s":"#Stream Changing requested granularity", "granularity":%{public, location:CLLocationStreamingGranularity}lld}
{"msg%{public}.0s":"#Stream #Multiclient failed to send streaming action event", "error":%{public, location:escape_only}@, "resp":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Stream #Multiclient action OK", "action":%{public, location:CLLocationMultiStreamingAction}lld}
{"msg%{public}.0s":"#Stream #Multiclient unexpected action returned in response to request", "action":%{public, location:CLLocationMultiStreamingAction}lld}
{"msg%{public}.0s":"#Multiclient attempting to re-register streaming link, but we already have one"}
{"msg%{public}.0s":"#Multiclient must pass a non-nil target device", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient invalidating server streaming link"}
{"msg%{public}.0s":"#Multiclient failed to activate streaming link", "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Multiclient streaming client good to go!", "remoteID":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient got a location from our client!", "message":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Stream Missing data", "payload":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Stream Dropping expired location", "timestamp":"%{public}f", "lifespan":"%{public}f"}
{"msg%{public}.0s":"#Stream Assertion count must be non-negative", "count":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Stream Client took disablement assertion", "before change":%{public}d}
{"msg%{public}.0s":"#Stream Assertion count must be positive", "count":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Stream Client released disablement assertion", "before change":%{public}d}
{"msg%{public}.0s":"#Stream Client took emergency enablement assertion", "before change":%{public}d}
{"msg%{public}.0s":"#Stream Client released emergency enablement assertion", "before change":%{public}d}
{"msg%{public}.0s":"Must be overridden", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient listener found nearby device", "model":%{public, location:escape_only}s, "name":%{private, location:escape_only}s, "effectiveID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient listener lost contact with nearby device", "model":%{public, location:escape_only}s, "name":%{private, location:escape_only}s, "effectiveID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient failed to setup nearby device listener", "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Multiclient nearby device listener ready"}
{"msg%{public}.0s":"#Stream #Multiclient found an active device with effective ID", "effectiveID":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient probe client failed to register"}
{"msg%{public}.0s":"#Multiclient probing potential server", "remote":%{public, location:escape_only}s, "name":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient error invoking interest request", "error":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient received availability response", "name":%{private, location:escape_only}s, "remote":%{public, location:escape_only}s, "resp":%{public, location:escape_only}@}
Size mismatch between encoded (%zu) and decoded (%zu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly
#VerifyHost result,%{private}u
#Warning No pinning rule for host %{private}s
#Warning Empty pinning rule for host %{private}s
{"msg%{public}.0s":"Unable to create a security policy", "host":%{public, location:escape_only}s, "leafOID":%{public, location:escape_only}s}
Can't SecTrustEvaluate returned the error (%{private}ld) : %{private}@
Not sending escalation event to CoreAnalytics, no IHA permission
Not sending escalation event to CoreAnalytics, invalid escalation time recorded %d
{"msg%{public}.0s":"Sending escalation event to CoreAnalytics", "escType":%{public}d, "workoutType":%{public}d, "workoutLocation":%{public}d, "escTime":%{public}d, "escToWorkout":%{public}d, "pctBackgroundEscalation":%{public}d}
Not sending alert event to CoreAnalytics, no IHA permission
Not sending alert event to CoreAnalytics, invalid escalation time recorded %d
{"msg%{public}.0s":"Sending alert event to CoreAnalytics", "alertWorkoutType":%{public}d, "acceptedWorkoutType":%{public}d, "alertActiveTime":%{public}d, "alertStatus":%{public}d}
Dance,metsWR,%f,metsHR,%f,truthMets,%f,userMets,%f,endTime,%f,danceWrMets,%f,motionIntensity,%d,hrDrift,%f,wrWeight,%f,metsSource,%d,accelZ,%f,vm,%f,hr,%f,hrIntensity,%d,rotationRate,%f
iz,%f,w,%f,cr,%f,weight,%f,height,%f,wr,%f
HRSE,clear AVL status cache
#Warning,HRSE,isTileAvailableBasedOnAvlFile,availability file is not valid,fNeedToDownloadAvlFile,%{public}d
HRSE,isTileAvailableBasedOnAvlFile,Reading,%{public}s
#Error,HRSE,isTileAvailableBasedOnAvlFile,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d
#Warning,HRSE,isTileAvailableBasedOnAvlFile,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d
HRSE,isTileAvailableBasedOnAvlFile,input latitude, %{private}.3lf, below minimum acceptable latitude, %{private}d
HRSE,isTileAvailableBasedOnAvlFile,input latitude, %{private}.3lf, beyond maximum acceptable latitude, %{private}d
#Warning,HRSE,isTileAvailableBasedOnAvlFile,avl byte index,%{public}d,is larger than the data available in the availabilty file,fNeedToDownloadAvlFile,%{public}d
#Warning,HRSE,isTileAvailableBasedOnAvlFile,unable to get data byte,fNeedToDownloadAvlFile,%{public}d
HRSE,isTileAvailableBasedOnAvlFile,unexpected case,fNeedToDownloadAvlFile,%{public}d
HRSE,isTileAvailableBasedOnAvlFile,isTileAvailable,%{public}d,fNeedToDownloadAvlFile,%{public}d
HRSE,checkAvlFileValidityAndSetDownloadFlag,fNeedToDownloadAvlFile,%{public}d
#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file does not exist,fNeedToDownloadAvlFile,%{public}d
HRSE,checkAvlFileValidityAndSetDownloadFlag,Reading,%{public}s
#Error,HRSE,checkAvlFileValidityAndSetDownloadFlag,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d
#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d
#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file version does not match expected,fNeedToDownloadAvlFile,%{public}d
#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file has expired,fNeedToDownloadAvlFile,%{public}d
HRSE,checkAvlFileValidityAndSetDownloadFlag,reached end of function,fNeedToDownloadAvlFile,%{public}d
#Error,HRSE,readAvlHelper,invalid availability file
#Error,HRSE,readAvlHelper,null buffer
#Error,HRSE,readAvlHelper,fseek returned non-zero
#Error,HRSE,readAvlHelper,did not synchronize to tile header_string
#Error,HRSE,readAvlHelper,invalid availability file - header string
#Error,HRSE,readAvlHelper,invalid availability file - invalid header string
#Error,HRSE,readAvlHelper,invalid availability file - version
#Error,HRSE,readAvlHelper,invalid availability file - headerLength
#Error,HRSE,readAvlHelper,invalid availability file - minLat
#Error,HRSE,readAvlHelper,invalid availability file - maxLat
#Error,HRSE,readAvlHelper,invalid availability file - binsize
#Error,HRSE,readAvlHelper,coarse avl file is not 0.05 deg by 0.05 deg,spacing unexpected,%{public}.1f,re-download needed
#Error,HRSE,readAvlHelper,invalid availability file - timestamp
#Error,HRSE,readAvlHelper,invalid availability file - expiration age
#Error,HRSE,readAvlHelper,invalid availability file - data size
#Error,HRSE,readAvlHelper,invalid availability file - crc
HRSE,readAvlHelper,vers,%{private}d,headerLen,%{private}d,minLat,%{private}d,maxLat,%{private}d,binsize,%{private}.7f,timestamp,%{private}.1f,expirationAge,%{private}d,dataSizeBytes,%{private}d,crc,%{private}d
StandPlus,time zone change,clearing everything,old,%d,new,%d
StandPlus,ignoring calorimetry input
StandPlus,maxReached,sedentaryTimer
StandPlus,no hour earned
StandPlus,empty minute buffer,forcing minute from early stand hour,startTime,%{public}f,firedTime,%{public}f
StandPlus,firing stand hour immediately,firedTime,%f
StandPlus,forcing reset from early stand minute,endTime,%{public}f
StandPlus,forcing minute from early stand hour,%{public}f,endTime,%{public}f
StandPlus,no reminder %d,hour earned %d
StandPlus,firing reminder immediately,firedTime,%f
StandPlus,enforced alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d
StandPlus,minuteAdded,startTime,%{public}f,endTime,%{public}f
StandPlus,maxReached,minutes,startTime,%{public}f
Fast path has been initialized,serviceRef,%{public}p
Fast path closed,serviceRef,%{public}p
#Warning Device motion event ref invalid
Bad device motion report,type,%d,size,%lu
Unexpected device motion report type %{public}d, returning
MsgEnabledBitMask is %s
CLActivityLoggerWriter open log file filePath is %s, file is %p.
CLActivityLoggerWriter logData, prepare to log %d bytes
CLActivityLoggerWriter failed to log data: %{public}s
ending metric session (LocationMonitorSession) for %{public}s
iB: ending metric session (BeaconMonitorSession) for %s
{"msg%{public}.0s":"Unable to encode vertices in populateGeographicRegion", "error":%{public, location:escape_only}@}
#Warning Couldn't get value for key %{private}s, %{private}s/%{private}s
{"msg%{public}.0s":"#FenceHandoff Handoff is empty for a handed of region", "fenceName":%{public, location:escape_only}s}
Client %{public}s does not have appropriate entitlement to use significant
Client %{public}s does not have appropriate entitlement to use low power fence
starting metric session (LocationMonitorSession) for %{public}s
Adding geographic fence [%{public}s]/%{public}s/%{private}s
Removing geographic fence [%{public}s]/%{public}s/%{private}s
Client %{public}s does not have appropriate entitlement to monitor while nearby
Adding geographic polygonal fence [%{public}s]/%{public}s/%{private}s
{"msg%{public}.0s":"Unable to get vertices from data in handleRequestRegionMonitoring", "error":%{public, location:escape_only}@}
Number of vertices received invalid, %{public}d, monitoring
Removing geographic polygonal fence [%{public}s]/%{public}s/%{private}s
ending metric session (BeaconMonitorSession) for %s
starting metric session (BeaconMonitorSession) for %s
Invalid beacon region request [%{public}s]/%{public}s/%{public}s.
Client %{public}s does not have the appopriate entitlement to act as an emergency service
#Warning Couldn't get value for key %{private}s, %{public}s/%{private}s
Client %{public}s does not have appropriate entitlement to act as a proxy service to %{public}s
#Warning #FenceHandoff %{public}s does not have the appopriate entitlement for fence handoff service
{"msg%{public}.0s":"#FenceHandoff handleMessageRegionState HandoffTag is empty for handed off region", "fenceName":%{public, location:escape_only}s}
Fence: requesting, %{public}s for, [%s]/%s/%s
Client %{public}s does not have appropriate entitlement to use polygonal regions
Fence: requesting, kCLClientRegionPolygonal for, [%s]/%s/%s
{"msg%{public}.0s":"Unable to get vertices from data in handleMessageRegionState", "error":%{public, location:escape_only}@}
Number of vertices received doesn't match stored, %{public}d, %{public}lu
iB: requesting, kCLClientRegionBeacon for, [%s]/%s/%s
Fence: kNotificationRegionStateRequest, failed to populateGeographicRegion, %s
Fence: received, %s, %s, state, %d, %s
Fence: unknown state, %{public}d
Notifying client of fence %{private}s for %{public}s/%{private}s (location <%{private}+.8f,%{private}+.8f> acc %{public}.2f type %{public}d, sinceLast,%{private}.1f, fence,%{private}d,%{private}d,%{private}d,%{private}d,%{private}d, motion,%{private}d,%{private}d,%{private}d,%{private}d)
Fence: received, kNotificationFenceNotAuthorized
Fence: kNotificationFenceNotAuthorized, failed to populate fence
#Notice Fence: kNotificationFenceNotAuthorized, bundle not authorized for location, %{public}s, fence, %{public}s
Fence: received, kNotificationFenceFailure
#Warning Can't populate fence, %s
#Warning Couldn't populate alternate region
No alternate region available
@iB: Sending kCLConnectionMessageRegionMonitoringError for region,'%{public}s/%{private}s'.
@iB: Sending kCLConnectionMessageRegionMonitoringSetupCompleted for region,'%{public}s/%{private}s'.
@iB: Sending kCLConnectionMessageRegionState for region,'%{public}s/%{private}s'.
@iB: Sending kCLConnectionMessageRegionMonitoring for region,'%{public}s/%{private}s'.
Unsupported region transition state,%{public}d will not be reported.
CL: CLFenceSubscription::onFenceNotification
{"msg%{public}.0s":"CLFenceSubscription::onFenceNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceSubscription::onBTLEFenceNotification
{"msg%{public}.0s":"CLFenceSubscription::onBTLEFenceNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLActivityLogger being constructed.
CLActivityLogger, kNotificationActivityOverride,overrideAction,%d,activity{State,%d,Confidence,%d,MountedState,%d,MountedConfidence,%d,exitState,%d,estExitTime,%f,startTime,%f}
CLActivityLogger,log kNotificationActivityOverride:%s
#Warning CLActivityLogger, Unhandled notification %d
CLActivityLogger, dataCollection setting changed
CL: CLActivityLogger::onFitnessDataCollectionSettingChangedNotification
{"msg%{public}.0s":"CLActivityLogger::onFitnessDataCollectionSettingChangedNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLActivityLogger::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLActivityLogger::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
motion default,%s,set,%d,value,%s
Harvest is not supported in multiuser mode
Harvest is not supported in diagnostics mode
CLHarvesterService is supported, %{public}d
Service attempting to construct monitors without controller
{"msg%{public}.0s":"attempting to construct policies without controller", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"attempting to construct policies without gps monitor", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Service attempting to construct subharvesters without controller
Service attempting to construct subharvesters without gps monitor
Service attempting to construct subharvesters without policies
{"msg%{public}.0s":"Classifier has been set up"}
{"msg%{public}.0s":"flushing archivemanager to disk as result of a darwin notification."}
{"msg%{public}.0s":"-submitSample: called"}
{"msg%{public}.0s":"-fetchStateWithReply: called"}
received connection request
connecting process isn't entitled, they shall not pass %{public}@
%{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}d, %{public}s, %{public}d, %{public}s, %{public}s
SignificantElevation,startTime,%{public}.3f,endTime,%{public}.3f,ascended,%{private}d,descended,%{private}d
Motion calibration system service is disabled.
Unable to retrieve the earliest calorie record. MaxMets will not be calculated.
persistMaxMets - startDayTimestamp: %{public}f, endTime: %{public}f, sevenDaysAgoToReferenceTime: %{public}f
persistMaxMets - Adjusted startDayTimestamp: %{public}f
Fetch of Calorimetry data failed. MaxMets will not be calculated. Error: %{public}u
Fetch of Met Minutes data returned no records. MaxMets will not be calculated.
persistMaxMets - metMinutes.size(): %{public}lu
persistMaxMets - Finished window. sumMets: %f, numRecords: %hu
persistMaxMets - meanMets: %f, maxMetsForDay: %f
Not starting up CLVO2MaxCloudKitManager because it is not enabled
Starting up CLVO2MaxCloudKitManager
Max sessions for each CloudKit upload: %{public}d
Min time between forced fetches from CloudKit if no metadata updates: %{public}f
VO2Max CloudKit daily stats time interval: %{public}f
Shutting down CLVO2MaxCloudKitManager
Attempt to save retrocomputed outputs to CloudKit failed
%{public}s is too far in the future (%{public}.2f). Resetting!
%{public}s: Registering XPC Activity with nextPreprocessingTime=(%{public}.2f) and delay=(%{public}lld)
XPC_CHECK_IN: %{public}s: Overwriting previous delay (%{public}lld) with a new delay of %{public}lld seconds
XPC_CHECK_IN: %{public}s activity already scheduled with a delay of %{public}lld seconds
Failed to mark %{public}s activity as Continue. Current state is %{public}ld
%{public}s: Resetting next activity time to: %{public}.1f
Failed to mark activity as Done. Current state is %{public}ld
Invalid xpc activity.
Unexpected activity state: %ld
Checking for more unsynced local data to upload
No sync engine metadata available, so attempting to upload all local data
Sync engine metadata available, so attempting to upload unsynced local data
Forcing fetch from CloudKit. secondsSinceMetadataUpdate: %{public}f, secondsSinceLastForcedFetch: %{public}f, buffer: %{public}d
Error determining account status: %{public}@
iCloud account is not available, status: %{public}ld
iCloud account for container %{public}@ doesn't support device to device encryption
Error getting user record: %{public}@
iCloud account has changed. Due to testing override, will not delete local VO2Max data but will still delete sync engine metadata.
iCloud account has changed. Deleting sync engine metadata and local VO2Max data.
Will attempt to initialize the sync engine if/after device has been unlocked.
Setting userRecordIDName to %{private}@
Device has been unlocked. Will now initialize the sync engine.
Loaded sync engine metadata, length = %{public}lu
Sync engine fetch complete for output records: %{public}@
Sync engine fetch complete for input records: %{public}@
Creating VO2MaxOutputs zone
Creating VO2MaxInputs zone
Deleting zone with zoneID = %{public}@
Adding sessionId %{public}@ to RecordIDs for sync engine to save to VO2MaxOutputZone
Adding sessionId %{public}@ to RecordIDs for sync engine to save to VO2MaxInputZone
Sync engine uninitialized, so not adding sessionId %{public}@ to RecordIDs for sync engine to save
Hit the max of %{public}d sessions per CloudKit upload. Will check for more data later.
Done adding sessions to sync
Failed to retrieve VO2MaxSessionAttributes for CKRecordID: %{public}@
Failed to decode output record from system fields data: %{public}@
Unable to get output due to device being locked, clearing the sync engine and will try again later.
Completed fetch of output proto; duration: %{public}f
Failed to retrieve VO2MaxSessionAttributes for CKRecord with ID: %{public}@
Saving output metadata %s
Unable to persist fetched output due to device being locked, clearing the sync engine and will try again later.
Completed save of output proto; duration: %{public}f
Failed to decode input record from system fields data: %{public}@
Unable to get input due to device being locked, clearing the sync engine and will try again later.
Completed fetch of input proto; duration: %{public}f
Saving input metadata %s
Unable to persist fetched input due to device being locked, clearing the sync engine and will try again later.
Completed save of input proto; duration: %{public}f
CloudKit provided server record of unexpected type: %{public}@
Expected server record is missing from error after failed record save
CloudKit provided record of unexpected type: %{public}@
Will not attempt to save unexpected zone: %{public}@
Delete reported for unexpected zone: %{public}@
Will not attempt to purge unexpected zone: %{public}@
VO2MaxCloudKitDailyCounts,Not sending analytics, no IHA permission
Attempting to send ids message from watch to phone for VO2Max CloudKit daily stats
Successfully saved CKRecordZone %{public}@
Sync engine reports successful deletion of CKRecordZone with zoneID: %{public}@. Will recreate zone and reupload local data.
Failed to save CKRecordZone: %{public}@, error = %{public}@
Sync engine reports failure to delete CKRecordZone: %{public}@, zoneID = %{public}@. This is unexpected, as we should not be deleting any zones
Sync engine reports that CKRecordZone with identifier %{public}@ changed
Sync engine reports that CKRecordZone with identifier %{public}@ was deleted
Sync engine reports that CKRecordZone with identifier %{public}@ was purged
Sync engine is asking for CKRecord with ID %{public}@
Returning output CKRecord: %@
Returning input CKRecord: %@
RecordID associated with unexpected zone: %{public}@
Sync engine saved CKRecord with CKRecordID %{public}@, record = %{private}@
CloudKit reporting saved record of unexpected type: %{public}@
Sync engine failed to save CKRecord: error domain = %{public}@, code = %{public}ld, error = %{public}@, record = %{private}@
Sync engine deleted CKRecord with CKRecordID %{public}@
Sync engine failed to delete CKRecord: error domain = %{public}@, code = %{public}ld, error = %{public}@, recordID = %{public}@
Sync engine asking if it should fetch changes for %{public}@
Answering sync engine shouldFetchChangesForZone = %{public}d for zone: %{public}@
Sync engine fetched CKRecord with CKRecordID %{public}@, record = %{private}@
Fetched record of unexpected type: %{public}@
Sync engine unexpectedly fetched deletion of CKRecord with CKRecordID %{public}@ of type %{public}@
Received updated metadata from sync engine, length = %{public}lu
Changed from %s to %s:,
#Warning Latest speed is %lf but no information about speed uncertainty
startTime,%f,endTime,%f,numberOfStrokes,%d,strokeType,%d,epochMets,%f,timestamp,%f,speed,%f,metSource,%d,strokeLength,%f,strokeRate,%f,entryStartTime,%f,entryEndTime,%f,distance,%f,scaledMets,%f,historicalTurnsPerSession,%f
***no run loop available***
Changing CLCommon's runloop after it was already established
#Warning Setting CLCommon's runloop after it was already established
CLCommonSetRunLoop, %p
cannot open source file: %{public}s, errno %{public}d
cannot open target file: %{public}s, errno %{public}d
error reading source file: %{public}s
error writing target file: %{public}s
cannot open compression stream: %{public}s, bzerror %{public}d
error writing target file: %{public}s, bzerror: %{public}d
error closing target file: %{public}s, bzerror: %{public}d
CLCommonGzipDecompressFile, can't stat, %{public}s
CLCommonGzipDecompressFile, from, %s, to, %s, size, %llu, cTime, %.1lf, isOK, %d
CLCommonGzipDecompressFile, can't open, file_path_to, %{public}s, errno %{public}d
CLCommonGzipDecompressFile, can't open, file_path_from, %{public}s, errno, %{public}d
CLCommonGzipDecompressFile, error reading source file: %{public}s, errno, %{public}d, read, %{public}d
CLCommonGzipDecompressFile, can't write, %{public}s, errno, %{public}d, write, %{public}zu
CLCommonGzipDecompressFile, from, %s, to, %s, isOK, %d, fileSize, %llu, totalReadBytes, %u, totalWrittenBytes, %u, compression, %.4lf
http date string is converted to timestamp %.3f and adjusted to %.3f by %.3fs RTT (%.3fs diff from systime)
GPS_NETWORK: enabled %d found %d
CLCommonCompareLocationEqualityClient compared two coordinates that were identical other than their reference frames: (%lf, %lf, %d) (%lf, %lf, %d)
{"msg%{public}.0s":"Bundle for LocationdInternalSystemService not marked as SystemService", "bundle":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning CLCommonGetFileTimestamps, failed to stat file, %s, ret, %d
TILE: delete file, %s
TILE: stat, %s, ret, %d, mtime, %lu, ctime, %lu, size, %lld
TILE: unlink, %s, ret, %d
CLCommonSetFileProtectionClass,sFilename==nullptr
CLCommonSetFileProtectionClass,open,errno,%{public}d
#Warning,CLCommonSetFileProtectionClass,%s,oldPc,%{public}d,newPc,%{public}d,ret,%{public}d,errno,%{public}d
CLCommonSetFileProtectionClass,%s,oldPc,%{public}d,newPc,%{public}d,ret,%{public}d
{"msg%{public}.0s":"CLAvengerScanner: downgrading CoexFriendlyAggressiveDiscovery scan"}
HARVEST NAVIGATION SESSION: start navigation session
HARVEST NAVIGATION SESSION: stop navigation session, identifier, %s, duration, %.3f, automtiveActivityDuration, %.3f, isVehicleConnectedDuration, %.3f, gpsDuration, %.3f, proactiveGpsDuration, %.3f, mapsUsed, %d, batteryStates, %lu, beggining, level, %f, charging, %d, end, level, %f, charging, %d
HARVEST NAVIGATION SESSION: start automotive activity
HARVEST NAVIGATION SESSION: stop automotive activity
HARVEST NAVIGATION SESSION: start vehicle connected
HARVEST NAVIGATION SESSION: stop vehicle connected
processed %p %d to (%s)
could not create new mutable dictionary
{"msg%{public}.0s":"could not deserialize property list", "file":%{public, location:escape_only}s}
{"msg%{public}.0s":"file does not exist... clearing", "file":%{public, location:escape_only}s, "error":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning Error reading file", "file":%{public, location:escape_only}s, "error":%{public, location:escape_only}s}
Could not create NSURL for file: %{public}s
Could not write data to disk %{public}s, %{public}s
Could not serialize data for file %{public}s
{"msg%{public}.0s":"Could not serialize data", "file":%{public, location:escape_only}s}
key %{public}s does not have element %{public}d in array of size %{public}ld
key %{public}s does not have element %{public}d in non-array type %{public}lu
Unsupported type at %@:%@ (domain:key)
type IDs do not match for key %{public}s - %{public}lu vs %{public}lu
specified index is out of range for key %{public}s (%{public}d of %{public}ld)
specified index %{public}d not applicable to type %{public}lu for key %{public}s
could not create cf type for key %{public}s
could not create write stream
could not open write stream
could not write data, error code, %{public}ld, error domain, %{public}s
could not create intermediate property list - %{public}ld (%{public}s)
%s = <dictionary (%ld entries)>:
%s = %s
%s = %0.6f
%s = %d
%s = <unhandled value type %lu>
could not get value
type IDs do not match - %{public}lu vs %{public}lu
could not convert to C string
can't convert %{public}u data bytes
#Warning type IDs do not match - %{public}lu
CL: CLMonitorGpsExternal::onGpsNotification
{"msg%{public}.0s":"CLMonitorGpsExternal::onGpsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMonitorGpsExternal::onAccessoryNotification
{"msg%{public}.0s":"CLMonitorGpsExternal::onAccessoryNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"Ignoring new #filedownload request with invalid timeout", "Timeout_s":"%{public}.09f"}
{"msg%{public}.0s":"Ignoring new #filedownload request with invalid src string", "URLString":%{private, location:escape_only}s}
{"msg%{public}.0s":"Ignoring new #filedownload request with invalid src url", "URL":%{private, location:escape_only}@}
{"msg%{public}.0s":"Dropping uncancelled #filedownload to service new request", "OriginalRequest":%{private, location:escape_only}@, "NewRequest":%{private, location:escape_only}@}
{"msg%{public}.0s":"Ignoring new #filedownload request with invalid dst string", "NewRequest":%{private, location:escape_only}@, "LocalFileString":%{private, location:escape_only}s}
{"msg%{public}.0s":"Created task for #filedownload request", "NewRequest":%{private, location:escape_only}@, "LocalFile":%{private, location:escape_only}@}
{"msg%{public}.0s":"Could not create task for #filedownload request", "NewRequest":%{private, location:escape_only}@, "LocalFile":%{private, location:escape_only}@}
{"msg%{public}.0s":"Cancelling task for #filedownload request", "OriginalRequest":%{private, location:escape_only}@}
{"msg%{public}.0s":"Error on #filedownload task completion", "Response":%{private, location:escape_only}@, "LocalFile":%{private, location:escape_only}@, "Error":%{private, location:escape_only}@}
{"msg%{public}.0s":"Protocol error on #filedownload task completion", "Response":%{private, location:escape_only}@, "LocalFile":%{private, location:escape_only}@, "ResultCode":%{private}d}
{"msg%{public}.0s":"#filedownload task completed successfully", "Response":%{private, location:escape_only}@, "LocalFile":%{private, location:escape_only}@}
{"msg%{public}.0s":"Error persisting file for completed #filedownload task", "Response":%{private, location:escape_only}@, "LocalFile":%{private, location:escape_only}@, "LostAndFile":%{private, location:escape_only}@, "TempFile":%{private, location:escape_only}@, "Error":%{private, location:escape_only}@}
PowerLog is not enabled so not writing microlocation metrics
Wrote microlocation metrics to power log: %{private}s
HKHealthStore, health data not available
event has not response
event should not be logged in HK with response %i
{"msg%{public}.0s":"Candidate fall event record", "felt":%{private}hhd, "actionRequested":%{private}hhd}
HKHealthStore, saveObjects failed on, %@
Fall event successfully pushed to HKHealthStore
[SedentaryTimerTriage] SedentaryAlarm, syncgetStartTimerForClient starting timer for client,%{public}@!
[SedentaryTimerTriage] SedentaryAlarm, syncgetStopTimerForClient stopping timer for client,%{public}@!
[SedentaryTimerTriage] SedentaryAlarm, syncgetSedentaryAlarmData with start time,%{public}f!
SedentaryAlarm,Error starting,client,%{public}s,fitness tracking,%{public}d
SedentaryAlarm,Error starting,client,%{public}s,armed,%{public}d
SedentaryAlarm,startDate sent that doesn't align with the wall hour,%f,minuteOffset,%ld,secondOffset,%ld
SedentaryAlarm,START,client,%s,offset,%d,period,%d,reminder,%d,autoReschedule,%d,startDate,%f
SedentaryAlarm,STOP
SedentaryAlarm,STOP,fitness tracking,%d
SedentaryAlarm,InVehicleReminder,now,%.3f,motionStateTime,%.3f
StandPlus,aop alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d
Activity mode from %{public}d to %{public}d
StandPlus, running stand minute estimator
StandPlus, stopping stand minute estimator
StandPlus,bucketStart,%{public}f,bucketEnd,%{public}f,count,%{public}d
HKHealthStore, StandPlus, saveObjects failed on, %{error}@, for startBucket, %{public}f
StandPlus successfully pushed to HKHealthStore, startBucket, %{public}f
StandPlus,warning,time went backward,alreadyLogged,%{public}f,new,%{public}f
StandPlus,warning,attempting to log bad alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d,count,%{public}d,countReset,%{public}d
CL: CLSedentaryTimerNotifier::onFitnessTrackingNotification
{"msg%{public}.0s":"CLSedentaryTimerNotifier::onFitnessTrackingNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSedentaryTimerNotifier::onMotionStateObserverNotification
{"msg%{public}.0s":"CLSedentaryTimerNotifier::onMotionStateObserverNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSedentaryTimerNotifier::onNatalimetryNotification
{"msg%{public}.0s":"CLSedentaryTimerNotifier::onNatalimetryNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"Selecting models", "age":"%{private}f", "gender":%{private}d, "height":"%{private}f", "weight":"%{private}f", "pal":"%{private}f", "vo2max":"%{private}f", "metminpercentile":"%{private}f", "metminCount":%{private}ld, "workout":%{private}ld, "hkWorkout":%{private}ld}
{"msg%{public}.0s":"Model Selector - Picked thresholds based on features", "impactMaxAccelNormAlertThreshold":"%{public}f", "age":"%{private}f", "totalLongLieThreshold":%{private}d, "consecutiveLongLieThreshold":%{private}d, "metminpercentile":"%{private}f", "alertGatingMotionThreshold":"%{private}f", "cyclingImpactMaxAbsYThreshold":"%{private}f", "otherWorkoutQuiescenceThresholdLow":%{private}d, "otherWorkoutQuiescenceThresholdHigh":%{private}d, "otherWorkoutConsecutiveLongLieThreshold":%{private}d, "otherWorkoutShouldCancelAlertOnStepsThreshold":%{private}hhd, "otherWorkoutShouldCancelAlertOnStandThreshold":%{private}hhd, "otherWorkoutShouldCancelAlertOnActiveThreshold":%{private}hhd}
{"msg%{public}.0s":"Model Selector - Revised thresholds based on background analytics requirements", "impactMaxAccelNormAlertThreshold":"%{public}f", "age":"%{private}f", "metminpercentile":"%{private}f"}
{"msg%{public}.0s":"Model Selector - Picked thresholds based on features", "impactMaxAccelNormAlertThreshold":"%{public}f", "totalLongLieThreshold":%{private}d, "consecutiveLongLieThreshold":%{private}d, "minMetminCount":%{public}d, "maxMetminCount":%{public}d, "metminCount":%{public}ld, "alpha":"%{public}f", "age":"%{private}f", "metminpercentile":"%{private}f", "alertGatingMotionThreshold":"%{private}f", "cyclingImpactMaxAbsYThreshold":"%{private}f", "otherWorkoutQuiescenceThresholdLow":%{private}d, "otherWorkoutQuiescenceThresholdHigh":%{private}d, "otherWorkoutConsecutiveLongLieThreshold":%{private}d, "otherWorkoutShouldCancelAlertOnStepsThreshold":%{private}hhd, "otherWorkoutShouldCancelAlertOnStandThreshold":%{private}hhd, "otherWorkoutShouldCancelAlertOnActiveThreshold":%{private}hhd}
{"msg%{public}.0s":"Model Selector - Picked thresholds based on age only", "impactMaxAccelNormAlertThreshold":"%{public}f", "totalLongLieThreshold":%{private}d, "consecutiveLongLieThreshold":%{private}d, "age":"%{private}f", "metminpercentile":"%{private}f", "alertGatingMotionThreshold":"%{private}f", "cyclingImpactMaxAbsYThreshold":"%{private}f", "otherWorkoutQuiescenceThresholdLow":%{private}d, "otherWorkoutQuiescenceThresholdHigh":%{private}d, "otherWorkoutConsecutiveLongLieThreshold":%{private}d, "otherWorkoutShouldCancelAlertOnStepsThreshold":%{private}hhd, "otherWorkoutShouldCancelAlertOnStandThreshold":%{private}hhd, "otherWorkoutShouldCancelAlertOnActiveThreshold":%{private}hhd}
{"msg%{public}.0s":"Model Selector - Could not pick thresholds based on available features - Falling back to defaults", "impactMaxAccelNormAlertThreshold":"%{public}f", "totalLongLieThreshold":%{private}d, "consecutiveLongLieThreshold":%{private}d, "age":"%{private}f", "metminpercentile":"%{private}f", "alertGatingMotionThreshold":"%{private}f", "cyclingImpactMaxAbsYThreshold":"%{private}f", "otherWorkoutQuiescenceThresholdLow":%{private}d, "otherWorkoutQuiescenceThresholdHigh":%{private}d, "otherWorkoutConsecutiveLongLieThreshold":%{private}d, "otherWorkoutShouldCancelAlertOnStepsThreshold":%{private}hhd, "otherWorkoutShouldCancelAlertOnStandThreshold":%{private}hhd, "otherWorkoutShouldCancelAlertOnActiveThreshold":%{private}hhd}
{"msg%{public}.0s":"Overriding behavior feature", "key":%{public, location:escape_only}s, "value":%{public}d}
MotionStateObserver, Invalid data received.
MotionStateObserver, Timing out session since we have not heard a response in %f seconds.
MotionStateObserver, Starting update timer.
MotionStateObserver,VehicularTracking,STOP
MotionStateObserver,VehicularTracking,MotionState,startTime,%.3f,activityType,%d,vehicularConfidence,%d
MotionStateObserver,VehicularTracking,setActivityAlarm,%d,duration,%0.3f
MotionStateObserver,VehicularTracking,onActivityAlarm,%d
nil identifier given to CLKeychainItemWrapper
{"msg%{public}.0s":"Initializing CLKeychainItemWrapper with identifier and key.", "identifier":%{private, location:escape_only}s, "key":%{private, location:escape_only}@}
{"msg%{public}.0s":"Initial query to CLKeychainItemWrapper failed", "error":%{public}d}
nil dictionary passed for converstion
Conversion of dictionary without kSecValueData key requested.
nil dictionary passed for retrieving keychain item
Expected keychain item not found.
{"msg%{public}.0s":"Unable to retrieve keychain item", "error":%{public}d}
{"msg%{public}.0s":"Couldn't update the Keychain Item", "error":%{public}d}
{"msg%{public}.0s":"Couldn't add the Keychain Item", "error":%{public}d}
{"msg%{public}.0s":"Couldn't query for the Keychain Item to add", "error":%{public}d}
CL: CLNetworkLocationProvider::onStatusNotification
{"msg%{public}.0s":"CLNetworkLocationProvider::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onManagerNotification
{"msg%{public}.0s":"CLNetworkLocationProvider::onManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onCompanionNotification
{"msg%{public}.0s":"CLNetworkLocationProvider::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onDataProtectionNotification
{"msg%{public}.0s":"CLNetworkLocationProvider::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onTelephonyNotification
{"msg%{public}.0s":"CLNetworkLocationProvider::onTelephonyNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
@WifiFlow, reissue, time, %{public}.1f, last, %{public}.1f
@WifiFlow, inter-locreq state update per update timer event, staging, %{public}s, current, %{public}s
@WifiFlow, reissue, invalid location, #CloneMe
{"msg%{public}.0s":"Invalid batched location", "location":%{private, location:CLClientLocation}.*P}
{"msg%{public}.0s":"Batched locations are supposed to be ordered from oldest to more recent", "t0":"%{private}f", "t1":"%{private}f"}
WsbCalc, filter, live, %{public}lu, groups, %{public}lu
WsbCalc, filter, reproc, %{public}lu, groups, %{public}lu
@WifiFlow, alsreply, aps, error, tag, %{public}d
Wifi,undulation,%{public}lf, model, %{public}d
@WifiFlow, inter-locreq state update, staging, %{public}s, current, %{public}s
#Warning TIMEOUT: Waited %f seconds to aquire lock '%s' (%p)
{"msg%{public}.0s":"CSI assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning TIMEOUT: Held lock '%s' (%p) for %f seconds
Resetting detector, %.1f seconds without a gyro sample
{"msg%{public}.0s":"#Stream Nearby status change", "is nearby":%{public}d}
{"msg%{public}.0s":"#Stream failed to activate #Rapport link", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Stream #Rapport discovered nearby device", "model":%{public, location:escape_only}s, "name":%{private, location:escape_only}s, "effectiveID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream #Rapport lost nearby device", "model":%{public, location:escape_only}s, "name":%{private, location:escape_only}s, "effectiveID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream #Rapport Missing message type", "message":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Stream #Rapport Got message", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream Received message of unsupported version", "type":%{public, location:escape_only}s, "declared version":%{public}d, "minimum version":%{public}d, "maximum version":%{public}d}
{"msg%{public}.0s":"#Stream suspending silo until IDS becomes available"}
{"msg%{public}.0s":"#Stream waiting on IDS to become available"}
{"msg%{public}.0s":"#Stream IDS service failed to initialize", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Stream IDS became available so resuming silo"}
{"msg%{public}.0s":"#Stream No error, but also no identifier", "message type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#warning #Stream Got error from IDS", "error":%{public, location:escape_only}@, "message type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream Handed off message to IDS", "message type":%{public, location:escape_only}s, "identifier":%{public, location:escape_only}s}
{"msg%{public}.0s":"#warning #Stream #Rapport failed to send event", "writtenToNetworkStack":%{public}d, "error":%{public, location:escape_only}@, "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream #Rapport Send success", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#warning #Stream Got error from #Rapport", "error":%{public, location:escape_only}@, "message type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream Handed off message to #Rapport", "message type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream Missing message type", "message":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Stream Got message", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream Missing identifier"}
{"msg%{public}.0s":"#Stream Sync to/from standalone watch is not supported"}
{"msg%{public}.0s":"#warning #Stream Send failure", "identifier":%{public, location:escape_only}s, "success":%{public}d, "error":%{public, location:escape_only}@, "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream Send success", "identifier":%{public, location:escape_only}s, "type":%{public, location:escape_only}s}
***not supported***
<empty>
Attempt to set key %{public}s for read-only preferences %{public}s/%{public}s!
Enabling companion data source
could not store cached data 
#Warning clearing location cache
Not starting up CLVO2MaxService because it is not enabled
Starting up CLVO2MaxService
Shutting down CLVO2MaxService
Retro-compute, not sending analytics, no IHA permission
Succesfully accessed history table, sent Core Analytics event
XPC_CHECK_IN: VO2MaxRetrocomputePreProcessing already scheduled with a delay of %{public}lld seconds
Failed to mark VO2MaxRetrocomputePreProcessing activity as Continue. Current state is %{public}ld
Preparing to execute VO2MaxRetrocomputePreProcessing
Unexpected VO2MaxRetrocomputePreProcessing activity state: %ld
Error querying VO2MaxRetrocomputeHistory: %u
Queried VO2MaxRetrocomputeHistory for algVersion = %d and received %s
Will not attempt retrocompute pre-processing, status: %{public}d, algVersion: %{public}d
VO2MaxRetrocomputeHistory query failed due to device lock
Will not attempt retrocompute pre-processing, no age set
HealthKit VO2Max query failed due to device lock
HealthKit VO2Max query encountered error,%{public}ld
Retrieved sample... VO2Max: %{private}f, startTime: %{private}@, endTime: %{private}@, metadata: %{private}@, sourceRevision: %{private}@
Will not attempt to retrocompute sample due to missing metadata
Attempting to defer VO2MaxRetrocomputePreProcessing activity
Failed to mark VO2MaxRetrocomputePreProcessing activity as deferred. Current state is %{public}ld
Failed to mark activity as done. Current state is %{public}ld
There are no VO2Max HealthKit samples to retrocompute
Retrocompute encountered HealthKit sample with no SessionAttributes for sessionId %{private}@
CLVO2MaxService::getIndexInHealthKitSamples - sessionId: %{private}@, startIndex: %{public}d, index: %{public}zu
CLVO2MaxService::getIndexInHealthKitSamples - index not found for sessionId: %{private}@, startIndex: %{public}d
Query for staged summaries failed due to device lock
Query for historical summaries failed due to device lock
Query for pre-existing summaries for current session failed due to device lock
Stopping pre-processing due to age unexpectedly no longer being set after the initial check. Will retry later.
For testing purposes, incrementing VO2Max estimate by %{public}f units
Retrocompute result for sessionId %{private}@: old estimate: %{private}f, new estimate: %{private}f
Updating VO2MaxRetrocomputeHistory: startTime,%{private}f,algVersion,%{private}d,status,%{private}d,lastSessionTimestamp,%{private}f,lastSessionId,%{private}@,firstSampleDate,%{private}f,lastSampleDate,%{private}f,lastSampleDatePrevAlg,%{private}f,meanDelta,%{private}f,meanPercentileDelta,%{private}f,numUpdatedEstimates,%{private}d,numNewEstimates,%{private}d,numLostEstimates,%{private}d
Unable to query for staging output due to device lock
VO2MaxRetrocomputeHistory data checks: prevAlgSampleInterval,%{private}f,minPrevAlgSampleInterval,%{private}f,estimatesUpdatedRatio,%{private}f,minEstimatesUpdatedRatio,%{private}f,meanDelta,%{private}f,minMeanDelta,%{private}f,failedDataCheck,%{private}d,oldRetrocomputeStatus,%{public}d,newRetrocomputeStatus,%{public}d
Retrocompute triggered
Unable to query for staging output: %d
No staging data found
Adding retrocomputed sample to HKHealthStore: %{public}@
Retrocomputed VO2Max sample failed to push to HKHealthStore, %{public}@
Retrocomputed VO2Max sample successfully pushed to HKHealthStore
Will retry retrocompute trigger due to unexpected state. fPendingHealthKitWrites count: %{public}lu, expected sample startTime: %{private}f, actual sample startTime: %{private}f
Failed to update retrocompute history record with lastTimestampToHealthKit (%{private}f). Will attempt to proceed with remaining HealthKit writes.
Could not promote staging data: %d
Setting up %{public}s activity
Retrying retrocompute trigger already succeeded, cancelling activity
Unable to query for retrocompute history due to device lock
Will not attempt to retry retrocompute trigger, status: %{public}d, algVersion: %{public}d
Giving up attempting to retry retrocompute trigger
Retrying retrocompute trigger
Attempting to delete samples without estimates in HKHealthStore
Unable to fetch sessions without estimates
No sessions to delete from HKHealthStore
Setting up activity to attempt deleting sessions without estimates from HKHealthStore
Failed to mark activity as Continue. Current state is %{public}ld
HealthKit samples without an estimate have been deleted, cancelling activity
Attempting to retry deleting HealthKit samples without an estimate
Giving up attempting to delete HealthKit samples without an estimate
Deleting session %@ from HKHealthStore
Delete HK Sessions,success,%d,deletedObjectCount,%lu,error,%@
Successfully deleted samples from HKHealthStore
No sessions found without estimates to delete from HKHealthStore
CLVO2MaxService: Received user info update. IsAgeSet,%{public}d,Age,%{private}f,BiologicalSex,%{private}d,IsHeightSet,%{public}d,Height,%{private}f,IsWeightSet,%{public}d,Weight,%{private}f
Starting device motion service %{public}d
GyroUpdateInterval,%{public}.4f,AccelerometerUpdateInterval,%{public}.4f
Dumped gyro cal database with id %@
Stopping device motion service %{public}#x
Set device motion sensor status %{public}ld
[CLSensorFusionService] q.x,%10.10f,q.y,%10.10f,q.z,%10.10f,q.w,%10.10f,userAccel.x,%10.10f,userAccel.y,%10.10f,userAccel.z,%10.10f,rotationRate.x,%10.10f,rotationRate.y,%10.10f,rotationRate.z,%10.10f,magneticField.x,%10.10f,magneticField.y,%10.10f,magneticField.z,%10.10f,heading,%.3f,accuracy,%.3f,level,%{public}d,variant,%{public}d,mode,%{public}d,status,%{public}#02x,clientID,%{public}llu,timestamp,%{public}lf,now,%{public}lf,latency,%{public}lf
Overriding youth type for generic workout, beginTime, %f, before, %{public}d, after, %{public}d
invalid inputs
fVarEast <= 0.0
fVarNorth <= 0.0
fVarEastNorth < 0.0
CLMM, Unexpected determinant of 0
determinant <= 0.0
no mutable store path for type, %{public}d
could not get mutable store path for type, %{public}d
{"msg%{public}.0s":"Unknown persistent domain", "domain":%{public}d}
{"msg%{public}.0s":"accessing data", "file":%{public, location:escape_only}s}
{"msg%{public}.0s":"file does not exist (or cannot be accessed), starting fresh", "file":%{public, location:escape_only}s}
Store %s is configured for in-memory mode - not refreshing and marking the store as unmodified
#Warning persistent store %s has been modified - refreshing will lose changes
#Warning data set %s is not changeable - not storing
Store %s is configured for in-memory mode - not storing and marking the store as unmodified
%s stored to disk %s
scheduling to auto-store %s every %.3fs
disabling auto-store for %s
#Warning Got a request for a scan but no one is interested. Ignoring
found device %{private}@, data: %{private}@, rssi: %{private}d, type: %{private}d
#Warning Got a device notification but not device data
{"msg%{public}.0s":"No way to convert an internal unknown enum value to a valid WPHomeKitType", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning Found invalid HomeKit device. Data length was invalid
#Warning Found invalid HomeKit device: %{private}s
{"msg%{public}.0s":"HarvestController-Contruct", "isHarvestAllLocations":%{private}hhd, "highThermalThreshold":%{private}d, "lowThermalThreshold":%{private}d, "maxHarvestAge_s":"%{private}.09f", "maxHarvestPointsPer":%{private}d}
{"msg%{public}.0s":"#pruneTimer", "nextPruneTime_s":"%{private}.09f"}
{"msg%{public}.0s":"registering for internal notifications"}
{"msg%{public}.0s":"CLHarvestController-upload"}
{"msg%{public}.0s":"CLHarvestController-prune"}
{"msg%{public}.0s":"gps harvesting is not supported"}
{"msg%{public}.0s":"Harvester registering for location leech notifications"}
{"msg%{public}.0s":"Harvester registering for PassKit notifications"}
{"msg%{public}.0s":"Harvester registering for leech visit notifications"}
{"msg%{public}.0s":"Harvester registering for wifi notificatons"}
{"msg%{public}.0s":"Harvester unregistering for location notifications"}
{"msg%{public}.0s":"Harvester unregistering for PassKit notifications"}
{"msg%{public}.0s":"Harvester unregistering for leech visit notifications"}
{"msg%{public}.0s":"Harvester unregistering for wifi notificatons"}
{"msg%{public}.0s":"Unknown SubHarvester registering for notification", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "harvestNotificationType":%{private, location:escape_only}s}
{"msg%{public}.0s":"SubHarvester re-registered for notification", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "harvestNotificationType":%{private, location:escape_only}s}
{"msg%{public}.0s":"subharvester registered for notification", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "harvestNotificationType":%{private, location:escape_only}s}
{"msg%{public}.0s":"Unknown SubHarvester unregistering for notification", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "harvestNotificationType":%{private, location:escape_only}s}
{"msg%{public}.0s":"subharvester unregistered for notification", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "harvestNotificationType":%{private, location:escape_only}s}
{"msg%{public}.0s":"location-specific entry is incomplete", "incompleteEntry":%{private}d}
{"msg%{public}.0s":"applying bounding-box-specific overrides", "lat":"%{private}f", "lon":"%{private}f", "latMin":"%{private}f", "lonMin":"%{private}f", "latMax":"%{private}f", "lonMax":"%{private}f"}
{"msg%{public}.0s":"applying overrides"}
{"msg%{public}.0s":"found default overrides - applying"}
{"msg%{public}.0s":"found network overrides - applying"}
{"msg%{public}.0s":"no overrides found in daemon settings or network settings"}
{"msg%{public}.0s":"updateHarvestingAllowed", "isHarvestingEnabled":%{public}hhd, "fHarvestingAllowed":%{public}hhd, "isLocationServicesEnabled":%{public}hhd, "fThermalLevelAcceptableLowCpu":%{public}hhd, "isInPrivateMode":%{public}hhd, "fBatterySaverModeEnabled":%{public}hhd, "hasAuthorizedClients":%{public}hhd, "isGpsControllerSimulationEnabled":%{public}hhd, "isHarvestingAllowedForLocationSimulation":%{public}hhd, "isGpsControllerSimulationEnabled":%{public}hhd, "isLocationControllerSimulationEnabled":%{public}hhd}
{"msg%{public}.0s":"Harvesting not allowed: disabled"}
{"msg%{public}.0s":"Harvesting not allowed: location services disabled"}
{"msg%{public}.0s":"Harvesting not allowed: thermal level unacceptable"}
{"msg%{public}.0s":"Harvesting not allowed: in private mode"}
{"msg%{public}.0s":"Harvesting not allowed: battery saver mode enabled"}
{"msg%{public}.0s":"Harvesting not allowed: no authorized clients"}
{"msg%{public}.0s":"Harvesting not allowed: gps simulation enabled"}
{"msg%{public}.0s":"Harvesting not allowed: gps simulation enabled (gps monitor)"}
{"msg%{public}.0s":"Harvesting not allowed: location simulation enabled"}
{"msg%{public}.0s":"Harvesting now allowed"}
EnableHarvestingForLocationSimulation not set to True.
Collection endpoint for: %s  set to : %s. Should be localhost:8008
{"msg%{public}.0s":"starting motion activity monitoring"}
{"msg%{public}.0s":"fetched most recent connection", "startTime":"%{private}f", "endTime":"%{private}f", "vehicleConnected":%{private}hhd}
{"msg%{public}.0s":"stopping motion activity monitoring"}
{"msg%{public}.0s":"starting battery monitoring"}
{"msg%{public}.0s":"stopping battery monitoring"}
{"msg%{public}.0s":"not harvesting, harvesting now allowed", "age_s":"%{private}.09f"}
Pos harvesting not eligible as gps harvetsing is ineligible
{"msg%{public}.0s":"#warning: faking harvest eligibility"}
{"msg%{public}.0s":"WARN: location dropped due to referenceFrame", "referenceFrame":%{private, location:CLClientLocationReferenceFrame}lld}
{"msg%{public}.0s":"SystemService gating harvester does not exists in isClientAuthorizedMap. Treating as not authorized", "SystemService":%{public, location:escape_only}s, "Harvester":%{public, location:escape_only}s}
{"msg%{public}.0s":"update authorization", "clientKey":%{public, location:escape_only}s, "isAuthorized":%{public}hhd}
{"msg%{public}.0s":"SystemService not found in kSystemServicesUsedInHarvesting", "SystemService":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Battery changed state", "oldBatteryState":%{private, location:escape_only}s, "newBatteryState":%{private, location:escape_only}s}
{"msg%{public}.0s":"Reachability changed state", "oldReachability":%{private, location:CLDaemonStatus_Type::Reachability}lld, "newReachability":%{private, location:CLDaemonStatus_Type::Reachability}lld}
{"msg%{public}.0s":"onThermalStatusNotification", "thermalLevel":%{public}d}
{"msg%{public}.0s":"thermal (low cpu tasks) transition", "acceptable":%{private}hhd}
{"msg%{public}.0s":"thermal (high cpu tasks) transition", "acceptable":%{private}hhd}
{"msg%{public}.0s":"thermal level is too high - no network request", "thermalLevel":%{private}d}
{"msg%{public}.0s":"no data available - no network requests"}
{"msg%{public}.0s":"currently have active or held calls - no network requests over cellular"}
{"msg%{public}.0s":"currently roaming - no network requests over cellular"}
{"msg%{public}.0s":"vehicle connected state changed, was unknown", "newVehicleConnectionState":%{private}d}
{"msg%{public}.0s":"vehicle connected state changed", "oldVehicleConnectionState":%{private}d, "newVehicleConnectionState":%{private}d}
{"msg%{public}.0s":"#pruneTimer fired", "lastPruneTime_s":"%{private}.09f", "maxHarvestAge_s":"%{private}.09f"}
{"msg%{public}.0s":"#uploadTimer fired"}
{"msg%{public}.0s":"#uploadTimer upload requirements not met, skipping upload"}
{"msg%{public}.0s":"#uploadTimer already locked"}
{"msg%{public}.0s":"#uploadTimer locked"}
{"msg%{public}.0s":"#uploadTimer already unlocked"}
{"msg%{public}.0s":"#uploadTimer unlocked"}
{"msg%{public}.0s":"cleaning dirty #uploadTimer times"}
{"msg%{public}.0s":"#uploadTimer already set to this time", "uploadTimerFireTime_s":"%{private}.09f"}
{"msg%{public}.0s":"#uploadTimer locked, ignoring timer update request", "uploadTimerFireTime_s":"%{private}.09f"}
{"msg%{public}.0s":"Upload requirements not met, ignoring #uploadTimer update request", "uploadTimerFireTime_s":"%{private}.09f"}
{"msg%{public}.0s":"#uploadTimer fired twice quickly, adding delay", "uploadTimerFireTime_s":"%{private}.09f", "uploadDelay_s":"%{private}.09f"}
{"msg%{public}.0s":"#uploadTimer disabled"}
{"msg%{public}.0s":"#uploadTimer fire date set", "uploadTimerFireTime_s":"%{private}.09f"}
getNextUploadTime: min time: %f
{"msg%{public}.0s":"Unknown SubHarvester notifying of #uploadTimer fire date."}
{"msg%{public}.0s":"next attempt time is equal to existing attempt time", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld}
{"msg%{public}.0s":"#uploadTimer invalid time reported", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld}
{"msg%{public}.0s":"#uploadTimer upload time set", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "notifiedAttemptTime_s":"%{private}.09f", "timeUntilAttempt_s":"%{private}.09f"}
{"msg%{public}.0s":"MainHarvesterMetrics", "reachabilityNotifications":%{private}d, "batteryNotifications":%{private}d, "thermalNotifications":%{private}d, "locationNotifications":%{private}d, "rawsGpsNotifications":%{private}d, "validatedGpsNotifications":%{private}d, "managerNotifications":%{private}d, "durationMinimumUploadRequirementsMet":"%{private}f", "durationMinimumUploadRequirementsNotMet":"%{private}f"}
{"msg%{public}.0s":"data protection is becoming re-enabled"}
{"msg%{public}.0s":"upload requirements not met, skipping DataProtection-initiated upload"}
{"msg%{public}.0s":"uploaded too recently, skipping DataProtection-initiated upload"}
{"msg%{public}.0s":"starting DataProtection-initiated upload"}
{"msg%{public}.0s":"Harvester received an un-registered location notification", "notification":%{private, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"dominant motion activity changed", "oldDominantActivity":%{private, location:CLMotionActivity}.*P, "newDominantActivity":%{private, location:CLMotionActivity}.*P}
{"msg%{public}.0s":"location services reset, clearing all local cache"}
{"msg%{public}.0s":"location services disabled, clearing all local cache"}
{"msg%{public}.0s":"onManagerNotification: auth changed received for SS not used in harvesting. skip auth caching.", "SystemService":%{public, location:escape_only}s}
{"msg%{public}.0s":"battery save mode state update", "batterySaverEnabled":%{private}hhd}
{"msg%{public}.0s":"onVisit", "validLocationOfInterest":%{private}hhd, "locationOfInterestType":%{private, location:RTLocationOfInterestType}lld}
CL: CLHarvestController::onPruneTimer
{"msg%{public}.0s":"CLHarvestController::onPruneTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLHarvestController::onUploadTimer
{"msg%{public}.0s":"CLHarvestController::onUploadTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"CLTelephonyServiceNotifier Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"attempt to reset modem", "success":%{public}hhd, "reason":%{private, location:escape_only}s}
CELL_LOC: fHardwareType, %d
Registration status: %d
{"msg%{public}.0s":"DaemonNotReady for CT SPI", "fDaemonReady":%{public}hhd}
currently not connected to telephony service
{"msg%{public}.0s":"#Int2NotifMap", "Key":%{public}d, "NotifPtr":"%{public}p", "NotifVal":%{public, location:escape_only}@}
Request to decode unknown integer %d is a programmer error. fSize %d
IndoorPedStop,state,%d,headingCnt,%d,stepCount,%d,zeroStepCount,%d,likelyExitCount,%d,longStd,%f,shortStd,%f,rails,%d,currentSteps,%d,vm,%f,recentZeroSteps,%d,exertionDelta,%f,exertionIsLow,%d,headingDelta,%f
WifiService, gExcludedAP, %{public}s
{"msg%{public}.0s":"WifiService, dispatchQ, Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
WifiService, ctor, fDpcSource is NULL
WifiService, passive scans only
WsbClients, timer, %{public}0.f
WRTT: no active listeners
WifiService, getPower, fDpcSource is NULL
WsbMetric, clients, %{public}s, delta, %{public}.1f
WsbMetric, regmode, %{public}s, duration, %{public}.1f
WsbMetric, regmode, total, duration, %{public}.1f
WsbMetric, regmode, subminute
WsbClients, status, holdoff, clients, %{public}d, samplescan, %{public}d
WsbClients, status, reportonly, clients, %{public}d, dummyscan, %{public}d
WsbClients, mismatch, %{public}s, %{public}d, %{public}d, #CloneMe
setExitAndEntryScanNetworks, entry, %lu, exit, %lu
WsbTimer, first, %{public}d
WsbClients, status, start
CL: CLWifiService::onDpcSource
{"msg%{public}.0s":"CLWifiService::onDpcSource", "event":%{public, location:escape_only}s, "this":"%{public}p"}
pause
resume
METS consumed,startTime,%.3f,computeTime,%.3f,now,%.3f,activity,%d,userMets,%f,wrMets,%f,rawTruthMets,%f,avgTruthMets,%f,basalMets,%f,duration,%lf,stored,%d,%s,rawHRMets,%f,rawFMMets,%f,totalCalories,%lld,basalCalories,%lld,VectorMag,%f,pushCount,%d,activityWithoutOverride,%d,isStanding,%d,isMotionOverrideSet,%d
Popping out an activity since there's no activity associated with current time.  This shouldn't happen
MET spike,%f,setting to basal,%f
In-human MET spike,%f,setting to upper bound,%f
spuLogLevel,%d
Trying to send CMA command,datalen,%zu
Sending new config to SPU:enableActivity,%{private}u,enableStepCounting,%{private}u,enableOnBodyDetection,%{private}u,activityForceCodeTransition,%{private}u,stepCountingForceCodeTransition,%{private}u,enableThreshold,%{private}u,disableDynamicBias,%{public}u,ignoreDynamicBias,%{public}u,ispEnable,%{public}u,ispMode,%{public}u,ISPUpdateIntervalOverride,%{public}f,stickyIsp,%{public}d,logLevel,%{public}d,enableCoarseElevation,%{private}d,proactiveRevisitTime,%{public}u,fallStatsMode,%{private}u,sensorRecordingActive,%{private}u,simulateEvent,%{private}u,userStudyPressureDataCollection,%{private}u,detectorEnabled,%{private}u,lastAckedAopTimestamp,%{public}llu,gateDynamicBiasOnChargerStatus,%{private}u,supportsOISImprovements,%{private}u
Sending initial configuration.
Failed to configure motion coprocessor
[CompassCalibration] no persistent calibration found
[CompassCalibration] logging initial persisted calibration: bias.x,%.2f,.y,%.2f,.z,%.2f,radius,%.2f,level,%d,quality,%.2f,cftime,%.3f
[CompassCalibration] stale persistent calibration,%@
[CompassCalibration] restoring calibration,%@
SPU rejected configuration. resending.
[CompassCalibration] bias.x,%f,.y,%f,.z,%f,scale.x,%f,.y,%f,.z,%f,quality,%{public}f,cost,%{public}f,coverage,%{public}f,earthDiffRatio,%{public}f,pose.x,%f,.y,%f,.z,%f,level,%{public}d,saturations,%{public}d,hasConsistency,%{public}d,apAwake,%{public}d,planarity,%{public}f,temperature,%{public}f,minTemperatureSinceLastCal,%{public}f,maxTemperatureSinceLastCal,%{public}f,avgTemperatureSinceLastCal,%{public}f
[CompassCalibration] persisting calibration,%@
[CompassCalibration] clearing persistent calibration
data type %u,received and reconstructed
Receiving first Sensor Buffer packet since process start, seq %u
Sensor Buffer packet drop detected. AP is expecting %u, but got %u
{"msg%{public}.0s":"Configuration sent", "fFallStatsMode":%{private}d, "fSensorRecordingActive":%{private}hhd, "fSimulateEvent":%{private}d, "fUserStudyPressureDataCollection":%{private}hhd, "fDetectorEnabled":%{private}hhd, "fLastReplyAopTimestamp":%{private}llu}
Sending fallModel Command.
{"msg%{public}.0s":"Sending fallThresholds Command", "fImpactMaxAccelNormAlertThreshold":"%{private}f", "fImpactMaxAccelNormLoggingStatsThreshold":"%{private}f", "fImpactMaxAccelNormLoggingHeartRateThreshold":"%{private}f", "fImpactMaxAccelNormLoggingHighResolutionSensorDataThreshold":"%{private}f", "fCyclingImpactGravityVarianceThreshold":"%{private}f", "fCyclingImpactCrownVarianceThreshold":"%{private}f", "fCyclingImpactMaxAbsYThreshold":"%{private}f", "fCyclingDistanceTraveledPostImpactThreshold":"%{private}f", "fCyclingEpochsDetectedPostImpactThreshold":%{private}d, "fOtherWorkoutQuiescenceThresholdLow":%{private}d, "fOtherWorkoutQuiescenceThresholdHigh":%{private}d, "fOtherWorkoutConsecutiveLongLieThreshold":%{private}d, "fOtherWorkoutShouldCancelAlertOnStepsThreshold":%{private}d, "fOtherWorkoutShouldCancelAlertOnStandThreshold":%{private}d, "fOtherWorkoutShouldCancelAlertOnActiveThreshold":%{private}d, "fRefereeOperatingModeOverride":%{private}d, "fAllDayStateMachineOperatingModeOverride":%{private}d, "fCyclingStateMachineEnabledOverride":%{private}d, "fAllDayStateMachineEnabledOverride":%{private}d}
Commanding fast accel config BW %{public}u, FSR %{public}u
{"msg%{public}.0s":"Configuration sent", "shouldGateDynamicBiasOnChargerStatus":%{private}d}
MagnetometerReset,timestamp,%{public}f,timeSinceLastRemagTrigger,%llu,timeSinceLastRemag,%llu,triggerCount,%llu,exitingSaturation,%{public}d,extendedSaturation,%{public}d,shiftInSaturation,%{public}d,fSuccessFlag,%{public}d
Out of order segments,U::kType,%{public}u,fLastSegment,%{public}u,packet->fSegment,%{public}u
Bad size,packet->fSize,%{public}u
{"msg%{public}.0s":"#Stream Transitioned state", "old state":%{public, location:CLStreamingAwareLocationProviderNoLocalGPSStateMachine::LocationSourceState}lld, "new state":%{public, location:CLStreamingAwareLocationProviderNoLocalGPSStateMachine::LocationSourceState}lld}
WMM initialization encountered an error
WMM evaluation encountered an error
geomagnetic model invalid near poles (%f, %f, %f)
could not open geomagnetic data file %s (%{public}s)
geomagnetic data file appears to be empty
geomagnetic data file appears to have invalid dimensions
supplied date (%{public}f) outside valid range (epoch=%{public}f)
DisableMotionStateNotifyDefaultsWrite,%d
DOMINANT ACTIVITY: start monitoring dominant activity
DOMINANT ACTIVITY: stop monitoring dominant activity
Walking bout ended due to exceeding max duration without stepNotifications
Activity type is %{private}s (%{private}d), conf, %{private}d, raw activity type %{private}s (%{private}d), raw conf, %{private}d, mounted, %{private}d, startTime, %f
Received stepCountEntry, startTime, %{private}f, count, %{private}d, activeTime, %{private}f, distance, %{private}f, firstStepTime, %{private}f, distanceSource, %{private}d
Ignoring step count while in wheelchair mode
Saw time go backwards
Saw step count go backwards
Unexpected large jump in steps, %{public}d new steps, %{public}.1f seconds delay since last entry, stopping bout
Possibly missing step count entries, %{public}d new steps, %{public}.1f seconds delay since last entry
Unexpected large jump in steps, %{public}d new steps, %{public}.1f seconds delay since last entry
Walking bout ended due to exceeding max duration without steps
Walking bout has ended due to exceeding the max duration
StepCountEntry with steps but no firstStepTime
StepCountEntry with steps but activeTime doesn't advance
Potential walking bout identified... fBoutStartTime: %{public}f
Missing previous epoch before an epoch with steps
Extending bout...,deltaSteps,%d,dist,%.3f,activeTime,%.3f
Timestamp comparisons... firstStepCountTime:%{private}f, lastStepCountTime:%{private}f, trimmedBoutStartTime:%{private}f, trimmedBoutEndTime:%{private}f
type,%{public}d,boutStart,%{public}f,boutEnd,%{public}f,steps,%{public}d,distance,%{public}f,activeTime,%{public}f,gpsSteps,%{public}d,gpsDistance,%{public}f,report,%{public}d
Discarding bout since it does not meet minimum timeWithSteps requirement
CLPredictedWalkDistanceBoutDetector: Received user info (%s)
CLPredictedWalkDistanceBoutDetector: Ending walking bout due to wheelchair (%{public}.2f)
CLFU,data reachability is not available - not downloading %s
CLFU,downloading from %s to %s
#Warning,CLFU,could not download from %s to %s
CLFU,registered for kNotificationCompanionConnectionUpdate
CLFU,onCompanionNotification, notification, %d
CLFU,fCompanionIsNearby,%d,fDownloadDst,%s
CLFU,no download source set - not downloading
CLFU,we are now on wifi, downloading %s aggressively (period %.3f)
CLFU,last %s downloaded over %.3f seconds ago (%.3f), starting a download now
CLFU,last %s downloaded less than %.3f seconds ago (%.3f), scheduling download for %.3f (%.3f away)
CLFU,cannot verify existence of %s, re-downloading
CLFU,scheduled download %s is after %.3f deadline (%.3f after) - overriding
CLFU,Throttling download %s due to retry delay, scheduling download for %.3f (%.3f away)
CLFU,could not rename %{public}s to %{public}s,%{public}d
CLFU,download completed to %s
CLFU,newly downloaded %s file is now %s (time %.3f)
#Warning,CLFU, could not get modified time for %{public}s
#Warning,CLFU, could not download from %s to %s
CLFU,data reachability is not available - not retrying %s
CLFU,retry count %{public}d, will re-download for %s after delay of %f
#Warning,CLFU,%{public}s downloading in progress, cannot change update settings
CLFU,%{public}s download timeout must be greater than 0. Forcing to 30 seconds.
CLFU,could not create path %{public}s
#Warning,CLFU, update rate %.3fs is shorter than WiFi update rate %.3fs - overriding WiFi update rate
CLFU,file %s update rate set to %.3fs, %.3fs
CLFU,unregistered for kNotificationCompanionConnectionUpdate for %s
CLFU,stopping download of %s
CLFU,destination stat failed,%{public}s,%{public}d
CLFU,download of %s not yet timed out. Blocking current download request
CLFU,current download of %s has timed out, canceling
CL: CLFileUpdate::onDownloaded
{"msg%{public}.0s":"CLFileUpdate::onDownloaded", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFileUpdate::onStatusNotification
{"msg%{public}.0s":"CLFileUpdate::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFileUpdate::onCompanionNotification
{"msg%{public}.0s":"CLFileUpdate::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Warning: Not implemented.
TransitMac, Traversing transit mac tile
TransitMac, Transit mac tile size = %lu
TransitMac, failed to allocate transit mac tile
TransitMac, failed to decode transit mac tile protobuf, encrypted=%{public}lu
TransitMac, failed to get fields in transit mac tile
TransitMac, ver,%d, x, %d, y, %d, generated, %.01lf, age, %.01f, ageThresh, %d, numOfMacs, %lu
TransitMac, Searching transit mac tile
TransitMac, failed to open tile file, %s
TransitMac, failed to read tile file, %s
TransitMac, failed to parse tile file, %s
TransitMac, empty tile??, %s
WRTT: device type,%{public}d
WRTT: request while wifi is off!
WRTT: mgr received request as initiator, timeout, %{public}lf [s]
WRTT: mgr received request as target
WRTT: mgr received cancel session
WRTT: timed out
WRTT: WiFi power %{public}s
#Warning Multiple Peers in request with matching mac address, %{private}s
WRTT: RTT measurements for %{public}ld peer(s)
WRTT: unexpected status code %{public}d (%{public}#x)
WRTT: error status code %{public}d (%{public}#x) reported from WiFi, report kCLErrorPrivateRangingLowLevelError
WRTT: unknown status code %{public}d (%{public}#x)
WRTT: no individual measurements in burst
WRTT,range %{public}lu of %{public}lu,%{private}f,core,%{private}d
WRTT, decisionProcessor in CLPeerRangingManager is not allocated
{"msg%{public}.0s":"WRTT: Unlock result", "peer":%{private, location:escape_only}s, "notify":%{public}d, "shouldUnlock":%{public}d, "rangeEstimate":"%{public}f"}
WRTT: recieved Wifi error %{public}ld for %{public}ld peers
%s, %d, %s, %d
startWsbClient
stopWsbClient
VEHICULAR: start extra scan
VEHICULAR: leeched location, %s
VEHICULAR: disqualified leeched location, type, %d
VEHICULAR: location timestamp out of order
VEHICULAR: disqualified leeched location, horizontal accuracy, %f
VEHICULAR: disqualified leeched location, age, %f
VEHICULAR: qualified leeched location, type, %d
VEHICULAR: first qualifying location
VEHICULAR: renew previous location older than age of %f seconds
VEHICULAR: previous location, type, %d, %s
VEHICULAR: distanceMoved, %f, elapsedTime, %f
VEHICULAR: drop leeched location within %f sec
VEHICULAR: accept qualified leeched location, type, %d
VEHICULAR: outlier, conservativeSpeed, %f, effectiveSpeed, %f, speedUncertainty, %f, distanceMoved, %f, elapsedTime, %f, type, %d
VEHICULAR: vehicular speed detected, consecutive observations, %d, elapsedTime, %f, lastElapsedTime, %f, delta, %f
VEHICULAR: conservativeSpeed, %f, effectiveSpeed, %f, speedUncertainty, %f, distanceMoved, %f, elapsedTime, %f, type, %d
MotionState, %s, type, %d, conf, %d, mounted, %d, startTime, %f
VEHICULAR: vehicularStartTime, %f, seq, %d
VEHICULAR: vehicularLastNoHintsTime, %f
VEHICULAR: skipping LatencyMetrics, seenNonVehicularState, %d
VEHICULAR: reset vehicular latency measures
VEHICULAR: notification ScanCache received %d
VEHICULAR: wifi associated state, %d
VEHICULAR: received unhandled WifiService notification %d
VEHICULAR: received unhandled notification %d
Sending message,type,%d,size,%lu,priority,%ld,fireAndForget,%d,encrypt,%d,bypassConnectionCheck,%d,timeout,%f,nonWaking,%d
timer interval,%f
IDS connection update,status,%d,prevDisconnection,%f,modelID,%s,uniqueIDOverride,%s,localDeviceID,%s
companion idsService (beginService) %p
{"msg%{public}.0s":"#CLCompanionNotifier suspending silo until IDS becomes available (CLCompanionTransport)"}
{"msg%{public}.0s":"#CLCompanionNotifier waiting on IDS to become available (CLCompanionTransport)"}
{"msg%{public}.0s":"#CLCompanionNotifier IDS service failed to initialize", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#CLCompanionNotifier IDS became available so resuming silo (CLCompanionTransport)"}
CL: CLCompanionNotifier::onDataProtectionNotification
{"msg%{public}.0s":"CLCompanionNotifier::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCompanionNotifier::onFitnessTrackingNotification
{"msg%{public}.0s":"CLCompanionNotifier::onFitnessTrackingNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCompanionNotifier::onMotionStateObserverNotification
{"msg%{public}.0s":"CLCompanionNotifier::onMotionStateObserverNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Cycling active state model failure to get cycling result, %f
CLOutdoorCyclingActiveStateModel,pausing,nominalPauseStates,%d,fastPauseWithTier1Prob,%d,pauseHistGPSOverride,%d,countTier1Override,%d,%s
CLOutdoorCyclingActiveStateModel,resuming,nominalResumeStates,%d,fastResumeWithTier1Prob,%d,resumeHistGPSOverride,%d,countTier1Override,%d,%s
{"msg%{public}.0s":"Killing locationd to trace sqlite statement creating failures", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Query: %s, full table scans: %d, sorts: %d, File: %s
{"msg%{public}.0s":"open", "path":%{public, location:escape_only}s, "protection":%{public}d, "persistence":%{public}d}
{"msg%{public}.0s":"Requested filename", "expected":%{public, location:escape_only}s, "actual":%{public, location:escape_only}s}
{"msg%{public}.0s":"Returned database", "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"Unable to turn ON foreign keys check"}
{"msg%{public}.0s":"#warning Could not open database", "path":%{public, location:escape_only}s, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"Could not open database", "path":%{public, location:escape_only}s, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"#warning Failed to create UUID select statement"}
{"msg%{public}.0s":"initUUID", "path":%{public, location:escape_only}s, "uuid":%{private, location:escape_only}s}
{"msg%{public}.0s":"#warning Failed to create UUID insert statement"}
{"msg%{public}.0s":"UUID initialized", "path":%{public, location:escape_only}s, "uuid":%{private, location:escape_only}s}
{"msg%{public}.0s":"Failed to initialize DB UUID", "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"unknown protection type", "protection":%{public}d}
{"msg%{public}.0s":"could not create path", "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"unknown persistence type", "persistence":%{public}d}
{"msg%{public}.0s":"displaySqlResult", "function":%{public, location:escape_only}s, "errno":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"#warning displaySqlResult", "function":%{public, location:escape_only}s, "errno":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"handleSqlError on read-only db", "path":%{public, location:escape_only}s, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"database error; deleting and exiting", "path":%{public, location:escape_only}s, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"Killing locationd to resolve corrupted database", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"createTableIfNecessary", "table":%{private, location:escape_only}s, "specificToSerialNumber":%{public}hhd}
{"msg%{public}.0s":"Index already exists; not re-creating", "index":%{private, location:escape_only}s}
{"msg%{public}.0s":"Index already exists but is different; dropping", "index":%{private, location:escape_only}s, "actual":%{private, location:escape_only}s, "expected":%{private, location:escape_only}s}
{"msg%{public}.0s":"Index does not exist; creating", "index":%{private, location:escape_only}s}
{"msg%{public}.0s":"#warning Couldn't create index statement", "table":%{private, location:escape_only}s, "columns":%{public, location:escape_only}s}
{"msg%{public}.0s":"#warning Couldn't create drop index statement", "index":%{private, location:escape_only}s}
{"msg%{public}.0s":"Trigger does not exist", "trigger":%{public, location:escape_only}s}
{"msg%{public}.0s":"#warning Couldn't create drop trigger statement", "trigger":%{public, location:escape_only}s}
{"msg%{public}.0s":"Couldn't create add count trigger statement", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Couldn't create select count statement", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Couldn't get row count for", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Couldn't prepare row count insertion statement"}
{"msg%{public}.0s":"Table doesn't exist in database", "table":%{public, location:escape_only}s}
{"msg%{public}.0s":"Need at least one column in table", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"#warning Existing table's column does not match expected", "table":%{private, location:escape_only}s, "index":%{public}d, "expected name":%{public, location:escape_only}s, "expected type":%{public, location:escape_only}s, "expected primary key":%{public}hhd, "actual name":%{public, location:escape_only}s, "actual type":%{public, location:escape_only}s, "actual primary key":%{public}hhd}
{"msg%{public}.0s":"#warning Existing table's schema does not have the same number of columns as the requested schema", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"#warning Existing table's foreign key constraint does not match expected", "table":%{private, location:escape_only}s, "ExpectedFromCol":%{public, location:escape_only}s, "ExpectedToTable":%{public, location:escape_only}s, "ExpectedToCol":%{public, location:escape_only}s, "ActualFromCol":%{public, location:escape_only}s, "ActualToTable":%{public, location:escape_only}s, "ActualToCol":%{public, location:escape_only}s, "ExpectedOnDelete":%{public, location:escape_only}s, "ActualOnDelete":%{public, location:escape_only}s, "ExpectedOnUpdate":%{public, location:escape_only}s, "ActualOnUpdate":%{public, location:escape_only}s}
{"msg%{public}.0s":"#warning Actual table has more foreign key contraints than expected"}
{"msg%{public}.0s":"#warning Table exists but does not have matching schema", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Re-recreating table to fix primary key", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Destination name should not be NULL", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Did not successfully finish backup", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"Unable to open", "path":%{private, location:escape_only}s}
{"msg%{public}.0s":"Opening a blob for read", "tableName":%{private, location:escape_only}s, "colname":%{private, location:escape_only}s, "row":%{private}llu}
{"msg%{public}.0s":"failed to open blob", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"error when closing blob", "code":%{public}d}
{"msg%{public}.0s":"Creating table", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Schema statement created", "schema":%{public, location:escape_only}s}
{"msg%{public}.0s":"version and serial number", "table":%{private, location:escape_only}s, "path":%{public, location:escape_only}s, "rc":%{public, location:SqliteResult}.*P, "version":%{public, location:escape_only}s, "serial number":%{private, location:escape_only}s}
{"msg%{public}.0s":"Created row in TableInfo", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Dropping table", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Invalid parameters", "table":%{private, location:escape_only}s, "columnNames[0]":%{public, location:escape_only}s}
{"msg%{public}.0s":"Invalid parameters", "table":%{private, location:escape_only}s, "columnNames[0]":%{public, location:escape_only}s, "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"Invalid parameters", "table":%{private, location:escape_only}s, "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"Could not prepare statement", "query":%{private, location:escape_only}s, "rc":%{public, location:SqliteResult}.*P, "errmsg":%{private, location:escape_only}s}
{"msg%{public}.0s":"Preparing statement for database", "query":%{private, location:escape_only}s, "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"Prepared statement", "statement":"%{public}p"}
{"msg%{public}.0s":"beginTransaction", "path":%{public, location:escape_only}s, "count":%{public}d, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"endTransaction", "path":%{public, location:escape_only}s, "count":%{public}d, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"rollbackTransaction", "path":%{public, location:escape_only}s, "count":%{public}d, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"We should only have one transaction at a time and thus should be back at zero", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#warning Finalized statement previously failed", "rc":%{public, location:SqliteResult}.*P, "errmsg":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not find prepared statement", "statement":"%{public}p"}
{"msg%{public}.0s":"start vacuum", "page_count":%{public}lld, "freelist_count":%{public}lld, "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"incremental_vacuum", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "page_count":%{public}lld, "freelist_count":%{public}lld, "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"vacuum", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "rc":%{public, location:SqliteResult}.*P, "page_count":%{public}lld, "freelist_count":%{public}lld, "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"wal_checkpoint", "path":%{public, location:escape_only}s, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"incrementalVacuum", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "pages":%{public}lld, "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"incrementalVacuum", "result":%{public}d}
{"msg%{public}.0s":"Attempt to reduceFreePages on readonly database", "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"Attempt to reduceFreePages with incremental vacuum disabled", "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"reduceFreePages", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f"}
{"msg%{public}.0s":"reduceFreePages", "path":%{public, location:escape_only}s, "page_count":%{public}lld, "freelist_count":%{public}lld, "loadFactor":"%{public}f"}
{"msg%{public}.0s":"Cannot reduceFreePages", "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"setIncrementalVacuumEnabled", "enabled":%{public}hhd, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"Actual auto-vacuum state does not match desired state", "actual":%{public}d, "expected":%{public}d, "vacuumNow":%{public}hhd}
{"msg%{public}.0s":"Must provide a table name"}
{"msg%{public}.0s":"Table does not exist but its metadata does", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"#warning Table was created by a different device (serial numbers do not match). Deleting", "table":%{private, location:escape_only}s, "expected":%{private, location:escape_only}s, "actual":%{private, location:escape_only}s}
{"msg%{public}.0s":"Table was created by this device (serial numbers match). Keeping", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Table was created by an unknown device (table info missing). Deleting", "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"The CL version has not changed since CLSqliteDatabase::createTableIfNecessary() was last invoked for this pair, so not creating table", "path":%{public, location:escape_only}s, "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"The CL version has changed since CLSqliteDatabase::createTableIfNecessary() was last invoked for this pair. Checking schema", "path":%{public, location:escape_only}s, "table":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not bind", "value":%{private}d, "index":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not bind", "value":%{private}u, "index":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not bind", "value":"%{private}f", "index":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not bind", "value":%{private, location:escape_only}s, "index":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not bind", "value":%{private}lld, "index":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not bind", "value":%{private, location:escape_only}@, "index":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not bind", "index":%{public}d, "rc":%{public, location:SqliteResult}.*P, "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"getForeignKeyDefinitionString: NULL column definition"}
{"msg%{public}.0s":"Foreign key reference and index check failed"}
{"msg%{public}.0s":"Foreign key references are valid", "FK_Table":%{public, location:escape_only}s, "FK_Col":%{public, location:escape_only}s}
{"msg%{public}.0s":"Index exist", "FK_Table":%{public, location:escape_only}s, "FK_Col":%{public, location:escape_only}s}
{"msg%{public}.0s":"ForeignKey reference", "isReferenceValid":%{public}hhd, "isIndexed":%{public}hhd}
{"msg%{public}.0s":"getColumnInfo", "table":%{private, location:escape_only}s, "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"getColumnInfo", "index":%{public}u, "name":%{public, location:escape_only}s, "type":%{public, location:escape_only}s, "isPrimaryKey":%{public}hhd}
{"msg%{public}.0s":"getColumnInfo", "table":%{private, location:escape_only}s, "name":%{public, location:escape_only}s, "isFound":%{public}hhd}
{"msg%{public}.0s":"Already in a transaction. DaemonStatus threading bug?", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "new":%{public, location:_CLDaemonStatusStateTrackerState}.*P}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "old":"%{public}p", "new":"%{public}p"}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "old":%{public, location:CLDaemonStatus_Type::Battery}.*P, "new":%{public, location:CLDaemonStatus_Type::Battery}.*P}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "old":%{public, location:CLDaemonStatus_Type::Reachability}lld, "new":%{public, location:CLDaemonStatus_Type::Reachability}lld}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "old":%{public}d, "new":%{public}d}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "old":%{public}hhd, "new":%{public}hhd}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "old":%{public, location:_CLDaemonStatusStateTrackerState}.*P, "new":%{public, location:_CLDaemonStatusStateTrackerState}.*P}
{"msg%{public}.0s":"state dump failure", "expected_size":%{public}lld, "provided_size":%{public}lld}
failed to set MetricHeartbeat activity as DONE.  current state is %{public}ld
locationd was started after an unclean shutdown
airplane mode not supported on non-embedded
{"msg%{public}.0s":"received IOKit notification", "sleepNotification":%{public, location:IOMessage}lld, "keepAliveClientCount":%{public}lu}
system has powered on
#warning No sleep state tranaction on has powered on
system can sleep request
system entering sleep
Sleep transaction grace timer still pending on will sleep
Already holding sleep state transaction on will sleep
system will power on
system exiting sleep
#warning No sleep state tranaction on will not sleep
MetricHeartbeat, notify
Notifying clients that migration is being performed
CL: CLDaemonStatus::onPowerNotification
{"msg%{public}.0s":"CLDaemonStatus::onPowerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
UclpMetric, celltileusage, attempts, %{public}d, als, %{public}d, tiles, %{public}d, unknown, %{public}d, alsreq, %{public}d, alscells, %{public}d, nCurrent, %{public}d, kbCurrent, %{public}.1f, nNeighbor, %{public}d, kbNeighbor, %{public}.01f
@Celltileusage, attempt, %{public}d, als, %{public}d, tiles, %{public}d, unknown, %{public}d
@Celltileusage, als, %{public}d, cells, %{public}d
@Celltileusage, download, isCurrent, %{public}d, size, %{public}d, nCurrent, %{public}d, kbCurrent, %{public}.1f, nNeighbor, %{public}d, kbNeighbor, %{public}.01f
Fence: No access to state DB
Fence: state No access to DB
Fence: state Invalid for DB
Fence: state store, %{private}lld, %{private}d, %{private}s
#Warning Fence: state couldn't bind statement (bundle ID %{public}s, name %{private}s)
Fence: state remove, %{private}lld, %{private}s
#Warning Fence: state couldn't bind statement for deleting (bundle ID %{public}s, name %{private}s)
Fence: state can't scrub DB
Fence: state scrub, remaining, %{public}lu
Fence: state couldn't bind state [%{public}s]/%{public}s/%{private}s
Fence: state doesn't exist [%{public}s]/%{public}s/%{private}s
Fence: state error in retrieving for [%{public}s/%{public}s/%{private}s
Fence: state get, %{private}lld, %{private}d, %{private}s
Type,WatchCals,binCadenceCenter,%{private}.2f,binState,%{private}d,binValue,%{private}.3f,predictedStrideLength,%{private}.3f
numCalsWatch,%d,offsetWatch,%.3f
Type,PhoneCals,binCadenceCenter,%{private}.2f,binState,%{private}d,binValue,%{private}.3f,predictedStrideLength,%{private}.3f
numCalsPhone,%d,offsetPhone,%.3f
Type,WalkingSpeed,binCadenceCenter,%{private}.2f,binState,%{private}d,binValue,%{private}.3f,predictedStrideLength,%{private}.3f
numCalsWalkingSpeed,%d,offsetWalkingSpeed,%.3f
Looking for metrics during bout,startTime,%{private}f,endTime,%{private}f,steps,%{private}u,metrics,%{private}lu
startTime,%.3f,walkingSpeed,%.3f
startTime,%.3f,walkingSpeed,%.4f,stepLength,%.4f,segmentSteps,%d,segmentCadence,%.4f,segmentEpochCadenceSD,%d,cycleTime,%.3f
Writing walkingSpeedCal,startTime,%{public}.3f,endTime,%{public}.3f,cadenceWatch,%{public}.3f,cadenceGaitCycle,%{public}.3f,meanWalkingSpeed,%{public}.3f,gaitCycleYield,%{public}.3f
Derived Vo2max, %.1f, Revised Vo2max, %.1f, Minimum Vo2max, %.1f, Beta Blocker Use, %d, Beta Blocker Vo2max, %.1f
Estimated HRmin, %.1f 
ModelInput, Larger than expected gap between begin and end ts.  Setting end ts to some sane default. (%f, %f)
ModelInput, Event time, %.2f, GPS sample time, %.2f, distance, %.2f, speed, %.2f, altitude, %.2f
ModelInput,gender,%d,height,%f,weight,%f,vo2max,%f,age,%f,hrmin,%f,hrmax,%f,hronset,%f,pal,%f,condition,%d,runVo2max,%f,betaBlockerUse,%d,biologicalSex,%d,isAgeSet,%d,isHeightSet,%d,isWeightSet,%d,adaptiveEMThresh,%f
Unsupported CLHKBiologicalSex value: %{private}d
Rejecting accessory on deny list: HARMAN
Rejecting accessory on deny list: Volkswagen AG, 1.0.0
Rejecting accessory on deny list: Volkswagen AG, 2.0.0
Rejecting accessory on deny list: BENTLEY
@AlsFlow, reply, tag, %{public}d, wifi, rtt, %{public}.1f, aps, %{public}lu, type, %{public}d
@AlsFlow, reply, tag, %{public}d, cell, rtt, %{public}.1f, %{public}s, %{public}d
AlsCell, cdma, rx, %{public}lu
AlsCell, cdma, %{public}d, unknown, %{private}s
AlsCell, cdma, %{public}d, valid, %{private}s, location, %{private}s
AlsCell, lte, rx, %{public}lu
AlsCell, lte, %{public}d, unknown, %{private}s
AlsCell, lte, %{public}d, valid, %{private}s, location, %{private}s
AlsCell, nr, rx, %{public}lu
AlsCell, nr, %{public}d, unknown, %{private}s
AlsCell, nr, %{public}d, valid, %{private}s, location, %{private}s
AlsCell, gsm, unbatched, %{public}lu
AlsWifi, unbatched, %{public}lu
Unknown pbrequester object received in delegate callback
AlsRequester, didFinish, payload, %lu, outstanding, %ld
@AlsFlow, reply, tag, %{public}d, error, rtt, %{public}.1lf, code, %{public}ld
query: received error for unknown requester type (tag %{public}d)
AlsRequester, didFailWithError, code, %s, outstanding, %ld
AlsRequester, finished, outstanding, %ld
AlsCell, gsm, rx, %{public}lu
AlsCell, gsm, %{public}lu, unknown, %{private}s
AlsCell, gsm, %{public}lu, valid, %{private}s, location, %{private}s
AlsCell, scdma, rx, %{public}lu
AlsCell, scdma, %{public}lu, unknown, %{private}s
AlsCell, scdma, %{public}lu, valid, %{private}s, location, %{private}s
AlsWifi, rx, %{public}lu
AlsWifi, unknown, %{private}s, %{public}lu, hasInfoMask, %{public}d, infoMask, 0x%{public}x
AlsWifi, valid, location, %{private}s, %{public}lu, %{private}s, score, %{public}d, channel, %{public}d, alt, %{public}.2lf, reach, %{public}d, hasInfoMask, %{public}d, infoMask, 0x%{public}x, type, %{public}d
AlsInit, server, %{private}s, override, %{public}d, timeout, %{public}d, log request/response, %{public}d, %{public}d
query: queryLocation, location, %14.8lf, %14.8lf, timeout, %d
query: queryLocation, tag, %d, location, %14.8lf, %14.8lf, timeout, %d, payload, %lu, reachability, %d, bands, %{public}@
@AlsFlow, request, tag, %{public}d, location, %{private}0.2lf, %{private}0.2lf, server, %{private}s, override, %{public}d, reach, %{public}d, watch, %{public}d
AlsWifi, tx, %{public}lu, %{public}lu, surronding, %{public}d, max, %{public}d
@AlsFlow, server, %{private}s, tag, %{public}d, override, %{public}d, reach, %{public}d, watch, %{public}d
@AlsFlow, request, tag, %{public}d, wifi, %{public}lu, surrounding, %{public}lu, bands, %{public}@
@AlsFlow, request, tag, %{public}d, cell, gsm, %{public}lu, lte, %{public}lu, cdma, %{public}lu, nr, %{public}lu, surrounding, %{public}lu
AlsCell, query, cdma, %{public}lu, gsm, %{public}lu, scdma, %{public}lu, lte, %{public}lu, nr, %{public}lu, max, %{public}d
#Warning query: don't have derivedMcc - using %d
query: Adding single derivedMcc %d
query: Adding multi derivedMcc %d
AlsCell, cdma, query, %{public}d, key, %{private}s
AlsCell, cdma, dropping, %{public}u, key, %{private}s, #CloneMe
AlsCell, gsm, query, %{public}d, key, %{private}s
AlsCell, gsm, dropping, %{public}u, key, %{private}s, #CloneMe
AlsCell, scdma, query, %{public}d, key, %{private}s
AlsCell. scdma, dropping, %{public}u, key, %{private}s, #CloneMe
AlsCell, lte, query, %{public}d, key, %{private}s
AlsCell. lte, dropping, %{public}u, key, %{private}s, #CloneMe
AlsCell, nr, query, %{public}d, key, %{private}s
AlsCell. nr, dropping, %{public}u, key, %{private}s, #CloneMe
AlsWifi, query, %{private}s, %{public}d
AlsWifi, dropping, %{private}s, %{public}u, #CloneMe
Unimplemented CDMA NetworkLocationRequester
nearby data query not supported
WifiCalc, zaxis, calculate uncertainty, empty accessPointWithWeights
WifiCalc, zaxis, calculate uncertainty, num accessPointWithWeights, %{private}d
WifiCalc, zaxis, calculate uncertainty, accessPointsWithValidWeights is empty
WifiCalc, zaxis, calculate uncertainty, num accessPointsWithValidWeights, %{private}d
WifiCalc, zaxis, calculate uncertainty, dSumWeightV, %{private}.2f, dSumWeightVSquare, %{private}.2f, dSumWeightedDeviation, %{private}.2f, altVarianceDivisor, %{private}.2f
WifiCalc, zaxis, MultiModal, detection failed
WifiCalc, zaxis, MultiModal, detected, max cluster centers, %{public}0.3f, %{public}0.3f, max weight, %{public}0.3f
WifiCalc, zaxis, reject outlier, num input accessPointWithWeights, %{private}d
WifiCalc, zaxis, reject outlier, accessPointsWithValidWeights is empty
WifiCalc, zaxis, reject outlier, num accessPointsWithValidWeights, %{private}d
WifiCalc, zaxis, reject outlier, medianAltitude, %{private}.2f, maxDeviationFromMedian, %{private}.2f, maxNumApsToReject, %{private}.1f, maxWeightsToReject, %{private}.2f
WifiCalc, zaxis, all aps filtered out due to weak rssi, add them back to yield a fix
WifiCalc, zaxis, num input aps, %lu, num valid unc aps, %lu
WifiCalc, zaxis, validUncApCollection is empty
WifiCalc, zaxis, all aps were non-slam, add them back to yield a fix
WifiCalc, zaxis, apCollection is empty
WifiCalc, zaxis, validRssiApCollection is empty
@WifiCalc, zaxis, num accessPointsToUseInCalculation, %{private}lu
WifiCalc, zaxis, isMultimodal, %{private}d
WifiCalc, zaxis, num aps after outlier rejection, %lu
WifiCalc, zaxis, maxRssi, %d
WifiCalc, est, %{private}0.3f, vunc, %{public}0.1f, numInputAps, %lu, numApsUsed, %lu, isSLAM, %d
WifiCalc, zaxis, inf unc
WifiCalc, zaxis, invalid signleshot alt, %{private}.2f, unc, %{private}.2f
WifiCalc, zaxis, invalid vertical accuracy!
#Warning WIFI_LOC: filtered by location hint, ap, %s, hint, %s
#Warning WIFI_LOC: revert hint, %lu, %lu
WifiCalc, b360repr, min, %{public}.1lf, max, %{public}.1lf
WifiCalc, outlieriter, %{public}d, dropped, %{public}d, verified, %{public}d
WifiCalc, counts, %{public}ld, %{public}ld, %{public}ld, %{public}ld, verified, %{public}d, hint, %{public}.1f, %{public}d
WifiCalc, invalid estimatedWorstCaseErrorMeters, estimatedWorstCaseErrorMeters, %{public}0.1f, hunc, %{public}0.1f, #Warning
WifiCalc, est, %{public}.1f, %{private}0.3f, %{private}0.3f, hunc, %{public}0.1f, estWorstError, %{public}0.1f, n, %{public}d, x, %{public}d
WifiCalc, b360repr, %{private}14.8lf, %{private}14.8lf
#Warning Overriding clear tables by age to %d for %s
Could not prepare cached insert statement
could not bind %.3f <%+.8f,%+.8f> %.2f
Could not prepare cached update statement
failed to setLocation, numModRows, %d, %s
Can't clear location for read-only database
could not bind %{public}lld
Can't clear locations in read-only database
Can't clear locations by age in read-only database
{"msg%{public}.0s":"CLLocationDatabase::clearLocationsByAge", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "age_s":"%{public}.09f", "tableName":%{private, location:escape_only}s}
Clearing locations older than %.3f from %s
%lld total entries deleted
Performing incremental vacuum on %s
VO2MaxHistory, DB not accessible
CMGyroBiasEstimator::reset: cold start
CMGyroBiasEstimator::reset: warm start [%f < %f]
CMGyroBiasEstimator::reset: dbias.x,%.2e,.y,%.2e,.z,%.2e,P.x,%.2e,.y,%.2e,.z,%.2e
CMGyroBiasEstimator: biasFitReset
CMGyroBiasEstimator::feedGyro: converged!
Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 210,variance() on empty buffer.
Couldn't get time zone for point <%+.8f,%+.8f>
Point <%+.8f,%+.8f> not in any time zone polygon; closest polygon is %f meters away; default time zone is %s, but we're not using it
Not in any polygons; falling back to closest nearby time zone ID %lld (distance %f, %ld possibilities)
Point <%+.8f,%+.8f> not in any time zone polygon; default time zone is %s, but we're not using it
#Warning Point <%+.8f,%+.8f> in multiple time zone polygons
Could not get time zone name for zone ID %{public}lld
Couldn't get list of candidates for point <%+.8f,%+.8f>
Couldn't determine if point <%+.8f,%+.8f> is in polygon %lld
Getting polygons for point <%+.8f,%+.8f> acc %.2f
#Warning fBoundingBoxesSelectNearbyStatement not available - rtree module missing or db unavailable
#Warning Ignoring bogus location <%+.8f,%+.8f>
Could not bind <%+.8f,%+.8f> - <%+.8f,%+.8f>
#Warning fNamesSelectStatement not available - rtree module missing or db unavailable
Could not bind %{public}lld
Could not get polygon name
#Warning No entry in names table for polygon ID %lld
#Warning fNamesSelectOnNameStatement not available - rtree module missing or db unavailable
#Warning Could not bind %s
#Warning Polygon %s not found in names table
#Warning No bounding box found for polygon %s
#Warning fPointsSelectStatement not available - rtree module missing or db unavailable
#Warning Could not bind %lld
#Warning No points data found for polygon Id %lld
#Warning fBoundingBoxesSelectStatement not available - rtree module missing or db unavailable
#Warning Could not bind polygon ID %lld
#Warning No bounding box found for polygon ID %lld
Dummy, Static, step count: %d, step distance: %f, activity: %d, type: %d, vm: %f
Sending along GPS time %.2f to CoreTime
BaroAlt,Realtime harvest,not supported
buildCFAbsoluteTime,%{public}.0f
Integrity Monitoring is Disabled
GpsWifiKeepAlive is no longer supported! If you want to leave all providers actively subscribed to, set DynamicLocationProviders to false
UseLocationKFAsDefaultProvider is set
CLMM,EnableMapMatching,%{public}d
CLMM,ForceMapMatching,%{public}d
dynamic location providers,%{public}d,accuracy,%{public}.2f,gps test mode,%{public}d,always notify,%{public}d
Applying KF to simulated locations for internal testing
location derived speed estimator enabled,%{public}d
could not create tech status run loop source
could not create check active run loop source
{"msg%{public}.0s":"CLLocationController registration", "client":%{public, location:escape_only}@, "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
#wigo,on,CLLocationController,%{public}d,%{public}s
#wigo,on,LocationController,%{public}d,%{public}s
{"msg%{public}.0s":"CLLocationController unregistration", "client":%{public, location:escape_only}@, "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
CLIENT:registerForNotificationInternal,notification,%{public}d,%{public}s,granularity,%{public}d
Before register,required granularity,%{public}d,active granularity,%{public}d
BATCH:unsupported platform
CLMM,RunMapMatching is turned on
@WsbReg, kNotificationWifiLocationBatched unsupported
registering notification,%{public}d,location provider,%{public}s
{"msg%{public}.0s":"register kNotificationExternalLocationDisablementAssert"}
{"msg%{public}.0s":"registering kNotificationExternalLocationDisablementAssert w/ accessory provider"}
CLIENT:registerForNotificationInternal,propagate,desiredAccuracy,%{public}.1lf,name,%{public}s,active,%{public}d,operating mode,%{public}d
CLIENT:unregisterForNotificationInternal,notification,%{public}d,%{public}s,granularity,%{public}d
Unregistered for notification,%{public}d,new required location granularity,%{public}d
After unregister,required granularity,%{public}d,active granularity,%{public}d
CLMM,RunMapMatching is turned off
unregistering notification,%{public}d,with,location provider,%{public}s
unregistering notification,%{public}d,location provider,%{public}s
{"msg%{public}.0s":"unregister kNotificationExternalLocationDisablementAssert"}
{"msg%{public}.0s":"unregistering kNotificationExternalLocationDisablementAssert w/ accessory provider"}
CLIENT:unregisterForNotificationInternal,propagate,desiredAccuracy,%{public}.1lf,name,%{public}s,active,%{public}d
Device going to sleep,stop location unavailable timer
Device wake setting location unavailable timer to fire at %{public}.3f
#Warning,Unhandled status notification,%{public}u
@ClxVersion, Init, os, %{public}s, model, %{private}s, build, %{public}s, triage, %{public}d
shutting down %{public}s location provider
#techstatus,signalling
Starting all location providers up to threshold,%{public}d,desiredAccuracy,%{public}.1lf
Not starting location provider,%{public}s,fRequiredLocationGranularity,%{public}d,fActiveLocationGranularity,%{public}d
Stopping all location providers above threshold %{public}d
Stopping all location providers that are worse than kDynamicLocationProvider %{public}d
got better location provider,%{public}d,NOT stopping worse location provider,%{public}d,isAccessorySpecialCase,1
got better location provider,%{public}d,NOT stopping worse location provider,%{public}d
got better location provider,%{public}d,stopping worse location provider,%{public}d
lost location from kDynamicLocationProvider,%{public}d,restarting all worse providers
restarting worse location provider kDynamicLocationProvider,%{public}d
#Warning,startLocation when provider is None
CLIENT:startLocation,registerForNotification,start reg info,client,%{public}p,desiredAccuracy,%{public}.1lf,name,%{public}s
#Warning, starting already active provider
registering location provider,%{public}s,as a bystander only
@ClxProvider, start, %{public}s, desiredAccuracy, %{public}.1f
WlpReg, 1, loccontroller
UclpReg, 1, loccontroller
#Warning,stopLocation when provider is None
Unregistering %s location provider as bystander
@ClxProvider, stop, %{private}s, desiredAccuracy, %{public}.1f
WlpReg, 0, loccontroller
UclpReg, 0, loccontroller
catch-all location unavailable timer fired
Location unavailable timer fired,required granularity is none,ignoring
#Warning,Location unavailable fired while sleeping
could not find provider from list
Got location unavailable notification for non-active provider,%{public}s,ignoring
Got location unavailable notification for location provider,%{public}s
provider,%{public}s,still available,lat,%{private}.7lf,lon,%{private}.7lf,lifespan,%{public}.1lf,age,%{public}.3fs
No location is available from any provider,notifying clients
Ignored: GPS warmup,runtime,%{public}.1fs,thresh,%{public}.1fs,age,%{public}.1fs,thresh,%{public}.1fs,gacc,%{public}.1fm,wacc,%{public}fm
#Warning,shouldNotify when provider is None
Got,lat,%{private}.7f,lon,%{private}.7f,for non-active location provider,%{public}s,ignoring
#Warning,Got future,lat,%{private}.7f,lon,%{private}.7f,from provider,%{public}s,age,%{public}.3fs,correcting to,%{public}.3fs
expiredLocation,provider,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,age,%{public}.3fs,lifespan,%{public}.1fs
current most confident provider,%{public}s,conf,%{public}d
#Warning,new,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with confident,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,age,%{public}.3f,distance,%{public}.2f,discarding
#Warning,new,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with current,%{public}s lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,notifying
new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,coarser and agrees with current,%{public}s, lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding
#Warning,new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,conflicts with current,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding
new,%s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,coarser than current,%{public}s,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.2f,conf,%{public}d,distance,%{public}.2f,discarding
got accessory,stopping everything less preferred,isShifted,%{public}d,isPropagatedSolution,%{public}d
changing to provider,%{public}s,from,%{public}s
unsupported location type,%{public}d
location rejected by IM,locationType,%{public}d,lat,%{private}.7lf,lon,%{private}.7lf
location rejected by KF,%{public}d,lat,%{private}.7lf,lon,%{private}.7lf
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,LocationTimestamp,%.3f,Age,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,SpeedAccuracy,%.3f,CourseAccuracy,%.1f,timestampGps,%.3lf,integrity,%d,referenceFrame,%d,rawReferenceFrame,%d
#Warning not notifying location with location derived speed
Notifying using location KF,but no location available
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,LocationTimestamp,%.3f,Age,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,SpeedAccuracy,%.3f,CourseAccuracy,%.1f,timestampGps,%.3lf,integrity,%d
DEM,query,%{private}.7f,%{private}.7f,HorUnc,%{public}.2lf,Type,%{public}d,%{public}s,Alt,%{private}.2f,AltUnc,%{public}.2f,GroundAlt,%{public}.2lf,GroundAltUnc,%{public}.2lf,Undulation,%{private}.3lf,UndulationModel,%{public}d,
@ClxClient, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, speed, %{private}.1f, course, %{private}.1f, type, %{public}d, alt, %{private}.1f, altunc, %{public}.1f,ellipsoidalAlt,%{private}.1f,speedUnc,%{private}.1f,courseUnc,%{private}.1f,signalEnv,%{private}d,timestamp,%{public}.3f
ClxMetric, islands, %{private}s, %{private}s
BaroAlt,LocCtrlOnEmergencyStateChange,isEmergency,%{public}d
%{public}.1lf,DeadReckoning,%{public}s,%{public}.2lf,Propagating solution,lastGPSTime,%{public}.2lf,lastAccessoryTime,%{public}.2lf
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,Speed,%.2f,Course,%.2f,Confidence,%d,Lifespan,%.3f,Altitude,%.1f,AltitudeAccuracy,%.1f,LocationTimestamp,%.3f,Age,%.3f,timestampGps,%.3lf,floor,%d,SpeedAccuracy,%.3lf,CourseAccuracy,%.1lf,integrity,%d,rawLat,%.7lf,rawLon,%.7lf,rawCourse,%.2f,refFrame,%d,rawRefFrame,%d,propagated,%d,gnssContent,%d,signalEnv,%d
{"msg%{public}.0s":"Notifying clients with location", "location":%{private, location:CLClientLocation}.*P, "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
#Warning,Notifying clients of an already-expired location,age,%{public}.3f
GPSODOM,timestamp,%{public}.3lf,timestampGps,%{public}.3lf,odometer,%{public}.3lf,deltaDist,%{public}.3lf,deltaDistUnc,%{public}.3lf,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.1lf,alt,%{private}.3lf,vunc,%{public}.1lf,speed,%{public}.3lf,sunc,%{public}.3lf,course,%{public}.3lf,cunc,%{public}.3lf
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%{public}d,%{public}s,Speed,%{public}.2f,Course,%{public}.2f,Confidence,%{public}d,Lifespan,%{public}.3f,LocationTimestamp,%{public}.3f,Age,%{public}.3f,Altitude,%{private}.3f,AltitudeAccuracy,%{public}.3f,SpeedAccuracy,%{public}.3f,CourseAccuracy,%{public}.1f,timestampGps,%{public}.3lf,integrity,%{public}d,undulation,%{private}.3lf,undulationModel,%{public}d,referenceFrame,%d,rawReferenceFrame,%d
Accessory,propagated on-device GPS,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%{public}.1lf
Wifi2 provider active, but pipelined not activated
Indoor provider active, but pipelined not activated
GPSController indicates hardware active while client is not active
#techstatus,enquired,sz,%{public}zu,gpsClientActive,%{public}d,gpsHwActive,%{public}d
Setting simulation to %{public}d for all location providers
#techstatus,posting notification
Notifying clients of providers active update to %{public}d
#Warning,Clearing all location data from the controller
#Warning,Location Services reset,clearing local cache
@ClxNotify, LpReset, 0
#Warning,Location Services state changed,clearing local cache
CLIENT:hasClients,%{public}d,hasFineClients,%{public}d,hasCoarseClients,%{public}d,desiredAccuracy,%{public}.1lf
@ClxEvent, %{public}s, %{public}d, delta, %{public}.1f
@ClxVersion, Timer, os, %{public}s, model, %{private}s, build, %{public}s, triage, %{public}d
@ClxSnapshot, %{public}s, %{public}d, last, %{public}.1f, delta, %{public}.1f
CLLocationController,gnssPredictedAvailability,%{public}d,probability,%{public}.3f,timestamp,%{public}.3f
CL: CLLocationController::onStatusNotification
{"msg%{public}.0s":"CLLocationController::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::onWifiServiceNotification
{"msg%{public}.0s":"CLLocationController::onWifiServiceNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::onClientNotification
{"msg%{public}.0s":"CLLocationController::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::onDataProtectionNotification
{"msg%{public}.0s":"CLLocationController::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::onBluetoothNotification
{"msg%{public}.0s":"CLLocationController::onBluetoothNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::onCompanionNotification
{"msg%{public}.0s":"CLLocationController::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::sendTechStatusNotification
{"msg%{public}.0s":"CLLocationController::sendTechStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::checkActiveProviders
{"msg%{public}.0s":"CLLocationController::checkActiveProviders", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::onWifiNotification
{"msg%{public}.0s":"CLLocationController::onWifiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::onAccessoryNotification
{"msg%{public}.0s":"CLLocationController::onAccessoryNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationController::onSimulatedNotification
{"msg%{public}.0s":"CLLocationController::onSimulatedNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
notifier adapter received emergency state %s
@ClxWifi, supported, %{public}d
WlpMetric, ClearAls
@WifiLogic, entry, register, notification, %{public}s, lsb, %{public}d, %{public}d, %{public}d
@WifiLoc, miscregister, %{public}s
@WifiEntry, register for odometer notification
@WifiLogic, entry, unregister, notification, %{public}s, lsb, %{public}d, %{public}d, %{public}d
@WifiLoc, miscunregister, %{public}s
@WifiEntry, unregister for odometer notification
@WifiEntry, noregistrants
@WifiLogic, entry, clienttimer
@WifiLogic, entry, wsbtimer
@WifiLogic, entry, requestLocationUpdate, %{public}s
@WifiLogic, entry, wifiNotify, %{public}s
@WifiLogic, entry, odometer, %{public}d,
received odometer update entry,startTime,%{public}lf,elevationAscended,%{public}u,elevationDescended,%{public}u,now,%{public}.lf
#Warning,received invalid elevation entry,startTime,%{public}lf,elevationAscended,%{public}u,elevationDescended,%{public}u
@WifiLogic, entry, motion
@WifiLogic, entry, signalEnvironment
@WifiLogic, entry, clientNotify
@WifiLogic, entry, alsNotify
@WifiLogic, entry, reach, %{public}d
@WifiLogic, entry, batterysaver, %{public}d
@WifiLogic, entry, wake
@WifiLogic, entry, heartbeat
@WifiLogic, entry, companionnearby, %{public}d
@WifiLogic, entry, locationNotify
@WifiLogic, entry, emergencyState
@WifiLogic, handleInput, %{public}s
@WifiLogic, decision, newUpdate, didStart, %{public}d
@WsbReproc, reason, %{public}s
@WifiLogic, decision, reprocWsb
@WifiLogic, decision, alsreq
@WifiLogic, decision, alswsb, aps, %{public}lu
{"msg%{public}.0s":"requesting wifi scan", "scan_type":%{public}d, "priority":%{public, location:escape_only}s, "latency":%{public, location:escape_only}s, "scan_request_successful":%{public}hhd}
value of didStartScan being reset to false after successfully beginning a scan
@WifiLogic, decision, scanreq, didStart, %{public}d
@WifiLogic, decision, wifipower, %{public}s
{"msg%{public}.0s":"requesting wifi tile download", "latitude":"%{private}f", "longitude":"%{private}f"}
@WifiLogic, decision, tiledl, %{private}.02f, %{private}.02f
{"msg%{public}.0s":"update schedule of refresh timer", "delay_s":"%{public}.09f"}
@WifiLogic, decision, timer, %{public}.1f, reIssue, %{public}d
@WifiLogic, decision, wsbtimer, %{public}.1f
@WifiLogic, decision, timer, cancel
@ClxWifi, Fix, 0, ll, N/A
@WifiLogic, decision, notifyUnavail
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Confidence,%d,TTF,%.3f,sinceReg,%.3f,Confirmed,%d,Altitude,%.2f,VerticalAccuracy,%.2lf,locationSimulated,%d,notifiedLocationAge,%f,integrity,%d
@ClxWifi, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, course, -1.0, alt, %{private}.1f, altunc, %{public}.1f, time, %{public}.1f
@WifiLogic, decision, notifyLoc
{"msg%{public}.0s":"should not send out an empty container of batched wifi locations", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
notifying clients of %{public}ld batched wifi locations
WsbCalc, notify, %{public}lu
@WifiLogic, decision, notifyBatched
@WifiFlow, nexttimer, %{public}d
@WifiFlow, nexttimer, off
%s is deprecated. setting this has no effect
CellFlow, compute, cells, %{public}zu, spectators, %{public}d, last, %{public}.1lf, type, %{public}d
CellMatch, invalid cell, %{public}s, #CloneMe
CellMatch, ignoring cell, %{private}s
CellMatch, best network, %{public}s, %{private}s, location, %{private}s
CellMatch, best tile, %{public}s, location, %{private}s
CellMatch, prefer, %{private}s, %{public}s, levels, %{public}s, %{public}s, als, %{public}d
@CellFlow, match, %{private}s, %{public}s, %{public}s, rat, %{public}s, needsAls, %{public}d
@CellFlow, counts, in, %{public}lu, sortIn, %{public}lu, sortOut, %{public}lu, shouldQuery, %{public}d
CellMatch, preferred cell matches, in ascending order, %{private}s, %{private}s
UclpMetric, fixattempt, %{public}s, %{public}s, %{public}s, acc, %{private}.0f, %{public}s, %{public}s, submit10, %{public}d
CellFlow, fix, %{private}s, acc, %{private}.0f, %{public}s, %{public}s, %{public}s, %{public}s, notify, %{public}d, deploymentType, %{public}d, %{public}s
reference frame is not properly set
confidence is not properly set
@ClxCell, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, course, -1.0, key, %{private}s, type, %{public}d
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Confidence,%d,Lifespan,%.3f,SubType,%s,MatchLevel,%d,cell,%s,Transmit,%d,integrity,%d
@CellLoc, tiledl, cells, %{public}lu, gsm, %{public}d, cdma, %{public}d, lte, %{public}d
CellLoc, requestDownload, GSM, %.8f, %.8f, seckey, %llu
CellLoc, requestDownload, CDMA, %.8f, %.8f, seckey, %llu
CellLoc, requestDownload, LTE, %.8f, %.8f, seckey, %llu
@ClxCell, Fix, 0, ll, N/A, Unknown, %{private}s, querying, %{public}d
CellFlow, skipreqwifi, locationclients, %{public}d
CellLoc, Invalid rat, %{public}d, %{public}s, #CloneMe
{"msg%{public}.0s":"both cell locations should have equal validity", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"both cell locations should be type Cell or LAC", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"cells should be a pair of GSM/CDMA or a pair of non-GSM/CDMA cells", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"cells should be a pair of LTE or a pair of non-LTE cells", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Workout, Taking power assertion due to session start.
Workout, Releasing power assertion due to session end.
Workout, Releasing power assertion due to a session pause event.
Workout, Taking power assertion due to a session resume event.
#gfc didExitGeoFence() received in adapter
#gfc didTimeout() received in adapter
IndoorOutdoor detector running without turn detector.
Enabled device motion.
Disabled device motion.
Starting turn detector
Stopping turn detector
Wifi timer already existed, reinitializing.
Starting Wifi Scans.
Triggering Wifi Scan.
Stopping Wifi Scans.
IndoorOutdoor, starting indoorOutdoor
IndoorOutdoor, stopping indoorOutdoor
IndoorOutdoor,new location type,%{public}ld,confidence,%{public}ld,probability,%{public}f
IndoorOutdoor, issuing notification old (%s, %s) new (%s, %s)
Workout, Receiving addClientForPrepareSessionEnd after client list has been deleted!
Workout, Receiving removeClientForPrepareSessionEnd after client list has been deleted!
Workout, Client for PrepareSessionEnd of session type %d does not exist!
Workout, Prepared session client, end for session, %d, duration (s), %f, success, %d
#gfc started workout, starting geofence with radius %{public}f
#gfc stopped workout, stopping geofence
Workout,Setting suggested stop timeout for workout,%f
User dismissed current workout alert.
#gfc didExit recieved in msm, stopping, current workout in session %{public}d
#gfc didTimeout recieved in msm, stopping, current workout in session %{public}d
Unsupported escalation type reported for metrics, %d
MotionStateMediator received unhandled odometer notification, %d
Watch orientation settings updated,crown,%{public}d,wrist,%{public}d
Battery connected state %{public}d
{"msg%{public}.0s":"Current Activity Move Mode changed", "from":%{public, location:CLFitnessTrackingNotifier_Type::ActivityMoveMode}lld, "to":%{public, location:CLFitnessTrackingNotifier_Type::ActivityMoveMode}lld}
{"msg%{public}.0s":"Workout Alert Enabled - MotionStateMediator", "Start":%{public}hhd, "Stop":%{public}hhd}
VehicularConfidence,%{public}d
{"msg%{public}.0s":"Received Motion Calibration & Distance", "permission":%{public}hhd}
Received an authorization notification %{public}d. Checking bundle permissions.
Enabling tier1 cycling features message sending
Disabling tier1 cycling features message sending
CL: CLMotionStateMediator::onOldMotionCoprocessorData
{"msg%{public}.0s":"CLMotionStateMediator::onOldMotionCoprocessorData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onActivePedStateCoprocessorData
{"msg%{public}.0s":"CLMotionStateMediator::onActivePedStateCoprocessorData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onWatchElevationCoprocessorData
{"msg%{public}.0s":"CLMotionStateMediator::onWatchElevationCoprocessorData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onAveragedAlsData
{"msg%{public}.0s":"CLMotionStateMediator::onAveragedAlsData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onTier1CyclingFeaturesData
{"msg%{public}.0s":"CLMotionStateMediator::onTier1CyclingFeaturesData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onCalorimetryNotification
{"msg%{public}.0s":"CLMotionStateMediator::onCalorimetryNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onSkiNotification
{"msg%{public}.0s":"CLMotionStateMediator::onSkiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onWatchOrientationSettingsNotification
{"msg%{public}.0s":"CLMotionStateMediator::onWatchOrientationSettingsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onDaemonStatus
{"msg%{public}.0s":"CLMotionStateMediator::onDaemonStatus", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onCatherineNotification
{"msg%{public}.0s":"CLMotionStateMediator::onCatherineNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onFitnessTrackingNotification
{"msg%{public}.0s":"CLMotionStateMediator::onFitnessTrackingNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onMotionStateObserverNotification
{"msg%{public}.0s":"CLMotionStateMediator::onMotionStateObserverNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onLocationNotification
{"msg%{public}.0s":"CLMotionStateMediator::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onClientManagerNotification
{"msg%{public}.0s":"CLMotionStateMediator::onClientManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onDataProtectionNotification
{"msg%{public}.0s":"CLMotionStateMediator::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onDeviceMotionData
{"msg%{public}.0s":"CLMotionStateMediator::onDeviceMotionData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onWifiNotification
{"msg%{public}.0s":"CLMotionStateMediator::onWifiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateMediator::onOdometerNotification
{"msg%{public}.0s":"CLMotionStateMediator::onOdometerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
activate src %s
deactivate src %s
time rollback on add, newItemTime, %f, lastItemTime, %f
disable message src %s
Input, Elevation, time stamp, %.2lf, elevationAscended, %d, elevationDescended, %d, source, %d
Input, Elevation, beyond time window, buffer size, %lu, deltaTime, %f
Input, Elevation, Online grade estimation regime change, time start, %.2lf, elevationAscended, %d, elevationDescended, %d,input_altitude, %.4f, Prediction Error, %.4f
Input, Elevation, Online grade estimation, gradeType, %d, time start, %.2lf, altitude delta, %.2f, vspeed, %.2f, fParam_m, %f, fParam_b, %f,fTimeBufferFront, %f,fTimeBufferBack, %f, elevationAscended, %d, elevationDescended, %d, input_altitude, %.4f
Input, Elevation, Hardware gradeTypeFilter, gradeType, %d, vspeed, %.4f
enable message src %s
CL: CLMotionStateMediator::onWorkoutPredictorUpdate
{"msg%{public}.0s":"CLMotionStateMediator::onWorkoutPredictorUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Failed to updateRegistrationInfoForClient %p (%d)
Failed to registerForFilteredLocation %{public}p (%{public}d, %{public}d, %{public}f)
#Warning provider %s disabled - will run but not send locations to clients
 Location Provider (%s) set to (%d)
CLIENT: registerForNotification, register for notification, %d, %s, desiredAccuracy, %.1lf, operatingMode, %d
Wrong registration method called!
CLIENT: updateRegistrationInfoForClient, client, %d, notification, %d, %s, from desiredAccuracy, %.1lf, to, %.1lf
CLIENT: updateRegistrationInfoForClient, client, %d, notification, %d, %s, no notification
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Type,%d,%s,LocationTimestamp,%.3f,Age,%.3f,Lifespan,%.3f,
Ignoring location for %s
Provider %s is notifying clients (type=%d) of an invalid position (<%+.8f,%+.8f>)
Provider %s is notifying clients (type=%d) of an invalid altitude %.2f (accuracy %.2f)
Provider %s is notifying clients (type=%d) of a <0,0> position
#Warning Should not be sending coarse and fine notifications directly
Sending location unavailable notification through for %s
Sending through simulated location for %s
Simulation is now %s for %s
Notifying
#Warning Database is not valid; not initializing
failed to bind %{public}s
CELL_LOC: fInsertStatement [%s]
could not bind
Tier2Smoother, tracking alternate walk escalation
Tier2Smoother, set rapid walking detection, %{public}d
Tier2Smoother attemped de-escalating due to Unknown calls in Tier 2 Classifier
Tier2Smoother swimcheck, insufficient samples in range start %{public}f, end %{public}f, num %zu
Tier2Smoother swimcheck,waterOccluded,%{public}d,startTime,%{public}f,averageNow,%{public}f,,averageHistorical,%{public}f
Tier2Smoother swimcheck, failed to get first entry
Tier2Smoother, bypassing exercise minute requirements for sustained walking
Tier2Smoother,passed unknown threshold of %d
Tier2Smoother,briskCheck,startTime,%{public}f,endTime,%{public}f,numExerciseMinutes,%{public}u,threshold,%{public}d
Tier2Smoother attempted de-escalating due to no Running calls in Tier 1 Classifier
Tier2Smoother,ped auto-stop detected,%{public}d,ped de-escalation from exercise minutes,%{public}d
Tier2Smoother,WorkoutPauseFlags,flagLastEpochsUnknown,%d,flagNoPatternInTier1,%d,flagNoCurrentStateInLastEpochs,%d
Tier2Smoother, resetting pedestrian stop detector FSM
%s,%f,%s,%f,%s,%f,%s,%f
weatherEstimateWithRebase is %f weatherEstimateFromSigElevation is %f timestamp is %f cumulativeAscendingDelta is %f cumulativeDescendingDelta is %f
new centroid: latitude %f, longitude %f
updated pressure uncertainty due to distance %f by %f uncertainty now is %f
updated bias location latitude %f longitude %f
updated visit status for bias estimator, %d, step count timestamp, %f, current time, %f
updated weather drift due to time, %f, sig elev state, %d, inVisit, %d
updated pressure uncertainty due to time: timestamp %f _biasTimestamp %f _biasUncertaintyTimestamp %f by %f uncertainty now is %f
term1 %f, dElevationdPresureSA(pmeas) %f std::abs(_pressureUncertainty) %f pmeas %f
term2 %f, slopeDiffDElevationDPressureSA(pbias) %f std::abs(pressure - _biasPressure) %f
term3 %f, slopeDiffDElevationDPressureSA(pmeas) %f std::abs(_pressureUncertainty %f
total bias uncertainty %f
pressure too far from reference data
individual bias calculated from DEM: %f, DEM timestamp %f,  DEM altitude %f, DEM uncertainty %f, pressure timestamp %f, pressure altitude %f
pressure height rebase to type %d new bias is %f new bias uncertainty is %f old baroAlt is %f old refAlt is %f old baroUncertainty is %f old refUncertainty is %f weatherEstimateInMeter is %f calculated from track start at %f end at %f DEMpoints %d underDEMPoints %d
track is too old, don't rebase, startTime %f, endTime %f
companion data found, altitude %f, timestamp %f
pressure too far from companion data
individual bias calculated: %f, companion timestamp %f,  companion altitude %f, pressure timestamp %f, pressure altitude %f
new bias calculated from companion is %f, average baroAlt %f, average companion alt %f, average pressure %f, timestamp %f
individual bias error: reference Uncertainty < 0 and no DEMS, location timestamp %f, location altitude %f, location DEMS %f
individual location data: type %d location timestamp %f pressure timestamp %f location altitude %f pressure altitude %f location verticalUncertainty %f horizontalUncertainty %f lat %f lon %f current bias %f track start at %f end at %f isPrefilteredLocation %d fSlope %f maxAbsSlope %f fSpeed %f fSpeedAccuracy %f fEnvironment %d fMatchQuality %d altitude %f verticalAccuracy %f rawAltitude %f rawVerticalAccuracy %f
individual bias calculated: %f, location timestamp %f, pressure timestamp %f, location altitude %f, DEM altitude %f, pressure altitude %f
cross entropy of type %d is %f calculated from baroAlt is %f refAlt is %f baroUncertainty is %f refUncertainty is %f track start at %f end at %f
pressure height rebase to type %d new bias is %f new bias uncertainty is %f old baroAlt is %f old refAlt is %f old baroUncertainty is %f old refUncertainty is %f weatherEstimateInMeter is %f calculated from track start at %f end at %f
significant elevation rebase: %s,%f
received entry visit, shouldTakeMax updated to, %d, timestamp, %f
saving rebase info to cache, timestamp %f, bias, %f, uncertainty, %f, weather estimate, %f, sig elevation, %f, pressure, %f
recovering from locationd crash, timestamp %f, bias, %f, uncertainty, %f, weather, %f, sig elev, %f, pressure, %f
state is too old to be recovered
{"msg%{public}.0s":"MaxMETs,MET Minutes", "total count":%{private}ld, "Max. METs":"%{private}f"}
{"msg%{public}.0s":"MaxMETs,Setting query range", "start_s":"%{private}.09f", "end_s":"%{private}.09f"}
{"msg%{public}.0s":"MaxMETs,query,", "error":%{public}d}
WifiFlow, reset, last, %{public}d
WifiStep, same, %{public}s
WifiFlow, step, %{public}s, from, %{public}s, donereason, %{public}s
WlpMetric, request, %{public}s, %{public}s, done, %{public}s, fix, %{public}s, tt, %{public}s, %{public}s, durint, %{public}s, %{public}s, als, %{public}d
@WifiFlow, outcome, %{public}s
read only database - not creating bounding boxes, tableName, %s
platform does not support WiFi location monitoring - not creating bounding boxes, tableName, %s
{"msg%{public}.0s":"failure to bind", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"failure to bind row_id", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
failed to execute statement properly
Unknown WiFi AP. %s
No valid WiFi AP location. %s
Coarse wifi query fence key, %d, aps, %ld
invalid return value getting size of WifiLocation table
NETWORK: fIsUseEVDOTransmittedLocations = %d
NETWORK: fIsExponentialRetryTimer, %d
fServerRefreshInterval, %.1lf
Scheduling purge for %.3f and checking every %.3fs for older than %.3fs
NETWORK: stats: cellsQueried, %d, wifisQueried, %d, locationsQueried, %d, totalRequests, %d, totalRequestsSuccessful, %d
NETWORK: check reschedule, fQueryRetries, %d, sinceLastRetry, %.1lf
cell %03d %03d 0x%x 0x%x is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> %.2fm apart - using local
CELL_LOC: cell, %s, has local, but no remote - querying
CELL_LOC: found, %d, server, %d, cell, %s, location, %s
CELL_LOC: scdma, found, %d, server, %d, cell, %s, location, %s
CELL_LOC: failed get location for, %s
CELL_LOC: best match cell, %s, bestMatch, %d
CELL_LOC: SCDMA full match 0, %s, %s
CELL_LOC: SCDMA match 1, %s, %s
CELL_LOC: SCDMA match 2, %s, %s
CELL_LOC: SCDMA match 3, %s, %s
CELL_LOC: SCDMA match 4, %s, %s
CELL_LOC: SCDMA NO MATCH, %s
CELL_LOC: GSM full match 0, %s, %s
CELL_LOC: GSM match 1, %s, %s
CELL_LOC: GSM match 2, %s, %s
CELL_LOC: GSM match 3, %s, %s
CELL_LOC: GSM match 4, %s, %s
CELL_LOC: GSM NO MATCH, %s
CELL_LOC: LTE full match 0, %s, %s
CELL_LOC: LTE match 1, %s, %s
CELL_LOC: LTE match 2, %s, %s
CELL_LOC: LTE match 3, %s, %s
CELL_LOC: LTE match 4, %s, %s
CELL_LOC: LTE NO MATCH, %s
CELL_LOC: NR full match 0, %s, %s
CELL_LOC: NR match 1, %s, %s
CELL_LOC: NR match 2, %s, %s
CELL_LOC: NR match 3, %s, %s
CELL_LOC: NR match 4, %s, %s
CELL_LOC: NR NO MATCH, %s
CELL_LOC: match 8 (%s)
CELL_LOC: match 5.1 (%s)
CELL_LOC: match 7 (%s)
CELL_LOC: match 4.1 (%s)
CELL_LOC: match 4.2 (%s)
CELL_LOC: match 3 (%s)
CELL_LOC: match 2 (%s)
CELL_LOC: match 1 (%s)
CELL_LOC: match sector location, %s, location, %s
CELL_LOC: avoid using transmitted locations
CELL_LOC: NO MATCH (%s)
CELL_LOC: found in DB (%s) loc (%lf %lf) acc (%lf)
CELL_LOC: cell %03d %03d 0%03d %03d %03d is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> %.2fm apart - using local
CELL_LOC: cell, %s, has local, but no remote - not querying, server doesn't server these
CELL_LOC: cell, %s, has local, but no remote -  pending query
CELL_LOC: cell, [%s], is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> %.2fm apart - using local
CELL_LOC: cell, %s, has local, but no remote -  querying
CELL_LOC: cell, [%s], is local <%+.8f, %+.8f> remote <%+.8f %+.8f> %.2fm apart - using local
CELL_LOC: cell (%s) is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> only %.2fm apart - not storing locally
CELL_LOC: cell (%s) is local at <%+.8f,%+.8f>
cell %03d %03d 0x%x 0x%x is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> only %.2fm apart - not storing locally
cell %03d %03d 0x%x 0x%x is local at <%+.8f,%+.8f>
#Warning Location Services disabled, not storing location entry
scdma cell %03d %03d 0x%x 0x%x is local <%+.8f,%+.8f> remote <%+.8f,%+.8f> only %.2fm apart - not storing locally
scdma cell %03d %03d 0x%x 0x%x is local at <%+.8f,%+.8f>
CELL_LOC: distance, %.1lf, not storing locally, %s, location, %s
CELL_LOC: distance, %.1lf, override local location, %s, location, %s
@AlsFlow, query, in, cells, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, wifi, %{public}lu, cache, %{public}d, piggyback, %{public}d
@AlsFlow, query, skip, private
@AlsFlow, query, skip, bigswitch
@AlsFlow, query, skip, connectivity
CELL_LOC: cdma cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: cdma cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: cdma cell, %s, re-querying
CELL_LOC: gsm cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: gsm cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: gsm cell, %s, re-querying
CELL_LOC: scdma cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: scdma cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: scdma cell, %s, re-querying
CELL_LOC: lte cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: lte cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: lte cell, %s, re-querying
CELL_LOC: nr cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: nr cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying
CELL_LOC: nr cell, %s, re-querying
AlsWifi, query, in, %{public}lu, paths, %{public}d, %{public}d, %{public}d, out, %{public}lu
@AlsFlow, query, made, %{public}d, cells, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, wifi, %{public}lu, nearby, %{public}d
AlsWifi, pending, %{private}s, from, %{public}.3f, %{public}.3fs
AlsWifi, clearpending, %{public}ld, #CloneMe
#Warning CELL_LOC: %ld pending gsm cells, clearing
CELL_LOC: pending gsm cell, %s, from, %.3f, %.3f, ago)
#Warning CELL_LOC: %ld pending scdma cells, clearing
CELL_LOC: pending scdma cell, %s, from, %.3f, %.3f, ago)
#Warning CELL_LOC: %ld pending cdma cells, clearing
CELL_LOC: pending cdma cell, %s, from, %.3f, %.3f, ago)
#Warning CELL_LOC: %ld pending lte cells, clearing
CELL_LOC: pending lte cell, %s, from, %.3f, %.3f, ago)
#Warning CELL_LOC: %ld pending nr cells, clearing
CELL_LOC: pending nr cell, %s, from, %.3f, %.3f, ago)
@AlsFlow, requery, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, items, fQueryRetries, %{public}d, fLastRetryTimestamp, %{public}.1lf
#Warning NETWORK: in private location mode; not querying for unknown cells or unknown wifis
#Warning NETWORK: Location Services disabled, not querying location
NETWORK: re-querying cells, %lu, %lu, %lu, %lu, %lu, wifis, %lu, retry count, %d
Nlp, isBroadConnection, %{public}d, reachability, %{public}d, dataAccessTech, %{public}ld, %{public}ld
#Warning in private location mode; not querying for unknown cells or unknown wifis
#Warning Location Services disabled, not querying location
@AlsFlow, querynearby, skip, connectivity
CELL_LOC: start sequence, This, %p
CELL_LOC: beginning cell database
CELL_LOC: ending cell database (%lu cells still pending)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,LAC,0x%x,CI,0x%x,Confidence,%d,Count,%d,lock,%d
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,LAC,0x%x,CI,0x%x,
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,SID,%03d,NID,%03d,BSID,%03d,Confidence,%d,Count,%d,lock,%d
CELL_LOC: server response cell(%s) loc (%lf %lf) acc(%lf)
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,SID,%03d,NID,%03d,BSID,%03d
CELL_LOC: server response lte cell, %s, location, %s
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,TAC,0x%x,CI,0x%x,Confidence,%d,Count,%d,lock,%d
NETWORK: pending, known, before, %lu, cell, %s
NETWORK: pending, known, after, %lu, cell, %s
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,TAC,0x%x,CI,0x%x,
NETWORK: pending, unknown, before, %lu, cell, %s
NETWORK: pending, unknown, after, %lu, cell, %s
CELL_LOC: server response nr cell, %s, location, %s
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,TAC,0x%x,CI,0x%llx,Confidence,%d,Count,%d,lock,%d
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,MCC,%03d,MNC,%03d,TAC,0x%x,CI,0x%llx,
AlsWifi, seriesComplete, known, %{public}lu, unknown, %{public}lu
{"msg%{public}.0s":"Nearby request complete without keys for the tag", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"At least one fence key required", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
AlsWifi, seriesComplete, tags remain, %{private}zu, keys, %{private}zu
Extra 5GHz #als response, mac, %s, channel, %d, isNearbyQuery, %d, fDataProtectionEnabled, %d
{"msg%{public}.0s":"Partial numer of ALS aps saved"}
#Warning Location Services disabled, not storing location entries
NETWORK: stats: onLocationRequesterResponse, %d
#Notice NETWORK: no response from server, reachability, %{public}d, queryRetries, %{public}d
NETWORK: data reachability is not available - not retrying
NETWORK: retry query, %d, %d
NETWORK: retry count %d exceeded %d - not retrying
NETWORK: query failed for nearbys - not retrying
NETWORK: query: finished, tag, %d, cells, %d, wifis, %d
NETWORK: onStatusNotification, kNotificationReachability, from, %d, to, %d
@ClxLink, reach, %{public}d, last, %{public}d, retries, %{public}d
trimming pending gsm, %lu, scdma, %lu, cdma, %lu, lte, %lu, wifis, %lu, nr, %lu, to, %d
@AlsFlow, query, internal, cells, %{public}lu, %{public}lu, %{public}lu, %{public}lu, %{public}lu, wifi, %{public}lu, skipnearby, %{public}d
query, broadDataConnection, %d, timeout, %d
#Warning Location Services reset, clearing all local cache
#Warning Location Services disabled, clearing all local cache
onCompanionNotification, notification, %d
@ClxLink, Nearby, %{public}d
Data protection is now %s
Nlp, received %{public}s
Purging entries older than %.2fs.
NETWORK: onRetryTimer, %s, %p, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, %lu
NETWORK: areQueryRetriesNeeded, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, %lu, currentRetry, %d, sinceRetrySequenceStart, %.2lf, needed, %d
NETWORK: scheduleRetryTimer, retry timer already scheduled
NETWORK: scheduleRetryTimer, %s, %p, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, %lu, timerInterval, %.1lf, isTimerNeeded, %d
NETWORK: cancelRetryTimer, %s, %p, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, %lu
NETWORK: cancelRetryTimer, no retry timer
NETWORK: resetRetryCounters, sinceLastReset, %.1lf
NETWORK: resetRetryCounters, %s, %p, fQueryRetries, %d, pending, %lu, %lu, %lu, %lu, %lu, sinceLastReset, %.1lf
CL: CLNetworkLocationProvider::onLocationRequesterCellLocationSeries
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterCellLocationSeries", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterCellLocation
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterCellLocation", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterCellLocationUnknown
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterCellLocationUnknown", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterWifiLocationSeriesComplete
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterWifiLocationSeriesComplete", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterResponse
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterResponse", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterLocationError
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterLocationError", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterNearbyError
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterNearbyError", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterFinished
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterFinished", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterCdmaCellLocation
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterCdmaCellLocation", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterCdmaCellLocationUnknown
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterCdmaCellLocationUnknown", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterLteCellLocation
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterLteCellLocation", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterLteCellLocationUnknown
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterLteCellLocationUnknown", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterNrCellLocation
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterNrCellLocation", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterNrCellLocationUnknown
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterNrCellLocationUnknown", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterScdmaCellLocation
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterScdmaCellLocation", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onLocationRequesterScdmaCellLocationUnknown
{"msg%{public}.0s":"CLNetworkLocationProvider::onLocationRequesterScdmaCellLocationUnknown", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNetworkLocationProvider::onPurgeTimer
{"msg%{public}.0s":"CLNetworkLocationProvider::onPurgeTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Warning ignoring second MCC %d %d
NETWORK: cleaning, curEntryAge, %.1lf, ageThreshold, %.1lf
Failed to find entry from in-memory database, table, %{public}s, type %{public}s, rowid, %{public}lld
Failed to save entry to persisted database, table %{public}s
Failed to migrate in-memory database to persisted.
Successfully migrated %u rows from in-memory database to persisted for table %s
{"msg%{public}.0s":"Persistent subscription persistence must be set exactly once and set to a non-null value", "fPersistence":%{public}hhd, "persistence":%{public}hhd, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLMobility::ModelFusion::Result,classificationEnd,%{public}.2f,rawSteadiness,%{public}.2f,walkingSteadiness,%{public}.2f,successfulModelCount,%{public}lu
fuseLikelihoods using mean log odds fusion rule, modelLikelihoods count,%{public}lu
No component models to fuse likelihoods
Unexpected model likelihood OK,%{public}.2f and/or NotOK,%{public}.2f
CLExerciseMinuteIntensityEstimator::feedNatalie called, rawMets, %f
CLExerciseMinuteIntensityEstimator::feedBodyMetrics called
CLExerciseMinuteIntensityEstimator::feedBodyMetrics, threshold, %f, scalingFactor, %f, thresholdSource, %d
Invalid timestamps, natalieModelInput computeTime is less than the duration, computeTime, %.3f, duration, %.3f
Time rolled back, bufferEndTime, %.3f, newSampleStartTime, %.3f
operateOnWindow - windowStartTime is outside of our intensity buffer, windowStartTime, %.3f, bufferStartTime, %.3f
operateOnWindow - our window is incomplete, this indicates there is a logic error.
Creating daemon cache for AWD metrics
Loading daemon cache for AWD metrics
imageCaptures,[%d,%d,%d,%d,%d,%d],endConditions,[%d,%d,%d,%d,%d,%d],biasChanges,[%d,%d,%d,%d,%d,%d,%d,%d],minDuration,%llu,maxDuration,%llu,meanDuration,%llu,minTemperature,%5.2f,maxTemperature,%5.2f
Saving daemon cache for AWD metrics
could not create path %{public}s
IgnoreAccessoryLocations,%{public}d
EnableAccessoryNMEAScreening,%{public}d
registered for app client notifications
unregistered for app client notifications
EnableAccessoryNMEAScreening,0,airborne,1
PauseExternalLocation,1
EnableAccessoryNMEAScreening,1,airborne,0
PauseExternalLocation,0
registered for unfiltered location notifications
registered for propagated location notifications
unregistered for unfiltered location notifications
unregistered for propagated location notifications
Accessory,StartLocation,IgnoreAccessoryLocation,%{public}d
#Warning no reference time available, not sending reference time
#Warning location services is disabled, not sending reference location
#Warning no reference location available, not sending reference location
#Warning ephemeris %s not available
could not create input stream for ephemeris file, %{public}s
could not create data from file %{public}s
#Warning received an unknown location notification %d
Unable to open nmea fifo FD %d %s.
CLAccessoryAWD,%{public}.1lf,NmeaScreener reset
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Speed,%.2f,Course,%.2f,timestampGps,%.2lf,GgaOnly,integrity,%d
CLAccessoryAWD,%{public}.1lf,machContTime,%{public}.1lf,onApp,newApp,%{private}s
CLAccessoryAWD,%{public}.1lf,machContTime,%{public}.1lf,onApp,ReceivedAppNotification,%{public}d,%{private}s
CLAccessoryAWD,%{public}.1lf,ReceivedBatteryNotification,connected,%{public}d,type,%{public}d
CLAccessoryAWD,%{public}.1lf,RouteListener,navstate,%{public}d
CL: CLAccessoryLocationProvider::onEphemerisUpdated
{"msg%{public}.0s":"CLAccessoryLocationProvider::onEphemerisUpdated", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAccessoryLocationProvider::onLocationNotification
{"msg%{public}.0s":"CLAccessoryLocationProvider::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAccessoryLocationProvider::onTimeNotification
{"msg%{public}.0s":"CLAccessoryLocationProvider::onTimeNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAccessoryLocationProvider::onClientManagerNotification
{"msg%{public}.0s":"CLAccessoryLocationProvider::onClientManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAccessoryLocationProvider::onAppNotification
{"msg%{public}.0s":"CLAccessoryLocationProvider::onAppNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAccessoryLocationProvider::onBatteryNotification
{"msg%{public}.0s":"CLAccessoryLocationProvider::onBatteryNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
could not store stats data 
location system state, cell available, %d, wifi available, %d, passcode locked, %d, airplane mode enabled, %d, accessory connected, %d, reachability, %d, powered, %d, gpsCoexWifi, %d, gpsCoexBt, %d
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,enabled,%d,event,%d
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,bundleIdApproved,%s,approved,%d,authorization,%d,
The sum of the delivered locations by type (%d) does not equal the delivered locations counter (%d).
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,cellAvailable,%d,wifiAvailable,%d,passcodeLocked,%d,airplaneMode,%d,reachability,%d,accessoryConnected,%d,powered,%d,gpsCoexWifi,%d,gpsCoexBt,%d,timestampEnd,%.3f,duration,%.3f,desiredAccuracy,%.2f,achievedAccuracy,%.2f,ttff,%.3f,ttffGps,%.3f,achievedSpeed,%.2f,autoStopped,%d,deferredLocations,0,deliveredLocations,%d,deliveredLocationsByType,%s,deliveredLocationsByTypeFraction,%s,sdeliveredLocationsUndefined,%d,deliveredLocationsUndefinedFraction,%.4f,validDeliveredLocationsByType,%d
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,fenceRadiusMin,%.2f,fenceRadiusMax,%.2f,numFences,%d,numFencesRemoved,%d,slc,%d,
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,cellAvailable,%d,wifiAvailable,%d,passcodeLocked,%d,airplaneMode,%d,eventType,%d,eventRadius,%.2f,eventDistance,%.2f,eventLatency,%.3f,eventMask,0x%x,sinceLast,%{private}.1f,fenceType,%{private}d,fenceAPs,%{private}d,boundedFenceAps,%{private}d,totalAPs,%{private}d,conservative,%{private}d,emergency,%{private}d,polygonal,%{private}d,throttled,%{private}d,inVehicle,%{private}d,driving,%{private}d,static,%{private}d,pedestrian,%{private}d
{"msg%{public}.0s":"iB: submit monitor session", "metric.valid":%{public}d, "metric.timestamp":"%{public}f", "metric.bundleId":%{private, location:escape_only}s, "onbehalfbundleid":%{private, location:escape_only}s, "addedRegions":%{public}d, "addedWildCarded":%{public}d, "addedEntryState":%{public}d, "addedConservative":%{public}d, "removedRegions":%{public}d, "removedWildCarded":%{public}d, "removedEntryState":%{public}d, "removedConservative":%{public}d}
{"msg%{public}.0s":"iB: submit monitor trigger", "metric.valid":%{public}d, "metric.timestamp":"%{public}f", "metric.bundleId":%{private, location:escape_only}s, "onBehalfBundleId":%{private, location:escape_only}s, "eventType":%{public}d, "regionMask":%{public}d, "monitoredRegionsClient":%{public}d, "monitoredZonesDevice":%{public}d}
{"msg%{public}.0s":"iB: submit ranging session", "metric.valid":%{public}d, "metric.timstamp":"%{public}f", "metric.bundleId":%{private, location:escape_only}s, "regions":%{public}d, "beacons":%{public}d, "measurements":%{public}d, "duration":%{public}d, "trace size":%{public}lu, "trace sample":%{public}d}
metric.valid,%d,metric.timestamp,%.3f,metric.metricsIdentifier,%s,metric.reachabilityNotifications,%u,metric.batteryNotifications,%u,metric.thermalNotifications,%u,metric.locationNotifications,%u,metric.rawGpsNotifications,%u,metric.validatedGpsNotifications,%u,metric.managerNotifications,%u,metric.durationMinimumUploadRequirementsMet,%.3f,metric.durationMinimumUploadRequirementsNotMet,%.3f
Max prototypes overriden to %d
metric.valid,%d,metric.timestamp,%.3f,metric.bundleId,%s,timestampEnd,%.3f,duration,%.3f,motionType,%d,numTriggers,%d,prototypes,%zu,%s
metric.valid,%d,metric.timestamp,%.3f,step,%d,distance,%.2f,timeLength,%.2f,score,%.2f,trackdistance,%.2f,kfactor,%.2f,kfactorupdated,%.2f
CLIENT: Clearing cached notification for %d
CLIENT: %d, registerForNotification, distanceFilter, %.1lf, checkInterval, %.1lf, sleepProof, %d, operatingMode, %d
CLIENT: register for notification, %d, %s
CLIENT: unregister for notification, %d, %s, wasRegistered, %d
<%+.8f,%+.8f> is stale from %.3fs ago, not using for distance filtering
distance filter %.2f not exceeded by <%+.8f,%+.8f> and <%+.8f,%+.8f> (distance %.2f)
Now registered for %s location notifications, operating mode %d
no more location clients - not re-registering
leaving location as it would turn on in %.3fs anyway
@ClxClient, accuracy, %{public}d, %{public}d, %{public}d, level, %{public}s, reg?, %{public}d
CLIENT: notification, %s, clients, %lu, distanceFilter, %.1lf, sleepProof, %d
#Warning Ignoring request for sleep-proof location updates with no check interval
CLIENT: distanceFilter, %.1lf, fDistanceFilter, %.1lf
minimum distance unchanged from %.3f, still requesting location at %.3f (%.3fs away)
minimum distance changed to %.3f from %.3f
turning off location requests and re-scheduling for %.3fs later
scheduling location requests for %.3fs later
no location currently available, starting it immediately
wake interval unchanged from %.3f, still waking at %.3f (%.3fs away)
wake interval changed to %.3f from %.3f
#Warning Location Services reset, clearing local cache
#Warning Location Services state changed, clearing local cache
Cached location,%.8lf,%.8lf,HorAcc,%.1lf,Type,%s,Confidence,%d,Timestamp,%.3f,Lifespan,%.3f,Age,%.3f,integrity,%d
No valid last confident location
CL: CLFilteredLocationController::onLocationNotification
{"msg%{public}.0s":"CLFilteredLocationController::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFilteredLocationController::onManagerNotification
{"msg%{public}.0s":"CLFilteredLocationController::onManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLNmeaScreener,type,%d,lat,%{private}.8lf,lon,%{private}.8lf,timestampGPS,%.1lf,machContTime,%.1lf,fHorizontalUncertainty,%.1lf
CLNmeaScreener,fSimulatorMode,1
{"msg%{public}.0s":"NmeaScreener isExternalLocationDisablementAllowed,0"}
{"msg%{public}.0s":"NmeaScreener isExternalLocationDisablementAllowed,1", "PauseExternalLocation":%{public}hhd}
%s,invalid location input,type,%d
Traversing preload manifest file
Preload manifest tile size = %lu
failed to allocate transit tile
failed to decode transit tile protobuf, encrypted=%{public}lu tile=%{public}s
failed to get fields in manifest
ver,%d,x,%d,y,%d,generated,%.01lf,age,%.01f,ageThresh,%d
Reading new market, {%.06lf,%.06lf}, {%.06lf,%.06lf}
Adding new tile to market, [%.06lf,%.06lf]
loaded transit tile %s with %lu regions
unknown hardware type %{private}d
#Warning PLOS: ignoring hw. forceSupport,%d
{"msg%{public}.0s":"#ALERT Device is currently running Apple Store demo mode"}
#Warning OBM, ignoring hw. forceSupport,%d
Unsupported HW type %d; file a radar to CoreMotion Factory | 1.0
Unsupported HW type %{private}d; file a radar to CoreMotion Factory | 1.0
Booted in to diagnostics mode
beginTime, %{public}f, distanceSource, %{public}d, bestSpeed, %{public}f, pedSpeed, %{public}f, uncalibratedSpeed, %{public}f, currentCadence,%{public}f
Overriding youth type for brisk walk, beginTime, %f, before, %{public}d, after, %{public}d, speed, %{public}f, speedThreshold, %{public}f
Overriding youth type for nonzero speed, beginTime, %f, before, %{public}d, after, %{public}d, speed, %{public}f
CLMM,MA-OTA,MM disabled for this country
CLMM,MA-OTA,initialCheck,signalEnv,%{public}d,isSEOk,%{public}d,size,%{public}d,isPolygonOK,%{public}d,size,%{public}d,isInsideSkippedPolygon,%{public}d,size,%{public}d,dtSinceLastMMStateChangedBasedOnSE,%{public}.1lf,mmStateBasedOnSE,%{public}d
CLMM,MA-OTA,seStateChanged,prevSEState,%{public}d,newSEState,%{public}d
CLMM,MA-OTA,seCheck,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d,early return due to failed se check - polygon not checked)
CLMM,MA-OTA,polygonCheck,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d,inside,%{private}s
CLMM,MA-OTA,polygonCheck,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d,early return due to failed polygon check - skipregion not checked)
CLMM,MA-OTA,skipRegionCheck,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d,inside,%{private}s
CLMM,MA-OTA,final,isSEOk,%{public}d,isPolygonOK,%{public}d,isInsideSkippedPolygon,%{public}d
CLMM,%{public}.1lf,operatingDynamics,overwriting machContinuousTime,machContinuousTime,%{public}.1lf
CLMM,%{public}.1lf,operatingDynamics,not matching,non-terrestrial speedMps,%{public}.2lf,threshold,%{public}.1lf
CLMM,%{public}.1lf,operatingDynamics,pedestrian matching,routehints,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,vehicle matching,routehints,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,cycle matching,routehints,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,sticking to last dynamics,%{public}d,timeInCurrentMode,%{public}.1lf
CLMM,%{public}.1lf,operatingDynamics,pedestrian matching,walking dynamics,speed,%{public}.2lf,wasRecentlyWalking,%{public}d,motion,%{public}d,fitness,%{public}d
CLMM,%{public}.1lf,operatingDynamics,cycling matching,cycling dynamics,speed,%{public}.2lf,wasRecentlyCycling,%{public}d,motion,%{public}d,fitness,%{public}d
CLMM,%{public}.1lf,operatingDynamics,vehicle matching,vehicle dynamics,speed,%{public}.2lf,wasRecentlyDriving,%{public}d
CLMM,%{public}.1lf,operatingDynamics,pedestrian matching,wasRecentlyWalking,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,vehicle matching,wasRecentlyDriving,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,cycle matching,wasRecentlyCycling,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics,vehicle matching,highSpeed,speed,%{public}.2lf
CLMM,%{public}.1lf,operatingDynamics, activity based pedestrian map-matching not allowed,%{public}d, or country not supported,%{private}s, setting unknown
CLMM,%{public}.1lf,operatingDynamics, pedestrian map-matching not allowed, setting unknown
CLMM,%{public}.1lf,operatingDynamics, activity based cycling map-matching not allowed,%{public}d, or country not supported,%{private}s, setting unknown
CLMM,%{public}.1lf,operatingDynamics, cycling map-matching not allowed, setting unknown
CLMM,%{public}.1lf,operatingDynamics,fDynamics,%{public}d,dynamics,%{public}d,currentCountry,%{private}s
IndoorOutdoor,ALSScan,lux,%{public}.0f,t,%{public}f
IndoorOutdoor,ALSResult,outputProb,%{public}.2f,rawProb,%{public}.2f,meanLux,%{public}.2f,stdLux,%{public}.2f,n,%{public}d,elevation,%{public}.2f,hasLatLon,%{public}d
iB: state No access to state DB
iB: state No access to DB
iB: state Invalid for DB
iB: state store, %{private}lld, %{private}d, %{private}s
#Warning iB: state Couldn't bind statement for store (%{private}s)
iB: state remove, %{private}lld, %{private}s
#Warning iB: state couldn't bind statement for deleting (%{private}s)
iB: state can't scrub DB
iB: state scrub, remaining, %{public}lu
iB: state couldn't bind (%{private}s)
iB: state doesn't exist (%{private}s)
iB: state Error in retrieving state for %{private}s
iB: state get, %{private}lld, %{private}d, %{private}s
{"msg%{public}.0s":"CLC: Enable CLRouteListener when already enabled", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLC: Enabled
#Warning CLC: Disable CLRouteListener when already disabled, shutdown?
CLC: Disable
CLC: Received a route, %{public}d,%{public}d,%{public}d,%{public}d
#Warning CLC: Starting route without an appoximate location
CLC: Received a transit route
CLC: Received a state change, %{public}d,%{public}d,%{public}d,%{public}d
CLC: Route type        : %{private}d, %{private}@
CLC: Route origin      : %{public}s
CLC: Route destination : %{public}s
CLC: Route dest name   : %{private}@
CLC: Route travel time : %{private}.01lf
CLC: Transit Stop:
CLC:     LAT : %{private}lf
CLC:     LON : %{private}lf
CLC: Transit Link:
CLC:     ID  : %{private}llu
CLC:     DEP : %{private}lf
CLC:     ARR : %{private}lf
CLC:     Stop From :
CLC:     Stop To :
CLC:         ID  : %{private}llu
CLC:         LAT : %{private}lf
CLC:         LON : %{private}lf
CLC: Guidance Level   : %{public}@
CLC: Navigation State : %{public}@
CLC: Transport Type   : %{private}@
CLC: navigation stopped
CLC: Received a unsupported GEONavigationState, %d
Legacy compass, interval (%{public}.3f) gyro (%{public}d)
Legacy compass started. Cover attached %{public}d
Dumped compass cal database with id %@
Compass is requesting device motion with mode %{public}#x
Legacy compass stopped.
Notify after %{public}.3f seconds of no event.
Type,%s,compassJustAlignedToStableField,%d,timestamp,%20.20f
Type,%s,magneticHeading,%20.20f,trueHeading,%20.20f,accuracy,%20.20f,magneticField.x,%20.20f,magneticField.y,%20.20f,magneticField.z,%20.20f,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,level,%d,magnitude,%20.20f,inclination,%20.20f,horizontal,%20.20f,timestamp,%20.20f
notified clients. sampleCount,%d,compass.compass.calibrationLevel,%d,compass.timestamp,%f
CLWorkoutActiveStateDetector,sending event %d
CLWorkoutActiveStateDetector,sending external active state %d
CLWorkoutActiveStateDetector,setting workout type to,%{public}ld
CLWorkoutActiveStateDetector,workout type didn't change,%{public}ld
WIFI_LOC: failed to get power state
@WifiFlow, scanreq, %{public}s, %{public}s, result, %{public}d
CL: CLWifiLocationProvider::onWifiNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onWifiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiLocationProvider::onClientNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiLocationProvider::onNetworkLocationNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onNetworkLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiLocationProvider::onStatusNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiLocationProvider::onCompanionNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiLocationProvider::onMotionNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onMotionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiLocationProvider::onLocationNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiLocationProvider::onSignalEnvironmentNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onSignalEnvironmentNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiLocationProvider::onOdometerNotification
{"msg%{public}.0s":"CLWifiLocationProvider::onOdometerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Warning Overriding FenceStartDelay,%{private}.2f
iB: Scheduling initialization delay,%{private}.2f, silo,%{private}p
{"msg%{public}.0s":"iB: Initializing", "unlocked":%{public}d, "awaiting":%{public}d}
iB: Already initialized
{"msg%{public}.0s":"@iB: Adding monitored region", "region":%{private, location:escape_only}s, "totalRegions":%{public}lu}
{"msg%{public}.0s":"iB: Retrieved monitored regions", "numRegions":%{public}lu, "bundle":%{public, location:escape_only}s}
{"msg%{public}.0s":"@iB: Removing monitored region", "region":%{private, location:escape_only}s, "totalRegions":%{public}lu}
iB: Region,%{private}s, has state,%{private}d
#Warning Unable to find region,%{private}s, in the cache
#Warning Authorization error,%{public}d, while requesting state for region,%{private}s
@iB: Simulating Beacon : %s.%d.%d  RegionState : %d
@iB: Simulating Beacon : beacon notification sent
{"msg%{public}.0s":"iB: Resuming monitoring for fence", "region":%{private, location:escape_only}s}
Unable to monitor the zone for region,%{private}s
#Warning iB: state kNotificationFenceResume, before first unlock
iB: Already resumed monitoring for fence,%{private}s
{"msg%{public}.0s":"iB: Suspending monitoring for fence", "region":%{private, location:escape_only}s}
Unable to unmonitor the zone for fence,%{private}s
iB: state kNotificationFenceSuspend, before first unlock
iB: Fence,%{private}s, is not being monitored, the suspension request will be ignored
{"msg%{public}.0s":"@iB: Zone state transition", "region":%{private, location:escape_only}s, "fromState":%{private}d, "toState":%{private}d, "totalRegions":%{public}lu}
{"msg%{public}.0s":"@iB: Launching application for notification (if necessary)", "bundle":%{private, location:escape_only}s}
#Warning iB: state changed before first unlock
iB: Warning data can't be cleared yet
{"msg%{public}.0s":"iB: Received display on notification"}
{"msg%{public}.0s":"@iB: Display turned on, notifying region", "region":%{private, location:escape_only}s}
iB: Pending notification for fence,%{private}s, state,%{private}d, has expired
{"msg%{public}.0s":"iB: Sending cached notification for fence", "region":%{private, location:escape_only}s, "state":%{private}d, "type":%{private}d}
iB: state kNotificationDeviceUnlockedSinceBoot, from, %{public}d, to, %{public}d, start, %{public}d
iB: createStateDatabase, fStateDatabase, %{private}p, fDeviceUnlockedSinceBoot, %{public}d, reason, %{public}s
CL: CLBTLEFenceManagerConcrete::onDataProtectionNotification
{"msg%{public}.0s":"CLBTLEFenceManagerConcrete::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLBTLEFenceManagerConcrete::onClientManagerNotification
{"msg%{public}.0s":"CLBTLEFenceManagerConcrete::onClientManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLBTLEFenceManagerConcrete::onAuthorizationNotification
{"msg%{public}.0s":"CLBTLEFenceManagerConcrete::onAuthorizationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLBTLEFenceManagerConcrete::onBeaconNotification
{"msg%{public}.0s":"CLBTLEFenceManagerConcrete::onBeaconNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLBTLEFenceManagerConcrete::onDaemonStatusNotification
{"msg%{public}.0s":"CLBTLEFenceManagerConcrete::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
AmbientLightDecisionTreeOutput,%{public}d
ALSProcessor,FilterReset,timestamp,%{public}.2f,lastTimestamp,%{public}.2f
not connected to wifi #tile header table
{"msg%{public}.0s":"@TileHeader, wifi, failed to bind values for #tile save header", "x":%{private}d, "y":%{private}d}
{"msg%{public}.0s":"@TileHeader, wifi, failed to bind values for deleting #tile", "x":%{private}d, "y":%{private}d}
failed to select count(*) from wifi #tile header table
{"msg%{public}.0s":"Usage of incorrect column to update timestamp", "column":%{private, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
@TileList, touch, ignoring, 0, #CloneMe
{"msg%{public}.0s":"@TileHeader, wifi, failed to bind values for #tile to update timestamp", "timestamp":%{private}lld, "x":%{private}d, "y":%{private}d}
failed to update timestamp of #tile header
{"msg%{public}.0s":"@TileHeader, wifi, failed to bind values for #tile to select timestamp", "x":%{private}d, "y":%{private}d}
{"msg%{public}.0s":"@TileHeader, wifi, dropping legacy tile table", "tableName":%{private, location:escape_only}s}
failed to connect to wifi #tile header database
failed to connect to wifi #tile heeaders table
successfully created wifi #tile headers table
Setting up first session entry
Enabling kNotificationOdometerUpdateElevation from companion
Disabling kNotificationOdometerUpdateElevation from companion
Added client for cycling workout distance updates
Removed client from cycling workout distance updates
CoarseElevation,phone,1,watch,1
CoarseElevation,src,phone,0,watch,1
CoarseElevation,src,phone,1,watch,0
CoarseElevation,src,phone,0,watch,0
Updating odometer state, authorized, %{public}d, has active clients, %{public}d, cycling distance controller, %{public}d
Update location authorization, current, %{public}d, new, %{public}d
Enable GPS; Start GPS subscription
Disable GPS; Stop GPS subscription
watch:notifying elevation entry from phone
Location batch notification size %{public}ld
#Warning Received unhandled location provider notification, %{public}d
Incoming odometer, %{private}.8f
#Warning Current odometer sample fails time check. Gps,%{public}.2lf,%{public}.2lf,startTime,%{public}.2lf,%{public}.2lf,odometer,%{private}.2lf,%{private}.2lf
Source may have reset. Gps,%{public}.2lf,%{public}.2lf,startTime,%{public}.2lf,%{public}.2lf,odometer,%{private}.2lf,%{private}.2lf
Odometer source change,previous,%{private}lf,current,%{private}lf,previousType,%{public}d,type,%{public}d
{"msg%{public}.0s":"CLElevationAWDAggregator", "Origin Device":%{private}d}
Drop entry! distance, %{private}.8f, startTime, %{public}.8f, gps altitude, %{private}.8f, odometer, %{private}.8f, accuracy, %{public}.8f, gpsSpeed, %{private}.8f, gpsSpeedAccuracy, %{public}.8f, timestampGps, %{public}.8f, rawSpeed, %{private}.8f, originDevice, %{public}d, locationType: %{public}d
Notifying odometer clients, distance, %{private}.8f, startTime, %{public}.8f, gps altitude, %{private}.8f, odometer, %{private}.8f, accuracy, %{public}.8f, gpsSpeed, %{private}.8f, gpsSpeedAccuracy, %{public}.8f, timestampGps, %{public}.8f, rawSpeed, %{private}.8f, originDevice, %{public}d, locationType, %{public}d, groundAltitude, %{private}.8f, groundAltitudeUncertainty, %{public}.8f, smoothedGPSAltitude, %{private}.8f, smoothedGPSAltitudeUncertainty, %{public}.8f, gpsCourseRadians, %{private}.8f, gpsCourseAccuracy, %{public}.8f
CL: CLOdometerNotifierWatch::onCompanionNotification
{"msg%{public}.0s":"CLOdometerNotifierWatch::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLOdometerNotifierWatch::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLOdometerNotifierWatch::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLOdometerNotifierWatch::onLocationNotification
{"msg%{public}.0s":"CLOdometerNotifierWatch::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLOdometerNotifierWatch::onSignalEnvironmentNotification
{"msg%{public}.0s":"CLOdometerNotifierWatch::onSignalEnvironmentNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
onCoarseElevation,startTime,%.3f,ascended,%d,source,%d,fused,startTime,%.3f,ascended,%d,source,%d
watch:notifying elevation entry from watch
CNNWorkoutClass,%d
GBTWorkoutClass,%d
LRWorkoutClass,%d
Tier2WorkoutClass,%d,CMWorkoutType,%ld,SmoothedCMWorkoutType,%ld,startTime,%f
DeviceOrientation,%d,%d
SessionStats,%s,%f,%s,%f,%s,%u,%s,%u,%s,%u,%s,%f,%s,%u,%s,%u,%s,%u,%s,%u,%s,%u,%s,%u
{"msg%{public}.0s":"Already in a transaction. ClientManager threading bug?", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "new":%{public, location:_CLClientManagerStateTrackerState}.*P}
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "old":%{public, location:_CLClientManagerStateTrackerState}.*P, "new":%{public, location:_CLClientManagerStateTrackerState}.*P}
{"msg%{public}.0s":"#PersistentSubscription PersistenceBackend removeAllPersistedDataForSubscription", "clientKey":%{public, location:escape_only}s, "storageName":%{public, location:escape_only}s}
{"msg%{public}.0s":"#PersistentSubscription PersistenceBackend clearObjectForKeyForSubscription", "clientKey":%{public, location:escape_only}s, "storageName":%{public, location:escape_only}s, "storageKey":%{private, location:escape_only}s}
{"msg%{public}.0s":"#PersistentSubscription PersistenceBackend setObjectForKeyForSubscription", "clientKey":%{public, location:escape_only}s, "storageName":%{public, location:escape_only}s, "storageKey":%{private, location:escape_only}s, "storageValue":%{private, location:escape_only}@}
could not store clients data
{"msg%{public}.0s":"Connection to User Event Agent already exists.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
UserEventAgent connected (from %{public}s)
Client %{public}s connected with message name %{public}s
#Error no bundle ID or bundle path found - denying %{public}s
platform does not support system service, %{public}s, required capabilities.
{"msg%{public}.0s":"Client static registration result", "name":%{public, location:escape_only}s, "registration":%{public, location:CLClientRegistrationResult}lld}
location disabled system-wide, denying executable %{public}s
location emergency-enablement explicitly benefits %{public}s, not denying
location emergency-enabled with explicit beneficiaries, denying executable %{public}s
getClientEffectiveRegistrationResult, %{public}s, %{public}s, %{public}s, CLClientRegistrationResult, %{public}s, CLCommonLocationServicesEnabled, %{public}d
Couldn't get keys for client dictionary
mayTakeProcessAssertion,%d,background,%d,slc,%d
client, '%s', app's client cnt, %d, active, %d, spectator, %d, batchEnabled, %d, desiredAccuracy, %.2f, distanceFilter, %.2f
{"msg%{public}.0s":"removing client entry", "client":%{public, location:escape_only}s}
Couldn't get keys for client dictionary, deauthorizing all clients
GPS_NETWORK: currentStatus(%d) isGpsControlledByNetwork(%d)
{"msg%{public}.0s":"#authsync sending kNotificationLocationServicesStatus"}
{"msg%{public}.0s":"#IncidentalPrompt CLCM:InUseAssertion IncidentalPresence", "Client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth Client has dropped below in-use-ness threshold, losing WIU status", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#IncreasedProminence InUseLevel less than threshold. current session terminated", "ClientKey":%{public, location:escape_only}s, "ClientsWithActiveProminenceSession":%{public, location:escape_only}@}
#IncidentalUseMode able to get client's incidental use mode
#IncidentalUseMode  returning with value:%d
#IncidentalUseMode able to SET client's incidental use mode:%d
{"msg%{public}.0s":"Unable to find client to update #IncidentalUseMode", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#LocationButtonFirstUsage skip prompting. Restrictions enabled", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#LocationButtonFirstUsage skip prompting. InflightPromptAuthorizationRequest found.", "ClientKey":%{public, location:escape_only}s, "inflightClientKey":%{public, location:escape_only}s, "inflightRequestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}
{"msg%{public}.0s":"#Warning Could not post #LocationButtonFirstUsage", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth Explicit temporary authorization request received", "ClientKey":%{public, location:escape_only}s, "Granted":%{public}hhd, "UsingLocationButton":%{public}hhd, "VoiceInteractionEnabled":%{public}hhd, "LocationButtonUseMode":%{public, location:CLClientLocationButtonUseMode}lld, "TransientAwareRegistrationResult":%{public}d}
{"msg%{public}.0s":"#TemporaryAuth cannot be rescinded (granted=false) using location-button", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth #LocationButtonUse prompting status", "ClientKey":%{public, location:escape_only}s, "PromptingStatus":%{public}hhd}
{"msg%{public}.0s":"#TemporaryAuth could not be granted , #LocationButtonUse denied", "ClientKey":%{public, location:escape_only}s}
#CLEEA Emergency clients %d %s 1
#CLEEA adding emergency client,%{public}s
#CLEEA First emergency client connected
#CLEEA removing emergency client,%{public}s
{"msg%{public}.0s":"#CLEEA Trying to remove emergency beneficiary which doesn't exist", "MissingClientKey":%{public, location:escape_only}s, "TotalMultisetSize":%{public}d}
#CLEEA Last emergency client disconnected
#CLEEA %{public}s is still an emergency client
{"msg%{public}.0s":"Skip UpdateClientServiceTypeMasks #pla for zones. BigSwitch is Off", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"Skip UpdateClientServiceTypeMasks #pla for zones. No InterestZones", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla updateServiceTypeMasks", "ClientKey":%{public, location:escape_only}s, "ZoneId":%{public, location:escape_only}s, "zoneRegistration":%{public, location:CLClientRegistrationResult}lld, "zoneCC":%{public, location:CLClientCorrectiveCompensation}lld, "zoneIncidentalUse":%{public, location:CLClientIncidentalUseMode}lld, "zoneInUseLevel":%{public, location:CLClientManager_Type::ClientInUseLevel}lld, "zoneEffectiveMask":%{public}d, "zoneProvisionalMask":%{public}d, "ClientOldEffectiveMask":%{public}d, "ClientOldProvisionalMask":%{public}d, "zoneServiceMaskOptr":%{public, location:CLClientInterestZoneServiceMaskOperator}lld, "ClientNewEffectiveMask":%{public}d, "ClientNewProvisionalMask":%{public}d}
Considering whether to mark client, %s, for always power use
Not marking client %s as having used Always-powers (not Always authorized (%s))
{"msg%{public}.0s":"Limiting identity's #compensation value imposed on bundlePath identity", "AffectedIdentity":%{public, location:escape_only}s}
{"msg%{public}.0s":"Path must not be the empty string here", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
could not retrieve bundle IDs
installation check found %ld uninstalled apps (amongst %ld bundle IDs)
%s is missing
{"msg%{public}.0s":"Deleting entry as client has been missing beyond safe harbor threshold", "bundleId":%{public, location:escape_only}s, "missingTimeDuration_s":"%{public}.09f", "safe harbor threshold_s":"%{public}.09f"}
{"msg%{public}.0s":"Marking client as missing", "bundleId":%{public, location:escape_only}s, "missingTime_s":"%{public}.09f"}
%s has been missing for %.3fs (safe harbor thershold: %.3fs)
{"msg%{public}.0s":"Client restored within safe harbor threshold - keeping", "bundleId":%{public, location:escape_only}s, "safe harbor threshold_s":"%{public}.09f"}
updated AppUninstallTimer; next timer will fire in %.3fs
ImproveAccuracyNotification object not created for technology, %{public}s
{"msg%{public}.0s":"WiFi is disabled, but the prompt will be suppressed because we're in demo mode"}
{"msg%{public}.0s":"#AuthPrompt posted improve accuracy notification", "client":%{public, location:escape_only}s, "technology":%{public, location:escape_only}s, "status":%{public}hhd}
DAR: could not read map file %{public}s
DAR map: %s
DAR map sorted keys: %s
DAR: original location: %.8f, %.8f, %.2f
DAR:  reduced location: %.8f, %.8f, %.2f
#Warning DAR: applying default quantization %f
DAR: applying new quantization %f based on ap count %d
DAR: applying cached quantization %f
{"msg%{public}.0s":"No client found for the connection", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#sbim Out of bounds access -- entity class too large", "entityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld}
{"msg%{public}.0s":"#sbim Out of bounds access -- arrow state too large", "arrowState":%{public}lu}
{"msg%{public}.0s":"#sbim Count overflow!", "entityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, "arrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}
{"msg%{public}.0s":"#sbim Count underflow!", "entityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, "arrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}
{"msg%{public}.0s":"#sbim entity class count updated", "entityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, "change":%{public}d, "arrowStateBeingChanged":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "newCount":%{public}u, "oldArrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "newArrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}
{"msg%{public}.0s":"#sbim entity class arrow state changed", "entityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, "oldArrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "newArrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "dueToDeauthorization":%{public}hhd}
{"msg%{public}.0s":"#sbim moving arrow retain count between entity classes", "clientKey":%{public, location:escape_only}s, "oldEntityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, "newEntityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, "arrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}
{"msg%{public}.0s":"#sbim client arrow state changed", "clientKey":%{public, location:escape_only}s, "entityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, "oldArrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "newArrowState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "dueToDeauthorization":%{public}hhd}
Sending kCLConnectionMessageWakeClient for %{public}s to client '%{public}s'
#Warning Can't find /usr/libexec/UserEventAgent connection for waking Client: <%s>
{"msg%{public}.0s":"failed to archive authorization decisions", "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"Failed to unarchive authorization decisions", "errorDesc":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning intentionally exiting to simplify loading in our new clients database.  See you on the other side!"}
{"msg%{public}.0s":"Handle #provisional intermediation for service", "client":%{public, location:escape_only}s, "serviceType":%{public}lu}
{"msg%{public}.0s":"Dropping #provisional intermediation reigning king is not yet stale", "client":%{public, location:escape_only}s, "kingOfTheDeck":%{public, location:escape_only}s}
{"msg%{public}.0s":"Taking #provisional intermediation kingOfTheDeck", "newKing":%{public, location:escape_only}s, "oldKing":%{public, location:escape_only}s}
{"msg%{public}.0s":"Skipping #provisional intermediation throne change because of outstanding prompt", "wouldBeKing":%{public, location:escape_only}s}
{"msg%{public}.0s":"#compensation failed to load persistent store for client", "client":%{public, location:escape_only}s}
Setting client for bundle path %s
{"msg%{public}.0s":"Unsupported CLClientServiceType", "serviceType":%{public}lu, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"started receiving location information", "client":%{public, location:escape_only}@}
{"msg%{public}.0s":"stopped receiving location information", "client":%{public, location:escape_only}@}
{"msg%{public}.0s":"createClientUserNotification: BundleDisplayName nil", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#CUN Creating client user notification for client", "name":%{public, location:escape_only}s, "requestType":%{public}d}
{"msg%{public}.0s":"Client is #appclip", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning, unable to copy purpose string from client", "name":%{public, location:escape_only}s, "requestType":%{public}d}
{"msg%{public}.0s":"Failed archiving extension item", "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"#AuthPrompt Not showing prompt because the client asked us not to", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt location services settings are frozen by restrictions - denying", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Not showing big switch re-enable prompt on OSX", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Not showing big switch re-enable prompt because the client asked us not to", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Not showing big switch re-enable prompt because the client has asked for too many", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Ignoring request because authorization in progress -- not showing big switch re-enable prompt", "client":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "inflightClientKey":%{public, location:escape_only}s, "inflightRequestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}
{"msg%{public}.0s":"Showing big switch #AuthPrompt", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Ignoring request because authorization in progress", "client":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "inflightClientKey":%{public, location:escape_only}s, "inflightRequestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}
{"msg%{public}.0s":"#AuthPrompt #Notice ERROR: Client is depending on legacy on-demand authorization, which is not supported for new apps", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Client requested a big switch prompt, but the big switch is already on", "client":%{public, location:escape_only}s}
#AuthPrompt Unrecognized/invalid request type: %{public}d
{"msg%{public}.0s":"Showing #AuthPrompt", "requestType":%{public}d, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt posted", "client":%{public, location:escape_only}s, "type":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}
{"msg%{public}.0s":"#authsync applyfullSyncMessages couldn't get all client keys"}
{"msg%{public}.0s":"#authsync List before applying changes", "Client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync List after applying changes", "Client":%{public, location:escape_only}s}
{"msg%{public}.0s":"NotSuported #authSync applyAuthorizationSyncMessage applies syncMessage of operationTye Add or Update", "Received OperationType":%{public}d}
{"msg%{public}.0s":"#authsync applyAuthorizationSyncMessage on Companion received an update message"}
{"msg%{public}.0s":"#authsync applyAuthorizationSyncMessage un-translated key", "clientKey":%{public, location:escape_only}s, "OperationType":%{public}d}
{"msg%{public}.0s":"#authsync applyAuthorizationSyncMessage", "clientKey":%{public, location:escape_only}s, "auth":%{public}d, "corrective":%{public}d, "OperationType":%{public}d}
{"msg%{public}.0s":"#authsync Conflict resolution", "clientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync applyAuthorizationSyncMessage change denied due to SyncedAuthorizationDecisionOnGizmo=false", "OperationType":%{public}d, "clientKey":%{public, location:escape_only}s, "oldAuth":%{public}d, "newAuth":%{public}d, "correctiveComp":%{public}d}
{"msg%{public}.0s":"#authsync applyAuthorizationSyncMessage denied due to an auth conflict", "OperationType":%{public}d, "clientKey":%{public, location:escape_only}s, "oldAuth":%{public}d, "newAuth":%{public}d}
{"msg%{public}.0s":"#pla #authsync ApplyStaticZone.", "Client":%{public, location:escape_only}s, "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"Applying auth for SyncedZone.", "Client":%{public, location:escape_only}s, "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync applyAuthorizationSyncMessageTypeDelete", "clientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"authsync: Updating location services", "newState":%{public}d}
{"msg%{public}.0s":"authsync: Missing client on disk", "clientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"authsync: Updating SyncedAuthorizationDecisionOnGizmo", "clientKey":%{public, location:escape_only}s, "value":%{public}hhd}
#authsync getDeltaSyncObjectsForClientsWithFirstAuthorizationDecisionOnGizmo couldn't get keys for client dictionary
{"msg%{public}.0s":"#authsync getDeltaSyncObjectsForClientsWithFirstAuthorizationDecisionOnGizmo finish", "syncObjects":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Couldn't get nvp", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Merging remote location usage", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync #warning Didn't expect a start time and a stop time", "start time_s":"%{public}.09f", "stop time_s":"%{public}.09f", "service":%{public}lu}
{"msg%{public}.0s":"#usesync Starting remote location service", "client":%{public, location:escape_only}s, "start time_s":"%{public}.09f", "service":%{public}lu}
{"msg%{public}.0s":"#usesync Stopping remote location service", "client":%{public, location:escape_only}s, "stop time_s":"%{public}.09f", "service":%{public}lu}
{"msg%{public}.0s":"Couldn't get keys?!"}
#authsync addObject: %{public}s %{public}u %{public}u %{public}d
#authsync deleteObject: %{public}s
#authsync sending kNotificationReset to the watch
#authsync received kNotificationReset from the companion
last improve accuracy notification for %s, %f, retry interval, %f
clear %s improve accuracy notification
{"msg%{public}.0s":"Incomplete Reset, trying again", "ResetRetrialCount":%{public}ld, "Pending ResetIdentifiers":%{public, location:escape_only}@}
ResetRetrialCount exhausted.
#authsync initializing sync store
#authsync isWatch: %{public}d, isCompanion: %{public}d
{"msg%{public}.0s":"#warning uninstalled expiration time interval overridden", "uninstalledExpirationTimeInterval":"%{public}f"}
#warning Maximum location services enabled prompts per application overridden to %{public}d
Client unsubscription grace duration overridden to %{public}f
Will fault consumption score increases for %s
{"msg%{public}.0s":"Ending #provisional intermediation reign guarantee due to staleness", "king":%{public, location:escape_only}s}
airplane mode enabled, %d.
failed to fetch airplane mode state.
#warning Can't get clients for filing crash-grace CLInUseAssertions
#warning Can't get client state for key:%{public}s to file crash-grace CLInUseAssertions
Client %s had ongoing background location, taking temporary crash-grace CLInUseAssertion
Sending app status change notification
Client %{public}s disconnected
Got disconnection for unknown client
{"msg%{public}.0s":"destruction without invalidation", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Skipping Reset, already in progress.
#warning location services settings are frozen by restrictions - resetting
resetting and disconnecting all clients from daemon
reset identifiers saved to settings
Client record is nil in CLClientManager::copyClients for clientKey %{public}@
{"msg%{public}.0s":"Sliding CorrectiveCompensationUnspecified(0) to CorrectiveCompensationOn(2)", "Client":%{public, location:escape_only}s}
Client %s allowable mask (%lu) no longer contains authorization level (%lu) downgrading to (%lu)
currently %{public}lu non-system location clients
{"msg%{public}.0s":"Non-persistent SLC usage detected"}
#Warning, new start time for %s is after it's stored time
Service: key, %s, type, %s, active, %d
Service: name, %s, type, %s, marked as used
clearing regions for client '%s'
clearing significant location change for client '%s'
{"msg%{public}.0s":"#appclip looking for authorizations to clear"}
{"msg%{public}.0s":"#warning #appclip entry has TMMonotonicClock registration time in the future??", "client":%{public, location:escape_only}s, "now":"%{public}f", "timeGivenAuth":"%{public}f"}
{"msg%{public}.0s":"#appclip detected RTC reset count > 1", "rtcResetCount":%{public}u}
{"msg%{public}.0s":"#appclip client authorization has gone on long enough! PURGE!", "client":%{public, location:escape_only}s, "now":"%{public}f", "timeGivenAuth":"%{public}f", "delta":"%{public}f"}
{"msg%{public}.0s":"#appclip client is spared from the PURGE... for now", "client":%{public, location:escape_only}s, "now":"%{public}f", "timeGivenAuth":"%{public}f"}
{"msg%{public}.0s":"#appclip removing client because it expired", "client":%{public, location:escape_only}s}
How can an app be missing if we don't have an entry for it?
{"msg%{public}.0s":"#AuthPrompt Teardown Inflight Prompt", "ClientKey":%{public, location:escape_only}s, "PromptType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "Teardown Reason":%{public, location:PromptTeardownReason}lld}
couldn't get keys for client dictionary
#Error no bundle ID or bundle path found - enabling background indicator %{public}s
Requesting client (%{public}s) purpose for unsupported registration type %{public}d
purpose string from %s's bundle: '%s'
purpose string from %s's property: '%s'
{"msg%{public}.0s":"Could not create ImproveAccuracyPrefs notification", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"Could not create runloop source for ImproveAccuracyPrefs notification", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"createClientPrefsNotification: BundleDisplayName nil", "client":%{public, location:escape_only}s}
Could not create client prefs notification for %{public}s
Could not create runloop source for client prefs notification for %{public}s
unknown registsration result %{public}d
Setting executable: %{public}s, bundle: %{public}s, bundle path: %{public}s background indicator to %{public}d
location services settings are frozen by restrictions - denying %{public}s
Setting executable: %{public}s, bundle: %{public}s, bundle path: %{public}s authorization to %{public}d (%{public}s)
retrieved empty non-system location client key
Location services available %d; parental controls enabled %d (refresh %d)
#warning location is restricted; freezing client states
location is not restricted
{"msg%{public}.0s":"Removing obsolete client record key from client", "ClientKey":%{public, location:escape_only}@, "ClientRecordKey":%{public, location:escape_only}@, "ClientRecordValue":%{private, location:escape_only}@}
No registered clients for kNotificationReset.
Found regsietred client for kNotificationReset with empty resetIdentifier
Skip un-tracked resetIdentifier: %s
{"msg%{public}.0s":"fetched reset-identifiers", "ResetIdentifiers":%{public, location:escape_only}@}
NameValuePair::get failed despite our bounds checking
#warning %{public}s time started exists (%{public}.2f), but time stopped (%{public}.2f) doesn't exist or is earlier for %{public}s - setting to %{public}.2f
Resuming client '%s'
Failed to resume '%{public}s': init failure
#warning Failed to resume '%{public}s': assertion not acquired
Non-app client is was a background client?
Scheduling pending app status event
#warning %{public}s region time started exists (%{public}.2f), but time stopped (%{public}.2f) doesn't exist or is earlier for %{public}s - setting to %{public}.2f
stop range for client '%s'
client, '%s', app's client cnt, %d, active, %d
{"msg%{public}.0s":"#AuthPrompt User responded to prompt for client", "key":%{public, location:escape_only}@, "requestType":%{public}d, "response":%{public}d}
{"msg%{public}.0s":"#AuthPrompt User dismissed prompt for client", "key":%{public, location:escape_only}@}
{"msg%{public}.0s":"Impossible response to Plain, Vanilla, or Legacy Anything prompt", "key":%{public, location:escape_only}@, "flags":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth Client has been granted temporary WIU status", "ClientKey":%{public, location:escape_only}@}
{"msg%{public}.0s":"Impossible response to LocationButtonUse prompt", "key":%{public, location:escape_only}@, "flags":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth granted temporary auth , allowed chosen on #LocationButtonUse prompt", "ClientKey":%{public, location:escape_only}@}
{"msg%{public}.0s":"Impossible response to WhenInUse Upgrade to Always prompt", "key":%{public, location:escape_only}@, "flags":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#provisional prompt response", "ClientKey":%{public, location:escape_only}@, "GrantedStatus":%{public, location:CLClientAuthorizationStatus}lld, "FollowupPending":%{public}hhd}
{"msg%{public}.0s":"Non-#provisional WIU to Always #AuthPrompt prompt response", "ClientKey":%{public, location:escape_only}@, "GrantedStatus":%{public, location:CLClientAuthorizationStatus}lld, "BypassingSomeoneElseOnDeck":%{public}hhd}
{"msg%{public}.0s":"Temporary relief from #compensation response", "ClientKey":%{public, location:escape_only}@, "TempPrecise":%{public, location:escape_only}s}
{"msg%{public}.0s":"Unexpected authorization status for #TemporaryAuth precise promptee", "ClientKey":%{public, location:escape_only}@, "AuthMask":%{public}lu}
{"msg%{public}.0s":"#AdvisorySubIdentity response", "ClientKey":%{public, location:escape_only}@, "TempPrecise":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt response", "ClientKey":%{public, location:escape_only}@, "IncidentalUseMode":%{public, location:escape_only}s}
#AuthPrompt Received response (%{public}d) for invalid/unrecognized response type (%{public}d)
open preferences with url, %{public}s
Couldn't create Preferences URL, %{public}s
could not launch Preferences
{"msg%{public}.0s":"#AuthPrompt User responded on BigSwitch prompt", "key":%{public, location:escape_only}s, "response":%{public}d}
#warning no user response to client %{public}s (flags 0x%{public}lx)
{"msg%{public}.0s":"#AuthPrompt User responded on ImproveAccuracyPrefs prompt", "key":%{public, location:escape_only}s, "response":%{public}d}
ImproveAccuracyNotification object not created for notification, %{public}p
#warning no user response for improve accuracy prefs notification %{public}s (flags 0x%{public}lx)
ResetTimer fired
Reset registration and completion reporting is un-balanced. Completion not reported for clients: %@
Reset registration and completion reporting is balanced for all clients.
#reset-retry completing pending reset.
#reset-retry - service with identifier: %@ never checked in to retry handling reset after crash
Setting executable %s
Setting bundle ID %s and executable %s
Unknown notification: %{public}d
AppMonitor notification, %d, %s, pid, %d, bundleId, %s
Deleting entry for %s
'%{public}s' task suspended: removing client
Trial period #reprompt disarmed by foregrounded app
wifi power state, %d.
wifi enabled
{"msg%{public}.0s":"#sbim system service switch state changed", "from":%{public}hhd, "to":%{public}hhd}
{"msg%{public}.0s":"#sbim unsupported system system service notification for entity", "notification":%{public, location:CLStatusBarIconManager_Type::Notification}lld, "entityClass":%{public, location:CLStatusBarIconManager_Type::EntityClass}lld}
bluetooth power state, %d.
bluetooth enabled
{"msg%{public}.0s":"Sucessfully removed file at path to locScoreInfoReport"}
{"msg%{public}.0s":"Unable to remove file at path to locScoreInfoReport", "error":%{public, location:escape_only}@}
#warning Can't migrate "%{public}s" to "%{public}s": client already exists with an auth of "%{public}d"
Can't migrate "%{public}s" to "%{public}s": NVP failure
Migrated "%{public}s" to "%{public}s"
"%{public}s" not found, skipping migration
Removing entry for bundle ID %{public}s if present
Removing entry for bundle path %{public}s if present
#warning bundle path, '%{public}s', does not exist on disk;  clearing.
AuthMigrate(%{public}s): Authorization mask contains Always but not WhenInUse
AuthMigrate(%{public}s): Skipping: no Authorized key
AuthMigrate(%{public}s): Preserving Authorization over Authorized
AuthMigrate(%{public}s): Y => Always
AuthMigrate(%{public}s): N => Never
AuthMigrate(%{public}s): Authorization mask already available
AuthMigrate(%{public}s): Imputing default supported authorization mask
Client %{public}s missing for authorization update, but didn't we just create it?
Unable to save clients list after migration, data loss due to crash possible
{"msg%{public}.0s":"Zone not found - updating zone static authorization", "client":%{public, location:escape_only}s, "zoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"update client authorization mask", "name":%{public, location:escape_only}s, "old":%{public}d, "new":%{public}lu, "oldCC":%{public}d, "newCC":%{public}d, "localAuthorizationChange":%{public}d}
{"msg%{public}.0s":"#authsync First time authorization on the gizmo", "app":%{public, location:escape_only}s, "authorization":%{public}d, "correctiveCompensation":%{public}d}
{"msg%{public}.0s":"#authsync Upgrade authorization on the gizmo", "app":%{public, location:escape_only}s, "authorization":%{public}d, "correctiveCompensation":%{public}d, "numberOfTimesPrompted":%{public}d}
{"msg%{public}.0s":"#authsync Corrective compensation state changed on the gizmo", "app":%{public, location:escape_only}s, "authorization":%{public}d, "correctiveCompensation":%{public}d, "numberOfTimesPrompted":%{public}d}
{"msg%{public}.0s":"#authsync Setting SyncedAuthorizationDecisionOnGizmo=true", "app":%{public, location:escape_only}s, "authorization":%{public}d}
{"msg%{public}.0s":"#authsync SyncedAuthorizationDecisionOnGizmo=false for the incoming auth change", "app":%{public, location:escape_only}s, "authorization":%{public}d}
{"msg%{public}.0s":"#authsync SyncedAuthorizationDecisionOnGizmo is already set to true", "app":%{public, location:escape_only}s, "authorization":%{public}d}
#warning New authMask %{public}lu for client %{public}s implicitly extends its supported mask (%{public}d) until next connection & slide
{"msg%{public}.0s":"setting authorization value", "client":%{public, location:escape_only}s, "newAuth":%{public}lu}
{"msg%{public}.0s":"Setting registration time for #appclip", "client":%{public, location:escape_only}s, "registrationTime":"%{public}f"}
{"msg%{public}.0s":"#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient: unknown client"}
{"msg%{public}.0s":"#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient may not take nil data", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth encountered error while decoding", "error":%{public, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth missing one or more keys from decoded dict", "target":%{public}lu, "found":%{public}lu}
{"msg%{public}.0s":"#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient failed to find a timestamp in the packaged data. Ignoring the packet", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient stale info received", "tNow":%{public}ld, "sentTime":%{public}ld}
{"msg%{public}.0s":"#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient", "hasPrecise":%{public}hhd, "inUseInt":%{public}d, "hasWIU":%{public}hhd}
{"msg%{public}.0s":"#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient releasing in use assertion"}
{"msg%{public}.0s":"#TemporaryAuth retrieveTemporaryAuthorizationStatusInfoForClient", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#TemporaryAuth retrieveTemporaryAuthorizationStatusInfoForClient: unknown client"}
{"msg%{public}.0s":"#TemporaryAuth retrieveTemporaryAuthorizationStatusInfoForClient", "tNow":%{public}ld, "inUse":%{public}d, "hasTempWIU":%{public}hhd, "hasTempPrecise":%{public}hhd}
{"msg%{public}.0s":"#TemporaryAuth encountered error while converting", "error":%{public, location:escape_only}s}
#appclip setting for bundle ID %s
{"msg%{public}.0s":"#appclip no such client", "clientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#appclip setOrChangeAppClipAuthorizationTime", "client":%{public, location:escape_only}s, "registrationTime":"%{public}f", "delta":"%{public}f"}
{"msg%{public}.0s":"update client background indicator enabled", "name":%{public, location:escape_only}s, "old":%{public}d, "new":%{public}lu}
Registering coreanalytics activity
coreanalytics activity run
coreanalytics activity check-in
{"msg%{public}.0s":"get #pla zone nvp", "ClientNvp":%{public, location:escape_only}@, "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla retreive zone nvp. No InterestZones", "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla retreive zone nvp. InterestZone does not exist.", "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"set #pla zone-nvp to client-nvp", "ClientNvp":%{public, location:escape_only}@, "zoneNvp":%{public, location:escape_only}@, "ZoneId":%{public, location:escape_only}s}
#IncidentalPrompt skip prompting. No client for incidental prompt
{"msg%{public}.0s":"#IncidentalPrompt Ineligible marking as NotDetermined", "Client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#IncidentalPrompt skip prompting. IncidentalUseMode should be UnDetermined", "ClientKey":%{public, location:escape_only}s, "IncidentalUseMode":%{public, location:CLClientIncidentalUseMode}lld}
{"msg%{public}.0s":"#IncidentalPrompt skip prompting. Registration Result should be WIU", "ClientKey":%{public, location:escape_only}s, "RegistrationResult":%{public}d}
{"msg%{public}.0s":"#IncidentalPrompt skip prompting. Restrictions enabled", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#IncidentalPrompt client queued", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#IncidentalPrompt skip prompting. Not at homescreen.", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#IncidentalPrompt skip prompting. InflightPromptAuthorizationRequest found.", "ClientKey":%{public, location:escape_only}s, "inflightClientKey":%{public, location:escape_only}s, "inflightRequestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}
{"msg%{public}.0s":"#Warning Could not post #IncidentalUsePrompt", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"Skip completion reporting. No Reset in progress", "Identifier":%{public, location:escape_only}s}
Reset registration and completion reporting is un-balanced. Completion of Reset reported for unregistered identifier: %@
{"msg%{public}.0s":"reset completion reporting", "Current Identifier":%{public, location:escape_only}s, "ResetIdentifiers Snapshot":%{public, location:escape_only}@, "Count":%{public}ld}
Completion reported back for all Reset registered clients
{"msg%{public}.0s":"Registration for InterestZone #pla", "clientKey":%{public, location:escape_only}s, "type":%{public, location:CLClientInterestZoneType}lld, "zoneIdentifier":%{public, location:escape_only}s, "lat":"%{private}7f", "lon":"%{private}7f", "radius":"%{public}.3f", "PhenolicLocation":%{public, location:CLClientPhenolicLocation}lld, "ServiceMaskOperator":%{public, location:CLClientInterestZoneServiceMaskOperator}lld, "ProvenanceType":%{public, location:CLClientInterestZoneProvenanceType}lld}
{"msg%{public}.0s":"Zone radius too small. Updated to min threshold", "ClientKey":%{public, location:escape_only}s, "ZoneIdentifier":%{public, location:escape_only}s, "MinRadiusThreshold":"%{public}.3f"}
{"msg%{public}.0s":"Zone radius too large. Updated to max threshold", "ClientKey":%{public, location:escape_only}s, "ZoneIdentifier":%{public, location:escape_only}s, "MaxRadiusThreshold":"%{public}.3f"}
{"msg%{public}.0s":"AuthZone operation failed.", "Error":%{public, location:escape_only}s, "ClientKey":%{public, location:escape_only}s, "ZoneIdentifier":%{public, location:escape_only}s}
{"msg%{public}.0s":"InterestZone registered", "ClientKey":%{public, location:escape_only}s, "ZoneIdentifier":%{public, location:escape_only}s}
{"msg%{public}.0s":"SetRelevanceForInterestZone", "clientKey":%{public, location:escape_only}s, "zoneIdentifier":%{public, location:escape_only}s, "isRelevant":%{public}hhd}
{"msg%{public}.0s":"Delete InterestZone", "clientKey":%{public, location:escape_only}s, "zoneIdentifier":%{public, location:escape_only}s}
{"msg%{public}.0s":"invalid zone config", "ForKey":%{public, location:escape_only}s, "Zone":%{public, location:escape_only}@}
{"msg%{public}.0s":"value-type validation of Info.plist zone received un-recongnised zone type", "ZoneType":%{public, location:CLClientInterestZoneType}lld}
{"msg%{public}.0s":"check #pla zones are identical", "Zone1":%{public, location:escape_only}@, "Zone2":%{public, location:escape_only}@}
{"msg%{public}.0s":"#pla #authsync info.plist zones", "CompanionBundleId":%{public, location:escape_only}s, "WatchSideBundleId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla #authsync apply zone-sync info.plist zones", "ClientKey":%{public, location:escape_only}s, "effectiveBundle":%{public, location:escape_only}@, "Info.plist Zones":%{public, location:escape_only}@}
{"msg%{public}.0s":"ClientsPlistZone is stale. Not found in Info.plist. Delete", "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"Zone unchanged. Remove from infoPlistZones. Will skip registration", "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"Zone has been updated. Delete from clients.plist first. Will be re-registered", "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla no-eligible info-plist zones for registeration", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"final info.plist zones for #pla registeration", "ClientKey":%{public, location:escape_only}s, "InfoPlistZones":%{public, location:escape_only}@}
{"msg%{public}.0s":"#warning Info.plist zone registration failed. Invalid zone.", "ClientKey":%{public, location:escape_only}s, "ZoneId":%{public, location:escape_only}s, "Info.PlistZone":%{public, location:escape_only}@}
{"msg%{public}.0s":"registerAndReconcile only consumes info-plist zone or synced-info-plist zone", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#pla #reconcile registered zone not in zonesReconciliationLedger. No collapsing", "clientKey":%{public, location:escape_only}s, "zoneIdToWrite":%{public, location:escape_only}s, "zoneIdToReconcile":%{public, location:escape_only}s, "isSyncedZone":%{public}hhd}
#pla #reconcile SyncedInfoPlistZone:%@ collapsed to :%@
{"msg%{public}.0s":"#pla #reconcile existing entry for collapsing not found", "clientKey":%{public, location:escape_only}s, "zoneIdToWrite":%{public, location:escape_only}s, "zoneIdToReconcile":%{public, location:escape_only}s, "isSyncedZone":%{public}hhd}
{"msg%{public}.0s":"info.plist zone registration, zone-to-reconcile should exists in clients.plist", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"info.plist zone registration, zone-to-reconcile should be identical to registered zone", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#pla #reconcile existing entry for collapsing not identical. Delete existing entry", "clientKey":%{public, location:escape_only}s, "zoneIdToWrite":%{public, location:escape_only}s, "zoneIdToReconcile":%{public, location:escape_only}s, "isSyncedZone":%{public}hhd}
{"msg%{public}.0s":"#pla #reconcile Collapsing, existing entry identical. Using existing entry, deleting new entry", "clientKey":%{public, location:escape_only}s, "zoneIdToWrite":%{public, location:escape_only}s, "zoneIdToReconcile":%{public, location:escape_only}s, "isSyncedZone":%{public}hhd}
#pla restarting zone relevance-monitoring. clients.plist is empty
{"msg%{public}.0s":"#pla restarting relevance-monitoring for zones", "Client":%{public, location:escape_only}s}
{"msg%{public}.0s":"RegistrationResult from nvp", "LocationDictionaryUtility AuthMask":%{public}d, "nvp":%{public, location:escape_only}@}
{"msg%{public}.0s":"#CUN Could not create CFUserNotificcation", "Client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#CUN Created client user notification for client", "name":%{public, location:escape_only}s, "requestType":%{public}d}
{"msg%{public}.0s":"#CUN Could not create runloop source for  CFUserNotificcation", "Client":%{public, location:escape_only}s}
CL: CLClientManager::onDarwinNotification
{"msg%{public}.0s":"CLClientManager::onDarwinNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLClientManager::onCarrierNotification
{"msg%{public}.0s":"CLClientManager::onCarrierNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLClientManager::onStatusNotification
{"msg%{public}.0s":"CLClientManager::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLClientManager::onRestrictionsChangedNotification
{"msg%{public}.0s":"CLClientManager::onRestrictionsChangedNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLClientManager::onAppMonitorNotification
{"msg%{public}.0s":"CLClientManager::onAppMonitorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLClientManager::onDaemonStatusNotification
{"msg%{public}.0s":"CLClientManager::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLClientManager::onWifiServiceNotification
{"msg%{public}.0s":"CLClientManager::onWifiServiceNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLClientManager::onBluetoothServiceNotification
{"msg%{public}.0s":"CLClientManager::onBluetoothServiceNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLClientManager::onStatusBarNotification
{"msg%{public}.0s":"CLClientManager::onStatusBarNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#warning could not get localized string '%{public}s'!
could not get UN localized bundle name from bundle at '%{public}s'; soup cannot be given to them.
{"msg%{public}.0s":"#AuthPrompt #Thunk CFUserNotification", "ResponseFlag":%{public}d, "HasInflightAuthPromptRequest":%{public}hhd, "ThunkCFUN":%{public, location:escape_only}@, "InflightCFUN":%{public, location:escape_only}@}
#AuthPrompt #Thunk InflightAuthPromptRequest has unexpected state
{"msg%{public}.0s":"Request was completed multiple times"}
{"msg%{public}.0s":"#AuthPrompt AuthorizationRequest completion", "ClientKey":%{public, location:escape_only}s, "RequestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}
{"msg%{public}.0s":"dynamic_pointer_cast must never fail in this context", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Creating persistent subscription due to demand", "type":%{public, location:escape_only}s, "clientKey":%{public, location:escape_only}s}
Client %{public}s connected
CLRS,CLRTD,too few points to detect
CLRS,CLRTD,failed to convert input points to enu coordinates
CLRS,CLRTD,loopStartIndex,%lu,loopEndIndex,%lu,out of enuCoordinates size,%lu
CLRS,CLRTD,loop detected from,%.1lf,to,%.1lf
CLRS,CLRTD,Warning,Could not convert LLA Coordinate %{private}.7lf,%{private}.7lf to ENU
CLRS,CLRTD,Not enough points to detect loop
CLRS,CLRTD,non-track detected,numOutOfBoundaryPoints,%d,numOfPoints,%lu
CLRS,CLRTD,track detected,numOutOfBoundaryPoints,%d,numOfPoints,%lu
[VO2MaxRetrocomputeHistory] Database inaccessible, unable to delete records.
{"msg%{public}.0s":"#slv Malformed visit", "visit":%{private, location:escape_only}@}
{"msg%{public}.0s":"#slv key not found after we were told it was there", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Could not store client auth dates"}
{"msg%{public}.0s":"#slv Could not store significant location visit clients"}
{"msg%{public}.0s":"#slv ensureMonitoringWithType", "type":%{public}d, "monitoring":%{public}hhd, "leeching":%{public}hhd}
{"msg%{public}.0s":"#slv Currently leeching. Stop leeching and switch to monitoring"}
{"msg%{public}.0s":"#slv Begin monitoring"}
{"msg%{public}.0s":"#slv Currently monitoring. Stop monitoring and switch to leeching"}
{"msg%{public}.0s":"#slv Begin leeching"}
{"msg%{public}.0s":"#slv ensureStop", "monitoring":%{public}hhd, "leeching":%{public}hhd}
#slv Stop monitoring or leeching
{"msg%{public}.0s":"#slv Dropping old visit", "visit":%{private, location:escape_only}@}
{"msg%{public}.0s":"#slv Client in store with no interest", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Can't deliver visit to client that hasn't connected"}
{"msg%{public}.0s":"#slv Client has no interest", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Client is interested", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Cannot deliver a visit to a client without a key"}
{"msg%{public}.0s":"#slv Not delivering visit to client... not interested", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Client not authorized for visit", "key":%{public, location:escape_only}s, "authDate_s":"%{public}.09f"}
{"msg%{public}.0s":"#slv Delivering visit to client", "key":%{public, location:escape_only}s, "authDate_s":"%{public}.09f", "mangled":%{private, location:escape_only}@}
{"msg%{public}.0s":"#slv Client is connecting", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Tried to start monitoring for a client that isn't connected"}
{"msg%{public}.0s":"#slv Client start", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Tried to stop monitoring for a client that isn't connected"}
{"msg%{public}.0s":"#slv client stop", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv programmer error.  Only call this function after setting client interest to PendingDelete", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#slv Sending simulated visit to clients"}
{"msg%{public}.0s":"#slv Visit must be non-nil", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#slv Sending out visit", "visit":%{private, location:escape_only}@}
{"msg%{public}.0s":"#slv Launching", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Client not eligible to receive visit", "key":%{public, location:escape_only}s, "interested":%{public}hhd, "authDate_s":"%{public}.09f"}
{"msg%{public}.0s":"#slv Sending to clients", "visit":%{private, location:escape_only}@}
{"msg%{public}.0s":"#slv #warning Can't produce a meaningful authorization date before arming is complete.  Returning nil"}
{"msg%{public}.0s":"#slv Not checking for monitoring... not armed"}
{"msg%{public}.0s":"#slv Checking if SLV should be active"}
#slv Invalid interest type
{"msg%{public}.0s":"#slv should be monitoring"}
{"msg%{public}.0s":"#slv should be leeching"}
{"msg%{public}.0s":"#slv should be off"}
{"msg%{public}.0s":"#slv Couldn't get list of clients"}
{"msg%{public}.0s":"#slv Migrated value for key to a dictionary", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv invalid value found in plist"}
{"msg%{public}.0s":"#slv Attempting to notify nil visit"}
{"msg%{public}.0s":"#slv Received visit from routined", "visit":%{private, location:escape_only}@}
{"msg%{public}.0s":"#slv received unhandled notification", "notification":%{public}d}
{"msg%{public}.0s":"#slv Spoofing a Significant Visit", "visit":%{private, location:escape_only}@}
TILE: mmapTile, prefer local file name because it exists, %s
TILE: mmapTile, can't open, %s, errno, %d, %s
TILE: can't stat, %s, errno, %d, %s
TILE: can't stat, %{public}s, errno, %{public}d, %{public}s
TILE: mmap file size changed, %{public}s, size before mmap, %{public}ld, size after mmap, %{public}lld
TILE: mmap failed, %s, size, %lld, errno, %d, %s
TILE: corrupt header, fileGetNextSection, size, %zd, readto, %lld, %d
TILE: traverseTileFile, start, message, %s, isHeadersOnly, %d, isBinarySearch, %d, macAddressToSearch, %012llx
TILE: traverseTileFile, can't open tile
TILE: traverseTileFile, file is empty
TILE: thisSection, message, %s, readBytes, %lu, section, signature, 0x%x, sectionId, %d, sizeBytes, %d, headerSizeBytes, %d, name, %s
TILE: Invalid section signature, readBytes, %lu, section, signature, 0x%x, sectionId, %d, sizeBytes, %d
TILE: invalid tile file, bad allocation size, totalBytesInSection, %lu, maxAllocationSize, %lu
TILE: failed to allocate memory for, %lu
TILE: failed to read pSectionH, %lu, %lu
TILE: section, signature, 0x%x, sectionId, %d, headerSizeBytes, %u, sizeBytes, %u
TILE: ERROR: failed to fseek to, currentFileOffset, %lu, %u
TILE: traverseTileFile, done
TILE: CLTileFile, sectionId, %d, %s
TILE: tile, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, altitude, %f,  minAltitude, %f, maxAltitude, %f, numOfInputPoints, %d, generationTime, %.1f, expirationAge, %d, %d, age, %.1lf
TILE: onTraversingTileHeaderKeyLatLon, tileid, %s
TILE: tile.keylatlon, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, generationTime, %.1f, expirationAge, %d, age, %.1lf, sec_key, %016llx
TILE: tile.location, tileid, %s, serverName, %s
TILE: tile.location, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, generationTime, %.1f, expirationAge, %d, age, %.1lf
TILE: tileMacIndexHeader, headerSizeBytes, %u, tileMacIndexHeader, entrySizeInBytes, %u, numOfEntries, %u
TILE: idx, %3u, mac,%x:%x:%x:%x:%x:%x, offset, %u
TILE: tileAccessPointTable, headerSizeBytes, %u, tileAccessPointTable, entrySizeInBytes, %u, numOfEntries, %u
TILE: mac, %3u, mac,%x:%x:%x:%x:%x:%x, y, %3d, x, %3d, loc, %14.10lf, %14.10lf
TILE: read data, sectionId, %d, entriesOffset, %u, entriesNumToRead, %u
TILE: ERROR: failed to skip entries pre read, %u, ret, %d
TILE: ERROR: failed to read bytes, %u, %u
{"msg%{public}.0s":"initialized location source"}
location last altitude %.3lf last time %.3lf last location time %.3lf,indoorConfidence,%{private}.3lf, outdoorConfidence,%{private}.3lf,PositionOutdoorState,%{private}u,mapMatchType,%{private}u
underDEM, %d, altitude, %f, uncertainty, %f, demAltitude, %f, demUncertainty, %f, threshold, %f
good DEM data: location altitude state is %u
location altitude state %u
language changed - refreshing
could not use english as default language
#Warning could not get localizations array from bundle
#Warning could not get localizations for preferred languages
#Warning no localizations for preferred languages
getting '%s' localized strings for '%s'
#Warning could not get resource URL for %s
could not create input stream for %{public}s
could not deserialize data from URL for %{public}s, error, %{public}s
#Warning issue retrieving localized strings for bundle '%s'
key %{public}s does not contain a string value
no corresponding string for %{public}s
should not write to carrier bundle
CL: CLCarrierSettings::onTelephonyNotification
{"msg%{public}.0s":"CLCarrierSettings::onTelephonyNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#SystemState, Overriding device activation status check.
#SystemState, Unable to query pairing id, suspending activity tracking.
#SystemState, Unable to obtain pairing id, suspending activity tracking.
#SystemState, Failed to get fitness tracking state in Bridge->Motion&Fitness. It may not have been set yet. Assuming default.
#SystemState, Fitness tracking is disabled, suspending activity tracking.
#SystemState, Watch, Enabled, %{public}d, DeviceActivated, %{public}d, OnCharger, %{public}d
#SystemState, Pairing state changed
#SystemState, OverrideChargerType, %{public}d, NotifyChargerType, %{public}d
#SystemState, Device on-charger, suspending activity tracking.
#SystemState, Un-handled notification,%{public}d
{"msg%{public}.0s":"Workout Alert Flags", "Start Enabled":%{public}hhd}
{"msg%{public}.0s":"Workout Alert Flags", "Stop Enabled":%{public}hhd}
CM Activity Move Mode,%{public}d
CM Satellite Pairing State,%{public}d
CL: CLFitnessTrackingNotifier::fitnessTrackingStateChanged
{"msg%{public}.0s":"CLFitnessTrackingNotifier::fitnessTrackingStateChanged", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFitnessTrackingNotifierWatch::nanoLifestyleSessionTrackerAppPreferencesChanged
{"msg%{public}.0s":"CLFitnessTrackingNotifierWatch::nanoLifestyleSessionTrackerAppPreferencesChanged", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFitnessTrackingNotifierWatch::nanoLifestyleEnableFitnessDataCollectionSettingChanged
{"msg%{public}.0s":"CLFitnessTrackingNotifierWatch::nanoLifestyleEnableFitnessDataCollectionSettingChanged", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFitnessTrackingNotifierWatch::pairingStateChanged
{"msg%{public}.0s":"CLFitnessTrackingNotifierWatch::pairingStateChanged", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFitnessTrackingNotifierWatch::activityMoveModeChanged
{"msg%{public}.0s":"CLFitnessTrackingNotifierWatch::activityMoveModeChanged", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFitnessTrackingNotifierWatch::onBatteryNotification
{"msg%{public}.0s":"CLFitnessTrackingNotifierWatch::onBatteryNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLRS,EnableMapMatchingBeforeSmoothing,%{public}d,EnableMapMatchingAfterSmoothing,%{public}d,EnableReSmoothingAfterMapMatching,%{public}d,EnablePerEpochSmoothLogOutput,%{public}d,this->fEnableCornerDetectionDuringSmoothing_,%{public}d,this->fEnableRunningTrackDetectionDuringSmoothing_,%{public}d
CLRS,Starting smoother for workoutActivity,%{public}u
CLRS,CLMM mapMatching before smoothing failed
CLRS,smoother returned error
CLRS,CLMM mapMatching after smoothing failed
CLRS,resmoother returned error
CLRS,Smoothing,%{public}s,dataCount,%{public}zu,workout,%{public}u
CLRS,too few points to smooth
CLRS,CLCF,corner detection started
CLRS,CLCF,corner detection failed
CLRS,CLCF,Corner found,index,%{public}d,lat,%{private}.7f,lon,%{private}.7f
CLRS,CLCF,corner detection completed,dataCount,%{public}zu,elapsedTime,%{public}lld,msec
CLRS,CLCF,corner detection disabled
CLRS,gap detection started
CLRS,gap found,index,%{public}d,time,%{public}.1lf,gap,%{public}.1lf,lat,%{private}.7f,lon,%{private}.7f
CLRS,CLRTD,running track detection started
CLRS,CLRTD,Running track detection failed
CLRS,CLRTD,running track detection completed,dataCount,%{public}zu,elapsedTime,%{public}lld,msec
CLRS,CLRTD,Running track detected!
CLRS,CLRTD,running track detection disabled
CLRS,input data contains Null Island or non-positive horizontal uncertainty. Will not attempt to smooth.
CLRS,smoother is unhealthy
CLRS,Indexing error,startToOutput,%zu,endToOutput,%zu,smoothedSegment,%zu
CLRS,smoothed segment,#%{public}zu,dataCount,%{public}zu,elapsedTime,%{public}lld,msec
CLRS,smoothing all segments completed,segmentCount,%{public}zu,elapsedTime,%{public}lld,msec
CLRS,Smoother,type,%{public}s,dataCount,%{public}zu,elapsedTime,%{public}lld,msec,workout,%{public}u
CLRS,CLMM mapMatching,%{public}s,workout,%{public}u,dataCount,%{public}zu
CLRS,CLMM,Unsupported activity type
CLRS,CLMM,Failed to create geometry pointer
CLRS,CLMM,Failed to create mapmatcher pointer
CLRS,CLMM,type,%{public}s,dataCount,%{public}zu,elapsedTime,%{public}lld,msec,workout,%{public}u
CLRS,%{public}.1lf,%s,latitude,%{private}.8lf,longitude,%{private}.8lf,altitude,%{private}.2lf,speed,%{public}.2lf,course,%{public}.2lf,hunc,%{public}.2lf,vunc,%{public}.2lf,speedUnc,%{public}.2lf,courseUnc,%{public}.2lf,signalEnvironment,%{public}d
CLRS,Unhandled CLMotionActivity workout type,%d
CLRS,CLMM,fillCrumb,Null Island
CLRS,CLMM,China shift returned false
CLRS,Unhandled CLClient signal environment type
CLRS,Unhandled signal environment type
VO2MaxAlert,fAlertBlackoutDuration,%{private}.3f,fRepeatAlertWindow,%{private}.3f,fHistoricalEstimateWindow,%{private}.3f,fMaxHistoricalEstimatesForAlert,%{private}d,fMinDaysWithEstimate,%{private}d,fMinEstimatesSinceAlgChange,%{private}d
VO2MaxAlert,gender,%{private}d,age,%{private}f,biologicalSex,%{private}d
VO2MaxAlert,HistoricalEstimateBiasAdjustment,startTime,%{public}.3f,estimatedVO2Max,%{public}.3f,biasAdjustment,%{public}.3f
VO2MaxAlert,ageOutOfRange,%{public}d,age,%{private}.3f,inBlackoutPeriod,%{public}d,mostRecentAlertStartTime,%{private}.3f,alertBlackoutDuration,%{private}.3f,estimateTime,%{public}.3f, sufficientDaysWithEstimate,%{public}d,queryFromTime,%{public}.3f,numberOfEstimates,%{public}lu,countDaysWithEstimate,%{public}d,numWorkoutsContrToLatestEstimate,%{public}d,sufficientEstimatesSinceAdaptiveModel,%{public}d, earliestTimestampSinceAdaptiveModel,%{public}.3f,countEstimatesSinceAdaptiveModel,%{public}d,earliestTimestampSinceHunterC,%{public}.3f,latestVO2Max,%{private}.3f,lowClassificationThreshold,%{private}.3f, shouldTriggerAlert,%{private}d,isRepeatAlert,%{private}d,repeatAlertWindow,%{private}.3f
VO2MaxAlert,Unexpectedly not able to retrieve a session record since algorithm version %{public}.3d
VO2MaxAlert,estimateTime,%{public}.3f,isCurrentEstimateLow,%{private}d,isRecentActivityLow,%{private}d,weightedAvg,%{private}.3f,std,%{private}.3f,lowAlertThreshold,%{private}.3f
CELL_LOC: failed to bind %s
CELL_CEN: adding cell, %s, rowid, %lld
Starting up CLPredictedWalkDistanceServiceWatch
Attempting to send ids message from watch to phone
CLPredictedWalkDistanceServiceWatch: Received user info update
SignificantElevation subscription changed, %s, %p, %d
#Warning Failed to subscribe to significant elevation updates.
#Warning Failed to subscribe to filtered elevation updates.
Programmer error: Wrong parameters were passed.
%{public}s is not entitled for motion updates
AbsoluteAltitude subscription changed, %s, %p, %d
#Warning Failed to subscribe to absolute altitude updates.
CL: CLElevationSubscription::onOdometerUpdate
{"msg%{public}.0s":"CLElevationSubscription::onOdometerUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Watch Orientation,Orientation Notifier Instantiated
Watch Orientation,Orientation Notifier is shutting down.
Watch Orientation,Added client for %d, count %d
Watch Orientation,Removed client for %d, count %d
Watch Orientation,Crown orientation setting key is invalid, defaulting to crown on right (not inverted)
Watch Orientation,Wrist orientation setting key is invalid, defaulting to left wrist
Watch Orientation,crown,%{public}d,wrist,%{public}d
Watch wrist state %{public}d
CL: CLWatchOrientationSettingsNotifier::onOrientationSettingsChanged
{"msg%{public}.0s":"CLWatchOrientationSettingsNotifier::onOrientationSettingsChanged", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Stair Climbing, load calibration, %d, HR mode, %d, mets scaling factor, %f, VO2max scaling factor, %f
Stair Climbing, Work Rate Model, timestamp, %f, step frequency, %f, WRMETS, %f, sinceLastGood, %f
Stair Climbing, HR Rate Model, timestamp, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, METS, %f
Stair Climbing, timestamp, %f, HRMETs, %f, WRMETs, %f, calibrationValue, %f, loadCalStatus, %d
Stair Climbing, timestamp, %f, finalMETS, %f, fMetsScaling, %f
#warning: error serializing json data, error, %s
#diagnosticManager beginService
#diagnosticManager endService
Add file to #diagnosticManager: %{public}@
Trying to register a nil NSURL
Remove file to #diagnosticManager: %{public}@
Trying to unregister a nil NSURL
Client requested #diagnosticManager file copy to dest: %@
diagnosticManager trying to copy file: %@
{"msg%{public}.0s":"Failed to copy diagnostic file", "srcURL":%{public, location:escape_only}@, "dstURL":%{public, location:escape_only}@, "error":%{public, location:escape_only}@}
#diagnosticManager received new XPC Connection request
Why didn't we get a connection?
{"msg%{public}.0s":"#diagnosticManager missing entitlement", "entitlement":%{public, location:escape_only}s, "pid":%{public}d}
#diagnosticManager Interruption handler called
#diagnosticManager Invalidation handler called
#diagnosticManager Resuming XPC Connection: %@
#diagnosticManager fileManager asking if should copy from %@ to %@
Trying to move a file that is not in our cache directory: %@
Assertion failed: (fIirFilterParams != __null) && (fIirFilterParams->filterOrder <= kMaxFilterOrder), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMIirFilter.cpp, line 20,IirFilterParams,%p,filterOrder,%d,maxFilterOrder,%d.
configuration: low band = [%d %d] high band [%d %d]
configuration: classifierMinLowPower = %f, classifierMaxLowPower = %f, classifierMaxHighPower = %f
configuration: theta = [%.2f %.2f %.2f %.2f %.2f %.2f]
configuration: oddsThreshold = %f, medianFilterSize = %zu, confidenceThreshold = %f, useHysteresis = %d, useAngleOverride = %d, angleMetricThreshold = %f
Accel saturation detected, forcing OnBody.
Assertion failed: fHeadAndSize.fSize == 0 && fHeadAndSize.fHead == 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMQueue.h, line 90,size,%u,head,%u.
Application state changed, %d
Large time gap, %lf
Reset while backgrounded
Invalid cpas data.
The cpas data is not a CFData type.
#Warning Cpas data is NULL.
#Warning Cpas pointer is NULL.
Unexpected cpas version: %u.
Original serial number data is NULL.
Original serial number pointer is NULL.
Invalid back camera serial number data.
Incorrect back camera serial number length. Actual length %ld. Expected length %lu.
Current serial number data is NULL.
Bailing while checking VCM actuator ID.
VCM actuator ID data type %d does not match expected type %d
#Warning CPAS data is NULL.
#Warning CPAS pointer is NULL.
{"msg%{public}.0s":"Location #compensation gonna be Snapping", "Input":%{private, location:CLClientLocation}.*P}
#compensation GeoLocation coarseMetaData: %@
#compensation GeoLocation coarseMetaData encoding failed, error, %@
{"msg%{public}.0s":"Location #compensation Snapping", "Input":%{private, location:CLClientLocation}.*P, "Output":%{private, location:CLClientLocation}.*P, "distance":"%{public}f", "GeoResultCode":%{public}ld}
{"msg%{public}.0s":"#pla #zone-relevance-monitoring cannot create CircularRegion", "Client":%{public, location:escape_only}s, "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla #zone-relevance-monitoring for circular-region", "monitoring":%{public, location:escape_only}s, "latitude":"%{public}.7f", "longitude":"%{public}.7f", "radius":"%{public}.3f", "Client":%{public, location:escape_only}s, "ZoneId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla #zone-relevance-monitoring region-monitoring started", "RegionIdentifier/ZoneRelevanceMonitoringId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla #zone-relevance-monitoring region-monitoring failed to start", "RegionIdentifier/ZoneRelevanceMonitoringId":%{public, location:escape_only}s, "Error":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla #zone-relevance-monitoring entered circular region", "RegionIdentifier/ZoneRelevanceMonitoringId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla #zone-relevance-monitoring exited circular-region", "RegionIdentifier/ZoneRelevanceMonitoringId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla #zone-relevance-monitoring determined state", "State":%{public}d, "RegionIdentifier/ZoneRelevanceMonitoringId":%{public, location:escape_only}s}
{"msg%{public}.0s":"#pla locationManager delegate received error", "Error":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning open failed", "errno":%{public, location:escape_only}s, "path":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Warning failed to concatenate files", "leading":%{private, location:escape_only}@, "trailing":%{private, location:escape_only}@}
{"msg%{public}.0s":"failed to remove fs item", "path":%{private, location:escape_only}@, "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"removed fs item", "path":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Stream Stop timer fired"}
{"msg%{public}.0s":"#Stream Motion alarm stop timer fired"}
{"msg%{public}.0s":"#Stream Repeating motion state"}
{"msg%{public}.0s":"#Stream Sending alive again after a delay", "last timestamp":"%{public}f"}
{"msg%{public}.0s":"#Stream Sending alive again"}
{"msg%{public}.0s":"#Stream Shut down location"}
{"msg%{public}.0s":"#Stream #CLEEA change", "needed":%{public}hhd}
{"msg%{public}.0s":"#Stream CLMM Setting client map matching", "state":%{public}hhd}
{"msg%{public}.0s":"#Stream Setting fitness activity type", "state":%{public}hhd}
{"msg%{public}.0s":"#Stream Setting airborne activity type", "state":%{public}hhd}
{"msg%{public}.0s":"#Stream Starting", "new granularity":%{public, location:CLLocationStreamingGranularity}lld, "current granularity":%{public, location:CLLocationStreamingGranularity}lld}
{"msg%{public}.0s":"#Stream Unexpected granularity", "granularity":%{public, location:CLLocationStreamingGranularity}lld}
{"msg%{public}.0s":"#Stream Dropping location due to expiration", "timestamp":"%{public}f", "lifespan":"%{public}f"}
{"msg%{public}.0s":"#Stream Unexpected notification", "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"#Stream Motion state subscription", "is subscribed":%{public}d}
{"msg%{public}.0s":"#Stream Start motion alarm", "currently active":%{public}d}
{"msg%{public}.0s":"#Stream Stop motion alarm", "currently active":%{public}d}
{"msg%{public}.0s":"#Stream Unexpected motion notification", "notification":%{public}d}
{"msg%{public}.0s":"#Stream Missing data", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream Unrecognized message type", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#warning #Stream Message failed to send", "type":%{public, location:escape_only}s, "error":%{public, location:escape_only}@, "fatal":%{public}d}
{"msg%{public}.0s":"#Stream Message sent", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream Paired device has left us, stopping location"}
#cclp registering for un-supported notification: %s
{"msg%{public}.0s":"#cclp registration", "client-id":%{public}ld, "client":%{public, location:escape_only}@, "notification":%{public, location:escape_only}s}
{"msg%{public}.0s":"#cclp unregistration", "client-Id":%{public}ld, "client":%{public, location:escape_only}@, "notification":%{public, location:escape_only}s}
{"msg%{public}.0s":"Update #compensation #settings for CCLP", "CorrectiveCompensationInterval":"%{public}f", "ApparentCorrectiveCompensationInterval":"%{public}f", "CorrectiveCompensationClaimsOriginalAccuracy":%{public}hhd, "ClockAlignmentTestModeEnabled":%{public}hhd, "EnableClockAlignment":%{public}hhd, "CorrectiveCompensationIntervalLowerBound":"%{public}f", "CorrectiveCompensationIntervalUpperBound":"%{public}f"}
#cclp CorrectiveCompensationInterval changed. Reset CompensationTimer.
#warning #cclp ApparentCorrectiveCompensationInterval greater than CorrectiveCompensationInterval
#cclp ApparentCorrectiveCompensationInterval changed. Reset ApparentCompensationTimer.
#cclp: Clock Alignment disabled by default settings. Using default CC interval
#cclp: Clock Alignment disabled. Either TestMode should be enabled or CompensationInterval should be 15m. Check #compensation #settings
#cclp: next fire delay: %f
{"msg%{public}.0s":"#cclp ceasing apparent #compensation rate increase monitoring due to no cached message"}
#cclp CompensationTimer fired at : %f
{"msg%{public}.0s":"#cclp UpdateLastReceivedLocationTimer fired. Using location", "location":%{private, location:CLClientLocation}.*P}
#cclp #warning UpdateLastReceivedLocationTimer handler early return. LastReceivedLocation is invalid.
{"msg%{public}.0s":"#cclp notifying clients when CompensationTimer is scheduled. Not Allowed.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#cclp Simulation %s
#cclp CompensationTimer not scheduled and not subscribed to FLC
{"msg%{public}.0s":"#cclp Location Received", "Notification":%{public, location:escape_only}s, "location":%{private, location:CLClientLocation}.*P}
#cclp received location notification for un-supported notification: %s
#cclp skip notification: %s. CompensationTimer scheduled
#cclp skip notification: %s. UpdateLastReceivedLocationTimer scheduled
#cclp #warning invalid location. skip snapping
#cclp Encoded coarse meta data available
#cclp Simulation started. Random next fire delay: %f
CL: CLCorrectiveCompensatedLocationProvider::onSimulationNotification
{"msg%{public}.0s":"CLCorrectiveCompensatedLocationProvider::onSimulationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCorrectiveCompensatedLocationProvider::onLocationNotification
{"msg%{public}.0s":"CLCorrectiveCompensatedLocationProvider::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLC: Init power state: off
{"msg%{public}.0s":"CLC: Unknown CLCachedLocationController::CachedLocationState value", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLC: Debounce changed to %{private}lf [s]
CLC: Already in state %{private}s, %{private}lf
CLC: Cached Location changed state from %{private}s to %{private}s
CLC: Debounce timer fired, stopping
CLC: Received start route
CLC: Received end route
CLC: Received unknown notification, %{public}d
CLC: Recevied kNotificationAuthorization for %{private}s
CLC: Received Location Services status %{public}d
#Warning CLC: Received unknown notification, %{public}d
CLC: Resume for exception, %{public}#x, oldExceptions %{public}#x
CLC: Resume
CLC: Suspend for exception, %{public}#x, oldExceptions %{public}#x
CLC: Suspend
CL: CLCachedLocationController::onClientManagerNotification
{"msg%{public}.0s":"CLCachedLocationController::onClientManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCachedLocationController::onAppMonitorNotification
{"msg%{public}.0s":"CLCachedLocationController::onAppMonitorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCachedLocationController::onLocationUpdateNotification
{"msg%{public}.0s":"CLCachedLocationController::onLocationUpdateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#tiledownloadscheduler, add client, count, %ld
#tiledownloadscheduler, warning, client is re-subscribing
#tiledownloadscheduler, client unsubscribe, count, %{public}ld
#tiledownloadscheduler, callback, %{public}d
#tiledownloadscheduler, run, wifi connectivity, client count, %{public}ld
#tiledownloadscheduler, failed to mark activity as done. current state, %{public}ld
#tiledownloadscheduler, run, cellular connectivity, client count, %{public}ld
PressureQualityController::reset::%d => %d
PressureQualityController::setResult::%d => %d
CLMobility::SteadinessModelBalance::Features,intermediateBoutsAsymmetryPercentageMedian,%{private}.3f,intermediateBoutsAsymmetryPercentageCv,%{private}.3f,intermediateBoutsDoubleSupportPercentageMedian,%{private}.3f,intermediateBoutsDoubleSupportPercentageStd,%{private}.3f
Rejection: CLMobilitySteadinessModelBalance missing required feature inputs
SteadinessModelBalance::extractFeatures,classificationTime,%{public}.2f,numBouts,%{public}lu,doubleSupportPercentages,%{public}lu,asymmetryPercentages,%{public}lu
WorkloadCalibration, timestamp, %f, HRMETs, %f, WRMETs, %f, calibrationValue, %f, calibratedMets, %f
Workload Calibrator, DB Delete Records Before, expirationTime, %f
Workload Calibrator, DB Get All Records By Activity Type And Maximum Standard Deviation, activityType, %u, standardDeviation, %f
Workload Calibrator, Bootstraping Calibration, Value, %f
Workload Calibrator, DB Insert, activityType, %u, valueAverage, %f, standardDeviation, %f, entry.startTime, %f
Workload Calibrator, DB Delete Keep Last N, kMaximumDbHistorySize, %lu, activityType, %u
Workload Calibrator, DB Update, activityType, %u, valueAverage, %f, standardDeviation, %f, entry.startTime, %f
Taking gps odometer power assertion.
Releasing gps odometer power assertion.
#wigo,on,OdometerNotifierCompanion
#wigo,off,OdometerNotifierCompanion
onCoarseElevation,startTime,%{public}f,ascended,%{private}d,source,%{private}d
Odometer(GPS),%{public}f,%{private}f,%{public}f,%{private}f,%{private}f
#Warning Received unhandled location notification, %{public}d
CL: CLOdometerNotifierCompanion::onLocationNotification
{"msg%{public}.0s":"CLOdometerNotifierCompanion::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Bluetooth is OFF, ignoring request to scan
Found device %{private}s withData: %{private}s
Found a device but its UUID is nil
No IP address provided. Ignoring device
Not enough data provided for advertisement data. Ignoring
AirPlaySolo started scanning
AirPlaySolo stopped scanning
Failed to start AirPlaySolo scanning. %{public}@
init %s, %s
Resetting significant elevation %s, %s
significant elevation break frequency change, inVisit, %d, resetCheck, %d
%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%d,%s,%s,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f
%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%s,%s,%f
Not companion or watch. Returning.
AutomaticStrideCalibration,Pass,CreatingDaemonCacheForCalibrationBins
AutomaticStrideCalibration,Success,AllChecksPassed
setSession,oldSession,%ld,newSession,%ld
A new calData is added: %s
ForcingLocationDueToGizmoRequest,session,%ld,%s
StepRunNotification,Pass,LeechingLocation,Steps,%d
StepRunNotification,Pass,AttemptingToForceLocation,Steps,%d
AttemptForcedLocation,Fail,NotSufficientTimeSinceLastCalibrationSuccess,TimeSinceLastCalibrationSuccess,%0.3f
AttemptForcedLocation,Fail,NotSufficientTimeSinceLastCalibrationAttempt,TimeSinceLastCalibrationAttempt,%0.3f
AttemptForcedLocation,Fail,NotSufficientTimeSinceLastConverged,TimeSinceLastCalibrationAttempt,%0.3f
AttemptForcedLocation,Success,AllChecksPassed
Terminated forced calibration.
LocationStateOld,%d,LocationStateNew,%d
TrackClose,Pass,LocationTimeout,TimeSinceLastPosition,%0.3f
TrackClose,Pass,ForcedNotSufficientSteps,Steps,%d
TrackClose,Pass,EnabledNotSufficientSteps,Steps,%d
TrackCalibration,Fail,Pedometer distance is zero,startTime,%f,endTime,%f
TrackCalibration,Fail,rawSpeed %f out of bounds,startTime,%f,endTime,%f
TrackCalibration,Fail,KFactorOutOfBounds,%s,KFactor,%0.4f,RawSpeed,%f,startTime,%f,endTime,%f
SessionMetrics,Fail,Pedometer,GainOutOfBounds,DistanceFusion,%0.6f,startTime,%f,endTime,%f
SessionMetrics,Fail,GPS,GainOutOfBounds,DistanceFusion,%0.6f,startTime,%f,endTime,%f
CalData, %s, stepEntryEpochTime, %f
SessionMetrics,Fail,Gradient,DistanceFusion,startTime,%f,endTime,%f
FloorsAscended,%d,FloorsDescended,%d
{"msg%{public}.0s":"tile id doesn't exist in tiles map", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
DEM,clear AVL status cache
#Warning,DEM,availability file is not valid,fNeedToDownloadAvlFile,%{public}d
#Error,DEM,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d
DEM,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d
DEM,input latitude, %{private}.3lf, below minimum acceptable latitude, %{private}d
DEM,input latitude, %{private}.3lf, beyond maximum acceptable latitude, %{private}d
#Warning,DEM,avl byte index,%{public}d,is larger than the data available in the availabilty file,fNeedToDownloadAvlFile,%{public}d
#Warning,DEM,Invalid CLDEM availability file - unable to get data byte,fNeedToDownloadAvlFile,%{public}d
DEM,Unexpected case,fNeedToDownloadAvlFile,%{public}d
DEM,isTileAvailable,%{public}d,fNeedToDownloadAvlFile,%{public}d
DEM,fNeedToDownloadAvlFile,%{public}d
#Warning,DEM,availability file does not exist,fNeedToDownloadAvlFile,%{public}d
#Warning,DEM,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d
DEM,availability file version does not match expected,fNeedToDownloadAvlFile,%{public}d
DEM,availability file has expired,fNeedToDownloadAvlFile,%{public}d
DEM,end of checkAvlFileValidityAndSetDownloadFlag function reached,fNeedToDownloadAvlFile,%{public}d
DEM,fseek returned non-zero
#Warning,DEM,Invalid CLDEM availability file - header string
#Warning,DEM,Invalid CLDEM availability file - invalid header string
#Warning,DEM,Invalid CLDEM availability file - version
#Warning,DEM,Invalid CLDEM availability file - headerLength
#Warning,DEM,Invalid CLDEM availability file - minLat
#Warning,DEM,Invalid CLDEM availability file - maxLat
#Warning,DEM,Invalid CLDEM availability file - binsize
#Warning,DEM,coarse avl file is not 0.1 deg by 0.1 deg,spacing unexpected,%{public}.1f,re-download needed
#Warning,DEM,Invalid CLDEM availability file - timestamp
#Warning,DEM,Invalid CLDEM availability file - expiration age
#Warning,DEM,Invalid CLDEM availability file - data size
#Warning,DEM,Invalid CLDEM availability file - crc
CLMM, DisableMapMatchingRouteHints, %{public}d
CLMM,RouteHints,addObserver,%s,size,%lu
CLMM,RouteHints,removeObserver,%s,size,%lu
CLMM,RouteHints,updateMapRouteHint,%{public}d,routingType,%{public}d,stepType,%{public}d
Unknown notification during unregistration: %{public}d
{"msg%{public}.0s":"Motion Sensor Logging", "Always On":%{public}hhd}
{"msg%{public}.0s":"#usesync suspending silo until IDS becomes available"}
{"msg%{public}.0s":"#usesync waiting on IDS to become available"}
{"msg%{public}.0s":"#usesync IDS service failed to initialize", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#usesync IDS became available so resuming silo"}
{"msg%{public}.0s":"#usesync UUIDs found", "on disk":%{public, location:escape_only}s, "current":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Serial", "serial":%{private, location:escape_only}s}
{"msg%{public}.0s":"#usesync Non-active device unpaired", "current id":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Unpair", "current id":%{public, location:escape_only}s, "active id":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Pairing", "new id":%{public, location:escape_only}s, "old id":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Attempted to send when unpaired"}
{"msg%{public}.0s":"#usesync Setting 5 minute error retry timer"}
{"msg%{public}.0s":"#usesync Adding a message to the error queue", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Draining the error queue", "count":%{public}lu}
{"msg%{public}.0s":"#usesync Error queue drained"}
{"msg%{public}.0s":"#usesync Message was replaced"}
{"msg%{public}.0s":"#usesync Message timed out.  Retrying"}
{"msg%{public}.0s":"#usesync #warning Got error from IDS, attempting to recover", "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#usesync Unrecognized type message failed to send.  Cannot recover.", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Dropping a message because we aren't paired", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Didn't get an identifier for message", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Not performing full sync due to being unpaired"}
{"msg%{public}.0s":"#usesync Full resync requested"}
{"msg%{public}.0s":"#didChangeUsageData dropping companion usage data change"}
{"msg%{public}.0s":"#usesync Got empty usage dictionary", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Not performing sync due to being unpaired"}
{"msg%{public}.0s":"#usesync Enqueued usage update message", "client":%{public, location:escape_only}s, "usage":%{public, location:escape_only}@}
{"msg%{public}.0s":"#onStatusBarIconChange on watch, dropping iconState change"}
{"msg%{public}.0s":"#onStatusBarIconChange dropping iconState change, coalescing updates"}
{"msg%{public}.0s":"#onStatusBarIconChangeInternal dropping duplicate iconState", "iconState":%{public}d}
{"msg%{public}.0s":"#onStatusBarIconChangeInternal processing iconState", "iconState":%{private}d}
{"msg%{public}.0s":"#onStatusBarIconChangeInternal lacks start key", "clientServiceType":%{public}lu}
{"msg%{public}.0s":"#usesync Dropping full sync due to being unpaired"}
{"msg%{public}.0s":"#usesync Enqueued all usage data"}
{"msg%{public}.0s":"#usesync Unknown message failed", "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#usesync Message from past life failed", "identifier":%{public, location:escape_only}s, "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#usesync Message sent", "identifier":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Got usage update"}
{"msg%{public}.0s":"#usesync Didn't get an expected parameter", "client key":%{public}hhd, "usage data":%{public}hhd}
{"msg%{public}.0s":"#usesync Got request for full resync of data"}
{"msg%{public}.0s":"#usesync Got full resync data"}
{"msg%{public}.0s":"#usesync Sync to/from standalone watch is not supported"}
{"msg%{public}.0s":"#usesync #warning Failure", "identifier":%{public, location:escape_only}s, "succeeded":%{public}hhd, "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#usesync sent", "identifier":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Got invalid message from IDS", "message":%{public, location:escape_only}@}
{"msg%{public}.0s":"#usesync #warning received legacy kCLUsageSyncMessagePromptKey message, ignoring", "payload":%{private, location:escape_only}@}
{"msg%{public}.0s":"#usesync Unrecognized message", "type":%{public, location:escape_only}s, "payload":%{private, location:escape_only}@}
{"msg%{public}.0s":"#usesync Paired device nearby change", "is nearby":%{public}hhd}
SkiData subscription changed, %s, %p, %d
#Warning Failed to subscribe to ski updates.
Query: id, %llu, session, %s, source, %s, count: %lu
CL: CLSkiDataSubscription::onSkiNotification
{"msg%{public}.0s":"CLSkiDataSubscription::onSkiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Lat/lon is out of range for conversion.
Input to Douglas-Peucker algorithm must have at least one vertex.
DynamicProgramArea distance is not implemented
#Warning Never achieved the desired simplification. Using the original curve.
Programming error. Number of points in backtrack do not match expected (1).
Programming error. Number of points in backtrack do not match expected (2): %{public}d, %{public}d
Loaded previous time zone %s
Setting start timer to fire after %.2fs
Setting active mode timer to fire at %.2f (%.2fs away)
Setting continuous location timer to fire after %.2fs
ReachabilityTimer fired
Continuous location timer fired
#Warning Failed to get any fix while in continuous location mode
Location services are disabled; stopping automatic time zone
Time Zone system service disabled; stopping automatic time zone
Automatic time zone starting in passive mode
Automatic time zone starting in active mode
Automatic time zone disabled
Starting automatic time zone in active mode
Already have previous border distance and timestamp
Entering active location mode
Exiting active location mode
Starting automatic time zone in passive mode
#Notice Stopping automatic time zone
We ran point-in-polygon on a location we threw out anyway!
Current time zone %s not in database; changing time because of acceptable location accuracy %.3f
#Warning Distance from previous time zone's border is %.3f; accuracy of position is %.3f
Telling timed the time zone is "%s".
#Warning bystander location, used to set time zone, billed to 'TimeZone' system service
#Notice Potentially setting system time zone to %s based on <%{private}+.8lf,%{private}+.8lf> acc %.2f timestamp %.2f confidence %d
#Notice Potentially setting system time zone to %{public}s
Potentially setting system time zone to %s based on <%{private}+.8lf,%{private}+.8lf> acc %.2f timestamp %.2f confidence %d
#Warning Received invalid location for time zone
#Warning Disregarding location with accuracy: %.1f (> %.1f)
Received invalid location <%{private}+.8f,%{private}+.8f> for time zone
#Warning Disregarding location for timezone with speed: %.1f (> %.1f)
#Notice Handling new location <%{private}+.8lf,%{private}+.8lf>, acc %.2f, timestamp %.2f, lifespan %.2f, confidence %d
Distance travelled from last point is %.3lf; previous point's distance from border was %.3lf
We've travelled outside our "fence".
#Warning Couldn't get time zone for location <%{private}+.8lf,%{private}+.8lf>
Time zone from database was %s
We're still inside our last "fence".
we've previously confirmed our timezone
Distance travelled from last unconfirmed point is %.3lf; previous point's distance from border was %.3lf; acc is %.3lf
time zone confirmed (horizontalAccuracy has improved faster than we've moved)
#Warning we can't possibly confirm our timezone, uncertainty too large
we can't optimize, find out if this position confirms our location
#Warning Not using <%{private}+.8lf,%{private}+.8lf> (timestamp %.2f) because interval has not elapsed
Unconfirmed border distance is <= 0 yet we have an unconfirmed timezone label.
Got data mode change notification; entering continuous location mode
Got data mode change notification, but haven't exceeded reachability interval(%.3f s).  Will try again in %.3f s
Got airplane entered notification
Got airplane mode exited notification; entering continuous location mode
Got new time zone location: %d
#Warning Ignoring expired location <%{private}+.8f, %{private}.8f>, acc %.2f, timestamp %.2f, lifespan %.2f
#Warning Ignoring unsure location <%{private}+.8f, %{private}.8f>, acc %.2f, timestamp %.2f, lifespan %.2f, confidence %d
#Warning Ignoring inaccurate location <%{private}+.8f, %{private}.8f>, acc %.2f
#Warning Ignoring borderline location <%{private}+.8f, %{private}.8f>, acc %.2f
Got kNotificationLocationUnavailable
Got kNotificationServiceAuthorization
#Warning Got unknown notification %d
#Warning received unknown notification %s from telephony service
Automatic time is now in mode %d
#Warning location status reset; removing all clients
Got immediate check notification
Transition from continuous active to continuous active with retry
Already in continuous location mode; not re-entering
Location services are disabled; not starting continuous location
Time Zone system service disabled; not starting continuous location
In bystander-only mode; not starting continuous location
Entering continuous location mode
Timezone is not confirmed.
Not in continuous location mode; not exiting
Exiting continuous location mode
Not registered for location or fine location; ignoring location failure
Got location unavailable while in continuous location mode; ignoring location failure
#Warning Location failed for time zone (exiting continuous mode %d; failure count now %d)
Maximum failure count not exceeded; retrying in %.2f seconds
Exceeded maximum failures; not retrying for %.2f seconds
CL: CLTimeZoneManager::onSettingsNotification
{"msg%{public}.0s":"CLTimeZoneManager::onSettingsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTimeZoneManager::onLocationNotification
{"msg%{public}.0s":"CLTimeZoneManager::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTimeZoneManager::onStatusNotification
{"msg%{public}.0s":"CLTimeZoneManager::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTimeZoneManager::onManagerNotification
{"msg%{public}.0s":"CLTimeZoneManager::onManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTimeZoneManager::onActiveModeTimer
{"msg%{public}.0s":"CLTimeZoneManager::onActiveModeTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTimeZoneManager::onImmediateCheckNotification
{"msg%{public}.0s":"CLTimeZoneManager::onImmediateCheckNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTimeZoneManager::onLocationTimeZoneActiveNotification
{"msg%{public}.0s":"CLTimeZoneManager::onLocationTimeZoneActiveNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Overriding fence start delay to %{private}.2f
setting FenceStartShowDialog to %{private}d
Fence: Start after unclean shutdown
Fence: Starting fence monitoring
Fence: Already started fence monitoring
Fence: CLFenceManager, shutdown
Fence: resetFenceMonitoring_nl
Fence: startMonitoringAllFences_nl
Starting to monitor all %{public}ld authorized fences
Fence: startMonitoringFences_nl
Fence: stopMonitoringFences_nl
Fence: erasing dormant bucket %{private}s
Fence: Number of buckets,%{public}lu,%{public}lu
Fence:Add sending kNotificationFenceSetupCompleted - existed, fence, %{private}s
#Warning monitoring for identical pre-existing fence hasn't started yet
Fence: fence not added, too many fences, %{private}s, %{private}lu, %{private}u
Fence: monitoring is not supported on this platform; not adding fence %{private}s/%{private}s
Not adding fence %{private}s/%{private}s because coordinate is invalid
canPerformMonitoringForFence is true, fence, %{private}s
canPerformMonitoringForFence is false, fence, %{private}s
Adding fence %{private}s
Fence:Fail sending kNotificationFenceFailure, fence, %{private}s
Fence:Add sending kNotificationFenceSetupCompleted, fence, %{private}s
Fence:Remove fence %{public}s/%{private}s
{"msg%{public}.0s":"Found the bundleID but it contained no fences with fenceID", "fenceID":%{public, location:escape_only}s}
{"msg%{public}.0s":"You're not authorized for fence.", "bundleID":%{public, location:escape_only}s, "fenceId":%{public, location:escape_only}s}
Fence: requestRegionState, %{private}s/%{private}s, registered, %{public}d, authorized, %{public}d
Fence: requestRegionState, fence, %{private}s/%{private}s, status, %{private}d, %{private}s
Fence: requestRegionState, fence, %{private}s/%{private}s, not authorized
Fence: requestRegionState, fence, %{private}s/%{private}s, not registered
Fence: requestRegionState, fence, %{private}s/%{private}s, error.
#FenceHandoff fence manager doing requestAllHandoffTags
Fence:Status fence, %{private}s, status, %{private}s, isIssueNotification, %{public}d, fenceAge, %{public}.1lf, StopTime, %{private}.1lf, StartTime, %{private}.1lf
Fence: fence, %{private}s, new status, %{private}s, bundleId, %{private}s, not authorized, avoiding notification
pending, transition, %{private}s, fence, %{private}s, timestamp, %{private}.1lf
pending, state, %{private}s, fence, %{private}s, timestamp, %{private}.1lf
#Warning Fence: avoid notifyFenceEntryExitForAuthorizedFence, fence, %s, status, %s, searchStatus, %s, client, %d, timestamp,%.1lf
notifyFenceEntryExitForAuthorizedFence,fence,%{private}s,fenceStatus,%{private}s,searchStatus %{private}s,client,%{public}d
#Warning Fence: avoid sendFenceStatusNotification, fence, %{private}s, status, %{private}s, searchStatus, %{private}s, client, %{public}d, timestamp,%{public}.1lf
sendFenceStatusNotification,fence,%{private}s,fenceStatus,%{private}s,searchStatus %{private}s,client,%{public}d
{"msg%{public}.0s":"Attempting to send fence transition, but state unknown", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: Sending %{private}s notification for [%{public}s]/%{private}s/%{private}s to client %{public}d%{private}s, sinceLast,%{private}.1f, type,%{private}d,%{private}d,%{private}d,%{private}d,%{private}d, motion,%{private}d,%{private}d,%{private}d,%{private}d
Fence: Sending state notification (requested: %{private}d) for [%{public}s]/%{private}s/%{private}s to client %{public}d%{private}s
#Warning Invalid fence status, %d
{"msg%{public}.0s":"Transtion, but prev state unknown", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: Got data downloaded notification for [%{public}s]/%{public}s/%{private}s
#Warning Fence: Got data download failure notification for [%{public}s]/%{private}s/%{private}s
Fence: Got data download invalidated notification
Fence: Got kNotificationLocationServicesStatus, enabled, %{public}d, StopTime, %{public}.1lf, StartTime, %{public}.1lf
#Warning Got unknown client notification %{public}d
Fence: Got fence addition notification for %{public}ld fences
Fence [%{public}s]/%{public}s/%{private}s is authorized
{"msg%{public}.0s":"onAuthorizationNotification fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning throttle fine fence usage by client [%{public}s]/%{public}s, %{private}s
Fence [%{public}s]/%{public}s/%{private}s is not authorized
Fence: Got fence removal notification for %{public}ld fences
Fence: Got fence reset notification
Received motion state,static,%{private}d,walking,%{private}d,driving,%{private}d,inVehicle,%{private}d
Unhandled notification %{public}d
CL: CLFenceManager::onClientNotification
{"msg%{public}.0s":"CLFenceManager::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceManager::onMonitorNotification
{"msg%{public}.0s":"CLFenceManager::onMonitorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceManager::onStartTimer
{"msg%{public}.0s":"CLFenceManager::onStartTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceManager::onDaemonStatusNotification
{"msg%{public}.0s":"CLFenceManager::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceManager::onMotionStateNotification
{"msg%{public}.0s":"CLFenceManager::onMotionStateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceManager::onDataDownloadNotification
{"msg%{public}.0s":"CLFenceManager::onDataDownloadNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceManager::onAuthorizationNotification
{"msg%{public}.0s":"CLFenceManager::onAuthorizationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Motion alarm fire subscription changed, %s, %p, %d
Unable to find bundle identifier!
{"msg%{public}.0s":"Couldn't get value for kCLConnectionMessageSubscribeKey key"}
MotionState,Motion,From,%d,To,%d,conf,%d,Mounted,From,%d,To,%d,conf,%d,tilt,%.1f,exitC,%d,exitTime,%f,startTime,%f,timestamp,%f,standing,%d,rawMotionType,%d,rawConfidence,%d,motionHint,%d,bbHint,%d,wifiHint,%d,btHint,%d,gpsHint,%d,drivingStowedLikelihoodSum,%f,drivingArmLikelihoodSum,%f,ssLikelihoodSum,%f,tag,workoutDetectionType,%d,workoutDetectionTime,%f,workoutEscalationTime,%lld, YouthMotionState, %d, %s
MotionSyncSendCalsFireIntervalInSeconds set to %f seconds.
Timer fired.
unlocked
Watch retrieved calibrations and saved them in memory, current version, %d
%s, current version, %d, timestamp, %lf
Watch did not persist Motion Cals, waiting until unlock, current version, %d, isDeviceCurrentlyUnlocked, %d
Begin persisting calibrations to disk on watch, current version, %d.
Persisted a reset Motion Cals
Finished setting user profile on watch = %s
Persisted raw speed to kValue bins
Persisted step cadence to stride length bins
Completed persistence of motion cals to disk on watch. %s
Watch received motion calibrations from companion, %s, version, %d, timestamp, %lf, udid, %s
user info notification
Workout session ended on watch.
#Warning Unhandled notification %d
notification, %d
Unhandled notification
raw speed to kValue bins updated
step cadence to stride length bins updated
restore backup motion cals
connected
updating motion cals
restore and arbitrate
Buffered motion cals from companion
disconnected
arbitrateMotionCals
Restored backup calibrations, %s, version, %d, timestamp, %lf
No buffered Motion Cals, no arbitration
Ignoring update.  Phone Motion Cals UDID %s is different from current UDID %s, but version %d is not larger than current version %d
Buffered Motion Cals, version, %d, timestamp, %lf, udid, %s, Current Motion Cals, version, %d, timestamp, %lf, udid, %s, result, %d
schedule send to companion
CL: CLMotionSyncStoreWatch::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLMotionSyncStoreWatch::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionSyncStoreWatch::onUserInfoNotification
{"msg%{public}.0s":"CLMotionSyncStoreWatch::onUserInfoNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionSyncStoreWatch::onCompanionNotification
{"msg%{public}.0s":"CLMotionSyncStoreWatch::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Fence: distance = %.2f; compare = %.2f
Fence: LAC monitoring is %ssufficient for %s/%s
distance = %.2f; compare = %.2f
Fence: no allowing wifi monitor for, %.1lf, fence, %s
Cell monitoring is %ssufficient for %s/%s
@WsbCalc, groups, %{public}lu, %{public}s
{"msg%{public}.0s":"Input expected to contain all APs with valid locations", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
@WsbLoc, fix, aps, %{public}d, %{public}lu, reproc, %{public}d, time, %{public}.1f, ll, %{private}.7f, %{private}.7f, hAcc, %{public}.1f
WsbMetric, fix, aps, %{public}d, age, %{public}0.1f, %{public}s
@WsbLoc, none, aps, %{public}lu, reproc, %{public}d, time, %{public}.3f
WsbCalc, computed, %{public}d, of, %{public}lu, %{public}s
WsbMetric, groupresult, %{public}s, %{public}d
@WifiAps, compute, %{public}lu, used, %{public}u, used_vert, %{public}u, hint, %{public}d
WifiCalc, zaxis, isWsb, %{public}d
WifiCalc, zaxis input kalmanFilter, initialized, %{public}s, relative altitude, %{private}.6f, wifiAltUncAve, %{private}.6f, alt_k_k, %{private}.6f, alt_k1_k, %{private}.6f, cov_k_k, %{private}.6f, cov_k1_k, %{private}.6f, process noise variance, stable, %{private}.6f, unstable, %{private}.6f, measurement variance, %{private}.6f, timestamp, propagate, %{private}.3lf, update, %{private}.3lf, relative altitude timestamp, %{private}.3lf, wifi time interval, %{private}.6f, relative altitude time interval, %{private}.6f, altitude change during baro outage, %{private}.6f
WifiCalc, zaxis input elevation, size, %{public}d, relative altitude, %{private}.6f, timestamp, %{public}.3lf, elevation steady, %{public}s
WifiCalc, zaxis input elevation empty, stop filter
WifiCalc, zaxis, reported invalid alt, %{private}.2f, unc, %{private}.2f
WlpMetric, fixaps, %{public}d, trigger, %{public}s, used, %{public}d, out, %{public}d, pct, %{public}d
@WifiFlow, compute, %{public}u, hacc, %{public}.1f, vaps, %{public}u, vacc, %{public}.1f, conf, %{public}d, reason, %{public}s
WlpMetric, fixerror, %{public}.1f, agetype, %{public}s, dt, %{public}.1f, %{public}d, ratio, %{public}.1f
WlpMetric, fixerror, %{public}s
@WifiFlow, sufficiency, %{public}d, %{public}s
WifiCalc, input AP, %{public}d, %{private}s, %{private}.7f, %{private}.7f, hacc, %{public}.6f, reach, %{public}d, altitude, %{private}.2f, vacc, %{public}.2f, rssi, %{public}d, channel, %{public}d, scan timestamp, %{public}.3lf, query timestamp, %{public}.3lf, %{private}s
Fence: No access to DB
Fence: addFence, %{private}s, key, %{public}d
Fence: attempting to add fence to db without a key
#Warning Fence: Couldn't bind statement for adding fence (bundle ID %{public}s, name %{private}s, deviceId %{public}s)
{"msg%{public}.0s":"Fence: Unable to update FenceHandoff table", "bundleId":%{public, location:escape_only}s, "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"Fence: Read Index for fence", "index":%{public}d, "bundleId":%{public, location:escape_only}s, "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"Fence: Unable to read fence index", "bundleId":%{public, location:escape_only}s, "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"Fence: Unable to insert in FenceHandoff table", "FenceIndex":%{public}d, "status":%{public}d}
{"msg%{public}.0s":"Fence: Remove Fence", "primaryKey":%{public}d}
{"msg%{public}.0s":"#Warning Fence: Invalid primaryKey", "primaryKey":%{public}d}
{"msg%{public}.0s":"#Warning Fence: unable to bind primaryKey"}
Fence: Removing fence %{public}s/%{private}s
#Warning Fence: Couldn't bind statement for deleting fence (bundle ID %{public}s, name %{private}s)
Fence: No vertices removed for key %{public}d
#Warning Fence: Couldn't bind statement for deleting fences for bundle ID %{public}s
Fence: Couldn't get fences from database
Fence: fetched fence, %{private}s
{"msg%{public}.0s":"Fence: db fenceKey not set", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: Error in retrieving fences from database
Fence: Couldn't bind fence [%{public}s]/%{public}s/%{public}s
fetched fence, %{private}s
Fence: Fence doesn't exist [%{public}s]/%{public}s/%{private}s
Fence: Error in retrieving fence key from database for [%{public}s/%{public}s/%{private}s
Fence: Couldn't bind bundle ID %{public}s
fetched bundle fence, %{private}s
Fence: Error in retrieving fences from database for bundle ID %{public}s
fetched bundle or onbehalf fence, %{private}s
Fence: Error in retrieving fences from database for bundle or onbehalf ID %{public}s
{"msg%{public}.0s":"Found valid index for Fence", "index":%{public}d, "fence":%{private, location:escape_only}s}
#Warning Fence: Couldn't get number of fences for bundle ID %{public}s
{"msg%{public}.0s":"Fence: #FenceHandoff fence exists in main Fence table", "fenceIndex":%{public}d}
{"msg%{public}.0s":"Fence: #FenceHandoff unable to delete FenceHandoff Table", "fenceIndex":%{public}d}
{"msg%{public}.0s":"Fence: Unable to update FenceHandoff table", "fenceKey":%{public}d}
{"msg%{public}.0s":"#Warning Fence: Couldn't check if Fence exists", "fenceIndex":%{public}d}
{"msg%{public}.0s":"Fence: #FenceHandoff all Fences were handed off to companion"}
{"msg%{public}.0s":"Fence: #FenceHandoff unable to get Fences"}
{"msg%{public}.0s":"Fence: #FenceHandoff prepareToHandoff Unable to bind monitorFlags or index"}
{"msg%{public}.0s":"Fence: #FenceHandoff unable to get fences pending handoff"}
{"msg%{public}.0s":"Fence: #FenceHandoff No fences are pending delete"}
{"msg%{public}.0s":"Fence: #FenceHandoff Unable to get fences pending delete"}
{"msg%{public}.0s":"Fence: #FenceHandoff Pending delete", "FenceKey":%{public}d}
{"msg%{public}.0s":"Fence: #FenceHandoff unable to update status to HandoffCompleted", "fenceIndex":%{public}d}
Fence: resetHandoffStatus unable to bind
Fence: Recording [%{public}s]/%{public}s/%{private}s last download time change to %{public}.2f
#Warning Fence: Couldn't update last download time for %{public}s/%{private}s in database
Fence: Marking all fence data download times as invalid
Fence: invalidate download date for, %{public}s
Fence: failed to bind bundleId, %{public}s
Fence: Couldn't get bundle IDs from database
Fence: Error in retrieving bundle IDs from database
{"msg%{public}.0s":"Fence: #migration column exists", "table":%{public, location:escape_only}s, "column":%{public, location:escape_only}s}
{"msg%{public}.0s":"Fence: #migration column doesn't exists", "table":%{public, location:escape_only}s, "column":%{public, location:escape_only}s}
Fence: #FenceHandoff Unable to initDeviceIdTable
Fence: Setting fence keys values for existing fences
{"msg%{public}.0s":"Fence: Unable to read/insert Fences for migration"}
{"msg%{public}.0s":"Fence: #migration contains FenceForeignKey"}
Fence: Unable to bind default handoff tag
Fence: Unable to bind default enablement status
Fence: Unable to bind default deviceId index
@TileData, CLWifiTileBlobsTable, not connected to wifi #tile header table
@TileData, saveWifiTileBlobData, not connected to wifi #tile blobs table
{"msg%{public}.0s":"@TileData, wifi, failed to bind values for #tile save blob data", "x":%{private}d, "y":%{private}d}
{"msg%{public}.0s":"@TileData, wifi, failed to dump #tile to blob", "row":%{public}d, "tileX":%{private}d, "tileY":%{private}d}
@TileData, selectBlobDataByTileXY, not connected to wifi #tile data table
@TileData, deleteBlobDataByTileXY, not connected to wifi #tile blob data table
{"msg%{public}.0s":"@TileData, wifi, failed to bind values for deleting #tile", "x":%{private}d, "y":%{private}d}
{"msg%{public}.0s":"@TileData, wifi, failed to bind values for #tile to find mac address", "x":%{private}d, "y":%{private}d}
Failed to read wifi tile successfully
{"msg%{public}.0s":"expecting 1 to 1", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"@TileData, wifi, failed to serialize #tile", "x":%{private}d, "y":%{private}d}
{"msg%{public}.0s":"@TileData, wifi, failed to find relevant row for #tile", "x":%{private}d, "y":%{private}d}
{"msg%{public}.0s":"@TileData, wifi, something went wrong trying to dump the #tile data"}
{"msg%{public}.0s":"@TileData, wifi, failed to write #blob data to #tile #database", "code":%{public}d}
{"msg%{public}.0s":"@TileData, wifi, failed to read #blob data from #tile #database", "code":%{public}d}
{"msg%{public}.0s":"@TileData, wifi, failed to incrementally read contents of blob from #tile header"}
GYTT data not long enough to get version properly
Invalid version parameter.
Service doesn't exist
No optional GYTT data found
Cannot get GYTT property
GYTT data %@
Invalid GYTT parameter data.
Failed to read GYTT.
GYTT version (%{public}u) does not match expected version (%{public}u)
Attempting GYTT recovery!
After recovery, GYTT version (%{public}u) still does not match expected version (%{public}u)
Invalid GYTT temperature %{public}f
Reading GYTT point %zu: %f,%f,%f,%f
Skipping GYTT point %zu: %f,%f,%f,%f
%zu GYTT points found
Started Tier2 smoother.
Stopped Tier2 smoother.
Tier2Smoothed,%d,Confidence,%d
n,%lu,baseline,%f,counter,%f,t,%f,exertion,%f,baseThreshold,%f,lowExertionThreshold,%f,accelVectorMagnitude,%f,HRStop
HRModel,stopping workout,baseline,%{private}f,restingHeartRate,%{private}f
TransitMac: service begin
TransitMac: service end
TransitMac: spoofing a query
TransitMac: result, %lu
TransitMac, result, mac, %s
Stroke detected,timestamp,%.3f,count,%lu,startTime,%f,isSwim,%d,style,%d
Turn detected,timestamp,%f,startTime,%f,isSwimming,%d
[SwimOdom] Received an odometer update,distance,%lf,accuracy,%lf,speed,%lf,rawspeed,%lf,odometer,%lf,gpsSpeedAccuracy,%lf,timestampGps,%lf
New lap entry, identifier, %llu, uuid, %s, sourceId, %s, startTime, %f, endTime, %f, timestamp, %f, pace, %f, distance, %f, paceSource, %d, style, %d, numberOfStrokes, %d, totalLaps, %d, inserted, %d, segment, %d
New lap entry, failed to get and log new lap entry after adding to db.
style,%d,currentTimestamp,%f,turnTimestamp,%f,turnStartTime,%f,mean,%f,stddev,%f,min,%f,max,%f,median,%f,samples,%d,prctile10,%f,prctile90,%f
{"msg%{public}.0s":"Starting swim session", "location":%{public}ld, "pool length":"%{public}f"}
{"msg%{public}.0s":"Re-initializing swim session", "location":%{public}ld, "pool length":"%{public}f"}
{"msg%{public}.0s":"Updating swim session", "location":%{public}ld, "pool length":"%{public}f"}
Deleting boundary from db: id=%{public}d
MobilityWalkingBoutHistory not accessible
Wrote boundary to db: id=%{public}d, startTime=%{public}.2f
Inserted boundary (startTime=%{public}f) is not the latest boundary (startTime=%{public}f)
MobilityWalkingBoutHistory Encountered an error getting earliest record
MobilityWalkingBoutHistory Encountered an error getting latest record
SessionMetrics,Start
SessionMetrics,End,Summary,DistanceFusionSuccess,%0.6f,DistanceFusionOther,%0.6f,DistanceFusionGPS,%0.6f,DistanceFusionPedometer,%0.6f,DistanceFusionGradient,%0.6f,DistanceFusionGain,%0.6f,DistanceFusionSpeed,%0.6f,DistanceFusionLength,%0.6f,startTime,%0.6f,endTime,%0.6f
SessionMetrics,%s,%s,%s,DistanceFusion,%0.4f
Trying to send track with startTime %f. a %u b %u a == b %d
Trying to send track with startTime %f. now %f 2 %f 1 %f
Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMQueue.h, line 244,i,%zu,capacity,%u.
os_transaction released: (%p) %@
interval, %s, %.5lf, flooring to 1.0, interval
setTimerWithInterval, %s, interval, DBL_MAX
setTimerWithInterval, %s, interval, %.1lf
timerFired: timer, _clTimer, %s, %p, %p
Scheduling invalidation, %s, %p
invalidate, %s, %p
setNextFireDate, %s, %.1lf
timerFired, fIdentifier, %s, f, %p
Invalidate, %s
StationaryLocationHarvest enabled
ignore vehicular speed
HARVEST: starting gps harvesting.
HARVEST: stopping gps harvesting.
invalid/stale location (age %.3fs) - ignoring
not harvesting yet; GPS warming count is %d < %d
%d consecutive clamps at <%+.8f,%+.8f> - not harvesting
getting GPS notifications
{"msg%{public}.0s":"vehicular speed achieved", "vehicularSpeedAchieved":%{private}hhd}
Location is spoofed, do not harvest
#Warning,invalid,type,%{public}d,lat,%{private}.7f,lon,%{private}.7f
Got GPS location simulation %s notification
{"msg%{public}.0s":"We have no WGS84, anywhere! Only Chinese Stark"}
{"msg%{public}.0s":"onGps", "location":%{private, location:CLDaemonLocation}.*P}
GPS dropped out for %.3fs while warming - resetting count (from %d)
location is clamped at <%+.8f,%+.8f> acc %.2f - count %d
on gps notification. Pos harvesting not eligible
#loiOverride received LOI location,lat,%{private}.7f,lon,%{private}.7f,hunc,%{public}.2f,timestamp,%{public}.3f,sourceAccuracy,%{public}d
#loiOverride LOI location is not valid anymore.
#loiOverride update WiFi association state,isWiFiAssociated,%{public}s,last association time,%{public}.3f,LOI location timestamp,%{public}.3f
#loiOverride using Loi Location
#loiOverride no valid current location.
#loiOverride location is not Wifi1 or Cell.
#loiOverride location source accuracy is not High to overide location.
#loiOverride the spread of the LOI is larger than the location fix.
#loiOverride locations are not sufficiently proximate.
#loiOverride WiFi is not associated to overide Wifi1 locations.
#loiOverride totalUncertainty,%{public}.8lf,distanceBetweenLocations,%{public}.8lf
#loiOverride LOI location is not sufficiently proximate, uncertainty bubbles don't touch.
#loiOverride LOI location is not sufficiently proximate, does not meet distance threshold.
#loiOverride LOI location is sufficiently proximate.
#loiOverride LOI location,%{private}.8lf,%{private}.8lf,HorAcc,%{public}.1lf,Type,%{public}s,Confidence,%{public}d,Timestamp,%{public}.3f,Lifespan,%{public}.3f,integrity,%{public}d,verticalAcc,%{public}.1lf,altitude,%{private}.1lf
#loiOverride filtered location,%{private}.8lf,%{private}.8lf,HorAcc,%{public}.1lf,Type,%{public}s,Confidence,%{public}d,Timestamp,%{public}.3f,Lifespan,%{public}.3f,integrity,%{public}d,verticalAcc,%{public}.1lf,altitude,%{private}.1lf
#loiOverride Fused location,%{private}.8lf,%{private}.8lf,HorAcc,%{public}.1lf,Type,%{public}s,Confidence,%{public}d,Timestamp,%{public}.3f,Lifespan,%{public}.3f,integrity,%{public}d,verticalAcc,%{public}.1lf,altitude,%{private}.1lf
CL: CLLoiLocationOverride::onLoiLocationNotification
{"msg%{public}.0s":"CLLoiLocationOverride::onLoiLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Error in calorie update, %s, %p
Calorie subscription changed, %d, %s, %p
Error querying calorie data, %{public}d
Calibration prompt, isConnectedToCompanion: %d, promptsNeeded: %ld.
Resetting calibration.
Getting user profile, %@, %s, %p
Setting user profile, %{private}@, %s, %p
#Warning Client failed entitlement check for calorimetry, %s, %p
WorkoutMets,query,empty request
Error querying workout mets, %{public}d
Workout Mets Query Result: %@
#Warning Client %s does not have appropriate entitlement to access user info spi
CL: CLNatalimetrySubscription::onNatalimetryUpdate
{"msg%{public}.0s":"CLNatalimetrySubscription::onNatalimetryUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Shutting down alarm notifier.
Invalid name.
Unable to create client bundle identifier.
Registering client: %{private}@.
Unregistering client: %{private}@.
Registering alarm for client: %{private}@, name: %{private}@.
Invalid alarm to add!
Alarm already exists for client, firing: %{private}@, name: %{private}@.
Updating alarm for client: %{private}@, name: %{private}@.
Failed to update or insert alarm for client: %{private}@ name: %{private}@.
Alarm construction failed!
Failed to remove alarm entry for id: %llu.
Construction of alarm failed for client: %{private}@ name: %{private}@.
Unregistering alarm for client: %{private}@, name: %{private}@.
Invalid alarm to remove!
Unable to find alarm to remove!
Failed to remove activity alarm entry for id: %llu.
Acknowledging alarm for client: %{private}@, name: %{private}@.
Invalid alarm to acknowledge!
Unable to find alarm entry to acknowledge!
Unable to acknowledge alarm in state: %@ for client: %{private}@ name: %{private}@, id: %llu.
Preconditions have been violated and we have a repeating activity alarm!
Setting alarm to %@ for client: %{private}@, id: %llu.
Removing all alarms for client: %{private}@.
Time alarm already exists for id: %llu.
Saving persistent alarm for client: %{private}@, id: %llu, duration: %u, repeats: %d, fire: %f.
Unable to find persistent alarm for id: %llu.
Removing persistent alarm for id: %llu.
Class A timer alarm already exists for id: %llu.
Removing Class A timer alarm for id: %llu.
Invalid trigger type!
Unable to create activity alarm key.
Activity alarm already exists for id: %llu.
Failed to create activity alarm for client: %{private}@, id: %llu.
Saving activity alarm for client: %{private}@, id: %llu, trigger: %d duration: %u.
Unable to find activity alarm for id: %llu.
Removing activity alarm for id: %llu.
Unable to access database after first unlock!
Restoring alarms: %lu.
Removing expired alarms: %lu.
Invalid alarm timer.
Invalid alarm identifier.
Activity alarm timer fired: %llu.
Activity alarm is pending acknowledgment. Not firing alarm.
Unexpected alarm identifier.
Persistent timer fired id: %llu.
Persistent timer is pending acknowledgment. Not firing alarm.
Invalid alarm activity.
Class A timer fired id: %llu.
Alarm state is rolling over for alarm: %llu.
Unable to find alarm for id: %llu.
Invalid fire state: %@.
Previous alarm state: %@, current state: %@.
Maximum launch attempts reached for: %{private}@.
Failed to update state for the alarm: %llu!
Will not fire due to invalid fire state, current state: %@.
Firing alarm on client: %@, current state: %@.
Unable to fire alarm on client, client is not registered: %@, current state: %@.
Re-firing alarm: %llu.
Application %{private}@ installed: %d.
Application %{private}@ sending remote app launch.
Launching application: %{private}@.
Unable to find watch application for companion: %{private}@.
Launching watch application: %{private}@ for companion: %{private}@.
Invalid alarm bundle identifier!
Device unlocked since boot: %{private}s.
CL: CLMotionAlarmNotifier::onAppMonitorNotification
{"msg%{public}.0s":"CLMotionAlarmNotifier::onAppMonitorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionAlarmNotifier::onDataProtectionManagerNotification
{"msg%{public}.0s":"CLMotionAlarmNotifier::onDataProtectionManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionAlarmNotifier::onCompanionNotification
{"msg%{public}.0s":"CLMotionAlarmNotifier::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionAlarmNotifier::onPersistentTimerFired
{"msg%{public}.0s":"CLMotionAlarmNotifier::onPersistentTimerFired", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Delete CLCdmaCellLocationDatabase
GET could not bind %d %d %d %d %d %d %d %d %d
SET could not bind %d %d %d %d %d %d %d %d %d
getCell SID %d NID %d
Bad index into kkDefenseMappingAgencyTenByTenGeoid.
#Warning Input latitude = %.9lf is out of possible range
longitude %.9lf is not valid.
latitude %.9lf is not valid.
data is available
data is NOT available
Encrypted:%d State:%d Health:%d
query encountered error,%{public}ld
#Warning No step count / workouts
workouts: %lu, Minutes:%f
%s steps:%f
%s Steps:%f, Hours:%d
%s count:%zu
%s Count:%zu
day:%s duration:%f
All queries finished succssfully
Unknown notification %d
Requested update interval cannot be == 0.0 and dispatcher cannot be NULL. Use interval < 0.0 for spectator.
CLMotionNotifier::addDispatcherPrivate UpdateInterval is zero!
CLMotionNotifier::addDispatcherPrivate Added dispatcher for notification:%d, Update Interval:%f(%.1fHz)
CLMotionNotifier::updateSamplePeriod UpdateInterval:%f
{"msg%{public}.0s":"#authsync suspending silo until IDS becomes available"}
{"msg%{public}.0s":"#authsync waiting on IDS to become available"}
{"msg%{public}.0s":"#authsync IDS service failed to initialize", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync IDS became available so resuming silo"}
{"msg%{public}.0s":"#authsync Resuming SYService failed", "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync SYService resumed"}
{"msg%{public}.0s":"#authsync Setting sync state store path", "storePath":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync Checking isWatchBuildVersionPriorTo when watchProductVersion is NRProductVersionNone"}
{"msg%{public}.0s":"#authsync Handling MigrationSync start"}
{"msg%{public}.0s":"#authsync Handling MigrationSync end"}
{"msg%{public}.0s":"#authsync Empty sync store state path"}
{"msg%{public}.0s":"#authsync Sync store state exists already", "syncStoreState":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Creating sync store state", "syncStoreState":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Directory creation failed", "syncStorePath":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync Creating sync state failed", "syncStorePath":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync Creating sync state", "syncStorePath":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync Empty SyncStoreState path"}
{"msg%{public}.0s":"#authsync SyncStoreState updated", "updateReason":%{public, location:escape_only}@, "newSyncState":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Writing SyncStoreState failed", "updateReason":%{public, location:escape_only}@, "syncStorePath":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync No sync store state on disk"}
{"msg%{public}.0s":"#authsync Sync store state updated from disk", "syncState":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Iterate through clients.plist and identify the client that has the key 'SyncedFirstAuthorizationDecisionOnGizmo'"}
{"msg%{public}.0s":"#authsync Watch has nothing to sync", "watchInitiatedDeltaSyncInProgress":%{public}hhd, "syncedToggleNotification":%{public}hhd}
{"msg%{public}.0s":"#authsync Devices connected", "gizmoDeltaSyncObjects":%{public, location:escape_only}@, "gizmoDeltaSyncObjectsWaitingForAck":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Watch is not paired"}
{"msg%{public}.0s":"#authsync Device info updated", "deviceUUID":%{public, location:escape_only}@, "buildVersion":%{public, location:escape_only}s, "deviceName":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync LS TOGGLE as a notification", "locationServicesAsNotification":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync translating corrective compenesation", "Client":%{public, location:escape_only}s, "CorrectiveCompensationMask":%{public}u, "AuthorizationMask":%{public}u}
{"msg%{public}.0s":"#authsync corrective compensation translation is off", "Client":%{public, location:escape_only}s, "CorrectiveCompensationMask":%{public}u, "AuthorizationMask":%{public}u}
{"msg%{public}.0s":"#authsync no valid corrective compensation mask", "Client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync Error in sending sync session", "sessionIdentifier":%{public, location:escape_only}@, "reason":%{public, location:escape_only}@, "isResetSync":%{public}hhd, "state":%{public, location:SYSessionState}lld, "wasCancelled":%{public}hhd, "targetIsInProximity":%{public}hhd, "sessionStalenessInterval":%{public}ld, "errorDomain":%{public, location:escape_only}@, "errorCode":%{public}ld, "errorDesc":%{public, location:escape_only}@, "retryCount":%{public}d}
{"msg%{public}.0s":"#authsync Error in receiving sync session", "sessionIdentifier":%{public, location:escape_only}@, "reason":%{public, location:escape_only}@, "isResetSync":%{public}hhd, "state":%{public, location:SYSessionState}lld, "wasCancelled":%{public}hhd, "targetIsInProximity":%{public}hhd, "sessionStalenessInterval":%{public}ld, "errorDomain":%{public, location:escape_only}@, "errorCode":%{public}ld, "errorDesc":%{public, location:escape_only}@, "retryCount":%{public}d}
{"msg%{public}.0s":"#authsync No devices in promixity. Not retrying."}
{"msg%{public}.0s":"#authsync Retrying sync session", "retryInterval":%{public}ld, "retryCount":%{public}d}
{"msg%{public}.0s":"#authsync Will retry another sync session", "retryInterval":%{public}ld, "retryCount":%{public}d}
{"msg%{public}.0s":"#Warning #authsync Retry limit reached"}
{"msg%{public}.0s":"#authsync Delivered", "deltaSyncMessage":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Simulator client identity translated ", "from":%{public, location:escape_only}@, "to":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Applying notification message", "notification":%{public, location:CLCompanionSyncAuthObject_CLCompanionSyncNotification}lld}
{"msg%{public}.0s":"#authsync Missing vector clock key", "key":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Missing vector clock value", "key":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Missing notificationValue", "key":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Unknown vector lock", "key":%{public, location:escape_only}@, "value":%{public}d}
{"msg%{public}.0s":"#authsync Unknown vector lock with no value", "key":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Missing kCLToggleNotificationOnCompanion on disk"}
{"msg%{public}.0s":"#authsync TOGGLE vector clock", "onDiskCompanion":%{public}d, "onWireCompanion":%{public}d, "onDiskGizmo":%{public}d, "onWireGizmo":%{public}d, "onDiskLS":%{public}hhd, "onWireLS":%{public}hhd}
{"msg%{public}.0s":"#authsync Resolving the conflict by turning off location services"}
{"msg%{public}.0s":"#authsync onDiskToggleVersionNumberOnCompanion > onWireToggleVersionNumberOnCompanion"}
{"msg%{public}.0s":"#authsync Resolving vector clock conflict"}
{"msg%{public}.0s":"#authsync Applying auth add message", "message":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Applying auth update message", "message":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Applying auth delete message", "message":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Removed duplicate from gizmoDeltaSyncObjects", "clientKey":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Unsupported notification", "notification":%{public}d}
{"msg%{public}.0s":"#authsync Watch is sending delete auth message to companion"}
{"msg%{public}.0s":"#authsync Requesting full sync", "syncReason":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Dropping the full sync request", "syncReason":%{public, location:escape_only}@, "denialReason":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Requesting a delta sync session", "syncReason":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Dropping the delta sync request", "syncReason":%{public, location:escape_only}@, "denialReason":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Forcing full auth sync due to version", "foundVersion":%{public}d, "requiredVersion":%{public}d}
{"msg%{public}.0s":"#authsync Device established peer-to-peer connection"}
{"msg%{public}.0s":"#authsync No nearby devices with peer-to-peer connection"}
{"msg%{public}.0s":"#authsync SYService suspended"}
{"msg%{public}.0s":"#authsync SYService device switch", "oldPairingID":%{public, location:escape_only}s, "newPairingID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#authsync New/migrated device"}
{"msg%{public}.0s":"#authsync Watch unpaired"}
{"msg%{public}.0s":"#authsync This watch has somehow managed to pair with multiple companions"}
{"msg%{public}.0s":"Watch cannot start a sending reset sync session", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#authsync Sending sync session started", "sessionIdentifier":%{public, location:escape_only}@, "reason":%{public, location:escape_only}@, "isResetSync":%{public}hhd, "state":%{public, location:SYSessionState}lld, "wasCancelled":%{public}hhd, "targetIsInProximity":%{public}hhd, "sessionStalenessInterval":%{public}ld}
{"msg%{public}.0s":"#authsync Receiving sync session started", "sessionIdentifier":%{public, location:escape_only}@, "reason":%{public, location:escape_only}@, "isResetSync":%{public}hhd, "state":%{public, location:SYSessionState}lld, "wasCancelled":%{public}hhd, "targetIsInProximity":%{public}hhd, "sessionStalenessInterval":%{public}ld}
{"msg%{public}.0s":"Watch cannot end a sending reset sync session", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#authsync Sync to/from standalone watch is not supported"}
{"msg%{public}.0s":"#authsync Session ended with failure", "syncSessionReason":%{public, location:escape_only}@, "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Session ended successfully", "syncSessionReason":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Warning #authsync Error in service", "error":%{public, location:escape_only}@, "context":%{public, location:escape_only}@}
{"msg%{public}.0s":"Watch cannot do a reset sync", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#authsync Sending delta sync session continues enqueuing", "sessionState":%{public, location:SYSessionState}lld}
{"msg%{public}.0s":"#authsync Sending delta sync session begins enqueuing", "sessionState":%{public, location:SYSessionState}lld}
{"msg%{public}.0s":"#authsync Message enqueued", "gizmoDeltaSyncObject":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Message enqueue failed", "syncSessionReason":%{public, location:escape_only}@}
{"msg%{public}.0s":"#authsync Sending delta sync session finishes enqueuing", "numberOfDeltaSyncMessages":%{public}lu}
{"msg%{public}.0s":"Companion is receiving a reset sync session from the watch", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#authsync Receiving sync session changes", "queued":%{public}hhd, "applied":%{public}hhd, "service":%{public, location:escape_only}@, "session":%{public, location:escape_only}@, "sessionIdentifier":%{public, location:escape_only}@, "reason":%{public, location:escape_only}@, "isSending":%{public}hhd, "isResetSync":%{public}hhd, "state":%{public, location:SYSessionState}lld, "wasCancelled":%{public}hhd, "targetIsInProximity":%{public}hhd}
{"msg%{public}.0s":"#authsync Queued sync session changes applied", "service":%{public, location:escape_only}@, "session":%{public, location:escape_only}@, "sessionIdentifier":%{public, location:escape_only}@, "reason":%{public, location:escape_only}@, "isSending":%{public}hhd, "isResetSync":%{public}hhd, "state":%{public, location:SYSessionState}lld, "wasCancelled":%{public}hhd, "targetIsInProximity":%{public}hhd}
{"msg%{public}.0s":"#authsync Updated the kCLVersionOfLastFullAuthSync to currentVersion", "kCLCurrentAuthSyncVersion":%{public}d}
{"msg%{public}.0s":"#authsync Sending sync session ended successfully", "sessionIdentifier":%{public, location:escape_only}@, "reason":%{public, location:escape_only}@, "isResetSync":%{public}hhd, "state":%{public, location:SYSessionState}lld, "wasCancelled":%{public}hhd, "targetIsInProximity":%{public}hhd, "sessionStalenessInterval":%{public}ld}
{"msg%{public}.0s":"#authsync Receiving sync session ended successfully", "sessionIdentifier":%{public, location:escape_only}@, "reason":%{public, location:escape_only}@, "isResetSync":%{public}hhd, "state":%{public, location:SYSessionState}lld, "wasCancelled":%{public}hhd, "targetIsInProximity":%{public}hhd, "sessionStalenessInterval":%{public}ld}
{"msg%{public}.0s":"#authsync RESET from companion and delta sync from gizmo collided"}
{"msg%{public}.0s":"#authsync Sessions collided", "P-identifier":%{public, location:escape_only}@, "P-SyncReason":%{public, location:escape_only}@, "R-Identifier":%{public, location:escape_only}@, "R-SyncReason":%{public, location:escape_only}@, "P-syncState":%{public, location:SYSessionState}lld, "R-syncState":%{public, location:SYSessionState}lld}
Database not accessible
Could not get parent thread parameters
Motion runloop ref still not set!
Could not get scheduling parameters for motion thread, error = %{public}d
could not create runloop source
_CFRunLoopSetPerCalloutAutoreleasepoolEnabled() returned a value of, %{private}d.
Ping timer fired, resetting watchdog
Motion thread deadlock watchdog after %d petting
Failed to create watchdog timer
Motion thread exiting
Location Push Registrar XPC invalidation handler
Location Push Registrar XPC interruption handler
Ellptical, Load Calibration Enabled status, %d, WR-HR switch margin, %f
Elliptical, Linear Regression, timestamp, %f, duration, %f, stepcount, %d, steprate, %f, resistance, %f, weight, %f, feature2, %f, mets, %f
Elliptical, DT Regression, timestamp, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, METS, %f
Elliptical, METs, timestamp, %f, hrMets, %f, wrMets, %f, calibrationValue, %f, calibrated wrMets, %f, HR-WR diff, %f, mets, %f, metsSource, %d, fMetsScaling, %f, loadCalStatus, %d
Unable to insert VO2Max Input record.
Unable to get entries for uuid %{public}s
Unable to purge records.
Completed delete of aged-out input records; duration: %{public}f
Unable to purge VO2MaxInputHistory records from sessions already synced to CloudKit.
Completed delete of synced input records; duration: %{public}f
Completed reduce free pages after VO2MaxInputHistory deletes; duration: %{public}f
Completed fetch of input record count; duration: %{public}f
Unable to purge VO2MaxInputHistory records from oldest sessions after exceeding max record count.
Completed fetch of input record count after delete after exceeding max record count; duration: %{public}f
Completed delete of VO2MaxInputHistory records from oldest sessions after exceeding max record count; duration: %{public}f
Index VO2MaxInputHistoryUuidIndex already exists; not re-creating
Unable to create index VO2MaxInputHistoryUuidIndex
Index VO2MaxInputHistoryUuidIndex created successfully
History not accessible
Non-existent query record, returning all records.
Error querying records.
VO2MaxInputHistory, DB not accessible
Unable to save fetched input data from CloudKit. Device is locked and we are unable to open the database
Unable to delete out-of-date VO2MaxInputHistory records
Unable to save synced VO2MaxSummaryInput records
Unable to update synced VO2MaxSessionAttributes record
Unable to insert synced VO2MaxSessionAttributes record
SensorRecorderCacheSizeBytes, %d
SensorRecorderType, %s
Detected incompatible sensor table, purging Sensor Recorder data
Device is locked and we are unable to open the database
{"msg%{public}.0s":"Deleting Sensor Table", "table":%{private, location:escape_only}s, "database":%{public, location:escape_only}s}
Unable to open legacy database; failed to drop obsolete tables
Flushing to memory. %zu, %zu
Unable to insert meta data.
Unable to insert data.
Unable to get last accel data id.
Unable to update meta records dataId.
Database is inaccessible
Invalid query, both data id and meta id are 0
Database upper and/or lower time bound query failed to bind.
Database upper and/or lower time bound query failed.
Data request failed because db is not accessible.
Non-empty, endTime in memory, %d, current time, %f, endTime, %f, first entry startTime, %f, 
Data requested is in memory.  Writing incremental data out to disk.
VO2Max,Clustering failed
AlgoName,AdaptiveOutdoorPedestrianModel,ts,%.9f,duration,%.9f,size,%lld,hr min.,%f,hr max.,%f,hrMean,%f,hrConfMean,%f,hrCadenceMean,%f,vo2Mean,%f,speedMean,%f,gradeMean,%f,hrVariance,%f,hrConfVariance,%f,vo2Variance,%f,speedVariance,%f,gradeVariance,%f,cadenceMean,%f,vo2MaxModelSource,%d
VO2Max,AdaptiveOutdoorPedestrianModel,ComputePriors,age,%{private}f,biologicalSex,%{private}u,height,%{private}f,weight,%{private}f,maxMets,%{private}f,efficiency,%{private}f,priorVO2Max,%{private}f,modelPriorCoefficient_a,%{private}f,modelPriorCoefficient_b,%{private}f
{"msg%{public}.0s":"VO2Max,AdaptiveOutdoorPedestrianModel,Invalid clustering results.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
AlgoName,AdaptiveOutdoorPedestrianModel,numHistoricalResiduals,%ld,median,%f
VO2Max,AdaptiveOutdoorPedestrianModel,Longitudinal Estimate,numClusters,%lu,numClustersContr,%u,numWorkoutsContr,%u,medianResidual,%f,hrMin,%f,hrMax,%f,meanResidual,%f,clusterResidualBoundsMax,%f
{"msg%{public}.0s":"VO2Max,AdaptiveOutdoorPedestrianModel,ComputeEfficiency", "fhr":"%{private}f", "mets":"%{private}f"}
{"msg%{public}.0s":"VO2Max,AdaptiveOutdoorPedestrianModel,ComputeEfficiency", "canCalculateEfficiency":%{private, location:escape_only}s, "efficiency":"%{private}f"}
VO2Max,AdaptiveOutdoorPedestrianModel,Longitudinal Estimate,ts,%.9f,size,%lld,hrMin,%f,hrMax,%f,hrMean,%f,vo2Mean,%f,hrConfidenceMean,%f,gradeMean,%f,oneMinusFHR,%f,residual,%f,failHistResidCheck,%d,confidence,%f,sessionType,%d
remove %{public}s/%{private}s from %{private}s, remaining fences, %{public}lu
Fence: kill combinedFence, %{private}s, remaining fences, %{public}lu
FenceCal: combine fine fence, distance, %{private}.1lf, %{private}s
FenceCal: combine large fences, distance, %{private}.1lf, %{private}s
FenceCal: combine non-fine non-large fence, distance, %{private}.1lf, %{private}s
FenceCal: creating a new combined fence for, %{private}s
FenceCal: adding to, %{private}s, isExit, %{private}d
FenceCal: No fences
#Warning Fence: why is this used?, %{private}s, %{private}lf
Fence: fence, %{private}s, became empty
{"msg%{public}.0s":"CombinedFence addFence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning %p Scan delay of %Lf secs is invalid. Setting to the minimum of %Lf secs
%p INITIAL isWifiPowered=%d
%p Start monitor for active scanning
%p Stop monitor for active scanning
%p TIMER TRIGGERED
%p WIFI EXECUTING IMMEDIATELY, now=%f nextRequestTime=%f
%p WIFI SCAN SCHEDULED FOR %f
NonInterruptingTimer, %s, totalTime, %.2f
NonInterruptingTimer, %s, persist
NonInterruptingTimer, %s, startTimer
NonInterruptingTimer, %s, stopTimer
ending metric session (MotionTrigger) for %{public}s
Sent ear gesture message (prototype %{private}s)
ignoring metric for phone pick-up
counting metric for non-phone pick-up
Received Gesture request,client,%{public}s,subscribe,%{public}d
Priority not set
Got gesture subscription request, priority = %{public}d, Client = %{public}s
#Warning CLDaemonClient got ear gesture callback after destruction... ignoring
starting metric session (MotionTrigger) for %{public}s
Got gesture unsubscription request, Client = %{public}s
CLCatherineNotifier is shutting down.
CatherineNotifier Added client for %d, count %d
CatherineNotifier Removed client for %d, count %d
ExerciseMinute, Failed to expire records.
ExerciseMinute, DB not accessible.
ExerciseMinute, DB UUID un-initialized
ExerciseMinute, Potential DB reset / roll back, returning all records to clients,mru.recordId,%d,record.recordId,%d
{"msg%{public}.0s":"ExerciseMinute, Un-initialized DB update finished handler.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
ExerciseMinute, Device is locked and we are unable to open the database
ExerciseMinute, Failed to delete records
ExerciseMinute, Failed to shift records
{"msg%{public}.0s":"[CLIoHidInterface] addDevice should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Adding new Device with usage pair {%{public}d, %{public}d}
{"msg%{public}.0s":"[CLIoHidInterface] initializeHidIfNecessary should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Could not create event system client. All bets are off
[CLIoHidInterface] Event system client initialized successfully
{"msg%{public}.0s":"[CLIoHidInterface] closeHid should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Hid interface closed
{"msg%{public}.0s":"[CLIoHidInterface] refreshDeviceServiceRefs should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Refreshing service refs
[CLIoHidInterface] Check service ref %{private}p with usage pair {%{public}d, %{public}d} as a potential match
{"msg%{public}.0s":"[CLIoHidInterface] invalidateDeviceServiceRefs should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Invalidating hid service refs
{"msg%{public}.0s":"[CLIoHidInterface] setPropertyIoHid should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Property can not be set for null hidServiceRef
[CLIoHidInterface] IOHIDServiceClientSetProperty() returned false
{"msg%{public}.0s":"[CLIoHidInterface] applyAllDirtyDeviceProperties should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Apply all dirty device properties
[CLIoHidInterface] Service for device with usage pair {%{public}d, %{public}d} is not ready
[CLIoHidInterface] Property for usage pair {%{public}d, %{public}d}: {%{public}@ = %{public}@} was set %{public}s
[CLIoHidInterface] Could not set all properties. Setting timer to fire %{public}f seconds from now
[CLIoHidInterface] Could not set all properties after too many retries. Giving up.
{"msg%{public}.0s":"[CLIoHidInterface] setMatchingForDevices should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Prox: remove set matching multiple
[CLIoHidInterface] Adding match entry for usage pair {%{public}d, %{public}d}
[CLIoHidInterface] Setting matching multiple for %{public}lu events
[CLIoHidInterface] Received null sender
[CLIoHidInterface] Got null event,sender %{private}p,registryID %{public}llx
[CLIoHidInterface] Fetching historical events
[CLIoHidInterface] Did not fetch historical events
[CLIoHidInterface] It looks like our HID event system just become available (again)
[CLIoHidInterface] New IOHIDServiceClientRef for usage pair {%{public}d, %{public}d} just became available.
[CLIoHidInterface] onServiceRemoval - IOHIDServiceClientRef for service %{private}p with usage pair {%{public}d, %{public}d} and property %{private}@ will be removed.
[CLIoHidInterface] onServiceRemoval - successfully switch to service %{private}p with usage pair {%{public}d, %{public}d} and property %{private}@.
[CLIoHidInterface] onServiceRemoval - no available alternatives
{"msg%{public}.0s":"[CLIoHidInterface] setCallback should be called from motion thread", "usagePage":%{public}d, "usage":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"[CLIoHidInterface] setProperty should be called from motion thread", "usagePage":%{public}d, "usage":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Could not set property value for %{public}@
{"msg%{public}.0s":"[CLIoHidInterface] copyProperty should be called from motion thread", "usagePage":%{public}d, "usage":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"[CLIoHidInterface] should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"[CLIoHidInterface] must have event type set", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Service for usage pair {%{public}d, %{public}d} is not ready
{"msg%{public}.0s":"[CLIoHidInterface] Should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLIoHidInterface] Failed to stop streaming from the old service before switching to the new one
[CLIoHidInterface] Device,usagePage,%{public}d,usage,%{public}d,hidserviceref,old,%{private}p,new,%{private}p
[CLIoHidInterface] Service ref with usage pair {%{public}d, %{public}d} is %{private}p
[CLIoHidInterface] Checking matching property %{public}@ = %{private}@ for service ref %{private}p
[CLIoHidInterface] Invalid matching property %{public}@ = %{public}@ for service ref %{private}p
[CLIoHidInterface] Property mismatch! %{public}@ = %{public}@ for service ref %{private}p
[CLIoHidInterface] Device,hidUsagePage,%{public}d,hidUsage,%{public}d,hasCallback,%{public}d,serviceRef,%{private}p
[CLIoHidInterface] 
Property: %{public}@ = %{public}@,dirty,%{public}d
{"msg%{public}.0s":"CLCompass7 requires deviceMotionService", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Compass for AOP started. CoverAttached %{public}d
Compass for AOP stopped.
Setting compass update interval to %{public}f
Could not create turn-off timer
Keeping compass on for %{public}.0f seconds
Type,%s,attitude.x,%.8f,.y,%.8f,.z,%.8f,.w,%.8f,calibrated.x,%.8f,.y,%.8f,.z,%.8f,uncalibrated.x,%.8f,.y,%.8f,.z,%.8f,gravity.x,%.8f,.y,%.8f,.z,%.8f,heading,%.1f,trueheading,%.1f,accuracy,%.1f,level,%d,biasEstimation,%d,yawCorrection,%d,gravityCorrection,%d,courseCorrection,%d,visualLocalizationCorrection,%d,initalized,%d,accelSaturated,%d,gyroSaturated,%d,compassCalibration,%d,gyroCalibration,%d,course,%d,gmm,%d,north,%d,visualLocalization,%d,timestamp,%f
visionARSessionState.state,%d
Logging anomaly info in file [%s] [%s]
Logging anomaly info done packing file
Dumping [%s]
Unable to get contents of logging directory, error: %{public}@
Simulating event: %{public}lu.
Changing hgal capture mode: %{public}u.
{"msg%{public}.0s":"Notifier - Received anomaly detection subscription request with no event"}
{"msg%{public}.0s":"Notifier - Received anomaly detection subscription request with event", "direction":%{public, location:escape_only}s, "aop timestamp":%{public}llu, "operatingMode":%{private}u, "anomaly timestamp":"%{private}f", "update timestamp":"%{private}f", "state":%{private}d, "response":%{private}d, "resolution":%{private}d, "sosState":%{private}d, "current":%{public}hhd, "log to healthkit":%{public}hhd}
CLFitnessTrackingAllDayAWD: Increasing NumRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingWorkoutRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingtRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningWorkoutRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumHikingWorkoutRecoveryEvents
CLFitnessTrackingAllDayAWD: Increasing NumFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumHikingFallAlerts
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseConfirmedActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseConfirmedNoActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseDismissed
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseRejected
CLFitnessTrackingAllDayAWD: Increasing NumUserResponseAutomaticActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorCyclingUserResponseAutomaticActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorWalkingUserResponseAutomaticActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumOutdoorRunningUserResponseAutomaticActionRequested
CLFitnessTrackingAllDayAWD: Increasing NumHikingUserResponseAutomaticActionRequested
{"msg%{public}.0s":"CLFitnessTrackingAllDayAWD: Stacking new event duration", "duration":"%{private}f"}
Notifier - Received SOS Call initiated Callback
Notifier - Received SOS Call canceled Callback
Notifier - Received SOS Call ended Callback
Notifier - Received a SOS Call Ended Callback with no SOS Call timestamp!
Notifier - Logging SOS Call Placed
Notifier - Received SOS Call failed Callback
{"msg%{public}.0s":"Notifier - Received anomaly detection subscription request with outdated event", "direction":%{public, location:escape_only}s, "aop timestamp":%{public}llu, "operatingMode":%{private}u, "absolute timestamp":"%{private}f", "state":%{private}d, "response":%{private}d, "resolution":%{private}d, "sosState":%{private}d, "current":%{public}hhd, "log to healthkit":%{public}hhd}
{"msg%{public}.0s":"Skipping impact check against on/off wrist status and on/off charger for simulated event", "Received state":%{public}hhd, "Gating enabled":%{public}hhd}
{"msg%{public}.0s":"Skipping impact check against on/off wrist status and on/off charger as we did not receive a state yet", "Received state":%{public}hhd, "Gating enabled":%{public}hhd}
{"msg%{public}.0s":"Checking impact against on/off wrist status", "Received state":%{public}hhd, "Gating enabled":%{public}hhd, "status":%{private}hhd, "duration":"%{private}f"}
{"msg%{public}.0s":"Avoided event dispatch with watch off charger for too short", "status":%{private}d, "duration":"%{private}f", "threshold":%{private}d}
{"msg%{public}.0s":"Avoided event dispatch with watch on charger", "status":%{private}d, "duration":"%{private}f"}
{"msg%{public}.0s":"Checking impact against threshold", "age":%{private}d, "feature":"%{private}f"}
Fall detection feature is disabled, avoided dispatching event
No client was connected when event needed to be dispatched
{"msg%{public}.0s":"Avoided event dispatch not meeting threshold requirement", "identifier":%{public}llu, "feature":"%{private}f"}
{"msg%{public}.0s":"Failed to persist timestamp ", "for key":%{public, location:escape_only}s}
{"msg%{public}.0s":"Failed to read the timestamp."}
{"msg%{public}.0s":"Logging to AWD - time since last alert", "timeSinceLastAlert":"%{public}f"}
config{ mode=%{public}d, sensorRecordingEnabled=%{public}d, sensorRecordingActive=%{public}d, simulateEvent=%{public}d, userStudyPressureDataCollection=%{public}d, detectorEnabled=%{public}d, lastReplyAopTimestamp=%{public}llu -> variables{ enableFallStats=%{public}d, alwaysOn=%{public}d, supportsFallStatsModeBW190=%{public}d, supportsFallStatsModeBW400=%{public}d, optin=%{public}d, age=%{private}d, underRateLimit=%{public}d, shouldLogSensorData=%{public}d},keys{ FallStatsEnabled=%{public}d, FallStatsSensorRecordingEnabled=%{public}d}
Enabling Sensor Recorder
Disabling Sensor Recorder
CLFitnessTrackingAllDayAWD: Updating didEnableBackgroundAllDayAnomalyDetection %d
Clearing fall stats rate limit counter, was %f out of %d allowed
Fall stats rate limit counter incremented by %f for a total %f out of %d allowed
{"msg%{public}.0s":"Registration monitor - Added first client", "notification":%{public}d}
{"msg%{public}.0s":"Registration monitor - Removed last client", "notification":%{public}d}
{"msg%{public}.0s":"Registration monitor - Client registered, now allowing algorithms to run", "current status":%{private}hhd, "previous status":%{private}hhd}
{"msg%{public}.0s":"Registration monitor - Last client unregistered, setting timer for stopping detector", "current status":%{private}hhd, "previous status":%{private}hhd, "timer duration":%{public}d}
{"msg%{public}.0s":"Registration monitor - Last client unregistered, making sure detector is stopped", "current status":%{private}hhd}
{"msg%{public}.0s":"Registration monitor - Making sure the timer will not be trigger", "current status":%{private}hhd}
{"msg%{public}.0s":"Registration monitor - Finished clients discovery", "has client(s)":%{public}hhd}
{"msg%{public}.0s":"Registration monitor - Stopping algorithms after timer fire"}
Checking debug profile presence
{"msg%{public}.0s":"Debug profile presence has been changed, wiping subject UUID", "Presence before":%{public}hhd, "Presence now":%{public}hhd}
MaxMETs, on charger, setting timer interval to %f
MaxMETs, off charger, setting timer interval to %f
CLFallImpactMetrics: Logging impact at time %llu
CLFitnessTrackingAllDayAWD: Logging impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging outdoor cycling impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging outdoor walking impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging outdoor running impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging hiking impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Logging other workout impact cancelation reason 0x%llx
{"msg%{public}.0s":"Setting up logger manager", "enabled":%{public}hhd}
Unregistering for HR Notifications
Fail safe sensor recording handler
{"msg%{public}.0s":"Captured ADL Msl payload", "length":%{public}llu}
Received fall buffer flush packet
{"msg%{public}.0s":"Skipped sensor samples", "Data type":%{public}llu}
StatsRateLimitCounter set to %f
{"msg%{public}.0s":"Client discovery is now considered complete"}
{"msg%{public}.0s":"MaxMETs, Done computing stats."}
{"msg%{public}.0s":"MaxMETs, Queuing stats compute."}
{"msg%{public}.0s":"Wrist/Charger gating is now enabled"}
{"msg%{public}.0s":"Bridge settings were toggled", "enabled":%{private}d}
{"msg%{public}.0s":"Data collection setting was toggled", "stats":%{private}d, "presssure":%{private}d, "sensor":%{private}d}
Setting up sensor recording
{"msg%{public}.0s":"Flush handler being invoked - payload was not sent because watch has not been unlocked since last boot"}
{"msg%{public}.0s":"Flush handler being invoked - payload is too short to be sent", "actual duration":"%{public}f", "required duration":%{public}d}
{"msg%{public}.0s":"Flush handler being invoked - no payload to be sent as opt-in data collection is not enabled"}
{"msg%{public}.0s":"Avoiding tap to radar for near falls during workouts."}
{"msg%{public}.0s":"Flush handler being invoked - no GM payload to be sent"}
Releasing sensor data collection OS transaction
Time moved backwards. Reset timer immediately.
Setting next fire time for stats rate limiter (%f)
Tearing down sensor recording to server.
Releasing power assertion due to Fall Notifier destruction.
Received a workout event of type: %ld, with workout of type: %ld, workout state: %ld and healthkit workout of type: %ld
CLFitnessTrackingAllDayAWD: Updating end stats with workout type: %ld, start time: %ld, end time: %ld
{"msg%{public}.0s":"Recieved a un-subscribed notification"}
Logging odometer to logger.
Logging odometer for user studies.
Logging odometer to SensorKit.
{"msg%{public}.0s":"Logger manager was enabled whereas data collection date is passed - Disabling logger manager"}
Impact does not meet logging threshold requirement, will disregard stats.
Impact stats logged in previous state, will disregard duplicate logging.
Taking power assertion due to significant impact event subscription.
Setting fail safe timer for 180s.
High impact event HR subscription.
Logging impact stats to logger.
Logging impact stats for user studies.
Logging impact stats to AWD
Logging impact stats to CoreAnalytics
Logging impact stats to SensorKit.
{"msg%{public}.0s":"Received Near Fall event"}
Impact does not meet logging threshold requirement, will disregard state.
Logging impact update to logger.
Logging impact update for user studies.
Logging impact stats to Msl sink.
Logging on-wrist state update to logger.
Logging wrist state update for user studies.
Logging on-wrist state update to Msl sink.
Logging age group to AWD and CoreAnalytics
{"msg%{public}.0s":"CLFitnessTrackingAllDayAWD: Updating user age group", "belongsToOlderGroup":%{private}hhd}
{"msg%{public}.0s":"CLFitnessTrackingAllDayAWD: Updating user age bin", "value":"%{private}f"}
{"msg%{public}.0s":"Flush handler being invoked - checking if fall payloads should be sent to server or listeners"}
{"msg%{public}.0s":"Impact during", "Workout type ":%{public}llu}
{"msg%{public}.0s":"Captured Msl payload", "length":%{public}llu}
{"msg%{public}.0s":"Flush handler being invoked - did not meet all conditions for flushing yet", "fHasReceivedResolutionSinceLastFlush":%{private}hhd, "fHasReceivedFlushPacket":%{private}hhd}
{"msg%{public}.0s":"Flush handler being invoked - checking if near fall payloads should be sent to server or listeners"}
{"msg%{public}.0s":"Flush handler being invoked - did not see an alert - cleared payloads"}
{"msg%{public}.0s":"Logged item count", "Accel800Sample":%{public}llu, "Gyro200":%{public}llu, "Quaternion6":%{public}llu, "Pressure":%{public}llu, "HgalSample":%{public}llu}
Releasing power assertion
{"msg%{public}.0s":"User Profile Dictionnary", "content":%{private, location:escape_only}s}
{"msg%{public}.0s":"Notifier - Received anomaly event notification while detector is disabled - ignoring", "direction":%{public, location:escape_only}s, "aop timestamp":%{public}llu, "operatingMode":%{private}u, "anomaly timestamp":"%{private}f", "update timestamp":"%{private}f", "state":%{private}d, "response":%{private}d, "resolution":%{private}d, "sos_state":%{private}d}
{"msg%{public}.0s":"Notifier - Received anomaly event notification", "direction":%{public, location:escape_only}s, "aop timestamp":%{public}llu, "operatingMode":%{private}u, "anomaly timestamp":"%{private}f", "update timestamp":"%{private}f", "state":%{private}d, "response":%{private}d, "resolution":%{private}d, "sos_state":%{private}d}
{"msg%{public}.0s":"Notifier - Received anomaly event notification (already seen it)", "direction":%{public, location:escape_only}s, "aop timestamp":%{public}llu, "operatingMode":%{private}u, "anomaly timestamp":"%{private}f", "update timestamp":"%{private}f", "state":%{private}d, "response":%{private}d, "resolution":%{private}d, "sos_state":%{private}d}
Receiving Accel800
Receiving Hgal
Receiving sensor data due to high impact
Receiving Gyro200
Receiving DeviceMotion100
Creating sensor data collection OS transaction
Logging false positive suppression features.
Logging Max Accel Norm feature distribution to awd.
Logging Jerk Vector Magnitude feature distribution to awd.
Logging Max Abs XYZ feature distribution to awd.
Received reason for canceling (impact:%{public}llu, operatingMode:%{public}u, reason:0x%{public}llx)
         reason: %s
Dropping reason for canceling because of untracked operating mode
Logging reason for canceling in AWD
CLFitnessTrackingAllDayAWD: Increasing NumImpactReplacedBecauseOfNewImpact
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfMaxAccelNorm
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfOtherHardThresholds
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfMultiPeaks
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfNaiveBayes
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfExistingAlert
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfCyclingImpactThresholds
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledBecauseOfDisabledStateMachine
CLFitnessTrackingAllDayAWD: Increasing NumImpactCanceledAggregate
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfHighFrequencyFFT
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfLowFrequencyFFT
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDecimatedLowFrequencyFFT
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfFFT
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfPeaksIQR
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffBody
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfRepetitiveMotion
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfAbsenceOfQuiessence
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffWristPre
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffWristPost
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledAggregate
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfFeatureDisabled
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOnCharger
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfAlreadyGatedBefore
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfSimilarPeaks
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfLockedNoMotionBeforeImpact
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfReferee
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseStand
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseActive
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseSteps
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDistanceTraveledPostImpact
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfDistanceCyclingPostImpact
CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledOtherAggregate
CLFitnessTrackingAllDayAWD: Increasing NumRecoveryCanceledBecauseOfReferee
CLFitnessTrackingAllDayAWD: Increasing NumRecoveryCanceledAggregate
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseUserResponse
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseOffWrist
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseStand
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseActive
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseSteps
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledBecauseAbsenceOfLongLie
CLFitnessTrackingAllDayAWD: Increasing NumSOSCanceledAggregate
An Impact sequence just started.
Receiving Pressure
{"msg%{public}.0s":"Received onWristMonitor update", "timestamp":%{public}llu, "onWrist":%{public}d, "onWristSensor":%{public}d, "onWristConfidence":%{public}d, "isOnCharger":%{public}hhd, "isForcedOnWristEnabled":%{public}hhd, "isWristDetectionEnabled":%{public}hhd}
Received post event HR : %f
{"msg%{public}.0s":"Received CLDataProtectionManager notification, will no register to natalimetry"}
{"msg%{public}.0s":"Wiring bug, should not be subscribed to ", "notification":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLFallNotifier Logging Internal State:
{"msg%{public}.0s":"CMFallConfig", "CMFallStatsMode":%{private}u, "CMFallStatsSensorRecordingActive":%{private}u, "CMFallStatsSimulateFall":%{private}u, "CMFallStatsUserStudyPressureDataCollection":%{private}u, "CMAnomalyDetectorEnabled":%{private}u, "CMFallLastReplyAopTimestamp":%{private}llu}
{"msg%{public}.0s":"CMFallBehavioralConfig", "CMFallConfigUserAge":"%{private}f", "CMFallConfigUserMets":"%{private}f", "CMFallImpactAlertThreshold":"%{private}f", "CMFallImpactLoggingStatsThreshold":"%{private}f", "CMFallImpactLoggingHeartRateThreshold":"%{private}f", "CMFallImpactLoggingHighResolutionSensorDataThreshold":"%{private}f"}
CMFallInternalNotifierState::CMFallDefaults: %{private}@
CMFallInternalNotifierState::CMFallConfiguration: %{private}@
CMFallInternalNotifierState::CMFallState: %{private}@
CMFallInternalNotifierState::CMFallOptInsAndProfiles: %{private}@
CMFallInternalNotifierState::CMFallFieldMetrics: %{private}@
CMFallInternalNotifierState::CMFallHDSCollection: %{private}@
CMFallInternalMetricState: (%{private}lu)
    %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@, %{private}@: %{private}@
Received sysdiagnose event
Additional logging profile installed - Subject UUID: %{public}@
Logging anomaly info...
Received daemon settings notification
Received managed configuration change notification
Failed to get user mets percentile.
Could not select model based in provided features - Falling back to defaults
{"msg%{public}.0s":"CLFitnessTrackingAllDayAWD: Updating user max mets", "value":"%{public}f"}
{"msg%{public}.0s":"CLFitnessTrackingAllDayAWD: Updating user behavioral threshold", "value":"%{public}f"}
CL: CLFallNotifier::onFallStatsData
{"msg%{public}.0s":"CLFallNotifier::onFallStatsData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onFallEventData
{"msg%{public}.0s":"CLFallNotifier::onFallEventData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onImpactDataAccel800
{"msg%{public}.0s":"CLFallNotifier::onImpactDataAccel800", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onImpactDataHgal
{"msg%{public}.0s":"CLFallNotifier::onImpactDataHgal", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onImpactDataGyro200
{"msg%{public}.0s":"CLFallNotifier::onImpactDataGyro200", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onImpactDataQuaternion6
{"msg%{public}.0s":"CLFallNotifier::onImpactDataQuaternion6", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onImpactDataStart
{"msg%{public}.0s":"CLFallNotifier::onImpactDataStart", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onFalsePositiveSuppressionFeatures
{"msg%{public}.0s":"CLFallNotifier::onFalsePositiveSuppressionFeatures", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onFeatureDistributionMaxAccelNorm
{"msg%{public}.0s":"CLFallNotifier::onFeatureDistributionMaxAccelNorm", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onFeatureDistributionJerkVectorMagnitude
{"msg%{public}.0s":"CLFallNotifier::onFeatureDistributionJerkVectorMagnitude", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onFeatureDistributionMaxAbsXYZ
{"msg%{public}.0s":"CLFallNotifier::onFeatureDistributionMaxAbsXYZ", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onFallCancelReason
{"msg%{public}.0s":"CLFallNotifier::onFallCancelReason", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onPressureData
{"msg%{public}.0s":"CLFallNotifier::onPressureData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onFallDistance
{"msg%{public}.0s":"CLFallNotifier::onFallDistance", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onWatchOrientationNotification
{"msg%{public}.0s":"CLFallNotifier::onWatchOrientationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onAppMonitorNotification
{"msg%{public}.0s":"CLFallNotifier::onAppMonitorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onHeartRateNotification
{"msg%{public}.0s":"CLFallNotifier::onHeartRateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onUserInfoNotification
{"msg%{public}.0s":"CLFallNotifier::onUserInfoNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onDataProtectionNotification
{"msg%{public}.0s":"CLFallNotifier::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onWatchOrientationSettingsNotification
{"msg%{public}.0s":"CLFallNotifier::onWatchOrientationSettingsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLFallNotifier::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onOdometerUpdate
{"msg%{public}.0s":"CLFallNotifier::onOdometerUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onBatteryNotification
{"msg%{public}.0s":"CLFallNotifier::onBatteryNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onDataCollectionChangedNotification
{"msg%{public}.0s":"CLFallNotifier::onDataCollectionChangedNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFallNotifier::onDarwinNotification
{"msg%{public}.0s":"CLFallNotifier::onDarwinNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d
{"msg%{public}.0s":"Unsupported update for feature distribution type", "type":%{public}d}
Resetting detector, %.1f seconds without an accel sample
Resetting detector, %.1f seconds without a tremor score
Invalid message recieved from framework.
[SidebandSensorFusion] Wrong parameters were passed!
[SidebandSensorFusion] Request failed,enabled,%{public}d,snoop,%{public}d,latency,%{public}d,success,%{public}d
Registered for keyboard state notifications
Registered for charging events.
Retrieved cached cover state timestamp,%f
Registered for cover state notifications
Could not create timer
Cover attached,%d,forced,%d
Keyboard coexSource,%d
Cover %s
Keyboard %s
{"msg%{public}.0s":"Compass should only be reset from locationd", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Resetting compass on charging event,charging,%d
using attitude dependent KF calibrator
compass ignoring database (%d)
compass using manual bias (%.3f/%.3f/%.3f)
compass ignoring calibration (%d)
compass input filter is using (%zuu) samples
compass heading output filter samples (%d) scale (%f)
apple compass calculator, sample rate (%.3f) ignoreDatabase (%d) manual (%d)
XYDevice not stable. %d, %d, %.3f, Clearing search buffers.
storing new compass calibration, magneticField (%+.3f,%+.3f,%+.3f), bias (%+.3f/%+.3f/%+.3f), level (%d) magnitude (%+.3f) inclination (%+.3f)
rawHeading, %.3f, gyroHeading, %.3f, deltaRaw, %.3f, deltaGyro, %.3f, rawHeadingU, %.3f, gyroHeadingU, %.3f, filteredHeading, %.3f, alpha, %.3f, gamma, %.3f, rotVar, %.5f, rotMag, %.3f, deltaFiltered, %.3f
#Warning Heading  %.2f, is not in bound [0 360]
magnitude max threshold exceeded (%+.3f), resetting calibration
magnitude threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
inclination threshold exceeded (%f) with (%f) from base value (%f), resetting calibration
CompassDB restored bias (%+.3f/%+.3f/%+.3f)
{"msg%{public}.0s":"#EED2Cfg updated CB info", "changed":%{public}d, "sim":%{public}d, "version":%{public, location:escape_only}s, "id":%{public, location:escape_only}s, "enabled":%{public}hhd, "adrEnabled":%{public}hhd, "dsaEnabled":%{public}hhd, "lisUrl":%{private, location:escape_only}s, "adrUrl":%{private, location:escape_only}s, "firstLisTimeout":"%{private}f", "periodicLisTimeout":"%{private}f", "initialAdrTimeout":"%{private}f", "partnerCertMapSize":%{public}d, "intermediateCert":%{public, location:escape_only}s}
{"msg%{public}.0s":"#EED2Cfg updated BAA settings", "changed":%{public}hhd, "disabled":%{public}hhd, "EED enabled only":%{public}hhd, "cert validty period":%{public}d, "no cert request window":%{public}d, "no cert retry window":%{public}d, "cert available request window min":%{public}d, "cert available request window max":%{public}d, "cert available retry window":%{public}d}
#Warning #EED2Cfg,inst,%{public}d,unable to convert base64 string to SecCertificateRef for partner %{private}s
#Warning #EED2Cfg,inst,%{public}d,found duplicate certifacte for partner %{partner}s
#EED2Cfg,inst,%{public}d,added cert for partner %{private}s
#Warning #EED2Cfg,inst,%{public}d,overriding intermediate cert to %{private}s
#Warning #EED2Cfg,inst,%{public}d,overriding LIS URL to %{private}s
#Warning #EED2Cfg,inst,%{public}d,overriding ADR URL to %{private}s
#Warning #EED2Cfg,inst,%{public}d,force enabling EED
#Warning #EED2Cfg,partner certificate default overriding certs from other sources
#Warning #EED2Cfg,inst,%{public}d,unable to retrieve partner IDs from default
#EED2Cfg,inst,%{public}d,reading %{public}d partner certs from default
#Warning #EED2Cfg,inst,%{public}d,unable to read cert data for partner %{private}s
#EED2Cfg,unable to convert intermediate cert data to SecCertificateRef
#EED2Cfg,inst,%{public}d,configured to use %{public}s ADR cert policy
#EED2Cfg,failed to create ADR cert validation policy
#EED2Cfg,partner certificate is valid,partner ID,%{public}s,partner cert,%{public}s
#EED2Cfg,invalid partner certificate found,partner ID,%{public}s,partner cert,%{public}s
#EED2Cfg,unable to convert partner cert data to SecCertificateRef,partner ID,%{public}s
#EED2Cfg,partner ID does not match common name in cert,partner ID,%{public}s,common name,%{public}s
#EED2Cfg,failed to create trust object when validating ADR cert,partner ID,%{public}s,err,%{public}d
#EED2Cfg,failed to disable network use for trust eval,partner ID,%{public}s,err,%{public}d
#EED2Cfg,ADR certificate validation failed,partner ID,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s
#Warning #EED2Cfg EED2 is disabled due to simulator mode
#Warning #EED2Cfg EED2 is disabled due to conformance mode
#EED2Cfg ignoring emergency settings for unexpected inst %{public}d
#EED2Cfg keeping previous active inst %{public}d
#EED2Cfg ignoring unexpected inst %{public}d
#EED2Cfg active inst changed to %{public}d
#EED2Cfg ignoring BAA settings for unexpected inst %{public}d
#EED2Cfg unexpected inst %{public}d is active
#EED2Cfg EED enabled for sim %{public}d operator
#EED2Cfg EED enabled for sim %{public}d carrier
#EED2Cfg EED UI should %{public}s
#EED2Cfg BAA enabled for sim %{public}d operator
#EED2Cfg BAA enabled for sim %{public}d carrier
#EED2Cfg BAA cert requests %{public}s
#EED2Cfg EED2 config for inst %{public}d wasn't created on construction
#EED2Cfg EED2 carrier config for inst %{public}d wasn't created on construction
#EED2Cfg EED2 operator config for inst %{public}d wasn't created on construction
#EED2Cfg requested sim config for BAA when not enabled
{"msg%{public}.0s":"#EED2 logging current settings", "enabled":%{public}d, "switch state":%{public}d, "inst":%{public}d, "bundle ID":%{public, location:escape_only}s, "bundle version":%{public, location:escape_only}s, "LIS URL":%{private, location:escape_only}s, "ADR URL":%{private, location:escape_only}s}
{"msg%{public}.0s":"#EmgContext #EED2", "CompanionNum":%{private, location:escape_only}s, "UserToggle":%{public}d}
#EED2 active inst changed to %{public}d
{"msg%{public}.0s":"#EED2 emergency call status change", "old trigger":%{public, location:escape_only}s, "new trigger":%{public, location:escape_only}s, "old call status":%{public, location:escape_only}s, "new call status":%{public, location:escape_only}s}
#EED2,#DSA,authorization status has not changed,status,%{public}d
#EED2,#DSA,authorization status changed for SOS bundle,status,%{public}d
#Warning #EED2 SendFixTimeout fired while Disabled
#Warning #EED2 SendAdrTimeout fired while Disabled
#Warning #EED2 SessionAssertReleased fired in Disabled state
#Warning #EED2 CanSendADRTimeout fired while Disabled
#EED2 LIS Response timer timedout. Submit AWD report with failure
#EED2 LIS Response timer timedout when no notifications were expected
#Warning #EED2 SendFixTimeout fired while Idle
#Warning #EED2 SendAdrTimeout fired while Idle
#Warning #EED2 SessionAssertReleased fired in Idle state
#Warning #EED2 CanSendADRTimeout fired while Idle
#EED2 LIS response timer timedout. Submit AWD report with failure
#EED2 LIS response timer timedout when no notifications were expected
#EED2 Submitting previous session AWD report before starting new session
#EED2 allowed to send ADR data immediately
#EED2 session assertion active during Session Exit,clearing
#Warning #EED2 unexpectedly disabled during active emergency call
#EED2 delaying Session Exit due to session assertion
#EED2 EmergencyCallStatusChange,no ongoing call,cancel CanSendADRTimeout
#EED2 EmergencyCallStatusChange,ADR allowed immediately
#EED2 EmergencyCallStatusChange,subsequent emergency call ongoing,restart CanSendADRTimeout
#EED2 EmergencyCallStatusChange,subsequent emergency call ongoing,ADR allowed immediately
#EED2 EmergencyCallStatusChange,sending ADR immediately
#EED2 CachedLocationUpdate,triggering ADR send
#EED2 delaying sending updated ADR data until timer fires or we fetch all ADR data
#EED2 CanSendADRTimeout,ADR sending already allowed
#EED2 CanSendADRTimeout,no ongoing emergency call
#EED2 CanSendADRTimeout,ongoing emergency call,allow ADR
#Warning #EED2 LIS Timeout while in Session. Ignoring it
#EED2,#Sec,failed to copy key from keychain,response,%{public}d
#EED2,#Sec,failed to delete key from keychain,response,%{public}d
#EED2,#Sec,failed to add key to keychain,response,%{public}d
#EED2,#Sec,failed to copy cert from keychain,response,%{public}d
#EED2,#Sec,failed to delete cert,response,%{public}d
#EED2,#Sec,failed to add cert to keychain,response,%{public}d
#EED2,#BAA,loading cached info
#EED2,#BAA,unable to retrieve BAA private key from keychain
#EED2,#BAA,unable to retrieve BAA leaf cert from keychain
#EED2,#BAA,unable to retrieve BAA intermediate cert from keychain
#EED2,#BAA,following info missing in keychain,private key,%{public}d,leaf cert,%{public}d,intermediate cert,%{public}d
#EED2,#BAA,cache did not contain next BAA cert request time
#EED2,#BAA,writing info to disk
#EED2,#BAA,failed to add BAA private key to keychain
#EED2,#BAA,failed to add BAA leaf cert to keychain
#EED2,#BAA,failed to add BAA intermediate cert to keychain
#EED2,#BAA,deleting cached info
#EED2,#BAA,unable to delete existing BAA private key
#EED2,#BAA,unable to delete existing BAA leaf cert
#EED2,#BAA,unable to delete existing BAA intermediate cert
{"msg%{public}.0s":"#EED2,#BAA,current BAA info", "cert valid":%{public}hhd, "cert validity begins":"%{public}.1f", "cert validity ends":"%{public}.1f", "next cert request":"%{public}.1f"}
{"msg%{public}.0s":"#EED2,#BAA,checking cert request status", "reason":%{public, location:escape_only}s, "valid cart available":%{public}hhd, "next scheduled request":"%{public}.1f"}
#EED2,#BAA,there is a cert request outstanding already,no need to do anything until we get a response
#EED2,#BAA,no need to start XPC activity
#EED2,#BAA,need to stop XPC activity due to device settings
#EED2,#BAA,next cert request time changed so (re)starting XPC activity
#EED2,#BAA,need to start XPC activity
#EED2,#BAA,need to request cert immediately for ongoing session
#EED2,#BAA,scheduling next cert request
#EED2,#BAA,shouldn't be checking next cert request time during SessionStart
#Warning #EED2,#BAA,next cert request time places us beyond expiration of current cert so modifying
#EED2,#BAA,updated next cert request time
#EED2,#BAA,requesting of BAA certs not allowed by config,not starting XPC activity
#EED2,#BAA,registering BAA cert request activity,delay,%{public}lld,gracePeriod,%{public}lld
#EED2,#BAA,cert request activity handler triggered with unexpected state %{public}d
#EED2,#BAA,cert request activity handler triggered
#EED2,#BAA,unregistering BAA cert request activity
#EED2 attempted to send location when not enabled
#EED2 sending message for native number
#EED2 native number is empty, not sending message
#EED2 sending message for companion number
#EED2 companion number is empty or device supports alternate account, not sending message
#EED2 no fix available to send in LIS payload, not sending
#EED2 can't POST message due to invalid URL session
#EED2 POSTing LIS data for %{public}s number message %{public}d
{"msg%{public}.0s":"#EED2 created LIS dict", "phone number":%{private, location:escape_only}s, "session start time":%{public}lld, "medium":%{public, location:escape_only}s}
#EED2,location is not valid so not creating location dict
{"msg%{public}.0s":"#EED2 created location dict", "timestamp":%{public}lld, "latitude":"%{private}f", "longitude":"%{private}f", "altitude (HAE)":"%{private}f", "hunc":"%{public}f", "vunc":"%{public}f"}
{"msg%{public}.0s":"#EED2 created internal dict", "message_ID":%{public}d, "sim":%{public}d, "rat":%{public}d, "sim_bundle_id":%{public, location:escape_only}s, "sim_country":%{public, location:escape_only}s, "operator_bundle_id":%{public, location:escape_only}s, "operator_country":%{public, location:escape_only}s, "product_type":%{private, location:escape_only}s, "release_type":%{public}d, "trigger_type":%{public}d}
#EED2 failed to serialize LIS dict into JSON
{"msg%{public}.0s":"#EED2,sending LIS POST", "URL":%{private, location:escape_only}s, "length":%{private}lld}
#EED2,getSerializedJsonData,dict is nil
#EED2,getSerializedJsonData,failed to serialize dict into JSON,domain,%{public}s,code,%{public}d
#EED2,#BAA,added header x-eed-baa-signature : %{public}s
#EED2,#BAA,added header x-eed-baa-leaf-cert : %{public}s
#EED2,#BAA,added header x-eed-baa-int-cert-1 : %{public}s
#EED2,#BAA,addHeadersToUrlRequest,cert not available
#Warning #EED2,sending environment override header for %{private}s
#Warning #EED2,sending demo header for %{private}s
{"msg%{public}.0s":"#EED2,#LIS,handleHttpsResponse,response headers", "numberType":%{public, location:escape_only}s, "message":%{public}d, "responding instance":%{private, location:escape_only}s, "UUID":%{private, location:escape_only}s, "jingle corr key":%{private, location:escape_only}s, "via":%{private, location:escape_only}s}
#EED2, messageID is not part of pending messageID!
#EED2 POST for %{public}s number message %{public}d succeeded with response code %{public}d
#EED2 POST for %{public}s number message %{public}d failed with response code %{public}d
#EED2 POST was determined to be outside coverage area
#EED2 POST for %{public}s number message %{public}d failed with error code,%{public}d,domain,%{public}@,reason,%{public}@
#EED2 startCanSendADRTimeout called when timeout is already running, ignoring
#EED2 startCanSendADRTimeout
#EED2 cancelCanSendADRTimeout
#EED2,sendAdr,attempted to send ADR when not enabled
#EED2,sendAdr,ignoring ADR send request,not allowed to send ADR data at this time
#EED2,sendAdr,ignoring ADR send request,not finished gathering ADR data
{"msg%{public}.0s":"#EED2,sendAdr,not configured for ADR encryption"}
#EED2,sendAdr,neither native nor companion number available so not sending ADR
#EED2,sendAdr,no location available so not sending ADR
#EED2,sendAdr,failed to send
{"msg%{public}.0s":"#EED2,#ADR,handleAdrResponse,response headers", "numberType":%{public, location:escape_only}s, "responding instance":%{private, location:escape_only}s, "UUID":%{private, location:escape_only}s, "jingle corr key":%{private, location:escape_only}s, "via":%{private, location:escape_only}s}
#EED2,ADR POST for %{public}s number succeeded with response code %{public}d
#EED2,ADR POST for %{public}s number failed with response code %{public}d
#EED2,ADR POST was determined to be outside coverage area
#EED2,ADR POST for %{public}s number failed with error code,%{public}d,domain,%{public}@,reason,%{public}@
#Warning #EED2 unexpected error code
%sstate,%d,%s
%scurrent_state,%s,event,%s
%sNested invocation of state machine
%snewState,%s
%soldState,%s,event,%s
%snewState,%s,event,%s
%scancel timer,event,%s
#Warning,%s,cancel timer,notFound, event,%s
%sInvoking timers without callback queue set
%sCannot start timer, event, %{public}s, timeOutSec, %{public}.2f
%scannot create timer, event, %{public}s
%sevent,%s,timeout,%.2f
{"msg%{public}.0s":"AlsNetworkRequestMetric", "number of ALS requests triggered by WiFi":%{public}lu, "number of APs requested":%{public}lu, "number of surrounding APs requested":%{public}lu, "number of ALS requests per Rat":%{public, location:escape_only}s, "number of Als Cells requested per Rat":%{public, location:escape_only}s, "number of ALS cell requests with different rats":%{public}lu}
{"msg%{public}.0s":"LogCellAlsMetric", "number of Als Cells requested per Rat":%{public, location:escape_only}s}
{"msg%{public}.0s":"LogWifiAlsMetric", "number of APs requested":%{public}lu, "number of surrounding APs requested":%{public}lu}
Already correct power mode, %d
Changing cached location power mode from %d to %d
mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd), coverAttached (%d)
mean (%f) scale (%f) variance sample size (%zd) max sample length (%zd)
{"msg%{public}.0s":"lookupBias was called on the base CLCompassDatabase class"}
sample rate (%.3f) observation rate (%.3f) observation threshold (%.3f) deviation count threshold (%d) standard deviation threshold (%.3f)
threshold (%f) was exceeded with observed value (%f) and base value (%f) and standard deviation (%f) and count of (%d)
Overriding youth type for heart rate, beginTime, %f, before, %{public}d, after, %{public}d, fhr,%{public}f
HRStop detect in rowing model during state,%{public}d
RowStop,state,%d,rowCounter,%d,headingCounter,%d,epochsInExit,%d,longStd,%f,shortStd,%f,isRow,%d,isRowHistory,%d,isRowUnf,%d
WifiFlow, cpitile, %{public}d, didfix, %{public}d, battsaver, %{public}d, sigenv, %{public}d, aps, %{public}ld, hacc, %{public}0.1f, scanAge, %{public}d
CLRS,CLCF,Could not convert LLA Coordinate %.7lf,%.7lf to ECEF
CLRS,CLCF,Could not convert ECEF Coordinate %.3lf,%.3lf,%.3lf to ENU
CLRS,CLCF,No corners found, input segment too short.
{"msg%{public}.0s":"This class doesn't have a callback to register -- you must assign one first", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Registered with CoreDuet for %{private}@ with predicate %{private}@
{"msg%{public}.0s":"This class doesn't have a callback to deregister -- you must assign one first", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Deregistered with CoreDuet for %{private}@ with predicate %{private}@
{"msg%{public}.0s":"Couldn't find a string for event type", "event type":%{public}ld, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLDuetMonitor: not supported on this platform because CoreDuet.framework is not present
{"msg%{public}.0s":"Unable to register for a CoreDuet notification", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Added %{private}@ client to the list of listeners for event type %{private}ld with predicate %{private}@
{"msg%{public}.0s":"Attempting to register for Duet event but already registered", "event":%{public}ld, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Received callback for %{public}@
Client %{private}@ is not registered for event %{public}ld
{"msg%{public}.0s":"Couldn't find a keypath for event type", "event type":%{public}ld, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Couldn't find a predicate for event type", "event type":%{public}ld, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Event is nil", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Invalid event value", "eventType":%{public}ld, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Event type does not have a corresponding notification.", "event type":%{public}ld, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning The app dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetForegroundApp class
bundleId or launchReason were nil so not processing this notification
#Warning The scene dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetHomeKitScene class
some of the expected keys were not found, so not processing this notification. %{private}@
#Warning The accessory dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetHomeKitAccessory class
some of the expected keys were not found so not processing this notification. %{private}@
#Warning The app view dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetHomeKitAppView class
#Warning The Now Playing dictionary notification from CoreDuet has different information than we expect. This info should be added to the CLDuetNowPlaying class
Assertion failed: temperature != 3.40282347e+38F, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMLinearTemperatureFit.cpp, line 45,temperature,%f.
Workout query, %@
registerClient: notification %ld is not supported
{"msg%{public}.0s":"registerClient", "notification":%{public}ld, "newCount":%{public}ld}
{"msg%{public}.0s":"unregisterClient", "notification":%{public}ld, "newCount":%{public}ld}
{"msg%{public}.0s":"CLBarometerCalibration track started", "time":"%{private}f", "type":%{private}d}
{"msg%{public}.0s":"CLBarometerCalibration track stopped", "time":"%{private}f", "type":%{private}d}
received odometer notification, startTime %f, elevationAscended %u, elevationDescended %u, failure mode %u, source %u
motion state observer updates, time %f, activityType %d, predictedWorkoutType %d
inOutdoorWorkout %d
companion connected updated: %d
wet state updated to %d
destructing Altimeter context
received visit for altimeter, inVisit, %d, arrival date, %f, departure date, %f, current time, %f
error fetching visits
retrieved visits, last visit type was, %d, lat, %f, lon, %f
Received error when fetching LOI from visit, LOI id %@
LOI id %@, elevation, %f, uncertainty, %f, visit entry time, %f, current timestamp, %f
LOI visit entry, timestamp, %f, current timestamp, %f, loi altitude, %f, loi altitude uncertainty, %f, altimeter, %f, altimeter uncertainty, %f
Database is not accessible.
Unable to update alarm because bundleId or name is empty.
Unable to iterate through all rows for getAllAlarms!
Unable to prepare due to invalid database.
Successfully created database
RotationStability buffer not set.
Could not set bias retrieved from database
setting bias (%.3f/%.3f/%.3f) level (%d)
reset internal. levels-data(%d %d %d), pScale=%.3f 
compass calibrator reset
Resetting calibrator states.
Resync after long coasting with mag drift. mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), Age(%d,%d)
DRIFT DETECTED. numBad=%d,s=%.3f,delH(%.3f,%d,%.3f), expectedVec (%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d),deltaTime(%.3f)
fBackupInfoSet(%d), syncAge(%d)
Likely bad resync. Backup.
RESYNC Rejected. numBad=%d,mag/incDiffMean(%.3f/%.3f), measure(%.3f/%.3f/%.3f/%.3f), syncAge(%d)
numBad(%d), delH(%.3f), coastVec(%.3f/%.3f/%.3f), expectedVec(%.3f/%.3f/%.3f), calibrated(%.3f/%.3f/%.3f), angleDiff(%.3f/%.3f), magDiff(%.3f/%.4f), incDiff(%.3f/%.3f), measure(%.3f/%.3f/%.3f), coasting(%.3f/%d/%d), coastingCount(%d)
Coasting vector not set.
Prolonged high magDiff. Likely bad calibration. Resetting.
Extremely high magnitude.  magDiff (%.3f), magnitude (%.3f), calibrated (%.3f/%.3f/%.3f), coastVector (%.3f/%.3f/%.3f),coastingTime,%.3f,magDiffVar,%.3f,resetInternal,%d
******* scale(%.3f),cAge(%d), magDiff(%.3f), dHeading(%.3f), deltaAngle(%.3f), numBad(%d), calInc(%.3f), incDiffIsStable(%d)
Steep inclination. Likely bad interference or bad database lookup. Resetting. 
Interference is gone.
**INTERFERENCE-1 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
**INTERFERENCE-0 dAngle=%.3f,dHeading=%.3f,magDiff=%.3f,incDiff=%.3f
Likely bad database lookup. Resetting. 
Divergence!!! Resetting.
new internal estimates (%.3f %.3f %.3f)
taking new estimates, Internal. fIsCoasting (%d)
new estimates denied, fIsCoasting (%d)
taking new estimates, reached database. (%d)
new esitmates disagree with database. (%d,%d,%.3f)
calibrated, first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
taking new estimates, fIsCoasting (%d)
estimates improved.(%.3f/%.3f/%.3f), numImprov=%d 
new estimates needed, fIsCoasting (%d)
first estimates completed (%.3f/%.3f/%.3f/%.3f), conv(%d %d %d), level (%d)
new estimates calculated, converged(%d %d %d) Var (%.3f %.3f %.3f), remain (%.3f), level (%d), num=%d 
Bad heading divergence for too long. Prompt user to re-calibrate.
Waiting too long for internal re-calibration. Prompt user.
Waiting too long for high magnitude interference to go away. Exit coasting.
Coasting for too long. Exit coasting.
fCoastingVecPrint: %.3f, %.3f, %.3f, %.3f, %.3f, %.3f
Attitude data not set.
Type,%s,Updating reference frame.
Updating during coasting, fIsResetInternal(%d)
BACKUP resync coasting vector
resync coasting vector. rotM,%.3f,rotV,%.3f
device status: (smooth static) = (%d %d), rotM,%.3f,rotV,%.3f, q.x,%.3f,q.y,%.3f,q.z,%.3f,q.w,%.3f)
coasting vector is mature, no more updating
numSamplesSkipped (%d), deltaQ (%.3f/%.3f/%.3f/%.3f), deltaReadingM (%.3f)
bias.x,%.3f,bias.y,%.3f,bias.z,%.3f,scale.x,%.5f,scale.y,%.5f,scale.z,%.5f,extF.x,%.3f,extF.y,%.3f,extF.z,%.3f
set coasting vector (%.3f/%.3f/%.3f), levels (%d %d) conv(%d %d %d) age (%d) syncAge (%d) DueTo (%d)
enters coasting
exits coasting
PLOS:kLowestElevationInDegrees,%.2f,kTallestBuildingHeight,%.2f,kLargestDistance,%.2f
PLOS,GpsForcePlos,%d
PLOS, cannot estimate nav mode, disabling
PLOS, non-pedestrian, not matching
PLOS: no mapGeometry!
PLOS: no geometry!
#Warning PLOS: buildingsWithinDistance,%lf returned false!
#Warning PLOS: buildings.size() %ld > 500. too many buildings. Aborting
PLOS: no candidate svs for time %{public}lf
#Warning PLOS: polyPoint == candidatePoint
PLOS: unexpected to not find SV, %{public}d in fSvPlosMap!
#Warning PLOS: majorAxis,%lf < minorAxis,%lf
#Warning PLOS: Clamping majorAxis,minorAxis,%fm
%{public}s not supported on this device type
Failed parse os_log format specifier for shimming:missing closing brace,format,%{public}s
%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f
Odometer failed to compute a mean pace.
Time didn't move! time,%{public}f
TCONV,mach_get_times failed
TCONV,error occurred, no mib to wake_abs_time conversion
TCONV,mib filled to %zu
TCONV,Error occurred when get wake_abs_time,%{errno}d
TCONV,GetLastWakeUpMachAbsoluteTime success,machAbs,%{public}llu,floatInterval,%{public}.6lf
TCONV,Getting last wake up time failed
TCONV,invalid deltaContAbsSec
TCONV,invalid deltaCfAbsSec
TCONV,mach_get_times,machAbs,%{public}llu,machCont,%{public}llu,tv_sec,%{public}ld,tv_nsec,%{public}ld,deltaContAbs,%{public}.6lf,deltaCfAbs,%{public}.6lf,lastWakeAbs,%{public}.6lf,machNow,%{public}.6lf,machContNow,%{public}.6lf,sysNow,%{public}.6lf
TCONV,Cannot get wakeTime or MachTime before sleep,machAbs,%{public}.6lf,wakeTime,%{public}.6lf
TCONV,UpdateLastWakeUpTime failed
TCONV,Failed in getting the offset between mach continuous time and mach absolute time
TCONV,Failed in getting the offset between CF time and mach time
Deleting all files in %{private}@
Cleaning up files older than %.0f [s] in %{private}@
skipping directory %@
pairNumber,%d,startTime,%f,mets,%f,hr,%f,hrConfidence,%f,gradeType,%d,grade,%f,hasGPS,%d,hasStrideCal,%d,metSource,%d,workoutType,%d,warmupOK,%d,gradeOK,%d,metDeltaOK,%d,metsAboveMin,%d,metSourceOK,%d,hrOK,%d,cadence,%f,workoutLengthOK,%d,pace,%f,paceOK,%d,strollerOK,%d,percentGradeSigma,%.6f,percentWalkingOK,%d,metsAboveAdaptiveAlgMin,%d,pairOKForClustering,%d,pairOKForAdaptiveModel,%d,isStroller,%d
Session distance estimate,odometer,%lf,generic stroke lengths,%lf
WheelchairPush, computeTime, %f, metsFromPushes, %.1f, Push Count, %d, pushEM, %.1f
Yoga,metsWR,%f,metsHR,%f,truthMets,%f,truthMetsSrc,%d,userMets,%f,userMetsSrc,%d
Doing crude accel measurement update.
rotBufferSize, %zu, accelBufferSize, %zuu, peakCount, %d, fMaxStd, %.3f
gyroDt, %.4f, doAccelCheck, %d
omegaMag6, %.3f, omega, %.3f, %.3f, %.3f
[AppleQuaternion] x,%f,y,%f,z,%f,w,%f,timestamp,%f
[Bias,Var] bias.x,%f,bias.y,%f,bias.z,%f,var.x,%f,var.y,%f,var.z,%f
[Accelerometer6] x,%.4f,y,%.4f,z,%.4f,lpf, %.4f, %.4f, %.4f, timestamp,%lf
[RotationRate6X] %.3f, %.3f, %.3f, %.3f, %.3f
rotating and going through.
it's been too long. go through.
grabing gravity, %.4f, %.4f, %.4f
std, %.3f, %.3f, %.3f, mag, %.3f, dot, %.3f, leftover, %.3f
sum, %.3f, %.3f, %.3f, dot, %.3f, leftover, %.3f
===========Skip ahead.
Skip ahead------.
Taking another look.
using mean accel
accM, (%.4f, %.4f, %.4f), mag, %.3f
Doing some crude updates to catch up.
[KalmanFilterStates] %f,%f,%f,%f,%f,%f,%f
High Intensity, CR DT Regression, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, METS, %f
Deescalation event for background VO2Max estimation, max time limit reached
Deescalation event for background VO2Max estimation, location is not outdoors
Deescalation event for background VO2Max estimation, session stats, duration,%.3f,totalBadSeconds,%.3f,preconditionFailed,%d
Deescalation event for background VO2Max estimation, pair stats, countTotalSamples,%d,countBadHR,%d,countBadWR,%d,countBadGPS,%d,countBadSamples,%d
VO2SessionStatus,duration,%.3f,totalGoodSeconds,%.3f,totalBadSeconds,%.3f,timeElapsed,%.3f,preConditionFailed,%d
#Warning malformed mac address error, %{public}s, %{private}s
#availabilityregionmonitor, monitor initialize, country code, %{private}@, token, %{public}d
#availabilityregionmonitor, last, %{private}@, new, %{private}@, token, %{public}d, entered, %{private}d, exited, %{private}d
HeartRate,%f,hr,%f,conf,%f
Steps,%f,pace,%f,cadence,%f,count,%d
ExtendedSteps,%f,firstStepTime,%f,lastStepTime,%f,rawPace,%f,incrementalSteps,%u,odometerSpeed,%f
Odometer,%f,rawSpeed,%f,speed,%f,speedAccuracy,%f,startTime,%f
Elevation,%f,ascended,%d,descended,%d,gradeType,%d,verticalSpeed,%f,startTime,%f,source,%d
WatchPressure,startTime,%f,averagePressure,%f,failureState,%d
Activity,%f,type,%u,standing,%d,angeX,%f,vectorMag,%f,strokeAmp,%f,strokePwr,%f,strokeFreq,%f,machineFreq,%f,pushVectorMag,%f,epochType,%d
Activity2,%f,result,%lu,startTime,%f
Turn,%f,%f,%f,%f
Swim,startTime,%f,strokes,%d,style,%d
ExerciseMinute,%.3f
CyclingState,%.3f,state,%d
Tier1CyclingFeatures,%.3f,isArmConstrained,%d,accelXPowerSum,%f,grav90th_100Hz,%f,cyclingProbability,%f,pedEnergyVertical,%f
iB: ending metric session (BeaconRangingSession) for %s
#Warning Unknown range notification received, %{public}d
iB: Unable to find ranged region,%{private}s.
#Warning Sending kCLConnectionMessageRangingError for region,%{private}s with error,%{public}d.
@iB: Sending kCLConnectionMessageRanging for region,%{private}s, with beacons,%{public}d.
Client %{public}s is attempting ranging as a proxy service to %{public}s
Ranging any region,%{public}s, requires an entitlement.
Unable to parse ranged region,%{public}d.
#Warning Unable to subscribe to ranging.
{"msg%{public}.0s":"client not authorized for ranging; not starting yet", "name":%{public, location:escape_only}s}
Starting ranging for regions,%lu.
iB: start metric session (BeaconRangingSession) for %s
iB: update ranged regions (BeaconRangingSession) for %s
#Warning There are no regions to range.
Stopping ranging.
CL: CLRangingSubscription::onBTLERangeNotification
{"msg%{public}.0s":"CLRangingSubscription::onBTLERangeNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CyclingStateDetector,state,%d,hasGPS,%d,hasStep,%d,hasElevation,%d,hasHR,%d,stepsRaw,%u,stepsQual,%u,gpsSpeed,%f,rawGPSSpeed,%f,hr,%f,hrConf,%f,grade,%f,pedSpeed,%f,wrHrMetDiscordanceStatus,%d,hasTier1,%d,tier1Type,%d,hasStepsQual,%d,cycleState,%d,isArmConstrained,%d,tier1CyclingProbability,%f,accelXPowerSum,%f,grav90th_100Hz,%f,avgWRMets,%f,HRMets,%f,fhr,%f,isDriving,%f,roadNoise,%f,gpsDeltaDistanceState,%d,gpsDeltaDist,%f,verticalSpeed,%f,vehicularAccel,%d,speedBufferLen,%zu,tier1Smooth,%f,pedEnergyVertical,%f
Stationary Cycle, Begin Time, %f, End Time, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, duration(s), %f, weight(kg), %f, METS, %f, HRstaleness, %f
Stationary Cycle, computeTime, %.3f, hrMets, %f, fmMets, %f, userMets, %f, Duration, %f, truthMets, %f
i-index(%{public}d)!=kSize(%{public}d)
OutdoorWheelchair, beginTime, %f, endTime, %f, duration(s), %f,gpsSpeed,%.2f, gpsAvail, %d, elevAvail, %d, pushVM,%.1f, verticalSpeed, %.3f, gradeType, %d, metsFromGps,%.1f, metsFromPushes, %.1f, mets, %.1f
Starting up CLDeviceMotionAWDAggregator
Received compass saturation,%d,timestamp,%f,meanDeltaTimeSaturations,%d
Creating daemon cache for AWD CompassSaturations metric
Loading daemon cache for Compass Saturations AWD metrics
Failed to load cache for AWD metrics %{private}@
Saving daemon cache for CompassSaturations AWD metrics
#Warning daemon cache does not exist!
saturations,%d,meanTimeMsec,%d,intensity,[%d %d],maxQuality,%f,deltaBias,%d,deltaRadius,%d,attachments,%d
Creating daemon cache for AWD MotionGyroDaily metric
Loading daemon cache for MotionGyroDaily AWD metrics
Saving daemon cache for MotionGyroDaily AWD metrics
magnitude,%d,activeMins,%d
New cover attachment,total,%d
Cover open,%d
Keyboard attached,%d
#Warning failed to read [%{public}s]
#Warning, PLOS: can't open file 
#Warning PLOS: endian
#Warning PLOS: sp3file
#Warning PLOS: sp3fileglonass
#Warning PLOS: header
#Warning PLOS_XTRA: header
#Warning PLOS: id
PLOS: eof
#Warning PLOS: id,%{public}d,dataSize,%{public}d
#Warning PLOS: GPS ALM
#Warning PLOS: GLO ALM
PLOS: seting xtra file %{public}s
PLOS: XTRA: fPopulated,%{public}d,fParseError,%{public}d. nothing to do
#Warning XTRA: can't open [%{public}s]
#Warning PLOS: failed to parse [%{public}s]
PLOS:%{public}s
gpsWeek,%{public}d,gpsSec,%{public}d,gloDay,%{public}d,gloSec,%{public}lf
PLOS:svid,%{public}d,el,%{public}.2lf,az,%{public}.2lf,retval,%{public}d
#Warning eof,n,%{public}ld,requested,%{public}ld
ActivityLite not available unable to service request,connection,%s,pid,%d,this,%p
ActivityLite client failed entitlement check,connection,%s,pid,%d,this,%p
Received MotionActivityUpdate request
Received MotionActivityUpdate subscription,%{public}u
CL: CLMotionActivityLiteClient::onMotionActivityNotification
{"msg%{public}.0s":"CLMotionActivityLiteClient::onMotionActivityNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"CLElevationAWDAggregator, time dilation exceeding threshold.", "currentTimeStamp_s":"%{private}.09f", "fLastUpdateTime_s":"%{private}.09f"}
Step counter update time rolled back, previousTime, %{public}f, newTime, %{public}f
{"msg%{public}.0s":"CLElevationAWDAggregator absolute altimetry logging.", "DataTimestamp_s":"%{private}.09f", "fEscalatedSessions":%{private, location:escape_only}s, "fConfirmedSessions":%{private, location:escape_only}s}
{"msg%{public}.0s":"CLElevationAWDAggregator submision cancelled due to insufficient data."}
{"msg%{public}.0s":"CLElevationAWDAggregator logging.", "DataTimestamp_s":"%{private}.09f", "fHasWetWorkout":%{private}hhd, "fNumAscendingFailureEventsPerFailureType":%{private, location:escape_only}s, "fNumDescendingFailureEventsPerFailureType":%{private, location:escape_only}s, "fNumFailuresByType":%{private, location:escape_only}s, "fWetPeriodBins":%{private, location:escape_only}s, "fPressureAmplitudeBins":%{private, location:escape_only}s, "fNumDaysWetInWeek":%{private}d}
CLElevationAWDAggregator user started workout.
Flight segment update time rolled back, previousEndTime, %{public}f, newStartTime, %{public}f
{"msg%{public}.0s":"device orientation update", "fWrist":%{public}d, "fCrown":%{public}d, "combo":%{public}d}
Gyro escalation update time rolled back, previousTime, %{public}f, newTime, %{public}f
{"msg%{public}.0s":"com.apple.Motion.Flights", "ageGroup":%{public}d, "fallDetectionStatus":%{public}d, "gender":%{public}d, "hasStairSpeed":%{public}d, "isAscending":%{public}d, "isGyroOn":%{public}d, "numFlights":%{public}d, "watchOrientation":%{public}d, "workoutGroupType":%{public}d}
{"msg%{public}.0s":"com.apple.Motion.StairSpeed", "ageGroup":%{public}d, "elevationChange":%{public}d, "exceededLengthThreshold":%{public}d, "exceededProbabilityThreshold":%{public}d, "exceededRateThreshold":%{public}d, "fallDetectionStatus":%{public}d, "gender":%{public}d, "hasAtLeast2mElevChange":%{public}d, "hasFlightReported":%{public}d, "isAscending":%{public}d, "isRejected":%{public}d, "isWithinRateLimit":%{public}d, "lengthOfClimb":%{public}d, "probability":%{public}d, "stairSpeed":%{public}d, "stairSpeedMAD":%{public}d, "watchOrientation":%{public}d, "workoutType":%{public}d}
IDSService CLCompanionTransport is nil!
Creating CLCompanionTransport
{"msg%{public}.0s":"updateIDSStatus:", "name":%{private, location:escape_only}s, "isNearby":%{public}hhd, "isDefaultPairedDevice":%{public}hhd, "isConnected":%{public}hhd}
Fitness: Companion model is %s
prevConnectedState,%s,currConnectedState,%s
Sending protobuf ID:%s size: %lu type: %d over IDSService - Status %d, md5 %s
No device locally connected - Ignore sending data
Received message ID:%s, type:%d, size %lu, md5 %s
Unexpected message received while disconnected. Updating status.
Received data over IDSService size : %ld
Received unhandled protobuf ID:%s, size:%lu
Service sent data with ID:%s with success %d error %s
Service data ack on otherside with ID:%s
%s,%f,%s,%f
CLRobustSlopeEstimator given only %zd bins
%s,%f,%s,%d
%s,%f,%s,%f,%s,%f,%s,%f,%s,%d
[CLCompassCalibrationLogger] Last CompassCalibration: bias.x,%.2f,.y,%.2f,.z,%.2f,radius,%.2f,level,%d,quality,%.2f,cost,%.2f,coverage,%.2f,saturations,%d,consistency,%d,apAwake,%d,cftime,%.3f
#SystemState, Device is not activated, suspending activity tracking.
#SystemState, Failed to get TCC for motion, suspending activity tracking.
#SystemState, Companion, Enabled, %{public}d, DeviceActivated, %{public}d
TileMgr, Timer allocation failure, #CloneMe
CL: CLTilesManager::onStoreFrontDidChangeNotification
{"msg%{public}.0s":"CLTilesManager::onStoreFrontDidChangeNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTilesManager::onClientNotification
{"msg%{public}.0s":"CLTilesManager::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTilesManager::onDataProtectionNotification
{"msg%{public}.0s":"CLTilesManager::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTilesManager::onCompanionNotification
{"msg%{public}.0s":"CLTilesManager::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTilesManager::onStatusNotification
{"msg%{public}.0s":"CLTilesManager::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLTilesManager::onLocationNotification
{"msg%{public}.0s":"CLTilesManager::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Session started
Session ended
Run started
transitioning to low power mode: start of lift
transitioning to low power mode: sedentary
Run stopped
last elevation entry not found
last odometer entry not found
End of run stats,startTime,%lf,endTime,%lf,runDistance,%f,runElevationDescent,%f,runAvgSpeed,%f,runMaxSpeed,%f,runSlope,%f
resuming tracking
ElevationBuffer%s
adding ElevationRate, %f
State from, %d, event, %d, to, %d
n and g are too close %f
Assertion failed: lambda2 != 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMOQuaternion.cpp, line 213,invalid weights.
kappa zero!
Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMVector.h, line 277,invalid index %zu >= %zu.
Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMVector.h, line 271,invalid index %zu >= %zu.
Assertion failed: ldx < M*N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 84,invalid element %zu >= %zu.
Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 77,invalid row %zu > %zu.
Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 78,invalid col %zu > %zu.
Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 70,invalid row %zu > %zu.
Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMMatrix.h, line 71,invalid col %zu > %zu.
CLExerciseMinuteController::CLExerciseMinuteController called
CLExerciseMinuteController::feedNatalie called, rawMets, %f
CLExerciseMinuteController::feedBodyMetrics called
ExerciseMinute, adjustedStartTime, %{public}.3f, startTime, %{public}.3f, averageIntensity, %{private}f, awardMode, %{public}d, inWorkoutSession, %{public}d, hasElevationCredit, %{public}d, duplicate, %{public}d
Purging ExerciseMinute, adjustedStartTime, %{public}.3f, startTime, %{public}.3f, averageIntensity, %{private}f, awardMode, %{public}d, inWorkoutSession, %{public}d, hasElevationCredit, %{public}d
Unknown SubHarvester requesting description string
BoutDetector (%{public}s): Received user info (%s)
BoutDetector (%{public}s): bout already in progress (%{public}.2f), cannot start bout at startTime %{public}.2f
BoutDetector (%{public}s): Identified potential walking bout... marking as in progress (start: %{public}.2f)
BoutDetector (%{public}s): Cannot extend bout, no bout in progress
BoutDetector (%{public}s): ExtendingBout,startTime,%{public}.2f,duration,%{public}.2f
BoutDetector (%{public}s): Cannot stop bout, no bout in progress
BoutDetector (%{public}s): zero-length bout (%{public}.2f). Ignoring.
BoutDetector (%{public}s): duration is negative. Time likely rolled back. startTime,%{public}.2f,endTime,%{public}.2f
BoutDetector (%{public}s): exceeded max duration. Should not be possible. startTime,%{private}.3f,endTime,%{private}.3f
BoutDetector (%{public}s): Failed to write new bout %{public}.2f
BoutDetector (%{public}s): Ending bout (%{public}.2f) due to maxTimeSinceEndOfBout from %{public}s time (%{public}.2f)
BoutDetector (%{public}s): Ending bout (%{public}.2f) due to timeRollback time (%{public}.2f)
BoutDetector (%{public}s): Ending bout (%{public}.2f) due to maxBoutDuration (%{public}.2f)
CLSwimAlgSimulator Instantiated
Simulated stroke
Simulated turn
Input is not valid: %{public}s
Only check polygonal fences, %{private}lu
Fence: location, why are you unknown?, %{private}s
getStatusFromLocation, %{private}s, fix, %c%c%c%c%c, isWifiPowered, %{public}d,  effectiveDistance, %{public}.2lf, distance, %{public}.1f, entryRadius, %{private}.1f, exitRadius, %{private}.1f, adjDist, %{private}.1lf, adjHorAcc, %{private}.1lf, origHorAcc, %{public}.1lf
Fence status changed to Inside, distToCenter, %{private}.1lf, %{private}s
Fence status changed to Outside, distToCenter, %{private}.1lf, %{private}s
Fence status remained unchanged, distToCenter, %{private}.1lf, %{private}s
Fence: location treated as new continuous session
Fence: Ignoring location, %{private}s, type, %{public}d, hacc, %{public}.1f, conf, %{public}d, integ, %{public}d, fixCnt, %{private}d, counter, %{private}d
Fence: Accepting location, %{private}s, type, %{public}d, hacc, %{public}.1f, conf, %{public}d, integ, %{public}d, fixCnt, %{private}d, counter, %{private}d
Attempting to calculate distance to an invalid polygon, %{public}lu
Fence: distance to nearest point %{private}.02lf (%{private}d)
{"msg%{public}.0s":"unsupported location type", "type":%{private, location:CLLocationType}lld}
CL: CLDaemonClient(ctor)
{"msg%{public}.0s":"CLDaemonClient(ctor)", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Couldn't get information from PID %{public}u
Failed to become client of CLClientManager
WRTT: overriding burst size to %{public}d
{"msg%{public}.0s":"state transition", "event":%{public, location:escape_only}s, "state":%{public, location:escape_only}s, "id":"%{public}p", "property":%{public, location:escape_only}s, "old":%{public, location:escape_only}s, "new":%{public, location:escape_only}s}
CL: kCLConnectionMessageUnknown
{"msg%{public}.0s":"kCLConnectionMessageUnknown", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Sending,vehicle speed,to client,%{public}s,time,%{public}.3lf,speed,%{private}.3lf
Sending,vehicle heading,to client,%{public}s,time,%{public}.3lf,heading,%{private}.3lf
Got active change notification; updating requests
WRTT: Send PeerRanges, %{public}ld, Errors, %{public}ld
WRTT: send Errors (%{public}lu) to client '%s'
WRTT: processed request processed, isStart,%{public}d, nPeers,%{public}lu
WRTT: send Results (%{public}ld) to client '%s'
WRTT: Sending PeerRanging info to client '%{private}s'
Sent gyro bias estimation message
Received GMM notification %d
Unexpected notification in onPressureBias,notification,%d
'%{public}s' received unknown notification: %{public}d
client authorized; sending out cached message %s
client authorized but no longer interested in cached message %s; discarding cache
#Warning %s is still not authorized for %s, dropping
{"msg%{public}.0s":"Unverified is not a state iOS clients should get into", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
PID %u either doesn't specify UIBackgroundModes, or SB timed out fetching them
client '%s' supports background location
Sending denied error message to %s
{"msg%{public}.0s":"Client not authorized for message", "message":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning Client not interested in this message", "client":%{public, location:escape_only}s, "message":%{public, location:escape_only}s}
#Warning Client '%{public}s' does not have required entitlement '%{public}s' to set effective bundle identifier, '%{public}s', or effective bundle, '%{public}s'
{"msg%{public}.0s":"Client is setting effective bundle path", "NaturalName":%{public, location:escape_only}s, "NewName":%{public, location:escape_only}s, "SystemService":%{public}hhd}
{"msg%{public}.0s":"Failed bundle-path masquerading attempt", "NaturalName":%{public, location:escape_only}s, "NewBundlePath":%{public, location:escape_only}@, "NewLimitingBundleId":%{public, location:escape_only}@}
Client '%{public}s' is setting effective bundle identifier to '%{public}s'
Client '%{public}s' is attempting to masquerade as uninstalled app with effective bundle identifier '%{public}s'
Client '%{public}s' is a plugin, auto-masquerading as its containing app
{"msg%{public}.0s":"#warning Could not find placeholder bundle for client", "client":%{public, location:escape_only}s}
Could not access bundle for masquerading client %{public}s
{"msg%{public}.0s":"WatchKit-Plugin connecting on watch , but companion placeholder bundle not found", "client":%{public, location:escape_only}s}
%{public}s is creating a CLLocationManager, but does not have any NSLocation*UsageDescription keys
{"msg%{public}.0s":"#appclip Removing Always from allowable authorizations", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLDaemonClient registered", "client":%{public, location:escape_only}s, "tag":"%{public}p"}
{"msg%{public}.0s":"a missing client has registered", "client":%{public, location:escape_only}s, "missing":"%{public}f"}
Unentitled entity '%{public}s' trying to tell us they are WatchKit
Setting client, %s, is actually a WatchKit extension, %d
{"msg%{public}.0s":"#usesync Unentitled client claims to be a remote client", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#usesync Setting client proxy for remote client", "client":%{public, location:escape_only}s, "is proxy":%{public}hhd}
{"msg%{public}.0s":"#usesync #warning Received a ProxyForRemoteClient message for a client that failed to register.  Is it uninstalled?", "pid":%{public}d}
Unentitled entity '%{public}s' trying to mark itself as having received location?!
{"msg%{public}.0s":"#Warning, request to mark client as having received location while it is not authorized", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"Marking client as having received location without regard to authorization", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Malformed authorization request", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"WatchKit-1.0 client requesting authorization on companion", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Malformed authorization status", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Not showing temporary precise prompt because the client lacks the required SPI entitlement", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt couldn't get bundle for client", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt System services may not request authorization", "client":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}
{"msg%{public}.0s":"#AuthPrompt Permitting authorization request placed by client entitled to specially request prompts despite being insufficiently in-use", "client":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "inUseLevel":%{public, location:CLClientManager_Type::ClientInUseLevel}lld}
{"msg%{public}.0s":"#AuthPrompt #Warning Delaying authorization request placed while insufficiently in-use", "client":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "inUseLevel":%{public, location:CLClientManager_Type::ClientInUseLevel}lld}
{"msg%{public}.0s":"#AuthPrompt #Warning Dropping authorization request placed while insufficiently in-use", "client":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "inUseLevel":%{public, location:CLClientManager_Type::ClientInUseLevel}lld}
{"msg%{public}.0s":"#AuthPrompt Unrecognized authorization value", "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Authorization value requested by client ignored because not in its allowable mask", "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "client":%{public, location:escape_only}s, "authMaskAllowable":%{public}lu}
{"msg%{public}.0s":"#AuthPrompt Authorization request ignored, at lock-screen", "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Authorization request ignored because another authorization effort is already in flight", "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "existingRequestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "client":%{public, location:escape_only}s, "existingClientKey":%{public, location:escape_only}s, "InflightRequestSquattingDurationSeconds":%{public}ld}
{"msg%{public}.0s":"#AuthPrompt Inflight auth-request squatting for more than 15 mins. TearingDown", "currentClient":%{public, location:escape_only}s, "squattingClient":%{public, location:escape_only}s, "squattingRequestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "InflightRequestSquattingDurationMinutes":"%{public}.2f"}
{"msg%{public}.0s":"#AuthPrompt Ignoring request for temporary precise from app with no authorization yet", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Allowing standard prompt because no auth yet", "ClientKey":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}
{"msg%{public}.0s":"#AuthPrompt Allowing one-shot upgrade attempt", "ClientKey":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "RegistrationResult":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Client is denied.  Asking client manager to consider doing a big switch prompt", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Allowing no-auth-change auth request because this #compensation client wants temporary precise", "ClientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Ignoring authorization request due to existing authorization", "ClientKey":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "RegistrationResult":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AuthPrompt Ignoring special-reprompt authorization request due to existing authorization", "ClientKey":%{public, location:escape_only}s, "requestType":%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, "RegistrationResult":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning Client does not have appropriate entitlement to enable match info", "client":%{public, location:escape_only}s}
Client %s is setting match info enabled to %d
{"msg%{public}.0s":"#Warning Client does not have appropriate entitlement to enable ground altitude", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning Client does not have appropriate entitlement to enable fusion info", "client":%{public, location:escape_only}s}
Client %{public}s does not have appropriate entitlement to change prompt behaviour
Client %s is setting location prompt allowed to %d
Client %s is setting location prompt show to %d
Client %{public}s is registering as a location client and will show up in Settings
{"msg%{public}.0s":"#Warning Client does not have appropriate entitlement to access stored locations", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning Client is not authorized for locations", "client":%{public, location:escape_only}s}
Error checking date parameter
{"msg%{public}.0s":"Request for estimated locations is replied", "client":%{public, location:escape_only}s}
WRTT: client %s does not have appropriate entitlement to access SPI
WRTT: daemon client received request,client,%s,subscribe,%{public}d
WRTT: Incorrect data type for ranging peers
WRTT: Exception while decoding peers
WRTT: peer %{private}#llX, timeout %{puclic}lf, len(keyID) %{private}lu
WRTT: Client '%s' registered for PeerRanging notifications
WRTT: Client '%s' unregistered from PeerRanging notifications
Client %s did not pass entitlement/tcc checks.
Client %s cannot access sensor recorder, invalid target.
#Warning Client %s does not have access to motion activity spi because the platform is not supported
#Warning Client %{public}s does not have appropriate entitlement to access motion activity SPI
Error checking IsVehicle with device address and type!
#Warning Client %{public}s does not have access to vehicular state SPI because the platform is not supported
Cannot find vehicle state proxy
#Warning Client %s does not have access to vehicular state spi because the platform is not supported
CLDaemonClient received GyroBiasEstimation request,client,%{public}s,subscribe,%{public}d
isBuildingGYTT not set
CLDaemonClient got gyro bias estimation subscription request,isBuildingGYTT,%{public}d
CLDaemonClient got gyro bias estimation unsubscription request
Received GMM request,client,%{public}s,subscribe,%{public}d
Recieved pressure bias estimation request.,client,%s,subscribe,%d
Error receiving data from fitness machine
Client %{public}s does not have appropriate entitlement to access catherine provider SPI
#Warning Packet contains nil catherine data
#Warning Client %s does not have appropriate entitlement to run miniCal
#Warning HealthAssessment,Client failed entitlement check, %{public}s, %{public}d, %{public}p
#Warning HealthAssessment,Client failed authorization check, %{public}s, %{public}d, %{public}p
(%f, %f), %d records returned
Allocating mmap buffer.
mmap failure.  errno %d
Did not successfully allocate buffer for sensor recorder.  Returning CMErrorNotAvailable
Requesting id, %llu, meta id, %llu
Client %{public}s does not have appropriate motion entitlement.
#Warning Client %s does not have appropriate entitlement to access vehicle data SPI
Received VehicleSpeed request,client,%s,subscribe,%d
client '%s' subscribing to vehicle speed
client '%s' unsubscribing from vehicle speed
Received VehicleHeading request,client,%s,subscribe,%d
client '%s' subscribing to vehicle heading
client '%s' unsubscribing from vehicle heading
{"msg%{public}.0s":"#Warning Client does not have appropriate entitlement to access MicroLocation SPI", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"Received current MicroLocation request from: ", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"MicroLocations are not available on this platform", "platform":%{public, location:escape_only}s}
{"msg%{public}.0s":"Received Microlocation recording scan request from: ", "client":%{public, location:escape_only}s}
Received request to trigger VO2Max retrocompute
Received request to query VO2Max retrocompute status
Client %s did pass Fall Detection entitlement/tcc checks.
Client %s did not pass Fall Detection entitlement/tcc checks.
Client %{public}s (%{public}p) is %{public}ssubscribing to notification %{public}s
{"msg%{public}.0s":"Allowing process assertion due to foreground-ish status", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"Allowing process assertion due to client manager.", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning Denying process assertion", "client":%{public, location:escape_only}s}
CL: CLDaemonClient::onLocationNotification
{"msg%{public}.0s":"CLDaemonClient::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLDaemonClient::onPeerRangeNotification
{"msg%{public}.0s":"CLDaemonClient::onPeerRangeNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLDaemonClient::onManagerNotification
{"msg%{public}.0s":"CLDaemonClient::onManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
WRTT: No key when retrieving data
{"msg%{public}.0s":"Prepended SIMULATOR_ROOT to bundle path due to being on simulator"}
{"msg%{public}.0s":"CLEligibleMasqueraders for bundle", "EligibleMasqueraders":%{private, location:escape_only}@, "Bundle":%{private, location:escape_only}s}
{"msg%{public}.0s":"Invalid masquerader for bundle", "Bundle":%{public, location:escape_only}s, "Client ProcessPath":%{public, location:escape_only}s, "EligibleMasqueraders for bundle":%{public, location:escape_only}s}
CL: CLDaemonClient::onGmmNotification
{"msg%{public}.0s":"CLDaemonClient::onGmmNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLDaemonClient::onPressureBias
{"msg%{public}.0s":"CLDaemonClient::onPressureBias", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: Incoming message
{"msg%{public}.0s":"Incoming message", "event":%{public, location:escape_only}s, "name":%{public, location:escape_only}s, "this":"%{public}p", "registrationReceived":%{public}hhd}
{"msg%{public}.0s":"Invalid persistent subscription detected... getting a fresh one", "clientKey":%{public, location:escape_only}s, "subscription":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLClientManager should always hand back a non-null, valid subscription pointer", "isNonNull":%{public}hhd, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Creating subscription due to demand", "type":%{public, location:escape_only}s}
{"msg%{public}.0s":"We should never have a nullptr here", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"dynamic_cast must never fail in this context", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CL: LocationManager/kCLConnectionMessageRegistration
{"msg%{public}.0s":"LocationManager/kCLConnectionMessageRegistration", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageAllowsLocationPrompts
{"msg%{public}.0s":"kCLConnectionMessageAllowsLocationPrompts", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageShowLocationPrompt
{"msg%{public}.0s":"kCLConnectionMessageShowLocationPrompt", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessagePurpose
{"msg%{public}.0s":"kCLConnectionMessagePurpose", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageIsActuallyAWatchKitExtension
{"msg%{public}.0s":"kCLConnectionMessageIsActuallyAWatchKitExtension", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageProxyForRemoteClient
{"msg%{public}.0s":"kCLConnectionMessageProxyForRemoteClient", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageRequestAuthorization
{"msg%{public}.0s":"kCLConnectionMessageRequestAuthorization", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageRequestTemporaryPrecise
{"msg%{public}.0s":"kCLConnectionMessageRequestTemporaryPrecise", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageMarkAsHavingReceivedLocation
{"msg%{public}.0s":"kCLConnectionMessageMarkAsHavingReceivedLocation", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageMatchInfoEnabled
{"msg%{public}.0s":"kCLConnectionMessageMatchInfoEnabled", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageGroundAltitudeEnabled
{"msg%{public}.0s":"kCLConnectionMessageGroundAltitudeEnabled", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageFusionInfoEnabled
{"msg%{public}.0s":"kCLConnectionMessageFusionInfoEnabled", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageRegisterAsLocationClient
{"msg%{public}.0s":"kCLConnectionMessageRegisterAsLocationClient", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageFetchEstimatedLocationAtDate
{"msg%{public}.0s":"kCLConnectionMessageFetchEstimatedLocationAtDate", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessagePeerRanging
{"msg%{public}.0s":"kCLConnectionMessagePeerRanging", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicleHeading
{"msg%{public}.0s":"kCLConnectionMessageVehicleHeading", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicleSpeed
{"msg%{public}.0s":"kCLConnectionMessageVehicleSpeed", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageRequestMicroLocation
{"msg%{public}.0s":"kCLConnectionMessageRequestMicroLocation", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageRequestMicroLocationRecordingScan
{"msg%{public}.0s":"kCLConnectionMessageRequestMicroLocationRecordingScan", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageGmm
{"msg%{public}.0s":"kCLConnectionMessageGmm", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessagePressureBias
{"msg%{public}.0s":"kCLConnectionMessagePressureBias", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageGyroBiasEstimation
{"msg%{public}.0s":"kCLConnectionMessageGyroBiasEstimation", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageHasRunMiniCal
{"msg%{public}.0s":"kCLConnectionMessageHasRunMiniCal", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageStartMiniCal
{"msg%{public}.0s":"kCLConnectionMessageStartMiniCal", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSetUrgentCalFlag
{"msg%{public}.0s":"kCLConnectionMessageSetUrgentCalFlag", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageCatherineData
{"msg%{public}.0s":"kCLConnectionMessageCatherineData", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicleConnectionMostRecent
{"msg%{public}.0s":"kCLConnectionMessageVehicleConnectionMostRecent", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicleStateIsAvailable
{"msg%{public}.0s":"kCLConnectionMessageVehicleStateIsAvailable", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicleStateMostRecentVehicleConnection
{"msg%{public}.0s":"kCLConnectionMessageVehicleStateMostRecentVehicleConnection", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicleStateMostRecentInVehicle
{"msg%{public}.0s":"kCLConnectionMessageVehicleStateMostRecentInVehicle", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicleStateIsVehicle
{"msg%{public}.0s":"kCLConnectionMessageVehicleStateIsVehicle", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicularState
{"msg%{public}.0s":"kCLConnectionMessageVehicularState", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVehicularOperatorState
{"msg%{public}.0s":"kCLConnectionMessageVehicularOperatorState", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageHealthAssessmentRecordTypeForDurationKey
{"msg%{public}.0s":"kCLConnectionMessageHealthAssessmentRecordTypeForDurationKey", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageHealthAssessmentParkinsonsResultQuery
{"msg%{public}.0s":"kCLConnectionMessageHealthAssessmentParkinsonsResultQuery", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageMovementDisorderLastProcessedDate
{"msg%{public}.0s":"kCLConnectionMessageMovementDisorderLastProcessedDate", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageMovementDisorderMonitorKinesiasExpirationDate
{"msg%{public}.0s":"kCLConnectionMessageMovementDisorderMonitorKinesiasExpirationDate", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderAuthorized
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderAuthorized", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderSensorAvailable
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderSensorAvailable", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderGetMetaByID
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderGetMetaByID", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderGetMetaSinceID
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderGetMetaSinceID", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderGetMetasByDateRange
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderGetMetasByDateRange", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderGetDataByID
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderGetDataByID", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderRecordFor
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderRecordFor", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderWriteSensorDataToFileByDateRange
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderWriteSensorDataToFileByDateRange", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageSensorRecorderSetSensorSampleRate
{"msg%{public}.0s":"kCLConnectionMessageSensorRecorderSetSensorSampleRate", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageDeviceHasOriginalCamera
{"msg%{public}.0s":"kCLConnectionMessageDeviceHasOriginalCamera", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageCameraVcmActuatorId
{"msg%{public}.0s":"kCLConnectionMessageCameraVcmActuatorId", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageCompassCalibrationData
{"msg%{public}.0s":"kCLConnectionMessageCompassCalibrationData", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageFitnessMachineData
{"msg%{public}.0s":"kCLConnectionMessageFitnessMachineData", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessagePredictedWalkDistanceReset
{"msg%{public}.0s":"kCLConnectionMessagePredictedWalkDistanceReset", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageWriteDbToFile
{"msg%{public}.0s":"kCLConnectionMessageWriteDbToFile", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageTriggerVO2MaxRetrocompute
{"msg%{public}.0s":"kCLConnectionMessageTriggerVO2MaxRetrocompute", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
CL: kCLConnectionMessageVO2MaxRetrocomputeStatusQuery
{"msg%{public}.0s":"kCLConnectionMessageVO2MaxRetrocomputeStatusQuery", "event":%{public, location:escape_only}s, "this":"%{public}p", "registrationRequired":%{public}hhd, "registrationReceived":%{public}hhd}
WRTT: peer without a key
TmmFile, name, path, %s, servername, %s
#BLP attempting to create bundle location provider with NULL bundle path and NULL bundle identifier
#BLP bundle path does not exist, %{public}s
#BLP no application installed backed by bundle identifier, %{public}s
BLP: Need a bundle path or a bundle identifier.
BLP: Couldn't create client for bundle path %{public}s
BLP: Registering with desired accuracy %d (%s)
BLP: Location distance filter is now %.2f (%s)
BLP: Stopping location updates (%s)
#Warning BLP: CLBundleLocationProvider does not support spectators (%s)
BLP: Bystander distance filter is now %.2f (%s)
BLP: Stopping bystander location updates (%s)
@WsbBundle, %{public}s, clients, %{public}ld, numActive, %{public}d
BLP: starting wifi location batch, bundleId, %s
BLP: stopping wifi location batch, bundleId, %s
BLP: starting BystanderPreLoiOverride, bundleId, %s
BLP: stopping BystanderPreLoiOverride, bundleId, %s
#Warning Could not get location from location event (%s)
#Warning BLP: Could not get authorization status (%s)
CLGyroCalibrationDatabase is not available.
Error retrieving LOIs. %{public}@
No LOIs near
Received an LOI notification:longitude,%f,lattitude,%f,
departureDate,%f,arrivalDate,%f,
horizontalAccuracy,%f,confidence,%d
CLFitnessTrackingAllDayAWD: Updating impact cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Updating outdoor cycling cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Updating outdoor walking cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Updating outdoor running cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Updating hiking cancelation reason 0x%llx
CLFitnessTrackingAllDayAWD: Updating other workout cancelation reason 0x%llx
Not supported on this platform because ManagedConfiguration.framework is not present
New app discovery support: %{public}d
setup: can install apps, %d
setup: max age allowed, %u
setup: done registering for leeched location
setup: service not enabled, not registering for leeched location
setup: cannot install apps, not registering for leeched location
location received: not usable, not suggesting
location received: forwarding to controller
fetching, marquees, submitting: %{private}lf, %{private}lf, %{private}lf
fetching: marquees, error, %{private}s
fetching: marquees, success, %{private}lu
fetching: marquees, exiting
fetching: marquees, using cached entries
fetching: lois, submitting: %{private}lf, %{private}lf, %{private}lf
fetching: lois, error, %{private}s
fetching: lois, success, %{private}lu
fetching, lois, exiting
fetching, lois, submitted: %{private}lf, %{private}lf, %{private}lf
fetching, lois, using cached entries
fetching: all done, entered notify handler
decision: fetching error, not suggesting
no fetching, using cached versions
loading key %{private}s GEO network overrides, %{private}d
service disabled via network override
location received: register: type, %{private}d, lat, %{private}lf, long, %{private}lf, %{private}lf
location received: done: type, %{private}d, lat, %{private}lf, long, %{private}lf, %{private}lf
unexpected location notification type received: %{private}d
{"msg%{public}.0s":"Beginning Simulation Service"}
{"msg%{public}.0s":"Do we have a listener?", "listtner":%{public, location:escape_only}@}
{"msg%{public}.0s":"received daemon-side update for isInEmegency", "isEmergencyState":%{public}hhd}
{"msg%{public}.0s":"received daemon-side request to stop location simulation"}
{"msg%{public}.0s":"received daemon-side request to start location simulation"}
{"msg%{public}.0s":"Reveived daemon-side request to append simulated location"}
{"msg%{public}.0s":"Should accept incoming connection?"}
{"msg%{public}.0s":"Using simulated location from defaults", "location":%{private, location:CLClientLocation}.*P}
SimulationController,InterpretLifeSpanAsCourseAccuracyInSimulation,%{public}d
{"msg%{public}.0s":"Attempt to start scenario, but no scenario is loaded!"}
{"msg%{public}.0s":"Failed to read simulation from url", "scenarioURL":%{public, location:escape_only}@}
{"msg%{public}.0s":"Couldn't parse simulation scenario data"}
{"msg%{public}.0s":"Couldn't get locations array for simulation scenario"}
{"msg%{public}.0s":"Applying new simulation scenario", "locationCount":%{public}ld, "scenarioURL":%{public, location:escape_only}@}
{"msg%{public}.0s":"location from scenario is of incorrect format", "locationIndex":%{public}d, "scenarioURL":%{public, location:escape_only}@}
{"msg%{public}.0s":"location from scenario is of incorrect format", "locationIndex":%{public}d, "incorrectType":%{public, location:escape_only}s, "scenarioURL":%{public, location:escape_only}@}
{"msg%{public}.0s":"Appending location", "location":%{private, location:CLClientLocation}.*P}
{"msg%{public}.0s":"Setting SimulationController property", "locationInterval":"%{public}f"}
{"msg%{public}.0s":"Setting SimulationController property", "locationTravellingSpeed":"%{public}f"}
{"msg%{public}.0s":"Setting SimulationController property", "intermediateDistance":"%{public}f"}
{"msg%{public}.0s":"next location", "location":%{private, location:CLClientLocation}.*P}
{"msg%{public}.0s":"Simulation start request received"}
{"msg%{public}.0s":"Simulation stop request received"}
{"msg%{public}.0s":"Setting SimulationController property", "locationDeliveryBehavior":%{public, location:CLSimulationLocationDeliveryBehavior}lld}
{"msg%{public}.0s":"Setting SimulationController property", "locationRepeatBehavior":%{public, location:CLSimulationLocationRepeatBehavior}lld}
{"msg%{public}.0s":"Setting SimulationController property", "intermediateLocationDistance":"%{public}f"}
{"msg%{public}.0s":"Setting SimulationController property", "locationInterval_s":"%{public}.09f"}
{"msg%{public}.0s":"Travelling speed changed", "travellingSpeed":"%{public}f"}
{"msg%{public}.0s":"#slv Simulating a visit event"}
{"msg%{public}.0s":"#slc Simulating an SLC event", "location":%{public, location:escape_only}s}
{"msg%{public}.0s":"Returning fences for bundleID", "bundleID":%{public, location:escape_only}s}
{"msg%{public}.0s":"Simulating a fence entry/exit for fence", "bundleID":%{public, location:escape_only}s, "fenceID":%{public, location:escape_only}s}
{"msg%{public}.0s":"Simulating beacon region entry/exit.", "proximityUUID: ":%{public, location:escape_only}s, "major: ":%{public}d, "minor: ":%{public}d}
{"msg%{public}.0s":"Clearing all pending locations and settings"}
{"msg%{public}.0s":"Preparing next location"}
{"msg%{public}.0s":"No more pending locations"}
{"msg%{public}.0s":"Dealing with no more locations", "repeatBehavior":%{public, location:CLSimulationLocationRepeatBehavior}lld}
{"msg%{public}.0s":"Sending appropriate location unavailable notification"}
{"msg%{public}.0s":"SimulationController is trying to sendNextLocation, but simulation is not running"}
{"msg%{public}.0s":"Nowhere to go; not preparing next location"}
{"msg%{public}.0s":"Adjust next location timestamp", "originalTimestamp_s":"%{public}.09f", "delta_s":"%{public}.09f"}
{"msg%{public}.0s":"snl", "speed":"%{public}f", "timeElapsed_s":"%{public}.09f", "distance":"%{public}f", "currentLocation":%{public, location:CLDaemonLocation}.*P, "nextLocation":%{public, location:CLDaemonLocation}.*P}
{"msg%{public}.0s":"Reached location, preparing next", "reachedLat":"%{public}f", "reachedLon":"%{public}f"}
{"msg%{public}.0s":"Notify location is", "location":%{private, location:CLClientLocation}.*P}
{"msg%{public}.0s":"Notification delay", "notificationDelay_s":"%{public}.09f"}
@ClxSimulated, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, course, -1.0, time, %{public}.1f
Considering location type for location delivery
CLGnssProvider will be use as location provider
{"msg%{public}.0s":"No location provider found. Defaulting to SimulatedLocationProvider"}
#CLEEA Releasing EmergencyEnablementAssertion on behalf of %{public}s with reason %{public}s
CL: EmergencyEnablementAssertion/kCLConnectionMessage
{"msg%{public}.0s":"EmergencyEnablementAssertion/kCLConnectionMessage", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#warning EmergencyEnablementAssertion already taken by %{public}s
#warning #CLEEA Not entitled as emergency enabler... ignoring EmergencyEnablementAssertion taken by %{public}s
#CLEEA EmergencyEnablementAssertion taken by %{public}s malformed: lacking required argument(s)
#CLEEA Assertion requested with no reason... ignoring EmergencyEnablementAssertion taken by %{public}s
{"msg%{public}.0s":"Ignoring #CLEEA Assertion requested without explicit beneficiary", "RequestedBy":%{public, location:escape_only}s, "Reason":%{public, location:escape_only}s}
#CLEEA Taking EmergencyEnablementAssertion on behalf of %{public}s with reason %{public}s
Timer fired on companion,currentMotionCalsVersion,%d
Phone converted RawSpeedToKValueTable to StrideCalibrationBins to comply with Watch (Major:%d Minor:%d).
Companion sent calibrations to watch: %s
Device is now unlocked.
Clearing a stale vo2max of 0 value.
Loaded Motion Cals from backup: fMotionCals, %s, current version, %d
No motion cal backup file was found at path: %s. Restore PAL.
restoring backup motion cals
quickswitch protocol %d
PAL is updated from %f to %f
PAL not loaded or changed.
Restore & Arbitrate
processing motion cals received from watch
arbitration
restore pal
Loaded Motion Cals from PAL: fMotionCals, %s, current version, %d.
Asked to persist Motion Cals, current version, %d, isDeviceCurrentlyUnlocked, %d
Companion did not persist Motion Cals, waiting until next unlock, current version, %d, isDeviceCurrentlyUnlocked, %d
Companion persisted calibrations to disk, fMotionCals = %s
Companion received calibrations from watch: %s
clearing motion calibrations
#Warning Failed to retreive default raw speed to kValue bins.
#Warning Failed to retreive default step cadence to stride length bins.
Buffered: version, %d, UDID, %s, timestamp, %lf, Current: version, %d, UDID, %s, timestamp, %lf, result, %d
Scheduled send to watch.
CL: CLMotionSyncStoreCompanion::onPalUpdateNotification
{"msg%{public}.0s":"CLMotionSyncStoreCompanion::onPalUpdateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionSyncStoreCompanion::onCompanionNotification
{"msg%{public}.0s":"CLMotionSyncStoreCompanion::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Warning Step count went backwards (%u -> %u). locationd starting? Motion Co-processor reboot?
startTime,%f,timestamp,%f,firstStepTime,%f,lastStepTime,%f,stepsDelta,%u,calibratedDistanceDelta,%f,calibratedPace,%f,rawStrideLength,%f,activeTimeDelta,%f,rawPaceCurrent,%f,rawPaceActive,%f,rawPaceDidJump,%d,stepCadenceCurrent,%f,stepCadenceActive,%f,kValue,%f,pedometerArmConstrainedState,%d,strideLengthFromStepCadence,%f,useStrideLengthFromStepCadence,%d,pushCount,%u,falseStepsSuppressed,%d
rotBufferSize9, %zu, accelBufferSize, %zuu, peakCount, %d, compassBufferSize, %zu
gyroDt9, %.4f, doAccelCheck, %d
fAccelBuffer,size,%zu
omegaMag9, %.3f, omega, %.3f, %.3f, %.3f
[AppleQuaternion9] x,%f,y,%f,z,%f,w,%f,timestamp,%f
[Accelerometer9] x,%f,y,%f,z,%f,timestamp,%lf
[RotationRate9] %.3f, %.3f, %.3f, %.3f
[KalmanFilterStates9] %f,%f,%f,%f,%f,%f,%f
[KalmanFilterStates9-AccelUpdate] %f,%f,%f,%f,%f,%f,%f
[CompassIntoKF] timestamp,%f,calibration level %d, compassHasAlignedToStableField %d, useMagneticRefX %d
[CompassIntoKF] fLastAccelTime,%f
[CompassIntoKF] magneticFieldAdjusted!
rotAroundGrav, %.3f, sum, %.3f
[CompassIntoKF] omegaMag, %.3f, omegaVar, %.3f
FieldDiff, %.3f, %.3f, %.3f, %.3f
Aborted yawUpdate.
Checking again for magField. checkcount, %d
fCorrected, %.3f, %.3f, %.3f
[!!!CompassInertialReference] x,%f,y,%f,z,%f,calibrationLevel,%d,timestamp,%lf
Warning: Compass outputs field magnitude 0.
[!!!CompassInertialReference] x,%f,y,%f,z,%f
UpdatingYaw!
[Magnetometer9] x,%f,y,%f,z,%f,timestamp,%lf
Warning: Hey! Compass outputs field magnitude 0.
[ExpectedCompass] %f,%f,%f,%f
[TrueCompass] %f,%f,%f,%d,%f
[MagCCross] %f,%f,%f,%f,%f,%f,%f,%f,%f,%f
[MagCorrectionDX] %f,%f,%f,angle,%.3f,sumRot,%.3f,%f
CLMotionCoprocessorInterface supported but not created.
@WifiAps, lookiter, %{private}s, %{private}.7f, %{private}.7f, hacc, %{public}1.f, reach, %{public}d, altitude, %{private}.1f, vacc, %{public}.1f
@WifiAps, lookiter, %{private}s, %{public}s
WlpMetric, aplookup, %{public}d, %{public}d, sources, %{public}s, als, %{public}d, tiles, %{public}d, invalid, %{public}d, unknown, %{public}d
{"msg%{public}.0s":"#CLIUA Required parameter missing", "logic":%{public}hhd, "clientKey":%{public, location:escape_only}s, "reason":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#CLIUA Unexpected app monitor notification", "notification":%{public}d}
{"msg%{public}.0s":"#CLIUA Records should not be stored unless they have active assertions", "key":%{public, location:escape_only}s, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#CLIUA Inconsistent state detected.  An unknown decay timer fired!", "clientKey":%{public, location:escape_only}s, "originalReason":%{public, location:escape_only}s}
{"msg%{public}.0s":"#CLIUA Invalid assertion level", "assertionLevel":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"#CLIUA Marking change", "clientKey":%{public, location:escape_only}s, "reason":%{public, location:escape_only}s, "assertionLevel":%{public}d, "coming":%{public}hhd}
{"msg%{public}.0s":"#CLIUA Over-release detected", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning,KF:invalid update,null island
#Warning,KF:invalid update,hunc<=0
KF:Attempting update,type,%{public}d,lat,%{private}.7f,lon,%{private}.7f,hunc,%{public}.1f,alt,%{private}.3f,vunc,%{public}.3f,conf,%{public}d
KF:Single AP,Dual input rejection,lat,%{private}.7f,lon,%{private}.7f
KF:input should not be rejected after a hard reset
KF:Dual rejection,type,%{public}d,lat,%{private}.7f,lon,%{private}.7f,blunder detected
#Warning,KF:longTermStatic should not fail if longTermNormal succeeded
KF:Dual,%{public}.3f,%{public}d,%{public}d,%{public}d,%{private}.7f,%{private}.8f,%{private}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}s
KF:calcTPTQ failed
KF:boundLatitude failed
KF:boundLongitude failed
KF:updateMotion failed unexpectedly
KF:calc_dNdE failed
KF:Prediction failed
KF:re-init,uncertainty growth>%{public}.0lf
KF:ZUPT failed
KF:ZUPT innovation update failed
KF:P is not dimensioned
KF:x is not dimensioned
KF:too many consecutive update rejections,KF reset
KF:update with same cell location ignored
KF:re-init,dT>%{public}.0lf
KF:non-GPS within %{public}.1f of GPS,ignoring.
KF:diverged compared to med/high conf WiFi,resetting
KF:Transition,coarse GPS to WiFi,hunc bumped,%{public}.1f
KF:diverged,%{public}.3lf,reseeding,inputType,%{public}d,lat,v2,%{public}.1lf
KF:reseed,type,%{public}d,%{private}.7lf,%{private}.7lf,%{private}.3lf,hunc,%{public}.1lf,vunc,%{public}.1lf,conf,%{public}d
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,lat,v2,%{public}.1lf
KF:Input is not consistent with prior input. Filter reseeding.
KF:lat innovation update failed
KF:increment num rejections by half
KF:diverged,%{public}.3lf,reseeding,inputType,%{public}d,lon,v2,%{public}.1lf
KF:seedTheFilter failed
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,lon,v2,%{public}.1lf
KF:Input is not consistent with prior input,filter reseeding
KF:lon innovation update failed
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,vn,v2,%{public}.1lf
KF:vn innovation update failed
KF:computePht_and_hPht failed
KF:sigma2_v <= 0
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,ve,v2,%{public}.1lf
KF:ve innovation update failed
KF:updateP failed
KF:sanityTestP failed
KF:Not applying the uncertainty floor
KF:lt%{public}c,%{public}.3lf,inputType,%{public}d,alt,v2,%.1lf
KF:getResult failed
KF:Filter corrobarated by type,rejects now allowed
KF:Filter corrobarated by position,rejects now allowed
KF:rejected cell and wifi locations are consistent,filter should reset
KF:rejected cell and coarse-gps locations are consistent,filter should reset
KF:rejected wifi and coarse-gps locations are consistent,filter should reset
KF:diagonal element of P < 0
KF:dN == 0
KF:x is not dimensioned, innovation not applied
KF:k is not dimensioned, innovation not applied
KF:latRads,%{private}.7f,out of bounds
KF:lonRads,%{private}.7f,out of bounds
KF:seedTheFilter,hunc<=0
KF:init P failed
#Warning,KF:Pht is not dimensioned
KF:h_index exceeds bounds
#Warning,KF:P is not dimensioned
KF:k is not dimensioned
KF:initP,hunc <= 0
KF:initP,speedUnc <= 0
#Warning,P was not dimensioned
KF:tuning invalid
#Warning,KF:Q was not dimensioned
KF:tuning invalid, beta == 0
KF:fKalman.dN == 0.0 || fKalman.dE == 0.0
KF:dT < 0
#Warning,Q is not dimensioned
KF:beta is zero
KF:setQ failed
#Warning,KF:P is not symmetric
{"msg%{public}.0s":"Assertion failed - unsupported location type", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
%%1:KF:,2:lts-or-ltn,3:timestamp(s),4:inType,5:outType,6:motionState,7:latitude(deg),8:longitude(deg),9:altitude(m),10:speed(km/hr),11:course(deg),12:hunc(m),13:vunc(m),14:sunc(m/s),15:cunc(deg),16:v_standardized^2
KF:,lt%{public}c,%{public}.3f,%{public}d,%{public}d,%{public}d,%{private}.7f,%{private}.7f,%{private}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}.1f,%{public}s
BoutExtractor: Received user info (%s)
GaitMetrics,startTime,%{public}.2f,timestamp,%{public}llu,walkingSpeed,%{private}.3f,doubleSupportPercentage,%{private}.3f,stepLength,%{private}.3f,asymmetryProbability,%{private}.3f,deviceSide,%{private}hhu,cycleTime,%{private}.3f
GaitMetrics::segmentsRejected,startTime,%{public}.2f,isSwingStanceCycle,%{private}hhu,isNotRunning,%{private}hhu,isFeasibleWalkingSpeed,%{private}hhu,isPendular,%{private}hhu,isSufficientVerticalTwist,%{private}hhu,isCadenceConcordant,%{private}hhu,userHeight,%{private}.2f,isHeightSet,%{public}d,userWeight,%{private}.2f,isWeightSet,%{public}d,
BoutExtractor: Received workout override
BoutExtractor: Unable to get time range to process
BoutExtractor: No bouts in db
Currently in workout predictedType %{public}u activityType %{public}u since (%{public}.2f)
BoutExtractor: All bouts deferred
BoutExtractor: Returned time range to process (%{public}.2f) to (%{public}.2f)
BoutExtractor: Checking for bouts from %{public}.2f to %{public}.2f
BoutExtractor: Deferring bout processing. Bouts unavailable.
BoutExtractor: No bouts found.
BoutExtractor: Defering bout processing. Gait Metrics unavailable, likely because device is locked.
BoutExtractor: Defering processing bout (%{public}.2f). Pedometer unavailable.
CLMobility::BoutMetrics,startTime,%{public}.2f,endTime,%{public}.2f,stepCount,%{public}u,walkingSpeed,%{private}.2f,walkingSpeedIsValid,%{public}d,doubleSupportPercentage,%{private}.1f,doubleSupportPercentageIsValid,%{public}d,stepLength,%{private}.2f,stepLengthIsValid,%{public}d,asymmetryProbabilityPercentage,%{private}.0f,asymmetryProbabilityPercentageIsValid,%{public}d,invalidGradePct,%{public}.2f,numGaitMetrics,%{public}d,deviceSide,%{private}s,userHeight,%{private}.2f,isHeightSet,%{private}d,userWeight,%{private}.2f,isWeightSet,%{private}d
BoutExtractor: Evaluating Bout -- startTime,%{public}.2f,endTime,%{public}.2f,numberOfGaitMetrics,%{public}lu,numberOfStepCountEntries,%{public}lu
User setting changed mid bout... very weird
User body metric setting changed mid bout from userHeight,%{private}.2f, userWeight,%{private}.2f to userHeight,%{private}.2f, userWeight,%{private}.2f
BoutExtractor: Discarding bout (%{public}.2f) due to insufficient steps: %u
BoutExtractor: Discarding bout (%{public}.2f) due to too much invalid grade. invalidGradePct,%{public}.2f%%,gradeAvailability,%{public}.2f%%
BoutExtractor: Discarding bout (%{public}.2f) due to ineligible workout type: %u
#warning One or more of GaitMetrics rejection counters hit capacity, Bout (%{public}.2f) segment rejection will undercount
BoutExtractor: Discarding %s due to no gait metrics
Unexpected CLMobility::QuantityTypeIdentifier %d
BoutExtractor: Discarding %s due to insufficient gait metrics (%{public}lu/%{public}d)
BoutExtractor: Discarding (%{public}s) due to insufficient gait metrics yield: %{public}.4f
BoutExtractor: Error, unsorted bouts.
BoutExtractor: Error, unsorted workouts.
Bout DeviceSide: %s (left=%.4f, right=%.4f)
Does not meet minimum number of samples criteria for Poincare, size: %lu
Does not meet minimum number of samples criteria for Entropy, size: %lu
BoutDetector (%{public}s): Initializing StepCountEntry %{public}.2f
BoutExtractor: Received StepCountEntry -- startTime,%.2f,deltaSteps,%d
BoutDetector (%{public}s): Step count rolled back. boutInProgress, %{public}d, curStepCount, %{private}u, prevStepCount, %{private}u, curStepTime, %{public}.2f, prevStepTime, %{public}.2f
BoutDetector (%{public}s): Active time rolled back. boutInProgress, %{public}d, curActiveTime, %{private}.2f, prevActiveTime, %{private}.2f, curStepTime, %{public}.2f, prevStepTime, %{public}.2f
BoutDetector(%{public}s): #warning, invalid firstStepTime (%{public}.2f)) at start of bout (%{public}.2f)). timestamp=%{public}.2f
BoutDetector(%{public}s): #warning, lastStepTime (%{public}.2f) exceeds startTime (%{public}.2f)). {timestamp=%{public}.2f, activeTime=%{public}.2f, prevStartTime=%{public}.2f}, prevTimestamp=%{public}.2f}, prevActiveTime=%{public}.2f}
{"msg%{public}.0s":"Pedometer Calibration Table Empty After Initialization", "tableName":%{private, location:escape_only}s}
binIndex %{public}lu invalid
%s,Updated,With,%s,%0.4f,%s,%0.4f,Alpha,%0.4f,NativeBinIndex,%lu,OldBinStatus,%s,NewBinStatus,%s
#dsa client '%{public}s' starts receiving CLPlaceInferenceSubscription updates
{"msg%{public}.0s":"#dsa client is authorized only for coarse", "Client":%{public, location:escape_only}s}
#dsa Please update initializePlaceInferencesOptions
#dsa RECEIVED RESPONSE in handler %{public}lu mapItems, error: %{public}@ in startFetchingRTPlaceInferencesWithOptions
{"msg%{public}.0s":"Woah!  Place inference results are available on macOS?!  Time to remove that fallback logic!"}
#dsa mecard returned error %@
#dsa %{private}@ address is %{public}.2f away from current location 
#dsa adding mecard address %{private}@,deviation,%{public}.2f
#dsa no valid address in contacts.skip sending dsa %lu
#dsa address type in mecard is %@, %{private}@, %@{private}
#dsa geocode returned error %@
#dsa fetchformattedaddress returned error %@
#dsa meCardAddress  %{private}@
#dsa fetchformattedaddress received %{private}@, updated address in placemark  %{private}@, address in mecard %{private}@
#dsa mecard geodetic location,lat,%{private}.7f,lon,%{private}.7f,currentlat,%{private}.7f,currentlon,%{private}.7f,distance,%{public}.2f
{"msg%{public}.0s":"#dsa userType", "userType":%{public}d}
#dsa invalid usertype and sourcetype, confidence,%{public}.2f,last confidence,%{public}.2f,loisource,%{public}@,userType,%d
#dsa invalid hunc, confidence,%{public}.2f,last confidence,%{public}.2f,loisource,%{public}@,userType,%d
#dsa invalid confidence, confidence,%{public}.2f,last confidence,%{public}.2f,loisource,%{public}@,userType,%d
#dsa zone of confusion,dropping dsa,current confidence,%{public}.2f,last confidence,%{public}.2f,confidenceinpercent,%{public}.2f,loisource,%{public}@,userType,%d
#dsa mapitem's geodetic location ,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f, currentlat,%{private}.7f,currentlon,%{private}.7f,currentacc,%{public}.2f,dist,%{public}.2f, currconf,%{public}.2f,loisource,%{public}@
{"msg%{public}.0s":"#dsa,received infered place address from coreroutine", "name":%{private, location:escape_only}s, "thoroughfare":%{private, location:escape_only}s, "subThoroughfare":%{private, location:escape_only}s, "locality":%{private, location:escape_only}s, "subLocality":%{private, location:escape_only}s, "administrativeArea":%{private, location:escape_only}s, "subAdministrativeArea":%{private, location:escape_only}s, "postalCode":%{private, location:escape_only}s, "ISOcountryCode":%{private, location:escape_only}s, "country":%{private, location:escape_only}s, "inlandWater":%{private, location:escape_only}s, "ocean":%{private, location:escape_only}s}
#dsa updated mapItem after cross-check ,maplat,%{private}.7f,maplon,%{private}.7f,updatedacc,%{public}.2f,origacc,%{public}.2f, usertype,%{public}d, placeType,%{public}d,inferredconf,%{public}.2f
{"msg%{public}.0s":"#dsa,sending infered place address to client", "name":%{private, location:escape_only}s, "thoroughfare":%{private, location:escape_only}s, "subThoroughfare":%{private, location:escape_only}s, "locality":%{private, location:escape_only}s, "subLocality":%{private, location:escape_only}s, "administrativeArea":%{private, location:escape_only}s, "subAdministrativeArea":%{private, location:escape_only}s, "postalCode":%{private, location:escape_only}s, "ISOcountryCode":%{private, location:escape_only}s, "country":%{private, location:escape_only}s, "inlandWater":%{private, location:escape_only}s, "ocean":%{private, location:escape_only}s}
#dsa did not meet the emergecy confidence and distance requirement,distance,%{public}.2f,confidence,%{public}.2f
{"msg%{public}.0s":"#dsa confidence do not meet the emergency case requirement", "userType":%{public}d, "userTypeSource":%{public, location:escape_only}@, "hunc":%{public}d, "confidence":%{public}d, "lastconfidence":%{public}d}
{"msg%{public}.0s":"#dsa Trying to send a result while the request is stopped"}
{"msg%{public}.0s":"#dsa Couldn't convert location notification to accuracy", "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"#dsa client stopped PlaceInference Request", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#dsa Already running a place inference request, but asked to start again"}
{"msg%{public}.0s":"#dsa Client does not have appropriate entitlement to get place inference", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#dsa Place inference request is missing required field: fidelityPolicy"}
#dsa client '%{public}s' not authorized for location; not starting yet in handleRequestPlaceInference
#dsa client '%{public}s' not authorized for Emergency Fidelity policy
#dsa client '%{public}s %{public}s'; stopping place inference location and wifi scans
#dsa received unhandled notification %{public, location:CLLocationProvider_Type::Notification}d In onLocationNotification
#dsa empty accessPoints, %{pubic}s
#dsa received unhandled notification %{public, CLWifiService_Type::Notification}d In onWifiServiceNotification
CL: CLPlaceInferenceSubscription::onLocationNotification
{"msg%{public}.0s":"CLPlaceInferenceSubscription::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLPlaceInferenceSubscription::onWifiServiceNotification
{"msg%{public}.0s":"CLPlaceInferenceSubscription::onWifiServiceNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#dsa Please update userSpecificPlaceTypeFromRTUserType
#dsa Please update placeInferencePlaceTypeFromRTPlaceType
MotionStateObserver, Disabling update timer.
MotionStateObserver, Sending session update, user type, %d, predicted type, %d
MotionStateObserver,RemoteState,startTime,%.3f,activityType,%d,vehicularConfidence,%d
CL: CLMotionStateObserverWatch::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLMotionStateObserverWatch::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Starting pressure calibration, user initiated, %d
Pressure dispatcher was expected to be null.
temperatureOffsetCoefficient,%f,medianAbsoluteDeviation,%f,minTemp,%d,maxTemp,%d,valid,%d
Stopped pressure calibration
SQL error: %s
Cannot get SPPO property
data not long enough to get version properly
SPPO version (%u) does not match expected versions (%u, %u)
factory calibrated temperature from syscfg: %f
Warning: factory calibrated temperature (%f) is not within acceptable bounds: [%f, %f], using default: %f
Warning: using default factory calibrated temperature: %f
size of tco list (%lu) is less than minimum (%d) required for median computation
pressure,%f,temperature,%f,timestamp,%f
supervised capability changed from, %d, to, %d
iCloud managed apple ID capability changed from, %d, to, %d
installed education profile capability changed from, %d, to, %d
iTunes managed apple ID capability changed from, %d, to, %d
received unhandled notification, %{public}d
proceed #alsquery eval due to 5GHz scan, since_last_query_secs, %d
blocking #alsquery, too soon, since_last_query_secs, %d
#alsquery number of aps in scan history, %lu
#alsquery, do_query, %d, reason, %s
@WifiFlow, alsrequest, %{public}d, %{public}s, aps, %{public}lu, type, %{public}d, vni, %{public}ld, %{public}ld, %{public}ld
#alsquery, create_request, %lu, use_cache, %d, query_nearbys, %d, config, %{public}s
WsbAls, query, %{public}d, %{public}s, unknown, %{public}ld
registered for kNotificationContext
registered for kNotificationContextSpectator
CLMM,MapMatchingGeometryType,%{public}s
CLMM, PlatformSupportsMapMatching, %{public}d
OBM,fPlatformSupportsOutdoorMatching,%{public}d
CLMM, EnableNMEAMapMatching, %{public}d
CLMM, EnableVerboseMapMatching, %{public}d
PLOS, ObmVerboseLogging, %{public}d
CLMM, MapMatchingNetworkUsageThermalLevelHighThreshold, %{public}d
CLMM, MapMatchingNetworkUsageThermalLevelLowThreshold, %{public}d
DEM,GroundAltitudeLookUpEnabled,%{public}d
Raven,%.2lf,Client location horizontal unc modified from,%.2lf,to,%.2lf
CLMM,RouteHints,CLLocationFilterController,setMapMatchingRouteHint, %{public}d
#Warning unexpected kNotificationMovementCoarse
Unhandled case
Going to sleep. Not providing motion state, %{public}d, to the location KF
CLMM, MotionState,type,%{public}d,confidence,%{public}d,mountedState,%{public}d,mountedConfidence,%{public}d
OBM, MotionState,type,%{public}d,confidence,%{public}d,mountedState,%{public}d,mountedConfidence,%{public}d
#Warning Unknown notification %{public}d
device entering sleep - no longer has active cell
device wake - checking for corresponding sleep
#Warning wake detected with no prior sleep known, sending unknown motion to location KF at time, %{public}.3lf
CLMM,Battery notification,level,%{public}.2lf,charged,%{public}d,connected,%{public}d,wasConnected,%{public}d
priorSignalEnvironment,%{public}d,newSignalEnvironment,%{public}d,fidelity,%{public}d
CLMM,isAirborne,%{public}d
CLMM,onMapMatcherStopped,timer triggered
CLMM,onMapMatcherStopped,road tiles cleared from process memory
CL: CLLocationFilterController::onMotionNotification
{"msg%{public}.0s":"CLLocationFilterController::onMotionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationFilterController::onDaemonStatusNotification
{"msg%{public}.0s":"CLLocationFilterController::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationFilterController::onSignalEnvironmentNotification
{"msg%{public}.0s":"CLLocationFilterController::onSignalEnvironmentNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
FenceCal: init globals
FenceCal: Overriding WifiFenceCalculatorDebug =%d
FenceCal: Overriding WifiFenceCalculatorDebugVerbose =%d
FenceCal: Overriding WifiFenceCalculatorMinNumAPs =%d
FenceCal: Overriding WifiFenceCalculatorSTDFactorMeters = %5.1lf
FenceCal: Overriding WifiFenceCalculatorRadiusFactor = %5.1lf
FenceCal: Overriding WifiFenceCalculatorMaxFenceRadius = %5.1lf
FenceCal: Overriding WifiFenceCalculatorMaxChosenAPs = %d
FenceCal: Overriding WifiFenceCalculatorMaxApsPerTileFactor = %lf
FenceCal: Overriding WifiFenceCalculatorSignificantScoreUpdateThresh = %lf
FenceCal: Overriding WifiFenceCalculatorGroupWeightForExit = %d
FenceCal: Overriding WifiFenceCalculatorMinApsPerFence = %d
FenceCal: Overriding WifiFenceCalculatorDefaultMaxChannelSetSize = %d
FenceCal: Overriding WifiFenceCalculatorDefaultChannelFilter = %d
FenceCal: Overriding WifiFenceCalculatorAPsScoreFilter = %d
FenceCal: fMaxChannelSetSize, %{private}d, kMaxChannel, %{private}d, fChannelFilter, 0x%{private}X, fDefaultChannelFilter, 0x%{private}X
bad CLStandardNormalDistribution(%{public}lf) = %{public}lf
FenceCal: Adding score, fence, %{private}20s, score, %{private}.8lf, min, %{private}.8lf, avg, %{private}.8lf, max, %{private}.8lf, scores, %{private}lu, aps, %{private}zu
#Warning fChosenAPs is empty
FenceCal: start calculate fence, %{private}-24s, C, center, %{private}.8lf, %{private}.8lf, radius, %{private}.8lf, isMonitorForExit, %{private}d
FenceCal: really bad fence, %{private}s
FenceCal: limit ePNO fence size, fence, %{private}s, fMaxRadius, %{private}.1lf
Invalid fence name, %{private}s, latitude, %{private}lf, longitude, %{private}lf, radius, %{private}lf
FenceCal: tile, y, %d, x, %d, index, %d, distanceFromCenter, %5.5lf, maxApsPerTile, %d, ApsFactor, %.5lf
FenceCal: fetched, %{public}ld, APs, forceFetchingExpectedAps, %{public}d
FenceCal: expectedAp, %{private}s
{"msg%{public}.0s":"FenceCal: Where did you come from", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
FenceCal: ap2Tile, %s, maxApsPerTile, %2d, left, %4d, top, %4d, tile, %4d, mac, %-24s, numAPs %4zu
FenceCal: chosen, %{private}lu, expected, %{private}lu, fence, %{private}s
FenceCal: calTile, %2zu : %3d / %3zu, %.8lf, %.8lf, FF0000FF
FenceCal: avoid adding moving AP as an exit AP, %{private}s
FenceCal: adding non-2GHz, reason: %{private}s, %{private}s
FenceCal: Adding AP, reason, %s, channelFilter, 0x%08x, isExit, %d, currentCount, %zu, apsBudget, %u , mac, %s, hAcc, %.2lf, channel, %d, location, %12.8lf, %12.8lf, added, %d
FenceCal: isAddChannel, %d, maxChannelSetSize, %d, totalAps, %.0lf, channelHistogram, sorted, channel, %2d, weight, %.3lf
FenceCal: addedChannels, %{private}d, channelFilter, 0x%{private}08x, totalWeight, %{private}.3lf
FenceCal: calculateGroup, start, group size, %zu, apsBudget, %u, currentlySeen, %zu, minScoreThresh, %.4lf
FenceCal: channelFilter, 0x%{private}08X,countNumOfSetBits,%{private}d
fencecalculator timestamp is 0
FenceCal: before devaluing, apLocation, %{private}s
FenceCal: devaluing, distanceToExpectedApLocation, %{private}.1lf, distanceToFenceCenter, %{private}.1lf
FenceCal: after devaluing, apLocation, %{private}s
FenceCal: devaluing, fence, %{private}s, result.fChosenAPs, %{private}lu, isExit, %{private}d
FenceCal: fence, %s, group pass, %3d, currentWeight, %3d, %3d, score, %+.4lf, newScore, %+.4lf, minScoreThresh, %+.4lf, totalChosenAps, %d, apsBudget, %d
FenceCal: fence, %s, group pass, %3d, currentWeight, %3d, %3d, upgrading score from, %.4lf, to, %.4lf, from, %4zu, to, %4zu, APs, index, %2d, totalChosenAps, %d, apsBudget, %d
FenceCal: fence, %s, score too close, currentScore, %lf, newScore, %lf, significantUpdateThresh, %lf, updating next step to, %d
FenceCal: passNum, %d, commitedAPs, %d, totalChosenAps, %d, numOfAps, %zu
FenceCal: group result, %{private}30s, totalChosenAps, %{private}4d, apsBudget, %{private}4d, index, %{private}4zu , %{private}4zu, aps, %{private}4zu, %{private}4zu, score, %{private}.2lf, index, %{private}4d, dbgCounter, %{private}4d
FenceCal: group result, %{private}30s, can't be monitored
#Warning FenceCal: no score for, %{private}s, fChosenAps, %{public}4zu
FenceCal: chosenScore, %-16s, fChosenScoreIndex, %4d, numOfAps, %4zu, %4zu, score, %.2lf
FenceCal: topping, %{public}zu, apsBudget, %{private}u
FenceCal: Topping, %{private}s, fChosenScoreIndex, %{private}d, total, %{private}zu
FenceCal: topping, from APs, %{private}zu, to APs, %{private}zu
FenceCal: finised topping, %{private}zu, apsBudget, %{private}u
FenceCal: fence, %s, isExit, %d, fChosenScoreIndex, %d, fChosenAPs, %zu, fChosenAPsScores, %zu, canBeMonitored, %d, canBeMonitoredInGroup, %d, numOfExitFences, %u
FenceCal: calculateGroup, end, return val, isOK, %d, numOfFences, %zu, numOfExitFences, %d, combinedCanMonitor, %d, combinedCanMonitorGroup, %d, combinedCanMonitorExitGroup, %d
Return entry AP, index, %2zu, %2zu, %s
Return exit AP, index, %2zu, %2zu, %s
FenceCal: fDistanceFromCurrentLocation, %{private}.2lf, %{private}s
dCOLLECT: no chosen score, was calculateGroup called?
{"msg%{public}.0s":"#SLC Overriding awareness parameters", "foundParameters":%{public, location:escape_only}@}
#SLC gSLCShowUI, %d
#SLC fIsConsolidateTriggersEnabled, %d
#SLC fConsolidatedTriggersTimeInterval, %.1lf
#SLC failed to allocate, fConsolidatedTrigger
{"msg%{public}.0s":"#SLC location changed", "now_s":"%{public}.09f", "location":%{private, location:CLClientLocation}.*P, "distance":"%{private}f"}
{"msg%{public}.0s":"#Warning #SLC Currently sending significant location changes read from defaults."}
{"msg%{public}.0s":"#Warning #SLC Delete 'SpoofSignificantLocationChange' from defaults to continue monitoring SLC updates."}
{"msg%{public}.0s":"#SLC Significant location change got invalid location!"}
{"msg%{public}.0s":"#SLC Ignoring inaccurate location"}
{"msg%{public}.0s":"#SLC Ignoring inaccurate GPS location"}
{"msg%{public}.0s":"#SLC Ignoring inaccurate WIFI location"}
{"msg%{public}.0s":"#SLC Ignoring inaccurate LoiOverride location"}
{"msg%{public}.0s":"#Warning #SLC Significant location change monitoring not active; not handling"}
#SLC handleSignificantLocationChange, distance, %.1lf, timeDelta, %.1lf, maxFactor, %.1lf
#SLC <%+.8f,%+.8f> acc %.2f timestamp %.2f is stale, discarding
#SLC <%+.8f,%+.8f> acc %.2f moved only %.2fm from previous significant location <%+.8f,%+.8f> acc %.2f, discarding
#SLC Lifespan of previous significant location <%+.8f,%+.8f> acc %.2f has not expired (timestamp %.2f, lifespan %.2f), discarding <%+.8f,%+.8f> acc %.2f
#SLC Timestamp %.2f of previous significant location <%+.8f,%+.8f> is less than %.2f seconds ago; discarding <%+.8f,%+.8f> acc %.2f
#Warning #SLC Location <%+.8f,%+.8f> acc %.2f is too far (distance %.2f) from previous location <%+.8f,%+.8f> acc %.2f from %.3fs ago, discarding
#SLC avoiding too frequent SLC notificaitons, age, %.1f, prev location, <%+.8f,%+.8f>, acc, %.2lf, new location, <%+.8f,%+.8f>, acc, %.2f
#SLC issue notificaiton, distance, %.1lf
#SLC got first location, sending SLC notification
#SLC no location change
#SLC reporting a location change
#SLC new location is not useful
{"msg%{public}.0s":"#SLC Location inspection complete", "isSignificantlocationchange":%{public}hhd, "distance":"%{private}f", "secondsSinceLastSLC_s":"%{public}.09f"}
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Lifespan,%.2f,LocationType,%d,PrevLocation,%+.8f,%+.8f,%.2f,Distance,%.2f,DeltaTime,%.3f,
{"msg%{public}.0s":"SLC simulation request received by CLSignificantChangeManager"}
{"msg%{public}.0s":"#SLC Checking whether we should be monitoring", "activeNow":%{public}hhd, "hasNotifierClients":%{public}hhd}
{"msg%{public}.0s":"#SLC Starting"}
{"msg%{public}.0s":"#SLC Stopping"}
#SLC Booting up
#SLC onSettingsNotification
#SLC Spoofing a Significant Location Change: %s
{"msg%{public}.0s":"#SLC Got location", "location":%{private, location:CLClientLocation}.*P}
{"msg%{public}.0s":"#SLC Location services is now disabled; Clearing cached location"}
{"msg%{public}.0s":"#SLC Got unknown client notification", "notification":%{public}d}
{"msg%{public}.0s":"#SLC Request location update"}
#SLC ignore, onConsolidatedTrigger, shutdown?
#SLC onConsolidatedTrigger, calling requestLocationUpdate
CL: CLSignificantChangeManager::onClientNotification
{"msg%{public}.0s":"CLSignificantChangeManager::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSignificantChangeManager::onAwarenessNotification
{"msg%{public}.0s":"CLSignificantChangeManager::onAwarenessNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
northAndGravity failed
invalid initializeDown covariance !(P > 0), reseting
Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 93,mean() on empty buffer.
D(%zu) <= 0 non-positive definite matrix!
Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 209,invalid col %zu > %zu.
Assertion failed: col > row, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 210,invalid element %zu <= %zu.
Assertion failed: row < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 163,invalid row %zu > %zu.
Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 145,back() on empty buffer.
Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 203,invalid col %zu > %zu.
Assertion failed: col > row, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 204,invalid element %zu <= %zu.
Assertion failed: row < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/Math/CMFactoredMatrix.h, line 158,invalid row %zu > %zu.
D[%zu] <= 0, matrix ! positive definite
D[%zu] == 0, semidefinite matrix!
%zu: alpha <= 0, matrix ! positive definite
Assertion failed: n > 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMQueue.h, line 191,.
ALM: not supported on this platform because FrontBoardServices.framework is not present
ALM: not supported on this platform because AssertionServices.framework is not present
{"msg%{public}.0s":"@ALM: Taking process assertion for process", "processId":%{public}u, "justLaunched":%{public}hhd, "clientKey":%{private, location:escape_only}s}
{"msg%{public}.0s":"@ALM: Releasing process assertion for process", "processId":%{public}u, "client":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Warning ALM: Couldn't create assertion for process", "processId":%{public}u, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning ALM: dropping launchApplication request for unauthorized purpose", "RequiredServiceMask":%{public}d, "AuthContext":%{public, location:escape_only}@}
%s doesn't have a bundle ID; not going to bug SpringBoard.
{"msg%{public}.0s":"ALM: failed attempt to launch before device unlocked since boot", "clientKey":%{private, location:escape_only}s}
ALM: %{private}s isn't running; launching...
#Warning Couldn't launch application %s (%s)
notification, %d, %s, pid, %d, bundleId, %s
#Warning unhandled app monitor notification, %d, %s
ALM: device unlocked since boot, %{private}s, application launch capability, %{private}sabled
CL: CLApplicationLifecycleManager::onAppMonitorNotification
{"msg%{public}.0s":"CLApplicationLifecycleManager::onAppMonitorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLApplicationLifecycleManager::onDataProtectionManagerNotification
{"msg%{public}.0s":"CLApplicationLifecycleManager::onDataProtectionManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
accel queue full @ %lld, %llu; reset; DM queue size %u
accel gap %llu reset
cannot interpolate because dT %llu large
DM queue full, reset; DM time: %llu
old accel %llu vs DM %llu, discarding
old DM %llu old vs accel %llu, discarding
alignAccelDM precondition violation
old dT idx %u, dist_before %llu, dist_after %llu
reset accel pre alignment queue %llu ~ %llu
reset DM pre alignment queue %llu ~ %llu
Enable dynamic accelerometer rate = %{public}d
Using prototype: %{private}s
Not starting gesture detection since requested accelerometer interval < 0
Gesture prototype was not setup. Using default prototype
No accelerometer; not detecting gestures
9-axis sensor fusion is not supported on this platform.  Returning.
North reference overridden as %{public}d by first client
correctedCompassExt, %.3f, %.3f, %.3f, %u, %u
CLCoarseCellTilesManager is not supported in diagnostics mode
{"msg%{public}.0s":"Non-cell tile Assertion", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
TILE: fMaxTileDataAge, %.1lf
TileCoarse, isActive, %{public}d
TILE: MTimeModificationPeriod, %.1lf
TILE: fDefaultCellTilesServerUrl, %{private}s, overridden, %{public}d
TILE: mkdir, %s, ret, %d
TILE: CLCoarseCellTilesManager::shutdown
TileCoarse, unexpected, dataprotection, %{public}d
TileCoarse, kNotificationEncryptedDataAvailability, %d, changed, %d
TileCoarse, unexpected, status, %{public}d
TileCoarse, kNotificationReachability, %{public}d, was, %{public}d
TileCoarse, kNotificationReset
TileCoarse, kNotificationLocationServicesStatus, %{public}d
TileCoarse, #CacheDelete kNotificationSoftwareUpdateStorageRecovery
TileCoarse, unexpected, companion, %{public}d
TileCoarse, Cleanup
TILE: performing, sAction, %s, tilesSet, %s
TileCoarse, listAvailableFilesAllTypes, indexed, %{public}d
TileCoarse, clear on index
TileCoarse, listAvailableFilesAllTypes, done
TileCoarse, indexTiles, rootDirectory, %{public}s, name, %{public}s
TileCoarse, indexTiles, can't open dir, %{public}s, #CloneMe
TileCoarse, indexTiles, absoluteFilename, '%{public}s', d_type, %{public}d
TileCoarse, indexTiles, invalid filename  %{public}s
TileCoarse, convert to class C, first unlock, %{public}s, files, %{public}d
TileCoarse, indexTiles, failed to stat file, %{public}s, ret, %{public}d, #CloneMe
@TileList, %{public}s, add, llsw, %{private}.2lf, %{private}.2lf, index, size, %{public}lu
TileCoarse, indexTiles, done, %{public}s, size, %{public}lu, unprotected, %{public}lu
TileCoarse, skip predownload, fIndexedAvailableFiles, %{public}d, fIsActive, %{public}d
@TileError, RequestID, ll, %{private}.3lf, %{private}.3lf, tid, %d, %d, %d
TileDl, requestDownload, type, %{public}d, %{public}s, location, %{private}14.8lf, %{private}14.8lf, id, %{private}s, updated, %{public}d, reachbility, %{public}d
@TileSched, coarsecell, set, %{public}d
@TileDl, coarse, failed criteria
TileDl, tileDownloadedCallback, success, %{public}d
@TileReq, %{public}s, downloaded, llsw, %{private}.2lf, %{private}.2lf, success, %{public}d, NSURLErrorCode, %{public}d
@TileDl, tileDecompressionCompleted, tile, %{private}s, decompress done, success, %{public}d, NSURLErrorCode, %{public}d, tileDoesNotExist, %{public}d, reachability, %{public}d, validId, %{public}d, locked, %{public}d, fileSize, %{public}d
@TileError, DecompressionID
@TileList, %{public}s, add, llsw, %{private}.2lf, %{private}.2lf, download, size, %{public}lu
@TileReq, %{public}s, add, llsw, %{private}.2lf, %{private}.2lf, download, size, %{public}lu
@TileError, tile not on download list, #CloneMe
@TileDl, kNotificationTileWasDownloaded, tileid, %{private}s, tileHeaderParsed, %{public}d, tileType, %{public}d, serverUrl, %{private}s, serverFilename, %{private}s, absoluteLocalFilename, %{private}s
TILE: getLocationByCellFromTile, searching, sec_key, %016llX, %s
TILE: getLocationByCellFromTile, in tile, accessible, %d, %s
TILE: no lac tile for, %s
TILE: getLocationByCellFromTile, isFound, %d, locationd, %s
TILE: getLocationByCell, index is not available, can't search tiles (locationd launched when device was locked?), fDataProtectionEnabled, %d
TILE: no tiles for, %s
CoarseTile, getLocationByCell, un-supported cell type, %{private}s, #CloneMe
TILE: getLocationByCell, search for LAC
TILE: getLocationByCell, LAC tiles for, %s, are not active
TILE: getLocationByCell, search for LAC, isFound, %d
TileCoarse, %{public}s
{"msg%{public}.0s":"CLCoarseCellTilesManager::removeAllTiles", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "type":%{private}d}
TileCoarse, %{public}s, removeAllTiles, size, %{public}lu
@TileList, %{public}s, delete, llsw, %{private}.2lf, %{private}.2lf, all, size, %{public}lu
TileCoarse, removeAllTiles, end, name, %{public}s, size, %{public}lu, unprot size, %{public}lu
TileCoarse, deleteAgedTiles, dispatch, %{public}s
TileCoarse, deleteAgedTiles, start, name, %{public}s, size, %{public}lu
{"msg%{public}.0s":"CLCoarseCellTilesManager::agedTileDeleter", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "now_s":"%{public}.09f"}
TILE: deleteAgedTiles, tileDataAge, %.1lf, %.1lf, corrupt, %d, isDelete, %d, tile, %s
@TileList, %{public}s, delete, llsw, %{private}.2lf, %{private}.2lf, %{public}s, size, %{public}lu
@TileList, %{public}s, delete, llsw, %{private}.2lf, %{private}.2lf, limits, size, %{public}lu
TileCoarse, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu, name, %{private}s
@TileList, %{public}s, readerror, dir, %{public}s, file, %{public}s, #CloneMe
@TileList, %{public}s, create, llsw, %{private}.2lf, %{private}.2lf, size, %{public}lu
TILE: tiles, %s, not active
TILE: updating mtime, %d, type, %d, tileid, %s
CoarseTile, Invalid tile id!, #CloneMe
@TileSched, coarsecell, called, %{public}ld
#Warning Cost of match %{public}f exceeds max of %{public}f allowed for prototype %{public}s
#Warning Could not open prototype file
#Warning Error reading magic number or number (%{public}x) does not match expected number (0x%{public}x)
#Warning Error reading number of prototypes
#Warning Error reading name length of prototype %{public}d
#Warning Error reading name of prototype %{public}d
#Warning Error reading rawName length of prototype %{public}d
#Warning Error reading rawName of prototype %{public}d
#Warning Error reading max distance
You are reading an older prototype file.
#Warning Error reading number of accelerometer samples for prototype %{public}d
#Warning Error reading %{public}d accelerometer samples for prototype %{public}d
#Warning Could not initialize prototype instance %{public}d
fLocationState %d state %d
Ear gesture disabled on this platform because BKSHIDServicesRequestProximityDetectionMode is not present
Ear gesture enabled: %{public}d
Ignoring prox: %{public}d
Max prox before motion interval = %{private}f
Max motion before prox interval = %{private}f
Starting ear gesture detection
Setting prox mode to PassiveMonitoring. Starting detection.
Setting prox mode to none. Stopping ear gesture detection.
Has blanked screen = %{public}d, Is locked = %{public}d
Screen is blanked and device is locked. Stopping gesture detection.
Screen is unblanked or device is not locked. Starting gesture detection if necessary.
endPose,%{public}.2f,%{public}.2f,%{public}.2f,tilt,%{public}.2f,timestamp,%{public}.3f
Failed end pose sanity check. Set state to %{public}s
Sending gesture notification. Matched prototype name, %{private}s
Sending gesture notification. Gesture cancelled due to unlikely end pose, %{public}.2f, %{public}.2f, %{public}.2f
Sending gesture notification. Gesture cancelled due to high dynamics, %{public}.3f, %{public}.3f, %{public}.3f
Readying gesture notification. Ignoring prox
Setting prox mode to PassiveEngaged. Ready to send notification.
Readying gesture notification. Prox triggered before motion. dt = %{public}.3f
Setting prox mode to PassiveEngaged. Motion waiting for prox.
Set timer for %{private}f seconds.
Gesture timer expired. State = %{public}s
Timer fired while in state %{public}s.
Setting prox mode to PassiveMonitoring. Prox timer expired.
#EmergCon,CLEmergencyState,SimInstance is KSimNone
{"msg%{public}.0s":"#EmergCon CLEmergencyState Creation ", "state":%{public, location:escape_only}s}
currentSize is %llu, log msg size is %lu
Log msg size exceeds limit %d, skip loging %lu bytes
Log size exceeded %llu, skip log of %lu bytes
Invalid parameter in getIndexFromAge: %{private}d
Invalid parameter, cannot calculate an alert threshold
Bytes: construct, name, %s
Bytes: clear, name, %s
Bytes: log, name, %s, m, %s, s, %d, r, %d, t, %d, ts, %d, reachability, %d
StepCount, %f, %f, %d, %f, %f, %u, %f, %f, %f, %f, %d
unified,%s,%0.3f,%s,%u,%s,%u,%s,%s,%0.2f,%s,%0.2f,%s,%0.2f,%s,%0.2f,%s,%s,%0.2f,%s,%0.2f,%s,%0.2f,%s,%u,%s,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%u,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.4f,%s,%0.3f,%s,%0.4f,%s,%0.2f,%s,%u,%s,%0.3f,%s,%0.3f,%s,%d,%s,%d
#Warning Potential StepDistanceFusion error. File a radar if you are not walking/running in place. %s, %f, %s, %u, %s, %u, %s, %f, %s, %f, %s, %f, %s, %f, %s, %f, %s, %f, %s, %d, %s, %f, %s, %f, %s, %f, %s, %f
#Warning Inconsistency found between steps and clock. Ignoring.
action,%d,type,%d
Classifying %lu odometer entries
OdometerQuality,%d,MostRecentOdometerEntry,timestamp,%.3lf,timestampGps,%.3lf,odometer,%.3lf,deltaDist,%.3lf,deltaDistUnc,%.3lf
#Warning Time rolled back! t1,%{public}f,t2,%{public}f
StepCountBuffer lookup time not successful,%0.3f
How can we generate pedometer distance with no time at all?
PedestrianStop,timestamp,%0.3f,statePrev,%d,state,%d,stepCountDiff,%d,activeTimeDiff,%0.3f,isStroller,%d,stepCadenceSmallWindow,%0.3f,strollerFractionSmallWindow,%0.3f,stepCadenceLargeWindow,%0.3f,strollerFractionLargeWindow,%0.3f,fTimeSinceRunTimer,%zd,isFrontSmallWindowActiveInLargeWindow,%d
@WifiService_Type, unsupported scan type %{public}d
[Baro] TPQ summary,%d,A,%f,B,%llu,C,%f,D,%f,E,%lu,F,%d,G,%llu,H,%f,I,%d,J,%d,K,%f,L,%f,M,%f,config-1,%f,config-2,%f,config-3,%f
baro (%f, %f, %f, %lu, %u, %f, %f, %f, %f) (%d, %d, %d, %d, %d, %d, %d, %d, %d)
baro config %f, %f, %f
Baro, error, rate outside possible range, %lu
Baro, calculatedRate, %lu
Baro, resetting algorithm
registering for keyboard updates
#Warning Failed to register for keyboard updates. Could not register for notifications from  AppleHIDKeyboardEventDriverV2 service and IOAccessoryIDBusHIDDevice service (for kIOFirstMatchNotification and kIOTerminatedNotification).
#Warning Failed to register for keyboard updates. Could not create KeyboardConnectNotificationPort and KeyboardConnectNotificationPort
unregistering for keyboard updates
StrideCalDb init
Finished insertion startTime %f
insertion startTime %f
Speed,%f,KFactorStd,%0.4f
Median kValue pacebin with rawSpeed %f: %f
Deleting VO2MaxStagingSummaryHistory records from db where sessionId = %{public}s
VO2MaxStagingSummaryHistory, DB not accessible
#Warning Received unhandled notification, %d
TaiChi,baselineMets,%.1f,metsHR,%.1f,metsWR,%.1f,userMets,%.1f,userMetsSource,%d
[Pulse] TPQ summary,%d,A,%f,B,%f,C,%llu,D,%llu,E,%d,config-1,%f
pulse (%f, %f, %d) (%d, %d, %d)
pulse config %f
Pulse alg: reset
Assertion failed: !empty(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 139,front() on empty buffer.
Assertion failed: i < size(), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMVectorBuffer.h, line 39,out of buffer range %zu.
Ski Record update: startTime %lf, endTime %lf, runDistance %f, runElevationDescent %f, runAvgSpeed %f, runMaxSpeed %f
CL: CLSkiNotifier::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLSkiNotifier::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSkiNotifier::onOdometerNotification
{"msg%{public}.0s":"CLSkiNotifier::onOdometerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"No previous sample matching aop timestamp, will insert first in queue", "aopTimestamp":%{public}llu}
{"msg%{public}.0s":"No previous sample matching ios timestamp, will insert first in queue", "iosTimestamp":%{public}llu}
CMFFTProcessor is being cleaned up.  Subsequent calls to CMAccelerometerProcessor::computeFrequencyFeatures will lead to undefined behavior.
Assertion failed: arg >= 0.f && arg <= static_cast<scalar_32>(2147483647), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMFFTProcessor.cpp, line 52,arg,%f.
Assertion failed: start < end, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMFFTProcessor.cpp, line 74,start,%d,end,%d.
{"msg%{public}.0s":"not ready to upload: turned off", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld}
{"msg%{public}.0s":"not ready to upload: no locations", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld}
%s not ready to upload: invalid reachability. Have %d and need %d
{"msg%{public}.0s":"Harvest-Upload", "subHarvester":%{private, location:CLSubHarvesterIdentifier}lld, "numPoints":%{private}lu, "secondsSinceLastUpload":"%{private}f"}
{"msg%{public}.0s":"cannot be enabled: disabled by harvest rule", "subHarvester":%{private, location:CLSubHarvesterIdentifier}lld}
{"msg%{public}.0s":"cannot be enabled: not supported", "subHarvester":%{private, location:CLSubHarvesterIdentifier}lld}
{"msg%{public}.0s":"harvesting enabled", "subHarvester":%{private, location:CLSubHarvesterIdentifier}lld}
{"msg%{public}.0s":"harvesting disabled", "subHarvester":%{private, location:CLSubHarvesterIdentifier}lld}
{"msg%{public}.0s":"#uploadTimer ATU", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "fLastUploadTime_s":"%{private}.09f", "fNextUploadTime_s":"%{private}.09f", "sinceLU_s":"%{private}.09f", "tillNU_s":"%{private}.09f"}
{"msg%{public}.0s":"#uploadTimer option A", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "fLastUploadTime":"%{private}f", "interval":"%{private}f"}
{"msg%{public}.0s":"#uploadTimer option B", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "fLastUploadTime":"%{private}f", "interval":"%{private}f"}
{"msg%{public}.0s":"#uploadTimer option C", "subHarvester":%{public, location:CLSubHarvesterIdentifier}lld, "fLastUploadTime":"%{private}f", "interval":"%{private}f"}
{"msg%{public}.0s":"pruned harvest points", "subHarvester":%{private, location:CLSubHarvesterIdentifier}lld, "prunedPointsCount":%{private}lu}
{"msg%{public}.0s":"cleared harvest points", "subHarvester":%{private, location:CLSubHarvesterIdentifier}lld, "clearedPointsCount":%{private}lu}
{"msg%{public}.0s":"#slv Overriding awareness parameters", "foundParameters":%{public, location:escape_only}@}
#slv telling routined to start visit monitoring
#slv received visit from routined, visit, %@, error, %@
#slv telling routined to stop visit monitoring
#slv Telling routined to start visit leeching
#slv Received leeched visit from routined, visit, %@, error, %@
#slv Telling routined to stop visit leeching
#slv Telling routined to start low confidence visit leeching
#slv Received leeched low confidence visit from routined, visit, %@, error, %@
#slv Got unexpceted error from routined, error, %@
#slv Telling routined to stop low confidence visit leeching
dropping duplicate location, %{private}@
received location, %{private}@
#warning in-memory cache has exceeded threshold of %{public}lu, removing oldest fix
received unhandled notification %{public, location:CLClientManager_Type::Notification}d
received unhandled notification %{public, location:CLLocationProvider_Type::Notification}d
flushing routine data
Location services are disabled; stopping routine data collection
Routine system service disabled; stopping routine data collection
LocationServer received incoming connection
Why didn't we get a connection
{"msg%{public}.0s":"process is not entitled to use CLLocationManagerRoutine", "pid":%{public}d, "executable":%{public, location:escape_only}s}
Connection interrupted
Connection invalidated
start updating location
stop updating location
{"msg%{public}.0s":"#location #routine sendLocationsWithReply"}
{"msg%{public}.0s":"#location #routine sendLocations replied"}
start wakeRoutinedTimer
stop wakeRoutinedTimer
wake routined
entering diminished mode; starting data collection
exiting diminished mode; stopping data collection
#scenarioTrigger Telling routined to start monitoring trigger of type, %lu
#scenarioTrigger Received trigger of type %lu from routined, error %@
#scenarioTrigger Got error from routined, error, %@
#scenarioTrigger Telling routined to stop monitoring trigger of type, %lu
{"msg%{public}.0s":"#storedLocations: CoreRoutine error while getting stored visits.", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#storedLocations: CoreRoutine returned.", "Visits":%{public}ld}
{"msg%{public}.0s":"#storedLocations: zipper start", "IntervalCount":%{public}ld, "VisitCount":%{public}ld, "startTime":%{public}ld, "endTime":%{public}ld, "FromDate":%{public, location:escape_only}@, "ToDate":%{public, location:escape_only}@}
{"msg%{public}.0s":"#storedLocations: CoreRoutine error while getting stored locations.", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#storedLocations: enumerateStoredLocationsWithOptions", "LocationCount":%{public}ld}
{"msg%{public}.0s":"#storedLocations: enumerateStoredLocationsWithOptions<finsihed>"}
{"msg%{public}.0s":"#storedLocations: zipper finished", "LocationCount":%{public}ld, "ClusteredCount":%{public}ld, "UnattributedIntervals":%{public}ld}
{"msg%{public}.0s":"#location #routine fetchEstimatedLocationAtDate"}
{"msg%{public}.0s":"#location #routine fetchEstimatedLocationAtDate is disabled"}
{"msg%{public}.0s":"#location #routine sendLocations complete"}
{"msg%{public}.0s":"#location #routine fetchEstimatedLocationAtDateOptions"}
{"msg%{public}.0s":"#location #routine sendLocations complete for options"}
{"msg%{public}.0s":"#storedLocations: dedupe", "locationCount":%{public}ld}
{"msg%{public}.0s":"#storedLocations: dedupe", "deduppedCount":%{public}ld}
TILE: clear, tile, %sd
Fence: delete CLFenceDataDownloadManager
Fence: Adding %{public}ld fences for download
{"msg%{public}.0s":"addFencesForDataDownload fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Adding fence to download, %{private}s
Fence: Already have fence data, download age %{private}.1f
Fence: Adding fence to download, restored fence, %{private}s
Fence: first fence added, enable download timer
Fence: Removing %{public}ld fences for download
Removing fence from download, [%{private}s]/%{private}s/%{private}s
Fence: last fence removed, disabled download timer
Fence: refreshDataForFence, %{private}s
Fence: Removing all fences for download, fences, %{public}lu
Fence: avoid download check, isLocationServicesEnabled, %{public}d
Fence: no reachability, download not possible
Download error too fresh, avoid new downloads, dt, %{private}.1lf
checkDownloadState, currentQueries, %{private}d, numCombined, %{private}lu, reachability, %{public}d,%{public}d,%{public}d
avoiding more concurrent downloads, %{private}d, max, %{private}d
already downloading fence, %{private}s
Fence: request tile download, %{private}s
Fence: Urgent refresh, %{private}s
fence, %{private}s, is fresh for reachability, %{public}d,%{public}d,%{public}d, age, %{public}.1lf, thresh, %{public}.1lf
Fence: request ALS/tile download, tag, %{public}d, %{private}s, need refresh, %{public}d,%{public}d,%{public}d, age, %{public}.1lf, num %{public}d, %{public}d, isUrgentDownload, %{public}d
#Warning Fence: can't start query
checkDownloadState, currentNumOfQueries, %{public}d, newNumOfQueries, %{public}d, numOfStartedQueries, %{public}d, nSmall, %{public}d, nLarge, %{public}d
Fence: networkQueryDone,tag,%{public}d,isSuccess,%{public}d,numOfAps,%{public}d,numOfCells,%{public}d,key,%{public}d,%{public}d,%{private}s
networkQueryDone, newNumOfQueries, %{public}u, isAvoidUpcomingFenceDownloads, %{public}d, doesTagBelongToFence, %{public}d
#Warning Got unknown notification %{public}d
Fence: ignore onFenceDownloadTimer, shutdown?
Fence: onFenceDownloadTimer, since last, %{private}.1lf
Fence: kNotificationReachability, notification, %{private}d, reachability, from, %{private}d, to, %{private}d
Unhandled reachability notification
Fence: kNotificationMigration
Fence: kNotificationCompanionConnectionUpdate, isNearby, from, %{public}d, to, %{public}d
CL: CLFenceDataDownloadManager::onNetworkLocationNotification
{"msg%{public}.0s":"CLFenceDataDownloadManager::onNetworkLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceDataDownloadManager::onStatusNotification
{"msg%{public}.0s":"CLFenceDataDownloadManager::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceDataDownloadManager::onCompanionNotification
{"msg%{public}.0s":"CLFenceDataDownloadManager::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceDataDownloadManager::onFenceDownloadTimer
{"msg%{public}.0s":"CLFenceDataDownloadManager::onFenceDownloadTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
VO2MaxPowerBudgetEstimator, budgetRefreshTimer fire
VO2MaxPowerBudgetEstimator, scheduling next budget refresh, time, %.2f
VO2MaxPowerBudgetEstimator, updating budgetRefreshTimer, delay, %.2f
VO2MaxPowerBudgetEstimator, getting sensitiveEscalationHoldoffInterval, %.2f
VO2MaxPowerBudgetEstimator, zeroing budget on VO2MaxEstimate, now, %{public}.2f, nextRefreshTime, %{public}.2f
VO2MaxPowerBudgetEstimator, zeroing budget on workout stop event, now, %{public}.2f, nextRefreshTime, %{public}.2f
VO2MaxPowerBudgetEstimator, encrypted data available notification, isAvailable, %d
VO2MaxPowerBudgetEstimator, kicking off historical data query, startTime, %{public}.2f, endTime, %{public}.2f
VO2MaxPowerBudgetEstimator, new budget awarded on HK query and VO2Max results, startTime, %{public}.2f, endTime, %{public}.2f, budget, %{public}.2f, now, %{public}.2f, nextRefreshTime, %{public}.2f
VO2MaxPowerBudgetEstimator, zeroing budget on HK query and VO2Max results, startTime, %{public}.2f, endTime, %{public}.2f, now, %{public}.2f, nextRefreshTime, %{public}.2f
VO2MaxPowerBudgetEstimator, Workout query returned empty
VO2MaxPowerBudgetEstimator, Workouts query result, startTime, %{public}.2f, endTime, %{public}.2f, hkWorkoutType, %{private}d, isPedestrian, %{private}d, isIndoorWorkout, %{private}d, calories, %{private}.2f
VO2MaxPowerBudgetEstimator, Workouts query last result, startTime, %{public}.2f, endTime, %{public}.2f, hkWorkoutType, %{private}d, isPedestrian, %{private}d, isIndoorWorkout, %{private}d, calories, %{private}.2f
VO2MaxPowerBudgetEstimator, Workout query failed, startTime, %{public}.2f, endTime, %{public}.2f
VO2MaxPowerBudgetEstimator, Workout query succeeded, startTime, %{public}.2f, endTime, %{public}.2f
[CLPressureStatsCollector] A new record saved to cache.plist
[CLPressureStatsCollector] cache.plist reset
[CLPressureStatsCollector] AWD values staged
Fence: Got kNotificationAirplaneMode, airplaneMode, %d, %d
Fence: sMessage, %{public}s, fFenceDatabase is NULL
Fence: Got kNotificationMigration
{"msg%{public}.0s":"#FenceHandoff To be deleted", "count":%{public}llu}
{"msg%{public}.0s":"#FenceHandoff Let me remove", "key":%{public}d}
{"msg%{public}.0s":"#Warning Fence: #FenceHandoff found no handofTag!"}
{"msg%{public}.0s":"#Warning Fence: #FenceHandoff tag value doesn't match previous value for bundle !! something is wrong !!", "Tag":%{public, location:escape_only}s}
{"msg%{public}.0s":"Fence: #FenceHandoff unable retrieve Fences from database"}
Fence: #FenceHandoff fenceHandedOffToCompanion: no fence before the first unlock
Fence: #FenceHandoff handedOffFenceRemovedFromCompanion: no fence before the first unlock
{"msg%{public}.0s":"CLFenceAuthorizationManager::reinitFenceMonitoring"}
{"msg%{public}.0s":"Fence: Adding authorized Fence", "fenceName":%{private, location:escape_only}s, "bundleId":%{public, location:escape_only}s, "onBehalfOf":%{public, location:escape_only}s}
{"msg%{public}.0s":"Ignoring notification", "WasUnlockedSinceBoot":%{public}hhd, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"Fence: missing bundleId", "bundleId":%{public, location:escape_only}s}
{"msg%{public}.0s":"Fence: Removing Fences installed by missing bundleId", "missingBundleId":%{public, location:escape_only}s}
#Warning Could not retrieve fences from database for client %{public}s
kNotificationAuthorization, %lu, fences for, exec, %{public}s, bundleId, %{public}s, bundlePath, %{public}s, clientKey, %{public}s
{"msg%{public}.0s":"Auth notification same bundle fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Auth notification fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: Removing denied fences,%{public}lu, for bundle,%{public}s.
Fence: Adding authorized fences,%{public}lu, for bundle,%{public}s.
#Warning Reset received; sending reset notification
Location services is now %{public}s; sending reset notification
Fence: notification, kNotificationEncryptedDataAvailability, data.availability, %{public}d, unlockedSinceBoot, from, %{public}d, to, %{public}d, isStartMonitoring, %{public}d
Fence: updateAuthorizedClients, can't add fence before the first unlock
Fence: updateAuthorizedClients, locationServicesEnabled, %{public}d
checkClientStatus, %{public}s
Fence: addFence, can't add fence before the first unlock
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Add,1,BundleId,%s,Name,%s,
Adding fence to db, %{private}s
{"msg%{public}.0s":"Fence: #FenceHandoff will be sent to companion", "fence":%{public, location:escape_only}s}
Fence: removeFence, can't remove fence before the first unlock
Removing fence %{public}s/%{private}s
Fence: getFence, can't add/remove fence before the first unlock
Fence: removeFences, can't remove fence before the first unlock
Removing all fences for %{public}s
Fence: getAuthorizedFences, no region monitoring before the first unlock
Location services are disabled; no monitored fences
Retrieved %{public}ld fences from database
%{public}s/%{private}s is not authorized; removing from authorized fences list
{"msg%{public}.0s":"Get auth fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: getFencesForBundle, no region monitoring before the first unlock
Fence: getAllFencesForBundle, no region monitoring before the first unlock
Fence: isFenceRegisteredAndAuthorized, no region monitoring before the first unlock
isFenceRegisteredAndAuthorized, [%{public}s]/%{public}s/%{private}s, isRegistered, %d, isAuthorized, %d
Fence: lastDownloadTimeChanged, no region monitoring before the first unlock
Fence: markDataDownloadInvalid, no region monitoring before the first unlock
{"msg%{public}.0s":"Fence: isClientAuthorized", "key":%{public, location:escape_only}s, "authorized":%{public}hhd}
{"msg%{public}.0s":"Fence: isOnBehalfBundleAuthorized", "key":%{public, location:escape_only}s, "authorized":%{public}hhd}
{"msg%{public}.0s":"#FenceHandoff isOnBehalfBundleAuthorized", "isAuthorized":%{public}hhd}
{"msg%{public}.0s":"Fence: isFenceAuthorized", "isAuthorized":%{public}hhd}
Fence: hasMonitoredFences, no region monitoring before the first unlock
%{public}d fences for %{public}s; authorized %{public}d
%{public}s: hasMonitoredFences %{public}d, monitoringAdded %{public}d airplane %{public}d
%{public}s is now a fence client, airplane, %{public}d
%{public}s is no longer a fence client, airplane, %{public}d
Fence: createFenceDatabase, fFenceDatabase, %{private}p, fWasUnlockedSinceBoot, %{public}d, reason, %{public}s
{"msg%{public}.0s":"Fence: #FenceHandoff setting monitorFlags", "fence":%{public, location:escape_only}s, "from":%{public}llu, "to":%{public}llu}
{"msg%{public}.0s":"Fence: #FenceHandoff Unable to update monitor flags for handoff", "fence":%{public, location:escape_only}s, "from":%{public}llu, "to":%{public}llu}
{"msg%{public}.0s":"Fence: #FenceHandoff Unable to reset handoff status", "fence":%{public, location:escape_only}s, "primaryKey":%{public}d}
{"msg%{public}.0s":"Fence: getAllFences, failed to get Fences to init handoff status"}
{"msg%{public}.0s":"#FenceHandoff unable reset handoff statyus"}
CL: CLFenceAuthorizationManager::onClientNotification
{"msg%{public}.0s":"CLFenceAuthorizationManager::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceAuthorizationManager::onStatusNotification
{"msg%{public}.0s":"CLFenceAuthorizationManager::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceAuthorizationManager::onDataProtectionNotification
{"msg%{public}.0s":"CLFenceAuthorizationManager::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Fence: Overriding cell positioning usage to %{private}d
Fence: Overriding WiFi positioning usage to %{private}d
Fence: Overriding GPS positioning usage to %{private}d
Fence: Overriding Pipeline positioning usage to %{private}d
Fence: Overriding continuous positioning usage to %{private}d
Fence: Overriding FenceIssueDelayedTriggers to %{private}d
Fence: Overriding fWakeIntervalSeconds, %{private}.1lf
Fence: Overriding fDelayedTriggerCountMax, %{private}d
Fence: Overriding fDelayedTriggerIntervalSeconds, %{private}.1lf
Fence: Overriding fIsConsolidateTriggersEnabled, %{private}d
Fence: Overriding fConsolidatedTriggersTimeInterval, %{private}.1lf
Fence: Overriding fIsScheduleContTrackingWakes, %{private}d
Fence: Overriding fIsTriggerOnTether, %{private}d
Fence: fIsUseActivityAlarm, %{private}d, activityAlarmAvailable, %{private}d
Fence: failed to allocate, fConsolidatedTrigger
Fence: can't check airplane mode
Fence: startMonitoringFences, fences, %{public}lu, status, %{private}s
{"msg%{public}.0s":"startMonitoringFences fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: restartMonitoringForAllFences
Fence: stopMonitoringFences, fences, %{public}lu
Fence: startMonitoring, fence, %{private}s
{"msg%{public}.0s":"Fence: startMonitoring fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: registerForNotification, location, numOfFencesOld, %{private}lu, numOfFenceNew, %{private}lu
#wigo,on,FenceAlwaysOn
Fence: unregisterForNotification, location, numOfFencesOld, %{private}lu, numOfFenceNew, %{private}lu
#wigo,off,FenceAlwaysOn
Start emergency acquisition, %{public}d
Started emergency acquisition
Stop emergency acquisition, %{public}d
Stopped emergency acquisition
Fence:Stop stopMonitoringNow, fence, %{public}s/%{private}s
{"msg%{public}.0s":"Where did this fence go", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: state stopMonitoringAFenceNow, before first unlock
Fence: stopMonitoringNow, no such fence, %{private}s
Fence: startMonitoringNow, fence, %{private}s, status, %{private}s
{"msg%{public}.0s":"startMonitoringNow fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: startMonitoringNow, fence, %{private}s, is already in fMonitoredFences
Fence: crirital error!
Fence: Location services is disabled; not starting monitoring for %{private}s/%{private}s
Fence: state, retrieved %{private}d
#Warning Fence: state startMonitoringNow, before first unlock
Fence: request scan, no current location
Fence: filtered fLastLocation, %{private}s
Fence: request scan, current location, %{private}s
Started monitoring, %{private}s, monitoringStatus, %{private}s
Fence:Start Started monitoring fence %{public}s/%{private}s (<%{private}+.8f,%{private}+.8f>, radius %{public}.3f, active tech %{private}d), numFences, %{public}zu, unlocked, %{public}d
Fence:Poly, %{public}s, %{public}d, %{public}d, %{publice}d, %{private}s
Fence: fence is already monitored, %{private}s
Fence: Got monitoring data changed for %{private}s/%{private}s
Fence: location services is disabled, no tech available
fence, %{private}s, requiredTech, %{private}s, fine, %{private}d, large, %{private}d
adjustTechLevel, fence, %{private}s, newOptions, %{private}s, availableTech, %{private}s, statusChanged, %{private}d
Stopping tech 0x%{private}x (active is 0x%{private}x) for %{public}s/%{private}s
Starting tech 0x%{private}x (active is 0x%{private}x) for %{public}s/%{private}s
Fence: fence, %{private}s, newTech, %{private}s, status, %{private}s
Fence: handleLocation, Ignoring cell or LAC position as per defaults
Fence: handleLocation, Ignoring WiFi position as per defaults
Fence: handleLocation, Ignoring GPS position as per defaults
Fence: handleLocation, Ignoring Pipeline position as per defaults
Fence: handleLocation, location, %{private}s, services, %{private}d, airplane, %{private}d, connected, %{private}d
Fence: cancelLocationWatchdog, num fences, %{public}lu, location type, %{private}s
Fence: Handling location, %{private}+.8f, %{private}+.8f, acc, %{private}.2f, timestamp, %{private}.1lf
request a scan to comfirm cell location, fences, %{public}lu
cancelLocationWatchdog, wifi off, minDistance, %{private}lf
Fence: requesting a scan, numOfFencesNeedScan, %{public}d, minDistanceToFence, %{private}.1lf
Fence: avoid a scan, numOfFencesNeedScan, %{public}d, minDistanceToFence, %{private}.1lf
Fence: Dispatch continuous engagement
#Warning Fence: Attempt to handle location <%{private}+.8f,%{private}+.8f> acc %{public}.2f for non-present fence %{public}s/%{private}s
Processing location when not supposed to
Fence: invalidate EPNO exit trigger time
Fence: %{private}s, filtering unwanted, %{private}s, nofitication, has not achieved settled state yet
Fence: %{private}s, filtering unwanted, %{private}s, nofitication, never achieved settled state for entry notification
Fence: fenceUpdate, %{private}s, bundle, %{private}s, type, %{private}-16s, loc, %{private}12.7lf, %{private}12.7lf, acc, %{public}4.0lf, distance, %{private}9.0lf, tech, %{private}4s%{private}s, trans, %{private}d, state, %{private}d, cont, %{private}d, fence, %{private}12.8lf, %{private}12.8lf, %{private}.1lf, %{private}.1lf, sCount, %{private}d, %{private}d, trig, %{private}d, %{private}d, sinceLastLoc, %{private}.1lf, events, 0x%{private}08x, status, %{private}-10s => %{private}-10s, settled state, %{private}s ==> %{private}s, cantShiftButNeedTo, %{private}d, sinceLastTransition, %{private}.1lf
{"msg%{public}.0s":"skyhook is no longer supported", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning Fence: state changed before first unlock
Fence: handleNoWifiApsArea, recalculated, %{public}d, fMinDistanceToFence, %{private}.1lf, fMinDistanceToFenceTimestamp, %{private}.1lf
Fence: Ignoring expired location <%{private}+.8f, %{private}.8f>, acc %{public}.2f, timestamp %{public}.2f, lifespan %{public}.2f
Fence: Ignoring old location, type, %{public}d, age, %{public}.1f
#Warning Fence: Got unknown location notification %{public}d
#Warning Fence: Cell monitoring is disabled; ignoring cell monitor notification %{public}d
Fence: Got kNotificationTriggerReceived from cell
Fence: Got kNotificationDelayTriggerReceived from cell
Fence: Got cell kNotificationMonitoringAvailable, available, %{public}d
#Warning Got unknown cell monitor notification %{public}d
#Warning WiFi monitoring is disabled; ignoring cell monitor notification %{public}d
Fence: Got kNotificationTriggerReceived from WIFI, cancelDelayedDeAssociationTrigger, %{public}d
Fence: setting EPNO exit trigger time
Fence: Got kNotificationDelayTriggerReceived from WIFI
Fence: Got WiFi kNotificationMonitoringAvailable, available, %{public}d
Fence: Got kNotificationReCheckContinuousEngagement
Fence: Got kNotificationFenceDownloadRequest
#Warning Fence: Got unknown WiFi monitor notification %{public}d
Fence: location services disabled, no continous tracking, %{public}d, isAirplaneMode, %{public}d, cConnected, %{public}d
Fence: FenceMonitorWifi needs tracking
Fence: engageContinuousTrackingIfNeeded, isEngageContinousTracking, %{public}d, numOfMonitoredFences, %{public}d, %{public}d
engageContinuousTrackingIfNeeded, timeToNextTimer, %{public}lf
{"msg%{public}.0s":"Connected state of watch changed", "from":%{public}hhd, "to":%{public}hhd}
Stop monitoring, nearby
#Warning Unhandled notification %{public}d
Fence: Got kNotificationAirplaneMode, airplaneMode, %{public}d
Fence: Got kNotificationBattery, level, %{private}lf, charged, %{private}d, connected, %{private}d, wasConnected, %{private}d
Fence: tether triggers are disabled
{"msg%{public}.0s":"FenceMetric, heartbeat,1,", "wifiScans":%{private}lld, "epnoCalc":%{private}lld, "epnoEntry":%{private}lld, "epnoExit":%{private}lld, "wakes":%{private}lld, "assertions":%{private}lld, "timers":%{private}lld, "gpsDenied":%{private}lld, "gpsSessions":%{private}lld, "gpsDuration":"%{private}.5f", "wdogArmed":%{private}lld, "wdogFired":%{private}lld, "wdogLong":%{private}lld}
{"msg%{public}.0s":"FenceMetric, heartbeat,2,", "locEnabled":%{public}hhd, "locToggled":%{public}hhd, "wifiEnabled":%{public}hhd, "wifiToggled":%{public}hhd, "airplaneEnabled":%{public}hhd, "airplaneToggled":%{public}hhd, "anyFences":%{public}hhd, "anyFineFences":%{private}hhd, "anyLargeFences":%{private}hhd, "anyEmergencyFences":%{private}hhd}
{"msg%{public}.0s":"FenceMetric, heartbeat,3,", "fences":%{private}lld, "fenceAdditions":%{private}lld, "fenceRemovals":%{private}lld, "fenceEntries":%{private}lld, "fenceExits":%{private}lld, "handoffFenceEntries":%{private}lld, "handoffFenceExits":%{private}lld, "locClient":%{private}lld, "locGps":%{private}lld, "locIndoor":%{private}lld, "locWifi2":%{private}lld, "locWifi":%{private}lld, "locCell":%{private}lld}
#Warning Fence: unknown notification, %{public}d
Fence: Got kNotificationPower, isWifiPowered, %{public}d
scan result, count, wait, %{public}d, retry, %{public}d, error
Fence: monitor, got kNotificationScan, result, %{private}lu, time, %{private}.1lf, age, %{private}.1lf, numFences, %{public}lu, locationCount, %{public}d, %{public}d
Fence: no reachability, expedite watchdog, %{public}.1lf
Fence: skip urgent, watchdog already active, %{public}d,%{public}d, %{public}d
Fence: startScan, requesting a scan due to an error / empty scan, fScanRetryCounter, %{public}d
Fence: expedite location watchdog due to empty / error scan , %{public}d, %{public}d, kUrgentWatchdogActivation, %{public}.1lf
Fence: triggerReceived, reason, %{private}s, schedule, %{private}p, pending, %{private}d, watchdogNeeded, %{private}d, %{private}d
Fence: triggerReceivedNow, isWifiPowered, %{public}d, isLocationEnabled, %{public}d, numOfFences, %{public}lu, airplane, %{public}d, connected, %{private}d, watchdogNeeded, %{private}d, minDist, %{private}.1lf, %{private}.1lf, minDistNextWake, %{private}.1lf
Fence: Trigger received; performing WiFi scan, minDistanceToFence, %{private}.1lf
Fence: Trigger received; schedule watchdog for GPS, minDistanceToFence, %{private}.1lf
Fence: ignoring trigger event
Fence: Cannot monitor %{public}s/%{private}s because the radius is too large, suggesting, %{private}.1lf
Fence: need a scan, count, %{public}d, %{public}d, dt_scan, %{private}.1lf, dt_watchdog, %{private}.1lf, interval, %{private}.1lf, needWatchdog, %{public}d
Fence: startScan, requesting a receovery scan
Fence: scheduleLocationWatchdog, at %{private}.1lf, in, %{private}.1lf, seconds
Fence: scheduleLocationWatchdog, ignore, shutdown?
Fence: loc watchdog cancel, count, %{public}d, %{public}d, client, %{public}p
Fence: cancelLocationWatchdog
Fence: cancelLocationWatchdog, ignore, shutdown?
loc watchdog expired, count, %{public}d, %{public}d
Fence: onLocationWatchdogExpired, since last, %{private}.1lf, isLocationEnabled, %{public}d, last scan, %{private}.1lf, fIsWaitingForLocationCount, %{public}d, sinceLastGpsSession, %{private}.1lf, %{private}.1lf, sinceLastContTimer, %{private}.1lf, %{private}.1lf, fScanRetryCounter, %{public}d
#Warning Fence: watchdog fired: %{private}.1lf, %{private}.1lf
Fence: onDelayedTriggerTimer, sleep period, %{private}.1lf, isLocationEnabled, %{public}d, count, %{public}d, %{public}d, sinceLastTrigger, %{private}.1lf
Fence: onDeAssTriggerTimer, sleep period, %{private}.1lf, isLocationEnabled, %{public}d, count, %{public}d, %{public}d, sinceLastTrigger, %{private}.1lf
Fence: onContinousTrackingTimer, sleep period, %{private}.1lf, isLocationEnabled, %{public}d, sinceLastTrigger, %{private}.1lf
Fence: Warning data can't be cleared yet
Fence: CLFenceMonitor, shutdown
Fence: ignore, onConsolidatedTrigger, shutdown?
Fence: onConsolidatedTrigger, calling triggerReceivedNow
Fence: request update, reason, %{private}s
Fence: requestRegionState, %{private}s/%{private}s
#Warning Fence: requestRegionState, %{public}s/%{public}s, NOT FOUND, %{public}d, %{public}d
#Warning Fence: state scrub prior unlock
Fence: createActivityAlarm, %{private}s, %{private}p, fIsUseActivityAlarm, %{private}d
Fence: activityAlarmHandler, %{private}p, %{private}s, trigger, %{private}d
Fence: releaseActivityAlarm, %{private}s, %{private}p
Fence: start monitoring scenario trigger settled
Fence: stop monitoring scenario trigger settled
Fence: received scenario trigger, %{private}s
Fence: settled timer expired
Fence: dispatch, handleSettled, fence, %{private}s, monitoringStarted, %{public}d, monitoringSettled, %{public}d
Fence: allowed gps time %{private}.1lf
Fence: unregister gps client, %{private}p
#wigo,off,Fence
Fence: discarding old gps session, %{public}.1lf
Fence: adding gps session, %{public}.1lf
Fence: state kNotificationDeviceUnlockedSinceBoot, from, %{public}d, to, %{public}d, start, %{public}d
Fence: createStateDatabase, fStateDatabase, %{private}p, fDeviceUnlockedSinceBoot, %{public}d, reason, %{public}s
CL: CLFenceMonitor::onBluetoothNotification
{"msg%{public}.0s":"CLFenceMonitor::onBluetoothNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onLocationNotification
{"msg%{public}.0s":"CLFenceMonitor::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onCellMonitorNotification
{"msg%{public}.0s":"CLFenceMonitor::onCellMonitorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onWifiMonitorNotification
{"msg%{public}.0s":"CLFenceMonitor::onWifiMonitorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onDataProtectionNotification
{"msg%{public}.0s":"CLFenceMonitor::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onStatusNotification
{"msg%{public}.0s":"CLFenceMonitor::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onDelayedTriggerTimer
{"msg%{public}.0s":"CLFenceMonitor::onDelayedTriggerTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onDeAssTriggerTimer
{"msg%{public}.0s":"CLFenceMonitor::onDeAssTriggerTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onContinousTrackingTimer
{"msg%{public}.0s":"CLFenceMonitor::onContinousTrackingTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onLocationWatchdogExpired
{"msg%{public}.0s":"CLFenceMonitor::onLocationWatchdogExpired", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFenceMonitor::onSettledTimerExpired
{"msg%{public}.0s":"CLFenceMonitor::onSettledTimerExpired", "event":%{public, location:escape_only}s, "this":"%{public}p"}
WIFI_LOC: Overriding fPerformScanOnWake = %{private}d
WIFI_LOC: Overriding fIsUseNetworkLocationProvider = %{private}d
Fence: failed to determine airplane mode
Fence: CLFenceMonitorWifi, shutdown
Fence: airplane mode is now, %{public}d, was, %{public}d
Fence: companion connected is now, %{public}d, was, %{public}d
Fence: Starting to monitor %{private}s/%{private}s for %{private}s
{"msg%{public}.0s":"Wifi startMonitoring fence without key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: Stopping monitoring for %{private}s/%{private}s
Fence: Got monitoring data changed for %{private}s/%{private}s; recalculating
isRecalculate, %{private}d, fIsRecalculationPending, %{private}d, sinceLastRecalculationTrigger, %{private}.1lf
Fence: power assertion no longer needed
Fence: recalculate, take power assertion
Fence: ignore recalculation, shut down?
Fence: resetConsecutiveExits start, %{public}.1lf, count, %{public}d
Fence: ignoring recalculateNow, shut down?
Fence: Recalculating monitored WiFis for %{private}ld monitored fences, %{public}d,%{public}d
Fence: No visible APs to use for fence calculation
Fence: Including %{private}ld visible APs in fence calculation
Fence: avoid fence calculateAPsForFences, numOfFences, %{private}lu, airplane, %{public}d
Fence: isWifiTrackingAvailable is false
Fence: fIsContinuousMonitoringNeeded, %{private}d
Fence: considered in leash, %{private}d
Fence: considered not in leash, %{private}d
Fence: exit sequence is too long, reset, sinceSequenceStart, %{private}.1lf, %{private}.1lf
Fence: Setting %{private}ld background scan entry networks
Fence: Setting %{private}ld background scan exit networks
Fence: recalculate, release power assertion
Fence: Device woke; sending trigger
Fence: Device is about to go to sleep
Fence: WiFi just lost (from %{private}d to %{private}d); sending trigger, aboutToSleep, %{private}d, recentlyWoke, %{private}d,
Fence: about to sleep or recently woke without WoW, ignoring, kNotificationReachability
Fence: WiFi just connected (from %{private}d to %{private}d); sending trigger, aboutToSleep, %{private}d, recentlyWoke, %{private}d,
Fence: take power assertion, reason, %{private}s, airplane, %{private}d
Fence: power assertion not needed, reason, %{private}s, airplane, %{private}d, isMonitoringFences, %{private}d
CL: CLFenceMonitorWifi::onStatusNotification
{"msg%{public}.0s":"CLFenceMonitorWifi::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"invalid db pointer", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#sqlitetransaction, begin exclusive transaction failed
#sqlitetransaction, commit failed
rollback #sqlitetransaction
#sqlitetransaction, rollback transaction failed
{"msg%{public}.0s":"#sqlitetransaction error", "path":%{public, location:escape_only}s, "rc":%{public, location:SqliteResult}.*P, "errmsg":%{private, location:escape_only}s, "autocommit":%{public}d}
#Warning SedentaryAlarm,Failed entitlement check,%{public}s
[SedentaryTimerTriage] SedentaryAlarm, handling SedentaryTimerStart message!
[SedentaryTimerTriage] SedentaryAlarm, is not qualified!
SedentaryAlarm,Failed to start,nil dictionary
[SedentaryTimerTriage] SedentaryAlarm, handling SedentaryTimerStop message!
SedentaryAlarm,Failed to query,nil dictionary
SedentaryAlarm,subscription changed, %d, %s, %p
CL: CLSedentaryTimerSubscription::onSedentaryTimerAlarm
{"msg%{public}.0s":"CLSedentaryTimerSubscription::onSedentaryTimerAlarm", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLSignalEnvironmentProvider is supported: %{public}d
CLSE, server, %{public}s, overridden, 1
CLSE, server, %{public}s, overridden, 0
CLSE, Client registered for notification %{public}d
CLSE, Client unregistered for notification %{public}d
#Error,CLSE,onLocationNotification,null CSE pointer
#Error,CLSE,onLocationNotification,null HRSE pointer
CLSE,fromSignalEnv,%{public}d,toSignalEnv,%{public}d,fromSignalEnvFidelityLevel,%{public}d,toSignalEnvFidelityLevel,%{public}d
CLSE,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf
CLSE,could not setUpdateSource AVL file updater
CLSE,could not setUpdateRate AVl file updater
CLSE,download status,NONE
CLSE,download status,STARTED
CLSE,download status,COMPLETED
CLSE,downloaded,%{public}s
#Warning,Cannot set protection class for CLSE downloaded file,%{public}s
CLSE,decompressed,%{public}s,to,%{public}s
#Warning,Cannot set protection class for CLSE decompressed file,%{public}s
CLSE,download status,FAILED
CLSE,download request failed,%{public}s,retryMultiplier,%{public}d
CLSE,download status,%{public}d
CL: CLSignalEnvironmentProvider::onSignalEnvironmentUpdated
{"msg%{public}.0s":"CLSignalEnvironmentProvider::onSignalEnvironmentUpdated", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSignalEnvironmentProvider::onLocationNotification
{"msg%{public}.0s":"CLSignalEnvironmentProvider::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
received weather updated with nill weather conditions
{"msg%{public}.0s":"received weather update for local location", "Timestamp_s":"%{private}.09f", "Pressure (Pa)":"%{private}.8f", "date":%{private, location:escape_only}@}
HRStop detect in stairclimber model during state,%{public}d
StairStop,state,%d,onCnt,%d,longStd,%f,shortStd,%f,exertionDelta,%f,exertionLow,%d,machineFreq,%f,on,%d,offCnt,%d,headCnt,%d,eDiff,%f,maxH,%f
MaxAllowedSecondsForIndoorOutdoorDetector was forced to %f seconds
Location type was forced to %ld
IndoorOutdoor,starting session,currentState,%ld,disableDistance,%{public}d,forceLocation,%{public}ld,overrideSeconds,%{public}f
IndoorOutdoor,last state,time,%f,new location type,%ld,confidence,%ld,probability,%f
IndoorOutdoor,TimeExceeded,maxAllowed,%f,timePassed,%f,locType,%d,distance,%f,outdoorProbability,%f
IndoorOutdoor,update,old probability,%{public}f,confidence,%{public}ld,state,%{public}ld,new probability,%{public}f,gpsOutdoor,%{public}f,wifiIndoor,%{public}f,alsOutdor,%{public}f,confidence,%{public}ld,state,%{public}ld
IndoorOutdoor,probabilities,llr,%{public}f,discordant,%{public}f,timeSinceStart,%{public}f,totalDistance,%{public}f,gpsOutdoor,%{public}f,wifiIndoor,%{public}f,alsOutdoor,%{public}f,probability,%{public}f,confidence,%{public}ld,location,%{public}ld
IndoorOutdoor, low confidence estimate,probability,%{public}f
WifiTimer, set, power, now
{"msg%{public}.0s":"indeterminate wifi power state", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
WifiTimer, set, scan, %{public}d
WifiTimer, set, scanbusy, %{public}d
@EmerWarn, ScanErrorBusy, %{public}s, retry in, %{pupblic}lld, reqtype, %{public}d
WifiTimer, set, scanerror, %{public}d
WifiTimer, nextscan, %{public}d, timer
WifiTimer, set, linkstatus, now
@WsbTimer, buffer, %{public}d
@WifiTimer, set, motion, %{public}d
@WifiTimer, skip, motion
WsbAls, resulttag, %{public}d, wsbtag, %{public}d, delay, %{public}d, set, %{public}d
@WsbTimer, alsresult, %{public}d
WifiTimer, set, alsreply, now
@WsbTimer, reach, %{public}d
WifiTimer, set, reach, now
WifiTimer, set, wake, now
@WifiTimer, set, locreq, %{public}d
@WifiTimer, set, suppressed, %{public}d
@WifiTimer, skip, locreq, %{public}d, %{public}d
@WsbTimer, fired, 0
Run, WorkRate, %f, distance(m), %f, duration(s), %f, mets, %f, fMetsScaling, %f, endTime, %f, currentPace, %f, isStroller, %d, metsStrollerCorrected, %f
Run, WorkRate, Grade type, %d, vertical speed %f, interval %f, workrate %f, mets %f, mets + grade %f, percent grade %f
Run, WorkRate, energy, %.1f,mets from intensity, %.1f
Run,WorkRate,finalUserMets,%f,finalTruthMets,%f
Run,fitness machine,computeTime,%.3f,startTime,%.3f,wr,%f,vertSpeed,%f,userMets,%f,truthMets,%f
{"msg%{public}.0s":"#Stream Resending motion alarm request"}
{"msg%{public}.0s":"#Stream We haven't received an update in a while"}
{"msg%{public}.0s":"#Stream Notifying motion alarm", "state":%{public, location:CLLocationProvider_Type::MotionDetected}lld}
{"msg%{public}.0s":"#Stream enabling motion alarm"}
{"msg%{public}.0s":"#Stream disabling motion alarm"}
{"msg%{public}.0s":"#Stream Motion alarm update without any state"}
@ClxCell, supported, %{public}d
@ClxCell, enabled, %{public}d
CellLoc, delete CLUnifiedCellLocationProvider
CellLoc, registerForNotificationInternal, notification, %{public}d
CellLoc, unregisterForNotificationInternal, notification, %{public}d
CellLoc, shutdown
@CellFlow, refresh, %{public}s
@CellFlow, outcome, %{public}s, UclpMetric
CellLoc, getCellFromTilesManager, isFound, %{public}d, cell, %{private}s, location, %{private}s
CellFlow, timer, %{public}s, %{public}.0f
CellFlow, skipnotify, in, %{public}d, new, %{public}d, retval, %{public}d, cell, %{public}d, latlon, %{public}d
@ClxCell, Fix, 0, ll, N/A, %{public}s
CellFlow, requestWifiLocationUpdate, reason, %{public}s
Cell, kNotificationReset
Cell, kNotificationLocationServicesStatus
UclpMetric, heartbeat, registrants, %{public}d, requests, %{public}d, infonotify, %{public}d, monitor, %{public}d
UclpMetric, regperiod, %{public}d
CellLoc, onCompanionNotification, notification, %{public}d, Tiles
@CellFlow, ctnotify, %{public}s, havedata, %{public}d
CellFlow, outcome, LS Off
CellService, unknown, %{public}s
@CellFlow, skipcalc, clients, %{public}d, get, %{public}s
CellLoc, ignore timer
CellFlow, timer, cancel, -1
CellQuery, notify, %{public}d
CellQuery, fail, acc, %{public}.1f, empty, %{public}d
CellQuery, response
CellQuery, no client
CellFlow, clearcells, %{public}s
CL: CLUnifiedCellLocationProvider::onStatusNotification
{"msg%{public}.0s":"CLUnifiedCellLocationProvider::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLUnifiedCellLocationProvider::onTelephonyNotification
{"msg%{public}.0s":"CLUnifiedCellLocationProvider::onTelephonyNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLUnifiedCellLocationProvider::onNetworkLocationNotification
{"msg%{public}.0s":"CLUnifiedCellLocationProvider::onNetworkLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLUnifiedCellLocationProvider::onClientNotification
{"msg%{public}.0s":"CLUnifiedCellLocationProvider::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLUnifiedCellLocationProvider::onCompanionNotification
{"msg%{public}.0s":"CLUnifiedCellLocationProvider::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLUnifiedCellLocationProvider::onTileDownloadNotification
{"msg%{public}.0s":"CLUnifiedCellLocationProvider::onTileDownloadNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLUnifiedCellLocationProvider::onDelayedCellPropagationTimer
{"msg%{public}.0s":"CLUnifiedCellLocationProvider::onDelayedCellPropagationTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
moving,%d,now,%f
CLSensorCalibrationStaticDetectorAccel::fire()
RawAccelerometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f
FilteredAccelerometer,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,readyX,%d
Variance,x,%20.20f,y,%20.20f,z,%20.20f,timestamp,%20.20f,Moving,%d
CL: CLSensorCalibrationStaticDetectorAccel::onAccelerometerData
{"msg%{public}.0s":"CLSensorCalibrationStaticDetectorAccel::onAccelerometerData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
(stddev samples) w/ turn, %f, %d, w/o turn, %f, %d, threshold, %f, %f
Turn, %s, Time, %f, Total Strokes, %d, Current Strokes, %d, Style, %d, Result, %d
Converged,freestyle,%d,backstroke,%d,breaststroke,%d,butterfly,%d
searchMedian, %f, historicalDistributionCount, %lu, historicalMatchingDistributionCount, %lu
distribution,localLimits,min,%f,max,%f
distribution,historicalSessionLimits,min,%d,max,%f
distribution,lastGood-populationLimits,min,%d,max,%f
lap detected with one or less strokes,strokes,%lu,lapType,%d
FST DM Features, startTime, %f, accelMag, %f, inertialAccelZMag, %f, rotationalAccelZMag, %f, rotationToAccelCorrelation, %f, pctDominanceCrownPlane, %f, gravityX, %f, pBody, %f, FSTMotionType, %d
FSTMotionClassifier, classifyByLikelihoodBody, FSTMotionType, %d, pBody, %f
FSTMotionClassifier, containsBodyMotion, %d, isNotDominantlyPlanar, %d, isBodyRangeAccelZMag, %d, isModerateBodyLikelihood, %d
Type,%s,bias.x,%20.20f,bias.y,%20.20f,bias.z,%20.20f,variance.x,%20.20f,variance.y,%20.20f,variance.z,%20.20f,doingBiasEstimation,%d
az_prev is not initialized before usage
#Warning, PLOS: invalid outside offset %{public}f
#Warning, PLOS: bad poly, bad!
#Warning, PLOS: invalid step size %{public}f
#Warning, PLOS: miniscule edge!
#Warning, PLOS: invalid distance %{public}F
#Warning, PLOS: invalid polygon size %{public}d
#Warning, PLOS: edge too small!
WifiTimer, reissue, %{public}d, force, %{public}d, time, %{public}d, %{public}.1f, %{public}.1f, %{public}.1f, place, %{public}d, %{public}d
@EmerTick, wifi, %{public}.1f
WifiFlow, scanreply, warn, ToggleOff
@EmerTick, scanreply, %{public}.1f
@EmerFlow, ScanReply, %{public}s, aps, %{public}lu, tte, %{public}.1f
@EmerTick, scanreply5ghz, %{public}.1f
@EmerFlow, %{public}s, %{public}s, aps, %{public}lu, tte, %{public}.1f
@EmerWarn, unexpected state, onWifiNotification, %{public}d, #CloneMe
@EmerWarn, ignore scan, %{public}s
WifiFlow, scanreply, warn, pre-privacy, %{public}d, scan, %{public}d, privacy, %{public}d
@WifiFlow, scanreply, aps, %{public}lu, type, %{public}s, lastused, %{public}d, use, %{public}d, history, %{public}ld, lsbclients, %{public}d, %{public}d, %{public}d, reqtype, %{public}s
WifiFlow, scanreply, warn, error
WifiFlow, scanreply, warn, busy
@WsbGroup, add, %{public}lu, aps, %{public}lu, time, %{public}.1f
@WsbGroup, last, %{public}lu, aps, %{public}lu, time, %{public}.1f
WsbMetric, scanaps, %{public}lu
@WsbDiscard, privacy, %{public}.1f, aps, %{public}ld, delta, %{public}.1f
WsbMetric, groupresult, privacy, %{public}d
@WsbDiscard, privacy, %{public}.1f, aps, %{public}ld
@EmerTick, toggle, %{public}.1f
@EmerFlow, ToggleOn, %{public}.1f
@WifiFlow, alsreply, aps, 0, tag, -1
WsbMetric, als, %{public}s, %{public}s, %{public}ld
{"msg%{public}.0s":"#pre-wifi-position-calculation-state-update, als request results indicate success", "tag":%{public}d, "requestType":%{public, location:escape_only}s}
@WifiFlow, alsreply, aps, %{public}d, tag, %{public}d
EmerCheck, als, top, highinteg, %{public}d, emer, %{public}d, state, %{public}d
@EmerTick, alsreply, %{public}.1f
@EmerFlow, AlsReply, aps, %{public}d, tag, %{public}d, queryType, %{public}d, tte, %{public}.1f
@EmerTick, preliminaryAlsReplyTick, %{public}.1f
@EmerFlow, %{public}s, aps, %{public}d, tag, %{public}d, queryType, %{public}d, tte, %{public}.1f
WsbAls, reply, 0
WlpMetric, locreq, %{public}s, dt, %{public}d
WifiFlow, locreq, skip, WifiOff
@WifiFlow, locreq, %{public}s, %{public}s, current, %{public}s
@WifiFlow, platform not support 5GHz, revert to default inter-locreq state
@WifiFlow, inter-locreq state per request type, %{private}s, current %{public}s, staging %{public}s
WlpMetric, heartbeat, requesters, %{public}d, aware, %{public}d, gf, %{public}d, slc, %{public}d, speedest, %{public}d, cpi, %{public}d, registrant, %{public}d, scanready, %{public}d, emer, %{public}d, timer, %{public}d, other, %{public}d
WlpMetric, heartbeat, locreqtypes, %{public}d, cpi, %{public}d, lowpower, %{public}d, clientupdate, %{public}d, emergency, %{public}d, other, %{public}d
WlpMetric, heartbeat, scanreqtypes, %{public}d%{public}s, other, %{public}d
WlpMetric, heartbeat, empty scans per scanreqtypes %{public}s
WlpMetric, heartbeat, misc, %{public}d, alsAps, %{public}d, fixes, %{public}d, scanErrors, %{public}d, scanBusys, %{public}d
WlpMetric, heartbeat, scanreqtype, %{public}s, fix ap count per bucket %{public}s
WlpMetric, clients, beat, %{public}d, sum, %{public}d, bin, %{public}d
WlpMetric, locreq, heartbeat, dt, %{public}d
WlpMetric, clients, reg, %{public}d, sum, %{public}d, bin, %{public}d
WlpMetric, clients, unreg, %{public}d, sum, %{public}d, bin, %{public}d
@WifiFlow, reset inter-locreq state, current, %{public}s, staging, %{public}s
@EmerFlow, StateChange, wasEmer, %{public}d, nowEmer, %{public}d
@EmerTick, on, %{public}.1f
@EmerFlow, RequestWifiOn
@EmerFlow, Off, any, %{public}.1f, sufficient, %{public}.1f
@EmerFlow, RequestWifiOff
WsbReproc, pass, %{public}d, groups, %{public}ld
@WsbReproc, inrange, %{public}.1f, count, %{public}d
@WsbDiscard, age, %{public}.1f, aps, %{public}d, delta, %{public}d
WsbMetric, groupresult, aged, %{public}d
WifiTimer, nextscan, %{public}d, haveLoc, %{public}d, codepath, %{public}s
remove old APs from scan history, count, %{public}ld, max_secs, %{public}lld
@WifiAps, history, %{public}lu, add, %{public}lu
{"msg%{public}.0s":"system time changed!"}
{"msg%{public}.0s":"updated scheduled event timer", "nextFireDelay":"%{public}f"}
Unable to persist swim distribution
Unable to purge old records.
Unable to get the number of distributions
Unable to delete all distributions!
CLSwimPersistence,getEntries,unable to get entries,numberOfRecords,%d
CLSwimPersistence,unable to get entries for uuid %{public}s
CLSwimPersistence, querySince, failed to bind id in query, %{public}llu
#Warning returning default entry after querying empty db for most recent lap
CLSwimPersistence, aggregateRecordsInternal, unable to purge records.
CLSwimPersistance, unable to insert swim record.
Workout Predictor - Saved session id found, sending de-escalation: %s
Workout Predictor - Retrieving session id: %s
Workout Predictor - Saving session id: %s to daemon cache.
Workout Predictor - Clearing session id from daemon cache.
New AP escalation detected for workout type, %{public}ld, with startTime, %{public}f
Current state of Workout Predictor: %{public}d
{"msg%{public}.0s":"Sending workout event", "event time":"%{public}f", "event type":%{public}ld, "workout type":%{public}ld}
Failed to get workout start reminder delay for workout type: %ld.
Workout Predictor Deescalating,shouldMute,%{public}d,startAlertEnabled,%{public}d,tier2,%{public}lu,backgroundDeescalate,%{public}d,isTrackingAltWalk,%{public}d,vehicular,%{public}d,supportedAlertType,%{public}d
{"msg%{public}.0s":"Check if workout should escalate.", "is start enabled":%{public}hhd, "is new":%{public}hhd, "allow background":%{public}hhd, "is allowed type":%{public}hhd, "should mute":%{public}hhd}
isWaitingForIndoorOutdoorDisambiguation,%{public}d,permission,%{public}d,enabled,%{public}d
{"msg%{public}.0s":"should mute - start", "previous workout type":%{public}ld, "current workout type":%{public}ld, "previous workout location type":%{public}ld, "current workout location type":%{public}ld, "should mute":%{public}d, "previous mute time - start":"%{public}f", "previous mute interval - start":"%{public}f"}
Checking if resuming the same workout: previous=%{public}ld new=%{public}ld
Checking to see if we should retract stop alert. Workout is the same.
Checking if resuming in the same location: previous=%{public}ld new=%{public}ld
User started activity again. Check to see if we should retract stop alert. Bringing up indoor/outdoor detector.
{"msg%{public}.0s":"Transitioned to kWaitForLabel state.", "escalated workout type":%{public}ld, "elapsed epochs":%{public}d}
Transitioned to kLabelAvailable state, wait for indoor/outdoor.
Transitioned to kLabelAvailable state.
Transitioned to kWorkoutStarted.
Transitioned to kWorkoutStopped (stop was detected after start confirmation).
Start alerts will be muted for %{public}f seconds for type %{public}ld.
Received indoor/outdoor update.
Received indoor/outdoor disambiguation for a one button workout, new location update %{public}ld
Updating label startTime to %{public}f and tearing down indoor/outdoor.
Updating label to %{public}ld.
User confirmed start of a workout (and stop is enabled).
User confirmed start of a workout.
User started workout based on prediction.
User started workout (%{public}ld) that differs from prediction (%{public}ld).
{"msg%{public}.0s":"Location type differs", "Detected":%{public}ld, "User specified":%{public}ld}
Trying to bringup ActiveStateDetector
Trying to bringup ActiveStateDetector,but already running
Bringing up ActiveStateDetector
Trying to tear down ActiveStateDetector
Tearing down ActiveStateDetector
Workout, Error stopping, no active workouts
ActiveStateDetector should be active?
Indoor/outdoor detector unable to disambiguate location for walking
Indoor/outdoor detector unable to disambiguate location for running
Called updateWorkoutTypeForOneButtonWorkouts when not in a one button workout
Updated workout type for one button workout to %{public}ld
Bringing up WorkoutLabeler
Tearing down labeler
Tearing down stop detector
Bringing up Tier2 Classifier
Tear down tier2 classifier
Trying to tear down TurnDetector,%d
Trying to bring up TurnDetector,%d
Bringing up Indoor/Outdoor detector,isActive,%{public}d
Teardown indoor/outdoor,isActive,%{public}d
Forced location signal, new workout location: %zd
Cannot force location signal; isValidWorkoutForLocationTbd: %d, IsLocationTbd: %d, fEnableForcedWorkoutLocationUpdatesFromSPI: %d
Entering a one button workout
Transitioned to kInit (stop was detected prior to start confirmation).
{"msg%{public}.0s":"Workout stop detected", "at":"%{public}f", "endTime":"%{public}f", "reason":%{public}d}
Tearing down. Resetting workout prediction.
Tearing down. Resetting workout prediction. Notifying clients.
Tearing down for StopDisabled
Bringing up StopDetector
userWorkoutType: fStopDetector->setWorkoutType(%ld,%ld)
predictedWorkoutType: fStopDetector->setWorkoutType(%ld,%ld)
Retracting stop alert.
{"msg%{public}.0s":"In order to retract a stop alert we need the sessionId to not have been cleared out, did something change?", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Tearing down StopDetector and IndoorOutdoor detector.
Workout Predictor is %s GPS
Resetting mute alerts for start
CLCyclingWorkoutDistanceController, received event, %{public}ld, workout, %{public}ld, current state, %{public}d
CLCyclingWorkoutDistanceController, state after workout event, %{public}d
CLCyclingWorkoutDistanceController, toggling gps, %{public}d
CLCyclingWorkoutDistanceController, notifying clients with num updates, %{public}lu, start, %{public}f, end, %{public}f
CLCyclingWorkoutDistanceController, sending update, %{public}f
Absolute Altimeter Context created
registering for phone detailed connection updates on watch
unsubscribing from Wifi notifications
unsubscribing from GPS notifications
absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source timestamp %f this should be one shot
checking if DEM underground, latest alt timestamp %f, latest abs alt %f
forcing GPS, detected underground, altitude %f, DEM %f, DEM source %d, time, %f
absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source %d, timestamp %f
GPS too far from DEM, not updating altitude
will not force Wifi/GPS, phone connected %d, phone has pressure %d, and sensor is dry
subscribing to Wifi notifications %f
subscribing to GPS notifications %f
latest KF pressure %f
average KF elevation %f, average timestamp %f
absolute altimeter wet state updated to %d
absolute altimeter: watch wet, forcing location
bias age is %f
absolute altitude corrected %f, absolute altitude before correction %f, weather %f, timestamp %f
absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source %d, timestamp, %f, bias uncertainty, %f
in outdoor workout: location buffer empty, pressure timestamp, %f
discrepancy between DEM and altiude in workout, discrepancy, %f, DEM, %f, altitude, %f, pressure timestamp, %f, location timestamp, %f
received phone connection updates, is phone connected %d, does phone have pressure sensor %d
GaitMetricsHistory not accessible
[GaitMetricsHistory] Database inaccessible, unable to query
[GaitMetricsHistory] Most recent gait metrics: No recent records in database
[GaitMetricsHistory] Most recent gait metrics: Query error
[GaitMetricsHistory] Most recent gait metrics: unexpected return type
[GaitMetricsRecorderDb] Inserting record %{public}f
consolidated database not valid; unable to drop obsolete tables
Class B database not valid; unable to drop obsolete tables
Cross Training, Compendium METS, METS, %f
HRMaxEstimator,vo2MaxObservedHRMax,%{private}f,ageAndBetaBlockerPredictedHrMax,%{private}f,hrMaxCeiling,%{private}f,estimatedHRMax,%{private}f
HRMaxEstimator,clusterHrMean,%{private}f,vo2MaxModelSource,%{private}d
HRMaxEstimator,observedHRMax,%{private}f
{"msg%{public}.0s":"#CLAvengerObservationReporterService changed state", "_currentState":%{public}d, "_currentContext.cameraForegrounded":%{public}hhd}
{"msg%{public}.0s":"#CLAvengerObservationReporterService received avenger scanner registration"}
{"msg%{public}.0s":"#CLAvengerObservationReporterService received avenger scanner unregistration"}
{"msg%{public}.0s":"#CLAvengerObservationReporterService onAvengerAdvertisementDetected: saveBeaconPayloads", "address":%{private, location:escape_only}@, "advertisementData":%{private, location:escape_only}@, "UUID":%{private, location:escape_only}@, "validity":%{private}hhd}
{"msg%{public}.0s":"#CLAvengerObservationReporterService WARN: onAvengerAdvertisementDetected: saveBeaconPayloads error received", "error":%{public, location:escape_only}s}
{"msg%{public}.0s":"#CLAvengerObservationReporterService onAppMonitorNotification", "notification":%{private, location:escape_only}s, "bundleId":%{private, location:escape_only}s}
{"msg%{public}.0s":"#CLAvengerObservationReporterService WARN, Received expected CLAppMonitor notification type for camera bundle ID", "notification":%{private, location:escape_only}s}
{"msg%{public}.0s":"Assertion failed, syncgetIonosphereParameters stub should not be called.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Creating managed location database %s (count triggers %d, use cache %d)
Data protection is enabled, creating in-memory database for table %s
Persistent database failed to create despite data protection not enabled. Falling back to in-memory database
ExerciseMinuteThresholdUpdater, begin tracking elapsed time for updates
ExerciseMinuteThresholdUpdater, could not get records from VO2MaxOutputStore, CMError, %d
ExerciseMinuteThresholdUpdater, no vo2max records found for update
ExerciseMinuteThresholdUpdater, previousValue, %{private}f, targetValue, %{private}f, lastVo2max, %{private}f, updateValue, %{private}f, daysElapsed, %{public}f
FST, FSTMotionType, %d, metsHR, %f, useHR, %d, userMets, %f, truthMets, %f, endTime, %f, semiStatMets, %f, userMetSource, %d, isWalking, %d, isTypeStatic, %d
{"msg%{public}.0s":"#Stream Source now available", "source":%{public, location:CLStreamingAwareLocationProviderStateMachine::LocationSource}lld}
{"msg%{public}.0s":"#Stream Source no longer available", "source":%{public, location:CLStreamingAwareLocationProviderStateMachine::LocationSource}lld}
{"msg%{public}.0s":"#Stream Client interest changed", "notification":%{public, location:CLLocationProvider_Type::Notification}lld, "is interested":%{public}d}
{"msg%{public}.0s":"#Stream Stopping location for source", "source":%{public, location:CLStreamingAwareLocationProviderStateMachine::LocationSource}lld}
{"msg%{public}.0s":"#Stream State is out of sync with registrations"}
{"msg%{public}.0s":"#Stream Local GPS is forbidden right now.  Downgrading to wifi accuracy"}
{"msg%{public}.0s":"#Stream Starting location for source", "source":%{public, location:CLStreamingAwareLocationProviderStateMachine::LocationSource}lld, "notification":%{public, location:CLLocationProvider_Type::Notification}lld, "include motion":%{public}d}
client of CLDataProtectionManager is requesting a re-broadcast of data availability
#dataprotection postDataAvailability, %{public}d
{"msg%{public}.0s":"Client lacks proper entitlement to hint _CLARSessionState", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"Client lacks proper entitlement to hint _CLVIOEstimation", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"Client lacks proper entitlement to hint _CLVLLocalizationResult", "client":%{public, location:escape_only}s}
No parameters for on body is available for %s
Parameters: theta0, %f, theta1, %f, theta2, %f, theta3, %f, theta4, %f, theta5, %f, minLowPower, %f, maxLowPower, %f, maxHighPower, %f, lowBandStart, %d, lowBandStop, %d, highbandStart, %d, highBandStop, %d, wakeThreshold, %f, oddsThreshold, %f, medianFilterSize, %u, confidenceThreshold, %f, useHysteresis, %d, useAngleOverride, %d, angleMetricThreshold, %f
Using the manufacturer specific parameters (%s): %s
Using the default parameters: %s
#Warning Using the hardcoded parameters
Invalid parameters received:
%{public}s
Rejection: ModelContinuousWalking missing required feature inputs
CLMobility::SteadinessModelContinuousWalking::Result,hkEndTime,%{public}.2f,likelihoodOK,%{public}.2f,likelihoodNotOK,%{public}.2f,rawSteadiness,%{private}.2f,rejectionStatus,%{public}d,numValidBouts7Days,%{private}d,numValidBouts28Days,%{private}d
CLMobility::SteadinessModelContinuousWalking::Features,allBoutsBoutDurationCv,%{private}.2f,allBoutsBoutDurationMedian,%{private}.2f,allBoutsCycleTimeCv,%{private}.2f,intermediateBoutsWalkingSpeedMedian,%{private}.2f,intermediateBoutsWalkingSpeedMedianSqrtheightnorm,%{private}.2f,intermediateBoutsWalkingSpeedCv,%{private}.2f,intermediateBoutsCycleTimeCv,%{private}.2f,intermediateBoutsStepLengthMedian,%{private}.2f,intermediateBoutsStepLengthMedianHeightnorm,%{private}.2f,intermediateBoutsDoubleSupportPercentageMedian,%{private}.2f,shortBoutsWalkingSpeedMedian,%{private}.2f,shortBoutsWalkingSpeedMedianSqrtheightnorm,%{private}.2f,shortBoutsStepLengthMedianHeightnorm,%{private}.2f,shortBoutsCycleTimeMedian,%{private}.2f,shortBoutsDoubleSupportPercentageMedian,%{private}.2f,shortBoutsWalkingSpeedCv,%{private}.2f,shortBoutsCycleTimeCv,%{private}.2f,shortBoutsStepLengthCv,%{private}.2f,longBoutsWalkingSpeedCountRatioLog,%{private}.2f
SteadinessModelContinuousWalking::extractFeatures,classificationTime,%{public}.2f,numBouts,%{public}lu,numIntermediateWalkingSpeeds,%{public}lu,numIntermediateDST,%{public}lu,numIntermediateStepLengths,%{public}lu,numDurations,%{public}lu,numCycleTimes,%{public}lu,numIntermediateCycleTimes,%{public}lu,numShortWalkingSpeeds,%{public}lu,numShortDST,%{public}lu,numShortStepLengths,%{public}lu,numShortCycleTimes,%{public}lu,numLongBouts,%{public}lu,numAllBouts,%{public}lu
Took, inc ref, %d, %s, thisReason, %s
%s, %s
Release power assertion, %s, heldFor, %.2lf
Release power assertion, dec ref, %d, %s
{"msg%{public}.0s":"CLStatusBarIconManagerNotifier Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CL: #SystemServiceSwitch Received sync darwin notification
{"msg%{public}.0s":"#SystemServiceSwitch Received sync darwin notification", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"#SystemServiceSwitch invalid or missing switch sync state.  Initializing...", "oldValueClass":%{public, location:escape_only}@}
{"msg%{public}.0s":"#SystemServiceSwitch Detected mismatch between local state and sync state.  Deferring to sync state.", "newState":%{public}hhd}
{"msg%{public}.0s":"#SystemServiceSwitch setting sync state", "enabled":%{public}hhd}
sbim: Got client notification
sbim: Posting status bar icon visibility change notification
{"msg%{public}.0s":"#sbim: unsupported attempt to set icon visibility", "class":%{public}d, "enabled":%{public}hhd}
Clearing status bar icon enabled states
{"msg%{public}.0s":"#sbim: entity class state mask", "class":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, "mask":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}
{"msg%{public}.0s":"#sbim: executing arrow demotion timer", "state":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "previousState":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "newMask":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}
{"msg%{public}.0s":"#sbim: scheduling arrow demotion timer", "state":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "delay":%{public}d}
{"msg%{public}.0s":"#sbim: promoting arrow", "state":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "mask":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}
{"msg%{public}.0s":"#sbim: only cancelling a demotion timer due to another demotion timer in-flight", "state":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "mask":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, "newMask":%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}
{"msg%{public}.0s":"Got max arrow state!", "entityClass":%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld}
#sbim: E911 is active; forcing icon on.
{"msg%{public}.0s":"#sbim: Location icon should now be in state", "IconState":%{public, location:escape_only}s, "SystemServiceSwitchEnabled":%{public}hhd}
CL: CLStatusBarIconManager::onClientNotification
{"msg%{public}.0s":"CLStatusBarIconManager::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"The capabilities cache has been accessed before being populated!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"I must have already been invalidated by CLDaemonInUseAssertion", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CL: InUseAssertion/kCLConnectionMessage
{"msg%{public}.0s":"InUseAssertion/kCLConnectionMessage", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"#Warning unrecognized message", "MessageName":%{public, location:escape_only}s}
CL: CLDaemonInUseAssertion::handleMessageInUseAssertion
{"msg%{public}.0s":"CLDaemonInUseAssertion::handleMessageInUseAssertion", "event":%{public, location:escape_only}s, "this":"%{public}p", "message":"%{public}p"}
#warning InUseAssertion already taken by %{public}s
#warning #CLIUA Not entitled as usage oracle... ignoring InUseAssertion taken by %{public}s
#CLIUA InUseAssertion taken by %{public}s malformed: lacking required argument
#CLIUA Neither bundleIdentifier nor bundlePath specified... ignoring InUseAssertion taken by %{public}s
#CLIUA Assertion requested with no reason... ignoring InUseAssertion taken by %{public}s
{"msg%{public}.0s":"#CLIUA Received invalid assertion level", "assertionLevel":%{public}d}
{"msg%{public}.0s":"#CLIUA expecting that fInUseAssertionContainer is nil, but it appears to have already been set! This is potentially a major privacy leak and is likely indicative of a memory leak or a double-assertion", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
%s is %s for %s
{"msg%{public}.0s":"#Stream allowing streaming to companion due to settings override"}
{"msg%{public}.0s":"#Stream cached location", "found":%{public}d}
Stream clearing cached notification for %d
{"msg%{public}.0s":"#Stream notifying location", "client":%{public, location:escape_only}s, "accuracy":"%{public}f", "type":%{public, location:CLLocationType}lld, "origin device":%{public, location:CLClientLocationOriginDevice}lld}
{"msg%{public}.0s":"#Stream notifying", "client":%{public, location:escape_only}s, "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"#Stream Invalid location source", "source":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Turning on step count notifications
Turning off step count notifications
{"msg%{public}.0s":"#Stream Received notification", "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"#Stream Received motion mediator notification"}
{"msg%{public}.0s":"#Stream Received step count notification"}
{"msg%{public}.0s":"#Stream Accuracy enablement assertion taken", "client":%{public, location:escape_only}s, "accuracy":"%{public}f"}
{"msg%{public}.0s":"#Stream Accuracy enablement assertion released", "client":%{public, location:escape_only}s}
CL: CLStreamingAwareLocationProvider::onStepCountNotification
{"msg%{public}.0s":"CLStreamingAwareLocationProvider::onStepCountNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLStreamingAwareLocationProvider::onLocalLocationNotification
{"msg%{public}.0s":"CLStreamingAwareLocationProvider::onLocalLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLStreamingAwareLocationProvider::onStreamedLocationNotification
{"msg%{public}.0s":"CLStreamingAwareLocationProvider::onStreamedLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLStreamingAwareLocationProvider::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLStreamingAwareLocationProvider::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLStreamingAwareLocationProvider::onManagerNotification
{"msg%{public}.0s":"CLStreamingAwareLocationProvider::onManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
WsbReproc, timer
WsbAls, reply, %{public}d
#Warning,CLMM,provideCacheHint,building,error:%{public}lld (%{public}@) "%{private}@"
#WarningCLMM,query failed (buildingsWithinDistance)
TILE: beginSeries
TILE: endSeries, size, %lu
TILE: endSeries, checking tile, count, %u,  localLocation, %14.8lf, %14.8lf
TILES: requestDownload, %.8f, %.8f
@WifiAps, als, %{public}lu, isNearby, %{public}d
TILE: macAddressResolved, invalid hash value, %s
attempting to create service location provider with NULL service name
Overriding youth type for outdoor cycling , beginTime, %f, before, %{public}d, after, %{public}d, speed, %{public}f
{"msg%{public}.0s":"Can't set the sqlite lookaside buffers size to 64K", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"sqlite3_trace", "query":%{private, location:escape_only}s}
{"msg%{public}.0s":"sqlite3_profile", "db_ptr":"%{public}p", "db_name":%{public, location:escape_only}s, "query":%{private, location:escape_only}s, "elapsed_ns":%{public}llu, "queue":%{public, location:escape_only}s}
Attempted to open an encrypted database
{"msg%{public}.0s":"openDatabase", "rc":%{public, location:SqliteResult}.*P, "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"pragma page_size = 4096", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"pragma journal_mode=WAL", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"pragma secure_delete", "useSecureDelete":%{public}hhd, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"pragma cache_size = 5", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"pragma cache_size = 50", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"pragma cache_spill = 500", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"pragma recursive_triggers = true", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"Failed to enable extended result codes", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"Database opened with read/write access was found to be read-only.", "properties.readOnly":%{public}d, "sqlite3_db_readonly":%{public}d, "last POSIX errNo":%{public}d, "File control rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"failed to obtain database handle", "errno":%{public}d, "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"Failed to close partially opened database", "rc":%{public, location:SqliteResult}.*P}
{"msg%{public}.0s":"Opening database", "path":%{public, location:escape_only}s}
{"msg%{public}.0s":"openDatabase failed to open a connection and then to clean up after itself"}
{"msg%{public}.0s":"Reference count increased", "path":%{public, location:escape_only}s, "referenceCount":%{public}d}
{"msg%{public}.0s":"Reference count decreased", "path":%{public, location:escape_only}s, "referenceCount":%{public}d}
{"msg%{public}.0s":"Destroying database", "path":%{public, location:escape_only}s}
Pedestrian, Using %s model
Rejection: SteadinessModelGaitBaseline missing required feature inputs
CLMobility::SteadinessModelGaitBaseline::Result,hkEndTime,%{public}.2f,likelihoodOK,%{public}.2f,likelihoodNotOK,%{public}.2f,rawSteadiness,%{public}.2f,rejectionStatus,%{public}d,numValidBouts7Days,%{private}d,numValidBouts28Days,%{private}d
CLMobility::SteadinessModelGaitBaseline::Features,balancePrior,%{private}.3f,intermediateBoutsStepLengthQ95Heightnorm,%{private}.3f,intermediateBoutsWalkingSpeedQ95Sqrtheightnorm,%{private}.3f,height,%{private}.2f
SteadinessModelGaitBaseline::extractFeatures,classificationTime,%{public}.2f,numBouts,%{public}lu,numIntermediateWalkingSpeeds,%{public}lu,numIntermediateStepLengths,%{public}lu
Rejection: ModelTemporalEntropy missing required feature inputs
CLMobility::SteadinessModelTemporalEntropy::Result,hkEndTime,%{public}.2f,likelihoodOK,%{public}.2f,likelihoodNotOK,%{public}.2f,rawSteadiness,%{private}.2f,rejectionStatus,%{public}d,numValidBouts7Days,%{private}d,numValidBouts28Days,%{private}d
CLMobility::SteadinessModelTemporalEntropy::Features,allBoutsMinGaitMetrics21StepLengthEntropyMeanLog,%{private}.2f,allBoutsMinGaitMetrics21CycleTimeEntropyMeanLog,%{private}.2f,allBoutsMinGaitMetrics21CycleTimeEntropy5thTo95thLog,%{private}.2f,allBoutsMinGaitMetrics21CycleTimeEntropyP5Log,%{private}.2f,allBoutsMinGaitMetrics21StepLengthPoincareSd1P5Log,%{private}.2f,allBoutsMinGaitMetrics21StepLengthPoincareSd1P95Log,%{private}.2f,allBoutsMinGaitMetrics21StepLengthPoincareSd2P5Log,%{private}.2f,allBoutsMinGaitMetrics21StepLengthPoincareSd2MeanLog,%{private}.2f,allBoutsMinGaitMetrics21CycleTimePoincareSd1P5Log,%{private}.2f,allBoutsMinGaitMetrics21CycleTimePoincareSd2P5Log,%{private}.2f
SteadinessModelTemporalEntropy::extractFeatures,classificationTime,%{public}.2f,numBouts,%{public}lu,numStepLengthEntropy,%{public}lu,cycleTimeEntropy,%{public}lu
Received message,type,%d,size,%lu
#Warning Error deserializing session override: %s
supported watch connected, phone subscribes to absolute altitude updates
#Warning error serializing Odometer(GPS) entry
#Warning error serializing Odometer(Elevation) entry
#Warning error serializing Odometer(Coarse Elevation) entry
supported watch disconnected, phone unsubscribes from absolute altitude updates
Time to the last received message from Watch is %lf. Lost connection to Watch.
#Warning Spectator subscriptions expired
coarse elevation src,enable,%d,elevationSpectator,%d,fitnessTracking,%d
phone, not sending altitude to watch, uncertainty %f
#Warning error serializing Absolute Altitude entry
sending altimeter data to watch: timestamp %f, altitude %f, accuracy %f, precision %f, status info %lu
CL: CLCompanionNotifierCompanion::onOdometerNotification
{"msg%{public}.0s":"CLCompanionNotifierCompanion::onOdometerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
%{public}s ear gesture
Removing client %{private}p
Unknown client instance %{private}p
Adding client %{private}p with priority %{public}d
Registering for ear gesture notifications
Unregistering for ear gesture notifications
Ear Gesture EnabledForTopClient: %{public}d (%{public}s)
Dispatching ear gesture to instance %{private}p from prototype %{private}s
%.1lf,DeadReckoning,%.2lf,fLastPASCDVelocityNotificationTime,%.2lf,fLastAccessoryLocation,%.2lf,fLastGPSLocationTime,%.2lf,fLastGPSPropagationTime,%.2lf
%.1lf,DeadReckoning,%s,%s,time,%.1lf,machCont,%.1lf,%{private}.8lf,%{private}.8lf
#SettingsMap,create,root,%{private}s
#SettingsMap,addBranch,root,%{private}s,failed to get shared this
#SettingsMap,addBranch,root,%{private}s,branch,%{private}s,failed to create branch
#SettingsMap,addBranch,root,%{private}s,branch,%{private}s,successful
#SettingsMap,create,branch,%{private}s,parent and/or root is empty
#SettingsMap,create,branch,%{private}s,parent,%{private}s,root,%{private}s
#SettingsMap,addBranch,branch,%{private}s,failed to get shared this
#SettingsMap,addBranch,branch,%{private}s,subBranch,%{private}s,root is empty
#SettingsMap,addBranch,branch,%{private}s,root,%{private}s,subBranch,%{private}s,failed to create branch
#SettingsMap,addBranch,branch,%{private}s,root,%{private}s,subBranch,%{private}s,successful
#SettingsMap,addLeaf,branch,%{private}s,failed to get shared this
#SettingsMap,addLeaf,branch,%{private}s,leaf,%{private}s,root is empty
#SettingsMap,addLeaf,branch,%{private}s,root,%{private}s,leaf,%{private}s,failed to create leaf
#SettingsMap,addLeaf,branch,%{private}s,root,%{private}s,leaf,%{private}s,successful
#SettingsMap,create,leaf,%{private}s,parent and/or root is empty
#SettingsMap,create,leaf,%{private}s,parent,%{private}s,root,%{private}s,type,%{private}d
%@ -> %s
Error in step count update
Sending pedometer event,%ld,eventTime,%.3f,%s
OdometerSuitability values,startDate,%.8f,suitableForRunning,%d,suitableForWalking,%d
StepCount subscription changed, %s, %p, %d
Cannot subscribe to step count updates, step counting is not available
Cannot subscribe to step count updates as step counting is not enabled
PedometerEvent subscription changed, %s, %p, %d
OdometerSuitabilityUpdate subscription changed, %s, %p, %d
query for step count was received but step counts were not available
Programmer error: Wrong parameters were passed!
Error querying step count data
Error querying pedometer data, %{public}d
Step count reset failed as it was not available!
#Warning Client %s does not have appropriate entitlement to access motion activity spi
CLDaemonClient received StrideCalibrationDump request,client,%s
Step count notifier not available
Cannot find step count proxy
received request for remote pedometer calibrations
Requested calibration type not recognized
No remote pedometer calibrations available
received request for pedometer calibrations
No pedometer calibrations available
CL: CLStepCountSubscription::onPedometerNotification
{"msg%{public}.0s":"CLStepCountSubscription::onPedometerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Warning FitnessMinuteEstimatorYouth (%{public}s), Invalid timestamps - ignored the epoch, epochStartTime:%{public}.3f, epochDuration:%{public}.3f
#Warning FitnessMinuteEstimatorYouth (%{public}s), Time rolled back, past back:%{public}.3f, current epochStartTime:%{public}.3f
Calisthenics (HIIT), METS, %f, %d, truthMETS, %f, %d
Richard 1
Richard 2
CLWorkoutSessionMetrics, no VO2Max records found at start of workout session
Discarding workout CA event, session uuid at end of session does not match uuid collected
Discarding workout CA event, invalid session duration %d
Discarding workout CA event, duration %d does not meet kWorkoutSessionMinSessionLength
Discarding workout CA event, invalid total epochs %d
@ClxLoi, supported, %{public}d
{"msg%{public}.0s":"#loip error fetching visits", "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#loip fetched most recent visit", "visit":%{private, location:escape_only}@}
#loip stop leeching visits
@ClxLoi, registerForNotificationInternal, notification, %{public}d
#loip register to leech visits
@ClxLoi, unregisterForNotificationInternal, notification, %{public}d
#loip cannot request LOI location for a nil visit
{"msg%{public}.0s":"#loip received visit", "visit":%{private, location:escape_only}@}
#loip cannot request LOI location for a nil LOI identifier
#loip skip requesting Loi location as routine monitor is not up
{"msg%{public}.0s":"#loip error fetching LOI", "loiIdentifier":%{private, location:escape_only}@, "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#loip received nil in return when fetching LOI", "loiIdentifier":%{private, location:escape_only}@}
{"msg%{public}.0s":"#loip received LOI has no visit history", "loi":%{private, location:escape_only}@, "loiIdentifier":%{private, location:escape_only}@}
{"msg%{public}.0s":"#loip received China Shifted LOI", "loi":%{private, location:escape_only}@, "loiIdentifier":%{private, location:escape_only}@}
{"msg%{public}.0s":"#loip received LOI has negative confidence value", "loi":%{private, location:escape_only}@, "loiIdentifier":%{private, location:escape_only}@}
{"msg%{public}.0s":"#loip received LOI", "loi":%{private, location:escape_only}@, "loiIdentifier":%{private, location:escape_only}@}
#loip unsupported location accuracy type, %lu
#loip,notify LOI location,lat,%{private}.7f,lon,%{private}.7f,hunc,%{public}.2f,altitude,%{private}.2f,vunc,%{public}.2f,confidence,%{public}d,integrity,%{public}lu,sourceAccuracy,%{public}lu
#loip notify LOI location unavailable
CLMM,AllowNetworkUsage,%{public}d,batterySaverMode,%{public}d,thermalVoteToAllow,%{public}d,signalEnv,%{public}d,isMapsForeground,%{public}d,thermalLevel,%{public}d,currentBatteryLevel,%{public}.2lf
Starting up CLMobilityWalkingBoutService
Shutting down CLMobilityWalkingBoutService
CLMobilityWalkingBoutService: Received unexpected type %{public}d
CLMobilityWalkingBoutService: Received user info update
This device is not expected to support Gait Metrics. Please file a radar: rdar://component/1021534
Invalid xpc activity (%s).
BoutService: Data sources unavailable, did not process bouts (%s)
Failed to mark (%s) activity as done. Current state is %{public}ld
Unexpected activity (%s) state: %ld
Invalid xpc classification activity.
Failed to mark activity (%s) as done. Current state is %{public}ld
BoutService: Mobility data requested
BoutService: Data sources unavailable, did not process bouts onDataCollectionRequested
BoutService: Data requested, but unable to query outstanding bouts. CMError: %d
BoutService: Unable to process BoutMetrics pre-aggregation, CMError: %d
CLMobilityWalkingBoutService: Aggregating WalkingBout, GaitMetrics, BoutMetrics records
BoutService: HK queried for workouts from (%{public}.2f) to (%{public}.2f)
CLMobilityWalkingBoutService: Sending %lu bout metrics to %d client(s)
Bout metrics result, startTime, %.2f, endTime, %.2f, stepCount, %d
#warning: HealthKit: Walking Steadiness unavailable
#warning: Classification already in progress
Checking for historical samples -- setting classification time in the past: (%{public}.2f)
Trying to classify a time period in the future (%{public}.2f)
Missing Database UUID
No steps detected, despite the presense of MobilityBoutMetrics
Most recent classification is OK, resetting previous notification %{private}.2f
Finished Classification: data sources unavailable
Height not set, increasing minimum delay before next classification
Finishing Classification: nextClassificationTime=%{}.2f, nextFireInterval=%{}.2f
checkForHistoricalComputeTrigger: NO, height is unset
checkForHistoricalComputeTrigger: NO, ClassB database inaccessible
checkForHistoricalComputeTrigger: NO, nextClassificationTime already set (%{public}.2f)
checkForHistoricalComputeTrigger: YES, attempting classification
BoutService: Not authorized to submit analytics without IHA
BoutService: Sending WalkingSteadiness to %d client(s)
BoutService: Not authorized to submit steadiness analytics without IHA
%{public}s: Registering XPC Activity with nextClassificationTime=(%{public}.2f) and delay=(%{public}lld)
XPC_CHECK_IN: Initializing %{public}s activity with delay %{public}lld
XPC_CHECK_IN: Checking in on XPC  %{public}s activity, previous delay (%{public}lld), new delay (%{public}lld)
BoutService: Data processing timer fired (%{public}ld)
BoutService: Registered new BoutMetrics client %@. Current client count: %d
BoutService: Unregistered BoutMetrics client %@. Current client count: %d
BoutService: Registered new WalkingSteadiness client %@. Current client count: %d
BoutService: Unregistered new WalkingSteadiness client %@. Current client count: %d
Failed to open MslLogger
Legacy motion setting found '%{public}s'. Clearing.
Failed to clear legacy motion setting: '%{public}s'. Stale profile?
CLAvengerScanner: begin service
{"msg%{public}.0s":"CLAvengerScanner: settings", "settings":%{private, location:escape_only}@}
{"msg%{public}.0s":"CLAvengerScanner: startMonitoringAvengerAdvertisementsForClient", "client":%{public, location:escape_only}@, "optedIn":%{public}hhd, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: stopMonitoringAvengerAdvertisementsForClient", "client":%{public, location:escape_only}@, "clientCount":%{public}lu, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: special scan requested, but currently no clients, not starting"}
{"msg%{public}.0s":"CLAvengerScanner: performTemporaryAggressiveScan requested", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: requested AggressiveScan but RSSI Finding scan active", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: performTemporaryLongAggressiveScan requested", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: performTemporaryLongAggressiveScan scanning", "duration":%{public}d, "coexImpacted":%{public}hhd, "associatedTo2GHzWiFi":%{public}hhd, "wifi2GHzCriticalState":%{public}hhd, "bluetoothAudioActive":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: extending LongAggressiveScan due to downgrade", "remainingDuration":%{public}d}
{"msg%{public}.0s":"CLAvengerScanner: performTemporaryHawkeyeLowEnergyScan requested", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: startBTFindingScan requested", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: stopBTFindingScan requested", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: startWatchAdvertisementBufferScan requested", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: stopWatchAdvertisementBufferScan requested", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: fetchCurrentScanParameters", "client":%{public, location:escape_only}@, "_currentWPState":%{public}d, "_state":%{public}d, "_stateContext.startScanningAwaitingResponse":%{public}hhd, "_stateContext.stopScanningAwaitingResponse":%{public}hhd}
{"msg%{public}.0s":"CLAvengerScanner: submitScanTypeChangeEvent", "analyticsEvent":%{public, location:escape_only}@}
{"msg%{public}.0s":"CLAvengerScanner: submitClientRequestsEvent", "analyticsEvent":%{public, location:escape_only}@}
{"msg%{public}.0s":"#CLAvengerScanner: attempted to update scan but not yet scanning"}
{"msg%{public}.0s":"#LocationPush couldn't get value for kCLConnectionMessageSubscribeKey key for client", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#LocationPush client attempted to subscribe", "client":%{public, location:escape_only}s, "subscribe":%{public}hhd}
{"msg%{public}.0s":"#LocationPush checking topic should be registered ", "client":%{public, location:escape_only}s, "shouldBeRegistered":%{public}hhd}
Something went wrong with num fences
#Warning Client %{public}s does not have appropriate motion entitlement.
Received AnomalyEventCompletedUpdate request,client,%s,subscribe,%d
%s is not authorized for Fall Detection updates
Received MessageAnomalyEventCompletedMostRecent message,client,%s
Received MessageAnomalyEventEnabled message,client,%s
Anomaly Detection subscription changed, %{public}s, %{private}p, %{public}d
{"msg%{public}.0s":"Subscription - Received anomaly detection subscription request with no event"}
{"msg%{public}.0s":"Subscription - Received anomaly detection subscription request with event", "direction":%{public, location:escape_only}s, "identifier":%{public}llu, "operatingMode":%{private}ld, "anomaly timestamp":"%{private}f", "update timestamp":"%{private}f", "state":%{private}ld, "response":%{private}ld, "resolution":%{private}ld, "isAcknowledgement":%{public}hhd, "sosState":%{public}hhd}
{"msg%{public}.0s":"Subscription - Received anomaly event notification with no event (reconnection)"}
{"msg%{public}.0s":"Subscription - Received anomaly event notification", "direction":%{public, location:escape_only}s, "identifier":%{public}llu, "operatingMode":%{public}u, "anomaly timestamp":"%{private}f", "update timestamp":"%{private}f", "state":%{private}d, "response":%{private}d, "resolution":%{private}d, "sosState":%{private}d}
CL: CLFallSubscription::onFallNotification
{"msg%{public}.0s":"CLFallSubscription::onFallNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"Background escalation manager permission changed", "from":%{public}hhd, "to":%{public}hhd}
Background escalation manager consuming more power than workout alerts
Background escalation manager not consuming more power than workout alerts
Background escalation manager already tracking escalation
Background escalation manager starting to track escalation
Background escalation manager should deescalate,hasBudget,%{public}d,hasPermission,%{public}d
Background escalation manager stopped tracking escalation
ExerciseMinute,ComputeTime,%.3f,awardedExerciseMinuteMode,%d,fBurstBufferCount,%.3f,fBurstBufferDuration,%.3f,fPushBufferCount,%.3f,fPushBufferDuration,%.3f,BurstModelDuration,%.3f,BurstModelCount,%.3f,BurstModelThreshold,%d,ThresholdModelDuration,%.3f,ThresholdModelCount,%.3f,ThresholdModelThreshold,%d,CoverageModelDuration,%.3f,CoverageModelCount,%.3f,CoverageModelThreshold,%d
AssistedCyclingDetector,beginTime,%f,endTime,%f,bufferSize,%d,totalSamplesAboveVO2MaxThreshold,%d,totalSamplesAboveVAMThreshold,%d,totalSamplesAboveDiscordanceThreshold,%d,totalSamplesNonexertion,%d,medianAccelVectorMagnitude,%f,assistedCyclingOverridden,%d,isMotionOverrideSet,%d,isAssistedOverrideTimedOut,%d,isNewCurrentSessionId,%d,isSessionDurationOk,%d
AssistedCyclingOverrideState,endTime,%f,previousOverride,%d,currentOverride,%d,totalSamplesAboveVO2MaxThreshold,%d,totalSamplesAboveVAMThreshold,%d,totalSamplesAboveDiscordanceThreshold,%d,totalSamplesNonexertion,%d,medianAccelVectorMagnitude,%f,isAssistedOverrideTimedOut,%d,isNewCurrentSessionId,%d,isSessionDurationOk,%d
fStaticWait,%{public}f,fMinimumInterval,%{public}f,fDoubleCalInterval,%{public}f,fOutOfBoxTimeout,%{public}f,fMinBatteryLevel,%{public}f,fRetryCalInterval,%{public}f,fUrgentStaticWait,%{public}f,fUrgentMinBatteryLevel,%{public}f,fUrgentAttemptMinimumInterval,%{public}f,fUrgentCalScheduled,%{public}d,fLastCalibration,%{public}g,fLongestDurationWithoutCal,%{public}.0f
fState,%{public}d
Thermal virus not supported for x86 yet
Calibration is already running
BatteryReady,%{public}d,ThermalReady,%{public}d,DisplayReady,%{public}d,StaticReady,%{public}d,MinimumIntervalReady,%{public}d,UrgentMiniCalScheduled,%{public}d,timeToIntervalReady,%{public}.0f,sinceLastCal,%{public}s,sinceLastUnpluggedCalAttempt,%{public}s,ChargerFamily,%{public}x,ChargerCloaked,%{public}u
Still waiting for long wait timer
Starting long wait timer for %{public}llu seconds
Long wait timer trigger.
Resetting static timer. Wait duration changed %{public}f -> %{public}f
Still waiting for static timer of %{public}f
Starting static timer for %{public}f
Static timer fired
Avoiding calibration during charging
No coex; calibration runtime = %.0f sec
CLSensorCalibrationController aborted,reason,%{public}d,%{public}s
Ignoring abort for user initiated calibration
Stopped sensor calibration, fState, %{public}d, successful, %{public}d
Scheduling double calibration,fLastCalibration,%{public}f,expectedNextCalibration,%{public}f
Scheduling retry calibration after previous aborted run,fLastCalibration,%{public}f,expectedNextCalibration,%{public}f
state,%{public}d,temperature,%{public}f
Warning: Bad state,%{public}d
state,%{public}d,elapsed,%{public}f
level,%{public}f,connected,%{public}d
Warning: Unexpected notification %{public}d
UrgentFlag,%{public}d
CL: CLSensorCalibrationController::onStatusNotification
{"msg%{public}.0s":"CLSensorCalibrationController::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSensorCalibrationController::onUrgentMiniCal
{"msg%{public}.0s":"CLSensorCalibrationController::onUrgentMiniCal", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"Can't have a scan of no channels"}
{"msg%{public}.0s":"Duty cycle percentage should be between 0 and 1", "dutyCycle":"%{private}f"}
{"msg%{public}.0s":"Duty cycle is NaN"}
[Audio] TPQ summary,%d,A,%d,B,%f,C,%f,D,%f,E,%f,F,%f,G,%f,H,%f,I,%f,J,%f,K,%f,L,%d,M,%d,N,%d,O,%d,config-1,%d,config-2,%f,config-3,%d,config-4,%d,config-5,%f,config-6,%f,config-7,%f,config-8,%f,config-9,%f,config-10,%f,config-11,%f,config-12,%f
audio (%f, %f, %f, %f, %f, %f) (%d, %d, %d, %d, %d, %d) (%d %d %d %d)
audio config %d, %f, %d, %d, %f, %f, %f, %f, %f, %f, %f, %f
CLMM, memory cache and tile count limit already set
CLMM,GEOTileLoader memory cache,%d,tile count limit,%d
[Dynamic Config] Error querying DB.
[Dynamic Config] No records in DB.
[Dynamic Config] Received parameter string %@.
[Dynamic Config] No valid configuration found, parameter %@ left unchanged.
[Dynamic Config] Value for key %@ set on disk, returning.
[Dynamic Config] Configuration doesn't modify parameter %@.
[Dynamic Config] Sanity check failed for key %@ with retrieved value %{private}@.
[Dynamic Config] Overriding %@ to %{private}f
[Dynamic Config] Invalid config received: %{private}@
[Dynamic Config] Valid config received: %{private}@
[Dynamic Config] Nil value received for one or more fields.
[Dynamic Config] Ignoring duplicate config %@.
[Dynamic Config] Parameter dictionary is empty, returning.
[Dynamic Config] Error serializing parameter dictionary, error: %@
[Dynamic Config] Inserted config with ID %{public}@
[Dynamic Config] No bounds defined for parameter %@. Defined bounds are %@
[Dynamic Config] Out of bounds: Parameter %@ cannot be set to %@
[Dynamic Config] Invalid configuration: too few keys.
[Dynamic Config] Invalid configuration: key %@ not found.
[Dynamic Config] Parse error: %@, error: %@
IndoorOutdoor, Subscription changed, %s, %p, %d
IndoorOutdoor, most recent update at %f, type %ld, sending %@
CL: CLIndoorOutdoorSubscription::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLIndoorOutdoorSubscription::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
@WifiAps, remove, %{private}s, age, %{public}d
@WifiAps, history, %{public}lu, aged, %{public}lu, thresh, %{public}d
Initializing with invalid channel, %d
{"msg%{public}.0s":"attempting to access moving ap info when never set", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
WifiAps, fix ap count per scan type, invalid bucket index, %{public}d, # of fix APs, %{public}d
CLMobility::SteadinessSuppression::Features,walkingSteadiness,%{private}.2f,allBoutsBoutDurationSecCv,%{private}.2f,intermediateBoutsDoubleSupportPercentageMedian,%{private}.2f,dailySteps30daysMax,%{private}.2f,dailyFlights30daysMax,%{private}.2f,dailySteps7daysMean,%{private}.2f
OBM,GpsForceOutdoorMatching,%{public}d,ObmAllowPositionOverride,%{public}d,fBumpHorizontalUncertaintyAmidstBuildings,%{public}d,fMinBuildingsForBump,%{public}u,fSearchRadiusInMeters,%{public}f,fMinHorizontalUncertaintyAmidstBuildings,%{public}f,fMinAverageBuildingHeightForUncertaintyBump,%{public}f
OBM, forcing building geometry
#Warning, OBM, cannot estimate nav mode, disabling
OBM, non-pedestrian, not matching
#Warning, OBM, no mapGeometry!
#Warning, OBM, no geometry!
#Warning, OBM, buildingsWithinDistance,%{public}lf returned false!
OBM, %{private}.13lf,%{private}.13lf,numbuildings,%{public}zu,radius,%{public}lf
#Warning, OBM, buildings.size() %{public}ld > 500. too many buildings. Aborting
OBM,averageBuildingHeight,%{public}.2lf,fNeighborhoodCharacter.type,%{public}d
OBM, not in any building
OBM, %{private}.13lf,%{private}.13lf,building,%{public}zu
OBM, a-priori,%{private}.6lf,%{private}.6lf,hacc,%{public}.2lf,a-posteriori,hacc,%{public}.2lf
#Warning, OBM, no building but point in building!
OBM, initialSize,%{public}ld,finalSize,%{public}ld
#Warning, OBM, no exterior particles remaining
OBM,particleCourse,%{public}.2lf,crumbCourse,%{public}.2lf,deltaCourse,%{public}.2lf,particle,%{public}.6lf,%{public}.6lf,crumb,%{public}.6lf,%{public}.6lf,deltaPos,%{public}.6lf,%{public}.6lf,score,%{public}.5lg,bestScore,%{public}.5lg,varFactor,%{public}.5lg
#Warning, OBM, LonLat conversion failed,point,%{public}lf,%{public}lf
OBM, inflatedHacc, %{public}.2lf, fMinHorizontalUncertaintyAmidstBuildings, %{public}.2lf. choosing max
OBM, a-priori,%{private}.6lf,%{private}.6lf,course,%{public}.2lf,hacc,%{public}.2lf,a-posteriori,%{private}.6lf,%{private}.6lf,course,%{public}.2lf,hacc,%{public}.2lf,bestScore,%{public}.6lg,bestLonLat,%{public}.6lf,%{public}.6lf,bestCourseInDegrees,%{public}.2lf,fAllowPositionOverride,%{public}d,
OBM, a11,%{public}.5lf,a12,%{public}.5lf,a22,%{public}.5lf,a33,%{public}.5lf
OBM,update
Attempting to notify nil retrocompute state
VO2Max Retrocompute Status, Subscription changed, %s, %p, %d
{"msg%{public}.0s":"MicroLocation Internal Version request", "version":%{public, location:escape_only}s}
Rapport, unregister rapport session
Rapport, register rapport session
{"msg%{public}.0s":"Rapport, rapport session ready to listen for incoming devices"}
{"msg%{public}.0s":"Rapport, onRapportDeviceFound - rapport session device found is nil"}
{"msg%{public}.0s":"Rapport, onRapportDeviceFound", "note":%{public, location:escape_only}s}
{"msg%{public}.0s":"Rapport, onRapportDeviceFound", "error":%{public, location:escape_only}s}
{"msg%{public}.0s":"Rapport, onRapportDeviceFound", "name":%{private, location:escape_only}s, "idsDeviceIdentifier":%{private, location:escape_only}s, "model":%{private, location:escape_only}s}
MicroLocation: shutdown
{"msg%{public}.0s":"Got BLE scan", "IDS ID":%{private, location:escape_only}s, "BT identifier":%{private, location:escape_only}s, "Model":%{private, location:escape_only}s}
MicroLocations not supported on this platform
Updating Significant Locations from Auth Cache Notification
Recording event %{public}d not enabled
Registering for app launch notifications
Registering for first wake of day events
Registering for forced recordings
Registering for HomeKit Accessory notifications
Home control suggestion enabled, %{public}d
Registering for HomeKit Scene notifications
Registering for notifications of battery state
Registering for notifications of screen wake
Registering for Now Playing notifications
Unregistering for app launch notifications
Unregistering for first wake of day events
Unregistering for Siri invocations
Unregistering for forced recordings
Unregistering for HomeKit Accessory notifications
Unregistering for HomeKit Scene notifications
Unregistering for notifications of battery state
Unregistering for notifications of screen wake
Unregistering for Now Playing notifications
{"msg%{public}.0s":"Recieived notification", "source":%{public, location:escape_only}s, "trigger":%{public, location:escape_only}s, "bundleId":%{private, location:escape_only}s}
Location services are disabled, ignore WiFi scan result
Received wifi notification %{public}d with scan type %{public}d
#Warning Received unknown wifi service notification %{public}d
Not scanning Wifi RSSI because it's not enabled
Not scanning Wifi RTT because it's not enabled
Not scanning HomeKit because it's not enabled
Not scanning for Apple TVs because it's not enabled
Wifi is powered off - not scanning
HomeKit is powered off - not scanning
Register for spyscan beacons
CBDiscovery activated successfully
Unregister spyscan beacons
{"msg%{public}.0s":"Recieived notification", "source":%{public, location:escape_only}s, "trigger":%{public, location:escape_only}s, "is restricted":%{private}hhd}
{"msg%{public}.0s":"Recieived notification", "source":%{public, location:escape_only}s, "trigger":%{public, location:escape_only}s, "is enabled":%{private}hhd}
{"msg%{public}.0s":"Recieived notification", "source":%{public, location:escape_only}s, "trigger":%{public, location:escape_only}s, "is on":%{private}hhd}
#Warning Received unhandled daemon status notification %d
#Warning Got a notification center notification that we weren't expecting: %s
Received unhandled homekit notification
{"msg%{public}.0s":"RecordingStarted", "durationInMs":%{public}lld}
Recording timer cancelled
Recording timer stopped
{"msg%{public}.0s":"Recieived notification", "source":%{public, location:escape_only}s, "trigger":%{public, location:escape_only}s}
{"msg%{public}.0s":"localization results vector cannot be empty", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning Unable to save localization results to duet. %{private}s
Successfully logged to duet
Deleting all entries in the MicroLocation CoreDuet event stream
#Warning Unable to clear MicroLocation CoreDuet Event Stream. %{private}s
Deleted %{public}lu events from MicroLocation Event Stream
Got a data protection notification we weren't registered for: %{public}d
CL: CLMicroLocationNotifier::onDarwinNotification
{"msg%{public}.0s":"CLMicroLocationNotifier::onDarwinNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMicroLocationNotifier::onDataProtectionManagerNotification
{"msg%{public}.0s":"CLMicroLocationNotifier::onDataProtectionManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMicroLocationNotifier::onDaemonStatusNotification
{"msg%{public}.0s":"CLMicroLocationNotifier::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMicroLocationNotifier::onHomeKitNotification
{"msg%{public}.0s":"CLMicroLocationNotifier::onHomeKitNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMicroLocationNotifier::onNotificationCenterNotification
{"msg%{public}.0s":"CLMicroLocationNotifier::onNotificationCenterNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"CFType must be a CFString to convert to a std::string", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"fstat failed"}
{"msg%{public}.0s":"mmap failed"}
{"msg%{public}.0s":"filtering out access point from calculation based on scan timestamp", "mac":%{private, location:escape_only}s, "age_seconds_s":"%{public}.09f"}
{"msg%{public}.0s":"elevation is steady", "max_ap_age_s":"%{public}.09f"}
{"msg%{public}.0s":"elevation is not steady", "max_ap_age_s":"%{public}.09f"}
@WifiFlow, aps, history, %{public}lu, fresh, %{public}llu, 2ghz, %{public}llu, 5ghz, %{public}llu, agethresh, %{public}llu,
TileDl, backoff, count, %{public}d, time, %{public}0.1f
CLMM,no TEPA,isTunnel,%d,isSnapUsable,%d,lastAssistanceTime,%.1lf
CLMM,%.2lf,no TEPA, shifted coordinates
CLMM,TEPA,outgoing reached max iterations,%d
CLMM,no TEPA,multi-outbound,%d
CLMM,TEPA,incoming reached max iterations,%d
CLMM,no TEPA,multi-inbound,%d
CLMM,%.1lf,TEPA,ell,%{private}.7lf,%{private}.7lf,sll,%{private}.7lf,%{private}.7lf,alt,%.1lf,vUnc,%.1lf,length,%.2lf,distFromCurrentParticle,%.1lf,iterCountOut,%d,iterCountIn,%d
CLMM,%.2lf,NotPropagating,isTunnel,%d,isSnapUsable,%d,particleTime,%.2lf,particleTimeOut,%.1lf,speed,%.2lf,speedTime,%.2lf,speedTimeOut,%.1lf,speedLimit,%.1lf
CLMM,%.2lf,NotPropagating, shifting is required but accessory is outputting  unshifted coordinates
CLMM,%.2lf,NotPropagating,time lower than particleTime, %.2lf
CLMM,%.2lf,limit distance to propagate,orig,%.1lf,new,%.1lf
CLMM,NotPropagating,roadsAtIntersection returned false
CLMM,NotPropagating,multi-outbound,%lu,intersection within the distance,%.2lf, needed to be travelled returned
CLMM,NotPropagating,moveOnRoad returned false
CLMM,NotPropagating,NULL road
CLMM,NotPropagating,solution moved away from tunnel
CLMM,%.2lf,Propagating,lat,%.8lf,lon,%.8lf,course,%.8lf,speed,%.1lf,speedLimit,%.1lf
#Warning CLMM, %.1lf,detected stuck,alongTrackRawToSnap,%.1lf,deltaPosChange,%.1lf,deltaSnapChange,%.1lf,thresholdDiff,%.1lf
CLMM, %.1lf,isMovingAway,%d,deltaPosChange,%.1lf,deltaSnapChange,%.1lf,thresholdDiff,%.1lf
Fence: No access to vertices DB
Fence: addVertices, key, %{public}d, num %{public}lu
Fence: attempting to add vertices to db without a key
#Warning Fence: Couldn't bind statement for adding vertices (key %{public}d
Fence: Removing vertices, key, %{public}d
#Warning Fence: Couldn't bind statement for deleting vertices (key %{public}d
Fence: Couldn't bind foreignKey %{public}d
Fence: Couldn't get vertices from database
Fence: Error in retrieving vertices from database for foreignKey %{public}d
use handleMessageKappaSendConfig to update the configuration
received AP command %d
invalid AP command
Client %{private}s does not have appropriate motion entitlement.
Client %{private}s is not available on this platform.
invalid item specified for kappa request
CL: CLKappaSubscription::onKappaNotification
{"msg%{public}.0s":"CLKappaSubscription::onKappaNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Warning #EmergCon call connect timeout fired
#EmergCon #Warning inst0 settings find returned null
#EmergCon #Warning inst1 settings find returned null
#EmergCon,onDaemonStatusNotification,kNotificationLockScreen,display [%{public}s]
{"msg%{public}.0s":"#EmergCon Location Services status change", "enabled":%{public}hhd}
#EmergCon Creating new transaction without releasing previous one
#EmergCon Creating os transaction CLEmergency
#EmergCon Release os transaction CLEmergency
#EmergCon Attempt to release transaction that was already released
#EmergCon setCLEEA,Current,%d,New,%d,ignoring
#EmergCon setCLEEA,Current,%d,New,%d
#EmergCon,error unpicking AirPlay routes,%{public}@
#EmergCon,successfully unpicked AirPlay routes
#EmergCon,EnterEmergency
#EmgContext,repeating current settings for sim 1,%{private}s
#EmgContext,repeating current settings for sim 2,%{private}s
{"msg%{public}.0s":"#EmgContext", "CleeaAsserted":%{public}d}
#EmergCon,ExitEmergency
#EmergCon,newState,ignoring,fEmergencyStateOld,%d,state,%d
{"msg%{public}.0s":"#EmergCon delaying emergency state until call connects", "state":%{public}d, "StringifiedState":%{public, location:escape_only}s}
{"msg%{public}.0s":"#EmergCon E911Event", "event":%{public, location:escape_only}s, "Emergency: state":%{public}d, "Emergency: StringifiedState":%{public, location:escape_only}s}
{"msg%{public}.0s":"#EmergCon,updateEmergencyState,ignoring as it is same as current state", "state":%{public, location:escape_only}s}
#EmergCon,updateEmergencyState,emergency call not active but CT in voice emergency
{"msg%{public}.0s":"#EmergCon,updateEmergencyState,delaying emergency state until call connects", "State":%{public, location:escape_only}s}
{"msg%{public}.0s":"#EmergCon E911Event", "event":%{public, location:escape_only}s, "Emergency: StringifiedState":%{public, location:escape_only}s}
{"msg%{public}.0s":"#EmergCon E911Event", "event":%{public, location:escape_only}s, "CLEEA":%{public}d}
#EmergCon,updateCleeaEmergencyState,state,%d
#EmergCon,skipping updateEmergencyState, do not clear telephony determined emergency state
#EmergCon setting call connect timeout for %{public}f s
#EmergCon clearing call connect timeout
#EmergCon,longEemTimeout,longer than expected EEM detected
#EmergCon,createLongEemTimeout,started timer for %{public}f
#EmergCon,createLongEemTimeout,timer already exists
#EmergCon,clearLongEemTimeout,timer cleared
#EmergCon,clearLongEemTimeout,no timer exists
#EmergCon,getBundleId,unexpected bundle type
#EmergCon NILR %{public}s
#EmergCon NILR already %{public}s
CL: CLEmergencyController::onDaemonStatusNotification
{"msg%{public}.0s":"CLEmergencyController::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLEmergencyController::onClientNotification
{"msg%{public}.0s":"CLEmergencyController::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
undefined constellation usage %d
#wlan,apConfigToString,undefined AccessPointConfig,%d
undefined MeasurementTimeStampSource,%d
PLOS, fPlatformSupportsPlosEstimation, %{public}d
PLOS,%.3lf,fillCrumb false
PLOS: match returned false!
OBM, ForceNetworkUsage %{public}d
OBM, DisallowNetworkUsage %{public}d
handling notification %{public}s
CL: CLOutdoorMatchingEngine::onGpsNotification
{"msg%{public}.0s":"CLOutdoorMatchingEngine::onGpsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
rtree: insert, adamId %{private}u, centroid %{private}lf, %{private}lf, %{private}s
idle bbox: no marquee apps, %{private}s
idle bbox: empty box, inside %{private}u's bbox: %{private}s
idle bbox: %{private}s
ilde box: all app's bboxes
idle bbox: marquee app fetch bbox, %{private}s
loi, precondition failed, not checking lois, nullptr
loi, empty loi, returning not near loi without checking
loi, nearby, %{private}lf, %{private}lf, type, %{private}lu, visit count, %{private}lu
decision: in cool down, not suggesting, last suggestion, %{private}lf
decision: in idle box, not suggesting, box, %{private}lf, %{private}lf, %{private}lf, %{private}lf
decision: not in any app's bounding box, not suggesting
decision: near loi, not suggesting
rtree: traversing: adamId, %{private}u, %{private}s
decision: not inside any marquee app nearby bounding box, not suggesting, %{private}lf, %{private}lf
filter: %{private}u, above age limit: %{private}u, %{private}u
filter: %{private}u, installed
filter: %{private}u, recently suggested
filter: %{private}u, app not nearby, centroid, %{private}lf, %{private}lf
present: suggested %{private}u, done, at %{private}lf, %{private}lf
decision: suggested %{private}u, done, at %{private}lf, %{private}lf
decision: nothing to suggest, done, at %{private}lf, %{private}lf
maint: prune suggestion record, before, load factor, %{private}f, bucket ct, %{private}lu, size, %{private}lu
maint: prune suggestion record, after, load factor, %{private}f, bucket ct, %{private}lu, size, %{private}lu
idle bbox: %{private}u, %{private}s
Received MotionActivityUpdate request,client,%s,subscribe,%d
Cannot subscribe to motion activity updates, motion activity is not available
query for motion activity was received but motion activity is not available
CL: CLMotionActivitySubscription::onMotionActivityNotification
{"msg%{public}.0s":"CLMotionActivitySubscription::onMotionActivityNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Request region preload manifest, no manifest
isStart,%d,manifest,%d,LastTime,%lf,LastLat,%.05lf,LastLon,%.05lf
Request region preload manifest, update
Found a preload region %s
Requesting download of preload manifest, allowCell,%d
Request tiles at lat,%.06lf,lon,%.06lf, allowCell,%d
startTime, %{public}.3f, rawActivity, %{public}d, overridenActivity, %{public}d
#Warning Popping out an activity since there's no activity associated with current time.  This shouldn't happen
TileFile, fTileDownloadCoolOffPeriod, %{public}.1lf
TileFile, fTileDownloadExtendedCoolOffPeriod, %{public}.1lf
TileFile, fTileForceExpirationPeriod, %{public}.1lf
TileFile, fTileMinExpirationPeriod, %{public}.1lf
@TileQueue, hasDataExpired, %{public}d, isLargeConnectivity, %{public}d, fExpirationAge, %{public}d, dataExpirationPeriod, %{public}.1lf, dataAge, %{public}.1lf, tile, %{private}s
TileFile, canRequestBasedOnAttempts, tile, %{private}s, age, %{public}.1lf, needs to be refreshed - retry
TileFile, canRequestBasedOnAttempts, tile, %{private}s, age, %{public}.1lf, expirationAge, %d
TileFile, canRequestBasedOnAttempts, tile, %{private}s, sinceLastDownload, %{public}.1lf, %{public}d, needs to be refreshed, TileDoesNotExistOnTheServer
@TileDl, %{public}s, attempts, llsw, %{private}.2lf, %{private}.2lf, lastSuccess, %{public}d, existsOnServer, %{public}d, sinceLastDownload, %{public}.1lf, cooloff1, %{public}d, cooloff2, %{public}d, cooloff3, %{public}d, expired, %{public}d, path, %{private}s
TileFile, startDownloading, tile, %{private}s, localFilename, %{public}s, tempFilename, %{public}s
TileFile, startDownloading, failed to download without a downloadRequest, %{private}s, #CloneMe
TileFile, startDownloading, tile is already being downloaded, %{private}s, #CloneMe
TileFile, startDownloading, tile, %{private}s, started, %{public}d, strFileUrl, %{private}s
TileFile, decompress, failed to move, %{public}s, %{public}s, errno, %{public}d, %{public}s, #CloneMe
TileFile, decompress, from, %{public}s, to, %{public}s, failed, errno, %{public}d, %{public}s, #CloneMe
TileFile, decompress, in, %{public}.6lf, seconds, size, %{public}u, to, %{public}u, tile, %{private}s
TileFile, decompress, from, %{public}s, to, %{public}s, failed, %{public}u byte file, #CloneMe
TileFile, decompress, file is not compressed, %{private}s
TileFile, generateUniqueFileName, trying, %{public}s, tile, %{private}s
TileFile, generateUniqueFileName, end, localFilename, %{public}s, temp, %{public}s
TileFile, deleteFile, unlink, %{public}s
TileFile, deleteTempFile, unlink, %{public}s
TileFile, onDownloadCompleted, success, %{public}d, fDownloadRequest, %{public}p, tileDoesNotExist, %{public}d, details, %{public}s
TileFile, copy from, %{public}s, to, %{public}s, start
TileFile, onDownloadCompleted, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, tile, %{private}s
TileFile, onDownloadCompleted, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, type, %{public}d, %{public}s, #CloneMe
TileFile, tile, %{private}s, download failed, #CloneMe
TileFile, failed to move from, %{public}s, to, %{public}s, errno, %{public}d, %{public}s, #CloneMe
TileFile, setLocalfilename, localFilename, %{public}s, tempFilename, %{public}s
TileFile, Delta lat/lon zero, %{public}d, %{public}d, #CloneMe
TileFile,: extractTileIdFromFile, prefer local file name because it exists, %{public}s
TileFile, extractTileIdFromFile, directory, %{public}s, filename, %{public}s, absFilename, %{public}s, type, %{public}d, isHeadersOnly, %{public}d
TileFile, extractTileIdFromFile, failed, %{public}s, #CloneMe
TileFile, extractTileIdFromFile, failed to open file, %{public}s, errno, %{public}d, %{public}s, #CloneMe
TileFile, extractTileIdFromFile, tile version, %{public}d, min version, %{public}d, isVersionOk, %{public}d, dLat, %{public}.5lf, dLon, %{public}.5lf
TileFile, extractTileIdFromFile, invalid hash value for, %{private}s, #CloneMe
TileFile, extractTileIdFromFile, read tileid from file, %{private}s
TileFile, extractTileIdFromFile, read, absFilenameParams, %{public}s
TileFile, readTileFileByFileName, start, file, %{public}s, isHeadersOnly, %{public}d, isBinarySearch, %d
TileFile, readTileFileByFileName, reading input from stdin
TileFile, failed to open, %{public}s, errno, %{public}d, %{public}s, #CloneMe
TileFile, readTileFileByFileName, done, file, %{public}s, isHeadersOnly, %{public}d, isBinarySearch, %{public}d, isOK, %{public}d
TileFile,filename==nullptr
TileFile,setProtectionClass,failed,protectionClass,%{public}d,#CloneMe
TileFile,setProtectionClass,failed,%{public}s,protectionClass,%{public}d
TileFile, setProtectionClass, tile, %{private}s, newClass, %{public}d, curClass, %{public}d
TileFile, setProtectionClass, invalid protectionClass, %{public}d, #CloneMe
@TileList, %{public}s, %{public}s, llsw, %{private}.2lf, %{private}.2lf, Class%{public}c
@TileList, %{public}s, unlocked, llsw, %{private}.2lf, %{private}.2lf, ClassC
TileFile, getProtectionClass, failed to open, %{public}s
TileFile, getProtectionClass, failed to set protection class, %{public}d, #CloneMe
TileFile, no location / coordinates, tile, %{private}s, scaledLocation, %{private}.8lf, %{private}.8lf, #CloneMe
TileFile, doesLocationIntersectWithTile, distance, %{public}.1lf, deltas, %{public}.1lf, %{public}.1lf
@TileList, %{public}s, touch, ignoring, %{public}.2lf, #CloneMe
@TileList, %{public}s, touch, llsw, %{private}.2lf, %{private}.2lf
TileFile, saving, %{public}s
TileFile, paramsFileExist, %{public}d, loading, %{public}s, accessTimestamp, %{public}.1lf
@TileReq, %{public}s, skip, llsw, %{private}.2lf, %{private}.2lf, reason, %{public}s, last, %{public}s
This instance has no : TEST_testBinarySearch
WRTT: No peer range notifier.
CL: CLPeerRangingNotifier::onTimer
{"msg%{public}.0s":"CLPeerRangingNotifier::onTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLTilesManager is not supported in diagnostics mode
{"msg%{public}.0s":"TileType Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
TILE: fDefaultMaxDownloadListSize, %d
TILE: registered, tilesSet, %s
TmmMgr, ctor
TILE: fMinEncryptionGracePeriod, %.2lf
@TileEvent, all, locked, %{public}d
TILE: isAppTilesActive, %d
TILE: isTilePreloadManifestActive, %d
TILE: defaultDemTilesServerUrl, %{private}s, overridden, %{public}d
TILE: defaultHrseTilesServerUrl, %{private}s, overridden, %{public}d
TILE: defaultTilePreloadManifestServerUrl, %{private}s, overridden, %{public}d
TILE: defaultTransitMacTilesServerUrl, %{private}s, overridden, %{public}d
TILE: fDefaultMaxTileAge, %.1lf
TILE: fDefaultMaxTileDataAge, %.1lf
TILE: fDefaultEncryptionGracePeriod, %.1lf
TILE: fMaxNumOfTiles, %d
TILE: fDefaultDisableTilesWhileLocked, %d
TILE: DEM,fDefaultNumOfSurroundingCirclesDEM, %d
TILE: HRSE,fDefaultNumOfSurroundingCirclesHrse, %d
TILE: onDataProtectionNotification, %p, notification, %d
TILE: onDataProtectionNotification, kNotificationEncryptedDataAvailability, was, %d, now, %d, availability, %d
TILE: updateProtectionClass, skip on unlock
TILE: onCleanupAgedTiles, %p
TILE: %{public}s
onCompanionNotification, notification, %d, Tiles
TILE: onClientNotification, %p, notification, %d
TILE: kNotificationReset
TILE: kNotificationLocationServicesStatus, areLocationServicesEnabled, %d
TILE: location services off, remove all the tiles
TILE: #CacheDelete kNotificationSoftwareUpdateStorageRecovery
{"msg%{public}.0s":"CLTilesManager::deleteAgedDownloadItems", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "now_s":"%{public}.09f"}
TILE: deleteAgedDownloadItems, start
@TileReq, %{public}s, rmlist, llsw, %{private}.2lf, %{private}.2lf, aged, size, %{public}ld
TilesManager, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu
{"msg%{public}.0s":"Finished CLTilesManager::deleteAgedDownloadItems", "deleted":%{public}u}
{"msg%{public}.0s":"CLTilesManager::agedTileDeleter", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "now_s":"%{public}.09f"}
TILE: deleteAgedTiles, age, %.1lf, %.1lf, tileDataAge, %.1lf, %.1lf, corrupt, %d, isDelete, %d, tile, %s
TILE: deleteAgedTiles, too many tiles, %lu, tile, %s
TilesManager, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu, name, %{private}s
{"msg%{public}.0s":"CLTilesManager::agedTileDeleter", "deleted":%{private}u}
TILE: deleteAgedTiles, start, name, %s, size, %lu
TILE: dispatch, deleteAgedTiles, for, %s
TILE: deleteAgedTiles, fTilesToDownload
{"msg%{public}.0s":"CLTilesManager::cancelAllDownloads", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "planned":%{private}lu}
TILE: cancelAllDownloads, planned, %lu
{"msg%{public}.0s":"CLTilesManager::removeAllTiles", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "type":%{private}d}
TILE: removeAllTiles, cleaning map, %d, %s
TILE: removeAllTiles, end, name, %s, size, %lu, unprot size, %lu, downloadSize, %lu
TILE: listTilesDirectory, tileType, %d, %s
TILE: listAvailableFilesAllTypes, start
TILE: listAvailableFilesAllTypes, can't list tiles while locked, wait for unlock
TILE: convert to class B, first unlock, %s
TILE: convert to class C, first unlock, %s
@TileEvent, %{public}s, indexed, %{public}lu
TILE: listAvailableFilesAllTypes, done
TILE: listAvailableFilesByLister, reason, %s, rootDirectory, %s, name, %s
TileMgr, listAvailableFilesByLister, reason, %{public}s, can't open dir, %{public}s, #CloneMe
TILE: listAvailableFilesByLister, start
TILE: listAvailableFilesByLister, found tile file, filesNum, %u, absoluteFilename, '%s', d_type, %d
TileMgr, listAvailableFiles, can't open dir, %{public}s
TILE: listAvailableFiles, start
TILE: listAvailableFiles, found tile file, filesNum, %u, absoluteFilename, '%s', d_type, %d
TileMgr, listAvailableFiles, failed to stat file, %{public}s, ret, %{public}d, #CloneMe
TILE: listAvailableFiles, end
TILE: refreshTilesDataIfNeeded, isTileDataExpired, %d, isShouldBeDownloaded, %d, tile, %s
TILE: checkDownloadSchedule, location services disabled - no tile downloads
TILE: checkDownloadSchedule, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: checkDownloadSchedule, no tiles while locked
TILE: checkDownloadSchedule, no data connectivity, avoiding downloads
TILE: checkDownloadSchedule, no download on none broadband cellular connections
TILE: checkDownloadSchedule, checking, numOfActiveDownloads, %u, small, %d, large, %d
TILE: checkDownloadSchedule, numOfActiveDownloads, %d, not scheduling more
TILE: checkDownloadSchedule, both download requests are already in use
TILE: checkDownloadSchedule, both download requests null, shutdown?
TILE: checkDownloadSchedule, isLocationValid, %d, isDeviceLocked, %d
TILE: checkDownloadSchedule, lastLocation, %s
TILE: checkDownloadSchedule, isShouldDownload is not true, exists on server, %d
TILE: checkDownloadSchedule, rule, isCurrent, isAllowCellularIfCurrent,  IsOkToDownloadRealtime, %s
TILE: checkDownloadSchedule, rule, isCurrent, fDownloadCurrentTileOverCell, IsOkToDownloadRealtime, %s
TILE: checkDownloadSchedule, rule, isCurrent, IsOkToDownloadLarge, %s
TILE: checkDownloadSchedule, rule, isAllowCellularIfNotCurrent, IsOkToDownloadRealtime, %s
TILE: checkDownloadSchedule, rule, IsOkToDownloadLarge, %s
TILE: checkDownloadSchedule, isShouldDownload, %d, isAllowDownload, %d, isCurrentTile, %d, isAllowCellular, %d, check, %s, details, %s
TILE: checkDownloadSchedule, chose, downloadState, %s
TILE: checkDownloadSchedule, started downloading, numOfActiveDownloads, %d, tile, %s
@TileReq, %{public}s, start, llsw, %{private}.2lf, %{private}.2lf, reach, %{public}d, url, %{private}s
TILE: checkDownloadSchedule, numOfActiveDownloads, %d, tilesToDownload, %lu, small, %d, large, %d
TILE: checkDownloadSchedule, NoActiveDownloads
TILE: tileDownloadCompleted, tile, %s, download done, success, %d, NSURLErrorCode, %d, tileDoesNotExist, %d, reachability, %d, locked, %d, fileSize, %d
TileMgr, where did this download request come from?, download, %{public}p, #CloneMe
TileMgr, tileDecompressionCompleted, nullptr in fTilesDownload, #CloneMe
TileMgr, tileDecompressionCompleted, no tile for download, %{public}p, #CloneMe
TILE: tileDecompressionCompleted, tile, %s, decompress done, tileDownloadWasSuccessful, %d, NSURLErrorCode, %d, tileDoesNotExist, %d, reachability, %d
TILE: tileDecompressionCompleted, tile, %s, reachability, %d, isLocked, %d, downloadDuration, %.1lf, downloadState, %s, progress, s, %d, l, %d
TILE: tileDecompressionCompleted, replacing from, %s
TILE: tileDecompressionCompleted, replacing to, %s
TileMgr, tileDecompressionCompleted, where the file, was it deleted, %{private}s, #CloneMe
TILE: tileDecompressionCompleted, added, tileid, %s, tilesMap.size, %lu
TILE: kNotificationTileWasDownloaded, tileid, %s, tileHeaderParsed, %d, tileType, %d, serverUrl, %s, serverFilename, %s, absoluteLocalFilename, %s
TILE: _tileDownloadCompleted, success, %d
TILE: getNumOfActiveDownloads, tile, %s, is being downloaded, %d, total, %d, download, %p
TILE: requestDownload, type, %d, %s, not active
TILE: requestDownload, type, %d, %s, location, %14.8lf, %14.8lf, id, %s, reachbility, %d, details, %s
@TileDl, %{public}s, request, llsw, %{private}.2lf, %{private}.2lf
TILE: requestDownload, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: requestDownload, ignoring request, no sec_key
TILE: requestDownload, tileId=%s isAlreadyDownloaded, %d, isBeingDownloaded, %d, shouldDownloadedBasedOnPermissions, %d
TILE: requestDownload, tileid, %s, already available, isUpdateMTimestamp, %d, isShouldBeRefreshed, %d, isBeingDownloaded, %d
TILE: requestDownload, refresh download, %s
TILE: requestDownload, tileid, %s, will be downloaded, details, %s
TILE: requestDownload, tileid, %s, is locked will be redownloaded, details, %s, allowRedownload, %d, isAddToDownloadList, %d
TILE: requestDownload, tileid, %.8lf, %8lf, will be downloaded, details, %s
TILE: DEM,fForceDownloadDEMTiles, %d
TILE: DEM, skip, tile is not available based on availability file
TILE: HRSE, skip, tile is not available based on availability file
@TileReq, %{public}s, onlist, llsw, %{private}.2lf, %{private}.2lf, center, size, %{public}ld
TILE: requestDownload, out of boundaries, y, %d, x, %d, tile_y, %d, tile_x, %d, neighbourTileID, %s
TILE: requestDownload, y, %d, x, %d, tile_y, %d, tile_x, %d, neighbourTileID, %s
TILE: requestDownload, adding neighbour, %s
@TileReq, %{public}s, onlist, llsw, %{private}.2lf, %{private}.2lf, neighbor, size, %{public}ld
TILE: getTileFile, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: getTileFile, tile, %s, isAvailable, %d, isFileAccessible, %d
TILE: getTileFile, tileid, %s, not available
TileMgr, deleteTileFile, tileType, %{public}d, %{private}s, localPathToFile, %{public}s, #CloneMe
TILE: deleteTileFile, deleting, tileid, %s
TILE: addToDownloadList, added, %s, fTilesToDownload.size, %lu
#Warning TILE: updateProtectionClass, called on when not locked
TileMgr, updateProtectionClass, start, %s, reason, %s, isAboutToLock, %d, locationAge, %.1lf, doLocCheck, %d, sizes, %lu, %lu, knownLocation, %s
TileMgr, updateProtectionClass, failed unlocking tileid, %{private}s, size, %{public}lu, #CloneMe
TileMgr, updateProtectionClass, unable to lock tile, locking tileid, %{private}s, #CloneMe
TileMgr, tile ptr is NULL, #CloneMe
TILE: updateProtectionClass, location moved, locking tileid, %s
TileMgr, updateProtectionClass, unable to lock tile, locking tileid, %{pricate}s, #CloneMe
TileMgr, %{public}s, locking, %{public}d, lock, %{public}d, unlock, %{public}d, size, %{public}lu
TILE: updateProtectionClass, clearing unprotected map
TileMgr, Unable to lock all unprotected files!, #CloneMe
TILE: updateProtectionClass, end, %s, total, %lu, numOfUnProtectedTiles, %d
@TileEvent, %{public}s, locking, %{public}d, readable, %{public}lu
TILE: updateProtectionClass, done, isAboutToLock, %d, numOfUnProtectedTiles, %d
TILE: scheduleExpiredLocationTimer, no valid location
TILE: scheduleExpiredLocationTimer, reason, %s, locationAge, %.1lf, secondsFromNow, %.1lf, lastKnownLocation, %s
TILE: cancelExpiredLocationTimer
TILE: onExpiredLocationTimerFired, isLocked, %d
TILE: onExpiredLocationTimerFired
TILE: onPCTimerFired
TILE: onLocationNotification, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: onLocationNotification, ignore leech when LS off
TILE: onLocationNotification, fLastLocationDownloadCheckTimestamp, %.1lf, isForceLocationCheck, %d, fLastLocationProtectionCheckTimestamp, %.1f, leech location, %s
TILE: onLocationNotification, unknown notificaiton, %d, %s
TileMgr, onStatusNotification, unknown notification, %{public}d, #CloneMe
TILE: cleanUpDownloadList, start, isLocked, %d
TILES: cleanUpDownloadList, download list is too large, %lu
TILE: cleanUpDownloadList, tileid, %s, available on disc, no need to download
TILE: cleanUpDownloadList, done,  isLocked, %d, cleanedFiles, %u
TILE: CLTilesManager::shutdown
TILE: stats: getTileStats, demTilesDownloaded, %d
TILE: stats: getTileStats, hrseTilesDownloaded, %d
TileMgr, invalid tileType, %{public}d, #CloneMe
TILE: location not relevant
TILE: updating dem neighbor mtime, %d, type, %d, tileid, %s
Invalid dem neighbor tile id!
TILE: updating HRSE neighbor mtime, %d, type, %d, tileid, %s
Invalid HRSE neighbor tile id!
TileMgr, Invalid tile id!, #CloneMe
TILE: getAppAvailabilityForArea, index is not available until first unlock, fDataProtectionEnabled, %d
TILE: getAppAvailabilityForArea, tiles, %d, %s, are not active on this device
TILE: getAppAvailabilityForArea, loc, %.8lf, %.8lf, radius, %.3f
TILE: getAppAvailabilityForArea, tile, %s
TILE: getAppAvailabilityForArea, ctile, %s
TILE: already been searched
TILE: getAppAvailabilityForArea, y, %d, x, %d, ntile, %s
TILE: getAppAvailabilityForArea, appRecommendation, %lu, %s, loc, %.10lf, %.10lf, span, %.10lf, %.10lf
TILE: fullAppTilesServerUrl, %s
TILE: onStoreFrontDidChangeNotification, new fServerUrl, %s
TILE: shouldEnableAppTiles, %d, fAppTilesEnabled, %d
Get manifest tile, %lu
TransitMac: getTransitMacAddresses, tile exists, %s
TILE: tileDecompressionCompleted, added to unprotected list, tileid, %s, size, %lu
TILE: tileDecompressionCompleted, unable to unlock, tileid, %s, size, %lu
@TileList, %{public}s, add, llsw, %{private}.2lf, %{private}.2lf, %{public}s, size, %{public}lu, 
TILE: tileDecompressionCompleted, unlocked tile type, tileid, %s, unlocked, %d
CL: CLTilesManager::onPCTimerFired
{"msg%{public}.0s":"CLTilesManager::onPCTimerFired", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Cycle, CR DT Regression, %f, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, duration(s), %f, weight(kg), %f, METS, %f
Cycle, GPS speed at time, %f, %f is too high,  set to maximum default, %f
Cycle, Uphill vertical speed at time, %f, %f is too high, set to maximum default %f
Cycle, WR Linear Regression, %f, %f, Grade type, %d, GPS Speed, %f, Vertical Speed, %f, Duration(s), %f, Weight(kg), %f, WR METS, %f
Cycle, Model switcher input availability, StartTime, %f, EndTime, %f, ModelSwitcherInputCase, %d, gradeType, %d, hspeed, %f, vspeed, %f, isCatherineAvailable, %d, isCatherineReliable, %d, isGpsAvailable, %d, HRstaleness, %f
Cycle, Fused, %f, %f, HR METS, %f, WR METS, %f, Fused User METS, %f, Grade type, %d, GPS Speed, %f, Vertical Speed, %f, Duration(s), %f, Weight(kg), %f, Steps, %d, ModelSwitcherInputCase, %d, distance, %f, altitude, %f, HRstaleness, %f, HR, %f, userMetSource, %d, Fused Truth METs, %f, truthMetSource, %d, isAssistedCycling, %d
Cycle, RollingResistance,%f,gravity,%f,wind,%f
Cycle, totalWR,%f,startTime,%f,endTime,%f
{"msg%{public}.0s":"No root directory set for tile type", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"SignificantLocationVisit notification enabled"}
{"msg%{public}.0s":"received visit not inside sanctioned polygons"}
{"msg%{public}.0s":"Received error when fetching LOI", "location: ":%{private, location:escape_only}@}
{"msg%{public}.0s":"LOI type is home"}
{"msg%{public}.0s":"Computed timestamps for tracks", "start_s":"%{private}.09f", "end_s":"%{private}.09f"}
{"msg%{public}.0s":"number of submissions exceeded for", "type":%{private}ld}
{"msg%{public}.0s":"number of submissions so far. ", "numWorkSubmissions":%{public}d, "numUnknownSubmissions":%{public}d, "loiType":%{public}ld, "calibrationType":%{public}ld}
{"msg%{public}.0s":"#Warning,Requested unsupported harvest type", "loiType":%{public}ld, "calibrationType":%{public}ld}
{"msg%{public}.0s":"Sending track to buffer", "start_s":"%{private}.09f", "end_s":"%{private}.09f"}
{"msg%{public}.0s":"pressure range check", "pressure change":"%{private}.6f"}
{"msg%{public}.0s":"checking distance to visit", "visitLat":"%{private}7f", "visitLon":"%{private}7f"}
{"msg%{public}.0s":"#Warning,invalid visit location, abort distance check"}
{"msg%{public}.0s":"no location recorded"}
{"msg%{public}.0s":"faraway location encountered", "time_s":"%{public}.09f", "distance":"%{public}.2f", "locLat":"%{private}7f", "locLon":"%{private}7f"}
{"msg%{public}.0s":"received invalid pressure / time from source aggregator", "pressure":"%{private}5f", "time_s":"%{public}.09f"}
{"msg%{public}.0s":"received DBL_MAX pressure / TIME from source aggregator"}
{"msg%{public}.0s":"trigger floor transition harvest"}
{"msg%{public}.0s":"number of submissions exceeded for floor transition traces, submission denied"}
{"msg%{public}.0s":"no locations indicating user moved into close radius of the visit"}
{"msg%{public}.0s":"truncate period before user moved into close radius of the visit", "defaultStartTimestamp_s":"%{public}.09f", "timeUserBecomesCloseToSLV_s":"%{public}.09f"}
{"msg%{public}.0s":"received floor transition detection request", "pressure":"%{private}5f", "time_s":"%{public}.09f"}
{"msg%{public}.0s":"floor transition detected", "transition time_s":"%{private}.09f"}
{"msg%{public}.0s":"received request to resolve whether the following location is inside sanctioned polygons: ", "lat":"%{private}6f", "lon":"%{private}6f"}
Unable to get entries for sessionId %{public}s
Failed to bind id in query, %{public}llu
Unable to get entries
TILE: running initStaticGlobals
TILE: fMinimumSupportedTilesVersion, %d
TILE: CLWifiTileFile, sectionId, %d, %s
TILE: tileMacIndexHeader, entrySizeInBytes, %u
TILE: headers only, avoid reading SectionID_TileIndex_Mac
TILE: headers only, avoid reading SectionID_TileAccessPointTable
TILE: idx, %3lu, %3u, mac, %s, offset, %u
TILE: mac, %3u, mac,%x:%x:%x:%x:%x:%x, y, %3d, x, %3d, loc, %14.10lf, %14.10lf, unc, %.1lf, reach, %.1lf
TILE: binarySearchAP, match, %012llx, %012llx
WifiTile, binarySearchIndex, ==================> indexFailed <==================, size, %{public}4lu, a, %{public}4lu, b, %{public}4lu, c, %{public}4lu,  A, %{public}012llx,  S, %{public}012llx, B, %{public}012llx, #CloneMe
TILE: binarySearchIndex, indexFound, isFound, %d, wasSearched, %d, size, %4lu, a, %4lu, b, %4lu, c, %4lu, searchAr, %4u, A, %012llx,  S, %012llx, B, %012llx
TILE: traverseTileFile, message, %s, isHeadersOnly, %d, isBinarySearch, %d, macAddressToSearch, %012llx, cachedIndex, %d
TILE: traverseTileFile, indexVector cached, seek to the APs table, %lld
TILE: traverseTileFile, re-using cached index vector
TILE: traverseTileFile, searched index, A, %012llx, mac, %012llx, B, %012llx, indexSize, %lu, halting search
WifiTile, Invalid section signature, readBytes, %{public}lu, section, signature, 0x%{public}x, sectionId, %{public}d, sizeBytes, %{public}d, #CloneMe
WifiTile, message, %{public}s, readBytes, %{public}lu, section, signature, 0x%{public}x, sectionId, %{public}d, sizeBytes, %{public}d, headerSizeBytes, %{public}d, sectionId, %{public}d, #CloneMe
WifiTile, traverseTileFile, invalid tile file, bad allocation size, bytesToAllocate, %{public}lu, maxAllocationSize, %{public}lu, #CloneMe
TILE: skip section, message, %s, signature, 0x%x, sectionId, %d, sizeBytes, %d, headerSizeBytes, %d
WifiTile, failed to allocate memory for, %{public}lu, #CloneMe
WifiTile, failed to read, %{public}lu, %{public}lu, #CloneMe
TILE: searched index, A, %012llx, mac, %012llx, B, %012llx, indexSize, %lu, halting search
TILE: searched index, A, %012llx, mac, %012llx, B, %012llx, indexSize, %lu
TILE: headers only, avoid reading the APs
TILE: unknown section : %d
TILE: traverseTileFile, finished traversing, file, index entries, %lu, apEntries, %lu
Initializing CLFallTap2Radar instance
Tearing down CLFallTap2Radar instance
{"msg%{public}.0s":"CLFallTap2Radar::trigger avoiding tap to radar as fall submission is not allowed"}
{"msg%{public}.0s":"CLFallTap2Radar::trigger avoiding tap to radar as near fall submission is not allowed"}
{"msg%{public}.0s":"CLFallTap2Radar::trigger", "isFalsePositive":%{private}hhd, "isTruePositive":%{private}hhd, "isBackgroundDetected":%{private}hhd, "isNearFall":%{private}hhd, "wasEmergencyCallPlaced":%{private}hhd}
{"msg%{public}.0s":"Not logged", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"Logged", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLFallTap2Radar::trigger written snippet to", "url":%{private, location:escape_only}s}
{"msg%{public}.0s":"CLFallTap2Radar::trigger failed to write snippet to", "url":%{private, location:escape_only}s}
{"msg%{public}.0s":"CLFallTap2Radar::trigger no data to send"}
{"msg%{public}.0s":"CLFallTap2Radar::trigger posting notification", "delay":%{private}d}
CFUserNotificationReceiveResponse returned %d at time %f.
CLFallTap2Radar::trigger received default response
CLFallTap2Radar::trigger received alternate response for near fall.
CLFallTap2Radar::trigger received alternate response
CLFallTap2Radar::trigger received cancel response
{"msg%{public}.0s":"CLFallTap2Radar::trigger received unknown response", "button":%{public}d}
{"msg%{public}.0s":"CLFallTap2Radar::trigger opening tap2radar URL", "url":%{private, location:escape_only}s}
CLFallTap2Radar::trigger not opening tap2radar
@WifiChannel, receive channel %{public}d recommendation from 5GHz selector
@WifiChannel, time-based 5GHz, query latest ALS channels %{public}s
@WifiChannel, time-based 5GHz, fill the extra %{public}d channel(s) from preset
@WifiChannel, time-based 5GHz, trim channel recommendation down to %{public}lu candidates
@WifiChannel, time-based 5GHz, reset channel selector due to no APs
@WifiChannel, apply, time-based 5GHz channel selector overrides, %{public}s
@WifiChannel, apply, default 5GHz channel selector overrides, %{public}s
%s,Updated,With,%s,%0.4f,%s,%0.4f,Alpha,%0.4f,%s
%s INITIAL isWifiPowered=%d
%s Start monitor for active scanning
%s Stop monitor for active scanning
%s WIFI TIMER TRIGGERED
%s WIFI SCAN SETTINGS EMPTY, TIMER RACE?
%s WIFI POWER NOTIFICATION RECEIVED, power=%d nextFire=%f
%s WIFI IGNORING NOTIFICATION, cached=%d scantype=%d
%s WIFI EXECUTING IMMEDIATELY, now=%f nextRequestTime=%f
%s WIFI SCAN SCHEDULED FOR %f
%s WIFI SCAN EFFECTIVELY NOT SCHEDULED
%s WIFI IS POWERED OFF - NOT ISSUING SCAN REQUEST
CL: CLWifiScanner::onWifiNotification
{"msg%{public}.0s":"CLWifiScanner::onWifiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Registering with Motion Coprocessor
Unregistering with Motion Coprocessor
onBodyStatusData->onBodyStatus,%d,onBodyStatusData->confidence,%d,onBodyStatusData->timestamp,%f
CL: CLOnBodyNotifier7::onMotionCoprocessorData
{"msg%{public}.0s":"CLOnBodyNotifier7::onMotionCoprocessorData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLFallImpactMetrics: Setting %s for impact at %f
CLFallImpactMetrics: Setting isUser%s for impact at %f
CA - Events about to be created, isImpactCandidateEvent=%d, isAlertCandidateEvent=%d, isSOSCandidateEvent=%d
Unknown whether or not provider %{public}d is a candidate for autopause
PKAUTOPAUSE MEAN coord: %f %f %f %f %f %f %f %d %d 
Received companion message,type,%d,size,%lu
#Warning error serializing OdometerCyclingData
#Warning error deserializing OdometerElevationData
#Warning error deserializing CoarseElevationData
#Warning error deserializing Absolute Altitude update
Watch received absolute altitude update, timestamp, %f, altitude, %f, accuracy %f, precision, %f, status, %d
kTypeKappaCollect dont collect
Registering for companion notification type %d
Last Overridden Session,%ld, Registration Info Overridden Session,%ld
Unregistering for companion notification type %d
Sync state with Companion
#Warning Error serializing session override (%ld): %s
coarse elevation sub,enable,%d,transport,%d,subsCompleted,%d,unlockSinceBoot,%d,fitnessTracking,%d,numClients,%d
{"msg%{public}.0s":"#SLC ending metric session", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slc Cannot migrate legacy subscription data", "legacySubscriptionData":%{public, location:escape_only}@, "clientKey":%{public, location:escape_only}s}
{"msg%{public}.0s":"Client is not entitled to provide #SLC configuration", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"Client provided invalid #SLC configuration", "key":%{public, location:escape_only}s, "desiredPowerBudgetRaw":%{public}d}
{"msg%{public}.0s":"client subscribing to #SLC", "client":%{public, location:escape_only}s, "distance":"%{public}f", "powerBudget":%{public}d}
{"msg%{public}.0s":"#SLC starting metric session", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"Client unsubscribing #SLC", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#SLC Change in session state or #compensation", "clientKey":%{public, location:escape_only}s, "shouldBeRegistered":%{public}hhd, "shouldEngageCorrectiveCompensation":%{public}hhd}
Sending #SLC <%{private}+.8f,%{private}+.8f> acc %{private}.2f for %{public}s
{"msg%{public}.0s":"Not sending #SLC to #compensation client because their estimate hasn't changed", "name":%{public, location:escape_only}s}
CL: CLSLCSubscription::onSLCNotification
{"msg%{public}.0s":"CLSLCSubscription::onSLCNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSLCSubscription::onFLNotification
{"msg%{public}.0s":"CLSLCSubscription::onFLNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Warning CLMM,provideCacheHint reported error:%{public}lld (%{public}@) "%{private}@"
#Warning CLMM, query failed (getGeoMapFeatureRoadObject)
#Warning CLMM, getGeoMapFeatureRoadObject, GEOMapFeatureRoad id,%{private}lld,has less than two coordinate,%{public}ld
%.1lf,getGeoMapFeatureRoadObject Unable to find roads
#Warning CLMM, query failed (roadsWithinDistance)
#Warning CLMM, makeRoadFromGEOMapFeatureRoad returned nullptr
#Warning CLMM, interpolateOnRoad returned false
#Warning CLMM, input road is nullptr
#Warning CLMM, outgoing roads query failed (roadsAtIntersection)
#Warning CLMM, getGeoMapFeatureRoadObject returned nil
#Warning CLMM, incoming roads query failed (roadsAtIntersection)
#Warning,CLMM, road length is 0.0
#Warning CLMM, GEOMapFeatureRoad id,%{private}lld,has less than two coordinate (moveOnRoadInternal),%{public}ld
#Warning CLMM, GEOMapFeatureRoad id,%{private}lld,startCoordinate is null,%{public}ld
CLMM, query failed (moveOnRoad)
#Warning CLMM,moveOnRoadInternal,interpolateProjections returned false
#Warning,CLMM,input road is nullptr
#Warning,CLMM,GEOMapFeatureRoad id,%{private}lld,has less than two coordinate (moveOnRoadInternal),%{public}ld
CLMM,%.3lf, no more route roads available to cover the distance travelled,index,%d,size,%lu
CLMM,%.3lf, unexpectedly reached to the end of routeRoadList
CLOutdoorCycleWorkoutStopDetector,cyclingSource,%f,%d
Failure to get cycling result, %f
OutdoorCycleStop,state,%d,hasGPS,%d,hasHR,%d,hr,%f,hrConf,%f,stopCounter,%f,fStopCounterUpdateRate,%f,hasTier1,%d,tier1Type,%d,percentNonCycleinBuffer,%f,percentModelTier1Concordant,%f,cyclieState,%d
OutdoorCycleStop,HRExertionCheck,hrExertion,%f,minHr,%f,maxHr,%f,shouldTransition,%d
VO2Max,fMinPreviousEstimatesForHealthKitWrite,%{private}d
Beginning aggregation for VO2Max data
Aggregation of VO2Max data complete; input duration: %{public}f, output duration: %{public}f
Completed insert of input record; duration: %{public}f
VO2Max,workoutEvent,%ld,workoutType,%ld
VO2Max,Failure to estimate,status,%d,workout duration,%.3f,estimate,%f
Will not retrocompute VO2Max due to absense of VO2MaxInputs, workoutEndTime:%{private}f
VO2Max,vo2MaxEstimationStatus,%{public}d,priorVO2Max,%{private}f,biasAdjustment,%{private}f,longitudinalVO2Max,%{private}f,sessionVO2Max,%{private}f
VO2Max,currentWorkoutType,%ld,hrmin,%f,hrmax,%f,outdoorPedestrianNumPairs,%lu,outdoorPedestrianStatus,%d,outdoorPedestrianSessionStatus,%d,outdoorPedestrianSessionVO2Max,%.5f,outdoorPedestrianEst,%.6f,adaptiveModelNumPairs,%lu,adaptiveModelStatus,%d, adaptiveModelSessionStatus,%d,adaptiveModelSessionVO2Max,%.5f,adaptiveModelEst,%f,adaptiveModelPrior,%f,betaBlockerUse,%d,longitudinalVO2Max,%f,sessionVO2Max,%f,isEscalation,%d,sessionDuration,%.5f,sessionType,%ld,escalationRatio,%f,finalStatus,%d,eligibleForHealthKit,%d,eligibleForCalorimetry,%d,numWorkoutsContrToEstimate,%u
VO2Max,GetMeanMaxMets,canCalculateMeanMaxMets,%{private}s,meanMaxMets,%{private}.3f
VO2Max,SamplesPostSession,%{public}d,PostSessionDuration,%{public}f,startingHR,%{private}f,HRAfter60s,%{private}f,HRAfter120s,%{private}f
VO2Max,pctHRSamplesValidMin,%d,pctHRSamplesValidMax,%d,pctHRSamplesWithRecentHR,%d,pctMETSamplesWithValidDelta,%d
VO2Max,longitudinalConsistency,%d,old,%f,new,%f
VO2Max,age,%.2f,biologicalSex,%d,useBetaBlocker,%d,userBMI,%.2f,vo2MaxMean,%.2f,vo2MaxPrior,%.2f,hrMaxObserved,%.2f,hrMaxAgePredicted,%.2f,hrMaxAgeAndMedicationPredicted,%.2f,hrMinBodyMetricsPredicted,%.2f,hrOnset,%.2f,hrRestingObservedOneDay,%.2f,hrRestingObservedSevenDays,%.2f,maxMetsMean,%.2f,maxMetsHigh,%.2f,vo2MaxValue,%.2f,vo2MaxValueAdaptiveModel,%.2f,vo2MaxValueOutdoorPedestrianModel,%.2f,vo2MaxValueOOB,%.2f,vo2MaxValueAdaptiveModelOOB,%.2f,vo2MaxValueOutdoorPedestrianModelOOB,%.2f,efficiency,%.2f,clustersHRMeanPedestrianModel,%.2f,clustersMetsMeanPedestrianModel,%.2f,clustersHRMeanAdaptiveModel,%.2f,clustersMetsMeanAdaptiveModel,%.2f,vo2MaxStDev,%.2f,vo2MaxTrend,%.2f,vo2MaxTrendSingleEst,%.2f,workoutTypeRatioWalk,%.2f,workoutTypeRatioRun,%.2f,workoutTypeRatioHike,%.2f,lookbackNumEstimates,%d,lookbackNumEstimatesAfterUpdate,%d,lookbackNumDaysWithEstimate,%d,lookbackEWMAPlusWeightedStDev,%.2f,numWorkoutsContrToLatestEstimate,%d,pctGPSAvailability,%.2f,pctHeartRateAvailability,%.2f,pctBackgroundEscalation,%.2f,pctHRMax,%.2f,pctHRMin,%.2f,validGradeMean,%.2f,validGradeStd,%.2f,pctGradeAboveAnalyticsThreshold,%.2f,workoutType,%d,sessionType,%d,sessionDuration,%.2f,hrMinSource,%d,vo2MaxEstimationStatus,%d,arbitrationState,%d,limitState,%d
VO2Max,Analytics unexpectedly not able to retrieve a session record for the minimum algorithm version with startTime > %{public}.3f
VO2Max,weightedAvg,%{private}.3f,std,%{private}.3f
VO2Max,Not sending analytics, no IHA permission
PreProcessor,PairStats,total,%d,warmup,%d,grade,%d,flat,%d,delta,%d,metsAboveMin,%d,gps,%d,stride,%d,distance,%d,source,%d,hrOK,%d,totalWorkoutLengthOK,%d,totalPaceOK,%d,totalStrollerOK,%d,totalPercentWalkingOK,%d,metsAboveAdaptiveMin,%d,totalGoodForClustering,%d,totalGoodForAdaptiveModel,%d,workoutStartTime,%f,workoutSessionType,%d
Bias Scheduler Context created
New reference data, starting track, TrackStartTime %f, reference type %d
switched from location track to companion track at time %f
bias too stale, bias age %f, track length is %f
Calibration track with start time %f, end time %f will not be submitted because device was wet at %f
Calibration track submitted with start time %f, end time %f
{"msg%{public}.0s":"Starting new track", "TrackStartTime_s":"%{public}.09f"}
{"msg%{public}.0s":"No new data, don't start a new track between", "TrackStartTime_s":"%{public}.09f", "TrackStopTime_s":"%{public}.09f"}
biasEstimationScheduler, lastWetTimestamp updated to %f
StandPlus,clearing buffers from body metrics,old,%{public}d,new,%{public}d
StandPlus,minuteAwarded,startTime,%{public}f,endTime,%{public}f,totalMetTime,%{public}f,totalSteps,%{public}d,metConditionMet,%{public}d,stepConditionMet,%{public}d
Unexpected notification from pressure db.notification,%d
CL: CLPressureBias::onDb
{"msg%{public}.0s":"CLPressureBias::onDb", "event":%{public, location:escape_only}s, "this":"%{public}p"}
readFactoryData cannot be called without a node or a property
Cannot find pressure registry entry
Failed to create CFString from proprety
Cannot get %s property
%s property is not CFData
%s property too small
Updating fMachToWallOffset %f, mach time %f, wall time %f, iohidtime %f
Unable to update fMachToWallOffset! %d
Sending userParam: %d
predictionInterval,%{public}f,ispUpdateInterval,%{public}f
Warning: dynamic bias estimation disabled!
Warning: manual gyro bias offset [%f %f %f] dps,error,%f
{"msg%{public}.0s":"setFeatures must be called before configureMotionCoprocessor", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Send gyro bias fit sync
GyroBiasFit,slope.x,%{public}f,.y,%{public}f.z,%{public}f,intercept.x,%{public}f,.y,%{public}f.z,%{public}f,lastMiniCal,%{public}f,hours,%{public}d
Decreasing proactive gyro bias estimation timeout for out of box.
NonlinearBiasFit,%{public}s
Send pressure bias fit sync
Send GMM data sync
Warning: No gmm data available
GeomagneticModelData.magnitude,%f
[SidebandSensorFusion] Feature not available.
[SidebandSensorFusion] configuring,enableCount,%{public}d,latencyCount,%{public}d,snoopCount,%{public}d
Setting activityOverride: when in activityType,%d, guarding against unexpected hkActivityType,%d 
Setting activityOverride: %d,hkActivityType,%d
Proactive gyro calibration disabled.
proactiveRevistTime,%{public}d sec
Kick-Off gyro bias fit using 0-fit
[OscarEmuReplay] Started.
[OscarEmuReplay] Stopped
motionstateupdate, calling setMotionStateYouthSim(%d, %hhu)
reply,%d
Invalid CMMotionCoprocessorReply::Log structure.
{"msg%{public}.0s":"received AOP log", "log":%{public, location:CMMotionCoprocessorReply_Log}.*P}
Type,%s,motionStateUpdate:Motion,%{public}d,conf,%{public}d,Mounted,%{public}d,MountedConf,%{public}d,exitState,%d,turn,%d,isVehicular,%d,isMoving,%d,seq,%d,motionTypeString,%s,startTime,%{public}f,timestamp,%f,startTimeUL,%lld,nowUL,%lld -- caltype,%d,vm,%f,standing,%d,machinefrequency,%f,strokefrequency,%f,strokeAmplitude,%f,strokepower,%f,meanAngleX,%f,pushVectorMagnitude,%f,rawMotionType,%{public}d,rawConf,%{public}d,rawMotionTypeString,%s,vehicularFlags:%{public}d,motionHint,%d,gpsHint,%d,basebandHint,%d,wifiHint,%d,btHint,%d,drivingStowedLikelihoodSum,%{public}f,drivingArmLikelihoodSum,%{public}f,ssLikelihoodSum,%{public}f,workoutDetectionType,%{public}d,workoutDetectionTime,%{public}f,vehicularConfidence,%{public}d,workoutDetectionTimeUL,%lld,workoutEscalationTime,%lld,MotionYouth,%{public}d,YouthClassificationReason,%{public}d,averageALSLux,%{public}d
After vehicular transition, startTime, %{public}f, rawMotionType, %{public}d, rawConfidence, %{public}d, mounted, %{public}d, mountedConfidence, %{public}d, drivingStowedLikelihoodSum, %{public}f, drivingArmLikelihoodSum, %{public}f, ssLikelihoodSum, %{public}f
Timestamp,%f,StepCount,%d,Stride,%0.2f,Ascended,%d,Descended,%d,ElevationUp,%d,ElevationDown,%d,Pace,%f,ActiveTime,%f,DeltaSteps,%d,locationdGpsTime,%20.20f,startTime,%f,currentCadence,%f,FirstStepTime,%f,RelativeTimeOfLastStep,%d,FloorCountingSupported,%d,pedometerArmConstrainedState,%d,FlightState,%d,FlightFailResetUnknown,%d,FlightFailResetWater,%d,FlightFailResetFrozen,%d,FlightFailInOutTrans,%u,FlightFailElevDelta,%u,FlightFailStepsPerElevRate,%u,FlightsFailElevRate,%u,PressureAmplitude,%f,PressureTemperature,%hd,FalseStepDetectorAccelPoseXHigh,%u,FalseStepDetectorAccelVarXYZLow,%u,FalseStepDetectorGyroNumSamplesSufficient,%u,FalseStepDetectorGyroVarXHigh,%u,FalseStepDetectorConsecutiveRequirement,%u,IsVehicularLowConfidence,%u,IsVehicularHighConfidence,%u,FalseStepDetectorConsistentStepsProtection,%u,FalseStepsSuppressed,%u,AverageFilteredPressure,%f,StepCountCurrentlySimulated,%d,DefaultStepsPerHour,%i,DefaultStepDurationHours,%i
CSLSStatusOverlayAssertion %sacquired
CSLSStatusOverlayAssertion invalidated
Assertion failed: fStatusBarAssertion, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Daemon/Motion/Utilities/CLMotionCoprocessor.mm, line 1409,We should have created a status bar assertion first.
Toggle fall detection status, %d
Timestamp,%.3f,StartTime,%.3f,ActivePedState,%u
trigger,%d,duration,%lld
MotionWakeReason,%u
Received bad wake reason from motion coprocessor,reason,%d
Type,CLOscar,onBodyStatus,%d,confidence,%d,timestamp,%f
Enabled,%{public}d,Proactive,%{public}u,EndCondition,%{public}hhu,SampleInterval,%{public}d,Temperature,%{public}f,DynamicBias.x,%{public}.3e,.y,%{public}.3e,.z,%{public}.3e,Covariance.x,%{public}.3e,.y,%{public}.3e,.z,%{public}.3e
Type,CLOscar,SedentaryAlarm:startTime,%f,firedTime,%f,type,%d,didWake,%d
Received stored user info from SPU, gender, %d, height(m), %f, weight(kg), %f, vo2max, %f, age, %f, hrmin, %f, hrmax, %f, hronset, %f, pal, %f, condition, %d, runVo2max, %f,betaBlockerUse, %d, biologicalSex, %d, isAgeSet, %d, isHeightSet, %d, isWeightSet, %d, adaptiveExerciseMinuteThreshold, %f
UrgentMiniCal requested
Coarse elevation,startTime,%f,ascended,%d
uuid,%s,name,%s
Baseband speed,timestamp,%f,startTime,%f,speedThreshold,0x%02hhx,speedRange,0x%02hhx,scaledValue,0x%02x,reserved,0x%02x,speedThresholdStr,%s,speedRangeStr,%s
received SkiAlarm,timestamp,%f
{"msg%{public}.0s":"visitHgal notifying clients (sampled)", "x":"%{public}f", "y":"%{public}f", "z":"%{public}f", "ts":%{public}llu, "dts":%{public}llu, "index":%{public}llu}
{"msg%{public}.0s":"Fall distance event record", "fFallTimestamp":%{private}llu, "fOperatingMode":%{private}u, "fPeakTimestamp":%{private}llu, "fBeforeImpactElevation":"%{private}.4f", "fAfterImpactElevation":"%{private}.4f", "fBeforeImpactStaticPeriodStartTimestamp":%{private}llu, "fAfterImpactStaticPeriodStartTimestamp":%{private}llu, "fFallDistance":"%{private}.4f"}
CLMotionCoprocessor::visitHighResolutionImpactDataStart
visitFlightSegment,now,%{public}llu,start,%{public}llu,end,%{public}llu,rate,%{public}f,probability, %{public}f, elevationChange, %{public}f, regressionMad, %{public}f, isValid, %{public}d, hasAtLeast2mElevChange, %{public}d
visitKFFilteredPressure nowAP %{public}f nowAOP %{public}llu filteredPressure %{public}f pressureTimestamp %{public}llu, kfElevation %{public}f wallTimePressureCorrected %{public}f wallTimeKFCorrected %{public}f
visitGyroEscalationState, timestamp, %{public}f, AopTime, %{public}llu, totalGyroTimeInSec, %{public}f, sessionTimeInSec, %{public}f, isQuotaMet, %{public}d, numEscalations, %{public}u
visitTier1CyclingFeatures,startTime,%{public}f,isArmConstrained,%{public}d,accelXPowerSum,%{public}f,grav90th_100Hz,%{public}f,cyclingProbability,%{public}f,smoothCyclingProbability,%{public}f,roadNoise,%{public}f,pedEnergyVertical,%{public}f
trigger,%u,duration,%f
Sending user info,fGender,%d,fHeightM,%f,fWeightKG,%f,fVo2Max,%f,fAge,%f,HRMin,%f,HRMax,%f,fHROnset,%f,fPal,%f,fCondition,%d,fRunVo2Max,%f,fBetaBlockerUse,%d,fBiologicalSex,%d,fIsBodyMetricSet,%d ,fAdaptiveExerciseMinuteThreshold,%f
Sending user info + walk stride length step cadence pair
Sending isVehicular %{public}d, vehicularConfidence %{public}d
MotionStateObserver, Sending down ActivityOverride,session,%d,hkActivityType,%d
[SedentaryTimerTriage] SedentaryAlarm, setSedentaryAlarmHandler!
[SedentaryTimerTriage] SedentaryAlarm, startSedentaryAlarm!
configuring on body detector
CLMotionCoprocessor %{public}s gyro bias and variance updates
Sending command to reset workout detector.
Sending updated alternate escalation parameters to the AOP: lookbackTimeInSeconds,%hu,activeTimeInSeconds,%hu,activeSpeedInMPH,%f
Cannot update alternate escalation parameters: lookbackTimeInSeconds,%hu,activeTimeInSeconds,%hu,activeSpeedInMPH,%f
Sending cycling state,%d
Sending workout pause/resume,%d
Toggle Tier1CyclingFeatures updates,%{public}d
Sending ski transition %d
Sending altimeter command to the AOP,%u
Sending update for ALS active scans to the AOP,shouldEnable,%d
%s accepted, timestamp, %f, speed, %f, speedUnc, %f, speedSource, %d, ageOfEstimation, %f
Youth Fitness Mode, %{public}d
isVehicleConnected,%d
Received VehicleConnection notification,%d,startTime, %f,endTime,%f
pressureBiasFit.fMedianTemperatureOffsetCoefficient,%f,pressureBiasFit.fMedToc_FactoryTemp,%f,fMaxTemp,%f
PressureInertialFit,compensationOnX,%f,compensationOnY,%f,compensationOnZ,%f
Unexpected CLPressureBias notification.notification,%d
#Warning Unhandled notification %d.
Unhandled notification from CLMotionState in CLMotionCoprocessor.
Sending induced motion: touch, %d, vibe, %d, sum, %d
Resetting compass on pencil state update, isAttached, %d
CL: CLMotionCoprocessor::onPressureBias
{"msg%{public}.0s":"CLMotionCoprocessor::onPressureBias", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionCoprocessor::onWatchOrientationSettingsNotification
{"msg%{public}.0s":"CLMotionCoprocessor::onWatchOrientationSettingsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionCoprocessor::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLMotionCoprocessor::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionCoprocessor::onPencilStateNotification
{"msg%{public}.0s":"CLMotionCoprocessor::onPencilStateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
BATCH: received locations w/ odometer: %f, %f
#Warning BATCH: odometer ran from %f to %f
#Warning BATCH: Received a location (%s) without an odometer while odometer alarm was set
#Warning BATCH: odometer reset: %.2f
BATCH: received odometer: %f
BATCH: Should not be registered for location
BATCH: Unexpected notification: %{public}d
{"msg%{public}.0s":"out of bounds index entry in #batchedlocations", "index":%{public}ld, "batchedLocationsSize":%{public}ld, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
IndoorOutdoor[%d][gps-current],[A-%s],timestampGps,%f,odometer,%f,gpsHeadingRad,%f,accuracy,%f[B-%s],timestampGps,%f,odometer,%f,gpsHeadingRad,%f,accuracy,%f[interp],startTime,%f,gpsDistance,%f,gpsHeadingRad,%f
IndoorOutdoor[%d][gps-previous],[A-%s],timestampGps,%f,odometer,%f,gpsHeadingRad,%f,accuracy,%f,[B-%s],timestampGps,%f,odometer,%f,gpsHeadingRad,%f,accuracy,%f,[interp],startTime,%f,gpsDistance,%f,gpsHeadingRad,%f
IndoorOutdoor[%d][step],startTime,%f,stepCount,%u,stepDistance,%f,rawStepDistance,%f,
IndoorOutdoor[%d][turn-recv],startTime,%f,gyroHeadingRad,%f
IndoorOutdoor[%d][turn-none],requestedSampleTime,%f
IndoorOutdoor,GPSResult,stepDeltaDistance,%f,gpsDeltaDistance,%f,fResidScalar,%f,fIMUDistanceX,%f,fIMUDistanceY,%f,stepTimestamp,%f,fGpsState,%d,gpsDiscordanceProbability,%f,gpsDiscordanceRawProbability,%f,gpsDiscordance,%f,numValidDiscordanceSamples,%d,llrBufferSumProbability,%f
{"msg%{public}.0s":"Iterator indices are outside of the buffer range.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"We should have picked at least one of the windows.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"IndoorOutdoorGpsChange", "Old GPS State":%{public}d, "New GPS State":%{public}d, "Epochs No Fix":%{public}d, "GPS fix buffer sum":"%{public}.9f", "GPS wander LLR sum":"%{public}.9f", "GPS LLR sum":"%{public}.9f"}
in-out-metrics,stepDeltaDistance,%f,gyroHeadingRadians,%f,gpsDeltaDistance,%f,gpsHeadingRadians,%f,bodySum,%f,fTurnEnv,%f,fGPSTurnEnv,%f,fResidScalar,%f,fIMUDistanceX,%f,fIMUDistanceY,%f,fGPSDistanceX,%f,fGPSDistanceY,%f,fGpsWanderLLRBufferSum,%f,fGpsLLRBufferSum,%f,fGpsFixBufferSum,%f,stepTimestamp,%f,fGpsState,%d
Week,%.0f,Support,%lu,BaseConf,%.3f,Conf+,%.3f,Dist,%.1f,timeWithSteps,%.1f,steps,%d
Saw %d goodWalkWorkouts and %d days of data in current week, 1 workout or at least %.1f days required 
Saw %d days of data in last %d days, at least %.1f required, earliest day with watch use was %.1f
Week,%.0f,meanFlightsPerDay,%.3f,meanStepsPerDay,%.3f,meanExerciseMinutesPerDay,%.3f
pDist,%{private}.0f,pSpeed,%{private}.0f,pSpeed95,%{private}.0f,pActivity,%{private}.0f,maxBout,%{private}.0f,avgActiveTimeInSupport,%{private}.0f,maxRunningDist,%{private}.0f,p6MWD,%{private}.0f
p6MWD based on %{public}s
No p6MWD estimate, insufficient time on wrist
No valid bouts for period ending %{public}.0f
No p6MWD estimate, no activity prediction
No p6MWD estimate, insufficient points for pSpeed
No p6MWD estimate, high uncertainty in speed prediction
No p6MWD estimate, inconsistent estimates
Available p6MWD estimate
Available p6MWD estimate because of workout
minCadenceForBouts,%.3f,minCadenceForWorkouts,%.3f,boutsUsed,%d
Week,%.0f,boutStart,%.3f,boutEnd,%.3f,dist,%.3f,steps,%d,activeTime,%.3f,workoutType,%d,conf,%.3f,baseConf,%.3f,supportsBout,%.3f
{"msg%{public}.0s":"Unhandled message", "name":%{public, location:escape_only}s, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#distributedSensing Service unavailable", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#distributedSensing Error obtaining subscription key", "client":%{public, location:escape_only}s, "subscribe":%{public}hhd}
{"msg%{public}.0s":"#distributedSensing Client subscribe", "client":%{public, location:escape_only}s, "subscribe":%{public}hhd}
Semistationary, Wheelchair, %d, metsFromIntensity, %.1f, metsFromPosture, %.1f, userMetsFinal, %.1f, userMetsFromPushes, %.1f, computeTime, %.1f, truthMetsFinal, %.1f, truthMetsFromPushes, %.1f
[FSM] %u,event,%u,transition,from,%u,to,%u
{"msg%{public}.0s":"CLWifi1SystemLogic::apply", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "event":%{public, location:escape_only}s, "now_s":"%{public}.09f"}
{"msg%{public}.0s":"wifi location update request state change", "before":%{public, location:escape_only}s, "after":%{public, location:escape_only}s}
initialize
CloseTrack,Stop
Type,%s,Pos,%d,%+.10f,%+.10f,Accuracy,%.3f,Speed,%0.3f,Course,%0.3f,Altitude,%0.3f,VerticalAccuracy,%0.3f,Timestamp,%0.3f,Source,%d
CloseTrack,GpsSourceChange,GpsSourceOld,%ld,GpsSourceNew,%ld
Suppressing duplicate GPS Odometer Entry from CalTrack %@
CloseTrack,GpsLocationEntryTimeOut,TimeSinceLastEntry,%0.2f
CloseTrack,GpsFilteredHorizontalAccuracyOutOfBounds,HorizontalAccuracy,%0.2f
CloseTrack,GpsFilteredSpeedOutOfBounds,Speed,%0.2f
CloseTrack,NumSamplesMaxGpsFilteredLocation,NumSamples,%d
CloseTrack,GpsOdometerEntryTimeOut,TimeSinceLastEntry,%0.2f
CloseTrack,DistanceGpsRoughMax,DistanceGpsRough,%0.2f
CloseTrack,TimeSpanMax,Timespan,%0.2f
CloseTrack,NumSamplesMaxGpsOdometer,NumSamples,%d
CloseTrack,PedometerEntryTimeOut,TimeSinceLastEntry,%0.2f
CloseTrack,NoStepsForTwoPedometerEntries
CloseTrack,PedometerSpeedCurrentZero
CloseTrack,PedometerSpeedCurrentJump,SpeedCurrentPrev,%0.2f,SpeedCurrent,%0.2f,SpeedCurrentJumpPercent,%0.2f
CloseTrack,PedometerArmConstrainedState,%d
CloseTrack,NumSamplesMaxPedometer,NumSamples,%d
CloseTrack,NumAdditionalPedometerEntriesRemoved,%ld
CloseTrack,TrackMetrics,TimeStartGpsLocationSegment,%0.2f,TimeEndGpsLocationSegment,%0.2f,%s
CloseTrack,Fail,DistanceGpsNotSufficient,DistanceGps,%0.2f
CloseCurrentTrack,Fail,GpsSpeedDiscrepancyDetected,SpeedGpsRawMean,%0.2f,GpsDistanceOverTime,%0.2f,SpeedErrorPercent,%0.2f
CloseTrack,Success
noSamples < 1 || hist.empty()
unexpected trained cdf data size issue
OdometerQualityIndicator,%d,r2,%f
fElevationBuffer timestamp did not move forward, timestamp, %llu
fStepHistory timestamp did not move forward, timestamp, %llu
Assertion failed: fElevationBuffer.size() > 2, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMFilteredElevationStepHistory.cpp, line 184,fElevationBufferSize,%zu.
logLatestTime for %s
Activity,lastTime,%f
Elevation,lastTime,%f
GPS,lastTime,%f
HR,lastTime,%f
Steps,lastTime,%f
Activity2,lastTime,%f
Activity2Smooth,lastTime,%f
Turns,lastTime,%f
ExtendedSteps,lastTime,%f
Swim,lastTime,%f
WatchPressure,lastTime,%f
CyclingState,lastTime,%f
Tier1CyclingFeatures,lastTime,%f
time rollback on update, currentTime, %f, lastUpdateTime, %f
Deleting VO2MaxStagingHistory records from db where sessionId = %{public}s
VO2MaxStagingHistory, DB not accessible
Promoting staging data
TileError, connectivity, current, %{public}d, neighbor, %{public}d
TileError, connectivity, neighbor, %{public}d, nonneighbor, %{public}d
TileQueue, %{public}s
TileDl, preindexskip, request, #CloneMe
@TileQueue, usable, %{public}d, tileid, %{private}s
@TileQueue, onlist, tileid, %{private}s
@TileQueue, unreadable, %{public}d, tileid, %{private}s
@TileQueue, queue, 1
@TileQueue, skip, alreadyDownloaded, %{public}d, accessible, %{private}d, inqueue, %{public}d, locked, %{private}d
@TileDl, skipneighbor, %{private}.2lf, %{private}.2lf, locked, %{public}d, dled, %{public}d, pending, %{public}d, outbounds, %{public}d
TileDl, preindexskip, addToDownloadList, #CloneMe
@TileDl, skipall, first unlock
@TileDl, skipall, on connectivity
@TileDl, skipall, in progress
@TileReq, %{public}s, attempts, llsw, %{private}.2lf, %{private}.2lf, isDownload, %{public}d, lastSuccess, %{public}d, existsOnServer, %{public}d, sinceLastDownload, %{public}.1lf, path, %{public}s
@TileError, %{public}s, nostate, %s, llsw, %{private}.2lf, %{private}.2lf, nlist, %{public}ld, nstate, %{public}lu
@TileDl, %{public}s, makestate, %s, llsw, %{private}.2lf, %{private}.2lf, nlist, %{public}ld, nstate, %{public}lu
@TileDl, %{public}s, checkNextEligible, tilesToDownload, %{public}lu, tilesCanBeDownloaded, %{public}lu, ncurrent, %{public}d, connectivity, %{public}d, %{public}d, %{public}d, location, %{private}0.1f, %{private}0.1f, %{public}1.f
@TileReq, %{public}s, start, llsw, %{private}.2lf, %{private}.2lf, allowOverCellular, %{public}d, isCurrentTile, %{public}d, %{private}s
@TileDl, cell, skipall
@TileDl, %{public}s, completed, llsw, %{private}.2lf, %{private}.2lf, success, %{public}d, nlist, %{public}ld, nstate, %{public}lu, rtt, %{public}.1f
TileDl, preindexskip, refresh, #CloneMe
@TileDl, checkRefresh, llsw, %{private}.2lf, %{private}.2lf, expired, %{public}d, onlist, %{public}d
{"msg%{public}.0s":"CLTileDownloader::deleteAgedDownloadItems", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "now_s":"%{public}.09f"}
@TileQueue, deleteAged, startsize, %{public}lu
TileQueue, %{public}s, reqage, llsw, %{private}.2lf, %{private}.2lf, age, %{public}0.1f, time, %{public}0.1f, size, %{public}lu
@TileQueue, deleteAged, %{public}d, endsize, %{public}lu
{"msg%{public}.0s":"Finished CLTilesDownloader::deleteAgedDownloads", "deleted":%{public}u}
{"msg%{public}.0s":"CLTileDownloader::cancelAllDownloads", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "planned":%{private}lu}
@TileQueue, cancelAll, size, %lu
TileQueue, cleanupList, start, size, %{public}lu, thresh, %{public}d
@TileReq, %{public}s, keeplist, llsw, %{private}.2lf, %{private}.2lf, reasons, dl, %{public}d, retry, %{public}d, onserver, %{public}d, ondisc, %{public}d
TileQueue, cleanupList, done, size, %{public}lu, cleanedFiles, %{public}u
TileQueue, setReach, %{public}d
TileQueue, firstUnlock
Programmer error, we expect an expiration record!
Failed to shift records.
Error setting elevation offsets.
{"msg%{public}.0s":"#proactive battery level overwritten by network default"}
{"msg%{public}.0s":"#proactive policy constructor", "isProactiveAllowed":%{private}hhd, "proactiveBatteryLevel":"%{private}.02f"}
{"msg%{public}.0s":"#proactive CLPolicyProactive.start Darwin Notification"}
{"msg%{public}.0s":"#proactive battery level overwritten by harvest rules", "proactiveBatteryLevel":"%{private}f"}
#proactive Extending proactive harvesting power assertion. Elapsed proactive time, %0.2f, minimum elapsed interval, %0.2f
{"msg%{public}.0s":"#proactive not allowed, prohibity by default write"}
{"msg%{public}.0s":"#proactive not allowed, 'Traffic' system service not authorized"}
{"msg%{public}.0s":"#proactive not allowed, battery criteria not met"}
{"msg%{public}.0s":"#proactive not allowed, device is ineligible"}
{"msg%{public}.0s":"#proactive not allowed, high CPU thermal criteria not met"}
{"msg%{public}.0s":"#proactive not allowed, low CPU thermal criteria not met"}
{"msg%{public}.0s":"#proactive now allowed"}
{"msg%{public}.0s":"#proactive taking no action, gps harvest not supported"}
{"msg%{public}.0s":"#proactive taking no action, already in desired state: ", "start":%{private}hhd}
#proactive Last attempted proactive harvesting %.3fs ago - waiting until %.3fs (%.3fs away) before trying again
{"msg%{public}.0s":"#proactive starting proactive", "sinceLastProactiveSession_s":"%{private}.09f", "isDominantDriving":%{private}hhd}
#wigo,on,proactiveHarvest
{"msg%{public}.0s":"#proactive stopping proactive harvest", "proactiveHarvestDuration_s":"%{private}.09f"}
{"msg%{public}.0s":"#proactive Could not release power assertion.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#wigo,off,proactiveHarvest
{"msg%{public}.0s":"#proactive setHarvesting ", "enabled":%{private}hhd}
#proactive Did not achieve vehicular speed from <%+.8f,%+.8f> in %.3fs, turning off proactive harvesting
{"msg%{public}.0s":"#proactive request #proactive authorization status", "isAuthorized":%{private}hhd}
{"msg%{public}.0s":"#proactive battery criteria not achieved: battery disconnected"}
#proactive battery criteria not achieved: battery level too low:required,%.2f,achieved,%.2f
#proactive battery criteria not achieved: battery level dropped: from,%.2f,to,%.2f
#proactive battery criteria achieved
{"msg%{public}.0s":"#proactive timer fired"}
#proactive GPS timed out (last location <%+.8f,%+.8f> from %.3fs ago), turning off proactive harvesting
#proactive Proactive harvesting is not allowed, ignoring, onProactiveTimer
#warning: zero-mean coefficient of variance
BoutExtractor: Unexpected type %d, cannot determine ranges
BoutExtractor: Boutwise %{public}s above limit, ignoring (%{private}.3f)
BoutExtractor: Boutwise %{public}s below limit, ignoring (%{private}.3f)
{"msg%{public}.0s":"[FastPathDevice] initializeFastPath should be running on motion thread", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[FastPath] Already initialized
[FastPath] Couldn't initialize FastPath due null service ref
[FastPath] Initialization failed,serviceRef,%@,properties,%@
[FastPath] copyEvent Failed (%{public}x)
Instantiating CLTileSyncManager
Instantiating NoopTileSyncManager
Error opening recording %@
Error opening D recording
Could not remove D MSL, error: %@
Begin sorting (%{public}u, %{public}u, %{public}u, %{public}u, %{public}u) items
Failed to open MSL streams
channel %{public}u sorted timestamp went backward; %{public}llu < %{public}llu, prev %{public}u
Done sorting with (%{public}u, %{public}u, %{public}u, %{public}u, %{public}u) remaining
error completing recording error = %@
moving recording from %@ to %@
stopping a recording that has not been started; noop
Keeping MSL %@, %u B
Deleting MSL %@, %u B
Error removing MSL %@, error: %@
precondition violation: audio frame chopped up! nByte %u
Dropping too early GPS item with AOP timestamp %llu
Dropping backward GPS item with AOP timestamp %llu
#Warning Client %s did not pass entitlement/tcc checks.
#Warning METMinutes,Client failed entitlement check, %s, %d, %p
METMinutes,query,empty request
METMinutes,query,error,invalid parameter,%@
METMinutes,query,error,%{public}d
METMinutes,query,range,from,%.3f,to,%.3f,count,%lu,response,%@
VO2MaxData,Client failed entitlement check, %s, %d, %p
VO2MaxData,query,empty request
VO2MaxData,query,error,%{public}d
VO2MaxData,query,fromRecordId,%llu,count,%lu,response,%@
{"msg%{public}.0s":"location source updated with", "altitude":"%{private}f", "time_s":"%{private}.09f", "lat":"%{private}f", "long":"%{private}f", "type":%{private}d, "isPrefilteredLocation":%{private}d, "rawAltitude":"%{private}f", "rawVerticalAccuracy":"%{private}f", "DEM":"%{private}f", "horizontalAccuracy":"%{private}f", "verticalAccuracy":"%{private}f", "DEMUncertainty":"%{private}f", "Environment":%{private}d, "Slope":"%{private}f", "MaxAbsSlope":"%{private}f", "Speed":"%{private}f", "SpeedAccuracy":"%{private}f", "MatchQuality":%{private}d}
{"msg%{public}.0s":"prefiltered location source updated with", "altitude":"%{private}f", "time_s":"%{private}.09f", "lat":"%{private}f", "long":"%{private}f", "type":%{private}d, "isPrefilteredLocation":%{private}d, "rawAltitude":"%{private}f", "rawVerticalAccuracy":"%{private}f", "DEM":"%{private}f"}
{"msg%{public}.0s":"pressure source updated with", "time_s":"%{public}.09f", "pressure":"%{private}f", "temperature":"%{private}f"}
{"msg%{public}.0s":"wifi source updated with", "scanTimestamp_s":"%{private}.09f", "mac":%{private, location:escape_only}s, "channel":%{private}d, "rssi":%{private}d, "hidden":%{private}hhd}
{"msg%{public}.0s":"elevation source updated with", "timestamp_s":"%{private}.09f", "elevation":%{private}d}
{"msg%{public}.0s":"companion source updated with", "timestamp_s":"%{private}.09f", "biasInMeters":"%{private}f", "uncertaintyInMeters":"%{private}f"}
companion source updated with timestamp %f, altitude %f, uncertainty %f
{"msg%{public}.0s":"kfPressure source updated with", "timestamp_s":"%{private}.09f", "kfPressure":"%{private}f", "kfElevation":"%{private}f"}
Sent%s onBodyDetection message to %s, %s
#Warning Client %s does not have appropriate entitlement to access on body detection SPI
Received OnBodyDetection request,client,%s,subscribe,%d
Wrong parameters were passed!
CL: CLOnBodyDetectionSubscription::onOnBodyNotification
{"msg%{public}.0s":"CLOnBodyDetectionSubscription::onOnBodyNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
HR,fhr,%{private}0.2f,userAge,%{private}0.2f,normalizedMets,%{private}0.2f
%@, %s, %p
CyclingDistance, sent datums, %{public}lu, first, %{public}@, last, %{public}@
OdometerGpsAvailability subscription changed, %d, %s, %p
Odometer subscription changed, %s, %p, %d
Cycling Workout Distance subscription changed, %s, %p, %d
CL: CLOdometerSubscription::onOdometerUpdate
{"msg%{public}.0s":"CLOdometerSubscription::onOdometerUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLOdometerSubscription::onNatalimetryUpdate
{"msg%{public}.0s":"CLOdometerSubscription::onNatalimetryUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
[Zg] summary,%d,A,%hu,B,%hu,C,%f,D,%f,E,%f,F,%f,G,%f,H,%hd,I,%hu,J,%d,K,%d,L,%d,config-1,%f,config-2,%f
zg (%d, %d, %f, %f, %f, %f, %f, %d, %d, %f, %f, %f) (%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d)
Zg config %f, %f
[Zg] algorithm reset
Warning: fast accel timestamp is non-monotonic,%s,%llu,%s,%llu
Warning: DM sample timestamp is non-monotonic,%s,%llu,%s,%llu
{"msg%{public}.0s":"fAngAccelQueue empty", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
device parameters,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f
#Error,DEM,latitude_degs>90.0
#Error,DEM,latitude_degs<-90.0
#Error,DEM,heightDEM<-500
#Error,DEM,heightVariance<=0
#Warning,DEM,deltaT<0,DEM height filter internal_reset
#Warning,DEM,Height filter timed out,DEM height filter internal_reset
DEM,Height filter exceeded maximum change in horizontal position,DEM height filter internal_reset
DEM,isUseOfDemInappropriate,true,fIsAirborne,%{public}d
DEM,isUseOfDemInappropriate,true,TBA,currentTime,%{public}.1lf,TBA machContinuousTime,%{public}.1lf,isCloseToOrAtTunnelBridge,%{public}d,lat,%{private}.8lf,lon,%{private}.8lf
#Warning,DEM,latitude,%{private}.7lf,out of range
#Warning,DEM,current tile is not valid
#Warning,DEM,cellsize == 0
#Warning,DEM,latitude,%{private}.9lf,out of range
#Warning,DEM,latitude,%{private}.9lf,lessThanMin,%{private}.9lf
#Warning,DEM,latitude,%{private}.9lf,exceedsMax,%{private}.9lf
#Warning,DEM,longitude,%{private}.9lf,lessThanMin,%{private}.9lf
#Warning,DEM,longitude,%{private}.9lf,exceedsMax,%{private}.9lf
#Warning,DEM,longitude,%{private}.9lf,invalid,minLongitude,%{private}.9lf
#Warning,DEM,latitude,%{private}.9lf,invalid,minLatitude,%{private}.9lf
#Warning,DEM,longitude,%{private}.9lf,invalid,maxLongitude,%{private}.9lf
#Warning,DEM,latitude,%{private}.9lf,invalid,maxLatitude,%{private}.9lf
#Warning,DEM,invalidIndex,%{public}zu
#Warning,DEM,Reached unexpected case
#Warning,DEM,unexpected noData
DEM,populateSlope,fail,lat,%{private}.8lf,lon,%{private}.8lf,testLocationLatDegs,%{private}.8lf,testLocationLonDegs,%{private}.8lf
DEM,populateSlope,lat,%{private}.7lf,lon,%{private}.7lf,hunc,%.1lf,centerAltitude,%.1lf,daemonLocation.priv.groundAltitude,%.1lf
DEM,populateSlope,fail,lat,%{private}.6lf,lon,%{private}.6lf,testLatDegs,%{private}.6lf,testLonDegs,%{private}.6lf
DEM,fForceDownloadDEMTiles, %d
#Error,DEM,invalidInput,timestamp,%{public}.1lf,lat,%{private}.8lf,lon,%{private}.8lf
DEM,not on the current in-memory tile,lat,%{private}.7lf,lon,%{private}.7lf,minLat,%{private}.7lf,maxLat,%{private}.7lf,minLon,%{private}.7lf,maxLon,%{private}.7lf
DEM,tile not available
DEM,Need to load tile
DEM,tile download needed
DEM,skipping loadTile query,skipCount,%{public}d
DEM,Tile not loaded yet
DEM,input location undulation,und,%{private}.3lf,model,%{public}d
DEM,update undulation,undOld,%{private}.3lf,undNew,%{private}.3lf,altOld,%{private}.3lf,altNew,%{private}.3lf,
DEM,Alt(m),%{private}.2lf,AltUnc(m),%{public}.2lf,filterAlt(m),%{private}.2lf,filterAltVariance(m^2),%{public}.2lf,RawDemAlt(m),%{private}.2lf,undulation,%{public}.3lf,slope,%{private}.3lf,maxAbsSlope,%{public}.3lf,lat,%{private}.8lf,lon,%{private}.8lf,type,%d
DEM,Alt(m),%{private}.2lf,AltUnc(m),%{public}.2lf,RawDemAlt(m),%{private}.2lf,undulation,%{public}.3lf,slope,%{private}.3lf,maxAbsSlope,%{public}.3lf,lat,%{private}.8lf,lon,%{private}.8lf,type,%d
DEM,loadTile,lat,%{private}.7lf,lon,%{private}.7lf
DEM,loadTile,CLTilesManager,getTileFile,took,%{public}.1lf
#Warning,Unexpected, this tile should be on disk,%{public}s
#Error,DEM,indexCrcInBuffer,%zu,exceeds (bufferSize-4) bytes,%{public}zu
#Error,DEM,Invalid CLDEM tile file - header string
#Error,DEM,Invalid CLDEM tile file - version
#Warning,DEM,header.dataSizeBytes != header.nrows*header.ncols
#Error,DEM,Invalid CLDEM tile file - headerLength
DEM,header,vers,%d,headerLen,%d,noDataValue,%d,importance,%d,overlapInPixels,%d,dataElementType,%d,compressionType,%d,expirationAge,%d,timestamp,%.1f,uncertainty_m,%.1f,nrows,%d,ncols,%d,dataSizeBytes,%d,crc,%d,xllcorner,%f,yllcorner,%f,cellsize,%f,maxalt,%f,minalt,%f,medianalt,%f,scaleFactor,%f,meanUndulation,%f
#Error,DEM,Unable to load %{public}s,errno,%{public}d
#Error,DEM,fseek returned non-zero
#Error,DEM,Invalid CLDEM tile file - file size does not match headerLength+dataSizeBytes
#Error,DEM,tile is larger than the allowed maximum
#Error,DEM,CLCommonSetFileProtectionClass,fail
#Error,DEM,can't open,%s,errno,%d
#Error,DEM,can't stat,%s,errno,%d
#Error,DEM,mmap,MAP_FAILED,errno,%d
DEM,mmapDem,%s,size,%lld,regfile,%d,m,%p,size,%lu
#Error,mmap failed
#Warning,DEM,calculateCLDEM_CRC returned false unexpectedly
#Error,DEM,Invalid CLDEM,crc fail,calculated,%X,received,%X
DEM,Reading,%{public}s
DEM,avl download status,NONE
DEM,avl download status,STARTED
DEM,avl download status,COMPLETED
DEM,avl downloaded,%{public}s
#Warning,DEM,Cannot set protection class for DEM avl file,%{public}s
DEM,avl file decompressed,%{public}s,to,%{public}s
#Warning,DEM,Cannot set protection class for DEM decompressed avl file,%{public}s
DEM,is availability file valid,%{public}d
#Warning,DEM,avl download status,FAILED
#Warning,DEM,avl download request failed,%{public}s,retryMultiplier,%{public}d
#Warning,DEM,avl download status,%{public}d
DEM,requestDownload, Requesting DEM Tile download,lat,%{private}.7lf,lon,%{private}.7lf
DEM,allowing download request over cell due to poor GNSS signal conditions
DEM,allowing download request over cell due to activity,%d
#Warning,DEM,given avl update rate over WiFi is invalid,%{public}.1lf,using default value instead
DEM,DemAvlFileUpdatePeriodOverWifi,%{public}.1lf
#Warning,DEM,given avl update rate over Cell is invalid,%{public}.1lf,using default value instead
DEM,DemAvlFileUpdatePeriodOverCell,%{public}.1lf
DEM, server, %{public}s, overridden, 1
DEM, server, %{public}s, overridden, 0
DEM,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf
#Warning,DEM,could not setUpdateSource AVL file updater
#Warning,DEM,could not setUpdateRate AVl file updater
Notification,%{public}d
CL: CLDigitalElevationModel::onAvlFileUpdated
{"msg%{public}.0s":"CLDigitalElevationModel::onAvlFileUpdated", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLDigitalElevationModel::onManagerNotification
{"msg%{public}.0s":"CLDigitalElevationModel::onManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Registering for XPC Activity %s
Attempting to run %s but Microlocations are disabled.
{"msg%{public}.0s":"Activity runner: starting activty", "Activity":%{public, location:escape_only}s}
{"msg%{public}.0s":"Activity runner: activity finished", "State":%{public}u, "Time elapsed (ms)":%{public}u}
#Warning Activity runner: Activity didn't complete before the runner was destroyed. Most likely this means there was an exception during the activity. Please check the logs.
CLVehicleConnectionNotifier is being constructed
#fmc CarKit connection status, %{public}d
CLVehicleConnectionNotifier is shutting down
CarKitConnectionStatus,%d,HandsfreeConnectionStatus,%d,current VehicleConnectionStatus,%d
#fmc Posting notification upon vehicle exit
#fmc startTime,%f,endTime,%f,exitTime,%f
CarKitConnectionStatus,%d,HandsfreeConnectionStatus,%d,current VehicleConnectionStatus,%d,new VehicleConnectionStatus,%d
CL: CLVehicleConnectionNotifier::onBluetoothNotification
{"msg%{public}.0s":"CLVehicleConnectionNotifier::onBluetoothNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLVehicleConnectionNotifier::onMotionStateNotification
{"msg%{public}.0s":"CLVehicleConnectionNotifier::onMotionStateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Warning refAlt < %.1lf,refAlt,%.1lf,using the min
#Warning refAlt > %.1lf,refAlt,%.1lf,using the max
latitude,%.7lf,is out of bounds
#Warning, same coordinates input
#Notice Calibrations were successfully cleared.
Forcing a raw speed to kValue bins update.
Forcing a step cadence to stride length bins update.
Received CLDataProtectionManager_Type %d, data availability %d
Setting the current Motion Cals version to, %d
Unable to decode pedometer data: %{public}@
CL: CLMotionSyncStore::onDataProtectionNotification
{"msg%{public}.0s":"CLMotionSyncStore::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"#Awareness Received unexpected Routine notification", "triggerClass":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Awareness Active location request has timed out"}
{"msg%{public}.0s":"#Awareness shutting down provider", "self":"%{public}p"}
{"msg%{public}.0s":"#Awareness Attempting to set a non-positive latency budget", "budget":"%{public}f"}
{"msg%{public}.0s":"#Awareness failed to register", "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"#Awareness New registration", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Awareness failed to unregister", "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"#Awareness Removed registration", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Awareness Shutting down", "hasClients":%{public}hhd, "bigSwitch":%{public}hhd}
{"msg%{public}.0s":"#Awareness starting active location request and taking power assertion", "powerAssertion":"%{public}p"}
{"msg%{public}.0s":"#Awareness stopping active location request and releasing power assertion", "powerAssertion":"%{public}p"}
{"msg%{public}.0s":"#Awareness Disabling wakes"}
{"msg%{public}.0s":"#Awareness Wake time is in the past", "wakeTime_s":"%{public}.09f"}
{"msg%{public}.0s":"#Awareness Awakened"}
{"msg%{public}.0s":"#Awareness #warning Awakened with no clients"}
{"msg%{public}.0s":"#Awareness #warning Unexpected notification", "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"#Awareness #warning Received location without clients"}
{"msg%{public}.0s":"#Awareness Received location"}
{"msg%{public}.0s":"#Awareness Unexpected client manager notification", "notification":%{public}d}
{"msg%{public}.0s":"#Awareness New big switch state", "enabled":%{public}d}
{"msg%{public}.0s":"#Awareness Unexpected wifi notification", "notification":%{public}d}
{"msg%{public}.0s":"#Awareness Wifi power state changed", "powered":%{public}hhd}
{"msg%{public}.0s":"#Awareness Settled state changed", "isSettled":%{public}hhd}
CL: CLLocationAwarenessProvider::onWakeTimer
{"msg%{public}.0s":"CLLocationAwarenessProvider::onWakeTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationAwarenessProvider::onWifiNotification
{"msg%{public}.0s":"CLLocationAwarenessProvider::onWifiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationAwarenessProvider::onLocationNotification
{"msg%{public}.0s":"CLLocationAwarenessProvider::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationAwarenessProvider::onClientManagerNotification
{"msg%{public}.0s":"CLLocationAwarenessProvider::onClientManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLFitnessMachineNotifier::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLFitnessMachineNotifier::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLMapGeometryPtr
CLMM,%{public}.1lf,MapsAPICallCount,%{public}d
Overriding youth type for elevation credit, beginTime, %f, before, %{public}d, after, %{public}d
{"msg%{public}.0s":"CLPredictedWalkDistanceBoutRecorderDb: Un-initialized DB update finished handler.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLPredictedWalkDistanceBoutRecorderDb - DB, not accessible
Retrieved %lu records between %.0f and %.0f
CLPredictedWalkDistanceBoutRecorderDb - Failed to expire records.
CLPredictedWalkDistanceBoutRecorderDb: Device is locked and we are unable to open the database
Workout query, health data is not available.
HealthKit Workout query encountered error,%{public}@
Steadiness query failed, health data unavailable (%{private}f, %{private}f)
Missing Database  UUID
HealthKit Steadiness query failed due to device lock
HealthKit Steadiness query encountered error: %{public}@
Sample did not contain the source UUID metadata
Sample's source UUID %{private}@ did not match dBUUID %{private}@
[WalkingSteadiness] numSamples, %{public}lu, startDate, %{public}@, endDate, %{public}@
Falls query failed, health data unavailable (%{private}f, %{private}f)
HealthKit numFalls query failed due to device lock
HealthKit numFalls query encountered error: %{public}@
[NumFalls] sumQuantity, %{private}d, startDate, %{public}@, endDate, %{public}@
Steadiness Events query failed, health data unavailable (%{private}f, %{private}f)
HealthKit SteadinessEvent query failed due to device lock
HealthKit SteadinessEvent query encountered error: %{public}@
[SteadinessEvent] numSamples, %{public}lu, startDate, %{public}@, endDate, %{public}@
QuantityType %{public}@ query failed, health data unavailable (%{private}f, %{private}f)
HealthKit  %{public}@ query failed due to device lock
HealthKit %{public}@ query encountered error: %{public}@
[%{public}@] daysOfData, %{private}lu, startDate, %{private}@, endDate, %{private}@
Steadiness HealthKit inputs queried success, %{public}d
#WARNING: Testing mode. Querying HK samples from any device (%s)
Begin.
Too few points.  End.
temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,1
temperature,%f,bias.x,%f,bias.y,%f,bias.z,%f,deleted,0
End.
CLMM, m_fSkipRMSECheckForScalingEntryThresholds,%{public}d
CLMM, holdCourseEngaged,%d,fabsCourseDiffWithPriorSnap,%.1lf,rawCourseUnc,%.1lf,newCourseUnc, %.1f
%.1lf CLMM, high course rate,course,%.1lf,priorCourse,%.1lf,speed,%.1lf,fabsCourseRate,%.1lf
CLMM, course,%.1lf,courseUnc,%.1lf,lastSnapCourse,%.1lf,speed,%.1lf,acrossTrack,%.1f,onRoad,%d,widthUsed,%.1lf
CLMM, Detected course swing after a recent dismount,intervalSinceDismount,%.1lf
CLMM, holdCourse,engaged, large course diff when static,fabsCourseDiffWithPriorSnap,%.1lf
CLMM, holdCourse,engaged, large course diff at slow speed within one second,fabsCourseDiffWithPriorSnap,%.1lf
CLMM, holdCourse,engaged,%d,speed,%.1lf,distance,%.1lf
CLMM, holdCourse,using prior snap,course,%.1lf,courseUnc,%.1lf,fabsCourseDiff,%.1lf
CLMM, varFactorCheck,oldOffRoadCount,%d,newOffRoadCount,%d
CLMM, courseCheck,oldOffRoadCount,%d,newOffRoadCount,%d
CLMM, stopSnapping,timeout,dT,%.1lf,threshold1,%.1lf,threshold2,%.1lf,static,%d
CLMM, stopSnapping,distance > %.0lfm,Intersection,%d
CLMM, jumpDistanceCheck,oldOffRoadCount,%d,newOffRoadCount,%.0f
CLMM, stopSnapping,varFactor,%.1lf,threshold,%.1lf
CLMM, stopSnapping,offRoadCount,%d,threshold,%.0f
CLMM, stopSnapping,isAmbiguous,1,acrossTrack,%.1lf,acrossTrackThreshold,%.1lf
CLMM, reseting offRoadCount,%d
CLMM, startSnapping
#Warning CLMM, NULL road
failed to write VO2MaxInput entry, error %d
Failed to get VO2MaxInput entries for session, error %d
TileMgr, cell, Timer allocation failure, #CloneMe
CL: CLCellTilesManager::onClientNotification
{"msg%{public}.0s":"CLCellTilesManager::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCellTilesManager::onDataProtectionNotification
{"msg%{public}.0s":"CLCellTilesManager::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCellTilesManager::onCompanionNotification
{"msg%{public}.0s":"CLCellTilesManager::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCellTilesManager::onStatusNotification
{"msg%{public}.0s":"CLCellTilesManager::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLCellTilesManager::onLocationNotification
{"msg%{public}.0s":"CLCellTilesManager::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLMM, Constructor, fUseSpeedCheckForDOT,%{public}d,fMaxDistanceForTIntersectionForDOT,%{public}.1lf
CLMM, Unexpected out of bounds array access attempt
CLMM, Assessing candidates
CLMM, NULL road, bad candidate
CLMM, interpolateOnRoad returned false, determining mean road position
CLMM, Time,%.1lf,candidate,roadID,%llu,fwd,%d,countAroundMean,%d
CLMM, roadsAtIntersection returned false, searching for connected candidates
CLMM, unexpected incomingCount < 1
CLMM, Time,%.1lf,roadID,%llu,incoming,countAroundMean,%d
CLMM, Time,%.1lf,combinedBest,roadID,%llu,incomingCount,%d,outgoingCount,%d
CLMM, interpolateOnRoad returned false, determining outgoing road position
CLMM, Time,%.1lf,roadID,%llu,no particles after the intersection
CLMM, Time,%.1lf,roadID,%llu,isCombined,%d,isMulti,%d
#Warning CLMM, Position jump(m),%.1lf,dT(s),%.1lf
CLMM,%.1lf,predictionAndUpdate, distance,%.1lf,distBasedOnSpeed,%.1lf,distBasedOnPos,%.1lf
CLMM, dT2 limited,from,%.1lf,to,%.1lf
#Warning CLMM, unexpected,dT,%.1lf,minMoreThan,0,threshold1,%.1lf,threshold2,%.1lf
CLMM,%{public}.1lf,routeHint,add particle,lat,%{private}.8lf,lon,%{private}.8lf,course,%{public}.3lf,rseg,%{private}lld,fwd,%{public}d
CLMM, railway search, roadsWithinDistance returned false
CLMM, railwayParticle,timestamp,%.3lf,lat,%.8lf,lon,%.8lf,course,%.3lf,rseg,%lld
CLMM, prediction,NrParticles,%d,NrStandard,%d,NrNew,%d,NrPriorIntersectionParticles,%d,NrNewAlternateCandidateNoiseParticles,%d,NrNewFwdIntersectionParticles,%d,NrNewBiasedToPrior,%d,NrNewAmbiguous,%d,NrNewRouteParticles,%d
CLMM, moveOnRoad returned false, standard particles
CLMM, moveOnRoad returned false, prior intersection particles
CLMM, moveOnRoad returned false, fwd intersection particles
CLMM, moveOnRoad returned false, prior snap particles
CLMM, moveOnRoad returned false, alternate ambiguous particles
CLMM, Unexpected particle with snapLat == snapLon == 0
#Warning CLMM, totalScore<=0,%.1lf
CLMM, resample
CLMM, Unexpected number of particles after resampling,%d
CLMM, extractSolution
CLMM, Unexpected bestCount<=0
CLMM, Unexpected no best candidate found
CLMM, Unexpected. There should be an outgoing road
CLMM, Unexpected NULL outgoing road candidate
CLMM, Unexpected outgoing snapLat==snapLon==0
CLMM,Time,%.1lf,snapCourse,%.2lf,outgoingSnapCourse,%.2lf, crumbCourse,%.2lf, outgoingDistanceFromIntersection,%.2lf,outgoingCondition,%d,crumbCourseUnc,%.2lf,significantCourseChange,%d,isCourseAligned,%d, isMeanCandidateAlignedWithCourse,%d
CLMM, Time,%.1lf,exit distance check,distance,%.2lf,exitDistance,%.2lf
CLMM, Time,%.1lf,outgoing condition,%d
CLMM, %.1lf, Using outgoing,incomingID,%lld,outgoingID,%lld
CLMM, %.1lf, Using particle on outgoing,incomingID,%lld,outgoingID,%lld
CLMM, %.1lf, bestParticleRoadID,%lld
CLMM, ambiguous solution not detected,fabsCourseDiff,%.1lf,acrossTrack,%.1lf,ratio,%.3lf,alongTrackToAlt,%.1lf
CLMM, ambiguous solution detected,fabsCourseDiff,%.1lf,acrossTrack,%.1lf,ratio,%.3lf,alongTrackToAlt,%.1lf
%.1lf,CLMM, ambiguity reverted using route-hints
CLMM, ambiguous solution hysteresis
CLMM, dismounted recently,doNotSnapCourse,%d
CLMM, distToNextMulti,%.1lf, distFromPriorCrumb,%.1lf
CLMM, not snapping course,reason,distanceToIntersection,%.1lf
CLMM, not snapping course,reason,at intersection,fabsCourseDifference,%.1lf
CLMM, not snapping course,reason,turning,fabsCourseDifference,%.1lf
CLMM, %.1lf, snapping course, reason, gps course not reliable,%.1lf,fabsCourseDiffWithPriorSnap,%.1lf
CLMM, %.1lf, overwriting unreliable GPS course, static case, priorCourse,%.1lf, newCourse,%.1lf
CLMM, %.1lf, snapping course, reason, gps course flipping at low speeds,%.1lf,fabsCourseDiffWithPriorSnap,%.1lf
CLMM, %.1lf, overwriting unreliable GPS course, low speed case, priorCourse,%.1lf, newCourse,%.1lf
CLMM,%{public}.1lf,roadWithAdustment,number of particles are 0
CLMM,%{public}.1lf,roadWithAdustment,snap invalid or frc = 9
CLMM,%{public}.1lf,roadWithAdustment,road is nullptr
CLMM,%{public}.1lf,frc,%{public}d,oneway,%{public}d,roadWidth,%{public}.1lf,acrossTrack,%{public}.3lf
CLMM,%.1lf,roadWidthCorrection,acrossTrack,%.2lf,correction,%.2lf,halfRoadWidth,%.2lf
CLMM, performPartialMatching
CLMM, skipping partial match, as solution is inside tunnel
CLMM, partial snapping,poorVarFactorCount,%d,weightGPS,%.2lf,weightSnap,%.2lf
CLMM, roadsWithinDistance returned false
#Warning CLMM, Unexpected roadsWithinDistance returned empty list
CLMM, Unexpected NULL road
#Warning CLMM, Unexpected roadsWithinDistance returned only railways
CLMM, prepareSeeding
CLMM, Unexpected crumb lat==lon==0
CLMM, Unexpected crumb snapLat==snapLon==0
CLMM, Unexpected maxDistance,%{public}.1lf
CLMM, including railway
CLMM, assessMatchAndNeedForReseed
CLMM,postEvaluateMatch,%s
CLMM, Reseeding due to varFactor,%.1lf,max,%.1lf
CLMM, Reseeding due to badMatchCount,max,%d
CLMM, Reseeding due to Neff
CLMM, Reseeding due to stuck at dead-end while observations move away
CLMM, reseed
CLMM, Unexpected number of particles after resampling,%{public}d
CLMM,%.1lf,Unexpected,invalid geometry pointer, mapMatch
CLMM, %.1lf, not matching
CLMM, opportunistic tile download only, favorable GPS conditions
CLMM, opportunistic tile download only, high speed threshold
CLMM, match,%.1lf, allowsNetworkUsage, %d
#Warning CLMM, Time difference between updates is zero. Update ignored.
CLMM, %.1lf,hopping check,connecting roads,%d, current road %lld,prior road %lld
CLMM, %.1lf,hopping check,prior road, %lld, connected to the incoming road, %lld, of the current solution road, %lld
CLMM, %.1lf,hopping between roads detected,reset,%d,priorfullSnapCourse,%.1lf,currentFullSnapCourse,%.1lf,priorId,%llu,currentId,%llu
CLMM, holdCourse engaged but not snapping course
CLMM, no DOT, course is not aligned
CLMM, across track too large, not suitable DOT assistance
CLMM, along track too large, not suitable DOT assistance
CLMM,%.1lf,lat,%.8lf,lon,%.8lf,alt,%.2lf,course,%.1lf,snapLat,%.8lf,snapLon,%.8lf,snapCourse,%.1lf,horizontalError,%.2lf,hunc,%.2lf,ratio,%.2lf
CLMM, no DOT,feedback interval check
CLMM, no DOT,frc,0
CLMM, no DOT, too close to prior intersection
CLMM, no DOT, course not aligned to full snap
CLMM, no DOT, assessParallelRoadsWithinDist returned false, unexpected
CLMM, no DOT, too close to a road with similar course
CLMM, no DOT, too close to next intersection
CLMM, no DOT, too slow when nearing intersection
CLMM, no DOT, too close large road direction change
CLMM, no DOT, computeSnapCoordinatesFromRawGPSCoordinates lookBehind returned false
CLMM, no DOT, predicted point is too close to intersection
CLMM, Unexpected calculateNewPosUsingAcrossTrack fail
CLMM, no DOT, current particle within the stopDistanceFromIntersection
CLMM, moveOnRoad returned false, DOT particle assistance
CLMM, no DOT, computeSnapCoordinatesFromRawGPSCoordinates predicted returned false
CLMM, DOT,%.1lf,lat,%.7lf,lon,%.7lf,course,%.1lf,courseUnc,%.1lf,rw,%.1lf,startLat,%.7lf,startLon,%.7lf,length,%.1lf,speed,%.3lf,isOneWay,%d,isRailWay,%d,isTunnel,%d,isBridge,%d,distFromIntersection,%.1lf,isFreeway,%d,machContinuousTime,%.3lf,lookBehindDistance,%.2lf,type,%d
CLMM, MMPA,%.1lf,lat,%.7lf,lon,%.7lf,a,%.2lf,b,%.2lf,az,%.3lf,course,%.3lf
CLMM, TBA, Invalid time
CLMM, TBA, NULL Island
CLMM, TBA,roadsWithinDistance returns query failed,lat,%{private}.8lf,lon,%{private}.8lf,searchRadius,%{public}.1lf
CLMM, TBA,lat,%{private}.8lf,lon,%{private}.8lf,unc,%{public}.8lf,searchRadius,%{public}.1lf,isCloseToTunnel,%{public}d,isCloseToBridge,%{public}d,isTunnel,%{public}d,isBridge,%{public}d
CLMM,Unexpected,invalid geometry pointer, generateRouteHint
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,failed as not enough route roads are available
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,route index,%d,is more than number of route roads,%{public}ld
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,routeCourse,%{public}.1lf,is very different than crumb course,%{public}.1lf,rejection,%d
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,routeCourse,%{public}.1lf,is different than crumb course,%{public}.1lf, and rejections are high,rejection,%d
CLMM,%{public}.1lf,routeHints,skipping,moveOnRouteRoads meas,routeCourse,%{public}.1lf,is somewhat different than crumb course,%{public}.1lf
CLMM,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,course deweighted,unc,%.2lf
CLMM,%{public}.1lf,routeHints,meas,moveOnRouteRoads,ll,%{private}.7lf,%{private}.7lf,course,%{public}.3lf,hunc,%{public}.3lf,cunc,%{public}.3lf,count,%{public}lu
CLMMPED,%{public}.1lf,routeHints, no meas, projection,routeCourse,%{public}.1lf,is very different than crumb course,%{public}.1lf,rejection,%d
CLMM,%{public}.1lf,routeHints,duplicate measurement check,measurementGood,%{public}d,vector,%{public}lu
CLMM,%{public}.1lf,routeHints,used route-hint
Unexpected failure attempting to save VO2MaxCloudKitSyncEngineMetadata record
CLActivityLogger managed should enable data collection setting is %{public}d.
#Warning CLActivityLogger Failed to get data collections enabled setting. It may not have been set yet.
CLActivityLogger exporting is disabled MotionMetricsExportInterval, %d, MotionMetricsExportTimerInterval, %d
CLActivityLogger should enable data collection is %{public}d.
CLActivityLogger exporting %s is disabled 
CLActivityLogger exporting %s is already enabled 
CLActivityLogger exporting %s: MotionMetricsExportTimerInterval = %d, MotionMetricsExportInterval = %d
CLActivityLogger exporting %s is %f, currentTime is %f, next dumping time is %f, %s
CLActivityLogger exporting %s metrics with OSAWriteLogForSubmission
#Warning CLActivityLogger failed to submit iOS data analysis with type kOSAProblemTypeMotionState
CLActivityLogger exporting timer enabled 
CLActivityLogger read %s as CFStringRef failed
CLMM, ForceNetworkUsage %{public}d
CLMM, DisallowNetworkUsage %{public}d
CLMM,%.1lf,signalEnvironment,%{public}d,name,%{public}s,fidelity,%{public}d
CLMM,%.3lf,applyChinaShift() returned false
CLMM,%.3lf,null pointers for matcher and geometry
CLMM,%.3lf,match() returned false
CLMM,%.3lf,matchRouteHints() returned false
CLMM,%.3lf,Using solution with route hints
{"msg%{public}.0s":"MapMatching Geometry,Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"MapMatching Matcher,Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"MapMatching Matcher Route hints,Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLMM, UseFullSnap, %{public}d
CLMM, enableDotGpsFeedback,%{public}d
CLMM, EnablePedestrianMapMatching,%{public}d
{"msg%{public}.0s":"Pedestrian MapMatching Geometry,Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Pedestrian MapMatching Matcher,Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLMMPED, PedestrianDirectionOfTravel,%d
CLMMPED,Overwrite,EnablePedestrianDirectionOfTravel,%{public}d
CLMMPED,Overwrite,EnableActivityBasedPedestrianDirectionOfTravel,%{public}d
CLMM, EnableCyclingMapMatching,%{public}d
{"msg%{public}.0s":"Cycling MapMatching Geometry,Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Cycling MapMatching Matcher,Assertion failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLMMPED, CyclingDirectionOfTravel,%d
CLMMPED,Overwrite,EnableCyclingDirectionOfTravel,%{public}d
CLMMPED,Overwrite,EnableActivityBasedCyclingDirectionOfTravel,%{public}d
CLMM, IntegrateRouteHintsInMapMatcher,%{public}d
CLMM, ForceActivity,Activity,%{public}d
CLMM,Country,%s,supportsTBTFeature,%d
CLMM,match,nav,%{public}d,forceActivity,%{public}d
CLMM,%.3lf,Unable to fill crumb,no matching
CLMM,%.3lf,Unknown dynamics,no matching,activity,%{public}d,fitness,%{public}d
CLMM,%.3lf,null pointers for pedestrian matcher
CLMM,%.3lf,null pointers for cycling matcher
CLMM,%.3lf,vehicle dynamics,wifi2 fix ignored
CLMM,%.3lf,null pointers for matcher or geometry
CLMM,%.3lf,MMFilter,latency,%.3lf,triggeredByRouteHints,%d,mmtype,%d
CLMM,%{public}.3lf,Match,latency,%{public}.3lf,mmType,%{public}d,usable,%{public}d,amb,%{public}d
CLMM,wantDot,%d,forceDot,%d,isPedestrian,%d,isVehicle,%d,isEureka,%d,isFire,%d,type,%d,isCycling,%d
CLMM,TBA,setTunnelBridgeAssistance,lat,%{private}.8lf,lon,%{private}.8lf,isCloseToTunnel,%{public}d,isCloseToBridge,%{public}d,isTunnel,%{public}d,isBridge,%{public}d
CLMM,FullSnapEnabled,%{public}d
CLMM,ForceNetworkUsage,%{public}d
CLMM,DisallowNetworkUsage,%{public}d
@WsbReproc, remain, groups, %{public}lu, unknownAPs, %{public}lu, pass, %{public}d
{"msg%{public}.0s":"mismatch of mac addresses", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
WsbAls, unknown, groups, %{public}ld, tags, %{public}d, %{public}d
{"msg%{public}.0s":"size of batched locations and scan buffer groups must be equal", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
WsbTimer, set, %{public}d, unknown, %{public}ld, wasempty, %{public}d, delay, %{public}d
@WifiFlow, scanreq inconsistent, pre, %{private}d, post, %{private}d
@WifiFlow, scanreq, suppressed, %{public}d
@EmerTick, scanrequest, %{public}.1f
@EmerFlow, ScanRequest, type, %{public}s, tte, %{public}.1f
@WsbDiscard, unknown, %{public}.1f, aps, %{public}ld
@WsbDiscard, alsmax, %{public}.1f, aps, %{public}ld
WsbMetric, groupresult, unknownaps, %{public}d
WsbMetric, groupresult, alsmax, %{public}d
@WsbReproc, update, groups, %{public}lu, unknownAPs, %{public}lu, deleteTo, %{public}0.1f
@EmerCheck, top, %{public}d
@EmerCheck, current, %{public}d
@EmerFlow, ScanRequest5GHzWithAlsReply, waiting for 5GHz scan result
@EmerWarn, ScanReply5GHzWithPendingAls, abort waiting for the preliminary ALS response
@EmerCheck, confidence, %{public}d, above threshold
@EmerTick, scanrequest5ghzwithals, %{public}.1f
@EmerFlow, ScanRequest5GHzWithPendingAls, queryType, %{public}d, tte, %{public}.1f
@EmerCheck, support 5GHz, %{public}d
@EmerFlow, Done, alsreply
@EmerWarn, unexpected state, processScanResult, %{public}d, #CloneMe
@EmerTick, anyfix, %{public}.1f
@EmerCheck, switched, %{public}d, aps, %{public}d
@EmerTick, sufficientfix, %{public}.1f
@EmerFlow, Done, conditions
@EmerCheck, returned, %{public}d
#post-wifi-position-calculation-state-update, location update not in progress, will not issue scan
@EmerFlow, ScanRequest5GHzWithPendingAls, type, %{public}s, tte, %{public}.1f
#post-wifi-position-calculation-state-update, #emergency location update in progress, skipping state transition logic
#post-wifi-position-calculation-state-update, previous decision made to skip using wifi scan, skipping state transition logic
#post-wifi-position-calculation-state-update, stop criteria has been satisfied
{"msg%{public}.0s":"#post-wifi-position-calculation-state-update, dont issue a scan"}
{"msg%{public}.0s":"#post-wifi-position-calculation-state-update, stop after fast scan"}
{"msg%{public}.0s":"#post-wifi-position-calculation-state-update, failed to achieve an accurate wifi location", "number_of_requested_scans":%{public}d}
@EmerTick, alsreq, %{public}.1f
@EmerFlow, AlsRequest, queryType, %{public}d, tte, %{public}.1f
{"msg%{public}.0s":"#post-wifi-position-calculation-state-update, valid computed location, but no post location calculation state update", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Starting PAL update timer
{"msg%{public}.0s":"PAL,", "error,":%{public, location:escape_only}@}
PAL, No step count / workouts from first party sources.
PAL,Containers out-of-sync,aborting
PAL,Daily steps,%f,Session type,%lu,startTime,%f,duration,%f,mean mets,%f,in-system steps,%f,met-converted steps,%f
PAL,Day index,%zu,stepCount,%f
{"msg%{public}.0s":"PAL,", "estimated":%{private}d, "current":%{private}d, "total steps":%{private}d, "valid days":%{private}d, "avg steps":%{private}d, "timeToEstimate":"%{private}.3f"}
no app proxy available for %{public}s
App foregrounded for %.2fs.  Post %s (%d), pid, %d, bundleId, %s
cannot find SBApplicationStateKey
unknown application state %{public}d
failed to retrieve pid
failed to retrieve bundle ID
Post Application State Change Notification, %d, %s, pid, %d, bundleId, %s
cannot find bundle ID for %{public}d
#Warning no app type available for %s
{"msg%{public}.0s":"Attempted to locate companion placeholder bundle on a non-watch device", "bundleId":%{public, location:escape_only}s}
Either not a watch platform or bundleId is empty
{"msg%{public}.0s":"stand alone watch app", "bundleId":%{public, location:escape_only}s, "status":%{public}hhd}
{"msg%{public}.0s":"#warning CLAppMonitor bundlePath from bundleId is nil", "BundleId":%{public, location:escape_only}@}
{"msg%{public}.0s":"DefaultAccuracyReduced key from Info.plist", "For Bundle":%{public, location:escape_only}@, "Value":%{public}hhd}
{"msg%{public}.0s":"No Info.plist InterestZones", "For Bundle":%{public, location:escape_only}@}
{"msg%{public}.0s":"Info.plist InterestZones not of type Dictionary", "Bundle":%{public, location:escape_only}@}
{"msg%{public}.0s":"Info.plist InterestZones", "For Bundle":%{public, location:escape_only}@, "InfoPlistZones":%{public, location:escape_only}@}
CL: CLAppMonitor::onApplicationStateChanged
{"msg%{public}.0s":"CLAppMonitor::onApplicationStateChanged", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAppMonitor::onApplicationRegistered
{"msg%{public}.0s":"CLAppMonitor::onApplicationRegistered", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAppMonitor::onApplicationUnregistered
{"msg%{public}.0s":"CLAppMonitor::onApplicationUnregistered", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Unable to log impact due to cancel reason not containing kImpactStart 0x%llu
Could not find impact at time %llu, unable to set impact features
Could not find impact at time %llu, unable to set user response
Could not find impact at time %llu, unable to set fall distance
Rescheduling impact reporting in %.2lf seconds
Start active dynamic Wsb
Stop active dynamic Wsb
Received kNotificationPower, isWifiPowered, %d
Received kNotificationScanCache
Unknown notification received, %{public}d
CL: CLTransitWsbClient::onWifiNotification
{"msg%{public}.0s":"CLTransitWsbClient::onWifiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CMStrideCalRecorderDb init
StrideCalHistory table doesn't even exist
StrideCalDb (%f,%d,%f,%f,%f,%f,%f,%d,%d,%f,%f,%d).
MotionStateObserver, Started session, startTime, %.3f, user type, %s, predicted type, %s, hk activity type, %i
MotionStateObserver, Stopped session, startTime, %.3f, user type, %s, predicted type, %s, hk activity type, %i
MotionStateObserver, Sending Down ActivityOverride,%ld,startTime,%.3f,activityType,%d,vehicularConfidence,%d
CL: CLMotionStateObserver::onCompanionNotification
{"msg%{public}.0s":"CLMotionStateObserver::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateObserver::onFitnessTrackingNotification
{"msg%{public}.0s":"CLMotionStateObserver::onFitnessTrackingNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLMotionStateObserver::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLMotionStateObserver::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
remaining header in db, deleting, x, %{private}d, y, %{private}d
runtime error deleting tiles
no sqlite connection error, %{private}s
tile parsing complete, successful, %d
deleting tile, x, %{private}d, y, %{private}d, header, %d, tile, %d
{"msg%{public}.0s":"This callback should only be invoked once", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
failed to delete previous tile before inserting new one
failed to save tile header
Period Estimate Update,period,%f,confidence,%f,timestamp,%f,startTime,%f
ClassificationResult,%d,startTime,%f,timestamp,%f
Swimming device orientation set,wrist,%d,crown,%d
Classification,%s,%d,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f,%s,%f
CLAccessoryAWD,%{public}.1lf,DeviceLocationData,type,%{public}d,ll,%{private}.7lf,%{private}.7lf,alt,%{public}.2lf,speed,%{public}.2lf,course,%{public}.2lf,hUnc,%{public}.2lf,vUnc,%{public}.2lf,speedUnc,%{public}.2lf,courseUnc,%{public}.2lf,mct,%{public}.1lf
CLAccessoryAWD,%{public}.1lf,locationSession,start,%{public}.1lf,end,%{public}.1lf,duration,%{public}d,sessions,%{public}d
CLAccessoryAWD,%{public}.1lf,locationSession,start,%{public}.1lf,sessions,%{public}d
CLAccessoryAWD,%{public}.1lf,updateNavigationAppStats,%{public}s,more than allowed location apps open,%{public}d
#Warning,CLAccessoryAWD,%{public}.1lf,updateNavigationAppStats,%{public}s,appStartTime,%{public}.1lf, greater than machContTime,%{public}.1lf
CLAccessoryAWD,%{public}.1lf,updateNavigationAppStats,%{public}s,appLaunchTime,%{public}.1lf,appStartTime,%{public}.1lf,appRunTime,%{public}d
{"msg%{public}.0s":"failed to invalidate before dealloc", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"failed to get assertion", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Completed async acquire of status bar assertion for %{public}s (PID:%{public}d)
Failed async acquire of status bar assertion for %{public}s (PID:%{public}d)
{"msg%{public}.0s":"attempted to double submit metric", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Failed to create super sticky assertion", "bundleId":%{public, location:escape_only}s}
{"msg%{public}.0s":"bundleId argument is required", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Could not start CSLSSession for client", "bundleId":%{public, location:escape_only}s, "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"Could not stop CSLSSession for client", "bundleId":%{public, location:escape_only}s, "error":%{private, location:escape_only}@}
PAUSE: Override AutoPause to On for all clients
PAUSE: Override AutoPause to On for all clients linked with SDK that predates 6.0
PAUSE: Override AutoPause to Off for all clients
PAUSE: Override AutoPause to None
PAUSE: AutoPause log UI Enabled
PAUSE: activity type defaulted to %d
Proactive compass is %{public}s.
Overriding ProactiveCompassStartDelay,%{public}.2f.
Background indicator enabled for %s is now %d (was %d)
BATCH: client, '%s', batchEnabled, %d
client '%s' subscribing to location desiredAccuracy %.2f distanceFilter %.2f dynamicAccuracyReductionEnabled %d allowsAlteredAccessoryLocations %d
client '%{public}s' unsubscribing from location
@ClxClient, unsubscribe, %{public}s
ending metric session (LocationUpdateSession) for %s
Client '%s' changed activity type from %d to %d
Couldn't get value for key %{public}s
Client %s is setting AutoPause to %d
Client %s is setting ContinuousBackgroundLocationRequested to %d
Client %s is setting ContinuousBackgroundLocationIndicatorForAlwaysEnabled to %d
BATCH: startBatching called but we're already batching
BATCH: starting client %s
BATCH: scheduling odometer alarm for %.1f
BATCH: Odometer errored (%{public}s) for client (%{public}s)
BATCH: Odometer criterion met, waiting for location event to notify client %s
BATCH: Odometer fired (%.1f,%s) but no longer relevant to us
BATCH: scheduling timer for %.1f
BATCH: stopBatching called but we're not batching
BATCH: stopping client %s
BATCH: client %s disallowed Batch
BATCH: How were we batching if this wasn't supported?
BATCH: request (%.1fm, %.1fs) will be based on %.1fm (%.1fs), %.1fs for client %s
BATCH: How were we not updating location?
BATCH: How were we batching accuracy was too low?
BATCH: How were we batching if a distance filter was on?
BATCH: distance or timeout was <= 0 (techincally exit criteria has already been satisfied.)
#Notice Location uncertainty too high to allow deferred updates now
#Warning BATCH: odometer is not running, we have no way to know what distance is relative to
BATCH: scheduled batch exit but not off-boarding
%s with CorrectiveCompensation enabled attempting allowsMapCorrection.
CLMM,Client,'%s',pid,%u,allowsMapCorrection,%d,desiredAccuracy,%lf,kNotificationMapMatching,%d
PAUSE: AutoPause is overridden to off, reject %s message to client '%s'
locationd paused updates to '%s' at %.2f. client autopause setting: %d, override setting: %d
PAUSE: Sending %s message to client '%s'
BATCH: Not batching but tried to finish with error %{public}d
BATCH: Sending didFinishDeferredUpdatesWithError:%d message to client '%s'
{"msg%{public}.0s":"Can't swap status bar assertions when both sides have values", "newValue":%{public}hhd, "oldValue":%{public}hhd, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"initializing process assertion to support background location for client", "pid":%{public}u, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"Couldn't initialize process assertion for client", "pid":%{public}u, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"Client is performing batch location, allowing idle sleep.", "pid":%{public}u, "client":%{public, location:escape_only}s}
#Warning Client,%s, pid,%u, is performing batch without location.
{"msg%{public}.0s":"Client is not performing batch location, preventing task suspend.", "pid":%{public}u, "client":%{public, location:escape_only}s}
Client,%s, pid,%u, is performing batch location, allowing idle sleep.
Client,%s, pid,%u, is not performing batch location, preventing task suspend.
{"msg%{public}.0s":"release process assertion", "fProcessAssertionReason":%{public, location:CLClientProcessAssertionReasons}lld, "backgroundLocationDesired":%{public}hhd}
{"msg%{public}.0s":"Releasing process assertion", "pid":%{public}u, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#visibility Only bundle-id identified clients can become super sticky"}
{"msg%{public}.0s":"swapVisibilityAssertion should return nil, here", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#visibility Completing async release of visibility assertion for %{public}s (PID:%{public}d, ptr:%p)
#visibility For %s (PID:%d)  Background:%s  Started:%s  > Needed:%s  Eligible:%s  Action:%s
%s with CorrectiveCompensation enabled attempting setActivityType
{"msg%{public}.0s":"client not currently authorized for location; sending error", "client":%{public, location:escape_only}s}
client '%{public}s' not authorized for location; not starting yet
{"msg%{public}.0s":"#warning failed to release fNotYetAuthorizedTimer after client was re-authorized", "client":%{public, location:escape_only}s}
Client '%{public}s' paused, not starting location
client '%{public}s' authorized for location; starting shortly
client '%{public}s' authorized for location; starting now, desiredAccuracy, %{public}.1lf, distanceFilter, %{public}.1lf, operatingMode %{public}d, dynamicAccuracyReductionEnabled %{public}d, allowsAlteredAccessoryLocations %{public}d, activityType %{public}d
@ClxClient, register, %{public}s, accuracy, %{public}.1lf
Not registering for location updates for %{public}s; the planets don't align
Not registering for location updates for %{public}s; desiredAccuracy is too high
BATCH: stop because accuracy changed %s
register for notification, %d, %s, desiredAccuracy, %.1f
BATCH: stop because distance filtered %s
starting metric session (LocationUpdateSession) for %s
received location system state of LocationUpdateSession for %s
BATCH: stop because stopping location for %s
{"msg%{public}.0s":"canBePaused()", "client":%{public, location:escape_only}s, "pid":%{public}d, "flag":%{public}hhd}
Client %s registered for autopause notifications
'%{public}s' failed to become client of CLAutopauseProvider
PAUSE: Client '%s' unregistered for autopause notifications
#Warning PAUSE: Unregistering for autopause notification when client '%s' does not exist
PAUSE: '%s' not a location client (%d), or not authorized (%d).
PAUSE: '%s' overridden to off.
PAUSE: '%s' not allowed to pause.
PAUSE: '%s' not backgrounded right now (%.1f).
PAUSE: now clock %f timestamp %f thresh %f.
PAUSE: client: '%s' type: %d states: veh %d fit %d oth %d
PAUSE: '%s' not changing state wasPaused: %d lastState: %d now clock: %f timestamp: %f thresh: %f.
PAUSE: %s (%p) changed from %d to %d
PAUSE: Pausing client '%s'
PAUSE: Resuming client '%{public}s' (This should be handled on framework side)
{"msg%{public}.0s":"Sending location to client", "client":%{public, location:escape_only}s, "location":%{private, location:CLClientLocation}.*P}
{"msg%{public}.0s":"#awd #thumper Caching location ", "lat":"%{private}.08f", "lon":"%{private}.08f", "alt":"%{private}f", "accuracy":"%{private}f"}
CoarseMetaData found in nvp. Encoded data size : %lu
BATCH: successfully ended for %s
The location type is undefined (%d).
BATCH: location unavailable caused batch failure
Wiring bug: %{public}d should not notify
PAUSE: %s received pause notification %d
BATCH: Time criterion met, waiting for location event to notify client %s
Compass calibration achieved (L%{public}d) for client '%{public}s'
Scheduling proactive compass start for client '%{public}s' with delay %{public}.2f
Starting compass proactively for client '%{public}s'
Proactive compass timer fired
Stopped proactive compass timer for client '%{public}s'
Stopped proactive compass for client '%{public}s'
CL: CLLocationSubscription::onLocationNotification
{"msg%{public}.0s":"CLLocationSubscription::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationSubscription::onBatchTimer
{"msg%{public}.0s":"CLLocationSubscription::onBatchTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationSubscription::onPauseNotification
{"msg%{public}.0s":"CLLocationSubscription::onPauseNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLLocationSubscription::onProactiveCompass
{"msg%{public}.0s":"CLLocationSubscription::onProactiveCompass", "event":%{public, location:escape_only}s, "this":"%{public}p"}
SwimStop is unable to get tier2 data!,the last swim time is %{public}f
SwimStop is unable to get activity data!,the last swim time is %{public}f
SwimStop is unable to get turn data!,the last swim time is %{public}f
SwimStop,startTime,%f,tier2Time,%f,epochCount,%d,epochTier2,%ld,bufferCnt,%d,bufferedPed,%d,bufferedSwim,%d,count,%d,style,%d,lastTime,%f,angle,%f,vectorMag,%f,yaw,%f,sinceTurn,%d
CLCellTilesManager is not supported in diagnostics mode
TILE: fMaxTileSecurityAge, %.1lf
TILE: fEncryptionGracePeriod, %.1lf
TileCell, isActive, %{public}d
TILE: defaultCellTilesServerUrl, %{private}s, overridden, %{public}d
TILE: CLCellTilesManager::shutdown
TileCell, unexpected, dataprotection, %{public}d
TileCell, kNotificationEncryptedDataAvailability, %d, changed, %d
TileCell, unexpected, location, %{public}d, %{public}s
TileCell, kNotificationLocationLeech, fLastLocationDownloadCheckTimestamp, %{public}.1lf, isForceLocationCheck, %{public}d, fLastLocationProtectionCheckTimestamp, %{public}.1f, leech location, %{private}s
TileCell, unexpected, status, %{public}d
TileCell, kNotificationReachability, %{public}d, was, %{public}d
TileCell, kNotificationReset
TileCell, kNotificationLocationServicesStatus, %{public}d
TileCell, #CacheDelete kNotificationSoftwareUpdateStorageRecovery
TileCell, unexpected, companion, %{public}d
TileCell, Timer, %{public}d, locked, %{public}d
TileCell, Cleanup
TileCell, listAvailableFilesAllTypes, indexed, %{public}d
TileCell, clear on index
TileCell, listAvailableFilesAllTypes, done
TileCell, indexTiles, rootDirectory, %{public}s, name, %{public}s
TileCell, indexTiles, can't open dir, %{public}s, #CloneMe
TileCell, indexTiles, absoluteFilename, '%{public}s', d_type, %{public}d
TileCell, indexTiles, invalid filename  %{public}s
TileCell, convert to class B, first unlock, %{public}s, files, %{public}d
TileCell, indexTiles, failed to stat file, %{public}s, ret, %{public}d, #CloneMe
TileCell, indexTiles, done, %{public}s, size, %{public}lu, unprotected, %{public}lu
TileDl, ignore before first unlock, fDataProtectionEnabled, %{public}d
@TileDl, requestDownload, type, %{public}d, %{private}s, not active
TileDl, requestDownload, type, %{public}d, %{public}s, location, %{private}14.8lf, %{private}14.8lf, id, %{private}s, reachbility, %{public}d
@TileSched, cell, set, %{public}d
@TileDl, cell, failed criteria
@TileDl, kNotificationTileWasDownloaded, tileid, %{private}s, tileHeaderParsed, %{public}d, tileType, %{public}d, serverUrl, %{private}s, serverFilename, %{private}s, absoluteLocalFilename, %{private}s, size, %{public}d, current, %{public}d
TILE: no cell tiles for, %s
CellTile, getLocationByCell, un-supported cell type, %{private}s, #CloneMe
TILE: getLocationByCell, tiles, %d, are not active on this device
TILE: getLocationByCell, isInKnownCache, %d, isInUnKnownCache, %d
TILE: getLocationByCell, using locationHint, %s
TILE: getLocationByCell, out of boundary, %s
TILE: getLocationByCell, search neighbor, step, %2d, y, %+2d, x, %+2d
TILE: getLocationByCell, search remaining tiles, %s
TileCell, %{public}s
{"msg%{public}.0s":"CLCellTilesManager::removeAllTiles", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "type":%{private}d}
TileCell, %{public}s, removeAllTiles, size, %{public}lu
TILE: removeAllTiles, end, name, %s, size, %lu, unprot size, %lu
TileCell, deleteAgedTiles, dispatch, %{public}s
TileCell, deleteAgedTiles, start, name, %{public}s, size, %{public}lu
{"msg%{public}.0s":"CLCellTilesManager::agedTileDeleter", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "now_s":"%{public}.09f"}
TileCell, deleteAgedTiles, end, numOfDeletedTiles, %{public}u, remain, %{public}lu, name, %{private}s
TILE: updateProtectionClass, start, %s, reason, %s, isAboutToLock, %d, locationAge, %.1lf, doLocCheck, %d, sizes, %lu, %lu, knownLocation, %s
CellTile, updateProtectionClass, failed unlocking tileid, %{private}s, size, %{public}lu, #CloneMe
CellTile, tile ptr is NULL, #CloneMe
CellTile, updateProtectionClass, unable to lock tile, locking tileid, %{private}s, #CloneMe
CellTile, %{public}s, locking, %{public}d, lock, %{public}d, unlock, %{public}d, size, %{public}lu
CellTile, Unable to lock all unprotected files!, #CloneMe
@TileList, %{public}s, unprotect, llsw, %{private}.2lf, %{private}.2lf, %{public}s, size, %{public}lu
TileTimer, skip, location, %{public}d
TileTimer, schedule, reason, %s, locationAge, %.1lf, secondsFromNow, %.1lf, lastKnownLocation, %s
TileTimer, cancel
CellTile, Invalid tile id!, #CloneMe
@TileSched, cell, called, %{public}ld
CL: CLCellTilesManager::onTimerFired
{"msg%{public}.0s":"CLCellTilesManager::onTimerFired", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CACHE: name, %s, clear, size, %lu
CACHE: name, %s, deleteAgedEntries, size, %lu
CACHE: name, %s, evict, aged, age, %.1lf, size, %lu, %lu, key, %s
CACHE: name, %s, evict, size, age, %.1lf, size, %lu, %lu, key, %s
CACHE: name, %s, getEntry, end, size, %lu, %s, entry, %s
CACHE: name, %s, bad set iterator - recovering, size, %lu, %s
CACHE: name, %s, cache too large, evicting, size, %lu
CACHE: name, %s, addEntry, end, size, %lu, %s, entry, %s
PAUSE: Constructing CLAutopauseProviderConcrete
PAUSE: Starting auto-pause monitoring.
PAUSE: Stopping auto-pause monitoring.
PAUSE: Batched notification response in auto-pause with %zu locations.
PAUSE: Pause state changed, notifying - fitness: %d navigation: %d other: %d
#Warning PAUSE: unexpected notification %d
#Warning PAUSE: Unknown notification %d
PAUSE: Autopause provider has no location updates for 15 minutes.
PAUSE: got kNotificationSleep.
PAUSE: got kNotificationWake.
CL: CLAutopauseProviderConcrete::onLocationNotification
{"msg%{public}.0s":"CLAutopauseProviderConcrete::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAutopauseProviderConcrete::onMotionNotification
{"msg%{public}.0s":"CLAutopauseProviderConcrete::onMotionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLAutopauseProviderConcrete::onStatusNotification
{"msg%{public}.0s":"CLAutopauseProviderConcrete::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
bufferLength(%{public}d)!=kSize(%{public}d)
#Warning,SpeedFilter,%{public}.1lf,unexpected,vehicleSpeed < 0
EnableLocationServices,Success,AllChecksPassed
EnableLocationServices,Fail,PedometerCalibrationLocationServicesDisabled
EnableLocationServices,Success
StrideCal - Register tracks activity %d, override action, %d, session, %@
@TileDl, isCurrent, %{public}d, inside, %{public}d, %{public}d, locknown, %{public}d, %{public}d, %{public}d, %{public}d, tile, %{private}s, delta, %{public}.02f
@TileList, %{public}s, duplicate, llsw, %{private}.2lf, %{private}.2lf, %{public}s, size, %{public}lu
{"msg%{public}.0s":"Attempting to assert invalid tile type.", "tileType":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
TileMgr, failed to allocate a tile for type, %{public}d, #CloneMe
No viable conversion for mode %{public}#x
No viable conversion for notification %{public}#x
CLDeviceMotion::addDeviceMotionDispatcher adding dispatcher with property: %{public}s
CLDeviceMotion::removeDeviceMotionDispatcher removing dispatcher with property: %{public}s
CLDeviceMotion::minimumUpdateIntervalChanged,notification,%{public}d,minimumUpdateInterval,%{public}f
minimumUpdateInterval GyroOnly:%{public}f, 3AxisDynamicGyro:%{public}f, 6Axis:%{public}f, 6AxisThrottledGyro:%{public}f, 9Axis:%{public}f, 9AxisWithNorthReference:%{public}f, 9AxisWithTrueNorthReference:%{public}f, BuildGYTT:%{public}f
CLDeviceMotion::numberOfClientsChanged notification:%{public}d, from:%{public}zu, to:%{public}zu
numberOfClients GyroOnly:%{public}zd, 3AxisDynamicGyro:%{public}zd, 6Axis:%{public}zd, 6AxisThrottledGyro:%{public}zd, 9Axis:%{public}zd, 9AxisWithNorthReference:%{public}zd, 9AxisWithTrueNorthReference:%{public}zd, BuildGYTT:%{public}zd
{"msg%{public}.0s":"9Axis should be running", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Device motion mode (%{public}d) not supported, can't process client change
Unsupported mode (%{public}d). Returning.
Unsupported mode (%{public}d). Compass not found. Returning.
Unsupported mode (%{public}d). Couldn't do DeviceMotion without Gyro. Returning.
Starting device motion, mode=%{public}#x,useAccelerometer=%{public}d,useGyro=%{public}d,useCompass=%{public}d,fUseNorthRef=%{public}d,buildingGYTT=%{public}d
Stopping device motion, mode=%{public}#x
Device motion mode (%{public}d) not supported, unable to disable sensor fusion
Registering for geomagnetic model updates
Unregistering for geomagnetic model updates
Received geomagnetic model, declination,%f,timestamp,%f
{"msg%{public}.0s":"Device motion service 6 is not supported on this platform!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Device motion service is not supported on this platform!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Workout, Duplicate START, %@, %s, %p
Forcing workout from workoutType: %zd, locationType: %zd, to workoutType: %zd, locationType: %zd
Passed an invalid HKWorkoutActivityType of %lu
Workout, STARTING, %@, %s, %p
Unable to start workout, another client has an active workout.
No active workouts to stop, requested, %@, %p, %p
Workout, STOPPING, %@, %p, %p
Workout, event subscription changed, %d, %s, %p
No active workouts to set a timeout for!
Workout, setting workout timeout %f.
{"msg%{public}.0s":"Calibration prompt", "needed":%{private}ld}
No active workouts or defaults write not set to force location updates!
Workout, LOCATION UPDATE FOR TESTING %zd.
Suppressing workout event for cycling,%ld
{"msg%{public}.0s":"Event", "clientName":%{public, location:escape_only}s, "eventTime":"%{public}.6f", "eventType":%{public}ld, "workoutType":%{public}ld, "locationType":%{public}ld, "startTime":"%{public}.6f", "endTime":"%{public}.6f", "sessionID":%{public, location:escape_only}s}
Error delivering event, %s, %p
CL: CLWorkoutSubscription::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLWorkoutSubscription::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
shouldILog returned %d for tag %d, last %f now %f, threshold is %lu
WorkoutElevationFusion,phone source time rolled back, now %f, prev, %f
WorkoutElevationFusion,watch source time rolled back, now %f, prev, %f
WorkoutElevationFusion,unexpected timestamp on source switch,fElevationWatch.startTime,%f
WorkoutElevationFusion,source,%d,deltaH,%f
WorkoutElevationFusion,VariabilityCheck,Baro,%f,Source,%f
WorkoutElevationFusion,BaroQuality,%d,DEMSourceAvailable,%d,GPSSourceAvailable,%d
WorkoutElevationFusion,WorkoutType,%d,BaroGood,%d,BaroUnkDEMAgree,%d,DEMBaroUnk,%d,BaroUnkDEMDisagree,%d,BaroUnkNoDEM,%d,DEMBaroBad,%d,None,%d,GPSBaroGood,%d,GPSBaroUnk,%d,GPSBaroBad,%d,GPSUnvailBaroGood,%d,GPSUnvailBaroUnk,%d,GPSUnvailBaroBad,%d,TransBaroDEM,%d,TransToGPS,%d,TransBaroToNone,%d,TransDEMToNone,%d,TransGPSToNone,%d
WorkoutElevationFusion,ResidualCheck,agree,%d,max-min,%f,median,%f,residual,%f
Walking steadiness query returned empty for CoreAnalytics
Error querying walking steadiness for CoreAnalytics, %d
UserInfo health not sent to CoreAnalytics because logging not enabled
Sending UserInfo to CoreAnalytics
CLWifiTilesManager is not supported in diagnostics mode
WIFITILE: fDefaultMaxDownloadListSize, %d
WIFITILE: MTimeModificationPeriod, %.1lf
@TileEvent, wifi, locked, %d
TILE: defaultWifiTilesServerUrl, %{private}s, overridden, %{public}d
WIFITILE: fDefaultEncryptionGracePeriod, %.1lf
WIFITILE: fDefaultDisableTilesWhileLocked, %d
WIFITILE: onDataProtectionNotification, %p, notification, %d
WIFITILE: onDataProtectionNotification, kNotificationEncryptedDataAvailability, was, %d, now, %d, availability, %d
WIFITILE: updateProtectionClass, skip on unlock
WIFITILE: %{public}s
WIFITILE: onClientNotification, %p, notification, %d
WIFITILE: kNotificationReset
WIFITILE: kNotificationLocationServicesStatus, areLocationServicesEnabled, %{public}d
WIFITILE: #CacheDelete kNotificationSoftwareUpdateStorageRecovery
WIFITILE: deleteAgedDownloadItems, start
WifiTile, deleteAgedDownloadItems, delete, age, %{public}.1lf, %{public}.1lf, tile, %{private}s
@TileReq, wifi, rmlist, llsw, %{private}.2lf, %{private}.2lf, aged, size, %{public}ld
WIFITILE: deleteAgedDownloadItems, deleted, %u, done
WIFITILE: deleteAgedTiles, start, name, %s, size, %lu
Missing wifi #tile, x, %{private}d, y, %{private}d, #CloneMe
Deleted wifi #tile isFileExistsOnServer is false. x, %{private}d, y, %{private}d, #CloneMe
@TileList, wifi, delete, llsw, %{private}.2lf, %{private}.2lf, limits, size, %{public}lu
WIFITILE: deleteAgedTiles, end, numOfDeletedTiles, %lu, remain, %lu, name, %s
WIFITILE: isCurrentTile, degreesFromCornerLat, %.8lf, degreesFromCornerLon, %.8lf, inside, %d, %d, isCurrentTile, %d, %d, isCurrentLocationKnown, %d, %s
WIFITILE: dispatch, deleteAgedTiles, for, %s
WIFITILE: deleteAgedTiles, fTilesToDownload
WIFITILE: cancelAllDownloads, planned, %lu
WIFITILE: removeAllTiles, cleaning map, %d, %s
@TileList, wifi, delete, llsw, %{private}.2lf, %{private}.2lf, all, size, %{public}lu
WIFITILE: removeAllTiles, end, name, %s, size, %lu, unprot size, %lu, downloadSize, %lu
wifi #tiles, populateTilesSet
@TileEvent, wifi, indexed, %{public}lu
{"msg%{public}.0s":"CLWifiTilesManager::lockAllOnDiskWifiTiles", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "now_s":"%{public}.09f"}
{"msg%{public}.0s":"lock on-disk wifi #tiles", "numberOfOnDiskTiles":%{public}ld}
WIFITILE: refreshTilesDataIfNeeded, isTileDataExpired, %d, isShouldBeDownloaded, %d, tile, %s
WIFITILE: checkDownloadSchedule, wifi off - no tile downloads
WIFITILE: checkDownloadSchedule, location services disabled - no tile downloads
WIFITILE: checkDownloadSchedule, index is not available until first unlock, fDataProtectionEnabled, %{public}d
WIFITILE: checkDownloadSchedule, no data connectivity, avoiding downloads, reachability, %{public}d, companion, %{public}d
WIFITILE: checkDownloadSchedule, no download on none broadband cellular connections
WIFITILE: checkDownloadSchedule, skip, wifion, %{public}d, ls, %{public}d, indexed, %{public}d, protection, %{public}d, lockdisable, %{public}d, reach, %{public}d, companion, %{public}d, broadband, %{public}d
WIFITILE: checkDownloadSchedule, numOfActiveDownloads, %{public}d, not scheduling more
WIFITILE: checkDownloadSchedule, both download requests are already in use
WIFITILE: checkDownloadSchedule, both download requests null, shutdown?
WIFITILE: checkDownloadSchedule, skip, active, %{public}d, inprogress, %{public}d, %{public}d, shutdown, %{public}d, %{public}d
WIFITILE: checkDownloadSchedule, priority, %{public}d, lastLocation, %{private}s
WIFITILE: checkDownloadSchedule, chose, downloadState, %{public}s
WIFITILE: checkDownloadSchedule, started downloading, numOfActiveDownloads, %{public}d, tile, %{private}s
@TileReq, wifi, start, llsw, %{private}.2lf, %{private}.2lf, reach, %{public}d, url, %{private}s
WIFITILE: checkDownloadSchedule, numOfActiveDownloads, %{public}d, tilesToDownload, %{public}lu, small, %{public}d, large, %{public}d
WIFITILE: checkDownloadSchedule, NoActiveDownloads
WIFITILE: checkDownloadSchedule, rule, isCurrent, isAllowCellularIfCurrent,  IsOkToDownloadRealtime, %s
WIFITILE: checkDownloadSchedule, rule, isCurrent, fDownloadCurrentTileOverCell, IsOkToDownloadRealtime, %s
WIFITILE: checkDownloadSchedule, rule, isCurrent, IsOkToDownloadLarge, %s
WIFITILE: checkDownloadSchedule, rule, isAllowCellularIfNotCurrent, IsOkToDownloadRealtime, %s
WIFITILE: checkDownloadSchedule, rule, IsOkToDownloadLarge, %s
WIFITILE: tileDownloadCompleted, tile, %s, download done, success, %d, NSURLErrorCode, %d, tileDoesNotExist, %d, reachability, %d, locked, %d, fileSize, %d
@TileReq, wifi, downloaded, llsw, %{private}.2lf, %{private}.2lf, success, %{public}d, NSURLErrorCode, %{public}d
WifiTile, where did this download request come from?, download, %{public}p, #CloneMe
Null pointer in fTilesToDownload
WifiTile, tileDecompressionCompleted, no tile for download, %{public}p, #CloneMe
WIFITILE: tileDecompressionCompleted, tile, %s, decompress done, tileDownloadWasSuccessful, %d, NSURLErrorCode, %d, tileDoesNotExist, %d, reachability, %d
WIFITILE: tileDecompressionCompleted, tile, %s, reachability, %d, isLocked, %d, downloadDuration, %.1lf, downloadState, %s, progress, s, %d, l, %d
WIFITILE: tileDecompressionCompleted, replacing from, %s
WIFITILE: tileDecompressionCompleted, replacing to, %s
WIFITILE: tileDecompressionCompleted, added, tileid, %s, tilesMap.size, %lu
@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, download, size, %{public}lu
WIFITILE: kNotificationTileWasDownloaded, tileid, %s, tileHeaderParsed, %d, tileType, %d, serverUrl, %s, serverFilename, %s, absoluteLocalFilename, %s
WIFITILE: _tileDownloadCompleted, success, %d
WIFITILE: getNumOfActiveDownloads, tile, %s, is being downloaded, %d, total, %d, download, %p
WIFITILE: requestDownload, type, %d, %s, not active
@TileDl, wifi, request, llsw, %{private}.2lf, %{private}.2lf, currOverCell, %{public}d
TileDl, wifi, %{public}s
WIFITILE: requestDownload, index is not available until first unlock, fDataProtectionEnabled, %d
WIFITILE: requestDownload, tileId=%s isAlreadyDownloaded, %d, isBeingDownloaded, %d, shouldDownloadedBasedOnPermissions, %d, isAlreadyDownloaded, %d
WIFITILE: requestDownload, tileid, %s, already available, isUpdateMTimestamp, %d, isShouldBeRefreshed, %d, isBeingDownloaded, %d
WIFITILE: requestDownload, refresh download, %s
WIFITILE: requestDownload, tileid, %s, will be downloaded, details, %s, updated, %d
WIFITILE: requestDownload, tileid, %.8lf, %8lf, will be downloaded, details, %s
@TileReq, wifi, onlist, llsw, %{private}.2lf, %{private}.2lf, center, size, %{public}ld
WIFITILE: requestDownload, out of boundaries, y, %d, x, %d, tile_y, %d, tile_x, %d, neighbourTileID, %s
WIFITILE: requestDownload, y, %d, x, %d, tile_y, %d, tile_x, %d, neighbourTileID, %s
WIFITILE: requestDownload, adding neighbour, %s
@TileReq, wifi, onlist, llsw, %{private}.2lf, %{private}.2lf, neighbor, size, %{public}ld
@TileSched, wifi, set, %{public}d
WIFITILE: addToDownloadList, added, %s, fTilesToDownload.size, %lu
WIFITILE: onLocationNotification, ignore leech when LS off
WIFITILE: onLocationNotification, index is not available until first unlock, fDataProtectionEnabled, %{public}d
WIFITILE: onLocationNotification, fLastLocationDownloadCheckTimestamp, %{public}.1lf, isForceLocationCheck, %{public}d, fLastLocationProtectionCheckTimestamp, %{public}.1f, leech location, %{private}s
WIFITILE: onLocationNotification, unknown notificaiton, %d, %s
WIFITILE: onStatusNotification, kNotificationReachability, from, %d, to, %d
@TileSched, wifi, called, %{public}ld
WIFITILE: cleanUpDownloadList, start, isLocked, %d
WIFITILE: cleanUpDownloadList, tileid, %s, available on disc, no need to download
WIFITILE: cleanUpDownloadList, done,  isLocked, %d, cleanedFiles, %u
WIFITILE: CLWifiTilesManager::shutdown
WifiTile, invalid tileType, %{private}d, #CloneMe
WIFITILE: tiles, %s, not active
WIFITILE: location not relevant
#tiles, data protection enabled, ending side load.
#tiles, finished side-loading raw wifi tiles from disk
#tiles, side loading wifi tile from disk, %{private}s
Side loading already in progress.
#warning, failed to unlock wifi tile, %{private}s
@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, rawfile, size, %{public}lu
#warning, failed to save wifi #tile in db, %{private}s
Failed to create tile file object, %{private}s
@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, database, size, %{public}lu
WIFITILE: db to map, %lu, %lu
{"msg%{public}.0s":"Expecting exactly one result from updateAccessTimestampsIfNecessary", "size":%{public}lu, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
@TileList, wifi, touch, llsw, %{private}.2lf, %{private}.2lf, time, %{public}.1f
#warning, failed to read directory, %{private}s
{"msg%{public}.0s":"invalid wifi #tile encountered. now deleting.", "filepath":%{private, location:escape_only}s}
creating the BinaryLog instance
creating fInstance = new CLBinaryLog()
#Notice Logging binary sensor data to %{public}s
Failed to determine if log rotation is needed. errno, %{public}d, %{public}s
#Warning Failed to move aside log file %s to %s (%d)
#Warning Unable to open %s
tagEnabled returns %d for tag %d
PAUSE: Autopause not suppored on this platform, constructing CLAutopauseProviderDummy
PAUSE: Client registered for %s
PAUSE: Client unregistered for %s
headingCrown,%f,headingFace,%f,bodySum,%f,cx,%f,cy,%f,fx,%f,fy,%f,gx,%f,gy,%f,gz,%f
received visit for altimeter, inVisit, %d
queryWorkoutMets nil sessionId
Found vo2max calibration override flag,%d 
Running aggregation for calorie-related tables
CalorieAggregation: Estimating MaxMets
CalorieAggregation: Aggregating CalorieHistory
CalorieAggregation: Aggregating MaxMetsHistory
CalorieAggregation: Aggregating ExerciseMinuteHistory
CalorieAggregation: Aggregating VO2Max data
Attempting to defer CalorieAggregation activity
Failed to mark CalorieAggregation activity as deferred. Current state is %{public}ld
Failed to mark CalorieAggregation activity as done. Current state is %{public}ld
CalorieHistory,recordId,%d,startTime,%.3f,duration,%f,activityType,%d,userMets,%lf,calories,%lld,basalCalories,%lld,incrementalActiveCalories,%lld,incrementalBasalCalories,%lld
ExerciseMinuteHistory,recordId,%{public}d,startTime,%{public}.3f
UserProfile, Error in user info,heightM,%f
UserProfile, Error in user info,ageYr,%f
UserProfile,runVo2maxVal,%f,runVo2maxFlag,%d,runVo2maxUpdatedFlag,%d,hronsetVo2max,%f,hronsetVo2maxFlag,%d,derivedVo2max,%f,derivedVo2maxFlag,%d,oldVo2max,%f,estimatedVo2max,%f,mergedVo2max,%f,boundedVo2max,%f,doMerge,%d,betaBlockerUseChanged,%d,adaptiveEmThresh,%f
UserProfile, update completed with result, %{private}@
UserProfile, Number of active vo2max calibrations, %d, first PAL estimate at, %.3f, VO2max delta, %f
UserProfile, read before device unlock
UserProfile, Resetting to defaults for keys, %@
UserProfile, Resetting ActiveVo2Calibration, NumActiveCalibrations, and TimeFirstPAL.
UserProfile, resetting CLBodyMetrics for keys: %{private}@
UserProfile, Persistent store not yet initialized 
UserProfile, Unable to read from disk!
fActiveVo2maxOverride has been set to %d
GPS availability at time %lf, companion time, %lf, GPS timestamp, %lf, %d
GPS not available at time %lf
ActivitySpectator,activity{State,%d,Confidence,%d,MountedState,%d,MountedConfidence,%d,exitState,%d,estExitTime,%f,startTime,%f},nataliFeatures{fVectorMagnitude,%f,fEpochType,%d,fStanding,%d,fMachineFrequency,%f,fRowStrokeFrequency,%f,fRowStrokeAmplitude,%f,fRowStrokePower,%f,fPushVectorMagnitude,%f}
VO2Max, estimate, %{private}.2f, betaBlockerUser, %{private}d, eligibleForHealthKit, %{private}d
Sending sessionId %@ to CLVO2MaxCloudKitManager
Received Onset notification from CatherineNotifier (%f bpm)!
Updating min. HR, %f
UserProfile, Encrypted data availability, was, %d, now, %d, availability, %d
Proactively running HR and Odometer
Proactively running HR
UserProfile, Received from SPU, data protection enabled %d
Watch orientation settings updated, crown, %{public}d, wrist, %{public}d
HKDataCollector, received mode update of %{public}d and starting collectors
Activity Move Mode changed from %{public}d to %{public}d
HKDataCollector, received mode update of %{public}d and stopping collectors
UserProfile, Forcing a pal update.
UserProfile, Forcing a vo2max clear.
UserProfile, Forcing a vo2max update.
UserProfile, Forcing a run vo2max clear.
UserProfile, Forcing a run vo2max update.
ExerciseMinute, startTime, %{public}f
Enabled device motion for calorimetry
Disabled device motion for calorimetry
MoveMinute, startTime, %{public}f
HKDataCollector, insertDatums failed to insert a move minute with startTime, %{public}f, error, %{public}@
HKDataCollector successfully pushed move minute update with startTime, %{public}f
HKDataCollector, attempting to start collectors, pushing calories enabled, %{public}d
HKDataCollector, starting active energy collector
HKDataCollector, failed to get last active energy sample with error %@
HKDataCollector, starting basal energy collector
HKDataCollector, failed to get last basal energy sample with error %@
HKDataCollector, attempting to stop initialized collectors
HKDataCollector, stopping active energy collector
HKDataCollector, failed to finish with completion for active energy, error, %{public}@
HKDataCollector, successfully finished with completion for active energy
HKDataCollector, stopping basal energy collector
HKDataCollector, failed to finish with completion for basal energy, error, %{public}@
HKDataCollector, successfully finished with completion for basal energy
HKHealthStore, VO2Max, saveObjects failed on, %{public}@
VO2Max successfully pushed to HKHealthStore
Error retrieving cardio fitness notification status, %{public}@
Cardio fitness, notificationState, %{public}ld, notificationUnavailableReasons, %{public}ld
CardioFitnessEvent failed to push to HKHRCardioFitnessStore, startTime, %{public}f, endTime, %{public}f, error, %{public}@
CardioFitnessEvent successfully pushed to HKHRCardioFitnessStore, startTime, %{public}f, endTime, %{public}f
Forcing a fake VO2Max sample: vo2Max, %{private}.2f, startTime, %{public}f
Forcing a fake Cardio Fitness Event: latestVO2Max, %{private}.2f, lowClassificationThreshold, %{private}.2f, alertPeriodStartTime, %{public}f, alertPeriodEndTime, %{public}f, isRepeatAlert, %{private}d
HKDataCollector, attempting to create HistoricalPush transaction before releasing previous one
HKDataCollector, creating HistoricalPush transaction
HKDataCollector, releasing HistoricalPush transaction
HKDataCollector, attempting to release HistoricalPush transaction after it was released
HKDataCollector, handling last persisted value for active energy
HKDataCollector, handling last persisted value for basal energy
HKDataCollector, unknown collector passed!
HKDataCollector, sent last persisted with time %{public}f
HKDataCollector, sent nil last persisted so grabbing earliest record with time %{public}f
HKDataCollector, query range didn't change with last entry %{public}f, setting new
HKDataCollector, completed query with %{public}d iterations
HKDataCollector, query from %{public}f to %{public}f returned %{public}lu records with result %{public}d
HKDataCollector, unable to perform incremental calculation since only %{public}lu entries in db
HKDataCollector, backfilled %{public}lld calories, from %{public}f to %{public}f
HKDataCollector, failed to insert energy sample, error, %{public}@
HKDataCollector, successfully pushed energy sample
#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.
CL: CLNatalimetryNotifier::onCatherineNotification
{"msg%{public}.0s":"CLNatalimetryNotifier::onCatherineNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNatalimetryNotifier::onDataProtectionNotification
{"msg%{public}.0s":"CLNatalimetryNotifier::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNatalimetryNotifier::onCompanionNotification
{"msg%{public}.0s":"CLNatalimetryNotifier::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNatalimetryNotifier::onWatchOrientationSettingsNotification
{"msg%{public}.0s":"CLNatalimetryNotifier::onWatchOrientationSettingsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNatalimetryNotifier::onFitnessTrackingNotification
{"msg%{public}.0s":"CLNatalimetryNotifier::onFitnessTrackingNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNatalimetryNotifier::onStoredUserInfo
{"msg%{public}.0s":"CLNatalimetryNotifier::onStoredUserInfo", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNatalimetryNotifier::onSessionTrackerAppLaunchNotification
{"msg%{public}.0s":"CLNatalimetryNotifier::onSessionTrackerAppLaunchNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLNatalimetryNotifier::onDeviceMotionData
{"msg%{public}.0s":"CLNatalimetryNotifier::onDeviceMotionData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
METMinutes,time rolled back
Start spectator for src %s
Activate src %s
Inactivate src %s
#Warning Input, elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.
#Warning Input, all-day elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.
%s is not ready at, %f, timeout, %f
%s is ready at, %f, timeout, %f
Climbing,deltaElevation,%f,ascentDuration,%f,climbingMets,%f,len,%lu
Climbing,epochMets,%f,bufferLength,%lu
Climbing,epochMets,%f,historicalBufferLength,%lu
[CLGBE] SPU bias NOT available,default,%{public}s
[CLGBE] Client instance %{public}p already unregistered
[CLGBE] Removing client %{public}p
[CLGBE] Adding client %{public}p, sending out cached gyro bias,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f
[CLGBE] Adding client %{public}p, no cached gyro bias available
[CLGBE] Gyro not available
[CLGBE] SPUEnabled,%{public}d,BuildingGYTT,%{public}d,NumClients,%{public}lu
{"msg%{public}.0s":"AOP/SPU gyro bias not available on this platform", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
[CLGBE] Notifying clients on temperature update,temperature,%{public}f
[CLGBE] GyroBias,time,%{public}f,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,dbias.x,%{public}f,dbias.y,%{public}f,dbias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f,client,%{public}p
[CLGBE] #Warning Temperature is changing too quickly, clearing GYTT buffers,max,%{public}f,min,%{public}f
[CLGBE] #Warning Could not insert GYTT because bump was detected,variance.x,%{public}f,y,%{public}f,z,%{public}f
[CLGBE] Bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public}f,temperature,%{public}f
[CLGBE] Expected linear fit.
[CLGBE] GyroBiasFit,slope.x,%{public}f,slope.y,%{public}f,slope.z,%{public}f,intercept.x,%{public}f,intercept.y,%{public}f,intercept.z,%{public}f,lastMiniCal,%{public}f
[CLGBE] SPUGyroBias,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f,client,%{public}p
[CLGBE] Ignoring bias estimate during charging
[CLGBE] SPU bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public}f,temperature,%{public}f
[CLGBE] Registering for gyro notifications
[CLGBE] Unregistering for gyro notifications
[CLGBE] Registering for gyro temperature notifications
[CLGBE] Unregistering for gyro temperature notifications
[CLGBE] Registering for magnetometer notifications
[CLGBE] Unregistering for magnetometer notifications
[CLGBE] Registering for SPU Gyro Bias And Variance
[CLGBE] Removing SPU Gyro Bias And Variance dispatcher
configuration: wake threshold = %f
Registering with daemon status
Registering with CLAccelerometer
Registering throttledDispatcher with CLAccelerometer
Unregistering with CLAccelerometer
Unregistering throttleDispatcher with CLAccelerometer
detection @ %llu : low %f high %f status %d confidence %d odds %.2f
Failed to add throttled dispatcher
throttled @ %llu: accel = [%.2f %.2f %.2f] = %.2f ? %.2f
Failed to add dispatcher
kNotificationSleep. Turning off on body detector
kNotificationWake. Turning on on body detector
CL: CLOnBodyNotifier6::onDaemonStatusNotification
{"msg%{public}.0s":"CLOnBodyNotifier6::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLOnBodyNotifier6::onAccelerometerData
{"msg%{public}.0s":"CLOnBodyNotifier6::onAccelerometerData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLOnBodyNotifier6::onThrottledAccelerometerData
{"msg%{public}.0s":"CLOnBodyNotifier6::onThrottledAccelerometerData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Unable to find index (%{public}d) to value on which we want to build a cluster around!  Returning from function.
VO2MaxSummaryHistory, DB not accessible
Deleting VO2MaxSummaryHistory records from db where sessionId = %{public}s
Index VO2MaxSummaryHistorySessionIdIndex already exists; not re-creating
Unable to create index VO2MaxSummaryHistorySessionIdIndex
Index VO2MaxSummaryHistorySessionIdIndex created successfully
HRHBS StopDetected,%{public}f,%{public}f
HRHBS,good,%f,eDiff,%f,degree,%f
Rowing, Speed Model, timestamp, %f, stroke power, %f, strokes amplitude, %f, stroke rate (spm), %f, height (m), %f, gender, %d, speed, %f, strokePowerDM, %f, strokeAmpDM, %f, strokeRateDM, %f, strokeDriveVelocityDM, %f, strokeLengthDM, %f, speedDM, %f, speedLegacy, %f
Rowing, WR Model, timestamp, %f, stroke speed, %f, strokes amplitude, %f, weight (KG), %f, METS, %f, fMetsScaling, %f, METSDM, %f, METSLegacy, %f
#Warning #AMLCfg,inst,%{public}d,overriding first fix delay to %{public}f
#Warning #AMLCfg,inst,%{public}d,overriding enablement of multiple SMS to %{public}d
{"msg%{public}.0s":"#AMLCfg updated CB info", "changed":%{public}d, "sim":%{public}d, "version":%{public, location:escape_only}s, "id":%{public, location:escape_only}s}
{"msg%{public}.0s":"#AMLCfg,logSettings", "sim":%{public}d, "smsAddress":%{private, location:escape_only}s, "binary":%{private}d, "port":%{private}d, "firstFixDelay":"%{public}f", "multipleSmsEnabled":%{public}hhd, "maxFixDelay":"%{public}f", "minFixDelay":"%{public}f"}
#AMLCfg ignoring emergency settings for unexpected inst %{public}d
#AMLCfg keeping previous active inst %{public}d
#AMLCfg ignoring unexpected inst %{public}d
#AMLCfg active inst changed to %{public}d
#AMLCfg unexpected inst %{public}d is active
#AMLCfg AML config for inst %{public}d wasn't created on construction
{"msg%{public}.0s":"#AML logging current settings", "enabled":%{public}d, "inst":%{public}d, "bundle ID":%{public, location:escape_only}s, "bundle version":%{public, location:escape_only}s, "sms address":%{private, location:escape_only}s, "binary":%{private}d, "port":%{private}d}
#AML active inst changed to %{public}d
{"msg%{public}.0s":"#AML received send success notification", "inst":%{public}d, "messageID":%{public}d}
{"msg%{public}.0s":"#AML received send failure notification", "inst":%{public}d, "messageID":%{public}d, "sendError":%{public}d, "modemError":%{public}d}
#Warning #AML SendFixTimeout fired while Disabled
#AML SMS Notification Timeout. Submit AWD report with failure
#AML SMS Notification timer timedout when no notifications were expected
#Warning #AML SessionAssertReleased fired in Disabled state
#Warning #AML SendFixTimeout fired while Idle
#Warning #AML SessionAssertReleased fired in Idle state
#AML Submitting previous session AWD report before starting new session
#AML session assertion active during Session Exit,clearing
#Warning #AML unexpectedly disabled during active emergency call
#AML delaying Session Exit due to session assertion
#Warning #AML SMS Timeout while in Session. Ignoring it
#Warning #AML,shouldSendLocation,cached location is invalid
#AML,shouldSendLocation,sending,last send attempt had no location
#AML,shouldSendLocation,not sending,last send was too recent,tDiff,%{public}f
#AML,shouldSendLocation,sending,lower hunc,previous,%{public}f,current,%{public}f
#AML,shouldSendLocation,sending,location changed significantly,dist,%{public}f
#AML,shouldSendLocation,not sending,no significant changes
#AML attempted to send location when not enabled
#AML,sendLocation,roaming not supported
#AML not sending no fix message
#AML preparing to send SMS message: %{private}s
#Warning #AML attempting to send AML SMS on a device without CoreTelephony
#AML sending valid fix from time %{public}s
#AML method,%{public}c,lat,%{private}f,lon,%{private}f,acc,%{public}f
#AML sending no fix message at time %{public}s
#Warning #AML Valid location with unknown or obsolete type
#AML total message length,%{public}d
#Warning #AML unexpected error code
#update-count: archive:%@, oldCount:%d, newCount:%d, oldTotalCount:%d, newTotalCount:%d
{"msg%{public}.0s":"failed to create archive dir", "path":%{private, location:escape_only}@, "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"archive dir now exists", "path":%{private, location:escape_only}@}
{"msg%{public}.0s":"rotating secondary file", "from":%{private, location:escape_only}@, "to":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Warning could not open file", "path":%{private, location:escape_only}@}
{"msg%{public}.0s":"CLHRequestArchive error writing conglomerate(parimary and secondaries)", "file":%{public, location:escape_only}s, "Error":%{public, location:escape_only}s}
{"msg%{public}.0s":"removing primary file", "url":%{private, location:escape_only}@}
{"msg%{public}.0s":"CLHRequestArchive error over-writing primary data", "file":%{public, location:escape_only}s, "Error":%{public, location:escape_only}s}
{"msg%{public}.0s":"failed to update secondary filename", "from":%{private, location:escape_only}@, "to":%{private, location:escape_only}@, "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"updated secondary filename", "to":%{private, location:escape_only}@}
{"msg%{public}.0s":"CLHRequestArchive secondary-data write failed", "secondaryFilePath":%{public, location:escape_only}s, "Error":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning Turning on sub-archiving on an archive with existing data erases existing data.", "directory":%{private, location:escape_only}@}
{"msg%{public}.0s":"failed to create sub-archive", "path":%{private, location:escape_only}@, "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"#SubArchiving delete inactive. receiver not sub-archive", "receiver":%{public, location:escape_only}s}
{"msg%{public}.0s":"#SubArchiving delete inactive. archiveToDelete not sub-archive", "archiveToDelete":%{public, location:escape_only}s}
{"msg%{public}.0s":"#SubArchiving not enabled. Inactive sub-archives cannot be determined.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"totalSecondaryPointsUnderAllSubArchives", "archive":%{public, location:escape_only}@, "totalCount":%{public}d}
{"msg%{public}.0s":"failed to find contents of rootDir", "url":%{private, location:escape_only}@, "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"found contents of rootDir", "url":%{private, location:escape_only}@, "count":%{private}lu}
{"msg%{public}.0s":"CLHRequestArchive auto clean-up, threshold none", "dir":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLHRequestArchive auto clean-up. dir not exists", "dir":%{public, location:escape_only}s}
{"msg%{public}.0s":"#warning CLHRequestArchive auto clean-up, directory-url nil", "dir":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLHRequestArchive auto clean-up. Enumeration error", "Item":%{public, location:escape_only}@, "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"CLHRequestArchive auto clean-up completed", "threshold":%{public}u, "dir":%{public, location:escape_only}s, "total-items":%{public}u}
{"msg%{public}.0s":"CLHRequestArchive auto clean-up. dir deleted.", "dir":%{public, location:escape_only}s, "status":%{public}hhd}
{"msg%{public}.0s":"CLHRequestArchive auto clean-up threshold crossed", "threshold":%{public}u, "dir":%{public, location:escape_only}s, "total-items":%{public}u}
file does not exists. CheckAndRemoveItemAtPath : %@
{"msg%{public}.0s":"failed to remove fs item", "URL":%{public, location:escape_only}@, "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"removed fs item", "URL":%{private, location:escape_only}@}
{"msg%{public}.0s":"Error finding contents of directory", "directory":%{public, location:escape_only}@}
WorkoutElevation,onElevationPhone,fusionInput,startTime,%.3f,ascended,%d,descended,%d
WorkoutElevation,onElevationPhone,fusionOutput,startTime,%.3f,ascended,%d,descended,%d
WorkoutElevation,onElevationWatch,fusionInput,startTime,%.3f,ascended,%d,descended,%d,pressureAmplitude,%f,pressureQuality,%d,deltaSteps,%d
WorkoutElevation,onElevationWatch,fusionOutput,startTime,%.3f,ascended,%d,descended,%d
WorkoutElevation,clients,%d
WorkoutElevation,phone connection,prev,%d,curr,%d,elev,%d
CL: CLElevationController::onMotionStateObserverNotification
{"msg%{public}.0s":"CLElevationController::onMotionStateObserverNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
WorkoutElevation,subs,phone,0
WorkoutElevation,subs,phone,waitingToUnsubscribe
WorkoutElevation,subs,phone,1
WorkoutElevation,subs,phone,cancelWaitingToUnsubscribe
Received MotionState request,client,%s,subscribe,%d
Failed to override motion state youth. Invalid message received from framework.
CL: CLMotionStateSubscription::onMotionStateNotification
{"msg%{public}.0s":"CLMotionStateSubscription::onMotionStateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
VO2MaxPrecondition,sessionStart,%d,sessionStartTime,%f,lastEstimateTime,%f,status,%d
WifiCalc, zaxis, kalmanFilter, already initialized
WifiCalc, zaxis, kalmanFilter, did not initialize, wifi measurement timestamp %{private}0.3f was negative.
WifiCalc, zaxis, kalmanFilter, did not initialize, relative altitude timestamp %{private}0.3f was negative.
WifiCalc, zaxis, kalmanFilter, initialized, wifi timestamp, %{private}0.3f, relative altitude timestamp, %{private}0.3f, initial altitude, %{private}0.3f, initial uncertainty, %{public}0.3f.
WifiCalc, zaxis, invalid uncertainty, %{public}0.3f
WifiCalc, zaxis, invalid altitude, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, did not propagate and update, not initialized
WifiCalc, zaxis, kalmanFilter, stopping, did not propagate for, %{private}0.3f, seconds
WifiCalc, zaxis, kalmanFilter, stopping, did not update for, %{private}0.3f, seconds
WifiCalc, zaxis, kalmanFilter, stopping, unable to propagate
WifiCalc, zaxis, kalmanFilter, stopping, unable to update
WifiCalc, zaxis, kalmanFilter, estimated altitude, %{private}0.3f, uncertainty, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, did not propagate, filter's propagation timestamp, %{private}0.3f, is larger than current wifi timestamp, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, did not propagate, filter's relative altitude timestamp, %{private}0.3f, is larger than current relative altitude timestamp, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, baro outage time interval, %{private}0.3f, altitude change over outage, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, propagated, timestamp, %{private}0.3f
WifiCalc, zaxis, kalmanFilter, updated, timestamp, %{private}0.3f
TILE_APP: begin
TILE_APP: Removing request since it timed out, lat, %f, lon, %f, radius, %f.
TILE_APP: shutdown
TILE_APP: getAppsForArea, examining %zu candidate grids.
TILE_APP: getAppsForArea, query for exact grid containing lat = %f, lon = %f, gridLat = %f, gridLon = %f
#Warning TILE_APP: getAppsForArea, invalid age rating, lat, %f, lon, %f, adamId, %d
TILE_APP: fetchAppsForArea, tile is available for lat = %f, lon = %f.
TILE_APP: fetchAppsForArea, found %lu apps.
TILE_APP: fetchAppsForArea, tile does not exist on the server for lat = %f, lon = %f.
TILE_APP: fetchAppsForArea, tile is not available for lat = %f, lon = %f. Request for download.
TILE_APP: onTileWasDownloadedNotification, activeRequests.count = %lu
TILE_APP: onTileWasDownloadedNotification, tile is available (or tile is 404) for lat = %f, lon = %f.
TILE_APP: onTileWasDownloadedNotification, found %lu apps.
#Warning TILE_APP: Got unexpected notification, %d
Assertion failed: receiver, file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMLinearTemperatureFit.h, line 27,receiver must not be null..
emergency wifi toggle not allowed so skipping check
Received kNotificationWifiLocationBatched, num,%u,Size, %lu
Received unknown notification %d
Skipping new location with invalid coordinate
Skipping new location with invalid rawCoordinate
Skipping new location with coordinate in null-island
Skipping new location with rawCoordinate in null-island
#Warning Last confident location is in future, timestamp,%.03lf
Skipping new location with an older timestamp,%.03lf,cached,%.03lf
Skipping new location, since having recent more confident location
Last confident location not available
Last confident location too old, maxAge = %.1lf
Notifying cached location,num,%u,accuracy,%.01lf,timestamp,%.03lf,lifespan,%.04lf
Received a kNotificationCachedLocationControllerStateUpdate notification, state, %d
Recieved unknown notification %d
CL: CLLastConfidentLocation::onCachedLocationControllerNotification
{"msg%{public}.0s":"CLLastConfidentLocation::onCachedLocationControllerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
received unexpected darwin notification
TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s
TILE: result: tilestool: prog, %3lu, %3lu, ===============> isFound, %d, location, %14.8lf, %14.8lf, entry, %s
TILE: result: tilestool: pass, %d, tests, %lu, %lu
TILE: index entry, %3lu, %3u, %s
TILE: searched, numOfEntries, %u, offsetEntries, %d
TILE: avoid data search
TILE: entry, %3lu, %3u, %3lu, %s, loc, %.8lf, %.8lf, delta, %.5lf, %.5lf, grid, %u, %u
TILE: getLocationByKey, isFound, %d, searchedArea, %d, key, %s
TILE: binarySearchIndex, size, %lu, searchedIndexEntry, %s, %d
TILE: index search, match, %s
TILE: index search, not found
TILE: binarySearchData, search data, isFound, %d, numOfCompares, %u
TILE:  getLocationByKey_mmap, key, %s
TILE: getLocationByKey_mmap, failed to mmap, #CloneMe
TILE: pIndexEntries passes valid mmapped region, pIndexEntries:%{private}lu, numOfEntries:%{private}u, atOffset:%{private}lld, %{private}s, %{private}s, %{private}s
TILE: pDataEntries passes valid mmapped region, pDataEntries:%{private}lu, numOfEntries:%{private}u, atOffset:%{private}lld, %{private}s, %{privat}s, %{private}s
TILE: invalid binary search %{private}s in %{private}s, %{private}s, a:%{private}u, b:%{private}u, max:%{private}u, %{private}s
TILE: no index section before entries section, %{private}s, %{private}s
TILE: not found in index, a, %{private}u, b, %{private}u, %{private}s, %{private}s, %{private}s
TILE: unregconized sectionId, %lld, %s, %s
TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s
TILE: getLocationByKey_traverse, key, %s
TILE: getLocationByKey_traverse, prefer local file name because it exists, %s
TILE: getLocationByKey_traverse, isFound, %d, searchedArea, %u, key, %s, entry, %s
{"msg%{public}.0s":"CLBBTFTA,releasing assertion", "client":%{public, location:escape_only}s, "reason":%{public, location:escape_only}s}
#wigo,off,CLBBTFTA
{"msg%{public}.0s":"CLBBTFTA", "message":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"#Warning,CLBBTFTA,unrecognized message", "message":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLBBTFTA,feature not supported"}
{"msg%{public}.0s":"CLBBTFTA", "assertion already taken by":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLBBTFT,not entitled,ignoring", "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLBBTFTA,missing bundleID,request denined", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLBBTFTA,missing bundlePath,request denined", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLBBTFTA,missing reason,request denined", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLBBTFTA,empty reason,request denined", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLBBTFTA,no beneficiary,request denined", "requested by":%{public, location:escape_only}s, "reason":%{public, location:escape_only}s}
#wigo,on,CLBBTFTA
{"msg%{public}.0s":"CLBBTFTA", "taken by":%{public, location:escape_only}s, "reason":%{public, location:escape_only}s}
{"msg%{public}.0s":"CLBBTFTA", "requested by":%{public, location:escape_only}s, "entitlement":%{public, location:escape_only}s, "entitled":%{public}hhd}
{"msg%{public}.0s":"CLBBTFTA,GPSUTCLeapSecond,GregorianTime", "year":%{public}d, "month":%{public}d, "day":%{public}d, "hour":%{public}d, "minute":%{public}d, "second":"%{public}f"}
{"msg%{public}.0s":"CLBBTFTA,GPSUTCLeapSecond,nextPotentialLeapSecUpdateTime", "currGpsTimeNsec":%{public}llu, "fPotentialLeapSecondUpdateTimeGPSNsec":%{public}llu}
{"msg%{public}.0s":"CLBBTFTA,kNotificationBasebandTimeFreqTransfer"}
{"msg%{public}.0s":"CLBBTFTA,GNSS measurements not valid", "SystemClockFreqValid":%{public}hhd, "SystemClockTimeandFreqValid":%{public}hhd, "GPSTimeNs":%{public}llu}
{"msg%{public}.0s":"CLBBTFTA,GNSS measurements not valid", "SystemClockFreqValid":%{public}hhd, "SystemClockMsec":%{public}llu, "GPSTimeNs":%{public}llu}
{"msg%{public}.0s":"CLBBTFTA", "kCLBBTFT_messageVersion":"%{public}.1f", "kCLBBTFT_timestamp":"%{public}f", "kCLBBTFT_systemRTCMsec":%{public}llu, "kCLBBTFT_systemRTCSubMsec":"%{public}f", "kCLBBTFT_systemRTCUncertaintyMsec":"%{public}f", "kCLBBTFT_GPSTimeNsec":%{public}llu, "kCLBBTFT_GPSTimeUncertaintyNsec":"%{public}f", "kCLBBTFT_clockOffsetPPB":"%{public}f", "kCLBBTFT_clockOffsetUncertaintyPPB":"%{public}f", "kCLBBTFT_clockOffsetThermalCorrectionPPB":"%{public}f"}
{"msg%{public}.0s":"CLBBTFTA,heatmap,invalid az/el"}
{"msg%{public}.0s":"CLBBTFTA,kNotificationGnssMeas"}
{"msg%{public}.0s":"CLBBTFTA,heatmap,invalid GNSS measurement"}
{"msg%{public}.0s":"CLBBTFTA,Warning,unexpected onLocationControllerNotification"}
CL: CLDaemonBBTimeFreqTransferCallbackAssertion::onLocationControllerNotification
{"msg%{public}.0s":"CLDaemonBBTimeFreqTransferCallbackAssertion::onLocationControllerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLDaemonBBTimeFreqTransferCallbackAssertion::handleMeasurementNotification
{"msg%{public}.0s":"CLDaemonBBTimeFreqTransferCallbackAssertion::handleMeasurementNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLDaemonBBTimeFreqTransferCallbackAssertion::onGnssLocationNotification
{"msg%{public}.0s":"CLDaemonBBTimeFreqTransferCallbackAssertion::onGnssLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
TILE: creating directory, %s, ret, %d
TilesSet, Initialize CLTilesSetCollection
{"msg%{public}.0s":"Invalid TileType value.", "tileType":%{private}d}
{"msg%{public}.0s":"Index out of bounds", "index":%{private}d, "size":%{private}lu}
{"msg%{public}.0s":"Mismatch of tile type inserting CLTilesSet."}
[Dynamic Config] Error on config insertion: %{public}d
Attempting to write accel sample. startTime: %{public}f, timestamp: %{public}llu, dataSize: %{public}d
Attempting to write gyro sample. startTime: %{public}f, timestamp: %{public}llu, dataSize: %{public}d
Attempting to write pressure. startTime: %{public}f, timestamp: %{public}llu, dataSize: %{public}f
Aggregating accel sensor recorder samples.
Aggregating gyro sensor recorder samples.
Aggregating pressure sensor recorder samples.
Record %{location:CLSensorRecorder_Types::DataType,public}d data for %{public}f
requested sampling rate of %{public}d is greater than the max allowed of %{public}d
Invalid data type.
setting desired accel sampling rate to %dhz
Error accessing sensor recorder data from %{private}f, %{private}f
Error occurred while retrieving data record %{private}llu
Wrote %lu meta records across %d data containers to %s
Updating %{location:CLSensorRecorder_Types::DataType,public}d sampling rate %{public}d, fitness tracking enabled, %{public}d
Updated %{location:CLSensorRecorder_Types::DataType,public}d subscription due to invalid time.
Updated %{location:CLSensorRecorder_Types::DataType,public}d subscription override due to invalid time.
#CacheDelete - onSoftwareUpdateStorageRecovery - Flushing SensorRecorderDB
Failed to dump sensor recorder (accel) to disk because fileHandle is nil.
CL: CLSensorRecorderNotifier::onFitnessTrackingNotification
{"msg%{public}.0s":"CLSensorRecorderNotifier::onFitnessTrackingNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSensorRecorderNotifier::onSysdiagnoseStarted
{"msg%{public}.0s":"CLSensorRecorderNotifier::onSysdiagnoseStarted", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSensorRecorderNotifier::onSoftwareUpdateStorageRecovery
{"msg%{public}.0s":"CLSensorRecorderNotifier::onSoftwareUpdateStorageRecovery", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Attempting to fulfill scan requests,%lu.
Fulfilled scan requests,%d.
Processing events for %lu proximity zones.
Processed %d proximity zone events.
Bluetooth is powered off, no events will be processed.
CL: CLBTLEBeaconProviderMock::onEventSource
{"msg%{public}.0s":"CLBTLEBeaconProviderMock::onEventSource", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Elevation, %f, %f, %d, %d
TrackCalibration,%s,CalData,%s,ElevationAscended,%d,ElevationDescended,%d
[GPS] TPQ summary,A,%d,B,%d,C,%f,D,%f,E,%f,F,%f,G,%f,H,%d,config-1,%f,config-2,%f,config-3,%f
gps (%f, %f, %f, %f, %f, %f) (%d, %d, %d, %d, %d, %d)
GPS updateResult %f %f %f %llu
GPS queue precondition not met
GPS alg: reset
gps config %f, %f, %f
{"msg%{public}.0s":"Un-initialized query handler", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
id,%llu,startTime,%lf,eventType,%ld
Started tracking,duration,%.3f
Stopped tracking
CL: CLSpringTrackingNotifier::onDataProtectionNotification
{"msg%{public}.0s":"CLSpringTrackingNotifier::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Error expiring records.
DB UUID un-initialized
{"msg%{public}.0s":"Error setting finished handler.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Warning Overriding BeaconFenceBestEffortScheduleEnabled,%{private}d
#Warning Overriding BeaconFenceBestEffortInterval,%{private}.2f
iB: Adding zone,%{private}s
Invalid region definition for zone monitoring
{"msg%{public}.0s":"iB: Zone already registered", "zone":%{private, location:escape_only}s, "refCount":%{public}d}
{"msg%{public}.0s":"iB: Device doesn't support background monitoring, performing BE zone detection"}
iB: Registering zone,%{private}s, with Bluetooth
iB: Removing zone,%{private}s
{"msg%{public}.0s":"iB: Unregistering zone with Bluetooth, last client", "zone":%{private, location:escape_only}s}
{"msg%{public}.0s":"iB: Decremented zone reference count, still clients", "zone":%{private, location:escape_only}s, "refCount":%{public}d}
#Warning Unable to remove zone,%{private}s, it wasn't found.
iB: Zone detection timer woke up
iB: Received a wake event
iB: Resuming scan, reference count,%{public}d,lastScan,%{private}.0lf,lastScheduled,%{private}.0lf
iB: Scan is already resumed, reference count,%{public}d,lastScan,%{private}.0lf,lastScheduled,%{private}.0lf
iB: Suspending scan, reference count,%{public}d
iB: Scan is already suspended, reference count,%{public}d
iB: Posting notification with proximity devices,%{public}lu
iB: Best effort zone,%{private}s, firstExit,%{private}f, now,%{private}f, has not reached exitThreshold,%{private}f
iB: Best effort zone,%{private}s, subject to exit
{"msg%{public}.0s":"@iB: BE zone state transition", "zone":%{private, location:escape_only}s, "state":%{private}d, "totalZones":%{public}lu}
{"msg%{public}.0s":"iB: Resetting best effort zone exit state", "zone":%{private, location:escape_only}s}
CL: CLBTLEBeaconProviderConcrete::onDaemonStatusNotification
{"msg%{public}.0s":"CLBTLEBeaconProviderConcrete::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLBTLEBeaconProviderConcrete::onZoneDetectionTimer
{"msg%{public}.0s":"CLBTLEBeaconProviderConcrete::onZoneDetectionTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"HTTP header key must be string", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"HTTP header val must be string", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Request archive and Payload both were nil for upload request
{"msg%{public}.0s":"#network NetworkController received request", "request":%{private, location:escape_only}@}
{"msg%{public}.0s":"#network task didSendBodyData", "task":%{private, location:escape_only}@}
{"msg%{public}.0s":"#network task did complete with error", "task":%{private, location:escape_only}@, "error":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Warning NSHTTPURLResponse contains date in an obsolete format. Ignoring."}
{"msg%{public}.0s":"received data task response", "taskIdentifier":%{private}lu}
{"msg%{public}.0s":"#network data task completed", "taskIdentifier":%{public}lu}
{"msg%{public}.0s":"#network purging completed task", "taskIdentifier":%{public}lu}
{"msg%{public}.0s":"#network received response for unknown data task", "task":%{private, location:escape_only}@}
{"msg%{public}.0s":"#network task did receive data", "task":%{private, location:escape_only}@, "data":%{private, location:escape_only}@}
CLMMPED,%{public}.1lf,Unexpected,invalid bestParticle road
CLMMPED,%{public}.1lf,Unexpected,RawGPSScore not available
CLMMPED,%{public}.1lf,Unexpected,unable to determine roadWidth when filling crumb
CLMMPED,%{public}.1lf,fRawWeight,%{public}.2lf,fSnapWeight,%{public}.2lf,fTimeInMode,%{public}.2lf,snapType,%{public}d
CLMMPED,%{public}.1lf,Unexpected, null road when trying to add particles into candidate
CLMMPED,%{public}.1lf,shallConsiderOutgoingCandidate,ambiguityCase,combined,%{public}d,secondBestCombined,%{public}d,sigEnv,%{public}d
CLMMPED,%{public}.1lf,shallConsiderOutgoingCandidate,lowerOutgoingCountCase,course,%{public}.2lf,snapCourse,%{public}.2lf,outgoingSnapCourse,%{public}.2lf,approxCourseOfTurningRoad,%{public}.2lf,turningCourseDiff,%{public}.2lf,outgoingCondition,%{public}d
CLMMPED,%{public}.1lf,shallConsiderOutgoingCandidate,lowerOutgoingCountCase,course,%{public}.2lf,snapCourse,%{public}.2lf,outgoingSnapCourse,%{public}.2lf,isCrumbCourseAlignedWithOutgoing,%{public}d,isCrumbCourseAlignedWithIncoming,%{public}d,sigEnv,%{public}d,outgoingCondition,%{public}d
CLMMPED,%{public}.1lf,shallConsiderOutgoingCandidate,position dependent
CLMMPED,%{public}.1lf,snapCourse,%{public}.2lf,outgoingSnapCourse,%{public}.2lf, crumbCourse,%{public}.2lf, outgoingDistanceFromIntersection,%{public}.2lf,outgoingCondition,%{public}d,crumbCourseUnc,%{public}.2lf,significantCourseChange,%{public}d,isCrumbCourseAlignedWithOutgoing,%{public}d, isCrumbCourseAlignedWithIncoming,%{public}d
CLMMPED,%{public}.1lf,Unexpected, geometry is null
CLMMPED,%{public}.1lf,Unexpected, zero candidates,assessCandidates
CLMMPED,%{public}.1lf,unable to determine best particle
CLMMPED,%{public}.1lf,interpolateOnRoad returned false, determining mean road position
CLMMPED,%{public}.1lf,roadsConnected returned false, searching for connected candidates
CLMMPED,%{public}.1lf,interpolateOnRoad returned false, determining outgoing road position
CLMMPED,%{public}.1lf,candidate,ID,%{private}llu,fwd,%{public}d,countArndMean,%{public}d,bestParticleScore,%{public}.9lf,isCombined,%{public}d,isMulti,%{public}d,combinedWith,%{private}llu,fwd,%{public}d,incomingCnt,%{public}lu,outgoingCnt,%{public}d,combinedCnt,%{public}d,bestCombinedCnt,%{public}d,secondBestCombinedCnt,%{public}d,secondCombinedWith,%{private}llu
CLMMPED,%{public}.1lf,unexpectedly unable to find candidates,getSolutionCandidate
CLMMPED,%{public}.1lf,unexpectedly, best candidate is nullptr
CLMMPED,%{public}.1lf,overrode bestCandidate with alternate,roadID,%{public}lld,bestIncoming,%{public}d,altBestIncoming,%{public}d,bestCombined,%{public}d,altBestCombined,%{public}d
CLMMPED,%{public}.1lf,unexpectedly zero candidates,getBestCandidate
CLMMPED,%{public}.1lf,unexpectedly zero candidates,getAlternateBestCandidate
CLMMPED,%{public}.1lf,unexpectedly zero candidates,getSecondBestCandidate
CLMMPED,%{public}.1lf,Unexpected,particle road is null while eliminateParticlesWithRoadKey
CLMMPED,%{public}.1lf,unable to normalizeLikelihoods, negative/zero totalScore after regular update,%{public}.8lf
CLMMPED,%{public}.1lf,unable to computeLikelihoods
CLMMPED,%{public}.1lf,invalid Neffsum,%{public}.3lf
CLMMPED,%{public}.1lf,unable to compute likelihoods and csw vector
CLMMPED,%{public}.1lf,Unexpected number of particles after resampling,%{public}d
CLMMPED,%{public}.1lf,Resampled,Neff,%{public}lf
CLMMPED,%{public}.1lf,Unexpected,NULL road when computing score
CLMMPED,%{public}.1lf,Reducing particles to half,speed,%{public}.1lf,static,%{public}d
CLMMPED,%{public}.1lf,Added prior particle,score,%{public}.8lf
CLMMPED,%{public}.1lf,resample failed
CLMMPED,%{public}.1lf,candidate update failed
CLMMPED,%{public}.1lf,assessCandidates failed
CLMMPED,%{public}.1lf,extractSolution failed
CLMMPED,%{public}.1lf,Unexpected,particle count,0
CLMMPED,%{public}.1lf,Unexpected,candidate count,0
CLMMPED,%{public}.1lf,Unexpected,bestCandidate is nullptr
CLMMPED,%{public}.1lf,Unexpected,particles in candidate,0
CLMMPED,%{public}.1lf,Unexpected,best particle road in best candidate is nullptr
CLMMPED,%{public}.1lf,extractSolution,using outgoing particles,previous,%{public}d
CLMMPED,%{public}.1lf,Unexpected,solutionParticleVector has zero particles
CLMMPED,%{public}.1lf,deweightCourse,courseUnc,%{public}.1lf,deweightUnc,%{public}.1lf
CLMMPED,%{public}.1lf,invalidateCourse,particleIsOnSegementsThatHasSmallCurves,%{public}d,particleInOnSameRoadAsPriorSnap,%{public}d
CLMMPED,%{public}.1lf,Particle is on a curved section of road,%{private}lld,projection,%{public}.2lf,deweightCourse,%{public}d
CLMMPED,%{public}.1lf,invalidated course and recomputed solution,changeInDistance,%{public}.2lf,newChangeInDistance,%{public}.2lf
CLMMPED,%{public}.1lf,Unexpected,newParticle road is nullptr,1
CLMMPED,%{public}.1lf,eliminated outgoing roadKey for local solution,%{public}d
CLMMPED,%{public}.1lf,use new particle, course check, crumbCourseDiffWithNewParticle,%{public}.1lf,crumbCourseDiffWithPreviousParticle,%{public}.1lf
CLMMPED,%{public}.1lf,new particle without the outgoing road accepted,courseIsUnreliable,%{public}d
CLMMPED,%{public}.1lf,not using local solution without outgoing road,%{public}d
CLMMPED,%{public}.1lf,Unexpected,newParticle road is nullptr,2
CLMMPED,%{public}.1lf,Number of particles 0 after eliminating particles on combined road,%{public}d
CLMMPED,%{public}.1lf,Unexpected,best particle road is nullptr
CLMMPED,%{public}.1lf,Unexpected,bestCandidate bestParticle road is nullptr`
CLMMPED,%{public}.1lf,Using outgoing,incomingID,%{private}lld,outgoingID,%{private}lld,score,%{public}.8lf
CLMMPED,%{public}.1lf,Unexpected,unable to calculate score
CLMMPED,%{public}.1lf,Unexpected,unable to fill crumb
CLMMPED,%{public}.1lf,bestParticleRoadID,%{private}lld,score,%{public}.8lf
CLMMPED,%{public}.1lf,not snapping course,reason,distanceToIntersection,%{public}.1lf
CLMMPED,%{public}.1lf,distToNextMulti,%{public}.1lf,distFromPriorCrumb,%{public}.1lf,fabsCourseDiffWithSnap,%{public}.1lf,fabsCourseDiffWithPriorFullSnap,%{public}.1lf
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, mapMatch
CLMMPED,%{public}.1lf,unable to compute timeDiff
CLMMPED,%{public}.1lf,not matching, time betwen updates is 0.0
CLMMPED,%{public}.1lf,filterReset, dT, %{public}.1lf
CLMMPED,%{public}.1lf,not matching
CLMMPED,%{public}.1lf,filterReset, assessMatch failed
CLMMPED,%{public}.1lf,filterReset, adjustSolutionforRoadWidth failed
CLMMPED,%{public}.1lf,isSolutionAmbiguous,%{public}d,consecutiveAmbCount,%{public}.1lf
CLMMPED,%{public}.1lf,filterReset, shallReset
CLMMPED,%{public}.1lf,unable to re-initialize filter
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, prepareSolution
CLMMPED,%{public}.1lf,unable to initialize filter
CLMMPED,%{public}.1lf,filterReset, prediction failed
CLMMPED,%{public}.1lf,filterReset, update failed
CLMMPED,%{public}.1lf,using route hints
CLMMPED,%{public}.1lf,filterReset, prepareCandidates failed
CLMMPED,%{public}.1lf,checkForUserDeviationFromRoute skipped,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,routeHints,solutionDiff,%{public}.2lf,newSolutionDiff,%{public}.2lf,courseDiffNewAndRawSolution,%{public}.2lf,factor,%{public}.5lf,bestParticle,%{private}.8lf,%{private}.8lf,%{public}.3lf,%{private}lld,newBestParticle,%{private}.8lf,%{private}.8lf,%{public}.3lf,%{private}lld
CLMMPED,%{public}.1lf,filter swapped with local filter without routeHints,local,factor,%{public}.5lf,courseDiffNewAndRawSolution,%{public}.2lf
CLMMPED,%{public}.1lf,solutionJumpCheck,shouldNotPropagateFromLastSnap,%{public}d,consecutiveAmbiguityEpochCount,%{public}.1lf,deltaAz,%{public}.2lf,courseDiffWithPriorSolution,%{public}.2lf,acrossTrack,%{public}.2lf,bestLL,%{private}.7lf,%{private}.7lf
CLMMPED,%{public}.1lf,solutionJumpCheck,solution replacement failed as returned particle has invalid road
CLMMPED,%{public}.1lf,solutionJumpCheck,solution replaced with previous propagated solution,%{public}.2lf,bestLL,%{private}.7lf,%{private}.7lf,newLL,%{private}.7lf,%{private}.7lf
CLMMPED,%{public}.1lf,solutionJumpCheck,solution replacement failed as unable to fillCrumb
CLMMPED,%{public}.1lf,solution jump detected, recomputing without course,solutionDiff,%{public}.2lf
CLMMPED,%{public}.1lf,course,solutionDiff,%{public}.2lf,newSolutionDiff,%{public}.2lf
CLMMPED,%{public}.1lf,filter swapped with local filter without course, solutionDiffCheck
CLMMPED,%{public}.1lf,filter swapped with local filter without course, courseDiffCheck
CLMMPED,%{public}.1lf,solution jump detected,routeHints are not used
CLMMPED,%{public}.1lf,solution jump detected,verifying routeHints,courseDiffBetweenPriorSolution,%{public}.2lf,distanceDiffBetweenPriorSolution,%{public}.2lf
CLMMPED,%{public}.1lf,solution jump detected,routeHints are OK, skipping recomputation
CLMMPED,%{public}.1lf,solution jump detected, recomputing without routeHints,solutionDiff,%{public}.2lf
CLMMPED,%{public}.1lf,routeHints,solutionDiff,%{public}.2lf,newSolutionDiff,%{public}.2lf
CLMMPED,%{public}.1lf,filter swapped with local filter without routeHints
CLMMPED,%{public}.1lf,unexpected, negtive dT,%{public}.1lf
#Warning,CLMMPED,%{public}.1lf,Position jump,%{public}.1lf,dT,%{public}.1lf
CLMMPED,%{public}.1lf,predictionAndUpdate, distance,%{public}.1lf,distBasedOnSpeed,%{public}.1lf,distBasedOnPos,%{public}.1lf
CLMMPED,%{public}.1lf,Unexpected, prior or current snap is valid but bestparticle road is null
CLMMPED,%{public}.1lf,lat,%{private}.8lf,lon,%{private}.8lf,alt,%{public}.2lf,course,%{public}.1lf,snapLat,%{private}.8lf,snapLon,%{private}.8lf,snapCourse,%{public}.1lf,horizontalError,%{public}.2lf,hunc,%{public}.2lf,ratio,%{public}.2lf
CLMMPED,%{public}.1lf,moveParticle,failed,%{public}s,moveDistance,%{public}.1lf
CLMMPED,%{public}.1lf, no DOT,%{public}s,location or course diverged
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, moveParticle
CLMMPED,%{public}.1lf,moveParticle,moveOnRoad returned false,roadID,%{private}lld,projection,%{public}.3lf,fwd,%{public}d,moveDistance,%{public}.2lf
CLMMPED,%{public}.1lf,moveParticle,null road
CLMMPED,%{public}.1lf,moveParticle,unexpected particle with snapLat == snapLon == 0
CLMMPED,%{public}.1lf,moveParticle,invalidProjection,%{public}.3lf,roadID,%{private}lld
CLMMPED,%{public}.1lf,no DOT,too close to %{public}s intersection,dist,%{public}.2lf,speed,%{public}.2lf
CLMMPED,%{public}.1lf,moveParticle failed for %{public}s particle,distance,%{public}.1lf
CLMMPED,%{public}.1lf,no DOT, too close to a %{public}s road with large direction change
CLMMPED,Unexpected,invalid geometry pointer, getRoadsAtIntersection
CLMMPED,Unexpected,null road, getRoadsAtIntersection
CLMMPED,Unexpected,invalid geometry pointer, findMultiOutboundIntersection
CLMMPED,%{public}.1lf,harshDigitizationCheck skipped,signalEnv,%{public}d
CLMMPED,%{public}.1lf,harshDigitizationCheck skipped,courseDiff,%{public}.3lf,acrossTrack,%{public}.3lf
CLMMPED,%{public}.1lf,Unexpected,invalid road pointer,isHarshDigitizationCaseAtTurns
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer,isHarshDigitizationCaseAtTurns
CLMMPED,%{public}.1lf,findMultiOutboundIntersection returned false, searching for next connected candidates
CLMMPED,%{public}.1lf,findMultiOutboundIntersection returned false, searching for prior connected candidates
CLMMPED,%{public}.1lf,harshDigitizationCheck,road,%{private}lld,isApproachingMulti,%{public}d,justCrossedMulti,%{public}d,nextList,%{public}lu,priorList,%{public}lu,threshold,%{public}.1lf,roadWidth,%{public}.1lf,courseDiff,%{public}.3lf,AT,%{public}.3lf,harshAmb,%{public}d
CLMMPED,%{public}.1lf,isSolutionAmbiguous check,already ambiguous
CLMMPED,%{public}.1lf,AverageVarianceFactor,count,%{public}d,vf,%{public}.4lf,avf,%{public}.4lf,avfBuffer,%{public}.4lf,avfBufferCnt,%{public}zu,avfBuffer60,%{public}.4lf,avfBuffer30,%{public}.4lfisUsable,%{public}d,deltaAz,%{public}.2lf,fabsAT,%{public}.2lf,threshold,%{public}.2lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,routeHintsAvailable,1
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,isSnapUsable,0
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,sameAsRawGPS,1
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,isHarshDigitizationCaseAtTurns,1
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1, previous solution was ambiguous and AT,%{public}.1lf,is over scaled threshold,%{public}.1lf,consecutiveAmbCnt,%{public}1lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,averageVarianceFactor,count,%{public}d,vf,%{public}.4lf,avf,%{public}.4lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,lowAcrossTrack,%{public}.1lf,threshold,%{public}.2lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,0,overridden based on course matching,%{public}.2lf,AT,%{public}.2lf,hunc,%{public}.2lf,threshold,%{public}.2lf
CLMMPED,%{public}.1lf,skipping building checks for unknown roads,%{public}d
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,fewerThan2Buildings,%{public}d
CLMMPED,%{public}.1lf,isSolutionAmbiguous,-1,buildingCount,%{public}d,latitude,%{private}.7lf,longitude,%{private}.7lf,course,%{public}.2lf,rightSideCount,%{public}d,leftSideCount,%{public}d,searchDistance,%{public}.2lf,averageBuildingDirection,%{public}.2lf
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,buildingNotOnBothSides,rightCount,%{public}d,leftCount,%{public}d
CLMMPED,%{public}.1lf,isSolutionAmbiguous,1,buildingOnBothSides but AT too high,rightCount,%{public}d,leftCount,%{public}d,AT,%{public}.1lf,threshold,%{public}.1lf
CLMMPED,%{public}.1lf,initialized called on already intialized filter
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, initialize
CLMMPED,%{public}.1lf,roadsWithinDistance returned false
CLMMPED,%{public}.1lf,roadsWithinDistance returned 0 roads
CLMMPED,%{public}.1lf,Unexpected, NULL road at initialization
CLMMPED,%{public}.1lf,Unexpected,zero particles at initialization
CLMMPED,%{public}.1lf,filter initialized
CLMMPED,%{public}.1lf,allowsNetworkUsage,%{public}d
CLMMPED,match,%{public}.1lf,course invalidated as courseUnc was invalid,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,match,%{public}.1lf,invalidCourseInfoUpdatedUsingPreviousEpochInfo,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,courseInvalidated,particle near multioutbound intersection,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,highCourseUncDataReplacedWithPreviousEpochInfo,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,courseInvalidated,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,courseUncFloorApplied,course,%{public}.2lf,courseUnc,%{public}.2lf
CLMMPED,%{public}.1lf,routeHint,lat,%{private}.8lf,lon,%{private}.8lf,course,%{public}.3lf,rseg,%{private}lld,fwd,%{public}d
CLMMPED,Unexpected,invalid geometry pointer, predict
CLMMPED,%{public}.1lf,predict called with 0 particles
CLMMPED,%{public}.1lf,prediction,%{public}d,NrParticles,%{public}lu,NrPriorIntersectionParticles,%{public}d,NrNewFwdIntersectionParticles,%{public}d,NrNewBiasedToPrior,%{public}d,NrNewBiasedToPriorOppositeDirection,%{public}d,NrNewAmbiguous,%{public}d,numNewRouteParticles,%{public}d
CLMMPED,%{public}.1lf,Unexpected,invalid geometry pointer, generateRouteHint
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,failed as not enough route roads are available
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,route index,%{public}d,is more than number of route roads,%{public}ld
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,routeCourse,%{public}.1lf,is very different than crumb course,%{public}.1lf,rejection,%{public}d
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,routeCourse,%{public}.1lf,is different than crumb course,%{public}.1lf, and rejections are high,rejection,%{public}d
CLMMPED,%{public}.1lf,routeHints,skipping,moveOnRouteRoads meas,routeCourse,%{public}.1lf,is somewhat different than crumb course,%{public}.1lf
CLMMPED,%{public}.1lf,routeHints,no meas,moveOnRouteRoads,course deweighted,unc,%{public}.2lf
CLMMPED,%{public}.1lf,unexpected,routeHints,moving on to next route road,nullptr
CLMMPED,%{public}.1lf,routeHints,moving on to next route road,nextRouteRoadIndex,%{public}d,angleBetweenTwoRoads,%{public}.2lf,length,%{public}.2lf
CLMMPED,%{public}.1lf,routeHints,skipping,moveOnRouteRoads meas,crumb close to intersection and gpsCourse,%{public}.1lf,is matching with next road on route,%{public}.1lf,course,%{public}.1lf,nextCourseDiff,%{public}.1lf,approxCourseOfTurningRoad,%{public}.1lf,turningCourseDiff,%{public}.1lf,courseDiff,%{public}.1lf
CLMMPED,%{public}.1lf,routeHints,meas,moveOnRouteRoads,ll,%{private}.7lf,%{private}.7lf,course,%{public}.3lf,hunc,%{public}.3lf,cunc,%{public}.3lf,count,%{public}lu
CLMMPED,%{public}.1lf,routeHints, no meas, projection,routeCourse,%{public}.1lf,is very different than crumb course,%{public}.1lf,rejection,%{public}d
CLMMPED,%{public}.1lf,routeHints,meas,projection,ll,%{private}.7lf,%{private}.7lf,course,%{public}.3lf,hunc,%{public}.3lf,cunc,%{public}.3lf,count,%{public}lu,confidence,%{public}.4lf
CLMMPED,%{public}.1lf,routeHints,duplicate measurement check,measurementGood,%{public}d,vector,%{public}lu
CLMMPED,%{public}.1lf,routeHints,jump in route hint measurement,%{public}.3lf,rejecting
CLMMPED,Unexpected,invalid geometry pointer, multiOutboundHelper
CLMMPED,%{public}.1lf,evaluateMatch,oldOffRoadCount,fabsDeltaAz,%{public}.2lf,priorFabsDeltaAz,%{public}.2lf,atIntersection,%{public}d,varFactor,%{public}.2lf,acrossTrack,%{public}.2lf,isAmbiguous,%{public}d
CLMMPED,%{public}.1lf,varFactorCheck,oldOffRoadCount,%{public}d,newOffRoadCount,%{public}d
CLMMPED,%{public}.1lf,courseCheck,oldOffRoadCount,%{public}d,newOffRoadCount,%{public}d
CLMMPED,%{public}.1lf,stopSnapping,distance > %{public}.0lfm,Intersection,%{public}d
CLMMPED,%{public}.1lf,jumpDistanceCheck,%{public}.1lf,expectedDistanceTravelled,%{public}.1lf,oldOffRoadCount,%{public}d,newOffRoadCount,%{public}d
CLMMPED,%{public}.1lf,evalauteMatch,offRoadCount,%{public}d,projection,%{public}.2lf,delta,%{public}d
CLMMPED,%{public}.1lf,stopSnapping,varFactor,%{public}.1lf,threshold,%{public}.1lf
CLMMPED,%{public}.1lf,stopSnapping,offRoadCount,%{public}d,threshold,%{public}d
CLMMPED,%{public}.1lf,reseting offRoadCount,%{public}d
CLMMPED,%{public}.1lf,startSnapping,shouldStartSnappingOnfrc,frc,%{public}d,name,%{public}s,using tighter-threshold
CLMMPED,%{public}.1lf,startSnapping criteria,distance2,%{public}.1lf,acrossTrack,%{public}.2lf,drms,%{public}.1lf,currentVF,%{public}.3lf,prioVF{public},%.3lf,curSpeed,%{public}.2lf,priorSpeed,%{public}.2lf,curCourse,%{public}.2lf,priorCourse,%{public}.2lf,fabsDeltaAz,%{public}.2lf,priorFabsDeltaAz,%{public}.2lf
CLMMPED,%{public}.1lf,startSnapping
CLMMPED,%{public}.1lf,reset,snap coordinate is null island
CLMMPED,%{public}.1lf,reset,solution hopping detected
CLMMPED,%{public}.1lf,Reseeding due to varFactor,%{public}.1lf,max,%{public}.1lf
CLMMPED,%{public}.1lf,Reseeding as unable to match,max,%{public}d
CLMMPED,%{public}.1lf,accumulated snap distance is ~0, %{public}.3lf
CLMMPED,%{public}.1lf,Reseeding due to stuck at dead-end while observations move away, ratioDist, %{public}.3lf
CLMMPED,%{public}.1lf,hopping check,connecting roads,%{public}d, current road %{private}lld,prior road %{private}lld
CLMMPED,%{public}.1lf,hopping check,prior road, %{private}lld, connected to the incoming road, %{private}lld, of the current solution road, %{private}lld
CLMMPED,%{public}.1lf,hopping between roads detected,priorfullSnapCourse,%{public}.1lf,currentFullSnapCourse,%{public}.1lf,priorId,%{private}llu,currentId,%{private}llu
CLMMPED,%{public}.1lf,roadWithAdustment,number of particles are 0
CLMMPED,%{public}.1lf,roadWithAdustment,snap invalid or frc = 9
CLMMPED,%{public}.1lf,roadWithAdustment,road is nullptr
CLMMPED,%{public}.1lf,frc,%{public}d,oneway,%{public}d,roadWidth,%{public}.1lf,acrossTrack,%{public}.3lf
CLMMPED,%{public}.1lf,Unexpected,invalid bestParticle road,DOT
CLMMPED,%{public}.1lf,Unexpected,invalid timeDiff,DOT
CLMMPED,%{public}.1lf,timeDiff too large,DOT
CLMMPED,%{public}.1lf, no DOT, currentCrumb invalid
CLMMPED,%{public}.1lf, no DOT, priorCrumb invalid
CLMMPED,%{public}.1lf, no DOT,feedback interval check
CLMMPED,%{public}.1lf, no DOT, too close to prior intersection,transitiondetected,%{public}d,dist,%{public}.2lf
CLMMPED,%{public}.1lf, no DOT, course not aligned to full snap
CLMMPED,%{public}.1lf, no DOT, priorCrumb location or course diverged
CLMMPED,%{public}.1lf, no DOT, computeSnapCoordinatesFromRawGPSCoordinates lookBehind returned false
CLMMPED,%{public}.1lf, no DOT, predicted point is too close to intersection,dist,%{public}.2lf
CLMMPED,%{public}.1lf, no DOT, current particle within the stopDistanceFromIntersection
CLMMPED,%{public}.1lf,DOT,%{public}.1lf,lat,%{private}.7lf,lon,%{private}.7lf,course,%{public}.1lf,courseUnc,%{public}.1lf,rw,%{public}.1lf,startLat,%{private}.7lf,startLon,%{private}.7lf,length,%{public}.1lf,speed,%{public}.3lf,isOneWay,%{public}d,isRailWay,%{public}d,isTunnel,%{public}d,isBridge,%{public}d,distFromIntersection,%{public}.1lf,isFreeway,%{public}d,machContTime,%{public}.3lf,lookBehindDist,%{public}.2lf,type,%{public}d
CLMM,getHeadingForSegment,stored bearing value unavailble,had to be calculated,%{private}lld,index,%{public}d
CLMM,%{public}.1lf, no DOT, course is not aligned
CLMM,%{public}.1lf, across track too large, not suitable DOT assistance
CLMM,%{public}.1lf, along track too large, not suitable DOT assistance
CLMM,%{public}.1lf,routehint timed out or empty, segments,%{public}lu
CLMM,%{public}.1lf,Unexpected,invalid geometry pointer, determineRouteHintRoadVectors
CLMM,%{public}.1lf,routeHint road search,isConnectivityGood,poorConnectivity caused by radar:58817500,%{public}lu,file radar if 58817500 is already fixed
CLMM,%{public}.1lf,routeHint road search,getConnectedRouteSegments,poorConnectivity caused by radar:58817500,%{public}lu,file radar if 58817500 is already fixed
CLMM,%{public}.1lf,routeHints,search, roadsWithinDistance returned false
CLMM,%{public}.1lf,Unexpected, empty road list
CLMM,%{public}.1lf,routeHints,road search, invalid data encountered, same start and end route coords, not using routehints,sLat,%{private}.7lf,sLon,%{private}.7lf,eLat,%{private}.7lf,eLon,%{private}.7lf
CLMM,%{public}.1lf,routeHints,road search,road already present,%{private}lld
CLMM,%{public}.1lf,routeHints,road search,roadList,%{public}lu,routeRoads,%{public}lu,routeID,%{private}lld,matched,%{private}lld
CLMM,%{public}.1lf,routeHints,road search,road already present,start,%{private}lld
CLMM,%{public}.1lf,routeHints,road search,road already present,stop,%{private}lld
#Warning,CLMM,%{public}.1lf,routeHints,unable to find routeHints road,segments,%{public}lu,roadList,%{public}lu
#Warning CLMM, findClosestPointOnRoad returned false
CLMM,findClosestPointOnRoad,CoordinateCount is <= 1
#wifitilecentroids, read cache, %{public}d, in_tiles, %{public}d, not_in_tiles, %{public}d, not_found, %{public}d
{"msg%{public}.0s":"expecting results to correspond one-to-one with input", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#wifitilecentroids, search tiles, searched, %{public}d, found, %{public}d
#wifitilecentroids, write to cache, new size, %{public}du / %{public}du
#wifitilecentroids, clear cache
CLMM,RouteHints,%s
CLMM,%.3lf,RouteHints received without proper connections
CLMM,%.3lf,RouteHints received without proper connections,changing segments from %lu,to,%lu
Returning %{public}zu APs
Scrubbing done,pre,%{public}zu,post,%{public}zu
STARK,SpeedTO,isOffsetValid,%d,offsetUncSecs,%.9g,filteredOffsetSecs,%.4lf,machTime,%.4lf,vehicleTime,%.4lf
STARK,GyroTO,isOffsetValid,%d,offsetUncSecs,%.9g,filteredOffsetSecs,%.4lf,machTime,%.4lf,vehicleTime,%.4lf
Removing an alarm which has not been added.
#Warning Invalid trigger.trigger,%u
{"msg%{public}.0s":"ActivityAlarm", "BundleID":%{private, location:escape_only}s, "Executable":%{private, location:escape_only}s, "AlarmTrigger":%{private}lu, "AlarmDuration":%{private}d, "Action":%{private, location:escape_only}s}
enabling wifi data source
received wifi scan notification
received wifi scan cache notification
{"msg%{public}.0s":"submit wifi scan data", "mac":%{private, location:escape_only}s, "channel":%{private}d, "rssi":%{private}d, "scan time stamp_s":"%{private}.09f"}
buffered %zu samples, submitted %zu samples, between %f and %f
Unable to serialize dictionary data to json stream. Error: %@
Unable to write logs to json file! Exception: %{private}@
trigger,%d,duration,%f
{"msg%{public}.0s":"Unable to insert record!", "startTime":"%{public}f", "endTime":"%{public}f", "percentNoObservation":"%{private}f", "percentDyskinesiaLikely":"%{private}f", "percentTremorAbsent":"%{private}f", "percentTremorSlight":"%{private}f", "percentTremorMild":"%{private}f", "percentTremorModerate":"%{private}f", "percentTremorStrong":"%{private}f"}
Unknown registration requested: %{public}d
Unknown unregistration requested: %{public}d
Attempted to re-register for daemon settings while already registered
#Warning Attempted to unregister for daemon settings while not registered
Attempted to re-register for AppleAccountDidChange while already registered
#Warning Attempted to unregister for AppleAccountDidChange while not registered
{"msg%{public}.0s":"Assertion failed,fGEOMapFeatureAccess==nil", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
CLMM,Watch,Allowing maps stale data
#Warning,CLMMPED,provideCacheHint reported error:%{public}lld (%{public}@) "%{private}@"
#Warning,CLMMPED,roadsWithinDistanceLite returned false
#Warning,CLMMPED,roadsWithinDistance returned nullptr
#Warning,CLMMPED,findClosestPointOnRoad returned false
#Warning,CLMMPED,interpolateOnRoad returned false
#Warning,CLMMPED, query failed (roadsWithinDistance)
#Warning,CLMMPED, findAllDigitizedRoads returned false
CLGeoMapFeatureAccessGeometryPedestrian::roadsAtIntersection - Code not implemented
#Warning,CLMMPED, roadsWithinDistance returned false
#Warning,CLMMPED, roadsWithinDistance returned false, expanded search
CLMM,%.1lf,Unexpected,RoadConnectionsEntry could not be created
CLMM,%{public}.2lf,CLGeoMapFeatureAccessGeometryPedestrian,ConnectedRoads found 0 roads, %{private}lld, totalResults,%{public}lu,roadStartLL,%{private}.7lf,%{private}.7lf,roadEndLL,%{private}.7lf,%{private}.7lf,searchCoordinate,%{private}.7lf,%{private}.7lf
#Warning,CLMMPED,input road is nullptr
#Warning,CLMMPED, road length is 0.0
#Warning,CLMMPED,GEOMapFeatureRoad id,%{private}lld,has less than two coordinate (moveOnRoadInternal),%{public}ld
#Warning,CLMMPED,moveOnRoad,findAllDigitizedRoads returned false
#Warning CLMMPED,moveOnRoadInternal,interpolateProjections returned false
#Warning CLMM,interpolateOnRoad,interpolateProjections returned false
#Warning CLMMPED,moveOnRouteRoads,interpolateProjections returned false
CLMMPED,%.3lf, no more route roads available to cover the distance travelled,index,%d,size,%lu
CLMMPED,%.3lf, unexpectedly reached to the end of routeRoadList
#Warning CLMM,GEOMapFeatureAccessRequest reported error:%{public}lld (%{public}@) "%{private}@"
#Warning CLMM, GeoMapFeatureAccess query timed out
CLMM, NULL road
CLMM,interpolateProjections,CoordinateCount is 0
CLMM,interpolateProjections,inconsistent array size
CLMM,interpolateProjections,Could not interpolate, incorrect coordinateCount
CLMM,interpolateProjections,Could not interpolate to intended projection
CLMM,GEOMapFeatureRoad is null
#Warning CLMM, GEOMapFeatureRoad id,%{private}lld,has less than two coordinate,%{public}ld
CLMM,getSegmentLengthsAndHeading,CoordinateCount is 0
CLMM,getSegmentLengthsAndHeading,coordArray is nullptr
CLMM,%{public}.1lf,ClearStoredStaleConnections,szBefore,%{public}d,szAfter,%{public}d
#ADR,registerIDSBatchIDQueryActivity,Invalid interval value %{public}lld, reset to 0
#ADR,registerIDSBatchIDQueryActivity,Invalid interval value %{public}lld, reset to kIDSQueryInterval value
#ADR,#registerIDSBatchIDQueryActivity,registering IDS Query activity,interval,%{public}lld,gracePeriod,%{public}lld
#ADR,registerIDSBatchIDQueryActivity,IDS query activity handler triggered with unexpected state %{public}d
#ADR,registerIDSBatchIDQueryActivity,IDS query activity handler triggered
#ADR,unregistering IDS batch query activity
#ADR,issueIDSBatchQuery,MCProfileConnection class unavailable or Health Data Submission not allowed
#ADR,issueIDSBatchQuery,the device is neither a phone nor a tinker supported watch
#ADR,handleIDSBatchIDQueryResponse,EmergencyContactsMetric nil object
#ADR,cleanupEmergencyContactsMetrics,fEmergencyContactsMetric is nil
#ADR,handlePhoneNumberChange,received phone number update for inst %{public}d
#ADR,handleCompanionNumberChange,companion phone number changed to %{private}s
#ADR,handleCommTypeChange,comm type changed to %{public}s
#ADR,handleTriggerTypeChange,call trigger type changed to %{public}s
#ADR,sendAdr,required input is missing
{"msg%{public}.0s":"#ADR,sendAdr,no valid partner certs"}
#ADR,sendAdr,failed to serialize ADR data dict into JSON
#ADR,sendAdr,encrypted ADR data and/or key are nil
#ADR,sendAdr,sending ADR for native number
#ADR,sendAdr,native number is empty, not sending ADR
#ADR,sendAdr,sending ADR for companion number
#ADR,sendAdr,companion number is empty or device supports alternate account, not sending ADR
{"msg%{public}.0s":"#ADR,createAdrInternalDict", "sim":%{public}d, "rat":%{public}d, "sim_bundle_id":%{public, location:escape_only}s, "sim_country":%{public, location:escape_only}s, "operator_bundle_id":%{public, location:escape_only}s, "operator_country":%{public, location:escape_only}s, "release_type":%{public}d, "product_type":%{private, location:escape_only}s, "trigger_type":%{public}d, "dsa_availability":%{private}d, "did_dsa_change_within_call_count":%{private}d}
{"msg%{public}.0s":"#ADR,createCallInfoDict", "tel":%{private, location:escape_only}s, "tel_alt":%{private, location:escape_only}s, "medium":%{public, location:escape_only}s, "trigger_type":%{public, location:escape_only}s, "device_language":%{public, location:escape_only}s}
#ADR,createCallerLocationDict,ERA disabled
#ADR,createCallerLocationDict,no data available for caller location dict so not sending
#ADR,createCallerLocationDict,invalid placemark
#ADR,createCallerLocationDict,failed to create location dict
{"msg%{public}.0s":"#ADR,createCallerLocationDict,created caller location dict", "label":%{private, location:escape_only}s, "placeType":%{public, location:escape_only}s, "mecardaddress":%{private, location:escape_only}s, "name":%{private, location:escape_only}s}
#ADR,createAESEncryptedDataAndKey,data and/or key pointer are nil
#ADR,createAESEncryptedDataAndKey,unsupported AES key length,%{public}d
#ADR,createAESEncryptedDataAndKey,failed to generate AES key,error,%{public}d
#ADR,createAESEncryptedDataAndKey,failed to create AES encrypted data
#ADR,createAESEncryptedDataAndKey,successfully created AES key and encrypted data
#ADR,createAESEncryptedData,data and/or key pointer are nil
#ADR,createAESEncryptedData,unsupported AES key length,%{public}d
#ADR,createAESEncryptedData,failed to generate AES IV,error,%{public}d
#ADR,createAESEncryptedData,failed to encrypt data,error,%{public}d
#ADR,createAESEncryptedData,successfully encrypted data
#ADR,createWrappedKeyArray,hash of encrypted ADR data or key is nil so not computing wrapped keys
#ADR,createWrappedKeyArray,unable to convert cert data to SecCertificateRef for partner %{private}s
#ADR,createWrappedKeyArray,couldn't extract partner key from cert so not creating wrapping key,partner,%{public}s
#ADR,createWrappedKeyArray,failed to encrypt key for partner,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s
#ADR,createWrappedKeyArray,failed to create DER data for partner public key,partner,%{public}s,error code,%{public}d,domain,%{public}s,reason,%{public}s
#ADR,createAdrDict,missing required info for forming ADR POST dict
{"msg%{public}.0s":"#ADR,createAdrDict", "phone number":%{private, location:escape_only}s, "session start time":%{public}lld, "medium":%{public, location:escape_only}s, "encrypt time":%{public}lld}
#ADR,postAdr,failed to serialize ADR dict into JSON
#ADR,postADR,missing NSURLSession
{"msg%{public}.0s":"#ADR,postADR,sending ADR POST", "URL":%{private, location:escape_only}s, "length":%{private}lld}
#ADR,postADR,received response for %{public}s number
#ADR,EmergencyContactsMetric,ADR pointer is null
#ADR,EmergencyContactsMetric,medicalID unavailable or emergency contacts within medicalID unavailable
#ADR,clearIDSQueryTimeout,timer cleared
#ADR,clearIDSQueryTimeout,no timer exists
#ADR,handleIDSBatchIDQueryResponse,query response is Empty. Early return
#ADR,handleIDSBatchIDQueryResponse,Early return,error:%{public}@
#ADR,handleIDSBatchIDQueryResponse,Received %{public}u responses for service %{public}s
#ADR,handleIDSBatchIDQueryResponse,Number %{private}s supports service %{public}s
#ADR,handleIDSBatchIDQueryResponse,Number %{private}s does not support service %{public}s
#ADR,handleIDSBatchIDQueryResponse,Unhandled status response for number %{private}s for service %{public}s
#ADR,submitIDSQueryCAStats,adr pointer is nil
CL: CLPolicyProactiveExternal::onProactiveHarvestingProviderNotification
{"msg%{public}.0s":"CLPolicyProactiveExternal::onProactiveHarvestingProviderNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Warning Overriding VerboseRangeLoggingEnabled,%{private}d
iB: %{private}s
Unable to create directory. There is a file with the same name.
Directory creation failed: %@
File creation failed
iB: No access to DB
Cleaning DB: invalid proximity zone for fence, %{private}s
iB: Adding fence,%{private}s
Error, invalid proximity zone for fence,%{private}s
#Warning Unable to bind SQL for adding fence,%{private}s
iB: Removing fence,%{private}s
#Warning Unable to bind SQL for removing fence,%{private}s
iB: Removing all fences for bundle,%{private}s
#Warning Unable to bind SQL for removing all fences for bundle,%{private}s
iB: Retrieving all fences
Unable to get fences from the database
An error was encountered when retrieving fences from the database
iB: Retrieving fences for bundle,%{private}s
Unable to bind SQL for retrieving fences for bundle,%{private}s
Unable to get fences from database for bundle,%{private}s
An error was encountered when retrieving fences from the database for bundle,%{private}s
iB: Retrieving fence,%{private}s/%{private}s
Unable to bind SQL for retrieving fence,[%{private}s]/%{private}s/%{private}s
Unable to get fence,[%{private}s]/%{private}s/%{private}s, from database
Unable to get the fence count for bundle,%{private}s
iB: addOnBehalfBundleIdColumnIfNotExists
{"msg%{public}.0s":"iB: addOnBehalfBundleIdColumnIfNotExists, table doesn't even exist"}
{"msg%{public}.0s":"iB: addOnBehalfBundleIdColumnIfNotExists, OnBehalfBundleId already exists"}
{"msg%{public}.0s":"iB: Re-create primary key to include OnBehalfBundleId"}
Unable to initialize authorization manager with airplane mode status
{"msg%{public}.0s":"iB: Initializing authorization manager", "exceptions":%{public}d}
Unable to get fences for bundle,%{private}s. Fence,%{private}s, will not be added
#Warning Bundle,%{public}s, exceeds its fence limit,%{private}d. Fence,%{private}s, will not be added
iB: Added fence,%{private}s, to the database
Unable to add fence,%{private}s, to the database
iB: Removed fence,%{private}s, from the database
#Warning Unable to remove fence,%{private}s, from the database
{"msg%{public}.0s":"@iB: Received Bluetooth LE power", "BT power":%{public}hhd}
iB: Received uninstall for bundle,%{private}s
iB: Received authorization for bundle,%{private}s
iB: Received location services status,%{public}d
{"msg%{public}.0s":"iB: Reset authorization by toggling beacon fences"}
iB: Received airplane status,%{public}d
Unable to update authorization manager with airplane mode status
{"msg%{public}.0s":"iB: isBundleAuthorized", "key":%{public, location:escape_only}s, "authorized":%{public}hhd}
Empty bundle identifier should not be passed in here
iB: Setting icon state,%{public}d, for bundle,%{public}s
{"msg%{public}.0s":"iB: Unable to get fences from database", "bundle":%{public, location:escape_only}s}
Unable to remove all fences from the database for bundle,%{public}s
{"msg%{public}.0s":"iB: Removed all fences for bundle", "bundle":%{public, location:escape_only}s}
#Warning Unable to retrieve all fences from the database
#Warning No fences will be resumed due to exception,%{public}d
{"msg%{public}.0s":"iB: Resuming all fences", "numRegions":%{public}lu, "numBundlePairs":%{public}lu}
Unable to get fence,[%{public}s]/%{public}s/%{private}s, from the database
#Warning Bundle(s) not authorized, fence,[%{public}s]/%{public}s/%{private}s, will not be resumed
#Warning Fence,[%{public}s]/%{public}s/%{private}s, will not be resumed due to exception,%{public}d
iB: Resuming fence,[%{public}s]/%{public}s/%{private}s
Unable to get all fences from database
{"msg%{public}.0s":"iB: Suspending fences", "numRegions":%{public}lu, "numBundles":%{public}lu}
Unable to get fences from database for bundle,%{public}s
iB: Resuming fences,%{public}lu, for bundle,%{public}s
{"msg%{public}.0s":"iB: Suspending fences", "reason":%{private, location:escape_only}s, "numRegions":%{public}lu, "bundle":%{public, location:escape_only}s}
iB: Adding exception,%{public}#x, to stored exceptions %{public}#x
iB: Removing exception,%{public}#x, from stored exceptions %{public}#x
CL: CLBeaconFenceAuthorizationManager::onBeaconNotification
{"msg%{public}.0s":"CLBeaconFenceAuthorizationManager::onBeaconNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLBeaconFenceAuthorizationManager::onClientManagerNotification
{"msg%{public}.0s":"CLBeaconFenceAuthorizationManager::onClientManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLBeaconFenceAuthorizationManager::onDaemonStatusNotification
{"msg%{public}.0s":"CLBeaconFenceAuthorizationManager::onDaemonStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"iB: Registered regions for ranging", "numRegions":%{public}lu, "totalRegions":%{public}lu}
Unable to register with base-class
{"msg%{public}.0s":"iB: Unregistered regions from ranging", "numRegions":%{public}lu, "totalRegions":%{public}lu}
#Warning Unable to retrieve registration info for client,%{public}d
{"msg%{public}.0s":"iB: Range manager has lost its last connection"}
iB: Received Bluetooth LE power,%{public}d
{"msg%{public}.0s":"iB: Received proximity scan, updating beacon cache with devices", "samples":%{public}lu, "totalCached":%{public}lu}
{"msg%{public}.0s":"iB: Caching new beacon identifier", "identifier":%{private, location:escape_only}s, "uuid":%{private, location:escape_only}s, "major":%{private}d, "minor":%{private}d, "mask":%{public}d}
{"msg%{public}.0s":"iB: Removed expired beacons", "numExpired":%{public}d, "totalCached":%{public}lu}
iB: Notifying region proximityUUID,'%{private}s', major,%{private}d, minor,%{private}d, mask,%{public}d with beacons,%{public}zu
iB: Received activity update of activity,%{private}d
#Warning Unexpected notification %{public}d
{"msg%{public}.0s":"iB: Starting range manager", "totalRegions":%{public}lu}
{"msg%{public}.0s":"iB: Stopping range manager", "totalRegions":%{public}lu}
iB: Starting the manager if there's an interest in ranging
iB: There's no interest in ranging, the manager wont be started
iB: The manager is already started
iB: Stopping the manager if there's no interest in ranging
iB: There's an interest in ranging, the manager wont be stopped
iB:The manager is already stopped
iB: Removing exception,%{public}#x, from stored exceptions %{public}#x.
CL: CLBTLERangeManagerConcrete::onBeaconNotification
{"msg%{public}.0s":"CLBTLERangeManagerConcrete::onBeaconNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLBTLERangeManagerConcrete::onMotionStateNotification
{"msg%{public}.0s":"CLBTLERangeManagerConcrete::onMotionStateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLMM,%{public}s,trip,%{public}lld,T,%{public}.1lf,machT,%{public}.2lf,contT,%{public}.2lf,gpsTMs,%{public}d,%{public}d,LL,%{private}.7lf,%{private}.7lf,hunc,%{public}.1lf,alt,%{public}.1lf,vunc,%{public}.1lf,crse,%{public}.1lf,crseUnc,%{public}.1lf,spdKph,%{public}.3lf,spdUncMps,%{public}.1lf,a95,%{public}.1lf,b95,%{public}.1lf,theta,%{public}.1lf,snapLL,%{private}.7lf,%{private}.7lf,snapCrse,%{public}.1lf,fSnapLL,%{private}.7lf,%{private}.7lf,fSnapCrse,%{public}.1lf,pSnapLL,%{private}.7lf,%{private}.7lf,rwSnapLL,%{private}.7lf,%{private}.7lf,rwSnapOfstLL,%{private}.7lf,%{private}.7lf,rwFSnapOfstLL,%{private}.7lf,%{private}.7lf,rwLL,%{private}.7lf,%{private}.7lf,score,%{public}.1lf,ratio,%{public}.1lf,varFac,%{public}.7g,deltaAz,%{public}.3lf,alngTrk,%{public}.3lf,acrsTrk,%{public}.3lf,usable,%{public}d,ambiguous,%{public}d,proj,%{public}.3lf,type,%{public}d,rseg,%{private}lld,frc,%{public}d,fow,%{public}d,road,"%{private}s",activity,%{public}d,actConf,%{public}d,static,%{public}d,staticSetAt,%{public}.1lf,mount,%{public}d,fitness,%{public}d,shifted,%{public}d,propagated,%{public}d,rail,%{public}d,bridge,%{public}d,tunnel,%{public}d,favGPS,%{public}d,gnssCont,%{public}d,locationType,%{public}d,lifespan,%{public}.1lf,rawCourse,%{public}.1lf,sigEnv,%{public}d,sigEnvFid,%{public}d
CLMM,%{public}s,T,%{public}.1lf,usable,%{public}d,ambiguous,%{public}d,LL,%{private}.7lf,%{private}.7lf,crse,%{public}.1lf,snapLL,%{private}.7lf,%{private}.7lf,snapCrse,%{public}.1lf,fSnapLL,%{private}.7lf,%{private}.7lf,fSnapCrse,%{public}.1lf,hunc,%{public}.1lf,alt,%{public}.1lf,vunc,%{public}.1lf,crseUnc,%{public}.1lf,spdMps,%{public}.3lf,spdUncMps,%{public}.1lf,a95,%{public}.1lf,b95,%{public}.1lf,theta,%{public}.1lf,shifted,%{public}d,propagated,%{public}d,rail,%{public}d,bridge,%{public}d,tunnel,%{public}d,locationType,%{public}d,sigEnv,%{public}d,sigEnvFid,%{public}d
CLMM, %{public}.1lf, not matching, unable to compute snap from raw positions
CLMM, %{public}.1lf, null island
CLMM, %{public}.1lf, New Snap Coordinates,%s,inSnapLat,%{private}.8lf,inSnapLon,%{private}.8lf,outSnapLat,%{private}.8lf,outSnapLon,%{private}.8lf
%s,%sRun,%0.4f
%s,%sWalk,%0.4f,%sWalk,%0.4f
#TransitMacMonitor: service begin
#TransitMacMonitor: service end
#TransitMacMonitor: transit state changed from, %{public}lu, to, %{public}lu
#TransitMacMonitor: added %{public}d new access point scans, total cache size, %{public}lu
#TransitMacMonitor: no scan history
#TransitMacMonitor: not enough scan history, length, %{public}f
#TransitMacMonitor: transit state, on transit, based on mac, %{private}@, history count, %{public}lu, interval, %{public}f
#TransitMacMonitor: wifi notification, %{public}d
#TransitMacMonitor: received a wifi scan with %{private}lu access points, but we don't have a location to query tiles
#TransitMacMonitor: error fetching from CLTransitMacTileDataProvider, %@
#Warning deltaTime = %0.3f, but most negative allowed is %0.3lf, resetting Integrity Monitor
locationType,integrityPrior,%d,integrityNew,%d
location type,%d,not supported
not reliable or very low reliable,locationType,%d,lat,%.8lf,lon,%.8lf
Location rejected by IM,Reason,disagrees with GPS,location type,%d
Location rejected by IM,Reason,disagrees with high confidence wifi,location type,%d
huncBump,fromHunc,%.1lf,toHunc,%.1lf
Location rejected by IM,Reason,low confidence wifi strongly disagrees with cell,location type,%d
Client registered for notification %d
Client unregistered for notification %d
CLSE,getSignalEnvironment,opening,%{public}s
#Warning,CLSE,getSignalEnvironment,could not open,%{public}s
#Warning,CLSE,getSignalEnvironment,could not read,%{public}s
CLSE,getSignalEnvironment,file has expired - redownload
CLSE,getSignalEnvironment,file version does not match expected
#Warning,CLSE,getSignalEnvironment,latitude,%{private}.9lf,out of range
#Warning,CLSE,getSignalEnvironment,byte index,%{public}d,is larger than the data available in the coarse signal environment binary file
#Warning,CLSE,getSignalEnvironment,invalid coarse signal environment file - unable to get data byte
#Error,CLSE,getSignalEnvironment,unexpected case,potential file corruption
#Warning,CLSE,readSignalEnvHelper,fseek returned non-zero
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - header string
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - version
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - headerLength
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - minLat
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - maxLat
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - binsize
#Warning,CLSE,readSignalEnvHelper,coarse signal environment file is not %{public}f deg by %{public}f deg,spacing unexpected,%{public}f,re-download needed
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - timestamp
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - expiration age
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - data size
#Warning,CLSE,readSignalEnvHelper,invalid CLSE file - crc
#Error,HRSE,is latitude finite,%d,is longitude finite,%d
#Error,HRSE,latitude is beyond the valid range,lat,%{private}.7lf
#Warning,HRSE,getSignalEnvironmentForTile,invalid tile
#Error,HRSE,getSignalEnvironmentForTile,invalid coordinates,lat,%{private}.7lf,lon,%{private}.7lf
#Warning,HRSE,getSignalEnvironmentForTile,cellsize is zero
#Warning,HRSE,getSignalEnvironmentForTile,latitude,%{private}.9lf,lessThanMin,%{private}.9lf
#Warning,HRSE,getSignalEnvironmentForTile,latitude,%{private}.9lf,exceedsMax,%{private}.9lf
#Warning,HRSE,getSignalEnvironmentForTile,longitude,%{private}.9lf,lessThanMin,%{private}.9lf
#Warning,HRSE,getSignalEnvironmentForTile,longitude,%{private}.9lf,exceedsMax,%{private}.9lf
#Warning,HRSE,getSignalEnvironmentForTile,invalid tile - unable to get data byte
HRSE,getSignalEnvironmentForTile,X,%{private}.7lf,Y,%{private}.7lf,x1,%{private}d,y1,%{private}d,iNibble,%{private}d,iByte,%{private}d,iNibbleInByte,%{private}d,typeNibble,%{private}d
#Error,HRSE,getSignalEnvironmentForTile,unexpected signal environment type detected: %{private}d
HRSE,getSignalEnvironmentForTile,hrseType,%{private}d
HRSE,getSignalEnvironment,fForceDownloadHrseTiles, %d
#Error,HRSE,getSignalEnvironment,invalid coordinates,lat,%{private}.7lf,lon,%{private}.7lf
HRSE,getSignalEnvironment,not on the current in-memory tile,lat,%{private}.7lf,lon,%{private}.7lf,minLat,%{private}.7lf,maxLat,%{private}.7lf,minLon,%{private}.7lf,maxLon,%{private}.7lf
HRSE,getSignalEnvironment,tile not available
HRSE,getSignalEnvironment,need to load tile
HRSE,getSignalEnvironment,tile download needed,lat,%{private}.7lf,lon,%{private}.7lf,is file needed,%{public}d,is bad tile,%{public}d
HRSE,getSignalEnvironment,skipping loadTile query,skipCount,%{public}d
HRSE,Tile not loaded yet
HRSE,good to go!
HRSE,lat,%{private}.7lf,lon,%{private}.7lf,hrse,%{private}d
HRSE,loadTile,lat,%{private}.7lf,lon,%{private}.7lf
HRSE,loadTile,CLTilesManager,getTileFile,took,%{public}.1lf
#Warning,HRSE,loadTile,unexpected case,this tile should be on disk,%{public}s
#Error,HRSE,loadTile,remove the corrupted tile from disk,%{public}s
#Error,HRSE,calculateCLHRSE_CRC,indexCrcInBuffer,%{public}zu,exceeds (bufferSize-4) bytes,%{public}zu
#Error,HRSE,readCLHRSETileHeader,fseek returned non-zero
#Error,HRSE,readCLHRSETileHeader,did not synchronize to tile header_string
#Error,HRSE,readCLHRSETileHeader,invalid CLHRSE tile file - header string
#Error,HRSE,readCLHRSETileHeader,invalid CLHRSE tile file - version and headerLength
#Error,HRSE,readCLHRSETileHeader,invalid tile version - expected,%d,got,%d
#Error,HRSE,readCLHRSETileHeader,invalid header length - expected,%d,got,%d
#Error,HRSE,readCLHRSETileHeader,invalid CLHRSE tile file - rest of header
#Warning,HRSE,readCLHRSETileHeader,header.dataSizeBytes != header.nrows * header.ncols
#Error,HRSE,readCLHRSETileHeader,invalid CLHRSE tile file - incorrect headerLength
HRSE,readCLHRSETileHeader,vers,%{private}d,headerLen,%{private}d,compressionType,%{private}d,expirationAge,%{private}d,timestamp,%{private}.1f,nrows,%{private}d,ncols,%{private}d,dataSizeBytes,%{private}d,crc,%{private}d,xllcorner,%{private}.7lf,yllcorner,%{private}.7lf,cellsize,%{private}.7f,buildingMedianHeight,%{private}.7f,buildingMaximumHeight,%{private}.7f
#Error,HRSE,readCLHRSETile,unable to load file,file path, %{public}s,errno, %{public}d
#Error,HRSE,readCLHRSETile,unable to read file header,file path, %{public}s
#Error,HRSE,readCLHRSETile,zero file size,file path, %{public}s
#Error,HRSE,readCLHRSETile,invalid file size,file path, %{public}s
#Error,HRSE,readCLHRSETile,file format not supported,file path, %{public}s
#Error,HRSE,readCLHRSETile,tile is larger than the allowed maximum,file path, %{public}s
#Error,HRSE,readCLHRSETile,fseek returned non-zero,file path, %{public}s
#Error,HRSE,readCLHRSETile,CLCommonSetFileProtectionClass failed
#Error,HRSE,readCLHRSETile,failed to read tile,file path, %{public}s
#Warning,HRSE,readCLHRSETile,calculateCLHRSE_CRC returned false unexpectedly
#Error,HRSE,readCLHRSETile,invalid CLHRSE,crc fail,calculated,%X,received,%X
#Error,HRSE,onAvlFileUpdated,null pointer
HRSE,onAvlFileUpdated,avl download status,NONE
HRSE,onAvlFileUpdated,avl download status,STARTED
HRSE,onAvlFileUpdated,avl download status,COMPLETED
HRSE,onAvlFileUpdated,avl downloaded,%{public}s
#Warning,HRSE,onAvlFileUpdated,Cannot set protection class for HRSE avl file,%{public}s
HRSE,onAvlFileUpdated,avl file decompressed,%{public}s,to,%{public}s
#Warning,HRSE,onAvlFileUpdated,Cannot set protection class for HRSE decompressed avl file,%{public}s
HRSE,onAvlFileUpdated,is availability file valid,%{public}d
#Warning,HRSE,onAvlFileUpdated,avl download status,FAILED
#Warning,HRSE,onAvlFileUpdated,avl download request failed,%{public}s,retryMultiplier,%{public}d
#Warning,HRSE,onAvlFileUpdated,avl download status,%{public}d
HRSE,downloadFileIfNeeded,needAvailability,%{public}d,needTile,%{public}d
HRSE,downloadFileIfNeeded,download availability file
HRSE,downloadFileIfNeeded,corrupted tile, increase download retry interval to %{public}.5lf seconds
HRSE,requestDownload,requesting HRSE tile download,lat,%{private}.7lf,lon,%{private}.7lf
HRSE,allowing download request over cell due to large horizontal uncertainty, uncertainty,%{public}.5lf, uncertainty threshold,%{public}.5lf
HRSE,downloadFileIfNeeded,tile download finished!
#Warning,HRSE,given avl update rate over WiFi is invalid,%{public}.1lf,using default value instead
HRSE,HrseAvlFileUpdatePeriodOverWifi,%{public}.1lf
#Warning,HRSE,given avl update rate over Cell is invalid,%{public}.1lf,using default value instead
HRSE,HrseAvlFileUpdatePeriodOverCell,%{public}.1lf
HRSE, server, %{public}s, overridden, 1
HRSE, server, %{public}s, overridden, 0
HRSE,downloadAvailabilityFile,download request,url,%{public}s,storeTo,%{public}s,retryInterval,%{public}.1lf
#Warning,HRSE,downloadAvailabilityFile,could not setUpdateSource AVL file updater
#Warning,HRSE,downloadAvailabilityFile,could not setUpdateRate AVl file updater
CL: CLHighResolutionSignalEnvironmentDataManager::onAvlFileUpdated
{"msg%{public}.0s":"CLHighResolutionSignalEnvironmentDataManager::onAvlFileUpdated", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLHighResolutionSignalEnvironmentDataManager::onManagerNotification
{"msg%{public}.0s":"CLHighResolutionSignalEnvironmentDataManager::onManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
fVehicleConnectionNotifier is not initialized, skip fetching mostRecentConnection
{"msg%{public}.0s":"networkSettings", "networkHarvestRules":%{private, location:escape_only}@}
Sent unhandled notification 0x%04X (%d)
Received error when fetching LOI at location: %@
CL: CLHarvestControllerExternal::onTelephonyNotification
{"msg%{public}.0s":"CLHarvestControllerExternal::onTelephonyNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLHarvestControllerExternal::onStatusNotification
{"msg%{public}.0s":"CLHarvestControllerExternal::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLHarvestControllerExternal::onManagerNotification
{"msg%{public}.0s":"CLHarvestControllerExternal::onManagerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLHarvestControllerExternal::onDataProtectionNotification
{"msg%{public}.0s":"CLHarvestControllerExternal::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLHarvestControllerExternal::onLocationNotification
{"msg%{public}.0s":"CLHarvestControllerExternal::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLHarvestControllerExternal::onGnssNotification
{"msg%{public}.0s":"CLHarvestControllerExternal::onGnssNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLHarvestControllerExternal::onMotionStateNotification
{"msg%{public}.0s":"CLHarvestControllerExternal::onMotionStateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
IndoorOutdoor,WifiModel,scanRange,%{public}f,distanceTraveled,%{public}f,numAps,%{public}zu,invalidResult,%{public}d,stationaryProbability,%{public}f,wifiRssiModelIndoorProbability,%{public}f
IndoorOutdoor, can't compute percentile on buffer of this size %{public}zu
{"msg%{public}.0s":"#gfc Failed to stop monitoring before dealloc", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#gfc Starting geofence
#gfc Could not start geofence, check authorizations
#gfc Stopping geofence
#gfc Installed region exists at stop workout, uninstalling
#gfc Generating temporary region to uninstall just in case
#gfc Installing fence with radius %f
#gfc Canceling all timers
#gfc Timed out fence monitoring
#gfc Timed out location updates
#gfc Received new location, timestamp %@, time since now %f
#gfc Attempting to install fence
#gfc Exited fence
#gfc Generic failure with error %@
#gfc Monitoring failed with error %@, stopping updates
#gfc Started monitoring
#gfc Determined state %ld
#gfc Received auth update %d
#gfc No longer authorized, stopping geofence
#gfc Scheduling timer with timeout %llu
#gfc Canceling timer
#gfc Timer existed, canceling now
{"msg%{public}.0s":"Invalid registration timer", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
setup configuration timer
_configurationTimerFireInterval %d
Request for configuration already in progress.
Created request for configuration.
init CLKappaServer instance
re-registering with the server
Requesting authorization from server
Error parsing authorization response: %@, error: %@
Server response has no subjectId
Server response has no token
registered device, subject UUID: %{private}@, subject Auth: %{private}@
Error requesting authorization from server
Creating a new server session
Have a HC session; stopping registration timer
Invalid HC URL session
scheduling registration event
{"msg%{public}.0s":"upload precondition violation", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Missing or invalid 'type' in metadata
Uploading collection type %@, trigger %@
Missing or invalid 'start' in metadata
Missing or invalid 'end' in metadata
Missing or invalid 'trigger' in metadata
Error starting HK message, error: %@
Error appending data to HK message, error: %@
Error finalizing HK message, error: %@
Failed to move HK message from %@ to %@, error: %@
Invalid metadata value type for key: %@, val: %@
Called back for %@ with task: %@ and data of length: %lu and id: %@
Called back for %@ with task state %ld: %@ and error: %@ and id: %@
HTTP Response, statusCode: %{public}d, filePath: %@, response: header %@, body %@
called back with request type upload
Removed file after upload attempt, filePath: %@
called back with request type configuration
Download task completed with task: %@ and task id: %lu and location: %@
Error in download task:%@, statusCode: %ld, error: %@
responseDictionary = %@
Unable to parse response for configuration request, error: %@
Received callback for unexpected download task: %{public}@
Got called back for %@
requestType %@ requestURL %@
bad RAT for GSM: %{public}s
bad RAT for SCDMA: %{public}s
bad RAT for CDMA: %{public}s
bad RAT for LTE: %{public}s
bad RAT for NR: %{public}s
CELL_LOC: override to, %s
CELL_LOC: which cell is that, %s
CELL_LOC: sec_key, 0x%016llX
AWD: workout:%d, companion:%d, %s, GPS:%u, HR:%u, Onset:%d, HRUtil:%u, VO2Avail:%d, HRSrc:%d, VO2Cons:%u, PALStat:%d, VO2Stat:%d, loadUtil:%u, strideAvail:%u, walkAvail:%d, runAvail:%d, walkStat:%d, runStat:%d, VO2Grade:%d, idsAvail:%d, defaultUtil:%d, WRHR:%d, PedGPSAvailable:%d, DistTrackUsed:%d, DistTrackInvalidGradient:%d, DistTrackInvalidGain:%d, DistTrackInvalidSpeed:%d, DistTrackInvalidLength:%d, SeshDuration:%d, PedCalibrated:%d, PaceFail:%d, PedMetSourceDiff:%f, PedMetSourceDiff:%f, HrBoundsFail:%d, SeshUp:%d, SeshDown:%d, SeshCaloriesFromGrade:%d, SeshGPSSourcePhone:%d, SeshGPSSourceWatch:%d, ElevationError:%lld, HRSamplesValidMin: %d, HRSamplesValidMax: %d, METSamplesWithRecentHR: %d, METSamplesValidDelta: %d, VO2DeltaPercentage: %d, HRMetPairs: %d
WorkoutElevationFusion,WorkoutType,%d,BaroGood,%d,BaroUnkDEMAgree,%d,DEMBaroUnk,%d,BaroUnkDEMDisagree,%d,BaroUnkNoDEM,%d,DEMBaroBad,%d,None,%d,GPSBaroGood,%d,GPSBaroUnk,%d,GPSBaroBad,%d,GPSUnvailBaroGood,%d,GPSUnvailBaroUnk,%d,GPSUnvailBaroBad,%d
Swimmming: Free:%d, Breast:%d, Butter:%d, Back:%d, Other:%d, Swimming:%d
Auto-pause: Enabled:%d, WillResume:%d, WillPause:%d, ResumeFalse:%d
WorkoutSessionStatistics,isStopAlertEnabled,%d,isStartAlertEnabled,%d,activtyTypeWhenStopDisabled,%d,activityTypeWhenStartDisabled,%d,coarseLocationLat,%lld,coarseLocationLong,%lld,timeSinceLastDetectedStopToWorkoutEnd,%f,numAlertsDetectedStops,%d,numStopAlertRetractions,%d,indoorOutdoorState,%d
%sSubmitted session stats; session length, %f
#Warning HealthKit query error,%ld
#Warning HealthKit Inaccessible error,%ld
Setting otherWorkoutLabel: %d
{"msg%{public}.0s":"SedentaryAlarm, Unable to set update finished handlers", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
SedentaryAlarm, Failed to delete records
#Warning SedentaryAlarm, Time rolled back, deleting records in the future
SedentaryAlarm, Failed to shift records
SedentaryAlarm, Failed to insert record
SedentaryAlarm, Failed to insert record due to failure from reading the most recent entry.
Got unhandled mesage of type %{public}s
Tracking START, %s, %d, %p, %d
Tracking STOP, %s, %d, %p, %d
Error in query request.
%@, %s, %d, %p
%{public}s is enabling power conservative device motion for parallax.
%{public}s is disabling power conservation for parallax.
Device is stationary and Timeout exceeded, turning off device motion gyro heartbeat and bias estimator.
CLPolicyTrip: duration,%.2fs
using trip id %s (previous trip duration %.3fs and gap %.3fs)
WorkoutStopDetected,charging,type,%ld
WorkoutStopDetected,geoFence,type,%ld
Triggering WorkoutStopDetected, currentTime %f, fLastUnknownOrOffTime %f
WorkoutStopDetected,connectedVehicle,type,%ld
WorkoutStopDetected,wrist,type,%ld
WorkoutStopDetected,vehicleSpeedConstrainedArm,type,%ld,constrainedState,%d
Failed to get constrainedArm state
WorkoutStopDetected,type,%ld,stopReason,%d,stopTimestamp,%f
CLWorkoutStopDetector,invalid generic workout label received,%lu
CLWorkoutStopDetector::selectModel,type,%{public}ld,location,%{public}ld,startType,%{public}ld
CLWorkoutStopDetector,workout type did not change,not updating models,currentTypeWithLocation,%{public}ld,newTypeWithLocation,%{public}ld
CLWorkoutStopDetector::selectModel,workoutType,%ld,locationType,%ld,typeWithLocation,%ld
{"msg%{public}.0s":"missing completion handler", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Classifier finished setup"}
{"msg%{public}.0s":"On wrist status changed", "status":%{private}d}
{"msg%{public}.0s":"On wrist status did not change", "status":%{private}d}
{"msg%{public}.0s":"Wrist State History should always be guaranteed to be non-empty.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"On charger status changed", "status":%{private}d}
{"msg%{public}.0s":"On charger status did not change", "status":%{private}d}
{"msg%{public}.0s":"Lock State History should always be guaranteed to be non-empty.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Canceling alert because watch goes off-wrist after impact", "timeOfImpact":"%{private}f"}
{"msg%{public}.0s":"Canceling alert because watch was off-wrist before impact", "timeOfImpact":"%{private}f"}
{"msg%{public}.0s":"Canceling alert because watch was locked and had no motion before impact", "timeOfImpact":"%{private}f"}
{"msg%{public}.0s":"Checking impact against charger status", "status":%{private}d, "duration":"%{private}f"}
Input, HR = %.8f, timestamp = %.8lf, starttime = %.8lf, source = %d, interpolation = %d, srcName = %s
Input, Odometer, time stamp, %.8lf, distance, %.8f, GPS altitude, %.8lf, estimated speed(m/s), %.8lf, odometer, %.8lf, accuracy, %.8lf, speed accuracy, %.8lf, timestampGps, %.8lf, rawSpeed, %.8f, srcName, %s
Input, Elevation, ready at time, %.2f, no data point
Input, Elevation, not ready at time, %.2f 
Input, Elevation, ready at time, %.2f, nearest data point at time, %.2f
Fitness Machine datum,startTime,%.3f,elapsedTime,%.3f,calories,%f,distance,%f,elevationAscended,%f,strideCount,%ld,strokeCount,%ld,floors,%ld,speed,%f,cadence,%f,power,%f,incline,%f,resistance,%f,verticalSpeed,%f
Calorie Model, Skiing Compendium METS, METS, %f
tiles defaults applied, maxTileAccessAge, %.0f, maxTileCount, %du
#tilesearch, num tiles, %{public}d
{"msg%{public}.0s":"expecting mac to be in intermediate_results", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
expecting equal length, input, %{public}lu, output, %{public}lu
{"msg%{public}.0s":"input-output lengths are not equal", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
@TileSearch, wifi, use ALS results for location hint
tile header missing from returned mac, x, %{private}d, y, %{private}d
@TileSearch, wifi, results, searched, %{public}d, in_tiles, %{public}d, ALS, %{public}d
No Mac addresses found in neighbor list, will search remaining tiles
{"msg%{public}.0s":"Fence key vector must have content", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
@WifiChannel, surroundingWifiBand, %d, # of aps on band, %lu
@WifiAps, dbadd, %{public}lu, was, %{public}u, now, %{public}u, aps, %{public}lu
sqlite error, %{private}s
{"msg%{public}.0s":"CLWifiAccessPointLocationService::saveWifiTileAccessPointEntries", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "now_s":"%{public}.09f"}
no sqlite connection, %{private}s
memory mapped error, %{private}s
{"msg%{public}.0s":"Invalid tile type", "tileType":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
attempted to update timestamp for tile that does not exist, x, %{private}d, y, %{private}d
{"msg%{public}.0s":"runtime error while updating access timestamps", "error":%{private, location:escape_only}s}
{"msg%{public}.0s":"no database connection while updating timestamps", "error":%{private, location:escape_only}s}
{"msg%{public}.0s":"sqlite error updating access timestamps", "error":%{private, location:escape_only}s}
#warning, tile does not exists to query num inputs, x, %{private}d, y, %{private}d
failed to establish a valid database connection, expect wifi positioning accuracy to be significantly degraded
{"msg%{public}.0s":"invalid #tile header table connection.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
unconditionally removing all #tile tables in favor of new schema
Detected that we had legacy tile tables. Unconditionally dropping all tile headers as well
{"msg%{public}.0s":"@TileHeader, wifi, failed to remove some headers", "existing":%{public}d, "removed":%{public}d}
remaining entries in als db, deleting, %{private}d
{"msg%{public}.0s":"runtime error deleting tile.", "error":%{private, location:escape_only}s}
{"msg%{public}.0s":"no database connection.", "error":%{private, location:escape_only}s}
{"msg%{public}.0s":"sqlite error deleting remaining tiles.", "error":%{private, location:escape_only}s}
@TileSearch, wifi, missreset, %{public}s
@TileSearch, wifi, misscount, %{public}d
invalid location provided and complete miss, will not return any tiles to search
@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, 0, completemiss, %{public}d
@TileSearch, wifi, nrx, %{public}ld, %{public}ld, %{public}ld, havecurrent, %{public}d, completemiss, %{public}d
DB, Error expiring records.
DB, CalorimetryHistory not accessible
DB, UUID un-initialized
Attempting to request data older than 24 hours with queryNatalieDataSince, start, %f
DB, Potential DB reset, returning all records to clients
DB, CalorimetryHistory has rolled back, returning mru to clients,mru.recordId,%d,record.recordId,%d,mru.natalies,%lld,record.natalies,%lld
DB, not accessible
Attempting to request data older than 24 hours with queryNatalieData, start, %f, end, %f
{"msg%{public}.0s":"DB, Invalid update finished handlers.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
DB, Device is locked and we are unable to open the database
DB, doesn't exist yet.
DB, Failed to delete records
DB, Failed to shift records
DB, Inserting basal calories %f for gap (%lf - %lf, %lfs)
ExerciseMinute, error in update
ExerciseMinute, Subscription changed, %s, %p, %d
ExerciseMinute, Error in query request.
ExerciseMinute, Error query response, %{public}d, %s, %p
CL: CLExerciseMinuteSubscription::onNatalimetryUpdate
{"msg%{public}.0s":"CLExerciseMinuteSubscription::onNatalimetryUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
%{public}s : %{private}s
#Warning #Actor limiting multi-line string to %{public}d lines
#Actor splitting string (length %{public}d) into %{public}d parts
%{public}s %{public}d of %{public}d : %{private}s
#Actor truncated string max length is too small, not enforcing
#Warning #Actor truncated string to %{public}d characters
{"msg%{public}.0s":"#Actor,isAltitudeAvailable", "available":%{public}hhd, "altitude (MSL)":"%{private}f", "undulation":"%{private}f", "vunc":"%{public}f", "undulation model":%{public}d}
#Actor EED UI should %{public}s
{"msg%{public}.0s":"#Actor emergency state change", "oldState":%{public, location:escape_only}s, "newState":%{public, location:escape_only}s}
{"msg%{public}.0s":"#EmgContext #Actor", "LS":%{public}d}
{"msg%{public}.0s":"#EmgContext #Actor", "inst":%{public}d, "InHomeCountry":%{private}d}
{"msg%{public}.0s":"#EmgContext #Actor", "inst":%{public}d, "PhoneNum":%{private, location:escape_only}s}
#Actor,handleEmergencyStateChange,pointer was null for %{public}s
{"msg%{public}.0s":"#Actor handleLocationServicesStatusChange", "fLocationServicesEnabled":%{public}hhd}
#Actor LS unexpectedly turned off during an emergency, still clearing cached location
#Actor clearing cached location due to LS off
#Actor registering as client of Location Controller
#Actor already registered as client of Location Controller
#Actor registering as client of WiFi location
#Actor already registered as client of WiFi location
#Actor registering as client of Cell location
#Actor already registered as client of Cell location
#Actor,checkLocationRegistration,pointer was null for %{public}s
#Actor registering for location notifications
#Actor registering for WiFi location notification
#Actor registering - WiFi client NULL
#Actor registering for Cell location notification
#Actor registering - Cell client NULL
#Actor attempted to register for location notification without a client
#Actor unregistering for location notifications
#Actor unregistering for WiFi location notifications
#Actor unregistering - WiFi client NULL
#Actor unregistering for Cell location notifications
#Actor unregistering - Cell client NULL
#Actor sending lockout NILR
#Actor sending disable NILR lockout
#Warning #Actor received unexpected notification %{public}d
#Actor received new fix
#Actor rejected %s location fix as altitude is not usable,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,alt,%{private}.7f,vacc,%{public}.2f,speed,%{private}.1f,course,%{private}.1f,type,%{public}d
#Actor rejected %s location fix as unusable,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,speed,%{private}.1f,course,%{private}.1f,type,%{public}d
#Actor cached %s fix,lat,%{private}.7f,lon,%{private}.7f,acc,%{public}.2f,alt,%{private}.7f,vacc,%{public}.2f,speed,%{private}.1f,course,%{private}.1f,type,%{public}d
#Actor,updateCachedLocation,pointer was null for %{public}s
#Actor %s fix is unusable due to invalid lat,%{private}.7f,lon,%{private}.7f
#Actor %s fix is unusable due to age,%{public}.3f
#Actor %s fix is unusable due to horizontal accuracy,%{public}.2f
#Actor %s fix is unusable due to low integrity,%{public}d
#Actor %s fix is usable
#Actor %s received altitude accuracy is not valid,%{public}.2f
#Actor %s received altitude is not valid,%{public}.2f
#Actor %s altitude undulation model is not valid
#Actor %s altitude is unusable due to age,%{public}.3f
#Actor %s altitude is unusable due to low integrity,%{public}d
#Actor new fix is preferred over cached by default
#Actor, WiFi location notification received lat,%{private}.7f,lon,%{private}.7f,hacc,%{private}.7f,conf,%{private}d
#Actor, Cell location notification received lat,%{private}.7f,lon,%{private}.7f,hacc,%{private}.7f
#Warning #%{public}s allowing session for non-active emergencies
#%{public}s companion phone number changed to %{private}s
#%{public}s session assertion is already %{public}s,ignoring
#%{public}s session assertion %{public}s
CL: CLEmergencyActor::onLocationNotification
{"msg%{public}.0s":"CLEmergencyActor::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLEmergencyActor::onWifiLocationProviderNotification
{"msg%{public}.0s":"CLEmergencyActor::onWifiLocationProviderNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLEmergencyActor::onCellLocationProviderNotification
{"msg%{public}.0s":"CLEmergencyActor::onCellLocationProviderNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#Actor,LocationCallback,returning cached fix
#Warning #Actor,LocationCallback,cached fix is not usable
#Actor,LocationCallback,returning cached prefiltered fix
#Warning #Actor,LocationCallback,cached prefiltered fix is not usable
{"msg%{public}.0s":"#ZoneMonitor changed classfication", "timeZone":%{public, location:escape_only}s, "oldIsInZone":%{public}hhd, "newIsInZone":%{public}hhd}
{"msg%{public}.0s":"#Multiclient Stop timer fired"}
{"msg%{public}.0s":"#Multiclient #CLEEA change", "needed":%{public}hhd}
{"msg%{public}.0s":"#Multiclient Setting fitness activity type", "state":%{public}hhd}
{"msg%{public}.0s":"#Multiclient Setting airborne activity type", "state":%{public}hhd}
{"msg%{public}.0s":"#Multiclient toggling streaming", "state":%{public}hhd, "fitness":%{public}hhd, "airborne":%{public}hhd, "emergency":%{public}hhd}
{"msg%{public}.0s":"#Multiclient Dropping location due to expiration", "timestamp":"%{public}f", "lifespan":"%{public}f"}
{"msg%{public}.0s":"#Multiclient failed to post multiclient stream event", "err":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Multiclient posted a location to interested peers", "numClients":%{public}u}
{"msg%{public}.0s":"#Multiclient Unexpected notification", "notification":%{public, location:CLLocationProvider_Type::Notification}lld}
{"msg%{public}.0s":"#Multiclient registering request handlers"}
{"msg%{public}.0s":"#Multiclient received interest in streaming from a nearby client", "requester":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient received streaming action request from a client", "msg":%{private, location:escape_only}@}
{"msg%{public}.0s":"#Multiclient starting location streaming to remote client", "effectiveID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient stopping location streaming to remote client", "effectiveID":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient CLLocationStreamer can no longer see a device", "effectiveID":%{public, location:escape_only}s, "name":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient CLLocationStreamer spotted a device", "effectiveID":%{public, location:escape_only}s, "name":%{private, location:escape_only}s}
{"msg%{public}.0s":"#Multiclient failed to activate advertisement server", "error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Multiclient ready to listen for incoming streaming requests"}
{"msg%{public}.0s":"#Multiclient location streaming outbound client ready to go when needed"}
{"msg%{public}.0s":"#Multiclient Shut down location streaming"}
Bringing up cycling state detector
Tear down cycling state detector
CL: CLWifiTilesManager::onClientNotification
{"msg%{public}.0s":"CLWifiTilesManager::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiTilesManager::onDataProtectionNotification
{"msg%{public}.0s":"CLWifiTilesManager::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiTilesManager::onStatusNotification
{"msg%{public}.0s":"CLWifiTilesManager::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiTilesManager::onLocationNotification
{"msg%{public}.0s":"CLWifiTilesManager::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLWifiTilesManager::onCompanionNotification
{"msg%{public}.0s":"CLWifiTilesManager::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CLMobility::SteadinessAdjustment::Features,allBoutsBoutDurationSecCv,%{private}.2f,dailySteps30daysMean,%{private}.2f,dailyFlights30daysMean,%{private}.2f
{"msg%{public}.0s":"CLAvengerZoneMonitor: polygon information is found.", "fZoneName":%{private, location:escape_only}s, "zones":%{private}lu}
{"msg%{public}.0s":"CLAvengerZoneMonitor: no zone information is found.", "fZoneName":%{private, location:escape_only}s}
{"msg%{public}.0s":"isInside", "fZoneId":%{private}d, "minLat":"%{private}f", "maxLat":"%{private}f", "minLon":"%{private}f", "maxLon":"%{private}f", "latitude":"%{private}f", "longitude":"%{private}f", "isInsize":%{private}hhd}
Wrote boutMetrics to db: startTime=%{public}.2f
{"msg%{public}.0s":"Need to override getTableName in order to use default definition of getEntriesByTimeRange", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Buffer size: %d
{"msg%{public}.0s":"Database can now be opened!", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"Database is already opened.", "name":%{public, location:escape_only}s}
In memory buffer should have been empty! Instead it had a size of %{public}lu.
{"msg%{public}.0s":"Inserting entries into database", "name":%{public, location:escape_only}s, "size":%{private}llu}
{"msg%{public}.0s":"Unexpected error condition! Device has been unlocked but database remains unreadable!", "name":%{public, location:escape_only}s}
#Notice %{public}s needs autoincrement migration
#Notice %{public}s autoincrement migration succeeded
%{public}s autoincrement migration failed
{"msg%{public}.0s":"Need to override getTableName in order to use default definition of aggregateRecords", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Need to override getTableName in order to use default definition of getAllRecords", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf
Entry being recorded has a startTime in the recent past.  Deleting records after %f.
Entry being recorded has a startTime in the substantial past.  Shift records by %f.
Failed to insert record due to failure from reading the most recent entry.
{"msg%{public}.0s":"Need to override getTableName in order to use default definition of deleteAllRecordsUL", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Need to override getTableName in order to use default definition of deleteRecordsAfterInsertUL", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Need to override getTableName in order to use default definition of shiftRecordsByUL", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Need to override getTableName in order to use default definition of getMostRecentRecordUL", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Need to override getTableName in order to use default definition of getNumberOfRecords", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
MaxMetsHistory, DB not accessible
@GtsMgr, nrIsPairingActive, %{public}d
GtsMgr, canDownload, %d
@GtsSync, inactive nil
Semistationary, Standing, %d, metsFromIntensity, %.1f, userMetsFromSteps, %.1f, metsFromPosture, %.1f, userMetsFinal, %.1f, computeTime, %.1f, truthMetsFinal, %.1f, truthMetsFromSteps, %.1f, activityType, %d, floor, %f
Pedestrian, metsHrUpperBound, %.1f 
Pedestrian, wrMets, %f,  fmMets, %f, hrMets, %f, hrwrDiff, %f, useHrMets, %d, userMets, %f, truthMets, %f
Error in FFT,p,%d
Device is locked and we are unable to open the database.
Failed to delete records.
WorkloadCalibratorDb (%d,%f,%f,%f).
SwimData subscription changed, %s, %p, %d
#Warning Failed to subscribe to swim updates.
Query: id, %llu, session, %s, db, %s, Response (numel): %lu
CL: CLSwimDataSubscription::onSwimNotification
{"msg%{public}.0s":"CLSwimDataSubscription::onSwimNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
syncgetAuthorizationOfClient, %s, forServiceMask, %lx, authorized, %d
setClients, %s
{"msg%{public}.0s":"#slv Dropping visit because there's nothing left after slicing out unauthorized bits", "commencementDate":%{public, location:escape_only}@, "clientKey":%{public, location:escape_only}s, "interest":%{public, location:escape_only}@, "authorized":%{public}hhd}
{"msg%{public}.0s":"#slv Sending visit to client", "visit":%{private, location:escape_only}@, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Preparing visit info for client", "visit":%{private, location:escape_only}@, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#slv Preparing visit info for client", "visit":%{private, location:escape_only}s, "client":%{public, location:escape_only}s}
{"msg%{public}.0s":"#INFO #slv authorization status", "isAuthorized":%{public}hhd, "commencementDate":%{public, location:escape_only}@, "clientKey":%{public, location:escape_only}s, "interest":%{public, location:escape_only}@}
{"msg%{public}.0s":"#Warning #slv Got visit when we should be unsubscribed", "commencementDate":%{public, location:escape_only}@, "clientKey":%{public, location:escape_only}s, "interest":%{public, location:escape_only}@}
{"msg%{public}.0s":"#slv Client subscribe", "client":%{public, location:escape_only}s, "subscribe":%{public}hhd}
{"msg%{public}.0s":"Client is not entitled to provide #SLV configuration", "key":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Warning #slv Got visit state request when we should be unsubscribed", "commencementDate":%{public, location:escape_only}@, "clientKey":%{public, location:escape_only}s, "interest":%{public, location:escape_only}@}
{"msg%{public}.0s":"#slv We can retrieve the visit", "Silo":%{public, location:escape_only}@}
{"msg%{public}.0s":"#slv inside the fetchStoredVisitsWithOptions block", "Silo":%{public, location:escape_only}@}
{"msg%{public}.0s":"#slv after the DBG_ASSERT_INSIDE", "Silo":%{public, location:escape_only}@}
{"msg%{public}.0s":"#slv: CoreRoutine error while getting stored visits.", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#slv: last RTVisit returned.", "RTVisit":%{private, location:escape_only}@}
{"msg%{public}.0s":"#slv: last visit returned.", "visit":%{private, location:escape_only}@}
#slv: using corrective compensation
#slv: using full precision or lastVisit is nil
{"msg%{public}.0s":"Using a persistent subscription that has been invalidated!", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Failed to downcast objc type", "clientKey":%{public, location:escape_only}s, "foundClass":%{public, location:escape_only}s}
Initializing CLFallServer instance
Overriding registration timer fire interval: %d
Unable to create log directory, error: %@
Tearing down CLFallServer instance
Overriding %{public}@ to: %{public}@
Overriding %{public}@
Attempting to register device...
HTTP Response for Server registration, statusCode: %{public}d
Unable to register subject, statusCode: %{public}ld, error: %@, response: %@
Unable to parse response! Exception: %{private}@
Unable to parse response for register subject, responseDictionary: %@, error: %@
Successfully registered device, subject UUID: %{private}@, subject Auth: %{private}@
Enabling data collection
NULL certificate for %{public}@
Data collection enabled
Attempting to send data...
Created request for file: %@, task: %@, ingest URL: %@
Data not sent, IsDataCollectionEnabled: %d
Cleaning up Server files older than %f(s)
Error removing data file, error: %@
Removed %d Server files
Error starting Server message, error: %@
Error appending data to Server message, error: %@
Error finalizing Server message, error: %@
Unable to move Server message along side url, error: %@
Successfully encrypted and moved out URL: %{private}@
Invalid value type for key: %@, val: %@
Received CLDataProtectionManager notification, deviceUnlockedSinceBoot: %d
Cached subject credentials, _subjectUUID: %{private}@, _subjectAuth: %{private}@
Got called back for %@ with task: %@ and data of length: %lu and id: %@
Got called back for %@ with task: %@ and error: %@ and id: %@
HTTP Response, statusCode: %{public}d, filePath: %@, response: %@
Unable to remove file after upload attempt, filePath: %@, error: %@
Got called back for %@ with task: %@ and bytesSent: %lld and totalBytesSent: %lld and totalBytesExpectedToSend: %lld and id: %@
VO2MaxSessionAttributesHistory, DB not accessible
Unable to save fetched output data from CloudKit. Device is locked and we are unable to open the database
Unable to delete out-of-date VO2MaxSummaryHistory records
Unable to save synced VO2MaxSummaryHistory records
Unable to update synced VO2MaxHistory record
Unable to insert synced VO2MaxHistory record
Index VO2MaxSessionAttributesHistorySessionIdIndex already exists; not re-creating
Unable to create index VO2MaxSessionAttributesHistorySessionIdIndex
Index VO2MaxSessionAttributesHistorySessionIdIndex created successfully
{"msg%{public}.0s":"#Stream #CLLIA Disablement assertion dropped", "me":%{public, location:escape_only}s}
CL: LocationIndependenceAssertion/kCLConnectionMessage
{"msg%{public}.0s":"LocationIndependenceAssertion/kCLConnectionMessage", "event":%{public, location:escape_only}s, "this":"%{public}p"}
#warning LocationIndependenceAssertion already taken by %{public}s
{"msg%{public}.0s":"#Stream #CLLIA #warning Not entitled as a streaming disabler... ignoring LocationIndependenceAssertion", "client name":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream #CLLIA LocationIndependenceAssertion is malformed.  Needs a reason.", "client name":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Stream #CLLIA Taking a disablement assertion", "me":%{public, location:escape_only}s}
#clgda,daemon,CLDaemonGnssDisablementAssertion()
#clgda,daemon,~CLDaemonGnssDisablementAssertion()
#clgda,daemon,sendAssertionRspWithSuccess
#clgda,daemon,sendAssertionRspWithFailure
#clgda,daemon,message,%s
{"msg%{public}.0s":"#clgda,#warning,daemon,unsupported platform,request denied", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"#clgda,#warning,daemon,missing entitlement,request denied", "requested by":%{public, location:escape_only}s, "entitlement":%{public, location:escape_only}s}
{"msg%{public}.0s":"#clgda,#warning,daemon,missing bundleID,request denied", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"#clgda,#warning,daemon,missing bundlePath,request denied", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"#clgda,#warning,daemon,missing reason,request denied", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"#clgda,#warning,daemon,empty reason,request denied", "requested by":%{public, location:escape_only}s}
{"msg%{public}.0s":"#clgda,#warning,daemon,no beneficiary,request denied", "requested by":%{public, location:escape_only}s, "reason":%{public, location:escape_only}s}
#clgda,daemon,takenBy,%s,reason,%s
{"msg%{public}.0s":"#clgda,daemon,", "requested by":%{public, location:escape_only}s, "entitlement":%{public, location:escape_only}s, "entitled":%{public}hhd}
#clgda,daemon,kNotificationGnssDisablementAssertRsp,%d
CL: CLDaemonGnssDisablementAssertion::handleGnssDisablementNotification
{"msg%{public}.0s":"CLDaemonGnssDisablementAssertion::handleGnssDisablementNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
{"msg%{public}.0s":"App has more than one counterpart.  Defaulting to the first listed one", "bundleId":%{public, location:escape_only}s, "counterparts":%{public, location:escape_only}@}
{"msg%{public}.0s":"unknown in-useness level enum passed to encodeInUseLevelAsInteger", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"level int is out of range for in-use level", "level":%{public}d, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
HealthKitWriter: Initializing Mobility HKDataCollectors (%@)
Writing Steadiness score to HealthKit, startDate: %{public}@, endDate:%{public}@, walkingSteadiness: %{private}f, source: %{public}@
Steadiness Sample missing source metadata
HealthKitWriter: failed to push steadiness sample to HealthKit, error, %{public}@
HealthKitWriter: successfully pushed steadiness sample to HealthKit, startDate: %{public}@, endDate:%{public}@, walkingSteadiness: %{private}f
Writing Steadiness event to HealthKit, startDate: %{public}@, endDate:%{public}@, eventType: %{private}ld, source: %{public}@
Unsupported event type: none
Steadiness Event missing source metadata
Successfully pushed WalkingSteadinessEvent sample
Failed to insert WalkingSteadinessEvent sample: %{public}@
HealthKitWriter: Writing %s to HealthKit, startDate: %{public}@, endDate: %{public}@, value: %{private}.2f, metadata: %@
HealthKitWriter: Unexpected QuantityTypeIdentifier %d
HKDataCollector %s was not properly initialized
HKDataCollector successfully pushed %s sample
HKDataCollector failed to insert a %s sample, error, %{public}@
Unable to query onboarding status: %{public}@
HK Walking Steadiness unavailable. reasons=%{public}ld, isLocaleValid=%{public}d, state=%{public}ld
Unable to query notification status: %{public}@
HealthKitWriter: Data collection requested through date %@
HealthKitWriter: Data collection completion was nil
collectionAuthorized = %u
Failed to mmap the MSL file %@
Heartbeating UUID %{public}@
collection UUID %{public}@, recording started = %{public}d
start recording
fRecordingUUID = %{public}@, %{public}p
Error starting recording %@
starting recording %@
pressure min %f max %f delta %f
Stopped recording %{public}p, retain count %lu
Stopping a recording without a UUID
Stopping a non-active recording %p
upload timer using %d seconds
upload will not be performed in-system, skipping upload timer setup
Kappa is disabled
setFastAccelConfig failed
requesting location update
setting AOP collection timeout timer at %d seconds
Trigger companion at %{public}llu
tell the companion to trigger
playing alarm haptic
skipping alarm haptic
precondition violation; no recording, or D MSL could was not opened
bypass SOS wait state since SOS events have already occurred and been logged
waiting for sos for %d seconds
disabled -> authorized
authorized -> disabled
authorized -> collecting
collecting (timeout) -> authorized
collecting (stop) -> authorized
collecting -> triggered
triggered -> authorized
triggered -> qualifying
qualifying -> SOS wait
qualifying -> disabled
SOS wait (SOS) -> disabled
SOS wait (SOS Event) -> authorized
SOS wait (timeout) -> authorized
using trigger parameters uncoupled %f, coupled %f
fFSMTimer handler
fHeartbeatTimer handler
recording list:
%d %@
recording dictionaries:
dictionary %i
recordings may not be requested while the device is locked
file handle is nil
system configured for upload of recordings, refusing to obtain manually
coin flip = %f, rbound = %f
pulse alg result passed
pulse alg forced
gps alg result passed
gps alg forced
baro alg result passed
baro alg forced
zg alg result passed
zg alg forced
audio alg result passed
audio alg forced
TPQ 0x%x, order %u (%d, %d, %d, %d, %d) acceptance rate %g
false positive should be uploaded
recording has SOS event, uploading
uploading because the companion will upload
error converting metadata to nsdata
error creating file %@
wrote metadata to path = %@
recordings meta dictionary and files are different sizes
saving recording to the upload queue
saving recording for user study application
%d %{public}@ = %{public}@
discarding %{public}@, not added to upload queue
trigger (%d) upload (%d) candidate (%d) trigger_type (%d) trigger_bitmap (%d) collecting (%d) driving (%d) tpq_bitmap (%d) config_version (%d) age (%d) biologicalSex (%d) hasSOS (%d)
#Warning could not open file path %{public}@
failed to remove %@; error: %@
deferring upload while collection could be in progress
enabling the server
no recordings to upload
sequenceNumber %u
uploading file = %{public}@, UUID = %{public}@
failed to upload the file
rotating UUID fRecordingSeq (%d) rotateCount (%d) hasSOS (%d)
upload: fDeviceUnlockedSinceBoot = %d, fDeviceUnlocked = %d, fSessionEstablished = %d
skipping upload timer setup, system will not upload recordings
Failed to create log directory %@, error: %@
Created log folder %@
Log folder is %@
recording sequence %d
{"msg%{public}.0s":"CLServiceLocationProvider_Type add client failed", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
configuration version %d
tearing down tpqs
(CLKappaNotifier) %d
Recording compass calibration stopped.
returning defaults write AR for 0x%x = %g
returning server config AR for 0x%x = %g
Invalid server AR config array
returning default AR for 0x%x = %g
got a trigger at %llu, simulated %d, triggerPathBitmap %x, listening %u
kappa timed out
Streaming has finished at %llu
companion nearby %{public}d
companion nearby, but kappa is disabled
(onMotionStateUpdate) %p state %d, EventActivity; inVehicle %d, high confidence %d, mounted %d
isAuthorizedForIHA (simulated) %d
isAuthorizedForIHA  %d
isAuthorizedForDNU (simulated) %d
isAuthorizedForDNU  %d
HDS session established
upload finished for file: %@
upload successful for file: %@
PressureInertialFit,x,%f,y,%f,z,%f
%s %g
saving KappaDisable = 1
saving KappaDisable = 0
clearing KappaDisable
saving KappaDisable = %d
Received server configuration
%d %@ = %@
acceptance rates
[0x%x] %@
signal environment %u
type = %u, speed = %f accuracy = %f course = %f lat = %f long = %f
Unhandled location notification %{public}d
DeviceUnlockedSinceBoot %u
EncryptedDataAvailability %u
age=%d biologicalSex=%d
emergency state is the same %s
emergency state change was %s now is %s
logging active SOS call
tell the companion to upload
Firing companion stop event
Companion triggered; forced AOP trigger
Ignoring loopback msg
NOT collecting; ignoring companion trigger
Companion will upload %{public}@ with SOS state %{public}u
logging companion SOS call
NOT in SOS wait state; asserting fBypassSOSWait
My collection UUID is different than companion's
setIsSimulated
setIsSimulatedAuthorized
enable manual mode
manual mode already enabled
disable manual mode
setting one shot custom config: fast accel (%d), accel (%d), pressure (%d), DM (%d), audio (%u), mag (%d)timeout %d
simulate authorized %d current state %d
simulate driving confidence = %d
detected cached value larger than the defaults, resetting
updating tokens to %{public}u
token %{public}u
simulate triggered
forcing audio %d
forcing pulse %d
forcing gps %d
forcing zg %d
forcing baro %d
CL: CLKappaNotifier::onKappaReply
{"msg%{public}.0s":"CLKappaNotifier::onKappaReply", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLKappaNotifier::onDataProtectionNotification
{"msg%{public}.0s":"CLKappaNotifier::onDataProtectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLKappaNotifier::onLocation
{"msg%{public}.0s":"CLKappaNotifier::onLocation", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLKappaNotifier::onMotionStateUpdate
{"msg%{public}.0s":"CLKappaNotifier::onMotionStateUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLKappaNotifier::onPressureBias
{"msg%{public}.0s":"CLKappaNotifier::onPressureBias", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLKappaNotifier::onUserInfoNotification
{"msg%{public}.0s":"CLKappaNotifier::onUserInfoNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLKappaNotifier::onCompanionNotification
{"msg%{public}.0s":"CLKappaNotifier::onCompanionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLKappaNotifier::onSignalEnvironmentNotification
{"msg%{public}.0s":"CLKappaNotifier::onSignalEnvironmentNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
%s %f
%s-%i %f
Assertion failed: !(ignoreHamming && node->requiresHammingWindow(samples[r]->sampleFreq)), file /Library/Caches/com.apple.xbs/Sources/CoreLocation_Sim/CoreLocation-2665.0.3/Oscar/CMAccelerometerProcessor.cpp, line 185,Hamming required but ignored..
Developer error. Specified rate does not exist.
Polygonal fence should not be added for wifi monitoring
Fence: combined fences, %{public}lu, fences to, %{public}lu, fences
{"msg%{public}.0s":"Fence: combined, no key", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Fence: Failed to calculate fence %{private}s
#Warning Fence: combined fence, %{private}s
Fence: Calculator for %{public}s/%{private}s returned %{public}ld desired APs for %{private}s
Fence: Using associated AP %{private}s, channel %{private}d for exit
#Warning Fence: Continuous monitoring is needed in order to supported the monitored fences
WifiFenceCalculator: Adding exit AP, mac, %{private}s, hAcc, %{private}.2lf, channel, %{private}d, location, %{private}12.8lf, %{private}12.8lf, isLocallyAdministered, %{private}d
Fence: WifiFenceCalculator: Skipped non-2GHz AP, channel, %{private}d, mac, %{private}s
WifiFenceCalculator: Adding entry AP, mac, %{private}s, hAcc, %{private}.2lf, channel, %{private}d, location, %{private}12.8lf, %{private}12.8lf
Fence: Fence calculator returned more APs (%{public}zu) than maximum (%{public}d)
#Warning Fence: no visible APs, exitAPs, %{public}lu
Fence: request a download for, %{private}s, fChosenAPs, %{public}lu
Fence: calculateAPsForFences end
Estimated,time offset measurement variance(s^2),%.12g
#Warning Unacceptable,time offset measurement variance(s^2),%.12g
Unexpected,state plus measurement covariance < 0.
internalTimeSecs,%.6lf,externalTimeSecs,%.6lf,filteredOffsetSecs,%.6lf,offsetUncertaintySecs,%.9g,R,%.9g,Q,%.9g,v,%.9g,vtest2,%.9g
VEHICULAR: Motion calibration system service is disabled.
VEHICULAR: Taking power assertion and enabling proactive gps.
VEHICULAR: Releasing power assertion and disabling proactive gps, loi, %{private}d, stationaryWifi, %{private}d, state, %{private}lu, auth, %{private}d, clients, %{private}d
VEHICULAR: visit, confidence, %s, exit
VEHICULAR: visit, confidence, %s, entry
VEHICULAR: Received transit navigation state: %{public}d
VEHICULAR: WiFi dis-associated, update vehicular state
VEHICULAR: WiFi isStationary, %{private}d
#Warning VEHICULAR: Received unhandled location notification, %{public}d
VEHICULAR: entering DNDLOI, range, %{public}f
VEHICULAR: too far from center of DNDLOI
VEHICULAR: skipping repeated nearby location
VEHICULAR: Error retrieving LOIs. %{public}@
VEHICULAR: No LOIs near fast suppression range
VEHICULAR: recover visit, confidence, high, entry
VEHICULAR: fast suppression range detected
VEHICULAR: state, %{public}lu, hints, %{public}lu, fpSuppress, %{public}u, dndOverride, %{public}u
VEHICULAR: submitted metrics, %@
VEHICULAR: reset vehicular false positive mitigation states
VEHICULAR: Could not post state associated with vehicular state changed notification.
VEHICULAR: Could not post kCMVehicularStateChangedToVehicularNotification.
VEHICULAR: successfully posted notification, %@
CL: CLVehicleStateNotifier::onVehicleConnectionNotification
{"msg%{public}.0s":"CLVehicleStateNotifier::onVehicleConnectionNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLVehicleStateNotifier::onMotionStateUpdate
{"msg%{public}.0s":"CLVehicleStateNotifier::onMotionStateUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLVehicleStateNotifier::onTransitNavigationStateUpdateNotification
{"msg%{public}.0s":"CLVehicleStateNotifier::onTransitNavigationStateUpdateNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLVehicleStateNotifier::onDaemonStatus
{"msg%{public}.0s":"CLVehicleStateNotifier::onDaemonStatus", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLVehicleStateNotifier::onLocationNotification
{"msg%{public}.0s":"CLVehicleStateNotifier::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Unrecognized notification
Empty payload, returning
ALTERED: original location: %.8f, %.8f, %.2f, %d, %d
ALTERED:  unaltered location: %.8f, %.8f, %.2f, %d, %d
Failed to convert Coarse MetaData to nvp
Failed to convert location to nvp
Failed to convert location private to nvp
beginService
endService
shouldAcceptNewConnection
process is not entitled to use CLLocationSmoother, pid, %{public}d, executable, %{public}s
Connection Interrupted
Connection Invalidated
TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s, id, %s
TILE: searched for, location, %.10lf, %.10lf, setLinear, %lu, setIndex, %lu
TILE: not in index, %s, count, %3u, locationd, %.10lf, %.10lf
TILE: result: tilestool: pass, %d, tests, %u, %d
TILE: CLSpatialDataTileTemplate, parsing, sectionId, %d, %s
TILE: CLSpatialDataTileTemplate, index, height, %u, width, %u
TILE: index entry, %3lu, %3u, step, %04d, %s
TILE: CLSpatialDataTileTemplate, entries, numOfEntries, %u
TILE: entry, %3lu, %3u, %3lu, %s, swLoc, %.8lf, %.8lf
TILE: CLSpatialDataTileTemplate, regionalEntries, numOfEntries, %u
TILE: CLSpatialDataTileTemplate, headers only, give up
TILE: entry, %3lu, %3u, %3lu, %s
TILE: getEntriesForArea, input, swLatitude, %.8lf, swLongitude, %.8lf, search, %.8lf, %.8lf, isUseIndex, %d, includeRegionalEntries, %d, entries, %lu
TILE: doesIntersectWithTile, %d, no intersection with the tile
TILE: invalid section, signature, 0x%x, stopping
TILE: getEntriesForArea, invalid tile file, bad allocation size, totalBytesInSection, %lu, maxSectionSize, %lu
TILE: getEntriesForArea, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, genTime, %.2lf, expAge, %d, age, %.2lf
TILE: getEntriesForArea, numEntriesHeight, %d, numEntriesWidth, %d, entrySizeInBytes, %d
TILE: getEntriesForArea, numOfEntries, %d, entrySizeInBytes, %d, numOfLargeEntries, %d
TILE: getEntriesForArea, numOfRegionalEntries, %d, entrySizeInBytes, %d
TILE: getEntriesForArea, asked not to use index
TILE: getEntriesForArea, pIndexEntries, 0x%lx, pEntries, 0x%lx
TILE: getEntriesForArea, line, %d, searched_min_y, %d, %d, searched_min_x, %d, %d, index_y, %d, index_x, %d, entriesOffset, %d
TILE: getEntriesForArea, entryId, %d, isIntersect, %d, examinedEntries, %d, entry, %s
TILE: getEntriesForArea, nothing to search, %s
TILE: getEntriesForArea, examinedEntries, %5u, foundEntries, %5lu, isUseIndex, %d, clocks, %10lu, extra, %3d, %3d
{"msg%{public}.0s":"receiver object cannot be null"}
{"msg%{public}.0s":"users of CLWifiServiceClient should not register for kNotificationPower directly"}
{"msg%{public}.0s":"users of CLWifiServiceClient should not register for kNotificationLinkStatus directly"}
{"msg%{public}.0s":"users of CLWifiServiceClient should not register for kNotificationRoam directly"}
{"msg%{public}.0s":"users of CLWifiServiceClient should not unregister for kNotificationPower directly"}
{"msg%{public}.0s":"users of CLWifiServiceClient should not unregister for kNotificationLinkStatus directly"}
{"msg%{public}.0s":"users of CLWifiServiceClient should not unregister for kNotificationRoam directly"}
notification, %d, kNotificationPower, fIsWifiPowered, %d, data.power, %d
notification, %{public}d, kNotificationLinkStatus/Roam, wasAssociated, %{public}d, isAssociated, %{public}d
CL: CLWifiServiceClient::onWifiNotification
{"msg%{public}.0s":"CLWifiServiceClient::onWifiNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
StepCountHistory table doesn't even exist
Assumption failed: startTime (%{public}f) was found to be newer than endTime (%{public}f), queryTimeType %{public}d
#Warning First step time invalid.
{"msg%{public}.0s":"Steps were found to be non monotonically increasing", "startTime":"%{public}.6f", "endTime":"%{public}.6f", "startLeft.startTime":"%{public}.6f", "startRight.startTime":"%{public}.6f", "startLeft.count":%{public}u, "startRight.count":%{public}u, "startLeft.floorsAscended":%{public}u, "startRight.floorsAscended":%{public}u, "startLeft.floorsDescended":%{public}u, "startRight.floorsDescended":%{public}u, "endLeft.startTime":"%{public}.6f", "endRight.startTime":"%{public}.6f", "endLeft.count":%{public}u, "endRight.count":%{public}u, "endLeft.floorsAscended":%{public}u, "endRight.floorsAscended":%{public}u, "endLeft.floorsDescended":%{public}u, "endRight.floorsDescended":%{public}u, "startCount":%{public}ld, "endCount":%{public}ld, "startPushCount":%{public}ld, "endPushCount":%{public}ld, "startFloorAscended":%{public}ld, "endFloorAscended":%{public}ld, "startFloorDescended":%{public}ld, "endFloorDescended":%{public}ld, "queryTimeType":%{public}d}
{"msg%{public}.0s":"Invalid delta distance and time.", "startDistance":"%{public}f", "endDistance":"%{public}f", "startRawDistance":"%{public}f", "endRawDistance":"%{public}f", "startActiveTime":"%{public}f", "endActiveTime":"%{public}f"}
StepCountHistory not accessible
#Warning DB UUID un-initialized
#Warning Potential DB reset, returning all records to clients
#Warning Step count has rolled back, returning mru to clients,mru.recordId,%d,record.recordId,%d,mru.count,%u,record.count,%u,mru.distance,%f,record.distance,%f,mru.activeTime,%f,record.activeTime,%f,mru.pushCount,%d,record.pushCount,%d
Failed to delete records
Failed to shift records
Failed to search list for %{public}s %{public}f
Failed to examine the most last record for data aggregation.
Failed to examine the second to last record for data aggregation.
Failed to iterate through records for data aggregation.
Failed to retrieve most recent record for data aggregation.
Failed to delete marked records with timestamp of %{public}f
Reset requested.  Counts (prev: %d cur:%d). New fOffset (%d).
Reset current step count.  Counts (prev: %d cur:%d). New fOffset (%d).
Oscar restart detected.  Count (prev: %d cur:%d). New fOffset (%d).
An error in step counts is highly likely.  Treating current count as new 0.  Count (prev: %{public}d cur:%{public}d). New fOffset (%{public}d).
Reset requested.  New offset (%d, %d, %f).
Reset requested.  New elevation offset (%d, %d).
Locationd restart detected.  New offset (%d, %d, %f).
Locationd restart detected.  New elevation offset (%d, %d).
Oscar restart detected.  New offset (%d, %d, %f).
Oscar restart detected.  New elevation offset (%d, %d).
An error in floor counts is highly likely.  Treating current count as new 0.  New offset (%{public}d, %{public}d, %{public}f).
CLStepCountNotifier is being constructed
Configuration: speedUpRate %f, aggregationDisabled %d, expirationDisabled %d, detailedLogging %d
CLStepCountNotifier is shutting down
Aggregating records due to timer!
StepCount, %f, %d, %f, %d, %d, %d, %d
Adding Fused entry, time, %f, count, %d, raw_dist(m), %f, fused_dist(m), %f, cadence(steps/s), %f
Query (%f, %f): %d, %f, %f, %d, %d, %f
step counting overrideActivityType,%lu,
CL: CLStepCountNotifier::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLStepCountNotifier::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLStepCountNotifier::onUserInfoUpdate
{"msg%{public}.0s":"CLStepCountNotifier::onUserInfoUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLStepCountNotifier::onActivePedStateCoprocessorData
{"msg%{public}.0s":"CLStepCountNotifier::onActivePedStateCoprocessorData", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLStepCountNotifier::onActivePedStateCoprocessorDataSpectator
{"msg%{public}.0s":"CLStepCountNotifier::onActivePedStateCoprocessorDataSpectator", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Programmer error, this rule is not valid (age: %{public}f, interval:%{public}f).
received KF filtered pressure from AOP!, now %f filteredPressureTimestamp %f filteredPressure %f kfTimestamp %f kfElevation %f kfPressure %f temperature %f
activity alarm triggered. (internal id %d)
activity alarm triggered, but invalidated.  ignoring.  (internal id %d)
#Warning Activity alarms not available.  Requested alarm will not be listened for.
Primed for activity alarm %d with duration %f (internal id %d)
#Warning CLDaemonClient got activity alarm callback after destruction... ignoring
Invalidated activity alarm %d with duration %f (internal id %d)
SwimNotifier, Requested finalize before end.
SwimDistributionsByLOI set to %d
Swim Notifier instantiated
LogMotionStateReplay and LogSwimming are both set - LogMotionStateReplay takes precedence in the Swim Notifier
CLSwimNotifier is shutting down.
Added client for %d, count %d
[LOI] Calling fetchLocationsOfInterestWithinDistance
Error retrieving the RT LOIs. %@
[LOI] Found nil locationsOfInterest
[LOI] Registering for location updates
SwimController is ready
[SwimOdom] Registering for odometer updates
Removed client for %d, count %d
[SwimOdom] Unregistering for odometer updates
[LOI] Unregistering for location updates
Swim Controller released
swim fusion setup
swim fusion teardown
Swimming workout started, location, %lu, poolLength, %f
Swimming workout has ended
[SwimOdom] Received an odometer update of type: %d
[SwimOdom] Received unhandled notification, %d
{"msg%{public}.0s":"[LOI] Received a location", "location":%{private, location:CLClientLocation}.*P}
[LOI] Received a location,lat: %{private}lf, long: %{private}lf, accuracy: %lf, lifespan: %lf, timestamp: %lf
Received unhandled notification, %d
CL: CLSwimNotifier::onMotionStateMediatorNotification
{"msg%{public}.0s":"CLSwimNotifier::onMotionStateMediatorNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSwimNotifier::onWatchOrientationSettingsNotification
{"msg%{public}.0s":"CLSwimNotifier::onWatchOrientationSettingsNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSwimNotifier::onNataliemetryUpdate
{"msg%{public}.0s":"CLSwimNotifier::onNataliemetryUpdate", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSwimNotifier::onOdometerNotification
{"msg%{public}.0s":"CLSwimNotifier::onOdometerNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLSwimNotifier::onLocationNotification
{"msg%{public}.0s":"CLSwimNotifier::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
SteadinessClassifier: Received user info (%{public}s)
SteadinessClassifier unable to classify because UserInfo not set
#warning: Attempted a classification despite invalid user age: %{private}.1f. Exiting.
#warning: SteadinessClassifier unable to classify, BoutMetricsDb unavailable
No height set, setting nextClassificationTime to the past for historical compute
SteadinessClassifier: score suppressed.
CLMobility::SteadinessResult,hkStartTime,%{public}.2f,hkEndTime,%{public}.2f,unadjustedScore,%{private}.2f,walkingSteadiness,%{private}.2f,writeToHealthKit,%{public}d,errorStatus,%{public}d,rejectionStatus,%{public}d,nextClassificationTime,%{public}.2f,dataSourcesUnavailable,%{public}d
Applied bout metrics correction (speeds=%{public}d, stepLengths=%{public}d, doubleSupportPercentages=%{public}d, entropyModelStepLengthFeatures=%{public}d)
Insufficient time since first bout (%{public}.2f). Retrying on %{public}.2f
SteadinessClassifier unable to classify, insufficient time since previous steadiness endTime, classificationTime=%{public}.2f, previousSteadinessEndTime=%{public}.2f
[SteadinessEvent] No steadiness samples, no event detected
[SteadinessEvent] Evaluating %ld sample(s) from (%.2f->%.2f)
[SteadinessEvent] EvaluateRepeatVeryLow: isRepeatVeryLow,%d,durationOK,%.2f,durationVeryLow,%.2f,durationLow,%.2f
[SteadinessEvent] EvaluateRepeatLow: isRepeatLow,%d,durationOK,%.2f,durationVeryLow,%.2f,durationLow,%.2f
[SteadinessEvent] steadinessEvent, %{private}ld, percentLow, %{private}.2f, percentVeryLow, %{private}.2f, mostRecentClassification, %{private}ld, isBlockoutPeriodLow, %{private}d, isBlockoutPeriodVeryLow, %{private}d, isSampleRecent, %{public}d, userOnboardedNotifications, %{private}d, isRepeatVeryLow, %{private}d, isRepeatLow, %{private}d 
Unexpected event type value: %ld
BMI above max threshold, %{private}.2f, setting it to Max threshold, %{private}.2f
BMI below min threshold, %{private}.2f, setting it to Min threshold, %{private}.2f
Attempted to correct entropy model feature without height being set
{"msg%{public}.0s":"#durian #system coex", "state":%{public}d, "btaudio":%{public}d, "wifiNetworkCritical":%{public}d, "isAssociatedTo2GHzWiFi":%{public}d, "prior":%{public}d}
{"msg%{public}.0s":"#durian #system failed to get audio stream state"}
{"msg%{public}.0s":"#durian received FindMy app event", "notification":%{public}ld}
{"msg%{public}.0s":"#durian #system will sleep"}
{"msg%{public}.0s":"#durian #system", "reach":%{public}d}
{"msg%{public}.0s":"#durian #system metricheartbeat"}
{"msg%{public}.0s":"#durian #system unexpected status", "notification":%{public}d}
{"msg%{public}.0s":"#durian #system unexpected wifi", "notification":%{public}d}
[CMMslDefaultObserver] Received KVO for key,%{public}@,value,%{public}@
Unable to create directory at path: %{public}s
Event: %s
 Condition: %s
 Message: %s
Msl files on disk:
  %{private}s
MSLWriter - deleting: %{private}s
Unable to create directory at path: %{public}@, error, %{public}@
Unable to list files at path: %{public}s, error, %{public}@
Unable to delete file %{public}s, error, %{public}@
{"msg%{public}.0s":"CLEmergencySessionReport part 1", "lat":"%{private}.08f", "lon":"%{private}.08f", "alt":"%{private}f", "accuracy":"%{public}f", "verticalAccuracy":"%{public}f", "ttff":"%{public}f", "positionValid":%{public}hhd, "source":%{public}d, "methodType":%{public, location:escape_only}s, "sessionType":%{public, location:escape_only}s, "protocol":%{public, location:escape_only}s, "rat":%{public, location:escape_only}s, "mcc":%{private}d, "mnc":%{private}d, "sid":%{private}d, "nid":%{private}d, "requestedTimeout":"%{public}f", "requestedAccuracy":"%{public}f", "requestReportType":%{public, location:escape_only}s, "transFreq":"%{public}f", "transBW":"%{public}f", "errorCode":%{public, location:escape_only}s, "HELOEnabled":%{public}hhd, "HELOInjected":%{public}hhd, "HELOUsed":%{public, location:escape_only}s, "sendError":%{public}d, "modemError":%{public}d, "starttime":"%{public}f", "stoptime":"%{public}f"}
{"msg%{public}.0s":"CLEmergencySessionReport part 2", "wifiAssociated":%{public}hhd, "isTandemDP":%{public}hhd, "isOrbitFileAvailable":%{public}hhd, "orbitFileAge":%{public}llu, "wasNetworkReachable":%{public}hhd, "tandemCapability":%{public, location:escape_only}s, "nInstance":%{public}u, "isTandemVD":%{public}hhd, "isSimPresent":%{public}hhd, "subscriberMCC":%{private}d, "subscribeMNC":%{private}d, "satelliteReportCount":%{public}u, "HELORejected":%{public}hhd, "heloRejectReason":%{public}u, "numValidFixesSent":%{public}d, "numNoFixMessagesSent":%{public}d, "numSendSuccessForValidFix":%{public}d, "numSendFailForValidFixes":%{public}d, "lastHttpPostFailureCode":%{public}d, "phoneNumbersAvailable":%{public, location:escape_only}s, "wasNILRSent":%{public}hhd, "isNWRefLocAvailable":%{public}hhd, "nwRefLocUncertainity":"%{public}f", "nwRefLocDeviationFromHELO":"%{public}f", "nwRefLocDeviationFromCellLocation":"%{public}f", "nwRefLocDeviationFromFinalFix":"%{public}f", "nwRefLocLat":"%{private}f", "nwRefLocLon":"%{private}f", "nwRefLocConfidence":"%{public}f"}
{"msg%{public}.0s":"CLEmergencySessionReport part 3", "commType":%{public, location:escape_only}s, "isInActiveEmergency":%{public}hhd, "abortCause":%{public, location:escape_only}s, "overridingSessionType":%{public, location:escape_only}s, "overridingCommType":%{public, location:escape_only}s, "finalFixDeviationFromCellLocation":%{public}d, "fCarrierBundleVersion":%{public, location:escape_only}s, "fCarrierBundleID":%{public, location:escape_only}s, "locConfigCompatibilityVersion":%{public}d, "locConfigContentVersion":%{public}d, "isSUPLEnabled":%{public}hhd, "isDBHEnabled":%{public}hhd, "wasDBHLocationSent":%{public}hhd, "nwReportedFixDeviationFromDBH":%{public}d, "nwReportedFixDeviationFromWifiLocation":%{public}d, "fIsWlanFeatureEnabled":%{public}hhd, "isLocationSourceEnabled":%{public}hhd, "isRssiReportingEnabled":%{public}hhd, "wasRssiRequested":%{public}hhd, "wasServingApSent":%{public}hhd, "finalFixDeviationFromSuplEnd":%{public}d}
{"msg%{public}.0s":"#awd CLEmergencySessionReport::reset"}
#Warning Valid location with unknown or obsolete type
#Warning multiple instances created - last instance %p
CL: startInitialize
{"msg%{public}.0s":"startInitialize", "event":%{public, location:escape_only}s}
#Warning OBSERVER: TIMEOUT: %s => %s RunLoop is really busy time(%.8lf) tdiff(%.8lf)
Can't read mach_timebase_info = %{public}d
sTimebaseInfo.denom %d sTimebaseInfo.numer %d
CL: startRun
{"msg%{public}.0s":"startRun", "event":%{public, location:escape_only}s}
OBSERVER: ProfileObserver = %d
starting idle shutdown timer of %d seconds
Simulator will skip cleanup
CL: locationd shutting down
{"msg%{public}.0s":"locationd shutting down", "event":%{public, location:escape_only}s, "force":%{public}hhd, "killerPid":%{public}d}
linger requested - not shutting down
no more clients, %d second(s) to auto-shutdown
Obsolete data has already been deleted; not deleting again
Deleting obsolete data
Obsolete data deleted in %.2f seconds
CL: CLDaemonCore::onStatusNotification
{"msg%{public}.0s":"CLDaemonCore::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
no LaunchEvents found
{"msg%{public}.0s":"ensure service is running for xpc activity", "service":%{public, location:escape_only}@, "identifier":%{public, location:escape_only}@}
no xpc activities registered
CL: _deleteObsoleteData
{"msg%{public}.0s":"_deleteObsoleteData", "event":%{public, location:escape_only}s}
#Notice Deleting %{public}s if present
Deleting obsolete wifi subdirectory
Deleting %s
Could not delete file %{public}s
CL: locationd main - setup
{"msg%{public}.0s":"locationd main - setup"}
locationd does not take any command-line arguments. Use CFPreferences instead.
Setting location services to %d
{"msg%{public}.0s":"locationd information", "CoreLocation":%{public, location:escape_only}s, "compilation date":%{public, location:escape_only}s, "compilation time":%{public, location:escape_only}s}
{"msg%{public}.0s":"system information", "model":%{public, location:escape_only}s, "system":%{public, location:escape_only}s, "IOPlatformSerialNumber":%{private, location:escape_only}s}
Lock time debugging is enabled
CL: locationd main - teardown
{"msg%{public}.0s":"locationd main - teardown", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"Warning, Legacy logging enabled", "radar":%{public}d}
{"msg%{public}.0s":"Invalid radar", "radar":%{public}d}
{"msg%{public}.0s":"#Warning, Legacy log settings found", "key":%{public, location:escape_only}s, "clearing":%{public}hhd}
CLGyroCalibrationDatabaseLocalMultiRun insert x,%f,y,%f,z,%f,temperature,%f
fBuilding,%d
Wipe database during a build.
CLGyroCalibrationDatabaseLocalMultiRun startFactoryGYTT
CLGyroCalibrationDatabaseLocalMultiRun getLastMiniCalibration
GyroBiasFit: slope,%f,%f,%f,intercept,%f,%f,%f,seconds,%f
SQL error: %{public}s
Dropping GyroMultiCalibration.
fNextRound,%d,fIsUrgentCal,%d
nonFactoryRoundCount,%d,kRoundLimit,%d,roundToRemove,%d,fIsUrgentCal,%d
Ending UrgentCal run, double entering this round
Double entry: nonFactoryRoundCount,%d,kRoundLimit,%d,roundToRemove,%d,secondRoundNum,%d
ComputeFullBias: x,%f,y,%f,z,%f
ComputeIntercept: x,%f,y,%f,z,%f
Starting gyro calibration, user initiated, %d
Stopped gyro calibration
{"msg%{public}.0s":"#NearbydIfMgr,suspending silo until IDS becomes available"}
{"msg%{public}.0s":"#NearbydIfMgr,waiting on IDS to become available"}
{"msg%{public}.0s":"#NearbydIfMgr IDS service failed to initialize", "Error":%{public, location:escape_only}@}
{"msg%{public}.0s":"#NearbydIfMgr,IDS became available so resuming silo"}
{"msg%{public}.0s":"#NearbydIfMgr,beginService"}
{"msg%{public}.0s":"#NearbydIfMgr,addDelegateself queue:[(CLDispatchSilo *)self.universe.silo queue]];"}
{"msg%{public}.0s":"#NearbydIfMgr,Nearby status change", "is nearby":%{public}d}
{"msg%{public}.0s":"#NearbydIfMgr,nearbyDevicesChanged"}
{"msg%{public}.0s":"This delegate cannot be invalidated", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
#Spi, beginService
#Spi , Listener?, %{public}@
#Spi, endService
#Spi, Connection interrupted for process %d
#Spi, Connection invalidated for process %d
#Spi, New connection by process id %d resumed
CL: _CLDaemonGetAppsUsingLocation (Fallback)
{"msg%{public}.0s":"_CLDaemonGetAppsUsingLocation", "event":%{public, location:escape_only}s}
#Spi, connecting process isn't entitled, they shall not pass
CL: _CLDaemonGetTechnologiesInUse (Fallback)
{"msg%{public}.0s":"_CLDaemonGetTechnologiesInUse", "event":%{public, location:escape_only}s}
CL: _CLDaemonGetGnssBandsInUse (Fallback)
{"msg%{public}.0s":"_CLDaemonGetGnssBandsInUse", "event":%{public, location:escape_only}s}
CL: _CLDaemonSetLocationDefault (Fallback)
{"msg%{public}.0s":"_CLDaemonSetLocationDefault", "event":%{public, location:escape_only}s}
#Spi, Setting default %@ from %s
CL: _CLDaemonGetLocationDefault (Fallback)
{"msg%{public}.0s":"_CLDaemonGetLocationDefault", "event":%{public, location:escape_only}s}
#Spi, Getting default %@ for %s
CL: _CLDaemonTimeZoneAtLocation (Fallback)
{"msg%{public}.0s":"_CLDaemonTimeZoneAtLocation", "event":%{public, location:escape_only}s}
CL: _CLDaemonSetAuthorizationStatus (Fallback)
{"msg%{public}.0s":"_CLDaemonSetAuthorizationStatus", "event":%{public, location:escape_only}s}
#Spi, Must provide a bundle identifier or bundle path for which to set location authorization status
CL: _CLDaemonResetAllClients (Fallback)
{"msg%{public}.0s":"_CLDaemonResetAllClients", "event":%{public, location:escape_only}s}
CL: _CLDaemonSetPrivateMode (Fallback)
{"msg%{public}.0s":"_CLDaemonSetPrivateMode", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Spi, private mode changed", "privateModeEnabled":%{public}hhd}
CL: _CLDaemonGetPrivateMode (Fallback)
{"msg%{public}.0s":"_CLDaemonGetPrivateMode", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"getPrivateMode called", "privateMode":%{public}hhd}
CL: _CLDaemonSetLocationServicesEnabled (Fallback)
{"msg%{public}.0s":"_CLDaemonSetLocationServicesEnabled", "event":%{public, location:escape_only}s}
#Spi, %{public}s is setting location services to %{public}s
CL: _CLDaemonGetLocationServicesEnabled (Fallback)
{"msg%{public}.0s":"_CLDaemonGetLocationServicesEnabled", "event":%{public, location:escape_only}s}
CL: _CLDaemonSetAuthorizationPromptMapDisplayEnabled (Fallback)
{"msg%{public}.0s":"_CLDaemonSetAuthorizationPromptMapDisplayEnabled", "event":%{public, location:escape_only}s}
#Spi, %{public}s is setting authorization prompt map display to %{public}s
CL: _CLDaemonGetAuthorizationPromptMapDisplayEnabled (Fallback)
{"msg%{public}.0s":"_CLDaemonGetAuthorizationPromptMapDisplayEnabled", "event":%{public, location:escape_only}s}
CL: _CLDaemonSetGestureServiceEnabled (Fallback)
{"msg%{public}.0s":"_CLDaemonSetGestureServiceEnabled", "event":%{public, location:escape_only}s}
#Spi, %s is setting ear gesture service to %s
CL: _CLSetClientTransientAuthorizationInfo (Fallback)
{"msg%{public}.0s":"_CLSetClientTransientAuthorizationInfo", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"setting temporary authorization status info for client", "name":%{public, location:escape_only}s}
CL: _CLGetClientTransientAuthorizationInfo (Fallback)
{"msg%{public}.0s":"_CLGetClientTransientAuthorizationInfo", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"getting temporary authorization status info for client, if applicable", "name":%{public, location:escape_only}s}
{"msg%{public}.0s":"temporary auth replying for client", "name":%{public, location:escape_only}s}
CL: _CLInternalChangeClientAuthorizationTime (Fallback)
{"msg%{public}.0s":"_CLInternalChangeClientAuthorizationTime", "event":%{public, location:escape_only}s}
CL: _CLInternalTriggerExpiredAuthorizationPurge (Fallback)
{"msg%{public}.0s":"_CLInternalTriggerExpiredAuthorizationPurge", "event":%{public, location:escape_only}s}
CL: _CLDaemonGetGestureServiceEnabled (Fallback)
{"msg%{public}.0s":"_CLDaemonGetGestureServiceEnabled", "event":%{public, location:escape_only}s}
CL: _CLDaemonPingDaemon (Fallback)
{"msg%{public}.0s":"_CLDaemonPingDaemon", "event":%{public, location:escape_only}s}
#Spi, Pinged by external process %s
CL: _CLDaemonGetPrecisionPermission (Fallback)
{"msg%{public}.0s":"_CLDaemonGetPrecisionPermission", "event":%{public, location:escape_only}s}
CL: _CLDaemonGetAuthorizationStatus (Fallback)
{"msg%{public}.0s":"_CLDaemonGetAuthorizationStatus", "event":%{public, location:escape_only}s}
#Spi, Authorization status for %s is %s
CL: getIncidentalUseModeForBundleID:forBundleID:orBundlePath:replyBlock: (Fallback)
{"msg%{public}.0s":"getIncidentalUseModeForBundleID:forBundleID:orBundlePath:replyBlock:", "event":%{public, location:escape_only}s}
#UsageWin, setting incidentalUseMode to: %d
CL: registerCircularInterestZoneWithId: (Fallback)
{"msg%{public}.0s":"registerCircularInterestZoneWithId:", "event":%{public, location:escape_only}s}
#Spi registerCircularInterestZone, Must provide a bundle identifier or bundle path
{"msg%{public}.0s":"#Spi, Register Circular InterestZone", "client":%{public, location:escape_only}s, "ZoneName":%{public, location:escape_only}s}
CL: registerPhenolicInterestZoneWithId: (Fallback)
{"msg%{public}.0s":"registerPhenolicInterestZoneWithId:", "event":%{public, location:escape_only}s}
#Spi registerPhenolicInterestZone, Must provide a bundle identifier or bundle path
{"msg%{public}.0s":"#Spi, Register Phenolic InterestZone", "client":%{public, location:escape_only}s, "ZoneName":%{public, location:escape_only}s}
CL: setRelevance:forInterestZoneWithName: (Fallback)
{"msg%{public}.0s":"setRelevance:forInterestZoneWithName:", "event":%{public, location:escape_only}s}
#Spi setRelevanceForInterestZone, Must provide a bundle identifier or bundle path
{"msg%{public}.0s":"#Spi, SetRelevanceForInterestZone", "client":%{public, location:escape_only}s, "ZoneName":%{public, location:escape_only}s}
CL: deleteInterestZoneWithId: (Fallback)
{"msg%{public}.0s":"deleteInterestZoneWithId:", "event":%{public, location:escape_only}s}
#Spi deleteInterestZoneWithId, Must provide a bundle identifier or bundle path
{"msg%{public}.0s":"#Spi, delete interest zone", "client":%{public, location:escape_only}s, "ZoneName":%{public, location:escape_only}s}
CL: _CLDaemonPerformMigration (Fallback)
{"msg%{public}.0s":"_CLDaemonPerformMigration", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Spi, triggered migration", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f", "clientName":%{public, location:escape_only}s}
CL: _CLDaemonShutdownDaemon (Fallback)
{"msg%{public}.0s":"_CLDaemonShutdownDaemon", "event":%{public, location:escape_only}s}
#Spi, Daemon shutdown requested by %s
CL: _CLDaemonDisplayStatistics (Fallback)
{"msg%{public}.0s":"_CLDaemonDisplayStatistics", "event":%{public, location:escape_only}s}
#Spi, Daemon stats requested by %s
CL: _CLDaemonDumpLogs (Fallback)
{"msg%{public}.0s":"_CLDaemonDumpLogs", "event":%{public, location:escape_only}s}
#Spi, Log dump requested by %s: %@
CL: _CLDaemonCopyLastLog (Fallback)
{"msg%{public}.0s":"_CLDaemonCopyLastLog", "event":%{public, location:escape_only}s}
#Spi, %s requested to copy locationd's last logs to crash reporter
CL: _CLDaemonGetMonitoredRegions (Fallback)
{"msg%{public}.0s":"_CLDaemonGetMonitoredRegions", "event":%{public, location:escape_only}s}
#Spi, #warning Couldn't get fences for client key %s
{"msg%{public}.0s":"#Spi, #error Unable to encode vertices", "error":%{public, location:escape_only}@}
CL: checkAndExerciseAuthorizationForBundleID:orBundlePath:services:replyBlock:
{"msg%{public}.0s":"checkAndExerciseAuthorizationForBundleID:orBundlePath:services:replyBlock:", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"checkAndExerciseAuthorization response is NO", "client":%{public, location:escape_only}s, "requiredServices":%{public}ld, "authContext":%{public, location:escape_only}@}
{"msg%{public}.0s":"checkAndExerciseAuthorization response is YES", "client":%{public, location:escape_only}s, "requiredServices":%{public}ld, "authContext":%{public, location:escape_only}@}
CL: _CLDaemonGetLocation (Fallback)
{"msg%{public}.0s":"_CLDaemonGetLocation", "event":%{public, location:escape_only}s}
#Warning #Spi, GetLocation rejected for '%s(%d)': no way to establish effective authorization
#Spi, GetLocation rejected for '%s': insufficient effective authorization
{"msg%{public}.0s":"#Spi, altered getLocation", "location":%{private, location:CLClientLocation}.*P, "timestampGps":"%{private}f", "machTime":"%{private}f", "gotLocation":%{private}hhd, "specialCoordinateLat":"%{private}f", "specialCoordinateLon":"%{private}f", "specialHorizontalAccuracy":"%{private}f"}
CL: _CLDaemonGetGroundAltitude (Fallback)
{"msg%{public}.0s":"_CLDaemonGetGroundAltitude", "event":%{public, location:escape_only}s}
CL: _CLDaemonGetStatusBarIconState (Fallback)
{"msg%{public}.0s":"_CLDaemonGetStatusBarIconState", "event":%{public, location:escape_only}s}
Unexpected iconState: %d
CL: _CLDaemonSetStatusBarIconEnabledForEntityClass (Fallback)
{"msg%{public}.0s":"_CLDaemonSetStatusBarIconEnabledForEntityClass", "event":%{public, location:escape_only}s}
#Spi, %s is setting the status bar icon enabled state for %u to %d
CL: _CLDaemonGetStatusBarIconEnabledForEntityClass (Fallback)
{"msg%{public}.0s":"_CLDaemonGetStatusBarIconEnabledForEntityClass", "event":%{public, location:escape_only}s}
#Spi, %s retrieved the status bar icon enabled state for %u
CL: _CLDaemonSetMapMatchingRouteHint (Fallback)
{"msg%{public}.0s":"_CLDaemonSetMapMatchingRouteHint", "event":%{public, location:escape_only}s}
#Spi,RouteHints,setMapMatchingRouteHint,received,%{public}lu,routeType,%{public}d,stepType,%{public}d,source,%{public}s
CL: getAccessoryTypeBitSetWithReplyBlock (Fallback)
{"msg%{public}.0s":"getAccessoryTypeBitSetWithReplyBlock", "event":%{public, location:escape_only}s}
#Spi, requires entitlement '%{public}@' with bundle identifier '%{public}@' or bundle path '%{public}@'
#Spi, Called for bundle identifier %s
#Spi, Called for bundle path %s
{"msg%{public}.0s":"client getting effective client name", "bundleId":%{public, location:escape_only}@, "bundlePath":%{public, location:escape_only}@}
CL: _CLDaemongetPipelinedCache (Fallback)
{"msg%{public}.0s":"_CLDaemongetPipelinedCache", "event":%{public, location:escape_only}s}
getPipelinedCacheWithReply cancelling previous delete due to new request
getPipelinedCacheWithReply FAILED to find root uid and _analyticsusers gid
getPipelinedCacheWithReply destination root path exists, deleting directory now...
getPipelinedCacheWithReply removal of %@ FAILED with error %@
getPipelinedCacheWithReply created destination root path %@
getPipelinedCacheWithReply FAILED to create destination root path %@ with error %@
getPipelinedCacheWithReply successfully copied %@ to %@
getPipelinedCacheWithReply successfully changed owner of %@ to TTR accessible
getPipelinedCacheWithReply FAILED to change owner of %@ to TTR accessible
getPipelinedCacheWithReply FAILED to copy %@ to %@. Check PROTECTION CLASS of the file and device protection state.
getPipelinedCacheWithReply deleting %@ in %llu seconds
getPipelinedCacheWithReply %@ deleted
CL: _CLDaemonSetAuthorizationStatusByType (Fallback)
{"msg%{public}.0s":"_CLDaemonSetAuthorizationStatusByType", "event":%{public, location:escape_only}s}
#Spi, Must provide a bundle identifier or bundle path if setting temporay authorization not by LocationButton
CL: _CLDaemonGetActivities (Fallback)
{"msg%{public}.0s":"_CLDaemonGetActivities", "event":%{public, location:escape_only}s}
#Spi, #warning _CLDaemonGetActivityAlarms called without support for activity alarms
{"msg%{public}.0s":"#Spi, Invalid authorization", "auth":%{public, location:CLClientAuthorizationStatus}lld}
{"msg%{public}.0s":"#Spi, Invalid corrective compensation state", "compensate":%{public, location:CLClientCorrectiveCompensation}lld}
CL: updateCorrectiveCompensationChoiceForOutstandingPrompt:replyBlock: (Fallback)
{"msg%{public}.0s":"updateCorrectiveCompensationChoiceForOutstandingPrompt:replyBlock:", "event":%{public, location:escape_only}s}
CL: setIncidentalUseMode:forBundleID:orBundlePath:replyBlock: (Fallback)
{"msg%{public}.0s":"setIncidentalUseMode:forBundleID:orBundlePath:replyBlock:", "event":%{public, location:escape_only}s}
#Spi, Must provide a bundle identifier or bundle path for which to set incidental use mode
CL: _CLDaemonGyroCalibrationDatabaseSupportsMiniCalibration (Fallback)
{"msg%{public}.0s":"_CLDaemonGyroCalibrationDatabaseSupportsMiniCalibration", "event":%{public, location:escape_only}s}
CL: _CLDaemonSetBackgroundIndicatorEnabled (Fallback)
{"msg%{public}.0s":"_CLDaemonSetBackgroundIndicatorEnabled", "event":%{public, location:escape_only}s}
#Spi, both bundle-id and bundle-identifier are either zero-length or nil
CL: _CLDaemonOscarTimeSync (Fallback)
{"msg%{public}.0s":"_CLDaemonOscarTimeSync", "event":%{public, location:escape_only}s}
CL: _CLPassKitNotifyPayment (Fallback)
{"msg%{public}.0s":"_CLPassKitNotifyPayment", "event":%{public, location:escape_only}s}
CL: _CLWeatherNotifyForecast (Fallback)
{"msg%{public}.0s":"_CLWeatherNotifyForecast", "event":%{public, location:escape_only}s}
CL: _CLDaemonGetMicroLocationInternalVersion (Fallback)
{"msg%{public}.0s":"_CLDaemonGetMicroLocationInternalVersion", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Spi,MicroLocationInternalVersion,#warning Couldn't get MicroLocation Internal Version"}
CL: _CLDaemonGetZaxisStats (Fallback)
{"msg%{public}.0s":"_CLDaemonGetZaxisStats", "event":%{public, location:escape_only}s}
{"msg%{public}.0s":"#Spi,,ZaxisStats,#warning Couldn't get vector capacity to fetch data"}
{"msg%{public}.0s":"#Spi,ZaxisStats,#warning dictionary allocation failed"}
Removing outliers from database.
Insert into uncached database.
Client registered, caching database
No more clients, flushing cache to database
Database should be cached
CLGyroCalibrationDatabaseLocal insert x,%{public}f,y,%{public}f,z,%{public}f,temperature,%{public}f
Reading database into non-empty cache.
Attempting to write zero entries to Gyro database.
Creating GyroCalibrationDatabaseLocal with isNonUI,%{public}u, enableGyroNonlinearCalibration,%{public}u, enableGyroLinearCalibration,%{public}u,enableGyroMultiRunCalibration,%{public}u, gyroNonlinearity,%{public}u, gyroMultiRunCalibration,%{public}u
Offsetting time by %{private}f
Writing files to %@.
Unable to create writer.
Recording working directory already exists. This should never happen.
Unable to create recording working directory, error: %{public}@
{"msg%{public}.0s":"Working directory should only ever be set once.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Adding file to be sent: %@
{"msg%{public}.0s":"Duplicate creation of accelerometer listener.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Duplicate creation of rotation rate listener.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Duplicate creation of heart rate listener.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Duplicate creation of odometer listener.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Duplicate creation of watch orientation listener.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Duplicate creation of natalimetry listener.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"Duplicate creation of magnetometer listener.", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Tearing down listeners.
Recording accelerometer stopped.
Recording rotation rate stopped.
Recording magnetometer stopped.
Recording pressure stopped.
Recording fast accelerometer stopped.
Offsetting elevation by %{private}f
Received: WorkoutEventType: %ld WorkoutType: %ld Location: %ld
WiFi scan entry,id,%d,rssi,%d,timestamp,%f,isMoving,%{private}d
Failed to query HealthKit for: %{public}@, error: %{public}@
Found HK Sample: %{private}@
Unable to find HealthKit results for: %{public}@
RawSpeedToKValue entry,begin,%f,end,%f,kValue,%f,state,%d
StepCadenceToStrideLength entry,begin,%f,end,%f,strideLength,%f,state,%d
Unable to delete recording working directory, error: %{public}@
Start factory GYTT
{"msg%{public}.0s":"db doesn't exist", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
{"msg%{public}.0s":"initialization function expected with no pending samples", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
flushPendingError: %{public}s
Factory data persisted in gyro database, %zu samples added.
%f,%f,%f,%f
Point gyro database load, SQL error: %{public}s
Point gyro database flushed, %zu samples added.
Point gyro pending samples thinned.  %zu samples reduced to %zu.
Point gyro database prune, deleted %zu samples, %zu remain.
Failed to log gyro non factory cal from db because the temperature range is either unintialized or invalid.
Failed to log gyro non factory cal because the number of samples (%zu) exceeds the max limit (%zu).
Initializing CLRecordingTriggerBase instance
Unable to start recording, could not start recording.
{"msg%{public}.0s":"How did we have an assertion if we weren't recording?", "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Deferred stop already created and scheduled.
Unable to create deferred stop timer, not currently recording.
Scheduling stop for %f seconds in the future.
Stopping Recording
Publishing Recording
Initializing CLWorkoutRecorderTrigger instance
Setting up workout recorder trigger listener.
Tearing down workout recorder trigger listener.
Received an AP escalation.
Received an AP de-escalation.
Canceling deferred stop.
isSupported Flags - disable: %d, alwaysOn: %d, iha: %d
Beginning service.
Ending service.
Unable to start recording, no longer allowed.
Unable to start recording, no working directory.
Unable to start recording, not enough free space in working directory.
Unable to start recording, already recording.
Unable to start recording, no publisher.
Unable to start recording, publisher is not ready to publish.
Unable to start recording, session already being captured.
Not recording, rate limit reached.
Can Start Recording
Deferring publishing of recording until device is unlocked.
Deferring publishing of recording until publisher is created.
Unable to publish recording, no longer allowed.
Unable to aquire token, no publisher.
Unable to aquire token. Filtered out due to server side sampling rate.
Unable to aquire token due to system side sampling rate.
Unable to delete working directory, error: %{public}@
Unable to create working directory, path exists as a file, path: %{public}@
Unable to create working directory, error: %{public}@
Unable to get free space of working directory. Assuming no free space, path: %{public}@, error: %{public}@
Working directory free space: %{public}@ bytes.
Received configuration: %{private}@
{"msg%{public}.0s":"#warning CLPrivacyManager is disabled by defaults write!"}
{"msg%{public}.0s":"CLISP bug: CLPrivacyManager still receiving messages after invalidation by the service vendor"}
CL: Scheduling vacuum
{"msg%{public}.0s":"Scheduling vacuum", "event":%{public, location:escape_only}s, "reason":%{public, location:escape_only}@}
{"msg%{public}.0s":"#warning Not vacuuming due to defaults-based disablement"}
{"msg%{public}.0s":"Deferring previously scheduled vacuum"}
{"msg%{public}.0s":"Vacuuming all"}
{"msg%{public}.0s":"failed to copy criteria", "encryptionClass":%{public, location:escape_only}@}
{"msg%{public}.0s":"retrying activity", "encryptionClass":%{public, location:escape_only}@, "reason":%{public}d}
{"msg%{public}.0s":"failed to get activity", "encryptionClass":%{public, location:escape_only}@}
CL: CLPrivacyManager activity handler
{"msg%{public}.0s":"CLPrivacyManager activity handler", "event":%{public, location:escape_only}s, "job identifier":%{public, location:escape_only}@, "state":%{public}ld}
{"msg%{public}.0s":"Unexpected activity state. XPC bug?"}
{"msg%{public}.0s":"activity deferred", "encryptionClass":%{public, location:escape_only}@}
{"msg%{public}.0s":"Vacuuming database", "class":%{public, location:escape_only}@}
{"msg%{public}.0s":"Unexpected encryption class", "class":%{public, location:escape_only}@, "event":%{public, location:escape_only}s, "condition":%{private, location:escape_only}s}
Dumping gyro calibration database
No gyroCal database file set in preferences. Using the default database.
Using gyroCal database file: %s.
Max magnitude difference (%f), Max inclination difference (%f), CompassBiasClusteringEnabled (%d), CompassBiasTemporalVarianceCheck (%d)
CompassBiasDB, begin lookups
Compass recently calibrated.  Using cached bias: (%f, %f, %f) with level: (%d).
search found: bestfit (%+.3f/%+.3f/%+.3f) bias (%+.3f/%+.3f/%+.3f) level (%d) using magneticField (%+.3f/%+.3f/%+.3f) acceleration (%+.3f/%+.3f/%+.3f) from %d entries. No: %llu. IsCluster: %d, 2D Check,%d
search failure: no result, saw bestfit (%+.3f/%+.3f/%+.3f) bias (%+.3f/%+.3f/%+.3f) level (%d) using magneticField (%+.3f/%+.3f/%+.3f) acceleration (%+.3f/%+.3f/%+.3f) from %d entries
search complete failure: no results from %d entries
CompassBiasDB, setBias has novel information, countdown to clustering: %d
CompassBiasDB, setBias is not novel.
Dumping compass database
CompassBiasDB, clusteralgo, started
CompassBiasDB, clusteralgo, finished, numbers of clusters found, %zu,  %d
search complete failure: too much variation in bias within a short time period, mean (%.3f) max (%.3f)
CompassBiasDB, lookup, rowid, %llu, bias, %.3f, %.3f, %.3f, mag, %.3f, %.3f, incl, %.3f, %.3f, magDiff, %.3f, inclDiff, %.3f, score, %.3f, betterMatch, %d
CompassBiasDB, lookupBiasIndividually
Best fit values (will update timestamp): %llu, %f, %f
Clearing obsolete bias entries
search comparison: db level (%d) db age (%.3f), db mag (%.3f) est mag (%.3f) delta mag (%.3f), db inc (%.3f) est inc (%.3f) delta inc (%.3f)
CL: CLCompassDatabaseController::onClearBiasTimer
{"msg%{public}.0s":"CLCompassDatabaseController::onClearBiasTimer", "event":%{public, location:escape_only}s, "this":"%{public}p"}
GyroBias received by DeviceMotion in daemon
#Warning geomagnetic provider received a stale location <%+.8f,%+.8f,%+.3f> @ %.3f
current location is still fresh, geomagnetic data is not re-calculated
geomagnetic information calculated for <%+.8f,%+.8f,%+.3f> @ %.3f, declination %f inclination %f will expire @ %.3f
Type,%s,lat,%+.8f,long,%+.8f,alt,%+.3f,x,%.3f,y,%.3f,z,%.3f,m,%.3f,h,%.3f,dec,%+.3f,inc,%+.3f,
#Warning no geomagnetic information available for <%+.8f,%+.8f,%+.3f>
loadGeomagneticDataFromCache already loaded
loadGeomagneticDataFromCache not loading because deauthorized
loadGeomagneticDataFromCache loading
recovered geomagnetic information @ %{public}.3f
caching geomagnetic information @ %{public}.3f
current location is still fresh, not requesting coarse location for computing geomagnetic data, gmmTimestamp %.1f gmmFreshnessDuration %.1f
avoiding frequent coarse location request for computing geomagnetic data, fLastCoarseLocationRequestTimestamp %.1f minimumLocationRequestInterval %.1f
requesting coarse location for computing geomagnetic data
stopping coarse location for computing geomagnetic data
Client requested notification %d
registered as location spectator to compute geomagnetic data
unregistered as location spectator to compute geomagnetic data
declination calculation failed @ %{public}lf (%{public}f)
invalidateGeomagneticField already invalid
invalidateGeomagneticField invalidating
Geomagnetic model data invalidated. Sending notification with timestamp %f
location services is now disabled; invalidating geomagnetic field data
CL: CLGeomagneticModelProviderDaemon::onStatusNotification
{"msg%{public}.0s":"CLGeomagneticModelProviderDaemon::onStatusNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLGeomagneticModelProviderDaemon::onClientNotification
{"msg%{public}.0s":"CLGeomagneticModelProviderDaemon::onClientNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
CL: CLGeomagneticModelProviderDaemon::onLocationNotification
{"msg%{public}.0s":"CLGeomagneticModelProviderDaemon::onLocationNotification", "event":%{public, location:escape_only}s, "this":"%{public}p"}
Nonlinear gyro database computed fit.
Setting property %s to %f
Last cover open timestamp = %f
Initializing CLWorkoutRecorderPublisher instance
Unable to delete publishing directory directory, error: %{public}@
Unable to create publishing directory, error: %@
Publishing data files.
Unable to publish, publisher not active.
Unable to send file, unable to create message for server.
Created request for file: %@, task: %@
Error starting message, error: %{public}@
Error appending file to message, file: %{public}@, error: %{public}@
Error finalizing message, error: %{public}@
Unable to move publishing file, error: %@
Successfully created message with UUID: %{private}@, URL: %{public}@
Registration request already in progress.
Created request for registration.
_subjectUUID cached copy %@
clearing empty uuid saved to cache
Unable to parse response for register subject, error: %@
Successfully registered device.
Got invalid response from server on registration. subjectId or token nil.
Unable to register subject, statusCode: %{public}ld, error: %{public}@, response: %{public}@
Unable to get configuration, statusCode: %{public}ld, error: %{public}@, response: %{public}@
Unable to remove file: %{public}@, error: %{public}@
Successfully uploaded file: %@, response: %@
Error when uploading file, file: %{public}@, error: %{public}@, response: %{public}@, responseBody: %{public}@
Request completed with task: %@ and error: %@ and id: %@
%s table creation.
{"msg%{public}.0s":"CLClusterCompassCalibrationTable::deleteAll", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f"}
{"msg%{public}.0s":"CLCompassCalibrationTable::clearBias", "event":%{public, location:escape_only}s, "begin_mach":%{public}llu, "end_mach":%{public}llu, "elapsed_s":"%{public}.09f"}
Initializing CLDrivingRecorderTrigger instance
Setting up driving recorder trigger listener.
Deferred start already scheduled.
Unable to schedule start, currently recording
Scheduling start for %f seconds in the future.
Tearing down driving recorder trigger listener.
Received high confidence driving notification.
Received low confidence driving notification.
Linear gyro database computed fit.
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>BuildMachineOSBuild</key>
<string>20A241123</string>
<key>CFBundleDevelopmentRegion</key>
<string>English</string>
<key>CFBundleExecutable</key>
<string>locationd</string>
<key>CFBundleIdentifier</key>
<string>com.apple.locationd</string>
<key>CFBundleInfoDictionaryVersion</key>
<string>6.0</string>
<key>CFBundlePackageType</key>
<string>APPL</string>
<key>CFBundleShortVersionString</key>
<string>2665.0.3</string>
<key>CFBundleSignature</key>
<string>????</string>
<key>CFBundleSupportedPlatforms</key>
<array>
<string>WatchSimulator</string>
</array>
<key>CFBundleVersion</key>
<string>2665.0.3</string>
<key>DTCompiler</key>
<string>com.apple.compilers.llvm.clang.1_0</string>
<key>DTPlatformBuild</key>
<string>13A191</string>
<key>DTPlatformName</key>
<string>watchsimulator</string>
<key>DTPlatformVersion</key>
<string>8.3</string>
<key>DTSDKBuild</key>
<string>19S5026b</string>
<key>DTSDKName</key>
<string>watchsimulator8.3.internal</string>
<key>DTXcode</key>
<string>1300</string>
<key>DTXcodeBuild</key>
<string>13A191</string>
<key>MinimumOSVersion</key>
<string>8.3</string>
<key>UIDeviceFamily</key>
<array>
<integer>4</integer>
</array>
</dict>
</plist>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
<key>application-identifier</key>
<string>com.apple.locationd</string>
<key>aps-connection-initiate</key>
<true/>
<key>backupd-connection-initiate</key>
<true/>
<key>com.apple.BTServer.appleMfgDataScanner</key>
<true/>
<key>com.apple.Carousel.statusOverlay</key>
<true/>
<key>com.apple.CommCenter.fine-grained</key>
<array>
<string>sms</string>
<string>spi</string>
<string>identity</string>
<string>bb-xpc</string>
<string>phone</string>
</array>
<key>com.apple.CompanionLink</key>
<true/>
<key>com.apple.CoreLocation.PrivateMode</key>
<true/>
<key>com.apple.CoreRoutine.LocationOfInterest</key>
<true/>
<key>com.apple.CoreRoutine.Prediction</key>
<true/>
<key>com.apple.CoreRoutine.ScenarioTrigger</key>
<true/>
<key>com.apple.CoreRoutine.StoredLocation</key>
<true/>
<key>com.apple.CoreRoutine.Visit</key>
<true/>
<key>com.apple.SystemConfiguration.SCPreferences-write-access</key>
<array>
<string>com.apple.AutoWake.xml</string>
</array>
<key>com.apple.accessoryupdater.uarp</key>
<true/>
<key>com.apple.accounts.appleaccount.fullaccess</key>
<true/>
<key>com.apple.authkit.client.private</key>
<true/>
<key>com.apple.backboard.client</key>
<true/>
<key>com.apple.backboardd.estimatedProximityDetection</key>
<true/>
<key>com.apple.backboardd.proximityDetection</key>
<true/>
<key>com.apple.bluetooth.internal</key>
<true/>
<key>com.apple.bluetooth.system</key>
<true/>
<key>com.apple.carousel.nonmatchingsessions</key>
<true/>
<key>com.apple.carousel.onWristMonitor.actions</key>
<array>
<string>monitor</string>
</array>
<key>com.apple.carousel.viewonwakeaccess</key>
<true/>
<key>com.apple.companionappd.connect.allow</key>
<true/>
<key>com.apple.coreduetd.allow</key>
<true/>
<key>com.apple.coreduetd.context</key>
<true/>
<key>com.apple.developer.extension-host.widget-extension</key>
<true/>
<key>com.apple.developer.healthkit</key>
<true/>
<key>com.apple.developer.icloud-container-environment</key>
<string>Production</string>
<key>com.apple.developer.icloud-services</key>
<array>
<string>CloudKit</string>
</array>
<key>com.apple.distributedsensingd-motionState</key>
<true/>
<key>com.apple.geoservices.navigation_info</key>
<true/>
<key>com.apple.geoservices.preload</key>
<true/>
<key>com.apple.geoservices.restricted-tiles</key>
<array>
<string>coarselocation</string>
</array>
<key>com.apple.geoservices.traffic_probe</key>
<true/>
<key>com.apple.gpsd</key>
<true/>
<key>com.apple.healthlite.spi</key>
<true/>
<key>com.apple.hid.manager.user-access-protected</key>
<true/>
<key>com.apple.hid.system.fast-path-motion-event-privileged</key>
<true/>
<key>com.apple.icloud.searchpartyd.advertisementcache.access</key>
<true/>
<key>com.apple.icloud.searchpartyd.advertisementcache.write</key>
<true/>
<key>com.apple.icloud.searchpartyd.beaconmanager</key>
<true/>
<key>com.apple.icloud.searchpartyd.finderstatemanager.access</key>
<true/>
<key>com.apple.icloud.searchpartyd.ownersession</key>
<true/>
<key>com.apple.icloud.searchpartyd.pairingmanager</key>
<true/>
<key>com.apple.idsremoteurlconnectionagent.embedded.auth</key>
<true/>
<key>com.apple.itunesstored.private</key>
<true/>
<key>com.apple.keystore.sik.access</key>
<true/>
<key>com.apple.location.region_low_power</key>
<true/>
<key>com.apple.locationd.activity</key>
<true/>
<key>com.apple.locationd.advertise-beacon</key>
<true/>
<key>com.apple.locationd.authorizeapplications</key>
<true/>
<key>com.apple.locationd.bbtimefreqtransfer_callback</key>
<true/>
<key>com.apple.locationd.configure</key>
<true/>
<key>com.apple.locationd.effective_bundle</key>
<true/>
<key>com.apple.locationd.emergency_enabler</key>
<true/>
<key>com.apple.locationd.emergencyplace_inference</key>
<true/>
<key>com.apple.locationd.integritycheck</key>
<true/>
<key>com.apple.locationd.mock_testing</key>
<true/>
<key>com.apple.locationd.motion_alarms</key>
<true/>
<key>com.apple.locationd.natalimetry</key>
<true/>
<key>com.apple.locationd.on_body_detection</key>
<true/>
<key>com.apple.locationd.place_inference</key>
<true/>
<key>com.apple.locationd.private_info</key>
<true/>
<key>com.apple.locationd.prompt_behavior</key>
<true/>
<key>com.apple.locationd.ranging</key>
<true/>
<key>com.apple.locationd.rebuild_gytt</key>
<true/>
<key>com.apple.locationd.region_fence_handoff</key>
<true/>
<key>com.apple.locationd.region_while_nearby</key>
<true/>
<key>com.apple.locationd.route_hint</key>
<true/>
<key>com.apple.locationd.sedentary_timer</key>
<true/>
<key>com.apple.locationd.simulation</key>
<true/>
<key>com.apple.locationd.spectator</key>
<true/>
<key>com.apple.locationd.status</key>
<true/>
<key>com.apple.locationd.time_zone</key>
<true/>
<key>com.apple.locationd.usage_oracle</key>
<true/>
<key>com.apple.locationd.vehicle_data</key>
<true/>
<key>com.apple.managedconfiguration.profiled-access</key>
<true/>
<key>com.apple.mobileactivationd.spi</key>
<true/>
<key>com.apple.multitasking.unlimitedassertions</key>
<true/>
<key>com.apple.nano.nanoregistry</key>
<true/>
<key>com.apple.nearbyd.diagnostics</key>
<true/>
<key>com.apple.nearbyd.xpc</key>
<true/>
<key>com.apple.nearbyinteraction.background</key>
<true/>
<key>com.apple.osanalytics.otatasking-service-access</key>
<true/>
<key>com.apple.pairedsync.progressObserver</key>
<true/>
<key>com.apple.pipelined</key>
<array>
<string>positioning</string>
</array>
<key>com.apple.private.CacheDelete</key>
<array>
<string>CLIENT_ENTITLEMENT</string>
<string>SERVICE_ENTITLEMENT</string>
</array>
<key>com.apple.private.MobileGestalt.AllowedProtectedKeys</key>
<array>
<string>UniqueDeviceID</string>
<string>ArrowChipID</string>
<string>ArrowUniqueChipID</string>
</array>
<key>com.apple.private.accessories.showallconnections</key>
<true/>
<key>com.apple.private.applemediaservices</key>
<true/>
<key>com.apple.private.assets.accessible-asset-types</key>
<array>
<string>com.apple.MobileAsset.CoreLocationConfig</string>
</array>
<key>com.apple.private.carkit.dnd</key>
<true/>
<key>com.apple.private.cloudkit.serviceNameForContainerMap</key>
<dict>
<key>com.apple.vo2max</key>
<string>com.apple.vo2max</string>
</dict>
<key>com.apple.private.cloudkit.spi</key>
<true/>
<key>com.apple.private.externalaccessory.showallaccessories</key>
<true/>
<key>com.apple.private.healthkit</key>
<true/>
<key>com.apple.private.healthkit.authorization_bypass</key>
<true/>
<key>com.apple.private.healthkit.local-device-source</key>
<true/>
<key>com.apple.private.healthkit.medicaliddata</key>
<true/>
<key>com.apple.private.healthkit.preferred_source</key>
<true/>
<key>com.apple.private.healthkit.source.identities</key>
<array>
<string>com.apple.health.[any-device-uuid]</string>
</array>
<key>com.apple.private.hid.client.event-dispatch</key>
<true/>
<key>com.apple.private.hid.client.event-monitor</key>
<true/>
<key>com.apple.private.hid.client.motion-event-privileged</key>
<true/>
<key>com.apple.private.hid.client.service-protected</key>
<true/>
<key>com.apple.private.ids.messaging</key>
<array>
<string>com.apple.private.alloy.location.motion</string>
<string>com.apple.private.alloy.location.auth</string>
<string>com.apple.private.alloy.location.stream</string>
<string>com.apple.private.alloy.location.usage</string>
<string>com.apple.private.alloy.location.wifitilesync</string>
<string>com.apple.private.alloy.location.motion.livabilityprogram</string>
<string>com.apple.private.alloy.regulatorysync</string>
<string>com.apple.private.alloy.location.fencehandoff</string>
</array>
<key>com.apple.private.ids.messaging.urgent-priority</key>
<array>
<string>com.apple.private.alloy.location.auth</string>
<string>com.apple.private.alloy.location.stream</string>
<string>com.apple.private.alloy.location.motion</string>
<string>com.apple.private.alloy.location.usage</string>
<string>com.apple.private.alloy.location.motion.livabilityprogram</string>
<string>com.apple.private.alloy.regulatorysync</string>
<string>com.apple.private.alloy.location.fencehandoff</string>
</array>
<key>com.apple.private.ids.remotecredentials</key>
<true/>
<key>com.apple.private.imcore.imremoteurlconnection</key>
<true/>
<key>com.apple.private.kernel.override-cpumon</key>
<true/>
<key>com.apple.private.locationpushd.pushtokenregistration</key>
<true/>
<key>com.apple.private.nearbyd.regulatory-assistance</key>
<true/>
<key>com.apple.private.nearbyinteraction.privileged</key>
<true/>
<key>com.apple.private.privacy.accounting.write</key>
<true/>
<key>com.apple.private.security.storage.pipelined</key>
<true/>
<key>com.apple.private.tcc.allow</key>
<array>
<string>kTCCServiceLiverpool</string>
</array>
<key>com.apple.private.tcc.manager.access.read</key>
<array>
<string>kTCCServiceAll</string>
</array>
<key>com.apple.private.tcc.manager.check-by-audit-token</key>
<array>
<string>kTCCServiceAll</string>
</array>
<key>com.apple.private.usernotifications.bundle-identifiers</key>
<array>
<string>com.apple.findmy</string>
<string>com.apple.locationd.LocationNotificationBundle</string>
</array>
<key>com.apple.private.vfs.allow-low-space-writes</key>
<true/>
<key>com.apple.proactive.hero.AppPrediction.predictions</key>
<true/>
<key>com.apple.rootless.storage.sensorkit</key>
<true/>
<key>com.apple.runningboard.process-state</key>
<true/>
<key>com.apple.security.attestation.access</key>
<true/>
<key>com.apple.security.exception.files.absolute-path.read-only</key>
<array>
<string>/private/var/tmp/aud/</string>
</array>
<key>com.apple.security.exception.mach-lookup.global-name</key>
<array>
<string>com.apple.nearbyd.xpc.nearbyinteraction.observer</string>
<string>com.apple.CarPlayApp.user-alerts-service</string>
<string>com.apple.rapport.people</string>
<string>com.apple.locationpushd.pushregistration</string>
<string>com.apple.nearbyd.xpc.diagnostics</string>
<string>com.apple.accessoryupdater.uarp</string>
<string>com.apple.cloudd</string>
<string>com.apple.bluetooth.xpc</string>
<string>com.apple.nearbyd.xpc.nearbyinteraction</string>
<string>com.apple.privacyaccountingd</string>
<string>com.apple.accessories.blepairing</string>
</array>
<key>com.apple.security.network.client</key>
<true/>
<key>com.apple.security.network.server</key>
<true/>
<key>com.apple.security.system-groups</key>
<array>
<string>systemgroup.com.apple.osanalytics</string>
<string>systemgroup.com.apple.sharedpclogging</string>
</array>
<key>com.apple.sensorkit.writer.allow</key>
<array>
<string>com.apple.SensorKit.pedometer.data.watch</string>
<string>com.apple.SensorKit.pedometer.data</string>
<string>com.apple.SensorKit.visit.metrics</string>
<string>com.apple.SensorKit.motion.accelerometer</string>
<string>com.apple.SensorKit.motion.accelerometer.watch</string>
<string>com.apple.SensorKit.motion.gyroscope</string>
<string>com.apple.SensorKit.motion.gyroscope.watch</string>
<string>com.apple.private.SensorKit.fallstatistics</string>
<string>com.apple.private.SensorKit.odometer</string>
<string>com.apple.private.SensorKit.elevation</string>
<string>com.apple.private.SensorKit.heart.rate</string>
<string>com.apple.private.SensorKit.odometer.suitability</string>
<string>com.apple.private.SensorKit.elevation.rawpressure</string>
</array>
<key>com.apple.springboard.CFUserNotification</key>
<true/>
<key>com.apple.springboard.launchapplications</key>
<true/>
<key>com.apple.springboard.launchapplicationswithoptions</key>
<true/>
<key>com.apple.springboard.opensensitiveurl</key>
<true/>
<key>com.apple.springboard.statusbarstyleoverrides</key>
<true/>
<key>com.apple.symptom_diagnostics.report</key>
<true/>
<key>com.apple.systemstatus.publisher.domains</key>
<array>
<string>location</string>
</array>
<key>com.apple.telephonyutilities.callservicesd</key>
<array>
<string>access-calls</string>
</array>
<key>com.apple.timed</key>
<true/>
<key>com.apple.timed.sources</key>
<array>
<string>GPS</string>
<string>LocationServer</string>
<string>HarvestServer</string>
<string>Location</string>
<string>TimeSourceGnssValidPos</string>
<string>TimeSourceGnss</string>
<string>TimeSourceBBTimeTransfer</string>
<string>TimeSourceBBTimeTagging</string>
</array>
<key>com.apple.wifi.events.private</key>
<true/>
<key>com.apple.wifi.manager-access</key>
<true/>
<key>com.apple.wifi.scan.live</key>
<true/>
<key>com.apple.wirelessproxd-location</key>
<true/>
<key>com.apple.wirelessproxd-object-discovery</key>
<true/>
<key>fairplay-client</key>
<string>465671667</string>
<key>keychain-access-groups</key>
<array>
<string>apple</string>
<string>com.apple.distributedsensing</string>
</array>
<key>platform-application</key>
<true/>
<key>seatbelt-profiles</key>
<array>
<string>locationd</string>
</array>
</dict>
</plist>
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
U@qvk
?pB!
jIG9
^@Qf
h9x.@
:$3@
&TpxA
_[?}
@wKr
+cs@*
!;oc
?dWZF
obHN&n
@D5%Y
%@W
W9@9
Am!@M
`@^M
c@F_A
%@x*
{K9_
?#i7
@Ef.py,
?;R}
?*oG8-
vMHk
5=((
n@(b
?333333
%@mr
U,~S
?zo
@\sG
KXo@
_@RC
_!se
e5]Ot]
?-$`tys
 |(
@L@R
!6X8
U1e?
~k;_@
#bJ$
:?/@
'OYM
?#J{
'@333333
~31]
ip[[x^
WXp?
@ADj
@Wzm6Vb
@l$
@?bK
?*oG8-x
p]1#
~31]
?ffffff
Z@@M-[
Q@-Z
0a4+[
@fKVE
e5]Ot]
p;4,
9#J{
@>u
+^r@)
 P@o
9[@h
?'OYM
U1e?
Y5@}?5^
@s4a@
 Q@Nz
 Q@J
p1@&
R)v4
_[?=
?hur
^}<0A@z
?R&5
-$`ty
1uWv
5=((E
?4GV~
|?9O@@
?u!V
_YiR
f@zR&5
Xni5$
?ffffff
?K#f
wcAa
?|F"4
4I,)w
s(CUL
71$'
9@0Go#@8
d\qqTn
j3NCT
?og_y
?F"4
+^r@Hm
_s[@N
6@C:<
?2uWv
9x&4I
'JB"m
@d:tz
6G4@H
?wH1@
vj.7
p;4,
?~?h
6 B\
 F@Y
?{0)>>!
]J]2
v@2Y
`S@uU
@Qk
?'g(
VAt
"lxz
;@(c|
+QW@
 \@c
~j@c
71$'
6X8I
VAt
 iGo@
@>u
9[@h
bhur
@NA~6r
`V@xE
jdWZ
?dY0
?J]2
U1e?
6G4@=
W@gH
g)YN
iL.@F
yXg@
T.@R
?W'g(
?;4,F]k
C5%Y
.)@j
?Ef.py
?TUh 
SUh 
`V@1&
61@A+0du+
@p&
?9% &
@9Cq
@L@'1
?c~nh
?~p>u
`YiR
i8en
%@u?
?2ZGU
?9}=_
VAt
 iGo@`
P@)\
bhur
4'/2
c9C@
?yZ~
CP5z
6G4@.Ui
tv28
:9Cq
Iv(@
?-AF@
3\[@(*
@@"9
.rOW
C5%Y
/Q&@
_!seP
~31]
h?RD
 !f@
`U@333333
bc^G
m6Vb
}w+K
1ZGU
n1?74e
)[$m
(yuf.
Nc{-
Udt@
o.@d
_{fI
`_@wMHkz
 iGo@
?ro~
TU@r2q
?C:<
!@XXp?
lV@L6
1w-!
5]Ot]
5=((E
@O@H
@W^
|(@
%@2q
*2: 
??:u
?d<J%<
lXSY
?uYLl>
'@*V
@h=|
?R~R
?'JB"m;/
@@=I
%TpxA
?2w-!
t><K
?"6X8IG4@
?J%<
?QhY
`S@u!V
uoEb
6y@z
BY0=@
*u@m
Yg|_
?TpxADj
'eRC
bFx{
@D@*
?1Bx
 iGo@
XXp?
lV@_
`T@.
tv28
g?RD
??5^
h"lxz
!@\qqTn
j,am
C5%Y
V'g(
?8/N|
3@-B
4@qVDM
!@t]
+U0@>
?gDio
?u["
>sv?
?a2U0*
fh<1?*
?/0+
8EGr
q?gb
1?C@T
?Ll>
 iGo@[C
1w-!
@p(|
?-?p
?N(D
CQT1@M
]J]2
({K9
?1a4+
5jb@HO
m3@TR'
)@fN
v0@cb
wMHk:
?5*p
w@ffffff
?"nN%
%9`W
?Ii6
?zo
t{Ic
>x?h
8s?+
(F>$@{
?F]k
@I@k
g)YN
? |(
s0?@
@0J
,AF@
l ]l
pxADj
obHN&n
'@/M
X6sH
>@333333
@1<P
 @h\8
?VW
]J]2
?ffffff
`T@|
76u@
?333333
-@{?!
8EGr
V@8.
+w@2
sCSv
u7Ou
#p=@
.x@u<f
6 B\9
?4GV~
vMHk
?8gDio
jIG9h?Q29
R)v4
@M@~
Sa@T
j]K@
_?[[x^*
5#S.@R
nnLOX
@/R(
9@0G
`obHN
@$*T7
@333333
9[@h
cFx{
?6x_
OWw,
W@8.
0@xB
@LTo
? |(
?!Z+
]J]2
?.py
ED1y
%Tpx
\4d|
D5%Y
C1@Y
?^-wf
@OWw,
qS(@j2
{)<hv
?q;4,F]
vIK@
?a4+
Cr2q
?wH1@
)@*S
,cC7
?R)v4
Cr2q
%@Hj
@E@{
?"S>
?h\8
s`9B
<@k`
@@+l
?whX
X@PR`
LGT@R
.rOWw
8b?F
VBwI
!@By
[@h=|
?6;R}
jIG9
6Y@l!
>U~P@!
?u<f
,AF@
?=+i
,X@{j
?T:X
^Cp\
(eRC
?_b,
"d@+
4@^*6
WBwI
?% &
{)<hv
~lb?>Ab
]@?8
d<J%<
?o/i
c)w@
NA~6r
?8/N|
?|)<hv
QD@C
$g3@o
@B@ADj
T@w0b
61@b
?.rOWw,
g)YNB
?s-Z
@Zg|_\
>p@o
u7Ou
8EGr
k,am
Q@q=
?h?RD
@bHN&n
?!x|{
?Cus
]&@X
yy:W
$[]N
`obHN
'Hlw
 P@MeQ
<e5]O
?bHN&n
AA)Z
?%wd@
Vj8@
`P@)
ahur
jIG9h?]
~p>u
 |8
Gp#e
@C@`
0@%<
?||Bv
s(CU
qd@X
$[]N
?ffffff
?c{-
?WZF
:9Cq;F@
?$%=
B=S@w
333333
gB5@If
"LQ.
]L3}
4GV~
?LqU
c)w@
ik2@M
X6sH
`Q@5
B\9{g
?R+L
'eRC
?@Pn
?+@v
=@<J%<
`@=,
6Y@l!
?d> 
?F|'f
a4?&
`@)A
?ffffff
6 B\9
[%8;@
&OYM
 |(
?xADj
?T:X
FD1y
o}Xo
X2(@:
@{Nz
=R,@<
,cC7
?D1y
@9Cq
L$@S[
UId??]
 [@t(CULe
t/F@
xCF@<
@uWv
?XSY
^@Tq
)t^c
?6sHj
,AF@
%@Ui
hwH1@
?b->
@CUL
0|DL
?>$|
? _B
!6X8
`T(^@
?L4H
|^AB
kzPP
?:!t
?*t^c
??RD
g$@D
\@?:u
? |(
p[[x^*
?p}Xo
v@F"4
G@xB
?Xp?
SUh 
3c)@
.@,J
@u9% f}q@B
!@)\
lBZc
?Hk:!t
?%=
ip[[
!p$P
@ D2
@O@,
qo~C
_J@K
3p@KW`
@4g}
1uWv
?!Z+
?B$C
19%@p%;6
_!se
$EdX
s(CU
o}Xo
y#@9*7QKs
?zR&5
4o?
?qvk
#@g_y
>`?$_
N3@U4
'A]@1_^
?zpw
?ir1
?333333
6 B\
=&Rj
2^@N
l ]lZ
#EdX
!6X8I
D@"4
/.U)
>($@|a2U0*
/5B?S
?Uh 
'-\V
^@Tq
?0du
@?sK
!qEJ@
??:u
uv28J^
? )"
Yg|_
@G8-x
wI>@O
OVW
@N{J
fh<Q?B
!@AH
exh@i
?(}!
Gp#e
?RF\
? <
D9@9{g
emS<.
@O@Q
=@@K
k'JB"m
?h?RD
~NA~6
{)<hv
1>@l>
`Z@fO
ffffff
'@6[y
@+0d
?`x%
"nN%
e0F$
@p]1#
?u["
.PR`
o}XoT
=~o%T@
@ZH
'@c%
wcAaP
?DN_
1ZGU
hUK:
?\sG
?UN{J
\:*A@|e
?F]k
sx?b
=~os
'jin
v@$G:
@I@s-Z
@F%u
/3@F
?"nN%
l ]lZ
@`[?
?eo)
~31]
 B\9{g
>PT6
VAt
@bHN&n
0|DL
kzPP
zm6Vb
Wzm6Vb
t(CUL
%9`W
?^J]2
?|_\
TQ,%@
E@B!
0@U2
?Z*oG8
#@+5{
pa@>
?9Cq
ypwV
@D@x(
0a46Z@ffffff
?kGq
@$d 
=k?\
q?}v
-@l#
?<2V
g$B#~E@
9[@h=
?T{P@8
?k'JB"m
?7Ou
R@Gu:
@rOWw,
:q9^
;4,F]k
R@vQ
7@Dio
C@h>
?i5$
cyW=
sCSv
E'K-
 P@/
ffffff
?zPP
P5z5@
?}uU
%@c_
?qqTn
'@p(|
g)YN
?d:tz
]@D6
.Vt?3P
>%T@
?"6X8I
#@od
T3k) 
'A]@
fF?J?
lT@kE
?1DN_
@N@f
@N@W^
H@p|
/'g@w0b
?Nc{-
y}?1
`T@w
@f0F$
?*9'
|$%=
}w+Kt
)<hv
[u+@
?{fI
={.S
?DP5z5
'@F$
?6sHj
tYLl
(eRC
gDio
cVR@
#@5z5@i
@:[@h=|i?3P
>%T@
f7`@9
?p(|
1ZGU
B@P7P
?s-Z
Gp#e
%VF#
?q $
?J`s
@N@O
@ffffff
p;4,F
`R@{
-y<-
DkI@B
?5]Ot]
?h$B#
-@-y<-?p
?*oG8-
|@`9r@
Yg|_XK@T
@R+L
?c('
?F_A
?g+/
|a2U0
@333333
!@=((E+
&EQ@
#*T7
$}ZE
U^i@
?CUL
?}Xo
?=c_
.?}=_
yt#,*
?s/0+
?"R
,{B?
:@qu
`[@Vdt@
Cr2q
ng_y
1uWv
s(CUL
a?{Ic
?kdWZF
_!seP
?9% &
emS<.
)@B!
`7l[
DZ#@q=
@Mjh
-y<-
J@VE
?jin
.PR`
e0F$
Z}uU
dvf?
)t^cw?
?:#J{
m@%@
Coq;@V
R)v4
?qqTn
?-?p
 S@2
?R~R
?M/1
#@m6Vb
?Mjh
\Va3
@GZ*oG8
s`9B
j]V@
P@W|C
T@V}
4,F]k
'OYM
 |(
?mu9% &
R)v4
s`9B
|xv?
`Q@333333
?:x&4I
UPt@
M?_)
?'jin
?;V)=
? B\9{g
$@M-[
*7QKs+
OWw,
?RcB
7n1?
1 {}
C@uYLl>.
?)^emS<
a@-y<-?p
l ]l
.X1@
Q?mq
@l|&
aO1@ 
j]P@s
QA1@K
@K@7
1Xy!@
@M@\
.rOW
@F@rk
`obHN
/@?p|
?&4I,)w
'@Mjh
drjgx?
#EdXE
?|'f
}U.T
?uYLl>
g?RD
Q@>w
{)<hv
?O#-
?~6r
h?RD
=((E+
vMHkL
@E@emS<.
?qs*
;O<g=B@Nb
?bjK
UK@?
t@|H
?T5A
?pxADj
?"S>
]w?{
n1?74e
"LQ.
@@;q9^
I@`YiR
?0h!
@`x%
?6;R}
?J@L
fz?5
?i5$
yt#,*
q?ffffff
?'g(
`S@@KW
>tA}
k'JB"
?/kb
`W@b
{qf@
@N@B
@2w-!
?O#-
O@fO
 \_@=e5]Ot
@J@
b?d@
Y6sHj
4'/2
@ro~
+@M.
@uWv
NL@d
D6@h
0)>>!;
>`=@
.>?@
UN{J
obHN&ne?
%9`W
?4I,)w
<e5]O
!S*2@a
`7l[
f3r@
%@[
|?-'
sCSV
P@[B>
/+d@
ikD0
&OYM
Ral!
#@?8
?t&m
~k'J
EEl?
a@d?
?|'f
.X1@
={.S
|a2U
aO1@
@ffffff
DZ#@333333
kBZc
?)yu
]J]2
Zg|_
d@,I
'@J|
E@-z
^(`;
@h=|
nB@x'
-y<-?p
N} y
`obH
[%XL?
?8gDiop
`S@g&
5l@
k?zo
?4d<J%<
?p}Xo
x?1zn
r/0+
_(`;
o`r#
Z@Qf
! _B
G@ *
?wKr
?/0+
 V@/2
/fKVE
?Dio
?#LQ.
?ILP
"nN%
?/PR`
L)?.rOWw,
`7l[
D5%Y
qQ-"
1uWv
g?xC
?}?5^
TN{J
H]m@
jIG9
K@jK
X*,@
E|'f
?GXT
G@j2
@L@d
|F"4
'-\Va
?_`V(
AV-@2
$}ZE
?28J^
a@scz
.X1@
BX7@@
?!x|{
?<Mf
j,am
q4GV
! _B
NA~6r
W@SAE
ED1y
?voEb
?WBwI
~31]
-W?6
xy:W
@J@#
?s/0+
?%;6
(Hlw
o?zUg
`Y@E
ML@X
d@A,
 b@cE
>tA}
?9`W
[;QB
~NA~6
:@0G
sCSv
lXSYt?
.m8,
3@aq8
?|'f
I]V@
?ADj
4s?^
&w?Ac&Q/
?g_y
wcAa
?t(CUL
?74e
{)<hv
k_@/\
@9Cq
?UK:
?3SZ
?*T7
;Kj@
9}=_
%qVD
 P@gaO;
?~6r
.5B?S
~#Gd@
vj.7X
.m8,
TkaF
?ffffff
@zrM
?O<g
1ZGU
@ffffff
P4?:y
#bJ$
?t{Ic
}s'$@Zg|_
7@+Q
?QMI
f@?74e
?\sG
?o*Ral!
6=((E+
#@|c
?Zg|_\
d:tz
?><K
?LTo
?]4d<J%
~4<!@0
@L@\
]@.:Yj
FwP?
j-@"r
?]S 
Xni5$
?be4
@2ZGU
7n1?7
6 B\
jIG9
VAt
R=@A
~NA~
r&@A*
?i:;
?JbI
 X@kdWZF
@e73
dp2@"
@J@u["
ikD0
0fKVE
([@W_]
?x|{
?FB[
;l"3'
'eRC
iN^d
4'/2
@N@B
&OYM
@D@3
?Mjh
`X@p
;l"3g
@F@hA(
4'/2
b)";@
8r@4H
1ZGU
s(CU
W zR&
'@-C
@B@rS
U@[(
~{?i
"@g_y
y`@4
IbI9
__kgd@y
 x|{
?o/i
ip[[x
++MJA
F;n8
&F?W
?OYM
B:<x>@g
/.Ui
!@W[
Wk'@
S?o*Ra
]@Qg
6Q@,(
2?8en
@Z@p
r/0+d
>tA}
@5z5@i
#@zl
?/0+
.m8,
}s'$@
U@mU
 @jm
24@m
;q9^
%@"O
8'T@
$#ga
O@]R
,cCw
jIG9
rQ-"
$@W
?vb@
iN^d
e1}0@R
k#a@
h:;9
?rjg
vMHk
Df#@
%@!<
d4@fO
.d@DN_
'(N@Q
?)&o
@L@C
?%=
`U@'
,@t$
g?RD
~k'JB
@A@H
?Swe
{b@"
@-?p
C+@O;
@L@K
fv1@
U@mY
?y:W
"@hY
f@>z
?rjg
i8en
9#J{
?N(D
D@{j
F@xG
vT5A
?>yX
?4iSu
7/N|
'-\Va
?76;R}g
?8/N|
?Va3
?33333
Ac&Q/
333333
?Wzm6Vb
?J}Y
! _B
5O@wKr
1w-!o?
l=C8f
^-wf
#bJ$
0a@C
]Ot]
?;4,F]k
?Um7
=~os
?O<g
?'g(
h:;i?4
\4d<
_{fI
9Z1@
B@*8
Yg|_\
n,(
?TUh 
?0du
?ffffff
9@0G
_>Y1\
}s'$@
_{fI
@E@:
g$B#x
r?ke
.J7@
@R@Y
?,~SX
iN^d
0DN_
?]n0
-y<-
e2\?;
&9`W
@I@:
f+/y
9@0+`@
@$G:
N`:-
aTR'
,^,
:@QO
b@6t
@D@q
h8en
rOWw,
?9*7QKs
/K;5w?
@ZH
?fM,
@Z@p
lXSYt
@p]1#
R@pB!
@O@$H
?DN_
!@?W[
81@m
NA~6r
pr?k
@L@P
?Va3
Xv@Ze
?8gDio
.PR`
?28J^
?$`tys
?"nN%
mnLO
?8gDio
+u?s
?Ii6
t><K
ILE@
CM?R)v4
Df?;
?I/j
VBwIl
?>&R
Z}uU
%9`W
9#J{
7gP@
`U@;s
 X@_@/
K@ffffff
1w-!
wcAa
?N&n
?hA(
s/0+
#d O
a5FZ@G
_>Y1\
Z}uU
??74e
?333333
?2w-!
f\R@
4@1E
&jin
?ni5$
 ]@8
ng_!'@
@G@sg&
lXSY
9x&4
?v7Ou
/aM@2V
?1DN_
Yg|_
?,-#
?f.py
rg&x?
?@Pn
! _B
`Y@![
w?XXp?`.d@
?[]N
Ac&qD@
kK@\
=x#E@
?\X7
?aobHN&
!6X8
TUh 
'eRCK
N} y
-$`t
1ZGUc
@HAR@R
C@,,
VZ0@Y
?l=C8f
`V@*
@G@q
?6[y
t?Ab
8b->
p]1#
@I/j
.PR`
%TpxA
^Cp\
N@W&
C_ @
!@0K;5
:q9^
bHN&n
#f@|)<hv
@}!
o}Xo
gcx@
?NA~6r
-</U?P5z5@i
!@h<
p}Xo
@nlv
@B@W'g(
7n1?
Mc{-
dWZF
l2@BA)Z
`R||
P@|`
@=((E+
?S$_
*2: 
/.Ui
6Q@sG
0a@o*Ral!
?ffffff
h"lx
Udt@B?a
?fh<
NA~6
R{a?
$#ga
LLW?
?!Z+
zR&5
sw?i
?;4,F]k
l ]l
?=b
t@y#
a2U0*
?gc%
@}=_
 Y@Ov3
wcAat=@}!
?d!:
x?%y
_Cp\
1"QhY
/i1@
?YNB
`Q@CV
/K;5
?RcB
%U{?
?]4d<J%
1ZGU?:@
-@IG9
Ja@G
?Y1\
7y'@
z3j~
#/kb
?/m8,
&@<1
?9% &
?EGr
c\qq
?[_$
%@S^+
!@X<
:sO&@
?l_@/
||Bv
g{J@-
eG4@
}U.T
 |(
?K;5
-q?)
?c^G
a.@&
H@OX
`U@7
?E.8
aMeQ
M@Fx{
p/@
)w?T
=&Rj?@/
g?}>
9Z1@
;O<gK
@-$`tys
vMHk
 R@E-
?VF#
p[[x^*
WAt
?o/i
?3p@KW
z.@Y
k@@9
Ac&}E@d
-^,
_Cp\
 U@}#
^(`;
 P@wH1@
AGl@
`T@^c
?U3k) 
??rk
^`V(
!@333333
0c@U
@kD0
?8J^
`7l[
?J`s
?^/M
?tCSv
#LQ.
?FzQ
{F"4
? 'L
c> YV@
6@h 
s(CU
5@t)
V..@
?f.py
^J]2
 Z@ 
K@k`
?>@[
)@,J
?Q0c
aM@{
`R||
TkaF?
?5bf
?RcB
 |(
?2Xq
f+G@
?M-[
#EdXE
tYLl>
S@!w
cyW=`
t;W@
4@1zn
@fM,
Tkaf?
.C+@
}"Or?
$#gaO
u?,am
<e5]
?BZc
Yni5$
0a@:x&4I
?x)u
8f,@Q
'!0@
Yfa?j
~p>u
)@pw
ffffff
?`vO
DNW@
?{fI
NfB@
bFx{p
(@='
WBwI
"Rs?
)@!sePmp
@o/i
BW"P
ZDd?
6@[`
 X@/
|@a
\4d<J
`a@c{-
J %v
?=c_
?6;R}
?J(}!
?NE*
?,cC7
 Y@%xC
?IG9
?0h!
?]lZ)
P@t%
?uv28J^}?/
>A@D
?5_%
?!u;
?! _B
$bJ$
#*T7
~p>u\
aTR'
xM@,
?RcB
Yni5$
71$'c
<l"3
qQ-"
#@FC
?333333
4@,G
W zR
?2=a
@D3O
?kC@
?fh<
*Ral!
0a4+
'@ap
9#J{
VZ0@
@B@,
]c@P
?28J^
@Ii6
?'2s
?4GV~
a??6
x$^n?
7gP@
uoEb
@VId
iQo?_
eU?)
@u9% &!
i)@_
?{k`
#@}@
?.W?6
#bJ$
?1|DL
?,+MJA
.$@@N
lXSY
@S<.
`T@i9
TN{J
?c^G
?t(CUL
?Oyt#,*
?d!:
H#@:
?ir1
 U@-
bFx{
t3@>v
'@8L4H
;l"3g?W
_{fI
{ds5
?+MJA
`!sePm
#@Sv
A]\D@
SUh 
j=@ {
?q;4,F
?Zg|_
UId?
-$`ty
?L4H
@]1#
bc^G
+)@9EGr
9}=_
cyW=`
k!@G
,cC7
CP5z
?0fKVE
?f.py
V_]U?
?*T7
}?bN
%9`W
?V)=
^Cp\
<D@al!
AQ:@"
69|r
Vzm6
Z_$4
NA~6
U?j3NCT
'!@N
},P@
~Pg?"nN%
+@[
$2@!
e0F$
?5%Y
i*^@
ip[[x
RGl@
]J]2
/?|+
t`9B
?HN&n
{qf@
2@)&o
@G@nQf
1w-!
K %vmo
i3NC
9[@h=
#*T7W
&OYM
_@ILP
FpT@
It?`
!@wj.7
l_@/
W'A@
?gDio
Vzm6V
`T@g}
?VW
N@)\
u7Ou
U`?A
o%;6
tv28J
3NCT
 \@qs*
0e@~
a{U@
q4GV~9?
#S@q=
?,-#
?<hv
x?|`
Xp@#
^Cp\
#EdX
}'8@
bBP@
E@S=
vMHk
@J@Y
FZ*o
N@Nz
?_EF
?uv28JV-@:
8/N|
@s/0+
^-wf
?0K;5
aMeQ
:9Cqg
V'g(
?qqTn
AB@A
g@$H
|''@
3@RG
x?c}
D5%Y
@T:X
%Tpx
#@:\
?;q9^
 Z@qvk
~4l?~
?t^c
?5'/2
`obH
?>&R
6 B\
$@M-
>a?+
I(}!
 Y@$
v?j0
?]n0
Z@"R
ypw6
eO!@
?)YNB
s(CUL
>tA}
rl=C8f
?(CUL
!@gaO;
|$%=
?+Kt
?0Ie
?(}!
|cK@
T@2t
a-@
?TZ?
V@#I
;l"37
!sePmp
lu9%
&OYM
~31]
@yW=`>I
@scz
-\Va3
>o0@
=L@{
-:Yj
:q9^
?KxB
)YNB
9[@h
;l"3
?.:Yj
?nQf
PJI@c|
?Wzm6Vb
`S@}w+Kt6(@ffffff
`T@i
&9`W
~wp@
OvC-@
@M-[
Z0@N
d<J%<
?tE)!XU
?y\T
@Vc
Vzm6V
0@Qi
LLg?:=
@M@
;@=b
Bw@
?D1y
)t~?
j,am
?t(CUL
aq?5A
?8-x
d*A@.v
+@Ov3
E|'f
?p%;6
(Q)@
@M@Ag
?^emS<.
?`!sePm
W zR
?|)<hv
||Bv
 Q@lxz
`TR'
q4GV~
m6Vb
?eo)
?5]Ot]
Vq?q
@@}Y
b@35
`S@.
 S@x
?NCT
G@'N
8EG>1@
F@F}
;l~<@>^H
<e5]O
`7l{?
uT5A
l#n?
|a2U
ikD0
$@;6
@5z5@i
`X@E
,AF@
?4GV~
<e5]O
`Z@0
J4@0Ie
?%xC
?.W?6
fh<a?/
@A@q
+bN@
EB[N
XnA&@
 ]lZ)
;d?r
`W@Tq
pJR@(
 Z@0
b('z?
?a4+
p;4,
?0F$
EY>@
0Xr
q,q@
^Cp\
?!XU/
]3@oc
?;9Cq
_>Y1\m?n
CP5z
d:tz
?eRC
Q@}!
?wKr
&<@W
dx7@{-
Z}uU
'@/M
EX2@
8G]?C
0K;5
.$@RC
?iW!
?sePmp"
1_C@k
?xak
 @T
p`@"
??RD
drjg
?,)w
(w?o
?j3NCT
]_@Xp?
R@<
N@q9^
?rQ-"
ff4@
~'@2;
nyI@z9
++MJA
6Q@H
`\@Q
?'jin
t?y<-?p
W@r4GV~
?LOX
0DN_
Cr2Q.@
?G;n
]J]2
\q?8
?LOX
bEA@
?o/i
"nN%
?(`;
%s,o
?u!V
5D2@
?PVW
w?rk
5]Ot]
Cn!@
j,amL
?'jin
@p`r
`Q@!
?79|
j,am
K6n?
@k:!t
?ffffff
R?o*R
pc?[_$
ng_y
hwH1
"@3nj
UY@F@
?_EF
v?u><K
'!@]
},P@u"
?[[x^*6
?O[#
jIG9
,@W
mnLOX
?d!:
+H3v?
@I/j
333333
?^/M
?FzQ
lXSYd?
@ffffff
>>e@S
a5f?l
}w+Kt
Zf.@9_
AA)Z
/5B?S
~p?;9Cq
s/0+
~?,g
~x%@
CP5z
??5^
R?o*R
J(}!
9}=_
=yPN@
@J@A
AA}=@
?G=D
&OYMw
f.py
[x^*6
ng_y
KX@OX
?[z4
+P@$
V$v!@
N} y
?2 {
g$B#
 R@U
t<f`
@ffffff
(0@H
?^-wf
K!@{
dyW=`
7co@c^G
lu9%
>x?f
>tA}
Vzm6
1@YO
OVW
poY@
?:Yj
?X8I
[@=c_
?B_z
sE)!
xW@O
:9Cq
?z5@i
?"S>
^Cp\
?]lZ)
?,-#
,^,
^(`;X
kzPP
3iSu
X6sH
?scz
?x^*6
?3nj
A,p@
?<jL
0DN_
uB@c%
Fs@2
)t^c
KU1@+n
?WBwI
[%XL
?$B#
!@g|_\
F@Yj
h/6@
@n?DQ
?8en
?pxADj
?'/2
8@wMHk:
q?Dl
:9Cq
?=((E+
@]1#
2p@Kw
BW"P
^`V(2
Vzm6V
1|DL
?VfJ
?WBwI
-:Yj
r/0+
h:;Y?
3@6w
?]n0
?X8I
@oJy
V'g(
unz?
aR||Bv
hs|?
WXp?
?fk}
H3B@
wD@P
d)@=
?8o?
%VF#
X6sHj
?%]3
1ZGU
 P@-|}
?"nN%
'-\Va
Q@o)
sq?Y
}Vy?
71$'
<P@Y
?4iSu
?Hk:!t
p@KW
?hA(
jIG9X
#@333333
"@G:
? B\9{g
.5B?
wcAa|7@K
?wH1@b
e@0h!
?P5z5@i
B\9{g
@F@%
I(}!
/w8@
#@)\
^J]2
#*T7
@<O<g
5c?C
`R@x
bc^G
[$@!
R{a?
(0!@
`7l{?
={.S
xy:w?
lXSY
?TpxAD:+@$
p;4,F
#Ed<0@
?Y6sHj
?S^+
?=e5]Ot
xy:W
`Y@h
2"@X
Ac&Q/
i?kH
?*9'
?RF\
9]V?
k^u?
?D1y
?|ds
$#gaO
`T@c
_!seP
u7Ou
sE)!
3@?;
@L@X
`Z@s
zR&5
?W$&
?4JT@
Co99@
m&@%
'eRC
JB"m
_#I`
71$'
$>wr
={.Sc?
?>Ab
T@F?
 R@LR
x?['.
@N@a
'jin
?S<.
?'jin
?8/N|
@u!V
?ILP
$`tys
?-\Va3
sJ@L
kU@4GV~
1|DL
?%]3
?>!;oc
UM`?
I@x~Q
A@8M
'eRC{
?'g(
YpT@
@N@u 
"nN%
ng_y
@5bf
"z_@
"LQ.
tE)!XU
NP @
Yk(5
={.S
?TiP@#
E@Bv
?FzQ
?_}<
sE)!
:7Q@
hwH1@
8@ F
Z}uU
G@%\
)t^c
bFx{
t{Ic
W zR&
t`9B
?<2V
FD1y
I}Yz
R)v4
!1@9
?9b->
W zR&
#*T7
?N&n
W z6l@
=e5]Ot
rJ@L
2w-!
?{Nz
bFx{
?1?74e
?9{g
?sJ@L
:@t{Ic
3M@\
?5]Ot]
;@YQ
;~C@+
zo!
lDR@
%@@Ral!
! _BCa@X:
"LQ.
o%;6
?ir1
-\Va3
Df.p
k'JB"
L@+3
B@v4
?_{fI
z0)>
?LOX
cyW=
u7Ou
Nl.@
X @c
}U.T
#bJ$
#@ b
`[@u
%.?(
?NCT
}Vq@
f0F$
L@$
iN^d
?lxz
TPq?
?kGq
?36t
?Z,E
k'JB"
?r2q
?Y1\
%vmo
0a4+
:9Cqg
%9`Wav@
9@0G
)@>\r
0|D$ @y
E'K-
8*7QK
I(}!
W@%;6
OVW
p;4,
,@IG9
w=@w
4'/2
9x&4I
?`9B
k_@/
p%;6
?4d<J%<
^@->
IL@;
?!sePmp
?!x|{
y?Xp?
L@@O
?.:Yj
9@0G
By"R@
h8en
v7Ou
#@Cr2q
5_%}C@
@Va3
?iW!
p]1#
9Ak?$H
@*T7
(^emS
l^@1
^F=0@
?9Cq
|v!@
5@%A
?7n1?7d2@
zm6Vb
C@>w
?m8,
?(~:
?@)3
Un=H
?td{YX
?nTV
sue
?P-U37
?\h"
]*y?
Cv?0=
s?<V
2Zq?
Ip?1
Cgac?
CWAq
)!X?
V?x)2
A?4a 
)n@?9z
b'H<?
QQB,?
XE&?
$?Pg+
}!?P
X  ?59
>z,i
>V{@V
$h>+
*>|ar>
F5@`vG@
s@]m
O3@p
 ?w-
6|>'1
>Gr9?
@6<5@
>HP?
a!@aT.@Nb<@[
S\@|an@=
@8gp@
 P?>
_>U0
R@Tt
,?F%U?$
?'18?
6<@6<Q@>
i@\ 
ServerConfigVersion
>ff&?33
