-[MTLDebugIndirectComputeCommand setComputePipelineState:]
Setting the pipeline state of indirect command buffers created with inheritPipelineState = YES is invalid
Setting a pipeline that does not have supportIndirectCommandBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand setKernelBuffer:offset:atIndex:]
index(%lu) must be < %lu.
Setting buffers on a indirect command buffer created with inheritBuffers = YES is invalid
-[MTLDebugIndirectComputeCommand concurrentDispatchThreadgroups:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatch is not enabled on this indirect command buffer
-[MTLDebugIndirectComputeCommand concurrentDispatchThreads:threadsPerThreadgroup:]
MTLIndirectCommandTypeConcurrentDispatchThreads is not enabled on this indirect command buffer
v24@?0@"<MTLFunction>"8@"NSError"16
%@%@
label =
<none>
v16@?0@"<MTLCommandBuffer>"8
allocator<T>::allocate(size_t n) 'n' exceeds maximum supported size
v32@?0@"<MTLCommandBuffer>"8@"NSData"16Q24
v8@?0
com.apple.Metal
GPUDebug
v40@?0r^v8{_NSRange=QQ}16^B32
MTL_BOUNDS_ACCURATE_MODE
MTL_SHADER_VALIDATION_CPUOPT_FORCE_INIT
MTLBoundsCheck::Options
MTLBoundsCheck::RenderPipelineData
v32@?0@"<MTLRenderPipelineState>"8@"MTLRenderPipelineReflection"16@"NSError"24
v32@?0@"<MTLComputePipelineState>"8@"MTLComputePipelineReflection"16@"NSError"24
-[MTLGPUDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
Indirect Command Buffers are not currently supported with Shader Validation
v24@?0@"<MTLLibrary>"8@"NSError"16
MTL_SHADER_VALIDATION_MODE
Tier1
Tier2
MTL_SHADER_VALIDATION_ENABLE_ERROR_REPORTING
MTL_SHADER_VALIDATION_GLOBAL_MEMORY
MTL_SHADER_VALIDATION_THREADGROUP_MEMORY
MTL_SHADER_VALIDATION_TEXTURE_USAGE
MTL_SHADER_VALIDATION_COMPILER_INLINING
none
full
partial
default
MTL_SHADER_VALIDATION_FAIL_MODE
zerofill
allow
MTL_SHADER_VALIDATION_GPUOPT_FORCE_INLINE
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_PACK_POINTER_ADDRESSES
MTL_SHADER_VALIDATION_GPUOPT_ENABLE_BACKTRACK
MTL_SHADER_VALIDATION_GPUOPT_CONST_DEREF
MTL_SHADER_VALIDATION_GPUOPT_GEP
MTL_SHADER_VALIDATION_GPUOPT_GENERIC
MTL_SHADER_VALIDATION_GPUOPT_SKIP_VFETCH
MTL_SHADER_VALIDATION_GPUOPT_BACKTRACK_FAIL_ASSUME_SAFE
MTL_SHADER_VALIDATION_GPUOPT_MERGE_CHECKS
MTL_SHADER_VALIDATION_GPUOPT_USE_LENGTH_ONLY
MTL_SHADER_VALIDATION_GPUOPT_NOINLINE_TRIVIAL
MTL_SHADER_VALIDATION_GPUOPT_DEMOTE_GLOBALS_CONSTANTS_TO_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_POINTER_INDIRECTION
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_GLOBALS
MTL_SHADER_VALIDATION_GPUOPT_MERGE_THREADGROUP_ARGUMENTS
MTL_SHADER_VALIDATION_GPUOPT_JUMP_THREADING
MTL_SHADER_VALIDATION_CPUOPT_RETAIN_REFELECTION
Invalid option for %s, valid options are:
com.apple.gpusw.MetalTools
MTLGPUDebugICBSupport
metallib
ICB_Inherit_PSO_Vertex
ICB_Inherit_None_Vertex
ICB_Inherit_Buffers_Vertex
Faults from argument buffers will not be detected.
Faults from reading global constant variables will not be detected.
%@ -debug-info-kind=line-tables-only
-debug-info-kind=line-tables-only
v24@?0@"<MTLRenderPipelineState>"8@"NSError"16
v24@?0@"<MTLComputePipelineState>"8@"NSError"16
ciKernelMain
v24@?0@"<MTLSharedEvent>"8Q16
-[MTLDebugPipelineLibrary newComputePipelineStateWithName:options:reflection:error:]
name must not be nil.
descriptor is not a NSString.
-[MTLDebugPipelineLibrary newRenderPipelineStateWithName:options:reflection:error:]
%@ -> %@
"version":"
0.908
,"handle":"
,"device":{
"handle":"
,"name":"
,"queue":{
,"events":{
,"methods":[
{"selector":"
,"flags":
,"commands":"
,"commandBufferLength":
,"encoders":[
{"flags":
,"segment":{"location":
,"length":
,"statistics":{"flags":
,"counters":[
{"name":"
],"samples":"
,"sampleBufferLength":
cb_%llu.json
Error saving file '%@' (%@)
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options
fillBuffer:range:value
fillBuffer:range:pattern4
fillTexture:level:slice:region:data:size
fillTexture:level:slice:region:color
fillTexture:level:slice:region:color:pixelFormat
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount
copyFromTexture:toTexture
generateMipmapsForTexture
synchronizeResource
synchronizeTexture
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset
resetTextureAccessCounters:region:mipLevel:slice
dispatchThreadgroups:threadsPerThreadgroup
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup
dispatchThreads:threadsPerThreadgroup
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
setBuffer:offset:atIndex
setBufferOffset:atIndex
setBuffers:offsets:withRange
setBytes:length:atIndex
setComputePipelineState
setSamplerState:atIndex
setSamplerState:lodMinClamps:lodMaxClamps:atIndex
setSamplerStates:withRange
setSamplerStates:lodMinClamps:lodMaxClamps:withRange
setStageInRegion
setTexture:atIndex
setTextures:withRange
setThreadgroupMemoryLength:atIndex
memoryBarrierWithScope
memoryBarrierWithResources:count
drawPrimitives:vertexStart:vertexCount
drawPrimitives:vertexStart:vertexCount:instanceCount
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance
drawPrimitives:indirectBuffer:indirectBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset
drawIndexedPatches:patchStart:patchCount:controlPointIndexBuffer:controlPointIndexBufferOffset:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset
dispatchThreadsPerTile
setBlendColorRed:green:blue:alpha
setColorStoreAction:atIndex
setCullMode
setDepthBias:slopeScale:clamp
setDepthClipMode
setDepthStencilState
setDepthStoreAction
setFragmentBuffer:offset:atIndex
setFragmentBufferOffset:atIndex
setFragmentBuffers:offsets:withRange
setFragmentBytes:length:atIndex
setFragmentSamplerState:atIndex
setFragmentSamplerState:lodMinClamps:lodMaxClamps:atIndex
setFragmentSamplerStates:withRange
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange
setFragmentTexture:atIndex
setFragmentTextures:withRange
setFrontFaceWinding
setRenderPipelineState
setScissorRect
setScissorRects:count
setStencilFrontReferenceValue:backReferenceValue
setStencilReferenceValue
setStencilStoreAction
setTessellationFactorBuffer:offset:instanceStride
setTessellationFactorScale
setTriangleFillMode
setVertexBuffer:offset:atIndex
setVertexBufferOffset:atIndex
setVertexBuffers:offsets:withRange
setVertexBytes:length:atIndex
setVertexSamplerState:atIndex
setVertexSamplerState:lodMinClamps:lodMaxClamps:atIndex
setVertexSamplerStates:withRange
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange
setVertexTexture:atIndex
setVertexTextures:withRange
setTileBuffer:offset:atIndex
setTileBufferOffset:atIndex
setTileBuffers:offsets:withRange
setTileBytes:length:atIndex
setTileSamplerState:atIndex
setTileSamplerState:lodMinClamps:lodMaxClamps:atIndex
setTileSamplerStates:withRange
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange
setTileTexture:atIndex
setTileTextures:withRange
setViewport
setViewports:count
setVisibilityResultMode:offset
textureBarrier
memoryBarrierWithScope:afterStages:beforeStages
memoryBarrierWithResources:count:afterStages:beforeStages
setVisibleFunctionTable:atBufferIndex
setVisibleFunctionTables:withBufferRange
setIntersectionFunctionTable:atBufferIndex
setIntersectionFunctionTables:withBufferRange
insertDebugSignpost
pushDebugGroup
popDebugGroup
setLabel
updateFence
updateFence:afterStages
useHeap
useHeap:stages
useHeaps:count
useHeaps:count:stages
useResource:usage
useResource:usage:stages
useResources:count:usage
useResources:count:usage:stages
waitForFence
waitForFence:beforeStages
updateTextureMapping:mode:regions:mipLevel:slice
updateTextureMappings:mode:regions:mipLevels:numRegions:slices
updateTextureMappings:mode:indirectBuffer:indirectBufferOffset
copyMappingStateFromTexture:mipLevel:slice:toBuffer:offset:numTiles
%llu
-[MTLToolsResource validateCPUReadable]
resourceOptions (0x%lx) specify MTLResourceStorageModePrivate, which is not CPU accessible.
resourceOptions (0x%lx) specify MTLStorageModeMemoryless, which is not CPU accessible.
-[MTLToolsResource validateCPUWriteable]
Null texture access executing %@ function "%@" encoder: "%@", %@: %lu
<unknown>
<unnamed>
Invalid %@ %@ executing %@ function "%@" encoder: "%@", %@: %lu, at offset %llu
device
threadgroup
buffer: "%@"
%@:%@
kernel
dispatch
vertex
draw
fragment
visible
.xctoolchain/
%@(%@)
%llX
-[MTLDebugBlitCommandEncoder dealloc]
Command encoder released without endEncoding.
-[MTLDebugBlitCommandEncoder internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
the combination of MTLBlitOptionDepthFromDepthStencil and MTLBlitOptionStencilFromDepthStencil is invalid.
invalid usage because encoding has ended.
sourceTexture must not be nil.
sourceTexture is not a MTLTexture.
sourceTexture is associated with a different device
sourceTexture is Memoryless and cannot be used for copy operations!
destinationTexture must not be nil.
destinationTexture is not a MTLTexture.
destinationTexture is associated with a different device
destinationTexture is Memoryless and cannot be used for copy operations!
(sourceSize.width(%lu) * sourceSize.height(%lu) * sourceSize.depth(%lu))(%lu) must not be 0.
sourceTexture != nil
destinationTexture != nil
[sourceTexture pixelFormat](%s) and [destinationTexture pixelFormat](%s) are not compatible for depth/stencil blits.
[sourceTexture pixelFormat](%s) must equal [destinationTexture pixelFormat](%s) 
[sourceTexture sampleCount](%lu) must equal [destinationTexture sampleCount](%lu).
sourceTexture must not be a framebufferOnly texture.
destinationTexture must not be a framebufferOnly texture.
sourceLevel(%lu) must be < [sourceTexture mipmapLevelCount](%lu).
sourceSlice(%lu) must be < (%lu).
destinationLevel(%lu) must be < [destinationTexture mipmapLevelCount](%lu).
destinationSlice(%lu) must be < (%lu).
(sourceOrigin.x + adjustedSourceSize.width)(%lu) must be <= paddedWidth(%lu).
(sourceOrigin.y + adjustedSourceSize.height)(%lu) must be <= paddedHeight(%lu).
(sourceOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(sourceOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(sourceOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(sourceOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
(destinationOrigin.x + adjustedDestinationSize.width)(%lu) must be <= paddedWidth(%lu).
(destinationOrigin.y + adjustedDestinationSize.height)(%lu) must be <= paddedHeight(%lu).
(destinationOrigin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(destinationOrigin.x + destinationSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + destinationSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + destinationSize.depth)(%lu) must be <= depth(%lu).
sourceOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
sourceOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
sourceOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
size.width(%lu) must be a multiple of %s blockWidth(%lu).
size.height(%lu) must be a multiple of %s blockHeight(%lu).
size.depth(%lu) must be a multiple of %s blockDepth(%lu).
destinationOrigin.x(%lu) must be a multiple of %s blockWidth(%lu).
destinationOrigin.y(%lu) must be a multiple of %s blockHeight(%lu).
destinationOrigin.z(%lu) must be a multiple of %s blockDepth(%lu).
sourceOrigin.x must be 0 (full image) for %s.
sourceOrigin.y must be 0 (full image) for %s.
sourceOrigin.z must be 0 (full image) for %s.
sourceSize.width(%lu) must equal width(%lu) (full image) for %s.
sourceSize.height(%lu) must equal height(%lu) (full image) for %s.
sourceSize.depth(%lu) must equal depth(%lu) (full image) for %s.
destinationOrigin.x must be 0 (full image) for %s.
destinationOrigin.y must be 0 (full image) for %s.
destinationOrigin.z must be 0 (full image) for %s.
destinationSize.width(%lu) must equal width(%lu) (full image) for %s.
destinationSize.height(%lu) must equal height(%lu) (full image) for %s.
destinationSize.depth(%lu) must equal depth(%lu) (full image) for %s.
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s and destinationTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for sourceTexture with pixel format %s.
option (%s) is not a valid MTLBlitOption for destinationTexture with pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
sourceBuffer must not be nil.
sourceBuffer is not a MTLBuffer.
sourceBuffer is associated with a different device
destinationTexture cannot be Memoryless.
(destinationOrigin.x + sourceSize.width)(%lu) must be <= width(%lu).
(destinationOrigin.y + sourceSize.height)(%lu) must be <= height(%lu).
(destinationOrigin.z + sourceSize.depth)(%lu) must be <= depth(%lu).
sourceOffset (%lu) must be a multiple of %lu bytes.
%s disallowed unless MTLBlitOptionRowLinearPVRTC option is used.
%s is not allowed to use the MTLBlitOptionRowLinearPVRTC option.
sourceBytesPerRow(%lu) must be >= (%lu).
sourceBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [sourceBuffer length](%lu).
sourceBytesPerRow (%lu) must be a multiple of %lu bytes.
sourceBytesPerImage (%lu) must be a multiple of %lu bytes.
sourceBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:]
blits between texture with pixel format %s and buffer are not allowed.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:]
option (%s) is not a valid MTLBlitOption for pixel format %s.
-[MTLDebugBlitCommandEncoder validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
destinationBuffer must not be nil.
destinationBuffer is not a MTLBuffer.
destinationBuffer is associated with a different device
destinationOffset (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be >= (%lu).
destinationBytesPerImage(%lu) must be >= (%lu).
totalBytesUsed(%lu) must be <= [destinationBuffer length](%lu).
destinationBytesPerRow (%lu) must be a multiple of %lu bytes.
destinationBytesPerImage (%lu) must be a multiple of %lu bytes.
destinationBytesPerRow(%lu) must be <= (%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:]
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:]
-[MTLDebugBlitCommandEncoder generateMipmapsForTexture:]
tex must not be nil.
tex is not a MTLTexture.
tex is associated with a different device
cannot generate mipmaps of Memoryless texture.
[tex mipmapLevelCount](%lu) must be > 1.
tex != nil
tex(%s) is not colorRenderable.
tex(%s) is not filterable.
-[MTLDebugBlitCommandEncoder fillBuffer:range:value:]
buffer must not be nil.
buffer is not a MTLBuffer.
buffer is associated with a different device
(range.location + range.length)(%lu) must be <= [buffer length](%lu).
range.length(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:]
(sourceOffset + size)(%lu) must be <= [sourceBuffer length](%lu).
(destinationOffset + size)(%lu) must be <= [destinationBuffer length](%lu).
size(%lu) must not be 0.
-[MTLDebugBlitCommandEncoder waitForFence:]
MTLFence cannot be waited on after it has been updated within the same encoder.
-[MTLDebugBlitCommandEncoder endEncoding]
endEncoding without use.
-[MTLDebugBlitCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
firstBatch (%d) must be less than or equal to lastBatch(%d)
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:]
texture must not be nil.
texture is not a MTLTexture.
texture is associated with a different device
-[MTLDebugBlitCommandEncoder optimizeContentsForGPUAccess:slice:level:]
level(%lu) must be < [texture mipmapLevelCount](%lu).
slice(%lu) must be < (%lu).
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:]
-[MTLDebugBlitCommandEncoder optimizeContentsForCPUAccess:slice:level:]
-[MTLDebugBlitCommandEncoder resetCommandsInBuffer:withRange:]
Specified range (loc=%lu, len=%lu) is not inside the command buffer with size %lu.
-[MTLDebugBlitCommandEncoder copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:]
source is not a MTLIndirectCommandBuffer.
destination is not a MTLIndirectCommandBuffer.
Specified source range (loc=%lu, len=%lu) is not inside the source command buffer with size %lu.
Specified destination range (loc=%lu, len=%lu) is not inside the destination command buffer with size %lu.
source commandTypes (%lu) are not equal to destination commandTypes (%lu).
source inheritPipelineState (%s) is not equal to destination inheritPipelineState (%s).
source inheritBuffers (%s) is not equal to destination inheritBuffers (%s).
source maxVertexBufferBindCount (%lu) is not equal to destination maxVertexBufferBindCount (%lu).
source maxFragmentBufferBindCount (%lu) is not equal to destination maxFragmentBufferBindCount (%lu).
source maxKernelBufferBindCount (%lu) is not equal to destination maxKernelBufferBindCount (%lu).
-[MTLDebugBlitCommandEncoder optimizeIndirectCommandBuffer:withRange:]
Overlapping ranges are not allowed
-[MTLDebugBlitCommandEncoder copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:]
sliceCount must not be 0.
levelCount must not be 0.
sourceTexture.width(%lu) at mip %lu must match destinationTexture.width(%lu) at mip level %lu.
sourceTexture.height(%lu) at mip %lu must match destinationTexture.height(%lu) at mip level %lu.
sourceTexture.depth(%lu) at mip %lu must match destinationTexture.depth(%lu) at mip level %lu.
sourceLevel(%lu) + levelCount(%lu) must not exceed sourceTexture.mipmapLevelCount(%lu).
destinationLevel(%lu) + levelCount(%lu) must not exceed destinationTexture.mipmapLevelCount(%lu).
sourceSlice(%lu) + sliceCount(%lu) must not exceed sourceTexture.arrayLength(%lu) x sourceTexture.numFaces(%lu).
destinationSlice(%lu) + sliceCount(%lu) must not exceed destinationTexture.arrayLength(%lu) x destinationTexture.numFaces(%lu).
-[MTLDebugBlitCommandEncoder copyFromTexture:toTexture:]
-[MTLDebugBlitCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtBlitBoundary is not supported.
Sample buffer is not a MTLCounterSampleBuffer.
Sample buffer is associated with a different device.
sampleIndex(%lu) must be < sampleCount(%lu).
-[MTLDebugBlitCommandEncoder resolveCounters:inRange:destinationBuffer:destinationOffset:]
MTLCounterSampleBuffer must be provided
Destination buffer is not a MTLBuffer.
Destination buffer is associated with a different device.
Destination offset (%llu) must be multiple of minimum constant buffer alignment (%llu).
NSMaxRange(range)(%lu) must be <= sampleCount(%lu).
validateMTLBlitOption
option is not a valid MTLBlitOption.
texture
validateBlitProtectionOptions
Blit from %@ has protection options %016llx not set in command buffer protection options %016llx
Blit to %@ with protection options %016llx missing bits set in command buffer protection options %016llx
is illegal on a non-placement heap
is defined on a placement heap only when using a blit method copying entire texture surfaces, or when copying between buffers
is defined on a placement heap only when both textures have the same MTLTextureUsage flags
is defined on a placement heap only when both textures are linear and have the same bufferBytesPerRow value
is defined on a placement heap only when both top-level resources have the same layout
is defined on a placement heap when the texture views refer to the same sub-resources with the same texture type
top-level source and top-level destination resource dimensions must be identical when moving resources inside a placement heap
validateResourceAliasing
blitting between aliasing resources %s.
MTLBlitOptionNone
MTLBlitOptionDepthFromDepthStencil
MTLBlitOptionStencilFromDepthStencil
MTLBlitOptionRowLinearPVRTC
buffer
-[MTLDebugBuffer makeAliasable]
This resource was not allocated on a heap.
-[MTLDebugBuffer newTextureWithDescriptor:offset:bytesPerRow:]
New Texture With Descriptor Validation
resourceOptions (0x%lx) must match backing buffer resource options (0x%lx).
linear texture depth(%ld) must be 1
linear texture mipmapLevelCount(%ld) must be 1
linear texture sampleCount(%ld) must be 1
linear texture arrayLength(%ld) must be 1
linear textures cannot be created with usage MTLTextureUsageRenderTarget
-[MTLDebugBuffer newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:]
Texture Descriptor Validation
2D linear texture array is not supported.
bytesPerImage must be aligned to %u bytes.
-[MTLDebugBuffer setPurgeableState:]
Setting purgeability state directly on heap sub-allocated resources is not allowed.
Cannot set purgeability state to volatile while resource is in use by a command buffer.
validateNewTexture
descriptor must not be nil.
descriptor is not a MTLTextureDescriptor.
MTLTextureDescriptor.usage == MTLTextureUsageUnknown.
cannot create Memoryless texture from Buffer.
Textures with compressed pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with depth pixel formats cannot be created from a buffer and must be created as a standalone texture.
Textures with stencil pixel formats cannot be created from a buffer and must be created as a standalone texture.
bytesPerRow(%lu) must be greater than (width * pixel_bytes)(%lu).
bytesPerRow must be non-zero.
Buffer-backed textures must have a texture type of MTLTextureType2D, MTLTextureTypeTextureBuffer or MTLTextureType2DArray, found %@.
Bytes required by texture offset, stride, height and array length (%lu) exceed buffer capacity(%lu).
Offset of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found offset(%lu)
BytesPerRow of a buffer-backed texture with pixelFormat(%s) must be aligned to %u bytes, found bytesPerRow(%lu)
-[MTLDebugCommandBuffer dealloc]
MTLCommandBuffer is in an invalid status when being destroyed; is it being over-released?
-[MTLDebugCommandBuffer encodeWaitForEvent:value:]
Standard MTLEvents must signal events on the same device. Use MTLSharedEvent for cross-device events.
-[MTLDebugCommandBuffer encodeWaitForEvent:value:timeout:]
-[MTLDebugCommandBuffer encodeSignalEvent:value:]
-[MTLDebugCommandBuffer waitUntilScheduled]
waitUntilScheduled on uncommitted command buffer
-[MTLDebugCommandBuffer waitUntilCompleted]
waitUntilCompleted on uncommitted command buffer
-[MTLDebugCommandBuffer blitCommandEncoder]
encoding in progress
_MTLValidateResolveTexture
MSAA Resolve is only supported for color, depth, and stencil textures
MTLRenderPassDescriptor resolveTexture is associated with a different device
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1D.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType1DArray.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureType2DMultisample.
MTLRenderPassDescriptor resolveTexture must not be MTLTextureTypeTextureBuffer.
MTLRenderPassDescriptor resolveTexture must not be Memoryless.
MTLRenderPassDescriptor texture and resolveTexture size mismatch.
PixelFormat %s cannot be a MSAA resolve target
Texture PixelFormat %s does not match Resolve PixelFormat %s
Slice is %lu, but the texture has only %lu slices
mipmap level is %lu, but the texture has only %lu levels
depth plane is %lu, but the texture has a depth of %lu at mip level %lu
resolveTexture sampleCount is %lu, but must be 1
resolveTexture must not be buffer-backed.
_MTLValidateDepthStencilStoreState
%@: mixing %@ and %@ store actions for the depth and stencil render pass attachments is not allowed.
MTLDebugRenderPipeline
MTLDebugRenderCommandEncoder
%@: the stencil attachment resolve filter mode (MTLMultisampleStencilResolveFilterDepthResolvedSample) is not valid because the depth attachment store action (%@) does not contain a resolve.
-[MTLDebugCommandBuffer addCompletedHandler:]
block cannot be nil
-[MTLDebugCommandBuffer addScheduledHandler:]
-[MTLDebugCommandBuffer unwrapMTLRenderPassDescriptor:]
colorAttachment[%lu].loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
depthAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
stencilAttachment.loadAction of MTLLoadActionDontCare replaced with MTLLoadActionClear
-[MTLDebugCommandBuffer renderCommandEncoderWithDescriptor:]
renderPassDescriptor must not be nil.
renderPassDescriptor is not a MTLRenderPassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoder]
-[MTLDebugCommandBuffer computeCommandEncoderWithDescriptor:]
computePassDescriptor must not be nil.
computePassDescriptor is not a MTLComputePassDescriptor.
-[MTLDebugCommandBuffer blitCommandEncoderWithDescriptor:]
blitPassDescriptor must not be nil.
blitPassDescriptor is not a MTLBlitPassDescriptor.
-[MTLDebugCommandBuffer computeCommandEncoderWithDispatchType:]
-[MTLDebugCommandBuffer parallelRenderCommandEncoderWithDescriptor:]
-[MTLDebugCommandBuffer preCommit]
command buffer references deallocated object which previously existed at address %p.
-[MTLDebugCommandBuffer sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:]
-[MTLDebugCommandBuffer sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:]
-[MTLDebugCommandBuffer lockPurgeableObjects]
MTLResource %p (label: %@), referenced in cmd buffer %p (label: %@) is in volatile or empty purgeable state at commit
MTLStoreActionDontCare
MTLStoreActionStore
MTLStoreActionMultisampleResolve
MTLStoreActionStoreAndMultisampleResolve
MTLStoreActionUnknown
Unknown
validateRenderPassDescriptor
not a MTLDebugTexture.
Texture at colorAttachment[%lu] has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions on color attachment %i includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
Attachment %u overlaps with attachment %u
This set of render targets requires %lu bytes of pixel storage. This device supports %lu bytes.
Texture at depthAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
storeActionOptions on the depth attachment includes MTLStoreActionOptionCustomSamplePositions, but no custom sample positions were specified
This render pass descriptor's clear depth (%f) is outside of the range [0..1]
Texture at stencilAttachment has usage (0x%02lx) which doesn't specify MTLTextureUsageRenderTarget (0x%02lx)
renderTargetWidth (%lu) must be <= minimum attachment width (%lu).
renderTargetHeight (%lu) must be <= minimum attachment height (%lu).
No rendertargets set in RenderPassDescriptor.
Either set rendertargets in RenderPassDescriptor or set renderTargetWidth and renderTargetHeight.
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must have a combined depth+stencil pixel format.
When depth and stencil are used together, the texture bound to the depth and stencil render pass attachments must be the same depth and stencil texture.
When depth and stencil are used together, the render pass has to write to the same level and slice for both.
When depth and stencil are used together, the resolve texture for the depth and stencil render pass attachments must be the same depth and stencil texture.
When both depth (%lu x %lu) and stencil (%lu x %lu) are used from separate textures, they must have identical dimensions.
defaultColorSampleCount (%lu) is not supported by device.
defaultRasterSampleCount (%lu) is not supported by device.
no sampleCount for color and raster available, either set defaultColorSampleCount or set defaultRasterSampleCount or set appropriate attachments
unexpected color and depth/stencil sample counts
defaultColorSampleCount should be zero.
Either set rendertargets in RenderPassDescriptor or set defaultRasterSampleCount.
defaultRasterSampleCount should be zero.
Per sample storage cannot be greater than 64B
Per pixel storage cannot be greater than 256B
Total allocated thread group memory (%lu) cannot be greater than (%lu)
4X MSAA does not support 32 x 32 tiles
MTLRenderPassDescriptor visibilityResultBuffer is associated with a different device
%lu custom sample positions were programmed, but this render pass uses %lu rasterizer sample(s). These counts must match.
startOfVertexSampleIndex (%u) must be < sample buffer sample count (%u)
endOfVertexSampleIndex (%u) must be < sample buffer sample count (%u)
startOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u)
endOfFragmentSampleIndex (%u) must be < sample buffer sample count (%u)
MTLCounterSamplingPointAtStageBoundary is not supported, startOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfVertexSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, startOfFragmentSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfFragmentSampleIndex must be MTLCounterDontSample
validateAttachmentOnDevice
MTLRenderPassDescriptor texture is associated with a different device
Memoryless attachment need to be Texture2D or Texture2DMultisample.
Memoryless attachment cannot be loaded as it have no memory to load from.
Memoryless attachment content cannot be stored in memory.
PixelFormat %s is not color renderable
PixelFormat %s is not depth renderable
PixelFormat %s is not stencil renderable
MTLRenderPassDescriptor texture must not be MTLTextureType1D.
MTLRenderPassDescriptor texture must not be MTLTextureType1DArray.
MTLRenderPassDescriptor texture must not be MTLTextureTypeTextureBuffer.
depth plane index is %lu, but the texture has a depth of %lu at mip level %lu
depth plane + renderTargetArrayLength is %lu, but the texture has a depth of %lu at mip level %lu.
slice + renderTargetArrayLength is %lu, but the texture only has %lu slices.
Mixing MTLTextureType3D with other attachment types is not allowed when renderTargetArrayLength is not zero
MTLRenderPassDescriptor %s store action for the depth attachment is not supported by device
MTLRenderPassDescriptor %s store action for the stencil attachment is not supported by device
MTLRenderPassDescriptor %s store action requires resolve texture
MTLRenderPassDescriptor %s depth resolve filter mode is not supported by device
MTLRenderPassDescriptor MTLMultisampleStencilResolveFilterDepthResolvedSample stencil resolve filter mode is not supported by device
MTLRenderPassDescriptor render targets have inconsistent sample counts.
MTLRenderPassDescriptor texture must not be buffer-backed.
MTLRenderPassDescriptor resolveTexture must have storeAction of MTLStoreActionMultisampleResolve, MTLStoreActionStoreAndMultisampleResolve or MTLStoreActionUnknown
MTLRenderPassDescriptor texture must be MTLTextureType2DMultisample when using a resolveTexture.
texture sampleCount is %lu, but must be > 1 when using a resolveTexture
the depth attachment
the stencil attachment
color attachment %lu
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, but Programmable Sample Positions is not supported on this device.
storeActionOptions on %@ includes MTLStoreActionOptionCustomSamplePositions, which does not apply to the store action (%@).
MTLMultisampleDepthResolveFilterSample0
MTLMultisampleDepthResolveFilterMin
MTLMultisampleDepthResolveFilterMax
validateTileDimensions
Invalid tile dimensions (%lu, %lu)
validateComputePassDescriptor
startOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u)
endOfEncoderSampleIndex (%u) must be < sample buffer sample count (%u)
MTLCounterSamplingPointAtStageBoundary is not supported, startOfEncoderSampleIndex must be MTLCounterDontSample
MTLCounterSamplingPointAtStageBoundary is not supported, endOfEncoderSampleIndex must be MTLCounterDontSample
validateBlitPassDescriptor
validateStoreLoadTransition
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. The results are undefined.
Attachment (name:%@) at index %d previously used store action %@ and now it is using loadAction %@. This is perfectly valid transition but it will result in reduced performance.
MTLLoadActionDontCare
MTLLoadActionLoad
MTL_DEBUG_LAYER_VALIDATE_UNRETAINED_RESOURCES
-[MTLDebugDynamicLibrary serializeToURL:error:]
url must not be nil.
url must be a file URL.
-[MTLDebugDynamicLibrary serializeToURL:options:error:]
-[MTLDebugCounterSampleBuffer resolveCounterRange:]
NSMaxRange(indexRange)(%lu) must be <= sampleCount(%lu).
CPU access not allowed for sample buffers with MTLResourceStorageModePrivate.
-[MTLDebugBinaryArchive addComputePipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLComputePipelineDescriptor object.
descriptor.computeFunction must not be nil.
-[MTLDebugBinaryArchive addRenderPipelineFunctionsWithDescriptor:options:error:]
descriptor is not a MTLRenderPipelineDescriptor object.
-[MTLDebugBinaryArchive addTileRenderPipelineFunctionsWithDescriptor:options:error:]
device does not support tile shaders
descriptor is not a MTLTileRenderPipelineDescriptor object.
-[MTLDebugBinaryArchive serializeToURL:error:]
-[MTLDebugBinaryArchive serializeToURL:options:error:]
MTL_COUNTERS_LAYER_API_TIMING
-[MTLDebugCommandQueue insertDebugCaptureBoundary]
InsertDebugCaptureBoundary should not be called inside the completion handler
-[MTLDebugComputeCommandEncoder dealloc]
computePipelineState =
<null>
Set Buffers:
Buffer %lu:
Set Textures:
Texture %lu:
Set Samplers:
Sampler %lu:
Set ThreadgroupMemoryLengths:
Threadgroup %lu:
Image Block Size: %lu x %lu
-[MTLDebugComputeCommandEncoder setComputePipelineState:]
computePipelineState must not be nil.
computePipelineState is not a MTLComputePipelineState.
computePipelineState is associated with a different device
redundant setComputePipelineState.
previous setComputePipelineState was unused.
-[MTLDebugComputeCommandEncoder setBytes:length:atIndex:]
length(%lu) must be <= %lu.
-[MTLDebugComputeCommandEncoder setBuffer:offset:atIndex:]
offset(%lu) must be < [buffer length](%lu).
offset(%lu) must be 0.
-[MTLDebugComputeCommandEncoder setBufferOffset:atIndex:]
index(%lu) must have an existing buffer.
-[MTLDebugComputeCommandEncoder setBuffers:offsets:withRange:]
NSMaxRange(range)(%lu) must be <= %lu.
buffers[%lu] is not an MTLBuffer.
buffers[%lu] is associated with a different device
offset[%lu](%lu) must be < [buffers[%lu] length](%lu).
offsets[%lu](%lu) must be 0.
-[MTLDebugComputeCommandEncoder setTexture:atIndex:]
frameBufferOnly texture not supported for compute.
Memoryless texture not supported for compute.
-[MTLDebugComputeCommandEncoder setTextures:withRange:]
textures[%lu] is not an MTLTexture.
textures[%lu] is associated with a different device
frameBufferOnly textures[%lu] not supported for compute.
textures[%lu] is Memoryless and cannot be assigned.
-[MTLDebugComputeCommandEncoder setSamplerState:atIndex:]
sampler is not a MTLSamplerState.
sampler is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerStates:withRange:]
samplers[%lu] is not an MTLSamplerState.
samplers[%lu] is associated with a different device
-[MTLDebugComputeCommandEncoder setSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugComputeCommandEncoder setSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugComputeCommandEncoder setThreadgroupMemoryLength:atIndex:]
length(%lu) must be a multiple of %lu bytes.
-[MTLDebugComputeCommandEncoder setImageblockWidth:height:]
width(%lu) must be a power of 2.
height(%lu) must be a power of 2.
width(%lu)*height(%lu) must be less than or equal to 1024
-[MTLDebugComputeCommandEncoder validateStageInRegion:]
stage_in region (width(%lu) * height(%lu) * depth(%lu))(%lu) must not be 0.
stage_in region (width)(%lu) must be <= width(%lu).
stage_in region (height)(%lu) must be <= height(%lu).
stage_in region (depth)(%lu) must be <= depth(%lu).
-[MTLDebugComputeCommandEncoder setStageInRegionWithIndirectBuffer:indirectBufferOffset:]
indirectBufferOffset (%lu) must be a multiple of 4
-[MTLDebugComputeCommandEncoder _validateThreadsPerThreadgroup:]
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must not be 0.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (device threadgroup size limit)
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be <= %lu. (kernel threadgroup size limit)
threadsPerThreadgroup.width(%lu) must be <= %lu.
threadsPerThreadgroup.height(%lu) must be <= %lu.
threadsPerThreadgroup.depth(%lu) must be <= %lu.
(threadsPerThreadgroup.width(%lu) * threadsPerThreadgroup.height(%lu) * threadsPerThreadgroup.depth(%lu))(%lu) must be multiples of %lu.
-[MTLDebugComputeCommandEncoder dispatchThreadgroups:threadsPerThreadgroup:]
threadgroupsPerGrid.width(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.height(%lu) must be <= UINT32_MAX.
threadgroupsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadgroupsPerGrid.width(%lu) * threadgroupsPerGrid.y(%lu) * threadgroupsPerGrid.depth(%lu))(%lu) must not be 0.
Compute
stage_in region was not set for compute pipeline
-[MTLDebugComputeCommandEncoder dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:]
indirectBuffer must not be nil.
indirectBuffer is not a MTLBuffer.
indirectBuffer is associated with a different device
(indirectBufferOffset + sizeof(MTLDispatchThreadgroupsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
indirectBufferOffset(%lu) must be a multiple of 4 bytes.
-[MTLDebugComputeCommandEncoder dispatchThreads:threadsPerThreadgroup:]
threadsPerGrid.width(%lu) must be <= UINT32_MAX.
threadsPerGrid.height(%lu) must be <= UINT32_MAX.
threadsPerGrid.depth(%lu) must be <= UINT32_MAX.
(threadsPerGrid.width(%lu) * threadsPerGrid.y(%lu) * threadsPerGrid.depth(%lu))(%lu) must not be 0.
-[MTLDebugComputeCommandEncoder dispatchThreadsWithIndirectBuffer:indirectBufferOffset:]
(indirectBufferOffset + sizeof(MTLDispatchThreadsIndirectArguments))(%lu) must be <= [indirectBuffer length](%lu).
-[MTLDebugComputeCommandEncoder waitForFence:]
-[MTLDebugComputeCommandEncoder endEncoding]
endEncoding without dispatchThreadgroups.
-[MTLDebugComputeCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
-[MTLDebugComputeCommandEncoder useResource:usage:]
resource should not be nil
usage (0x%lx) has an invalid value
-[MTLDebugComputeCommandEncoder useResources:count:usage:]
resource (at index: %lu) should not be nil
-[MTLDebugComputeCommandEncoder useHeap:]
heap should not be nil
-[MTLDebugComputeCommandEncoder useHeaps:count:]
heap (at index: %lu) should not be nil
-[MTLDebugComputeCommandEncoder memoryBarrierWithScope:]
scope (0x%lx) has an invalid value for compute
compute memoryBarrierWithScope is not supported on this device
-[MTLDebugComputeCommandEncoder memoryBarrierWithResources:count:]
resources should not be nil or empty array
compute memoryBarrierWithResources is not supported on this device
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:withRange:]
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the compute pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugComputeCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugComputeCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDispatchBoundary is not supported.
validateArg
unused binding in encoder at %s index %lu.
sampler
threadgroupMemory
MTLDebugFunctionArgumentInit
redundant setting of %@.
thread_position_in_grid
threads_per_grid
thread_position_in_threadgroup
thread_index_in_threadgroup
threads_per_threadgroup
threadgroup_position_in_grid
threadgroups_per_grid
validateBuiltinArguments
Invalid built-in argument %@
component %lu: %llu must be <= %llu for %@ [[ %@ ]]
validateComputeFunctionArguments
%@ Function(%@): missing %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect %s binding at index %lu for %@[%lu].
%@ Function(%@): the offset into the buffer %@ that is bound at %s index %lu must be a multiple of %lu but was set to %lu.
%@ Function(%@): argument %@[%lu] from %s(%lu) with offset(%lu) and length(%lu) has space for %lu bytes, but argument has a length(%lu).
%@ Function(%@): Bytes are being bound at index %lu to a shader argument with write access enabled.
%@ Function(%@): Reading from buffer bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to buffer bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
%@ Function(%@): threadgroupMemoryLength(%lu) must be >= %lu at %s binding at index %lu for %@[%lu].
%@ Function(%@): incorrect type of texture (%@) bound at %s binding at index %lu (expect %@) for %@[%lu].
%@ Function(%@): Non-writeable texture format %s is being bound at index %lu to a shader argument with write access enabled.
%@ Function(%@): The pixel format (%s) of the %s (name:%@) bound at index %lu is incompatible with the data type (%@) of the %s parameter (%@ [[%s(%lu)]]). %s is compatible with the data type(s) %@.
%@ Function(%@): reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
%@ Function(%@): Shader uses texture(%@[%lu]) as read-write, but hardware does not support read-write texture of this pixel format.
%@ Function(%@): Reading from texture bound at index %lu has protection options %016llx not set in command buffer protection options %016llx
%@ Function(%@): Writing to texture bound at index %lu with protection options %016llx missing bits set in command buffer protection options %016llx
Functon(%@): total used threadgroupMemoryLength(%lu) must be <= %lu.
-[MTLDebugIndirectCommandBuffer indirectRenderCommandAtIndex:]
CPU access for MTLIndirectCommandBuffer with MTLResourceStorageModePrivate storage mode is disallowed.
MTLIndirectCommandBuffer created without any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectRenderCommands 
The requested command (%lu) is greater than the indirect command buffer size (%lu)
-[MTLDebugIndirectCommandBuffer indirectComputeCommandAtIndex:]
MTLIndirectCommandBuffer created with any MTLIndirectCommandTypeDraw commandTypes descriptor.commandTypes(%lu) cannot be used to create MTLIndirectComputeCommands 
-[MTLDebugIndirectCommandBuffer setPurgeableState:]
-[MTLDebugIndirectCommandBuffer resetWithRange:]
MTL_XML_DUMP_COUNTERS
MTL_XML_SYNC_BEFORE_SAMPLE
MTL_XML_TRACE_PATH
xml_trace_%p
Error creating directory '%@' (%@)
MTL_XML_COUNTER_NAMES
MTLStat_nSec
Unsupported counter: %@
Failed to request counters
findMemberContainingIndex
Index %u does not match any member of the argument buffer
indexRangeIsValueType
Index %u does not correspond to any valid member of the argument buffer
Trying to set a %@ at index %u but the argument buffer has a %@ at this index
index range (%lu, %lu) has indices that are outside of the valid index range [%u, %u]
indexIsValueType
index (%lu) is outside of the valid index range [%u, %u]
-[MTLDebugArgumentEncoder setArgumentBuffer:startOffset:elementIndex:]
buffer storage mode (%@) should be MTLStorageModeShared
offset (%lu) + encodedLength (%lu) should be smaller or equal to the buffer length (%lu)
-[MTLDebugArgumentEncoder setFunctionPointer:atIndex:]
No argument buffer is set
-[MTLDebugArgumentEncoder setFunctionPointers:withRange:]
-[MTLDebugArgumentEncoder setBuffer:offset:atIndex:]
offset (%lu) should be smaller than the buffer lengh (%lu)
-[MTLDebugArgumentEncoder setBuffers:offsets:withRange:]
-[MTLDebugArgumentEncoder setTexture:atIndex:]
-[MTLDebugArgumentEncoder setTextures:withRange:]
-[MTLDebugArgumentEncoder setSamplerState:atIndex:]
Sampler state did not have supportArgumentBuffers flag set on creation, but is used with argument buffers
-[MTLDebugArgumentEncoder setSamplerStates:withRange:]
-[MTLDebugArgumentEncoder constantDataAtIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineState:atIndex:]
-[MTLDebugArgumentEncoder setRenderPipelineStates:withRange:]
-[MTLDebugArgumentEncoder setComputePipelineState:atIndex:]
-[MTLDebugArgumentEncoder setComputePipelineStates:withRange:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffer:atIndex:]
-[MTLDebugArgumentEncoder setIndirectCommandBuffers:withRange:]
-[MTLDebugArgumentEncoder newArgumentEncoderForBufferAtIndex:]
No indirect argument buffer at that index
Constant
Texture
Sampler
Buffer
Struct
RenderPipelineState
ComputePipelineState
IndirectCommandBuffer
METAL_COMPLAIN_ABOUT_SLOPPY_TEXTURE_USAGE
MTL_DEBUG_LAYER_VALIDATE_STORE_ACTIONS
MTL_DEBUG_LAYER_VALIDATE_LOAD_ACTIONS
-[MTLDebugDevice heapTextureSizeAndAlignWithDescriptor:]
-[MTLDebugDevice newHeapWithDescriptor:]
New Heap With Descriptor Validation
Heap needs to have a size.
Requested storage mode is not allowed for Heaps.
Requested CPU cache mode is not allowed for Heaps.
Requested hazard tracking mode is not allowed for Heaps.
Memoryless texture need to have renderable PixelFormat.
Memoryless texture need to be of type Texture2D or Texture2DMultisample.
options 0x%lx conveys invalid cpuCacheMode of 0x%lx
IOSurface textures must use MTLStorageModeShared
MTLStorageModeShared not allowed for textures
MTLStorageModeMemoryless can only be used with textures
MTLStorageModeMemoryless is not supported on this device
Illegal MTLStorageMode 0x%lx
options 0x%lx conveys invalid hazardTrackingMode of 0x%lx
MTLResourceOptions options has unknown bits 0x%lx.
Cannot create buffer of zero length.
newBufferWith*:length 0x%lx must not exceed %llu MB.
-[MTLDebugDevice newBufferWithLength:options:]
Buffer Validation
-[MTLDebugDevice newBufferWithBytes:length:options:]
storageModePrivate incompatible with ...WithBytes variant of newBuffer
newBufferWithBytes:pointer must not be nil.
-[MTLDebugDevice newBufferWithBytesNoCopy:length:options:deallocator:]
storageModePrivate incompatible with ...WithBytesNoCopy variant of newBuffer
newBufferWithBytesNoCopy:pointer must not be nil.
newBufferWithBytesNoCopy:pointer %p is not %d byte aligned.
newBufferWithBytesNoCopy:length 0x%lx is not %d byte aligned.
-[MTLDebugDevice newIndirectCommandBufferWithDescriptor:maxCommandCount:options:]
Indirect Command Buffer Validation
-[MTLDebugDevice newArgumentEncoderWithArguments:]
arguments cannot be nil
arguments must have at least one element
-[MTLDebugDevice newTextureWithBytesNoCopy:length:descriptor:deallocator:]
MTLResourceStorageModeShared must be used.
newTextureWithBytesNoCopy:pointer must not be nil.
newTextureWithBytesNoCopy:pointer %p is not %d byte aligned.
-[MTLDebugDevice newDepthStencilStateWithDescriptor:]
descriptor is not a MTLDepthStencilDescriptor.
texture buffer width (%llu) must be less than %llu
texture buffer height (%llu) must be 1
texture buffer depth (%llu) must be 1
texture buffer mipmapLevelCount (%llu) must be 1
texture buffer sampleCount (%llu) must be 1
texture buffer arrayLength (%llu) must be 1
usage must be set
MTLTextureUsageRenderTarget is not valid for a texture buffer
Texture buffer usage must contain read or write
texture buffer with pixel format (%s) cannot be written to from a shader
pixel format (%s) cannot be written to from a shader on this device
pixel format (%s) cannot be used for a texture buffer
-[MTLDebugDevice newTextureWithDescriptor:]
Cannot use an Xn format when creating a new texture
-[MTLDebugDevice newSamplerStateWithDescriptor:]
descriptor is not a MTLSamplerDescriptor.
-[MTLDebugDevice newBinaryArchiveWithDescriptor:error:]
descriptor is not a MTLBinaryArchiveDescriptor object.
url, if not nil, must be a file URL.
-[MTLDebugDevice newBinaryLibraryWithOptions:url:error:]
-[MTLDebugDevice newDynamicLibraryWithURL:options:error:]
device does not support dynamic libraries
-[MTLDebugDevice newDynamicLibrary:computeDescriptor:error:]
library must not be nil.
library is not a MTLLibrary object.
-[MTLDebugDevice newDynamicLibrary:error:]
-[MTLDebugDevice loadDynamicLibrariesForComputeDescriptor:error:]
-[MTLDebugDevice validateDynamicLibrary:state:error:]
-[MTLDebugDevice validateDynamicLibraryURL:error:]
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:reflection:error:]
descriptor is not a MTLRenderPipelineDescriptor.
-[MTLDebugDevice _newRenderPipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice validateLinkedFunctions:]
Function '%s' in group '%s' was not found in functions array.
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:reflection:error:]
function must not be nil.
descriptor is not a MTLComputePipelineDescriptor.
-[MTLDebugDevice _newComputePipelineStateWithDescriptor:options:completionHandler:]
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:reflection:error:]
descriptor is not a MTLTileRenderPipelineDescriptor.
-[MTLDebugDevice _newRenderPipelineStateWithTileDescriptor:options:completionHandler:]
-[MTLDebugDevice newLibraryWithFile:error:]
filepath must not be nil.
filepath is not a NSString.
-[MTLDebugDevice newLibraryWithURL:error:]
url is not a NSURL.
Invalid file url
-[MTLDebugDevice newLibraryWithSource:options:error:]
source must not be nil.
source is not a NSString.
options is not a MTLCompileOptions.
options.libraries contains an object that is not a MTLDynamicLibrary.
-[MTLDebugDevice newLibraryWithSource:options:completionHandler:]
-[MTLDebugDevice newLibraryWithData:error:]
data must not be nil.
-[MTLDebugDevice newPipelineLibraryWithFilePath:error:]
-[MTLDebugDevice newTextureWithDescriptor:iosurface:plane:]
iosurface must not be nil.
-[MTLDebugDevice newBufferWithIOSurface:]
-[MTLDebugDevice minLinearTextureAlignmentForPixelFormat:]
%s is not supported on this device.
Linear textures do not support compressed pixel formats
Linear textures do not support depth/stencil pixel formats
-[MTLDebugDevice minimumLinearTextureAlignmentForPixelFormat:]
-[MTLDebugDevice newCounterSampleBufferWithDescriptor:error:]
MTLCounterSampleBufferDescriptor must be provided
descriptor is not a MTLCounterSampleBufferDescriptor.
-[MTLDebugDevice newFence]
Attempt to create new fence over the fence instance limit (%lu).
The following Metal object is being destroyed while still required to be alive by the command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
The following Metal object has been over-released by the application and is being destroyed while still retained by command buffer %p (label: %@):
<MTLToolsObject: %p> -> %@
-[MTLDebugDevice notifyExternalReferencesNonZeroOnDealloc:]
<no label set>
MTLDebugShaders
simple_vertex
fill_checkboard_fragment
buffer =
bufferOffset =
texture =
baseLevel =
sampler =
lodMinClamp =
lodMaxClamp =
threadgroupMemoryLength =
newArgumentEncoder
Function %@ does not have a buffer argument with buffer index %lu
Buffer argument %@ (buffer index: %lu) of function %@ is not an indirect argument buffer
-[MTLDebugLibrary newFunctionWithName:]
name is not a NSString.
validateNewFunctionWithConstantArguments
functionName is not a NSString.
constantValues must not be nil.
-[MTLDebugLibrary validateDescriptor:expectedClass:]
descriptor is not a %@.
-[MTLDebugParallelRenderCommandEncoder setColorStoreAction:atIndex:]
attachmentIndex(%lu) must be < %lu
-[MTLDebugParallelRenderCommandEncoder setColorStoreActionOptions:atIndex:]
-[MTLDebugParallelRenderCommandEncoder endEncoding]
endEncoding called with store action for color attachment index %u still set to MTLStoreActionUnknown
endEncoding called with store action for depth attachment still set to MTLStoreActionUnknown
endEncoding called with store action for stencil attachment still set to MTLStoreActionUnknown
endEncoding called with store action unsupported for Memoryless attachment.
-[MTLDebugParallelRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
filterCounterRangeWithFirstBatch should not be called on ParallelRenderCommandEncoders
_MTLDebugValidateBuffer
%s must not be nil.
%s is not a MTLBuffer.
%s is associated with a different device
_MTLDebugValidateIndexBuffer
%sOffset(%lu) must be a multiple of %lu bytes.
%sOffset(%lu) + (indexCount(%lu) * %lu) must be <= [%s length](%lu).
indexCount(%lu) must be non-zero.
_MTLDebugValidatePatchIndexBuffer
%sOffset(%lu) + (patchIndicesUsed(%lu) * %lu) must be <= [%s length](%lu).
patchCount(%lu) must be non-zero.
instanceCount(%lu) must be non-zero.
%sOffset(%lu) must be 0.
v24@?0@"<MTLRenderCommandEncoderSPI>"8Q16
-[MTLDebugRenderCommandEncoder initWithRenderCommandEncoder:parent:descriptor:]_block_invoke
Exceeded HW limit of resources used by render encoder working in Memoryless mode.
Exceeded HW limit of scissor rectangles for render encoder working in Memoryless mode.
Exceeded HW limit of depth biases for render encoder working in Memoryless mode.
-[MTLDebugRenderCommandEncoder dealloc]
Command encoder released without endEncoding
descriptor =
viewportCount =
viewports:
Viewport %lu:
frontFacingWinding =
cullMode =
depthClipMode =
lineWidth =
depthBias =
depthBiasSlopeScale =
depthBiasClamp =
scissorRectCount =
scissorRects:
Scissor %lu:
triangleFillMode =
renderPipelineState =
depthStencilState =
frontStencilRef =
0x%x
backStencilRef =
visibilityResultMode =
visibilityResultOffset =
Blend Color =
%g %g %g %g
Set Vertex Buffers:
Set Vertex Textures:
Set Vertex Samplers:
Set Fragment Buffers:
Set Fragment Textures:
Set Fragment Samplers:
Set Tile Buffers:
Set Tile Textures:
Set Tile Samplers:
Set Tessellation Factor Buffer =
tessellationFactorBufferInstanceStride =
tessellationFactorScale =
-[MTLDebugRenderCommandEncoder validateFramebufferWithRenderPipelineState:]
Framebuffer With Render Pipeline State Validation
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState colorSampleCount (%lu).
For color attachment %d, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For color attachment %d, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For color attachment %d, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For depth attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For depth attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For depth attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState rasterSampleCount (%lu).
For stencil attachment, the texture sample count (%lu) does not match the renderPipelineState sampleCount (%lu).
For stencil attachment, the render pipeline's pixelFormat (%s) does not match the framebuffer's pixelFormat (%s).
For stencil attachment, the renderPipelineState pixelFormat must be MTLPixelFormatInvalid, as no texture is set.
The color sample count (%lu) does not match the renderPipelineState's color sample count (%lu)
The raster sample count (%lu) does not match the renderPipelineState's raster sample count (%lu)
Device does not support separable raster/color shading rates
The sample count (%lu) does not match the renderPipelineState's sample count (%lu)
-[MTLDebugRenderCommandEncoder setRenderPipelineState:]
renderPipelineState must not be nil.
redundant setRenderPipelineState.
previous setRenderPipelineState was unused.
renderPipelineState is not a MTLRenderPipelineState.
renderPipelineState is associated with a different device
the pipelineState's per sample imageBlock usage(%lu) is greater than the encoder's perSample imageBlock usage(%lu)
The threadgroup memory consumed must be <= (%lu)
-[MTLDebugRenderCommandEncoder setVertexBytes:length:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexBufferOffset:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexBuffers:offsets:withRange:]
-[MTLDebugRenderCommandEncoder setVertexTexture:atIndex:]
texture is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexTextures:withRange:]
textures[%lu] is Memoryless, and cannot be assigned.
-[MTLDebugRenderCommandEncoder setVertexSamplerState:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:withRange:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentBytes:length:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBufferOffset:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentBuffers:offsets:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentTextures:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:]
-[MTLDebugRenderCommandEncoder setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:]
textureIndex(%lu) must be < %lu.
samplerIndex(%lu) must be < %lu.
-[MTLDebugRenderCommandEncoder setTileBytes:length:atIndex:]
-[MTLDebugRenderCommandEncoder setTileBuffer:offset:atIndex:]
-[MTLDebugRenderCommandEncoder setTileBufferOffset:atIndex:]
-[MTLDebugRenderCommandEncoder setTileBuffers:offsets:withRange:]
-[MTLDebugRenderCommandEncoder setTileTexture:atIndex:]
-[MTLDebugRenderCommandEncoder setTileTextures:withRange:]
-[MTLDebugRenderCommandEncoder setTileSamplerState:atIndex:]
-[MTLDebugRenderCommandEncoder setTileSamplerStates:withRange:]
-[MTLDebugRenderCommandEncoder setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:]
-[MTLDebugRenderCommandEncoder setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:]
-[MTLDebugRenderCommandEncoder dispatchThreadsPerTile:]
the renderPipelineState was not created with a tileDescriptor
threadsPerTile (%lu, %lu) must equal tile size (%lu, %lu) when threadgroupSizeMatchesTileSize is true
threadsPerTile.width(%lu) and threadsPerTile.height(%lu) must match the tile size or threadsPerTile.width(%lu) must be equal to threadsPerTile.height(%lu)
roundup2(threadsPerTile.width(%lu)) * roundup2(threadsPerTile.height(%lu)) * threadsPerTile.depth(%lu) must be <= %lu, both width and height are rounded up to nearest even number 
tile shader input image-block layout must match the previous state's image-block layout
threadsPerTile.width(%lu) * threadsPerTile.height(%lu) * threadsPerTile.depth(%lu) must not be 0
threadsPerTile.width(%lu) must be <= %lu
threadsPerTile.depth(%lu) must be 1
Tile
-[MTLDebugRenderCommandEncoder setThreadgroupMemoryLength:offset:atIndex:]
A dispatch is required to reinterpret threadgroup memory.
offset + length(%lu) must be <= threadgroupMemoryLength(%lu).
offset(%lu) must be a multiple of %lu bytes.
-[MTLDebugRenderCommandEncoder useResource:usage:]
-[MTLDebugRenderCommandEncoder useResource:usage:stages:]
stages (0x%lx) has an invalid stage
'stages' does not specify any render stages. Specify at least one stage.
-[MTLDebugRenderCommandEncoder useResources:count:usage:]
-[MTLDebugRenderCommandEncoder useResources:count:usage:stages:]
-[MTLDebugRenderCommandEncoder useHeap:]
-[MTLDebugRenderCommandEncoder useHeap:stages:]
-[MTLDebugRenderCommandEncoder useHeaps:count:]
-[MTLDebugRenderCommandEncoder useHeaps:count:stages:]
-[MTLDebugRenderCommandEncoder setViewport:]
Viewport Validation
redundant setViewport.
previous setViewport was unused.
-[MTLDebugRenderCommandEncoder setViewports:count:]
viewports parameter cannot be nullptr
viewport count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setFrontFacingWinding:]
redundant setFrontFacingWinding.
previous setFrontFacingWinding was unused.
-[MTLDebugRenderCommandEncoder setCullMode:]
redundant setCullMode.
previous setCullMode was unused.
-[MTLDebugRenderCommandEncoder setDepthClipMode:]
redundant setDepthClipMode.
previous setDepthClipMode was unused.
-[MTLDebugRenderCommandEncoder setLineWidth:]
lineWidth(%g) must be between 1.0f and %.1ff
redundant setLineWidth.
previous setLineWidth was unused.
-[MTLDebugRenderCommandEncoder setDepthBias:slopeScale:clamp:]
redundant setDepthBias.
previous setDepthBias was unused.
-[MTLDebugRenderCommandEncoder setScissorRect:]
redundant setScissorRect.
previous setScissorRect was unused.
-[MTLDebugRenderCommandEncoder setScissorRects:count:]
scissorRects parameter cannot be nullptr
scissor rect count must be between 1 and %d
-[MTLDebugRenderCommandEncoder setTriangleFrontFillMode:backFillMode:]
-[MTLDebugRenderCommandEncoder setTriangleFillMode:]
redundant setTriangleFillMode.
previous setTriangleFillMode was unused.
-[MTLDebugRenderCommandEncoder setDepthStencilState:]
depthStencilState must not be nil.
depthStencilState is not a MTLDepthStencilState.
depthStencilState is associated with a different device
redundant setDepthStencilState.
previous setDepthStencilState was unused.
-[MTLDebugRenderCommandEncoder setStencilReferenceValue:]
redundant setStencilReferenceValue.
previous setStencilReferenceValue was unused.
-[MTLDebugRenderCommandEncoder setStencilFrontReferenceValue:backReferenceValue:]
_MTLDebugValidateDeferredStoreActionOnDevice
storeAction must not be MTLStoreActionUnknown
store actions known at render command encoder init time may not be mutated
storeAction unsupported for Memoryless attachment.
Store action for color attachment index %u must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for depth attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
Store action for stencil attachment must be one of MTLStoreActionMultisampleResolve or MTLStoreActionStoreAndMultisampleResolve
-[MTLDebugRenderCommandEncoder setColorStoreAction:atIndex:]
deferred color store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreAction:]
deferred depth store actions cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreAction:]
deferred stencil store actions cannot be set on sub render command encoders
_MTLDebugValidateDeferredStoreActionOptionsOnDevice
-[MTLDebugRenderCommandEncoder setColorStoreActionOptions:atIndex:]
deferred color store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setDepthStoreActionOptions:]
deferred depth store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setStencilStoreActionOptions:]
deferred stencil store action options cannot be set on sub render command encoders
-[MTLDebugRenderCommandEncoder setVisibilityResultMode:offset:]
offset(%lu) must be a multiple of result-size(%u) bytes.
offset(%lu) must be <= %lu.
using the same offset (%lu) in the visibility buffer twice in the same command encoder is not allowed.
framebuffer visibilityResultBuffer must not be nil.
offset(%lu) + result-size(%u) must be <= [visibilityResultBuffer length](%lu).
redundant setVisibilityResultMode.
previous setVisibilityResultMode was unused.
-[MTLDebugRenderCommandEncoder setBlendColorRed:green:blue:alpha:]
redundant setBlendColorRed.
previous setBlendColorRed was unused.
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:atIndex:]
-[MTLDebugRenderCommandEncoder setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:]
_MTLDebugValidateMTLPrimitiveType
primitiveType is not a valid MTLPrimitiveType.
-[MTLDebugRenderCommandEncoder validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:]
renderPipelineState must be set.
renderPipelineState must be created using a MTLRenderPipelineDescriptor.
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassPoint but primitiveType is not MTLPrimitiveTypePoint
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassLine but primitiveType is neither MTLPrimitiveTypeLine nor MTLPrimitiveTypeLineStrip
renderPipelineState inputPrimitiveTopology is MTLPrimitiveTopologyClassTriangle but primitiveType is neither MTLPrimitiveTypeTriangle nor MTLPrimitiveTypeTriangleStrip
The scissor rectangle count (%lu) should be equal to the viewport count (%lu) or should be 1.
input image-block layout must match the previous state image-block layout
the renderPipelineState has a vertex shader that writes to render_target_array_index but renderTargetArrayLength is set to zero
Vertex
Fragment
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:]
indexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:]
-[MTLDebugRenderCommandEncoder drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
indirectBuffer
sizeof(MTLDrawPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder drawPrimitives:indirectBuffer:indirectBufferOffset:]
sizeof(MTLDrawIndexedPrimitivesIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder waitForFence:beforeStages:]
-[MTLDebugRenderCommandEncoder endEncoding]
endEncoding without draw.
-[MTLDebugRenderCommandEncoder setTessellationFactorBuffer:offset:instanceStride:]
offset(%lu) must be a multiple of 4 bytes.
instanceStride(%lu) must be a multiple of 4 bytes.
-[MTLDebugRenderCommandEncoder setTessellationFactorScale:]
scale(%g) must be a normal floating point value (not denormal, infinite, nor NaN) and must be > 0.0f.
-[MTLDebugRenderCommandEncoder drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:]
patchIndexBuffer
-[MTLDebugRenderCommandEncoder drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
sizeof(MTLDrawPatchIndirectArguments)
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:]
controlPointIndexBuffer
-[MTLDebugRenderCommandEncoder drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder filterCounterRangeWithFirstBatch:lastBatch:filterIndex:]
-[MTLDebugRenderCommandEncoder textureBarrier]
-textureBarrier is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithScope:afterStages:beforeStages:]
render memoryBarrierWithScope is not supported on this device
-[MTLDebugRenderCommandEncoder memoryBarrierWithResources:count:afterStages:beforeStages:]
render memoryBarrierWithResources is not supported on this device
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:withRange:]
The indirect command buffer inherits pipelines ( inheritPipelineState = YES) but the render pipeline set on this encoder does not support indirect command buffers ( supportIndirectCommandBuffers = NO )
-[MTLDebugRenderCommandEncoder executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:]
-[MTLDebugRenderCommandEncoder sampleCountersInBuffer:atSampleIndex:withBarrier:]
MTLCounterSamplingPointAtDrawBoundary is not supported.
MTLIndexTypeSize
indexType not valid MTLIndexType
%g %g %g %g %g %g
MTLWindingClockwise
MTLWindingCounterClockwise
MTLCullModeNone
MTLCullModeFront
MTLCullModeBack
MTLDepthClipModeClip
MTLDepthClipModeClamp
%lu %lu %lu %lu
MTLTriangleFillModeFill
MTLTriangleFillModeLines
MTLTriangleFillModePoint
MTLVisibilityResultModeDisabled
MTLVisibilityResultModeBoolean
MTLVisibilityResultModeCounting
local memory
%s must not be infinite or NaN.
viewport.originX
viewport.originY
viewport.width
viewport.height
viewport.znear
viewport.zfar
validateMTLWinding
frontFacingWinding is not a valid MTLWinding.
validateMTLCullMode
cullMode is not a valid MTLCullMode.
validateMTLDepthClipMode
depthClipMode is not a valid MTLDepthClipMode.
validateMTLScissorRect
(rect.x(%lu) + rect.width(%lu))(%lu) must be <= render pass width(%lu)
(rect.y(%lu) + rect.height(%lu))(%lu) must be <= render pass height(%lu)
validateMTLTransformFeedbackState
state(%u) is not a valid MTLTransformFeedbackState.
validateMTLTriangleFillMode
fillMode is not a valid MTLTriangleFillMode.
validateMTLVisibilityResultMode
mode is not a valid MTLVisibilityResultMode.
validateFunctionArguments
%@ Function(%@): Shader reads texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderRead (0x%02lx)
%@ Function(%@): Shader writes texture (%@[%lu]) whose usage (0x%02lx) doesn't specify MTLTextureUsageShaderWrite (0x%02lx)
q24@?0@8@16
%@ Function(%@): there is an overlap with the threadgroupMemoryArgument at offset (%lu) and at offset(%lu).
validateDisjointRenderTargetsAndTexture
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also a %s attachment at index %lu. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and writeMask != MTLColorWriteMaskNone.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and depth writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is also the %s attachment. This may be a conflict as the %s attachment's storeAction == MTLStoreActionStore and stencil writes are enabled.
%@ Function(%@): uses %s binding at index %lu for %@[%lu] which is currently being written to in this render pass. This may be a conflict.
resolve
color
depth
stencil
validateBuiltInArguments
vertex_id type is not big enough to draw this many vertices (%lu)
instance_id type is not big enough to draw this many instances (%lu)
validateVertexDescriptor
missing vertexDescriptor %s binding at index %lu.
incorrect vertexDescriptor %s binding at index %lu.
validateDepthStencilState
MTLDepthStencilDescriptor sets depth test but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor has depthWriteEnabled but MTLRenderPassDescriptor has a nil depthAttachment texture
MTLDepthStencilDescriptor uses frontFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
MTLDepthStencilDescriptor uses backFaceStencil but MTLRenderPassDescriptor has a nil stencilAttachment texture
validateVertexFunction
%s requires a postTessellationVertexFunction but the vertexFunction of the renderPipelineState is not a postTessellationVertexFunction.
%s requires a normal vertexFunction but the vertexFunction of the renderPipelineState is a postTessellationVertexFunction.
validateIndirectBuffer
(%sOffset + %s)(%lu) must be <= [%s length](%lu).
%sOffset(%lu) must be a multiple of 4 bytes.
validateCommonTessellationErrors
missing tessellationFactorBuffer binding.
numberOfPatchControlPoints(%lu) must match the number of control points(%ld) set in the vertexFunction of the renderPipelineState.
numberOfPatchControlPoints(%lu) must be <= 32.
for drawIndexedPatches numberOfPatchControlPoints(%lu) must not be 0.
for MTLTessellationFactorStepFunctionConstant and MTLTessellationFactorStepFunctionPerPatch tessellationFactorBufferInstanceStride(%lu) must be zero.
for MTLTessellationFactorStepFunctionPerInstance and MTLTessellationFactorStepFunctionPerPatchAndPerInstance tessellationFactorBufferInstanceStride(%lu) must be non-zero.
tessellationFactorBufferInstanceStride(%lu) must be a multiple of %lu bytes.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeNone not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt16 not valid for %s.
tessellationControlPointIndexType of MTLTessellationControlPointIndexTypeUInt32 not valid for %s.
tessellationFactorBuffer
validateTessellationFactorBuffer
%sOffset(%lu) + tessellationFactorBytesUsed(%lu) must be <= [%s length](%lu).
_MTLTessellationFactorBytesUsed
(patchStart + patchCount)(%lu) * %lu must be <= tessellationFactorBufferInstanceStride(%lu).
MTL_XML_DUMP_EVENTS
MTLCommandBufferKernelStartTime
MTLCommandBufferKernelEndTime
MTLCommandBufferGPUStartTime
MTLCommandBufferGPUEndTime
-[MTLDebugResource doesAliasResource:]
Input resource was not allocated on the Heap.
-[MTLDebugResource doesAliasAllResources:count:]
Resources count cannot be zero.
Input resource %0lx was not allocated on a heap.
-[MTLDebugResource doesAliasAnyResources:count:]
v24@?0@"MTLStructType"8Q16
-[MTLDebugIndirectRenderCommand setVertexBuffer:offset:atIndex:]
-[MTLDebugIndirectRenderCommand setFragmentBuffer:offset:atIndex:]
-[MTLDebugIndirectRenderCommand drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:]
drawPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:]
drawIndexedPrimitives is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand setRenderPipelineState:]
-[MTLDebugIndirectRenderCommand drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawPatches is not enabled on this indirect command buffer
-[MTLDebugIndirectRenderCommand drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:]
drawIndexedPatches is not enabled on this indirect command buffer
validateMTLSamplerDescriptor
MTLSamplerDescriptor:non-normalized coords require MTLSamplerMipFilterNotMipmapped.
MTLSamplerDescriptor:non-normalized coords require MTLSamplerAddressModeClampToEdge, MTLSamplerAddressModeClampToZero or MTLSamplerAddressModeClampToBorderColor.
MTLSamplerDescriptor:non-normalized coords require maxAnisotropy == 1.
MTLSamplerDescriptor:non-normalized coords require minFilter==magFilter of MTLSamplerMinMagFilterNearest or MTLSamplerMinMagFilterLinear, to be portable to all Metal devices.
MTLSamplerDescriptor's min filter value (%lu) is invalid.
MTLSamplerDescriptor's mag filter value (%lu) is invalid.
MTLSamplerDescriptor's mip filter value (%lu) is invalid.
MTLSamplerDescriptor's max anisotropy value (%lu) is invalid. Clamping to [%i, %i] range.
MTLSamplerDescriptor's S texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's T texture coordinate address mode value (%lu) is invalid.
MTLSamplerDescriptor's R texture coordinate address mode value (%lu) is invalid.
Exceeded the limit on number of unique samplers usable in argument buffers (which is %u)
-[MTLDebugHeap validateHeapResourceOptions:isTexture:isIOSurface:]
The requested hazard tracking mode does not match the heap's mode
The requested CPU cache mode does not match the heap's mode
The requested storage mode is not compatible with the heap's mode
Shared textures created via heaps are not supported on this device
MTLResourceOptions options have unknown bits 0x%lx.
-[MTLDebugHeap maxAvailableSizeWithAlignment:]
aligment needs to be power of two, or zero.
-[MTLDebugHeap newBufferWithLength:options:]
Requested length %lu must not exceed heap size %lu.
newBufferWithLength:options: cannot be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options:offset: instead.
-[MTLDebugHeap newTextureWithDescriptor:]
newTextureWithDescriptor: cannot be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor:offset: instead.
-[MTLDebugHeap setPurgeableState:]
-[MTLDebugHeap validateOffset:withRequirements:]
Cannot place resource at offset %lu extending beyond the heap size %lu (resource size %lu)
Cannot place resource at offset %lu which is not aligned to %lu bytes
-[MTLDebugHeap newBufferWithLength:options:offset:]
newBufferWithLength:options:offset: can only be used when heap type is MTLHeapTypePlacement, use newBufferWithLength:options: instead.
-[MTLDebugHeap newTextureWithDescriptor:offset:]
newTextureWithDescriptor:offset: can only be used when heap type is MTLHeapTypePlacement, use newTextureWithDescriptor: instead.
-[MTLDebugTexture dealloc]
usageRequested 0x%lx != usageRequired 0x%lx
-[MTLDebugTexture makeAliasable]
Memoryless textures cannot be made aliasable.
Texture Views created from Textures, that are backed by the Heap, cannot be made aliasable.
-[MTLDebugTexture setPurgeableState:]
_validateReplaceRegion
(size.width(%lu) * size.height(%lu) * size.depth(%lu))(%lu) must not be 0.
CPU access for textures with MTLResourceStorageModePrivate storage mode is disallowed.
CPU access for textures with MTLStorageModeMemoryless is disallowed.
texture must not be a framebufferOnly texture.
mipmapLevel(%lu) must be < [texture mipmapLevelCount](%lu).
(origin.x + adjustedSize.width)(%lu) must be <= paddedWidth(%lu).
(origin.y + adjustedSize.height)(%lu) must be <= paddedHeight(%lu).
(origin.z + size.depth)(%lu) must be <= paddedDepth(%lu).
(origin.x + size.width)(%lu) must be <= width(%lu).
(origin.y + size.height)(%lu) must be <= height(%lu).
(origin.z + size.depth)(%lu) must be <= depth(%lu).
origin.x(%lu) must be a multiple of %s blockWidth(%lu).
origin.y(%lu) must be a multiple of %s blockHeight(%lu).
origin.z(%lu) must be a multiple of %s blockDepth(%lu).
origin.x must be 0 (full image) for %s.
origin.y must be 0 (full image) for %s.
origin.z must be 0 (full image) for %s.
size.width(%lu) must equal width(%lu) (full image) for %s.
size.height(%lu) must equal height(%lu) (full image) for %s.
size.depth(%lu) must equal depth(%lu) (full image) for %s.
rowBytes must be 0 for %s.
imageBytes must be 0 for %s.
rowBytes(%lu) must be >= (%lu).
imageBytes(%lu) must be >= (%lu).
rowBytes(%lu) must be a multiple of %s %s bytes(%lu).
block
pixel
imageBytes(%lu) must be a multiple of %s %s bytes(%lu).
CPU access for this texture with pixel format %s is disallowed.
Replacing region on slice(%u) on mipmapLevel(%u) that is currently attached as a writeable render target.
_validateGetBytes
_validateTextureView
cannot create View from Memoryless texture.
texture usage (0x%02lx) doesn't specify MTLTextureUsagePixelFormatView (0x%02lx)
invalid pixelFormat.
texture view creation not allowed from frameBufferOnly textures.
textureType %@ cannot be used for buffer-backed textures.
C12StringBuffer
12AppendBuffer
12BinaryBuffer
BufferHeap::MemoryAllocated (MB) - %.2f
BufferHeap::MemoryUsed (MB) - %.2f/%.2f
DescriptorHeapSize (MB) - %.2f
DescriptorHeapNewHandle - %llu
ConstantBufferCache::TotalMemory - %llu
Device Alloc - %s, %p
Device Dealloc - %s, %p
Fatal failure when instrumenting %s "%s":
Function is not instrumented and faults will not be detected.
Partial failure when instrumenting %s "%s":%s%s
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
MTLDebugIndirectComputeCommand
MTLGPUDebugRenderCommandEncoder
MTLGPUDebugCommandEncoder
NSObject
MTLToolsIndirectCommandBuffer
MTLIndirectCommandBufferSPI
MTLIndirectCommandBuffer
MTLResource
MTLToolsBlitCommandEncoder
MTLBlitCommandEncoder
MTLCommandEncoder
MTLToolsFence
MTLFence
MTLCountersRenderCommandEncoder
MTLToolsCounterSampleBuffer
MTLCounterSampleBuffer
MTLGPUDebugLibrary
MTLToolsBuffer
MTLBuffer
MTLToolsCommandBuffer
MTLCommandBufferSPI
MTLCommandBuffer
MTLToolsRetainingContainer
MTLParallelRenderCommandEncoder
MTLToolsCommandEncoder
MTLToolsPerfCounterMailbox
MTLToolsCommandQueue
MTLCommandQueueSPI
MTLCommandQueue
MTLToolsDynamicLibrary
MTLDynamicLibrarySPI
MTLDynamicLibrary
MTLToolsBinaryArchive
MTLBinaryArchiveSPI
MTLBinaryArchive
MTLToolsHeap
MTLHeapSPI
MTLHeap
MTLToolsComputeCommandEncoder
MTLComputeCommandEncoderSPI
MTLComputeCommandEncoder
MTLToolsComputePipelineState
MTLComputePipelineStateSPI
MTLComputePipelineState
MTLGPUDebugBuffer
MTLToolsDepthStencilState
MTLDepthStencilStateSPI
MTLDepthStencilState
MTLToolsIndirectComputeCommand
MTLIndirectComputeCommandSPI
MTLIndirectComputeCommand
MTLGPUDebugDevice
MTLToolsDevice
MTLDeviceSPI
MTLDevice
MTLToolsEvent
MTLEvent
MTLToolsSharedEvent
MTLSharedEvent
MTLToolsFunction
MTLFunctionSPI
MTLFunction
MTLToolsLibrary
MTLLibrarySPI
MTLLibrary
MTLDebugPipelineLibrary
MTLCountersComputeCommandEncoder
MTLGPUDebugRenderPipelineState
MTLToolsObject
MTLToolsParallelRenderCommandEncoder
MTLToolsRenderCommandEncoder
MTLRenderCommandEncoderSPI
MTLRenderCommandEncoder
MTLGPUDebugIndirectComputeCommand
MTLCountersTraceCommandEncoder
MTLCountersTraceBlitCommandEncoder
MTLCountersTraceComputeCommandEncoder
MTLCountersTraceRenderCommandEncoder
MTLCountersTraceResourceStateCommandEncoder
MTLCountersTraceCommandBuffer
MTLToolsRenderPipelineState
MTLRenderPipelineStateSPI
MTLRenderPipelineState
MTLToolsResource
MTLResourceSPI
MTLToolsResourceGroupSPI
MTLResourceGroupSPI
MTLGPUDebugIndirectRenderCommand
MTLToolsSamplerState
MTLSamplerState
MTLSamplerStateSPI
MTLToolsTexture
MTLTextureImplementation
MTLTextureSPI
MTLTexture
MTLToolsTextureLayout
MTLTextureLayout
MTLCountersParallelRenderCommandEncoder
MTLTextureErrorLog
MTLFunctionLog
MTLBufferErrorLog
MTLGPUDebugCommandBuffer
MTLGPUDebugBufferEncoder
MTLDebugBlitCommandEncoder
MTLDebugBufferMarker
MTLDebugBuffer
MTLDebugResourcePurgeable
MTLGPUDebugCommandQueue
MTLDebugCommandBuffer
MTLGPUDebugBinaryArchive
MTLDebugDynamicLibrary
MTLToolsIndirectRenderCommand
MTLIndirectRenderCommandSPI
MTLIndirectRenderCommand
MTLDebugCounterSampleBuffer
MTLDebugBinaryArchive
MTLCountersDevice
MTLGPUDebugArgumentEncoder
MTLGPUDebugComputePipelineState
MTLDebugCommandQueue
MTLDebugComputeCommandEncoder
MTLDebugComputePipelineState
MTLDebugIndirectCommandBuffer
MTLCountersCommandQueue
MTLToolsPipelineLibrary
MTLPipelineLibrarySPI
MTLPipelineLibrary
MTLToolsArgumentEncoder
MTLArgumentEncoderSPI
MTLArgumentEncoder
MTLGPUDebugHeap
MTLDebugArgumentEncoder
MTLDebugDevice
MTLDebugDepthStencilState
MTLGPUDebugIndirectCommandBuffer
MTLDebugEvent
MTLDebugSharedEvent
MTLGPUDebugParallelRenderCommandEncoder
MTLDebugFunction
MTLDebugLibrary
MTLDebugParallelRenderCommandEncoder
MTLDebugRenderTargetAttachmentInfo
MTLDebugRenderCommandEncoder
MTLCountersCommandBuffer
MTLGPUDebugBlitCommandEncoder
MTLDebugResource
MTLGPUDebugComputeCommandEncoder
MTLGPUDebugFunction
MTLDebugIndirectRenderCommand
MTLDebugRenderPipelineState
MTLDebugSamplerState
MTLDebugHeap
MTLDebugTexture
MTLDebugTextureLayout
MTLCountersBlitCommandEncoder
initWithBaseObject:parent:
dealloc
inheritPipelineState
baseObject
supportIndirectCommandBuffers
setComputePipelineState:
maxKernelBufferBindCount
inheritBuffers
setKernelBuffer:offset:atIndex:
commandTypes
concurrentDispatchThreadgroups:threadsPerThreadgroup:
concurrentDispatchThreads:threadsPerThreadgroup:
initWithBaseObject:descriptor:indexCount:indirectCommandBuffer:
index
indirectCommandBuffer
_desc
_index
_iCB
TQ,R
T@"<MTLIndirectCommandBuffer>",R
initWithRenderCommandEncoder:parent:descriptor:
_initBufferArgumentData:
setVertexBytes:length:atIndex:
setFragmentBytes:length:atIndex:
setTileBytes:length:atIndex:
tileDebugInstrumentationData
activeThreadgroupMask
fragmentDebugInstrumentationData
setThreadgroupMemoryLength:offset:atIndex:
device
setVertexBuffer:offset:atIndex:
setFragmentBuffer:offset:atIndex:
bufferAccessMask
vertexDebugInstrumentationData
setTileBuffer:offset:atIndex:
commandBuffer
handleForOffset:
useResource:usage:stages:
addRetainedObject:
globalConstantsBuffer
vertexConstantOffset
fragmentConstantOffset
tileConstantOffset
offset
temporaryBufferWithBytes:length:
flushBindings
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:indirectBuffer:indirectBufferOffset:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexType:indexBuffer:indexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
drawPatches:patchIndexBuffer:patchIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:
setTessellationControlPointIndexBuffer:offset:
drawIndexedPatches:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:indirectBuffer:indirectBufferOffset:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:
dispatchThreadsPerTile:
internalICBBuffer
internalDrawIDBuffer
useResource:usage:
setDepthStencilState:
fragmentFunction
tileFunction
setRenderPipelineStateBuffers:
setRenderPipelineState:
endingEncoder:type:
endEncoding
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
T#,R
T@"NSString",R,C
encoderID
TI,R
initWithRenderCommandEncoder:commandBuffer:descriptor:encoderID:
initWithRenderCommandEncoder:parallelEncoder:descriptor:encoderID:
setVertexReportBuffer:offset:
setFragmentReportBuffer:offset:
setTileReportBuffer:offset:
setVertexBufferOffset:atIndex:
setVertexBuffers:offsets:withRange:
setFragmentBufferOffset:atIndex:
setFragmentBuffers:offsets:withRange:
setTileBufferOffset:atIndex:
setTileBuffers:offsets:withRange:
executeCommandsInBuffer:withRange:
executeCommandsInBuffer:indirectBuffer:indirectBufferOffset:
useResources:count:usage:
useResources:count:usage:stages:
.cxx_construct
useResourceIteration
_tileStageActive
_tileStageUsed
_fragmentStageActive
_vertexHandles
_fragmentHandles
_tileHandles
_vertexBuffers
_fragmentBuffers
_tileBuffers
_threadgroup
_options
_drawID
_encoderType
_currentPipeline
_currentDepthStencil
_vertexReportBuffer
_fragmentReportBuffer
_tileReportBuffer
T@"MTLGPUDebugCommandBuffer",R,D
length
encodeBuffers:offsets:withRange:resultOffset:
indirectComputeCommandAtIndex:
indirectRenderCommandAtIndex:
size
storageMode
getHeader:headerSize:
resetWithRange:
uniqueIdentifier
gpuAddress
resourceIndex
setPurgeableState:
makeAliasable
isAliasable
label
setLabel:
cpuCacheMode
hazardTrackingMode
resourceOptions
heap
heapOffset
allocatedSize
T@"NSString",C
T@"<MTLDevice>",R
T@"<MTLHeap>",R
TQ,R,N
TQ,R,D,N
updateFence:
waitForFence:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
generateMipmapsForTexture:
fillBuffer:range:value:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
copyFromTexture:toTexture:
optimizeContentsForGPUAccess:
optimizeContentsForGPUAccess:slice:level:
optimizeContentsForCPUAccess:
optimizeContentsForCPUAccess:slice:level:
resetCommandsInBuffer:withRange:
copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:
optimizeIndirectCommandBuffer:withRange:
resolveCounters:inRange:destinationBuffer:destinationOffset:
sampleCountersInBuffer:atSampleIndex:withBarrier:
insertDebugSignpost:
pushDebugGroup:
popDebugGroup
synchronizeResource:
synchronizeTexture:slice:level:
initWithBlitCommandEncoder:parent:descriptor:
APITimingEnabled
traceBuffer
renderCommandEncoder
setVertexTexture:atIndex:
setVertexTextures:withRange:
setVertexSamplerState:atIndex:
setVertexSamplerStates:withRange:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentTexture:atIndex:
setFragmentTextures:withRange:
setFragmentSamplerState:atIndex:
setFragmentSamplerStates:withRange:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setFragmentTexture:atTextureIndex:samplerState:atSamplerIndex:
setTileTexture:atIndex:
setTileTextures:withRange:
setTileSamplerState:atIndex:
setTileSamplerStates:withRange:
setTileSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:
useHeap:
useHeaps:count:
setViewport:
setViewports:count:
setFrontFacingWinding:
setCullMode:
setDepthClipMode:
setLineWidth:
setDepthBias:slopeScale:clamp:
setScissorRect:
setScissorRects:count:
setTriangleFillMode:
setStencilReferenceValue:
setStencilFrontReferenceValue:backReferenceValue:
setColorStoreAction:atIndex:
setDepthStoreAction:
setStencilStoreAction:
setVisibilityResultMode:offset:
setBlendColorRed:green:blue:alpha:
setColorResolveTexture:slice:depthPlane:level:atIndex:
setColorResolveTexture:slice:depthPlane:level:yInvert:atIndex:
setDepthResolveTexture:slice:depthPlane:level:
setDepthResolveTexture:slice:depthPlane:level:yInvert:
setStencilResolveTexture:slice:depthPlane:level:
setStencilResolveTexture:slice:depthPlane:level:yInvert:
updateFence:afterStages:
waitForFence:beforeStages:
setTessellationFactorBuffer:offset:instanceStride:
setTessellationFactorScale:
memoryBarrierWithScope:afterStages:beforeStages:
memoryBarrierWithResources:count:afterStages:beforeStages:
_APITimingEnabled
_traceEncoder
sampleCount
resolveCounterRange:
T@"NSString",R
newFunctionWithName:
newFunctionWithFunction:library:
newFunctionWithName:constantValues:error:
newFunctionWithName:constantValues:completionHandler:
initWithLibrary:device:
stringByPaddingToLength:withString:startingAtIndex:
formattedDescription:
arrayWithObjects:count:
componentsJoinedByString:
stringWithFormat:
contents
didModifyRange:
newLinearTextureWithDescriptor:offset:bytesPerRow:bytesPerImage:
addDebugMarker:range:
removeAllDebugMarkers
newTextureWithDescriptor:offset:bytesPerRow:
initWithBaseObject:parent:buffer:
iosurface
retainedReferences
originalObject
snapshotPerfSampleHandlerAndStatEnabled:forCommandBuffer:
invokeScheduledHandlers
invokeCompletedHandlers
preScheduledHandlers
postScheduledHandlers
preCompletionHandlers
postCompletionHandlers
addObject:
removeAllObjects
clearRetainedObjects
status
extractDataAndNumSamples:forRequester:isLast:
addScheduledHandler:
addCompletedHandler:
preCommit
commit
commitAndHold
commitAndWaitUntilSubmitted
debugCommandEncoder
logs
GPUStartTime
GPUEndTime
globalTraceObjectID
enqueue
presentDrawable:
presentDrawable:atTime:
waitUntilScheduled
waitUntilCompleted
error
blitCommandEncoder
computeCommandEncoder
kernelStartTime
kernelEndTime
debugBufferContentsWithLength:
copy
visibilityResultBuffer
setVisibilityResultBuffer:
_descriptorPrivate
_descriptorAtIndex:
texture
colorAttachments
objectAtIndexedSubscript:
setTexture:
resolveTexture
setResolveTexture:
depthAttachment
stencilAttachment
sampleBuffer
sampleBufferAttachments
setSampleBuffer:
unwrapMTLRenderPassDescriptor:
renderCommandEncoderWithDescriptor:
parallelRenderCommandEncoderWithDescriptor:
setUseRetainedObjectsLock:
sampledRenderCommandEncoderWithDescriptor:programInfoBuffer:capacity:
sampledComputeCommandEncoderWithProgramInfoBuffer:capacity:
computeCommandEncoderWithDispatchType:
unwrapMTLComputePassDescriptor:
computeCommandEncoderWithDescriptor:
sampledComputeCommandEncoderWithDescriptor:programInfoBuffer:capacity:
unwrapMTLBlitPassDescriptor:
blitCommandEncoderWithDescriptor:
encodeSignalEvent:value:
encodeWaitForEvent:value:
encodeWaitForEvent:value:timeout:
addPurgedResource:
addPurgedHeap:
sampledComputeCommandEncoderWithDispatchType:programInfoBuffer:capacity:
isProfilingEnabled
setProfilingEnabled:
profilingResults
userDictionary
getListIndex
addSynchronizationNotification:
executeSynchronizationNotifications:
executeSynchronizationNotifications:scope:resources:count:
setResourceGroups:count:
dropResourceGroups:count:
encodeCacheHintTag:resourceGroups:count:
encodeCacheHintFinalize:resourceGroups:count:
setProtectionOptions:
protectionOptions
errorOptions
commandQueue
T@"<MTLCommandQueue>",R
TB,R
Td,R
T@"<MTLLogContainer>",R
T@"NSError",R
listIndex
TQ,R,N,GgetListIndex
profilingEnabled
TB,GisProfilingEnabled
T@"NSDictionary",R
T@"NSMutableDictionary",R,N
retainedObjects
T@"NSMutableSet",R,N
willEncodeSignalEvent:value:writeableResources:
useRetainedObjectsLock
.cxx_destruct
_flags
_retainedObjectsLock
_handlerLock
_scheduledHandlers
_completedHandlers
_didInvokeHandlers
_perfSampleHandlerBlock
_StatEnabled
_useRetainedObjectsLock
_retainedObjects
TB,V_useRetainedObjectsLock
T@"NSMutableSet",R,N,V_retainedObjects
filterCounterRangeWithFirstBatch:lastBatch:filterIndex:
_commandBuffer
T@"MTLToolsCommandBuffer",R,N,V_commandBuffer
insertData:andNumSamples:forRequester:
_requester
_data
_iterator
commandBufferWithUnretainedReferences
commandBufferWithDescriptor:
insertDebugCaptureBoundary
getGPUPriority
setGPUPriority:
setGPUPriority:offset:
getBackgroundGPUPriority
setBackgroundGPUPriority:
setBackgroundGPUPriority:offset:
maxCommandBufferCount
backgroundTrackingPID
setBackgroundTrackingPID:
finish
skipRender
setSkipRender:
executionEnabled
setExecutionEnabled:
setCompletionQueue:
setSubmissionQueue:
isOpenGLQueue
requestCounters:
addPerfSampleHandler:
isStatEnabled
requestCounters:withIndex:
subdivideCounterList:
qosLevel
commitQueue
commitSynchronously
completionQueue
disableCrossQueueHazardTracking
availableCounters
getRequestedCounters
setStatEnabled:
getStatOptions
setStatOptions:
getStatLocations
setStatLocations:
counterInfo
availableCountersAndDict
T@"NSObject<OS_dispatch_queue>",R
StatEnabled
TB,N,GisStatEnabled
StatOptions
TQ,N,GgetStatOptions
StatLocations
TQ,N,GgetStatLocations
_perfSampleMailbox
_perfHandlerLock
binaryData
exportedFunctions
exportedVariables
importedSymbols
importedLibraries
installName
libraryPath
libraryUUID
serializeToURL:error:
serializeToURL:options:error:
T@"NSObject<OS_dispatch_data>",R
T@"NSArray",R
Tr^{?=[32C]},R
options
unwrapMTLComputePipelineDescriptor:
addComputePipelineFunctionsWithDescriptor:error:
addComputePipelineFunctionsWithDescriptor:options:error:
unwrapMTLRenderPipelineDescriptor:
addRenderPipelineFunctionsWithDescriptor:error:
addRenderPipelineFunctionsWithDescriptor:options:error:
unwrapMTLTileRenderPipelineDescriptor:
addTileRenderPipelineFunctionsWithDescriptor:error:
addTileRenderPipelineFunctionsWithDescriptor:options:error:
keys
addBinaryEntry:forKey:
getBinaryDataForKey:
unfilteredResourceOptions
usedSize
maxAvailableSizeWithAlignment:
currentAllocatedSize
type
initWithBaseObject:parent:heap:
newBufferWithLength:options:
_newToolsBuffer:
newBufferWithLength:options:offset:
newTextureWithDescriptor:
_newToolsTexture:
newTextureWithDescriptor:offset:
Tq,R
setBytes:length:atIndex:
setBufferOffset:atIndex:
setBuffer:offset:atIndex:
setBuffers:offsets:withRange:
setTexture:atIndex:
setTextures:withRange:
setSamplerState:atIndex:
setSamplerStates:withRange:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setSamplerStates:lodMinClamps:lodMaxClamps:withRange:
setThreadgroupMemoryLength:atIndex:
dispatchThreadgroups:threadsPerThreadgroup:
setStageInRegion:
setStageInRegionWithIndirectBuffer:indirectBufferOffset:
setImageblockWidth:height:
dispatchThreadgroupsWithIndirectBuffer:indirectBufferOffset:threadsPerThreadgroup:
dispatchThreads:threadsPerThreadgroup:
dispatchThreadsWithIndirectBuffer:indirectBufferOffset:
newKernelDebugInfo
dispatchType
memoryBarrierWithScope:
memoryBarrierWithResources:count:
enableNullBufferBinds:
initWithComputeCommandEncoder:parent:descriptor:
setImageBlockWidth:height:
functionPointerHandleWithFunction:
count
arrayWithCapacity:
countByEnumeratingWithState:objects:count:
functionPointerHandlesWithFunctions:range:
textureWriteRoundingMode
maxTotalThreadsPerThreadgroup
threadExecutionWidth
staticThreadgroupMemoryLength
imageblockMemoryLengthForDimensions:
debugInstrumentationData
T@"MTLDebugInstrumentationData",R,&,N
_function
initWithBuffer:device:offset:length:track:
initWithBuffer:heap:device:offset:length:track:
initWithBuffer:device:
initWithBuffer:device:offset:length:
initWithBuffer:heap:device:
bufferIndex
_offset
_length
_descriptorHeap
encodedLength
setArgumentBuffer:offset:
constantDataAtIndex:
readsDepth
writesDepth
readsStencil
writesStencil
getThreadgroupMemoryLengthAtIndex:
getStageInRegion
hasBarrier
getImageBlockSize
setBarrier
clearBarrier
dispatchThreadgroupsArguments
dispatchThreadsArguments
reset
getPipelineStateUniqueIdentifier
getKernelBufferAtIndex:
getCommandType
getOptimizedStatus
newInternalBufferWithLength:options:
setIndex:
setAccess:
setArrayLength:
setDataType:
newArgumentEncoderWithArguments:
enumerateByteRangesUsingBlock:
name
UTF8String
supportsFamily:
initWithBytesNoCopy:length:freeWhenDone:
initWithDictionary:
setObject:forKeyedSubscript:
setForceSoftwareVertexFetch:
pluginData
_modifyPluginData:
initWithLength:
bytes
isAlphaToCoverageEnabled
setPluginData:
_modifyCompileOptions:
_modifyRenderPipelineDescriptor:
_modifyComputePipelineDescriptor:
_modifyTileRenderPipelineDescriptor:
vertexFunction
computeFunction
newCommandQueueWithDescriptor:
initWithCommandQueue:device:
commandQueueDescriptor
setMaxCommandBufferCount:
newRenderPipelineStateWithDescriptor:options:reflection:error:
unwrapAndModifyRenderPipelineDescriptor:options:
initWithRenderPipelineState:descriptor:unwrappedDescriptor:reflection:device:pipelineOptions:
userReflection
releaseReflection
onRenderPipelineCreated:
newRenderPipelineStateWithDescriptor:options:completionHandler:
unwrapAndModifyTileRenderPipelineDescriptor:options:
newRenderPipelineStateWithTileDescriptor:options:reflection:error:
initWithRenderPipelineState:tileDescriptor:reflection:device:
newRenderPipelineStateWithTileDescriptor:options:completionHandler:
newComputePipelineStateWithDescriptor:options:reflection:error:
unwrapAndModifyComputePipelineDescriptor:options:
initWithComputePipelineState:descriptor:unwrappedDescriptor:reflection:device:
onComputePipelineCreated:
newComputePipelineStateWithDescriptor:options:completionHandler:
setComputeFunction:
newComputePipelineStateWithDescriptor:error:
newComputePipelineStateWithDescriptor:completionHandler:
setMaxVertexBufferBindCount:
setMaxFragmentBufferBindCount:
setInheritBuffers:
newIndirectCommandBufferWithDescriptor:maxCommandCount:options:
initWithIndirectCommandBuffer:descriptor:maxCommandCount:resourceOptions:device:
newLibraryWithCIFiltersForComputePipeline:imageFilterFunctionInfo:error:
newLibraryWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
newLibraryWithCIFilters:imageFilterFunctionInfo:error:
newDefaultLibrary
newDefaultLibraryWithBundle:error:
initWithArray:
setObject:atIndexedSubscript:
newLibraryWithDAG:functions:error:
newLibraryWithFile:error:
newLibraryWithData:error:
newLibraryWithURL:error:
newLibraryWithSource:options:error:
newLibraryWithSource:options:completionHandler:
newBinaryArchiveWithDescriptor:error:
initWithBinaryArchive:device:
newBinaryLibraryWithOptions:url:error:
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
newHeapWithDescriptor:
initWithHeap:descriptor:device:
newArgumentEncoderWithArguments:structType:
mutableCopy
constantBlockAlignment
dataType
setConstantBlockAlignment:
insertObject:atIndex:
initWithArgumentEncoder:layout:device:
supportsGFXIndirectCommandBuffers
supportsBinaryArchives
supportsFunctionPointers
newStageBufferArgumentEncoder
newStageArgumentBuffer
newCommandQueue
newCommandQueueWithMaxCommandBufferCount:
newRenderPipelineStateWithDescriptor:error:
newRenderPipelineStateWithDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:completionHandler:
newRenderPipelineStateWithTileDescriptor:error:
newComputePipelineStateWithFunction:error:
newComputePipelineStateWithFunction:completionHandler:
newComputePipelineStateWithFunction:options:completionHandler:
newComputePipelineStateWithFunction:options:reflection:error:
ICB_Inherit_PSO_VertexPipelineState
ICB_Inherit_None_VertexPipelineState
ICB_Inherit_Buffers_VertexPipelineState
ICB_DepthStencilState
newBufferWithIOSurface:
newBufferWithLength:options:gpuAddress:
newBufferWithBytes:length:options:gpuAddress:
newBufferWithBytesNoCopy:length:options:gpuAddress:deallocator:
newArgumentEncoderWithLayout:
supportsArgumentBuffersTier2
supportsCMPIndirectCommandBuffers
supportsRaytracing
supportsBinaryLibraries
supportsBinaryFunctionPointers
supportsDynamicLibraries
bufferHeap
boundsCheckOptions
deviceOptions
globalBufferHeap
constantBufferCache
globalICBBufferResidentList
_boundsCheckOptionsData
_argumentDescriptors
_deviceInitFlag
_icbPipelineInit
_icbInheritVertexPipelineState
_icbInheritNoneVertexPipelineState
_icbInheritBuffersVertexPipelineState
_icbDepthStencilState
T@"<MTLRenderPipelineState>",R,N
T@"<MTLDepthStencilState>",R,N
bundleWithIdentifier:
pathForResource:ofType:
setRasterizationEnabled:
setSupportIndirectCommandBuffers:
setVertexFunction:
setDepthWriteEnabled:
setDepthCompareFunction:
frontFaceStencil
setReadMask:
setWriteMask:
backFaceStencil
newDepthStencilStateWithDescriptor:
functionType
hasArgumentLimitsInstrumentationFailures
hasArgumentBufferInstrumentationFailures
hasGlobalConstantsInstrumentationFailures
additionalCompilerArguments
setAdditionalCompilerArguments:
_setDeviceWrapper:
newFunctionWithGLIR:functionType:
newFunctionWithGLIR:inputsDescription:functionType:
shaderDebugInfoCaching
setShaderDebugInfoCaching:
mapShaderSampleBufferWithBuffer:capacity:size:
unmapShaderSampleBuffer
reportLeaks
registryID
vendorName
familyName
productName
targetDeviceInfo
targetDeviceArchitecture
loadDynamicLibrariesForComputeDescriptor:error:
validateDynamicLibrary:state:error:
validateDynamicLibraryURL:error:
areGPUAssertionsEnabled
setGPUAssertionsEnabled:
reserveGPUAddressRange:
maxThreadsPerThreadgroup
isLowPower
isHeadless
isRemovable
hasUnifiedMemory
recommendedMaxWorkingSetSize
sharedMemorySize
dedicatedMemorySize
isDepth24Stencil8PixelFormatSupported
unloadShaderCaches
libraryCacheStats
pipelineCacheStats
copyShaderCacheToPath:
getShaderCacheKeys
compilerPropagatesThreadPriority:
newIndirectCommandBufferWithDescriptor:maxCount:options:
newIndirectRenderCommandEncoderWithBuffer:
newIndirectComputeCommandEncoderWithBuffer:
newTextureWithBytesNoCopy:length:descriptor:deallocator:
newSamplerStateWithDescriptor:
unwrapMTLCompileOptions:
startCollectingPipelineDescriptors
endCollectingPipelineDescriptors
newPipelineLibraryWithFilePath:error:
serializeRenderPipelineDescriptor:
newRenderPipelineDescriptorWithSerializedData:deserializationContext:
newComputePipelineDescriptorWithSerializedData:deserializationContext:
serializeStructType:
heapTextureSizeAndAlignWithDescriptor:
heapBufferSizeAndAlignWithLength:options:
newFence
indirectArgumentBufferCapabilities
newIndirectArgumentBufferLayoutWithStructType:
newIndirectArgumentEncoderWithLayout:
maxThreadgroupMemoryLength
maxArgumentBufferSamplerCount
setFragmentFunction:
pipelineLibrary
setPipelineLibrary:
binaryArchives
setBinaryArchives:
linkedFunctions
setLinkedFunctions:
functions
setFunctions:
privateFunctions
setPrivateFunctions:
groups
dictionary
objectForKeyedSubscript:
setValue:forKey:
setGroups:
functionPointers
array
setFunctionPointers:
arrayByAddingObject:
functionPointerGroups
setFunctionPointerGroups:
insertLibraries
setInsertLibraries:
setTileFunction:
libraries
setLibraries:
deviceSupportsFeatureSet:
deviceOrFeatureProfileSupportsFeatureSet:
supportsFeatureSet:
supportsTextureSampleCount:
supportsSampleCount:
minLinearTextureAlignmentForPixelFormat:
minimumLinearTextureAlignmentForPixelFormat:
minimumTextureBufferAlignmentForPixelFormat:
areProgrammableSamplePositionsSupported
getDefaultSamplePositions:count:
_deviceWrapper
resourcePatchingTypeForResourceType:
reserveResourceIndicesForResourceType:indices:indexCount:
halfFPConfig
singleFPConfig
doubleFPConfig
featureProfile
limits
supportPriorityBand
maxFramebufferStorageBits
linearTextureArrayAlignmentBytes
linearTextureArrayAlignmentSlice
maxTileBuffers
maxTileTextures
maxTileSamplers
maxTileInlineDataSize
minTilePixels
maxColorAttachments
maxVertexAttributes
maxVertexBuffers
maxVertexTextures
maxVertexSamplers
maxVertexInlineDataSize
maxInterpolants
maxFragmentBuffers
maxFragmentTextures
maxFragmentSamplers
maxFragmentInlineDataSize
maxComputeBuffers
maxComputeTextures
maxComputeSamplers
maxComputeInlineDataSize
maxComputeLocalMemorySizes
maxTotalComputeThreadsPerThreadgroup
maxComputeThreadgroupMemory
maxLineWidth
maxPointSize
maxVisibilityQueryOffset
minConstantBufferAlignmentBytes
minBufferNoCopyAlignmentBytes
maxTextureWidth1D
maxTextureWidth2D
maxTextureHeight2D
maxTextureWidth3D
maxTextureHeight3D
maxTextureDepth3D
maxTextureDimensionCube
maxTextureLayers
linearTextureAlignmentBytes
iosurfaceTextureAlignmentBytes
iosurfaceReadOnlyTextureAlignmentBytes
deviceLinearTextureAlignmentBytes
deviceLinearReadOnlyTextureAlignmentBytes
maxFunctionConstantIndices
maxComputeThreadgroupMemoryAlignmentBytes
maxInterpolatedComponents
maxTessellationFactor
maxIndirectBuffers
maxIndirectTextures
maxIndirectSamplers
maxIndirectSamplersPerDevice
maxFenceInstances
maxViewportCount
maxCustomSamplePositions
maxTextureBufferWidth
maxComputeAttributes
maxConstantBufferArguments
maxBufferLength
readWriteTextureSupport
argumentBuffersSupport
areRasterOrderGroupsSupported
isFloat32FilteringSupported
isMsaa32bSupported
isQuadDataSharingSupported
newResourceGroupFromResources:count:
metalAssertionsEnabled
setMetalAssertionsEnabled:
newTextureWithDescriptor:iosurface:plane:
newEvent
newSharedEvent
newSharedEventWithMachPort:
newSharedEventWithHandle:
newTextureLayoutWithDescriptor:isHeapOrBufferBacked:
setupMPSFunctionTable:
allowLibrariesFromOtherPlatforms
setResourcesPurgeableState:newState:oldState:count:
counterSets
sampleTimestamps:gpuTimestamp:
supportsCounterSampling:
newCounterSampleBufferWithDescriptor:error:
isPlacementHeapSupported
commandBufferErrorOptions
setCommandBufferErrorOptions:
getSupportedCommandBufferErrorOptions
supportsPrimitiveType:
deviceCreationFlags
newDynamicLibraryFromURL:error:
newDynamicLibraryWithURL:error:
newDynamicLibraryWithURL:options:error:
newDynamicLibrary:error:
newDynamicLibrary:computeDescriptor:error:
supportsTextureWriteRoundingMode:
defaultTextureWriteRoundingMode
supportsBufferlessClientStorageTexture
supportsComputeMemoryBarrier
supportsRenderMemoryBarrier
supportsReadWriteTextureArgumentsTier2
supportsProgrammableSamplePositions
supportsLargeFramebufferConfigs
supportsCustomBorderColor
supportsBCTextureCompression
supports3DBCTextures
supportsPrimitiveRestartOverride
supports32bpcMSAATextures
supports32BitMSAA
supports32BitFloatFiltering
supportsPlacementHeaps
supportsOpenCLTextureWriteSwizzles
supportsPullModelInterpolation
supportsInt64
supportsNonZeroTextureWriteLOD
supportsSharedTextureHandles
supportsBufferPrefetchStatistics
supportsLimitedYUVFormats
supportsNonPrivateDepthStencilTextures
supportsNonPrivateMSAATextures
supportsSharedStorageHeapResources
supportsSharedStorageTextures
supportsLinearTextureFromSharedBuffer
supportsPipelineLibraries
supportsFragmentOnlyEncoders
supportsBufferWithIOSurface
supportsProgrammableBlending
supportsRenderToLinearTextures
supportsMemorylessRenderTargets
supportsFastMathInfNaNPropagation
supportsInvariantVertexPosition
supportsShaderLODAverage
supportsRelaxedTextureViewRequirements
supportsSeparateDepthStencil
supportsGPUStatistics
supportsCompressedTextureViewSPI
supportsRenderTargetTextureRotation
supportsDynamicControlPointCount
supportsIABHashForTools
supportsASTCTextureCompression
supportsExtendedYUVFormats
supportsPublicXR10Formats
supportsSRGBwrites
supportsDepthClipMode
supportsPacked32TextureBufferWrites
supports3DASTCTextures
supportsExtendedXR10Formats
supportsFragmentBufferWrites
supportsCountingOcclusionQuery
supportsBaseVertexInstanceDrawing
supportsIndirectDrawAndDispatch
supportsTessellation
supportsReadWriteBufferArguments
supportsArrayOfTextures
supportsArrayOfSamplers
supportsCombinedMSAAStoreAndResolveAction
supportsMutableTier1ArgumentBuffers
supportsSamplerCompareFunction
supportsMSAADepthResolve
supportsMSAAStencilResolve
supportsMSAADepthResolveFilter
supportsIndirectStageInRegion
supportsIndirectTextures
supportsNorm16BCubicFiltering
supportsTextureOutOfBoundsReads
supportsTextureSwizzle
supportsAlphaYUVFormats
supportsMemoryOrderAtomics
supportsQuadGroup
supportsRenderTextureWrites
supportsImageBlocks
supportsTileShaders
supportsImageBlockSampleCoverageControl
supportsNativeHardwareFP16
supportsPostDepthCoverage
supportsMipLevelsSmallerThanBlockSize
supportsNonUniformThreadgroupSize
supportsReadWriteTextureArguments
supportsReadWriteTextureCubeArguments
supportsTextureCubeArray
supportsQuadShufflesAndBroadcast
supportsConcurrentComputeDispatch
supportsRenderPassWithoutRenderTarget
supportsRasterOrderGroups
supportsRasterOrderGroupsColorAttachment
supportsLinearTexture2DArray
supportsNonSquareTileShaders
supportsSeparateVisibilityAndShadingRate
supports2DLinearTexArraySPI
supportsLayeredRendering
supportsViewportAndScissorArray
supportsIndirectTessellation
supportsMSAAStencilResolveFilter
supportsStencilFeedback
supportsFP32TessFactors
supportsUnalignedVertexFetch
supportsSIMDGroup
supportsShaderMinLODClamp
supportsSIMDShufflesAndBroadcast
supportsWritableArrayOfTextures
supportsIndirectWritableTextures
supportsStatefulDynamicLibraries
supportsBlackOrWhiteSamplerBorderColors
supportsMirrorClampToEdgeSamplerMode
supportsSIMDReduction
supportsDepthClipModeClampExtended
supportsTexture2DMultisampleArray
supportsForceSeamsOnCubemaps
supportsFloat16BCubicFiltering
supportsFloat16InfNanFiltering
registerDevices
T{?=QQQ},R
lowPower
TB,R,GisLowPower
headless
TB,R,GisHeadless
removable
TB,R,GisRemovable
depth24Stencil8PixelFormatSupported
TB,R,GisDepth24Stencil8PixelFormatSupported
rasterOrderGroupsSupported
TB,R,GareRasterOrderGroupsSupported
programmableSamplePositionsSupported
TB,R,GareProgrammableSamplePositionsSupported
indirectArgumentBufferDecodingData
setIndirectArgumentBufferDecodingData:
newIndirectArgumentEncoderWithArguments:
newComputePipelineStateWithImageFilterFunctionsSPI:imageFilterFunctionInfo:error:
startCollectingPipelineDescriptorsUsingPrefixForNames:
serializeComputePipelineDescriptor:
serializeStructType:version:
deserializeCompileTimeStats:addToDictionary:
TB,R,N
gpuAssertionsEnabled
TB,GareGPUAssertionsEnabled,SsetGPUAssertionsEnabled:
TQ,N
Tr^{MTLTargetDeviceArch=QI*},R
T@"MTLTargetDeviceArchitecture",R
TB,N
Tr^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ},R
Tf,R
T{IndirectArgumentBufferCapabilities=b1b1b1b29},R
quadDataSharingSupported
TB,R,GisQuadDataSharingSupported
float32FilteringSupported
TB,R,GisFloat32FilteringSupported
msaa32bSupported
TB,R,GisMsaa32bSupported
placementHeapSupported
TB,R,GisPlacementHeapSupported
notifyExternalReferencesNonZeroOnDealloc:
debugPipelineOptions:includePipelinePerfStats:
supportsTextureWriteFPRoundingMode:
isIntegrated
memorySize
_integrated
_memorySize
integrated
TB,R,GisIntegrated,V_integrated
TQ,R,V_memorySize
notifyListener:atValue:block:
newSharedEventHandle
signaledValue
setSignaledValue:
vertexAttributes
returnType
arguments
stageInputAttributes
filePath
lineNumber
unpackedFilePath
functionInputs
renderTargetArrayIndexType
functionConstantsDictionary
patchType
patchControlPointCount
newArgumentEncoderWithBufferIndex:
newArgumentEncoderWithBufferIndex:reflection:
newArgumentEncoderWithBufferIndex:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:
newArgumentEncoderWithBufferIndex:reflection:binaryArchives:
bitcodeData
reflectionWithOptions:
reflectionWithOptions:pipelineLibrary:
reflectionWithOptions:binaryArchives:
reflectionWithOptions:completionHandler:
bitCodeHash
newFunctionWithPluginData:bitcodeType:
newFunctionWithBaseObject:parent:
T@"MTLType",R
overrideTriple
setOverrideTriple:
newExternFunctionWithName:
newFunctionWithName:constantValues:pipelineLibrary:error:
newFunctionWithDescriptor:completionHandler:
newFunctionWithDescriptor:error:
newFunctionWithName:constantValues:pipelineLibrary:completionHandler:
functionNames
externFunctionNames
newComputePipelineStateWithName:options:reflection:error:
newComputePipelineDescriptorWithName:error:
initWithComputePipelineState:reflection:parent:descriptor:
traceBufferIndex
validateTraceBuffer:maxBufferCount:options:
newRenderPipelineStateWithName:options:reflection:error:
newRenderPipelineDescriptorWithName:error:
initWithPipelineState:reflection:parent:descriptor:
initWithLibrary:parent:filePath:
setFilePath:
_filePath
T@"NSString",C,N,V_filePath
initWithComputeCommandEncoder:commandBuffer:
globalConstantsData
appendData:
initWithCapacity:
setRenderPipelineState:atIndex:
userReflectionData
newSerializedVertexDataWithFlags:options:error:
initWithVertexData:fragmentData:serializedVertexDescriptor:device:options:flags:
performanceStatistics
setPerformanceStatistics:
_initConstantsBuffer:device:
initWithTileData:functionType:device:options:flags:
vertexLibrary
fragmentLibrary
internalReflection
indirectStateBuffer
_descriptor
_tileDescriptor
_internalReflection
_userReflection
_globalConstants
_vertexConstantOffset
_fragmentConstantOffset
_tileConstantOffset
_indirectStateBuffer
_supportsIndirectCommandBuffers
T@"MTLGPUDebugFunction",R,N
T@"MTLRenderPipelineReflection",R,N
T@"MTLGPUDebugBuffer",R,N
init
setOriginalObject:
parent
strongParent
setBaseObject:
_parent
_baseObject
_device
_externalReferences
T@,&,N,V_baseObject
isMemorylessRender
setColorStoreActionOptions:atIndex:
setDepthStoreActionOptions:
setStencilStoreActionOptions:
setVertexSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setDepthClipModeSPI:
setCommandDataCorruptModeSPI:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:lodBias:atIndex:
setDepthCleared
setStencilCleared
setAlphaTestReferenceValue:
setPointSize:
setClipPlane:p2:p3:p4:atIndex:
setViewportTransformEnabled:
setProvokingVertexMode:
setPrimitiveRestartEnabled:
setPrimitiveRestartEnabled:index:
setTriangleFrontFillMode:backFillMode:
setTransformFeedbackState:
addSplitHandler:
useRenderPipelineState:
useRenderPipelineStates:count:
useHeap:stages:
useHeaps:count:stages:
tileWidth
tileHeight
textureBarrier
setColorResolveTexture:slice:depthPlane:level:atIndex:yInvert:
setBuffer:offset:atIndex:forStage:commandIndex:
initWithIndirectComputeCommand:commandIndex:indirectCommandBuffer:
_commandIndex
init:flags:
flags
segment
_timer
_stream
_segment
TQ,R,N,V_flags
T{_NSRange=QQ},R,N,V_segment
init:
getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:
resetTextureAccessCounters:region:mipLevel:slice:
objectForKey:
unsignedIntegerValue
tracePath
stringByAppendingPathComponent:
writeToFile:options:error:
localizedDescription
resourceStateCommandEncoder
appendSamples:length:
saveCommandBuffer:queue:profilingResults:
_commands
_encoders
_samples
_timestamp
dataWithLength:
setLength:
base64EncodedDataWithOptions:
dataWithBytesNoCopy:length:freeWhenDone:
lengthOfBytesUsingEncoding:
threadgroupSizeMatchesTileSize
newVertexShaderDebugInfo
newFragmentShaderDebugInfo
imageblockSampleLength
isPurgeable
responsibleProcess
setResponsibleProcess:
allocationID
doesAliasResource:
doesAliasAllResources:count:
doesAliasAnyResources:count:
isComplete
waitUntilComplete
validateCPUReadable
validateCPUWriteable
_heap
TQ,R,N,V_options
containsResource:
setRenderPipelineStateBuffers:commandIndex:
setTessellationControlPointIndexBuffer:offset:commandIndex:
drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
initWithIndirectRenderCommand:commandIndex:indirectCommandBuffer:
drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:
buffer
parentTexture
realRootResource
parentRelativeLevel
parentRelativeSlice
bufferOffset
bufferBytesPerRow
swizzle
swizzleKey
isCompressed
compressionFeedback
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
textureType
pixelFormat
usage
width
height
depth
mipmapLevelCount
arrayLength
isFramebufferOnly
allowGPUOptimizedContents
newTextureViewWithPixelFormat:resourceIndex:
newTextureViewWithPixelFormat:
initWithBaseObject:parent:parentTexture:
newTextureViewWithPixelFormat:textureType:levels:slices:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:resourceIndex:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
newCompressedTextureViewWithPixelFormat:textureType:level:slice:
canGenerateMipmapLevels
generateMipmapLevel:slice:
rotation
iosurfacePlane
numFaces
isDrawable
getBytes:bytesPerRow:fromRegion:mipmapLevel:
replaceRegion:mipmapLevel:withBytes:bytesPerRow:
rootResource
T@"<MTLResource>",R
T@"<MTLTexture>",R
T@"<MTLBuffer>",R
T^{__IOSurface=},R
framebufferOnly
TB,R,GisFramebufferOnly
T{?=CCCC},R,N
copyFromSlice:mipmapLevel:origin:size:toPixels:rowBytes:imageBytes:
copyFromPixels:rowBytes:imageBytes:toSlice:mipmapLevel:origin:size:
_parentTexture
_buffer
T@"<MTLTexture>",R,V_parentTexture
T@"<MTLBuffer>",R,V_buffer
alignment
copyGranularity
watermark
initializeTextureMemory:
copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:
copyFromTextureMemory:textureSlice:textureLevel:textureRegion:toLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:
finalizeTextureMemory:
T{?=[2Q]},R
sampledRenderCommandEncoderWithProgramInfoBuffer:capacity:
initWithBaseRenderPass:commandBuffer:descriptor:
debugLocation
encoderLabel
function
T@"NSString",R,N
T@"<MTLFunction>",R,N
T@"<MTLFunctionLogDebugLocation>",R,N
initWithType:function:encoderLabel:texture:stackTrace:
encoderMethodIdentifier
setEncoderMethodIdentifier:
errorStackTrace
_debugLocation
_encoderLabel
_type
_encoderMethodIdentifier
_texture
_errorStackTrace
TQ,N,V_encoderMethodIdentifier
T@"<MTLTexture>",R,N,V_texture
T@"NSArray",R,N,V_errorStackTrace
TQ,R,N,V_type
T@"NSString",R,N,V_encoderLabel
T@"<MTLFunction>",R,N,V_function
T@"<MTLFunctionLogDebugLocation>",R,N,V_debugLocation
initWithType:function:encoderLabel:addressSpace:buffer:offset:operation:stackTrace:argument:
argument
addressSpace
operation
_argument
_addressSpace
_operation
TQ,R,N,V_addressSpace
T@"<MTLBuffer>",R,N,V_buffer
TQ,R,N,V_offset
TQ,R,N,V_operation
T@"MTLArgument",R,N,V_argument
initWithDebugLocation:
inlinedAt
_newReportBuffer
_temporaryBufferWithLength:
temporaryBufferWithLength:
_encoderIdentifierForEncoderIndex:
_encodeReportBuffer:type:
initWithFormat:
_allocReportEntryStorageForType:
beginingEncoder:type:
initWithParallelRenderCommandEncoder:parent:descriptor:encoderID:
initWithComputeCommandEncoder:parent:encoderID:
initWithBlitCommandEncoder:parent:encoderID:
_checkReportBuffers
initWithCommandBuffer:commandQueue:
_stageArgumentEncoder
_vertexComputeReportBuffer
_vertexComputeReportOffset
_fragmentReportOffset
_usedBuffers
_currentPooledBuffer
_currentPooledBufferOffset
_currentEncoderID
_currentReportID
_reportBufferList
_reportEntryList
_encoderLabels
_allocationLock
_tempBufLock
_supportsTileStage
T@"MTLGPUDebugDevice",R,D
standardizedURL
path
containsString:
vertexArguments
fragmentArguments
debugLocationForID:
_setDefaults
internalValidateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:move:
addObject:retained:purgeable:
cStringUsingEncoding:
validateCopyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
maxVertexBufferBindCount
maxFragmentBufferBindCount
optimizedRangeList
rangeValue
valueWithRange:
validateCopyFromTexture:sourceSlice:sourceLevel:sourceSize:toTexture:destinationSlice:destinationLevel:options:sliceCount:levelCount:
initWithBlitCommandEncoder:commandBuffer:
canDealloc
canEndEncoding
hasEndEncoding
updatedFences
string
appendString:
range
setRange:
_label
_range
T@"NSString",C,N,V_label
T{_NSRange=QQ},N,V_range
hasTrackedMakeAliasable
setHasTrackedMakeAliasable:
initWithBaseTexture:device:buffer:offset:bytesPerRow:
initWithBaseTexture:device:buffer:offset:bytesPerRow:bytesPerImage:
lockPurgeableState
unlockPurgeableState
purgeableStateValidForRendering
initWithBuffer:device:options:
initWithBuffer:heap:device:options:
initWithBuffer:device:bytes:options:
copyDebugMarkers
common
pointer
isContentExposedToCPU
setIsContentExposedToCPU:
_common
_debugDevice
_debugMarkers
_purgeableStateToken
_purgeableStateHasBeenSet
_isContentExposedToCPU
_pointer
T@"MTLDebugResource",R,N,V_common
Tr^v,R,N,V_pointer
TB,N,V_isContentExposedToCPU
complainAboutSloppyTextureUsage
setRetainedReferences:
_tracePath
T@"NSString",R,N,V_tracePath
addReferenceTrackingCommandBuffer:
isCommitted
loadAction
loadValidationEnabled
setLoadAction:
setClearColor:
setClearDepth:
setClearStencil:
addReferencedObject:internallyRetained:
addPurgeableObject:
baseTexture
baseLevelOffset
baseSliceRangeOffset
addUsedRenderTarget:slices:
baseResolveTexture
resolveLevelOffset
resolveSliceRangeOffset
lockPurgeableObjects
removeUsedRenderTarget:slices:
unlockPurgeableObjects
removeAllReferencedObjects:
removeReferenceTrackingCommandBuffer:
unionSet:
containsObject:
onParallelRenderCommanderEndEncoding
validateStoreLoadTransition:atIndex:renderTargetArrayLength:
testObjectReferenced:wasInternallyRetained:
addActiveRenderTargets:
addActiveRenderTarget:
renderTargetInActiveRenderTargets:
_currentEncoder
_attachmentSet
_prevAttachments
_currAttachments
_purgeableObjectsLock
_referencedPurgeableObjects
_externallyRetainedObjects
_internallyRetainedObjects
_referencedDeadObject
_renderTargetAttachmentLock
_renderTargetAttachments
renderTargetArrayLength
requireUsage:
clearDepth
threadgroupMemoryLength
startOfVertexSampleIndex
endOfVertexSampleIndex
startOfFragmentSampleIndex
endOfFragmentSampleIndex
startOfEncoderSampleIndex
endOfEncoderSampleIndex
null
isFileURL
drawArguments
drawIndexedArguments
drawIndexedPatchesArguments
drawPatchesArguments
getTessellationFactorArguments
getFragmentBufferAtIndex:
getVertexBufferAtIndex:
initWithCounterSampleBuffer:device:descriptor:
descriptor
_storageMode
T@"MTLCounterSampleBufferDescriptor",R,N,V_descriptor
TQ,R,N,V_storageMode
_newRenderPipelineStateWithTileDescriptor:options:reflection:error:
_newRenderPipelineStateWithTileDescriptor:options:completionHandler:
TB,R,N,V_APITimingEnabled
setArgumentBuffer:startOffset:arrayElement:
setIndirectCommandBuffer:atIndex:
setRenderPipelineStates:withRange:
setIndirectCommandBuffers:withRange:
newArgumentEncoderForBufferAtIndex:
_layout
newSerializedComputeDataWithFlags:options:
initWithSerializedData:serializedStageInputDescriptor:device:options:flags:
threadgroupArgumentOffset
T@"MTLToolsFunction",R,N
T@"MTLComputePipelineReflection",R,N
addObjectsFromArray:
threadGroupSizeIsMultipleOfThreadExecutionWidth
_validateThreadsPerThreadgroup:
reflection
validateStageInRegion:
_validateAllFunctionArguments
computePipelineState
enumerateBuffersUsingBlock:
enumerateTexturesUsingBlock:
enumerateSamplersUsingBlock:
enumerateThreadgroupMemoryLengthsUsingBlock:
_buffers
_textures
_samplers
_threadgroupMemoryLengths
_imageBlockSize
canSetComputePipelineState
hasSetComputePipelineState
hasSetStageInRegion
stageInRegion
hasIndirectSetStageInRegion
allowsNullBufferBinds
_computePipelineState
T@"<MTLComputePipelineState>",R,N,V_computePipelineState
builtInArguments
builtInType
isActive
bufferAlignment
bufferDataSize
access
threadgroupMemoryDataSize
textureDataType
builtInDataType
getParameter:
_maxThreadPositionInGrid
_maxThreadsPerGrid
_maxThreadPositionInThreadgroup
_maxThreadIndexInThreadgroup
_maxThreadsPerThreadgroup
_maxThreadgroupPositionInGrid
_maxThreadgroupsPerGrid
_maxStageInGridSize
_maxStageInGridOrigin
_reflection
T@"MTLComputePipelineDescriptor",R,N,V_descriptor
T@"MTLComputePipelineReflection",R,N,V_reflection
initWithIndirectCommandBuffer:device:descriptor:maxCommandCount:options:
_optimizedRangeList
_maxCommandCount
_isRender
T@"NSMutableArray",R
T@"MTLIndirectCommandBufferDescriptor",R
stringWithUTF8String:
stringByStandardizingPath
defaultManager
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
componentsSeparatedByString:
pipelineNames
disableRunTimeCompilation
setDisableRunTimeCompilation:
pipelineCache
functionCache
T@"<MTLPipelineCache>",R,N
layout
setFunctionPointer:atIndex:
setFunctionPointers:withRange:
setComputePipelineState:atIndex:
setComputePipelineStates:withRange:
T@"_MTLIndirectArgumentBufferLayout",R,N
elementType
elementStructType
elementArrayType
members
indirectArgumentIndex
structType
arrayType
pointerType
elementIsArgumentBuffer
setArgumentBuffer:startOffset:elementIndex:
supportArgumentBuffers
initWithBaseObject:structType:parent:
_currentBuffer
_currentOffset
_reflectionParser
initWithHeap:device:
validateResourceOptions:isTexture:isIOSurface:context:
validateNewBufferArgs:options:context:
initWithBaseTexture:device:
newDepthStencilStateWithBaseObject:device:descriptor:
validateMemorylessResource:context:
newSamplerStateWithBaseObject:device:descriptor:
initWithLibrary:parent:type:code:options:
_newRenderPipelineStateWithDescriptor:options:reflection:error:
_newRenderPipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithDescriptor:options:reflection:error:
validateLinkedFunctions:
_newComputePipelineStateWithDescriptor:options:completionHandler:
_newComputePipelineStateWithFunction:options:reflection:error:
_newComputePipelineStateWithFunction:options:completionHandler:
initWithPipelineState:reflection:parent:tileDescriptor:
arrayWithArray:
setImageFilterFunctions:imageFilterFunctionInfo:
fileSystemRepresentation
initWithUTF8String:
initWithBaseTexture:device:plane:
initWithBaseTextureLayout:device:descriptor:
notifySamplerStateDeallocated:
clearRenderEncoder:writeMask:withCheckerboard:
storeValidationEnabled
_argumentBufferSamplers
_referenceTrackingCommandBufferLock
_referenceTrackingCommandBuffers
_checkerboardRTPipelineCache
_storeValidationEnabled
_loadValidationEnabled
TB,R,V_loadValidationEnabled
TB,R,V_storeValidationEnabled
URLForResource:withExtension:
storeAction
setConstantValue:type:atIndex:
setPixelFormat:
setDepthAttachmentPixelFormat:
depthCompareFunction
isDepthWriteEnabled
_initWithBaseDepthStencilState:device:descriptor:
attachmentWriteMask
_attachmentWriteMask
T@"MTLDepthStencilDescriptor",R,N,V_descriptor
TC,R,N,V_attachmentWriteMask
stencilCompareFunction
writeMask
stencilFailureOperation
depthStencilPassOperation
depthFailureOperation
setInheritPipelineState:
setCommandTypes:
maxCommands
maxVertexBindings
maxFragmentBindings
commandByteStride
inheritsBuffers
inheritsPipelineState
onExecuteWithRenderEncoder:
onExecuteWithComputeEncoder:
fencingICB
_hasRender
_inheritsBuffers
_inheritsPipelineState
_argumentStorage
_drawIDBuffer
_maxCommands
_maxVertexBindings
_maxFragmentBindings
_commandByteStride
_originalResourceOptions
_fencingICB
T@"<MTLBuffer>",R,N
_encoderID
numberWithUnsignedInteger:
numberWithFloat:
dataTypeDescription
elementIsIndirectArgumentBuffer
bufferStructType
constantValues
setConstantValues:
_constantValues
T@"MTLFunctionConstantValues",&,N,V_constantValues
validateDescriptor:expectedClass:
copyConstantValues:
debugType
setDebugType:
code
setCode:
compileOptions
setCompileOptions:
imageFilterFunctions
imageFilterFunctionInfo
_debugType
_code
_compileOptions
_imageFilterFunctions
_imageFilterFunctionInfo
TQ,N,V_debugType
T@,C,N,V_code
T@"MTLCompileOptions",C,N,V_compileOptions
T@"NSArray",R,N,V_imageFilterFunctions
T^{?=BQ^{?}},R,N,V_imageFilterFunctionInfo
setStoreAction:
setStoreActionOptions:
mergeAttachmentWriteMask:
_unknownStoreActions
T@"MTLRenderPassDescriptor",R,C,N,V_descriptor
initWithDesc:renderTargetArrayLength:
intersectsTexture:
attachmentTexture
_attachmentTexture
_baseResolveTexture
_baseTexture
_renderTargetArrayLength
_baseLevelOffset
_resolveLevelOffset
_baseSliceRangeOffset
_resolveSliceRangeOffset
T@"<MTLTexture>",R,N,V_attachmentTexture
T@"<MTLTexture>",R,N,V_baseResolveTexture
T@"<MTLTexture>",R,N,V_baseTexture
TQ,R,N,V_renderTargetArrayLength
TQ,R,N,V_baseLevelOffset
TQ,R,N,V_resolveLevelOffset
T{_NSRange=QQ},R,N,V_baseSliceRangeOffset
T{_NSRange=QQ},R,N,V_resolveSliceRangeOffset
validate:width:height:
defaultColorSampleCount
defaultRasterSampleCount
openGLModeEnabled
numberWithUnsignedLong:
rasterSampleCount
colorSampleCount
rasterizationEnabled
tileDescriptor
validateFramebufferWithRenderPipelineState:
outputImageBlockData
renderPipelineState
isImageBlockLayoutInputCompatibleWithOutputOf:
tileArguments
inputPrimitiveTopology
updatePipelineData
validateCommonDrawErrors:instanceCount:baseInstance:maxVertexID:
validateDrawPrimitives:vertexStart:vertexCount:instanceCount:function:
validateDrawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:function:
tessellationControlPointIndexType
viewports
scissorRects
viewport
scissorRect
enumerateVertexBuffersUsingBlock:
enumerateVertexTexturesUsingBlock:
enumerateVertexSamplersUsingBlock:
enumerateFragmentBuffersUsingBlock:
enumerateFragmentTexturesUsingBlock:
enumerateFragmentSamplersUsingBlock:
enumerateTileBuffersUsingBlock:
enumerateTileTexturesUsingBlock:
enumerateTileSamplersUsingBlock:
enumerateThreadgroupMemoryUsingBlock:
frontFacingWinding
cullMode
depthClipMode
lineWidth
depthBias
depthBiasSlopeScale
depthBiasClamp
triangleFillMode
peakPerSampleStorage
resolvedSampleCount
depthStencilState
defaultDepthStencilDescriptor
frontStencilRef
backStencilRef
visibilityResultMode
visibilityResultOffset
blendColorRed
blendColorGreen
blendColorBlue
blendColorAlpha
tessellationFactorBufferArgument
tessellationFactorBufferInstanceStride
tessellationFactorScale
_dirtyBits
_openGLModeEnabled
_vertexBuiltinArguments
_attachmentInfo
_previousRenderPipelineStateWithWritesToImageBlock
_resolvedRasterSampleCount
_vertexTextures
_vertexSamplers
_fragmentTextures
_fragmentSamplers
_tileTextures
_tileSamplers
_threadgroupMemoryArguments
_encoderState
_visibilityOffsets
_viewports
_scissorRects
_updatedFences
_storingRenderTargets
_maxVertexBuffers
_lineWidth
_depthBias
_depthBiasSlopeScale
_depthBiasClamp
_frontStencilRef
_backStencilRef
_blendColorRed
_blendColorGreen
_blendColorBlue
_blendColorAlpha
_tessellationFactorScale
_frontFacingWinding
_cullMode
_depthClipMode
_triangleFillMode
_renderPipelineState
_peakPerSampleStorage
_resolvedSampleCount
_depthStencilState
_defaultDepthStencilDescriptor
_visibilityResultMode
_visibilityResultOffset
_width
_height
_tessellationFactorBufferInstanceStride
_tessellationFactorBufferArgument
TQ,R,N,V_attachmentWriteMask
T^{vector<MTLViewport, std::__1::allocator<MTLViewport>>=^{?}^{?}{__compressed_pair<MTLViewport *, std::__1::allocator<MTLViewport>>=^{?}}},R,N
T^{vector<MTLScissorRect, std::__1::allocator<MTLScissorRect>>=^{?}^{?}{__compressed_pair<MTLScissorRect *, std::__1::allocator<MTLScissorRect>>=^{?}}},R,N
T{?=dddddd},R,N
T{?=QQQQ},R,N
TQ,R,N,V_frontFacingWinding
TQ,R,N,V_cullMode
TQ,R,N,V_depthClipMode
Tf,R,N,V_lineWidth
Tf,R,N,V_depthBias
Tf,R,N,V_depthBiasSlopeScale
Tf,R,N,V_depthBiasClamp
TQ,R,N,V_triangleFillMode
T@"<MTLRenderPipelineState>",R,N,V_renderPipelineState
TQ,R,N,V_peakPerSampleStorage
TQ,R,N,V_resolvedSampleCount
T@"<MTLDepthStencilState>",R,N,V_depthStencilState
T@"MTLDepthStencilDescriptor",R,N,V_defaultDepthStencilDescriptor
TI,R,N,V_frontStencilRef
TI,R,N,V_backStencilRef
TQ,R,N,V_visibilityResultMode
TQ,R,N,V_visibilityResultOffset
Tf,R,N,V_blendColorRed
Tf,R,N,V_blendColorGreen
Tf,R,N,V_blendColorBlue
Tf,R,N,V_blendColorAlpha
TQ,R,V_width
TQ,R,V_height
T{?=BBQ@QQQQQBff},R,N,V_tessellationFactorBufferArgument
TQ,R,N,V_tessellationFactorBufferInstanceStride
Tf,R,N,V_tessellationFactorScale
sortedArrayUsingComparator:
readMask
tessellationFactorFormat
tessellationFactorStepFunction
numberWithUnsignedLongLong:
setObject:forKey:
_traceBuffer
T@"MTLCountersTraceCommandBuffer",R,N,V_traceBuffer
TI,R,V_encoderID
_hasTrackedMakeAliasable
T@,R,V_baseObject
TB,V_hasTrackedMakeAliasable
_handles
_dispatchID
initWithFunction:library:
internalStructTypeFromUserStructType:
internalArrayTypeFromUserArrayType:
stride
convertUserType:
indirectArgumentIndexStride
setIndirectArgumentIndexStride:
argumentIndex
setMembers:count:
newArgumentEncoderWithBufferIndex:reflection:pipelineLibrary:binaryArchives:
argumentLayoutsMutex
argumentLayouts
setStructType:withDevice:
initWithArrayLength:elementType:stride:pixelFormat:aluType:details:
initWithName:type:access:isActive:locationIndex:dataType:pixelFormat:aluType:dataSize:alignment:
initWithName:offset:dataType:pixelFormat:aluType:indirectArgumentIndex:render_target:raster_order_group:details:
_updateCachedPipelineState:
_updateCachedTilePipelineState:
imageBlockMasterStructMembers
imageBlockDataReturn
initWithObjects:
_findMasterStruct:includeImageBlockData:
isStructLayoutThreadSafeWith:
isRasterizationEnabled
vertexDescriptor
layouts
vertexBuiltInArguments
_maxVertexCount
_maxInstanceCount
_maxPatchCount
_rasterSampleCount
_colorPixelFormat
_depthPixelFormat
_stencilPixelFormat
_vertexDescriptorLayoutCount
_vertexDescriptorLayouts
_threadgroupSizeMatchesTileSize
T@"MTLRenderPipelineDescriptor",R,N,V_descriptor
T@"MTLRenderPipelineReflection",R,N,V_reflection
T@"MTLTileRenderPipelineDescriptor",R,N,V_tileDescriptor
_initWithBaseSamplerState:device:descriptor:
T@"MTLSamplerDescriptor",R,C,N,V_descriptor
normalizedCoordinates
mipFilter
sAddressMode
tAddressMode
rAddressMode
maxAnisotropy
minFilter
magFilter
compareFunction
setMaxAnisotropy:
descriptorPrivate
validateHeapResourceOptions:isTexture:isIOSurface:
validateHeapTextureUsage:options:
validatePixelFormatWithHeap:
initWithBaseTexture:heap:device:
validateOffset:withRequirements:
debugDevice
T@"MTLDebugDevice",R,N,V_debugDevice
initWithBaseTexture:device:texture:
initWithBaseTexture:device:texture:pixelFormat:
initWithBaseTexture:device:texture:pixelFormat:textureType:levels:slices:
_resourceHasMemory
bytesPerRow
bytesPerImage
plane
activeSubViews
setActiveSubViews:
isLinearTexture
_pixelFormatInfo
_usageRequired
_subViewUseLock
_isLinearTexture
_bytesPerRow
_bytesPerImage
_plane
_activeSubViews
TQ,R,N,V_bytesPerRow
TQ,R,N,V_bytesPerImage
TQ,R,N,V_plane
T{unordered_map<SubView, unsigned long, SubView::hash_t, SubView::equal_t, std::__1::allocator<std::__1::pair<const SubView, unsigned long>>>={__hash_table<std::__1::__hash_value_type<SubView, unsigned long>, std::__1::__unordered_map_hasher<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::hash_t, true>, std::__1::__unordered_map_equal<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::equal_t, true>, std::__1::allocator<std::__1::__hash_value_type<SubView, unsigned long>>>={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>>={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>>=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *>>>={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::hash_t, true>>=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::equal_t, true>>=f}}},N,V_activeSubViews
TB,R,N,V_isLinearTexture
T@"MTLTextureDescriptor",R,C,N,V_descriptor
@48@0:8@16@24Q32@40
Q16@0:8
@16@0:8
v16@0:8
v24@0:8@16
v40@0:8@16Q24Q32
v64@0:8{?=QQQ}16{?=QQQ}40
@"MTLIndirectCommandBufferDescriptor"
@"<MTLIndirectCommandBufferSPI>"
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B16@0:8
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
I16@0:8
@44@0:8@16@24@32I40
v32@0:8@16Q24
v32@0:8Q16Q24
v48@0:8r^@16r^Q24{_NSRange=QQ}32
v40@0:8r^v16Q24Q32
v40@0:8Q16Q24Q32
v40@0:8Q16@24Q32
v48@0:8Q16Q24Q32Q40
v56@0:8Q16Q24Q32Q40Q48
v56@0:8Q16Q24Q32@40Q48
v64@0:8Q16Q24Q32@40Q48Q56
v64@0:8Q16Q24@32Q40@48Q56
v80@0:8Q16Q24Q32@40Q48Q56q64Q72
v56@0:8Q16@24Q32@40Q48
v72@0:8Q16Q24Q32@40Q48Q56Q64
v72@0:8Q16@24Q32@40Q48@56Q64
v88@0:8Q16Q24Q32@40Q48@56Q64Q72Q80
v40@0:8{?=QQQ}16
v40@0:8@16{_NSRange=QQ}24
v40@0:8@16@24Q32
v40@0:8r^@16Q24Q32
v48@0:8r^@16Q24Q32Q40
{MTLGPUDebugStageBufferHandles="handles"[31Q]"buffers"[31@"MTLGPUDebugBuffer"]"offsets"[31Q]"needsFlush"B}
{MTLGPUDebugBufferArgumentData="needsFlush"B"argumentBufferBacking"B"useLengths"B"buffers"[31@"<MTLBuffer>"]"offsets"[31Q]"lengths"[31I]"gpu_address"[31[2Q]]}
{MTLGPUDebugTileThreadgroup="entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
^{Options=Iiiii{?=b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1b1}}
{GPUDebugEventUUIDPacket="pipelineStateID"Q"encoderID"I"eventID"I}
@"MTLGPUDebugRenderPipelineState"
@"MTLToolsDepthStencilState"
{GPUBufferSubAlloc="buffer"@"<MTLBuffer>""offset"Q}
Q24@0:8Q16
v24@0:8@"NSString"16
@"<MTLDevice>"16@0:8
@"<MTLHeap>"16@0:8
v32@0:8{_NSRange=QQ}16
@24@0:8Q16
@"<MTLIndirectRenderCommand>"24@0:8Q16
@"<MTLIndirectComputeCommand>"24@0:8Q16
v32@0:8^^v16^Q24
v136@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112
v120@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96
v128@0:8@16Q24Q32Q40{?=QQQ}48@72Q80Q88{?=QQQ}96Q120
v120@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112
v128@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104Q112Q120
v44@0:8@16{_NSRange=QQ}24C40
v80@0:8@16Q24Q32@40Q48Q56Q64Q72
v32@0:8@16@24
v56@0:8@16Q24@32Q40Q48
v56@0:8@16{_NSRange=QQ}24@40Q48
v36@0:8@16Q24B32
v24@0:8@"<MTLResource>"16
v40@0:8@"<MTLTexture>"16Q24Q32
v136@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLTexture>"88Q96Q104{?=QQQ}112
v120@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96
v128@0:8@"<MTLBuffer>"16Q24Q32Q40{?=QQQ}48@"<MTLTexture>"72Q80Q88{?=QQQ}96Q120
v120@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112
v128@0:8@"<MTLTexture>"16Q24Q32{?=QQQ}40{?=QQQ}64@"<MTLBuffer>"88Q96Q104Q112Q120
v24@0:8@"<MTLTexture>"16
v44@0:8@"<MTLBuffer>"16{_NSRange=QQ}24C40
v80@0:8@"<MTLTexture>"16Q24Q32@"<MTLTexture>"40Q48Q56Q64Q72
v32@0:8@"<MTLTexture>"16@"<MTLTexture>"24
v56@0:8@"<MTLBuffer>"16Q24@"<MTLBuffer>"32Q40Q48
v24@0:8@"<MTLFence>"16
v40@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24
v56@0:8@"<MTLIndirectCommandBuffer>"16{_NSRange=QQ}24@"<MTLIndirectCommandBuffer>"40Q48
v36@0:8@"<MTLCounterSampleBuffer>"16Q24B32
v56@0:8@"<MTLCounterSampleBuffer>"16{_NSRange=QQ}24@"<MTLBuffer>"40Q48
@40@0:8@16@24@32
v144@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136
v40@0:8r^@16{_NSRange=QQ}24
v40@0:8@16f24f28Q32
v56@0:8r^@16r^f24r^f32{_NSRange=QQ}40
v48@0:8@16Q24@32Q40
v32@0:8r^@16Q24
v64@0:8{?=dddddd}16
v32@0:8r^{?=dddddd}16Q24
v24@0:8Q16
v20@0:8f16
v28@0:8f16f20f24
v48@0:8{?=QQQQ}16
v32@0:8r^{?=QQQQ}16Q24
v20@0:8I16
v24@0:8I16I20
v32@0:8f16f20f24f28
v56@0:8@16Q24Q32Q40Q48
v60@0:8@16Q24Q32Q40B48Q52
v48@0:8@16Q24Q32Q40
v52@0:8@16Q24Q32Q40B48
@"MTLCountersTraceRenderCommandEncoder"
@32@0:8{_NSRange=QQ}16
@"NSData"32@0:8{_NSRange=QQ}16
@32@0:8@16@24
@24@0:8@16
@40@0:8@16@24^@32
v40@0:8@16@24@?32
^v16@0:8
@40@0:8@16Q24Q32
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16Q24Q32
v40@0:8@"NSString"16{_NSRange=QQ}24
@48@0:8@16Q24Q32Q40
^{__IOSurface=}16@0:8
v24@0:8@?16
v32@0:8@16d24
d16@0:8
v24@0:8@?<v@?@"<MTLCommandBuffer>">16
v24@0:8@"<MTLDrawable>"16
v32@0:8@"<MTLDrawable>"16d24
@"<MTLBlitCommandEncoder>"16@0:8
@"<MTLRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLComputeCommandEncoder>"24@0:8@"MTLComputePassDescriptor"16
@"<MTLBlitCommandEncoder>"24@0:8@"MTLBlitPassDescriptor"16
@"<MTLComputeCommandEncoder>"16@0:8
@"<MTLComputeCommandEncoder>"24@0:8Q16
v32@0:8@"<MTLEvent>"16Q24
@"<MTLParallelRenderCommandEncoder>"24@0:8@"MTLRenderPassDescriptor"16
@"<MTLCommandQueue>"16@0:8
@"<MTLLogContainer>"16@0:8
@"NSError"16@0:8
v20@0:8B16
^v24@0:8^Q16
@40@0:8@16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
v36@0:8@16Q24I32
v40@0:8Q16r^@24Q32
v24@0:8@"<MTLHeap>"16
@"NSDictionary"16@0:8
@"NSMutableDictionary"16@0:8
@"<MTLRenderCommandEncoder>"40@0:8@"MTLRenderPassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"32@0:8^(?={?=b8b24IQQ}{?=b8b24IQQ})16Q24
@"<MTLComputeCommandEncoder>"40@0:8Q16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLComputeCommandEncoder>"40@0:8@"MTLComputePassDescriptor"16^(?={?=b8b24IQQ}{?=b8b24IQQ})24Q32
@"<MTLDebugCommandEncoder>"16@0:8
v36@0:8@"<MTLEvent>"16Q24I32
B24@0:8@"MTLToolsObject"16
@"NSMutableSet"16@0:8
v40@0:8@16Q24@32
v20@0:8i16
v44@0:8i16Q20r^@28Q36
{?="hasCommit"b1"addedCompletedHandler"b1"addedScheduledHandler"b1"padding"b29}
{os_unfair_lock_s="_os_unfair_lock_opaque"I}
{vector<void (^)(id<MTLCommandBuffer>), std::__1::allocator<void (^)(id<MTLCommandBuffer>)>>="__begin_"^@?"__end_"^@?"__end_cap_"{__compressed_pair<void (^*)(id<MTLCommandBuffer>), std::__1::allocator<void (^)(id<MTLCommandBuffer>)>>="__value_"^@?}}
@"NSMutableSet"
v28@0:8I16I20I24
@"MTLToolsCommandBuffer"
v40@0:8@16Q24^v32
@40@0:8^Q16^v24^B32
{vector<std::__1::pair<NSData *, unsigned long>, std::__1::allocator<std::__1::pair<NSData *, unsigned long>>>="__begin_"^{pair<NSData *, unsigned long>}"__end_"^{pair<NSData *, unsigned long>}"__end_cap_"{__compressed_pair<std::__1::pair<NSData *, unsigned long> *, std::__1::allocator<std::__1::pair<NSData *, unsigned long>>>="__value_"^{pair<NSData *, unsigned long>}}}
{__wrap_iter<std::__1::pair<NSData *, unsigned long> *>="__i"^{pair<NSData *, unsigned long>}}
@"<MTLCommandBuffer>"16@0:8
@"<MTLCommandBuffer>"24@0:8@"MTLCommandBufferDescriptor"16
B24@0:8Q16
B28@0:8Q16S24
i16@0:8
i24@0:8@16
i32@0:8@16Q24
v24@0:8@"NSObject<OS_dispatch_queue>"16
@"NSObject<OS_dispatch_queue>"16@0:8
@"NSArray"16@0:8
i24@0:8@"NSArray"16
i32@0:8@"NSArray"16Q24
@"NSArray"24@0:8@"NSArray"16
v24@0:8@?<v@?@"<MTLCommandBuffer>"@"NSData"Q>16
@?32@0:8^B16@24
@"MTLToolsPerfCounterMailbox"
B32@0:8@16^@24
B32@0:8@"NSURL"16^@24
B40@0:8@16Q24^@32
r^{?=[32C]}16@0:8
B40@0:8@"NSURL"16Q24^@32
@"NSString"24@0:8Q16
@"NSObject<OS_dispatch_data>"16@0:8
B32@0:8@"MTLComputePipelineDescriptor"16^@24
B32@0:8@"MTLRenderPipelineDescriptor"16^@24
B32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
v32@0:8@"MTLBinaryEntry"16@"MTLBinaryKey"24
@"MTLBinaryEntry"24@0:8@"MTLBinaryKey"16
B40@0:8@"MTLComputePipelineDescriptor"16Q24^@32
B40@0:8@"MTLRenderPipelineDescriptor"16Q24^@32
B40@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32
@32@0:8Q16Q24
@40@0:8Q16Q24Q32
@32@0:8@16Q24
q16@0:8
@"<MTLBuffer>"32@0:8Q16Q24
@"<MTLTexture>"24@0:8@"MTLTextureDescriptor"16
@"<MTLBuffer>"40@0:8Q16Q24Q32
@"<MTLTexture>"32@0:8@"MTLTextureDescriptor"16Q24
v64@0:8{?={?=QQQ}{?=QQQ}}16
v56@0:8@16Q24{?=QQQ}32
v24@0:8@"<MTLComputePipelineState>"16
v40@0:8@"<MTLBuffer>"16Q24Q32
v32@0:8@"<MTLTexture>"16Q24
v32@0:8@"<MTLSamplerState>"16Q24
v40@0:8@"<MTLSamplerState>"16f24f28Q32
v32@0:8@"<MTLBuffer>"16Q24
v56@0:8@"<MTLBuffer>"16Q24{?=QQQ}32
v32@0:8@"<MTLResource>"16Q24
v40@0:8@"<MTLIndirectCommandBuffer>"16@"<MTLBuffer>"24Q32
@"NSData"16@0:8
Q40@0:8{?=QQQ}16
@40@0:8@16{_NSRange=QQ}24
@"<MTLFunctionPointerHandleSPI>"24@0:8@"<MTLFunction>"16
@"NSArray"40@0:8@"NSArray"16{_NSRange=QQ}24
@"MTLDebugInstrumentationData"16@0:8
@"<MTLFunction>"
@48@0:8@16@24Q32Q40
@52@0:8@16@24Q32Q40B48
@60@0:8@16@24@32Q40Q48B56
^{GPUDebugBufferDescriptorHeap={mutex={_opaque_pthread_mutex_t=q[56c]}}{vector<unsigned int, std::__1::allocator<unsigned int>>=^I^I{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int>>=^I}}{vector<MTLGPUDebugBuffer *, std::__1::allocator<MTLGPUDebugBuffer *>>=^@^@{__compressed_pair<MTLGPUDebugBuffer **, std::__1::allocator<MTLGPUDebugBuffer *>>=^@}}Q@@}
^v24@0:8Q16
{?={?=QQQ}{?=QQQ}}16@0:8
@"_MTLIndirectDispatchThreadgroupsArguments"16@0:8
@"_MTLIndirectDispatchThreadsArguments"16@0:8
@"_MTLImageBlockArguments"16@0:8
v24@0:8^Q16
@32@0:8@16^Q24
@32@0:8@16^@24
@48@0:8@16Q24^@32^@40
v32@0:8@16@?24
v40@0:8@16Q24@?32
@40@0:8@16r^{?=BQ^{?}}24^@32
@40@0:8Q16@24^@32
@40@0:8r^v16Q24Q32
@48@0:8^v16Q24Q32@?40
@24@0:8^{__IOSurface=}16
@48@0:8r^v16Q24Q32Q40
@56@0:8^v16Q24Q32Q40@?48
{MetalBufferHeap="_mutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_buffers"{vector<id<MTLBuffer>, std::__1::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::__1::allocator<id<MTLBuffer>>>="__value_"^@}}"_freeList"{vector<unsigned int, std::__1::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int>>="__value_"^I}}"_currentFreeIndex"i"_totalMemoryAllocated"Q"_totalMemoryInUse"Q"_bufferLength"Q"_device"@"MTLGPUDebugDevice"}
{Options="version"I"mode"i"programTypes"i"accessTypes"i"failMode"i""{?="enableReporting"b1"packPointerAddresses"b1"unpackPointerAddress"b1"forceInline"b1"enableBacktracking"b1"optimizeConstantDeref"b1"skipVertexFetchLoads"b1"enableGEPOptimization"b1"emitBoundsChecking"b1"runStandardOptimizations"b1"backtrackFailuresAssumeSafe"b1"pageDataIs32bitLength"b1"forceUnrollLoops"b1"mergeAccessChecks"b1"convertToAB"b1"arraysOfBuffersAB"b1"noInlineTrivialFunctions"b1"unrollMemCpyWA"b1"checkGlobalConstants"b1"enableTextureChecks"b1"demoteGlobalConstantsToArg"b1"argumentPointerIndirection"b1"enableThreadgroupMemoryChecks"b1"mergeThreadgroupGlobals"b1"mergeThreadgroupArguments"b1"tagThreadgroupPointers"b1"noInlineCheckFunctions"b1"enableJumpThreading"b1"enableICBSupport"b1}}
{GPUDebugDeviceOptions="retainReflection"b1}
{GPUDebugBufferDescriptorHeap="s"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_freeIndexList"{vector<unsigned int, std::__1::allocator<unsigned int>>="__begin_"^I"__end_"^I"__end_cap_"{__compressed_pair<unsigned int *, std::__1::allocator<unsigned int>>="__value_"^I}}"_bufferList"{vector<MTLGPUDebugBuffer *, std::__1::allocator<MTLGPUDebugBuffer *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<MTLGPUDebugBuffer **, std::__1::allocator<MTLGPUDebugBuffer *>>="__value_"^@}}"_freeIndex"Q"_argumentEncoder"@"<MTLArgumentEncoder>""_descriptorHeap"@"<MTLBuffer>"}
{GPUDebugConstantBufferCache="_totalUsedMemory"Q"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_cache"{unordered_map<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value, GPUDebugConstantBufferCache::Key::Hash, std::__1::equal_to<GPUDebugConstantBufferCache::Key>, std::__1::allocator<std::__1::pair<const GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__table_"{__hash_table<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::__1::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, true>, std::__1::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::__1::equal_to<GPUDebugConstantBufferCache::Key>, true>, std::__1::allocator<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<GPUDebugConstantBufferCache::Key, std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, GPUDebugConstantBufferCache::Key::Hash, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<GPUDebugConstantBufferCache::Key, std::__1::__hash_value_type<GPUDebugConstantBufferCache::Key, GPUDebugConstantBufferCache::Value>, std::__1::equal_to<GPUDebugConstantBufferCache::Key>, true>>="__value_"f}}}"_device"@"MTLGPUDebugDevice"}
{GlobalResidentBufferList="_iteration"I"_accessMutex"{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}"_bufferList"{list<id<MTLBuffer>, std::__1::allocator<id<MTLBuffer>>>="__end_"{__list_node_base<id<MTLBuffer>, void *>="__prev_"^{__list_node_base<id<MTLBuffer>, void *>}"__next_"^{__list_node_base<id<MTLBuffer>, void *>}}"__size_alloc_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__list_node<id<MTLBuffer>, void *>>>="__value_"Q}}}
@"NSData"
@"NSMutableArray"
{once_flag="__state_"Q}
@"<MTLRenderPipelineState>"
@"<MTLDepthStencilState>"
{?=QQ}24@0:8@16
{?=QQ}32@0:8Q16Q24
@40@0:8@16^{__IOSurface=}24Q32
B24@0:8q16
v32@0:8^{?=ff}16Q24
v32@0:8^Q16^Q24
{?=QQQ}16@0:8
@"<MTLCommandQueue>"24@0:8Q16
{?=QQ}24@0:8@"MTLTextureDescriptor"16
@"<MTLHeap>"24@0:8@"MTLHeapDescriptor"16
@"<MTLBuffer>"40@0:8r^v16Q24Q32
@"<MTLBuffer>"48@0:8^v16Q24Q32@?<v@?^vQ>40
@"<MTLDepthStencilState>"24@0:8@"MTLDepthStencilDescriptor"16
@"<MTLTexture>"40@0:8@"MTLTextureDescriptor"16^{__IOSurface=}24Q32
@"<MTLSamplerState>"24@0:8@"MTLSamplerDescriptor"16
@"<MTLLibrary>"16@0:8
@"<MTLLibrary>"32@0:8@"NSBundle"16^@24
@"<MTLLibrary>"32@0:8@"NSString"16^@24
@"<MTLLibrary>"32@0:8@"NSURL"16^@24
@"<MTLLibrary>"32@0:8@"NSObject<OS_dispatch_data>"16^@24
@"<MTLLibrary>"40@0:8@"NSString"16@"MTLCompileOptions"24^@32
v40@0:8@"NSString"16@"MTLCompileOptions"24@?<v@?@"<MTLLibrary>"@"NSError">32
@"<MTLRenderPipelineState>"32@0:8@"MTLRenderPipelineDescriptor"16^@24
@"<MTLRenderPipelineState>"48@0:8@"MTLRenderPipelineDescriptor"16Q24^@32^@40
v32@0:8@"MTLRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
v40@0:8@"MTLRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"32@0:8@"<MTLFunction>"16^@24
@"<MTLComputePipelineState>"48@0:8@"<MTLFunction>"16Q24^@32^@40
v32@0:8@"<MTLFunction>"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
v40@0:8@"<MTLFunction>"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLComputePipelineState>"48@0:8@"MTLComputePipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLComputePipelineDescriptor"16Q24@?<v@?@"<MTLComputePipelineState>"@"MTLComputePipelineReflection"@"NSError">32
@"<MTLFence>"16@0:8
@"<MTLRenderPipelineState>"48@0:8@"MTLTileRenderPipelineDescriptor"16Q24^@32^@40
v40@0:8@"MTLTileRenderPipelineDescriptor"16Q24@?<v@?@"<MTLRenderPipelineState>"@"MTLRenderPipelineReflection"@"NSError">32
@"<MTLArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLIndirectCommandBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLEvent>"16@0:8
@"<MTLSharedEvent>"16@0:8
@"<MTLSharedEvent>"24@0:8@"MTLSharedEventHandle"16
@"<MTLCounterSampleBuffer>"32@0:8@"MTLCounterSampleBufferDescriptor"16^@24
@"<MTLDynamicLibrary>"32@0:8@"<MTLLibrary>"16^@24
@"<MTLDynamicLibrary>"32@0:8@"NSURL"16^@24
@"<MTLBinaryArchive>"32@0:8@"MTLBinaryArchiveDescriptor"16^@24
{?=II}16@0:8
@20@0:8I16
B44@0:8^@16Q24^Q32i40
@40@0:8@16Q24^@32
B36@0:8@16B24^@28
r^{MTLTargetDeviceArch=QI*}16@0:8
r^{?=IIIIIIIIIIIIIIIIIIIIIIIIIIffIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQ}16@0:8
f16@0:8
{IndirectArgumentBufferCapabilities=b1b1b1b29}16@0:8
v24@0:8^{MPSFunctionTable=}16
v40@0:8Q16^Q24Q32
B32@0:8{_NSRange=QQ}16
B40@0:8^{?=III}16Q24Q32
@32@0:8^v16Q24
@40@0:8^v16@24Q32
@28@0:8@16I24
@48@0:8^v16Q24@32@?40
@28@0:8@16B24
@32@0:8r^@16Q24
v24@0:8@"<MTLDeviceSPI>"16
@"<MTLBuffer>"24@0:8^{__IOSurface=}16
B24@0:8@"NSString"16
@"<MTLCommandQueue>"24@0:8@"MTLCommandQueueDescriptor"16
@"_MTLIndirectArgumentBufferLayout"24@0:8@"MTLStructType"16
@"<MTLArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
@"<MTLBuffer>"40@0:8@"MTLIndirectCommandBufferDescriptor"16Q24Q32
@"<MTLIndirectRenderCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLIndirectComputeCommandEncoder>"24@0:8@"<MTLBuffer>"16
@"<MTLSharedEvent>"20@0:8I16
@"<MTLDynamicLibrary>"40@0:8@"<MTLLibrary>"16@"MTLComputePipelineDescriptor"24^@32
@"<MTLDynamicLibrary>"40@0:8@"NSURL"16Q24^@32
@"NSArray"32@0:8@"MTLComputePipelineDescriptor"16^@24
B36@0:8@"<MTLLibrary>"16B24^@28
@"<MTLBinaryArchive>"40@0:8Q16@"NSURL"24^@32
@"MTLTargetDeviceArchitecture"16@0:8
v24@0:8@"NSObject<OS_dispatch_data>"16
@"<MTLBuffer>"48@0:8r^v16Q24Q32Q40
@"<MTLBuffer>"56@0:8^v16Q24Q32Q40@?<v@?^vQ>48
@"<MTLComputePipelineState>"32@0:8@"MTLComputePipelineDescriptor"16^@24
v32@0:8@"MTLComputePipelineDescriptor"16@?<v@?@"<MTLComputePipelineState>"@"NSError">24
@"<MTLRenderPipelineState>"32@0:8@"MTLTileRenderPipelineDescriptor"16^@24
v32@0:8@"MTLTileRenderPipelineDescriptor"16@?<v@?@"<MTLRenderPipelineState>"@"NSError">24
@"<MTLFunction>"32@0:8^v16Q24
@"<MTLFunction>"40@0:8^v16@"NSObject<OS_dispatch_data>"24Q32
@"<MTLIndirectArgumentEncoder>"24@0:8@"NSArray"16
@"<MTLComputePipelineState>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLLibrary>"40@0:8@"NSString"16@"NSArray"24^@32
@"<MTLLibrary>"40@0:8@"NSArray"16r^{?=BQ^{?}}24^@32
@"<MTLPipelineLibrarySPI>"32@0:8@"NSString"16^@24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLRenderPipelineDescriptor"16
@"NSObject<OS_dispatch_data>"24@0:8@"MTLComputePipelineDescriptor"16
@"MTLRenderPipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"MTLComputePipelineDescriptor"32@0:8@"NSObject<OS_dispatch_data>"16@"<MTLDeserializationContext>"24
@"NSObject<OS_dispatch_data>"24@0:8@"MTLStructType"16
@"NSObject<OS_dispatch_data>"28@0:8@"MTLStructType"16I24
@"<MTLTexture>"48@0:8^v16Q24@"MTLTextureDescriptor"32@?<v@?^vQ>40
@"<MTLTextureLayout>"28@0:8@"MTLTextureDescriptor"16B24
@"<MTLIndirectArgumentEncoder>"24@0:8@"_MTLIndirectArgumentBufferLayout"16
@"<MTLResourceGroupSPI>"32@0:8r^@16Q24
v32@0:8@"NSObject<OS_dispatch_data>"16@"NSMutableDictionary"24
Q28@0:8Q16B24
@"<MTLDeviceSPI>"
v40@0:8@"MTLSharedEventListener"16Q24@?<v@?@"<MTLSharedEvent>"Q>32
@"MTLSharedEventHandle"16@0:8
@32@0:8Q16^@24
@"<MTLArgumentEncoder>"24@0:8Q16
@"<MTLArgumentEncoder>"32@0:8Q16^@24
@32@0:8Q16@24
v32@0:8Q16@?24
@40@0:8Q16^@24@32
@28@0:8@16C24
@"MTLFunctionReflection"24@0:8Q16
@"MTLFunctionReflection"32@0:8Q16@"<MTLPipelineLibrary>"24
@"MTLFunctionReflection"32@0:8Q16@"NSArray"24
v32@0:8Q16@?<v@?@"MTLFunctionReflection">24
@"<MTLArgumentEncoder>"32@0:8Q16@"<MTLPipelineLibrary>"24
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"<MTLPipelineLibrary>"32
@"<MTLArgumentEncoder>"40@0:8Q16^@24@"NSArray"32
@"<MTLFunction>"28@0:8@"NSData"16C24
@"MTLType"16@0:8
@"<MTLFunction>"24@0:8@"NSString"16
@"<MTLFunction>"40@0:8@"NSString"16@"MTLFunctionConstantValues"24^@32
v40@0:8@"NSString"16@"MTLFunctionConstantValues"24@?<v@?@"<MTLFunction>"@"NSError">32
v32@0:8@"MTLFunctionDescriptor"16@?<v@?@"<MTLFunction>"@"NSError">24
@"<MTLFunction>"32@0:8@"MTLFunctionDescriptor"16^@24
@48@0:8@16@24@32^@40
v48@0:8@16@24@32@?40
@"<MTLFunction>"48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32^@40
v48@0:8@"NSString"16@"MTLFunctionConstantValues"24@"<MTLPipelineLibrary>"32@?<v@?@"<MTLFunction>"@"NSError">40
@"NSString"
@"MTLCountersTraceComputeCommandEncoder"
@64@0:8@16@24@32@40@48Q56
@48@0:8@16@24@32@40
@"MTLRenderPipelineDescriptor"
@"MTLTileRenderPipelineDescriptor"
@"MTLRenderPipelineReflection"
{KeyBufferPair="key"{Key="hash"{?="key"[32C]}"data"@"NSData"}"buffer"@"<MTLBuffer>"}
@"MTLGPUDebugBuffer"
@"MTLToolsObject"
@"MTLToolsDevice"
@"<MTLRenderCommandEncoder>"16@0:8
v24@0:8@"<MTLRenderPipelineState>"16
v24@0:8@"<MTLDepthStencilState>"16
v64@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56
v56@0:8Q16Q24Q32@"<MTLBuffer>"40Q48
v80@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56q64Q72
v40@0:8Q16@"<MTLBuffer>"24Q32
v64@0:8Q16Q24@"<MTLBuffer>"32Q40@"<MTLBuffer>"48Q56
v32@0:8@"<MTLFence>"16Q24
v72@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64
v56@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48
v88@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80
v72@0:8Q16@"<MTLBuffer>"24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64
v40@0:8@"<MTLResource>"16Q24Q32
v32@0:8@"<MTLHeap>"16Q24
v40@0:8f16f20f24f28Q32
v44@0:8@16f24f28f32Q36
v28@0:8B16Q20
v24@0:8@?<v@?@"<MTLRenderCommandEncoderSPI>"Q>16
v48@0:8@"<MTLTexture>"16Q24@"<MTLSamplerState>"32Q40
v44@0:8@"<MTLSamplerState>"16f24f28f32Q36
v56@0:8@"<MTLTexture>"16Q24Q32Q40Q48
v60@0:8@"<MTLTexture>"16Q24Q32Q40B48Q52
v48@0:8@"<MTLTexture>"16Q24Q32Q40
v52@0:8@"<MTLTexture>"16Q24Q32Q40B48
v60@0:8@16Q24Q32Q40Q48B56
@40@0:8@16Q24@32
@32@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16Q24
{_NSRange=QQ}16@0:8
^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}
{_NSRange="location"Q"length"Q}
@24@0:8^{BinaryBuffer=^^?{StreamBuffer=***}{mach_timebase_info=II}}16
v108@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80B88@92Q100
v88@0:8@16{?={?=QQQ}{?=QQQ}}24Q72Q80
v80@0:8Q16Q24Q32@40Q48Q56Q64Q72
@20@0:8B16
v32@0:8r^v16Q24
v40@0:8r^v16@24@32
{BinaryBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}"_timebase"{mach_timebase_info="numer"I"denom"I}}
{AppendBuffer="_vptr$AppendBuffer"^^?"stream"{StreamBuffer="bytes"*"pWrite"*"pEnd"*}}
B32@0:8r^@16Q24
B24@0:8@"<MTLResource>"16
@"MTLToolsHeap"
v112@0:8Q16Q24Q32@40Q48@56Q64Q72Q80@88Q96Q104
v104@0:8^v16Q24Q32{?={?=QQQ}{?=QQQ}}40Q88Q96
v104@0:8{?={?=QQQ}{?=QQQ}}16Q64Q72r^v80Q88Q96
v88@0:8^v16Q24{?={?=QQQ}{?=QQQ}}32Q80
v88@0:8{?={?=QQQ}{?=QQQ}}16Q64r^v72Q80
@64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
{?=CCCC}16@0:8
@"<MTLTexture>"24@0:8Q16
@"<MTLTexture>"64@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48
@"<MTLTexture>"68@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64
@"<MTLResource>"16@0:8
@"<MTLTexture>"16@0:8
@"<MTLBuffer>"16@0:8
@48@0:8Q16Q24Q32Q40
@72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
@"<MTLTexture>"48@0:8Q16Q24Q32Q40
@"<MTLTexture>"32@0:8Q16Q24
@"<MTLTexture>"72@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48Q64
@"<MTLTexture>"76@0:8Q16Q24{_NSRange=QQ}32{_NSRange=QQ}48{?=CCCC}64Q68
v104@0:8Q16Q24{?=QQQ}32{?=QQQ}56^v80Q88Q96
v104@0:8r^v16Q24Q32Q40Q48{?=QQQ}56{?=QQQ}80
@"<MTLTexture>"
@"<MTLBuffer>"
v120@0:8r^v16Q24Q32Q40^v48Q56Q64{?={?=QQQ}{?=QQQ}}72
v120@0:8r^v16Q24Q32{?={?=QQQ}{?=QQQ}}40^v88Q96Q104Q112
v24@0:8^v16
{?=[2Q]}16@0:8
@"MTLRenderPassDescriptor"
@"<MTLFunction>"16@0:8
@"<MTLFunctionLogDebugLocation>"16@0:8
@56@0:8Q16@24@32@40@48
@"<MTLFunctionLogDebugLocation>"
@"NSArray"
@88@0:8Q16@24@32Q40@48Q56Q64@72@80
@"MTLArgument"
@56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
@"<MTLBuffer>"56@0:8r^@16r^Q24{_NSRange=QQ}32^Q48
{pair<id<MTLBuffer>, unsigned long>=@Q}24@0:8Q16
@32@0:8r^v16Q24
{ReportBufferEntry=Q@Q}24@0:8Q16
@"<MTLArgumentEncoder>"
{vector<MetalBuffer, std::__1::allocator<MetalBuffer>>="__begin_"^{MetalBuffer}"__end_"^{MetalBuffer}"__end_cap_"{__compressed_pair<MetalBuffer *, std::__1::allocator<MetalBuffer>>="__value_"^{MetalBuffer}}}
{MetalBuffer="heap"^{MetalBufferHeap}"index"I}
{vector<id<MTLBuffer>, std::__1::allocator<id<MTLBuffer>>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<id<MTLBuffer> *, std::__1::allocator<id<MTLBuffer>>>="__value_"^@}}
{vector<ReportBufferEntry, std::__1::allocator<ReportBufferEntry>>="__begin_"^{ReportBufferEntry}"__end_"^{ReportBufferEntry}"__end_cap_"{__compressed_pair<ReportBufferEntry *, std::__1::allocator<ReportBufferEntry>>="__value_"^{ReportBufferEntry}}}
{vector<NSString *, std::__1::allocator<NSString *>>="__begin_"^@"__end_"^@"__end_cap_"{__compressed_pair<NSString **, std::__1::allocator<NSString *>>="__value_"^@}}
{mutex="__m_"{_opaque_pthread_mutex_t="__sig"q"__opaque"[56c]}}
v148@0:8@16Q24Q32{?=QQQ}40{?=QQQ}64@88Q96Q104{?=QQQ}112Q136B144
v112@0:8@16Q24Q32{?=QQQ}40@64Q72Q80Q88Q96Q104
{deque<id, std::__1::allocator<id>>="__map_"{__split_buffer<id *, std::__1::allocator<id *>>="__first_"^^@"__begin_"^^@"__end_"^^@"__end_cap_"{__compressed_pair<id **, std::__1::allocator<id *>>="__value_"^^@}}"__start_"Q"__size_"{__compressed_pair<unsigned long, std::__1::allocator<id>>="__value_"Q}}
@"MTLDebugCommandBuffer"
@40@0:8@16@24Q32
@48@0:8@16@24@32Q40
@48@0:8@16@24r^v32Q40
r^v16@0:8
@"MTLDebugResource"
@"MTLDebugDevice"
{atomic<int>="__a_"{__cxx_atomic_impl<int, std::__1::__cxx_atomic_base_impl<int>>="__a_value"Ai}}
v32@0:8@16B24B28
v28@0:8@16B24
B32@0:8@16^B24
@"_MTLCommandEncoder"
{unordered_multiset<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::__1::allocator<AttachmentDescriptorSimple>>="__table_"{__hash_table<AttachmentDescriptorSimple, AttachmentDescriptorSimple::hash_t, AttachmentDescriptorSimple::equal_t, std::__1::allocator<AttachmentDescriptorSimple>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *>, std::__1::allocator<std::__1::__hash_node<AttachmentDescriptorSimple, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<AttachmentDescriptorSimple, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, AttachmentDescriptorSimple::hash_t>="__value_"Q}"__p3_"{__compressed_pair<float, AttachmentDescriptorSimple::equal_t>="__value_"f}}}
{array<AttachmentDescriptorSimple, 8>="__elems_"[8{AttachmentDescriptorSimple="texture"^v"level"Q"sliceRange"{_NSRange="location"Q"length"Q}"depthPlaneRange"{_NSRange="location"Q"length"Q}"storeAction"Q}]}
{unordered_set<id<MTLDebugResourcePurgeable>, std::__1::hash<id<MTLDebugResourcePurgeable>>, std::__1::equal_to<id<MTLDebugResourcePurgeable>>, std::__1::allocator<id<MTLDebugResourcePurgeable>>>="__table_"{__hash_table<id<MTLDebugResourcePurgeable>, std::__1::hash<id<MTLDebugResourcePurgeable>>, std::__1::equal_to<id<MTLDebugResourcePurgeable>>, std::__1::allocator<id<MTLDebugResourcePurgeable>>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>, std::__1::allocator<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<id<MTLDebugResourcePurgeable>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::hash<id<MTLDebugResourcePurgeable>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::equal_to<id<MTLDebugResourcePurgeable>>>="__value_"f}}}
{unordered_set<MTLToolsObject *, std::__1::hash<MTLToolsObject *>, std::__1::equal_to<MTLToolsObject *>, std::__1::allocator<MTLToolsObject *>>="__table_"{__hash_table<MTLToolsObject *, std::__1::hash<MTLToolsObject *>, std::__1::equal_to<MTLToolsObject *>, std::__1::allocator<MTLToolsObject *>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *>, std::__1::allocator<std::__1::__hash_node<MTLToolsObject *, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<MTLToolsObject *, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::hash<MTLToolsObject *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::equal_to<MTLToolsObject *>>="__value_"f}}}
v96@0:8Q16Q24Q32@40Q48Q56Q64@72Q80Q88
v96@0:8Q16Q24Q32@"<MTLBuffer>"40Q48Q56Q64@"<MTLBuffer>"72Q80Q88
v112@0:8Q16Q24Q32@"<MTLBuffer>"40Q48@"<MTLBuffer>"56Q64Q72Q80@"<MTLBuffer>"88Q96Q104
@"_MTLIndirectDrawArguments"16@0:8
@"_MTLIndirectDrawIndexedArguments"16@0:8
@"_MTLIndirectDrawPatchesArguments"16@0:8
@"_MTLIndirectDrawIndexedPatchesArguments"16@0:8
@"_MTLIndirectTessellationFactorArguments"16@0:8
@"MTLCounterSampleBufferDescriptor"
@40@0:8@16r^{GPUDebugArgumentEncoderLayout=@{unordered_map<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>, std::__1::hash<unsigned int>, std::__1::equal_to<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>>>={__hash_table<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::__unordered_map_hasher<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::hash<unsigned int>, true>, std::__1::__unordered_map_equal<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::equal_to<unsigned int>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>>>={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>>={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>>=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *>>>={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::hash<unsigned int>, true>>=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::equal_to<unsigned int>, true>>=f}}}}24@32
r^{GPUDebugArgumentEncoderLayout=@{unordered_map<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>, std::__1::hash<unsigned int>, std::__1::equal_to<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>>>={__hash_table<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::__unordered_map_hasher<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::hash<unsigned int>, true>, std::__1::__unordered_map_equal<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::equal_to<unsigned int>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>>>={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>>={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>>=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *>>>={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::hash<unsigned int>, true>>=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::equal_to<unsigned int>, true>>=f}}}}
@56@0:8@16@24@32@40@48
@"MTLComputePipelineDescriptor"
@"MTLComputePipelineReflection"
[31{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[96{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
[16{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
{?="width"Q"height"Q"depth"Q}
{?="origin"{?="x"Q"y"Q"z"Q}"size"{?="width"Q"height"Q"depth"Q}}
@"<MTLComputePipelineState>"
[3Q]
@56@0:8@16@24@32Q40Q48
@"<MTLIndirectCommandBuffer>"
@"<MTLComputePipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"<MTLRenderPipelineState>"48@0:8@"NSString"16Q24^@32^@40
@"MTLComputePipelineDescriptor"32@0:8@"NSString"16^@24
@"MTLRenderPipelineDescriptor"32@0:8@"NSString"16^@24
@"<MTLPipelineCache>"16@0:8
v32@0:8@"<MTLRenderPipelineState>"16Q24
v32@0:8@"<MTLComputePipelineState>"16Q24
v32@0:8@"<MTLIndirectCommandBuffer>"16Q24
v32@0:8@"<MTLFunctionPointerHandleSPI>"16Q24
@"_MTLIndirectArgumentBufferLayout"16@0:8
^{StructType={vector<MemberRef, std::__1::allocator<MemberRef>>=^{MemberRef}^{MemberRef}{__compressed_pair<MemberRef *, std::__1::allocator<MemberRef>>=^{MemberRef}}}}
v32@0:8@16^{_MTLMessageContext=q*I@q@*}24
v40@0:8Q16B24B28^{_MTLMessageContext=q*I@q@*}32
v40@0:8Q16Q24^{_MTLMessageContext=q*I@q@*}32
v40@0:8@16Q24^f32
{MTLSamplerDescriptorHashMap="_map"{unordered_map<std::__1::array<unsigned long long, 3>, unsigned int, MTLSamplerDescriptorHashMap::hash_t, MTLSamplerDescriptorHashMap::equal_t, std::__1::allocator<std::__1::pair<const std::__1::array<unsigned long long, 3>, unsigned int>>>="__table_"{__hash_table<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, std::__1::__unordered_map_hasher<std::__1::array<unsigned long long, 3>, std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, true>, std::__1::__unordered_map_equal<std::__1::array<unsigned long long, 3>, std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::array<unsigned long long, 3>, std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::hash_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<std::__1::array<unsigned long long, 3>, std::__1::__hash_value_type<std::__1::array<unsigned long long, 3>, unsigned int>, MTLSamplerDescriptorHashMap::equal_t, true>>="__value_"f}}}"_limit"I}
{unordered_set<MTLDebugCommandBuffer *, std::__1::hash<MTLDebugCommandBuffer *>, std::__1::equal_to<MTLDebugCommandBuffer *>, std::__1::allocator<MTLDebugCommandBuffer *>>="__table_"{__hash_table<MTLDebugCommandBuffer *, std::__1::hash<MTLDebugCommandBuffer *>, std::__1::equal_to<MTLDebugCommandBuffer *>, std::__1::allocator<MTLDebugCommandBuffer *>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *>, std::__1::allocator<std::__1::__hash_node<MTLDebugCommandBuffer *, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<MTLDebugCommandBuffer *, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::hash<MTLDebugCommandBuffer *>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::equal_to<MTLDebugCommandBuffer *>>="__value_"f}}}
{CheckerboardRenderTargetPipelineCache="_cacheLock"{os_unfair_lock_s="_os_unfair_lock_opaque"I}"_library"@"<MTLLibrary>""_vertexFunction"@"<MTLFunction>""_depthStencilState"[2@"<MTLDepthStencilState>"]"_fConstants"@"MTLFunctionConstantValues""_cache"{unordered_map<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>, MTLDebugCheckerboardFillHashKey::Hash, std::__1::equal_to<MTLDebugCheckerboardFillHashKey>, std::__1::allocator<std::__1::pair<const MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__table_"{__hash_table<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::__1::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, true>, std::__1::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::__1::equal_to<MTLDebugCheckerboardFillHashKey>, true>, std::__1::allocator<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<MTLDebugCheckerboardFillHashKey, std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, MTLDebugCheckerboardFillHashKey::Hash, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<MTLDebugCheckerboardFillHashKey, std::__1::__hash_value_type<MTLDebugCheckerboardFillHashKey, id<MTLRenderPipelineState>>, std::__1::equal_to<MTLDebugCheckerboardFillHashKey>, true>>="__value_"f}}}}
C16@0:8
@"MTLDepthStencilDescriptor"
@56@0:8@16@24Q32Q40@48
@"MTLFunctionConstantValues"
@56@0:8@16@24Q32@40@48
v32@0:8@16#24
v32@0:8@16r^{?=BQ^{?}}24
^{?=BQ^{?}}16@0:8
@"MTLCompileOptions"
^{?=BQ^{?}}
{atomic<unsigned long long>="__a_"{__cxx_atomic_impl<unsigned long long, std::__1::__cxx_atomic_base_impl<unsigned long long>>="__a_value"AQ}}
@32@0:8r^{MTLRenderPassAttachmentDescriptorPrivate=@QQQQQQ{?=dddd}dIQ@QQQQQQB}16Q24
Q24@0:8@16
^{vector<MTLViewport, std::__1::allocator<MTLViewport>>=^{?}^{?}{__compressed_pair<MTLViewport *, std::__1::allocator<MTLViewport>>=^{?}}}16@0:8
^{vector<MTLScissorRect, std::__1::allocator<MTLScissorRect>>=^{?}^{?}{__compressed_pair<MTLScissorRect *, std::__1::allocator<MTLScissorRect>>=^{?}}}16@0:8
{?=dddddd}16@0:8
{?=QQQQ}16@0:8
v56@0:8Q16Q24Q32Q40r*48
v72@0:8Q16Q24Q32@40Q48Q56r*64
{?=BBQ@QQQQQBff}16@0:8
^{?=QQ}
[10{?="pixelFormat"Q"sampleCount"Q}]
[36{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}]
^{set<unsigned int, std::__1::less<unsigned int>, std::__1::allocator<unsigned int>>={__tree<unsigned int, std::__1::less<unsigned int>, std::__1::allocator<unsigned int>>=^{__tree_end_node<std::__1::__tree_node_base<void *> *>}{__compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<unsigned int, void *>>>={__tree_end_node<std::__1::__tree_node_base<void *> *>=^{__tree_node_base<void *>}}}{__compressed_pair<unsigned long, std::__1::less<unsigned int>>=Q}}}
{vector<MTLViewport, std::__1::allocator<MTLViewport>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLViewport *, std::__1::allocator<MTLViewport>>="__value_"^{?}}}
{vector<MTLScissorRect, std::__1::allocator<MTLScissorRect>>="__begin_"^{?}"__end_"^{?}"__end_cap_"{__compressed_pair<MTLScissorRect *, std::__1::allocator<MTLScissorRect>>="__value_"^{?}}}
{?="isValid"B"hasBeenUsed"B"type"Q"object"@"baseLevel"Q"bufferLength"Q"bufferOffset"Q"threadgroupMemoryLength"Q"threadgroupMemoryOffset"Q"hasLodClamp"B"lodMinClamp"f"lodMaxClamp"f}
@"MTLCountersTraceCommandBuffer"
@36@0:8@16@24I32
@"MTLDebugHeap"
{MTLGPUDebugThreadgroupLengths="threadgroupSizes"[31I]"entries"[32{GPUDebugThreadgroupTableEntry="offset"I"length"I}]"needsFlush"B}
@"MTLGPUDebugComputePipelineState"
@48@0:8Q16^@24@32@40
{unordered_map<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>, std::__1::hash<unsigned int>, std::__1::equal_to<unsigned int>, std::__1::allocator<std::__1::pair<const unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>>>="__table_"{__hash_table<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::__unordered_map_hasher<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::hash<unsigned int>, true>, std::__1::__unordered_map_equal<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::equal_to<unsigned int>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::hash<unsigned int>, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<unsigned int, std::__1::__hash_value_type<unsigned int, std::__1::unique_ptr<GPUDebugArgumentEncoderLayout, std::__1::default_delete<GPUDebugArgumentEncoderLayout>>>, std::__1::equal_to<unsigned int>, true>>="__value_"f}}}
[8Q]
[31{?="bufferIndex"Q"bufferStride"Q}]
@"MTLSamplerDescriptor"
v32@0:8Q16B24B28
v40@0:8Q16{?=QQ}24
@64@0:8@16@24@32Q40Q48Q56
@88@0:8@16@24@32Q40Q48{_NSRange=QQ}56{_NSRange=QQ}72
v40@0:8Q16{_NSRange=QQ}24
{unordered_map<SubView, unsigned long, SubView::hash_t, SubView::equal_t, std::__1::allocator<std::__1::pair<const SubView, unsigned long>>>={__hash_table<std::__1::__hash_value_type<SubView, unsigned long>, std::__1::__unordered_map_hasher<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::hash_t, true>, std::__1::__unordered_map_equal<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::equal_t, true>, std::__1::allocator<std::__1::__hash_value_type<SubView, unsigned long>>>={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>>={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>>=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *>>>={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::hash_t, true>>=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::equal_t, true>>=f}}}16@0:8
v56@0:8{unordered_map<SubView, unsigned long, SubView::hash_t, SubView::equal_t, std::__1::allocator<std::__1::pair<const SubView, unsigned long>>>={__hash_table<std::__1::__hash_value_type<SubView, unsigned long>, std::__1::__unordered_map_hasher<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::hash_t, true>, std::__1::__unordered_map_equal<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::equal_t, true>, std::__1::allocator<std::__1::__hash_value_type<SubView, unsigned long>>>={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>>={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>>=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>=Q}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *>>>={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::hash_t, true>>=Q}{__compressed_pair<float, std::__1::__unordered_map_equal<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::equal_t, true>>=f}}}16
{MTLPixelFormatInfo="name"*"flags"I"castClass"Q"type"(?="normal"{MTLNormalPixelFormatInfo="pixelBytes"Q"componentCount"C"alignment"C"pixelBytesRender"Q"pixelBytesRenderMSAA"Q}"compressed"{MTLCompressedPixelFormatInfo="blockBytes"Q"blockWidth"Q"blockHeight"Q"blockDepth"Q})}
{unordered_map<SubView, unsigned long, SubView::hash_t, SubView::equal_t, std::__1::allocator<std::__1::pair<const SubView, unsigned long>>>="__table_"{__hash_table<std::__1::__hash_value_type<SubView, unsigned long>, std::__1::__unordered_map_hasher<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::hash_t, true>, std::__1::__unordered_map_equal<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::equal_t, true>, std::__1::allocator<std::__1::__hash_value_type<SubView, unsigned long>>>="__bucket_list_"{unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__ptr_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>>="__value_"^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>}"__value_"{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__data_"{__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *> *>>="__value_"Q}}}}"__p1_"{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *>>>="__value_"{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>="__next_"^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<SubView, unsigned long>, void *> *>}}}"__p2_"{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::hash_t, true>>="__value_"Q}"__p3_"{__compressed_pair<float, std::__1::__unordered_map_equal<SubView, std::__1::__hash_value_type<SubView, unsigned long>, SubView::equal_t, true>>="__value_"f}}}
@"MTLTextureDescriptor"
@"MTLCountersTraceBlitCommandEncoder"
