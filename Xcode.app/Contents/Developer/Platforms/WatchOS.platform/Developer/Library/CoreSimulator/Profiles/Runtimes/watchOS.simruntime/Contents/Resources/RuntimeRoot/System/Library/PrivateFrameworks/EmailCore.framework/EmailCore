numberWithUnsignedLong:
stringWithUTF8String:
currentHandler
localizedNameOfStringEncoding:
handleFailureInFunction:file:lineNumber:description:
init
copy
handleFailureInMethod:object:file:lineNumber:description:
headerData
length
_encodedWordStartSequence
rangeOfData:options:range:
_lineSeparator
_encodedWordDelimiter
_encodedWordEndSequence
getBytes:range:
setEncodedWordEncoding:
setStringEncoding:
setLanguage:
setEncodedTextRange:
_encodedWordLanguageDelimiter
subdataWithRange:
alloc
initWithData:encoding:
initWithBytes:length:
encodedWordEncoding
encodedTextRange
_decodeBEncodedTextToData:
_decodeQEncodedTextToData:
initWithBase64EncodedData:options:
appendData:
_enumerateQByteRangesUsingBlock:
increaseLengthBy:
mutableBytes
bytes
initWithHeaderData:
identifyRangeOfEncodedWordAtIndex:
decodeEncodedTextToData:
.cxx_destruct
stringEncoding
language
_stringEncoding
_language
_headerData
_encodedWordEncoding
_encodedTextRange
canBeConvertedToEncoding:
string
description
class
stringWithFormat:
_prepareForEncoding
singleEncodedWordLength
lengthOfBytesUsingEncoding:
dataUsingEncoding:
_lengthOfQEncodedTextForBytes:length:
setCharacterSet:
setDecodedText:
setSingleEncodedWordLength:
_bEncodeToHeaderData:currentLineLength:
_qEncodeToHeaderData:currentLineLength:
characterSet
getBytes:maxLength:usedLength:encoding:options:range:remainingRange:
_writeEncodedWordPreambleToBuffer:length:
decodedText
base64EncodedDataWithOptions:
getBytes:length:
initWithCapacity:
setLength:
_writeQEncodedTextAndEndSequenceToHeaderBytes:fromDecodedBytes:length:
_getBytesWithoutSplittingComposedCharacters:targetQEncodedTextLength:usedLength:splitComposedCharacterSequence:usedQEncodedTextLength:extraLength:extraQEncodedTextLength:fromString:stringEncoding:range:remainingRange:
enumerateSubstringsInRange:options:usingBlock:
_findNextByteThatNeedsQEncodingBetweenStartByte:endByte:
initWithString:stringEncoding:language:
minimumLengthOfEncodedWord
encodeToHeaderData:currentLineLength:
_string
_characterSet
_decodedText
_singleEncodedWordLength
rangeOfComposedCharacterSequenceAtIndex:
KS_C_5601-1987
GB2312
ISO-8859-6-i
ISO-8859-8-i
NSString * _Nonnull ECConvertEncodingToCharacterSetName(NSStringEncoding)
<Unknown Function>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/Email_Sim/Email-3445.4.4/EmailCore/MIME/ECCharacterSet.m
<Unknown File>
No character set name for string encoding %@ (%lu)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/Email_Sim/Email-3445.4.4/EmailCore/MIME/ECEncodedWord.m
Invalid initializer called, returning nil
Invalid parameter not satisfying: %@
index < headerLength
v4@?0
v16@?0r*4L8i12
headerData
T@"NSData",R,C,N,V_headerData
stringEncoding
T@"NSNumber",&,N,V_stringEncoding
language
T@"NSString",C,N,V_language
encodedWordEncoding
Ti,N,V_encodedWordEncoding
encodedTextRange
T{_NSRange=II},N,V_encodedTextRange
string.length
[string canBeConvertedToEncoding:stringEncoding]
%@ %lu (%@*%@) <%@: %p>
Character set %@ is not encodable in ASCII
Language %@ is not encodable in ASCII
Impossible to make an encoded-word with character set "%@" and language "%@"
Could not determine encoded-word encoding
Failed to get bytes from string
Can't make encoded-word without splitting a composed character sequence
v28@?0@"NSString"4{_NSRange=II}8{_NSRange=II}16^B24
TI,R,N,V_stringEncoding
T@"NSString",R,C,N,V_language
string
T@"NSString",R,C,N,V_string
characterSet
T@"NSString",C,N,V_characterSet
decodedText
T@"NSData",C,N,V_decodedText
singleEncodedWordLength
TI,N,V_singleEncodedWordLength
minimumLengthOfEncodedWord
TI,R,N
BOOL getBytesFromStringWithoutSplittingComposedCharacters(NSString * _Nonnull __strong, void * _Nonnull, NSUInteger, NSUInteger * _Nonnull, NSStringEncoding, NSRange, NSRangePointer _Nonnull, BOOL * _Nonnull)
?=?*
0123456789ABCDEF@(#)PROGRAM:EmailCore  PROJECT:Email-3445.4.4
ECEncodedWordDecoder
ECEncodedWordEncoder
@12@0:4@8
@8@0:4
{_NSRange=II}12@0:4I8
B12@0:4@8
v12@0:4@?8
v8@0:4
v12@0:4@8
i8@0:4
v12@0:4i8
{_NSRange=II}8@0:4
v16@0:4{_NSRange=II}8
@"NSNumber"
@"NSString"
@"NSData"
{_NSRange="location"I"length"I}
@20@0:4@8I12@16
I8@0:4
I16@0:4@8I12
I16@0:4*8I12
B56@0:4^v8I12^I16^B20^I24^I28^I32@36I40{_NSRange=II}44^{_NSRange=II}52
I16@0:4r*8I12
v20@0:4*8r*12I16
r*16@0:4r*8r*12
v12@0:4I8
zPLR
