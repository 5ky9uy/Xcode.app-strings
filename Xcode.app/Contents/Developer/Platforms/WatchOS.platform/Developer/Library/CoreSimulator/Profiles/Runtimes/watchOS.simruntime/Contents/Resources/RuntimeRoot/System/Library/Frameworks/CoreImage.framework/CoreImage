:D7V
"nN%
AA)Z
>Y1\
?*Ral!
WXp?
>J6h
iQ~V?
iN^d
iN^d
N} y
?9(a
g|_\
&4I,)
|F"4
_Cp\
vj.7
ip[[
'Hlw
?VF#
uoEb
?\='
@ut\
?'/2
h?RD
"nN%
t><K
!sePmp
|zlK
c\qq
0Xr
9x&4
^Cp\
`!sePm
?aobHN
.5B?S
i3NCT
"nN%
|a2U0
%Tpx
"nN%
~NA~
lscz
AA)Z
r?jl@
<e5]O
! _B
?`vO
^Cp\F
@Y32
d:tz
N} y
?Uka
SrNl
-:Yj
tBFe@
@!"5
O7+]3n@
h8en
;a@O
?!=E
"LQ.
OVW
"nN%
0Xr
W zR&
/5B?S
|a2U0*
?EUwv
E|'f
i3NCT
1zn!
"nN%
#gaO;|
[@h=|
2uWv
 |(
?K[\
p}?33S?
L>333?
?ffffff
|?5^
@ffffff
vH7B
W4vC
9Y>)F$
MbP?-C
]r2<
 9^;Q
Dfff?
es-8R
es-8R
MbP?
?333333
?333333
$@M-[
N@\r
++MJ
?|'f
i@r3
 l@a
pw@L7
 |@)?
@gDio
?33333S7
333333
?ffffff
?ffffff
?333333
800L80AL
RGBAABGRARGB
AhGRAfGR8Iic80C2f024v024800A80C1
r46l610L61AL6Ric61C2h00Ah00Lh0ALh0C1h0C2yuv2svuyhIic6Iic610Af00Af00LfIicf0C1f0ALf0C284ic
h3icf3ic
r46lfuv2fvuy01icr01cr03w
800L80AL
RGBAABGRARGB 
RGBAABGRARGBAhGRAfGR8Iic80C2f024v024800A80C1ARGBARGBARGBARGBf024f024v024v024r46l610L61AL6Ric61C2h00Ah00Lh0ALh0C1h0C2yuv2svuyhIic6Iic610Af00Af00LfIicf0C1f0ALf0C284icr46lAfGRr46lr46lh3icf3ic
r46lfuv2fvuy01icr01cr03w
333333
?333333
Mb@?
$@M-[
N@\r
++MJ
?|'f
i@r3
 l@a
pw@L7
 |@)?
@gDio
?33333S7
Ww'&l
333333
ffffff
?333333
?333333
:gUU
?333333
?333333
?333333
@?a2U0*
333333
?333333
?333333
?333333
?333333
?333333
?333333
?Zd;
9@UUUUUU
P?333333
@UUUUUU
i?yCu
JQ/#
?333333
?~0d>
(knN 
 A)\
$@ffffff
>B`e=
~%<(
?es-8R
es-8R
?333?fff?fff?
eUB
m#39
?eUB
;gM$
?[+5
.z<g
`*h 
Kfie
?cc^G
?cWb
x/k 
7:Ba
:ua;
lErd
m|X5
tZ;z
APPL
mntrRGB XYZ 
acspAPPL
APPLsRGB
-APPL
desc
icprt
"wtpt
rXYZ
gXYZ
bXYZ
rTRC
bTRC
gTRC
desc
sRGB Linear
text
Copyright 2012 Apple Inc.
XYZ 
XYZ 
XYZ 
XYZ 
curv
pappl
mntrGRAYXYZ 
acspAPPL
none
-appl
desc
qcprt
#wtpt
kTRC
desc
Linear Gray Profile
text
Copyright Apple Inc., 2017
XYZ 
curv
ffffff
?yCu
333333
?es-8R
0123456789&
,:#-.$/+%*=^
?UUUUUU
?UUUUUU
@\^_`|~
!"#$%&'()*+,-./:;<=>?[]{}
UUUUUU
?UUUUUU
?59$5r:
?59$5r:
0Xr
?g|_\
ADBE
mntrRGB XYZ 
;acspAPPL
none
-ADBE
cprt
2desc
kwtpt
bkpt
rTRC
gTRC
bTRC
rXYZ
gXYZ
bXYZ
text
Copyright 2000 Adobe Systems Incorporated
desc
Adobe RGB (1998)
XYZ 
XYZ 
curv
XYZ 
XYZ 
XYZ 
?ff&?ff&
6@ff&
?ff&
init
setSvmParameters:
svmParameters
computeKernelValueWithSupportVector:
scaleVector
predictResult
initWithVersion:
isBurstAction
testAverageCameraTravelDistance
setTestAverageCameraTravelDistance:
testMaxRegistrationErrorIntegral
setTestMaxRegistrationErrorIntegral:
testMaxPeakRegistrationError
setTestMaxPeakRegistrationError:
testMeanPeakRegistrationError
setTestMeanPeakRegistrationError:
testBeginningVsEndAEMatrixVsAverageAdjacentAEMatrix
setTestBeginningVsEndAEMatrixVsAverageAdjacentAEMatrix:
testInOutRatio
setTestInOutRatio:
testMaxInnerDistance
setTestMaxInnerDistance:
testAverageRegistrationErrorSkewness
setTestAverageRegistrationErrorSkewness:
testMinRegionOfInterestSize
setTestMinRegionOfInterestSize:
testMaxRegistrationErrorSkewness
setTestMaxRegistrationErrorSkewness:
hasBeenScaled
testVector
_svmParameters
standardUserDefaults
persistentDomainForName:
objectForKey:
intValue
defaultManager
stringByAppendingPathComponent:
burstId
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
arrayWithCapacity:
retain
defaultVersionString
setVersionString:
isEqualToString:
versionString
setVersion:
alloc
setWithCapacity:
version
dictionaryWithCapacity:
stringWithCString:encoding:
setBurstId:
setForceFaceDetectionEnable:
UTF8String
initWithCGImage:maxDimension:
dictionaryWithDictionary:
setDateFormat:
date
stringFromDate:
release
burstDocumentDirectory
fileExistsAtPath:
count
objectAtIndex:
releaseImage
dealloc
countByEnumeratingWithState:objects:count:
burstImages
isGarbage
registrationErrorIntegral
imageId
timestamp
latestFaceTimestamp
imageProps
numberWithDouble:
setObject:forKey:
image
width
height
addFacesToImageStat:imageSize:
faceStatArray
faceId
numberWithInt:
normalizedFaceRect
numberWithFloat:
hasRollAngle
rollAngle
hasYawAngle
yawAngle
hasLeftEye
leftEyeRect
leftEyeBlinkScore
hasRightEye
rightEyeRect
rightEyeBlinkScore
smileScore
addObject:
findFacesInImage:imageStat:
setTimeFaceDetectionDone:
setTimeBlinkDetectionDone:
timeFaceDetectionDone
timeBlinkDetectionDone
calculateFaceFocusInImage:imageStat:
adjustFaceIdsForImageStat:
dumpFaceInfoArray
computeImageData:faceIDCounts:
focusScore
leftEyeOpen
numberWithBool:
rightEyeOpen
smiling
smallFace
FCRLeftEyeFeaturesOffset
FCRRightEyeFeaturesOffset
FCRSmileFeaturesOffset
FCRBlinkFeaturesSize
FCRSmileFeaturesSize
stringWithFormat:
Ybuffer
bytesPerRow
dataWithBytes:length:
Cbuffer
dictionaryWithObjectsAndKeys:
writeToFile:atomically:
facesRoiRect
AEAverage
AETarget
AEStable
AFStable
orientation
aeMatrix
completionBlock
extractFacesFromMetadata:
initWithImageData:dict:identifier:imageProps:completionBlock:
setTemporalOrder:
doubleValue
setTimeReceived:
processClusters:
setSmiling:
normalizedFocusScore
computeEmotion:
temporalOrder
setEmotionallyRejected:
avgHorzDiffY
blurExtent
setImageScore:
setActionScore:
computeAEMatrixDifference:
canRegister
allocateMeanStdPingPongBuffers::::
assignMeanStdBuffers:
performRegistration:deltaCol:deltaRow:
maxSkewness
setMaxSkewness:
setTx:
setTy:
computeSmoothedGridROI:nextStat:
doLimitedSharpnessAndBlur
hasRegistrationData
countForObject:
removeObject:
collapseSharpnessGrid
setIsGarbage:
flagAsGarbage
roiSize
registrationErrorX
registrationErrorY
computeCameraTravelDistance
computeBeginningVsEndAEMatrixDiffVsAverageAdjacent
computeActionSelectionThreshold
computeScore:
writeGridROI:
actionScore
imageScore
lastObject
stringWithString:
calcFaceScores:
computeAllImageScores
faceRect
performEmotionalRejectionOnCluster:
findBestImage:useActionScores:
emotionallyRejected
selectCoverPhotoFromMultiple:burstSize:
addItemsFromCluster:
removeObjectAtIndex:
setBestImageIdentifiersArray:
forceFaceDetectionEnable
bestImageIdentifiersArray
bestImageIdentifiers
initWithOptions:
addYUVImage:properties:identifier:imageProps:completionBlock:
imageClusterForIdentifier:
isFaceDetectionForced
isPortrait
isAction
clusterArray
setClusterArray:
faceIDCounts
setFaceIDCounts:
allImageIdentifiers
setAllImageIdentifiers:
actionClassifier
setActionClassifier:
statsByImageIdentifier
setStatsByImageIdentifier:
clusterByImageIdentifier
setClusterByImageIdentifier:
burstLogFileName
setBurstLogFileName:
maxNumPendingFrames
setMaxNumPendingFrames:
enableAnalysis
setEnableAnalysis:
dummyAnalysisCount
setDummyAnalysisCount:
enableFaceCore
setEnableFaceCore:
enableDumpYUV
setEnableDumpYUV:
burstCoverSelection
setBurstCoverSelection:
dq_yuvdump
faceAnalysisContext
overrideImage
overrideProps
burstLogFileHandle
curClusterIndexToProcess
_versionString
_version
computeImageDistance:
numHWFaces
setDividerScore:
setLeftImage:
actionClusteringScore
setActionAmount:
dividerScore
setNoiseThreshold:
setHighNoiseThreshold:
leftImage
noiseThreshold
highNoiseThreshold
setTrueLocalMaximum:
compareDividers:
sortedArrayUsingSelector:
compareIndices:
addObjectsFromArray:
removeAllObjects
compareImageOrder:
clearOutputMask:WithBytesPerRow:OutputRegion:
trainSkinMaskUsingInputImage:InputBytesPerRow:InputRegion:QuadRegion:
findSkinMaskUsingInputImage:InputBytesPerRow:InputRegion:OutputMask:OutputBytesPerRow:OutputRegion:FaceBounds:SeedPoints:NumberOfSeedPoints:FillValue:
findToothMaskUsingInputImage:InputBytesPerRow:InputRegion:OutputMask:OutputBytesPerRow:OutputRegion:TeethBounds:SeedPoints:NumberOfSeedPoints:FillValue:
drawEyeMaskUsingQuads:OutputMask:OutputBytesPerRow:OutputRegion:
dilateRadius
setDilateRadius:
erodeRadius
setErodeRadius:
_colorCube
_tempColorCube
_inputScalingForCube
_dilateRadius
_erodeRadius
arrayWithObjects:count:
dictionaryWithObjects:forKeys:count:
extent
CGRectValue
_netExtent
_inputsAreOK
filteredImage:keysAndValues:
dataWithLength:
mutableBytes
length
context
defaultWorkingColorSpace
render:toBitmap:rowBytes:bounds:format:colorSpace:
imageWithBitmapData:bytesPerRow:size:format:colorSpace:
imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor:
customAttributes
outputData
outputImage
inputImage
setInputImage:
inputExtent
setInputExtent:
inputScale
setInputScale:
inputCount
setInputCount:
_context
baseAddress
region
format
kernelWithString:
floatValue
imageByApplyingGaussianBlurWithSigma:
_CIEdgeWork
applyWithExtent:arguments:
_CIEdgeWorkContrast
inputRadius
emptyImage
imageByClampingToExtent
applyWithExtent:roiCallback:arguments:options:
imageByCroppingToRect:
objectAtIndexedSubscript:
objectForKeyedSubscript:
processWithInputs:arguments:output:error:
outputFormat
synchronizeInputs
roiForInput:arguments:outputRect:
formatForInputAtIndex:
imageByApplyingTransform:
imageByApplyingFilter:
imageByApplyingFilter:withInputParameters:
transitionDepthsKernel
applyWithExtent:arguments:options:
thresholdKernel
vectorWithCGRect:
vectorWithX:Y:
inputFocusRect
setInputFocusRect:
convertToHalfFloat
renormalize01
renormalizeThreshold
vectorWithX:Y:Z:
computeBand
protectInterior
filterWithName:withInputParameters:
denormalize
vectorWithX:Y:Z:W:
invertImage
normalizeToPhysicalDepth
foreground
filterCut
boxBlur3Mono
inputDisparityImage
setInputDisparityImage:
inputThresholdImage
setInputThresholdImage:
inputMaxNumVertices
setInputMaxNumVertices:
inputSigmaS
setInputSigmaS:
inputSigmaRLuma
setInputSigmaRLuma:
inputSigmaRChroma
setInputSigmaRChroma:
inputLambda
setInputLambda:
inputMaxNumIterations
setInputMaxNumIterations:
inputBandRange
setInputBandRange:
inputThresholdOffset
setInputThresholdOffset:
inputFilterCut
setInputFilterCut:
inputFeatherBandRange
setInputFeatherBandRange:
inputAdaptiveThresholdRange
setInputAdaptiveThresholdRange:
inputSigmaFallout
setInputSigmaFallout:
colorSpace
imageYCC444:matrix:fullRange:colorSpace:
_confidenceExtractRed
extractLuminance:
_kernelD2
applyWithExtent:roiCallback:arguments:
autorelease
_isIdentity
downTwo:
upCubic:scale:
_kernelCombine
inputMask
setInputMask:
setInputRadius:
initWithRect:withFaceId:
setFaceId:
setFaceRect:
framesSinceLast
setFramesSinceLast:
computeAverage
initWithScore:
addScore:
computeStandardDeviation
maxScore
setMaxScore:
minScore
setMinScore:
numScores
setNumScores:
sumScores
sumSqScores
setSwFaceId:
setSwCenter:
setSwSize:
setSwLastFrameSeen:
setHwFaceId:
setHwCenter:
setHwSize:
setHwLastFrameSeen:
hwCenter
hwSize
swCenter
swSize
hwFaceId
hwFaceRect
swFaceId
swFaceRect
overlapWithHwRect:
overlapWithSwRect:
swLastFrameSeen
hwLastFrameSeen
dictionary
addEntriesFromDictionary:
faceDetectorWithOptions:
setHwFaceRect:
padRoiRect:paddingX:paddingY:
isSyncedWithImage
setFacesRoiRect:
setNumHWFaces:
setupFaceDetector
calculateFaceCoreROI:imageStat:needFaceCore:
dataWithBytesNoCopy:length:freeWhenDone:
array
setFaceAngle:
faceAngle
setFaceType:
setFace:
setFaceSize:
setExpressionFeatures:
setLeftEye:
setRightEye:
setMouth:
valueWithBytes:objCType:
detectFacesInData:width:height:bytesPerRow:options:error:
arrayByAddingObjectsFromArray:
face
findOverlappingFaceStat:imageStat:
sortedArrayUsingComparator:
subarrayWithRange:
extractDetailsForFaces:inData:width:height:bytesPerRow:options:error:
localizedDescription
expressionFeatures
valueForKey:
boolValue
setNormalizedFaceRect:
setFoundByFaceCore:
setHasLeftEye:
setHasRightEye:
setLeftEyeOpen:
setRightEyeOpen:
setLeftEyeBlinkScore:
setRightEyeBlinkScore:
setSmileScore:
leftEye
setLeftEyeRect:
rightEye
setRightEyeRect:
foundByFaceCore
value:withObjCType:
getValue:
setFocusScore:
setNormalizedFocusScore:
setNormalizedSigma:
removeObjectForKey:
allKeys
arrayWithArray:
class
isKindOfClass:
unsignedLongLongValue
insertObject:atIndex:
addFaceToArray:
setTimestamp:
setHasRollAngle:
setRollAngle:
setHasYawAngle:
setYawAngle:
setIsSyncedWithImage:
setLatestFaceTimestamp:
curConfig
faceIdMapping
renameMapping
faceIdCounter
faceInfoArray
numFramesSinceFullFaceCore
numFramesNoFaces
faceDetector
faceTimestampArray
latestImageTimestamp
lastFaceIndex
normalizedSigma
faceScore
allocWithZone:
initWithFaceStat:
copyWithZone:
setFaceScore:
setFCRLeftEyeFeaturesOffset:
setFCRRightEyeFeaturesOffset:
setFCRSmileFeaturesOffset:
setFCRBlinkFeaturesSize:
setFCRSmileFeaturesSize:
FCRSmileAndBlinkFeatures
setFCRSmileAndBlinkFeatures:
setSmallFace:
_isSyncedWithImage
_hwFaceRect
getSharpnessAndBlurLimits
setAEDelta:
setRegistrationErrorX:
setRegistrationErrorY:
setHasRegistrationData:
setRegistrationErrorIntegral:
setActionClusteringScore:
updateROI:
computeImageColorHistogram:
computeImageSharpnessOnGrid:
computeBlurStatsOnGrid:
computeImageProjections:
getBytes:length:
computeFacialFocusScoreSum
initWithIdentifier:
computeRuleOfThreeDistance
computeSmilePercentage
setAEMatrix:
computeAEMatrix:
compareImageStats:
colorHistogram
setImageId:
setOrientation:
setFaceStatArray:
exclude
setExclude:
setAEStable:
setAEAverage:
setAETarget:
setAFStable:
setAvgHorzDiffY:
setBlurExtent:
timeReceived
setDoLimitedSharpnessAndBlur:
setRoiSize:
AEDelta
fullsizeJpegSize
setFullsizeJpegSize:
numEntries
dissimilarity
projectionMemoryBlock
projectionSignature
sharpnessGrid
gridWidth
gridHeight
gridROI
smoothedROI
_AEDelta
_fullsizeJpegSize
allowsKeyedCoding
supportsSecureCoding
encodeWithCoder:
initWithCoder:
isValid
initWithPayload:symbolVersion:maskPattern:errorCorrectionLevel:
decodeObjectOfClass:forKey:
decodeIntegerForKey:
encodeObject:forKey:
encodeInteger:forKey:
descriptorWithPayload:symbolVersion:maskPattern:errorCorrectionLevel:
errorCorrectedPayload
symbolVersion
maskPattern
errorCorrectionLevel
initWithPayload:isCompact:layerCount:dataCodewordCount:
decodeBoolForKey:
encodeBool:forKey:
descriptorWithPayload:isCompact:layerCount:dataCodewordCount:
isCompact
layerCount
dataCodewordCount
initWithPayload:isCompact:rowCount:columnCount:
copy
descriptorWithPayload:isCompact:rowCount:columnCount:
rowCount
columnCount
initWithPayload:rowCount:columnCount:eccVersion:
descriptorWithPayload:rowCount:columnCount:eccVersion:
eccVersion
_CITriangleTile
inputCenter
inputAngle
inputWidth
_CILozengeRefraction
inputPoint0
inputPoint1
inputRefraction
_CITorusRefraction
setPerservesAlpha:
bytes
initWithImageProvider:width:height:format:colorSpace:options:
_checkInputs
null
imageByColorMatchingWorkingSpaceToColorSpace:
imageByUnpremultiplyingAlpha
curvesImage
_kernel
imageByPremultiplyingAlpha
imageByColorMatchingColorSpaceToWorkingSpace:
setInputCurvesData:
inputCurvesDomain
setInputCurvesDomain:
inputCurvesData
inputColorSpace
setInputColorSpace:
_curvesImage
encodeFloat:forKey:
decodeFloatForKey:
_internalContext
_contextColorForInstruments
contextWithOptions:
isEqual:
setValue:forKey:
internalCLContextWithOptions:
_initWithInternalRepresentation:
internalContextWithMTLDevice:options:
internalGLContextWithOptions:
initWithCGContext:options:
initWithEAGLContext:
initWithEAGLContext:options:
internalContextWithEAGLContext:options:
initWithMTLDevice:options:
_gpuContextCheck
_crashed_because_nonaddressable_memory_was_passed_to_render:toBitmap:rowBytes:bounds:format:colorSpace:
_internalRepresentation
lock
unlock
render:toCVPixelBuffer:bounds:colorSpace:
bounds
drawImage:inRect:fromRect:
_isGLBackedContext
_isCGBackedContext
createCGImage:fromRect:format:colorSpace:
createCGImage:fromRect:
render:toTexture:target:bounds:colorSpace:
_outputColorSpace
defaultRGBColorSpace
defaultGrayColorSpace
_createCGImage:fromRect:format:colorSpace:deferred:textureLimit:
workingColorSpace
regionOfInterestForImage:inRect:
description
_isMetalInternalContext
_singletonContext
contextWithCGContext:options:
contextWithEAGLContext:
contextWithEAGLContext:options:
contextWithMTLDevice:
contextWithMTLDevice:options:
abort
invalidate
render:toCVPixelBuffer:
_isGLInternalContext
_insertEventMarker:
render:
drawImage:atPoint:fromRect:
render:toTexture:bounds:colorSpace:
render:toMTLTexture:commandBuffer:bounds:colorSpace:
createCGImage:fromRect:format:
createCGImage:fromRect:format:colorSpace:deferred:
createCGLayerWithSize:info:
maximumInputImageSize
maximumOutputImageSize
inputImageMaximumSize
outputImageMaximumSize
workingFormat
reclaimResources
clearCaches
flatten:fromRect:format:colorSpace:
measureRequirementsOf:query::results:
setCTM:
setBounds:
createColorCubeDataForFilters:dimension:
_priv
internalCLContextWithOptions:glContext:
_pdfDataRepresentation
resetStatistics
peakNonVolatileSize
_CIPageCurlTransNoEmap
_CIPageCurlTransition
filterWithName:keysAndValues:
inputTargetImage
inputBacksideImage
inputShadingImage
inputTime
_CIPageCurlWithShadowTransition
_CIPageCurlNoShadowTransition
inputShadowSize
inputShadowAmount
inputShadowExtent
inputKeys
hash
setValue:forUndefinedKey:
valueForUndefinedKey:
classInfoForClass:
inputClasses
_crashed_when_dealloc_called_setValue_nil_forKey_probably_because_the_subclass_already_released_it:
finalize
outputKeys
classAttributesForClass:
classDefaultsForClass:
setWithArray:
keyPathsForValuesAffectingValueForKey:
raise:format:
initWithFormat:
userInfo
setWithObjects:
decodeObjectOfClasses:forKey:
containsValueForKey:
_copyFilterWithZone:
_propertyArrayFromFilters:inputImageExtent:
_filterArrayFromProperties:inputImageExtent:
ROISelector
respondsToSelector:
methodForSelector:
applyWithExtent:roiCallback:inputImage:arguments:
apply:arguments:options:
serializedXMPFromFilters:inputImageExtent:
filterArrayFromSerializedXMP:inputImageExtent:error:
attributes
setDefaults
mutableCopyWithZone:
apply:
name
setName:
isEnabled
setEnabled:
_enabled
classCategoriesForClass:
containsObject:
componentsSeparatedByString:
filterWithName:
hasPrefix:
vectorWithString:
substringWithRange:
_filterClassInCategory:
substringFromIndex:
stringValue
stringRepresentation
rangeOfString:
isSubclassOfClass:
_outputProperties
_initFromProperties:
conformsToProtocol:
_serializedXMPString
filterWithString:
setIdentity
setUserInfo:
setOption:forKey:
_imageMetadataFromFilters:inputImageExtent:
_filterArrayFromImageMetadata:inputImageExtent:
_filterArrayFromProperties:
transformStruct
_CIParallelogramTile
inputAcuteAngle
_blur:pass:weightsFactor:
setInputAngle:
setInputAmount:
inputAmount
_kernelNew
setInputCenter:
unsignedIntValue
CGImage
imageWithCGImage:options:
initWithCGImage:options:
fileURLWithPath:
mutableCopy
numberWithUnsignedInt:
_initNaiveWithCGImage:options:
_setOriginalCGImage:
_initWithIOSurface:options:owner:
initWithCVPixelBuffer:options:
initAuxiliaryWithImageSource:options:depth:
imageWithCGLayer:options:
initWithCGLayer:options:
initWithBitmapData:bytesPerRow:size:format:options:
initWithBitmapData:bytesPerRow:size:format:colorSpace:
_initWithBitmapData:bytesPerRow:size:format:options:
initWithBytesNoCopy:length:deallocator:
initWithTexture:size:flipped:colorSpace:
initWithTexture:size:options:
initWithTexture:size:flipped:options:
pixelBuffer
imageWithCVPixelBuffer:options:
_initWithCVImageBuffer:options:
_setOriginalCVPixelBuffer:
imageWithCVImageBuffer:options:
initWithCVImageBuffer:options:
initWithColor:
cgColor
initWithEmptyClearColor
imageTransformForOrientation:
imageTransformForCGOrientation:
initWithData:options:
initWithCGImageSource:index:options:
imageWithContentsOfURL:options:
initWithContentsOfURL:options:
imageWithContentsOfFile:options:
initWithContentsOfFile:options:
imageWithInternalRepresentation:
imageByClampingToRect:
initWithDictionary:copyItems:
imageBySamplingNearest
imageBySamplingLinear
initWithArrayOfImages:selector:
shapeWithRect:
stringWithUTF8String:
filterWithName:setDefaults:
writeTIFFRepresentationOfImage:toURL:format:colorSpace:options:error:
initWithCGImage:
nullImage
imageWithCGImage:
imageWithCGLayer:
imageWithBitmapData:bytesPerRow:size:format:options:
imageWithTexture:size:flipped:colorSpace:
imageWithTexture:size:options:
imageWithTexture:size:flipped:options:
imageWithMTLTexture:options:
imageWithCVPixelBuffer:
imageWithCVImageBuffer:
imageWithColor:
noiseImage
noiseImageNearest
noiseImagePadded
imageWithData:
imageWithData:options:
imageWithContentsOfURL:
imageWithContentsOfFile:
imageForRenderingWithMetal:orNonMetal:
imageForRenderingWithMPS:orNonMPS:
imageForRenderingWithMetalContext:orOpenGLContextUsingMetal:orNonMetalContext:
imageWithArrayOfImages:selector:
_originalCGImage
initWithCGLayer:
initWithMTLTexture:options:
_originalCVPixelBuffer
depthData
initWithCVPixelBuffer:
initWithCVImageBuffer:
initWithColorR:G:B:A:
imageByApplyingOrientation:
imageByApplyingCGOrientation:
initWithData:
initWithContentsOfURL:
initWithContentsOfFile:
imageByApplyingTransform:highQualityDownsample:
imageByCompositingOverImage:
_imageByPremultiplying
_imageByUnpremultiplying
_imageByClampingAlpha
imageBySettingAlphaOneInExtent:
_imageByApplyingGamma:
_imageByApplyingBlur:
_imageByMatchingWorkingSpaceToColorSpace:
imageByColorMatchingWorkingSpaceToRGBorGrayColorSpace:
_imageByMatchingColorSpaceToWorkingSpace:
imageByTaggingWithColorSpace:
_imageByRenderingToIntermediate
imageBySettingProperties:
_imageBySamplingNearest
_imageBySamplingLinear
initForRenderingWithMetal:orNonMetal:
initForRenderingWithMPS:orNonMPS:
initForRenderingWithMetalContext:orOpenGLContextUsingMetal:orNonMetalContext:
definition
debugDescription
properties
isOpaque
setCacheHint:
cacheHint
writeToTIFF:
printTree
TIFFRepresentation
setValue:forKeyPath:
initWithDepthData:options:
initWithDepthData:
imageWithDepthData:options:
imageWithDepthData:
initWithAttributedString:format:options:
string
archivedDataWithRootObject:
appendBytes:length:
appendData:
initWithAttributedString:format:
imageWithAttributedString:format:
imageWithAttributedString:format:options:
setObject:forKeyedSubscript:
encodeInt:forKey:
decodeIntForKey:
modifiedKernelStringForFosl:
_initWithDict:
kernelsWithString:messageLog:
initWithString:
kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:
libraryWithData:error:
_initWithFirstKernelFromString:withCruftCompatibility:
_outputPixelFormatFromExplicitAttributes:
appendString:
longValue
_isValidOutputPixelFormat:
_outputFormatUsingDictionary:andKernel:
kernelsWithString:
kernelWithFunctionName:fromMetalLibraryData:error:
colorMatrixBiasKernel
perservesAlpha
preservesRange
setPreservesRange:
canReduceOutputChannels
setCanReduceOutputChannels:
setROISelector:
parameters
autogenerateROI:args:arguments:extent:
applyWithExtent:roiCallback:inputImage:arguments:options:
initWithString:extentType:
kernelWithString:extentType:
applyWithForeground:background:
enumerateLinesUsingBlock:
CGAffineTransformValue
_values
initWithImageProvider:userInfo:size:format:flipped:colorSpace:
initWithImageProvider:size::format:colorSpace:options:
provideImageData:bytesPerRow:origin::size::userInfo:
_initWithImageProvider:width:height:format:colorSpace:surfaceCache:options:
imageWithImageProvider:userInfo:size:format:flipped:colorSpace:
imageWithImageProvider:size::format:colorSpace:options:
_scale
inputAspectRatio
setInputAspectRatio:
inputB
setInputB:
inputC
setInputC:
_CIAlphaNormalize
_CITiltShift
_DistanceColored
inputSaturation
inputUnsharpMaskRadius
inputUnsharpMaskIntensity
_kickLightKernel_pos
_kickLightKernel_neg
setInputWidth:
inputStrength
setInputStrength:
inputRotate
setInputRotate:
inputPt1
setInputPt1:
inputPt2
setInputPt2:
inputPt3
setInputPt3:
inputPt4
setInputPt4:
inputPt5
setInputPt5:
inputPt6
setInputPt6:
inputOrientation
setInputOrientation:
inputCenterBottom
setInputCenterBottom:
_dualLightKernel
inputCenter1
setInputCenter1:
inputCenter2
setInputCenter2:
inputBottom1
setInputBottom1:
inputBottom2
setInputBottom2:
inputWidth1
setInputWidth1:
inputWidth2
setInputWidth2:
inputHeight1
setInputHeight1:
inputHeight2
setInputHeight2:
inputRotate1
setInputRotate1:
inputRotate2
setInputRotate2:
inputBrighten
setInputBrighten:
inputContrast
setInputContrast:
_strobeKernel
_extractRed
_contourLightKernel
inputEyes
setInputEyes:
inputHeight
setInputHeight:
_portraitSpotKernel
inputDarken
setInputDarken:
_neckContourKernel
inputChin
setInputChin:
inputFaceOrientation
setInputFaceOrientation:
initWithFormat:arguments:
stringByAppendingString:
errorWithDomain:code:userInfo:
setInputTransform:
inputTransform
setInputRectangle:
inputRectangle
TIFFRepresentationOfImage:format:colorSpace:options:
writeToURL:options:error:
PNGRepresentationOfImage:format:colorSpace:options:
JPEGRepresentationOfImage:colorSpace:options:
HEIFRepresentationOfImage:format:colorSpace:options:
writePNGRepresentationOfImage:toURL:format:colorSpace:options:error:
writeJPEGRepresentationOfImage:toURL:colorSpace:options:error:
writeHEIFRepresentationOfImage:toURL:format:colorSpace:options:error:
numberWithUnsignedLong:
inputIntensity
setInputIntensity:
_CILenticularHalo
colorWithRed:green:blue:
inputColor
inputHaloRadius
inputHaloWidth
inputHaloOverlap
inputStriationStrength
inputStriationContrast
performSelector:withObject:withObject:
depthDataType
depthDataByConvertingToDepthDataType:
depthDataByReplacingDepthDataMapWithPixelBuffer:error:
depthDataMap
dictionaryRepresentationForAuxiliaryDataType:
cameraCalibrationData
intrinsicMatrix
intrinsicMatrixReferenceDimensions
depthDataAccuracy
portraitScore
clearImage:
initWithExtent:format:options:
initWithExtent:format:
initWithExtent:format:colorSpace:
isMemberOfClass:
setImage:dirtyRect:
imageAccumulatorWithExtent:format:options:
imageAccumulatorWithExtent:format:
imageAccumulatorWithExtent:format:colorSpace:
setImage:
clear
commitUpdates:
_state
initWithValues:count:
initWithX:
initWithX:Y:
initWithX:Y:Z:
initWithX:Y:Z:W:
initWithCGPoint:
initWithCGRect:
initWithCGAffineTransform:
valueAtIndex:
stringByAppendingFormat:
decodeRectForKey:
vectorWithValues:count:
vectorWithX:
vectorWithCGPoint:
vectorWithCGAffineTransform:
CGPointValue
_count
inputEV
setInputEV:
_CIDisplaceFromImage
inputDisplacementImage
setInputSaturation:
inputBrightness
setInputBrightness:
offsetAndCrop
_reduce2X2
_reduce1X4
_reduce4X1
_reduceCrop
_reduce4x4
inputRVector
setInputRVector:
inputGVector
setInputGVector:
inputBVector
setInputBVector:
inputAVector
setInputAVector:
inputBiasVector
setInputBiasVector:
_kernelNeg
_kernelPos
_kernelH
_kernelV
performPass:reference:values:rect:
_kernelMetal
inputLumaNoiseAmpl
setInputLumaNoiseAmpl:
inputLumaNoiseModelCoeff
setInputLumaNoiseModelCoeff:
inputUseMetal
setInputUseMetal:
samplerWithImage:options:
inputHorizontalBlur
setInputHorizontalBlur:
inputMaxBlur
setInputMaxBlur:
inputAntiAliasBlurStrength
setInputAntiAliasBlurStrength:
_kernelWithShapesMetal
_kernelsWithShapes
_ourBlendKernelMetal
_ourBlendKernel
outputImage:
inputBlurmapImage
setInputBlurmapImage:
inputLumaNoiseScale
setInputLumaNoiseScale:
inputTuningParameters
setInputTuningParameters:
inputShape
setInputShape:
applyWithExtent:inputs:arguments:error:
unarchiveObjectWithData:
skipFormatChecks
applyWithExtent:shader:inputs:roiMethods:insetRects:scaleFactors:arguments:error:
applyWithExtent:shader:inputs:insetRects:arguments:error:
applyWithExtent:shader:inputs:scaleFactors:arguments:error:
applyWithExtent:shader:inputs:arguments:error:
applyWithExtent:shader:inputs:className:arguments:error:
outputIsOpaque
inputText
setInputText:
inputFontName
setInputFontName:
inputFontSize
setInputFontSize:
inputScaleFactor
setInputScaleFactor:
inputNeutral
setInputNeutral:
inputTargetNeutral
setInputTargetNeutral:
green
blue
alpha
setInputColor:
clearColor
inputColor0
setInputColor0:
inputColor1
setInputColor1:
initWithAPI:properties:
setDebugLabel:
getMacroContextPrivate
sharegroup
setParameter:to:
currentContext
setCurrentContext:
initWithAPI:
inputPower
setInputPower:
initWithSurface:texture:allowSRGB:bounds:context:
surface
usesSRGBTransferFunction
_region
_surface
_usesSRGB
_mtlTexture
_surfaceLocked
retainedReferences
metalTexture
metalCommandBuffer
metalCommandBufferRequested
_cmdBuffer
exceptionWithName:reason:userInfo:
compare:
lengthOfBytesUsingEncoding:
allowSRGBTranferFuntionOnOutput
allowSRGBTranferFuntionOnInputAtIndex:
_digestForArgs:
allowPartialOutputRegion
_CINoiseReduction
inputNoiseLevel
inputSharpness
_CIEdgesPrep
_CIFindEdges
_CIConvertRGBtoY
_CIBlur1
_CIBlur2
_CIBlur4
_CISharpenCombineEdges
inputFalloff
inputEdgeScale
bundleForClass:
newDefaultLibraryWithBundle:error:
newFunctionWithName:
computeCommandEncoder
newComputePipelineStateWithFunction:error:
setComputePipelineState:
setBytes:length:atIndex:
setBuffer:offset:atIndex:
setTexture:atIndex:
threadExecutionWidth
maxTotalThreadsPerThreadgroup
dispatchThreadgroups:threadsPerThreadgroup:
endEncoding
addCompletedHandler:
initWithDevice:kernelName:
encodeToCommandBuffer:sourceBuffer:sourceRowBytes:destinationTexture:
encodeToCommandBuffer:sourceBuffer:sourceRowBytes:destinationBuffer:destinationRowBytes:destinationSize:
_device
_convertToTexture
_convertToBuffer
arrayWithObjects:
_CIOpTile
setInputSharpness:
initWithImage:
initWithImage:options:
_initWithImage:key0:vargs:
samplerWithImage:
samplerWithImage:keysAndValues:
initWithImage:keysAndValues:
opaqueShape
wrapMode
_CIShadedmaterial_0
_CIShadedmaterial
integerValue
_customBoxBlur5Kernel
outputImageMetal
inputNumIterations
setInputNumIterations:
_CICircle
inputEdgeBlur
smartToneAdjustmentsForValue:andStatistics:
smartToneAdjustmentsForValue:localLightAutoValue:andStatistics:
smartColorAdjustmentsForValue:andStatistics:
smartToneStatistics
smartColorStatistics
inputUseCube
inputUseCubeColorSpace
_kernelBneg
_kernelBpos
_kernelRH
_kernelC
inputExposure
setInputExposure:
inputShadows
setInputShadows:
inputHighlights
setInputHighlights:
inputBlack
setInputBlack:
inputRawHighlights
setInputRawHighlights:
inputLocalLight
setInputLocalLight:
inputLightMap
setInputLightMap:
setInputUseCube:
setInputUseCubeColorSpace:
_inputLightMap
_cubeImage
_cubeData
_cubeContext
_kernelV_lt1
_kernelV_gt1
_kernelCPos
_kernelCNeg
_kernelCast
inputVibrancy
setInputVibrancy:
inputCast
setInputCast:
initWithBitmap:rowBytes:bounds:format:
initWithBitmap:rowBytes:bounds:format:options:
setBitmap:rowBytes:bounds:format:
contextWithBitmap:rowBytes:bounds:format:
contextWithBitmap:rowBytes:bounds:format:options:
_bcpriv
detectorOfType:context:options:
featuresInImage:options:
drain
_autoRedEyeFilterWithFeatures:imageProperties:context:options:
setFaceBalanceEnabled:
setVibranceEnabled:
setCurvesEnabled:
setShadowsEnabled:
faceBalanceEnabled
setupFaceColorFromImage:usingContext:features:
_scaleImageToMaxDimension:
forImage:usingContext:
setupHistogramsUsing:redIndex:greenIndex:blueIndex:
getAutoRotateFilter:ciImage:rgbRows:inputRect:rotateCropRect:
getAutocropRect:rotateXfrm:inputImageRect:clipRect:
faceBalanceWarmth
faceBalanceStrength
originalFaceColor
vibranceEnabled
vibrance
curvesEnabled
curveCount
curvePointAtIndex:
shadowsEnabled
shadow
autoAdjustmentFiltersWithOptions:
autoAdjustmentFiltersWithImageProperties:options:
hasLeftEyePosition
leftEyePosition
hasRightEyePosition
rightEyePosition
hasMouthPosition
mouthPosition
_dictForFeature:scale:imageHeight:
supportRectangleWithFaceArray:imageSize:
initWithExternalBuffer:subRectangle:fullSize:rowBytes:cameraModel:
autoRepairWithFaceArray:
repairArray
autoAdjustmentFilters
autoRedEyeFilterWithFeatures:imageProperties:options:
autoRedEyeFilterWithFeatures:options:
supportRectangleWithRepair:imageSize:
allValues
inputCameraModel
setInputCameraModel:
inputCorrectionInfo
setInputCorrectionInfo:
executeRepair:
repairExternalBuffer
histogramFromData:
histogramFromFloatData:
histogramFromDoubleData:
values
hist
_CIConvolutionAdd_1
_CIConvolutionAdd_2
_CIConvolutionAdd_3
_CIConvolutionAdd_4
_CIConvolutionAdd_5
_CIConvolutionAdd_6
_CIConvolutionAdd_7
_CIConvolutionAdd_8
doConvolutionPass:weights:sums:
samplesPerPass
inputPoints
inputWeights
inputLinearFilterModeEnabled
inputRingAmount
inputRingSize
inputSoftness
_recipe
inputPointCount
removeLastObject
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
addScheduledHandler:
initWithBounds:andImage:usingContext:
size
centerX
centerY
_CIDroste
inputInsetPoint0
inputInsetPoint1
inputStrands
inputPeriodicity
inputRotation
inputZoom
_internalRenderDestination
_initWithInternalRenderDestination:width:height:format:colorspace:
setFlipped:
_render:withContext:
initWithPixelBuffer:
initWithWidth:height:pixelFormat:colorSpace:pixelBufferProvider:
initWithMTLTexture:commandBuffer:
initWithWidth:height:pixelFormat:commandBuffer:mtlTextureProvider:
initWithGLTexture:target:width:height:
initWithBitmapData:width:height:bytesPerRow:format:
alphaMode
setAlphaMode:
isFlipped
isDithered
setDithered:
ditherDepth
isClamped
setClamped:
setColorSpace:
blendKernel
setBlendKernel:
blendsInDestinationColorSpace
setBlendsInDestinationColorSpace:
imageRepresentation
internalRepresentation
initWithCompletedTask:
renderInfoWithCompletedTask:
kernelExecutionTime
passCount
pixelsProcessed
pixelsOverdrawn
initWithInternalTask:
rendertaskWithInternalTask:
waitUntilCompletedAndReturnError:
startTaskToRender:toDestination:error:
_startTaskToRender:toDestination:forPrepareRender:error:
startTaskToRender:fromRect:toDestination:atPoint:error:
prepareRender:fromRect:toDestination:atPoint:error:
startTaskToClear:error:
fromImage:
initFileURLWithPath:
_dumpImage:colorspace:
forImage:downscaleToMax:colorspace:
forImage:downscaleToMax:colorspace:usingContext:
forImage:usingContext:colorspace:
numberWithShort:
unsignedLongValue
shortValue
fromImageFile:
forImage:downscaleToMax:
withDictionary:
rowAtIndex:
bytesPerPixel
dumpImage:
dumpImageAsDeviceRGB:
dumpImageAsDict:
data
setRGBSumHistogram:
setLuminanceHistogram:
setBorderHistogram:
setSaturationHistogram:
bestWarmthForI:q:percentChange:
setFaceColorFromChromaI:andChromaQ:
analyzeFeatures:usingContext:baseImage:
histogramFromRows:componentOffset:
setupFaceColorFromImage:usingContext:detectorOpts:
_kernel16
curveImageFromPoints:
splineCurveTable:tableSize:gamma:from:
curveImageFromPoints:linear:
setInputPoint0:
setInputPoint1:
setInputPoint2:
setInputPoint3:
setInputPoint4:
inputPoint2
inputPoint3
inputPoint4
_curveImage
filterNamesInCategories:
isSubsetOfSet:
caseInsensitiveCompare:
notificationWithName:object:
defaultQueue
enqueueNotification:postingStyle:coalesceMask:forModes:
classAttributesForName:
localizedStringForKey:value:table:
filterNamesInCategory:
registerFilterName:constructor:classAttributes:
localizedNameForFilterName:
localizedNameForCategory:
localizedDescriptionForFilterName:
localizedReferenceDocumentationForFilterName:
compatibilityVersion
filterWithName:compatibilityVersion:
filterWithName:compatibilityVersion:keysAndValues:
allCategories:
URLWithString:
_attributesWithClass:
initWithClass:
indexOfObject:
setObject:atIndexedSubscript:
superclass
instanceMethodForSelector:
characterAtIndex:
containsString:
_defaultVersion
_maxVersion
_kernelSnoB_v0
_kernelSHnoB_v0
_kernelSH_v0
_kernelSHnoB_v1
_kernelSH_v1
_kernelSHnoB_v2
_kernelSH_v2
setInputShadowAmount:
setInputHighlightAmount:
inputHighlightAmount
initWithContext:options:
featuresInImage:
setContext:
_width
_height
featureOptions
_CIRippleTransition
roiForInput:arguments:output:
colorWithRed:green:blue:alpha:
_CISunbeams
inputSunRadius
inputMaxStriationRadius
getNonNormalizedSettings:
createHueArray
hueArrayImage:
inputNeutralGamma
setInputNeutralGamma:
inputTone
setInputTone:
inputHue
setInputHue:
inputGrain
setInputGrain:
inputSeed
setInputSeed:
smartBlackAndWhiteStatistics
smartBlackAndWhiteAdjustmentsForValue:andStatistics:
setInputOrigI:
setInputOrigQ:
setInputWarmth:
inputOrigI
inputOrigQ
inputWarmth
inputEpsilon
setInputEpsilon:
inputCrossAngle
setInputCrossAngle:
inputCrossScale
setInputCrossScale:
inputCrossWidth
setInputCrossWidth:
inputCrossOpacity
setInputCrossOpacity:
getBlockSetWithImage:into:width:height:
getDataProviderBytePtrWithImage:into:width:height:
getDataProviderCopyWithImage:into:
initWithDeskView:andFrame:
skinInit
initializeNonDebugVariables
initWithFrameExternalBuffer:
repairWithTag:
upperRepairSizeFraction:
lowerRepairSizeFraction:
upperRepairDistance:
lowerRepairSize:
upperRepairSize:
extractReusableAlignedBitmapsAroundPoint:YR:subYBitmap:subCbCrBitmap:
averageValueFromY:withinSkinMask:butOutsideAlpha:
computeTrimmedBitmaps:newY:newCbCr:IR:newTrimY:newTrimCbCr:returningYR:andCbCrR:
undoRepair:
redEyeRemovalWithPoint:alignPupilShades:matching:force:IOD:tap:
redoRepairWithTag:IOD:
upperRepairDistanceFraction:
insertIntoProminenceVettingHopper:max:outside:confidence:distance:row:column:IOD:
gatherProminencesWithC:MC:altC:altMC:maxwindowsize:repairsize:IR:fr:intoHopper:faceIndex:left:
extractAverageFaceY:contrast:faceIndex:
confidenceWithIOD:repair:andProminenceDifference:
distanceMaskFromPolyToCb:Cr:
prepareLineFunctions
autoRepairExtractAndSearchLeft:right:data:repairSize:autoPupilTonality:faceIndex:
getFloat:d:s:
getInt:d:s:
getBool:d:s:
redEyeRemovalWithData:
supportRectangleWithPoint:imageSize:IOD:
initWithCGImage:cameraModel:
createRepairedImage
initWithExternalBuffer:size:rowBytes:
debug
setDebug:
logRepairs
setLogRepairs:
redEyeThresholdKind
setRedEyeThresholdKind:
renderAlpha
setRenderAlpha:
infillBackground
setInfillBackground:
renderSpecularShine
setRenderSpecularShine:
specularSize
setSpecularSize:
specularSoftness
setSpecularSoftness:
pupilShadeAlignment
setPupilShadeAlignment:
autoPupilTonality
setAutoPupilTonality:
forceLoValue
setForceLoValue:
loValue
setLoValue:
standardTemplate
faces
repairs
nRepairs
lastRepairTag
redoLastRepair
executeRepairArray:
setFaceIndex:
setLeft:
ownLF
imageSourceType
blockSet
releaseMe
dataRef
nextRepairTag
lastRepairIOD
iFaceIndex
iLeft
debugRedEye
lastClickYBitmap
lastClickCbCrBitmap
lastClickBitmapMinX
lastClickBitmapMaxX
lastClickBitmapMinY
lastClickBitmapMaxY
lastClickYBitmaps
lastClickCbCrBitmaps
lastClickBitmapRects
lastSearchYBitmap
lastSearchCbCrBitmap
lastSearchBitmapMinX
lastSearchBitmapMaxX
lastSearchBitmapMinY
lastSearchBitmapMaxY
nPolyPoints
polyClosed
polyPoints
polyLines
polyPointConcave
CbCrDistanceTable
nLinears
linearCoefficients
computeDOD:tst:off:mtx:
inputPoint
setInputPoint:
inputImage2
setInputImage2:
_geomKernel
_colorKernel
inputSize
setInputSize:
setInputRotation:
inputDecay
setInputDecay:
_CICheapBlur
_CILerp
inputPasses
inputSampling
computeDOD:
_kernelGuideMono
_kernelGuideCombine
_kernelJointUpsamp
_kernelJointUpsampRG
_kernelGuideCombine4
inputSmallImage
setInputSmallImage:
inputSpatialSigma
setInputSpatialSigma:
inputLumaSigma
setInputLumaSigma:
filterWithImageURL:options:
filterWithImageData:options:
filterWithCVPixelBuffer:properties:options:
setFaceCoreDetector:
adjustedImageFromImage:orientation:inverseCTM:
createFaceCoreDataFromCIImage:width:height:
mouth
trackID
trackDuration
initWithBounds:hasLeftEyePosition:leftEyePosition:hasRightEyePosition:rightEyePosition:hasMouthPosition:mouthPosition:hasFaceAngle:faceAngle:hasTrackingID:trackingID:hasTrackingFrameCount:trackingFrameCount:hasSmile:leftEyeClosed:rightEyeClosed:
faceCoreDetector
_tracking
ctmForImageWithBounds:orientation:
type
hasTrackingID
trackingID
hasTrackingFrameCount
trackingFrameCount
hasFaceAngle
hasSmile
leftEyeClosed
rightEyeClosed
initWithBounds:topLeft:topRight:bottomLeft:bottomRight:
topLeft
topRight
bottomLeft
bottomRight
initWithInternalRepresentation:
numberWithUnsignedChar:
numberWithInteger:
featureWithInternalRepresentation:
messageString
symbolDescriptor
initWithBounds:topLeft:topRight:bottomLeft:bottomRight:subFeatures:messageString:
subFeatures
initWithCGColor:
initWithRed:green:blue:alpha:
initWithRed:green:blue:alpha:colorSpace:
colorWithRed:green:blue:alpha:colorSpace:
performSelector:withObject:
colorWithCGColor:
colorWithRed:green:blue:colorSpace:
colorWithString:
blackColor
whiteColor
grayColor
redColor
greenColor
blueColor
cyanColor
magentaColor
yellowColor
initWithRed:green:blue:
initWithRed:green:blue:colorSpace:
numberOfComponents
components
debugQuickLookObject
_pad
inputSkyAmount
setInputSkyAmount:
inputGrassAmount
setInputGrassAmount:
stringByReplacingOccurrencesOfString:withString:
hashForString:
betterString:
rawShadow
putShadowsAnalysisInto:
downSampleHistogram:to:storeIn:
printAnalysis
setCurvePercent:
setupFaceColor:redIndex:greenIndex:blueIndex:
setExposureValue:
setShadowsMin:max:zeroExposure:
printHistogram:downsampledTo:
printHistogramsDownsampledTo:
lumHist
rgbSumHist
satHist
borderHist
exposureValue
maxShadow
minShadow
exposureValueAtZeroShadow
curvePercent
faceInputSet
percentFaceChange
releaseResources
pixelTransferSession
interimScaleBuffer
scaleBuffer
_perMeshPtr
_internalBuffer
initWithData:error:
newLibraryWithData:error:
externFunctionNames
newExternFunctionWithName:
device
functionCount
functionWithName:
newFunctionWithName:device:
_data
_library
_CISpotLight
inputLightPosition
inputLightPointsAt
inputConcentration
cubeImage
_kernelOpaque
setInputCubeData:
inputCubeDimension
setInputCubeDimension:
inputCubeData
inputMaskImage
setInputMaskImage:
inputCube0Data
setInputCube0Data:
inputCube1Data
setInputCube1Data:
inputRadius0
setInputRadius0:
inputRadius1
setInputRadius1:
_kernelD
inputValue
setInputValue:
setInputSoftness:
inputDither
setInputDither:
inputBackgroundImage
setInputBackgroundImage:
multiply
screen
overlay
darken
lighten
colorDodge
colorBurn
hardLight
softLight
difference
exclusion
_kernel_v0
_kernel_v1
saturation
color
luminosity
subtract
divide
linearBurn
linearDodge
vividLight
linearLight
pinLight
hardMix
_poskernel
_negkernel
setInputFalloff:
_outputExtent
imageWithYImage:CrCbImage:CrCbScale:matrix:fullRange:colorSpace:
inputDamping
setInputDamping:
computeDOD:scale:
_pinchDistortionScaleLT1
_pinchDistortionScaleGE1
_convertToGrayscale
_kernelLocalContrast
_CIPointillize
inputRadiusImage
setInputRadiusImage:
_CICMYK_convert
_CIWhite
_CICMYK_cyan
_CICMYK_magenta
_CICMYK_yellow
_CICMYK_black
inputGCR
inputUCR
_CIRectangle
lumaTable
_tableImage
currentHandler
handleFailureInFunction:file:lineNumber:description:
outputCGImageForQRCodeDescriptor
outputCGImageForAztecCodeDescriptor
outputCGImageForPDF417CodeDescriptor
outputCGImageForDataMatrixCodeDescriptor
outputCGImage
inputBarcodeDescriptor
setInputBarcodeDescriptor:
inputMessage
setInputMessage:
setInputCorrectionLevel:
inputCorrectionLevel
setInputLayers:
inputLayers
inputCompactStyle
setInputCompactStyle:
numberWithLong:
setInputMinWidth:
setInputMaxWidth:
setInputMinHeight:
setInputMaxHeight:
setInputDataColumns:
setInputRows:
setInputPreferredAspectRatio:
setInputCompactionMode:
setInputAlwaysSpecifyCompaction:
inputMaxWidth
inputMinHeight
inputMaxHeight
inputDataColumns
inputRows
inputPreferredAspectRatio
inputCompactionMode
inputAlwaysSpecifyCompaction
inputMinWidth
inputQuietSpace
setInputQuietSpace:
inputBarcodeHeight
setInputBarcodeHeight:
setImageProps:
setCompletionBlock:
computeMergeCost:::
setBurstImages:
_CICrystallize
inputImage1
setInputImage1:
inputSelected
setInputSelected:
initReedSolomon
encode:length:bytes:
fillPoly:coefficients:length:
clearPoly:
isZero:
copyPoly:
addOrSubtract:with:
multiply:with:
Degree:
polyCoefficient:degree:
inverse:
multiplyByMonomial:degree:coefficient:
addOrSubtractPoly:with:
Exp:
multiplyPoly:with:
buildGenerator:
divide:by:
createMonomial:coefficient:
coefficients:
_expTable
_logTable
_cachedGeneratorNum
_memoryCapacity
_cachedGenerators
pathForResource:ofType:
_interpolateGrainKernel
_paddedTileKernel
_grainBlendAndMixKernel
inputISO
setInputISO:
cubeName
dataWithContentsOfFile:
cubePath
cubeColorSpaceName
inputSigmaX
setInputSigmaX:
inputSigmaY
setInputSigmaY:
actionAmount
compareActionAmounts:
trueLocalMaximum
substringToIndex:
componentsJoinedByString:
initWithBytesNoCopy:length:encoding:freeWhenDone:
boolForKey:
volatileDomainForName:
initWithBytesNoCopy:length:freeWhenDone:
_kernel_code
inputLevels
setInputLevels:
_CIEdges
_fadeKernel
setInputTargetImage:
setInputTime:
_needToRunFaceMask
_nativeCILensModelImage:aperture:
_nativeCIFaceMaskImage:tuningParameters:
_nativeImage:aperture:
_metalImage
inputShiftmapImage
setInputShiftmapImage:
inputAperture
setInputAperture:
inputLeftEyePosition
setInputLeftEyePosition:
inputRightEyePosition
setInputRightEyePosition:
inputChinPosition
setInputChinPosition:
inputFaceMidPoint
setInputFaceMidPoint:
inputAuxDataMetadata
setInputAuxDataMetadata:
inputCalibrationData
setInputCalibrationData:
inputBlurMap
setInputBlurMap:
_getFocusRect:focusRect:
inputLeftEyePositions
setInputLeftEyePositions:
inputRightEyePositions
setInputRightEyePositions:
inputChinPositions
setInputChinPositions:
inputNosePositions
setInputNosePositions:
propertyListWithData:options:format:error:
initWithBase64EncodedString:options:
_CIHexagonalPixellate
inputOpacity
setInputOpacity:
regionOf:destRect:Offset:
setInputWeights:
secondsSinceStart
statsForImageWithIdentifier:
stringByAppendingPathExtension:
dictionaryWithContentsOfFile:
burstImageSet
burstImageSetWithOptions:
coverImageIdentifier
imageClusterCount
imageClusterForIndex:
setLoggingListener:withUserInfo:
computeDOD
_CIBox6
_CIBox4
_CICross4
_CILanczosDownBy2
_CILanczosHorizontalUpsample
_CILanczosVerticalUpsample
_maskFillColorValue
convertRGBAToYUV420:rgbaBytesPerRow:
setWidth:
setHeight:
setYbuffer:
setCbuffer:
setBytesPerRow:
dataPtr
apply:image:arguments:inoutSpace:
apply:image:arguments:inSpace:
inputWhitePoint
inputVersion
inputRAWDictionary
initWithRect:
_shapeInfinite
initWithStruct:
transformBy:interior:
insetByX:Y:
unionWith:
unionWithRect:
intersectWith:
intersectWithRect:
CGSRegion
inputCompression
setInputCompression:
_kernel_name
_kernel_source
_croppedCenterPixelImage
_roiArea
_roiCenter
_singlePixelImage
_roiRect
setInputAcuteAngle:
_CIComicNoiseReduction
_CISobelEdges
_CIColorControls
inputNRNoiseLevel
inputNRSharpness
inputEdgeIntensity
inputThreshold
_CISpotColor
inputCenterColor1
inputReplacementColor1
inputCloseness1
inputContrast1
inputCenterColor2
inputReplacementColor2
inputCloseness2
inputContrast2
inputCenterColor3
inputReplacementColor3
inputCloseness3
inputContrast3
setLength:
localLightStatisticsWithProxy:
localLightStatistics
localLightStatisticsNoProxy
inputLightMapWidth
inputLightMapHeight
inputGuideImage
_polyKernel
inputLightMapImage
initWithLength:
inputGradientImage
setInputGradientImage:
inputBarOffset
setInputBarOffset:
_kernelG
inputShadowRadius
setInputShadowRadius:
inputShadowDensity
setInputShadowDensity:
inputShadowOffset
setInputShadowOffset:
setInputMaxStriationRadius:
setInputStriationStrength:
setInputStriationContrast:
inputFadeThreshold
setInputFadeThreshold:
componentAdd
componentMultiply
componentMin
componentMax
source
destination
sourceOver
destinationOver
sourceIn
destinationIn
sourceOut
destinationOut
sourceAtop
destinationAtop
exclusiveOr
darkerColor
lighterColor
plusDarker
plusLighter
insertString:atIndex:
replaceOccurrencesOfString:withString:options:range:
generateGeneralKernelFromWarpKernel:args:
generateMainFromWarpKernel:args:
makeGridImage:nx:ny:
inputGreyscale
setInputGreyscale:
inputTopLeft
setInputTopLeft:
inputTopRight
setInputTopRight:
inputBottomRight
setInputBottomRight:
inputBottomLeft
setInputBottomLeft:
inputCrop
setInputCrop:
inputRedCoefficients
setInputRedCoefficients:
inputGreenCoefficients
setInputGreenCoefficients:
inputBlueCoefficients
setInputBlueCoefficients:
inputAlphaCoefficients
setInputAlphaCoefficients:
setWithObject:
initWithImageSource:options:
isFileURL
path
pathExtension
initWithCVPixelBuffer:properties:options:
optionKeys
defaultInputLuminanceNoiseReductionAmount
setInputLuminanceNoiseReductionAmount:
defaultInputColorNoiseReductionAmount
setInputColorNoiseReductionAmount:
defaultInputNoiseReductionContrastAmount
setInputNoiseReductionContrastAmount:
defaultInputNoiseReductionDetailAmount
setInputNoiseReductionDetailAmount:
defaultInputNoiseReductionSharpnessAmount
setInputNoiseReductionSharpnessAmount:
defaultInputMoireAmount
setInputMoireAmount:
defaultInputEnableVendorLensCorrection
setInputEnableVendorLensCorrection:
setInputIgnoreOrientation:
setInputEnableNoiseTracking:
setInputNoiseReductionAmount:
setInputEnableSharpening:
setInputDraftMode:
setInputBoost:
defaultBoostShadowAmount
setInputBoostShadowAmount:
defaultImageOrientation
setInputImageOrientation:
defaultDecoderVersion
setInputDecoderVersion:
defaultInputBaselineExposureAmount
setInputBaselineExposure:
defaultInputBiasAmount
setInputBias:
defaultInputHueMagMRAmount
setInputHueMagMR:
defaultInputHueMagRYAmount
setInputHueMagRY:
defaultInputHueMagYGAmount
setInputHueMagYG:
defaultInputHueMagGCAmount
setInputHueMagGC:
defaultInputHueMagCBAmount
setInputHueMagCB:
defaultInputHueMagBMAmount
setInputHueMagBM:
setInputDisableGamutMap:
defaultNeutralTemperature
setInputNeutralTemperature:
defaultNeutralTint
setInputNeutralTint:
defaultNeutralChromaticityX
setInputNeutralChromaticityX:
defaultNeutralChromaticityY
setInputNeutralChromaticityY:
arrayByAddingObject:
_inputImageSource
_inputImageAndProperties
_inputImage
_nativeSize
_isRawSource
_calledDealloc
_baseImageProperties
_rawDictionary
_rawReconstructionDefaultsDictionary
_supportedSushiModes
_supportedDecoderVersions
_filters
_typeIdentifierHint
_defaultOrientation
inputRequestedSushiMode
inputNeutralChromaticityX
inputNeutralChromaticityY
inputNeutralTemperature
inputNeutralTint
inputNeutralLocation
inputBoost
inputDraftMode
inputIgnoreOrientation
inputImageOrientation
inputEnableSharpening
inputEnableNoiseTracking
inputEnableVendorLensCorrection
inputNoiseReductionAmount
inputLuminanceNoiseReductionAmount
inputColorNoiseReductionAmount
inputNoiseReductionSharpnessAmount
inputNoiseReductionContrastAmount
inputNoiseReductionDetailAmount
inputMoireAmount
inputDecoderVersion
inputBoostShadowAmount
inputBias
inputBaselineExposure
inputDisableGamutMap
inputHueMagMR
inputHueMagRY
inputHueMagYG
inputHueMagGC
inputHueMagCB
inputHueMagBM
inputLinearSpaceFilter
rawReconstructionDefaultsDictionary
rawOptions
rawDictionary
whitePointArray
whitePoint
getWhitePointVectorsR:g:b:
sushiMode
invalidateFilters
rawOptionsWithSubsampling:
subsampling
transformedImageIgnoringOrientation:
filters
performSelector:
valueForKeyPath:
nativeSize
getScaleTransform:
getOrientationTransform:
rawMajorVersion
invalidateInputImage
setTempTintAtPoint:
applyMatrix:toCIImage:
automaticallyNotifiesObserversForKey:
isEqualToNumber:
supportedDecoderVersions
RAWFiltersValueForKeyPath:
setInputNeutralLocation:
supportedSushiModes
setInputLinearSpaceFilter:
activeKeys
outputNativeSize
convertNeutralX:y:toTemperature:tint:
convertNeutralTemperature:tint:toX:y:
updateTemperatureAndTint
willChangeValueForKey:
didChangeValueForKey:
updateChomaticityXAndY
handleFailureInMethod:object:file:lineNumber:description:
setInputRequestedSushiMode:
_CIResetalpha
inputMinComponents
setInputMinComponents:
inputMaxComponents
setInputMaxComponents:
inputTexture
setInputTexture:
inputCropAmount
inputCenterStretchAmount
inputBreakpoint0
setInputBreakpoint0:
inputBreakpoint1
setInputBreakpoint1:
inputGrowAmount
setInputGrowAmount:
_kernelAlt
inputFlipYTiles
setInputFlipYTiles:
backgroundCubeName
applyCubeWithName:toImage:
_CIPhotoEffectDepthBlend
backgroundCubePath
inputDepthMap
setInputDepthMap:
setInputThreshold:
inputGrainAmount
setInputGrainAmount:
inputHighLimit
setInputHighLimit:
inputLowLimit
setInputLowLimit:
_kernelWarpS
_kernelWarpT
_kernelMix
inputBottomHeight
setInputBottomHeight:
inputNumberOfFolds
setInputNumberOfFolds:
inputFoldShadowAmount
setInputFoldShadowAmount:
unsignedCharValue
_initialConversionRGB
_pyramidGenerateLevel
_smoothDisparity
_propagateDisparityR1
_propagateDisparity
initialConversionForSize:useMetal:
generatePyramidLevel:useMetal:
shiftmapLevelZeroWithSize:useMetal:
propagateDisparity:pyramids:useMetal:computedPyramidLevels:
smoothDisparityImage:useMetal:
outputImageUsingMetal:
_propagateDisparityR1Combined
_propagateDisparityCombined
_combineImages
inputPropagateKernel
setInputPropagateKernel:
inputSmoothSigma
setInputSmoothSigma:
inputPropagateMinWeightSum
setInputPropagateMinWeightSum:
inputPropagateSigmaLuma
setInputPropagateSigmaLuma:
inputPropagateSigmaChma
setInputPropagateSigmaChma:
inputOriginalSize
setInputOriginalSize:
inputOffset
setInputOffset:
inputRange
setInputRange:
inputSpread
setInputSpread:
inputFill
setInputFill:
inputGlowColorInner
setInputGlowColorInner:
inputGlowColorOuter
setInputGlowColorOuter:
inputShadowColorInner
setInputShadowColorInner:
inputShadowColorOuter
setInputShadowColorOuter:
inputShadowBlurInner
setInputShadowBlurInner:
inputShadowBlurOuter
setInputShadowBlurOuter:
inputSoften
setInputSoften:
inputHighlightColor
setInputHighlightColor:
inputShadowColor
setInputShadowColor:
_kernelInvertMask
_kernelMultiplyByMask
setShouldFavorTop:
setShouldFavorBottom:
rectContainingRect:andOtherRect:
replaceObjectAtIndex:withObject:
rectWithSize:andPoint:inPosition:fromOriginalSize:
scaleRect:toFitSize:withAnchorPoint:
determineBestPositionWithinSize:forImportantRect:restrictRect:
scaleRect:byScale:
expandRect:toContainRect:
computeClippingWithinSize:andImportantRect:
getRatioOfSize:
clusterRects:
computeClippingWithinSize:andImportantRects:
computeClippingWithinSize:forImportantRect:andType:restrictRect:
computeClippingWithinSize:forMultipleRects:
shouldFavorTop
shouldFavorBottom
originalImageSize
setOriginalImageSize:
inputMinMaxImage
setInputMinMaxImage:
appendFormat:
writeToFile:atomically:encoding:error:
_lensModelKernel
inputCalculatorValuesImage
setInputCalculatorValuesImage:
inputIntrinsicMatrixFocalLength
setInputIntrinsicMatrixFocalLength:
autoRotateFilterFFT:image:inputRect:
calcIntersection:slope1:pt2:slope2:
initWithCapacity:
scaled Average Camera Travel Distance = %f
scaled Max Registration Error Integral = %f
scaled Mean peak registration error / Max peak registration error = %f
scaled Beginning vs. End AEMatrix difference vs. Average of Adjacent AE Matrix Differences = %f
scaled In-out ratio = %f
scaled Max inner distance = %f
scaled Average registration error skewness = %f
Sequence classified as NON-ACTION due to complete lack of local motion (%f, threshold %f)
Non-Linear SVM Action classifier called with:
Average Camera Travel Distance = %f
Max Registration Error Integral = %f
Mean peak registration error / Max peak registration error = %f
Beginning vs. End AEMatrix difference vs. Average of Adjacent AE Matrix Differences = %f
In-out ratio = %f
Max inner distance = %f
Average registration error skewness = %f
PREDICTION: --- %s --- (value = %f)
ACTION
NON-ACTION
testMaxInnerDistance
Tf,VtestMaxInnerDistance
testInOutRatio
Tf,VtestInOutRatio
testMaxPeakRegistrationError
Tf,VtestMaxPeakRegistrationError
testMeanPeakRegistrationError
Tf,VtestMeanPeakRegistrationError
testMinRegionOfInterestSize
Tf,VtestMinRegionOfInterestSize
testMaxRegistrationErrorSkewness
Tf,VtestMaxRegistrationErrorSkewness
testMaxRegistrationErrorIntegral
Tf,VtestMaxRegistrationErrorIntegral
testAverageCameraTravelDistance
Tf,VtestAverageCameraTravelDistance
testAverageRegistrationErrorSkewness
Tf,VtestAverageRegistrationErrorSkewness
testBeginningVsEndAEMatrixVsAverageAdjacentAEMatrix
Tf,VtestBeginningVsEndAEMatrixVsAverageAdjacentAEMatrix
svmParameters
T^{__SVMParameters=[7{__SVMScaleOffset=ff}]ddii^{CIBurstSupportVector}^{CIBurstSupportVector}},V_svmParameters
burst_mode_logging
staccato_mode_logging
burst_max_pending_frames
burst_disable_analysis
burst_force_face_detection
burst_dummy_analysis
burst_disable_facecore
burst_use_fixed_image
burst_fixed_image_filename
burst_dump_yuv
staccato_yuv_dump
burst_use_version
com.apple.camera
/var/mobile/Library/Caches/com.apple.camera
burstSets
com.apple.burstAnalyzer
dd-MM-yyyy'_'HH-mm-ss'_burstLog.txt'
kern.osversion
com.apple.staccato_dump
counter.bin
BurstDoc_AllImageStats
BurstDoc_AllImageIdentifiers
BurstDoc_BestImageIds
BurstDoc_LogFile
Computing action selection threshold
Mean non-zero actions = %f, std dev = %f
ACTION SELECTION THRESHOLD = %f
Examining image, id=%s, timestamp = %.6f, done=%d
Not processing frames, imageStat.timestamp = %.6f, latestFaceTimestamp = %.6f
LeftEyeFeaturesOffset
RightEyeFeaturesOffset
SmileFeaturesOffset
BlinkFeaturesSize
SmileFeaturesSize
burstimage_%06d.yuv
v4@?0
Image_FaceRectROI
Image_Width
Image_Height
Image_AEAverage
Image_AETarget
Image_AEStable
Image_AFStable
Image_Orientation
Image_AEMatrix
Error!  Done adding, but there are still frames left!
Adding image: %s
Image %d:%s has emotional score %d
Image %d:%s has been emotionally rejected.
Skipping projection computation because data isn't present
LOOKING FOR FALSE-POSITIVE FACES...
Analyzing %s...
REMOVING false-positive face with ID = %d
Keeping face with ID = %d
Collapsing %s
*_*_* GARBAGE DETECTOR FOR %s *_*_*
Travel = %f, maxSkewness = %f, avgSkewness = %f, blur = %f, avgBlur = %f, stdBlur = %f
hasFaces = %d
notBlurry = %d
veryBlurry = %d
potentiallyBlurry = %d
poorRegistration = %d
suspectRegistration = %d
******Image %s classified as garbage.
**** Image %s classified as garbage by association.
Image_FacesArray
Score for %s:%d is %f 
with action score %f and center bias %f (isGarbage=%d)
NEW BEST
Cover photo PORTRAIT selection score for %d:%s = %f (unbiased = %f)
Cover photo ACTION selection score for %d:%s = %f
%s:   # faces = %d, avgH = %f
    face id=%d, rect=%.3f,%.3f,%.3f,%.3f, focus=%.3f, faceScore=%.3f, leftEyeOpen=%d, rightEyeOpen=%d
Performing emotional rejection of face images in cluster %d:
Items in next cluster:
Image %s is classified as garbage for portrait mode, no sharp faces.
Checking temporal order: %d vs. %d
Removing %d:%s
All items in one cluster.
clusterArray
T@"NSMutableArray",VclusterArray
temporalOrder
Ti,VtemporalOrder
faceIDCounts
T@"NSCountedSet",VfaceIDCounts
allImageIdentifiers
T@"NSMutableArray",VallImageIdentifiers
statsByImageIdentifier
T@"NSMutableDictionary",VstatsByImageIdentifier
clusterByImageIdentifier
T@"NSMutableDictionary",VclusterByImageIdentifier
burstLogFileName
T@"NSString",VburstLogFileName
actionClassifier
T@"CIBurstActionClassifier",VactionClassifier
maxNumPendingFrames
Ti,VmaxNumPendingFrames
enableAnalysis
TB,VenableAnalysis
dummyAnalysisCount
Ti,VdummyAnalysisCount
enableFaceCore
TB,VenableFaceCore
enableDumpYUV
TB,VenableDumpYUV
burstCoverSelection
T@"NSString",VburstCoverSelection
burstId
T@"NSString",&,N,VburstId
bestImageIdentifiersArray
T@"NSArray",VbestImageIdentifiersArray
versionString
T@"NSString",V_versionString
version
Ti,V_version
Images without faces = %d, threshold = %d, total # = %d
Classified as portrait mode. Affects cover photo selection.
all costs within valid region: 
mean = %f, std = %f
First average cost = %f
Second average cost = %f
--Invalidating two outliers from the start of the burst
--Invalidating one outlier from the start of the burst
Last average cost = %f
Second-to-last average cost = %f
--Invalidating two outliers from the end of the burst
--Invalidating one outlier from the end of the burst
Number of images too few after invalidation at the endpoints. Return one selection.
Result of three-way division: finalCost: %f, inOutRatio: %f
Classified as non-action.
Classified as action.
Between %d and %d: 
motion: %f
Action mean = %f, action std = %f, action threshold = %f
Local statistics for divider %03d
 with score %f:
 noise threshold = %f, high threshold = %f (mean %f, std %f)
Overall mean divider score = %f
clusterDividerArraySize = %d
Locally-maximal divider %d not considered due to being potential noise (%f vs %f,%f)
Locally-maximal divider %d not considered due to lack of any motion: %f
Locally-maximal divider %d not considered due to being potential noise (nearby peak).
local maxima size: %ld
divider %d
Re-running three-way division with minClusterSize = %d, maxClusterSize = %d
Strongest local maxima: %d and %d
Expanding main peak to include divider %d
Adding action-based cluster boundaries.
Cluster %d is too small for action-based cluster boundaries
Action statistics for cluster %d: mean %f std %f threshold %f
Adding ACTION DIVIDER at location %d
***Finding three way division:
firstValidImage = %d, lastValidImage = %d
NEW BEST: largestInnerDistance = %f, bestRatio = %f
Divider1 = %d, Divider2 = %d
RECURSING: (%d->%d) becomes (%d->%d)
Clustering costs: maxInner = %f, inOutRatio = %f
Threshold for dupes: %f
Distance between selections %d and %d: %f, %f
Selection score of %d is %f... isGarbage = %d
Choosing candidate %d from a series of dupes
Throwing away all dupes due to garbage classification
Keeping candidate %d
Tossing out the %s on %d
trash
reject
All images are garbage. Picking the middle selection = %s.
-[CPUFaceMask clearOutputMask:WithBytesPerRow:OutputRegion:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/AutoEnhance/Portrait/CPUFaceMask.m
outputMaskBaseAddr
-[CPUFaceMask trainSkinMaskUsingInputImage:InputBytesPerRow:InputRegion:QuadRegion:]
inputBGRAImageBaseAddr
-[CPUFaceMask findSkinMaskUsingInputImage:InputBytesPerRow:InputRegion:OutputMask:OutputBytesPerRow:OutputRegion:FaceBounds:SeedPoints:NumberOfSeedPoints:FillValue:]
seedPoints
-[CPUFaceMask findToothMaskUsingInputImage:InputBytesPerRow:InputRegion:OutputMask:OutputBytesPerRow:OutputRegion:TeethBounds:SeedPoints:NumberOfSeedPoints:FillValue:]
-[CPUFaceMask drawEyeMaskUsingQuads:OutputMask:OutputBytesPerRow:OutputRegion:]
eyeQuads
eyeQuads->nQuads <= FACEMASK_MAX_NEYEQUADS
dilateRadius
Ti,N,V_dilateRadius
erodeRadius
Ti,N,V_erodeRadius
render
v24@?0^v4L8L12L16L20
v24@?0r^v4L8L12L16L20
Projections error %d:%s in %s @ %s:%d
FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/api/Burst/Projections/FastRegistration_Core.c
FastRegistration error %d:%s in %s @ %s:%d
FastRegistration_status FastRegistration_register(const FastRegistration_Signatures *, const FastRegistration_Signatures *, float, dispatch_queue_t, float *, float *, float *, float *)
FastRegistration_status FastRegistration_processProjections(float *, vImagePixelCount)
!!! you should not read this !!!
error with the projections computation
vImage error
out of bounds error
memory allocation error
invalid parameter
invalid option
internal error
v8@?0r^{__IOSurface=}4
ProviderNode::surface
ProvAssembled %llu
ProvAssembled %p
ProvTile %llu
ProvTile
v8@?0^{__IOSurface=}4
provider %s %ldx%ld
 tile %zu,%zu
 tile %zu
 nearestsampling
 cache
v12@?0^{roiData={CGRect={CGPoint=ff}{CGSize=ff}}{vector<CI::SerialRectArray::parentROI, std::__1::allocator<CI::SerialRectArray::parentROI> >=^{parentROI}^{parentROI}{__compressed_pair<CI::SerialRectArray::parentROI *, std::__1::allocator<CI::SerialRectArray::parentROI> >=^{parentROI}}}i}4r^{__wrap_iter<CI::SerialRectArray::parentROI *>=^{parentROI}}8
alpha_premul
alpha_one
alpha_unpremul
alpha_premul-clear-edges
alpha_unpremul-clear-edges
alpha_unknown
edge_clamp
edge_unknown
10.5
inputCount
inputScale
CIAreaHistogram requires inputCount >= 1 and <= 2048
CIAreaHistogram area width or height is greater than 32768.
CIAreaHistogram outputData requires inputCount >= 1 and <= 256
CIExposureAdjust
CIAreaHistogram failed to allocate memory.
CIAreaHistogram_%dbins
{CGRect={CGPoint=ff}{CGSize=ff}}20@?0{CGRect={CGPoint=ff}{CGSize=ff}}4
v12@?0@"<CIImageProcessorInput>"4@"<CIImageProcessorOutput>"8
inputImage
T@"CIImage",&,N,VinputImage
inputExtent
T@"CIVector",&,N,VinputExtent
T@"NSNumber",&,N,VinputScale
T@"NSNumber",&,N,VinputCount
processHistogram
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/CIAreaHistogram.mm
!hist8
hist8
false
kernel vec4 _edgeWork(__sample src, __sample blurred)
  float lum = dot(src.rgb, vec3(0.299, 0.587, 0.114));
  float blum = dot(blurred.rgb, vec3(0.299, 0.587, 0.114));
  return vec4(clamp((lum - blum) * 1000.0, 0.0, 1.0));
kernel vec4 _edgeWorkContrast(__sample src, float contrast)
  return clamp((src - 0.5) * contrast + 0.5, 0.0, 1.0);
10.4
slab_alloc
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/util/x-alloc.c
slab->magic == SLAB_MAGIC (bucket_idx)
slab_dealloc
size
x-alloc
{CGRect={CGPoint=ff}{CGSize=ff}}24@?0i4{CGRect={CGPoint=ff}{CGSize=ff}}8
T@"CIImage",&,VinputImage
inputFocusRect
fullROI
10.13
inputNeedsGammaCorrection
kernel vec4 _transitionDepths(__sample edges,__sample depthLo) { float v = float((edges.r) > 0.5)*depthLo.r; return vec4(v,v,v,1.0); }
CISobelHV
CIMorphologyMaximum
T@"CIVector",C,N,VinputFocusRect
T@"NSNumber",C,N,VinputScale
inputMaxNumVertices
inputSigmaS
inputSigmaRLuma
inputSigmaRChroma
inputLambda
inputMaxNumIterations
inputBandRange
inputThresholdOffset
inputFilterCut
inputFeatherBandRange
inputAdaptiveThresholdRange
inputSigmaFallout
kernel vec4 _renormalize01(__sample a,__sample b) { float zmin = b.r; float zmax = b.g; float v = (a.r - zmin)/(zmax-zmin); return vec4(v,v,v,1.0); }
kernel vec4 _featherBand(__sample image,__sample threshold,__sample mm,vec3 params) { 
  float zMin = mm.r;
  float zMax = mm.g;
  float zRange = zMax - zMin;
  float lowerBandOffset  = -params.y * zRange;
  float upperBandOffset  = -params.x * zRange;
  float featherBandRange =  params.z * zRange;
  float bandRange = upperBandOffset - lowerBandOffset;
  float bandCenter = threshold.r + lowerBandOffset + bandRange / 2.0;
  float band = abs(image.r - bandCenter) - bandRange / 2.0;
  band = 1.0 - smoothstep(0.0, featherBandRange, band);
   return vec4(band,band,band,1.0);
kernel vec4 _protectInterior(__sample C,__sample band) { 
   float v = max(min(C.r - band.r * 0.5,0.999),1e-4);
   return vec4(v,v,v,1.0);
kernel vec4 _invertImage(__sample a) { float v = 1.0 - a.r; return vec4(v,v,v,1.0); }
kernel vec4 _normalizeToPhysicalDepth(__sample threshold,__sample mm,float thresholdOffset) { float v = threshold.r + thresholdOffset *(1.0 -threshold.r)/(mm.g-mm.r);  return vec4(v,v,v,1.0); }
kernel vec4 _foreground(__sample mask,__sample threshold) { float v = (mask.r < threshold.r) ? mask.r : 0.0; return vec4(v,v,v,1.0); }
kernel vec4 _filterCut(__sample mask,__sample threshold,float filterCut) {
  float v = min(1.0, mask.r * filterCut / threshold.r);
  return vec4(v,v,v,1.0); }
kernel vec4 _bb3Mono(sampler a) { 
   float r = 0.0;
   vec2 dc = destCoord();
   r += sample(a,samplerTransform(a, dc + vec2(-1.0, -1.0))).r;
   r += sample(a,samplerTransform(a, dc + vec2(-1.0,  0.0))).r;
   r += sample(a,samplerTransform(a, dc + vec2(-1.0,  1.0))).r;
   r += sample(a,samplerTransform(a, dc + vec2( 0.0, -1.0))).r;
   r += sample(a,samplerTransform(a, dc + vec2( 0.0,  0.0))).r;
   r += sample(a,samplerTransform(a, dc + vec2( 0.0,  1.0))).r;
   r += sample(a,samplerTransform(a, dc + vec2( 1.0, -1.0))).r;
   r += sample(a,samplerTransform(a, dc + vec2( 1.0,  0.0))).r;
   r += sample(a,samplerTransform(a, dc + vec2( 1.0,  1.0))).r;
   r *= 0.111111111;
   return vec4(r,r,r,1.0);
kernel vec4 _denormalize(__sample image, __sample minMaxImage)
    float v = image.r;
    float maxV = minMaxImage.g;
    float minV = minMaxImage.r;
    v = v * (maxV - minV) + minV;
    return vec4(v,v,v,1.0);
kernel vec4 _confidenceConvertToHalfFloat (__sample c) __attribute__((outputFormat(kCIFormatRGBAh))) {
  return c;
kernel vec4 _renormalizeThreshold(__sample threshold,__sample disparityMinMax) { 
  float minV = disparityMinMax.x; 
  float maxV = disparityMinMax.y; 
  float range = maxV - minV; 
  float absoluteThreshold = threshold.r; 
  float v = (absoluteThreshold - minV) / max(0.0001,range); 
  return vec4(v,v,v,1.0); 
CIAreaMinMaxRed
CIConfidenceMap
CILinearToSRGBToneCurve
CIFastBilateralSolver
inputConfidenceMapImage
CIBoxBlur3_7
CIColorMatrix
inputRVector
inputGVector
inputBVector
inputDisparityImage
T@"CIImage",&,VinputDisparityImage
inputThresholdImage
T@"CIImage",&,VinputThresholdImage
T@"NSNumber",C,N,VinputMaxNumVertices
T@"NSNumber",C,N,VinputSigmaS
T@"NSNumber",C,N,VinputSigmaRLuma
T@"NSNumber",C,N,VinputSigmaRChroma
T@"NSNumber",C,N,VinputLambda
T@"NSNumber",C,N,VinputMaxNumIterations
T@"CIVector",&,VinputBandRange
T@"NSNumber",C,N,VinputThresholdOffset
T@"NSNumber",C,N,VinputFilterCut
T@"NSNumber",C,N,VinputFeatherBandRange
T@"NSNumber",C,N,VinputAdaptiveThresholdRange
T@"NSNumber",C,N,VinputSigmaFallout
kernel vec4 _confidenceExtractRed (__sample c) __attribute__((outputFormat(kCIFormatRh))) {
  return vec4(c.r, 0.0, 0.0, 1.0);
CISRGBToneCurveToLinear
CIGaussianBlur
kernel vec4 _boxBlur3_7_H(sampler image)
    vec2 dc = destCoord();
    float c =  sample(image, samplerTransform(image, dc + vec2(-7.0, 0.0))).r * 0.0005;
         c += sample(image, samplerTransform(image, dc + vec2(-6.0, 0.0))).r * 0.0032;
         c += sample(image, samplerTransform(image, dc + vec2(-5.0, 0.0))).r * 0.0128;
         c += sample(image, samplerTransform(image, dc + vec2(-4.0, 0.0))).r * 0.0352;
         c += sample(image, samplerTransform(image, dc + vec2(-3.0, 0.0))).r * 0.0736;
         c += sample(image, samplerTransform(image, dc + vec2(-2.0, 0.0))).r * 0.1216;
         c += sample(image, samplerTransform(image, dc + vec2(-1.0, 0.0))).r * 0.1632;
         c += sample(image, samplerTransform(image, dc + vec2( 0.0, 0.0))).r * 0.1797;
         c += sample(image, samplerTransform(image, dc + vec2( 1.0, 0.0))).r * 0.1632;
         c += sample(image, samplerTransform(image, dc + vec2( 2.0, 0.0))).r * 0.1216;
         c += sample(image, samplerTransform(image, dc + vec2( 3.0, 0.0))).r * 0.0736;
         c += sample(image, samplerTransform(image, dc + vec2( 4.0, 0.0))).r * 0.0352;
         c += sample(image, samplerTransform(image, dc + vec2( 5.0, 0.0))).r * 0.0128;
         c += sample(image, samplerTransform(image, dc + vec2( 6.0, 0.0))).r * 0.0032;
         c += sample(image, samplerTransform(image, dc + vec2( 7.0, 0.0))).r * 0.0005;
        
    return vec4(c,c,c,1.0);
kernel vec4 _boxBlur3_7_V(sampler image)
    vec2 dc = destCoord();
    float c =  sample(image, samplerTransform(image, dc + vec2(0.0, -7.0))).r * 0.0005;
         c += sample(image, samplerTransform(image, dc + vec2(0.0,-6.0))).r * 0.0032;
         c += sample(image, samplerTransform(image, dc + vec2(0.0,-5.0))).r * 0.0128;
         c += sample(image, samplerTransform(image, dc + vec2(0.0,-4.0))).r * 0.0352;
         c += sample(image, samplerTransform(image, dc + vec2(0.0,-3.0))).r * 0.0736;
         c += sample(image, samplerTransform(image, dc + vec2(0.0,-2.0))).r * 0.1216;
         c += sample(image, samplerTransform(image, dc + vec2(0.0,-1.0))).r * 0.1632;
         c += sample(image, samplerTransform(image, dc + vec2(0.0, 0.0))).r * 0.1797;
         c += sample(image, samplerTransform(image, dc + vec2(0.0, 1.0))).r * 0.1632;
         c += sample(image, samplerTransform(image, dc + vec2(0.0, 2.0))).r * 0.1216;
         c += sample(image, samplerTransform(image, dc + vec2(0.0, 3.0))).r * 0.0736;
         c += sample(image, samplerTransform(image, dc + vec2(0.0, 4.0))).r * 0.0352;
         c += sample(image, samplerTransform(image, dc + vec2(0.0, 5.0))).r * 0.0128;
         c += sample(image, samplerTransform(image, dc + vec2(0.0, 6.0))).r * 0.0032;
         c += sample(image, samplerTransform(image, dc + vec2(0.0, 7.0))).r * 0.0005;
        
    return vec4(c,c,c,1.0);
kernel vec4 _sobelHV(sampler image)        {
            vec2 dc = destCoord();
    float c0 = sample(image, samplerTransform(image, dc + vec2(-1.0,1.0))).r;
    float c1 = sample(image, samplerTransform(image, dc + vec2( 0.0,1.0))).r;
    float c2 = sample(image, samplerTransform(image, dc + vec2( 1.0,1.0))).r;
    float c3 = sample(image, samplerTransform(image, dc + vec2(-1.0,0.0))).r;
    float c5 = sample(image, samplerTransform(image, dc + vec2( 1.0,0.0))).r;
    float c6 = sample(image, samplerTransform(image, dc + vec2(-1.0,-1.0))).r;
    float c7 = sample(image, samplerTransform(image, dc + vec2( 0.0,-1.0))).r;
    float c8 = sample(image, samplerTransform(image, dc + vec2( 1.0,-1.0))).r;
    float h = abs((c0 + 2.0 * c1 + c2) - (c6 + 2.0 * c7 + c8));
    float v = abs((c0 + 2.0 * c3 + c6) - (c2 + 2.0 * c5 + c8));
    float total = (h + v);
    return vec4(total, total, total, 1.0);
kernel vec4 _h9(sampler a)  { 
   float m = 0.0;
   vec2 dc = destCoord();
   for(int i = -4; i <= 4; i++) {
      m = max(m, sample(a,samplerTransform(a, dc + vec2(float(i), 0.0))).r);
   }
   return vec4(m,m,m,1.0);
kernel vec4 _v7(sampler a)  { 
   float m = 0.0;
   vec2 dc = destCoord();
   for(int i = -3; i <= 3; i++) {
      m = max(m, sample(a,samplerTransform(a, dc + vec2(float(i), 0.0))).r);
   }
   return vec4(m,m,m,1.0);
kernel vec4 _dilateRem(sampler a,sampler o) { 
   float m = sample(a, samplerCoord(a)).r;
   vec2 dc = destCoord();
   for(int i = -3; i<= 3; i++) {
      m = max(m, sample(o,samplerTransform(o, dc + vec2(float(i), 4.0))).r);
   }
   for(int i = -3; i<= 3; i++) {
      m = max(m, sample(o,samplerTransform(o, dc + vec2(float(i), -4.0))).r);
   }
   m = max(m, sample(o,samplerTransform(o, dc + vec2( 0.0, 5.0))).r);
   m = max(m, sample(o,samplerTransform(o, dc + vec2( 0.0,-5.0))).r);
   m = max(m, sample(o,samplerTransform(o, dc + vec2( 5.0, 0.0))).r);
   m = max(m, sample(o,samplerTransform(o, dc + vec2(-5.0, 0.0))).r);
   return vec4(m,m,m,1.0);
kernel vec4 _sobelHVGeoMean(sampler image)        {
            vec2 dc = destCoord();
    float c0 = sample(image, samplerTransform(image, dc + vec2(-1.0,1.0))).r;
    float c1 = sample(image, samplerTransform(image, dc + vec2( 0.0,1.0))).r;
    float c2 = sample(image, samplerTransform(image, dc + vec2( 1.0,1.0))).r;
    float c3 = sample(image, samplerTransform(image, dc + vec2(-1.0,0.0))).r;
    float c5 = sample(image, samplerTransform(image, dc + vec2( 1.0,0.0))).r;
    float c6 = sample(image, samplerTransform(image, dc + vec2(-1.0,-1.0))).r;
    float c7 = sample(image, samplerTransform(image, dc + vec2( 0.0,-1.0))).r;
    float c8 = sample(image, samplerTransform(image, dc + vec2( 1.0,-1.0))).r;
    float h = (c0 + 2.0 * c1 + c2) - (c6 + 2.0 * c7 + c8);
    float v = (c0 + 2.0 * c3 + c6) - (c2 + 2.0 * c5 + c8);
    float total = sqrt(max(0.0000001,h*h + v*v));
    return vec4(total, total, total, 1.0);
kernel vec4 _invertImages(__sample c) { float v = c.r; v = 1.0 - min(1.0,v); v = max(min(v,1.0),0.0001); return vec4(v,v,v,1.0); }
kernel vec4 _dilateDisparityEdgeDetectLuminance(sampler image, vec2 ninj,sampler lumImage){
    float m = 0.0, n = 0.0;
    vec2 dc = destCoord();
    
    int i;
    for(i = -int(ninj.x); i <= int(ninj.x); i++) {
        float v = sample(image, samplerTransform(image, dc + vec2(float(i),0.0))).r;
        n = max(v,n);
    }
    for(i = -int(ninj.y); i <= int(ninj.y); i++) {
        float v = sample(image, samplerTransform(image, dc + vec2(0.0,float(i)))).r;
        m = max(v,m);
    }
    float r = m + n;
    float c0 = sample(lumImage, samplerTransform(lumImage, dc + vec2(-1.0,1.0))).r;
    float c1 = sample(lumImage, samplerTransform(lumImage, dc + vec2( 0.0,1.0))).r;
    float c2 = sample(lumImage, samplerTransform(lumImage, dc + vec2( 1.0,1.0))).r;
    float c3 = sample(lumImage, samplerTransform(lumImage, dc + vec2(-1.0,0.0))).r;
    float c5 = sample(lumImage, samplerTransform(lumImage, dc + vec2( 1.0,0.0))).r;
    float c6 = sample(lumImage, samplerTransform(lumImage, dc + vec2(-1.0,-1.0))).r;
    float c7 = sample(lumImage, samplerTransform(lumImage, dc + vec2( 0.0,-1.0))).r;
    float c8 = sample(lumImage, samplerTransform(lumImage, dc + vec2( 1.0,-1.0))).r;
    float h = abs((c0 + 2.0 * c1 + c2) - (c6 + 2.0 * c7 + c8));
    float v = abs((c0 + 2.0 * c3 + c6) - (c2 + 2.0 * c5 + c8));
    float total = h + v;
    float result = max(total, r);
    return vec4(result,result,result,1.0);
// Kernel Source
%a %b %e %H:%M:%S %Z %Y
** Log started %s **
X_LOG_FILE
stderr
stdout
setprops
10.10
kernel vec4 _betterDown2 (sampler image)
  vec4 U = sample(image, samplerTransform(image, destCoord()*2.0 + vec2(0.0, 1.0))); 
  vec4 D = sample(image, samplerTransform(image, destCoord()*2.0 + vec2(0.0,-1.0))); 
  vec4 R = sample(image, samplerTransform(image, destCoord()*2.0 + vec2( 1.0,0.0))); 
  vec4 L = sample(image, samplerTransform(image, destCoord()*2.0 + vec2(-1.0,0.0))); 
  return (U+D+L+R)*0.25; 
kernel vec4 _maskedVariableBlur (__sample mask, 
    __sample c0, __sample c1, __sample c2, __sample c3, __sample c4, __sample c5, __sample c6, 
    float maxBlur) 
  float k = mask.y; 
  k = clamp(k, 0.0, 1.0); 
  float m = k*maxBlur; 
  m = log2(m*4.0/3.0); 
  m = max(m,0.0); 
  float mLo = floor(m); 
  vec4 cLo = c0; 
  vec4 cHi = c1; 
  cLo =  (mLo > 0.5) ? c1 : cLo; 
  cHi =  (mLo > 0.5) ? c2 : cHi; 
  cLo =  (mLo > 1.5) ? c2 : cLo; 
  cHi =  (mLo > 1.5) ? c3 : cHi; 
  cLo =  (mLo > 2.5) ? c3 : cLo; 
  cHi =  (mLo > 2.5) ? c4 : cHi; 
  cLo =  (mLo > 3.5) ? c4 : cLo; 
  cHi =  (mLo > 3.5) ? c5 : cHi; 
  cLo =  (mLo > 4.5) ? c5 : cLo; 
  cHi =  (mLo > 4.5) ? c6 : cHi; 
  cLo =  (mLo > 5.5) ? c6 : cLo; 
  return mix(cLo,cHi,m-mLo); 
CISoftCubicUpsample
inputMask
T@"CIImage",&,N,VinputMask
inputRadius
T@"NSNumber",&,N,VinputRadius
faceId
Ti,VfaceId
faceRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VfaceRect
framesSinceLast
Ti,VframesSinceLast
maxScore
Tf,VmaxScore
minScore
Tf,VminScore
numScores
Ti,VnumScores
swFaceId
Ti,VswFaceId
swCenter
T{CGPoint=ff},VswCenter
swSize
T{CGSize=ff},VswSize
swLastFrameSeen
Ti,VswLastFrameSeen
hwFaceId
Ti,VhwFaceId
hwCenter
T{CGPoint=ff},VhwCenter
hwSize
T{CGSize=ff},VhwSize
hwLastFrameSeen
Ti,VhwLastFrameSeen
true
FCRSetupParamLoadModelFiles
    orientation = %d
Number of HW faces = %d - calculating rect
   hwFaceRect: (%.3f,%.3f,%.3f,%.3f), hasLeftEye = %d, hasRightEye = %d
   face %d = (%.3f,%.3f,%.3f,%.3f)
   fcrect  = (%.3f,%.3f,%.3f,%.3f)
   inserting prev face (hw%d,sw=%d) = (%.3f,%.3f,%.3f,%.3f) padding=(%.3f,%.3f)
  needFaceCore = %d
setting faces ROI to (%.3f,%.3f,%.3f,%.3f)
{CGRect={CGPoint=ff}{CGSize=ff}}
i12@?0@"FCRFace"4@"FCRFace"8
Face detection error
extractDetails error: %s
face %d: rect = %.3f,%.3f,%.3f,%.3f, leftOpen=%d,rightOpen=%d
  #faces = %d
calculateFaceFocus:
   adding rect: %.3f,%.3f,%.3f,%.3f
   focusScore = %d, %.3f
AdjustFaceIds: Examining '%s'
faceStat.id = %d
    rename found: %d mapped to %d
    new id: %d mapped to %d
    no id: assigning %d
    map found: %d maps to %d
       entry exists with same id: %d
%d faces so far unmatched:
    face %d
    %d overlaps with %d by %.3f %% : 
    matched!  mapping %d to %d
    not matched
      no match found for id %d - adding face
  prevConfig has %d entries
Found mapping!
   mapping not found for %d, mapping to itself
removing config entry: %d
Timestamp
  face ID = %d, timestamp = %.6f
FaceID
Rect
Width
Height
    inserting at index %d, count=%d
  extractFacesFromMetadata
extractFaceMetadata: invalid properties
AccumulatedFaceMetadata
  accumulatedFaceMetadata = %x
adding %d faces
Regions
regions exist
RegionList
  num regions = %d
    latestFaceTimestamp = %.6f
addFacesToImageStat: timestamp = %.6f, lastFaceIndex=%d
    imageTimestamp > latestFaceTimestamp
RollAngle
YawAngle
LeftEyeX
LeftEyeY
LeftEyeWidth
LeftEyeHeight
LeftEyeBlinkLevel
RightEyeX
RightEyeY
RightEyeWidth
RightEyeHeight
RightEyeBlinkLevel
SmileLevel
      found face id %d, timestamp=%.6f, x=%.3f,y=%.3f,w=%.3f,h=%.3f
    adding face id %d, timestamp %.6f
    face id %d, timestamp %.6f - delta = %.6f, perhaps should use FaceCore
FaceInfoArray:
hwId = %d (lastSeen=%d, ctr=%.3f,%.3f size=%.3f,%.3f), swId = %d (lastSeen=%d, ctr=%.3f,%.3f size=%.3f,%.3f)
timeFaceDetectionDone
Td,VtimeFaceDetectionDone
timeBlinkDetectionDone
Td,VtimeBlinkDetectionDone
forceFaceDetectionEnable
TB,VforceFaceDetectionEnable
latestFaceTimestamp
Td,VlatestFaceTimestamp
leftEyeOpen
TB,VleftEyeOpen
rightEyeOpen
TB,VrightEyeOpen
smiling
TB,Vsmiling
leftEyeBlinkScore
Tf,VleftEyeBlinkScore
rightEyeBlinkScore
Tf,VrightEyeBlinkScore
smileScore
Tf,VsmileScore
hasLeftEye
TB,VhasLeftEye
hasRightEye
TB,VhasRightEye
foundByFaceCore
TB,VfoundByFaceCore
normalizedFaceRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VnormalizedFaceRect
focusScore
Tf,VfocusScore
faceScore
Tf,VfaceScore
leftEyeRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VleftEyeRect
rightEyeRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VrightEyeRect
FCRLeftEyeFeaturesOffset
Ti,VFCRLeftEyeFeaturesOffset
FCRRightEyeFeaturesOffset
Ti,VFCRRightEyeFeaturesOffset
FCRSmileFeaturesOffset
Ti,VFCRSmileFeaturesOffset
FCRBlinkFeaturesSize
Ti,VFCRBlinkFeaturesSize
FCRSmileFeaturesSize
Ti,VFCRSmileFeaturesSize
FCRSmileAndBlinkFeatures
T@"NSMutableArray",VFCRSmileAndBlinkFeatures
hwFaceRect
T{CGRect={CGPoint=ff}{CGSize=ff}},V_hwFaceRect
normalizedFocusScore
Tf,VnormalizedFocusScore
normalizedSigma
Tf,VnormalizedSigma
hasRollAngle
TB,VhasRollAngle
hasYawAngle
TB,VhasYawAngle
rollAngle
Tf,VrollAngle
yawAngle
Tf,VyawAngle
timestamp
Td,Vtimestamp
isSyncedWithImage
TB,V_isSyncedWithImage
smallFace
TB,VsmallFace
Image_ImageROIGridStartX
Image_ImageROIGridStartY
Image_ImageROIGridEndX
Image_ImageROIGridEndY
Original ROI = %d,%d -> %d,%d
Smoothed ROI = %d,%d -> %d,%d
Sharpness ROI for %s updated to (%d,%d)->(%d,%d)
%s REGISTERED AGAINST %s
Registration result: tx = %d, ty = %d
----------REGISTRATION ERROR INTEGRAL 
Row interval: (%d->%d)
Column interval: (%d->%d)
sensedROI = (%d,%d)->(%d,%d)
referenceROI = (%d,%d)->(%d,%d)
Registration rejected due to ROI too large or too small.
Registration in favor of face detection ROI.
Registration rejected due to skewness, which can indicate a bad registration result.
Registration rejected due to insufficient local motion.
----------------------- facecore count = %d, numHWFaces = %d
Limited ROI = (%d,%d)->(%d,%d)
Computing sharpness over grid points (%d,%d)->(%d,%d)
After collapse avgHorzDiffY = %f, blurExtent = %f
Num HW faces = %d, facecore faces = %d
combined normalized focus score for face core detections = %f
Limited sharpness score = %f, with number of faces = %d
Thumbnail selection score computation for %s
Average facial focus score = %f
Initial score (no faces) = %f (isGarbage = %d)
Action selection score = %f
imageId
T@"NSString",VimageId
orientation
Ti,Vorientation
faceStatArray
T@"NSMutableArray",VfaceStatArray
exclude
TB,Vexclude
AEStable
TB,VAEStable
AEAverage
Ti,VAEAverage
AETarget
Ti,VAETarget
AFStable
TB,VAFStable
avgHorzDiffY
Tf,VavgHorzDiffY
blurExtent
Tf,VblurExtent
imageScore
Tf,VimageScore
actionScore
Tf,VactionScore
timeReceived
Td,VtimeReceived
maxSkewness
Tf,VmaxSkewness
registrationErrorX
Tf,VregistrationErrorX
registrationErrorY
Tf,VregistrationErrorY
registrationErrorIntegral
Tf,VregistrationErrorIntegral
actionClusteringScore
Tf,VactionClusteringScore
hasRegistrationData
TB,VhasRegistrationData
facesRoiRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VfacesRoiRect
numHWFaces
Ti,VnumHWFaces
emotionallyRejected
TB,VemotionallyRejected
doLimitedSharpnessAndBlur
TB,VdoLimitedSharpnessAndBlur
Tf,Vtx
Tf,Vty
isGarbage
TB,VisGarbage
roiSize
Tf,VroiSize
AEDelta
Ti,V_AEDelta
fullsizeJpegSize
Ti,V_fullsizeJpegSize
Registration error stats: mean=%f, stdDev=%f, skewness=%f, maxValue=%f
Insufficient peak error for ROI computation %f (threshold %f)
Peak rejection threshold = %f (mean = %f, std = %f)
Starting ROI construction at %d->%d
-[CIBarcodeDescriptor init]
-[CIBarcodeDescriptor initWithCoder:]
supportsSecureCoding
TB,R
-[CIQRCodeDescriptor isValid]
errorCorrectedPayload
symbolVersion
maskPattern
errorCorrectionLevel
T@"NSData",R,VerrorCorrectedPayload
Ti,R,VsymbolVersion
TC,R,VmaskPattern
Ti,R,VerrorCorrectionLevel
-[CIAztecCodeDescriptor isValid]
isCompact
layerCount
codewordCount
dataCodewordCount
TB,R,VisCompact
Ti,R,VlayerCount
Ti,R,VdataCodewordCount
-[CIPDF417CodeDescriptor isValid]
rowCount
columnCount
Ti,R,VrowCount
Ti,R,VcolumnCount
eccVersion
Ti,R,VeccVersion
kernel vec4 _triangleTile (sampler src, vec2 center, vec4 ftrans, vec4 btrans)
  vec2  t = destCoord() - center;
  t = vec2(dot(t, ftrans.xy), dot(t, ftrans.zw));
  t = fract(t);
  t = (t.x > t.y) ? t.yx : t;
  t.y = (t.y > 2.0 - t.x - t.y) ? (2.0 - t.x - t.y) : t.y;
  t.x = (t.x < 1.0 - t.x - t.y) ? (1.0 - t.x - t.y) : t.x;
  t = (t.x > t.y) ? t.yx : t;
  t = vec2(dot(t, btrans.xy), dot(t, btrans.zw));
  t += center;
  return sample(src, samplerTransform(src, t));
kernel vec4 _lozengeRefraction(sampler src, vec2 p0, vec2 p1, float radius, vec2 v01, vec2 x01, float indexOfRefraction, float levitation)
  vec2 v0 = destCoord() - p0;
  vec3 c0 = cross(vec3(v0, 0.0), vec3(v01, 0.0));
  vec2 unitvec = (c0.z < 0.0) ? x01 : -x01;
  float dist = abs(c0.z);
  float dist2 = length(v0);
  vec2 unitvec2 = normalize(v0);
  float d0 = dot(v01, v0);
  dist = (d0 < 0.0) ? dist : dist2;
  unitvec = (d0 < 0.0) ? unitvec : unitvec2;
  v0 = destCoord() - p1;
  dist2 = length(v0);
  unitvec2 = normalize(v0);
  d0 = dot(v01, v0);
  dist = (d0 < 0.0) ? dist2 : dist;
  unitvec = (d0 < 0.0) ? unitvec2 : unitvec;
  d0 = dist / radius;
  vec3 surfaceNormal = vec3(unitvec * d0, sqrt(1.0 - d0 * d0));
  float surfaceHeight = surfaceNormal.z * radius + levitation;
  float eta = 1.0 / indexOfRefraction;
  float c1 = surfaceNormal.z;
  float cs2 = 1.0 - eta * eta * (1.0 - c1 * c1);
  vec3 rayDirection = eta * vec3(0.0, 0.0, -1.0);
  c1 = eta * c1 - sqrt(abs(cs2));
  rayDirection += c1 * surfaceNormal;
  float t = - surfaceHeight / rayDirection.z;
  vec2 travel = t * rayDirection.xy;
  travel = max(min(travel, vec2(radius*2.0)), vec2(-radius*2.0));
  vec4 color = sample(src, samplerTransform(src, destCoord() + travel));
  color = (cs2 < 0.0) ? vec4(0.0, 0.0, 0.0, 0.0) : color;
  float alpha = clamp(radius - dist, 0.0, 1.0);
  vec4 unrefracted = sample(src, samplerCoord(src));
  return mix(unrefracted, color, alpha);
inputPoint0
inputPoint1
kernel vec4 _torusRefraction(sampler src, vec2 center, float a, float b, float c, float indexOfRefraction, float levitation)
  vec2 v0 = destCoord() - center;
  float dist = length(v0);
  vec2 unitvec = normalize(v0);
  float fdom = a * dist + b;
  float alpha = clamp((1.0 - abs(fdom)) * c, 0.0, 1.0);
  vec3 surfaceNormal = vec3(unitvec * fdom, sqrt(1.0 - fdom * fdom));
  float surfaceHeight = surfaceNormal.z * c + levitation;
  vec3 rayOrigin = vec3(destCoord(), surfaceHeight);
  float eta = 1.0 / indexOfRefraction;
  float c1 = surfaceNormal.z;
  float cs2 = 1.0 - eta * eta * (1.0 - c1 * c1);
  vec3 rayDirection = eta * vec3(0.0, 0.0, -1.0);
  c1 = eta * c1 - sqrt(abs(cs2));
  rayDirection += c1 * surfaceNormal;
  float t = - surfaceHeight / rayDirection.z;
  vec3 hitPoint = rayOrigin + t * rayDirection;
  if (alpha<0.001) hitPoint.xy = vec2(50.0); 
  vec4 color = sample(src, samplerTransform(src, hitPoint.xy));
  color = (cs2 < 0.0) ? vec4(0.0, 0.0, 0.0, 0.0) : color;
  vec4 unrefracted = sample(src, samplerCoord(src));
  return mix(unrefracted, color, alpha);
inputCurvesData
inputCurvesDomain
inputColorSpace
kernel vec4 _colorcurves (__sample im, sampler2D table, vec2 domain, vec2 normalizer)
  im.rgb = (im.rgb - domain.x) / (domain.y - domain.x); 
  im.rgb = clamp(im.rgb, 0.0001, 0.9999);
  return vec4(
    texture2D(table, vec2(normalizer.x * im.r + normalizer.y, 0.5)).r, 
    texture2D(table, vec2(normalizer.x * im.g + normalizer.y, 0.5)).g, 
    texture2D(table, vec2(normalizer.x * im.b + normalizer.y, 0.5)).b, 
    im.a); 
v28@?0^v4L8L12L16L20L24
CIColorCurves inputCurvesData must be of type NSData.
CIColorCurves inputCurvesData is not of the expected length.
CIColorCurves inputCurvesDomain must be of type CIVector and count 2.
CIColorCurves inputCurvesDomain X must be less than Y.
CIColorCurves inputColorSpace must be an RGB CGColorSpaceRef
T@"NSData",C,N,VinputCurvesData
T@"CIVector",&,N,VinputCurvesDomain
T@,&,N,VinputColorSpace
%@.%@
suffix
{CGAffineTransform=ffffff}
output_color_space
working_color_space
working_format
software_renderer
quality
high_quality_downsample
output_premultiplied
kCIContextCacheIntermediates
priority_request_low
disable_software_fallback
color_cube_size
share_context
default_CGImage_format
parametric_color_matching
inline_affine_matrices
kCIContextEnableBlending
kCIContextUseMetalRenderer
kCIContextAllowClampToAlpha
kCIContextIntermediateMemoryTarget
-[CIContext setObject:forKey:]
-[CIContext objectForKey:]
-[CIContext initWithEAGLContext:options:]
-[CIContext render:toBitmap:rowBytes:bounds:format:colorSpace:]
 in Simulator
-[CIContext render:toCVPixelBuffer:bounds:colorSpace:]
-[CIContext render:]
-[CIContext drawImage:inRect:fromRect:]
-[CIContext render:toTexture:target:bounds:colorSpace:]
-[CIContext render:toMTLTexture:commandBuffer:bounds:colorSpace:]
-[CIContext flatten:fromRect:format:colorSpace:]
<%@: %p (%s%s %d)
%@ MTLDevice=%p
%@ bounds=[empty]
%@ bounds=[%g %g %g %g]
%@    withCGContext: %p
%@    withGLContext: %p
%@    priority: %@
high
%@    workingSpace: %@
%@    workingFormat: %s
%@    downsampleQuality: %@
High
workingColorSpace
T^{CGColorSpace=},R,N
workingFormat
Ti,R,N
kCIFormatBGRA8, kCIFormatRGBA8, kCIFormatRGBAh or nil
CoreUI
kCIFormatBGRA8, kCIFormatRGBA8, kCIFormatRGBAh, kCIFormatRGBAf or nil
com.apple.CoreImage
com.apple.CoreImage-Internal
_internalContext
T^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@},R
peakNonVolatileSize
Ti,R
kernel vec4 _pageCurlTransition(sampler front, sampler back, sampler emap, vec4 cyl, vec2 cyloff, vec4 fbrot, vec2 fboff, vec4 hi, vec2 hioff, float radius, vec4 emapExtent)
  vec2 backPt;
  vec2 d = destCoord();
  vec2 frontPt = backPt = vec2(dot(d,cyl.xy),dot(d,cyl.zw)) + cyloff;
  float f = frontPt.x;
  float asn = sqrt(1.0-pow(frontPt.x,1.5)) - 1.0;
  float v = frontPt.x + asn*asn*0.5625;
  frontPt.x = v;
  backPt.x = (3.141592653589793 - v);
  frontPt = vec2(dot(frontPt,fbrot.xy),dot(frontPt,fbrot.zw)) + fboff;
  backPt  = vec2(dot(backPt,fbrot.xy),dot(backPt,fbrot.zw)) + fboff;
  frontPt = (f <= 0.0) ? d : frontPt;
  vec2 highPt = vec2(dot(d,hi.xy),dot(d,hi.zw)) + hioff;
  backPt = (f <= 0.0) ? highPt : backPt;
  vec4 fs = sample(front, samplerTransform(front, frontPt));
  vec4 bs = sample(back, samplerTransform(back, backPt));
  vec2 n = clamp(f * radius * cyl.xy, -1.0, 1.0);
  vec2 bn0 = ((f < 0.0) ? vec2(0.0) : n);
  bn0 = bn0 * 0.5 + 0.5;
  bn0 = bn0 * emapExtent.zw + emapExtent.xy;
  vec4 es = sample(emap, samplerTransform(emap, bn0));
  es *= bs.a;
  bs = es + (1.0 - es.a) * bs;
  vec4 pix = bs + (1.0 - bs.a) * fs;
  pix *= clamp((1.0 - f) * radius, 0.0, 1.0);
  return pix;
kernel vec4 _pageCurlTransNoEmap(sampler front, sampler back, vec4 cyl, vec2 cyloff, vec4 fbrot, vec2 fboff, vec4 hi, vec2 hioff, float radius)
  vec2 backPt;
  vec2 d = destCoord();
  vec2 frontPt = backPt = vec2(dot(d,cyl.xy),dot(d,cyl.zw)) + cyloff;
  float f = frontPt.x;
  float asn = sqrt(1.0-pow(frontPt.x,1.5)) - 1.0;
  float v = frontPt.x + asn*asn*0.5625;
  frontPt.x = v;
  backPt.x = (3.141592653589793 - v);
  frontPt = vec2(dot(frontPt,fbrot.xy),dot(frontPt,fbrot.zw)) + fboff;
  backPt  = vec2(dot(backPt,fbrot.xy),dot(backPt,fbrot.zw)) + fboff;
  frontPt = (f <= 0.0) ? d : frontPt;
  vec2 highPt = vec2(dot(d,hi.xy),dot(d,hi.zw)) + hioff;
  backPt = (f <= 0.0) ? highPt : backPt;
  vec4 fs = sample(front, samplerTransform(front, frontPt));
  vec4 bs = sample(back, samplerTransform(back, backPt));
  vec4 pix = bs + (1.0 - bs.a) * fs;
  pix *= clamp((1.0 - f) * radius, 0.0, 1.0);
  return pix;
CISourceOverCompositing
kernel vec4 _pageCurlWithShadowTransition (sampler front, sampler back, vec4 cyl, vec2 cyloff, vec4 fbrot, vec2 fboff, vec4 hi, vec2 hioff, float radius, vec4 shadowDims, float shadowSize, float shadowAmount, vec4 sheenBright, vec4 sheenDark)
  float shadowSizeBack = 2.5;
  float pi = 3.141592653589793;
  vec2 frontPt, frontPtAlt, backPt, backPtAlt, highPt;
  vec2 d = destCoord();
  vec2 dcyl = vec2(dot(d,cyl.xy),dot(d,cyl.zw)) + cyloff;
  frontPt = frontPtAlt = dcyl;
  backPt  = backPtAlt  = dcyl;
  float f = frontPt.x;
  float asn = sqrt(1.0-pow(f,1.5)) - 1.0;
  frontPt.x = (f <= 0.0) ? f : ((f >= 1.0) ? 9999.0*f : f + asn*asn*0.5625);
  float ss = f + 0.570796326794897 * smoothstep(0.607,1.3,f);
  asn = sqrt(1.0-pow(f,1.5)) - 1.0;
  frontPtAlt.x = (f <= 0.0) ? f : ((f >= 0.9) ? ss : f + asn*asn*0.5625);
  backPt.x    = pi - frontPt.x;
  backPtAlt.x = pi - frontPtAlt.x;
  frontPt    = vec2(dot(frontPt,fbrot.xy),dot(frontPt,fbrot.zw)) + fboff;
  frontPtAlt = vec2(dot(frontPtAlt,fbrot.xy),dot(frontPtAlt,fbrot.zw)) + fboff;
  backPt     = vec2(dot(backPt,fbrot.xy),dot(backPt,fbrot.zw)) + fboff;
  backPtAlt  = vec2(dot(backPtAlt,fbrot.xy),dot(backPtAlt,fbrot.zw)) + fboff;
  frontPtAlt = mix(frontPtAlt, d, 2.0*shadowSize);
  frontPt = (f < 0.0) ? d : frontPt;
  highPt = vec2(dot(d,hi.xy),dot(d,hi.zw)) + hioff;
  backPt = (f < 0.0) ? highPt : backPt;
  backPtAlt = mix(backPtAlt, highPt, 2.0*shadowSize);
  vec4 fs = sample(front, samplerTransform(front, frontPt));
  fs *= clamp((1.0 - f) * radius, 0.0, 1.0);
  vec4 bs = sample(back, samplerTransform(back, backPt));
  bs *= clamp((1.0 - f) * radius, 0.0, 1.0);
  float sl = (f<0.0) ? 0.0 : f;
  sl = clamp(2.5 * (sl - 0.6), 0.0, 1.0);
  sl = (sl > 0.75) ? (0.4 + 15.0 * (sl - 0.82) * (sl - 0.82)) : (0.35 * sl + 0.375 * sl * sl);
  vec4 shading = mix(sheenBright, sheenDark, sl);
  shading *= bs.a;
  bs = shading + (1.0-shading.a)*bs;
  vec4 one = vec4(1.0);
  vec4 zero = vec4(0.0);
  float light = 0.0;
  float netH, rr;
  netH = mix(2.0, 0.5*shadowSizeBack, smoothstep(0.5,1.0,f));
  netH = mix(2.3, netH, fs.a);
  rr = netH * shadowSize * radius;
  vec4 pp1 = vec4(backPtAlt.xy-shadowDims.xy, shadowDims.zw-backPtAlt.xy)/rr;
  vec4 v4 = 0.5 + 0.64*pp1 - 0.14*pp1*pp1*pp1;
  v4 = compare(pp1+one, zero, v4);
  vec4 ss1 = compare(pp1-one, v4, one);
  float xx = (1.0-f)/(netH * shadowSize);
  float fv = 0.5 + 0.64*xx - 0.14*xx*xx*xx;
  fv = (xx<=-1.0) ? 0.0 : fv;
  fv = (xx>=1.0)  ? 1.0 : fv;
  light = ss1.x * ss1.y * ss1.z * ss1.w * fv;
  light = clamp(light, 0.0, 1.0);
  }  float light2;
  float netH, rr;
  netH = clamp(f*f,0.0,1.5)*0.65;
  netH = (f<0.0) ? 0.0 : netH;
  rr = netH * shadowSize * shadowSizeBack * radius;
  vec4 pp2 = vec4(frontPtAlt.xy-shadowDims.xy, shadowDims.zw-frontPtAlt.xy)/rr;
  vec4 v4 = 0.5 + 0.64*pp2 - 0.14*pp2*pp2*pp2;
  v4 = compare(pp2+one, zero, v4);
  vec4 ss2 = compare(pp2-one, v4, one);
  float xx = (1.0-f)/(shadowSize * shadowSizeBack);
  float fv = 0.5 + 0.64*xx - 0.14*xx*xx*xx;
  fv = (xx<=-1.0) ? 0.0 : fv;
  fv = (xx>=1.0)  ? 1.0 : fv;
  light2 = ss2.x * ss2.y * ss2.z * ss2.w * fv;
  light2 *= 1.0 - fs.a;
  light2 *= clamp(f*1.0, 0.0, 1.0);
  light2 = clamp(light2, 0.0, 1.0);
  if (f<0.0) light2 = 0.0;  }  light = max(light, light2);
  light = min(light, 0.5);
  vec4 shadow = vec4(0.0, 0.0,0.0, light*shadowAmount);
  vec4 pix = fs;
  pix = shadow + (1.0-shadow.a)*pix;
  pix = bs + (1.0-bs.a)*pix;
  return pix;
kernel vec4 _pageCurlNoShadowTransition (sampler front, sampler back, vec4 cyl, vec2 cyloff, vec4 fbrot, vec2 fboff, vec4 hi, vec2 hioff, float radius, vec4 sheenBright, vec4 sheenDark)
  float pi = 3.141592653589793;
  vec2 d = destCoord();
  vec2 dcyl = vec2(dot(d,cyl.xy),dot(d,cyl.zw)) + cyloff;
  vec2 frontPt = dcyl;
  vec2 backPt  = dcyl;
  float f = frontPt.x;
  float asn = sqrt(1.0-pow(f,1.5)) - 1.0;
  frontPt.x = (f <= 0.0) ? f : ((f >= 1.0) ? 9999.0*f : f + asn*asn*0.5625);
  backPt.x  = pi - frontPt.x;
  frontPt = vec2(dot(frontPt,fbrot.xy),dot(frontPt,fbrot.zw)) + fboff;
  backPt  = vec2(dot(backPt,fbrot.xy),dot(backPt,fbrot.zw)) + fboff;
  frontPt = (f < 0.0) ? d : frontPt;
  vec2 highPt = vec2(dot(d,hi.xy),dot(d,hi.zw)) + hioff;
  backPt = (f < 0.0) ? highPt : backPt;
  vec4 fs = sample(front, samplerTransform(front, frontPt));
  fs *= clamp((1.0 - f) * radius, 0.0, 1.0);
  vec4 bs = sample(back, samplerTransform(back, backPt));
  bs *= clamp((1.0 - f) * radius, 0.0, 1.0);
  float sl = (f<0.0) ? 0.0 : f;
  sl = clamp(2.5 * (sl - 0.6), 0.0, 1.0);
  sl = (sl > 0.75) ? (0.4 + 15.0 * (sl - 0.82) * (sl - 0.82)) : (0.35 * sl + 0.375 * sl * sl);
  vec4 shading = mix(sheenBright, sheenDark, sl);
  shading *= bs.a;
  bs = shading + (1.0-shading.a)*bs;
  return bs + (1.0-bs.a)*fs;
10.9
inputShadowSize
inputShadowAmount
inputShadowExtent
__WrappedNSNumber
outputImage
CIRequiresKeyedArchiver
CoreImage requires keyed archiving.
CICS_%@
CI_%@
-[CIFilter encodeWithCoder:]_block_invoke
CIName
CIVersion
CIUserInfo
-[CIFilter initWithCoder:]_block_invoke
<%@: 
%@inputVersion=%@ 
%@%@=%@%c
-[CIFilter apply:arguments:options:]
regionOf:destRect:userInfo:
regionOf:destRect:
DGCurvesFilter
PXSoftProofingFilter
-[CIFilter apply:arguments:options:]_block_invoke
PX_CIF_Noise
-[CIFilter apply:arguments:options:]_block_invoke_2
T@"CIImage",R,D,N
name
T@"NSString",C,N
enabled
TB,GisEnabled,V_enabled
inputKeys
T@"NSArray",R,N
outputKeys
attributes
T@"NSDictionary",R,N
input%@
%@,%@=%@
%@,%@="%s"
%@,%@=nil
CIAffineTransform
CICrop
+[CIFilter(Private) _propertyArrayFromFilters:inputImageExtent:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/api/CIFilter.mm
affineFilter != nil || cropFilter != nil
inputRectangle
http://ns.adobe.com/camera-raw-settings/1.0/
CropAngle
CropTop
CropBottom
CropLeft
CropRight
HasCrop
AlreadyApplied
http://ns.apple.com/adjustment-settings/1.0/
Filters
CIRedEyeCorrections
CIFaceBalance
CIVibrance
CIToneCurve
CIHighlightShadowAdjust
+[CIFilter(Private) _filterArrayFromProperties:]
CIAttributeFilterName
CIAttributeFilterDisplayName
CIAttributeDescription
CIAttributeFilterAvailable_Mac
CIAttributeFilterAvailable_iOS
CIAttributeReferenceDocumentation
CIAttributeFilterCategories
CIAttributeClass
CIAttributeType
CIAttributeMin
CIAttributeMax
CIAttributeSliderMin
CIAttributeSliderMax
CIAttributeDefault
CIAttributeIdentity
CIAttributeName
CIAttributeDisplayName
CIUIParameterSet
CIUISetBasic
CIUISetIntermediate
CIUISetAdvanced
CIUISetDevelopment
CIAttributeTypeTime
CIAttributeTypeScalar
CIAttributeTypeDistance
CIAttributeTypeAngle
CIAttributeTypeBoolean
CIAttributeTypeInteger
CIAttributeTypeCount
CIAttributeTypePosition
CIAttributeTypeOffset
CIAttributeTypePosition3
CIAttributeTypeRectangle
CIAttributeTypeColor
CIAttributeTypeOpaqueColor
CIAttributeTypeImage
CIAttributeTypeGradient
CIAttributeTypeTransform
inputBackgroundImage
inputDepthImage
inputTime
inputTransform
inputAspectRatio
inputCenter
inputAngle
inputRefraction
inputWidth
inputSharpness
inputIntensity
inputEV
inputSaturation
inputColor
inputBrightness
inputContrast
inputGradientImage
inputBias
inputWeights
inputMaskImage
inputShadingImage
inputTargetImage
__inputVersion
CICategoryDistortionEffect
CICategoryGeometryAdjustment
CICategoryCompositeOperation
CICategoryLightingEffect
CICategoryHalftoneEffect
CICategoryColorAdjustment
CICategoryColorEffect
CICategoryTransition
CICategoryTileEffect
CICategoryGenerator
CICategoryGradient
CICategoryStylize
CICategorySharpen
CICategoryBlur
CICategoryVideo
CICategoryStillImage
CICategoryInterlaced
CICategoryNonSquarePixels
CICategoryHighDynamicRange
CICategoryApplePrivate
CICategoryReduction
CICategoryBuiltIn
CICategoryFilterGenerator
CICategoryXMPSerializable
extent
definition
user_info
color_space
cs_deviceGray
cs_deviceRGB
cs_deviceCMYK
kernel vec4 _parallelogramTile (sampler src, vec2 center, vec2 ftransx, vec2 ftransy, vec2 btransx, vec2 btransy)
  vec2 t2;
  vec2 t1 = destCoord() - center;
  t2.x = dot(t1, ftransx);
  t2.y = dot(t1, ftransy);
  t2 = fract(t2);
  t2 = min(t2, vec2(1.0) - t2);
  t2 = t2 + t2;
  t1.x = dot(t2, btransx);
  t1.y = dot(t2, btransy);
  return sample(src, samplerTransform(src, t1 + center));
inputAcuteAngle
kernel vec4 _motionBlur (sampler src, vec4 parms)
  vec2 delta = parms.xy;
  vec2 delt2 = delta * 2.0;
  vec2 p0 = samplerTransform (src, destCoord() - delt2);
  vec2 p1 = samplerTransform (src, destCoord() - delta);
  vec2 p3 = samplerTransform (src, destCoord() + delta);
  vec2 p4 = samplerTransform (src, destCoord() + delt2);
  vec4 s0 = sample (src, p0);
  vec4 s1 = sample (src, p1);
  vec4 s2 = sample (src, samplerCoord(src));
  vec4 s3 = sample (src, p3);
  vec4 s4 = sample (src, p4);
  vec2 w = parms.zw;
  return w.x * s2 + w.y * (s3 + s1 + (w.y * (s4 + s0)));
T@"NSNumber",&,N,VinputAngle
inputAmount
kernel vec4 _zoomBlur (sampler src, vec2 center, vec4 parms, vec4 w0, float w1)
  vec2 v = destCoord() - center;
  vec4 s0 = sample (src, samplerCoord (src));
  vec4 s1 = sample (src, samplerTransform (src, v * parms.x + center));
  vec4 s2 = sample (src, samplerTransform (src, v * parms.y + center));
  vec4 s3 = sample (src, samplerTransform (src, v * parms.z + center));
  vec4 s4 = sample (src, samplerTransform (src, v * parms.w + center));
  return s4*w0.x + s3*w0.y + s2*w0.z + s1*w0.w + s0*w1;
kernel vec4 _zoom (sampler src, vec2 center, float k)
  vec2 dist = destCoord() - center; 
  vec4 result = vec4(0.0); 
  for (int n=0; n<100; n++) 
  { 
    float f = float(n) / 99.0; 
    f -= 0.5; 
    f = (f + f*f*f)*0.8 + 0.5; 
    vec2 p = dist * mix(k, 1.0, f); 
    result += sample(src, samplerTransform(src, center + p)) * 0.01; 
  } 
  return result; 
T@"CIVector",&,N,VinputCenter
T@"NSNumber",&,N,VinputAmount
CIImageFlipped
CIImagePremultiplied
opaque
CIImageColorSpace
CIImageEdgesAreClear
CIImageProperties
kCIImageApplyOrientationProperty
CIImageClampToEdge
CIImageNearestSampling
CIImageEdgeRepeat
kCIImageAlphaOne
kCIImageCacheHint
kCIImageCacheImmediately
kCIImageYCCMatrix
kCIImageTextureTarget
kCIImageTextureFormat
ignorePixelFormatFor601Fixup
kCIImageAuxiliaryDepth
kCIImageAuxiliaryDisparity
kCIImageAVDepthData
CIImageSurfaceFormat
/tmp
tiff
public.png
public.tiff
-[CIImage initWithCGImage:options:]
CIImage
v12@?0^v4I8
-[CIImage initWithTexture:size:options:]
+[CIImage imageWithMTLTexture:options:]
-[CIImage initWithMTLTexture:options:]
v32@?0^v4L8L12L16L20L24L28
-[CIImage initWithCVPixelBuffer:options:]
-[CIImage initWithCVImageBuffer:options:]
-[CIImage imageByColorMatchingWorkingSpaceToColorSpace:]
-[CIImage imageByColorMatchingWorkingSpaceToRGBorGrayColorSpace:]
-[CIImage imageByColorMatchingColorSpaceToWorkingSpace:]
-[CIImage imageByTaggingWithColorSpace:]
-[CIImage imageBySettingProperties:]
-[CIImage initWithArrayOfImages:selector:]
<CIImage: %p extent [infinite]>
<CIImage: %p extent [empty]>
<CIImage: %p extent [%g %g %g %g]>
<CIImage: %p extent [infinite]>
<CIImage: %p extent [empty]>
<CIImage: %p extent [%g %g %g %g]>
CoreImage doesn't support old-style archiving
CIImageEncoder
CoreImage doesn't support archiving infinite images.
-[CIImage encodeWithCoder:]_block_invoke
-[CIImage initWithCoder:]_block_invoke
<CIImage: %p> printTree:
-[CIImage setValue:forKeyPath:]
T{CGRect={CGPoint=ff}{CGSize=ff}},R,N
properties
T@"NSDictionary",R
T@"CIFilterShape",R
T@"NSURL",R
colorSpace
T^{CGColorSpace=},R
pixelBuffer
T^{__CVBuffer=},R,N
CGImage
T^{CGImage=},R,N
depthData
T@"AVDepthData",R,N
kCIImageTextScaleFactor
tagcolorspace 
CICGImageData
CICGImageWidth
CICGImageHeight
CICGImageBPC
CICGImageBPP
CICGImageBPR
CICGImageAlphaInfo
CICGImageInterp
CICGImageRI
CIKernelMessageType
CIKernelMessageTypeNote
CIKernelMessageTypeRemark
CIKernelMessageTypeWarning
CIKernelMessageTypeError
CIKernelMessageTypeFatal
CIKernelMessageFilename
CIKernelMessageLineNumber
kCIKernelMessageOffset
kCIKernelMessageDescription
kCIKernelMessageTypeSyntaxError
kCIKernelMessageTypeInternalError
kCIKernelMessageTypeFunctionName
kCIKernelOutputFormat
<%@: %s>
vec4  compare (vec4 x, vec4 y, vec4 z)    { return mix(y, z, step(0.0,x)); }
vec3  compare (vec3 x, vec3 y, vec3 z)    { return mix(y, z, step(0.0,x)); }
vec2  compare (vec2 x, vec2 y, vec2 z)    { return mix(y, z, step(0.0,x)); }
float compare (float x, float y, float z) { return x < 0.0 ? y : z; }
vec4  cos_ (vec4 x)  { return cos(x); }
vec3  cos_ (vec3 x)  { return cos(x); }
vec2  cos_ (vec2 x)  { return cos(x); }
float cos_ (float x) { return cos(x); }
vec4  sin_ (vec4 x)  { return sin(x); }
vec3  sin_ (vec3 x)  { return sin(x); }
vec2  sin_ (vec2 x)  { return sin(x); }
float sin_ (float x) { return sin(x); }
vec4  tan_ (vec4 x)  { return tan(x); }
vec3  tan_ (vec3 x)  { return tan(x); }
vec2  tan_ (vec2 x)  { return tan(x); }
float tan_ (float x) { return tan(x); }
vec2 cossin (float x)
    return vec2(cos(x), sin(x));
vec2 cossin_ (float x)
    return vec2(cos_(x), sin_(x));
vec2 sincos (float x)
    return vec2(sin(x), cos(x));
vec2 sincos_ (float x)
    return vec2(sin_(x), cos_(x));
vec4 premultiply (vec4 s)
    return vec4(s.rgb*s.a, s.a);
vec4 unpremultiply (vec4 s)
    return vec4(s.rgb/max(s.a,0.00001), s.a);
vec3 srgb_to_linear (vec3 s)
    return sign(s)*mix(abs(s)*0.077399380804954, pow(abs(s)*0.947867298578199 + 0.052132701421801, vec3(2.4)), step(0.04045, abs(s)));
vec4 srgb_to_linear (vec4 s)
    s = unpremultiply(s);
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*0.077399380804954, pow(abs(s.rgb)*0.947867298578199 + 0.052132701421801, vec3(2.4)), step(0.04045, abs(s.rgb)));
    return premultiply(s);
vec4 _srgb_to_linear (vec4 s)
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*0.077399380804954, pow(abs(s.rgb)*0.947867298578199 + 0.052132701421801, vec3(2.4)), step(0.04045, abs(s.rgb)));
    return s;
vec3 linear_to_srgb (vec3 s)
    return sign(s)*mix(abs(s)*12.92, pow(abs(s), vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abs(s)));
vec4 linear_to_srgb (vec4 s)
    s = unpremultiply(s);
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*12.92, pow(abs(s.rgb), vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abs(s.rgb)));
    return premultiply(s);
vec4 _linear_to_srgb (vec4 s)
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*12.92, pow(abs(s.rgb), vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abs(s.rgb)));
    return s;
#define _STUB_IMPL_VEC4_ _linear_to_srgb(_srgb_to_linear(vec4(0.0)))
#define _STUB_IMPL_VEC2_ vec2(0.0)
vec2 destCoord ()
    return _dc;
vec4 sampleImage (sampler src, vec2 point)
    return _STUB_IMPL_VEC4_; // for OpenGL
vec4 sampleImage (sampler2D src, vec2 point)
    return _STUB_IMPL_VEC4_; // for OpenCL and Metal
vec2 samplerTransform (sampler src, vec2 point)
    return _STUB_IMPL_VEC2_; // for OpenGL
vec2 samplerTransform (sampler2D src, vec2 point)
    return _STUB_IMPL_VEC2_; // for OpenCL and Metal
#define samplerCoord(src) samplerTransform(src, destCoord())
vec4 samplerExtent (sampler src)
    return _STUB_IMPL_VEC4_; // for OpenGL
vec4 samplerExtent (sampler2D src)
    return _STUB_IMPL_VEC4_; // for OpenCL and Metal
#define samplerOrigin(src) samplerExtent(src).xy
#define samplerSize(src) samplerExtent(src).zw
vec4 sampleImage (vec4 src, vec2 point) { return src; }
vec2 samplerTransform (vec4 src, vec2 point) { return point; }
void writeImage (vec4 color, vec2 point) {}
void writeImagePlane (vec4 color, vec2 point) {}
void writePixel (int r, int g, int b, int a, vec2 point) {}
vec2 writeCoord () { return vec2(0.0); }
#define new _new
#define delete _delete
#define and _and
#define not _not
#define or _or
#define xor _xor
#define sample(s, p) sampleImage(s, p)
Printed AST of kernel %s:
kernel_name
kernel_gl_source
kernel_argument_types
kernel_argument_names
kernel_attributes
kernel_explicit_attributes
outputFormat
kCIFormat
+[CIKernel kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:]
kernel_metalllib
, kCIFormat
-[CIKernel applyWithExtent:roiCallback:arguments:options:]
_arg%d
CISampler
NSNumber
CIVector
CIVectorSize
CIColor
perservesAlpha
TB,N
canReduceOutputChannels
preservesRange
T@"NSString",R
-[CIColorKernel applyWithExtent:roiCallback:arguments:options:]
-[CIColorKernel applyWithExtent:roiCallback:arguments:]
-[CIColorKernel applyWithExtent:arguments:options:]
-[CIWarpKernel applyWithExtent:roiCallback:arguments:options:]
-[CIWarpKernel applyWithExtent:roiCallback:arguments:]
-[CIWarpKernel applyWithExtent:roiCallback:inputImage:arguments:options:]
{%g,%g %g x %g}
[CIKernelPool] 
note: 
remark: 
WARNING: 
ERROR: 
FATAL ERROR: 
v12@?0@"NSString"4^B8
 errors 
 error 
generated.
Expected a CIImage or a CISampler. 
Expected a leaf CIImage.
Expected an NSNumber or a CIVector of count 1. 
Expected a CIVector of count 2 or more. 
Expected a CIVector of count 3 or more. 
Expected a CIVector of count 4 or more. 
Expected a CIVector of count 4.
Expected a CIVector of count 6 or 9. 
Expected a CIVector of count 16. 
Expected a CIColor or CIVector. 
AffineImage
ApplyImage
ClampToAlphaImage
ColorMatchImage
ColorMatrixImage
CropImage
ClampImage
FillImage
GammaImage
SRGBImage
NoopImage
PremultiplyImage
ProcessorImage
PromiseImage
ProviderImage
SampleModeImage
SetPropsImage
SurfaceImage
SwitchImage
SwizzleImage
TagColorSpaceImage
TextueImage
AffineNode
ApplyNode
CGNode
ClampToAlphaNode
ColorMatrixNode
CropNode
ClampNode
GammaNode
CurveNode
FillNode
NoopNode
PremultiplyNode
ProcessorNode
PromiseNode
ProviderNode
SRGBNode
SampleModeNode
SurfaceNode
SwizzleNode
TextureNode
ProgramNode
Bitmap
Vector
Color
TextureSampler
ColorKernel
WarpKernel
GeneralKernel
ComputeKernel
MainProgram
MetalDAG
CLContext
GLContext
MetalContext
SurfaceCacheEntry
TileTask
RenderTask
BitmapDestination
PixelBufferDestination
SurfaceDestination
GLTextureDestination
MTLTextureDestination
PixelBufferProviderDestination
SurfaceProviderDestination
MTLTextureProviderDestination
Unknown enum %d
Unknown
<CI::Object %s %p ref=%u>
[infinite]
[null]
[empty]
[%g %g %g %g]
B20@?0^{GraphObject=^^?{atomic<unsigned int>=AI}}4^{GraphObject=^^?{atomic<unsigned int>=AI}}8i12i16
v20@?0^{GraphObject=^^?{atomic<unsigned int>=AI}}4^{GraphObject=^^?{atomic<unsigned int>=AI}}8i12i16
%.*sNULL
%.*s
<%ld>
 <%ld>
IOSurface %p
(%d)
 seed:%d
SurfaceNode::surface
v8@?0^v4
 rois=
 extent=
 luma opaque
 r-only opaque
 rg-only opaque
 opaque
crop 
Singular matrix 
 cannot be inverted!
[%g %g %g %g %g %g]
crop
colorkernel
warpkernel
kernel
computekernel
mainprogram
metaldag
unknownkernel
=nil
<CI::%s %p, %s>
tile_size
kCIImageProviderContentDigest
provideImageData:bytesPerRow:origin::size::userInfo:
%s provider does not implement provideImageData:bytesPerRow:origin::size::userInfo:.
-[CIImage(CIImageProvider) initWithImageProvider:size::format:colorSpace:options:]
provideImageTexture:bounds:userInfo:
CIImageProvider <%s %p> %zux%zu at %zu,%zu
%s format is not supported.
-[CIImage(CIImageProvider) _initWithImageProvider:width:height:format:colorSpace:surfaceCache:options:]
%s format %s is not supported.
CIImage kCIImageEdgeRepeat not supported.
%s kCIImageProviderTileSize value is not a NSNumber, NSArray, CIVector, or NSNull.
%s kCIImageProviderContentDigest value is not NSData of at least 32 bytes.
samplemode %s
point
nearest
linear
unknown
affine %s
loQ 
hiQ 
 outputFormat=%s
CGImageRef %p %s %ldx%ld 
processor %s
:%llX
 noPartialOutput
inputB
inputC
T@"NSNumber",&,N,VinputAspectRatio
T@"NSNumber",&,N,VinputB
T@"NSNumber",&,N,VinputC
kernel vec4 _cubicDownsample2 (sampler src, vec4 parms) 
  vec2 p = destCoord() * 2.0; 
  vec4 r = vec4(0.0); 
  float w1 = parms.x; 
  float w2 = parms.y; 
  vec4 off = vec4(-parms.wz,parms.zw); 
  r += sample(src, samplerTransform(src, p + off.xx)) * w2 * w2; 
  r += sample(src, samplerTransform(src, p + off.yx)) * w1 * w2; 
  r += sample(src, samplerTransform(src, p + off.zx)) * w1 * w2; 
  r += sample(src, samplerTransform(src, p + off.wx)) * w2 * w2; 
  r += sample(src, samplerTransform(src, p + off.xy)) * w2 * w1; 
  r += sample(src, samplerTransform(src, p + off.yy)) * w1 * w1; 
  r += sample(src, samplerTransform(src, p + off.zy)) * w1 * w1; 
  r += sample(src, samplerTransform(src, p + off.wy)) * w2 * w1; 
  r += sample(src, samplerTransform(src, p + off.xz)) * w2 * w1; 
  r += sample(src, samplerTransform(src, p + off.yz)) * w1 * w1; 
  r += sample(src, samplerTransform(src, p + off.zz)) * w1 * w1; 
  r += sample(src, samplerTransform(src, p + off.wz)) * w2 * w1; 
  r += sample(src, samplerTransform(src, p + off.xw)) * w2 * w2; 
  r += sample(src, samplerTransform(src, p + off.yw)) * w1 * w2; 
  r += sample(src, samplerTransform(src, p + off.zw)) * w1 * w2; 
  r += sample(src, samplerTransform(src, p + off.ww)) * w2 * w2; 
  return r; 
kernel vec4 _cubicDownsample2h (sampler src, vec4 parms) 
  vec2 dir = vec2(1.0,0.0); 
  vec2 p = destCoord() * vec2(2.0,1.0); 
  vec4 r = vec4(0.0); 
  vec4 off = vec4(-parms.wz,parms.zw); 
  r += sample(src, samplerTransform(src, p + dir * off.xx)) * parms.y; 
  r += sample(src, samplerTransform(src, p + dir * off.yy)) * parms.x; 
  r += sample(src, samplerTransform(src, p + dir * off.zz)) * parms.x; 
  r += sample(src, samplerTransform(src, p + dir * off.ww)) * parms.y; 
  return r; 
kernel vec4 _cubicDownsample2v (sampler src, vec4 parms) 
  vec2 dir = vec2(0.0,1.0); 
  vec2 p = destCoord() * vec2(1.0,2.0); 
  vec4 r = vec4(0.0); 
  vec4 off = vec4(-parms.wz,parms.zw); 
  r += sample(src, samplerTransform(src, p + dir * off.xx)) * parms.y; 
  r += sample(src, samplerTransform(src, p + dir * off.yy)) * parms.x; 
  r += sample(src, samplerTransform(src, p + dir * off.zz)) * parms.x; 
  r += sample(src, samplerTransform(src, p + dir * off.ww)) * parms.y; 
  return r; 
kernel vec4 _cubicDownsampleH (sampler src, vec4 scale, vec4 coefsLT1, vec4 coefsLT2) 
  vec2 dc = destCoord(); 
  vec2 dcMappedToSrc = scale.xy * dc; 
  vec2 dcMinus2MappedToSrc = scale.xy * (dc - 2.0); 
  vec2 dcPlus2MappedToSrc = scale.xy * (dc + 2.0); 
  float firstSrc = floor(dcMinus2MappedToSrc.x+0.5) + 0.5; 
  float lastSrc = floor(dcPlus2MappedToSrc.x-0.5) + 0.5; 
  vec4 r = vec4(0.0); 
  float sum = 0.0; 
  vec2 p = dcMappedToSrc; 
  float invScale = scale.z; 
  float delta = (firstSrc - dcMappedToSrc.x) * invScale; 
  for (p.x = firstSrc; p.x <= lastSrc; p.x += 1.0) 
  { 
    float x = abs(delta); 
    vec4 xvec = vec4(x*x*x, x*x, x, 1.0); 
    float weight = (x<1.0) ? dot(xvec,coefsLT1) : dot(xvec,coefsLT2); 
    r += sample(src, samplerTransform(src, p)) * weight; 
    sum += weight; 
    delta += invScale; 
  } 
  return r / sum; 
kernel vec4 _cubicDownsampleV (sampler src, vec4 scale, vec4 coefsLT1, vec4 coefsLT2) 
  vec2 dc = destCoord(); 
  vec2 dcMappedToSrc = scale.xy * dc; 
  vec2 dcMinus2MappedToSrc = scale.xy * (dc - 2.0); 
  vec2 dcPlus2MappedToSrc = scale.xy * (dc + 2.0); 
  float firstSrc = floor(dcMinus2MappedToSrc.y+0.5) + 0.5; 
  float lastSrc = floor(dcPlus2MappedToSrc.y-0.5) + 0.5; 
  vec4 r = vec4(0.0); 
  float sum = 0.0; 
  vec2 p = dcMappedToSrc; 
  float invScale = scale.w; 
  float delta = (firstSrc - dcMappedToSrc.y) * invScale; 
  for (p.y = firstSrc; p.y <= lastSrc; p.y += 1.0) 
  { 
    float x = abs(delta); 
    vec4 xvec = vec4(x*x*x, x*x, x, 1.0); 
    float weight = (x<1.0) ? dot(xvec,coefsLT1) : dot(xvec,coefsLT2); 
    r += sample(src, samplerTransform(src, p)) * weight; 
    sum += weight; 
    delta += invScale; 
  } 
  return r / sum; 
kernel vec4 _cubicUpsample10 (sampler src, vec4 scale) 
  vec2 d = scale.xy * destCoord() - 0.5; 
  vec2 c = floor(d); 
  vec2 x = (c - d + 1.0); 
  vec2 X = (d - c); 
  vec2 w1 = (-1.0/3.0)*x*x*x + 0.5*x*x + 0.5*x + 1.0/6.0; 
  vec2 w2 = 1.0 - w1; 
  vec2 o1 = (-0.5*x*x*x + 0.5*x*x + 0.5*x + 1.0/6.0) / w1 + c - 0.5; 
  vec2 o2 = (X*X*X/6.0) / w2 + c + 1.5; 
  vec4 r; 
  r  = w1.x * w1.y * sample(src, samplerTransform(src, vec2(o1.x,o1.y))); 
  r += w2.x * w1.y * sample(src, samplerTransform(src, vec2(o2.x,o1.y))); 
  r += w1.x * w2.y * sample(src, samplerTransform(src, vec2(o1.x,o2.y))); 
  r += w2.x * w2.y * sample(src, samplerTransform(src, vec2(o2.x,o2.y))); 
  return r; 
vec2 _cubic_coefs_ (vec2 x, vec4 c) 
  x = abs(x); 
  return c.x * x*x*x + c.y * x*x + c.z * x + c.w; 
kernel vec4 _cubicUpsampleX0 (sampler src, vec4 scale, vec4 coefsLT1, vec4 coefsLT2) 
  vec2 dcMappedToSrc = scale.xy * destCoord(); 
  vec2 srcCenterBefore = floor(dcMappedToSrc-0.5) + 0.5; 
  vec2 delta = srcCenterBefore - dcMappedToSrc; 
  vec2 weight0 = _cubic_coefs_(delta - 1.0, coefsLT2); 
  vec2 weight1 = _cubic_coefs_(delta      , coefsLT1); 
  vec2 weight3 = _cubic_coefs_(delta + 2.0, coefsLT2); 
  vec2 w1 = weight0 + weight1; 
  vec2 w2 = vec2(1.0) - w1; 
  vec2 o1 = compare(w1 - 0.0001, vec2(0.0), weight1 / w1) + (srcCenterBefore - 1.0); 
  vec2 o2 = compare(w2 - 0.0001, vec2(0.0), weight3 / w2) + (srcCenterBefore + 1.0); 
  vec4 r; 
  r  = w1.x * w1.y * sample(src, samplerTransform(src, vec2(o1.x,o1.y))); 
  r += w2.x * w1.y * sample(src, samplerTransform(src, vec2(o2.x,o1.y))); 
  r += w1.x * w2.y * sample(src, samplerTransform(src, vec2(o1.x,o2.y))); 
  r += w2.x * w2.y * sample(src, samplerTransform(src, vec2(o2.x,o2.y))); 
  return r; 
vec2 _cubic_coefs (vec2 x, vec4 c) 
  x = abs(x); 
  return c.x * x*x*x + c.y * x*x + c.z * x + c.w; 
kernel vec4 _cubicUpsample (sampler src, vec4 scale, vec4 coefsLT1, vec4 coefsLT2) 
  vec2 dcMappedToSrc = scale.xy * destCoord(); 
  vec2 srcCenterBefore = floor(dcMappedToSrc-0.5) + 0.5; 
  vec2 delta = srcCenterBefore - dcMappedToSrc; 
  vec4 r = vec4(0.0); 
  vec2 p; 
  vec2 w0 = _cubic_coefs(delta - 1.0, coefsLT2); 
  vec2 w1 = _cubic_coefs(delta      , coefsLT1); 
  vec2 w2 = _cubic_coefs(delta + 1.0, coefsLT1); 
  vec2 w3 = 1.0 - (w0 + w1 + w2); 
  p.y = -1.0; 
  p.x = -1.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w0.x * w0.y; 
  p.x =  0.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w1.x * w0.y; 
  p.x =  1.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w2.x * w0.y; 
  p.x =  2.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w3.x * w0.y; 
  p.y = 0.0; 
  p.x = -1.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w0.x * w1.y; 
  p.x =  0.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w1.x * w1.y; 
  p.x =  1.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w2.x * w1.y; 
  p.x =  2.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w3.x * w1.y; 
  p.y = 1.0; 
  p.x = -1.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w0.x * w2.y; 
  p.x =  0.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w1.x * w2.y; 
  p.x =  1.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w2.x * w2.y; 
  p.x =  2.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w3.x * w2.y; 
  p.y = 2.0; 
  p.x = -1.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w0.x * w3.y; 
  p.x =  0.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w1.x * w3.y; 
  p.x =  1.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w2.x * w3.y; 
  p.x =  2.0;  r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w3.x * w3.y; 
  return r; 
 roi=
com.apple.coreimage
performance
compile
CI::TileTaskQueue
%llX(%04x,%04x,%04x)
purge_wired_intermediates
Cannot handle a (%lu x %lu) sized texture with the given GLES context!
CIEAGLContextTexImageIOSurface failed for %s!
GLTextureManager::attach_IOSurface unsupported format %s!
GL_APPLE_client_storage
GL_APPLE_texture_ycbcr_basic_formats
GL_APPLE_texture_ycbcr_extended_formats
GL_EXT_color_buffer_half_float
GL_EXT_shader_texture_lod
GL_OES_texture_half_float
GL_OES_texture_float
GL_APPLE_texture_xr
finish_render
after_render
link_shaders
Program exceeds GLES%d uniform size limit. (%d > %zu)
position
texcoord
quad
GLContext::set_surface_destination unsupported format %s!
Destination buffer size too large (%lu x %lu); cannot be larger than %d x %d.
attribute highp vec4 position;
attribute highp vec4 texcoord;
varying highp vec2 p0;
void main()
  gl_Position = position;
  p0 = texcoord.xy;
varying highp vec2 p0;
uniform sampler2D s0;
void main()
  gl_FragColor = texture2D(s0, p0);
Using low GPU priority for background rendering.
readback_bitmap
bind_arguments
Unhandled type: %d
compile_kernel
// Copyright 2015 Apple Inc.
attribute highp vec4 position;
attribute highp vec4 texcoord;
varying highp vec2 p0;
uniform highp mat3 vertexTransform;
void main()
  gl_Position = position;
  p0 = (vec3(texcoord.xy,1.0) * vertexTransform).xy;
compile_shader
CI_SUBDIVIDE_QUADS
opengles2
opengles3
opengles?
metal
CI::RenderCompletionQueue
CI::KernelCacheQ
render_node
create_intermediate
B8@?0i4
%s/%d_intermediate_%d_%d_%d_%d_%d.png
Dumped intermediate to: %s
CI::ObjectCacheQ
kernel vec4 _tiltShift(sampler image,sampler blurM,sampler blurL,vec2 p0,vec2 p1,vec2 sizes)
  vec2 pt       = samplerCoord(image);
  vec4 col0     = sample(image, pt);
  vec4 colMed   = sample(blurM, samplerCoord(blurM));
  vec4 colLarge = sample(blurL, samplerCoord(blurL));
  float denom = (p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y);
  float s =  ((p0.y-pt.y)*(p1.x-p0.x)-(p0.x-pt.x)*(p1.y-p0.y) ) / denom;
  float dist = abs(s)*sqrt(denom) / sizes.y;
  dist *= 2.0;
  float w0 = smoothstep(0.0, 1.0,  1.0 - 2.0*dist);
  float wL = smoothstep(0.0, 1.0, -1.0 + 2.0*dist);
  float wM = 1.0 - (w0 + wL);
  return w0*col0 + wM*colMed + wL*colLarge;
kernel vec4 _distanceColored(sampler image,vec2 p0,vec2 p1)
  vec2 pt = samplerCoord(image);
  float denom = (p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y);
  float s =  ((p0.y-pt.y)*(p1.x-p0.x)-(p0.x-pt.x)*(p1.y-p0.y) ) / denom;
  float dist = abs(s)*sqrt(denom) / samplerSize(image).y;
  dist *= 2.0;
  float val = dist;
  return vec4(val,val,val,1.0);
kernel vec4 _alphaNormalize(__sample image)
  vec4 col = image;
  col.rgb /= col.a;
  col.a = 1.0;
  return col;
CIColorControls
CIUnsharpMask
CIDiscBlur
10.6
inputUnsharpMaskRadius
inputUnsharpMaskIntensity
10.12
inputStrength
inputRotate
inputOrientation
inputCenterBottom
kernel vec4 _kickLightKernel_pos(__sample im, vec2 xy1, vec4 abc1, vec2 xy2, vec4 abc2, vec2 xy3, vec4 abc3, vec2 xy4, vec4 abc4, float str) 
    float dx = xy1.x-destCoord().x ; 
    float dy = xy1.y-destCoord().y ; 
    float s = exp(-(abc1.r*dx*dx +2.0*abc1.g*dx*dy +abc1.b*dy*dy)); 
    dx = xy2.x-destCoord().x ; 
    dy = xy2.y-destCoord().y ; 
    float g = exp(-(abc2.r*dx*dx +2.0*abc2.g*dx*dy +abc2.b*dy*dy)); 
    dx = xy3.x-destCoord().x ; 
    dy = xy3.y-destCoord().y ; 
    float ss = exp(-(abc3.r*dx*dx +2.0*abc3.g*dx*dy +abc3.b*dy*dy)); 
    dx = xy4.x-destCoord().x ; 
    dy = xy4.y-destCoord().y ; 
    float gg = exp(-(abc4.r*dx*dx +2.0*abc4.g*dx*dy +abc4.b*dy*dy)); 
    vec3 orig = im.rgb; 
    vec3 neg = min(im.rgb, 0.0); 
    vec3 pos = max(im.rgb, 1.0)-1.0; 
    im.rgb = clamp(im.rgb, 0.0, 1.0); 
    vec3 m = 1.0-im.rgb; 
    float a = 0.6; 
    vec4 result = im; 
    result.rgb = 1.0 - (pow(m, vec3(str))+a*( ((str-1.0)*m*(1.0-m*m))/(str*str))); 
    im.rgb = pow(im.rgb, vec3(1.0-((min(str, 2.95)-1.0)/2.6))); 
    result.rgb = mix(im.rgb, result.rgb, .85); 
    result.rgb = mix(orig, result.rgb+neg+pos, (s+g+ss+gg)); 
    return result; 
kernel vec4 _kickLightKernel_neg(__sample im, vec2 xy1, vec4 abc1, vec2 xy2, vec4 abc2, vec2 xy3, vec4 abc3, vec2 xy4, vec4 abc4, float str) 
    float dx = xy1.x-destCoord().x ; 
    float dy = xy1.y-destCoord().y ; 
    float s = exp(-(abc1.r*dx*dx +2.0*abc1.g*dx*dy +abc1.b*dy*dy)); 
    dx = xy2.x-destCoord().x ; 
    dy = xy2.y-destCoord().y ; 
    float g = exp(-(abc2.r*dx*dx +2.0*abc2.g*dx*dy +abc2.b*dy*dy)); 
    dx = xy3.x-destCoord().x ; 
    dy = xy3.y-destCoord().y ; 
    float ss = exp(-(abc3.r*dx*dx +2.0*abc3.g*dx*dy +abc3.b*dy*dy)); 
    dx = xy4.x-destCoord().x ; 
    dy = xy4.y-destCoord().y ; 
    float gg = exp(-(abc4.r*dx*dx +2.0*abc4.g*dx*dy +abc4.b*dy*dy)); 
    vec3 neg = min(im.rgb, 0.0); 
    vec3 pos = max(im.rgb, 1.0)-1.0; 
    im.rgb = clamp(im.rgb, 0.0, 1.0); 
    vec4 orig = im; 
    float lum = max(max(im.r, im.g), im.b); 
    vec3 gamma = compare(vec3(lum)-.001, vec3(0.0), pow(im.rgb, vec3(1.0-str*min(s+g+ss+gg, 1.0)))); 
    im.rgb = mix(gamma, mix(orig.rgb, orig.rgb*lum, -str*min(s+g+ss+gg, 1.0)), 0.3) ;
    im.rgb = mix(orig.rgb, im.rgb, 4.0*lum*(1.0-lum)) + pos + neg; 
    return im; 
inputPt1
T@"CIVector",&,N,VinputPt1
inputPt2
T@"CIVector",&,N,VinputPt2
inputPt3
T@"CIVector",&,N,VinputPt3
inputPt4
T@"CIVector",&,N,VinputPt4
inputPt5
T@"CIVector",&,N,VinputPt5
inputPt6
T@"CIVector",&,N,VinputPt6
T@"NSNumber",&,N,VinputWidth
T@"NSNumber",&,N,VinputStrength
T@"NSNumber",&,N,VinputRotate
T@"NSNumber",&,N,VinputOrientation
T@"NSNumber",&,N,VinputCenterBottom
inputBrighten
kernel vec4 _dualLightKernel(__sample im, vec2 xy1, vec4 abc1, vec2 xy2, vec4 abc2, vec3 mcb) 
    float dx = xy1.x-destCoord().x ; 
    float dy = xy1.y-destCoord().y ; 
    float s = exp(-(abc1.r*dx*dx +2.0*abc1.g*dx*dy +abc1.b*dy*dy)); 
    dx = xy2.x-destCoord().x ; 
    dy = xy2.y-destCoord().y ; 
    float g = exp(-(abc2.r*dx*dx +2.0*abc2.g*dx*dy +abc2.b*dy*dy)); 
    float contrast = .1*mcb.g*g; 
    vec3 neg = min(im.rgb, 0.0); 
    vec3 pos = max(im.rgb, 1.0)-1.0; 
    im.rgb = clamp(im.rgb, 0.0, 1.0); 
    vec3 orig = im.rgb; 
    float lum = (dot(im.rgb, vec3(.333333))); 
    float y = sqrt(lum); 
    vec3 light = vec3((1.0-y)*g-mcb.b*.4*(1.0-lum)*s); 
    float yy = compare(light.r, pow(lum, 1.0+abc1.a*light.r), pow(lum, 1.0+abc2.a*light.r)); 
    yy = mix(yy, 0.5, -(y*(1.0-y))*contrast); 
    im.rgb = lum > 0.0 ? im.rgb*yy/lum : vec3(0.0); 
    im.rgb = mix(orig.rgb, im.rgb, mcb.r) + pos + neg; 
    return im; 
inputCenter1
T@"CIVector",&,N,VinputCenter1
inputCenter2
T@"CIVector",&,N,VinputCenter2
inputBottom1
T@"CIVector",&,N,VinputBottom1
inputBottom2
T@"CIVector",&,N,VinputBottom2
inputWidth1
T@"NSNumber",&,N,VinputWidth1
inputWidth2
T@"NSNumber",&,N,VinputWidth2
inputHeight1
T@"NSNumber",&,N,VinputHeight1
inputHeight2
T@"NSNumber",&,N,VinputHeight2
T@"NSNumber",&,N,VinputBrighten
inputRotate1
T@"NSNumber",&,N,VinputRotate1
inputRotate2
T@"NSNumber",&,N,VinputRotate2
T@"NSNumber",&,N,VinputContrast
kernel vec4 _strobeKernel(__sample im, vec2 xy1, vec4 abc1, float str) 
    float dx = xy1.x-destCoord().x ; 
    float dy = xy1.y-destCoord().y ; 
    float s = exp(-(abc1.r*dx*dx +2.0*abc1.g*dx*dy +abc1.b*dy*dy)); 
    vec3 orig = im.rgb; 
    float lum = (dot(im.rgb, vec3(.333333))); 
    float y = sqrt(lum); 
    vec3 light = vec3(.4*(1.0-lum)*s); 
    float yy = pow(lum, 1.0-abc1.a*light.r); 
    im.rgb = lum > 0.0 ? im.rgb*yy/lum : vec3(0.0); 
    im.rgb = mix(orig.rgb, im.rgb, 1.0); 
    return im; 
kernel vec4 _contourExtractRed (__sample c) __attribute__((outputFormat(kCIFormatRh))) {
  return vec4(c.r, 0.0, 0.0, 1.0);
kernel vec4 _contourLightKernel (__sample back, __sample fore, vec4 xy1, vec4 abc1, vec4 eyes, float str, float radius )
    fore = vec4(fore.r, fore.r, fore.r, 1.0);
    fore = max(fore, 0.0); 
    vec3 neg = min(back.rgb, 0.0); 
    vec3 pos = max(back.rgb, 1.0)-1.0; 
    back = clamp(back, 0.0, 1.0); 
    vec4 DCb = compare(0.25 - back, sqrt(back), ((16.0 * back - 12.0) * back + 4.0) * back);
    vec4 B  = back + (2.0 * fore - 1.0) * compare(0.5 - fore, DCb - back, back * (1.0 - back));
    float dx = xy1.x-destCoord().x ; 
    float dy = xy1.y-destCoord().y ; 
    float s = str*exp(-(abc1.r*dx*dx +2.0*abc1.g*dx*dy +abc1.b*dy*dy)); 
    dx = eyes.x-destCoord().x ;
    dy = eyes.y-destCoord().y ;
    float le = .8*str*exp(-(dx*dx + dy*dy)/(2.0*radius)); 
    dx = eyes.z-destCoord().x ;
    dy = eyes.w-destCoord().y ;
    float re = .8*str*exp(-(dx*dx + dy*dy)/(2.0*radius)); 
    dx = xy1.z-destCoord().x ;
    dy = xy1.w-destCoord().y ;
    float chin = .5*str*exp(-(dx*dx + dy*dy)/(1.0*radius)); 
    B = mix(pow(B, vec4(1.6)), B, smoothstep(0.1, .7, fore.r+chin)) ;
    vec4 im = back; 
    im.rgb = mix(im.rgb, B.rgb, (s - re -le +chin)) + pos + neg; 
    return im; 
inputEyes
T@"CIVector",&,N,VinputEyes
inputHeight
T@"NSNumber",&,N,VinputHeight
inputDarken
kernel vec4 _portraitSpotKernel (__sample c, vec4 xy1, vec4 abc1, vec2 darken )
    float dx = xy1.x-destCoord().x ; 
    float dy = xy1.y-destCoord().y ; 
    float s = exp(-(abc1.r*dx*dx +2.0*abc1.g*dx*dy +abc1.b*dy*dy)); 
  vec3 orig = c.rgb; 
  vec3 neg = min(c.rgb, 0.0); 
  vec3 pos = max(c.rgb, 1.0)-1.0; 
  c.rgb = clamp(c.rgb, 0.0, 1.0); 
  vec3 m = 1.0-c.rgb; 
  float a = 0.6; 
  vec4 result = c; 
  float gamma = abc1.w; 
  result.rgb = 1.0 - (pow(m, vec3(gamma))+a*( ((gamma-1.0)*m*(1.0-m*m))/(gamma*gamma))); 
  c.rgb = pow(c.rgb, vec3(1.0-((min(gamma, 2.95)-1.0)/2.6))); 
  result.rgb = darken.g*mix(c.rgb, result.rgb, .85); 
  result.rgb = mix(darken.r*orig, result.rgb+neg+pos, s); 
  return result; 
T@"NSNumber",&,N,VinputDarken
inputFaceOrientation
kernel vec4 _neckContour(__sample im, vec4 xy1, vec4 abc1, vec4 abc2, float str) 
    float dx = xy1.x-destCoord().x ; 
    float dy = xy1.y-destCoord().y ; 
    float s = -smoothstep(0.0, .1, exp(-(abc1.r*dx*dx +2.0*abc1.g*dx*dy +abc1.b*dy*dy))) ; 
    dx = xy1.z-destCoord().x ; 
    dy = xy1.w-destCoord().y ; 
    float ss = smoothstep(0.0, .15, exp(-(abc2.r*dx*dx +2.0*abc2.g*dx*dy +abc2.b*dy*dy))) ; 
    s = clamp(ss+s, 0.0, 1.0); 
    im.rgb = mix(im.rgb, .85*im.rgb, str*s); 
    im.rgb = mix(im.rgb, im.rgb*im.rgb, .6*str*s); 
    return im; 
inputChin
T@"CIVector",&,N,VinputChin
T@"NSNumber",&,N,VinputFaceOrientation
The message must contain at least one character.
The message is too long for a Code128 barcode.
The message contains non-7bit ascii characters.
Could not allocate memory for image.
v16@?0i4B8r*12
Unable to create barcode. 
com.apple.code128
StartC
StartA
StartB
Code C
Code B
Code A
Check
Stop
image
image_chroma
float
vec2
vec3
vec4
mat2
mat3
mat4
table
dest_coord
dest_gid
sampler_index
sampler_transform
sampler_transform_and_extent
sampler_transform_row0
sampler_transform_row1
vertex_transform
vertex_transform_row0
vertex_transform_row1
set_roi_selector queue
fill 
clear
[CIAffineTransform inputTransfom] is not a valid object.
AffineA
AffineB
AffineC
AffineD
AffineX
AffineY
T@"NSValue",&,N,VinputTransform
CropX
CropY
CropW
CropH
T@"CIVector",&,N,VinputRectangle
CI_PRINT_TIME new bitmap (%ldx%ld) = %.3f seconds
affine 
affine
-[CIContext(ImageRepresentation) TIFFRepresentationOfImage:format:colorSpace:options:]
-[CIContext(ImageRepresentation) PNGRepresentationOfImage:format:colorSpace:options:]
kCIImageRepresentationAVDepthData
kCIImageRepresentationDepthImage
kCIImageRepresentationDisparityImage
-[CIContext(ImageRepresentation) JPEGRepresentationOfImage:colorSpace:options:]
public.jpeg
-[CIContext(ImageRepresentation) HEIFRepresentationOfImage:format:colorSpace:options:]
public.heic
CIContextWriteRepresentation
CINonLocalizedDescriptionKey
image extent must be finite and non-empty.
-[CIContext(ImageRepresentation) writeTIFFRepresentationOfImage:toURL:format:colorSpace:options:error:]
unsupported colorspace.
failed to create data representation.
-[CIContext(ImageRepresentation) writePNGRepresentationOfImage:toURL:format:colorSpace:options:error:]
-[CIContext(ImageRepresentation) writeJPEGRepresentationOfImage:toURL:colorSpace:options:error:]
-[CIContext(ImageRepresentation) writeHEIFRepresentationOfImage:toURL:format:colorSpace:options:error:]
kCGImageAuxiliaryDataInfoData
kCGImageAuxiliaryDataInfoDataDescription
BytesPerRow
PixelFormat
[[:space:]]+
[[:space:]]*
_ci_tweaked_(
[[:space:]]*([_[:alnum:]]*)[[:space:]]+([_[:alnum:]]*)
sampler
sampler2D 
, vec4 
_transform0
_transform1
_transform2
, mat4 
_transform
#define 
tweak
(float|vec2|vec3|vec4)[[:space:]]+([_[:alnum:]]+)[[:space:]]*\((.*)\)[[:space:]]*\{
.*(sampler|int).*
 ## 
CGNode::surface
CGImageRef %p
CGImageRef %d
Could not create IOSurface in ioSurfaceFromCGImage failed
kCGImageBlockTileRequest
Failed to access image block data.
LA16
RG16
RGB8
RGB16
RGBh
RGBf
BGRA8
RGBA8
ARGB8
ABGR8
BGRX8
RGBX8
XRGB8
XBGR8
YCC420f
YCC420v
YCC444f601
YCC444f709
YCC444v601
YCC444v709
YCC420f601
YCC420f709
YCC420v601
YCC420v709
RGBA16
ARGB16
RGBA16-Unorm
RGBAh
RGBAf
ARGBf
A2BGR10
A2RGB10
RGB10A2-WideGamut
RGBA14
RGBA14v0
CbYCrY8
CbYCrY8f
YCbYCr8
YCbYCr8f
CbYCrY_RGB8
YCbYCr_RGB8
unknown-format
need a %s swizzler so that %s can be read as %s
kSwizzleBGRAtoRRGG1
kPixelFormatRG16
kPixelFormatBGRA8
kSwizzleBGRAtoLLAA
kPixelFormatLA16
kSwizzleGBAR
kPixelFormatARGB8
kPixelFormatRGBA8
kSwizzleAGBR
kPixelFormatABGR8
kSwizzleGBA1
kPixelFormatXRGB8
kSwizzleAGB1
kPixelFormatXBGR8
kSwizzleRGB14
kPixelFormatRGBA14
kPixelFormatRGBA16
kSwizzleRGB14v0
kPixelFormatRGBA14v0
need a swizzler so that %s can be read.
kSwizzleToRGB14
kSwizzleToRGB14v0
need a swizzler so that %s can be written.
swizzle_identity
swizzle_bgra
swizzle_abgr
swizzle_argb
swizzle_gbra
swizzle_grab
swizzle_gbar
swizzle_rgb1
swizzle_bgr1
swizzle_arg1
swizzle_gra1
swizzle_1bgr
swizzle_1rgb
swizzle_aaaa
swizzle_rrrr
swizzle_000r
swizzle_rrr1
swizzle_r001
swizzle_a001
swizzle_rg01
swizzle_ra01
swizzle_aaa1
swizzle_rrrg
swizzle_rg_to_rr1
swizzle_rg_to_ll1
swizzle_rg_to_a
swizzle_rg_to_i
swizzle_rg_to_cbycry
swizzle_rg_to_ycbycr
swizzle_la_to_rr1
swizzle_la_to_ll1
swizzle_la_to_a
swizzle_la_to_i
swizzle_rgba_to_rrgg1
swizzle_rgba_to_llaa
swizzle_to_r16_as_rg8
swizzle_to_l16_as_rg8
swizzle_to_a16_as_rg8
combine_r_as_rgba
combine_l_as_rgba
combine_a_as_rgba
swizzle_to_rg16_as_rgba8
swizzle_to_rg16_as_bgra8
swizzle_to_la16_as_rgba8
swizzle_to_la16_as_bgra8
swizzle_to_YCbYCr_as_rg8
swizzle_to_CbYCrY_as_rg8
swizzle_to_rgb_as_r
swizzle_to_a2bgr10_as_rgba8
swizzle_to_a2rgb10_as_rgba8
swizzle_to_rgb10_wide_as_rgba8
combine_420
swizzle_to_444_biplanar
swizzle_ycc_to_rgb
swizzle_to_laaa
swizzle_rgba8_to_a2rgb10
swizzle_rgba8_to_a2bgr10
swizzle_rgba8_to_rgb10_wide
swizzle_rgb10_wide
swizzle_bgr10_wide
swizzle_to_rgb10_wide
swizzle_to_bgr10_wide
swizzle_rgba16_normalize
swizzle_to_rg_as_rgba
swizzle_to_r16_as_rgba
swizzle_to_a16_as_rgba
swizzle_to_l16_as_rgba
swizzle_to_la_as_rgba
unknown-swizzle
kernel vec4 _sepia (__sample s, float amount)
  vec4  color = vec4(1.0, 0.99, 0.92, 1.0);
  vec4  c0 = vec4(0.895663e-3, -0.1104567e-2, -0.60827e-3, 0.32774281e-1);
  vec4  c1 = vec4(3.1166719, 0.79263718, 0.32196859e-1, 1.4118470);
  vec4  c2 = vec4(-50.933413, 0.46548312, 1.0275550, -.90690876);
  vec4  c3 = vec4(708.79386, -0.39031064, -0.58540133e-1, 0.66210230);
  vec4  c4 = vec4(-3605.9836, 0.13231560, 0.0, -0.19916155);
  float l  = dot(s.rgb, vec3(.2125, .7154, .0721));
  float la = l / max(0.0001, s.a);
  vec4  t  = c0*s.a + (c1 + (c2 + (c3 + c4*la)*la)*la)*l;
        t.r = (l < 0.085*s.a)  ?  t.r  :  t.a;
  vec3  r = (l*l-l < 0.0)  ?  t.rgb  :  vec3(l,l,l);
  return mix(s,vec4(r, s.a)*color, amount);
T@"NSNumber",&,N,VinputIntensity
kernel vec4 _lenticularHalo(sampler noise, vec2 center, vec2 sourcecenter, float noiseRadius, float haloThicknessRecip, float a, float b, vec3 rgbdist, __color color)
  vec2 v = destCoord() - center;
  vec3 rgbfunc = clamp((length(v) - rgbdist) * haloThicknessRecip, 0.0, 1.0);
  rgbfunc = 2.0 * min(rgbfunc, 1.0 - rgbfunc);
  rgbfunc = (3.0 - 2.0 * rgbfunc) * rgbfunc * rgbfunc;
  vec2 noiseloc = normalize(v) * noiseRadius + sourcecenter;
  vec4 npix = sample(noise, samplerTransform(noise, noiseloc));
  vec3 color3 = (npix.r * a + b) * rgbfunc * color.rgb;
  return vec4(color3, max(max(color3.r, color3.g), color3.b));
inputHaloRadius
inputHaloWidth
inputHaloOverlap
inputStriationStrength
inputStriationContrast
CILenticularHaloGenerator only has one input
10.7
AVDepthData
AVCameraCalibrationData
depthDataFromDictionaryRepresentation:error:
/System/Library/Frameworks/AVFoundation.framework/AVFoundation
abortable
blend_kernel
kernel vec4 _clearer() { return vec4(0.0); }
CIImageAccumulator
-[CIImageAccumulator init]
-[CIImageAccumulator initWithExtent:format:options:]
[CIImageAccumulator initWithExtent:format:] failed.
<CIImageAccumulator: %p extent [%g %g %g %g] format %s>
T{CGRect={CGPoint=ff}{CGSize=ff}},R
format
[%g]
[%g %g]
[%g %g %g]
[%g %g %g %g
CICount
CI_%zu
count
TL,R
Tf,R
CGPointValue
T{CGPoint=ff},R
CGRectValue
CGAffineTransformValue
T{CGAffineTransform=ffffff},R
stringRepresentation
_values
T^f,R
inputAVector
inputBiasVector
T@"NSNumber",&,N,VinputEV
%s:%d: Assertion failed: %s
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/internal/render.cpp
graph != NULL
^{TileTask=^^?{atomic<unsigned int>=AI}^{dispatch_group_s}L^{ProgramNode}{CGRect={CGPoint=ff}{CGSize=ff}}{unordered_map<CI::ProgramNode *, CI::ProgramNode::Stats, std::__1::hash<CI::ProgramNode *>, std::__1::equal_to<CI::ProgramNode *>, std::__1::allocator<std::__1::pair<CI::ProgramNode *const, CI::ProgramNode::Stats> > >={__hash_table<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, std::__1::__unordered_map_hasher<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, std::__1::hash<CI::ProgramNode *>, true>, std::__1::__unordered_map_equal<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, std::__1::equal_to<CI::ProgramNode *>, true>, std::__1::allocator<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats> > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *> *> >=L}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, std::__1::hash<CI::ProgramNode *>, true> >=L}{__compressed_pair<float, std::__1::__unordered_map_equal<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, CI::ProgramNode::Stats>, std::__1::equal_to<CI::ProgramNode *>, true> >=f}}}{unordered_map<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> >, std::__1::hash<CI::ProgramNode *>, std::__1::equal_to<CI::ProgramNode *>, std::__1::allocator<std::__1::pair<CI::ProgramNode *const, std::__1::vector<CGRect, std::__1::allocator<CGRect> > > > >={__hash_table<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::__unordered_map_hasher<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::hash<CI::ProgramNode *>, true>, std::__1::__unordered_map_equal<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::equal_to<CI::ProgramNode *>, true>, std::__1::allocator<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > > > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *> >=L}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::hash<CI::ProgramNode *>, true> >=L}{__compressed_pair<float, std::__1::__unordered_map_equal<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::equal_to<CI::ProgramNode *>, true> >=f}}}^{dispatch_queue_s}}24@?0^{ProgramNode=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB^{Node}^{SerialStringArray}^{SerialObjectPtrArray}^{Kernel}^{SerialObjectPtrArray}B{IntermediateDescriptor=iC}^{dispatch_queue_s}^{dispatch_group_s}}4{CGRect={CGPoint=ff}{CGSize=ff}}8
CI_PRINT_TIME %s (%s%s context %d frame %lu) (%llux%llu) = %.3f seconds%s
 (aborted)
render_to_display
render_to_texture
get_bitmap
create_cgimage
Could not access surface.
CI_PRINT_TIME %s (%s%s context %d frame %lu) (%llux%llu) = %.3f seconds
prepare_initial_graph
v24@?0^{GraphObject=^^?{atomic<unsigned int>=AI}}4^{GraphObject=^^?{atomic<unsigned int>=AI}}8i12i16i20
initial graph %s (%s%s context %d frame %lu) format=%s roi=
 lowp
optimized graph %s (%s%s context %d frame %lu) format=%s roi=
No need to render
Cannot render to infinite output region.
Failed to render %llu pixels 
Failed to render %llu of %llu pixels 
because a CIKernel's ROI function did not allow tiling.
render_tile
Failed to render part of the image because %s
destination %dx%d too big
input %d too big
intermediate %d too big
memory requirement of %d too big
main
make_program_graph
program graph %s (%s%s context %d frame %lu tile %lu) format=%s roi=
Cannot create a CGImageProvider for %s
CGImageProviderCallbackQueue
kCGImageProviderPrefersBandedDecoding
kCGImageProviderPreferedBandHeight
failed mprotect
fill
kernel vec4 _displaceFromImage (sampler src, sampler image, float k)
  vec2 dc = destCoord(); 
  float E = sample(image, samplerTransform(image,dc+vec2(1.0,0.0))).r; 
  float S = sample(image, samplerTransform(image,dc+vec2(0.0,-1.0))).r; 
  float C = sample(image, samplerTransform(image,dc)).r; 
  return sample(src, samplerTransform(src, dc + k * vec2(E-C, S-C)));
T@"NSNumber",&,N,VinputSaturation
T@"NSNumber",&,N,VinputBrightness
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/internal/vector.cpp
values != NULL
<CI::Vector %p>[]
<CI::Vector %p>[%g]
<CI::Vector %p>[%g %g]
<CI::Vector %p>[%g %g %g]
<CI::Vector %p>[%g %g %g %g]
<CI::Vector %p>[%d values]
%c%g
CIColumnAverage
kernel vec4 _reduceCrop (sampler image)
  vec4 p = sample(image, samplerTransform(image, vec2(0.5, 0.5)));
  vec2 d = abs(destCoord() - 0.5);
  return max(d.x, d.y) < 0.5  ?  p  :  vec4(0.0);
kernel vec4 _areaMax4(sampler image, vec2 bound)
  vec2  d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x)  ?  max(p0, p1)  :  p0;
  p2 = (d.x+0.5 < bound.x)  ?  max(p2, p3)  :  p2;
  p0 = (d.y+0.5 < bound.y)  ?  max(p0, p2)  :  p0;
  return p0;
kernel vec4 _horizMax4(sampler image, float bound)
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  p0 = (d.x-0.5 < bound)  ?  max(p0, p1)  :  p0;
  p0 = (d.x+0.5 < bound)  ?  max(p0, p2)  :  p0;
  p0 = (d.x+1.5 < bound)  ?  max(p0, p3)  :  p0;
  return p0;
kernel vec4 _vertMax4(sampler image, float bound)
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  p0 = (d.y-0.5 < bound)  ?  max(p0, p1)  :  p0;
  p0 = (d.y+0.5 < bound)  ?  max(p0, p2)  :  p0;
  p0 = (d.y+1.5 < bound)  ?  max(p0, p3)  :  p0;
  return p0;
kernel vec4 _areaMin4(sampler image, vec2 bound)
  vec2 d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x)  ?  min(p0, p1)  :  p0;
  p2 = (d.x+0.5 < bound.x)  ?  min(p2, p3)  :  p2;
  p0 = (d.y+0.5 < bound.y)  ?  min(p0, p2)  :  p0;
  return p0;
kernel vec4 _horizMin4(sampler image, float bound)
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  p0 = (d.x-0.5 < bound)  ?  min(p0, p1)  :  p0;
  p0 = (d.x+0.5 < bound)  ?  min(p0, p2)  :  p0;
  p0 = (d.x+1.5 < bound)  ?  min(p0, p3)  :  p0;
  return p0;
kernel vec4 _vertMin4(sampler image, float bound)
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  p0 = (d.y-0.5 < bound)  ?  min(p0, p1)  :  p0;
  p0 = (d.y+0.5 < bound)  ?  min(p0, p2)  :  p0;
  p0 = (d.y+1.5 < bound)  ?  min(p0, p3)  :  p0;
  return p0;
kernel vec4 _areaMaxAlphaS4(sampler image, vec2 bound)
  vec2 d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x)  ?  (p0.a>=p1.a ? p0 : p1)  :  p0;
  p2 = (d.x+0.5 < bound.x)  ?  (p2.a>=p3.a ? p2 : p3)  :  p2;
  p0 = (d.y+0.5 < bound.y)  ?  (p0.a>=p2.a ? p0 : p2)  :  p0;
  return p0;
kernel vec4 _areaMaxAlphaH4(sampler image, float bound)
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  p0 = (d.x-0.5 < bound)  ?  (p0.a>=p1.a ? p0 : p1)  :  p0;
  p0 = (d.x+0.5 < bound)  ?  (p0.a>=p2.a ? p0 : p2)  :  p0;
  p0 = (d.x+1.5 < bound)  ?  (p0.a>=p3.a ? p0 : p3)  :  p0;
  return p0;
kernel vec4 _areaMaxAlphaV4(sampler image, float bound)
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  p0 = (d.y-0.5 < bound)  ?  (p0.a>=p1.a ? p0 : p1)  :  p0;
  p0 = (d.y+0.5 < bound)  ?  (p0.a>=p2.a ? p0 : p2)  :  p0;
  p0 = (d.y+1.5 < bound)  ?  (p0.a>=p3.a ? p0 : p3)  :  p0;
  return p0;
kernel vec4 _reduceCropMinMaxRed (sampler image) __attribute__((outputFormat(kCIFormatRGh)))
  vec4 p = sample(image, samplerTransform(image, vec2(0.5, 0.5)));
  vec2 d = abs(destCoord() - 0.5);
  return max(d.x, d.y) < 0.5  ?  p  :  vec4(0.0);
kernel vec4 _areaMinMaxRed16 (sampler image, vec2 bound,float first) __attribute__((outputFormat(kCIFormatRGh))) 
  vec2  d  = 4.0*destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(0.5)));
  vec2 mm = first > 0.1 ? p.rr : p.rg;
  vec2 v, location;
  for(int j = -2 ; j < 2; j++) {
    for(int i = -2; i < 2; i++) {
       location = vec2(float(i),float(j)) + vec2(0.5);
       p = sample(image, samplerTransform(image, d + location));
       v = first > 0.1 ? p.rr : p.rg;
       mm.r = location.x < bound.x ? min(v.r, mm.r) : mm.r;
       mm.g = location.x < bound.x ? max(v.g, mm.g) : mm.g;
    }
  return vec4(mm, 0.0, 1.0);
kernel vec4 _areaMinMaxRed4 (sampler image, vec2 bound,float first) __attribute__((outputFormat(kCIFormatRGh))) 
  vec2  d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  vec2 mm0 = ( first > 0.1 ) ? p0.rr : p0.rg;
  vec2 mm1 = ( first > 0.1 ) ? p1.rr : p1.rg;
  vec2 mm2 = ( first > 0.1 ) ? p2.rr : p2.rg;
  vec2 mm3 = ( first > 0.1 ) ? p3.rr : p3.rg;
  mm0.r = (d.x+0.5 < bound.x)  ?  min(mm0.r, mm1.r)  :  mm0.r;
  mm2.r = (d.x+0.5 < bound.x)  ?  min(mm2.r, mm3.r)  :  mm2.r;
  mm0.r = (d.y+0.5 < bound.y)  ?  min(mm0.r, mm2.r)  :  mm0.r;
  mm0.g = (d.x+0.5 < bound.x)  ?  max(mm0.g, mm1.g)  :  mm0.g;
  mm2.g = (d.x+0.5 < bound.x)  ?  max(mm2.g, mm3.g)  :  mm2.g;
  mm0.g = (d.y+0.5 < bound.y)  ?  max(mm0.g, mm2.g)  :  mm0.g;
  return vec4(mm0.rg, 0.0, 1.0);
kernel vec4 _horizMinMaxRed4(sampler image, float bound,float first) __attribute__((outputFormat(kCIFormatRGh)))
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  vec2 mm0 = ( first > 0.1 ) ? p0.rr : p0.rg;
  vec2 mm1 = ( first > 0.1 ) ? p1.rr : p1.rg;
  vec2 mm2 = ( first > 0.1 ) ? p2.rr : p2.rg;
  vec2 mm3 = ( first > 0.1 ) ? p3.rr : p3.rg;
  mm0.r = (d.x-0.5 < bound)  ?  min(mm0.r, mm1.r)  :  mm0.r;
  mm0.r = (d.x+0.5 < bound)  ?  min(mm0.r, mm2.r)  :  mm0.r;
  mm0.r = (d.x+1.5 < bound)  ?  min(mm0.r, mm3.r)  :  mm0.r;
  mm0.g = (d.x-0.5 < bound)  ?  max(mm0.g, mm1.g)  :  mm0.g;
  mm0.g = (d.x+0.5 < bound)  ?  max(mm0.g, mm2.g)  :  mm0.g;
  mm0.g = (d.x+1.5 < bound)  ?  max(mm0.g, mm3.g)  :  mm0.g;
  return vec4(mm0.rg, 0.0, 1.0);
kernel vec4 _vertMinMaxRed4(sampler image, float bound,float first) __attribute__((outputFormat(kCIFormatRGh)))
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  vec2 mm0 = ( first > 0.1 ) ? p0.rr : p0.rg;
  vec2 mm1 = ( first > 0.1 ) ? p1.rr : p1.rg;
  vec2 mm2 = ( first > 0.1 ) ? p2.rr : p2.rg;
  vec2 mm3 = ( first > 0.1 ) ? p3.rr : p3.rg;
  mm0.r = (d.y-0.5 < bound)  ?  min(mm0.r, mm1.r)  :  mm0.r;
  mm0.r = (d.y+0.5 < bound)  ?  min(mm0.r, mm2.r)  :  mm0.r;
  mm0.r = (d.y+1.5 < bound)  ?  min(mm0.r, mm3.r)  :  mm0.r;
  mm0.g = (d.y-0.5 < bound)  ?  max(mm0.g, mm1.g)  :  mm0.g;
  mm0.g = (d.y+0.5 < bound)  ?  max(mm0.g, mm2.g)  :  mm0.g;
  mm0.g = (d.y+1.5 < bound)  ?  max(mm0.g, mm3.g)  :  mm0.g;
  return vec4(mm0.rg, 0.0, 1.0);
kernel vec4 _areaMinAlphaS4(sampler image, vec2 bound)
  vec2 d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x)  ?  (p0.a<=p1.a ? p0 : p1)  :  p0;
  p2 = (d.x+0.5 < bound.x)  ?  (p2.a<=p3.a ? p2 : p3)  :  p2;
  p0 = (d.y+0.5 < bound.y)  ?  (p0.a<=p2.a ? p0 : p2)  :  p0;
  return p0;
kernel vec4 _areaMinAlphaH4(sampler image, float bound)
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  p0 = (d.x-0.5 < bound)  ?  (p0.a<=p1.a ? p0 : p1)  :  p0;
  p0 = (d.x+0.5 < bound)  ?  (p0.a<=p2.a ? p0 : p2)  :  p0;
  p0 = (d.x+1.5 < bound)  ?  (p0.a<=p3.a ? p0 : p3)  :  p0;
  return p0;
kernel vec4 _areaMinAlphaV4(sampler image, float bound)
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  p0 = (d.y-0.5 < bound)  ?  (p0.a<=p1.a ? p0 : p1)  :  p0;
  p0 = (d.y+0.5 < bound)  ?  (p0.a<=p2.a ? p0 : p2)  :  p0;
  p0 = (d.y+1.5 < bound)  ?  (p0.a<=p3.a ? p0 : p3)  :  p0;
  return p0;
CIAreaMinimum
CIAreaMaximum
kernel vec4 _minMaxNormalize(__sample c, __sample minc, __sample maxc) 
  c.rgb = (c.rgb - minc.rgb) / max(maxc.rgb - minc.rgb, 0.00001); }
kernel vec4 _minMaxRedNormalize(__sample c, __sample minmaxc) __attribute__((outputFormat(kCIFormatRh))) 
  c.r = (c.r - minmaxc.r) / max(minmaxc.g - minmaxc.r, 0.00001); 
  return c; 
kernel vec4 _areaAvg8(sampler image)
  vec2 d = 8.0*destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-3.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2( 1.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2( 3.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2(-3.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2( 1.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2( 3.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-3.0, 1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0, 1.0))) 
         + sample(image, samplerTransform(image, d + vec2( 1.0, 1.0))) 
         + sample(image, samplerTransform(image, d + vec2( 3.0, 1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-3.0, 3.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0, 3.0))) 
         + sample(image, samplerTransform(image, d + vec2( 1.0, 3.0))) 
         + sample(image, samplerTransform(image, d + vec2( 3.0, 3.0)));
  return 0.0625*p;
kernel vec4 _areaAvg4(sampler image)
  vec2 d = 4.0*destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-1.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0,+1.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0,+1.0)));
  return 0.25*p;
kernel vec4 _areaAvg2(sampler image)
  vec2 d  = 2.0*destCoord();
  return sample(image, samplerTransform(image, d));
kernel vec4 _vertAvg16(sampler image)
  vec2 d = vec2(1.0, 16.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(0.0,-7.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,-5.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+3.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+5.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+7.0)));
  return p * 0.125;
kernel vec4 _vertAvg8(sampler image)
  vec2 d = vec2(1.0, 8.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(0.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+3.0)));
  return p * 0.25;
kernel vec4 _vertAvg4(sampler image)
  vec2 d = vec2(1.0, 4.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(0.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+1.0)));
  return p * 0.5;
kernel vec4 _vertAvg2(sampler image)
  vec2 d = vec2(1.0,2.0)*destCoord();
  return sample(image, samplerTransform(image, d));
kernel vec4 _horizAvg16(sampler image)
  vec2 d = vec2(16.0, 1.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-7.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(-5.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(-3.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+3.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+5.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+7.0, 0.0)));
  return p * 0.125;
kernel vec4 _horizAvg8(sampler image)
  vec2 d = vec2(8.0, 1.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-3.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+3.0, 0.0)));
  return p * 0.25;
kernel vec4 _horizAvg4(sampler image)
  vec2 d = vec2(4.0, 1.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0, 0.0)));
  return p * 0.5;
kernel vec4 _horizAvg2(sampler image)
  vec2 d = vec2(2.0,1.0)*destCoord();
  return sample(image, samplerTransform(image, d));
construct_shader
#define _sampler_swizzle(s) (%s)
#define _sampler_srgb_to_linear(s) _srgb_to_linear(s, _dc)
static constant float4 _ci_constants = (float4)(1.0,0.0,1.0/257.0,256.0/257.0);
#define sampleImage(s, ss, p, dc) %s(%s(read_imagef(s, ss, p))%s)
_sampler_swizzle
_sampler_srgb_to_linear
#define samplerTransform(s, ss, p, dc) (float2)(dot((float4)(p,1.0,0.0),s##_transform0),dot((float4)(p,1.0,0.0),s##_transform1))
#define samplerExtent(s, ss, dc) s##_transform2
#define _sampler_srgb_to_linear(s) _srgb_to_linear(s)
const lowp vec4 _ci_constants = vec4(1.0,0.0,1.0/257.0,256.0/257.0);
#define sampleImage(s,p) %s(%s(texture2D(_image[s],p))%s)
#define samplerTransform(s,p) ((vec3(p, 1.0) * _transform[s]).xy)
#define samplerExtent(s) _extent[s]
uniform lowp sampler2D _image[%d];
uniform highp mat3 _transform[%d];
uniform highp vec4 _extent[%d];
static constant metal::float4 _ci_constants = metal::float4(1.0,0.0,1.0/257.0,256.0/257.0);
#define sampleImage(s, ss, p, dc) %s(%s(s.sample(ss,p))%s)
#define samplerTransform(s, ss, p, dc) float2(dot(float3(p,1.0),s##_transform[0].xyz),dot(float3(p,1.0),s##_transform[1].xyz))
#define samplerExtent(s, ss, dc) (s##_transform[3])
#define writeImage(c, p, _dc) write_imagef(_outputTexture, (int2)p, c)
#define writeImagePlane(c, p, _dc) write_imagef(_outputTexturePlane, (int2)p, c)
#define writePixel(r, g, b, a, p, _dc) write_imagei(_outputTexture, (int2)p, (int4)(r,g,b,a))
#define writeCoord(_dc) (float2)_writeLoc
#define writeImage(c, p) gl_FragData[0] = c
#define writeImagePlane(c, p) gl_FragData[1] = c
#define writePixel(r, g, b, a, p) 
#define writeCoord() p0
#define writeImage(c, p, _dc) _outputTexture.write(c, static_cast<uint2>(p))
#define writeImagePlane(c, p, _dc) _outputTexturePlane.write(c, static_cast<uint2>(p))
#define writePixel(r, g, b, a, p, _dc) _outputTexture.write(float4(r,g,b,a) / 255.0, static_cast<uint2>(p))
#define writeCoord(_dc) static_cast<float2>(_gid)
gid += static_cast<uint2>(params.outputRect.xy * step(params.outputRect.w, 0.0));
gid.y += lessThan(params.outputRect.w, 0) * ((-params.outputRect.w-1)-2*gid.y);
  gid += static_cast<uint2>(params.outputRect.xy);
sampleImage(
_STUB_
samplerTransform(
samplerExtent(
write_imagef
gl_FragColor
outputTexture.write
writeImage
writeImagePlane
writePixel
writeCoord
write_only image2d_t out
texture2d<float, access::write> outputTexture
write_only image2d_t _outputTexture
write_only image2d_t _outputTexturePlane
int2 _writeLoc
out1
_writeLoc
texture2d<float, access::write> _outputTexture
texture2d<float, access::write> _outputTexturePlane
uint2 _gid
outputTexture
outputTexture1
EntryPoint
 %s1,
.bgra
.abgr
.argb
.gbra
.grab
.gbar
.aaaa
.rrrr
.rrrg
.rgba * _ci_constants.xxxy + _ci_constants.yyyx
.bgra * _ci_constants.xxxy + _ci_constants.yyyx
.argb * _ci_constants.xxxy + _ci_constants.yyyx
.grab * _ci_constants.xxxy + _ci_constants.yyyx
.abgr * _ci_constants.yxxx + _ci_constants.xyyy
.argb * _ci_constants.yxxx + _ci_constants.xyyy
.rrrr * _ci_constants.yyyx
.rrrr * _ci_constants.xxxy + _ci_constants.yyyx
.rrrr * _ci_constants.xyyy + _ci_constants.yyyx
.rggg * _ci_constants.xxyy + _ci_constants.yyyx
.aaaa * _ci_constants.xyyy + _ci_constants.yyyx
.raaa * _ci_constants.xxyy + _ci_constants.yyyx
.aaaa * _ci_constants.xxxy + _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.xyyy + _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.xxxy + _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.xxxx
dot(s.ra, _ci_constants.zw) * _ci_constants.xyyy + _ci_constants.yyyx
dot(s.ra, _ci_constants.zw) * _ci_constants.xxxy + _ci_constants.yyyx
dot(s.ra, _ci_constants.zw) * _ci_constants.yyyx
dot(s.ra, _ci_constants.zw) * _ci_constants.xxxx
dot(s.rg, _ci_constants.zw) * _ci_constants.xyyy + dot(s.ba, _ci_constants.zw) * _ci_constants.yxyy + _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.xxxy + dot(s.ba, _ci_constants.zw) * _ci_constants.yyyx
, %s
T@"CIVector",&,N,VinputRVector
T@"CIVector",&,N,VinputGVector
T@"CIVector",&,N,VinputBVector
T@"CIVector",&,N,VinputAVector
T@"CIVector",&,N,VinputBiasVector
kernel vec4 _vibrance_neg(__sample pixel0, float vibrance)
  vec4 pixel = clamp(pixel0, 0.0001, 0.9999);
  vec4 pdelta = pixel0 - pixel;
  float gray = (pixel.r + pixel.g + pixel.b) * 0.33333;
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  vec3 rgbsat = max((pixel.rgb - gray) * gii, (gray - pixel.rgb) * gi);
  float sat = max(max(rgbsat.r, rgbsat.g), rgbsat.b);
  float skin = min(pixel.r - pixel.g, pixel.g * 2.0 - pixel.b) * 4.0 * (1.0 - rgbsat.r) * gi;
  skin = 0.15 + clamp(skin, 0.0, 1.0) * 0.7;
  float boost = ((sat * (sat - 1.0) + 1.0) * vibrance) * (1.0-skin);
  pixel = clamp(pixel + (pixel - gray) * boost, 0.0, 1.0);
  pixel.a = pixel0.a;
  pixel.rgb += pdelta.rgb;
  return pixel;
kernel vec4 _vibrance_pos(__sample pixel0, vec4 vvec)
  vec4 pixel = clamp(pixel0, 0.0001, 0.9999);
  vec4 pdelta = pixel0 - pixel;
  float gray = (pixel.r + pixel.g + pixel.b) * 0.33333;
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  vec3 rgbsat = max((pixel.rgb - gray) * gii, (gray - pixel.rgb) * gi);
  float sat = max(max(rgbsat.r, rgbsat.g), rgbsat.b);
  float skin = min(pixel.r - pixel.g, pixel.g * 2.0 - pixel.b) * 4.0 * (1.0 - rgbsat.r) * gi;
  skin = 0.15 + clamp(skin, 0.0, 1.0) * 0.7;
  float boost = dot(vvec, vec4(1.0, sat, sat*sat, sat*sat*sat)) * (1.0 - skin);
  pixel = clamp(pixel + (pixel - gray) * boost, 0.0, 1.0);
  pixel.a = pixel0.a;
  pixel.rgb += pdelta.rgb;
  return pixel;
Vibrance
kernel vec4 _xSmooth(sampler image)
    float v;
    float sum = 0.0;
    float minv = 100.0;
    vec2  dc = destCoord();
    for(int i = -4; i < 5; i++) {
        v = sample(image, samplerTransform(image, dc + vec2(float(i),0.0))).r;
        sum += (v*v) * 0.1111111111;
        minv = min(minv,v);
    }
    return vec4(sqrt(sum),minv,0.0,1.0);
kernel vec4 _ySmooth(sampler image,sampler reference,vec4 blurValues)
    float v;
    float sum = 0.0;
    float minv = 100.0;
    vec2  dc = destCoord();
    for(int i = -4; i < 5; i++) {
        v = sample(image, samplerTransform(image, dc + vec2(0.0,float(i)))).r;
        sum += (v*v) * 0.1111111111;
        minv = min(minv,v);
    }
    sum = sqrt(sum);
    float refT0 = blurValues.x;
    float refT1 = blurValues.y;
    float minT0 = blurValues.z;
    float minT1 = blurValues.w;
    float ref = sample(reference, samplerCoord(reference)).x;
    float mixWeight = smoothstep(refT0, refT1, ref) * smoothstep(minT0, minT1, minv);
    float result = mix(ref, sum, mixWeight);
    return vec4(result,0.0,0.0,1.0);
originalBlurValueT0
originalBlurValueT1
localMinimumBlurValueT0
localMinimumBlurValueT1
nIterations
vec2 pseudo_randKY( vec2 pos )
float rand1 = mod(12.63 * pos.x - 57.3 * pos.y * pos.y, 0.01369) 
+ mod(75.833 * pos.y - 37.135 * pos.x * pos.x, 0.014) 
+ mod(39.7 * pos.x * pos.y + 21.7 * pos.x * pos.y * pos.y, 0.0879);
vec2 rand2 = fract(3576.7453 * vec2( rand1, 2.0 * rand1 ));
vec2 rand3 = fract(vec2(7.7387 * (rand2.x + rand2.y), 33.707 * (rand2.x - rand2.y)));
return rand3;
kernel vec4 _CIPortraitBlurNoise(__sample pixBlurred, vec4 params)
    float lumaNoiseAmpl = params.x;
    float lumaNoiseModelCoeff = params.y;
    vec2 randVal = pseudo_randKY( destCoord() / params.zw );
    float noiseLuma = clamp( sqrt( -2.0 * log(randVal.x) ) * cos( 6.2832 * randVal.y ), -5.0, 5.0 );
    vec4 kRGB_to_Y = vec4( 0.299 , 0.587, 0.114, 0.0);
    float outLuma = dot( pixBlurred, kRGB_to_Y );
    float addLumaNoiseLevel = lumaNoiseAmpl * mix( 1.0, outLuma, lumaNoiseModelCoeff );
    vec4 pixOut = clamp( pixBlurred + (noiseLuma * addLumaNoiseLevel) , 0.0, 1.0);
    pixOut.w = pixBlurred.w;
 return pixOut;
inputLumaNoiseAmpl
T@"NSNumber",C,N,VinputLumaNoiseAmpl
inputLumaNoiseModelCoeff
T@"NSNumber",C,N,VinputLumaNoiseModelCoeff
T@"CIVector",C,VinputExtent
inputUseMetal
T@"NSNumber",C,N,VinputUseMetal
kernel vec4 _CIPortraitBlurDir(sampler image,vec3 params)
    vec2 dir = params.yz;
    vec2 dc = destCoord(); 
    vec4 pix0 = sample( image, samplerTransform(image, dc -3.0 * dir));
    vec4 pix1 = sample( image, samplerTransform(image, dc -2.0 * dir));
    vec4 pix2 = sample( image, samplerTransform(image, dc - dir));
    vec4 pix3 = sample( image, samplerTransform(image, dc));
    vec4 pix4 = sample( image, samplerTransform(image, dc + dir));
    vec4 pix5 = sample( image, samplerTransform(image, dc + 2.0 * dir));
    vec4 pix6 = sample( image, samplerTransform(image, dc + 3.0 * dir));
    float outW = pix3.w;
    pix0.w = pix0.w * pix0.w;
    pix1.w = pix1.w * pix1.w;
    pix2.w = pix2.w * pix2.w;
    pix3.w = pix3.w * pix3.w;
    pix4.w = pix4.w * pix4.w;
    pix5.w = pix5.w * pix5.w;
    pix6.w = pix6.w * pix6.w;
    float radius = max(params.x * pix3.w, 1e-2);
    float radius2 = 1.0 / (2.0 * radius * radius);
    float weight0 = 1.0;
    float weight1 = exp(-1.0 * radius2);
    float weight2 = weight1 * weight1 * weight1 * weight1;
    float weight3 = weight2 * weight2 * weight1;
    float invWeightSum = 1.0 / (pix0.w * weight3 + pix1.w * weight2 + pix2.w * weight1 + pix3.w * weight0 + pix4.w * weight1 + pix5.w * weight2 + pix6.w * weight3 );
    weight0 *= invWeightSum;
    weight1 *= invWeightSum;
    weight2 *= invWeightSum;
    weight3 *= invWeightSum;
   vec4 pixOut;
   pixOut.xyz = weight3 * pix0.w * pix0.xyz + weight2 * pix1.w * pix1.xyz + weight1 * pix2.w * pix2.xyz 
              + weight0 * pix3.w * pix3.xyz + weight1 * pix4.w * pix4.xyz + weight2 * pix5.w * pix5.xyz 
              + weight3 * pix6.w * pix6.xyz;
   pixOut.w = outW;
    
return pixOut;
inputMaxBlur
T@"NSNumber",C,N,VinputMaxBlur
inputHorizontalBlur
T@"NSNumber",C,N,VinputHorizontalBlur
inputAntiAliasBlurStrength
T@"NSNumber",C,N,VinputAntiAliasBlurStrength
inputLumaNoiseScale
inputShape
NSString
vec2 _pseudo_randPBN( vec2 pos )
    float rand1 = mod(12.63 * pos.x - 57.3 * pos.y * pos.y, 0.01369) + mod(75.833 * pos.y - 37.135 * pos.x * pos.x, 0.014) + mod(39.7 * pos.x * pos.y + 21.7 * pos.x * pos.y * pos.y, 0.0879);
    vec2 rand2 = fract(3576.7453 * vec2( rand1, 2.0 * rand1 ));
    return fract(vec2(7.7387 * (rand2.x + rand2.y), 33.707 * (rand2.x - rand2.y)));
vec4 _pixWeight( vec4 sampledPix,vec2 offset,float basePixRawR,float distWeight,vec2 spatialWeightSoftMinMax ,float highlightBoostGain,vec2 relativeWeightThreshold) {
    float sampleR = 1.0 / sqrt(offset.x*offset.x + offset.y*offset.y);
    float spatialWeight = clamp(spatialWeightSoftMinMax.x * sampledPix.w * sampleR + spatialWeightSoftMinMax.y, 0.0, 1.0);
    float colorWeight = highlightBoostGain * (sampledPix.x + sampledPix.y + sampledPix.z) + 1.0; 
    float backgroundWeight = (3.0 - 2.0 * sampledPix.w);
    float rwT = clamp(relativeWeightThreshold.x * (sampledPix.w - basePixRawR) + relativeWeightThreshold.y, 0.0, 1.0);
    float relativeWeight = rwT * rwT * (3.0 - 2.0 * rwT); 
    float totalWeight = distWeight * spatialWeight * colorWeight * backgroundWeight * relativeWeight;
    return vec4( totalWeight * sampledPix.xyz, totalWeight );
float _ushortMultiply(float a,float multiplier) {
   int q = int(a) * int(multiplier);
   int r = q/65536;
   int m = q - r * 65536;
   float mf = float(m);
   return mf + compare(mf, 65535.0, 0.0);
kernel vec4 _CIPortraitBlur(sampler image,vec4 sizeAndScale,vec3 p0,vec4 p1,vec2 relativeWeightThreshold) 
   float maxBlurInPixels         = p0.x;
   float sharpRadius             = p0.y;
   float highlightBoostGain      = p0.z;
   vec2 spatialWeightSoftMinMax  = p1.xy;
   float basePixelWeight         = p1.z;
   int numSamples                = int(p1.w);
    vec2 dc = destCoord();
    vec4 basePix = sample(image, samplerCoord(image));
    float rawBlurRadius = basePix.w * basePix.w;
    float blurRadius = rawBlurRadius * maxBlurInPixels;
    vec4 outRGB;
    if ( blurRadius >= sharpRadius )
    {
      vec4 pixSum = vec4(basePix.xyz * basePixelWeight, basePixelWeight);
   vec2 randXY = _pseudo_randPBN(dc/sizeAndScale.xy) * sizeAndScale.zw * 65536.0;
      for ( int i = 0; i < numSamples; i++ )
      {
           vec2 randXY2 = (1./32767.5) * randXY - 1.0; 
           float randDist = randXY2.x*randXY2.x + randXY2.y*randXY2.y;
           float randNorm0 = max(abs(randXY2.x),abs(randXY2.y));
           float randShape = randNorm0 / sqrt(randDist);
           vec2  samplePos = randShape * rawBlurRadius * randXY2;
           float randW = randShape * randShape;
           samplePos.y = -samplePos.y;
           randXY.x = _ushortMultiply(randXY.x, 28563.0);
           randXY.y = _ushortMultiply(randXY.y, 44519.0);
        vec4 pix = sample( image, samplerTransform(image, dc + maxBlurInPixels * samplePos));
           pix.w = pix.w * pix.w;
           pixSum += _pixWeight(pix, samplePos, rawBlurRadius, randW, spatialWeightSoftMinMax, highlightBoostGain, relativeWeightThreshold);
        }
        outRGB.xyz = pixSum.w > 0.0 ?  vec3(pixSum.xyz / pixSum.w) : basePix.xyz;
        outRGB.w = basePix.w;
    }
    else
    {
        outRGB = basePix;
    }
return outRGB;
vec2 _pseudo_randPBNS( vec2 pos )
    float rand1 = mod(12.63 * pos.x - 57.3 * pos.y * pos.y, 0.01369) + mod(75.833 * pos.y - 37.135 * pos.x * pos.x, 0.014) + mod(39.7 * pos.x * pos.y + 21.7 * pos.x * pos.y * pos.y, 0.0879);
    vec2 rand2 = fract(3576.7453 * vec2( rand1, 2.0 * rand1 ));
    return fract(vec2(7.7387 * (rand2.x + rand2.y), 33.707 * (rand2.x - rand2.y)));
float _spatialWeightHearts(vec4 sampledPix,vec2 offset,vec4 shapeOrientation) {
   offset = offset.x * shapeOrientation.xy + offset.y * shapeOrientation.zw;
   vec2 sampleR = vec2(abs(offset.x), -offset.y) / sampledPix.w;
   vec2 v = sampleR - vec2(0.45, -0.217945);
   float lenSquared = v.x * v.x + v.y * v.y;
   bool circleT = lenSquared <= 0.25;
   bool innerT = dot(sampleR, vec2( -0.593342, 0.780268 ))  +0.340111 > 0.0;
   bool tailT  = dot(vec2(sampleR), vec2( -0.842548, -0.780268 )) +0.780268 > 0.0;
   return circleT || (innerT && tailT) ? 1.0 : 0.0;
float _spatialWeightPentagon(vec4 sampledPix,vec2 offset,vec4 shapeOrientation) {
   offset = offset.x * shapeOrientation.xy + offset.y * shapeOrientation.zw;
   vec2 sampleR = vec2(abs(offset.x), -offset.y) / sampledPix.w;
   float v1 =  dot( sampleR, vec2(-0.690758, 0.950983) ) + 0.950983;
   float v2 =  dot( sampleR, vec2(-1.117980, -0.3628144) ) + 0.950984;
   float v3 =  sampleR.y;
   return v1 > 0.0 && v2 > 0.0 && v3 < 0.808738 ? 1.0 : 0.0;
float _spatialWeightRings(vec4 sampledPix,vec2 offset) {
   vec2 sampleR = offset / sampledPix.w;
   float sampleD = length(sampleR);
   return sampleD > 0.3 && sampleD <= 1.0 ? 1.0 : 0.0;
float _spatialWeightStars(vec4 sampledPix,vec2 offset,vec4 shapeOrientation) {
   offset = offset.x * shapeOrientation.xy + offset.y * shapeOrientation.zw;
   vec2 sampleR = vec2(abs(offset.x), -offset.y) / sampledPix.w;
   float t1a = dot( sampleR, vec2(-1.11798, 1.53915) ) - 0.587209;
   float t1b = dot( sampleR, vec2(1.80874, -0.58816) ) - 0.588168;
   float t2a = sampleR.y + 0.30924;
   float t2b = dot( sampleR, vec2( 1.11798, 1.53915 ) ) - 0.587209;
   return (t1a < 0.0) && (t1b < 0.0) && (t2a > 0.0) && (t2b < 0.0) ? 1.0 : 0.0;
float _spatialWeightSwirl(vec4 sampledPix,vec2 offset,vec4 rotVec) {
    vec2 sampleR = offset / sampledPix.w; 
    float sampleD = length(sampleR.x * rotVec.xy + sampleR.y * rotVec.zw);
    return sampleD <= 1.0 ? 1.0 : 0.0;
vec4 _pixWeightShape( vec4 sampledPix,vec2 offset,float basePixRawR,float distWeight,vec2 spatialWeightSoftMinMax ,float highlightBoostGain,vec2 relativeWeightThreshold,vec4 shapeOrientation,float shape) {
   float spatialWeight = 0.0;
   int shapeN = int(shape);
   if (shapeN == 0) spatialWeight = _spatialWeightHearts(sampledPix, offset, shapeOrientation);
   else if ( shapeN == 1 ) spatialWeight = _spatialWeightPentagon(sampledPix, offset, shapeOrientation);
   else if ( shapeN == 2 ) spatialWeight = _spatialWeightRings(sampledPix, offset);
   else if ( shapeN == 3 ) spatialWeight = _spatialWeightStars(sampledPix, offset, shapeOrientation);
   else if ( shapeN == 4 || shapeN == 5 ) spatialWeight = _spatialWeightSwirl(sampledPix, offset, shapeOrientation);
   else {
      float sampleR = 1.0 / sqrt(offset.x*offset.x + offset.y*offset.y);
      spatialWeight = clamp(spatialWeightSoftMinMax.x * sampledPix.w * sampleR + spatialWeightSoftMinMax.y, 0.0, 1.0);
   }
    float colorWeight = highlightBoostGain * (sampledPix.x + sampledPix.y + sampledPix.z) + 1.0; 
    float backgroundWeight = (3.0 - 2.0 * sampledPix.w);
    float rwT = clamp(relativeWeightThreshold.x * (sampledPix.w - basePixRawR) + relativeWeightThreshold.y, 0.0, 1.0);
    float relativeWeight = rwT * rwT * (3.0 - 2.0 * rwT); 
    float totalWeight = distWeight * spatialWeight * colorWeight * backgroundWeight * relativeWeight;
    return vec4( totalWeight * sampledPix.xyz, totalWeight );
float _ushortMultiply2(float a,float multiplier) {
   int q = int(a) * int(multiplier);
   int r = q/65536;
   int m = q - r * 65536;
   return float(m) + ( m < 0  ? 65536.0 : 0.0);
kernel vec4 _CIPortraitBlurShape( sampler image,vec4 sizeAndScale,vec3 p0,vec4 p1,vec2 relativeWeightThreshold,vec4 shapeV,float shapeN) 
   float maxBlurInPixels         = p0.x;
   float sharpRadius             = p0.y;
   float highlightBoostGain      = p0.z;
   vec2 spatialWeightSoftMinMax  = p1.xy;
   float basePixelWeight         = p1.z;
   int numSamples                = int(p1.w);
    vec2 dc = destCoord();
    vec4 basePix = sample(image, samplerCoord(image));
    float rawBlurRadius = basePix.w * basePix.w;
    float blurRadius = rawBlurRadius * maxBlurInPixels;
  vec2 halfDims = 0.5 * sizeAndScale.xy;
  vec4 rotVec =  (halfDims.yxxy - dc.yxxy);
  float rotLen = length(rotVec.xy);
  float rotLenNorm = 2.0 * rotLen / max(halfDims.x, halfDims.y);
  rotVec *= 1.0 / rotLen;
  if ( int(shapeN) == 5 ) {
    rotVec *= vec4( -1.0 - rotLenNorm, -1.0, 1.0 + rotLenNorm, -1.0 );
    shapeV = rotVec;
  } else if ( int(shapeN) == 4 ){ 
    rotVec *= vec4(-1.0, -1.0 - rotLenNorm, 1.0, -1.0 - rotLenNorm);
    shapeV = rotVec;
    vec4 outRGB;
    if ( blurRadius >= sharpRadius )
    {
      vec4 pixSum = vec4(basePix.xyz * basePixelWeight, basePixelWeight);
       vec2 randXY = _pseudo_randPBNS(dc/sizeAndScale.xy) * sizeAndScale.zw * 65536.0;
      for ( int i = 0; i < numSamples; i++ )
      {
           vec2 randXY2 = (1./32767.5) * randXY - 1.0; 
           float randDist = randXY2.x*randXY2.x + randXY2.y*randXY2.y;
           float randNorm0 = max(abs(randXY2.x),abs(randXY2.y));
           float randShape = randNorm0 / sqrt(randDist);
           vec2  samplePos = randShape * rawBlurRadius * randXY2;
           float randW = randShape * randShape;
           samplePos.y = -samplePos.y;
           randXY.x = ceil(_ushortMultiply2(randXY.x, 28563.0));
           randXY.y = ceil(_ushortMultiply2(randXY.y, 44519.0));
            vec4 pix = sample( image, samplerTransform(image, dc + maxBlurInPixels * samplePos));
           pix.w = pix.w * pix.w;
           pixSum += _pixWeightShape(pix, samplePos, rawBlurRadius, randW, spatialWeightSoftMinMax, highlightBoostGain, relativeWeightThreshold, shapeV, shapeN);
        }
        outRGB.xyz = pixSum.w > 0.0 ?  vec3(pixSum.xyz / pixSum.w) : basePix.xyz;
        outRGB.w = basePix.w;
    }
    else
    {
        outRGB = basePix;
    }
    return outRGB;
kernel vec4 _CIPortraitBlurBlendWithMaskFromAlpha(__sample sharp,__sample blurry,vec4 radii ) {
  float maxBlur = radii.x;
  float sharpRadius = radii.y;
  float softRadius = radii.z;
  float width = radii.w;
  float blurRadius = maxBlur * width * blurry.w * blurry.w;
  blurry.w = clamp( (blurRadius - sharpRadius) / softRadius, 0.0, 1.0);
  vec4 c = mix(sharp, blurry, blurry.w);
  c.w = sharp.w;
  return c;
CIPortraitBlurPreProcess
inputBlurmapImage
/tmp/preprocessed-CI.tiff
maxBlur
sharpRadius
highlightBoostGain
nSamples
spatialWeightSoftMin
spatialWeightSoftMax
relativeWeightThreshold
basePixelWeight
/tmp/blur-CI.tiff
antiAliasBlurStrength
CIPortraitBlurDirectionalBlur
/tmp/blur-X-CI.tiff
/tmp/blur-Y-CI.tiff
CIPortraitBlurNoise
lumaNoiseModelCoeff
/tmp/blur-NoiseAddedHalfRes-CI.tiff
/tmp/upsampledBlurredImage.tiff
/tmp/blur-NoiseAddedFullRes-CI.tiff
softRadius
/tmp/finalBlend.tiff
CI_DISABLE_PORTRAIT_METAL
T@"CIImage",&,VinputBlurmapImage
T@"NSNumber",C,N,VinputLumaNoiseScale
inputTuningParameters
T@"NSDictionary",&,N,VinputTuningParameters
T@"NSString",&,N,VinputShape
kernel vec4 _CIBlurPreProcess(__sample downsampledImage,__sample refinedBlurmap)
{ return vec4(downsampledImage.xyz, refinedBlurmap.x); }
hearts
pentagons
rings
stars
swirl
warp
_shader
_roiMethods
_insetRects
_scaleFactors
_class
halfInput
halfOutput
doubleOutput
identity
roiForInput:arguments:outputRect:
inputFontName
HelveticaNeue
inputFontSize
inputScaleFactor
-[CITextImageGenerator outputImage]
inputText
T@"NSString",&,N,VinputText
T@"NSString",&,N,VinputFontName
T@"NSNumber",&,N,VinputFontSize
T@"NSNumber",&,N,VinputScaleFactor
-[CIAttributedTextImageGenerator outputImage]
T@"NSAttributedString",&,N,VinputText
inputNeutral
inputTargetNeutral
T@"CIVector",&,D,N
T@"CIVector",&,N,VinputTargetNeutral
kernel vec4 _whitepointadjust (__sample img, __color color) { return img * color; }
T@"CIColor",&,N,VinputColor
kernel vec4 _falseColor (__sample img, __color c0, __color c1)
  return img.a * mix (c0, c1, dot(img.rgb, vec3(.2125, .7154, .0721)));
inputColor0
inputColor1
T@"CIColor",&,N,VinputColor0
T@"CIColor",&,N,VinputColor1
CI Internal Context
Could not set current EAGL context to %p.
inputPower
T@"NSNumber",&,N,VinputPower
kCIImageProcessorSynchronizeInputs
%s surface is nil.
-[CIImageProcessorInOut initWithSurface:texture:allowSRGB:bounds:context:]
%s context is nil.
%@: cannot return a CVPixelBuffer on this platform.
<%@: %p %s extent [infinite]>
<%@: %p %s extent [empty]>
<%@: %p %s extent [%g %g %g %g]>
region
T{CGRect={CGPoint=ff}{CGSize=ff}},R,N,V_region
surface
T^{__IOSurface=},R,N
usesSRGBTransferFunction
TB,R,N
bytesPerRow
TL,R,N
%s command buffer provided to processor does not hold strong references to resources.
-[CIImageProcessorOutput metalCommandBuffer]
baseAddress
T^v,R,N
metalTexture
T@"<MTLTexture>",R,N
metalCommandBuffer
T@"<MTLCommandBuffer>",R,N
Tr^v,R,N
%s processor block must be provided.
-[CIImage(CIImageProcessor) imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor:]
%s inputFormat must be 0, R8, BGRA8, RGBAh, RGBAf.
%s outputFormat must be 0, R8, BGRA8, RGBAh, RGBAf.
Image Processor
v56@?0^^{__IOSurface}4^{Texture=(?={?=II}^v)}8^{CGRect={CGPoint=ff}{CGSize=ff}}12^B16^{__IOSurface=}20{Texture=(?={?=II}^v)}24{CGRect={CGPoint=ff}{CGSize=ff}}32B48^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@}52
%s must be overridden in %@ class
+[CIImageProcessorKernel processWithInputs:arguments:output:error:]
processWithInputs:arguments:output:error:
+[CIImageProcessorKernel applyWithExtent:inputs:arguments:error:]
CIImageProcessorKernel
outputFormat must be 0, R8, BGRA8, RGBAh, RGBAf.
inputFormat for image %d must be 0, R8, BGRA8, RGBAh, RGBAf.
CIGenericMetalProcessor
outputIsOpaque
synchronizeInputs
kernel vec4 _noiseReduction(sampler src, vec2 offset, vec3 weight, vec3 intensity)
  vec2 c  = destCoord();
  vec4 cn = sample(src, samplerTransform(src, c));
  vec4 t0 = sample(src, samplerTransform(src, c + vec2(0.0,-offset.x)));
  vec4 t1 = sample(src, samplerTransform(src, c + vec2(0.0, offset.x)));
  vec4 t2 = sample(src, samplerTransform(src, c + vec2(-offset.x,0.0)));
  vec4 t3 = sample(src, samplerTransform(src, c + vec2( offset.x,0.0)));
  vec4 t4 = sample(src, samplerTransform(src, c + vec2( offset.y, offset.y)));
  vec4 t5 = sample(src, samplerTransform(src, c + vec2( offset.y,-offset.y)));
  vec4 t6 = sample(src, samplerTransform(src, c + vec2(-offset.y,-offset.y)));
  vec4 t7 = sample(src, samplerTransform(src, c + vec2(-offset.y, offset.y)));
  t0      = (t0+t1+t2+t3)*weight.x + (t4+t5+t6+t7)*weight.y + cn*weight.z;
  vec4 d  = abs(t0 - cn);
  float s = intensity.x + intensity.y * (d.r + d.g + d.b);
  s     = clamp(s, intensity.z, 1.0);
  return mix(cn, t0, s);
inputNoiseLevel
kernel vec4 _convertRGBtoY (__sample c)
  c = vec4(c.rgb/max(c.a,0.00001), c.a);
  float Y = sqrt(max(dot(c.rgb, vec3(0.299,0.587,0.114)), 0.0));
  c.rgb = vec3(Y);
  return c;
kernel vec4 _blur1(sampler src) 
  vec2 p = destCoord(); 
  vec4 pixB  = sample(src, samplerTransform(src, p + vec2(-1.0, 1.0)));
  vec4 pixA  = sample(src, samplerTransform(src, p + vec2( 0.0, 1.0)));
       pixB += sample(src, samplerTransform(src, p + vec2( 1.0, 1.0)));
       pixA += sample(src, samplerTransform(src, p + vec2(-1.0, 0.0)));
  vec4 pix   = sample(src, samplerTransform(src, p));
       pixA += sample(src, samplerTransform(src, p + vec2( 1.0, 0.0)));
       pixB += sample(src, samplerTransform(src, p + vec2(-1.0,-1.0)));
       pixA += sample(src, samplerTransform(src, p + vec2( 0.0,-1.0)));
       pixB += sample(src, samplerTransform(src, p + vec2( 1.0,-1.0)));
  pix.g = pix.r * 0.25  +  pixA.r * 0.125  +  pixB.r * 0.0625;
  return pix;
kernel vec4 _blur2(sampler src) 
  vec2 p = destCoord(); 
  vec4 pixB  = sample(src, samplerTransform(src, p + vec2(-2.0, 2.0)));
  vec4 pixA  = sample(src, samplerTransform(src, p + vec2( 0.0, 2.0)));
       pixB += sample(src, samplerTransform(src, p + vec2( 2.0, 2.0)));
       pixA += sample(src, samplerTransform(src, p + vec2(-2.0, 0.0)));
  vec4 pix   = sample(src, samplerTransform(src, p));
       pixA += sample(src, samplerTransform(src, p + vec2( 2.0, 0.0)));
       pixB += sample(src, samplerTransform(src, p + vec2(-2.0,-2.0)));
       pixA += sample(src, samplerTransform(src, p + vec2( 0.0,-2.0)));
       pixB += sample(src, samplerTransform(src, p + vec2( 2.0,-2.0)));
  pix.b = pix.g * 0.25  +  pixA.g * 0.125  +  pixB.g * 0.0625;
  return pix;
kernel vec4 _blur4(sampler src) 
  vec2 p = destCoord(); 
  vec4 pixB  = sample(src, samplerTransform(src, p + vec2(-4.0, 4.0)));
  vec4 pixA  = sample(src, samplerTransform(src, p + vec2( 0.0, 4.0)));
       pixB += sample(src, samplerTransform(src, p + vec2( 4.0, 4.0)));
       pixA += sample(src, samplerTransform(src, p + vec2(-4.0, 0.0)));
  vec4 pix   = sample(src, samplerTransform(src, p));
       pixA += sample(src, samplerTransform(src, p + vec2( 4.0, 0.0)));
       pixB += sample(src, samplerTransform(src, p + vec2(-4.0,-4.0)));
       pixA += sample(src, samplerTransform(src, p + vec2( 0.0,-4.0)));
       pixB += sample(src, samplerTransform(src, p + vec2( 4.0,-4.0)));
  pix.a = pix.b * 0.25  +  pixA.b * 0.125  + pixB.b * 0.0625;
  return pix;
kernel vec4 _edgesPrep(__sample s)
  s = vec4(s.rgb/max(s.a,0.00001), s.a);
  s.rgb = sqrt(max(s.rgb, vec3(0.0)));
  return s;
kernel vec4 _findEdges(sampler src, float scale)
  vec2 p = destCoord();
  vec4 rA = sample(src, samplerTransform(src, p)) - 
            sample(src, samplerTransform(src, p + vec2(1.0, 1.0)));  
  vec4 rB = sample(src, samplerTransform(src, p + vec2(0.0, 1.0))) - 
            sample(src, samplerTransform(src, p + vec2(1.0, 0.0)));  
  vec4 r = (rA*rA + rB*rB) * scale;
  float R = min(max(max(r.r, r.g), r.b),1.0);
  return vec4(vec3(R), 1.0);
kernel vec4 _sharpenCombineEdges(__sample orig, __sample blurs, vec3 sharps, __sample edges)
  vec4 so = vec4(orig.rgb/max(orig.a,0.00001), orig.a); 
  float Y = blurs.r + dot(blurs.r - blurs.gba, sharps); 
  so.rgb = vec3(Y*Y) +
           so.r * vec3( 0.701428, -0.299276, -0.297756) + 
           so.g * vec3(-0.5881610, 0.4133170, -0.5857185) + 
           so.b * vec3(-0.113745, -0.113905, 0.884027); 
  float alpha = edges.x;
  so = vec4(so.rgb*so.a, so.a);
  return mix(orig, so, alpha);
inputFalloff
inputEdgeScale
_texture
_buffer
v8@?0@"<MTLCommandBuffer>"4
kernel vec4 _opTile (sampler src, vec2 center, vec2 params, vec4 trans)
  vec2  t3;
  vec2 t1 = destCoord() - center;
  vec2 t2 = floor (t1 * params.x) * params.y;
  t1 = t1 - t2;
  t3.x = dot (t2, trans.xy);
  t3.y = dot (t2, trans.zw);
  t1 = t3 + t1 + center;
  return sample (src, samplerTransform (src, t1));
builtin_sqr
builtin_pow4
builtin_sqrt
builtin_gamma
sqrt
pow4
gamma %g
gamma
CI::TextureManager
TextureManager::TextureManager() failed to create empty surface
TextureManager::remove_lru() did not find an info struct!
%p numSurfaceHits: %zu, numMisses: %zu
kernel vec4 _checker (vec2 center, __color c0, __color c1, vec3 parms)
  vec2 d0 = destCoord() - center;
  d0 = fract(d0 * parms.x);
  d0 = min (1.0 - d0, d0);
  d0 = clamp (d0 * parms.y + parms.z, 0.0, 1.0);
  d0 = (d0 * -2.0 + 3.0) * d0 * d0;
  float d1 = 2.0 * min (d0.x, d0.y) + 1.0 - (d0.x + d0.y);
  return mix(c1, c0, d1);
T@"NSNumber",&,N,VinputSharpness
gltexture: %u
requires a GL or CL context.
failed to set texture destination.
clamp
clamp 
bitmap: %p
affine_matrix
wrap_mode
filter_mode
black
periodic
blur
blur_format
-[CISampler initWithImage:options:]
<CISampler: %p extent [infinite]>
<CISampler: %p extent [empty]>
<CISampler: %p extent [%g %g %g %g]>
<CISampler: %p>
color_matrix
bias
 %s=(%g %g %g %g)
kernel vec4 _shadedmaterial(sampler heightfield, sampler envmap, float surfaceScale, vec2 envscaling)
  vec2 d       = destCoord();
  vec4 sup     = sample(heightfield, samplerTransform(heightfield, d+vec2( 0.0,+1.0)));
  vec4 sdown   = sample(heightfield, samplerTransform(heightfield, d+vec2( 0.0,-1.0)));
  vec4 sleft   = sample(heightfield, samplerTransform(heightfield, d+vec2(-1.0, 0.0)));
  vec4 sright  = sample(heightfield, samplerTransform(heightfield, d+vec2(+1.0, 0.0)));
  vec4 scenter = sample(heightfield, samplerCoord(heightfield));
  vec3 normal  = normalize(vec3(sleft.r - sright.r, sdown.r - sup.r, surfaceScale));
  vec2 eloc = (normal.xy * 0.495 + 0.5) * envscaling;
  vec4 pix = sample(envmap, samplerTransform(envmap, eloc));
  return pix * scenter.a;
kernel vec4 _shadedmaterial_0(sampler heightfield, sampler envmap, vec2 envscaling)
  vec4 scenter = sample(heightfield, samplerCoord(heightfield));
  vec3 normal  = vec3(0.0, 0.0, 1.0);
  vec2 eloc = (normal.xy * 0.495 + 0.5) * envscaling;
  vec4 pix = sample(envmap, samplerTransform(envmap, eloc));
  return pix * scenter.a;
inputNumIterations
kernel vec4 _CIBoxBlur5Min(sampler i) __attribute__((outputFormat(kCIFormatRh)))
  vec2 dc = destCoord(); 
     vec4 c = vec4(0.0); 
     
     vec4 center = sample(i, samplerCoord(i)); 
     
     c += sample(i, samplerTransform(i,dc + vec2(-1.5, 1.5))) * 0.16; 
     c += sample(i, samplerTransform(i,dc + vec2( 0.0, 1.5))) * 0.08; 
     c += sample(i, samplerTransform(i,dc + vec2(+1.5, 1.5))) * 0.16; 
     c += sample(i, samplerTransform(i,dc + vec2(-1.5, 0.0))) * 0.08; 
     c += center * 0.04;
     c += sample(i, samplerTransform(i,dc + vec2(+1.5, 0.0))) * 0.08; 
  c += sample(i, samplerTransform(i,dc + vec2(-1.5,-1.5))) * 0.16; 
     c += sample(i, samplerTransform(i,dc + vec2( 0.0,-1.5))) * 0.08; 
     c += sample(i, samplerTransform(i,dc + vec2( 1.5,-1.5))) * 0.16; 
     
  c = min (c,center);
     c.bg = vec2(0.0);
     c.a = center.a;
     c.a = 1.0;
     
     return c;
/tmp/inputToBoxBlur.tiff
/tmp/outputFromBoxBlur.tiff
T@"NSNumber",C,VinputNumIterations
kernel vec4 _circle (vec4 parms, __color color)
  float d = parms.z - length (destCoord() - parms.xy);
  return clamp (d * parms.w + .5, 0.0, 1.0) * color;
inputEdgeBlur
Warning smartToneStatistics will soon need [receiver properties] be non-nil so flash-fired state can be determined.
tonalRange
highKey
autoValue
blackPoint
whitePoint
satPercentile75
satPercentile98
satPercentileG98
satAutoValue
inputExposure
inputShadows
inputHighlights
inputBlack
inputLocalLight
inputRawHighlights
inputVibrancy
inputCast
inputUseCube
inputUseCubeColorSpace
kernel vec4 _smarttone_brightness_neg (__sample c, float gamma)
  vec3 neg = min(c.rgb, 0.0); 
  c.rgb = max(c.rgb, 0.0); 
  vec3 pix = pow(c.rgb, vec3(gamma)); 
  float lum = dot(c.rgb, vec3(0.39, .5, .11)); 
  vec3 pix2 = lum>0.0 ? c.rgb*pow(lum, gamma)/lum : vec3(0.0); 
  pix = mix(pix, pix2, 0.8) + neg; 
  return vec4(pix, c.a); 
kernel vec4 _smarttone_brightness_pos (__sample c, float gamma)
  vec3 neg = min(c.rgb, 0.0); 
  vec3 pos = max(c.rgb, 1.0)-1.0; 
  c.rgb = clamp(c.rgb, 0.0, 1.0); 
  vec3 m = 1.0-c.rgb; 
  float a = 0.6; 
  vec4 result = c; 
  result.rgb = 1.0 - (pow(m, vec3(gamma))+a*( ((gamma-1.0)*m*(1.0-m*m))/(gamma*gamma))); 
  c.rgb = pow(c.rgb, vec3(1.0-((min(gamma, 2.95)-1.0)/2.6))); 
  result.rgb = mix(c.rgb, result.rgb, .85); 
  result.rgb = result.rgb+neg+pos; 
  return result; 
kernel vec4 _smarttone_contrast (__sample im, float midAmt) 
  vec3 neg = min(im.rgb, 0.0); 
  vec3 pos = max(im.rgb, 1.0)-1.0; 
  im.rgb = clamp(im.rgb, 0.0, 1.0); 
  float y = dot(im.rgb, vec3(0.3333)); 
  y = sqrt(y); 
  float sat = (im.r-y)*(im.r-y)+(im.g-y)*(im.g-y)+(im.b-y)*(im.b-y); 
  y = y*(1.0-y); 
  im.rgb = sqrt(im.rgb); 
  float a = midAmt*y; 
  float b = -0.5*a; 
  vec3 pix = im.r * vec3(0.299*a) + 
             im.g * vec3(0.587*a) + 
             im.b * vec3(0.114*a) + 
             im.rgb + vec3(b); 
  im.rgb = mix(im.rgb, vec3(0.5), -y*midAmt); 
  im.rgb = mix(im.rgb, pix, 0.8+sat); 
  im.rgb = max(im.rgb, 0.0); 
  im.rgb *= im.rgb; 
  im.rgb = im.rgb + neg + pos; 
  return im; 
kernel vec4 _smarttone_highlightcontrast (__sample pix, float highAmt, float sat)
  float lum = clamp(dot(pix.rgb, vec3(.3333)),0.0,1.0); 
  vec3 high = pow(max(pix.rgb, 0.0), vec3(3.0 - 2.0*highAmt))  +  min(pix.rgb, 0.0); 
  float pivot = 0.8; 
  vec3 pix1 = (high - pivot)*(4.0 - 3.0*highAmt) + pivot; 
  float h = highAmt*highAmt*highAmt*highAmt; 
  float a = (4.0 - 3.0*h); 
  vec3 pix2 = (lum-pivot)*a+pivot + high.rgb -lum; 
  high = mix(pix2, pix1, sat); 
  pix.rgb = mix(pix.rgb, high, lum*lum); 
  return pix; 
kernel vec4 _rawHighlights(__sample pix, float gain) 
    vec3 high = gain*pix.rgb; 
    float lum = clamp(dot(pix.rgb, vec3(.3333)), 0.0, 1.0); 
    vec3 neg = min(high, 0.0); 
    high.rgb = mix(max(pix.rgb, 0.0), high.rgb, lum*lum) + neg; 
    return vec4(high, pix.a); 
CIColorCubeWithColorSpace
inputCubeData
inputCubeDimension
inputHighlightAmount
T@"NSNumber",&,N,VinputExposure
T@"NSNumber",&,N,VinputShadows
T@"NSNumber",&,N,VinputHighlights
T@"NSNumber",&,N,VinputBlack
T@"NSNumber",&,N,VinputRawHighlights
T@"NSNumber",&,N,VinputLocalLight
inputLightMap
T@"NSData",&,N,V_inputLightMap
T@"NSNumber",&,N,VinputUseCube
T@,&,N,VinputUseCubeColorSpace
kernel vec4 _smartcolor_contrast (__sample im, float amt)
  vec3 diff = im.rgb-dot(im.rgb, vec3(.0, .3, .5)); 
  float dist = distance(diff, vec3(0.0)); 
  dist = smoothstep(0.0, 1.0, dist); 
  float strength = 5.0*dist*amt; 
  vec3 pos = max(im.rgb, 1.0)-1.0 + min(im.rgb, 0.0); 
  im.rgb = clamp(im.rgb, 0.0, 1.0); 
  strength *= (im.b-im.g); 
  strength = max(strength, -0.35); 
  vec4 result; 
  result.rgb = im.rgb/(strength + 1.0 - (im.rgb*strength)) + pos; 
  result.a = im.a; 
  return result; 
kernel vec4 _smartcolor_contrast_darken (__sample im, float amt)
  vec3 diff = im.rgb-dot(im.rgb, vec3(.0, .3, .5)); 
  float dist = distance(diff, vec3(0.0)); 
  dist = smoothstep(0.0, 1.0, dist); 
  float strength = 5.0*dist*amt; 
  vec3 pos = max(im.rgb, 1.0)-1.0 + min(im.rgb, 0.0); 
  im.rgb = clamp(im.rgb, 0.0, 1.0); 
  strength *= (im.b-im.g); 
  float gray = 1.0-min(dot(im.rgb, vec3(0.5, 0.7, -0.20)), 1.0); 
  vec4 result; 
  result.rgb = strength < 0.0 ? pow(im.rgb, vec3(1.0-strength*gray)) : im.rgb/(strength+1.0-(im.rgb*strength)); 
  result.rgb += pos;  result.a = im.a; 
  return result; 
kernel vec4 _smartcolor_vibrancy_gt1 (__sample im, float amt) 
  float gray = dot(clamp(im.rgb, 0.0, 1.0), vec3(.3, .5, .2)); 
  float y = dot(clamp(im.rgb, 0.0, 1.0), vec3(.4, .2, .1)); 
  float damp = 1.0-4.0*y*(1.0-y); 
  float s = 1.0/(im.r+im.g+im.b); 
  float r = im.r*s; 
  float b = im.b*s; 
  float d = 1.0-.8*smoothstep(0.2, 0.4, r-b); 
  damp *= d; 
  damp = amt > 2.5 ? min(damp+(amt-2.5)/5.0, 1.0) : damp; 
  float sat = min(amt, 3.0); 
  vec4 result; 
  result.rgb = (im.rgb - gray)*sat + gray; 
  result.rgb = mix(im.rgb, result.rgb, damp); 
  result.a = im.a; 
  return result; 
kernel vec4 _smartcolor_vibrancy_lt1 (__sample im, float amt) 
  float gray = dot(im.rgb, vec3(0.333333)); 
  im.rgb = mix(vec3(gray), im.rgb, amt); 
  return im; 
kernel vec4 _smartcolor_cast (__sample im, float lum, float grayI, float grayQ, float strength) 
  vec4 pix = clamp(im, 0.0, 1.0);
  pix.rgb = pow(pix.rgb, vec3(.25));
  pix.rgb = pix.r * vec3(0.299,  0.595716,  0.211456) + 
            pix.g * vec3(0.587, -0.274453, -0.522591) + 
            pix.b * vec3(0.114, -0.321263,  0.311135); 
  vec2 grayOffset = vec2(grayI, grayQ) ; 
  vec3 result = pix.rgb; 
  float newStrength = 1.0 + (strength-1.0)*(1.0-pix.r) ; 
  result.gb = pix.gb + newStrength*grayOffset ; 
  float damp = max(min(1.0, pix.r/(lum+0.00001)),0.0) ; 
  result.rgb = mix(pix.rgb, result.rgb, damp) ; 
  pix.rgb = result.r * vec3(1.0) + 
            result.g * vec3(0.956296, -0.272122, -1.10699) + 
            result.b * vec3(0.621024, -0.647381, 1.70461); 
  pix.rgb = clamp(pix.rgb, 0.0, 1.0); 
  pix.rgb *= pix.rgb*pix.rgb*pix.rgb; 
  pix.rgb += min(im.rgb, 0.0) + max(im.rgb,1.0) -1.0; 
  return pix; 
T@"NSNumber",&,N,VinputVibrancy
T@"NSNumber",&,N,VinputCast
CI_SMART_TONE_USE_CUBE
CI_SMART_COLOR_USE_CUBE
CIBitmapContext bounds is too large
CIBitmapContext format %s is unsupported%s.
CIBitmapContext rowBytes must be a multiple of %ld.
CIBitmapContext output colorspace can't be used with pixel format %s. Using default output colorspace instead.
kernel vec2 _paddedTile(vec4 k) { return fract(destCoord() * k.zw) * k.xy + vec2(1.0); }
processor
v56@?0^^{__IOSurface}4^{Texture=(?={?=II}^v)}8^{CGRect={CGPoint=ff}{CGSize=ff}}12^B16^{__IOSurface=}20{Texture=(?={?=II}^v)}24{CGRect={CGPoint=ff}{CGSize=ff}}32B48^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd^{dispatch_queue_s}^{RenderTask}iBI^{dispatch_source_s}^{dispatch_group_s}}52
noop
builtin_colormatrix_rrra
builtin_colormatrixdiag
builtin_colormatrixdiag4
builtin_colormatrix3x1
builtin_colormatrix3x3
builtin_colormatrix3x4
builtin_colormatrix
color_matrix_rrra
color_matrix_diag [%g, %g, %g]
color_matrix_diag4 [%g, %g, %g, %g]
color_matrix_3x1 [%g, %g, %g]
color_matrix_3x3 (
r=[%g %g %g],
g=[%g %g %g],
b=[%g %g %g])
color_matrix_3x4 (
bias=[%g %g %g])
color_matrix_4x3 (
r=[%g %g %g %g],
g=[%g %g %g %g],
b=[%g %g %g %g],
color_matrix (
a=[%g %g %g %g],
bias=[%g %g %g %g])
color_matrix_diag
color_matrix_diag4
color_matrix_3x1
color_matrix_3x3
color_matrix_3x4
color_matrix_4x3
colormatrix
kCIImageAutoAdjustEnhance
kCIImageAutoAdjustRedEye
kCIImageAutoAdjustFeatures
kCIImageAutoAdjustCrop
kCIImageAutoAdjustLevel
CIDetectorBetterEyeLocs
   adding crop rect: x=%.3f,y=%.3f,w=%.3f,h=%.3f
inputOrigI
inputOrigQ
inputWarmth
inputPoint2
inputPoint3
inputPoint4
iPhone
iPad
DUMP_AUTO_ENHANCE_ARRAY
filters = %@
leftEyeX
leftEyeY
rightEyeX
rightEyeY
mouthCenterX
mouthCenterY
leftEyePosition
leftEye
rightEyePosition
rightEye
leftEyeTouchSize
leftEyeSize
rightEyeTouchSize
rightEyeSize
mouthPosition
mouthCenter
inputCameraModel
inputCorrectionInfo
kIOSurfaceWidth
kIOSurfaceHeight
kIOSurfaceBytesPerRow
kIOSurfaceBytesPerElement
kIOSurfaceElementWidth
kIOSurfaceElementHeight
kIOSurfaceClientAddress
kIOSurfaceAllocSize
kIOSurfacePlaneInfo
kIOSurfacePlaneWidth
kIOSurfacePlaneHeight
kIOSurfacePlaneBytesPerRow
kIOSurfacePlaneBytesPerElement
kIOSurfacePlaneElementWidth
kIOSurfacePlaneElementHeight
kIOSurfacePlaneOffset
kIOSurfacePlaneSize
kIOSurfacePixelFormat
kIOSurfaceCacheMode
kIOSurfaceYCbCrMatrix
kIOSurfaceYCbCrMatrix_ITU_R_709_2_String
kIOSurfaceYCbCrMatrix_ITU_R_601_4_String
kIOSurfaceYCbCrMatrix_SMPTE_240M_1995_String
.png
.jpg
IOSurface
<IOSurface %p refcnt=%d>
com.apple.surface.isolationqueue
CI_TRASH_SURFACES_ON_SETVOLATILE
profileType
description
gammaR
gammaG
gammaB
phosphorRx
phosphorRy
phosphorGx
phosphorGy
phosphorBx
phosphorBy
whitePointx
whitePointy
copyright
displayRGB
HDTV
Composite NTSC
Composite PAL
HDTV Interim Color Implementation
Digital Cinema P3
D65 P3
QuickTime 'nclc' Video (%d,%d,%d)
Copyright 2007 Apple Inc.
rTRC
gTRC
bTRC
providerGetBytesAtPositionCallback_HtoF_surface
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/misc/Surface.c
info
buffer
providerGetBytesAtPositionCallback_2C08_surface
providerGetBytesAtPositionCallback_YCbYCr_surface
providerGetBytesAtPositionCallback_CbYCrY_surface
providerGetBytesAtPositionCallback_YCbYCrFull_surface
providerGetBytesAtPositionCallback_CbYCrYFull_surface
providerGetBytesAtPositionCallback_2C0h_surface
providerGetBytesAtPositionCallback_2C0f_surface
providerGetBytesAtPositionCallback_1C08_surface
providerGetBytesAtPositionCallback_A008_surface
providerGetBytesAtPositionCallback_1C0f_surface
providerGetBytesAtPositionCallback_1C0h_surface
providerGetBytePointerCallback
providerReleaseBytePointerCallback
undefined
CIRedEyeCorrections %lu
T@"NSString",C,N,VinputCameraModel
T@"NSDictionary",C,N,VinputCorrectionInfo
CIRedEyeCorrection
x = %.5f, y = %.5f, width = %.5f, height = %.5f, alpha = 0.0244, density = 0.86, strength = 0.0757, redBias = 0.253, pupilSize = 0.50, pupilDarkenAmount = 0.75
pointX
pointY
%@ %@ %@
%@ %@ %@ %@
pupilShadeLow
pupilShadeMedium
pupilShadeHigh
pupilShadeAverage
interocularDistance
%@ %@
snappedX
snappedY
bitmaskX
bitmaskY
bitmaskThreshold
cornealReflectionX
cornealReflectionY
cornealReflectionThreshold
existingPupilLow
existingPupilMedium
existingPupilHigh
existingPupilAverage
averageSkinLuminance
searchRectangleMinimumY
searchRectangleMaximumY
searchRectangleMinimumX
searchRectangleMaximumX
repairRectangleMinimumY
repairRectangleMaximumY
repairRectangleMinimumX
repairRectangleMaximumX
forceCase
pupilShadeAlignment
finalEyeCase
RedEyeInfo
RedEyeW
fullImageWidth
RedEyeH
fullImageHeight
RedEyeISV
imageSpecialValue
RedEyeOrt
imageOrientation
RedEyeSNR
imageSignalToNoiseRatio
http://ns.apple.com/adjustment-settings/1.0/sType/redeye
RedEyeCorrections
RedEyeModel
http://ns.apple.com/adjustment-settings/1.0/sType/red-eye
T@"NSArray",C,N,VinputCorrectionInfo
vImageConvert_Planar16FtoPlanar8 error %zi in CIRedEyeCorrection
Unknown input pixel format in CIRedEyeCorrection %i
vImageConvert_Planar8toPlanar16F error %zi in CIRedEyeCorrection
Unknown output pixel format in CIRedEyeCorrection %i
kernel vec4 _convolutionAdd_1(sampler src, sampler sums, vec2 offset1, float weight1)
  vec4 sum = sample(sums, samplerCoord(sums));
  vec2 coord = destCoord();
  vec4 pix1 = sample(src, samplerTransform(src, coord + offset1));
  return sum + pix1 * weight1;
kernel vec4 _convolutionAdd_2(sampler src, sampler sums, vec2 offset1, vec2 offset2, vec2 weight1)
  vec4 sum = sample(sums, samplerCoord(sums));
  vec2 coord = destCoord();
  vec4 pix1 = sample(src, samplerTransform(src, coord + offset1));
  vec4 pix2 = sample(src, samplerTransform(src, coord + offset2));
  return sum + pix1 * weight1.x + pix2 * weight1.y;
kernel vec4 _convolutionAdd_3(sampler src, sampler sums, vec2 offset1, vec2 offset2, vec2 offset3, vec3 weight1)
  vec4 sum = sample(sums, samplerCoord(sums));
  vec2 coord = destCoord();
  vec4 pix1 = sample(src, samplerTransform(src, coord + offset1));
  vec4 pix2 = sample(src, samplerTransform(src, coord + offset2));
  vec4 pix3 = sample(src, samplerTransform(src, coord + offset3));
  return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z;
kernel vec4 _convolutionAdd_4(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec4 weight1)
  vec4 sum = sample(sums, samplerCoord(sums));
  vec2 coord = destCoord();
  vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy));
  vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw));
  vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy));
  vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw));
  return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w;
kernel vec4 _convolutionAdd_5(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec2 offset5, vec4 weight1, float weight2)
  vec4 sum = sample(sums, samplerCoord(sums));
  vec2 coord = destCoord();
  vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy));
  vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw));
  vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy));
  vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw));
  vec4 pix5 = sample(src, samplerTransform(src, coord + offset5));
  return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w + pix5 * weight2;
kernel vec4 _convolutionAdd_6(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec4 offset56, vec4 weight1, vec2 weight2)
  vec4 sum = sample(sums, samplerCoord(sums));
  vec2 coord = destCoord();
  vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy));
  vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw));
  vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy));
  vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw));
  vec4 pix5 = sample(src, samplerTransform(src, coord + offset56.xy));
  vec4 pix6 = sample(src, samplerTransform(src, coord + offset56.zw));
  return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w + pix5 * weight2.x + pix6 * weight2.y;
kernel vec4 _convolutionAdd_7(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec4 offset56, vec2 offset7, vec4 weight1, vec3 weight2)
  vec4 sum = sample(sums, samplerCoord(sums));
  vec2 coord = destCoord();
  vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy));
  vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw));
  vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy));
  vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw));
  vec4 pix5 = sample(src, samplerTransform(src, coord + offset56.xy));
  vec4 pix6 = sample(src, samplerTransform(src, coord + offset56.zw));
  vec4 pix7 = sample(src, samplerTransform(src, coord + offset7));
  return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w + pix5 * weight2.x + pix6 * weight2.y + pix7 * weight2.z;
kernel vec4 _convolutionAdd_8(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec4 offset56, vec4 offset78, vec4 weight1, vec4 weight2)
  vec4 sum = sample(sums, samplerCoord(sums));
  vec2 coord = destCoord();
  vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy));
  vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw));
  vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy));
  vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw));
  vec4 pix5 = sample(src, samplerTransform(src, coord + offset56.xy));
  vec4 pix6 = sample(src, samplerTransform(src, coord + offset56.zw));
  vec4 pix7 = sample(src, samplerTransform(src, coord + offset78.xy));
  vec4 pix8 = sample(src, samplerTransform(src, coord + offset78.zw));
  return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w + pix5 * weight2.x + pix6 * weight2.y + pix7 * weight2.z + pix8 * weight2.w;
inputRingAmount
inputRingSize
inputSoftness
inputPointCount
down
conv3
conv5
conv7
add4
add8and8
add4and8
add8
CIConvolution3X3
CIConvolution5X5
CIConvolution7X7
add4and4
kernel vec4 _downhalf (sampler i) 
  vec2 dc = destCoord() * 2.0; 
  vec4 s = sample(i, samplerTransform(i,dc+vec2(-1.,0.))); 
  s += sample(i, samplerTransform(i,dc+vec2(1.,0.))); 
  s += sample(i, samplerTransform(i,dc+vec2(0.,1.))); 
  s += sample(i, samplerTransform(i,dc+vec2(0.,-1.))); 
  return s * 0.25; 
kernel vec4 _box3 (sampler image, float r) 
  vec4 rr = vec4(-r,0.0,r,0.0); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += sample(image, samplerTransform(image,dc+rr.xx)); 
  c += sample(image, samplerTransform(image,dc+rr.xy)); 
  c += sample(image, samplerTransform(image,dc+rr.xz)); 
  c += sample(image, samplerTransform(image,dc+rr.yx)); 
  c += sample(image, samplerTransform(image,dc+rr.yy)); 
  c += sample(image, samplerTransform(image,dc+rr.yz)); 
  c += sample(image, samplerTransform(image,dc+rr.zx)); 
  c += sample(image, samplerTransform(image,dc+rr.zy)); 
  c += sample(image, samplerTransform(image,dc+rr.zz)); 
  return c / 9.0; 
kernel vec4 _add4 (sampler a, sampler b, vec2 pt, vec2 w) 
  vec4 p = vec4(pt,-pt); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c *= w.y; 
  c += sample(a, samplerCoord(a)) * w.x; 
  return c; 
kernel vec4 _add8 (sampler a, sampler b, vec2 pt, vec2 w) 
  vec4 p = vec4(pt,-pt); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  c *= w.y; 
  c += sample(a, samplerCoord(a)) * w.x; 
  return c; 
kernel vec4 _add4and4 (sampler a, sampler b, vec4 pt, vec4 w) 
  vec4 p = vec4(pt.xy,-pt.xy); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += (sample(b, samplerTransform(b,dc+p.xy)) +         sample(b, samplerTransform(b,dc+p.yz)) +         sample(b, samplerTransform(b,dc+p.zw)) +         sample(b, samplerTransform(b,dc+p.wx))) * w.y; 
  p = vec4(pt.zw,-pt.zw); 
  c += (sample(b, samplerTransform(b,dc+p.xy)) +         sample(b, samplerTransform(b,dc+p.yz)) +         sample(b, samplerTransform(b,dc+p.zw)) +         sample(b, samplerTransform(b,dc+p.wx))) * w.z; 
  c += sample(a, samplerCoord(a)) * w.x; 
  return c; 
kernel vec4 _add4and8 (sampler a, sampler b, vec4 pt, vec4 w) 
  vec4 p = vec4(pt.xy,-pt.xy); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += (sample(b, samplerTransform(b,dc+p.xy)) +         sample(b, samplerTransform(b,dc+p.yz)) +         sample(b, samplerTransform(b,dc+p.zw)) +         sample(b, samplerTransform(b,dc+p.wx))) * w.y; 
  p = vec4(pt.zw,-pt.zw); 
  c += (sample(b, samplerTransform(b,dc+p.xy)) +         sample(b, samplerTransform(b,dc+p.yz)) +         sample(b, samplerTransform(b,dc+p.zw)) +         sample(b, samplerTransform(b,dc+p.wx)) +         sample(b, samplerTransform(b,dc+p.yx)) +         sample(b, samplerTransform(b,dc+p.zy)) +         sample(b, samplerTransform(b,dc+p.wz)) +         sample(b, samplerTransform(b,dc+p.xw))) * w.z; 
  c += sample(a, samplerCoord(a)) * w.x; 
  return c; 
kernel vec4 _add8and8 (sampler a, sampler b, vec4 pt, vec4 w) 
  vec4 p = vec4(pt.xy,-pt.xy); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += (sample(b, samplerTransform(b,dc+p.xy)) +         sample(b, samplerTransform(b,dc+p.yz)) +         sample(b, samplerTransform(b,dc+p.zw)) +         sample(b, samplerTransform(b,dc+p.wx)) +         sample(b, samplerTransform(b,dc+p.yx)) +         sample(b, samplerTransform(b,dc+p.zy)) +         sample(b, samplerTransform(b,dc+p.wz)) +         sample(b, samplerTransform(b,dc+p.xw))) * w.y; 
  p = vec4(pt.zw,-pt.zw); 
  c += (sample(b, samplerTransform(b,dc+p.xy)) +         sample(b, samplerTransform(b,dc+p.yz)) +         sample(b, samplerTransform(b,dc+p.zw)) +         sample(b, samplerTransform(b,dc+p.wx)) +         sample(b, samplerTransform(b,dc+p.yx)) +         sample(b, samplerTransform(b,dc+p.zy)) +         sample(b, samplerTransform(b,dc+p.wz)) +         sample(b, samplerTransform(b,dc+p.xw))) * w.z; 
  c += sample(a, samplerCoord(a)) * w.x; 
  return c; 
kernel vec4 _ringAvg8 (sampler b, vec4 pts) 
  vec4 p = vec4(pts.xy,-pts.xy); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  return c / 8.0; 
kernel vec4 _ringAvg16 (sampler b, vec4 pts) 
  vec4 p = vec4(pts.xy,-pts.xy); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  p = vec4(pts.zw,-pts.zw); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  return c / 16.0; 
kernel vec4 _ringAvg24 (sampler b, vec4 pts, vec2 pts2) 
  vec4 p = vec4(pts.xy,-pts.xy); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  p = vec4(pts.zw,-pts.zw); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  p = vec4(pts2.xy,-pts2.xy); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  return c / 24.0; 
kernel vec4 _ringAvg32 (sampler b, vec4 pts, vec4 pts2) 
  vec4 p = vec4(pts.xy,-pts.xy); 
  vec2 dc = destCoord(); 
  vec4 c = vec4(0.0); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  p = vec4(pts.zw,-pts.zw); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  p = vec4(pts2.xy,-pts2.xy); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  p = vec4(pts2.zw,-pts2.zw); 
  c += sample(b, samplerTransform(b,dc+p.xy)); 
  c += sample(b, samplerTransform(b,dc+p.yz)); 
  c += sample(b, samplerTransform(b,dc+p.zw)); 
  c += sample(b, samplerTransform(b,dc+p.wx)); 
  c += sample(b, samplerTransform(b,dc+p.yx)); 
  c += sample(b, samplerTransform(b,dc+p.zy)); 
  c += sample(b, samplerTransform(b,dc+p.wz)); 
  c += sample(b, samplerTransform(b,dc+p.xw)); 
  return c / 32.0; 
convert_identity
convert_rgb8_to_rgba8
convert_rgb16_to_rgba16
convert_rgbh_to_rgbah
convert_rgbf_to_rgbaf
convert_rgba16_to_rgbah
convert_rgbaf_to_rgbah
convert_rgb16_to_rgbah
convert_rgbf_to_rgbah
convert_r8_to_rh
convert_rh_to_r8
convert_r8_to_rf
convert_rf_to_r8
convert_rh_to_rf
convert_rf_to_rh
convert_rgbah_to_rh
convert_rh_to_rgbah
convert_rgbaf_to_rf
convert_rf_to_rgbaf
unknown-conversion
v8@?0L4
size = %d, center = %d, %d, I = %g, Q = %g
Ti,R,Vsize
centerX
Ti,R,VcenterX
centerY
Ti,R,VcenterY
Td,R,VI
Td,R,VQ
kernel vec2 _droste(vec2 center, vec2 r, float logScale, vec2 rotzoom, vec2 innerSizeHalved)
  vec2 c = destCoord() - center;
  float theta = atan(c.y, c.x) + rotzoom.x;
  vec2 polar = vec2(0.5 * log(dot(c,c)), theta);
  vec2 rotated = vec2( polar.x * r.x - polar.y * r.y, dot(polar, r.yx));
  vec2 coord = exp(rotated.x) * cossin(rotated.y);
  coord *= rotzoom.y;
  float d0 = max(abs(coord.x)/innerSizeHalved.x,
                 abs(coord.y)/innerSizeHalved.y);
  float myMod; { 
    float a = log(d0); 
    float b = logScale; 
    myMod = a - b*floor(a/b); 
  } 
  float d1 = exp(myMod);
  coord *= ( d1 / d0 );
  return coord + center;
inputInsetPoint0
inputInsetPoint1
inputPeriodicity
inputStrands
inputRotation
inputZoom
-[CIRenderDestination init]
internal CI render destination is invalid.
internal CI image is invalid.
internal CI context is invalid.
-[CIRenderDestination initWithPixelBuffer:]
-[CIRenderDestination initWithWidth:height:pixelFormat:colorSpace:pixelBufferProvider:]
-[CIRenderDestination initWithGLTexture:target:width:height:]
-[CIRenderDestination initWithBitmapData:width:height:bytesPerRow:format:]
-[CIRenderDestination setAlphaMode:]
-[CIRenderDestination setColorSpace:]
-[CIRenderDestination setBlendKernel:]
<%@: %p format: %s size: %ux%u
 %@>
    alphaMode: None
    alphaMode: Premultiplied
    alphaMode: Unpremultiplied
    blendKernel: %@
    blendsInDestinationColorSpace: %d
    flipped: %d
    dithered: %d
    clamped: %d
width
TI,R
height
alphaMode
flipped
TB,GisFlipped
dithered
TB,GisDithered
clamped
TB,GisClamped
T^{CGColorSpace=},N
blendKernel
T@"CIBlendKernel",&,N
blendsInDestinationColorSpace
-[CIRenderInfo init]
<%@: %p>{
kernelExecutionTime: %.5f ms 
passCount: %ld 
pixelsProcessed: %ld 
kernelExecutionTime
Td,R
passCount
pixelsProcessed
-[CIRenderTask init]
CIRenderTaskWaitUntilCompleted
Unexpected error in the backing renderer.
-[CIRenderTask waitUntilCompletedAndReturnError:]
CIContextStartTask
The CIContext is invalid.
-[CIContext(CIRenderDestination) _startTaskToRender:toDestination:forPrepareRender:error:]
The destination is nil.
The destination is invalid.
The image extent and destination extent do not intersect.
CIContextRenderDestination
kernel vec4 _destDither (__sample c, __sample n, float amount) 
    float nn = (n.r + n.g + n.b + n.a)*0.25 - 0.5; 
    c.rgb = clamp(c.rgb + amount*nn, 0.0, 1.0); 
    return c; 
CIRandomGenerator
bytes
green
blue
alpha
bounds
faceBalanceEnabled
TB,VfaceBalanceEnabled
vibranceEnabled
TB,VvibranceEnabled
curvesEnabled
TB,VcurvesEnabled
shadowsEnabled
TB,VshadowsEnabled
kernel vec4 _curve16 (__sample s, sampler2D curveImage, vec2 normalizer)
  s.rgb = normalizer.x * s.rgb + normalizer.y;
  vec2 v = texture2D(curveImage, vec2(s.r , 0.5)).rg;
  s.r = 0.9961089494 * v.r + 0.0038910506 * v.g;
  v = texture2D(curveImage, vec2(s.g, 0.5)).rg;
  s.g = 0.9961089494 * v.r + 0.0038910506 * v.g;
  v = texture2D(curveImage, vec2(s.b, 0.5)).rg;
  s.b = 0.9961089494 * v.r + 0.0038910506 * v.g;
  return s;
%d, %d
Curve0x
Curve0y
Curve1x
Curve1y
Curve2x
Curve2y
Curve3x
Curve3y
Curve4x
Curve4y
ToneCurve
ToneCurveName
Custom
T@"CIVector",C,N,VinputPoint0
T@"CIVector",C,N,VinputPoint1
T@"CIVector",C,N,VinputPoint2
T@"CIVector",C,N,VinputPoint3
T@"CIVector",C,N,VinputPoint4
CIFilterAddedNotification
CIConstructorKey
CIAccordionFoldTransition
CIAdditionCompositing
CIAffineClamp
CIAffineTile
CIAreaAverage
CIAreaHistogram
CIAreaMaximumAlpha
CIAreaMinimumAlpha
CIAreaMinMaxNormalize
CIAreaMinMaxRedNormalize
CIBicubicScaleTransform
CIRowAverage
CIAztecCodeGenerator
CIBarsSwipeTransition
CIBlendWithMask
CIBlendWithRedMask
CIBlendWithBlueMask
CIBlendWithAlphaMask
CIBloom
CIBokehBlur
CIBoxBlur
CIBumpDistortion
CIBumpDistortionLinear
CICheatBlur
CICheapBlur
CICheapMorphology
CICheckerboardGenerator
CICircleGenerator
CICircleSplashDistortion
CICircularScreen
CICircularWrap
CIClamp
CICMYKHalftone
CICode128BarcodeGenerator
CIColorBalance
CIColorBlendMode
CIColorBurnBlendMode
CIColorClamp
CIColorCrossPolynomial
CIColorCube
CIColorCubesMixedWithMask
CIColorCurves
CIColorDodgeBlendMode
CIColorInvert
CIColorMap
CIColorMonochrome
CIColorPolynomial
CIColorPosterize
CIComicEffect
CIConstantColorGenerator
CIConvolution9Horizontal
CIConvolution9Vertical
CICopyMachineTransition
CICrystallize
CIDarkenBlendMode
CIDepthBlurEffect
CIDepthEffectApplyBlurMap
CIDepthEffectMakeBlurMap
CIDepthOfField
CIDepthToDisparity
CIDifferenceBlendMode
CIDisintegrateWithMaskTransition
CIDisparityRefinement
CIDisparityToDepth
CIDisplacementDistortion
CIDissolveTransition
CIDivideBlendMode
CIDotScreen
CIDroste
CIEdges
CIEdgePreserveUpsampleFilter
CIEdgeWork
CIEightfoldReflectedTile
CIExclusionBlendMode
CIFalseColor
CIFlashTransition
CIFourfoldReflectedTile
CIFourfoldRotatedTile
CIFourfoldTranslatedTile
CIGammaAdjust
CIGaussianBlurXY
CIGaussianGradient
CIGlideReflectedTile
CIGloom
CIGlassDistortion
CIGlassLozenge
CIHardLightBlendMode
CIHardMixBlendMode
CIHatchedScreen
CIHeightFieldFromMask
CIHexagonalPixellate
CIHistogramDisplayFilter
CIHoleDistortion
CIHueAdjust
CIHueBlendMode
CIHueSaturationValueGradient
CIIntegralImage
CIKaleidoscope
CILabDeltaE
CILanczosScaleTransform
CILenticularHaloGenerator
CILightTunnel
CILightenBlendMode
CILinearLightBlendMode
CILineScreen
CILinearBurnBlendMode
CILinearDodgeBlendMode
CILinearGradient
CILineOverlay
CILuminosityBlendMode
CIMaskToAlpha
CIMaximumComponent
CIMaximumCompositing
CIMedianFilter
CIMinimumComponent
CIMinimumCompositing
CIMirror
CIModTransition
CIMorphologyMinimum
CIMorphologyGradient
CIMorphologyLaplacian
CIMotionBlur
CIMultiplyBlendMode
CIMultiplyCompositing
CINinePartStretched
CINinePartTiled
CINoiseReduction
CIOpacity
CIOpTile
CIOverlayBlendMode
CIPDF417BarcodeGenerator
CIPaperWash
CIDocumentEnhancer
CIPageCurlTransition
CIPageCurlWithShadowTransition
CIParallelogramTile
CIPerspectiveTile
CIPerspectiveTransform
CIPerspectiveTransformWithExtent
CIPerspectiveCorrection
CIPhotoEffectNoir
CIPhotoEffectChrome
CIPhotoEffectFade
CIPhotoEffectInstant
CIPhotoEffectMono
CIPhotoEffectProcess
CIPhotoEffectTonal
CIPhotoEffectTransfer
CIPinLightBlendMode
CIPinchDistortion
CIPixellate
CIPointillize
CIPremultiply
CIProSharpenEdges
CIPseudoMedian
CIQRCodeGenerator
CIRadialGradient
CIRectangleGenerator
CIRippleTransition
CIRingBlur
CISaturationBlendMode
CIScreenBlendMode
CISepiaTone
CIShadedMaterial
CISharpenLuminance
CISimpleTile
CISixfoldReflectedTile
CISixfoldRotatedTile
CISkyAndGrassAdjust
CISmartColorFilter
CISmartToneFilter
CISmoothLinearGradient
CISpotColor
CISpotLight
CISoftLightBlendMode
CISourceAtopCompositing
CISourceInCompositing
CISourceOutCompositing
CIStarShineGenerator
CIStraightenFilter
CIStretch
CIStretchCrop
CIStripesGenerator
CISubtractBlendMode
CISunbeamsGenerator
CISwipeTransition
CITemperatureAndTint
CIThermal
CITorusLensDistortion
CITriangleKaleidoscope
CITriangleTile
CITwelvefoldReflectedTile
CITwirlDistortion
CIUnpremultiply
CIVariableBoxBlur
CIVignette
CIVignetteEffect
CIVividLightBlendMode
CIVortexDistortion
CIWhitePointAdjust
CIWrapMirror
CIXRay
CIZoomBlur
CUIScaleClampFilter
CUIOuterBevelEmbossFilter
CUIOuterGlowOrShadowFilter
CUIInnerBevelEmbossFilter
CUIInnerGlowOrShadowFilter
CUIShapeEffectBlur1
CIPlusDarkerCompositing
CIPlusLighterCompositing
CIMaskedVariableBlur
CISmartBlackAndWhite
CIPhotoGrain
CIPassThroughColorFilter
CIPassThroughWarpFilter
CIPassThroughGeneralFilter
CIPassThroughGeneralAltFilter
CIPassThroughIntermediateFilter
CIPassThroughSelectFrom3
CITextImageGenerator
CIAttributedTextImageGenerator
CIBarcodeGenerator
CIPortraitPrepareStage
[CIFilter registerFilterName:constructor:classAttributes:] needs a name parameter.
[CIFilter registerFilterName:constructor:classAttributes:] registration of '%@' should provide a contructor object or class.
[CIFilter registerFilterName:constructor:classAttributes:] registration of '%@' should not provide a contructor class that is just [CIFilter class].
filterWithName:
[CIFilter registerFilterName:constructor:classAttributes:] registration of '%@' needs a constructor object or class that implements filterWithName:
[CIFilter registerFilterName:constructor:classAttributes:] registration of '%@' needs a constructor object or class that overrides filterWithName:
Categories
Descriptions
%s [constructor filterWithName:%@] returned nil.
+[CIFilter(CIFilterRegistryPrivate) filterWithName:setDefaults:]
%s [constructor filterWithName:%@] returned an object of class %@.
+[CIFilter(CIFilterRegistryPrivate) filterWithName:setDefaults:]_block_invoke
http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/%@
Keys
<none>
input
output
<%@: inputKeys=%@ inputClasses=%@ outputKeys=%@>
com.apple.coreimage.CIFilterRegistryIsolation
customAttributes
%@ -customAttributes is not supported on iOS. Implement +customAttributes instead.
iIsSlLqQBfdcC
NSObject
kernel vec4 _highlightsAndShadows2(__sample pix, __sample blur, vec4 params)
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max( 0.001, pix.r + pix.g + pix.b); 
  float shadAmt = params.x * pow(min(rgbFactor, 1.0), 1.0-params.x); 
  vec3 shadExp = mix(pow(vec3(2.0), (-shadAmt - blur.rgb)), vec3(1.0), params.z); 
  float blurLum2 = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(blurLum2); 
  float kGain = 0.5 + 0.5*smoothstep(0.5, 1.0, params.x); 
  float newGain = shadAmt; 
  vec3 neg = min(pix.rgb, 0.0); 
  vec3 shad = (1.0+newGain)*pow(max(pix.rgb, 0.0)*kGain, shadExp)*2.0; 
  vec3 ycc = pix.r * vec3(0.299, 0.596, 0.212) + 
             pix.g * vec3(0.587, -0.2755, -0.523) + 
             pix.b * vec3(0.114, -0.321, 0.311); 
  float Y = pow(max(ycc.r, 0.0)*kGain, shadExp.r)*2.0; 
  vec3 shad2 = Y * vec3(1.00048, 0.999864, 0.999446) + 
           ycc.g * vec3(0.955558, -0.271545, -1.10803) + 
           ycc.b * vec3(0.619549, -0.646786, 1.70542); 
  shad = mix(shad, shad2, 0.35); 
  shad = mix(pix.rgb, shad, (smoothstep(0.0, 0.1+shadAmt, sqrt(blurLum)))); 
  shad = mix(shad, pix.rgb, blurLum); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  Y = dot(high, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float kHighMix = 1.0 + (1.0-min(1.0, params.y+0.3))*0.4; 
  vec3 mid = mix(vec3(0.25), high, kHighMix); 
  float highBoost = min(effectAmount, 30.0*blurLum2) * (1.0-params.y); 
  high = mix(high, mid, highBoost); 
  high = mix(pix.rgb, high, smoothstep(0.2, 0.8, blurLum)); 
  high = mix(pix.rgb, high, blurLum2); 
  vec4 result; 
  result.rgb = mix(shad, high, min(blurLum, 1.0)); 
  Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float midAmt = abs(shadAmt)*0.1*(1.0-params.z); 
  mid = mix(vec3(0.5), result.rgb, 1.0 + midAmt); 
  result.rgb = mix(result.rgb, mid, min(effectAmount, 30.0*blurLum2)); 
  result.rgb = max(result.rgb, 0.0)+neg; 
  result.a = pix.a; 
  return result; 
kernel vec4 _highlightsAndShadows_noblur2(__sample pix, vec4 params)
  vec4 blur = pix; 
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max( 0.001, pix.r + pix.g + pix.b); 
  float shadAmt = params.x * pow(min(rgbFactor, 1.0), 1.0-params.x); 
  vec3 shadExp = mix(pow(vec3(2.0), (-shadAmt - blur.rgb)), vec3(1.0), params.z); 
  float blurLum2 = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(blurLum2); 
  float kGain = 0.5 + 0.5*smoothstep(0.5, 1.0, params.x); 
  float newGain = shadAmt; 
  vec3 neg = min(pix.rgb, 0.0); 
  vec3 shad = (1.0+newGain)*pow(max(pix.rgb, 0.0)*kGain, shadExp)*2.0; 
  vec3 ycc = pix.r * vec3(0.299, 0.596, 0.212) + 
             pix.g * vec3(0.587, -0.2755, -0.523) + 
             pix.b * vec3(0.114, -0.321, 0.311); 
  float Y = sign(ycc.r)*pow(abs(ycc.r)*kGain, shadExp.r)*2.0; 
  vec3 shad2 = Y * vec3(1.00048, 0.999864, 0.999446) + 
           ycc.g * vec3(0.955558, -0.271545, -1.10803) + 
           ycc.b * vec3(0.619549, -0.646786, 1.70542); 
  shad = mix(shad, shad2, 0.35); 
  shad = mix(pix.rgb, shad, (smoothstep(0.0, 0.1+shadAmt, sqrt(blurLum)))); 
  shad = mix(shad, pix.rgb, blurLum); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  Y = dot(high, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float kHighMix = 1.0 + (1.0-min(1.0, params.y+0.3))*0.4; 
  vec3 mid = mix(vec3(0.25), high, kHighMix); 
  float highBoost = min(effectAmount, 30.0*blurLum2) * (1.0-params.y); 
  high = mix(high, mid, highBoost); 
  high = mix(pix.rgb, high, smoothstep(0.2, 0.8, blurLum)); 
  high = mix(pix.rgb, high, blurLum2); 
  vec4 result; 
  result.rgb = mix(shad, high, min(blurLum, 1.0)); 
  Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float midAmt = abs(shadAmt)*0.1*(1.0-params.z); 
  mid = mix(vec3(0.5), result.rgb, 1.0 + midAmt); 
  result.rgb = mix(result.rgb, mid, min(effectAmount, 30.0*blurLum2)); 
  result.rgb = max(result.rgb, 0.0)+neg; 
  result.a = pix.a; 
  return result; 
kernel vec4 _highlightsAndShadows1(__sample pix, __sample blur, vec4 params)
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max( 0.001, pix.r + pix.g + pix.b); 
  float shadAmt = params.x * pow(min(rgbFactor, 1.0), 1.0-params.x); 
  vec3 shadExp = mix(pow(vec3(2.0), (-shadAmt - blur.rgb)), vec3(1.0), params.z); 
  float blurLum2 = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(blurLum2); 
  float kGain = 0.5 + 0.5*smoothstep(0.5, 1.0, params.x); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*kGain, shadExp)*2.0; 
  vec3 ycc = pix.r * vec3(0.299, 0.596, 0.212) + 
             pix.g * vec3(0.587, -0.2755, -0.523) + 
             pix.b * vec3(0.114, -0.321, 0.311); 
  float Y = sign(ycc.r)*pow(abs(ycc.r)*kGain, shadExp.r)*2.0; 
  vec3 shad2 = Y * vec3(1.00048, 0.999864, 0.999446) + 
           ycc.g * vec3(0.955558, -0.271545, -1.10803) + 
           ycc.b * vec3(0.619549, -0.646786, 1.70542); 
  shad = mix(shad, shad2, 0.35); 
  shad = mix(pix.rgb, shad, sqrt(smoothstep(0.0, 0.1+shadAmt, sqrt(blurLum)))); 
  shad = mix(shad, pix.rgb, blurLum); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  Y = dot(high, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float kHighMix = 1.0 + (1.0-min(1.0, params.y+0.3))*0.4; 
  vec3 mid = mix(vec3(0.25), high, kHighMix); 
  float highBoost = min(effectAmount, 30.0*blurLum2) * (1.0-params.y); 
  high = mix(high, mid, highBoost); 
  high = mix(pix.rgb, high, smoothstep(0.2, 0.8, blurLum)); 
  high = mix(pix.rgb, high, blurLum2); 
  vec4 result; 
  result.rgb = mix(shad, high, min(blurLum, 1.0)); 
  Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float midAmt = abs(shadAmt)*0.1*(1.0-params.z); 
  mid = mix(vec3(0.5), result.rgb, 1.0 + midAmt); 
  result.rgb = mix(result.rgb, mid, min(effectAmount, 30.0*blurLum2)); 
  result.a = pix.a; 
  return result; 
kernel vec4 _highlightsAndShadows_noblur1(__sample pix, vec4 params)
  vec4 blur = pix; 
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max( 0.001, pix.r + pix.g + pix.b); 
  float shadAmt = params.x * pow(min(rgbFactor, 1.0), 1.0-params.x); 
  vec3 shadExp = mix(pow(vec3(2.0), (-shadAmt - blur.rgb)), vec3(1.0), params.z); 
  float blurLum2 = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(blurLum2); 
  float kGain = 0.5 + 0.5*smoothstep(0.5, 1.0, params.x); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*kGain, shadExp)*2.0; 
  vec3 ycc = pix.r * vec3(0.299, 0.596, 0.212) + 
             pix.g * vec3(0.587, -0.2755, -0.523) + 
             pix.b * vec3(0.114, -0.321, 0.311); 
  float Y = sign(ycc.r)*pow(abs(ycc.r)*kGain, shadExp.r)*2.0; 
  vec3 shad2 = Y * vec3(1.00048, 0.999864, 0.999446) + 
           ycc.g * vec3(0.955558, -0.271545, -1.10803) + 
           ycc.b * vec3(0.619549, -0.646786, 1.70542); 
  shad = mix(shad, shad2, 0.35); 
  shad = mix(pix.rgb, shad, sqrt(smoothstep(0.0, 0.1+shadAmt, sqrt(blurLum)))); 
  shad = mix(shad, pix.rgb, blurLum); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  Y = dot(high, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float kHighMix = 1.0 + (1.0-min(1.0, params.y+0.3))*0.4; 
  vec3 mid = mix(vec3(0.25), high, kHighMix); 
  float highBoost = min(effectAmount, 30.0*blurLum2) * (1.0-params.y); 
  high = mix(high, mid, highBoost); 
  high = mix(pix.rgb, high, smoothstep(0.2, 0.8, blurLum)); 
  high = mix(pix.rgb, high, blurLum2); 
  vec4 result; 
  result.rgb = mix(shad, high, min(blurLum, 1.0)); 
  Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float midAmt = abs(shadAmt)*0.1*(1.0-params.z); 
  mid = mix(vec3(0.5), result.rgb, 1.0 + midAmt); 
  result.rgb = mix(result.rgb, mid, min(effectAmount, 30.0*blurLum2)); 
  result.a = pix.a; 
  return result; 
kernel vec4 _highlightsAndShadows0(__sample pix, __sample blur, vec4 params)
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max(0.001, pix.r + pix.g + pix.b); 
  rgbFactor = clamp(rgbFactor, 0.0, 1.0); 
  float shadAmt = params.x * pow(rgbFactor, max(0.0,(1.0-params.x))); 
  vec3 clamped = clamp(pix.rgb, 0.00001, 0.99999); 
  float gray = (clamped.r + clamped.g + clamped.b) * 0.33333; 
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  float rgbsat = max((clamped.r - gray) * gii, (gray - clamped.r) * gi); 
  float skin = min(1.0, max(0.0, min(clamped.r - clamped.g, clamped.g * 2.0 - clamped.b)) * 4.0 * (1.0 - rgbsat) * gi); 
  skin = 0.15 + skin * 0.7; 
  vec3 rgbExp = pow(vec3(2.0), (-shadAmt - blur.rgb)); 
  float uniformExp = min(rgbExp.r, min(rgbExp.g, rgbExp.b)); 
  vec3 shadExp = mix(rgbExp, vec3(uniformExp), skin); 
  float nopMix = params.z; 
  shadExp = mix(shadExp, vec3(1.0, 1.0, 1.0), nopMix); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*0.5, shadExp)*2.0; 
  float maxChan = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(maxChan); 
  float origPercent = sqrt( smoothstep(0.0, 0.1 + 0.5*shadAmt*shadAmt, blurLum) ); 
  origPercent *= (1.0-origPercent); 
  shad = mix(shad, pix.rgb, origPercent); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  origPercent = 1.0 - smoothstep(0.2, 0.8, blurLum); 
  high = mix(high, pix.rgb, origPercent); 
  vec4 result; 
  result.rgb = mix(shad, high, blurLum); 
  float Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  vec3 mid = mix(vec3(0.5), result.rgb, 1.0 + abs(shadAmt)*0.05); 
  result.rgb = mix(result.rgb, mid.rgb, min(effectAmount, 30.0*blurLum*blurLum)); 
  result.a = pix.a; 
  return result;
kernel vec4 _highlightsAndShadows_noblur0(__sample pix, vec4 params)
  vec4 blur = pix; 
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max(0.001, pix.r + pix.g + pix.b); 
  rgbFactor = clamp(rgbFactor, 0.0, 1.0); 
  float shadAmt = params.x * pow(rgbFactor, max(0.0,(1.0-params.x))); 
  vec3 clamped = clamp(pix.rgb, 0.00001, 0.99999); 
  float gray = (clamped.r + clamped.g + clamped.b) * 0.33333; 
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  float rgbsat = max((clamped.r - gray) * gii, (gray - clamped.r) * gi); 
  float skin = min(1.0, max(0.0, min(clamped.r - clamped.g, clamped.g * 2.0 - clamped.b)) * 4.0 * (1.0 - rgbsat) * gi); 
  skin = 0.15 + skin * 0.7; 
  vec3 rgbExp = pow(vec3(2.0), (-shadAmt - blur.rgb)); 
  float uniformExp = min(rgbExp.r, min(rgbExp.g, rgbExp.b)); 
  vec3 shadExp = mix(rgbExp, vec3(uniformExp), skin); 
  float nopMix = params.z; 
  shadExp = mix(shadExp, vec3(1.0, 1.0, 1.0), nopMix); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*0.5, shadExp)*2.0; 
  float maxChan = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(maxChan); 
  float origPercent = sqrt( smoothstep(0.0, 0.1 + 0.5*shadAmt*shadAmt, blurLum) ); 
  origPercent *= (1.0-origPercent); 
  shad = mix(shad, pix.rgb, origPercent); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  origPercent = 1.0 - smoothstep(0.2, 0.8, blurLum); 
  high = mix(high, pix.rgb, origPercent); 
  vec4 result; 
  result.rgb = mix(shad, high, blurLum); 
  float Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  vec3 mid = mix(vec3(0.5), result.rgb, 1.0 + abs(shadAmt)*0.05); 
  result.rgb = mix(result.rgb, mid.rgb, min(effectAmount, 30.0*blurLum*blurLum)); 
  result.a = pix.a; 
  return result;
kernel vec4 _shadows_noblur(__sample pix, vec4 params)
  vec4 blur = pix; 
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max(0.001, pix.r + pix.g + pix.b); 
  rgbFactor = clamp(rgbFactor, 0.0, 1.0); 
  float shadAmt = params.x * pow(rgbFactor, max(0.0,(1.0-params.x))); 
  vec3 clamped = clamp(pix.rgb, 0.00001, 0.99999); 
  float gray = (clamped.r + clamped.g + clamped.b) * 0.33333; 
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  float rgbsat = max((clamped.r - gray) * gii, (gray - clamped.r) * gi); 
  float skin = min(1.0, max(0.0, min(clamped.r - clamped.g, clamped.g * 2.0 - clamped.b)) * 4.0 * (1.0 - rgbsat) * gi); 
  skin = 0.15 + skin * 0.7; 
  vec3 rgbExp = pow(vec3(2.0), (-shadAmt - blur.rgb)); 
  float uniformExp = min(rgbExp.r, min(rgbExp.g, rgbExp.b)); 
  vec3 shadExp = mix(rgbExp, vec3(uniformExp), skin); 
  float nopMix = params.z; 
  shadExp = mix(shadExp, vec3(1.0, 1.0, 1.0), nopMix); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*0.5, shadExp)*2.0; 
  float maxChan = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(maxChan); 
  float origPercent = sqrt( smoothstep(0.0, 0.1 + 0.5*shadAmt*shadAmt, blurLum) ); 
  origPercent *= (1.0-origPercent); 
  shad = mix(shad, pix.rgb, origPercent); 
  vec4 result; 
  result.rgb = mix(shad, pix.rgb, blurLum); 
  float Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  vec3 mid = mix(vec3(0.5), result.rgb, 1.0 + abs(shadAmt)*0.05); 
  result.rgb = mix(result.rgb, mid.rgb, min(effectAmount, 30.0*blurLum*blurLum)); 
  result.a = pix.a; 
  return result;
Shadows
Highlights
FillLight
T@"NSNumber",&,N,VinputShadowAmount
T@"NSNumber",&,N,VinputHighlightAmount
context
T@"CIContext",&,N,Vcontext
kernel vec4 _rippleTransition (sampler src1, sampler src2, sampler emap, vec2 center, vec4 parms, vec2 emapscaling)
  vec2 dest = destCoord();
  vec2 delta = dest - center;
  float delta_length = length(delta);
  vec2 unit = delta / delta_length;
  float scaled = (delta_length - parms.x) * parms.y;
  vec4 normalized_radius = vec4(scaled * parms.z) + vec4(-0.0, -1.0, -2.0, -3.0);
  vec4 smoothed = smoothstep(0.0, 1.0, clamp(normalized_radius.xyzy, 0.0, 1.0));
  vec4 cubic = smoothed * vec4(1.0, -2.0, 1.0, 1.0) + vec4(0.0, 1.0, -1.0, 0.0);
  smoothed = compare(vec4(normalized_radius.x), vec4(0.0), vec4(cubic.x));
  smoothed = compare(vec4(normalized_radius.y), smoothed, vec4(cubic.y));
  smoothed = compare(vec4(normalized_radius.z), smoothed, vec4(cubic.z));
  normalized_radius = compare(vec4(normalized_radius.w), vec4(smoothed), vec4(0.0));
  vec2 displacement = normalized_radius.xy * unit;
  vec2 location = displacement * parms.w + dest;
  vec2 emap_location = (displacement * 0.5 + 0.5) * emapscaling;
  vec4 pix1 = sample(src1, samplerTransform(src1, location));
  vec4 pix2 = sample(src2, samplerTransform(src2, location));
  vec4 emap_pix = sample(emap, samplerTransform(emap, emap_location));
  vec4 tmp = mix(pix2, pix1, cubic.w);
  emap_pix *= tmp.a;
  tmp = tmp * (1.0 - emap_pix.a) + emap_pix;
  return tmp;
integral_image_manual
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/CIIntegralImage.mm
input.format == kCIFormatRGBAf || input.format == kCIFormatRGBAh || input.format == kCIFormatBGRA8 || input.format == kCIFormatRGBA8
output.format == kCIFormatRGBAf || output.format == kCIFormatRGBAh
input.region.size.width == output.region.size.width
input.region.size.height == output.region.size.height
compute_integral_image
don't know how to create builtin kernel for type %d
_ci_affine
vec2 _ci_affine(vec4 vx, vec4 vy)
  vec4 d = vec4(destCoord(), 1.0, 0.0);
  return vec2(dot(d,vx),dot(d,vy));
_ci_crop
vec4 _ci_crop(vec4 p, vec4 rect)
  highp vec4 x = destCoord().xxyy * vec4(1.0, -1.0, 1.0, -1.0) + rect;
  x = clamp(min(x, x.yzwx), 0.0, 1.0);
  return (x.x * x.z) * p;
rect
_ci_clamp
vec2 _ci_clamp(vec4 r) { return min(max(destCoord(), r.xy), r.zw); }
_ci_srgb_to_lin
vec4 _ci_srgb_to_lin(vec4 s)
  vec4 abss = abs(s);  s.rgb = sign(s.rgb)*mix(abss.rgb*0.077399380804954, pow(abss.rgb*0.947867298578199 + 0.052132701421801, vec3(2.4)), step(0.04045, abss.rgb));
  return s;
_ci_lin_to_srgb
vec4 _ci_lin_to_srgb(vec4 s)
  vec4 abss = abs(s);  s.rgb = sign(s.rgb)*mix(abss.rgb*12.92, pow(abss.rgb, vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abss.rgb));
  return s;
_ci_premul
vec4 _ci_premul(vec4 s) { return vec4(s.rgb*s.a, s.a); }
_ci_unpremul
vec4 _ci_unpremul(vec4 s) { return vec4(s.rgb/max(s.a,0.00001), s.a); }
_ci_clamp_to_alpha
vec4 _ci_clamp_to_alpha(vec4 s) { return clamp(s, 0.0, s.a); }
_ci_nearest
vec2 _ci_nearest() { return (floor((destCoord())) + 0.5); }
_ci_pass_thru
vec4 _ci_pass_thru (vec4 s) { return s; }
_ci_fill
vec4 _ci_fill(vec4 c) {return c;}
_ci_gamma
vec4 _ci_gamma(vec4 s, float power)
  s.rgb = pow(max(vec3(0.0), s.rgb), vec3(power));
  return s;
power
_ci_sqr
vec4 _ci_sqr(vec4 s)
  s.rgb = max(vec3(0.0), s.rgb);
  s.rgb *= s.rgb;
  return s;
_ci_pow4
vec4 _ci_pow4(vec4 s)
  s.rgb = max(vec3(0.0), s.rgb);
  s.rgb = s.rgb * s.rgb * s.rgb * s.rgb;
  return s;
_ci_sqrt
vec4 _ci_sqrt(vec4 s)
  s.rgb = sqrt(max(vec3(0.0), s.rgb));
  return s;
_ci_curv
vec4 _ci_curv(vec4 s, vec4 p0, vec3 p1)
  float power = p0.x; 
  float a = p0.y, b = p0.z, c = p0.w; 
  float d = p1.x, e = p1.y, f = p1.z; 
  vec3 hi = pow(max(vec3(0.0), s.rgb * a + b), vec3(power)) + e; 
  vec3 lo = s.rgb * c + f; 
  s.rgb = mix(lo, hi, step(d, s.rgb));
  return s;}
_ci_colormatrix_canonical
vec4 _ci_colormatrix_canonical (vec4 s, vec4 r0, vec4 r1, vec4 r2) 
  s.rgb /= max(s.a, 0.00001);
  s.rgb = vec3(dot(s,r0), dot(s,r1), dot(s,r2)); 
  s.rgb *= s.a;
  return s;
_ci_colormatrix
vec4 _ci_colormatrix (vec4 s, vec4 c0, vec4 c1, vec4 c2, vec4 c3, vec4 bias) 
  s.rgb /= max(s.a, 0.00001);
  s = s.r*c0 + s.g*c1 + s.b*c2 + s.a*c3 + bias;
  s.rgb *= s.a;
  return s;
_ci_colormatrix3x4
vec4 _ci_colormatrix3x4 (vec4 s, vec4 c0, vec4 c1, vec4 c2) 
{ s.rgb = s.r*c0.rgb + s.g*c1.rgb + s.b*c2.rgb + s.a*vec3(c0.a,c1.a,c2.a); return s; }
_ci_colormatrix3x3
vec4 _ci_colormatrix3x3 (vec4 s, vec3 col0, vec3 col1, vec3 col2)
  s.rgb = s.r*col0 + s.g*col1 + s.b*col2;
  return s;
col0
col1
col2
_ci_colormatrix3x1
vec4 _ci_colormatrix3x1 (vec4 s, vec3 v) { return vec4(vec3(dot(s.rgb, v)), s.a); }
_ci_colormatrix_rrra
vec4 _ci_colormatrix_rrra(vec4 s) { return s.rrra; }
_ci_colormatrixdiag
vec4 _ci_colormatrixdiag (vec4 s, vec3 diag) 
  s.rgb *= diag;
  return s;
diag
_ci_colormatrixdiag4
vec4 _ci_colormatrixdiag4 (vec4 s, vec4 diag) 
  return s * diag;
_ci_aaaa
vec4 _ci_aaaa (vec4 s) { return s.aaaa; }
_ci_rrrr
vec4 _ci_rrrr (vec4 s) { return s.rrrr; }
_ci_000r
vec4 _ci_000r (vec4 s) { return vec4(0.,0.,0.,s.r); }
_ci_rrr1
vec4 _ci_rrr1 (vec4 s) { return vec4(s.rrr,1.); }
_ci_r001
vec4 _ci_r001 (vec4 s) { return vec4(s.r,0.,0.,1.); }
_ci_rg01
vec4 _ci_rg01 (vec4 s) { return vec4(s.rg,0.,1.); }
_ci_a001
vec4 _ci_a001 (vec4 s) { return vec4(s.a,0.,0.,1.); }
_ci_aaa1
vec4 _ci_aaa1 (vec4 s) { return vec4(s.www,1.); }
_ci_rrrg
vec4 _ci_rrrg (vec4 s) { return s.rrrg; }
_ci_bgra
vec4 _ci_bgra (vec4 s) { return s.bgra; }
_ci_abgr
vec4 _ci_abgr (vec4 s) { return s.abgr; }
_ci_gbra
vec4 _ci_gbra (vec4 s) { return s.gbra; }
_ci_grab
vec4 _ci_grab (vec4 s) { return s.grab; }
_ci_gbar
vec4 _ci_gbar (vec4 s) { return s.gbar; }
_ci_argb
vec4 _ci_argb (vec4 s) { return s.argb; }
_ci_gra1
vec4 _ci_gra1 (vec4 s) { s = s.grab; s.a = 1.0; return s; }
_ci_arg1
vec4 _ci_arg1 (vec4 s) { s = s.argb; s.a = 1.0; return s; }
_ci_rgb1
vec4 _ci_rgb1 (vec4 s) { return vec4(s.rgb, 1.0); }
_ci_bgr1
vec4 _ci_bgr1 (vec4 s) { return vec4(s.bgr, 1.0); }
_ci_1rgb
vec4 _ci_1rgb (vec4 s) { return vec4(1.0, s.rgb); }
_ci_1bgr
vec4 _ci_1bgr (vec4 s) { return vec4(1.0, s.bgr); }
_ci_rg_to_rr1
vec4 _ci_rg_to_rr1(vec4 s) { return vec4((s.g*256.0+s.r)/257.0, 0.0, 0.0, 1.0); }
_ci_rg_to_ll1
vec4 _ci_rg_to_ll1(vec4 s) { return vec4(vec3((s.g*256.0+s.r)/257.0), 1.0); }
_ci_rg_to_a
vec4 _ci_rg_to_a(vec4 s) { return vec4(0.0, 0.0, 0.0, (s.g*256.0+s.r)/257.0); }
_ci_rg_to_i
vec4 _ci_rg_to_i(vec4 s) { return vec4((s.g*256.0+s.r)/257.0); }
_ci_la_to_rr1
vec4 _ci_la_to_rr1(vec4 s) { return vec4((s.a*256.0+s.r)/257.0, 0.0, 0.0, 1.0); }
_ci_la_to_ll1
vec4 _ci_la_to_ll1(vec4 s) { return vec4(vec3((s.a*256.0+s.r)/257.0), 1.0); }
_ci_la_to_a
vec4 _ci_la_to_a(vec4 s) { return vec4(0.0, 0.0, 0.0, (s.a*256.0+s.r)/257.0); }
_ci_la_to_i
vec4 _ci_la_to_i(vec4 s) { return vec4((s.a*256.0+s.r)/257.0); }
_ci_rgba_to_rrgg1
vec4 _ci_rgba_to_rrgg1(vec4 s) { return vec4((s.g*256.0+s.r)/257.0, (s.a*256.0+s.b)/257.0, 0.0, 1.0); }
_ci_rgba_to_llaa
vec4 _ci_rgba_to_llaa(vec4 s) { return vec4(vec3((s.g*256.0+s.r)/257.0), (s.a*256.0+s.b)/257.0); }
_ci_to_r16_as_rg8
vec4 _ci_to_r16_as_rg8(vec4 s) 
  float r = s.r*65535.0; 
  float rL = mod(r,256.0); 
  float rH = (r-rL)/256.0; 
  return vec4(rL,rH,0.0,1.0)/255.0; 
_ci_to_l16_as_rg8
vec4 _ci_to_l16_as_rg8(vec4 s) 
  const vec4 gray = vec4(0.299, 0.587, 0.114, 0.0); 
  float l = dot(s,gray)*65535.0; 
  float lL = mod(l,256.0); 
  float lH = (l-lL)/256.0; 
  return vec4(lL,lH,0.0,1.0)/255.0; 
_ci_to_a16_as_rg8
vec4 _ci_to_a16_as_rg8(vec4 s) 
  float a = s.a*65535.0; 
  float aL = mod(a,256.0); 
  float aH = (a-aL)/256.0; 
  return vec4(aL,aH,0.0,1.0)/255.0; 
_ci_to_rg16_as_rgba8
vec4 _ci_to_rg16_as_rgba8(vec4 s) 
  float r = s.r*65535.0; 
  float rL = mod(r,256.0); 
  float rH = (r-rL)/256.0; 
  float g = s.g*65535.0; 
  float gL = mod(g,256.0); 
  float gH = (g-gL)/256.0; 
  return vec4(rL,rH,gL,gH)/255.0; 
_ci_to_rg16_as_bgra8
vec4 _ci_to_rg16_as_bgra8(vec4 s) 
  float r = s.r*65535.0; 
  float rL = mod(r,256.0); 
  float rH = (r-rL)/256.0; 
  float g = s.g*65535.0; 
  float gL = mod(g,256.0); 
  float gH = (g-gL)/256.0; 
  return vec4(gL,rH,rL,gH)/255.0; 
_ci_to_la16_as_rgba8
vec4 _ci_to_la16_as_rgba8(vec4 s) 
  const vec4 gray = vec4(0.299, 0.587, 0.114, 0.0); 
  float l = dot(s,gray)*65535.0; 
  float lL = mod(l,256.0); 
  float lH = (l-lL)/256.0; 
  float a = s.a*65535.0; 
  float aL = mod(a,256.0); 
  float aH = (a-aL)/256.0; 
  return vec4(lL,lH,aL,aH)/255.0; 
_ci_to_la16_as_bgra8
vec4 _ci_to_la16_as_bgra8(vec4 s) 
  const vec4 gray = vec4(0.299, 0.587, 0.114, 0.0); 
  float l = dot(s,gray)*65535.0; 
  float lL = mod(l,256.0); 
  float lH = (l-lL)/256.0; 
  float a = s.a*65535.0; 
  float aL = mod(a,256.0); 
  float aH = (a-aL)/256.0; 
  return vec4(aL,lH,lL,aH)/255.0; 
_ci_rg_to_cbycry
vec4 _ci_rg_to_cbycry(sampler s) 
  vec4 c = sample(s,samplerCoord(s)); 
  float col = step(0.5, fract(destCoord().x * 0.5)); 
  float cOther = sample(s,samplerCoord(s) + vec2(1.0-2.0*col,0.0)).r; 
  vec4 r0 = vec4(c.g, c.r, cOther, 1.0); 
  vec4 r1 = vec4(c.g, cOther, c.r, 1.0); 
  return mix(r0,r1,col); 
_ci_rg_to_ycbycr
vec4 _ci_rg_to_ycbycr(sampler s) 
  vec4 c = sample(s,samplerCoord(s)); 
  float col = step(0.5, fract(destCoord().x * 0.5)); 
  float cOther = sample(s,samplerCoord(s) + vec2(1.0-2.0*col,0.0)).g; 
  vec4 r0 = vec4(c.r, c.g, cOther, 1.0); 
  vec4 r1 = vec4(c.r, cOther, c.g, 1.0); 
  return mix(r0,r1,col); 
_ci_to_YCbYCr_as_rg8
vec4 _ci_to_YCbYCr_as_rg8(vec4 s) 
  vec2 YCb = s.rg, YCr = s.rb; 
  float m = step(0.5, fract(destCoord().x * 0.5)); 
  return vec4(mix(YCb,YCr,m),0.0,1.0); 
_ci_to_CbYCrY_as_rg8
vec4 _ci_to_CbYCrY_as_rg8(vec4 s) 
  vec2 CbY = s.gr, CrY = s.br; 
  float m = step(0.5, fract(destCoord().x * 0.5)); 
  return vec4(mix(CbY,CrY,m),0.0,1.0); 
_ci_to_rgb_as_r
vec4 _ci_to_rgb_as_r (vec4 s)
  vec2 rCoord = writeCoord() * vec2(3,1);
  writeImage(s.rrrr, rCoord);
  vec2 gCoord = rCoord + vec2(1,0);
  writeImage(s.gggg, gCoord);
  vec2 bCoord = rCoord + vec2(2,0);
  writeImage(s.bbbb, bCoord);
  return s; 
_ci_to_a2bgr10_as_rgba8
vec4 _ci_to_a2bgr10_as_rgba8 (vec4 s)
  vec4 denorm = clamp(s,0.0,1.0) * vec4(vec3(1023.0), 3.0) + 0.5;
  int pixel  = int(denorm.r);
      pixel |= int(denorm.g) << 10;
      pixel |= int(denorm.b) << 20;
      pixel |= int(denorm.a) << 30;
  writePixel((pixel) & 0xFF, (pixel >> 8) & 0xFF, (pixel >> 16) & 0xFF, (pixel >> 24) & 0xFF, writeCoord());
  return s; 
_ci_to_a2rgb10_as_rgba8
vec4 _ci_to_a2rgb10_as_rgba8 (vec4 s)
  vec4 denorm = clamp(s,0.0,1.0) * vec4(vec3(1023.0), 3.0) + 0.5;
  int pixel  = int(denorm.b);
      pixel |= int(denorm.g) << 10;
      pixel |= int(denorm.r) << 20;
      pixel |= int(denorm.a) << 30;
  writePixel((pixel) & 0xFF, (pixel >> 8) & 0xFF, (pixel >> 16) & 0xFF, (pixel >> 24) & 0xFF, writeCoord());
  return s; 
_ci_to_rgb10wide_as_rgba8
vec4 _ci_to_rgb10wide_as_rgba8 (vec4 s)
  s = vec4(linear_to_srgb(s.rgb) * (511.0/1023.0) + (384.0/1023.0), 1.0);
  vec4 denorm = clamp(s,0.0,1.0) * vec4(vec3(1023.0), 3.0) + 0.5;
  int pixel  = int(denorm.b);
      pixel |= int(denorm.g) << 10;
      pixel |= int(denorm.r) << 20;
      pixel |= int(denorm.a) << 30;
  writePixel((pixel) & 0xFF, (pixel >> 8) & 0xFF, (pixel >> 16) & 0xFF, (pixel >> 24) & 0xFF, writeCoord());
  return s; 
_ci_combine_420
vec4 _ci_combine_420(vec4 s00, vec4 s10, vec4 s01, vec4 s11)
  vec2 pc = writeCoord();
  vec2 py = pc * vec2(2,2);
  writeImage(s00.rrrr, py);
  writeImage(s10.rrrr, py + vec2(1,0));
  writeImage(s01.rrrr, py + vec2(0,1));
  writeImage(s11.rrrr, py + vec2(1,1));
  vec4 cc = (s00 + s10 + s01 + s11) * 0.25;
  writeImagePlane(vec4(cc.gb,0.0,0.0), pc);
  return s00; 
_ci_swizzle_to_444
vec4 _ci_swizzle_to_444(vec4 s)
  vec2 pc = writeCoord();
  writeImage(vec4(s.r,0.0,0.0,1.0), pc);
  writeImagePlane(vec4(s.gb,0.0,1.0), pc);
  return s; 
_ci_swizzle_rgba8_to_a2rgb10
vec4 _ci_swizzle_rgba8_to_a2rgb10(vec4 s) 
  s = floor(s * 255.0 + 0.5); 
  vec4 r; 
  r.b = (mod(s.g,  4.0) * 256.0 + s.r)              / 1023.0; 
  r.g = (mod(s.b, 16.0) *  64.0 + floor(s.g/ 4.0))  / 1023.0; 
  r.r = (mod(s.a, 64.0) *  16.0 + floor(s.b/16.0))  / 1023.0; 
  r.a = floor(s.a/63.99999) / 3.0; 
  return r; 
_ci_swizzle_rgba8_to_rgb10_wide
vec4 _ci_swizzle_rgba8_to_rgb10_wide(vec4 s) 
  s = floor(s * 255.0 + 0.5); 
  vec4 r; 
  r.b = (mod(s.g,  4.0) * 256.0 + s.r)              / 1023.0; 
  r.g = (mod(s.b, 16.0) *  64.0 + floor(s.g/ 4.0))  / 1023.0; 
  r.r = (mod(s.a, 64.0) *  16.0 + floor(s.b/16.0))  / 1023.0; 
  r.a = 1.0; 
  r.rgb = srgb_to_linear((r.rgb - 384.0/1023.0) * (1023.0/511.0)); 
  return r; 
_ci_swizzle_rgba8_to_a2bgr10
vec4 _ci_swizzle_rgba8_to_a2bgr10(vec4 s) 
  s = floor(s * 255.0 + 0.5); 
  vec4 r; 
  r.r = (mod(s.g,  4.0) * 256.0 + s.r)              / 1023.0; 
  r.g = (mod(s.b, 16.0) *  64.0 + floor(s.g/ 4.0))  / 1023.0; 
  r.b = (mod(s.a, 64.0) *  16.0 + floor(s.b/16.0))  / 1023.0; 
  r.a = floor(s.a/63.99999) / 3.0; 
  return r; 
_ci_rgb10wide
vec4 _ci_rgb10wide(vec4 s) { return vec4(srgb_to_linear((s.rgb - 384.0/1023.0) * (1023.0/511.0)), 1.0); }
_ci_bgr10wide
vec4 _ci_bgr10wide(vec4 s) { return vec4(srgb_to_linear((s.bgr - 384.0/1023.0) * (1023.0/511.0)), 1.0); }
_ci_to_rgb10wide
vec4 _ci_to_rgb10wide(vec4 s) { return vec4(linear_to_srgb(s.rgb) * (511.0/1023.0) + (384.0/1023.0), 1.0); }
_ci_to_bgr10wide
vec4 _ci_to_bgr10wide(vec4 s) { return vec4(linear_to_srgb(s.bgr) * (511.0/1023.0) + (384.0/1023.0), 1.0); }
_ci_rgba16_normalize
vec4 _ci_rgba16_normalize(vec4 s) { return s / 65535.0; }
_ci_ra01
vec4 _ci_ra01(vec4 s) { return vec4(s.ra, 0.0, 1.0); }
_ci_ycc_to_rgb
vec4 _ci_ycc_to_rgb(vec4 s) { return s.zxyw; }
_ci_swizzle_to_laaa
vec4 _ci_swizzle_to_laaa(vec4 s) 
  const vec4 g = vec4(0.299, 0.587, 0.114, 0.0); 
  return vec4(dot(s,g), s.aaa); 
_ci_combine_gray
vec4 _ci_combine_gray(vec4 s0, vec4 s1, vec4 s2, vec4 s3) 
  vec4 g = vec4(0.299, 0.587, 0.114, 0.0); 
  return vec4(dot(s0,g), dot(s1,g), dot(s2,g), dot(s3,g)); 
_ci_combine_r
vec4 _ci_combine_r(vec4 s0, vec4 s1, vec4 s2, vec4 s3) { return vec4(s0.r, s1.r, s2.r, s3.r); }
_ci_combine_a
vec4 _ci_combine_a(vec4 s0, vec4 s1, vec4 s2, vec4 s3) { return vec4(s0.a, s1.a, s2.a, s3.a); }
_ci_combine_rg
vec4 _ci_combine_rg(vec4 s0, vec4 s1) { return vec4(s0.rg, s1.rg); }
_ci_combine_r16
vec4 _ci_combine_r16(vec4 s0, vec4 s1) 
  float v0 = s0.r*65535.0; 
  float v0L = mod(v0,256.0); 
  float v0H = (v0-v0L)/256.0; 
  float v1 = s1.r*65535.0; 
  float v1L = mod(v1,256.0); 
  float v1H = (v1-v1L)/256.0; 
  return vec4(v0L,v0H,v1L,v1H)/255.0; 
_ci_combine_a16
vec4 _ci_combine_a16(vec4 s0, vec4 s1) 
  float v0 = s0.a*65535.0; 
  float v0L = mod(v0,256.0); 
  float v0H = (v0-v0L)/256.0; 
  float v1 = s1.a*65535.0; 
  float v1L = mod(v1,256.0); 
  float v1H = (v1-v1L)/256.0; 
  return vec4(v0L,v0H,v1L,v1H)/255.0; 
_ci_combine_l16
vec4 _ci_combine_l16(vec4 s0, vec4 s1) 
  vec4 g = vec4(0.299, 0.587, 0.114, 0.0); 
  float v0 = dot(s0,g)*65535.0; 
  float v0L = mod(v0,256.0); 
  float v0H = (v0-v0L)/256.0; 
  float v1 = dot(s1,g)*65535.0; 
  float v1L = mod(v1,256.0); 
  float v1H = (v1-v1L)/256.0; 
  return vec4(v0L,v0H,v1L,v1H)/255.0; 
_ci_combine_la
vec4 _ci_combine_la(vec4 s0, vec4 s1) 
  vec4 g = vec4(0.299, 0.587, 0.114, 0.0); 
  return vec4(dot(s0,g), s0.a, dot(s1,g), s1.a);
True
False
TRUE
kernel vec4 _stripes (vec2 center, __color c0, __color c1, vec3 params)
  float d0;
  d0 = (destCoord() - center).x;
  d0 = fract(d0 * params.x - .25);
  d0 = min (1.0 - d0, d0);
  d0 = clamp (d0 * params.y + params.z, 0.0, 1.0);
  float d1 = (d0 * -2.0 + 3.0) * d0 * d0;
  return mix(c1, c0, d1);
kernel vec4 _sunbeams(sampler noise, vec4 centers, vec4 params, __color color)
  float sunRadius2 = params.x; 
  float striationFactor = params.y; 
  float a = params.z; 
  float b = params.w; 
  vec2  v = destCoord() - centers.xy; 
  float len = length(v);
  float len2 = dot(v,v);
  vec2  noiseCtr = centers.zw; 
  vec2  noiseLoc = normalize(v) * 50.0 + noiseCtr; 
  vec4  npix = sample(noise, samplerTransform(noise, noiseLoc)); 
  float noiseAmount = npix.r * a + b;
  float f2 = sunRadius2 / (len2+0.0001);
  vec4  pix = f2 * color + noiseAmount; 
  return pix * clamp(1.0 - len * striationFactor, 0.0, 1.0); 
inputSunRadius
inputMaxStriationRadius
inputNeutralGamma
inputTone
inputHue
inputGrain
inputSeed
kernel vec4 _smartBlackAndWhite(__sample image, sampler2D hueImage, vec4 rgbWeights, vec4 normalizer)
    float scaleFactor = rgbWeights.w;
    float neutralGamma = normalizer.z;
    float phototone = normalizer.w;
    image = clamp(image, 0.0, 1.0);
    vec3 lms;
    lms.x = dot(image.rgb, vec3(0.3139902162, 0.6395129383, 0.0464975462));
    lms.y = dot(image.rgb, vec3(0.155372406, 0.7578944616, 0.0867014186));
    lms.z = dot(image.rgb, vec3(0.017752387, 0.109442094, 0.8725692246));
    lms = pow(lms, vec3(0.43));
    float i = dot(lms, vec3(0.4,0.4,0.2));
    float p = dot(lms, vec3(4.4550,-4.8510,0.3960));
    float t = dot(lms, vec3(0.8056,0.3572,-1.1628));
    float chroma = sqrt(p*p+t*t);
    float hue = 0.5 + (atan(t, p) / 6.28318530718); 
    vec2 huePt = vec2(hue * normalizer.x + normalizer.y, 0.5); 
    float exponent = scaleFactor * texture2D(hueImage, huePt).a; 
    float cd = 0.06 + 0.53*abs(i-0.5); 
    float lumDamp = smoothstep(0.0, 1.0, 25.0*i); 
    float x = smoothstep(0.0, 1.0, chroma/cd); 
    exponent = x*(1.0-i)*lumDamp*(exponent - 1.0) + 1.0; 
    float bw = dot(image.rgb, rgbWeights.rgb); 
    bw = pow(bw, exponent); 
    x = 1.0 - smoothstep(0.0, 1.0, chroma * 10.0); 
    float lumAdjust = bw*(1.0 - bw)*x*(neutralGamma - 1.0) + 1.0;
    lumAdjust = 5.0 - 4.0 * lumAdjust;
    bw = pow(bw, lumAdjust);
    float result = 1.8031*bw*bw*bw - 2.1972*bw*bw + 1.3823*bw;
    bw = mix(bw, result, -phototone);
    return vec4(bw,bw,bw,image.a);
inputISO
T@"NSNumber",C,N,VinputStrength
T@"NSNumber",C,N,VinputNeutralGamma
T@"NSNumber",C,N,VinputTone
T@"NSNumber",C,N,VinputHue
T@"NSNumber",C,N,VinputGrain
T@"NSNumber",C,N,VinputSeed
T@"NSNumber",C,N,VinputScaleFactor
There is no need to call smartBlackAndWhiteStatistics.
Just use [CIFilter filterWithName:@"CISmartBlackAndWhite"] instead.
There is no need to call smartBlackAndWhiteAdjustmentsForValue:andStatistics:.
kernel vec4 facebalance (__sample pix, vec2 delta)
  pix.rgb = pix.r * vec3(0.299,  0.595716,  0.211456) + 
            pix.g * vec3(0.587, -0.274453, -0.522591) + 
            pix.b * vec3(0.114, -0.321263,  0.311135);
  float chroma2 = min(1.0, 4.0*(pix.g*pix.g + pix.b*pix.b));
  pix.gb += delta * pow(chroma2,0.2) * (1.0-chroma2*chroma2);
  pix.rgb = pix.r * vec3(1.0) + 
            pix.g * vec3(0.956296, -0.272122, -1.10699) + 
            pix.b * vec3(0.621024, -0.647381, 1.70461); 
  return pix;
FaceBalanceOrigI
FaceBalanceOrigQ
FaceBalanceStrength
FaceBalanceWarmth
IncrementalTemperature
IncrementalTint
HasSettings
T@"NSNumber",&,N,VinputOrigI
T@"NSNumber",&,N,VinputOrigQ
T@"NSNumber",&,N,VinputWarmth
copySliceOfBitmapToBitmap: bytes per sample or samples per pixel differs!
copyBitmapToSliceOfBitmap: bytes per sample or samples per pixel differs!
bitmapToBitmapDifferenceBitmapRect: source pixel configuration illegal
initBitmask:b
initBitmask:b->body
initBitmask: bitmap record can not be allocated
initBitmask: bitmap body can not be allocated
termBitmask: bitmap was null
setBitInBitmask: coordinate out of range
bitmaskMinus: bitmasks have different shapes
bitmaskBoundingBitmapRectWithSeedPoint: seed point outside bitmask
ConvertYCbCrtoREDEYEFORMAT: rowSamples is too small for CbCr bitmap
ConvertYCbCrtoREDEYEFORMAT: rowSamples is too small for Y bitmap
ConvertYCbCrtoREDEYEFORMAT: heights do not match
ConvertYCbCrtoREDEYEFORMAT: widths do not match
ConvertRedChannel2toY: rowSamples is too small for ARGB bitmap
ConvertRedChannel2toY: rowSamples is too small for CbCr bitmap
ConvertRedChannel2toY: rowSamples is too small for Y bitmap
ConvertRedChannel2toY: heights do not match
ConvertRedChannel2toY: widths do not match
ConvertRedChannel5toY: rowSamples is too small for ARGB bitmap
ConvertRedChannel5toY: rowSamples is too small for CbCr bitmap
ConvertRedChannel5toY: rowSamples is too small for Y bitmap
ConvertRedChannel5toY: heights do not match
ConvertRedChannel5toY: widths do not match
extractAlpha:alphaMap
extractAlpha:savedscans
computePupilAlphaMap:allPoints
computePupilAlphaMap:alphaMap
blurBitmapHorizontal:scan
blurBitmapVertical:scan
infill area boundary path
specular bitmask outside path
infill arcs surround arcs
specular bitmask path outside arc bodies
specular bitmask path outside arcs
arcCorrelation: improper crossing pairing at f1 %.2f
%d crossings:
  [%2d] f2 %.2f pix %.2f 
arcInfill: improper crossing pairing at f1 %.2f
extractFirstGradientMaximumFrom:scanline
computeOutlineByTracingSnake:snakeBodies
computeOutlineByTracingSnake:points
winning snake = connection of snakes %d and %d
computeBitmask: connected pieces search failed
computeBitmask: seedFill failed
computeBitmask: centroid closest bit search failed
computeBitmask: can not allocate bitmask bm2
computeBitmask: can not allocate bitmask bm
recomputeBitmask: seedFill failed
recomputeBitmask: can not allocate bitmask bm2
recomputeBitmask: can not allocate bitmask bm
closestConnectedComponent: seedFill failed
closestConnectedComponent: centroid closest bit search failed
closestConnectedComponent: can not allocate bitmask bm3
closestConnectedComponent: can not allocate bitmask bm2
closestConnectedComponent: can not allocate bitmask bm
cornealReflectionBitmask: can not allocate bitmask bm2 intended for spread
determineOutsidePath: nowhere to go
determineOutsidePath: border pixel expected
determineOutsidePath: overflow
determineOutsidePath: unable to allocate path body
determineOutsidePath: isolated point
determineOutsidePath: no bits set
determineOutsidePath: unable to allocate path
determineArcsAtAngleForOutsidePath: too many arc bodies
determineArcsAtAngleForOutsidePath: too many arcs
determineArcsAtAngleForOutsidePath: unable to allocate arc bodies
determineArcsAtAngleForOutsidePath: unable to allocate arcs
arcCorrelation: no crossings at f1
arcCorrelation: odd number of crossings
arcCorrelation: too many crossings
arcInfill: no crossings at f1
arcInfill: odd number of crossings
arcInfill: too many crossings
error - impossible connect arrangement
incorrect number of points
examineAlpha: bitmaps don't match
examineAlpha: bitmaps are the wrong number of samples per pixel
examineBitmask: bitmaps don't match
examineBitmask: bitmaps are the wrong number of samples per pixel
allocSpanStack:s
allocSpanStack:s->firstChunk
pushSpan:s->stackHeadChunk->next
allocSpanStack: span stack could not be allocated
spanSearch: empty span
freeSpanStack: span stack is null
seedFill: can not pop span stack
seedFill: can not push span onto stack
seedFill: can not allocate span stack
inputCrossScale
inputCrossAngle
inputCrossOpacity
inputCrossWidth
inputEpsilon
kernel vec4 _starshine(vec2 center, vec4 xyvec, vec4 parms, float widthrecip, __color color)
  vec2 offset = destCoord() - center;
  vec2 loc = vec2(dot(offset, xyvec.xy), dot(offset, xyvec.zw));
  float l = length(offset);
  float rlen = parms.x / l;
  loc = max(abs(loc) * widthrecip + parms.w, vec2(0.0000001));
  loc = abs(parms.x / loc);
  loc = loc * loc * loc;
  float f = loc.x * loc.y * parms.z;
  float g = clamp(1.0 - l * parms.y, 0.0, 1.0);
  return min(rlen * rlen * color + g * g * f, vec4(1.0));
T@"NSNumber",&,N,VinputCrossScale
T@"NSNumber",&,N,VinputCrossAngle
T@"NSNumber",&,N,VinputCrossOpacity
T@"NSNumber",&,N,VinputCrossWidth
T@"NSNumber",&,N,VinputEpsilon
frame
initWithExternalBuffer:size:rowBytes:f
initWithExternalBuffer:subRectange:fullSize:rowBytes:f
redEyeRemovalWithPoint:recognitionChannels[0]
redEyeRemovalWithPoint:recognitionChannels[1]
redEyeRemovalWithPoint:recognitionChannels[i]
redEyeRemovalWithData:recognitionChannel
surface=%p(%.3u)
 fmt=%.4s
 fmt=%ld
 x=%+.4lld y=%+.4lld w=%.4zu h=%.4zu ctx=%u img=%u vol=%d
 id='%s'
 id=nil
 size=%ld%s
 empty
 use=%ld
SurfaceCacheEntry 
GetSurfaceFromCacheAndFill was passed contextIndex=%d and imageIndex=%d.  Ignoring imageIndex.
GetValidSurfaceFromCache was passed contextIndex=%d and imageIndex=%d.  Ignoring imageIndex.
GetSurfaceFromCache was passed contextIndex=%d and imageIndex=%d.  Ignoring imageIndex.
CISurfaceCacheQueue
v8@?0^{SurfaceCacheEntry=^^?{atomic<unsigned int>=AI}^{__IOSurface}{IPoint=qq}II^{__CFString}I^{dispatch_queue_s}@?li}4
SurfaceCache:
  count: %ld
  size: %ld%s
  non-volatile: %ld%s
  volatile: %ld%s
  capacity: %ld%s
  cumulativeStats:
    peakCount=%ld peakSize=%ld%s peakNVSize=%ld%s totalAlloced=%ld%s totalFilled=%ld%s timeFilling=%gs
    hits=%ld (%lu%%)  purgedHits=%ld (%lu%%)  recycledMisses=%ld (%lu%%)  misses=%ld (%lu%%)  nearmisses=%ld (%lu%%)
useCountDecrement
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/internal/surface-cache.cpp
_useCount > 0
inputPoint
kernel vec2 _mirror (vec2 center, vec3 tst, vec4 off, vec4 mtx)
  float test = dot(tst.xy, destCoord()) + tst.z;
  vec2 p = destCoord() - center;
  p = (test < 0.0) ? p + off.xy : vec2(dot(p, mtx.xy), dot(p, mtx.zw)) + off.zw;
  return p + center;
T@"CIVector",&,N,VinputPoint
vec3 _toLab (vec3 rgb) 
  vec3 XYZ = vec3(dot(rgb, vec3(0.452350,0.399530,0.148409)), 
                  dot(rgb, vec3(0.222488,0.716873,0.060608)), 
                  dot(rgb, vec3(0.016868,0.117668,0.865571))); 
  XYZ = max(XYZ, vec3(0.0)); 
  XYZ = compare(XYZ - 0.008856, 7.787 * XYZ + 16.0 / 116.0, pow(XYZ,vec3(0.33333333))); 
  return vec3(116.0 * XYZ.y - 16.0,  500.0 * (XYZ.x - XYZ.y),  200.0 * (XYZ.y - XYZ.z)); 
float _deltaE (vec3 lab1, vec3 lab2) 
  vec3 d = lab1 - lab2; 
  float dL = d.x; 
  float da = d.y; 
  float db = d.z; 
  float C1 = length(lab1.yz); 
  float C2 = length(lab2.yz); 
  float Cgmean = sqrt(C1*C2); 
  float dC = C1 - C2; 
  float dH2 = max(da*da + db*db - dC*dC, 0.0); 
  float K1 = 0.045; 
  float K2 = 0.015; 
  float Sc = 1.0 + K1*Cgmean; 
  float Sh = 1.0 + K2*Cgmean; 
  float Lv = dL; 
  float Cv = dC / Sc; 
  float Hv2 = dH2 / (Sh * Sh); 
  return sqrt(Lv*Lv + Cv*Cv + Hv2); 
kernel vec4 _LabDeltaE (__sample c1, __sample c2) 
  vec4 c1overwhite = c1 + (1.0 - c1.a); 
  vec3 lab1w = _toLab(c1overwhite.rgb); 
  vec3 lab1b = _toLab(c1.rgb); 
  vec4 c2overwhite = c2 + (1.0 - c2.a); 
  vec3 lab2w = _toLab(c2overwhite.rgb); 
  vec3 lab2b = _toLab(c2.rgb); 
  float dE = max(_deltaE(lab1w, lab2w), _deltaE(lab1b, lab2b)); 
  return vec4(dE); 
inputImage2
T@"CIImage",&,N,VinputImage2
inputSize
inputDecay
kernel vec4 _triangleKaleidoscopeColor (__sample c, vec2 center, vec4 ftrans, float decay)
  vec2 p = destCoord() - center;
  p = vec2(dot(p, ftrans.xy), dot(p, ftrans.zw));
  highp vec3 z = vec3(1.0 + p.x - p.y, 2.0 - p.x - 2.0 * p.y, 2.0 - 2.0 * p.x - p.y);
  z = abs(floor(z));
  float K = pow(decay, dot(z, vec3(1.0)));
  c.rgb *= K;
  return c;
kernel vec2 _triangleKaleidoscopeGeom (vec2 center, vec4 ftrans, vec4 btrans)
  vec2 p = destCoord() - center;
  p = vec2(dot(p, ftrans.xy), dot(p, ftrans.zw));
  p = fract(p);
  p = (p.x > p.y) ? p.yx : p;
  p.y = (p.y > 2.0 - p.x - p.y) ? (2.0 - p.x - p.y) : p.y;
  p.x = (p.x < 1.0 - p.x - p.y) ? (1.0 - p.x - p.y) : p.x;
  p = (p.x > p.y) ? p.yx : p;
  p = vec2(dot(p, btrans.xy), dot(p, btrans.zw));
  p += center;
  return p;
T@"NSNumber",&,N,VinputSize
T@"NSNumber",&,N,VinputRotation
T@"NSNumber",&,N,VinputDecay
kernel vec4 _cheapBlur(sampler src, vec2 parms)
  vec2 dc = destCoord();
  vec2 offA = parms * vec2(-1.0,  4.0);
  vec2 offB = parms * vec2( 4.0,  1.0);
  vec4 sul = sample(src, samplerTransform(src, dc + offA));
  vec4 sur = sample(src, samplerTransform(src, dc + offB));
  vec4 sdl = sample(src, samplerTransform(src, dc - offB));
  vec4 sdr = sample(src, samplerTransform(src, dc - offA));
  vec4 sc  = sample(src, samplerCoord (src));
  return 0.181818181818182 * sc + 0.204545454545455 * (sur + sul + sdr + sdl);
kernel vec4 _lerp(__sample src0, __sample src1, float factor) { return mix(src1, src0, factor); }
inputPasses
inputSampling
kernel vec2 _stretch (vec2 center, vec3 param)
  vec2 g = vec2(1.0) - clamp(abs(destCoord() - center) * param.x, 0.0, 1.0);
  g = (g * -2.0 + vec2(3.0)) * g * g;
  g *= param.y * sin((destCoord() - center.yy) * param.z);
  return destCoord() - g;
T@"CIVector",&,N,VinputSize
kernel vec2 _lighttunnel (vec4 param)
  vec2 p = destCoord() - param.xy;
  float rlen = param.z * inversesqrt(dot(p,p));
  float angle = log(rlen) * param.w;
  vec2 cs = vec2(cos(angle), sin(angle));
  p = vec2(dot(p, cs), dot(p, vec2(-cs.y, cs.x)));
  p = p * rlen + param.xy;
  p = mix(destCoord(), p, step(rlen, 1.0));
  return p;
curve gamma=%g a=%g b=%g c=%g d=%g e=%g f=%g
curve
inputSpatialSigma
inputLumaSigma
kernel vec4 _jointBilateral (sampler small, sampler guide, vec4 parms) 
  vec2 dc = destCoord(); 
  vec2 smallCenter = samplerCoord(small); 
  vec2 guideCenter = samplerCoord(guide); 
  vec2 smallDelta = samplerTransform(small, dc+vec2(1.0)) - smallCenter; 
  vec2 guideDelta = samplerTransform(guide, dc+vec2(1.0)) - guideCenter; 
  vec4 I0 = sample(small, smallCenter); 
  float IE0 = sample(guide, guideCenter).r; 
  vec4 sumFGI = vec4(0.0); 
  float sumFG = 0.0; 
  float x,y; 
  float w=2.0; 
  for (x=-w;x<=w;x++) 
  { 
    for (y=-w;y<=w;y++) 
    { 
      vec2 xy = vec2(x,y) * parms.zw; 
      float G = exp(-(x*x+y*y)*parms.y); 
      vec4  I  = sample(small, smallCenter + xy*smallDelta); 
      float IE = sample(guide, guideCenter + xy*guideDelta).g; 
      float F = exp(-((IE - IE0)*(IE - IE0))*parms.x); 
      sumFG += F*G; 
      sumFGI += F*G*I; 
    } 
  } 
  return sumFG<0.001 ? I0 : sumFGI/sumFG; 
kernel vec4 _jointBilateralRG (sampler combo, vec4 parms) 
  vec2 dc = destCoord(); 
  vec2 comboCenter = samplerCoord(combo); 
  vec2 comboDelta = samplerTransform(combo, dc+vec2(1.0)) - comboCenter; 
  vec4  c = sample(combo, comboCenter); 
  vec2  I0 = c.zw; 
  float IE0 = c.r; 
  vec2 sumFGI = vec2(0.0); 
  float sumFG = 0.0; 
  float x,y; 
  float w=2.0; 
  for (x=-w;x<=w;x++) 
  { 
    for (y=-w;y<=w;y++) 
    { 
      vec2 xy = vec2(x,y) * parms.zw; 
      float G = exp(-(x*x+y*y)*parms.y); 
      vec4  c = sample(combo, comboCenter + xy*comboDelta); 
      vec2  I  = c.zw; 
      float IE = c.g; 
      float F = exp(-((IE - IE0)*(IE - IE0))*parms.x); 
      sumFG += F*G; 
      sumFGI += F*G*I; 
    } 
  } 
  return vec4(sumFG<0.001 ? I0 : sumFGI/sumFG, 0.0, 1.0); 
kernel vec4 _guideCombine (__sample g, __sample gb) __attribute__((outputFormat(kCIFormatRGh))) 
  return vec4(g.r, gb.r, 0.0, 1.0); 
kernel vec4 _guideCombine4 (__sample guide, __sample guideblurred, __sample map) 
  return vec4(guide.r, guideblurred.r, map.rg); 
kernel vec4 _guideMono (__sample g) __attribute__((outputFormat(kCIFormatRh))) 
  return vec4(clamp(dot(g.rgb, vec3(0.3333)),0.0,1.0), 0.0, 0.0, 1.0); 
inputSigmaX
inputSigmaY
inputSmallImage
T@"CIImage",&,N,VinputSmallImage
T@"NSNumber",&,N,VinputSpatialSigma
T@"NSNumber",&,N,VinputLumaSigma
inputEnableNoiseTracking
inputNoiseReductionAmount
inputEnableSharpening
inputEnableVendorLensCorrection
inputDisableGamutMap
inputLuminanceNoiseReductionAmount
inputColorNoiseReductionAmount
inputNoiseReductionSharpnessAmount
inputNoiseReductionContrastAmount
inputNoiseReductionDetailAmount
inputMoireAmount
inputBaselineExposure
inputBoost
inputBoostShadowAmount
inputNeutralChromaticityX
inputNeutralChromaticityY
inputNeutralTemperature
inputNeutralTint
inputNeutralLocation
inputDraftMode
inputIgnoreOrientation
inputImageOrientation
inputLinearSpaceFilter
inputDecoderVersion
supportedDecoderVersions
outputNativeSize
activeKeys
[CIDetector detectorOfType:context:options:] failed because type %@ is unkonw.
CIDetectorTypeFace
CIDetectorTypeRectangle
CIDetectorTypeQRCode
CIDetectorTypeText
CIDetectorAccuracy
CIDetectorAccuracyLow
CIDetectorAccuracyHigh
CIDetectorMinFeatureSize
CIDetectorMaxFeatureCount
CIDetectorTracking
CIDetectorNumberOfAngles
CIDetectorImageOrientation
CIDetectorEyeBlink
CIDetectorSmile
CIDetectorFocalLength
CIDetectorAspectRatio
CIDetectorDetectDiacritics
CIDetectorReturnSubFeatures
CITextDetectorMinimizeFalseDetections
CIDetectorExtraCharacters
CIDetectorLanguage
CIDetectorLanguageNone
CIDetectorLanguageASCII
CIDetectorLanguageEnglish
CIDetectorLanguageDanish
CIDetectorLanguageDutch
CIDetectorLanguageFrench
CIDetectorLanguageGerman
CIDetectorLanguageIcelandic
CIDetectorLanguageItalian
CIDetectorLanguageNorwegian
CIDetectorLanguagePortuguese
CIDetectorLanguageSpanish
CIDetectorLanguageSwedish
Unknown CIDetectorAccuracy specified. Ignoring.
Unknown CIDetectorTracking specified. Ignoring.
Unknown CIDetectorMinFeatureSize specified. Ignoring.
Unknown CIDetectorNumberOfAngles specified. Ignoring.
Face detection finding face error: %@
Face detection finding facial expression error: %@
faceCoreDetector
T@"FCRFaceDetector",&,VfaceCoreDetector
type
T@"NSString",R,&
Face
Rectangle
QRCode
Text
T{CGRect={CGPoint=ff}{CGSize=ff}},R,Vbounds
hasLeftEyePosition
TB,R,VhasLeftEyePosition
T{CGPoint=ff},R,VleftEyePosition
hasRightEyePosition
TB,R,VhasRightEyePosition
T{CGPoint=ff},R,VrightEyePosition
hasMouthPosition
TB,R,VhasMouthPosition
T{CGPoint=ff},R,VmouthPosition
hasTrackingID
TB,R,VhasTrackingID
trackingID
Ti,R,VtrackingID
hasTrackingFrameCount
TB,R,VhasTrackingFrameCount
trackingFrameCount
Ti,R,VtrackingFrameCount
hasFaceAngle
TB,R,VhasFaceAngle
faceAngle
Tf,R,VfaceAngle
hasSmile
TB,R,VhasSmile
leftEyeClosed
TB,R,VleftEyeClosed
rightEyeClosed
TB,R,VrightEyeClosed
topLeft
T{CGPoint=ff},R,VtopLeft
topRight
T{CGPoint=ff},R,VtopRight
bottomLeft
T{CGPoint=ff},R,VbottomLeft
bottomRight
T{CGPoint=ff},R,VbottomRight
messageString
symbolDescriptor
T@"CIQRCodeDescriptor",R,VsymbolDescriptor
T@"NSString",R,VmessageString
subFeatures
T@"NSArray",R,VsubFeatures
-[CIColor initWithRed:green:blue:alpha:colorSpace:]
%g %g %g %g
(%g %g %g %g) %@
UIColor
colorWithCIColor:
blackColor
T@"CIColor",R
whiteColor
grayColor
redColor
greenColor
blueColor
cyanColor
magentaColor
yellowColor
clearColor
numberOfComponents
components
Tr^f,R
inputSkyAmount
inputGrassAmount
kernel vec4 _grassAndSkyAdjust (__sample im, vec2 params) 
  float enhanceGrass = params.x; 
  float enhanceSky = params.y; 
  vec3 ipt, ipt2; 
  float range; 
  { 
    vec3 lms = im.r * vec3(0.3347, 0.1747, 0.0187) + 
               im.g * vec3(0.5984, 0.7151, 0.1018) + 
               im.b * vec3(0.0671, 0.1106, 0.8794); 
    lms = sign(lms)*pow(abs(lms), vec3(0.43)); 
    ipt = lms.r * vec3(0.4,  4.455,  0.8056) + 
          lms.g * vec3(0.4, -4.851,  0.3572) + 
          lms.b * vec3(0.2,  0.396,-1.1628); 
  } 
  float hue = atan((sqrt(ipt.b*ipt.b+ipt.g*ipt.g)-ipt.g)/ipt.b)/3.1416+0.5; 
  range = hue - 0.88; 
  float maskGrass = exp((-1.0*range*range)/(2.0*.088*.088)); 
  range = 1.0 - smoothstep(0.4, 0.5, ipt.r); 
  maskGrass *= range; 
  vec2 idealGrass = vec2(-0.03, 0.1); 
  vec2 toIdeal = idealGrass - ipt.gb; 
  float dist = sqrt(toIdeal.r*toIdeal.r+toIdeal.g*toIdeal.g); 
  float chroma2 = 4.0*(ipt.g*ipt.g + ipt.b*ipt.b); 
  float str = enhanceGrass*pow(chroma2, .2); 
  str = str*min(1.0, 1.0-chroma2*chroma2); 
  str = min(str, 1.5); 
  float scale = min(1.0, 0.1/(dist+0.05)); 
  ipt2.gb = ipt.gb + str*toIdeal*scale; 
  ipt2.gb *= enhanceGrass; 
  ipt2.r = ipt.r; 
  ipt = mix(ipt, ipt2.rgb, maskGrass); 
  float maskSky = smoothstep(0.2, 0.5, ipt.r); 
  range = ipt.g + .04; 
  maskSky *= exp((-1.0*range*range)/(2.0*0.15*0.15)); 
  range = ipt.b + 0.1; 
  maskSky *= exp((-1.0*range*range)/(2.0*0.2*0.2)); 
  { 
    vec3 lms = ipt.r * vec3(1.0000, 1.0000, 1.0000) + 
               ipt.g * vec3(0.0976,-0.1139, 0.0326) + 
               ipt.b * vec3(0.2052, 0.1332,-0.6769); 
    lms = sign(lms)*pow(abs(lms), vec3(1.0/.43)); 
    im.rgb = lms.r * vec3( 5.3089, -1.3026,  0.0381) + 
             lms.g * vec3(-4.4648,  2.5193, -0.1968) + 
             lms.b * vec3( 0.1564, -0.2175,  1.1590); 
  } 
  im.rgb = max(im.rgb, 0.0); 
  float gain = max(1.0, 1.0 + enhanceSky); 
  float gamma = 1.0 + abs(enhanceSky); 
  vec4 result = pow(gain*im, vec4(gamma)); 
  float gray = (result.r + result.b + result.g)/3.0; 
  result.rgb += (result.rgb-gray) * abs(enhanceSky) * 0.5; 
  result = mix(im, result, maskSky); 
  result.a = im.a; 
  return result;
T@"NSNumber",&,N,VinputSkyAmount
T@"NSNumber",&,N,VinputGrassAmount
CI_ENABLE_SUBDIVIDE_ROI
CI_MAX_TEXTURE_SIZE
CI_IOSURFACE_WRAPPING
CI_IOSURFACE_INTERMEDIATES
CI_PRINT_TIME
CI_PRINT_TREE
CI_PRINT_TREE options flags:
%3d  initial graph %s
(set)
%3d  optimized graph %s
%3d  program graph %s
 dump-inputs %s
dump-inputs
 dump-intermediates %s
dump-intermediates
 dump-timing %s
dump-timing
 skip-cpu %s
skip-cpu
 skip-gpu %s
skip-gpu
 skip-small %s
skip-small
(set number=%d)
 frame-<number> %s
(set format=%s)
 <format> (dot/pdf) %s
frame-
graphviz
CI_PRINT_PROGRAM
CI_USE_SW
CI_NO_CM
CI_FORCE_IS_BACKGROUND
CI_FORCE_GPU_PRIORITY
CI_INPUT_CACHE_SIZE
CI_ENABLE_KERNEL_CACHE
CI_ASYNC_KERNEL_COMPILE
CI_INTERMEDIATE_CACHE_SIZE
CI_INTERMEDIATE_SRGB_TEXTURES
CI_INPUT_SRGB_TEXTURES
CI_OUTPUT_SRGB_TEXTURES
CI_RECYCLE_OPENGL_TEXTURES
CI_RECYCLE_METAL_TEXTURES
CI_WORKING_FORMAT
CI_ENABLE_METAL_GPU
CI_ENABLE_METAL_CONVERT
CI_ENABLE_METAL_BLIT
CI_ENABLE_METAL_REFLECTION
CI_ENABLE_CL_CPU
CI_ENABLE_CL_GPU
CI_AUTOTEST_ROI
CI_DISABLE_MERGING
CI_DISABLE_MERGING_PRE_GENERAL
CI_DISABLE_MERGING_POST_GENERAL
CI_LOG_TEXTURE_CACHE
CI_LIMIT_SAMPLERS
CI_LIMIT_RENDER
CI_NO_RENDER
CI_LOG_SURFACE_CACHE
CI_LOG_IMAGE_PROVIDER
CI_RENDER_MB_LIMIT
CI_SURFACE_CACHE_CAPACITY
CI_TEMP_DIR
CI_KDEBUG
CI_DISABLE_CRUFT_COMPATABILITY
CI_FORCE_INSERT_NOOPS
CI_MAX_CL_COMPLEXITY
CI_DEBUG_CONTEXT_COLOR
CI_DISABLE_WORKAROUND
CI_GRAPH_ALLOW_REORDER
CI_GRAPH_FORCE_CROP
CI_FLIP_IMAGE_PROCESSOR
CI_FORCE_GLES_VERSION
CI_CACHE_PROGRAM_GRAPH
FOSL_DUMP_GRAPH
FOSL_PRINT_GRAPH
FOSL_PRINT_KERNEL_AST
&amp;
&lt;
&gt;
&quot;
&apos;
 94 42182154  3198255235 94254236138180 80 32238196106200163
231135151  7244167137102 45 85205108187254 85 31125176101125
210159109 92 99  0111 42232183107 75 83 73 33168 13158104 52
 21 79 25207203 12204  9 16  0 62169 72 50 15164121 22 12 90
135126204  9215 16198163 19138 52 28252162 65199105 9821615
110155171173177217230 12135125 99179192 62  5100 27100247229
158 76 12 19 74 59179 69199170224162116160 36243192238102116
227190 38186 46106  3151139 74180110126140101135 38175114 52
 45 22116246144186171156230 18224154112100 95178129 78 52 67
154 79203178105 68227227 46106 31216231181 41 16111 49120 67
  8228 62134  5248 95233220104181 33112 30245  1 49236 63237
252226233 24195165144 12195245 33239 61140 56 66242 86209 37
195 93 42 53191  4198 41165172182107162183 15163222242 96 46
 43 78166 61115228209209199 78 64193117220101158144234 11205
%.5f
%.6f
originalFaceColor
T{?=ff},R,VoriginalFaceColor
lumHist
T@"CIEnhancementHistogram",R,VlumHist
rgbSumHist
T@"CIEnhancementHistogram",R,VrgbSumHist
satHist
T@"CIEnhancementHistogram",R,VsatHist
borderHist
T@"CIEnhancementHistogram",R,VborderHist
CIKernelLibrary
Cannot initialize kernel library on unsupported system.
functionCount
%spremultiply
kernel vec4 _spotLight (__sample src, vec3 lightpos, vec3 lightpointsat, vec4 lightcolor, vec2 parms)
  vec4 t0 = vec4(0.0);
  t0.xy = destCoord();
  vec4 r0;
  r0.xyz = lightpos - t0.xyz;
  r0.w = 0.0;
  r0 = normalize(r0);
  float k0 = dot(r0.xyz, lightpointsat);
  k0 = clamp(k0, 0.0, 1.0);
  k0 = pow(k0, parms.x); 
  vec4 r3 = k0 * lightcolor;
  r0 = r0.z * r3;
  vec4 dest = r0 * src;
  return dest;
inputConcentration
inputLightPosition
inputLightPointsAt
builtin_premultiply
builtin_unpremultiply
Invalid premultiply power %d.
premultiply
unpremultiply
nopremultiply
badpremultiply
premul
unpremul
kernel vec4 _colorcube (__sample im, sampler2D cube, vec4 dims)
  im.rgb = clamp(im.rgb, 0.0001, 0.9999);
  im.rgb *= dims.x;
  float flr = floor(im.b);
  vec2 xy = (0.5 + im.rg) * dims.zw;
  xy.y += flr * dims.z; 
  vec4 sLo = texture2D(cube, xy);
  xy.y += dims.z; 
  vec4 sHi = texture2D(cube, xy);
  return mix(sLo, sHi, im.b - flr) * im.a;
kernel vec4 _colorcubeopaque (__sample im, sampler2D cube, vec4 dims)
  im.rgb = clamp(im.rgb, 0.0001, 0.9999);
  im.rgb *= dims.x;
  float flr = floor(im.b);
  vec2 xy = (0.5 + im.rg) * dims.zw;
  xy.y += flr * dims.z; 
  vec3 sLo = texture2D(cube, xy).rgb;
  xy.y += dims.z; 
  vec3 sHi = texture2D(cube, xy).rgb;
  im.rgb = mix(sLo, sHi, im.b - flr);
  return im;
CIColorCube inputCubeDimension must be from 2 through %d.
CIColorCube inputCubeData must be of type NSData.
CIColorCube inputCubeData is not of the expected length.
T@"NSNumber",&,N,VinputCubeDimension
T@"NSData",C,N,VinputCubeData
CIColorCubeWithColorSpace inputColorSpace must be an RGB CGColorSpaceRef
inputCube0Data
inputCube1Data
CIColorCube inputCube0Data must be of type NSData.
CIColorCube inputCube1Data must be of type NSData.
CIColorCube inputCube0Data is not of the expected length.
CIColorCube inputCube1Data is not of the expected length.
T@"CIImage",&,N,VinputMaskImage
T@"NSData",C,N,VinputCube0Data
T@"NSData",C,N,VinputCube1Data
kernel vec4 _radialGradient (vec4 params, __color c0, __color c1)
  highp float t = distance(destCoord(),params.xy) * params.z + params.w;
  return mix(c0, c1, clamp(t, 0.0, 1.0));
inputRadius0
inputRadius1
T@"NSNumber",&,N,VinputRadius0
T@"NSNumber",&,N,VinputRadius1
kernel vec4 _linearGradient (vec2 p0, vec2 p1, __color c0, __color c1, float d1Inv)
  highp float t = dot(p1 - p0, destCoord() - p0) * d1Inv;
  return mix(c0, c1, clamp(t, 0.0, 1.0));
T@"CIVector",&,N,VinputPoint0
T@"CIVector",&,N,VinputPoint1
kernel vec4 _smoothLinearGradient (vec2 p0, vec2 p1, __color c0, __color c1, float d1Inv)
  highp float t = dot(p1 - p0, destCoord() - p0) * d1Inv;
  return mix(c0, c1, smoothstep(0.0, 1.0, t));
kernel vec4 _gaussianGradient (vec3 params, __color c0, __color c1)
  highp float d = min(distance(destCoord(), params.xy) * params.z, 1.0);
  d = (d * -2.0 + 3.0) * d * d;
  return mix(c0, c1, d);
kernel vec4 _hsvwheel (vec4 params) 
  float value = params.x; 
  float radius = params.y; 
  float invradius = params.z; 
  float smoothness = params.w; 
  vec2 p = destCoord() - vec2(radius); 
  float len = length(p); 
  float H = atan(p.y,p.x) * 3.0 / 3.1415926; 
  float S = clamp(len / radius, 0.0, 1.0); 
  vec4 c = vec4(H, H-2.0, H+2.0, 0.0); 
  c = clamp(abs(3.0-abs(c))-1.0, 0.0, 1.0); 
  c = mix(c, smoothstep(0.0,1.0,c), smoothness); 
  c = mix(vec4(1.0), c, S); 
  c.a = 1.0; 
  c.rgb *= value; 
  return c * clamp(radius - len, 0.0, 1.0); 
float noise(float seed, vec2 dc) 
  float x = (13.0*dc.x + 1111.0)/(17.0 + seed); 
  float y = (11.0*dc.y + 7777.0)/(19.0 - seed); 
  float m = 37.0; 
  float n = x; 
  n = mod(y*n + y, m); 
  n = mod(y*n + x, m); 
  n = mod(x*n, m); 
  n = mod(x*n, m); 
  return n/m; 
kernel vec4 _hsvwheeldithered (vec4 params, float dither) 
  float value = params.x; 
  float radius = params.y; 
  float invradius = params.z; 
  float smoothness = params.w; 
  vec2 p = destCoord() - vec2(radius); 
  float len = length(p); 
  float H = atan(p.y,p.x) * 3.0 / 3.1415926; 
  float S = clamp(len / radius, 0.0, 1.0); 
  vec4 c = vec4(H, H-2.0, H+2.0, 0.0); 
  c = clamp(abs(3.0-abs(c))-1.0, 0.0, 1.0); 
  c = mix(c, smoothstep(0.0,1.0,c), smoothness); 
  c = mix(vec4(1.0), c, S); 
  c.a = 1.0; 
  c.rgb *= value; 
  c.rgb += (noise(0.0, floor(destCoord())) - 0.5)*dither; 
  return c * clamp(radius - len, 0.0, 1.0); 
+[CIHueSaturationValueGradient customAttributes]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/CIGradient.mm
inputValue
inputDither
T@"NSNumber",&,N,VinputValue
T@"NSNumber",&,N,VinputSoftness
T@"NSNumber",&,N,VinputDither
kernel vec4 _colorMonochrome (__sample img, __color color, float intensity)
  float c1 = dot(img.rgb, vec3(0.2125, 0.7154, 0.0721));
  vec4 low = 2.0 * c1 * color;
  vec4 high = 1.0 - 2.0 * ((1.0 - c1) * (vec4(1.0) - color));
  vec4 lt = vec4(lessThan(vec4(c1 - 0.5), vec4(0.0)));
  vec4 pix = mix(img, mix(high, low, lt), intensity);
  img.rgb = pix.rgb;
  return img;
T@"CIImage",&,N,VinputBackgroundImage
kernel vec4 _hueBlendMode_v0 (__sample pCf, __sample pCb) 
  vec4 uCf = unpremultiply(pCf);  vec4 uCb = unpremultiply(pCb);  vec4 uCfSort = (uCf.r > uCf.g) ? uCf : uCf.grba;
  uCfSort = (uCfSort.g > uCfSort.b) ? uCfSort : uCfSort.rbga;
  uCfSort = (uCfSort.r > uCfSort.g) ? uCfSort : uCfSort.grba;
  vec4 uCbSort = (uCb.r > uCb.g) ? uCb : uCb.grba;
  uCbSort = (uCbSort.g > uCbSort.b) ? uCbSort : uCbSort.rbga;
  uCbSort = (uCbSort.r > uCbSort.g) ? uCbSort : uCbSort.grba;
  vec4 Ct = (uCfSort.b+0.00001 > uCfSort.r) ? uCbSort.rbba : (uCf - uCfSort.b) * (uCbSort.r - uCbSort.b) / (uCfSort.r - uCfSort.b) + uCbSort.b;
  Ct.a = uCb.a;
  vec4 Cb = vec4(uCb.rgb * uCb.a, uCb.a);
  Ct = mix(uCf, Ct, uCb.a);
  Ct.a = 1.0;
  return mix(Cb, Ct, uCf.a);
kernel vec4 _saturationBlendMode_v0 (__sample pCf, __sample pCb)
  vec4 uCf = unpremultiply(pCf);  vec4 uCb = unpremultiply(pCb);  vec4 uCfSort = (uCf.r > uCf.g) ? uCf : uCf.grba;
  uCfSort = (uCfSort.g > uCfSort.b) ? uCfSort : uCfSort.rbga;
  uCfSort = (uCfSort.r > uCfSort.g) ? uCfSort : uCfSort.grba;
  float fL = (uCfSort.r + uCfSort.b) * 0.5;
  float cmax = uCfSort.r;
  float cmin = uCfSort.b;
  vec4 uCbSort = (uCb.r > uCb.g) ? uCb : uCb.grba;
  uCbSort = (uCbSort.g > uCbSort.b) ? uCbSort : uCbSort.rbga;
  uCbSort = (uCbSort.r > uCbSort.g) ? uCbSort : uCbSort.grba;
  float bL = (uCbSort.r + uCbSort.b) * 0.5;
  float d = cmax - cmin;
  float dv = (fL < 0.5) ? (cmax + cmin) : (2.0 - (cmax + cmin));
  float s = d / max(dv, 0.000001);
  float mmax = (bL <= 0.5) ? (bL + bL*s) : (bL + s - bL*s);
  float mmin = bL * 2.0 - mmax;
  vec4 Ct = (uCbSort.b+0.00001 > uCbSort.r) ? vec4(mmax,mmin,mmin,1.0) : (uCb - uCbSort.b) * (mmax - mmin) / (uCbSort.r - uCbSort.b) + mmin;
  Ct.a = uCb.a;
  vec4 Cb = vec4(uCb.rgb * uCb.a, uCb.a);
  Ct = mix(uCf, Ct, uCb.a);
  Ct.a = 1.0;
  return mix(Cb, Ct, uCf.a);
kernel vec4 _colorBlendMode_v0 (__sample pCf, __sample pCb)
  vec4 uCf = unpremultiply(pCf);  vec4 uCb = unpremultiply(pCb);  vec4 uCfSort = (uCf.r > uCf.g) ? uCf : uCf.grba;
  uCfSort = (uCfSort.g > uCfSort.b) ? uCfSort : uCfSort.rbga;
  uCfSort = (uCfSort.r > uCfSort.g) ? uCfSort : uCfSort.grba;
  float fL = (uCfSort.r + uCfSort.b) * 0.5;
  float cmax = uCfSort.r;
  float cmin = uCfSort.b;
  vec4 uCbSort = (uCb.r > uCb.g) ? uCb : uCb.grba;
  uCbSort = (uCbSort.g > uCbSort.b) ? uCbSort : uCbSort.rbga;
  uCbSort = (uCbSort.r > uCbSort.g) ? uCbSort : uCbSort.grba;
  float bL = (uCbSort.r + uCbSort.b) * 0.5;
  float d = cmax - cmin;
  float dv = (fL < 0.5) ? (cmax + cmin) : (2.0 - (cmax + cmin));
  float s = d / max(dv, 0.000001);
  float mmax = (bL <= 0.5) ? (bL + bL*s) : (bL + s - bL*s);
  float mmin = bL * 2.0 - mmax;
  vec4 Ct = (uCf - uCfSort.b) * (mmax - mmin) / (uCfSort.r - uCfSort.b) + mmin;
  Ct = (mmin+0.00001 > mmax) ? vec4(mmin) : Ct;
  Ct.a = uCb.a;
  vec4 Cb = vec4(uCb.rgb * uCb.a, uCb.a);
  Ct = mix(uCf, Ct, uCb.a);
  Ct.a = 1.0;
  return mix(Cb, Ct, uCf.a);
kernel vec4 _luminosityBlendMode_v0 (__sample pCf, __sample pCb)
  vec4 uCf = unpremultiply(pCf);  vec4 uCb = unpremultiply(pCb);  vec4 uCbSort = (uCb.r > uCb.g) ? uCb : uCb.grba;
  uCbSort = (uCbSort.g > uCbSort.b) ? uCbSort : uCbSort.rbga;
  uCbSort = (uCbSort.r > uCbSort.g) ? uCbSort : uCbSort.grba;
  float fL = (uCbSort.r + uCbSort.b) * 0.5;
  float cmax = uCbSort.r;
  float cmin = uCbSort.b;
  vec4 uCfSort = (uCf.r > uCf.g) ? uCf : uCf.grba;
  uCfSort = (uCfSort.g > uCfSort.b) ? uCfSort : uCfSort.rbga;
  uCfSort = (uCfSort.r > uCfSort.g) ? uCfSort : uCfSort.grba;
  float bL = (uCfSort.r + uCfSort.b) * 0.5;
  float d = cmax - cmin;
  float dv = (fL < 0.5) ? (cmax + cmin) : (2.0 - (cmax + cmin));
  float s = d / max(dv, 0.000001);
  float mmax = (bL <= 0.5) ? (bL + bL*s) : (bL + s - bL*s);
  float mmin = bL * 2.0 - mmax;
  vec4 Ct = (uCb - uCbSort.b) * (mmax - mmin) / (uCbSort.r - uCbSort.b) + mmin;
  Ct = (mmin+0.00001 > mmax) ? vec4(mmin) : Ct;
  Ct.a = uCf.a;
  vec4 Cf = vec4(uCf.rgb * uCf.a, uCf.a);
  Ct = mix(uCb, Ct, uCf.a);
  Ct.a = 1.0;
  return mix(Cf, Ct, uCb.a);
kernel vec4 _linearBurnBlendMode_v0 (__sample pCf, __sample pCb)
  vec4 uCf = unpremultiply(pCf);  vec4 uCb = unpremultiply(pCb);  vec4 Ct = clamp(uCb - (1.0 - uCf*uCf.a), 0.0, 1.0);
  vec4 Cb = vec4(uCb.rgb * uCb.a, uCb.a);
  Ct = mix(uCf, Ct, uCb.a);
  Ct.a = 1.0;
  return mix(Cb, Ct, uCf.a);
kernel vec2 _twirl(vec4 param)
  vec2 d = destCoord() - param.xy;
  float r = min(length(d) * param.z, 1.0);
  float _1mr = 1.0 - r;
  float ss = (_1mr * -2.0 + 3.0) * _1mr * _1mr;
  float angle = param.w * ss;
  vec2 cs = vec2(cos(angle), sin(angle));
  vec2 p = vec2(dot(d, cs), dot(d, vec2(-cs.y, cs.x)));
  return (r >= 1.0) ? destCoord() : p + param.xy;
function not implemented
out of boundaries
<CI::Color %p>[%g %g %g %g]
[%g %g %g %g 
kernel vec4 _vignette (__sample s, vec4 params)
  vec2 point = destCoord() - params.xy;
  float len2 = dot(point, point);
  float v = pow(max(1.0 - len2 * params.w, 0.0), params.z);
  s.rgb *= v;
  return s;
kernel vec4 _vignetteeffect (__sample s, vec2 center, vec4 params) 
  vec2 point = (destCoord() - center) * params.x; 
  float dist = sqrt(dot(point,point)); 
  float x = clamp((dist-params.y)*params.z,0.0,1.0); 
  x = x*x*x*((6.0*x - 15.0)*x + 10.0); 
  float v = 1.0 - x*params.w; 
  v = ((( -0.120638501063760*v + 0.543878646118680)*v + 0.538772615443760)*v + 0.037600999734998)*v; 
  s.rgb *= v; 
  return s; 
kernel vec4 _vignetteeffectneg (__sample s, vec2 center, vec4 params) 
  vec2 point = (destCoord() - center) * params.x; 
  float dist = sqrt(dot(point,point)); 
  float x = clamp((dist-params.y)*params.z,0.0,1.0); 
  x = x*x*x*((6.0*x - 15.0)*x + 10.0); 
  float v = 16.0*x*params.w + 1.0; 
  s.rgb *= v; 
  return s; 
T@"NSNumber",&,N,VinputFalloff
kernel vec2 _kaleida (vec4 parms, vec4 rota, vec4 rotb)
  vec2 ctr = parms.xy;
  float TwoPiDivCount = parms.z;
  float CountDivTwoPi = parms.w;
  vec2 v = destCoord() - ctr;
  v = vec2(dot(v, rota.xy), dot(v, rota.zw));
  const float pi = 3.141592653589793;
  const float halfpi = 1.570796326794897;
  v.y = abs(v.y);
  float a = atan(v.y,v.x);
  a = - TwoPiDivCount * floor(a*CountDivTwoPi+0.5);
  float x = (a>halfpi) ? pi-a : a;
  x = (x<-halfpi) ? -pi-x : x;
  float sn = x - (x*x*x/6.0) + (x*x*x*x*x/120.0) - (x*x*x*x*x*x*x/5040.0) + (x*x*x*x*x*x*x*x*x/362880.0);
  x = abs(a);
  float k = (x>halfpi) ? -1.0 : 1.0;
  x = (x>halfpi) ? pi-x : x;
  x = x*x;
  x = (((0.000024801587302*x - 0.001388888888889)*x + 0.041666666666667)*x - 0.5)*x + 1.0;
  float cs = x*k;
  v = vec2(v.x*cs - v.y*sn, v.x*sn + v.y*cs);
  v.y = abs(v.y);
  v = vec2(dot(v, rotb.xy),dot(v, rotb.zw));
  return v + ctr;
devicegray
devicergb
calRGB(
wp=d50 
wp=%.3f,%.3f,%.3f 
bp=%.3f,%.3f,%.3f 
gamma=1 
gamma=%.3f 
gamma=%.3f,%.3f,%.3f 
mtx=%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)
calGray(
gamma=1)
gamma=%.3f)
DeviceCMYK Colorspace %p
Lab Colorspace %p
Indexed Colorspace %p
DeviceN Colorspace %p
Pattern Colorspace %p
PlatformSets Colorspace %p
kernel vec4 _yccCombiner (__sample imY, __sample imCC)
  return vec4(imY.r, imCC.rg, imY.a);
srgb_to_linear
linear_to_srgb
srgb_noop
builtin_linear_to_srgb
builtin_srgb_to_linear
Invalid srgb direction %d.
srgb_invalid
lintosrgb
srgbtolin
samplemode
inputDamping
kernel vec4 _colorbalance (__sample pix, __color clr, vec4 params)
  pix.rgb = pix.r * vec3(0.299,  0.595716,  0.211456) + 
            pix.g * vec3(0.587, -0.274453, -0.522591) + 
            pix.b * vec3(0.114, -0.321263,  0.311135);
  clr.rgb /= max(clr.a, 0.00001);
  clr.rgb = pow(max(clr.rgb, 0.0), vec3(0.25)); 
  clr.rgb = clr.r * vec3(0.299,  0.595716,  0.211456) + 
            clr.g * vec3(0.587, -0.274453, -0.522591) + 
            clr.b * vec3(0.114, -0.321263,  0.311135);
  pix.gb += params.z * (params.xy - clr.gb) * pow(pix.r, params.w); 
  pix.rgb = pix.r * vec3(1.0) + 
            pix.g * vec3(0.956296, -0.272122, -1.10699) + 
            pix.b * vec3(0.621024, -0.647381, 1.70461); 
  return pix;
T@"NSNumber",&,N,VinputDamping
kernel vec2 _pinchDistortionScaleLT1(vec2 c, vec4 param)
  vec2 p = destCoord() - c;
  float r = length(p) * param.y + .000001;
  p = p * inversesqrt(r) + c;
  return mix(destCoord(), p, param.z);
kernel vec2 _pinchDistortionScaleGE1(vec2 c, vec4 param)
  vec2 p = destCoord() - c;
  float r = length(p) * param.y + .000001;
  vec2 pRGT = pow(r, param.w) * p + c;
  p = p * inversesqrt(r) + c;
  p = mix(destCoord(), p, param.z);
  return (r <= 1.0) ? p : pRGT;
Invalid scale %g in CIPinchDistortion, must be less than 2
map_point_inv
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/PhotoBooth/CIPinchDistortion.m
scale < 2.0
kernel vec4 _portraitConvertToGrayscale (__sample c) __attribute__((outputFormat(kCIFormatRh))) {
  float g = dot(c.rgb, vec3(0.333333));
  return vec4(g, 0.0, 0.0, 1.0);
kernel vec4 _portraitLocalContrast(__sample im, __sample shc, float amt)
  float midAmt = amt;
  vec3 neg = min(im.rgb, 0.0);
  vec3 pos = max(im.rgb, 1.0)-1.0;
  im.rgb = clamp(im.rgb, 0.0, 1.0);
  float y = dot(im.rgb, vec3(0.3333));
  y = sqrt(y);
  y = y*(1.0-y);
  im.rgb = sqrt(im.rgb);
  float pivot = sqrt(shc.r);
  float a = midAmt*y;
  float b = -pivot*a;
  vec3 pix = im.r * vec3(0.299*a) +
             im.g * vec3(0.587*a) +
             im.b * vec3(0.114*a) +
             im.rgb + vec3(b);
  im.rgb = mix(im.rgb, vec3(pivot), -y*midAmt);
  im.rgb = mix(im.rgb, pix, 0.8);
  im.rgb = max(im.rgb, 0.0);
  im.rgb *= im.rgb;
  im.rgb = im.rgb + neg + pos;
  return im;
colormatch
workingspace
_to_
Matching a color failed: from 
 to 
Core Image could not support source colorspace: 
B48@?0{CGColorConversionIteratorData=Iiiiiii^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMLUTData}}4^{__CFDictionary=}44
B56@?0{CGColorConversionIteratorData=Iiiiiii^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMLUTData}}4l44l48^i52
B52@?0{CGColorConversionIteratorData=Iiiiiii^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMLUTData}}4l44l48
failed to create a converter from 
cmlut %llu
cm%zux%zulut %llu
kernel vec4 _cmlut (__sample im, sampler2D lut, vec2 dim)
  im.rgb = clamp(im.rgb, 0.0, 1.0); 
  im.rgb = im.rgb * dim.x + dim.y; 
  im.r = texture2D(lut, vec2(im.r, 0.5)).r; 
  im.g = texture2D(lut, vec2(im.g, 0.5)).r; 
  im.b = texture2D(lut, vec2(im.b, 0.5)).r; 
  return im;
cube
_cmlut
kernel vec4 _cmcubeopaque (__sample im, sampler2D cube, vec4 dims)
  im.rgb = clamp(im.rgb, 0.0001, 0.9999);
  im.rgb *= dims.x;
  float flr = floor(im.b);
  vec2 xy = (0.5 + im.rg) * dims.zw;
  xy.y += flr * dims.z; 
  vec3 sLo = texture2D(cube, xy).rgb;
  xy.y += dims.z; 
  vec3 sHi = texture2D(cube, xy).rgb;
  im.rgb = mix(sLo, sHi, im.b - flr);
  return im;
dims
_cmcubeopaque
kernel vec4 _cm1x3lut (__sample im, sampler2D lut, vec2 dim)
  im.rgb = clamp(im.rgb, 0.0, 1.0); 
  im.rgb = im.rgb * dim.x + dim.y; 
  im.rgb = texture2D(lut, vec2(im.r, 0.5)).rgb; 
  return im;
_cm1x3lut
Core Image could not support destination colorspace: 
vec4 _pointillizeStep( sampler src, vec4 background, sampler noise, vec2 cellSize, vec2 noiseOffset, vec2 cellOffset, vec2 dc)
  float o; 
  float tSize = 256.0; 
  float _randomFactor = 0.65; 
  float _radiusFactor = 0.71; 
  float _colorRandom = 0.1; 
  vec2 noiseLoc = floor(dc*cellSize.y + .5) + noiseOffset; 
  vec4 np = sample(noise, samplerTransform(noise, mod(noiseLoc, tSize))); 
  vec2 cellLoc = (floor(dc*cellSize.y - 0.5) + 0.5) * cellSize.x + 0.5 + cellOffset; 
  cellLoc += (np.xy - 0.5) * cellSize.x * _randomFactor; 
  o = distance(dc, cellLoc); 
  o = clamp((1.0 - o * cellSize.y / _radiusFactor) * 3.0, 0.0, 1.0); 
  o = (3.0 - 2.0 * o) * o * o; 
  vec4 p1 = sample(src, samplerTransform(src, cellLoc)); 
  p1.rgb += vec3(np.b - 0.5) * _colorRandom * p1.a; 
  return mix(background, p1, o); 
kernel vec4 _pointillize(sampler src, sampler noise, vec4 parms)
  vec4 background = sample(src, samplerCoord(src)).aaaa;
  background = _pointillizeStep(src, background, noise, parms.zw, parms.xy + vec2(0.5,0.5),   vec2(parms.z,parms.z), destCoord()); 
  background = _pointillizeStep(src, background, noise, parms.zw, parms.xy + vec2(-0.5,0.5),  vec2(0,parms.z),       destCoord()); 
  background = _pointillizeStep(src, background, noise, parms.zw, parms.xy + vec2(0.5,-0.5),  vec2(parms.z,0),       destCoord()); 
  background = _pointillizeStep(src, background, noise, parms.zw, parms.xy + vec2(-0.5,-0.5), vec2(0,0),             destCoord()); 
  return background;
Projections_status Projections_computeShiftBruteForce(const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float, float *, float *, float *, float *)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/api/Burst/Projections/Projections_Optimizer.c
Projections_status Projections_computeCost(int, float, float, const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float *)
clamptoalpha
clamp_to_alpha
memstream_write
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/util/memstream.c
ms->size < ms->capacity
ms->contents[ms->size] == 0
memstream_seek
ms->size < ms->capacity && ms->contents[ms->size] == 0
memstream_close
vec2 clampToRect(vec2 point,vec4 rect) {
  return clamp(point,rect.xy,rect.xy + rect.zw);
vec4 sampleBilinear(sampler image,vec2 p) {
    vec2 xy0 = p - vec2(0.5);
    vec2  p0 = floor(xy0);
    vec2  p1 = p0 + vec2(1.0);
    vec2 amount = p1 - xy0;
    vec4 ll = sample(image, samplerTransform(image, p0 + vec2(0.5)));
    vec4 ur = sample(image, samplerTransform(image, p1 + vec2(0.5)));
    vec4 lr = sample(image, samplerTransform(image, vec2(p1.x, p0.y) + vec2(0.5)));
    vec4 ul = sample(image, samplerTransform(image, vec2(p0.x, p1.y) + vec2(0.5)));
    vec4 bottom = mix(lr, ll, amount.x);
    vec4 top = mix(ur, ul, amount.x);
    return mix(top, bottom, amount.y);
kernel vec4 variableBoxBlur(sampler integralImage,sampler radiusImage,float scale,vec4 e) {
  vec4 v = unpremultiply(sample(radiusImage, samplerCoord(radiusImage)));
  float radius = scale * dot(v.rgb,vec3(0.2126, 0.7152, 0.0722));
 radius = max(radius, 0.5);
  vec2 c = destCoord();
  vec2 lowerLeft = clampToRect(c + vec2(-radius-1.0, -radius), e);
  vec2 upperRight = clampToRect(c + vec2(radius, radius+1.0), e);
  vec4 ul = sampleBilinear(integralImage, vec2(lowerLeft.x, upperRight.y));
  vec4 ur = sampleBilinear(integralImage, upperRight);
  vec4 ll = sampleBilinear(integralImage, lowerLeft);
  vec4 lr = sampleBilinear(integralImage, vec2(upperRight.x, lowerLeft.y));
  vec4 rc = ul + lr - ur - ll;
  vec2 diagonal = upperRight - lowerLeft;
  float usedArea = abs(diagonal.x * diagonal.y);
  float originalArea = (2.0*radius+1.0) * (2.0*radius+1.0);
 rc /= rc.a;
 rc.a = 1.0;
  return premultiply(rc);
inputRadiusImage
T@"CIImage",&,N,VinputRadiusImage
kernel vec4 _white(__sample src)
  return vec4(src.a);
kernel vec4 _cmyk_convert(__sample src, vec2 ucrgcr)
  vec4 pix = src;
  vec3 v = 1.0 - pix.rgb;
  float f = min(min(v.r,v.g),v.b) * ucrgcr.y;
  float sblack = f * f;
  float removed = sblack * ucrgcr.x;
  pix.rgb = v - vec3(removed);
  pix.a = sblack;
  return pix;
kernel vec4 _cmyk_cyan(__sample sofar, __sample cmyksrc, vec2 center, vec4 mtx, float con)
  vec2 pt = destCoord() - center;
  pt = vec2(dot(pt, mtx.xy),dot(pt, mtx.zw));
  pt = fract(pt + center) * 6.2831853;
  float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / con) + 0.5;
  float f = clamp((cmyksrc.r - g) * con + 0.5, 0.0, 1.0);
  vec4 ink = mix(vec4(1.0), vec4(0.0,1.0,1.0,1.0), f);
  return clamp(ink * sofar, 0.0, 1.0);
kernel vec4 _cmyk_magenta(__sample sofar, __sample cmyksrc, vec2 center, vec4 mtx, float con)
  vec2 pt = destCoord() - center;
  pt = vec2(dot(pt, mtx.xy),dot(pt, mtx.zw));
  pt = fract(pt + center) * 6.2831853;
  float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / con) + 0.5;
  float f = clamp((cmyksrc.g - g) * con + 0.5, 0.0, 1.0);
  vec4 ink = mix(vec4(1.0), vec4(1.0,0.0,1.0,1.0), f);
  return clamp(ink * sofar, 0.0, 1.0);
kernel vec4 _cmyk_yellow(__sample sofar, __sample cmyksrc, vec2 center, vec4 mtx, float con)
  vec2 pt = destCoord() - center;
  pt = vec2(dot(pt, mtx.xy),dot(pt, mtx.zw));
  pt = fract(pt + center) * 6.2831853;
  float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / con) + 0.5;
  float f = clamp((cmyksrc.b - g) * con + 0.5, 0.0, 1.0);
  vec4 ink = mix(vec4(1.0), vec4(1.0,1.0,0.0,1.0), f);
  return clamp(ink * sofar, 0.0, 1.0);
kernel vec4 _cmyk_black(__sample sofar, __sample cmyksrc, vec2 center, vec4 mtx, float con)
  vec2 pt = destCoord() - center;
  pt = vec2(dot(pt, mtx.xy),dot(pt, mtx.zw));
  pt = fract(pt + center) * 6.2831853;
  float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / con) + 0.5;
  float f = clamp((cmyksrc.a - g) * con + 0.5, 0.0, 1.0);
  vec4 ink = mix(vec4(1.0), vec4(0.0,0.0,0.0,1.0), f);
  return clamp(ink * sofar, 0.0, 1.0);
inputGCR
inputUCR
kernel vec4 _rectangle (vec4 parms1, vec4 parms2, __color color)
  vec4 d0 = destCoord().xxyy;
  d0 = d0 * parms1 + parms2;
  d0 = clamp(max(d0, d0.yxwz), 0.0, 1.0);
  d0 = 1.0 - smoothstep(0.0, 1.0, d0); 
  return d0.x * d0.z * color; 
kernel vec2 _wrapMirror (vec2 dim) { return mix(dim - abs(dim-destCoord()), abs(destCoord()), vec2(lessThan(destCoord(), 0.5 * dim))); }
kernel vec4 _lumaMap (__sample pixel, sampler2D table,vec2 normalizer)
  float luma = dot(pixel, vec4(0.299, 0.587, 0.114, 0.0));
  vec4 result = texture2D(table, vec2(normalizer.x * luma + normalizer.y, 0.5));
  result.a = pixel.a;
  return result;
10.11
PDF417OptionMessageDataIsCodeWordData
PDF417OptionCompactionMode
PDF417OptionUseCompactStyle
PDF417OptionErrorCorrectionLevel
PDF417OptionAlwaysSpecifyCompaction
PDF417OptionDataColumns
PDF417OptionRows
PDF417OptionMinWidth
PDF417OptionMaxWidth
PDF417OptionMinHeight
PDF417OptionMaxHeight
PDF417OptionPreferredAspectRatio
CGImageRef PDF417CreateBarcodeImage(NSData *, NSDictionary *, NSError **)
<Unknown Function>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/Barcodes/PDF417.m
<Unknown File>
Invalid parameter not satisfying: %@
message != nil
When supplying a raw message payload, the data columns and rows must also be specified
Message codeword payload must contain a symbol length descriptor codeword
Message codeword payload is too small for symbol length descriptor codeword.
Symbol matrix is too small for specified parameters with supplied message codeword payload
Symbol matrix dimensions and supplied message codewords imply an invalid error correction level
Specified PDF417 symbol matrix is too large
Message is longer than is supportable by barcode format.
com.apple.pdf417
Specified %@, %ld, is less than the minimum, %ld.
Specified %@, %ld, is greater than the maximum, %ld.
NSInteger ErrorCorrectionCodeWordCountForLevel(NSInteger)
Error correction level must be between 0 and 8!
;<>@[\]_`~!
-.$/"|*()?{}'
int EmitCodeWordsWithTextCompactionMode(NSData *, int, int, NSMutableData *, int)_block_invoke
cannot flush an odd number of half code words
v12@?0c4i8
Message cannot be encoded with PDF417CompactionModeText because it contains character '%d'
Message cannot be encoded with PDF417CompactionModeNumeric because it contains character '%d'
It is not possible to encode a message this long with the recommended level of error correction
Unable to fit message into space available!
-[CIBarcodeGenerator outputCGImageForQRCodeDescriptor]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/Barcodes/CIBarcode.m
0 && "unreachable"
-[CIBarcodeGenerator outputCGImageForAztecCodeDescriptor]
-[CIBarcodeGenerator outputCGImageForPDF417CodeDescriptor]
-[CIBarcodeGenerator outputCGImage]
inputBarcodeDescriptor
T@"CIBarcodeDescriptor",C,N,VinputBarcodeDescriptor
inputMessage
T@"NSData",C,N,VinputMessage
inputCorrectionLevel
inputOptions
QRCodeOptionErrorCorrectionLevel
CIQRCodeGenerator filter requires NSData for inputMessage
CIQRCodeGenerator filter requires L, M, Q, or H for inputCorrectionLevel
T@"NSString",C,N,VinputCorrectionLevel
inputLayers
inputCompactStyle
AztecOptionErrorCorrectionPercentage
AztecOptionLayers
AztecOptionUseCompactStyle
CIAztecCodeGenerator filter requires NSData for inputMessage
CIAztecCodeGenerator filter requires nil or a number between 5 and 95 for inputCorrectionLevel
CIAztecCodeGenerator filter requires nil or a number between 1 and 32 for inputLayers
CIAztecCodeGenerator filter requires nil or @YES or @NO for inputCompactStyle
CIAztecCodeGenerator could not generate an image
T@"NSNumber",C,N,VinputCorrectionLevel
T@"NSNumber",C,N,VinputLayers
T@"NSNumber",C,N,VinputCompactStyle
inputMinWidth
inputMaxWidth
inputMinHeight
inputMaxHeight
inputDataColumns
inputRows
inputPreferredAspectRatio
inputCompactionMode
inputAlwaysSpecifyCompaction
CIPDF417BarcodeGenerator filter requires NSData for inputMessage
CIPDF417BarcodeGenerator could not generate an image
T@"NSNumber",C,N,VinputMinWidth
T@"NSNumber",C,N,VinputMaxWidth
T@"NSNumber",C,N,VinputMinHeight
T@"NSNumber",C,N,VinputMaxHeight
T@"NSNumber",C,N,VinputDataColumns
T@"NSNumber",C,N,VinputRows
T@"NSNumber",C,N,VinputPreferredAspectRatio
T@"NSNumber",C,N,VinputCompactionMode
T@"NSNumber",C,N,VinputAlwaysSpecifyCompaction
inputQuietSpace
inputBarcodeHeight
CICode128BarcodeGenerator filter requires NSData for inputMessage
CICode128BarcodeGenerator could not generate an image
T@"NSNumber",C,N,VinputQuietSpace
T@"NSNumber",C,N,VinputBarcodeHeight
ThumbnailCluster - adding %s
[CIBurstThumbnailCluster initWithImageData] : metadata parsing error
[CIBurstThumbnailCluster initWithImageData] : no error
burstImages
T@"NSMutableArray",VburstImages
imageProps
T@"NSMutableDictionary",VimageProps
T@"CIBurstYUVImage",Vimage
completionBlock
T@?,VcompletionBlock
kernel vec4 _crystallize(sampler src, sampler noise, vec2 cellSize, vec2 offset)
  float tSize = 256.;
  vec4 u1, u2, u3, u4;
  vec2 t0 = destCoord();
  vec2 cellCorner = (floor(t0 * cellSize.y - 0.5) + 0.5) * cellSize.x + 0.5;
  vec2 t1 = cellCorner * cellSize.y + offset;
  t1 = t1 + vec2(-.5,-.5);
  vec2 t2 = t1 + vec2(1.0, 0.0);
  vec2 t3 = t1 + vec2(0.0, 1.0);
  vec2 t4 = t1 + vec2(1.0, 1.0);
  vec4 c1 = sample(noise, samplerTransform(noise, mod(t1, tSize)));
  vec4 c2 = sample(noise, samplerTransform(noise, mod(t2, tSize)));
  vec4 c3 = sample(noise, samplerTransform(noise, mod(t3, tSize)));
  vec4 c4 = sample(noise, samplerTransform(noise, mod(t4, tSize)));
  u1.xy = cellCorner;
  u2.xy = u1.xy + vec2(cellSize.x, 0.0);
  u3.xy = u1.xy + vec2(0.0, cellSize.x);
  u4.xy = u1.xy + vec2(cellSize.x, cellSize.x);
  float cellSize3 = cellSize.x * 0.65;
  u1.xy += (c1.rg - 0.5) * cellSize3;
  u2.xy += (c2.rg - 0.5) * cellSize3;
  u3.xy += (c3.rg - 0.5) * cellSize3;
  u4.xy += (c4.rg - 0.5) * cellSize3;
  vec2 d0 = t0 - u1.xy;
  u1.z = dot(d0,d0);
  d0 = t0 - u2.xy;
  u2.z = dot(d0,d0);
  d0 = t0 - u3.xy;
  u3.z = dot(d0,d0);
  d0 = t0 - u4.xy;
  u4.z = dot(d0,d0);
  vec4 desc = vec4(u1.z - u2.z);
  vec4 v1 = compare(desc, u1, u2);
  vec4 v2 = compare(desc, u2, u1);
  desc = vec4(u3.z - u4.z);
  vec4 v3 = compare(desc, u3, u4);
  vec4 v4 = compare(desc, u4, u3);
  desc = vec4(v1.z - v3.z);
  u1 = compare(desc, v1, v3);
  u2 = compare(desc, v3, v1);
  desc = vec4(v2.z - v4.z);
  u3 = compare(desc, v2, v4);
  desc = vec4(u2.z - u3.z);
  u2 = compare(desc, u2, u3);
  float alpha = clamp((sqrt(u2.z) - sqrt(u1.z)) * 0.5 + 0.5, 0.0, 1.0);
  vec4 p1 = sample(src, samplerTransform(src, u1.xy));
  vec4 p2 = sample(src, samplerTransform(src, u2.xy));
  return mix(p2, p1, alpha);
kernel vec4 _pass3(__sample c0, __sample c1, __sample c2, float sel) { return sel < 1.0 ? c0 : sel < 2.0 ? c1 : c2; } 
inputImage1
T@"CIImage",&,VinputImage1
T@"CIImage",&,VinputImage2
inputSelected
T@"NSNumber",C,N,VinputSelected
kernel vec4 _passThroughColor (__sample s) { return s; }
kernel vec2 _passThroughWarp () { return destCoord(); }
kernel vec4 _passThroughGeneral (sampler s)
{ return sample(s, samplerCoord(s)); }
kernel vec4 _passThroughGeneralAlt (sampler s, float v)
{ return sample(s, samplerCoord(s)+v); }
Error: bitAt parameter index out of range
Error: bitAppendBit bad bit
Error: bitAppendBits num bits must be between 0 and 32
Error: bitXor bitVector sizes don't match
Error: byteArrayAt ByteArray is NULL
Error: byteArraySetIndex ByteArray is NULL
Error: byteArraySetSource ByteArray is NULL
Error: byteMatrixInitWithSizes ByteMatrix is NULL
Shift_JIS
Error: initQRCodeForInputByteSize cannot find proper rs block info (input data too big?)
Error: data bits cannot fit in the QR Code
Error: terminateBits number of bits is not a multiple of 8
Error: terminateBits bits size does not equal capacity
Error: getNumDataBytesAndNumECBytesForBlockID block ID too large
Error: getNumDataBytesAndNumECBytesForBlockID EC bytes mismatch
Error: getNumDataBytesAndNumECBytesForBlockID total bytes mismatch
Error: interleaveWithECBytes number of bits and data bytes does not match
Error: interleaveWithECBytes memory allocation failed
Error: interleaveWithECBytes data bytes does not match offset
Error: interleaveWithECBytes interleaving error
Error: appendLengthInfo %d is bigger than %d
Error: appendBytes invalid mode
Error: appendAlphanumericBytes appendAlphanumericBytes
Error: invalid byte sequence
ISO-8859-1
BYTE
Cp437
ISO8859_1
ISO-8859_1
ISO8859_2
ISO8859_3
ISO8859_4
ISO8859_5
ISO8859_6
ISO8859_7
ISO8859_8
ISO8859_9
ISO8859_10
ISO8859_11
ISO8859_13
ISO8859_14
ISO8859_15
ISO8859_16
SJIS
Error: _createQRCodeWithFullDescription invalid QR code
KANJI
ALPHANUMERIC
NUMERIC
Error: embedPositionDetectionPattern the matrix element should be empty
Error: embedHorizontalSeparationPattern the matrix element should be empty
Error: the matrix element should be empty
Error: embedDarkDotAtLeftBottomCorner matrix element wrong value
Error: embedTimingPatternsMatrix matrix element invalid value
Error: makeTypeInfoBitsErrorCorrectionLevel invalid mask pattern
Error: makeTypeInfoBitsErrorCorrectionLevel should not happen but we got: %d
Error: number should not be negative!
Error: makeVersionInfoBitsVersion should not happen but we got: %d
Error: embedDataBits not all bits consumed: %i / %i
Error: invalid mask pattern: %d
Error: getCharacterCountBits character count doesn't apply to this mode
Error: inverse argument error
Error: createMonomial arugment error
Error: fillPoly argument error
Error: polyCoefficient argument error
Error: multiplyByMonomial arugment error
Error: divide by 0
Error: encode no error correction bytes
Error: encode no data bytes provided
Error: versionForNumber version number is not between 0 and 40
kernel vec4 _blendGrains(__sample isoImages, float log10iso)
  vec4 c = isoImages; 
  float mix10_50    = mix(c.r, c.g, log10iso*1.43067655809 
                                           - 1.43067655809); 
  float mix50_400   = mix(c.g, c.b, log10iso*1.10730936496 
                                           - 1.88128539659); 
  float mix400_3200 = mix(c.b, c.a, log10iso*1.10730936496 
                                           - 2.88128539659); 
  float v = compare(log10iso - 1.69897000434,                     mix10_50,                     compare(log10iso - 2.60205999133,                             mix50_400,                             mix400_3200)); 
  return vec4(v,v,v,1.0);
kernel vec4 _grainBlendAndMix(__sample img, __sample grainImage, float contrast, float mixAmount)
  vec3 rgb = img.rgb;
  float luminance = clamp(dot(rgb, vec3(.333333)), 0.0, 1.0); 
  float gamma = 4.01 - 2.0*luminance;
  rgb = sign(rgb) * pow(abs(rgb), vec3(1.0/gamma));
  float grain = grainImage.r - 0.5;
  float mult = contrast * grain;
  rgb += (max(luminance, 0.5) * mult * (1.0-luminance));
  rgb = sign(rgb) * pow(abs(rgb), vec3(gamma));
  rgb = min(rgb, 1.0);
  return mix(img, vec4(rgb,img.a), mixAmount);
kernel vec2 _paddedTile2(vec4 k) { return fract(destCoord() * k.zw) * k.xy + vec2(1.0); }
noiseImage
T@"NSNumber",C,N,VinputISO
T@"NSNumber",C,N,VinputAmount
GLTexture %d
MTLTexture %p
 %dx%d
%@.%d
scube
com.apple.coreimage.photoEffectsIsolation
Cannot render image (with an input %s texture) using a %s context.
Metal
T@"NSNumber",&,N,VinputSigmaX
T@"NSNumber",&,N,VinputSigmaY
kernel vec4 _gaussianReduce4(sampler src, vec4 scale)
  vec2 d = destCoord() * scale.xy;
  vec4 q  = sample(src, samplerTransform(src, d));
  vec4 s  = q*0.249105655;
  vec2 o = vec2(1.95019665)*scale.zw;
  q  = sample(src, samplerTransform(src, d-o)) + sample(src, samplerTransform(src, d+o));
  s += q*0.204995265;
  o  = vec2(3.90137021)*scale.zw;
  q  = sample(src, samplerTransform(src, d-o)) + sample(src, samplerTransform(src, d+o));
  s += q*0.11422973;
  o  = vec2(5.85840079)*scale.zw;
  q  = sample(src, samplerTransform(src, d-o)) + sample(src, samplerTransform(src, d+o));
  s += q*0.0433552031;
  o  = vec2(7.86886245)*scale.zw;
  q  = sample(src, samplerTransform(src, d-o)) + sample(src, samplerTransform(src, d+o));
  s += q*0.0128669748;
  return s;
kernel vec4 _gaussianReduce2(sampler src, vec4 scale)
  vec2 d = destCoord() * scale.xy;
  vec2 o1 = vec2(1.84623909)*scale.zw;
  vec2 o2 = vec2(3.74518052)*scale.zw;
  vec4 q1  = sample(src, samplerTransform(src, d - o2));
  vec4 q2  = sample(src, samplerTransform(src, d - o1));
  vec4 q3  = sample(src, samplerTransform(src, d));
  q2 += sample(src, samplerTransform(src, d + o1));
  q1 += sample(src, samplerTransform(src, d + o2));
  return 0.432290834*q3 + 0.24061645*q2 + 0.0432381327*q1;
kernel vec4 _gaussianBlur19(sampler src, vec4 offset01, vec4 offset23, vec4 offset4, vec4 weight, vec4 weight2)
  vec2 d   = destCoord();
  vec4 q0  = sample(src, samplerTransform(src, d - offset4.xy));
  vec4 q1  = sample(src, samplerTransform(src, d - offset23.zw));
  vec4 q2  = sample(src, samplerTransform(src, d - offset23.xy));
  vec4 q3  = sample(src, samplerTransform(src, d - offset01.zw));
  vec4 q4  = sample(src, samplerTransform(src, d - offset01.xy));
  vec4 q5  = sample(src, samplerTransform(src, d + offset01.xy));
  vec4 q6  = sample(src, samplerTransform(src, d + offset01.zw));
  vec4 q7  = sample(src, samplerTransform(src, d + offset23.xy));
  vec4 q8  = sample(src, samplerTransform(src, d + offset23.zw));
  vec4 q9  = sample(src, samplerTransform(src, d + offset4.xy));
  return weight.x*(q4+q5) + weight.y*(q3+q6) + weight.z*(q2+q7) + weight.w*(q1+q8) + weight2.x*(q0+q9);
kernel vec4 _gaussianBlur15(sampler src, vec4 offset01, vec4 offset23, vec4 weight)
  vec2 d   = destCoord();
  vec4 q0  = sample(src, samplerTransform(src, d - offset23.zw));
  vec4 q1  = sample(src, samplerTransform(src, d - offset23.xy));
  vec4 q2  = sample(src, samplerTransform(src, d - offset01.zw));
  vec4 q3  = sample(src, samplerTransform(src, d - offset01.xy));
  vec4 q4  = sample(src, samplerTransform(src, d + offset01.xy));
  vec4 q5  = sample(src, samplerTransform(src, d + offset01.zw));
  vec4 q6  = sample(src, samplerTransform(src, d + offset23.xy));
  vec4 q7  = sample(src, samplerTransform(src, d + offset23.zw));
  return weight.x*(q3+q4) + weight.y*(q2+q5) + weight.z*(q1+q6) + weight.w*(q0+q7);
kernel vec4 _gaussianBlur11(sampler src, vec4 offset01, vec4 offset2, vec4 weight)
  vec2 d   = destCoord();
  vec4 q1  = sample(src, samplerTransform(src, d - offset2.xy));
  vec4 q2  = sample(src, samplerTransform(src, d - offset01.zw));
  vec4 q3  = sample(src, samplerTransform(src, d - offset01.xy));
  vec4 q4  = sample(src, samplerTransform(src, d + offset01.xy));
  vec4 q5  = sample(src, samplerTransform(src, d + offset01.zw));
  vec4 q6  = sample(src, samplerTransform(src, d + offset2.xy));
  return weight.x*(q3+q4) + weight.y*(q2+q5) + weight.z*(q1+q6);
kernel vec4 _gaussianBlur7(sampler src, vec4 offset01, vec4 weight)
  vec2 d   = destCoord();
  vec4 q2  = sample(src, samplerTransform(src, d - offset01.zw));
  vec4 q3  = sample(src, samplerTransform(src, d - offset01.xy));
  vec4 q4  = sample(src, samplerTransform(src, d + offset01.xy));
  vec4 q5  = sample(src, samplerTransform(src, d + offset01.zw));
  return weight.x*(q3+q4) + weight.y*(q2+q5);
kernel vec4 _gaussianBlur3(sampler src, vec4 offset0)
  vec2 d = destCoord();
  return (sample(src, samplerTransform(src, d - offset0.xy)) + sample(src, samplerTransform(src, d + offset0.xy))) * 0.5;
kernel vec4 _unsharpmask (__sample s, __sample b, float k) { s.rgb += (s.rgb - b.rgb * (s.a/max(b.a, 0.0001))) * k; return s; }
dividerScore
Tf,VdividerScore
trueLocalMaximum
Ti,VtrueLocalMaximum
leftImage
Ti,VleftImage
actionAmount
Tf,VactionAmount
noiseThreshold
Tf,VnoiseThreshold
highNoiseThreshold
Tf,VhighNoiseThreshold
noop_affine
noop_forced
noop_contextlimits
noop_multiuse
noop_samplemode
noop_disablemerging
AztecOptionMessageDataIsDataCodeWords
AztecOptionMessageCodeWordCount
%-15s %@
CGImageRef AztecCreateBarcodeImage(NSData *, NSDictionary *, NSError **)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/Barcodes/Aztec.m
msgData != nil
The message is too long for an Aztec barcode.
Number of message codewords must be less than the number of symbol codewords.
Insufficient message data supplied for Aztec symbol with explicit geometry
Head
%@ '%c'
NumStates (bad value?)
<unknown state>
Latch %@->%@
Shift %@->%@
<null two char punc val>
P 'CR' 'LF'
P '.' ' '
P ',' ' '
P ':' ' '
<unknown two char punc>
len %d
com.apple.aztec
Specified %@, %d, is less than the minimum, %d.
Specified %@, %d, is greater than the maximum, %d.
len:%ld seq:
CreateSeqEntryPool
initialCapacity > 0
AztecDebugSequence
%@=%@
The message doesn't fit into the specified number of layers, %d.
The message is too large for an Aztec barcode.
The message does not fit into the space allocated in the barcode.
i12@?0i4i8
i8@?0i4
v12@?0i4i8
v16@?0i4i8B12
com.apple.coreimage.halftoneKernelIsolation
kernel vec4 _dotscreen (__sample s, vec3 params, vec4 mtx)
  vec2 pt = destCoord() - params.xy;
  pt = vec2(dot(pt, mtx.xy), dot(pt, mtx.zw));
  pt = fract(pt + params.xy) * 6.2831853;
  float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / params.z) + 0.5;
  float l = dot(s.rgb, vec3(0.2125, 0.7154, 0.0721));
  s.rgb = vec3(clamp((l - g) * params.z + 0.5, 0.0, 1.0) * s.a);
  return s;
kernel vec4 _hatchedscreen (__sample s, vec3 params, vec4 mtx)
  vec2 pt = destCoord() - params.xy;
  pt = vec2(dot(pt, mtx.xy), dot(pt, mtx.zw));
  pt = fract(pt.xy + params.xy);
  pt = min(vec2(1.0) - pt, pt) * 2.0;
  float g = min(pt.x, pt.y * .5 + .5);
  float l = dot(s.xyz, vec3(.2125, .7154, .0721));
  s.rgb = vec3(clamp((l - g) * params.z + 0.5, 0.0, 1.0) * s.a);
  return s;
kernel vec4 _linescreen (__sample s, vec3 params, vec4 mtx)
  vec2 pt = destCoord() - params.xy;
  pt = vec2(dot(pt, mtx.xy), dot(pt, mtx.zw));
  pt = fract(pt.xy + params.xy);
  float g = min(1.0 - pt.x, pt.x) * 2.0;
  float l = dot(s.xyz, vec3(.2125, .7154, .0721));
  s.rgb = vec3(clamp((l - g) * params.z + 0.5, 0.0, 1.0) * s.a);
  return s;
kernel vec4 _circularscreen (__sample s, vec4 params)
  float d = length(destCoord() - params.xy);
  d = fract(d * params.z);
  d = min(1.0 - d, d);
  d = dot(s.rgb, vec3(.2125, .7154, .0721)) - d * 2.0;
  d = clamp(d * params.w + .5, 0.0, 1.0);
  s.rgb = vec3(d) * s.a;
  return s;
kernel vec4 _bloom (__sample s, __sample b, float k) { return mix(s, max(s,b), k); }
kernel vec4 _gloom (__sample s, __sample b, float k) { return mix(s, min(s,b), k); }
inputLevels
kernel vec4 _colorPosterize (__sample src, vec2 factors)
  src.rgb = floor(src.rgb * factors.x + 0.5) * factors.y;
  return src;
T@"NSNumber",&,N,VinputLevels
kernel vec4 _edges(sampler src, float scale)
  vec2 dc = destCoord();
  vec4 r0 = sample (src, samplerTransform(src, dc + vec2(0.0,-1.0)));
  vec4 r3 = sample (src, samplerTransform(src, dc + vec2(1.0,-1.0)));
  vec4 r2 = sample (src, samplerTransform(src, dc + vec2(1.0, 0.0)));
  vec4 r1 = sample (src, samplerCoord(src));
  r3 = r1 - r3;
  r2 = r0 - r2;
  r2 = (r3 * r3 + r2 * r2) * scale;
  return vec4(r2.rgb, r1.a);
kernel vec4 _disolve (__sample src0, __sample src1, float factor) { return mix(src1, src0, factor); }
kernel vec4 _fadeDissolve (__sample src, float factor) { return src*factor; }
T@"CIImage",&,N,VinputTargetImage
T@"NSNumber",&,N,VinputTime
kernel vec4 _maskToAlpha (__sample src) { return src.yyyy; }
CI_METAL_SDOF
kContextInfoIsMetal
BlurMapSmoothing
DisparitySmoothing
Rendering
faces.%@
kernel vec4 _convertDepthOrDisparity(__sample s) 
  __attribute__((outputFormat(kCIFormatRh)))
{ return vec4(1.0/max(s.r,1e-6), s.gba); }
inputAperture
inputLeftEyePosition
inputRightEyePosition
inputChinPosition
inputFaceMidPoint
inputCalibrationData
inputAuxDataMetadata
CGImageMetadataRef
inputOriginalSize
CIDisparitySmoothing
CI_DISPARITY_SDOF_HISTOGRAM
CILensModelCalculatorNative
inputMinMaxImage
CILensModelApply
inputCalculatorValuesImage
inputIntrinsicMatrixFocalLength
inputFacesLeftEyeX
inputFacesLeftEyeY
inputFacesCenterX
inputFacesCenterY
inputFacesRightEyeX
inputFacesRightEyeY
inputFacesChinX
inputFacesChinY
inputFacesMaxBlurOnEyes
maxBlurOnEyes
inputFacesMaxBlurDistFromFocus
maxBlurDistFromFocus
inputFacesEyeToEyebrowRatio
eyeToEyebrowRatio
inputFacesLinearBlurGrowthM
linearBlurGrowthM
inputFacesLinearBlurGrowthC
linearBlurGrowthC
inputFacesDistToBlurScaling
distToBlurScaling
inputFacesCapMultip
capMultip
inputFacesGainMultip
gainMultip
CIFaceMaskCalculator
inputParameterImage
CIFaceMaskApply
CIBlurmapSmoothing
inputShiftmapImage
T@"CIImage",&,VinputShiftmapImage
T@"NSNumber",C,N,VinputAperture
T@"CIVector",&,N,VinputLeftEyePosition
T@"CIVector",&,N,VinputRightEyePosition
T@"CIVector",&,N,VinputChinPosition
T@"CIVector",&,N,VinputFaceMidPoint
T@"CIVector",&,N,VinputFocusRect
T@"AVCameraCalibrationData",&,N,VinputCalibrationData
T@,&,N,VinputAuxDataMetadata
CIPortraitBlur
inputBlurMap
T@"CIImage",&,VinputBlurMap
inputLeftEyePositions
inputRightEyePositions
inputChinPositions
inputNosePositions
NSDictionary
inputShiftMin
inputShiftMax
inputUseMipmaps
inputUseNativeImage
inputUseNormalizedDisparity
-[CIDepthBlurEffect outputImage]
lumaNoiseScale
T@"NSNumber",&,N,VinputAperture
T@"NSNumber",&,N,VinputLumaNoiseScale
T@"CIVector",&,N,VinputLeftEyePositions
T@"CIVector",&,N,VinputRightEyePositions
T@"CIVector",&,N,VinputChinPositions
T@"CIVector",&,N,VinputNosePositions
T@"AVCameraCalibrationData",C,N,VinputCalibrationData
<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"> <plist version="1.0"> <dict> <key>DisparitySmoothing</key> <dict> <key>nIterations</key> <real>2</real> </dict> <key>NoiseEstimation</key> <dict> <key>HDR</key> <dict> <key>GainLevels</key> <array> <real>0.0</real> <real>1</real> <real>2</real> <real>4</real> <real>8</real> <real>16</real> <real>32</real> <real>64</real> </array> <key>NoiseLevels</key> <array> <real>0.0070000000000000001</real> <real>0.01</real> <real>0.014999999999999999</real> <real>0.017999999999999999</real> <real>0.02</real> <real>0.021999999999999999</real> <real>0.023</real> <real>0.025000000000000001</real> </array> </dict> <key>OIS</key> <dict> <key>GainLevels</key> <array> <real>0.0</real> <real>1</real> <real>2</real> <real>4</real> <real>8</real> <real>16</real> <real>32</real> <real>64</real> </array> <key>NoiseLevels</key> <array> <real>0.0070000000000000001</real> <real>0.01</real> <real>0.014999999999999999</real> <real>0.017999999999999999</real> <real>0.02</real> <real>0.021999999999999999</real> <real>0.023</real> <real>0.025000000000000001</real> </array> </dict> <key>SIS</key> <dict> <key>GainLevels</key> <array> <real>0.0</real> <real>1</real> <real>2</real> <real>4</real> <real>8</real> <real>16</real> <real>32</real> <real>64</real> </array> <key>NoiseLevels</key> <array> <real>0.0070000000000000001</real> <real>0.01</real> <real>0.014999999999999999</real> <real>0.017999999999999999</real> <real>0.02</real> <real>0.021999999999999999</real> <real>0.023</real> <real>0.025000000000000001</real> </array> </dict> <key>SingleImage</key> <dict> <key>GainLevels</key> <array> <real>0.0</real> <real>1</real> <real>2</real> <real>4</real> <real>8</real> <real>16</real> <real>32</real> <real>64</real> </array> <key>NoiseLevels</key> <array> <real>0.0050000000000000001</real> <real>0.0050000000000000001</real> <real>0.0070000000000000001</real> <real>0.01</real> <real>0.014999999999999999</real> <real>0.02</real> <real>0.028000000000000001</real> <real>0.033000000000000002</real> </array> </dict> </dict> <key>Rendering</key> <dict> <key>antiAliasBlurStrength</key> <real>0.15</real> <key>basePixelWeight</key> <real>9.9999999999999998e-13</real> <key>faces.capMultip</key> <real>1</real> <key>faces.chinThetaLimit</key> <real>1</real> <key>faces.chinThetaMultip</key> <real>1</real> <key>faces.chinVectorSnapping</key> <real>0.5</real> <key>faces.distToBlurScaling</key> <real>0.090999999999999998</real> <key>faces.eyeToEyebrowRatio</key> <real>1.3999999999999999</real> <key>faces.gainMultip</key> <real>1</real> <key>faces.linearBlurGrowthC</key> <real>0.00027901</real> <key>faces.linearBlurGrowthM</key> <real>0.01</real> <key>faces.maxBlurDistFromFocus</key> <real>0.00074405000000000001</real> <key>faces.maxBlurOnEyes</key> <real>0.0022000000000000001</real> <key>highlightBoostGain</key> <real>0.5</real> <key>lumaNoiseModelCoeff</key> <real>0.9</real> <key>lumaNoiseScale</key> <real>0.0025000000000000001</real> <key>maxBlur</key> <real>0.029999999999999999</real> <key>nSamples</key> <real>100</real> <key>relativeWeightThreshold</key> <real>0.0063120187260210497</real> <key>sharpRadius</key> <real>0.25</real> <key>softRadius</key> <real>1.5</real> <key>spatialWeightSoftMax</key> <real>1.05</real> <key>spatialWeightSoftMin</key> <real>0.94999999999999996</real> </dict> <key>SLM</key> <dict> <key>fallbackFocusROI_height</key> <real>0.10000000000000001</real> <key>fallbackFocusROI_left</key> <real>0.45000000000000001</real> <key>fallbackFocusROI_top</key> <real>0.45000000000000001</real> <key>fallbackFocusROI_width</key> <real>0.10000000000000001</real> <key>maxFGBlur</key> <real>0.00020000000000000001</real> <key>shiftDeadZone</key> <real>0.29999999999999999</real> <key>simulatedAperture</key> <real>4.5</real> <key>zeroShiftPercentile</key> <real>0.75</real> </dict> <key>BlurMapSmoothing</key> <dict> <key>nIterations</key> <real>5</real> <key>originalBlurValueT0</key> <real>0.2</real> <key>originalBlurValueT1</key> <real>0.5</real> <key>localMinimumBlurValueT0</key> <real>0.05</real> <key>localMinimumBlurValueT1</key> <real>0.3</real> </dict> </dict> </plist>
SDOFParameterValue_block_invoke
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/PortraitBlur/CIsDOF.m
sdofParameters
SDOFParameterValue
value
depthBlurEffect:RenderingParameters
shiftDeadZone
faces.linearBlurGrowthC
faces.linearBlurGrowthM
faces.distToBlurScaling
faces.eyeToEyebrowRatio
simulatedAperture
depthBlurEffect:SimulatedAperture
kernel vec2 _pixellate (vec2 c, vec2 params) { return (floor((destCoord() - c) * params.x) + 0.5) * params.y + c; }
kernel vec4 _hexagonalPixellate(sampler src, vec2 center, vec2 skew_to_unit, vec2 unit_to_skew, float sqrt3inv)
  vec2 t0 = destCoord() - center;
  vec2 t0_skewed = t0;
  t0_skewed.x -= t0_skewed.y * sqrt3inv;
  vec2 t0_unit = t0_skewed * skew_to_unit;
  vec2 t0_slot = floor(t0_unit);
  vec2 t0_offset = t0_unit - t0_slot;
  vec2 t0_base = t0_slot * unit_to_skew;
  vec2 p0 = t0_base;
  vec2 p1 = t0_base;
  p1.y = p1.y + unit_to_skew.y;
  vec2 p2 = t0_base;
  p2.x = p2.x + unit_to_skew.x;
  vec2 p3 = t0_base + unit_to_skew;
  p0 = compare(vec2(t0_offset.x + t0_offset.y - 1.0), p0, p3);
  p0.x += p0.y * sqrt3inv;
  p1.x += p1.y * sqrt3inv;
  p2.x += p2.y * sqrt3inv;
  vec2 d0 = t0 - p0;
  d0 = d0 * d0;
  float d1 = d0.x + d0.y;
  vec3 s0 = vec3(p0, d1 * inversesqrt(d1));
  d0 = t0 - p1;
  d0 = d0 * d0;
  d1 = d0.x + d0.y;
  vec3 s1 = vec3(p1, d1 * inversesqrt(d1));
  d0 = t0 - p2;
  d0 = d0 * d0;
  d1 = d0.x + d0.y;
  vec3 s2 = vec3(p2, d1 * inversesqrt(d1));
  vec3 desc = vec3(s0.z - s1.z);
  vec3 s3 = compare(desc, s0, s1);
  vec3 s4 = compare(desc, s1, s0);
  desc = vec3(s3.z - s4.z);
  vec3 s5 = compare(desc, s3, s2);
  vec3 s6 = compare(desc, s2, s3);
  desc = vec3(s4.z - s6.z);
  vec3 s7 = compare(desc, s4, s6);
  vec4 c0 = sample(src, samplerTransform(src, s5.xy + center));
  vec4 c1 = sample(src, samplerTransform(src, s7.xy + center));
  return mix(c0, c1, clamp((s5.z - s7.z) * 0.5 + 0.5, 0.0, 1.0));
kernel vec4 _sharpenLuminance(__sample ip, __sample bl, float s)
  vec3 luminance = vec3(0.299, 0.587, 0.114);
  vec3 invLuminance = vec3(1.0, -0.5093696763, -0.1942078365);
  float intensity = 1.0 + s;
  vec3  s0,s1;
  s0.x  = dot(luminance, bl.rgb);
  s0.yz = bl.rb - s0.x;
  s1.x  = dot(luminance, ip.rgb);
  s1.yz = ip.rb - s1.x;
  s0    = mix(s0,s1, intensity);
  ip.g  = dot(invLuminance, s0);
  ip.rb = s0.yz + s0.x;
  return ip;
inputOpacity
kernel vec4 _swipeTransition(__sample src0, __sample src1, __color color, vec4 parms)
  float k1 = clamp(dot(vec4(destCoord(), 1.0, 0.0), parms), 0.0, 1.0);
  float k0 = min(1.0-k1, k1) * 2.0 * parms.w;
  return mix(mix(src1, src0, k1), color, k0);
T@"NSNumber",&,N,VinputOpacity
construct_fragment_shader
build_dag
enqueueForRect
compute_quad
release_resources
sync_render_completion
CI_PRINT_TIME 
%s = %.1f ms
~Timer
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/misc/CITimer.cpp
atomic_load(&sLogLevel) > 0
T@"NSNumber",&,N,VinputWeights
kernel vec4 _max3x3 (sampler s, vec4 d)
    vec2 p = destCoord ();
    vec4 c =   sample(s, samplerTransform(s, p - d.yy));
    c = max(c, sample(s, samplerTransform(s, p - d.wx)));
    c = max(c, sample(s, samplerTransform(s, p + d.yz)));
    c = max(c, sample(s, samplerTransform(s, p - d.xw)));
    c = max(c, sample(s, samplerTransform(s, p       )));
    c = max(c, sample(s, samplerTransform(s, p + d.xw)));
    c = max(c, sample(s, samplerTransform(s, p - d.yz)));
    c = max(c, sample(s, samplerTransform(s, p + d.wx)));
    c = max(c, sample(s, samplerTransform(s, p + d.yy)));
    return c;
kernel vec4 _min3x3 (sampler s, vec4 d)
    vec2 p = destCoord ();
    vec4 c =   sample(s, samplerTransform(s, p - d.yy));
    c = min(c, sample(s, samplerTransform(s, p - d.wx)));
    c = min(c, sample(s, samplerTransform(s, p + d.yz)));
    c = min(c, sample(s, samplerTransform(s, p - d.xw)));
    c = min(c, sample(s, samplerTransform(s, p       )));
    c = min(c, sample(s, samplerTransform(s, p + d.xw)));
    c = min(c, sample(s, samplerTransform(s, p - d.yz)));
    c = min(c, sample(s, samplerTransform(s, p + d.wx)));
    c = min(c, sample(s, samplerTransform(s, p + d.yy)));
    return c;
kernel vec4 _gradient (__sample sMax, __sample sMin)
  return vec4( (sMax.rgb - sMin.rgb) * .5, sMax.a);
kernel vec4 _laplacian (__sample s, __sample sMax, __sample sMin)
  return vec4( (sMax.rgb + sMin.rgb - 2.0 * s.rgb) * .5, s.a);
kernel vec4 _average (__sample s0, __sample s1, float w)
  return mix(s0, s1, w);
/System/Library/PrivateFrameworks/Quagga.framework
Unable to load Quagga from %s
ACBSConfigCreate
ACBSConfigFree
ACBSConfigSetMaxQRModuleSamples
ACBSCreateFrameInfoBySearchingForBarcodesInCVPixelBuffer
ACBSConfigSetSymbologiesEnabled
ACBSCreateSymbolDescriptorFromBasicDescriptorWithDefaultPayloadEncoding
SymbolDescriptionArray
CodeProperties
CodeLocation
ErrorCorrectionLevel
BarcodeRawData
BarcodeString
BarcodeType
QRMASK
SymbolVersion
2.006 -   May 13, 2015
1.021 - Aug 1, 2013
BurstSet_AlgorithmVersion
Image_ISPFacesArray
Image_ImageScore
Image_Timestamp
Image_YUVData
ImageYUVWidth
ImageYUVHeight
ImageYData
ImageUVData
ImageYUVBytesPerRow
Image_TimeReceived
Image_TimeQueued
Image_TimeConverted
Image_TimeStartedAnalysis
Image_TimeStartedFaceDetection
Image_TimeDoneFaceDetection
Image_TimeDoneFaceBlinkDetection
Image_TimeDoneFaceFocusScore
Image_TimeDoneAnalysis
ImageFace_ID
ImageFaceX
ImageFaceY
ImageFaceW
ImageFaceH
ImageFaceFocusScore
ImageFaceLeftEyeOpen
ImageFaceRightEyeOpen
ImageFaceSmiling
ImageFaceLeftEyePosX
ImageFaceLeftEyePosY
ImageFaceRightEyePosX
ImageFaceRightEyePosY
ImageFaceTimestamp
ImageFaceRollAngle
ImageFaceYawAngle
ImageFaceLeftEyeBlinkScore
ImageFaceRightEyeBlinkScore
ImageFaceSmileScore
ImageFaceSmallFace
ImageSet_Version
ImageSetVersion_Default
ImageSetVersion_Latest
BurstSet_TimeDoneCapturing
BurstSet_TimeDone
BurstSet_Setting_MaxNumPendingFrames
BurstSet_Setting_DisableAnalysis
BurstSet_Setting_DisableFaceCore
BurstSet_Setting_DummyAnalysisCount
BurstSet_Setting_ForceFaceDetection
BurstSet_Setting_EnableDumpYUV
BurstSet_IsAction
BurstSet_IsPortrait
BurstSet_CoverImage
BURST ANALYSIS VERSION = %s (%s)
   initWithBurstImageSet - Error: stats not found
fosl_filter_interface_version
fosl_filter_kernelpool_createPool
fosl_filter_kernelpool_hasError
fosl_filter_kernelpool_addLibrary
fosl_filter_kernelpool_addString
fosl_filter_kernelpool_destroyPool
fosl_filter_kernelpool_getNumKernels
fosl_filter_kernelpool_lookupKernel
fosl_filter_kernelpool_getKernelByIdx
fosl_filter_kernelpool_getNumDiagnostics
fosl_filter_kernelpool_getDiagnosticByIdx
fosl_filter_kernelpool_getKernelKind
fosl_filter_kernelpool_getKernelName
fosl_filter_kernelpool_getPrintedKernel
fosl_filter_kernelpool_getKernelDimensionality
fosl_filter_kernelpool_isPositionInvariant
fosl_filter_kernelpool_preservesAlpha
fosl_filter_kernelpool_getNumKernelParameters
fosl_filter_kernelpool_getParamName
fosl_filter_kernelpool_getParamType
fosl_filter_kernelpool_getNumKernelAttributes
fosl_filter_kernelpool_getAttributeKeyword
fosl_filter_kernelpool_getAttributeParameters
fosl_filter_kernelpool_hasAttributeParameters
fosl_filter_createGraph
fosl_filter_assignRoot
fosl_filter_destroyGraph
fosl_filter_createKernel
fosl_filter_addLibraryFunction
fosl_filter_addChild
fosl_filter_createImage
fosl_filter_createUniform
fosl_filter_createConstant
fosl_filter_createTransformMatrix
fosl_filter_createSampleTransform
fosl_filter_createUsePosition
fosl_filter_createPositionUpdate
fosl_filter_createCoordinateTransform
fosl_filter_setPositionUpdatePosition
fosl_filter_setPositionUpdateContinuation
fosl_filter_parseNodesInGraph
fosl_filter_synthesizeMainInGraph
fosl_filter_synthesizeMainInGraphOfType
fosl_filter_synthesizeMainInGraphOfTypeWithOptions
fosl_filter_dumpGraph
fosl_filter_printGraph
fosl_filter_getStringForGraph
fosl_filter_getStringForGraphWithOptions
fosl_filter_createReadPixel
/usr/lib/libFosl_dynamic.dylib
IPHONE_SIMULATOR_ROOT
Core Image Fosl wrapper: Unable to determine iPhone simulator root SDK path.
%s%s
Unable to open Fosl library at path %s
foslFunctions
kernel vec2 _holeDistortion (vec2 center, float radius2)
  vec2 delta = destCoord() - center;
  float dist2 = dot(delta,delta);
  return (dist2 <= radius2) ? center : (destCoord() - delta * radius2 / dist2);
kernel vec4 _holeAntialias(__sample src, vec2 center, float radius)
  return src * clamp(length(destCoord() - center) - radius, 0.0, 1.0);
kernel vec4 _box4(sampler src)
  vec2 d   = destCoord() * 4.0;
  vec4 q0  = sample(src, samplerTransform(src, d + vec2(-1.0, -1.0)));
  vec4 q1  = sample(src, samplerTransform(src, d + vec2(-1.0, +1.0)));
  vec4 q2  = sample(src, samplerTransform(src, d + vec2(+1.0, -1.0)));
  vec4 q3  = sample(src, samplerTransform(src, d + vec2(+1.0, +1.0)));
  return 0.25*(q0+q1+q2+q3);
kernel vec4 _box6(sampler src)
  vec2 d   = destCoord() * 6.0;
  vec4 q0  = sample(src, samplerTransform(src, d + vec2(-2.0, -2.0)));
  vec4 q1  = sample(src, samplerTransform(src, d + vec2( 0.0, -2.0)));
  vec4 q2  = sample(src, samplerTransform(src, d + vec2(+2.0, -2.0)));
  vec4 q3  = sample(src, samplerTransform(src, d + vec2(-2.0,  0.0)));
  vec4 q4  = sample(src, samplerTransform(src, d + vec2( 0.0,  0.0)));
  vec4 q5  = sample(src, samplerTransform(src, d + vec2(+2.0,  0.0)));
  vec4 q6  = sample(src, samplerTransform(src, d + vec2(-2.0, +2.0)));
  vec4 q7  = sample(src, samplerTransform(src, d + vec2( 0.0, +2.0)));
  vec4 q8  = sample(src, samplerTransform(src, d + vec2(+2.0, +2.0)));
  return (1.0/9.0)*(q0+q1+q2+q3+q4+q5+q6+q7+q8);
kernel vec4 _cross4(sampler src, float weight)
  vec2 d   = destCoord();
  vec4 q0  = sample(src, samplerTransform(src, d));
  vec4 q1  = sample(src, samplerTransform(src, d - vec2(+0.5, +1.5)));
  vec4 q2  = sample(src, samplerTransform(src, d + vec2(+0.5, +1.5)));
  vec4 q3  = sample(src, samplerTransform(src, d - vec2(+1.5, -0.5)));
  vec4 q4  = sample(src, samplerTransform(src, d + vec2(+1.5, -0.5)));
  q1  = 0.23*(q1+q2+q3+q4) + 0.08*q0;
  return mix(q0,q1, weight);
kernel vec4 _minimumComponent (__sample s) { return vec4(vec3(min(min(s.r,s.g),s.b)), s.a); }
kernel vec4 _maximumComponent (__sample s) { return vec4(vec3(max(max(s.r,s.g),s.b)), s.a); }
kernel vec2 _vortexDistortion(vec2 center, vec2 params)
  vec2 d = destCoord() - center;
  float len = length(d);
  float r = len * params.x - 1.0;
  float a = r * r * params.y / len;
  vec2 sc = vec2(cos(a), sin(a));
  vec2 p = vec2(dot(d, sc), dot(d, vec2(-sc.y, sc.x)));
  return (r >= 0.0) ? destCoord() : p+center;
kernel vec4 _lanczosDownBy2(sampler src, vec4 scale)
  vec2 d   = destCoord() * scale.xy;
  vec2 o0  = scale.zw * 0.732871;
  vec2 o1  = scale.zw * 2.83784;
  vec2 o2  = scale.zw * 4.6968;
  vec4 q0  = sample(src, samplerTransform(src, d - o2));
  vec4 q1  = sample(src, samplerTransform(src, d - o1));
  vec4 q2  = sample(src, samplerTransform(src, d - o0));
  vec4 q3  = sample(src, samplerTransform(src, d + o0));
  vec4 q4  = sample(src, samplerTransform(src, d + o1));
  vec4 q5  = sample(src, samplerTransform(src, d + o2));
  return (0.581891)*(q2+q3) + (-0.100636)*(q1+q4) + (0.0187453)*(q0+q5);
kernel vec4 _lanczosHorizontalUpsample(sampler src, float scale)
  vec4 w;
  vec2 c = destCoord();
  c.x = scale*c.x - 0.5;
  vec2 d = c;
  c.x = floor(c.x);
  float x = (c.x - d.x + 1.0);
  w.z = x*x*(x*(x*(x*-0.41086841 + 0.78286595) + 1.04059357) - 2.41189213) + 1.0;
  w.x = x*x*(x*(x*(x*-0.29216512 + 1.02524562) - 0.52422910) - 0.20885140);
  x = 1.0-x;
  w.y = x*x*(x*(x*(x*-0.41086841 + 0.78286595) + 1.04059357) - 2.41189213) + 1.0;
  w.w = 1.0 - w.x - w.y - w.z;
  vec4 p0  = sample(src, samplerTransform(src, c + vec2(-0.5,0.0)));
  vec4 p1  = sample(src, samplerTransform(src, c + vec2(+0.5,0.0)));
  vec4 p2  = sample(src, samplerTransform(src, c + vec2(+1.5,0.0)));
  vec4 p3  = sample(src, samplerTransform(src, c + vec2(+2.5,0.0)));
  return w.x*p0 + w.y*p1 + w.z*p2 + w.w*p3;
kernel vec4 _lanczosVerticalUpsample(sampler src, float scale)
  vec4    w;
  vec2 c   = destCoord();
  c.y = scale*c.y - 0.5;
  vec2 d   = c;
  c.y = floor(c.y);
  float x = (c.y - d.y + 1.0);
  w.z = x*x*(x*(x*(x*-0.41086841 + 0.78286595) + 1.04059357) - 2.41189213) + 1.0;
  w.x = x*x*(x*(x*(x*-0.29216512 + 1.02524562) - 0.52422910) - 0.20885140);
  x = 1.0-x;
  w.y = x*x*(x*(x*(x*-0.41086841 + 0.78286595) + 1.04059357) - 2.41189213) + 1.0;
  w.w = 1.0 - w.x - w.y - w.z;
  vec4 p0  = sample(src, samplerTransform(src, c + vec2(0.0,-0.5)));
  vec4 p1  = sample(src, samplerTransform(src, c + vec2(0.0,+0.5)));
  vec4 p2  = sample(src, samplerTransform(src, c + vec2(0.0,+1.5)));
  vec4 p3  = sample(src, samplerTransform(src, c + vec2(0.0,+2.5)));
  return w.y*p1 + w.z*p2 + w.x*p0 + w.w*p3;
kernel vec4 _blendWithMask (__sample f, __sample b, __sample m) { return mix(b,f,m.g); }
kernel vec4 _blendWithRedMask (__sample f, __sample b, __sample m) { return mix(b,f,m.r); }
kernel vec4 _blendWithBlueMask (__sample f, __sample b, __sample m) { return mix(b,f,m.b); }
kernel vec4 _blendWithAlphaMask (__sample f, __sample b, __sample m) { return mix(b,f,m.a); }
initWithCGImage: %dx%d
Ti,Vwidth
Ti,Vheight
Ti,VbytesPerRow
Ybuffer
T*,VYbuffer
Cbuffer
T*,VCbuffer
Kernel %@ should be of class CIColorKernel
mc00
mc01
mc02
mc10
mc11
mc12
mc20
mc21
mc22
bknd
btpnt
btwid
blamt
bamt
otrcS0
otrcS1
otrcS2
otrcS3
otrcS4
otrcY1
otrcY2
otrcY3
kernel vec4 _convertUsingColorMatrix(sampler src, vec4 rv, vec4 gv, vec4 bv) {
  vec4 pix, color;
  pix = sample(src, samplerCoord(src));
  color = pix.r * rv + pix.g * gv + pix.b * bv;
  color.a = pix.a;
  return color;
CIRAWGamutMapping: key %@ was not found in the RAW dictionary
kernel vec4 _localBoost(sampler src, vec4 breaks, vec4 coeffs1, vec4 coeffs2, vec4 coeffs3, vec4 coeffs4, float scaleAboveOne) {
  float x;
  vec4 color, powers, interval1, interval2, interval3, interval4, answer;
  color = sample(src, samplerCoord(src));
  x = color.r;
  powers.rgb = vec3(x);
  powers.rg = powers.rg * vec2(x);
  powers.r = powers.r * x;
  powers.a = 1.0;
  interval1.r = dot(powers, coeffs1);
  interval2.r = dot(powers, coeffs2);
  interval3.r = dot(powers, coeffs3);
  interval4.r = dot(powers, coeffs4);
  answer.r = (x - 1.0) * scaleAboveOne + 1.0;
  x = color.g;
  powers.rgb = vec3(x);
  powers.rg = powers.rg * vec2(x);
  powers.r = powers.r * x;
  powers.a = 1.0;
  interval1.g = dot(powers, coeffs1);
  interval2.g = dot(powers, coeffs2);
  interval3.g = dot(powers, coeffs3);
  interval4.g = dot(powers, coeffs4);
  answer.g = (x - 1.0) * scaleAboveOne + 1.0;
  x = color.b;
  powers.rgb = vec3(x);
  powers.rg = powers.rg * vec2(x);
  powers.r = powers.r * x;
  powers.a = 1.0;
  interval1.b = dot(powers, coeffs1);
  interval2.b = dot(powers, coeffs2);
  interval3.b = dot(powers, coeffs3);
  interval4.b = dot(powers, coeffs4);
  answer.b = (x - 1.0) * scaleAboveOne + 1.0;
  answer = compare(color - breaks.w, interval4, answer);
  answer = compare(color - breaks.z, interval3, answer);
  answer = compare(color - breaks.y, interval2, answer);
  answer = compare(color - breaks.x, interval1, answer);
  answer = compare(color, vec4(0.0), answer);
  answer.a = color.a;
  return answer;
kernel vec4 _boostRGB(sampler src, vec4 breaks, vec4 coeffs1, vec4 coeffs2, vec4 coeffs3, vec4 coeffs4, float scaleAboveOne) {
  float x;
  vec4 color, powers, interval1, interval2, interval3, interval4, answer;
  color = sample(src, samplerCoord(src));
  x = color.r;
  powers.rgb = vec3(x);
  powers.rg = powers.rg * vec2(x);
  powers.r = powers.r * x;
  powers.a = 1.0;
  interval1.r = dot(powers, coeffs1);
  interval2.r = dot(powers, coeffs2);
  interval3.r = dot(powers, coeffs3);
  interval4.r = dot(powers, coeffs4);
  answer.r = (x - 1.0) * scaleAboveOne + 1.0;
  x = color.g;
  powers.rgb = vec3(x);
  powers.rg = powers.rg * vec2(x);
  powers.r = powers.r * x;
  powers.a = 1.0;
  interval1.g = dot(powers, coeffs1);
  interval2.g = dot(powers, coeffs2);
  interval3.g = dot(powers, coeffs3);
  interval4.g = dot(powers, coeffs4);
  answer.g = (x - 1.0) * scaleAboveOne + 1.0;
  x = color.b;
  powers.rgb = vec3(x);
  powers.rg = powers.rg * vec2(x);
  powers.r = powers.r * x;
  powers.a = 1.0;
  interval1.b = dot(powers, coeffs1);
  interval2.b = dot(powers, coeffs2);
  interval3.b = dot(powers, coeffs3);
  interval4.b = dot(powers, coeffs4);
  answer.b = (x - 1.0) * scaleAboveOne + 1.0;
  answer = compare(color - breaks.w, interval4, answer);
  answer = compare(color - breaks.z, interval3, answer);
  answer = compare(color - breaks.y, interval2, answer);
  answer = compare(color - breaks.x, interval1, answer);
  answer = compare(color, vec4(0.0), answer);
  answer = compare(answer, vec4(0.0), answer);
  answer.a = color.a;
  return answer;
kernel vec4 _boostRGBLNoGamma(sampler src, vec4 breaks, vec4 coeffs1, vec4 coeffs2, vec4 coeffs3, vec4 coeffs4, float scaleAboveOne) {
   float x, luminance;
   vec4 color, powers, interval1, interval2, interval3, interval4, answer, xcolor;
   color = sample(src, samplerCoord(src));
   x = color.r;
   powers.rgb = vec3(x);
   powers.rg = powers.rg * vec2(x);
   powers.r = powers.r * x;
   powers.a = 1.0;
   interval1.r = dot(powers, coeffs1);
   interval2.r = dot(powers, coeffs2);
   interval3.r = dot(powers, coeffs3);
   interval4.r = dot(powers, coeffs4);
   x = color.g;
   powers.rgb = vec3(x);
   powers.rg = powers.rg * vec2(x);
   powers.r = powers.r * x;
   powers.a = 1.0;
   interval1.g = dot(powers, coeffs1);
   interval2.g = dot(powers, coeffs2);
   interval3.g = dot(powers, coeffs3);
   interval4.g = dot(powers, coeffs4);
   x = color.b;
   powers.rgb = vec3(x);
   powers.rg = powers.rg * vec2(x);
   powers.r = powers.r * x;
   powers.a = 1.0;
   interval1.b = dot(powers, coeffs1);
   interval2.b = dot(powers, coeffs2);
   interval3.b = dot(powers, coeffs3);
   interval4.b = dot(powers, coeffs4);
   luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
   x = luminance;
   powers.rgb = vec3(x);
   powers.rg = powers.rg * vec2(x);
   powers.r = powers.r * x;
   powers.a = 1.0;
   interval1.a = dot(powers, coeffs1);
   interval2.a = dot(powers, coeffs2);
   interval3.a = dot(powers, coeffs3);
   interval4.a = dot(powers, coeffs4);
   xcolor = color;
   xcolor.a = luminance;
   answer = xcolor*scaleAboveOne + vec4(1.0-scaleAboveOne);
   answer = compare(xcolor - breaks.w, interval4, answer);
   answer = compare(xcolor - breaks.z, interval3, answer);
   answer = compare(xcolor - breaks.y, interval2, answer);
   answer = compare(xcolor - breaks.x, interval1, answer);
   return answer;
kernel vec4 _boostHybrid(sampler src, sampler rgblboostnogamma, float transitionBreakpoint, float transitionWidth, float luminanceAmount) {
  float luminance, factor, interpolant;
  vec4 color, xcolor, answer;
  color = sample(src, samplerCoord(src));
  luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
  answer = sample(rgblboostnogamma, samplerCoord(rgblboostnogamma));
  xcolor = color;
  xcolor.a = luminance;
  answer = compare(xcolor, vec4(0.0), answer);
  answer = max(answer, vec4(0.0));
  factor = answer.a / max(luminance, 0.000001);
  color.rgb = color.rgb * vec3(factor);
  color.rgb = max(color.rgb, vec3(0.0));
  interpolant = clamp((luminance - (transitionBreakpoint - transitionWidth * 0.5)) / transitionWidth, 0.0, 1.0);
  interpolant = 1.0 - ((3.0 - 2.0 * interpolant) * interpolant * interpolant);
  interpolant = interpolant * luminanceAmount;
  color.rgb = mix(answer.rgb, color.rgb, interpolant);
  return color;
<CIFilterShape: %p extent [infinite]>
<CIFilterShape: %p extent [empty]>
<CIFilterShape: %p extent [%g %g %g %g]>
kernel vec2 _tile(vec2 origin, vec4 scaling) {return fract((destCoord() - origin) * scaling.zw) * scaling.xy + origin;}
kernel vec2 _lowq_affine(vec2 center, vec2 xvec, vec2 yvec)
  vec2 p = destCoord(); 
  return center + vec2(dot(p, xvec), dot(p, yvec)); 
[CIAffineTile inputTransfom] is not a valid object.
[CIAffineClamp inputTransfom] is not a valid object.
kernel vec2 _circleSplash(vec2 center, float radius)
  vec2 r0;
  float r1, r2;
  r0 = destCoord() - center;
  r1 = dot (r0, r0);
  r2 = inversesqrt (r1);
  r1 = r1 * r2;
  r0 = r0 * r2;
  r1 = min(r1, radius);
  r0 = r0 * r1 + center;
  return r0;
inputCompression
kernel vec4 _modTransition (__sample src0, __sample src1, vec2 center, vec4 parms, vec4 xform, vec4 botparms, vec4 topparms)
  vec2 offset = destCoord() - center, vv;
  float r = offset.x * parms.z;
  float a = botparms.z / (r * botparms.x + botparms.y) + botparms.w;
  float b = topparms.z / (r * topparms.x + topparms.y) + topparms.w;
  float v = (r<0.5) ? a : b;
  vv = vec2(v * parms.w, offset.y);
  vv = vec2(dot(vv, xform.xy), dot(vv, xform.zw));
  vv = fract(vv + center);
  vv = 2.0 * min(vv, vec2(1.0) - vv);
  float len = clamp(length(vv)* parms.x + parms.y, 0.0, 1.0);
  return mix(src1, src0, len);
T@"NSNumber",&,N,VinputCompression
projectionRows_planar8UtoF
projectionCols_planar8UtoF
Projections_status Projections_projectionRowsCols_planar8UtoF(const uint8_t *, int, int, size_t, float *, float *)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/api/Burst/Projections/Projections_Core.c
Projections_status Projections_computeProjectionDerivative(const float *, int, float *)
kernel vec4 _copyMachineTransition (__sample src0, __sample src1, vec3 parms2, vec4 multiplier, vec4 color, vec3 parms)
  vec4 v = vec4(destCoord(), parms.x, 1.0);
  float k = clamp(dot(v, multiplier), 0.0, 1.0);
  float j = clamp(min(k * parms2.x + parms2.y, k * parms2.z), 0.0, 1.0) * parms.y;
  k = max(k, parms.z);
  return j * color + mix(src0, src1, k);
com.apple.coreimage.tileKernelIsolation
T@"NSNumber",&,N,VinputAcuteAngle
_fourfoldRotatedTile
kernel vec2 _fourfoldRotatedTile(vec2 center, vec4 ftrans, vec4 btrans)
  vec2 t1, t2, t3, t4, t5, ci;
  t1 = destCoord() - center;
  t2.x = dot(t1, ftrans.xy);
  t2.y = dot(t1, ftrans.zw);
  ci = fract(floor(t2) * 0.5) * 2.0;
  t2 = fract(t2);
  t4 = 1.0 - t2;
  t3 = vec2(t4.y, t2.x);
  t5 = vec2(t2.y, t4.x);
  t2 = mix(t2, t5, ci.x);
  t3 = mix(t3, t4, ci.x);
  t2 = mix(t2, t3, ci.y);
  t1.x = dot(t2, btrans.xy);
  t1.y = dot(t2, btrans.zw);
  return t1 + center;
_sixfoldRotatedTile
kernel vec2 _sixfoldRotatedTile(vec2 center, vec4 ftrans, vec4 btrans)
  vec2 t1, t2;
  t1 = destCoord() - center;
  t2.x = dot(t1, ftrans.xy);
  t2.y = dot(t1, ftrans.zw);
  t2 = fract(t2);
  t1.x = 1.0 - t2.y;
  t1.y = t2.x + t2.y - 1.0;
  t2 = (t1.y < 0.0) ? t2 : t1;
  t1.x = t2.y;
  t1.y = 1.0 - t2.x - t2.y;
  t2 = (1.0 - 2.0 * t2.x - t2.y < 0.0) ? t1 : t2;
  t1.x = 1.0 - t2.x - t2.y;
  t1.y = t2.x;
  t2 = (1.0 - 2.0 * t2.y - t2.x < 0.0) ? t1 : t2;
  t1.x = t2.y;
  t1.y = 1.0 - t2.x - t2.y;
  t2 = (1.0 - 2.0 * t2.x - t2.y < 0.0) ? t1 : t2;
  t1.x = dot(t2, btrans.xy);
  t1.y = dot(t2, btrans.zw);
  return t1 + center;
_twelvefoldReflectedTile
kernel vec2 _twelvefoldReflectedTile(vec2 center, vec4 ftrans, vec4 btrans)
  vec2 t1, t2;
  float d0, d1;
  t1 = destCoord() - center;
  t2.x = dot(t1.xy, ftrans.xy);
  t2.y = dot(t1.xy, ftrans.zw);
  t2 = fract(t2).xy;
  d0 = t2.x - t2.y;
  vec2 lt = vec2(lessThan(vec2(d0), vec2(0.0)));
  t2 = mix(t2.yx, t2.xy, lt);
  d0 = 1.0 - t2.x - t2.y;
  t1 = 1.0 - t2.yx;
  lt = vec2(lessThan(vec2(d0), vec2(0.0)));
  t2 = mix(t2, t1, lt);
  d1 = 1.0 - 2.0 * t2.x - t2.y;
  d0 = 1.0 - t2.x - t2.y;
  t2.x = (d1 < 0.0) ? d0 : t2.x;
  d1 = 0.5 - 0.5 * t2.x - t2.y;
  d0 = 1.0 - t2.x - t2.y;
  t2.y = (d1 < 0.0) ? d0 : t2.y;
  t1.x = dot(t2.xy, btrans.xy);
  t1.y = dot(t2.xy, btrans.zw);
  return t1 + center;
_fourfoldTranslatedTile
kernel vec2 _fourfoldTranslatedTile(vec2 center, vec4 ftrans, vec4 btrans)
  vec2 t1, t2;
  t1 = destCoord() - center;
  t2.x = dot(t1, ftrans.xy);
  t2.y = dot(t1, ftrans.zw);
  t2 = fract(t2);
  t1.x = dot(t2, btrans.xy);
  t1.y = dot(t2, btrans.zw);
  return t1 + center;
_glideReflectedTile
kernel vec2 _glideReflectedTile(vec2 center, vec4 ftrans, vec4 btrans)
  vec2 t1, t2, t3, t4, t5, ci;
  t1 = destCoord() - center;
  t2.x = dot(t1, ftrans.xy);
  t2.y = dot(t1, ftrans.zw);
  ci = fract(floor(t2) * 0.5) * 2.0;
  t2 = fract(t2);
  t3 = vec2(t2.x, t2.y + 1.0);
  t4 = vec2(1.0 - t2.x, t2.y);
  t5 = vec2(t4.x, t4.y + 1.0);
  t2 = mix(t2, t5, ci.x);
  t3 = mix(t3, t4, ci.x);
  t2 = mix(t2, t3, ci.y);
  t1.x = dot(t2, btrans.xy);
  t1.y = dot(t2, btrans.zw);
  return t1 + center;
_eightfoldReflectedTile
kernel vec2 _eightfoldReflectedTile(vec2 center, vec4 ftrans, vec4 btrans)
  vec2 t1, t2;
  float d0;
  t1 = destCoord() - center;
  t2.x = dot(t1, ftrans.xy);
  t2.y = dot(t1, ftrans.zw);
  t2 = fract(t2);
  t2 = min(t2, 1.0 - t2);
  d0 = t2.y - t2.x;
  vec2 lt = vec2(lessThan(vec2(d0), vec2(0.0)));
  t2 = mix(t2.yx, t2.xy, lt);
  t1.x = dot(t2, btrans.xy);
  t1.y = dot(t2, btrans.zw);
  return t1 + center;
_fourfoldReflectedTile
kernel vec2 _fourfoldReflectedTile(vec2 center, vec4 ftrans, vec4 btrans)
  vec2 t1, t2;
  t1 = destCoord() - center;
  t2.x = dot(t1, ftrans.xy);
  t2.y = dot(t1, ftrans.zw);
  t2 = fract(t2);
  t2 = min (t2, 1.0 - t2);
  t2 = t2 + t2;
  t1.x = dot(t2, btrans.xy);
  t1.y = dot(t2, btrans.zw);
  return t1 + center;
_sixfoldReflectedTile
kernel vec2 _sixfoldReflectedTile(vec2 center, vec4 ftrans, vec4 btrans)
  vec2 t1, t2;
  float d0, d1, d2;
  t1 = destCoord() - center;
  t2.x = dot(t1, ftrans.xy);
  t2.y = dot(t1, ftrans.zw);
  t2 = fract(t2);
  d0 = t2.x - t2.y; 
  vec2 lt = vec2(lessThan(vec2(d0), vec2(0.0)));
  t2 = mix(t2.yx, t2.xy, lt);
  d2 = t2.x + t2.y;
  d0 = 2.0 - d2;
  d1 = d0 - t2.y;
  t2.y = (d1 < 0.0) ? d0 : t2.y;
  d0 = 1.0 - d2;
  d1 = d0 * -1.0 + t2.x;
  t2.x = (d1 < 0.0) ? d0 : t2.x;
  d0 = t2.x - t2.y;
  lt = vec2(lessThan(vec2(d0), vec2(0.0)));
  t2 = mix(t2.yx, t2.xy, lt);
  t1.x = dot(t2, btrans.xy);
  t1.y = dot(t2, btrans.zw);
  return t1 + center;
singular matrix cannot be inverted
kernel vec4 _sobelEdges(sampler src, float scale)
  vec2 coord = destCoord();
  vec2 sc = samplerTransform(src, coord);
  vec2 dx = samplerTransform(src, coord + vec2(1.0, 0.0)) - sc;
  vec2 dy = samplerTransform(src, coord + vec2(0.0, 1.0)) - sc;
  vec2 d = dx + dy;
  vec4 pix3 = sample(src, sc + d);
  vec4 pix7 = sample(src, sc - d);
  d = dx - dy;
  vec4 pix9 = sample(src, sc + d);
  vec4 pix1 = sample(src, sc - d);
  vec4 pix2 = sample(src, sc + dy);
  vec4 pix8 = sample(src, sc - dy);
  vec4 pix6 = sample(src, sc + dx);
  vec4 pix4 = sample(src, sc - dx);
  vec4 pix5 = sample(src, sc);
  vec4 gx = (pix3 + 2.0*pix6 + pix9) - (pix1 + 2.0*pix4 + pix7);
  vec4 gy = (pix1 + 2.0*pix2 + pix3) - (pix7 + 2.0*pix8 + pix9);
  vec4 g2 = gx*gx + gy*gy;
  pix5 = vec4(pix5.rgb/max(pix5.a,0.00001), pix5.a);
  pix5.rgb = sqrt(g2).rgb * scale;
  return vec4(pix5.rgb*pix5.a, pix5.a);
kernel vec4 _noiseComicReduction(sampler src, vec2 offset, vec3 weight, vec3 intensity)
  vec2 c = destCoord();
  vec4 cn = sample(src, samplerTransform(src, c));
  vec4 t0 = sample(src, samplerTransform(src, c + vec2(0.0, -offset.x)));
  vec4 t1 = sample(src, samplerTransform(src, c + vec2(0.0, offset.x)));
  vec4 t2 = sample(src, samplerTransform(src, c + vec2(-offset.x, 0.0)));
  vec4 t3 = sample(src, samplerTransform(src, c + vec2(offset.x, 0.0)));
  vec4 t4 = sample(src, samplerTransform(src, c + vec2(offset.y, offset.y)));
  vec4 t5 = sample(src, samplerTransform(src, c + vec2(offset.y, -offset.y)));
  vec4 t6 = sample(src, samplerTransform(src, c + vec2(-offset.y, -offset.y)));
  vec4 t7 = sample(src, samplerTransform(src, c + vec2(-offset.y, offset.y)));
  t0 = (t0 + t1 + t2 + t3) * weight.x + (t4 + t5 + t6 + t7) * weight.y + cn * weight.z;
  vec4 d = abs(t0 - cn);
  float s = intensity.x + intensity.y * (d.r + d.g + d.b);
  s = clamp(s, intensity.z, 1.0);
  return mix(cn, t0, s);
kernel vec4 _colorControls(__sample src, float threshold, float contrast)
  vec4 pix = vec4(src.rgb/max(src.a,0.00001), src.a);
  float f = clamp((dot(pix.rgb, vec3(0.2125, 0.7154, 0.0721)) - threshold) * contrast + 0.5, 0.0, 1.0);
  return vec4(0.0, 0.0, 0.0, f);
inputNRSharpness
inputNRNoiseLevel
inputEdgeIntensity
inputThreshold
kernel vec4 _spotColor(__sample src, 
  __color cclr1, __color rclr1, 
  __color cclr2, __color rclr2, 
  __color cclr3, __color rclr3, 
  vec4 closeness, vec4 contrast)
  vec4 pix = vec4(src.rgb/max(src.a,0.00001), src.a);
  float dist = length(pix.rgb - cclr1.rgb);
  float alpha = clamp((closeness.x - dist) * contrast.x + 0.5, 0.0, 1.0);
  vec4 result1 = rclr1 * alpha;
  dist = length(pix.rgb - cclr2.rgb);
  alpha = clamp((closeness.y - dist) * contrast.y + 0.5, 0.0, 1.0);
  vec4 result2 = rclr2 * alpha;
  dist = length(pix.rgb - cclr3.rgb);
  alpha = clamp((closeness.z - dist) * contrast.z + 0.5, 0.0, 1.0);
  vec4 result3 = rclr3 * alpha;
  pix = result1 + (1.0 - result1.a) * vec4(1.0);
  pix = result2 + (1.0 - result2.a) * pix;
  return result3 + (1.0 - result3.a) * pix;
inputCloseness1
inputContrast1
inputCenterColor1
inputReplacementColor1
inputCloseness2
inputContrast2
inputCenterColor2
inputReplacementColor2
inputCloseness3
inputContrast3
inputCenterColor3
inputReplacementColor3
CI::MainProgramArgsQ
B24@?0^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}4^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}8i12i16i20
v20@?0^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}4^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}8i12i16
program 
 kernel=0x%llx
 format=%s%s
<CI::%s %p>
vertexTransform0
vertexTransform1
vertexTransform2
vertexTransform3
vertexTransform
CI_PRINT_PROGRAM %s <0x%llx> (%s context %p) = 
Argument count mismatch for program (%s) <0x%llx> (%d != %d).
[argument types]
[argument names]
[argument objects]
r*8@?0i4
mData[%i] = %s
mData[%i] = %p <%s> 
kernel vec4 _boxBlur3(sampler i, vec2 dir)
  vec2 dc = destCoord(); 
  vec4 c; 
  c  = sample(i, samplerTransform(i,dc - dir)); 
  c += sample(i, samplerTransform(i,dc + 0.5*dir)) * 2.0; 
  return c / 3.0; 
kernel vec4 _boxBlur5(sampler i, vec2 dir)
  vec2 dc = destCoord(); 
  vec4 c; 
  c  = sample(i, samplerTransform(i,dc - 1.5*dir)) * 0.4; 
  c += sample(i, samplerTransform(i,dc)) * 0.2; 
  c += sample(i, samplerTransform(i,dc + 1.5*dir)) * 0.4; 
  return c; 
kernel vec4 _boxBlur7(sampler i, vec2 dir)
  vec2 dc = destCoord(); 
  vec4 c; 
  c  = sample(i, samplerTransform(i,dc - 2.5*dir)); 
  c += sample(i, samplerTransform(i,dc - dir)) * 0.5; 
  c += sample(i, samplerTransform(i,dc + 0.5*dir)); 
  c += sample(i, samplerTransform(i,dc + 2.5*dir)); 
  return c / 3.5; 
kernel vec4 _boxBlur9(sampler i, vec2 dir)
  vec2 dc = destCoord(); 
  vec4 c; 
  c  = sample(i, samplerTransform(i,dc - 3.5*dir)); 
  c += sample(i, samplerTransform(i,dc - 1.5*dir)); 
  c += sample(i, samplerTransform(i,dc)) * 0.5; 
  c += sample(i, samplerTransform(i,dc + 1.5*dir)); 
  c += sample(i, samplerTransform(i,dc + 3.5*dir)); 
  return c / 4.5; 
kernel vec4 _boxBlur11(sampler i, vec2 dir)
  vec2 dc = destCoord(); 
  vec4 c; 
  c  = sample(i, samplerTransform(i,dc - 4.5*dir)); 
  c += sample(i, samplerTransform(i,dc - 2.5*dir)); 
  c += sample(i, samplerTransform(i,dc - dir)) * 0.5; 
  c += sample(i, samplerTransform(i,dc + 0.5*dir)); 
  c += sample(i, samplerTransform(i,dc + 2.5*dir)); 
  c += sample(i, samplerTransform(i,dc + 4.5*dir)); 
  return c / 5.5; 
kernel vec4 _boxBlur13(sampler i, vec2 dir)
  vec2 dc = destCoord(); 
  vec4 c; 
  c  = sample(i, samplerTransform(i,dc - 5.5*dir)); 
  c += sample(i, samplerTransform(i,dc - 3.5*dir)); 
  c += sample(i, samplerTransform(i,dc - 1.5*dir)); 
  c += sample(i, samplerTransform(i,dc)) * 0.5; 
  c += sample(i, samplerTransform(i,dc + 1.5*dir)); 
  c += sample(i, samplerTransform(i,dc + 3.5*dir)); 
  c += sample(i, samplerTransform(i,dc + 5.5*dir)); 
  return c / 6.5; 
kernel vec4 _boxCombine7 (sampler blur, vec2 off)
  vec2 dc = destCoord(); 
  vec4 c = sample(blur, samplerTransform(blur, dc - 3.0*off)) 
         + sample(blur, samplerTransform(blur, dc - 2.0*off)) 
         + sample(blur, samplerTransform(blur, dc - off)) 
         + sample(blur, samplerTransform(blur, dc)) 
         + sample(blur, samplerTransform(blur, dc + off)) 
         + sample(blur, samplerTransform(blur, dc + 2.0*off)) 
         + sample(blur, samplerTransform(blur, dc + 3.0*off)); 
  return c / 7.0; 
kernel vec4 _boxCombine5 (sampler blur, vec2 off)
  vec2 dc = destCoord(); 
  vec4 c = sample(blur, samplerTransform(blur, dc - 2.0*off)) 
         + sample(blur, samplerTransform(blur, dc - off)) 
         + sample(blur, samplerTransform(blur, dc)) 
         + sample(blur, samplerTransform(blur, dc + off)) 
         + sample(blur, samplerTransform(blur, dc + 2.0*off)); 
  return c * 0.2; 
kernel vec4 _boxCombine3 (sampler blur, vec2 off)
  vec2 dc = destCoord(); 
  vec4 c = sample(blur, samplerTransform(blur, dc)) 
         + sample(blur, samplerTransform(blur, dc - off)) 
         + sample(blur, samplerTransform(blur, dc + off)); 
  return c / 3.0; 
kernel vec4 _boxCombine2 (sampler img, sampler blur, vec4 parms)
  vec2 off = parms.xy; 
  float kc = parms.w; 
  float kb = parms.z; 
  vec2 dc = destCoord(); 
  return kc * sample(img,  samplerTransform(img,  dc)) 
       + kb * sample(blur, samplerTransform(blur, dc - off)) 
       + kb * sample(blur, samplerTransform(blur, dc + off)); 
lightMap
lightMapWidth
lightMapHeight
lightMapAvg
localAutoValue
proxyLightMap
proxyLightMapWidth
proxyLightMapHeight
inputLightMapWidth
inputLightMapHeight
kernel vec4 _polyKernel(__sample im, __sample adj, float str) 
  adj.r = 3.4*adj.r-1.2; 
  vec3 neg = min(im.rgb, 0.0); 
  vec3 pos = max(im.rgb, 1.0)-1.0; 
  im.rgb = clamp(im.rgb, 0.0, 1.0); 
  vec4 orig = im; 
  float y = sqrt(dot(im.rgb, vec3(.33333))); 
  float s = mix(0.0, adj.r, str); 
  vec3 gain = s > 0.0 ? vec3(1.5*s) : vec3(1.75*s, 1.75*s, 1.55*s); 
  im.rgb = im.rgb*im.rgb*gain + im.rgb*(1.0-gain); 
  im.rgb = (clamp(im.rgb, 0.0, 1.0)); 
  float midAmt = min(str, .5); 
  y = y*(1.0-y); 
  im.rgb = sqrt(im.rgb); 
  float pivot = max(adj.g, 0.5); 
  float a = midAmt*y; 
  float b = -pivot*a; 
  vec3 pix = im.r * vec3(0.299*a) + 
             im.g * vec3(0.587*a) + 
             im.b * vec3(0.114*a) + 
             im.rgb + vec3(b); 
  im.rgb = mix(im.rgb, vec3(pivot), -y*midAmt); 
  im.rgb = mix(im.rgb, pix, 0.8); 
  im.rgb = max(im.rgb, 0.0); 
  im.rgb *= im.rgb; 
  im.rgb = clamp(im.rgb, 0.0,1.0)+pos+neg; 
  return im; 
-[CILocalLightFilter outputImage]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/CILocalLight.mm
CGRectEqualToRect([guideImage extent], [inputImage extent])
inputImage != nil
guideImage != nil
inputLocalLight != nil
CGRectEqualToRect([lightMapImage extent], [inputImage extent])
_lightMapImageFromData_block_invoke
x == 0
y == 0
width == lmWidth
height == lmHeight
CIEdgePreserveUpsampleRGFilter
kernel vec4 _colorMap (sampler src, sampler map, float scale)
  vec4 s = unpremultiply(sample(src, samplerCoord(src))); 
  float n = clamp(dot(s.rgb, vec3(0.2125, 0.7154, 0.0721)), 0.0, 1.0);
  return s.a * sample(map, samplerTransform(map, vec2(n*scale + 0.5, 0.5)));
%s requires the inputGradientImage to be finite
-[CIColorMap outputImage]
T@"CIImage",&,N,VinputGradientImage
kernel vec4 _median3x3(sampler src) 
  vec2  d; 
  vec4  p1,p2,p3,p4,p5,p6,p7,p8,p9; 
  vec4  e1, e2, e3, e4, e5, e6, e7, e8, e9, e10; 
  vec4  e11, e12, e13, e14, e15, e16, e17, e18, e19, e20; 
  vec4  e21, e22, e23, e24, e25, e26, e27, e28, e29; 
  d  = destCoord(); 
  p1 = sample(src, samplerTransform(src, d + vec2(+1.0, 0.0))); 
  p2 = sample(src, samplerTransform(src, d + vec2(+1.0,+1.0))); 
  p3 = sample(src, samplerTransform(src, d + vec2( 0.0,+1.0))); 
  p4 = sample(src, samplerTransform(src, d + vec2(-1.0,+1.0))); 
  p5 = sample(src, samplerTransform(src, d + vec2(-1.0, 0.0))); 
  p6 = sample(src, samplerTransform(src, d + vec2(-1.0,-1.0))); 
  p7 = sample(src, samplerTransform(src, d + vec2( 0.0,-1.0))); 
  p8 = sample(src, samplerTransform(src, d + vec2(+1.0,-1.0))); 
  p9 = sample(src, samplerTransform(src, d)); 
  e1  = min(p2 , p3 );    e2  = max(p2 , p3 ); 
  e3  = min(p5 , p6 );    e4  = max(p5 , p6 ); 
  e5  = min(p8 , p9 );    e6  = max(p8 , p9 ); 
  e7  = min(p1 , e1 );    e8  = max(p1 , e1 ); 
  e9  = min(p4 , e3 );    e10 = max(p4 , e3 ); 
  e11 = min(p7 , e5 );    e12 = max(p7 , e5 ); 
  e13 = min(e8 , e2 );    e14 = max(e8 , e2 ); 
  e15 = min(e10, e4 );    e16 = max(e10, e4 ); 
  e17 = min(e12, e6 );    e18 = max(e12, e6 ); 
  e19 = max(e7 , e9 ); 
  e20 = min(e16, e18); 
  e21 = max(e19, e11); 
  e22 = min(e14, e20); 
  e23 = min(e15, e17);    e24 = max(e15, e17); 
  e25 = max(e13, e23); 
  e26 = min(e24, e25); 
  e27 = min(e26, e22);    e28 = max(e26, e22); 
  e29 = max(e21, e27); 
  return min(e29, e28); 
inputBarOffset
kernel vec2 _barsSwipe (vec3 ptoy, vec2 dir, float progress)
  float y = dot(ptoy.xy,destCoord()) + ptoy.z;
  y = abs(floor(y));
  y = max(progress - y, 0.0);
  return destCoord() + y*y*dir;
T@"NSNumber",&,N,VinputBarOffset
inputShadowRadius
inputShadowDensity
inputShadowOffset
kernel vec4 _disintegrateWithMask (__sample t0, __sample t1, 
   __sample m0, __sample m1, __sample m2, __sample m3, 
   vec4 param)
  float shadowRadiusInv = param.y; 
  float shadowDensity = param.z; 
  float time = param.w; 
  float ramp = 1.0 / (max(abs(m1.r-m0.r), abs(m2.r-m0.r)) + 0.001);
  float shadow = (time - m3.r) * shadowRadiusInv * ramp + time;
  shadow = clamp(shadow, 0.0, 1.0);
  shadow = shadowDensity*(shadow-1.0) + 1.0;
  t0.rgb = t0.rgb * (param.x*time + 1.0);
  t1.rgb = t1.rgb * (param.x*time + 1.0 - param.x) * shadow;
  float s = clamp((time - m0.r) * ramp + time, 0.0, 1.0);
  return mix(t0, t1, s);
kernel vec4 _disintegrateWithMaskG (sampler s0, sampler s1, sampler m, vec2 offset, vec4 param)
  float shadowRadiusInv = param.y; 
  float shadowDensity = param.z; 
  float time = param.w; 
  vec4 t0 = sample(s0, samplerCoord(s0)); 
  vec4 t1 = sample(s1, samplerCoord(s1)); 
  vec2 d  = destCoord(); 
  vec4 m0 = sample(m, samplerTransform(m, d)); 
  vec4 m1 = sample(m, samplerTransform(m, d + vec2(1.0, 0.0))); 
  vec4 m2 = sample(m, samplerTransform(m, d + vec2(0.0, 1.0))); 
  vec4 m3 = sample(m, samplerTransform(m, d - offset)); 
  float ramp = 1.0 / (max(abs(m1.r-m0.r), abs(m2.r-m0.r)) + 0.001);
  float shadow = (time - m3.r) * shadowRadiusInv * ramp + time;
  shadow = clamp(shadow, 0.0, 1.0);
  shadow = shadowDensity*(shadow-1.0) + 1.0;
  t0.rgb = t0.rgb * (param.x*time + 1.0);
  t1.rgb = t1.rgb * (param.x*time + 1.0 - param.x) * shadow;
  float s = clamp((time - m0.r) * ramp + time, 0.0, 1.0);
  return mix(t0, t1, s);
T@"NSNumber",&,N,VinputShadowRadius
T@"NSNumber",&,N,VinputShadowDensity
T@"CIVector",&,N,VinputShadowOffset
com.apple.mobileslideshow
inputFadeThreshold
kernel vec4 _flashColor (__sample r1, __sample r0, vec2 center, __color color, __sample noise, vec4 parms, vec2 parms2)
  vec2 delta = destCoord() - center;
  float len = length(delta);
  float len2 = dot(delta,delta);
  float mask = clamp(1.0 - len * parms.z, 0.0, 1.0);
  float n = clamp(noise.x, 0.0, noise.a);
  n = n * parms2.x + parms2.y;
  vec4 flash = color * parms.y / len2 + n;
  vec4 r2 = clamp(flash * mask, 0.0, 1.0);
  r1 = clamp(r1 + r2, 0.0, 1.0);
  return mix(r1, r0, parms.w);
kernel vec2 _flashGeom (vec2 center)
  vec2 delta = destCoord() - center;
  float len = length(delta);
  return (delta * 100.0 / len) + vec2(128.0);
T@"NSNumber",&,N,VinputMaxStriationRadius
T@"NSNumber",&,N,VinputStriationStrength
T@"NSNumber",&,N,VinputStriationContrast
T@"NSNumber",&,N,VinputFadeThreshold
kernel vec4 _add(__sample src, __sample dst)
  return src + dst;
kernel vec4 _multiply(__sample src, __sample dst)
  return src * dst;
kernel vec4 _min(__sample src, __sample dst)
  return min(src, dst);
kernel vec4 _max(__sample src, __sample dst)
  return max(src, dst);
kernel vec4 _clear(__sample src, __sample dst)
  return vec4(0.0);
kernel vec4 _src(__sample src, __sample dst)
  return src;
kernel vec4 _dst(__sample src, __sample dst)
  return dst;
kernel vec4 _srcOver(__sample src, __sample dst)
  return src + dst*(1.0 - src.a);
kernel vec4 _dstOver(__sample src, __sample dst)
  return dst + src*(1.0 - dst.a);
kernel vec4 _srcIn(__sample src, __sample dst)
  return src*dst.a;
kernel vec4 _dstIn(__sample src, __sample dst)
  return dst*src.a;
kernel vec4 _srcOut(__sample src, __sample dst)
  return src*(1.0-dst.a);
kernel vec4 _dstOut(__sample src, __sample dst)
  return src*(1.0-dst.a);
kernel vec4 _srcAtop(__sample src, __sample dst)
  return src * dst.a + dst * (1.0 - src.a);
kernel vec4 _dstAtop(__sample src, __sample dst)
  return dst * src.a + src * (1.0 - dst.a);
kernel vec4 _exclusiveOr(__sample src, __sample dst)
  return src * (1.0 - dst.a) + dst * (1.0 - src.a);
kernel vec4 _multiplyBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb * Cs;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _screenBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb + Cs - (Cb * Cs);
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _overlayBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = compare(0.5 - Cb, 2.0 * (Cs + Cb - Cs * Cb) - 1.0, 2.0 * Cb * Cs);
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _darkenBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = min(Cb, Cs);
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _lightenBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = max(Cb, Cs);
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _colorDodgeBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb / max(1.0 - Cs, vec4(0.0000001));
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _colorBurnBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = 1.0 - (1.0 - Cb) / max(Cs, vec4(0.0000001));
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _hardLightBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = compare(0.5 - Cs, 2.0 * (Cb + Cs - Cb * Cs) - 1.0, 2.0 * Cs * Cb);
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _softLightBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 DCb = compare(0.25 - Cb, sqrt(Cb), ((16.0 * Cb - 12.0) * Cb + 4.0) * Cb);
  vec4 B  = Cb + (2.0 * Cs - 1.0) * compare(0.5 - Cs, DCb - Cb, Cb * (1.0 - Cb));
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _differenceBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = abs(Cb - Cs);
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _exclusionBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb + Cs - 2.0 * Cb * Cs;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _hueBlendMode (__sample fore, __sample back) 
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 CsSort = (Cs.r > Cs.g) ? Cs : Cs.grba;
  CsSort = (CsSort.g > CsSort.b) ? CsSort : CsSort.rbga;
  CsSort = (CsSort.r > CsSort.g) ? CsSort : CsSort.grba;
  vec4 CbSort = (Cb.r > Cb.g) ? Cb : Cb.grba;
  CbSort = (CbSort.g > CbSort.b) ? CbSort : CbSort.rbga;
  CbSort = (CbSort.r > CbSort.g) ? CbSort : CbSort.grba;
  float bMax = CbSort.r;
  float bMin = CbSort.b;
  float Sb = bMax - bMin;
  float sMax = CsSort.r;
  float sMid = CsSort.g;
  float sMin = CsSort.b;
  int sMaxIdx = (sMax == Cs.r ? 0 : (sMax == Cs.g ? 1 : 2));
  int sMinIdx = (sMin == Cs.b ? 2 : (sMin == Cs.g ? 1 : 0));
  int sMidIdx = 3 - sMinIdx - sMaxIdx;
  vec4 CsSb = Cs;
  CsSb[sMaxIdx] = (sMax > sMin) ? Sb : 0.0;
  CsSb[sMidIdx] = (sMax > sMin) ? (sMid - sMin) * Sb / (sMax - sMin) : 0.0;
  CsSb[sMinIdx] = 0.0;
  float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b;
  float LCsSb = 0.3 * CsSb.r + 0.59 * CsSb.g + 0.11 * CsSb.b;
  vec4 BB = CsSb + vec4(Lb - LCsSb);
  float l = 0.3 * BB.r + 0.59 * BB.g + 0.11 * BB.b;
  float n = min(min(BB.r, BB.g), BB.b);
  float x = max(max(BB.r, BB.g), BB.b);
  vec4 B = BB;
  B = n < 0.0 ? vec4(l) + (B - vec4(l)) *      l    / (l - n) : B;
  B = x > 1.0 ? vec4(l) + (B - vec4(l)) * (1.0 - l) / (x - l) : B;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _saturationBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 CsSort = (Cs.r > Cs.g) ? Cs : Cs.grba;
  CsSort = (CsSort.g > CsSort.b) ? CsSort : CsSort.rbga;
  CsSort = (CsSort.r > CsSort.g) ? CsSort : CsSort.grba;
  vec4 CbSort = (Cb.r > Cb.g) ? Cb : Cb.grba;
  CbSort = (CbSort.g > CbSort.b) ? CbSort : CbSort.rbga;
  CbSort = (CbSort.r > CbSort.g) ? CbSort : CbSort.grba;
  float sMax = CsSort.r;
  float sMin = CsSort.b;
  float Ss = sMax - sMin;
  float bMax = CbSort.r;
  float bMid = CbSort.g;
  float bMin = CbSort.b;
  int bMaxIdx = (bMax == Cb.r ? 0 : (bMax == Cb.g ? 1 : 2));
  int bMinIdx = (bMin == Cb.b ? 2 : (bMin == Cb.g ? 1 : 0));
  int bMidIdx = 3 - bMinIdx - bMaxIdx;
  vec4 CbSs = Cb;
  CbSs[bMaxIdx] = (bMax > bMin) ? Ss : 0.0;
  CbSs[bMidIdx] = (bMax > bMin) ? (bMid - bMin) * Ss / (bMax - bMin) : 0.0;
  CbSs[bMinIdx] = 0.0;
  float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b;
  float LCbSs = 0.3 * CbSs.r + 0.59 * CbSs.g + 0.11 * CbSs.b;
  vec4 BB = CbSs + vec4(Lb - LCbSs);
  float l = 0.3 * BB.r + 0.59 * BB.g + 0.11 * BB.b;
  float n = min(min(BB.r, BB.g), BB.b);
  float x = max(max(BB.r, BB.g), BB.b);
  vec4 B = BB;
  B = n < 0.0 ? vec4(l) + (B - vec4(l)) *      l    / (l - n) : B;
  B = x > 1.0 ? vec4(l) + (B - vec4(l)) * (1.0 - l) / (x - l) : B;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _colorBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  float Ls = 0.3 * Cs.r + 0.59 * Cs.g + 0.11 * Cs.b;
  float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b;
  vec4 BB = Cs + vec4(Lb - Ls);
  float l = 0.3 * BB.r + 0.59 * BB.g + 0.11 * BB.b;
  float n = min(min(BB.r, BB.g), BB.b);
  float x = max(max(BB.r, BB.g), BB.b);
  vec4 B = BB;
  B = n < 0.0 ? vec4(l) + (B - vec4(l)) *      l    / (l - n) : B;
  B = x > 1.0 ? vec4(l) + (B - vec4(l)) * (1.0 - l) / (x - l) : B;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _luminosityBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  float Ls = 0.3 * Cs.r + 0.59 * Cs.g + 0.11 * Cs.b;
  float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b;
  vec4 BB = Cb + vec4(Ls - Lb);
  float l = 0.3 * BB.r + 0.59 * BB.g + 0.11 * BB.b;
  float n = min(min(BB.r, BB.g), BB.b);
  float x = max(max(BB.r, BB.g), BB.b);
  vec4 B = BB;
  B = n < 0.0 ? vec4(l) + (B - vec4(l)) *      l    / (l - n) : B;
  B = x > 1.0 ? vec4(l) + (B - vec4(l)) * (1.0 - l) / (x - l) : B;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _subtractBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb - Cs;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _divideBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb / max(Cs,vec4(0.0000001));
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _linearBurnBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb + Cs - 1.0;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _linearDodgeBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb + Cs;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _vividLightBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 epsilon = vec4(0.0000001);
  vec4 lo = 1.0 - ((1.0 - Cb) / max(2.0 * Cs, epsilon));
  vec4 hi = Cb / max(2.0 * (1.0 - Cs), epsilon);
  vec4 B  = compare(0.5 - Cs, hi, lo);
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _linearLightBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B  = Cb + 2.0 * Cs - 1.0;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _pinLightBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 hi = 2.0 * Cs;
  vec4 lo = hi - 1.0;
  vec4 B  = compare(Cb - lo, lo, compare(Cb - hi, Cb, hi));
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _hardMixBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  vec4 B = compare(1.0 - Cb - Cs, vec4(1.0), vec4(0.0));
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _darkerColorBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  float Ls = 0.3 * Cs.r + 0.59 * Cs.g + 0.11 * Cs.b;
  float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b;
  vec4 B  = Ls > Lb ? Cb : Cs;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _lighterColorBlendMode (__sample fore, __sample back)
  vec4 Cs = unpremultiply(fore);
  vec4 Cb = unpremultiply(back);
  float Ls = 0.3 * Cs.r + 0.59 * Cs.g + 0.11 * Cs.b;
  float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b;
  vec4 B  = Ls < Lb ? Cb : Cs;
  vec4 Cr = clamp(B, 0.0, 1.0);
  Cr = mix(Cs, Cr, back.a);
  Cr.a = 1.0;
  Cr = mix(back, Cr, fore.a);
  return Cr;
kernel vec4 _plusDarker(__sample src, __sample dst)
  vec4 R = src + dst;
  R.rgb = R.a - R.rgb;
  R = clamp(R, 0.0, 1.0);
  R.rgb = R.a - R.rgb;
  return R;
kernel vec4 _plusLighter(__sample src, __sample dst)
  return src + dst;
componentAdd
T@"CIBlendKernel",R
componentMultiply
componentMin
componentMax
source
destination
sourceOver
destinationOver
sourceIn
destinationIn
sourceOut
destinationOut
sourceAtop
destinationAtop
exclusiveOr
multiply
screen
overlay
darken
lighten
colorDodge
colorBurn
hardLight
softLight
difference
exclusion
saturation
color
luminosity
subtract
divide
linearBurn
linearDodge
vividLight
linearLight
pinLight
hardMix
darkerColor
lighterColor
,vec2 samplePoint
destCoord()
samplePoint
__table
kernel vec4 autoROI_%s(__sample s,vec4 e,
%s v%d%s
  vec2 pt = ( 
v%d%s
,s.xy) - e.xy) / e.zw; return pt.xyxy; }
kernel vec4 autoROI_%s(sampler s,vec4 e,
  vec2 pt = 
 return ((samplerTransform(s, pt).xyxy)- e.xyxy) / e.zwzw; }
inputGreyscale
T@"NSNumber",C,N,VinputSaturation
T@"NSNumber",C,N,VinputGreyscale
kernel vec4 _DEmin4luma(sampler image, vec2 bound)
  vec2 d = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  vec3 Y = vec3(0.299, 0.587, 0.114);
  float m0 = dot(p0.rgb, Y);
  float m1 = dot(p1.rgb, Y);
  float m2 = dot(p2.rgb, Y);
  float m3 = dot(p3.rgb, Y);
  if (m1 < m0 && d.x+0.5 < bound.x) {
    m0 = m1;
    p0 = p1;
  if (m3 < m2 && d.x+0.5 < bound.x) {
    m2 = m3;
    p2 = p3;
  if (m2 < m0 && d.y+0.5 < bound.y) {
    m0 = m2;
    p0 = p2;
  return p0;
kernel vec4 _DEmax4luma(sampler image, vec2 bound)
  vec2 d = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  vec3 Y = vec3(0.299, 0.587, 0.114);
  float m0 = dot(p0.rgb, Y);
  float m1 = dot(p1.rgb, Y);
  float m2 = dot(p2.rgb, Y);
  float m3 = dot(p3.rgb, Y);
  if (m1 > m0 && d.x+0.5 < bound.x) {
    m0 = m1;
    p0 = p1;
  if (m3 > m2 && d.x+0.5 < bound.x) {
    m2 = m3;
    p2 = p3;
  if (m2 > m0 && d.y+0.5 < bound.y) {
    m0 = m2;
    p0 = p2;
  return p0;
kernel vec4 _DEcomputeInversionMask(__sample c, __sample cmin, __sample cmax, float maxSaturation, float minRange) {
  float range = cmax.r - cmin.r;
  float mean = cmin.r + range/2.0;
  float vmin = min(min(c.r,c.g),c.b);
  float vmax = max(max(c.r,c.g),c.b);
  vec3 Y = vec3(0.299, 0.587, 0.114);
  float luma = dot(c.rgb, Y);
  float mask = (vmax / vmin > maxSaturation || luma > mean || range < minRange) ? 1.0 : 0.0;
  float hardBit = 1.0;
  return vec4(vec3(mask), hardBit);
kernel vec4 _DEmin4(sampler image, vec2 bound)
  vec2 d = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x) ? min(p0, p1) : p0;
  p2 = (d.x+0.5 < bound.x) ? min(p2, p3) : p2;
  p0 = (d.y+0.5 < bound.y) ? min(p0, p2) : p0;
  return p0;
kernel vec4 _DEmax4(sampler image, vec2 bound)
  vec2 d = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x) ? max(p0, p1) : p0;
  p2 = (d.x+0.5 < bound.x) ? max(p2, p3) : p2;
  p0 = (d.y+0.5 < bound.y) ? max(p0, p2) : p0;
  return p0;
kernel vec4 _DEcreateForegroundMask(__sample c, __sample downMin, __sample downMax, __sample meanMin, __sample meanMax, vec4 params) 
float threshMin = params.x;
float threshMaxOverMin = params.y;
float cutoff = params.z;
float epsChroma = params.w;
float cmincomp = min(c.r, min(c.g, c.b)); 
float cmaxcomp = max(c.r, max(c.g, c.b)); 
float luminance = dot(downMax.rgb, vec3(0.3333333)); 
vec3 Y = vec3(0.299, 0.587, 0.114);
vec3 Cb = vec3(-0.168736, -0.331264, 0.5);
vec3 Cr = vec3(0.5, -0.418688, -0.081312);
vec3 YCbCr_c = vec3(dot(c.rgb,Y), dot(c.rgb,Cb), dot(c.rgb,Cr));
vec3 YCbCr_bg = vec3(dot(downMax.rgb,Y), dot(meanMax.rgb,Cb), dot(meanMax.rgb,Cr));
float dchromaticity = length(YCbCr_c.yz-YCbCr_bg.yz); 
  if (cmincomp < threshMin * luminance || cmaxcomp/cmincomp > threshMaxOverMin || dchromaticity > epsChroma) 
    c *= 0.0; 
  return c; 
kernel vec4 _DEnormalizeAlpha(__sample c) { return c * smoothstep(0.001, 0.1, c.a) / max(c.a,0.0001); }
kernel vec4 _DEWash(__sample c, __sample w) { return c / (0.000001 + w); }
kernel vec4 _DEconditionalFilter(__sample c, __sample d, __sample mask, float threshold) {
  return mask.r > threshold ? c : d;
inputBottomLeft
inputBottomRight
inputTopRight
inputTopLeft
kernel vec2 _perspectiveTransform(vec3 A1, vec3 A2, vec3 A3, vec2 origin)
  vec3 h = vec3(destCoord(), 1.0);
  vec2 p = vec2(dot(h, A1), dot(h, A2));
  float w = 1.0 / max(dot(h, A3), 0.000001);
  return p * w + origin;
T@"CIVector",&,N,VinputTopLeft
T@"CIVector",&,N,VinputTopRight
T@"CIVector",&,N,VinputBottomRight
T@"CIVector",&,N,VinputBottomLeft
kernel vec4 _perspectiveMask(__sample p, vec3 A3) { return p * ((dot(vec3(destCoord(), 1.0), A3)<0.000001) ? 0.0 : 1.0); }
inputCrop
kernel vec2 _perspectiveCorrection(vec3 A1, vec3 A2, vec3 A3)
  vec3 h = vec3(destCoord(), 1.0);
  vec2 p = vec2(dot(h, A1), dot(h, A2)); 
  return p / max(dot(h, A3), 0.000001); 
T@"NSNumber",&,N,VinputCrop
kernel vec2 _bumpDistortion(vec4 parms)
  float d0 = clamp(distance(destCoord(), parms.zw) * -parms.x + 1.0, 0.0, 1.0);
  d0 = ((d0 * -2.0 + 3.0) * d0 * d0) * parms.y + 1.0;
  return (destCoord() - parms.zw) * d0 + parms.zw;
kernel vec2 _bumpDistortionLinear(vec4 edgeFunc, vec4 vec)
  float eFunc = dot(vec4(destCoord(), 1.0, 0.0), edgeFunc);
  float r0 = clamp(1.0 - abs(eFunc), 0.0, 1.0);
  r0 = ((r0 * -2.0 + 3.0) * r0 * r0) * vec.z + 1.0;
  return destCoord() + (eFunc * (r0 - 1.0) * vec.xy);
kernel vec4 _colorPolynomial (__sample c, vec4 cf0, vec4 cf1, vec4 cf2, vec4 cf3) { return cf0 + c * (cf1 + c * (cf2 + c * cf3)); }
inputRedCoefficients
inputGreenCoefficients
inputBlueCoefficients
inputAlphaCoefficients
T@"CIVector",&,N,VinputRedCoefficients
T@"CIVector",&,N,VinputGreenCoefficients
T@"CIVector",&,N,VinputBlueCoefficients
T@"CIVector",&,N,VinputAlphaCoefficients
kernel vec4 _colorCrossPolynomial (__sample c, vec3 pr, vec3 pg, vec3 pb, 
                                    vec3 prr, vec3 pgg, vec3 pbb, 
                                    vec3 prg, vec3 pgb, vec3 pbr, vec3 p1) 
  c.rgb =   c.r * pr   +        c.g * pg   +        c.b * pb   +  
      c.r * c.r * prr  +  c.g * c.g * pgg  +  c.b * c.b * pbb  +  
      c.r * c.g * prg  +  c.g * c.b * pgb  +  c.b * c.r * pbr  +  p1;
  return c; 
CPUFaceMask_Clear
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/AutoEnhance/Portrait/CPUFaceMask_algorithms.c
outputMaskBaseAddr != NULL
( bounds.x >= region.x ) && ( bounds.y >= region.y ) && ( bounds.z <= region.z ) && ( bounds.w <= region.w )
simd_all( length > 0 ) && simd_all( offset >= 0 )
CPUFaceMask_MinMax
minMaxObj != NULL
inputBGRAImageBaseAddr != NULL
CPUFaceMask_PopulateCube
outputCube != NULL
CPUFaceMask_GenerateMask
spanTable != NULL
firstSpanInRows != NULL
inputCube != NULL
CPUFaceMask_GenerateToothMask
CPUFaceMask_DrawSpans
simd_all( length > 0 )
CPUFaceMask_DrawEye
eyeQuads != NULL
switch
CIFilter
inputHueMagMR
inputHueMagRY
inputHueMagYG
inputHueMagGC
inputHueMagCB
inputHueMagBM
inputRequestedSushiMode
RCCreateCIImageFromBufferAndProperties
raw-image
kCGImageSourceShouldUseRawDataForFulleSize
kCGImageSourceShouldUseRawDataForFullSize
kCGImageSourceSupportedSushiLevels
{Raw}
filters
RAWDemosaicFilter
RAWGamutMap
RAWReduceNoise
inputLNRAmount
inputCNRAmount
inputSharpenAmount
inputContrastAmount
inputDetailAmount
RAWRadialLensCorrection
inputLDCExecuteFlags
RAWConvert
RAWAdjustTempTint
inputWhitePoint
RAWAdjustExposureAndBias
RAWHueMagnet
RAWAdjustColorTRC
inputBoostAmount
RAWAdjustColors
RAWTemperatureAdjust
RAWLinearSpacePlaceholder
kCGImageSourceNoiseReductionAmount
kCGImageSourceLuminanceNoiseReductionAmount
kCGImageSourceColorNoiseReductionAmount
kCGImageSourceNoiseReductionSharpnessAmount
kCGImageSourceNoiseReductionContrastAmount
kCGImageSourceNoiseReductionDetailAmount
kCGImageSourceChromaBlurMoireAmount
kCGImageSourceDisableVendorLensDistortionCorrection
inputNeutralXY
PixelWidth
PixelHeight
{Raw}.filters
inputCropRect
{Exif}.PixelXDimension
{Exif}.PixelYDimension
RAWCropFilter
rawDictionary
T@"NSDictionary",R,&
rawReconstructionDefaultsDictionary
sushiMode
T@"NSNumber",R,&
rawMajorVersion
T@"NSArray",R,&
subsampling
nativeSize
T{CGSize=ff},R
-[CIRAWFilterImpl(CustomAccessors) inputImage]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/Raw/CIRAWFilterImpl.m
_inputImage != nil
CIRAWFilter %s: The file does not support version %@. The version %@ will be used instead.
-[CIRAWFilterImpl(CustomAccessors) setInputDecoderVersion:]
kCGImageSourceVendorLensCorrectionFeatures
RAWAdjustExposureAndBias.inputBias
RAWAdjustExposureAndBias.inputBaselineExposure
RAWHueMagnet.inputHueMagMR
RAWHueMagnet.inputHueMagRY
RAWHueMagnet.inputHueMagYG
RAWHueMagnet.inputHueMagGC
RAWHueMagnet.inputHueMagCB
RAWHueMagnet.inputHueMagBM
bsamt
RAWLensCorrectionDNG
RAWRadialLensCorrectionRB
(rVector != nil) && (gVector != nil) && (bVector != nil)
kernel vec4 _resetalpha(__sample src, __sample mask)
  src.a = mask.a;
  return src;
kernel vec4 _colorClamp (__sample c, vec4 lo, vec4 hi) { return clamp(c,lo,hi); }
inputMinComponents
inputMaxComponents
T@"CIVector",&,N,VinputMinComponents
T@"CIVector",&,N,VinputMaxComponents
inputTexture
kernel vec4 _glassDistort (sampler tex0, sampler tex1, 
              vec2 scale_plus_unit, vec2 off0, vec2 off1, 
              vec2 off2, vec2 unit_to_glass, float height_factor) 
    vec2 dc = destCoord(); 
    vec2 dcscaled = dc * scale_plus_unit; 
    vec2 t0g = fract(dcscaled + off0) * unit_to_glass + vec2(.5); 
    vec2 t1g = fract(dcscaled + off1) * unit_to_glass + vec2(.5); 
    vec2 t2g = fract(dcscaled + off2) * unit_to_glass + vec2(.5); 
    float tcen = sample(tex1, samplerTransform(tex1, t0g)).r; 
    float tdx  = sample(tex1, samplerTransform(tex1, t1g)).r; 
    float tdy  = sample(tex1, samplerTransform(tex1, t2g)).r; 
    vec2 p = dc + vec2(tdx-tcen, tdy-tcen) * height_factor; 
    return sample(tex0, samplerTransform(tex0, p)); 
T@"CIImage",&,N,VinputTexture
kernel vec2 _stretchcrop (vec2 sizeIn, vec2 center, vec4 p)
  vec2 a = p.xy, b = p.zw; 
  vec2 c = destCoord(); 
  c = (c-center)/sizeIn;
  c = c / (a + b*abs(c));
  c = (c + 0.5)*sizeIn;
  return c;
inputCropAmount
inputCenterStretchAmount
kernel vec2 _ninePartStretched (vec2 bpmin, vec2 growth, vec2 slope)
  vec2 dc = destCoord();
  vec2 c1 = slope * (dc - bpmin) + bpmin;
  vec2 c2 = dc - growth;
  return max(min(dc,c1),c2);
inputBreakpoint0
inputBreakpoint1
inputGrowAmount
T@"CIVector",&,N,VinputBreakpoint0
T@"CIVector",&,N,VinputBreakpoint1
T@"CIVector",&,N,VinputGrowAmount
kernel vec2 _ninePartTiledAlt (vec4 bp01, vec2 growth, vec2 shift)
  vec2 dc = destCoord();
  vec2 bp0 = bp01.xy;
  vec2 bp1 = bp01.zw;
  vec2 myMod; { 
    vec2 a = dc - shift; 
    vec2 b = bp1-bp0; 
    myMod = a - b*floor(a/b); 
  } 
  vec2 c1 = bp0 + myMod;
  vec2 p = compare(dc - bp0, dc, c1); 
  p = compare(dc - (bp1+growth), p, dc - growth); 
  return p;
inputFlipYTiles
T@"NSNumber",&,N,VinputFlipYTiles
inputGrainAmount
kernel vec4 _photoEffectDepthBlend (__sample fg, __sample bg, __sample depthMap, const float thresh) 
  float d = min(2.0*depthMap.r, 1.0); 
  vec3 blended = mix(fg.rgb, bg.rgb, d); 
  float g = smoothstep(thresh, thresh+.15, d); 
  blended = mix(fg.rgb, blended, g);
  return vec4(blended, fg.a); 
%@BG
com.apple.coreimage.photoEffects3DIsolation
inputDepthMap
T@"CIImage",&,N,VinputDepthMap
T@"NSNumber",&,N,VinputThreshold
T@"NSNumber",&,N,VinputGrainAmount
10.?
inputLowLimit
inputHighLimit
kernel vec4 _histogram_display (sampler image, float height, vec2 hilo) 
    vec2  d = destCoord(); 
    vec2  histcoord = vec2(floor(d.x)+0.5, 0.5); 
    vec4  v = sample(image, samplerTransform(image, histcoord)); 
    v = step(vec4(d.y), height*v); 
    float vi = v.r*4.0 + v.g*2.0 + v.b; 
    vec4 p = vec4(.25,.25,.25,1.0); 
    p = (vi==4.0) ? vec4(.50,.05,.05,1.0) : p; 
    p = (vi==6.0) ? vec4(.20,.40,.05,1.0) : p; 
    p = (vi==2.0) ? vec4(.05,.50,.05,1.0) : p; 
    p = (vi==3.0) ? vec4(.05,.20,.40,1.0) : p; 
    p = (vi==1.0) ? vec4(.05,.05,.50,1.0) : p; 
    p = (vi==5.0) ? vec4(.20,.05,.40,1.0) : p; 
    p = (vi==7.0) ? vec4(.05,.10,.30,1.0) : p; 
    p.rgb = (d.x<hilo.x+0.5)  ? p.rgb*vec3(0.4)             : p.rgb; 
    p.rgb = (d.x>=hilo.y+0.5) ? p.rgb*vec3(0.6) + vec3(0.4) : p.rgb; 
    return p; 
T@"NSNumber",&,N,VinputHighLimit
T@"NSNumber",&,N,VinputLowLimit
%llX(%04X)
Cannot handle a (%lu x %lu) sized texture with the given context!
CI::KernelCompileQ
CI::CompiledKernelCacheQ
ci_kernels
kContextInfoSupportsMPS
kContextInfoWorkingFormat
kContextInfoWorkingSpace
CI_PRINT_TIME [GPU] root program (%s) = %.1f ms
CI_PRINT_TIME [GPU] intermediate program (%s) = %.1f ms
kernel vec4 _localContrast(__sample im, __sample shc, float amt)
  float midAmt = amt;
  vec3 neg = min(im.rgb, 0.0);
  vec3 pos = max(im.rgb, 1.0)-1.0;
  im.rgb = clamp(im.rgb, 0.0, 1.0);
  float y = dot(im.rgb, vec3(0.3333));
  y = sqrt(y);
  y = y*(1.0-y);
  im.rgb = sqrt(im.rgb);
  float pivot = sqrt(shc.g);
  float a = midAmt*y;
  float b = -pivot*a;
  vec3 pix = im.r * vec3(0.299*a) +
             im.g * vec3(0.587*a) +
             im.b * vec3(0.114*a) +
             im.rgb + vec3(b);
  im.rgb = mix(im.rgb, vec3(pivot), -y*midAmt);
  im.rgb = mix(im.rgb, pix, 0.8);
  im.rgb = max(im.rgb, 0.0);
  im.rgb *= im.rgb;
  im.rgb = im.rgb + neg + pos;
  return im;
inputBottomHeight
inputNumberOfFolds
inputFoldShadowAmount
kernel vec2 _accordianWarpS (vec3 foldParms, vec4 dims)
    float numFoldsX2 = foldParms.x;
    float foldScaleH = foldParms.y;
    float bottomHeight = dims.x;
    float gap = dims.y;
    vec2 dc = destCoord();
    float x = dc.x;
    float y = dc.y;
    float gapLoc = clamp((y - bottomHeight) / gap, 0.0, 1.0);
    float gapLocSaw = 1.0 - abs(mod((numFoldsX2*gapLoc), 2.0) - 1.0);
    float hScale = 1.0 + foldScaleH*gapLocSaw;
    vec2 pS;
    pS.y = min( y, max( y-gap, bottomHeight));
    pS.x = x * hScale;
    return pS;
kernel vec2 _accordianWarpT (vec3 foldParms, vec4 dims)
    float numFoldsX2 = foldParms.x;
    float foldScaleH = foldParms.y;
    float bottomHeight = dims.x;
    float gap = dims.y;
    vec2 dc = destCoord();
    float x = dc.x;
    float y = dc.y;
    float gapLoc = clamp((y - bottomHeight) / gap, 0.0, 1.0);
    float gapLocSaw = 1.0 - abs(mod((numFoldsX2*gapLoc), 2.0) - 1.0);
    float hScale = 1.0 + foldScaleH*gapLocSaw;
    vec2 pT;
    pT.y = max( y, min ( (y-bottomHeight)*dims.z + bottomHeight, y+dims.w ));
    pT.x = x * hScale;
    return pT;
kernel vec4 _accordionMix (
    __sample cS, __sample cT,
    vec3 foldParms, float time, vec4 dims)
    float numFoldsX2 = foldParms.x;
    float foldShadeAmt = foldParms.z;
    float bottomHeight = dims.x;
    float gap = dims.y;
    vec2 dc = destCoord();
    float y = dc.y;
    float gapLoc = clamp((y - bottomHeight) / gap, 0.0, 1.0);
    float shadeAmt = 1.0 - foldShadeAmt*mod((numFoldsX2*gapLoc), 1.0);
    vec4 result = mix(cS, cT, time);
    result.rgb *= shadeAmt;
    return result;
kernel vec4 _accordionFoldTransition (
    sampler shortImage, sampler tallImage,
    vec3 foldParms, float time, vec4 dims)
    float numFoldsX2 = foldParms.x;
    float foldScaleH = foldParms.y;
    float foldShadeAmt = foldParms.z;
    float bottomHeight = dims.x;
    float gap = dims.y;
    vec2 dc = destCoord();
    float x = dc.x;
    float y = dc.y;
    float gapLoc = clamp((y - bottomHeight) / gap, 0.0, 1.0);
    float gapLocSaw = 1.0 - abs(mod((numFoldsX2*gapLoc), 2.0) - 1.0);
    float shadeAmt = 1.0 - foldShadeAmt*mod((numFoldsX2*gapLoc), 1.0);
    float hScale = 1.0 + foldScaleH*gapLocSaw;
    vec2 pS;
    pS.y = min( y, max( y-gap, bottomHeight));
    pS.x = x * hScale;
    vec4 cS = sample(shortImage, samplerTransform(shortImage, pS));
    vec2 pT;
    pT.y = max( y, min ( (y-bottomHeight)*dims.z + bottomHeight, y+dims.w ));
    pT.x = x * hScale;
    vec4 cT = sample(tallImage, samplerTransform(tallImage, pT));
    vec4 result = mix(cS, cT, time);
    result.rgb *= shadeAmt;
    return result;
T@"NSNumber",&,N,VinputBottomHeight
T@"NSNumber",&,N,VinputNumberOfFolds
T@"NSNumber",&,N,VinputFoldShadowAmount
kernel %s
-[CIBarcodeDetector featuresInImage:options:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/api/Detectors/CIBarcodeDetector.mm
NULL != symbologies
<CI::%s %p [%s]>
inputPropagateKernel
inputSmoothSigma
inputPropogateMinWeightSum
inputPropogateSigmaLuma
inputPropogateSigmaChroma
kernel vec4 _CIInitialConversionRGB(sampler image,vec2 scale)
vec2 sp = destCoord() * scale;
    vec4 b0b3, c0c3, a0a3, d0d3;
    b0b3 = sample(image, samplerTransform(image, sp + vec2(-2.0, 0.0)));
    c0c3 = sample(image, samplerTransform(image, sp + vec2( 2.0, 0.0)));
    a0a3 = sample(image, samplerTransform(image, sp + vec2( 0.0, 2.0)));
    d0d3 = sample(image, samplerTransform(image, sp + vec2( 0.0,-2.0)));
    vec4 g = abs(c0c3 - b0b3) + abs(d0d3 - a0a3);
    vec4 outPix = sample(image, samplerTransform(image, sp));
    outPix.w  = min(max(g.x, max(g.y,g.z)), 1.0);
    return outPix;
kernel vec4 _CIPyramidGenerateLevel(sampler inYuva)
    vec2 gid2 = destCoord() * 2.0;
    vec4 pix_0_0 = sample(inYuva, samplerTransform(inYuva, gid2 + vec2(-0.5, -0.5)));
    vec4 pix_1_0 = sample(inYuva, samplerTransform(inYuva, gid2 + vec2(-0.5,  0.5)));
    vec4 pix_0_1 = sample(inYuva, samplerTransform(inYuva, gid2 + vec2( 0.5, -0.5)));
    vec4 pix_1_1 = sample(inYuva, samplerTransform(inYuva, gid2 + vec2( 0.5,  0.5)));
    
    if (pix_1_0.w > pix_0_0.w) pix_0_0 = pix_1_0;
    if (pix_0_1.w > pix_0_0.w) pix_0_0 = pix_0_1;
    if (pix_1_1.w > pix_0_0.w) pix_0_0 = pix_1_1;
    
    return pix_0_0;
float _local_yuvWeightG(vec4 pix1,vec4 pix2,vec2 sigmaLumaChmaRecip)
    vec3 yuv = pix1.xyz - pix2.xyz;
    yuv.xyz = (yuv.xyz * yuv.xyz) * sigmaLumaChmaRecip.xyy;
    return exp(-(yuv.x+yuv.y+yuv.z));
kernel vec4 _CIPropagateDisparity(sampler inDispMap,sampler yuv0,sampler yuv1,vec4 params)
    int   radius        = int(params.x); 
    vec2  sigmaLCRecip  = params.yz;
    float pmws          = params.w; 
    vec2  dc            = destCoord();
    vec2 gidHalf = floor(0.5*dc) + vec2(0.5);
    vec4  ref           = sample(yuv0, samplerTransform(yuv0, dc));
    float sow           = 0.0;
    float sowd          = 0.0;
    
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
        
 vec2 p  = vec2(float(x),float(y));
            vec4 p2 = sample(yuv1,      samplerTransform(yuv1,      gidHalf + p));
            float d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + p)).r;
            float w = _local_yuvWeightG(ref, p2, sigmaLCRecip);
            sow+= w; sowd+= w * d;
        }
    }
    float alt = sample(inDispMap, samplerTransform(inDispMap, gidHalf)).r;
    float rc = (sow < pmws) ? alt : (sowd / sow);
return vec4(rc,rc,rc,1.0);
float _local_yuvWeight(vec4 pix1,vec4 pix2,vec2 sigmaLumaChmaRecip)
    vec3 yuv = pix1.xyz - pix2.xyz;
    yuv.xyz = (yuv.xyz * yuv.xyz) * sigmaLumaChmaRecip.xyy;
    return exp(-(yuv.x+yuv.y+yuv.z));
kernel vec4 _CIPropagateDisparityR1(sampler inDispMap,sampler yuv0,sampler yuv1,vec4 params)
    vec2  sigmaLCRecip  = params.yz;
    float pmws          = params.w; 
    vec2  dc            = destCoord();
    vec2 gidHalf = floor(0.5*dc) + vec2(0.5);
    vec4  ref           = sample(yuv0, samplerTransform(yuv0, dc));
    float sow           = 0.0;
    float sowd          = 0.0;
    
    vec4 p;
    float d, w;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2(-1.0, -1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2(-1.0, -1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 0.0, -1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 0.0, -1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 1.0, -1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 1.0, -1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2(-1.0, 0.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2(-1.0, 0.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 0.0, 0.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 0.0, 0.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    float alt = d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 1.0, 0.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 1.0, 0.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2(-1.0, 1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2(-1.0, 1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 0.0, 1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 0.0, 1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 1.0, 1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 1.0, 1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    float rc = (sow < pmws) ? alt : (sowd / sow);
return vec4(rc,rc,rc,1.0);
float _local_yuvWeightC(vec4 pix1,vec4 pix2,vec2 sigmaLumaChmaRecip)
    vec3 yuv = pix1.xyz - pix2.xyz;
    yuv.xyz = (yuv.xyz * yuv.xyz) * sigmaLumaChmaRecip.xyy;
    return exp(-(yuv.x+yuv.y+yuv.z));
kernel vec4 _CIPropagateDisparityR1C(sampler image,sampler yuv0,vec4 params)
    vec2  sigmaLCRecip  = params.yz;
    float pmws          = params.w; 
    vec2  dc            = destCoord();
    vec2 gidHalf = floor(0.5*dc) + vec2(0.5);
    vec4  ref           = sample(yuv0, samplerTransform(yuv0, dc));
    float sow           = 0.0;
    float sowd          = 0.0;
    
    vec4 p;
    float w;
    p = sample(image, samplerTransform(image, gidHalf + vec2(-1.0, -1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 0.0, -1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 1.0, -1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2(-1.0, 0.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    float alt = p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 1.0, 0.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2(-1.0, 1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 0.0, 1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 1.0, 1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    float rc = (sow < pmws) ? alt : (sowd / sow);
return vec4(rc,rc,rc,1.0);
float _local_yuvWeightG2(vec4 pix1,vec4 pix2,vec2 sigmaLumaChmaRecip)
    vec3 yuv = pix1.xyz - pix2.xyz;
    yuv.xyz = (yuv.xyz * yuv.xyz) * sigmaLumaChmaRecip.xyy;
    return exp(-(yuv.x+yuv.y+yuv.z));
kernel vec4 _CIPropagateDisparityRC(sampler image,sampler yuv0,vec4 params)
    int   radius        = int(params.x); 
    vec2  sigmaLCRecip  = params.yz;
    float pmws          = params.w; 
    vec2  dc            = destCoord();
    vec2 gidHalf = floor(0.5*dc) + vec2(0.5);
    vec4  ref           = sample(yuv0, samplerTransform(yuv0, dc));
    float sow           = 0.0;
    float sowd          = 0.0;
    
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
            vec4  p = sample(image, samplerTransform(image, gidHalf + vec2(float(x), float(y))));
            float w = _local_yuvWeightG2(ref, p, sigmaLCRecip);
            sow+= w; sowd+= w * p.a;
        }
    }
    float alt = sample(image, samplerTransform(image, gidHalf)).r;
    float rc = (sow < pmws) ? alt : (sowd / sow);
return vec4(rc,rc,rc,1.0);
kernel vec4 _CISmoothDisparity(sampler inDisp, vec3 params)
    float wSide      = params.x;
    float wDiag      = params.y;
    float denomRecip = params.z;
    vec2  dc         = destCoord();
   vec4 g0, g1, g2;
   g0.x = sample(inDisp, samplerTransform(inDisp, dc + vec2(-1.0, 0.0))).x;
   g0.y = sample(inDisp, samplerTransform(inDisp, dc                  )).x;
   g0.z = sample(inDisp, samplerTransform(inDisp, dc + vec2( 0.0, 1.0))).x;
   g0.w = sample(inDisp, samplerTransform(inDisp, dc + vec2(-1.0, 1.0))).x;
   g1.y = sample(inDisp, samplerTransform(inDisp, dc + vec2( 1.0, 0.0))).x;
   g1.z = sample(inDisp, samplerTransform(inDisp, dc + vec2( 1.0, 1.0))).x;
   g2.x = sample(inDisp, samplerTransform(inDisp, dc + vec2(-1.0,-1.0))).x;
   g2.y = sample(inDisp, samplerTransform(inDisp, dc + vec2( 0.0,-1.0))).x;
   float g3   = sample(inDisp, samplerTransform(inDisp, dc + vec2( 1.5,-1.5))).x;
   float  v = (g0.y + (g0.x + g0.z + g1.y + g2.y) * wSide + (g0.w + g1.z + g2.x + g3) * wDiag) * denomRecip;
    return vec4(v,v,v,1.0);
/tmp/yuvImageUsingConstants.tiff
kernel_InitialConversion
/tmp/initialConversion-Metal.tiff
/tmp/initialConversion-CI.tiff
kernel_UpscaleShiftmap
scaleFactors
/tmp/upsampledShiftmap-Metal.tiff
/tmp/upsampledShiftmap-CI.tiff
kernel_PyramidGenerateLevel
/tmp/pyramidLevel1-Metal.tiff
/tmp/pyramidLevel1-CI.tiff
kernel_SmoothDisparity
config
/tmp/smoothDisparity-Metal.tiff
/tmp/smoothDisparity-CI.tiff
kernel vec4 _combineImages(__sample s0,__sample s1) { return vec4(s0.xyz,s1.r); }
kernel_PropagateDisparity
/tmp/propagateDisparity_%d-%s.tiff
/tmp/inputToDisparity.tiff
-[CIDisparityRefinement outputImageUsingMetal:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-579.1.2/Framework/filters/PortraitBlur/CIDisparityRefinement.m
computedPyramidNumLevels >= 1 && computedPyramidNumLevels <= kMAX_NUM_PYRAMID_LEVELS
/tmp/smoothed-Metal.tiff
/tmp/smoothed-CI.tiff
i8@?0@"NSDictionary"4
T@"NSNumber",C,VinputPropagateKernel
T@"NSNumber",C,VinputSmoothSigma
inputPropagateMinWeightSum
T@"NSNumber",C,VinputPropagateMinWeightSum
inputPropagateSigmaLuma
T@"NSNumber",C,VinputPropagateSigmaLuma
inputPropagateSigmaChma
T@"NSNumber",C,VinputPropagateSigmaChma
T@"NSNumber",C,VinputScale
T@"CIVector",C,VinputOriginalSize
CI_SAVE_IMAGES
Can't save nil image
infinite rect can't save image
kernel vec4 _gray(__sample s) { return s.rrra; }
CIConvolutionWeights
CIConvolution3X3 expects inputWeights to be a length-9 CIVector
T@"CIVector",&,N,VinputWeights
T@"NSNumber",&,N,VinputBias
CIConvolution5X5 expects inputWeights to be a length-25 CIVector
CIConvolution7X7 expects inputWeights to be a length-49 CIVector
kernel vec4 _conv3x3sym (sampler image, vec4 parms)
  vec2 dc = destCoord(); 
  vec2 dA = parms.xy; 
  vec2 dB = vec2(-dA.y, dA.x); 
  vec4 sum = sample(image, samplerTransform(image, dc + dB)) 
           + sample(image, samplerTransform(image, dc + dA)) 
           + sample(image, samplerTransform(image, dc - dA)) 
           + sample(image, samplerTransform(image, dc - dB));
  return sum * parms.z + parms.w;
kernel vec4 _conv3x3 (sampler image, vec4 w0, vec4 w1, vec4 w2)
  vec2 dc = destCoord();
  vec4 sum = w2.yyyy;
  vec2 delta = w2.zw;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delta.y))) * w0.x;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0, -delta.y))) * w0.y;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delta.y))) * w0.z;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,      0.0))) * w0.w;
  sum += sample(image, samplerTransform(image, dc                           )) * w1.x;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,      0.0))) * w1.y;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,  delta.y))) * w1.z;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0,  delta.y))) * w1.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,  delta.y))) * w2.x;
  return sum;
kernel vec4 _convolution5x5 (sampler image, vec4 w0, vec4 w1, vec4 w2, vec4 w3, vec4 w4, vec4 w5, vec4 w6)
  vec2 dc = destCoord();
  vec4 sum = w6.yyyy;
  vec2 delta = w6.zw;
  vec2 delt2 = 2.0 * delta;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delt2.y))) * w0.x;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delt2.y))) * w0.y;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0, -delt2.y))) * w0.z;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delt2.y))) * w0.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delt2.y))) * w1.x;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delta.y))) * w1.y;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delta.y))) * w1.z;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0, -delta.y))) * w1.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delta.y))) * w2.x;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delta.y))) * w2.y;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x,      0.0))) * w2.z;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,      0.0))) * w2.w;
  sum += sample(image, samplerTransform(image, dc                           )) * w3.x;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,      0.0))) * w3.y;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x,      0.0))) * w3.z;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x,  delta.y))) * w3.w;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,  delta.y))) * w4.x;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0,  delta.y))) * w4.y;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,  delta.y))) * w4.z;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x,  delta.y))) * w4.w;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x,  delt2.y))) * w5.x;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,  delt2.y))) * w5.y;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0,  delt2.y))) * w5.z;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,  delt2.y))) * w5.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x,  delt2.y))) * w6.x;
  return sum;
kernel vec4 _convolution7x7 (sampler image, vec4 w0, vec4 w1, vec4 w2, vec4 w3, vec4 w4, vec4 w5, vec4 w6, vec4 w7, vec4 w8, vec4 w9, vec4 w10, vec4 w11, vec4 w12)
  vec2 dc = destCoord();
  vec4 sum = w12.yyyy;
  vec2 delta = w12.zw;
  vec2 delt2 = 2.0 * delta;
  vec2 delt3 = 3.0 * delta;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, -delt3.y))) * w0.x;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delt3.y))) * w0.y;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delt3.y))) * w0.z;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0, -delt3.y))) * w0.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delt3.y))) * w1.x;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delt3.y))) * w1.y;
  sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, -delt3.y))) * w1.z;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, -delt2.y))) * w1.w;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delt2.y))) * w2.x;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delt2.y))) * w2.y;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0, -delt2.y))) * w2.z;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delt2.y))) * w2.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delt2.y))) * w3.x;
  sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, -delt2.y))) * w3.y;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, -delta.y))) * w3.z;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delta.y))) * w3.w;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delta.y))) * w4.x;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0, -delta.y))) * w4.y;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delta.y))) * w4.z;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delta.y))) * w4.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, -delta.y))) * w5.x;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x,      0.0))) * w5.y;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x,      0.0))) * w5.z;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,      0.0))) * w5.w;
  sum += sample(image, samplerTransform(image, dc                           )) * w6.x;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,      0.0))) * w6.y;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x,      0.0))) * w6.z;
  sum += sample(image, samplerTransform(image, dc + vec2( delt3.x,      0.0))) * w6.w;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x,  delta.y))) * w7.x;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x,  delta.y))) * w7.y;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,  delta.y))) * w7.z;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0,  delta.y))) * w7.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,  delta.y))) * w8.x;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x,  delta.y))) * w8.y;
  sum += sample(image, samplerTransform(image, dc + vec2( delt3.x,  delta.y))) * w8.z;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x,  delt2.y))) * w8.w;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x,  delt2.y))) * w9.x;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,  delt2.y))) * w9.y;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0,  delt2.y))) * w9.z;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,  delt2.y))) * w9.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x,  delt2.y))) * w10.x;
  sum += sample(image, samplerTransform(image, dc + vec2( delt3.x,  delt2.y))) * w10.y;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x,  delt3.y))) * w10.z;
  sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x,  delt3.y))) * w10.w;
  sum += sample(image, samplerTransform(image, dc + vec2(-delta.x,  delt3.y))) * w11.x;
  sum += sample(image, samplerTransform(image, dc + vec2(     0.0,  delt3.y))) * w11.y;
  sum += sample(image, samplerTransform(image, dc + vec2( delta.x,  delt3.y))) * w11.z;
  sum += sample(image, samplerTransform(image, dc + vec2( delt2.x,  delt3.y))) * w11.w;
  sum += sample(image, samplerTransform(image, dc + vec2( delt3.x,  delt3.y))) * w12.x;
  return sum;
kernel vec4 _convolution9 (sampler image, vec4 w0, vec4 w1, vec4 w2)
  vec2 dc = destCoord();
  vec4 sum = w2.yyyy;
  vec2 delta = w2.zw;
  sum += sample(image, samplerTransform(image, dc - delta*4.0)) * w0.x;
  sum += sample(image, samplerTransform(image, dc - delta*3.0)) * w0.y;
  sum += sample(image, samplerTransform(image, dc - delta*2.0)) * w0.z;
  sum += sample(image, samplerTransform(image, dc - delta    )) * w0.w;
  sum += sample(image, samplerTransform(image, dc            )) * w1.x;
  sum += sample(image, samplerTransform(image, dc + delta    )) * w1.y;
  sum += sample(image, samplerTransform(image, dc + delta*2.0)) * w1.z;
  sum += sample(image, samplerTransform(image, dc + delta*3.0)) * w1.w;
  sum += sample(image, samplerTransform(image, dc + delta*4.0)) * w2.x;
  return sum;
kernel vec4 _convolution7 (sampler image, vec4 w0, vec4 w1, vec4 w2)
  vec2 dc = destCoord();
  vec4 sum = w2.yyyy;
  vec2 delta = w2.zw;
  sum += sample(image, samplerTransform(image, dc - delta*3.0)) * w0.y;
  sum += sample(image, samplerTransform(image, dc - delta*2.0)) * w0.z;
  sum += sample(image, samplerTransform(image, dc - delta    )) * w0.w;
  sum += sample(image, samplerTransform(image, dc            )) * w1.x;
  sum += sample(image, samplerTransform(image, dc + delta    )) * w1.y;
  sum += sample(image, samplerTransform(image, dc + delta*2.0)) * w1.z;
  sum += sample(image, samplerTransform(image, dc + delta*3.0)) * w1.w;
  return sum;
kernel vec4 _convolution5 (sampler image, vec4 w0, vec4 w1)
  vec2 dc = destCoord();
  vec4 sum = w1.yyyy;
  vec2 delta = w1.zw;
  sum += sample(image, samplerTransform(image, dc - delta*2.0)) * w0.x;
  sum += sample(image, samplerTransform(image, dc - delta    )) * w0.y;
  sum += sample(image, samplerTransform(image, dc            )) * w0.z;
  sum += sample(image, samplerTransform(image, dc + delta    )) * w0.w;
  sum += sample(image, samplerTransform(image, dc + delta*2.0)) * w1.x;
  return sum;
kernel vec4 _convolution3 (sampler image, vec4 w0, vec4 w1)
  vec2 dc = destCoord();
  vec4 sum = w1.yyyy;
  vec2 delta = w1.zw;
  sum += sample(image, samplerTransform(image, dc - delta    )) * w0.y;
  sum += sample(image, samplerTransform(image, dc            )) * w0.z;
  sum += sample(image, samplerTransform(image, dc + delta    )) * w0.w;
  return sum;
kernel vec4 _scaleClamp(__sample p, float scale)
  return clamp(p * scale, 0.0, 1.0);
kernel vec4 _innerGorS (__sample b, __color color, float range)
  return clamp((1.0 - b.a) / range, 0.0, 1.0) * color;
inputOffset
inputRange
T@"CIVector",&,N,VinputOffset
T@"NSNumber",&,N,VinputRange
kernel vec4 _outerGorS (__sample b, __color color, float range)
  return clamp(b.a / range, 0.0, 1.0) * color;
inputSpread
T@"NSNumber",&,N,VinputSpread
inputGlowColorInner
inputGlowOuterOuter
inputShadowColorInner
inputShadowOuterOuter
inputShadowBlurInner
inputShadowBlurOuter
kernel vec4 _shapeEffectBlur_1 (__sample p0, __sample p1, __sample b0, __sample b1, __sample f0, 
                         __color gcI, __color gcO, __color scI, __color scO, vec2 sparms) 
  gcI *= clamp( (1.0 - b0.a) * 2.0, 0.0, 1.0); 
  gcO *= clamp( b0.a * 2.0, 0.0, 1.0); 
  scI *= mix( (1.0 - p1.a), (1.0 - b1.a), sparms.x ); 
  scO *= mix( p1.a, b1.a, sparms.y ); 
  vec4 I,O; 
  I = (gcI +  f0*(1.0 - gcI.a)); 
  I = (scI +   I*(1.0 - scI.a)) * (p0.a); 
  O = (gcO + scO*(1.0 - gcO.a)) * (1.0 - p0.a); 
  return I + O*(1.0 - I.a); 
inputFill
T@"CIImage",&,N,VinputFill
T@"CIColor",&,N,VinputGlowColorInner
inputGlowColorOuter
T@"CIColor",&,N,VinputGlowColorOuter
T@"CIColor",&,N,VinputShadowColorInner
inputShadowColorOuter
T@"CIColor",&,N,VinputShadowColorOuter
T@"NSNumber",&,N,VinputShadowBlurInner
T@"NSNumber",&,N,VinputShadowBlurOuter
inputSoften
inputHighlightColor
inputShadowColor
kernel vec4 _outerBevelEmboss (sampler image, vec2 ss) 
  vec2 st = destCoord(); 
  float a = 0.0, mm_a, pm_a, mp_a, pp_a;
  mm_a = sample(image, samplerTransform(image, st + ss.yy)).a; 
  pm_a = sample(image, samplerTransform(image, st + ss.xy)).a; 
  mp_a = sample(image, samplerTransform(image, st + ss.yx)).a; 
  pp_a = sample(image, samplerTransform(image, st + ss.xx)).a; 
  a = mm_a + pm_a - 1.3*(mp_a+pp_a); 
  a = clamp( a*0.5 + 0.5, 0.0, 1.0); 
  return vec4(a); 
kernel vec4 _outerBevelEmbossC (__sample v, __color hc, __color sc) 
  float a = v.a * 2.0 - 1.0; 
  vec4 result = hc*clamp(a, 0.0, 1.0) + sc*clamp(-a, 0.0, 1.0); 
  return result; 
T@"NSNumber",&,N,VinputSoften
T@"CIColor",&,N,VinputHighlightColor
T@"CIColor",&,N,VinputShadowColor
kernel vec4 _invertedMask (__sample c) { return vec4(0.0, 0.0, 0.0, 1.0 - c.a); } 
kernel vec4 _multiplyByMask (__sample c, __sample m) { return c*m.a;} 
CI_DEBUG_AUTOCROP
scaleRect:inner=(%.3f,%.3f,%.3f,%.3f), size=(%.3f,%.3f), anchor=(%.3f,%.3f)
ERROR <AutoCropper>: Point should be within rect
AspectRatioCutoff
MinimumCroppedArea
ProximityToCenter
Face area is %f, Total is %f
Large Face!
ERROR <AutoCropper>: unrecognized aspect ratio
No Crop. Reduces area too much
Clipping to original aspect ratio
Clipping to aspect ratio 4:3
Clipping to aspect ratio 3:2
Clipping to aspect ratio 16:9
Clipping to square
Clipping to aspect ratio 5:3
Clipping to aspect ratio 5:4
MinCropPercentage
determineBestPositionWithinSize:size=%.3f,%.3f, center=%.3f,%.3f, minPercentage=%.3f, restrict=%.3f,%.3f,%.3f,%.3f
originalArea = %.2f
pos = %d, rect=(%.2f,%.2f,%.2f,%.2f), area=%.2f
    topleft=%.2f
    topcenter=%.2f
    topright=%.2f
    bottomleft=%.2f
    bottomcenter=%.2f
    bottomright=%.2f
    leftcenter=%.2f
    rightcenter=%.2f
    center=%.2f
Best is %d
Want bottom
shouldFavorBottom
TB,N,VshouldFavorBottom
shouldFavorTop
TB,N,VshouldFavorTop
originalImageSize
T{CGSize=ff},N,VoriginalImageSize
ProviderImageSurfaceCacheQueue
provider %s
Render failed because a pixel format %s is not supported.
float dummyDoNothing() { return 10.0; }
int myMAX(int a,int b) { return a > b ? a : b; }
int myMIN(int a,int b) { return a < b ? a : b; }
vec2 calcPosition(vec2 index,vec4 rect) {
  vec2 step = rect.zw / 64.0;
  vec2 pos  = rect.xy + step * index + step / 2.0;
  return pos;
kernel vec4 _ciLensModelCalculator(sampler image,vec4 focusRect,sampler minMaxImage,float zeroShiftPercentile)
    int histBuf[256];
    for(int i = 0 ; i < 256; i++) {
    
  histBuf[i] = 0;
    }
   vec2 minMax = sample(minMaxImage, samplerTransform(minMaxImage, vec2(0.5))).rg;
   float shiftMin = floor(65536.0 * minMax.x) / 65536.0;
   float shiftMax = ceil(65536.0 * minMax.y) / 65536.0;
   float shiftRange = shiftMax - shiftMin;
   float shiftRecipRange = 1.0 / shiftRange; 
   for(int j = 0; j < 64; j++) {
       for ( int i = 0; i <  64; i++ ) {
            vec2 location = vec2(float(i),float(j));
            vec2 focusLocation  = calcPosition(location,focusRect);
            float shiftVal = sample(image, samplerTransform(image, focusLocation)).r;
            int index = int(255.0 * shiftRecipRange * ( shiftVal - shiftMin ));
            index = myMIN(myMAX(index,0),255);
            histBuf[index]++;
        }
    }
    int binCountThreshold = int(floor( zeroShiftPercentile * 64.0 * 64.0 ));
    int binCount = 0;
    int zeroShiftBinIndex = 0;
    for ( zeroShiftBinIndex = 0; (zeroShiftBinIndex < 256) && (binCount < binCountThreshold); zeroShiftBinIndex++ )
    {
    
binCount += histBuf[zeroShiftBinIndex];
    }
    float zeroShift = (shiftRange * float(zeroShiftBinIndex) / 255.0) + shiftMin;
    return vec4(shiftMin, zeroShift, 0.0, shiftMax);
zeroShiftPercentile
/tmp/manualCalculator.tiff
/tmp/calculator.tiff
T@"CIVector",C,VinputFocusRect
T@"CIImage",&,VinputMinMaxImage
%d, 
focus = 
kernel vec4 _CILensModelApplyGeneral(sampler image,sampler params,vec3 p){
  vec4 s          = sample(image, samplerCoord(image));
  vec4 histParams = sample(params, samplerTransform(params, vec2(0.5)));
    float radiusOffset  = histParams.y;
    float radiusScale   = p.x;
    float maxFGBlur     = p.y;
    float shiftDeadZone = p.z;
    float shiftVal      = s.x;
    float relShift      = abs( min( shiftVal - radiusOffset, maxFGBlur ) );
    float dzRelShift = mix( 0.0, relShift, clamp(relShift * shiftDeadZone, 0.0, 1.0));
    float blurVal = clamp( radiusScale * dzRelShift , 0.0, 1.0);
    float  resultBlurVal = clamp(sqrt(blurVal), 0.0, 1.0);
    return vec4(resultBlurVal,0.0,0.0,1.0);
maxFGBlur
/tmp/lensModel.tiff
T@"CIImage",&,N,VinputCalculatorValuesImage
T@"CIVector",C,N,VinputOriginalSize
T@"NSNumber",C,N,VinputIntrinsicMatrixFocalLength
image%d_0
u%d_0
transform%d
vec4 _ci_srgb_to_linear (vec4 s) { return _srgb_to_linear(s); }
_image[%d]
_transform[%d]
_extent[%d]
Cannot use sRGB texture binding with format %s for sampler %d in kernel '%s'.
Invalid DAG node type
vec4 _ci_linear_to_srgb (vec4 s) { return _linear_to_srgb(s); }
vec4 _read_pixel(sampler2D image, vec2 c, vec4 m0, vec4 m1) {
     float x = dot(vec4(c,1.0,0.0), m0);
     float y = dot(vec4(c,1.0,0.0), m1);
     return texture2D(image, vec2(x,y)); }
vec4 _read_pixel(sampler2D image, vec2 c, mat3 m){ return texture2D(image, (vec3(c, 1.0) * m).xy);}
vec4 _read_pixel_420(sampler2D Y, sampler2D cc, vec2 c, vec2 f, vec4 m0, vec4 m1){
     float x = dot(vec4(c,1.0,0.0), m0);
     float y = dot(vec4(c,1.0,0.0), m1);
     return vec4(texture2D(Y, vec2(x,y)).a, texture2D(cc, 0.5*vec2(x,y)).rg, 1.0);}
vec4 _read_pixel_420(sampler2D Y, sampler2D cc, vec2 c, vec2 f, mat3 m){
     highp vec3 p = vec3(c, 1.0) * m;
     return vec4(texture2D(Y, p.xy).a, texture2D(cc, f*p.xy).rg, 1.0);}
kernel vec2 _circularWrap(vec2 center, float b, float c, float d, float minAngle)
  vec2 p;
  vec2 t0 = destCoord() - center;
  float d0 = dot(t0, t0);
  float d1 = inversesqrt(d0);
  float r = d0 * d1; 
  vec2 u = t0 * d1; 
  vec2 x_ = abs(u);
  vec2 t = 0.00119152193164364 + (1.149637430629571 + (-0.6987144230270900 + 0.9002138006758336 * x_) * x_) * x_;
  vec2 thetas = compare(u, -t, t);
  thetas.x = (u.y < 0.0) ? (thetas.x - 1.5707963) : (1.5707963 - thetas.x);
  thetas.y = (u.x < 0.0) ? (3.1415927 - thetas.y) : thetas.y;
  vec2 abss = abs(u); 
  float theta = (abss.x < abss.y) ? thetas.x : thetas.y;
  theta = fract((theta - minAngle) * 0.15915494) * 6.2831853;
  p.x = theta * c + d; 
  p.y = r + b; 
  return p;
Crop: Based on %d features
  feature%d has left eye at (%.3f,%.3f), right eye at (%.3f,%.3f)
  clip overall %% = %.3f
    too much clipping - reverting back to rotated crop only
    too little clipping - reverting back
CIBurstActionClassifier
CIBurstImageSetInternal
CPUFaceMask
CIAreaHistogram
CIEdgeWork
CIBoxBlur3_7
CISobelHV
CIMorphologicalMax5Mono
CIConfidenceThresholdProcessor
CIConfidenceThreshold
CIPortraitPrepareStage
CIConfidenceMap
CIMaskedVariableBlur
CIBurstFaceConfigEntry
CIBurstFaceScoreEntry
CIBurstFaceInfo
CIBurstImageFaceAnalysisContext
CIBurstFaceStat
NSCopying
CIBurstImageStat
CIBarcodeDescriptor
NSSecureCoding
NSCoding
CIQRCodeDescriptor
CIAztecCodeDescriptor
CIPDF417CodeDescriptor
CIDataMatrixCodeDescriptor
CITriangleTile
CIGlassLozenge
CITorusLensDistortion
CIColorCurves
CIContext
Internal
QuicklookSupport
CIContextCache
CIPageCurlTransition
CIPageCurlWithShadowTransition
CIFilter
_CIFilterProperties
Private
CIParallelogramTile
CILinearBlur
CIMotionBlur
CIZoomBlur
CIImage
DepthData
TextImage
CIKernel
CIColorKernel
CIWarpKernel
CIBlendKernel
CIImageProvider
CIBicubicScaleTransform
CISoftCubicUpsample
CIDepthOfField
CIPortraitLightingSide
CIPortraitLightingFront
CIPortraitLightingStrobe
CIPortraitLightingContour
CIPortraitLightingSpot
CIPortraitLightingNeckContour
NSError
CIAffineTransform
CICrop
ImageRepresentation
CISepiaTone
CILenticularHaloGenerator
CIStraightenFilter
ClearImage
CIImageAccumulator
CIVector
CIExposureAdjust
CIDisplacementDistortion
CIColorControls
CIHueAdjust
CIReductionFilter
CIAreaAverage
CIColumnAverage
CIRowAverage
CIAreaMaximum
CIAreaMinimum
CIAreaMaximumAlpha
CIAreaMinMaxRed
CIAreaMinimumAlpha
CIAreaMinMaxNormalize
CIAreaMinMaxRedNormalize
CIColorMatrix
CIColorInvert
CIVibrance
CIBlurmapSmoothing
CIPortraitBlurNoise
CIPortraitBlurDirectionalBlur
CIPortraitBlur
CIPortraitBlurPreProcess
CIGenericMetalProcessorSingleChannel
CIGenericMetalProcessor
CITextImageGenerator
CIAttributedTextImageGenerator
CITemperatureAndTint
CIWhitePointAdjust
CIFalseColor
CIGammaAdjust
CIImageProcessorInOut
CIImageProcessorOutput
CIImageProcessorInput
CIImageProcessor
CIImageProcessorKernel
CINoiseReduction
CIProSharpenEdges
CIMetalConverter
CIOpTile
CICheckerboardGenerator
CISampler
CIShadedMaterial
CIDisparitySmoothing
CIDisparitySmoothingProcessor
CICircleGenerator
PrivateSmartToneAndColor
CISmartToneFilter
CISmartColorFilter
CIBitmapContext
CIRandomGenerator
AutoAdjust
CIRedEyeCorrection
CIRedEyeCorrections
CIEnhancementHistogram
CIConvolution
CIBokehBlur
CIDiscBlur
CIRingBlur
CIAutoEnhanceFace
CIDroste
CIRenderDestination
CIRenderInfo
CIRenderTask
CIImageRowReader
ImageRowReading
CIEnhancementCalculator
CIToneCurve
CIFilterRegistry
CIFilterRegistryPrivate
CIFilterClassAttributes
CIFilterClassCategories
CIFilterClassDefaults
CIFilterClassInfo
CIHighlightShadowAdjust
CITextDetector
CIRippleTransition
CIIntegralImageKernelProcessor
CIIntegralImage
CIStripesGenerator
CISunbeamsGenerator
CISmartBlackAndWhite
PrivateSmartBlackAndWhite
CIFaceBalance
CIStarShineGenerator
CIRedEyeRepair
CIMirror
CILabDeltaE
CITriangleKaleidoscope
CICheapBlur
CIStretch
CILightTunnel
CIEdgePreserveUpsampleFilter
CIEdgePreserveUpsampleRGFilter
CIRAWFilter
CIDetector
CIFaceCoreDetector
CIFeature
CIFaceFeature
CIRectangleFeature
CIQRCodeFeature
CITextFeature
CIColor
CISkyAndGrassAdjust
CIConstantColorGenerator
CruftCompatability
CIEnhancementCalculation
CIRectangleDetector
CIPremultiply
CIUnpremultiply
CIKernelLibrary
CISpotLight
CIColorCube
CIColorCubeWithColorSpace
CIColorCubesMixedWithMask
CIRadialGradient
CILinearGradient
CISmoothLinearGradient
CIGaussianGradient
CIHueSaturationValueGradient
CIColorMonochrome
CIBlendModeFilter
CIMultiplyBlendMode
CIScreenBlendMode
CIOverlayBlendMode
CIDarkenBlendMode
CILightenBlendMode
CIColorDodgeBlendMode
CIColorBurnBlendMode
CIHardLightBlendMode
CISoftLightBlendMode
CIDifferenceBlendMode
CIExclusionBlendMode
CIPDFNonSeparableBlendMode
CIHueBlendMode
CISaturationBlendMode
CIColorBlendMode
CILuminosityBlendMode
CISubtractBlendMode
CIDivideBlendMode
CILinearBurnBlendMode
CILinearDodgeBlendMode
CIVividLightBlendMode
CILinearLightBlendMode
CIPinLightBlendMode
CIHardMixBlendMode
CITwirlDistortion
CIVignette
CIVignetteEffect
CIKaleidoscope
YCCExtensions
CIColorBalance
CIPinchDistortion
CIPortraitLocalContrast
CIPointillize
CIVariableBoxBlur
CICMYKHalftone
CIRectangleGenerator
CIWrapMirror
CILumaMap
CIXRay
CIThermal
CIBarcodeGenerator
CICodeGenerator
CIQRCodeGenerator
CIAztecCodeGenerator
CIPDF417BarcodeGenerator
CICode128BarcodeGenerator
CIBurstThumbnailCluster
CICrystallize
CIPassThroughSelectFrom3
CIPassThroughFilter
CIPassThroughColorFilter
CIPassThroughWarpFilter
CIPassThroughGeneralFilter
CIPassThroughGeneralAltFilter
CIPassThroughIntermediateFilter
CIReedSolomon
CIPhotoGrain
CIPhotoEffect
CIPhotoEffectNoir
CIPhotoEffectChrome
CIPhotoEffectFade
CIPhotoEffectInstant
CIPhotoEffectMono
CIPhotoEffectProcess
CIPhotoEffectTonal
CIPhotoEffectTransfer
CIPhotoEffectStageMono
CIGaussianBlur
CIGaussianBlurXY
CIUnsharpMask
CIBurstClusterDivider
_CIScreenFilter
CIDotScreen
CIHatchedScreen
CILineScreen
CICircularScreen
CISRGBToneCurveToLinear
CILinearToSRGBToneCurve
CIBloom
CIGloom
CIColorPosterize
CIEdges
CIDissolveTransition
CIMaskToAlpha
CIDepthToDisparity
CIDisparityToDepth
CIDepthDisparityConverter
CIDepthEffectMakeBlurMap
CIDepthEffectApplyBlurMap
CIDepthEffect
CIDepthBlurEffect
CIPixellate
CIHexagonalPixellate
CISharpenLuminance
CISwipeTransition
CIMorphology
CICheapMorphology
CIMorphologyMinimum
CIMorphologyMaximum
CIMorphologyGradient
CIMorphologyLaplacian
CIPseudoMedian
CIBurstImageSet
CIHoleDistortion
CICheatBlur
CIMinimumComponent
CIMaximumComponent
CIVortexDistortion
CILanczosScaleTransform
CIBlendWithMask
CIBlendWithRedMask
CIBlendWithBlueMask
CIBlendWithAlphaMask
CIBurstYUVImage
Apply
CIRAWTemperatureAdjust
CIRAWGamutMapping
CIFilterShape
CIFilterShapePrivate
CISimpleTile
CIAffineTile
CIClamp
CIAffineClamp
CICircleSplashDistortion
CIModTransition
CICopyMachineTransition
CITileFilter
CITile2Filter
CIFourfoldRotatedTile
CISixfoldRotatedTile
CITwelvefoldReflectedTile
CIFourfoldTranslatedTile
CIGlideReflectedTile
CIEightfoldReflectedTile
CIFourfoldReflectedTile
CISixfoldReflectedTile
CILineOverlay
CISpotColor
CIComicEffect
CIBoxBlur
PrivateLocalLight
CILocalLightMapPrepare
CILocalLightFilter
CIColorMap
CIMedianFilter
CIBarsSwipeTransition
CIDisintegrateWithMaskTransition
CIFlashTransition
BuiltIn
AutoROI
CIDocumentEnhancer
CIPaperWash
CIPerspectiveTransformWithExtent
CIPerspectiveTransform
CIPerspectiveTile
CIPerspectiveCorrection
CIBumpDistortion
CIBumpDistortionLinear
CIColorPolynomial
CIColorCrossPolynomial
CIRAWFilterImpl
CustomAccessors
WhiteBalance
CIHeightFieldFromMask
CIColorClamp
CIGlassDistortion
CIStretchCrop
CINinePartStretched
CINinePartTiled
CIPhotoEffect3D
CIPhotoEffect3DVivid
CIPhotoEffect3DVividWarm
CIPhotoEffect3DVividCool
CIPhotoEffect3DDramatic
CIPhotoEffect3DDramaticWarm
CIPhotoEffect3DDramaticCool
CIPhotoEffect3DSilverplate
CIPhotoEffect3DCommercial
CIPhotoEffect3DNoir
CIHistogramDisplayFilter
_CICompositeFilter
CISourceOverCompositing
CISourceInCompositing
CISourceOutCompositing
CISourceAtopCompositing
CIAdditionCompositing
CIMultiplyCompositing
CIMinimumCompositing
CIMaximumCompositing
CIPlusDarkerCompositing
CIPlusLighterCompositing
CILocalContrast
CIAccordionFoldTransition
CIBarcodeDetector
CIDisparityRefinement
CIConvolution3X3
CIConvolution5X5
CIConvolution7X7
CIConvolution9Horizontal
CIConvolution9Vertical
CUIScaleClampFilter
CUIInnerGlowOrShadowFilter
CUIOuterGlowOrShadowFilter
CUIShapeEffectBlur1
CUIOuterBevelEmbossFilter
CUIInnerBevelEmbossFilter
AutoCropper
CILensModelCalculatorNative
CILensModelCalculator
CILensModelApply
CIOpacity
CICircularWrap
AutoAdjustCrop
@8@0:4
@12@0:4i8
v8@0:4
d12@0:4r^{CIBurstSupportVector=d[7d]}8
f8@0:4
B8@0:4
v12@0:4f8
^{__SVMParameters=[7{__SVMScaleOffset=ff}]ddii^{CIBurstSupportVector}^{CIBurstSupportVector}}8@0:4
v12@0:4^{__SVMParameters=[7{__SVMScaleOffset=ff}]ddii^{CIBurstSupportVector}^{CIBurstSupportVector}}8
[7d]
^{__SVMParameters=[7{__SVMScaleOffset=ff}]ddii^{CIBurstSupportVector}^{CIBurstSupportVector}}
@12@0:4@8
v12@0:4B8
v28@0:4@8@12@16@20@?24
i12@0:4@8
v12@0:4@8
@16@0:4@8B12
v16@0:4@8i12
i8@0:4
v12@0:4i8
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_semaphore>"
@"NSMutableArray"
@"NSString"
@"CIBurstImageFaceAnalysisContext"
@"CIBurstYUVImage"
@"NSDictionary"
@"NSCountedSet"
@"NSMutableDictionary"
^{__sFILE=*iiss{__sbuf=*i}i^v^?^?^?^?{__sbuf=*i}^{__sFILEX}i[3C][1C]{__sbuf=*i}iq}
@"CIBurstActionClassifier"
l32@0:4*8L12{CGRect={CGPoint=ff}{CGSize=ff}}16
l36@0:4r*8L12{CGRect={CGPoint=ff}{CGSize=ff}}16[4{CGPoint=ff}]32
l84@0:4r*8L12{CGRect={CGPoint=ff}{CGSize=ff}}16*32L36{CGRect={CGPoint=ff}{CGSize=ff}}40{CGRect={CGPoint=ff}{CGSize=ff}}56^{CGPoint=ff}72L76C80
l36@0:4^{MetalFaceMaskEyeQuads_t=IIC[16{MetalFaceMaskQuad_t=}]}8*12L16{CGRect={CGPoint=ff}{CGSize=ff}}20
{CPUColorCube="data"[32768C]}
{MetalFaceMaskCubeInputScaling_t="offset""scale"}
{IRect={IPoint=qq}{ISize=II}}8@0:4
@"CIImage"
@"CIVector"
@"NSNumber"
@"CIContext"
B24@0:4@8@12@16^@20
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4i8@12{CGRect={CGPoint=ff}{CGSize=ff}}16
i12@0:4i8
@16@0:4@8f12
@28@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24
{CGRect={CGPoint=ff}{CGSize=ff}}8@0:4
v24@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8
{CGRect="origin"{CGPoint="x"f"y"f}"size"{CGSize="width"f"height"f}}
@12@0:4f8
f24@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8
{CGPoint=ff}8@0:4
v16@0:4{CGPoint=ff}8
{CGSize=ff}8@0:4
v16@0:4{CGSize=ff}8
{CGPoint="x"f"y"f}
{CGSize="width"f"height"f}
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8f24f28
{CGRect={CGPoint=ff}{CGSize=ff}}20@0:4@8@12^B16
@28@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24
i16@0:4@8@12
v16@0:4@8@12
v20@0:4@8{CGSize=ff}12
d8@0:4
v16@0:4d8
@"FCRFaceDetector"
@12@0:4^{_NSZone=}8
v24@0:4^^f8^^f12^^f16^^f20
v12@0:4^f8
{GridROI_t=iiii}8@0:4
f16@0:4@8@12
v24@0:4{GridROI_t=iiii}8
v20@0:4@8^f12^f16
f12@0:4@8
^S8@0:4
f12@0:4f8
^f8@0:4
[1024f]
[256S]
{FastRegistration_Signatures="piRow"^f"nPiRow"I"piRowTable"{Projections_meanStdTable="sumTable"^f"sumSqTable"^f}"piCol"^f"nPiCol"I"piColTable"{Projections_meanStdTable="sumTable"^f"sumSqTable"^f}}
^{SharpnessGridElement_t=CCf}
{GridROI_t="startX"i"startY"i"endX"i"endY"i}
v12@0:4@"NSCoder"8
@12@0:4@"NSCoder"8
@24@0:4@8i12C16i20
C8@0:4
@"NSData"
@24@0:4@8B12i16i20
@24@0:4@8i12i16i20
@16@0:4^{CGContext=}8@12
@16@0:4@8@12
i44@0:4@8^v12i16{CGRect={CGPoint=ff}{CGSize=ff}}20i36^{CGColorSpace=}40
^{CGColorSpace=}8@0:4
v44@0:4@8^v12i16{CGRect={CGPoint=ff}{CGSize=ff}}20i36^{CGColorSpace=}40
v16@0:4@8^{__CVBuffer=}12
v36@0:4@8^{__CVBuffer=}12{CGRect={CGPoint=ff}{CGSize=ff}}16^{CGColorSpace=}32
v12@0:4r*8
v36@0:4@8{CGPoint=ff}12{CGRect={CGPoint=ff}{CGSize=ff}}20
v44@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12{CGRect={CGPoint=ff}{CGSize=ff}}28
v36@0:4@8I12{CGRect={CGPoint=ff}{CGSize=ff}}16^{CGColorSpace=}32
v40@0:4@8I12I16{CGRect={CGPoint=ff}{CGSize=ff}}20^{CGColorSpace=}36
v40@0:4@8@12@16{CGRect={CGPoint=ff}{CGSize=ff}}20^{CGColorSpace=}36
^{CGImage=}28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
^{CGImage=}32@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28
^{CGImage=}36@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28^{CGColorSpace=}32
^{CGImage=}40@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28^{CGColorSpace=}32B36
^{CGLayer=}20@0:4{CGSize=ff}8^{__CFDictionary=}16
L8@0:4
@36@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28^{CGColorSpace=}32
B24@0:4@8i12^@16^{CGRect={CGPoint=ff}{CGSize=ff}}20
v32@0:4{CGAffineTransform=ffffff}8
{CGAffineTransform=ffffff}8@0:4
@16@0:4@8i12
^{CGImage=}44@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28^{CGColorSpace=}32B36L40
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@}8@0:4
@12@0:4^v8
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@}12@0:4@8
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@}16@0:4@8@12
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@}16@0:4@8^v12
@28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
@32@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12^@28
I8@0:4
@20@0:4@8@12@16
[8^v]
@"NSArray"8@0:4
@"CIFilter"12@0:4@"NSArray"8
B12@0:4@8
^{CGImageMetadata=}28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
@28@0:4^{CGImageMetadata=}8{CGRect={CGPoint=ff}{CGSize=ff}}12
@20@0:4@8i12f16
@12@0:4^{CGImage=}8
@16@0:4^{CGImage=}8@12
@12@0:4^{CGLayer=}8
@16@0:4^{CGLayer=}8@12
@32@0:4@8L12{CGSize=ff}16i24@28
@32@0:4@8L12{CGSize=ff}16i24^{CGColorSpace=}28
@28@0:4I8{CGSize=ff}12B20^{CGColorSpace=}24
@24@0:4I8{CGSize=ff}12@20
@28@0:4I8{CGSize=ff}12B20@24
@12@0:4^{__CVBuffer=}8
@16@0:4^{__CVBuffer=}8@12
@16@0:4@8@?12
@20@0:4^{__IOSurface=}8@12^v16
v12@0:4^{CGImage=}8
^{CGImage=}8@0:4
@20@0:4^{CGImageSource=}8@12B16
@20@0:4^{CGImageSource=}8L12@16
v12@0:4^{__CVBuffer=}8
^{__CVBuffer=}8@0:4
@24@0:4f8f12f16f20
{CGAffineTransform=ffffff}12@0:4i8
{CGAffineTransform=ffffff}12@0:4I8
@12@0:4I8
@32@0:4{CGAffineTransform=ffffff}8
@36@0:4{CGAffineTransform=ffffff}8B32
@24@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8
@16@0:4d8
@12@0:4^{CGColorSpace=}8
^v8@0:4
{CGRect={CGPoint=ff}{CGSize=ff}}28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
@20@0:4@8i12@16
@20@0:4@8@12^@16
@24@0:4@8@12i16^@20
B12@0:4i8
i16@0:4@8^{Kernel=^^?{atomic<unsigned int>=AI}**B^{SerialIntArray}^{SerialStringArray}^{__CFString}BBBBBi}12
@36@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@?24@28@32
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@?24@28
v12@0:4:8
:8@0:4
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28
@40@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@?24@28@32@36
@36@0:4@8@12{CGSize=ff}16i24B28^{CGColorSpace=}32
@32@0:4@8L12L16i20^{CGColorSpace=}24@28
@32@0:4@?8L12L16i20^{CGColorSpace=}24@28
@36@0:4@?8L12L16i20^{CGColorSpace=}24B28@32
{vec2=ff}8@0:4
@"NSValue"
@24@0:4@8i12^{CGColorSpace=}16@20
@20@0:4@8^{CGColorSpace=}12@16
B32@0:4@8@12i16^{CGColorSpace=}20@24^@28
B28@0:4@8@12^{CGColorSpace=}16@20^@24
@"CIColor"
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24@28
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24^{CGColorSpace=}28
v28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
@16@0:4r^f8L12
@16@0:4f8f12
@20@0:4f8f12f16
@16@0:4{CGPoint=ff}8
f12@0:4L8
(?="vec"[4f]"ptr"^f)
@36@0:4@8@12@16{CGRect={CGPoint=ff}{CGSize=ff}}20
@12@0:4B8
@52@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28@32@36@40@44^@48
@44@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28@32@36^@40
@40@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28@32^@36
@36@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28^@32
@"NSAttributedString"
@44@0:4^{__IOSurface=}8{Texture=(?={?=II}^v)}12B20{CGRect={CGPoint=ff}{CGSize=ff}}24^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@}40
^{__IOSurface=}8@0:4
^{__IOSurface=}
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@}
@"<MTLTexture>"
@"<MTLTexture>"8@0:4
@"<MTLCommandBuffer>"8@0:4
@"<MTLCommandBuffer>"
r^v8@0:4
@56@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24Q28i36i40@44@?48@?52
Q12@0:4@8
v24@0:4@8@12I16@20
v40@0:4@8@12I16@20I24{?=III}28
@"<MTLDevice>"
@"<MTLFunction>"
@20@0:4@8@12*16
@20@0:4d8@16
@28@0:4d8d16@24
@36@0:4^v8i12{CGRect={CGPoint=ff}{CGSize=ff}}16i32
@40@0:4^v8i12{CGRect={CGPoint=ff}{CGSize=ff}}16i32@36
B36@0:4^v8i12{CGRect={CGPoint=ff}{CGSize=ff}}16i32
^{CIBitmapContextPrivate=^vi{CGRect={CGPoint=ff}{CGSize=ff}}i}
@20@0:4@8f12f16
@24@0:4@8@12@16@20
@"NSArray"
@12@0:4r^f8
@12@0:4r^d8
r^f8@0:4
[256f]
^{CIRenderDestinationInternal=^{RenderDestination}IIi^{CGColorSpace}IBBiBB@}8@0:4
^{RenderDestination=^^?{atomic<unsigned int>=AI}}8@0:4
@28@0:4^{RenderDestination=^^?{atomic<unsigned int>=AI}}8I12I16i20^{CGColorSpace=}24
^{RenderTask=^^?{atomic<unsigned int>=AI}*iiBL^{Node}{CGRect={CGPoint=ff}{CGSize=ff}}iQ^{__CFString}{vector<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}{__compressed_pair<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > *, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}}}dIII}16@0:4^{Image=^^?{atomic<unsigned int>=AI}{CGRect={CGPoint=ff}{CGSize=ff}}^{__CFURL}^v^vI}8^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLiB[1024{TreeCacheElement=Q^{Kernel}}]I^{ObjectCache<CI::Node>}^{ObjectCache<CI::Node>}dd@^{RenderTask}iBI@@}12
@28@0:4I8I12L16^{CGColorSpace=}20@?24
@28@0:4I8I12I16@20@?24
@24@0:4I8I12I16I20
@28@0:4^v8I12I16I20i24
v12@0:4I8
v12@0:4^{CGColorSpace=}8
@12@0:4^{RenderTask=^^?{atomic<unsigned int>=AI}*iiBL^{Node}{CGRect={CGPoint=ff}{CGSize=ff}}iQ^{__CFString}{vector<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}{__compressed_pair<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > *, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}}}dIII}8
^{RenderTask=^^?{atomic<unsigned int>=AI}*iiBL^{Node}{CGRect={CGPoint=ff}{CGSize=ff}}iQ^{__CFString}{vector<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}{__compressed_pair<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > *, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}}}dIII}8@0:4
@12@0:4^@8
@44@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12@28{CGPoint=ff}32^@40
@24@0:4@8@12B16^@20
B44@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12@28{CGPoint=ff}32^@40
@16@0:4@8^@12
@16@0:4@8I12
@20@0:4@8I12^{CGColorSpace=}16
@24@0:4@8I12^{CGColorSpace=}16@20
@20@0:4@8@12^{CGColorSpace=}16
r*12@0:4I8
v16@0:4@8^{CGColorSpace=}12
s8@0:4
^{CGColorSpace=}
v24@0:4@8i12i16i20
v20@0:4@8@12@16
@16@0:4r^{CGPoint=ff}8B12
@12@0:4r^{CGPoint=ff}8
v24@0:4^f8i12f16r^{CGPoint=ff}20
@12@0:4#8
v12@0:4^{?=Bffff[3f]}8
@12@0:4^f8
{CGRect={CGPoint=ff}{CGSize=ff}}28@0:4{CGPoint=ff}8{CGSize=ff}16f24
{CGRect={CGPoint=ff}{CGSize=ff}}20@0:4@8{CGSize=ff}12
B24@0:4^{CGImage=}8^{?=*iiiiiiif}12L16L20
B16@0:4^{CGImage=}8^{?=*iiiiiiif}12
@16@0:4@8^{?=[256c][32c]{?=*iiiiiiif}ii{?=iiii}^{CGColorSpace}IiiBf}12
@12@0:4^{?=[256c][32c]{?=*iiiiiiif}ii{?=iiii}^{CGColorSpace}IiiBf}8
@24@0:4*8{CGSize=ff}12L20
@44@0:4*8{CGRect={CGPoint=ff}{CGSize=ff}}12{CGSize=ff}28L36@40
{?=iiii}8@0:4
^{?=i{CGPoint=ff}iiii{?=*iiiiiiif}{?=iiii}{?=iiii}B{?=iiii}iBf{?=iiiiiiiiiiB{?=iiii}{?=iiii}iiif{?=ifBifff}{?=iiii}}{?={CGPoint=ff}ifffi{?=iiii}fBiiiiffff}}8@0:4
i20@0:4^{?=*iiiiiiif}8^{?=*iiiiiiif}12^{?=*iiiiiiif}16
B52@0:4^{?=*iiiiiiif}8^{?=*iiiiiiif}12^{?=*iiiiiiif}16{?=iiii}20^{?=*iiiiiiif}36^{?=*iiiiiiif}40^{?=iiii}44^{?=iiii}48
B36@0:4^{?=*iiiiiiif}8{?=iiii}12^{?=*iiiiiiif}28^{?=*iiiiiiif}32
i48@0:4{CGPoint=ff}8B16{?=iiii}20i36f40B44
^{?=i{CGPoint=ff}iiii{?=*iiiiiiif}{?=iiii}{?=iiii}B{?=iiii}iBf{?=iiiiiiiiiiB{?=iiii}{?=iiii}iiif{?=ifBifff}{?=iiii}}{?={CGPoint=ff}ifffi{?=iiii}fBiiiiffff}}12@0:4i8
i16@0:4i8f12
f20@0:4^{?=Biiffiiiiffiifiiiiiifiiii}8^f12i16
f20@0:4f8i12i16
v40@0:4^{?=i[4{?=fiifffiif}]}8i12i16f20f24i28i32f36
B64@0:4^{?=*iiiiiiif}8^{?=*iiiiiiif}12^{?=*iiiiiiif}16^{?=*iiiiiiif}20i24i28{?=iiii}32^{?=Biiffiiiiffiifiiiiiifiiii}48^{?=i[4{?=fiifffiif}]}52i56B60
v56@0:4{?=iiii}8{?=iiii}24^{?=Biiffiiiiffiifiiiiiifiiii}40f44B48i52
i16@0:4i8i12
i144@0:4{?=iiiiiiiiiiB{?=iiii}{?=iiii}iiif{?=ifBifff}{?=iiii}}8
B20@0:4^f8@12@16
B20@0:4^i8@12@16
B20@0:4^B8@12@16
^{?=[256c][32c]{?=*iiiiiiif}ii{?=iiii}^{CGColorSpace}IiiBf}
^{CGImageBlockSet=}
^{__CFData=}
[32{?="tag"i"pt2"{CGPoint="x"f"y"f}"eyeCase"i"forceCase"i"npixels"i"bignpixels"i"fullNew"{?="baseAddress"*"width"i"height"i"rowSamples"i"rowBytes"i"size"i"samplesPerPixel"i"bytesPerSample"i"resolution"f}"YR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}"psTemplate"{?="lo"i"med"i"hi"i"average"i}"pupilShadeAlignment"B"matchingTemplate"{?="lo"i"med"i"hi"i"average"i}"faceIndex"i"left"B"IOD"f"data"{?="origHitX"i"origHitY"i"snapHitX"i"snapHitY"i"bitmaskSeedX"i"bitmaskSeedY"i"bitmaskThreshold"i"cornealReflectionSeedX"i"cornealReflectionSeedY"i"cornealReflectionThreshold"i"align"B"mTemplate"{?="lo"i"med"i"hi"i"average"i}"existingTemplate"{?="lo"i"med"i"hi"i"average"i}"averageSkinMapY"i"characterizeCase"i"finalEyeCase"i"IOD"f"O"{?="orientation"i"SNR"f"N90"B"redBitmaskArea"i"imageCenterX"f"imageCenterY"f"halfDiagonalSize"f}"CR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}}"BI"{?="centroid"{CGPoint="x"f"y"f}"area"i"ovalness"f"contrast"f"mincontrast"f"nborder"i"IR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}"aspectRatio"f"touchingEdge"B"localmax"i"localmaxrow"i"localmaxcol"i"localfloor"i"rgmean"f"rgstd"f"ymean"f"ystd"f}}]
{?="lo"i"med"i"hi"i"average"i}
{?="baseAddress"*"width"i"height"i"rowSamples"i"rowBytes"i"size"i"samplesPerPixel"i"bytesPerSample"i"resolution"f}
[3{?="baseAddress"*"width"i"height"i"rowSamples"i"rowBytes"i"size"i"samplesPerPixel"i"bytesPerSample"i"resolution"f}]
[3{?="minrow"i"maxrow"i"mincol"i"maxcol"i}]
[20{CGPoint="x"f"y"f}]
[20{?="a"f"b"f"c"f}]
[20B]
[65536C]
[8[3i]]
{Rectangle=dddd}60@0:4{vec2=ff}8{vec3=fff}16{vec4=ffff}28{vec4=ffff}44
{CGRect={CGPoint=ff}{CGSize=ff}}24@0:4{vec4=ffff}8
@20@0:4^{__CVBuffer=}8@12@16
{CGAffineTransform=ffffff}28@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24
@20@0:4@8i12^{CGAffineTransform=ffffff}16
@20@0:4@8^I12^I16
@96@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8B24{CGPoint=ff}28B36{CGPoint=ff}40B48{CGPoint=ff}52B60f64B68i72B76i80B84B88B92
@56@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8{CGPoint=ff}24{CGPoint=ff}32{CGPoint=ff}40{CGPoint=ff}48
@12@0:4^{?={CGRect={CGPoint=ff}{CGSize=ff}}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}@}8
@"CIQRCodeDescriptor"
@64@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8{CGPoint=ff}24{CGPoint=ff}32{CGPoint=ff}40{CGPoint=ff}48@56@60
@12@0:4^{CGColor=}8
@28@0:4f8f12f16f20^{CGColorSpace=}24
@24@0:4f8f12f16^{CGColorSpace=}20
^{CGColor=}8@0:4
[3^v]
f20@0:4f8f12^f16
v16@0:4f8f12
v20@0:4f8f12f16
{?=ff}8@0:4
{CGPoint=ff}12@0:4L8
i12@0:4^f8
v20@0:4@8I12^f16
v16@0:4@8I12
{?="i"f"q"f}
@"CIEnhancementHistogram"
^{OpaqueVTPixelTransferSession=}
^{__CVBuffer=}
^{vImage_Buffer=^vIII}
@"NSObject<OS_dispatch_data>"
@"<MTLLibrary>"
@32@0:4@8@12i16i20B24^{CGColorSpace=}28
@24@0:4@8i12B16^{CGColorSpace=}20
{CGRect={CGPoint=ff}{CGSize=ff}}16@0:4f8f12
r*8@0:4
@"CIBarcodeDescriptor"
@28@0:4@8@12@16@20@?24
f20@0:4@8^i12i16
@?8@0:4
v12@0:4@?8
^{?=^ii}16@0:4i8i12
i16@0:4{?=^ii}8
^i16@0:4{?=^ii}8
B16@0:4{?=^ii}8
B20@0:4^{?=^ii}8^i12i16
v12@0:4^{?=^ii}8
i16@0:4^{?=^ii}8i12
^{?=^ii}12@0:4^{?=^ii}8
^{?=^ii}16@0:4^{?=^ii}8^{?=^ii}12
^{?=^ii}20@0:4^{?=^ii}8i12i16
^{?=^ii}12@0:4i8
B20@0:4^i8i12i16
[256i]
^{?=^ii}
@"AVCameraCalibrationData"
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12f28
v16@0:4^v8^v12
@"CIBurstImageSetInternal"
v16@0:4*8i12
@16@0:4^{CGImage=}8i12
*8@0:4
v12@0:4*8
@24@0:4@8@12@16^{CGColorSpace=}20
@12@0:4^{filterShape={CGRect={CGPoint=ff}{CGSize=ff}}}8
@16@0:4i8i12
^{CGSRegionObject=}8@0:4
@16@0:4^{WarpKernel=^^?{atomic<unsigned int>=AI}**B^{SerialIntArray}^{SerialStringArray}^{__CFString}BBBBBi}8^{SerialObjectPtrArray=iii^^v}12
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24i28
{CGRect={CGPoint=ff}{CGSize=ff}}36@0:4^{WarpKernel=^^?{atomic<unsigned int>=AI}**B^{SerialIntArray}^{SerialStringArray}^{__CFString}BBBBBi}8^{SerialObjectPtrArray=iii^^v}12@16{CGRect={CGPoint=ff}{CGSize=ff}}20
^{CGImageSource=}
@"NSObject"
@"CIFilter"
@16@0:4^{CGImageSource=}8@12
{CGAffineTransform=ffffff}12@0:4@8
@16@0:4r^d8@12
v20@0:4^@8^@12^@16
v24@0:4@8@12^@16^@20
@20@0:4{CGSize=ff}8B16
@24@0:4@8^@12B16i20
{CGRect={CGPoint=ff}{CGSize=ff}}28@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8f24
{CGRect={CGPoint=ff}{CGSize=ff}}40@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8{CGRect={CGPoint=ff}{CGSize=ff}}24
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4{CGSize=ff}8{CGRect={CGPoint=ff}{CGSize=ff}}16
i16@0:4{CGSize=ff}8
{CGRect={CGPoint=ff}{CGSize=ff}}40@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8{CGSize=ff}24{CGPoint=ff}32
{CGRect={CGPoint=ff}{CGSize=ff}}36@0:4{CGSize=ff}8{CGPoint=ff}16i24{CGSize=ff}28
{CGRect={CGPoint=ff}{CGSize=ff}}20@0:4{CGSize=ff}8@16
i48@0:4{CGSize=ff}8{CGRect={CGPoint=ff}{CGSize=ff}}16{CGRect={CGPoint=ff}{CGSize=ff}}32
{CGRect={CGPoint=ff}{CGSize=ff}}52@0:4{CGSize=ff}8{CGRect={CGPoint=ff}{CGSize=ff}}16i32{CGRect={CGPoint=ff}{CGSize=ff}}36
{CGPoint=ff}40@0:4{CGPoint=ff}8{CGPoint=ff}16{CGPoint=ff}24{CGPoint=ff}32
@40@0:4@8@12@16{CGRect={CGPoint=ff}{CGSize=ff}}20^{CGRect={CGPoint=ff}{CGSize=ff}}36
@32@0:4@8^{CGImage=}12{CGRect={CGPoint=ff}{CGSize=ff}}16
v56@0:4@8{CGAffineTransform=ffffff}12{CGRect={CGPoint=ff}{CGSize=ff}}36^{CGRect={CGPoint=ff}{CGSize=ff}}52
%{public}s %@: instantiating abstract barcode descriptor objects is prohibited
%{public}s %@: requires coder that supports keyed coding of objects
%{public}s %{public}@: symbolVersion must be in the range of [1,40]
%{public}s %{public}@: invalid errorCorrectionLevel
%{public}s %{public}@: layerCount must be in the range of [1,32]
%{public}s %{public}@: dataCodewordCount must be in the range of [1,2048]
%{public}s %{public}@: rowCount must be in the range of [3,90]
%{public}s %{public}@: columnCount must be in the range of [1,30]
%{public}s unsupported object %{public}@ for key %{public}@.
%{public}s unsupported key %{public}@.
%{public}s can only be created with ES 2.0 or 3.0 EAGLContexts.
%{public}s format %{public}s is unsupported%{public}s.
%{public}s unsupported colorspace.
%{public}s rowBytes must be a multiple of %ld.
%{public}s unsupported format.
%{public}s unsupported plane count.
%{public}s CI_CONVERSION: Rendered to intermediate YCC444 buffer because CI can not render directly to %{public}s.
%{public}s could allocate memory.
%{public}s could not access buffer.
%{public}s cannot render an infinite image into an infinite context.
%{public}s requires a CIContext created with a GL context or a CG context.
%{public}s given an infinite rect
%{public}s target must be GL_TEXTURE_2D.
%{public}s requires a GL or CL context!
%{public}s requires a Metal context (with the same device used to create the given texture).
%{public}s was called but ignored.
[CIContext createCGImage:fromRect:format:colorSpace:] unsupported format %{public}s.
[CIContext createCGImage:fromRect:format:colorSpace:] unsupported colorspace.
CIContext workingformat must be %s. Ignoring request for %{public}s.
CIContext workingformat must be %s. Ignoring request.
CIContext for CL: do something about disabling software fallback here.
CIContext workingformat must be %{public}s. Ignoring request for %{public}s.
CIContext workingformat must be %{public}s. Ignoring request.
CIContext kCIContextOutputColorSpace must be [NSNull null], or a CGColorSpaceRef with kCGColorSpaceModelRGB or kCGColorSpaceModelMonochrome that supports output.
CIContext kCIContextWorkingColorSpace must be [NSNull null], or a CGColorSpaceRef with kCGColorSpaceModelRGB that supports output.
%{public}s option CIUserInfo is no longer encoded for security.
%{public}s first parameter should be CIKernel.
%{public}s kCIApplyOptionDefinition is not a CIFilterShape or an NSArray with four elements.
%{public}s kCIApplyOptionExtent is not an NSArray with four elements. Ignoring.
%{public}s The filter PXSoftProofingFilter has an incorrect ROI method for sampler index 1.  This may fail in the future.
%{public}s The filter PX_CIF_Noise has an incorrect ROI method for sampler index 1.  This may fail in the future.
[%@ apply:...] First argument should be CIKernel.
[%{public}@ apply:...] The last key "%{public}@" at index %d is followed by nil. It will be ignored.
[%{public}@ apply:...] Argument at index %d should be a CIImage, CISampler, CIVector, or NSNumber.
CIFilter %{public}@ cannot be serialized because %{public}@ value is a %{public}@. Only NSString, NSNumber and CIVector is supported at this time.
%{public}s warning: affine+crop region falls outside of image area, results may be wrong
%{public}s now returns nil.  Use _filterArrayFromProperties:inputImageExtent: instead
[CIImage initWithIOSurface:options:] failed because surface format was %{public}.4s.
[CIImage initWithIOSurface:options:] failed because surface format was %ld.
[CIImage initWithIOSurface:options:] kCIImageSurfaceFormat option value is not compatable with actual format of surface.
[CIImage initWithIOSurface:options:] kCIImageEdgeRepeat option not supported. Ignoring.
[CIImage initWithCGImage:] kCIImageEdgeRepeat option not supported. Ignoring.
%{public}s failed because the CGImage is nil.
%{public}s CI_CONVERSION: Rendered to intermediate ABGR8 CGImage because CI can not directly support a %{public}s CGImage.
%{public}s failed because the CGImage format is not supported and we failed to create a CGBitmapContext.
[CIImage initWithBitmapData:] failed because the format '%{public}s' is not supported.
[CIImage initWithBitmapData:] failed because the format is not supported.
[CIImage initWithBitmapData:] failed because data length was less than height times bytesPerRow.
%{public}s kCIImageEdgeRepeat option not supported. Ignoring.
%{public}s does not support Metal on this platform.
[CIImage initWithCVPixelBuffer:optiopns:] failed because it is not a CVPixelBuffer.
[CIImage initWithCVImageBuffer:] kCIImageEdgeRepeat option not supported. Ignoring.
%{public}s failed because the buffer is nil.
%{public}s failed because the buffer is not a CVPixelBufferRef.
%{public}s failed because its pixel format %{public}.4s is not supported.
%{public}s failed because its pixel format %ld is not supported.
%{public}s failed because the type of buffer is not yet supported.
%{public}s ColorSpace must be an RGB CGColorSpaceRef that supports output.
%{public}s ColorSpace must be an RGB or Gray CGColorSpaceRef that supports output.
%{public}s ColorSpace must be an RGB CGColorSpaceRef.
%{public}s properties is not a NSDictionary.
%{public}s object at index %d of array is not a CIImage.
%{public}s CIUserInfo is no longer encoded for sake of security.
%{public}s CIUserInfo is no longer decoded for sake of security.
%{public}s not supported for keypath %{public}@.
[%{public}@ initWithString:] failed due to error parsing kernel source.
[%{public}@ initWithString:] failed because no valid kernels were in the string.
[%{public}@ initWithString:] failed because '%{public}s', the first kernel in the string, does not conform to supported calling convensions.
[CIWarpKernel initWithString:] failed because '%{public}s', the first kernel in the string, does not conform to the calling convensions of a CIWarpKernel.
[CIColorKernel initWithString:] failed because '%{public}s', the first kernel in the string, does not conform to the calling convensions of a CIColorKernel.
[CIKernel initWithString:] failed because '%s', the first kernel in the string, does not conform to supported calling convensions.
[%{public}@ initWithString:] failed because '%{public}s', the first kernel in the string, has an unsupported type for the parameter '%{public}s'.
[CIKernel kernelsWithString:] passed an empty or nil string.
[%{public}@ kernelsWithString:] kernel '%{public}s' failed because it does not conform to supported calling convensions.
[%{public}@ kernelsWithString:] kernel '%{public}s' failed because it has an unsupported type for the parameter '%s'.
%{public}@ is not an known pixel format name. Will use working format instead.
%{public}s Cannot initialize kernel with given library data.
kCIKernelOutputFormat value (%s) is not supported.Use one of these formats instead: %@
Warning: specified  as kernel attribute output format of %s and apply option kCIKernelOutputFormat of %s. The former will be used.
%{public}s argument count mismatch for kernel '%{public}s', expected %d but saw %d.
%{public}s type mismatch for kernel '%{public}s' parameter %d. %{public}sGot %{public}@.
%{public}s no image in arguments array.
%{public}s ignores callback and is not recomended.  Use applyWithExtent:arguments:options: instead.
%{public}s ignores callback and is not recomended.  Use applyWithExtent:arguments: instead.
%{public}s is not supported.  Use applyWithExtent:roiCallback:inputImage:arguments:options: instead.
%{public}s is not supported.  Use applyWithExtent:roiCallback:inputImage:arguments: instead.
%{public}s provided rect for kernel %{public}s is %{public}@ but should be at least %{public}@
CI_CONVERSION: Converted input surface to a new surface with required rowbytes alignment (of %d bytes).
Cannot render image (with Metal kernel '%s') using an %s context.
%{public}s requires an image with a finite non-empty extent.
%{public}s init is not a valid initializer for CIImageAccumulator
%{public}s failed because the extent is empty.
%{public}s failed because the format '%s' is not supported.
%{public}s failed because the format is not supported.
%{public}s blendKernel ignored (invalid value of type '%s').
%{public}s inputText must be a NSString.
%{public}s inputText must be a NSAttributedString.
%{public}s argumentDigest is 0 which will prevent CoreImage from caching %{public}s optimally.
%{public}s argument value for key %{public}s must be NSNumber, NSData, NSString, CIVector or CIColor for CoreImage to cache optimally.
CISampler value for key '%s' is nil. Skipping.
CISampler value for key '%s' must be a NSObject or a CGColorSpaceRef. Skipping.
CISampler option key must be a NSString. Skipping.
%{public}s ignoring kCISamplerBlurFormat because it is not supported.
%{public}s ignoring kCISamplerWrapPeriodic because it is not supported.
%{public}s ignoring kCISamplerAffineMatrix value because it is not a valid object '%@'.
%{public}s ignoring kCISamplerColorSpace value because it is not an RGB CGColorSpaceRef that supports output.
Failed to render - cannot access data from CGImage %p
CI_CONVERSION: (Metal) %{public}s_buffer
CI_CONVERSION: (Metal) %{public}s_texture
CI_CONVERSION: (CPU) %{public}s
%{public}s init is not a valid initializer for CIRenderDestination
%{public}s requires a valid pixelBuffer argument.
%{public}s requires a pixelBuffer with valid width and height.
%{public}s unsupported pixelBuffer format.
%{public}s unsupported pixelBuffer plane count.
%{public}s not supported yet.
%{public}s requires a valid pixelBuffer provider block.
%{public}s requires a valid width and height.
%{public}s requires a valid data argument.
%{public}s requires a valid bytesPerRow.
%{public}s bytesPerRow must be greater than or equal to width times format's bytes per pixel .
%{public}s unsupported alpha mode.
%{public}s unsupported colorspace for this destination.
%{public}s blendKernel must be a subclass of CIBlendKernel.
Destination blend kernel is not supported for provider backed destinations.
%{public}s init is not a valid initializer for CIRenderInfo
%{public}s init is not a valid initializer for CIRenderTask
%{public}s Unexpected error in the backing renderer.
%{public}s The CIContext is invalid.
%{public}s The destination is nil.
%{public}s The destination is invalid.
%{public}s The image extent and destination extent do not intersect.
%{public}s %s.
Failed to allocate IOSurface
%{public}s colorSpace must be kCGColorSpaceModelRGB.
CIBarcodeGenerator could not generate an image
%{public}s %{public}@
Value for key inputBarcodeDescriptor of type CIDataMatrixCodeDescriptor is not yet supported
%{public}s Unsupported value for key inputBarcodeDescriptor of class %{public}@
input image(s) to CIDepthBlurEffect apply is of inifite extent; returning input image
%{public}s inputAuxDataMetadata should be nil or a CGImageMetadata object.
Failed to parse rendering parameters
Params data too small
Invalid parameters data; no start marker found
Incorrect parameters version
Size mismatch
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
?P$
?Ds(
