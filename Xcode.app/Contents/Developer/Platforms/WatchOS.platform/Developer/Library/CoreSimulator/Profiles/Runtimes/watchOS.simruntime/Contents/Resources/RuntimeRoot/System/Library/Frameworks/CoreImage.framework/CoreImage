?333333
?0123456789ABCDEF
 c@333333
?ffffff
@XUUUUU
?OUUUUU
_>Y1\
?333333
f@33333Cm@vq
?ffffff
#<33s?o
 ?z7
:D7V
"nN%
AA)Z
>Y1\
?*Ral!
WXp?
>J6h
iQ~V?
iN^d
iN^d
N} y
?9(a
g|_\
&4I,)
|F"4
_Cp\
vj.7
ip[[
'Hlw
?VF#
uoEb
?\='
@ut\
?'/2
h?RD
"nN%
t><K
!sePmp
|zlK
c\qq
0Xr
9x&4
^Cp\
`!sePm
?aobHN
.5B?S
i3NCT
"nN%
|a2U0
%Tpx
"nN%
~NA~
lscz
AA)Z
r?jl@
<e5]O
! _B
?`vO
^Cp\F
@Y32
d:tz
N} y
?Uka
SrNl
-:Yj
tBFe@
@!"5
O7+]3n@
h8en
;a@O
?!=E
"LQ.
OVW
"nN%
0Xr
W zR&
/5B?S
|a2U0*
?EUwv
E|'f
i3NCT
1zn!
"nN%
#gaO;|
[@h=|
2uWv
 |(
?K[\
p}?33S?
L>333?
?ffffff
|?5^
@ffffff
vH7B
W4vC
9Y>)F$
MbP?-C
]r2<
 9^;Q
Dfff?
es-8R
es-8R
MbP?
$@M-[
N@\r
++MJ
?|'f
i@r3
 l@a
pw@L7
 |@)?
@gDio
?33333S7
800L80AL
RGBAABGRARGB
AhGRAfGR8Iic80C2f024v024800A80C1
r46l610L61AL6Ric61C2h00Ah00Lh0ALh0C1h0C2yuv2svuyhIic6Iic610Af00Af00LfIicf0C1f0ALf0C284ic
h3icf3ic
r46lfuv2fvuy01icr01cr03w
800L80AL
RGBAABGRARGB 
RGBAABGRARGBAhGRAfGR8Iic80C2f024v024800A80C1ARGBARGBARGBARGBf024f024v024v024r46l610L61AL6Ric61C2h00Ah00Lh0ALh0C1h0C2yuv2svuyhIic6Iic610Af00Af00LfIicf0C1f0ALf0C284icr46lAfGRr46lr46lh3icf3ic
r46lfuv2fvuy01icr01cr03w
333333
?333333
Mb@?
$@M-[
N@\r
++MJ
?|'f
i@r3
 l@a
pw@L7
 |@)?
@gDio
?33333S7
Ww'&l
333333
?ffffff
?333333
@333333
?333333
?333333
333333
:gUU
a2U0*
333333
?333333
?333333
?333333
?333333
?333333
?333333
?Zd;
333333
9@UUUUUU
P?333333
@UUUUUU
i?yCu
JQ/#
?333333
?~0d>
MbP?
MbP?
(knN 
$@ffffff
>B`e=
~%<(
?es-8R
es-8R
:gUU
?333?fff?fff?
eUB
m#39
?eUB
;gM$
?[+5
.z<g
`*h 
Kfie
?cc^G
?cWb
x/k 
7:Ba
:ua;
lErd
m|X5
tZ;z
APPL
mntrRGB XYZ 
acspAPPL
APPLsRGB
-APPL
desc
icprt
"wtpt
rXYZ
gXYZ
bXYZ
rTRC
bTRC
gTRC
desc
sRGB Linear
text
Copyright 2012 Apple Inc.
XYZ 
XYZ 
XYZ 
XYZ 
curv
pappl
mntrGRAYXYZ 
acspAPPL
none
-appl
desc
qcprt
#wtpt
kTRC
desc
Linear Gray Profile
text
Copyright Apple Inc., 2017
XYZ 
curv
?ffffff
?yCu
333333
?es-8R
?UUUUUU
?ffffff
@?fff?
@?fff?
@?fff?
@?fff?
REND
REND
AUUUUUU
?59$5r:
?59$5r:
0Xr
?g|_\
ADBE
mntrRGB XYZ 
;acspAPPL
none
-ADBE
cprt
2desc
kwtpt
bkpt
rTRC
gTRC
bTRC
rXYZ
gXYZ
bXYZ
text
Copyright 2000 Adobe Systems Incorporated
desc
Adobe RGB (1998)
XYZ 
XYZ 
curv
XYZ 
XYZ 
XYZ 
?ff&?ff&
Mbp?q
?333333
?ffffff
?333333
?333333
?ffffff
6@ff&
?ff&
objectAtIndexedSubscript:
objectForKeyedSubscript:
floatValue
boolValue
intValue
stringOption:in:theDefault:
isEqualToString:
containsString:
intOption:in:theDefault:
boolOption:in:theDefault:
floatOption:in:theDefault:
getCString:maxLength:encoding:
extentOption:in:theDefault:
array
retain
faceContextWithFaceArray:index:
numberWithFloat:
arrayWithObjects:count:
setUpWithOptions:
bitmapRectWithImageSubRectangle:
init
release
dealloc
count
printFaceArray
stringWithFormat:
addObject:
updateWithFaceIndex:
characterizePupilAndSpecularShine
alignPupils
doRepairExtraction
inverseImageTransformForOrientation:
transformRepairArray:
countByEnumeratingWithState:objects:count:
dataWithPropertyList:format:options:error:
localizedDescription
defaultCStringEncoding
propertyListWithData:options:format:error:
dictionary
numberWithInt:
setValue:forKey:
stringWithCString:encoding:
globalBitmapPointWithDictionaryPoint:
globalBitmapRectWithDictionaryRectArray:
bitmaskWithDictionary:
unpackGlobalRepairDictionary:
setObject:forKeyedSubscript:
dictionaryPointWithGlobalBitmapPoint:
dictionaryWithObjects:forKeys:count:
numberWithBool:
dictionaryRectArrayWithGlobalBitmapRect:
dictionaryWithBitmask:print:
packGlobalRepairDictionary:print:
packRepairDictionary:print:
leftHandedTransform:ofPoint:
transformGlobalRepairRecord:transform:
replaceObjectAtIndex:withObject:
mutableCopyOfArray:
autorelease
unpackRepairDictionary:
validateRepair:
computeSyntheticPupilBitmapWithRepair:returningBitmap:atImageLocation:
computeFilteredOvalBitmapWithRepair:returningBitmap:atImageLocation:
computeFilteredArbitraryBitmapWithRepair:returningBitmap:atImageLocation:
supportRectangleWithRepair:imageSize:
supportRectangleWithFaceArray:options:
setInspector:
repairExternalBuffer
repairMap
repairRect
bitmapPointWithDictionaryPoint:
dictionaryPointWithBitmapPoint:
bitmapRectWithDictionaryRectArray:
dictionaryRectArrayWithBitmapRect:
initWithExternalBuffer:subRectangle:rowBytes:options:
autoRepairWithFaceArray:
repairWithSide:
packRepairDictionary:
repairArray
printExecuteRepairError:
executeRepair:
inspector
fullBitmap
subRectangle
cameraType
orientation
computeType
forceFail
debugSyntheticPupils
showSpecularShine
syntheticPupilChannel
syntheticRepairTag
syntheticPupilShade
syntheticPupilSoftness
syntheticPupilReach
syntheticPupilSampling
syntheticSpecularShineSoftness
syntheticSpecularShineAlpha
sharpeningEdgeExtractRadius
sharpeningEdgeExtractThreshold
syntheticEyelidOcclusion
syntheticIrisInfill
inputImageExtent
printPupilSummary
printIODEtc
printRepairsSaved
printRepairsApplied
printFaceStatistics
printProminenceContainment
printProminenceAlternatives
printEyeOpenness
printConfidenceLog
printImproveBitmaskLevel
printImproveBitmaskConsistencyCheck
printIrisRingLevel
printNeededOcclusions
printFaceArrayLevel
ROIRect
faceIndex
avgLuminance
minLuminance
maxLuminance
skinval
faceArray
ioffx
ioffy
faceBitmap
syntheticRepairs
erError
failureCauses
ovalOutlinePointWithT:OC:
falloffFunctionName:
printRepair:
circleRadiusAndCenter:withPoint1:point2:andPoint3:
LHSpoint:isToLeftOfLineFromPoint:toPoint:
start12BitRandom:
radiusOfEllipseInDirection:a:b:angle:
next12BitRandom
applyFalloffFunction:toAlpha:discFactor:
adjacencyScoreInBitmask:atColumn:row:radius:
summarizeBitmap:withBitmask:radius:rect:returningInsideSummary:outsideBorderSummary:
computeBorderPoints:rect:inside:outside:
averageDifferenceBetweenInsideSummary:andOutsideBorderSummary:
printBorder:name:
countOfAdjacentValues:in:ofValue:atCol:row:radius:addingTo:
verifyBorderPoints:rect:inside:outside:error:
analyzeCoarseGrowBitmaskData:dataSize:context:
graphBitmaskGrowData:size:index:debugComments:
analyzeFineGrowBitmaskData:dataSize:context:
drawBitmask:index:debugComments:
insertIntoProminenceVettingHopper:measure:max:outside:confidence:distance:area:borderMax:borderMin:row:column:
localComputeBitmaskWithChannel:x:y:options:eyeCase:returningMaxData:isSpecularData:maxSpecularData:specularBitmask:
improveBitmask:radius:inChannel:rect:
dataWithBytes:length:
imageWithBitmapData:bytesPerRow:size:format:colorSpace:
imageWithREDEYEFORMATBitmap:
extent
imageByApplyingFilter:withInputParameters:
vectorWithX:Y:Z:W:
context
render:toBitmap:rowBytes:bounds:format:colorSpace:
facePoseYawAngle
findProminenceWithSide:record:
printProminenceSearchResultsWithTitle:hopperElement:maxData:toLine:maxLength:
infoWithPointer:faceIndex:eyeIndex:eyeCase:kind:p1:p2:p3:
bitmask:debugComments:toOval:
averageColorUnderBitmask:rect:eye:HSV:minSE:avgSE:maxSE:satSE:satSEFraction:satSERect:
gatherFaceStatistics
allocateAndPopulateBitmaps
eyeOpennessWithEyeIndex:
initChoiceRecord:type:title:plusWhiteTitle:name:canPlusWhite:canSpecular:metrics:
bitmaskWithSharpeningEdgeInRect:
acquireProminences:onSide:metrics:
winningProminence:metrics:
repairWithProminence:white:onSide:metrics:rect:
freeChoiceRecord:
freeBitmaps
pupilFractionWithEyeIndex:andPupilCenter:
pupilAspectWithEyeIndex:andPupilCenter:
removeObject:
ovalBoundsWithOC:
is2MImageWithBase:
needsEyelidOcclusionWithBase:side:upper:
hasBeautyMarkWithBase:side:
extractIrisColors:
analyzeIrisColors:side:
intersectRayOrigin:unitVector:withEllipseOrigin:a:b:angle:
defaultManager
fileExistsAtPath:isDirectory:
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
contentsOfDirectoryAtPath:error:
removeItemAtPath:error:
pathWithDirectory:file:
moveItemAtPath:toPath:error:
drawBitmask:withOval:index:comparison:salientMode:debugComments:
initAdjustmentData:
processAdjustmentData:intoRadiusChange:andShift:whichRadius:radiusValue:debugComments:
fileExistsAtPath:
directoryExistsAtPath:
createDirectoryAtPath:
directoryContents:
deleteAtPath:
renameFile:toFile:inDirectory:
setSvmParameters:
svmParameters
computeKernelValueWithSupportVector:
scaleVector
predictResult
initWithVersion:
isBurstAction
testAverageCameraTravelDistance
setTestAverageCameraTravelDistance:
testMaxRegistrationErrorIntegral
setTestMaxRegistrationErrorIntegral:
testMaxPeakRegistrationError
setTestMaxPeakRegistrationError:
testMeanPeakRegistrationError
setTestMeanPeakRegistrationError:
testBeginningVsEndAEMatrixVsAverageAdjacentAEMatrix
setTestBeginningVsEndAEMatrixVsAverageAdjacentAEMatrix:
testInOutRatio
setTestInOutRatio:
testMaxInnerDistance
setTestMaxInnerDistance:
testAverageRegistrationErrorSkewness
setTestAverageRegistrationErrorSkewness:
testMinRegionOfInterestSize
setTestMinRegionOfInterestSize:
testMaxRegistrationErrorSkewness
setTestMaxRegistrationErrorSkewness:
hasBeenScaled
testVector
_svmParameters
standardUserDefaults
persistentDomainForName:
objectForKey:
stringByAppendingPathComponent:
burstId
arrayWithCapacity:
defaultVersionString
setVersionString:
versionString
setVersion:
alloc
setWithCapacity:
version
dictionaryWithCapacity:
setBurstId:
setForceFaceDetectionEnable:
UTF8String
initWithCGImage:maxDimension:
dictionaryWithDictionary:
setDateFormat:
date
stringFromDate:
burstDocumentDirectory
objectAtIndex:
releaseImage
burstImages
isGarbage
registrationErrorIntegral
imageId
timestamp
latestFaceTimestamp
imageProps
numberWithDouble:
setObject:forKey:
image
width
height
addFacesToImageStat:imageSize:
faceStatArray
faceId
normalizedFaceRect
hasRollAngle
rollAngle
hasYawAngle
yawAngle
hasLeftEye
leftEyeRect
leftEyeBlinkScore
hasRightEye
rightEyeRect
rightEyeBlinkScore
smileScore
findFacesInImage:imageStat:
setTimeFaceDetectionDone:
setTimeBlinkDetectionDone:
timeFaceDetectionDone
timeBlinkDetectionDone
calculateFaceFocusInImage:imageStat:
adjustFaceIdsForImageStat:
dumpFaceInfoArray
computeImageData:faceIDCounts:
focusScore
leftEyeOpen
rightEyeOpen
smiling
smallFace
FCRLeftEyeFeaturesOffset
FCRRightEyeFeaturesOffset
FCRSmileFeaturesOffset
FCRBlinkFeaturesSize
FCRSmileFeaturesSize
Ybuffer
bytesPerRow
Cbuffer
dictionaryWithObjectsAndKeys:
writeToFile:atomically:
facesRoiRect
AEAverage
AETarget
AEStable
AFStable
aeMatrix
completionBlock
extractFacesFromMetadata:
initWithImageData:dict:identifier:imageProps:completionBlock:
setTemporalOrder:
doubleValue
setTimeReceived:
processClusters:
setSmiling:
normalizedFocusScore
computeEmotion:
temporalOrder
setEmotionallyRejected:
avgHorzDiffY
blurExtent
setImageScore:
setActionScore:
computeAEMatrixDifference:
canRegister
allocateMeanStdPingPongBuffers::::
assignMeanStdBuffers:
performRegistration:deltaCol:deltaRow:
maxSkewness
setMaxSkewness:
setTx:
setTy:
computeSmoothedGridROI:nextStat:
doLimitedSharpnessAndBlur
hasRegistrationData
countForObject:
collapseSharpnessGrid
setIsGarbage:
flagAsGarbage
roiSize
registrationErrorX
registrationErrorY
computeCameraTravelDistance
computeBeginningVsEndAEMatrixDiffVsAverageAdjacent
computeActionSelectionThreshold
computeScore:
writeGridROI:
actionScore
imageScore
lastObject
stringWithString:
calcFaceScores:
computeAllImageScores
faceRect
performEmotionalRejectionOnCluster:
findBestImage:useActionScores:
emotionallyRejected
selectCoverPhotoFromMultiple:burstSize:
addItemsFromCluster:
removeObjectAtIndex:
setBestImageIdentifiersArray:
forceFaceDetectionEnable
bestImageIdentifiersArray
bestImageIdentifiers
initWithOptions:
addYUVImage:properties:identifier:imageProps:completionBlock:
imageClusterForIdentifier:
isFaceDetectionForced
isPortrait
isAction
clusterArray
setClusterArray:
faceIDCounts
setFaceIDCounts:
allImageIdentifiers
setAllImageIdentifiers:
actionClassifier
setActionClassifier:
statsByImageIdentifier
setStatsByImageIdentifier:
clusterByImageIdentifier
setClusterByImageIdentifier:
burstLogFileName
setBurstLogFileName:
maxNumPendingFrames
setMaxNumPendingFrames:
enableAnalysis
setEnableAnalysis:
dummyAnalysisCount
setDummyAnalysisCount:
enableFaceCore
setEnableFaceCore:
enableDumpYUV
setEnableDumpYUV:
burstCoverSelection
setBurstCoverSelection:
dq_yuvdump
faceAnalysisContext
overrideImage
overrideProps
burstLogFileHandle
curClusterIndexToProcess
_versionString
_version
computeImageDistance:
numHWFaces
setDividerScore:
setLeftImage:
actionClusteringScore
setActionAmount:
dividerScore
setNoiseThreshold:
setHighNoiseThreshold:
leftImage
noiseThreshold
highNoiseThreshold
setTrueLocalMaximum:
compareDividers:
sortedArrayUsingSelector:
compareIndices:
addObjectsFromArray:
removeAllObjects
compareImageOrder:
imageByClampingToExtent
imageByUnpremultiplyingAlpha
applyWithExtent:roiCallback:arguments:
imageByPremultiplyingAlpha
imageByCroppingToRect:
customAttributes
outputImage
inputSource
setInputSource:
inputSigmaSpace
setInputSigmaSpace:
inputSigmaRange
setInputSigmaRange:
inputImage
kernelWithString:
CGRectValue
_netExtent
_inputsAreOK
filteredImage:keysAndValues:
dataWithLength:
mutableBytes
length
defaultWorkingColorSpace
applyWithExtent:arguments:
imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor:
outputImageNonMPS
outputData
setInputImage:
inputExtent
setInputExtent:
inputScale
setInputScale:
inputCount
setInputCount:
_context
vectorWithCGRect:
inputPercentile
setInputPercentile:
inputNormalize
setInputNormalize:
inputClip
setInputClip:
inputHard
setInputHard:
baseAddress
region
format
imageByApplyingGaussianBlurWithSigma:
_CIEdgeWork
_CIEdgeWorkContrast
inputRadius
_kernelD2
_isIdentity
downTwo:
upCubic:scale:
_kernelCombine
inputMask
setInputMask:
setInputRadius:
initWithRect:withFaceId:
setFaceId:
setFaceRect:
framesSinceLast
setFramesSinceLast:
computeAverage
initWithScore:
addScore:
computeStandardDeviation
maxScore
setMaxScore:
minScore
setMinScore:
numScores
setNumScores:
sumScores
sumSqScores
setSwFaceId:
setSwCenter:
setSwSize:
setSwLastFrameSeen:
setHwFaceId:
setHwCenter:
setHwSize:
setHwLastFrameSeen:
hwCenter
hwSize
swCenter
swSize
hwFaceId
hwFaceRect
swFaceId
swFaceRect
overlapWithHwRect:
overlapWithSwRect:
swLastFrameSeen
hwLastFrameSeen
setHwFaceRect:
padRoiRect:paddingX:paddingY:
isSyncedWithImage
setFacesRoiRect:
setNumHWFaces:
value:withObjCType:
getValue:
setFocusScore:
setNormalizedFocusScore:
setNormalizedSigma:
removeObjectForKey:
addEntriesFromDictionary:
allKeys
arrayWithArray:
class
isKindOfClass:
unsignedLongLongValue
insertObject:atIndex:
addFaceToArray:
setNormalizedFaceRect:
setTimestamp:
setHasRollAngle:
setRollAngle:
setHasYawAngle:
setYawAngle:
setHasLeftEye:
setLeftEyeRect:
setLeftEyeBlinkScore:
setHasRightEye:
setRightEyeRect:
setRightEyeBlinkScore:
setSmileScore:
setIsSyncedWithImage:
setupFaceDetector
calculateFaceCoreROI:imageStat:needFaceCore:
findOverlappingFaceStat:imageStat:
setLatestFaceTimestamp:
curConfig
faceIdMapping
renameMapping
faceIdCounter
faceInfoArray
numFramesSinceFullFaceCore
numFramesNoFaces
faceTimestampArray
latestImageTimestamp
lastFaceIndex
foundByFaceCore
normalizedSigma
faceScore
allocWithZone:
initWithFaceStat:
copyWithZone:
setLeftEyeOpen:
setRightEyeOpen:
setFoundByFaceCore:
setFaceScore:
setFCRLeftEyeFeaturesOffset:
setFCRRightEyeFeaturesOffset:
setFCRSmileFeaturesOffset:
setFCRBlinkFeaturesSize:
setFCRSmileFeaturesSize:
FCRSmileAndBlinkFeatures
setFCRSmileAndBlinkFeatures:
setSmallFace:
_isSyncedWithImage
_hwFaceRect
getSharpnessAndBlurLimits
setAEDelta:
setRegistrationErrorX:
setRegistrationErrorY:
setHasRegistrationData:
setRegistrationErrorIntegral:
setActionClusteringScore:
updateROI:
computeImageColorHistogram:
computeImageSharpnessOnGrid:
computeBlurStatsOnGrid:
computeImageProjections:
getBytes:length:
computeFacialFocusScoreSum
initWithIdentifier:
computeRuleOfThreeDistance
computeSmilePercentage
setAEMatrix:
computeAEMatrix:
compareImageStats:
colorHistogram
setImageId:
setOrientation:
setFaceStatArray:
exclude
setExclude:
setAEStable:
setAEAverage:
setAETarget:
setAFStable:
setAvgHorzDiffY:
setBlurExtent:
timeReceived
setDoLimitedSharpnessAndBlur:
setRoiSize:
AEDelta
fullsizeJpegSize
setFullsizeJpegSize:
numEntries
dissimilarity
projectionMemoryBlock
projectionSignature
sharpnessGrid
gridWidth
gridHeight
gridROI
smoothedROI
_AEDelta
_fullsizeJpegSize
allowsKeyedCoding
supportsSecureCoding
encodeWithCoder:
initWithCoder:
isValid
initWithPayload:symbolVersion:maskPattern:errorCorrectionLevel:
decodeObjectOfClass:forKey:
decodeIntegerForKey:
encodeObject:forKey:
encodeInteger:forKey:
descriptorWithPayload:symbolVersion:maskPattern:errorCorrectionLevel:
errorCorrectedPayload
symbolVersion
maskPattern
errorCorrectionLevel
initWithPayload:isCompact:layerCount:dataCodewordCount:
decodeBoolForKey:
encodeBool:forKey:
descriptorWithPayload:isCompact:layerCount:dataCodewordCount:
isCompact
layerCount
dataCodewordCount
initWithPayload:isCompact:rowCount:columnCount:
copy
descriptorWithPayload:isCompact:rowCount:columnCount:
rowCount
columnCount
initWithPayload:rowCount:columnCount:eccVersion:
descriptorWithPayload:rowCount:columnCount:eccVersion:
eccVersion
_objectForIdentifier:
_payloadForIdentifier:
self
_setPayloadIdentifier:object:withBlock:
detectedBarcodeDescriptor
setDetectedCode:
_CITriangleTile
inputCenter
inputAngle
inputWidth
vectorWithX:Y:
_CILozengeRefraction
inputPoint0
inputPoint1
inputRefraction
_CITorusRefraction
setPerservesAlpha:
bytes
initWithImageProvider:width:height:format:colorSpace:options:
_checkInputs
null
imageByColorMatchingWorkingSpaceToColorSpace:
curvesImage
_kernel
imageByColorMatchingColorSpaceToWorkingSpace:
setInputCurvesData:
inputCurvesDomain
setInputCurvesDomain:
inputCurvesData
inputColorSpace
setInputColorSpace:
_curvesImage
encodeFloat:forKey:
decodeFloatForKey:
valueWithBytes:objCType:
unarchivedObjectOfClass:fromData:error:
setWithObjects:
unarchivedObjectOfClasses:fromData:error:
archivedDataWithRootObject:requiringSecureCoding:error:
_internalContext
_contextColorForInstruments
contextWithOptions:
isEqual:
valueForKey:
internalCLContextWithOptions:
_initWithInternalRepresentation:
internalContextWithMTLDevice:options:
internalGLContextWithOptions:
initWithCGContext:options:
initWithEAGLContext:
initWithEAGLContext:options:
internalContextWithEAGLContext:options:
initWithMTLDevice:options:
_gpuContextCheck
_crashed_because_nonaddressable_memory_was_passed_to_render:toBitmap:rowBytes:bounds:format:colorSpace:
imageByApplyingTransform:
_internalRepresentation
lock
unlock
render:toCVPixelBuffer:bounds:colorSpace:
identifier
bounds
drawImage:inRect:fromRect:
_isGLBackedContext
_isCGBackedContext
createCGImage:fromRect:format:colorSpace:
createCGImage:fromRect:
render:toTexture:target:bounds:colorSpace:
_outputColorSpace
defaultRGBColorSpace
defaultGrayColorSpace
_createCGImage:fromRect:format:colorSpace:deferred:textureLimit:
workingColorSpace
regionOfInterestForImage:inRect:
description
_isMetalInternalContext
stringByAppendingFormat:
_singletonContext
contextWithCGContext:options:
contextWithEAGLContext:
contextWithEAGLContext:options:
contextWithMTLDevice:
contextWithMTLDevice:options:
device
abort
invalidate
render:toCVPixelBuffer:
_isGLInternalContext
_insertEventMarker:
render:
drawImage:atPoint:fromRect:
render:toTexture:bounds:colorSpace:
render:toMTLTexture:commandBuffer:bounds:colorSpace:
createCGImage:fromRect:format:
createCGImage:fromRect:format:colorSpace:deferred:
createCGLayerWithSize:info:
maximumInputImageSize
maximumOutputImageSize
inputImageMaximumSize
outputImageMaximumSize
workingFormat
reclaimResources
clearCaches
flatten:fromRect:format:colorSpace:
measureRequirementsOf:query::results:
setCTM:
setBounds:
createColorCubeDataForFilters:dimension:
_priv
internalCLContextWithOptions:glContext:
_pdfDataRepresentation
resetStatistics
peakNonVolatileSize
_CIPageCurlTransNoEmap
_CIPageCurlTransition
filterWithName:keysAndValues:
inputTargetImage
inputBacksideImage
inputShadingImage
inputTime
emptyImage
_CIPageCurlWithShadowTransition
_CIPageCurlNoShadowTransition
inputShadowSize
inputShadowAmount
inputShadowExtent
inputKeys
hash
setValue:forUndefinedKey:
valueForUndefinedKey:
classInfoForClass:
inputClasses
instanceMethodForSelector:
_crashed_when_dealloc_called_setValue_nil_forKey_probably_because_the_subclass_already_released_it:overridesDealloc:
finalize
outputKeys
classAttributesForClass:
classDefaultsForClass:
setWithArray:
keyPathsForValuesAffectingValueForKey:
raise:format:
initWithFormat:
userInfo
decodeObjectOfClasses:forKey:
containsValueForKey:
_copyFilterWithZone:
_propertyArrayFromFilters:inputImageExtent:
_filterArrayFromProperties:inputImageExtent:
ROISelector
respondsToSelector:
methodForSelector:
subarrayWithRange:
applyWithExtent:roiCallback:inputImage:arguments:
apply:arguments:options:
serializedXMPFromFilters:inputImageExtent:
filterArrayFromSerializedXMP:inputImageExtent:error:
attributes
setDefaults
mutableCopyWithZone:
apply:
name
setName:
isEnabled
setEnabled:
_enabled
classCategoriesForClass:
containsObject:
componentsSeparatedByString:
filterWithName:
hasPrefix:
vectorWithString:
substringWithRange:
_filterClassInCategory:
substringFromIndex:
stringValue
stringRepresentation
rangeOfString:
isSubclassOfClass:
_outputProperties
_initFromProperties:
conformsToProtocol:
_serializedXMPString
filterWithString:
setIdentity
setUserInfo:
setOption:forKey:
_imageMetadataFromFilters:inputImageExtent:
_filterArrayFromImageMetadata:inputImageExtent:
_filterArrayFromProperties:
transformStruct
_CIParallelogramTile
inputAcuteAngle
_blur:pass:weightsFactor:
setInputAngle:
setInputAmount:
inputAmount
vectorWithX:Y:Z:
_kernelNew
setInputCenter:
unsignedIntValue
mutableCopy
removeObjectsForKeys:
CGImage
imageWithCGImage:options:
initWithCGImage:options:
fileURLWithPath:
numberWithUnsignedInt:
_initNaiveWithCGImage:options:
_setOriginalCGImage:options:
_initWithIOSurface:options:owner:
initWithCVPixelBuffer:options:
initAuxiliaryWithImageSource:options:depth:
initMatteWithImageSource:options:
imageWithCGLayer:options:
initWithCGLayer:options:
initWithBitmapData:bytesPerRow:size:format:options:
initWithBitmapData:bytesPerRow:size:format:colorSpace:
_initWithBitmapData:bytesPerRow:size:format:options:
initWithBytesNoCopy:length:deallocator:
initWithTexture:size:flipped:colorSpace:
initWithTexture:size:options:
initWithTexture:size:flipped:options:
pixelBuffer
imageWithCVPixelBuffer:options:
_initWithCVImageBuffer:options:
_setOriginalCVPixelBuffer:options:
imageWithCVImageBuffer:options:
initWithCVImageBuffer:options:
initWithColor:
cgColor
initWithEmptyClearColor
imageTransformForOrientation:
imageTransformForCGOrientation:
initWithData:options:
initWithCGImageSource:index:options:
imageWithContentsOfURL:options:
initWithContentsOfURL:options:
imageWithContentsOfFile:options:
initWithContentsOfFile:options:
imageWithInternalRepresentation:
imageByClampingToRect:
initWithDictionary:copyItems:
imageBySamplingNearest
imageBySamplingLinear
initWithArrayOfImages:selector:
shapeWithRect:
stringWithUTF8String:
filterWithName:setDefaults:
writeTIFFRepresentationOfImage:toURL:format:colorSpace:options:error:
initWithCGImage:
nullImage
imageWithCGImage:
imageWithCGLayer:
imageWithBitmapData:bytesPerRow:size:format:options:
imageWithTexture:size:flipped:colorSpace:
imageWithTexture:size:options:
imageWithTexture:size:flipped:options:
imageWithMTLTexture:options:
imageWithCVPixelBuffer:
imageWithCVImageBuffer:
imageWithColor:
noiseImage
noiseImageNearest
noiseImagePadded
imageWithData:
imageWithData:options:
imageWithContentsOfURL:
imageWithContentsOfFile:
imageForRenderingWithMetal:orNonMetal:
imageForRenderingWithMPS:orNonMPS:
imageForRenderingWithMetalContext:orOpenGLContextUsingMetal:orNonMetalContext:
imageWithArrayOfImages:selector:
_originalCGImage
initWithCGLayer:
initWithMTLTexture:options:
_originalCVPixelBuffer
depthData
portraitEffectsMatte
initWithCVPixelBuffer:
initWithCVImageBuffer:
initWithColorR:G:B:A:
imageByApplyingOrientation:
imageByApplyingCGOrientation:
initWithData:
initWithContentsOfURL:
initWithContentsOfFile:
imageByApplyingTransform:highQualityDownsample:
imageByCompositingOverImage:
_imageByPremultiplying
_imageByUnpremultiplying
_imageByClampingAlpha
imageBySettingAlphaOneInExtent:
_imageByApplyingGamma:
_imageByApplyingBlur:
_imageByMatchingWorkingSpaceToColorSpace:
imageByColorMatchingWorkingSpaceToRGBorGrayColorSpace:
_imageByMatchingColorSpaceToWorkingSpace:
imageByTaggingWithColorSpace:
imageByInsertingIntermediate
imageByInsertingIntermediate:
_imageByRenderingToIntermediate
imageBySettingProperties:
imageBySettingPropertiesNoCopy:
_imageBySamplingNearest
_imageBySamplingLinear
initForRenderingWithMetal:orNonMetal:
initForRenderingWithMPS:orNonMPS:
initForRenderingWithMetalContext:orOpenGLContextUsingMetal:orNonMetalContext:
definition
debugDescription
properties
colorSpace
isOpaque
setCacheHint:
cacheHint
imageByApplyingFilter:
writeToTIFF:
printTree
TIFFRepresentation
setValue:forKeyPath:
initWithDepthData:options:
initWithDepthData:
imageWithDepthData:options:
imageWithDepthData:
initWithPortaitEffectsMatte:options:
initWithPortaitEffectsMatte:
imageWithPortaitEffectsMatte:options:
imageWithPortaitEffectsMatte:
initWithAttributedString:format:options:
string
appendBytes:length:
appendData:
initWithAttributedString:format:
imageWithAttributedString:format:
imageWithAttributedString:format:options:
encodeInt:forKey:
decodeIntForKey:
functionWithName:
functionCount
externFunctionNames
stringByReplacingOccurrencesOfString:withString:
_initWithReflection:
_initWithString:andMetalLibrary:usingCruftCompatibility:
modifiedKernelStringForFosl:
libraryWithData:error:
kernelsWithString:andMetalLibrary:messageLog:
initWithString:
kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:
kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:outputGroupSize:error:
_initWithString:usingCruftCompatibility:
appendString:
longValue
_isValidOutputPixelFormat:
_outputFormatUsingDictionary:andKernel:
applyWithExtent:roiCallback:arguments:options:
kernelsWithString:fromMetalLibraryData:
kernelsWithString:messageLog:
kernelsWithString:
kernelWithString:fromMetalLibraryData:
kernelWithFunctionName:fromMetalLibraryData:error:
kernelWithFunctionName:fromMetalLibraryData:outputGroupSize:error:
colorMatrixBiasKernel
perservesAlpha
preservesRange
setPreservesRange:
canReduceOutputChannels
setCanReduceOutputChannels:
outputGroupSize
setOutputGroupSize:
setROISelector:
parameters
applyWithExtent:arguments:options:
autogenerateROI:args:arguments:extent:
applyWithExtent:roiCallback:inputImage:arguments:options:
initWithString:extentType:
kernelWithString:extentType:
applyWithForeground:background:
errorWithDomain:code:userInfo:
enumerateLinesUsingBlock:
CGAffineTransformValue
_values
filterWithName:withInputParameters:
_dict
set_dict:
inputFilterName
setInputFilterName:
initWithImageProvider:userInfo:size:format:flipped:colorSpace:
initWithImageProvider:size::format:colorSpace:options:
provideImageData:bytesPerRow:origin::size::userInfo:
_initWithImageProvider:width:height:format:colorSpace:surfaceCache:options:
imageWithImageProvider:userInfo:size:format:flipped:colorSpace:
imageWithImageProvider:size::format:colorSpace:options:
initWithCIImage:options:
setRevision:
performRequests:error:
results
setInputFaceObservations:
pointsInImageOfSize:
pointCount
boundingBox
landmarks
leftEye
rightEye
setObject:atIndexedSubscript:
allPoints
faceContour
innerLips
leftEyebrow
leftPupil
medianLine
nose
noseCrest
outerLips
rightEyebrow
rightPupil
initWithCapacity:
vectorWithCGPoint:
outputImageScale:outset:hKernel:vKernel:
_scale
inputAspectRatio
setInputAspectRatio:
inputB
setInputB:
inputC
setInputC:
internalLibraryWithName:device:
setLabel:
newExternFunctionWithName:
_CIAlphaNormalize
_CITiltShift
_DistanceColored
inputSaturation
inputUnsharpMaskRadius
inputUnsharpMaskIntensity
setInputTransform:
inputTransform
setInputRectangle:
inputRectangle
TIFFRepresentationOfImage:format:colorSpace:options:
writeToURL:options:error:
PNGRepresentationOfImage:format:colorSpace:options:
JPEGRepresentationOfImage:colorSpace:options:
HEIFRepresentationOfImage:format:colorSpace:options:
writePNGRepresentationOfImage:toURL:format:colorSpace:options:error:
writeJPEGRepresentationOfImage:toURL:colorSpace:options:error:
writeHEIFRepresentationOfImage:toURL:format:colorSpace:options:error:
numberWithUnsignedLong:
inputIntensity
setInputIntensity:
_CILenticularHalo
colorWithRed:green:blue:
inputColor
inputHaloRadius
inputHaloWidth
inputHaloOverlap
inputStriationStrength
inputStriationContrast
valueWithPointer:
indexForWrapperNumber:
exchangeImplementationsForClass
setValuesForKeysWithDictionary:
intersectSet:
_prependSingleFilter:
_appendSingleFilterTo:filterAndSettings:
_prepend:
performSelector:
_append:image:
wrapClassIfNeeded:
arrayWithObjects:
outputImageCatchAll:
filterName:replacement:arguments:
wrappedOutputImage10
wrappedOutputImage11
wrappedOutputImage12
wrappedOutputImage13
wrappedOutputImage14
wrappedOutputImage15
wrappedOutputImage16
wrappedOutputImage17
wrappedOutputImage18
wrappedOutputImage19
wrappedOutputImage20
wrappedOutputImage21
wrappedOutputImage22
wrappedOutputImage23
wrappedOutputImage24
wrappedOutputImage25
wrappedOutputImage26
wrappedOutputImage27
wrappedOutputImage28
wrappedOutputImage29
wrappedOutputImage30
wrappedOutputImage31
wrappedOutputImage32
wrappedOutputImage33
wrappedOutputImage34
wrappedOutputImage35
wrappedOutputImage36
wrappedOutputImage37
wrappedOutputImage38
wrappedOutputImage39
wrappedOutputImage40
wrappedOutputImage41
wrappedOutputImage42
wrappedOutputImage43
wrappedOutputImage44
wrappedOutputImage45
wrappedOutputImage46
wrappedOutputImage47
wrappedOutputImage48
wrappedOutputImage49
wrappedOutputImage50
wrappedOutputImage51
wrappedOutputImage52
wrappedOutputImage53
wrappedOutputImage54
wrappedOutputImage55
wrappedOutputImage56
wrappedOutputImage57
wrappedOutputImage58
wrappedOutputImage59
wrappedOutputImage60
wrappedOutputImage61
wrappedOutputImage62
wrappedOutputImage63
wrappedOutputImage64
wrappedOutputImage65
wrappedOutputImage66
wrappedOutputImage67
wrappedOutputImage68
wrappedOutputImage69
wrappedOutputImage70
wrappedOutputImage71
wrappedOutputImage72
wrappedOutputImage73
wrappedOutputImage74
wrappedOutputImage75
wrappedOutputImage76
wrappedOutputImage77
wrappedOutputImage78
wrappedOutputImage79
wrappedOutputImage80
wrappedOutputImage81
wrappedOutputImage82
wrappedOutputImage83
wrappedOutputImage84
wrappedOutputImage85
wrappedOutputImage86
wrappedOutputImage87
wrappedOutputImage88
wrappedOutputImage89
wrappedOutputImage90
wrappedOutputImage91
wrappedOutputImage92
wrappedOutputImage93
wrappedOutputImage94
wrappedOutputImage95
wrappedOutputImage96
wrappedOutputImage97
wrappedOutputImage98
wrappedOutputImage99
load
filterName:append:arguments:
filterName:prepend:imageName:arguments:
addFilterToSkip:
filterName:replacement:
performSelector:withObject:withObject:
depthDataType
depthDataByConvertingToDepthDataType:
depthDataByReplacingDepthDataMapWithPixelBuffer:error:
depthDataMap
dictionaryRepresentationForAuxiliaryDataType:
cameraCalibrationData
intrinsicMatrix
intrinsicMatrixReferenceDimensions
lensDistortionLookupTable
inverseLensDistortionLookupTable
lensDistortionCenter
depthDataAccuracy
portraitScore
mattingImage
clearImage:
initWithExtent:format:options:
initWithExtent:format:
initWithExtent:format:colorSpace:
isMemberOfClass:
setImage:dirtyRect:
imageAccumulatorWithExtent:format:options:
imageAccumulatorWithExtent:format:
imageAccumulatorWithExtent:format:colorSpace:
setImage:
clear
commitUpdates:
_state
initWithValues:count:
initWithX:
initWithX:Y:
initWithX:Y:Z:
initWithX:Y:Z:W:
initWithCGPoint:
initWithCGRect:
initWithCGAffineTransform:
valueAtIndex:
stringByAppendingString:
decodeRectForKey:
vectorWithValues:count:
vectorWithX:
vectorWithCGAffineTransform:
CGPointValue
_count
inputEV
setInputEV:
_CIDisplaceFromImage
inputDisplacementImage
setInputSaturation:
inputBrightness
setInputBrightness:
inputContrast
setInputContrast:
_reduceCrop
offsetAndCrop
_reduce2X2
_reduce1X4
_reduce4X1
_reduce4x4
colorWithRed:green:blue:alpha:
_combine:
unsignedIntegerValue
_kernelKmeans
magentaColor
greenColor
inputPasses
setInputPasses:
inputMeans
setInputMeans:
inputPerceptual
setInputPerceptual:
_kernelWeightedCoordinate
_kernelCentroid
integerValue
_kernelCenter
_kernelDisk
_kernelGaussian
inputRadialMode
setInputRadialMode:
inputMinWeight
setInputMinWeight:
_kernelDraw
inputCoordinate
setInputCoordinate:
inputInnerRadius
setInputInnerRadius:
inputOuterRadius
setInputOuterRadius:
inputRVector
setInputRVector:
inputGVector
setInputGVector:
inputBVector
setInputBVector:
inputAVector
setInputAVector:
inputBiasVector
setInputBiasVector:
_kernelNeg
_kernelPos
_kernelH
_kernelV
inputDraftMode
getDraftMode:
performPass:reference:values:rect:
inputTuningParameters
setInputTuningParameters:
setInputDraftMode:
SDOFV2MetalKernelNamed:
_kernelMetal
inputLumaNoiseAmpl
setInputLumaNoiseAmpl:
inputLumaNoiseModelCoeff
setInputLumaNoiseModelCoeff:
inputUseMetal
setInputUseMetal:
samplerWithImage:options:
inputHorizontalBlur
setInputHorizontalBlur:
inputMaxBlur
setInputMaxBlur:
inputAntiAliasBlurStrength
setInputAntiAliasBlurStrength:
_kernelWithShapesMetal
_kernelsWithShapes
_ourBlendKernelMetal
_ourBlendKernel
outputImage:
metalFilterWithName:
outputImageV2
outputImageV3
inputBlurmapImage
setInputBlurmapImage:
inputMatteImage
setInputMatteImage:
inputLumaNoiseScale
setInputLumaNoiseScale:
inputAperture
setInputAperture:
inputShape
setInputShape:
outputFormat
formatForInputAtIndex:
applyWithExtent:inputs:arguments:error:
roiForInput:arguments:outputRect:
skipFormatChecks
applyWithExtent:shader:inputs:roiMethods:insetRects:scaleFactors:arguments:error:
applyWithExtent:shader:inputs:insetRects:arguments:error:
applyWithExtent:shader:inputs:scaleFactors:arguments:error:
applyWithExtent:shader:inputs:arguments:error:
applyWithExtent:shader:inputs:className:arguments:error:
processWithInputs:arguments:output:error:
outputIsOpaque
synchronizeInputs
inputText
setInputText:
inputFontName
setInputFontName:
inputFontSize
setInputFontSize:
inputScaleFactor
setInputScaleFactor:
inputNeutral
setInputNeutral:
inputTargetNeutral
setInputTargetNeutral:
green
blue
alpha
setInputColor:
clearColor
inputColor0
setInputColor0:
inputColor1
setInputColor1:
initWithAPI:properties:
setDebugLabel:
getMacroContextPrivate
sharegroup
setParameter:to:
currentContext
setCurrentContext:
initWithAPI:
inputPower
setInputPower:
initWithSurface:texture:allowSRGB:bounds:context:
surface
usesSRGBTransferFunction
_region
_surface
_usesSRGB
_mtlTexture
_surfaceLocked
metalTexture
metalCommandBuffer
metalCommandBufferRequested
contextID
metalContext
_cmdBuffer
exceptionWithName:reason:userInfo:
allowSRGBTranferFuntionOnOutput
_digestForArgs:
allowSRGBTranferFuntionOnInputAtIndex:
allowPartialOutputRegion
lengthOfBytesUsingEncoding:
compare:
_CINoiseReduction
inputNoiseLevel
inputSharpness
_CIEdgesPrep
_CIFindEdges
_CIConvertRGBtoY
_CIBlur1
_CIBlur2
_CIBlur4
_CISharpenCombineEdges
inputFalloff
inputEdgeScale
bundleForClass:
newDefaultLibraryWithBundle:error:
newFunctionWithName:
computeCommandEncoder
newComputePipelineStateWithFunction:error:
setComputePipelineState:
setBytes:length:atIndex:
setBuffer:offset:atIndex:
setTexture:atIndex:
threadExecutionWidth
maxTotalThreadsPerThreadgroup
dispatchThreadgroups:threadsPerThreadgroup:
endEncoding
addCompletedHandler:
initWithDevice:kernelName:
encodeToCommandBuffer:sourceBuffer:sourceRowBytes:destinationTexture:
encodeToCommandBuffer:sourceBuffer:sourceRowBytes:destinationBuffer:destinationRowBytes:destinationSize:
_device
_convertToTexture
_convertToBuffer
_CIOpTile
setInputWidth:
setInputSharpness:
initWithImage:
initWithImage:options:
_initWithImage:key0:vargs:
samplerWithImage:
samplerWithImage:keysAndValues:
initWithImage:keysAndValues:
opaqueShape
wrapMode
_CIShadedmaterial_0
_CIShadedmaterial
_customBoxBlur5Kernel
outputImageMetal
inputNumIterations
setInputNumIterations:
_CICircle
inputEdgeBlur
smartToneAdjustmentsForValue:andStatistics:
smartToneAdjustmentsForValue:localLightAutoValue:andStatistics:
smartColorAdjustmentsForValue:andStatistics:
smartToneStatistics
smartColorStatistics
inputUseCube
inputUseCubeColorSpace
_kernelBneg
_kernelBpos
_kernelRH
_kernelC
inputExposure
setInputExposure:
inputShadows
setInputShadows:
inputHighlights
setInputHighlights:
inputBlack
setInputBlack:
inputRawHighlights
setInputRawHighlights:
inputLocalLight
setInputLocalLight:
inputLightMap
setInputLightMap:
setInputUseCube:
setInputUseCubeColorSpace:
_inputLightMap
_cubeImage
_cubeData
_cubeContext
_kernelV_lt1
_kernelV_gt1
_kernelCPos
_kernelCNeg
_kernelCast
inputVibrancy
setInputVibrancy:
inputCast
setInputCast:
inputFilename
setInputFilename:
inputShouldDumpInputValues
setInputShouldDumpInputValues:
inputOriginalFilter
setInputOriginalFilter:
initWithBitmap:rowBytes:bounds:format:
initWithBitmap:rowBytes:bounds:format:options:
setBitmap:rowBytes:bounds:format:
contextWithBitmap:rowBytes:bounds:format:
contextWithBitmap:rowBytes:bounds:format:options:
_bcpriv
_fullFloatBoxFilter
_multiplyImagesKernel
_boxFilter:fullFloat:
_swizzleImageXXX1:
_swizzleImageYYZ1:
_swizzleImageYZZ1:
multiplyImages:imageB:
subtract:minus:
_computeABKernel
_downsampledColorImage:
_combineRGB_and_A
computeAB:
_upsampleImage:targetImageSize:
_finalResult
inputGuideImage
setInputGuideImage:
inputEpsilon
setInputEpsilon:
detectorOfType:context:options:
featuresInImage:options:
_autoRedEyeFilterWithFeatures:imageProperties:context:options:
setFaceBalanceEnabled:
setVibranceEnabled:
setCurvesEnabled:
setShadowsEnabled:
faceBalanceEnabled
setupFaceColorFromImage:usingContext:features:
drain
_scaleImageToMaxDimension:
forImage:usingContext:
setupHistogramsUsing:redIndex:greenIndex:blueIndex:
getAutoRotateFilter:ciImage:rgbRows:inputRect:rotateCropRect:
getAutocropRect:rotateXfrm:inputImageRect:clipRect:
faceBalanceWarmth
faceBalanceStrength
originalFaceColor
vibranceEnabled
vibrance
curvesEnabled
curveCount
curvePointAtIndex:
shadowsEnabled
shadow
autoAdjustmentFiltersWithOptions:
autoAdjustmentFiltersWithImageProperties:options:
pointWithDictionary:name:index:transformedBy:
hasLeftEyePosition
leftEyePosition
hasRightEyePosition
rightEyePosition
hasMouthPosition
mouthPosition
_dictForFeature:invOrientationTransform:extent:
supportRectangleWithFaceArray:imageSize:
initWithExternalBuffer:subRectangle:fullSize:rowBytes:cameraModel:
autoAdjustmentFilters
imageWithMesh:transform:
autoRedEyeFilterWithFeatures:imageProperties:options:
autoRedEyeFilterWithFeatures:options:
allValues
inputCameraModel
setInputCameraModel:
inputCorrectionInfo
setInputCorrectionInfo:
histogramFromData:
histogramFromFloatData:
histogramFromDoubleData:
values
hist
_CIConvolutionAdd_1
_CIConvolutionAdd_2
_CIConvolutionAdd_3
_CIConvolutionAdd_4
_CIConvolutionAdd_5
_CIConvolutionAdd_6
_CIConvolutionAdd_7
_CIConvolutionAdd_8
doConvolutionPass:weights:sums:
samplesPerPass
inputPoints
inputWeights
inputLinearFilterModeEnabled
inputRingAmount
inputRingSize
inputSoftness
_recipe
inputPointCount
removeLastObject
newBufferWithBytes:length:options:
newBufferWithBytesNoCopy:length:options:deallocator:
addScheduledHandler:
initWithBounds:andImage:usingContext:
size
centerX
centerY
_CIDroste
inputInsetPoint0
inputInsetPoint1
inputStrands
inputPeriodicity
inputRotation
inputZoom
_internalRenderDestination
_initWithInternalRenderDestination:width:height:format:colorspace:
setFlipped:
_render:withContext:
initWithPixelBuffer:
initWithWidth:height:pixelFormat:colorSpace:pixelBufferProvider:
initWithMTLTexture:commandBuffer:
initWithWidth:height:pixelFormat:commandBuffer:mtlTextureProvider:
initWithGLTexture:target:width:height:
initWithBitmapData:width:height:bytesPerRow:format:
alphaMode
setAlphaMode:
isFlipped
isDithered
setDithered:
ditherDepth
isClamped
setClamped:
setColorSpace:
blendKernel
setBlendKernel:
blendsInDestinationColorSpace
setBlendsInDestinationColorSpace:
label
imageRepresentation
internalRepresentation
initWithCompletedTask:
renderInfoWithCompletedTask:
kernelExecutionTime
kernelExecutionCycles
passCount
pixelsProcessed
pixelsOverdrawn
timeForNodeID:
initWithInternalTask:
rendertaskWithInternalTask:
waitUntilCompletedAndReturnError:
startTaskToRender:toDestination:error:
_startTaskToRender:toDestination:forPrepareRender:error:
startTaskToRender:fromRect:toDestination:atPoint:error:
prepareRender:fromRect:toDestination:atPoint:error:
startTaskToClear:error:
fromImage:
initFileURLWithPath:
_dumpImage:colorspace:
forImage:downscaleToMax:colorspace:
forImage:downscaleToMax:colorspace:usingContext:
forImage:usingContext:colorspace:
numberWithShort:
unsignedLongValue
shortValue
fromImageFile:
forImage:downscaleToMax:
withDictionary:
rowAtIndex:
bytesPerPixel
dumpImage:
dumpImageAsDeviceRGB:
dumpImageAsDict:
data
setRGBSumHistogram:
setLuminanceHistogram:
setBorderHistogram:
setSaturationHistogram:
bestWarmthForI:q:percentChange:
setFaceColorFromChromaI:andChromaQ:
analyzeFeatures:usingContext:baseImage:
histogramFromRows:componentOffset:
setupFaceColorFromImage:usingContext:detectorOpts:
_kernel16
curveImageFromPoints:
splineCurveTable:tableSize:gamma:from:
curveImageFromPoints:linear:
setInputPoint0:
setInputPoint1:
setInputPoint2:
setInputPoint3:
setInputPoint4:
inputPoint2
inputPoint3
inputPoint4
_curveImage
filterNamesInCategories:
isSubsetOfSet:
caseInsensitiveCompare:
notificationWithName:object:
defaultQueue
enqueueNotification:postingStyle:coalesceMask:forModes:
classAttributesForName:
localizedStringForKey:value:table:
filterNamesInCategory:
registerFilterName:constructor:classAttributes:
localizedNameForFilterName:
localizedNameForCategory:
localizedDescriptionForFilterName:
localizedReferenceDocumentationForFilterName:
compatibilityVersion
filterWithName:compatibilityVersion:
filterWithName:compatibilityVersion:keysAndValues:
allCategories:
URLWithString:
_attributesWithClass:
initWithClass:
indexOfObject:
superclass
bundlePath
stringByDeletingLastPathComponent
fileURLWithPath:isDirectory:
contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:
pathExtension
bundleWithURL:
objectForInfoDictionaryKey:
path
characterAtIndex:
_defaultVersion
_maxVersion
_kernelSnoB_v0
_kernelSHnoB_v0
_kernelSH_v0
_kernelSHnoB_v1
_kernelSH_v1
_kernelSHnoB_v2
_kernelSH_v2
setInputShadowAmount:
setInputHighlightAmount:
inputHighlightAmount
initWithContext:options:
featuresInImage:
setContext:
_width
_height
featureOptions
_CIRippleTransition
_CISunbeams
inputSunRadius
inputMaxStriationRadius
getNonNormalizedSettings:
createHueArray
hueArrayImage:
inputStrength
setInputStrength:
inputNeutralGamma
setInputNeutralGamma:
inputTone
setInputTone:
inputHue
setInputHue:
inputGrain
setInputGrain:
inputSeed
setInputSeed:
smartBlackAndWhiteStatistics
smartBlackAndWhiteAdjustmentsForValue:andStatistics:
setInputOrigI:
setInputOrigQ:
setInputWarmth:
inputOrigI
inputOrigQ
inputWarmth
depthBlurEffectFilterForImageData:options:
depthBlurEffectFilterForImageURL:options:
_performFaceDetection:image:orientation:filter:
depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:orientation:options:
inputCrossAngle
setInputCrossAngle:
inputCrossScale
setInputCrossScale:
inputCrossWidth
setInputCrossWidth:
inputCrossOpacity
setInputCrossOpacity:
getBlockSetWithImage:into:width:height:
getDataProviderBytePtrWithImage:into:width:height:
getDataProviderCopyWithImage:into:
initWithDeskView:andFrame:
skinInit
initializeNonDebugVariables
initWithFrameExternalBuffer:
repairWithTag:
upperRepairSizeFraction:
lowerRepairSizeFraction:
upperRepairDistance:
lowerRepairSize:
upperRepairSize:
extractReusableAlignedBitmapsAroundPoint:YR:subYBitmap:subCbCrBitmap:
averageValueFromY:withinSkinMask:butOutsideAlpha:
computeTrimmedBitmaps:newY:newCbCr:IR:newTrimY:newTrimCbCr:returningYR:andCbCrR:
undoRepair:
redEyeRemovalWithPoint:alignPupilShades:matching:force:IOD:tap:
redoRepairWithTag:IOD:
upperRepairDistanceFraction:
insertIntoProminenceVettingHopper:max:outside:confidence:distance:row:column:IOD:
gatherProminencesWithC:MC:maxwindowsize:repairsize:IR:fr:intoHopper:faceIndex:left:coss:sins:bitmapName:
gatherProminencesWithC:MC:altC:altMC:maxwindowsize:repairsize:IR:fr:intoHopper:faceIndex:left:
confidenceWithIOD:repair:andProminenceDifference:
extractAndGatherProminencesWithRect:face:faceIndex:left:maxwindowsize:repairsize:returningRedHopper:whiteHopper:redChannel:redChannelMask:
repairDecisionWithFaceRecord:left:redHopper:whiteHopper:
extractAverageFaceY:contrast:faceIndex:
applyEyeRepairWithEye:left:IOD:autoPupilTonality:match:faceIndex:whiteHopper:
distanceMaskFromPolyToCb:Cr:
prepareLineFunctions
autoRepairExtractAndSearchLeft:right:data:repairSize:autoPupilTonality:faceIndex:
getFloat:d:s:
orientPointX:Y:
getInt:d:s:
getBool:d:s:
orientRectangleMinX:maxX:minY:maxY:
redEyeRemovalWithData:
supportRectangleWithPoint:imageSize:IOD:
initWithCGImage:cameraModel:
createRepairedImage
initWithExternalBuffer:size:rowBytes:
debug
setDebug:
logRepairs
setLogRepairs:
redEyeThresholdKind
setRedEyeThresholdKind:
renderAlpha
setRenderAlpha:
infillBackground
setInfillBackground:
renderSpecularShine
setRenderSpecularShine:
specularSize
setSpecularSize:
specularSoftness
setSpecularSoftness:
pupilShadeAlignment
setPupilShadeAlignment:
autoPupilTonality
setAutoPupilTonality:
forceLoValue
setForceLoValue:
loValue
setLoValue:
standardTemplate
faces
repairs
nRepairs
lastRepairTag
redoLastRepair
executeRepairArray:
setFaceIndex:
setLeft:
ownLF
imageSourceType
blockSet
releaseMe
dataRef
nextRepairTag
lastRepairIOD
iFaceIndex
iLeft
debugRedEye
lastClickYBitmap
lastClickCbCrBitmap
lastClickBitmapMinX
lastClickBitmapMaxX
lastClickBitmapMinY
lastClickBitmapMaxY
lastClickYBitmaps
lastClickCbCrBitmaps
lastClickBitmapRects
lastSearchYBitmap
lastSearchCbCrBitmap
lastSearchBitmapMinX
lastSearchBitmapMaxX
lastSearchBitmapMinY
lastSearchBitmapMaxY
nPolyPoints
polyClosed
polyPoints
polyLines
polyPointConcave
CbCrDistanceTable
nLinears
linearCoefficients
computeDOD:tst:off:mtx:
inputPoint
setInputPoint:
inputImage2
setInputImage2:
_geomKernel
_colorKernel
inputSize
setInputSize:
setInputRotation:
inputDecay
setInputDecay:
_CICheapBlur
_CILerp
inputSampling
computeDOD:
_kernelGuideMono
_kernelGuideCombine
_kernelJointUpsamp
_kernelJointUpsampRG
_kernelGuideCombine4
inputSmallImage
setInputSmallImage:
inputSpatialSigma
setInputSpatialSigma:
inputLumaSigma
setInputLumaSigma:
isFileURL
isReadableFileAtPath:
filterWithImageURL:options:
filterWithImageData:options:
filterWithCVPixelBuffer:properties:options:
faceCoreDetector
setFaceCoreDetector:
_tracking
type
initWithBounds:hasLeftEyePosition:leftEyePosition:hasRightEyePosition:rightEyePosition:hasMouthPosition:mouthPosition:hasFaceAngle:faceAngle:hasTrackingID:trackingID:hasTrackingFrameCount:trackingFrameCount:hasSmile:leftEyeClosed:rightEyeClosed:landmarks:
hasTrackingID
trackingID
hasTrackingFrameCount
trackingFrameCount
hasFaceAngle
faceAngle
hasSmile
leftEyeClosed
rightEyeClosed
initWithBounds:topLeft:topRight:bottomLeft:bottomRight:
topLeft
topRight
bottomLeft
bottomRight
initWithInternalRepresentation:
featureWithInternalRepresentation:
messageString
symbolDescriptor
initWithBounds:topLeft:topRight:bottomLeft:bottomRight:subFeatures:messageString:
subFeatures
initWithCGColor:
initWithRed:green:blue:alpha:
initWithRed:green:blue:alpha:colorSpace:
colorWithRed:green:blue:alpha:colorSpace:
performSelector:withObject:
colorWithCGColor:
colorWithRed:green:blue:colorSpace:
colorWithString:
blackColor
whiteColor
grayColor
redColor
blueColor
cyanColor
yellowColor
initWithRed:green:blue:
initWithRed:green:blue:colorSpace:
numberOfComponents
components
debugQuickLookObject
_pad
inputSkyAmount
setInputSkyAmount:
inputGrassAmount
setInputGrassAmount:
hashForString:
betterString:
rawShadow
putShadowsAnalysisInto:
downSampleHistogram:to:storeIn:
printAnalysis
setCurvePercent:
setupFaceColor:redIndex:greenIndex:blueIndex:
setExposureValue:
setShadowsMin:max:zeroExposure:
printHistogram:downsampledTo:
printHistogramsDownsampledTo:
lumHist
rgbSumHist
satHist
borderHist
exposureValue
maxShadow
minShadow
exposureValueAtZeroShadow
curvePercent
faceInputSet
percentFaceChange
releaseResources
pixelTransferSession
interimScaleBuffer
scaleBuffer
_perMeshPtr
_internalBuffer
initWithData:error:
newLibraryWithData:error:
newFunctionWithName:device:
_data
_library
URLForResource:withExtension:
newLibraryWithURL:error:
_CISpotLight
inputLightPosition
inputLightPointsAt
inputConcentration
cubeImage
_kernelOpaque
setInputCubeData:
inputCubeDimension
setInputCubeDimension:
inputCubeData
inputMaskImage
setInputMaskImage:
inputCube0Data
setInputCube0Data:
inputCube1Data
setInputCube1Data:
inputRadius0
setInputRadius0:
inputRadius1
setInputRadius1:
_kernelD
inputValue
setInputValue:
setInputSoftness:
inputDither
setInputDither:
_kernelApplyPalette
inputPaletteImage
setInputPaletteImage:
_kernelDither
inputThreshold
setInputThreshold:
inputBackgroundImage
setInputBackgroundImage:
multiply
screen
overlay
darken
lighten
colorDodge
colorBurn
hardLight
softLight
difference
exclusion
_kernel_v0
_kernel_v1
saturation
color
luminosity
subtract
divide
linearBurn
linearDodge
vividLight
linearLight
pinLight
hardMix
_poskernel
_negkernel
setInputFalloff:
_outputExtent
imageWithYImage:CrCbImage:CrCbScale:matrix:fullRange:colorSpace:
imageYCC444:matrix:fullRange:colorSpace:
inputDamping
setInputDamping:
_dot:
_norm
_orthonormalizeTo:
defaultRepairParameters
defaultSessionParameters
setSessionTuning:
setFilterTuning:
cleanupState
setPrimary:
setPrimaryImage:
setDestination:
setMetadata:
setImageProperties:
setFaces:
repairParametersForTuning:
sessionParametersForTuning:
setTuningFromMetadata:
sessionTuning
filterTuning
imageProperties
primaryImage
_dump:tag:
confidence
faceJunkinessIndex
faceOrientationIndex
sortUsingComparator:
primary
_repairPrimaryWithSecondary:to:
_contextRGBAh
sourceOver
destination
prepareRepair
setPrimary:observations:metadata:
repairPrimaryWithSecondary:
metadata
_primaryImage
computeDOD:scale:
_pinchDistortionScaleLT1
_pinchDistortionScaleGE1
_CIPointillize
inputRadiusImage
setInputRadiusImage:
pointerValue
_CICMYK_convert
_CIWhite
_CICMYK_cyan
_CICMYK_magenta
_CICMYK_yellow
_CICMYK_black
inputGCR
inputUCR
_CIRectangle
lumaTable
dataWithBytesNoCopy:length:freeWhenDone:
_tableImage
setImageProps:
setCompletionBlock:
computeMergeCost:::
setBurstImages:
_CICrystallize
pathForResource:ofType:
_interpolateGrainKernel
_paddedTileKernel
_grainBlendAndMixKernel
inputISO
setInputISO:
cubeName
dataWithContentsOfFile:
cubePath
cubeColorSpaceName
inputSigmaX
setInputSigmaX:
inputSigmaY
setInputSigmaY:
actionAmount
compareActionAmounts:
trueLocalMaximum
_kernel_code
inputLevels
setInputLevels:
_CIEdges
_fadeKernel
setInputTargetImage:
setInputTime:
metalFilterWithName:withInputParameters:
metalImageByApplyingFilter:withInputParameters:
metalImageByApplyingFilter:
SDOFV3MetalKernelNamed:
kernel
inputAddBlur
inputRemoveBlur
inputApertureScaling
inputLensModelImage
setInputLensModelImage:
weightsXKernel
weightsYKernel
preprocKernel
preprocKernelNoAlpha
inputAlphaImage
setInputAlphaImage:
sampleKernel
inputPreprocImage
setInputPreprocImage:
antialiasKernel
inputDisparityWeightImage
setInputDisparityWeightImage:
alphaImageForMainImage:disparity:
inputMainImage
setInputMainImage:
calibrationData
originalShiftMapSize
intrinsicMatrixFocalLength
inputLeftEyePosition
inputRightEyePosition
inputFaceMidPoint
inputChinPosition
upsampledShiftMap:
smoothShiftMapV2:
lensModelParams:
lensModelApply:shiftMap:
needToRunFaceMask
faceMaskParams:
faceMaskApply:blurMap:
refineShiftMapV3WithMainImage:shiftmap:lensModel:
blurMapV2:
blurMapV3:shiftmap:alphaImage:
inputShiftmapImage
setInputShiftmapImage:
setInputLeftEyePosition:
setInputRightEyePosition:
setInputChinPosition:
setInputFaceMidPoint:
inputFocusRect
setInputFocusRect:
inputAuxDataMetadata
setInputAuxDataMetadata:
inputCalibrationData
setInputCalibrationData:
tuningParameters
simulatedAperture
inputBlurMap
setInputBlurMap:
_getFocusRect:focusRect:
inputDisparityImage
setInputDisparityImage:
inputLeftEyePositions
setInputLeftEyePositions:
inputRightEyePositions
setInputRightEyePositions:
inputChinPositions
setInputChinPositions:
inputNosePositions
setInputNosePositions:
tuningParametersFromMetadata:
metadataFromDictionary:metadata:
replaceRenderingParameters:tuningParameters:
augmentMetadataWithRenderingPropertiesForImage:
initWithBase64EncodedString:options:
base64EncodedDataWithOptions:
_CIHexagonalPixellate
inputOpacity
setInputOpacity:
inputPredicateImage
inputSubsampling
inputEPS
inputErosionKernelSize
inputUseDepthFilter
inputFGThresholdValue
inputBGThresholdValue
regionOf:destRect:Offset:
setInputWeights:
secondsSinceStart
statsForImageWithIdentifier:
stringByAppendingPathExtension:
dictionaryWithContentsOfFile:
burstImageSet
burstImageSetWithOptions:
coverImageIdentifier
imageClusterCount
imageClusterForIndex:
setLoggingListener:withUserInfo:
computeDOD
_CIBox6
_CIBox4
_CICross4
outputImageNewScaleX:scaleY:
outputImageOldScaleX:scaleY:
_maskFillColorValue
_kernelB0
convertRGBAToYUV420:rgbaBytesPerRow:
setWidth:
setHeight:
setYbuffer:
setCbuffer:
setBytesPerRow:
dataPtr
arrayByAddingObjectsFromArray:
apply:image:arguments:inoutSpace:
apply:image:arguments:inSpace:
inputWhitePoint
inputVersion
inputRAWDictionary
initWithRect:
_shapeInfinite
initWithStruct:
transformBy:interior:
insetByX:Y:
unionWith:
unionWithRect:
intersectWith:
intersectWithRect:
CGSRegion
inputCompression
setInputCompression:
_kernel_name
_kernel_source
_croppedCenterPixelImage
_roiArea
_roiCenter
_singlePixelImage
_roiRect
setInputAcuteAngle:
_CIComicNoiseReduction
_CISobelEdges
_CIColorControls
inputNRNoiseLevel
inputNRSharpness
inputEdgeIntensity
_CISpotColor
inputCenterColor1
inputReplacementColor1
inputCloseness1
inputContrast1
inputCenterColor2
inputReplacementColor2
inputCloseness2
inputContrast2
inputCenterColor3
inputReplacementColor3
inputCloseness3
inputContrast3
setLength:
localLightStatisticsWithProxy:
localLightStatistics
localLightStatisticsNoProxy
inputLightMapWidth
inputLightMapHeight
_polyKernel
inputLightMapImage
initWithLength:
ReferenceensDistortionPointForPoint:lookupTable:distortionOpticalCenter:imageSize:
regionOf:destRect:userInfo:
inputAVCameraCalibrationData
inputUseInverseLookUpTable
inputGradientImage
setInputGradientImage:
_kernel3x3
inputBarOffset
setInputBarOffset:
_kernelG
inputShadowRadius
setInputShadowRadius:
inputShadowDensity
setInputShadowDensity:
inputShadowOffset
setInputShadowOffset:
setInputMaxStriationRadius:
setInputStriationStrength:
setInputStriationContrast:
inputFadeThreshold
setInputFadeThreshold:
componentAdd
componentMultiply
componentMin
componentMax
source
destinationOver
sourceIn
destinationIn
sourceOut
destinationOut
sourceAtop
destinationAtop
exclusiveOr
darkerColor
lighterColor
plusDarker
plusLighter
inputZeroShiftPercentile
inputAlphaThreshold
inputAmplitude
inputExponent
inputGamma
inputMinFactor
inputMaxFactor
_focalPlanePreProcessorKernel
inputLensModelCalculatorImage
insertString:atIndex:
replaceOccurrencesOfString:withString:options:range:
generateGeneralKernelFromWarpKernel:args:
generateMainFromWarpKernel:args:
makeGridImage:nx:ny:
extentOfMeshStart:count:halfWidth:
_CIMesh32
_CIMesh16
_CIMesh8
_CIMesh4
_CIMesh2
_CIMesh1
inputMesh
setInputMesh:
inputGreyscale
setInputGreyscale:
inputLocal
setInputLocal:
inputTopLeft
setInputTopLeft:
inputTopRight
setInputTopRight:
inputBottomRight
setInputBottomRight:
inputBottomLeft
setInputBottomLeft:
inputCrop
setInputCrop:
inputRedCoefficients
setInputRedCoefficients:
inputGreenCoefficients
setInputGreenCoefficients:
inputBlueCoefficients
setInputBlueCoefficients:
inputAlphaCoefficients
setInputAlphaCoefficients:
setWithObject:
initWithImageSource:options:
initWithCVPixelBuffer:properties:options:
optionKeys
defaultInputLuminanceNoiseReductionAmount
setInputLuminanceNoiseReductionAmount:
defaultInputColorNoiseReductionAmount
setInputColorNoiseReductionAmount:
defaultInputNoiseReductionContrastAmount
setInputNoiseReductionContrastAmount:
defaultInputNoiseReductionDetailAmount
setInputNoiseReductionDetailAmount:
defaultInputNoiseReductionSharpnessAmount
setInputNoiseReductionSharpnessAmount:
defaultInputMoireAmount
setInputMoireAmount:
defaultInputEnableVendorLensCorrection
setInputEnableVendorLensCorrection:
setInputIgnoreOrientation:
setInputEnableNoiseTracking:
setInputNoiseReductionAmount:
setInputEnableSharpening:
setInputBoost:
defaultBoostShadowAmount
setInputBoostShadowAmount:
defaultImageOrientation
setInputImageOrientation:
defaultDecoderVersion
setInputDecoderVersion:
defaultInputBaselineExposureAmount
setInputBaselineExposure:
defaultInputBiasAmount
setInputBias:
defaultInputHueMagMRAmount
setInputHueMagMR:
defaultInputHueMagRYAmount
setInputHueMagRY:
defaultInputHueMagYGAmount
setInputHueMagYG:
defaultInputHueMagGCAmount
setInputHueMagGC:
defaultInputHueMagCBAmount
setInputHueMagCB:
defaultInputHueMagBMAmount
setInputHueMagBM:
setInputDisableGamutMap:
defaultNeutralTemperature
setInputNeutralTemperature:
defaultNeutralTint
setInputNeutralTint:
defaultNeutralChromaticityX
setInputNeutralChromaticityX:
defaultNeutralChromaticityY
setInputNeutralChromaticityY:
arrayByAddingObject:
_inputImageSource
_inputImageAndProperties
_inputImage
_nativeSize
_isRawSource
_calledDealloc
_baseImageProperties
_rawDictionary
_rawReconstructionDefaultsDictionary
_supportedSushiModes
_supportedDecoderVersions
_filters
_typeIdentifierHint
_defaultOrientation
inputRequestedSushiMode
inputNeutralChromaticityX
inputNeutralChromaticityY
inputNeutralTemperature
inputNeutralTint
inputNeutralLocation
inputBoost
inputIgnoreOrientation
inputImageOrientation
inputEnableSharpening
inputEnableNoiseTracking
inputEnableVendorLensCorrection
inputNoiseReductionAmount
inputLuminanceNoiseReductionAmount
inputColorNoiseReductionAmount
inputNoiseReductionSharpnessAmount
inputNoiseReductionContrastAmount
inputNoiseReductionDetailAmount
inputMoireAmount
inputDecoderVersion
inputBoostShadowAmount
inputBias
inputBaselineExposure
inputDisableGamutMap
inputHueMagMR
inputHueMagRY
inputHueMagYG
inputHueMagGC
inputHueMagCB
inputHueMagBM
inputLinearSpaceFilter
rawReconstructionDefaultsDictionary
rawOptions
rawDictionary
whitePointArray
whitePoint
getWhitePointVectorsR:g:b:
sushiMode
invalidateFilters
rawOptionsWithSubsampling:
subsampling
transformedImageIgnoringOrientation:
filters
valueForKeyPath:
nativeSize
getScaleTransform:
getOrientationTransform:
rawMajorVersion
invalidateInputImage
setTempTintAtPoint:
applyMatrix:toCIImage:
automaticallyNotifiesObserversForKey:
isEqualToValue:
isEqualToNumber:
supportedDecoderVersions
RAWFiltersValueForKeyPath:
setInputNeutralLocation:
supportedSushiModes
setInputLinearSpaceFilter:
activeKeys
outputNativeSize
convertNeutralX:y:toTemperature:tint:
convertNeutralTemperature:tint:toX:y:
updateTemperatureAndTint
willChangeValueForKey:
didChangeValueForKey:
updateChomaticityXAndY
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
setInputRequestedSushiMode:
_CIResetalpha
_kernelAlphaPreserving
inputMinComponents
setInputMinComponents:
inputMaxComponents
setInputMaxComponents:
inputTexture
setInputTexture:
inputCropAmount
inputCenterStretchAmount
inputBreakpoint0
setInputBreakpoint0:
inputBreakpoint1
setInputBreakpoint1:
inputGrowAmount
setInputGrowAmount:
_kernelAlt
inputFlipYTiles
setInputFlipYTiles:
_maxVersionBG
backgroundCubeName
applyCubeWithName:toImage:
_CIPhotoEffectDepthBlend
backgroundCubePath
inputDepthMap
setInputDepthMap:
inputGrainAmount
setInputGrainAmount:
center:inImg:fromRect:offset:
inputCenterLeft
setInputCenterLeft:
inputCenterRight
setInputCenterRight:
inputPercentileRepair
setInputPercentileRepair:
inputPercentileSpecular
setInputPercentileSpecular:
inputPercentRepair
setInputPercentRepair:
inputPercentSpecular
setInputPercentSpecular:
inputInterPeakMinRepair
setInputInterPeakMinRepair:
inputAbortMaxCenterDist
setInputAbortMaxCenterDist:
inputMinDensity
setInputMinDensity:
inputMaxRelDensity
setInputMaxRelDensity:
inputDensityRadius
setInputDensityRadius:
inputMinimum
setInputMinimum:
inputMaxArea
setInputMaxArea:
inputCenterOffsetLeft
setInputCenterOffsetLeft:
inputCenterOffsetRight
setInputCenterOffsetRight:
inputDetectionLeft
setInputDetectionLeft:
inputDetectionRight
setInputDetectionRight:
inputTuning
setInputTuning:
inputAreaThresholdLoHi
setInputAreaThresholdLoHi:
inputSplat
setInputSplat:
inputCentroid
setInputCentroid:
inputSpecularMask
setInputSpecularMask:
inputSpecularThreshold
setInputSpecularThreshold:
inputSpecIntensity
setInputSpecIntensity:
inputDebugFlag
setInputDebugFlag:
kernelRecovery
kernelRepair
inputNoiseAmount
setInputNoiseAmount:
inputRecovery
setInputRecovery:
inputWhiteCutoff
setInputWhiteCutoff:
inputChroma
setInputChroma:
inputAnisotropic
setInputAnisotropic:
inputIterations
setInputIterations:
setInputGamma:
inputLocalizationRadius
setInputLocalizationRadius:
inputDebug
setInputDebug:
inputAxisLong
setInputAxisLong:
inputAxisShort
setInputAxisShort:
inputPupilCenter
setInputPupilCenter:
inputSearchAxisLong
setInputSearchAxisLong:
inputSearchAxisShort
setInputSearchAxisShort:
numberWithUnsignedChar:
inputPrimary
setInputPrimary:
inputSecondary
setInputSecondary:
inputOriginLeft
setInputOriginLeft:
inputOriginRight
setInputOriginRight:
inputAxisShortLeft
setInputAxisShortLeft:
inputAxisShortRight
setInputAxisShortRight:
inputAxisLongLeft
setInputAxisLongLeft:
inputAxisLongRight
setInputAxisLongRight:
inputPupilCenterLeft
setInputPupilCenterLeft:
inputPupilCenterRight
setInputPupilCenterRight:
inputOrientationHint
setInputOrientationHint:
inputOrientationScale
setInputOrientationScale:
inputRepairSource
setInputRepairSource:
inputRepairDarken
setInputRepairDarken:
inputRepairChroma
setInputRepairChroma:
inputCutoff
setInputCutoff:
inputSpecMin
setInputSpecMin:
inputSpecMax
setInputSpecMax:
inputSpecular
setInputSpecular:
inputShowMask
setInputShowMask:
inputRepairPercent
setInputRepairPercent:
inputInterPeakMin
setInputInterPeakMin:
inputRepairPercentile
setInputRepairPercentile:
inputClipMin
setInputClipMin:
inputMidSpectrumWhiteOffsets
setInputMidSpectrumWhiteOffsets:
inputClosingErosion
setInputClosingErosion:
inputClosingDilation
setInputClosingDilation:
inputFlooding
setInputFlooding:
inputFeathering
setInputFeathering:
inputFSmooth
setInputFSmooth:
inputRepairDither
setInputRepairDither:
inputRecover
setInputRecover:
inputSpecArea
setInputSpecArea:
inputAbortDensityLo
setInputAbortDensityLo:
inputAbortDensityDiff
setInputAbortDensityDiff:
inputCircularity
setInputCircularity:
inputIntersect
setInputIntersect:
inputSkinThreshold
setInputSkinThreshold:
inputCenterSpecRad
setInputCenterSpecRad:
inputFalloffDensity
setInputFalloffDensity:
inputFalloffRepair
setInputFalloffRepair:
inputFalloffSpecular
setInputFalloffSpecular:
inputRadiusRepair
setInputRadiusRepair:
inputRadiusDensity
setInputRadiusDensity:
inputRadiusSpecular
setInputRadiusSpecular:
inputCentroidIterations
setInputCentroidIterations:
inputCentroidGamma
setInputCentroidGamma:
inputCentroidRadius
setInputCentroidRadius:
inputCentroidRadiusSmall
setInputCentroidRadiusSmall:
inputFoobar
setInputFoobar:
inputFoobar2
setInputFoobar2:
inputFoobar3
setInputFoobar3:
inputFoobar4
setInputFoobar4:
inputRefilterSpace
setInputRefilterSpace:
inputRefilterRange
setInputRefilterRange:
inputDetectWhite
setInputDetectWhite:
inputDetectRed
setInputDetectRed:
inputHeight
setInputHeight:
inputHighLimit
setInputHighLimit:
inputLowLimit
setInputLowLimit:
_kernelLocalContrast
_kernelWarpS
_kernelWarpT
_kernelMix
inputBottomHeight
setInputBottomHeight:
inputNumberOfFolds
setInputNumberOfFolds:
inputFoldShadowAmount
setInputFoldShadowAmount:
_initialConversionRGB
_pyramidGenerateLevel
_smoothDisparity
_propagateDisparityR1
_propagateDisparity
initialConversionForSize:useMetal:
generatePyramidLevel:useMetal:
shiftmapLevelZeroWithSize:useMetal:
propagateDisparity:pyramids:useMetal:computedPyramidLevels:
smoothDisparityImage:useMetal:
outputImageUsingMetal:
_propagateDisparityR1Combined
_propagateDisparityCombined
_combineImages
inputPropagateKernel
setInputPropagateKernel:
inputSmoothSigma
setInputSmoothSigma:
inputPropagateMinWeightSum
setInputPropagateMinWeightSum:
inputPropagateSigmaLuma
setInputPropagateSigmaLuma:
inputPropagateSigmaChma
setInputPropagateSigmaChma:
inputOriginalSize
setInputOriginalSize:
inputOffset
setInputOffset:
inputRange
setInputRange:
inputSpread
setInputSpread:
inputFill
setInputFill:
inputGlowColorInner
setInputGlowColorInner:
inputGlowColorOuter
setInputGlowColorOuter:
inputShadowColorInner
setInputShadowColorInner:
inputShadowColorOuter
setInputShadowColorOuter:
inputShadowBlurInner
setInputShadowBlurInner:
inputShadowBlurOuter
setInputShadowBlurOuter:
inputSoften
setInputSoften:
inputHighlightColor
setInputHighlightColor:
inputShadowColor
setInputShadowColor:
_kernelInvertMask
_kernelMultiplyByMask
setShouldFavorTop:
setShouldFavorBottom:
rectContainingRect:andOtherRect:
rectWithSize:andPoint:inPosition:fromOriginalSize:
scaleRect:toFitSize:withAnchorPoint:
determineBestPositionWithinSize:forImportantRect:restrictRect:
scaleRect:byScale:
expandRect:toContainRect:
computeClippingWithinSize:andImportantRect:
getRatioOfSize:
clusterRects:
computeClippingWithinSize:andImportantRects:
computeClippingWithinSize:forImportantRect:andType:restrictRect:
computeClippingWithinSize:forMultipleRects:
shouldFavorTop
shouldFavorBottom
originalImageSize
setOriginalImageSize:
appendFormat:
writeToFile:atomically:encoding:error:
cpuParams
inputMinMaxImage
setInputMinMaxImage:
inputSimulatedAperture
setInputSimulatedAperture:
inputIntrinsicMatrixFocalLength
setInputIntrinsicMatrixFocalLength:
inputLensModelParams
setInputLensModelParams:
autoRotateFilterFFT:image:inputRect:
calcIntersection:slope1:pt2:slope2:
leftEyeX
rightEyeX
rightEyeY
mouthCenterX
leftEyeLeftX
leftEyelidUpperX
leftEyeRightX
leftEyeRightY
leftEyelidLowerX
rightEyeLeftX
rightEyeLeftY
rightEyelidUpperX
rightEyelidUpperY
rightEyeRightX
rightEyelidLowerX
rightEyelidLowerY
cameraModel
Unknown
iPhone X
iPhone 4
iPhone
KODAK
computeType
forceFail
debugSyntheticPupils
showSpecularShine
syntheticPupilChannel
syntheticRepairTag
syntheticPupilShade
syntheticPupilSoftness
syntheticPupilReach
syntheticPupilSampling
syntheticSpecularShineSoftness
syntheticSpecularShineAlpha
sharpeningEdgeExtractRadius
sharpeningEdgeExtractThreshold
syntheticEyelidOcclusion
syntheticIrisInfill
fileNameBody
0000
imageExtent
orientation
printFaceArrayLevel
printPupilSummary
printIODEtc
printRepairsSaved
printRepairsApplied
printFaceStatistics
printProminenceContainment
printProminenceAlternatives
printEyeOpenness
printConfidenceLog
printImproveBitmaskLevel
printImproveBitmaskConsistencyCheck
printIrisRingLevel
printNeededOcclusions
centerX
centerY
noseBridgeX
noseBridgeY
noseTipX
face %d   left (%.1f, %.1f) right (%.1f, %.1f) IOD %.1f
face %d   mouth (%.1f, %.1f) center (%.1f, %.1f)
face %d   nose bridge (%.1f, %.1f) tip (%.1f, %.1f)
face %d   left eye l (%.1f, %.1f) u (%.1f, %.1f) r (%.1f, %.1f) d (%.1f, %.1f)
face %d   right eye l (%.1f, %.1f) u (%.1f, %.1f) r (%.1f, %.1f) d (%.1f, %.1f)
red-eye correction was prevented: no face detected
mutableCopyOfArray: %s
pointX
pointY
JSON string encoding overflow
errors writing bitmask encoding
errors writing non-zero rectangle
unsigned integer outside represented range
bitmask encoding string too large
failed to allocate input bit string
end-of-bitstream reached prematurely when reading skip rows run
end-of-bitstream reached prematurely when reading continuation run
end-of-bitstream reached prematurely when reading delta run
end-of-bitstream reached prematurely when reading absolute run
end-of-bitstream reached prematurely when reading non-zero rectangle
malformed hex string in bitmask encoding
sizing error in repair bitmask
could not allocate input bit string
run is outside non-zero rect
run is outside bitmask
image special value is out of range
image signal-to-noise ratio is out of range
image orientation is out of range
final eye case is not red, golden, or white
average skin map Y is out of range
existing pupil shade template is improperly formed
corneal specular reflection threshold is out of range
corneal specular reflection seed point is outside the artifact search rectangle
bitmask threshold is out of range
bitmask seed point is outside the artifact search rectangle
snapped hit point is outside the artifact search rectangle
interocular distance is out of range
match pupil shade template is improperly formed
align is not 0 or 1
characterize case is not red, golden, or white
specular shine center point is outside the artifact search rectangle
pupil center point is outside the artifact search rectangle
artifact search rectangle is empty
invalid artifact search rectangle
could not allocate output bit string
could not increase output bit string size when writing
signed integer outside represented range
linear
smoothstep
quadratic
circular
inverse quadratic
inverse circular
disc
kronecker delta
none
face %d/%c %s (%.1f, %.1f) size %.1f aspect %d%% tilt %.1f
 shade %d%% edge %.1f 
     glint (%.1f, %.1f) size %.1f aspect %d%% tilt %.1f
 shade %d%% edge %.1f 
     upper eyelid %s (%.1f, %.1f) (%.1f, %.1f) edge %.1f
     lower eyelid %s (%.1f, %.1f) (%.1f, %.1f) edge %.1f
%s: 
(%2d, %2d) 
%s: %d
bitmask touches the edge
could not allocate inside border point bitmask
could not allocate outside border point bitmask
in (%d, %d) not found
out (%d, %d) not found
actual #out %d != incremental #out %d - never saw (%d, %d)
actual #in %d != incremental #in %d - never saw (%d, %d)
in %.2f/%d out %.2f/%d k = %.2f
start iteration %d
R: [%d...%d, %d...%d]
borders in %d out %d
  (%d, %d) in->out (%d) 
inSum (%d/%d=%.2f) outSum (%d/%d=%.2f) 
nk = %.2f
****** %s
    in %.2f/%d out %.2f/%d k = %.2f
  (%d, %d) out->in (%d) 
end iteration %d: k = %.2f (%d in->out, %d out->in)
graf
prom
window size %d
radius %d
impr
CIGaussianBlur
inputRadius
SharpeningEdgeExtract
inputBlurredImage
inputThreshold
CICrop
inputRectangle
%s (%d, %d) peak %d floor %d threshold %d area %.1f cen (%.1f, %.1f)
face %s   [%6d] c=%5.2f%% d=%5.1f%% lo %3d av %3d hi %3d score %6.1f blur/IOD %6.4f
alte %s/%s %3s c/c %5.3f/%6.3f o %.3f d %.3f s %3d%% HSV %03d %03d %3d cen (%3d,%3d) w %2d h %2d sov %d ov %4d a %4d lk %5.3f
chos %s/%s %3s c/c %5.3f/%6.3f o %.3f d %.3f s %3d%% HSV %3d %3d %3d
face %s/%s saving repair: %s conf %.3f a %d ov %.3f pf %.3f H %.3f S %.3f V %.1f
not local
not circular
not bright
not contained
not facing forward
   min SE %d average SE %d max SE %d sat SE %d in [%d x %d] (%.1f%% of area) glint: %c %s
face %s/%s saving pupil: radius %.2f aspect %5.1f%% angle %.1f
face %s   IOD %.1f dist %.2fm yaw %.1f degrees pupil sizes %.1f%% different
face %s/%c openness %4.1f%%
red-eye correction was prevented: (face %d %s) eye is closed or nearly so
right
left
amber
hue red
hue orange
hue yellow
white
edge
leftEyeLeftY
leftEyelidUpperY
leftEyelidLowerY
rightEyeRightY
leftEyeY
mouthCenterY
noseTipY
%s%c iris ring
^ begin %d (%.1f, %.1f)
^ end %d (%.1f, %.1f)
      %d %3d %3d %3d - %4d %3d %5d
%s%c (%2d, %2d) %s %3d - sv %4d a %4d (a/sv %5.1f) ai %4d ao %4d b %4d rb %4d iob %4d riob %4d g1 %4d g2 %4d
upper
lower
 ***
    
red-eye correction was prevented: (face %d %s eye) in the wrong place
1ini
2coa
3fin
4end
5spr
6cho
7sfi
8sen
9ssp
Asch
grow-%s
threshold %d value %.3f
(%.1f, %.4f),
ray-ellipse intersection: roots are both on the same side of 0
ray-ellipse intersection: descriminant negative
before move-in pass
before move-out pass
at start
syntheticGrowBitmask: seedFill failed
syntheticGrowBitmask: can not allocate bitmask bm
no colors sampled!
      b red grn blu -  val lum  grad
%@/%@
r%d from %.2f 
-> %.2f  
moving center in rotated %s by %.2f pixels
match
scaled Average Camera Travel Distance = %f
scaled Max Registration Error Integral = %f
scaled Mean peak registration error / Max peak registration error = %f
scaled Beginning vs. End AEMatrix difference vs. Average of Adjacent AE Matrix Differences = %f
scaled In-out ratio = %f
scaled Max inner distance = %f
scaled Average registration error skewness = %f
Sequence classified as NON-ACTION due to complete lack of local motion (%f, threshold %f)
Non-Linear SVM Action classifier called with:
Average Camera Travel Distance = %f
Max Registration Error Integral = %f
Mean peak registration error / Max peak registration error = %f
Beginning vs. End AEMatrix difference vs. Average of Adjacent AE Matrix Differences = %f
In-out ratio = %f
Max inner distance = %f
Average registration error skewness = %f
PREDICTION: --- %s --- (value = %f)
ACTION
NON-ACTION
testMaxInnerDistance
Tf,VtestMaxInnerDistance
testInOutRatio
Tf,VtestInOutRatio
testMaxPeakRegistrationError
Tf,VtestMaxPeakRegistrationError
testMeanPeakRegistrationError
Tf,VtestMeanPeakRegistrationError
testMinRegionOfInterestSize
Tf,VtestMinRegionOfInterestSize
testMaxRegistrationErrorSkewness
Tf,VtestMaxRegistrationErrorSkewness
testMaxRegistrationErrorIntegral
Tf,VtestMaxRegistrationErrorIntegral
testAverageCameraTravelDistance
Tf,VtestAverageCameraTravelDistance
testAverageRegistrationErrorSkewness
Tf,VtestAverageRegistrationErrorSkewness
testBeginningVsEndAEMatrixVsAverageAdjacentAEMatrix
Tf,VtestBeginningVsEndAEMatrixVsAverageAdjacentAEMatrix
svmParameters
T^{__SVMParameters=[7{__SVMScaleOffset=ff}]ddii^{CIBurstSupportVector}^{CIBurstSupportVector}},V_svmParameters
burst_mode_logging
staccato_mode_logging
burst_max_pending_frames
burst_disable_analysis
burst_force_face_detection
burst_dummy_analysis
burst_disable_facecore
burst_use_fixed_image
burst_fixed_image_filename
burst_dump_yuv
staccato_yuv_dump
burst_use_version
com.apple.camera
/var/mobile/Library/Caches/com.apple.camera
burstSets
com.apple.burstAnalyzer
dd-MM-yyyy'_'HH-mm-ss'_burstLog.txt'
kern.osversion
com.apple.staccato_dump
counter.bin
BurstDoc_AllImageStats
BurstDoc_AllImageIdentifiers
BurstDoc_BestImageIds
BurstDoc_LogFile
Computing action selection threshold
Mean non-zero actions = %f, std dev = %f
ACTION SELECTION THRESHOLD = %f
Examining image, id=%s, timestamp = %.6f, done=%d
Not processing frames, imageStat.timestamp = %.6f, latestFaceTimestamp = %.6f
LeftEyeFeaturesOffset
RightEyeFeaturesOffset
SmileFeaturesOffset
BlinkFeaturesSize
SmileFeaturesSize
burstimage_%06d.yuv
v4@?0
Image_FaceRectROI
Image_Width
Image_Height
Image_AEAverage
Image_AETarget
Image_AEStable
Image_AFStable
Image_Orientation
Image_AEMatrix
Error!  Done adding, but there are still frames left!
Adding image: %s
Image %d:%s has emotional score %d
Image %d:%s has been emotionally rejected.
Skipping projection computation because data isn't present
LOOKING FOR FALSE-POSITIVE FACES...
Analyzing %s...
REMOVING false-positive face with ID = %d
Keeping face with ID = %d
Collapsing %s
*_*_* GARBAGE DETECTOR FOR %s *_*_*
Travel = %f, maxSkewness = %f, avgSkewness = %f, blur = %f, avgBlur = %f, stdBlur = %f
hasFaces = %d
notBlurry = %d
veryBlurry = %d
potentiallyBlurry = %d
poorRegistration = %d
suspectRegistration = %d
******Image %s classified as garbage.
**** Image %s classified as garbage by association.
Image_FacesArray
Score for %s:%d is %f 
with action score %f and center bias %f (isGarbage=%d)
NEW BEST
Cover photo PORTRAIT selection score for %d:%s = %f (unbiased = %f)
Cover photo ACTION selection score for %d:%s = %f
%s:   # faces = %d, avgH = %f
    face id=%d, rect=%.3f,%.3f,%.3f,%.3f, focus=%.3f, faceScore=%.3f, leftEyeOpen=%d, rightEyeOpen=%d
Performing emotional rejection of face images in cluster %d:
Items in next cluster:
Image %s is classified as garbage for portrait mode, no sharp faces.
Checking temporal order: %d vs. %d
Removing %d:%s
All items in one cluster.
clusterArray
T@"NSMutableArray",VclusterArray
temporalOrder
Ti,VtemporalOrder
faceIDCounts
T@"NSCountedSet",VfaceIDCounts
allImageIdentifiers
T@"NSMutableArray",VallImageIdentifiers
statsByImageIdentifier
T@"NSMutableDictionary",VstatsByImageIdentifier
clusterByImageIdentifier
T@"NSMutableDictionary",VclusterByImageIdentifier
burstLogFileName
T@"NSString",VburstLogFileName
actionClassifier
T@"CIBurstActionClassifier",VactionClassifier
maxNumPendingFrames
Ti,VmaxNumPendingFrames
enableAnalysis
TB,VenableAnalysis
dummyAnalysisCount
Ti,VdummyAnalysisCount
enableFaceCore
TB,VenableFaceCore
enableDumpYUV
TB,VenableDumpYUV
burstCoverSelection
T@"NSString",VburstCoverSelection
burstId
T@"NSString",&,N,VburstId
bestImageIdentifiersArray
T@"NSArray",VbestImageIdentifiersArray
versionString
T@"NSString",V_versionString
version
Ti,V_version
Images without faces = %d, threshold = %d, total # = %d
Classified as portrait mode. Affects cover photo selection.
all costs within valid region: 
mean = %f, std = %f
First average cost = %f
Second average cost = %f
--Invalidating two outliers from the start of the burst
--Invalidating one outlier from the start of the burst
Last average cost = %f
Second-to-last average cost = %f
--Invalidating two outliers from the end of the burst
--Invalidating one outlier from the end of the burst
Number of images too few after invalidation at the endpoints. Return one selection.
Result of three-way division: finalCost: %f, inOutRatio: %f
Classified as non-action.
Classified as action.
Between %d and %d: 
motion: %f
Action mean = %f, action std = %f, action threshold = %f
Local statistics for divider %03d
 with score %f:
 noise threshold = %f, high threshold = %f (mean %f, std %f)
Overall mean divider score = %f
clusterDividerArraySize = %d
Locally-maximal divider %d not considered due to being potential noise (%f vs %f,%f)
Locally-maximal divider %d not considered due to lack of any motion: %f
Locally-maximal divider %d not considered due to being potential noise (nearby peak).
local maxima size: %ld
divider %d
Re-running three-way division with minClusterSize = %d, maxClusterSize = %d
Strongest local maxima: %d and %d
Expanding main peak to include divider %d
Adding action-based cluster boundaries.
Cluster %d is too small for action-based cluster boundaries
Action statistics for cluster %d: mean %f std %f threshold %f
Adding ACTION DIVIDER at location %d
***Finding three way division:
firstValidImage = %d, lastValidImage = %d
NEW BEST: largestInnerDistance = %f, bestRatio = %f
Divider1 = %d, Divider2 = %d
RECURSING: (%d->%d) becomes (%d->%d)
Clustering costs: maxInner = %f, inOutRatio = %f
Threshold for dupes: %f
Distance between selections %d and %d: %f, %f
Selection score of %d is %f... isGarbage = %d
Choosing candidate %d from a series of dupes
Throwing away all dupes due to garbage classification
Keeping candidate %d
Tossing out the %s on %d
trash
reject
All images are garbage. Picking the middle selection = %s.
render
v24@?0^v4L8L12L16L20
v24@?0r^v4L8L12L16L20
Projections error %d:%s in %s @ %s:%d
FastRegistration_status FastRegistration_computeSignatures(const vImage_Buffer *, _Bool, dispatch_queue_t, FastRegistration_Signatures *)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/api/Burst/Projections/FastRegistration_Core.c
FastRegistration error %d:%s in %s @ %s:%d
FastRegistration_status FastRegistration_register(const FastRegistration_Signatures *, const FastRegistration_Signatures *, float, dispatch_queue_t, float *, float *, float *, float *)
FastRegistration_status FastRegistration_processProjections(float *, vImagePixelCount)
10.14
inputSigmaRange
inputSigmaSpace
inputSource
{CGRect={CGPoint=ff}{CGSize=ff}}24@?0i4{CGRect={CGPoint=ff}{CGSize=ff}}8
T@"CIImage",&,N,VinputSource
T@"NSNumber",&,N,VinputSigmaSpace
T@"NSNumber",&,N,VinputSigmaRange
kernel vec4 _CBHorzGuided(sampler u, sampler v, float k, float colorInv, float spatialInv) __attribute__((outputFormat(kCIFormatRGBAh))) { 
 vec2 dc = destCoord(); 
 vec4 u_0 = sample(u, samplerTransform(u, dc)); 
 vec4 v_0 = sample(v, samplerTransform(v, dc)); 
 vec4 Cacc = vec4(0.0); 
 float W = 0.0; 
 int kk = int(k); 
 for (int x = -kk; x <= kk; x++) { 
 float ws = exp(-float(x*x) * spatialInv); 
 vec4 u_xy = sample(u, samplerTransform(u, dc + vec2(x,0.))); 
 vec4 v_xy = sample(v, samplerTransform(v, dc + vec2(x,0.))); 
 float r2 = dot(u_xy.rgb-u_0.rgb, u_xy.rgb-u_0.rgb); 
 float wc = exp(-r2 * colorInv); 
 float w = ws * wc * u_xy.a; 
 W += w; 
 Cacc += w * v_xy; 
 } return vec4(W < 0.00001 ? v_0.rgb : Cacc.rgb / W, v_0.a); 
kernel vec4 _CBVertGuided(sampler u, sampler v, float k, float colorInv, float spatialInv) __attribute__((outputFormat(kCIFormatRGBAh))) { 
 vec2 dc = destCoord(); 
 vec4 u_0 = sample(u, samplerTransform(u, dc)); 
 vec4 v_0 = sample(v, samplerTransform(v, dc)); 
 vec4 Cacc = vec4(0.0); 
 float W = 0.0; 
 int kk = int(k); 
 for (int y = -kk; y <= kk; y++) { 
 float ws = exp(-float(y*y) * spatialInv); 
 vec4 u_xy = sample(u, samplerTransform(u, dc + vec2(0.,y))); 
 vec4 v_xy = sample(v, samplerTransform(v, dc + vec2(0.,y))); 
 float r2 = dot(u_xy.rgb-u_0.rgb, u_xy.rgb-u_0.rgb); 
 float wc = exp(-r2 * colorInv); 
 float w = ws * wc * u_xy.a; 
 W += w; 
 Cacc += w * v_xy; 
 } return vec4(W < 0.00001 ? v_0.rgb : Cacc.rgb / W, v_0.a); 
kernel vec4 _CBHorz(sampler u, float k, float colorInv, float spatialInv) __attribute__((outputFormat(kCIFormatRGBAh))) { 
 vec2 dc = destCoord(); 
 vec4 u_0 = sample(u, samplerTransform(u, dc)); 
 vec4 Cacc = vec4(0.0); 
 float W = 0.0; 
 int kk = int(k); 
 for (int x = -kk; x <= kk; x++) { 
 float ws = exp(-float(x*x) * spatialInv); 
 vec4 u_xy = sample(u, samplerTransform(u, dc + vec2(x,0.))); 
 float r2 = dot(u_xy.rgb-u_0.rgb, u_xy.rgb-u_0.rgb); 
 float wc = exp(-r2 * colorInv); 
 float w = ws * wc * u_xy.a; 
 W += w; 
 Cacc += w * u_xy; 
 } return vec4(W < 0.00001 ? u_0.rgb : Cacc.rgb / W, u_0.a); 
kernel vec4 _CBVert(sampler u, float k, float colorInv, float spatialInv) __attribute__((outputFormat(kCIFormatRGBAh))) { 
 vec2 dc = destCoord(); 
 vec4 u_0 = sample(u, samplerTransform(u, dc)); 
 vec4 Cacc = vec4(0.0); 
 float W = 0.0; 
 int kk = int(k); 
 for (int y = -kk; y <= kk; y++) { 
 float ws = exp(-float(y*y) * spatialInv); 
 vec4 u_xy = sample(u, samplerTransform(u, dc + vec2(0.,y))); 
 float r2 = dot(u_xy.rgb-u_0.rgb, u_xy.rgb-u_0.rgb); 
 float wc = exp(-r2 * colorInv); 
 float w = ws * wc * u_xy.a; 
 W += w; 
 Cacc += w * u_xy; 
 } return vec4(W < 0.00001 ? u_0.rgb : Cacc.rgb / W, u_0.a); 
!!! you should not read this !!!
error with the projections computation
vImage error
out of bounds error
memory allocation error
invalid parameter
invalid option
internal error
v8@?0r^{__IOSurface=}4
ProvTile %llu
ProvTile
v8@?0^{__IOSurface=}4
ProvAssembled %llu
ProvAssembled %p
ProviderNode::surface
provider
 %llX
 %ldx%ld
 tile %zu,%zu
 tile %zu
 nearestsampling
 cache
v12@?0^{roiData={CGRect={CGPoint=ff}{CGSize=ff}}{vector<CI::SerialRectArray::parentROI, std::__1::allocator<CI::SerialRectArray::parentROI> >=^{parentROI}^{parentROI}{__compressed_pair<CI::SerialRectArray::parentROI *, std::__1::allocator<CI::SerialRectArray::parentROI> >=^{parentROI}}}i}4r^{__wrap_iter<CI::SerialRectArray::parentROI *>=^{parentROI}}8
alpha_one
alpha_unpremul
alpha_premul-clear-edges
alpha_unpremul-clear-edges
alpha_unknown
edge_clamp
edge_unknown
10.5
inputCount
inputScale
CIAreaHistogram requires inputCount >= 1 and <= 2048
CIAreaHistogram area width or height is greater than 32768.
CIAreaHistogram outputData requires inputCount >= 1 and <= 256
CIExposureAdjust
CIAreaHistogram failed to allocate memory.
kernel vec4 CIAreaHistogramScale(__sample p, float s) { 
 return floor(s * p * 255.0) / 255.0; 
CIAreaHistogram_%dbins
v12@?0@"<CIImageProcessorInput>"4@"<CIImageProcessorOutput>"8
inputImage
inputExtent
T@"CIVector",&,N,VinputExtent
T@"NSNumber",&,N,VinputScale
T@"NSNumber",&,N,VinputCount
inputPercentile
inputNormalize
inputClip
inputHard
CIAreaMinMaxRed
CIAreaHistogram
T@"NSNumber",&,N,VinputPercentile
T@"NSNumber",&,N,VinputNormalize
T@"NSNumber",&,N,VinputClip
T@"NSNumber",&,N,VinputHard
processHistogram
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/CIAreaHistogram.mm
!hist8
hist8
false
kernel vec4 _perc_norm_red(__sample c, __sample minmax) __attribute__((outputFormat(kCIFormatRh))) { 
 c.r = max((c.r - minmax.r) / max(minmax.g - minmax.r, 0.00001), 0.0); 
 return c; 
kernel vec4 _perc_accum_red(sampler h, float target, float bins) __attribute__((outputFormat(kCIFormatRh))) { 
 float left = 0.0; float right = 0.0; float sum = 0.0; int i = 0; for (; i < int(bins); i++) { float c = sample(h, samplerTransform(h, vec2(0.5) + vec2(i, 0))).r; 
 right += c; 
 if (right >= target) 
 break; 
 left += c; 
 } float t = target > 0.0 && right-left > 0.0 ? (target - left) / (right - left) : 0.0; 
 return vec4((float(i)+t)/bins); 
kernel vec4 _perc_denorm_red(__sample c, __sample minmax) __attribute__((outputFormat(kCIFormatRh))) { 
 c.r = minmax.r + c.r*(minmax.g-minmax.r); 
 return c; 
kernel vec4 _perc_clip_hard(__sample c, __sample p) __attribute__((outputFormat(kCIFormatRh))) { 
 c.r = c.r < p.r ? 0.0 : 1.0; 
 return c; 
kernel vec4 _perc_clip_soft(__sample c, __sample p) __attribute__((outputFormat(kCIFormatRh))) { 
 c.r = c.r < p.r ? 0.0 : c.r; 
 return c; 
kernel vec4 _edgeWork(__sample src, __sample blurred) 
 float lum = dot(src.rgb, vec3(0.299, 0.587, 0.114)); 
 float blum = dot(blurred.rgb, vec3(0.299, 0.587, 0.114)); 
 return vec4(clamp((lum - blum) * 1000.0, 0.0, 1.0)); 
kernel vec4 _edgeWorkContrast(__sample src, float contrast) 
 return clamp((src - 0.5) * contrast + 0.5, 0.0, 1.0); 
10.4
slab_alloc
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/util/x-alloc.c
slab->magic == SLAB_MAGIC (bucket_idx)
slab_dealloc
x-alloc
// Kernel Source
%a %b %e %H:%M:%S %Z %Y
** Log started %s **
X_LOG_FILE
stderr
stdout
setprops
10.10
kernel vec4 _betterDown2 (sampler image) 
 vec4 U = sample(image, samplerTransform(image, destCoord()*2.0 + vec2(0.0, 1.0))); 
 vec4 D = sample(image, samplerTransform(image, destCoord()*2.0 + vec2(0.0,-1.0))); 
 vec4 R = sample(image, samplerTransform(image, destCoord()*2.0 + vec2( 1.0,0.0))); 
 vec4 L = sample(image, samplerTransform(image, destCoord()*2.0 + vec2(-1.0,0.0))); 
 return (U+D+L+R)*0.25; 
kernel vec4 _maskedVariableBlur (__sample mask, 
 __sample c0, __sample c1, __sample c2, __sample c3, __sample c4, __sample c5, __sample c6, 
 float maxBlur) 
 float k = mask.y; 
 k = clamp(k, 0.0, 1.0); 
 float m = k*maxBlur; 
 m = log2(m*4.0/3.0); 
 m = max(m,0.0); 
 float mLo = floor(m); 
 vec4 cLo = c0; 
 vec4 cHi = c1; 
 cLo = (mLo > 0.5) ? c1 : cLo; 
 cHi = (mLo > 0.5) ? c2 : cHi; 
 cLo = (mLo > 1.5) ? c2 : cLo; 
 cHi = (mLo > 1.5) ? c3 : cHi; 
 cLo = (mLo > 2.5) ? c3 : cLo; 
 cHi = (mLo > 2.5) ? c4 : cHi; 
 cLo = (mLo > 3.5) ? c4 : cLo; 
 cHi = (mLo > 3.5) ? c5 : cHi; 
 cLo = (mLo > 4.5) ? c5 : cLo; 
 cHi = (mLo > 4.5) ? c6 : cHi; 
 cLo = (mLo > 5.5) ? c6 : cLo; 
 return mix(cLo,cHi,m-mLo); 
CISoftCubicUpsample
inputMask
T@"CIImage",&,N,VinputMask
T@"NSNumber",&,N,VinputRadius
faceId
Ti,VfaceId
faceRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VfaceRect
framesSinceLast
Ti,VframesSinceLast
maxScore
Tf,VmaxScore
minScore
Tf,VminScore
numScores
Ti,VnumScores
swFaceId
Ti,VswFaceId
swCenter
T{CGPoint=ff},VswCenter
swSize
T{CGSize=ff},VswSize
swLastFrameSeen
Ti,VswLastFrameSeen
hwFaceId
Ti,VhwFaceId
hwCenter
T{CGPoint=ff},VhwCenter
hwSize
T{CGSize=ff},VhwSize
hwLastFrameSeen
Ti,VhwLastFrameSeen
    orientation = %d
Number of HW faces = %d - calculating rect
   hwFaceRect: (%.3f,%.3f,%.3f,%.3f), hasLeftEye = %d, hasRightEye = %d
   face %d = (%.3f,%.3f,%.3f,%.3f)
   fcrect  = (%.3f,%.3f,%.3f,%.3f)
   inserting prev face (hw%d,sw=%d) = (%.3f,%.3f,%.3f,%.3f) padding=(%.3f,%.3f)
calculateFaceFocus:
   adding rect: %.3f,%.3f,%.3f,%.3f
{CGRect={CGPoint=ff}{CGSize=ff}}
   focusScore = %d, %.3f
AdjustFaceIds: Examining '%s'
faceStat.id = %d
    rename found: %d mapped to %d
    new id: %d mapped to %d
    no id: assigning %d
    map found: %d maps to %d
       entry exists with same id: %d
%d faces so far unmatched:
    face %d
    %d overlaps with %d by %.3f %% : 
    matched!  mapping %d to %d
    not matched
      no match found for id %d - adding face
  prevConfig has %d entries
Found mapping!
   mapping not found for %d, mapping to itself
removing config entry: %d
Timestamp
  face ID = %d, timestamp = %.6f
FaceID
Rect
Width
Height
    inserting at index %d, count=%d
  extractFacesFromMetadata
extractFaceMetadata: invalid properties
AccumulatedFaceMetadata
  accumulatedFaceMetadata = %x
adding %d faces
Regions
regions exist
RegionList
  num regions = %d
    latestFaceTimestamp = %.6f
addFacesToImageStat: timestamp = %.6f, lastFaceIndex=%d
    imageTimestamp > latestFaceTimestamp
RollAngle
YawAngle
LeftEyeX
LeftEyeY
LeftEyeWidth
LeftEyeHeight
LeftEyeBlinkLevel
RightEyeX
RightEyeY
RightEyeWidth
RightEyeHeight
RightEyeBlinkLevel
SmileLevel
      found face id %d, timestamp=%.6f, x=%.3f,y=%.3f,w=%.3f,h=%.3f
    adding face id %d, timestamp %.6f
    face id %d, timestamp %.6f - delta = %.6f, perhaps should use FaceCore
FaceInfoArray:
hwId = %d (lastSeen=%d, ctr=%.3f,%.3f size=%.3f,%.3f), swId = %d (lastSeen=%d, ctr=%.3f,%.3f size=%.3f,%.3f)
timeFaceDetectionDone
Td,VtimeFaceDetectionDone
timeBlinkDetectionDone
Td,VtimeBlinkDetectionDone
forceFaceDetectionEnable
TB,VforceFaceDetectionEnable
latestFaceTimestamp
Td,VlatestFaceTimestamp
leftEyeOpen
TB,VleftEyeOpen
rightEyeOpen
TB,VrightEyeOpen
smiling
TB,Vsmiling
leftEyeBlinkScore
Tf,VleftEyeBlinkScore
rightEyeBlinkScore
Tf,VrightEyeBlinkScore
smileScore
Tf,VsmileScore
hasLeftEye
TB,VhasLeftEye
hasRightEye
TB,VhasRightEye
foundByFaceCore
TB,VfoundByFaceCore
normalizedFaceRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VnormalizedFaceRect
focusScore
Tf,VfocusScore
faceScore
Tf,VfaceScore
leftEyeRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VleftEyeRect
rightEyeRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VrightEyeRect
FCRLeftEyeFeaturesOffset
Ti,VFCRLeftEyeFeaturesOffset
FCRRightEyeFeaturesOffset
Ti,VFCRRightEyeFeaturesOffset
FCRSmileFeaturesOffset
Ti,VFCRSmileFeaturesOffset
FCRBlinkFeaturesSize
Ti,VFCRBlinkFeaturesSize
FCRSmileFeaturesSize
Ti,VFCRSmileFeaturesSize
FCRSmileAndBlinkFeatures
T@"NSMutableArray",VFCRSmileAndBlinkFeatures
hwFaceRect
T{CGRect={CGPoint=ff}{CGSize=ff}},V_hwFaceRect
normalizedFocusScore
Tf,VnormalizedFocusScore
normalizedSigma
Tf,VnormalizedSigma
hasRollAngle
TB,VhasRollAngle
hasYawAngle
TB,VhasYawAngle
rollAngle
Tf,VrollAngle
yawAngle
Tf,VyawAngle
timestamp
Td,Vtimestamp
isSyncedWithImage
TB,V_isSyncedWithImage
smallFace
TB,VsmallFace
Image_ImageROIGridStartX
Image_ImageROIGridStartY
Image_ImageROIGridEndX
Image_ImageROIGridEndY
Original ROI = %d,%d -> %d,%d
Smoothed ROI = %d,%d -> %d,%d
Sharpness ROI for %s updated to (%d,%d)->(%d,%d)
%s REGISTERED AGAINST %s
Registration result: tx = %d, ty = %d
----------REGISTRATION ERROR INTEGRAL 
Row interval: (%d->%d)
Column interval: (%d->%d)
sensedROI = (%d,%d)->(%d,%d)
referenceROI = (%d,%d)->(%d,%d)
Registration rejected due to ROI too large or too small.
Registration in favor of face detection ROI.
Registration rejected due to skewness, which can indicate a bad registration result.
Registration rejected due to insufficient local motion.
----------------------- facecore count = %d, numHWFaces = %d
Limited ROI = (%d,%d)->(%d,%d)
Computing sharpness over grid points (%d,%d)->(%d,%d)
After collapse avgHorzDiffY = %f, blurExtent = %f
Num HW faces = %d, facecore faces = %d
combined normalized focus score for face core detections = %f
Limited sharpness score = %f, with number of faces = %d
Thumbnail selection score computation for %s
Average facial focus score = %f
Initial score (no faces) = %f (isGarbage = %d)
Action selection score = %f
imageId
T@"NSString",VimageId
Ti,Vorientation
faceStatArray
T@"NSMutableArray",VfaceStatArray
exclude
TB,Vexclude
AEStable
TB,VAEStable
AEAverage
Ti,VAEAverage
AETarget
Ti,VAETarget
AFStable
TB,VAFStable
avgHorzDiffY
Tf,VavgHorzDiffY
blurExtent
Tf,VblurExtent
imageScore
Tf,VimageScore
actionScore
Tf,VactionScore
timeReceived
Td,VtimeReceived
maxSkewness
Tf,VmaxSkewness
registrationErrorX
Tf,VregistrationErrorX
registrationErrorY
Tf,VregistrationErrorY
registrationErrorIntegral
Tf,VregistrationErrorIntegral
actionClusteringScore
Tf,VactionClusteringScore
hasRegistrationData
TB,VhasRegistrationData
facesRoiRect
T{CGRect={CGPoint=ff}{CGSize=ff}},VfacesRoiRect
numHWFaces
Ti,VnumHWFaces
emotionallyRejected
TB,VemotionallyRejected
doLimitedSharpnessAndBlur
TB,VdoLimitedSharpnessAndBlur
Tf,Vtx
Tf,Vty
isGarbage
TB,VisGarbage
roiSize
Tf,VroiSize
AEDelta
Ti,V_AEDelta
fullsizeJpegSize
Ti,V_fullsizeJpegSize
Registration error stats: mean=%f, stdDev=%f, skewness=%f, maxValue=%f
Insufficient peak error for ROI computation %f (threshold %f)
Peak rejection threshold = %f (mean = %f, std = %f)
Starting ROI construction at %d->%d
-[CIBarcodeDescriptor init]
-[CIBarcodeDescriptor initWithCoder:]
supportsSecureCoding
TB,R
-[CIQRCodeDescriptor isValid]
errorCorrectedPayload
symbolVersion
maskPattern
errorCorrectionLevel
T@"NSData",R,VerrorCorrectedPayload
Ti,R,VsymbolVersion
TC,R,VmaskPattern
Ti,R,VerrorCorrectionLevel
-[CIAztecCodeDescriptor isValid]
isCompact
layerCount
codewordCount
dataCodewordCount
TB,R,VisCompact
Ti,R,VlayerCount
Ti,R,VdataCodewordCount
-[CIPDF417CodeDescriptor isValid]
rowCount
columnCount
Ti,R,VrowCount
Ti,R,VcolumnCount
eccVersion
Ti,R,VeccVersion
com.apple.DetectedBarcode.UserActivityPayload
v20@?0@"NSUserActivity"4@8@"NSString"12@?<v@?@"NSString"@"NSData"@"NSError"B>16
detectedBarcodeDescriptor
T@"CIBarcodeDescriptor",R,C,N
kernel vec4 _triangleTile (sampler src, vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t = destCoord() - center; 
 t = vec2(dot(t, ftrans.xy), dot(t, ftrans.zw)); 
 t = fract(t); 
 t = (t.x > t.y) ? t.yx : t; 
 t.y = (t.y > 2.0 - t.x - t.y) ? (2.0 - t.x - t.y) : t.y; 
 t.x = (t.x < 1.0 - t.x - t.y) ? (1.0 - t.x - t.y) : t.x; 
 t = (t.x > t.y) ? t.yx : t; 
 t = vec2(dot(t, btrans.xy), dot(t, btrans.zw)); 
 t += center; 
 return sample(src, samplerTransform(src, t)); 
kernel vec4 _lozengeRefraction(sampler src, vec2 p0, vec2 p1, float radius, vec2 v01, vec2 x01, float indexOfRefraction, float levitation) 
 vec2 v0 = destCoord() - p0; 
 vec3 c0 = cross(vec3(v0, 0.0), vec3(v01, 0.0)); 
 vec2 unitvec = (c0.z < 0.0) ? x01 : -x01; 
 float dist = abs(c0.z); 
 float dist2 = length(v0); 
 vec2 unitvec2 = normalize(v0); 
 float d0 = dot(v01, v0); 
 dist = (d0 < 0.0) ? dist : dist2; 
 unitvec = (d0 < 0.0) ? unitvec : unitvec2; 
 v0 = destCoord() - p1; 
 dist2 = length(v0); 
 unitvec2 = normalize(v0); 
 d0 = dot(v01, v0); 
 dist = (d0 < 0.0) ? dist2 : dist; 
 unitvec = (d0 < 0.0) ? unitvec2 : unitvec; 
 d0 = dist / radius; 
 vec3 surfaceNormal = vec3(unitvec * d0, sqrt(1.0 - d0 * d0)); 
 float surfaceHeight = surfaceNormal.z * radius + levitation; 
 float eta = 1.0 / indexOfRefraction; 
 float c1 = surfaceNormal.z; 
 float cs2 = 1.0 - eta * eta * (1.0 - c1 * c1); 
 vec3 rayDirection = eta * vec3(0.0, 0.0, -1.0); 
 c1 = eta * c1 - sqrt(abs(cs2)); 
 rayDirection += c1 * surfaceNormal; 
 float t = - surfaceHeight / rayDirection.z; 
 vec2 travel = t * rayDirection.xy; 
 travel = max(min(travel, vec2(radius*2.0)), vec2(-radius*2.0)); 
 vec4 color = sample(src, samplerTransform(src, destCoord() + travel)); 
 color = (cs2 < 0.0) ? vec4(0.0, 0.0, 0.0, 0.0) : color; 
 float alpha = clamp(radius - dist, 0.0, 1.0); 
 vec4 unrefracted = sample(src, samplerCoord(src)); 
 return mix(unrefracted, color, alpha); 
inputPoint0
inputPoint1
kernel vec4 _torusRefraction(sampler src, vec2 center, float a, float b, float c, float indexOfRefraction, float levitation) 
 vec2 v0 = destCoord() - center; 
 float dist = length(v0); 
 vec2 unitvec = normalize(v0); 
 float fdom = a * dist + b; 
 float alpha = clamp((1.0 - abs(fdom)) * c, 0.0, 1.0); 
 vec3 surfaceNormal = vec3(unitvec * fdom, sqrt(1.0 - fdom * fdom)); 
 float surfaceHeight = surfaceNormal.z * c + levitation; 
 vec3 rayOrigin = vec3(destCoord(), surfaceHeight); 
 float eta = 1.0 / indexOfRefraction; 
 float c1 = surfaceNormal.z; 
 float cs2 = 1.0 - eta * eta * (1.0 - c1 * c1); 
 vec3 rayDirection = eta * vec3(0.0, 0.0, -1.0); 
 c1 = eta * c1 - sqrt(abs(cs2)); 
 rayDirection += c1 * surfaceNormal; 
 float t = - surfaceHeight / rayDirection.z; 
 vec3 hitPoint = rayOrigin + t * rayDirection; 
 if (alpha<0.001) hitPoint.xy = vec2(50.0); 
 vec4 color = sample(src, samplerTransform(src, hitPoint.xy)); 
 color = (cs2 < 0.0) ? vec4(0.0, 0.0, 0.0, 0.0) : color; 
 vec4 unrefracted = sample(src, samplerCoord(src)); 
 return mix(unrefracted, color, alpha); 
10.13
inputCurvesData
inputCurvesDomain
inputColorSpace
kernel vec4 _colorcurves (__sample im, sampler2D table, vec2 domain, vec2 normalizer) 
 im.rgb = (im.rgb - domain.x) / (domain.y - domain.x); 
 im.rgb = clamp(im.rgb, 0.0001, 0.9999); 
 return vec4( 
 texture2D(table, vec2(normalizer.x * im.r + normalizer.y, 0.5)).r, 
 texture2D(table, vec2(normalizer.x * im.g + normalizer.y, 0.5)).g, 
 texture2D(table, vec2(normalizer.x * im.b + normalizer.y, 0.5)).b, 
 im.a); 
CIColorCurves
v28@?0^v4L8L12L16L20L24
CIColorCurves inputCurvesData must be of type NSData.
CIColorCurves inputCurvesData is not of the expected length.
CIColorCurves inputCurvesDomain must be of type CIVector and count 2.
CIColorCurves inputCurvesDomain X must be less than Y.
CIColorCurves inputColorSpace must be an RGB CGColorSpaceRef
T@"NSData",C,N,VinputCurvesData
T@"CIVector",&,N,VinputCurvesDomain
T@,&,N,VinputColorSpace
%@.%@
suffix
{CGAffineTransform=ffffff}
output_color_space
working_color_space
working_format
software_renderer
quality
high_quality_downsample
output_premultiplied
kCIContextCacheIntermediates
priority_request_high
priority_request_low
disable_software_fallback
color_cube_size
share_context
default_CGImage_format
parametric_color_matching
inline_affine_matrices
kCIContextEnableBlending
kCIContextUseMetalRenderer
kCIContextAllowClampToAlpha
kCIContextAllowHalfPrecision
kCIContextIntermediateMemoryTarget
kCIContextName
-[CIContext setObject:forKey:]
-[CIContext objectForKey:]
CoreUI
-[CIContext initWithEAGLContext:options:]
-[CIContext render:toBitmap:rowBytes:bounds:format:colorSpace:]
 in Simulator
-[CIContext render:toCVPixelBuffer:bounds:colorSpace:]
-[CIContext render:]
-[CIContext drawImage:inRect:fromRect:]
-[CIContext render:toTexture:target:bounds:colorSpace:]
-[CIContext render:toMTLTexture:commandBuffer:bounds:colorSpace:]
-[CIContext flatten:fromRect:format:colorSpace:]
<%@: %p (%s %d)
%@ MTLDevice=%p
%@ bounds=[empty]
%@ bounds=[%g %g %g %g]
%@    withCGContext: %p
%@    withGLContext: %p
    name: %s
%@    priority: default
%@    priority: high
%@    priority: low
%@    workingSpace: %@
%@    workingFormat: %s
%@    downsampleQuality: %@
High
workingColorSpace
T^{CGColorSpace=},R,N
workingFormat
Ti,R,N
kCIFormatBGRA8, kCIFormatRGBA8, kCIFormatRGBAh or nil
kCIFormatBGRA8, kCIFormatRGBA8, kCIFormatRGBAh, kCIFormatRGBAf or nil
com.apple.CoreImage
com.apple.CoreImage-Internal
v28@?0^v4r^v8Q12Q20
_internalContext
T^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@},R
identifier
TQ,R
peakNonVolatileSize
Ti,R
kernel vec4 _pageCurlTransition(sampler front, sampler back, sampler emap, vec4 cyl, vec2 cyloff, vec4 fbrot, vec2 fboff, vec4 hi, vec2 hioff, float radius, vec4 emapExtent) 
 vec2 backPt; 
 vec2 d = destCoord(); 
 vec2 frontPt = backPt = vec2(dot(d,cyl.xy),dot(d,cyl.zw)) + cyloff; 
 float f = frontPt.x; 
 float asn = sqrt(1.0-pow(frontPt.x,1.5)) - 1.0; 
 float v = frontPt.x + asn*asn*0.5625; 
 frontPt.x = v; 
 backPt.x = (3.141592653589793 - v); 
 frontPt = vec2(dot(frontPt,fbrot.xy),dot(frontPt,fbrot.zw)) + fboff; 
 backPt = vec2(dot(backPt,fbrot.xy),dot(backPt,fbrot.zw)) + fboff; 
 frontPt = (f <= 0.0) ? d : frontPt; 
 vec2 highPt = vec2(dot(d,hi.xy),dot(d,hi.zw)) + hioff; 
 backPt = (f <= 0.0) ? highPt : backPt; 
 vec4 fs = sample(front, samplerTransform(front, frontPt)); 
 vec4 bs = sample(back, samplerTransform(back, backPt)); 
 vec2 n = clamp(f * radius * cyl.xy, -1.0, 1.0); 
 vec2 bn0 = ((f < 0.0) ? vec2(0.0) : n); 
 bn0 = bn0 * 0.5 + 0.5; 
 bn0 = bn0 * emapExtent.zw + emapExtent.xy; 
 vec4 es = sample(emap, samplerTransform(emap, bn0)); 
 es *= bs.a; 
 bs = es + (1.0 - es.a) * bs; 
 vec4 pix = bs + (1.0 - bs.a) * fs; 
 pix *= clamp((1.0 - f) * radius, 0.0, 1.0); 
 return pix; 
kernel vec4 _pageCurlTransNoEmap(sampler front, sampler back, vec4 cyl, vec2 cyloff, vec4 fbrot, vec2 fboff, vec4 hi, vec2 hioff, float radius) 
 vec2 backPt; 
 vec2 d = destCoord(); 
 vec2 frontPt = backPt = vec2(dot(d,cyl.xy),dot(d,cyl.zw)) + cyloff; 
 float f = frontPt.x; 
 float asn = sqrt(1.0-pow(frontPt.x,1.5)) - 1.0; 
 float v = frontPt.x + asn*asn*0.5625; 
 frontPt.x = v; 
 backPt.x = (3.141592653589793 - v); 
 frontPt = vec2(dot(frontPt,fbrot.xy),dot(frontPt,fbrot.zw)) + fboff; 
 backPt = vec2(dot(backPt,fbrot.xy),dot(backPt,fbrot.zw)) + fboff; 
 frontPt = (f <= 0.0) ? d : frontPt; 
 vec2 highPt = vec2(dot(d,hi.xy),dot(d,hi.zw)) + hioff; 
 backPt = (f <= 0.0) ? highPt : backPt; 
 vec4 fs = sample(front, samplerTransform(front, frontPt)); 
 vec4 bs = sample(back, samplerTransform(back, backPt)); 
 vec4 pix = bs + (1.0 - bs.a) * fs; 
 pix *= clamp((1.0 - f) * radius, 0.0, 1.0); 
 return pix; 
CISourceOverCompositing
kernel vec4 _pageCurlWithShadowTransition (sampler front, sampler back, vec4 cyl, vec2 cyloff, vec4 fbrot, vec2 fboff, vec4 hi, vec2 hioff, float radius, vec4 shadowDims, float shadowSize, float shadowAmount, vec4 sheenBright, vec4 sheenDark) 
 float shadowSizeBack = 2.5; 
 float pi = 3.141592653589793; 
 vec2 frontPt, frontPtAlt, backPt, backPtAlt, highPt; 
 vec2 d = destCoord(); 
 vec2 dcyl = vec2(dot(d,cyl.xy),dot(d,cyl.zw)) + cyloff; 
 frontPt = frontPtAlt = dcyl; 
 backPt = backPtAlt = dcyl; 
 float f = frontPt.x; 
 float asn = sqrt(1.0-pow(f,1.5)) - 1.0; 
 frontPt.x = (f <= 0.0) ? f : ((f >= 1.0) ? 9999.0*f : f + asn*asn*0.5625); 
 float ss = f + 0.570796326794897 * smoothstep(0.607,1.3,f); 
 asn = sqrt(1.0-pow(f,1.5)) - 1.0; 
 frontPtAlt.x = (f <= 0.0) ? f : ((f >= 0.9) ? ss : f + asn*asn*0.5625); 
 backPt.x = pi - frontPt.x; 
 backPtAlt.x = pi - frontPtAlt.x; 
 frontPt = vec2(dot(frontPt,fbrot.xy),dot(frontPt,fbrot.zw)) + fboff; 
 frontPtAlt = vec2(dot(frontPtAlt,fbrot.xy),dot(frontPtAlt,fbrot.zw)) + fboff; 
 backPt = vec2(dot(backPt,fbrot.xy),dot(backPt,fbrot.zw)) + fboff; 
 backPtAlt = vec2(dot(backPtAlt,fbrot.xy),dot(backPtAlt,fbrot.zw)) + fboff; 
 frontPtAlt = mix(frontPtAlt, d, 2.0*shadowSize); 
 frontPt = (f < 0.0) ? d : frontPt; 
 highPt = vec2(dot(d,hi.xy),dot(d,hi.zw)) + hioff; 
 backPt = (f < 0.0) ? highPt : backPt; 
 backPtAlt = mix(backPtAlt, highPt, 2.0*shadowSize); 
 vec4 fs = sample(front, samplerTransform(front, frontPt)); 
 fs *= clamp((1.0 - f) * radius, 0.0, 1.0); 
 vec4 bs = sample(back, samplerTransform(back, backPt)); 
 bs *= clamp((1.0 - f) * radius, 0.0, 1.0); 
 float sl = (f<0.0) ? 0.0 : f; 
 sl = clamp(2.5 * (sl - 0.6), 0.0, 1.0); 
 sl = (sl > 0.75) ? (0.4 + 15.0 * (sl - 0.82) * (sl - 0.82)) : (0.35 * sl + 0.375 * sl * sl); 
 vec4 shading = mix(sheenBright, sheenDark, sl); 
 shading *= bs.a; 
 bs = shading + (1.0-shading.a)*bs; 
 vec4 one = vec4(1.0); 
 vec4 zero = vec4(0.0); 
 float light = 0.0; 
 float netH, rr; 
 netH = mix(2.0, 0.5*shadowSizeBack, smoothstep(0.5,1.0,f)); 
 netH = mix(2.3, netH, fs.a); 
 rr = netH * shadowSize * radius; 
 vec4 pp1 = vec4(backPtAlt.xy-shadowDims.xy, shadowDims.zw-backPtAlt.xy)/rr; 
 vec4 v4 = 0.5 + 0.64*pp1 - 0.14*pp1*pp1*pp1; 
 v4 = compare(pp1+one, zero, v4); 
 vec4 ss1 = compare(pp1-one, v4, one); 
 float xx = (1.0-f)/(netH * shadowSize); 
 float fv = 0.5 + 0.64*xx - 0.14*xx*xx*xx; 
 fv = (xx<=-1.0) ? 0.0 : fv; 
 fv = (xx>=1.0) ? 1.0 : fv; 
 light = ss1.x * ss1.y * ss1.z * ss1.w * fv; 
 light = clamp(light, 0.0, 1.0); 
 } float light2; 
 float netH, rr; 
 netH = clamp(f*f,0.0,1.5)*0.65; 
 netH = (f<0.0) ? 0.0 : netH; 
 rr = netH * shadowSize * shadowSizeBack * radius; 
 vec4 pp2 = vec4(frontPtAlt.xy-shadowDims.xy, shadowDims.zw-frontPtAlt.xy)/rr; 
 vec4 v4 = 0.5 + 0.64*pp2 - 0.14*pp2*pp2*pp2; 
 v4 = compare(pp2+one, zero, v4); 
 vec4 ss2 = compare(pp2-one, v4, one); 
 float xx = (1.0-f)/(shadowSize * shadowSizeBack); 
 float fv = 0.5 + 0.64*xx - 0.14*xx*xx*xx; 
 fv = (xx<=-1.0) ? 0.0 : fv; 
 fv = (xx>=1.0) ? 1.0 : fv; 
 light2 = ss2.x * ss2.y * ss2.z * ss2.w * fv; 
 light2 *= 1.0 - fs.a; 
 light2 *= clamp(f*1.0, 0.0, 1.0); 
 light2 = clamp(light2, 0.0, 1.0); 
 if (f<0.0) light2 = 0.0; } light = max(light, light2); 
 light = min(light, 0.5); 
 vec4 shadow = vec4(0.0, 0.0,0.0, light*shadowAmount); 
 vec4 pix = fs; 
 pix = shadow + (1.0-shadow.a)*pix; 
 pix = bs + (1.0-bs.a)*pix; 
 return pix; 
kernel vec4 _pageCurlNoShadowTransition (sampler front, sampler back, vec4 cyl, vec2 cyloff, vec4 fbrot, vec2 fboff, vec4 hi, vec2 hioff, float radius, vec4 sheenBright, vec4 sheenDark) 
 float pi = 3.141592653589793; 
 vec2 d = destCoord(); 
 vec2 dcyl = vec2(dot(d,cyl.xy),dot(d,cyl.zw)) + cyloff; 
 vec2 frontPt = dcyl; 
 vec2 backPt = dcyl; 
 float f = frontPt.x; 
 float asn = sqrt(1.0-pow(f,1.5)) - 1.0; 
 frontPt.x = (f <= 0.0) ? f : ((f >= 1.0) ? 9999.0*f : f + asn*asn*0.5625); 
 backPt.x = pi - frontPt.x; 
 frontPt = vec2(dot(frontPt,fbrot.xy),dot(frontPt,fbrot.zw)) + fboff; 
 backPt = vec2(dot(backPt,fbrot.xy),dot(backPt,fbrot.zw)) + fboff; 
 frontPt = (f < 0.0) ? d : frontPt; 
 vec2 highPt = vec2(dot(d,hi.xy),dot(d,hi.zw)) + hioff; 
 backPt = (f < 0.0) ? highPt : backPt; 
 vec4 fs = sample(front, samplerTransform(front, frontPt)); 
 fs *= clamp((1.0 - f) * radius, 0.0, 1.0); 
 vec4 bs = sample(back, samplerTransform(back, backPt)); 
 bs *= clamp((1.0 - f) * radius, 0.0, 1.0); 
 float sl = (f<0.0) ? 0.0 : f; 
 sl = clamp(2.5 * (sl - 0.6), 0.0, 1.0); 
 sl = (sl > 0.75) ? (0.4 + 15.0 * (sl - 0.82) * (sl - 0.82)) : (0.35 * sl + 0.375 * sl * sl); 
 vec4 shading = mix(sheenBright, sheenDark, sl); 
 shading *= bs.a; 
 bs = shading + (1.0-shading.a)*bs; 
 return bs + (1.0-bs.a)*fs; 
10.9
inputShadowSize
inputShadowAmount
inputShadowExtent
Crashed in [CIFilter dealloc] releasing the value of %@ for %@. Subclasses of CIFilter should not release ivars without setting them to nil afterwards.
dealloc
__WrappedNSNumber
outputImage
CIRequiresKeyedArchiver
CoreImage requires keyed archiving.
CICS_%@
CI_%@
-[CIFilter encodeWithCoder:]_block_invoke
CIName
CIVersion
CIUserInfo
-[CIFilter initWithCoder:]_block_invoke
<%@: 
%@inputVersion=%@ 
%@%@=%@%c
-[CIFilter apply:arguments:options:]
regionOf:destRect:userInfo:
regionOf:destRect:
DGCurvesFilter
PXSoftProofingFilter
-[CIFilter apply:arguments:options:]_block_invoke
PX_CIF_Noise
T@"CIImage",R,D,N
name
T@"NSString",C,N
enabled
TB,GisEnabled,V_enabled
inputKeys
T@"NSArray",R,N
outputKeys
attributes
T@"NSDictionary",R,N
input%@
%@,%@=%@
%@,%@="%s"
%@,%@=nil
CIAffineTransform
+[CIFilter(Private) _propertyArrayFromFilters:inputImageExtent:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/api/CIFilter.mm
affineFilter != nil || cropFilter != nil
CropAngle
CropTop
CropBottom
CropLeft
CropRight
HasCrop
AlreadyApplied
Filters
CIRedEyeCorrections
CIFaceBalance
CIVibrance
CIToneCurve
CIHighlightShadowAdjust
+[CIFilter(Private) _filterArrayFromProperties:]
CIAttributeFilterName
CIAttributeFilterDisplayName
CIAttributeDescription
CIAttributeFilterAvailable_Mac
CIAttributeFilterAvailable_iOS
CIAttributeReferenceDocumentation
CIAttributeFilterCategories
CIAttributeClass
CIAttributeType
CIAttributeMin
CIAttributeMax
CIAttributeSliderMin
CIAttributeSliderMax
CIAttributeDefault
CIAttributeIdentity
CIAttributeName
CIAttributeDisplayName
CIUIParameterSet
CIUISetBasic
CIUISetIntermediate
CIUISetAdvanced
CIUISetDevelopment
CIAttributeTypeTime
CIAttributeTypeScalar
CIAttributeTypeDistance
CIAttributeTypeAngle
CIAttributeTypeBoolean
CIAttributeTypeInteger
CIAttributeTypeCount
CIAttributeTypePosition
CIAttributeTypeOffset
CIAttributeTypePosition3
CIAttributeTypeRectangle
CIAttributeTypeColor
CIAttributeTypeOpaqueColor
CIAttributeTypeImage
CIAttributeTypeGradient
CIAttributeTypeTransform
inputBackgroundImage
inputDepthImage
inputDisparityImage
inputTime
inputTransform
inputAspectRatio
inputCenter
inputAngle
inputRefraction
inputWidth
inputSharpness
inputIntensity
inputAmount
inputEV
inputSaturation
inputColor
inputBrightness
inputContrast
inputGradientImage
inputBias
inputWeights
inputMaskImage
inputMatteImage
inputShadingImage
inputTargetImage
__inputVersion
CICategoryDistortionEffect
CICategoryGeometryAdjustment
CICategoryCompositeOperation
CICategoryLightingEffect
CICategoryHalftoneEffect
CICategoryColorAdjustment
CICategoryColorEffect
CICategoryTransition
CICategoryTileEffect
CICategoryGenerator
CICategoryGradient
CICategoryStylize
CICategorySharpen
CICategoryBlur
CICategoryVideo
CICategoryStillImage
CICategoryInterlaced
CICategoryNonSquarePixels
CICategoryHighDynamicRange
CICategoryApplePrivate
CICategoryReduction
CICategoryBuiltIn
CICategoryFilterGenerator
CICategoryXMPSerializable
extent
definition
user_info
color_space
cs_deviceGray
cs_deviceRGB
cs_deviceCMYK
CGImageMetadataCreateFromMetadataProperties
/System/Library/Frameworks/ImageIO.framework/ImageIO
CGImageMetadataCreateMetadataProperties
kernel vec4 _parallelogramTile (sampler src, vec2 center, vec2 ftransx, vec2 ftransy, vec2 btransx, vec2 btransy) 
 vec2 t2; 
 vec2 t1 = destCoord() - center; 
 t2.x = dot(t1, ftransx); 
 t2.y = dot(t1, ftransy); 
 t2 = fract(t2); 
 t2 = min(t2, vec2(1.0) - t2); 
 t2 = t2 + t2; 
 t1.x = dot(t2, btransx); 
 t1.y = dot(t2, btransy); 
 return sample(src, samplerTransform(src, t1 + center)); 
inputAcuteAngle
kernel vec4 _motionBlur (sampler src, vec4 parms) 
 vec2 delta = parms.xy; 
 vec2 delt2 = delta * 2.0; 
 vec2 p0 = samplerTransform (src, destCoord() - delt2); 
 vec2 p1 = samplerTransform (src, destCoord() - delta); 
 vec2 p3 = samplerTransform (src, destCoord() + delta); 
 vec2 p4 = samplerTransform (src, destCoord() + delt2); 
 vec4 s0 = sample (src, p0); 
 vec4 s1 = sample (src, p1); 
 vec4 s2 = sample (src, samplerCoord(src)); 
 vec4 s3 = sample (src, p3); 
 vec4 s4 = sample (src, p4); 
 vec2 w = parms.zw; 
 return w.x * s2 + w.y * (s3 + s1 + (w.y * (s4 + s0))); 
T@"NSNumber",&,N,VinputAngle
kernel vec4 _zoomBlur (sampler src, vec2 center, vec4 parms, vec4 w0, float w1) 
 vec2 v = destCoord() - center; 
 vec4 s0 = sample (src, samplerCoord (src)); 
 vec4 s1 = sample (src, samplerTransform (src, v * parms.x + center)); 
 vec4 s2 = sample (src, samplerTransform (src, v * parms.y + center)); 
 vec4 s3 = sample (src, samplerTransform (src, v * parms.z + center)); 
 vec4 s4 = sample (src, samplerTransform (src, v * parms.w + center)); 
 return s4*w0.x + s3*w0.y + s2*w0.z + s1*w0.w + s0*w1; 
kernel vec4 _zoom (sampler src, vec2 center, float k) 
 vec2 dist = destCoord() - center; 
 vec4 result = vec4(0.0); 
 for (int n=0; n<100; n++) 
 float f = float(n) / 99.0; 
 f -= 0.5; 
 f = (f + f*f*f)*0.8 + 0.5; 
 vec2 p = dist * mix(k, 1.0, f); 
 result += sample(src, samplerTransform(src, center + p)) * 0.01; 
 return result; 
T@"CIVector",&,N,VinputCenter
T@"NSNumber",&,N,VinputAmount
CIImageFlipped
CIImagePremultiplied
opaque
CIImageColorSpace
CIImageEdgesAreClear
CIImageProperties
kCIImageApplyOrientationProperty
CIImageClampToEdge
CIImageNearestSampling
CIImageEdgeRepeat
kCIImageAlphaOne
kCIImageCacheHint
kCIImageCacheImmediately
kCIImageYCCMatrix
kCIImageTextureTarget
kCIImageTextureFormat
ignorePixelFormatFor601Fixup
kCIImageAuxiliaryDepth
kCIImageAuxiliaryDisparity
kCIImageAVDepthData
kCIImageAVPortraitEffectsMatte
kCIImageAuxiliaryPortraitEffectsMatte
CIImageSurfaceFormat
/tmp
tiff
public.png
public.tiff
-[CIImage initWithCGImage:options:]
CIImage
RGBAh
ABGR8
mask
decode array
pixel format that is unsupported
kCGImageAuxiliaryDataTypePortraitEffectsMatte
v12@?0^v4I8
-[CIImage initWithTexture:size:options:]
+[CIImage imageWithMTLTexture:options:]
-[CIImage initWithMTLTexture:options:]
initWithCVImage
v32@?0^v4L8L12L16L20L24L28
-[CIImage initWithCVPixelBuffer:options:]
-[CIImage initWithCVImageBuffer:options:]
-[CIImage imageByColorMatchingWorkingSpaceToColorSpace:]
-[CIImage imageByColorMatchingWorkingSpaceToRGBorGrayColorSpace:]
-[CIImage imageByColorMatchingColorSpaceToWorkingSpace:]
-[CIImage imageByTaggingWithColorSpace:]
-[CIImage imageBySettingProperties:]
-[CIImage imageBySettingPropertiesNoCopy:]
-[CIImage initWithArrayOfImages:selector:]
<CIImage: %p extent [infinite]>
<CIImage: %p extent [empty]>
<CIImage: %p extent [%g %g %g %g]>
<CIImage: %p extent [infinite]>
<CIImage: %p extent [empty]>
<CIImage: %p extent [%g %g %g %g]>
CoreImage doesn't support old-style archiving
CIImageEncoder
CoreImage doesn't support archiving infinite images.
-[CIImage encodeWithCoder:]_block_invoke
-[CIImage initWithCoder:]_block_invoke
<CIImage: %p> printTree:
-[CIImage setValue:forKeyPath:]
T{CGRect={CGPoint=ff}{CGSize=ff}},R,N
properties
T@"NSDictionary",R
T@"CIFilterShape",R
T@"NSURL",R
colorSpace
T^{CGColorSpace=},R
pixelBuffer
T^{__CVBuffer=},R,N
CGImage
T^{CGImage=},R,N
depthData
T@"AVDepthData",R,N
portraitEffectsMatte
T@"AVPortraitEffectsMatte",R,N
kCIImageTextScaleFactor
tagcolorspace 
CICGImageData
CICGImageWidth
CICGImageHeight
CICGImageBPC
CICGImageBPP
CICGImageBPR
CICGImageAlphaInfo
CICGImageInterp
CICGImageRI
CIKernelMessageType
CIKernelMessageTypeNote
CIKernelMessageTypeRemark
CIKernelMessageTypeWarning
CIKernelMessageTypeError
CIKernelMessageTypeFatal
CIKernelMessageFilename
CIKernelMessageLineNumber
kCIKernelMessageOffset
kCIKernelMessageDescription
kCIKernelMessageTypeSyntaxError
kCIKernelMessageTypeInternalError
kCIKernelMessageTypeFunctionName
kCIKernelOutputFormat
No valid kernels were in the string
Printed AST of kernel %s:
Kernel %s has an unsupported type for the parameter %s
outputFormat
kCIFormat
Function does not exist in library data. %s
Check if Metal library is linked with -cikernel option.
reflect
<%@: %s>
vec4  compare (vec4 x, vec4 y, vec4 z)    { return mix(y, z, step(0.0,x)); }
vec3  compare (vec3 x, vec3 y, vec3 z)    { return mix(y, z, step(0.0,x)); }
vec2  compare (vec2 x, vec2 y, vec2 z)    { return mix(y, z, step(0.0,x)); }
float compare (float x, float y, float z) { return x < 0.0 ? y : z; }
vec4  cos_ (vec4 x)  { return cos(x); }
vec3  cos_ (vec3 x)  { return cos(x); }
vec2  cos_ (vec2 x)  { return cos(x); }
float cos_ (float x) { return cos(x); }
vec4  sin_ (vec4 x)  { return sin(x); }
vec3  sin_ (vec3 x)  { return sin(x); }
vec2  sin_ (vec2 x)  { return sin(x); }
float sin_ (float x) { return sin(x); }
vec4  tan_ (vec4 x)  { return tan(x); }
vec3  tan_ (vec3 x)  { return tan(x); }
vec2  tan_ (vec2 x)  { return tan(x); }
float tan_ (float x) { return tan(x); }
vec2 cossin (float x)
    return vec2(cos(x), sin(x));
vec2 cossin_ (float x)
    return vec2(cos_(x), sin_(x));
vec2 sincos (float x)
    return vec2(sin(x), cos(x));
vec2 sincos_ (float x)
    return vec2(sin_(x), cos_(x));
vec4 premultiply (vec4 s)
    return vec4(s.rgb*s.a, s.a);
hvec4 premultiply (hvec4 s)
    return hvec4(s.rgb*s.a, s.a);
vec4 unpremultiply (vec4 s)
    return vec4(s.rgb/max(s.a,0.00001), s.a);
hvec4 unpremultiply (hvec4 s)
    return hvec4(s.rgb/max(s.a,0.0001h), s.a);
vec3 srgb_to_linear (vec3 s)
    return sign(s)*mix(abs(s)*0.077399380804954, pow(abs(s)*0.947867298578199 + 0.052132701421801, vec3(2.4)), step(0.04045, abs(s)));
hvec3 srgb_to_linear (hvec3 s)
    return sign(s)*mix(abs(s)*0.077399380804954h, pow(abs(s)*0.947867298578199h + 0.052132701421801h, hvec3(2.4h)), step(0.04045h, abs(s)));
vec4 srgb_to_linear (vec4 s)
    s = unpremultiply(s);
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*0.077399380804954, pow(abs(s.rgb)*0.947867298578199 + 0.052132701421801, vec3(2.4)), step(0.04045, abs(s.rgb)));
    return premultiply(s);
hvec4 srgb_to_linear (hvec4 s)
    s = unpremultiply(s);
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*0.077399380804954h, pow(abs(s.rgb)*0.947867298578199h + 0.052132701421801h, hvec3(2.4h)), step(0.04045h, abs(s.rgb)));
    return premultiply(s);
vec4 _srgb_to_linear (vec4 s)
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*0.077399380804954, pow(abs(s.rgb)*0.947867298578199 + 0.052132701421801, vec3(2.4)), step(0.04045, abs(s.rgb)));
    return s;
vec3 linear_to_srgb (vec3 s)
    return sign(s)*mix(abs(s)*12.92, pow(abs(s), vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abs(s)));
hvec3 linear_to_srgb (hvec3 s)
    return sign(s)*mix(abs(s)*12.92h, pow(abs(s), hvec3(0.4166667h)) * 1.055h - 0.055h, step(0.0031308h, abs(s)));
vec4 linear_to_srgb (vec4 s)
    s = unpremultiply(s);
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*12.92, pow(abs(s.rgb), vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abs(s.rgb)));
    return premultiply(s);
hvec4 linear_to_srgb (hvec4 s)
    s = unpremultiply(s);
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*12.92h, pow(abs(s.rgb), hvec3(0.4166667h)) * 1.055h - 0.055h, step(0.0031308h, abs(s.rgb)));
    return premultiply(s);
vec4 _linear_to_srgb (vec4 s)
    s.rgb = sign(s.rgb)*mix(abs(s.rgb)*12.92, pow(abs(s.rgb), vec3(0.4166667)) * 1.055 - 0.055, step(0.0031308, abs(s.rgb)));
    return s;
vec2 destCoord ()
    return _dc;
#define _samplerOffset(src, offset) (samplerTransform(src,offset) - samplerTransform(src,vec2(0.0)))
#define gatherX(src, point) vec4 \
    sample(src, point+_samplerOffset(src,vec2(-0.5,-0.5))).x, \
    sample(src, point+_samplerOffset(src,vec2( 0.5,-0.5))).x, \
    sample(src, point+_samplerOffset(src,vec2( 0.5, 0.5))).x, \
    sample(src, point+_samplerOffset(src,vec2(-0.5, 0.5))).x  \
#define gatherY(src, point) vec4 \
    sample(src, point+_samplerOffset(src,vec2(-0.5,-0.5))).y, \
    sample(src, point+_samplerOffset(src,vec2( 0.5,-0.5))).y, \
    sample(src, point+_samplerOffset(src,vec2( 0.5, 0.5))).y, \
    sample(src, point+_samplerOffset(src,vec2(-0.5, 0.5))).y  \
#define gatherZ(src, point) vec4 \
    sample(src, point+_samplerOffset(src,vec2(-0.5,-0.5))).z, \
    sample(src, point+_samplerOffset(src,vec2( 0.5,-0.5))).z, \
    sample(src, point+_samplerOffset(src,vec2( 0.5, 0.5))).z, \
    sample(src, point+_samplerOffset(src,vec2(-0.5, 0.5))).z  \
#define gatherW(src, point) vec4 \
    sample(src, point+_samplerOffset(src,vec2(-0.5,-0.5))).w, \
    sample(src, point+_samplerOffset(src,vec2( 0.5,-0.5))).w, \
    sample(src, point+_samplerOffset(src,vec2( 0.5, 0.5))).w, \
    sample(src, point+_samplerOffset(src,vec2(-0.5, 0.5))).w  \
#define _unordered_gatherX(src, point) gatherX(src, point)
#define _unordered_gatherY(src, point) gatherY(src, point)
#define _unordered_gatherZ(src, point) gatherZ(src, point)
#define _unordered_gatherW(src, point) gatherW(src, point)
#define samplerOrigin(src) samplerExtent(src).xy
#define samplerSize(src) samplerExtent(src).zw
void writeImage (vec4 color, vec2 point) {}
void writeImagePlane (vec4 color, vec2 point) {}
void writePixel (int r, int g, int b, int a, vec2 point) {}
vec2 writeCoord () { return vec2(0.0); }
#define new _new
#define delete _delete
#define and _and
#define not _not
#define or _or
#define xor _xor
__sampler
sampler
-[CIKernel _initWithString:andMetalLibrary:usingCruftCompatibility:]
+[CIKernel kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:outputGroupSize:error:]
, kCIFormat
-[CIKernel applyWithExtent:roiCallback:arguments:options:]
_arg%d
CISampler
NSNumber
CIVector
CIVectorSize
CIColor
perservesAlpha
TB,N
canReduceOutputChannels
preservesRange
outputGroupSize
T{CGSize=ff},N
T@"NSString",R
-[CIColorKernel applyWithExtent:roiCallback:arguments:options:]
-[CIColorKernel applyWithExtent:roiCallback:arguments:]
-[CIColorKernel applyWithExtent:arguments:options:]
-[CIWarpKernel applyWithExtent:roiCallback:arguments:options:]
-[CIWarpKernel applyWithExtent:roiCallback:arguments:]
-[CIWarpKernel applyWithExtent:roiCallback:inputImage:arguments:options:]
{%g,%g %g x %g}
CIKernel
CINonLocalizedDescriptionKey
[CIKernelPool] 
note: 
remark: 
WARNING: 
ERROR: 
FATAL ERROR: 
v12@?0@"NSString"4^B8
 errors 
 error 
generated.
Expected a CIImage or a CISampler. 
Expected a leaf CIImage.
Expected an NSNumber or a CIVector of count 1. 
Expected a CIVector of count 2 or more. 
Expected a CIVector of count 3 or more. 
Expected a CIVector of count 4 or more. 
Expected a CIVector of count 4.
Expected a CIVector of count 6 or 9. 
Expected a CIVector of count 16. 
Expected a CIColor or CIVector. 
AffineImage
ClampToAlphaImage
ColorMatchImage
ColorMatrixImage
CropImage
ClampImage
FillImage
GammaImage
ColorKernelImage
WarpKernelImage
GeneralKernelImage
SRGBImage
NoopImage
PremultiplyImage
ProcessorImage
ProviderImage
SampleModeImage
SetPropsImage
SurfaceImage
SwitchImage
SwizzleImage
TagColorSpaceImage
TextueImage
AffineNode
ColorKernelNode
WarpKernelNode
GeneralKernelNode
CGNode
ClampToAlphaNode
ColorMatrixNode
CropNode
ClampNode
GammaNode
CurveNode
FillNode
NoopNode
PremultiplyNode
ProcessorNode
ConvertNode
ProviderNode
SRGBNode
SampleModeNode
SurfaceNode
SwizzleNode
TextureNode
ProgramNode
Bitmap
Vector
Color
TextureSampler
ColorKernel
WarpKernel
GeneralKernel
MainProgram
MetalDAG
CLContext
GLContext
MetalContext
SurfaceCacheEntry
TileTask
RenderTask
RenderToBitmap
RenderToPixelBuffer
RenderToSurface
RenderToGLTexture
RenderToMTLTexture
RenderToPixelBufferProvider
RenderToSurfaceProvider
RenderToMTLTextureProvider
Unknown enum %d
<CI::Object %s %p ref=%u>
[infinite]
[null]
[empty]
[%g %g %g %g]
B20@?0^{GraphObject=^^?{atomic<unsigned int>=AI}}4^{GraphObject=^^?{atomic<unsigned int>=AI}}8i12i16
v20@?0^{GraphObject=^^?{atomic<unsigned int>=AI}}4^{GraphObject=^^?{atomic<unsigned int>=AI}}8i12i16
IOSurface
IOSurface %p
(%d)
 seed:%d
SurfaceNode::surface
v8@?0^v4
%.*sNULL
%.*s
<%ld>
 <%ld>
 rois=
 extent=
 luma opaque
 r-only opaque
 rg-only opaque
 opaque
crop 
Singular matrix 
 cannot be inverted!
[%g %g %g %g %g %g]
crop
colorkernel %s
=nil
<CI::%s %p, %s>
inputFilterName
_dict
T@"NSMutableDictionary",&,V_dict
T@"NSString",C,VinputFilterName
tile_size
kCIImageProviderContentDigest
kCIImageProviderName
provideImageData:bytesPerRow:origin::size::userInfo:
%s provider does not implement provideImageData:bytesPerRow:origin::size::userInfo:.
-[CIImage(CIImageProvider) initWithImageProvider:size::format:colorSpace:options:]
provideImageTexture:bounds:userInfo:
CIImageProvider <%s %p> %zux%zu at %zu,%zu
%s format is not supported.
-[CIImage(CIImageProvider) _initWithImageProvider:width:height:format:colorSpace:surfaceCache:options:]
%s format %s is not supported.
CIImage kCIImageEdgeRepeat not supported.
%s kCIImageProviderTileSize value is not a NSNumber, NSArray, CIVector, or NSNull.
%s kCIImageProviderContentDigest value is not NSData of at least 32 bytes.
samplemode %s
point
nearest
unknown
affine %s
loQ 
hiQ 
face
allPoints
faceContour
innerLips
leftEye
leftEyebrow
leftPupil
medianLine
nose
noseCrest
outerLips
rightEye
rightEyebrow
rightPupil
junkiness
CIVNDetectFaces
CIVNDetectLandmarks
Orientation
VNImageOptionImageOrientation
/System/Library/Frameworks/Vision.framework/Vision
VNImageOptionCIContext
VNImageRequestHandler
VNDetectFaceRectanglesRequest
VNDetectFaceLandmarksRequest
CGImageSurfaceCacheQueue
CGImageRef %p %s %ldx%ld 
kernel vec4 _ASGh50(sampler src) 
 vec2 dc = destCoord(); 
 vec2 srcPt = vec2(floor(floor(dc.x) * 2.0 + 0.499) + 0.5, dc.y); 
 vec2 d = samplerTransform(src, vec2(1.0, 0.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 p = sample(src, coord) * 0.500106; 
 p += (sample(src, coord + d) + sample(src, coord - d)) * 0.294604; 
 p -= (sample(src, coord + d*3.0) + sample(src, coord - d*3.0)) * 0.0507232; 
 p += (sample(src, coord + d*5.0) + sample(src, coord - d*5.0)) * 0.00606636; 
 return p; 
kernel vec4 _ASGv50(sampler src) 
 vec2 dc = destCoord(); 
 vec2 srcPt = vec2(dc.x, floor(floor(dc.y) * 2.0 + 0.499) + 0.5); 
 vec2 d = samplerTransform(src, vec2(0.0, 1.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 p = sample(src, coord) * 0.500106; 
 p += (sample(src, coord + d) + sample(src, coord - d)) * 0.294604; 
 p -= (sample(src, coord + d*3.0) + sample(src, coord - d*3.0)) * 0.0507232; 
 p += (sample(src, coord + d*5.0) + sample(src, coord - d*5.0)) * 0.00606636; 
 return p; 
kernel vec4 _ASGh66(sampler src) { vec2 dc = destCoord(); 
 float residue = floor(fract(dc.x/2.0)*2.0); 
 vec2 srcPt = vec2(floor(floor(dc.x) * 1.5 + 0.499) + 0.5, dc.y); 
 vec2 d = samplerTransform(src, vec2(1.0, 0.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 d2 = d + d; 
 vec2 d3 = d2 + d; 
 vec2 d4 = d2 + d2; 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 s0 = sample(src, coord - d4); 
 vec4 s1 = sample(src, coord - d3); 
 vec4 s2 = sample(src, coord - d2); 
 vec4 s3 = sample(src, coord - d ); 
 vec4 s4 = sample(src, coord ); 
 vec4 s5 = sample(src, coord + d ); 
 vec4 s6 = sample(src, coord + d2); 
 vec4 s7 = sample(src, coord + d3); 
 vec4 s8 = sample(src, coord + d4); 
 vec4 index0pix = s4*0.6665609 + (s3+s5)*0.2399313 - (s2+s6)*0.0775183 + (s0+s8)*0.0043066; 
 vec4 index1pix = (s4+s5)*0.5328763 - (s2+s7)*0.0436967 + (s1+s8)*0.0108204; 
 return mix(index0pix, index1pix, residue); 
kernel vec4 _ASGv66(sampler src) 
 vec2 dc = destCoord(); 
 float residue = floor(fract(dc.y/2.0)*2.0); 
 vec2 srcPt = vec2(dc.x, floor(floor(dc.y) * 1.5 + 0.499) + 0.5); 
 vec2 d = samplerTransform(src, vec2(0.0, 1.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 d2 = d + d; 
 vec2 d3 = d2 + d; 
 vec2 d4 = d2 + d2; 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 s0 = sample(src, coord - d4); 
 vec4 s1 = sample(src, coord - d3); 
 vec4 s2 = sample(src, coord - d2); 
 vec4 s3 = sample(src, coord - d ); 
 vec4 s4 = sample(src, coord ); 
 vec4 s5 = sample(src, coord + d ); 
 vec4 s6 = sample(src, coord + d2); 
 vec4 s7 = sample(src, coord + d3); 
 vec4 s8 = sample(src, coord + d4); 
 vec4 index0pix = s4*0.6665609 + (s3+s5)*0.2399313 - (s2+s6)*0.0775183 + (s0+s8)*0.0043066; 
 vec4 index1pix = (s4+s5)*0.5328763 - (s2+s7)*0.0436967 + (s1+s8)*0.0108204; 
 return mix(index0pix, index1pix, residue); 
kernel vec4 _ASGh75(sampler src) 
 vec2 dc = destCoord(); 
 float residue = floor(fract(dc.x/3.0)*3.0); 
 vec2 srcPt = vec2(floor(floor(dc.x) * 1.3333333333 + 0.5) + 0.5, dc.y); 
 vec2 d = samplerTransform(src, vec2(1.0, 0.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 d2 = d + d; 
 vec2 d3 = d2 + d; 
 vec2 d4 = d2 + d2; 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 s0 = sample(src, coord - d4); 
 vec4 s1 = sample(src, coord - d3); 
 vec4 s2 = sample(src, coord - d2); 
 vec4 s3 = sample(src, coord - d ); 
 vec4 s4 = sample(src, coord ); 
 vec4 s5 = sample(src, coord + d ); 
 vec4 s6 = sample(src, coord + d2); 
 vec4 s7 = sample(src, coord + d3); 
 vec4 s8 = sample(src, coord + d4); 
 vec4 index0pix = s4*0.7502581 + (s3+s5)*0.1888096 - (s2+s6)*0.0760948 + (s1+s7)*0.0121562; 
 vec4 index1pix = -s0*0.0003689 + s1*0.0090998 - s2*0.0344513 + s4*0.6624862 + s5*0.4419191 - s6*0.0817168 + s8*0.0030319; 
 vec4 index2pix = s0*0.0030319 - s2*0.0817168 + s3*0.4419191 + s4*0.6624862 - s6*0.0344513 + s7*0.0090998 - s8*0.0003689; 
 vec4 pix = mix(index0pix, index1pix, min(residue, 1.0)); 
 return mix(pix, index2pix, max(residue - 1.0, 0.0)); 
kernel vec4 _ASGv75(sampler src) 
 vec2 dc = destCoord(); 
 float residue = floor(fract(dc.y/3.0)*3.0); 
 vec2 srcPt = vec2(dc.x, floor(floor(dc.y) * 1.3333333333 + 0.5) + 0.5); 
 vec2 d = samplerTransform(src, vec2(0.0, 1.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 d2 = d + d; 
 vec2 d3 = d2 + d; 
 vec2 d4 = d2 + d2; 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 s0 = sample(src, coord - d4); 
 vec4 s1 = sample(src, coord - d3); 
 vec4 s2 = sample(src, coord - d2); 
 vec4 s3 = sample(src, coord - d ); 
 vec4 s4 = sample(src, coord ); 
 vec4 s5 = sample(src, coord + d ); 
 vec4 s6 = sample(src, coord + d2); 
 vec4 s7 = sample(src, coord + d3); 
 vec4 s8 = sample(src, coord + d4); 
 vec4 index0pix = s4*0.7502581 + (s3+s5)*0.1888096 - (s2+s6)*0.0760948 + (s1+s7)*0.0121562; 
 vec4 index1pix = -s0*0.0003689 + s1*0.0090998 - s2*0.0344513 + s4*0.6624862 + s5*0.4419191 - s6*0.0817168 + s8*0.0030319; 
 vec4 index2pix = s0*0.0030319 - s2*0.0817168 + s3*0.4419191 + s4*0.6624862 - s6*0.0344513 + s7*0.0090998 - s8*0.0003689; 
 vec4 pix = mix(index0pix, index1pix, min(residue, 1.0)); 
 return mix(pix, index2pix, max(residue - 1.0, 0.0)); 
kernel vec4 _ASGh80(sampler src) 
 vec2 dc = destCoord(); 
 float residue = floor(fract(dc.x/4.0)*4.0); 
 vec2 srcPt = vec2(floor(floor(dc.x) * 1.25 + 0.499) + 0.5, dc.y); 
 vec2 d = samplerTransform(src, vec2(1.0, 0.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 d2 = d + d; 
 vec2 d3 = d2 + d; 
 vec2 d4 = d2 + d2; 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 s0 = sample(src, coord - d4); 
 vec4 s1 = sample(src, coord - d3); 
 vec4 s2 = sample(src, coord - d2); 
 vec4 s3 = sample(src, coord - d ); 
 vec4 s4 = sample(src, coord ); 
 vec4 s5 = sample(src, coord + d ); 
 vec4 s6 = sample(src, coord + d2); 
 vec4 s7 = sample(src, coord + d3); 
 vec4 s8 = sample(src, coord + d4); 
 vec4 index0pix = s4*0.8002434 + (s3+s5)*0.1531180 - (s2+s6)*0.0648618 + (s1+s7)*0.0120488 - (s0+s8)*0.0004266; 
 vec4 index1pix = -s0*0.0002116 + s1*0.0069449 - s2*0.0278111 + s4*0.7394604 + s5*0.3609697 - s6*0.0914600 + s7*0.0121077; 
 vec4 index2pix = (s4+s5)*0.5763899 - (s3+s6)*0.0786414 + (s1+s8)*0.0022716 - s0*0.0000403; 
 vec4 index3pix = s1*0.0121077 - s2*0.0914600 + s3*0.3609697 + s4*0.7394604 - s6*0.0278111 + s7*0.0069449 - s8*0.0002116; 
 vec4 pix = mix(index0pix, index1pix, min(residue, 1.0)); 
 pix = mix(pix, index2pix, max(residue - 1.0, 0.0)); 
 return mix(pix, index3pix, max(residue - 2.0, 0.0)); 
kernel vec4 _ASGv80(sampler src) 
 vec2 dc = destCoord(); 
 float residue = floor(fract(dc.y/4.0)*4.0); 
 vec2 srcPt = vec2(dc.x, floor(floor(dc.y) * 1.25 + 0.499) + 0.5); 
 vec2 d = samplerTransform(src, vec2(0.0, 1.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 d2 = d + d; 
 vec2 d3 = d2 + d; 
 vec2 d4 = d2 + d2; 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 s0 = sample(src, coord - d4); 
 vec4 s1 = sample(src, coord - d3); 
 vec4 s2 = sample(src, coord - d2); 
 vec4 s3 = sample(src, coord - d ); 
 vec4 s4 = sample(src, coord ); 
 vec4 s5 = sample(src, coord + d ); 
 vec4 s6 = sample(src, coord + d2); 
 vec4 s7 = sample(src, coord + d3); 
 vec4 s8 = sample(src, coord + d4); 
 vec4 index0pix = s4*0.8002434 + (s3+s5)*0.1531180 - (s2+s6)*0.0648618 + (s1+s7)*0.0120488 - (s0+s8)*0.0004266; 
 vec4 index1pix = -s0*0.0002116 + s1*0.0069449 - s2*0.0278111 + s4*0.7394604 + s5*0.3609697 - s6*0.0914600 + s7*0.0121077; 
 vec4 index2pix = (s4+s5)*0.5763899 - (s3+s6)*0.0786414 + (s1+s8)*0.0022716 - s0*0.0000403; 
 vec4 index3pix = s1*0.0121077 - s2*0.0914600 + s3*0.3609697 + s4*0.7394604 - s6*0.0278111 + s7*0.0069449 - s8*0.0002116; 
 vec4 pix = mix(index0pix, index1pix, min(residue, 1.0)); 
 pix = mix(pix, index2pix, max(residue - 1.0, 0.0)); 
 return mix(pix, index3pix, max(residue - 2.0, 0.0)); 
kernel vec4 _ASGh60(sampler src) 
 vec2 dc = destCoord(); 
 float residue = floor(fract(dc.x/3.0)*3.0); 
 vec2 srcPt = vec2(floor(floor(dc.x) / 0.60 + 0.499) + 0.5, dc.y); 
 vec2 d = samplerTransform(src, vec2(1.0, 0.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 d2 = d + d; 
 vec2 d3 = d2 + d; 
 vec2 d4 = d2 + d2; 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 s0 = sample(src, coord - d4); 
 vec4 s1 = sample(src, coord - d3); 
 vec4 s2 = sample(src, coord - d2); 
 vec4 s3 = sample(src, coord - d ); 
 vec4 s4 = sample(src, coord ); 
 vec4 s5 = sample(src, coord + d ); 
 vec4 s6 = sample(src, coord + d2); 
 vec4 s7 = sample(src, coord + d3); 
 vec4 s8 = sample(src, coord + d4); 
 vec4 index0pix = s4*0.600173 + (s3+s5)*0.270712 - (s2+s6)*0.0589776 - (s1+s7)*0.0208571 + (s0+s8)*0.00903642; 
 vec4 index1pix = s0*0.0090808 - s1*0.0486483 + s3*0.432291 + s4*0.554595 + s5*0.114843 - s6*0.0685949 + s8*0.00520863; 
 vec4 index2pix = s0*0.00520863 - s2*0.0685949 + s3*0.114843 + s4*0.554595 + s5*0.432291 - s7*0.0486483 + s8*0.0090808; 
 vec4 pix = mix(index0pix, index1pix, min(residue, 1.0)); 
 return mix(pix, index2pix, max(residue - 1.0, 0.0)); 
kernel vec4 _ASGv60(sampler src) 
 vec2 dc = destCoord(); 
 float residue = floor(fract(dc.y/3.0)*3.0); 
 vec2 srcPt = vec2(dc.x, floor(floor(dc.y) / 0.60 + 0.499) + 0.5); 
 vec2 d = samplerTransform(src, vec2(0.0, 1.0)) - samplerTransform(src, vec2(0.0)); 
 vec2 d2 = d + d; 
 vec2 d3 = d2 + d; 
 vec2 d4 = d2 + d2; 
 vec2 coord = samplerTransform(src, srcPt); 
 vec4 s0 = sample(src, coord - d4); 
 vec4 s1 = sample(src, coord - d3); 
 vec4 s2 = sample(src, coord - d2); 
 vec4 s3 = sample(src, coord - d ); 
 vec4 s4 = sample(src, coord ); 
 vec4 s5 = sample(src, coord + d ); 
 vec4 s6 = sample(src, coord + d2); 
 vec4 s7 = sample(src, coord + d3); 
 vec4 s8 = sample(src, coord + d4); 
 vec4 index0pix = s4*0.600173 + (s3+s5)*0.270712 - (s2+s6)*0.0589776 - (s1+s7)*0.0208571 + (s0+s8)*0.00903642; 
 vec4 index1pix = s0*0.0090808 - s1*0.0486483 + s3*0.432291 + s4*0.554595 + s5*0.114843 - s6*0.0685949 + s8*0.00520863; 
 vec4 index2pix = s0*0.00520863 - s2*0.0685949 + s3*0.114843 + s4*0.554595 + s5*0.432291 - s7*0.0486483 + s8*0.0090808; 
 vec4 pix = mix(index0pix, index1pix, min(residue, 1.0)); 
 return mix(pix, index2pix, max(residue - 1.0, 0.0)); 
CILanczosScaleTransform
float _asgh (float x) 
 x = abs(x); 
 if (x >= 3.0) return 0.0; 
 if (x < 1e-6) return 1.0; 
 x *= 3.141592653589793; 
 float sinc = sin(x)/x; 
 float asgw = cos(x/8.0); 
 return sinc * asgw * asgw * asgw * asgw; 
 kernel vec4 _asgDownH(sampler src, vec4 scale, float z) 
 vec2 c = destCoord() * scale.xy; 
 vec2 pm1 = vec2(floor(c.x-0.5)+0.5, c.y); 
 vec2 pm6 = pm1 - scale.zw * 5.0; 
 vec2 pm5 = pm1 - scale.zw * 4.0; 
 vec2 pm4 = pm1 - scale.zw * 3.0; 
 vec2 pm3 = pm1 - scale.zw * 2.0; 
 vec2 pm2 = pm1 - scale.zw * 1.0; 
 vec2 pp1 = pm1 + scale.zw * 1.0; 
 vec2 pp2 = pm1 + scale.zw * 2.0; 
 vec2 pp3 = pm1 + scale.zw * 3.0; 
 vec2 pp4 = pm1 + scale.zw * 4.0; 
 vec2 pp5 = pm1 + scale.zw * 5.0; 
 vec2 pp6 = pm1 + scale.zw * 6.0; 
 vec4 vm6 = sample(src, samplerTransform(src, pm6)); 
 vec4 vm5 = sample(src, samplerTransform(src, pm5)); 
 vec4 vm4 = sample(src, samplerTransform(src, pm4)); 
 vec4 vm3 = sample(src, samplerTransform(src, pm3)); 
 vec4 vm2 = sample(src, samplerTransform(src, pm2)); 
 vec4 vm1 = sample(src, samplerTransform(src, pm1)); 
 vec4 vp1 = sample(src, samplerTransform(src, pp1)); 
 vec4 vp2 = sample(src, samplerTransform(src, pp2)); 
 vec4 vp3 = sample(src, samplerTransform(src, pp3)); 
 vec4 vp4 = sample(src, samplerTransform(src, pp4)); 
 vec4 vp5 = sample(src, samplerTransform(src, pp5)); 
 vec4 vp6 = sample(src, samplerTransform(src, pp6)); 
 float wm6 = _asgh((pm6.x-c.x)/scale.x + z); 
 float wm5 = _asgh((pm5.x-c.x)/scale.x + z); 
 float wm4 = _asgh((pm4.x-c.x)/scale.x + z); 
 float wm3 = _asgh((pm3.x-c.x)/scale.x + z); 
 float wm2 = _asgh((pm2.x-c.x)/scale.x + z); 
 float wm1 = _asgh((pm1.x-c.x)/scale.x + z); 
 float wp1 = _asgh((pp1.x-c.x)/scale.x + z); 
 float wp2 = _asgh((pp2.x-c.x)/scale.x + z); 
 float wp3 = _asgh((pp3.x-c.x)/scale.x + z); 
 float wp4 = _asgh((pp4.x-c.x)/scale.x + z); 
 float wp5 = _asgh((pp5.x-c.x)/scale.x + z); 
 float wp6 = _asgh((pp6.x-c.x)/scale.x + z); 
 float wsum = wm6+wm5+wm4+wm3+wm2+wm1+wp1+wp2+wp3+wp4+wp5+wp6; 
 return (wm6*vm6 + wm5*vm5 + wm4*vm4 + wm3*vm3 + wm2*vm2 + wm1*vm1 + 
 wp6*vp6 + wp5*vp5 + wp4*vp4 + wp3*vp3 + wp2*vp2 + wp1*vp1)/wsum; 
float _asgv (float x) 
 x = abs(x); 
 if (x >= 3.0) return 0.0; 
 if (x < 1e-6) return 1.0; 
 x *= 3.141592653589793; 
 float sinc = sin(x)/x; 
 float asgw = cos(x/8.0); 
 return sinc * asgw * asgw * asgw * asgw; 
 kernel vec4 _asgDownV(sampler src, vec4 scale, float z) 
 vec2 c = destCoord() * scale.xy; 
 vec2 pm1 = vec2(c.x, floor(c.y-0.5)+0.5); 
 vec2 pm6 = pm1 - scale.zw * 5.0; 
 vec2 pm5 = pm1 - scale.zw * 4.0; 
 vec2 pm4 = pm1 - scale.zw * 3.0; 
 vec2 pm3 = pm1 - scale.zw * 2.0; 
 vec2 pm2 = pm1 - scale.zw * 1.0; 
 vec2 pp1 = pm1 + scale.zw * 1.0; 
 vec2 pp2 = pm1 + scale.zw * 2.0; 
 vec2 pp3 = pm1 + scale.zw * 3.0; 
 vec2 pp4 = pm1 + scale.zw * 4.0; 
 vec2 pp5 = pm1 + scale.zw * 5.0; 
 vec2 pp6 = pm1 + scale.zw * 6.0; 
 vec4 vm6 = sample(src, samplerTransform(src, pm6)); 
 vec4 vm5 = sample(src, samplerTransform(src, pm5)); 
 vec4 vm4 = sample(src, samplerTransform(src, pm4)); 
 vec4 vm3 = sample(src, samplerTransform(src, pm3)); 
 vec4 vm2 = sample(src, samplerTransform(src, pm2)); 
 vec4 vm1 = sample(src, samplerTransform(src, pm1)); 
 vec4 vp1 = sample(src, samplerTransform(src, pp1)); 
 vec4 vp2 = sample(src, samplerTransform(src, pp2)); 
 vec4 vp3 = sample(src, samplerTransform(src, pp3)); 
 vec4 vp4 = sample(src, samplerTransform(src, pp4)); 
 vec4 vp5 = sample(src, samplerTransform(src, pp5)); 
 vec4 vp6 = sample(src, samplerTransform(src, pp6)); 
 float wm6 = _asgv((pm6.y-c.y)/scale.y + z); 
 float wm5 = _asgv((pm5.y-c.y)/scale.y + z); 
 float wm4 = _asgv((pm4.y-c.y)/scale.y + z); 
 float wm3 = _asgv((pm3.y-c.y)/scale.y + z); 
 float wm2 = _asgv((pm2.y-c.y)/scale.y + z); 
 float wm1 = _asgv((pm1.y-c.y)/scale.y + z); 
 float wp1 = _asgv((pp1.y-c.y)/scale.y + z); 
 float wp2 = _asgv((pp2.y-c.y)/scale.y + z); 
 float wp3 = _asgv((pp3.y-c.y)/scale.y + z); 
 float wp4 = _asgv((pp4.y-c.y)/scale.y + z); 
 float wp5 = _asgv((pp5.y-c.y)/scale.y + z); 
 float wp6 = _asgv((pp6.y-c.y)/scale.y + z); 
 float wsum = wm6+wm5+wm4+wm3+wm2+wm1+wp1+wp2+wp3+wp4+wp5+wp6; 
 return (wm6*vm6 + wm5*vm5 + wm4*vm4 + wm3*vm3 + wm2*vm2 + wm1*vm1 + 
 wp6*vp6 + wp5*vp5 + wp4*vp4 + wp3*vp3 + wp2*vp2 + wp1*vp1)/wsum; 
render_graph_core
processor %s
:%llX
 outputFormat=%s
 noPartialOutput
inputB
inputC
T@"NSNumber",&,N,VinputAspectRatio
T@"NSNumber",&,N,VinputB
T@"NSNumber",&,N,VinputC
kernel vec4 _cubicDownsample2 (sampler src, vec4 parms) 
 vec2 p = destCoord() * 2.0; 
 vec4 r = vec4(0.0); 
 float w1 = parms.x; 
 float w2 = parms.y; 
 vec4 off = vec4(-parms.wz,parms.zw); 
 r += sample(src, samplerTransform(src, p + off.xx)) * w2 * w2; 
 r += sample(src, samplerTransform(src, p + off.yx)) * w1 * w2; 
 r += sample(src, samplerTransform(src, p + off.zx)) * w1 * w2; 
 r += sample(src, samplerTransform(src, p + off.wx)) * w2 * w2; 
 r += sample(src, samplerTransform(src, p + off.xy)) * w2 * w1; 
 r += sample(src, samplerTransform(src, p + off.yy)) * w1 * w1; 
 r += sample(src, samplerTransform(src, p + off.zy)) * w1 * w1; 
 r += sample(src, samplerTransform(src, p + off.wy)) * w2 * w1; 
 r += sample(src, samplerTransform(src, p + off.xz)) * w2 * w1; 
 r += sample(src, samplerTransform(src, p + off.yz)) * w1 * w1; 
 r += sample(src, samplerTransform(src, p + off.zz)) * w1 * w1; 
 r += sample(src, samplerTransform(src, p + off.wz)) * w2 * w1; 
 r += sample(src, samplerTransform(src, p + off.xw)) * w2 * w2; 
 r += sample(src, samplerTransform(src, p + off.yw)) * w1 * w2; 
 r += sample(src, samplerTransform(src, p + off.zw)) * w1 * w2; 
 r += sample(src, samplerTransform(src, p + off.ww)) * w2 * w2; 
 return r; 
kernel vec4 _cubicDownsample2h (sampler src, vec4 parms) 
 vec2 dir = vec2(1.0,0.0); 
 vec2 p = destCoord() * vec2(2.0,1.0); 
 vec4 r = vec4(0.0); 
 vec4 off = vec4(-parms.wz,parms.zw); 
 r += sample(src, samplerTransform(src, p + dir * off.xx)) * parms.y; 
 r += sample(src, samplerTransform(src, p + dir * off.yy)) * parms.x; 
 r += sample(src, samplerTransform(src, p + dir * off.zz)) * parms.x; 
 r += sample(src, samplerTransform(src, p + dir * off.ww)) * parms.y; 
 return r; 
kernel vec4 _cubicDownsample2v (sampler src, vec4 parms) 
 vec2 dir = vec2(0.0,1.0); 
 vec2 p = destCoord() * vec2(1.0,2.0); 
 vec4 r = vec4(0.0); 
 vec4 off = vec4(-parms.wz,parms.zw); 
 r += sample(src, samplerTransform(src, p + dir * off.xx)) * parms.y; 
 r += sample(src, samplerTransform(src, p + dir * off.yy)) * parms.x; 
 r += sample(src, samplerTransform(src, p + dir * off.zz)) * parms.x; 
 r += sample(src, samplerTransform(src, p + dir * off.ww)) * parms.y; 
 return r; 
kernel vec4 _cubicDownsampleH (sampler src, vec4 scale, vec4 coefsLT1, vec4 coefsLT2) 
 vec2 dc = destCoord(); 
 vec2 dcMappedToSrc = scale.xy * dc; 
 vec2 dcMinus2MappedToSrc = scale.xy * (dc - 2.0); 
 vec2 dcPlus2MappedToSrc = scale.xy * (dc + 2.0); 
 float firstSrc = floor(dcMinus2MappedToSrc.x+0.5) + 0.5; 
 float lastSrc = floor(dcPlus2MappedToSrc.x-0.5) + 0.5; 
 vec4 r = vec4(0.0); 
 float sum = 0.0; 
 vec2 p = dcMappedToSrc; 
 float invScale = scale.z; 
 float delta = (firstSrc - dcMappedToSrc.x) * invScale; 
 for (p.x = firstSrc; p.x <= lastSrc; p.x += 1.0) 
 float x = abs(delta); 
 vec4 xvec = vec4(x*x*x, x*x, x, 1.0); 
 float weight = (x<1.0) ? dot(xvec,coefsLT1) : dot(xvec,coefsLT2); 
 r += sample(src, samplerTransform(src, p)) * weight; 
 sum += weight; 
 delta += invScale; 
 return r / sum; 
kernel vec4 _cubicDownsampleV (sampler src, vec4 scale, vec4 coefsLT1, vec4 coefsLT2) 
 vec2 dc = destCoord(); 
 vec2 dcMappedToSrc = scale.xy * dc; 
 vec2 dcMinus2MappedToSrc = scale.xy * (dc - 2.0); 
 vec2 dcPlus2MappedToSrc = scale.xy * (dc + 2.0); 
 float firstSrc = floor(dcMinus2MappedToSrc.y+0.5) + 0.5; 
 float lastSrc = floor(dcPlus2MappedToSrc.y-0.5) + 0.5; 
 vec4 r = vec4(0.0); 
 float sum = 0.0; 
 vec2 p = dcMappedToSrc; 
 float invScale = scale.w; 
 float delta = (firstSrc - dcMappedToSrc.y) * invScale; 
 for (p.y = firstSrc; p.y <= lastSrc; p.y += 1.0) 
 float x = abs(delta); 
 vec4 xvec = vec4(x*x*x, x*x, x, 1.0); 
 float weight = (x<1.0) ? dot(xvec,coefsLT1) : dot(xvec,coefsLT2); 
 r += sample(src, samplerTransform(src, p)) * weight; 
 sum += weight; 
 delta += invScale; 
 return r / sum; 
kernel vec4 _cubicUpsample10 (sampler src, vec4 scale) 
 vec2 d = scale.xy * destCoord() - 0.5; 
 vec2 c = floor(d); 
 vec2 x = (c - d + 1.0); 
 vec2 X = (d - c); 
 vec2 w1 = (-1.0/3.0)*x*x*x + 0.5*x*x + 0.5*x + 1.0/6.0; 
 vec2 w2 = 1.0 - w1; 
 vec2 o1 = (-0.5*x*x*x + 0.5*x*x + 0.5*x + 1.0/6.0) / w1 + c - 0.5; 
 vec2 o2 = (X*X*X/6.0) / w2 + c + 1.5; 
 vec4 r; 
 r = w1.x * w1.y * sample(src, samplerTransform(src, vec2(o1.x,o1.y))); 
 r += w2.x * w1.y * sample(src, samplerTransform(src, vec2(o2.x,o1.y))); 
 r += w1.x * w2.y * sample(src, samplerTransform(src, vec2(o1.x,o2.y))); 
 r += w2.x * w2.y * sample(src, samplerTransform(src, vec2(o2.x,o2.y))); 
 return r; 
vec2 _cubic_coefs_ (vec2 x, vec4 c) 
 x = abs(x); 
 return c.x * x*x*x + c.y * x*x + c.z * x + c.w; 
 kernel vec4 _cubicUpsampleX0 (sampler src, vec4 scale, vec4 coefsLT1, vec4 coefsLT2) 
 vec2 dcMappedToSrc = scale.xy * destCoord(); 
 vec2 srcCenterBefore = floor(dcMappedToSrc-0.5) + 0.5; 
 vec2 delta = srcCenterBefore - dcMappedToSrc; 
 vec2 weight0 = _cubic_coefs_(delta - 1.0, coefsLT2); 
 vec2 weight1 = _cubic_coefs_(delta , coefsLT1); 
 vec2 weight3 = _cubic_coefs_(delta + 2.0, coefsLT2); 
 vec2 w1 = weight0 + weight1; 
 vec2 w2 = vec2(1.0) - w1; 
 vec2 o1 = compare(w1 - 0.0001, vec2(0.0), weight1 / w1) + (srcCenterBefore - 1.0); 
 vec2 o2 = compare(w2 - 0.0001, vec2(0.0), weight3 / w2) + (srcCenterBefore + 1.0); 
 vec4 r; 
 r = w1.x * w1.y * sample(src, samplerTransform(src, vec2(o1.x,o1.y))); 
 r += w2.x * w1.y * sample(src, samplerTransform(src, vec2(o2.x,o1.y))); 
 r += w1.x * w2.y * sample(src, samplerTransform(src, vec2(o1.x,o2.y))); 
 r += w2.x * w2.y * sample(src, samplerTransform(src, vec2(o2.x,o2.y))); 
 return r; 
vec2 _cubic_coefs (vec2 x, vec4 c) 
 x = abs(x); 
 return c.x * x*x*x + c.y * x*x + c.z * x + c.w; 
 kernel vec4 _cubicUpsample (sampler src, vec4 scale, vec4 coefsLT1, vec4 coefsLT2) 
 vec2 dcMappedToSrc = scale.xy * destCoord(); 
 vec2 srcCenterBefore = floor(dcMappedToSrc-0.5) + 0.5; 
 vec2 delta = srcCenterBefore - dcMappedToSrc; 
 vec4 r = vec4(0.0); 
 vec2 p; 
 vec2 w0 = _cubic_coefs(delta - 1.0, coefsLT2); 
 vec2 w1 = _cubic_coefs(delta , coefsLT1); 
 vec2 w2 = _cubic_coefs(delta + 1.0, coefsLT1); 
 vec2 w3 = 1.0 - (w0 + w1 + w2); 
 p.y = -1.0; 
 p.x = -1.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w0.x * w0.y; 
 p.x = 0.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w1.x * w0.y; 
 p.x = 1.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w2.x * w0.y; 
 p.x = 2.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w3.x * w0.y; 
 p.y = 0.0; 
 p.x = -1.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w0.x * w1.y; 
 p.x = 0.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w1.x * w1.y; 
 p.x = 1.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w2.x * w1.y; 
 p.x = 2.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w3.x * w1.y; 
 p.y = 1.0; 
 p.x = -1.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w0.x * w2.y; 
 p.x = 0.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w1.x * w2.y; 
 p.x = 1.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w2.x * w2.y; 
 p.x = 2.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w3.x * w2.y; 
 p.y = 2.0; 
 p.x = -1.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w0.x * w3.y; 
 p.x = 0.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w1.x * w3.y; 
 p.x = 1.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w2.x * w3.y; 
 p.x = 2.0; r += sample(src, samplerTransform(src, srcCenterBefore + p)) * w3.x * w3.y; 
 return r; 
// DAG Functions
%zu: 
compile
Cannot use sRGB texture binding with format %s for sampler %d in kernel '%s'.
_ci_half_to_float
_ci_float_to_half
build_dag
v36@?0^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}4^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}8i12i16^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}20Q24i32
_ci_read_pixel_420
_ci_read_pixel
_ci_read_pixel_420_h
_ci_read_pixel_h
_ci_srgb_to_linear
_ci_srgb_to_linear_h
B24@?0^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}4^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}8i12i16i20
_ci_early_out
_ci_init_destcoord
_ci_linear_to_srgb
_ci_linear_to_srgb_h
_ci_write_pixel_h
_ci_write_pixel
ci_stdlib
Failed to load 'ci_stdlib' Metal library.
ci_filters
Failed to load 'ci_filters' Metal library.
ci_stdlib_h
Failed to load 'ci_stdlib_h' Metal library.
{ %s
bool
    arg%zu= 
{%s, index=%zu, offset=%zu}
Texture2DSPI
Texture2DWriteSPI
SamplerSPI
BufferSPI
ThreadPositionInGridSPI
OutputSPI
<Unknown>
 roi=
com.apple.coreimage
performance
filter
CI::TileTaskQueue
wait
GLTextureManager_block_invoke
%llX(%04x,%04x,%04x)
Cannot handle a (%lu x %lu) sized texture with the given GLES context!
CIEAGLContextTexImageIOSurface failed for %s!
GLTextureManager::attach_IOSurface unsupported format %s!
Program exceeds GLES%d uniform size limit. (%d > %zu)
position
texcoord
opengles2
opengles3
opengles
GL_APPLE_client_storage
GL_APPLE_texture_ycbcr_basic_formats
GL_APPLE_texture_ycbcr_extended_formats
GL_EXT_color_buffer_half_float
GL_EXT_shader_texture_lod
GL_OES_texture_half_float
GL_OES_texture_float
GL_APPLE_texture_xr
finish_render
after_render
quad
GLContext::set_surface_destination unsupported format %s!
Destination buffer size too large (%lu x %lu); cannot be larger than %d x %d.
attribute highp vec4 position;
attribute highp vec4 texcoord;
varying highp vec2 p0;
void main()
  gl_Position = position;
  p0 = texcoord.xy;
varying highp vec2 p0;
uniform sampler2D s0;
void main()
  gl_FragColor = texture2D(s0, p0);
Using low GPU priority for background rendering.
readback_bitmap
bind_arguments
Unhandled type: %d
compile_shader
// Copyright 2015 Apple Inc.
attribute highp vec4 position;
attribute highp vec4 texcoord;
varying highp vec2 p0;
uniform highp mat3 vertexTransform;
void main()
  gl_Position = position;
  p0 = (vec3(texcoord.xy,1.0) * vertexTransform).xy;
Intel
CI_SUBDIVIDE_QUADS
CI::RenderCompletionQueue
render_node
create_intermediate
CGImageRef %d
B8@?0i4
Core Image cannot allocate IOSurface with unspecified format.
Core Image cannot allocate surface of size %zu x %zu
%s/%d_intermediate_%d_%d_%d_%d_%d.png
Dumped intermediate to: %s
CI_ASSEMBLE_INPUT_TILES
CI::ObjectCacheQ
kernel vec4 _tiltShift(sampler image,sampler blurM,sampler blurL,vec2 p0,vec2 p1,vec2 sizes) 
 vec2 pt = samplerCoord(image); 
 vec4 col0 = sample(image, pt); 
 vec4 colMed = sample(blurM, samplerCoord(blurM)); 
 vec4 colLarge = sample(blurL, samplerCoord(blurL)); 
 float denom = (p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y); 
 float s = ((p0.y-pt.y)*(p1.x-p0.x)-(p0.x-pt.x)*(p1.y-p0.y) ) / denom; 
 float dist = abs(s)*sqrt(denom) / sizes.y; 
 dist *= 2.0; 
 float w0 = smoothstep(0.0, 1.0, 1.0 - 2.0*dist); 
 float wL = smoothstep(0.0, 1.0, -1.0 + 2.0*dist); 
 float wM = 1.0 - (w0 + wL); 
 return w0*col0 + wM*colMed + wL*colLarge; 
kernel vec4 _distanceColored(sampler image,vec2 p0,vec2 p1) 
 vec2 pt = samplerCoord(image); 
 float denom = (p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y); 
 float s = ((p0.y-pt.y)*(p1.x-p0.x)-(p0.x-pt.x)*(p1.y-p0.y) ) / denom; 
 float dist = abs(s)*sqrt(denom) / samplerSize(image).y; 
 dist *= 2.0; 
 float val = dist; 
 return vec4(val,val,val,1.0); 
kernel vec4 _alphaNormalize(__sample image) 
 vec4 col = image; 
 col.rgb /= col.a; 
 col.a = 1.0; 
 return col; 
CIColorControls
CIUnsharpMask
CIDiscBlur
10.6
inputUnsharpMaskRadius
inputUnsharpMaskIntensity
image
image_chroma
sampler2D
float
float2
float3
float4
float2x2
float3x3
float4x4
half
half2
half3
half4
half2x2
half3x3
half4x4
color
dest_coord
dest_gid
dest_extent
dest_transform
dest_image
dest_image_plane
sampler_transform
sampler_transform_and_extent
sampler_transform_row0
sampler_transform_row1
vertex_transform
vertex_transform_row0
vertex_transform_row1
set_roi_selector queue
fill 
clear
[CIAffineTransform inputTransfom] is not a valid object.
AffineA
AffineB
AffineC
AffineD
AffineX
AffineY
T@"NSValue",&,N,VinputTransform
CropX
CropY
CropW
CropH
T@"CIVector",&,N,VinputRectangle
CI_PRINT_TIME new bitmap (%ldx%ld) = %.3f seconds
affine 
affine
-[CIContext(ImageRepresentation) TIFFRepresentationOfImage:format:colorSpace:options:]
-[CIContext(ImageRepresentation) PNGRepresentationOfImage:format:colorSpace:options:]
kCIImageRepresentationAVDepthData
kCIImageRepresentationDepthImage
kCIImageRepresentationDisparityImage
kCIImageRepresentationAVPortraitEffectsMatte
kCIImageRepresentationPortraitEffectsMatteImage
-[CIContext(ImageRepresentation) JPEGRepresentationOfImage:colorSpace:options:]
public.jpeg
-[CIContext(ImageRepresentation) HEIFRepresentationOfImage:format:colorSpace:options:]
public.heic
failed to create data representation.
failed to write TIFF data to file.
failed to write PNG data to file.
failed to write JPEG data to file.
failed to write HEIC data to file.
PortraitEffectsMatteVersion
portraitEffectsMatte:PortraitEffectsMatteVersion
kCGImageAuxiliaryDataInfoData
kCGImageAuxiliaryDataInfoDataDescription
BytesPerRow
PixelFormat
kCGImageAuxiliaryDataInfoMetadata
image extent must be finite and non-empty.
canCreateDataRepresentation
unsupported colorspace.
CGNode::surface
CGImageRef
CGImageRef %p
Could not create IOSurface in ioSurfaceFromCGImage failed
kCGImageBlockTileRequest
Failed to access image block data.
LA16
RG16
RGB8
RGB16
RGBh
RGBf
BGRA8
RGBA8
ARGB8
BGRX8
RGBX8
XRGB8
XBGR8
YCC420f
YCC420v
YCC444f601
YCC444f709
YCC444v601
YCC444v709
YCC420f601
YCC420f709
YCC420v601
YCC420v709
RGBA16
ARGB16
RGBA16-Unorm
RGBAf
ARGBf
A2BGR10
A2RGB10
RGB10A2-WideGamut
RGBA14
RGBA14v0
CbYCrY8
CbYCrY8f
YCbYCr8
YCbYCr8f
CbYCrY_RGB8
YCbYCr_RGB8
unknown-format
need a %s swizzler so that %s can be read as %s
kSwizzleBGRAtoRRGG1
kPixelFormatRG16
kPixelFormatBGRA8
kSwizzleBGRAtoLLAA
kPixelFormatLA16
kSwizzleGBAR
kPixelFormatARGB8
kPixelFormatRGBA8
kSwizzleAGBR
kPixelFormatABGR8
kSwizzleGBA1
kPixelFormatXRGB8
kSwizzleAGB1
kPixelFormatXBGR8
kSwizzleRGB14
kPixelFormatRGBA14
kPixelFormatRGBA16
kSwizzleRGB14v0
kPixelFormatRGBA14v0
need a swizzler so that %s can be read.
kSwizzleToRGB14
kSwizzleToRGB14v0
need a swizzler so that %s can be written.
swizzle_identity
swizzle_bgra
swizzle_abgr
swizzle_argb
swizzle_gbra
swizzle_grab
swizzle_gbar
swizzle_aaaa
swizzle_rrrr
swizzle_rrrg
swizzle_rgb1
swizzle_bgr1
swizzle_arg1
swizzle_gra1
swizzle_1bgr
swizzle_1rgb
swizzle_000r
swizzle_rrr1
swizzle_r001
swizzle_a001
swizzle_rg01
swizzle_ra01
swizzle_aaa1
swizzle_rg_to_rr1
swizzle_rg_to_ll1
swizzle_rg_to_a
swizzle_rg_to_i
swizzle_la_to_rr1
swizzle_la_to_ll1
swizzle_la_to_a
swizzle_la_to_i
swizzle_rgba_to_rrgg1
swizzle_rgba_to_llaa
swizzle_rg_to_cbycry
swizzle_rg_to_ycbycr
swizzle_to_r16_as_rg8
swizzle_to_l16_as_rg8
swizzle_to_a16_as_rg8
combine_r_as_rgba
combine_l_as_rgba
combine_a_as_rgba
swizzle_to_rg16_as_rgba8
swizzle_to_rg16_as_bgra8
swizzle_to_la16_as_rgba8
swizzle_to_la16_as_bgra8
swizzle_to_YCbYCr_as_rg8
swizzle_to_CbYCrY_as_rg8
swizzle_to_rgb_as_r
swizzle_to_a2bgr10_as_rgba8
swizzle_to_a2rgb10_as_rgba8
swizzle_to_rgb10_wide_as_rgba8
combine_420
swizzle_to_444_biplanar
swizzle_ycc_to_rgb
swizzle_to_laaa
swizzle_rgba8_to_a2rgb10
swizzle_rgba8_to_a2bgr10
swizzle_rgba8_to_rgb10_wide
swizzle_rgb10_wide
swizzle_bgr10_wide
swizzle_to_rgb10_wide
swizzle_to_bgr10_wide
swizzle_rgba16_normalize
swizzle_to_rg_as_rgba
swizzle_to_r16_as_rgba
swizzle_to_a16_as_rgba
swizzle_to_l16_as_rgba
swizzle_to_la_as_rgba
unknown-swizzle
kernel vec4 _sepia (__sample s, float amount) 
 vec4 color = vec4(1.0, 0.99, 0.92, 1.0); 
 vec4 c0 = vec4(0.895663e-3, -0.1104567e-2, -0.60827e-3, 0.32774281e-1); 
 vec4 c1 = vec4(3.1166719, 0.79263718, 0.32196859e-1, 1.4118470); 
 vec4 c2 = vec4(-50.933413, 0.46548312, 1.0275550, -.90690876); 
 vec4 c3 = vec4(708.79386, -0.39031064, -0.58540133e-1, 0.66210230); 
 vec4 c4 = vec4(-3605.9836, 0.13231560, 0.0, -0.19916155); 
 float l = dot(s.rgb, vec3(.2125, .7154, .0721)); 
 float la = l / max(0.0001, s.a); 
 vec4 t = c0*s.a + (c1 + (c2 + (c3 + c4*la)*la)*la)*l; 
 t.r = (l < 0.085*s.a) ? t.r : t.a; 
 vec3 r = (l*l-l < 0.0) ? t.rgb : vec3(l,l,l); 
 return mix(s,vec4(r, s.a)*color, amount); 
T@"NSNumber",&,N,VinputIntensity
kernel vec4 _lenticularHalo(sampler noise, vec2 center, vec2 sourcecenter, float noiseRadius, float haloThicknessRecip, float a, float b, vec3 rgbdist, __color color) 
 vec2 v = destCoord() - center; 
 vec3 rgbfunc = clamp((length(v) - rgbdist) * haloThicknessRecip, 0.0, 1.0); 
 rgbfunc = 2.0 * min(rgbfunc, 1.0 - rgbfunc); 
 rgbfunc = (3.0 - 2.0 * rgbfunc) * rgbfunc * rgbfunc; 
 vec2 noiseloc = normalize(v) * noiseRadius + sourcecenter; 
 vec4 npix = sample(noise, samplerTransform(noise, noiseloc)); 
 vec3 color3 = (npix.r * a + b) * rgbfunc * color.rgb; 
 return vec4(color3, max(max(color3.r, color3.g), color3.b)); 
inputHaloRadius
inputHaloWidth
inputHaloOverlap
inputStriationStrength
inputStriationContrast
CILenticularHaloGenerator only has one input
10.7
true
Can't wrap anymore classes without some additional macro magic.
%@ will *not* be wrapped.
wrappedOutputImage%d
No input on filter %@ named %@
inputOriginalFilter
inputOutputImage
AVDepthData
AVCameraCalibrationData
depthDataFromDictionaryRepresentation:error:
AVPortraitEffectsMatte
portraitEffectsMatteFromDictionaryRepresentation:error:
/System/Library/Frameworks/AVFoundation.framework/AVFoundation
abortable
blend_kernel
kernel vec4 _clearer() { return vec4(0.0); }
CIImageAccumulator
-[CIImageAccumulator init]
-[CIImageAccumulator initWithExtent:format:options:]
<CIImageAccumulator: %p extent [%g %g %g %g] format %s>
T{CGRect={CGPoint=ff}{CGSize=ff}},R
format
[%g]
[%g %g]
[%g %g %g]
[%g %g %g %g
CICount
CI_%zu
count
TL,R
Tf,R
CGPointValue
T{CGPoint=ff},R
CGRectValue
CGAffineTransformValue
T{CGAffineTransform=ffffff},R
stringRepresentation
_values
T^f,R
CIColorMatrix
inputRVector
inputGVector
inputBVector
inputAVector
inputBiasVector
T@"NSNumber",&,N,VinputEV
%s:%d: Assertion failed: %s
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/internal/render.cpp
graph != NULL
^{TileTask=^^?{atomic<unsigned int>=AI}^{dispatch_group_s}L^{ProgramNode}{CGRect={CGPoint=ff}{CGSize=ff}}{unordered_map<const CI::GraphObject *, CI::ProgramNode::Stats, std::__1::hash<const CI::GraphObject *>, std::__1::equal_to<const CI::GraphObject *>, std::__1::allocator<std::__1::pair<const CI::GraphObject *const, CI::ProgramNode::Stats> > >={__hash_table<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, std::__1::__unordered_map_hasher<const CI::GraphObject *, std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, std::__1::hash<const CI::GraphObject *>, true>, std::__1::__unordered_map_equal<const CI::GraphObject *, std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, std::__1::equal_to<const CI::GraphObject *>, true>, std::__1::allocator<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats> > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *> *> >=L}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<const CI::GraphObject *, std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, std::__1::hash<const CI::GraphObject *>, true> >=L}{__compressed_pair<float, std::__1::__unordered_map_equal<const CI::GraphObject *, std::__1::__hash_value_type<const CI::GraphObject *, CI::ProgramNode::Stats>, std::__1::equal_to<const CI::GraphObject *>, true> >=f}}}{unordered_map<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> >, std::__1::hash<CI::ProgramNode *>, std::__1::equal_to<CI::ProgramNode *>, std::__1::allocator<std::__1::pair<CI::ProgramNode *const, std::__1::vector<CGRect, std::__1::allocator<CGRect> > > > >={__hash_table<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::__unordered_map_hasher<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::hash<CI::ProgramNode *>, true>, std::__1::__unordered_map_equal<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::equal_to<CI::ProgramNode *>, true>, std::__1::allocator<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > > > >={unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *> > >={__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *> > >=^^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *>}{__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *> >={__compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *> *> >=L}}}}{__compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> > >={__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *>=^{__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, void *> *>}}}{__compressed_pair<unsigned long, std::__1::__unordered_map_hasher<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::hash<CI::ProgramNode *>, true> >=L}{__compressed_pair<float, std::__1::__unordered_map_equal<CI::ProgramNode *, std::__1::__hash_value_type<CI::ProgramNode *, std::__1::vector<CGRect, std::__1::allocator<CGRect> > >, std::__1::equal_to<CI::ProgramNode *>, true> >=f}}}^{dispatch_queue_s}}24@?0^{ProgramNode=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB^^?^{Node}^{SerialStringArray}^{SerialObjectPtrArray}^{MainProgram}^{SerialObjectPtrArray}B{IntermediateDescriptor=iCi}^{dispatch_queue_s}^{dispatch_group_s}}4{CGRect={CGPoint=ff}{CGSize=ff}}8
CI_PRINT_TIME %s (%s%s context %d%s%s frame %lu) (%llux%llu) = %.3f seconds%s
 (aborted)
render_to_display
render_to_texture
get_bitmap
create_cgimage
Could not access surface.
CI_PRINT_TIME %s (%s%s context %d%s%s frame %lu) (%llux%llu) = %.3f seconds
prepare_initial_graph
v24@?0^{GraphObject=^^?{atomic<unsigned int>=AI}}4^{GraphObject=^^?{atomic<unsigned int>=AI}}8i12i16i20
[%s] 
initial graph %s (%s%s context %d%s%s frame %lu) 
format=%s roi=
optimized graph %s (%s%s context %d%s%s frame %lu) 
No need to render
Cannot render to infinite output region.
Failed to render %llu pixels 
Failed to render %llu of %llu pixels 
because a CIKernel's ROI function did not allow tiling.
render_tile
Failed to render part of the image because %s
highp 
lowp 
make_program_graph_if_renderable
destination %dx%d too big
input %d too big
intermediate %d too big
memory requirement of %d too big
main
program graph %s (%s%s context %d%s%s frame %lu tile %lu) 
 ms=%d
Cannot create a CGImageProvider for %s
CGImageProviderCallbackQueue
kCGImageProviderPrefersBandedDecoding
kCGImageProviderPreferedBandHeight
failed mprotect
fill
kernel vec4 _displaceFromImage (sampler src, sampler image, float k)
  vec2 dc = destCoord(); 
  float E = sample(image, samplerTransform(image,dc+vec2(1.0,0.0))).r; 
  float S = sample(image, samplerTransform(image,dc+vec2(0.0,-1.0))).r; 
  float C = sample(image, samplerTransform(image,dc)).r; 
  return sample(src, samplerTransform(src, dc + k * vec2(E-C, S-C)));
T@"NSNumber",&,N,VinputSaturation
T@"NSNumber",&,N,VinputBrightness
T@"NSNumber",&,N,VinputContrast
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/internal/vector.cpp
values != NULL
<CI::Vector %p>[]
<CI::Vector %p>[%g]
<CI::Vector %p>[%g %g]
<CI::Vector %p>[%g %g %g]
<CI::Vector %p>[%g %g %g %g]
<CI::Vector %p>[%d values]
%c%g
kernel vec4 _reduceCrop (sampler image)
  vec4 p = sample(image, samplerTransform(image, vec2(0.5, 0.5)));
  vec2 d = abs(destCoord() - 0.5);
  return max(d.x, d.y) < 0.5  ?  p  :  vec4(0.0);
CIColumnAverage
CIAreaMaximum
CIAreaMinimum
kernel vec4 _areaMax4(sampler image, vec2 bound)
  vec2  d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x)  ?  max(p0, p1)  :  p0;
  p2 = (d.x+0.5 < bound.x)  ?  max(p2, p3)  :  p2;
  p0 = (d.y+0.5 < bound.y)  ?  max(p0, p2)  :  p0;
  return p0;
kernel vec4 _horizMax4(sampler image, float bound)
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  p0 = (d.x-0.5 < bound)  ?  max(p0, p1)  :  p0;
  p0 = (d.x+0.5 < bound)  ?  max(p0, p2)  :  p0;
  p0 = (d.x+1.5 < bound)  ?  max(p0, p3)  :  p0;
  return p0;
kernel vec4 _vertMax4(sampler image, float bound)
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  p0 = (d.y-0.5 < bound)  ?  max(p0, p1)  :  p0;
  p0 = (d.y+0.5 < bound)  ?  max(p0, p2)  :  p0;
  p0 = (d.y+1.5 < bound)  ?  max(p0, p3)  :  p0;
  return p0;
kernel vec4 _areaMin4(sampler image, vec2 bound)
  vec2 d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x)  ?  min(p0, p1)  :  p0;
  p2 = (d.x+0.5 < bound.x)  ?  min(p2, p3)  :  p2;
  p0 = (d.y+0.5 < bound.y)  ?  min(p0, p2)  :  p0;
  return p0;
kernel vec4 _horizMin4(sampler image, float bound)
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  p0 = (d.x-0.5 < bound)  ?  min(p0, p1)  :  p0;
  p0 = (d.x+0.5 < bound)  ?  min(p0, p2)  :  p0;
  p0 = (d.x+1.5 < bound)  ?  min(p0, p3)  :  p0;
  return p0;
kernel vec4 _vertMin4(sampler image, float bound)
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  p0 = (d.y-0.5 < bound)  ?  min(p0, p1)  :  p0;
  p0 = (d.y+0.5 < bound)  ?  min(p0, p2)  :  p0;
  p0 = (d.y+1.5 < bound)  ?  min(p0, p3)  :  p0;
  return p0;
kernel vec4 _areaMaxAlphaS4(sampler image, vec2 bound)
  vec2 d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x)  ?  (p0.a>=p1.a ? p0 : p1)  :  p0;
  p2 = (d.x+0.5 < bound.x)  ?  (p2.a>=p3.a ? p2 : p3)  :  p2;
  p0 = (d.y+0.5 < bound.y)  ?  (p0.a>=p2.a ? p0 : p2)  :  p0;
  return p0;
kernel vec4 _areaMaxAlphaH4(sampler image, float bound)
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  p0 = (d.x-0.5 < bound)  ?  (p0.a>=p1.a ? p0 : p1)  :  p0;
  p0 = (d.x+0.5 < bound)  ?  (p0.a>=p2.a ? p0 : p2)  :  p0;
  p0 = (d.x+1.5 < bound)  ?  (p0.a>=p3.a ? p0 : p3)  :  p0;
  return p0;
kernel vec4 _areaMaxAlphaV4(sampler image, float bound)
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  p0 = (d.y-0.5 < bound)  ?  (p0.a>=p1.a ? p0 : p1)  :  p0;
  p0 = (d.y+0.5 < bound)  ?  (p0.a>=p2.a ? p0 : p2)  :  p0;
  p0 = (d.y+1.5 < bound)  ?  (p0.a>=p3.a ? p0 : p3)  :  p0;
  return p0;
kernel vec4 _areaMinAlphaS4(sampler image, vec2 bound)
  vec2 d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  p0 = (d.x+0.5 < bound.x)  ?  (p0.a<=p1.a ? p0 : p1)  :  p0;
  p2 = (d.x+0.5 < bound.x)  ?  (p2.a<=p3.a ? p2 : p3)  :  p2;
  p0 = (d.y+0.5 < bound.y)  ?  (p0.a<=p2.a ? p0 : p2)  :  p0;
  return p0;
kernel vec4 _areaMinAlphaH4(sampler image, float bound)
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  p0 = (d.x-0.5 < bound)  ?  (p0.a<=p1.a ? p0 : p1)  :  p0;
  p0 = (d.x+0.5 < bound)  ?  (p0.a<=p2.a ? p0 : p2)  :  p0;
  p0 = (d.x+1.5 < bound)  ?  (p0.a<=p3.a ? p0 : p3)  :  p0;
  return p0;
kernel vec4 _areaMinAlphaV4(sampler image, float bound)
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  p0 = (d.y-0.5 < bound)  ?  (p0.a<=p1.a ? p0 : p1)  :  p0;
  p0 = (d.y+0.5 < bound)  ?  (p0.a<=p2.a ? p0 : p2)  :  p0;
  p0 = (d.y+1.5 < bound)  ?  (p0.a<=p3.a ? p0 : p3)  :  p0;
  return p0;
kernel vec4 _reduceCropMinMaxRed (sampler image) __attribute__((outputFormat(kCIFormatRGh)))
  vec4 p = sample(image, samplerTransform(image, vec2(0.5, 0.5)));
  vec2 d = abs(destCoord() - 0.5);
  return max(d.x, d.y) < 0.5  ?  p  :  vec4(0.0);
kernel vec4 _areaMinMaxRed16 (sampler image, vec2 bound,float first) __attribute__((outputFormat(kCIFormatRGh))) 
  vec2  d  = 4.0*destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(0.5)));
  vec2 mm = first > 0.1 ? p.rr : p.rg;
  vec2 v, location;
  for(int j = -2 ; j < 2; j++) {
    for(int i = -2; i < 2; i++) {
       location = vec2(float(i),float(j)) + vec2(0.5);
       p = sample(image, samplerTransform(image, d + location));
       v = first > 0.1 ? p.rr : p.rg;
       mm.r = location.x < bound.x ? min(v.r, mm.r) : mm.r;
       mm.g = location.x < bound.x ? max(v.g, mm.g) : mm.g;
    }
  return vec4(mm, 0.0, 1.0);
kernel vec4 _areaMinMaxRed4 (sampler image, vec2 bound,float first) __attribute__((outputFormat(kCIFormatRGh))) 
  vec2  d  = 2.0*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5)));
  vec2 mm0 = ( first > 0.1 ) ? p0.rr : p0.rg;
  vec2 mm1 = ( first > 0.1 ) ? p1.rr : p1.rg;
  vec2 mm2 = ( first > 0.1 ) ? p2.rr : p2.rg;
  vec2 mm3 = ( first > 0.1 ) ? p3.rr : p3.rg;
  mm0.r = (d.x+0.5 < bound.x)  ?  min(mm0.r, mm1.r)  :  mm0.r;
  mm2.r = (d.x+0.5 < bound.x)  ?  min(mm2.r, mm3.r)  :  mm2.r;
  mm0.r = (d.y+0.5 < bound.y)  ?  min(mm0.r, mm2.r)  :  mm0.r;
  mm0.g = (d.x+0.5 < bound.x)  ?  max(mm0.g, mm1.g)  :  mm0.g;
  mm2.g = (d.x+0.5 < bound.x)  ?  max(mm2.g, mm3.g)  :  mm2.g;
  mm0.g = (d.y+0.5 < bound.y)  ?  max(mm0.g, mm2.g)  :  mm0.g;
  return vec4(mm0.rg, 0.0, 1.0);
kernel vec4 _horizMinMaxRed4(sampler image, float bound,float first) __attribute__((outputFormat(kCIFormatRGh)))
  vec2 d  = vec2(4.0,1.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2(-1.5, 0.0)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2(-0.5, 0.0)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2(+0.5, 0.0)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2(+1.5, 0.0)));
  vec2 mm0 = ( first > 0.1 ) ? p0.rr : p0.rg;
  vec2 mm1 = ( first > 0.1 ) ? p1.rr : p1.rg;
  vec2 mm2 = ( first > 0.1 ) ? p2.rr : p2.rg;
  vec2 mm3 = ( first > 0.1 ) ? p3.rr : p3.rg;
  mm0.r = (d.x-0.5 < bound)  ?  min(mm0.r, mm1.r)  :  mm0.r;
  mm0.r = (d.x+0.5 < bound)  ?  min(mm0.r, mm2.r)  :  mm0.r;
  mm0.r = (d.x+1.5 < bound)  ?  min(mm0.r, mm3.r)  :  mm0.r;
  mm0.g = (d.x-0.5 < bound)  ?  max(mm0.g, mm1.g)  :  mm0.g;
  mm0.g = (d.x+0.5 < bound)  ?  max(mm0.g, mm2.g)  :  mm0.g;
  mm0.g = (d.x+1.5 < bound)  ?  max(mm0.g, mm3.g)  :  mm0.g;
  return vec4(mm0.rg, 0.0, 1.0);
kernel vec4 _vertMinMaxRed4(sampler image, float bound,float first) __attribute__((outputFormat(kCIFormatRGh)))
  vec2 d  = vec2(1.0,4.0)*destCoord();
  vec4 p0 = sample(image, samplerTransform(image, d + vec2( 0.0,-1.5)));
  vec4 p1 = sample(image, samplerTransform(image, d + vec2( 0.0,-0.5)));
  vec4 p2 = sample(image, samplerTransform(image, d + vec2( 0.0,+0.5)));
  vec4 p3 = sample(image, samplerTransform(image, d + vec2( 0.0,+1.5)));
  vec2 mm0 = ( first > 0.1 ) ? p0.rr : p0.rg;
  vec2 mm1 = ( first > 0.1 ) ? p1.rr : p1.rg;
  vec2 mm2 = ( first > 0.1 ) ? p2.rr : p2.rg;
  vec2 mm3 = ( first > 0.1 ) ? p3.rr : p3.rg;
  mm0.r = (d.y-0.5 < bound)  ?  min(mm0.r, mm1.r)  :  mm0.r;
  mm0.r = (d.y+0.5 < bound)  ?  min(mm0.r, mm2.r)  :  mm0.r;
  mm0.r = (d.y+1.5 < bound)  ?  min(mm0.r, mm3.r)  :  mm0.r;
  mm0.g = (d.y-0.5 < bound)  ?  max(mm0.g, mm1.g)  :  mm0.g;
  mm0.g = (d.y+0.5 < bound)  ?  max(mm0.g, mm2.g)  :  mm0.g;
  mm0.g = (d.y+1.5 < bound)  ?  max(mm0.g, mm3.g)  :  mm0.g;
  return vec4(mm0.rg, 0.0, 1.0);
kernel vec4 _minMaxNormalize(__sample c, __sample minc, __sample maxc) 
  c.rgb = (c.rgb - minc.rgb) / max(maxc.rgb - minc.rgb, 0.00001);   return c; 
kernel vec4 _minMaxRedNormalize(__sample c, __sample minmaxc) __attribute__((outputFormat(kCIFormatRh))) 
  c.r = (c.r - minmaxc.r) / max(minmaxc.g - minmaxc.r, 0.00001); 
  return c; 
10.15
inputPasses
inputPerceptual
kernel vec4 _KM_combine(__sample buffer, __sample s1, __sample s2) {
 return buffer + s1 + s2;
-[CIKMeans _combine:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/CIReduction.mm
type_check < 0 || type_check == 0
type_check < 0 || type_check == 1
v.count == 3 || v.count == 4
type_check < 0 || type_check == 2
float _KM_distance(vec4 c) { return dot(c,c); }
kernel vec4 _KM_select(sampler image, sampler means, float K, float k) __attribute__((outputFormat(kCIFormatRGBAh))) {
    vec4 img = sample(image, samplerTransform(image, destCoord()));
    vec4 kmin4 = sample(means, samplerTransform(means, vec2(0.5 + k, 0.5)));
    float kmin = _KM_distance(img-kmin4);
    float minm = kmin;
    for (float m = 0.0f; m < K; m += 1.0f) {
        vec4 mean = sample(means, samplerTransform(means, vec2(0.5 + m, 0.5)));
        minm = min(minm, _KM_distance(img-mean));
    }
    return abs(kmin-minm) < 0.000001 ? img : vec4(0.0);
-[CIKMeans outputImage]
Either inputMeans or inputCount should be specified.
infinite
%.1f x %.1f
Mean seeds should be passed as a K x 1 image but received %@]
CILinearGradient
inputColor0
inputColor1
CIAreaAverage
inputMeans
T@"CIImage",&,N,VinputMeans
T@"NSNumber",C,N,VinputCount
T@"NSNumber",C,N,VinputPasses
T@"NSNumber",C,N,VinputPerceptual
kernel vec4 _ACWeightedCoordinatesR(__sample weight, vec4 originInvExtent) __attribute__((outputFormat(kCIFormatRGBAh))) { 
 return weight.r * vec4((destCoord()-originInvExtent.xy)*originInvExtent.zw, 1.0, 1.0); 
kernel vec4 _ACCentroid(__sample c, vec4 extent) __attribute__((outputFormat(kCIFormatRGh))) { 
 return vec4(extent.xy + c.xy / max(c.z, 0.0001) * vec2(extent.zw), 0.0, 1.0);
inputRadialMode
inputMinWeight
kernel vec4 _RCFalloffGaussian(__sample img, __sample center, float invSigma2) __attribute__((outputFormat(kCIFormatRh))) { 
 vec2 d = destCoord(); 
 vec2 c = center.xy; 
 return img * exp(-dot(d-c,d-c)*invSigma2); 
kernel vec4 _RCFalloffDisk(__sample img, __sample center, float r2) __attribute__((outputFormat(kCIFormatRh))) { 
 vec2 d = destCoord(); 
 vec2 c = center.xy; 
 return img * (dot(d-c,d-c) < r2 ? 1.0 : 0.0); 
kernel vec4 _RCCenter(vec2 c) __attribute__((outputFormat(kCIFormatRGh))) { 
 return vec4(c.x, c.y, 0., 1.); 
CIAreaRedCentroid
T@"CIImage",&,N,VinputCenter
T@"NSNumber",&,N,VinputRadialMode
T@"NSNumber",&,N,VinputMinWeight
kernel vec4 _PSDrawSpread(__sample coordinate, float r2) __attribute__((outputFormat(kCIFormatRGBAh))) 
    vec2 v = destCoord() - coordinate.xy;
    return dot(v,v) <= r2 ? vec4(1.0) : vec4(0.0);
inputCoordinate
T@"CIImage",&,N,VinputCoordinate
inputInnerRadius
T@"NSNumber",C,N,VinputInnerRadius
inputOuterRadius
T@"NSNumber",C,N,VinputOuterRadius
kernel vec4 _areaAvg8(sampler image)
  vec2 d = 8.0*destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-3.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2( 1.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2( 3.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2(-3.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2( 1.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2( 3.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-3.0, 1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0, 1.0))) 
         + sample(image, samplerTransform(image, d + vec2( 1.0, 1.0))) 
         + sample(image, samplerTransform(image, d + vec2( 3.0, 1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-3.0, 3.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0, 3.0))) 
         + sample(image, samplerTransform(image, d + vec2( 1.0, 3.0))) 
         + sample(image, samplerTransform(image, d + vec2( 3.0, 3.0)));
  return 0.0625*p;
kernel vec4 _areaAvg4(sampler image)
  vec2 d = 4.0*destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-1.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0,+1.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0,+1.0)));
  return 0.25*p;
kernel vec4 _areaAvg2(sampler image)
  vec2 d  = 2.0*destCoord();
  return sample(image, samplerTransform(image, d));
kernel vec4 _vertAvg16(sampler image)
  vec2 d = vec2(1.0, 16.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(0.0,-7.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,-5.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+3.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+5.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+7.0)));
  return p * 0.125;
kernel vec4 _vertAvg8(sampler image)
  vec2 d = vec2(1.0, 8.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(0.0,-3.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+3.0)));
  return p * 0.25;
kernel vec4 _vertAvg4(sampler image)
  vec2 d = vec2(1.0, 4.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(0.0,-1.0))) 
         + sample(image, samplerTransform(image, d + vec2(0.0,+1.0)));
  return p * 0.5;
kernel vec4 _vertAvg2(sampler image)
  vec2 d = vec2(1.0,2.0)*destCoord();
  return sample(image, samplerTransform(image, d));
kernel vec4 _horizAvg16(sampler image)
  vec2 d = vec2(16.0, 1.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-7.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(-5.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(-3.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+3.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+5.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+7.0, 0.0)));
  return p * 0.125;
kernel vec4 _horizAvg8(sampler image)
  vec2 d = vec2(8.0, 1.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-3.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(-1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+3.0, 0.0)));
  return p * 0.25;
kernel vec4 _horizAvg4(sampler image)
  vec2 d = vec2(4.0, 1.0) * destCoord();
  vec4 p = sample(image, samplerTransform(image, d + vec2(-1.0, 0.0))) 
         + sample(image, samplerTransform(image, d + vec2(+1.0, 0.0)));
  return p * 0.5;
kernel vec4 _horizAvg2(sampler image)
  vec2 d = vec2(2.0,1.0)*destCoord();
  return sample(image, samplerTransform(image, d));
kernel vec4 _RCSelectGreaterThan(__sample c, __sample d, __sample minimax, float threshold) { return minimax.g > threshold ? c : d; 
construct_shader
static constant float4 _ci_constants = (float4)(1.0,0.0,1.0/257.0,256.0/257.0);
const lowp vec4 _ci_constants = vec4(1.0,0.0,1.0/257.0,256.0/257.0);
static constant metal::float4 _ci_constants = metal::float4(1.0,0.0,1.0/257.0,256.0/257.0);
#define writeImage(c, p, _dc) write_imagef(_outputTexture, (int2)p, c)
#define writeImagePlane(c, p, _dc) write_imagef(_outputTexturePlane, (int2)p, c)
#define writePixel(r, g, b, a, p, _dc) write_imagei(_outputTexture, (int2)p, (int4)(r,g,b,a))
#define writeCoord(_dc) (float2)_writeLoc
#define writeImage(c, p) gl_FragData[0] = c
#define writeImagePlane(c, p) gl_FragData[1] = c
#define writePixel(r, g, b, a, p) 
#define writeCoord() p0
#define writeImage(c, p, _dc) _outputTexture.write(c, static_cast<uint2>(p))
#define writeImagePlane(c, p, _dc) _outputTexturePlane.write(c, static_cast<uint2>(p))
#define writePixel(r, g, b, a, p, _dc) _outputTexture.write(float4(r,g,b,a) / 255.0, static_cast<uint2>(p))
#define writeCoord(_dc) static_cast<float2>(_wc)
gid += static_cast<uint2>(params.outputRect.xy * step(params.outputRect.w, 0.0));
gid.y += lessThan(params.outputRect.w, 0) * ((-params.outputRect.w-1)-2*gid.y);
  gid += static_cast<uint2>(params.outputRect.xy);
write_imagef
gl_FragColor
outputTexture.write
writeImage
_STUB_
writeImagePlane
writePixel
writeCoord
write_only image2d_t out
texture2d<float, access::write> outputTexture
write_only image2d_t _outputTexture
write_only image2d_t _outputTexturePlane
int2 _writeLoc
out1
_writeLoc
texture2d<float, access::write> _outputTexture
texture2d<float, access::write> _outputTexturePlane
uint2 _wc
outputTexture
outputTexture1
 %s1,
, %s
T@"CIVector",&,N,VinputRVector
T@"CIVector",&,N,VinputGVector
T@"CIVector",&,N,VinputBVector
T@"CIVector",&,N,VinputAVector
T@"CIVector",&,N,VinputBiasVector
kernel vec4 _vibrance_neg(__sample pixel0, float vibrance)
  vec4 pixel = clamp(pixel0, 0.0001, 0.9999);
  vec4 pdelta = pixel0 - pixel;
  float gray = (pixel.r + pixel.g + pixel.b) * 0.33333;
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  vec3 rgbsat = max((pixel.rgb - gray) * gii, (gray - pixel.rgb) * gi);
  float sat = max(max(rgbsat.r, rgbsat.g), rgbsat.b);
  float skin = min(pixel.r - pixel.g, pixel.g * 2.0 - pixel.b) * 4.0 * (1.0 - rgbsat.r) * gi;
  skin = 0.15 + clamp(skin, 0.0, 1.0) * 0.7;
  float boost = ((sat * (sat - 1.0) + 1.0) * vibrance) * (1.0-skin);
  pixel = clamp(pixel + (pixel - gray) * boost, 0.0, 1.0);
  pixel.a = pixel0.a;
  pixel.rgb += pdelta.rgb;
  return pixel;
kernel vec4 _vibrance_pos(__sample pixel0, vec4 vvec)
  vec4 pixel = clamp(pixel0, 0.0001, 0.9999);
  vec4 pdelta = pixel0 - pixel;
  float gray = (pixel.r + pixel.g + pixel.b) * 0.33333;
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  vec3 rgbsat = max((pixel.rgb - gray) * gii, (gray - pixel.rgb) * gi);
  float sat = max(max(rgbsat.r, rgbsat.g), rgbsat.b);
  float skin = min(pixel.r - pixel.g, pixel.g * 2.0 - pixel.b) * 4.0 * (1.0 - rgbsat.r) * gi;
  skin = 0.15 + clamp(skin, 0.0, 1.0) * 0.7;
  float boost = dot(vvec, vec4(1.0, sat, sat*sat, sat*sat*sat)) * (1.0 - skin);
  pixel = clamp(pixel + (pixel - gray) * boost, 0.0, 1.0);
  pixel.a = pixel0.a;
  pixel.rgb += pdelta.rgb;
  return pixel;
Vibrance
inputDraftMode
kernel vec4 _xSmooth(sampler image)
    float v;
    float sum = 0.0;
    float minv = 100.0;
    vec2  dc = destCoord();
    for(int i = -4; i < 5; i++) {
        v = sample(image, samplerTransform(image, dc + vec2(float(i),0.0))).r;
        sum += (v*v) * 0.1111111111;
        minv = min(minv,v);
    }
    return vec4(sqrt(sum),minv,0.0,1.0);
kernel vec4 _ySmooth(sampler image,sampler reference,vec4 blurValues)
    vec2 v;
    float sum = 0.0;
    float minv = 100.0;
    vec2  dc = destCoord();
    for(int i = -4; i < 5; i++) {
        v = sample(image, samplerTransform(image, dc + vec2(0.0,float(i)))).rg;
        sum += (v.r*v.r) * 0.1111111111;
        minv = min(minv,v.g);
    }
    sum = sqrt(sum);
    float refT0 = blurValues.x;
    float refT1 = blurValues.y;
    float minT0 = blurValues.z;
    float minT1 = blurValues.w;
    float ref = sample(reference, samplerCoord(reference)).x;
    float mixWeight = smoothstep(refT0, refT1, ref) * smoothstep(minT0, minT1, minv);
    float result = mix(ref, sum, mixWeight);
    return vec4(result,0.0,0.0,1.0);
nIterations
originalBlurValueT0
originalBlurValueT1
localMinimumBlurValueT0
localMinimumBlurValueT1
T@"CIImage",&,VinputImage
T@"NSNumber",&,VinputScale
inputTuningParameters
T@"NSDictionary",&,VinputTuningParameters
T@"NSNumber",&,N,VinputDraftMode
vec2 pseudo_randKY( vec2 pos )
float rand1 = mod(12.63 * pos.x - 57.3 * pos.y * pos.y, 0.01369) 
+ mod(75.833 * pos.y - 37.135 * pos.x * pos.x, 0.014) 
+ mod(39.7 * pos.x * pos.y + 21.7 * pos.x * pos.y * pos.y, 0.0879);
vec2 rand2 = fract(3576.7453 * vec2( rand1, 2.0 * rand1 ));
vec2 rand3 = fract(vec2(7.7387 * (rand2.x + rand2.y), 33.707 * (rand2.x - rand2.y)));
return rand3;
kernel vec4 _CIPortraitBlurNoise(__sample pixBlurred, vec4 params)
    float lumaNoiseAmpl = params.x;
    float lumaNoiseModelCoeff = params.y;
    vec2 randVal = pseudo_randKY( destCoord() / params.zw );
    float noiseLuma = clamp( sqrt( -2.0 * log(randVal.x) ) * cos( 6.2832 * randVal.y ), -5.0, 5.0 );
    vec4 kRGB_to_Y = vec4( 0.299 , 0.587, 0.114, 0.0);
    float outLuma = dot( pixBlurred, kRGB_to_Y );
    float addLumaNoiseLevel = lumaNoiseAmpl * mix( 1.0, outLuma, lumaNoiseModelCoeff );
    vec4 pixOut = clamp( pixBlurred + (noiseLuma * addLumaNoiseLevel) , 0.0, 1.0);
    pixOut.w = pixBlurred.w;
 return pixOut;
_CIPortraitBlurNoiseM
inputLumaNoiseAmpl
T@"NSNumber",C,N,VinputLumaNoiseAmpl
inputLumaNoiseModelCoeff
T@"NSNumber",C,N,VinputLumaNoiseModelCoeff
T@"CIVector",C,VinputExtent
inputUseMetal
T@"NSNumber",C,N,VinputUseMetal
kernel vec4 _CIPortraitBlurDir(sampler image,vec3 params)
    vec2 dir = params.yz;
    vec2 dc = destCoord(); 
    vec4 pix0 = sample( image, samplerTransform(image, dc -3.0 * dir));
    vec4 pix1 = sample( image, samplerTransform(image, dc -2.0 * dir));
    vec4 pix2 = sample( image, samplerTransform(image, dc - dir));
    vec4 pix3 = sample( image, samplerTransform(image, dc));
    vec4 pix4 = sample( image, samplerTransform(image, dc + dir));
    vec4 pix5 = sample( image, samplerTransform(image, dc + 2.0 * dir));
    vec4 pix6 = sample( image, samplerTransform(image, dc + 3.0 * dir));
    float outW = pix3.w;
    pix0.w = pix0.w * pix0.w;
    pix1.w = pix1.w * pix1.w;
    pix2.w = pix2.w * pix2.w;
    pix3.w = pix3.w * pix3.w;
    pix4.w = pix4.w * pix4.w;
    pix5.w = pix5.w * pix5.w;
    pix6.w = pix6.w * pix6.w;
    float radius = max(params.x * pix3.w, 1e-2);
    float radius2 = 1.0 / (2.0 * radius * radius);
    float weight0 = 1.0;
    float weight1 = exp(-1.0 * radius2);
    float weight2 = weight1 * weight1 * weight1 * weight1;
    float weight3 = weight2 * weight2 * weight1;
    float invWeightSum = 1.0 / (pix0.w * weight3 + pix1.w * weight2 + pix2.w * weight1 + pix3.w * weight0 + pix4.w * weight1 + pix5.w * weight2 + pix6.w * weight3 );
    weight0 *= invWeightSum;
    weight1 *= invWeightSum;
    weight2 *= invWeightSum;
    weight3 *= invWeightSum;
   vec4 pixOut;
   pixOut.xyz = weight3 * pix0.w * pix0.xyz + weight2 * pix1.w * pix1.xyz + weight1 * pix2.w * pix2.xyz 
              + weight0 * pix3.w * pix3.xyz + weight1 * pix4.w * pix4.xyz + weight2 * pix5.w * pix5.xyz 
              + weight3 * pix6.w * pix6.xyz;
   pixOut.w = outW;
    
return pixOut;
_CIPortraitBlurDirM
inputMaxBlur
T@"NSNumber",C,N,VinputMaxBlur
inputHorizontalBlur
T@"NSNumber",C,N,VinputHorizontalBlur
inputAntiAliasBlurStrength
T@"NSNumber",C,N,VinputAntiAliasBlurStrength
inputLumaNoiseScale
inputAperture
inputShape
NSString
vec2 _pseudo_randPBN( vec2 pos )
    float rand1 = mod(12.63 * pos.x - 57.3 * pos.y * pos.y, 0.01369) + mod(75.833 * pos.y - 37.135 * pos.x * pos.x, 0.014) + mod(39.7 * pos.x * pos.y + 21.7 * pos.x * pos.y * pos.y, 0.0879);
    vec2 rand2 = fract(3576.7453 * vec2( rand1, 2.0 * rand1 ));
    return fract(vec2(7.7387 * (rand2.x + rand2.y), 33.707 * (rand2.x - rand2.y)));
vec4 _pixWeight( vec4 sampledPix,vec2 offset,float basePixRawR,float distWeight,vec2 spatialWeightSoftMinMax ,float highlightBoostGain,vec2 relativeWeightThreshold) {
    float sampleR = 1.0 / sqrt(offset.x*offset.x + offset.y*offset.y);
    float spatialWeight = clamp(spatialWeightSoftMinMax.x * sampledPix.w * sampleR + spatialWeightSoftMinMax.y, 0.0, 1.0);
    float colorWeight = highlightBoostGain * (sampledPix.x + sampledPix.y + sampledPix.z) + 1.0; 
    float backgroundWeight = (3.0 - 2.0 * sampledPix.w);
    float rwT = clamp(relativeWeightThreshold.x * (sampledPix.w - basePixRawR) + relativeWeightThreshold.y, 0.0, 1.0);
    float relativeWeight = rwT * rwT * (3.0 - 2.0 * rwT); 
    float totalWeight = distWeight * spatialWeight * colorWeight * backgroundWeight * relativeWeight;
    return vec4( totalWeight * sampledPix.xyz, totalWeight );
float _ushortMultiply(float a,float multiplier) {
   int q = int(a) * int(multiplier);
   int r = q/65536;
   int m = q - r * 65536;
   float mf = float(m);
   return mf + compare(mf, 65535.0, 0.0);
kernel vec4 _CIPortraitBlur(sampler image,vec4 sizeAndScale,vec3 p0,vec4 p1,vec2 relativeWeightThreshold) 
   float maxBlurInPixels         = p0.x;
   float sharpRadius             = p0.y;
   float highlightBoostGain      = p0.z;
   vec2 spatialWeightSoftMinMax  = p1.xy;
   float basePixelWeight         = p1.z;
   int numSamples                = int(p1.w);
    vec2 dc = destCoord();
    vec4 basePix = sample(image, samplerCoord(image));
    float rawBlurRadius = basePix.w * basePix.w;
    float blurRadius = rawBlurRadius * maxBlurInPixels;
    vec4 outRGB;
    if ( blurRadius >= sharpRadius )
    {
      vec4 pixSum = vec4(basePix.xyz * basePixelWeight, basePixelWeight);
   vec2 randXY = _pseudo_randPBN(dc/sizeAndScale.xy) * sizeAndScale.zw * 65536.0;
      for ( int i = 0; i < numSamples; i++ )
      {
           vec2 randXY2 = (1./32767.5) * randXY - 1.0; 
           float randDist = randXY2.x*randXY2.x + randXY2.y*randXY2.y;
           float randNorm0 = max(abs(randXY2.x),abs(randXY2.y));
           float randShape = randNorm0 / sqrt(randDist);
           vec2  samplePos = randShape * rawBlurRadius * randXY2;
           float randW = randShape * randShape;
           samplePos.y = -samplePos.y;
           randXY.x = _ushortMultiply(randXY.x, 28563.0);
           randXY.y = _ushortMultiply(randXY.y, 44519.0);
        vec4 pix = sample( image, samplerTransform(image, dc + maxBlurInPixels * samplePos));
           pix.w = pix.w * pix.w;
           pixSum += _pixWeight(pix, samplePos, rawBlurRadius, randW, spatialWeightSoftMinMax, highlightBoostGain, relativeWeightThreshold);
        }
        outRGB.xyz = pixSum.w > 0.0 ?  vec3(pixSum.xyz / pixSum.w) : basePix.xyz;
        outRGB.w = basePix.w;
    }
    else
    {
        outRGB = basePix;
    }
return outRGB;
_CIPortraitBlurM
_CIPortraitBlurShapeM
vec2 _pseudo_randPBNS( vec2 pos )
    float rand1 = mod(12.63 * pos.x - 57.3 * pos.y * pos.y, 0.01369) + mod(75.833 * pos.y - 37.135 * pos.x * pos.x, 0.014) + mod(39.7 * pos.x * pos.y + 21.7 * pos.x * pos.y * pos.y, 0.0879);
    vec2 rand2 = fract(3576.7453 * vec2( rand1, 2.0 * rand1 ));
    return fract(vec2(7.7387 * (rand2.x + rand2.y), 33.707 * (rand2.x - rand2.y)));
float _spatialWeightHearts(vec4 sampledPix,vec2 offset,vec4 shapeOrientation) {
   offset = offset.x * shapeOrientation.xy + offset.y * shapeOrientation.zw;
   vec2 sampleR = vec2(abs(offset.x), -offset.y) / sampledPix.w;
   vec2 v = sampleR - vec2(0.45, -0.217945);
   float lenSquared = v.x * v.x + v.y * v.y;
   bool circleT = lenSquared <= 0.25;
   bool innerT = dot(sampleR, vec2( -0.593342, 0.780268 ))  +0.340111 > 0.0;
   bool tailT  = dot(vec2(sampleR), vec2( -0.842548, -0.780268 )) +0.780268 > 0.0;
   return circleT || (innerT && tailT) ? 1.0 : 0.0;
float _spatialWeightPentagon(vec4 sampledPix,vec2 offset,vec4 shapeOrientation) {
   offset = offset.x * shapeOrientation.xy + offset.y * shapeOrientation.zw;
   vec2 sampleR = vec2(abs(offset.x), -offset.y) / sampledPix.w;
   float v1 =  dot( sampleR, vec2(-0.690758, 0.950983) ) + 0.950983;
   float v2 =  dot( sampleR, vec2(-1.117980, -0.3628144) ) + 0.950984;
   float v3 =  sampleR.y;
   return v1 > 0.0 && v2 > 0.0 && v3 < 0.808738 ? 1.0 : 0.0;
float _spatialWeightRings(vec4 sampledPix,vec2 offset) {
   vec2 sampleR = offset / sampledPix.w;
   float sampleD = length(sampleR);
   return sampleD > 0.3 && sampleD <= 1.0 ? 1.0 : 0.0;
float _spatialWeightStars(vec4 sampledPix,vec2 offset,vec4 shapeOrientation) {
   offset = offset.x * shapeOrientation.xy + offset.y * shapeOrientation.zw;
   vec2 sampleR = vec2(abs(offset.x), -offset.y) / sampledPix.w;
   float t1a = dot( sampleR, vec2(-1.11798, 1.53915) ) - 0.587209;
   float t1b = dot( sampleR, vec2(1.80874, -0.58816) ) - 0.588168;
   float t2a = sampleR.y + 0.30924;
   float t2b = dot( sampleR, vec2( 1.11798, 1.53915 ) ) - 0.587209;
   return ((t1a < 0.0) && (t1b < 0.0)) || ((t2a > 0.0) && (t2b < 0.0)) ? 1.0 : 0.0;
float _spatialWeightSwirl(vec4 sampledPix,vec2 offset,vec4 rotVec) {
    vec2 sampleR = offset / sampledPix.w; 
    float sampleD = length(sampleR.x * rotVec.xy + sampleR.y * rotVec.zw);
    return sampleD <= 1.0 ? 1.0 : 0.0;
float _spatialWeightSwirl2(vec4 sampledPix, vec2 offset, vec2 offsetUV, vec4 rotVec) { 
vec2 sampleR = offset / sampledPix.w; 
vec2 iRotVec = vec2(-rotVec.y, rotVec.x); 
vec2 uv = sampleR.x * rotVec.xy + sampleR.y * iRotVec + offsetUV; 
uv.y = abs(uv.y) +  rotVec.z; 
float sampleD = length(uv); 
float w = sampleD >= 0.8 ? 1.0 : 0.5; 
return sampleD <= 1.0 ? w : 0.0; 
float _spatialWeightSwirl3(vec4 sampledPix, vec2 offset, float radiusScale, vec4 rotVec) { 
vec2 sampleR = offset / sampledPix.w; 
vec2 iRotVec = vec2(-rotVec.y, rotVec.x); 
vec2 uv = sampleR.x * rotVec.xy + sampleR.y * iRotVec; 
uv.y = uv.y > 0.0 ? uv.y : uv.y - rotVec.z; 
float sampleD = length(uv) * radiusScale; 
float w = sampleD >= 0.8 ? 1.0 : 0.5; 
return sampleD <= 1.0 ? w : 0.0; 
vec3 _pixWeightShape( vec4 sampledPix,vec2 offset,float basePixRawR,float distWeight,vec2 spatialWeightSoftMinMax ,float highlightBoostGain,vec2 relativeWeightThreshold,vec4 shapeOrientation,float shape) {
   vec3 spatialWeight = vec3( 0.0, 0.0, 0.0 );
   int shapeN = int(shape);
   if (shapeN == 0) spatialWeight = vec3( _spatialWeightHearts(sampledPix, offset, shapeOrientation) );
   else if ( shapeN == 1 ) spatialWeight = vec3( _spatialWeightPentagon(sampledPix, offset, shapeOrientation) );
   else if ( shapeN == 2 ) spatialWeight = vec3( _spatialWeightRings(sampledPix, offset) );
   else if ( shapeN == 3 ) spatialWeight = vec3( _spatialWeightStars(sampledPix, offset, shapeOrientation) );
   else if ( shapeN == 4 || shapeN == 5 ) spatialWeight = vec3( _spatialWeightSwirl(sampledPix, offset, shapeOrientation) );
   else if ( shapeN == 6 ) {
       spatialWeight.x = _spatialWeightSwirl2(sampledPix, offset, vec2(0,0.1), shapeOrientation);
       spatialWeight.y = _spatialWeightSwirl2(sampledPix, offset, vec2(0,0), shapeOrientation);
       spatialWeight.z = _spatialWeightSwirl2(sampledPix, offset, vec2(0,-0.1), shapeOrientation);
   } else if ( shapeN == 7 ) {
       spatialWeight.x = _spatialWeightSwirl3(sampledPix, offset, 1.1, shapeOrientation);
       spatialWeight.y = _spatialWeightSwirl3(sampledPix, offset, 1.0, shapeOrientation);
       spatialWeight.z = _spatialWeightSwirl3(sampledPix, offset, 1.05, shapeOrientation);
   } else {
      float sampleR = 1.0 / sqrt(offset.x*offset.x + offset.y*offset.y);
      spatialWeight = vec3( clamp(spatialWeightSoftMinMax.x * sampledPix.w * sampleR + spatialWeightSoftMinMax.y, 0.0, 1.0) );
   }
    float colorWeight = highlightBoostGain * (sampledPix.x + sampledPix.y + sampledPix.z) + 1.0; 
    float backgroundWeight = (3.0 - 2.0 * sampledPix.w);
    float rwT = clamp(relativeWeightThreshold.x * (sampledPix.w - basePixRawR) + relativeWeightThreshold.y, 0.0, 1.0);
    float relativeWeight = rwT * rwT * (3.0 - 2.0 * rwT); 
    vec3 totalWeight = distWeight * spatialWeight * colorWeight * backgroundWeight * relativeWeight;
    return totalWeight;
float _ushortMultiply2(float a,float multiplier) {
   int q = int(a) * int(multiplier);
   int r = q/65536;
   int m = q - r * 65536;
   return float(m) + ( m < 0  ? 65536.0 : 0.0);
kernel vec4 _CIPortraitBlurShape( sampler image,vec4 sizeAndScale,vec3 p0,vec4 p1,vec2 relativeWeightThreshold,vec4 shapeV,float shapeN) 
   float maxBlurInPixels         = p0.x;
   float sharpRadius             = p0.y;
   float highlightBoostGain      = p0.z;
   vec2 spatialWeightSoftMinMax  = p1.xy;
   float basePixelWeight         = p1.z;
   int numSamples                = int(p1.w);
    vec2 dc = destCoord();
    vec4 basePix = sample(image, samplerCoord(image));
    float rawBlurRadius = basePix.w * basePix.w;
    float blurRadius = rawBlurRadius * maxBlurInPixels;
  vec2 halfDims = 0.5 * sizeAndScale.xy;
  vec4 rotVec =  (halfDims.yxxy - dc.yxxy);
  float rotLen = length(rotVec.xy);
  float rotLenNorm = 2.0 * rotLen / max(halfDims.x, halfDims.y);
  rotVec *= 1.0 / rotLen;
  if ( int(shapeN) == 5 ) {
    rotVec *= vec4( -1.0 - rotLenNorm, -1.0, 1.0 + rotLenNorm, -1.0 );
    shapeV = rotVec;
  } else if ( int(shapeN) == 4 ) {
    rotVec *= vec4(-1.0, -1.0 - rotLenNorm, 1.0, -1.0 - rotLenNorm);
    shapeV = rotVec;
  } else if ( int(shapeN) == 6 ) {
    shapeV = vec4(rotVec.x, rotVec.y, rotLenNorm/8.0, 0.0);
  } else if ( int(shapeN) == 7 ) {
    shapeV = vec4(rotVec.x, rotVec.y, rotLenNorm/8.0, 0.0);
    vec4 outRGB;
    if ( blurRadius >= sharpRadius )
    {
      vec3 pixSum = basePix.xyz * basePixelWeight;
      vec3 pixWeightSum = vec3( basePixelWeight );
       vec2 randXY = _pseudo_randPBNS(dc/sizeAndScale.xy) * sizeAndScale.zw * 65536.0;
      for ( int i = 0; i < numSamples; i++ )
      {
           vec2 randXY2 = (1./32767.5) * randXY - 1.0; 
           float randDist = randXY2.x*randXY2.x + randXY2.y*randXY2.y;
           float randNorm0 = max(abs(randXY2.x),abs(randXY2.y));
           float randShape = randNorm0 / sqrt(randDist);
           vec2  samplePos = randShape * rawBlurRadius * randXY2;
           float randW = randShape * randShape;
           samplePos.y = -samplePos.y;
           randXY.x = ceil(_ushortMultiply2(randXY.x, 28563.0));
           randXY.y = ceil(_ushortMultiply2(randXY.y, 44519.0));
            vec4 pix = sample( image, samplerTransform(image, dc + maxBlurInPixels * samplePos));
           pix.w = pix.w * pix.w;
           vec3 pixWeight = _pixWeightShape(pix, samplePos, rawBlurRadius, randW, spatialWeightSoftMinMax, highlightBoostGain, relativeWeightThreshold, shapeV, shapeN);
           pixSum += pix.xyz * pixWeight;
           pixWeightSum += pixWeight;
        }
        outRGB.xyz = pixSum / pixWeightSum;
        outRGB.w = basePix.w;
    }
    else
    {
        outRGB = basePix;
    }
    return outRGB;
kernel vec4 _CIPortraitBlurBlendWithMaskFromAlpha(__sample sharp,__sample blurry,vec4 radii ) {
  float maxBlur = radii.x;
  float sharpRadius = radii.y;
  float softRadius = radii.z;
  float width = radii.w;
  float blurRadius = maxBlur * width * blurry.w * blurry.w;
  blurry.w = clamp( (blurRadius - sharpRadius) / softRadius, 0.0, 1.0);
  vec4 c = mix(sharp, blurry, blurry.w);
  c.w = sharp.w;
  return c;
_CIPortraitBlurBlendWithMaskFromAlphaM
CIPortraitBlurPreProcess
inputBlurmapImage
/tmp/preprocessed-CI.tiff
maxBlur
sharpRadius
highlightBoostGain
nSamples
spatialWeightSoftMin
spatialWeightSoftMax
relativeWeightThreshold
basePixelWeight
/tmp/blur-CI.tiff
antiAliasBlurStrength
CIPortraitBlurDirectionalBlur
/tmp/blur-X-CI.tiff
/tmp/blur-Y-CI.tiff
CIPortraitBlurNoise
lumaNoiseModelCoeff
/tmp/blur-NoiseAddedHalfRes-CI.tiff
/tmp/upsampledBlurredImage.tiff
/tmp/blur-NoiseAddedFullRes-CI.tiff
softRadius
/tmp/finalBlend.tiff
CI_DISABLE_PORTRAIT_METAL
CIPortraitBlurV2
CI_ENABLE_NEW_PORTRAIT
Version
-[CIPortraitBlur outputImage]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/PortraitBlur/CIPortraitBlur.m
0 && "unreachable"
T@"CIImage",&,VinputBlurmapImage
T@"CIImage",&,VinputMatteImage
T@"NSNumber",C,N,VinputLumaNoiseScale
T@"NSNumber",C,N,VinputScale
T@"NSNumber",C,N,VinputAperture
T@"NSDictionary",&,N,VinputTuningParameters
T@"NSString",&,N,VinputShape
kernel vec4 _CIBlurPreProcess(__sample downsampledImage,__sample refinedBlurmap)
{ return vec4(downsampledImage.xyz, refinedBlurmap.x); }
_CIBlurPreProcessM
hearts
pentagons
rings
stars
swirl
warp
lens1
lens2
_shader
_roiMethods
_insetRects
_scaleFactors
_class
halfInput
halfOutput
doubleOutput
identity
roiForInput:arguments:outputRect:
inputFontName
HelveticaNeue
inputFontSize
inputScaleFactor
-[CITextImageGenerator outputImage]
inputText
T@"NSString",&,N,VinputText
T@"NSString",&,N,VinputFontName
T@"NSNumber",&,N,VinputFontSize
T@"NSNumber",&,N,VinputScaleFactor
-[CIAttributedTextImageGenerator outputImage]
T@"NSAttributedString",&,N,VinputText
inputNeutral
inputTargetNeutral
T@"CIVector",&,D,N
T@"CIVector",&,N,VinputTargetNeutral
kernel vec4 _whitepointadjust (__sample img, __color color) { return img * color; }
T@"CIColor",&,N,VinputColor
kernel vec4 _falseColor (__sample img, __color c0, __color c1) 
 return img.a * mix (c0, c1, dot(img.rgb, vec3(.2125, .7154, .0721))); 
T@"CIColor",&,N,VinputColor0
T@"CIColor",&,N,VinputColor1
CI Internal Context
Could not set current EAGL context to %p.
inputPower
T@"NSNumber",&,N,VinputPower
kCIImageProcessorSynchronizeInputs
kCIImageProcessorAllowPartialOutputRegion
-[CIImageProcessorInOut initWithSurface:texture:allowSRGB:bounds:context:]
%@: cannot return a CVPixelBuffer on this platform.
<%@: %p %s extent [infinite]>
<%@: %p %s extent [empty]>
<%@: %p %s extent [%g %g %g %g]>
region
T{CGRect={CGPoint=ff}{CGSize=ff}},R,N,V_region
surface
T^{__IOSurface=},R,N
usesSRGBTransferFunction
TB,R,N
bytesPerRow
TL,R,N
device
T^v,R,N
-[CIImageProcessorOutput initWithSurface:texture:allowSRGB:bounds:context:]
baseAddress
metalTexture
T@"<MTLTexture>",R,N
metalCommandBuffer
T@"<MTLCommandBuffer>",R,N
Tr^v,R,N
-[CIImage(CIImageProcessor) imageWithExtent:processorDescription:argumentDigest:inputFormat:outputFormat:options:roiCallback:processor:]
Image Processor
v56@?0^^{__IOSurface}4^{Texture=(?={?=II}^v)}8^{CGRect={CGPoint=ff}{CGSize=ff}}12^B16^{__IOSurface=}20{Texture=(?={?=II}^v)}24{CGRect={CGPoint=ff}{CGSize=ff}}32B48^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@}52
%s must be overridden in %@ class
+[CIImageProcessorKernel processWithInputs:arguments:output:error:]
processWithInputs:arguments:output:error:
+[CIImageProcessorKernel applyWithExtent:inputs:arguments:error:]
CIImageProcessorKernel
outputFormat must be 0, %s.
inputFormat for image %d must be 0, %s.
CIGenericMetalProcessor
CIMetalProcessor
filterName
outputIsOpaque
synchronizeInputs
R8, Rh, Rf, BGRA8, RGBAh, RGBAf
emptyCIVector
emptyCIImage
emptyNSData
emptyNSString
emptyNSArray
emptyNSDictionary
kernel vec4 _noiseReduction(sampler src, vec2 offset, vec3 weight, vec3 intensity) 
 vec2 c = destCoord(); 
 vec4 cn = sample(src, samplerTransform(src, c)); 
 vec4 t0 = sample(src, samplerTransform(src, c + vec2(0.0,-offset.x))); 
 vec4 t1 = sample(src, samplerTransform(src, c + vec2(0.0, offset.x))); 
 vec4 t2 = sample(src, samplerTransform(src, c + vec2(-offset.x,0.0))); 
 vec4 t3 = sample(src, samplerTransform(src, c + vec2( offset.x,0.0))); 
 vec4 t4 = sample(src, samplerTransform(src, c + vec2( offset.y, offset.y))); 
 vec4 t5 = sample(src, samplerTransform(src, c + vec2( offset.y,-offset.y))); 
 vec4 t6 = sample(src, samplerTransform(src, c + vec2(-offset.y,-offset.y))); 
 vec4 t7 = sample(src, samplerTransform(src, c + vec2(-offset.y, offset.y))); 
 t0 = (t0+t1+t2+t3)*weight.x + (t4+t5+t6+t7)*weight.y + cn*weight.z; 
 vec4 d = abs(t0 - cn); 
 float s = intensity.x + intensity.y * (d.r + d.g + d.b); 
 s = clamp(s, intensity.z, 1.0); 
 return mix(cn, t0, s); 
inputNoiseLevel
kernel vec4 _convertRGBtoY (__sample c) 
 c = vec4(c.rgb/max(c.a,0.00001), c.a); 
 float Y = sqrt(max(dot(c.rgb, vec3(0.299,0.587,0.114)), 0.0)); 
 c.rgb = vec3(Y); 
 return c; 
kernel vec4 _blur1(sampler src) 
 vec2 p = destCoord(); 
 vec4 pixB = sample(src, samplerTransform(src, p + vec2(-1.0, 1.0))); 
 vec4 pixA = sample(src, samplerTransform(src, p + vec2( 0.0, 1.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2( 1.0, 1.0))); 
 pixA += sample(src, samplerTransform(src, p + vec2(-1.0, 0.0))); 
 vec4 pix = sample(src, samplerTransform(src, p)); 
 pixA += sample(src, samplerTransform(src, p + vec2( 1.0, 0.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2(-1.0,-1.0))); 
 pixA += sample(src, samplerTransform(src, p + vec2( 0.0,-1.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2( 1.0,-1.0))); 
 pix.g = pix.r * 0.25 + pixA.r * 0.125 + pixB.r * 0.0625; 
 return pix; 
kernel vec4 _blur2(sampler src) 
 vec2 p = destCoord(); 
 vec4 pixB = sample(src, samplerTransform(src, p + vec2(-2.0, 2.0))); 
 vec4 pixA = sample(src, samplerTransform(src, p + vec2( 0.0, 2.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2( 2.0, 2.0))); 
 pixA += sample(src, samplerTransform(src, p + vec2(-2.0, 0.0))); 
 vec4 pix = sample(src, samplerTransform(src, p)); 
 pixA += sample(src, samplerTransform(src, p + vec2( 2.0, 0.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2(-2.0,-2.0))); 
 pixA += sample(src, samplerTransform(src, p + vec2( 0.0,-2.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2( 2.0,-2.0))); 
 pix.b = pix.g * 0.25 + pixA.g * 0.125 + pixB.g * 0.0625; 
 return pix; 
kernel vec4 _blur4(sampler src) 
 vec2 p = destCoord(); 
 vec4 pixB = sample(src, samplerTransform(src, p + vec2(-4.0, 4.0))); 
 vec4 pixA = sample(src, samplerTransform(src, p + vec2( 0.0, 4.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2( 4.0, 4.0))); 
 pixA += sample(src, samplerTransform(src, p + vec2(-4.0, 0.0))); 
 vec4 pix = sample(src, samplerTransform(src, p)); 
 pixA += sample(src, samplerTransform(src, p + vec2( 4.0, 0.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2(-4.0,-4.0))); 
 pixA += sample(src, samplerTransform(src, p + vec2( 0.0,-4.0))); 
 pixB += sample(src, samplerTransform(src, p + vec2( 4.0,-4.0))); 
 pix.a = pix.b * 0.25 + pixA.b * 0.125 + pixB.b * 0.0625; 
 return pix; 
kernel vec4 _edgesPrep(__sample s) 
 s = vec4(s.rgb/max(s.a,0.00001), s.a); 
 s.rgb = sqrt(max(s.rgb, vec3(0.0))); 
 return s; 
kernel vec4 _findEdges(sampler src, float scale) 
 vec2 p = destCoord(); 
 vec4 rA = sample(src, samplerTransform(src, p)) - 
 sample(src, samplerTransform(src, p + vec2(1.0, 1.0))); 
 vec4 rB = sample(src, samplerTransform(src, p + vec2(0.0, 1.0))) - 
 sample(src, samplerTransform(src, p + vec2(1.0, 0.0))); 
 vec4 r = (rA*rA + rB*rB) * scale; 
 float R = min(max(max(r.r, r.g), r.b),1.0); 
 return vec4(vec3(R), 1.0); 
kernel vec4 _sharpenCombineEdges(__sample orig, __sample blurs, vec3 sharps, __sample edges) 
 vec4 so = vec4(orig.rgb/max(orig.a,0.00001), orig.a); 
 float Y = blurs.r + dot(blurs.r - blurs.gba, sharps); 
 so.rgb = vec3(Y*Y) + 
 so.r * vec3( 0.701428, -0.299276, -0.297756) + 
 so.g * vec3(-0.5881610, 0.4133170, -0.5857185) + 
 so.b * vec3(-0.113745, -0.113905, 0.884027); 
 float alpha = edges.x; 
 so = vec4(so.rgb*so.a, so.a); 
 return mix(orig, so, alpha); 
inputFalloff
inputEdgeScale
_texture
_buffer
v8@?0@"<MTLCommandBuffer>"4
kernel vec4 _opTile (sampler src, vec2 center, vec2 params, vec4 trans) 
 vec2 t3; 
 vec2 t1 = destCoord() - center; 
 vec2 t2 = floor (t1 * params.x) * params.y; 
 t1 = t1 - t2; 
 t3.x = dot (t2, trans.xy); 
 t3.y = dot (t2, trans.zw); 
 t1 = t3 + t1 + center; 
 return sample (src, samplerTransform (src, t1)); 
builtin_sqr
builtin_pow4
builtin_sqrt
builtin_gamma
sqrt
pow4
gamma %g
gamma
CI::TextureManager
TextureManager::TextureManager() failed to create empty surface
TextureManager::remove_lru() did not find an info struct!
%p numSurfaceHits: %zu, numMisses: %zu
kernel vec4 _checker (vec2 center, __color c0, __color c1, vec3 parms) 
 vec2 d0 = destCoord() - center; 
 d0 = fract(d0 * parms.x); 
 d0 = min (1.0 - d0, d0); 
 d0 = clamp (d0 * parms.y + parms.z, 0.0, 1.0); 
 d0 = (d0 * -2.0 + 3.0) * d0 * d0; 
 float d1 = 2.0 * min (d0.x, d0.y) + 1.0 - (d0.x + d0.y); 
 return mix(c1, c0, d1); 
T@"NSNumber",&,N,VinputWidth
T@"NSNumber",&,N,VinputSharpness
gltexture: %u
requires a GL or CL context.
failed to set texture destination.
signpost_render
signpost_compile
signpost_cache
signpost_dualredeye
clampRect
clampRect 
bitmap: %p
affine_matrix
wrap_mode
filter_mode
black
clamp
periodic
blur
blur_format
-[CISampler initWithImage:options:]
<CISampler: %p extent [infinite]>
<CISampler: %p extent [empty]>
<CISampler: %p extent [%g %g %g %g]>
<CISampler: %p>
color_matrix
bias
 %s=(%g %g %g %g)
kernel vec4 _shadedmaterial(sampler heightfield, sampler envmap, float surfaceScale, vec2 envscaling) 
 vec2 d = destCoord(); 
 vec4 sup = sample(heightfield, samplerTransform(heightfield, d+vec2( 0.0,+1.0))); 
 vec4 sdown = sample(heightfield, samplerTransform(heightfield, d+vec2( 0.0,-1.0))); 
 vec4 sleft = sample(heightfield, samplerTransform(heightfield, d+vec2(-1.0, 0.0))); 
 vec4 sright = sample(heightfield, samplerTransform(heightfield, d+vec2(+1.0, 0.0))); 
 vec4 scenter = sample(heightfield, samplerCoord(heightfield)); 
 vec3 normal = normalize(vec3(sleft.r - sright.r, sdown.r - sup.r, surfaceScale)); 
 vec2 eloc = (normal.xy * 0.495 + 0.5) * envscaling; 
 vec4 pix = sample(envmap, samplerTransform(envmap, eloc)); 
 return pix * scenter.a; 
kernel vec4 _shadedmaterial_0(sampler heightfield, sampler envmap, vec2 envscaling) 
 vec4 scenter = sample(heightfield, samplerCoord(heightfield)); 
 vec3 normal = vec3(0.0, 0.0, 1.0); 
 vec2 eloc = (normal.xy * 0.495 + 0.5) * envscaling; 
 vec4 pix = sample(envmap, samplerTransform(envmap, eloc)); 
 return pix * scenter.a; 
inputNumIterations
kernel vec4 _CIBoxBlur5Min(sampler i) __attribute__((outputFormat(kCIFormatRh)))
  vec2 dc = destCoord(); 
     vec4 c = vec4(0.0); 
     
     vec4 center = sample(i, samplerCoord(i)); 
     
     c += sample(i, samplerTransform(i,dc + vec2(-1.5, 1.5))) * 0.16; 
     c += sample(i, samplerTransform(i,dc + vec2( 0.0, 1.5))) * 0.08; 
     c += sample(i, samplerTransform(i,dc + vec2(+1.5, 1.5))) * 0.16; 
     c += sample(i, samplerTransform(i,dc + vec2(-1.5, 0.0))) * 0.08; 
     c += center * 0.04;
     c += sample(i, samplerTransform(i,dc + vec2(+1.5, 0.0))) * 0.08; 
  c += sample(i, samplerTransform(i,dc + vec2(-1.5,-1.5))) * 0.16; 
     c += sample(i, samplerTransform(i,dc + vec2( 0.0,-1.5))) * 0.08; 
     c += sample(i, samplerTransform(i,dc + vec2( 1.5,-1.5))) * 0.16; 
     
  c = min (c,center);
     c.bg = vec2(0.0);
     c.a = center.a;
     c.a = 1.0;
     
     return c;
/tmp/inputToBoxBlur.tiff
/tmp/outputFromBoxBlur.tiff
T@"NSNumber",C,VinputNumIterations
kernel vec4 _circle (vec4 parms, __color color) 
 float d = parms.z - length (destCoord() - parms.xy); 
 return clamp (d * parms.w + .5, 0.0, 1.0) * color; 
inputEdgeBlur
Warning smartToneStatistics will soon need [receiver properties] be non-nil so flash-fired state can be determined.
tonalRange
highKey
autoValue
blackPoint
whitePoint
satPercentile75
satPercentile98
satPercentileG98
satAutoValue
inputExposure
inputShadows
inputHighlights
inputBlack
inputLocalLight
inputRawHighlights
inputVibrancy
inputCast
inputUseCube
inputUseCubeColorSpace
kernel vec4 _smarttone_brightness_neg (__sample c, float gamma) 
 vec3 neg = min(c.rgb, 0.0); 
 c.rgb = max(c.rgb, 0.0); 
 vec3 pix = pow(c.rgb, vec3(gamma)); 
 float lum = dot(c.rgb, vec3(0.39, .5, .11)); 
 vec3 pix2 = lum>0.0 ? c.rgb*pow(lum, gamma)/lum : vec3(0.0); 
 pix = mix(pix, pix2, 0.8) + neg; 
 return vec4(pix, c.a); 
kernel vec4 _smarttone_brightness_pos (__sample c, float gamma) 
 vec3 neg = min(c.rgb, 0.0); 
 vec3 pos = max(c.rgb, 1.0)-1.0; 
 c.rgb = clamp(c.rgb, 0.0, 1.0); 
 vec3 m = 1.0-c.rgb; 
 float a = 0.6; 
 vec4 result = c; 
 result.rgb = 1.0 - (pow(m, vec3(gamma))+a*( ((gamma-1.0)*m*(1.0-m*m))/(gamma*gamma))); 
 c.rgb = pow(c.rgb, vec3(1.0-((min(gamma, 2.95)-1.0)/2.6))); 
 result.rgb = mix(c.rgb, result.rgb, .85); 
 result.rgb = result.rgb+neg+pos; 
 return result; 
kernel vec4 _smarttone_contrast (__sample im, float midAmt) 
 vec3 neg = min(im.rgb, 0.0); 
 vec3 pos = max(im.rgb, 1.0)-1.0; 
 im.rgb = clamp(im.rgb, 0.0, 1.0); 
 float y = dot(im.rgb, vec3(0.3333)); 
 y = sqrt(y); 
 float sat = (im.r-y)*(im.r-y)+(im.g-y)*(im.g-y)+(im.b-y)*(im.b-y); 
 y = y*(1.0-y); 
 im.rgb = sqrt(im.rgb); 
 float a = midAmt*y; 
 float b = -0.5*a; 
 vec3 pix = im.r * vec3(0.299*a) + 
 im.g * vec3(0.587*a) + 
 im.b * vec3(0.114*a) + 
 im.rgb + vec3(b); 
 im.rgb = mix(im.rgb, vec3(0.5), -y*midAmt); 
 im.rgb = mix(im.rgb, pix, 0.8+sat); 
 im.rgb = max(im.rgb, 0.0); 
 im.rgb *= im.rgb; 
 im.rgb = im.rgb + neg + pos; 
 return im; 
kernel vec4 _smarttone_highlightcontrast (__sample pix, float highAmt, float sat) 
 float lum = clamp(dot(pix.rgb, vec3(.3333)),0.0,1.0); 
 vec3 high = pow(max(pix.rgb, 0.0), vec3(3.0 - 2.0*highAmt)) + min(pix.rgb, 0.0); 
 float pivot = 0.8; 
 vec3 pix1 = (high - pivot)*(4.0 - 3.0*highAmt) + pivot; 
 float h = highAmt*highAmt*highAmt*highAmt; 
 float a = (4.0 - 3.0*h); 
 vec3 pix2 = (lum-pivot)*a+pivot + high.rgb -lum; 
 high = mix(pix2, pix1, sat); 
 pix.rgb = mix(pix.rgb, high, lum*lum); 
 return pix; 
kernel vec4 _rawHighlights(__sample pix, float gain) 
 vec3 high = gain*pix.rgb; 
 float lum = clamp(dot(pix.rgb, vec3(.3333)), 0.0, 1.0); 
 vec3 neg = min(high, 0.0); 
 high.rgb = mix(max(pix.rgb, 0.0), high.rgb, lum*lum) + neg; 
 return vec4(high, pix.a); 
CIColorCubeWithColorSpace
inputCubeData
inputCubeDimension
inputHighlightAmount
T@"NSNumber",&,N,VinputExposure
T@"NSNumber",&,N,VinputShadows
T@"NSNumber",&,N,VinputHighlights
T@"NSNumber",&,N,VinputBlack
T@"NSNumber",&,N,VinputRawHighlights
T@"NSNumber",&,N,VinputLocalLight
inputLightMap
T@"NSData",&,N,V_inputLightMap
T@"NSNumber",&,N,VinputUseCube
T@,&,N,VinputUseCubeColorSpace
kernel vec4 _smartcolor_contrast (__sample im, float amt) 
 vec3 diff = im.rgb-dot(im.rgb, vec3(.0, .3, .5)); 
 float dist = distance(diff, vec3(0.0)); 
 dist = smoothstep(0.0, 1.0, dist); 
 float strength = 5.0*dist*amt; 
 vec3 pos = max(im.rgb, 1.0)-1.0 + min(im.rgb, 0.0); 
 im.rgb = clamp(im.rgb, 0.0, 1.0); 
 strength *= (im.b-im.g); 
 strength = max(strength, -0.35); 
 vec4 result; 
 result.rgb = im.rgb/(strength + 1.0 - (im.rgb*strength)) + pos; 
 result.a = im.a; 
 return result; 
kernel vec4 _smartcolor_contrast_darken (__sample im, float amt) 
 vec3 diff = im.rgb-dot(im.rgb, vec3(.0, .3, .5)); 
 float dist = distance(diff, vec3(0.0)); 
 dist = smoothstep(0.0, 1.0, dist); 
 float strength = 5.0*dist*amt; 
 vec3 pos = max(im.rgb, 1.0)-1.0 + min(im.rgb, 0.0); 
 im.rgb = clamp(im.rgb, 0.0, 1.0); 
 strength *= (im.b-im.g); 
 float gray = 1.0-min(dot(im.rgb, vec3(0.5, 0.7, -0.20)), 1.0); 
 vec4 result; 
 result.rgb = strength < 0.0 ? pow(im.rgb, vec3(1.0-strength*gray)) : im.rgb/(strength+1.0-(im.rgb*strength)); 
 result.rgb += pos; result.a = im.a; 
 return result; 
kernel vec4 _smartcolor_vibrancy_gt1 (__sample im, float amt) 
 float gray = dot(clamp(im.rgb, 0.0, 1.0), vec3(.3, .5, .2)); 
 float y = dot(clamp(im.rgb, 0.0, 1.0), vec3(.4, .2, .1)); 
 float damp = 1.0-4.0*y*(1.0-y); 
 float s = 1.0/(im.r+im.g+im.b); 
 float r = im.r*s; 
 float b = im.b*s; 
 float d = 1.0-.8*smoothstep(0.2, 0.4, r-b); 
 damp *= d; 
 damp = amt > 2.5 ? min(damp+(amt-2.5)/5.0, 1.0) : damp; 
 float sat = min(amt, 3.0); 
 vec4 result; 
 result.rgb = (im.rgb - gray)*sat + gray; 
 result.rgb = mix(im.rgb, result.rgb, damp); 
 result.a = im.a; 
 return result; 
kernel vec4 _smartcolor_vibrancy_lt1 (__sample im, float amt) 
 float gray = dot(im.rgb, vec3(0.333333)); 
 im.rgb = mix(vec3(gray), im.rgb, amt); 
 return im; 
kernel vec4 _smartcolor_cast (__sample im, float lum, float grayI, float grayQ, float strength) 
 vec4 pix = clamp(im, 0.0, 1.0); 
 pix.rgb = pow(pix.rgb, vec3(.25)); 
 pix.rgb = pix.r * vec3(0.299, 0.595716, 0.211456) + 
 pix.g * vec3(0.587, -0.274453, -0.522591) + 
 pix.b * vec3(0.114, -0.321263, 0.311135); 
 vec2 grayOffset = vec2(grayI, grayQ) ; 
 vec3 result = pix.rgb; 
 float newStrength = 1.0 + (strength-1.0)*(1.0-pix.r) ; 
 result.gb = pix.gb + newStrength*grayOffset ; 
 float damp = max(min(1.0, pix.r/(lum+0.00001)),0.0) ; 
 result.rgb = mix(pix.rgb, result.rgb, damp) ; 
 pix.rgb = result.r * vec3(1.0) + 
 result.g * vec3(0.956296, -0.272122, -1.10699) + 
 result.b * vec3(0.621024, -0.647381, 1.70461); 
 pix.rgb = clamp(pix.rgb, 0.0, 1.0); 
 pix.rgb *= pix.rgb*pix.rgb*pix.rgb; 
 pix.rgb += min(im.rgb, 0.0) + max(im.rgb,1.0) -1.0; 
 return pix; 
T@"NSNumber",&,N,VinputVibrancy
T@"NSNumber",&,N,VinputCast
CI_SMART_TONE_USE_CUBE
CI_SMART_COLOR_USE_CUBE
inputFilename
inputShouldDumpInputValues
T@"NSString",&,VinputFilename
T@"NSNumber",&,VinputShouldDumpInputValues
T@"CIFilter",&,VinputOriginalFilter
-[CIBitmapContext setBitmap:rowBytes:bounds:format:]
-[CIBitmapContext drawImage:inRect:fromRect:]
kernel vec2 _paddedTile(vec4 k) { return fract(destCoord() * k.zw) * k.xy + vec2(1.0); }
processor
v56@?0^^{__IOSurface}4^{Texture=(?={?=II}^v)}8^{CGRect={CGPoint=ff}{CGSize=ff}}12^B16^{__IOSurface=}20{Texture=(?={?=II}^v)}24{CGRect={CGPoint=ff}{CGSize=ff}}32B48^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I^{dispatch_source_s}^{dispatch_group_s}}52
intermediate-uncached
intermediate-cached
intermediate
inputEpsilon
kernel vec4 _boxFilter3(sampler a) __attribute__((outputFormat(kCIFormatRGBAf)))
{ vec2 dc = destCoord(); 
  vec4 v0 = sample(a, samplerTransform(a, dc + vec2(-0.5, +0.5))) * (4.0/9.0); 
  vec4 v1 = sample(a, samplerTransform(a, dc + vec2( 1.0,  0.5))) * (2.0/9.0); 
  vec4 v2 = sample(a, samplerTransform(a, dc + vec2(-0.5, -1.0))) * (2.0/9.0); 
  vec4 v3 = sample(a, samplerTransform(a, dc + vec2( 1.0, -1.0))) * (1.0/9.0); 
  return (v0 + v1 + v2 + v3); 
CIBoxBlur
kernel vec4 _multiplyImages(__sample a,__sample b) __attribute__((outputFormat(kCIFormatRGBAf)))  { return a * b; }
kernel vec4 _subtractImages(__sample a,__sample b) { return a - b; }
kernel vec4 _computeAB(__sample var_I_A,__sample var_I_B,__sample cov_Ip,__sample meanIP,float eps) 
var_I_A.x  += eps; 
var_I_B.xz += eps; 
vec2 r1r2    = var_I_A.yz / var_I_A.xx;
var_I_B.xyz -= r1r2.xxy * var_I_A.yzz;
cov_Ip.yz   -= r1r2     * cov_Ip.xx;
r1r2.x     = var_I_B.y / var_I_B.x;
var_I_B.z -= r1r2.x * var_I_B.y;
cov_Ip.z  -= r1r2.x * cov_Ip.y;
cov_Ip.z  /= var_I_B.z;
cov_Ip.y   = (cov_Ip.y - var_I_B.y * cov_Ip.z) / var_I_B.x;
cov_Ip.x   = (cov_Ip.x - var_I_A.y * cov_Ip.y - var_I_A.z * cov_Ip.z) / var_I_A.x;
cov_Ip.w   = meanIP.w - dot(cov_Ip.xyz, meanIP.xyz);
return cov_Ip;
kernel vec4 _finalResult(__sample ab,__sample I) 
  float v = dot(ab.rgb, I.rgb) + ab.w;
  return vec4(v,v,v,1.0);
kernel vec4 _combineRGB_and_A(__sample a,__sample b) 
{ return vec4(a.xyz, b.r);  }
kernel vec4 _swizzleXXX1(__sample a) { return vec4(a.xxx,1.0); } 
kernel vec4 _swizzleYYZ1(__sample a) { return vec4(a.yyz,1.0); } 
kernel vec4 _swizzleYZZ1(__sample a) { return vec4(a.yzz,1.0); } 
inputGuideImage
T@"CIImage",&,VinputGuideImage
T@"NSNumber",C,VinputRadius
T@"NSNumber",C,VinputEpsilon
builtin_colormatrix_rrra
builtin_colormatrixdiag
builtin_colormatrixdiag4
builtin_colormatrix3x1
builtin_colormatrix3x3
builtin_colormatrix3x4
builtin_colormatrix
color_matrix_rrra
color_matrix_diag [%g, %g, %g]
color_matrix_diag4 [%g, %g, %g, %g]
color_matrix_3x1 [%g, %g, %g]
color_matrix_3x3 (
r=[%g %g %g],
g=[%g %g %g],
b=[%g %g %g])
color_matrix_3x4 (
bias=[%g %g %g])
color_matrix_4x3 (
r=[%g %g %g %g],
g=[%g %g %g %g],
b=[%g %g %g %g],
color_matrix (
a=[%g %g %g %g],
bias=[%g %g %g %g])
color_matrix_diag
color_matrix_diag4
color_matrix_3x1
color_matrix_3x3
color_matrix_3x4
color_matrix_4x3
colormatrix
kCIImageAutoAdjustEnhance
kCIImageAutoAdjustRedEye
kCIImageAutoAdjustFeatures
kCIImageAutoAdjustCrop
kCIImageAutoAdjustLevel
   adding crop rect: x=%.3f,y=%.3f,w=%.3f,h=%.3f
inputOrigI
inputOrigQ
inputStrength
inputWarmth
inputPoint2
inputPoint3
inputPoint4
iPad
DUMP_AUTO_ENHANCE_ARRAY
filters = %@
CIMeshGenerator
inputMesh
leftEyePosition
rightEyePosition
leftEyeTouchSize
leftEyeSize
rightEyeTouchSize
rightEyeSize
mouthPosition
mouthCenter
fullSizeImage
kIOSurfaceWidth
kIOSurfaceHeight
kIOSurfaceBytesPerRow
kIOSurfaceBytesPerElement
kIOSurfaceElementWidth
kIOSurfaceElementHeight
kIOSurfaceClientAddress
kIOSurfaceAllocSize
kIOSurfacePlaneInfo
kIOSurfacePlaneWidth
kIOSurfacePlaneHeight
kIOSurfacePlaneBytesPerRow
kIOSurfacePlaneBytesPerElement
kIOSurfacePlaneElementWidth
kIOSurfacePlaneElementHeight
kIOSurfacePlaneOffset
kIOSurfacePlaneSize
kIOSurfacePixelFormat
kIOSurfaceCacheMode
kIOSurfaceYCbCrMatrix
kIOSurfaceYCbCrMatrix_ITU_R_709_2_String
kIOSurfaceYCbCrMatrix_ITU_R_601_4_String
kIOSurfaceYCbCrMatrix_SMPTE_240M_1995_String
<IOSurface %p refcnt=%d>
com.apple.surface.isolationqueue
CI_TRASH_SURFACES_ON_SETVOLATILE
profileType
description
gammaR
gammaG
gammaB
phosphorRx
phosphorRy
phosphorGx
phosphorGy
phosphorBx
phosphorBy
whitePointx
whitePointy
copyright
displayRGB
HDTV
Composite NTSC
Composite PAL
HDTV Interim Color Implementation
Digital Cinema P3
D65 P3
QuickTime 'nclc' Video (%d,%d,%d)
Copyright 2007 Apple Inc.
rTRC
gTRC
bTRC
.png
.jpg
providerGetBytesAtPositionCallback_HtoF_surface
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/misc/Surface.c
info
buffer
providerGetBytesAtPositionCallback_2C08_surface
providerGetBytesAtPositionCallback_YCbYCr_surface
providerGetBytesAtPositionCallback_CbYCrY_surface
providerGetBytesAtPositionCallback_YCbYCrFull_surface
providerGetBytesAtPositionCallback_CbYCrYFull_surface
providerGetBytesAtPositionCallback_2C0h_surface
providerGetBytesAtPositionCallback_2C0f_surface
providerGetBytesAtPositionCallback_1C08_surface
providerGetBytesAtPositionCallback_A008_surface
providerGetBytesAtPositionCallback_1C0f_surface
providerGetBytesAtPositionCallback_1C0h_surface
providerGetBytePointerCallback
providerReleaseBytePointerCallback
undefined
CILinearToSRGBToneCurve
CIRedEyeCorrections %lu
{CGRect={CGPoint=ff}{CGSize=ff}}20@?0{CGRect={CGPoint=ff}{CGSize=ff}}4
CISRGBToneCurveToLinear
T@"CIImage",&,N,VinputImage
inputCameraModel
T@"NSString",C,N,VinputCameraModel
inputCorrectionInfo
T@"NSDictionary",C,N,VinputCorrectionInfo
CIRedEyeCorrection
x = %.5f, y = %.5f, width = %.5f, height = %.5f, alpha = 0.0244, density = 0.86, strength = 0.0757, redBias = 0.253, pupilSize = 0.50, pupilDarkenAmount = 0.75
http://ns.apple.com/adjustment-settings/1.0/
size
%@ %@ %@
%@ %@ %@ %@
pupilShadeLow
pupilShadeMedium
pupilShadeHigh
pupilShadeAverage
interocularDistance
%@ %@
snappedX
snappedY
bitmaskX
bitmaskY
bitmaskThreshold
cornealReflectionX
cornealReflectionY
cornealReflectionThreshold
existingPupilLow
existingPupilMedium
existingPupilHigh
existingPupilAverage
averageSkinLuminance
searchRectangleMinimumY
searchRectangleMaximumY
searchRectangleMinimumX
searchRectangleMaximumX
repairRectangleMinimumY
repairRectangleMaximumY
repairRectangleMinimumX
repairRectangleMaximumX
forceCase
pupilShadeAlignment
finalEyeCase
RedEyeW
fullImageWidth
RedEyeH
fullImageHeight
RedEyeISV
imageSpecialValue
RedEyeOrt
imageOrientation
RedEyeSNR
imageSignalToNoiseRatio
RedEyeModel
%@ %@ %@ %@ %@ %@
%@ %@ %@ %@ %@
http://ns.apple.com/adjustment-settings/1.0/sType/redeye
RedEyeCorrections
http://ns.adobe.com/camera-raw-settings/1.0/
RedEyeInfo
http://ns.apple.com/adjustment-settings/1.0/sType/red-eye
T@"NSArray",C,N,VinputCorrectionInfo
vImageConvert_Planar16FtoPlanar8 error %zi in CIRedEyeCorrection
Unknown input pixel format in CIRedEyeCorrection %i
vImageConvert_Planar8toPlanar16F error %zi in CIRedEyeCorrection
Unknown output pixel format in CIRedEyeCorrection %i
red-eye repair dictionary is of unknown type
kernel vec4 _convolutionAdd_1(sampler src, sampler sums, vec2 offset1, float weight1) 
 vec4 sum = sample(sums, samplerCoord(sums)); 
 vec2 coord = destCoord(); 
 vec4 pix1 = sample(src, samplerTransform(src, coord + offset1)); 
 return sum + pix1 * weight1; 
kernel vec4 _convolutionAdd_2(sampler src, sampler sums, vec2 offset1, vec2 offset2, vec2 weight1) 
 vec4 sum = sample(sums, samplerCoord(sums)); 
 vec2 coord = destCoord(); 
 vec4 pix1 = sample(src, samplerTransform(src, coord + offset1)); 
 vec4 pix2 = sample(src, samplerTransform(src, coord + offset2)); 
 return sum + pix1 * weight1.x + pix2 * weight1.y; 
kernel vec4 _convolutionAdd_3(sampler src, sampler sums, vec2 offset1, vec2 offset2, vec2 offset3, vec3 weight1) 
 vec4 sum = sample(sums, samplerCoord(sums)); 
 vec2 coord = destCoord(); 
 vec4 pix1 = sample(src, samplerTransform(src, coord + offset1)); 
 vec4 pix2 = sample(src, samplerTransform(src, coord + offset2)); 
 vec4 pix3 = sample(src, samplerTransform(src, coord + offset3)); 
 return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z; 
kernel vec4 _convolutionAdd_4(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec4 weight1) 
 vec4 sum = sample(sums, samplerCoord(sums)); 
 vec2 coord = destCoord(); 
 vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy)); 
 vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw)); 
 vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy)); 
 vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw)); 
 return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w; 
kernel vec4 _convolutionAdd_5(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec2 offset5, vec4 weight1, float weight2) 
 vec4 sum = sample(sums, samplerCoord(sums)); 
 vec2 coord = destCoord(); 
 vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy)); 
 vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw)); 
 vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy)); 
 vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw)); 
 vec4 pix5 = sample(src, samplerTransform(src, coord + offset5)); 
 return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w + pix5 * weight2; 
kernel vec4 _convolutionAdd_6(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec4 offset56, vec4 weight1, vec2 weight2) 
 vec4 sum = sample(sums, samplerCoord(sums)); 
 vec2 coord = destCoord(); 
 vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy)); 
 vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw)); 
 vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy)); 
 vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw)); 
 vec4 pix5 = sample(src, samplerTransform(src, coord + offset56.xy)); 
 vec4 pix6 = sample(src, samplerTransform(src, coord + offset56.zw)); 
 return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w + pix5 * weight2.x + pix6 * weight2.y; 
kernel vec4 _convolutionAdd_7(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec4 offset56, vec2 offset7, vec4 weight1, vec3 weight2) 
 vec4 sum = sample(sums, samplerCoord(sums)); 
 vec2 coord = destCoord(); 
 vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy)); 
 vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw)); 
 vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy)); 
 vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw)); 
 vec4 pix5 = sample(src, samplerTransform(src, coord + offset56.xy)); 
 vec4 pix6 = sample(src, samplerTransform(src, coord + offset56.zw)); 
 vec4 pix7 = sample(src, samplerTransform(src, coord + offset7)); 
 return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w + pix5 * weight2.x + pix6 * weight2.y + pix7 * weight2.z; 
kernel vec4 _convolutionAdd_8(sampler src, sampler sums, vec4 offset12, vec4 offset34, vec4 offset56, vec4 offset78, vec4 weight1, vec4 weight2) 
 vec4 sum = sample(sums, samplerCoord(sums)); 
 vec2 coord = destCoord(); 
 vec4 pix1 = sample(src, samplerTransform(src, coord + offset12.xy)); 
 vec4 pix2 = sample(src, samplerTransform(src, coord + offset12.zw)); 
 vec4 pix3 = sample(src, samplerTransform(src, coord + offset34.xy)); 
 vec4 pix4 = sample(src, samplerTransform(src, coord + offset34.zw)); 
 vec4 pix5 = sample(src, samplerTransform(src, coord + offset56.xy)); 
 vec4 pix6 = sample(src, samplerTransform(src, coord + offset56.zw)); 
 vec4 pix7 = sample(src, samplerTransform(src, coord + offset78.xy)); 
 vec4 pix8 = sample(src, samplerTransform(src, coord + offset78.zw)); 
 return sum + pix1 * weight1.x + pix2 * weight1.y + pix3 * weight1.z + pix4 * weight1.w + pix5 * weight2.x + pix6 * weight2.y + pix7 * weight2.z + pix8 * weight2.w; 
inputRingAmount
inputRingSize
inputSoftness
inputPointCount
down
conv3
conv5
conv7
add4
add8and8
add4and8
add8
CIConvolution3X3
CIConvolution5X5
CIConvolution7X7
add4and4
kernel vec4 _downhalf (sampler i) 
 vec2 dc = destCoord() * 2.0; 
 vec4 s = sample(i, samplerTransform(i,dc+vec2(-1.,0.))); 
 s += sample(i, samplerTransform(i,dc+vec2(1.,0.))); 
 s += sample(i, samplerTransform(i,dc+vec2(0.,1.))); 
 s += sample(i, samplerTransform(i,dc+vec2(0.,-1.))); 
 return s * 0.25; 
kernel vec4 _box3 (sampler image, float r) 
 vec4 rr = vec4(-r,0.0,r,0.0); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += sample(image, samplerTransform(image,dc+rr.xx)); 
 c += sample(image, samplerTransform(image,dc+rr.xy)); 
 c += sample(image, samplerTransform(image,dc+rr.xz)); 
 c += sample(image, samplerTransform(image,dc+rr.yx)); 
 c += sample(image, samplerTransform(image,dc+rr.yy)); 
 c += sample(image, samplerTransform(image,dc+rr.yz)); 
 c += sample(image, samplerTransform(image,dc+rr.zx)); 
 c += sample(image, samplerTransform(image,dc+rr.zy)); 
 c += sample(image, samplerTransform(image,dc+rr.zz)); 
 return c / 9.0; 
kernel vec4 _add4 (sampler a, sampler b, vec2 pt, vec2 w) 
 vec4 p = vec4(pt,-pt); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c *= w.y; 
 c += sample(a, samplerCoord(a)) * w.x; 
 return c; 
kernel vec4 _add8 (sampler a, sampler b, vec2 pt, vec2 w) 
 vec4 p = vec4(pt,-pt); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 c *= w.y; 
 c += sample(a, samplerCoord(a)) * w.x; 
 return c; 
kernel vec4 _add4and4 (sampler a, sampler b, vec4 pt, vec4 w) 
 vec4 p = vec4(pt.xy,-pt.xy); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += (sample(b, samplerTransform(b,dc+p.xy)) + sample(b, samplerTransform(b,dc+p.yz)) + sample(b, samplerTransform(b,dc+p.zw)) + sample(b, samplerTransform(b,dc+p.wx))) * w.y; 
 p = vec4(pt.zw,-pt.zw); 
 c += (sample(b, samplerTransform(b,dc+p.xy)) + sample(b, samplerTransform(b,dc+p.yz)) + sample(b, samplerTransform(b,dc+p.zw)) + sample(b, samplerTransform(b,dc+p.wx))) * w.z; 
 c += sample(a, samplerCoord(a)) * w.x; 
 return c; 
kernel vec4 _add4and8 (sampler a, sampler b, vec4 pt, vec4 w) 
 vec4 p = vec4(pt.xy,-pt.xy); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += (sample(b, samplerTransform(b,dc+p.xy)) + sample(b, samplerTransform(b,dc+p.yz)) + sample(b, samplerTransform(b,dc+p.zw)) + sample(b, samplerTransform(b,dc+p.wx))) * w.y; 
 p = vec4(pt.zw,-pt.zw); 
 c += (sample(b, samplerTransform(b,dc+p.xy)) + sample(b, samplerTransform(b,dc+p.yz)) + sample(b, samplerTransform(b,dc+p.zw)) + sample(b, samplerTransform(b,dc+p.wx)) + sample(b, samplerTransform(b,dc+p.yx)) + sample(b, samplerTransform(b,dc+p.zy)) + sample(b, samplerTransform(b,dc+p.wz)) + sample(b, samplerTransform(b,dc+p.xw))) * w.z; 
 c += sample(a, samplerCoord(a)) * w.x; 
 return c; 
kernel vec4 _add8and8 (sampler a, sampler b, vec4 pt, vec4 w) 
 vec4 p = vec4(pt.xy,-pt.xy); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += (sample(b, samplerTransform(b,dc+p.xy)) + sample(b, samplerTransform(b,dc+p.yz)) + sample(b, samplerTransform(b,dc+p.zw)) + sample(b, samplerTransform(b,dc+p.wx)) + sample(b, samplerTransform(b,dc+p.yx)) + sample(b, samplerTransform(b,dc+p.zy)) + sample(b, samplerTransform(b,dc+p.wz)) + sample(b, samplerTransform(b,dc+p.xw))) * w.y; 
 p = vec4(pt.zw,-pt.zw); 
 c += (sample(b, samplerTransform(b,dc+p.xy)) + sample(b, samplerTransform(b,dc+p.yz)) + sample(b, samplerTransform(b,dc+p.zw)) + sample(b, samplerTransform(b,dc+p.wx)) + sample(b, samplerTransform(b,dc+p.yx)) + sample(b, samplerTransform(b,dc+p.zy)) + sample(b, samplerTransform(b,dc+p.wz)) + sample(b, samplerTransform(b,dc+p.xw))) * w.z; 
 c += sample(a, samplerCoord(a)) * w.x; 
 return c; 
kernel vec4 _ringAvg8 (sampler b, vec4 pts) 
 vec4 p = vec4(pts.xy,-pts.xy); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 return c / 8.0; 
kernel vec4 _ringAvg16 (sampler b, vec4 pts) 
 vec4 p = vec4(pts.xy,-pts.xy); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 p = vec4(pts.zw,-pts.zw); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 return c / 16.0; 
kernel vec4 _ringAvg24 (sampler b, vec4 pts, vec2 pts2) 
 vec4 p = vec4(pts.xy,-pts.xy); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 p = vec4(pts.zw,-pts.zw); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 p = vec4(pts2.xy,-pts2.xy); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 return c / 24.0; 
kernel vec4 _ringAvg32 (sampler b, vec4 pts, vec4 pts2) 
 vec4 p = vec4(pts.xy,-pts.xy); 
 vec2 dc = destCoord(); 
 vec4 c = vec4(0.0); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 p = vec4(pts.zw,-pts.zw); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 p = vec4(pts2.xy,-pts2.xy); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 p = vec4(pts2.zw,-pts2.zw); 
 c += sample(b, samplerTransform(b,dc+p.xy)); 
 c += sample(b, samplerTransform(b,dc+p.yz)); 
 c += sample(b, samplerTransform(b,dc+p.zw)); 
 c += sample(b, samplerTransform(b,dc+p.wx)); 
 c += sample(b, samplerTransform(b,dc+p.yx)); 
 c += sample(b, samplerTransform(b,dc+p.zy)); 
 c += sample(b, samplerTransform(b,dc+p.wz)); 
 c += sample(b, samplerTransform(b,dc+p.xw)); 
 return c / 32.0; 
convert_identity
convert_rgb8_to_rgba8
convert_rgb16_to_rgba16
convert_rgbh_to_rgbah
convert_rgbf_to_rgbaf
convert_rgbah_to_rgba16
convert_rgba16_to_rgbah
convert_rgbah_to_rgbaf
convert_rgbaf_to_rgbah
convert_rgb16_to_rgbah
convert_rgbf_to_rgbah
convert_r8_to_rh
convert_rh_to_r8
convert_r8_to_rf
convert_rf_to_r8
convert_rh_to_rf
convert_rf_to_rh
convert_rgbah_to_rh
convert_rh_to_rgbah
convert_rgbaf_to_rf
convert_rf_to_rgbaf
unknown-conversion
v8@?0L4
size = %d, center = %d, %d, I = %g, Q = %g
Ti,R,Vsize
Ti,R,VcenterX
Ti,R,VcenterY
Td,R,VI
Td,R,VQ
kernel vec2 _droste(vec2 center, vec2 r, float logScale, vec2 rotzoom, vec2 innerSizeHalved) 
 vec2 c = destCoord() - center; 
 float theta = atan(c.y, c.x) + rotzoom.x; 
 vec2 polar = vec2(0.5 * log(dot(c,c)), theta); 
 vec2 rotated = vec2( polar.x * r.x - polar.y * r.y, dot(polar, r.yx)); 
 vec2 coord = exp(rotated.x) * cossin(rotated.y); 
 coord *= rotzoom.y; 
 float d0 = max(abs(coord.x)/innerSizeHalved.x, 
 abs(coord.y)/innerSizeHalved.y); 
 float myMod; { 
 float a = log(d0); 
 float b = logScale; 
 myMod = a - b*floor(a/b); 
 float d1 = exp(myMod); 
 coord *= ( d1 / d0 ); 
 return coord + center; 
inputInsetPoint0
inputInsetPoint1
inputPeriodicity
inputStrands
inputRotation
inputZoom
-[CIRenderDestination init]
internal CI render destination is invalid.
internal CI image is invalid.
internal CI context is invalid.
-[CIRenderDestination initWithPixelBuffer:]
-[CIRenderDestination initWithWidth:height:pixelFormat:colorSpace:pixelBufferProvider:]
-[CIRenderDestination initWithGLTexture:target:width:height:]
-[CIRenderDestination initWithBitmapData:width:height:bytesPerRow:format:]
-[CIRenderDestination setAlphaMode:]
-[CIRenderDestination setColorSpace:]
-[CIRenderDestination setBlendKernel:]
 (%@)
<%@: %p%@ format: %s size: %ux%u
    alphaMode: None
    alphaMode: Premultiplied
    alphaMode: Unpremultiplied
    blendKernel: %@
    blendsInDestinationColorSpace: %d
    flipped: %d
    dithered: %d
    clamped: %d
width
TI,R
height
alphaMode
flipped
TB,GisFlipped
dithered
TB,GisDithered
clamped
TB,GisClamped
T^{CGColorSpace=},N
blendKernel
T@"CIBlendKernel",&,N
blendsInDestinationColorSpace
-[CIRenderInfo init]
<%@: %p>{
kernelExecutionTime: %.5f ms 
passCount: %ld 
pixelsProcessed: %ld 
kernelExecutionTime
Td,R
passCount
pixelsProcessed
-[CIRenderTask init]
CIRenderTaskWaitUntilCompleted
Unexpected error in the backing renderer.
-[CIRenderTask waitUntilCompletedAndReturnError:]
CIContextStartTask
The CIContext is invalid.
-[CIContext(CIRenderDestination) _startTaskToRender:toDestination:forPrepareRender:error:]
The destination is nil.
The destination is invalid.
The image extent and destination extent do not intersect.
CIContextRenderDestination
kernel vec4 _destDither (__sample c, __sample n, float amount) 
 float nn = (n.r + n.g + n.b + n.a)*0.25 - 0.5; 
 c.rgb = clamp(c.rgb + amount*nn, vec3(0.0), vec3(1.0)); 
 return c; 
CIRandomGenerator
bytes
green
blue
alpha
bounds
faceBalanceEnabled
TB,VfaceBalanceEnabled
vibranceEnabled
TB,VvibranceEnabled
curvesEnabled
TB,VcurvesEnabled
shadowsEnabled
TB,VshadowsEnabled
kernel vec4 _curve16 (__sample s, sampler2D curveImage, vec2 normalizer) 
 s.rgb = normalizer.x * s.rgb + normalizer.y; 
 vec2 v = texture2D(curveImage, vec2(s.r , 0.5)).rg; 
 s.r = 0.9961089494 * v.r + 0.0038910506 * v.g; 
 v = texture2D(curveImage, vec2(s.g, 0.5)).rg; 
 s.g = 0.9961089494 * v.r + 0.0038910506 * v.g; 
 v = texture2D(curveImage, vec2(s.b, 0.5)).rg; 
 s.b = 0.9961089494 * v.r + 0.0038910506 * v.g; 
 return s; 
%d, %d
Curve0x
Curve0y
Curve1x
Curve1y
Curve2x
Curve2y
Curve3x
Curve3y
Curve4x
Curve4y
ToneCurve
ToneCurveName
Custom
T@"CIVector",C,N,VinputPoint0
T@"CIVector",C,N,VinputPoint1
T@"CIVector",C,N,VinputPoint2
T@"CIVector",C,N,VinputPoint3
T@"CIVector",C,N,VinputPoint4
CIFilterAddedNotification
CIConstructorKey
CIAccordionFoldTransition
CIAdditionCompositing
CIAffineClamp
CIAffineTile
CIAppleSmithGossettScale
CIASG50Percent
CIASG60Percent
CIASG66Percent
CIASG75Percent
CIASG80Percent
CIAreaMaximumAlpha
CIAreaMinimumAlpha
CIAreaMinMax
CIAreaMinMaxNormalize
CIAreaMinMaxRedNormalize
CIAreaRedRadialCentroid
CIBicubicScaleTransform
CIRowAverage
CIBarsSwipeTransition
CIBlendWithMask
CIBlendWithRedMask
CIBlendWithBlueMask
CIBlendWithAlphaMask
CIBloom
CIBokehBlur
CIBumpDistortion
CIBumpDistortionLinear
CICheapBilateral
CICheatBlur
CICheapBlur
CICheapMorphology
CICheckerboardGenerator
CICircleGenerator
CICircleSplashDistortion
CICircularScreen
CICircularWrap
CIClamp
CICMYKHalftone
CIColorBalance
CIColorBlendMode
CIColorBurnBlendMode
CIColorClamp
CIColorCrossPolynomial
CIColorCube
CIColorCubesMixedWithMask
CIColorDodgeBlendMode
CIColorInvert
CIColorMap
CIColorMonochrome
CIColorPolynomial
CIColorPosterize
CIComicEffect
CIConstantColorGenerator
CIContrastEnhancer
CIConvolution9Horizontal
CIConvolution9Vertical
CICopyMachineTransition
CICrystallize
CIDarkenBlendMode
CIDepthBlurEffect
CIDepthEffectApplyBlurMap
CIDepthEffectMakeBlurMap
CIDepthOfField
CIDepthToDisparity
CIDesaturateShadows
CIDifferenceBlendMode
CIDisintegrateWithMaskTransition
CIDisparityRefinement
CIDisparityToDepth
CIDisplacementDistortion
CIDissolveTransition
CIDither
CIDivideBlendMode
CIDotScreen
CIDroste
CIEdges
CIEdgePreserveUpsampleFilter
CIEdgeWork
CIEightfoldReflectedTile
CIExclusionBlendMode
CIFalseColor
CIFlashTransition
CIFourfoldReflectedTile
CIFourfoldRotatedTile
CIFourfoldTranslatedTile
CIGammaAdjust
CIGaussianBlurXY
CIGaussianGradient
CIGlideReflectedTile
CIGloom
CIGlassDistortion
CIGlassLozenge
CIGuidedFilter
CIHardLightBlendMode
CIHardMixBlendMode
CIHatchedScreen
CIHeightFieldFromMask
CIHexagonalPixellate
CIHistogramDisplayFilter
CIHoleDistortion
CIHueAdjust
CIHueBlendMode
CIHueSaturationValueGradient
CISampleNearest
CIIntegralImage
CIKaleidoscope
CILabDeltaE
CILenticularHaloGenerator
CILightTunnel
CILightenBlendMode
CILinearLightBlendMode
CILineScreen
CILinearBurnBlendMode
CILinearDodgeBlendMode
CILineOverlay
CILuminosityBlendMode
CIMaskToAlpha
CIMaximumComponent
CIMaximumCompositing
CIMedianFilter
CIMinimumComponent
CIMinimumCompositing
CIMirror
CIMix
CIModTransition
CIMorphologyMinimum
CIMorphologyMaximum
CIMorphologyGradient
CIMorphologyLaplacian
CIMotionBlur
CIMultiplyBlendMode
CIMultiplyCompositing
CINinePartStretched
CINinePartTiled
CINoiseReduction
CIOpacity
CIOpTile
CIOverlayBlendMode
CIPaperWash
CIDocumentEnhancer
CIPageCurlTransition
CIPageCurlWithShadowTransition
CIParallelogramTile
CIPercentileRed
CIPerspectiveTile
CIPerspectiveTransform
CIPerspectiveTransformWithExtent
CIPerspectiveCorrection
CIPhotoEffectNoir
CIPhotoEffectChrome
CIPhotoEffectFade
CIPhotoEffectInstant
CIPhotoEffectMono
CIPhotoEffectProcess
CIPhotoEffectTonal
CIPhotoEffectTransfer
CIPinLightBlendMode
CIPinchDistortion
CIPixellate
CIPointillize
CIPremultiply
CIProSharpenEdges
CIPseudoMedian
CIRadialGradient
CIRectangleGenerator
CIRippleTransition
CIRingBlur
CISaturationBlendMode
CIScreenBlendMode
CISepiaTone
CIShadedMaterial
CISharpenLuminance
CISimpleTile
CISixfoldReflectedTile
CISixfoldRotatedTile
CISkyAndGrassAdjust
CISmartColorFilter
CISmartToneFilter
CISmoothLinearGradient
CISpotColor
CISpotLight
CISoftLightBlendMode
CISourceAtopCompositing
CISourceInCompositing
CISourceOutCompositing
CIStarShineGenerator
CIStraightenFilter
CIStretch
CIStretchCrop
CIStripesGenerator
CISubtractBlendMode
CISunbeamsGenerator
CISwipeTransition
CITemperatureAndTint
CIThermal
CITorusLensDistortion
CITriangleKaleidoscope
CITriangleTile
CITwelvefoldReflectedTile
CITwirlDistortion
CIUnpremultiply
CIVariableBoxBlur
CIVignette
CIVignetteEffect
CIVividLightBlendMode
CIVortexDistortion
CIWhitePointAdjust
CIWrapMirror
CIXRay
CIZoomBlur
CUIScaleClampFilter
CUIOuterBevelEmbossFilter
CUIOuterGlowOrShadowFilter
CUIInnerBevelEmbossFilter
CUIInnerGlowOrShadowFilter
CUIShapeEffectBlur1
CIPlusDarkerCompositing
CIPlusLighterCompositing
CIMaskedVariableBlur
CISmartBlackAndWhite
CIPhotoGrain
CITextImageGenerator
CIAttributedTextImageGenerator
CIMattingSolver
CIFocalPlane
CICameraCalibrationLensCorrection
v8@?0@"NSString"4
[CIFilter registerFilterName:constructor:classAttributes:] needs a name parameter.
[CIFilter registerFilterName:constructor:classAttributes:] registration of '%@' should provide a contructor object or class.
[CIFilter registerFilterName:constructor:classAttributes:] registration of '%@' should not provide a contructor class that is just [CIFilter class].
filterWithName:
[CIFilter registerFilterName:constructor:classAttributes:] registration of '%@' needs a constructor object or class that implements filterWithName:
[CIFilter registerFilterName:constructor:classAttributes:] registration of '%@' needs a constructor object or class that overrides filterWithName:
Categories
.description
Descriptions
%s [constructor filterWithName:%@] returned nil.
+[CIFilter(CIFilterRegistryPrivate) filterWithName:setDefaults:]
%s [constructor filterWithName:%@] returned an object of class %@.
+[CIFilter(CIFilterRegistryPrivate) filterWithName:setDefaults:]_block_invoke
http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/%@
Keys
<none>
%@.%@.description
input
output
<%@: inputKeys=%@ inputClasses=%@ outputKeys=%@>
CI_FILTERS_DIR
/CoreImage
cifilter
CIFilterList
The filter '%@' in %@ has already been registered so this bundle will be ignored.
The filter '%@' in the bundle at %@ has already been registered.
The filter '%@' is not implemented in the bundle at %@.
The filter '%@' in the bundle at %@ is not a subclass of CIFilter so it will not be registered.
com.apple.coreimage.CIFilterRegistryIsolation
customAttributes
%@ -customAttributes is not supported on iOS. Implement +customAttributes instead.
iIsSlLqQBfdcC
NSObject
kernel vec4 _highlightsAndShadows2(__sample pix, __sample blur, vec4 params)
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max( 0.001, pix.r + pix.g + pix.b); 
  float shadAmt = params.x * pow(min(rgbFactor, 1.0), 1.0-params.x); 
  vec3 shadExp = mix(pow(vec3(2.0), (-shadAmt - blur.rgb)), vec3(1.0), params.z); 
  float blurLum2 = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(blurLum2); 
  float kGain = 0.5 + 0.5*smoothstep(0.5, 1.0, params.x); 
  float newGain = shadAmt; 
  vec3 neg = min(pix.rgb, 0.0); 
  vec3 shad = (1.0+newGain)*pow(max(pix.rgb, 0.0)*kGain, shadExp)*2.0; 
  vec3 ycc = pix.r * vec3(0.299, 0.596, 0.212) + 
             pix.g * vec3(0.587, -0.2755, -0.523) + 
             pix.b * vec3(0.114, -0.321, 0.311); 
  float Y = pow(max(ycc.r, 0.0)*kGain, shadExp.r)*2.0; 
  vec3 shad2 = Y * vec3(1.00048, 0.999864, 0.999446) + 
           ycc.g * vec3(0.955558, -0.271545, -1.10803) + 
           ycc.b * vec3(0.619549, -0.646786, 1.70542); 
  shad = mix(shad, shad2, 0.35); 
  shad = mix(pix.rgb, shad, (smoothstep(0.0, 0.1+shadAmt, sqrt(blurLum)))); 
  shad = mix(shad, pix.rgb, blurLum); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  Y = dot(high, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float kHighMix = 1.0 + (1.0-min(1.0, params.y+0.3))*0.4; 
  vec3 mid = mix(vec3(0.25), high, kHighMix); 
  float highBoost = min(effectAmount, 30.0*blurLum2) * (1.0-params.y); 
  high = mix(high, mid, highBoost); 
  high = mix(pix.rgb, high, smoothstep(0.2, 0.8, blurLum)); 
  high = mix(pix.rgb, high, blurLum2); 
  vec4 result; 
  result.rgb = mix(shad, high, min(blurLum, 1.0)); 
  Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float midAmt = abs(shadAmt)*0.1*(1.0-params.z); 
  mid = mix(vec3(0.5), result.rgb, 1.0 + midAmt); 
  result.rgb = mix(result.rgb, mid, min(effectAmount, 30.0*blurLum2)); 
  result.rgb = max(result.rgb, 0.0)+neg; 
  result.a = pix.a; 
  return result; 
kernel vec4 _highlightsAndShadows_noblur2(__sample pix, vec4 params)
  vec4 blur = pix; 
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max( 0.001, pix.r + pix.g + pix.b); 
  float shadAmt = params.x * pow(min(rgbFactor, 1.0), 1.0-params.x); 
  vec3 shadExp = mix(pow(vec3(2.0), (-shadAmt - blur.rgb)), vec3(1.0), params.z); 
  float blurLum2 = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(blurLum2); 
  float kGain = 0.5 + 0.5*smoothstep(0.5, 1.0, params.x); 
  float newGain = shadAmt; 
  vec3 neg = min(pix.rgb, 0.0); 
  vec3 shad = (1.0+newGain)*pow(max(pix.rgb, 0.0)*kGain, shadExp)*2.0; 
  vec3 ycc = pix.r * vec3(0.299, 0.596, 0.212) + 
             pix.g * vec3(0.587, -0.2755, -0.523) + 
             pix.b * vec3(0.114, -0.321, 0.311); 
  float Y = sign(ycc.r)*pow(abs(ycc.r)*kGain, shadExp.r)*2.0; 
  vec3 shad2 = Y * vec3(1.00048, 0.999864, 0.999446) + 
           ycc.g * vec3(0.955558, -0.271545, -1.10803) + 
           ycc.b * vec3(0.619549, -0.646786, 1.70542); 
  shad = mix(shad, shad2, 0.35); 
  shad = mix(pix.rgb, shad, (smoothstep(0.0, 0.1+shadAmt, sqrt(blurLum)))); 
  shad = mix(shad, pix.rgb, blurLum); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  Y = dot(high, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float kHighMix = 1.0 + (1.0-min(1.0, params.y+0.3))*0.4; 
  vec3 mid = mix(vec3(0.25), high, kHighMix); 
  float highBoost = min(effectAmount, 30.0*blurLum2) * (1.0-params.y); 
  high = mix(high, mid, highBoost); 
  high = mix(pix.rgb, high, smoothstep(0.2, 0.8, blurLum)); 
  high = mix(pix.rgb, high, blurLum2); 
  vec4 result; 
  result.rgb = mix(shad, high, min(blurLum, 1.0)); 
  Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float midAmt = abs(shadAmt)*0.1*(1.0-params.z); 
  mid = mix(vec3(0.5), result.rgb, 1.0 + midAmt); 
  result.rgb = mix(result.rgb, mid, min(effectAmount, 30.0*blurLum2)); 
  result.rgb = max(result.rgb, 0.0)+neg; 
  result.a = pix.a; 
  return result; 
kernel vec4 _highlightsAndShadows1(__sample pix, __sample blur, vec4 params)
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max( 0.001, pix.r + pix.g + pix.b); 
  float shadAmt = params.x * pow(min(rgbFactor, 1.0), 1.0-params.x); 
  vec3 shadExp = mix(pow(vec3(2.0), (-shadAmt - blur.rgb)), vec3(1.0), params.z); 
  float blurLum2 = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(blurLum2); 
  float kGain = 0.5 + 0.5*smoothstep(0.5, 1.0, params.x); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*kGain, shadExp)*2.0; 
  vec3 ycc = pix.r * vec3(0.299, 0.596, 0.212) + 
             pix.g * vec3(0.587, -0.2755, -0.523) + 
             pix.b * vec3(0.114, -0.321, 0.311); 
  float Y = sign(ycc.r)*pow(abs(ycc.r)*kGain, shadExp.r)*2.0; 
  vec3 shad2 = Y * vec3(1.00048, 0.999864, 0.999446) + 
           ycc.g * vec3(0.955558, -0.271545, -1.10803) + 
           ycc.b * vec3(0.619549, -0.646786, 1.70542); 
  shad = mix(shad, shad2, 0.35); 
  shad = mix(pix.rgb, shad, sqrt(smoothstep(0.0, 0.1+shadAmt, sqrt(blurLum)))); 
  shad = mix(shad, pix.rgb, blurLum); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  Y = dot(high, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float kHighMix = 1.0 + (1.0-min(1.0, params.y+0.3))*0.4; 
  vec3 mid = mix(vec3(0.25), high, kHighMix); 
  float highBoost = min(effectAmount, 30.0*blurLum2) * (1.0-params.y); 
  high = mix(high, mid, highBoost); 
  high = mix(pix.rgb, high, smoothstep(0.2, 0.8, blurLum)); 
  high = mix(pix.rgb, high, blurLum2); 
  vec4 result; 
  result.rgb = mix(shad, high, min(blurLum, 1.0)); 
  Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float midAmt = abs(shadAmt)*0.1*(1.0-params.z); 
  mid = mix(vec3(0.5), result.rgb, 1.0 + midAmt); 
  result.rgb = mix(result.rgb, mid, min(effectAmount, 30.0*blurLum2)); 
  result.a = pix.a; 
  return result; 
kernel vec4 _highlightsAndShadows_noblur1(__sample pix, vec4 params)
  vec4 blur = pix; 
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max( 0.001, pix.r + pix.g + pix.b); 
  float shadAmt = params.x * pow(min(rgbFactor, 1.0), 1.0-params.x); 
  vec3 shadExp = mix(pow(vec3(2.0), (-shadAmt - blur.rgb)), vec3(1.0), params.z); 
  float blurLum2 = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(blurLum2); 
  float kGain = 0.5 + 0.5*smoothstep(0.5, 1.0, params.x); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*kGain, shadExp)*2.0; 
  vec3 ycc = pix.r * vec3(0.299, 0.596, 0.212) + 
             pix.g * vec3(0.587, -0.2755, -0.523) + 
             pix.b * vec3(0.114, -0.321, 0.311); 
  float Y = sign(ycc.r)*pow(abs(ycc.r)*kGain, shadExp.r)*2.0; 
  vec3 shad2 = Y * vec3(1.00048, 0.999864, 0.999446) + 
           ycc.g * vec3(0.955558, -0.271545, -1.10803) + 
           ycc.b * vec3(0.619549, -0.646786, 1.70542); 
  shad = mix(shad, shad2, 0.35); 
  shad = mix(pix.rgb, shad, sqrt(smoothstep(0.0, 0.1+shadAmt, sqrt(blurLum)))); 
  shad = mix(shad, pix.rgb, blurLum); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  Y = dot(high, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float kHighMix = 1.0 + (1.0-min(1.0, params.y+0.3))*0.4; 
  vec3 mid = mix(vec3(0.25), high, kHighMix); 
  float highBoost = min(effectAmount, 30.0*blurLum2) * (1.0-params.y); 
  high = mix(high, mid, highBoost); 
  high = mix(pix.rgb, high, smoothstep(0.2, 0.8, blurLum)); 
  high = mix(pix.rgb, high, blurLum2); 
  vec4 result; 
  result.rgb = mix(shad, high, min(blurLum, 1.0)); 
  Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  float midAmt = abs(shadAmt)*0.1*(1.0-params.z); 
  mid = mix(vec3(0.5), result.rgb, 1.0 + midAmt); 
  result.rgb = mix(result.rgb, mid, min(effectAmount, 30.0*blurLum2)); 
  result.a = pix.a; 
  return result; 
kernel vec4 _highlightsAndShadows0(__sample pix, __sample blur, vec4 params)
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max(0.001, pix.r + pix.g + pix.b); 
  rgbFactor = clamp(rgbFactor, 0.0, 1.0); 
  float shadAmt = params.x * pow(rgbFactor, max(0.0,(1.0-params.x))); 
  vec3 clamped = clamp(pix.rgb, 0.00001, 0.99999); 
  float gray = (clamped.r + clamped.g + clamped.b) * 0.33333; 
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  float rgbsat = max((clamped.r - gray) * gii, (gray - clamped.r) * gi); 
  float skin = min(1.0, max(0.0, min(clamped.r - clamped.g, clamped.g * 2.0 - clamped.b)) * 4.0 * (1.0 - rgbsat) * gi); 
  skin = 0.15 + skin * 0.7; 
  vec3 rgbExp = pow(vec3(2.0), (-shadAmt - blur.rgb)); 
  float uniformExp = min(rgbExp.r, min(rgbExp.g, rgbExp.b)); 
  vec3 shadExp = mix(rgbExp, vec3(uniformExp), skin); 
  float nopMix = params.z; 
  shadExp = mix(shadExp, vec3(1.0, 1.0, 1.0), nopMix); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*0.5, shadExp)*2.0; 
  float maxChan = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(maxChan); 
  float origPercent = sqrt( smoothstep(0.0, 0.1 + 0.5*shadAmt*shadAmt, blurLum) ); 
  origPercent *= (1.0-origPercent); 
  shad = mix(shad, pix.rgb, origPercent); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  origPercent = 1.0 - smoothstep(0.2, 0.8, blurLum); 
  high = mix(high, pix.rgb, origPercent); 
  vec4 result; 
  result.rgb = mix(shad, high, blurLum); 
  float Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  vec3 mid = mix(vec3(0.5), result.rgb, 1.0 + abs(shadAmt)*0.05); 
  result.rgb = mix(result.rgb, mid.rgb, min(effectAmount, 30.0*blurLum*blurLum)); 
  result.a = pix.a; 
  return result;
kernel vec4 _highlightsAndShadows_noblur0(__sample pix, vec4 params)
  vec4 blur = pix; 
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max(0.001, pix.r + pix.g + pix.b); 
  rgbFactor = clamp(rgbFactor, 0.0, 1.0); 
  float shadAmt = params.x * pow(rgbFactor, max(0.0,(1.0-params.x))); 
  vec3 clamped = clamp(pix.rgb, 0.00001, 0.99999); 
  float gray = (clamped.r + clamped.g + clamped.b) * 0.33333; 
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  float rgbsat = max((clamped.r - gray) * gii, (gray - clamped.r) * gi); 
  float skin = min(1.0, max(0.0, min(clamped.r - clamped.g, clamped.g * 2.0 - clamped.b)) * 4.0 * (1.0 - rgbsat) * gi); 
  skin = 0.15 + skin * 0.7; 
  vec3 rgbExp = pow(vec3(2.0), (-shadAmt - blur.rgb)); 
  float uniformExp = min(rgbExp.r, min(rgbExp.g, rgbExp.b)); 
  vec3 shadExp = mix(rgbExp, vec3(uniformExp), skin); 
  float nopMix = params.z; 
  shadExp = mix(shadExp, vec3(1.0, 1.0, 1.0), nopMix); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*0.5, shadExp)*2.0; 
  float maxChan = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(maxChan); 
  float origPercent = sqrt( smoothstep(0.0, 0.1 + 0.5*shadAmt*shadAmt, blurLum) ); 
  origPercent *= (1.0-origPercent); 
  shad = mix(shad, pix.rgb, origPercent); 
  vec3 high = sign(pix.rgb)*pow(abs(pix.rgb)*params.w, vec3((2.0 - params.y))); 
  origPercent = 1.0 - smoothstep(0.2, 0.8, blurLum); 
  high = mix(high, pix.rgb, origPercent); 
  vec4 result; 
  result.rgb = mix(shad, high, blurLum); 
  float Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  vec3 mid = mix(vec3(0.5), result.rgb, 1.0 + abs(shadAmt)*0.05); 
  result.rgb = mix(result.rgb, mid.rgb, min(effectAmount, 30.0*blurLum*blurLum)); 
  result.a = pix.a; 
  return result;
kernel vec4 _shadows_noblur(__sample pix, vec4 params)
  vec4 blur = pix; 
  float rgbFactor = dot(vec3(1.0, 0.8, 1.1), max(pix.rgb, 0.0)) / max(0.001, pix.r + pix.g + pix.b); 
  rgbFactor = clamp(rgbFactor, 0.0, 1.0); 
  float shadAmt = params.x * pow(rgbFactor, max(0.0,(1.0-params.x))); 
  vec3 clamped = clamp(pix.rgb, 0.00001, 0.99999); 
  float gray = (clamped.r + clamped.g + clamped.b) * 0.33333; 
  float gi   = 1.0 / gray;
  float gii  = 1.0 / (1.0 - gray);
  float rgbsat = max((clamped.r - gray) * gii, (gray - clamped.r) * gi); 
  float skin = min(1.0, max(0.0, min(clamped.r - clamped.g, clamped.g * 2.0 - clamped.b)) * 4.0 * (1.0 - rgbsat) * gi); 
  skin = 0.15 + skin * 0.7; 
  vec3 rgbExp = pow(vec3(2.0), (-shadAmt - blur.rgb)); 
  float uniformExp = min(rgbExp.r, min(rgbExp.g, rgbExp.b)); 
  vec3 shadExp = mix(rgbExp, vec3(uniformExp), skin); 
  float nopMix = params.z; 
  shadExp = mix(shadExp, vec3(1.0, 1.0, 1.0), nopMix); 
  vec3 shad = sign(pix.rgb)*pow(abs(pix.rgb)*0.5, shadExp)*2.0; 
  float maxChan = max(0.0, max(max(blur.r, blur.g), blur.b)); 
  float blurLum = sqrt(maxChan); 
  float origPercent = sqrt( smoothstep(0.0, 0.1 + 0.5*shadAmt*shadAmt, blurLum) ); 
  origPercent *= (1.0-origPercent); 
  shad = mix(shad, pix.rgb, origPercent); 
  vec4 result; 
  result.rgb = mix(shad, pix.rgb, blurLum); 
  float Y = dot(result.rgb, vec3(0.299, 0.587, 0.114)); 
  float effectAmount = max(max(-2.6*Y*Y - 2.6*Y + 0.98, -6.25*Y*Y - 6.25*Y + 0.5965), 1.0); 
  vec3 mid = mix(vec3(0.5), result.rgb, 1.0 + abs(shadAmt)*0.05); 
  result.rgb = mix(result.rgb, mid.rgb, min(effectAmount, 30.0*blurLum*blurLum)); 
  result.a = pix.a; 
  return result;
Shadows
Highlights
FillLight
T@"NSNumber",&,N,VinputShadowAmount
T@"NSNumber",&,N,VinputHighlightAmount
context
T@"CIContext",&,N,Vcontext
kernel vec4 _rippleTransition (sampler src1, sampler src2, sampler emap, vec2 center, vec4 parms, vec2 emapscaling) 
 vec2 dest = destCoord(); 
 vec2 delta = dest - center; 
 float delta_length = length(delta); 
 vec2 unit = delta / delta_length; 
 float scaled = (delta_length - parms.x) * parms.y; 
 vec4 normalized_radius = vec4(scaled * parms.z) + vec4(-0.0, -1.0, -2.0, -3.0); 
 vec4 smoothed = smoothstep(0.0, 1.0, clamp(normalized_radius.xyzy, 0.0, 1.0)); 
 vec4 cubic = smoothed * vec4(1.0, -2.0, 1.0, 1.0) + vec4(0.0, 1.0, -1.0, 0.0); 
 smoothed = compare(vec4(normalized_radius.x), vec4(0.0), vec4(cubic.x)); 
 smoothed = compare(vec4(normalized_radius.y), smoothed, vec4(cubic.y)); 
 smoothed = compare(vec4(normalized_radius.z), smoothed, vec4(cubic.z)); 
 normalized_radius = compare(vec4(normalized_radius.w), vec4(smoothed), vec4(0.0)); 
 vec2 displacement = normalized_radius.xy * unit; 
 vec2 location = displacement * parms.w + dest; 
 vec2 emap_location = (displacement * 0.5 + 0.5) * emapscaling; 
 vec4 pix1 = sample(src1, samplerTransform(src1, location)); 
 vec4 pix2 = sample(src2, samplerTransform(src2, location)); 
 vec4 emap_pix = sample(emap, samplerTransform(emap, emap_location)); 
 vec4 tmp = mix(pix2, pix1, cubic.w); 
 emap_pix *= tmp.a; 
 tmp = tmp * (1.0 - emap_pix.a) + emap_pix; 
 return tmp; 
10.12
integral_image_manual
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/CIIntegralImage.mm
input.region.size.width == output.region.size.width
input.region.size.height == output.region.size.height
compute_integral_image
don't know how to create builtin kernel for type %d
_ci_affine
float2 _ci_affine(float4 vx, float4 vy)
  float4 d = float4(destCoord(), 1.0, 0.0);
  return float2(dot(d,vx),dot(d,vy));
_ci_crop
vec4 _ci_crop(vec4 p, float4 rect)
  highp float4 x = destCoord().xxyy * float4(1.0, -1.0, 1.0, -1.0) + rect;
  x = clamp(min(x, x.yzwx), float4(0.0), float4(1.0));
  return (x.x * x.z) * p;
rect
_ci_clamp_rect
float2 _ci_clamp_rect(float4 r) { return min(max(destCoord(), r.xy), r.zw); }
_ci_srgb_to_lin
vec4 _ci_srgb_to_lin(vec4 s)
  s.rgb = srgb_to_linear(s.rgb);
  return s;
_ci_lin_to_srgb
vec4 _ci_lin_to_srgb(vec4 s)
  s.rgb = linear_to_srgb(s.rgb);
  return s;
_ci_premul
vec4 _ci_premul(vec4 s) { return premultiply(s); }
_ci_unpremul
vec4 _ci_unpremul(vec4 s) { return unpremultiply(s); }
_ci_clamp_to_alpha
vec4 _ci_clamp_to_alpha(vec4 s) { return clamp(s, 0.0, s.a); }
_ci_nearest
float2 _ci_nearest() { return (floor((destCoord())) + 0.5); }
_ci_pass_thru
vec4 _ci_pass_thru (vec4 s) { return s; }
_ci_fill
vec4 _ci_fill(vec4 c) {return c;}
_ci_gamma
vec4 _ci_gamma(vec4 s, float power)
  s.rgb = pow(max(vec3(0.0), s.rgb), vec3(power));
  return s;
power
_ci_sqr
vec4 _ci_sqr(vec4 s)
  s.rgb = max(vec3(0.0), s.rgb);
  s.rgb *= s.rgb;
  return s;
_ci_pow4
vec4 _ci_pow4(vec4 s)
  s.rgb = max(vec3(0.0), s.rgb);
  s.rgb = s.rgb * s.rgb * s.rgb * s.rgb;
  return s;
_ci_sqrt
vec4 _ci_sqrt(vec4 s)
  s.rgb = sqrt(max(vec3(0.0), s.rgb));
  return s;
_ci_curv
vec4 _ci_curv(vec4 s, vec4 p0, vec3 p1)
  float power = p0.x; 
  float a = p0.y, b = p0.z, c = p0.w; 
  float d = p1.x, e = p1.y, f = p1.z; 
  vec3 hi = pow(max(vec3(0.0), s.rgb * a + b), vec3(power)) + e; 
  vec3 lo = s.rgb * c + f; 
  s.rgb = mix(lo, hi, step(vec3(d), s.rgb));
  return s;}
_ci_colormatrix_canonical
vec4 _ci_colormatrix_canonical (vec4 s, vec4 r0, vec4 r1, vec4 r2) 
  s = unpremultiply(s);
  s.rgb = vec3(dot(s,r0), dot(s,r1), dot(s,r2)); 
  return premultiply(s);
_ci_colormatrix
vec4 _ci_colormatrix (vec4 s, vec4 c0, vec4 c1, vec4 c2, vec4 c3, vec4 bias) 
  s = unpremultiply(s);
  s = s.r*c0 + s.g*c1 + s.b*c2 + s.a*c3 + bias;
  return premultiply(s);
_ci_colormatrix3x4
vec4 _ci_colormatrix3x4 (vec4 s, vec4 c0, vec4 c1, vec4 c2) 
{ s.rgb = s.r*c0.rgb + s.g*c1.rgb + s.b*c2.rgb + s.a*vec3(c0.a,c1.a,c2.a); return s; }
_ci_colormatrix3x3
vec4 _ci_colormatrix3x3 (vec4 s, vec3 col0, vec3 col1, vec3 col2)
  s.rgb = s.r*col0 + s.g*col1 + s.b*col2;
  return s;
col0
col1
col2
_ci_colormatrix3x1
vec4 _ci_colormatrix3x1 (vec4 s, vec3 v) { return vec4(vec3(dot(s.rgb, v)), s.a); }
_ci_colormatrix_rrra
vec4 _ci_colormatrix_rrra(vec4 s) { return s.rrra; }
_ci_colormatrixdiag
vec4 _ci_colormatrixdiag (vec4 s, vec3 diag) 
  s.rgb *= diag;
  return s;
diag
_ci_colormatrixdiag4
vec4 _ci_colormatrixdiag4 (vec4 s, vec4 diag) 
  return s * diag;
_ci_aaaa
vec4 _ci_aaaa (vec4 s) { return s.aaaa; }
_ci_rrrr
vec4 _ci_rrrr (vec4 s) { return s.rrrr; }
_ci_000r
vec4 _ci_000r (vec4 s) { return vec4(0.,0.,0.,s.r); }
_ci_rrr1
vec4 _ci_rrr1 (vec4 s) { return vec4(s.rrr,1.); }
_ci_r001
vec4 _ci_r001 (vec4 s) { return vec4(s.r,0.,0.,1.); }
_ci_rg01
vec4 _ci_rg01 (vec4 s) { return vec4(s.rg,0.,1.); }
_ci_a001
vec4 _ci_a001 (vec4 s) { return vec4(s.a,0.,0.,1.); }
_ci_aaa1
vec4 _ci_aaa1 (vec4 s) { return vec4(s.www,1.); }
_ci_rrrg
vec4 _ci_rrrg (vec4 s) { return s.rrrg; }
_ci_bgra
vec4 _ci_bgra (vec4 s) { return s.bgra; }
_ci_abgr
vec4 _ci_abgr (vec4 s) { return s.abgr; }
_ci_gbra
vec4 _ci_gbra (vec4 s) { return s.gbra; }
_ci_grab
vec4 _ci_grab (vec4 s) { return s.grab; }
_ci_gbar
vec4 _ci_gbar (vec4 s) { return s.gbar; }
_ci_argb
vec4 _ci_argb (vec4 s) { return s.argb; }
_ci_gra1
vec4 _ci_gra1 (vec4 s) { s = s.grab; s.a = 1.0; return s; }
_ci_arg1
vec4 _ci_arg1 (vec4 s) { s = s.argb; s.a = 1.0; return s; }
_ci_rgb1
vec4 _ci_rgb1 (vec4 s) { return vec4(s.rgb, 1.0); }
_ci_bgr1
vec4 _ci_bgr1 (vec4 s) { return vec4(s.bgr, 1.0); }
_ci_1rgb
vec4 _ci_1rgb (vec4 s) { return vec4(1.0, s.rgb); }
_ci_1bgr
vec4 _ci_1bgr (vec4 s) { return vec4(1.0, s.bgr); }
_ci_rg_to_rr1
vec4 _ci_rg_to_rr1(vec4 s) { return vec4((s.g*256.0+s.r)/257.0, 0.0, 0.0, 1.0); }
_ci_rg_to_ll1
vec4 _ci_rg_to_ll1(vec4 s) { return vec4(vec3((s.g*256.0+s.r)/257.0), 1.0); }
_ci_rg_to_a
vec4 _ci_rg_to_a(vec4 s) { return vec4(0.0, 0.0, 0.0, (s.g*256.0+s.r)/257.0); }
_ci_rg_to_i
vec4 _ci_rg_to_i(vec4 s) { return vec4((s.g*256.0+s.r)/257.0); }
_ci_la_to_rr1
vec4 _ci_la_to_rr1(vec4 s) { return vec4((s.a*256.0+s.r)/257.0, 0.0, 0.0, 1.0); }
_ci_la_to_ll1
vec4 _ci_la_to_ll1(vec4 s) { return vec4(vec3((s.a*256.0+s.r)/257.0), 1.0); }
_ci_la_to_a
vec4 _ci_la_to_a(vec4 s) { return vec4(0.0, 0.0, 0.0, (s.a*256.0+s.r)/257.0); }
_ci_la_to_i
vec4 _ci_la_to_i(vec4 s) { return vec4((s.a*256.0+s.r)/257.0); }
_ci_rgba_to_rrgg1
vec4 _ci_rgba_to_rrgg1(vec4 s) { return vec4((s.g*256.0+s.r)/257.0, (s.a*256.0+s.b)/257.0, 0.0, 1.0); }
_ci_rgba_to_llaa
vec4 _ci_rgba_to_llaa(vec4 s) { return vec4(vec3((s.g*256.0+s.r)/257.0), (s.a*256.0+s.b)/257.0); }
_ci_to_r16_as_rg8
vec4 _ci_to_r16_as_rg8(vec4 s) 
  float r = s.r*65535.0; 
  float rL = mod(r,256.0); 
  float rH = (r-rL)/256.0; 
  return vec4(rL,rH,0.0,1.0)/255.0; 
_ci_to_l16_as_rg8
vec4 _ci_to_l16_as_rg8(vec4 s) 
  const vec4 gray = vec4(0.299, 0.587, 0.114, 0.0); 
  float l = dot(s,gray)*65535.0; 
  float lL = mod(l,256.0); 
  float lH = (l-lL)/256.0; 
  return vec4(lL,lH,0.0,1.0)/255.0; 
_ci_to_a16_as_rg8
vec4 _ci_to_a16_as_rg8(vec4 s) 
  float a = s.a*65535.0; 
  float aL = mod(a,256.0); 
  float aH = (a-aL)/256.0; 
  return vec4(aL,aH,0.0,1.0)/255.0; 
_ci_to_rg16_as_rgba8
vec4 _ci_to_rg16_as_rgba8(vec4 s) 
  float r = s.r*65535.0; 
  float rL = mod(r,256.0); 
  float rH = (r-rL)/256.0; 
  float g = s.g*65535.0; 
  float gL = mod(g,256.0); 
  float gH = (g-gL)/256.0; 
  return vec4(rL,rH,gL,gH)/255.0; 
_ci_to_rg16_as_bgra8
vec4 _ci_to_rg16_as_bgra8(vec4 s) 
  float r = s.r*65535.0; 
  float rL = mod(r,256.0); 
  float rH = (r-rL)/256.0; 
  float g = s.g*65535.0; 
  float gL = mod(g,256.0); 
  float gH = (g-gL)/256.0; 
  return vec4(gL,rH,rL,gH)/255.0; 
_ci_to_la16_as_rgba8
vec4 _ci_to_la16_as_rgba8(vec4 s) 
  const vec4 gray = vec4(0.299, 0.587, 0.114, 0.0); 
  float l = dot(s,gray)*65535.0; 
  float lL = mod(l,256.0); 
  float lH = (l-lL)/256.0; 
  float a = s.a*65535.0; 
  float aL = mod(a,256.0); 
  float aH = (a-aL)/256.0; 
  return vec4(lL,lH,aL,aH)/255.0; 
_ci_to_la16_as_bgra8
vec4 _ci_to_la16_as_bgra8(vec4 s) 
  const vec4 gray = vec4(0.299, 0.587, 0.114, 0.0); 
  float l = dot(s,gray)*65535.0; 
  float lL = mod(l,256.0); 
  float lH = (l-lL)/256.0; 
  float a = s.a*65535.0; 
  float aL = mod(a,256.0); 
  float aH = (a-aL)/256.0; 
  return vec4(aL,lH,lL,aH)/255.0; 
_ci_rg_to_cbycry
vec4 _ci_rg_to_cbycry(sampler s) 
  vec4 c = sample(s,samplerCoord(s)); 
  float col = step(0.5, fract(destCoord().x * 0.5)); 
  float cOther = sample(s,samplerCoord(s) + float2(1.0-2.0*col,0.0)).r; 
  vec4 r0 = vec4(c.g, c.r, cOther, 1.0); 
  vec4 r1 = vec4(c.g, cOther, c.r, 1.0); 
  return mix(r0,r1,vec4(col)); 
_ci_rg_to_ycbycr
vec4 _ci_rg_to_ycbycr(sampler s) 
  vec4 c = sample(s,samplerCoord(s)); 
  float col = step(0.5, fract(destCoord().x * 0.5)); 
  float cOther = sample(s,samplerCoord(s) + float2(1.0-2.0*col,0.0)).g; 
  vec4 r0 = vec4(c.r, c.g, cOther, 1.0); 
  vec4 r1 = vec4(c.r, cOther, c.g, 1.0); 
  return mix(r0,r1,vec4(col)); 
_ci_to_YCbYCr_as_rg8
vec4 _ci_to_YCbYCr_as_rg8(vec4 s) 
  vec2 YCb = s.rg, YCr = s.rb; 
  float m = step(0.5, fract(destCoord().x * 0.5)); 
  return vec4(mix(YCb,YCr,vec2(m)),0.0,1.0); 
_ci_to_CbYCrY_as_rg8
vec4 _ci_to_CbYCrY_as_rg8(vec4 s) 
  vec2 CbY = s.gr, CrY = s.br; 
  float m = step(0.5, fract(destCoord().x * 0.5)); 
  return vec4(mix(CbY,CrY,vec2(m)),0.0,1.0); 
_ci_to_rgb_as_r
vec4 _ci_to_rgb_as_r (vec4 s)
  float2 rCoord = writeCoord() * float2(3,1);
  writeImage(s.rrrr, rCoord);
  float2 gCoord = rCoord + float2(1,0);
  writeImage(s.gggg, gCoord);
  float2 bCoord = rCoord + float2(2,0);
  writeImage(s.bbbb, bCoord);
  return s; 
_ci_to_a2bgr10_as_rgba8
vec4 _ci_to_a2bgr10_as_rgba8 (vec4 s)
  vec4 denorm = clamp(s,vec4(0.0),vec4(1.0)) * vec4(vec3(1023.0), 3.0) + 0.5;
  int pixel  = int(denorm.r);
      pixel |= int(denorm.g) << 10;
      pixel |= int(denorm.b) << 20;
      pixel |= int(denorm.a) << 30;
  writePixel((pixel) & 0xFF, (pixel >> 8) & 0xFF, (pixel >> 16) & 0xFF, (pixel >> 24) & 0xFF, writeCoord());
  return s; 
_ci_to_a2rgb10_as_rgba8
vec4 _ci_to_a2rgb10_as_rgba8 (vec4 s)
  vec4 denorm = clamp(s,vec4(0.0),vec4(1.0)) * vec4(vec3(1023.0), 3.0) + 0.5;
  int pixel  = int(denorm.b);
      pixel |= int(denorm.g) << 10;
      pixel |= int(denorm.r) << 20;
      pixel |= int(denorm.a) << 30;
  writePixel((pixel) & 0xFF, (pixel >> 8) & 0xFF, (pixel >> 16) & 0xFF, (pixel >> 24) & 0xFF, writeCoord());
  return s; 
_ci_to_rgb10wide_as_rgba8
vec4 _ci_to_rgb10wide_as_rgba8 (vec4 s)
  s = vec4(linear_to_srgb(s.rgb) * (511.0/1023.0) + (384.0/1023.0), 1.0);
  vec4 denorm = clamp(s,vec4(0.0),vec4(1.0)) * vec4(vec3(1023.0), 3.0) + 0.5;
  int pixel  = int(denorm.b);
      pixel |= int(denorm.g) << 10;
      pixel |= int(denorm.r) << 20;
      pixel |= int(denorm.a) << 30;
  writePixel((pixel) & 0xFF, (pixel >> 8) & 0xFF, (pixel >> 16) & 0xFF, (pixel >> 24) & 0xFF, writeCoord());
  return s; 
_ci_combine_420
vec4 _ci_combine_420(vec4 s00, vec4 s10, vec4 s01, vec4 s11)
  float2 pc = writeCoord();
  float2 py = pc * 2.0;
  writeImage(s00.rrrr, py);
  writeImage(s10.rrrr, py + float2(1,0));
  writeImage(s01.rrrr, py + float2(0,1));
  writeImage(s11.rrrr, py + float2(1,1));
  vec4 cc = (s00 + s10 + s01 + s11) * 0.25;
  writeImagePlane(vec4(cc.gb,0.0,0.0), pc);
  return s00; 
_ci_swizzle_to_444
vec4 _ci_swizzle_to_444(vec4 s)
  float2 pc = writeCoord();
  writeImage(vec4(s.r,0.0,0.0,1.0), pc);
  writeImagePlane(vec4(s.gb,0.0,1.0), pc);
  return s; 
_ci_swizzle_rgba8_to_a2rgb10
vec4 _ci_swizzle_rgba8_to_a2rgb10(vec4 s) 
  s = floor(s * 255.0 + 0.5); 
  vec4 r; 
  r.b = (mod(s.g,  4.0) * 256.0 + s.r)              / 1023.0; 
  r.g = (mod(s.b, 16.0) *  64.0 + floor(s.g/ 4.0))  / 1023.0; 
  r.r = (mod(s.a, 64.0) *  16.0 + floor(s.b/16.0))  / 1023.0; 
  r.a = floor(s.a/63.99999) / 3.0; 
  return r; 
_ci_swizzle_rgba8_to_rgb10_wide
vec4 _ci_swizzle_rgba8_to_rgb10_wide(vec4 s) 
  s = floor(s * 255.0 + 0.5); 
  vec4 r; 
  r.b = (mod(s.g,  4.0) * 256.0 + s.r)              / 1023.0; 
  r.g = (mod(s.b, 16.0) *  64.0 + floor(s.g/ 4.0))  / 1023.0; 
  r.r = (mod(s.a, 64.0) *  16.0 + floor(s.b/16.0))  / 1023.0; 
  r.a = 1.0; 
  r.rgb = srgb_to_linear((r.rgb - 384.0/1023.0) * (1023.0/511.0)); 
  return r; 
_ci_swizzle_rgba8_to_a2bgr10
vec4 _ci_swizzle_rgba8_to_a2bgr10(vec4 s) 
  s = floor(s * 255.0 + 0.5); 
  vec4 r; 
  r.r = (mod(s.g,  4.0) * 256.0 + s.r)              / 1023.0; 
  r.g = (mod(s.b, 16.0) *  64.0 + floor(s.g/ 4.0))  / 1023.0; 
  r.b = (mod(s.a, 64.0) *  16.0 + floor(s.b/16.0))  / 1023.0; 
  r.a = floor(s.a/63.99999) / 3.0; 
  return r; 
_ci_rgb10wide
vec4 _ci_rgb10wide(vec4 s) { return vec4(srgb_to_linear((s.rgb - 384.0/1023.0) * (1023.0/511.0)), 1.0); }
_ci_bgr10wide
vec4 _ci_bgr10wide(vec4 s) { return vec4(srgb_to_linear((s.bgr - 384.0/1023.0) * (1023.0/511.0)), 1.0); }
_ci_to_rgb10wide
vec4 _ci_to_rgb10wide(vec4 s) { return vec4(linear_to_srgb(s.rgb) * (511.0/1023.0) + (384.0/1023.0), 1.0); }
_ci_to_bgr10wide
vec4 _ci_to_bgr10wide(vec4 s) { return vec4(linear_to_srgb(s.bgr) * (511.0/1023.0) + (384.0/1023.0), 1.0); }
_ci_rgba16_normalize
vec4 _ci_rgba16_normalize(vec4 s) { return s / 65535.0; }
_ci_ra01
vec4 _ci_ra01(vec4 s) { return vec4(s.ra, 0.0, 1.0); }
_ci_ycc_to_rgb
vec4 _ci_ycc_to_rgb(vec4 s) { return s.zxyw; }
_ci_swizzle_to_laaa
vec4 _ci_swizzle_to_laaa(vec4 s) 
  const vec4 g = vec4(0.299, 0.587, 0.114, 0.0); 
  return vec4(dot(s,g), s.aaa); 
_ci_combine_gray
vec4 _ci_combine_gray(vec4 s0, vec4 s1, vec4 s2, vec4 s3) 
  vec4 g = vec4(0.299, 0.587, 0.114, 0.0); 
  return vec4(dot(s0,g), dot(s1,g), dot(s2,g), dot(s3,g)); 
_ci_combine_r
vec4 _ci_combine_r(vec4 s0, vec4 s1, vec4 s2, vec4 s3) { return vec4(s0.r, s1.r, s2.r, s3.r); }
_ci_combine_a
vec4 _ci_combine_a(vec4 s0, vec4 s1, vec4 s2, vec4 s3) { return vec4(s0.a, s1.a, s2.a, s3.a); }
_ci_combine_rg
vec4 _ci_combine_rg(vec4 s0, vec4 s1) { return vec4(s0.rg, s1.rg); }
_ci_combine_r16
vec4 _ci_combine_r16(vec4 s0, vec4 s1) 
  float v0 = s0.r*65535.0; 
  float v0L = mod(v0,256.0); 
  float v0H = (v0-v0L)/256.0; 
  float v1 = s1.r*65535.0; 
  float v1L = mod(v1,256.0); 
  float v1H = (v1-v1L)/256.0; 
  return vec4(v0L,v0H,v1L,v1H)/255.0; 
_ci_combine_a16
vec4 _ci_combine_a16(vec4 s0, vec4 s1) 
  float v0 = s0.a*65535.0; 
  float v0L = mod(v0,256.0); 
  float v0H = (v0-v0L)/256.0; 
  float v1 = s1.a*65535.0; 
  float v1L = mod(v1,256.0); 
  float v1H = (v1-v1L)/256.0; 
  return vec4(v0L,v0H,v1L,v1H)/255.0; 
_ci_combine_l16
vec4 _ci_combine_l16(vec4 s0, vec4 s1) 
  vec4 g = vec4(0.299, 0.587, 0.114, 0.0); 
  float v0 = dot(s0,g)*65535.0; 
  float v0L = mod(v0,256.0); 
  float v0H = (v0-v0L)/256.0; 
  float v1 = dot(s1,g)*65535.0; 
  float v1L = mod(v1,256.0); 
  float v1H = (v1-v1L)/256.0; 
  return vec4(v0L,v0H,v1L,v1H)/255.0; 
_ci_combine_la
vec4 _ci_combine_la(vec4 s0, vec4 s1) 
  vec4 g = vec4(0.299, 0.587, 0.114, 0.0); 
  return vec4(dot(s0,g), s0.a, dot(s1,g), s1.a);
True
False
TRUE
kernel vec4 _stripes (vec2 center, __color c0, __color c1, vec3 params) 
 float d0; 
 d0 = (destCoord() - center).x; 
 d0 = fract(d0 * params.x - .25); 
 d0 = min (1.0 - d0, d0); 
 d0 = clamp (d0 * params.y + params.z, 0.0, 1.0); 
 float d1 = (d0 * -2.0 + 3.0) * d0 * d0; 
 return mix(c1, c0, d1); 
kernel vec4 _sunbeams(sampler noise, vec4 centers, vec4 params, __color color) 
 float sunRadius2 = params.x; 
 float striationFactor = params.y; 
 float a = params.z; 
 float b = params.w; 
 vec2 v = destCoord() - centers.xy; 
 float len = length(v); 
 float len2 = dot(v,v); 
 vec2 noiseCtr = centers.zw; 
 vec2 noiseLoc = normalize(v) * 50.0 + noiseCtr; 
 vec4 npix = sample(noise, samplerTransform(noise, noiseLoc)); 
 float noiseAmount = npix.r * a + b; 
 float f2 = sunRadius2 / (len2+0.0001); 
 vec4 pix = f2 * color + noiseAmount; 
 return pix * clamp(1.0 - len * striationFactor, 0.0, 1.0); 
inputSunRadius
inputMaxStriationRadius
inputNeutralGamma
inputTone
inputHue
inputGrain
inputSeed
kernel vec4 _smartBlackAndWhite(__sample image, sampler2D hueImage, vec4 rgbWeights, vec4 normalizer)
    float scaleFactor = rgbWeights.w;
    float neutralGamma = normalizer.z;
    float phototone = normalizer.w;
    image = clamp(image, 0.0, 1.0);
    vec3 lms;
    lms.x = dot(image.rgb, vec3(0.3139902162, 0.6395129383, 0.0464975462));
    lms.y = dot(image.rgb, vec3(0.155372406, 0.7578944616, 0.0867014186));
    lms.z = dot(image.rgb, vec3(0.017752387, 0.109442094, 0.8725692246));
    lms = pow(lms, vec3(0.43));
    float i = dot(lms, vec3(0.4,0.4,0.2));
    float p = dot(lms, vec3(4.4550,-4.8510,0.3960));
    float t = dot(lms, vec3(0.8056,0.3572,-1.1628));
    float chroma = sqrt(p*p+t*t);
    float hue = 0.5 + (atan(t, p) / 6.28318530718); 
    vec2 huePt = vec2(hue * normalizer.x + normalizer.y, 0.5); 
    float exponent = scaleFactor * texture2D(hueImage, huePt).a; 
    float cd = 0.06 + 0.53*abs(i-0.5); 
    float lumDamp = smoothstep(0.0, 1.0, 25.0*i); 
    float x = smoothstep(0.0, 1.0, chroma/cd); 
    exponent = x*(1.0-i)*lumDamp*(exponent - 1.0) + 1.0; 
    float bw = dot(image.rgb, rgbWeights.rgb); 
    bw = pow(bw, exponent); 
    x = 1.0 - smoothstep(0.0, 1.0, chroma * 10.0); 
    float lumAdjust = bw*(1.0 - bw)*x*(neutralGamma - 1.0) + 1.0;
    lumAdjust = 5.0 - 4.0 * lumAdjust;
    bw = pow(bw, lumAdjust);
    float result = 1.8031*bw*bw*bw - 2.1972*bw*bw + 1.3823*bw;
    bw = mix(bw, result, -phototone);
    return vec4(bw,bw,bw,image.a);
inputISO
T@"NSNumber",C,N,VinputStrength
T@"NSNumber",C,N,VinputNeutralGamma
T@"NSNumber",C,N,VinputTone
T@"NSNumber",C,N,VinputHue
T@"NSNumber",C,N,VinputGrain
T@"NSNumber",C,N,VinputSeed
T@"NSNumber",C,N,VinputScaleFactor
There is no need to call smartBlackAndWhiteStatistics.
Just use [CIFilter filterWithName:@"CISmartBlackAndWhite"] instead.
There is no need to call smartBlackAndWhiteAdjustmentsForValue:andStatistics:.
kernel vec4 facebalance (__sample pix, vec2 delta) 
 pix.rgb = pix.r * vec3(0.299, 0.595716, 0.211456) + 
 pix.g * vec3(0.587, -0.274453, -0.522591) + 
 pix.b * vec3(0.114, -0.321263, 0.311135); 
 float chroma2 = min(1.0, 4.0*(pix.g*pix.g + pix.b*pix.b)); 
 pix.gb += delta * pow(chroma2,0.2) * (1.0-chroma2*chroma2); 
 pix.rgb = pix.r * vec3(1.0) + 
 pix.g * vec3(0.956296, -0.272122, -1.10699) + 
 pix.b * vec3(0.621024, -0.647381, 1.70461); 
 return pix; 
FaceBalanceOrigI
FaceBalanceOrigQ
FaceBalanceStrength
FaceBalanceWarmth
IncrementalTemperature
IncrementalTint
HasSettings
T@"NSNumber",&,N,VinputOrigI
T@"NSNumber",&,N,VinputOrigQ
T@"NSNumber",&,N,VinputStrength
T@"NSNumber",&,N,VinputWarmth
copySliceOfBitmapToBitmap: bytes per sample or samples per pixel differs!
copyBitmapToSliceOfBitmap: bytes per sample or samples per pixel differs!
bitmapToBitmapDifferenceBitmapRect: source pixel configuration illegal
initBitmask:b
initBitmask:b->body
initBitmask: bitmap record can not be allocated
initBitmask: bitmap body can not be allocated
termBitmask: bitmap was null
bitmaskAndBitmask: bitmasks have different shapes
bitmaskOrBitmask: bitmasks have different shapes
bitmaskMinus: bitmasks have different shapes
ConvertYCbCrtoREDEYEFORMAT: rowSamples is too small for CbCr bitmap
ConvertYCbCrtoREDEYEFORMAT: rowSamples is too small for Y bitmap
ConvertYCbCrtoREDEYEFORMAT: heights do not match
ConvertYCbCrtoREDEYEFORMAT: widths do not match
ConvertRedChannel5toY: rowSamples is too small for ARGB bitmap
ConvertRedChannel5toY: rowSamples is too small for CbCr bitmap
ConvertRedChannel5toY: rowSamples is too small for Y bitmap
ConvertRedChannel5toY: heights do not match
ConvertRedChannel5toY: widths do not match
ConvertRedChannel7toY: rowSamples is too small for ARGB bitmap
ConvertRedChannel7toY: rowSamples is too small for CbCr bitmap
ConvertRedChannel7toY: rowSamples is too small for Y bitmap
ConvertRedChannel7toY: heights do not match
ConvertRedChannel7toY: widths do not match
ConvertHuePurityRedtoY: rowSamples is too small for ARGB bitmap
ConvertHuePurityRedtoY: rowSamples is too small for CbCr bitmap
ConvertHuePurityRedtoY: rowSamples is too small for Y bitmap
ConvertHuePurityRedtoY: heights do not match
ConvertHuePurityRedtoY: widths do not match
ConvertHuePurityOrangetoY: rowSamples is too small for ARGB bitmap
ConvertHuePurityOrangetoY: rowSamples is too small for CbCr bitmap
ConvertHuePurityOrangetoY: rowSamples is too small for Y bitmap
ConvertHuePurityOrangetoY: heights do not match
ConvertHuePurityOrangetoY: widths do not match
ConvertHuePurityYellowtoY: rowSamples is too small for ARGB bitmap
ConvertHuePurityYellowtoY: rowSamples is too small for CbCr bitmap
ConvertHuePurityYellowtoY: rowSamples is too small for Y bitmap
ConvertHuePurityYellowtoY: heights do not match
ConvertHuePurityYellowtoY: widths do not match
ConvertRedChannel2toY: rowSamples is too small for ARGB bitmap
ConvertRedChannel2toY: rowSamples is too small for CbCr bitmap
ConvertRedChannel2toY: rowSamples is too small for Y bitmap
ConvertRedChannel2toY: heights do not match
ConvertRedChannel2toY: widths do not match
ConvertAmberChanneltoY8: rowSamples is too small for ARGB bitmap
ConvertAmberChanneltoY8: rowSamples is too small for CbCr bitmap
ConvertAmberChanneltoY8: rowSamples is too small for Y bitmap
ConvertAmberChanneltoY8: heights do not match
ConvertAmberChanneltoY8: widths do not match
extractAlpha:alphaMap
extractAlpha:savedscans
computePupilAlphaMap:allPoints
computePupilAlphaMap:alphaMap
blurBitmapHorizontal:scan
blurBitmapVertical:scan
infill area boundary path
specular bitmask outside path
infill arcs surround arcs
specular bitmask path outside arc bodies
specular bitmask path outside arcs
arcCorrelation: improper crossing pairing at f1 %.2f
%d crossings:
  [%2d] f2 %.2f pix %.2f 
arcInfill: improper crossing pairing at f1 %.2f
extractFirstGradientMaximumFrom:scanline
computeOutlineByTracingSnake:snakeBodies
computeOutlineByTracingSnake:points
winning snake = connection of snakes %d and %d
computeBitmask: connected pieces search failed
computeBitmask: seedFill failed
computeBitmask: centroid closest bit search failed
computeBitmask: can not allocate bitmask bm2
computeBitmask: can not allocate bitmask bm
recomputeBitmask: seedFill failed
recomputeBitmask: can not allocate bitmask bm2
recomputeBitmask: can not allocate bitmask bm
closestConnectedComponent: seedFill failed
closestConnectedComponent: centroid closest bit search failed
closestConnectedComponent: can not allocate bitmask bm3
closestConnectedComponent: can not allocate bitmask bm2
closestConnectedComponent: can not allocate bitmask bm
cornealReflectionBitmask: can not allocate bitmask bm2 intended for spread
determineOutsidePath: nowhere to go
determineOutsidePath: border pixel expected
determineOutsidePath: overflow
determineOutsidePath: unable to allocate path body
determineOutsidePath: isolated point
determineOutsidePath: no bits set
determineOutsidePath: unable to allocate path
determineArcsAtAngleForOutsidePath: too many arc bodies
determineArcsAtAngleForOutsidePath: too many arcs
determineArcsAtAngleForOutsidePath: unable to allocate arc bodies
determineArcsAtAngleForOutsidePath: unable to allocate arcs
arcCorrelation: no crossings at f1
arcCorrelation: odd number of crossings
arcCorrelation: too many crossings
arcInfill: no crossings at f1
arcInfill: odd number of crossings
arcInfill: too many crossings
error - impossible connect arrangement
incorrect number of points
examineAlpha: bitmaps don't match
examineAlpha: bitmaps are the wrong number of samples per pixel
examineBitmask: bitmaps don't match
examineBitmask: bitmaps are the wrong number of samples per pixel
allocSpanStack:s
allocSpanStack:s->firstChunk
pushSpan:s->stackHeadChunk->next
allocSpanStack: span stack could not be allocated
spanSearch: empty span
freeSpanStack: span stack is null
seedFill: can not push span onto stack
seedFill: can not allocate span stack
inputCrossScale
inputCrossAngle
inputCrossOpacity
inputCrossWidth
kernel vec4 _starshine(vec2 center, vec4 xyvec, vec4 parms, float widthrecip, __color color) 
 vec2 offset = destCoord() - center; 
 vec2 loc = vec2(dot(offset, xyvec.xy), dot(offset, xyvec.zw)); 
 float l = length(offset); 
 float rlen = parms.x / l; 
 loc = max(abs(loc) * widthrecip + parms.w, vec2(0.0000001)); 
 loc = abs(parms.x / loc); 
 loc = loc * loc * loc; 
 float f = loc.x * loc.y * parms.z; 
 float g = clamp(1.0 - l * parms.y, 0.0, 1.0); 
 return min(rlen * rlen * color + g * g * f, vec4(1.0)); 
T@"NSNumber",&,N,VinputCrossScale
T@"NSNumber",&,N,VinputCrossAngle
T@"NSNumber",&,N,VinputCrossOpacity
T@"NSNumber",&,N,VinputCrossWidth
T@"NSNumber",&,N,VinputEpsilon
frame
initWithExternalBuffer:size:rowBytes:f
initWithExternalBuffer:subRectange:fullSize:rowBytes:f
redEyeRemovalWithPoint:recognitionChannels[0]
redEyeRemovalWithPoint:recognitionChannels[1]
redEyeRemovalWithPoint:recognitionChannels[i]
redEyeRemovalWithPoint:table16
extractAverageFaceY: bigyhisto
redEyeRemovalWithData:recognitionChannel
surface=%p(%.3u)
 fmt=%.4s
 fmt=%ld
 x=%+.4lld y=%+.4lld w=%.4zu h=%.4zu surfaceWidth=%.4zu surfaceHeight=%.4zu ctx=%u img=%u vol=%d
 id='%s'
 id=nil
 size=%ld%s
 empty
 use=%ld
SurfaceCacheEntry 
GetSurfaceFromCacheAndFill was passed contextIndex=%d and imageIndex=%d.  Ignoring imageIndex.
GetValidSurfaceFromCache was passed contextIndex=%d and imageIndex=%d.  Ignoring imageIndex.
GetSurfaceFromCache was passed contextIndex=%d and imageIndex=%d.  Ignoring imageIndex.
AddReleaseSurfaceBlock_block_invoke
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/internal/surface-cache.cpp
CI::gReleaseSurfaceBlockMap().find(queue) == CI::gReleaseSurfaceBlockMap().end()
CISurfaceCacheQueue
v8@?0^{SurfaceCacheEntry=^^?{atomic<unsigned int>=AI}^^?^{__IOSurface}{IRect={IPoint=qq}{ISize=II}}II^{__CFString}I^{dispatch_queue_s}@?li}4
SurfaceCache:
  count: %ld
  size: %ld%s
  non-volatile: %ld%s
  volatile: %ld%s
  capacity: %ld%s
  cumulativeStats:
    peakCount=%ld peakSize=%ld%s peakNVSize=%ld%s totalAlloced=%ld%s totalFilled=%ld%s timeFilling=%gs
    hits=%ld (%lu%%)  purgedHits=%ld (%lu%%)  recycledMisses=%ld (%lu%%)  misses=%ld (%lu%%)  inusemisses=%ld (%lu%%)
useCountDecrement
_useCount > 0
inputPoint
kernel vec2 _mirror (vec2 center, vec3 tst, vec4 off, vec4 mtx) 
 float test = dot(tst.xy, destCoord()) + tst.z; 
 vec2 p = destCoord() - center; 
 p = (test < 0.0) ? p + off.xy : vec2(dot(p, mtx.xy), dot(p, mtx.zw)) + off.zw; 
 return p + center; 
T@"CIVector",&,N,VinputPoint
vec3 _toLab (vec3 rgb) 
 vec3 XYZ = vec3(dot(rgb, vec3(0.452350,0.399530,0.148409)), 
 dot(rgb, vec3(0.222488,0.716873,0.060608)), 
 dot(rgb, vec3(0.016868,0.117668,0.865571))); 
 XYZ = max(XYZ, vec3(0.0)); 
 XYZ = compare(XYZ - 0.008856, 7.787 * XYZ + 16.0 / 116.0, pow(XYZ,vec3(0.33333333))); 
 return vec3(116.0 * XYZ.y - 16.0, 500.0 * (XYZ.x - XYZ.y), 200.0 * (XYZ.y - XYZ.z)); 
 float _deltaE (vec3 lab1, vec3 lab2) 
 vec3 d = lab1 - lab2; 
 float dL = d.x; 
 float da = d.y; 
 float db = d.z; 
 float C1 = length(lab1.yz); 
 float C2 = length(lab2.yz); 
 float Cgmean = sqrt(C1*C2); 
 float dC = C1 - C2; 
 float dH2 = max(da*da + db*db - dC*dC, 0.0); 
 float K1 = 0.045; 
 float K2 = 0.015; 
 float Sc = 1.0 + K1*Cgmean; 
 float Sh = 1.0 + K2*Cgmean; 
 float Lv = dL; 
 float Cv = dC / Sc; 
 float Hv2 = dH2 / (Sh * Sh); 
 return sqrt(Lv*Lv + Cv*Cv + Hv2); 
 kernel vec4 _LabDeltaE (__sample c1, __sample c2) 
 vec4 c1overwhite = c1 + (1.0 - c1.a); 
 vec3 lab1w = _toLab(c1overwhite.rgb); 
 vec3 lab1b = _toLab(c1.rgb); 
 vec4 c2overwhite = c2 + (1.0 - c2.a); 
 vec3 lab2w = _toLab(c2overwhite.rgb); 
 vec3 lab2b = _toLab(c2.rgb); 
 float dE = max(_deltaE(lab1w, lab2w), _deltaE(lab1b, lab2b)); 
 return vec4(dE); 
inputImage2
T@"CIImage",&,N,VinputImage2
inputSize
inputDecay
kernel vec4 _triangleKaleidoscopeColor (__sample c, vec2 center, vec4 ftrans, float decay) 
 vec2 p = destCoord() - center; 
 p = vec2(dot(p, ftrans.xy), dot(p, ftrans.zw)); 
 highp vec3 z = vec3(1.0 + p.x - p.y, 2.0 - p.x - 2.0 * p.y, 2.0 - 2.0 * p.x - p.y); 
 z = abs(floor(z)); 
 float K = pow(decay, dot(z, vec3(1.0))); 
 c.rgb *= K; 
 return c; 
kernel vec2 _triangleKaleidoscopeGeom (vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 p = destCoord() - center; 
 p = vec2(dot(p, ftrans.xy), dot(p, ftrans.zw)); 
 p = fract(p); 
 p = (p.x > p.y) ? p.yx : p; 
 p.y = (p.y > 2.0 - p.x - p.y) ? (2.0 - p.x - p.y) : p.y; 
 p.x = (p.x < 1.0 - p.x - p.y) ? (1.0 - p.x - p.y) : p.x; 
 p = (p.x > p.y) ? p.yx : p; 
 p = vec2(dot(p, btrans.xy), dot(p, btrans.zw)); 
 p += center; 
 return p; 
T@"NSNumber",&,N,VinputSize
T@"NSNumber",&,N,VinputRotation
T@"NSNumber",&,N,VinputDecay
kernel vec4 _cheapBlur(sampler src, vec2 parms) 
 vec2 dc = destCoord(); 
 vec2 offA = parms * vec2(-1.0, 4.0); 
 vec2 offB = parms * vec2( 4.0, 1.0); 
 vec4 sul = sample(src, samplerTransform(src, dc + offA)); 
 vec4 sur = sample(src, samplerTransform(src, dc + offB)); 
 vec4 sdl = sample(src, samplerTransform(src, dc - offB)); 
 vec4 sdr = sample(src, samplerTransform(src, dc - offA)); 
 vec4 sc = sample(src, samplerCoord (src)); 
 return 0.181818181818182 * sc + 0.204545454545455 * (sur + sul + sdr + sdl); 
kernel vec4 _lerp(__sample src0, __sample src1, float factor) { return mix(src1, src0, factor); }
inputSampling
kernel vec2 _stretch (vec2 center, vec3 param) 
 vec2 g = vec2(1.0) - clamp(abs(destCoord() - center) * param.x, 0.0, 1.0); 
 g = (g * -2.0 + vec2(3.0)) * g * g; 
 g *= param.y * sin((destCoord() - center.yy) * param.z); 
 return destCoord() - g; 
T@"CIVector",&,N,VinputSize
kernel vec2 _lighttunnel (vec4 param) 
 vec2 p = destCoord() - param.xy; 
 float rlen = param.z * inversesqrt(dot(p,p)); 
 float angle = log(rlen) * param.w; 
 vec2 cs = vec2(cos(angle), sin(angle)); 
 p = vec2(dot(p, cs), dot(p, vec2(-cs.y, cs.x))); 
 p = p * rlen + param.xy; 
 p = mix(destCoord(), p, step(rlen, 1.0)); 
 return p; 
curve gamma=%g a=%g b=%g c=%g d=%g e=%g f=%g
curve
inputSpatialSigma
inputLumaSigma
kernel vec4 _jointBilateral (sampler small, sampler guide, vec4 parms) 
  vec2 dc = destCoord(); 
  vec2 smallCenter = samplerCoord(small); 
  vec2 guideCenter = samplerCoord(guide); 
  vec2 smallDelta = samplerTransform(small, dc+vec2(1.0)) - smallCenter; 
  vec2 guideDelta = samplerTransform(guide, dc+vec2(1.0)) - guideCenter; 
  vec4 I0 = sample(small, smallCenter); 
  float IE0 = sample(guide, guideCenter).r; 
  vec4 sumFGI = vec4(0.0); 
  float sumFG = 0.0; 
  float x,y; 
  float w=2.0; 
  for (x=-w;x<=w;x++) 
  { 
    for (y=-w;y<=w;y++) 
    { 
      vec2 xy = vec2(x,y) * parms.zw; 
      float G = exp(-(x*x+y*y)*parms.y); 
      vec4  I  = sample(small, smallCenter + xy*smallDelta); 
      float IE = sample(guide, guideCenter + xy*guideDelta).g; 
      float F = exp(-((IE - IE0)*(IE - IE0))*parms.x); 
      sumFG += F*G; 
      sumFGI += F*G*I; 
    } 
  } 
  return sumFG<0.001 ? I0 : sumFGI/sumFG; 
kernel vec4 _jointBilateralRG (sampler combo, vec4 parms) 
  vec2 dc = destCoord(); 
  vec2 comboCenter = samplerCoord(combo); 
  vec2 comboDelta = samplerTransform(combo, dc+vec2(1.0)) - comboCenter; 
  vec4  c = sample(combo, comboCenter); 
  vec2  I0 = c.zw; 
  float IE0 = c.r; 
  vec2 sumFGI = vec2(0.0); 
  float sumFG = 0.0; 
  float x,y; 
  float w=2.0; 
  for (x=-w;x<=w;x++) 
  { 
    for (y=-w;y<=w;y++) 
    { 
      vec2 xy = vec2(x,y) * parms.zw; 
      float G = exp(-(x*x+y*y)*parms.y); 
      vec4  c = sample(combo, comboCenter + xy*comboDelta); 
      vec2  I  = c.zw; 
      float IE = c.g; 
      float F = exp(-((IE - IE0)*(IE - IE0))*parms.x); 
      sumFG += F*G; 
      sumFGI += F*G*I; 
    } 
  } 
  return vec4(sumFG<0.001 ? I0 : sumFGI/sumFG, 0.0, 1.0); 
kernel vec4 _guideCombine (__sample g, __sample gb) __attribute__((outputFormat(kCIFormatRGh))) 
  return vec4(g.r, gb.r, 0.0, 1.0); 
kernel vec4 _guideCombine4 (__sample guide, __sample guideblurred, __sample map) 
  return vec4(guide.r, guideblurred.r, map.rg); 
kernel vec4 _guideMono (__sample g) __attribute__((outputFormat(kCIFormatRh))) 
  return vec4(clamp(dot(g.rgb, vec3(0.3333)),0.0,1.0), 0.0, 0.0, 1.0); 
inputSigmaX
inputSigmaY
inputSmallImage
T@"CIImage",&,N,VinputSmallImage
T@"NSNumber",&,N,VinputSpatialSigma
T@"NSNumber",&,N,VinputLumaSigma
+[CIFilter(CIRAWFilter) filterWithImageURL:options:]
inputEnableNoiseTracking
inputNoiseReductionAmount
inputEnableSharpening
inputEnableVendorLensCorrection
inputDisableGamutMap
inputLuminanceNoiseReductionAmount
inputColorNoiseReductionAmount
inputNoiseReductionSharpnessAmount
inputNoiseReductionContrastAmount
inputNoiseReductionDetailAmount
inputMoireAmount
inputBaselineExposure
inputBoost
inputBoostShadowAmount
inputNeutralChromaticityX
inputNeutralChromaticityY
inputNeutralTemperature
inputNeutralTint
inputNeutralLocation
inputIgnoreOrientation
inputImageOrientation
inputLinearSpaceFilter
inputDecoderVersion
supportedDecoderVersions
outputNativeSize
activeKeys
[CIDetector detectorOfType:context:options:] failed because type %@ is unkonw.
CIDetectorTypeFace
CIDetectorTypeRectangle
CIDetectorTypeQRCode
CIDetectorTypeText
CIDetectorAccuracy
CIDetectorAccuracyLow
CIDetectorAccuracyHigh
CIDetectorMinFeatureSize
CIDetectorMaxFeatureCount
CIDetectorTracking
CIDetectorNumberOfAngles
CIDetectorImageOrientation
CIDetectorBetterEyeLocs
CIDetectorEyeBlink
CIDetectorSmile
CIDetectorFocalLength
CIDetectorAspectRatio
CIDetectorDetectDiacritics
CIDetectorReturnSubFeatures
CITextDetectorMinimizeFalseDetections
CIDetectorExtraCharacters
CIDetectorLanguage
CIDetectorLanguageNone
CIDetectorLanguageASCII
CIDetectorLanguageEnglish
CIDetectorLanguageDanish
CIDetectorLanguageDutch
CIDetectorLanguageFrench
CIDetectorLanguageGerman
CIDetectorLanguageIcelandic
CIDetectorLanguageItalian
CIDetectorLanguageNorwegian
CIDetectorLanguagePortuguese
CIDetectorLanguageSpanish
CIDetectorLanguageSwedish
faceCoreDetector
T@"FCRFaceDetector",&,VfaceCoreDetector
type
T@"NSString",R,&
Face
Rectangle
QRCode
Text
landmarks
T@"NSDictionary",R,Vlandmarks
T{CGRect={CGPoint=ff}{CGSize=ff}},R,Vbounds
hasLeftEyePosition
TB,R,VhasLeftEyePosition
T{CGPoint=ff},R,VleftEyePosition
hasRightEyePosition
TB,R,VhasRightEyePosition
T{CGPoint=ff},R,VrightEyePosition
hasMouthPosition
TB,R,VhasMouthPosition
T{CGPoint=ff},R,VmouthPosition
hasTrackingID
TB,R,VhasTrackingID
trackingID
Ti,R,VtrackingID
hasTrackingFrameCount
TB,R,VhasTrackingFrameCount
trackingFrameCount
Ti,R,VtrackingFrameCount
hasFaceAngle
TB,R,VhasFaceAngle
faceAngle
Tf,R,VfaceAngle
hasSmile
TB,R,VhasSmile
leftEyeClosed
TB,R,VleftEyeClosed
rightEyeClosed
TB,R,VrightEyeClosed
topLeft
T{CGPoint=ff},R,VtopLeft
topRight
T{CGPoint=ff},R,VtopRight
bottomLeft
T{CGPoint=ff},R,VbottomLeft
bottomRight
T{CGPoint=ff},R,VbottomRight
messageString
symbolDescriptor
T@"CIQRCodeDescriptor",R,VsymbolDescriptor
T@"NSString",R,VmessageString
subFeatures
T@"NSArray",R,VsubFeatures
-[CIColor initWithRed:green:blue:alpha:colorSpace:]
%g %g %g %g
(%g %g %g %g) %@
UIColor
colorWithCIColor:
blackColor
T@"CIColor",R
whiteColor
grayColor
redColor
greenColor
blueColor
cyanColor
magentaColor
yellowColor
clearColor
numberOfComponents
components
Tr^f,R
inputSkyAmount
inputGrassAmount
kernel vec4 _grassAndSkyAdjust (__sample im, vec2 params) 
  float enhanceGrass = params.x; 
  float enhanceSky = params.y; 
  vec3 ipt, ipt2; 
  float range; 
  { 
    vec3 lms = im.r * vec3(0.3347, 0.1747, 0.0187) + 
               im.g * vec3(0.5984, 0.7151, 0.1018) + 
               im.b * vec3(0.0671, 0.1106, 0.8794); 
    lms = sign(lms)*pow(abs(lms), vec3(0.43)); 
    ipt = lms.r * vec3(0.4,  4.455,  0.8056) + 
          lms.g * vec3(0.4, -4.851,  0.3572) + 
          lms.b * vec3(0.2,  0.396,-1.1628); 
  } 
  float hue = atan((sqrt(ipt.b*ipt.b+ipt.g*ipt.g)-ipt.g)/ipt.b)/3.1416+0.5; 
  range = hue - 0.88; 
  float maskGrass = exp((-1.0*range*range)/(2.0*.088*.088)); 
  range = 1.0 - smoothstep(0.4, 0.5, ipt.r); 
  maskGrass *= range; 
  vec2 idealGrass = vec2(-0.03, 0.1); 
  vec2 toIdeal = idealGrass - ipt.gb; 
  float dist = sqrt(toIdeal.r*toIdeal.r+toIdeal.g*toIdeal.g); 
  float chroma2 = 4.0*(ipt.g*ipt.g + ipt.b*ipt.b); 
  float str = enhanceGrass*pow(chroma2, .2); 
  str = str*min(1.0, 1.0-chroma2*chroma2); 
  str = min(str, 1.5); 
  float scale = min(1.0, 0.1/(dist+0.05)); 
  ipt2.gb = ipt.gb + str*toIdeal*scale; 
  ipt2.gb *= enhanceGrass; 
  ipt2.r = ipt.r; 
  ipt = mix(ipt, ipt2.rgb, maskGrass); 
  float maskSky = smoothstep(0.2, 0.5, ipt.r); 
  range = ipt.g + .04; 
  maskSky *= exp((-1.0*range*range)/(2.0*0.15*0.15)); 
  range = ipt.b + 0.1; 
  maskSky *= exp((-1.0*range*range)/(2.0*0.2*0.2)); 
  { 
    vec3 lms = ipt.r * vec3(1.0000, 1.0000, 1.0000) + 
               ipt.g * vec3(0.0976,-0.1139, 0.0326) + 
               ipt.b * vec3(0.2052, 0.1332,-0.6769); 
    lms = sign(lms)*pow(abs(lms), vec3(1.0/.43)); 
    im.rgb = lms.r * vec3( 5.3089, -1.3026,  0.0381) + 
             lms.g * vec3(-4.4648,  2.5193, -0.1968) + 
             lms.b * vec3( 0.1564, -0.2175,  1.1590); 
  } 
  im.rgb = max(im.rgb, 0.0); 
  float gain = max(1.0, 1.0 + enhanceSky); 
  float gamma = 1.0 + abs(enhanceSky); 
  vec4 result = pow(gain*im, vec4(gamma)); 
  float gray = (result.r + result.b + result.g)/3.0; 
  result.rgb += (result.rgb-gray) * abs(enhanceSky) * 0.5; 
  result = mix(im, result, maskSky); 
  result.a = im.a; 
  return result;
T@"NSNumber",&,N,VinputSkyAmount
T@"NSNumber",&,N,VinputGrassAmount
CI_ENABLE_SUBDIVIDE_ROI
CI_MAX_TEXTURE_SIZE
CI_IOSURFACE_WRAPPING
CI_IOSURFACE_INTERMEDIATES
CI_PRINT_TIME
CI_PRINT_TREE
CI_PRINT_TREE options flags:
%3d  initial graph %s
(set)
%3d  optimized graph %s
%3d  program graph %s
 dump-inputs %s
dump-inputs
 dump-intermediates %s
dump-intermediates
 dump-timing %s
dump-timing
 skip-cpu %s
skip-cpu
 skip-gpu %s
skip-gpu
context==
(set %s)
 context==<name|number> %s
context!=
 context!=<name|number> %s
(set frame-%d)
 frame-<number> %s
 <dot|pdf> %s
frame-
graphviz
CI_PRINT_PROGRAM
CI_USE_SW
CI_NO_CM
CI_FORCE_IS_BACKGROUND
CI_FORCE_GPU_PRIORITY
CI_INPUT_CACHE_SIZE
CI_ENABLE_KERNEL_CACHE
CI_ENABLE_HALF_KERNELS
CI_ASYNC_KERNEL_COMPILE
CI_INTERMEDIATE_CACHE_SIZE
CI_INTERMEDIATE_SRGB_TEXTURES
CI_INPUT_SRGB_TEXTURES
CI_OUTPUT_SRGB_TEXTURES
CI_RECYCLE_OPENGL_TEXTURES
CI_RECYCLE_METAL_TEXTURES
CI_WORKING_FORMAT
CI_ENABLE_METAL_GPU
CI_ENABLE_METAL_DAG
CI_ENABLE_METAL_CONVERT
CI_ENABLE_METAL_BLIT
CI_ENABLE_METAL_REFLECTION
CI_ENABLE_METAL_DEBUG
CI_ENABLE_CL_CPU
CI_ENABLE_CL_GPU
CI_AUTOTEST_ROI
CI_ENABLE_SYNTHETIC_PUPIL_RED_EYE
CI_DISABLE_MERGING
CI_DISABLE_MERGING_PRE_GENERAL
CI_DISABLE_MERGING_POST_GENERAL
CI_LOG_TEXTURE_CACHE
CI_LIMIT_SAMPLERS
CI_LIMIT_RENDER
CI_NO_RENDER
CI_LOG_SURFACE_CACHE
CI_LOG_IMAGE_PROVIDER
CI_RENDER_MB_LIMIT
CI_SURFACE_CACHE_CAPACITY
CI_TEMP_DIR
CI_KDEBUG
CI_DISABLE_CRUFT_COMPATABILITY
CI_FORCE_INSERT_NOOPS
CI_MAX_CL_COMPLEXITY
CI_DEBUG_CONTEXT_COLOR
CI_DISABLE_WORKAROUND
CI_GRAPH_ALLOW_REORDER
CI_GRAPH_FORCE_CROP
CI_FLIP_IMAGE_PROCESSOR
CI_FORCE_GLES_VERSION
CI_CACHE_PROGRAM_GRAPH
Progam Graph cache disabled when using CI_PRINT_TREE dump_timing
FOSL_DUMP_GRAPH
FOSL_PRINT_GRAPH
FOSL_PRINT_KERNEL_AST
CI_DISABLE_REDEYE_SEARCH
CI_LOG_DUALRED
com.apple.coremedia
&amp;
&lt;
&gt;
&quot;
&apos;
 94 42182154  3198255235 94254236138180 80 32238196106200163
231135151  7244167137102 45 85205108187254 85 31125176101125
210159109 92 99  0111 42232183107 75 83 73 33168 13158104 52
 21 79 25207203 12204  9 16  0 62169 72 50 15164121 22 12 90
135126204  9215 16198163 19138 52 28252162 65199105 9821615
110155171173177217230 12135125 99179192 62  5100 27100247229
158 76 12 19 74 59179 69199170224162116160 36243192238102116
227190 38186 46106  3151139 74180110126140101135 38175114 52
 45 22116246144186171156230 18224154112100 95178129 78 52 67
154 79203178105 68227227 46106 31216231181 41 16111 49120 67
  8228 62134  5248 95233220104181 33112 30245  1 49236 63237
252226233 24195165144 12195245 33239 61140 56 66242 86209 37
195 93 42 53191  4198 41165172182107162183 15163222242 96 46
 43 78166 61115228209209199 78 64193117220101158144234 11205
%.5f
%.6f
originalFaceColor
T{?=ff},R,VoriginalFaceColor
lumHist
T@"CIEnhancementHistogram",R,VlumHist
rgbSumHist
T@"CIEnhancementHistogram",R,VrgbSumHist
satHist
T@"CIEnhancementHistogram",R,VsatHist
borderHist
T@"CIEnhancementHistogram",R,VborderHist
CIKernelLibrary
Cannot initialize kernel library on unsupported system.
functionCount
metallib
%spremultiply
kernel vec4 _spotLight (__sample src, vec3 lightpos, vec3 lightpointsat, vec4 lightcolor, vec2 parms) 
 vec4 t0 = vec4(0.0); 
 t0.xy = destCoord(); 
 vec4 r0; 
 r0.xyz = lightpos - t0.xyz; 
 r0.w = 0.0; 
 r0 = normalize(r0); 
 float k0 = dot(r0.xyz, lightpointsat); 
 k0 = clamp(k0, 0.0, 1.0); 
 k0 = pow(k0, parms.x); 
 vec4 r3 = k0 * lightcolor; 
 r0 = r0.z * r3; 
 vec4 dest = r0 * src; 
 return dest; 
inputConcentration
inputLightPosition
inputLightPointsAt
builtin_premultiply
builtin_unpremultiply
Invalid premultiply power %d.
premultiply
unpremultiply
nopremultiply
badpremultiply
premul
unpremul
kernel vec4 _colorcube (__sample im, sampler2D cube, vec4 dims) 
 im.rgb = clamp(im.rgb, 0.0001, 0.9999); 
 im.rgb *= dims.x; 
 float flr = floor(im.b); 
 vec2 xy = (0.5 + im.rg) * dims.zw; 
 xy.y += flr * dims.z; 
 vec4 sLo = texture2D(cube, xy); 
 xy.y += dims.z; 
 vec4 sHi = texture2D(cube, xy); 
 return mix(sLo, sHi, im.b - flr) * im.a; 
kernel vec4 _colorcubeopaque (__sample im, sampler2D cube, vec4 dims) 
 im.rgb = clamp(im.rgb, 0.0001, 0.9999); 
 im.rgb *= dims.x; 
 float flr = floor(im.b); 
 vec2 xy = (0.5 + im.rg) * dims.zw; 
 xy.y += flr * dims.z; 
 vec3 sLo = texture2D(cube, xy).rgb; 
 xy.y += dims.z; 
 vec3 sHi = texture2D(cube, xy).rgb; 
 im.rgb = mix(sLo, sHi, im.b - flr); 
 return im; 
CIColorCube inputCubeDimension must be from 2 through %d.
CIColorCube inputCubeData must be of type NSData.
CIColorCube inputCubeData is not of the expected length.
T@"NSNumber",&,N,VinputCubeDimension
T@"NSData",C,N,VinputCubeData
CIColorCubeWithColorSpace inputColorSpace must be an RGB CGColorSpaceRef
inputCube0Data
inputCube1Data
CIColorCube inputCube0Data must be of type NSData.
CIColorCube inputCube1Data must be of type NSData.
CIColorCube inputCube0Data is not of the expected length.
CIColorCube inputCube1Data is not of the expected length.
T@"CIImage",&,N,VinputMaskImage
T@"NSData",C,N,VinputCube0Data
T@"NSData",C,N,VinputCube1Data
kernel vec4 _radialGradient (vec4 params, __color c0, __color c1) 
 highp float t = distance(destCoord(),params.xy) * params.z + params.w; 
 return mix(c0, c1, clamp(t, 0.0, 1.0)); 
inputRadius0
inputRadius1
T@"NSNumber",&,N,VinputRadius0
T@"NSNumber",&,N,VinputRadius1
kernel vec4 _linearGradient (vec2 p0, vec2 p1, __color c0, __color c1, float d1Inv) 
 highp float t = dot(p1 - p0, destCoord() - p0) * d1Inv; 
 return mix(c0, c1, clamp(t, 0.0, 1.0)); 
T@"CIVector",&,N,VinputPoint0
T@"CIVector",&,N,VinputPoint1
kernel vec4 _smoothLinearGradient (vec2 p0, vec2 p1, __color c0, __color c1, float d1Inv) 
 highp float t = dot(p1 - p0, destCoord() - p0) * d1Inv; 
 return mix(c0, c1, smoothstep(0.0, 1.0, t)); 
kernel vec4 _gaussianGradient (vec3 params, __color c0, __color c1) 
 highp float d = min(distance(destCoord(), params.xy) * params.z, 1.0); 
 d = (d * -2.0 + 3.0) * d * d; 
 return mix(c0, c1, d); 
kernel vec4 _hsvwheel (vec4 params) 
 float value = params.x; 
 float radius = params.y; 
 float invradius = params.z; 
 float smoothness = params.w; 
 vec2 p = destCoord() - vec2(radius); 
 float len = length(p); 
 float H = atan(p.y,p.x) * 3.0 / 3.1415926; 
 H = p.x == 0.0 ? p.y > 0.0 ? 1.5 : -1.5 : H; float S = clamp(len * invradius, 0.0, 1.0); 
 vec4 c = vec4(H, H-2.0, H+2.0, 0.0); 
 c = clamp(abs(3.0-abs(c))-1.0, 0.0, 1.0); 
 c = mix(c, smoothstep(0.0,1.0,c), smoothness); 
 c = mix(vec4(1.0), c, S); 
 c.a = 1.0; 
 c.rgb *= value; 
 return c * clamp(radius - len, 0.0, 1.0); 
float noise(float seed, vec2 dc) 
 float x = (13.0*dc.x + 1111.0)/(17.0 + seed); 
 float y = (11.0*dc.y + 7777.0)/(19.0 - seed); 
 float m = 37.0; 
 float n = x; 
 n = mod(y*n + y, m); 
 n = mod(y*n + x, m); 
 n = mod(x*n, m); 
 n = mod(x*n, m); 
 return n/m; 
 kernel vec4 _hsvwheeldithered (vec4 params, float dither) 
 float value = params.x; 
 float radius = params.y; 
 float invradius = params.z; 
 float smoothness = params.w; 
 vec2 p = destCoord() - vec2(radius); 
 float len = length(p); 
 float H = atan(p.y,p.x) * 3.0 / 3.1415926; 
 H = p.x == 0.0 ? p.y > 0.0 ? 1.5 : -1.5 : H; float S = clamp(len * invradius, 0.0, 1.0); 
 vec4 c = vec4(H, H-2.0, H+2.0, 0.0); 
 c = clamp(abs(3.0-abs(c))-1.0, 0.0, 1.0); 
 c = mix(c, smoothstep(0.0,1.0,c), smoothness); 
 c = mix(vec4(1.0), c, S); 
 c.a = 1.0; 
 c.rgb *= value; 
 c.rgb += (noise(0.0, floor(destCoord())) - 0.5)*dither; 
 return c * clamp(radius - len, 0.0, 1.0); 
+[CIHueSaturationValueGradient customAttributes]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/CIGradient.mm
inputValue
inputDither
T@"NSNumber",&,N,VinputValue
T@"NSNumber",&,N,VinputSoftness
T@"NSNumber",&,N,VinputDither
kernel vec4 _colorMonochrome (__sample img, __color color, float intensity) 
 float c1 = dot(img.rgb, vec3(0.2125, 0.7154, 0.0721)); 
 vec4 low = 2.0 * c1 * color; 
 vec4 high = 1.0 - 2.0 * ((1.0 - c1) * (vec4(1.0) - color)); 
 vec4 lt = vec4(lessThan(vec4(c1 - 0.5), vec4(0.0))); 
 vec4 pix = mix(img, mix(high, low, lt), intensity); 
 img.rgb = pix.rgb; 
 return img; 
float _PA_distance(vec4 c) { return dot(c,c); }
kernel vec4 _palettize(sampler image, sampler palette, float K) {
    vec4 img = sample(image, samplerTransform(image, destCoord()));
    vec4 minp = sample(palette, samplerTransform(palette, vec2(0.5, 0.5)));
    float mind = _PA_distance(img-minp);
    for (float m = 1.0f; m < K; m += 1.0f) {
        vec4 pal = sample(palette, samplerTransform(palette, vec2(0.5+m, 0.5)));
        float d = _PA_distance(img-pal);
        if (d < mind) {
            mind = d;
            minp = pal;
        }
    }
    return vec4(minp.rgb, img.a);
-[CIPalettize outputImage]
inputPaletteImage
T@"CIImage",&,N,VinputPaletteImage
T@"NSNumber",&,N,VinputPerceptual
kernel vec4 _ddither(__sample c, __sample n, float amount) 
 float nn = (n.r + n.g + n.b + n.a)*0.25 - 0.5; 
 c.rgb = c.rgb + amount*nn; 
 return c; 
kernel vec4 _shadowdesat(__sample u, float shadow, float amount, float feather) { 
 float Y = dot(u.rgb, vec3(0.299, 0.587, 0.114)); 
 float mask = 1.0 - smoothstep(feather*shadow, shadow, Y); 
 return vec4(mix(u.rgb, vec3(Y), mask * amount), u.a); 
T@"NSNumber",&,N,VinputThreshold
T@"CIImage",&,N,VinputBackgroundImage
kernel vec4 _hueBlendMode_v0 (__sample pCf, __sample pCb) 
 vec4 uCf = unpremultiply(pCf); vec4 uCb = unpremultiply(pCb); vec4 uCfSort = (uCf.r > uCf.g) ? uCf : uCf.grba; 
 uCfSort = (uCfSort.g > uCfSort.b) ? uCfSort : uCfSort.rbga; 
 uCfSort = (uCfSort.r > uCfSort.g) ? uCfSort : uCfSort.grba; 
 vec4 uCbSort = (uCb.r > uCb.g) ? uCb : uCb.grba; 
 uCbSort = (uCbSort.g > uCbSort.b) ? uCbSort : uCbSort.rbga; 
 uCbSort = (uCbSort.r > uCbSort.g) ? uCbSort : uCbSort.grba; 
 vec4 Ct = (uCfSort.b+0.00001 > uCfSort.r) ? uCbSort.rbba : (uCf - uCfSort.b) * (uCbSort.r - uCbSort.b) / (uCfSort.r - uCfSort.b) + uCbSort.b; 
 Ct.a = uCb.a; 
 vec4 Cb = vec4(uCb.rgb * uCb.a, uCb.a); 
 Ct = mix(uCf, Ct, uCb.a); 
 Ct.a = 1.0; 
 return mix(Cb, Ct, uCf.a); 
kernel vec4 _saturationBlendMode_v0 (__sample pCf, __sample pCb) 
 vec4 uCf = unpremultiply(pCf); vec4 uCb = unpremultiply(pCb); vec4 uCfSort = (uCf.r > uCf.g) ? uCf : uCf.grba; 
 uCfSort = (uCfSort.g > uCfSort.b) ? uCfSort : uCfSort.rbga; 
 uCfSort = (uCfSort.r > uCfSort.g) ? uCfSort : uCfSort.grba; 
 float fL = (uCfSort.r + uCfSort.b) * 0.5; 
 float cmax = uCfSort.r; 
 float cmin = uCfSort.b; 
 vec4 uCbSort = (uCb.r > uCb.g) ? uCb : uCb.grba; 
 uCbSort = (uCbSort.g > uCbSort.b) ? uCbSort : uCbSort.rbga; 
 uCbSort = (uCbSort.r > uCbSort.g) ? uCbSort : uCbSort.grba; 
 float bL = (uCbSort.r + uCbSort.b) * 0.5; 
 float d = cmax - cmin; 
 float dv = (fL < 0.5) ? (cmax + cmin) : (2.0 - (cmax + cmin)); 
 float s = d / max(dv, 0.000001); 
 float mmax = (bL <= 0.5) ? (bL + bL*s) : (bL + s - bL*s); 
 float mmin = bL * 2.0 - mmax; 
 vec4 Ct = (uCbSort.b+0.00001 > uCbSort.r) ? vec4(mmax,mmin,mmin,1.0) : (uCb - uCbSort.b) * (mmax - mmin) / (uCbSort.r - uCbSort.b) + mmin; 
 Ct.a = uCb.a; 
 vec4 Cb = vec4(uCb.rgb * uCb.a, uCb.a); 
 Ct = mix(uCf, Ct, uCb.a); 
 Ct.a = 1.0; 
 return mix(Cb, Ct, uCf.a); 
kernel vec4 _colorBlendMode_v0 (__sample pCf, __sample pCb) 
 vec4 uCf = unpremultiply(pCf); vec4 uCb = unpremultiply(pCb); vec4 uCfSort = (uCf.r > uCf.g) ? uCf : uCf.grba; 
 uCfSort = (uCfSort.g > uCfSort.b) ? uCfSort : uCfSort.rbga; 
 uCfSort = (uCfSort.r > uCfSort.g) ? uCfSort : uCfSort.grba; 
 float fL = (uCfSort.r + uCfSort.b) * 0.5; 
 float cmax = uCfSort.r; 
 float cmin = uCfSort.b; 
 vec4 uCbSort = (uCb.r > uCb.g) ? uCb : uCb.grba; 
 uCbSort = (uCbSort.g > uCbSort.b) ? uCbSort : uCbSort.rbga; 
 uCbSort = (uCbSort.r > uCbSort.g) ? uCbSort : uCbSort.grba; 
 float bL = (uCbSort.r + uCbSort.b) * 0.5; 
 float d = cmax - cmin; 
 float dv = (fL < 0.5) ? (cmax + cmin) : (2.0 - (cmax + cmin)); 
 float s = d / max(dv, 0.000001); 
 float mmax = (bL <= 0.5) ? (bL + bL*s) : (bL + s - bL*s); 
 float mmin = bL * 2.0 - mmax; 
 vec4 Ct = (uCf - uCfSort.b) * (mmax - mmin) / (uCfSort.r - uCfSort.b) + mmin; 
 Ct = (mmin+0.00001 > mmax) ? vec4(mmin) : Ct; 
 Ct.a = uCb.a; 
 vec4 Cb = vec4(uCb.rgb * uCb.a, uCb.a); 
 Ct = mix(uCf, Ct, uCb.a); 
 Ct.a = 1.0; 
 return mix(Cb, Ct, uCf.a); 
kernel vec4 _luminosityBlendMode_v0 (__sample pCf, __sample pCb) 
 vec4 uCf = unpremultiply(pCf); vec4 uCb = unpremultiply(pCb); vec4 uCbSort = (uCb.r > uCb.g) ? uCb : uCb.grba; 
 uCbSort = (uCbSort.g > uCbSort.b) ? uCbSort : uCbSort.rbga; 
 uCbSort = (uCbSort.r > uCbSort.g) ? uCbSort : uCbSort.grba; 
 float fL = (uCbSort.r + uCbSort.b) * 0.5; 
 float cmax = uCbSort.r; 
 float cmin = uCbSort.b; 
 vec4 uCfSort = (uCf.r > uCf.g) ? uCf : uCf.grba; 
 uCfSort = (uCfSort.g > uCfSort.b) ? uCfSort : uCfSort.rbga; 
 uCfSort = (uCfSort.r > uCfSort.g) ? uCfSort : uCfSort.grba; 
 float bL = (uCfSort.r + uCfSort.b) * 0.5; 
 float d = cmax - cmin; 
 float dv = (fL < 0.5) ? (cmax + cmin) : (2.0 - (cmax + cmin)); 
 float s = d / max(dv, 0.000001); 
 float mmax = (bL <= 0.5) ? (bL + bL*s) : (bL + s - bL*s); 
 float mmin = bL * 2.0 - mmax; 
 vec4 Ct = (uCb - uCbSort.b) * (mmax - mmin) / (uCbSort.r - uCbSort.b) + mmin; 
 Ct = (mmin+0.00001 > mmax) ? vec4(mmin) : Ct; 
 Ct.a = uCf.a; 
 vec4 Cf = vec4(uCf.rgb * uCf.a, uCf.a); 
 Ct = mix(uCb, Ct, uCf.a); 
 Ct.a = 1.0; 
 return mix(Cf, Ct, uCb.a); 
kernel vec4 _linearBurnBlendMode_v0 (__sample pCf, __sample pCb) 
 vec4 uCf = unpremultiply(pCf); vec4 uCb = unpremultiply(pCb); vec4 Ct = clamp(uCb - (1.0 - uCf*uCf.a), 0.0, 1.0); 
 vec4 Cb = vec4(uCb.rgb * uCb.a, uCb.a); 
 Ct = mix(uCf, Ct, uCb.a); 
 Ct.a = 1.0; 
 return mix(Cb, Ct, uCf.a); 
kernel vec2 _twirl(vec4 param) 
 vec2 d = destCoord() - param.xy; 
 float r = min(length(d) * param.z, 1.0); 
 float _1mr = 1.0 - r; 
 float ss = (_1mr * -2.0 + 3.0) * _1mr * _1mr; 
 float angle = param.w * ss; 
 vec2 cs = vec2(cos(angle), sin(angle)); 
 vec2 p = vec2(dot(d, cs), dot(d, vec2(-cs.y, cs.x))); 
 return (r >= 1.0) ? destCoord() : p + param.xy; 
function not implemented
out of boundaries
<CI::Color %p>[%g %g %g %g]
[%g %g %g %g 
kernel vec4 _vignette (__sample s, vec4 params) 
 vec2 point = destCoord() - params.xy; 
 float len2 = dot(point, point); 
 float v = pow(max(1.0 - len2 * params.w, 0.0), params.z); 
 s.rgb *= v; 
 return s; 
kernel vec4 _vignetteeffect (__sample s, vec2 center, vec4 params) 
 vec2 point = (destCoord() - center) * params.x; 
 float dist = sqrt(dot(point,point)); 
 float x = clamp((dist-params.y)*params.z,0.0,1.0); 
 x = x*x*x*((6.0*x - 15.0)*x + 10.0); 
 float v = 1.0 - x*params.w; 
 v = ((( -0.120638501063760*v + 0.543878646118680)*v + 0.538772615443760)*v + 0.037600999734998)*v; 
 s.rgb *= v; 
 return s; 
kernel vec4 _vignetteeffectneg (__sample s, vec2 center, vec4 params) 
 vec2 point = (destCoord() - center) * params.x; 
 float dist = sqrt(dot(point,point)); 
 float x = clamp((dist-params.y)*params.z,0.0,1.0); 
 x = x*x*x*((6.0*x - 15.0)*x + 10.0); 
 float v = 16.0*x*params.w + 1.0; 
 s.rgb *= v; 
 return s; 
T@"NSNumber",&,N,VinputFalloff
kernel vec2 _kaleida (vec4 parms, vec4 rota, vec4 rotb) 
 vec2 ctr = parms.xy; 
 float TwoPiDivCount = parms.z; 
 float CountDivTwoPi = parms.w; 
 vec2 v = destCoord() - ctr; 
 v = vec2(dot(v, rota.xy), dot(v, rota.zw)); 
 const float pi = 3.141592653589793; 
 const float halfpi = 1.570796326794897; 
 v.y = abs(v.y); 
 float a = atan(v.y,v.x); 
 a = - TwoPiDivCount * floor(a*CountDivTwoPi+0.5); 
 float x = (a>halfpi) ? pi-a : a; 
 x = (x<-halfpi) ? -pi-x : x; 
 float sn = x - (x*x*x/6.0) + (x*x*x*x*x/120.0) - (x*x*x*x*x*x*x/5040.0) + (x*x*x*x*x*x*x*x*x/362880.0); 
 x = abs(a); 
 float k = (x>halfpi) ? -1.0 : 1.0; 
 x = (x>halfpi) ? pi-x : x; 
 x = x*x; 
 x = (((0.000024801587302*x - 0.001388888888889)*x + 0.041666666666667)*x - 0.5)*x + 1.0; 
 float cs = x*k; 
 v = vec2(v.x*cs - v.y*sn, v.x*sn + v.y*cs); 
 v.y = abs(v.y); 
 v = vec2(dot(v, rotb.xy),dot(v, rotb.zw)); 
 return v + ctr; 
devicegray
devicergb
calRGB(
wp=d50 
wp=%.3f,%.3f,%.3f 
bp=%.3f,%.3f,%.3f 
gamma=1 
gamma=%.3f 
gamma=%.3f,%.3f,%.3f 
mtx=%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f)
calGray(
gamma=1)
gamma=%.3f)
DeviceCMYK Colorspace %p
Lab Colorspace %p
Indexed Colorspace %p
DeviceN Colorspace %p
Pattern Colorspace %p
PlatformSets Colorspace %p
kernel vec4 _yccCombiner (__sample imY, __sample imCC)
  return vec4(imY.r, imCC.rg, imY.a);
srgb_to_linear
linear_to_srgb
srgb_noop
builtin_linear_to_srgb
builtin_srgb_to_linear
Invalid srgb direction %d.
srgb_invalid
lintosrgb
srgbtolin
samplemode
inputDamping
kernel vec4 _colorbalance (__sample pix, __color clr, vec4 params) 
 pix.rgb = pix.r * vec3(0.299, 0.595716, 0.211456) + 
 pix.g * vec3(0.587, -0.274453, -0.522591) + 
 pix.b * vec3(0.114, -0.321263, 0.311135); 
 clr.rgb /= max(clr.a, 0.00001); 
 clr.rgb = pow(max(clr.rgb, 0.0), vec3(0.25)); 
 clr.rgb = clr.r * vec3(0.299, 0.595716, 0.211456) + 
 clr.g * vec3(0.587, -0.274453, -0.522591) + 
 clr.b * vec3(0.114, -0.321263, 0.311135); 
 pix.gb += params.z * (params.xy - clr.gb) * pow(pix.r, params.w); 
 pix.rgb = pix.r * vec3(1.0) + 
 pix.g * vec3(0.956296, -0.272122, -1.10699) + 
 pix.b * vec3(0.621024, -0.647381, 1.70461); 
 return pix; 
T@"NSNumber",&,N,VinputDamping
ExifOrientation
WouldAutoFlashTurnOn
PortType
DeviceModelName
NormalizedSNR
Tuning
kLandmarks
kEyeArea
kEyeAxes
kEyeROIs
kEyePupil
/var/mobile/Media/DCIM/
kSessionTuningOutsetROILong
kSessionTuningOutsetROIShort
kMinPrimaryDimension
kMinLandmarkConfidenceThreshold
kMaxFaceJunkinessThreshold
kMinLandmarkArea
kMinIsotropy
kMaxFaceCount
kRenderFullRect
kMinLaplacianVariance
inputOrientationHint
inputOrientationScale
inputRefilterSpace
inputRefilterRange
inputDetectRed
inputDetectWhite
inputMidSpectrumWhiteOffsets
inputCentroidIterations
inputCentroidRadius
inputCentroidRadiusSmall
inputCentroidGamma
inputFalloffRepair
inputRadiusRepair
inputRepairPercentile
inputRepairPercent
inputClipMin
inputClosingDilation
inputClosingErosion
inputRepairDarken
inputRepairChroma
inputRepairDither
inputCutoff
inputGamma
inputSplat
inputFeathering
inputFSmooth
inputFlooding
inputRecover
inputFoobar
inputFoobar2
inputFoobar3
inputFoobar4
inputFalloffSpecular
inputRadiusSpecular
inputSpecular
inputSpecArea
inputSpecIntensity
inputSpecMin
inputCenterSpecRad
inputWhiteCutoff
inputFalloffDensity
inputAbortDensityLo
inputAbortDensityDiff
inputRadiusDensity
inputInterPeakMin
inputCircularity
inputIntersect
inputSkinThreshold
inputRepairSource
inputSpecMax
inputShowMask
+[CIDualRedEyeRepairSession repairParametersForTuning:]
+[CIDualRedEyeRepairSession sessionParametersForTuning:]
N841
D321
D331
D331p
PortTypeBackTelephoto
-[CIDualRedEyeRepairSession setPrimary:observations:metadata:]
i12@?0@4@8
-[CIDualRedEyeRepairSession _repairPrimaryWithSecondary:to:]
-raw
CIRedEyeRaw
inputPrimary
inputSecondary
inputOriginLeft
inputOriginRight
inputAxisLongLeft
inputAxisLongRight
inputAxisShortLeft
inputAxisShortRight
inputPupilCenterLeft
inputPupilCenterRight
-repair
YYYY_MM_dd__HH_mm_ss_SSS
__IMG__%@__redeye
%@%@%@.tiff
primary
T^{__CVBuffer=},&,N,Vprimary
destination
T@"CIRenderDestination",&,N,Vdestination
primaryImage
T@"CIImage",&,N,V_primaryImage
metadata
T@"NSDictionary",&,N,Vmetadata
imageProperties
T@"NSDictionary",&,N,VimageProperties
faces
T@"NSArray",&,N,Vfaces
filterTuning
T@"NSDictionary",&,N,VfilterTuning
sessionTuning
T@"NSDictionary",&,N,VsessionTuning
T@"NSDate",&,N,Vtimestamp
repairROIforEyePoints
kernel vec2 _pinchDistortionScaleLT1(vec2 c, vec4 param)
  vec2 p = destCoord() - c;
  float r = length(p) * param.y + .000001;
  p = p * inversesqrt(r) + c;
  return mix(destCoord(), p, param.z);
kernel vec2 _pinchDistortionScaleGE1(vec2 c, vec4 param)
  vec2 p = destCoord() - c;
  float r = length(p) * param.y + .000001;
  vec2 pRGT = pow(r, param.w) * p + c;
  p = p * inversesqrt(r) + c;
  p = mix(destCoord(), p, param.z);
  return (r <= 1.0) ? p : pRGT;
Invalid scale %g in CIPinchDistortion, must be less than 2
map_point_inv
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/PhotoBooth/CIPinchDistortion.m
scale < 2.0
colormatch
workingspace
_to_
Matching a color failed: from 
 to 
Core Image could not support source colorspace: 
B48@?0{CGColorConversionIteratorData=Iiiiiii^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMLUTData}}4^{__CFDictionary=}44
B56@?0{CGColorConversionIteratorData=Iiiiiii^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMLUTData}}4l44l48^i52
B52@?0{CGColorConversionIteratorData=Iiiiiii^^{CGColorTRCData}^^{CGColorMatrixData}^^{CGColorNxMLUTData}}4l44l48
failed to create a converter from 
cmlut %llu
cm%zux%zulut %llu
kernel vec4 _cmlut (__sample im, sampler2D lut, vec2 dim)
  im.rgb = clamp(im.rgb, 0.0, 1.0); 
  im.rgb = im.rgb * dim.x + dim.y; 
  im.r = texture2D(lut, vec2(im.r, 0.5)).r; 
  im.g = texture2D(lut, vec2(im.g, 0.5)).r; 
  im.b = texture2D(lut, vec2(im.b, 0.5)).r; 
  return im;
cube
_cmlut
kernel vec4 _cmcubeopaque (__sample im, sampler2D cube, vec4 dims)
  im.rgb = clamp(im.rgb, 0.0001, 0.9999);
  im.rgb *= dims.x;
  float flr = floor(im.b);
  vec2 xy = (0.5 + im.rg) * dims.zw;
  xy.y += flr * dims.z; 
  vec3 sLo = texture2D(cube, xy).rgb;
  xy.y += dims.z; 
  vec3 sHi = texture2D(cube, xy).rgb;
  im.rgb = mix(sLo, sHi, im.b - flr);
  return im;
dims
_cmcubeopaque
kernel vec4 _cm1x3lut (__sample im, sampler2D lut, vec2 dim)
  im.rgb = clamp(im.rgb, 0.0, 1.0); 
  im.rgb = im.rgb * dim.x + dim.y; 
  im.rgb = texture2D(lut, vec2(im.r, 0.5)).rgb; 
  return im;
_cm1x3lut
Core Image could not support destination colorspace: 
vec4 _pointillizeStep( sampler src, vec4 background, sampler noise, vec2 cellSize, vec2 noiseOffset, vec2 cellOffset, vec2 dc) 
 float o; 
 float tSize = 256.0; 
 float _randomFactor = 0.65; 
 float _radiusFactor = 0.71; 
 float _colorRandom = 0.1; 
 vec2 noiseLoc = floor(dc*cellSize.y + .5) + noiseOffset; 
 vec4 np = sample(noise, samplerTransform(noise, mod(noiseLoc, tSize))); 
 vec2 cellLoc = (floor(dc*cellSize.y - 0.5) + 0.5) * cellSize.x + 0.5 + cellOffset; 
 cellLoc += (np.xy - 0.5) * cellSize.x * _randomFactor; 
 o = distance(dc, cellLoc); 
 o = clamp((1.0 - o * cellSize.y / _radiusFactor) * 3.0, 0.0, 1.0); 
 o = (3.0 - 2.0 * o) * o * o; 
 vec4 p1 = sample(src, samplerTransform(src, cellLoc)); 
 p1.rgb += vec3(np.b - 0.5) * _colorRandom * p1.a; 
 return mix(background, p1, o); 
kernel vec4 _pointillize(sampler src, sampler noise, vec4 parms) 
 vec4 background = sample(src, samplerCoord(src)).aaaa; 
 background = _pointillizeStep(src, background, noise, parms.zw, parms.xy + vec2(0.5,0.5), vec2(parms.z,parms.z), destCoord()); 
 background = _pointillizeStep(src, background, noise, parms.zw, parms.xy + vec2(-0.5,0.5), vec2(0,parms.z), destCoord()); 
 background = _pointillizeStep(src, background, noise, parms.zw, parms.xy + vec2(0.5,-0.5), vec2(parms.z,0), destCoord()); 
 background = _pointillizeStep(src, background, noise, parms.zw, parms.xy + vec2(-0.5,-0.5), vec2(0,0), destCoord()); 
 return background; 
Projections_status Projections_computeShiftBruteForce(const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float, float *, float *, float *, float *)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/api/Burst/Projections/Projections_Optimizer.c
Projections_status Projections_computeCost(int, float, float, const float *, int, const Projections_meanStdTable *, const float *, int, const Projections_meanStdTable *, int, float *)
clamptoalpha
clamp_to_alpha
memstream_write
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/util/memstream.c
ms->size < ms->capacity
ms->contents[ms->size] == 0
memstream_seek
ms->size < ms->capacity && ms->contents[ms->size] == 0
memstream_close
vec2 clampToRect(vec2 point,vec4 rect) {
  return clamp(point,rect.xy,rect.xy + rect.zw);
vec4 sampleBilinear(sampler image,vec2 p) {
    vec2 xy0 = p - vec2(0.5);
    vec2  p0 = floor(xy0);
    vec2  p1 = p0 + vec2(1.0);
    vec2 amount = p1 - xy0;
    vec4 ll = sample(image, samplerTransform(image, p0 + vec2(0.5)));
    vec4 ur = sample(image, samplerTransform(image, p1 + vec2(0.5)));
    vec4 lr = sample(image, samplerTransform(image, vec2(p1.x, p0.y) + vec2(0.5)));
    vec4 ul = sample(image, samplerTransform(image, vec2(p0.x, p1.y) + vec2(0.5)));
    vec4 bottom = mix(lr, ll, amount.x);
    vec4 top = mix(ur, ul, amount.x);
    return mix(top, bottom, amount.y);
kernel vec4 variableBoxBlur(sampler integralImage,sampler radiusImage,float scale,vec4 e) {
  vec4 v = unpremultiply(sample(radiusImage, samplerCoord(radiusImage)));
  float radius = scale * dot(v.rgb,vec3(0.2126, 0.7152, 0.0722));
 radius = max(radius, 0.5);
  vec2 c = destCoord();
  vec2 lowerLeft = clampToRect(c + vec2(-radius-1.0, -radius), e);
  vec2 upperRight = clampToRect(c + vec2(radius, radius+1.0), e);
  vec4 ul = sampleBilinear(integralImage, vec2(lowerLeft.x, upperRight.y));
  vec4 ur = sampleBilinear(integralImage, upperRight);
  vec4 ll = sampleBilinear(integralImage, lowerLeft);
  vec4 lr = sampleBilinear(integralImage, vec2(upperRight.x, lowerLeft.y));
  vec4 rc = ul + lr - ur - ll;
  vec2 diagonal = upperRight - lowerLeft;
  float usedArea = abs(diagonal.x * diagonal.y);
  float originalArea = (2.0*radius+1.0) * (2.0*radius+1.0);
 rc /= rc.a;
 rc.a = 1.0;
  return premultiply(rc);
inputRadiusImage
T@"CIImage",&,N,VinputRadiusImage
_wrapper
originalObject
@"CIFilter"
@"CIImage"
metaFilterForFilter
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/api/CIMetaFilter.mm
s0 && s1 && s2 && s3 && s4
ivar is nil for key %@
Not adding new key to class because types are inconsistent (%s & %s)
addKeyForToFilter
success
setValueForObject
value == object_getIvar(object, var)
kernel vec4 _white(__sample src) 
 return vec4(src.a); 
kernel vec4 _cmyk_convert(__sample src, vec2 ucrgcr) 
 vec4 pix = src; 
 vec3 v = 1.0 - pix.rgb; 
 float f = min(min(v.r,v.g),v.b) * ucrgcr.y; 
 float sblack = f * f; 
 float removed = sblack * ucrgcr.x; 
 pix.rgb = v - vec3(removed); 
 pix.a = sblack; 
 return pix; 
kernel vec4 _cmyk_cyan(__sample sofar, __sample cmyksrc, vec2 center, vec4 mtx, float con) 
 vec2 pt = destCoord() - center; 
 pt = vec2(dot(pt, mtx.xy),dot(pt, mtx.zw)); 
 pt = fract(pt + center) * 6.2831853; 
 float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / con) + 0.5; 
 float f = clamp((cmyksrc.r - g) * con + 0.5, 0.0, 1.0); 
 vec4 ink = mix(vec4(1.0), vec4(0.0,1.0,1.0,1.0), f); 
 return clamp(ink * sofar, 0.0, 1.0); 
kernel vec4 _cmyk_magenta(__sample sofar, __sample cmyksrc, vec2 center, vec4 mtx, float con) 
 vec2 pt = destCoord() - center; 
 pt = vec2(dot(pt, mtx.xy),dot(pt, mtx.zw)); 
 pt = fract(pt + center) * 6.2831853; 
 float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / con) + 0.5; 
 float f = clamp((cmyksrc.g - g) * con + 0.5, 0.0, 1.0); 
 vec4 ink = mix(vec4(1.0), vec4(1.0,0.0,1.0,1.0), f); 
 return clamp(ink * sofar, 0.0, 1.0); 
kernel vec4 _cmyk_yellow(__sample sofar, __sample cmyksrc, vec2 center, vec4 mtx, float con) 
 vec2 pt = destCoord() - center; 
 pt = vec2(dot(pt, mtx.xy),dot(pt, mtx.zw)); 
 pt = fract(pt + center) * 6.2831853; 
 float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / con) + 0.5; 
 float f = clamp((cmyksrc.b - g) * con + 0.5, 0.0, 1.0); 
 vec4 ink = mix(vec4(1.0), vec4(1.0,1.0,0.0,1.0), f); 
 return clamp(ink * sofar, 0.0, 1.0); 
kernel vec4 _cmyk_black(__sample sofar, __sample cmyksrc, vec2 center, vec4 mtx, float con) 
 vec2 pt = destCoord() - center; 
 pt = vec2(dot(pt, mtx.xy),dot(pt, mtx.zw)); 
 pt = fract(pt + center) * 6.2831853; 
 float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / con) + 0.5; 
 float f = clamp((cmyksrc.a - g) * con + 0.5, 0.0, 1.0); 
 vec4 ink = mix(vec4(1.0), vec4(0.0,0.0,0.0,1.0), f); 
 return clamp(ink * sofar, 0.0, 1.0); 
inputGCR
inputUCR
kernel vec4 _rectangle (vec4 parms1, vec4 parms2, __color color) 
 vec4 d0 = destCoord().xxyy; 
 d0 = d0 * parms1 + parms2; 
 d0 = clamp(max(d0, d0.yxwz), 0.0, 1.0); 
 d0 = 1.0 - smoothstep(0.0, 1.0, d0); 
 return d0.x * d0.z * color; 
kernel vec2 _wrapMirror (vec2 dim) { return mix(dim - abs(dim-destCoord()), abs(destCoord()), vec2(lessThan(destCoord(), 0.5 * dim))); }
kernel vec4 _lumaMap (__sample pixel, sampler2D table,vec2 normalizer)
  float luma = dot(pixel, vec4(0.299, 0.587, 0.114, 0.0));
  vec4 result = texture2D(table, vec2(normalizer.x * luma + normalizer.y, 0.5));
  result.a = pixel.a;
  return result;
10.11
ThumbnailCluster - adding %s
[CIBurstThumbnailCluster initWithImageData] : metadata parsing error
[CIBurstThumbnailCluster initWithImageData] : no error
burstImages
T@"NSMutableArray",VburstImages
imageProps
T@"NSMutableDictionary",VimageProps
T@"CIBurstYUVImage",Vimage
completionBlock
T@?,VcompletionBlock
kernel vec4 _crystallize(sampler src, sampler noise, vec2 cellSize, vec2 offset) 
 float tSize = 256.; 
 vec4 u1, u2, u3, u4; 
 vec2 t0 = destCoord(); 
 vec2 cellCorner = (floor(t0 * cellSize.y - 0.5) + 0.5) * cellSize.x + 0.5; 
 vec2 t1 = cellCorner * cellSize.y + offset; 
 t1 = t1 + vec2(-.5,-.5); 
 vec2 t2 = t1 + vec2(1.0, 0.0); 
 vec2 t3 = t1 + vec2(0.0, 1.0); 
 vec2 t4 = t1 + vec2(1.0, 1.0); 
 vec4 c1 = sample(noise, samplerTransform(noise, mod(t1, tSize))); 
 vec4 c2 = sample(noise, samplerTransform(noise, mod(t2, tSize))); 
 vec4 c3 = sample(noise, samplerTransform(noise, mod(t3, tSize))); 
 vec4 c4 = sample(noise, samplerTransform(noise, mod(t4, tSize))); 
 u1.xy = cellCorner; 
 u2.xy = u1.xy + vec2(cellSize.x, 0.0); 
 u3.xy = u1.xy + vec2(0.0, cellSize.x); 
 u4.xy = u1.xy + vec2(cellSize.x, cellSize.x); 
 float cellSize3 = cellSize.x * 0.65; 
 u1.xy += (c1.rg - 0.5) * cellSize3; 
 u2.xy += (c2.rg - 0.5) * cellSize3; 
 u3.xy += (c3.rg - 0.5) * cellSize3; 
 u4.xy += (c4.rg - 0.5) * cellSize3; 
 vec2 d0 = t0 - u1.xy; 
 u1.z = dot(d0,d0); 
 d0 = t0 - u2.xy; 
 u2.z = dot(d0,d0); 
 d0 = t0 - u3.xy; 
 u3.z = dot(d0,d0); 
 d0 = t0 - u4.xy; 
 u4.z = dot(d0,d0); 
 vec4 desc = vec4(u1.z - u2.z); 
 vec4 v1 = compare(desc, u1, u2); 
 vec4 v2 = compare(desc, u2, u1); 
 desc = vec4(u3.z - u4.z); 
 vec4 v3 = compare(desc, u3, u4); 
 vec4 v4 = compare(desc, u4, u3); 
 desc = vec4(v1.z - v3.z); 
 u1 = compare(desc, v1, v3); 
 u2 = compare(desc, v3, v1); 
 desc = vec4(v2.z - v4.z); 
 u3 = compare(desc, v2, v4); 
 desc = vec4(u2.z - u3.z); 
 u2 = compare(desc, u2, u3); 
 float alpha = clamp((sqrt(u2.z) - sqrt(u1.z)) * 0.5 + 0.5, 0.0, 1.0); 
 vec4 p1 = sample(src, samplerTransform(src, u1.xy)); 
 vec4 p2 = sample(src, samplerTransform(src, u2.xy)); 
 return mix(p2, p1, alpha); 
kernel vec4 _blendGrains(__sample isoImages, float log10iso)
  vec4 c = isoImages; 
  float mix10_50    = mix(c.r, c.g, log10iso*1.43067655809 
                                           - 1.43067655809); 
  float mix50_400   = mix(c.g, c.b, log10iso*1.10730936496 
                                           - 1.88128539659); 
  float mix400_3200 = mix(c.b, c.a, log10iso*1.10730936496 
                                           - 2.88128539659); 
  float v = compare(log10iso - 1.69897000434,                     mix10_50,                     compare(log10iso - 2.60205999133,                             mix50_400,                             mix400_3200)); 
  return vec4(v,v,v,1.0);
kernel vec4 _grainBlendAndMix(__sample img, __sample grainImage, float contrast, float mixAmount)
  vec3 rgb = img.rgb;
  float luminance = clamp(dot(rgb, vec3(.333333)), 0.0, 1.0); 
  float gamma = 4.01 - 2.0*luminance;
  rgb = sign(rgb) * pow(abs(rgb), vec3(1.0/gamma));
  float grain = grainImage.r - 0.5;
  float mult = contrast * grain;
  rgb += (max(luminance, 0.5) * mult * (1.0-luminance));
  rgb = sign(rgb) * pow(abs(rgb), vec3(gamma));
  rgb = min(rgb, 1.0);
  return mix(img, vec4(rgb,img.a), mixAmount);
kernel vec2 _paddedTile2(vec4 k) { return fract(destCoord() * k.zw) * k.xy + vec2(1.0); }
noiseImage
T@"NSNumber",C,N,VinputISO
T@"NSNumber",C,N,VinputAmount
GLTexture %d
MTLTexture %p
 %dx%d
%@.%d
scube
com.apple.coreimage.photoEffectsIsolation
Input Metal texture was created with a device that does not match the current context device.
Cannot render image (with an input %s texture) using a %s context.
Metal
T@"NSNumber",&,N,VinputSigmaX
T@"NSNumber",&,N,VinputSigmaY
kernel vec4 _gaussianReduce4(sampler src, vec4 scale) 
 vec2 d = destCoord() * scale.xy; 
 vec4 q = sample(src, samplerTransform(src, d)); 
 vec4 s = q*0.249105655; 
 vec2 o = vec2(1.95019665)*scale.zw; 
 q = sample(src, samplerTransform(src, d-o)) + sample(src, samplerTransform(src, d+o)); 
 s += q*0.204995265; 
 o = vec2(3.90137021)*scale.zw; 
 q = sample(src, samplerTransform(src, d-o)) + sample(src, samplerTransform(src, d+o)); 
 s += q*0.11422973; 
 o = vec2(5.85840079)*scale.zw; 
 q = sample(src, samplerTransform(src, d-o)) + sample(src, samplerTransform(src, d+o)); 
 s += q*0.0433552031; 
 o = vec2(7.86886245)*scale.zw; 
 q = sample(src, samplerTransform(src, d-o)) + sample(src, samplerTransform(src, d+o)); 
 s += q*0.0128669748; 
 return s; 
kernel vec4 _gaussianReduce2(sampler src, vec4 scale) 
 vec2 d = destCoord() * scale.xy; 
 vec2 o1 = vec2(1.84623909)*scale.zw; 
 vec2 o2 = vec2(3.74518052)*scale.zw; 
 vec4 q1 = sample(src, samplerTransform(src, d - o2)); 
 vec4 q2 = sample(src, samplerTransform(src, d - o1)); 
 vec4 q3 = sample(src, samplerTransform(src, d)); 
 q2 += sample(src, samplerTransform(src, d + o1)); 
 q1 += sample(src, samplerTransform(src, d + o2)); 
 return 0.432290834*q3 + 0.24061645*q2 + 0.0432381327*q1; 
kernel vec4 _gaussianBlur19(sampler src, vec4 offset01, vec4 offset23, vec4 offset4, vec4 weight, vec4 weight2) 
 vec2 d = destCoord(); 
 vec4 q0 = sample(src, samplerTransform(src, d - offset4.xy)); 
 vec4 q1 = sample(src, samplerTransform(src, d - offset23.zw)); 
 vec4 q2 = sample(src, samplerTransform(src, d - offset23.xy)); 
 vec4 q3 = sample(src, samplerTransform(src, d - offset01.zw)); 
 vec4 q4 = sample(src, samplerTransform(src, d - offset01.xy)); 
 vec4 q5 = sample(src, samplerTransform(src, d + offset01.xy)); 
 vec4 q6 = sample(src, samplerTransform(src, d + offset01.zw)); 
 vec4 q7 = sample(src, samplerTransform(src, d + offset23.xy)); 
 vec4 q8 = sample(src, samplerTransform(src, d + offset23.zw)); 
 vec4 q9 = sample(src, samplerTransform(src, d + offset4.xy)); 
 return weight.x*(q4+q5) + weight.y*(q3+q6) + weight.z*(q2+q7) + weight.w*(q1+q8) + weight2.x*(q0+q9); 
kernel vec4 _gaussianBlur15(sampler src, vec4 offset01, vec4 offset23, vec4 weight) 
 vec2 d = destCoord(); 
 vec4 q0 = sample(src, samplerTransform(src, d - offset23.zw)); 
 vec4 q1 = sample(src, samplerTransform(src, d - offset23.xy)); 
 vec4 q2 = sample(src, samplerTransform(src, d - offset01.zw)); 
 vec4 q3 = sample(src, samplerTransform(src, d - offset01.xy)); 
 vec4 q4 = sample(src, samplerTransform(src, d + offset01.xy)); 
 vec4 q5 = sample(src, samplerTransform(src, d + offset01.zw)); 
 vec4 q6 = sample(src, samplerTransform(src, d + offset23.xy)); 
 vec4 q7 = sample(src, samplerTransform(src, d + offset23.zw)); 
 return weight.x*(q3+q4) + weight.y*(q2+q5) + weight.z*(q1+q6) + weight.w*(q0+q7); 
kernel vec4 _gaussianBlur11(sampler src, vec4 offset01, vec4 offset2, vec4 weight) 
 vec2 d = destCoord(); 
 vec4 q1 = sample(src, samplerTransform(src, d - offset2.xy)); 
 vec4 q2 = sample(src, samplerTransform(src, d - offset01.zw)); 
 vec4 q3 = sample(src, samplerTransform(src, d - offset01.xy)); 
 vec4 q4 = sample(src, samplerTransform(src, d + offset01.xy)); 
 vec4 q5 = sample(src, samplerTransform(src, d + offset01.zw)); 
 vec4 q6 = sample(src, samplerTransform(src, d + offset2.xy)); 
 return weight.x*(q3+q4) + weight.y*(q2+q5) + weight.z*(q1+q6); 
kernel vec4 _gaussianBlur7(sampler src, vec4 offset01, vec4 weight) 
 vec2 d = destCoord(); 
 vec4 q2 = sample(src, samplerTransform(src, d - offset01.zw)); 
 vec4 q3 = sample(src, samplerTransform(src, d - offset01.xy)); 
 vec4 q4 = sample(src, samplerTransform(src, d + offset01.xy)); 
 vec4 q5 = sample(src, samplerTransform(src, d + offset01.zw)); 
 return weight.x*(q3+q4) + weight.y*(q2+q5); 
kernel vec4 _gaussianBlur3(sampler src, vec4 offset0) 
 vec2 d = destCoord(); 
 return (sample(src, samplerTransform(src, d - offset0.xy)) + sample(src, samplerTransform(src, d + offset0.xy))) * 0.5; 
kernel vec4 _unsharpmask (__sample s, __sample b, float k) { s.rgb += (s.rgb - b.rgb * (s.a/max(b.a, 0.0001))) * k; return s; }
dividerScore
Tf,VdividerScore
trueLocalMaximum
Ti,VtrueLocalMaximum
leftImage
Ti,VleftImage
actionAmount
Tf,VactionAmount
noiseThreshold
Tf,VnoiseThreshold
highNoiseThreshold
Tf,VhighNoiseThreshold
noop_affine
noop_forced
noop_contextlimits
noop_multiuse
noop_samplemode
noop_disablemerging
noop_intermediate_uncached
noop_intermediate_cached
noop_full_intermediate
noop_intermediate
noop
com.apple.coreimage.halftoneKernelIsolation
kernel vec4 _dotscreen (__sample s, vec3 params, vec4 mtx) 
 vec2 pt = destCoord() - params.xy; 
 pt = vec2(dot(pt, mtx.xy), dot(pt, mtx.zw)); 
 pt = fract(pt + params.xy) * 6.2831853; 
 float g = (sin(pt.x) + sin(pt.y)) * 0.25 * (0.995 - 1.0 / params.z) + 0.5; 
 float l = dot(s.rgb, vec3(0.2125, 0.7154, 0.0721)); 
 s.rgb = vec3(clamp((l - g) * params.z + 0.5, 0.0, 1.0) * s.a); 
 return s; 
kernel vec4 _hatchedscreen (__sample s, vec3 params, vec4 mtx) 
 vec2 pt = destCoord() - params.xy; 
 pt = vec2(dot(pt, mtx.xy), dot(pt, mtx.zw)); 
 pt = fract(pt.xy + params.xy); 
 pt = min(vec2(1.0) - pt, pt) * 2.0; 
 float g = min(pt.x, pt.y * .5 + .5); 
 float l = dot(s.xyz, vec3(.2125, .7154, .0721)); 
 s.rgb = vec3(clamp((l - g) * params.z + 0.5, 0.0, 1.0) * s.a); 
 return s; 
kernel vec4 _linescreen (__sample s, vec3 params, vec4 mtx) 
 vec2 pt = destCoord() - params.xy; 
 pt = vec2(dot(pt, mtx.xy), dot(pt, mtx.zw)); 
 pt = fract(pt.xy + params.xy); 
 float g = min(1.0 - pt.x, pt.x) * 2.0; 
 float l = dot(s.xyz, vec3(.2125, .7154, .0721)); 
 s.rgb = vec3(clamp((l - g) * params.z + 0.5, 0.0, 1.0) * s.a); 
 return s; 
kernel vec4 _circularscreen (__sample s, vec4 params) 
 float d = length(destCoord() - params.xy); 
 d = fract(d * params.z); 
 d = min(1.0 - d, d); 
 d = dot(s.rgb, vec3(.2125, .7154, .0721)) - d * 2.0; 
 d = clamp(d * params.w + .5, 0.0, 1.0); 
 s.rgb = vec3(d) * s.a; 
 return s; 
kernel vec4 _bloom (__sample s, __sample b, float k) { return mix(s, max(s,b), k); }
kernel vec4 _gloom (__sample s, __sample b, float k) { return mix(s, min(s,b), k); }
inputLevels
kernel vec4 _colorPosterize (__sample src, vec2 factors) 
 src.rgb = floor(src.rgb * factors.x + 0.5) * factors.y; 
 return src; 
T@"NSNumber",&,N,VinputLevels
kernel vec4 _edges(sampler src, float scale) 
 vec2 dc = destCoord(); 
 vec4 r0 = sample (src, samplerTransform(src, dc + vec2(0.0,-1.0))); 
 vec4 r3 = sample (src, samplerTransform(src, dc + vec2(1.0,-1.0))); 
 vec4 r2 = sample (src, samplerTransform(src, dc + vec2(1.0, 0.0))); 
 vec4 r1 = sample (src, samplerCoord(src)); 
 r3 = r1 - r3; 
 r2 = r0 - r2; 
 r2 = (r3 * r3 + r2 * r2) * scale; 
 return vec4(r2.rgb, r1.a); 
kernel vec4 _disolve (__sample src0, __sample src1, float factor) { return mix(src1, src0, factor); }
kernel vec4 _fadeDissolve (__sample src, float factor) { return src*factor; }
T@"CIImage",&,N,VinputTargetImage
T@"NSNumber",&,N,VinputTime
kernel vec4 _maskToAlpha (__sample src) { return src.yyyy; }
CIMetalWrapper
CI_METAL_SDOF
kContextInfoIsMetal
BlurMapSmoothing
DisparitySmoothing
DisparityRefinement
Rendering
RenderingV3
defaultSimulatedAperture
faces.%@
HighlightRecovery
kernel vec4 _convertDepthOrDisparity(__sample s) 
  __attribute__((outputFormat(kCIFormatRh)))
{ return vec4(1.0/max(s.r,1e-6), s.gba); }
kernel vec4 _segmentationFusion(__sample blurmap,__sample alpha,vec3 addBlur,vec3 removeBlur) { float additiveTerm = clamp( addBlur.x * alpha.x + addBlur.y, 0.0, addBlur.z ); float subtractiveTerm = clamp( removeBlur.x * alpha.x + removeBlur.y, 0.0, removeBlur.z ); float outputBlurValue = sqrt ( clamp( ( blurmap.x * blurmap.x )+ additiveTerm - subtractiveTerm, 0.0, 1.0) ); return vec4(outputBlurValue, outputBlurValue, outputBlurValue, 1.0); }
additiveLowerAlpha
additiveUpperAlpha
additiveMaxBlur
subtractiveLowerAlpha
subtractiveUpperAlpha
subtractiveMaxBlur
inputAddBlur
inputRemoveBlur
inputApertureScaling
Matte image and blurmap are of different sizes.
disparity_refinement_slm_passthrough
inputLensModelImage
T@"CIImage",&,VinputLensModelImage
disparity_refinement_calcweightsX
disparity_refinement_calcweightsY
radius
weightScaling
-[CIDisparityWeightsV3 outputImage]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/PortraitBlur/CIsDOF.m
weightsXKernel
weightsYKernel
disparity_refinement_preproc
disparity_refinement_preproc_no_alpha
-[CIDisparityPreprocV3 outputImage]
preprocKernel
inputAlphaImage
T@"CIImage",&,VinputAlphaImage
disparity_refinement_sample
maxReconstructionWeight
disparitySigma
lumaSigma
chromaSigma
segmentationSigma
accumulatedWeightT0
accumulatedWeightT1
innerSamplingRadius
outerSamplingRadius
-[CIDisparityRefinementSparseSamplerV3 outputImage]
sampleKernel
-[CIDisparityRefinementSparseSamplerV3 outputImage]_block_invoke
inputPreprocImage
T@"CIImage",&,VinputPreprocImage
disparity_refinement_antialias
aaLumaSigma
aaChromaSigma
aaSegmentationSigma
aaSpatialSigma
-[CIDisparityRefinementAntialiasV3 outputImage]
antialiasKernel
-[CIDisparityRefinementAntialiasV3 outputImage]_block_invoke
inputDisparityWeightImage
T@"CIImage",&,VinputDisparityWeightImage
CIDisparityPreprocV3
CIDisparityWeightsV3
CIDisparityRefinementSparseSamplerV3
CIDisparityRefinementAntialiasV3
T@"NSNumber",C,VinputScale
inputMainImage
T@"CIImage",&,VinputMainImage
CGImageMetadataRef
inputOriginalSize
CILensModelCalculator
inputMinMaxImage
inputSimulatedAperture
inputIntrinsicMatrixFocalLength
CILensModelApply
inputLensModelParams
CIFaceMaskCalculator
inputFacesLeftEyeX
inputFacesLeftEyeY
inputFacesCenterX
inputFacesCenterY
inputFacesRightEyeX
inputFacesRightEyeY
inputFacesChinX
inputFacesChinY
inputFacesMaxBlurOnEyes
maxBlurOnEyes
inputFacesMaxBlurDistFromFocus
maxBlurDistFromFocus
inputFacesEyeToEyebrowRatio
eyeToEyebrowRatio
inputFacesLinearBlurGrowthM
linearBlurGrowthM
inputFacesLinearBlurGrowthC
linearBlurGrowthC
inputFacesDistToBlurScaling
distToBlurScaling
inputFacesCapMultip
capMultip
inputFacesGainMultip
gainMultip
CIFaceMaskApply
inputParameterImage
CIDisparitySmoothing
-[CIDepthEffectMakeBlurMap blurMapV2:]
shiftMap
slmParams
blurMap
faceMaskParams
CI_NATIVE_FOCAL_PLANE
inputZeroShiftPercentile
inputAlphaThreshold
inputAmplitude
inputExponent
inputMinFactor
inputMaxFactor
CIFocalPlaneNative
inputLensModelCalculatorImage
inputPredicateImage
inputSubsampling
inputEPS
CIDisparityRefinementV3
-[CIDepthEffectMakeBlurMap blurMapV3:shiftmap:alphaImage:]
lensModelParams
refinedShiftmap
CI_DISABLE_SEGMENTATION_FUSION
CISegmentationFusion
-[CIDepthEffectMakeBlurMap outputImage]
CIBlurmapSmoothing
inputShiftmapImage
T@"CIImage",&,VinputShiftmapImage
inputLeftEyePosition
T@"CIVector",&,VinputLeftEyePosition
inputRightEyePosition
T@"CIVector",&,VinputRightEyePosition
inputChinPosition
T@"CIVector",&,VinputChinPosition
inputFaceMidPoint
T@"CIVector",&,VinputFaceMidPoint
inputFocusRect
T@"CIVector",&,N,VinputFocusRect
inputCalibrationData
T@"AVCameraCalibrationData",&,N,VinputCalibrationData
inputAuxDataMetadata
T@,&,N,VinputAuxDataMetadata
SensorWidth
SensorHeight
CIPortraitBlur
inputBlurMap
T@"CIImage",&,VinputBlurMap
inputShiftMin
inputShiftMax
inputUseMipmaps
inputUseNativeImage
inputUseNormalizedDisparity
lumaNoiseScale
T@"CIImage",&,VinputDisparityImage
T@"NSNumber",&,N,VinputAperture
T@"NSNumber",&,N,VinputLumaNoiseScale
inputLeftEyePositions
T@"CIVector",&,VinputLeftEyePositions
inputRightEyePositions
T@"CIVector",&,VinputRightEyePositions
inputChinPositions
T@"CIVector",&,VinputChinPositions
inputNosePositions
T@"CIVector",&,VinputNosePositions
depthBlurEffect
UnpackedRenderingParameters
http://ns.apple.com/depthBlurEffect/1.0/
depthBlurEffect:UnpackedRenderingParameters
<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"> <plist version="1.0"> <dict> <key>DisparitySmoothing</key> <dict> <key>nIterations</key> <real>2</real> </dict> <key>NoiseEstimation</key> <dict> <key>HDR</key> <dict> <key>GainLevels</key> <array> <real>0.0</real> <real>1</real> <real>2</real> <real>4</real> <real>8</real> <real>16</real> <real>32</real> <real>64</real> </array> <key>NoiseLevels</key> <array> <real>0.0070000000000000001</real> <real>0.01</real> <real>0.014999999999999999</real> <real>0.017999999999999999</real> <real>0.02</real> <real>0.021999999999999999</real> <real>0.023</real> <real>0.025000000000000001</real> </array> </dict> <key>OIS</key> <dict> <key>GainLevels</key> <array> <real>0.0</real> <real>1</real> <real>2</real> <real>4</real> <real>8</real> <real>16</real> <real>32</real> <real>64</real> </array> <key>NoiseLevels</key> <array> <real>0.0070000000000000001</real> <real>0.01</real> <real>0.014999999999999999</real> <real>0.017999999999999999</real> <real>0.02</real> <real>0.021999999999999999</real> <real>0.023</real> <real>0.025000000000000001</real> </array> </dict> <key>SIS</key> <dict> <key>GainLevels</key> <array> <real>0.0</real> <real>1</real> <real>2</real> <real>4</real> <real>8</real> <real>16</real> <real>32</real> <real>64</real> </array> <key>NoiseLevels</key> <array> <real>0.0070000000000000001</real> <real>0.01</real> <real>0.014999999999999999</real> <real>0.017999999999999999</real> <real>0.02</real> <real>0.021999999999999999</real> <real>0.023</real> <real>0.025000000000000001</real> </array> </dict> <key>SingleImage</key> <dict> <key>GainLevels</key> <array> <real>0.0</real> <real>1</real> <real>2</real> <real>4</real> <real>8</real> <real>16</real> <real>32</real> <real>64</real> </array> <key>NoiseLevels</key> <array> <real>0.0050000000000000001</real> <real>0.0050000000000000001</real> <real>0.0070000000000000001</real> <real>0.01</real> <real>0.014999999999999999</real> <real>0.02</real> <real>0.028000000000000001</real> <real>0.033000000000000002</real> </array> </dict> </dict> <key>Rendering</key> <dict> <key>antiAliasBlurStrength</key> <real>0.15</real> <key>basePixelWeight</key> <real>9.9999999999999998e-13</real> <key>faces.capMultip</key> <real>1</real> <key>faces.chinThetaLimit</key> <real>1</real> <key>faces.chinThetaMultip</key> <real>1</real> <key>faces.chinVectorSnapping</key> <real>0.5</real> <key>faces.distToBlurScaling</key> <real>0.090999999999999998</real> <key>faces.eyeToEyebrowRatio</key> <real>1.3999999999999999</real> <key>faces.gainMultip</key> <real>1</real> <key>faces.linearBlurGrowthC</key> <real>0.00027901</real> <key>faces.linearBlurGrowthM</key> <real>0.01</real> <key>faces.maxBlurDistFromFocus</key> <real>0.00074405000000000001</real> <key>faces.maxBlurOnEyes</key> <real>0.0022000000000000001</real> <key>highlightBoostGain</key> <real>0.5</real> <key>lumaNoiseModelCoeff</key> <real>0.9</real> <key>lumaNoiseScale</key> <real>0.0025000000000000001</real> <key>maxBlur</key> <real>0.029999999999999999</real> <key>nSamples</key> <real>100</real> <key>relativeWeightThreshold</key> <real>0.0063120187260210497</real> <key>sharpRadius</key> <real>0.25</real> <key>softRadius</key> <real>1.5</real> <key>spatialWeightSoftMax</key> <real>1.05</real> <key>spatialWeightSoftMin</key> <real>0.94999999999999996</real> </dict> <key>RenderingV3</key> <dict> <key>preFilterRadius</key> <real>1</real> <key>preFilterBlurStrength</key> <real>0.05</real> <key>maxBlur</key> <real>0.03</real> <key>sharpRadius</key> <real>0.25</real> <key>softRadius</key> <real>1.5</real> <key>lumaNoiseModelCoeff</key> <real>0.9</real> <key>highlightBoostGain</key> <real>0.5</real> <key>nRings</key> <real>9</real> <key>basePixelWeight</key> <real>1E-12</real> <key>antiAliasBlurStrength</key> <real>0.6</real> <key>antiAliasRadius</key> <real>7</real> <key>relativeWeightThreshold</key> <real>0.00631201872602105</real> <key>alphaEpsilon</key> <real>0.05</real> <key>alphaGain</key> <real>2.0</real> <key>shapeObstructionCoeff</key> <real>0.7</real> <key>ringAmplitude</key> <real>2.0</real> <key>ringSharpness</key> <real>100.0</real> <key>xhlrbIterations</key> <real>50</real> <key>xhlrbBlurRadiusT0</key> <real>0.0025</real> <key>xhlrbBlurRadiusT1</key> <real>0.0075</real> <key>xhlrbMaxIntensityT0</key> <real>0.9</real> <key>xhlrbMaxIntensityT1</key> <real>1.0</real> <key>xhlrbMinIntensityT0</key> <real>0.0</real> <key>xhlrbMinIntensityT1</key> <real>0.2</real> <key>xhlrbExposureScoreT0</key> <real>1.0</real> <key>xhlrbExposureScoreT1</key> <real>5.0</real> <key>xhlrbClippedPixelsT0</key> <real>1.0</real> <key>xhlrbClippedPixelsT1</key> <real>5.0</real> <key>xhlrbRecoveryScoreT</key> <real>0.5</real> <key>xhlrbPreFilterGain</key> <real>25.0</real> <key>xhlrbWeightGain</key> <real>4.0</real> <key>xhlrbIntensityGain</key> <real>2.0</real> <key>faces.maxBlurOnEyes</key> <real>0.0022</real> <key>faces.maxBlurDistFromFocus</key> <real>7.4405e-04</real> <key>faces.eyeToEyebrowRatio</key> <real>1.4</real> <key>faces.linearBlurGrowthM</key> <real>0.01</real> <key>faces.linearBlurGrowthC</key> <real>2.7901e-4</real> <key>faces.distToBlurScaling</key> <real>0.091</real> <key>faces.capMultip</key> <real>1.0</real> <key>faces.gainMultip</key> <real>1.0</real> <key>faces.chinThetaLimit</key> <real>1.0</real> <key>faces.chinThetaMultip</key> <real>1.0</real> <key>faces.chinVectorSnapping</key> <real>0.5</real> </dict> <key>SLM</key> <dict> <key>fallbackFocusROI_height</key> <real>0.10000000000000001</real> <key>fallbackFocusROI_left</key> <real>0.45000000000000001</real> <key>fallbackFocusROI_top</key> <real>0.45000000000000001</real> <key>fallbackFocusROI_width</key> <real>0.10000000000000001</real> <key>maxFGBlur</key> <real>0.00020000000000000001</real> <key>shiftDeadZone</key> <real>0.29999999999999999</real> <key>simulatedAperture</key> <real>4.5</real> <key>zeroShiftPercentile</key> <real>0.75</real> </dict> <key>BlurMapSmoothing</key> <dict> <key>nIterations</key> <real>5</real> <key>originalBlurValueT0</key> <real>0.2</real> <key>originalBlurValueT1</key> <real>0.5</real> <key>localMinimumBlurValueT0</key> <real>0.05</real> <key>localMinimumBlurValueT1</key> <real>0.3</real> </dict> </dict> </plist>
SDOFParameterValue_block_invoke
sdofParameters
SDOFParameterValue
value
Fusion
depthBlurEffect:RenderingParameters
shiftDeadZone
maximumSimulatedAperture
faces.linearBlurGrowthC
faces.linearBlurGrowthM
faces.distToBlurScaling
faces.eyeToEyebrowRatio
zeroShiftPercentile
maxFGBlur
iterations
preFilterGain
weightGain
intensityGain
mode
blurRadiusT0
blurRadiusT1
maxIntensityT0
maxIntensityT1
minIntensityT0
minIntensityT1
faces.maxBlurOnEyes
faces.maxBlurDistFromFocus
faces.capMultip
faces.gainMultip
shapeObstructionCoeff
ringAmplitude
ringSharpness
minimumSimulatedAperture
antiAliasRadius
alphaEpsilon
alphaGain
nRings
preFilterBlurStrength
preFilterRadius
blendingQuarterResAlphaGain
blendingFullResAlphaGain
simulatedAperture
depthBlurEffect:SimulatedAperture
depthData:IntrinsicMatrixReferenceWidth
depthData:IntrinsicMatrixReferenceHeight
RenderingParameters
CI_SDOF_DICT
sdofrendering_parameters
kernel vec2 _pixellate (vec2 c, vec2 params) { return (floor((destCoord() - c) * params.x) + 0.5) * params.y + c; }
kernel vec4 _hexagonalPixellate(sampler src, vec2 center, vec2 skew_to_unit, vec2 unit_to_skew, float sqrt3inv) 
 vec2 t0 = destCoord() - center; 
 vec2 t0_skewed = t0; 
 t0_skewed.x -= t0_skewed.y * sqrt3inv; 
 vec2 t0_unit = t0_skewed * skew_to_unit; 
 vec2 t0_slot = floor(t0_unit); 
 vec2 t0_offset = t0_unit - t0_slot; 
 vec2 t0_base = t0_slot * unit_to_skew; 
 vec2 p0 = t0_base; 
 vec2 p1 = t0_base; 
 p1.y = p1.y + unit_to_skew.y; 
 vec2 p2 = t0_base; 
 p2.x = p2.x + unit_to_skew.x; 
 vec2 p3 = t0_base + unit_to_skew; 
 p0 = compare(vec2(t0_offset.x + t0_offset.y - 1.0), p0, p3); 
 p0.x += p0.y * sqrt3inv; 
 p1.x += p1.y * sqrt3inv; 
 p2.x += p2.y * sqrt3inv; 
 vec2 d0 = t0 - p0; 
 d0 = d0 * d0; 
 float d1 = d0.x + d0.y; 
 vec3 s0 = vec3(p0, d1 * inversesqrt(d1)); 
 d0 = t0 - p1; 
 d0 = d0 * d0; 
 d1 = d0.x + d0.y; 
 vec3 s1 = vec3(p1, d1 * inversesqrt(d1)); 
 d0 = t0 - p2; 
 d0 = d0 * d0; 
 d1 = d0.x + d0.y; 
 vec3 s2 = vec3(p2, d1 * inversesqrt(d1)); 
 vec3 desc = vec3(s0.z - s1.z); 
 vec3 s3 = compare(desc, s0, s1); 
 vec3 s4 = compare(desc, s1, s0); 
 desc = vec3(s3.z - s4.z); 
 vec3 s5 = compare(desc, s3, s2); 
 vec3 s6 = compare(desc, s2, s3); 
 desc = vec3(s4.z - s6.z); 
 vec3 s7 = compare(desc, s4, s6); 
 vec4 c0 = sample(src, samplerTransform(src, s5.xy + center)); 
 vec4 c1 = sample(src, samplerTransform(src, s7.xy + center)); 
 return mix(c0, c1, clamp((s5.z - s7.z) * 0.5 + 0.5, 0.0, 1.0)); 
kernel vec4 _sharpenLuminance(__sample ip, __sample bl, float s) 
 vec3 luminance = vec3(0.299, 0.587, 0.114); 
 vec3 invLuminance = vec3(1.0, -0.5093696763, -0.1942078365); 
 float intensity = 1.0 + s; 
 vec3 s0,s1; 
 s0.x = dot(luminance, bl.rgb); 
 s0.yz = bl.rb - s0.x; 
 s1.x = dot(luminance, ip.rgb); 
 s1.yz = ip.rb - s1.x; 
 s0 = mix(s0,s1, intensity); 
 ip.g = dot(invLuminance, s0); 
 ip.rb = s0.yz + s0.x; 
 return ip; 
inputOpacity
kernel vec4 _swipeTransition(__sample src0, __sample src1, __color color, vec4 parms) 
 float k1 = clamp(dot(vec4(destCoord(), 1.0, 0.0), parms), 0.0, 1.0); 
 float k0 = min(1.0-k1, k1) * 2.0 * parms.w; 
 return mix(mix(src1, src0, k1), color, k0); 
T@"NSNumber",&,N,VinputOpacity
inputFGThresholdValue
inputBGThresholdValue
inputErosionKernelSize
inputUseDepthFilter
construct_fragment_shader
compile_kernel
enqueueForRect
compute_quad
release_resources
purge_wired_intermediates
link_shaders
CI_PRINT_TIME 
%s = %.1f ms
~Timer
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/misc/CITimer.cpp
atomic_load(&sLogLevel) > 0
T@"NSNumber",&,N,VinputWeights
kernel vec4 _maxDisk (sampler i, float r) 
 vec2 dc = destCoord(); 
 vec4 v = sample(i, samplerCoord(i)); 
 float rr = ceil(r); 
 float r2 = r*r; 
 float x,y; 
 for (x = -rr; x<=rr; x+=1.0) 
 for (y = -rr; y<=rr; y+=1.0) 
 vec2 p = vec2(x,y); 
 if (dot(p,p)<=r2) 
 v = max(v, sample(i, samplerTransform(i,dc+p))); 
 return v; 
kernel vec4 _minDisk (sampler i, float r) 
 vec2 dc = destCoord(); 
 vec4 v = sample(i, samplerCoord(i)); 
 float rr = ceil(r); 
 float r2 = r*r; 
 float x,y; 
 for (x = -rr; x<=rr; x+=1.0) 
 for (y = -rr; y<=rr; y+=1.0) 
 vec2 p = vec2(x,y); 
 if (dot(p,p)<=r2) 
 v = min(v, sample(i, samplerTransform(i,dc+p))); 
 return v; 
kernel vec4 _max3x3 (sampler s, vec4 d) 
 vec2 p = destCoord (); 
 vec4 c = sample(s, samplerTransform(s, p - d.yy)); 
 c = max(c, sample(s, samplerTransform(s, p - d.wx))); 
 c = max(c, sample(s, samplerTransform(s, p + d.yz))); 
 c = max(c, sample(s, samplerTransform(s, p - d.xw))); 
 c = max(c, sample(s, samplerTransform(s, p ))); 
 c = max(c, sample(s, samplerTransform(s, p + d.xw))); 
 c = max(c, sample(s, samplerTransform(s, p - d.yz))); 
 c = max(c, sample(s, samplerTransform(s, p + d.wx))); 
 c = max(c, sample(s, samplerTransform(s, p + d.yy))); 
 return c; 
kernel vec4 _min3x3 (sampler s, vec4 d) 
 vec2 p = destCoord (); 
 vec4 c = sample(s, samplerTransform(s, p - d.yy)); 
 c = min(c, sample(s, samplerTransform(s, p - d.wx))); 
 c = min(c, sample(s, samplerTransform(s, p + d.yz))); 
 c = min(c, sample(s, samplerTransform(s, p - d.xw))); 
 c = min(c, sample(s, samplerTransform(s, p ))); 
 c = min(c, sample(s, samplerTransform(s, p + d.xw))); 
 c = min(c, sample(s, samplerTransform(s, p - d.yz))); 
 c = min(c, sample(s, samplerTransform(s, p + d.wx))); 
 c = min(c, sample(s, samplerTransform(s, p + d.yy))); 
 return c; 
kernel vec4 _gradient (__sample sMax, __sample sMin) 
 return vec4( (sMax.rgb - sMin.rgb) * .5, sMax.a); 
kernel vec4 _laplacian (__sample s, __sample sMax, __sample sMin) 
 return vec4( (sMax.rgb + sMin.rgb - 2.0 * s.rgb) * .5, s.a); 
kernel vec4 _average (__sample s0, __sample s1, float w) 
 return mix(s0, s1, w); 
2.006 -   May 13, 2015
1.021 - Aug 1, 2013
BurstSet_AlgorithmVersion
Image_ISPFacesArray
Image_ImageScore
Image_Timestamp
Image_YUVData
ImageYUVWidth
ImageYUVHeight
ImageYData
ImageUVData
ImageYUVBytesPerRow
Image_TimeReceived
Image_TimeQueued
Image_TimeConverted
Image_TimeStartedAnalysis
Image_TimeStartedFaceDetection
Image_TimeDoneFaceDetection
Image_TimeDoneFaceBlinkDetection
Image_TimeDoneFaceFocusScore
Image_TimeDoneAnalysis
ImageFace_ID
ImageFaceX
ImageFaceY
ImageFaceW
ImageFaceH
ImageFaceFocusScore
ImageFaceLeftEyeOpen
ImageFaceRightEyeOpen
ImageFaceSmiling
ImageFaceLeftEyePosX
ImageFaceLeftEyePosY
ImageFaceRightEyePosX
ImageFaceRightEyePosY
ImageFaceTimestamp
ImageFaceRollAngle
ImageFaceYawAngle
ImageFaceLeftEyeBlinkScore
ImageFaceRightEyeBlinkScore
ImageFaceSmileScore
ImageFaceSmallFace
ImageSet_Version
ImageSetVersion_Default
ImageSetVersion_Latest
BurstSet_TimeDoneCapturing
BurstSet_TimeDone
BurstSet_Setting_MaxNumPendingFrames
BurstSet_Setting_DisableAnalysis
BurstSet_Setting_DisableFaceCore
BurstSet_Setting_DummyAnalysisCount
BurstSet_Setting_ForceFaceDetection
BurstSet_Setting_EnableDumpYUV
BurstSet_IsAction
BurstSet_IsPortrait
BurstSet_CoverImage
BURST ANALYSIS VERSION = %s (%s)
   initWithBurstImageSet - Error: stats not found
fosl_filter_interface_version
fosl_filter_kernelpool_createPool
fosl_filter_kernelpool_hasError
fosl_filter_kernelpool_addLibrary
fosl_filter_kernelpool_addString
fosl_filter_kernelpool_destroyPool
fosl_filter_kernelpool_getNumKernels
fosl_filter_kernelpool_lookupKernel
fosl_filter_kernelpool_getKernelByIdx
fosl_filter_kernelpool_getNumDiagnostics
fosl_filter_kernelpool_getDiagnosticByIdx
fosl_filter_kernelpool_getKernelKind
fosl_filter_kernelpool_getKernelReturnType
fosl_filter_kernelpool_getKernelName
fosl_filter_kernelpool_getPrintedKernel
fosl_filter_kernelpool_getKernelDimensionality
fosl_filter_kernelpool_isPositionInvariant
fosl_filter_kernelpool_preservesAlpha
fosl_filter_kernelpool_getNumKernelParameters
fosl_filter_kernelpool_getParamName
fosl_filter_kernelpool_getParamType
fosl_filter_kernelpool_getNumKernelAttributes
fosl_filter_kernelpool_getAttributeKeyword
fosl_filter_kernelpool_getAttributeParameters
fosl_filter_kernelpool_hasAttributeParameters
fosl_filter_createGraph
fosl_filter_assignRoot
fosl_filter_destroyGraph
fosl_filter_createKernel
fosl_filter_addLibraryFunction
fosl_filter_addChild
fosl_filter_createSampler
fosl_filter_createImage
fosl_filter_createUniform
fosl_filter_createConstant
fosl_filter_createTransformMatrix
fosl_filter_createSampleTransform
fosl_filter_createUsePosition
fosl_filter_createPositionUpdate
fosl_filter_createCoordinateTransform
fosl_filter_setPositionUpdatePosition
fosl_filter_setPositionUpdateContinuation
fosl_filter_setSamplerNeedsSRGBToLinear
fosl_filter_setSamplerSwizzleMask
fosl_filter_setSamplerSwizzleMacro
fosl_filter_setMainEntryPointName
fosl_filter_parseNodesInGraph
fosl_filter_synthesizeMainInGraph
fosl_filter_synthesizeMainInGraphOfType
fosl_filter_synthesizeMainInGraphOfTypeWithOptions
fosl_filter_dumpGraph
fosl_filter_printGraph
fosl_filter_getStringForGraph
fosl_filter_getStringForGraphWithOptions
/usr/lib/libFosl_dynamic.dylib
IPHONE_SIMULATOR_ROOT
Core Image Fosl wrapper: Unable to determine iPhone simulator root SDK path.
%s%s
Unable to open Fosl library at path %s
foslFunctions
kernel vec2 _holeDistortion (vec2 center, float radius2) 
 vec2 delta = destCoord() - center; 
 float dist2 = dot(delta,delta); 
 return (dist2 <= radius2) ? center : (destCoord() - delta * radius2 / dist2); 
kernel vec4 _holeAntialias(__sample src, vec2 center, float radius) 
 return src * clamp(length(destCoord() - center) - radius, 0.0, 1.0); 
kernel vec4 _box4(sampler src) 
 vec2 d = destCoord() * 4.0; 
 vec4 q0 = sample(src, samplerTransform(src, d + vec2(-1.0, -1.0))); 
 vec4 q1 = sample(src, samplerTransform(src, d + vec2(-1.0, +1.0))); 
 vec4 q2 = sample(src, samplerTransform(src, d + vec2(+1.0, -1.0))); 
 vec4 q3 = sample(src, samplerTransform(src, d + vec2(+1.0, +1.0))); 
 return 0.25*(q0+q1+q2+q3); 
kernel vec4 _box6(sampler src) 
 vec2 d = destCoord() * 6.0; 
 vec4 q0 = sample(src, samplerTransform(src, d + vec2(-2.0, -2.0))); 
 vec4 q1 = sample(src, samplerTransform(src, d + vec2( 0.0, -2.0))); 
 vec4 q2 = sample(src, samplerTransform(src, d + vec2(+2.0, -2.0))); 
 vec4 q3 = sample(src, samplerTransform(src, d + vec2(-2.0, 0.0))); 
 vec4 q4 = sample(src, samplerTransform(src, d + vec2( 0.0, 0.0))); 
 vec4 q5 = sample(src, samplerTransform(src, d + vec2(+2.0, 0.0))); 
 vec4 q6 = sample(src, samplerTransform(src, d + vec2(-2.0, +2.0))); 
 vec4 q7 = sample(src, samplerTransform(src, d + vec2( 0.0, +2.0))); 
 vec4 q8 = sample(src, samplerTransform(src, d + vec2(+2.0, +2.0))); 
 return (1.0/9.0)*(q0+q1+q2+q3+q4+q5+q6+q7+q8); 
kernel vec4 _cross4(sampler src, float weight) 
 vec2 d = destCoord(); 
 vec4 q0 = sample(src, samplerTransform(src, d)); 
 vec4 q1 = sample(src, samplerTransform(src, d - vec2(+0.5, +1.5))); 
 vec4 q2 = sample(src, samplerTransform(src, d + vec2(+0.5, +1.5))); 
 vec4 q3 = sample(src, samplerTransform(src, d - vec2(+1.5, -0.5))); 
 vec4 q4 = sample(src, samplerTransform(src, d + vec2(+1.5, -0.5))); 
 q1 = 0.23*(q1+q2+q3+q4) + 0.08*q0; 
 return mix(q0,q1, weight); 
kernel vec4 _minimumComponent (__sample s) { return vec4(vec3(min(min(s.r,s.g),s.b)), s.a); }
kernel vec4 _maximumComponent (__sample s) { return vec4(vec3(max(max(s.r,s.g),s.b)), s.a); }
kernel vec2 _vortexDistortion(vec2 center, vec2 params) 
 vec2 d = destCoord() - center; 
 float len = length(d); 
 float r = len * params.x - 1.0; 
 float a = r * r * params.y / len; 
 vec2 sc = vec2(cos(a), sin(a)); 
 vec2 p = vec2(dot(d, sc), dot(d, vec2(-sc.y, sc.x))); 
 return (r >= 0.0) ? destCoord() : p+center; 
kernel vec4 _lanczosDown2(sampler src, vec4 scale) 
 vec2 d = destCoord() * scale.xy; 
 vec2 o0 = scale.zw * 0.732871; 
 vec2 o1 = scale.zw * 2.83784; 
 vec2 o2 = scale.zw * 4.6968; 
 vec4 q0 = sample(src, samplerTransform(src, d - o2)); 
 vec4 q1 = sample(src, samplerTransform(src, d - o1)); 
 vec4 q2 = sample(src, samplerTransform(src, d - o0)); 
 vec4 q3 = sample(src, samplerTransform(src, d + o0)); 
 vec4 q4 = sample(src, samplerTransform(src, d + o1)); 
 vec4 q5 = sample(src, samplerTransform(src, d + o2)); 
 return (0.581891)*(q2+q3) + (-0.100636)*(q1+q4) + (0.0187453)*(q0+q5); 
float _lanc3h (float x) 
 x = abs(x); 
 if (x >= 3.0) return 0.0; 
 if (x < 1e-3) return 1.0; 
 x *= 3.141592653589793; 
 return 3.0*sin(x)*sin(x/3.0) / (x*x); 
 kernel vec4 _lanczosDownH(sampler src, vec4 scale) 
 vec2 c = destCoord() * scale.xy; 
 vec2 pm1 = vec2(floor(c.x-0.5)+0.5, c.y); 
 vec2 pm6 = pm1 - scale.zw * 5.0; 
 vec2 pm5 = pm1 - scale.zw * 4.0; 
 vec2 pm4 = pm1 - scale.zw * 3.0; 
 vec2 pm3 = pm1 - scale.zw * 2.0; 
 vec2 pm2 = pm1 - scale.zw * 1.0; 
 vec2 pp1 = pm1 + scale.zw * 1.0; 
 vec2 pp2 = pm1 + scale.zw * 2.0; 
 vec2 pp3 = pm1 + scale.zw * 3.0; 
 vec2 pp4 = pm1 + scale.zw * 4.0; 
 vec2 pp5 = pm1 + scale.zw * 5.0; 
 vec2 pp6 = pm1 + scale.zw * 6.0; 
 vec4 vm6 = sample(src, samplerTransform(src, pm6)); 
 vec4 vm5 = sample(src, samplerTransform(src, pm5)); 
 vec4 vm4 = sample(src, samplerTransform(src, pm4)); 
 vec4 vm3 = sample(src, samplerTransform(src, pm3)); 
 vec4 vm2 = sample(src, samplerTransform(src, pm2)); 
 vec4 vm1 = sample(src, samplerTransform(src, pm1)); 
 vec4 vp1 = sample(src, samplerTransform(src, pp1)); 
 vec4 vp2 = sample(src, samplerTransform(src, pp2)); 
 vec4 vp3 = sample(src, samplerTransform(src, pp3)); 
 vec4 vp4 = sample(src, samplerTransform(src, pp4)); 
 vec4 vp5 = sample(src, samplerTransform(src, pp5)); 
 vec4 vp6 = sample(src, samplerTransform(src, pp6)); 
 float wm6 = _lanc3h((pm6.x-c.x)/scale.x); 
 float wm5 = _lanc3h((pm5.x-c.x)/scale.x); 
 float wm4 = _lanc3h((pm4.x-c.x)/scale.x); 
 float wm3 = _lanc3h((pm3.x-c.x)/scale.x); 
 float wm2 = _lanc3h((pm2.x-c.x)/scale.x); 
 float wm1 = _lanc3h((pm1.x-c.x)/scale.x); 
 float wp1 = _lanc3h((pp1.x-c.x)/scale.x); 
 float wp2 = _lanc3h((pp2.x-c.x)/scale.x); 
 float wp3 = _lanc3h((pp3.x-c.x)/scale.x); 
 float wp4 = _lanc3h((pp4.x-c.x)/scale.x); 
 float wp5 = _lanc3h((pp5.x-c.x)/scale.x); 
 float wp6 = _lanc3h((pp6.x-c.x)/scale.x); 
 float wsum = wm6+wm5+wm4+wm3+wm2+wm1+wp1+wp2+wp3+wp4+wp5+wp6; 
 return (wm6*vm6 + wm5*vm5 + wm4*vm4 + wm3*vm3 + wm2*vm2 + wm1*vm1 + 
 wp6*vp6 + wp5*vp5 + wp4*vp4 + wp3*vp3 + wp2*vp2 + wp1*vp1)/wsum; 
float _lanc3v (float x) 
 x = abs(x); 
 if (x >= 3.0) return 0.0; 
 if (x < 1e-3) return 1.0; 
 x *= 3.141592653589793; 
 return 3.0*sin(x)*sin(x/3.0) / (x*x); 
 kernel vec4 _lanczosDownV(sampler src, vec4 scale) 
 vec2 c = destCoord() * scale.xy; 
 vec2 pm1 = vec2(c.x, floor(c.y-0.5)+0.5); 
 vec2 pm6 = pm1 - scale.zw * 5.0; 
 vec2 pm5 = pm1 - scale.zw * 4.0; 
 vec2 pm4 = pm1 - scale.zw * 3.0; 
 vec2 pm3 = pm1 - scale.zw * 2.0; 
 vec2 pm2 = pm1 - scale.zw * 1.0; 
 vec2 pp1 = pm1 + scale.zw * 1.0; 
 vec2 pp2 = pm1 + scale.zw * 2.0; 
 vec2 pp3 = pm1 + scale.zw * 3.0; 
 vec2 pp4 = pm1 + scale.zw * 4.0; 
 vec2 pp5 = pm1 + scale.zw * 5.0; 
 vec2 pp6 = pm1 + scale.zw * 6.0; 
 vec4 vm6 = sample(src, samplerTransform(src, pm6)); 
 vec4 vm5 = sample(src, samplerTransform(src, pm5)); 
 vec4 vm4 = sample(src, samplerTransform(src, pm4)); 
 vec4 vm3 = sample(src, samplerTransform(src, pm3)); 
 vec4 vm2 = sample(src, samplerTransform(src, pm2)); 
 vec4 vm1 = sample(src, samplerTransform(src, pm1)); 
 vec4 vp1 = sample(src, samplerTransform(src, pp1)); 
 vec4 vp2 = sample(src, samplerTransform(src, pp2)); 
 vec4 vp3 = sample(src, samplerTransform(src, pp3)); 
 vec4 vp4 = sample(src, samplerTransform(src, pp4)); 
 vec4 vp5 = sample(src, samplerTransform(src, pp5)); 
 vec4 vp6 = sample(src, samplerTransform(src, pp6)); 
 float wm6 = _lanc3v((pm6.y-c.y)/scale.y); 
 float wm5 = _lanc3v((pm5.y-c.y)/scale.y); 
 float wm4 = _lanc3v((pm4.y-c.y)/scale.y); 
 float wm3 = _lanc3v((pm3.y-c.y)/scale.y); 
 float wm2 = _lanc3v((pm2.y-c.y)/scale.y); 
 float wm1 = _lanc3v((pm1.y-c.y)/scale.y); 
 float wp1 = _lanc3v((pp1.y-c.y)/scale.y); 
 float wp2 = _lanc3v((pp2.y-c.y)/scale.y); 
 float wp3 = _lanc3v((pp3.y-c.y)/scale.y); 
 float wp4 = _lanc3v((pp4.y-c.y)/scale.y); 
 float wp5 = _lanc3v((pp5.y-c.y)/scale.y); 
 float wp6 = _lanc3v((pp6.y-c.y)/scale.y); 
 float wsum = wm6+wm5+wm4+wm3+wm2+wm1+wp1+wp2+wp3+wp4+wp5+wp6; 
 return (wm6*vm6 + wm5*vm5 + wm4*vm4 + wm3*vm3 + wm2*vm2 + wm1*vm1 + 
 wp6*vp6 + wp5*vp5 + wp4*vp4 + wp3*vp3 + wp2*vp2 + wp1*vp1)/wsum; 
kernel vec4 _lanczosUpH(sampler src, float scale) 
 vec4 w; 
 vec2 c = destCoord(); 
 c.x = scale*c.x - 0.5; 
 vec2 d = c; 
 c.x = floor(c.x); 
 float x = (c.x - d.x + 1.0); 
 w.z = x*x*(x*(x*(x*-0.41086841 + 0.78286595) + 1.04059357) - 2.41189213) + 1.0; 
 w.x = x*x*(x*(x*(x*-0.29216512 + 1.02524562) - 0.52422910) - 0.20885140); 
 x = 1.0-x; 
 w.y = x*x*(x*(x*(x*-0.41086841 + 0.78286595) + 1.04059357) - 2.41189213) + 1.0; 
 w.w = 1.0 - w.x - w.y - w.z; 
 vec4 p0 = sample(src, samplerTransform(src, c + vec2(-0.5,0.0))); 
 vec4 p1 = sample(src, samplerTransform(src, c + vec2(+0.5,0.0))); 
 vec4 p2 = sample(src, samplerTransform(src, c + vec2(+1.5,0.0))); 
 vec4 p3 = sample(src, samplerTransform(src, c + vec2(+2.5,0.0))); 
 return w.x*p0 + w.y*p1 + w.z*p2 + w.w*p3; 
kernel vec4 _lanczosUpV(sampler src, float scale) 
 vec4 w; 
 vec2 c = destCoord(); 
 c.y = scale*c.y - 0.5; 
 vec2 d = c; 
 c.y = floor(c.y); 
 float x = (c.y - d.y + 1.0); 
 w.z = x*x*(x*(x*(x*-0.41086841 + 0.78286595) + 1.04059357) - 2.41189213) + 1.0; 
 w.x = x*x*(x*(x*(x*-0.29216512 + 1.02524562) - 0.52422910) - 0.20885140); 
 x = 1.0-x; 
 w.y = x*x*(x*(x*(x*-0.41086841 + 0.78286595) + 1.04059357) - 2.41189213) + 1.0; 
 w.w = 1.0 - w.x - w.y - w.z; 
 vec4 p0 = sample(src, samplerTransform(src, c + vec2(0.0,-0.5))); 
 vec4 p1 = sample(src, samplerTransform(src, c + vec2(0.0,+0.5))); 
 vec4 p2 = sample(src, samplerTransform(src, c + vec2(0.0,+1.5))); 
 vec4 p3 = sample(src, samplerTransform(src, c + vec2(0.0,+2.5))); 
 return w.y*p1 + w.z*p2 + w.x*p0 + w.w*p3; 
kernel vec4 _mix (__sample f, __sample b, float k) { return mix(b,f,k); }
kernel vec4 _blendWithMask (__sample f, __sample b, __sample m) { return mix(b,f,m.g); }
kernel vec4 _blendWithMaskB0 (__sample f, __sample m) { return f*m.g; }
kernel vec4 _blendWithRedMask (__sample f, __sample b, __sample m) { return mix(b,f,m.r); }
kernel vec4 _blendWithRedMaskB0 (__sample f, __sample m) { return f*m.r; }
kernel vec4 _blendWithBlueMask (__sample f, __sample b, __sample m) { return mix(b,f,m.b); }
kernel vec4 _blendWithBlueMaskB0 (__sample f, __sample m) { return f*m.b; }
kernel vec4 _blendWithAlphaMask (__sample f, __sample b, __sample m) { return mix(b,f,m.a); }
kernel vec4 _blendWithAlphaMaskB0 (__sample f, __sample m) { return f*m.a; }
initWithCGImage: %dx%d
Ti,Vwidth
Ti,Vheight
Ti,VbytesPerRow
Ybuffer
T*,VYbuffer
Cbuffer
T*,VCbuffer
Kernel %@ should be of class CIColorKernel
mc00
mc01
mc02
mc10
mc11
mc12
mc20
mc21
mc22
bknd
btpnt
btwid
blamt
bamt
otrcS0
otrcS1
otrcS2
otrcS3
otrcS4
otrcY1
otrcY2
otrcY3
kernel vec4 _convertUsingColorMatrix(__sample pix, vec4 rv, vec4 gv, vec4 bv) { 
 vec4 color = pix.r * rv + pix.g * gv + pix.b * bv; 
 color.a = pix.a; 
 return color; 
CIRAWGamutMapping: key %@ was not found in the RAW dictionary
kernel vec4 _localBoost(__sample color, vec4 breaks, vec4 coeffs1, vec4 coeffs2, vec4 coeffs3, vec4 coeffs4, float scaleAboveOne) { 
 float x; 
 vec4 powers, interval1, interval2, interval3, interval4, answer; 
 x = color.r; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.r = dot(powers, coeffs1); 
 interval2.r = dot(powers, coeffs2); 
 interval3.r = dot(powers, coeffs3); 
 interval4.r = dot(powers, coeffs4); 
 answer.r = (x - 1.0) * scaleAboveOne + 1.0; 
 x = color.g; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.g = dot(powers, coeffs1); 
 interval2.g = dot(powers, coeffs2); 
 interval3.g = dot(powers, coeffs3); 
 interval4.g = dot(powers, coeffs4); 
 answer.g = (x - 1.0) * scaleAboveOne + 1.0; 
 x = color.b; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.b = dot(powers, coeffs1); 
 interval2.b = dot(powers, coeffs2); 
 interval3.b = dot(powers, coeffs3); 
 interval4.b = dot(powers, coeffs4); 
 answer.b = (x - 1.0) * scaleAboveOne + 1.0; 
 answer = compare(color - breaks.w, interval4, answer); 
 answer = compare(color - breaks.z, interval3, answer); 
 answer = compare(color - breaks.y, interval2, answer); 
 answer = compare(color - breaks.x, interval1, answer); 
 answer = compare(color, vec4(0.0), answer); 
 answer.a = color.a; 
 return answer; 
kernel vec4 _boostRGB(__sample color, vec4 breaks, vec4 coeffs1, vec4 coeffs2, vec4 coeffs3, vec4 coeffs4, float scaleAboveOne) { 
 float x; 
 vec4 powers, interval1, interval2, interval3, interval4, answer; 
 x = color.r; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.r = dot(powers, coeffs1); 
 interval2.r = dot(powers, coeffs2); 
 interval3.r = dot(powers, coeffs3); 
 interval4.r = dot(powers, coeffs4); 
 answer.r = (x - 1.0) * scaleAboveOne + 1.0; 
 x = color.g; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.g = dot(powers, coeffs1); 
 interval2.g = dot(powers, coeffs2); 
 interval3.g = dot(powers, coeffs3); 
 interval4.g = dot(powers, coeffs4); 
 answer.g = (x - 1.0) * scaleAboveOne + 1.0; 
 x = color.b; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.b = dot(powers, coeffs1); 
 interval2.b = dot(powers, coeffs2); 
 interval3.b = dot(powers, coeffs3); 
 interval4.b = dot(powers, coeffs4); 
 answer.b = (x - 1.0) * scaleAboveOne + 1.0; 
 answer = compare(color - breaks.w, interval4, answer); 
 answer = compare(color - breaks.z, interval3, answer); 
 answer = compare(color - breaks.y, interval2, answer); 
 answer = compare(color - breaks.x, interval1, answer); 
 answer = compare(color, vec4(0.0), answer); 
 answer = compare(answer, vec4(0.0), answer); 
 answer.a = color.a; 
 return answer; 
kernel vec4 _boostRGBLNoGamma(__sample color, vec4 breaks, vec4 coeffs1, vec4 coeffs2, vec4 coeffs3, vec4 coeffs4, float scaleAboveOne) { 
 float x, luminance; 
 vec4 powers, interval1, interval2, interval3, interval4, answer, xcolor; 
 x = color.r; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.r = dot(powers, coeffs1); 
 interval2.r = dot(powers, coeffs2); 
 interval3.r = dot(powers, coeffs3); 
 interval4.r = dot(powers, coeffs4); 
 x = color.g; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.g = dot(powers, coeffs1); 
 interval2.g = dot(powers, coeffs2); 
 interval3.g = dot(powers, coeffs3); 
 interval4.g = dot(powers, coeffs4); 
 x = color.b; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.b = dot(powers, coeffs1); 
 interval2.b = dot(powers, coeffs2); 
 interval3.b = dot(powers, coeffs3); 
 interval4.b = dot(powers, coeffs4); 
 luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114)); 
 x = luminance; 
 powers.rgb = vec3(x); 
 powers.rg = powers.rg * vec2(x); 
 powers.r = powers.r * x; 
 powers.a = 1.0; 
 interval1.a = dot(powers, coeffs1); 
 interval2.a = dot(powers, coeffs2); 
 interval3.a = dot(powers, coeffs3); 
 interval4.a = dot(powers, coeffs4); 
 xcolor = color; 
 xcolor.a = luminance; 
 answer = xcolor*scaleAboveOne + vec4(1.0-scaleAboveOne); 
 answer = compare(xcolor - breaks.w, interval4, answer); 
 answer = compare(xcolor - breaks.z, interval3, answer); 
 answer = compare(xcolor - breaks.y, interval2, answer); 
 answer = compare(xcolor - breaks.x, interval1, answer); 
 return answer; 
kernel vec4 _boostHybrid(__sample color, sampler rgblboostnogamma, float transitionBreakpoint, float transitionWidth, float luminanceAmount) { 
 float luminance, factor, interpolant; 
 vec4 xcolor, answer; 
 luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114)); 
 answer = sample(rgblboostnogamma, samplerCoord(rgblboostnogamma)); 
 xcolor = color; 
 xcolor.a = luminance; 
 answer = compare(xcolor, vec4(0.0), answer); 
 answer = max(answer, vec4(0.0)); 
 factor = answer.a / max(luminance, 0.000001); 
 color.rgb = color.rgb * vec3(factor); 
 color.rgb = max(color.rgb, vec3(0.0)); 
 interpolant = clamp((luminance - (transitionBreakpoint - transitionWidth * 0.5)) / transitionWidth, 0.0, 1.0); 
 interpolant = 1.0 - ((3.0 - 2.0 * interpolant) * interpolant * interpolant); 
 interpolant = interpolant * luminanceAmount; 
 color.rgb = mix(answer.rgb, color.rgb, interpolant); 
 return color; 
<CIFilterShape: %p extent [infinite]>
<CIFilterShape: %p extent [empty]>
<CIFilterShape: %p extent [%g %g %g %g]>
warpkernel %s
kernel vec2 _tile(vec2 origin, vec4 scaling) {return fract((destCoord() - origin) * scaling.zw) * scaling.xy + origin;} 
kernel vec2 _lowq_affine(vec2 center, vec2 xvec, vec2 yvec) 
 vec2 p = destCoord(); 
 return center + vec2(dot(p, xvec), dot(p, yvec)); 
[CIAffineTile inputTransfom] is not a valid object.
[CIAffineClamp inputTransfom] is not a valid object.
kernel vec2 _circleSplash(vec2 center, float radius) 
 vec2 r0; 
 float r1, r2; 
 r0 = destCoord() - center; 
 r1 = dot (r0, r0); 
 r2 = inversesqrt (r1); 
 r1 = r1 * r2; 
 r0 = r0 * r2; 
 r1 = min(r1, radius); 
 r0 = r0 * r1 + center; 
 return r0; 
inputCompression
kernel vec4 _modTransition (__sample src0, __sample src1, vec2 center, vec4 parms, vec4 xform, vec4 botparms, vec4 topparms) 
 vec2 offset = destCoord() - center, vv; 
 float r = offset.x * parms.z; 
 float a = botparms.z / (r * botparms.x + botparms.y) + botparms.w; 
 float b = topparms.z / (r * topparms.x + topparms.y) + topparms.w; 
 float v = (r<0.5) ? a : b; 
 vv = vec2(v * parms.w, offset.y); 
 vv = vec2(dot(vv, xform.xy), dot(vv, xform.zw)); 
 vv = fract(vv + center); 
 vv = 2.0 * min(vv, vec2(1.0) - vv); 
 float len = clamp(length(vv)* parms.x + parms.y, 0.0, 1.0); 
 return mix(src1, src0, len); 
T@"NSNumber",&,N,VinputCompression
projectionRows_planar8UtoF
projectionCols_planar8UtoF
Projections_status Projections_projectionRowsCols_planar8UtoF(const uint8_t *, int, int, size_t, float *, float *)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/api/Burst/Projections/Projections_Core.c
Projections_status Projections_computeProjectionDerivative(const float *, int, float *)
kernel vec4 _copyMachineTransition (__sample src0, __sample src1, vec3 parms2, vec4 multiplier, vec4 color, vec3 parms) 
 vec4 v = vec4(destCoord(), parms.x, 1.0); 
 float k = clamp(dot(v, multiplier), 0.0, 1.0); 
 float j = clamp(min(k * parms2.x + parms2.y, k * parms2.z), 0.0, 1.0) * parms.y; 
 k = max(k, parms.z); 
 return j * color + mix(src0, src1, k); 
com.apple.coreimage.tileKernelIsolation
T@"NSNumber",&,N,VinputAcuteAngle
_fourfoldRotatedTile
kernel vec2 _fourfoldRotatedTile(vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t1, t2, t3, t4, t5, ci; 
 t1 = destCoord() - center; 
 t2.x = dot(t1, ftrans.xy); 
 t2.y = dot(t1, ftrans.zw); 
 ci = fract(floor(t2) * 0.5) * 2.0; 
 t2 = fract(t2); 
 t4 = 1.0 - t2; 
 t3 = vec2(t4.y, t2.x); 
 t5 = vec2(t2.y, t4.x); 
 t2 = mix(t2, t5, ci.x); 
 t3 = mix(t3, t4, ci.x); 
 t2 = mix(t2, t3, ci.y); 
 t1.x = dot(t2, btrans.xy); 
 t1.y = dot(t2, btrans.zw); 
 return t1 + center; 
_sixfoldRotatedTile
kernel vec2 _sixfoldRotatedTile(vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t1, t2; 
 t1 = destCoord() - center; 
 t2.x = dot(t1, ftrans.xy); 
 t2.y = dot(t1, ftrans.zw); 
 t2 = fract(t2); 
 t1.x = 1.0 - t2.y; 
 t1.y = t2.x + t2.y - 1.0; 
 t2 = (t1.y < 0.0) ? t2 : t1; 
 t1.x = t2.y; 
 t1.y = 1.0 - t2.x - t2.y; 
 t2 = (1.0 - 2.0 * t2.x - t2.y < 0.0) ? t1 : t2; 
 t1.x = 1.0 - t2.x - t2.y; 
 t1.y = t2.x; 
 t2 = (1.0 - 2.0 * t2.y - t2.x < 0.0) ? t1 : t2; 
 t1.x = t2.y; 
 t1.y = 1.0 - t2.x - t2.y; 
 t2 = (1.0 - 2.0 * t2.x - t2.y < 0.0) ? t1 : t2; 
 t1.x = dot(t2, btrans.xy); 
 t1.y = dot(t2, btrans.zw); 
 return t1 + center; 
_twelvefoldReflectedTile
kernel vec2 _twelvefoldReflectedTile(vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t1, t2; 
 float d0, d1; 
 t1 = destCoord() - center; 
 t2.x = dot(t1.xy, ftrans.xy); 
 t2.y = dot(t1.xy, ftrans.zw); 
 t2 = fract(t2).xy; 
 d0 = t2.x - t2.y; 
 vec2 lt = vec2(lessThan(vec2(d0), vec2(0.0))); 
 t2 = mix(t2.yx, t2.xy, lt); 
 d0 = 1.0 - t2.x - t2.y; 
 t1 = 1.0 - t2.yx; 
 lt = vec2(lessThan(vec2(d0), vec2(0.0))); 
 t2 = mix(t2, t1, lt); 
 d1 = 1.0 - 2.0 * t2.x - t2.y; 
 d0 = 1.0 - t2.x - t2.y; 
 t2.x = (d1 < 0.0) ? d0 : t2.x; 
 d1 = 0.5 - 0.5 * t2.x - t2.y; 
 d0 = 1.0 - t2.x - t2.y; 
 t2.y = (d1 < 0.0) ? d0 : t2.y; 
 t1.x = dot(t2.xy, btrans.xy); 
 t1.y = dot(t2.xy, btrans.zw); 
 return t1 + center; 
_fourfoldTranslatedTile
kernel vec2 _fourfoldTranslatedTile(vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t1, t2; 
 t1 = destCoord() - center; 
 t2.x = dot(t1, ftrans.xy); 
 t2.y = dot(t1, ftrans.zw); 
 t2 = fract(t2); 
 t1.x = dot(t2, btrans.xy); 
 t1.y = dot(t2, btrans.zw); 
 return t1 + center; 
_glideReflectedTile
kernel vec2 _glideReflectedTile(vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t1, t2, t3, t4, t5, ci; 
 t1 = destCoord() - center; 
 t2.x = dot(t1, ftrans.xy); 
 t2.y = dot(t1, ftrans.zw); 
 ci = fract(floor(t2) * 0.5) * 2.0; 
 t2 = fract(t2); 
 t3 = vec2(t2.x, t2.y + 1.0); 
 t4 = vec2(1.0 - t2.x, t2.y); 
 t5 = vec2(t4.x, t4.y + 1.0); 
 t2 = mix(t2, t5, ci.x); 
 t3 = mix(t3, t4, ci.x); 
 t2 = mix(t2, t3, ci.y); 
 t1.x = dot(t2, btrans.xy); 
 t1.y = dot(t2, btrans.zw); 
 return t1 + center; 
_eightfoldReflectedTile
kernel vec2 _eightfoldReflectedTile(vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t1, t2; 
 float d0; 
 t1 = destCoord() - center; 
 t2.x = dot(t1, ftrans.xy); 
 t2.y = dot(t1, ftrans.zw); 
 t2 = fract(t2); 
 t2 = min(t2, 1.0 - t2); 
 d0 = t2.y - t2.x; 
 vec2 lt = vec2(lessThan(vec2(d0), vec2(0.0))); 
 t2 = mix(t2.yx, t2.xy, lt); 
 t1.x = dot(t2, btrans.xy); 
 t1.y = dot(t2, btrans.zw); 
 return t1 + center; 
_fourfoldReflectedTile
kernel vec2 _fourfoldReflectedTile(vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t1, t2; 
 t1 = destCoord() - center; 
 t2.x = dot(t1, ftrans.xy); 
 t2.y = dot(t1, ftrans.zw); 
 t2 = fract(t2); 
 t2 = min (t2, 1.0 - t2); 
 t2 = t2 + t2; 
 t1.x = dot(t2, btrans.xy); 
 t1.y = dot(t2, btrans.zw); 
 return t1 + center; 
_sixfoldReflectedTile
kernel vec2 _sixfoldReflectedTile(vec2 center, vec4 ftrans, vec4 btrans) 
 vec2 t1, t2; 
 float d0, d1, d2; 
 t1 = destCoord() - center; 
 t2.x = dot(t1, ftrans.xy); 
 t2.y = dot(t1, ftrans.zw); 
 t2 = fract(t2); 
 d0 = t2.x - t2.y; 
 vec2 lt = vec2(lessThan(vec2(d0), vec2(0.0))); 
 t2 = mix(t2.yx, t2.xy, lt); 
 d2 = t2.x + t2.y; 
 d0 = 2.0 - d2; 
 d1 = d0 - t2.y; 
 t2.y = (d1 < 0.0) ? d0 : t2.y; 
 d0 = 1.0 - d2; 
 d1 = d0 * -1.0 + t2.x; 
 t2.x = (d1 < 0.0) ? d0 : t2.x; 
 d0 = t2.x - t2.y; 
 lt = vec2(lessThan(vec2(d0), vec2(0.0))); 
 t2 = mix(t2.yx, t2.xy, lt); 
 t1.x = dot(t2, btrans.xy); 
 t1.y = dot(t2, btrans.zw); 
 return t1 + center; 
singular matrix cannot be inverted
kernel vec4 _sobelEdges(sampler src, float scale) 
 vec2 coord = destCoord(); 
 vec2 sc = samplerTransform(src, coord); 
 vec2 dx = samplerTransform(src, coord + vec2(1.0, 0.0)) - sc; 
 vec2 dy = samplerTransform(src, coord + vec2(0.0, 1.0)) - sc; 
 vec2 d = dx + dy; 
 vec4 pix3 = sample(src, sc + d); 
 vec4 pix7 = sample(src, sc - d); 
 d = dx - dy; 
 vec4 pix9 = sample(src, sc + d); 
 vec4 pix1 = sample(src, sc - d); 
 vec4 pix2 = sample(src, sc + dy); 
 vec4 pix8 = sample(src, sc - dy); 
 vec4 pix6 = sample(src, sc + dx); 
 vec4 pix4 = sample(src, sc - dx); 
 vec4 pix5 = sample(src, sc); 
 vec4 gx = (pix3 + 2.0*pix6 + pix9) - (pix1 + 2.0*pix4 + pix7); 
 vec4 gy = (pix1 + 2.0*pix2 + pix3) - (pix7 + 2.0*pix8 + pix9); 
 vec4 g2 = gx*gx + gy*gy; 
 pix5 = vec4(pix5.rgb/max(pix5.a,0.00001), pix5.a); 
 pix5.rgb = sqrt(g2).rgb * scale; 
 return vec4(pix5.rgb*pix5.a, pix5.a); 
kernel vec4 _noiseComicReduction(sampler src, vec2 offset, vec3 weight, vec3 intensity) 
 vec2 c = destCoord(); 
 vec4 cn = sample(src, samplerTransform(src, c)); 
 vec4 t0 = sample(src, samplerTransform(src, c + vec2(0.0, -offset.x))); 
 vec4 t1 = sample(src, samplerTransform(src, c + vec2(0.0, offset.x))); 
 vec4 t2 = sample(src, samplerTransform(src, c + vec2(-offset.x, 0.0))); 
 vec4 t3 = sample(src, samplerTransform(src, c + vec2(offset.x, 0.0))); 
 vec4 t4 = sample(src, samplerTransform(src, c + vec2(offset.y, offset.y))); 
 vec4 t5 = sample(src, samplerTransform(src, c + vec2(offset.y, -offset.y))); 
 vec4 t6 = sample(src, samplerTransform(src, c + vec2(-offset.y, -offset.y))); 
 vec4 t7 = sample(src, samplerTransform(src, c + vec2(-offset.y, offset.y))); 
 t0 = (t0 + t1 + t2 + t3) * weight.x + (t4 + t5 + t6 + t7) * weight.y + cn * weight.z; 
 vec4 d = abs(t0 - cn); 
 float s = intensity.x + intensity.y * (d.r + d.g + d.b); 
 s = clamp(s, intensity.z, 1.0); 
 return mix(cn, t0, s); 
kernel vec4 _colorControls(__sample src, float threshold, float contrast) 
 vec4 pix = vec4(src.rgb/max(src.a,0.00001), src.a); 
 float f = clamp((dot(pix.rgb, vec3(0.2125, 0.7154, 0.0721)) - threshold) * contrast + 0.5, 0.0, 1.0); 
 return vec4(0.0, 0.0, 0.0, f); 
inputNRSharpness
inputNRNoiseLevel
inputEdgeIntensity
kernel vec4 _spotColor(__sample src, 
 __color cclr1, __color rclr1, 
 __color cclr2, __color rclr2, 
 __color cclr3, __color rclr3, 
 vec4 closeness, vec4 contrast) 
 vec4 pix = vec4(src.rgb/max(src.a,0.00001), src.a); 
 float dist = length(pix.rgb - cclr1.rgb); 
 float alpha = clamp((closeness.x - dist) * contrast.x + 0.5, 0.0, 1.0); 
 vec4 result1 = rclr1 * alpha; 
 dist = length(pix.rgb - cclr2.rgb); 
 alpha = clamp((closeness.y - dist) * contrast.y + 0.5, 0.0, 1.0); 
 vec4 result2 = rclr2 * alpha; 
 dist = length(pix.rgb - cclr3.rgb); 
 alpha = clamp((closeness.z - dist) * contrast.z + 0.5, 0.0, 1.0); 
 vec4 result3 = rclr3 * alpha; 
 pix = result1 + (1.0 - result1.a) * vec4(1.0); 
 pix = result2 + (1.0 - result2.a) * pix; 
 return result3 + (1.0 - result3.a) * pix; 
inputCloseness1
inputContrast1
inputCenterColor1
inputReplacementColor1
inputCloseness2
inputContrast2
inputCenterColor2
inputReplacementColor2
inputCloseness3
inputContrast3
inputCenterColor3
inputReplacementColor3
CI::MainProgramArgsQ
v20@?0^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}4^{Node=^^?{atomic<unsigned int>=AI}I{SerialRectArray={vector<CI::SerialRectArray::roiData, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}^{roiData}{__compressed_pair<CI::SerialRectArray::roiData *, std::__1::allocator<CI::SerialRectArray::roiData> >=^{roiData}}}}Q{Hash=[20C]}{Hash=[20C]}BB}8i12i16
program 
 kernel=0x%llx
 format=%s%s
 cycles=%llu
 ms=%.1f
<CI::%s %p>
mainMetalEntryPoint
vertexTransform0
vertexTransform1
vertexTransform
CI_PRINT_PROGRAM %s <0x%llx> (%s context %p) = 
Argument count mismatch for program (%s) <0x%llx> (%d != %d).
[argument types]
[argument names]
[argument objects]
r*8@?0i4
mData[%i] = %s
mData[%i] = %p <%s> 
kernel vec4 _boxBlur3x3(sampler i) 
 vec2 dc = destCoord(); 
 vec4 c; 
 c = sample(i, samplerTransform(i,dc + vec2(1.0,1.0))); 
 c += sample(i, samplerTransform(i,dc + vec2(1.0,-.5))) * 2.0; 
 c += sample(i, samplerTransform(i,dc + vec2(-.5,1.0))) * 2.0; 
 c += sample(i, samplerTransform(i,dc + vec2(-.5,-.5))) * 4.0; 
 return c / 9.0; 
kernel vec4 _boxBlur3(sampler i, vec2 dir) 
 vec2 dc = destCoord(); 
 vec4 c; 
 c = sample(i, samplerTransform(i,dc - dir)); 
 c += sample(i, samplerTransform(i,dc + 0.5*dir)) * 2.0; 
 return c / 3.0; 
kernel vec4 _boxBlur5(sampler i, vec2 dir) 
 vec2 dc = destCoord(); 
 vec4 c; 
 c = sample(i, samplerTransform(i,dc - 1.5*dir)) * 0.4; 
 c += sample(i, samplerTransform(i,dc)) * 0.2; 
 c += sample(i, samplerTransform(i,dc + 1.5*dir)) * 0.4; 
 return c; 
kernel vec4 _boxBlur7(sampler i, vec2 dir) 
 vec2 dc = destCoord(); 
 vec4 c; 
 c = sample(i, samplerTransform(i,dc - 2.5*dir)); 
 c += sample(i, samplerTransform(i,dc - dir)) * 0.5; 
 c += sample(i, samplerTransform(i,dc + 0.5*dir)); 
 c += sample(i, samplerTransform(i,dc + 2.5*dir)); 
 return c / 3.5; 
kernel vec4 _boxBlur9(sampler i, vec2 dir) 
 vec2 dc = destCoord(); 
 vec4 c; 
 c = sample(i, samplerTransform(i,dc - 3.5*dir)); 
 c += sample(i, samplerTransform(i,dc - 1.5*dir)); 
 c += sample(i, samplerTransform(i,dc)) * 0.5; 
 c += sample(i, samplerTransform(i,dc + 1.5*dir)); 
 c += sample(i, samplerTransform(i,dc + 3.5*dir)); 
 return c / 4.5; 
kernel vec4 _boxBlur11(sampler i, vec2 dir) 
 vec2 dc = destCoord(); 
 vec4 c; 
 c = sample(i, samplerTransform(i,dc - 4.5*dir)); 
 c += sample(i, samplerTransform(i,dc - 2.5*dir)); 
 c += sample(i, samplerTransform(i,dc - dir)) * 0.5; 
 c += sample(i, samplerTransform(i,dc + 0.5*dir)); 
 c += sample(i, samplerTransform(i,dc + 2.5*dir)); 
 c += sample(i, samplerTransform(i,dc + 4.5*dir)); 
 return c / 5.5; 
kernel vec4 _boxBlur13(sampler i, vec2 dir) 
 vec2 dc = destCoord(); 
 vec4 c; 
 c = sample(i, samplerTransform(i,dc - 5.5*dir)); 
 c += sample(i, samplerTransform(i,dc - 3.5*dir)); 
 c += sample(i, samplerTransform(i,dc - 1.5*dir)); 
 c += sample(i, samplerTransform(i,dc)) * 0.5; 
 c += sample(i, samplerTransform(i,dc + 1.5*dir)); 
 c += sample(i, samplerTransform(i,dc + 3.5*dir)); 
 c += sample(i, samplerTransform(i,dc + 5.5*dir)); 
 return c / 6.5; 
kernel vec4 _boxCombine7 (sampler blur, vec2 off) 
 vec2 dc = destCoord(); 
 vec4 c = sample(blur, samplerTransform(blur, dc - 3.0*off)) 
 + sample(blur, samplerTransform(blur, dc - 2.0*off)) 
 + sample(blur, samplerTransform(blur, dc - off)) 
 + sample(blur, samplerTransform(blur, dc)) 
 + sample(blur, samplerTransform(blur, dc + off)) 
 + sample(blur, samplerTransform(blur, dc + 2.0*off)) 
 + sample(blur, samplerTransform(blur, dc + 3.0*off)); 
 return c / 7.0; 
kernel vec4 _boxCombine5 (sampler blur, vec2 off) 
 vec2 dc = destCoord(); 
 vec4 c = sample(blur, samplerTransform(blur, dc - 2.0*off)) 
 + sample(blur, samplerTransform(blur, dc - off)) 
 + sample(blur, samplerTransform(blur, dc)) 
 + sample(blur, samplerTransform(blur, dc + off)) 
 + sample(blur, samplerTransform(blur, dc + 2.0*off)); 
 return c * 0.2; 
kernel vec4 _boxCombine3 (sampler blur, vec2 off) 
 vec2 dc = destCoord(); 
 vec4 c = sample(blur, samplerTransform(blur, dc)) 
 + sample(blur, samplerTransform(blur, dc - off)) 
 + sample(blur, samplerTransform(blur, dc + off)); 
 return c / 3.0; 
kernel vec4 _boxCombine2 (sampler img, sampler blur, vec4 parms) 
 vec2 off = parms.xy; 
 float kc = parms.w; 
 float kb = parms.z; 
 vec2 dc = destCoord(); 
 return kc * sample(img, samplerTransform(img, dc)) 
 + kb * sample(blur, samplerTransform(blur, dc - off)) 
 + kb * sample(blur, samplerTransform(blur, dc + off)); 
lightMap
lightMapWidth
lightMapHeight
lightMapAvg
localAutoValue
proxyLightMap
proxyLightMapWidth
proxyLightMapHeight
inputLightMapWidth
inputLightMapHeight
kernel vec4 _polyKernel(__sample im, __sample adj, float str) 
 adj.r = 3.4*adj.r-1.2; 
 vec3 neg = min(im.rgb, 0.0); 
 vec3 pos = max(im.rgb, 1.0)-1.0; 
 im.rgb = clamp(im.rgb, 0.0, 1.0); 
 vec4 orig = im; 
 float y = sqrt(dot(im.rgb, vec3(.33333))); 
 float s = mix(0.0, adj.r, str); 
 vec3 gain = s > 0.0 ? vec3(1.5*s) : vec3(1.75*s, 1.75*s, 1.55*s); 
 im.rgb = im.rgb*im.rgb*gain + im.rgb*(1.0-gain); 
 im.rgb = (clamp(im.rgb, 0.0, 1.0)); 
 float midAmt = min(str, .5); 
 y = y*(1.0-y); 
 im.rgb = sqrt(im.rgb); 
 float pivot = max(adj.g, 0.5); 
 float a = midAmt*y; 
 float b = -pivot*a; 
 vec3 pix = im.r * vec3(0.299*a) + 
 im.g * vec3(0.587*a) + 
 im.b * vec3(0.114*a) + 
 im.rgb + vec3(b); 
 im.rgb = mix(im.rgb, vec3(pivot), -y*midAmt); 
 im.rgb = mix(im.rgb, pix, 0.8); 
 im.rgb = max(im.rgb, 0.0); 
 im.rgb *= im.rgb; 
 im.rgb = clamp(im.rgb, 0.0,1.0)+pos+neg; 
 return im; 
-[CILocalLightFilter outputImage]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/CILocalLight.mm
CGRectEqualToRect([guideImage extent], [inputImage extent])
inputImage != nil
guideImage != nil
inputLocalLight != nil
CGRectEqualToRect([lightMapImage extent], [inputImage extent])
CILocalLight
_lightMapImageFromData_block_invoke
x == 0
y == 0
width == lmWidth
height == lmHeight
CIEdgePreserveUpsampleRGFilter
inputAVCameraCalibrationData
Calibration Data object of type AVCameraCalibrationData
inputUseInverseLookUpTable
Use Inverse Look Up Table
lookUpTableLength
lookUpTable
opticalCenter
kernel vec4 radialLensDistortion(sampler src, sampler lut, vec4 params) { vec2 opticalCenter = vec2(params.x, params.y); float r_max = params.z; float lutSize = params.w - 1.0; float r_point = distance(destCoord(), opticalCenter); float mag = sample(lut, samplerTransform(lut, vec2(lutSize*r_point/r_max + .5, .5))).x; vec2 v_point = destCoord() - opticalCenter; vec2 warpedCoord = (v_point + mag*v_point) + opticalCenter; vec4 c = sample(src, samplerTransform(src, warpedCoord)); return c; }
kernel vec4 _colorMap (sampler src, sampler map, float scale) 
 vec4 s = unpremultiply(sample(src, samplerCoord(src))); 
 float n = clamp(dot(s.rgb, vec3(0.2125, 0.7154, 0.0721)), 0.0, 1.0); 
 return s.a * sample(map, samplerTransform(map, vec2(n*scale + 0.5, 0.5))); 
%s requires the inputGradientImage to be finite
-[CIColorMap outputImage]
T@"CIImage",&,N,VinputGradientImage
kernel vec4 _median3x3(sampler src) 
 vec2 d; 
 vec4 p1,p2,p3,p4,p5,p6,p7,p8,p9; 
 vec4 e1, e2, e3, e4, e5, e6, e7, e8, e9, e10; 
 vec4 e11, e12, e13, e14, e15, e16, e17, e18, e19, e20; 
 vec4 e21, e22, e23, e24, e25, e26, e27, e28, e29; 
 d = destCoord(); 
 p1 = sample(src, samplerTransform(src, d + vec2(+1.0, 0.0))); 
 p2 = sample(src, samplerTransform(src, d + vec2(+1.0,+1.0))); 
 p3 = sample(src, samplerTransform(src, d + vec2( 0.0,+1.0))); 
 p4 = sample(src, samplerTransform(src, d + vec2(-1.0,+1.0))); 
 p5 = sample(src, samplerTransform(src, d + vec2(-1.0, 0.0))); 
 p6 = sample(src, samplerTransform(src, d + vec2(-1.0,-1.0))); 
 p7 = sample(src, samplerTransform(src, d + vec2( 0.0,-1.0))); 
 p8 = sample(src, samplerTransform(src, d + vec2(+1.0,-1.0))); 
 p9 = sample(src, samplerTransform(src, d)); 
 e1 = min(p2 , p3 ); e2 = max(p2 , p3 ); 
 e3 = min(p5 , p6 ); e4 = max(p5 , p6 ); 
 e5 = min(p8 , p9 ); e6 = max(p8 , p9 ); 
 e7 = min(p1 , e1 ); e8 = max(p1 , e1 ); 
 e9 = min(p4 , e3 ); e10 = max(p4 , e3 ); 
 e11 = min(p7 , e5 ); e12 = max(p7 , e5 ); 
 e13 = min(e8 , e2 ); e14 = max(e8 , e2 ); 
 e15 = min(e10, e4 ); e16 = max(e10, e4 ); 
 e17 = min(e12, e6 ); e18 = max(e12, e6 ); 
 e19 = max(e7 , e9 ); 
 e20 = min(e16, e18); 
 e21 = max(e19, e11); 
 e22 = min(e14, e20); 
 e23 = min(e15, e17); e24 = max(e15, e17); 
 e25 = max(e13, e23); 
 e26 = min(e24, e25); 
 e27 = min(e26, e22); e28 = max(e26, e22); 
 e29 = max(e21, e27); 
 return min(e29, e28); 
inputBarOffset
kernel vec2 _barsSwipe (vec3 ptoy, vec2 dir, float progress) 
 float y = dot(ptoy.xy,destCoord()) + ptoy.z; 
 y = abs(floor(y)); 
 y = max(progress - y, 0.0); 
 return destCoord() + y*y*dir; 
T@"NSNumber",&,N,VinputBarOffset
inputShadowRadius
inputShadowDensity
inputShadowOffset
kernel vec4 _disintegrateWithMask (__sample t0, __sample t1, 
 __sample m0, __sample m1, __sample m2, __sample m3, 
 vec4 param) 
 float shadowRadiusInv = param.y; 
 float shadowDensity = param.z; 
 float time = param.w; 
 float ramp = 1.0 / (max(abs(m1.r-m0.r), abs(m2.r-m0.r)) + 0.001); 
 float shadow = (time - m3.r) * shadowRadiusInv * ramp + time; 
 shadow = clamp(shadow, 0.0, 1.0); 
 shadow = shadowDensity*(shadow-1.0) + 1.0; 
 t0.rgb = t0.rgb * (param.x*time + 1.0); 
 t1.rgb = t1.rgb * (param.x*time + 1.0 - param.x) * shadow; 
 float s = clamp((time - m0.r) * ramp + time, 0.0, 1.0); 
 return mix(t0, t1, s); 
kernel vec4 _disintegrateWithMaskG (sampler s0, sampler s1, sampler m, vec2 offset, vec4 param) 
 float shadowRadiusInv = param.y; 
 float shadowDensity = param.z; 
 float time = param.w; 
 vec4 t0 = sample(s0, samplerCoord(s0)); 
 vec4 t1 = sample(s1, samplerCoord(s1)); 
 vec2 d = destCoord(); 
 vec4 m0 = sample(m, samplerTransform(m, d)); 
 vec4 m1 = sample(m, samplerTransform(m, d + vec2(1.0, 0.0))); 
 vec4 m2 = sample(m, samplerTransform(m, d + vec2(0.0, 1.0))); 
 vec4 m3 = sample(m, samplerTransform(m, d - offset)); 
 float ramp = 1.0 / (max(abs(m1.r-m0.r), abs(m2.r-m0.r)) + 0.001); 
 float shadow = (time - m3.r) * shadowRadiusInv * ramp + time; 
 shadow = clamp(shadow, 0.0, 1.0); 
 shadow = shadowDensity*(shadow-1.0) + 1.0; 
 t0.rgb = t0.rgb * (param.x*time + 1.0); 
 t1.rgb = t1.rgb * (param.x*time + 1.0 - param.x) * shadow; 
 float s = clamp((time - m0.r) * ramp + time, 0.0, 1.0); 
 return mix(t0, t1, s); 
T@"NSNumber",&,N,VinputShadowRadius
T@"NSNumber",&,N,VinputShadowDensity
T@"CIVector",&,N,VinputShadowOffset
com.apple.mobileslideshow
inputFadeThreshold
kernel vec4 _flashColor (__sample r1, __sample r0, vec2 center, __color color, __sample noise, vec4 parms, vec2 parms2) 
 vec2 delta = destCoord() - center; 
 float len = length(delta); 
 float len2 = dot(delta,delta); 
 float mask = clamp(1.0 - len * parms.z, 0.0, 1.0); 
 float n = clamp(noise.x, 0.0, noise.a); 
 n = n * parms2.x + parms2.y; 
 vec4 flash = color * parms.y / len2 + n; 
 vec4 r2 = clamp(flash * mask, 0.0, 1.0); 
 r1 = clamp(r1 + r2, 0.0, 1.0); 
 return mix(r1, r0, parms.w); 
kernel vec2 _flashGeom (vec2 center) 
 vec2 delta = destCoord() - center; 
 float len = length(delta); 
 return (delta * 100.0 / len) + vec2(128.0); 
T@"NSNumber",&,N,VinputMaxStriationRadius
T@"NSNumber",&,N,VinputStriationStrength
T@"NSNumber",&,N,VinputStriationContrast
T@"NSNumber",&,N,VinputFadeThreshold
kernel vec4 _add(__sample src, __sample dst) 
 return src + dst; 
kernel vec4 _multiply(__sample src, __sample dst) 
 return src * dst; 
kernel vec4 _min(__sample src, __sample dst) 
 return min(src, dst); 
kernel vec4 _max(__sample src, __sample dst) 
 return max(src, dst); 
kernel vec4 _clear(__sample src, __sample dst) 
 return vec4(0.0); 
kernel vec4 _src(__sample src, __sample dst) 
 return src; 
kernel vec4 _dst(__sample src, __sample dst) 
 return dst; 
kernel vec4 _srcOver(__sample src, __sample dst) 
 return src + dst*(1.0 - src.a); 
kernel vec4 _dstOver(__sample src, __sample dst) 
 return dst + src*(1.0 - dst.a); 
kernel vec4 _srcIn(__sample src, __sample dst) 
 return src*dst.a; 
kernel vec4 _dstIn(__sample src, __sample dst) 
 return dst*src.a; 
kernel vec4 _srcOut(__sample src, __sample dst) 
 return src*(1.0-dst.a); 
kernel vec4 _dstOut(__sample src, __sample dst) 
 return src*(1.0-dst.a); 
kernel vec4 _srcAtop(__sample src, __sample dst) 
 return src * dst.a + dst * (1.0 - src.a); 
kernel vec4 _dstAtop(__sample src, __sample dst) 
 return dst * src.a + src * (1.0 - dst.a); 
kernel vec4 _exclusiveOr(__sample src, __sample dst) 
 return src * (1.0 - dst.a) + dst * (1.0 - src.a); 
kernel vec4 _multiplyBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb * Cs; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _screenBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb + Cs - (Cb * Cs); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _overlayBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = compare(0.5 - Cb, 2.0 * (Cs + Cb - Cs * Cb) - 1.0, 2.0 * Cb * Cs); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _darkenBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = min(Cb, Cs); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _lightenBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = max(Cb, Cs); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _colorDodgeBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb / max(1.0 - Cs, vec4(0.0000001)); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _colorBurnBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = 1.0 - (1.0 - Cb) / max(Cs, vec4(0.0000001)); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _hardLightBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = compare(0.5 - Cs, 2.0 * (Cb + Cs - Cb * Cs) - 1.0, 2.0 * Cs * Cb); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _softLightBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 DCb = compare(0.25 - Cb, sqrt(Cb), ((16.0 * Cb - 12.0) * Cb + 4.0) * Cb); 
 vec4 B = Cb + (2.0 * Cs - 1.0) * compare(0.5 - Cs, DCb - Cb, Cb * (1.0 - Cb)); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _differenceBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = abs(Cb - Cs); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _exclusionBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb + Cs - 2.0 * Cb * Cs; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _hueBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 CsSort = (Cs.r > Cs.g) ? Cs : Cs.grba; 
 CsSort = (CsSort.g > CsSort.b) ? CsSort : CsSort.rbga; 
 CsSort = (CsSort.r > CsSort.g) ? CsSort : CsSort.grba; 
 vec4 CbSort = (Cb.r > Cb.g) ? Cb : Cb.grba; 
 CbSort = (CbSort.g > CbSort.b) ? CbSort : CbSort.rbga; 
 CbSort = (CbSort.r > CbSort.g) ? CbSort : CbSort.grba; 
 float bMax = CbSort.r; 
 float bMin = CbSort.b; 
 float Sb = bMax - bMin; 
 float sMax = CsSort.r; 
 float sMid = CsSort.g; 
 float sMin = CsSort.b; 
 int sMaxIdx = (sMax == Cs.r ? 0 : (sMax == Cs.g ? 1 : 2)); 
 int sMinIdx = (sMin == Cs.b ? 2 : (sMin == Cs.g ? 1 : 0)); 
 int sMidIdx = 3 - sMinIdx - sMaxIdx; 
 vec4 CsSb = Cs; 
 CsSb[sMaxIdx] = (sMax > sMin) ? Sb : 0.0; 
 CsSb[sMidIdx] = (sMax > sMin) ? (sMid - sMin) * Sb / (sMax - sMin) : 0.0; 
 CsSb[sMinIdx] = 0.0; 
 float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b; 
 float LCsSb = 0.3 * CsSb.r + 0.59 * CsSb.g + 0.11 * CsSb.b; 
 vec4 BB = CsSb + vec4(Lb - LCsSb); 
 float l = 0.3 * BB.r + 0.59 * BB.g + 0.11 * BB.b; 
 float n = min(min(BB.r, BB.g), BB.b); 
 float x = max(max(BB.r, BB.g), BB.b); 
 vec4 B = BB; 
 B = n < 0.0 ? vec4(l) + (B - vec4(l)) * l / (l - n) : B; 
 B = x > 1.0 ? vec4(l) + (B - vec4(l)) * (1.0 - l) / (x - l) : B; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _saturationBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 CsSort = (Cs.r > Cs.g) ? Cs : Cs.grba; 
 CsSort = (CsSort.g > CsSort.b) ? CsSort : CsSort.rbga; 
 CsSort = (CsSort.r > CsSort.g) ? CsSort : CsSort.grba; 
 vec4 CbSort = (Cb.r > Cb.g) ? Cb : Cb.grba; 
 CbSort = (CbSort.g > CbSort.b) ? CbSort : CbSort.rbga; 
 CbSort = (CbSort.r > CbSort.g) ? CbSort : CbSort.grba; 
 float sMax = CsSort.r; 
 float sMin = CsSort.b; 
 float Ss = sMax - sMin; 
 float bMax = CbSort.r; 
 float bMid = CbSort.g; 
 float bMin = CbSort.b; 
 int bMaxIdx = (bMax == Cb.r ? 0 : (bMax == Cb.g ? 1 : 2)); 
 int bMinIdx = (bMin == Cb.b ? 2 : (bMin == Cb.g ? 1 : 0)); 
 int bMidIdx = 3 - bMinIdx - bMaxIdx; 
 vec4 CbSs = Cb; 
 CbSs[bMaxIdx] = (bMax > bMin) ? Ss : 0.0; 
 CbSs[bMidIdx] = (bMax > bMin) ? (bMid - bMin) * Ss / (bMax - bMin) : 0.0; 
 CbSs[bMinIdx] = 0.0; 
 float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b; 
 float LCbSs = 0.3 * CbSs.r + 0.59 * CbSs.g + 0.11 * CbSs.b; 
 vec4 BB = CbSs + vec4(Lb - LCbSs); 
 float l = 0.3 * BB.r + 0.59 * BB.g + 0.11 * BB.b; 
 float n = min(min(BB.r, BB.g), BB.b); 
 float x = max(max(BB.r, BB.g), BB.b); 
 vec4 B = BB; 
 B = n < 0.0 ? vec4(l) + (B - vec4(l)) * l / (l - n) : B; 
 B = x > 1.0 ? vec4(l) + (B - vec4(l)) * (1.0 - l) / (x - l) : B; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _colorBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 float Ls = 0.3 * Cs.r + 0.59 * Cs.g + 0.11 * Cs.b; 
 float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b; 
 vec4 BB = Cs + vec4(Lb - Ls); 
 float l = 0.3 * BB.r + 0.59 * BB.g + 0.11 * BB.b; 
 float n = min(min(BB.r, BB.g), BB.b); 
 float x = max(max(BB.r, BB.g), BB.b); 
 vec4 B = BB; 
 B = n < 0.0 ? vec4(l) + (B - vec4(l)) * l / (l - n) : B; 
 B = x > 1.0 ? vec4(l) + (B - vec4(l)) * (1.0 - l) / (x - l) : B; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _luminosityBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 float Ls = 0.3 * Cs.r + 0.59 * Cs.g + 0.11 * Cs.b; 
 float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b; 
 vec4 BB = Cb + vec4(Ls - Lb); 
 float l = 0.3 * BB.r + 0.59 * BB.g + 0.11 * BB.b; 
 float n = min(min(BB.r, BB.g), BB.b); 
 float x = max(max(BB.r, BB.g), BB.b); 
 vec4 B = BB; 
 B = n < 0.0 ? vec4(l) + (B - vec4(l)) * l / (l - n) : B; 
 B = x > 1.0 ? vec4(l) + (B - vec4(l)) * (1.0 - l) / (x - l) : B; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _subtractBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb - Cs; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _divideBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb / max(Cs,vec4(0.0000001)); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _linearBurnBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb + Cs - 1.0; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _linearDodgeBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb + Cs; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _vividLightBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 epsilon = vec4(0.0000001); 
 vec4 lo = 1.0 - ((1.0 - Cb) / max(2.0 * Cs, epsilon)); 
 vec4 hi = Cb / max(2.0 * (1.0 - Cs), epsilon); 
 vec4 B = compare(0.5 - Cs, hi, lo); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _linearLightBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = Cb + 2.0 * Cs - 1.0; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _pinLightBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 hi = 2.0 * Cs; 
 vec4 lo = hi - 1.0; 
 vec4 B = compare(Cb - lo, lo, compare(Cb - hi, Cb, hi)); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _hardMixBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 vec4 B = compare(1.0 - Cb - Cs, vec4(1.0), vec4(0.0)); 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _darkerColorBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 float Ls = 0.3 * Cs.r + 0.59 * Cs.g + 0.11 * Cs.b; 
 float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b; 
 vec4 B = Ls > Lb ? Cb : Cs; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _lighterColorBlendMode (__sample fore, __sample back) 
 vec4 Cs = unpremultiply(fore); 
 vec4 Cb = unpremultiply(back); 
 float Ls = 0.3 * Cs.r + 0.59 * Cs.g + 0.11 * Cs.b; 
 float Lb = 0.3 * Cb.r + 0.59 * Cb.g + 0.11 * Cb.b; 
 vec4 B = Ls < Lb ? Cb : Cs; 
 vec4 Cr = clamp(B, vec4(0.0), vec4(1.0)); 
 Cr = mix(Cs, Cr, back.a); 
 Cr.a = 1.0; 
 Cr = mix(back, Cr, fore.a); 
 return Cr; 
kernel vec4 _plusDarker(__sample src, __sample dst) 
 vec4 R = src + dst; 
 R.rgb = R.a - R.rgb; 
 R = clamp(R, vec4(0.0), vec4(1.0)); 
 R.rgb = R.a - R.rgb; 
 return R; 
kernel vec4 _plusLighter(__sample src, __sample dst) 
 return src + dst; 
componentAdd
T@"CIBlendKernel",R
componentMultiply
componentMin
componentMax
source
sourceOver
destinationOver
sourceIn
destinationIn
sourceOut
destinationOut
sourceAtop
destinationAtop
exclusiveOr
multiply
screen
overlay
darken
lighten
colorDodge
colorBurn
hardLight
softLight
difference
exclusion
saturation
luminosity
subtract
divide
linearBurn
linearDodge
vividLight
linearLight
pinLight
hardMix
darkerColor
lighterColor
kernel vec4 _disparityRefinementPreprocessing(__sample alpha,__sample disparity,__sample lm,vec4 config0,vec4 config1) { float alpha_val = alpha.x; float d = disparity.x; float zeroShift = lm.x; float d_factor = clamp( config0.x * exp( -pow(d - zeroShift , config0.y) / config0.z ) , config0.w, config1.x); if ( alpha_val > config1.y ) { d -= (d - zeroShift) * d_factor; } return vec4(d, 0.0, 0.0, 1.0); }
,vec2 samplePoint
destCoord()
samplePoint
vec2
vec3
vec4
mat2
mat3
mat4
__table
kernel vec4 autoROI_%s(__sample s,vec4 e,
%s v%d%s
  vec2 pt = ( 
v%d%s
,s.xy) - e.xy) / e.zw; return pt.xyxy; }
kernel vec4 autoROI_%s(sampler s,vec4 e,
  vec2 pt = 
 return ((samplerTransform(s, pt).xyxy)- e.xyxy) / e.zwzw; }
kernel vec4 _mesh1(vec4 pt1, float width, __color color, float opacity) 
 float hw, dist, interpolant; 
 vec2 p1, p2, p, v, w, s; 
 hw = width*0.5; 
 p = destCoord(); 
 p1 = pt1.rg; p2 = pt1.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist = compare(v.x*s.x + v.y*s.y, length(v), dist); 
 w = p - p2; 
 dist = compare(w.x*s.x + w.y*s.y, dist, length(w)); 
 interpolant = clamp(hw - dist, 0.0, 1.0); 
 interpolant = (3.0 - 2.0*interpolant)*interpolant*interpolant; 
 return compare(vec4(dist - (hw - 1.0)), color, compare(vec4(dist - hw), color * interpolant, vec4(0.0))) * opacity; 
kernel vec4 _mesh2(vec4 pt1, vec4 pt2, float width, __color color, float opacity) 
 float hw, dist1, dist2, interpolant; 
 vec2 p1, p2, p, v, w, s; 
 hw = width*0.5; 
 p = destCoord(); 
 p1 = pt1.rg; p2 = pt1.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist1 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist1 = compare(v.x*s.x + v.y*s.y, length(v), dist1); 
 w = p - p2; 
 dist1 = compare(w.x*s.x + w.y*s.y, dist1, length(w)); 
 p1 = pt2.rg; p2 = pt2.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 interpolant = clamp(hw - dist1, 0.0, 1.0); 
 interpolant = (3.0 - 2.0*interpolant)*interpolant*interpolant; 
 return compare(vec4(dist1 - (hw - 1.0)), color, compare(vec4(dist1 - hw), color * interpolant, vec4(0.0))) * opacity; 
kernel vec4 _mesh4(vec4 pt1, vec4 pt2, vec4 pt3, vec4 pt4, float width, __color color, float opacity) 
 float hw, dist1, dist2, interpolant; 
 vec2 p1, p2, p, v, w, s; 
 hw = width*0.5; 
 p = destCoord(); 
 p1 = pt1.rg; p2 = pt1.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist1 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist1 = compare(v.x*s.x + v.y*s.y, length(v), dist1); 
 w = p - p2; 
 dist1 = compare(w.x*s.x + w.y*s.y, dist1, length(w)); 
 p1 = pt2.rg; p2 = pt2.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt3.rg; p2 = pt3.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt4.rg; p2 = pt4.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 interpolant = clamp(hw - dist1, 0.0, 1.0); 
 interpolant = (3.0 - 2.0*interpolant)*interpolant*interpolant; 
 return compare(vec4(dist1 - (hw - 1.0)), color, compare(vec4(dist1 - hw), color * interpolant, vec4(0.0))) * opacity; 
kernel vec4 _mesh8(vec4 pt1, vec4 pt2, vec4 pt3, vec4 pt4, vec4 pt5, vec4 pt6, vec4 pt7, vec4 pt8, float width, __color color, float opacity) 
 float hw, dist1, dist2, interpolant; 
 vec2 p1, p2, p, v, w, s; 
 hw = width*0.5; 
 p = destCoord(); 
 p1 = pt1.rg; p2 = pt1.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist1 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist1 = compare(v.x*s.x + v.y*s.y, length(v), dist1); 
 w = p - p2; 
 dist1 = compare(w.x*s.x + w.y*s.y, dist1, length(w)); 
 p1 = pt2.rg; p2 = pt2.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt3.rg; p2 = pt3.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt4.rg; p2 = pt4.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt5.rg; p2 = pt5.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt6.rg; p2 = pt6.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt7.rg; p2 = pt7.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt8.rg; p2 = pt8.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 interpolant = clamp(hw - dist1, 0.0, 1.0); 
 interpolant = (3.0 - 2.0*interpolant)*interpolant*interpolant; 
 return compare(vec4(dist1 - (hw - 1.0)), color, compare(vec4(dist1 - hw), color * interpolant, vec4(0.0))) * opacity; 
kernel vec4 _mesh16(vec4 pt1, vec4 pt2, vec4 pt3, vec4 pt4, vec4 pt5, vec4 pt6, vec4 pt7, vec4 pt8, vec4 pt9, vec4 pt10, vec4 pt11, vec4 pt12, vec4 pt13, vec4 pt14, vec4 pt15, vec4 pt16, float width, __color color, float opacity) 
 float hw, dist1, dist2, interpolant; 
 vec2 p1, p2, p, v, w, s; 
 hw = width*0.5; 
 p = destCoord(); 
 p1 = pt1.rg; p2 = pt1.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist1 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist1 = compare(v.x*s.x + v.y*s.y, length(v), dist1); 
 w = p - p2; 
 dist1 = compare(w.x*s.x + w.y*s.y, dist1, length(w)); 
 p1 = pt2.rg; p2 = pt2.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt3.rg; p2 = pt3.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt4.rg; p2 = pt4.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt5.rg; p2 = pt5.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt6.rg; p2 = pt6.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt7.rg; p2 = pt7.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt8.rg; p2 = pt8.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt9.rg; p2 = pt9.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt10.rg; p2 = pt10.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt11.rg; p2 = pt11.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt12.rg; p2 = pt12.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt13.rg; p2 = pt13.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt14.rg; p2 = pt14.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt15.rg; p2 = pt15.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt16.rg; p2 = pt16.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 interpolant = clamp(hw - dist1, 0.0, 1.0); 
 interpolant = (3.0 - 2.0*interpolant)*interpolant*interpolant; 
 return compare(vec4(dist1 - (hw - 1.0)), color, compare(vec4(dist1 - hw), color * interpolant, vec4(0.0))) * opacity; 
kernel vec4 _mesh32(vec4 pt1, vec4 pt2, vec4 pt3, vec4 pt4, vec4 pt5, vec4 pt6, vec4 pt7, vec4 pt8, vec4 pt9, vec4 pt10, vec4 pt11, vec4 pt12, vec4 pt13, vec4 pt14, vec4 pt15, vec4 pt16, vec4 pt17, vec4 pt18, vec4 pt19, vec4 pt20, vec4 pt21, vec4 pt22, vec4 pt23, vec4 pt24, vec4 pt25, vec4 pt26, vec4 pt27, vec4 pt28, vec4 pt29, vec4 pt30, vec4 pt31, vec4 pt32, float width, __color color, float opacity) 
 float hw, dist1, dist2, interpolant; 
 vec2 p1, p2, p, v, w, s; 
 hw = width*0.5; 
 p = destCoord(); 
 p1 = pt1.rg; p2 = pt1.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist1 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist1 = compare(v.x*s.x + v.y*s.y, length(v), dist1); 
 w = p - p2; 
 dist1 = compare(w.x*s.x + w.y*s.y, dist1, length(w)); 
 p1 = pt2.rg; p2 = pt2.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt3.rg; p2 = pt3.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt4.rg; p2 = pt4.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt5.rg; p2 = pt5.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt6.rg; p2 = pt6.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt7.rg; p2 = pt7.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt8.rg; p2 = pt8.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt9.rg; p2 = pt9.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt10.rg; p2 = pt10.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt11.rg; p2 = pt11.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt12.rg; p2 = pt12.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt13.rg; p2 = pt13.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt14.rg; p2 = pt14.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt15.rg; p2 = pt15.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt16.rg; p2 = pt16.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt17.rg; p2 = pt17.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt18.rg; p2 = pt18.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt19.rg; p2 = pt19.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt20.rg; p2 = pt20.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt21.rg; p2 = pt21.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt22.rg; p2 = pt22.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt23.rg; p2 = pt23.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt24.rg; p2 = pt24.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt25.rg; p2 = pt25.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt26.rg; p2 = pt26.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt27.rg; p2 = pt27.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt28.rg; p2 = pt28.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt29.rg; p2 = pt29.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt30.rg; p2 = pt30.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt31.rg; p2 = pt31.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 p1 = pt32.rg; p2 = pt32.ba; 
 v = p - p1; 
 s = p2 - p1; 
 dist2 = abs((v.x*s.y - v.y*s.x) / max(length(s), 0.01)); 
 dist2 = compare(v.x*s.x + v.y*s.y, length(v), dist2); 
 w = p - p2; 
 dist2 = compare(w.x*s.x + w.y*s.y, dist2, length(w)); 
 dist1 = min(dist1, dist2); 
 interpolant = clamp(hw - dist1, 0.0, 1.0); 
 interpolant = (3.0 - 2.0*interpolant)*interpolant*interpolant; 
 return compare(vec4(dist1 - (hw - 1.0)), color, compare(vec4(dist1 - hw), color * interpolant, vec4(0.0))) * opacity; 
T@"NSArray",&,N,VinputMesh
inputLocal
inputGreyscale
T@"NSNumber",C,N,VinputSaturation
T@"NSNumber",C,N,VinputGreyscale
T@"NSNumber",&,N,VinputLocal
kernel vec4 _DEmin4luma(sampler image, vec2 bound) {
 vec2 d = 2.0*destCoord(); 
 vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5))); 
 vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5))); 
 vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5))); 
 vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5))); 
 vec3 Y = vec3(0.299, 0.587, 0.114); 
 float m0 = dot(p0.rgb, Y); 
 float m1 = dot(p1.rgb, Y); 
 float m2 = dot(p2.rgb, Y); 
 float m3 = dot(p3.rgb, Y); 
 if (m1 < m0 && d.x+0.5 < bound.x) {
 m0 = m1; 
 p0 = p1; 
 if (m3 < m2 && d.x+0.5 < bound.x) {
 m2 = m3; 
 p2 = p3; 
 if (m2 < m0 && d.y+0.5 < bound.y) {
 m0 = m2; 
 p0 = p2; 
 return p0; 
kernel vec4 _DEmax4luma(sampler image, vec2 bound) {
 vec2 d = 2.0*destCoord(); 
 vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5))); 
 vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5))); 
 vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5))); 
 vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5))); 
 vec3 Y = vec3(0.299, 0.587, 0.114); 
 float m0 = dot(p0.rgb, Y); 
 float m1 = dot(p1.rgb, Y); 
 float m2 = dot(p2.rgb, Y); 
 float m3 = dot(p3.rgb, Y); 
 if (m1 > m0 && d.x+0.5 < bound.x) {
 m0 = m1; 
 p0 = p1; 
 if (m3 > m2 && d.x+0.5 < bound.x) {
 m2 = m3; 
 p2 = p3; 
 if (m2 > m0 && d.y+0.5 < bound.y) {
 m0 = m2; 
 p0 = p2; 
 return p0; 
kernel vec4 _DEcomputeInversionMask(__sample c, __sample cmin, __sample cmax, float maxSaturation, float minRange) {
 float range = cmax.r - cmin.r; 
 float mean = cmin.r + range/2.0; 
 float vmin = min(min(c.r,c.g),c.b); 
 float vmax = max(max(c.r,c.g),c.b); 
 vec3 Y = vec3(0.299, 0.587, 0.114); 
 float luma = dot(c.rgb, Y); 
 float mask = (vmax / vmin > maxSaturation || luma > mean || range < minRange) ? 1.0 : 0.0; 
 float hardBit = 1.0; 
 return vec4(vec3(mask), hardBit); 
kernel vec4 _DEmin4(sampler image, vec2 bound) {
 vec2 d = 2.0*destCoord(); 
 vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5))); 
 vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5))); 
 vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5))); 
 vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5))); 
 p0 = (d.x+0.5 < bound.x) ? min(p0, p1) : p0; 
 p2 = (d.x+0.5 < bound.x) ? min(p2, p3) : p2; 
 p0 = (d.y+0.5 < bound.y) ? min(p0, p2) : p0; 
 return p0; 
kernel vec4 _DEmax4(sampler image, vec2 bound) {
 vec2 d = 2.0*destCoord(); 
 vec4 p0 = sample(image, samplerTransform(image, d + vec2(-0.5,-0.5))); 
 vec4 p1 = sample(image, samplerTransform(image, d + vec2(+0.5,-0.5))); 
 vec4 p2 = sample(image, samplerTransform(image, d + vec2(-0.5,+0.5))); 
 vec4 p3 = sample(image, samplerTransform(image, d + vec2(+0.5,+0.5))); 
 p0 = (d.x+0.5 < bound.x) ? max(p0, p1) : p0; 
 p2 = (d.x+0.5 < bound.x) ? max(p2, p3) : p2; 
 p0 = (d.y+0.5 < bound.y) ? max(p0, p2) : p0; 
 return p0; 
kernel vec4 _DEcreateForegroundMask(__sample c, __sample downMin, __sample downMax, __sample meanMin, __sample meanMax, vec4 params) {
 float threshMin = params.x; 
 float threshMaxOverMin = params.y; 
 float cutoff = params.z; 
 float epsChroma = params.w; 
 float cmincomp = min(c.r, min(c.g, c.b)); 
 float cmaxcomp = max(c.r, max(c.g, c.b)); 
 float luminance = dot(downMax.rgb, vec3(0.3333333)); 
 vec3 Y = vec3(0.299, 0.587, 0.114); 
 vec3 Cb = vec3(-0.168736, -0.331264, 0.5); 
 vec3 Cr = vec3(0.5, -0.418688, -0.081312); 
 vec3 YCbCr_c = vec3(dot(c.rgb,Y), dot(c.rgb,Cb), dot(c.rgb,Cr)); 
 vec3 YCbCr_bg = vec3(dot(downMax.rgb,Y), dot(meanMax.rgb,Cb), dot(meanMax.rgb,Cr)); 
 float dchromaticity = length(YCbCr_c.yz-YCbCr_bg.yz); 
 if (cmincomp < threshMin * luminance || cmaxcomp/cmincomp > threshMaxOverMin || dchromaticity > epsChroma) 
 c *= 0.0; 
 return c; 
kernel vec4 _DEnormalizeAlpha(__sample c) { return c * smoothstep(0.001, 0.1, c.a) / max(c.a,0.0001); }
kernel vec4 _DEWash(__sample c, __sample w) { return c / (0.000001 + w); }
kernel vec4 _DE_compinv(__sample u) __attribute__((outputFormat(kCIFormatRh))) { 
 return vec4(dot(vec3(1.0)-u.rgb, vec3(1.0/3.0)), 0., 0., 1.); 
kernel vec4 _DEconditionalFilter(__sample c, __sample d, __sample mask, float threshold) { return mask.r > threshold ? c : d; 
kernel vec4 _DE_sub(__sample u, __sample v) __attribute__((outputFormat(kCIFormatRh))) { vec3 Y = vec3(0.299, 0.587, 0.114); float Yu = dot(Y,u.rgb); float Yv = dot(Y,v.rgb); return vec4(Yv-Yu, 0., 0., 1.0); }
kernel vec4 _DE_scaleAdd(__sample u, __sample Yv, float s) { vec3 Y = vec3(0.299, 0.587, 0.114); vec3 Cb = vec3(-0.168736, -0.331264, 0.5); vec3 Cr = vec3(0.5, -0.418688, -0.081312); vec3 yR = vec3(1., 0., 1.4); vec3 yG = vec3(1., -0.344136, -0.714136); vec3 yB = vec3(1., 1.772, 0.); vec3 cu = vec3(dot(u.rgb,Y), dot(u.rgb,Cb), dot(u.rgb,Cr)); cu.x -= s * Yv.x; cu = vec3(dot(cu,yR), dot(cu,yG), dot(cu,yB)); return clamp(vec4(cu.rgb, 1.0), 0.0, u.a); }
kernel vec4 _CEstretch(__sample c, __sample lo, __sample hi, float amount) 
 float lov = min(min(lo.r,lo.g),lo.b); 
 float hiv = max(max(hi.r,hi.g),hi.b); 
 return vec4(mix(c.rgb, clamp((c.rgb-lov)/max(0.00001, hiv-lov), 0., 1.), amount), c.a); 
inputBottomLeft
inputBottomRight
inputTopRight
inputTopLeft
kernel vec2 _perspectiveTransform(vec3 A1, vec3 A2, vec3 A3, vec2 origin) 
 vec3 h = vec3(destCoord(), 1.0); 
 vec2 p = vec2(dot(h, A1), dot(h, A2)); 
 float w = 1.0 / max(dot(h, A3), 0.000001); 
 return p * w + origin; 
T@"CIVector",&,N,VinputTopLeft
T@"CIVector",&,N,VinputTopRight
T@"CIVector",&,N,VinputBottomRight
T@"CIVector",&,N,VinputBottomLeft
kernel vec4 _perspectiveMask(__sample p, vec3 A3) { return p * ((dot(vec3(destCoord(), 1.0), A3)<0.000001) ? 0.0 : 1.0); } 
inputCrop
kernel vec2 _perspectiveCorrection(vec3 A1, vec3 A2, vec3 A3) 
 vec3 h = vec3(destCoord(), 1.0); 
 vec2 p = vec2(dot(h, A1), dot(h, A2)); 
 return p / max(dot(h, A3), 0.000001); 
T@"NSNumber",&,N,VinputCrop
kernel vec2 _bumpDistortion(vec4 parms) 
 float d0 = clamp(distance(destCoord(), parms.zw) * -parms.x + 1.0, 0.0, 1.0); 
 d0 = ((d0 * -2.0 + 3.0) * d0 * d0) * parms.y + 1.0; 
 return (destCoord() - parms.zw) * d0 + parms.zw; 
kernel vec2 _bumpDistortionLinear(vec4 edgeFunc, vec4 vec) 
 float eFunc = dot(vec4(destCoord(), 1.0, 0.0), edgeFunc); 
 float r0 = clamp(1.0 - abs(eFunc), 0.0, 1.0); 
 r0 = ((r0 * -2.0 + 3.0) * r0 * r0) * vec.z + 1.0; 
 return destCoord() + (eFunc * (r0 - 1.0) * vec.xy); 
kernel vec4 _colorPolynomial (__sample c, vec4 cf0, vec4 cf1, vec4 cf2, vec4 cf3) { return cf0 + c * (cf1 + c * (cf2 + c * cf3)); }
inputRedCoefficients
inputGreenCoefficients
inputBlueCoefficients
inputAlphaCoefficients
T@"CIVector",&,N,VinputRedCoefficients
T@"CIVector",&,N,VinputGreenCoefficients
T@"CIVector",&,N,VinputBlueCoefficients
T@"CIVector",&,N,VinputAlphaCoefficients
kernel vec4 _colorCrossPolynomial (__sample c, vec3 pr, vec3 pg, vec3 pb, 
 vec3 prr, vec3 pgg, vec3 pbb, 
 vec3 prg, vec3 pgb, vec3 pbr, vec3 p1) 
 c.rgb = c.r * pr + c.g * pg + c.b * pb + 
 c.r * c.r * prr + c.g * c.g * pgg + c.b * c.b * pbb + 
 c.r * c.g * prg + c.g * c.b * pgb + c.b * c.r * pbr + p1; 
 return c; 
switch
CIFilter
inputHueMagMR
inputHueMagRY
inputHueMagYG
inputHueMagGC
inputHueMagCB
inputHueMagBM
inputRequestedSushiMode
RCCreateCIImageFromBufferAndProperties
raw-image
kCGImageSourceShouldUseRawDataForFulleSize
kCGImageSourceShouldUseRawDataForFullSize
kCGImageSourceSupportedSushiLevels
{Raw}
filters
RAWDemosaicFilter
RAWGamutMap
RAWReduceNoise
inputLNRAmount
inputCNRAmount
inputSharpenAmount
inputContrastAmount
inputDetailAmount
RAWRadialLensCorrection
inputLDCExecuteFlags
RAWConvert
RAWAdjustTempTint
inputWhitePoint
RAWAdjustExposureAndBias
RAWHueMagnet
RAWAdjustColorTRC
inputBoostAmount
RAWAdjustColors
RAWTemperatureAdjust
RAWLinearSpacePlaceholder
kCGImageSourceNoiseReductionAmount
kCGImageSourceLuminanceNoiseReductionAmount
kCGImageSourceColorNoiseReductionAmount
kCGImageSourceNoiseReductionSharpnessAmount
kCGImageSourceNoiseReductionContrastAmount
kCGImageSourceNoiseReductionDetailAmount
kCGImageSourceChromaBlurMoireAmount
kCGImageSourceDisableVendorLensDistortionCorrection
inputNeutralXY
PixelWidth
PixelHeight
{Raw}.filters
inputCropRect
{Exif}.PixelXDimension
{Exif}.PixelYDimension
RAWCropFilter
rawDictionary
T@"NSDictionary",R,&
rawReconstructionDefaultsDictionary
sushiMode
T@"NSNumber",R,&
rawMajorVersion
T@"NSArray",R,&
subsampling
nativeSize
T{CGSize=ff},R
-[CIRAWFilterImpl(CustomAccessors) inputImage]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/Raw/CIRAWFilterImpl.m
_inputImage != nil
-[CIRAWFilterImpl(CustomAccessors) setInputDecoderVersion:]
kCGImageSourceVendorLensCorrectionFeatures
RAWAdjustExposureAndBias.inputBias
RAWAdjustExposureAndBias.inputBaselineExposure
RAWHueMagnet.inputHueMagMR
RAWHueMagnet.inputHueMagRY
RAWHueMagnet.inputHueMagYG
RAWHueMagnet.inputHueMagGC
RAWHueMagnet.inputHueMagCB
RAWHueMagnet.inputHueMagBM
bsamt
RAWLensCorrectionDNG
RAWRadialLensCorrectionRB
<Unknown File>
Invalid parameter not satisfying: %@
(rVector != nil) && (gVector != nil) && (bVector != nil)
kernel vec4 _resetalpha(__sample src, __sample mask) 
 src.a = mask.a; 
 return src; 
kernel vec4 _colorClamp (__sample c, vec4 lo, vec4 hi) { return clamp(c,lo,hi); }
kernel vec4 _colorClampAP(__sample c, vec4 lo, vec4 hi) { return clamp(c,lo,hi); }
inputMinComponents
inputMaxComponents
T@"CIVector",&,N,VinputMinComponents
T@"CIVector",&,N,VinputMaxComponents
inputTexture
kernel vec4 _glassDistort (sampler tex0, sampler tex1, 
 vec2 scale_plus_unit, vec2 off0, vec2 off1, 
 vec2 off2, vec2 unit_to_glass, float height_factor) 
 vec2 dc = destCoord(); 
 vec2 dcscaled = dc * scale_plus_unit; 
 vec2 t0g = fract(dcscaled + off0) * unit_to_glass + vec2(.5); 
 vec2 t1g = fract(dcscaled + off1) * unit_to_glass + vec2(.5); 
 vec2 t2g = fract(dcscaled + off2) * unit_to_glass + vec2(.5); 
 float tcen = sample(tex1, samplerTransform(tex1, t0g)).r; 
 float tdx = sample(tex1, samplerTransform(tex1, t1g)).r; 
 float tdy = sample(tex1, samplerTransform(tex1, t2g)).r; 
 vec2 p = dc + vec2(tdx-tcen, tdy-tcen) * height_factor; 
 return sample(tex0, samplerTransform(tex0, p)); 
T@"CIImage",&,N,VinputTexture
kernel vec2 _stretchcrop (vec2 sizeIn, vec2 center, vec4 p) 
 vec2 a = p.xy, b = p.zw; 
 vec2 c = destCoord(); 
 c = (c-center)/sizeIn; 
 c = c / (a + b*abs(c)); 
 c = (c + 0.5)*sizeIn; 
 return c; 
inputCropAmount
inputCenterStretchAmount
kernel vec2 _ninePartStretched (vec2 bpmin, vec2 growth, vec2 slope) 
 vec2 dc = destCoord(); 
 vec2 c1 = slope * (dc - bpmin) + bpmin; 
 vec2 c2 = dc - growth; 
 return max(min(dc,c1),c2); 
inputBreakpoint0
inputBreakpoint1
inputGrowAmount
T@"CIVector",&,N,VinputBreakpoint0
T@"CIVector",&,N,VinputBreakpoint1
T@"CIVector",&,N,VinputGrowAmount
kernel vec2 _ninePartTiledAlt (vec4 bp01, vec2 growth, vec2 shift) 
 vec2 dc = destCoord(); 
 vec2 bp0 = bp01.xy; 
 vec2 bp1 = bp01.zw; 
 vec2 myMod; { 
 vec2 a = dc - shift; 
 vec2 b = bp1-bp0; 
 myMod = a - b*floor(a/b); 
 vec2 c1 = bp0 + myMod; 
 vec2 p = compare(dc - bp0, dc, c1); 
 p = compare(dc - (bp1+growth), p, dc - growth); 
 return p; 
inputFlipYTiles
T@"NSNumber",&,N,VinputFlipYTiles
inputGrainAmount
kernel vec4 _photoEffectDepthBlend (__sample fg, __sample bg, __sample depthMap, const float thresh) 
 float d = min(2.0*depthMap.r, 1.0); 
 vec3 blended = mix(fg.rgb, bg.rgb, d); 
 float g = smoothstep(thresh, thresh+.15, d); 
 blended = mix(fg.rgb, blended, g); 
 return vec4(blended, fg.a); 
%@BG
com.apple.coreimage.photoEffects3DIsolation
inputDepthMap
T@"CIImage",&,N,VinputDepthMap
T@"NSNumber",&,N,VinputGrainAmount
float _cheapnoise(vec2 dc) 
 float x = 0.7647058824*dc.x + 65.3529411765; 
 float y = 0.5789473684*dc.y + 409.3157894737; 
 float n = mod(x*mod(y*mod(y*x + y, 37.0) + x, 37.0), 37.0); 
 return n * 0.027027027027027; 
 kernel vec4 _noiseGen(float dither, float scale) __attribute__((outputFormat(kCIFormatRh))) { 
 return vec4(_cheapnoise(floor(destCoord())) - 0.5)*dither; 
+[PercentileClipProcessor_RGBA8_CPU formatForInputAtIndex:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/CIDualRedEyeRepairFilter.mm
threshold
area
centerOffsetLeft
centerOffsetRight
interPeakMinRepair
abortMaxCenterDist
densityRadius
minDensity
maxRelDensity
percentileRepair
percentileSpecular
percentRepair
percentSpecular
+[PercentileClipProcessor_RGBA8_CPU processWithInputs:arguments:output:error:]
iRowbytes == oRowbytes
w == oW && h == oH
tuning
inputCenterLeft
T@"CIImage",&,N,VinputCenterLeft
inputCenterRight
T@"CIImage",&,N,VinputCenterRight
inputPercentileRepair
T@"NSNumber",&,N,VinputPercentileRepair
inputPercentileSpecular
T@"NSNumber",&,N,VinputPercentileSpecular
inputPercentRepair
T@"NSNumber",&,N,VinputPercentRepair
inputPercentSpecular
T@"NSNumber",&,N,VinputPercentSpecular
inputInterPeakMinRepair
T@"NSNumber",&,N,VinputInterPeakMinRepair
inputAbortMaxCenterDist
T@"NSNumber",&,N,VinputAbortMaxCenterDist
inputMinDensity
T@"NSNumber",&,N,VinputMinDensity
inputMaxRelDensity
T@"NSNumber",&,N,VinputMaxRelDensity
inputDensityRadius
T@"NSNumber",&,N,VinputDensityRadius
inputMinimum
T@"CIVector",&,N,VinputMinimum
inputMaxArea
T@"CIVector",&,N,VinputMaxArea
inputCenterOffsetLeft
T@"CIVector",&,N,VinputCenterOffsetLeft
inputCenterOffsetRight
T@"CIVector",&,N,VinputCenterOffsetRight
inputDetectionLeft
T@"CIImage",&,N,VinputDetectionLeft
inputDetectionRight
T@"CIImage",&,N,VinputDetectionRight
inputTuning
T@"NSNumber",&,N,VinputTuning
+[ConvexFillProcessor processWithInputs:arguments:output:error:]
kThreshold
kAreaThresholdHi
kAreaThresholdLo
kSplatArea
inputAreaThresholdLoHi
T@"CIVector",&,N,VinputAreaThresholdLoHi
T@"NSNumber",&,N,VinputSplat
+[CISeedFillProcessor processWithInputs:arguments:output:error:]
fabs(inputCenter.region.size.width-1.0) <= 0.0001 && fabs(inputCenter.region.size.height-1.0) <= 0.0001
kernel vec4 _CD2_intersect(__sample f, __sample c, __sample a, float denorm) __attribute__((outputFormat(kCIFormatRh))) { vec2 p = destCoord(); 
 return f * (dot(p-c.xy,p-c.xy) <= a.x * denorm ? 1.0 : 0.0); 
kernel vec4 _CD2_m(__sample a, __sample aI) __attribute__((outputFormat(kCIFormatRh))) { return 1.0 - abs(a-aI)/max(a+aI,0.0001); 
inputCentroid
T@"CIImage",&,N,VinputCentroid
kernel vec4 _drr_spec(__sample img, __sample c, __sample specular, float specularScale, float specthreshold, float debugBit) { 
 float y = 0.5*(c.r+c.g+c.b-min(min(c.r,c.g),c.b)); 
 float specularSmoothstep = 0.6; 
 float s = min(1.0, specularScale*y); 
 s = smoothstep(0.0, specularSmoothstep, s); 
 specular.r = min(1.0, 1.25*specular.r); vec3 spec = vec3(s); 
 img.rgb = specular.r > specthreshold ? mix(img.rgb, spec, specular.r) : img.rgb; 
 return img; 
kernel vec4 _drr_spec_debug(__sample img, __sample c, __sample specular, float specularScale, float specthreshold, float debugBit) { 
 float y = 0.5*(c.r+c.g+c.b-min(min(c.r,c.g),c.b)); 
 float specularSmoothstep = 0.6; 
 float s = min(1.0, specularScale*y); 
 s = smoothstep(0.0, specularSmoothstep, s); 
 specular.r = min(1.0, 1.25*specular.r); vec3 spec = vec3(s); 
 img.rgb = specular.r > specthreshold ? mix(img.rgb, spec, specular.r) : img.rgb; 
 if (debugBit < 1.0) 
 return img; 
 else if (debugBit < 2.0) 
 img.gb *= 0.0; 
 else if (debugBit < 3.0) 
 img.rb *= 0.0; 
 return img; 
inputSpecularMask
T@"CIImage",&,N,VinputSpecularMask
inputSpecularThreshold
T@"NSNumber",&,N,VinputSpecularThreshold
T@"NSNumber",&,N,VinputSpecIntensity
inputDebugFlag
T@"NSNumber",&,N,VinputDebugFlag
kernel vec4 _rer_repair(__sample img, __sample c, __sample m, __sample avg, __sample noise, float brightness, float noiseAmount, float whiteCutoff, float chroma) { 
 float mixer = m.r; 
 vec3 Y = vec3(0.299, 0.587, 0.114); 
 float nn = noise.r; 
 avg.rgb += 2.0*noiseAmount*nn; 
 vec3 source = c.rgb; c.rgb += noiseAmount*nn; 
 float rg = max(0.,img.r-img.g)/max(0.0001,img.r+img.g); 
 float rb = max(0.,img.r-img.b)/max(0.0001,img.r+img.b); 
 float redness = max(0.25,0.5*(rg+rb)); 
 redness = smoothstep(0.1, 0.6, redness); 
 vec3 replacementRed = 0.5*brightness*vec3(min(c.b, c.g)); 
 vec3 replacementWhite = 2.0*brightness*avg.rgb; 
 vec3 replacement = mix(replacementWhite, replacementRed, redness); 
 float Lrep = dot(replacement, Y); 
 float Lavg = dot(avg.rgb, Y); 
 replacement = mix(replacement, avg.rgb * Lrep * Lavg, chroma); 
 replacement = max(0.06*avg.rgb, replacement); 
 float n = dot(img.rgb, Y); float whiteness = smoothstep(0.01+whiteCutoff, 1.01, n); 
 replacement.rgb = mix(replacement.rgb, vec3(n), whiteness); 
 mixer *= 1.0-whiteness; 
 img.rgb = mix(img.rgb, replacement, mixer); 
 img.rgb = mix(source, img.rgb, m.r); 
 return img; 
kernel vec4 _rer_recovery(__sample img, __sample c, __sample avg, __sample avgRaw, float recovery) { 
 float mixer = 0.0; 
 float n = dot(c.rgb, vec3(1.0/3.0)); 
 float highlightNeutrality = 0.0; 
 float cmixer = recovery*(1.0-smoothstep(0.0, 0.2, mixer)) * smoothstep(0.6, 0.95, min(min(img.r,img.g),img.b)); 
 vec3 highlightReplacement = mix(c.rgb, vec3(n), highlightNeutrality) * avg.rgb / avgRaw.rgb; 
 img.rgb = min(img.rgb, mix(img.rgb, highlightReplacement, cmixer)); 
 return img; 
CheapRandomness
inputNoiseAmount
T@"NSNumber",&,N,VinputNoiseAmount
inputRecovery
T@"NSNumber",&,N,VinputRecovery
T@"NSNumber",&,N,VinputWhiteCutoff
inputChroma
T@"NSNumber",&,N,VinputChroma
inputAnisotropic
T@"NSNumber",&,N,VinputAnisotropic
inputIterations
T@"NSNumber",&,N,VinputIterations
T@"NSNumber",&,N,VinputGamma
inputLocalizationRadius
T@"NSNumber",&,N,VinputLocalizationRadius
inputDebug
T@"NSNumber",&,N,VinputDebug
inputAxisLong
T@"CIVector",&,N,VinputAxisLong
inputAxisShort
T@"CIVector",&,N,VinputAxisShort
inputPupilCenter
T@"CIVector",&,N,VinputPupilCenter
inputSearchAxisLong
T@"NSNumber",&,N,VinputSearchAxisLong
inputSearchAxisShort
T@"NSNumber",&,N,VinputSearchAxisShort
-[CIRedEyeRaw outputImage]
kernel vec4 _drr_boost(__sample c, float s) { 
 return vec4(s*c.rgb, c.a); 
RedPupilLocalizer
RadialFalloffFilter
HistoClip_RGBA8_CPU
CICircularityDescriptor
CIConvexFill
RedEyeRecolor
RedEyeSpecular
kernel vec4 _drr_threshold(__sample s, __sample m, float threshold) { 
 return s * step(threshold, m.r); 
T@"CIImage",&,N,VinputPrimary
T@"CIImage",&,N,VinputSecondary
T@"CIVector",&,N,VinputOriginLeft
T@"CIVector",&,N,VinputOriginRight
T@"CIVector",&,N,VinputAxisShortLeft
T@"CIVector",&,N,VinputAxisShortRight
T@"CIVector",&,N,VinputAxisLongLeft
T@"CIVector",&,N,VinputAxisLongRight
T@"CIVector",&,N,VinputPupilCenterLeft
T@"CIVector",&,N,VinputPupilCenterRight
T@"NSNumber",&,N,VinputRepairSource
T@"NSNumber",&,N,VinputRepairDarken
T@"NSNumber",&,N,VinputRepairChroma
T@"NSNumber",&,N,VinputCutoff
T@"NSNumber",&,N,VinputSpecMin
T@"NSNumber",&,N,VinputSpecMax
T@"NSNumber",&,N,VinputOrientationHint
T@"NSNumber",&,N,VinputOrientationScale
T@"NSNumber",&,N,VinputSpecular
T@"NSNumber",&,N,VinputShowMask
T@"NSNumber",&,N,VinputRepairPercent
T@"NSNumber",&,N,VinputInterPeakMin
T@"NSNumber",&,N,VinputRepairPercentile
T@"NSNumber",&,N,VinputClipMin
T@"CIVector",&,N,VinputMidSpectrumWhiteOffsets
T@"NSNumber",&,N,VinputClosingErosion
T@"NSNumber",&,N,VinputClosingDilation
T@"NSNumber",&,N,VinputFlooding
T@"NSNumber",&,N,VinputFeathering
T@"NSNumber",&,N,VinputFSmooth
T@"NSNumber",&,N,VinputRepairDither
T@"NSNumber",&,N,VinputRecover
T@"NSNumber",&,N,VinputSpecArea
T@"NSNumber",&,N,VinputAbortDensityLo
T@"NSNumber",&,N,VinputAbortDensityDiff
T@"NSNumber",&,N,VinputCircularity
T@"NSNumber",&,N,VinputIntersect
T@"NSNumber",&,N,VinputSkinThreshold
T@"NSNumber",&,N,VinputFalloffDensity
T@"NSNumber",&,N,VinputFalloffRepair
T@"NSNumber",&,N,VinputFalloffSpecular
T@"NSNumber",&,N,VinputRadiusRepair
T@"NSNumber",&,N,VinputRadiusDensity
T@"NSNumber",&,N,VinputRadiusSpecular
T@"NSNumber",&,N,VinputCenterSpecRad
T@"NSNumber",&,N,VinputFoobar
T@"NSNumber",&,N,VinputFoobar2
T@"NSNumber",&,N,VinputFoobar3
T@"NSNumber",&,N,VinputFoobar4
T@"NSNumber",&,N,VinputCentroidIterations
T@"NSNumber",&,N,VinputCentroidGamma
T@"NSNumber",&,N,VinputCentroidRadius
T@"NSNumber",&,N,VinputCentroidRadiusSmall
T@"NSNumber",&,N,VinputRefilterSpace
T@"NSNumber",&,N,VinputRefilterRange
T@"NSNumber",&,N,VinputDetectWhite
T@"NSNumber",&,N,VinputDetectRed
convexFillHorizontal
kernel vec4 _drr_puncturec2(__sample center, float r, float hardness, vec2 s) __attribute__((outputFormat(kCIFormatRh))) { 
 vec2 p = destCoord(); float d = (p.x-center.x)*(p.x-center.x)*s.x + (p.y-center.y)*(p.y-center.y)*s.y; 
 d = 1.0-smoothstep(hardness*r*r, r*r, d); 
 return vec4(d, 0.0, 0.0, 1.0); 
kernel vec4 _drr_puncturec2_hard(__sample center, float r, float hardness, vec2 s) __attribute__((outputFormat(kCIFormatRh))) { 
 vec2 p = destCoord(); float d = (p.x-center.x)*(p.x-center.x)*s.x + (p.y-center.y)*(p.y-center.y)*s.y; 
 return vec4(d <= r*r ? 1.0 : 0.0); 
kernel vec4 _drr_maximumRh(__sample a, __sample b) __attribute__((outputFormat(kCIFormatRh))) { 
 return max(a,b); 
kernel vec4 _drr_mmv(vec2 center, vec2 u, vec2 v, float c, float s, float normu, float normv, float plateau) __attribute__((outputFormat(kCIFormatRh))) { vec2 p = destCoord(); vec2 w = p-center; vec2 qu = w - dot(w,u) * u; vec2 qv = w - dot(w,v) * v; float du = sqrt(dot(qu,qu)) * normu; float dv = sqrt(dot(qv,qv)) * normv; float mu = 1.0-smoothstep(s*c, c, du); float mv = 1.0-smoothstep(s*c, c, dv); float m = mu*mv; m = m > plateau ? 1.0 : m; return vec4(m, 0.0, 0.0, 1.0); }
kernel vec4 _drr_mmi(__sample center, vec2 u, vec2 v, float c, float s, float normu, float normv, float plateau) __attribute__((outputFormat(kCIFormatRh))) { vec2 p = destCoord(); vec2 w = p-center.xy; vec2 qu = w - dot(w,u) * u; vec2 qv = w - dot(w,v) * v; float du = sqrt(dot(qu,qu)) * normu; float dv = sqrt(dot(qv,qv)) * normv; float mu = 1.0-smoothstep(s*c, c, du); float mv = 1.0-smoothstep(s*c, c, dv); float m = mu*mv; m = m > plateau ? 1.0 : m; return vec4(m, 0.0, 0.0, 1.0); }
RRradialEllipticalMask
kernel vec4 _drr_multiply(__sample a, __sample b) __attribute__((outputFormat(kCIFormatRh))) { 
 return a*b; 
kernel vec4 _drr_pclip(__sample c, float t) { c.r = c.r < t ? 0.0 : c.r; 
 c.g = c.g < t ? 0.0 : c.g; 
 c.b = c.b < t ? 0.0 : c.b; 
 return c; }
kernel vec4 _drr_rawred_sm(__sample c, float whiteness, float spectrum) __attribute__((outputFormat(kCIFormatRh))) { if (c.r < 0.005) { return vec4(0.0, 0.0, 0.0, 1.0); 
 } float n = dot(c.rgb, vec3(1.0/3.0)); 
 float rv = (c.r-n)*(c.r-n) + (c.g-n)*(c.g-n) + (c.b-n)*(c.b-n); 
 rv /= max(0.0001,n); 
 float rg = max(0.,c.r-c.g)/max(0.00001,c.r+c.g); 
 float rb = max(0.,c.r-c.b)/max(0.00001,c.r+c.b); 
 float rm = min(rg,rb); 
 float r = rv * rm; 
 r *= 10.0; r *= r; 
 float w = max(0.0, c.r - whiteness*max(c.g,c.b)); 
 r = mix(r, w, spectrum); 
 return vec4(r, 0.0, 0.0, 1.0); 
kernel vec4 _drr_rawred_large(__sample c, float whiteness, float spectrum) __attribute__((outputFormat(kCIFormatRh))) { if (c.r < 0.005) { return vec4(0.0, 0.0, 0.0, 1.0); 
 } float n = dot(c.rgb, vec3(1.0/3.0)); 
 float rv = (c.r-n)*(c.r-n) + (c.g-n)*(c.g-n) + (c.b-n)*(c.b-n); 
 rv /= max(0.0001,n); 
 float rg = max(0.,c.r-c.g)/max(0.00001,c.r+c.g); 
 float rb = max(0.,c.r-c.b)/max(0.00001,c.r+c.b); 
 float rm = min(rg,rb); 
 float r = mix(1.0, rv, spectrum)*rm; 
 float w = c.r; r = mix(r, w, whiteness); 
 return vec4(r, 0.0, 0.0, 1.0); 
kernel vec4 _drr_detect_specs(__sample primary, __sample secondary, float tuning, float cutoff) __attribute__((outputFormat(kCIFormatRh))) { 
 float spec2 = min(secondary.r, secondary.b) * max(0.0, sign(secondary.b-tuning*secondary.g)); 
 float s = spec2 * max(0.0, sign(spec2-cutoff)); 
 return vec4(1.0-s, 0.0, 0.0, 1.0); 
kernel vec4 _drr_specular(__sample c) __attribute__((outputFormat(kCIFormatRh))) { 
 float r = 0.5*(c.r+c.g+c.b-min(min(c.r,c.g),c.b)); 
 return vec4(r); 
kernel vec4 _drr_maxScalarRh(__sample a, float v) __attribute__((outputFormat(kCIFormatRh))) { 
 a.r = max(a.r, v); 
 return a; 
kernel vec4 _drr_puncture2(vec2 center, float r, float hardness, vec2 s) __attribute__((outputFormat(kCIFormatRh))) { 
 vec2 p = destCoord(); float d = (p.x-center.x)*(p.x-center.x)*s.x + (p.y-center.y)*(p.y-center.y)*s.y; 
 d = 1.0-smoothstep(hardness*r*r, r*r, d); 
 return vec4(d, 0.0, 0.0, 1.0); 
kernel vec4 _drr_puncture2_hard(vec2 center, float r, float hardness, vec2 s) __attribute__((outputFormat(kCIFormatRh))) { 
 vec2 p = destCoord(); float d = (p.x-center.x)*(p.x-center.x)*s.x + (p.y-center.y)*(p.y-center.y)*s.y; 
 return vec4(d <= r*r ? 1.0 : 0.0); 
kernel vec4 _drr_combine_rgba(__sample r, __sample g, __sample b, __sample a) { 
 return vec4(r.x, g.x, b.x, a.x); 
kernel vec4 _drr_r(__sample c) __attribute__((outputFormat(kCIFormatR8))) { 
 return vec4(c.r, 0.0, 0.0, 1.0); 
kernel vec4 _drr_g(__sample c) __attribute__((outputFormat(kCIFormatR8))) { 
 return vec4(c.g, 0.0, 0.0, 1.0); 
kernel vec4 _drr_b(__sample c) __attribute__((outputFormat(kCIFormatR8))) { 
 return vec4(c.b, 0.0, 0.0, 1.0); 
kernel vec4 _drr_a(__sample c) __attribute__((outputFormat(kCIFormatR8))) { 
 return vec4(c.a, 0.0, 0.0, 1.0); 
kernel vec4 _drr_maxmask(__sample a, __sample b) __attribute__((outputFormat(kCIFormatRh))) { 
 return a.r > 0.0 ? max(a,b) : a; 
kernel vec4 _drr_binarize_alpha_inv(__sample c, __sample m) __attribute__((outputFormat(kCIFormatRGBAh))) { 
 c *= m.r > 0.001 ? 0.0 : 1.0; 
 return c; 
kernel vec4 _drr_binarize_alpha(__sample c, __sample m) __attribute__((outputFormat(kCIFormatRGBAh))) { 
 c *= m.r > 0.001 ? 1.0 : 0.0; 
 return c; 
kernel vec4 _drr_binarize(__sample m) __attribute__((outputFormat(kCIFormatRh))) { 
 m.r = m.r > 0.00001 ? 1.0 : 0.0; 
 return m; } 
kernel vec4 _drr_binarize_inv(__sample m) __attribute__((outputFormat(kCIFormatRh))) { 
 m.r = m.r > 0.00001 ? 0.0 : 1.0; 
 return m; } 
kernel vec4 _drr_chromaexc(__sample a, __sample b, float t2) __attribute__((outputFormat(kCIFormatRh))) { 
 vec3 diff = a.rgb-b.rgb; 
 float n = min(a.r, b.r); 
 float exc = dot(diff, diff) < t2*n ? 0.0 : 1.0; 
 return vec4(exc, 0.0, 0.0, 1.0) ; 
kernel vec4 _rr_conditionalZeroRh(__sample img, __sample mask, float threshold) __attribute__((outputFormat(kCIFormatRh))) { return img * (mask.r > threshold ? 1.0 : 0.0); 
kernel vec4 _drr_smoothstepRh(__sample m, float cutoff) __attribute__((outputFormat(kCIFormatRh))) { 
 return vec4(smoothstep(0.0, cutoff, m.r), 0.0, 0.0, 1.0); 
kernel vec4 _drr_refilter_chan(__sample img) { 
 return vec4(img.r, img.r, img.r, img.a); 
kernel vec4 _drr_rcsoft(__sample center, float scale2, float hardness, float norm) __attribute__((outputFormat(kCIFormatRh))) { 
 vec2 p = destCoord(); float d = (p.x-center.x)*(p.x-center.x)*norm + (p.y-center.y)*(p.y-center.y)*norm; 
 d = 1.0-smoothstep(hardness*scale2, scale2, d); 
 return vec4(d, 0.0, 0.0, 1.0); 
10.?
inputHeight
inputLowLimit
inputHighLimit
kernel vec4 _histogram_display (sampler image, float height, vec2 hilo) 
    vec2  d = destCoord(); 
    vec2  histcoord = vec2(floor(d.x)+0.5, 0.5); 
    vec4  v = sample(image, samplerTransform(image, histcoord)); 
    v = step(vec4(d.y), height*v); 
    float vi = v.r*4.0 + v.g*2.0 + v.b; 
    vec4 p = vec4(.25,.25,.25,1.0); 
    p = (vi==4.0) ? vec4(.50,.05,.05,1.0) : p; 
    p = (vi==6.0) ? vec4(.20,.40,.05,1.0) : p; 
    p = (vi==2.0) ? vec4(.05,.50,.05,1.0) : p; 
    p = (vi==3.0) ? vec4(.05,.20,.40,1.0) : p; 
    p = (vi==1.0) ? vec4(.05,.05,.50,1.0) : p; 
    p = (vi==5.0) ? vec4(.20,.05,.40,1.0) : p; 
    p = (vi==7.0) ? vec4(.05,.10,.30,1.0) : p; 
    p.rgb = (d.x<hilo.x+0.5)  ? p.rgb*vec3(0.4)             : p.rgb; 
    p.rgb = (d.x>=hilo.y+0.5) ? p.rgb*vec3(0.6) + vec3(0.4) : p.rgb; 
    return p; 
T@"NSNumber",&,N,VinputHeight
T@"NSNumber",&,N,VinputHighLimit
T@"NSNumber",&,N,VinputLowLimit
MetalTextureManager_block_invoke
%llX(%04X)
Cannot handle a (%lu x %lu) sized texture with the given context!
CI::KernelCompileQueue
metal
kContextInfoSupportsMPS
kContextInfoWorkingFormat
kContextInfoWorkingSpace
CI::TileTask
CI::ProgramNode
CI_PRINT_TIME [GPU] root program (%s) = %.1f ms
CI_PRINT_TIME [GPU] intermediate program (%s) = %.1f ms
kernel vec4 _localContrast(__sample im, __sample shc, float amt)
  float midAmt = amt;
  vec3 neg = min(im.rgb, 0.0);
  vec3 pos = max(im.rgb, 1.0)-1.0;
  im.rgb = clamp(im.rgb, 0.0, 1.0);
  float y = dot(im.rgb, vec3(0.3333));
  y = sqrt(y);
  y = y*(1.0-y);
  im.rgb = sqrt(im.rgb);
  float pivot = sqrt(shc.g);
  float a = midAmt*y;
  float b = -pivot*a;
  vec3 pix = im.r * vec3(0.299*a) +
             im.g * vec3(0.587*a) +
             im.b * vec3(0.114*a) +
             im.rgb + vec3(b);
  im.rgb = mix(im.rgb, vec3(pivot), -y*midAmt);
  im.rgb = mix(im.rgb, pix, 0.8);
  im.rgb = max(im.rgb, 0.0);
  im.rgb *= im.rgb;
  im.rgb = im.rgb + neg + pos;
  return im;
inputBottomHeight
inputNumberOfFolds
inputFoldShadowAmount
kernel vec2 _accordianWarpS (vec3 foldParms, vec4 dims) 
 float numFoldsX2 = foldParms.x; 
 float foldScaleH = foldParms.y; 
 float bottomHeight = dims.x; 
 float gap = dims.y; 
 vec2 dc = destCoord(); 
 float x = dc.x; 
 float y = dc.y; 
 float gapLoc = clamp((y - bottomHeight) / gap, 0.0, 1.0); 
 float gapLocSaw = 1.0 - abs(mod((numFoldsX2*gapLoc), 2.0) - 1.0); 
 float hScale = 1.0 + foldScaleH*gapLocSaw; 
 vec2 pS; 
 pS.y = min( y, max( y-gap, bottomHeight)); 
 pS.x = x * hScale; 
 return pS; 
kernel vec2 _accordianWarpT (vec3 foldParms, vec4 dims) 
 float numFoldsX2 = foldParms.x; 
 float foldScaleH = foldParms.y; 
 float bottomHeight = dims.x; 
 float gap = dims.y; 
 vec2 dc = destCoord(); 
 float x = dc.x; 
 float y = dc.y; 
 float gapLoc = clamp((y - bottomHeight) / gap, 0.0, 1.0); 
 float gapLocSaw = 1.0 - abs(mod((numFoldsX2*gapLoc), 2.0) - 1.0); 
 float hScale = 1.0 + foldScaleH*gapLocSaw; 
 vec2 pT; 
 pT.y = max( y, min ( (y-bottomHeight)*dims.z + bottomHeight, y+dims.w )); 
 pT.x = x * hScale; 
 return pT; 
kernel vec4 _accordionMix ( 
 __sample cS, __sample cT, 
 vec3 foldParms, float time, vec4 dims) 
 float numFoldsX2 = foldParms.x; 
 float foldShadeAmt = foldParms.z; 
 float bottomHeight = dims.x; 
 float gap = dims.y; 
 vec2 dc = destCoord(); 
 float y = dc.y; 
 float gapLoc = clamp((y - bottomHeight) / gap, 0.0, 1.0); 
 float shadeAmt = 1.0 - foldShadeAmt*mod((numFoldsX2*gapLoc), 1.0); 
 vec4 result = mix(cS, cT, time); 
 result.rgb *= shadeAmt; 
 return result; 
kernel vec4 _accordionFoldTransition ( 
 sampler shortImage, sampler tallImage, 
 vec3 foldParms, float time, vec4 dims) 
 float numFoldsX2 = foldParms.x; 
 float foldScaleH = foldParms.y; 
 float foldShadeAmt = foldParms.z; 
 float bottomHeight = dims.x; 
 float gap = dims.y; 
 vec2 dc = destCoord(); 
 float x = dc.x; 
 float y = dc.y; 
 float gapLoc = clamp((y - bottomHeight) / gap, 0.0, 1.0); 
 float gapLocSaw = 1.0 - abs(mod((numFoldsX2*gapLoc), 2.0) - 1.0); 
 float shadeAmt = 1.0 - foldShadeAmt*mod((numFoldsX2*gapLoc), 1.0); 
 float hScale = 1.0 + foldScaleH*gapLocSaw; 
 vec2 pS; 
 pS.y = min( y, max( y-gap, bottomHeight)); 
 pS.x = x * hScale; 
 vec4 cS = sample(shortImage, samplerTransform(shortImage, pS)); 
 vec2 pT; 
 pT.y = max( y, min ( (y-bottomHeight)*dims.z + bottomHeight, y+dims.w )); 
 pT.x = x * hScale; 
 vec4 cT = sample(tallImage, samplerTransform(tallImage, pT)); 
 vec4 result = mix(cS, cT, time); 
 result.rgb *= shadeAmt; 
 return result; 
T@"NSNumber",&,N,VinputBottomHeight
T@"NSNumber",&,N,VinputNumberOfFolds
T@"NSNumber",&,N,VinputFoldShadowAmount
kernel %s
<CI::%s %p [%s]>
inputPropagateKernel
inputSmoothSigma
inputPropogateMinWeightSum
inputPropogateSigmaLuma
inputPropogateSigmaChroma
kernel vec4 _CIInitialConversionRGB(sampler image,vec2 scale)
vec2 sp = destCoord() * scale;
    vec4 b0b3, c0c3, a0a3, d0d3;
    b0b3 = sample(image, samplerTransform(image, sp + vec2(-2.0, 0.0)));
    c0c3 = sample(image, samplerTransform(image, sp + vec2( 2.0, 0.0)));
    a0a3 = sample(image, samplerTransform(image, sp + vec2( 0.0, 2.0)));
    d0d3 = sample(image, samplerTransform(image, sp + vec2( 0.0,-2.0)));
    vec4 g = abs(c0c3 - b0b3) + abs(d0d3 - a0a3);
    vec4 outPix = sample(image, samplerTransform(image, sp));
    outPix.w  = min(max(g.x, max(g.y,g.z)), 1.0);
    return outPix;
kernel vec4 _CIPyramidGenerateLevel(sampler inYuva)
    vec2 gid2 = destCoord() * 2.0;
    vec4 pix_0_0 = sample(inYuva, samplerTransform(inYuva, gid2 + vec2(-0.5, -0.5)));
    vec4 pix_1_0 = sample(inYuva, samplerTransform(inYuva, gid2 + vec2(-0.5,  0.5)));
    vec4 pix_0_1 = sample(inYuva, samplerTransform(inYuva, gid2 + vec2( 0.5, -0.5)));
    vec4 pix_1_1 = sample(inYuva, samplerTransform(inYuva, gid2 + vec2( 0.5,  0.5)));
    
    if (pix_1_0.w > pix_0_0.w) pix_0_0 = pix_1_0;
    if (pix_0_1.w > pix_0_0.w) pix_0_0 = pix_0_1;
    if (pix_1_1.w > pix_0_0.w) pix_0_0 = pix_1_1;
    
    return pix_0_0;
float _local_yuvWeightG(vec4 pix1,vec4 pix2,vec2 sigmaLumaChmaRecip)
    vec3 yuv = pix1.xyz - pix2.xyz;
    yuv.xyz = (yuv.xyz * yuv.xyz) * sigmaLumaChmaRecip.xyy;
    return exp(-(yuv.x+yuv.y+yuv.z));
kernel vec4 _CIPropagateDisparity(sampler inDispMap,sampler yuv0,sampler yuv1,vec4 params)
    int   radius        = int(params.x); 
    vec2  sigmaLCRecip  = params.yz;
    float pmws          = params.w; 
    vec2  dc            = destCoord();
    vec2 gidHalf = floor(0.5*dc) + vec2(0.5);
    vec4  ref           = sample(yuv0, samplerTransform(yuv0, dc));
    float sow           = 0.0;
    float sowd          = 0.0;
    
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
        
 vec2 p  = vec2(float(x),float(y));
            vec4 p2 = sample(yuv1,      samplerTransform(yuv1,      gidHalf + p));
            float d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + p)).r;
            float w = _local_yuvWeightG(ref, p2, sigmaLCRecip);
            sow+= w; sowd+= w * d;
        }
    }
    float alt = sample(inDispMap, samplerTransform(inDispMap, gidHalf)).r;
    float rc = (sow < pmws) ? alt : (sowd / sow);
return vec4(rc,rc,rc,1.0);
float _local_yuvWeight(vec4 pix1,vec4 pix2,vec2 sigmaLumaChmaRecip)
    vec3 yuv = pix1.xyz - pix2.xyz;
    yuv.xyz = (yuv.xyz * yuv.xyz) * sigmaLumaChmaRecip.xyy;
    return exp(-(yuv.x+yuv.y+yuv.z));
kernel vec4 _CIPropagateDisparityR1(sampler inDispMap,sampler yuv0,sampler yuv1,vec4 params)
    vec2  sigmaLCRecip  = params.yz;
    float pmws          = params.w; 
    vec2  dc            = destCoord();
    vec2 gidHalf = floor(0.5*dc) + vec2(0.5);
    vec4  ref           = sample(yuv0, samplerTransform(yuv0, dc));
    float sow           = 0.0;
    float sowd          = 0.0;
    
    vec4 p;
    float d, w;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2(-1.0, -1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2(-1.0, -1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 0.0, -1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 0.0, -1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 1.0, -1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 1.0, -1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2(-1.0, 0.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2(-1.0, 0.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 0.0, 0.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 0.0, 0.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    float alt = d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 1.0, 0.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 1.0, 0.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2(-1.0, 1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2(-1.0, 1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 0.0, 1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 0.0, 1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    p = sample(yuv1,      samplerTransform(yuv1,      gidHalf + vec2( 1.0, 1.0)));
    d = sample(inDispMap, samplerTransform(inDispMap, gidHalf + vec2( 1.0, 1.0))).r;
    w = _local_yuvWeight(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * d;
    float rc = (sow < pmws) ? alt : (sowd / sow);
return vec4(rc,rc,rc,1.0);
float _local_yuvWeightC(vec4 pix1,vec4 pix2,vec2 sigmaLumaChmaRecip)
    vec3 yuv = pix1.xyz - pix2.xyz;
    yuv.xyz = (yuv.xyz * yuv.xyz) * sigmaLumaChmaRecip.xyy;
    return exp(-(yuv.x+yuv.y+yuv.z));
kernel vec4 _CIPropagateDisparityR1C(sampler image,sampler yuv0,vec4 params)
    vec2  sigmaLCRecip  = params.yz;
    float pmws          = params.w; 
    vec2  dc            = destCoord();
    vec2 gidHalf = floor(0.5*dc) + vec2(0.5);
    vec4  ref           = sample(yuv0, samplerTransform(yuv0, dc));
    float sow           = 0.0;
    float sowd          = 0.0;
    
    vec4 p;
    float w;
    p = sample(image, samplerTransform(image, gidHalf + vec2(-1.0, -1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 0.0, -1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 1.0, -1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2(-1.0, 0.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    float alt = p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 1.0, 0.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2(-1.0, 1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 0.0, 1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    p = sample(image, samplerTransform(image, gidHalf + vec2( 1.0, 1.0)));
    w = _local_yuvWeightC(ref, p, sigmaLCRecip);
    sow+= w; sowd+= w * p.a;
    float rc = (sow < pmws) ? alt : (sowd / sow);
return vec4(rc,rc,rc,1.0);
float _local_yuvWeightG2(vec4 pix1,vec4 pix2,vec2 sigmaLumaChmaRecip)
    vec3 yuv = pix1.xyz - pix2.xyz;
    yuv.xyz = (yuv.xyz * yuv.xyz) * sigmaLumaChmaRecip.xyy;
    return exp(-(yuv.x+yuv.y+yuv.z));
kernel vec4 _CIPropagateDisparityRC(sampler image,sampler yuv0,vec4 params)
    int   radius        = int(params.x); 
    vec2  sigmaLCRecip  = params.yz;
    float pmws          = params.w; 
    vec2  dc            = destCoord();
    vec2 gidHalf = floor(0.5*dc) + vec2(0.5);
    vec4  ref           = sample(yuv0, samplerTransform(yuv0, dc));
    float sow           = 0.0;
    float sowd          = 0.0;
    
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
            vec4  p = sample(image, samplerTransform(image, gidHalf + vec2(float(x), float(y))));
            float w = _local_yuvWeightG2(ref, p, sigmaLCRecip);
            sow+= w; sowd+= w * p.a;
        }
    }
    float alt = sample(image, samplerTransform(image, gidHalf)).r;
    float rc = (sow < pmws) ? alt : (sowd / sow);
return vec4(rc,rc,rc,1.0);
kernel vec4 _CISmoothDisparity(sampler inDisp, vec3 params)
    float wSide      = params.x;
    float wDiag      = params.y;
    float denomRecip = params.z;
    vec2  dc         = destCoord();
   vec4 g0, g1, g2;
   g0.x = sample(inDisp, samplerTransform(inDisp, dc + vec2(-1.0, 0.0))).x;
   g0.y = sample(inDisp, samplerTransform(inDisp, dc                  )).x;
   g0.z = sample(inDisp, samplerTransform(inDisp, dc + vec2( 0.0, 1.0))).x;
   g0.w = sample(inDisp, samplerTransform(inDisp, dc + vec2(-1.0, 1.0))).x;
   g1.y = sample(inDisp, samplerTransform(inDisp, dc + vec2( 1.0, 0.0))).x;
   g1.z = sample(inDisp, samplerTransform(inDisp, dc + vec2( 1.0, 1.0))).x;
   g2.x = sample(inDisp, samplerTransform(inDisp, dc + vec2(-1.0,-1.0))).x;
   g2.y = sample(inDisp, samplerTransform(inDisp, dc + vec2( 0.0,-1.0))).x;
   float g3   = sample(inDisp, samplerTransform(inDisp, dc + vec2( 1.5,-1.5))).x;
   float  v = (g0.y + (g0.x + g0.z + g1.y + g2.y) * wSide + (g0.w + g1.z + g2.x + g3) * wDiag) * denomRecip;
    return vec4(v,v,v,1.0);
/tmp/yuvImageUsingConstants.tiff
kernel_InitialConversion
/tmp/initialConversion-Metal.tiff
/tmp/initialConversion-CI.tiff
kernel_UpscaleShiftmap
scaleFactors
/tmp/upsampledShiftmap-Metal.tiff
/tmp/upsampledShiftmap-CI.tiff
kernel_PyramidGenerateLevel
/tmp/pyramidLevel1-Metal.tiff
/tmp/pyramidLevel1-CI.tiff
kernel_SmoothDisparity
config
/tmp/smoothDisparity-Metal.tiff
/tmp/smoothDisparity-CI.tiff
kernel vec4 _combineImages(__sample s0,__sample s1) { return vec4(s0.xyz,s1.r); }
kernel_PropagateDisparity
/tmp/propagateDisparity_%d-%s.tiff
/tmp/inputToDisparity.tiff
-[CIDisparityRefinement outputImageUsingMetal:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/PortraitBlur/CIDisparityRefinement.m
computedPyramidNumLevels >= 1 && computedPyramidNumLevels <= kMAX_NUM_PYRAMID_LEVELS
/tmp/smoothed-Metal.tiff
/tmp/smoothed-CI.tiff
i8@?0@"NSDictionary"4
T@"NSNumber",C,VinputPropagateKernel
T@"NSNumber",C,VinputSmoothSigma
inputPropagateMinWeightSum
T@"NSNumber",C,VinputPropagateMinWeightSum
inputPropagateSigmaLuma
T@"NSNumber",C,VinputPropagateSigmaLuma
inputPropagateSigmaChma
T@"NSNumber",C,VinputPropagateSigmaChma
T@"CIVector",C,VinputOriginalSize
CI_SAVE_IMAGES
Can't save nil image
infinite rect can't save image
kernel vec4 _gray(__sample s) { return s.rrra; }
CIConvolutionWeights
CIConvolution3X3 expects inputWeights to be a length-9 CIVector
T@"CIVector",&,N,VinputWeights
T@"NSNumber",&,N,VinputBias
CIConvolution5X5 expects inputWeights to be a length-25 CIVector
CIConvolution7X7 expects inputWeights to be a length-49 CIVector
kernel vec4 _conv3x3sym (sampler image, vec4 parms) 
 vec2 dc = destCoord(); 
 vec2 dA = parms.xy; 
 vec2 dB = vec2(-dA.y, dA.x); 
 vec4 sum = sample(image, samplerTransform(image, dc + dB)) 
 + sample(image, samplerTransform(image, dc + dA)) 
 + sample(image, samplerTransform(image, dc - dA)) 
 + sample(image, samplerTransform(image, dc - dB)); 
 return sum * parms.z + parms.w; 
kernel vec4 _conv3x3 (sampler image, vec4 w0, vec4 w1, vec4 w2) 
 vec2 dc = destCoord(); 
 vec4 sum = w2.yyyy; 
 vec2 delta = w2.zw; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delta.y))) * w0.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, -delta.y))) * w0.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delta.y))) * w0.z; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, 0.0))) * w0.w; 
 sum += sample(image, samplerTransform(image, dc )) * w1.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, 0.0))) * w1.y; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, delta.y))) * w1.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, delta.y))) * w1.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, delta.y))) * w2.x; 
 return sum; 
kernel vec4 _convolution9 (sampler image, vec4 w0, vec4 w1, vec4 w2) 
 vec2 dc = destCoord(); 
 vec4 sum = w2.yyyy; 
 vec2 delta = w2.zw; 
 sum += sample(image, samplerTransform(image, dc - delta*4.0)) * w0.x; 
 sum += sample(image, samplerTransform(image, dc - delta*3.0)) * w0.y; 
 sum += sample(image, samplerTransform(image, dc - delta*2.0)) * w0.z; 
 sum += sample(image, samplerTransform(image, dc - delta )) * w0.w; 
 sum += sample(image, samplerTransform(image, dc )) * w1.x; 
 sum += sample(image, samplerTransform(image, dc + delta )) * w1.y; 
 sum += sample(image, samplerTransform(image, dc + delta*2.0)) * w1.z; 
 sum += sample(image, samplerTransform(image, dc + delta*3.0)) * w1.w; 
 sum += sample(image, samplerTransform(image, dc + delta*4.0)) * w2.x; 
 return sum; 
kernel vec4 _convolution7 (sampler image, vec4 w0, vec4 w1, vec4 w2) 
 vec2 dc = destCoord(); 
 vec4 sum = w2.yyyy; 
 vec2 delta = w2.zw; 
 sum += sample(image, samplerTransform(image, dc - delta*3.0)) * w0.y; 
 sum += sample(image, samplerTransform(image, dc - delta*2.0)) * w0.z; 
 sum += sample(image, samplerTransform(image, dc - delta )) * w0.w; 
 sum += sample(image, samplerTransform(image, dc )) * w1.x; 
 sum += sample(image, samplerTransform(image, dc + delta )) * w1.y; 
 sum += sample(image, samplerTransform(image, dc + delta*2.0)) * w1.z; 
 sum += sample(image, samplerTransform(image, dc + delta*3.0)) * w1.w; 
 return sum; 
kernel vec4 _convolution5 (sampler image, vec4 w0, vec4 w1) 
 vec2 dc = destCoord(); 
 vec4 sum = w1.yyyy; 
 vec2 delta = w1.zw; 
 sum += sample(image, samplerTransform(image, dc - delta*2.0)) * w0.x; 
 sum += sample(image, samplerTransform(image, dc - delta )) * w0.y; 
 sum += sample(image, samplerTransform(image, dc )) * w0.z; 
 sum += sample(image, samplerTransform(image, dc + delta )) * w0.w; 
 sum += sample(image, samplerTransform(image, dc + delta*2.0)) * w1.x; 
 return sum; 
kernel vec4 _convolution3 (sampler image, vec4 w0, vec4 w1) 
 vec2 dc = destCoord(); 
 vec4 sum = w1.yyyy; 
 vec2 delta = w1.zw; 
 sum += sample(image, samplerTransform(image, dc - delta )) * w0.y; 
 sum += sample(image, samplerTransform(image, dc )) * w0.z; 
 sum += sample(image, samplerTransform(image, dc + delta )) * w0.w; 
 return sum; 
kernel vec4 _convolution5x5 (sampler image, vec4 w0, vec4 w1, vec4 w2, vec4 w3, vec4 w4, vec4 w5, vec4 w6) 
 vec2 dc = destCoord(); 
 vec4 sum = w6.yyyy; 
 vec2 delta = w6.zw; 
 vec2 delt2 = 2.0 * delta; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delt2.y))) * w0.x; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delt2.y))) * w0.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, -delt2.y))) * w0.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delt2.y))) * w0.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delt2.y))) * w1.x; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delta.y))) * w1.y; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delta.y))) * w1.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, -delta.y))) * w1.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delta.y))) * w2.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delta.y))) * w2.y; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, 0.0))) * w2.z; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, 0.0))) * w2.w; 
 sum += sample(image, samplerTransform(image, dc )) * w3.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, 0.0))) * w3.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, 0.0))) * w3.z; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, delta.y))) * w3.w; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, delta.y))) * w4.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, delta.y))) * w4.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, delta.y))) * w4.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, delta.y))) * w4.w; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, delt2.y))) * w5.x; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, delt2.y))) * w5.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, delt2.y))) * w5.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, delt2.y))) * w5.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, delt2.y))) * w6.x; 
 return sum; 
kernel vec4 _convolution7x7 (sampler image, vec4 w0, vec4 w1, vec4 w2, vec4 w3, vec4 w4, vec4 w5, vec4 w6, vec4 w7, vec4 w8, vec4 w9, vec4 w10, vec4 w11, vec4 w12) 
 vec2 dc = destCoord(); 
 vec4 sum = w12.yyyy; 
 vec2 delta = w12.zw; 
 vec2 delt2 = 2.0 * delta; 
 vec2 delt3 = 3.0 * delta; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, -delt3.y))) * w0.x; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delt3.y))) * w0.y; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delt3.y))) * w0.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, -delt3.y))) * w0.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delt3.y))) * w1.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delt3.y))) * w1.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, -delt3.y))) * w1.z; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, -delt2.y))) * w1.w; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delt2.y))) * w2.x; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delt2.y))) * w2.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, -delt2.y))) * w2.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delt2.y))) * w2.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delt2.y))) * w3.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, -delt2.y))) * w3.y; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, -delta.y))) * w3.z; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, -delta.y))) * w3.w; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, -delta.y))) * w4.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, -delta.y))) * w4.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, -delta.y))) * w4.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, -delta.y))) * w4.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, -delta.y))) * w5.x; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, 0.0))) * w5.y; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, 0.0))) * w5.z; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, 0.0))) * w5.w; 
 sum += sample(image, samplerTransform(image, dc )) * w6.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, 0.0))) * w6.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, 0.0))) * w6.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, 0.0))) * w6.w; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, delta.y))) * w7.x; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, delta.y))) * w7.y; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, delta.y))) * w7.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, delta.y))) * w7.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, delta.y))) * w8.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, delta.y))) * w8.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, delta.y))) * w8.z; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, delt2.y))) * w8.w; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, delt2.y))) * w9.x; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, delt2.y))) * w9.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, delt2.y))) * w9.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, delt2.y))) * w9.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, delt2.y))) * w10.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, delt2.y))) * w10.y; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt3.x, delt3.y))) * w10.z; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delt2.x, delt3.y))) * w10.w; 
 sum += sample(image, samplerTransform(image, dc + vec2(-delta.x, delt3.y))) * w11.x; 
 sum += sample(image, samplerTransform(image, dc + vec2( 0.0, delt3.y))) * w11.y; 
 sum += sample(image, samplerTransform(image, dc + vec2( delta.x, delt3.y))) * w11.z; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt2.x, delt3.y))) * w11.w; 
 sum += sample(image, samplerTransform(image, dc + vec2( delt3.x, delt3.y))) * w12.x; 
 return sum; 
kernel vec4 _scaleClamp(__sample p, float scale) 
 return clamp(p * scale, 0.0, 1.0); 
kernel vec4 _innerGorS (__sample b, __color color, float range) 
 return clamp((1.0 - b.a) / range, 0.0, 1.0) * color; 
inputOffset
inputRange
T@"CIVector",&,N,VinputOffset
T@"NSNumber",&,N,VinputRange
kernel vec4 _outerGorS (__sample b, __color color, float range) 
 return clamp(b.a / range, 0.0, 1.0) * color; 
inputSpread
T@"NSNumber",&,N,VinputSpread
inputGlowColorInner
inputGlowOuterOuter
inputShadowColorInner
inputShadowOuterOuter
inputShadowBlurInner
inputShadowBlurOuter
kernel vec4 _shapeEffectBlur_1 (__sample p0, __sample p1, __sample b0, __sample b1, __sample f0, 
 __color gcI, __color gcO, __color scI, __color scO, vec2 sparms) 
 gcI *= clamp( (1.0 - b0.a) * 2.0, 0.0, 1.0); 
 gcO *= clamp( b0.a * 2.0, 0.0, 1.0); 
 scI *= mix( (1.0 - p1.a), (1.0 - b1.a), sparms.x ); 
 scO *= mix( p1.a, b1.a, sparms.y ); 
 vec4 I,O; 
 I = (gcI + f0*(1.0 - gcI.a)); 
 I = (scI + I*(1.0 - scI.a)) * (p0.a); 
 O = (gcO + scO*(1.0 - gcO.a)) * (1.0 - p0.a); 
 return I + O*(1.0 - I.a); 
inputFill
T@"CIImage",&,N,VinputFill
T@"CIColor",&,N,VinputGlowColorInner
inputGlowColorOuter
T@"CIColor",&,N,VinputGlowColorOuter
T@"CIColor",&,N,VinputShadowColorInner
inputShadowColorOuter
T@"CIColor",&,N,VinputShadowColorOuter
T@"NSNumber",&,N,VinputShadowBlurInner
T@"NSNumber",&,N,VinputShadowBlurOuter
inputSoften
inputHighlightColor
inputShadowColor
kernel vec4 _outerBevelEmboss (sampler image, vec2 ss) 
 vec2 st = destCoord(); 
 float a = 0.0, mm_a, pm_a, mp_a, pp_a; 
 mm_a = sample(image, samplerTransform(image, st + ss.yy)).a; 
 pm_a = sample(image, samplerTransform(image, st + ss.xy)).a; 
 mp_a = sample(image, samplerTransform(image, st + ss.yx)).a; 
 pp_a = sample(image, samplerTransform(image, st + ss.xx)).a; 
 a = mm_a + pm_a - 1.3*(mp_a+pp_a); 
 a = clamp( a*0.5 + 0.5, 0.0, 1.0); 
 return vec4(a); 
kernel vec4 _outerBevelEmbossC (__sample v, __color hc, __color sc) 
 float a = v.a * 2.0 - 1.0; 
 vec4 result = hc*clamp(a, 0.0, 1.0) + sc*clamp(-a, 0.0, 1.0); 
 return result; 
T@"NSNumber",&,N,VinputSoften
T@"CIColor",&,N,VinputHighlightColor
T@"CIColor",&,N,VinputShadowColor
kernel vec4 _invertedMask (__sample c) { return vec4(0.0, 0.0, 0.0, 1.0 - c.a); } 
kernel vec4 _multiplyByMask (__sample c, __sample m) { return c*m.a;} 
CI_DEBUG_AUTOCROP
scaleRect:inner=(%.3f,%.3f,%.3f,%.3f), size=(%.3f,%.3f), anchor=(%.3f,%.3f)
ERROR <AutoCropper>: Point should be within rect
AspectRatioCutoff
MinimumCroppedArea
ProximityToCenter
Face area is %f, Total is %f
Large Face!
ERROR <AutoCropper>: unrecognized aspect ratio
No Crop. Reduces area too much
Clipping to original aspect ratio
Clipping to aspect ratio 4:3
Clipping to aspect ratio 3:2
Clipping to aspect ratio 16:9
Clipping to square
Clipping to aspect ratio 5:3
Clipping to aspect ratio 5:4
MinCropPercentage
determineBestPositionWithinSize:size=%.3f,%.3f, center=%.3f,%.3f, minPercentage=%.3f, restrict=%.3f,%.3f,%.3f,%.3f
originalArea = %.2f
pos = %d, rect=(%.2f,%.2f,%.2f,%.2f), area=%.2f
    topleft=%.2f
    topcenter=%.2f
    topright=%.2f
    bottomleft=%.2f
    bottomcenter=%.2f
    bottomright=%.2f
    leftcenter=%.2f
    rightcenter=%.2f
    center=%.2f
Best is %d
Want bottom
shouldFavorBottom
TB,N,VshouldFavorBottom
shouldFavorTop
TB,N,VshouldFavorTop
originalImageSize
T{CGSize=ff},N,VoriginalImageSize
ProviderImageSurfaceCacheQueue
Render failed because a pixel format %s is not supported.
%d, 
focus = 
float dummyDoNothing() { return 10.0; }
int myMAX(int a,int b) { return a > b ? a : b; }
int myMIN(int a,int b) { return a < b ? a : b; }
vec2 calcPosition(vec2 index,vec4 rect) {
  vec2 step = rect.zw / 64.0;
  vec2 pos  = rect.xy + step * index + step / 2.0;
  return pos;
kernel vec4 _ciLensModelCalculator(sampler image, vec4 focusRect, sampler minMaxImage, float4 cpuParams)
    float zeroShiftPercentile = cpuParams.x;
    int histBuf[256];
    for(int i = 0 ; i < 256; i++) {
    
  histBuf[i] = 0;
    }
   vec2 minMax = sample(minMaxImage, samplerTransform(minMaxImage, vec2(0.5))).rg;
   float shiftMin = floor(65536.0 * minMax.x) / 65536.0;
   float shiftMax = ceil(65536.0 * minMax.y) / 65536.0;
   float shiftRange = shiftMax - shiftMin;
   float shiftRecipRange = 1.0 / shiftRange; 
   for(int j = 0; j < 64; j++) {
       for ( int i = 0; i <  64; i++ ) {
            vec2 location = vec2(float(i),float(j));
            vec2 focusLocation  = calcPosition(location,focusRect);
            float shiftVal = sample(image, samplerTransform(image, focusLocation)).r;
            int index = int( min( 256.0f * shiftRecipRange * ( shiftVal - shiftMin ), 255.0f ) );
            index = myMIN(myMAX(index,0),255);
            histBuf[index]++;
        }
    }
    int binCountThreshold = int(floor( zeroShiftPercentile * 64.0 * 64.0 ));
    int binCount = 0;
    int oldBinCount = 0;
    int zeroShiftBinIndex = 0;
    for ( zeroShiftBinIndex = 0; (zeroShiftBinIndex < 256) && (binCount < binCountThreshold); zeroShiftBinIndex++ )
    {
    
binCount += histBuf[zeroShiftBinIndex];
    }
    float zeroShiftFractionalBinPos = min(1.0, max( 0.0, float( binCountThreshold - oldBinCount ) / max( float( binCount - oldBinCount ), 1.0f ))); 
    float interpolateZeroShiftBinIndex = max( 0.0f, zeroShiftBinIndex - 1.0 ) + zeroShiftFractionalBinPos; 
    float zeroShift = (shiftRange * float(interpolateZeroShiftBinIndex + 0.5 ) / 256.0) + shiftMin;
    float radiusScale   = cpuParams.y;
    float maxFGBlur     = cpuParams.z;
    float shiftDeadZone = cpuParams.w;
    return vec4(zeroShift, radiusScale, maxFGBlur, shiftDeadZone);
-[CILensModelCalculator outputImage]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/EmbeddedCoreImage_Sim/EmbeddedCoreImage-700.4.210/Framework/filters/PortraitBlur/CILensModel.m
calc
T@"CIImage",&,VinputMinMaxImage
T@"CIVector",C,N,VinputOriginalSize
T@"CIVector",C,N,VinputFocusRect
T@"NSNumber",C,N,VinputSimulatedAperture
T@"NSNumber",C,N,VinputIntrinsicMatrixFocalLength
kernel vec4 _CILensModelApply(__sample shiftMap, __sample p) {
  float radiusOffset  = p.x;
  float radiusScale   = p.y;
  float maxFGBlur     = p.z;
  float shiftDeadZone = p.w;
  float shiftVal = shiftMap.x; 
  float relShift = abs( min( shiftVal - radiusOffset, maxFGBlur ) );
  float dzRelShift = mix( 0.0, relShift, clamp(relShift * shiftDeadZone, 0.0, 1.0));
  float blurVal = clamp( radiusScale * dzRelShift , 0.0, 1.0);
  float  resultBlurVal = clamp(sqrt(blurVal), 0.0, 1.0);
  return vec4(resultBlurVal,0.0,0.0,1.0);
-[CILensModelApply outputImage]
applyKernel
T@"CIImage",&,N,VinputLensModelParams
_i%d
_u%d
_t%d
vec4 _ci_srgb_to_linear (vec4 s) { return _srgb_to_linear(s); }
_samplers[%d]
_transforms[%d]
_extents[%d]
_s%d
_s%d_transform0
_s%d_transform1
_s%d_extent
Invalid DAG node type
vec4 _ci_linear_to_srgb (vec4 s) { return _linear_to_srgb(s); }
hvec4 _read_pixel(hsampler2D image, vec2 c, vec4 m0, vec4 m1) {
 float x = dot(vec4(c,1.0,0.0), m0);
 float y = dot(vec4(c,1.0,0.0), m1);
 return texture2D(image, vec2(x,y)); }
vec4 _read_pixel(sampler2D image, vec2 c, vec4 m0, vec4 m1) {
 float x = dot(vec4(c,1.0,0.0), m0);
 float y = dot(vec4(c,1.0,0.0), m1);
 return texture2D(image, vec2(x,y)); }
hvec4 _read_pixel(hsampler2D image, vec2 c, mat3 m){ return texture2D(image, (vec3(c, 1.0) * m).xy);}
vec4 _read_pixel(sampler2D image, vec2 c, mat3 m){ return texture2D(image, (vec3(c, 1.0) * m).xy);}
hvec4 _read_pixel_420(hsampler2D Y, hsampler2D cc, vec2 c, vec2 f, vec4 m0, vec4 m1){
 float x = dot(vec4(c,1.0,0.0), m0);
 float y = dot(vec4(c,1.0,0.0), m1);
 return hvec4(texture2D(Y, vec2(x,y)).a, texture2D(cc, 0.5*vec2(x,y)).rg, 1.0);}
vec4 _read_pixel_420(sampler2D Y, sampler2D cc, vec2 c, vec2 f, vec4 m0, vec4 m1){
 float x = dot(vec4(c,1.0,0.0), m0);
 float y = dot(vec4(c,1.0,0.0), m1);
 return vec4(texture2D(Y, vec2(x,y)).a, texture2D(cc, 0.5*vec2(x,y)).rg, 1.0);}
hvec4 _read_pixel_420(hsampler2D Y, hsampler2D cc, vec2 c, vec2 f, mat3 m){
 highp vec3 p = vec3(c, 1.0) * m;
 return hvec4(texture2D(Y, p.xy).a, texture2D(cc, f*p.xy).rg, 1.0);}
vec4 _read_pixel_420(sampler2D Y, sampler2D cc, vec2 c, vec2 f, mat3 m){
 highp vec3 p = vec3(c, 1.0) * m;
 return vec4(texture2D(Y, p.xy).a, texture2D(cc, f*p.xy).rg, 1.0);}
hvec4 _cast_vec4_to_hvec4(vec4 v) { return hvec4(v); }
vec4 _cast_hvec4_to_vec4(hvec4 v) { return vec4(v); }
.bgra
.abgr
.argb
.gbra
.grab
.gbar
.aaaa
.rrrr
.rrrg
.rgba * _ci_constants.xxxy + _ci_constants.yyyx
.bgra * _ci_constants.xxxy + _ci_constants.yyyx
.argb * _ci_constants.xxxy + _ci_constants.yyyx
.grab * _ci_constants.xxxy + _ci_constants.yyyx
.abgr * _ci_constants.yxxx + _ci_constants.xyyy
.argb * _ci_constants.yxxx + _ci_constants.xyyy
.rrrr * _ci_constants.yyyx
.rrrr * _ci_constants.xxxy + _ci_constants.yyyx
.rrrr * _ci_constants.xyyy + _ci_constants.yyyx
.rggg * _ci_constants.xxyy + _ci_constants.yyyx
.aaaa * _ci_constants.xyyy + _ci_constants.yyyx
.raaa * _ci_constants.xxyy + _ci_constants.yyyx
.aaaa * _ci_constants.xxxy + _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.xyyy + _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.xxxy + _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.xxxx
dot(s.ra, _ci_constants.zw) * _ci_constants.xyyy + _ci_constants.yyyx
dot(s.ra, _ci_constants.zw) * _ci_constants.xxxy + _ci_constants.yyyx
dot(s.ra, _ci_constants.zw) * _ci_constants.yyyx
dot(s.ra, _ci_constants.zw) * _ci_constants.xxxx
dot(s.rg, _ci_constants.zw) * _ci_constants.xyyy + dot(s.ba, _ci_constants.zw) * _ci_constants.yxyy + _ci_constants.yyyx
dot(s.rg, _ci_constants.zw) * _ci_constants.xxxy + dot(s.ba, _ci_constants.zw) * _ci_constants.yyyx
kernel vec2 _circularWrap(vec2 center, float b, float c, float d, float minAngle) 
 vec2 p; 
 vec2 t0 = destCoord() - center; 
 float d0 = dot(t0, t0); 
 float d1 = inversesqrt(d0); 
 float r = d0 * d1; 
 vec2 u = t0 * d1; 
 vec2 x_ = abs(u); 
 vec2 t = 0.00119152193164364 + (1.149637430629571 + (-0.6987144230270900 + 0.9002138006758336 * x_) * x_) * x_; 
 vec2 thetas = compare(u, -t, t); 
 thetas.x = (u.y < 0.0) ? (thetas.x - 1.5707963) : (1.5707963 - thetas.x); 
 thetas.y = (u.x < 0.0) ? (3.1415927 - thetas.y) : thetas.y; 
 vec2 abss = abs(u); 
 float theta = (abss.x < abss.y) ? thetas.x : thetas.y; 
 theta = fract((theta - minAngle) * 0.15915494) * 6.2831853; 
 p.x = theta * c + d; 
 p.y = r + b; 
 return p; 
Crop: Based on %d features
  feature%d has left eye at (%.3f,%.3f), right eye at (%.3f,%.3f)
  clip overall %% = %.3f
    too much clipping - reverting back to rotated crop only
    too little clipping - reverting back
convert_YCC444_to_420
node:%d from_prov [%g %g %g %g]
surface_for_roi
node:%d
%{public}s %@: instantiating abstract barcode descriptor objects is prohibited
%{public}s %@: requires coder that supports keyed coding of objects
%{public}s %{public}@: symbolVersion must be in the range of [1,40]
%{public}s %{public}@: invalid errorCorrectionLevel
%{public}s %{public}@: layerCount must be in the range of [1,32]
%{public}s %{public}@: dataCodewordCount must be in the range of [1,2048]
%{public}s %{public}@: rowCount must be in the range of [3,90]
%{public}s %{public}@: columnCount must be in the range of [1,30]
frame %lu
render_lock
%{public}s unsupported object %{public}@ for key %{public}@.
%{public}s unsupported key %{public}@.
%{public}s can only be created with ES 2.0 or 3.0 EAGLContexts.
%{public}s format %{public}s is unsupported%{public}s.
%{public}s unsupported colorspace.
%{public}s rowBytes must be a multiple of %ld.
%{public}s unsupported format.
%{public}s unsupported plane count.
%{public}s CI_CONVERSION: Rendered to intermediate YCC444 buffer because CI can not render directly to %{public}s.
%{public}s could allocate memory.
%{public}s could not access buffer.
%{public}s cannot render an infinite image into an infinite context.
%{public}s requires a CIContext created with a GL context or a CG context.
%{public}s given an infinite rect
%{public}s target must be GL_TEXTURE_2D.
%{public}s requires a GL or CL context!
%{public}s requires a Metal context (with the same device used to create the given texture).
%{public}s was called but ignored.
[CIContext createCGImage:fromRect:format:colorSpace:] unsupported format %{public}s.
[CIContext createCGImage:fromRect:format:colorSpace:] unsupported colorspace.
CIContext workingformat must be %s. Ignoring request for %{public}s.
CIContext workingformat must be %s. Ignoring request.
CIContext for CL: do something about disabling software fallback here.
CIContext workingformat must be %{public}s. Ignoring request for %{public}s.
CIContext workingformat must be %{public}s. Ignoring request.
CIContext kCIContextOutputColorSpace must be [NSNull null], or a CGColorSpaceRef with kCGColorSpaceModelRGB or kCGColorSpaceModelMonochrome that supports output.
CIContext kCIContextWorkingColorSpace must be [NSNull null], or a CGColorSpaceRef with kCGColorSpaceModelRGB that supports output.
%{public}s option CIUserInfo is no longer encoded for security.
%{public}s first parameter should be CIKernel.
%{public}s kCIApplyOptionDefinition is not a CIFilterShape or an NSArray with four elements.
%{public}s kCIApplyOptionExtent is not an NSArray with four elements. Ignoring.
%{public}s The filter PXSoftProofingFilter has an incorrect ROI method for sampler index 1.  This may fail in the future.
%{public}s The filter PX_CIF_Noise has an incorrect ROI method for sampler index 1.  This may fail in the future.
[%@ apply:...] First argument should be CIKernel.
[%{public}@ apply:...] The last key "%{public}@" at index %d is followed by nil. It will be ignored.
[%{public}@ apply:...] Argument at index %d should be a CIImage, CISampler, CIVector, or NSNumber.
CIFilter %{public}@ cannot be serialized because %{public}@ value is a %{public}@. Only NSString, NSNumber and CIVector is supported at this time.
%{public}s warning: affine+crop region falls outside of image area, results may be wrong
%{public}s now returns nil.  Use _filterArrayFromProperties:inputImageExtent: instead
[CIImage initWithIOSurface:options:] failed because surface format was %{public}.4s.
[CIImage initWithIOSurface:options:] failed because surface format was %ld.
[CIImage initWithIOSurface:options:] kCIImageSurfaceFormat option value is not compatable with actual format of surface.
[CIImage initWithIOSurface:options:] kCIImageEdgeRepeat option not supported. Ignoring.
[CIImage initWithCGImage:] kCIImageEdgeRepeat option not supported. Ignoring.
%{public}s failed because the CGImage is nil.
%{public}s CI_CONVERSION: Rendered to intermediate %{public}s CGImage because CI can not directly support the CGImage because it has a %{public}s.
%{public}s failed because the CGImage format is not supported and we failed to create a CGBitmapContext.
[CIImage initWithBitmapData:] failed because the format '%{public}s' is not supported.
[CIImage initWithBitmapData:] failed because the format is not supported.
[CIImage initWithBitmapData:] failed because data length was less than height times bytesPerRow.
%{public}s kCIImageEdgeRepeat option not supported. Ignoring.
%{public}s does not support Metal on this platform.
[CIImage initWithCVPixelBuffer:optiopns:] failed because it is not a CVPixelBuffer.
[CIImage initWithCVImageBuffer:] kCIImageEdgeRepeat option not supported. Ignoring.
%{public}s failed because the buffer is nil.
%{public}s failed because the buffer is not a CVPixelBufferRef.
%{public}s failed because its pixel format %{public}.4s is not supported.
%{public}s failed because its pixel format %ld is not supported.
%{public}s failed because the type of buffer is not yet supported.
%{public}s ColorSpace must be an RGB CGColorSpaceRef that supports output.
%{public}s ColorSpace must be an RGB or Gray CGColorSpaceRef that supports output.
%{public}s ColorSpace must be an RGB CGColorSpaceRef.
%{public}s properties is not a NSDictionary.
%{public}s object at index %d of array is not a CIImage.
%{public}s CIUserInfo is no longer encoded for sake of security.
%{public}s CIUserInfo is no longer decoded for sake of security.
%{public}s not supported for keypath %{public}@.
[CIKernel initWithString:] failed because no valid kernels were in the string.
[CIKernel initWithString:] failed because '%{public}s', the first kernel in the string, has an unsupported type for the parameter '%{public}s'.
%{public}s is not an known pixel format name. Will use working format instead.
%{public}s Available function names are: %@
%{public}s Function '%s' does not exist.
[%{public}@ initWithString:] failed due to error parsing kernel source.
[%{public}@ initWithString:] failed because no valid kernels were in the string.
[CIWarpKernel initWithString:] failed because '%{public}s', the first kernel in the string, does not conform to the calling convensions of a CIWarpKernel.
[CIColorKernel initWithString:] failed because '%{public}s', the first kernel in the string, does not conform to the calling convensions of a CIColorKernel.
%{public}s Function '%s' does not conform to the calling conventions of a CIColorKernel.
%{public}s Function '%s' does not conform to the calling conventions of a CIWarpKernel.
[CIKernel kernelsWithString:] passed an empty or nil string.
%{public}s Cannot initialize kernel with given library data.
%{public}s Cannot initialize kernel with Metal DAG compiler disabled.
%{public}s User-specified output group size not yet supported.
kCIKernelOutputFormat value (%s) is not supported.Use one of these formats instead: %@
Warning: specified  as kernel attribute output format of %s and apply option kCIKernelOutputFormat of %s. The former will be used.
%{public}s argument count mismatch for kernel '%{public}s', expected %d but saw %d.
%{public}s type mismatch for kernel '%{public}s' parameter %d. %{public}sGot %{public}@.
%{public}s no image in arguments array.
%{public}s ignores callback and is not recomended.  Use applyWithExtent:arguments:options: instead.
%{public}s ignores callback and is not recomended.  Use applyWithExtent:arguments: instead.
%{public}s kernel '%{public}s' is not a color kernel.
%{public}s is not supported.  Use applyWithExtent:roiCallback:inputImage:arguments:options: instead.
%{public}s is not supported.  Use applyWithExtent:roiCallback:inputImage:arguments: instead.
%{public}s kernel '%{public}s' is not a warp kernel.
%{public}s provided rect for kernel %{public}s is %{public}@ but should be at least %{public}@
node:%d from_surface [%g %g %g %g]
CI_CONVERSION: Converted input surface to a new surface with required rowbytes alignment (of %d bytes).
%{public}s Error while detecting faces: %@
%{public}s Error while detecting landmarks: %@
%{public}s CI_CONVERSION: Rendered to intermediate between two CIImageProcessorKernels.
compile_metal_dag
release_surface_block
compile_gl
finish_render
after_render
quad
readback_bitmap
bind_arguments
node:%d [%g %g %g %g]
render_quad
wait_for_cache
create_intermediate
%{public}s requires an image with a finite non-empty extent.
node:%d from_cg [%g %g %g %g]
%{public}s init is not a valid initializer for CIImageAccumulator
%{public}s failed because the extent is empty.
%{public}s failed because the format '%s' is not supported.
%{public}s failed because the format is not supported.
%{public}s blendKernel ignored (invalid value of type '%s').
%{public}s failed.
prepare_initial_graph
render_tile
make_program_graph_if_renderable
%{public}s %{public}@
%{public}s inputText must be a NSString.
%{public}s inputText must be a NSAttributedString.
%{public}s context is nil.
%{public}s surface is nil.
%{public}s processor block must be provided.
%{public}s inputFormat must be 0, %{public}s.
%{public}s outputFormat must be 0, %{public}s.
%{public}s argumentDigest is 0 which will prevent CoreImage from caching %{public}s optimally.
%{public}s each object in arguments dictionary be an NSArray, NSDictionary, NSNumber, NSData, NSString, CIVector, CIColor, CIImage, CGImageRef or CGColorSpaceRef for CoreImage to cache optimally.
CISampler value for key '%s' is nil. Skipping.
CISampler value for key '%s' must be a NSObject or a CGColorSpaceRef. Skipping.
CISampler option key must be a NSString. Skipping.
%{public}s ignoring kCISamplerBlurFormat because it is not supported.
%{public}s ignoring kCISamplerWrapPeriodic because it is not supported.
%{public}s ignoring kCISamplerAffineMatrix value because it is not a valid object '%@'.
%{public}s ignoring kCISamplerColorSpace value because it is not an RGB CGColorSpaceRef that supports output.
%{public}s bounds is too large
%{public}s format %s is unsupported%s.
%{public}s rowBytes must be a multiple of %ld.
%{public}s context's output colorspace can't be used with pixel format %s. Using default output colorspace instead.
processor_render
convert_processor
Failed to render - cannot access data from CGImage %p
%s version
CIRedEyeCorrection_processor
CI_CONVERSION: (Metal) %{public}s_buffer
CI_CONVERSION: (Metal) %{public}s_texture
convert_metal
CI_CONVERSION: (CPU) %{public}s
convert_cpu
%{public}s init is not a valid initializer for CIRenderDestination
%{public}s requires a valid pixelBuffer argument.
%{public}s requires a pixelBuffer with valid width and height.
%{public}s unsupported pixelBuffer format.
%{public}s unsupported pixelBuffer plane count.
%{public}s not supported yet.
%{public}s requires a valid pixelBuffer provider block.
%{public}s requires a valid width and height.
%{public}s requires a valid data argument.
%{public}s requires a valid bytesPerRow.
%{public}s bytesPerRow must be greater than or equal to width times format's bytes per pixel .
%{public}s unsupported alpha mode.
%{public}s unsupported colorspace for this destination.
%{public}s blendKernel must be a subclass of CIBlendKernel.
Destination blend kernel is not supported for provider backed destinations.
%{public}s init is not a valid initializer for CIRenderInfo
%{public}s init is not a valid initializer for CIRenderTask
%{public}s Unexpected error in the backing renderer.
%{public}s The CIContext is invalid.
%{public}s The destination is nil.
%{public}s The destination is invalid.
%{public}s The image extent and destination extent do not intersect.
%{public}s %s.
%{public}s Input format not supported: %d
%{public}s Output format not supported: %d
%{public}s Could not allocate %lu bytes of memory
Cannot render image (with Metal kernel '%s') using an %s context.
seedFill: seed is outside bitmask
Failed to allocate IOSurface
CacheEntryFillAsync
cid:%u iid:%u [%lld %lld %zu %zu]
GetSurfaceFromCacheAndFill
GetSurfaceFromCache
%{public}s unable to read file %{private}@.
%{public}s colorSpace must be kCGColorSpaceModelRGB.
%{public}s The input palette should be a K x 1 image but received %.1f x %.1f]
%{public}s Repair tuning set to default
%{public}s Repair tuning set to A wide
%{public}s Repair tuning set to A tele
%{public}s Repair tuning set to A portrait
%{public}s Repair tuning set to B
%{public}s Session tuning set to default
%{public}s Session tuning set to A wide
%{public}s Session tuning set to A tele
%{public}s Session tuning set to A portrait
%{public}s Session tuning set to B
eyeCount:%d
setPrimary
%{public}s setPrimary called with %d observations
%{public}s setPrimary called with metadata:
%{public}s setPrimary called with session tuning:
%{public}s setPrimary called with repair tuning:
%{public}s fail: nil primary
%{public}s fail: no landmarks found
%{public}s fail: image too small (%lu)
%{public}s Landmarks computed from orientation %d and size %f, %f
%{public}s Processing face observation %d
%{public}s Confidence=%.3f | junk=%.3f | Anisotropy=%.3f | area=%.0f
%{public}s skip: confidence too low (%f)
%{public}s skip: junkiness too high (%f)
%{public}s skip: eye isotropy too large (%f)
%{public}s skip: eye constellation area too small (%f)
%{public}s skip: flash was forced and the flash would not have normally fired.
%{public}s Focus variance = %.3f, count = %ld
%{public}s Time spent computing focus stats: %.3fms
%{public}s skip: face out of focus: %.3f > %.3f
%{public}s Good face %d/%lu: left %@ axes %@ | right %@ axes %@ 
%{public}s fail: no good landmarks found
%{public}s Total time spent during setPrimary: %.3fms
%{public}s setPrimary returning successfully
repairPrimaryWithSecondary
%{public}s repairPrimaryWithSecondary called
%{public}s fail: primary %d | secondary %d
%{public}s setPrimary:landmarks:metadata must be called first.
%{public}s CVPixelBuffer size (primary) = %lu, %lu
%{public}s CVPixelBuffer size (secondary) = %lu, %lu
%{public}s Forcing working format to RGBAh
face:%d
repairFace
%{public}s Intersection: %f,%f,%f,%f
%{public}s Repair %d/%d: left %@ | right %@
%{public}s Output image took %.3fms
%{public}s startTaskToRender (composite) took %.3fms
%{public}s startTaskToRender (left) took %.3fms
%{public}s Error in left startTaskToRender: %@
%{public}s startTaskToRender (right) took %.3fms
%{public}s Error in right startTaskToRender: %@
%{public}s Error while preparing renderTask
%{public}s Error in waitUntilCompletedAndReturnError: %@
%{public}s Last kernel execution took %.3fms
%{public}s Total time spent during repair: %.3fms = %.3fms/eye
%{public}s eye outset = %.3f x %.3f
Unsupported disparity refinement configuration = %d
Unable to run CIFocalPlane
input image(s) to CIDepthBlurEffect apply is of inifite extent; returning input image
Failed to parse rendering parameters; unknown version %d
Params data too small
Invalid parameters data; no start marker found
Incorrect parameters version
Size mismatch
Unable to set new image metadata
No tuning parameters specified. Skipping.
Unknown depth blur effect rendering version %d
Invalid rendering parameter start marker.
Invalid rendering parameter header size (%d)
%{public}s Invalid argument type
%{public}s The file does not support version %{public}@. The version %{public}@ will be used instead.
%{public}s Centroid distance from L center failed: (%.0f, %.0f)
%{public}s Centroid distance from R center failed: (%.0f, %.0f)
%{public}s [abort] Inter centroid distance failed: %.3f > %.3f
%{public}s [abort] Interpeak percentile distance failed at p=%.2f: %hhu < %hhu
%{public}s [abort] Center pixel failed: L = %hhu < %hhu | R = %hhu < %hhu
%{public}s Density (left): %.4f < %.4f
%{public}s [abort] Minimum density failed (left): %.4f < %.4f
%{public}s Density (right): %.4f < %.4f
%{public}s [abort] Minimum density failed (right): %.4f < %.4f
%{public}s [abort] Maximum density failed (left): %.4f > %.4f
%{public}s [abort] Maximum density failed (right): %.4f > %.4f
%{public}s [abort] Minimum dispersion not reached (L): %.3f
%{public}s [abort] Minimum dispersion not reached (R): %.3f
%{public}s [abort] Maximum inter dispersion reached: %.3f. Eliminating right.
%{public}s [abort] Maximum inter dispersion reached: %.3f. Eliminating left.
%{public}s [abort] Mask response (L) too close to global: %.0f%%
%{public}s [abort] Mask response (R) too close to global: %.0f%%
%{public}s [abort] Convex fill failed due to invalid centroid: %d, %d
%{public}s Convex fill seeding from (%d,%d)
%{public}s [abort] Empty seed fill!
%{public}s [abort] Convex fill reached upper bound: %zu > %d
%{public}s [abort] Convex fill reached lower bound: %zu < %d
%{public}s Eye size: major axis %.0f -> %@
%{public}s Convex area threshold range for radius %d = [%d, %d]
%{public}s Long %.2f | Short %.2f | Ratio %.0f | Conf %.2f
%{public}s [ConvexFill] center lies outside of the buffer
%{public}s [ConvexFill] center is below threshold (%d < %d)
compile_metal
compute_quad
CIRedEyeRepair2
SyntheticPupil
BitmaskToOval
CIBurstActionClassifier
CIBurstImageSetInternal
CICheapBilateral
CIAreaHistogram
CIPercentileRed
CIEdgeWork
CIMaskedVariableBlur
CIBurstFaceConfigEntry
CIBurstFaceScoreEntry
CIBurstFaceInfo
CIBurstImageFaceAnalysisContext
CIBurstFaceStat
NSCopying
CIBurstImageStat
CIBarcodeDescriptor
NSSecureCoding
NSCoding
CIQRCodeDescriptor
CIAztecCodeDescriptor
CIPDF417CodeDescriptor
CIDataMatrixCodeDescriptor
CITriangleTile
CIGlassLozenge
CITorusLensDistortion
CIColorCurves
CIContext
Internal
QuicklookSupport
CIContextCache
CIPageCurlTransition
CIPageCurlWithShadowTransition
CIFilter
_CIFilterProperties
Private
CIParallelogramTile
CILinearBlur
CIMotionBlur
CIZoomBlur
CIImage
AVDepthData
AVPortraitEffectsMatte
TextImage
CIKernel
CIColorKernel
CIWarpKernel
CIBlendKernel
CIMetalWrapper
CIImageProvider
CIASGPercent
CIASG50Percent
CIASG66Percent
CIASG75Percent
CIASG80Percent
CIASG60Percent
CIAppleSmithGossettScale
CIBicubicScaleTransform
CISoftCubicUpsample
CIDepthOfField
CIAffineTransform
CICrop
ImageRepresentation
CISepiaTone
CILenticularHaloGenerator
CIStraightenFilter
Interposer
ClearImage
CIImageAccumulator
CIVector
CIExposureAdjust
CIDisplacementDistortion
CIColorControls
CIHueAdjust
CIReductionFilter
CIAreaAverage
CIColumnAverage
CIRowAverage
CIAreaMinMax
CIAreaMaximum
CIAreaMinimum
CIAreaMaximumAlpha
CIAreaMinimumAlpha
CIAreaMinMaxRed
CIAreaMinMaxNormalize
CIAreaMinMaxRedNormalize
CIKMeans
CIAreaCentroid
CIAreaRedCentroid
CIAreaRedRadialCentroid
CICircularMaskFromPointImage
CIColorMatrix
CIColorInvert
CIVibrance
CIBlurmapSmoothing
CIPortraitBlurNoise
CIPortraitBlurDirectionalBlur
CIPortraitBlur
CIPortraitBlurPreProcess
CIGenericMetalProcessorSingleChannel
CIGenericMetalProcessor
CITextImageGenerator
CIAttributedTextImageGenerator
CITemperatureAndTint
CIWhitePointAdjust
CIFalseColor
CIGammaAdjust
CIImageProcessorInOut
CIImageProcessorOutput
CIImageProcessorInput
CIImageProcessor
CIImageProcessorKernel
CINoiseReduction
CIProSharpenEdges
CIMetalConverter
CIOpTile
CICheckerboardGenerator
CISampler
CIShadedMaterial
CIDisparitySmoothing
CIDisparitySmoothingProcessor
CICircleGenerator
PrivateSmartToneAndColor
CISmartToneFilter
CISmartColorFilter
CIImageWriter
CIBitmapContext
CIRandomGenerator
CIGuidedFilter
AutoAdjust
CIRedEyeCorrection
CIRedEyeCorrections
CIEnhancementHistogram
CIConvolution
CIBokehBlur
CIDiscBlur
CIRingBlur
CIAutoEnhanceFace
CIDroste
CIRenderDestination
CIRenderInfo
CIRenderTask
CIImageRowReader
ImageRowReading
CIEnhancementCalculator
CIToneCurve
CIFilterRegistry
CIFilterRegistryPrivate
CIFilterClassAttributes
CIFilterClassCategories
CIFilterClassDefaults
CIFilterClassInfo
CIHighlightShadowAdjust
CITextDetector
CIRippleTransition
CIIntegralImageProcessorCPU
CIIntegralImage
CIStripesGenerator
CISunbeamsGenerator
CISmartBlackAndWhite
PrivateSmartBlackAndWhite
CIFaceBalance
CIDepthBlurEffect
CIStarShineGenerator
CIRedEyeRepair
CIMirror
CILabDeltaE
CITriangleKaleidoscope
CICheapBlur
CIStretch
CILightTunnel
CIEdgePreserveUpsampleFilter
CIEdgePreserveUpsampleRGFilter
CIRAWFilter
CIDetector
CIFaceCoreDetector
CIFeature
CIFaceFeature
CIRectangleFeature
CIQRCodeFeature
CITextFeature
CIColor
CISkyAndGrassAdjust
CIConstantColorGenerator
CruftCompatability
CIEnhancementCalculation
CIRectangleDetector
CIPremultiply
CIUnpremultiply
CIKernelLibrary
CISpotLight
CIColorCube
CIColorCubeWithColorSpace
CIColorCubesMixedWithMask
CIRadialGradient
CILinearGradient
CISmoothLinearGradient
CIGaussianGradient
CIHueSaturationValueGradient
CIColorMonochrome
CIPalettize
CIDither
CIDesaturateShadows
CIBlendModeFilter
CIMultiplyBlendMode
CIScreenBlendMode
CIOverlayBlendMode
CIDarkenBlendMode
CILightenBlendMode
CIColorDodgeBlendMode
CIColorBurnBlendMode
CIHardLightBlendMode
CISoftLightBlendMode
CIDifferenceBlendMode
CIExclusionBlendMode
CIPDFNonSeparableBlendMode
CIHueBlendMode
CISaturationBlendMode
CIColorBlendMode
CILuminosityBlendMode
CISubtractBlendMode
CIDivideBlendMode
CILinearBurnBlendMode
CILinearDodgeBlendMode
CIVividLightBlendMode
CILinearLightBlendMode
CIPinLightBlendMode
CIHardMixBlendMode
CITwirlDistortion
CIVignette
CIVignetteEffect
CIKaleidoscope
YCCExtensions
CIColorBalance
Algebra
CIDualRedEyeRepairSession
CIPinchDistortion
CIPointillize
CIVariableBoxBlur
CICMYKHalftone
CIRectangleGenerator
CISampleNearest
CIWrapMirror
CILumaMap
CIXRay
CIThermal
CIBurstThumbnailCluster
CICrystallize
CIPhotoGrain
CIPhotoEffect
CIPhotoEffectNoir
CIPhotoEffectChrome
CIPhotoEffectFade
CIPhotoEffectInstant
CIPhotoEffectMono
CIPhotoEffectProcess
CIPhotoEffectTonal
CIPhotoEffectTransfer
CIPhotoEffectStageMono
CIGaussianBlur
CIGaussianBlurXY
CIUnsharpMask
CIBurstClusterDivider
_CIScreenFilter
CIDotScreen
CIHatchedScreen
CILineScreen
CICircularScreen
CISRGBToneCurveToLinear
CILinearToSRGBToneCurve
CIBloom
CIGloom
CIColorPosterize
CIEdges
CIDissolveTransition
CIMaskToAlpha
MetalAdditions
SDOF
CIDepthToDisparity
CIDisparityToDepth
CIDepthDisparityConverter
CISegmentationFusion
CILensModelApplyV3
CIDisparityWeightsV3
CIDisparityPreprocV3
CIDisparityRefinementSparseSamplerV3
CIDisparityRefinementAntialiasV3
CIDisparityRefinementV3
CIDepthEffectMakeBlurMap
CIDepthEffectApplyBlurMap
CIDepthEffect
Utilities
CIPixellate
CIHexagonalPixellate
CISharpenLuminance
CISwipeTransition
CIMattingSolverInternal
CIMattingSolver
CIMorphology
CICheapMorphology
CIMorphologyMinimum
CIMorphologyMaximum
CIMorphologyGradient
CIMorphologyLaplacian
CIPseudoMedian
CIBurstImageSet
CIHoleDistortion
CICheatBlur
CIMinimumComponent
CIMaximumComponent
CIVortexDistortion
CILanczosScaleTransform
CIMix
CIBlendWithMask
CIBlendWithRedMask
CIBlendWithBlueMask
CIBlendWithAlphaMask
CIBurstYUVImage
Apply
CIRAWTemperatureAdjust
CIRAWGamutMapping
CIFilterShape
CIFilterShapePrivate
CISimpleTile
CIAffineTile
CIClamp
CIAffineClamp
CICircleSplashDistortion
CIModTransition
CICopyMachineTransition
CITileFilter
CITile2Filter
CIFourfoldRotatedTile
CISixfoldRotatedTile
CITwelvefoldReflectedTile
CIFourfoldTranslatedTile
CIGlideReflectedTile
CIEightfoldReflectedTile
CIFourfoldReflectedTile
CISixfoldReflectedTile
CILineOverlay
CISpotColor
CIComicEffect
CIBoxBlur
PrivateLocalLight
CILocalLightMapPrepare
CILocalLightFilter
CICameraCalibrationLensCorrection
CIColorMap
CIMedianFilter
CIBarsSwipeTransition
CIDisintegrateWithMaskTransition
CIFlashTransition
BuiltIn
CIFocalPlanePreprocessorInternal
CIFocalPlaneNative
CIFocalPlane
AutoROI
CIMeshGenerator
CIDocumentEnhancer
CIPaperWash
CIContrastEnhancer
CIPerspectiveTransformWithExtent
CIPerspectiveTransform
CIPerspectiveTile
CIPerspectiveCorrection
CIBumpDistortion
CIBumpDistortionLinear
CIColorPolynomial
CIColorCrossPolynomial
CIRAWFilterImpl
CustomAccessors
WhiteBalance
CIHeightFieldFromMask
CIColorClamp
CIGlassDistortion
CIStretchCrop
CINinePartStretched
CINinePartTiled
CIPhotoEffect3D
CIPhotoEffect3DVivid
CIPhotoEffect3DVividWarm
CIPhotoEffect3DVividCool
CIPhotoEffect3DDramatic
CIPhotoEffect3DDramaticWarm
CIPhotoEffect3DDramaticCool
CIPhotoEffect3DSilverplate
CIPhotoEffect3DCommercial
CIPhotoEffect3DNoir
CheapRandomness
PercentileClipProcessor_RGBA8_CPU
HistoClip_RGBA8_CPU
ConvexFillProcessor
CIConvexFill
CISeedFillProcessor
CISeedFill
CICircularityDescriptor
RedEyeSpecular
RedEyeRecolor
RadialFalloffFilter
RedPupilLocalizer
CIRedEyeRaw
CIHistogramDisplayFilter
_CICompositeFilter
CISourceOverCompositing
CISourceInCompositing
CISourceOutCompositing
CISourceAtopCompositing
CIAdditionCompositing
CIMultiplyCompositing
CIMinimumCompositing
CIMaximumCompositing
CIPlusDarkerCompositing
CIPlusLighterCompositing
CILocalContrast
CIAccordionFoldTransition
CIBarcodeDetector
CIDisparityRefinement
CIConvolution3X3
CIConvolution5X5
CIConvolution7X7
CIConvolution9Horizontal
CIConvolution9Vertical
CUIScaleClampFilter
CUIInnerGlowOrShadowFilter
CUIOuterGlowOrShadowFilter
CUIShapeEffectBlur1
CUIOuterBevelEmbossFilter
CUIInnerBevelEmbossFilter
AutoCropper
CILensModelCalculatorCPU
CILensModelCalculator
CILensModelApply
CIOpacity
CICircularWrap
AutoAdjustCrop
{?={?=iiii}{CGPoint=ff}{CGPoint=ff}[4f][4f]{?=iiii}{?=iiii}fff[7{?=*iiiiiiif}]{?=*iiiiiiif}}16@0:4@8i12
{CGRect={CGPoint=ff}{CGSize=ff}}20@0:4@8{CGSize=ff}12
{CGRect={CGPoint=ff}{CGSize=ff}}16@0:4@8@12
v12@0:4@8
B20@0:4@8@12B16
i20@0:4@8@12i16
f20@0:4@8@12f16
@20@0:4@8@12@16
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4@8@12{CGRect={CGPoint=ff}{CGSize=ff}}16
v12@0:4i8
v8@0:4
^{?=*iiiiiiif}8@0:4
{?=iiii}8@0:4
{CGPoint=ff}16@0:4{CGPoint=ff}8
{?=iiii}12@0:4@8
@24@0:4{?=iiii}8
{?=iiii}24@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8
@36@0:4*8{CGRect={CGPoint=ff}{CGSize=ff}}12L28@32
{CGAffineTransform=ffffff}12@0:4i8
@12@0:4i8
@12@0:4@8
@16@0:4^{?=*iii}8B12
^{?=*iii}12@0:4@8
{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}12@0:4@8
@16@0:4^{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}8B12
@12@0:4^{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}8
{CGPoint=ff}40@0:4{CGAffineTransform=ffffff}8{CGPoint=ff}32
{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}36@0:4^{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}8{CGAffineTransform=ffffff}12
v32@0:4{CGAffineTransform=ffffff}8
@8@0:4
i12@0:4@8
@"<RedEyeInspector>"
{?="baseAddress"*"width"i"height"i"rowSamples"i"rowBytes"i"size"i"samplesPerPixel"i"bytesPerSample"i"resolution"f}
{?="minrow"i"maxrow"i"mincol"i"maxcol"i}
{CGRect="origin"{CGPoint="x"f"y"f}"size"{CGSize="width"f"height"f}}
@"NSArray"
{?="FR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}"leftEye"{CGPoint="x"f"y"f}"rightEye"{CGPoint="x"f"y"f}"leftDistMatrix"[4f]"rightDistMatrix"[4f]"LR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}"RR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}"IOD"f"IODp"f"IOAngle"f"channels"[7{?="baseAddress"*"width"i"height"i"rowSamples"i"rowBytes"i"size"i"samplesPerPixel"i"bytesPerSample"i"resolution"f}]"M"{?="baseAddress"*"width"i"height"i"rowSamples"i"rowBytes"i"size"i"samplesPerPixel"i"bytesPerSample"i"resolution"f}}
@"NSMutableArray"
{?="debug"B"base"[256c]"face"[4c]"eye"[2c]"title"[4c]"passSpec"[12c]"line1"[256c]"line2"[256c]"line3"[256c]}
*12@0:4i8
v820@0:4{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}8
B20@0:4@8^{?=*iiiiiiif}12^{?=iiii}16
{?=Bidiidi}36@0:4^{?=*iii}8i12^{?=*iiiiiiif}16{?=iiii}20
^{?=*iii}44@0:4^{?=*iiiiiiif}8i12i16^{?=^v^?}20i24^{?=iffffB{?=iiii}{CGPoint=ff}ff}28^B32^{?=iffffB{?=iiii}{CGPoint=ff}ff}36^^{?}40
B16@0:4i8^{?=iB^{?}^{?}i{?=B{CGPoint=ff}{?=fff}}{?=Bidiidi}{?=iiii}fffif{?=ffff}{?=ffff}iiiif{?=iiii}{?=ffffff}BB^{?}^{?}^{?}B^{?}^{?}^{?}i{?=fiiiifffiii}{?=B{CGPoint=ff}{?=fff}}{?=iffffB{?=iiii}{CGPoint=ff}ff}{?=iffffB{?=iiii}{CGPoint=ff}ff}i[4c][4c][12c]}12
^{?=*iii}24@0:4{?=iiii}8
B8@0:4
{?=ffff}60@0:4^{?=*iii}8{?=iiii}12i28^{?=ffff}32^i36^i40^i44^i48^f52^{?=iiii}56
v60@0:4^{?=iB^{?}^{?}i{?=B{CGPoint=ff}{?=fff}}{?=Bidiidi}{?=iiii}fffif{?=ffff}{?=ffff}iiiif{?=iiii}{?=ffffff}BB^{?}^{?}^{?}B^{?}^{?}^{?}i{?=fiiiifffiii}{?=B{CGPoint=ff}{?=fff}}{?=iffffB{?=iiii}{CGPoint=ff}ff}{?=iffffB{?=iiii}{CGPoint=ff}ff}i[4c][4c][12c]}8i12*16*20*24B28B32{?=ffffff}36
v12@0:4^{?=iB^{?}^{?}i{?=B{CGPoint=ff}{?=fff}}{?=Bidiidi}{?=iiii}fffif{?=ffff}{?=ffff}iiiif{?=iiii}{?=ffffff}BB^{?}^{?}^{?}B^{?}^{?}^{?}i{?=fiiiifffiii}{?=B{CGPoint=ff}{?=fff}}{?=iffffB{?=iiii}{CGPoint=ff}ff}{?=iffffB{?=iiii}{CGPoint=ff}ff}i[4c][4c][12c]}8
v40@0:4[7{?=iB^{?}^{?}i{?=B{CGPoint=ff}{?=fff}}{?=Bidiidi}{?=iiii}fffif{?=ffff}{?=ffff}iiiif{?=iiii}{?=ffffff}BB^{?}^{?}^{?}B^{?}^{?}^{?}i{?=fiiiifffiii}{?=B{CGPoint=ff}{?=fff}}{?=iffffB{?=iiii}{CGPoint=ff}ff}{?=iffffB{?=iiii}{CGPoint=ff}ff}i[4c][4c][12c]}]8i12{?=ffffff}16
{?=iB^{?}^{?}i{?=B{CGPoint=ff}{?=fff}}{?=Bidiidi}{?=iiii}fffif{?=ffff}{?=ffff}iiiif{?=iiii}{?=ffffff}BB^{?}^{?}^{?}B^{?}^{?}^{?}i{?=fiiiifffiii}{?=B{CGPoint=ff}{?=fff}}{?=iffffB{?=iiii}{CGPoint=ff}ff}{?=iffffB{?=iiii}{CGPoint=ff}ff}i[4c][4c][12c]}36@0:4[7{?=iB^{?}^{?}i{?=B{CGPoint=ff}{?=fff}}{?=Bidiidi}{?=iiii}fffif{?=ffff}{?=ffff}iiiif{?=iiii}{?=ffffff}BB^{?}^{?}^{?}B^{?}^{?}^{?}i{?=fiiiifffiii}{?=B{CGPoint=ff}{?=fff}}{?=iffffB{?=iiii}{CGPoint=ff}ff}{?=iffffB{?=iiii}{CGPoint=ff}ff}i[4c][4c][12c]}]8{?=ffffff}12
{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}504@0:4{?=iB^{?}^{?}i{?=B{CGPoint=ff}{?=fff}}{?=Bidiidi}{?=iiii}fffif{?=ffff}{?=ffff}iiiif{?=iiii}{?=ffffff}BB^{?}^{?}^{?}B^{?}^{?}^{?}i{?=fiiiifffiii}{?=B{CGPoint=ff}{?=fff}}{?=iffffB{?=iiii}{CGPoint=ff}ff}{?=iffffB{?=iiii}{CGPoint=ff}ff}i[4c][4c][12c]}8^{?=iB^{?}^{?}i{?=B{CGPoint=ff}{?=fff}}{?=Bidiidi}{?=iiii}fffif{?=ffff}{?=ffff}iiiif{?=iiii}{?=ffffff}BB^{?}^{?}^{?}B^{?}^{?}^{?}i{?=fiiiifffiii}{?=B{CGPoint=ff}{?=fff}}{?=iffffB{?=iiii}{CGPoint=ff}ff}{?=iffffB{?=iiii}{CGPoint=ff}ff}i[4c][4c][12c]}456i460{?=ffffff}464{?=iiii}488
f12@0:4i8
f20@0:4i8{CGPoint=ff}12
f8@0:4
v12@0:4^{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}8
B20@0:4*8i12i16
B16@0:4*8i12
B12@0:4*8
B16@0:4^{?=i{CGPoint=ff}ffffffif[32{?=ffff}]fiB{CGPoint=ff}fffffifBBBB{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}fii{?=iiii}i{?=iiii}iiiiiffiBffffffiiiif{?=iiii}f^{?}f}8i12
{CGPoint=ff}16@0:4f8^{?=B{CGPoint=ff}{?=fff}}12
{?=iiii}12@0:4^{?=B{CGPoint=ff}{?=fff}}8
f44@0:4{CGPoint=ff}8{CGPoint=ff}16{CGPoint=ff}24f32f36f40
d36@0:4^{CGPoint=ff}8{CGPoint=ff}12{CGPoint=ff}20{CGPoint=ff}28
B32@0:4{CGPoint=ff}8{CGPoint=ff}16{CGPoint=ff}24
f28@0:4{CGPoint=ff}8f16f20f24
d8@0:4
d28@0:4i8d12d20
i24@0:4^{?=*iii}8i12i16i20
v44@0:4^{?=*iiiiiiif}8^{?=*iii}12i16{?=iiii}20^{?=II}36^{?=II}40
d16@0:4^{?=II}8^{?=II}12
B36@0:4^{?=*iii}8{?=iiii}12^{?=ii^{?}}28^{?=ii^{?}}32
v16@0:4^{?=ii^{?}}8*12
B40@0:4^{?=*iii}8{?=iiii}12^{?=ii^{?}}28^{?=ii^{?}}32[256c]36
i36@0:4[4{?=ii}]8^{?=*iii}12i16i20i24i28i32
v52@0:4^{?=i[4{?=fiiiifffiii}]}8f12i16i20f24f28i32i36i40i44i48
v20@0:4^{?=iffffB{?=iiii}{CGPoint=ff}ff}8i12^{?=iff^{?}iii{?=iffffB{?=iiii}{CGPoint=ff}ff}B{?=iffffB{?=iiii}{CGPoint=ff}ff}ii}16
@12@0:4^{?=*iiiiiiif}8
v28@0:4*8^{?=fiiiifffiii}12^{?=iffffB{?=iiii}{CGPoint=ff}ff}16*20i24
@16@0:4@8@12
B12@0:4@8
v20@0:4@8@12@16
v32@0:4^{?=*iii}8^{?=B{CGPoint=ff}{?=fff}}12i16B20i24^{?=B[256c][4c][2c][4c][12c][256c][256c][256c]}28
v20@0:4^{?=*iii}8i12^{?=B[256c][4c][2c][4c][12c][256c][256c][256c]}16
v24@0:4^{?=iffffB{?=iiii}{CGPoint=ff}ff}8i12i16^{?=B[256c][4c][2c][4c][12c][256c][256c][256c]}20
v12@0:4^{?=iiii[100{?=fff}][100{?=fff}][100{?=fff}][100{?=fff}]}8
v32@0:4^{?=iiii[100{?=fff}][100{?=fff}][100{?=fff}][100{?=fff}]}8^f12^f16i20f24^{?=B[256c][4c][2c][4c][12c][256c][256c][256c]}28
f20@0:4^{?=*iii}8^{?=B[256c][4c][2c][4c][12c][256c][256c][256c]}12^{?=B{CGPoint=ff}{?=fff}}16
d12@0:4r^{CIBurstSupportVector=d[7d]}8
v12@0:4f8
^{__SVMParameters=[7{__SVMScaleOffset=ff}]ddii^{CIBurstSupportVector}^{CIBurstSupportVector}}8@0:4
v12@0:4^{__SVMParameters=[7{__SVMScaleOffset=ff}]ddii^{CIBurstSupportVector}^{CIBurstSupportVector}}8
[7d]
^{__SVMParameters=[7{__SVMScaleOffset=ff}]ddii^{CIBurstSupportVector}^{CIBurstSupportVector}}
v12@0:4B8
v28@0:4@8@12@16@20@?24
@16@0:4@8B12
v16@0:4@8i12
i8@0:4
@"NSObject<OS_dispatch_queue>"
@"NSObject<OS_dispatch_semaphore>"
@"NSString"
@"CIBurstImageFaceAnalysisContext"
@"CIBurstYUVImage"
@"NSDictionary"
@"NSCountedSet"
@"NSMutableDictionary"
^{__sFILE=*iiss{__sbuf=*i}i^v^?^?^?^?{__sbuf=*i}^{__sFILEX}i[3C][1C]{__sbuf=*i}iq}
@"CIBurstActionClassifier"
@"CIImage"
@"NSNumber"
{IRect={IPoint=qq}{ISize=II}}8@0:4
@"CIVector"
@"CIContext"
@16@0:4@8f12
@28@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24
{CGRect={CGPoint=ff}{CGSize=ff}}8@0:4
v24@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8
@12@0:4f8
f24@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8
{CGPoint=ff}8@0:4
v16@0:4{CGPoint=ff}8
{CGSize=ff}8@0:4
v16@0:4{CGSize=ff}8
{CGPoint="x"f"y"f}
{CGSize="width"f"height"f}
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8f24f28
{CGRect={CGPoint=ff}{CGSize=ff}}20@0:4@8@12^B16
@28@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24
i16@0:4@8@12
v16@0:4@8@12
v20@0:4@8{CGSize=ff}12
v16@0:4d8
@12@0:4^{_NSZone=}8
v24@0:4^^f8^^f12^^f16^^f20
v12@0:4^f8
{GridROI_t=iiii}8@0:4
f16@0:4@8@12
v24@0:4{GridROI_t=iiii}8
v20@0:4@8^f12^f16
f12@0:4@8
^S8@0:4
f12@0:4f8
^f8@0:4
[1024f]
[256S]
{FastRegistration_Signatures="piRow"^f"nPiRow"I"piRowTable"{Projections_meanStdTable="sumTable"^f"sumSqTable"^f}"piCol"^f"nPiCol"I"piColTable"{Projections_meanStdTable="sumTable"^f"sumSqTable"^f}}
^{SharpnessGridElement_t=CCf}
{GridROI_t="startX"i"startY"i"endX"i"endY"i}
v12@0:4@"NSCoder"8
@12@0:4@"NSCoder"8
@24@0:4@8i12C16i20
C8@0:4
@"NSData"
@24@0:4@8B12i16i20
@24@0:4@8i12i16i20
@16@0:4^{CGContext=}8@12
i44@0:4@8^v12i16{CGRect={CGPoint=ff}{CGSize=ff}}20i36^{CGColorSpace=}40
^{CGColorSpace=}8@0:4
Q8@0:4
v44@0:4@8^v12i16{CGRect={CGPoint=ff}{CGSize=ff}}20i36^{CGColorSpace=}40
v16@0:4@8^{__CVBuffer=}12
v36@0:4@8^{__CVBuffer=}12{CGRect={CGPoint=ff}{CGSize=ff}}16^{CGColorSpace=}32
v12@0:4r*8
v36@0:4@8{CGPoint=ff}12{CGRect={CGPoint=ff}{CGSize=ff}}20
v44@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12{CGRect={CGPoint=ff}{CGSize=ff}}28
v36@0:4@8I12{CGRect={CGPoint=ff}{CGSize=ff}}16^{CGColorSpace=}32
v40@0:4@8I12I16{CGRect={CGPoint=ff}{CGSize=ff}}20^{CGColorSpace=}36
v40@0:4@8@12@16{CGRect={CGPoint=ff}{CGSize=ff}}20^{CGColorSpace=}36
^{CGImage=}28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
^{CGImage=}32@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28
^{CGImage=}36@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28^{CGColorSpace=}32
^{CGImage=}40@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28^{CGColorSpace=}32B36
^{CGLayer=}20@0:4{CGSize=ff}8^{__CFDictionary=}16
L8@0:4
@36@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28^{CGColorSpace=}32
B24@0:4@8i12^@16^{CGRect={CGPoint=ff}{CGSize=ff}}20
{CGAffineTransform=ffffff}8@0:4
@16@0:4@8i12
^{CGImage=}44@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12i28^{CGColorSpace=}32B36L40
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@}8@0:4
@12@0:4^v8
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@}12@0:4@8
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@}16@0:4@8@12
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@}16@0:4@8^v12
@28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
@32@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12^@28
I8@0:4
v16@0:4@8B12
[8^v]
@"NSArray"8@0:4
@"CIFilter"12@0:4@"NSArray"8
r^{CGImageMetadata=}28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
@28@0:4^{CGImageMetadata=}8{CGRect={CGPoint=ff}{CGSize=ff}}12
@20@0:4@8i12f16
@12@0:4^{CGImage=}8
@16@0:4^{CGImage=}8@12
@12@0:4^{CGLayer=}8
@16@0:4^{CGLayer=}8@12
@32@0:4@8L12{CGSize=ff}16i24@28
@32@0:4@8L12{CGSize=ff}16i24^{CGColorSpace=}28
@28@0:4I8{CGSize=ff}12B20^{CGColorSpace=}24
@24@0:4I8{CGSize=ff}12@20
@28@0:4I8{CGSize=ff}12B20@24
@12@0:4^{__CVBuffer=}8
@16@0:4^{__CVBuffer=}8@12
@16@0:4@8@?12
@20@0:4^{__IOSurface=}8@12^v16
v16@0:4^{CGImage=}8@12
^{CGImage=}8@0:4
@20@0:4^{CGImageSource=}8@12B16
@16@0:4^{CGImageSource=}8@12
@20@0:4^{CGImageSource=}8L12@16
v16@0:4^{__CVBuffer=}8@12
^{__CVBuffer=}8@0:4
@24@0:4f8f12f16f20
{CGAffineTransform=ffffff}12@0:4I8
@12@0:4I8
@32@0:4{CGAffineTransform=ffffff}8
@36@0:4{CGAffineTransform=ffffff}8B32
@24@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8
@16@0:4d8
@12@0:4^{CGColorSpace=}8
@12@0:4B8
^v8@0:4
{CGRect={CGPoint=ff}{CGSize=ff}}28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
@20@0:4@8i12@16
@20@0:4@8@12^@16
@24@0:4@8@12i16^@20
@28@0:4@8@12{CGSize=ff}16^@24
@32@0:4@8@12i16{CGSize=ff}20^@28
@20@0:4@8@12B16
@72@0:4{CIKernelReflection=ii**{vector<CI::KernelArgumentType, std::__1::allocator<CI::KernelArgumentType> >=^i^i{__compressed_pair<CI::KernelArgumentType *, std::__1::allocator<CI::KernelArgumentType> >=^i}}{vector<std::__1::basic_string<char>, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}{__compressed_pair<std::__1::basic_string<char> *, std::__1::allocator<std::__1::basic_string<char> > >=^{basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >}}}@IiIIB}8
B12@0:4i8
i16@0:4@8^{Kernel=^^?{atomic<unsigned int>=AI}**B^{SerialIntArray}^{SerialStringArray}^{__CFString}ii{ISize=II}BBBBBB}12
@36@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@?24@28@32
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@?24@28
v12@0:4:8
:8@0:4
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28
@40@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@?24@28@32@36
@36@0:4@8@12{CGSize=ff}16i24B28^{CGColorSpace=}32
@32@0:4@8L12L16i20^{CGColorSpace=}24@28
@32@0:4@?8L12L16i20^{CGColorSpace=}24@28
@36@0:4@?8L12L16i20^{CGColorSpace=}24B28@32
@28@0:4d8i16@20@24
{vec2=ff}8@0:4
@"NSValue"
@24@0:4@8i12^{CGColorSpace=}16@20
@20@0:4@8^{CGColorSpace=}12@16
B32@0:4@8@12i16^{CGColorSpace=}20@24^@28
B28@0:4@8@12^{CGColorSpace=}16@20^@24
@"CIColor"
I12@0:4I8
B12@0:4#8
@24@0:4@8@12@16@20
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24@28
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24^{CGColorSpace=}28
v28@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12
@16@0:4r^f8L12
@16@0:4f8f12
@20@0:4f8f12f16
@16@0:4{CGPoint=ff}8
f12@0:4L8
(?="vec"[4f]"ptr"^f)
@36@0:4@8@12@16{CGRect={CGPoint=ff}{CGSize=ff}}20
i12@0:4i8
@52@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28@32@36@40@44^@48
@44@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28@32@36^@40
@40@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28@32^@36
B24@0:4@8@12@16^@20
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4i8@12{CGRect={CGPoint=ff}{CGSize=ff}}16
@36@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24@28^@32
@"NSAttributedString"
@44@0:4^{__IOSurface=}8{Texture=(?={?=II}^v)}12B20{CGRect={CGPoint=ff}{CGSize=ff}}24^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@}40
^{__IOSurface=}8@0:4
^{__IOSurface=}
^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@}
@"<MTLTexture>"
@"<MTLTexture>"8@0:4
@"<MTLCommandBuffer>"8@0:4
@"<MTLCommandBuffer>"
r^v8@0:4
@56@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8@24Q28i36i40@44@?48@?52
Q12@0:4@8
v24@0:4@8@12I16@20
v40@0:4@8@12I16@20I24{?=III}28
@"<MTLDevice>"
@"<MTLFunction>"
@20@0:4@8@12*16
@20@0:4d8@16
@28@0:4d8d16@24
@"CIFilter"
@36@0:4^v8i12{CGRect={CGPoint=ff}{CGSize=ff}}16i32
@40@0:4^v8i12{CGRect={CGPoint=ff}{CGSize=ff}}16i32@36
B36@0:4^v8i12{CGRect={CGPoint=ff}{CGSize=ff}}16i32
^{CIBitmapContextPrivate=^vi{CGRect={CGPoint=ff}{CGSize=ff}}i}
@20@0:4@8{CGSize=ff}12
@36@0:4@8{CGAffineTransform=ffffff}12
{CGPoint=ff}44@0:4@8@12i16{CGAffineTransform=ffffff}20
@52@0:4@8{CGAffineTransform=ffffff}12{CGRect={CGPoint=ff}{CGSize=ff}}36
@12@0:4r^f8
@12@0:4r^d8
r^f8@0:4
[256f]
^{CIRenderDestinationInternal=^{RenderDestination}IIi^{CGColorSpace}IBBiBB@}8@0:4
^{RenderDestination=^^?{atomic<unsigned int>=AI}^{__CFString}}8@0:4
@28@0:4^{RenderDestination=^^?{atomic<unsigned int>=AI}^{__CFString}}8I12I16i20^{CGColorSpace=}24
^{RenderTask=^^?{atomic<unsigned int>=AI}**i[64c]L^{Node}{CGRect={CGPoint=ff}{CGSize=ff}}iQ^{__CFString}^{__CFString}{vector<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}{__compressed_pair<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > *, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}}}dQIII}16@0:4^{Image=^^?{atomic<unsigned int>=AI}{CGRect={CGPoint=ff}{CGSize=ff}}^{__CFURL}^v^vI}8^{Context=^^?{atomic<unsigned int>=AI}^{CGColorSpace}^{CGColorSpace}iBBBBB^{CGContext}fB{CGRect={CGPoint=ff}{CGSize=ff}}{CGAffineTransform=ffffff}ILLi[64c]B^{ObjectCache<CI::MainProgram, false>}^{ObjectCache<CI::Node, false>}^{ObjectCache<CI::Node, false>}dd^{RenderTask}ii^{Context}I@@}12
@28@0:4I8I12L16^{CGColorSpace=}20@?24
@28@0:4I8I12I16@20@?24
@24@0:4I8I12I16I20
@28@0:4^v8I12I16I20i24
v12@0:4I8
v12@0:4^{CGColorSpace=}8
d16@0:4Q8
@12@0:4^{RenderTask=^^?{atomic<unsigned int>=AI}**i[64c]L^{Node}{CGRect={CGPoint=ff}{CGSize=ff}}iQ^{__CFString}^{__CFString}{vector<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}{__compressed_pair<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > *, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}}}dQIII}8
^{RenderTask=^^?{atomic<unsigned int>=AI}**i[64c]L^{Node}{CGRect={CGPoint=ff}{CGSize=ff}}iQ^{__CFString}^{__CFString}{vector<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}{__compressed_pair<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > *, std::__1::allocator<std::__1::unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> > > >=^{unique_ptr<CI::TileTask, CI::ObjectDeleter<CI::TileTask> >}}}dQIII}8@0:4
@12@0:4^@8
@44@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12@28{CGPoint=ff}32^@40
@24@0:4@8@12B16^@20
B44@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12@28{CGPoint=ff}32^@40
@16@0:4@8^@12
@16@0:4@8I12
@20@0:4@8I12^{CGColorSpace=}16
@24@0:4@8I12^{CGColorSpace=}16@20
@20@0:4@8@12^{CGColorSpace=}16
r*12@0:4I8
v16@0:4@8^{CGColorSpace=}12
s8@0:4
^{CGColorSpace=}
v24@0:4@8i12i16i20
@16@0:4r^{CGPoint=ff}8B12
@12@0:4r^{CGPoint=ff}8
v24@0:4^f8i12f16r^{CGPoint=ff}20
@12@0:4#8
v12@0:4^{?=Bffff[3f]}8
@12@0:4^f8
v24@0:4@8@12i16@20
@28@0:4@8@12@16I20@24
{CGRect={CGPoint=ff}{CGSize=ff}}28@0:4{CGPoint=ff}8{CGSize=ff}16f24
B24@0:4^{CGImage=}8^{?=*iiiiiiif}12L16L20
B16@0:4^{CGImage=}8^{?=*iiiiiiif}12
@16@0:4@8^{?=[256c][32c]{?=*iiiiiiif}ii{?=iiii}^{CGColorSpace}IiiBf}12
@12@0:4^{?=[256c][32c]{?=*iiiiiiif}ii{?=iiii}^{CGColorSpace}IiiBf}8
@24@0:4*8{CGSize=ff}12L20
@44@0:4*8{CGRect={CGPoint=ff}{CGSize=ff}}12{CGSize=ff}28L36@40
^{?=i{CGPoint=ff}iiii{?=*iiiiiiif}{?=iiii}{?=iiii}B{?=iiii}iBf{?=iiiiiiiiiiB{?=iiii}{?=iiii}iiif{?=^v^?ifBifff}{?=iiii}}{?={CGPoint=ff}ifffi{?=iiii}fBiiiiffff}}8@0:4
i20@0:4^{?=*iiiiiiif}8^{?=*iiiiiiif}12^{?=*iiiiiiif}16
B52@0:4^{?=*iiiiiiif}8^{?=*iiiiiiif}12^{?=*iiiiiiif}16{?=iiii}20^{?=*iiiiiiif}36^{?=*iiiiiiif}40^{?=iiii}44^{?=iiii}48
B36@0:4^{?=*iiiiiiif}8{?=iiii}12^{?=*iiiiiiif}28^{?=*iiiiiiif}32
i48@0:4{CGPoint=ff}8B16{?=iiii}20i36f40B44
^{?=i{CGPoint=ff}iiii{?=*iiiiiiif}{?=iiii}{?=iiii}B{?=iiii}iBf{?=iiiiiiiiiiB{?=iiii}{?=iiii}iiif{?=^v^?ifBifff}{?=iiii}}{?={CGPoint=ff}ifffi{?=iiii}fBiiiiffff}}12@0:4i8
i16@0:4i8f12
f20@0:4^{?=Biiffiiiiffiiii}8^f12i16
f20@0:4f8i12i16
v40@0:4^{?=i[4{?=fiifffiif}]}8i12i16f20f24i28i32f36
B68@0:4^{?=*iiiiiiif}8^{?=*iiiiiiif}12i16i20{?=iiii}24^{?=Biiffiiiiffiiii}40^{?=i[4{?=fiifffiif}]}44i48B52[10f]56[10f]60*64
B64@0:4^{?=*iiiiiiif}8^{?=*iiiiiiif}12^{?=*iiiiiiif}16^{?=*iiiiiiif}20i24i28{?=iiii}32^{?=Biiffiiiiffiiii}48^{?=i[4{?=fiifffiif}]}52i56B60
B60@0:4{?=iiii}8^{?=Biiffiiiiffiiii}24i28B32f36f40^{?=i[4{?=fiifffiif}]}44^{?=i[4{?=fiifffiif}]}48^{?=*iiiiiiif}52^{?=*iiiiiiif}56
{?=iiBBfiiii}24@0:4^{?=Biiffiiiiffiiii}8B12^{?=i[4{?=fiifffiif}]}16^{?=i[4{?=fiifffiif}]}20
i36@0:4^{?=iiBBfiiii}8B12f16B20^{?=iiii}24i28^{?=i[4{?=fiifffiif}]}32
v56@0:4{?=iiii}8{?=iiii}24^{?=Biiffiiiiffiiii}40f44B48i52
i16@0:4i8i12
i152@0:4{?=iiiiiiiiiiB{?=iiii}{?=iiii}iiif{?=^v^?ifBifff}{?=iiii}}8
B20@0:4^f8@12@16
B20@0:4^i8@12@16
B20@0:4^B8@12@16
v24@0:4^f8^f12^f16^f20
v16@0:4^f8^f12
^{?=[256c][32c]{?=*iiiiiiif}ii{?=iiii}^{CGColorSpace}IiiBf}
^{CGImageBlockSet=}
^{__CFData=}
[32{?="tag"i"pt2"{CGPoint="x"f"y"f}"eyeCase"i"forceCase"i"npixels"i"bignpixels"i"fullNew"{?="baseAddress"*"width"i"height"i"rowSamples"i"rowBytes"i"size"i"samplesPerPixel"i"bytesPerSample"i"resolution"f}"YR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}"psTemplate"{?="lo"i"med"i"hi"i"average"i}"pupilShadeAlignment"B"matchingTemplate"{?="lo"i"med"i"hi"i"average"i}"faceIndex"i"left"B"IOD"f"data"{?="origHitX"i"origHitY"i"snapHitX"i"snapHitY"i"bitmaskSeedX"i"bitmaskSeedY"i"bitmaskThreshold"i"cornealReflectionSeedX"i"cornealReflectionSeedY"i"cornealReflectionThreshold"i"align"B"mTemplate"{?="lo"i"med"i"hi"i"average"i}"existingTemplate"{?="lo"i"med"i"hi"i"average"i}"averageSkinMapY"i"characterizeCase"i"finalEyeCase"i"IOD"f"O"{?="bitmapproc_context"^v"bproc"^?"orientation"i"SNR"f"N90"B"redBitmaskArea"i"imageCenterX"f"imageCenterY"f"halfDiagonalSize"f}"CR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}}"BI"{?="centroid"{CGPoint="x"f"y"f}"area"i"ovalness"f"contrast"f"mincontrast"f"nborder"i"IR"{?="minrow"i"maxrow"i"mincol"i"maxcol"i}"aspectRatio"f"touchingEdge"B"localmax"i"localmaxrow"i"localmaxcol"i"localfloor"i"rgmean"f"rgstd"f"ymean"f"ystd"f}}]
{?="lo"i"med"i"hi"i"average"i}
[3{?="baseAddress"*"width"i"height"i"rowSamples"i"rowBytes"i"size"i"samplesPerPixel"i"bytesPerSample"i"resolution"f}]
[3{?="minrow"i"maxrow"i"mincol"i"maxcol"i}]
[20{CGPoint="x"f"y"f}]
[20{?="a"f"b"f"c"f}]
[20B]
[65536C]
[8[3i]]
{Rectangle=dddd}60@0:4{vec2=ff}8{vec3=fff}16{vec4=ffff}28{vec4=ffff}44
{CGRect={CGPoint=ff}{CGSize=ff}}24@0:4{vec4=ffff}8
@20@0:4^{__CVBuffer=}8@12@16
@"FCRFaceDetector"
@100@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8B24{CGPoint=ff}28B36{CGPoint=ff}40B48{CGPoint=ff}52B60f64B68i72B76i80B84B88B92@96
@56@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8{CGPoint=ff}24{CGPoint=ff}32{CGPoint=ff}40{CGPoint=ff}48
@12@0:4^{?={CGRect={CGPoint=ff}{CGSize=ff}}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}{CGPoint=ff}@}8
@"CIQRCodeDescriptor"
@64@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8{CGPoint=ff}24{CGPoint=ff}32{CGPoint=ff}40{CGPoint=ff}48@56@60
@12@0:4^{CGColor=}8
@28@0:4f8f12f16f20^{CGColorSpace=}24
@24@0:4f8f12f16^{CGColorSpace=}20
^{CGColor=}8@0:4
[3^v]
f20@0:4f8f12^f16
v16@0:4f8f12
v20@0:4f8f12f16
{?=ff}8@0:4
{CGPoint=ff}12@0:4L8
i12@0:4^f8
v20@0:4@8I12^f16
v16@0:4@8I12
{?="i"f"q"f}
@"CIEnhancementHistogram"
^{OpaqueVTPixelTransferSession=}
^{__CVBuffer=}
^{vImage_Buffer=^vIII}
@"NSObject<OS_dispatch_data>"
@"<MTLLibrary>"
@32@0:4@8@12i16i20B24^{CGColorSpace=}28
@24@0:4@8i12B16^{CGColorSpace=}20
B20@0:4^{__CVBuffer=}8@12@16
B12@0:4^{__CVBuffer=}8
B16@0:4^{__CVBuffer=}8^{__CVBuffer=}12
v12@0:4^{__CVBuffer=}8
@"CIRenderDestination"
@"NSDate"
{CGRect={CGPoint=ff}{CGSize=ff}}16@0:4f8f12
r*8@0:4
@28@0:4@8@12@16@20@?24
f20@0:4@8^i12i16
@?8@0:4
v12@0:4@?8
@"AVCameraCalibrationData"
^{CGImageMetadata=}16@0:4^{CGImageMetadata=}8@12
@12@0:4^{CGImageMetadata=}8
^{CGImageMetadata=}16@0:4@8^{CGImageMetadata=}12
^{CGImageMetadata=}12@0:4@8
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4@8{CGRect={CGPoint=ff}{CGSize=ff}}12f28
v16@0:4^v8^v12
@"CIBurstImageSetInternal"
@24@0:4d8d16
v16@0:4*8i12
@16@0:4^{CGImage=}8i12
*8@0:4
v12@0:4*8
@24@0:4@8@12@16^{CGColorSpace=}20
@12@0:4^{filterShape={CGRect={CGPoint=ff}{CGSize=ff}}}8
@16@0:4i8i12
^{CGSRegionObject=}8@0:4
{CGPoint=ff}36@0:4{CGPoint=ff}8@16{CGPoint=ff}20{CGSize=ff}28
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4i8{CGRect={CGPoint=ff}{CGSize=ff}}12@28
@16@0:4^{WarpKernel=^^?{atomic<unsigned int>=AI}**B^{SerialIntArray}^{SerialStringArray}^{__CFString}ii{ISize=II}BBBBBB^^?}8^{SerialObjectPtrArray=iii^^v}12
@32@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8i24i28
{CGRect={CGPoint=ff}{CGSize=ff}}36@0:4^{WarpKernel=^^?{atomic<unsigned int>=AI}**B^{SerialIntArray}^{SerialStringArray}^{__CFString}ii{ISize=II}BBBBBB^^?}8^{SerialObjectPtrArray=iii^^v}12@16{CGRect={CGPoint=ff}{CGSize=ff}}20
{CGRect={CGPoint=ff}{CGSize=ff}}24@0:4i8i12d16
^{CGImageSource=}
@"NSObject"
{CGAffineTransform=ffffff}12@0:4@8
@16@0:4r^d8@12
v20@0:4^@8^@12^@16
v24@0:4@8@12^@16^@20
v40@0:4^{CGPoint=ff}8@12{CGRect={CGPoint=ff}{CGSize=ff}}16{CGPoint=ff}32
@20@0:4{CGSize=ff}8B16
@24@0:4@8^@12B16i20
{CGRect={CGPoint=ff}{CGSize=ff}}28@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8f24
{CGRect={CGPoint=ff}{CGSize=ff}}40@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8{CGRect={CGPoint=ff}{CGSize=ff}}24
{CGRect={CGPoint=ff}{CGSize=ff}}32@0:4{CGSize=ff}8{CGRect={CGPoint=ff}{CGSize=ff}}16
i16@0:4{CGSize=ff}8
{CGRect={CGPoint=ff}{CGSize=ff}}40@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8{CGSize=ff}24{CGPoint=ff}32
{CGRect={CGPoint=ff}{CGSize=ff}}36@0:4{CGSize=ff}8{CGPoint=ff}16i24{CGSize=ff}28
{CGRect={CGPoint=ff}{CGSize=ff}}20@0:4{CGSize=ff}8@16
i48@0:4{CGSize=ff}8{CGRect={CGPoint=ff}{CGSize=ff}}16{CGRect={CGPoint=ff}{CGSize=ff}}32
{CGRect={CGPoint=ff}{CGSize=ff}}52@0:4{CGSize=ff}8{CGRect={CGPoint=ff}{CGSize=ff}}16i32{CGRect={CGPoint=ff}{CGSize=ff}}36
{CGPoint=ff}40@0:4{CGPoint=ff}8{CGPoint=ff}16{CGPoint=ff}24{CGPoint=ff}32
@40@0:4@8@12@16{CGRect={CGPoint=ff}{CGSize=ff}}20^{CGRect={CGPoint=ff}{CGSize=ff}}36
@32@0:4@8^{CGImage=}12{CGRect={CGPoint=ff}{CGSize=ff}}16
v56@0:4@8{CGAffineTransform=ffffff}12{CGRect={CGPoint=ff}{CGSize=ff}}36^{CGRect={CGPoint=ff}{CGSize=ff}}52
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
0014
0015
0023
0024
0025
0029
0030
0033
0044
0045
0053
0091
0095
0096
0115
0124
0125
0126
0128
0129
0130
0138
0156
0157
0187
0206
0207
0224
0251
0252
0257
0266
0267
0271
0272
0286
0029
0047
0052
0056
0071
0072
0076
0091
0111
0114
0123
0127
0134
0157
0173
0191
0207
0331
0334
0337
0339
0367
0369
0394
0484
0492
0494
0497
0504
0511
0528
0545
0550
0554
0588
0592
0593
0619
0620
?P$
