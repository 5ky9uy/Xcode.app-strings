*** NXCreateHashTable: invalid style
*** NXCreateHashTable: bug
*** hashtable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isEqual(x, y) is TRUE but hash(x) != hash (y)
*** NXCreateMapTable: invalid creation parameters
*** NXMapInsert: invalid key: -1
**** NXMapInsert: bug
**** NXMapRemove: incorrect table
**** NXMapRemove: bug
*** maptable: count differs after rehashing; probably indicates a broken invariant: there are x and y such as isEqual(x, y) is TRUE but hash(x) != hash (y)
CACHES: new empty buckets at %p (capacity %zu)
Method cache corrupted. This may be a message to an invalid object, or a memory error somewhere else.
%s %p, SEL %p, isa %p, cache %p, buckets %p, mask 0x%x, occupied 0x%x
receiver
unused
%s %zu bytes, buckets %zu bytes
selector '%s'
isa '%s'
CACHES: not collecting; objc_msgSend in progress
CACHES: COLLECTING %zu bytes (%zu allocations, %zu collections)
CACHES: %4d slots: %4d caches, %6zu bytes
CACHES:      total: %4zu caches, %6zu bytes
task_threads failed (result 0x%x)
CXX: calling C++ constructors for class %s
class_respondsToMethod
class_lookupMethod
invalid selector (null)
/tmp/msgSends-%d
%c %s %s %s
Class %s is implemented in both %s (%p) and %s (%p). One of the two will be used. Which one is undefined.
"%s"%s,
%s%s,
CXX: calling C++ destructors for class %s
RESOLVE: method %c[%s %s] dynamically resolved to %p
RESOLVE: +[%s resolveInstanceMethod:%s] returned YES, but no new implementation of %c[%s %s] was found
RESOLVE: +[%s resolveClassMethod:%s] returned YES, but no new implementation of %c[%s %s] was found
%s: %s
objc[%d]: %s
The function %s is obsolete. Use %s instead. Set a breakpoint on _objc_warn_deprecated to find the culprit.
The function %s is obsolete. Do not use it. Set a breakpoint on _objc_warn_deprecated to find the culprit.
objc[%d]: HALTED
... %s
EXCEPTIONS: %s through frame [ip=%p sp=%p] for exception %p
unwinding
searching
EXCEPTIONS: throwing %p (object %p, a %s)
EXCEPTIONS: rethrowing current exception
EXCEPTIONS: handling exception %p at %p
EXCEPTIONS: finishing handler
unexpected call into objc exception typeinfo vtable %d
EXCEPTIONS: releasing completed exception %p (object %p, a %s)
EXCEPTIONS: skipping catch(?)
EXCEPTIONS: catch(id)
EXCEPTIONS: catch(%s)
EXCEPTIONS: skipping catch(%s)
EXCEPTIONS: terminating
__objc_selrefs
__objc_msgrefs
__objc_classrefs
__objc_superrefs
__objc_classlist
__objc_nlclslist
__objc_catlist
__objc_nlcatlist
__objc_protolist
__objc_protorefs
__objc_init_func
__objc_imageinfo
__DATA
__DATA_CONST
__DATA_DIRTY
__objc_
INITIALIZE: thread %p: blocking until +[%s initialize] completes
INITIALIZE: thread %p: skipping trivial +[%s initialize] in fork() child process
INITIALIZE: thread %p: refusing to call +[%s initialize] in fork() child process because it may have been in progress when fork() was called
+[%s initialize] may have been in progress in another thread when fork() was called.
+[%s initialize] may have been in progress in another thread when fork() was called. We cannot safely call it or ignore it in the fork() child process. Crashing instead. Set a breakpoint on objc_initializeAfterForkError to debug.
INITIALIZE: thread %p: calling +[%s initialize]
INITIALIZE: thread %p: finished +[%s initialize]
INITIALIZE: thread %p: +[%s initialize] threw an exception
thread-safe class init in objc runtime is buggy!
pthread_mutex_lock failed (%d)
pthread_mutex_unlock failed (%d)
INITIALIZE: thread %p: %s is fully +initialized
pthread_cond_broadcast failed (%d)
thread is not initializing this class!
INITIALIZE: thread %p: class %s will be marked as fully +initialized after superclass +[%s initialize] completes
thread is already initializing this class!
pthread_cond_wait failed (%d)
warning: failing to set GC layout for '%s'
layout bitmap sliding backwards
layout bitmap too short
layout_bitmap_or: layout bitmap too short%s%s
layout_bitmap_clear: layout bitmap too short%s%s
%zu: 
LOAD: class '%s' scheduled for +load
LOAD: category '%s(%s)' scheduled for +load
LOAD: class '%s' unscheduled for +load
LOAD: category '%s(%s)' unscheduled for +load
LOAD: +[%s load]
LOAD: +[%s(%s) load]
LOAD: %d categories still waiting for +load
FUTURE: found %p already in use for %s
the image is for iOS simulator
PREOPTIMIZATION: reading classes manually from %s because %s
CLASS: IGNORING class '%s' with missing weak-linked superclass
Can't complete future class request for '%s' because the real class is too big.
CLASS: found %d classes during launch
IMAGE TIMES: first time tasks
IMAGE TIMES: discover classes
IMAGE TIMES: remap classes
IMAGE TIMES: fix up selector references
IMAGE TIMES: discover protocols
IMAGE TIMES: fix up @protocol references
IMAGE TIMES: realize non-lazy classes
IMAGE TIMES: realize future classes
CLASS: IGNORING category ???(%s) %p with missing weak-linked target class
CLASS: found category -%s(%s) %s
on existing class
CLASS: found category +%s(%s)
IMAGE TIMES: discover categories
PREOPTIMIZATION: honoring preoptimized selectors in %s
PREOPTIMIZATION: IGNORING preoptimized selectors in %s
PREOPTIMIZATION: %zu selector references not pre-optimized
PREOPTIMIZATION: %u/%u (%.3g%%) method lists pre-sorted
PREOPTIMIZATION: %u/%u (%.3g%%) classes pre-registered
PREOPTIMIZATION: %zu protocol references not pre-optimized
objc_registerProtocol: protocol '%s' was already registered!
objc_registerProtocol: protocol '%s' was not allocated with objc_allocateProtocol!
protocol_addProtocol: modified protocol '%s' is not under construction!
protocol_addProtocol: added protocol '%s' is still under construction!
protocol_addMethodDescription: protocol '%s' is not under construction!
protocol_addProperty: protocol '%s' is not under construction!
v8@?0#4
load
Memory corruption in class list.
CUSTOM RR:  %s%s%s
 (meta)
 (inherited)
CUSTOM AWZ:  %s%s%s
RAW ISA:  %s%s%s
*** Can't set ivar layout for already-registered class '%s'
*** Can't set weak ivar layout for already-registered class '%s'
CLASS: realizing class '%s' (duplicate of %s) %p %p
objc_registerClassPair: class '%s' was already registered!
objc_registerClassPair: class '%s' was not allocated with objc_allocateClassPair!
objc_readClassPair for class %s changed %p to %p
objc_disposeClassPair: class '%s' was not allocated with objc_allocateClassPair!
objc_disposeClassPair: class '%s' is a metaclass, not a class!
objc_disposeClassPair: class '%s' still has subclasses, including '%s'!
INITIALIZE: %d/%d (%g%%) successful by-name metaclass lookups
INITIALIZE: %d/%d (%g%%) successful secondary metaclass lookups
INITIALIZE: %d/%d (%g%%) successful shared cache metaclass lookups
no class for metaclass %p
FUTURE: reserving %p for %s
FUTURE: using %p instead of %p for %s
%.2f ms: %s
PROTOCOLS: protocol at %p is %s  (duplicate of %p)
PROTOCOLS: protocol at %p is %s
PROTOCOLS: protocol at %p is %s  
PROTOCOLS: protocol at %p is %s  (reallocated to %p)
CLASS: realizing class '%s'%s %p %p #%u
NSCF
__CF
NSConstantString
NSSimpleCString
IVARS: DEBUG: forcing ivars for class '%s' to slide (instanceStart %zu -> %zu)
IVARS: sliding ivars for class %s (superclass was %u bytes, now %u)
IVARS:    offset %u -> %u for %s (size %u, align %u)
CLASS: methodizing class '%s' %s
(meta)
CLASS: attached category %c%s(%s)
CLASS: attaching categories to class '%s' %s
_TtP
_TtC
Swift
%.*s.%.*s
_Tt%cs%zu%.*s%s
_Tt%c%zu%.*s%zu%.*s%s
pthread_rwlock_rdlock failed (%d)
pthread_rwlock_unlock failed (%d)
pthread_rwlock_wrlock failed (%d)
link error: class '%s' not found.
class `%s' not linked into application
Malloc
DYLD
NSZombiesEnabled
OBJC_
OBJC_HELP=
OBJC_PRINT_OPTIONS=
DYLD_INSERT_LIBRARIES
OBJC_DEBUG_POOL_ALLOCATION
MallocStackLogging
MallocStackLoggingNoCompact
libgmalloc
Objective-C runtime debugging. Set variable=YES to enable.
OBJC_HELP: describe available environment variables
OBJC_HELP is set
OBJC_PRINT_OPTIONS: list which options are set
OBJC_PRINT_OPTIONS is set
%s is set
REPLACED: %c[%s %s]  %s%s  (IMP was %p (%s), now %p (%s))
by category 
objc_setMultithreaded
%c[%s %s]: unrecognized selector sent to instance %p (no message forward handler is installed)
mutation detected during 'for(... in ...)'  enumeration of object %p.
OBJC_PRINT_IMAGES
log image and library names as they are loaded
OBJC_PRINT_IMAGE_TIMES
measure duration of image loading steps
OBJC_PRINT_LOAD_METHODS
log calls to class and category +load methods
OBJC_PRINT_INITIALIZE_METHODS
log calls to class +initialize methods
OBJC_PRINT_RESOLVED_METHODS
log methods created by +resolveClassMethod: and +resolveInstanceMethod:
OBJC_PRINT_CLASS_SETUP
log progress of class and category setup
OBJC_PRINT_PROTOCOL_SETUP
log progress of protocol setup
OBJC_PRINT_IVAR_SETUP
log processing of non-fragile ivars
OBJC_PRINT_VTABLE_SETUP
log processing of class vtables
OBJC_PRINT_VTABLE_IMAGES
print vtable images showing overridden methods
OBJC_PRINT_CACHE_SETUP
log processing of method caches
OBJC_PRINT_FUTURE_CLASSES
log use of future classes for toll-free bridging
OBJC_PRINT_PREOPTIMIZATION
log preoptimization courtesy of dyld shared cache
OBJC_PRINT_CXX_CTORS
log calls to C++ ctors and dtors for instance variables
OBJC_PRINT_EXCEPTIONS
log exception handling
OBJC_PRINT_EXCEPTION_THROW
log backtrace of every objc_exception_throw()
OBJC_PRINT_ALT_HANDLERS
log processing of exception alt handlers
OBJC_PRINT_REPLACED_METHODS
log methods replaced by category implementations
OBJC_PRINT_DEPRECATION_WARNINGS
warn about calls to deprecated runtime functions
OBJC_PRINT_POOL_HIGHWATER
log high-water marks for autorelease pools
OBJC_PRINT_CUSTOM_RR
log classes with un-optimized custom retain/release methods
OBJC_PRINT_CUSTOM_AWZ
log classes with un-optimized custom allocWithZone methods
OBJC_PRINT_RAW_ISA
log classes that require raw pointer isa fields
OBJC_DEBUG_UNLOAD
warn about poorly-behaving bundles when unloaded
OBJC_DEBUG_FRAGILE_SUPERCLASSES
warn about subclasses that may have been broken by subsequent changes to superclasses
OBJC_DEBUG_NIL_SYNC
warn about @synchronized(nil), which does no synchronization
OBJC_DEBUG_NONFRAGILE_IVARS
capriciously rearrange non-fragile ivars
OBJC_DEBUG_ALT_HANDLERS
record more info about bad alt handler use
OBJC_DEBUG_MISSING_POOLS
warn about autorelease with no pool in place, which may be a leak
halt when autorelease pools are popped out of order, and allow heap debuggers to track autorelease pools
OBJC_DEBUG_DUPLICATE_CLASSES
halt when multiple classes with the same name are present
OBJC_DEBUG_DONT_CRASH
halt the process by exiting instead of crashing
OBJC_DISABLE_VTABLES
disable vtable dispatch
OBJC_DISABLE_PREOPTIMIZATION
disable preoptimization courtesy of dyld shared cache
OBJC_DISABLE_TAGGED_POINTERS
disable tagged pointer optimization of NSNumber et al.
OBJC_DISABLE_NONPOINTER_ISA
disable non-pointer isa fields
OBJC_DISABLE_INITIALIZE_FORK_SAFETY
disable safety checks for +initialize after fork
initialize
resolveInstanceMethod:
resolveClassMethod:
.cxx_construct
.cxx_destruct
retain
release
autorelease
retainCount
alloc
allocWithZone:
dealloc
copy
forwardInvocation:
_tryRetain
_isDeallocating
retainWeakReference
allowsWeakReference
<null selector>
NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug
id2data fastcache is buggy
id2data cache is buggy
id2data is buggy
Object: SubtypeUntil: end of type encountered prematurely
Protocol
IMAGES: processing %u newly-mapped images...
IMAGES: loading image for %s%s%s%s%s
 (bundle)
 (replacement)
 (has class properties)
 (preoptimized)
IMAGES: processing 1 newly-unmapped image...
IMAGES: unloading image for %s%s%s
PREOPTIMIZATION: honoring preoptimized header info at %p for %s
__OBJC
vm_allocate failed
vm_deallocate failed
unknown return mode %d
vm_deallocate for retry failed.
Cannot form weak reference to instance (%p) of class %s. It is possible that this object was over-released, or is in the process of deallocation.
__weak variable at %p holds %p instead of %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.
bad weak table at %p. This may be a runtime bug or a memory error somewhere else.
Attempted to unregister unknown __weak variable at %p. This is probably incorrect use of objc_storeWeak() and objc_loadWeak(). Break on objc_weak_error to debug.
_objc_rootFinalize called with garbage collection off
+[%s %s]: unrecognized selector sent to instance %p
-[%s %s]: unrecognized selector sent to instance %p
+[NSObject instanceMethodSignatureForSelector:] not available without CoreFoundation
+[NSObject methodSignatureForSelector:] not available without CoreFoundation
-[NSObject methodSignatureForSelector:] not available without CoreFoundation
hash
TI,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
attempt to allocate object of class '%s' failed
autorelease pool page %p corrupted
  magic     0x%08x 0x%08x 0x%08x 0x%08x
  should be 0x%08x 0x%08x 0x%08x 0x%08x
  pthread   %p
  should be %p
AUTORELEASE!
MISSING POOLS: (%p) Object %p of class %s autoreleased with no pool in place - just leaking - break on objc_autoreleaseNoPool() to debug
Invalid or prematurely-freed autorelease pool %p.
Invalid or prematurely-freed autorelease pool %p. Set a breakpoint on objc_autoreleasePoolInvalid to debug. Proceeding anyway because the app is old (SDK version %hu.%hhu.%hhu). Memory errors are likely.
POOL HIGHWATER: new high water mark of %u pending releases for thread %p:
POOL HIGHWATER:     %s
##############
AUTORELEASE POOLS for thread %p
%llu releases pending.
[%p]  ................  PAGE (placeholder)
[%p]  ################  POOL (placeholder)
[%p]  ................  PAGE %s %s %s
(full)
(hot)
(cold)
[%p]  ################  POOL %p
[%p]  %#16lx  %s
Hash table corrupted. This is probably a memory error somewhere. (table at %p, buckets at %p (%zu bytes), %u buckets, %u entries, %u tombstones, data %p %p %p %p)
PREOPTIMIZATION: is DISABLED (not supported on ths platform)
retain
release
initialize
class
autorelease
load
conformsTo:
descriptionForInstanceMethod:
descriptionForClassMethod:
name
isEqual:
hash
copyWithZone:
mutableCopyWithZone:
dealloc
doesNotRecognizeSelector:
selector
description
init
_isDeallocating
_tryRetain
self
superclass
isMemberOfClass:
isKindOfClass:
isSubclassOfClass:
isAncestorOfObject:
instancesRespondToSelector:
respondsToSelector:
conformsToProtocol:
isFault
isProxy
instanceMethodForSelector:
methodForSelector:
resolveClassMethod:
resolveInstanceMethod:
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
instanceMethodSignatureForSelector:
methodSignatureForSelector:
forwardInvocation:
forwardingTargetForSelector:
debugDescription
allowsWeakReference
retainWeakReference
retainCount
alloc
allocWithZone:
zone
copy
mutableCopy
finalize
Object
__IncompleteProtocol
Protocol
NSObject
@8@0:4
v8@0:4
B12@0:4@8
^{objc_method_description=:*}12@0:4:8
r*8@0:4
I8@0:4
#8@0:4
B12@0:4#8
B12@0:4:8
B8@0:4
^?12@0:4:8
v12@0:4:8
@12@0:4:8
@16@0:4:8@12
@20@0:4:8@12@16
v12@0:4@8
Vv8@0:4
@12@0:4^{_NSZone=}8
^{_NSZone=}8@0:4
B12@0:4@"Protocol"8
@"NSString"8@0:4
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
zPLR
