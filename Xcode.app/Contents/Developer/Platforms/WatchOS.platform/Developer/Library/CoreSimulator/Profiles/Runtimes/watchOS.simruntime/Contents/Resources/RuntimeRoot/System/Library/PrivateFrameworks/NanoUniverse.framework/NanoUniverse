Nl=!
?@(#)PROGRAM:NanoUniverse  PROJECT:NanoTimeKit-1
init
collectionType
position
_updateCamera
_updatePositionFromAngle
date:toRotation:toAngle:toLight:toDistance:toRadius:
orbit
alloc
initWithDate:body:
longitude
calculateGeocentricDirectionForSunX:Y:Z:date:
alCity
latitude
setCenterCoordinate:animated:
initWithAnimatable:value:key:
addAnimation:
removeAllAnimationsFor:withKeys:
focus
isAnimating:forKeys:
spheroidOfType:
homeCoordinate
setCamera:target:up:roll:
setCenterCoordinate:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
description
debugDescription
animatedFloatForKey:
setAnimatedFloat:forKey:
setHomeCoordinate:
centerCoordinate
initWithScene:parent:type:
setDistanceScale:
date:toCameraPosition:toCameraTarget:
updateSunLocationForDate:
centerOnCity:
setCenter:
.cxx_destruct
type
parent
distance
setDistance:
distanceScale
angle
setAngle:
rotation
setRotation:
opacity
setOpacity:
colorize
setColorize:
radius
radiusScale
setRadiusScale:
light
programType
spriteType
setSpriteType:
isVisible
setVisible:
isFacing
setFacing:
_scene
_visible
_facing
_type
_parent
_distance
_distanceScale
_angle
_rotation
_opacity
_radius
_radiusScale
_programType
_spriteType
_light
_colorize
_position
_homeCoordinate
_centerCoordinate
addObject:
setSnap:
setDate:
date
countByEnumeratingWithState:objects:count:
frameInterval
update:
indexOfObject:
addIndex:
observer
universeAnimationFinished:
count
removeObjectsAtIndexes:
animatable
removeAnimation:
removeObject:
initWithAnimatable:from:to:key:
updateSunLocationForDate:animated:
initWithSphereoids:currentDateBlock:
snap
acceptableFrameInterval
updateSunLocation
updateFromDateIfNeeded
isUpdatable
setUpdatable:
spheroids
target
setFocus:
setOrbit:
roll
setRoll:
minFrameInterval
setMinFrameInterval:
backgroundType
setBackgroundType:
projectionType
setProjectionType:
setCollectionType:
currentDateBlock
setCurrentDateBlock:
yearsSince1970
_spheroids
_snap
_animations
_date
_currentDateBlock
_isUpdateNeeded
_isUpdatable
_focus
_orbit
_roll
_minFrameInterval
_backgroundType
_projectionType
_collectionType
_yearsSince1970
_target
timeIntervalSince1970
initWithFrame:
sharedRenderingContext
device
quadViewWithFrame:options:
addSubview:
addQuad:
setPaused:
setDelegate:
isOpaque
setOpaque:
layoutSubviews
bounds
setFrame:
setPreferredFramesPerSecond:
isPaused
renderSynchronouslyWithImageQueueDiscard:
scene
setScene:
snapshot:size:
screenScale
snapshotInRect:scale:time:
quadViewWillDisplay:forTime:
setAnimationFrameInterval:
startAnimation
stopAnimation
snapshot
_device
_context
_quadView
_quad
sharedInstance
createVertexArray
renderWithScene:viewport:
prepare
encodeGLforSize:
_isPrepared
_vertexArray
_baseTime
initWithAnimatable:from:to:ctrl1:ctrl2:key:
initWithAnimatable:values:count:key:
startTime
setStartTime:
duration
setDuration:
delay
setDelay:
setFrameInterval:
from
setFrom:
setTo:
isRepeat
setRepeat:
function
setFunction:
setKey:
setAnimatable:
setObserver:
_ctrl1
_ctrl2
_values
_valuesCount
_prevTime
_pauseTime
_repeat
_paused
_startTime
_duration
_delay
_frameInterval
_function
_key
_animatable
_observer
_from
dictionary
numberWithInteger:
setObject:forKey:
objectForKey:
dealloc
addVertices:count:
addIndices:count:vbase:
vertices
indices
vcount
icount
_vertices
_indices
_vcount
_icount
bundleForClass:
shareGroup
initWithAPI:sharegroup:
_initPrograms
_initHemi
_initTextures
defaultCenter
_asyncDeallocInstance
addObserver:selector:notificationName:
removeObserver:notificationName:
_renderWithScene:viewport:prime:
_requireTexture:sync:
imageWithCGImage:
atlasBackingWithArt:uuid:
path
atlasBackingWithBytes:length:mmapFile:uuid:
structure
_loadTexture:
stringWithFormat:
pathForResource:ofType:
isMainThread
_deallocInstance
performSelectorOnMainThread:withObject:waitUntilDone:
_purge
_prime
prime
purge
_shareGroup
_bundle
_resources
_initalizedProgams
_initalizedHemi
_initalizedTextures
_initalized
_octahedronGeomRange
_quadGeomRange
NUSpheroid
NUAnimatable
NSObject
NURotatable
NUScene
NUView
CLKUIQuadViewDelegate
NUGLQuad
NUAnimation
_NUGeometry
NURenderer
B12@0:4@8
#8@0:4
@8@0:4
@12@0:4:8
@16@0:4:8@12
@20@0:4:8@12@16
B8@0:4
B12@0:4#8
B12@0:4:8
Vv8@0:4
I8@0:4
^{_NSZone=}8@0:4
B12@0:4@"Protocol"8
@"NSString"8@0:4
12@0:4I8
v28@0:48I24
v28@0:4{CLLocationCoordinate2D=dd}8B24
{CLLocationCoordinate2D=dd}8@0:4
v24@0:4{CLLocationCoordinate2D=dd}8
@20@0:4@8@12I16
v8@0:4
v12@0:4f8
v20@0:4@8^12^16
v32@0:4@8^f12^f16^20^f24^f28
v12@0:4@8
v16@0:4{CGPoint=ff}8
f8@0:4
8@0:4
v24@0:48
v12@0:4I8
v12@0:4B8
@"NUScene"
@"NUSpheroid"
{CLLocationCoordinate2D="latitude"d"longitude"d}
@16@0:4I8@?12
i8@0:4
B16@0:4@8I12
v16@0:4@8I12
v16@0:4@8B12
@12@0:4I8
v60@0:482440f56
v12@0:4i8
@?8@0:4
v12@0:4@?8
@"NSMutableArray"
@"NSDate"
v20@0:4@8d12
v20@0:4@"CLKUIQuadView"8d12
@24@0:4{CGRect={CGPoint=ff}{CGSize=ff}}8
@20@0:4@8{CGSize=ff}12
@"CLKDevice"
@"EAGLContext"
@"CLKUIQuadView"
@"NUGLQuad"
v16@0:4{CLKUIQuadSize=ii}8
@24@0:4@8^12i16I20
@80@0:4@812284460I76
@48@0:4@81228I44
@32@0:4@812I28
B12@0:4f8
[75]
@"<NUAnimatable>"
@"<NUAnimationObserver>"
i16@0:4r^8i12
i20@0:4r^S8i12i16
r^8@0:4
r^S8@0:4
v28@0:4@8{NUViewport=iiii}12
v32@0:4@8{NUViewport=iiii}12B28
v16@0:4I8B12
@"EAGLSharegroup"
@"NSBundle"
{NURendererResources="programs"[3{NUProgram="program"I"uniforms"[13i]}]"vertexBuffer"I"indexBuffer"I"atlasTexture"I"loadedTexturesSet"Q"priTextures"[23I]"secTextures"[23I]"dummyCubeTexture"I"dummy2dTexture"I}
{_NUGeometryRange="start"i"count"i}
hash
TI,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
homeCoordinate
T{CLLocationCoordinate2D=dd},N
centerCoordinate
type
TI,R,N,V_type
parent
T@"NUSpheroid",R,N,V_parent
distance
Tf,N,V_distance
distanceScale
Tf,N,V_distanceScale
angle
Tf,N,V_angle
rotation
Tf,N,V_rotation
opacity
Tf,N,V_opacity
colorize
T,N,V_colorize
radius
Tf,R,N,V_radius
radiusScale
Tf,N,V_radiusScale
position
T,R,N,V_position
light
T,R,N,V_light
programType
TI,R,N,V_programType
spriteType
TI,N,V_spriteType
T{CLLocationCoordinate2D=dd},N,V_homeCoordinate
T{CLLocationCoordinate2D=dd},N,V_centerCoordinate
visible
TB,N,GisVisible,V_visible
facing
TB,N,GisFacing,V_facing
target
T,R,N,V_target
T,R,N,V_up
focus
T@"NUSpheroid",&,N,V_focus
orbit
Tf,N,V_orbit
roll
Tf,N,V_roll
minFrameInterval
Ti,N,V_minFrameInterval
acceptableFrameInterval
Ti,R,N
snap
TI,D,N
backgroundType
TI,N,V_backgroundType
projectionType
TI,N,V_projectionType
collectionType
TI,N,V_collectionType
spheroids
T@"NSArray",R,N,V_spheroids
date
T@"NSDate",&,D,N
currentDateBlock
T@?,C,N,V_currentDateBlock
updatable
TB,N,GisUpdatable,V_isUpdatable
yearsSince1970
Tf,R,N,V_yearsSince1970
scene
T@"NUScene",&,N
T@"NUScene",&,N,V_scene
-[NUAnimation initWithAnimatable:values:count:key:]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/NanoTimeKit_Sim/NanoTimeKit-1138/NanoUniverse/NUAnimation.m
false
startTime
Tf,N,V_startTime
duration
Tf,N,V_duration
delay
Tf,N,V_delay
frameInterval
Ti,N,V_frameInterval
from
T,N,V_from
T,N,V_to
repeat
TB,N,GisRepeat,V_repeat
paused
TB,N,GisPaused,V_paused
function
TI,N,V_function
TI,N,V_key
animatable
T@"<NUAnimatable>",&,N,V_animatable
observer
T@"<NUAnimationObserver>",W,N,V_observer
uPrimaryTexture
uSecondaryTexture
uViewMatrix
uModelMatrix
uModelPosition
uPositionMatrix
uCloudMatrix
uLightDirection
uViewDirection
uSprite
uOpacity
uColorize
uMixer
v4@?0
NanoUniverse
nanouniverse
vertices
Tr^,R,N,V_vertices
indices
Tr^S,R,N,V_indices
vcount
Ti,R,N,V_vcount
icount
Ti,R,N,V_icount
c%dd
c%dn
@"NSDate"4@?0
shareGroup
T@"EAGLSharegroup",R,N,V_shareGroup
com.apple.nu.queue
attribute vec3 aPosition; uniform highp vec3 uModelPosition; uniform highp mat4 uModelMatrix; uniform highp mat4 uViewMatrix; uniform highp mat4 uPositionMatrix; uniform mediump mat3 uCloudMatrix; varying mediump vec3 vPrimaryCoord; varying mediump vec3 vSecondaryCoord; varying highp vec3 vViewPosition; varying mediump vec3 vViewNormal; void main() { mediump vec4 lpos = vec4(aPosition, 1.0); highp vec4 wpos = uModelMatrix * lpos; vViewPosition = (uViewMatrix * wpos).xyz; highp vec3 wnrm = normalize(wpos.xyz - uModelPosition); vPrimaryCoord = lpos.xyz; vViewNormal = (uViewMatrix * vec4(wnrm, 0.0)).xyz; mediump vec3 cpos = uCloudMatrix * lpos.xyz; vSecondaryCoord = cpos; gl_Position = uPositionMatrix * lpos; }
uniform samplerCube uPrimaryTexture; uniform samplerCube uSecondaryTexture; uniform mediump vec4 uColorize; uniform mediump float uOpacity; uniform mediump vec3 uLightDirection; varying mediump vec3 vPrimaryCoord; varying mediump vec3 vSecondaryCoord; varying highp vec3 vViewPosition; varying mediump vec3 vViewNormal; void main() { mediump vec3 tc = vPrimaryCoord; mediump vec3 cc = vSecondaryCoord; mediump vec3 absTexCoord = abs(tc); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); mediump vec3 absCloudCoord = abs(cc); mediump float cmax = max(max(absCloudCoord.x, absCloudCoord.y), absCloudCoord.z); tc /= tmax; cc /= cmax; mediump vec3 albedoRGB = textureCube(uPrimaryTexture, tc).rgb; mediump float illumAmt = textureCube(uSecondaryTexture, tc).g; mediump float clouds = textureCube(uSecondaryTexture, cc).r; clouds *= clouds; mediump vec3 albedoBaseColor = albedoRGB; mediump float specularAmt = max(albedoRGB.g - 0.1, 0.0)/0.9; mediump vec3 normal = normalize(vViewNormal); mediump float NdotL = dot(normal, uLightDirection); mediump vec3 rfl = normal*(2.0*NdotL) - uLightDirection; mediump vec3 lightReflect = normalize(rfl); mediump vec3 viewDirection = -normalize(vViewPosition); mediump float specularFac = pow(max(dot(viewDirection, lightReflect), 0.0), 11.0); mediump float maxNdotL0 = max(NdotL, 0.0); mediump float fresnelBase = 1.0 - abs(dot(viewDirection, normal)); mediump float fresnelFac = pow(fresnelBase, 3.0)*maxNdotL0; albedoBaseColor = mix(albedoBaseColor, vec3(0.226, 0.229, 0.581), min(fresnelFac*1.5, 1.0)*(1.0 - specularAmt*0.7)); mediump float ambient = 0.03; mediump vec3 albedo = albedoBaseColor*(maxNdotL0 + ambient) + vec3(illumAmt, illumAmt*(0.75*illumAmt + 0.25), 0.0)*max(-NdotL, 0.0) + vec3(0.226, 0.229, 0.581)*min(specularAmt*specularFac + fresnelFac, 1.0); mediump vec3 cloudDiffuse = mix(vec3(0.402, 0.402, 0.726), vec3(0.683, 0.719, 0.994), smoothstep(0.2, 0.7, clouds)); cloudDiffuse *= smoothstep(0.0, 0.5, maxNdotL0)*(1.0 - 0.02) + 0.02; cloudDiffuse = mix(cloudDiffuse, vec3(0.226, 0.229, 0.581), min(fresnelFac*5.0, 1.0)); albedo = mix(albedo, cloudDiffuse, smoothstep(0.0, 0.3, clouds)*max(1.0 - fresnelFac*2.0, 0.0)*0.95); mediump float falloff = smoothstep(0.17364817766693033, 0.17364817766693033 + 0.1, 1.0 - fresnelBase); mediump float alpha = falloff*uOpacity; gl_FragColor = vec4(albedo*alpha, alpha); }
attribute vec3 aPosition; uniform mat4 uPositionMatrix; uniform mediump vec4 uSprite; varying mediump vec2 vTexCoord; void main() { vTexCoord = uSprite.xy + (aPosition.xy*0.5+0.5)*uSprite.zw; gl_Position = uPositionMatrix * vec4(aPosition.xy, 0.0, 1); }
uniform sampler2D uPrimaryTexture; uniform mediump float uOpacity; varying mediump vec2 vTexCoord; void main() { mediump vec4 albedo = texture2D(uPrimaryTexture, vTexCoord); gl_FragColor = albedo * uOpacity; }
attribute vec3 aPosition; uniform highp vec3 uModelPosition; uniform highp mat4 uModelMatrix; uniform highp mat4 uViewMatrix; uniform highp mat4 uPositionMatrix; varying mediump vec3 vPrimaryCoord; varying highp vec3 vViewPosition; varying mediump vec3 vViewNormal; void main() { mediump vec4 lpos = vec4(aPosition, 1.0); highp vec4 wpos = uModelMatrix * lpos; vViewPosition = (uViewMatrix * wpos).xyz; highp vec3 wnrm = normalize(wpos.xyz - uModelPosition); vPrimaryCoord = lpos.xyz; vViewNormal = (uViewMatrix * vec4(wnrm, 0.0)).xyz; gl_Position = uPositionMatrix * lpos; }
uniform samplerCube uPrimaryTexture; uniform samplerCube uSecondaryTexture; uniform mediump vec4 uColorize; uniform mediump float uOpacity; uniform mediump vec3 uLightDirection; uniform highp mat4 uModelMatrix; uniform highp mat4 uViewMatrix; varying mediump vec3 vPrimaryCoord; varying mediump vec3 vSecondaryCoord; varying highp vec3 vViewPosition; varying mediump vec3 vViewNormal; void main() { mediump vec3 tc = vPrimaryCoord; mediump vec3 absTexCoord = abs(tc); mediump float tmax = max(max(absTexCoord.x, absTexCoord.y), absTexCoord.z); tc /= tmax; mediump vec3 albedoRGB = textureCube(uPrimaryTexture, tc).rgb; mediump vec3 normalRGB = textureCube(uSecondaryTexture, tc).rgb; mediump vec3 lnormal = normalize(normalRGB*2.0 - 1.0); mediump vec3 wnormal = normalize((uModelMatrix * vec4(lnormal, 0.0)).xyz); mediump vec3 vnormal = normalize(vViewNormal); mediump vec3 normal = (uViewMatrix * vec4(wnormal, 0.0)).xyz; mediump float NdotL = dot(normal, uLightDirection); mediump float RdotL = dot(vnormal, uLightDirection); mediump float inten = max(NdotL, 0.0)*smoothstep(-0.1, 0.1, RdotL); mediump vec3 viewDirection = -normalize(vViewPosition); mediump float fresnelBase = 1.0 - abs(dot(viewDirection, vnormal)); mediump vec3 albedo = albedoRGB*(inten*(1.0 - 0.04) + 0.04); albedo = mix(albedo, uColorize.rgb, uColorize.a); mediump float falloff = smoothstep(0.17364817766693033, 0.17364817766693033 + 0.1, 1.0 - fresnelBase); mediump float alpha = falloff*uOpacity; gl_FragColor = vec4(albedo*alpha, alpha); }
atlas
Program validate log:
Failed to validate program %d
Failed to compile shader:
Failed to link program %d
snapshot begin
Failed to make complete framebuffer object %x
snapshot end
_requireTexture:%lu sync:%d
_loadTexture:%lu
purge texture %d
purge texture %lu
Failed to make complete framebuffer object for warmup %x
t not at right position
v not at right position
zPLR
