clientItemVersionAnchor
domain
requestedKey
dictionaryWithObjects:forKeys:count:
requestURL
requestWithRequestURL:
setMethod:
propertyListBodyWithTransaction:
setBodyDataWithPropertyList:
setTransaction:
setIncludeDeviceGUID:
transaction
responseWithResponse:transaction:
requestForTransaction:
canonicalResponseForResponse:
length
bytes
alloc
init
appendBytes:length:
initWithCapacity:
stringWithCapacity:
appendFormat:
dataUsingEncoding:
dataWithBytes:length:
SBKStringFromDigestData:
_SBKDataByInflatingWithNoZipHeader
_SBKDataByDeflatingWithNoZipHeaderWithCompression:
SBKDataByInflatingWithNoZipHeader
SBKDataByDeflatingWithNoZipHeader
SBKDataByInflatingWithGZip
SBKDataByDeflatingWithGZip
SBKStringByMD5HashingString:
storeBookkeeperPreferences
objectForKey:withDefaultValue:
unarchiveObjectWithData:
description
date
dateWithTimeIntervalSinceReferenceDate:
stringWithFormat:
encodeObject:forKey:
encodeDouble:forKey:
encodeInteger:forKey:
decodeIntegerForKey:
decodeObjectForKey:
mutableCopy
removeAllObjects
setValuesForKeysWithDictionary:
accessTransactionClampsWithBlock:
decodeDoubleForKey:
pendingUserDefaultArchivedData
archivedDataWithRootObject:
setPendingUserDefaultArchivedData:
setObject:forKey:
transactionClamps
class
isKindOfClass:
_canScheduleTransactionBasedOfNetworkingBlocked:error:
_canScheduleTransactionBasedOnBackOff:error:
_canScheduleTransactionBasedOnUserCancelledSignIn:error:
_canScheduleTransactionBasedOnAccountIdentifierCheck:error:
_canScheduleTransactionBasedOnType:error:
sharedLogger
shouldOverrideCondition:file:
logFunction:format:
clearAccountIdentifierCheckTimestamp
clearAuthenticationRequest
clearBackOff
clearNetworkingBlocked
clearUserAcceptedSyncTimestamp
clearUserCancelledSignIn
saveToUserDefaults
_keyForTransaction:
setValue:forKey:
_rightNow
setAccountIdentifierCheckTimestamp:
setAuthenticationNeededTimestamp:
authenticationNeededTimestamp
userClampErrorWithTransaction:retrySeconds:underlyingError:
setUserAcceptedSyncTimestamp:
userAcceptedSyncTimestamp
setUserCancelledSignInBackOffUntil:
timeIntervalSinceReferenceDate
logFile:lineNumber:format:
setBackOffUntil:
setNetworkingBlockedUntil:
networkingBlockedUntil
clampsKey
valueForKey:
timeIntervalSinceNow
serverClampErrorWithTransaction:retrySeconds:underlyingError:
clearTimestampForTransaction:
isNetworkingBlocked
networkingBlockedErrorWithTransaction:underlyingError:
accountIdentifierCheckTimestamp
backOffUntil
userCancelledSignInBackOffUntil
sharedClampsController
encodeWithCoder:
initWithCoder:
canScheduleTransaction:error:
reset
setTimestampForTransaction:
setAccountIdentifierCheckTimestamp
setAuthenticationRequest
hasAuthenticatedTooRecentlyForTransaction:error:
setUserAcceptedSyncTimestamp
hasUserRecentlyAcceptedSync
setUserCancelledSignIn
backOffForTimeInterval:
setNetworkingBlocked
.cxx_destruct
queue
setQueue:
setTransactionClamps:
nextUserCancelBackOffInterval
setNextUserCancelBackOffInterval:
_queue
_transactionClamps
_accountIdentifierCheckTimestamp
_authenticationNeededTimestamp
_userAcceptedSyncTimestamp
_networkingBlockedUntil
_backOffUntil
_userCancelledSignInBackOffUntil
_nextUserCancelBackOffInterval
_pendingUserDefaultArchivedData
initWithKVSKey:kvsPayload:
pairWithKVSKey:kvsPayload:
isEqual:
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
debugDescription
kvsKey
kvsPayload
timestamp
kvsValueDescription
_kvsKey
_kvsPayload
copy
setName:
setMaxConcurrentOperationCount:
initWithStoreAccount:
defaultCenter
_networkTypeChangedNotification:
sharedInstance
addObserver:selector:name:object:
removeObserver:name:object:
_onQueue_endBackgroundTask
operations
countByEnumeratingWithState:objects:count:
setDelegate:
dealloc
isEqualToString:
_onQueue_clampsController
_onQueue_processPendingTransactions
keyValueStoreDisabledErrorWithTransaction:underlyingError:
_onQueue_cancelAllPendingTransactions:
count
_onQueue_isIdle
setTransactionContext:forKey:
scheduleTransaction:
noStoreAccountErrorWithTransaction:underlyingError:
_delegateShouldScheduleTransaction:error:
_onQueue_scheduleTransaction:isRetry:
_onQueue_transactionDidFail:withError:
transactionCancelledErrorWithTransaction:underlyingError:
_onQueue_cancelTransaction:error:
transactionCancelledErrorWithTransaction:code:underlyingError:
_storeOperationDidComplete:
setCompletionBlock:
addOperation:
delegate
_onQueue_resolveError:resolution:
_onQueue_beginBackgroundTask
backgroundTaskAssertion
_endBackgroundTask
newBackgroundTaskWithExpirationHandler:debugInfo:
invalidate
cancelAllOperations
setActiveRequest:
_onQueue_transactionDidCancel:withError:
removeObject:
objectAtIndex:
_onQueue_processCurrentTransaction
_onQueue_authenticationCanProcessTransaction:error:
newRequest
shouldAuthenticate
setShouldAuthenticate:
newURLOperation
_enqueueStoreOperation:
_onQueue_canScheduleTransaction:error:
_onQueue_addPendingTransaction:
isClampError
retrySeconds
insertObject:atIndex:
addObject:
_onQueue_isEnabledForTransaction:error:
_onQueue_assertIsTransactionValid:error:
_onQueue_clampsCanScheduleTransaction:error:
isEnabled
stringWithUTF8String:
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
isAuthenticationValidForTransaction:error:
_delegateTransactionDidFinish:
_delegateTransactionDidFail:withError:
_resolveError:resolution:
_delegateTransactionDidCancel:withError:
storeGenericErrorWithTransaction:underlyingError:
_onQueue_currentTransactionDidFinish
processDataInResponse:withCompletionHandler:
response
responseWithURLResponse:responseDictionary:
activeRequest
isSuccess
saveAccountToLastSyncedDefaults
_processDataInResponse:
requestError
isUnsupportedClient
killSwitchErrorWithTransaction:underlyingError:
isGenericError
isValidationError
storeValidationErrorWithTransaction:underlyingError:
isAuthenticationError
saveAccountToLastFailedSyncDefaults
shouldAuthenticateIfNecessary
storeAccountSessionExpiredWithTransaction:underlyingError:
unknownErrorWithTransaction:underlyingError:
isTransactionCancelledError
_onQueue_performRetryErrorHandlingForError:
_onQueue_performCancelErrorHandlingForError:
_onQueue_performDefaultErrorHandlingForError:
isAccountsChangedError
transactionController:shouldScheduleTransaction:
delegateCancelledErrorWithTransaction:underlyingError:
transactionContextForKey:
isMainThread
_sendFinishedBlockForTransaction:success:cancelled:error:handledAsFinishedBlock:
transactionController:transactionDidFail:error:
transactionController:transactionDidCancel:error:
transactionController:transactionDidFinish:
needsAuthentication
_onQueue_processOperationOutput:operation:operationAuthenticated:
statusCode
code
userCancelledSignInErrorWithTransaction:underlyingError:
userEnteredWrongCredentialsErrorWithTransaction:underlyingError:
requestProperties
operation:failedWithError:
operation:updatedProgress:
operationFinished:
operationWillStart:
operation:didDiscoverContentLength:
operation:didReceiveResponse:
operation:finishedWithOutput:
operation:needNewBodyStream:
operation:processData:error:
operation:willSendRequest:
operation:sanitizedStringForString:
operation:dispositionForAuthenticationChallenge:
operation:credentialForAuthenticationChallenge:
URLCache
URLCacheID
operation:didAuthenticateWithDSID:
operation:shouldSetStoreFrontID:
initWithDomain:requestURL:
setDomain:
setRequestURL:
setEnabled:
isIdle
scheduleTransaction:withTransactionFinishedBlock:
cancelScheduledTransaction:
cancelAllTransactions
cancelAllTransactionsCancelCode:
_beginBackgroundTask
authenticationController
setAuthenticationController:
setShouldAuthenticateIfNecessary:
currentTransaction
setCurrentTransaction:
account
setAccount:
operationQueue
setOperationQueue:
pendingTransactions
setPendingTransactions:
isResolvingError
setIsResolvingError:
setBackgroundTaskAssertion:
networkTypeObserver
setNetworkTypeObserver:
conflictResolutionAttempts
setConflictResolutionAttempts:
_enabled
_shouldAuthenticateIfNecessary
_isResolvingError
_delegate
_domain
_requestURL
_authenticationController
_currentTransaction
_account
_operationQueue
_pendingTransactions
_backgroundTaskAssertion
_networkTypeObserver
_conflictResolutionAttempts
initWithTransaction:responseDictionary:response:
dictionary
array
_deserializeResponseDictionary:response:
numberWithUnsignedInteger:
objectForKey:
arrayWithObjects:count:
containsObject:
stringValue
deserializedResponseBodyWithTransaction:responseDictionary:response:
payloadDataForUpdateResponseKey:
syncAnchor
updatedKeys
conflictedKeys
deletedKeys
successfullyUpdatedKeys
successfullyDeletedKeys
responseOpEntiesByKey
setResponseOpEntiesByKey:
_transaction
_syncAnchor
_updatedKeys
_conflictedKeys
_deletedKeys
_successfullyUpdatedKeys
_successfullyDeletedKeys
_responseOpEntiesByKey
appendString:
enumerateObjectsUsingBlock:
localizedDescription
copyWithZone:
userInfo
doubleValue
isRecoverableError
isTransactionMissingInformationError
previousStoreAccountName
currentStoreAccountName
dictionaryWithObject:forKey:
errorWithDomain:code:userInfo:
keyValueStoreErrorWithCode:localizedDescription:transaction:underlyingError:
mainBundle
localizedStringForKey:value:table:
numberWithDouble:
storeLoggedOutErrorWithPreviousStoreAccountName:transaction:underlyingError:
storeAccountMismatchErrorWithPreviousStoreAccountName:currentStoreAccountName:transaction:underlyingError:
transactionMissingDomainErrorWithTransaction:underlyingError:
transactionMissingURLErrorWithTransaction:underlyingError:
transactionTimeoutErrorWithTransaction:underlyingError:
_init
copyRequestProperties
setRequestProperties:
setShouldMessageMainThread:
setQueuePriority:
responseDataProvider
setDataProvider:
setSBKRequest:
setNeedsAuthentication:
defaultStore
activeAccount
initWithAccount:
setPromptStyle:
setAllowsSilentAuthentication:
setAuthenticationContext:
authenticationContext
operationWithRequest:delegate:
SBKRequest
_shouldAuthenticate
_SBKRequest
syncTransaction
keysToUpdate
_serializableUpdateItemPayloadDictionaryForKey:
keysToDelete
_serializableDeleteItemPayloadDictionaryForKey:
_serializableConflictDetectionValue
arrayByAddingObjectsFromArray:
_needsConflictDetection
numberWithInteger:
conflictDetectionType
conflictDetectionOrdinalForKey:
longLongValue
keyValuePairForUpdatedKey:
_serializableConflictDetectionOrdinalForKey:
serializableRequestBodyPropertyList
storeAccount
uniqueIdentifier
lastSyncedAccountIdentifier
shouldForceAuthenticationForTransaction:
authenticationErrorsForTransaction:
accountName
lastSyncedAccountName
numberWithLongLong:
clearLastSyncnedAccount
lastFailedSyncAccountIdentifier
lastFailedSyncAccountName
_storeAccount
setDefaultFormatterBehavior:
setDateFormat:
stringFromDate:
numberWithInt:
integerValue
verboseLoggingEnabled
infoDictionary
processInfo
environment
setFilter:
setBool:forKey:
registerDefaultsIfKeyNotSet:registrationBlock:
_updateSettingsFromPreferences:
initWithPattern:options:error:
standardUserDefaults
stringByAppendingFormat:
boolForKey:
setRuntimeOverride:
removeObserver:
closeFile
fileExistsAtPath:
createFileAtPath:contents:attributes:
fileHandleForWritingAtPath:
runtimeOverride
lastPathComponent
stringByDeletingPathExtension
rangeOfString:options:
rangeOfFirstMatchInString:options:range:
lock
unlock
logString:
initWithFormat:arguments:
rangeOfString:
initWithFormat:
writeData:
performLoggingBlock:
stringByAppendingString:
stringByReplacingOccurrencesOfString:withString:
debugLoggingEnabled
setAuxPath:
auxPath
addRuntimeOverride:
removeRuntimeOverride:
filter
_auxPath
_fileHandle
_filter
_runtimeOverride
_pid
_procName
_runtimeOverrideRegex
_lock
pushKeyValueRequestURL
conflictItemValuePayload
conflictItemKey
_resolveConflictBetweenClientPayloadPair:andServerPayloadPair:
conflictItemVersionAnchor
domainVersion
initWithStoreBagContext:clientItemPayloadPair:clientItemVersionAnchor:
clientItemPayloadPair
requestItemPayloadPair
requestItemVersionAnchor
success
resultItemPayloadPair
resultItemVersionAnchor
resultDomainVersion
_isRechedulable
_success
_clientItemPayloadPair
_clientItemVersionAnchor
_requestItemPayloadPair
_requestItemVersionAnchor
_resultItemPayloadPair
_resultItemVersionAnchor
_resultDomainVersion
setTitle:
setMessage:
setCancelButtonTitle:
setAcceptButtonTitle:
completionHandler
setCompletionHandler:
_runAsUIAlertView
_runAsCFUserNotificationDisplayAlert
cancelButtonIndex
title
message
cancelButtonTitle
acceptButtonTitle
initWithTitle:message:delegate:cancelButtonTitle:otherButtonTitles:
show
dictionaryWithObjectsAndKeys:
initWithTitle:message:cancelButtonTitle:acceptButtonTitle:
showWithCompletionHandler:
alertView:clickedButtonAtIndex:
_title
_message
_cancelButtonTitle
_completionHandler
_acceptButtonTitle
processName
initWithPID:flags:reason:name:withHandler:
setBkProcessAssertion:
_expireBackgroundTask
addObserverForName:object:queue:usingBlock:
setExpirationObserver:
setInvalidationHandler:
_onQueueSetBkProcessAssertion:
initWithExpirationBlock:debugDescription:
bkProcessAssertion
identifier
expirationObserver
_expirationBlock
_identifier
_bkProcessAssertion
_expirationObserver
initWithExpirationHandler:debugInfo:
performExpirationHandler
_expireHandler
_debugInfo
_processAssertion
handleFailureInFunction:file:lineNumber:description:
componentsJoinedByString:
postNotificationName:object:userInfo:
numberWithBool:
_preferencesDidChange
syncRequestURL
transactionController
cancelWithError:
initWithBagContext:
scheduleTransaction:finishedBlock:
timeout
cancel
canceled
_canceled
_transactionController
sharedApplication
metadataWithItemIdentifier:keyValueStorePayload:failuresOkay:
initAsTestableItem
itemIdentifier
UTF8String
bookmarkTime
hasBeenPlayed
playCount
setItemIdentifier:
setTimestamp:
setBookmarkTime:
setHasBeenPlayed:
setPlayCount:
unsignedLongLongValue
setObject:forKeyedSubscript:
distantPast
initWithObjectsAndKeys:
allKeys
setWithArray:
enumerateValuesForProperties:usingBlock:
keyValueStoreItemIdentifierForItem:
boolValue
initForReadingWithData:
setRequiresSecureCoding:
setWithObjects:
decodeObjectOfClasses:forKey:
finishDecoding
dictionaryWithObjects:forKeys:
keyValueStorePayload
_testableMetadataItem_1
keyValueStoreItemIdentifierForUniqueStoreID:itemTitle:albumName:itemArtistName:feedURL:feedGUID:
metadataWithValuesFromDataSourceItem:
metadataWithItemIdentifier:bookmarkTime:bookmarkTimestamp:hasBeenPlayed:playCount:
metadataWithItemIdentifier:keyValueStorePayload:
_hasBeenPlayed
_itemIdentifier
_timestamp
_bookmarkTime
_playCount
setTimeStyle:
setDateStyle:
dictionaryWithCapacity:
string
absoluteString
distantFuture
setDateToFireNextTimer:
_updateAutorefreshRateSettingAndRestartTimer:
_onQueueLoadBagContextWithCompletionHandler:
mainQueue
_updateForStoreAccountsChange
initWithInitialUpdateDelay:
_onQueueStopTimer
_onQueueStartNewTimerWithTimeIntervalSinceNow:
bagLookupTask
currentTask
lookupDomainVersionTask
timer
_onQueueSuspendTimer
_automaticallySynchronizeOnBecomeActive
_onQueueResumeTimer
_onQueueUpdateTimerForActiveChanges
_automaticallySynchronizeLocalChangesOnResignActive
_onQueueSynchronizeWithAutosynchronizeMask:withCompletionBlock:
_onQueueUpdateTimerForAutomaticSyncOptionChanges
automaticSynchronizeOptions
setAutomaticSynchronizeOptions:
_onQueueSynchronizeImmediatelyWithCompletionHandler:
_onQueuePushMetadataItem:completionBlock:
_onQueuePullMetadataItemWithItemIdentifier:completionBlock:
domainDisabled
_accountForSyncing
_onQueueLoadRemoteDomainVersionWithCompletionBlock:
addTaskCompletionBlock:
initWithHandlerQueue:timeout:debugDescription:
setExpirationHandler:
setFinishedHandler:
error
invokeTaskCompletionBlocksWithBlock:
finishTaskOperationWithResult:error:
beginTaskOperation
responseDomainVersion
runWithCompletionHandler:
firstObject
removeObjectAtIndex:
_onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:
cancelType
result
postNotificationName:object:
_onQueueStartNewTimer
_onQueueRunNextPendingTaskBlock
initWithDataSource:bagContext:
synchronizeWithCompletionHandler:
initWithStoreBagContext:requestedKey:clientItemPayloadPair:clientItemVersionAnchor:
pollingIntervalInSeconds
_effectiveAutorefreshRate
_updateSettingsFromLoadedBagContext:
contextWithBagType:
URLBagForContext:
loadBagContextFromURLBag:domain:completionBlock:
floatValue
dateToFireNextTimer
isEqualToDate:
_timerFired:
dateWithTimeIntervalSinceNow:
scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
setTimer:
_timerIsStopped
_onQueueScheduleTimer
deprecated_setDataSource:
initWithDomain:dataSource:automaticSynchronizeOptions:isActive:
becomeActive
resignActive
setHasLocalChangesToSync:
hasLocalChangesToSync
setAutomaticallySynchronizeLocalChangesOnResignActive:
automaticallySynchronizeLocalChangesOnResignActive
setAutomaticallySynchronizeOnBecomeActive:
automaticallySynchronizeOnBecomeActive
synchronizeImmediatelyWithCompletionHandler:
pushMetadataItem:completionBlock:
pullMetadataItemWithItemIdentifier:completionBlock:
synchronizeImmediatelyWithCompletionBlock:
checkForAvailabilityWithCompletionBlock:
loadRemoteDomainVersionWithCompletionBlock:
loadBagContextWithCompletionBlock:
dataSource
setCurrentTask:
setLookupDomainVersionTask:
setBagLookupTask:
currentTaskRequestHandler
setCurrentTaskRequestHandler:
_isActive
_hasLocalChangesToSync
_pendingTaskBlocks
_automaticSynchronizeOptions
_initialAutosyncInterval
_pollingLimitFromBag
_autorefreshInterval
_refreshTimerActive
_accountsObserver
_prefsObserver
_dataSource
_currentTask
_lookupDomainVersionTask
_bagLookupTask
_currentTaskRequestHandler
_dateToFireNextTimer
_timer
setDataSource:
setMetadataItemsFromDataSource:
setMetadataItemsToCommitToDataSource:
setMetadataItemsToCommitToKVSStorage:
setResponseMetadataItemsToCommitToDataSource:
setResponseMetadataItemsMergedToCommitBackToKVSStorage:
setKvsController:
setDataSourceTransactionContext:
setCurrentKVSTransaction:
metadataItemsFromDataSource
responseMetadataItemsToCommitToDataSource
responseMetadataItemsMergedToCommitBackToKVSStorage
clearTransactionResponseData
cancelUniversalPlaybackPositionTransaction:
dataSourceTransactionContext
syncInProgress
setSyncInProgress:
beginTransactionWithItemsToSyncEnumerationBlock:
_shouldStop
_dataSourceCancelTransaction
metadataItemsToCommitToKVSStorage
newKVSSyncTransactionWithUpdatedMetadataItemIdentifiers:processConflicts:
currentKVSTransaction
_synchronouslyRunKVSTransaction:
_mergeMetadataItemsFromSyncResponse
metadataItemsToCommitToDataSource
objectEnumerator
nextObject
commitUniversalPlaybackPositionTransaction:domainVersion:metadataEnumerationBlock:
fatalSyncError
setCanceled:
kvsController
_signalKVSTransactionCompletion:withError:
_synchronize:
removeObjectForKey:
bagContext
lastSyncedDomainVersion
initWithStoreBagContext:syncAnchor:keysToUpdate:keysToDelete:conflictDetectionType:
setTransactionProcessor:
initWithCondition:
lockWhenCondition:beforeDate:
setFatalSyncError:
unlockWithCondition:
_signalKVSTransactionCompletion:
transaction:willProcessResponseData:
transaction:didProcessResponseData:
transaction:processUpdatedKey:data:conflict:isDirty:
_mergeConflictedItemFromSyncResponse:
transaction:processDeletedKey:isDirty:
transaction:keyValuePairForUpdatedKey:
transaction:syncAnchorForTransactionSyncAnchor:
transaction:keysForTransactionForTransactionKeysToUpdate:
transaction:keysForTransactionForTransactionKeysToDelete:
transaction:conflictDetectionTypeForTransactionDetectionType:
transaction:conflictDetectionOrdinalForKey:
overrideSyncAnchor
setOverrideSyncAnchor:
_syncOperationQueue
_syncInProgress
_kvsController
_dataSourceTransactionContext
_metadataItemsFromDataSource
_metadataItemsToCommitToDataSource
_metadataItemsToCommitToKVSStorage
_responseMetadataItemsToCommitToDataSource
_responseMetadataItemsMergedToCommitBackToKVSStorage
_currentKVSTransaction
_fatalSyncError
_overrideSyncAnchor
enumerateKeysAndObjectsUsingBlock:
_findFirstValueInBag:keyEnumerator:valueTransformer:defaultValue:completionBlock:
loadValueForKey:completionBlock:
loadWithCompletionBlock:
initWithBag:domain:
URLWithString:
enumerateRequestURLBagKeysWithBlock:
_initWithDomain:syncRequestURL:domainDisabled:
UPPDomainIdentifier
ExtrasDomainIdentifier
mutableCopyWithZone:
setPollingIntervalInSeconds:
setSyncRequestURL:
setPushKeyValueRequestURL:
pullKeyValueRequestURL
setPullKeyValueRequestURL:
pushAllKeyValueRequestURL
setPushAllKeyValueRequestURL:
pullAllKeyValueRequestURL
setPullAllKeyValueRequestURL:
setDomainDisabled:
setBag:
_domainDisabled
_pollingIntervalInSeconds
_syncRequestURL
_pushKeyValueRequestURL
_pullKeyValueRequestURL
_pushAllKeyValueRequestURL
_pullAllKeyValueRequestURL
_bag
itemValuePayload
itemKey
itemVersion
_requestedKey
responseWithResponse:
deserializeResponseBodyWithTransaction:
responseDictionary
objectForKeyedSubscript:
_domainVersion
_conflictItemValuePayload
_conflictItemKey
_conflictItemVersionAnchor
initWithTransaction:
syncResponseData
_syncResponseData
initWithSyncRequestURL:domain:syncAnchor:keysToUpdate:keysToDelete:conflictDetectionType:
type
transactionProcessor
_validateTransactionProcessor:
initWithResponseData:
enumerateKeysInResponseForTransaction:completionBlock:
_keysToUpdate
_keysToDelete
_conflictDetectionType
_transactionProcessor
_type
_processNextKey
_processUpdatedKey:isConflict:isDirty:
_processDeletedKey:isDirty:
responseData
setResponseData:
completionBlock
resolvedConflictsNeedSyncToServer
setResolvedConflictsNeedSyncToServer:
updatedKeysEnumerator
setUpdatedKeysEnumerator:
conflictedKeysEnumerator
setConflictedKeysEnumerator:
deletedKeysEnumerator
setDeletedKeysEnumerator:
_resolvedConflictsNeedSyncToServer
_responseData
_completionBlock
_updatedKeysEnumerator
_conflictedKeysEnumerator
_deletedKeysEnumerator
setCompletions:
_invalidateTimer
setCancelType:
setResult:
setError:
_onQueueFireExpirationHandlerIfNecesary
finishedHandler
expirationHandler
setTaskAssertion:
_invalidateAssertion:
completions
endTaskOperation
taskAssertion
_debugDescription
_handlerQueue
_timeoutTimer
_taskInvalidationDisabled
_timeout
_cancelType
_result
_error
_expirationHandler
_finishedHandler
_taskAssertion
_completions
loadsRemoteItemCount
responseUpdatedKeys
startTransactionWithSyncAnchor:keysToUpdate:keysToDelete:finishedBlock:
setLoadsRemoteItemCount:
responseItemCount
itemCount
setItemCount:
_loadsRemoteItemCount
_responseItemCount
_itemCount
_onQueue_clearTransactionResponseData
setResponseDomainVersion:
responseDeletedKeys
responseConflictedKeys
responseDataForResponseKey:
_overrideResponseDomainVersion
_responseUpdatedKeys
_responseDeletedKeys
_responseConflictedKeys
_responseDataByKey
initWithBufferingSize:compressionType:
writeBuffer:size:
close
data
dataByDeflatingData:
deflatedData
zstream
_outputBuffer
_bufferingSize
raise:format:
initWithRequestURL:
_defaultHeaderFields
setShouldPostFooterSectionChanged:
setShouldProcessDialogs:
setShouldTriggerDownloads:
setResponseDataProvider:
_methodStringForMethod:
bodyContentEncodingType
bodyContentType
dataWithPropertyList:format:options:error:
setBodyData:
initWithURL:
setHTTPMethod:
setValue:forHTTPHeaderField:
setValue:forRequestParameter:
includeDeviceGUID
guid
setHTTPBody:
timeoutInterval
setTimeoutInterval:
acceptsGzipEncoding
_contentEncodingTypeStringForBodyContentEncodingType:
_contentTypeStringForBodyContentType:
descriptionWithoutHeaderFields
setValue:forHeaderField:
setValue:forArgument:
isConcurrent
method
bodyData
_action
_bodyData
_bodyContentType
_headers
_arguments
_method
_responseDataProvider
_concurrent
_includeDeviceGUID
allHeaderFields
MIMEType
initWithCode:headerFields:responseDictionary:MIMEType:error:
responseStatusForStatusCodeNumber:
isPuntedError
initWithURLResponse:responseDictionary:
responseCode
responseHeaderFields
consoleDescription
isRecoverable
isError
shouldFileRadar
responseWithCode:headerFields:responseDictionary:MIMEType:error:
responseStatus
_responseDictionary
_responseCode
_responseHeaderFields
_retrySeconds
_MIMEType
_responseStatus
initWithDomain:code:userInfo:
initWithStatus:isRecoverable:isError:consoleDescription:shouldFileRadar:
_isRecoverable
_isError
_shouldFileRadar
_isPuntedError
_statusCode
_consoleDescription
_bagContext
setUserInfo:
_activeRequest
_userInfo
_itemKey
_itemVersion
_itemValuePayload
domain
since-version
ERROR: unable to zip large data of size ~%.3f GB
1.2.8
deflateInit2() failed: %s
deflate() failed: %s
%02x
SBKSyncClamps
v8@?0
Current Date = %@,
accountIdentifierCheckTimestamp = %@,
authenticationNeededTimestamp = %@,
userAcceptedSyncTimestamp = %@,
networkingBlockedUntil = %@,
backOffUntil= %@,
userCancelledSignInBackOffUntil = %@
SBKTransactionClamps
SBAccountIdentifierCheckTimestamp
SBKAuthenticationNeededTimestamp
SBKUserAcceptedSyncTimestamp
SBKNetworkingBlockedUntil
SBKUserCancelledSignInBackOffUntil
Version
SBKVersion
v16@?0@"NSMutableDictionary"8
SBK_KVSTORE_CLAMPS_LOG
-[SBKStoreClampsController reset]
Reseting Clamps
-[SBKStoreClampsController hasAuthenticatedTooRecentlyForTransaction:error:]
Drop transaction: %@ -- Too soon since last authentication: %f [%fs]
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKStoreClampsController.m
[StoreBookkeeper] SBKStoreClampsController - will avoid presenting authentication for %02llu:%02llu:%2f
-[SBKStoreClampsController _canScheduleTransactionBasedOnType:error:]
Drop transaction: %@ -- Interval since last request: %f [%fs]
-[SBKStoreClampsController _canScheduleTransactionBasedOfNetworkingBlocked:error:]
Drop transaction: <%p> -- Networking BlockedUntil: %@
-[SBKStoreClampsController _canScheduleTransactionBasedOnAccountIdentifierCheck:error:]
Drop transaction: <%p> -- AccountIdentifierCheck != 0
-[SBKStoreClampsController _canScheduleTransactionBasedOnBackOff:error:]
Drop transaction: <%p> -- BackOff until: %@ [%fs]
-[SBKStoreClampsController _canScheduleTransactionBasedOnUserCancelledSignIn:error:]
Drop transaction: <%p> -- userCancelledBackOff until: %@ [%fs]
queue
T@"NSObject<OS_dispatch_queue>",&,V_queue
transactionClamps
T@"NSDictionary",&,V_transactionClamps
accountIdentifierCheckTimestamp
Td,V_accountIdentifierCheckTimestamp
authenticationNeededTimestamp
Td,V_authenticationNeededTimestamp
userAcceptedSyncTimestamp
Td,V_userAcceptedSyncTimestamp
networkingBlockedUntil
Td,V_networkingBlockedUntil
backOffUntil
Td,V_backOffUntil
userCancelledSignInBackOffUntil
Td,V_userCancelledSignInBackOffUntil
nextUserCancelBackOffInterval
Td,V_nextUserCancelBackOffInterval
pendingUserDefaultArchivedData
T@"NSData",&,V_pendingUserDefaultArchivedData
%@: key=%@, payload=%@
hash
TQ,R
superclass
T#,R
description
T@"NSString",R,C
debugDescription
kvsKey
T@"NSString",R,N,V_kvsKey
kvsPayload
T@"NSData",R,N,V_kvsPayload
com.apple.SBKTransactionController
com.apple.SBKTransactionController.operationQueue
SBKTransactionFinishedBlock
[%@ _beginBackgroundTask]
SBK_KVSTORE_LOG
-[SBKTransactionController _onQueue_cancelTransaction:error:]
Cancelling transaction: %@ -- isCurrentTransaction: %@
-[SBKTransactionController _onQueue_processPendingTransactions]
No Pending Transactions
Transaction In progress: %@
-[SBKTransactionController _onQueue_processCurrentTransaction]
Processing Transaction: %@
-[SBKTransactionController _onQueue_scheduleTransaction:isRetry:]
Scheduling Transaction: %@
Holding transaction %@ (due to clamps) %.2f seconds
-[SBKTransactionController _onQueue_canScheduleTransaction:error:]
Unable to schedule (due to clamps %@) transaction %@.
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKTransactionController.m
<Unknown File>
No domain specified in transaction %@!
No url specified in transaction %@!
-[SBKTransactionController _onQueue_currentTransactionDidFinish]
Transaction Finished: %@
Transaction Failed: %@ -- Error: %@
-[SBKTransactionController _onQueue_transactionDidCancel:withError:]_block_invoke
v12@?0B8
-[SBKTransactionController _onQueue_processOperationOutput:operation:operationAuthenticated:]
Not using deserialized response because it is not a dictionary as expected!
Deserialized server response: %@
Deserialized server response produced response data: %@
Generic error indicated by response responseDictionary: %@
Validation error indicated by response responseDictionary: %@
Unknown error in response: %@
Not using deserialized responseDictionary because transactions have been cancelled!
Delegate calls should be done on the main thread
transaction controllers with delegates can not use transaction finish blocks
User cancelled sign-in
User entered wrong credentials
-[SBKTransactionController operation:failedWithError:]
Operation failedWithError: %@ -- inputError = %@
-[SBKTransactionController operation:failedWithError:]_block_invoke
[StoreBookkeeper] %@.  Will suppress authentication dialogs for a while.
account
T@"SSAccount",&,V_account
operationQueue
T@"NSOperationQueue",&,V_operationQueue
pendingTransactions
T@"NSMutableArray",&,V_pendingTransactions
currentTransaction
T@"SBKTransaction",&,N,V_currentTransaction
isResolvingError
TB,V_isResolvingError
backgroundTaskAssertion
T@"SBKTaskAssertion",&,V_backgroundTaskAssertion
networkTypeObserver
T@,W,V_networkTypeObserver
conflictResolutionAttempts
Tq,V_conflictResolutionAttempts
delegate
T@"<SBKTransactionControllerDelegate>",W,V_delegate
T@"NSString",R,C,V_domain
requestURL
T@"NSURL",R,V_requestURL
enabled
TB,R,GisEnabled,V_enabled
idle
TB,R,GisIdle
authenticationController
T@"SBKStoreAuthenticationController",&,V_authenticationController
shouldAuthenticateIfNecessary
TB,V_shouldAuthenticateIfNecessary
version
rejected
put-ok
deleted-ok
peer-ops
puts
deletes
value
reason
conflicted
oversize
%@ response: syncAnchor = %@
put-oks(%@), delete-oks(%@), updatedKeys(%@) = %@
conflictedKeys(%@) = %@
deletedKeys(%@) = %@
B24@?0@"NSDictionary"8@"NSString"16
v40@?0@"NSMutableArray"8@"NSString"16@"NSString"24@?<B@?@"NSDictionary"@"NSString">32
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncResponseData.m
ERROR: server rejected %@ because the payload was too big.
responseOpEntiesByKey
T@"NSMutableDictionary",&,V_responseOpEntiesByKey
transaction
T@"SBKSyncTransaction",R,V_transaction
syncAnchor
T@"NSString",R,C,V_syncAnchor
updatedKeys
T@"NSArray",R,V_updatedKeys
conflictedKeys
T@"NSArray",R,V_conflictedKeys
deletedKeys
T@"NSArray",R,V_deletedKeys
successfullyUpdatedKeys
T@"NSArray",R,V_successfullyUpdatedKeys
successfullyDeletedKeys
T@"NSArray",R,V_successfullyDeletedKeys
v32@?0@8Q16^B24
SBKStoreErrorDomain
SBKStoreErrorUserInfoKeyCurrentStoreAccountName
SBKStoreErrorUserInfoKeyPreviousStoreAccountName
SBKStoreErrorUserInfoKeyRetrySeconds
<%@:%p> "%@"
T@"SBKTransaction",&,V_transaction
isAuthenticationError
TB,R
isAccountsChangedError
isRecoverableError
isClampError
isTransactionCancelledError
isTransactionMissingInformationError
previousStoreAccountName
currentStoreAccountName
retrySeconds
Td,R
SBKTransactionErorGeneric: An unknown server error occurred. (underlyingError = %@) 
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorStoreAccountLoggedOut
SBKStoreErrorStoreAccountMismatch
SBKStoreErrorCodeGeneric: An unspecified server-side error was encountered (underlyingError = %@).
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorCodeGeneric: Request Invalid: It's likely that there is something wrong with the request format (underlyingError = %@).
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorUserClamp
SBKStoreErrorServerClamp
SBKStoreErrorCodeUnknown
Error Code = %@ (%d)
SBKStoreErrorCodeGenericValidationError
SBKStoreErrorCodeGenericBookkeeperServiceError
SBKStoreErrorCodeAuthenticationError
SBKStoreErrorCodeNoStoreAccount
SBKStoreErrorCodeStoreAccountLoggedOut
SBKStoreErrorCodeStoreAccountMismatch
SBKStoreErrorCodeStoreAccountSessionExpired
SBKStoreErrorCodeStoreAccountUserCancelSignIn
SBKStoreErrorCodeStoreAccountUserCredentials
SBKStoreErrorCodeGeneric
SBKStoreErrorCodeValidation
SBKStoreErrorCodeAuthenticationClamp
SBKStoreErrorCodeServerClamp
SBKStoreErrorCodeUserClamp
SBKStoreErrorCodeNetworkingBlocked
SBKStoreErrorCodeKillSwitch
SBKStoreErrorCodeDisabled
SBKStoreErrorCodeKeyBagKillSwitch
SBKStoreErrorCodeKeyBagLoadFailure
SBKStoreErrorCodeMissingURL
SBKStoreErrorCodeMissingDomain
SBKStoreErrorCodeCancelled
SBKStoreErrorCodeDelegateCancelled
SBKStoreErrorCodeTimeout
Error Code = %lld
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKTransactionURLOperation.m
Use +operationWithRequest:delegate:
SBK_REQUEST_LOG
-[SBKTransactionURLOperation setShouldAuthenticate:]
[StoreBookkeeper] setting up an authentication context - will FORCE authentication!
[StoreBookkeeper] setting up an authentication context - will NOT authenticate.
<%@: %p> (PrimaryURL: %@)
shouldAuthenticate
TB,N,V_shouldAuthenticate
SBKRequest
T@"SBKRequest",&,N,V_SBKRequest
conflict-detection
ordinal
none
delete
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncRequestData.m
WARNING: no data was provided for updated key %@, skipping just that item
SBK_KVSTORE_SERIALIZER_LOG
-[SBKSyncRequestData serializableRequestBodyPropertyList]
Sync request payload (plist): %@
%lld
SBKSync.LastAccountIdentifier
SBKSync.LastAccountName
SBKSync.SyncFailureLastAccountIdentifier
SBKSync.SyncFailureLastAccountName
SBK_STOREAUTHENTICATION_LOG
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKStoreAuthenticationController.m
-[SBKStoreAuthenticationController isAuthenticationValidForTransaction:error:]
Doesn't matter what the DISD is set to since authentication is forced for transaction: %@
-[SBKStoreAuthenticationController authenticationErrorsForTransaction:]
First Use Alert %@ [transaction = %@]
No longer logged in Use Alert %@ [transaction = %@]
AccountIdentifier mismatch: %@ vs %@ [transaction = %@]
storeAccount
T@"SSAccount",R,V_storeAccount
TB,V_shouldAuthenticate
SBKLogFilter
SBKLogRuntimeOverride
SBKLogRuntimeOverridePattern
YYYY-MM-dd HH:mm:ss.SSS
logLevel
LogDefaults.v1
LogAuthEvents
LogSyncEvents
LogSyncEventData
LogDefaults.v2
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/Utilities/SBKLogger.m
Invalid RegexPattern: %@ -- Error: %@
, %@
, SBK_UPPSTORE_LOG, SBK_SYNCHANDLER_LOG, SBK_KVSTORE_LOG, SBK_KVSTORE_CLAMPS_LOG, SBK_LOG_TASKS
, SBK_KVSTORE_DESERIALIZER_LOG, SBK_KVSTORE_SERIALIZER_LOG, SBK_KVSTORE_REQUEST_LOG
, SBK_STOREAUTHENTICATION_LOG
[%@:%d] <nil>
[%@:%d] %@
%s <nil>
%s %@
%@ %@[%d:%x] [StoreBookkeeper] %@
[StoreBookkeeper] %@
filter
T@"NSString",C,V_filter
runtimeOverride
T@"NSString",C,V_runtimeOverride
[client: payload-pair=%@, anchor=%@]
*unversioned*
[result: payload-pair=%@, anchor=%@]
[request: payload-pair=%@, anchor=%@]
%@ domain = %@, PUT: %@, %@, %@
%@-%@
clientItemPayloadPair
T@"<SBKKeyValuePayloadPair>",R,V_clientItemPayloadPair
clientItemVersionAnchor
T@"NSString",R,V_clientItemVersionAnchor
requestItemPayloadPair
T@"<SBKKeyValuePayloadPair>",R,V_requestItemPayloadPair
requestItemVersionAnchor
T@"NSString",R,V_requestItemVersionAnchor
success
TB,R,V_success
resultItemPayloadPair
T@"<SBKKeyValuePayloadPair>",R,V_resultItemPayloadPair
resultItemVersionAnchor
T@"NSString",R,V_resultItemVersionAnchor
resultDomainVersion
T@"NSString",R,V_resultDomainVersion
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/Utilities/SBKAlertDialog.m
Already displaying this alert dialog!
v12@?0i8
UIAlertView
title
T@"NSString",C,V_title
message
T@"NSString",C,V_message
cancelButtonTitle
T@"NSString",C,V_cancelButtonTitle
acceptButtonTitle
T@"NSString",C,V_acceptButtonTitle
completionHandler
T@?,C,V_completionHandler
com.apple.storebookkeeper-%@%@
v16@?0@"NSNotification"8
%@, assertionID = %llu
identifier
TQ,R,V_identifier
bkProcessAssertion
T@"BKSProcessAssertion",&,V_bkProcessAssertion
expirationObserver
T@,&,V_expirationObserver
SBK_LOG_TASKS
[SBKTaskAssertion] task created underlying assertion: %@
[SBKTaskAssertion] will invalidate underlying assertion: %@
<%@:%p; held=%@; info='%@', underlying assertion = %@>
void DebugNoteAssertionTaken(NSInteger, NSString *__strong)
<Unknown Function>
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/Utilities/SBKTaskAssertion.m
Internal Error -- assertion ID %lld is already in use (debugInfo=%@)
acquried assertion (%@) -- %@, active assertionIDs = %@
[SBKTaskAssertion] %@
( %@ )
assertionID = %@
%-2lld
**INVALID**
void DebugNoteAssertionReleased(NSInteger, NSString *__strong)
Internal Error -- released assertion ID %lld can not be found (debugInfo=%@)
released assertion (%@) -- %@, active assertionIDs = %@
SBKPreferencesDidChangeNotification
com.apple.storebookkeeper.defaultschange
_didRegister-
com.apple.storebookkeeper
B24@?0B8B12@"NSError"16
transactionController
T@"SBKTransactionController",R,N,V_transactionController
canceled
TB,R,N,V_canceled
UIApplicationBackgroundTaskWillExpireNotification
UIApplication
test-item-identifier
<SBKMetadata:%p, id=%-32s, bktm=%@, hbpl=%d, plct=%llu, timestamp=%@>
%llu
v32@?0@"NSString"8@16^B24
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/PlaybackPosition/SBKUniversalPlaybackPositionMetadata.m
ERROR: encountered invalid data while unarchiving payload for itemIdentifier: %@
pver
bktm
hbpl
plct
tstm
itemIdentifier
T@"NSString",C,V_itemIdentifier
timestamp
Td,V_timestamp
bookmarkTime
Td,V_bookmarkTime
hasBeenPlayed
TB,V_hasBeenPlayed
playCount
TQ,V_playCount
%02llu:%02llu:%.2f
no timestamp
*** 1970 timestamp ***
*** (-) 1970 timestamp ***
*** 1904 timestamp ***
*** (-) 1904 timestamp ***
*** distant past timestamp ***
(%f) %@
storeItemAdamID
subscriptionStoreItemAdamID
podcastURL
podcastGUID
artist
albumTitle
hasBeenPalyed
bookmarkMetadataTimestamp
mediaEntityType
SBKUniversalPlaybackPositionStoreDidSynchronizeNotification
9223372036854775807
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/PlaybackPosition/SBKUniversalPlaybackPositionStore.m
Invalid paramter.  no domain specified
SBKUniversalPlaybackPositionStore.queue
-[SBKUniversalPlaybackPositionStore resignActive]_block_invoke
starting synchronizing changes for resignActive
-[SBKUniversalPlaybackPositionStore resignActive]_block_invoke_2
finished synchronizing changes for resignActive
v20@?0B8@"NSError"12
v24@?0@"SBKStoreURLBagContext"8@"NSError"16
v24@?0@"NSString"8@"NSError"16
domain version lookup
-[SBKUniversalPlaybackPositionStore _onQueueLoadRemoteDomainVersionWithCompletionBlock:]
%s - %@ already in progress.  pending our completion block to be notified when it completes.
%s - beginning %@...
SBKUPPStore LookupDomainVersion
-[SBKUniversalPlaybackPositionStore _onQueueLoadRemoteDomainVersionWithCompletionBlock:]_block_invoke_2
_onQueueSync - %@ completed. %@
 ERROR = '%@'.
v32@?0@?<v@?>8@16@"NSError"24
_onQueueSync - synchronize operation beginning...
v16@?0@"NSError"8
-[SBKUniversalPlaybackPositionStore _onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:]
_onQueueRunTaskWithName %@ - short circuiting. No Active Account!
_onQueueSync - beginning %@ operation...
SBKUPPStore Synchronize
-[SBKUniversalPlaybackPositionStore _onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:]_block_invoke
-[SBKUniversalPlaybackPositionStore _onQueueSynchronizeImmediatelyWithCompletionHandler:]
_onQueueSync - synchronize already in progress.  pending our completion block to be notified when it completes.
synchronize
-[SBKUniversalPlaybackPositionStore _onQueueSynchronizeImmediatelyWithCompletionHandler:]_block_invoke
v24@?0@"SBKStoreURLBagContext"8@?<v@?B@"NSError">16
PUT value
-[SBKUniversalPlaybackPositionStore _onQueuePushMetadataItem:completionBlock:]_block_invoke
_onQueueSync - push value operation beginning...
v24@?0B8B12@"NSError"16
GET value
-[SBKUniversalPlaybackPositionStore _onQueuePullMetadataItemWithItemIdentifier:completionBlock:]_block_invoke
_onQueueSync - pull value operation beginning...
-[SBKUniversalPlaybackPositionStore _onQueueLoadBagContextWithCompletionHandler:]
_onQueueLoadBag - skipping bag load: No Active Account!
_onQueueLoadBag - load bag already in progress.  pending our completion block to be notified when it completes.
SBKUPPStore Load Bag
-[SBKUniversalPlaybackPositionStore _onQueueLoadBagContextWithCompletionHandler:]_block_invoke
_onQueueLoadBag - load bag completed.%@
_onQueueLoadBag - load bag operation beginning...
AutoSyncRateInMinutes
-[SBKUniversalPlaybackPositionStore _onQueueScheduleTimer]_block_invoke
scheduled timer date already passed.  Firing immediately
scheduling next timer update at %@
-[SBKUniversalPlaybackPositionStore _onQueueSuspendTimer]
suspending update timer
currentTask
T@"SBKAsynchronousTask",&,V_currentTask
lookupDomainVersionTask
T@"SBKAsynchronousTask",&,V_lookupDomainVersionTask
bagLookupTask
T@"SBKAsynchronousTask",&,V_bagLookupTask
currentTaskRequestHandler
T@"SBKRequestHandler",&,V_currentTaskRequestHandler
dateToFireNextTimer
T@"NSDate",&,V_dateToFireNextTimer
timer
T@"NSTimer",&,V_timer
dataSource
T@"<SBKUniversalPlaybackPositionDataSource>",R,W,V_dataSource
automaticSynchronizeOptions
hasLocalChangesToSync
%.2f seconds
%lld minutes, %lld seconds
%@ (%@ from now)
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/PlaybackPosition/SBKPlaybackPositionSyncRequestHandler.m
invalid parameters - data source is required
invalid parameters - bagContext is required
invalid parameters - bagContext.domain is required
Invalid bag.  no domain specified
SBKPlaybackPositionSyncRequestHandler.queue
SBKPlaybackPositionSyncRequestHandler.syncOperationQueue
SBK_REQUEST_HANDLING_LOG
-[SBKPlaybackPositionSyncRequestHandler _synchronize:]
Skipping synchronize: synchronization already in progress
Beginning synchronization
ERROR: will skip syncing item with no sync metadataIdentifier: %@
v16@?0@"<SBKUniversalPlaybackPositionMediaItem>"8
Gathered local %d items to sync from dataSource: %@
dataSource transaction context = %@
Performing sync with server using syncAnchor = %@
Sending merged items to server: %@
WARNING: sent resolved conflict to server, but still received conflicts in the response, saving those for next time...
Committing merged items with domainRevision: %@ to local database: %@
@"SBKUniversalPlaybackPositionMetadata"8@?0
Finished synchronization
you can not nest synchronization calls
i12@?0i8
-[SBKPlaybackPositionSyncRequestHandler _mergeMetadataItemsFromSyncResponse]
Handled items in response, will save %lld items locally and push back %lld conflict resolutions
keys to save to local db = %@
keys to push to cloud db = %@
completionConditionLock
-[SBKPlaybackPositionSyncRequestHandler _signalKVSTransactionCompletion:withError:]
transaction is being canceled.  error = %@
-[SBKPlaybackPositionSyncRequestHandler transactionController:transactionDidFail:error:]
Detected account change.  Getting remote items since version 0 instead of %@
-[SBKPlaybackPositionSyncRequestHandler transactionController:transactionDidFinish:]
kvsController
T@"SBKTransactionController",&,V_kvsController
T@"<SBKUniversalPlaybackPositionDataSource>",&,V_dataSource
dataSourceTransactionContext
T@"<SBKUniversalPlaybackPositionTransactionContext>",&,V_dataSourceTransactionContext
metadataItemsFromDataSource
T@"NSMutableDictionary",&,V_metadataItemsFromDataSource
metadataItemsToCommitToDataSource
T@"NSDictionary",&,V_metadataItemsToCommitToDataSource
metadataItemsToCommitToKVSStorage
T@"NSDictionary",&,V_metadataItemsToCommitToKVSStorage
responseMetadataItemsToCommitToDataSource
T@"NSMutableDictionary",&,V_responseMetadataItemsToCommitToDataSource
responseMetadataItemsMergedToCommitBackToKVSStorage
T@"NSMutableDictionary",&,V_responseMetadataItemsMergedToCommitBackToKVSStorage
currentKVSTransaction
T@"SBKSyncTransaction",&,V_currentKVSTransaction
syncInProgress
TB,V_syncInProgress
TB,V_canceled
fatalSyncError
T@"NSError",&,V_fatalSyncError
overrideSyncAnchor
T@"NSString",&,V_overrideSyncAnchor
syncRequestURL
kvs-sync
pullKeyValueRequestURL
kvs-get
pushKeyValueRequestURL
kvs-put
pullAllKeyValueRequestURL
kvs-getall
pushAllKeyValueRequestURL
kvs-putall
v32@?0@8@16^B24
com.apple.upp
com.apple.upp-extras
v24@?0@8@"NSError"16
key bag contents = 
v24@?0@"NSDictionary"8@"NSError"16
v32@?0@"NSString"8@16@"NSError"24
%@.%@
v56@?0@"NSString"8@16@?<@@?@>24@"NSString"32@"NSString"40@"NSDictionary"48
@16@?0@8
v24@?0@"NSString"8@"NSString"16
domainDisabled
kvs-sync-disabled
pollingIntervalInSeconds
kvs-sync-polling-interval-secs
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKStoreURLBagContext.m
Use +loadBagContextFromURLBag:domain:completionBlock:
%@(%@) = %@
%@ domain=%@, enabled=%d, requestURLs = 
T@"SSURLBag",&,V_bag
T@"NSString",C,V_domain
T@"NSURL",&,V_syncRequestURL
T@"NSURL",&,V_pushKeyValueRequestURL
T@"NSURL",&,V_pullKeyValueRequestURL
T@"NSURL",&,V_pushAllKeyValueRequestURL
T@"NSURL",&,V_pullAllKeyValueRequestURL
TB,V_domainDisabled
Td,V_pollingIntervalInSeconds
T@"NSString",C,D
T@"NSURL",&,D
TB,D
Td,D
%@ domain = %@, GET: key='%@', %@, %@
requestedKey
T@"NSString",R,C,V_requestedKey
domain-version
domainVersion
T@"NSString",R,V_domainVersion
conflictItemValuePayload
T@"NSData",R,V_conflictItemValuePayload
conflictItemKey
T@"NSString",R,V_conflictItemKey
conflictItemVersionAnchor
T@"NSString",R,V_conflictItemVersionAnchor
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/SBKRequestData.m
Subclass must implement
syncResponseData
T@"SBKSyncResponseData",R,V_syncResponseData
%lld-%@-%lld
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncTransaction.m
Invalid processor
????
SYNC: anchor=%@
, deletes=%@
, updates=%@
%@ domain = %@, %@
transactions using conflict detection must supply a conflict ordinal
WARNING: Invalid response (%@).  Skipping...
type
Tq,R,V_type
conflictDetectionType
Tq,R,V_conflictDetectionType
T@"NSURL",R,V_syncRequestURL
keysToUpdate
T@"NSArray",R,V_keysToUpdate
keysToDelete
T@"NSArray",R,V_keysToDelete
transactionProcessor
T@"<SBKSyncTransactionProcessing>",W,V_transactionProcessor
responseData
T@"SBKSyncResponseData",&,V_responseData
T@"SBKSyncTransaction",&,V_transaction
completionBlock
T@?,C,V_completionBlock
resolvedConflictsNeedSyncToServer
TB,V_resolvedConflictsNeedSyncToServer
updatedKeysEnumerator
T@"NSEnumerator",&,V_updatedKeysEnumerator
conflictedKeysEnumerator
T@"NSEnumerator",&,V_conflictedKeysEnumerator
deletedKeysEnumerator
T@"NSEnumerator",&,V_deletedKeysEnumerator
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/Utilities/SBKAsynchronousTask.m
[SBKAsynchronousTask] WARNING: task timed out: %@
%@ '%@'
[SBKAsynchronousTask] Invoking expiration handler for %@, with cancelType = %d
[SBKAsynchronousTask] beginTaskOperation %@
must have a finish and expiration handler specified
[SBKAsynchronousTask] Invoking completion handler for %@, result = %@, error = %@
result
T@,&,V_result
error
T@"NSError",&,V_error
taskAssertion
T@"SBKTaskAssertion",&,V_taskAssertion
completions
T@"NSMutableArray",&,V_completions
finishedHandler
T@?,C,V_finishedHandler
expirationHandler
T@?,C,V_expirationHandler
cancelType
Ti,V_cancelType
, itemCount = %@
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKLoadDomainVersionRequestHandler.m
-[SBKLoadDomainVersionRequestHandler runWithCompletionHandler:]_block_invoke
finished loading domain version: domainVersion = %@%@
itemCount
TQ,V_itemCount
loadsRemoteItemCount
TB,V_loadsRemoteItemCount
responseItemCount
TQ,R,V_responseItemCount
responseDomainVersion
com.apple.storebookkeeper.SBKSyncRequestHandler
@8@?0
-[SBKSyncRequestHandler transaction:willProcessResponseData:]_block_invoke
will process response with responseDomainVersion = %@
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncRequestHandler.m
subclass must supply key-value pair by implementing the SBKSyncTransactionProcessing protocol
T@"SBKSyncResponseData",R,V_responseData
T@"SBKTransactionController",R,V_transactionController
T@"NSString",C
responseUpdatedKeys
T@"NSArray",R,V_responseUpdatedKeys
responseDeletedKeys
T@"NSArray",R,V_responseDeletedKeys
responseConflictedKeys
T@"NSArray",R,V_responseConflictedKeys
ERROR: deflateEnd() failed: %s
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/SBKZipDeflateMemoryOutputStream.m
stream is already closed.
64-bit buffer writes not supported.
subclass must implement
 %@ [%@] URL = %@, shouldAuthenticate = %d, arguments = %@, headers = %@, bodyData = %@ 
 %@ [%@]
SBKRequestBodyContentType-TextXML
SBKRequestBodyContentType-EncodeGzip
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/iTMSKeyValueStorage/SBKRequest.m
Invalid bodyContentType requested for propertyList
ERROR: failed to serialize property list with error = %@
v32@?0@"NSString"8@"NSString"16^B24
guid
gzip
Accept-Encoding
Content-Encoding
Content-Type
POST
application/x-plist
text/xml; charset=UTF-8
text/plain; charset=UTF-8
T@"SBKTransaction",&,N,V_transaction
concurrent
TB,R,N,GisConcurrent,V_concurrent
method
Tq,N,V_method
timeoutInterval
Td,R,N
includeDeviceGUID
TB,N,V_includeDeviceGUID
bodyData
T@"NSData",&,N,V_bodyData
responseDataProvider
T@"ISDataProvider",&,N,V_responseDataProvider
SBKBookkeeperRequestErrorDomain
status
 [%ld]: responseDictionary = %@, (%@)
MIMEType
T@"NSString",R,N,V_MIMEType
responseStatus
T@"SBKResponseStatus",R,N,V_responseStatus
responseCode
TQ,R,N,V_responseCode
responseHeaderFields
T@"NSDictionary",R,N,V_responseHeaderFields
responseDictionary
T@"NSDictionary",R,N,V_responseDictionary
T@"NSError",R,N,V_error
statusCode
Tq,R
consoleDescription
requestError
T@"NSError",R
isSuccess
isRecoverable
isError
shouldFileRadar
isGenericError
isUnsupportedClient
isValidationError
isPuntedError
Td,R,V_retrySeconds
Success
Unknown server initialization error
The request format was invalid, or referenced an invalid domain
An unspecified server-side error (type 1) was encountered
The request requires an authenticated weak-token
The request deniend (punted - server too busy)
The request denied (too many recent request)
Unknown status
An unspecified server-side error (type 2) was encountered
The client's user agent is not supported
The putAll had a version mismatch
The domain specified in the request is locked
%@ (status = %@)%@
 Please enable logging and file a bug.
Tq,R,V_statusCode
T@"NSString",R,C,V_consoleDescription
TB,R,V_isRecoverable
TB,R,V_isError
TB,R,V_shouldFileRadar
TB,R,V_isPuntedError
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/SBKRequestHandler.m
bagContext
T@"SBKStoreURLBagContext",R,N,V_bagContext
/BuildRoot/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper-145/StoreBookkeeper/SBKTransaction.m
userInfo
T@"NSMutableDictionary",&,V_userInfo
T@"NSURL",&,V_requestURL
activeRequest
T@"SBKRequest",&,V_activeRequest
itemKey
T@"NSString",R,V_itemKey
itemVersion
T@"NSString",R,V_itemVersion
itemValuePayload
T@"NSData",R,V_itemValuePayload
base-version
SBKPullValueRequest
SBKAdditions
SBKStoreClampsController
NSCoding
SBKGenericKeyValuePair
SBKKeyValuePayloadPair
NSObject
SBKTransactionController
ISStoreURLOperationDelegate
ISURLOperationDelegate
ISOperationDelegate
SBKSyncResponseData
SBKStoreError
SBKPrivate
SBKTransactionURLOperation
SBKSyncRequestData
SBKStoreAuthenticationController
SBKLogger
SBKPushValueTransaction
SBKAlertDialog
SBKProcessAssertion
SBKTaskAssertion
SBKPreferences
SBKSimpleTransactionRequestHandler
SBKUniversalPlaybackPositionMetadata
NSCopying
SBKUniversalPlaybackPositionStore
SBKPlaybackPositionSyncRequestHandler
SBKTransactionControllerDelegate
SBKSyncTransactionProcessing
SBKStoreURLBagContext
NSMutableCopying
SBKMutableStoreURLBagContext
SBKPullValueTransaction
SBKPushValueResponse
SBKRequestData
SBKSyncResponse
SBKSyncTransaction
SBKSyncResponseDataKeyEnumerator
SBKAsynchronousTask
SBKLoadDomainVersionRequestHandler
SBKSyncRequestHandler
SBKZipDeflateMemoryOutputStream
SBKRequest
SBKResponse
SBKResponseStatus
SBKSyncRequest
SBKRequestHandler
SBKTransaction
SBKPullValueResponse
SBKPushValueRequest
@24@0:8@16
@16@0:8
@24@0:8Q16
v24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
v16@0:8
v24@0:8@?16
B32@0:8@16^@24
B16@0:8
v24@0:8d16
d16@0:8
@"NSObject<OS_dispatch_queue>"
@"NSDictionary"
@"NSData"
@32@0:8@16@24
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@"NSData"16@0:8
@32@0:8@"NSString"16@"NSData"24
@"NSString"
v32@0:8@16@24
v32@0:8@"ISOperation"16@"NSError"24
v32@0:8@"ISOperation"16@"SSOperationProgress"24
v24@0:8@"ISOperation"16
B40@0:8@16@24^@32
q32@0:8@16@24
v32@0:8@"ISURLOperation"16@"NSNumber"24
v32@0:8@"ISURLOperation"16@"NSURLResponse"24
v32@0:8@"ISURLOperation"16@24
@"NSInputStream"32@0:8@"ISURLOperation"16@"NSURLRequest"24
B40@0:8@"ISURLOperation"16@"NSMutableData"24^@32
v32@0:8@"ISURLOperation"16@"NSMutableURLRequest"24
@"NSString"32@0:8@"ISURLOperation"16@"NSString"24
q32@0:8@"ISURLOperation"16@"NSURLAuthenticationChallenge"24
@"NSURLCredential"32@0:8@"ISURLOperation"16@"NSURLAuthenticationChallenge"24
@"NSURLCache"16@0:8
B32@0:8@16@24
v32@0:8@"ISStoreURLOperation"16@"NSNumber"24
B32@0:8@"ISStoreURLOperation"16@"NSString"24
v20@0:8B16
v32@0:8@16@?24
v24@0:8q16
v28@0:8@16i24
v28@0:8@16B24
v32@0:8@16^@24
v36@0:8@16@24B32
B48@0:8@16B24B28@32^B40
q16@0:8
@"<SBKTransactionControllerDelegate>"
@"NSURL"
@"SBKStoreAuthenticationController"
@"SBKTransaction"
@"SSAccount"
@"NSOperationQueue"
@"NSMutableArray"
@"SBKTaskAssertion"
@40@0:8@16@24@32
@"SBKSyncTransaction"
@"NSArray"
@"NSMutableDictionary"
@24@0:8^{_NSZone=}16
@48@0:8q16@24@32@40
@48@0:8@16@24@32@40
@40@0:8@16q24@32
@40@0:8@16d24@32
@"SBKRequest"
v36@0:8r*16i24@28
v32@0:8r*16@24
@"NSFileHandle"
@"NSRegularExpression"
@"NSLock"
@"<SBKKeyValuePayloadPair>"
v32@0:8@16q24
@?16@0:8
@32@0:8@?16@24
@"BKSProcessAssertion"
@"SBKProcessAssertion"
v28@0:8B16@20
@"SBKTransactionController"
@64@0:8q16@24@32@40@48@56
@52@0:8@16d24d32B40Q44
@36@0:8@16@24B32
v24@0:8Q16
@44@0:8@16@24Q32B40
@24@0:8d16
v32@0:8Q16@?24
v40@0:8@16@?24@?32
@"<SBKUniversalPlaybackPositionDataSource>"
@"SBKAsynchronousTask"
@"SBKRequestHandler"
@"NSDate"
@"NSTimer"
B40@0:8@16@24@32
v40@0:8@16@24@32
B40@0:8@"SBKTransactionController"16@"SBKTransaction"24@"SBKStoreError"32
v40@0:8@"SBKTransactionController"16@"SBKTransaction"24@"SBKStoreError"32
v32@0:8@"SBKTransactionController"16@"SBKTransaction"24
B32@0:8@"SBKTransactionController"16@"SBKTransaction"24
v52@0:8@16@24@32B40^B44
v40@0:8@16@24^B32
q32@0:8@16q24
v32@0:8@"SBKSyncTransaction"16@"SBKSyncResponseData"24
v52@0:8@"SBKSyncTransaction"16@"NSString"24@"NSData"32B40^B44
v40@0:8@"SBKSyncTransaction"16@"NSString"24^B32
@"<SBKKeyValuePayloadPair>"32@0:8@"SBKSyncTransaction"16@"NSString"24
@"NSString"32@0:8@"SBKSyncTransaction"16@"NSString"24
@"NSArray"32@0:8@"SBKSyncTransaction"16@"NSArray"24
q32@0:8@"SBKSyncTransaction"16q24
@"NSNumber"32@0:8@"SBKSyncTransaction"16@"NSString"24
B24@0:8^@16
i24@0:8@16
@28@0:8@16B24
@"<SBKUniversalPlaybackPositionTransactionContext>"
@"NSError"
v56@0:8@16@24@?32@40@?48
v40@0:8@16@24@?32
@"SSURLBag"
@"SBKSyncResponseData"
@64@0:8@16@24@32@40@48q56
@56@0:8@16@24@32@40q48
@"<SBKSyncTransactionProcessing>"
v36@0:8@16B24^B28
v32@0:8@16^B24
@"NSEnumerator"
v20@0:8i16
i16@0:8
@"NSObject<OS_dispatch_source>"
v48@0:8@16@24@32@?40
@28@0:8i16Q20
B32@0:8r*16Q24
@"NSMutableData"
{z_stream_s="next_in"*"avail_in"I"total_in"Q"next_out"*"avail_out"I"total_out"Q"msg"*"state"^{internal_state}"zalloc"^?"zfree"^?"opaque"^v"data_type"i"adler"Q"reserved"Q}
@24@0:8q16
@"ISDataProvider"
@56@0:8Q16@24@32@40@48
@"SBKResponseStatus"
@44@0:8q16B24B28@32B40
@"SBKStoreURLBagContext"
