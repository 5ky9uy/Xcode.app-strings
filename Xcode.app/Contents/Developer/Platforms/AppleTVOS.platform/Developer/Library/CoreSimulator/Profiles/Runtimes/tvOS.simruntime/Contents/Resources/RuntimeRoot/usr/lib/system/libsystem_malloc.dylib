MallocStackLogging INTERNAL ERROR: interval wraps around the end of the address space: %llx, size=%llx
MallocStackLogging INTERNAL ERROR: cannot represent value:%llx or size:%llx (key is %llx)
MallocStackLogging INTERNAL ERROR: cannot represent key: %llx
MallocStackLogging INTERNAL ERROR: at least one edge must prefix-match or be unused
FATAL ERROR - invalid bitarray level
System
purgeable zone does not support guard pages
pointer %p being reallocated was not allocated
Scalable zone %p: inUse=%u(%y) flags=%d
pointer %p being freed already on death-row
*** can't vm_purgable_control(..., VM_PURGABLE_SET_STATE) for large freed block at %p
*** can't reset protection for large freed block at %p
entry for pointer %p being freed from death-row vanished
pointer %p being freed was not allocated
large entry %p reallocated is not properly in table
*** can't mvm_protect(0x0) region for new postlude guard page at %p
Non-aligned pointer %p being freed
Pointer %p to metadata being freed
Non-aligned pointer %p being freed (2)
Pointer %p to metadata being freed (2)
non-page-aligned, non-allocated pointer %p being freed
*** FATAL ERROR - comm page version mismatch.
FATAL ERROR - comm page version mismatch
at szone_check counter=%d
Scalable zone %p: inUse=%u(%y) touched=%y allocated=%y flags=%d
tiny=%u(%y) small=%u(%y) large=%u(%y) huge=%u(%y)
%lu tiny regions:
[%lu tiny regions have been vm_deallocate'd]
%lu small regions:
[%lu small regions have been vm_deallocate'd]
%ld, counter=%d
*** invariant broken: null msize ptr=%p num_small_regions=%d end=%p
%ld, counter=%d
*** invariant broken for free block %p this msize=%d
%ld, counter=%d
*** invariant broken for %p (previous %p is not a free pointer)
%ld, counter=%d
*** invariant broken for %p (next %p is not a free pointer)
%ld, counter=%d
*** invariant broken for small free %p followed by %p in region [%p-%p] (end marker incorrect) should be %d; in fact %d
small free sizes:
Magazine %d: 
%s%y[%d]; 
Small region [unknown address] was returned to the OS
*** error with %p: msize=%d
Small region [%p-%p, %y] 
Magazine=%d 
Allocations in use=%d 
 Bytes in use=%ly 
Untouched=%ly 
Advised MADV_FREE=%ly
Fragments subject to reclamation=%ly
Sizes in use: 
%d[%d] 
 (slot=%u), counter=%d
*** in-use ptr in free list slot=%u count=%d ptr=%p
 (slot=%u), counter=%d
*** unaligned ptr in free list slot=%u count=%d ptr=%p
 (slot=%u), counter=%d
*** ptr not in szone slot=%d count=%d ptr=%p
 (slot=%u), counter=%d
*** previous incorrectly set slot=%u count=%d ptr=%p
small_free_list_find_by_ptr: ptr is not free (ptr metadata !SMALL_IS_FREE), ptr=%p msize=%d metadata=0x%x
small_free_list_remove_ptr_no_clear: Internal invariant broken (next ptr of prev) for %p, prev_next=%p
small_free_list_remove_ptr_no_clear: Internal invariant broken (prev ptr of next) for %p, next_prev=%p
check: incorrect small region 
Incorrect checksum for freed object %p: probably modified after being freed.
Corrupt value: %p
double free for ptr %p
small free list metadata inconsistency (headers[previous] != previous size)
incorrect size information for %p - block header was damaged
small_free_try_depot_unmap_no_lock hash lookup failed: %p
small_free_try_depot_unmap_no_lock objects_in_use not zero: %d
check: small free list incorrect
*** FATAL ERROR - unable to allocate magazine array.
FATAL ERROR - unable to allocate magazine array
can't allocate region
*** mach_vm_map(size=%lu) failed (error code=%d)
can't unmap excess guard region
*** mach_vm_deallocate(addr=%p, size=%lu) failed (code=%d)
can't unmap excess trailing guard region
*** mach_vm_deallocate(addr=%p, size=%lu) failed (code=%d)
can't allocate region securely
*** mach_vm_map(size=%lu) failed (error code=%d)
Can't deallocate_pages region at %p
*** can't mvm_protect(%u) region for prelude guard page at %p
*** can't mvm_protect(%u) region for postlude guard page at %p
bad stack id. turning off stack logging
lite allocations exceeded limit. disabling lite mode
Failed to madvise block at blockp: %p, error: %d
Failed when changing state from MADVISING to MADVISED, block_metap = %p, blockp = %p
Failed to remadvise block at blockp: %p, error: %d
Heap corruption detected, free list is damaged at %p
*** Incorrect guard value: %lu
nano does not support guard pages
nano zone abandoned due to inability to preallocate reserved vm space.
%s value (%s) invalid - ignored.
%s value invalid: [%s] - ignored.
%s value invalid - values must sum to %d, not %d - ignored.
Nanozonev2 %p: blocks in use: %llu, size in use: %llu allocated size: %llu, allocated regions: %d, region holes: %d
Per size-class statistics:
  Class %d: 
total alloc: %llu, total frees: %llu, madvised blocks: %llu, madvise races: %llu
Current Allocation Blocks By Size Class/Context [CPU]
%d: %p; 
Region %d: base address %p
Arena #%d: base address %p. Blocks - active: %d, madvisable: %d, madvising: %d, madvised: %d, unused: %d
Size classes with allocated blocks: 
NOT USED
FULL
CAN MADVISE
MADVISING
MADVISED
    Block %d: base %p; metadata: %p, size %d (class %d) in-use: %d 
BUMP (free list empty)
next_slot (1-based) = %d
, allocated slots: %d, free slots = %d, occupancy: %d%%
MallocNanoZone
malloc_nano_max_magazines must be positive - ignored.
MallocNanoMaxMagazines
MallocNanoMaxMagazines must be positive - ignored.
Nano maximum magazines limited to number of physical CPUs [%d]
Nano maximum magazines set to %d
*** can't allocate pages: mach_vm_map(size=%lu) failed (error code=%d)
Can't deallocate_pages at %p
kern.bootargs
malloc_entropy
recording malloc and VM allocation stacks to disk using standard recorder
recording malloc (but not VM allocation) stacks to disk using standard recorder
recording VM allocation (but not malloc) stacks to disk using standard recorder
zone[0] is not the normal default zone so can't turn on lite mode.
recording malloc (and VM allocation) stacks using lite mode
recording VM allocation (but not malloc) stacks using lite mode
invalid mode %d passed to turn_on_stack_logging
malloc stack logging already enabled.
turning off recording malloc and VM allocation stacks to disk using standard recorder
turnning off recording malloc (but not VM allocation) stacks to disk using standard recorder
turning off recording VM allocation (but not malloc) stacks to disk using standard recorder
turning off recording malloc (but not VM allocation) stacks using lite mode
turning off recording VM allocation stacks using lite mode
invalid stack_logging_mode %d in turn_off_stack_logging
malloc stack logging not enabled.
DefaultPurgeableMallocZone
DefaultMallocZone
*** MallocCheckHeap: FAILED check at operation #%d
Stack for last operation where the malloc check succeeded: 
(Use 'atos' for a symbolic stack)
(Use 'atos' for a symbolic stack)
*** Recommend using 'setenv MallocCheckHeapStart %d; setenv MallocCheckHeapEach %d' to narrow down failure
*** Will sleep for %d seconds to leave time to attach
*** Will sleep once for %d seconds to leave time to attach
*** malloc_zone_unregister() failed for %p
*** error for object %p: pointer being freed was not allocated
*** error for object %p: pointer being realloc'd was not allocated
*** malloc_get_all_zones: error reading zones_address at %p
*** malloc_get_all_zones: error reading num_zones at %p
*** malloc_get_all_zones: error reading zones at %p
ptr %p in registered zone %p
ptr %p not in heap
*** OBSOLETE: malloc_singlethreaded()
*** OBSOLETE: malloc_debug()
malloc_max_magazines must be positive - ignored.
MallocStackLoggingLiteZone
MallocHelperZone
*** malloc_default_scalable_zone() failed to find 'DefaultMallocZone'
*** malloc was initialized without entropy
*** FATAL ERROR - logical_ncpus %% phys_ncpus != 0
FATAL ERROR - logical_ncpus %% phys_ncpus != 0
*** FATAL ERROR - logical_ncpus / phys_ncpus not 1, 2, or 4.
FATAL ERROR - logical_ncpus / phys_ncpus not 1, 2, or 4
Malloc
MallocGuardEdges
protecting edges
MallocDoNotProtectPrelude
... but not protecting prelude guard page
MallocDoNotProtectPostlude
... but not protecting postlude guard page
MallocStackLogging
MallocStackLoggingNoCompact
lite
vmlite
recording malloc and VM allocation stacks using lite mode
malloc
stack logging compaction turned off; size of log files on disk can increase rapidly
stack logging compaction turned off; VM can increase rapidly
MallocScribble
enabling scribbling to detect mods to free blocks
MallocErrorAbort
enabling abort() on bad malloc or free
MallocTracing
MallocCheckHeapStart
MallocCheckHeapEach
checks heap after operation #%d and each %d operations
MallocCheckHeapAbort
will abort on heap corruption
MallocCheckHeapSleep
will sleep for %d seconds on heap corruption
will sleep once for %d seconds on heap corruption
no sleep on heap corruption
MallocMaxMagazines
Maximum magazines defaulted to %d
MallocMaxMagazines must be positive - ignored.
Maximum magazines limited to number of logical CPUs (%d)
Maximum magazines set to %d
MallocRecircRetainedRegions
MallocRecircRetainedRegions must be positive - ignored.
MallocHelp
environment variables that can be set for debug:
- MallocLogFile <f> to create/append messages to file <f> instead of stderr
- MallocGuardEdges to add 2 guard pages for each large block
- MallocDoNotProtectPrelude to disable protection (when previous flag set)
- MallocDoNotProtectPostlude to disable protection (when previous flag set)
- MallocStackLogging to record all stacks.  Tools like leaks can then be applied
- MallocStackLoggingNoCompact to record all stacks.  Needed for malloc_history
- MallocStackLoggingDirectory to set location of stack logs, which can grow large; default is /tmp
- MallocScribble to detect writing on free blocks and missing initializers:
  0x55 is written upon free and 0xaa is written on allocation
- MallocCheckHeapStart <n> to start checking the heap after <n> operations
- MallocCheckHeapEach <s> to repeat the checking of the heap after <s> operations
- MallocCheckHeapSleep <t> to sleep <t> seconds on heap corruption
- MallocCheckHeapAbort <b> to abort on heap corruption if <b> is non-zero
- MallocCorruptionAbort to abort on malloc errors, but not on out of memory for 32-bit processes
  MallocCorruptionAbort is always set on 64-bit processes
- MallocErrorAbort to abort on any malloc error, including out of memory
- MallocTracing to emit kdebug trace points on malloc entry points
- MallocHelp - this help!
Attempted to register zone more than once: %p
malloc_zone_register allocation failed: %d
*** error %d
*** error %d
*** DefaultMallocError called
nano zone does not support guard pages
*** FATAL ERROR - nanozone abandoned because NCPUS > max magazines.
FATAL ERROR - nanozone abandoned because NCPUS > max magazines.
Free list walk for slot %p in _nano_block_inuse_p exceeded object count.
Free list walk in segregated_in_use_enumerator exceeded object count.
at nanozone_check counter=%d
Nanozone %p: inUse=%d(%lluKB) touched=%lluKB allocated=%lluMB
Magazine %2d(%3d) Unrealized
Magazine %2d(%3d) [%p, %3lluKB] 
 Allocations in use=%4d 
 Bytes in use=%llub 
 Untouched=%lluKB
bitarray_create(%d) in nano_print returned errno=%d.
Free list walk in nano_print exceeded object count.
Free list walk in count_free exceeded object count.
Invalid signature for pointer %p dequeued from free list
Mismatched magazine for pointer %p dequeued from free list
Invalid pointer %p dequeued from free list
Mismatched size for pointer %p dequeued from free list
Heap corruption detected, free list canary is damaged for %p
*** Incorrect guard value: %lu
Freeing unallocated pointer %p
Freeing pointer %p whose size was misdeclared
bitarray_create(%d) in nano_try_madvise returned errno=%d.
Free list walk in nano_try_madvise exceeded object count.
error creating VM region for stack logging output buffers
error while allocating stack uniquing table
error while allocating stack trace buffer
sandboxd
taskgated
MallocStackLoggingNoReaping
circular parent reference in __decrement_table_slot_refcount
MslUniquingTable
stack logging disabled due to previous errors.
allocate_pages(): virtual memory exhausted!
unable to allocate memory for stack log file path
No writeable tmp dir
.XXXXXX
stack logs being written into %s
unable to create stack logs at %s
MallocStackLoggingDirectory
MallocStackLoggingDirectory env var set to unwritable path '%s'
/tmp/
TMPDIR
stack logging postponed until after initialization.
stack-logs.
0123456789abcdef
.index
stack logs deleted from %s
unable to delete stack logs from %s
/private/var/folders
<xx>/<random>/T
process %ld no longer exists, stack logs deleted from %s
no more space in uniquing table
expandUniquingTable(): VMCopyFailed
expandUniquingTable(): mach_vm_deallocate failed. [%p]
Unable to write to stack logging file %s (%s)
Unknown file descriptor; expecting stack logging index file
unable to re-open stack logging file %s
%s%d.
%s/%s
warning: unable to map shared memory from %llx in target process %d; no stack backtraces will be available.
warning: unable to map vm_stackid table from %llx in target process %d; no VM stack backtraces will be available.
error while attempting to mach_vm_read remote stack uniquing table (%d): %s
error while attempting to mach_vm_read remote stack uniquing table contents (%d): %s
error while attempting to cache information from remote stack index file. (update_cache_for_file_streams)
insufficient data in remote stack index file; expected more records.
impossible collision! two address==address lists! (transfer_node)
reporting bad hash function! disk stack logging reader %lu bit. (transfer_node)
%ld, counter=%d
*** invariant broken for leader block %p - %d %d
%ld, counter=%d
*** invariant broken for tiny block %p this msize=%d - size is too small
%ld, counter=%d
*** invariant broken for %p this tiny msize=%d - size is too large
%ld, counter=%d
*** invariant broken for %p (next in free list %p is not a free pointer)
%ld, counter=%d
*** invariant broken for tiny free %p followed by %p in region [%p-%p] (end marker incorrect) should be %d; in fact %d
%ld, counter=%d
*** invariant broken for region end %p - %p
%ld, counter=%d
*** invariant broken for blocker block %p - %d %d
tiny free sizes:
Tiny region [unknown address] was returned to the OS
*** error at %p msize for in_use is %d
Tiny region [%p-%p, %y] 
 (slot=%u), counter=%d
*** ptr not in szone slot=%d  count=%u ptr=%p
tiny_free_list_remove_ptr: Internal invariant broken (next ptr of prev): ptr=%p, prev_next=%p
tiny_free_list_remove_ptr: Internal invariant broken (prev ptr of next): ptr=%p, next_prev=%p
tiny_free_try_depot_unmap_no_lock hash lookup failed: %p
tiny_free_try_depot_unmap_no_lock objects_in_use not zero: %d
*** check: incorrect tiny region 
Double free of object %p
check: tiny free list incorrect 
MallocDebugReport
stderr
crash
none
Unrecognized value for MallocDebugReport (%s) - using 'stderr'
MallocErrorStop
MallocErrorSleep
%s(%d,%p) malloc: 
*** set a breakpoint in malloc_error_break to debug
*** sending SIGSTOP to help debug
*** sleeping to help debug
MallocNanoMadvisePolicy
nanov2_madvise_policy
MallocNanoSingleArena
nanov2_single_arena
MallocNanoScanPolicy
nanov2_scan_policy
MallocNanoSizeClassBlocks
nanov2_size_class_blocks
immediate
warning
critical
nanov2_mode
inactive
enabled
forced
malloc_nano_max_magazines
malloc_max_magazines
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
com.apple.Libsystem.malloc
@(#)PROGRAM:libsystem_malloc  PROJECT:libmalloc-166.200.55
fffff
firstfit
