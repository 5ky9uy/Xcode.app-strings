))))#%J'
 "$&(*,.02
68:<>Tj
"%9)
&&&&&&&&&&&&
'' +7?BFJ
NRVaektx|
Frontend workarounds
Frontend features
OpenGL workarounds
D3D workarounds
D3D compiler workarounds
Vulkan workarounds
Vulkan features
Metal features
Metal Workarounds
Unknown
enabled
disabled
 __unassigned_attribute__
 -gnnnn
/9>DJPV
((&(((((
#version 300 es
precision highp float;
#define kMaxTexUnits 4
in vec4 pos;
in vec3 normal;
in vec4 color;
in float pointsize;
in vec4 texcoord0;
in vec4 texcoord1;
in vec4 texcoord2;
in vec4 texcoord3;
uniform mat4 projection;
uniform mat4 modelview;
uniform mat4 modelview_invtr;
uniform mat4 texture_matrix[kMaxTexUnits];
uniform bool enable_rescale_normal;
uniform bool enable_normalize;
// Point rasterization//////////////////////////////////////////////////////////
uniform bool point_rasterization;
uniform float point_size_min;
uniform float point_size_max;
uniform vec3 point_distance_attenuation;
// GL_OES_draw_texture uniforms/////////////////////////////////////////////////
uniform bool enable_draw_texture;
uniform vec4 draw_texture_coords;
uniform vec2 draw_texture_dims;
uniform vec4 draw_texture_normalized_crop_rect[kMaxTexUnits];
// Varyings/////////////////////////////////////////////////////////////////////
out vec4 pos_varying;
out vec3 normal_varying;
out vec4 color_varying;
flat out vec4 color_varying_flat;
out vec4 texcoord0_varying;
out vec4 texcoord1_varying;
out vec4 texcoord2_varying;
out vec4 texcoord3_varying;
const vec4 drawTextureVertices[6] = vec4[](
    vec4(0.0, 0.0, 0.0, 1.0),
    vec4(1.0, 0.0, 0.0, 1.0),
    vec4(1.0, 1.0, 0.0, 1.0),
    vec4(0.0, 0.0, 0.0, 1.0),
    vec4(1.0, 1.0, 0.0, 1.0),
    vec4(0.0, 1.0, 0.0, 1.0));
vec4 drawTexturePosition(int vertexId)
    float drawTexX = draw_texture_coords[0];
    float drawTexY = draw_texture_coords[1];
    float drawTexZ = draw_texture_coords[2];
    float drawTexW = draw_texture_dims[0];
    float drawTexH = draw_texture_dims[1];
    return vec4(drawTexX, drawTexY, drawTexZ, 0.0) +
           drawTextureVertices[vertexId] *
           vec4(drawTexW, drawTexH, 1.0, 1.0);
vec4 drawTextureTexCoord(int vertexId, int textureUnit)
    float texCropU = draw_texture_normalized_crop_rect[textureUnit].x;
    float texCropV = draw_texture_normalized_crop_rect[textureUnit].y;
    float texCropW = draw_texture_normalized_crop_rect[textureUnit].z;
    float texCropH = draw_texture_normalized_crop_rect[textureUnit].w;
    return vec4(texCropU, texCropV, 0.0, 0.0) +
           drawTextureVertices[vertexId] *
           vec4(texCropW, texCropH, 0.0, 0.0);
vec4 calcWorldPosition(vec4 posInput)
    return modelview * posInput;
vec4 calcNdcFromWorldPosition(vec4 worldPos)
    return projection * worldPos;
float calcPointSize(vec4 ndcPos)
    float dist         = length(ndcPos.z);
    float attConst     = point_distance_attenuation[0];
    float attLinear    = point_distance_attenuation[1];
    float attQuad      = point_distance_attenuation[2];
    float attPart      = attConst + attLinear * dist + attQuad * dist * dist;
    float attPointSize = pointsize / pow(attPart, 0.5);
    return clamp(attPointSize, point_size_min, point_size_max);
vec3 calcNormal(vec3 normalInput)
    mat3 mvInvTr3 = mat3(modelview_invtr);
    vec3 result   = mvInvTr3 * normalInput;
    if (enable_rescale_normal)
    {
        float rescale   = 1.0;
        vec3 rescaleVec = vec3(mvInvTr3[2]);
        float len       = length(rescaleVec);
        if (len > 0.0)
        {
            rescale = 1.0 / len;
        }
        result *= rescale;
    }
    if (enable_normalize)
    {
        result = normalize(result);
    }
    return result;
void main()
    color_varying      = color;
    color_varying_flat = color;
    if (enable_draw_texture)
    {
        int vertexId        = gl_VertexID;
        vec4 posDrawTexture = drawTexturePosition(vertexId);
        gl_Position = posDrawTexture;
        pos_varying = posDrawTexture;
        normal_varying = normal;
        gl_PointSize = pointsize;
        texcoord0_varying = drawTextureTexCoord(vertexId, 0);
        texcoord1_varying = drawTextureTexCoord(vertexId, 1);
        texcoord2_varying = drawTextureTexCoord(vertexId, 2);
        texcoord3_varying = drawTextureTexCoord(vertexId, 3);
    }
    else
    {
        vec4 worldPos = calcWorldPosition(pos);
        vec4 ndcPos   = calcNdcFromWorldPosition(worldPos);
        gl_Position = ndcPos;
        pos_varying = worldPos;
        normal_varying = calcNormal(normal);
        // Avoid calculating point size stuff
        // if we are not rendering points.
        if (point_rasterization)
        {
            gl_PointSize = calcPointSize(ndcPos);
        }
        else
        {
            gl_PointSize = pointsize;
        }
        texcoord0_varying = texture_matrix[0] * texcoord0;
        texcoord1_varying = texture_matrix[1] * texcoord1;
        texcoord2_varying = texture_matrix[2] * texcoord2;
        texcoord3_varying = texture_matrix[3] * texcoord3;
    }
#version 300 es
precision highp float;
// Defines for GL constants
#define kMaxLights                           8
#define kMaxTexUnits                         4
#define kMaxClipPlanes                       6
#define kModulate                       0x2100
#define kDecal                          0x2101
#define kCombine                        0x8570
#define kReplace                        0x1E01
#define kBlend                          0x0BE2
#define kAdd                            0x0104
#define kAddSigned                      0x8574
#define kInterpolate                    0x8575
#define kSubtract                       0x84E7
#define kDot3Rgb                        0x86AE
#define kDot3Rgba                       0x86AF
#define kAlpha                          0x1906
#define kRGB                            0x1907
#define kRGBA                           0x1908
#define kLuminance                      0x1909
#define kLuminanceAlpha                 0x190A
#define kTexture                        0x1702
#define kConstant                       0x8576
#define kPrimaryColor                   0x8577
#define kPrevious                       0x8578
#define kSrcColor                       0x0300
#define kOneMinusSrcColor               0x0301
#define kSrcAlpha                       0x0302
#define kOneMinusSrcAlpha               0x0303
#define kLinear                         0x2601
#define kExp                            0x0800
#define kExp2                           0x0801
#define kNever                          0x0200
#define kLess                           0x0201
#define kEqual                          0x0202
#define kLequal                         0x0203
#define kGreater                        0x0204
#define kNotequal                       0x0205
#define kGequal                         0x0206
#define kAlways                         0x0207
#define kZero                              0x0
#define kOne                               0x1
#define kClear                          0x1500
#define kAnd                            0x1501
#define kAnd_reverse                    0x1502
#define kCopy                           0x1503
#define kAnd_inverted                   0x1504
#define kNoop                           0x1505
#define kXor                            0x1506
#define kOr                             0x1507
#define kNor                            0x1508
#define kEquiv                          0x1509
#define kInvert                         0x150A
#define kOr_reverse                     0x150B
#define kCopy_inverted                  0x150C
#define kOr_inverted                    0x150D
#define kNand                           0x150E
#define kSet                            0x150F
// Texture units ///////////////////////////////////////////////////////////////
uniform bool enable_texture_2d[kMaxTexUnits];
uniform bool enable_texture_cube_map[kMaxTexUnits];
// These are not arrays because hw support for arrays
// of samplers is rather lacking.
uniform sampler2D tex_sampler0;
uniform samplerCube tex_cube_sampler0;
uniform sampler2D tex_sampler1;
uniform samplerCube tex_cube_sampler1;
uniform sampler2D tex_sampler2;
uniform samplerCube tex_cube_sampler2;
uniform sampler2D tex_sampler3;
uniform samplerCube tex_cube_sampler3;
uniform int texture_format[kMaxTexUnits];
uniform int texture_env_mode[kMaxTexUnits];
uniform int combine_rgb[kMaxTexUnits];
uniform int combine_alpha[kMaxTexUnits];
uniform int src0_rgb[kMaxTexUnits];
uniform int src0_alpha[kMaxTexUnits];
uniform int src1_rgb[kMaxTexUnits];
uniform int src1_alpha[kMaxTexUnits];
uniform int src2_rgb[kMaxTexUnits];
uniform int src2_alpha[kMaxTexUnits];
uniform int op0_rgb[kMaxTexUnits];
uniform int op0_alpha[kMaxTexUnits];
uniform int op1_rgb[kMaxTexUnits];
uniform int op1_alpha[kMaxTexUnits];
uniform int op2_rgb[kMaxTexUnits];
uniform int op2_alpha[kMaxTexUnits];
uniform vec4 texture_env_color[kMaxTexUnits];
uniform float texture_env_rgb_scale[kMaxTexUnits];
uniform float texture_env_alpha_scale[kMaxTexUnits];
uniform bool point_sprite_coord_replace[kMaxTexUnits];
// Vertex attributes////////////////////////////////////////////////////////////
in vec4 pos_varying;
in vec3 normal_varying;
in vec4 color_varying;
flat in vec4 color_varying_flat;
in vec4 texcoord0_varying;
in vec4 texcoord1_varying;
in vec4 texcoord2_varying;
in vec4 texcoord3_varying;
// Alpha test///////////////////////////////////////////////////////////////////
uniform bool enable_alpha_test;
uniform int alpha_func;
uniform float alpha_test_ref;
// Shading: flat shading, lighting, and materials///////////////////////////////
uniform bool shade_model_flat;
uniform bool enable_lighting;
uniform bool enable_color_material;
uniform vec4 material_ambient;
uniform vec4 material_diffuse;
uniform vec4 material_specular;
uniform vec4 material_emissive;
uniform float material_specular_exponent;
uniform vec4 light_model_scene_ambient;
uniform bool light_model_two_sided;
uniform bool light_enables[kMaxLights];
uniform vec4 light_ambients[kMaxLights];
uniform vec4 light_diffuses[kMaxLights];
uniform vec4 light_speculars[kMaxLights];
uniform vec4 light_positions[kMaxLights];
uniform vec3 light_directions[kMaxLights];
uniform float light_spotlight_exponents[kMaxLights];
uniform float light_spotlight_cutoff_angles[kMaxLights];
uniform float light_attenuation_consts[kMaxLights];
uniform float light_attenuation_linears[kMaxLights];
uniform float light_attenuation_quadratics[kMaxLights];
// Fog /////////////////////////////////////////////////////////////////////////
uniform bool enable_fog;
uniform int fog_mode;
uniform float fog_density;
uniform float fog_start;
uniform float fog_end;
uniform vec4 fog_color;
// User clip plane /////////////////////////////////////////////////////////////
uniform bool enable_clip_planes;
uniform bool clip_plane_enables[kMaxClipPlanes];
uniform vec4 clip_planes[kMaxClipPlanes];
// Point rasterization//////////////////////////////////////////////////////////
uniform bool point_rasterization;
uniform bool point_sprite_enabled;
// GL_OES_draw_texture//////////////////////////////////////////////////////////
uniform bool enable_draw_texture;
// Outgoing fragment////////////////////////////////////////////////////////////
out vec4 frag_color;
float posDot(vec3 a, vec3 b)
    return max(dot(a, b), 0.0);
vec4 doLighting(vec4 currentFragment)
    vec4 materialAmbientActual = material_ambient;
    vec4 materialDiffuseActual = material_diffuse;
    if (enable_color_material || enable_texture_2d[0] || enable_texture_cube_map[0])
    {
        materialAmbientActual = currentFragment;
        materialDiffuseActual = currentFragment;
    }
    vec4 lightingResult = material_emissive + materialAmbientActual * light_model_scene_ambient;
    for (int i = 0; i < kMaxLights; i++)
    {
        if (!light_enables[i])
            continue;
        vec4 lightAmbient  = light_ambients[i];
        vec4 lightDiffuse  = light_diffuses[i];
        vec4 lightSpecular = light_speculars[i];
        vec4 lightPos      = light_positions[i];
        vec3 lightDir      = light_directions[i];
        float attConst     = light_attenuation_consts[i];
        float attLinear    = light_attenuation_linears[i];
        float attQuadratic = light_attenuation_quadratics[i];
        float spotAngle    = light_spotlight_cutoff_angles[i];
        float spotExponent = light_spotlight_exponents[i];
        vec3 toLight;
        if (lightPos.w == 0.0)
        {
            toLight = lightPos.xyz;
        }
        else
        {
            toLight = (lightPos.xyz / lightPos.w - pos_varying.xyz);
        }
        float lightDist = length(toLight);
        vec3 h          = normalize(toLight) + vec3(0.0, 0.0, 1.0);
        float ndotL     = posDot(normal_varying, normalize(toLight));
        float ndoth     = posDot(normal_varying, normalize(h));
        float specAtt;
        if (ndotL != 0.0)
        {
            specAtt = 1.0;
        }
        else
        {
            specAtt = 0.0;
        }
        float att;
        if (lightPos.w != 0.0)
        {
            float attDenom =
                (attConst + attLinear * lightDist + attQuadratic * lightDist * lightDist);
            att = 1.0 / attDenom;
        }
        else
        {
            att = 1.0;
        }
        float spot;
        float spotAngleCos = cos(radians(spotAngle));
        vec3 toSurfaceDir  = -normalize(toLight);
        float spotDot      = posDot(toSurfaceDir, normalize(lightDir));
        if (spotAngle == 180.0 || lightPos.w == 0.0)
        {
            spot = 1.0;
        }
        else
        {
            if (spotDot < spotAngleCos)
            {
                spot = 0.0;
            }
            else
            {
                spot = pow(spotDot, spotExponent);
            }
        }
        vec4 contrib = materialAmbientActual * lightAmbient;
        contrib += ndotL * materialDiffuseActual * lightDiffuse;
        if (ndoth > 0.0 && material_specular_exponent > 0.0)
        {
            contrib += specAtt * pow(ndoth, material_specular_exponent) * material_specular *
                       lightSpecular;
        }
        else
        {
            if (ndoth > 0.0)
            {
                contrib += specAtt * material_specular * lightSpecular;
            }
        }
        contrib *= att * spot;
        lightingResult += contrib;
    }
    return lightingResult;
bool doAlphaTest(vec4 currentFragment)
    bool shouldPassAlpha = false;
    float incAlpha       = currentFragment.a;
    switch (alpha_func)
    {
        case kNever:
            shouldPassAlpha = false;
            break;
        case kLess:
            shouldPassAlpha = incAlpha < alpha_test_ref;
            break;
        case kLequal:
            shouldPassAlpha = incAlpha <= alpha_test_ref;
            break;
        case kEqual:
            shouldPassAlpha = incAlpha == alpha_test_ref;
            break;
        case kGequal:
            shouldPassAlpha = incAlpha >= alpha_test_ref;
            break;
        case kGreater:
            shouldPassAlpha = incAlpha > alpha_test_ref;
            break;
        case kNotequal:
            shouldPassAlpha = incAlpha != alpha_test_ref;
            break;
        case kAlways:
        default:
            shouldPassAlpha = true;
            break;
    }
    return shouldPassAlpha;
bool doClipPlaneTest()
    bool res = true;
    for (int i = 0; i < kMaxClipPlanes; i++)
    {
        if (clip_plane_enables[i])
        {
            float dist = dot(clip_planes[i].xyz, pos_varying.xyz) + clip_planes[i].w * pos_varying.w;
            res        = res && (dist >= 0.0);
        }
    }
    return res;
vec4 doFog(vec4 currentFragment)
    float eyeDist = -pos_varying.z / pos_varying.w;
    float f       = 1.0;
    switch (fog_mode)
    {
        case kExp:
            f = exp(-fog_density * eyeDist);
            break;
        case kExp2:
            f = exp(-(pow(fog_density * eyeDist, 2.0)));
            break;
        case kLinear:
            f = (fog_end - eyeDist) / (fog_end - fog_start);
            break;
        default:
            break;
    }
    vec4 result = f * currentFragment + (1.0 - f) * fog_color;
    return result;
bool isTextureUnitEnabled(int unit)
    return enable_texture_2d[unit] || enable_texture_cube_map[unit];
vec4 getTextureColor(int unit)
    vec4 res;
    switch (unit)
    {
        case 0:
            if (enable_texture_2d[0])
            {
                res = texture(tex_sampler0, texcoord0_varying.xy);
            }
            else if (enable_texture_cube_map[0])
            {
                res = texture(tex_cube_sampler0, texcoord0_varying.xyz);
            }
            break;
        case 1:
            if (enable_texture_2d[1])
            {
                res = texture(tex_sampler1, texcoord1_varying.xy);
            }
            else if (enable_texture_cube_map[1])
            {
                res = texture(tex_cube_sampler1, texcoord1_varying.xyz);
            }
            break;
        case 2:
            if (enable_texture_2d[2])
            {
                res = texture(tex_sampler2, texcoord2_varying.xy);
            }
            else if (enable_texture_cube_map[2])
            {
                res = texture(tex_cube_sampler2, texcoord2_varying.xyz);
            }
            break;
        case 3:
            if (enable_texture_2d[3])
            {
                res = texture(tex_sampler3, texcoord3_varying.xy);
            }
            else if (enable_texture_cube_map[3])
            {
                // TODO: Weird stuff happens
                // res = texture(tex_cube_sampler3, texcoord3_varying.xyz);
            }
            break;
        default:
            break;
    }
    return res;
vec4 getPointSpriteTextureColor(int unit)
    vec4 res;
    switch (unit)
    {
        case 0:
            if (enable_texture_2d[0])
            {
                res = texture(tex_sampler0, gl_PointCoord.xy);
            }
            break;
        case 1:
            if (enable_texture_2d[1])
            {
                res = texture(tex_sampler1, gl_PointCoord.xy);
            }
            break;
        case 2:
            if (enable_texture_2d[2])
            {
                res = texture(tex_sampler2, gl_PointCoord.xy);
            }
            break;
        case 3:
            if (enable_texture_2d[3])
            {
                res = texture(tex_sampler3, gl_PointCoord.xy);
            }
            break;
        default:
            break;
    }
    return res;
vec3 textureCombineSrcnOpnRgb(int srcnRgb,
                              int opnRgb,
                              vec4 textureEnvColor,
                              vec4 vertexColor,
                              vec4 texturePrevColor,
                              vec4 textureColor)
    vec3 res;
    vec4 op;
    switch (srcnRgb)
    {
        case kTexture:
            op = textureColor;
            break;
        case kConstant:
            op = textureEnvColor;
            break;
        case kPrimaryColor:
            op = vertexColor;
            break;
        case kPrevious:
            op = texturePrevColor;
            break;
        default:
            op = texturePrevColor;
            break;
    }
    switch (opnRgb)
    {
        case kSrcColor:
            res = op.rgb;
            break;
        case kOneMinusSrcColor:
            res = 1.0 - op.rgb;
            break;
        case kSrcAlpha:
            res = vec3(op.a, op.a, op.a);
            break;
        case kOneMinusSrcAlpha:
            res = vec3(1.0 - op.a, 1.0 - op.a, 1.0 - op.a);
            break;
        default:
            break;
    }
    return res;
float textureCombineSrcnOpnAlpha(int srcn,
                                 int opn,
                                 vec4 textureEnvColor,
                                 vec4 vertexColor,
                                 vec4 texturePrevColor,
                                 vec4 textureColor)
    float res;
    vec4 op;
    switch (srcn)
    {
        case kTexture:
            op = textureColor;
            break;
        case kConstant:
            op = textureEnvColor;
            break;
        case kPrimaryColor:
            op = vertexColor;
            break;
        case kPrevious:
            op = texturePrevColor;
            break;
        default:
            op = texturePrevColor;
            break;
    }
    switch (opn)
    {
        case kSrcAlpha:
            res = op.a;
            break;
        case kOneMinusSrcAlpha:
            res = 1.0 - op.a;
            break;
        default:
            break;
    }
    return res;
vec4 textureCombine(int combineRgb,
                    int combineAlpha,
                    int src0Rgb,
                    int src0Alpha,
                    int src1Rgb,
                    int src1Alpha,
                    int src2Rgb,
                    int src2Alpha,
                    int op0Rgb,
                    int op0Alpha,
                    int op1Rgb,
                    int op1Alpha,
                    int op2Rgb,
                    int op2Alpha,
                    vec4 textureEnvColor,
                    float rgbScale,
                    float alphaScale,
                    vec4 vertexColor,
                    vec4 texturePrevColor,
                    vec4 textureColor)
    vec3 resRgb;
    float resAlpha;
    vec3 arg0Rgb;
    float arg0Alpha;
    vec3 arg1Rgb;
    float arg1Alpha;
    vec3 arg2Rgb;
    float arg2Alpha;
    float dotVal;
    arg0Rgb   = textureCombineSrcnOpnRgb(src0Rgb, op0Rgb, textureEnvColor, vertexColor,
                                       texturePrevColor, textureColor);
    arg0Alpha = textureCombineSrcnOpnAlpha(src0Alpha, op0Alpha, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    if (combineRgb != kReplace)
    {
        arg1Rgb = textureCombineSrcnOpnRgb(src1Rgb, op1Rgb, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    }
    if (combineAlpha != kReplace)
    {
        arg1Alpha = textureCombineSrcnOpnAlpha(src1Alpha, op1Alpha, textureEnvColor, vertexColor,
                                               texturePrevColor, textureColor);
    }
    if (combineRgb == kInterpolate)
    {
        arg2Rgb = textureCombineSrcnOpnRgb(src2Rgb, op2Rgb, textureEnvColor, vertexColor,
                                           texturePrevColor, textureColor);
    }
    if (combineAlpha == kInterpolate)
    {
        arg2Alpha = textureCombineSrcnOpnAlpha(src2Alpha, op2Alpha, textureEnvColor, vertexColor,
                                               texturePrevColor, textureColor);
    }
    switch (combineRgb)
    {
        case kReplace:
            resRgb = arg0Rgb;
            break;
        case kModulate:
            resRgb = arg0Rgb * arg1Rgb;
            break;
        case kAdd:
            resRgb = arg0Rgb + arg1Rgb;
            break;
        case kAddSigned:
            resRgb = arg0Rgb + arg1Rgb - 0.5;
            break;
        case kInterpolate:
            resRgb = arg0Rgb * arg2Rgb + arg1Rgb * (1.0 - arg2Rgb);
            break;
        case kSubtract:
            resRgb = arg0Rgb - arg1Rgb;
            break;
        default:
            break;
    }
    switch (combineAlpha)
    {
        case kReplace:
            resAlpha = arg0Alpha;
            break;
        case kModulate:
            resAlpha = arg0Alpha * arg1Alpha;
            break;
        case kAdd:
            resAlpha = arg0Alpha + arg1Alpha;
            break;
        case kAddSigned:
            resAlpha = arg0Alpha + arg1Alpha - 0.5;
            break;
        case kInterpolate:
            resAlpha = arg0Alpha * arg2Alpha + arg1Alpha * (1.0 - arg2Alpha);
            break;
        case kSubtract:
            resAlpha = arg0Alpha - arg1Alpha;
            break;
        default:
            break;
    }
    if (combineRgb == kDot3Rgb || combineRgb == kDot3Rgba)
    {
        dotVal = 4.0 * dot(arg0Rgb - 0.5, arg1Rgb - 0.5);
        if (combineRgb == kDot3Rgb)
        {
            return vec4(dotVal, dotVal, dotVal, resAlpha);
        }
        else
        {
            return vec4(dotVal, dotVal, dotVal, dotVal);
        }
    }
    else
    {
        return vec4(resRgb, resAlpha);
    }
vec4 textureFunction(int unit,
                     int texFormat,
                     int envMode,
                     int combineRgb,
                     int combineAlpha,
                     int src0Rgb,
                     int src0Alpha,
                     int src1Rgb,
                     int src1Alpha,
                     int src2Rgb,
                     int src2Alpha,
                     int op0Rgb,
                     int op0Alpha,
                     int op1Rgb,
                     int op1Alpha,
                     int op2Rgb,
                     int op2Alpha,
                     vec4 textureEnvColor,
                     float rgbScale,
                     float alphaScale,
                     vec4 vertexColor,
                     vec4 texturePrevColor,
                     vec4 textureColor)
    if (!isTextureUnitEnabled(unit))
    {
        return texturePrevColor;
    }
    vec4 res;
    switch (envMode)
    {
        case kReplace:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a;
                    break;
                case kRGBA:
                case kLuminanceAlpha:
                    res.rgba = textureColor.rgba;
                    break;
                case kRGB:
                case kLuminance:
                default:
                    res.rgb = textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kModulate:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = texturePrevColor.a * textureColor.a;
                    break;
                case kRGBA:
                case kLuminanceAlpha:
                    res.rgba = texturePrevColor.rgba * textureColor.rgba;
                    break;
                case kRGB:
                case kLuminance:
                default:
                    res.rgb = texturePrevColor.rgb * textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kDecal:
            switch (texFormat)
            {
                case kRGB:
                    res.rgb = textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
                case kRGBA:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.a) +
                              textureColor.rgb * textureColor.a;
                    res.a = texturePrevColor.a;
                    break;
                case kAlpha:
                case kLuminance:
                case kLuminanceAlpha:
                default:
                    res.rgb = texturePrevColor.rgb * textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
            }
            break;
        case kBlend:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
                case kLuminance:
                case kRGB:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.rgb) +
                              textureEnvColor.rgb * textureColor.rgb;
                    res.a = texturePrevColor.a;
                    break;
                case kLuminanceAlpha:
                case kRGBA:
                default:
                    res.rgb = texturePrevColor.rgb * (1.0 - textureColor.rgb) +
                              textureEnvColor.rgb * textureColor.rgb;
                    res.a = textureColor.a * texturePrevColor.a;
                    break;
            }
            break;
        case kAdd:
            switch (texFormat)
            {
                case kAlpha:
                    res.rgb = texturePrevColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
                case kLuminance:
                case kRGB:
                    res.rgb = texturePrevColor.rgb + textureColor.rgb;
                    res.a   = texturePrevColor.a;
                    break;
                case kLuminanceAlpha:
                case kRGBA:
                default:
                    res.rgb = texturePrevColor.rgb + textureColor.rgb;
                    res.a   = textureColor.a * texturePrevColor.a;
                    break;
            }
            break;
        case kCombine:
            res = textureCombine(combineRgb, combineAlpha, src0Rgb, src0Alpha, src1Rgb, src1Alpha,
                                 src2Rgb, src2Alpha, op0Rgb, op0Alpha, op1Rgb, op1Alpha, op2Rgb,
                                 op2Alpha, textureEnvColor, rgbScale, alphaScale, vertexColor,
                                 texturePrevColor, textureColor);
            res.rgb *= rgbScale;
            res.a *= alphaScale;
            break;
        default:
            break;
    }
    return clamp(res, 0.0, 1.0);
void main()
    if (enable_clip_planes && !enable_draw_texture)
    {
        if (!doClipPlaneTest())
        {
            discard;
        }
    }
    vec4 currentFragment;
    vec4 vertex_color;
    if (shade_model_flat)
    {
        vertex_color = color_varying_flat;
    }
    else
    {
        vertex_color = color_varying;
    }
    currentFragment = vertex_color;
    vec4 texturePrevColor = currentFragment;
    for (int i = 0; i < kMaxTexUnits; i++)
    {
        vec4 textureColor;
        if (point_rasterization && point_sprite_enabled &&
            point_sprite_coord_replace[i]) {
            textureColor = getPointSpriteTextureColor(i);
        } else {
            textureColor = getTextureColor(i);
        }
        currentFragment = textureFunction(
            i, texture_format[i], texture_env_mode[i], combine_rgb[i], combine_alpha[i],
            src0_rgb[i], src0_alpha[i], src1_rgb[i], src1_alpha[i], src2_rgb[i], src2_alpha[i],
            op0_rgb[i], op0_alpha[i], op1_rgb[i], op1_alpha[i], op2_rgb[i], op2_alpha[i],
            texture_env_color[i], texture_env_rgb_scale[i], texture_env_alpha_scale[i],
            vertex_color, texturePrevColor, textureColor);
        texturePrevColor = currentFragment;
    }
    if (enable_lighting)
    {
        currentFragment = doLighting(currentFragment);
    }
    if (enable_fog)
    {
        currentFragment = doFog(currentFragment);
    }
    if (enable_alpha_test && !doAlphaTest(currentFragment))
    {
        discard;
    }
    frag_color = currentFragment;
 !"#$%&&&&'(&)&&*+,-./01&2
6789:;<=>&?@ABCD&EFGHIJKLMNOPQ
)2BJZckw
 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
ANGLE
Ga==
.M;vT
%cccccccccccc
%c@@ccc
IIqII
qqqqqqqx
qqqIIIII
26?H
.eB5
%-5=EMU]emu}
'/7?GOW_gow
!#%)+
@defined
2468
:<>@B
HJLNP
Z\^`
hjlnprtv
 __unassigned_attribute__
angleUniforms
ANGLE_METAL_PRINT_MSL_ENABLE
ANGLE_MSL_VERSION_MAJOR
ANGLE_MSL_VERSION_MINOR
ANGLE
 (E0
&+05:?DI
SX]bglqv
#(-11111111111111111111111111111111111
11111111
!$'*-
0369<?BEHKNQTWZ]`WZ]`c
lorux{~
&*.26
2222
')%%%%%+-/%%%%%135%%%%%79;
-/135
KKKKKKK"mpsKKKKKKKvKKKKKKKKKKKKKK
K%(y+.1|KKKKK
@@@@RRRR
%EGJL'
#(-27
#(-27
 !%&'()*+,-./01234
!+5<
PZ]1`cf
V<[>
EXZ_mw
TTTTTTTTTTT+.147:
777#
$')2
#&(1
#&(1
="@$
!%=Oa
FFFF-FF27<FFA
RUbo
    
%*/4L
!%04;
!%)4?JU`kw
 KO$S(W,0`48<d
 "$&(*,.024]68:<>@B]DFHJLNPR\T
Z_d{{ikm{{{{{{{oqsu{{{{{w{{{y
"!!%(+
0246
ANGLE
 "00A
ANGLEAtomicCounters
$-6cx
QZ?H
!#%')+,/2468:;=?ABDEFHJLNPRSUWYZ[]_`abceghikmnoqstvxz{}
10Dx4
68:<
#%')
$&(*
#%')
$&(*
=?AC
gg gg/
=?AC
negFlipXY
acbBufferOffsets
flipXY
clipDistancesEnabled
depthRange
angleUniforms
viewport
halfRenderArea
xfbActiveUnpaused
xfbVerticesPerDraw
xfbBufferOffsets
CEGIK
T+-/1o35q79s;u=w?ACEGy{I
SUWY[]
//////////
134///4//413
)*333*33*
))33*33
)*333**33*333**33
 " "
 "$
!$'*-03
SSSS
@EJO`
ffff  
NUBBt
ACEGIKMOQSUWY
[]_acegikm
222$$''/
3333).
OU<<//
09BK*T

NPRT
=?AC
:::::5
)/)))9
@BDF
_____Y
 **/
#4CO
OQSU
ikmo
#-3#
kqxaa
$+29@GNU\cjqx
G40,
cast
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/common/android_util.cpp
GLInternalFormatToNativePixelFormat
Unknown internalFormat: 
. Treating as 0
// BEGIN: Generated code for array bounds clamping
// END: Generated code for array bounds clamping
int webgl_int_clamp(int value, int minValue, int maxValue) { return ((value < minValue) ? minValue : ((value > maxValue) ? maxValue : value)); }
as_type
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/BlitGL.cpp
copyImageToLUMAWorkaroundTexture
mFunctions->texImage2D(ToGLenum(target), static_cast<GLint>(level), internalFormat, sourceArea.width, sourceArea.height, 0, format, readType, nullptr)
copySubImageToLUMAWorkaroundTexture
mFunctions->copyTexImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, sourceArea.x, sourceArea.y, sourceArea.width, sourceArea.height, 0)
mFunctions->texImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, gl::GetUnsizedFormat(copyTexImageFormat.internalFormat), readType, nullptr)
blitColorBufferWithShader
mFunctions->copyTexImage2D(GL_TEXTURE_2D, 0, copyTexImageFormat.internalFormat, inBoundsSource.x, inBoundsSource.y, inBoundsSource.width, inBoundsSource.height, 0)
copySubTextureCPUReadback
mFunctions->texImage2D(ToGLenum(scratchTextureType), 0, texImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
Failed to allocate host memory
generateSRGBMipmap
mFunctions->generateMipmap(ToGLenum(sourceTarget))
attribute
varying
texture2D
300 es
texture
#version 
 vec2 a_texcoord;
uniform vec2 u_scale;
uniform vec2 u_offset;
 vec2 v_texcoord;
void main()
    gl_Position = vec4((a_texcoord * 2.0) - 1.0, 0.0, 1.0);
    v_texcoord = a_texcoord * u_scale + u_offset;
usampler2D
sampler2D
samplerExternalOES
sampler2DRect
uvec4
vec4
#extension GL_OES_EGL_image_external : require
GL_ARB_texture_rectangle
#extension GL_ARB_texture_rectangle : require
outputUint
255.0
gl_FragColor
outputFloat
precision highp float;
uniform 
 u_source_texture;
uniform bool u_multiply_alpha;
uniform bool u_unmultiply_alpha;
vec2(textureSize(u_source_texture))
vec2(1.0)
    if (clamp(v_texcoord, vec2(0.0), 
) != v_texcoord)
    {
        discard;
    }
    
 color = 
(u_source_texture, v_texcoord);
    if (u_multiply_alpha)
        color.xyz = color.xyz * color.a;
    if (u_unmultiply_alpha && color.a != 0.0)
         color.xyz = color.xyz / color.a;
    color = color * 
(color);
u_source_texture
u_scale
u_offset
u_multiply_alpha
u_unmultiply_alpha
Failed to compile internal blit shader.
CheckCompileStatus
Failed to link internal blit program.
CheckLinkStatus
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/BlobCache.cpp
Failed to allocate memory for binary blob
Binary blob no longer available in cache (removed by a thread?)
GPU.ANGLE.ProgramCache.CacheResult
Failed to allocate host memory
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Buffer.cpp
bufferDataImpl
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/BufferGL.cpp
setData
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/BufferMtl.mm
setDataImpl
setSubDataImpl
_emu
int abs_emu(int x) { return x * sign(x); }
bool isnan_emu(float x) { return (x > 0.0 || x < 0.0) ? false : x != 0.0; }
bvec2 isnan_emu(vec2 x)
    bvec2 isnan;
    for (int i = 0; i < 2; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
bvec3 isnan_emu(vec3 x)
    bvec3 isnan;
    for (int i = 0; i < 3; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
bvec4 isnan_emu(vec4 x)
    bvec4 isnan;
    for (int i = 0; i < 4; i++)
    {
        isnan[i] = (x[i] > 0.0 || x[i] < 0.0) ? false : x[i] != 0.0;
    }
    return isnan;
emu_precision float atan_emu(emu_precision float y, emu_precision float x)
    if (x > 0.0) return atan(y / x);
    else if (x < 0.0 && y >= 0.0) return atan(y / x) + 3.14159265;
    else if (x < 0.0 && y < 0.0) return atan(y / x) - 3.14159265;
    else return 1.57079632 * sign(y);
emu_precision vec
 atan_emu(emu_precision vec
 y, emu_precision vec
    return vec
atan_emu(y[
], x[
uint packUnorm2x16_emu(vec2 v)
    int x = int(round(clamp(v.x, 0.0, 1.0) * 65535.0));
    int y = int(round(clamp(v.y, 0.0, 1.0) * 65535.0));
    return uint((y << 16) | (x & 0xFFFF));
vec2 unpackUnorm2x16_emu(uint u)
    float x = float(u & 0xFFFFu) / 65535.0;
    float y = float(u >> 16) / 65535.0;
    return vec2(x, y);
uint packSnorm2x16_emu(vec2 v)
    #if defined(GL_ARB_shading_language_packing)
        return packSnorm2x16(v);
    #else
        int x = int(round(clamp(v.x, -1.0, 1.0) * 32767.0));
        int y = int(round(clamp(v.y, -1.0, 1.0) * 32767.0));
        return uint((y << 16) | (x & 0xFFFF));
    #endif
#if !defined(GL_ARB_shading_language_packing)
    float fromSnorm(uint x)
    {
        int xi = (int(x) & 0x7FFF) - (int(x) & 0x8000);
        return clamp(float(xi) / 32767.0, -1.0, 1.0);
    }
#endif
vec2 unpackSnorm2x16_emu(uint u)
    #if defined(GL_ARB_shading_language_packing)
        return unpackSnorm2x16(u);
    #else
        uint y = (u >> 16);
        uint x = u;
        return vec2(fromSnorm(x), fromSnorm(y));
    #endif
#if !defined(GL_ARB_shading_language_packing)
    uint f32tof16(float val)
    {
        uint f32 = floatBitsToUint(val);
        uint f16 = 0u;
        uint sign = (f32 >> 16) & 0x8000u;
        int exponent = int((f32 >> 23) & 0xFFu) - 127;
        uint mantissa = f32 & 0x007FFFFFu;
        if (exponent == 128)
        {
            // Infinity or NaN
            // NaN bits that are masked out by 0x3FF get discarded.
            // This can turn some NaNs to infinity, but this is allowed by the spec.
            f16 = sign | (0x1Fu << 10);
            f16 |= (mantissa & 0x3FFu);
        }
        else if (exponent > 15)
        {
            // Overflow - flush to Infinity
            f16 = sign | (0x1Fu << 10);
        }
        else if (exponent > -15)
        {
            // Representable value
            exponent += 15;
            mantissa >>= 13;
            f16 = sign | uint(exponent << 10) | mantissa;
        }
        else
        {
            f16 = sign;
        }
        return f16;
    }
#endif
uint packHalf2x16_emu(vec2 v)
    #if defined(GL_ARB_shading_language_packing)
        return packHalf2x16(v);
    #else
        uint x = f32tof16(v.x);
        uint y = f32tof16(v.y);
        return (y << 16) | x;
    #endif
#if !defined(GL_ARB_shading_language_packing)
    float f16tof32(uint val)
    {
        uint sign = (val & 0x8000u) << 16;
        int exponent = int((val & 0x7C00u) >> 10);
        uint mantissa = val & 0x03FFu;
        float f32 = 0.0;
        if(exponent == 0)
        {
            if (mantissa != 0u)
            {
                const float scale = 1.0 / (1 << 24);
                f32 = scale * mantissa;
            }
        }
        else if (exponent == 31)
        {
            return uintBitsToFloat(sign | 0x7F800000u | mantissa);
        }
        else
        {
            exponent -= 15;
            float scale;
            if(exponent < 0)
            {
                // The negative unary operator is buggy on OSX.
                // Work around this by using abs instead.
                scale = 1.0 / (1 << abs(exponent));
            }
            else
            {
                scale = 1 << exponent;
            }
            float decimal = 1.0 + float(mantissa) / float(1 << 10);
            f32 = scale * decimal;
        }
        if (sign != 0u)
        {
            f32 = -f32;
        }
        return f32;
    }
#endif
vec2 unpackHalf2x16_emu(uint u)
    #if defined(GL_ARB_shading_language_packing)
        return unpackHalf2x16(u);
    #else
        uint y = (u >> 16);
        uint x = u & 0xFFFFu;
        return vec2(f16tof32(x), f16tof32(y));
    #endif
gl_InstanceID
gl_VertexID
angle_BaseInstance
Undefined function '
()' used in the following call chain:
Recursive function call in the following call chain:
 -> 
EGL_EXT_create_context_robustness
EGL_ANGLE_d3d_share_handle_client_buffer
EGL_ANGLE_d3d_texture_client_buffer
EGL_ANGLE_surface_d3d_texture_2d_share_handle
EGL_ANGLE_query_surface_pointer
EGL_ANGLE_window_fixed_size
EGL_ANGLE_keyed_mutex
EGL_ANGLE_surface_orientation
EGL_ANGLE_direct_composition
EGL_ANGLE_windows_ui_composition
EGL_NV_post_sub_buffer
EGL_KHR_create_context
EGL_EXT_device_query
EGL_KHR_image
EGL_KHR_image_base
EGL_KHR_image_pixmap
EGL_EXT_image_gl_colorspace
EGL_KHR_gl_colorspace
EGL_EXT_gl_colorspace_scrgb
EGL_EXT_gl_colorspace_scrgb_linear
EGL_EXT_gl_colorspace_display_p3
EGL_EXT_gl_colorspace_display_p3_linear
EGL_EXT_gl_colorspace_display_p3_passthrough
EGL_KHR_gl_texture_2D_image
EGL_KHR_gl_texture_cubemap_image
EGL_KHR_gl_texture_3D_image
EGL_KHR_gl_renderbuffer_image
EGL_KHR_get_all_proc_addresses
EGL_KHR_stream
EGL_KHR_stream_consumer_gltexture
EGL_NV_stream_consumer_gltexture_yuv
EGL_KHR_fence_sync
EGL_KHR_wait_sync
EGL_ANGLE_flexible_surface_compatibility
EGL_ANGLE_stream_producer_d3d_texture
EGL_ANGLE_create_context_webgl_compatibility
EGL_CHROMIUM_create_context_bind_generates_resource
EGL_CHROMIUM_sync_control
EGL_ANGLE_sync_control_rate
EGL_KHR_swap_buffers_with_damage
EGL_EXT_pixel_format_float
EGL_KHR_surfaceless_context
EGL_ANGLE_display_texture_share_group
EGL_ANGLE_display_semaphore_share_group
EGL_ANGLE_create_context_client_arrays
EGL_ANGLE_program_cache_control
EGL_ANGLE_robust_resource_initialization
EGL_ANGLE_iosurface_client_buffer
EGL_ANGLE_metal_texture_client_buffer
EGL_ANGLE_create_context_extensions_enabled
EGL_ANDROID_presentation_time
EGL_ANDROID_blob_cache
EGL_ANDROID_framebuffer_target
EGL_ANDROID_image_native_buffer
EGL_ANDROID_get_frame_timestamps
EGL_ANDROID_recordable
EGL_ANGLE_power_preference
EGL_ANGLE_image_d3d11_texture
EGL_ANDROID_create_native_client_buffer
EGL_ANDROID_get_native_client_buffer
EGL_ANDROID_native_fence_sync
EGL_ANGLE_create_context_backwards_compatible
EGL_KHR_no_config_context
EGL_IMG_context_priority
EGL_KHR_create_context_no_error
EGL_EXT_image_dma_buf_import
EGL_EXT_image_dma_buf_import_modifiers
EGL_NOK_texture_from_pixmap
EGL_NV_robustness_video_memory_purge
EGL_KHR_reusable_sync
EGL_ANGLE_device_d3d
EGL_ANGLE_device_cgl
EGL_ANGLE_device_eagl
EGL_EXT_client_extensions
EGL_EXT_platform_base
EGL_EXT_platform_device
EGL_ANGLE_platform_angle
EGL_ANGLE_platform_angle_d3d
EGL_ANGLE_platform_angle_d3d11on12
EGL_ANGLE_platform_angle_device_type_egl_angle
EGL_ANGLE_platform_angle_device_type_swiftshader
EGL_ANGLE_platform_angle_opengl
EGL_ANGLE_platform_angle_null
EGL_ANGLE_platform_angle_vulkan
EGL_ANGLE_platform_angle_metal
EGL_ANGLE_platform_angle_context_virtualization
EGL_ANGLE_platform_device_context_volatile_eagl
EGL_ANGLE_platform_device_context_volatile_cgl
EGL_ANGLE_device_creation
EGL_ANGLE_device_creation_d3d11
EGL_ANGLE_x11_visual
EGL_ANGLE_experimental_present_path
EGL_KHR_client_get_all_proc_addresses
EGL_KHR_debug
EGL_ANGLE_explicit_context
EGL_ANGLE_feature_control
GL_OES_element_index_uint
GL_OES_packed_depth_stencil
GL_OES_get_program_binary
GL_OES_rgb8_rgba8
GL_NV_read_depth
GL_NV_read_stencil
GL_NV_depth_buffer_float2
GL_EXT_texture_format_BGRA8888
GL_EXT_texture_type_2_10_10_10_REV
GL_EXT_read_format_bgra
GL_NV_pixel_buffer_object
GL_ARB_sync
GL_OES_mapbuffer
GL_EXT_map_buffer_range
GL_EXT_color_buffer_half_float
GL_OES_texture_half_float
GL_OES_texture_half_float_linear
GL_OES_texture_float
GL_OES_texture_float_linear
GL_EXT_texture_rg
GL_EXT_texture_compression_dxt1
GL_ANGLE_texture_compression_dxt3
GL_ANGLE_texture_compression_dxt5
GL_EXT_texture_compression_s3tc_srgb
GL_KHR_texture_compression_astc_ldr
GL_KHR_texture_compression_astc_hdr
GL_KHR_texture_compression_astc_sliced_3d
GL_OES_texture_compression_astc
GL_EXT_texture_compression_bptc
GL_EXT_texture_compression_rgtc
GL_OES_compressed_ETC1_RGB8_texture
GL_EXT_compressed_ETC1_RGB8_sub_texture
GL_OES_compressed_ETC2_RGB8_texture
GL_OES_compressed_ETC2_sRGB8_texture
GL_OES_compressed_ETC2_punchthroughA_RGBA8_texture
GL_OES_compressed_ETC2_punchthroughA_sRGB8_alpha_texture
GL_OES_compressed_ETC2_RGBA8_texture
GL_OES_compressed_ETC2_sRGB8_alpha8_texture
GL_OES_compressed_EAC_R11_unsigned_texture
GL_OES_compressed_EAC_R11_signed_texture
GL_OES_compressed_EAC_RG11_unsigned_texture
GL_OES_compressed_EAC_RG11_signed_texture
GL_ANGLE_compressed_texture_etc
GL_IMG_texture_compression_pvrtc
GL_EXT_pvrtc_sRGB
GL_EXT_sRGB
GL_EXT_texture_sRGB_R8
GL_ANGLE_depth_texture
GL_OES_depth_texture
GL_OES_depth_texture_cube_map
GL_OES_depth24
GL_OES_depth32
GL_OES_texture_3D
GL_EXT_texture_storage
GL_OES_texture_npot
GL_EXT_draw_buffers
GL_EXT_draw_buffers_indexed
GL_OES_draw_buffers_indexed
GL_EXT_texture_filter_anisotropic
GL_EXT_occlusion_query_boolean
GL_NV_fence
GL_EXT_disjoint_timer_query
GL_EXT_robustness
GL_KHR_robust_buffer_access_behavior
GL_EXT_blend_minmax
GL_ANGLE_framebuffer_blit
GL_ANGLE_framebuffer_multisample
GL_EXT_multisampled_render_to_texture
GL_EXT_multisampled_render_to_texture2
GL_ANGLE_instanced_arrays
GL_EXT_instanced_arrays
GL_ANGLE_pack_reverse_row_order
GL_OES_standard_derivatives
GL_EXT_shader_texture_lod
GL_EXT_frag_depth
GL_OVR_multiview
GL_OVR_multiview2
GL_ANGLE_texture_usage
GL_ANGLE_translated_shader_source
GL_OES_fbo_render_mipmap
GL_EXT_discard_framebuffer
GL_EXT_debug_marker
GL_OES_EGL_image
GL_OES_EGL_image_external
GL_OES_EGL_image_external_essl3
GL_EXT_EGL_image_external_wrap_modes
GL_OES_EGL_sync
GL_EXT_memory_object
GL_EXT_memory_object_fd
GL_ANGLE_memory_object_flags
GL_ANGLE_memory_object_fuchsia
GL_EXT_semaphore
GL_EXT_semaphore_fd
GL_NV_EGL_stream_consumer_external
GL_NV_shader_noperspective_interpolation
GL_ANGLE_semaphore_fuchsia
GL_EXT_unpack_subimage
GL_NV_pack_subimage
GL_EXT_color_buffer_float
GL_OES_vertex_half_float
GL_OES_vertex_array_object
GL_OES_vertex_type_10_10_10_2
GL_KHR_debug
GL_OES_texture_border_clamp
GL_KHR_no_error
GL_ANGLE_lossy_etc_decode
GL_CHROMIUM_bind_uniform_location
GL_CHROMIUM_sync_query
GL_CHROMIUM_copy_texture
GL_CHROMIUM_copy_compressed_texture
GL_ANGLE_copy_texture_3d
GL_ANGLE_webgl_compatibility
GL_ANGLE_request_extension
GL_CHROMIUM_bind_generates_resource
GL_ANGLE_robust_client_memory
GL_EXT_texture_sRGB_decode
GL_EXT_texture_sRGB_override
GL_EXT_sRGB_write_control
GL_CHROMIUM_color_buffer_float_rgb
GL_CHROMIUM_color_buffer_float_rgba
GL_EXT_multisample_compatibility
GL_CHROMIUM_framebuffer_mixed_samples
GL_EXT_texture_norm16
GL_OES_surfaceless_context
GL_ANGLE_client_arrays
GL_ANGLE_robust_resource_initialization
GL_ANGLE_program_cache_control
GL_ANGLE_texture_rectangle
GL_EXT_geometry_shader
GL_ANGLE_explicit_context_gles1
GL_ANGLE_explicit_context
GL_KHR_parallel_shader_compile
GL_OES_texture_storage_multisample_2d_array
GL_ANGLE_multiview_multisample
GL_EXT_blend_func_extended
GL_EXT_float_blend
GL_ANGLE_texture_multisample
GL_ANGLE_multi_draw
GL_ANGLE_provoking_vertex
GL_CHROMIUM_texture_filtering_hint
GL_CHROMIUM_lose_context
GL_ANGLE_texture_external_update
GL_ANGLE_base_vertex_base_instance
GL_ANGLE_get_image
GL_OES_draw_elements_base_vertex
GL_EXT_draw_elements_base_vertex
GL_EXT_gpu_shader5
GL_APPLE_clip_distance
GL_EXT_EGL_image_array
GL_EXT_buffer_storage
GL_EXT_external_buffer
GL_OES_texture_stencil8
GL_OES_sample_shading
GL_OES_shader_multisample_interpolation
GL_OES_shader_image_atomic
GL_NV_robustness_video_memory_purge
GL_ANGLE_get_tex_level_parameter
GL_EXT_copy_image
GL_OES_texture_buffer
GL_EXT_texture_buffer
GL_OES_point_size_array
GL_OES_texture_cube_map
GL_OES_point_sprite
GL_OES_draw_texture
GL_ANGLE_memory_size
GL_EXT_shader_non_constant_global_initializers
GL_WEBGL_video_texture
GL_OES_texture_cube_map_array
GL_EXT_texture_cube_map_array
GL_EXT_shadow_samplers
gl_FragDepth
clamp
gl_PointSize
gl_DepthRange
near
diff
gl_in
gl_PerVertex
unsupported shader version
Compute shader is not supported in this shader version.
Geometry shader is not supported in this shader version.
Precision emulation not supported for this output type.
too many uniforms
angle_DrawID
gl_DrawID
angle_BaseVertex
gl_BaseVertex
gl_BaseInstance
:MaxVertexAttribs:
:MaxVertexUniformVectors:
:MaxVaryingVectors:
:MaxVertexTextureImageUnits:
:MaxCombinedTextureImageUnits:
:MaxTextureImageUnits:
:MaxFragmentUniformVectors:
:MaxDrawBuffers:
:OES_standard_derivatives:
:OES_EGL_image_external:
:OES_EGL_image_external_essl3:
:NV_EGL_stream_consumer_external:
:ARB_texture_rectangle:
:EXT_draw_buffers:
:FragmentPrecisionHigh:
:MaxExpressionComplexity:
:MaxCallStackDepth:
:MaxFunctionParameters:
:EXT_blend_func_extended:
:EXT_frag_depth:
:EXT_shader_texture_lod:
:EXT_shader_framebuffer_fetch:
:NV_shader_framebuffer_fetch:
:ARM_shader_framebuffer_fetch:
:OVR_multiview2:
:OVR_multiview:
:EXT_YUV_target:
:EXT_geometry_shader:
:EXT_gpu_shader5:
:OES_texture_3D:
:MaxVertexOutputVectors:
:MaxFragmentInputVectors:
:MinProgramTexelOffset:
:MaxProgramTexelOffset:
:MaxDualSourceDrawBuffers:
:MaxViewsOVR:
:NV_draw_buffers:
:WEBGL_debug_shader_precision:
:ANGLE_multi_draw:
:ANGLE_base_vertex_base_instance:
:APPLE_clip_distance:
:OES_texture_cube_map_array:
:EXT_texture_cube_map_array:
:EXT_shadow_samplers:
:OES_shader_multisample_interpolation:
:OES_shader_image_atomic:
:OES_texture_buffer:
:EXT_texture_buffer:
:MinProgramTextureGatherOffset:
:MaxProgramTextureGatherOffset:
:MaxImageUnits:
:MaxVertexImageUniforms:
:MaxFragmentImageUniforms:
:MaxComputeImageUniforms:
:MaxCombinedImageUniforms:
:MaxCombinedShaderOutputResources:
:MaxComputeWorkGroupCountX:
:MaxComputeWorkGroupCountY:
:MaxComputeWorkGroupCountZ:
:MaxComputeWorkGroupSizeX:
:MaxComputeWorkGroupSizeY:
:MaxComputeWorkGroupSizeZ:
:MaxComputeUniformComponents:
:MaxComputeTextureImageUnits:
:MaxComputeAtomicCounters:
:MaxComputeAtomicCounterBuffers:
:MaxVertexAtomicCounters:
:MaxFragmentAtomicCounters:
:MaxCombinedAtomicCounters:
:MaxAtomicCounterBindings:
:MaxVertexAtomicCounterBuffers:
:MaxFragmentAtomicCounterBuffers:
:MaxCombinedAtomicCounterBuffers:
:MaxAtomicCounterBufferSize:
:MaxGeometryUniformComponents:
:MaxGeometryUniformBlocks:
:MaxGeometryInputComponents:
:MaxGeometryOutputComponents:
:MaxGeometryOutputVertices:
:MaxGeometryTotalOutputComponents:
:MaxGeometryTextureImageUnits:
:MaxGeometryAtomicCounterBuffers:
:MaxGeometryAtomicCounters:
:MaxGeometryShaderStorageBlocks:
:MaxGeometryShaderInvocations:
:MaxGeometryImageUniforms:
:MaxClipDistances
Call stack too deep (larger than 
) with the following call chain: 
Missing main()
Expression too complex.
Function has too many parameters.
gl_Position
#pragma STDGL invariant(all)
layout (early_fragment_tests) in;
layout (local_size_x=
, local_size_y=
, local_size_z=
) in;
#if defined(GL_ARB_shader_viewport_layer_array)
#extension GL_ARB_shader_viewport_layer_array : require
#elif defined(GL_NV_viewport_array2)
#extension GL_NV_viewport_array2 : require
#endif
#extension GL_OVR_multiview
layout(num_views=
cannot use both gl_FragData and gl_FragColor
cannot use both output variable sets (gl_FragData, gl_SecondaryFragDataEXT) and (gl_FragColor, gl_SecondaryFragColorEXT)
ANGLE_GEN_MTL_WITH_SPIRV
1.2.11
Undefined shift (operand out of range)
Constant folded undefined addition generated NaN
Constant folded addition overflowed to infinity
Constant folded undefined subtraction generated NaN
Constant folded subtraction overflowed to infinity
Constant folded undefined multiplication generated NaN
Constant folded multiplication overflowed to infinity
ANGLE (
OpenGL ES 
.0 (ANGLE 
2.1.14220 git hash: e4acbac6a5b8
OpenGL ES GLSL ES 
OpenGL GLSL 
0 (ANGLE 
Google Inc.
GL_OVR_multiview2
GL_OVR_multiview
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Context.cpp
initCaps
Limiting compressed format support.
Limiting binary format support count to zero while FrameCapture enabled
disable_program_binary
Disabling GL_EXT_map_buffer_range and GL_OES_mapbuffer during capture, which are not supported on some native drivers
BlitFramebuffer called for non-existing buffers
Clear called for non-existing buffers
Error: 
, in 
Program pipeline link failed
prepareForDispatch
Internal error: 
Metal backend encountered an error. Code=
Metal backend encountered an error: 
This set of render targets requires %lu bytes of pixel storage. This device supports %lu bytes.
MTLValidationError
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ContextMtl.mm
getRenderPassCommandEncoder
setupDraw
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Debug.cpp
insertMessage
 (this message will no longer repeat)
EGL 
error
deprecated behavior
undefined behavior
portability
performance
marker
start of group
end of group
other message
HIGH
MEDIUM
NOTIFICATION
CRITICAL
ERROR
WARNING
INFO
ViewID_OVR
InstanceID
multiviewBaseViewLayerIndex
initGlobals
' : 
internal error
out of memory
invalid character
invalid number
integer overflow
float overflow
token too long
invalid expression
division by zero
unexpected end of file found in comment
unexpected token
invalid directive name
macro name is reserved
macro redefined
predefined macro redefined
predefined macro undefined
unterminated macro invocation
macro undefined while being invoked
Not enough arguments for macro
Too many arguments for macro
duplicate macro parameter name
macro invocation chain too deep
unexpected #endif found without a matching #if
unexpected #else found without a matching #if
unexpected #else found after another #else
unexpected #elif found without a matching #if
unexpected #elif found after #else
unexpected end of file found in conditional block
invalid extension name
invalid extension behavior
invalid extension directive
invalid version number
invalid version directive
#version directive must occur before anything else, except for comments and white space
#version directive must occur on the first line of the shader
invalid line number
invalid file number
invalid line directive
extension directive must occur before any non-preprocessor tokens in ESSL1
extension directive must occur before any non-preprocessor tokens in ESSL3
shift exponent is negative or undefined
internal tokenizer error
unexpected end of file found in directive
unexpected token after conditional expression
unrecognized pragma
extension directive should occur before any non-preprocessor tokens
macro name with a double underscore is reserved - unintented behavior is possible
invariant
#pragma STDGL invariant(all) can not be used in fragment shader
optimize
webgl_debug_shader_precision
invalid pragma value - 'on' or 'off' expected
behavior invalid
extension cannot have 'require' behavior
extension cannot have 'enable' behavior
extension is not supported
client/version number not supported
STDGL
core
__VERSION__
extension
defined
glBlendFunc
glClear
glClearColor
glClearDepth
glClearStencil
glColorMask
glCullFace
glDepthFunc
glDepthMask
glDepthRange
glDisable
glDrawBuffer
glEnable
glFinish
glFlush
glFrontFace
glGetBooleanv
glGetDoublev
glGetError
glGetFloatv
glGetIntegerv
glGetString
glGetTexImage
glGetTexLevelParameterfv
glGetTexLevelParameteriv
glGetTexParameterfv
glGetTexParameteriv
glHint
glIsEnabled
glLineWidth
glLogicOp
glPixelStoref
glPixelStorei
glPointSize
glPolygonMode
glReadBuffer
glReadPixels
glScissor
glStencilFunc
glStencilMask
glStencilOp
glTexImage1D
glTexImage2D
glTexParameterf
glTexParameterfv
glTexParameteri
glTexParameteriv
glViewport
glBindTexture
glCopyTexImage1D
glCopyTexImage2D
glCopyTexSubImage1D
glCopyTexSubImage2D
glDeleteTextures
glDrawArrays
glDrawElements
glGenTextures
glIsTexture
glPolygonOffset
glTexSubImage1D
glTexSubImage2D
glCopyTexSubImage3D
glDrawRangeElements
glTexImage3D
glTexSubImage3D
glActiveTexture
glCompressedTexImage1D
glCompressedTexImage2D
glCompressedTexImage3D
glCompressedTexSubImage1D
glCompressedTexSubImage2D
glCompressedTexSubImage3D
glGetCompressedTexImage
glSampleCoverage
glBlendColor
glBlendEquation
glBlendFuncSeparate
glMultiDrawArrays
glMultiDrawElements
glPointParameterf
glPointParameterfv
glPointParameteri
glPointParameteriv
glBeginQuery
glBindBuffer
glBufferData
glBufferSubData
glDeleteBuffers
glDeleteQueries
glEndQuery
glGenBuffers
glGenQueries
glGetBufferParameteriv
glGetBufferPointerv
glGetBufferSubData
glGetQueryObjectiv
glGetQueryObjectuiv
glGetQueryiv
glIsBuffer
glIsQuery
glMapBuffer
glUnmapBuffer
glAttachShader
glBindAttribLocation
glBlendEquationSeparate
glCompileShader
glCreateProgram
glCreateShader
glDeleteProgram
glDeleteShader
glDetachShader
glDisableVertexAttribArray
glDrawBuffers
glEnableVertexAttribArray
glGetActiveAttrib
glGetActiveUniform
glGetAttachedShaders
glGetAttribLocation
glGetProgramInfoLog
glGetProgramiv
glGetShaderInfoLog
glGetShaderSource
glGetShaderiv
glGetUniformLocation
glGetUniformfv
glGetUniformiv
glGetVertexAttribPointerv
glGetVertexAttribdv
glGetVertexAttribfv
glGetVertexAttribiv
glIsProgram
glIsShader
glLinkProgram
glShaderSource
glStencilFuncSeparate
glStencilMaskSeparate
glStencilOpSeparate
glUniform1f
glUniform1fv
glUniform1i
glUniform1iv
glUniform2f
glUniform2fv
glUniform2i
glUniform2iv
glUniform3f
glUniform3fv
glUniform3i
glUniform3iv
glUniform4f
glUniform4fv
glUniform4i
glUniform4iv
glUniformMatrix2fv
glUniformMatrix3fv
glUniformMatrix4fv
glUseProgram
glValidateProgram
glVertexAttrib1d
glVertexAttrib1dv
glVertexAttrib1f
glVertexAttrib1fv
glVertexAttrib1s
glVertexAttrib1sv
glVertexAttrib2d
glVertexAttrib2dv
glVertexAttrib2f
glVertexAttrib2fv
glVertexAttrib2s
glVertexAttrib2sv
glVertexAttrib3d
glVertexAttrib3dv
glVertexAttrib3f
glVertexAttrib3fv
glVertexAttrib3s
glVertexAttrib3sv
glVertexAttrib4Nbv
glVertexAttrib4Niv
glVertexAttrib4Nsv
glVertexAttrib4Nub
glVertexAttrib4Nubv
glVertexAttrib4Nuiv
glVertexAttrib4Nusv
glVertexAttrib4bv
glVertexAttrib4d
glVertexAttrib4dv
glVertexAttrib4f
glVertexAttrib4fv
glVertexAttrib4iv
glVertexAttrib4s
glVertexAttrib4sv
glVertexAttrib4ubv
glVertexAttrib4uiv
glVertexAttrib4usv
glVertexAttribPointer
glUniformMatrix2x3fv
glUniformMatrix2x4fv
glUniformMatrix3x2fv
glUniformMatrix3x4fv
glUniformMatrix4x2fv
glUniformMatrix4x3fv
glBeginConditionalRender
glBeginTransformFeedback
glBindBufferBase
glBindBufferRange
glBindFragDataLocation
glBindFramebuffer
glBindRenderbuffer
glBindVertexArray
glBlitFramebuffer
glCheckFramebufferStatus
glClampColor
glClearBufferfi
glClearBufferfv
glClearBufferiv
glClearBufferuiv
glColorMaski
glDeleteFramebuffers
glDeleteRenderbuffers
glDeleteVertexArrays
glDisablei
glEnablei
glEndConditionalRender
glEndTransformFeedback
glFlushMappedBufferRange
glFramebufferRenderbuffer
glFramebufferTexture1D
glFramebufferTexture2D
glFramebufferTexture3D
glFramebufferTextureLayer
glGenFramebuffers
glGenRenderbuffers
glGenVertexArrays
glGenerateMipmap
glGetBooleani_v
glGetFragDataLocation
glGetFramebufferAttachmentParameteriv
glGetIntegeri_v
glGetRenderbufferParameteriv
glGetStringi
glGetTexParameterIiv
glGetTexParameterIuiv
glGetTransformFeedbackVarying
glGetUniformuiv
glGetVertexAttribIiv
glGetVertexAttribIuiv
glIsEnabledi
glIsFramebuffer
glIsRenderbuffer
glIsVertexArray
glMapBufferRange
glRenderbufferStorage
glRenderbufferStorageMultisample
glTexParameterIiv
glTexParameterIuiv
glTransformFeedbackVaryings
glUniform1ui
glUniform1uiv
glUniform2ui
glUniform2uiv
glUniform3ui
glUniform3uiv
glUniform4ui
glUniform4uiv
glVertexAttribI1i
glVertexAttribI1iv
glVertexAttribI1ui
glVertexAttribI1uiv
glVertexAttribI2i
glVertexAttribI2iv
glVertexAttribI2ui
glVertexAttribI2uiv
glVertexAttribI3i
glVertexAttribI3iv
glVertexAttribI3ui
glVertexAttribI3uiv
glVertexAttribI4bv
glVertexAttribI4i
glVertexAttribI4iv
glVertexAttribI4sv
glVertexAttribI4ubv
glVertexAttribI4ui
glVertexAttribI4uiv
glVertexAttribI4usv
glVertexAttribIPointer
glCopyBufferSubData
glDrawArraysInstanced
glDrawElementsInstanced
glGetActiveUniformBlockName
glGetActiveUniformBlockiv
glGetActiveUniformName
glGetActiveUniformsiv
glGetUniformBlockIndex
glGetUniformIndices
glPrimitiveRestartIndex
glTexBuffer
glUniformBlockBinding
glClientWaitSync
glDeleteSync
glDrawElementsBaseVertex
glDrawElementsInstancedBaseVertex
glDrawRangeElementsBaseVertex
glFenceSync
glFramebufferTexture
glGetBufferParameteri64v
glGetInteger64i_v
glGetInteger64v
glGetMultisamplefv
glGetSynciv
glIsSync
glMultiDrawElementsBaseVertex
glProvokingVertex
glSampleMaski
glTexImage2DMultisample
glTexImage3DMultisample
glWaitSync
glBindFragDataLocationIndexed
glBindSampler
glDeleteSamplers
glGenSamplers
glGetFragDataIndex
glGetQueryObjecti64v
glGetQueryObjectui64v
glGetSamplerParameterIiv
glGetSamplerParameterIuiv
glGetSamplerParameterfv
glGetSamplerParameteriv
glIsSampler
glQueryCounter
glSamplerParameterIiv
glSamplerParameterIuiv
glSamplerParameterf
glSamplerParameterfv
glSamplerParameteri
glSamplerParameteriv
glVertexAttribDivisor
glVertexAttribP1ui
glVertexAttribP1uiv
glVertexAttribP2ui
glVertexAttribP2uiv
glVertexAttribP3ui
glVertexAttribP3uiv
glVertexAttribP4ui
glVertexAttribP4uiv
glBeginQueryIndexed
glBindTransformFeedback
glBlendEquationSeparatei
glBlendEquationi
glBlendFuncSeparatei
glBlendFunci
glDeleteTransformFeedbacks
glDrawArraysIndirect
glDrawElementsIndirect
glDrawTransformFeedback
glDrawTransformFeedbackStream
glEndQueryIndexed
glGenTransformFeedbacks
glGetActiveSubroutineName
glGetActiveSubroutineUniformName
glGetActiveSubroutineUniformiv
glGetProgramStageiv
glGetQueryIndexediv
glGetSubroutineIndex
glGetSubroutineUniformLocation
glGetUniformSubroutineuiv
glGetUniformdv
glIsTransformFeedback
glMinSampleShading
glPatchParameterfv
glPatchParameteri
glPauseTransformFeedback
glResumeTransformFeedback
glUniform1d
glUniform1dv
glUniform2d
glUniform2dv
glUniform3d
glUniform3dv
glUniform4d
glUniform4dv
glUniformMatrix2dv
glUniformMatrix2x3dv
glUniformMatrix2x4dv
glUniformMatrix3dv
glUniformMatrix3x2dv
glUniformMatrix3x4dv
glUniformMatrix4dv
glUniformMatrix4x2dv
glUniformMatrix4x3dv
glUniformSubroutinesuiv
glActiveShaderProgram
glBindProgramPipeline
glClearDepthf
glCreateShaderProgramv
glDeleteProgramPipelines
glDepthRangeArrayv
glDepthRangeIndexed
glDepthRangef
glGenProgramPipelines
glGetDoublei_v
glGetFloati_v
glGetProgramBinary
glGetProgramPipelineInfoLog
glGetProgramPipelineiv
glGetShaderPrecisionFormat
glGetVertexAttribLdv
glIsProgramPipeline
glProgramBinary
glProgramParameteri
glProgramUniform1d
glProgramUniform1dv
glProgramUniform1f
glProgramUniform1fv
glProgramUniform1i
glProgramUniform1iv
glProgramUniform1ui
glProgramUniform1uiv
glProgramUniform2d
glProgramUniform2dv
glProgramUniform2f
glProgramUniform2fv
glProgramUniform2i
glProgramUniform2iv
glProgramUniform2ui
glProgramUniform2uiv
glProgramUniform3d
glProgramUniform3dv
glProgramUniform3f
glProgramUniform3fv
glProgramUniform3i
glProgramUniform3iv
glProgramUniform3ui
glProgramUniform3uiv
glProgramUniform4d
glProgramUniform4dv
glProgramUniform4f
glProgramUniform4fv
glProgramUniform4i
glProgramUniform4iv
glProgramUniform4ui
glProgramUniform4uiv
glProgramUniformMatrix2dv
glProgramUniformMatrix2fv
glProgramUniformMatrix2x3dv
glProgramUniformMatrix2x3fv
glProgramUniformMatrix2x4dv
glProgramUniformMatrix2x4fv
glProgramUniformMatrix3dv
glProgramUniformMatrix3fv
glProgramUniformMatrix3x2dv
glProgramUniformMatrix3x2fv
glProgramUniformMatrix3x4dv
glProgramUniformMatrix3x4fv
glProgramUniformMatrix4dv
glProgramUniformMatrix4fv
glProgramUniformMatrix4x2dv
glProgramUniformMatrix4x2fv
glProgramUniformMatrix4x3dv
glProgramUniformMatrix4x3fv
glReleaseShaderCompiler
glScissorArrayv
glScissorIndexed
glScissorIndexedv
glShaderBinary
glUseProgramStages
glValidateProgramPipeline
glVertexAttribL1d
glVertexAttribL1dv
glVertexAttribL2d
glVertexAttribL2dv
glVertexAttribL3d
glVertexAttribL3dv
glVertexAttribL4d
glVertexAttribL4dv
glVertexAttribLPointer
glViewportArrayv
glViewportIndexedf
glViewportIndexedfv
glBindImageTexture
glDrawArraysInstancedBaseInstance
glDrawElementsInstancedBaseInstance
glDrawElementsInstancedBaseVertexBaseInstance
glDrawTransformFeedbackInstanced
glDrawTransformFeedbackStreamInstanced
glGetActiveAtomicCounterBufferiv
glGetInternalformativ
glMemoryBarrier
glTexStorage1D
glTexStorage2D
glTexStorage3D
glBindVertexBuffer
glClearBufferData
glClearBufferSubData
glCopyImageSubData
glDebugMessageCallback
glDebugMessageControl
glDebugMessageInsert
glDispatchCompute
glDispatchComputeIndirect
glFramebufferParameteri
glGetDebugMessageLog
glGetFramebufferParameteriv
glGetInternalformati64v
glGetObjectLabel
glGetObjectPtrLabel
glGetPointerv
glGetProgramInterfaceiv
glGetProgramResourceIndex
glGetProgramResourceLocation
glGetProgramResourceLocationIndex
glGetProgramResourceName
glGetProgramResourceiv
glInvalidateBufferData
glInvalidateBufferSubData
glInvalidateFramebuffer
glInvalidateSubFramebuffer
glInvalidateTexImage
glInvalidateTexSubImage
glMultiDrawArraysIndirect
glMultiDrawElementsIndirect
glObjectLabel
glObjectPtrLabel
glPopDebugGroup
glPushDebugGroup
glShaderStorageBlockBinding
glTexBufferRange
glTexStorage2DMultisample
glTexStorage3DMultisample
glTextureView
glVertexAttribBinding
glVertexAttribFormat
glVertexAttribIFormat
glVertexAttribLFormat
glVertexBindingDivisor
glBindBuffersBase
glBindBuffersRange
glBindImageTextures
glBindSamplers
glBindTextures
glBindVertexBuffers
glBufferStorage
glClearTexImage
glClearTexSubImage
glBindTextureUnit
glBlitNamedFramebuffer
glCheckNamedFramebufferStatus
glClearNamedBufferData
glClearNamedBufferSubData
glClearNamedFramebufferfi
glClearNamedFramebufferfv
glClearNamedFramebufferiv
glClearNamedFramebufferuiv
glClipControl
glCompressedTextureSubImage1D
glCompressedTextureSubImage2D
glCompressedTextureSubImage3D
glCopyNamedBufferSubData
glCopyTextureSubImage1D
glCopyTextureSubImage2D
glCopyTextureSubImage3D
glCreateBuffers
glCreateFramebuffers
glCreateProgramPipelines
glCreateQueries
glCreateRenderbuffers
glCreateSamplers
glCreateTextures
glCreateTransformFeedbacks
glCreateVertexArrays
glDisableVertexArrayAttrib
glEnableVertexArrayAttrib
glFlushMappedNamedBufferRange
glGenerateTextureMipmap
glGetCompressedTextureImage
glGetCompressedTextureSubImage
glGetGraphicsResetStatus
glGetNamedBufferParameteri64v
glGetNamedBufferParameteriv
glGetNamedBufferPointerv
glGetNamedBufferSubData
glGetNamedFramebufferAttachmentParameteriv
glGetNamedFramebufferParameteriv
glGetNamedRenderbufferParameteriv
glGetQueryBufferObjecti64v
glGetQueryBufferObjectiv
glGetQueryBufferObjectui64v
glGetQueryBufferObjectuiv
glGetTextureImage
glGetTextureLevelParameterfv
glGetTextureLevelParameteriv
glGetTextureParameterIiv
glGetTextureParameterIuiv
glGetTextureParameterfv
glGetTextureParameteriv
glGetTextureSubImage
glGetTransformFeedbacki64_v
glGetTransformFeedbacki_v
glGetTransformFeedbackiv
glGetVertexArrayIndexed64iv
glGetVertexArrayIndexediv
glGetVertexArrayiv
glGetnCompressedTexImage
glGetnTexImage
glGetnUniformdv
glGetnUniformfv
glGetnUniformiv
glGetnUniformuiv
glInvalidateNamedFramebufferData
glInvalidateNamedFramebufferSubData
glMapNamedBuffer
glMapNamedBufferRange
glMemoryBarrierByRegion
glNamedBufferData
glNamedBufferStorage
glNamedBufferSubData
glNamedFramebufferDrawBuffer
glNamedFramebufferDrawBuffers
glNamedFramebufferParameteri
glNamedFramebufferReadBuffer
glNamedFramebufferRenderbuffer
glNamedFramebufferTexture
glNamedFramebufferTextureLayer
glNamedRenderbufferStorage
glNamedRenderbufferStorageMultisample
glReadnPixels
glTextureBarrier
glTextureBuffer
glTextureBufferRange
glTextureParameterIiv
glTextureParameterIuiv
glTextureParameterf
glTextureParameterfv
glTextureParameteri
glTextureParameteriv
glTextureStorage1D
glTextureStorage2D
glTextureStorage2DMultisample
glTextureStorage3D
glTextureStorage3DMultisample
glTextureSubImage1D
glTextureSubImage2D
glTextureSubImage3D
glTransformFeedbackBufferBase
glTransformFeedbackBufferRange
glUnmapNamedBuffer
glVertexArrayAttribBinding
glVertexArrayAttribFormat
glVertexArrayAttribIFormat
glVertexArrayAttribLFormat
glVertexArrayBindingDivisor
glVertexArrayElementBuffer
glVertexArrayVertexBuffer
glVertexArrayVertexBuffers
GL_ARB_ES2_compatibility
GL_ARB_ES3_1_compatibility
GL_ARB_ES3_2_compatibility
glPrimitiveBoundingBoxARB
GL_ARB_base_instance
GL_ARB_blend_func_extended
GL_ARB_buffer_storage
GL_ARB_clear_buffer_object
GL_ARB_clear_texture
GL_ARB_clip_control
GL_ARB_color_buffer_float
glClampColorARB
GL_ARB_compute_shader
GL_ARB_copy_buffer
GL_ARB_copy_image
GL_ARB_debug_output
glDebugMessageCallbackARB
glDebugMessageControlARB
glDebugMessageInsertARB
glGetDebugMessageLogARB
GL_ARB_direct_state_access
GL_ARB_draw_buffers
glDrawBuffersARB
GL_ARB_draw_buffers_blend
glBlendEquationSeparateiARB
glBlendEquationiARB
glBlendFuncSeparateiARB
glBlendFunciARB
GL_ARB_draw_elements_base_vertex
GL_ARB_draw_indirect
GL_ARB_draw_instanced
glDrawArraysInstancedARB
glDrawElementsInstancedARB
GL_ARB_fragment_program
glGetProgramivARB
glIsProgramARB
GL_ARB_framebuffer_no_attachments
GL_ARB_framebuffer_object
GL_ARB_geometry_shader4
glFramebufferTextureARB
glFramebufferTextureLayerARB
glProgramParameteriARB
GL_ARB_get_program_binary
GL_ARB_get_texture_sub_image
GL_ARB_gpu_shader_fp64
GL_ARB_imaging
GL_ARB_instanced_arrays
glVertexAttribDivisorARB
GL_ARB_internalformat_query
GL_ARB_internalformat_query2
GL_ARB_invalidate_subdata
GL_ARB_map_buffer_range
GL_ARB_multi_bind
GL_ARB_multi_draw_indirect
GL_ARB_multisample
glSampleCoverageARB
GL_ARB_multitexture
glActiveTextureARB
GL_ARB_occlusion_query
glBeginQueryARB
glDeleteQueriesARB
glEndQueryARB
glGenQueriesARB
glGetQueryObjectivARB
glGetQueryObjectuivARB
glGetQueryivARB
glIsQueryARB
GL_ARB_parallel_shader_compile
glMaxShaderCompilerThreadsARB
GL_ARB_point_parameters
glPointParameterfARB
glPointParameterfvARB
GL_ARB_program_interface_query
GL_ARB_provoking_vertex
GL_ARB_robustness
glGetGraphicsResetStatusARB
glGetnCompressedTexImageARB
glGetnTexImageARB
glGetnUniformdvARB
glGetnUniformfvARB
glGetnUniformivARB
glGetnUniformuivARB
glReadnPixelsARB
GL_ARB_sample_shading
glMinSampleShadingARB
GL_ARB_sampler_objects
GL_ARB_separate_shader_objects
GL_ARB_shader_atomic_counters
GL_ARB_shader_image_load_store
GL_ARB_shader_objects
glCompileShaderARB
glGetActiveUniformARB
glGetShaderSourceARB
glGetUniformLocationARB
glGetUniformfvARB
glGetUniformivARB
glLinkProgramARB
glShaderSourceARB
glUniform1fARB
glUniform1fvARB
glUniform1iARB
glUniform1ivARB
glUniform2fARB
glUniform2fvARB
glUniform2iARB
glUniform2ivARB
glUniform3fARB
glUniform3fvARB
glUniform3iARB
glUniform3ivARB
glUniform4fARB
glUniform4fvARB
glUniform4iARB
glUniform4ivARB
glUniformMatrix2fvARB
glUniformMatrix3fvARB
glUniformMatrix4fvARB
glValidateProgramARB
GL_ARB_shader_storage_buffer_object
GL_ARB_shader_subroutine
GL_ARB_tessellation_shader
GL_ARB_texture_barrier
GL_ARB_texture_buffer_object
glTexBufferARB
GL_ARB_texture_buffer_range
GL_ARB_texture_compression
glCompressedTexImage1DARB
glCompressedTexImage2DARB
glCompressedTexImage3DARB
glCompressedTexSubImage1DARB
glCompressedTexSubImage2DARB
glCompressedTexSubImage3DARB
glGetCompressedTexImageARB
GL_ARB_texture_multisample
GL_ARB_texture_storage
GL_ARB_texture_storage_multisample
GL_ARB_texture_view
GL_ARB_timer_query
GL_ARB_transform_feedback2
GL_ARB_transform_feedback3
GL_ARB_transform_feedback_instanced
GL_ARB_uniform_buffer_object
GL_ARB_vertex_array_object
GL_ARB_vertex_attrib_64bit
GL_ARB_vertex_attrib_binding
GL_ARB_vertex_buffer_object
glBindBufferARB
glBufferDataARB
glBufferSubDataARB
glDeleteBuffersARB
glGenBuffersARB
glGetBufferParameterivARB
glGetBufferPointervARB
glGetBufferSubDataARB
glIsBufferARB
glMapBufferARB
glUnmapBufferARB
GL_ARB_vertex_program
glDisableVertexAttribArrayARB
glEnableVertexAttribArrayARB
glGetVertexAttribPointervARB
glGetVertexAttribdvARB
glGetVertexAttribfvARB
glGetVertexAttribivARB
glVertexAttrib1dARB
glVertexAttrib1dvARB
glVertexAttrib1fARB
glVertexAttrib1fvARB
glVertexAttrib1sARB
glVertexAttrib1svARB
glVertexAttrib2dARB
glVertexAttrib2dvARB
glVertexAttrib2fARB
glVertexAttrib2fvARB
glVertexAttrib2sARB
glVertexAttrib2svARB
glVertexAttrib3dARB
glVertexAttrib3dvARB
glVertexAttrib3fARB
glVertexAttrib3fvARB
glVertexAttrib3sARB
glVertexAttrib3svARB
glVertexAttrib4NbvARB
glVertexAttrib4NivARB
glVertexAttrib4NsvARB
glVertexAttrib4NubARB
glVertexAttrib4NubvARB
glVertexAttrib4NuivARB
glVertexAttrib4NusvARB
glVertexAttrib4bvARB
glVertexAttrib4dARB
glVertexAttrib4dvARB
glVertexAttrib4fARB
glVertexAttrib4fvARB
glVertexAttrib4ivARB
glVertexAttrib4sARB
glVertexAttrib4svARB
glVertexAttrib4ubvARB
glVertexAttrib4uivARB
glVertexAttrib4usvARB
glVertexAttribPointerARB
GL_ARB_vertex_shader
glBindAttribLocationARB
glGetActiveAttribARB
glGetAttribLocationARB
GL_ARB_vertex_type_2_10_10_10_rev
GL_ARB_viewport_array
GL_EXT_blend_color
glBlendColorEXT
GL_EXT_blend_equation_separate
glBlendEquationSeparateEXT
GL_EXT_blend_func_separate
glBlendFuncSeparateEXT
GL_EXT_copy_texture
glCopyTexImage1DEXT
glCopyTexImage2DEXT
glCopyTexSubImage1DEXT
glCopyTexSubImage2DEXT
glCopyTexSubImage3DEXT
GL_EXT_direct_state_access
glCheckNamedFramebufferStatusEXT
glClearNamedBufferDataEXT
glClearNamedBufferSubDataEXT
glCompressedTextureSubImage1DEXT
glCompressedTextureSubImage2DEXT
glCompressedTextureSubImage3DEXT
glCopyTextureSubImage1DEXT
glCopyTextureSubImage2DEXT
glCopyTextureSubImage3DEXT
glDisableVertexArrayAttribEXT
glEnableVertexArrayAttribEXT
glFlushMappedNamedBufferRangeEXT
glGenerateTextureMipmapEXT
glGetCompressedTextureImageEXT
glGetDoublei_vEXT
glGetFloati_vEXT
glGetFramebufferParameterivEXT
glGetNamedBufferParameterivEXT
glGetNamedBufferPointervEXT
glGetNamedBufferSubDataEXT
glGetNamedFramebufferAttachmentParameterivEXT
glGetNamedFramebufferParameterivEXT
glGetNamedRenderbufferParameterivEXT
glGetTextureImageEXT
glGetTextureLevelParameterfvEXT
glGetTextureLevelParameterivEXT
glGetTextureParameterIivEXT
glGetTextureParameterIuivEXT
glGetTextureParameterfvEXT
glGetTextureParameterivEXT
glMapNamedBufferEXT
glMapNamedBufferRangeEXT
glNamedBufferDataEXT
glNamedBufferStorageEXT
glNamedBufferSubDataEXT
glNamedFramebufferParameteriEXT
glNamedFramebufferRenderbufferEXT
glNamedFramebufferTextureEXT
glNamedFramebufferTextureLayerEXT
glNamedRenderbufferStorageEXT
glNamedRenderbufferStorageMultisampleEXT
glProgramUniform1dEXT
glProgramUniform1dvEXT
glProgramUniform2dEXT
glProgramUniform2dvEXT
glProgramUniform3dEXT
glProgramUniform3dvEXT
glProgramUniform4dEXT
glProgramUniform4dvEXT
glProgramUniformMatrix2dvEXT
glProgramUniformMatrix2x3dvEXT
glProgramUniformMatrix2x4dvEXT
glProgramUniformMatrix3dvEXT
glProgramUniformMatrix3x2dvEXT
glProgramUniformMatrix3x4dvEXT
glProgramUniformMatrix4dvEXT
glProgramUniformMatrix4x2dvEXT
glProgramUniformMatrix4x3dvEXT
glTextureBufferEXT
glTextureBufferRangeEXT
glTextureParameterIivEXT
glTextureParameterIuivEXT
glTextureParameterfEXT
glTextureParameterfvEXT
glTextureParameteriEXT
glTextureParameterivEXT
glTextureStorage1DEXT
glTextureStorage2DEXT
glTextureStorage2DMultisampleEXT
glTextureStorage3DEXT
glTextureStorage3DMultisampleEXT
glTextureSubImage1DEXT
glTextureSubImage2DEXT
glTextureSubImage3DEXT
glUnmapNamedBufferEXT
GL_EXT_draw_range_elements
glDrawRangeElementsEXT
GL_EXT_framebuffer_blit
glBlitFramebufferEXT
GL_EXT_framebuffer_multisample
glRenderbufferStorageMultisampleEXT
GL_EXT_framebuffer_object
glBindFramebufferEXT
glBindRenderbufferEXT
glCheckFramebufferStatusEXT
glDeleteFramebuffersEXT
glDeleteRenderbuffersEXT
glFramebufferRenderbufferEXT
glFramebufferTexture1DEXT
glFramebufferTexture2DEXT
glFramebufferTexture3DEXT
glGenFramebuffersEXT
glGenRenderbuffersEXT
glGenerateMipmapEXT
glGetFramebufferAttachmentParameterivEXT
glGetRenderbufferParameterivEXT
glIsFramebufferEXT
glIsRenderbufferEXT
glRenderbufferStorageEXT
GL_EXT_gpu_shader4
glBindFragDataLocationEXT
glGetFragDataLocationEXT
glGetUniformuivEXT
glUniform1uiEXT
glUniform1uivEXT
glUniform2uiEXT
glUniform2uivEXT
glUniform3uiEXT
glUniform3uivEXT
glUniform4uiEXT
glUniform4uivEXT
GL_EXT_point_parameters
glPointParameterfEXT
glPointParameterfvEXT
GL_EXT_polygon_offset
glPolygonOffsetEXT
GL_EXT_provoking_vertex
glProvokingVertexEXT
GL_EXT_shader_image_load_store
glBindImageTextureEXT
glMemoryBarrierEXT
GL_EXT_subtexture
glTexSubImage1DEXT
glTexSubImage2DEXT
GL_EXT_texture3D
glTexImage3DEXT
glTexSubImage3DEXT
GL_EXT_texture_array
glFramebufferTextureLayerEXT
GL_EXT_texture_buffer_object
glTexBufferEXT
GL_EXT_texture_integer
glGetTexParameterIivEXT
glGetTexParameterIuivEXT
glTexParameterIivEXT
glTexParameterIuivEXT
GL_EXT_texture_object
glBindTextureEXT
glDeleteTexturesEXT
glGenTexturesEXT
glIsTextureEXT
GL_EXT_timer_query
glGetQueryObjecti64vEXT
glGetQueryObjectui64vEXT
GL_EXT_transform_feedback
glBeginTransformFeedbackEXT
glBindBufferBaseEXT
glBindBufferRangeEXT
glEndTransformFeedbackEXT
glGetTransformFeedbackVaryingEXT
glTransformFeedbackVaryingsEXT
GL_EXT_vertex_array
glDrawArraysEXT
glGetPointervEXT
GL_EXT_vertex_attrib_64bit
glGetVertexAttribLdvEXT
glVertexAttribL1dEXT
glVertexAttribL1dvEXT
glVertexAttribL2dEXT
glVertexAttribL2dvEXT
glVertexAttribL3dEXT
glVertexAttribL3dvEXT
glVertexAttribL4dEXT
glVertexAttribL4dvEXT
glVertexAttribLPointerEXT
GL_KHR_robustness
GL_NV_geometry_program4
glFramebufferTextureEXT
GL_NV_vertex_program4
glGetVertexAttribIivEXT
glGetVertexAttribIuivEXT
glVertexAttribI1iEXT
glVertexAttribI1ivEXT
glVertexAttribI1uiEXT
glVertexAttribI1uivEXT
glVertexAttribI2iEXT
glVertexAttribI2ivEXT
glVertexAttribI2uiEXT
glVertexAttribI2uivEXT
glVertexAttribI3iEXT
glVertexAttribI3ivEXT
glVertexAttribI3uiEXT
glVertexAttribI3uivEXT
glVertexAttribI4bvEXT
glVertexAttribI4iEXT
glVertexAttribI4ivEXT
glVertexAttribI4svEXT
glVertexAttribI4ubvEXT
glVertexAttribI4uiEXT
glVertexAttribI4uivEXT
glVertexAttribI4usvEXT
glVertexAttribIPointerEXT
GL_OES_single_precision
glClearDepthfOES
glDepthRangefOES
glBlendBarrier
glPrimitiveBoundingBox
GL_EXT_base_instance
glDrawArraysInstancedBaseInstanceEXT
glDrawElementsInstancedBaseInstanceEXT
glDrawElementsInstancedBaseVertexBaseInstanceEXT
glBindFragDataLocationIndexedEXT
glGetFragDataIndexEXT
glGetProgramResourceLocationIndexEXT
glBufferStorageEXT
GL_EXT_clear_texture
glClearTexImageEXT
glClearTexSubImageEXT
GL_EXT_clip_control
glClipControlEXT
glCopyImageSubDataEXT
glDiscardFramebufferEXT
glBeginQueryEXT
glDeleteQueriesEXT
glEndQueryEXT
glGenQueriesEXT
glGetInteger64vEXT
glGetQueryObjectivEXT
glGetQueryObjectuivEXT
glGetQueryivEXT
glIsQueryEXT
glQueryCounterEXT
glDrawBuffersEXT
glBlendEquationSeparateiEXT
glBlendEquationiEXT
glBlendFuncSeparateiEXT
glBlendFunciEXT
glColorMaskiEXT
glDisableiEXT
glEnableiEXT
glIsEnablediEXT
glDrawElementsBaseVertexEXT
glDrawElementsInstancedBaseVertexEXT
glDrawRangeElementsBaseVertexEXT
glMultiDrawElementsBaseVertexEXT
GL_EXT_draw_transform_feedback
glDrawTransformFeedbackEXT
glDrawTransformFeedbackInstancedEXT
glVertexAttribDivisorEXT
glFlushMappedBufferRangeEXT
glMapBufferRangeEXT
GL_EXT_multi_draw_indirect
glMultiDrawArraysIndirectEXT
glMultiDrawElementsIndirectEXT
GL_EXT_multiview_draw_buffers
glGetIntegeri_vEXT
GL_EXT_primitive_bounding_box
glPrimitiveBoundingBoxEXT
glGetGraphicsResetStatusEXT
glGetnUniformfvEXT
glGetnUniformivEXT
glReadnPixelsEXT
GL_EXT_tessellation_shader
glPatchParameteriEXT
GL_EXT_texture_border_clamp
glGetSamplerParameterIivEXT
glGetSamplerParameterIuivEXT
glSamplerParameterIivEXT
glSamplerParameterIuivEXT
glTexBufferRangeEXT
glTexStorage1DEXT
glTexStorage2DEXT
glTexStorage3DEXT
GL_EXT_texture_view
glTextureViewEXT
glDebugMessageCallbackKHR
glDebugMessageControlKHR
glDebugMessageInsertKHR
glGetDebugMessageLogKHR
glGetObjectLabelKHR
glGetObjectPtrLabelKHR
glGetPointervKHR
glObjectLabelKHR
glObjectPtrLabelKHR
glPopDebugGroupKHR
glPushDebugGroupKHR
glGetGraphicsResetStatusKHR
glGetnUniformfvKHR
glGetnUniformivKHR
glGetnUniformuivKHR
glReadnPixelsKHR
glEGLImageTargetRenderbufferStorageOES
glEGLImageTargetTexture2DOES
GL_OES_copy_image
glCopyImageSubDataOES
glBlendEquationSeparateiOES
glBlendEquationiOES
glBlendFuncSeparateiOES
glBlendFunciOES
glColorMaskiOES
glDisableiOES
glEnableiOES
glIsEnablediOES
glDrawElementsBaseVertexOES
glDrawElementsInstancedBaseVertexOES
glDrawRangeElementsBaseVertexOES
GL_OES_geometry_shader
glFramebufferTextureOES
glGetProgramBinaryOES
glProgramBinaryOES
glGetBufferPointervOES
glMapBufferOES
glUnmapBufferOES
GL_OES_primitive_bounding_box
glPrimitiveBoundingBoxOES
glMinSampleShadingOES
GL_OES_tessellation_shader
glPatchParameteriOES
glCompressedTexImage3DOES
glCompressedTexSubImage3DOES
glCopyTexSubImage3DOES
glFramebufferTexture3DOES
glTexImage3DOES
glTexSubImage3DOES
glGetSamplerParameterIivOES
glGetSamplerParameterIuivOES
glGetTexParameterIivOES
glGetTexParameterIuivOES
glSamplerParameterIivOES
glSamplerParameterIuivOES
glTexParameterIivOES
glTexParameterIuivOES
glTexBufferOES
glTexBufferRangeOES
glTexStorage3DMultisampleOES
GL_OES_texture_view
glTextureViewOES
glBindVertexArrayOES
glDeleteVertexArraysOES
glGenVertexArraysOES
glIsVertexArrayOES
GL_OES_viewport_array
glGetFloati_vOES
glScissorArrayvOES
glScissorIndexedOES
glScissorIndexedvOES
glViewportArrayvOES
glViewportIndexedfOES
glViewportIndexedfvOES
glBlendEquationEXT
GL_EXT_debug_label
glGetObjectLabelEXT
glInsertEventMarkerEXT
glPopGroupMarkerEXT
glPushGroupMarkerEXT
GL_EXT_draw_instanced
glDrawArraysInstancedEXT
glDrawElementsInstancedEXT
glBufferStorageMemEXT
glCreateMemoryObjectsEXT
glDeleteMemoryObjectsEXT
glGetMemoryObjectParameterivEXT
glGetUnsignedBytei_vEXT
glGetUnsignedBytevEXT
glIsMemoryObjectEXT
glMemoryObjectParameterivEXT
glNamedBufferStorageMemEXT
glTexStorageMem2DEXT
glTexStorageMem2DMultisampleEXT
glTexStorageMem3DEXT
glTexStorageMem3DMultisampleEXT
glTextureStorageMem2DEXT
glTextureStorageMem2DMultisampleEXT
glTextureStorageMem3DEXT
glTextureStorageMem3DMultisampleEXT
glImportMemoryFdEXT
GL_EXT_memory_object_win32
glImportMemoryWin32HandleEXT
glImportMemoryWin32NameEXT
GL_EXT_multi_draw_arrays
glMultiDrawArraysEXT
glMultiDrawElementsEXT
glDeleteSemaphoresEXT
glGenSemaphoresEXT
glGetSemaphoreParameterui64vEXT
glIsSemaphoreEXT
glSemaphoreParameterui64vEXT
glSignalSemaphoreEXT
glWaitSemaphoreEXT
glImportSemaphoreFdEXT
GL_EXT_semaphore_win32
glImportSemaphoreWin32HandleEXT
glImportSemaphoreWin32NameEXT
GL_EXT_separate_shader_objects
glActiveShaderProgramEXT
glBindProgramPipelineEXT
glCreateShaderProgramvEXT
glDeleteProgramPipelinesEXT
glGenProgramPipelinesEXT
glGetProgramPipelineInfoLogEXT
glGetProgramPipelineivEXT
glIsProgramPipelineEXT
glProgramParameteriEXT
glProgramUniform1fEXT
glProgramUniform1fvEXT
glProgramUniform1iEXT
glProgramUniform1ivEXT
glProgramUniform1uiEXT
glProgramUniform1uivEXT
glProgramUniform2fEXT
glProgramUniform2fvEXT
glProgramUniform2iEXT
glProgramUniform2ivEXT
glProgramUniform2uiEXT
glProgramUniform2uivEXT
glProgramUniform3fEXT
glProgramUniform3fvEXT
glProgramUniform3iEXT
glProgramUniform3ivEXT
glProgramUniform3uiEXT
glProgramUniform3uivEXT
glProgramUniform4fEXT
glProgramUniform4fvEXT
glProgramUniform4iEXT
glProgramUniform4ivEXT
glProgramUniform4uiEXT
glProgramUniform4uivEXT
glProgramUniformMatrix2fvEXT
glProgramUniformMatrix2x3fvEXT
glProgramUniformMatrix2x4fvEXT
glProgramUniformMatrix3fvEXT
glProgramUniformMatrix3x2fvEXT
glProgramUniformMatrix3x4fvEXT
glProgramUniformMatrix4fvEXT
glProgramUniformMatrix4x2fvEXT
glProgramUniformMatrix4x3fvEXT
glUseProgramStagesEXT
glValidateProgramPipelineEXT
glMaxShaderCompilerThreadsKHR
glDeleteFencesNV
glFinishFenceNV
glGenFencesNV
glGetFenceivNV
glIsFenceNV
glSetFenceNV
glTestFenceNV
GL_NV_framebuffer_mixed_samples
glCoverageModulationNV
GL_NV_internalformat_sample_query
glGetInternalformatSampleivNV
glFramebufferTextureMultiviewOVR
gpu.angle
egl::Display::initialize
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Display.cpp
initialize
ANGLE Display::initialize error 
Failed to initialize display because device creation failed: 
native client buffer allocation failed.
true
Program binary not accessible.
Program binary too large or changed during access.
Failed to copy program binary into the cache.
lose_context_on_out_of_memory
Some users rely on a lost context notification if a GL_OUT_OF_MEMORY error occurs
disable_program_caching_for_transform_feedback
On some GPUs, program binaries don't contain transform feedback varyings
sync_framebuffer_bindings_on_tex_image
On some drivers TexImage sometimes seems to interact with the Framebuffer
scalarize_vec_and_mat_constructor_args
Always rewrite vec/mat constructors to be consistent
http://crbug.com/398694
Disable support for GL_OES_get_program_binary
http://anglebug.com/5007
disable_anisotropic_filtering
Disable support for anisotropic filtering
allow_compressed_formats
Allow compressed formats
ANGLE_DEFAULT_PLATFORM
metal
GPU.ANGLE.DisplayInitializeMS
Unable to query ANGLE's SystemInfo.
Could not create the EAGL context.
Could set the EAGL context current.
Could not open the OpenGLES Framework.
OpenGL ES 2.0 is not supportable.
Could not make device EAGL context current.
Could not release device EAGL context.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
makeCurrent
Unable to make gl context current.
/System/Library/Frameworks/OpenGLES.framework/OpenGLES
DisplayImpl::validateClientBuffer unimplemented.
DisplayImpl::validateImageClientBuffer unimplemented.
DisplayImpl::valdiatePixmap unimplemented.
Google Inc.
 Metal Renderer: 
Metal Renderer
Intel
false
(isOSX || isCatalyst) && !isARM
isMetal2_1 && (isOSX || isCatalyst) && !isARM
supportsEitherGPUFamily(3, 2)
supportsEitherGPUFamily(5, 2)
supportsEitherGPUFamily(3, 1)
supportsEitherGPUFamily(3,1)
isMetal2_1 && !isIntel() && !isNVIDIA()
isMetal2_2 && supportsEitherGPUFamily(3, 2) && !isSimulator
isMetal2_1 && !isNVIDIA()
isAMD()
isOSX || isCatalyst || supportsIOSGPUFamily(3)
isOSX || isCatalyst || supportsIOSGPUFamily(4)
!isOSX && !isCatalyst && !isSimulator
isIntel()
isIntel() && GetMacOSVersion() < OSVersion(11, 0, 0)
v24@?0@"<MTLLibrary>"8@"NSError"16
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/DisplayMtl.mm
getDefaultShadersLib
Internal error: 
has_base_vertex_instanced_draw
The renderer supports base vertex instanced draw
has_depth_texture_filtering
The renderer supports depth texture's filtering other than nearest
has_explicit_mem_barrier
The renderer supports explicit memory barrier
has_cheap_render_pass_mtl
The renderer can cheaply break a render pass.
has_non_uniform_dispatch
The renderer supports non uniform compute shader dispatch's group size
has_stencil_output
The renderer supports stencil output from fragment shader
has_texture_swizzle
The renderer supports texture swizzle
has_msaa_depth_auto_resolve
The renderer supports MSAA depth auto resolve at the end of render pass
has_msaa_stencil_auto_resolve
The renderer supports MSAA stencil auto resolve at the end of render pass
has_mtl_events
The renderer supports MTL(Shared)Event
allow_inline_const_vertex_data
The renderer supports using inline constant data for small client vertex data
allow_separate_depth_stencil_buffers
Some Apple platforms such as iOS allows separate depth & stencil buffers, whereas others such as macOS don't
allow_runtime_sampler_compare_mode
The renderer supports changing sampler's compare mode outside shaders
allow_sampler_compare_gradient
The renderer supports sample_compare with gradients
allow_sampler_compare_lod
The renderer supports sample_compare with lod
allow_buffer_read_write
The renderer supports buffer read & write in the same shader
allow_msaa_store_and_resolve
The renderer supports MSAA store and resolve in the same pass
gen_multiple_mips_per_pass
The renderer supports generating multiple mipmaps per pass
force_d24s8_as_unsupported
Force Depth24Stencil8 format as unsupported.
break_render_pass_is_cheap
Breaking render pass is a cheap operation
force_buffer_gpu_storage
On systems that support both buffer' memory allocation on GPU and shared memory (such as macOS), force using GPU memory allocation for buffers everytime or not.
force_non_cs_mipmap_gen
Turn this feature on to disallow Compute Shader based mipmap generation. Compute Shader based mipmap generation might cause GPU hang on some older iOS devices.
emulate_transform_feedback
Turn this on to allow transform feedback in Metal using a 2-pass VS for GLES3.
rewrite_row_major_matrices
Rewrite row major matrices in shaders as column major.
intel_thin_mipmap_workaround
Generate mipmaps for thin (<5 pixel) wide textures on the CPU for Intel
intel_explicit_bool_cast_workaround
Insert explicit casts for float/double/unsigned/signed int on macOS 10.15 with Intel driver
unique_lock::lock: references null mutex
unique_lock::lock: already locked
unique_lock::unlock: not locked
GMD_FIXED_EMIT
/dev/null
texelFetch
texelFetchOffset
texture1D
texture1DLod
texture1DProjLod
texture2DLod
texture2DProj
texture2DRect
texture2DProjLod
texture2DRectProj
texture3D
texture3DLod
texture3DProjLod
textureCube
textureCubeLod
textureCubeProjLod
textureGrad
textureGradOffset
textureLod
textureLodOffset
textureOffset
textureProj
textureProjGrad
textureProjGradOffset
textureProjLod
textureProjLodOffset
textureProjOffset
textureSize
ANGLE_tensor<
metal::
packed_
-INFINITY
INFINITY
!=/*xor*/
ANGLE_equalStructArray
ANGLE_equal
ANGLE_notEqualStructArray
ANGLE_notEqual
ANGLE_notEqualStruct
kill
return
break
continue
ANGLE_radians
ANGLE_degrees
ANGLE_atan
ANGLE_mod
ANGLE_refract
ANGLE_distance
ANGLE_length
ANGLE_dot
ANGLE_normalize
ANGLE_faceforward
ANGLE_reflect
ANGLE_componentWiseMultiply
ANGLE_outerProduct
ANGLE_sign
metal::abs
metal::all
metal::any
metal::sin
metal::cos
metal::tan
metal::asin
metal::acos
metal::sinh
metal::cosh
metal::tanh
metal::asinh
metal::acosh
metal::atanh
metal::fma
metal::pow
metal::exp
metal::exp2
metal::log
metal::log2
metal::sqrt
metal::floor
metal::trunc
metal::ceil
metal::fract
metal::min
metal::max
metal::round
metal::rint
metal::clamp
ANGLE_mix_bool
metal::mix
metal::step
metal::smoothstep
metal::modf
metal::isnan
metal::isinf
metal::ldexp
metal::frexp
metal::rsqrt
metal::cross
metal::dfdx
metal::dfdy
metal::fwidth
metal::transpose
metal::determinant
ANGLE_inverse
as_type<int>
as_type<uint>
as_type<float>
TOperator_TODO
as_type<int2>
as_type<uint2>
as_type<float2>
as_type<int3>
as_type<uint3>
as_type<float3>
as_type<int4>
as_type<uint4>
as_type<float4>
metal::pack_float_to_unorm2x16
metal::pack_float_to_snorm2x16
metal::pack_float_to_unorm4x8
metal::pack_float_to_snorm4x8
metal::unpack_unorm2x16_to_float
metal::unpack_snorm2x16_to_float
metal::unpack_unorm4x8_to_float
metal::unpack_snorm4x8_to_float
ANGLE_pack_half_2x16
ANGLE_unpack_half_2x16
ANGLE_int_clamp(
, 0, 
.size()
if (
else
 else {}
switch (
case 
default:
 @@XFB-Bindings@@ 
fragment 
vertex __VERTEX_OUT(
 [[stage_in]]
 [[buffer(
metal::sampler
 [[sampler(
 [[texture(
 [[instance_id]]
struct 
char 
 [[flat]]
 [[color(
 [[depth(any)]]
 [[sample_mask, function_constant(
[[id(
 [[position]]
 [[point_size]]
 [[vertex_id]]
 [[point_coord]]
 [[front_facing]]
 [[invariant]]
constant 
for (
while (
metal::discard_fragment()
#if TRANSFORM_FEEDBACK_ENABLED
return;
#else
#endif
gl_FragData
angle_compound_
_frm
_frl
float
vec2
float2
vec3
float3
float4
mat2
float2x2
mat3
float3x3
mat4
float4x4
mat2x3
float2x3
mat2x4
float2x4
mat3x2
float3x2
mat3x4
float3x4
mat4x2
float4x2
mat4x3
float4x3
 angle_frm(
 v) {
    v = clamp(v, -65504.0, 65504.0);
    
 exponent = floor(log2(abs(v) + 1e-30)) - 10.0;
    bool
 isNonZero = exponent < -25.0;
    v = v * exp2(-exponent);
    v = sign(v) * floor(abs(v));
    return v * exp2(exponent) * (float
)(isNonZero);
 angle_frl(
 v) {
    v = clamp(v, -2.0, 2.0);
    v = v * 256.0;
    v = sign(v) * floor(abs(v));
    return v * 0.00390625;
 m) {
 rounded;
    rounded[
] = 
    return rounded;
highp 
 angle_frm(in 
 x) {
    x = clamp(x, -65504.0, 65504.0);
    
 exponent = floor(log2(abs(x) + 1e-30)) - 10.0;
    bool isNonZero = (exponent >= -25.0);
    x = x * exp2(-exponent);
    x = sign(x) * floor(abs(x));
    return x * exp2(exponent) * float(isNonZero);
 angle_frl(in 
 x) {
    x = clamp(x, -2.0, 2.0);
    x = x * 256.0;
    x = sign(x) * floor(abs(x));
    return x * 0.00390625;
 exponent = floor(log2(abs(v) + 1e-30)) - 10.0;
    bvec
 isNonZero = greaterThanEqual(exponent, vec
(-25.0));
    v = v * exp2(-exponent);
    v = sign(v) * floor(abs(v));
    return v * exp2(exponent) * vec
(isNonZero);
(in 
angle_frm
angle_frl
 angle_compound_
_frm(inout 
 x, in 
 y) {
    x = angle_frm(angle_frm(x) 
 y);
    return x;
_frl(inout 
 y) {
    x = angle_frl(angle_frl(x) 
eglInitialize
eglTerminate
eglQueryString
OpenGL_ES
1.5 (ANGLE 2.1.14220 git hash: e4acbac6a5b8)
eglGetConfigs
eglChooseConfig
eglGetConfigAttrib
eglCreateWindowSurface
eglCreatePbufferSurface
eglCreatePixmapSurface
eglDestroySurface
eglQuerySurface
eglCreateContext
eglDestroyContext
eglMakeCurrent
eglGetCurrentSurface
eglQueryContext
eglWaitGL
eglWaitNative
eglSwapBuffers
eglCopyBuffers
eglBindTexImage
eglSurfaceAttrib
eglReleaseTexImage
eglSwapInterval
eglBindAPI
eglCreatePbufferFromClientBuffer
eglReleaseThread
eglWaitClient
eglCreateSync
eglDestroySync
eglClientWaitSync
eglGetSyncAttrib
eglCreateImage
eglDestroyImage
eglGetPlatformDisplay
eglPlatformCreateWindowSurface
eglCreatePlatformPixmapSurface
eglWaitSync
eglQuerySurfacePointerANGLE
eglPostSubBufferNV
eglGetPlatformDisplayEXT
eglCreatePlatformWindowSurfaceEXT
CreatePlatformWindowSurfaceEXT unimplemented.
eglCreatePlatformPixmapSurfaceEXT
CreatePlatformPixmapSurfaceEXT unimplemented.
eglQueryDeviceAttribEXT
Device wasn't created using eglCreateDeviceANGLE, and the egl::Display that created it doesn't support device querying
eglQueryDeviceStringEXT
eglQueryDisplayAttribEXT
eglQueryDisplayAttribANGLE
eglCreateImageKHR
eglDestroyImageKHR
eglCreateDeviceANGLE
eglReleaseDeviceANGLE
eglCreateStreamKHR
eglDestroyStreamKHR
eglStreamAttribKHR
eglQueryStreamKHR
eglQueryStreamu64KHR
eglStreamConsumerGLTextureExternalKHR
eglStreamConsumerAcquireKHR
eglSStreamConsumerReleaseKHR
eglStreamConsumerReleaseKHR
eglStreamConsumerGLTextureExternalAttribsNV
eglCreateStreamProducerD3DTextureANGLE
eglStreamPostD3DTextureANGLE
eglGetMscRateANGLE
eglGetSyncValuesCHROMIUM
eglSwapBuffersWithDamageEXT
eglPresentationTimeANDROID
eglSetBlobCacheFuncsANDROID
eglProgramCacheGetAttribANGLE
eglProgramCacheQueryANGLE
eglProgramCachePopulateANGLE
eglProgramCacheResizeANGLE
eglDebugMessageControlKHR
eglQueryDebugKHR
eglLabelObjectKHR
eglQueryTimestampSupportedANDROID
eglGetCompositorTimingANDROIDD
eglGetNextFrameIdANDROID
eglGetFrameTimestampsANDROID
eglQueryStringiANGLE
eglGetNativeClientBufferANDROID
invalid attribute list.
eglCreateNativeClientBufferANDROID
eglDupNativeFenceFDANDROID
eglSwapBuffersWithFrameTokenANGLE
eglReleaseHighPowerGPUANGLE
eglReacquireHighPowerGPUANGLE
eglHandleGPUSwitchANGLE
eglSignalSyncKHR
Invalid buffer target.
Object cannot be used because it has not been generated.
Textarget must match the texture target type.
Cannot have negative start.
Negative count.
Not enough space in bound transform feedback buffers.
Draw framebuffer is incomplete
Integer overflow.
Offset must be a multiple of the passed in datatype.
Negative offset.
No element array buffer and no pointer.
Insufficient buffer size.
Element value exceeds maximum element index.
Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.
Enum is not currently supported.
Cannot have negative stride.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
Client data cannot be used with a non-default vertex array object.
GL_FIXED is not supported in WebGL.
Index must be less than MAX_VERTEX_ATTRIBS.
Invalid type.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
GL_ANGLE_base_vertex_base_instance
GL_ANGLE_multi_draw
GL_ANGLE_texture_multisample
GL_APPLE_clip_distance
GL_ARB_texture_rectangle
GL_ARM_shader_framebuffer_fetch
GL_EXT_blend_func_extended
GL_EXT_draw_buffers
GL_EXT_frag_depth
GL_EXT_geometry_shader
GL_EXT_gpu_shader5
GL_EXT_shader_framebuffer_fetch
GL_EXT_shader_non_constant_global_initializers
GL_EXT_shader_texture_lod
GL_EXT_shadow_samplers
GL_EXT_texture_buffer
GL_EXT_texture_cube_map_array
GL_EXT_YUV_target
GL_NV_EGL_stream_consumer_external
GL_NV_shader_framebuffer_fetch
GL_NV_shader_noperspective_interpolation
GL_OES_EGL_image_external
GL_OES_EGL_image_external_essl3
GL_OES_shader_multisample_interpolation
GL_OES_shader_image_atomic
GL_OES_standard_derivatives
GL_OES_texture_3D
GL_OES_texture_buffer
GL_OES_texture_cube_map_array
GL_OES_texture_storage_multisample_2d_array
GL_OVR_multiview
GL_OVR_multiview2
GL_WEBGL_video_texture
ANGLE_base_vertex_base_instance
ANGLE_multi_draw
ANGLE_texture_multisample
APPLE_clip_distance
ARB_texture_rectangle
ARM_shader_framebuffer_fetch
EXT_blend_func_extended
EXT_draw_buffers
EXT_frag_depth
EXT_geometry_shader
EXT_gpu_shader5
EXT_shader_framebuffer_fetch
EXT_shader_non_constant_global_initializers
EXT_shader_texture_lod
EXT_shadow_samplers
EXT_texture_buffer
EXT_texture_cube_map_array
EXT_YUV_target
NV_EGL_stream_consumer_external
NV_shader_framebuffer_fetch
NV_shader_noperspective_interpolation
OES_EGL_image_external
OES_EGL_image_external_essl3
OES_shader_multisample_interpolation
OES_shader_image_atomic
OES_standard_derivatives
OES_texture_3D
OES_texture_buffer
OES_texture_cube_map_array
OES_texture_storage_multisample_2d_array
OVR_multiview
OVR_multiview2
WEBGL_video_texture
require
enable
warn
disable
GL_ARB_shader_bit_encoding
GL_ARB_shading_language_packing
GL_NV_fence
glFenceSync failed to create a GLsync object.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/FenceNVGL.cpp
glClientWaitSync did not return GL_ALREADY_SIGNALED or GL_CONDITION_SATISFIED.
finish
GL_ARB_sync
GL_ARB_texture_rg
GL_ARB_texture_rgb10_a2ui
GL_EXT_texture_sRGB
GL_EXT_bgra
GL_EXT_packed_float
GL_EXT_packed_float GL_ARB_color_buffer_float
GL_EXT_texture_shared_exponent
GL_ARB_texture_rg ARB_texture_float
GL_ARB_texture_rg GL_ARB_texture_float GL_ARB_color_buffer_float
GL_OES_texture_half_float GL_EXT_texture_rg
GL_EXT_texture_storage GL_OES_texture_half_float GL_EXT_texture_rg GL_EXT_color_buffer_half_float
GL_EXT_texture_rg GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_ARB_texture_float
GL_ARB_texture_float GL_ARB_color_buffer_float
GL_OES_texture_half_float
GL_EXT_texture_storage GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_OES_texture_half_float GL_EXT_color_buffer_half_float
GL_ARB_texture_rg GL_ARB_texture_float
GL_OES_texture_float GL_EXT_texture_rg
GL_ARB_depth_texture
GL_ARB_depth_buffer_float
GL_EXT_packed_depth_stencil
GL_OES_depth_texture GL_OES_packed_depth_stencil
GL_ARB_texture_compression_rgtc
GL_ARB_texture_compression_bptc
GL_ARB_ES3_compatibility
OES_compressed_EAC_R11_unsigned_texture
OES_compressed_EAC_R11_signed_texture
OES_compressed_EAC_RG11_unsigned_texture
OES_compressed_EAC_RG11_signed_texture
OES_compressed_ETC2_RGB8_texture
OES_compressed_ETC2_sRGB8_texture
OES_compressed_ETC2_punchthroughA_RGBA8_texture
OES_compressed_ETC2_punchthroughA_sRGB8_alpha_texture
OES_compressed_ETC2_RGBA8_texture
OES_compressed_ETC2_sRGB8_alpha8_texture
GL_EXT_texture_compression_s3tc
GL_EXT_texture_compression_s3tc GL_NV_sRGB_formats
glReadPixels: GL_IMPLEMENTATION_COLOR_READ_FORMAT advertised by the driver is not handled by RGBA16 readPixels workaround.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/FramebufferGL.cpp
readPixels
checkStatus
GL framebuffer returned incomplete.
readPixelsRowByRow
readPixelsAllAtOnce
Initialize
RearrangeEXTTextureNorm16Pixels
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/FrameBufferMtl.mm
checkPackedDepthStencilAttachment
Packed depth stencil texture/buffer must not be mixed with other texture/buffer.
readPixelsImpl
readPixelsToPBO
readPixelsToBuffer
v8@?0
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/FunctionsEAGL.mm
OpenGLESLibrary_block_invoke
! Assert failed in 
frameworkLibrary
! Message: 
Unable to load OpenGLES.framework
EAGLContext
initEAGLContext_block_invoke
classEAGLContext
objc_getClass failed for EAGLContext
Missing shader object
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/GLES1Renderer.cpp
compileShader
Internal GLES 1 shader compile failed. Info log: 
GLES1Renderer shader compile failed.
Missing program object
linkProgram
Internal GLES 1 shader link failed. Info log: 
GLES1Renderer program link failed.
normal
color
pointsize
texcoord
projection
modelview
texture_matrix
modelview_invtr
tex_sampler
tex_cube_sampler
enable_texture_2d
enable_texture_cube_map
texture_format
texture_env_mode
combine_rgb
combine_alpha
src0_rgb
src0_alpha
src1_rgb
src1_alpha
src2_rgb
src2_alpha
op0_rgb
op0_alpha
op1_rgb
op1_alpha
op2_rgb
op2_alpha
texture_env_color
texture_env_rgb_scale
texture_env_alpha_scale
point_sprite_coord_replace
enable_alpha_test
alpha_func
alpha_test_ref
shade_model_flat
enable_lighting
enable_rescale_normal
enable_normalize
enable_color_material
material_ambient
material_diffuse
material_specular
material_emissive
material_specular_exponent
light_model_scene_ambient
light_model_two_sided
light_enables
light_ambients
light_diffuses
light_speculars
light_positions
light_directions
light_spotlight_exponents
light_spotlight_cutoff_angles
light_attenuation_consts
light_attenuation_linears
light_attenuation_quadratics
enable_fog
fog_mode
fog_density
fog_start
fog_end
fog_color
enable_clip_planes
clip_plane_enables
clip_planes
point_rasterization
point_size_min
point_size_max
point_distance_attenuation
point_sprite_enabled
enable_draw_texture
draw_texture_coords
draw_texture_dims
draw_texture_normalized_crop_rect
Context has been lost.
Illegal character at fieldname start
fatal flex scanner internal error--no action found
out of dynamic memory in yy_create_buffer()
yyset_column called with no buffer
GL_FRAGMENT_PRECISION_HIGH
fatal flex scanner internal error--end of buffer missed
fatal error - scanner input buffer overflow
out of dynamic memory in yy_get_next_buffer()
Input buffer overflow
out of dynamic memory in yyensure_buffer_stack()
Illegal use of reserved word
Unsigned integers are unsupported prior to GLSL ES 3.00
Integer overflow
Floating-point suffix unsupported prior to GLSL ES 3.00
Float overflow
unsupported value
methods supported in GLSL ES 3.00 and above only
bit-wise operator supported in GLSL ES 3.00 and above only
integer modulus operator supported in GLSL ES 3.00 and above only
interface blocks supported in GLSL ES 3.00 and above only
cannot be a parameter type except for '(void)'
void
first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
unsupported interpolation qualifier
noperspective
layout
 supported in vertex shaders only
 supported in GLSL ES 1.00 only
storage qualifier supported in GLSL ES 3.00 and above only
centroid
storage qualifier supported in GLSL ES 3.10 only
buffer
 supported in compute shaders only
shared
sample
qualifier supported in GLSL ES 3.00 and above only
implicitly sized array supported in GLSL ES 3.00 and above only
arrays of arrays supported in GLSL ES 3.10 only
unsupported type
yuvCscStandardEXT
__samplerCubeArray
__samplerBuffer
__isamplerCubeArray
__isamplerBuffer
__usamplerCubeArray
__usamplerBuffer
__samplerCubeArrayShadow
samplerVideoWEBGL
__samplerExternal2DY2YEXT
__imageCubeArray
__iimageCubeArray
__uimageCubeArray
__imageBuffer
__iimageBuffer
__uimageBuffer
syntax error
memory exhausted
itu_601
itu_601_full_range
itu_709
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/HandleAllocator.cpp
allocate
HandleAllocator::allocate reusing 
HandleAllocator::allocate allocating 
release
HandleAllocator::release releasing 
reserve
HandleAllocator::reserve reserving 
gl_ClipDistance
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ImageMtl.mm
ValidateClientBuffer
Unrecognized format
WARNING: 
ERROR: 
UNKOWN ERROR: 
invariant 
readonly 
writeonly 
coherent 
restrict 
volatile 
array[
] of 
 matrix of 
-component vector of 
Temporary
Global
const
uniform
inout
VertexID
Position
PointSize
DrawID
BaseVertex
BaseInstance
FragCoord
FrontFacing
HelperInvocation
PointCoord
FragColor
FragData
FragDepth
SecondaryFragColorEXT
SecondaryFragDataEXT
SampleMask
ViewIDOVR
ViewportIndex
Layer
LastFragColor
LastFragData
smooth out
smooth centroid out
flat out
noperspective out
smooth in
flat in
noperspective in
smooth centroid in
flat
smooth
NumWorkGroups
WorkGroupSize
WorkGroupID
LocalInvocationID
GlobalInvocationID
LocalInvocationIndex
readonly
writeonly
precise
ClipDistance
sample in
sample out
unknown qualifier
highp
mediump
lowp
casting a negative float to uint is undefined
Zero divided by zero during constant folding generated NaN
Divide by zero during constant folding
Infinity divided by infinity during constant folding generated NaN
Constant folded division overflowed to infinity
Divide by zero error during constant folding
Negative modulus operator operand encountered during constant folding. Results are undefined.
operation result is undefined for the values passed in
instanceIdMod
Failed to set pixel unpack state.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/IOSurfaceSurfaceEAGL.mm
createDefaultFramebuffer
IOSurfaces with OpenGL ES not supported on iOS Simulator
Failed to initialize IOSurface alpha channel.
__LINE__
__FILE__
e4acbac6a5b8
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/MemoryProgramCache.cpp
getProgram
Failure to decompressed binary data: 
GPU.ANGLE.ProgramCache.LoadBinarySuccess
Failed to load binary from cache.
Reaching warning limit for cache load failures, silencing subsequent warnings.
putProgram
Failed to allocate enough memory to hold compressed program. (
 bytes )
Error compressing binary data: 
Failed to resize to actual compressed program size. (
GPU.ANGLE.ProgramCache.ProgramBinarySizeBytes
originalToModified
modifiedToOriginal
original
modified
flatten
v16@?0@"<MTLCommandBuffer>"8
Invalid ASCII string
[[attribute(
        
ANGLE_
xfbBuffer
.ANGLE_xfbBufferOffsets[
] + (gl_VertexID + ANGLE_instanceIdMod * 
.ANGLE_xfbVerticesPerDraw) * 
ANGLE_vertexOut.
device float* ANGLE_
#if TRANSFORM_FEEDBACK_ENABLED
    if (ANGLE_
.ANGLE_xfbActiveUnpaused != 0)
    {
    }
#endif
OcclusionQueryPool
clearIntFS
clearUIntFS
clearFloatFS
blitIntFS
blitUIntFS
blitFloatFS
copyTextureFloatToUIntFS
readFromBufferToIntTexture
writeFromIntTextureToBuffer
readFromBufferToUIntTexture
writeFromUIntTextureToBuffer
readFromBufferToFloatTexture
writeFromFloatTextureToBuffer
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_render_utils.mm
handleError
Metal backend encountered an internal error. Code=
Metal backend encountered an internal error: 
clearVS
kNumColorOutputs
blitVS
kPremultiplyAlpha
kUnmultiplyAlpha
kSourceTextureType
blitDepthStencilFS
blitDepthFS
blitStencilFS
kSourceTexture2Type
blitStencilToBufferCS
kSourceBufferAligned
convertIndexU8ToU16
convertIndexU16
convertIndexU32
kSourceIndexIsU8
kSourceIndexIsU16
kSourceIndexIsU32
genTriFanIndicesFromArray
genLineLoopIndicesFromArray
Index offset is too large
generateTriFanBufferFromElementsArray
genTriFanIndicesFromElements
generateLineLoopBufferFromElementsArray
genLineLoopIndicesFromElements
generateLineLoopLastSegmentFromElementsArray
kCombineWithExistingResult
combineVisibilityResult
generate3DMipmaps
generate2DMipmaps
generate2DArrayMipmaps
generateCubeMipmaps
kCopyFormatType
kCopyTextureType
expandVertexFormatComponentsCS
expandVertexFormatComponentsVS
convertToFloatVertexFormatCS
convertToFloatVertexFormatVS
TRANSFORM_FEEDBACK_ENABLED
TransformFeedback
main0
EnsureSpecializedComputePipelineInitialized
EnsureComputePipelineInitialized
EnsureSpecializedVertexShaderOnlyPipelineCacheInitialized
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_resources.mm
MakeTexture
resize
MakeBufferWithSharedMemOpt
MakeBufferWithResOpt
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_state_cache.mm
createRenderPipelineState
createComputePipelineState
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/mtl_utils.mm
Failed to create a scratch index buffer for GL_TRIANGLE_FAN, too many indices required.
TriangleFanBoundCheck
Internal error compiling Metal shader:
CreateMslShader
Radeon
Geforce
Quadro
.length()
equal
notEqual
lessThan
greaterThan
lessThanEqual
greaterThanEqual
radians
degrees
asin
acos
atan
sinh
cosh
tanh
asinh
acosh
atanh
exp2
log2
sqrt
inversesqrt
sign
floor
trunc
round
roundEven
ceil
fract
modf
step
smoothstep
isnan
isinf
floatBitsToInt
floatBitsToUint
intBitsToFloat
uintBitsToFloat
frexp
ldexp
packSnorm2x16
packUnorm2x16
packHalf2x16
unpackSnorm2x16
unpackUnorm2x16
unpackHalf2x16
packUnorm4x8
packSnorm4x8
unpackUnorm4x8
unpackSnorm4x8
length
distance
cross
normalize
faceforward
reflect
refract
dFdx
dFdy
fwidth
matrixCompMult
outerProduct
transpose
determinant
inverse
bitfieldExtract
bitfieldInsert
bitfieldReverse
bitCount
findLSB
findMSB
uaddCarry
usubBorrow
umulExtended
imulExtended
barrier
memoryBarrier
memoryBarrierAtomicCounter
memoryBarrierBuffer
memoryBarrierImage
memoryBarrierShared
groupMemoryBarrier
atomicAdd
atomicMin
atomicMax
atomicAnd
atomicOr
atomicXor
atomicExchange
atomicCompSwap
EmitVertex
EndPrimitive
textureVideoWEBGL
gl_FragDepthEXT
webgl_FragColor
webgl_FragData
gl_SecondaryFragColorEXT
angle_SecondaryFragColor
gl_SecondaryFragDataEXT
angle_SecondaryFragData
texture2DLodEXT
texture2DProjLodEXT
textureCubeLodEXT
texture2DGradEXT
texture2DGradARB
texture2DProjGradEXT
texture2DProjGradARB
textureCubeGradEXT
textureCubeGradARB
texture3DProj
shadow2DEXT
shadow2DProjEXT
precise 
uintBitsToFloat(
index = 
offset = 
layout(
location = 
binding = 
column_major
row_major
 += 
 -= 
 /= 
 %= 
 *= 
 <<= 
 >>= 
 &= 
 ^= 
 |= 
[int(clamp(float(
[webgl_int_clamp(
), 0.0, float(
.length() - 1
)))]
 << 
 >> 
 == 
 != 
 <= 
 >= 
 || 
 ^^ 
 && 
).length())
) ? (
) : (
case (
discard
return 
#define
#endif
#ifdef
packed
std140
std430
layout (
invocations = 
) in;
max_vertices = 
) out;
rgba32f
rgba16f
r32f
rgba32ui
rgba16ui
rgba8ui
r32ui
rgba32i
rgba16i
rgba8i
r32i
rgba8
rgba8_snorm
unknown internal image format
unknown color space conversion standard
points
lines
triangles
lines_adjacency
triangles_adjacency
line_strip
triangle_strip
unknown geometry shader primitive type
(symbol id 
const bool
 (const float)
 (const int)
 (const uint)
 (const yuvCscStandardEXT)
Unknown constant
vector swizzle (
comma
move second child to first child
initialize first child with second child
add second child into first child
subtract second child into first child
multiply second child into first child
matrix mult second child into first child
vector scale second child into first child
matrix scale second child into first child
divide second child into first child
modulo second child into first child
bit-wise shift first child left by second child
bit-wise shift first child right by second child
bit-wise and second child into first child
bit-wise xor second child into first child
bit-wise or second child into first child
direct index
indirect index
direct index for structure
direct index for interface block
subtract
component-wise multiply
divide
modulo
bit-wise shift left
bit-wise shift right
bit-wise and
bit-wise xor
bit-wise or
Compare Equal
Compare Not Equal
Compare Less Than
Compare Greater Than
Compare Less Than or Equal
Compare Greater Than or Equal
vector-scale
vector-times-matrix
matrix-times-vector
matrix-scale
matrix-multiply
logical-or
logical-xor
logical-and
<unknown op>
 (field '
Negate value
Positive sign
negation
bit-wise not
Post-Increment
Post-Decrement
Pre-Increment
Pre-Decrement
Array length
component-wise not
Ternary selection
Condition
true case
false case
If test
true case is null
Switch
Default
Case
Function Prototype
parameter: 
 (internal function)
 (symbol id 
Function Definition:
node is still EOpNull!
Call a user-defined function
Call an internal function with raw implementation
Call a built-in function
Construct
component-wise equal
component-wise not equal
component-wise less than
component-wise greater than
component-wise less than or equal
component-wise greater than or equal
dot product
cross product
Code block
Precise Declaration:
Invariant Declaration:
Declaration
Loop with condition 
not 
tested first
Loop Condition
No loop condition
Loop Body
No loop body
Loop Terminal Expression
Branch: Kill
Branch: Break
Branch: Continue
Branch: Return
Branch: Unknown Branch
 with expression
unknown matrix packing
extension is not supported
extension is disabled
extension is being used
illegal vector field selection
vector field selection out of range
illegal - vector component fields not from the same set
cannot convert from '
' to '
wrong operand type - no operation '
' exists that takes an operand of type 
 (or there is no acceptable conversion)
wrong operand types - no operation '
' exists that takes a left-hand operand of type '
' and a right operand of type '
' (or there is no acceptable conversion)
illegal type for precision qualifier
No precision specified for (float)
No precision specified (int)
No precision specified
 l-value of swizzle cannot have duplicate components
can't modify a readonly variable
 l-value required
can't modify a const
can't modify an attribute
can't modify an input
can't modify a uniform
can't modify a varying
can't modify gl_FragCoord
can't modify gl_FrontFacing
can't modify gl_HelperInvocation
can't modify gl_PointCoord
can't modify gl_NumWorkGroups
can't modify gl_WorkGroupSize
can't modify gl_WorkGroupID
can't modify gl_LocalInvocationID
can't modify gl_GlobalInvocationID
can't modify gl_LocalInvocationIndex
can't modify gl_ViewID_OVR
can't modify work group size variable
can't modify any member in gl_in
can't modify gl_PrimitiveIDIn
can't modify gl_InvocationID
can't modify gl_PrimitiveID in a fragment shader
can't modify gl_Layer in a fragment shader
can't modify void
can't modify a variable with type 
l-value required
constant expression required
integer expression required
only allowed at global scope
reserved built-in name
webgl_
_webgl_
identifiers containing two consecutive underscores (__) are reserved as possible future keywords
constructor does not have any arguments
constructor
cannot convert a variable with type 
cannot convert a variable with writeonly
cannot convert a void
array constructor needs one argument per array element
constructing from a non-dereferenced array
Array constructor argument has an incorrect type
Number of constructor parameters does not match the number of structure fields
Structure constructor arguments do not match structure fields
a struct cannot be used as a constructor argument for this type
constructing matrix from matrix can only take one argument
not enough data provided for construction
too many arguments
illegal use of type 'void'
boolean expression expected
 (structure contains a sampler)
location must only be specified for a single input or output variable
location
invalid layout qualifier: only valid on program inputs and outputs
invalid layout qualifier: only valid on shader inputs, outputs, and uniforms
The std430 layout is supported only for shader storage blocks.
opaque types cannot be output parameters
array size must be a constant integer expression
array size must be non-negative
array size must be greater than zero
array size too large
cannot declare arrays of this qualifier
cannot declare arrays of arrays
vertex shader output cannot be an array of arrays
fragment shader input cannot be an array of arrays
fragment shader output cannot be an array of arrays
cannot declare arrays of structs of this qualifier
structures containing arrays may not be declared constant since they cannot be initialized
variables with qualifier 'const' must be initialized
implicitly sized arrays need to be initialized
If index layout qualifier is specified for a fragment output, location must also be specified.
index
gl_LastFragData
gl_MaxDrawBuffers
redeclaration of gl_LastFragData as an array of arrays
redeclaration of gl_LastFragData with size != gl_MaxDrawBuffers
gl_MaxClipDistances
redeclaration of gl_ClipDistance as an array of arrays
redeclaration of gl_ClipDistance with size > gl_MaxClipDistances
redefinition
Shared memory declarations cannot have layout specified
layout
layout qualifier only valid for interface blocks
invalid layout qualifier combination
Can only be highp
atomic counter
location must not be set for atomic_uint
no binding specified
empty array declaration needs to specify a size
cannot be used with a structure
cannot declare buffer variables at global scope(outside a block)
s must be uniform
cannot be used with a yuvCscStandardEXT
internal image format requires a floating image type
internal image format requires an integer image type
internal image format requires an unsigned image type
layout qualifier
No image internal format specified
unrecognized token
Except for images with the r32f, r32i and r32ui format qualifiers, image variables must be qualified readonly and/or writeonly
invalid layout qualifier: not supported
invalid layout qualifier: only valid when used with 'in' in a compute shader global layout declaration
invalid layout qualifier: only valid when used with images
invalid layout qualifier: only valid when used with a fragment shader output in ESSL version >= 3.00 and EXT_blend_func_extended is enabled
invalid layout qualifier: only valid when used with opaque types or blocks
binding
invalid layout qualifier: only valid when used with atomic counters
offset
image binding greater than gl_MaxImageUnits
sampler binding greater than maximum texture units
uniform block binding greater than MAX_UNIFORM_BUFFER_BINDINGS
shader storage block binding greater than MAX_SHADER_STORAGE_BUFFER_BINDINGS
atomic counter binding greater than gl_MaxAtomicCounterBindings
Uniform location out of range
Attribute location out of range
invalid layout qualifier: only valid on program outputs
invalid layout qualifier: only valid when used with 'in' in a fragment shader
early_fragment_tests
Writeonly value cannot be passed for 'in' or 'inout' parameters.
assign
Constant value cannot be passed for 'out' or 'inout' parameters.
Cannot be qualified as invariant.
invariant
undeclared identifier
variable expected
It is an error to use gl_WorkGroupSize before declaring the local group size
gl_WorkGroupSize
assigning non-constant to '
global variable initializers must be constant expressions
global variable initializers should be constant expressions (uniforms and globals are allowed in global initializers for legacy compatibility)
 cannot initialize this type of qualifier 
not supported
first-class array
cannot be bool or int
'in' can be only used to specify the local group size
cannot be bool
cannot be array
cannot be matrix
must use 'flat' interpolation here
cannot be an array of structures
cannot be a structure containing an array
cannot be a structure containing a structure
cannot be a structure containing a bool
Local variables can only use the const storage qualifier.
Only allowed with shader storage blocks, variables declared within shader storage blocks and variables declared as image types.
coherent
restrict
volatile
Offset overlapping
Offset must be multiple of 4
Missing a valid input primitive declaration before declaring an unsized array input
Geometry shader input variable must be declared as an array
Expected invariant or precise
invariant varying
undeclared identifier declared as invariant or precise
invariant or precise declaration specifies qualifier
invariant or precise declaration specifies precision
invariant or precise declaration specifies layout
'layout'
Requires both binding and offset
precision is not supported in fragment shader
highp
illegal type argument for default precision qualifier
Array size or input primitive declaration doesn't match the size of earlier sized array inputs.
max_vertices can only be declared in 'out' layout in a geometry shader
invalid primitive type for 'in' layout
primitive doesn't match earlier input primitive declaration
invocations contradicts to the earlier declaration
invocations can only be declared in 'in' layout in a geometry shader
invalid primitive type for 'out' layout
primitive doesn't match earlier output primitive declaration
max_vertices contradicts to the earlier declaration
Error during layout qualifier parsing.
Work group size does not match the previous declaration
in type qualifier supported in GLSL ES 3.10 only
No local work group size specified
gl_MaxComputeWorkGroupSize
invalid value: Value must be at least 1 and no greater than 
out type qualifier supported in GLSL ES 3.10 only
Number of views does not match the previous declaration
No num_views specified
num_views greater than the value of GL_MAX_VIEWS_OVR
in type qualifier without variable declaration supported in GLSL ES 3.10 only
only early_fragment_tests is allowed as layout qualifier when not declaring a variable
invalid qualifier: global layout can only be set for blocks
layout qualifiers supported in GLSL ES 3.00 and above
function parameter array must be sized at compile time
duplicate function prototype declarations are not allowed
function
local function prototype declarations are not allowed
function does not return a value:
function already has a body
Function parameter type cannot be a structure definition
Name of a built-in function cannot be redeclared as function
built-in functions cannot be redefined
function must have the same return type in all of its declarations
function must have the same parameter qualifiers in all of its declarations
redefinition of a function
function cannot take any parameter(s)
main
main function cannot return a value
no qualifiers allowed for function return
s can't be function return values
structures containing arrays can't be function return values
array constructor supported in GLSL ES 3.00 and above only
constructor can't be a structure definition
cannot construct this type
function parameter array must specify a size
implicitly sized array constructor must have at least one argument
implicitly sized array of arrays constructor argument is not an array
implicitly sized array of arrays constructor argument dimensionality is too low
invalid qualifier: interface blocks must be uniform in version lower than GLSL ES 3.10
invalid qualifier: interface blocks must be uniform or buffer
invalid qualifier on interface block member
unsupported type - 
 types are not allowed in interface blocks
invalid qualifier on shader storage block member
invalid qualifier on uniform block member
invalid layout qualifier: cannot be used here
extraneous layout qualifier: only has an effect on matrix types
array members of interface blocks must specify a size
redefinition of an interface block name
redefinition of an interface block member name
redefinition of an interface block instance name
Embedded struct definitions are not allowed
struct
Struct nesting
Reference of struct type 
 exceeds maximum allowed nesting level of 
 left of '[' is not of type array, matrix, or vector 
expression
missing input primitive declaration before indexing gl_in.
array indexes for uniform block arrays must be constant integral expressions
array indexes for shader storage block arrays must be constant integral expressions
array indexes for fragment outputs must be constant integral expressions
array index for gl_FragData must be constant zero
array index for samplers must be constant integral expressions
array indexes for image arrays must be constant integral expressions
index expression is negative
array index for gl_FragData must be zero when GL_EXT_draw_buffers is disabled
array index out of range
matrix field selection out of range
cannot apply dot operator to an array
structure has no fields
Internal Error
 no such field in structure
interface block has no fields
 no such field in interface block
 field selection requires structure or vector on left hand side
 field selection requires structure, vector, or interface block on left hand side
Only std140 layout is allowed in WebGL
invalid layout qualifier: location requires an argument
points
lines
lines_adjacency
triangles
triangles_adjacency
line_strip
triangle_strip
invalid layout qualifier
out of range: 
 must be positive
out of range: num_views must be positive
out of range: invocations must be in the range of [1, MAX_GEOMETRY_SHADER_INVOCATIONS_OES]
out of range: max_vertices must be in the range of [0, gl_MaxGeometryOutputVertices]
out of range: index layout qualifier can only be 0 or 1
out of range: location must be non-negative
out of range: binding must be non-negative
out of range: offset must be non-negative
local_size_x
local_size_y
local_size_z
num_views
invocations
max_vertices
storage qualifier isn't supported in compute shaders
invalid qualifier: can be only used with function parameters
inout
duplicate field name in structure
redefinition of a struct
invalid qualifier on struct member
disallowed type in struct
array members of structs must specify a size
init-expression in a switch statement must be a scalar integer
switch
case labels need to be inside switch statements
case
case label must have a condition
case label must be a scalar integer
case label must be constant
default labels need to be inside switch statements
default
Invalid operation for variables with an opaque type
Invalid operation for variables with writeonly
Invalid operation for structs
Invalid operation for interface blocks
array / non-array mismatch
Invalid operation for arrays
array size mismatch
undefined operation for structs containing arrays
undefined operation for structs containing samplers
dimension mismatch
comparison operator only defined for scalars
sequence operator is not allowed for void, arrays, or structs containing arrays
continue statement only allowed in loops
break statement only allowed in loops and switch statements
non-void function must return a value
return
discard supported in fragment shaders only
discard
void function cannot return a value
function return is not matching type:
Texture component must be a constant expression
Component must be in the range [0;3]
Texture offsets must be a constant expression
Texture offsets must be an array of 4 elements
Texture offset must be a constant expression
Texture offset value out of valid range
first argument must be an interpolant, or interpolant-array element
The value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable.
'imageStore' cannot be used with images qualified as 'readonly'
'imageLoad' cannot be used with images qualified as 'writeonly'
'imageAtomic' cannot be used with images qualified as 'readonly'
'imageAtomic' cannot be used with images qualified as 'writeonly'
Function call discards the 'readonly' qualifier from image
Function call discards the 'writeonly' qualifier from image
Function call discards the 'coherent' qualifier from image
Function call discards the 'volatile' qualifier from image
invalid method
method takes no parameters
length can only be called on arrays
missing input primitive declaration before calling length on gl_in
function name expected
no matching overloaded function found
mismatching ternary operator operand types '
 and '
ternary operator is not allowed for opaque types
ternary operator is not allowed for variables with writeonly
ternary operator is not allowed for structures or arrays
ternary operator is not allowed for interface blocks
ternary operator is not allowed for void
unknown block storage
dimension out of bounds
mediump
lowp
image
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/eagl/PbufferSurfaceEAGL.cpp
bindTexImage
PbufferSurfaceEAGL::bindTexImage
VertexInMod
VertexIn
VertexOutMod
VertexOut
FragmentInMod
FragmentIn
FragmentOutMod
FragmentOut
UserUniformsMod
UserUniforms
AngleUniformsMod
AngleUniforms
NonConstGlobalsMod
NonConstGlobals
InvocationVertexGlobalsMod
InvocationVertexGlobals
InvocationFragmentGlobalsMod
InvocationFragmentGlobals
TextureEnvsMod
TextureEnvs
InstanceIdMod
InstanceId
UniformBufferMod
UniformBuffer
vertexInMod
vertexIn
vertexOutMod
vertexOut
fragmentInMod
fragmentIn
fragmentOutMod
fragmentOut
userUniformsMod
userUniforms
angleUniformsMod
angleUniforms
nonConstGlobalsMod
nonConstGlobals
invocationVertexGlobalsMod
invocationVertexGlobals
invocationFragmentGlobalsMod
invocationFragmentGlobals
textureEnvsMod
textureEnvs
instanceIdMod
instanceId
uniformBufferMod
uniformBuffer
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Platform.cpp
ANGLEGetDisplayPlatform
Invalid platform method count: 
, expected 
Invalid platform method name: 
currentTime
monotonicallyIncreasingTime
logError
logWarning
logInfo
getTraceCategoryEnabledFlag
addTraceEvent
updateTraceEventDuration
histogramCustomCounts
histogramEnumeration
histogramSparse
histogramBoolean
overrideWorkaroundsD3D
overrideFeaturesVk
cacheProgram
overrideFeaturesMtl
postWorkerTask
__LINE__
__FILE__
__VERSION__
GL_ES
Integer overflow on line number
EOF while in a comment
out of dynamic memory in yy_create_buffer()
yyset_lineno called with no buffer
out of dynamic memory in yyensure_buffer_stack()
ANGLEGetDisplayPlatform
ANGLEResetDisplayPlatform
eglBindAPI
eglBindTexImage
eglChooseConfig
eglClientWaitSync
eglClientWaitSyncKHR
eglCopyBuffers
eglCreateContext
eglCreateDeviceANGLE
eglCreateImage
eglCreateImageKHR
eglCreateNativeClientBufferANDROID
eglCreatePbufferFromClientBuffer
eglCreatePbufferSurface
eglCreatePixmapSurface
eglCreatePlatformPixmapSurface
eglCreatePlatformPixmapSurfaceEXT
eglCreatePlatformWindowSurface
eglCreatePlatformWindowSurfaceEXT
eglCreateStreamKHR
eglCreateStreamProducerD3DTextureANGLE
eglCreateSync
eglCreateSyncKHR
eglCreateWindowSurface
eglDebugMessageControlKHR
eglDestroyContext
eglDestroyImage
eglDestroyImageKHR
eglDestroyStreamKHR
eglDestroySurface
eglDestroySync
eglDestroySyncKHR
eglDupNativeFenceFDANDROID
eglGetCompositorTimingANDROID
eglGetCompositorTimingSupportedANDROID
eglGetConfigAttrib
eglGetConfigs
eglGetCurrentContext
eglGetCurrentDisplay
eglGetCurrentSurface
eglGetDisplay
eglGetError
eglGetFrameTimestampSupportedANDROID
eglGetFrameTimestampsANDROID
eglGetMscRateANGLE
eglGetNativeClientBufferANDROID
eglGetNextFrameIdANDROID
eglGetPlatformDisplay
eglGetPlatformDisplayEXT
eglGetProcAddress
eglGetSyncAttrib
eglGetSyncAttribKHR
eglGetSyncValuesCHROMIUM
eglHandleGPUSwitchANGLE
eglInitialize
eglLabelObjectKHR
eglMakeCurrent
eglPostSubBufferNV
eglPresentationTimeANDROID
eglProgramCacheGetAttribANGLE
eglProgramCachePopulateANGLE
eglProgramCacheQueryANGLE
eglProgramCacheResizeANGLE
eglQueryAPI
eglQueryContext
eglQueryDebugKHR
eglQueryDeviceAttribEXT
eglQueryDeviceStringEXT
eglQueryDisplayAttribANGLE
eglQueryDisplayAttribEXT
eglQueryStreamKHR
eglQueryStreamu64KHR
eglQueryString
eglQueryStringiANGLE
eglQuerySurface
eglQuerySurfacePointerANGLE
eglReacquireHighPowerGPUANGLE
eglReleaseDeviceANGLE
eglReleaseHighPowerGPUANGLE
eglReleaseTexImage
eglReleaseThread
eglSetBlobCacheFuncsANDROID
eglSignalSyncKHR
eglStreamAttribKHR
eglStreamConsumerAcquireKHR
eglStreamConsumerGLTextureExternalAttribsNV
eglStreamConsumerGLTextureExternalKHR
eglStreamConsumerReleaseKHR
eglStreamPostD3DTextureANGLE
eglSurfaceAttrib
eglSwapBuffers
eglSwapBuffersWithDamageKHR
eglSwapBuffersWithFrameTokenANGLE
eglSwapInterval
eglTerminate
eglWaitClient
eglWaitGL
eglWaitNative
eglWaitSync
eglWaitSyncKHR
glActiveShaderProgram
glActiveShaderProgramContextANGLE
glActiveTexture
glActiveTextureContextANGLE
glAlphaFunc
glAlphaFuncContextANGLE
glAlphaFuncx
glAlphaFuncxContextANGLE
glAttachShader
glAttachShaderContextANGLE
glBeginQuery
glBeginQueryContextANGLE
glBeginQueryEXT
glBeginQueryEXTContextANGLE
glBeginTransformFeedback
glBeginTransformFeedbackContextANGLE
glBindAttribLocation
glBindAttribLocationContextANGLE
glBindBuffer
glBindBufferBase
glBindBufferBaseContextANGLE
glBindBufferContextANGLE
glBindBufferRange
glBindBufferRangeContextANGLE
glBindFragDataLocationEXT
glBindFragDataLocationEXTContextANGLE
glBindFragDataLocationIndexedEXT
glBindFragDataLocationIndexedEXTContextANGLE
glBindFramebuffer
glBindFramebufferContextANGLE
glBindFramebufferOES
glBindFramebufferOESContextANGLE
glBindImageTexture
glBindImageTextureContextANGLE
glBindProgramPipeline
glBindProgramPipelineContextANGLE
glBindRenderbuffer
glBindRenderbufferContextANGLE
glBindRenderbufferOES
glBindRenderbufferOESContextANGLE
glBindSampler
glBindSamplerContextANGLE
glBindTexture
glBindTextureContextANGLE
glBindTransformFeedback
glBindTransformFeedbackContextANGLE
glBindUniformLocationCHROMIUM
glBindUniformLocationCHROMIUMContextANGLE
glBindVertexArray
glBindVertexArrayContextANGLE
glBindVertexArrayOES
glBindVertexArrayOESContextANGLE
glBindVertexBuffer
glBindVertexBufferContextANGLE
glBlendBarrier
glBlendBarrierContextANGLE
glBlendColor
glBlendColorContextANGLE
glBlendEquation
glBlendEquationContextANGLE
glBlendEquationSeparate
glBlendEquationSeparateContextANGLE
glBlendEquationSeparatei
glBlendEquationSeparateiContextANGLE
glBlendEquationSeparateiEXT
glBlendEquationSeparateiEXTContextANGLE
glBlendEquationSeparateiOES
glBlendEquationSeparateiOESContextANGLE
glBlendEquationi
glBlendEquationiContextANGLE
glBlendEquationiEXT
glBlendEquationiEXTContextANGLE
glBlendEquationiOES
glBlendEquationiOESContextANGLE
glBlendFunc
glBlendFuncContextANGLE
glBlendFuncSeparate
glBlendFuncSeparateContextANGLE
glBlendFuncSeparatei
glBlendFuncSeparateiContextANGLE
glBlendFuncSeparateiEXT
glBlendFuncSeparateiEXTContextANGLE
glBlendFuncSeparateiOES
glBlendFuncSeparateiOESContextANGLE
glBlendFunci
glBlendFunciContextANGLE
glBlendFunciEXT
glBlendFunciEXTContextANGLE
glBlendFunciOES
glBlendFunciOESContextANGLE
glBlitFramebuffer
glBlitFramebufferANGLE
glBlitFramebufferANGLEContextANGLE
glBlitFramebufferContextANGLE
glBufferData
glBufferDataContextANGLE
glBufferStorageEXT
glBufferStorageEXTContextANGLE
glBufferStorageExternalEXT
glBufferStorageExternalEXTContextANGLE
glBufferStorageMemEXT
glBufferStorageMemEXTContextANGLE
glBufferSubData
glBufferSubDataContextANGLE
glCheckFramebufferStatus
glCheckFramebufferStatusContextANGLE
glCheckFramebufferStatusOES
glCheckFramebufferStatusOESContextANGLE
glClear
glClearBufferfi
glClearBufferfiContextANGLE
glClearBufferfv
glClearBufferfvContextANGLE
glClearBufferiv
glClearBufferivContextANGLE
glClearBufferuiv
glClearBufferuivContextANGLE
glClearColor
glClearColorContextANGLE
glClearColorx
glClearColorxContextANGLE
glClearContextANGLE
glClearDepthf
glClearDepthfContextANGLE
glClearDepthx
glClearDepthxContextANGLE
glClearStencil
glClearStencilContextANGLE
glClientActiveTexture
glClientActiveTextureContextANGLE
glClientWaitSync
glClientWaitSyncContextANGLE
glClipPlanef
glClipPlanefContextANGLE
glClipPlanex
glClipPlanexContextANGLE
glColor4f
glColor4fContextANGLE
glColor4ub
glColor4ubContextANGLE
glColor4x
glColor4xContextANGLE
glColorMask
glColorMaskContextANGLE
glColorMaski
glColorMaskiContextANGLE
glColorMaskiEXT
glColorMaskiEXTContextANGLE
glColorMaskiOES
glColorMaskiOESContextANGLE
glColorPointer
glColorPointerContextANGLE
glCompileShader
glCompileShaderContextANGLE
glCompressedCopyTextureCHROMIUM
glCompressedCopyTextureCHROMIUMContextANGLE
glCompressedTexImage2D
glCompressedTexImage2DContextANGLE
glCompressedTexImage2DRobustANGLE
glCompressedTexImage2DRobustANGLEContextANGLE
glCompressedTexImage3D
glCompressedTexImage3DContextANGLE
glCompressedTexImage3DOES
glCompressedTexImage3DOESContextANGLE
glCompressedTexImage3DRobustANGLE
glCompressedTexImage3DRobustANGLEContextANGLE
glCompressedTexSubImage2D
glCompressedTexSubImage2DContextANGLE
glCompressedTexSubImage2DRobustANGLE
glCompressedTexSubImage2DRobustANGLEContextANGLE
glCompressedTexSubImage3D
glCompressedTexSubImage3DContextANGLE
glCompressedTexSubImage3DOES
glCompressedTexSubImage3DOESContextANGLE
glCompressedTexSubImage3DRobustANGLE
glCompressedTexSubImage3DRobustANGLEContextANGLE
glCopyBufferSubData
glCopyBufferSubDataContextANGLE
glCopyImageSubData
glCopyImageSubDataContextANGLE
glCopyImageSubDataEXT
glCopyImageSubDataEXTContextANGLE
glCopyImageSubDataOES
glCopyImageSubDataOESContextANGLE
glCopySubTexture3DANGLE
glCopySubTexture3DANGLEContextANGLE
glCopySubTextureCHROMIUM
glCopySubTextureCHROMIUMContextANGLE
glCopyTexImage2D
glCopyTexImage2DContextANGLE
glCopyTexSubImage2D
glCopyTexSubImage2DContextANGLE
glCopyTexSubImage3D
glCopyTexSubImage3DContextANGLE
glCopyTexSubImage3DOES
glCopyTexSubImage3DOESContextANGLE
glCopyTexture3DANGLE
glCopyTexture3DANGLEContextANGLE
glCopyTextureCHROMIUM
glCopyTextureCHROMIUMContextANGLE
glCoverageModulationCHROMIUM
glCoverageModulationCHROMIUMContextANGLE
glCreateMemoryObjectsEXT
glCreateMemoryObjectsEXTContextANGLE
glCreateProgram
glCreateProgramContextANGLE
glCreateShader
glCreateShaderContextANGLE
glCreateShaderProgramv
glCreateShaderProgramvContextANGLE
glCullFace
glCullFaceContextANGLE
glCurrentPaletteMatrixOES
glCurrentPaletteMatrixOESContextANGLE
glDebugMessageCallback
glDebugMessageCallbackContextANGLE
glDebugMessageCallbackKHR
glDebugMessageCallbackKHRContextANGLE
glDebugMessageControl
glDebugMessageControlContextANGLE
glDebugMessageControlKHR
glDebugMessageControlKHRContextANGLE
glDebugMessageInsert
glDebugMessageInsertContextANGLE
glDebugMessageInsertKHR
glDebugMessageInsertKHRContextANGLE
glDeleteBuffers
glDeleteBuffersContextANGLE
glDeleteFencesNV
glDeleteFencesNVContextANGLE
glDeleteFramebuffers
glDeleteFramebuffersContextANGLE
glDeleteFramebuffersOES
glDeleteFramebuffersOESContextANGLE
glDeleteMemoryObjectsEXT
glDeleteMemoryObjectsEXTContextANGLE
glDeleteProgram
glDeleteProgramContextANGLE
glDeleteProgramPipelines
glDeleteProgramPipelinesContextANGLE
glDeleteQueries
glDeleteQueriesContextANGLE
glDeleteQueriesEXT
glDeleteQueriesEXTContextANGLE
glDeleteRenderbuffers
glDeleteRenderbuffersContextANGLE
glDeleteRenderbuffersOES
glDeleteRenderbuffersOESContextANGLE
glDeleteSamplers
glDeleteSamplersContextANGLE
glDeleteSemaphoresEXT
glDeleteSemaphoresEXTContextANGLE
glDeleteShader
glDeleteShaderContextANGLE
glDeleteSync
glDeleteSyncContextANGLE
glDeleteTextures
glDeleteTexturesContextANGLE
glDeleteTransformFeedbacks
glDeleteTransformFeedbacksContextANGLE
glDeleteVertexArrays
glDeleteVertexArraysContextANGLE
glDeleteVertexArraysOES
glDeleteVertexArraysOESContextANGLE
glDepthFunc
glDepthFuncContextANGLE
glDepthMask
glDepthMaskContextANGLE
glDepthRangef
glDepthRangefContextANGLE
glDepthRangex
glDepthRangexContextANGLE
glDetachShader
glDetachShaderContextANGLE
glDisable
glDisableClientState
glDisableClientStateContextANGLE
glDisableContextANGLE
glDisableExtensionANGLE
glDisableExtensionANGLEContextANGLE
glDisableVertexAttribArray
glDisableVertexAttribArrayContextANGLE
glDisablei
glDisableiContextANGLE
glDisableiEXT
glDisableiEXTContextANGLE
glDisableiOES
glDisableiOESContextANGLE
glDiscardFramebufferEXT
glDiscardFramebufferEXTContextANGLE
glDispatchCompute
glDispatchComputeContextANGLE
glDispatchComputeIndirect
glDispatchComputeIndirectContextANGLE
glDrawArrays
glDrawArraysContextANGLE
glDrawArraysIndirect
glDrawArraysIndirectContextANGLE
glDrawArraysInstanced
glDrawArraysInstancedANGLE
glDrawArraysInstancedANGLEContextANGLE
glDrawArraysInstancedBaseInstanceANGLE
glDrawArraysInstancedBaseInstanceANGLEContextANGLE
glDrawArraysInstancedContextANGLE
glDrawArraysInstancedEXT
glDrawArraysInstancedEXTContextANGLE
glDrawBuffers
glDrawBuffersContextANGLE
glDrawBuffersEXT
glDrawBuffersEXTContextANGLE
glDrawElements
glDrawElementsBaseVertex
glDrawElementsBaseVertexContextANGLE
glDrawElementsBaseVertexEXT
glDrawElementsBaseVertexEXTContextANGLE
glDrawElementsBaseVertexOES
glDrawElementsBaseVertexOESContextANGLE
glDrawElementsContextANGLE
glDrawElementsIndirect
glDrawElementsIndirectContextANGLE
glDrawElementsInstanced
glDrawElementsInstancedANGLE
glDrawElementsInstancedANGLEContextANGLE
glDrawElementsInstancedBaseVertex
glDrawElementsInstancedBaseVertexBaseInstanceANGLE
glDrawElementsInstancedBaseVertexBaseInstanceANGLEContextANGLE
glDrawElementsInstancedBaseVertexContextANGLE
glDrawElementsInstancedBaseVertexEXT
glDrawElementsInstancedBaseVertexEXTContextANGLE
glDrawElementsInstancedBaseVertexOES
glDrawElementsInstancedBaseVertexOESContextANGLE
glDrawElementsInstancedContextANGLE
glDrawElementsInstancedEXT
glDrawElementsInstancedEXTContextANGLE
glDrawRangeElements
glDrawRangeElementsBaseVertex
glDrawRangeElementsBaseVertexContextANGLE
glDrawRangeElementsBaseVertexEXT
glDrawRangeElementsBaseVertexEXTContextANGLE
glDrawRangeElementsBaseVertexOES
glDrawRangeElementsBaseVertexOESContextANGLE
glDrawRangeElementsContextANGLE
glDrawTexfOES
glDrawTexfOESContextANGLE
glDrawTexfvOES
glDrawTexfvOESContextANGLE
glDrawTexiOES
glDrawTexiOESContextANGLE
glDrawTexivOES
glDrawTexivOESContextANGLE
glDrawTexsOES
glDrawTexsOESContextANGLE
glDrawTexsvOES
glDrawTexsvOESContextANGLE
glDrawTexxOES
glDrawTexxOESContextANGLE
glDrawTexxvOES
glDrawTexxvOESContextANGLE
glEGLImageTargetRenderbufferStorageOES
glEGLImageTargetRenderbufferStorageOESContextANGLE
glEGLImageTargetTexture2DOES
glEGLImageTargetTexture2DOESContextANGLE
glEnable
glEnableClientState
glEnableClientStateContextANGLE
glEnableContextANGLE
glEnableVertexAttribArray
glEnableVertexAttribArrayContextANGLE
glEnablei
glEnableiContextANGLE
glEnableiEXT
glEnableiEXTContextANGLE
glEnableiOES
glEnableiOESContextANGLE
glEndQuery
glEndQueryContextANGLE
glEndQueryEXT
glEndQueryEXTContextANGLE
glEndTransformFeedback
glEndTransformFeedbackContextANGLE
glFenceSync
glFenceSyncContextANGLE
glFinish
glFinishContextANGLE
glFinishFenceNV
glFinishFenceNVContextANGLE
glFlush
glFlushContextANGLE
glFlushMappedBufferRange
glFlushMappedBufferRangeContextANGLE
glFlushMappedBufferRangeEXT
glFlushMappedBufferRangeEXTContextANGLE
glFogf
glFogfContextANGLE
glFogfv
glFogfvContextANGLE
glFogx
glFogxContextANGLE
glFogxv
glFogxvContextANGLE
glFramebufferParameteri
glFramebufferParameteriContextANGLE
glFramebufferRenderbuffer
glFramebufferRenderbufferContextANGLE
glFramebufferRenderbufferOES
glFramebufferRenderbufferOESContextANGLE
glFramebufferTexture
glFramebufferTexture2D
glFramebufferTexture2DContextANGLE
glFramebufferTexture2DMultisampleEXT
glFramebufferTexture2DMultisampleEXTContextANGLE
glFramebufferTexture2DOES
glFramebufferTexture2DOESContextANGLE
glFramebufferTexture3DOES
glFramebufferTexture3DOESContextANGLE
glFramebufferTextureContextANGLE
glFramebufferTextureEXT
glFramebufferTextureEXTContextANGLE
glFramebufferTextureLayer
glFramebufferTextureLayerContextANGLE
glFramebufferTextureMultiviewOVR
glFramebufferTextureMultiviewOVRContextANGLE
glFrontFace
glFrontFaceContextANGLE
glFrustumf
glFrustumfContextANGLE
glFrustumx
glFrustumxContextANGLE
glGenBuffers
glGenBuffersContextANGLE
glGenFencesNV
glGenFencesNVContextANGLE
glGenFramebuffers
glGenFramebuffersContextANGLE
glGenFramebuffersOES
glGenFramebuffersOESContextANGLE
glGenProgramPipelines
glGenProgramPipelinesContextANGLE
glGenQueries
glGenQueriesContextANGLE
glGenQueriesEXT
glGenQueriesEXTContextANGLE
glGenRenderbuffers
glGenRenderbuffersContextANGLE
glGenRenderbuffersOES
glGenRenderbuffersOESContextANGLE
glGenSamplers
glGenSamplersContextANGLE
glGenSemaphoresEXT
glGenSemaphoresEXTContextANGLE
glGenTextures
glGenTexturesContextANGLE
glGenTransformFeedbacks
glGenTransformFeedbacksContextANGLE
glGenVertexArrays
glGenVertexArraysContextANGLE
glGenVertexArraysOES
glGenVertexArraysOESContextANGLE
glGenerateMipmap
glGenerateMipmapContextANGLE
glGenerateMipmapOES
glGenerateMipmapOESContextANGLE
glGetActiveAttrib
glGetActiveAttribContextANGLE
glGetActiveUniform
glGetActiveUniformBlockName
glGetActiveUniformBlockNameContextANGLE
glGetActiveUniformBlockiv
glGetActiveUniformBlockivContextANGLE
glGetActiveUniformBlockivRobustANGLE
glGetActiveUniformBlockivRobustANGLEContextANGLE
glGetActiveUniformContextANGLE
glGetActiveUniformsiv
glGetActiveUniformsivContextANGLE
glGetAttachedShaders
glGetAttachedShadersContextANGLE
glGetAttribLocation
glGetAttribLocationContextANGLE
glGetBooleani_v
glGetBooleani_vContextANGLE
glGetBooleani_vRobustANGLE
glGetBooleani_vRobustANGLEContextANGLE
glGetBooleanv
glGetBooleanvContextANGLE
glGetBooleanvRobustANGLE
glGetBooleanvRobustANGLEContextANGLE
glGetBufferParameteri64v
glGetBufferParameteri64vContextANGLE
glGetBufferParameteri64vRobustANGLE
glGetBufferParameteri64vRobustANGLEContextANGLE
glGetBufferParameteriv
glGetBufferParameterivContextANGLE
glGetBufferParameterivRobustANGLE
glGetBufferParameterivRobustANGLEContextANGLE
glGetBufferPointerv
glGetBufferPointervContextANGLE
glGetBufferPointervOES
glGetBufferPointervOESContextANGLE
glGetBufferPointervRobustANGLE
glGetBufferPointervRobustANGLEContextANGLE
glGetClipPlanef
glGetClipPlanefContextANGLE
glGetClipPlanex
glGetClipPlanexContextANGLE
glGetDebugMessageLog
glGetDebugMessageLogContextANGLE
glGetDebugMessageLogKHR
glGetDebugMessageLogKHRContextANGLE
glGetError
glGetErrorContextANGLE
glGetFenceivNV
glGetFenceivNVContextANGLE
glGetFixedv
glGetFixedvContextANGLE
glGetFloatv
glGetFloatvContextANGLE
glGetFloatvRobustANGLE
glGetFloatvRobustANGLEContextANGLE
glGetFragDataIndexEXT
glGetFragDataIndexEXTContextANGLE
glGetFragDataLocation
glGetFragDataLocationContextANGLE
glGetFramebufferAttachmentParameteriv
glGetFramebufferAttachmentParameterivContextANGLE
glGetFramebufferAttachmentParameterivOES
glGetFramebufferAttachmentParameterivOESContextANGLE
glGetFramebufferAttachmentParameterivRobustANGLE
glGetFramebufferAttachmentParameterivRobustANGLEContextANGLE
glGetFramebufferParameteriv
glGetFramebufferParameterivContextANGLE
glGetFramebufferParameterivRobustANGLE
glGetFramebufferParameterivRobustANGLEContextANGLE
glGetGraphicsResetStatus
glGetGraphicsResetStatusContextANGLE
glGetGraphicsResetStatusEXT
glGetGraphicsResetStatusEXTContextANGLE
glGetInteger64i_v
glGetInteger64i_vContextANGLE
glGetInteger64i_vRobustANGLE
glGetInteger64i_vRobustANGLEContextANGLE
glGetInteger64v
glGetInteger64vContextANGLE
glGetInteger64vEXT
glGetInteger64vEXTContextANGLE
glGetInteger64vRobustANGLE
glGetInteger64vRobustANGLEContextANGLE
glGetIntegeri_v
glGetIntegeri_vContextANGLE
glGetIntegeri_vRobustANGLE
glGetIntegeri_vRobustANGLEContextANGLE
glGetIntegerv
glGetIntegervContextANGLE
glGetIntegervRobustANGLE
glGetIntegervRobustANGLEContextANGLE
glGetInternalformativ
glGetInternalformativContextANGLE
glGetInternalformativRobustANGLE
glGetInternalformativRobustANGLEContextANGLE
glGetLightfv
glGetLightfvContextANGLE
glGetLightxv
glGetLightxvContextANGLE
glGetMaterialfv
glGetMaterialfvContextANGLE
glGetMaterialxv
glGetMaterialxvContextANGLE
glGetMemoryObjectParameterivEXT
glGetMemoryObjectParameterivEXTContextANGLE
glGetMultisamplefv
glGetMultisamplefvANGLE
glGetMultisamplefvANGLEContextANGLE
glGetMultisamplefvContextANGLE
glGetMultisamplefvRobustANGLE
glGetMultisamplefvRobustANGLEContextANGLE
glGetObjectLabel
glGetObjectLabelContextANGLE
glGetObjectLabelKHR
glGetObjectLabelKHRContextANGLE
glGetObjectPtrLabel
glGetObjectPtrLabelContextANGLE
glGetObjectPtrLabelKHR
glGetObjectPtrLabelKHRContextANGLE
glGetPointerv
glGetPointervContextANGLE
glGetPointervKHR
glGetPointervKHRContextANGLE
glGetPointervRobustANGLERobustANGLE
glGetPointervRobustANGLERobustANGLEContextANGLE
glGetProgramBinary
glGetProgramBinaryContextANGLE
glGetProgramBinaryOES
glGetProgramBinaryOESContextANGLE
glGetProgramInfoLog
glGetProgramInfoLogContextANGLE
glGetProgramInterfaceiv
glGetProgramInterfaceivContextANGLE
glGetProgramInterfaceivRobustANGLE
glGetProgramInterfaceivRobustANGLEContextANGLE
glGetProgramPipelineInfoLog
glGetProgramPipelineInfoLogContextANGLE
glGetProgramPipelineiv
glGetProgramPipelineivContextANGLE
glGetProgramResourceIndex
glGetProgramResourceIndexContextANGLE
glGetProgramResourceLocation
glGetProgramResourceLocationContextANGLE
glGetProgramResourceLocationIndexEXT
glGetProgramResourceLocationIndexEXTContextANGLE
glGetProgramResourceName
glGetProgramResourceNameContextANGLE
glGetProgramResourceiv
glGetProgramResourceivContextANGLE
glGetProgramiv
glGetProgramivContextANGLE
glGetProgramivRobustANGLE
glGetProgramivRobustANGLEContextANGLE
glGetQueryObjecti64vEXT
glGetQueryObjecti64vEXTContextANGLE
glGetQueryObjecti64vRobustANGLE
glGetQueryObjecti64vRobustANGLEContextANGLE
glGetQueryObjectivEXT
glGetQueryObjectivEXTContextANGLE
glGetQueryObjectivRobustANGLE
glGetQueryObjectivRobustANGLEContextANGLE
glGetQueryObjectui64vEXT
glGetQueryObjectui64vEXTContextANGLE
glGetQueryObjectui64vRobustANGLE
glGetQueryObjectui64vRobustANGLEContextANGLE
glGetQueryObjectuiv
glGetQueryObjectuivContextANGLE
glGetQueryObjectuivEXT
glGetQueryObjectuivEXTContextANGLE
glGetQueryObjectuivRobustANGLE
glGetQueryObjectuivRobustANGLEContextANGLE
glGetQueryiv
glGetQueryivContextANGLE
glGetQueryivEXT
glGetQueryivEXTContextANGLE
glGetQueryivRobustANGLE
glGetQueryivRobustANGLEContextANGLE
glGetRenderbufferImageANGLE
glGetRenderbufferImageANGLEContextANGLE
glGetRenderbufferParameteriv
glGetRenderbufferParameterivContextANGLE
glGetRenderbufferParameterivOES
glGetRenderbufferParameterivOESContextANGLE
glGetRenderbufferParameterivRobustANGLE
glGetRenderbufferParameterivRobustANGLEContextANGLE
glGetSamplerParameterIiv
glGetSamplerParameterIivContextANGLE
glGetSamplerParameterIivOES
glGetSamplerParameterIivOESContextANGLE
glGetSamplerParameterIivRobustANGLE
glGetSamplerParameterIivRobustANGLEContextANGLE
glGetSamplerParameterIuiv
glGetSamplerParameterIuivContextANGLE
glGetSamplerParameterIuivOES
glGetSamplerParameterIuivOESContextANGLE
glGetSamplerParameterIuivRobustANGLE
glGetSamplerParameterIuivRobustANGLEContextANGLE
glGetSamplerParameterfv
glGetSamplerParameterfvContextANGLE
glGetSamplerParameterfvRobustANGLE
glGetSamplerParameterfvRobustANGLEContextANGLE
glGetSamplerParameteriv
glGetSamplerParameterivContextANGLE
glGetSamplerParameterivRobustANGLE
glGetSamplerParameterivRobustANGLEContextANGLE
glGetSemaphoreParameterui64vEXT
glGetSemaphoreParameterui64vEXTContextANGLE
glGetShaderInfoLog
glGetShaderInfoLogContextANGLE
glGetShaderPrecisionFormat
glGetShaderPrecisionFormatContextANGLE
glGetShaderSource
glGetShaderSourceContextANGLE
glGetShaderiv
glGetShaderivContextANGLE
glGetShaderivRobustANGLE
glGetShaderivRobustANGLEContextANGLE
glGetString
glGetStringContextANGLE
glGetStringi
glGetStringiContextANGLE
glGetSynciv
glGetSyncivContextANGLE
glGetTexEnvfv
glGetTexEnvfvContextANGLE
glGetTexEnviv
glGetTexEnvivContextANGLE
glGetTexEnvxv
glGetTexEnvxvContextANGLE
glGetTexGenfvOES
glGetTexGenfvOESContextANGLE
glGetTexGenivOES
glGetTexGenivOESContextANGLE
glGetTexGenxvOES
glGetTexGenxvOESContextANGLE
glGetTexImageANGLE
glGetTexImageANGLEContextANGLE
glGetTexLevelParameterfv
glGetTexLevelParameterfvANGLE
glGetTexLevelParameterfvANGLEContextANGLE
glGetTexLevelParameterfvContextANGLE
glGetTexLevelParameterfvRobustANGLE
glGetTexLevelParameterfvRobustANGLEContextANGLE
glGetTexLevelParameteriv
glGetTexLevelParameterivANGLE
glGetTexLevelParameterivANGLEContextANGLE
glGetTexLevelParameterivContextANGLE
glGetTexLevelParameterivRobustANGLE
glGetTexLevelParameterivRobustANGLEContextANGLE
glGetTexParameterIiv
glGetTexParameterIivContextANGLE
glGetTexParameterIivOES
glGetTexParameterIivOESContextANGLE
glGetTexParameterIivRobustANGLE
glGetTexParameterIivRobustANGLEContextANGLE
glGetTexParameterIuiv
glGetTexParameterIuivContextANGLE
glGetTexParameterIuivOES
glGetTexParameterIuivOESContextANGLE
glGetTexParameterIuivRobustANGLE
glGetTexParameterIuivRobustANGLEContextANGLE
glGetTexParameterfv
glGetTexParameterfvContextANGLE
glGetTexParameterfvRobustANGLE
glGetTexParameterfvRobustANGLEContextANGLE
glGetTexParameteriv
glGetTexParameterivContextANGLE
glGetTexParameterivRobustANGLE
glGetTexParameterivRobustANGLEContextANGLE
glGetTexParameterxv
glGetTexParameterxvContextANGLE
glGetTransformFeedbackVarying
glGetTransformFeedbackVaryingContextANGLE
glGetTranslatedShaderSourceANGLE
glGetTranslatedShaderSourceANGLEContextANGLE
glGetUniformBlockIndex
glGetUniformBlockIndexContextANGLE
glGetUniformIndices
glGetUniformIndicesContextANGLE
glGetUniformLocation
glGetUniformLocationContextANGLE
glGetUniformfv
glGetUniformfvContextANGLE
glGetUniformfvRobustANGLE
glGetUniformfvRobustANGLEContextANGLE
glGetUniformiv
glGetUniformivContextANGLE
glGetUniformivRobustANGLE
glGetUniformivRobustANGLEContextANGLE
glGetUniformuiv
glGetUniformuivContextANGLE
glGetUniformuivRobustANGLE
glGetUniformuivRobustANGLEContextANGLE
glGetUnsignedBytei_vEXT
glGetUnsignedBytei_vEXTContextANGLE
glGetUnsignedBytevEXT
glGetUnsignedBytevEXTContextANGLE
glGetVertexAttribIiv
glGetVertexAttribIivContextANGLE
glGetVertexAttribIivRobustANGLE
glGetVertexAttribIivRobustANGLEContextANGLE
glGetVertexAttribIuiv
glGetVertexAttribIuivContextANGLE
glGetVertexAttribIuivRobustANGLE
glGetVertexAttribIuivRobustANGLEContextANGLE
glGetVertexAttribPointerv
glGetVertexAttribPointervContextANGLE
glGetVertexAttribPointervRobustANGLE
glGetVertexAttribPointervRobustANGLEContextANGLE
glGetVertexAttribfv
glGetVertexAttribfvContextANGLE
glGetVertexAttribfvRobustANGLE
glGetVertexAttribfvRobustANGLEContextANGLE
glGetVertexAttribiv
glGetVertexAttribivContextANGLE
glGetVertexAttribivRobustANGLE
glGetVertexAttribivRobustANGLEContextANGLE
glGetnUniformfv
glGetnUniformfvContextANGLE
glGetnUniformfvEXT
glGetnUniformfvEXTContextANGLE
glGetnUniformfvRobustANGLE
glGetnUniformfvRobustANGLEContextANGLE
glGetnUniformiv
glGetnUniformivContextANGLE
glGetnUniformivEXT
glGetnUniformivEXTContextANGLE
glGetnUniformivRobustANGLE
glGetnUniformivRobustANGLEContextANGLE
glGetnUniformuiv
glGetnUniformuivContextANGLE
glGetnUniformuivRobustANGLE
glGetnUniformuivRobustANGLEContextANGLE
glHint
glHintContextANGLE
glImportMemoryFdEXT
glImportMemoryFdEXTContextANGLE
glImportMemoryZirconHandleANGLE
glImportMemoryZirconHandleANGLEContextANGLE
glImportSemaphoreFdEXT
glImportSemaphoreFdEXTContextANGLE
glImportSemaphoreZirconHandleANGLE
glImportSemaphoreZirconHandleANGLEContextANGLE
glInsertEventMarkerEXT
glInsertEventMarkerEXTContextANGLE
glInvalidateFramebuffer
glInvalidateFramebufferContextANGLE
glInvalidateSubFramebuffer
glInvalidateSubFramebufferContextANGLE
glInvalidateTextureANGLE
glInvalidateTextureANGLEContextANGLE
glIsBuffer
glIsBufferContextANGLE
glIsEnabled
glIsEnabledContextANGLE
glIsEnabledi
glIsEnablediContextANGLE
glIsEnablediEXT
glIsEnablediEXTContextANGLE
glIsEnablediOES
glIsEnablediOESContextANGLE
glIsFenceNV
glIsFenceNVContextANGLE
glIsFramebuffer
glIsFramebufferContextANGLE
glIsFramebufferOES
glIsFramebufferOESContextANGLE
glIsMemoryObjectEXT
glIsMemoryObjectEXTContextANGLE
glIsProgram
glIsProgramContextANGLE
glIsProgramPipeline
glIsProgramPipelineContextANGLE
glIsQuery
glIsQueryContextANGLE
glIsQueryEXT
glIsQueryEXTContextANGLE
glIsRenderbuffer
glIsRenderbufferContextANGLE
glIsRenderbufferOES
glIsRenderbufferOESContextANGLE
glIsSampler
glIsSamplerContextANGLE
glIsSemaphoreEXT
glIsSemaphoreEXTContextANGLE
glIsShader
glIsShaderContextANGLE
glIsSync
glIsSyncContextANGLE
glIsTexture
glIsTextureContextANGLE
glIsTransformFeedback
glIsTransformFeedbackContextANGLE
glIsVertexArray
glIsVertexArrayContextANGLE
glIsVertexArrayOES
glIsVertexArrayOESContextANGLE
glLightModelf
glLightModelfContextANGLE
glLightModelfv
glLightModelfvContextANGLE
glLightModelx
glLightModelxContextANGLE
glLightModelxv
glLightModelxvContextANGLE
glLightf
glLightfContextANGLE
glLightfv
glLightfvContextANGLE
glLightx
glLightxContextANGLE
glLightxv
glLightxvContextANGLE
glLineWidth
glLineWidthContextANGLE
glLineWidthx
glLineWidthxContextANGLE
glLinkProgram
glLinkProgramContextANGLE
glLoadIdentity
glLoadIdentityContextANGLE
glLoadMatrixf
glLoadMatrixfContextANGLE
glLoadMatrixx
glLoadMatrixxContextANGLE
glLoadPaletteFromModelViewMatrixOES
glLoadPaletteFromModelViewMatrixOESContextANGLE
glLogicOp
glLogicOpContextANGLE
glLoseContextCHROMIUM
glLoseContextCHROMIUMContextANGLE
glMapBufferOES
glMapBufferOESContextANGLE
glMapBufferRange
glMapBufferRangeContextANGLE
glMapBufferRangeEXT
glMapBufferRangeEXTContextANGLE
glMaterialf
glMaterialfContextANGLE
glMaterialfv
glMaterialfvContextANGLE
glMaterialx
glMaterialxContextANGLE
glMaterialxv
glMaterialxvContextANGLE
glMatrixIndexPointerOES
glMatrixIndexPointerOESContextANGLE
glMatrixMode
glMatrixModeContextANGLE
glMaxShaderCompilerThreadsKHR
glMaxShaderCompilerThreadsKHRContextANGLE
glMemoryBarrier
glMemoryBarrierByRegion
glMemoryBarrierByRegionContextANGLE
glMemoryBarrierContextANGLE
glMemoryObjectParameterivEXT
glMemoryObjectParameterivEXTContextANGLE
glMinSampleShading
glMinSampleShadingContextANGLE
glMinSampleShadingOES
glMinSampleShadingOESContextANGLE
glMultMatrixf
glMultMatrixfContextANGLE
glMultMatrixx
glMultMatrixxContextANGLE
glMultiDrawArraysANGLE
glMultiDrawArraysANGLEContextANGLE
glMultiDrawArraysInstancedANGLE
glMultiDrawArraysInstancedANGLEContextANGLE
glMultiDrawArraysInstancedBaseInstanceANGLE
glMultiDrawArraysInstancedBaseInstanceANGLEContextANGLE
glMultiDrawElementsANGLE
glMultiDrawElementsANGLEContextANGLE
glMultiDrawElementsBaseVertexEXT
glMultiDrawElementsBaseVertexEXTContextANGLE
glMultiDrawElementsInstancedANGLE
glMultiDrawElementsInstancedANGLEContextANGLE
glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLE
glMultiDrawElementsInstancedBaseVertexBaseInstanceANGLEContextANGLE
glMultiTexCoord4f
glMultiTexCoord4fContextANGLE
glMultiTexCoord4x
glMultiTexCoord4xContextANGLE
glNamedBufferStorageExternalEXT
glNamedBufferStorageExternalEXTContextANGLE
glNormal3f
glNormal3fContextANGLE
glNormal3x
glNormal3xContextANGLE
glNormalPointer
glNormalPointerContextANGLE
glObjectLabel
glObjectLabelContextANGLE
glObjectLabelKHR
glObjectLabelKHRContextANGLE
glObjectPtrLabel
glObjectPtrLabelContextANGLE
glObjectPtrLabelKHR
glObjectPtrLabelKHRContextANGLE
glOrthof
glOrthofContextANGLE
glOrthox
glOrthoxContextANGLE
glPatchParameteri
glPatchParameteriContextANGLE
glPauseTransformFeedback
glPauseTransformFeedbackContextANGLE
glPixelStorei
glPixelStoreiContextANGLE
glPointParameterf
glPointParameterfContextANGLE
glPointParameterfv
glPointParameterfvContextANGLE
glPointParameterx
glPointParameterxContextANGLE
glPointParameterxv
glPointParameterxvContextANGLE
glPointSize
glPointSizeContextANGLE
glPointSizePointerOES
glPointSizePointerOESContextANGLE
glPointSizex
glPointSizexContextANGLE
glPolygonOffset
glPolygonOffsetContextANGLE
glPolygonOffsetx
glPolygonOffsetxContextANGLE
glPopDebugGroup
glPopDebugGroupContextANGLE
glPopDebugGroupKHR
glPopDebugGroupKHRContextANGLE
glPopGroupMarkerEXT
glPopGroupMarkerEXTContextANGLE
glPopMatrix
glPopMatrixContextANGLE
glPrimitiveBoundingBox
glPrimitiveBoundingBoxContextANGLE
glProgramBinary
glProgramBinaryContextANGLE
glProgramBinaryOES
glProgramBinaryOESContextANGLE
glProgramParameteri
glProgramParameteriContextANGLE
glProgramUniform1f
glProgramUniform1fContextANGLE
glProgramUniform1fv
glProgramUniform1fvContextANGLE
glProgramUniform1i
glProgramUniform1iContextANGLE
glProgramUniform1iv
glProgramUniform1ivContextANGLE
glProgramUniform1ui
glProgramUniform1uiContextANGLE
glProgramUniform1uiv
glProgramUniform1uivContextANGLE
glProgramUniform2f
glProgramUniform2fContextANGLE
glProgramUniform2fv
glProgramUniform2fvContextANGLE
glProgramUniform2i
glProgramUniform2iContextANGLE
glProgramUniform2iv
glProgramUniform2ivContextANGLE
glProgramUniform2ui
glProgramUniform2uiContextANGLE
glProgramUniform2uiv
glProgramUniform2uivContextANGLE
glProgramUniform3f
glProgramUniform3fContextANGLE
glProgramUniform3fv
glProgramUniform3fvContextANGLE
glProgramUniform3i
glProgramUniform3iContextANGLE
glProgramUniform3iv
glProgramUniform3ivContextANGLE
glProgramUniform3ui
glProgramUniform3uiContextANGLE
glProgramUniform3uiv
glProgramUniform3uivContextANGLE
glProgramUniform4f
glProgramUniform4fContextANGLE
glProgramUniform4fv
glProgramUniform4fvContextANGLE
glProgramUniform4i
glProgramUniform4iContextANGLE
glProgramUniform4iv
glProgramUniform4ivContextANGLE
glProgramUniform4ui
glProgramUniform4uiContextANGLE
glProgramUniform4uiv
glProgramUniform4uivContextANGLE
glProgramUniformMatrix2fv
glProgramUniformMatrix2fvContextANGLE
glProgramUniformMatrix2x3fv
glProgramUniformMatrix2x3fvContextANGLE
glProgramUniformMatrix2x4fv
glProgramUniformMatrix2x4fvContextANGLE
glProgramUniformMatrix3fv
glProgramUniformMatrix3fvContextANGLE
glProgramUniformMatrix3x2fv
glProgramUniformMatrix3x2fvContextANGLE
glProgramUniformMatrix3x4fv
glProgramUniformMatrix3x4fvContextANGLE
glProgramUniformMatrix4fv
glProgramUniformMatrix4fvContextANGLE
glProgramUniformMatrix4x2fv
glProgramUniformMatrix4x2fvContextANGLE
glProgramUniformMatrix4x3fv
glProgramUniformMatrix4x3fvContextANGLE
glProvokingVertexANGLE
glProvokingVertexANGLEContextANGLE
glPushDebugGroup
glPushDebugGroupContextANGLE
glPushDebugGroupKHR
glPushDebugGroupKHRContextANGLE
glPushGroupMarkerEXT
glPushGroupMarkerEXTContextANGLE
glPushMatrix
glPushMatrixContextANGLE
glQueryCounterEXT
glQueryCounterEXTContextANGLE
glQueryMatrixxOES
glQueryMatrixxOESContextANGLE
glReadBuffer
glReadBufferContextANGLE
glReadPixels
glReadPixelsContextANGLE
glReadPixelsRobustANGLE
glReadPixelsRobustANGLEContextANGLE
glReadnPixels
glReadnPixelsContextANGLE
glReadnPixelsEXT
glReadnPixelsEXTContextANGLE
glReadnPixelsRobustANGLE
glReadnPixelsRobustANGLEContextANGLE
glReleaseShaderCompiler
glReleaseShaderCompilerContextANGLE
glRenderbufferStorage
glRenderbufferStorageContextANGLE
glRenderbufferStorageMultisample
glRenderbufferStorageMultisampleANGLE
glRenderbufferStorageMultisampleANGLEContextANGLE
glRenderbufferStorageMultisampleContextANGLE
glRenderbufferStorageMultisampleEXT
glRenderbufferStorageMultisampleEXTContextANGLE
glRenderbufferStorageOES
glRenderbufferStorageOESContextANGLE
glRequestExtensionANGLE
glRequestExtensionANGLEContextANGLE
glResumeTransformFeedback
glResumeTransformFeedbackContextANGLE
glRotatef
glRotatefContextANGLE
glRotatex
glRotatexContextANGLE
glSampleCoverage
glSampleCoverageContextANGLE
glSampleCoveragex
glSampleCoveragexContextANGLE
glSampleMaski
glSampleMaskiANGLE
glSampleMaskiANGLEContextANGLE
glSampleMaskiContextANGLE
glSamplerParameterIiv
glSamplerParameterIivContextANGLE
glSamplerParameterIivOES
glSamplerParameterIivOESContextANGLE
glSamplerParameterIivRobustANGLE
glSamplerParameterIivRobustANGLEContextANGLE
glSamplerParameterIuiv
glSamplerParameterIuivContextANGLE
glSamplerParameterIuivOES
glSamplerParameterIuivOESContextANGLE
glSamplerParameterIuivRobustANGLE
glSamplerParameterIuivRobustANGLEContextANGLE
glSamplerParameterf
glSamplerParameterfContextANGLE
glSamplerParameterfv
glSamplerParameterfvContextANGLE
glSamplerParameterfvRobustANGLE
glSamplerParameterfvRobustANGLEContextANGLE
glSamplerParameteri
glSamplerParameteriContextANGLE
glSamplerParameteriv
glSamplerParameterivContextANGLE
glSamplerParameterivRobustANGLE
glSamplerParameterivRobustANGLEContextANGLE
glScalef
glScalefContextANGLE
glScalex
glScalexContextANGLE
glScissor
glScissorContextANGLE
glSemaphoreParameterui64vEXT
glSemaphoreParameterui64vEXTContextANGLE
glSetFenceNV
glSetFenceNVContextANGLE
glShadeModel
glShadeModelContextANGLE
glShaderBinary
glShaderBinaryContextANGLE
glShaderSource
glShaderSourceContextANGLE
glSignalSemaphoreEXT
glSignalSemaphoreEXTContextANGLE
glStencilFunc
glStencilFuncContextANGLE
glStencilFuncSeparate
glStencilFuncSeparateContextANGLE
glStencilMask
glStencilMaskContextANGLE
glStencilMaskSeparate
glStencilMaskSeparateContextANGLE
glStencilOp
glStencilOpContextANGLE
glStencilOpSeparate
glStencilOpSeparateContextANGLE
glTestFenceNV
glTestFenceNVContextANGLE
glTexBuffer
glTexBufferContextANGLE
glTexBufferEXT
glTexBufferEXTContextANGLE
glTexBufferOES
glTexBufferOESContextANGLE
glTexBufferRange
glTexBufferRangeContextANGLE
glTexBufferRangeEXT
glTexBufferRangeEXTContextANGLE
glTexBufferRangeOES
glTexBufferRangeOESContextANGLE
glTexCoordPointer
glTexCoordPointerContextANGLE
glTexEnvf
glTexEnvfContextANGLE
glTexEnvfv
glTexEnvfvContextANGLE
glTexEnvi
glTexEnviContextANGLE
glTexEnviv
glTexEnvivContextANGLE
glTexEnvx
glTexEnvxContextANGLE
glTexEnvxv
glTexEnvxvContextANGLE
glTexGenfOES
glTexGenfOESContextANGLE
glTexGenfvOES
glTexGenfvOESContextANGLE
glTexGeniOES
glTexGeniOESContextANGLE
glTexGenivOES
glTexGenivOESContextANGLE
glTexGenxOES
glTexGenxOESContextANGLE
glTexGenxvOES
glTexGenxvOESContextANGLE
glTexImage2D
glTexImage2DContextANGLE
glTexImage2DExternalANGLE
glTexImage2DExternalANGLEContextANGLE
glTexImage2DRobustANGLE
glTexImage2DRobustANGLEContextANGLE
glTexImage3D
glTexImage3DContextANGLE
glTexImage3DOES
glTexImage3DOESContextANGLE
glTexImage3DRobustANGLE
glTexImage3DRobustANGLEContextANGLE
glTexParameterIiv
glTexParameterIivContextANGLE
glTexParameterIivOES
glTexParameterIivOESContextANGLE
glTexParameterIivRobustANGLE
glTexParameterIivRobustANGLEContextANGLE
glTexParameterIuiv
glTexParameterIuivContextANGLE
glTexParameterIuivOES
glTexParameterIuivOESContextANGLE
glTexParameterIuivRobustANGLE
glTexParameterIuivRobustANGLEContextANGLE
glTexParameterf
glTexParameterfContextANGLE
glTexParameterfv
glTexParameterfvContextANGLE
glTexParameterfvRobustANGLE
glTexParameterfvRobustANGLEContextANGLE
glTexParameteri
glTexParameteriContextANGLE
glTexParameteriv
glTexParameterivContextANGLE
glTexParameterivRobustANGLE
glTexParameterivRobustANGLEContextANGLE
glTexParameterx
glTexParameterxContextANGLE
glTexParameterxv
glTexParameterxvContextANGLE
glTexStorage1DEXT
glTexStorage1DEXTContextANGLE
glTexStorage2D
glTexStorage2DContextANGLE
glTexStorage2DEXT
glTexStorage2DEXTContextANGLE
glTexStorage2DMultisample
glTexStorage2DMultisampleANGLE
glTexStorage2DMultisampleANGLEContextANGLE
glTexStorage2DMultisampleContextANGLE
glTexStorage3D
glTexStorage3DContextANGLE
glTexStorage3DEXT
glTexStorage3DEXTContextANGLE
glTexStorage3DMultisample
glTexStorage3DMultisampleContextANGLE
glTexStorage3DMultisampleOES
glTexStorage3DMultisampleOESContextANGLE
glTexStorageMem2DEXT
glTexStorageMem2DEXTContextANGLE
glTexStorageMem2DMultisampleEXT
glTexStorageMem2DMultisampleEXTContextANGLE
glTexStorageMem3DEXT
glTexStorageMem3DEXTContextANGLE
glTexStorageMem3DMultisampleEXT
glTexStorageMem3DMultisampleEXTContextANGLE
glTexStorageMemFlags2DANGLE
glTexStorageMemFlags2DANGLEContextANGLE
glTexStorageMemFlags2DMultisampleANGLE
glTexStorageMemFlags2DMultisampleANGLEContextANGLE
glTexStorageMemFlags3DANGLE
glTexStorageMemFlags3DANGLEContextANGLE
glTexStorageMemFlags3DMultisampleANGLE
glTexStorageMemFlags3DMultisampleANGLEContextANGLE
glTexSubImage2D
glTexSubImage2DContextANGLE
glTexSubImage2DRobustANGLE
glTexSubImage2DRobustANGLEContextANGLE
glTexSubImage3D
glTexSubImage3DContextANGLE
glTexSubImage3DOES
glTexSubImage3DOESContextANGLE
glTexSubImage3DRobustANGLE
glTexSubImage3DRobustANGLEContextANGLE
glTransformFeedbackVaryings
glTransformFeedbackVaryingsContextANGLE
glTranslatef
glTranslatefContextANGLE
glTranslatex
glTranslatexContextANGLE
glUniform1f
glUniform1fContextANGLE
glUniform1fv
glUniform1fvContextANGLE
glUniform1i
glUniform1iContextANGLE
glUniform1iv
glUniform1ivContextANGLE
glUniform1ui
glUniform1uiContextANGLE
glUniform1uiv
glUniform1uivContextANGLE
glUniform2f
glUniform2fContextANGLE
glUniform2fv
glUniform2fvContextANGLE
glUniform2i
glUniform2iContextANGLE
glUniform2iv
glUniform2ivContextANGLE
glUniform2ui
glUniform2uiContextANGLE
glUniform2uiv
glUniform2uivContextANGLE
glUniform3f
glUniform3fContextANGLE
glUniform3fv
glUniform3fvContextANGLE
glUniform3i
glUniform3iContextANGLE
glUniform3iv
glUniform3ivContextANGLE
glUniform3ui
glUniform3uiContextANGLE
glUniform3uiv
glUniform3uivContextANGLE
glUniform4f
glUniform4fContextANGLE
glUniform4fv
glUniform4fvContextANGLE
glUniform4i
glUniform4iContextANGLE
glUniform4iv
glUniform4ivContextANGLE
glUniform4ui
glUniform4uiContextANGLE
glUniform4uiv
glUniform4uivContextANGLE
glUniformBlockBinding
glUniformBlockBindingContextANGLE
glUniformMatrix2fv
glUniformMatrix2fvContextANGLE
glUniformMatrix2x3fv
glUniformMatrix2x3fvContextANGLE
glUniformMatrix2x4fv
glUniformMatrix2x4fvContextANGLE
glUniformMatrix3fv
glUniformMatrix3fvContextANGLE
glUniformMatrix3x2fv
glUniformMatrix3x2fvContextANGLE
glUniformMatrix3x4fv
glUniformMatrix3x4fvContextANGLE
glUniformMatrix4fv
glUniformMatrix4fvContextANGLE
glUniformMatrix4x2fv
glUniformMatrix4x2fvContextANGLE
glUniformMatrix4x3fv
glUniformMatrix4x3fvContextANGLE
glUnmapBuffer
glUnmapBufferContextANGLE
glUnmapBufferOES
glUnmapBufferOESContextANGLE
glUseProgram
glUseProgramContextANGLE
glUseProgramStages
glUseProgramStagesContextANGLE
glValidateProgram
glValidateProgramContextANGLE
glValidateProgramPipeline
glValidateProgramPipelineContextANGLE
glVertexAttrib1f
glVertexAttrib1fContextANGLE
glVertexAttrib1fv
glVertexAttrib1fvContextANGLE
glVertexAttrib2f
glVertexAttrib2fContextANGLE
glVertexAttrib2fv
glVertexAttrib2fvContextANGLE
glVertexAttrib3f
glVertexAttrib3fContextANGLE
glVertexAttrib3fv
glVertexAttrib3fvContextANGLE
glVertexAttrib4f
glVertexAttrib4fContextANGLE
glVertexAttrib4fv
glVertexAttrib4fvContextANGLE
glVertexAttribBinding
glVertexAttribBindingContextANGLE
glVertexAttribDivisor
glVertexAttribDivisorANGLE
glVertexAttribDivisorANGLEContextANGLE
glVertexAttribDivisorContextANGLE
glVertexAttribDivisorEXT
glVertexAttribDivisorEXTContextANGLE
glVertexAttribFormat
glVertexAttribFormatContextANGLE
glVertexAttribI4i
glVertexAttribI4iContextANGLE
glVertexAttribI4iv
glVertexAttribI4ivContextANGLE
glVertexAttribI4ui
glVertexAttribI4uiContextANGLE
glVertexAttribI4uiv
glVertexAttribI4uivContextANGLE
glVertexAttribIFormat
glVertexAttribIFormatContextANGLE
glVertexAttribIPointer
glVertexAttribIPointerContextANGLE
glVertexAttribPointer
glVertexAttribPointerContextANGLE
glVertexBindingDivisor
glVertexBindingDivisorContextANGLE
glVertexPointer
glVertexPointerContextANGLE
glViewport
glViewportContextANGLE
glWaitSemaphoreEXT
glWaitSemaphoreEXTContextANGLE
glWaitSync
glWaitSyncContextANGLE
glWeightPointerOES
glWeightPointerOESContextANGLE
s of 
' member '
' differ between 
 and 
 shaders.
GPU.ANGLE.ProgramCache.ProgramCacheHitTimeUS
The sum of the number of active image uniforms, active shader storage blocks and active fragment shader outputs exceeds MAX_COMBINED_SHADER_OUTPUT_RESOURCES (
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Program.cpp
resolveLinkImpl
Failed to save linked program to memory program cache.
Invalid program binary format.
Insufficient buffer size
saveBinary
Program has not been successfully linked.
Samplers of conflicting types refer to the same texture image unit (
Both compute and graphics shaders are attached to the same program.
Attached compute shader is not compiled.
Work group size is not specified.
No compiled shaders.
Fragment shader is not compiled.
Vertex shader is not compiled.
No compiled fragment shader when at least one graphics shader is attached.
No compiled vertex shader when at least one graphics shader is attached.
Fragment shader version does not match vertex shader version.
The attached geometry shader isn't compiled.
Geometry shader version does not match vertex shader version.
Input primitive type is not specified in the geometry shader.
Output primitive type is not specified in the geometry shader.
'max_vertices' is not specified in the geometry shader.
 does not consume all varyings generated by 
 does not generate all varyings consumed by 
 varying 
 does not match any 
 varying
Exceeded maximum uniform location size
Attribute (
) at location 
 is too big to fit
Attribute '
' aliases attribute '
' at location 
Too many attributes (
The sum of the number of active uniform blocks exceeds MAX_COMBINED_UNIFORM_BLOCKS (
The sum of the number of active shader storage blocks exceeds MAX_COMBINED_SHADER_STORAGE_BLOCKS (
gl_Position
gl_PointSize
gl_FragCoord
gl_PointCoord
gl_FragCoord can only be declared invariant if and only if gl_Position is declared invariant.
gl_PointCoord can only be declared invariant if and only if gl_PointSize is declared invariant.
Capture of array elements is undefined and not supported.
Two transform feedback varyings include the same array element (
Two transform feedback varyings specify the same output variable (
Transform feedback varying 
 does not exist in the vertex shader.
Struct cannot be captured directly (
Capture of arrays is undefined and not supported.
Cannot capture outbound array element '
Varying '
' is not an array to be captured by element.
 components (
) exceed the maximum separate components (
Transform feedback varying total components (
) exceed the maximum interleaved components (
Location of variable 
 conflicts with another variable.
Could not fit output variable into available locations: 
serialize
Saving program binary with transform feedback, which is not supported on this driver.
Failed to allocate enough memory to serialize a program. (
Invalid program binary version.
Cannot load program binaries across different ES context versions.
Current driver does not support transform feedback in binary programs.
Type
Array size
Precision
Structure name
Field number
Field name
Interpolation type
Invariance
Binding layout qualifier
Location layout qualifier
Offset layout qualifier
Instance name qualifier
Format qualifier
Layout qualifier
Matrix Packing
 shader 
 count exceeds 
uniform block
shader storage block
GL_MAX_
UNIFORM_BUFFERS
SHADER_STORAGE_BLOCKS
_EXT
Name conflicts between uniform block field names: 
Name conflicts between a uniform and an attribute: 
Name conflicts between a uniform and a uniform block field: 
ProgramGL::load
ProgramGL::link
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/ProgramGL.cpp
checkLinkStatus
Program link or binary loading failed: 
Program link or binary loading failed with no info log.
ProgramGL::LinkTask::run
ProgramGL::LinkEventNativeParallel::wait
ProgramGL::LinkEventGL::wait
Multiple uniforms bound to location 
atomic counter count exceeds MAX_COMBINED_ATOMIC_COUNTERS
s count exceeds 
texture image unit
image uniform
atomic counter
MAX_TEXTURE_IMAGE_UNITS
MAX_
UNIFORM_VECTORS
UNIFORM_COMPONENTS
TEXTURE_IMAGE_UNITS
IMAGE_UNIFORMS
ATOMIC_COUNTERS
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/ProgramMtl.mm
resizeDefaultUniformBlocksMemory
ANGLE_UseSampleCompareGradient
ANGLE_UseSampleCompareLod
Internal error compiling shader with Metal backend.
Please submit this shader, or website as a bug to https://bugs.webkit.org
createMslShaderLib
 is not marked separable.
#define ANGLE_tensor metal::array
#pragma clang diagnostic ignored "-Wunused-value"
addressof
cast<>
elem_ref
swizzle_ref
texture1DProj
textureCubeProj
template <typename T>
ANGLE_ALWAYS_INLINE thread T * ANGLE_addressof(thread T &ref)
    return &ref;
template <typename T, int C1, int R1, int C2, int R2, typename Enable = void>
struct ANGLE_castMatrix
    static ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> exec(metal::matrix<T, C2, R2> const m2)
    {
        metal::matrix<T, C1, R1> m1;
        const int MinC = C1 <= C2 ? C1 : C2;
        const int MinR = R1 <= R2 ? R1 : R2;
        for (int c = 0; c < MinC; ++c)
        {
            for (int r = 0; r < MinR; ++r)
            {
                m1[c][r] = m2[c][r];
            }
            for (int r = R2; r < R1; ++r)
            {
                m1[c][r] = c == r ? T(1) : T(0);
            }
        }
        for (int c = C2; c < C1; ++c)
        {
            for (int r = 0; r < R1; ++r)
            {
                m1[c][r] = c == r ? T(1) : T(0);
            }
        }
        return m1;
    }
template <typename T, int C1, int R1, int C2, int R2>
struct ANGLE_castMatrix<T, C1, R1, C2, R2, ANGLE_enable_if_t<(C1 <= C2 && R1 <= R2)>>
    static ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> exec(metal::matrix<T, C2, R2> const m2)
    {
        metal::matrix<T, C1, R1> m1;
        for (size_t c = 0; c < C1; ++c)
        {
            m1[c] = ANGLE_cast<R1>(m2[c]);
        }
        return m1;
    }
template <int C1, int R1, int C2, int R2, typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, C1, R1> ANGLE_cast(metal::matrix<T, C2, R2> const m)
    return ANGLE_castMatrix<T, C1, R1, C2, R2>::exec(m);
template <bool B, typename T = void>
struct ANGLE_enable_if {};
template <typename T>
struct ANGLE_enable_if<true, T>
    using type = T;
template <bool B>
using ANGLE_enable_if_t = typename ANGLE_enable_if<B>::type;
template <typename T, int N1, int N2>
struct ANGLE_castVector {};
template <typename T, int N>
struct ANGLE_castVector<T, N, N>
    static ANGLE_ALWAYS_INLINE metal::vec<T, N> exec(metal::vec<T, N> const v)
    {
        return v;
    }
template <typename T>
struct ANGLE_castVector<T, 2, 3>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 2> exec(metal::vec<T, 3> const v)
    {
        return v.xy;
    }
template <typename T>
struct ANGLE_castVector<T, 2, 4>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 2> exec(metal::vec<T, 4> const v)
    {
        return v.xy;
    }
template <typename T>
struct ANGLE_castVector<T, 3, 4>
    static ANGLE_ALWAYS_INLINE metal::vec<T, 3> exec(metal::vec<T, 4> const v)
    {
        return as_type<metal::vec<T, 3>>(v);
    }
template <int N1, int N2, typename T>
ANGLE_ALWAYS_INLINE metal::vec<T, N1> ANGLE_cast(metal::vec<T, N2> const v)
    return ANGLE_castVector<T, N1, N2>::exec(v);
template <typename T, int N>
struct ANGLE_VectorElemRef
    thread metal::vec<T, N> &mVec;
    T mRef;
    const int mIndex;
    ~ANGLE_VectorElemRef() { mVec[mIndex] = mRef; }
    ANGLE_VectorElemRef(thread metal::vec<T, N> &vec, int index)
        : mVec(vec), mRef(vec[index]), mIndex(index)
    {}
    operator thread T &() { return mRef; }
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_VectorElemRef<T, N> ANGLE_elem_ref(thread metal::vec<T, N> &vec, int index)
    return ANGLE_VectorElemRef<T, N>(vec, index);
template <typename T>
struct ANGLE_flatten_impl
    static ANGLE_ALWAYS_INLINE thread T *exec(thread T &x)
    {
        return &x;
    }
template <typename T, size_t N>
struct ANGLE_flatten_impl<metal::array<T, N>>
    static ANGLE_ALWAYS_INLINE auto exec(thread metal::array<T, N> &arr) -> T
    {
        return ANGLE_flatten_impl<T>::exec(arr[0]);
    }
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE auto ANGLE_flatten(thread metal::array<T, N> &arr) -> T
    return ANGLE_flatten_impl<T>::exec(arr[0]);
template <typename T>
struct ANGLE_InOut
    T mTemp;
    thread T &mDest;
    ~ANGLE_InOut() { mDest = mTemp; }
    ANGLE_InOut(thread T &dest)
        : mTemp(dest), mDest(dest)
    {}
    operator thread T &() { return mTemp; }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_InOut<T> ANGLE_inout(thread T &dest)
    return ANGLE_InOut<T>(dest);
template <typename T>
struct ANGLE_Out
    T mTemp;
    thread T &mDest;
    ~ANGLE_Out() { mDest = mTemp; }
    ANGLE_Out(thread T &dest)
        : mTemp(dest), mDest(dest)
    {}
    operator thread T &() { return mTemp; }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_Out<T> ANGLE_out(thread T &dest)
    return ANGLE_Out<T>(dest);
template <typename T, int VN, int SN>
struct ANGLE_SwizzleRef
    thread metal::vec<T, VN> &mVec;
    metal::vec<T, SN> mRef;
    int mIndices[SN];
    ~ANGLE_SwizzleRef()
    {
        for (int i = 0; i < SN; ++i)
        {
            const int j = mIndices[i];
            mVec[j] = mRef[i];
        }
    }
    ANGLE_SwizzleRef(thread metal::vec<T, VN> &vec, thread const int *indices)
        : mVec(vec)
    {
        for (int i = 0; i < SN; ++i)
        {
            const int j = indices[i];
            mIndices[i] = j;
            mRef[i] = mVec[j];
        }
    }
    operator thread metal::vec<T, SN> &() { return mRef; }
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_VectorElemRef<T, N> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0)
    const int is[] = { i0 };
    return ANGLE_VectorElemRef<T, N>(vec, is);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 2> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1)
    const int is[] = { i0, i1 };
    return ANGLE_SwizzleRef<T, N, 2>(vec, is);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 3> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1, int i2)
    const int is[] = { i0, i1, i2 };
    return ANGLE_SwizzleRef<T, N, 3>(vec, is);
template <typename T, int N>
ANGLE_ALWAYS_INLINE ANGLE_SwizzleRef<T, N, 4> ANGLE_swizzle_ref(thread metal::vec<T, N> &vec, int i0, int i1, int i2, int i3)
    const int is[] = { i0, i1, i2, i3 };
    return ANGLE_SwizzleRef<T, N, 4>(vec, is);
#define ANGLE_texelFetch(env, ...) ANGLE_texelFetch_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread Texture &texture,
    metal::int2 const coord,
    uint level)
    return texture.read(uint2(coord), level);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread Texture &texture,
    metal::int3 const coord,
    uint level)
    return texture.read(uint3(coord), level);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetch_impl(
    thread metal::texture2d_array<T> &texture,
    metal::int3 const coord,
    uint level)
    return texture.read(uint2(coord.xy), uint(coord.z), level);
template <typename T>
struct ANGLE_TextureEnv
    thread T *texture;
    thread metal::sampler *sampler;
#define ANGLE_texelFetchOffset(env, ...) ANGLE_texelFetchOffset_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread Texture &texture,
    metal::int2 const coord,
    uint level,
    metal::int2 const offset)
    return texture.read(uint2(coord + offset), level);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread Texture &texture,
    metal::int3 const coord,
    uint level,
    metal::int3 const offset)
    return texture.read(uint3(coord + offset), level);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texelFetchOffset_impl(
    thread metal::texture2d_array<T> &texture,
    metal::int3 const coord,
    uint level,
    metal::int2 const offset)
    return texture.read(uint2(coord.xy + offset), uint(coord.z), level);
metal::depth2d<
metal::depthcube<
metal::depth2d_array<
metal::texture2d_array<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias));
#define ANGLE_texture(env, ...) ANGLE_texture_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample_compare(sampler, coord.xy, coord.z);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias)
    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample_compare(sampler, coord.xyz, coord.w);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float compare)
    return texture.sample_compare(sampler, coord.xyz, uint(metal::round(coord.w)), compare);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample_compare(sampler, coord.xy, uint(metal::round(coord.z)), coord.w);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias)
    return texture.sample(sampler, coord.xyz, uint(metal::round(coord.w)), metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample(sampler, coord.xyz, uint(metal::round(coord.w)));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
#define ANGLE_texture1DLod(env, ...) ANGLE_texture1DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    float const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture1DProj(env, ...) ANGLE_texture1DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.x/coord.y, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.x/coord.w, metal::bias(bias));
#define ANGLE_texture1DProjLod(env, ...) ANGLE_texture1DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord.x/coord.y, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture1DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.x/coord.w, metal::level(level));
#define ANGLE_texture2D(env, ...) ANGLE_texture2D_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2D_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
#define ANGLE_texture2DLod(env, ...) ANGLE_texture2DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture2DProj(env, ...) ANGLE_texture2DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));
#define ANGLE_texture2DRect(env, ...) ANGLE_texture2DRect_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRect_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord)
    return texture.sample(sampler, coord);
#define ANGLE_texture2DRectProj(env, ...) ANGLE_texture2DRectProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
                        
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord.xy/coord.z);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DRectProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord)
    return texture.sample(sampler, coord.xy/coord.w);
#define ANGLE_texture3DLod(env, ...) ANGLE_texture3DLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_texture3DProj(env, ...) ANGLE_texture3DProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
#define ANGLE_texture3DProjLod(env, ...) ANGLE_texture3DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture3DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
#define ANGLE_textureCube(env, ...) ANGLE_textureCube_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord)
    return texture.sample(sampler, coord);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCube_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias));
#define ANGLE_textureCubeLod(env, ...) ANGLE_textureCubeLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_textureCubeProj(env, ...) ANGLE_textureCubeProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
#define ANGLE_textureCubeProjLod(env, ...) ANGLE_textureCubeProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureCubeProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
#define ANGLE_texture2DProjLod(env, ...) ANGLE_texture2DProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_texture2DProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));
metal::texturecube<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLE_UseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy)) > coord.z);
    }
#define ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX 0
#define ANGLE_SAMPLE_COMPARE_LOD_INDEX      1
#define ANGLE_RASTERIZATION_DISCARD_INDEX   2
#define ANGLE_COVERAGE_MASK_ENABLED_INDEX   3
constant bool ANGLE_UseSampleCompareGradient [[function_constant(ANGLE_SAMPLE_COMPARE_GRADIENT_INDEX)]];
constant bool ANGLE_UseSampleCompareLod      [[function_constant(ANGLE_SAMPLE_COMPARE_LOD_INDEX)]];
constant bool ANGLE_RasterizationDiscard     [[function_constant(ANGLE_RASTERIZATION_DISCARD_INDEX)]];
constant bool ANGLE_CoverageMaskEnabled      [[function_constant(ANGLE_COVERAGE_MASK_ENABLED_INDEX)]];
#define ANGLE_textureGrad(env, ...) ANGLE_textureGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLE_UseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy)) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    if (ANGLE_UseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xyz, metal::gradientcube(dPdx, dPdy)) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread metal::texturecube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy));
template <typename Texture, int N>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::vec<float, N> const coord,
    metal::vec<float, N> const dPdx,
    metal::vec<float, N> const dPdy)
    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy));
template <int N>
struct ANGLE_gradient_traits;
template <>
struct ANGLE_gradient_traits<2> { using type = metal::gradient2d; };
template <>
struct ANGLE_gradient_traits<3> { using type = metal::gradient3d; };
template <int N>
using ANGLE_gradient = typename ANGLE_gradient_traits<N>::type;
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    if (ANGLE_UseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::gradient2d(dPdx, dPdy), offset) > coord.z);
    }
#define ANGLE_textureGradOffset(env, ...) ANGLE_textureGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depth2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    if (ANGLE_UseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, uint(metal::round(coord.z)), coord.w, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset) > coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::depthcube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    metal::int3 const offset)
    return texture.sample_compare(sampler, coord.xyz, coord.w, metal::gradientcube(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread metal::texturecube<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    metal::int3 const offset)
    return texture.sample(sampler, coord, metal::gradientcube(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture, int N>
ANGLE_ALWAYS_INLINE auto ANGLE_textureGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::vec<float, N> const coord,
    metal::vec<float, N> const dPdx,
    metal::vec<float, N> const dPdy,
    metal::vec<int, N> const offset)
    return texture.sample(sampler, coord, ANGLE_gradient<N>(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    if (ANGLE_UseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level)) > coord.z);
    }
#define ANGLE_textureLod(env, ...) ANGLE_textureLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::level(level));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz, uint(metal::round(coord.w)), metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord, metal::level(level));
#define ANGLE_textureLodOffset(env, ...) ANGLE_textureLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    float level,
    metal::int2 const offset)
    return texture.sample(sampler, coord, metal::level(level), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    metal::int3 const offset)
    return texture.sample(sampler, coord, metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    int2 const offset)
    if (ANGLE_UseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy, coord.z, metal::level(level), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy, metal::level(level), offset) > coord.z);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureLodOffset_impl(
    thread metal::texture2d_array<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    metal::int3 const offset)
    return texture.sample(sampler, coord.xyz, uint(metal::round(coord.w)), metal::level(level), offset);
#define ANGLE_textureOffset(env, ...) ANGLE_textureOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    metal::int2 const offset)
    return texture.sample(sampler, coord, offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float2 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample(sampler, coord.xy, uint(metal::round(coord.z)), metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int3 const offset)
    return texture.sample(sampler, coord, offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int3 const offset,
    float bias)
    return texture.sample(sampler, coord, metal::bias(bias), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset)
    return texture.sample_compare(sampler, coord.xy, coord.z, offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::int2 const offset,
    float bias)
    return texture.sample_compare(sampler, coord.xy, coord.z, metal::bias(bias), offset);
#define ANGLE_textureProj(env, ...) ANGLE_textureProj_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProj_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias));
metal::texture3d<
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    if (ANGLE_UseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy)) > coord.z/coord.w);
    }
#define ANGLE_textureProjGrad(env, ...) ANGLE_textureProjGrad_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy)
    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGrad_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy)
    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    if (ANGLE_UseSampleCompareGradient)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::gradient2d(dPdx, dPdy), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset) > coord.z/coord.w);
    }
#define ANGLE_textureProjGradOffset(env, ...) ANGLE_textureProjGradOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float3 const dPdx,
    metal::float3 const dPdy,
    int3 const offset)
    return texture.sample(sampler, coord.xyz/coord.w, metal::gradient3d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.z, metal::gradient2d(dPdx, dPdy), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjGradOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    metal::float2 const dPdx,
    metal::float2 const dPdy,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.w, metal::gradient2d(dPdx, dPdy), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    if (ANGLE_UseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level)));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level)) > coord.z/coord.w);
    }
#define ANGLE_textureProjLod(env, ...) ANGLE_textureProjLod_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level));
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLod_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level));
#define ANGLE_textureProjLodOffset(env, ...) ANGLE_textureProjLodOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    float level,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.z, metal::level(level), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int2 const offset)
    return texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread metal::depth2d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int2 const offset)
    if (ANGLE_UseSampleCompareLod)
    {
        return static_cast<T>(texture.sample_compare(sampler, coord.xy/coord.w, coord.z/coord.w, metal::level(level), offset));
    }
    else
    {
        return static_cast<T>(texture.sample(sampler, coord.xy/coord.w, metal::level(level), offset) > coord.z/coord.w);
    }
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjLodOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    float level,
    int3 const offset)
    return texture.sample(sampler, coord.xyz/coord.w, metal::level(level), offset);
#define ANGLE_textureProjOffset(env, ...) ANGLE_textureProjOffset_impl(*env.texture, *env.sampler, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float3 const coord,
    int2 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.z, metal::bias(bias), offset);
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread Texture &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    int2 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xy/coord.w, metal::bias(bias), offset);
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureProjOffset_impl(
    thread metal::texture3d<T> &texture,
    thread metal::sampler const &sampler,
    metal::float4 const coord,
    int3 const offset,
    float bias = 0)
    return texture.sample(sampler, coord.xyz/coord.w, metal::bias(bias), offset);
#define ANGLE_textureSize(env, ...) ANGLE_textureSize_impl(*env.texture, __VA_ARGS__)
template <typename Texture>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread Texture &texture,
    int level)
    return int2(texture.get_width(uint(level)), texture.get_height(uint(level)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::texture3d<T> &texture,
    int level)
    return int3(texture.get_width(uint(level)), texture.get_height(uint(level)), texture.get_depth(uint(level)));
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::depth2d_array<T> &texture,
    int level)
    return int3(texture.get_width(uint(level)), texture.get_height(uint(level)), texture.get_array_size());
template <typename T>
ANGLE_ALWAYS_INLINE auto ANGLE_textureSize_impl(
    thread metal::texture2d_array<T> &texture,
    int level)
    return int3(texture.get_width(uint(level)), texture.get_height(uint(level)), texture.get_array_size());
#define ANGLE_ALWAYS_INLINE __attribute__((always_inline))
ANGLE_ALWAYS_INLINE int ANGLE_int_clamp(int value, int minValue, int maxValue)
    return ((value < minValue) ?  minValue : ((value > maxValue) ? maxValue : value));
template <typename T, int N>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::vec<T, N> u, metal::vec<T, N> v)
    return metal::all(u == v);
#include <metal_math>
template <typename T, int C, int R>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::matrix<T, C, R> a, metal::matrix<T, C, R> b)
    for (int c = 0; c < C; ++c)
    {
        if (!ANGLE_equal(a[c], b[c]))
        {
            return false;
        }
    }
    return true;
#if TRANSFORM_FEEDBACK_ENABLED
    #define __VERTEX_OUT(args) void
#else
    #define __VERTEX_OUT(args) args
#endif
ANGLE_ALWAYS_INLINE void ANGLE_writeSampleMask(const uint mask,
                                               thread uint& gl_SampleMask)
    if (ANGLE_CoverageMaskEnabled)
    {
        gl_SampleMask = as_type<int>(mask);
    }
TextureEnv<
ANGLE_RasterizationDiscard
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_radians(T x)
    return static_cast<T>(1.7453292519943295e-2) * x;
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_degrees(T x)
    return static_cast<T>(57.29577951308232) * x;
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_atan(T yOverX)
    return metal::atan(yOverX);
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_atan(T y, T x)
    return metal::atan2(y, x);
template <typename X, typename Y>
ANGLE_ALWAYS_INLINE X ANGLE_mod(X x, Y y)
    return x - y * metal::floor(x / y);
template <typename T, typename Enable = void>
struct ANGLE_refract_impl
    static ANGLE_ALWAYS_INLINE T exec(T i, T n, ANGLE_scalar_of_t<T> eta)
    {
        return metal::refract(i, n, eta);
    }
template <typename T>
struct ANGLE_refract_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T i, T n, T eta)
    {
        auto dotNI = n * i;
        auto k = T(1) - eta * eta * (T(1) - dotNI * dotNI);
        if (k < T(0))
        {
            return T(0);
        }
        else
        {
            return eta * i - (eta * dotNI + metal::sqrt(k)) * n;
        }
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_refract(T i, T n, ANGLE_scalar_of_t<T> eta)
    return ANGLE_refract_impl<T>::exec(i, n, eta);
template <typename T>
struct ANGLE_is_scalar {};
#define ANGLE_DEFINE_SCALAR(scalar) \
    template <> struct ANGLE_is_scalar<scalar> { enum { value = true }; }
ANGLE_DEFINE_SCALAR(bool);
ANGLE_DEFINE_SCALAR(char);
ANGLE_DEFINE_SCALAR(short);
ANGLE_DEFINE_SCALAR(int);
ANGLE_DEFINE_SCALAR(long);
ANGLE_DEFINE_SCALAR(uchar);
ANGLE_DEFINE_SCALAR(ushort);
ANGLE_DEFINE_SCALAR(uint);
ANGLE_DEFINE_SCALAR(ulong);
ANGLE_DEFINE_SCALAR(half);
ANGLE_DEFINE_SCALAR(float);
template <typename T>
struct ANGLE_is_vector
    enum { value = false };
#define ANGLE_DEFINE_VECTOR(scalar) \
    template <> struct ANGLE_is_vector<metal::scalar ## 2> { enum { value = true }; }; \
    template <> struct ANGLE_is_vector<metal::scalar ## 3> { enum { value = true }; }; \
    template <> struct ANGLE_is_vector<metal::scalar ## 4> { enum { value = true }; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4> { using type = scalar; }
ANGLE_DEFINE_VECTOR(bool);
ANGLE_DEFINE_VECTOR(char);
ANGLE_DEFINE_VECTOR(short);
ANGLE_DEFINE_VECTOR(int);
ANGLE_DEFINE_VECTOR(long);
ANGLE_DEFINE_VECTOR(uchar);
ANGLE_DEFINE_VECTOR(ushort);
ANGLE_DEFINE_VECTOR(uint);
ANGLE_DEFINE_VECTOR(ulong);
ANGLE_DEFINE_VECTOR(half);
ANGLE_DEFINE_VECTOR(float);
template <typename T>
struct ANGLE_scalar_of
    using type = T;
template <typename T>
using ANGLE_scalar_of_t = typename ANGLE_scalar_of<T>::type;
template <typename T>
struct ANGLE_is_matrix
    enum { value = false };
#define ANGLE_DEFINE_MATRIX(scalar) \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 2x4> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 3x4> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x2> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x3> { enum { value = true }; }; \
    template <> struct ANGLE_is_matrix<metal::scalar ## 4x4> { enum { value = true }; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 2x4> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 3x4> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x2> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x3> { using type = scalar; }; \
    template <> struct ANGLE_scalar_of<metal::scalar ## 4x4> { using type = scalar; }
ANGLE_DEFINE_MATRIX(half);
ANGLE_DEFINE_MATRIX(float);
template <typename T, typename Enable = void>
struct ANGLE_distance_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x, T y)
    {
        return metal::distance(x, y);
    }
template <typename T>
struct ANGLE_distance_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x, T y)
    {
        return metal::abs(x - y);
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_distance(T x, T y)
    return ANGLE_distance_impl<T>::exec(x, y);
template <typename T, typename Enable = void>
struct ANGLE_length_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x)
    {
        return metal::length(x);
    }
template <typename T>
struct ANGLE_length_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::abs(x);
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_length(T x)
    return ANGLE_length_impl<T>::exec(x);
template <typename T, typename Enable = void>
struct ANGLE_dot_impl
    static ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> exec(T x, T y)
    {
        return metal::dot(x, y);
    }
template <typename T>
struct ANGLE_dot_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x, T y)
    {
        return x * y;
    }
template <typename T>
ANGLE_ALWAYS_INLINE ANGLE_scalar_of_t<T> ANGLE_dot(T x, T y)
    return ANGLE_dot_impl<T>::exec(x, y);
template <typename T, typename Enable = void>
struct ANGLE_normalize_impl
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::normalize(x);
    }
template <typename T>
struct ANGLE_normalize_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return ANGLE_sign(x);
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_normalize(T x)
    return ANGLE_normalize_impl<T>::exec(x);
template <typename T, typename Enable = void>
struct ANGLE_faceforward_impl
    static ANGLE_ALWAYS_INLINE T exec(T n, T i, T nref)
    {
        return metal::faceforward(n, i, nref);
    }
template <typename T>
struct ANGLE_faceforward_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T n, T i, T nref)
    {
        return ANGLE_dot(nref, i) < T(0) ? n : -n;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_faceforward(T n, T i, T nref)
    return ANGLE_faceforward_impl<T>::exec(n, i, nref);
template <typename T, typename Enable = void>
struct ANGLE_reflect_impl
    static ANGLE_ALWAYS_INLINE T exec(T i, T n)
    {
        return metal::reflect(i, n);
    }
template <typename T>
struct ANGLE_reflect_impl<T, ANGLE_enable_if_t<ANGLE_is_scalar<T>::value>>
    static ANGLE_ALWAYS_INLINE T exec(T i, T n)
    {
        return i - T(2) * ANGLE_dot(n, i) * n;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_reflect(T i, T n)
    return ANGLE_reflect_impl<T>::exec(i, n);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_equal(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
        if (u[i] != v[i]) return false;
    return true;
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_equalStructArray(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
    {
        if (ANGLE_equal(u[i], v[i]) == false) 
            return false;
    }
    return true;
template <typename T, int N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::vec<T, N> u, metal::vec<T, N> v)
    return !ANGLE_equal(u, v);
template <typename T>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqualStruct(thread const T &a, thread const T &b)
    return !ANGLE_equal(a, b);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::array<T, N> u, metal::array<T, N> v)
    return !ANGLE_equal(u,v);
template <typename T, size_t N>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqualStructArray(metal::array<T, N> u, metal::array<T, N> v)
    for(size_t i = 0; i < N; i++)
    {
        if (ANGLE_notEqualStruct(u[i], v[i]))
            return true;
    }
    return false;
template <typename T, int C, int R>
ANGLE_ALWAYS_INLINE bool ANGLE_notEqual(metal::matrix<T, C, R> u, metal::matrix<T, C, R> v)
    return !ANGLE_equal(u, v);
#include <metal_geometric>
template <typename T, typename Enable = void>
struct ANGLE_sign_impl
    static ANGLE_ALWAYS_INLINE T exec(T x)
    {
        return metal::sign(x);
    }
template <>
struct ANGLE_sign_impl<int>
    static ANGLE_ALWAYS_INLINE int exec(int x)
    {
        return (0 < x) - (x < 0);
    }
template <int N>
struct ANGLE_sign_impl<metal::vec<int, N>>
    static ANGLE_ALWAYS_INLINE metal::vec<int, N> exec(metal::vec<int, N> x)
    {
        metal::vec<int, N> s;
        for (int i = 0; i < N; ++i)
        {
            s[i] = ANGLE_sign_impl<int>::exec(x[i]);
        }
        return s;
    }
template <typename T>
ANGLE_ALWAYS_INLINE T ANGLE_sign(T x)
    return ANGLE_sign_impl<T>::exec(x);
#include <metal_common>
                        
template <typename T, int N>
ANGLE_ALWAYS_INLINE metal::vec<T,N> ANGLE_mix_bool(metal::vec<T, N> a, metal::vec<T, N> b, metal::vec<bool, N> c)
    return metal::mix(a, b, static_cast<metal::vec<T,N>>(c));
#include <metal_relational>
#include <metal_graphics>
#include <metal_matrix>
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator+(metal::matrix<T, Cols, Rows> m, T x)
    m += x;
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator+=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] += x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator-(metal::matrix<T, Cols, Rows> m, T x)
    m -= x;
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator-=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] -= x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator/(metal::matrix<T, Cols, Rows> a, metal::matrix<T, Cols, Rows> b)
    for (size_t col = 0; col < Cols; ++col)
    {
        a[col] /= b[col];
    }
    return a;
#if __METAL_VERSION__ <= 220
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator/(metal::matrix<T, Cols, Rows> m, T x)
    m /= x;
    return m;
#endif
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator/=(thread metal::matrix<T, Cols, Rows> &m, T x)
    for (size_t col = 0; col < Cols; ++col)
    {
        m[col] /= x;
    }
    return m;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator/=(thread metal::matrix<T, Cols, Rows> &a, metal::matrix<T, Cols, Rows> b)
    a = a / b;
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> ANGLE_componentWiseMultiply(metal::matrix<T, Cols, Rows> a, metal::matrix<T, Cols, Rows> b)
    for (size_t col = 0; col < Cols; ++col)
    {
        a[col] *= b[col];
    }
    return a;
template <typename T, int M, int N>
ANGLE_ALWAYS_INLINE metal::matrix<T, N, M> ANGLE_outerProduct(metal::vec<T, M> u, metal::vec<T, N> v)
    metal::matrix<T, N, M> o;
    for (size_t n = 0; n < N; ++n)
    {
        o[n] = u * v[n];
    }
    return o;
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 2, 2> ANGLE_inverse(metal::matrix<T, 2, 2> m)
    metal::matrix<T, 2, 2> adj;
    adj[0][0] =  m[1][1];
    adj[0][1] = -m[0][1];
    adj[1][0] = -m[1][0];
    adj[1][1] =  m[0][0];
    T det = (adj[0][0] * m[0][0]) + (adj[0][1] * m[1][0]);
    return adj * (T(1) / det);
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 3, 3> ANGLE_inverse(metal::matrix<T, 3, 3> m)
    T a = m[1][1] * m[2][2] - m[2][1] * m[1][2];
    T b = m[1][0] * m[2][2];
    T c = m[1][2] * m[2][0];
    T d = m[1][0] * m[2][1];
    T det = m[0][0] * (a) -
            m[0][1] * (b - c) +
            m[0][2] * (d - m[1][1] * m[2][0]);
    det = T(1) / det;
    metal::matrix<T, 3, 3> minv;
    minv[0][0] = (a) * det;
    minv[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * det;
    minv[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * det;
    minv[1][0] = (c - b) * det;
    minv[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * det;
    minv[1][2] = (m[1][0] * m[0][2] - m[0][0] * m[1][2]) * det;
    minv[2][0] = (d - m[2][0] * m[1][1]) * det;
    minv[2][1] = (m[2][0] * m[0][1] - m[0][0] * m[2][1]) * det;
    minv[2][2] = (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * det;
    return minv;
template <typename T>
ANGLE_ALWAYS_INLINE metal::matrix<T, 4, 4> ANGLE_inverse(metal::matrix<T, 4, 4> m)
    T A2323 = m[2][2] * m[3][3] - m[2][3] * m[3][2];
    T A1323 = m[2][1] * m[3][3] - m[2][3] * m[3][1];
    T A1223 = m[2][1] * m[3][2] - m[2][2] * m[3][1];
    T A0323 = m[2][0] * m[3][3] - m[2][3] * m[3][0];
    T A0223 = m[2][0] * m[3][2] - m[2][2] * m[3][0];
    T A0123 = m[2][0] * m[3][1] - m[2][1] * m[3][0];
    T A2313 = m[1][2] * m[3][3] - m[1][3] * m[3][2];
    T A1313 = m[1][1] * m[3][3] - m[1][3] * m[3][1];
    T A1213 = m[1][1] * m[3][2] - m[1][2] * m[3][1];
    T A2312 = m[1][2] * m[2][3] - m[1][3] * m[2][2];
    T A1312 = m[1][1] * m[2][3] - m[1][3] * m[2][1];
    T A1212 = m[1][1] * m[2][2] - m[1][2] * m[2][1];
    T A0313 = m[1][0] * m[3][3] - m[1][3] * m[3][0];
    T A0213 = m[1][0] * m[3][2] - m[1][2] * m[3][0];
    T A0312 = m[1][0] * m[2][3] - m[1][3] * m[2][0];
    T A0212 = m[1][0] * m[2][2] - m[1][2] * m[2][0];
    T A0113 = m[1][0] * m[3][1] - m[1][1] * m[3][0];
    T A0112 = m[1][0] * m[2][1] - m[1][1] * m[2][0];
    T a = m[1][1] * A2323 - m[1][2] * A1323 + m[1][3] * A1223;
    T b = m[1][0] * A2323 - m[1][2] * A0323 + m[1][3] * A0223;
    T c = m[1][0] * A1323 - m[1][1] * A0323 + m[1][3] * A0123;
    T d = m[1][0] * A1223 - m[1][1] * A0223 + m[1][2] * A0123;
    T det = m[0][0] * ( a )
          - m[0][1] * ( b )
          + m[0][2] * ( c )
          - m[0][3] * ( d );
    det = T(1) / det;
    metal::matrix<T, 4, 4> im;
    im[0][0] = det *   ( a );
    im[0][1] = det * - ( m[0][1] * A2323 - m[0][2] * A1323 + m[0][3] * A1223 );
    im[0][2] = det *   ( m[0][1] * A2313 - m[0][2] * A1313 + m[0][3] * A1213 );
    im[0][3] = det * - ( m[0][1] * A2312 - m[0][2] * A1312 + m[0][3] * A1212 );
    im[1][0] = det * - ( b );
    im[1][1] = det *   ( m[0][0] * A2323 - m[0][2] * A0323 + m[0][3] * A0223 );
    im[1][2] = det * - ( m[0][0] * A2313 - m[0][2] * A0313 + m[0][3] * A0213 );
    im[1][3] = det *   ( m[0][0] * A2312 - m[0][2] * A0312 + m[0][3] * A0212 );
    im[2][0] = det *   ( c );
    im[2][1] = det * - ( m[0][0] * A1323 - m[0][1] * A0323 + m[0][3] * A0123 );
    im[2][2] = det *   ( m[0][0] * A1313 - m[0][1] * A0313 + m[0][3] * A0113 );
    im[2][3] = det * - ( m[0][0] * A1312 - m[0][1] * A0312 + m[0][3] * A0112 );
    im[3][0] = det * - ( d );
    im[3][1] = det *   ( m[0][0] * A1223 - m[0][1] * A0223 + m[0][2] * A0123 );
    im[3][2] = det * - ( m[0][0] * A1213 - m[0][1] * A0213 + m[0][2] * A0113 );
    im[3][3] = det *   ( m[0][0] * A1212 - m[0][1] * A0212 + m[0][2] * A0112 );
    return im;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator*=(thread metal::matrix<T, Cols, Rows> &a, metal::matrix<T, Cols, Cols> b)
    a = a * b;
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator++(thread metal::matrix<T, Cols, Rows> &a)
    a += T(1);
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator++(thread metal::matrix<T, Cols, Rows> &a, int)
    auto b = a;
    a += T(1);
    return b;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE thread metal::matrix<T, Cols, Rows> &operator--(thread metal::matrix<T, Cols, Rows> &a)
    a -= T(1);
    return a;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator--(thread metal::matrix<T, Cols, Rows> &a, int)
    auto b = a;
    a -= T(1);
    return b;
template <typename T, int Cols, int Rows>
ANGLE_ALWAYS_INLINE metal::matrix<T, Cols, Rows> operator-(metal::matrix<T, Cols, Rows> m)
    for (size_t col = 0; col < Cols; ++col)
    {
        thread auto &mCol = m[col];
        mCol = -mCol;
    }
    return m;
#include <metal_pack>
ANGLE_ALWAYS_INLINE uint ANGLE_pack_half_2x16(float2 v)
    return as_type<uint>(half2(v));
ANGLE_ALWAYS_INLINE float2 ANGLE_unpack_half_2x16(uint x)
    return float2(as_type<half2>(x));
fixIndexBufferKey
fixIndexBuffer
Cannot have multiple different work group size specifiers
Cannot have multiple different primitive specifiers
Cannot have multiple different invocations specifiers
Cannot have multiple different max_vertices specifiers
Cannot have multiple index specifiers
qualifier sequence
unknown geometry shader primitive type
The invariant qualifier specified multiple times.
The precise qualifier specified multiple times.
The precision qualifier specified multiple times.
The layout qualifier specified multiple times.
The layout qualifier and invariant qualifier cannot coexist in the same declaration according to the grammar.
The interpolation qualifier specified multiple times.
 specified multiple times
Output layout location specified multiple times.
The invariant qualifier has to be first in the expression.
Storage qualifiers have to be after interpolation qualifiers.
Precision qualifiers have to be after interpolation qualifiers.
Storage qualifiers have to be after layout qualifiers.
Precision qualifiers have to be after layout qualifiers.
Precision qualifiers have to be after storage qualifiers.
Precision qualifiers have to be after memory qualifiers.
invalid parameter qualifier
Invalid parameter qualifier 
invalid qualifier combination
Unreachable Code.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/QueryGL.cpp
QueryMtl=%p
_webgl_struct_
Performance: dynamic indexing of vectors and matrices is emulated and can be slow.
dyn_index_
write_
ivec
bvec
uvec
base
value
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/RenderbufferGL.cpp
setStorage
functions->renderbufferStorage(GL_RENDERBUFFER, renderbufferFormat.internalFormat, width, height)
setStorageMultisample
functions->renderbufferStorageMultisample( GL_RENDERBUFFER, samples, renderbufferFormat.internalFormat, width, height)
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/RenderBufferMtl.mm
setStorageImpl
Integer overflow.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/renderer_utils.cpp
ComputeStartVertex
LogFeatureStatus
Feature: 
 enabled
 disabled
 is not a valid feature name.
ANGLE_FEATURE_OVERRIDES_ENABLED
ANGLE_FEATURE_OVERRIDES_DISABLED
debug.angle.feature_overrides_enabled
debug.angle.feature_overrides_disabled
, OpenGL
 compatibility
 core
avoid_1_bit_alpha_texture_formats
Issue with 1-bit alpha framebuffer formats
rgba4_is_not_supported_for_color_rendering
GL_RGBA4 is not color renderable
does_srgb_clears_on_linear_framebuffer_attachments
Issue clearing framebuffers with linear attachments when GL_FRAMEBUFFER_SRGB is enabled
do_while_glsl_causes_gpu_hang
Some GLSL constructs involving do-while loops cause GPU hangs
http://crbug.com/644669
vertex_id_does_not_include_base_vertex
gl_VertexID in GLSL vertex shader doesn't include base vertex value
finish_does_not_cause_queries_to_be_available
glFinish doesn't cause all queries to report available result
always_call_use_program_after_link
Always call useProgram after a successful link to avoid a driver bug
http://crbug.com/110263
unpack_overlapping_rows_separately_unpack_buffer
In the case of unpacking from a pixel unpack buffer, unpack overlapping rows row by row
pack_overlapping_rows_separately_pack_buffer
In the case of packing to a pixel pack buffer, pack overlapping rows row by row
initialize_current_vertex_attributes
During initialization, assign the current vertex attributes to the spec-mandated defaults
emulate_abs_int_function
abs(i) where i is an integer returns unexpected result
http://crbug.com/642227
add_and_true_to_loop_condition
Calculation of loop conditions in for and while loop has bug
unpack_last_row_separately_for_padding_inclusion
When uploading textures from an unpack buffer, some drivers count an extra row padding
http://anglebug.com/1512
pack_last_row_separately_for_padding_inclusion
When uploading textures from an pack buffer, some drivers count an extra row padding
emulate_isnan_float
Using isnan() on highp float will get wrong answer
http://crbug.com/650547
use_unused_blocks_with_standard_or_shared_layout
Unused std140 or shared uniform blocks will be treated as inactive
remove_invarient_and_centroid_for_essl3
Fix spec difference between GLSL 4.1 or lower and ESSL3
rewrite_float_unary_minus_operator
Using '-<float>' will get wrong answer
http://crbug.com/308366
emulate_atan_2_float
atan(y, x) may return a wrong answer
http://crbug.com/672380
reapply_ubo_bindings_after_using_binary_program
Some drivers forget about UBO bindings when using program binaries
http://anglebug.com/1637
emulate_max_vertex_attrib_stride
Some drivers return 0 when MAX_VERTEX_ATTRIB_STRIED queried
http://anglebug.com/1936
dont_initialize_uninitialized_locals
Initializing uninitialized locals caused odd behavior in a few WebGL 2 tests
http://anglebug.com/2046
clamp_point_size
The point size range reported from the API is inconsistent with the actual behavior
rewrite_vector_scalar_arithmetic
Certain types of GLSL arithmetic ops mixing vectors and scalars may be executed incorrectly
http://crbug.com/772651
dont_use_loops_to_initialize_variables
For loops used to initialize variables hit native GLSL compiler bugs
http://crbug.com/809422
clamp_frag_depth
gl_FragDepth is not clamped correctly when rendering to a floating point depth buffer
rewrite_repeated_assign_to_swizzled
Repeated assignment to swizzled values inside a GLSL user-defined function have incorrect results
disable_blend_func_extended
ARB_blend_func_extended does not pass the tests
http://anglebug.com/1085
unsized_srgb_read_pixels_doesnt_transform
Drivers returning raw sRGB values instead of linearized values when calling glReadPixels on unsized sRGB texture formats
http://crbug.com/565179
query_counter_bits_generates_errors
Drivers generate errors when querying the number of bits in timer queries
http://anglebug.com/3027
dont_relink_programs_in_parallel
Relinking a program in parallel is buggy
http://anglebug.com/3045
disable_worker_contexts
Some tests have been seen to fail using worker contexts
http://crbug.com/849576
max_texture_size_limit_4096
Limit max texture size to 4096 to avoid frequent out-of-memory errors
http://crbug.com/927470
max_msaa_sample_count_4
Various rendering bugs have been observed when using higher MSAA counts
http://crbug.com/797243
allow_clear_for_robust_resource_init
Using glClear for robust resource initialization is buggy on some drivers and leads to texture corruption. Default to data uploads except on MacOS where it is very slow.
http://crbug.com/883276
clamp_array_access
Clamp uniform array access to avoid reading invalid memory.
http://anglebug.com/2978
reset_teximage2d_base_level
Reset texture base level before calling glTexImage2D to work around pixel comparison failure.
https://crbug.com/705865
clear_to_zero_or_one_broken
Clears when the clear color is all zeros or ones do not work.
https://crbug.com/710443
max_3d_array_texture_size_1024
Limit max 3d texture size and max array texture layers to 1024 to avoid system hang
adjust_src_dst_region_for_blitframebuffer
Many platforms have issues with blitFramebuffer when the parameters are large.
http://crbug.com/830046
clip_src_region_for_blitframebuffer
Issues with blitFramebuffer when the parameters don't match the framebuffer size.
reset_texture_generates_errors
Calling glTexImage2D with zero size generates errors.
http://anglebug.com/3859
rgb_dxt1_textures_sample_zero_alpha
Sampling BLACK texels from RGB DXT1 textures returns transparent black on Mac.
http://anglebug.com/3729
unfold_short_circuits
Mac incorrectly executes both sides of && and || expressions when they should short-circuit.
http://anglebug.com/482
emulate_primitive_restart_fixed_index
When GL_PRIMITIVE_RESTART_FIXED_INDEX is not available, emulate it with GL_PRIMITIVE_RESTART and glPrimitiveRestartIndex.
http://anglebug.com/3997
set_primitive_restart_fixed_index_for_draw_arrays
Some drivers discard vertex data in DrawArrays calls when the fixed primitive restart index is within the number of primitives being drawn.
remove_dynamic_indexing_of_swizzled_vector
Dynamic indexing of swizzled l-values doesn't work correctly on various platforms.
http://crbug.com/709351
pre_add_texel_fetch_offsets
Intel Mac drivers mistakenly consider the parameter position of nagative vaule as invalid even if the sum of position and offset is in range, so we need to add workarounds by rewriting texelFetchOffset(sampler, position, lod, offset) into texelFetch(sampler, position + offset, lod).
http://crbug.com/642605
regenerate_struct_names
All Mac drivers do not handle struct scopes correctly. This workaround overwrites a structname with a unique prefix.
http://crbug.com/403957
read_pixels_using_implementation_color_read_format
Quite some OpenGL ES drivers don't implement readPixels for RGBA/UNSIGNED_SHORT from EXT_texture_norm16 correctly
http://anglebug.com/4214
flush_before_delete_texture_if_copied_to
Some drivers track CopyTex{Sub}Image texture dependencies incorrectly. Flush before glDeleteTextures in this case
http://anglebug.com/4267
Rewrite row major matrices in shaders as column major as a driver bug workaround
http://anglebug.com/2273
avoid_dxt1_srgb_texture_format
Replaces DXT1 sRGB with DXT1 sRGB Alpha as a driver bug workaround.
disable_draw_buffers_indexed
Disable OES_draw_buffers_indexed extension.
disable_semaphore_fd
Disable GL_EXT_semaphore_fd extension
https://crbug.com/1046462
disable_timestamp_queries
Disable GL_EXT_disjoint_timer_query extension
https://crbug.com/811661
decode_encode_srgb_for_generatemipmap
Decode and encode before generateMipmap for srgb format textures.
http://anglebug.com/4646
emulate_copyteximage2d_from_renderbuffers
CopyTexImage2D spuriously returns errors on iOS when copying from renderbuffers.
https://anglebug.com/4674
disable_gpu_switching_support
Disable GPU switching support (use only the low-power GPU) on older MacBook Pros.
https://crbug.com/1091824
disable_native_parallel_compile
Do not use native KHR_parallel_shader_compile even when available.
http://crbug.com/1094869
emulate_pack_skip_rows_and_pack_skip_pixels
GL_PACK_SKIP_ROWS and GL_PACK_SKIP_PIXELS are ignored in Apple's OpenGL driver.
https://anglebug.com/4849
clamp_msc_rate
Some drivers return bogus values for GetMscRate, so we clamp it to 30Hz
https://crbug.com/1042393
bind_transform_feedback_buffer_before_bind_buffer_range
Bind transform feedback buffers to the generic binding point before calling glBindBufferBase or glBindBufferRange.
https://anglebug.com/5140
disable_sync_control_support
Speculative fix for issues on Linux/Wayland where exposing GLX_OML_sync_control renders Chrome unusable
https://crbug.com/1137851
keep_buffer_shadow_copy
Maintain a shadow copy of buffer data when the GL API does not permit reading data back.
set_zero_level_before_generating_mipmap
glGenerateMipmap fails if the zero texture level is not set on some Mac drivers.
promote_packed_formats_to_8_bit_per_channel
Packed color formats are buggy on Macs with AMD GPUs
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/RendererGL.cpp
LogGLDebugMessage
Source: 
Type: 
ID: 
Severity: 
Message: 
extension `GL_ARB_gpu_shader5' unsupported in
extension `GL_EXT_gpu_shader5' unsupported in
Adreno (TM) 418
Adreno (TM) 530
Adreno (TM) 540
Mesa %d.%d.%d
GL_EXT_texture_lod_bias
ARB_draw_buffers
GL_ARB_sync
GL_ARB_texture_swizzle
GL_EXT_texture_swizzle
GL_ARB_explicit_attrib_location
GL_ARB_shader_storage_buffer_object
GL_ARB_explicit_uniform_location
GL_ARB_texture_gather
GL_ARB_texture_cube_map_array
GL_ARB_pixel_buffer_object
GL_EXT_pixel_buffer_object
GL_EXT_draw_buffers2
GL_ARB_fragment_shader
GL_ARB_shader_texture_lod
GL_ARB_shader_viewport_layer_array
GL_NV_viewport_array2
GL_NV_texture_border_clamp
GL_ARB_robust_buffer_access_behavior
GL_EXT_framebuffer_sRGB
GL_ARB_framebuffer_sRGB
GL_ARB_gpu_shader5
functions->standard == STANDARD_GL_DESKTOP && isAMD
functions->standard == STANDARD_GL_DESKTOP && isIntel
IsApple() && isIntel
isIntel && IsApple() && IsSkylake(device) && GetMacOSVersion() < OSVersion(10, 13, 2)
functions->standard == STANDARD_GL_DESKTOP && (isIntel || isAMD)
IsLinux() && functions->standard == STANDARD_GL_DESKTOP && isAMD
(IsApple() && functions->standard == STANDARD_GL_DESKTOP) || (IsLinux() && isAMD)
IsApple() && functions->standard == STANDARD_GL_DESKTOP && GetMacOSVersion() < OSVersion(10, 11, 0)
IsApple() && isIntel && GetMacOSVersion() < OSVersion(10, 12, 0)
IsApple() && isAMD
IsAndroid() && isQualcomm
functions->standard == STANDARD_GL_DESKTOP && isNvidia
isNvidia
IsApple() || isNvidia
functions->isAtMostGL(gl::Version(4, 1)) || (functions->standard == STANDARD_GL_DESKTOP && isAMD)
isAMD || IsAndroid()
IsAndroid() || isNvidia
(IsAndroid() && isQualcomm) || (isIntel && IsApple())
isAMD || isIntel
IsNexus5X(vendor, device)
IsAndroid() || (IsWindows() && isIntel)
(IsWindows() && (isIntel || isAMD)) || (IsLinux() && isNvidia) || IsIOS()
IsAndroid() || limitMaxTextureSize
IsAndroid() || (IsApple() && (isIntel || isAMD || isNvidia))
limitMaxTextureSize
IsApple()
IsAndroid() || isAMD || !functions->hasExtension("GL_KHR_robust_buffer_access_behavior")
IsApple() && isIntel && GetMacOSVersion() >= OSVersion(10, 12, 4)
IsApple() && isIntel && GetMacOSVersion() < OSVersion(10, 12, 6)
IsLinux() || (IsAndroid() && isNvidia) || (IsWindows() && isNvidia) || (IsApple() && functions->standard == STANDARD_GL_ES)
IsApple() || (IsLinux() && isAMD)
IsApple() || (IsWindows() && isAMD)
functions->standard == STANDARD_GL_DESKTOP && functions->isAtLeastGL(gl::Version(3, 1)) && !functions->isAtLeastGL(gl::Version(4, 3))
features->emulatePrimitiveRestartFixedIndex.enabled && IsApple() && isIntel
IsApple() || IsAndroid() || IsWindows()
functions->standard == STANDARD_GL_ES && functions->isAtLeastGLES(gl::Version(3, 1)) && functions->hasGLESExtension("GL_EXT_texture_norm16")
IsWindows() && isIntel
IsWindows() && isAMD
IsLinux() && isAMD && isMesa && mesaVersion < (std::array<int, 3>{19, 3, 5})
IsLinux() && isVMWare
IsApple() && functions->standard == STANDARD_GL_ES && !(isAMD && IsWindows())
isDualGPUMacWithNVIDIA
isTSANBuild && IsLinux() && isNvidia
IsApple() && (isAMD || isIntel || isNvidia)
IsLinux() && IsWayland()
!CanMapBufferForRead(functions)
IsApple() && hasAMD
GL_ARB_compute_shader
GL_ARB_occlusion_query2
GL_EXT_occlusion_query_boolean
GL_ARB_internalformat_query2
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/renderergl_utils.cpp
ClearErrors
Preexisting GL error 
 as of 
Unexpected driver error.
CheckError
GL call 
 generated error 
 in 
Additional GL error 
 generated.
Integer overflow.
ShouldApplyLastRowPaddingWorkaround
ANGLEClipDistance
counters
atomicCounters
arrayIndex
ANGLE_atomic_uint
atomicCounterIncrement
atomicCounterDecrement
textureCubeGrad
dPdx
dPdy
dUVdx
dUVdy
ANGLECubeMapCoordTransform
ANGLECubeMapCoordTransformImplicit
sampler
from
main
GMT_DISABLE_SEPARATE_COMPOUND_EXPRESSIONS
__unnamed
VERTEX
FRAGMENT
COMPUTE
GEOMETRY
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Shader.cpp
resolveCompile
Integer overflow when computing the product of local_size_x, 
local_size_y and local_size_z.
The total number of invocations within a work group exceeds 
MAX_COMPUTE_WORK_GROUP_INVOCATIONS.
Exceeded maximum shared memory size
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/ShaderGL.cpp
checkShader
Shader compilation failed with no info log.
TranslateTaskGL::run
source
TranslateTask::run
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/State.cpp
setProgram
Attempted to use a program that was not successfully linked
gpu.angle
egl::Surface::swap
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Surface.cpp
operator()
Unhandled internal error: 
swapWithDamage implementation missing.
setPresentationTime implementation missing.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/SurfaceMtl.mm
obtainNextDrawable
main
atomicCounter
constant
device
thread
metal::texture1d<float>
metal::texture1d<int>
metal::texture1d<uint>
metal::texture1d_array<float>
metal::texture1d_array<int>
metal::texture1d_array<uint>
metal::texture_buffer<float>
metal::texture_buffer<int>
metal::texture_buffer<uint>
metal::texture2d<float>
metal::texture2d<int>
metal::texture2d<uint>
metal::texture3d<float>
metal::texture3d<int>
metal::texture3d<uint>
metal::texturecube<float>
metal::texturecube<int>
metal::texturecube<uint>
metal::texture2d_array<float>
metal::texture2d_array<int>
metal::texture2d_array<uint>
metal::texture2d_ms<float>
metal::texture2d_ms<int>
metal::texture2d_ms<uint>
metal::texture2d_ms_array<float>
metal::texture2d_ms_array<int>
metal::texture2d_ms_array<uint>
metal::texturecube_array<float>
metal::texturecube_array<int>
metal::texturecube_array<uint>
metal::TODO<float>
metal::TODO<int>
metal::TODO<uint>
metal::depth2d<float>
metal::depth2d<int>
metal::depth2d<uint>
metal::depthcube<float>
metal::depthcube<int>
metal::depthcube<uint>
metal::depth2d_array<float>
metal::depth2d_array<int>
metal::depth2d_array<uint>
metal::depthcube_array<float>
metal::depthcube_array<int>
metal::depthcube_array<uint>
gl_in
angle_BaseInstance
angle_BaseVertex
gl_BaseInstance
gl_BaseVertex
gl_DrawID
gl_FragColor
gl_FragCoord
gl_FragDepth
gl_FrontFacing
gl_GlobalInvocationID
gl_HelperInvocation
gl_InstanceID
gl_InstanceIndex
gl_InvocationID
gl_LastFragColor
gl_LastFragColorARM
gl_Layer
gl_LocalInvocationID
gl_LocalInvocationIndex
gl_NumWorkGroups
gl_PointCoord
gl_PointSize
gl_Position
gl_PrimitiveID
gl_PrimitiveIDIn
gl_SecondaryFragColorEXT
gl_VertexID
gl_VertexIndex
gl_ViewID_OVR
gl_ViewportIndex
gl_WorkGroupID
gl_WorkGroupSize
gl_DepthRangeParameters
gl_DepthRange
gl_MaxVertexAttribs
gl_MaxVertexUniformVectors
gl_MaxVertexTextureImageUnits
gl_MaxCombinedTextureImageUnits
gl_MaxTextureImageUnits
gl_MaxFragmentUniformVectors
gl_MaxVaryingVectors
gl_MaxDrawBuffers
gl_MaxDualSourceDrawBuffersEXT
gl_MaxVertexOutputVectors
gl_MaxFragmentInputVectors
gl_MinProgramTexelOffset
gl_MaxProgramTexelOffset
gl_MaxImageUnits
gl_MaxVertexImageUniforms
gl_MaxFragmentImageUniforms
gl_MaxComputeImageUniforms
gl_MaxCombinedImageUniforms
gl_MaxCombinedShaderOutputResources
gl_MaxComputeWorkGroupCount
gl_MaxComputeWorkGroupSize
gl_MaxComputeUniformComponents
gl_MaxComputeTextureImageUnits
gl_MaxComputeAtomicCounters
gl_MaxComputeAtomicCounterBuffers
gl_MaxVertexAtomicCounters
gl_MaxFragmentAtomicCounters
gl_MaxCombinedAtomicCounters
gl_MaxAtomicCounterBindings
gl_MaxVertexAtomicCounterBuffers
gl_MaxFragmentAtomicCounterBuffers
gl_MaxCombinedAtomicCounterBuffers
gl_MaxAtomicCounterBufferSize
gl_MaxGeometryInputComponents
gl_MaxGeometryOutputComponents
gl_MaxGeometryImageUniforms
gl_MaxGeometryTextureImageUnits
gl_MaxGeometryOutputVertices
gl_MaxGeometryTotalOutputComponents
gl_MaxGeometryUniformComponents
gl_MaxGeometryAtomicCounters
gl_MaxGeometryAtomicCounterBuffers
gl_FragData
gl_SecondaryFragDataEXT
gl_FragDepthEXT
gl_LastFragData
gl_ClipDistance
gl_MaxClipDistances
gl_PerVertex
gl_in
textureProj(00R30B00B
imageAtomicExchange(01g00D00E
interpolateAtOffset(30B10B
textureProjOffset(00g10B00D
imageAtomicOr(00z10D00D
texture2DProj(00I20B
textureProjGradOffset(00v30B10B10B10D
texelFetch(00o00D00D
imageLoad(01g00D
imageAtomicAdd(01S10D00D00E
imageLoad(01I20D
tanh(30B
imageAtomicCompSwap(01E20D00D00D
textureQueryLod(00m00B
not(10F
findMSB(20E
lessThanEqual(30B30B
imageAtomicAdd(00z10D00E
textureLod(00t00B00B
textureProjGradOffset(00O30B10B10B10D
outerProduct(20B30B
imageAtomicOr(00z10D00E
imageSamples(01W
imageSamples(01V
imageSamples(01U
imageSamples(01T
imageSamples(01S
mix(20B20B00B
textureLodOffset(00o00B00B00D
imageAtomicMin(01S10D00D00E
uintBitsToFloat(30E
imageAtomicExchange(01R10D00D00B
textureSize(00K00D
textureSize(00h00D
texelFetchOffset(00q10D10D
greaterThanEqual(10E10E
texture(00d20B
atan(10B10B
clamp(30B30B30B
imageAtomicCompSwap(01a20D00E00E
imageAtomicCompSwap(01R10D00D00D00D
textureLodOffset(00a20B00B10D
greaterThanEqual(20B20B
imageLoad(01F20D
ceil(10C
imageAtomicCompSwap(01b20D00D00D
imageAtomicAnd(01A10D00D
imageAtomicAdd(01D20D00E
atomicAdd(00D00D
textureSize(00p00D
floatBitsToUint(20B
textureProjOffset(00t30B00D00B
mix(20D20D20F
degrees(20B
imageAtomicMin(01Y10D00D
imageAtomicXor(01R10D00D00D
imageAtomicCompSwap(01D20D00D00D
min(00C00C
imageAtomicMax(01S10D00D00E
inversesqrt(00C
inversesqrt(00B
texelFetchOffset(00J20D00D20D
textureProjGrad(00S30B20B20B
equal(10D10D
max(30D00D
groupMemoryBarrier(
imageAtomicExchange(01b20D00B
imageAtomicExchange(01b20D00E
imageAtomicExchange(01b20D00D
step(20C20C
texelFetch(00I10D00D
mod(00C00C
transpose(E0B
imageAtomicMin(01R10D00D00E
imageAtomicMin(01R10D00D00D
imageAtomicExchange(01i00D00E
textureGather(00O20B
textureProjOffset(00Y30B20D00B
imageStore(01C20D30B
modf(10B10B
determinant(50B
imageAtomicCompSwap(01J20D00E00E
textureProj(00g10B00B
lessThan(20B20B
imageAtomicCompSwap(01W20D00D00E00E
imageStore(01K20D30E
sign(20C
cosh(20B
sign(20D
atanh(00B
imageAtomicAnd(01V20D00D00E
imageAtomicAnd(01V20D00D00D
textureProj(00t10B
texture(00p20B00B
fma(10C10C10C
imageAtomicXor(01Y10D00D
imageAtomicXor(01Y10D00E
imageAtomicAnd(01C20D00E
textureOffset(00d20B10D00B
textureOffset(00m20B00D
imageAtomicAnd(01C20D00D
lessThan(10E10E
imageAtomicCompSwap(01A10D00D00D
textureGrad(00X00B00B00B
textureProjLodOffset(00t30B00B00D
fma(30C30C30C
textureGrad(00v10B10B10B
textureProj(00N30B00B
step(00C00C
imageAtomicCompSwap(01T10D00D00D00D
texture(00I10B00B
texelFetch(00j00D
lessThan(20D20D
clamp(20C20C20C
imageAtomicXor(00z10D00E
all(10F
dFdyCoarse(00B
isinf(30B
textureGatherOffset(00a20B10D00D
textureGatherOffset(00I10B10D
textureProjOffset(00q30B10D
textureOffset(00L20B10D
lessThanEqual(30E30E
min(10E00E
imageAtomicXor(01a20D00E
imageAtomicXor(01a20D00D
textureProjOffset(00S30B20D
round(00C
round(00B
greaterThan(30D30D
texture(00U20B
imageAtomicCompSwap(01P10D00E00E
smoothstep(00C00C20C
texture2DRect(00O10B
imageLoad(01N00D
noise2(20B
step(20B20B
imageAtomicAnd(01b20D00E
findMSB(10E
findMSB(10D
interpolateAtOffset(00B10B
texture(00t00B
textureLodOffset(00S20B00B20D
textureQueryLod(00p00B
imageStore(00z10D30B
textureGatherOffsets(00X10B10Dx400D
outerProduct(10B20B
imageAtomicMax(01Z10D00E
fwidthFine(10B
cos(30B
unpackHalf2x16(00E
outerProduct(10B10B
imageAtomicOr(01M00D00D
imageAtomicMax(01Y10D00E
imageAtomicMax(01Y10D00D
sin(30B
imageAtomicAnd(01O10D00D
textureGather(00L20B00D
imageStore(01i00D30E
imageStore(01A10D30D
imageAtomicXor(01H20D00D
imageAtomicXor(01H20D00E
shadow1D(00m20B00B
max(10E10E
max(30B30B
clamp(10E10E10E
texture(00N10B
textureProjGrad(00t30B00B00B
imageAtomicOr(01E20D00D
imageAtomicOr(01E20D00E
texelFetchOffset(00a20D00D10D
imageLoad(01V20D00D
not(20F
imageAtomicExchange(01F20D00D
imageAtomicExchange(01F20D00B
imageStore(01L00D30B
outerProduct(20B20B
imageAtomicXor(01D20D00D
textureProjLodOffset(00R20B00B10D
textureOffset(00p10B00D
texture(00h20B
textureProjGrad(00J30B20B20B
imageAtomicOr(01R10D00D00E
imageAtomicOr(01R10D00D00D
textureProjOffset(00g10B00D00B
imageAtomicAnd(01R10D00D00D
imageAtomicAdd(01E20D00E
radians(10B
textureGatherOffset(00n10B00B10D
noise2(10B
textureQueryLod(00a10B
textureGather(00e20B00B
distance(10B10B
textureGrad(00Z20B20B20B
sign(00B
bitfieldReverse(00D
bitfieldReverse(00E
bitfieldExtract(30E00D00D
textureLod(00I10B00B
greaterThanEqual(10D10D
imageAtomicCompSwap(01I20D00E00E
degrees(30B
inversesqrt(30B
inversesqrt(30C
imageAtomicMin(01I20D00D
textureGather(00v20B00D
intBitsToFloat(20D
exp(20B
imageAtomicMax(01A10D00E
imageAtomicMax(01A10D00D
acosh(00B
log(10B
textureProjLodOffset(00S30B00B20D
textureGather(00L20B
textureProj(00n30B
textureQueryLod(00i00B
texture(00p20B
outerProduct(30B20B
texture(00S20B
atomicXor(00D00D
texelFetch(00Y20D00D
imageAtomicOr(01P10D00D
imageAtomicOr(01P10D00E
bitfieldExtract(10D00D00D
sign(30B
sign(30C
sign(30D
texture(00Y20B00B
dFdy(20B
textureProj(00Y30B
textureOffset(00X10B10D00B
memoryBarrierBuffer(
isinf(00B
isinf(00C
clamp(20D00D00D
texture2DProj(00I20B00B
mod(30B00B
imageAtomicAnd(01A10D00E
textureGather(00f20B00B
textureProj(00m30B
greaterThan(20E20E
textureProjLod(00I30B00B
refract(00B00B00B
imageAtomicMin(01X10D00D
imageAtomicMin(01X10D00E
noise4(20B
textureSize(00e00D
imageStore(01N00D30E
texelFetch(00a20D00D
step(00C10C
frexp(30B30D
imageAtomicMin(01Y10D00E
texture(00t00B00B
min(30C00C
imageAtomicCompSwap(01X10D00E00E
texture(00I10B
normalize(20B
normalize(20C
imageAtomicCompSwap(01H20D00D00D
inverse(F0B
frexp(20C20D
atan(00B
textureGatherOffset(00R10B10D00D
imageAtomicMin(01h00D00E
imageAtomicMin(01h00D00D
greaterThan(30E30E
imageAtomicAdd(01N00D00D
imageAtomicAdd(01N00D00E
texelFetchOffset(00p10D00D00D
imageAtomicAnd(01J20D00D
imageAtomicAnd(01J20D00E
imageAtomicMax(01S10D00D00D
textureProj(00o30B
imageAtomicAdd(01I20D00E
bitfieldExtract(20D00D00D
texture(00L20B00B
imageAtomicOr(01L00D00E
imageAtomicOr(01L00D00D
mix(30D30D30F
imageLoad(01h00D
imageAtomicCompSwap(01E20D00E00E
textureProjOffset(00O30B10D
floor(10B
floor(10C
imageAtomicMax(01R10D00D00E
imageAtomicMax(01R10D00D00D
textureProjLodOffset(00o10B00B00D
textureGather(00x30B00D
interpolateAtSample(10B00D
imageAtomicMin(01F20D00E
imageAtomicMin(01F20D00D
outerProduct(10B30B
texture(00k30B
imageAtomicCompSwap(01O10D00E00E
cos(00B
imageAtomicXor(01F20D00E
imageAtomicXor(01B10D00E
frexp(00C00D
atomicCounterCompSwap(00G00E00E
textureOffset(00a20B10D00B
imageAtomicCompSwap(01b20D00E00E
textureGather(00X10B
imageLoad(01T10D00D
textureOffset(00R10B10D00B
textureGatherOffset(00d10B00B10D
textureSize(00i00D
equal(20E20E
uaddCarry(00E00E00E
textureQueryLod(00T20B
textureCube(00K20B
imageAtomicMax(01U20D00D00E
imageAtomicMax(01U20D00D00D
imageAtomicAnd(01K20D00D
matrixCompMult(90B90B
textureGatherOffsets(00I10B10Dx4
textureGradOffset(00p10B00B00B00D
textureProjLodOffset(00g30B00B00D
clamp(30E00E00E
asin(00B
textureProjOffset(00J30B20D00B
texelFetch(00w00D
notEqual(30E30E
imageAtomicOr(01K20D00D
imageAtomicOr(01K20D00E
lessThanEqual(10E10E
inversesqrt(20C
inversesqrt(20B
textureLod(00i20B00B
textureOffset(00u10B00D00B
reflect(00C00C
atomicAdd(00E00E
intBitsToFloat(30D
textureProjGradOffset(00v20B10B10B10D
textureGrad(00X10B10B10B
greaterThanEqual(30E30E
mix(20B20B20F
imageAtomicExchange(01T10D00D00E
imageAtomicExchange(01T10D00D00D
mix(20B20B20B
any(10F
textureProjGradOffset(00d30B10B10B10D
imageLoad(01X10D
textureProjOffset(00I30B10D
textureOffset(00X10B10D
texture(00R10B
imageAtomicXor(01R10D00D00E
imageStore(01M00D30D
radians(00B
textureGatherOffsets(00f20B00B10Dx4
step(10B10B
imageAtomicAdd(01Y10D00D
imageAtomicAdd(01Y10D00E
bitfieldReverse(10E
bitfieldReverse(10D
imageStore(01g00D30B
textureProjGradOffset(00q20B10B10B10D
imageAtomicExchange(01S10D00D00E
atomicXor(00E00E
mix(00C00C00F
textureLodOffset(00g00B00B00D
greaterThan(30B30B
faceforward(20B20B20B
textureSize(00x00D
textureProj(00S30B00B
fma(20B20B20B
textureProjLod(00o10B00B
imageAtomicMin(01J20D00E
outerProduct(30B30B
exp(30B
bitCount(10E
bitCount(10D
log(00B
mix(00F00F00F
imageAtomicCompSwap(01M00D00D00D
imageAtomicAdd(01Q10D00E
acosh(30B
imageAtomicOr(01Y10D00E
imageAtomicOr(01Y10D00D
textureGradOffset(00X10B10B10B10D
texelFetchOffset(00X10D00D10D
packUnorm2x16(10B
texture(00h20B00B
umulExtended(20E20E20E20E
texture(00m20B00B
textureProjGradOffset(00g30B00B00B00D
textureProj(00o30B00B
imageAtomicCompSwap(01T10D00D00E00E
textureCubeLod(00K20B00B
textureSize(00L00D
imageAtomicXor(01L00D00E
imageAtomicCompSwap(01Q10D00D00D
max(20E00E
textureProj(00S30B
dFdy(30B
isinf(10C
isinf(10B
greaterThanEqual(30B30B
texture2DProjLodEXT(00I20B00B
textureProjOffset(00t10B00D00B
acos(10B
textureCube(00K20B00B
lessThan(10B10B
imageAtomicCompSwap(01B10D00E00E
textureSize(00f00D
texelFetchOffset(00h10D00D00D
mod(20C00C
imageAtomicAnd(01g00D00D
textureGatherOffsets(00q10B10Dx4
lessThanEqual(20D20D
textureQueryLod(00k20B
imageAtomicAdd(01B10D00E
textureProjLod(00Y30B00B
imageAtomicAnd(01U20D00D00D
imageAtomicAnd(01U20D00D00E
transpose(B0B
imageAtomicXor(01b20D00E
mix(20F20F20F
smoothstep(00B00B30B
imageAtomicExchange(01M00D00B
imageAtomicExchange(01M00D00D
imageAtomicExchange(01M00D00E
textureQueryLod(00d10B
texelFetch(00N10D00D
textureSize(00a00D
EmitStreamVertex(00D
textureProjOffset(00Y30B20D
textureOffset(00n20B10D
atan(30B
imageAtomicMax(01b20D00E
imageAtomicMax(01b20D00D
ceil(10B
textureSize(00S00D
imageAtomicExchange(01S10D00D00B
atomicCounterDecrement(00G
ceil(30B
imageAtomicAnd(01Q10D00D
imageAtomicAnd(01Q10D00E
imageAtomicAnd(01c20D00E
imageAtomicAnd(01c20D00D
textureSize(00t00D
texture(00f30B
imageSamples(01R
texelFetch(00R10D00D
sign(20B
smoothstep(30B30B30B
imageAtomicExchange(01T10D00D00B
textureGrad(00R10B10B10B
min(00D00D
textureProj(00t10B00B
shadow2DProjEXT(00d30B
imageAtomicAdd(01V20D00D00E
ldexp(20B20D
greaterThanEqual(30D30D
imageLoad(01D20D
findLSB(10E
texture(00Z20B00B
imageAtomicXor(01S10D00D00E
imageAtomicXor(01S10D00D00D
cos(10B
texelFetch(00v10D
texture(00e30B
textureSize(00T00D
imageAtomicAnd(01g00D00E
textureSize(00u00D
textureProjGradOffset(00Y30B20B20B20D
noise3(30B
textureGrad(00T20B20B20B
texture1DProj(00g10B00B
textureProjOffset(00d30B10D00B
imageAtomicMin(01B10D00D
imageAtomicMin(01B10D00E
imageAtomicXor(01U20D00D00D
imageAtomicXor(01U20D00D00E
imageAtomicAdd(01h00D00D
imageAtomicAdd(01h00D00E
matrixCompMult(50B50B
equal(30B30B
imageAtomicExchange(01E20D00B
textureLod(00U20B00B
imageAtomicXor(01I20D00E
imageAtomicXor(01I20D00D
textureOffset(00h10B00D
textureLod(00p10B00B
max(20C20C
max(10B10B
imageAtomicCompSwap(01F20D00E00E
asin(10B
sinh(00B
imageAtomicAdd(01g00D00D
imageAtomicCompSwap(01h00D00E00E
textureOffset(00S20B20D
fma(20C20C20C
textureProj(00R20B
greaterThan(10E10E
imageAtomicAnd(01M00D00E
imageAtomicAdd(01B10D00D
imageAtomicAnd(01M00D00D
textureGatherOffsets(00n10B00B10Dx4
EmitVertex(
smoothstep(20B20B20B
textureSamples(00b
textureOffset(00J20B20D
texelFetch(00J20D00D
imageAtomicExchange(01V20D00D00E
imageAtomicExchange(01V20D00D00B
imageAtomicCompSwap(01Y10D00E00E
radians(30B
fract(30B
imageAtomicMin(01H20D00E
uaddCarry(20E20E20E
textureProjGrad(00X30B10B10B
textureSamples(00P
textureProjOffset(00v20B10D
shadow2D(00d20B00B
texelFetchOffset(00o00D00D00D
textureSamples(00V
textureSamples(00W
textureProjGrad(00q30B10B10B
textureGatherOffset(00O10B10D
clamp(10D00D00D
textureLod(00L20B00B
imageAtomicExchange(01A10D00B
imageAtomicCompSwap(01V20D00D00D00D
imageAtomicExchange(01A10D00E
imageAtomicExchange(01A10D00D
imageAtomicXor(01b20D00D
texture(00n20B
ldexp(20C20D
clamp(00E00E00E
length(20B
ldexp(00B00D
bitfieldInsert(00D00D00D00D
textureProjGrad(00Y30B20B20B
imageAtomicAdd(01W20D00D00E
roundEven(30B
roundEven(30C
acosh(20B
atanh(10B
length(20C
clamp(10B10B10B
textureGatherOffset(00L20B10D00D
bitCount(00D
bitCount(00E
floatBitsToInt(30B
max(20B00B
imageAtomicAdd(00z10D00D
texelFetchOffset(00Y20D00D20D
atomicExchange(00E00E
imageAtomicXor(01h00D00D
imageAtomicXor(01h00D00E
ldexp(30C30D
texture(00o00B
texture(00x30B00B
lessThanEqual(20B20B
min(10B00B
textureQueryLod(00f10B
smoothstep(10C10C10C
imageAtomicAnd(01L00D00D
imageAtomicAnd(01L00D00E
mix(30F30F30F
imageAtomicMax(01T10D00D00E
imageAtomicMax(01T10D00D00D
textureGatherOffsets(00O10B10Dx400D
abs(20D
abs(20C
abs(20B
lessThanEqual(10B10B
min(30E30E
imageAtomicOr(01a20D00D
mix(00B00B00B
mix(00B00B00F
textureGather(00s30B00D
textureProj(00I20B
textureLodOffset(00p10B00B00D
unpackDouble2x32(00C
acos(00B
textureGradOffset(00J20B20B20B20D
fma(00C00C00C
texture2DGradEXT(00I10B10B10B
imageAtomicCompSwap(01G20D00D00D
imageAtomicAnd(01I20D00D
texture2DProjGradEXT(00I30B10B10B
fma(30B30B30B
imageAtomicAdd(01L00D00D
texture(00i20B00B
clamp(20C00C00C
imageAtomicMax(01X10D00E
imageLoad(01i00D
mix(30E30E30F
imageAtomicMin(01G20D00D
imageAtomicMin(01G20D00E
imageAtomicExchange(01S10D00D00D
atan(20B
interpolateAtSample(30B00D
dFdxCoarse(30B
texture(00M10B
min(10B10B
textureLodOffset(00h10B00B00D
EndStreamPrimitive(00D
pow(10B10B
texture(00Y20B
imageAtomicXor(01P10D00D
texture(00X10B00B
frexp(00B00D
texture2D(00I10B
imageLoad(01O10D
ceil(20C
ceil(20B
imageAtomicMin(01b20D00E
imageAtomicMin(01b20D00D
imageAtomicMax(01P10D00D
imageAtomicMax(01P10D00E
imageAtomicExchange(01P10D00B
textureProjOffset(00R20B10D
imageStore(01V20D00D30D
subpassLoad(01m00D
textureOffset(00I10B10D
min(20B00B
reflect(00B00B
noise4(10B
sqrt(10C
sqrt(10B
clamp(20E20E20E
textureGradOffset(00g00B00B00B00D
textureGather(00q20B
noise3(00B
imageAtomicOr(01G20D00D
imageAtomicOr(01G20D00E
imageAtomicMin(01C20D00D
imageAtomicMin(01C20D00E
imageAtomicAnd(01F20D00E
imageStore(01a20D30B
textureProjLod(00d30B00B
imageLoad(01H20D
textureProjGradOffset(00I20B10B10B10D
interpolateAtSample(20B00D
reflect(10B10B
refract(10B10B00B
imageAtomicMax(01h00D00D
mix(20C20C20F
imageAtomicExchange(01X10D00D
imageAtomicExchange(01X10D00E
mix(20C20C20C
textureOffset(00v10B10D
imageAtomicExchange(01Q10D00E
imageAtomicExchange(01Q10D00D
imageAtomicMin(01P10D00D
sinh(30B
textureSize(00m00D
imageAtomicMin(01N00D00E
imageAtomicMin(01N00D00D
textureQueryLod(00e20B
asinh(20B
imageAtomicAdd(01C20D00D
imageAtomicCompSwap(01I20D00D00D
textureProj(00O20B
imageAtomicCompSwap(01M00D00E00E
frexp(10B10D
inverse(50B
dot(10B10B
noise2(00B
textureProjGradOffset(00o10B00B00B00D
radians(20B
atomicCompSwap(00E00E00E
textureGrad(00I00B00B00B
textureGrad(00Y20B20B20B
imageAtomicCompSwap(01Z10D00D00D
imageAtomicExchange(01W20D00D00B
textureOffset(00o00B00D00B
imageAtomicExchange(01W20D00D00E
imageAtomicExchange(01W20D00D00D
ftransform(
textureProj(00X20B
textureProjOffset(00n30B10D
imageAtomicOr(01W20D00D00E
imageAtomicOr(01W20D00D00D
greaterThanEqual(20E20E
textureProj(00M20B
texture3DProjLod(00J30B00B
isinf(30C
imageAtomicAdd(01Z10D00E
imageAtomicAdd(01Z10D00D
mix(10D10D10F
textureProjGrad(00g10B00B00B
log(20B
imageAtomicMax(01D20D00E
imageAtomicMax(01D20D00D
textureOffset(00h10B00D00B
modf(30B30B
roundEven(20C
roundEven(20B
outerProduct(30B10B
textureProj(00J30B
imageAtomicOr(01F20D00E
imageAtomicOr(01F20D00D
textureLodOffset(00t00B00B00D
floatBitsToInt(20B
texelFetch(00U20D00D
max(00D00D
round(20C
atomicMin(00E00E
textureGradOffset(00v10B10B10B10D
textureGrad(00n20B10B10B
imageLoad(01S10D00D
shadow2DEXT(00d20B
textureGatherOffsets(00a20B10Dx4
max(20E20E
imageAtomicCompSwap(01F20D00D00D
abs(10D
abs(10B
abs(10C
imageAtomicAdd(01V20D00D00D
modf(30C30C
imageAtomicMin(01T10D00D00E
imageAtomicMin(01T10D00D00D
textureGrad(00i20B00B00B
textureProj(00g10B
equal(20B20B
textureProjLodOffset(00X20B00B10D
max(30C00C
texture(00U20B00B
textureProj(00I30B
mix(00E00E00F
imageAtomicCompSwap(01h00D00D00D
mix(00D00D00F
textureProjOffset(00q20B10D
texture(00i20B
textureGradOffset(00a20B10B10B10D
smoothstep(00B00B20B
textureLod(00s30B00B
imageAtomicOr(01C20D00D
imageAtomicOr(01C20D00E
imageAtomicXor(01g00D00E
notEqual(30B30B
textureGatherOffset(00f20B00B10D
imageAtomicAnd(01N00D00D
imageAtomicAnd(01N00D00E
imageSize(00z
mod(10C10C
imageAtomicXor(01g00D00D
faceforward(00C00C00C
textureGrad(00a20B10B10B
dFdxCoarse(00B
imageAtomicMin(01a20D00D
texture(00J20B00B
refract(20B20B00B
ceil(30C
noise1(30B
log2(30B
textureProjGrad(00d30B10B10B
mod(20C20C
fract(30C
texelFetch(00t00D00D
imageAtomicXor(01L00D00D
max(30E30E
noise4(00B
distance(10C10C
textureProjLodOffset(00J30B00B20D
imageAtomicExchange(01O10D00B
imageAtomicMax(01H20D00E
imageAtomicMax(01H20D00D
imageStore(01h00D30D
imageAtomicExchange(01O10D00D
texelFetch(00c20D00D
sqrt(00B
sqrt(00C
textureProjLod(00R30B00B
noise3(10B
texelFetch(00q10D
imageAtomicAnd(01F20D00D
textureLod(00m20B00B
textureProjOffset(00m30B00D00B
textureProjGrad(00v30B10B10B
clamp(20D20D20D
imageAtomicMin(01P10D00E
imageAtomicAdd(01C20D00E
clamp(00C00C00C
imageAtomicXor(01N00D00D
imageAtomicXor(01N00D00E
texture(00x30B
max(10E00E
imageLoad(01c20D
textureGrad(00U20B10B10B
imageLoad(00z10D
clamp(30C00C00C
textureGatherOffsets(00a20B10Dx400D
sinh(20B
matrixCompMult(E0BE0B
fwidthFine(00B
textureGradOffset(00m20B00B00B00D
imageAtomicMin(01K20D00E
textureQueryLevels(00p
asinh(30B
cross(20C20C
textureGather(00a20B
textureProjGradOffset(00O20B10B10B10D
pow(30B30B
imageAtomicCompSwap(01G20D00E00E
smoothstep(10B10B10B
textureProj(00O30B
textureQueryLod(00R10B
imageAtomicAdd(01R10D00D00D
imageAtomicAdd(01R10D00D00E
imageAtomicExchange(01E20D00D
imageAtomicMin(01Q10D00E
imageAtomicMin(01Q10D00D
imageAtomicExchange(01E20D00E
isnan(00B
isnan(00C
imulExtended(10D10D10D10D
textureProjGrad(00o10B00B00B
imageAtomicMax(01i00D00D
imageAtomicMax(01i00D00E
refract(10C10C00B
min(00E00E
imageStore(01T10D00D30E
texture2DProj(00I30B
textureGradOffset(00I10B10B10B10D
textureLodOffset(00J20B00B20D
notEqual(20B20B
atomicCompSwap(00D00D00D
textureOffset(00i20B00D
dFdyFine(00B
textureLod(00a20B00B
textureProj(00N30B
refract(30C30C00B
equal(30D30D
imageStore(01D20D30D
packSnorm2x16(10B
floatBitsToUint(30B
textureOffset(00R10B10D
textureProjGrad(00q20B10B10B
textureProjGradOffset(00R20B10B10B10D
ldexp(30B30D
max(30B00B
atomicCounterOr(00G00E
imageAtomicMin(01i00D00E
step(30B30B
textureProj(00I30B00B
imageAtomicExchange(01D20D00E
textureOffset(00g00B00D00B
imageAtomicExchange(01D20D00B
imageAtomicMin(01g00D00E
imageAtomicMax(01c20D00D
abs(00D
abs(00C
abs(00B
textureLod(00R10B00B
dFdxCoarse(10B
texture1D(00g00B
frexp(10C10D
imageAtomicAdd(01g00D00E
texture2DLod(00I10B00B
textureProjGradOffset(00X20B10B10B10D
imageAtomicMax(01Z10D00D
texture(00s30B
EndPrimitive(
step(00B30B
round(20B
equal(30E30E
imageAtomicCompSwap(01R10D00D00E00E
imageAtomicAdd(01M00D00D
step(00C20C
dot(00C00C
max(30C30C
atomicOr(00D00D
texture2DProj(00M20B
notEqual(10D10D
imageAtomicExchange(01Z10D00D
textureSize(00V
imageAtomicAnd(01h00D00D
min(20C00C
imageAtomicAdd(01G20D00E
imageAtomicAdd(01G20D00D
findLSB(30D
findLSB(30E
textureProj(00X20B00B
shadow2D(00d20B
textureGatherOffset(00U20B10D
imageAtomicExchange(01Z10D00E
faceforward(10B10B10B
imageAtomicAnd(01h00D00E
min(10D00D
imageAtomicCompSwap(01J20D00D00D
all(20F
imageSize(01J
imageSize(01K
textureOffset(00t00B00D00B
imageSize(01I
packHalf2x16(10B
textureProj(00I20B00B
imageSize(01L
imageSize(01M
imageSize(01B
imageSize(01C
imageSize(01A
imageSize(01F
imageSize(01G
imageSize(01D
imageSize(01E
imageAtomicExchange(01L00D00B
imageAtomicExchange(01L00D00E
texelFetch(00X10D00D
notEqual(30F30F
imageSize(01R
imageSize(01S
imageSize(01P
imageSize(01Q
imageSize(01V
textureQueryLod(00g00B
imageSize(01T
imageSize(01U
imageSize(01h
imageSize(01i
fract(20C
fract(20B
textureGatherOffset(00X10B10D
imageSize(01c
imageStore(01R10D00D30B
imageSize(01a
imageSize(01f
texture2DProjGradEXT(00I20B10B10B
imageSize(01d
textureLod(00S20B00B
step(30C30C
imageAtomicMin(01J20D00D
textureGather(00x30B
mix(30B30B30F
mix(30B30B30B
textureGather(00Z20B00D
imageAtomicAnd(01Z10D00E
imageAtomicAnd(01Z10D00D
imageStore(01E20D30E
sqrt(30C
sqrt(30B
exp(00B
max(30D30D
interpolateAtCentroid(10B
texture(00q10B
textureSize(00M00D
textureSamples(00c
mix(10F10F10F
textureGradOffset(00U20B10B10B10D
textureGradOffset(00O10B10B10B10D
textureProj(00M30B
textureGradOffset(00L20B10B10B10D
imageAtomicExchange(01V20D00D00D
imageAtomicExchange(01J20D00B
imageAtomicExchange(01J20D00E
imageAtomicExchange(01J20D00D
textureQueryLod(00l20B
imageAtomicOr(01M00D00E
dot(20B20B
textureProjGrad(00v20B10B10B
textureProjLod(00S30B00B
textureProjGrad(00R20B10B10B
imageAtomicAnd(01i00D00E
imageAtomicAnd(01i00D00D
imageAtomicMax(00z10D00E
imageAtomicMax(00z10D00D
normalize(30C
normalize(30B
textureOffset(00O10B10D
textureProjGrad(00I20B10B10B
textureGather(00e20B
imageAtomicMax(01V20D00D00E
texture2D(00M10B
imageAtomicAdd(01a20D00E
fwidthFine(30B
textureGather(00K20B00D
textureCubeLodEXT(00K20B00B
textureGather(00T20B00D
textureProj(00N20B
textureQueryLod(00I10B
imageAtomicCompSwap(01A10D00E00E
dFdyFine(10B
modf(10C10C
imageAtomicMax(01E20D00D
imageAtomicMax(01E20D00E
textureProjLodOffset(00X30B00B10D
imageStore(01W20D00D30E
textureProjLod(00m30B00B
textureProjOffset(00g30B00D00B
texelFetchOffset(00U20D00D10D
imageAtomicCompSwap(00z10D00E00E
imageAtomicMin(01D20D00E
textureProjGradOffset(00q30B10B10B10D
textureGradOffset(00d20B10B10B10D
fwidthCoarse(20B
imageAtomicCompSwap(01N00D00E00E
textureProjOffset(00d30B10D
imageAtomicOr(01T10D00D00E
imageAtomicOr(01T10D00D00D
equal(20F20F
mix(20C20C00C
usubBorrow(10E10E10E
equal(10B10B
textureLodOffset(00U20B00B10D
isnan(10C
isnan(10B
imageAtomicMin(01H20D00D
imageAtomicXor(01A10D00D
imageAtomicXor(01A10D00E
imageAtomicCompSwap(01C20D00D00D
textureGrad(00R00B00B00B
atomicMin(00D00D
textureSize(00X00D
greaterThan(10B10B
mix(00C00C00C
noise1(20B
clamp(30D00D00D
mix(20E20E20F
floatBitsToInt(10B
textureProjOffset(00R30B10D00B
textureGather(00U20B00D
floatBitsToInt(00B
imageLoad(01a20D
floatBitsToUint(00B
min(30C30C
textureSamples(00Q
textureGradOffset(00i20B00B00B00D
imageAtomicXor(00z10D00D
texture2DRectProj(00O20B
modf(20C20C
tan(20B
floor(00C
floor(00B
imageAtomicMax(01O10D00E
imageAtomicMax(01O10D00D
mod(30C30C
textureOffset(00t00B00D
texture3DLod(00J20B00B
imageLoad(01Q10D
texture(00R10B00B
imageStore(01Y10D30D
modf(00B00B
notEqual(20D20D
imageAtomicExchange(01R10D00D00E
imageAtomicExchange(01R10D00D00D
ldexp(10C10D
imageAtomicExchange(01F20D00E
determinant(A0B
imageAtomicExchange(01i00D00D
textureLodOffset(00i20B00B00D
imageAtomicExchange(01i00D00B
shadow1DLod(00m20B00B
imageAtomicOr(01I20D00E
distance(00C00C
isnan(30B
textureProjOffset(00o30B00D
lessThanEqual(30D30D
textureProj(00M30B00B
texture2DProj(00M30B
atomicCounterMax(00G00E
atomicCounterExchange(00G00E
textureGrad(00I10B10B10B
step(00B20B
texture2DProjLod(00I20B00B
step(00C30C
yuv_2_rgb(20B00H
texelFetch(00b10D00D
textureProj(00J30B00B
textureGather(00R10B
imageAtomicCompSwap(01c20D00D00D
imageAtomicOr(01V20D00D00D
imageAtomicOr(01V20D00D00E
imageAtomicExchange(01P10D00D
imageLoad(01L00D
min(10D10D
all(30F
imageAtomicExchange(01P10D00E
imageAtomicAnd(01S10D00D00E
imageAtomicAnd(01S10D00D00D
bitfieldReverse(20D
bitfieldReverse(20E
imageAtomicExchange(01I20D00D
imageAtomicExchange(01I20D00E
imageAtomicExchange(01I20D00B
imageAtomicExchange(01c20D00E
textureGatherOffsets(00X10B10Dx4
texture(00u20B
textureGather(00v20B
fract(10B
fract(10C
textureGatherOffset(00O10B10D00D
textureQueryLod(00K20B
textureLodOffset(00I10B00B10D
imageAtomicCompSwap(01S10D00D00E00E
imageAtomicXor(01c20D00E
imageAtomicXor(01c20D00D
textureOffset(00U20B10D
min(30B00B
atomicAnd(00D00D
exp(10B
bitCount(30E
bitCount(30D
unpackUnorm2x16(00E
sqrt(20B
sqrt(20C
textureGrad(00L20B10B10B
interpolateAtCentroid(00B
textureSize(00o00D
textureProjGrad(00o30B00B00B
imageAtomicOr(01Q10D00D
packUnorm4x8(30B
imageAtomicMax(01Q10D00E
texelFetch(00P10D00D
imageAtomicCompSwap(01i00D00D00D
textureGatherOffsets(00d10B00B10Dx4
texture(00O10B
imageAtomicMin(01M00D00D
imageAtomicMin(01M00D00E
texture(00e30B00B
imageAtomicMin(01O10D00E
imageAtomicMin(01O10D00D
imageAtomicMax(01Q10D00D
imageAtomicMax(01X10D00D
textureGrad(00u10B00B00B
fwidthFine(20B
textureQueryLod(00o00B
imageAtomicAnd(01E20D00E
imageAtomicAnd(01E20D00D
normalize(00B
normalize(00C
clamp(10C00C00C
imageAtomicOr(01A10D00E
imageAtomicOr(01A10D00D
imageAtomicCompSwap(01Q10D00E00E
atomicMax(00D00D
textureProjGrad(00m30B00B00B
imageAtomicAnd(01R10D00D00E
floatBitsToUint(10B
textureLod(00J20B00B
textureGrad(00O10B10B10B
dFdyFine(20B
imageLoad(01W20D00D
textureSize(00I00D
texelFetchOffset(00R10D00D10D
dFdxFine(10B
imageAtomicExchange(01D20D00D
textureLodOffset(00X10B00B10D
texture(00T20B00B
log(30B
notEqual(20F20F
allInvocationsEqual(00F
imageAtomicMax(01K20D00D
imageAtomicMax(01K20D00E
dFdyCoarse(30B
textureProjLod(00R20B00B
notEqual(30D30D
fwidthCoarse(30B
textureProjOffset(00I20B10D
textureQueryLevels(00l
textureQueryLevels(00m
textureQueryLevels(00o
textureQueryLevels(00h
textureQueryLevels(00i
textureQueryLevels(00k
textureQueryLevels(00d
textureQueryLevels(00e
textureQueryLevels(00f
textureQueryLevels(00g
textureQueryLevels(00a
atomicCounterMin(00G00E
textureGradOffset(00u10B00B00B00D
textureQueryLevels(00x
textureQueryLevels(00t
textureQueryLevels(00u
imageAtomicMin(01K20D00D
imulExtended(20D20D20D20D
any(30F
distance(30B30B
textureQueryLevels(00s
textureQueryLevels(00L
textureQueryLevels(00I
textureQueryLevels(00J
textureQueryLevels(00K
imageAtomicExchange(01L00D00D
texture3D(00J20B00B
texture1DLod(00g00B00B
textureQueryLevels(00X
textureQueryLevels(00Y
textureQueryLevels(00Z
dot(30B30B
textureQueryLevels(00T
textureQueryLevels(00U
textureQueryLevels(00R
textureQueryLevels(00S
usubBorrow(20E20E20E
textureProj(00t30B00B
shadow1DProj(00m30B00B
clamp(30B00B00B
textureGatherOffsets(00O10B10Dx4
texture2DRectProj(00O30B
max(10D00D
textureGradOffset(00n20B10B10B10D
clamp(00D00D00D
floor(30B
floor(30C
imageStore(01P10D30D
textureProjGradOffset(00S30B20B20B20D
reflect(30C30C
imageAtomicOr(01D20D00E
textureGatherOffset(00v10B10D
imageAtomicOr(01D20D00D
imageStore(01F20D30B
packDouble2x32(10E
clamp(10B00B00B
texelFetchOffset(00S20D00D20D
lessThan(10D10D
textureSize(00g00D
textureGatherOffset(00U20B10D00D
textureGatherOffset(00q10B10D00D
textureGather(00I10B00D
texture1DProjLod(00g30B00B
texelFetch(00V10D00D
imageAtomicExchange(01h00D00E
imageAtomicExchange(01h00D00D
atan(30B30B
imageAtomicExchange(01h00D00B
imageAtomicMax(01a20D00D
imageAtomicMax(01a20D00E
textureProjLod(00g30B00B
max(00B00B
imageAtomicOr(01J20D00E
imageAtomicOr(01J20D00D
imageAtomicMax(01F20D00E
imageAtomicMax(01F20D00D
exp2(20B
smoothstep(30C30C30C
imageAtomicExchange(00z10D00B
imageAtomicExchange(00z10D00E
imageAtomicExchange(00z10D00D
textureProj(00q20B
textureProjLod(00t10B00B
imageAtomicMin(01c20D00D
imageAtomicMin(01c20D00E
textureSize(00k00D
reflect(20B20B
imageAtomicXor(01V20D00D00E
imageAtomicXor(01V20D00D00D
equal(10F10F
acos(30B
textureVideoWEBGL(00y10B
dFdx(10B
bitfieldReverse(30E
bitfieldReverse(30D
imageAtomicOr(01Z10D00D
imageAtomicOr(01Z10D00E
texture1DProj(00g30B
textureGatherOffsets(00v10B10Dx400D
fract(00C
fract(00B
min(30E00E
imageAtomicOr(01Q10D00E
interpolateAtOffset(20B10B
imageAtomicOr(01c20D00D
imageAtomicOr(01c20D00E
reflect(30B30B
interpolateAtCentroid(30B
textureGather(00s30B
imageAtomicXor(01X10D00E
imageAtomicXor(01X10D00D
memoryBarrier(
texture1D(00g00B00B
pow(00B00B
mod(00B00B
faceforward(30C30C30C
imageAtomicExchange(01K20D00D
roundEven(10B
roundEven(10C
atanh(30B
textureLod(00K20B00B
bitCount(20D
bitCount(20E
texelFetch(00L20D00D
dFdxFine(00B
imageAtomicAnd(01K20D00E
distance(20B20B
textureGradOffset(00q10B10B10B10D
uaddCarry(30E30E30E
textureSize(00U00D
textureProjOffset(00o10B00D00B
atomicCounterXor(00G00E
imageAtomicOr(01g00D00D
imageAtomicOr(01g00D00E
imageAtomicMin(01L00D00E
smoothstep(20C20C20C
imageAtomicCompSwap(01U20D00D00D00D
atomicOr(00E00E
mix(10B10B10F
reflect(10C10C
mix(10B10B10B
textureProj(00Y30B00B
imageAtomicMax(01I20D00D
imageAtomicMax(01I20D00E
frexp(20B20D
textureGatherOffset(00I10B10D00D
notEqual(20E20E
textureLodOffset(00d20B00B10D
inverse(A0B
textureProjGrad(00X20B10B10B
textureSize(00Y00D
atan(20B20B
usubBorrow(00E00E00E
imageAtomicXor(01M00D00E
textureGatherOffsets(00L20B10Dx400D
dFdyFine(30B
textureQueryLod(00s20B
texture(00v10B
textureGatherOffsets(00U20B10Dx4
subpassLoad(01n00D
imageAtomicCompSwap(01c20D00E00E
textureProjLodOffset(00g10B00B00D
step(10C10C
textureQueryLod(00x20B
fma(10B10B10B
smoothstep(00B00B10B
imageAtomicCompSwap(01a20D00D00D
imageSize(01N
textureLod(00u10B00B
textureProjGradOffset(00m30B00B00B00D
fwidthCoarse(00B
dFdyCoarse(20B
textureProjGradOffset(00o30B00B00B00D
imageStore(01b20D30D
textureProj(00g30B00B
bitfieldExtract(00E00D00D
distance(30C30C
any(20F
textureLod(00g00B00B
sin(10B
textureSize(00N00D
mod(20B20B
imageAtomicOr(01h00D00E
imageAtomicOr(01h00D00D
textureGrad(00k30B20B20B
textureProjOffset(00o10B00D
imageAtomicMin(01A10D00E
imageAtomicMin(01A10D00D
textureGradOffset(00f30B10B10B10D
max(20D20D
max(10D10D
textureGradOffset(00t00B00B00B00D
refract(30B30B00B
floor(20C
floor(20B
texelFetchOffset(00t00D00D00D
imageAtomicOr(01a20D00E
matrixCompMult(F0BF0B
umulExtended(10E10E10E10E
texture(00d20B00B
umulExtended(30E30E30E30E
textureGradOffset(00Y20B20B20B20D
textureGatherOffset(00a20B10D
textureGrad(00f30B10B10B
atomicCounterSubtract(00G00E
imageAtomicXor(01C20D00E
modf(20B20B
imageAtomicAnd(01Y10D00D
imageAtomicAnd(01Y10D00E
imageAtomicAdd(01i00D00E
imageAtomicAdd(01i00D00D
noise1(00B
imageLoad(01M00D
imageAtomicCompSwap(01L00D00E00E
texture(00y10B
length(30C
length(30B
imageStore(01B10D30E
mod(30B30B
mix(10C10C10F
imageAtomicMin(00z10D00E
imageAtomicMin(00z10D00D
imageStore(01I20D30B
exp2(30B
allInvocations(00F
max(20C00C
texture3DProj(00J30B00B
imageAtomicAdd(01K20D00E
imageAtomicAdd(01K20D00D
textureProjLod(00X30B00B
textureProjGradOffset(00I30B10B10B10D
imageAtomicAdd(01W20D00D00D
cosh(30B
textureProj(00q30B
textureOffset(00S20B20D00B
usubBorrow(30E30E30E
imageAtomicMax(01W20D00D00E
imageAtomicMax(01W20D00D00D
textureProjOffset(00R20B10D00B
imageSize(01H
textureOffset(00i20B00D00B
texture3DProj(00J30B
matrixCompMult(B0BB0B
lessThan(30B30B
cross(20B20B
imageSize(01O
textureGrad(00q10B10B10B
clamp(20B00B00B
dFdx(00B
findLSB(00D
textureProjLodOffset(00o30B00B00D
imageAtomicXor(01i00D00E
textureProj(00R20B00B
acos(20B
texelFetch(00r00D
max(20B20B
lessThan(20E20E
textureLod(00X10B00B
equal(30F30F
sign(00C
cosh(00B
bitfieldExtract(00D00D00D
imageAtomicMin(01E20D00D
imageAtomicMin(01E20D00E
textureLod(00Z20B00B
sign(00D
textureOffset(00Y20B20D
imageAtomicXor(01Q10D00D
imageAtomicXor(01Q10D00E
transpose(60B
imageStore(01G20D30D
imageAtomicAdd(01O10D00D
imageAtomicAdd(01O10D00E
faceforward(00B00B00B
imageLoad(01Z10D
imageAtomicOr(01O10D00E
imageAtomicOr(01O10D00D
imageAtomicAdd(01b20D00D
interpolateAtCentroid(20B
textureProjLodOffset(00R30B00B10D
textureGrad(00h10B00B00B
imageAtomicExchange(01U20D00D00B
texture1DProj(00g30B00B
textureQueryLod(00h00B
imageAtomicExchange(01U20D00D00E
modf(00C00C
textureProjLod(00t30B00B
textureOffset(00o00B00D
imageAtomicExchange(01U20D00D00D
imageStore(01H20D30E
textureGather(00U20B
texelFetch(00Q20D00D
roundEven(00C
roundEven(00B
texelFetchOffset(00O10D10D
atanh(20B
clamp(10E00E00E
dFdxFine(30B
imageAtomicAdd(01L00D00E
textureQueryLod(00J20B
textureProjOffset(00X30B10D
texture2DProjLod(00I30B00B
interpolateAtOffset(10B10B
max(10C10C
texelFetch(00g00D00D
abs(30B
bitfieldInsert(10E10E00D00D
packSnorm4x8(30B
mix(10B10B00B
imageSize(01b
clamp(30D30D30D
textureGatherOffsets(00L20B10Dx4
imageAtomicMax(01c20D00E
mod(10C00C
imageAtomicMax(01G20D00D
imageAtomicMax(01G20D00E
determinant(F0B
transpose(A0B
pow(20B20B
imageSize(01g
imageAtomicMax(01B10D00D
imageAtomicMax(01B10D00E
imageAtomicExchange(01G20D00B
imageSize(01e
imageAtomicExchange(01G20D00D
imageAtomicExchange(01G20D00E
imageLoad(01Y10D
imageAtomicMax(01g00D00D
imageAtomicMax(01g00D00E
textureProj(00v30B
textureProjGrad(00O20B10B10B
texture(00s30B00B
log2(20B
dot(30C30C
fwidthCoarse(10B
textureProjOffset(00I20B10D00B
imageAtomicAnd(01T10D00D00D
imageAtomicAnd(01T10D00D00E
notEqual(10F10F
smoothstep(00B00B00B
textureProjLodOffset(00d30B00B10D
imageAtomicAnd(01P10D00E
imageAtomicAnd(01P10D00D
textureProjLodOffset(00I30B00B10D
bitfieldInsert(10D10D00D00D
imageAtomicCompSwap(01N00D00D00D
imageAtomicCompSwap(01L00D00D00D
textureGather(00k30B
texture(00J20B
lessThanEqual(10D10D
textureProjOffset(00o30B00D00B
textureSize(00d00D
sin(00B
uaddCarry(10E10E10E
mix(10C10C00C
atomicCounterIncrement(00G
imageAtomicAdd(01J20D00D
imageAtomicAdd(01J20D00E
imageAtomicCompSwap(01S10D00D00D00D
imageStore(01Q10D30E
textureProj(00o10B00B
imageAtomicAdd(01U20D00D00D
imageAtomicAdd(01U20D00D00E
textureProjOffset(00m30B00D
imageAtomicExchange(01Y10D00B
equal(10E10E
imageAtomicExchange(01Y10D00E
imageAtomicExchange(01Y10D00D
imageLoad(01B10D
imageAtomicExchange(01O10D00E
textureProjOffset(00J30B20D
imageSize(01W
imageAtomicXor(01D20D00E
notEqual(10E10E
min(10C10C
textureProjGrad(00t10B00B00B
imageAtomicExchange(01N00D00B
textureGather(00q20B00D
imageAtomicExchange(01N00D00E
imageAtomicExchange(01N00D00D
textureGatherOffsets(00q10B10Dx400D
imageAtomicCompSwap(01O10D00D00D
shadow1DProjLod(00m30B00B
imageAtomicMin(01i00D00D
texture(00u20B00B
textureLodOffset(00R10B00B10D
trunc(10B
trunc(10C
imageAtomicAdd(01S10D00D00D
texelFetch(00u10D00D
dot(20C20C
noise4(30B
textureGather(00f20B
noise1(10B
textureProjGrad(00g30B00B00B
shadow2DProj(00d30B
textureProj(00d30B00B
sign(10B
max(00E00E
texture(00a20B00B
textureProj(00o10B
refract(20C20C00B
textureProj(00M20B00B
imageLoad(01A10D
textureProjOffset(00X30B10D00B
exp2(00B
imageAtomicExchange(01H20D00B
texelFetchOffset(00u10D00D00D
imageAtomicCompSwap(01H20D00E00E
imageAtomicExchange(01H20D00E
imageAtomicExchange(01H20D00D
textureGatherOffset(00q10B10D
textureGather(00a20B00D
imageStore(01S10D00D30D
ldexp(00C00D
textureSize(00s00D
imageAtomicXor(01P10D00E
imageAtomicOr(01I20D00D
texture(00N10B00B
imageAtomicCompSwap(01Y10D00D00D
textureProjGrad(00I30B10B10B
textureOffset(00d20B10D
dFdx(30B
textureGatherOffsets(00U20B10Dx400D
imageAtomicMin(01V20D00D00D
imageAtomicMin(01V20D00D00E
textureProjGradOffset(00t30B00B00B00D
min(20E20E
asin(20B
imageAtomicCompSwap(01U20D00D00E00E
texture(00l30B00B
texture1DProjLod(00g10B00B
fwidth(10B
dFdy(00B
shadow2DLod(00d20B00B
texture1DProj(00g10B
lessThan(30E30E
imulExtended(30D30D30D30D
transpose(70B
imulExtended(00D00D00D00D
imageAtomicAdd(01F20D00D
imageAtomicAdd(01F20D00E
texture(00S20B00B
textureLod(00Y20B00B
imageAtomicExchange(01c20D00D
faceforward(10C10C10C
imageStore(01Z10D30E
textureQueryLod(00u00B
imageAtomicExchange(01c20D00B
min(20D00D
imageAtomicCompSwap(01P10D00D00D
uintBitsToFloat(00E
dFdxFine(20B
imageAtomicMin(01L00D00D
imageAtomicExchange(01g00D00D
bitfieldInsert(20D20D00D00D
mix(30B30B00B
textureQueryLod(00U10B
tanh(00B
subpassLoad(01o00D
imageAtomicMax(01N00D00E
imageAtomicMax(01N00D00D
max(10C00C
matrixCompMult(D0BD0B
imageAtomicXor(01M00D00D
imageAtomicAnd(01X10D00E
shadow2DProjLod(00d30B00B
imageAtomicAnd(01X10D00D
min(30B30B
reflect(20C20C
texelFetch(00h10D00D
memoryBarrierAtomicCounter(
bitfieldInsert(00E00E00D00D
imageAtomicAdd(01b20D00E
imageAtomicMin(01a20D00E
textureGrad(00d20B10B10B
atan(10B
imageAtomicCompSwap(01g00D00D00D
clamp(30C30C30C
textureProj(00v20B
step(00B10B
textureProjLod(00I20B00B
rgb_2_yuv(20B00H
imageLoad(01P10D
texture(00T20B
log2(10B
imageAtomicAnd(01D20D00D
imageAtomicAnd(01D20D00E
findLSB(20E
findLSB(20D
imageAtomicCompSwap(01B10D00D00D
imageAtomicOr(01X10D00D
imageAtomicOr(01X10D00E
noise2(30B
imageAtomicOr(01U20D00D00E
greaterThanEqual(10B10B
clamp(10D10D10D
texelFetch(00M10D00D
textureQueryLod(00Y20B
transpose(F0B
textureOffset(00Y20B20D00B
textureGradOffset(00S20B20B20B20D
imageAtomicOr(01U20D00D00D
clamp(30E30E30E
textureSize(00R00D
acosh(10B
imageLoad(01b20D
imageAtomicCompSwap(01Z10D00E00E
textureOffset(00L20B10D00B
mod(20B00B
imageLoad(01U20D00D
textureProjLod(00J30B00B
subpassLoad(01k
transpose(90B
mix(30C30C00C
subpassLoad(01l
atomicAnd(00E00E
max(20D00D
texelFetchOffset(00I10D00D10D
imageAtomicMin(01Z10D00D
imageAtomicMin(01Z10D00E
imageAtomicCompSwap(01i00D00E00E
imageAtomicCompSwap(01K20D00D00D
textureQueryLod(00L10B
imageStore(01J20D30D
atomicCounter(00G
textureGrad(00m20B00B00B
noise3(20B
bitfieldInsert(30D30D00D00D
min(10C00C
greaterThan(10D10D
bitfieldExtract(10E00D00D
textureGradOffset(00h10B00B00B00D
imageAtomicMax(01V20D00D00D
texture2D(00I10B00B
greaterThan(20D20D
imageAtomicAnd(01W20D00D00D
imageAtomicAnd(01W20D00D00E
textureProjLodOffset(00t10B00B00D
textureProjOffset(00O20B10D
trunc(00B
length(10C
length(10B
imageLoad(01R10D00D
imageAtomicAdd(01H20D00D
imageAtomicAdd(01H20D00E
subpassLoad(01j
dot(00B00B
tan(30B
textureLod(00T20B00B
textureProjGrad(00R30B10B10B
exp2(10B
textureProjOffset(00X20B10D00B
textureProjGradOffset(00X30B10B10B10D
imageAtomicAnd(01B10D00D
imageStore(01U20D00D30B
matrixCompMult(A0BA0B
textureGrad(00S20B20B20B
round(30B
round(30C
anyInvocation(00F
textureGrad(00x30B20B20B
imageAtomicCompSwap(01D20D00E00E
textureProjLod(00o30B00B
smoothstep(00C00C10C
interpolateAtSample(00B00D
dFdx(20B
texture(00L20B
barrier(
imageAtomicOr(01N00D00E
imageAtomicOr(01N00D00D
imageAtomicAdd(01a20D00D
textureGather(00k30B00D
findMSB(20D
textureGatherOffset(00L20B10D
imageAtomicMin(01S10D00D00D
imageLoad(01J20D
textureProjOffset(00S30B20D00B
imageAtomicAdd(01D20D00D
normalize(10C
unpackSnorm4x8(00E
imageLoad(01C20D
imageAtomicMax(01C20D00D
imageAtomicMax(01C20D00E
textureGather(00l30B00B
normalize(10B
asin(30B
isnan(20B
isnan(20C
fwidth(00B
dFdy(10B
imageAtomicAdd(01P10D00E
imageAtomicAdd(01P10D00D
max(30E00E
textureLod(00d20B00B
textureOffset(00q10B10D
imageAtomicAdd(01c20D00E
imageAtomicAdd(01c20D00D
mod(10B00B
texture(00g00B00B
uintBitsToFloat(10E
textureProjOffset(00t30B00D
matrixCompMult(70B70B
imageAtomicAdd(01I20D00D
imageAtomicMax(01M00D00D
imageAtomicMax(01M00D00E
textureLod(00k30B00B
imageAtomicAdd(01E20D00D
textureLodOffset(00Y20B00B20D
refract(00C00C00B
log2(00B
tanh(10B
imageAtomicMin(01I20D00E
textureLod(00h10B00B
textureGather(00O20B00D
clamp(00B00B00B
textureGather(00d10B
textureOffset(00p10B00D00B
clamp(10C10C10C
imageAtomicXor(01B10D00D
outerProduct(20B10B
textureProjOffset(00t10B00D
isinf(20C
textureGrad(00e30B20B20B
textureSize(00J00D
textureQueryLod(00Z20B
dot(10C10C
imageAtomicXor(01K20D00E
imageAtomicXor(01K20D00D
textureProjGrad(00n30B10B10B
imageAtomicMin(01U20D00D00E
imageAtomicMin(01U20D00D00D
imageAtomicAdd(01Q10D00D
texture2DProjLodEXT(00I30B00B
imageAtomicXor(01T10D00D00D
imageAtomicXor(01T10D00D00E
imageAtomicAnd(01b20D00D
step(00B00B
texture2DLodEXT(00I10B00B
texture(00K20B00B
textureProjGradOffset(00n30B10B10B10D
textureGrad(00J20B20B20B
imageAtomicCompSwap(01V20D00D00E00E
textureOffset(00U20B10D00B
intBitsToFloat(10D
min(20C20C
findLSB(10D
textureProjLodOffset(00Y30B00B20D
imageAtomicMax(01h00D00E
texture3D(00J20B
imageAtomicAdd(01X10D00E
faceforward(20C20C20C
imageAtomicAnd(01O10D00E
imageAtomicAdd(01X10D00D
imageAtomicXor(01W20D00D00D
imageAtomicXor(01W20D00D00E
textureGather(00n10B00B
imageAtomicXor(01Z10D00E
imageAtomicXor(01Z10D00D
textureGather(00X10B00D
imageAtomicMax(01L00D00E
imageAtomicMax(01L00D00D
imageAtomicXor(01G20D00E
imageAtomicXor(01G20D00D
textureOffset(00a20B10D
imageAtomicExchange(01X10D00B
textureGatherOffsets(00v10B10Dx4
texture2DProj(00I30B00B
textureQueryLod(00X10B
imageAtomicAnd(01I20D00E
textureCubeGradEXT(00K20B20B20B
min(00B00B
textureGradOffset(00o00B00B00B00D
imageAtomicExchange(01Q10D00B
mix(30C30C30F
mix(30C30C30C
degrees(00B
imageAtomicMax(01J20D00E
imageAtomicMax(01J20D00D
imageAtomicMin(01D20D00D
textureGatherOffsets(00R10B10Dx4
atomicExchange(00D00D
textureOffset(00m20B00D00B
textureOffset(00f30B10D
imageStore(01c20D30E
imageAtomicExchange(01a20D00D
imageAtomicExchange(01a20D00E
imageAtomicExchange(01a20D00B
matrixCompMult(60B60B
imageAtomicCompSwap(00z10D00D00D
textureProj(00t30B
textureProjGradOffset(00t10B00B00B00D
unpackSnorm2x16(00E
lessThan(30D30D
atan(00B00B
textureQueryLod(00S20B
notEqual(10B10B
imageLoad(01G20D
trunc(30B
trunc(30C
length(00B
length(00C
imageAtomicAnd(01H20D00D
imageAtomicAnd(01H20D00E
textureProj(00X30B00B
imageAtomicCompSwap(01C20D00E00E
tan(00B
min(20E00E
textureLod(00x30B00B
textureSize(00j
textureSize(00n
imageAtomicXor(01F20D00D
textureSize(00c
textureSize(00b
min(20B20B
textureSize(00q
textureSize(00r
textureSize(00w
textureSize(00v
bitfieldInsert(20E20E00D00D
textureSize(00O
imageAtomicAnd(01a20D00E
imageAtomicMin(01g00D00D
trunc(00C
imageAtomicAnd(01a20D00D
textureSize(00Q
textureSize(00P
imageAtomicAdd(01M00D00E
imageLoad(01K20D
textureSize(00W
textureProjLod(00X20B00B
smoothstep(00C00C00C
atomicCounterAnd(00G00E
faceforward(30B30B30B
distance(20C20C
atomicCounterAdd(00G00E
imageStore(01O10D30B
texture(00X10B
ceil(00C
ceil(00B
distance(00B00B
texelFetch(00O10D
imageAtomicExchange(01C20D00D
imageAtomicExchange(01C20D00E
textureGrad(00s30B20B20B
textureGather(00I10B
imageAtomicExchange(01C20D00B
min(30D30D
imageAtomicExchange(01Z10D00B
findMSB(30E
findMSB(30D
textureGradOffset(00R10B10B10B10D
fwidth(30B
textureGrad(00K20B20B20B
texelFetch(00S20D00D
max(10B00B
textureProjGradOffset(00R30B10B10B10D
texelFetchOffset(00L20D00D10D
isnan(30C
transpose(50B
greaterThanEqual(20D20D
asinh(00B
textureGather(00Z20B
textureGrad(00p10B00B00B
textureProjOffset(00v30B10D
greaterThan(20B20B
min(20D20D
texelFetchOffset(00g00D00D00D
imageAtomicCompSwap(01g00D00E00E
imageAtomicMin(01W20D00D00E
imageAtomicMin(01W20D00D00D
imageAtomicXor(01O10D00D
imageAtomicXor(01O10D00E
tanh(20B
textureProj(00m30B00B
sin(20B
smoothstep(00C00C30C
textureSize(00l00D
textureLod(00o00B00B
textureOffset(00I10B10D00B
imageAtomicAnd(00z10D00D
imageAtomicAnd(00z10D00E
imageAtomicCompSwap(01W20D00D00D00D
textureOffset(00J20B20D00B
lessThanEqual(20E20E
textureOffset(00g00B00D
textureProj(00g30B
bitfieldInsert(30E30E00D00D
bitfieldExtract(20E00D00D
uintBitsToFloat(20E
unpackUnorm4x8(00E
imageAtomicExchange(01K20D00E
mod(10B10B
imageAtomicExchange(01K20D00B
imageAtomicAnd(01B10D00E
imageAtomicXor(01i00D00D
equal(20D20D
mix(10E10E10F
textureGather(00R10B00D
textureSize(00Z00D
bitfieldExtract(30D00D00D
imageAtomicXor(01J20D00D
imageAtomicXor(01J20D00E
intBitsToFloat(00D
textureLodOffset(00m20B00B00D
findLSB(00E
texelFetch(00p10D00D
textureGather(00d10B00B
shadow2DProj(00d30B00B
imageAtomicAdd(01T10D00D00D
imageAtomicAdd(01T10D00D00E
inversesqrt(10B
inversesqrt(10C
abs(30D
transpose(D0B
abs(30C
textureProjGrad(00O30B10B10B
imageLoad(01E20D
textureProj(00N20B00B
dFdxCoarse(20B
clamp(20E00E00E
textureProj(00d30B
imageAtomicOr(01i00D00D
imageAtomicOr(01i00D00E
shadow1D(00m20B
textureOffset(00u10B00D
cosh(10B
sign(10C
imageAtomicAnd(01G20D00E
imageAtomicAnd(01G20D00D
sign(10D
umulExtended(00E00E00E00E
texture(00a20B
imageAtomicExchange(01g00D00B
imageAtomicExchange(01B10D00B
ldexp(10B10D
imageAtomicExchange(01B10D00D
imageAtomicExchange(01B10D00E
textureProjOffset(00g30B00D
texture(00Z20B
degrees(10B
texture(00k30B00B
texture(00K20B
sinh(10B
texture(00m20B
imageAtomicXor(01C20D00D
textureGatherOffsets(00I10B10Dx400D
not(30F
textureProjLodOffset(00I20B00B10D
textureGather(00K20B
textureGatherOffset(00R10B10D
memoryBarrierShared(
clamp(20B20B20B
texelFetch(00W20D00D
textureProjLod(00g10B00B
trunc(20C
trunc(20B
textureProjOffset(00I30B10D00B
max(00C00C
tan(10B
texture(00g00B
textureLodOffset(00L20B00B10D
textureLodOffset(00u10B00B00D
imageAtomicOr(01B10D00D
imageAtomicOr(01B10D00E
isinf(20B
dFdyCoarse(10B
textureGatherOffset(00X10B10D00D
min(10E10E
memoryBarrierImage(
round(10B
round(10C
textureProjLodOffset(00m30B00B00D
textureProjGradOffset(00g10B00B00B00D
textureProj(00R30B
shadow1DProj(00m30B
texture(00f30B00B
fma(00B00B00B
imageStore(01X10D30B
imageAtomicOr(01b20D00E
imageAtomicOr(01b20D00D
textureGatherOffset(00v10B10D00D
atomicMax(00E00E
textureQueryLod(00t00B
textureProjOffset(00R30B10D
textureProj(00X30B
findMSB(00D
findMSB(00E
textureProjOffset(00X20B10D
imageAtomicCompSwap(01X10D00D00D
frexp(30C30D
mix(10C10C10C
min(30D00D
imageAtomicCompSwap(01K20D00E00E
texture(00M10B00B
fwidth(20B
imageAtomicOr(01S10D00D00D
imageAtomicOr(01S10D00D00E
mod(30C00C
imageAtomicAdd(01A10D00D
imageAtomicAdd(01A10D00E
texture(00o00B00B
imageAtomicOr(01H20D00E
imageAtomicOr(01H20D00D
cos(20B
textureGather(00T20B
textureProjGradOffset(00J30B20B20B20D
asinh(10B
texelFetchOffset(00v10D10D
imageAtomicXor(01E20D00E
imageAtomicXor(01E20D00D
textureGatherOffsets(00R10B10Dx400D
textureProj
imageAtomicExchange
interpolateAtOffset
textureProjOffset
imageAtomicOr
texture2DProj
textureProjGradOffset
texelFetch
imageLoad
imageAtomicAdd
tanh
imageAtomicCompSwap
textureQueryLod
findMSB
lessThanEqual
textureLod
outerProduct
imageSamples
textureLodOffset
imageAtomicMin
uintBitsToFloat
textureSize
texelFetchOffset
greaterThanEqual
texture
atan
clamp
ceil
imageAtomicAnd
atomicAdd
floatBitsToUint
degrees
imageAtomicXor
imageAtomicMax
inversesqrt
textureProjGrad
equal
groupMemoryBarrier
step
transpose
textureGather
imageStore
modf
determinant
lessThan
sign
cosh
atanh
textureOffset
textureGrad
textureProjLodOffset
dFdyCoarse
isinf
textureGatherOffset
round
greaterThan
smoothstep
texture2DRect
noise2
textureGatherOffsets
fwidthFine
unpackHalf2x16
shadow1D
radians
distance
bitfieldReverse
bitfieldExtract
intBitsToFloat
acosh
atomicXor
dFdy
memoryBarrierBuffer
textureProjLod
refract
noise4
frexp
normalize
inverse
floor
interpolateAtSample
atomicCounterCompSwap
uaddCarry
textureCube
matrixCompMult
textureGradOffset
asin
notEqual
reflect
faceforward
bitCount
packUnorm2x16
umulExtended
textureCubeLod
texture2DProjLodEXT
acos
EmitStreamVertex
atomicCounterDecrement
shadow2DProjEXT
ldexp
findLSB
noise3
texture1DProj
sinh
EmitVertex
textureSamples
fract
shadow2D
length
bitfieldInsert
roundEven
floatBitsToInt
atomicExchange
unpackDouble2x32
texture2DGradEXT
texture2DProjGradEXT
dFdxCoarse
EndStreamPrimitive
texture2D
subpassLoad
sqrt
asinh
atomicCompSwap
ftransform
texture3DProjLod
atomicMin
shadow2DEXT
imageSize
noise1
log2
textureQueryLevels
cross
isnan
imulExtended
dFdyFine
packSnorm2x16
atomicCounterOr
texture1D
texture2DLod
EndPrimitive
atomicOr
packHalf2x16
interpolateAtCentroid
textureCubeLodEXT
fwidthCoarse
usubBorrow
texture2DRectProj
texture3DLod
shadow1DLod
atomicCounterMax
atomicCounterExchange
texture2DProjLod
yuv_2_rgb
atomicAnd
unpackUnorm2x16
packUnorm4x8
atomicMax
dFdxFine
allInvocationsEqual
atomicCounterMin
texture3D
texture1DLod
shadow1DProj
packDouble2x32
texture1DProjLod
exp2
textureVideoWEBGL
dFdx
memoryBarrier
atomicCounterXor
atomicCounterSubtract
allInvocations
texture3DProj
packSnorm4x8
atomicCounterIncrement
shadow1DProjLod
trunc
shadow2DProj
fwidth
shadow2DLod
shadow2DProjLod
memoryBarrierAtomicCounter
rgb_2_yuv
atomicCounter
anyInvocation
barrier
unpackSnorm4x8
texture2DLodEXT
textureCubeGradEXT
unpackSnorm2x16
atomicCounterAnd
atomicCounterAdd
unpackUnorm4x8
memoryBarrierShared
memoryBarrierImage
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/SyncGL.cpp
v24@?0@"<MTLSharedEvent>"8Q16
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/Texture.cpp
onDestroy
Unhandled internal error: 
Error releasing tex image from texture
releaseTexImageInternal
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/TextureGL.cpp
setImageHelper
functions->texImage2D(nativegl::GetTextureBindingTarget(target), static_cast<GLint>(level), texImageFormat.internalFormat, size.width, size.height, 0, texImageFormat.format, texImageFormat.type, pixels)
functions->texImage3D(ToGLenum(target), static_cast<GLint>(level), texImageFormat.internalFormat, size.width, size.height, size.depth, 0, texImageFormat.format, texImageFormat.type, pixels)
functions->texImage2D(nativegl::GetTextureBindingTarget(target), 0, texImageFormat.internalFormat, 1, 1, 0, texImageFormat.format, texImageFormat.type, nullptr)
setSubImageRowByRowWorkaround
setSubImagePaddingWorkaround
setCompressedImage
functions->compressedTexImage2D(ToGLenum(target), static_cast<GLint>(level), compressedTexImageFormat.internalFormat, size.width, size.height, 0, static_cast<GLsizei>(imageSize), pixels)
functions->compressedTexImage3D(ToGLenum(target), static_cast<GLint>(level), compressedTexImageFormat.internalFormat, size.width, size.height, size.depth, 0, static_cast<GLsizei>(imageSize), pixels)
copyImage
functions->texImage2D(ToGLenum(target), static_cast<GLint>(level), copyTexImageFormat.internalFormat, sourceArea.width, sourceArea.height, 0, gl::GetUnsizedFormat(copyTexImageFormat.internalFormat), type, zero->data())
functions->copyTexImage2D(ToGLenum(target), static_cast<GLint>(level), copyTexImageFormat.internalFormat, clippedArea.x, clippedArea.y, clippedArea.width, clippedArea.height, 0)
functions->texStorage2D(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height)
functions->compressedTexImage2D( ToGLenum(type), static_cast<GLint>(level), compressedTexImageFormat.format, levelSize.width, levelSize.height, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage2D(ToGLenum(type), static_cast<GLint>(level), texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->compressedTexImage2D( ToGLenum(face), static_cast<GLint>(level), compressedTexImageFormat.format, levelSize.width, levelSize.height, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage2D( ToGLenum(face), static_cast<GLint>(level), texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->texStorage3D(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, size.depth)
functions->compressedTexImage3D( ToGLenum(type), i, compressedTexImageFormat.format, levelSize.width, levelSize.height, levelSize.depth, 0, static_cast<GLsizei>(dataSize), nullptr)
functions->texImage3D(ToGLenum(type), i, texImageFormat.internalFormat, levelSize.width, levelSize.height, levelSize.depth, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->texStorage2DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, gl::ConvertToGLBoolean(fixedSampleLocations))
functions->texImage2DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, gl::ConvertToGLBoolean(fixedSampleLocations))
functions->texStorage3DMultisample( ToGLenum(type), samples, texStorageFormat.internalFormat, size.width, size.height, size.depth, gl::ConvertToGLBoolean(fixedSampleLocations))
setStorageExternalMemory
functions->texStorageMem2DEXT(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, memoryObjectGL->getMemoryObjectID(), offset)
functions->texStorageMem3DEXT(ToGLenum(type), static_cast<GLsizei>(levels), texStorageFormat.internalFormat, size.width, size.height, size.depth, memoryObjectGL->getMemoryObjectID(), offset)
setImageExternal
generateMipmap
functions->texImage2D( ToGLenum(getType()), effectiveBaseLevel + levelIdx, texImageFormat.internalFormat, levelSize.width, levelSize.height, 0, texImageFormat.format, texImageFormat.type, nullptr)
functions->generateMipmap(ToGLenum(getType()))
initializeContents
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/TextureMtl.mm
ensureTextureCreated
generateMipmapCPU
getAttachmentRenderTarget
setSubImageImpl
setPerSliceSubImage
convertAndSetPerSliceSubImage
copySubImageCPU
copySubTextureCPU
UploadPackedDepthStencilTextureContentsWithStagingBuffer
// BEGIN: Generated code for built-in function emulation
#if defined(GL_FRAGMENT_PRECISION_HIGH)
#define emu_precision highp
#define emu_precision mediump
#endif
// END: Generated code for built-in function emulation
#extension GL_NV_shader_framebuffer_fetch : 
#extension GL_NV_draw_buffers : 
#ifdef GL_EXT_geometry_shader
#extension GL_EXT_geometry_shader : 
#elif defined GL_OES_geometry_shader
#extension GL_OES_geometry_shader : 
#error "No geometry shader extensions available." // Only generate this if the extension is "required"
#extension 
invariant gl_Position;
gl_FragCoord
gl_PointCoord
#define emu_precision
out vec4 webgl_FragColor;
out vec4 webgl_FragData[gl_MaxDrawBuffers];
out vec4 angle_SecondaryFragColor;
out vec4 angle_SecondaryFragData[
#extension GL_ARB_shader_texture_lod : 
#extension GL_ARB_draw_buffers : 
#extension GL_ARB_geometry_shader4 : 
#extension GL_ARB_texture_multisample : 
#extension GL_ARB_explicit_attrib_location : require
#extension GL_ARB_gpu_shader5 : enable
#extension GL_EXT_gpu_shader5 : enable
#extension GL_ARB_texture_cube_map_array : enable
#extension GL_OES_texture_cube_map_array : enable
#extension GL_EXT_texture_cube_map_array : enable
#extension GL_ARB_texture_buffer_objects : enable
#extension GL_OES_texture_buffer : enable
#extension GL_EXT_texture_buffer : enable
 : enable
 : require
mask
gl_SampleMask
gl_FrontFacing
ANGLE_CoverageMaskEnabled
ANGLE_RasterizationDiscard
writeSampleMask
coverageMask
emulatedInstanceID
AngleUniforms
reserved
DepthRangeParams
gl_FragData_
flippedPointCoord
flippedFragCoord
@@XFB-OUT@@
alignas
alignof
as_type
auto
catch
char
class
const_cast
constant
constexpr
decltype
delete
device
dynamic_cast
enum
explicit
export
extern
fragment
friend
goto
half
inline
int16_t
int32_t
int64_t
int8_t
kernel
long
mutable
namespace
noexcept
nullptr_t
nullptr
operator
override
private
protected
ptrdiff_t
public
ray_data
register
short
signed
size_t
sizeof
stage_in
static_assert
static_cast
static
template
this
thread_local
thread
threadgroup_imageblock
threadgroup
throw
typedef
typeid
typename
uchar
uint16_t
uint32_t
uint64_t
uint8_t
union
unsigned
ushort
using
vertex
virtual
wchar_t
void
float
uint
bool
yuvCscStandardEXT
sampler2D
sampler3D
samplerCube
samplerExternalOES
__samplerExternal2DY2YEXT
sampler2DRect
sampler2DArray
sampler2DMS
sampler2DMSArray
samplerCubeArray
samplerBuffer
isampler2D
isampler3D
isamplerCube
isampler2DArray
isampler2DMS
isampler2DMSArray
isamplerCubeArray
isamplerBuffer
usampler2D
usampler3D
usamplerCube
usampler2DArray
usampler2DMS
usampler2DMSArray
usamplerCubeArray
usamplerBuffer
sampler2DShadow
samplerCubeShadow
sampler2DArrayShadow
samplerCubeArrayShadow
structure
interface block
image2D
iimage2D
uimage2D
image3D
iimage3D
uimage3D
image2DArray
iimage2DArray
uimage2DArray
imageCube
iimageCube
uimageCube
imageCubeArray
iimageCubeArray
uimageCubeArray
imageBuffer
iimageBuffer
uimageBuffer
atomic_uint
samplerVideoWEBGL
unknown type
mat2
mat2x3
mat2x4
mat3x2
mat3
mat3x4
mat4x2
mat4x3
mat4
vec2
vec3
vec4
ivec2
ivec3
ivec4
bvec2
bvec3
bvec4
uvec2
uvec3
uvec4
intBitsToFloat
uintBitsToFloat
Unknown error.
Window System
Shader Compiler
Third Party
Application
Other
Unknown Source
Error
Deprecated behavior
Undefined behavior
Portability
Performance
Marker
Unknown Type
High
Medium
Notification
Unknown Severity
Not initialized.
Bad access.
Bad allocation.
Bad attribute.
Bad config.
Bad context.
Bad current surface.
Bad display.
Bad match.
Bad native window.
Bad native pixmap.
Bad parameter.
Bad surface.
Context lost.
Bad stream.
Bad state.
Bad device.
Found child with two parents
<validateSingleParent>
<validateNullNodes>
Found nullptr child
Loop index cannot be statically assigned to within the body of the loop
Index expression must be constant
This type of loop is not allowed
while
Missing init declaration
Invalid init declaration
Invalid type for loop index
Loop index cannot be initialized with non-constant expression
Missing condition
Invalid condition
Expected loop index
Invalid relational operator
Loop index cannot be compared with non-constant expression
Missing expression
Invalid expression
Invalid operator
Loop index cannot be modified by non-constant expression
conflicting output locations with previously defined output '
output array locations would exceed MAX_DRAW_BUFFERS
output location must be < MAX_DRAW_BUFFERS
must explicitly specify all locations when using multiple fragment outputs
not allowed to specify yuv qualifier when using depth or multiple color fragment outputs
default
label statement nested inside control flow
duplicate default label
case label type does not match switch init-expression type
duplicate case label
statement before the first label
switch
no statement between the last label and the end of the switch statement
too complex expressions inside a switch statement
' conflicting location with previously defined '
display is not initialized.
display had a context loss
image is not valid.
device is EGL_NO_DEVICE.
device is not valid.
sync object is not valid.
EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR is not
 valid for GLES with EGL 1.4 and KHR_create_context. Use
 EXT_create_context_robustness.
Invalid Context attribute.
Attribute must be EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE requires EGL_ANGLE_create_context_webgl_compatibility.
EGL_CONTEXT_WEBGL_COMPATIBILITY_ANGLE must be EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM requires EGL_CHROMIUM_create_context_bind_generates_resource.
EGL_CONTEXT_BIND_GENERATES_RESOURCE_CHROMIUM must be EGL_TRUE or EGL_FALSE.
Attribute EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE requires EGL_ANGLE_display_texture_share_group.
EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE must be EGL_TRUE or EGL_FALSE.
All contexts within a share group must be created with the same value of EGL_DISPLAY_TEXTURE_SHARE_GROUP_ANGLE.
Attribute EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE requires EGL_ANGLE_display_semaphore_share_group.
EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE must be EGL_TRUE or EGL_FALSE.
All contexts within a share group must be created with the same value of EGL_DISPLAY_SEMAPHORE_SHARE_GROUP_ANGLE.
Attribute EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE requires EGL_ANGLE_create_context_client_arrays.
EGL_CONTEXT_CLIENT_ARRAYS_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE requires EGL_ANGLE_program_cache_control.
EGL_CONTEXT_PROGRAM_BINARY_CACHE_ENABLED_ANGLE must be EGL_TRUE or EGL_FALSE.
Attribute EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE requires EGL_ANGLE_robust_resource_initialization.
EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE must be either EGL_TRUE or EGL_FALSE.
Attribute EGL_EXTENSIONS_ENABLED_ANGLE requires EGL_ANGLE_create_context_extensions_enabled.
EGL_EXTENSIONS_ENABLED_ANGLE must be either EGL_TRUE or EGL_FALSE.
Attribute EGL_POWER_PREFERENCE_ANGLE requires EGL_ANGLE_power_preference.
EGL_POWER_PREFERENCE_ANGLE must be either EGL_LOW_POWER_ANGLE or EGL_HIGH_POWER_ANGLE.
Attribute EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE requires EGL_ANGLE_create_context_backwards_compatible.
EGL_CONTEXT_OPENGL_BACKWARDS_COMPATIBLE_ANGLE must be either EGL_TRUE or EGL_FALSE.
Attribute EGL_CONTEXT_PRIORITY_LEVEL_IMG requires extension EGL_IMG_context_priority.
Attribute EGL_CONTEXT_PRIORITY_LEVEL_IMG must be one of: EGL_CONTEXT_PRIORITY_LOW_IMG, EGL_CONTEXT_PRIORITY_MEDIUM_IMG, or EGL_CONTEXT_PRIORITY_HIGH_IMG.
Attribute EGL_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV requires extension EGL_NV_robustness_video_memory_purge.
EGL_GENERATE_RESET_ON_VIDEO_MEMORY_PURGE_NV must be either EGL_TRUE or EGL_FALSE.
Unknown attribute.
Requested GLES version is not supported.
EGL_ANGLE_surface_orientation is not enabled.
EGL_GGP_STREAM_DESCRIPTOR_ANGLE requires EGL_ANGLE_ggp_stream_descriptor.
EGL_FLEXIBLE_SURFACE_COMPATIBILITY_SUPPORTED_ANGLE cannot be used without EGL_ANGLE_flexible_surface_compatibility support.
<buftype> EGL_IOSURFACE_ANGLE requires the EGL_ANGLE_iosurface_client_buffer extension.
<buffer> must be non null
Width and Height are not supported for thie <buftype>
Width and Height must be positive
Invalid value for EGL_TEXTURE_FORMAT
<buftype> doesn't support rectangle texture targets
Invalid value for EGL_TEXTURE_TARGET
<buftype> doesn't support iosurface plane
<buftype> doesn't support texture type
<buftype> doesn't support texture internal format
<buftype> doesn't support setting GL colorspace
IOSurface usage hint must only contain READ or WRITE
<buftype> doesn't support setting texture offset
Texture offset cannot be negative
invalid GL colorspace
EGL_IOSURFACE requires the texture target to match the config
EGL_IOSURFACE requires the EGL_TEXTURE_RGBA format
Missing required attribute for EGL_IOSURFACE
EGL_NOK_texture_from_pixmap is not enabled.
Unknown attribute
Congfig does not suport pixmaps.
If ctx is EGL_NO_CONTEXT, surfaces must be EGL_NO_SURFACE
If ctx is not EGL_NOT_CONTEXT, draw or read must both be EGL_NO_SURFACE, or both not
If ctx is not EGL_NO_CONTEXT, surfaces must not be EGL_NO_SURFACE
read and draw must both be valid surfaces, or both be EGL_NO_SURFACE
'dpy' not a valid EGLDisplay handle
'dpy' not initialized
Surface not compatible with OpenGL ES 1.x.
Surface not compatible with OpenGL ES 2.x.
Surface not compatible with OpenGL ES 3.x.
Surface not compatible with Context API.
Context with no config is not supported.
Color buffer types are not compatible.
Color buffer sizes are not compatible.
Color buffer component types are not compatible.
Depth-stencil buffer types are not compatible.
Surface type is not compatible.
EGL_IMAGE_PRESERVED must be EGL_TRUE or EGL_FALSE.
EGL_GL_TEXTURE_LEVEL cannot be used without KHR_gl_texture_*_image support.
EGL_GL_TEXTURE_LEVEL cannot be negative.
EGL_GL_TEXTURE_ZOFFSET cannot be used without KHR_gl_texture_3D_image support.
EGL_GL_COLORSPACE cannot be used without EGL_KHR_gl_colorspace support.
EGL_TEXTURE_INTERNAL_FORMAT_ANGLE and EGL_TEXTURE_TYPE_ANGLE cannot be used without EGL_ANGLE_image_d3d11_texture support.
Parameter cannot be used if target is not EGL_LINUX_DMA_BUF_EXT
Parameter cannot be used without EGL_EXT_image_dma_buf_import support.
Invalid value for EGL_YUV_COLOR_SPACE_HINT_EXT.
Invalid value for EGL_SAMPLE_RANGE_HINT_EXT.
Invalid value for EGL_YUV_CHROMA_HORIZONTAL_SITING_HINT_EXT or EGL_YUV_CHROMA_VERTICAL_SITING_HINT_EXT.
Parameter cannot be used without EGL_EXT_image_dma_buf_import_modifiers support.
invalid attribute: 0x
KHR_gl_texture_2D_image not supported.
buffer cannot reference a 2D texture with the name 0.
target is not a 2D texture.
texture has a surface bound to it.
target 2D texture does not have a valid size at specified level.
KHR_gl_texture_cubemap_image not supported.
buffer cannot reference a cubemap texture with the name 0.
target is not a cubemap texture.
target cubemap texture does not have a valid size at specified level and face.
if level is zero and the texture is incomplete, it must have all of its faces specified at level zero.
KHR_gl_texture_3D_image not supported.
buffer cannot reference a 3D texture with the name 0.
target is not a 3D texture.
target 3D texture does not have a valid size at specified level.
target 3D texture does not have enough layers for the specified Z offset at the specified level.
KHR_gl_renderbuffer_image not supported.
EGL_GL_TEXTURE_LEVEL cannot be used in conjunction with a renderbuffer target.
buffer cannot reference a renderbuffer with the name 0.
target is not a renderbuffer.
target renderbuffer cannot be multisampled.
EGL_ANDROID_image_native_buffer not supported.
ctx must be EGL_NO_CONTEXT.
EGL_ANGLE_image_d3d11_texture not supported.
EGL_EXT_image_dma_buf_import not supported.
buffer must be NULL.
Missing required parameter 
 for image target EGL_LINUX_DMA_BUF_EXT.
the list of attributes contains EGL_DMA_BUF_PLANE*_MODIFIER_LO_EXT but not EGL_DMA_BUF_PLANE*_MODIFIER_HI_EXT or vice versa.
EGL_ANGLE_metal_texture_client_buffer not supported.
invalid target: 0x
EGL_GL_TEXTURE_ZOFFSET must be used with a 3D texture target.
EGL_KHR_image not supported.
Device creation extension not active
Invalid attrib_list parameter
D3D11 device creation extension not active
Invalid device_type parameter
Invalid device parameter
Device must have been created using eglCreateDevice
Invalid attribute
EGL_KHR_fence_sync extension is not available
CreateSync can only be called on the current display
EGL_SYNC_FENCE_KHR cannot be used without GL_OES_EGL_sync support.
EGL_ANDROID_native_fence_sync extension is not available.
EGL_KHR_reusable_sync extension is not available.
Invalid type parameter
EGL_SYNC_CONDITION_KHR is not valid for this sync type.
EGL_KHR_wait_sync extension is not available
No context is current.
Server-side waits cannot be performed without GL_OES_EGL_sync support.
flags must be zero
Invalid value parameter
Stream extension not active
Bad stream state
Consumer GLTexture extension not active
Stream consumer extension not active
EGL stream consumer external GL extension not enabled
Invalid stream
Invalid stream state
No external texture bound
No GL context current to calling thread.
Current GL context not associated with stream consumer
Invalid stream consumer type
Invalid color buffer type
Invalid plane count
Invalid texture unit
Plane count must be 0 for RGB buffer
Planes cannot be specified
Invalid YUV plane count
Invalid plane specified
Not all planes specified
No external texture bound at one or more specified texture units
Multiple planes bound to same texture object
Stream producer extension not active
Stream not in connecting state
Incompatible stream consumer type
Invalid subresource index
Invalid plane offset
Stream not fully configured
Incompatible stream producer
Texture is null
syncControlCHROMIUM extension not active
syncControlRateANGLE extension not active
numerator is null
denominator is null
ust is null
msc is null
sbc is null
EGL_KHR_swap_buffers_with_damage is not available.
Swap surface cannot be EGL_NO_SURFACE.
n_rects cannot be negative.
n_rects cannot be greater than zero when rects is NULL.
the 'engine' parameter has an unrecognized value
EGL_ANDROID_presentation_time is not available.
Blob cache functions can only be set once in the lifetime of a Display
Blob cache callbacks cannot be null.
num_config cannot be null.
EGL_EXT_platform_base not supported
ValidateCreatePlatformWindowSurfaceEXT unimplemented.
ValidateCreatePlatformPixmapSurfaceEXT unimplemented.
Extension not supported
Invalid program cache attribute.
Program index out of range.
keysize and binarysize must always be valid pointers.
Invalid program key size.
key and binary must both be null or both non-null.
null pointer in arguments.
binarysize out of valid range.
limit must be non-negative.
Invalid cache resize mode.
Surface cannot be EGL_NO_SURFACE.
Surface does not support EGL_MULTISAMPLE_RESOLVE_BOX.
Invalid multisample resolve type.
Surface does not support EGL_SWAP_BEHAVIOR_PRESERVED.
Invalid swap behaviour.
EGL_WIDTH or EGL_HEIGHT cannot be set without EGL_ANGLE_window_fixed_size support.
EGL_WIDTH or EGL_HEIGHT cannot be set without EGL_FIXED_SIZE_ANGLE being enabled on the surface.
EGL_TIMESTAMPS_ANDROID cannot be used without EGL_ANDROID_get_frame_timestamps support.
Invalid value.
Invalid surface attribute.
EGL_POST_SUB_BUFFER_SUPPORTED_NV cannot be used without EGL_ANGLE_surface_orientation support.
EGL_FIXED_SIZE_ANGLE cannot be used without EGL_ANGLE_window_fixed_size support.
EGL_SURFACE_ORIENTATION_ANGLE cannot be queried without EGL_ANGLE_surface_orientation support.
EGL_DIRECT_COMPOSITION_ANGLE cannot be used without EGL_ANGLE_direct_composition support.
EGL_ROBUST_RESOURCE_INITIALIZATION_ANGLE cannot be used without EGL_ANGLE_robust_resource_initialization support.
Invalid context attribute.
EGL_KHR_debug extension is not available.
message controls must be EGL_TRUE or EGL_FALSE.
unknown attribute.
EGL_ANDROID_get_frame_timestamps extension is not available.
invalid timing name.
names is NULL.
values is NULL.
numTimestamps must be at least 0.
invalid compositor timing.
compositor timing not supported by surface.
frameId is NULL.
invalid timestamp type.
timestamp collection is not enabled for this surface.
timestamps is NULL.
timestamp not supported by surface.
EGL_ANGLE_feature_control extension is not available.
index is negative.
name is not valid.
index is too big.
EGL_EXT_device_query extension is not available.
attribute is not valid.
NULL buffer.
incorrect channel size requested
invalid usage flag
invalid attribute
incorrect buffer dimensions requested
unsupported format
EGL_ANGLE_swap_buffers_with_frame_token is not available.
eglSignalSyncKHR invalid mode.
display is EGL_NO_DISPLAY.
display is not a valid display.
when object type is EGL_OBJECT_DISPLAY_KHR, the object must be the same as the display.
unknown object type.
EXT_gl_colorspace_display_p3_linear is not available.
EXT_gl_colorspace_display_p3 is not available.
EGL_EXT_gl_colorspace_display_p3_passthrough is not available.
EXT_gl_colorspace_scrgb is not available.
EXT_gl_colorspace_scrgb_linear is not available.
texture must be complete if level is non-zero.
if level is zero and the texture is incomplete, it must have no mip levels specified except zero.
Attempt to initialize readonly parameter
Latency must be positive
Consumer GL extension not enabled
Timeout must be positive
Invalid stream attribute
EGL_EXT_pixel_format_float is not enabled.
EGL_ANDROID_recordable is not enabled.
EGL_ANDROID_framebuffer_target is not enabled.
EGL_ANGLE_iosurface_client_buffer is not enabled.
EGL_bind_to_texture invalid attribute: 
EGL_color_buffer_type invalid attribute: 
EGL_native_renderable invalid attribute: 
EGL_transparent_type invalid attribute: 
EGL_RECORDABLE_ANDROID invalid attribute: 
EGL_COLOR_COMPONENT_TYPE_EXT invalid attribute: 
Platform ANGLE extension is not active
Platform Device extension is not active
Bad platform type.
Invalid automatic trim attribute
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE extension not active.
Invalid D3D11on12 attribute
EGL_ANGLE_experimental_present_path extension not active
Invalid value for EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE
EGL_ANGLE_platform_angle_d3d is not supported
EGL_ANGLE_platform_angle_device_type_egl_angle is not supported
EGL_ANGLE_platform_angle_device_type_swiftshader is not supported
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_TYPE_ANGLE attrib
EGL_ANGLE_platform_angle extension not active
EGL_PLATFORM_ANGLE_DEBUG_LAYERS_ENABLED_ANGLE must be EGL_TRUE, EGL_FALSE, or EGL_DONT_CARE.
EGL_ANGLE_platform_angle_context_virtualization extension not active
Invalid value for EGL_PLATFORM_ANGLE_CONTEXT_VIRTUALIZATION_ANGLE attrib
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_CONTEXT_VOLATILE_EAGL_ANGLE attrib
Invalid value for EGL_PLATFORM_ANGLE_DEVICE_CONTEXT_VOLATILE_CGL_ANGLE attrib
Must specify major version if you specify a minor version.
EGL_PLATFORM_ANGLE_DEVICE_TYPE_WARP_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_ENABLE_AUTOMATIC_TRIM_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE requires a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D11ON12_ANGLE requires a device type of EGL_PLATFORM_ANGLE_DEVICE_TYPE_HARDWARE_ANGLE or EGL_PLATFORM_ANGLE_DEVICE_TYPE_D3D_WARP_ANGLE
EGL_EXPERIMENTAL_PRESENT_PATH_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
EGL_PLATFORM_ANGLE_D3D_LUID_HIGH_ANGLE and EGL_PLATFORM_ANGLE_D3D_LUID_LOW_ANGLE require a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE.
If either EGL_PLATFORM_ANGLE_D3D_LUID_HIGH_ANGLE and/or EGL_PLATFORM_ANGLE_D3D_LUID_LOW_ANGLE are specified, at least one must non-zero.
This device type requires a platform type of EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE or EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE.
This device type requires a platform type of EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE.
EGL_PLATFORM_ANGLE_TYPE_VULKAN_ANGLE currently only supports Vulkan 1.0.
EGL_PLATFORM_ANGLE_EGL_HANDLE_ANGLE requires a device type of EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE.
native_display should be a valid EGL device if platform equals EGL_PLATFORM_DEVICE_EXT
EGL_ANGLE_feature_control is not supported
EGL_FEATURE_OVERRIDES_ENABLED_ANGLE must be a valid pointer
EGL_FEATURE_OVERRIDES_DISABLED_ANGLE must be a valid pointer
Direct3D platform is unsupported.
OpenGL platform is unsupported.
Display type EGL_PLATFORM_ANGLE_TYPE_NULL_ANGLE requires EGL_ANGLE_platform_angle_null.
Vulkan platform is unsupported.
Metal platform is unsupported.
Unknown platform type.
Invalid or unsupported texture target.
A texture must be bound.
Insufficient buffer size.
Enum is not currently supported.
OpenGL ES 3.0 Required.
GLES1-only function.
Invalid pname.
Base level must be at least 0.
Base level must be 0.
Level of detail outside of range.
Enum requires GLES 3.1
Extension is not enabled.
EGL_ANGLE_robust_resource_initialization not enabled.
Sampler is not valid
Primcount must be greater than or equal to zero.
Attempting to draw without a program
At least one enabled attribute must have a divisor of zero.
Negative size.
The texture is a non-power-of-two texture.
Integer overflow.
It is undefined behavior to use a pixel unpack buffer that is bound for transform feedback.
imageSize must be 0 if no texture data is provided.
imageSize is too small.
Stride is over the maximum stride allowed by WebGL.
Offset must be a multiple of the passed in datatype.
Stride must be a multiple of the passed in datatype.
Expected a program name, but found a shader name.
Program object expected.
Expected a shader name, but found a program name.
Shader object expected.
Invalid Attachment Type.
Invalid renderbuffer target.
Renderbuffer width and height cannot be negative and cannot exceed maximum texture size.
Invalid renderbuffer internalformat.
Desired resource size is greater than max renderbuffer size.
Invalid framebuffer target.
It is invalid to change default FBO's attachments
Invalid blit filter.
Invalid blit mask.
Only nearest filtering can be used when blitting buffers other than the color buffer.
Read and draw framebuffers must both exist for a blit to succeed.
Blit feedback loop: the read and draw framebuffers are the same.
BlitFramebuffer dimensions out of 32-bit integer range.
If the read buffer contains fixed-point or floating-point values, the draw buffer must as well.
If the read buffer contains fixed-point values, the draw buffer must as well.
If the read buffer contains unsigned integer values the draw buffer must as well.
If the read buffer contains signed integer values the draw buffer must as well.
Attempt to blit from a multisampled framebuffer and the bounds or format of the color buffer don't match with the draw framebuffer.
Read and write color attachments cannot be the same image.
Cannot use GL_LINEAR filter when blitting a integer framebuffer.
Attempt to read from a missing color attachment of a complete framebuffer.
Depth/stencil buffer format combination not allowed for blit.
Attempt to blit from a multisampled framebuffer and the bounds don't match with the draw framebuffer.
Read and write depth stencil attachments cannot be the same image.
Attempt to read from a missing depth/stencil attachment of a complete framebuffer.
Attempt to read from a multi-view framebuffer.
Attempt to write to a multi-view framebuffer.
Negative buffer size.
Query extension not enabled.
Invalid query type.
Invalid query Id.
Other query is active.
Query type does not match target.
Query is not active.
Invalid query target.
Query is active.
Context has been lost.
Negative count.
Program not linked.
Invalid uniform location
Only array uniforms may have count > 1.
Sampler uniform value out of range.
Uniform type does not match uniform method.
Index must be less than MAX_DRAW_BUFFERS.
GL_ANGLE_texture_multisample_array not enabled.
Texture buffer extension not available.
Read buffer is GL_NONE.
Read buffer has no attachment.
name is not a valid renderbuffer.
Not a valid texture object name.
Passed in texture type must match the one originally used to define the texture.
Invalid target.
Negative offset.
The specified dimensions are outside of the bounds of the texture.
The texture is not complete.
Invalid region for compressed texture format.
Texture formats are not compatible
Samples must not be greater than maximum supported value for the format.
Offset overflows texture dimensions.
Border must be 0.
Missing read attachment.
The active read framebuffer object has multiview attachments.
Texture is immutable.
Invalid format.
Texture is not cubemap complete. All cubemaps faces must be defined and be the same size.
Desired resource size is greater than max texture size.
Feedback loop formed between Framebuffer and active Texture.
A program object is active for at least one, but not all of the shader stages that were present when the program was linked.
An active buffer is mapped
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/validationES.cpp
ValidateDrawStates
This ANGLE implementation does not support separate front/back stencil writemasks, reference values, or stencil mask values.
Stencil reference and mask values must be the same for front facing and back facing triangles.
GL_BLEND with floating-point color attachments requires the EXT_float_blend extension.
CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination color factors in the blend function.
Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR as color factors is not supported by this implementation.
An enabled vertex array has no buffer.
An enabled vertex array has no buffer and no pointer.
Two textures of different types use the same sampler location.
Mismatch between texture format and sampler type (signed/unsigned/float/shadow).
A transform feedback buffer that would be written to is also bound to a non-transform-feedback target, which would cause undefined behavior.
Vertex shader input type does not match the type of the bound vertex attribute.
Active draw buffers with missing fragment shader outputs.
Fragment shader output type does not match the bound framebuffer attachment type.
It is undefined behavior to use a vertex buffer that is bound for transform feedback.
Draw mode must match current transform feedback object's draw mode.
GL_EXT_geometry_shader extension not enabled.
Invalid draw mode.
Primitive mode is incompatible with the input primitive type of the geometry shader.
The draw command is unsupported when transform feedback is active and not paused.
It is undefined behavior to use an element array buffer that is bound for transform feedback.
Must have element array buffer bound.
No Texture is bound to the specified target.
Program doesn't exist.
Negative number of attachments.
Invalid attachment when the default framebuffer is bound.
Index is greater than the maximum supported color attachments
Invalid attachment when a user framebuffer is bound.
EGL image is not valid.
Cannot create a 2D texture from a multisampled EGL image.
EGL image internal format is not supported as a texture.
Image has more than 1 layer, target must be TEXTURE_2D_ARRAY
EGL image internal format is not supported as a renderbuffer.
Vertex array does not exist.
Program binary format is not valid.
Cannot change program binary while program is associated with an active transform feedback object.
No program binary formats supported.
Invalid draw buffer.
Ith value does not match COLOR_ATTACHMENTi or NONE.
The default framebuffer must have exactly one draw buffer.
Only NONE or BACK are valid draw buffers for the default framebuffer
Invalid buffer target.
Can not get pointer for reserved buffer name zero.
Buffer is not mapped.
Negative length.
Attempted to map buffer object zero.
Mapped range does not fit into buffer dimensions.
Invalid access bits.
Length must not be zero.
Buffer is already mapped.
Need to map buffer for either reading or writing.
Invalid access bits when mapping buffer for reading
The explicit flushing bit may only be set if the buffer is mapped for writing.
Attempted to flush buffer object zero.
Attempted to flush a buffer not mapped for explicit flushing.
Flushed range does not fit into buffer mapping dimensions.
More parameters are required than were provided.
Attachment type must be compatible with attachment object.
Invalid parameter name for framebuffer attachment.
Enum requires GLES 3.0
No active compute shader stage in this program.
No active geometry shader stage in this program.
No defined conversion between clear value and attachment format.
dataSize is too small
A buffer must be bound.
GL_BUFFER_MAP_POINTER can only be queried with GetBufferPointerv.
A renderbuffer must be bound.
GL_ANGLE_get_image extension not enabled.
Index must be less than MAX_VERTEX_ATTRIBS.
It is undefined behavior to use a pixel pack buffer that is bound for transform feedback.
The provided parameters overflow with the provided buffer.
Invalid combination of pack parameters for WebGL.
Invalid format and type combination.
Index exceeds active uniform block count.
Internal format is not renderable.
GL_ANGLE_texture_multisample or GLES 3.1 required.
Invalid operation on multisampled framebuffer
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_TEXTURE_UNITS)
Width and height must be less than or equal to GL_MAX_TEXTURE_SIZE.
Samples may not be zero.
SizedInternalformat must be color-renderable, depth-renderable, or stencil-renderable.
Internalformat is one of the unsupported unsized base internalformats.
Zero is bound to target.
The value of TEXTURE_IMMUTABLE_FORMAT for the texture currently bound to target on the active texture unit is true.
Texture dimensions must all be greater than zero.
Index must be less than the value of SAMPLES.
MaskNumber cannot be greater than or equal to the value of MAX_SAMPLE_MASK_WORDS.
Vertex buffer is not big enough for the draw call
Reset status is not valid
Parameter outside of bounds.
Uniform size does not match uniform method.
The number of views in the active program and draw framebuffer does not match.
There is an active transform feedback object when the number of views in the active draw framebuffer is greater than 1.
There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1.
It is undefined behaviour to have a used but unbound uniform buffer.
It is undefined behaviour to use a uniform buffer that is too small.
It is undefined behavior to use an uniform buffer that is bound for transform feedback.
Framebuffer is incomplete.
Invalid wrap mode for texture type.
Texture wrap mode not recognized.
Texture only supports NEAREST and LINEAR filtering.
Texture filter not recognized.
Unknown parameter value.
Enum is not currently supported.
GLES1-only function.
GL_OES_point_size_array not enabled.
Invalid client vertex array type.
Invalid stride for built-in vertex attribute.
Size for built-in vertex attribute is outside allowed range.
Invalid type for built-in vertex attribute.
Invalid light.
Light parameter out of range.
Invalid light parameter.
Material parameter out of range.
Invalid material parameter.
Invalid material face.
Invalid light model parameter.
Invalid clip plane.
Invalid fog mode.
Invalid fog density (must be nonnegative).
Invalid fog parameter.
Invalid texture environment mode.
Invalid texture combine mode.
Invalid texture combine source.
Invalid texture combine operand.
Invalid texture environment scale.
Invalid texture environment parameter.
Invalid texture environment target.
Invalid point parameter value (must be non-negative).
Invalid point parameter.
Invalid point size (must be positive).
Both width and height argument of drawn texture must be positive.
Near value cannot be greater than far.
Invalid projection matrix. Left/right, top/bottom, near/far intervals cannot be zero, and near/far cannot be less than zero.
Invalid width.
Invalid logical operation.
Invalid matrix mode.
Current matrix stack has only a single matrix.
Current matrix stack is full.
Invalid shading model.
Level of detail outside of range.
Rectangle texture cannot have a compressed format.
Each cubemap face must have equal width and height.
Invalid or unsupported texture target.
A buffer must be bound.
Invalid internal format.
Invalid compressed image size.
Enum is not currently supported.
Invalid texture target and format combination.
Pixel data must be null.
Texture level must be zero.
Texture level does not exist.
Passed in texture target and format must match the one originally used to define the texture.
Passed in texture type must match the one originally used to define the texture.
Pixel data cannot be null.
Invalid combination of format, type and internalFormat.
Texture dimensions must all be greater than zero.
Invalid level count.
Texture dimensions must be power-of-two.
No Texture is bound to the specified target.
Extension is not enabled.
Invalid framebuffer target.
Invalid debug source.
Invalid debug type.
Invalid debug severity.
If count is greater than zero, source and type cannot be GL_DONT_CARE.
Message length is larger than GL_MAX_DEBUG_MESSAGE_LENGTH.
Negative buffer size.
Cannot push more than GL_MAX_DEBUG_GROUP_STACK_DEPTH debug groups.
Cannot pop the default debug group.
Blit extension not available.
Scaling and flipping in BlitFramebufferANGLE not supported by this implementation.
Linear blit not supported in this extension.
Blits are only supported from 2D texture, renderbuffer or default framebuffer attachments in this extension.
Blits are only supported to 2D texture, renderbuffer or default framebuffer attachments in this extension.
Attempting to blit and the read and draw buffer formats don't match.
Only whole-buffer blit is supported from a multisampled read buffer in this extension.
Only whole-buffer depth and stencil blits are supported by this extension.
Multisampled depth/stencil blit is not supported by this extension.
Invalid mask bits.
There is an active query for target GL_TIME_ELAPSED_EXT when the number of views in the active draw framebuffer is greater than 1.
Integer overflow.
Compressed texture dimensions must exactly match the dimensions of the data passed in.
Invalid buffer target.
Attempted to map buffer object zero.
Invalid access bits.
Buffer is already mapped.
Buffer is bound for transform feedback.
Location cannot be less than 0.
Location must be less than (MAX_VERTEX_UNIFORM_VECTORS + MAX_FRAGMENT_UNIFORM_VECTORS) * 4
Name contains invalid characters.
Attributes that begin with 'gl_' are not allowed.
components is not one of GL_RGB, GL_RGBA, GL_ALPHA or GL_NONE.
Source texture is not a valid texture object.
Invalid source texture level.
Source texture internal format is invalid.
Destination texture is not a valid texture object.
Invalid destination texture type.
Destination texture cannot be immutable.
Source texture must be a valid texture type.
Negative offset.
Negative size.
The destination level of the destination texture must be defined.
Source texture must level 0 defined.
Source texture must have a compressed internal format.
OpenGL ES 3.1 Required
Invalid shader type.
Invalid buffer usage enum.
Buffer is immutable.
An active buffer is mapped
Buffer is not updatable.
The provided parameters overflow with the provided buffer.
Insufficient buffer size.
Extension is not requestable.
Extension is not disablable.
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_COMBINED_IMAGE_UNITS)
Shader attachment already has a shader.
Index must be less than MAX_VERTEX_ATTRIBS.
Object cannot be used because it has not been generated.
Invalid renderbuffer target.
Invalid blend equation.
Invalid blend function.
CONSTANT_COLOR (or ONE_MINUS_CONSTANT_COLOR) and CONSTANT_ALPHA (or ONE_MINUS_CONSTANT_ALPHA) cannot be used together as source and destination color factors in the blend function.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/validationES2.cpp
ValidateBlendFuncSeparate
Simultaneous use of GL_CONSTANT_ALPHA/GL_ONE_MINUS_CONSTANT_ALPHA and GL_CONSTANT_COLOR/GL_ONE_MINUS_CONSTANT_COLOR as color factors is not supported by this implementation.
Invalid name.
Invalid width.
Near value cannot be greater than far.
Samples must not be greater than maximum supported value for the format.
Cull mode not recognized.
Expected a program name, but found a shader name.
Program object expected.
Shader object expected.
Expected a shader name, but found a program name.
Shader to be detached must be currently attached to the program.
Index must be less than program active uniform count.
Negative maxcount.
A program must be bound.
Program not linked.
Compute shader precision not yet implemented.
Invalid or unsupported precision type.
Invalid pname.
param is negative.
Unpack alignment must be 1, 2, 4 or 8.
Invalid shader binary format.
Negative count.
Shader source contains invalid characters.
Invalid stencil.
Viewport size cannot be negative.
Current renderer doesn't support alpha-to-coverage.
ValidateEnable
Mipmap level must be 0 when attaching a texture.
GL_ANGLE_texture_multisample or GLES 3.1 required.
zoffset is larger than MAX_3D_TEXTURE_SIZE-1
Texture has incompatible target.
A texture must be bound.
Texture base level out of range
Texture format does not support mipmap generation.
The texture is a non-power-of-two texture.
Cannot generate mipmaps for a zero-size texture in a WebGL context.
OpenGL ES 3.0 Required.
Cannot link program while program is associated with an active transform feedback object.
Cannot change active program while transform feedback is unpaused.
GL_NV_fence is not supported
Invalid fence object.
Fence must be set.
Invalid value for condition.
The current context doesn't support setting a non-zero divisor on the attribute with index zero. Please reorder the attributes in your vertex shader so that attribute zero can have a zero divisor.
ValidateVertexAttribDivisorANGLE
Invalid provoking vertex.
Invalid Attachment Type.
Context does not support GL_ANGLE_texture_rectangle
GL_ANGLE_texture_multisample_array not enabled.
External texture extension not enabled
name is not a valid buffer.
name is not a valid vertex array.
name is not a valid query.
name is not a valid transform feedback.
name is not a valid sampler.
Not a valid texture object name.
name is not a valid renderbuffer.
name is not a valid framebuffer.
name is not a valid program pipeline.
Invalid identifier.
Label length is larger than GL_MAX_LABEL_LENGTH.
Not a valid sync pointer.
Location name lengths must not be greater than 256 characters.
Location lengths must not be greater than 1024 characters.
webgl_
_webgl_
Attributes that begin with 'webgl_', or '_webgl_' are not allowed.
Framebuffer is incomplete.
Rectangle texture cannot have a compressed format.
The cubemap depth must be a multiple of 6.
Enum is not currently supported.
Level of detail outside of range.
Compressed data is valid if-and-only-if the texture is compressed.
Invalid compressed image size.
Format must match internal format.
Invalid internal format.
Invalid or unsupported texture target.
Pixel data cannot be null.
Data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type.
An active buffer is mapped
Invalid combination of unpack parameters for WebGL.
Invalid copy texture format combination.
OpenGL ES 3.0 Required.
Negative layer.
Mip level invalid for framebuffer texture attachment.
Layer invalid for framebuffer texture attachment.
Texture is not a three-dimensional or two-dimensionsal array texture.
Compressed textures cannot be attached to a framebuffer.
Invalid framebuffer target.
Negative size.
Invalid element range.
No active read framebuffer.
Invalid read buffer
Read buffer must be GL_NONE or GL_BACK when reading from the default framebuffer.
Index is greater than the maximum supported color attachments
Not a valid compressed texture format.
Integer overflow.
Invalid buffer binding size.
Invalid boolean value. Must be GL_FALSE or GL_TRUE.
OpenGL ES 3.1 Required
Invalid pname.
Index must be less than MAX_DRAW_BUFFERS.
Draw buffer must be zero when using depth or stencil.
Source texture is not a valid texture object.
Destination texture is not a valid texture object.
Invalid source texture level.
Invalid source texture height or width.
Destination texture cannot be immutable.
x = y = or z cannot be negative.
Cannot have negative height, width, or depth.
Destination texture too small.
Extension is not enabled.
Attempt to delete an active transform feedback.
Invalid primitive mode.
Transform feedback is already active.
Transform feedback has a buffer bound to multiple outputs.
A program must be bound.
The active program has specified no output variables to record.
EXT/OES_draw_buffers_indexed is not available.
Index must be less than MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
Index must be less than MAX_UNIFORM_BUFFER_BINDINGS.
Index must be less than the number of workgroup dimensions (3).
Enum requires GLES 3.1
Index must be less than MAX_ATOMIC_COUNTER_BUFFER_BINDINGS.
Index must be within [0, MAX_SHADER_STORAGE_BUFFER_BINDINGS).
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
MaskNumber cannot be greater than or equal to the value of MAX_SAMPLE_MASK_WORDS.
Index must be within [0, MAX_IMAGE_UNITS).
A buffer must be bound.
Buffer is bound for transform feedback.
Buffer offset overflow.
The read and write copy regions alias memory.
Index must be within [0, NUM_EXTENSIONS).
Invalid name.
Index must be within [0, NUM_REQUESTABLE_EXTENSIONS_ANGLE).
Samples must not be greater than maximum supported value for the format.
Cannot have negative stride.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Client data cannot be used with a non-default vertex array object.
Negative buffer size.
Context has been lost.
Sync object does not exist.
Negative baseViewIndex.
Texture has incompatible target.
baseViewIndex+numViews cannot be greater than GL_MAX_ARRAY_TEXTURE_LAYERS.
No Transform Feedback object is active.
Negative count.
Count exceeds MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
Index must be less than the transform feedback varying count in the program.
The active Transform Feedback object is not paused.
Transform feedback object that does not exist.
The active Transform Feedback object is paused.
Program not linked.
Index must be less than program active uniform count.
Index must be less than program active uniform block count.
Invalid value for condition.
Invalid value for flags.
Invalid value for timeout.
Sampler is not valid
Specified unit must be in [GL_TEXTURE0, GL_TEXTURE0 + GL_MAX_COMBINED_IMAGE_UNITS)
Fragment output color index must be zero or one.
Color number for secondary color greater than or equal to MAX_DUAL_SOURCE_DRAW_BUFFERS
Color number for primary color greater than or equal to MAX_DRAW_BUFFERS
GL_ANGLE_texture_multisample or GLES 3.1 required.
GL_ANGLE_texture_multisample, GL_ANGLE_get_tex_level_parameter or GLES 3.1 required.
internalformat is an ETC2/EAC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an ASTC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an S3TC format and target is not GL_TEXTURE_2D_ARRAY.
internalformat is an RGTC format and target is not GL_TEXTURE_2D_ARRAY.
Invalid type.
Format cannot be GL_DEPTH_COMPONENT or GL_DEPTH_STENCIL if target is GL_TEXTURE_3D
Index is greater than or equal to the number of TRANSFORM_FEEDBACK_BUFFER indexed binding points.
Offset and size must be multiple of 4.
Target is TRANSFORM_FEEDBACK_BUFFER and transform feedback is currently active.
Offset must be multiple of value of UNIFORM_BUFFER_OFFSET_ALIGNMENT.
offset must be a multiple of 4.
Offset must be multiple of value of SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT.
Texture buffer extension not available.
Offset must be multiple of value of TEXTURE_BUFFER_OFFSET_ALIGNMENT.
GL_ANGLE_copy_texture_3d extension not available.
Index must be less than MAX_VERTEX_ATTRIBS.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
ANGLE_multiview is not available.
numViews cannot be less than 1.
numViews cannot be greater than GL_MAX_VIEWS_ANGLE.
Framebuffer is incomplete.
EXT/OES_draw_buffers_indexed or ES 3.1 are required but not available.
OpenGL ES 3.1 Required
Default vertex array object is bound.
Client data cannot be used with a non-default vertex array object.
Draw indirect buffer must be bound.
indirect must be a multiple of the size of uint in basic machine units.
Draw mode must match current transform feedback object's draw mode.
The draw command is unsupported when transform feedback is active and not paused.
The provided parameters overflow with the provided buffer.
Must have element array buffer bound.
Extension is not enabled.
Invalid framebuffer target.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_WIDTH.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_HEIGHT.
Params less than 0 or greater than GL_MAX_FRAMEBUFFER_SAMPLES.
GL_EXT_geometry_shader extension not enabled.
Framebuffer layer cannot be less than 0 or greater than GL_MAX_FRAMEBUFFER_LAYERS_EXT.
Invalid pname.
Default framebuffer is bound.
Invalid program interface.
Object cannot be used because it has not been generated.
Index must be within [0, MAX_VERTEX_ATTRIB_BINDINGS).
Negative offset.
Stride must be within [0, MAX_VERTEX_ATTRIB_STRIDE).
Index must be less than MAX_VERTEX_ATTRIBS.
Invalid program resource index.
Negative buffer size.
No active program for the compute shader stage.
num_groups_x cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[0]
num_groups_y cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[1]
num_groups_z cannot be greater than MAX_COMPUTE_WORK_GROUP_COUNT[2]
Offset must be a multiple of sizeof(uint) in basic machine units.
Dispatch indirect buffer must be bound.
Insufficient buffer size.
Index must be within [0, MAX_IMAGE_UNITS).
Level is negative.
Negative layer.
access is not one of the supported tokens.
format is not one of supported image unit formats.
texture is not the name of an existing texture object.
Texture is not immutable.
Program not linked.
Invalid propCount.
Invalid bufSize.
Invalid program resource property.
Not an allowed program resource property for this program interface
Active atomic counter resources are not assigned name strings.
MAX_NUM_ACTIVE_VARIABLES requires a buffer or block interface.
Unrecognized shader stage bit.
Program doesn't exist.
Program object was not linked with its PROGRAM_SEPARABLE status set.
Expected a program name, but found a shader name.
Invalid shader type.
Negative count.
Program pipeline does not exist.
Invalid memory barrier bit.
Not a valid texture object name.
Level of detail outside of range.
GL_ANGLE_texture_multisample_array not enabled.
Target must be TEXTURE_2D_MULTISAMPLE_ARRAY_OES.
Negative size.
Depth must be less than or equal to MAX_ARRAY_TEXTURE_LAYERS
programInterface must be set to GL_PROGRAM_OUTPUT.
Texture buffer extension not available.
Target must be TEXTURE_BUFFER.
Internal format is not an accepted sized internal format.
If buffer is nonzero, it must match the name of an existing buffer object.
Offset must be multiple of value of TEXTURE_BUFFER_OFFSET_ALIGNMENT.
Texture buffer size must be a positive integer.
Texture buffer offset + size must be less than or equal to BUFFER_SIZE.
Draw framebuffer is incomplete
Only UNSIGNED_SHORT and UNSIGNED_BYTE types are supported.
Enum is not currently supported.
Uniform size does not match uniform method.
relativeOffset cannot be greater than MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
Invalid type.
Vertex attribute size must be 1, 2, 3, or 4.
Type is INT_2_10_10_10_REV or UNSIGNED_INT_2_10_10_10_REV and size is not 4.
Type is INT_10_10_10_2_OES or UNSIGNED_INT_10_10_10_2_OES and size is not 3 or 4.
Draw buffer greater than MAX_DRAW_BUFFERS.
Index must be less than MAX_DRAW_BUFFERS.
OpenGL ES 3.2 Required
Enum is not currently supported.
Extension is not enabled.
Invalid pointer query.
OpenGL ES 1.x or 3.2 Required
GL_ANGLE_get_image extension not enabled.
Invalid or unsupported texture target.
Level is negative.
Level of detail outside of range.
Invalid renderbuffer target.
Extension is not enabled.
Element value exceeds element range.
Invalid memory object.
Invalid memory object parameter.
The memory object is immutable.
Invalid handle type.
Invalid image layout.
Create flags must only include bits defined by GL_ANGLE_external_objects_flags
Usage flags must only include bits defined by GL_ANGLE_external_objects_flags
Invalid buffer target.
Negative size.
Invalid buffer usage flags.
A buffer must be bound.
Buffer is immutable.
Invalid format.
Invalid type.
Could not pack varying 
Note: Additional non-conformant packing restrictions are enforced on D3D9.
Failed to unmap the client data streaming buffer.
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/gl/VertexArrayGL.cpp
streamAttributes
/Library/Caches/com.apple.xbs/Sources/ANGLE_Sim/WebKit-7612.1.22.3.2/Source/ThirdParty/ANGLE/src/libANGLE/renderer/metal/VertexArrayMtl.mm
updateClientAttribs
convertVertexBufferCPU
convertVertexBufferGPU
Unsupported format conversion
StreamVertexData
AsyncWaitableEvent::wait
AsyncWorkerPool::RunTask
thread constructor failed
J"`N"
WebSwapLayerEAGL
localizedDescription
UTF8String
renderPassDescriptor
stringWithFormat:
dictionaryWithObjects:forKeys:count:
errorWithDomain:code:userInfo:
initWithAPI:
setCurrentContext:
newCommandQueue
name
rangeOfString:
supportsFamily:
initWithBytesNoCopy:length:encoding:freeWhenDone:
newLibraryWithSource:options:completionHandler:
device
textureType
pixelFormat
texture2DDescriptorWithPixelFormat:width:height:mipmapped:
setUsage:
newTextureWithDescriptor:iosurface:plane:
waitUntilCompleted
commandBuffer
addCompletedHandler:
enqueue
waitUntilScheduled
presentDrawable:
commit
encodeSignalEvent:value:
encodeWaitForEvent:value:
pushDebugGroup:
popDebugGroup
endEncoding
insertDebugSignpost:
texture
setLoadAction:
setStoreAction:
setResolveTexture:
resolveTexture
storeAction
colorAttachments
objectAtIndexedSubscript:
depthAttachment
stencilAttachment
setVisibilityResultBuffer:
renderCommandEncoderWithDescriptor:
setStencilReferenceValue:
setLabel:
setClearColor:
setClearDepth:
setClearStencil:
blitCommandEncoder
copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:
copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:
copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:
fillBuffer:range:value:
copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:
generateMipmapsForTexture:
computeCommandEncoder
setComputePipelineState:
setBuffer:offset:atIndex:
setBytes:length:atIndex:
setSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setTexture:atIndex:
dispatchThreadgroups:threadsPerThreadgroup:
stringWithUTF8String:
setRenderPipelineState:
setTriangleFillMode:
setFrontFacingWinding:
setCullMode:
setDepthStencilState:
setDepthBias:slopeScale:clamp:
setStencilFrontReferenceValue:backReferenceValue:
setViewport:
setScissorRect:
setBlendColorRed:green:blue:alpha:
setVertexBuffer:offset:atIndex:
setVertexBufferOffset:atIndex:
setVertexBytes:length:atIndex:
setVertexSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setVertexTexture:atIndex:
setFragmentBuffer:offset:atIndex:
setFragmentBufferOffset:atIndex:
setFragmentBytes:length:atIndex:
setFragmentSamplerState:lodMinClamp:lodMaxClamp:atIndex:
setFragmentTexture:atIndex:
drawPrimitives:vertexStart:vertexCount:
drawPrimitives:vertexStart:vertexCount:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:
drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:
setVisibilityResultMode:offset:
useResource:usage:stages:
useResource:usage:
supportsTextureSampleCount:
newFunctionWithName:
setConstantValue:type:withName:
newFunctionWithName:constantValues:error:
threadExecutionWidth
newComputePipelineStateWithFunction:error:
textureCubeDescriptorWithPixelFormat:size:mipmapped:
setTextureType:
setPixelFormat:
setWidth:
setHeight:
setMipmapLevelCount:
setSampleCount:
setArrayLength:
setDepth:
mipmapLevelCount
usage
setResourceOptions:
newTextureWithDescriptor:
newTextureViewWithPixelFormat:
newTextureViewWithPixelFormat:textureType:levels:slices:
newTextureViewWithPixelFormat:textureType:levels:slices:swizzle:
storageMode
replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:
getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:
arrayLength
width
height
depth
sampleCount
copy
newBufferWithBytes:length:options:
newBufferWithLength:options:
contents
length
setTexture:
setLevel:
setSlice:
setDepthPlane:
setStepFunction:
setStepRate:
setStride:
vertexDescriptor
layouts
setObject:atIndexedSubscript:
newRenderPipelineStateWithDescriptor:error:
newDepthStencilStateWithDescriptor:
setCompareFunction:
newSamplerStateWithDescriptor:
setResolveLevel:
setResolveDepthPlane:
setResolveSlice:
setStoreActionOptions:
reset
setVertexDescriptor:
setDepthAttachmentPixelFormat:
setStencilAttachmentPixelFormat:
setAlphaToCoverageEnabled:
setRasterizationEnabled:
setVertexFunction:
isRasterizationEnabled
setFragmentFunction:
attributes
setFormat:
setOffset:
setBufferIndex:
setWriteMask:
setAlphaBlendOperation:
setRgbBlendOperation:
setDestinationAlphaBlendFactor:
setDestinationRGBBlendFactor:
setSourceAlphaBlendFactor:
setSourceRGBBlendFactor:
setBlendingEnabled:
setBackFaceStencil:
setFrontFaceStencil:
setDepthCompareFunction:
setDepthWriteEnabled:
setStencilFailureOperation:
setDepthFailureOperation:
setDepthStencilPassOperation:
setStencilCompareFunction:
setReadMask:
setRAddressMode:
setSAddressMode:
setTAddressMode:
setMinFilter:
setMagFilter:
setMipFilter:
setMaxAnisotropy:
setNormalizedCoordinates:
setPreserveInvariance:
languageVersion
setLanguageVersion:
setFastMathEnabled:
setPreprocessorMacros:
newLibraryWithSource:options:error:
newLibraryWithData:error:
supportsFeatureSet:
depthAttachmentPixelFormat
stencilAttachmentPixelFormat
encodedLength
setArgumentBuffer:offset:
newArgumentEncoderWithBufferIndex:
removeFromSuperlayer
frame
setFrame:
setDevice:
setFramebufferOnly:
contentsScale
setContentsScale:
addSublayer:
setDrawableSize:
drawableSize
bounds
nextDrawable
setAllowsNextDrawableTimeout:
newSharedEvent
signaledValue
notifyListener:atValue:block:
init
setNeedsDisplay
presentRenderbuffer:
initWithSharedState:withContext:withFunctions:
display
mDisplayContext
initialized
mSwapState
mFunctions
mReadFramebuffer
@40@0:8^{SharedSwapState=[3{SwapTexture=IIIQ}]{_opaque_pthread_mutex_t=q[56c]}^{SwapTexture}^{SwapTexture}^{SwapTexture}}16@24r^v32
v16@0:8
@"EAGLContext"
^{SharedSwapState=[3{SwapTexture=IIIQ}]{_opaque_pthread_mutex_t=q[56c]}^{SwapTexture}^{SwapTexture}^{SwapTexture}}
# 1 "temp_master_source.metal"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 392 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "temp_master_source.metal" 2
# 1 "./blit.metal" 1
# 1 "./common.h" 1
# 13 "./common.h"
# include <simd/simd.h>
# include <metal_stdlib>
# 1 "./constants.h" 1
# 11 "./constants.h"
namespace rx
namespace mtl_shader
enum
    kTextureType2D = 0,
    kTextureType2DMultisample = 1,
    kTextureType2DArray = 2,
    kTextureTypeCube = 3,
    kTextureType3D = 4,
    kTextureTypeCount = 5,
# 18 "./common.h" 2
using namespace metal;
constant uint32_t kNumColorOutputs [[function_constant(0)]];
constant bool kColorOutputAvailable0 = kNumColorOutputs > 0;
constant bool kColorOutputAvailable1 = kNumColorOutputs > 1;
constant bool kColorOutputAvailable2 = kNumColorOutputs > 2;
constant bool kColorOutputAvailable3 = kNumColorOutputs > 3;
namespace rx
namespace mtl_shader
constant float2 gCorners[3] = {float2(-1.0f, -1.0f), float2(3.0f, -1.0f), float2(-1.0f, 3.0f)};
template <typename T>
struct MultipleColorOutputs
    vec<T, 4> color0 [[color(0), function_constant(kColorOutputAvailable0)]];
    vec<T, 4> color1 [[color(1), function_constant(kColorOutputAvailable1)]];
    vec<T, 4> color2 [[color(2), function_constant(kColorOutputAvailable2)]];
    vec<T, 4> color3 [[color(3), function_constant(kColorOutputAvailable3)]];
# 61 "./common.h"
template <typename T>
static inline MultipleColorOutputs<T> toMultipleColorOutputs(vec<T, 4> color)
    MultipleColorOutputs<T> re;
    do { if (kColorOutputAvailable0) { re.color0 = color; } } while (0);
    do { if (kColorOutputAvailable1) { re.color1 = color; } } while (0);
    do { if (kColorOutputAvailable2) { re.color2 = color; } } while (0);
    do { if (kColorOutputAvailable3) { re.color3 = color; } } while (0);
    return re;
static inline float3 cubeTexcoords(float2 texcoords, int face)
    texcoords = 2.0 * texcoords - 1.0;
    switch (face)
    {
        case 0:
            return float3(1.0, -texcoords.y, -texcoords.x);
        case 1:
            return float3(-1.0, -texcoords.y, texcoords.x);
        case 2:
            return float3(texcoords.x, 1.0, texcoords.y);
        case 3:
            return float3(texcoords.x, -1.0, -texcoords.y);
        case 4:
            return float3(texcoords.x, -texcoords.y, 1.0);
        case 5:
            return float3(-texcoords.x, -texcoords.y, -1.0);
    }
    return float3(texcoords, 0);
template <typename T>
static inline vec<T, 4> resolveTextureMS(texture2d_ms<T> srcTexture, uint2 coords)
    uint samples = srcTexture.get_num_samples();
    vec<T, 4> output(0);
    for (uint sample = 0; sample < samples; ++sample)
    {
        output += srcTexture.read(coords, sample);
    }
    output = output / samples;
    return output;
static inline float4 sRGBtoLinear(float4 color)
    float3 linear1 = color.rgb / 12.92;
    float3 linear2 = pow((color.rgb + float3(0.055)) / 1.055, 2.4);
    float3 factor = float3(color.rgb <= float3(0.04045));
    float4 linear = float4(factor * linear1 + float3(1.0 - factor) * linear2, color.a);
    return linear;
static inline float linearToSRGB(float color)
    if (color <= 0.0f)
        return 0.0f;
    else if (color < 0.0031308f)
        return 12.92f * color;
    else if (color < 1.0f)
        return 1.055f * pow(color, 0.41666f) - 0.055f;
    else
        return 1.0f;
static inline float4 linearToSRGB(float4 color)
    return float4(linearToSRGB(color.r), linearToSRGB(color.g), linearToSRGB(color.b), color.a);
template <typename Short>
static inline Short bytesToShort(constant uchar *input, uint offset)
    Short inputLo = input[offset];
    Short inputHi = input[offset + 1];
    return inputLo | (inputHi << 8);
template <typename Int>
static inline Int bytesToInt(constant uchar *input, uint offset)
    Int input0 = input[offset];
    Int input1 = input[offset + 1];
    Int input2 = input[offset + 2];
    Int input3 = input[offset + 3];
    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
template <typename Short>
static inline void shortToBytes(Short val, uint offset, device uchar *output)
    ushort valUnsigned = as_type<ushort>(val);
    output[offset] = valUnsigned & 0xff;
    output[offset + 1] = (valUnsigned >> 8) & 0xff;
template <typename Int>
static inline void intToBytes(Int val, uint offset, device uchar *output)
    uint valUnsigned = as_type<uint>(val);
    output[offset] = valUnsigned & 0xff;
    output[offset + 1] = (valUnsigned >> 8) & 0xff;
    output[offset + 2] = (valUnsigned >> 16) & 0xff;
    output[offset + 3] = (valUnsigned >> 24) & 0xff;
static inline void floatToBytes(float val, uint offset, device uchar *output)
    intToBytes(as_type<uint>(val), offset, output);
static inline void int24bitToBytes(uint val, uint offset, device uchar *output)
    output[offset] = val & 0xff;
    output[offset + 1] = (val >> 8) & 0xff;
    output[offset + 2] = (val >> 16) & 0xff;
template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
static inline T getShiftedData(T input)
    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
                  "T must have at least as many bits as inputBitCount + inputBitStart.");
    const T mask = (1 << inputBitCount) - 1;
    return (input >> inputBitStart) & mask;
template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
static inline T shiftData(T input)
    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
                  "T must have at least as many bits as inputBitCount + inputBitStart.");
    const T mask = (1 << inputBitCount) - 1;
    return (input & mask) << inputBitStart;
template <unsigned int inputBitCount, typename T>
static inline float normalizedToFloat(T input)
    static_assert(inputBitCount <= (sizeof(T) * 8),
                  "T must have more bits than or same bits as inputBitCount.");
    static_assert(inputBitCount <= 23, "Only single precision is supported");
    constexpr float inverseMax = 1.0f / ((1 << inputBitCount) - 1);
    return input * inverseMax;
template <typename T>
static inline float normalizedToFloat(T input)
    return normalizedToFloat<sizeof(T) * 8, T>(input);
template <>
inline float normalizedToFloat(short input)
    constexpr float inverseMax = 1.0f / 0x7fff;
    return static_cast<float>(input) * inverseMax;
template <>
inline float normalizedToFloat(int input)
    constexpr float inverseMax = 1.0f / 0x7fffffff;
    return static_cast<float>(input) * inverseMax;
template <>
inline float normalizedToFloat(uint input)
    constexpr float inverseMax = 1.0f / 0xffffffff;
    return static_cast<float>(input) * inverseMax;
template <unsigned int outputBitCount, typename T>
static inline T floatToNormalized(float input)
    static_assert(outputBitCount <= (sizeof(T) * 8),
                  "T must have more bits than or same bits as inputBitCount.");
    static_assert(outputBitCount <= 23, "Only single precision is supported");
    return static_cast<T>(((1 << outputBitCount) - 1) * input + 0.5f);
template <typename T>
static inline T floatToNormalized(float input)
    return floatToNormalized<sizeof(T) * 8, T>(input);
# 9 "./blit.metal" 2
using namespace rx::mtl_shader;
constant bool kPremultiplyAlpha [[function_constant(1)]];
constant bool kUnmultiplyAlpha [[function_constant(2)]];
constant int kSourceTextureType [[function_constant(3)]];
constant int kSourceTexture2Type [[function_constant(4)]];
constant bool kSourceTextureType2D = kSourceTextureType == kTextureType2D;
constant bool kSourceTextureType2DArray = kSourceTextureType == kTextureType2DArray;
constant bool kSourceTextureType2DMS = kSourceTextureType == kTextureType2DMultisample;
constant bool kSourceTextureTypeCube = kSourceTextureType == kTextureTypeCube;
constant bool kSourceTextureType3D = kSourceTextureType == kTextureType3D;
constant bool kSourceTexture2Type2D = kSourceTexture2Type == kTextureType2D;
constant bool kSourceTexture2Type2DArray = kSourceTexture2Type == kTextureType2DArray;
constant bool kSourceTexture2Type2DMS = kSourceTexture2Type == kTextureType2DMultisample;
constant bool kSourceTexture2TypeCube = kSourceTexture2Type == kTextureTypeCube;
struct BlitParams
    float2 srcTexCoords[3];
    int srcLevel;
    int srcLayer;
    bool dstFlipViewportX;
    bool dstFlipViewportY;
    bool dstLuminance;
struct BlitVSOut
    float4 position [[position]];
    float2 texCoords [[user(locn1)]];
vertex BlitVSOut blitVS(unsigned int vid [[vertex_id]], constant BlitParams &options [[buffer(0)]])
    BlitVSOut output;
    output.position = float4(gCorners[vid], 0.0, 1.0);
    output.texCoords = options.srcTexCoords[vid];
    if (options.dstFlipViewportX)
    {
        output.position.x = -output.position.x;
    }
    if (!options.dstFlipViewportY)
    {
        output.position.y = -output.position.y;
    }
    return output;
template <typename SrcTexture2d>
static uint2 getImageCoords(SrcTexture2d srcTexture, float2 texCoords)
    uint2 dimens(srcTexture.get_width(), srcTexture.get_height());
    uint2 coords = uint2(texCoords * float2(dimens));
    return coords;
template <typename T>
static inline vec<T, 4> blitSampleTextureMS(texture2d_ms<T> srcTexture, float2 texCoords)
    uint2 coords = getImageCoords(srcTexture, texCoords);
    return resolveTextureMS(srcTexture, coords);
template <typename T>
static inline vec<T, 4> blitSampleTexture3D(texture3d<T> srcTexture,
                                            sampler textureSampler,
                                            float2 texCoords,
                                            constant BlitParams &options)
    uint depth = srcTexture.get_depth(options.srcLevel);
    float zCoord = (float(options.srcLayer) + 0.5) / float(depth);
    return srcTexture.sample(textureSampler, float3(texCoords, zCoord), level(options.srcLevel));
# 112 "./blit.metal"
template <typename T>
static inline vec<T, 4> blitReadTexture(BlitVSOut input [[stage_in]], texture2d<T> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<T> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<T> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<T> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<T> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
    vec<T, 4> output;
    switch (kSourceTextureType)
    {
        case kTextureType2D:
            output = srcTexture2d.sample(textureSampler, input.texCoords, level(options.srcLevel));
            break;
        case kTextureType2DArray:
            output = srcTexture2dArray.sample(textureSampler, input.texCoords, options.srcLayer,
                                              level(options.srcLevel));
            break;
        case kTextureType2DMultisample:
            output = blitSampleTextureMS(srcTexture2dMS, input.texCoords);
            break;
        case kTextureTypeCube:
            output = srcTextureCube.sample(textureSampler,
                                           cubeTexcoords(input.texCoords, options.srcLayer),
                                           level(options.srcLevel));
            break;
        case kTextureType3D:
            output = blitSampleTexture3D(srcTexture3d, textureSampler, input.texCoords, options);
            break;
    }
    if (kPremultiplyAlpha)
    {
        output.xyz *= output.a;
    }
    else if (kUnmultiplyAlpha)
    {
        if (output.a != 0.0)
        {
            output.xyz /= output.a;
        }
    }
    if (options.dstLuminance)
    {
        output.g = output.b = output.r;
    }
    return output;
template <typename T>
static inline MultipleColorOutputs<T> blitFS(BlitVSOut input [[stage_in]], texture2d<T> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<T> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<T> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<T> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<T> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
    vec<T, 4> output = blitReadTexture(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
    return toMultipleColorOutputs(output);
fragment MultipleColorOutputs<float> blitFloatFS(BlitVSOut input [[stage_in]], texture2d<float> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<float> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<float> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<float> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<float> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
fragment MultipleColorOutputs<int> blitIntFS(BlitVSOut input [[stage_in]], texture2d<int> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<int> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<int> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<int> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<int> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
fragment MultipleColorOutputs<uint> blitUIntFS(BlitVSOut input [[stage_in]], texture2d<uint> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<uint> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<uint> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<uint> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<uint> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
fragment MultipleColorOutputs<uint> copyTextureFloatToUIntFS(BlitVSOut input [[stage_in]], texture2d<float> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<float> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<float> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<float> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<float> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
    float4 inputColor = blitReadTexture<>(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
    uint4 output = uint4(inputColor * float4(255.0));
    return toMultipleColorOutputs(output);
struct FragmentDepthOut
    float depth [[depth(any)]];
static inline float sampleDepth(
    texture2d<float> srcTexture2d [[function_constant(kSourceTextureType2D)]],
    texture2d_array<float> srcTexture2dArray [[function_constant(kSourceTextureType2DArray)]],
    texture2d_ms<float> srcTexture2dMS [[function_constant(kSourceTextureType2DMS)]],
    texturecube<float> srcTextureCube [[function_constant(kSourceTextureTypeCube)]],
    float2 texCoords,
    constant BlitParams &options)
    float4 output;
    constexpr sampler textureSampler(mag_filter::nearest, min_filter::nearest);
    switch (kSourceTextureType)
    {
        case kTextureType2D:
            output = srcTexture2d.sample(textureSampler, texCoords, level(options.srcLevel));
            break;
        case kTextureType2DArray:
            output = srcTexture2dArray.sample(textureSampler, texCoords, options.srcLayer,
                                              level(options.srcLevel));
            break;
        case kTextureType2DMultisample:
            output = srcTexture2dMS.read(getImageCoords(srcTexture2dMS, texCoords), 0);
            break;
        case kTextureTypeCube:
            output =
                srcTextureCube.sample(textureSampler, cubeTexcoords(texCoords, options.srcLayer),
                                      level(options.srcLevel));
            break;
    }
    return output.r;
fragment FragmentDepthOut blitDepthFS(BlitVSOut input [[stage_in]],
                                      texture2d<float> srcTexture2d
                                      [[texture(0), function_constant(kSourceTextureType2D)]],
                                      texture2d_array<float> srcTexture2dArray
                                      [[texture(0), function_constant(kSourceTextureType2DArray)]],
                                      texture2d_ms<float> srcTexture2dMS
                                      [[texture(0), function_constant(kSourceTextureType2DMS)]],
                                      texturecube<float> srcTextureCube
                                      [[texture(0), function_constant(kSourceTextureTypeCube)]],
                                      constant BlitParams &options [[buffer(0)]])
    FragmentDepthOut re;
    re.depth = sampleDepth(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
                           input.texCoords, options);
    return re;
static inline uint32_t sampleStencil(
    texture2d<uint32_t> srcTexture2d [[function_constant(kSourceTexture2Type2D)]],
    texture2d_array<uint32_t> srcTexture2dArray [[function_constant(kSourceTexture2Type2DArray)]],
    texture2d_ms<uint32_t> srcTexture2dMS [[function_constant(kSourceTexture2Type2DMS)]],
    texturecube<uint32_t> srcTextureCube [[function_constant(kSourceTexture2TypeCube)]],
    float2 texCoords,
    int srcLevel,
    int srcLayer)
    uint4 output;
    constexpr sampler textureSampler(mag_filter::nearest, min_filter::nearest);
    switch (kSourceTexture2Type)
    {
        case kTextureType2D:
            output = srcTexture2d.sample(textureSampler, texCoords, level(srcLevel));
            break;
        case kTextureType2DArray:
            output = srcTexture2dArray.sample(textureSampler, texCoords, srcLayer, level(srcLevel));
            break;
        case kTextureType2DMultisample:
            output = srcTexture2dMS.read(getImageCoords(srcTexture2dMS, texCoords), 0);
            break;
        case kTextureTypeCube:
            output = srcTextureCube.sample(textureSampler, cubeTexcoords(texCoords, srcLayer),
                                           level(srcLevel));
            break;
    }
    return output.r;
struct BlitStencilToBufferParams
    float2 srcStartTexCoords;
    float2 srcTexCoordSteps;
    int srcLevel;
    int srcLayer;
    uint2 dstSize;
    uint dstBufferRowPitch;
    bool resolveMS;
kernel void blitStencilToBufferCS(ushort2 gIndices [[thread_position_in_grid]],
                                  texture2d<uint32_t> srcTexture2d
                                  [[texture(1), function_constant(kSourceTexture2Type2D)]],
                                  texture2d_array<uint32_t> srcTexture2dArray
                                  [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
                                  texture2d_ms<uint32_t> srcTexture2dMS
                                  [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
                                  texturecube<uint32_t> srcTextureCube
                                  [[texture(1), function_constant(kSourceTexture2TypeCube)]],
                                  constant BlitStencilToBufferParams &options [[buffer(0)]],
                                  device uchar *buffer [[buffer(1)]])
    if (gIndices.x >= options.dstSize.x || gIndices.y >= options.dstSize.y)
    {
        return;
    }
    float2 srcTexCoords = options.srcStartTexCoords + float2(gIndices) * options.srcTexCoordSteps;
    if (kSourceTexture2Type == kTextureType2DMultisample && !options.resolveMS)
    {
        uint samples = srcTexture2dMS.get_num_samples();
        uint2 imageCoords = getImageCoords(srcTexture2dMS, srcTexCoords);
        uint bufferOffset = options.dstBufferRowPitch * gIndices.y + samples * gIndices.x;
        for (uint sample = 0; sample < samples; ++sample)
        {
            uint stencilPerSample = srcTexture2dMS.read(imageCoords, sample).r;
            buffer[bufferOffset + sample] = static_cast<uchar>(stencilPerSample);
        }
    }
    else
    {
        uint32_t stencil =
            sampleStencil(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
                          srcTexCoords, options.srcLevel, options.srcLayer);
        buffer[options.dstBufferRowPitch * gIndices.y + gIndices.x] = static_cast<uchar>(stencil);
    }
#if __METAL_VERSION__ >= 210
struct FragmentStencilOut
    uint32_t stencil [[stencil]];
struct FragmentDepthStencilOut
    float depth [[depth(any)]];
    uint32_t stencil [[stencil]];
fragment FragmentStencilOut blitStencilFS(
    BlitVSOut input [[stage_in]],
    texture2d<uint32_t> srcTexture2d [[texture(1), function_constant(kSourceTexture2Type2D)]],
    texture2d_array<uint32_t> srcTexture2dArray
    [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
    texture2d_ms<uint32_t> srcTexture2dMS
    [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
    texturecube<uint32_t> srcTextureCube [[texture(1), function_constant(kSourceTexture2TypeCube)]],
    constant BlitParams &options [[buffer(0)]])
    FragmentStencilOut re;
    re.stencil = sampleStencil(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
                               input.texCoords, options.srcLevel, options.srcLayer);
    return re;
fragment FragmentDepthStencilOut blitDepthStencilFS(
    BlitVSOut input [[stage_in]],
    texture2d<float> srcDepthTexture2d [[texture(0), function_constant(kSourceTextureType2D)]],
    texture2d_array<float> srcDepthTexture2dArray
    [[texture(0), function_constant(kSourceTextureType2DArray)]],
    texture2d_ms<float> srcDepthTexture2dMS
    [[texture(0), function_constant(kSourceTextureType2DMS)]],
    texturecube<float> srcDepthTextureCube
    [[texture(0), function_constant(kSourceTextureTypeCube)]],
    texture2d<uint32_t> srcStencilTexture2d
    [[texture(1), function_constant(kSourceTexture2Type2D)]],
    texture2d_array<uint32_t> srcStencilTexture2dArray
    [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
    texture2d_ms<uint32_t> srcStencilTexture2dMS
    [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
    texturecube<uint32_t> srcStencilTextureCube
    [[texture(1), function_constant(kSourceTexture2TypeCube)]],
    constant BlitParams &options [[buffer(0)]])
    FragmentDepthStencilOut re;
    re.depth = sampleDepth(srcDepthTexture2d, srcDepthTexture2dArray, srcDepthTexture2dMS,
                           srcDepthTextureCube, input.texCoords, options);
    re.stencil =
        sampleStencil(srcStencilTexture2d, srcStencilTexture2dArray, srcStencilTexture2dMS,
                      srcStencilTextureCube, input.texCoords, options.srcLevel, options.srcLayer);
    return re;
#endif
# 2 "temp_master_source.metal" 2
# 1 "./clear.metal" 1
# 10 "./clear.metal"
using namespace rx::mtl_shader;
struct ClearParams
    float4 clearColor;
    float clearDepth;
vertex float4 clearVS(unsigned int vid [[ vertex_id ]],
                      constant ClearParams &clearParams [[buffer(0)]])
    return float4(gCorners[vid], clearParams.clearDepth, 1.0);
fragment MultipleColorOutputs<float> clearFloatFS(constant ClearParams &clearParams [[buffer(0)]])
    return toMultipleColorOutputs(clearParams.clearColor);
fragment MultipleColorOutputs<int> clearIntFS(constant ClearParams &clearParams [[buffer(0)]])
    return toMultipleColorOutputs(as_type<int4>(clearParams.clearColor));
fragment MultipleColorOutputs<uint> clearUIntFS(constant ClearParams &clearParams [[buffer(0)]])
    return toMultipleColorOutputs(as_type<uint4>(clearParams.clearColor));
# 3 "temp_master_source.metal" 2
# 1 "./gen_indices.metal" 1
using namespace rx::mtl_shader;
constant bool kSourceBufferAligned[[function_constant(100)]];
constant bool kSourceIndexIsU8[[function_constant(200)]];
constant bool kSourceIndexIsU16[[function_constant(300)]];
constant bool kSourceIndexIsU32[[function_constant(400)]];
constant bool kSourceBufferUnaligned = !kSourceBufferAligned;
constant bool kUseSourceBufferU8 = kSourceIndexIsU8 || kSourceBufferUnaligned;
constant bool kUseSourceBufferU16 = kSourceIndexIsU16 && kSourceBufferAligned;
constant bool kUseSourceBufferU32 = kSourceIndexIsU32 && kSourceBufferAligned;
struct IndexConversionParams
    uint32_t srcOffset;
    uint32_t indexCount;
    bool primitiveRestartEnabled;
inline ushort getIndexAligned(constant ushort *inputAligned, uint offset, uint idx)
    return inputAligned[offset / 2 + idx];
inline uint getIndexAligned(constant uint *inputAligned, uint offset, uint idx)
    return inputAligned[offset / 4 + idx];
inline uchar getIndexAligned(constant uchar *input, uint offset, uint idx)
    return input[offset + idx];
inline ushort getIndexUnalignedU16(constant uchar *input, uint offset, uint idx)
    ushort inputLo = input[offset + 2 * idx];
    ushort inputHi = input[offset + 2 * idx + 1];
    return inputLo | (inputHi << 8);
inline uint getIndexUnalignedU32(constant uchar *input, uint offset, uint idx)
    uint input0 = input[offset + 4 * idx];
    uint input1 = input[offset + 4 * idx + 1];
    uint input2 = input[offset + 4 * idx + 2];
    uint input3 = input[offset + 4 * idx + 3];
    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
kernel void convertIndexU8ToU16(uint idx[[thread_position_in_grid]],
                                constant IndexConversionParams &options[[buffer(0)]],
                                constant uchar *input[[buffer(1)]],
                                device ushort *output[[buffer(2)]])
    if (idx >= options.indexCount) { return; };
    uchar value = getIndexAligned(input, options.srcOffset, idx);
    if (options.primitiveRestartEnabled && value == 0xff)
    {
        output[idx] = 0xffff;
    }
    else
    {
        output[idx] = value;
    }
kernel void convertIndexU16(
    uint idx[[thread_position_in_grid]],
    constant IndexConversionParams &options[[buffer(0)]],
    constant uchar *input[[ buffer(1), function_constant(kSourceBufferUnaligned) ]],
    constant ushort *inputAligned[[ buffer(1), function_constant(kSourceBufferAligned) ]],
    device ushort *output[[buffer(2)]])
    if (idx >= options.indexCount) { return; };
    ushort value;
    if (kSourceBufferAligned)
    {
        value = getIndexAligned(inputAligned, options.srcOffset, idx);
    }
    else
    {
        value = getIndexUnalignedU16(input, options.srcOffset, idx);
    }
    output[idx] = value;
kernel void convertIndexU32(
    uint idx[[thread_position_in_grid]],
    constant IndexConversionParams &options[[buffer(0)]],
    constant uchar *input[[ buffer(1), function_constant(kSourceBufferUnaligned) ]],
    constant uint *inputAligned[[ buffer(1), function_constant(kSourceBufferAligned) ]],
    device uint *output[[buffer(2)]])
    if (idx >= options.indexCount) { return; };
    uint value;
    if (kSourceBufferAligned)
    {
        value = getIndexAligned(inputAligned, options.srcOffset, idx);
    }
    else
    {
        value = getIndexUnalignedU32(input, options.srcOffset, idx);
    }
    output[idx] = value;
struct IndexFromArrayParams
    uint firstVertex;
    uint vertexCount;
kernel void genTriFanIndicesFromArray(uint idx [[thread_position_in_grid]],
                                      constant IndexFromArrayParams &options [[buffer(0)]],
                                      device uint *output [[buffer(2)]])
    if (idx >= options.vertexCount) { return; };
    uint vertexIdx = options.firstVertex + 2 + idx;
    output[3 * idx] = options.firstVertex;
    output[3 * idx + 1] = vertexIdx - 1;
    output[3 * idx + 2] = vertexIdx;
inline uint getIndexU32(uint offset,
                        uint idx,
                        constant uchar *inputU8[[function_constant(kUseSourceBufferU8)]],
                        constant ushort *inputU16[[function_constant(kUseSourceBufferU16)]],
                        constant uint *inputU32[[function_constant(kUseSourceBufferU32)]])
    if (kUseSourceBufferU8)
    {
        if (kSourceIndexIsU16)
        {
            return getIndexUnalignedU16(inputU8, offset, idx);
        }
        else if (kSourceIndexIsU32)
        {
            return getIndexUnalignedU32(inputU8, offset, idx);
        }
        return getIndexAligned(inputU8, offset, idx);
    }
    else if (kUseSourceBufferU16)
    {
        return getIndexAligned(inputU16, offset, idx);
    }
    else if (kUseSourceBufferU32)
    {
        return getIndexAligned(inputU32, offset, idx);
    }
    return 0;
kernel void genTriFanIndicesFromElements(
    uint idx[[thread_position_in_grid]],
    constant IndexConversionParams &options[[buffer(0)]],
    constant uchar *inputU8[[ buffer(1), function_constant(kUseSourceBufferU8) ]],
    constant ushort *inputU16[[ buffer(1), function_constant(kUseSourceBufferU16) ]],
    constant uint *inputU32[[ buffer(1), function_constant(kUseSourceBufferU32) ]],
    device uint *output[[buffer(2)]])
    if (idx >= options.indexCount) { return; };
    uint elemIdx = 2 + idx;
    output[3 * idx] = getIndexU32(options.srcOffset, 0, inputU8, inputU16, inputU32);
    output[3 * idx + 1] = getIndexU32(options.srcOffset, elemIdx - 1, inputU8, inputU16, inputU32);
    output[3 * idx + 2] = getIndexU32(options.srcOffset, elemIdx, inputU8, inputU16, inputU32);
kernel void genLineLoopIndicesFromArray(uint idx [[thread_position_in_grid]],
                                        constant IndexFromArrayParams &options [[buffer(0)]],
                                        device uint *output [[buffer(2)]])
    uint totalIndices = options.vertexCount + 1;
    if (idx >= totalIndices) { return; };
    output[idx] = options.firstVertex + idx % options.vertexCount;
kernel void genLineLoopIndicesFromElements(uint idx [[thread_position_in_grid]],
                                           constant IndexConversionParams &options [[buffer(0)]],
                                           constant uchar *inputU8
                                           [[buffer(1), function_constant(kUseSourceBufferU8)]],
                                           constant ushort *inputU16
                                           [[buffer(1), function_constant(kUseSourceBufferU16)]],
                                           constant uint *inputU32
                                           [[buffer(1), function_constant(kUseSourceBufferU32)]],
                                           device uint *output [[buffer(2)]])
    uint totalTargetIndices = options.indexCount + 1;
    if (idx >= totalTargetIndices) { return; };
    output[idx] =
        getIndexU32(options.srcOffset, idx % options.indexCount, inputU8, inputU16, inputU32);
# 4 "temp_master_source.metal" 2
# 1 "./gen_mipmap.metal" 1
using namespace rx::mtl_shader;
# 31 "./gen_mipmap.metal"
struct GenMipParams
    uint srcLevel;
    uint numMipLevelsToGen;
    bool sRGB;
kernel void generate3DMipmaps(uint lIndex [[thread_index_in_threadgroup]],
                              ushort3 gIndices [[thread_position_in_grid]],
                              texture3d<float> srcTexture [[texture(0)]],
                              texture3d<float, access::write> dstMip1 [[texture(1)]],
                              texture3d<float, access::write> dstMip2 [[texture(2)]],
                              texture3d<float, access::write> dstMip3 [[texture(3)]],
                              texture3d<float, access::write> dstMip4 [[texture(4)]],
                              constant GenMipParams &options [[buffer(0)]])
    ushort3 mipSize = ushort3(dstMip1.get_width(), dstMip1.get_height(), dstMip1.get_depth());
    bool validThread = gIndices.x < mipSize.x && gIndices.y < mipSize.y && gIndices.z < mipSize.z;
    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
    threadgroup float sR[(8 * 8 * 8)];
    threadgroup float sG[(8 * 8 * 8)];
    threadgroup float sB[(8 * 8 * 8)];
    threadgroup float sA[(8 * 8 * 8)];
    float4 texel1;
    if (validThread)
    {
        float3 texCoords = (float3(gIndices) + float3(0.5, 0.5, 0.5)) / float3(mipSize);
        texel1 = srcTexture.sample(textureSampler, texCoords, level(options.srcLevel));
        dstMip1.write(texel1, gIndices);
    }
    else
    {
        lIndex = 0xffffffff;
    }
    if (options.numMipLevelsToGen == 1)
    {
        return;
    }
    if (options.sRGB)
    {
        texel1 = linearToSRGB(texel1);
    }
    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if ((lIndex & 0x49) == 0)
    {
        bool3 atEdge = gIndices == (mipSize - ushort3(1));
        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
        float4 texel4 = (atEdge.z) ? (texel1) : (float4(sR[lIndex + (8 * 8)], sG[lIndex + (8 * 8)], sB[lIndex + (8 * 8)], sA[lIndex + (8 * 8)]));
        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + ((8 * 8) + 1)], sG[lIndex + ((8 * 8) + 1)], sB[lIndex + ((8 * 8) + 1)], sA[lIndex + ((8 * 8) + 1)]));
        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + ((8 * 8) + 8)], sG[lIndex + ((8 * 8) + 8)], sB[lIndex + ((8 * 8) + 8)], sA[lIndex + ((8 * 8) + 8)]));
        float4 texel8 =
            (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + ((8 * 8) + 8 + 1)], sG[lIndex + ((8 * 8) + 8 + 1)], sB[lIndex + ((8 * 8) + 8 + 1)], sA[lIndex + ((8 * 8) + 8 + 1)]));
        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 1);
        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
    }
    if (options.numMipLevelsToGen == 2)
    {
        return;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if ((lIndex & 0xdb) == 0)
    {
        mipSize = max(mipSize >> 1, ushort3(1));
        bool3 atEdge = (gIndices >> 1) == (mipSize - ushort3(1));
        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
        float4 texel3 =
            (atEdge.y) ? (texel1) : (float4(sR[lIndex + (2 * 8)], sG[lIndex + (2 * 8)], sB[lIndex + (2 * 8)], sA[lIndex + (2 * 8)]));
        float4 texel4 =
            (atEdge.z) ? (texel1) : (float4(sR[lIndex + (2 * (8 * 8))], sG[lIndex + (2 * (8 * 8))], sB[lIndex + (2 * (8 * 8))], sA[lIndex + (2 * (8 * 8))]));
        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + (2 * (8 * 8) + 2)], sG[lIndex + (2 * (8 * 8) + 2)], sB[lIndex + (2 * (8 * 8) + 2)], sA[lIndex + (2 * (8 * 8) + 2)]));
        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + (2 * (8 * 8) + 2 * 8)], sG[lIndex + (2 * (8 * 8) + 2 * 8)], sB[lIndex + (2 * (8 * 8) + 2 * 8)], sA[lIndex + (2 * (8 * 8) + 2 * 8)]));
        float4 texel8 = (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sG[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sB[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sA[lIndex + (2 * (8 * 8) + 2 * 8 + 2)]));
        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 2);
        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
    }
    if (options.numMipLevelsToGen == 3)
    {
        return;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if ((lIndex & 0x1ff) == 0)
    {
        mipSize = max(mipSize >> 1, ushort3(1));
        bool3 atEdge = (gIndices >> 2) == (mipSize - ushort3(1));
        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
        float4 texel3 =
            (atEdge.y) ? (texel1) : (float4(sR[lIndex + (4 * 8)], sG[lIndex + (4 * 8)], sB[lIndex + (4 * 8)], sA[lIndex + (4 * 8)]));
        float4 texel4 =
            (atEdge.z) ? (texel1) : (float4(sR[lIndex + (4 * (8 * 8))], sG[lIndex + (4 * (8 * 8))], sB[lIndex + (4 * (8 * 8))], sA[lIndex + (4 * (8 * 8))]));
        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + (4 * (8 * 8) + 4)], sG[lIndex + (4 * (8 * 8) + 4)], sB[lIndex + (4 * (8 * 8) + 4)], sA[lIndex + (4 * (8 * 8) + 4)]));
        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + (4 * (8 * 8) + 4 * 8)], sG[lIndex + (4 * (8 * 8) + 4 * 8)], sB[lIndex + (4 * (8 * 8) + 4 * 8)], sA[lIndex + (4 * (8 * 8) + 4 * 8)]));
        float4 texel8 = (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sG[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sB[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sA[lIndex + (4 * (8 * 8) + 4 * 8 + 4)]));
        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 3);
    }
# 5 "temp_master_source.metal" 2
# 1 "./copy_buffer.metal" 1
# 12 "./copy_buffer.metal"
#include <metal_pack>
# 1 "./format_autogen.h" 1
# 11 "./format_autogen.h"
namespace rx
namespace mtl_shader
namespace FormatID
enum
    NONE,
    D16_UNORM,
    D24_UNORM_S8_UINT,
    D24_UNORM_X8_UINT,
    D32_FLOAT,
    D32_FLOAT_S8X24_UINT,
    D32_UNORM,
    S8_UINT,
    A16_FLOAT,
    A1R5G5B5_UNORM,
    A2R10G10B10_SINT_VERTEX,
    A2R10G10B10_SNORM_VERTEX,
    A2R10G10B10_SSCALED_VERTEX,
    A2R10G10B10_UINT_VERTEX,
    A2R10G10B10_UNORM_VERTEX,
    A2R10G10B10_USCALED_VERTEX,
    A32_FLOAT,
    A8_UNORM,
    ASTC_10x10_SRGB_BLOCK,
    ASTC_10x10_UNORM_BLOCK,
    ASTC_10x5_SRGB_BLOCK,
    ASTC_10x5_UNORM_BLOCK,
    ASTC_10x6_SRGB_BLOCK,
    ASTC_10x6_UNORM_BLOCK,
    ASTC_10x8_SRGB_BLOCK,
    ASTC_10x8_UNORM_BLOCK,
    ASTC_12x10_SRGB_BLOCK,
    ASTC_12x10_UNORM_BLOCK,
    ASTC_12x12_SRGB_BLOCK,
    ASTC_12x12_UNORM_BLOCK,
    ASTC_3x3x3_UNORM_BLOCK,
    ASTC_3x3x3_UNORM_SRGB_BLOCK,
    ASTC_4x3x3_UNORM_BLOCK,
    ASTC_4x3x3_UNORM_SRGB_BLOCK,
    ASTC_4x4_SRGB_BLOCK,
    ASTC_4x4_UNORM_BLOCK,
    ASTC_4x4x3_UNORM_BLOCK,
    ASTC_4x4x3_UNORM_SRGB_BLOCK,
    ASTC_4x4x4_UNORM_BLOCK,
    ASTC_4x4x4_UNORM_SRGB_BLOCK,
    ASTC_5x4_SRGB_BLOCK,
    ASTC_5x4_UNORM_BLOCK,
    ASTC_5x4x4_UNORM_BLOCK,
    ASTC_5x4x4_UNORM_SRGB_BLOCK,
    ASTC_5x5_SRGB_BLOCK,
    ASTC_5x5_UNORM_BLOCK,
    ASTC_5x5x4_UNORM_BLOCK,
    ASTC_5x5x4_UNORM_SRGB_BLOCK,
    ASTC_5x5x5_UNORM_BLOCK,
    ASTC_5x5x5_UNORM_SRGB_BLOCK,
    ASTC_6x5_SRGB_BLOCK,
    ASTC_6x5_UNORM_BLOCK,
    ASTC_6x5x5_UNORM_BLOCK,
    ASTC_6x5x5_UNORM_SRGB_BLOCK,
    ASTC_6x6_SRGB_BLOCK,
    ASTC_6x6_UNORM_BLOCK,
    ASTC_6x6x5_UNORM_BLOCK,
    ASTC_6x6x5_UNORM_SRGB_BLOCK,
    ASTC_6x6x6_UNORM_BLOCK,
    ASTC_6x6x6_UNORM_SRGB_BLOCK,
    ASTC_8x5_SRGB_BLOCK,
    ASTC_8x5_UNORM_BLOCK,
    ASTC_8x6_SRGB_BLOCK,
    ASTC_8x6_UNORM_BLOCK,
    ASTC_8x8_SRGB_BLOCK,
    ASTC_8x8_UNORM_BLOCK,
    B10G10R10A2_UNORM,
    B4G4R4A4_UNORM,
    B5G5R5A1_UNORM,
    B5G6R5_UNORM,
    B8G8R8A8_TYPELESS,
    B8G8R8A8_TYPELESS_SRGB,
    B8G8R8A8_UNORM,
    B8G8R8A8_UNORM_SRGB,
    B8G8R8X8_UNORM,
    BC1_RGBA_UNORM_BLOCK,
    BC1_RGBA_UNORM_SRGB_BLOCK,
    BC1_RGB_UNORM_BLOCK,
    BC1_RGB_UNORM_SRGB_BLOCK,
    BC2_RGBA_UNORM_BLOCK,
    BC2_RGBA_UNORM_SRGB_BLOCK,
    BC3_RGBA_UNORM_BLOCK,
    BC3_RGBA_UNORM_SRGB_BLOCK,
    BC4_RED_SNORM_BLOCK,
    BC4_RED_UNORM_BLOCK,
    BC5_RG_SNORM_BLOCK,
    BC5_RG_UNORM_BLOCK,
    BPTC_RGBA_UNORM_BLOCK,
    BPTC_RGB_SIGNED_FLOAT_BLOCK,
    BPTC_RGB_UNSIGNED_FLOAT_BLOCK,
    BPTC_SRGB_ALPHA_UNORM_BLOCK,
    EAC_R11G11_SNORM_BLOCK,
    EAC_R11G11_UNORM_BLOCK,
    EAC_R11_SNORM_BLOCK,
    EAC_R11_UNORM_BLOCK,
    ETC1_LOSSY_DECODE_R8G8B8_UNORM_BLOCK,
    ETC1_R8G8B8_UNORM_BLOCK,
    ETC2_R8G8B8A1_SRGB_BLOCK,
    ETC2_R8G8B8A1_UNORM_BLOCK,
    ETC2_R8G8B8A8_SRGB_BLOCK,
    ETC2_R8G8B8A8_UNORM_BLOCK,
    ETC2_R8G8B8_SRGB_BLOCK,
    ETC2_R8G8B8_UNORM_BLOCK,
    L16A16_FLOAT,
    L16_FLOAT,
    L32A32_FLOAT,
    L32_FLOAT,
    L8A8_UNORM,
    L8_UNORM,
    PVRTC1_RGBA_2BPP_UNORM_BLOCK,
    PVRTC1_RGBA_2BPP_UNORM_SRGB_BLOCK,
    PVRTC1_RGBA_4BPP_UNORM_BLOCK,
    PVRTC1_RGBA_4BPP_UNORM_SRGB_BLOCK,
    PVRTC1_RGB_2BPP_UNORM_BLOCK,
    PVRTC1_RGB_2BPP_UNORM_SRGB_BLOCK,
    PVRTC1_RGB_4BPP_UNORM_BLOCK,
    PVRTC1_RGB_4BPP_UNORM_SRGB_BLOCK,
    R10G10B10A2_SINT,
    R10G10B10A2_SNORM,
    R10G10B10A2_SSCALED,
    R10G10B10A2_UINT,
    R10G10B10A2_UNORM,
    R10G10B10A2_USCALED,
    R10G10B10X2_UNORM,
    R11G11B10_FLOAT,
    R16G16B16A16_FLOAT,
    R16G16B16A16_SINT,
    R16G16B16A16_SNORM,
    R16G16B16A16_SSCALED,
    R16G16B16A16_UINT,
    R16G16B16A16_UNORM,
    R16G16B16A16_USCALED,
    R16G16B16_FLOAT,
    R16G16B16_SINT,
    R16G16B16_SNORM,
    R16G16B16_SSCALED,
    R16G16B16_UINT,
    R16G16B16_UNORM,
    R16G16B16_USCALED,
    R16G16_FLOAT,
    R16G16_SINT,
    R16G16_SNORM,
    R16G16_SSCALED,
    R16G16_UINT,
    R16G16_UNORM,
    R16G16_USCALED,
    R16_FLOAT,
    R16_SINT,
    R16_SNORM,
    R16_SSCALED,
    R16_UINT,
    R16_UNORM,
    R16_USCALED,
    R32G32B32A32_FIXED,
    R32G32B32A32_FLOAT,
    R32G32B32A32_SINT,
    R32G32B32A32_SNORM,
    R32G32B32A32_SSCALED,
    R32G32B32A32_UINT,
    R32G32B32A32_UNORM,
    R32G32B32A32_USCALED,
    R32G32B32_FIXED,
    R32G32B32_FLOAT,
    R32G32B32_SINT,
    R32G32B32_SNORM,
    R32G32B32_SSCALED,
    R32G32B32_UINT,
    R32G32B32_UNORM,
    R32G32B32_USCALED,
    R32G32_FIXED,
    R32G32_FLOAT,
    R32G32_SINT,
    R32G32_SNORM,
    R32G32_SSCALED,
    R32G32_UINT,
    R32G32_UNORM,
    R32G32_USCALED,
    R32_FIXED,
    R32_FLOAT,
    R32_SINT,
    R32_SNORM,
    R32_SSCALED,
    R32_UINT,
    R32_UNORM,
    R32_USCALED,
    R4G4B4A4_UNORM,
    R5G5B5A1_UNORM,
    R5G6B5_UNORM,
    R8G8B8A8_SINT,
    R8G8B8A8_SNORM,
    R8G8B8A8_SSCALED,
    R8G8B8A8_TYPELESS,
    R8G8B8A8_TYPELESS_SRGB,
    R8G8B8A8_UINT,
    R8G8B8A8_UNORM,
    R8G8B8A8_UNORM_SRGB,
    R8G8B8A8_USCALED,
    R8G8B8_SINT,
    R8G8B8_SNORM,
    R8G8B8_SSCALED,
    R8G8B8_UINT,
    R8G8B8_UNORM,
    R8G8B8_UNORM_SRGB,
    R8G8B8_USCALED,
    R8G8_SINT,
    R8G8_SNORM,
    R8G8_SSCALED,
    R8G8_UINT,
    R8G8_UNORM,
    R8G8_USCALED,
    R8_SINT,
    R8_SNORM,
    R8_SSCALED,
    R8_UINT,
    R8_UNORM,
    R8_UNORM_SRGB,
    R8_USCALED,
    R9G9B9E5_SHAREDEXP,
    X2R10G10B10_SINT_VERTEX,
    X2R10G10B10_SNORM_VERTEX,
    X2R10G10B10_SSCALED_VERTEX,
    X2R10G10B10_UINT_VERTEX,
    X2R10G10B10_UNORM_VERTEX,
    X2R10G10B10_USCALED_VERTEX
# 16 "./copy_buffer.metal" 2
using namespace rx::mtl_shader;
constant int kCopyFormatType [[function_constant(10)]];
constant int kCopyTextureType [[function_constant(20)]];
constant bool kCopyTextureType2D = kCopyTextureType == kTextureType2D;
constant bool kCopyTextureType2DArray = kCopyTextureType == kTextureType2DArray;
constant bool kCopyTextureType2DMS = kCopyTextureType == kTextureType2DMultisample;
constant bool kCopyTextureTypeCube = kCopyTextureType == kTextureTypeCube;
constant bool kCopyTextureType3D = kCopyTextureType == kTextureType3D;
struct CopyPixelParams
    uint3 copySize;
    uint3 textureOffset;
    uint bufferStartOffset;
    uint pixelSize;
    uint bufferRowPitch;
    uint bufferDepthPitch;
struct WritePixelParams
    uint2 copySize;
    uint2 textureOffset;
    uint bufferStartOffset;
    uint pixelSize;
    uint bufferRowPitch;
    uint textureLevel;
    uint textureLayer;
    bool reverseTextureRowOrder;
# 120 "./copy_buffer.metal"
template <typename T>
static inline void textureWrite(ushort3 gIndices,
                                constant CopyPixelParams &options,
                                vec<T, 4> color,
                                texture2d<T, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<T, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<T, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<T, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
    uint3 writeIndices = options.textureOffset + uint3(gIndices);
    switch (kCopyTextureType)
    {
        case kTextureType2D:
            dstTexture2d.write(color, writeIndices.xy);
            break;
        case kTextureType2DArray:
            dstTexture2dArray.write(color, writeIndices.xy, writeIndices.z);
            break;
        case kTextureType3D:
            dstTexture3d.write(color, writeIndices);
            break;
        case kTextureTypeCube:
            dstTextureCube.write(color, writeIndices.xy, writeIndices.z);
            break;
    }
template <typename T>
static inline vec<T, 4> textureRead(ushort2 gIndices,
                                    constant WritePixelParams &options,
                                    texture2d<T, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<T, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<T, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<T, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<T, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]])
    vec<T, 4> color;
    uint2 coords = uint2(gIndices);
    if (options.reverseTextureRowOrder)
    {
        coords.y = options.copySize.y - 1 - gIndices.y;
    }
    coords += options.textureOffset;
    switch (kCopyTextureType)
    {
        case kTextureType2D:
            color = srcTexture2d.read(coords.xy, options.textureLevel);
            break;
        case kTextureType2DArray:
            color = srcTexture2dArray.read(coords.xy, options.textureLayer, options.textureLevel);
            break;
        case kTextureType2DMultisample:
            color = resolveTextureMS(srcTexture2dMS, coords.xy);
            break;
        case kTextureType3D:
            color = srcTexture3d.read(uint3(coords, options.textureLayer), options.textureLevel);
            break;
        case kTextureTypeCube:
            color = srcTextureCube.read(coords.xy, options.textureLayer, options.textureLevel);
            break;
    }
    return color;
# 215 "./copy_buffer.metal"
static inline float4 readR5G6B5_UNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
    color.r = normalizedToFloat<5>(getShiftedData<5, 11>(src));
    color.g = normalizedToFloat<6>(getShiftedData<6, 5>(src));
    color.b = normalizedToFloat<5>(getShiftedData<5, 0>(src));
    color.a = 1.0;
    return color;
static inline void writeR5G6B5_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    ushort dst = shiftData<5, 11>(floatToNormalized<5, ushort>(color.r)) |
                 shiftData<6, 5>(floatToNormalized<6, ushort>(color.g)) |
                 shiftData<5, 0>(floatToNormalized<5, ushort>(color.b));
    shortToBytes(dst, bufferOffset, buffer);
static inline float4 readR4G4B4A4_UNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
    color.r = normalizedToFloat<4>(getShiftedData<4, 12>(src));
    color.g = normalizedToFloat<4>(getShiftedData<4, 8>(src));
    color.b = normalizedToFloat<4>(getShiftedData<4, 4>(src));
    color.a = normalizedToFloat<4>(getShiftedData<4, 0>(src));
    return color;
static inline void writeR4G4B4A4_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    ushort dst = shiftData<4, 12>(floatToNormalized<4, ushort>(color.r)) |
                 shiftData<4, 8>(floatToNormalized<4, ushort>(color.g)) |
                 shiftData<4, 4>(floatToNormalized<4, ushort>(color.b)) |
                 shiftData<4, 0>(floatToNormalized<4, ushort>(color.a));
    ;
    shortToBytes(dst, bufferOffset, buffer);
static inline float4 readR5G5B5A1_UNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
    color.r = normalizedToFloat<5>(getShiftedData<5, 11>(src));
    color.g = normalizedToFloat<5>(getShiftedData<5, 6>(src));
    color.b = normalizedToFloat<5>(getShiftedData<5, 1>(src));
    color.a = normalizedToFloat<1>(getShiftedData<1, 0>(src));
    return color;
static inline void writeR5G5B5A1_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    ushort dst = shiftData<5, 11>(floatToNormalized<5, ushort>(color.r)) |
                 shiftData<5, 6>(floatToNormalized<5, ushort>(color.g)) |
                 shiftData<5, 1>(floatToNormalized<5, ushort>(color.b)) |
                 shiftData<1, 0>(floatToNormalized<1, ushort>(color.a));
    ;
    shortToBytes(dst, bufferOffset, buffer);
static inline int4 readR10G10B10A2_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    int src = bytesToInt<int>(buffer, bufferOffset);
    constexpr int3 rgbSignMask(0x200);
    constexpr int3 negativeMask(0xfffffc00);
    constexpr int alphaSignMask = 0x2;
    constexpr int alphaNegMask = 0xfffffffc;
    color.r = getShiftedData<10, 0>(src);
    color.g = getShiftedData<10, 10>(src);
    color.b = getShiftedData<10, 20>(src);
    int3 isRgbNegative = (color.rgb & rgbSignMask) >> 9;
    color.rgb = (isRgbNegative * negativeMask) | color.rgb;
    color.a = getShiftedData<2, 30>(src);
    int isAlphaNegative = color.a & alphaSignMask >> 1;
    color.a = (isAlphaNegative * alphaNegMask) | color.a;
    return color;
static inline uint4 readR10G10B10A2_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    uint src = bytesToInt<uint>(buffer, bufferOffset);
    color.r = getShiftedData<10, 0>(src);
    color.g = getShiftedData<10, 10>(src);
    color.b = getShiftedData<10, 20>(src);
    color.a = getShiftedData<2, 30>(src);
    return color;
static inline float4 readR8G8B8A8(uint bufferOffset, constant uchar *buffer, bool isSRGB)
    float4 color;
    uint src = bytesToInt<uint>(buffer, bufferOffset);
    if (isSRGB)
    {
        color = unpack_unorm4x8_srgb_to_float(src);
    }
    else
    {
        color = unpack_unorm4x8_to_float(src);
    }
    return color;
static inline void writeR8G8B8A8(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer, bool isSRGB)
    uint dst;
    if (isSRGB)
    {
        dst = pack_float_to_srgb_unorm4x8(color);
    }
    else
    {
        dst = pack_float_to_unorm4x8(color);
    }
    intToBytes(dst, bufferOffset, buffer);
static inline float4 readR8G8B8(uint bufferOffset, constant uchar *buffer, bool isSRGB)
    float4 color;
    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
    color.g = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
    color.b = normalizedToFloat<uchar>(buffer[bufferOffset + 2]);
    color.a = 1.0;
    if (isSRGB)
    {
        color = sRGBtoLinear(color);
    }
    return color;
static inline void writeR8G8B8(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer, bool isSRGB)
    color.a = 1.0;
    uint dst;
    if (isSRGB)
    {
        dst = pack_float_to_srgb_unorm4x8(color);
    }
    else
    {
        dst = pack_float_to_unorm4x8(color);
    }
    int24bitToBytes(dst, bufferOffset, buffer);
static inline float4 readR8G8B8A8_SNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    uint src = bytesToInt<uint>(buffer, bufferOffset);
    color = unpack_snorm4x8_to_float(src);
    return color;
static inline void writeR8G8B8A8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    uint dst = pack_float_to_snorm4x8(color);
    intToBytes(dst, bufferOffset, buffer);
static inline float4 readR8G8B8_SNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
    color.g = normalizedToFloat<7, char>(buffer[bufferOffset + 1]);
    color.b = normalizedToFloat<7, char>(buffer[bufferOffset + 2]);
    color.a = 1.0;
    return color;
static inline void writeR8G8B8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    uint dst = pack_float_to_snorm4x8(color);
    int24bitToBytes(dst, bufferOffset, buffer);
static inline float4 readR8G8B8A8_UNORM(uint bufferOffset, constant uchar *buffer)
    return readR8G8B8A8(bufferOffset, buffer, false);
static inline void writeR8G8B8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, false);
static inline float4 readR8G8B8A8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
    return readR8G8B8A8(bufferOffset, buffer, true);
static inline void writeR8G8B8A8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, true);
static inline float4 readB8G8R8A8_UNORM(uint bufferOffset, constant uchar *buffer)
    return readR8G8B8A8(bufferOffset, buffer, false).bgra;
static inline void writeB8G8R8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    color.rgba = color.bgra;
    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, false);
static inline float4 readB8G8R8A8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
    return readR8G8B8A8(bufferOffset, buffer, true).bgra;
static inline void writeB8G8R8A8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    color.rgba = color.bgra;
    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, true);
static inline float4 readR8G8B8_UNORM(uint bufferOffset, constant uchar *buffer)
    return readR8G8B8(bufferOffset, buffer, false);
static inline void writeR8G8B8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    return writeR8G8B8(gIndices, options, bufferOffset, color, buffer, false);
static inline float4 readR8G8B8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
    return readR8G8B8(bufferOffset, buffer, true);
static inline void writeR8G8B8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    return writeR8G8B8(gIndices, options, bufferOffset, color, buffer, true);
static inline float4 readL8_UNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.rgb = float3(normalizedToFloat<uchar>(buffer[bufferOffset]));
    color.a = 1.0;
    return color;
static inline void writeL8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
static inline void writeA8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    buffer[bufferOffset] = floatToNormalized<uchar>(color.a);
static inline float4 readL8A8_UNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.rgb = float3(normalizedToFloat<uchar>(buffer[bufferOffset]));
    color.a = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
    return color;
static inline void writeL8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
    buffer[bufferOffset + 1] = floatToNormalized<uchar>(color.a);
static inline float4 readR8_UNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
    color.g = color.b = 0.0;
    color.a = 1.0;
    return color;
static inline void writeR8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
static inline float4 readR8_SNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
    color.g = color.b = 0.0;
    color.a = 1.0;
    return color;
static inline void writeR8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    buffer[bufferOffset] = as_type<uchar>(floatToNormalized<7, char>(color.r));
static inline int4 readR8_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = as_type<char>(buffer[bufferOffset]);
    color.g = color.b = 0;
    color.a = 1;
    return color;
static inline void writeR8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    buffer[bufferOffset] = static_cast<uchar>(color.r);
static inline uint4 readR8_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = as_type<uchar>(buffer[bufferOffset]);
    color.g = color.b = 0;
    color.a = 1;
    return color;
static inline void writeR8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    buffer[bufferOffset] = static_cast<uchar>(color.r);
static inline float4 readR8G8_UNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
    color.g = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
    color.b = 0.0;
    color.a = 1.0;
    return color;
static inline void writeR8G8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
    buffer[bufferOffset + 1] = floatToNormalized<uchar>(color.g);
static inline float4 readR8G8_SNORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
    color.g = normalizedToFloat<7, char>(buffer[bufferOffset + 1]);
    color.b = 0.0;
    color.a = 1.0;
    return color;
static inline void writeR8G8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    buffer[bufferOffset] = as_type<uchar>(floatToNormalized<7, char>(color.r));
    buffer[bufferOffset + 1] = as_type<uchar>(floatToNormalized<7, char>(color.g));
static inline int4 readR8G8_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = as_type<char>(buffer[bufferOffset]);
    color.g = as_type<char>(buffer[bufferOffset + 1]);
    color.b = 0;
    color.a = 1;
    return color;
static inline void writeR8G8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    buffer[bufferOffset] = static_cast<uchar>(color.r);
    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
static inline uint4 readR8G8_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = as_type<uchar>(buffer[bufferOffset]);
    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
    color.b = 0;
    color.a = 1;
    return color;
static inline void writeR8G8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    buffer[bufferOffset] = static_cast<uchar>(color.r);
    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
static inline int4 readR8G8B8_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = as_type<char>(buffer[bufferOffset]);
    color.g = as_type<char>(buffer[bufferOffset + 1]);
    color.b = as_type<char>(buffer[bufferOffset + 2]);
    color.a = 1;
    return color;
static inline uint4 readR8G8B8_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = as_type<uchar>(buffer[bufferOffset]);
    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
    color.b = as_type<uchar>(buffer[bufferOffset + 2]);
    color.a = 1;
    return color;
static inline int4 readR8G8B8A8_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = as_type<char>(buffer[bufferOffset]);
    color.g = as_type<char>(buffer[bufferOffset + 1]);
    color.b = as_type<char>(buffer[bufferOffset + 2]);
    color.a = as_type<char>(buffer[bufferOffset + 3]);
    return color;
static inline void writeR8G8B8A8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    buffer[bufferOffset] = static_cast<uchar>(color.r);
    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
    buffer[bufferOffset + 2] = static_cast<uchar>(color.b);
    buffer[bufferOffset + 3] = static_cast<uchar>(color.a);
static inline uint4 readR8G8B8A8_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = as_type<uchar>(buffer[bufferOffset]);
    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
    color.b = as_type<uchar>(buffer[bufferOffset + 2]);
    color.a = as_type<uchar>(buffer[bufferOffset + 3]);
    return color;
static inline void writeR8G8B8A8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    buffer[bufferOffset] = static_cast<uchar>(color.r);
    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
    buffer[bufferOffset + 2] = static_cast<uchar>(color.b);
    buffer[bufferOffset + 3] = static_cast<uchar>(color.a);
static inline float4 readR16_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
    color.g = color.b = 0.0;
    color.a = 1.0;
    return color;
static inline void writeR16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
template <typename ShortType>
static inline float4 readR16_NORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
    color.g = color.b = 0.0;
    color.a = 1.0;
    return color;
static inline int4 readR16_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = bytesToShort<short>(buffer, bufferOffset);
    color.g = color.b = 0;
    color.a = 1;
    return color;
static inline void writeR16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
static inline uint4 readR16_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = bytesToShort<ushort>(buffer, bufferOffset);
    color.g = color.b = 0;
    color.a = 1;
    return color;
static inline void writeR16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
static inline float4 readA16_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
    color.rgb = 0.0;
    return color;
static inline void writeA16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset, buffer);
static inline float4 readL16_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.rgb = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
    color.a = 1.0;
    return color;
static inline void writeL16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
static inline float4 readL16A16_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.rgb = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
    return color;
static inline void writeL16A16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset + 2, buffer);
static inline float4 readR16G16_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
    color.b = 0.0;
    color.a = 1.0;
    return color;
static inline void writeR16G16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
    shortToBytes(as_type<ushort>(static_cast<half>(color.g)), bufferOffset + 2, buffer);
template <typename ShortType>
static inline float4 readR16G16_NORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
    color.b = 0.0;
    color.a = 1.0;
    return color;
static inline int4 readR16G16_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = bytesToShort<short>(buffer, bufferOffset);
    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
    color.b = 0;
    color.a = 1;
    return color;
static inline void writeR16G16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
    shortToBytes(static_cast<short>(color.g), bufferOffset + 2, buffer);
static inline uint4 readR16G16_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = bytesToShort<ushort>(buffer, bufferOffset);
    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
    color.b = 0;
    color.a = 1;
    return color;
static inline void writeR16G16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
    shortToBytes(static_cast<ushort>(color.g), bufferOffset + 2, buffer);
static inline float4 readR16G16B16_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
    color.b = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 4));
    color.a = 1.0;
    return color;
template <typename ShortType>
static inline float4 readR16G16B16_NORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
    color.b = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 4));
    color.a = 1.0;
    return color;
static inline int4 readR16G16B16_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = bytesToShort<short>(buffer, bufferOffset);
    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
    color.b = bytesToShort<short>(buffer, bufferOffset + 4);
    color.a = 1;
    return color;
static inline uint4 readR16G16B16_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = bytesToShort<ushort>(buffer, bufferOffset);
    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
    color.b = bytesToShort<ushort>(buffer, bufferOffset + 4);
    color.a = 1;
    return color;
static inline float4 readR16G16B16A16_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
    color.b = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 4));
    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 6));
    return color;
static inline void writeR16G16B16A16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
    shortToBytes(as_type<ushort>(static_cast<half>(color.g)), bufferOffset + 2, buffer);
    shortToBytes(as_type<ushort>(static_cast<half>(color.b)), bufferOffset + 4, buffer);
    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset + 6, buffer);
template <typename ShortType>
static inline float4 readR16G16B16A16_NORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
    color.b = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 4));
    color.a = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 6));
    return color;
static inline int4 readR16G16B16A16_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = bytesToShort<short>(buffer, bufferOffset);
    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
    color.b = bytesToShort<short>(buffer, bufferOffset + 4);
    color.a = bytesToShort<short>(buffer, bufferOffset + 6);
    return color;
static inline void writeR16G16B16A16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
    shortToBytes(static_cast<short>(color.g), bufferOffset + 2, buffer);
    shortToBytes(static_cast<short>(color.b), bufferOffset + 4, buffer);
    shortToBytes(static_cast<short>(color.a), bufferOffset + 6, buffer);
static inline uint4 readR16G16B16A16_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = bytesToShort<ushort>(buffer, bufferOffset);
    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
    color.b = bytesToShort<ushort>(buffer, bufferOffset + 4);
    color.a = bytesToShort<ushort>(buffer, bufferOffset + 6);
    return color;
static inline void writeR16G16B16A16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
    shortToBytes(static_cast<ushort>(color.g), bufferOffset + 2, buffer);
    shortToBytes(static_cast<ushort>(color.b), bufferOffset + 4, buffer);
    shortToBytes(static_cast<ushort>(color.a), bufferOffset + 6, buffer);
static inline float4 readR32_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
    color.g = color.b = 0.0;
    color.a = 1.0;
    return color;
static inline void writeR32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
template <typename IntType>
static inline float4 readR32_NORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
    color.g = color.b = 0.0;
    color.a = 1.0;
    return color;
static inline float4 readA32_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
    color.rgb = 0.0;
    return color;
static inline void writeA32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    intToBytes(as_type<uint>(color.a), bufferOffset, buffer);
static inline float4 readL32_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.rgb = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
    color.a = 1.0;
    return color;
static inline void writeL32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
static inline int4 readR32_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = bytesToInt<int>(buffer, bufferOffset);
    color.g = color.b = 0;
    color.a = 1;
    return color;
static inline void writeR32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    intToBytes(color.r, bufferOffset, buffer);
static inline float4 readR32_FIXED(uint bufferOffset, constant uchar *buffer)
    float4 color;
    constexpr float kDivisor = 1.0f / (1 << 16);
    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
    color.g = color.b = 0.0;
    color.a = 1.0;
    return color;
static inline uint4 readR32_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = bytesToInt<uint>(buffer, bufferOffset);
    color.g = color.b = 0;
    color.a = 1;
    return color;
static inline void writeR32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    intToBytes(color.r, bufferOffset, buffer);
static inline float4 readL32A32_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.rgb = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
    return color;
static inline void writeL32A32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
    intToBytes(as_type<uint>(color.a), bufferOffset + 4, buffer);
static inline float4 readR32G32_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
    color.b = 0.0;
    color.a = 1.0;
    return color;
static inline void writeR32G32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
    intToBytes(as_type<uint>(color.g), bufferOffset + 4, buffer);
template <typename IntType>
static inline float4 readR32G32_NORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
    color.b = 0.0;
    color.a = 1.0;
    return color;
static inline int4 readR32G32_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = bytesToInt<int>(buffer, bufferOffset);
    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
    color.b = 0;
    color.a = 1;
    return color;
static inline void writeR32G32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    intToBytes(color.r, bufferOffset, buffer);
    intToBytes(color.g, bufferOffset + 4, buffer);
static inline float4 readR32G32_FIXED(uint bufferOffset, constant uchar *buffer)
    float4 color;
    constexpr float kDivisor = 1.0f / (1 << 16);
    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
    color.b = 0.0;
    color.a = 1.0;
    return color;
static inline uint4 readR32G32_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = bytesToInt<uint>(buffer, bufferOffset);
    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
    color.b = 0;
    color.a = 1;
    return color;
static inline void writeR32G32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    intToBytes(color.r, bufferOffset, buffer);
    intToBytes(color.g, bufferOffset + 4, buffer);
static inline float4 readR32G32B32_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
    color.b = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 8));
    color.a = 1.0;
    return color;
template <typename IntType>
static inline float4 readR32G32B32_NORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
    color.b = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 8));
    color.a = 1.0;
    return color;
static inline int4 readR32G32B32_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = bytesToInt<int>(buffer, bufferOffset);
    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
    color.b = bytesToInt<int>(buffer, bufferOffset + 8);
    color.a = 1;
    return color;
static inline float4 readR32G32B32_FIXED(uint bufferOffset, constant uchar *buffer)
    float4 color;
    constexpr float kDivisor = 1.0f / (1 << 16);
    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
    color.b = bytesToInt<int>(buffer, bufferOffset + 8) * kDivisor;
    color.a = 1.0;
    return color;
static inline uint4 readR32G32B32_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = bytesToInt<uint>(buffer, bufferOffset);
    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
    color.b = bytesToInt<uint>(buffer, bufferOffset + 8);
    color.a = 1;
    return color;
static inline float4 readR32G32B32A32_FLOAT(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
    color.b = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 8));
    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 12));
    return color;
static inline void writeR32G32B32A32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
    intToBytes(as_type<uint>(color.g), bufferOffset + 4, buffer);
    intToBytes(as_type<uint>(color.b), bufferOffset + 8, buffer);
    intToBytes(as_type<uint>(color.a), bufferOffset + 12, buffer);
template <typename IntType>
static inline float4 readR32G32B32A32_NORM(uint bufferOffset, constant uchar *buffer)
    float4 color;
    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
    color.b = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 8));
    color.a = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 12));
    return color;
static inline int4 readR32G32B32A32_SINT(uint bufferOffset, constant uchar *buffer)
    int4 color;
    color.r = bytesToInt<int>(buffer, bufferOffset);
    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
    color.b = bytesToInt<int>(buffer, bufferOffset + 8);
    color.a = bytesToInt<int>(buffer, bufferOffset + 12);
    return color;
static inline void writeR32G32B32A32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
    intToBytes(color.r, bufferOffset, buffer);
    intToBytes(color.g, bufferOffset + 4, buffer);
    intToBytes(color.b, bufferOffset + 8, buffer);
    intToBytes(color.a, bufferOffset + 12, buffer);
static inline float4 readR32G32B32A32_FIXED(uint bufferOffset, constant uchar *buffer)
    float4 color;
    constexpr float kDivisor = 1.0f / (1 << 16);
    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
    color.b = bytesToInt<int>(buffer, bufferOffset + 8) * kDivisor;
    color.a = bytesToInt<int>(buffer, bufferOffset + 12) * kDivisor;
    return color;
static inline uint4 readR32G32B32A32_UINT(uint bufferOffset, constant uchar *buffer)
    uint4 color;
    color.r = bytesToInt<uint>(buffer, bufferOffset);
    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
    color.b = bytesToInt<uint>(buffer, bufferOffset + 8);
    color.a = bytesToInt<uint>(buffer, bufferOffset + 12);
    return color;
static inline void writeR32G32B32A32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
    intToBytes(color.r, bufferOffset, buffer);
    intToBytes(color.g, bufferOffset + 4, buffer);
    intToBytes(color.b, bufferOffset + 8, buffer);
    intToBytes(color.a, bufferOffset + 12, buffer);
# 1292 "./copy_buffer.metal"
static inline int4 readR8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8_SINT(bufferOffset, buffer); } static inline uint4 readR8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8_UINT(bufferOffset, buffer); } static inline int4 readR8G8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8_UINT(bufferOffset, buffer); } static inline int4 readR8G8B8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8B8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8_UINT(bufferOffset, buffer); } static inline int4 readR8G8B8A8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8A8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8B8A8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8A8_UINT(bufferOffset, buffer); }
static inline int4 readR16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16_SINT(bufferOffset, buffer); } static inline uint4 readR16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16_UINT(bufferOffset, buffer); } static inline int4 readR16G16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16_UINT(bufferOffset, buffer); } static inline int4 readR16G16B16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16B16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16_UINT(bufferOffset, buffer); } static inline int4 readR16G16B16A16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16A16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16B16A16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16A16_UINT(bufferOffset, buffer); }
static inline int4 readR32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32_SINT(bufferOffset, buffer); } static inline uint4 readR32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32_UINT(bufferOffset, buffer); } static inline int4 readR32G32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32_UINT(bufferOffset, buffer); } static inline int4 readR32G32B32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32B32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32_UINT(bufferOffset, buffer); } static inline int4 readR32G32B32A32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32A32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32B32A32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32A32_UINT(bufferOffset, buffer); }
static inline int4 readR10G10B10A2_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR10G10B10A2_SINT(bufferOffset, buffer); } static inline uint4 readR10G10B10A2_USCALED(uint bufferOffset, constant uchar *buffer) { return readR10G10B10A2_UINT(bufferOffset, buffer); }
kernel void readFromBufferToFloatTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<float, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<float, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<float, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<float, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
# 1336 "./copy_buffer.metal"
    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
    switch (kCopyFormatType)
    {
        case FormatID::R5G6B5_UNORM: { auto color = readR5G6B5_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UNORM: { auto color = readR8G8B8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UNORM_SRGB: { auto color = readR8G8B8A8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_SNORM: { auto color = readR8G8B8A8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::B8G8R8A8_UNORM: { auto color = readB8G8R8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::B8G8R8A8_UNORM_SRGB: { auto color = readB8G8R8A8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UNORM: { auto color = readR8G8B8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UNORM_SRGB: { auto color = readR8G8B8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_SNORM: { auto color = readR8G8B8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L8_UNORM: { auto color = readL8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L8A8_UNORM: { auto color = readL8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R5G5B5A1_UNORM: { auto color = readR5G5B5A1_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R4G4B4A4_UNORM: { auto color = readR4G4B4A4_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8_UNORM: { auto color = readR8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8_SNORM: { auto color = readR8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_UNORM: { auto color = readR8G8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_SNORM: { auto color = readR8G8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_FLOAT: { auto color = readR16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::A16_FLOAT: { auto color = readA16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L16_FLOAT: { auto color = readL16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L16A16_FLOAT: { auto color = readL16A16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_FLOAT: { auto color = readR16G16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_FLOAT: { auto color = readR16G16B16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_FLOAT: { auto color = readR16G16B16A16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_FLOAT: { auto color = readR32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::A32_FLOAT: { auto color = readA32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L32_FLOAT: { auto color = readL32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L32A32_FLOAT: { auto color = readL32A32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_FLOAT: { auto color = readR32G32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_FLOAT: { auto color = readR32G32B32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_FLOAT: { auto color = readR32G32B32A32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
    }
kernel void readFromBufferToIntTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<int, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<int, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<int, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<int, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
# 1364 "./copy_buffer.metal"
    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
    switch (kCopyFormatType)
    {
        case FormatID::R8_SINT: { auto color = readR8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_SINT: { auto color = readR8G8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_SINT: { auto color = readR8G8B8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_SINT: { auto color = readR8G8B8A8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_SINT: { auto color = readR16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_SINT: { auto color = readR16G16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_SINT: { auto color = readR16G16B16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_SINT: { auto color = readR16G16B16A16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_SINT: { auto color = readR32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_SINT: { auto color = readR32G32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_SINT: { auto color = readR32G32B32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_SINT: { auto color = readR32G32B32A32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
    }
kernel void readFromBufferToUIntTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<uint, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<uint, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<uint, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<uint, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
# 1392 "./copy_buffer.metal"
    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
    switch (kCopyFormatType)
    {
        case FormatID::R8_UINT: { auto color = readR8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_UINT: { auto color = readR8G8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UINT: { auto color = readR8G8B8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UINT: { auto color = readR8G8B8A8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_UINT: { auto color = readR16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_UINT: { auto color = readR16G16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_UINT: { auto color = readR16G16B16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_UINT: { auto color = readR16G16B16A16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_UINT: { auto color = readR32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_UINT: { auto color = readR32G32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_UINT: { auto color = readR32G32B32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_UINT: { auto color = readR32G32B32A32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
    }
kernel void writeFromFloatTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<float, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<float, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<float, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<float, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<float, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
# 1439 "./copy_buffer.metal"
    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
    switch (kCopyFormatType)
    {
        case FormatID::R5G6B5_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR5G6B5_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::B8G8R8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeB8G8R8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::B8G8R8A8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeB8G8R8A8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R5G5B5A1_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR5G5B5A1_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R4G4B4A4_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR4G4B4A4_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L16A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL16A16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L32A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL32A32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break;
    }
kernel void writeFromIntTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<int, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<int, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<int, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<int, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<int, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
# 1464 "./copy_buffer.metal"
    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
    switch (kCopyFormatType)
    {
        case FormatID::R8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_SINT(gIndices, options, bufferOffset, color, buffer); } break;
    }
kernel void writeFromUIntTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<uint, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<uint, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<uint, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<uint, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<uint, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
# 1489 "./copy_buffer.metal"
    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
    switch (kCopyFormatType)
    {
        case FormatID::R8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_UINT(gIndices, options, bufferOffset, color, buffer); } break;
    }
struct CopyVertexParams
    uint srcBufferStartOffset;
    uint srcStride;
    uint srcComponentBytes;
    uint srcComponents;
    uchar4 srcDefaultAlphaData;
    uint dstBufferStartOffset;
    uint dstStride;
    uint dstComponents;
    uint vertexCount;
# 1539 "./copy_buffer.metal"
template <typename IntType>
static inline void writeFloatVertex(constant CopyVertexParams &options,
                                    uint idx,
                                    vec<IntType, 4> data,
                                    device uchar *dst)
    uint dstOffset = idx * options.dstStride + options.dstBufferStartOffset;
    for (uint component = 0; component < options.dstComponents; ++component, dstOffset += 4)
    {
        floatToBytes(static_cast<float>(data[component]), dstOffset, dst);
    }
template <>
inline void writeFloatVertex(constant CopyVertexParams &options,
                             uint idx,
                             vec<float, 4> data,
                             device uchar *dst)
    uint dstOffset = idx * options.dstStride + options.dstBufferStartOffset;
    for (uint component = 0; component < options.dstComponents; ++component, dstOffset += 4)
    {
        floatToBytes(data[component], dstOffset, dst);
    }
static inline void convertToFloatVertexFormat(uint index,
                                              constant CopyVertexParams &options,
                                              constant uchar *srcBuffer,
                                              device uchar *dstBuffer)
# 1585 "./copy_buffer.metal"
    uint bufferOffset = options.srcBufferStartOffset + options.srcStride * index;
# 1594 "./copy_buffer.metal"
    switch (kCopyFormatType)
    {
        case FormatID::R8_UNORM: { auto data = readR8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SNORM: { auto data = readR8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_UINT: { auto data = readR8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SINT: { auto data = readR8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_USCALED: { auto data = readR8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SSCALED: { auto data = readR8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_UNORM: { auto data = readR8G8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SNORM: { auto data = readR8G8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_UINT: { auto data = readR8G8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SINT: { auto data = readR8G8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_USCALED: { auto data = readR8G8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SSCALED: { auto data = readR8G8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_UNORM: { auto data = readR8G8B8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SNORM: { auto data = readR8G8B8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_UINT: { auto data = readR8G8B8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SINT: { auto data = readR8G8B8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_USCALED: { auto data = readR8G8B8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SSCALED: { auto data = readR8G8B8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_UNORM: { auto data = readR8G8B8A8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SNORM: { auto data = readR8G8B8A8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_UINT: { auto data = readR8G8B8A8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SINT: { auto data = readR8G8B8A8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_USCALED: { auto data = readR8G8B8A8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SSCALED: { auto data = readR8G8B8A8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_UNORM: { auto data = readR16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SNORM: { auto data = readR16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_UINT: { auto data = readR16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SINT: { auto data = readR16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_USCALED: { auto data = readR16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SSCALED: { auto data = readR16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_UNORM: { auto data = readR16G16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SNORM: { auto data = readR16G16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_UINT: { auto data = readR16G16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SINT: { auto data = readR16G16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_USCALED: { auto data = readR16G16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SSCALED: { auto data = readR16G16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_UNORM: { auto data = readR16G16B16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SNORM: { auto data = readR16G16B16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_UINT: { auto data = readR16G16B16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SINT: { auto data = readR16G16B16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_USCALED: { auto data = readR16G16B16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SSCALED: { auto data = readR16G16B16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_UNORM: { auto data = readR16G16B16A16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SNORM: { auto data = readR16G16B16A16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_UINT: { auto data = readR16G16B16A16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SINT: { auto data = readR16G16B16A16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_USCALED: { auto data = readR16G16B16A16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SSCALED: { auto data = readR16G16B16A16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_UNORM: { auto data = readR32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SNORM: { auto data = readR32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_UINT: { auto data = readR32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SINT: { auto data = readR32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_USCALED: { auto data = readR32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SSCALED: { auto data = readR32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_UNORM: { auto data = readR32G32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SNORM: { auto data = readR32G32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_UINT: { auto data = readR32G32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SINT: { auto data = readR32G32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_USCALED: { auto data = readR32G32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SSCALED: { auto data = readR32G32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_UNORM: { auto data = readR32G32B32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SNORM: { auto data = readR32G32B32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_UINT: { auto data = readR32G32B32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SINT: { auto data = readR32G32B32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_USCALED: { auto data = readR32G32B32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SSCALED: { auto data = readR32G32B32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_UNORM: { auto data = readR32G32B32A32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SNORM: { auto data = readR32G32B32A32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_UINT: { auto data = readR32G32B32A32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SINT: { auto data = readR32G32B32A32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_USCALED: { auto data = readR32G32B32A32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SSCALED: { auto data = readR32G32B32A32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_FLOAT: { auto data = readR16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_FLOAT: { auto data = readR16G16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_FLOAT: { auto data = readR16G16B16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_FLOAT: { auto data = readR16G16B16A16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_FLOAT: { auto data = readR32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_FLOAT: { auto data = readR32G32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_FLOAT: { auto data = readR32G32B32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_FLOAT: { auto data = readR32G32B32A32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_FIXED: { auto data = readR32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_FIXED: { auto data = readR32G32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_FIXED: { auto data = readR32G32B32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_FIXED: { auto data = readR32G32B32A32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_SINT: { auto data = readR10G10B10A2_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_UINT: { auto data = readR10G10B10A2_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_SSCALED: { auto data = readR10G10B10A2_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_USCALED: { auto data = readR10G10B10A2_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break;
    }
kernel void convertToFloatVertexFormatCS(uint index [[thread_position_in_grid]],
                                         constant CopyVertexParams &options [[buffer(0)]],
                                         constant uchar *srcBuffer [[buffer(1)]],
                                         device uchar *dstBuffer [[buffer(2)]])
    if (index >= options.vertexCount) { return; };
    convertToFloatVertexFormat(index, options, srcBuffer, dstBuffer);
vertex void convertToFloatVertexFormatVS(uint index [[vertex_id]],
                                         constant CopyVertexParams &options [[buffer(0)]],
                                         constant uchar *srcBuffer [[buffer(1)]],
                                         device uchar *dstBuffer [[buffer(2)]])
    convertToFloatVertexFormat(index, options, srcBuffer, dstBuffer);
static inline void expandVertexFormatComponents(uint index,
                                                constant CopyVertexParams &options,
                                                constant uchar *srcBuffer,
                                                device uchar *dstBuffer)
    uint srcOffset = options.srcBufferStartOffset + options.srcStride * index;
    uint dstOffset = options.dstBufferStartOffset + options.dstStride * index;
    uint dstComponentsBeforeAlpha = min(options.dstComponents, 3u);
    uint component;
    for (component = 0; component < options.srcComponents; ++component,
        srcOffset += options.srcComponentBytes, dstOffset += options.srcComponentBytes)
    {
        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
        {
            dstBuffer[dstOffset + byte] = srcBuffer[srcOffset + byte];
        }
    }
    for (; component < dstComponentsBeforeAlpha;
         ++component, dstOffset += options.srcComponentBytes)
    {
        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
        {
            dstBuffer[dstOffset + byte] = 0;
        }
    }
    if (component < options.dstComponents)
    {
        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
        {
            dstBuffer[dstOffset + byte] = options.srcDefaultAlphaData[byte];
        }
    }
kernel void expandVertexFormatComponentsCS(uint index [[thread_position_in_grid]],
                                           constant CopyVertexParams &options [[buffer(0)]],
                                           constant uchar *srcBuffer [[buffer(1)]],
                                           device uchar *dstBuffer [[buffer(2)]])
    if (index >= options.vertexCount) { return; };
    expandVertexFormatComponents(index, options, srcBuffer, dstBuffer);
vertex void expandVertexFormatComponentsVS(uint index [[vertex_id]],
                                           constant CopyVertexParams &options [[buffer(0)]],
                                           constant uchar *srcBuffer [[buffer(1)]],
                                           device uchar *dstBuffer [[buffer(2)]])
    expandVertexFormatComponents(index, options, srcBuffer, dstBuffer);
# 6 "temp_master_source.metal" 2
# 1 "./visibility.metal" 1
constant bool kCombineWithExistingResult [[function_constant(1000)]];
struct CombineVisibilityResultOptions
    uint startOffset;
    uint numOffsets;
kernel void combineVisibilityResult(uint idx [[thread_position_in_grid]],
                                    constant CombineVisibilityResultOptions &options [[buffer(0)]],
                                    constant ushort4 *renderpassVisibilityResult [[buffer(1)]],
                                    device ushort4 *finalResults [[buffer(2)]])
    if (idx > 0)
    {
        return;
    }
    ushort4 finalResult16x4;
    if (kCombineWithExistingResult)
    {
        finalResult16x4 = finalResults[0];
    }
    else
    {
        finalResult16x4 = ushort4(0, 0, 0, 0);
    }
    for (uint i = 0; i < options.numOffsets; ++i)
    {
        uint offset = options.startOffset + i;
        ushort4 renderpassResult = renderpassVisibilityResult[offset];
        finalResult16x4 = finalResult16x4 | renderpassResult;
    }
    finalResults[0] = finalResult16x4;
# 7 "temp_master_source.metal" 2
# 1 "./rewrite_indices.metal" 1
# 10 "./rewrite_indices.metal"
#include <metal_stdlib>
# 1 "./rewrite_indices_shared.h" 1
# 12 "./rewrite_indices.metal" 2
using namespace metal;
constant uint fixIndexBufferKey [[ function_constant(2000) ]];
constant bool indexBufferIsUint16 = (((fixIndexBufferKey >> 0U) & 0x03U) == 2U);
constant bool indexBufferIsUint32 = (((fixIndexBufferKey >> 0U) & 0x03U) == 3U);
constant bool outIndexBufferIsUint16 = (((fixIndexBufferKey >> 2U) & 0x03U) == 2U);
constant bool outIndexBufferIsUint32 = (((fixIndexBufferKey >> 2U) & 0x03U) == 3U);
constant bool doPrimRestart = (fixIndexBufferKey & 0x00100U);
constant uint fixIndexBufferMode = (fixIndexBufferKey >> 4U) & 0x0FU;
static inline uint readIdx(
                           const device ushort *indexBufferUint16,
                           const device uint *indexBufferUint32,
                           const uint restartIndex,
                           const uint indexCount,
                           uint idx,
                           thread bool &foundRestart,
                           thread uint &indexThatRestartedFirst
                           )
    uint inIndex = idx;
    if(inIndex < indexCount)
    {
        if(indexBufferIsUint16)
        {
            inIndex = indexBufferUint16[inIndex];
        }
        else if(indexBufferIsUint32)
        {
            inIndex = indexBufferUint32[inIndex];
        }
    }
    else
    {
        foundRestart = true;
        indexThatRestartedFirst = idx;
    }
    if(doPrimRestart && !foundRestart && inIndex == restartIndex)
    {
        foundRestart = true;
        indexThatRestartedFirst = idx;
    }
    return inIndex;
static inline void outputPrimitive(
                                   const device ushort *indexBufferUint16,
                                   const device uint *indexBufferUint32,
                                   device ushort *outIndexBufferUint16,
                                   device uint *outIndexBufferUint32,
                                   const uint restartIndex,
                                   const uint indexCount,
                                   thread uint &baseIndex,
                                   uint onIndex,
                                   thread uint &onOutIndex
                                   )
    if(baseIndex > onIndex) return;
    bool foundRestart = false;
    uint indexThatRestartedFirst = 0;
# 86 "./rewrite_indices.metal"
    switch(fixIndexBufferMode)
    {
        //MtlFixIndexBufferKeyPoints
        case 0x00U:
        {
            auto tmpIndex = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex, foundRestart, indexThatRestartedFirst);
            if(foundRestart)
            {
                baseIndex = indexThatRestartedFirst + 1;
                return;
            }
            ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex; } onOutIndex++; });
        }
        break;
        //MtlFixIndexBufferKeyLines
        case 0x01U:
        {
            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
            if(foundRestart)
            {
                baseIndex = indexThatRestartedFirst + 1;
                return;
            }
            if((onIndex - baseIndex) & 1) return;
            if(fixIndexBufferKey & 0x00200U)
            {
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
            }
            else
            {
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
            }
        }
        break;
        //MtlFixIndexBufferKeyLineStrip
        case 0x03U:
        {
            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
            if(foundRestart)
            {
                baseIndex = indexThatRestartedFirst + 1;
                return;
            }
            if(fixIndexBufferKey & 0x00200U)
            {
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
            }
            else
            {
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
            }
        }
        break;
        //MtlFixIndexBufferKeyTriangles
        case 0x04U:
        {
            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
            auto tmpIndex2 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 2, foundRestart, indexThatRestartedFirst);
            if(foundRestart)
            {
                baseIndex = indexThatRestartedFirst + 1;
                return;
            }
            if(((onIndex - baseIndex) % 3) != 0) return;
            if(fixIndexBufferKey & 0x00200U)
            {
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
            }
            else
            {
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
            }
        }
        break;
        //MtlFixIndexBufferKeyTriangleStrip
        case 0x05U:
        {
            uint isOdd = ((onIndex - baseIndex) & 1);
            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0 + isOdd, foundRestart, indexThatRestartedFirst);
            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1 - isOdd, foundRestart, indexThatRestartedFirst);
            auto tmpIndex2 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 2, foundRestart, indexThatRestartedFirst);
            if(foundRestart)
            {
                baseIndex = indexThatRestartedFirst + 1;
                return;
            }
            if(fixIndexBufferKey & 0x00200U)
            {
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
            }
            else
            {
                if(isOdd)
                {
                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
                }
                else
                {
                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
                }
            }
            assert(onOutIndex <= (onIndex + 1) * 3);
            assert(onOutIndex <= (indexCount - 2) * 3);
        }
        break;
    }
kernel void fixIndexBuffer(
                           const device ushort *indexBufferUint16 [[ buffer(0), function_constant(indexBufferIsUint16) ]],
                           const device uint *indexBufferUint32 [[ buffer(0), function_constant(indexBufferIsUint32) ]],
                           device ushort *outIndexBufferUint16 [[ buffer(1), function_constant(outIndexBufferIsUint16) ]],
                           device uint *outIndexBufferUint32 [[ buffer(1), function_constant(outIndexBufferIsUint32) ]],
                           constant uint &indexCount [[ buffer(2) ]],
                           uint prim [[thread_position_in_grid]])
    constexpr uint restartIndex = 0xFFFFFFFF;
    uint baseIndex = 0;
    uint onIndex = onIndex;
    uint onOutIndex = onOutIndex;
    switch(fixIndexBufferMode)
    {
        case 0x00U:
            onIndex = prim;
            onOutIndex = prim;
            break;
        case 0x01U:
            onIndex = prim * 2 + 0;
            onOutIndex = prim * 2 + 0;
            break;
        case 0x03U:
            onIndex = prim;
            onOutIndex = prim * 2 + 0;
            break;
        case 0x04U:
            onIndex = prim * 3 + 0;
            onOutIndex = prim * 3 + 0;
            break;
        case 0x05U:
            onIndex = prim;
            onOutIndex = prim * 3 + 0;
            break;
    }
    outputPrimitive(indexBufferUint16, indexBufferUint32, outIndexBufferUint16, outIndexBufferUint32, restartIndex, indexCount, baseIndex, onIndex, onOutIndex);
# 8 "temp_master_source.metal" 2
