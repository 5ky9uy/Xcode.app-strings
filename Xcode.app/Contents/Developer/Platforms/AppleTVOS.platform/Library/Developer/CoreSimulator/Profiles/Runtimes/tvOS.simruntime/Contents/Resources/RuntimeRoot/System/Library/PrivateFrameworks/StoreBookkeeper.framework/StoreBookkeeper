domain
since-version
ERROR: unable to zip large data of size ~%.3f GB
deflateInit2() failed: %s
deflate() failed: %s
0123456789abcdef
MSVHasher+Algorithms.h
void _MSVHasherAppendBytes(MSVHasher * _Nonnull, const void * _Nonnull, size_t)
Cannot append to unknown hasher algorithm
NSString * _Nonnull _MSVHashGetDigest(MSVHash)
Cannot obtain digest from unknown hasher algorithm
MSVHash _MSVHasherFinalize(MSVHasher * _Nonnull)
Cannot finalize unknown hasher algorithm
SBKSyncClamps
com.apple.amp
+[SBKStoreClampsController sharedClampsController]_block_invoke
SBKStoreClampsController.m
Unarchiving SBKStoreClampsController resulted in error:%@
Current Date = %@,
accountIdentifierCheckTimestamp = %@,
authenticationNeededTimestamp = %@,
userAcceptedSyncTimestamp = %@,
networkingBlockedUntil = %@,
backOffUntil= %@,
userCancelledSignInBackOffUntil = %@
SBKTransactionClamps
SBAccountIdentifierCheckTimestamp
SBKAuthenticationNeededTimestamp
SBKUserAcceptedSyncTimestamp
SBKNetworkingBlockedUntil
SBKUserCancelledSignInBackOffUntil
Version
SBKVersion
v16@?0@"NSMutableDictionary"8
-[SBKStoreClampsController saveToUserDefaults]_block_invoke
Archiving SBKStoreClampsController resulted in error:%@
SBK_KVSTORE_CLAMPS_LOG
-[SBKStoreClampsController reset]
Reseting Clamps
-[SBKStoreClampsController hasAuthenticatedTooRecentlyForTransaction:error:]
Drop transaction: %@ -- Too soon since last authentication: %f [%fs]
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKStoreClampsController.m
[StoreBookkeeper] SBKStoreClampsController - will avoid presenting authentication for %02llu:%02llu:%2f
-[SBKStoreClampsController _canScheduleTransactionBasedOnType:error:]
Drop transaction: %@ -- Interval since last request: %f [%fs]
-[SBKStoreClampsController _canScheduleTransactionBasedOfNetworkingBlocked:error:]
Drop transaction: <%p> -- Networking BlockedUntil: %@
-[SBKStoreClampsController _canScheduleTransactionBasedOnAccountIdentifierCheck:error:]
Drop transaction: <%p> -- AccountIdentifierCheck != 0
-[SBKStoreClampsController _canScheduleTransactionBasedOnBackOff:error:]
Drop transaction: <%p> -- BackOff until: %@ [%fs]
-[SBKStoreClampsController _canScheduleTransactionBasedOnUserCancelledSignIn:error:]
Drop transaction: <%p> -- userCancelledBackOff until: %@ [%fs]
kvsKey
kvsPayload
%@: key=%@, payload=%@
com.apple.SBKTransactionController
com.apple.SBKTransactionController.operationQueue
SBKTransactionFinishedBlock
[%@ _beginBackgroundTask]
SBK_KVSTORE_LOG
-[SBKTransactionController _onQueue_cancelTransaction:error:]
Cancelling transaction: %@ -- isCurrentTransaction: %@
-[SBKTransactionController _onQueue_processPendingTransactions]
No Pending Transactions
Transaction In progress: %@
-[SBKTransactionController _onQueue_processCurrentTransaction]
Processing Transaction: %@
-[SBKTransactionController _onQueue_scheduleTransaction:isRetry:]
Scheduling Transaction: %@
Holding transaction %@ (due to clamps) %.2f seconds
-[SBKTransactionController _onQueue_canScheduleTransaction:error:]
Unable to schedule (due to clamps %@) transaction %@.
SBKTransactionController.m
No domain specified in transaction %@!
No url specified in transaction %@!
-[SBKTransactionController _onQueue_currentTransactionDidFinish]
Transaction Finished: %@
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKTransactionController.m
Transaction Failed: %@ -- Error: %@
-[SBKTransactionController _onQueue_transactionDidCancel:withError:]_block_invoke
-[SBKTransactionController _onQueue_processOperationOutput:operation:operationAuthenticated:]
Not using deserialized response because it is not a dictionary as expected!
Deserialized server response: %@
Deserialized server response produced response data: %@
Generic error indicated by response responseDictionary: %@
Validation error indicated by response responseDictionary: %@
Unknown error in response: %@
Not using deserialized responseDictionary because transactions have been cancelled!
Delegate calls should be done on the main thread
transaction controllers with delegates can not use transaction finish blocks
User cancelled sign-in
User entered wrong credentials
-[SBKTransactionController operation:failedWithError:]
Operation failedWithError: %@ -- inputError = %@
-[SBKTransactionController operation:failedWithError:]_block_invoke
[StoreBookkeeper] %@.  Will suppress authentication dialogs for a while.
rejected
put-ok
deleted-ok
peer-ops
puts
deletes
reason
conflicted
oversize
%@ response: syncAnchor = %@
put-oks(%@), delete-oks(%@), updatedKeys(%@) = %@
conflictedKeys(%@) = %@
deletedKeys(%@) = %@
B24@?0@"NSDictionary"8@"NSString"16
v40@?0@"NSMutableArray"8@"NSString"16@"NSString"24@?<B@?@"NSDictionary"@"NSString">32
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncResponseData.m
ERROR: server rejected %@ because the payload was too big.
SBKStoreErrorDomain
SBKStoreErrorUserInfoKeyCurrentStoreAccountName
SBKStoreErrorUserInfoKeyPreviousStoreAccountName
SBKStoreErrorUserInfoKeyRetrySeconds
<%@:%p> "%@"
SBKTransactionErorGeneric: An unknown server error occurred. (underlyingError = %@) 
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorStoreAccountLoggedOut
SBKStoreErrorStoreAccountMismatch
SBKStoreErrorCodeGeneric: An unspecified server-side error was encountered (underlyingError = %@).
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorCodeGeneric: Request Invalid: It's likely that there is something wrong with the request format (underlyingError = %@).
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorUserClamp
SBKStoreErrorServerClamp
SBKStoreErrorCodeUnknown
Error Code = %@ (%d)
SBKStoreErrorCodeGenericValidationError
SBKStoreErrorCodeGenericBookkeeperServiceError
SBKStoreErrorCodeAuthenticationError
SBKStoreErrorCodeNoStoreAccount
SBKStoreErrorCodeStoreAccountLoggedOut
SBKStoreErrorCodeStoreAccountMismatch
SBKStoreErrorCodeStoreAccountSessionExpired
SBKStoreErrorCodeStoreAccountUserCancelSignIn
SBKStoreErrorCodeStoreAccountUserCredentials
SBKStoreErrorCodeGeneric
SBKStoreErrorCodeValidation
SBKStoreErrorCodeAuthenticationClamp
SBKStoreErrorCodeServerClamp
SBKStoreErrorCodeUserClamp
SBKStoreErrorCodeNetworkingBlocked
SBKStoreErrorCodeKillSwitch
SBKStoreErrorCodeDisabled
SBKStoreErrorCodeKeyBagKillSwitch
SBKStoreErrorCodeKeyBagLoadFailure
SBKStoreErrorCodeMissingURL
SBKStoreErrorCodeMissingDomain
SBKStoreErrorCodeCancelled
SBKStoreErrorCodeDelegateCancelled
SBKStoreErrorCodeTimeout
Error Code = %lld
SBKTransactionURLOperation.m
Use +operationWithRequest:delegate:
SBK_REQUEST_LOG
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKTransactionURLOperation.m
-[SBKTransactionURLOperation setShouldAuthenticate:]
[StoreBookkeeper] setting up an authentication context - will FORCE authentication!
<%@: %p> (PrimaryURL: %@)
conflict-detection
ordinal
none
delete
value
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncRequestData.m
WARNING: no data was provided for updated key %@, skipping just that item
SBK_KVSTORE_SERIALIZER_LOG
-[SBKSyncRequestData serializableRequestBodyPropertyList]
Sync request payload (plist): %@
%lld
SBKSync.LastAccountIdentifier
SBKSync.LastAccountName
SBKSync.SyncFailureLastAccountIdentifier
SBKSync.SyncFailureLastAccountName
SBK_STOREAUTHENTICATION_LOG
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKStoreAuthenticationController.m
-[SBKStoreAuthenticationController isAuthenticationValidForTransaction:error:]
Doesn't matter what the DISD is set to since authentication is forced for transaction: %@
-[SBKStoreAuthenticationController authenticationErrorsForTransaction:]
First Use Alert %@ [transaction = %@]
No longer logged in Use Alert %@ [transaction = %@]
AccountIdentifier mismatch: %@ vs %@ [transaction = %@]
SBKLogFilter
SBKLogRuntimeOverride
SBKLogRuntimeOverridePattern
YYYY-MM-dd HH:mm:ss.SSS
logLevel
LogDefaults.v1
LogAuthEvents
LogSyncEvents
LogSyncEventData
LogDefaults.v2
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/Utilities/SBKLogger.m
Invalid RegexPattern: %@ -- Error: %@
, %@
, SBK_UPPSTORE_LOG, SBK_SYNCHANDLER_LOG, SBK_KVSTORE_LOG, SBK_KVSTORE_CLAMPS_LOG, SBK_LOG_TASKS
, SBK_KVSTORE_DESERIALIZER_LOG, SBK_KVSTORE_SERIALIZER_LOG, SBK_KVSTORE_REQUEST_LOG
, SBK_STOREAUTHENTICATION_LOG
[%@:%d] <nil>
[%@:%d] %@
%s <nil>
%s %@
%@ %@[%d:%x] [StoreBookkeeper] %@
[StoreBookkeeper] %@
*unversioned*
[result: payload-pair=%@, anchor=%@]
[request: payload-pair=%@, anchor=%@]
%@ domain = %@, PUT: %@, %@, %@
com.apple.storebookkeeper-%@%@
v16@?0@"NSNotification"8
%@, assertionID = %llu
SBK_LOG_TASKS
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/Utilities/SBKTaskAssertion.m
[SBKTaskAssertion] task created underlying assertion: %@
[SBKTaskAssertion] will invalidate underlying assertion: %@
<%@:%p; held=%@; info='%@', underlying assertion = %@>
void DebugNoteAssertionTaken(NSInteger, NSString *__strong)
SBKTaskAssertion.m
Internal Error -- assertion ID %lld is already in use (debugInfo=%@)
acquried assertion (%@) -- %@, active assertionIDs = %@
[SBKTaskAssertion] %@
( %@ )
assertionID = %@
%-2lld
**INVALID**
void DebugNoteAssertionReleased(NSInteger, NSString *__strong)
Internal Error -- released assertion ID %lld can not be found (debugInfo=%@)
released assertion (%@) -- %@, active assertionIDs = %@
SBKPreferencesDidChangeNotification
com.apple.storebookkeeper.defaultschange
_didRegister-
com.apple.storebookkeeper
UIApplicationBackgroundTaskWillExpireNotification
UIApplication
test-item-identifier
itemIdentifier
timestamp
hasBeenPlayed
playCount
<SBKMetadata:%p, id=%-32s, bktm=%@, hbpl=%d, plct=%llu, timestamp=%@>
%llu
v32@?0@"NSString"8@16^B24
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/PlaybackPosition/SBKUniversalPlaybackPositionMetadata.m
Unarchiving error: %@
ERROR: encountered invalid data while unarchiving payload for itemIdentifier: %@
pver
bktm
hbpl
plct
tstm
%02llu:%02llu:%.2f
no timestamp
*** 1970 timestamp ***
*** (-) 1970 timestamp ***
*** 1904 timestamp ***
*** (-) 1904 timestamp ***
*** distant past timestamp ***
(%f) %@
storeItemAdamID
subscriptionStoreItemAdamID
podcastURL
podcastGUID
title
artist
albumTitle
hasBeenPalyed
bookmarkTime
bookmarkMetadataTimestamp
mediaEntityType
SBKUniversalPlaybackPositionStoreDidSynchronizeNotification
9223372036854775807
SBKUniversalPlaybackPositionStore.m
Invalid paramter.  no domain specified
SBKUniversalPlaybackPositionStore.queue
-[SBKUniversalPlaybackPositionStore resignActive]_block_invoke
starting synchronizing changes for resignActive
-[SBKUniversalPlaybackPositionStore resignActive]_block_invoke_2
finished synchronizing changes for resignActive
v20@?0B8@"NSError"12
v24@?0@"SBKStoreURLBagContext"8@"NSError"16
v24@?0@"NSString"8@"NSError"16
domain version lookup
-[SBKUniversalPlaybackPositionStore _onQueueLoadRemoteDomainVersionWithCompletionBlock:]
%s - %@ already in progress.  pending our completion block to be notified when it completes.
%s - beginning %@...
SBKUPPStore LookupDomainVersion
-[SBKUniversalPlaybackPositionStore _onQueueLoadRemoteDomainVersionWithCompletionBlock:]_block_invoke_2
_onQueueSync - %@ completed. %@
 ERROR = '%@'.
v32@?0@?<v@?>8@16@"NSError"24
-[SBKUniversalPlaybackPositionStore _onQueueLoadRemoteDomainVersionWithCompletionBlock:]_block_invoke
_onQueueSync - synchronize operation beginning...
v16@?0@"NSError"8
-[SBKUniversalPlaybackPositionStore _onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:]
_onQueueRunTaskWithName %@ - short circuiting. _accountForSyncing=nil
_onQueueSync - beginning %@ operation...
SBKUPPStore Synchronize
-[SBKUniversalPlaybackPositionStore _onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:]_block_invoke_2
-[SBKUniversalPlaybackPositionStore _onQueueSynchronizeImmediatelyWithCompletionHandler:]
_onQueueSync - synchronize already in progress.  pending our completion block to be notified when it completes.
synchronize
-[SBKUniversalPlaybackPositionStore _onQueueSynchronizeImmediatelyWithCompletionHandler:]_block_invoke
v24@?0@"SBKStoreURLBagContext"8@?<v@?B@"NSError">16
PUT value
-[SBKUniversalPlaybackPositionStore _onQueuePushMetadataItem:completionBlock:]_block_invoke
_onQueueSync - push value operation beginning...
v24@?0B8B12@"NSError"16
GET value
-[SBKUniversalPlaybackPositionStore _onQueuePullMetadataItemWithItemIdentifier:completionBlock:]_block_invoke_2
_onQueueSync - pull value operation beginning...
-[SBKUniversalPlaybackPositionStore _onQueueLoadBagContextWithCompletionHandler:]
_onQueueLoadBag - skipping bag load: _accountIdentifier=%@ [no valid account identifier]
_onQueueLoadBag - load bag already in progress.  pending our completion block to be notified when it completes.
SBKUPPStore Load Bag
-[SBKUniversalPlaybackPositionStore _onQueueLoadBagContextWithCompletionHandler:]_block_invoke_4
_onQueueLoadBag - load bag completed.%@
_onQueueLoadBag - load bag operation beginning...
AutoSyncRateInMinutes
-[SBKUniversalPlaybackPositionStore _onQueueScheduleTimer]_block_invoke
scheduled timer date already passed.  Firing immediately
scheduling next timer update at %@
-[SBKUniversalPlaybackPositionStore _onQueueSuspendTimer]
suspending update timer
%.2f seconds
%lld minutes, %lld seconds
%@ (%@ from now)
SBKPlaybackPositionSyncRequestHandler.m
invalid parameters - data source is required
invalid parameters - bagContext is required
invalid parameters - bagContext.domain is required
Invalid bag.  no domain specified
SBKPlaybackPositionSyncRequestHandler.queue
SBKPlaybackPositionSyncRequestHandler.syncOperationQueue
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/PlaybackPosition/SBKPlaybackPositionSyncRequestHandler.m
-[SBKPlaybackPositionSyncRequestHandler _synchronize:]
Skipping synchronize: synchronization already in progress
Beginning synchronization
ERROR: will skip syncing item with no sync metadataIdentifier: %@
v16@?0@"<SBKUniversalPlaybackPositionMediaItem>"8
Gathered local %d items to sync from dataSource: %@
dataSource transaction context = %@
Performing sync with server using syncAnchor = %@
Sending merged items to server: %@
WARNING: sent resolved conflict to server, but still received conflicts in the response, saving those for next time...
Committing merged items with domainRevision: %@ to local database: %@
@"SBKUniversalPlaybackPositionMetadata"8@?0
Finished synchronization
you can not nest synchronization calls
i12@?0i8
-[SBKPlaybackPositionSyncRequestHandler _mergeMetadataItemsFromSyncResponse]
Handled items in response, will save %lld items locally and push back %lld conflict resolutions
keys to save to local db = %@
keys to push to cloud db = %@
completionConditionLock
-[SBKPlaybackPositionSyncRequestHandler _signalKVSTransactionCompletion:withError:]
transaction is being canceled.  error = %@
-[SBKPlaybackPositionSyncRequestHandler transactionController:transactionDidFail:error:]
Detected account change.  Getting remote items since version 0 instead of %@
-[SBKPlaybackPositionSyncRequestHandler transactionController:transactionDidFinish:]
syncRequestURL
kvs-sync
pullKeyValueRequestURL
kvs-get
pushKeyValueRequestURL
kvs-put
pullAllKeyValueRequestURL
kvs-getall
pushAllKeyValueRequestURL
kvs-putall
v32@?0@8@16^B24
com.apple.upp
com.apple.upp-extras
v24@?0@8@"NSError"16
v24@?0@"NSDictionary"8@"NSError"16
key bag contents = 
v32@?0@"NSString"8@16@"NSError"24
%@.%@
v56@?0@"NSString"8@16@?<@@?@>24@"NSString"32@"NSString"40@"NSDictionary"48
@16@?0@8
v24@?0@"NSString"8@"NSString"16
domainDisabled
kvs-sync-disabled
pollingIntervalInSeconds
kvs-sync-polling-interval-secs
SBKStoreURLBagContext.m
Use +loadBagContextFromURLBag:domain:completionBlock:
%@(%@) = %@
%@ domain=%@, enabled=%d, requestURLs = 
[client: payload-pair=%@, anchor=%@]
%@ domain = %@, GET: key='%@', %@, %@
%@-%@
version
domain-version
SBKRequestData.m
Subclass must implement
%lld-%@-%lld
SBKSyncTransaction.m
Invalid processor
????
SYNC: anchor=%@
, deletes=%@
, updates=%@
%@ domain = %@, %@
transactions using conflict detection must supply a conflict ordinal
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncTransaction.m
WARNING: Invalid response (%@).  Skipping...
v12@?0B8
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/Utilities/SBKAsynchronousTask.m
[SBKAsynchronousTask] WARNING: task timed out: %@
%@ '%@'
[SBKAsynchronousTask] Invoking expiration handler for %@, with cancelType = %d
[SBKAsynchronousTask] beginTaskOperation %@
SBKAsynchronousTask.m
must have a finish and expiration handler specified
[SBKAsynchronousTask] Invoking completion handler for %@, result = %@, error = %@
v32@?0@8Q16^B24
, itemCount = %@
SBK_REQUEST_HANDLING_LOG
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKLoadDomainVersionRequestHandler.m
-[SBKLoadDomainVersionRequestHandler runWithCompletionHandler:]_block_invoke
finished loading domain version: domainVersion = %@%@
B24@?0B8B12@"NSError"16
com.apple.storebookkeeper.SBKSyncRequestHandler
v8@?0
@8@?0
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncRequestHandler.m
-[SBKSyncRequestHandler transaction:willProcessResponseData:]_block_invoke
will process response with responseDomainVersion = %@
SBKSyncRequestHandler.m
subclass must supply key-value pair by implementing the SBKSyncTransactionProcessing protocol
1.2.11
ERROR: deflateEnd() failed: %s
SBKZipDeflateMemoryOutputStream.m
stream is already closed.
64-bit buffer writes not supported.
subclass must implement
 %@ [%@] URL = %@, shouldAuthenticate = %d, arguments = %@, headers = %@, bodyData = %@ 
 %@ [%@]
SBKRequestBodyContentType-TextXML
SBKRequestBodyContentType-EncodeGzip
SBKRequest.m
Invalid bodyContentType requested for propertyList
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKRequest.m
ERROR: failed to serialize property list with error = %@
v32@?0@"NSString"8@"NSString"16^B24
guid
gzip
Accept-Encoding
Content-Encoding
Content-Type
POST
application/x-plist
text/xml; charset=UTF-8
text/plain; charset=UTF-8
SBKBookkeeperRequestErrorDomain
status
 [%ld]: responseDictionary = %@, (%@)
Success
Unknown server initialization error
The request format was invalid, or referenced an invalid domain
An unspecified server-side error (type 1) was encountered
The request requires an authenticated weak-token
The request deniend (punted - server too busy)
The request denied (too many recent request)
Unknown status
An unspecified server-side error (type 2) was encountered
The client's user agent is not supported
The putAll had a version mismatch
The domain specified in the request is locked
%@ (status = %@)%@
 Please enable logging and file a bug.
SBKRequestHandler.m
SBKTransaction.m
base-version
Unarchiving SBKStoreClampsController resulted in error:%@
Archiving SBKStoreClampsController resulted in error:%@
SBKPullValueRequest
SBKAdditions
SBKStoreClampsController
NSSecureCoding
NSCoding
SBKGenericKeyValuePair
NSObject
SBKTransactionController
SBKTransactionURLOperationDelegate
ISStoreURLOperationDelegate
ISURLOperationDelegate
ISOperationDelegate
SBKSyncResponseData
SBKStoreError
SBKPrivate
SBKTransactionURLOperation
SBKSyncRequestData
SBKStoreAuthenticationController
SBKLogger
SBKPushValueTransaction
SBKProcessAssertion
SBKTaskAssertion
SBKPreferences
SBKSimpleTransactionRequestHandler
SBKUniversalPlaybackPositionMetadata
NSCopying
SBKUniversalPlaybackPositionStore
SBKPlaybackPositionSyncRequestHandler
SBKTransactionControllerDelegate
SBKSyncTransactionProcessing
SBKStoreURLBagContext
NSMutableCopying
SBKMutableStoreURLBagContext
SBKPullValueTransaction
SBKPushValueResponse
SBKRequestData
SBKSyncResponse
SBKSyncTransaction
SBKSyncResponseDataKeyEnumerator
SBKAsynchronousTask
SBKLoadDomainVersionRequestHandler
SBKSyncRequestHandler
SBKZipDeflateMemoryOutputStream
SBKRequest
SBKResponse
SBKResponseStatus
SBKSyncRequest
SBKRequestHandler
SBKTransaction
SBKPullValueResponse
SBKPushValueRequest
clientItemVersionAnchor
domain
requestedKey
dictionaryWithObjects:forKeys:count:
requestURL
requestWithRequestURL:
setMethod:
propertyListBodyWithTransaction:
setBodyDataWithPropertyList:
setTransaction:
setIncludeDeviceGUID:
transaction
responseWithResponse:transaction:
requestForTransaction:
canonicalResponseForResponse:
length
bytes
appendBytes:length:
initWithCapacity:
_SBKDataByInflatingWithNoZipHeader
_SBKDataByDeflatingWithNoZipHeaderWithCompression:
SBKDataByInflatingWithNoZipHeader
SBKDataByDeflatingWithNoZipHeader
SBKDataByInflatingWithGZip
SBKDataByDeflatingWithGZip
SBKStringFromDigestData:
SBKStringByMD5HashingString:
initWithBytesNoCopy:length:encoding:freeWhenDone:
currentHandler
stringWithUTF8String:
handleFailureInFunction:file:lineNumber:description:
UTF8String
storeBookkeeperPreferences
objectForKey:withDefaultValue:
unarchivedObjectOfClass:fromData:error:
init
description
date
dateWithTimeIntervalSinceReferenceDate:
stringWithFormat:
encodeObject:forKey:
encodeDouble:forKey:
encodeInteger:forKey:
decodeIntegerForKey:
decodePropertyListForKey:
mutableCopy
removeAllObjects
setValuesForKeysWithDictionary:
accessTransactionClampsWithBlock:
decodeDoubleForKey:
pendingUserDefaultArchivedData
archivedDataWithRootObject:requiringSecureCoding:error:
setPendingUserDefaultArchivedData:
setObject:forKey:
transactionClamps
_canScheduleTransactionBasedOfNetworkingBlocked:error:
_canScheduleTransactionBasedOnBackOff:error:
_canScheduleTransactionBasedOnUserCancelledSignIn:error:
_canScheduleTransactionBasedOnAccountIdentifierCheck:error:
_canScheduleTransactionBasedOnType:error:
sharedLogger
shouldOverrideCondition:file:
logFunction:format:
clearAccountIdentifierCheckTimestamp
clearAuthenticationRequest
clearBackOff
clearNetworkingBlocked
clearUserAcceptedSyncTimestamp
clearUserCancelledSignIn
saveToUserDefaults
_keyForTransaction:
setValue:forKey:
_rightNow
setAccountIdentifierCheckTimestamp:
setAuthenticationNeededTimestamp:
authenticationNeededTimestamp
userClampErrorWithTransaction:retrySeconds:underlyingError:
setUserAcceptedSyncTimestamp:
userAcceptedSyncTimestamp
setUserCancelledSignInBackOffUntil:
timeIntervalSinceReferenceDate
logFile:lineNumber:format:
setBackOffUntil:
setNetworkingBlockedUntil:
networkingBlockedUntil
clampsKey
valueForKey:
timeIntervalSinceNow
serverClampErrorWithTransaction:retrySeconds:underlyingError:
clearTimestampForTransaction:
isNetworkingBlocked
networkingBlockedErrorWithTransaction:underlyingError:
accountIdentifierCheckTimestamp
backOffUntil
userCancelledSignInBackOffUntil
sharedClampsController
supportsSecureCoding
encodeWithCoder:
initWithCoder:
TB,R
canScheduleTransaction:error:
reset
setTimestampForTransaction:
setAccountIdentifierCheckTimestamp
setAuthenticationRequest
hasAuthenticatedTooRecentlyForTransaction:error:
setUserAcceptedSyncTimestamp
hasUserRecentlyAcceptedSync
setUserCancelledSignIn
backOffForTimeInterval:
setNetworkingBlocked
queue
setQueue:
setTransactionClamps:
nextUserCancelBackOffInterval
setNextUserCancelBackOffInterval:
.cxx_destruct
_queue
_transactionClamps
_accountIdentifierCheckTimestamp
_authenticationNeededTimestamp
_userAcceptedSyncTimestamp
_networkingBlockedUntil
_backOffUntil
_userCancelledSignInBackOffUntil
_nextUserCancelBackOffInterval
_pendingUserDefaultArchivedData
T@"NSObject<OS_dispatch_queue>",&,N,V_queue
T@"NSDictionary",&,N,V_transactionClamps
Td,N,V_accountIdentifierCheckTimestamp
Td,N,V_authenticationNeededTimestamp
Td,N,V_userAcceptedSyncTimestamp
Td,N,V_networkingBlockedUntil
Td,N,V_backOffUntil
Td,N,V_userCancelledSignInBackOffUntil
Td,N,V_nextUserCancelBackOffInterval
T@"NSData",&,N,V_pendingUserDefaultArchivedData
initWithKVSKey:kvsPayload:
decodeObjectOfClass:forKey:
pairWithKVSKey:kvsPayload:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
debugDescription
TQ,R
T#,R
T@"NSString",R,C
kvsValueDescription
timestamp
kvsKey
kvsPayload
_kvsKey
_kvsPayload
T@"NSString",R,N,V_kvsKey
T@"NSData",R,N,V_kvsPayload
initWithDomain:requestURL:forAccount:
copy
setName:
setMaxConcurrentOperationCount:
initWithStoreAccount:
defaultCenter
_networkTypeChangedNotification:
sharedInstance
addObserver:selector:name:object:
removeObserver:name:object:
_onQueue_endBackgroundTask
operations
countByEnumeratingWithState:objects:count:
setDelegate:
dealloc
isEqualToString:
_onQueue_clampsController
_onQueue_processPendingTransactions
keyValueStoreDisabledErrorWithTransaction:underlyingError:
_onQueue_cancelAllPendingTransactions:
count
_onQueue_isIdle
setTransactionContext:forKey:
scheduleTransaction:
noStoreAccountErrorWithTransaction:underlyingError:
_delegateShouldScheduleTransaction:error:
_onQueue_scheduleTransaction:isRetry:
_onQueue_transactionDidFail:withError:
transactionCancelledErrorWithTransaction:underlyingError:
_onQueue_cancelTransaction:error:
transactionCancelledErrorWithTransaction:code:underlyingError:
_storeOperationDidComplete:
setCompletionBlock:
addOperation:
delegate
_onQueue_resolveError:resolution:
_onQueue_beginBackgroundTask
backgroundTaskAssertion
_endBackgroundTask
newBackgroundTaskWithExpirationHandler:debugInfo:
invalidate
cancelAllOperations
setActiveRequest:
_onQueue_transactionDidCancel:withError:
removeObject:
objectAtIndex:
_onQueue_processCurrentTransaction
_onQueue_authenticationCanProcessTransaction:error:
newRequest
shouldAuthenticate
setShouldAuthenticate:
newURLOperationWithDelegate:
_enqueueStoreOperation:
_onQueue_canScheduleTransaction:error:
_onQueue_addPendingTransaction:
isClampError
retrySeconds
insertObject:atIndex:
addObject:
_onQueue_isEnabledForTransaction:error:
_onQueue_assertIsTransactionValid:error:
_onQueue_clampsCanScheduleTransaction:error:
isEnabled
handleFailureInMethod:object:file:lineNumber:description:
isAuthenticationValidForTransaction:error:
_delegateTransactionDidFinish:
_delegateTransactionDidFail:withError:
_resolveError:resolution:
_delegateTransactionDidCancel:withError:
storeGenericErrorWithTransaction:underlyingError:
_onQueue_currentTransactionDidFinish
processDataInResponse:withCompletionHandler:
response
responseWithURLResponse:responseDictionary:
activeRequest
isSuccess
saveAccountToLastSyncedDefaults
_processDataInResponse:
requestError
isUnsupportedClient
killSwitchErrorWithTransaction:underlyingError:
isGenericError
isValidationError
storeValidationErrorWithTransaction:underlyingError:
isAuthenticationError
saveAccountToLastFailedSyncDefaults
shouldAuthenticateIfNecessary
storeAccountSessionExpiredWithTransaction:underlyingError:
unknownErrorWithTransaction:underlyingError:
isTransactionCancelledError
_onQueue_performRetryErrorHandlingForError:
_onQueue_performCancelErrorHandlingForError:
_onQueue_performDefaultErrorHandlingForError:
isAccountsChangedError
transactionController:shouldScheduleTransaction:
delegateCancelledErrorWithTransaction:underlyingError:
transactionContextForKey:
isMainThread
_sendFinishedBlockForTransaction:success:cancelled:error:handledAsFinishedBlock:
transactionController:transactionDidFail:error:
transactionController:transactionDidCancel:error:
transactionController:transactionDidFinish:
needsAuthentication
_onQueue_processOperationOutput:operation:operationAuthenticated:
statusCode
code
userCancelledSignInErrorWithTransaction:underlyingError:
userEnteredWrongCredentialsErrorWithTransaction:underlyingError:
requestProperties
operation:failedWithError:
operation:updatedProgress:
operationFinished:
operationWillStart:
operation:didDiscoverContentLength:
operation:didReceiveResponse:
operation:finishedWithOutput:
operation:needNewBodyStream:
operation:processData:error:
operation:willSendRequest:
operation:sanitizedStringForString:
operation:dispositionForAuthenticationChallenge:
operation:credentialForAuthenticationChallenge:
URLCache
URLCacheID
metricsLoadURLSessionDuration
metricsLoadURLSamplingPercentage
metricsLoadURLSamplingPercentageCachedResponses
T@"NSNumber",R,N
operation:didAuthenticateWithDSID:
operation:shouldAuthenticateWithContext:responseHandler:
operation:shouldSetStoreFrontID:
account
T@"SSAccount",R
initWithDomain:requestURL:
setDomain:
setRequestURL:
setEnabled:
isIdle
scheduleTransaction:withTransactionFinishedBlock:
cancelScheduledTransaction:
cancelAllTransactions
cancelAllTransactionsCancelCode:
_beginBackgroundTask
authenticationController
setAuthenticationController:
setShouldAuthenticateIfNecessary:
currentTransaction
setCurrentTransaction:
operationQueue
setOperationQueue:
pendingTransactions
setPendingTransactions:
isResolvingError
setIsResolvingError:
setBackgroundTaskAssertion:
networkTypeObserver
setNetworkTypeObserver:
conflictResolutionAttempts
setConflictResolutionAttempts:
_enabled
_shouldAuthenticateIfNecessary
_isResolvingError
_delegate
_domain
_requestURL
_account
_authenticationController
_currentTransaction
_operationQueue
_pendingTransactions
_backgroundTaskAssertion
_networkTypeObserver
_conflictResolutionAttempts
T@"NSOperationQueue",&,N,V_operationQueue
T@"NSMutableArray",&,N,V_pendingTransactions
T@"SBKTransaction",&,N,V_currentTransaction
TB,N,V_isResolvingError
T@"SBKTaskAssertion",&,N,V_backgroundTaskAssertion
T@,W,N,V_networkTypeObserver
Tq,N,V_conflictResolutionAttempts
T@"<SBKTransactionControllerDelegate>",W,N,V_delegate
T@"NSString",R,C,N,V_domain
T@"NSURL",R,N,V_requestURL
T@"SSAccount",R,N,V_account
enabled
TB,R,N,GisEnabled,V_enabled
idle
TB,R,N,GisIdle
T@"SBKStoreAuthenticationController",&,N,V_authenticationController
TB,N,V_shouldAuthenticateIfNecessary
initWithTransaction:responseDictionary:response:
dictionary
array
_deserializeResponseDictionary:response:
numberWithUnsignedInteger:
objectForKey:
arrayWithObjects:count:
containsObject:
stringValue
deserializedResponseBodyWithTransaction:responseDictionary:response:
payloadDataForUpdateResponseKey:
syncAnchor
updatedKeys
conflictedKeys
deletedKeys
successfullyUpdatedKeys
successfullyDeletedKeys
responseOpEntiesByKey
setResponseOpEntiesByKey:
_transaction
_syncAnchor
_updatedKeys
_conflictedKeys
_deletedKeys
_successfullyUpdatedKeys
_successfullyDeletedKeys
_responseOpEntiesByKey
T@"NSMutableDictionary",&,N,V_responseOpEntiesByKey
T@"SBKSyncTransaction",R,N,V_transaction
T@"NSString",R,C,N,V_syncAnchor
T@"NSArray",R,N,V_updatedKeys
T@"NSArray",R,N,V_conflictedKeys
T@"NSArray",R,N,V_deletedKeys
T@"NSArray",R,N,V_successfullyUpdatedKeys
T@"NSArray",R,N,V_successfullyDeletedKeys
appendString:
enumerateObjectsUsingBlock:
localizedDescription
copyWithZone:
userInfo
doubleValue
isRecoverableError
isTransactionMissingInformationError
previousStoreAccountName
currentStoreAccountName
T@"SBKTransaction",&,N,V_transaction
TB,R,N
T@"NSString",R,C,N
Td,R,N
dictionaryWithObject:forKey:
errorWithDomain:code:userInfo:
keyValueStoreErrorWithCode:localizedDescription:transaction:underlyingError:
mainBundle
localizedStringForKey:value:table:
numberWithDouble:
storeLoggedOutErrorWithPreviousStoreAccountName:transaction:underlyingError:
storeAccountMismatchErrorWithPreviousStoreAccountName:currentStoreAccountName:transaction:underlyingError:
transactionMissingDomainErrorWithTransaction:underlyingError:
transactionMissingURLErrorWithTransaction:underlyingError:
transactionTimeoutErrorWithTransaction:underlyingError:
_init
copyRequestProperties
setRequestProperties:
setShouldMessageMainThread:
setQueuePriority:
responseDataProvider
setDataProvider:
setSBKRequest:
setNeedsAuthentication:
defaultStore
activeAccount
initWithAccount:
setPromptStyle:
setAllowsSilentAuthentication:
setAuthenticationContext:
operationWithRequest:delegate:
SBKRequest
_shouldAuthenticate
_SBKRequest
TB,N,V_shouldAuthenticate
T@"SBKRequest",&,N,V_SBKRequest
syncTransaction
keysToUpdate
_serializableUpdateItemPayloadDictionaryForKey:
keysToDelete
_serializableDeleteItemPayloadDictionaryForKey:
_serializableConflictDetectionValue
arrayByAddingObjectsFromArray:
_needsConflictDetection
conflictDetectionType
numberWithInteger:
conflictDetectionOrdinalForKey:
longLongValue
keyValuePairForUpdatedKey:
_serializableConflictDetectionOrdinalForKey:
serializableRequestBodyPropertyList
storeAccount
uniqueIdentifier
lastSyncedAccountIdentifier
shouldForceAuthenticationForTransaction:
authenticationErrorsForTransaction:
accountName
lastSyncedAccountName
numberWithLongLong:
clearLastSyncnedAccount
lastFailedSyncAccountIdentifier
lastFailedSyncAccountName
_storeAccount
T@"SSAccount",R,N,V_storeAccount
setDefaultFormatterBehavior:
setDateFormat:
stringFromDate:
integerValue
verboseLoggingEnabled
infoDictionary
processInfo
environment
setFilter:
setBool:forKey:
registerDefaultsIfKeyNotSet:registrationBlock:
_updateSettingsFromPreferences:
initWithPattern:options:error:
standardUserDefaults
stringByAppendingFormat:
boolForKey:
setRuntimeOverride:
removeObserver:
closeFile
fileExistsAtPath:
createFileAtPath:contents:attributes:
fileHandleForWritingAtPath:
runtimeOverride
lastPathComponent
stringByDeletingPathExtension
rangeOfString:options:
rangeOfFirstMatchInString:options:range:
lock
unlock
logString:
initWithFormat:arguments:
rangeOfString:
initWithFormat:
dataUsingEncoding:
writeData:
performLoggingBlock:
stringByAppendingString:
stringByReplacingOccurrencesOfString:withString:
debugLoggingEnabled
setAuxPath:
auxPath
addRuntimeOverride:
removeRuntimeOverride:
filter
_auxPath
_fileHandle
_filter
_runtimeOverride
_pid
_procName
_runtimeOverrideRegex
_lock
T@"NSString",C,N,V_filter
T@"NSString",C,N,V_runtimeOverride
pushKeyValueRequestURL
conflictItemValuePayload
conflictItemKey
_resolveConflictBetweenClientPayloadPair:andServerPayloadPair:
conflictItemVersionAnchor
domainVersion
initWithStoreBagContext:clientItemPayloadPair:clientItemVersionAnchor:
clientItemPayloadPair
requestItemPayloadPair
requestItemVersionAnchor
success
resultItemPayloadPair
resultItemVersionAnchor
resultDomainVersion
_isRechedulable
_success
_clientItemPayloadPair
_clientItemVersionAnchor
_requestItemPayloadPair
_requestItemVersionAnchor
_resultItemPayloadPair
_resultItemVersionAnchor
_resultDomainVersion
T@"<SBKKeyValuePayloadPair>",R,N,V_clientItemPayloadPair
T@"NSString",R,N,V_clientItemVersionAnchor
T@"<SBKKeyValuePayloadPair>",R,N,V_requestItemPayloadPair
T@"NSString",R,N,V_requestItemVersionAnchor
TB,R,N,V_success
T@"<SBKKeyValuePayloadPair>",R,N,V_resultItemPayloadPair
T@"NSString",R,N,V_resultItemVersionAnchor
T@"NSString",R,N,V_resultDomainVersion
processName
initWithPID:flags:reason:name:withHandler:
setBkProcessAssertion:
_expireBackgroundTask
addObserverForName:object:queue:usingBlock:
setExpirationObserver:
setInvalidationHandler:
_onQueueSetBkProcessAssertion:
initWithExpirationBlock:debugDescription:
bkProcessAssertion
identifier
expirationObserver
_expirationBlock
_identifier
_bkProcessAssertion
_expirationObserver
TQ,R,N,V_identifier
T@"BKSProcessAssertion",&,N,V_bkProcessAssertion
T@,&,N,V_expirationObserver
initWithExpirationHandler:debugInfo:
performExpirationHandler
_expireHandler
_debugInfo
_processAssertion
componentsJoinedByString:
postNotificationName:object:userInfo:
numberWithBool:
_preferencesDidChange
syncRequestURL
transactionController
cancelWithError:
initWithBagContext:
scheduleTransaction:finishedBlock:
timeout
cancel
canceled
_canceled
_transactionController
T@"SBKTransactionController",R,N,V_transactionController
TB,R,N,V_canceled
sharedApplication
metadataWithItemIdentifier:keyValueStorePayload:failuresOkay:
decodeBoolForKey:
encodeBool:forKey:
initAsTestableItem
itemIdentifier
bookmarkTime
hasBeenPlayed
playCount
setItemIdentifier:
setTimestamp:
setBookmarkTime:
setHasBeenPlayed:
setPlayCount:
unsignedLongLongValue
setObject:forKeyedSubscript:
distantPast
initWithObjectsAndKeys:
allKeys
setWithArray:
enumerateValuesForProperties:usingBlock:
keyValueStoreItemIdentifierForItem:
boolValue
initForReadingFromData:error:
setDecodingFailurePolicy:
setWithObjects:
decodeObjectOfClasses:forKey:
finishDecoding
dictionaryWithObjects:forKeys:
keyValueStorePayload
_testableMetadataItem_1
keyValueStoreItemIdentifierForUniqueStoreID:itemTitle:albumName:itemArtistName:feedURL:feedGUID:
metadataWithValuesFromDataSourceItem:
metadataWithItemIdentifier:bookmarkTime:bookmarkTimestamp:hasBeenPlayed:playCount:
metadataWithItemIdentifier:keyValueStorePayload:
_hasBeenPlayed
_itemIdentifier
_timestamp
_bookmarkTime
_playCount
T@"NSString",C,N,V_itemIdentifier
Td,N,V_timestamp
Td,N,V_bookmarkTime
TB,N,V_hasBeenPlayed
TQ,N,V_playCount
setTimeStyle:
setDateStyle:
dictionaryWithCapacity:
string
absoluteString
initWithDomain:dataSource:automaticSynchronizeOptions:accountIdentifier:isActive:
distantFuture
setDateToFireNextTimer:
_updateAutorefreshRateSettingAndRestartTimer:
_onQueueLoadBagContextWithCompletionHandler:
mainQueue
_updateForStoreAccountsChange
initWithInitialUpdateDelay:
_onQueueStopTimer
_onQueueStartNewTimerWithTimeIntervalSinceNow:
bagLookupTask
currentTask
lookupDomainVersionTask
timer
_onQueueSuspendTimer
_automaticallySynchronizeOnBecomeActive
_onQueueResumeTimer
_onQueueUpdateTimerForActiveChanges
_automaticallySynchronizeLocalChangesOnResignActive
_onQueueSynchronizeWithAutosynchronizeMask:withCompletionBlock:
_onQueueUpdateTimerForAutomaticSyncOptionChanges
automaticSynchronizeOptions
setAutomaticSynchronizeOptions:
_onQueueSynchronizeImmediatelyWithCompletionHandler:
_onQueuePushMetadataItem:completionBlock:
_onQueuePullMetadataItemWithItemIdentifier:completionBlock:
domainDisabled
_accountForSyncing
_onQueueLoadRemoteDomainVersionWithCompletionBlock:
addTaskCompletionBlock:
initWithHandlerQueue:timeout:debugDescription:
setExpirationHandler:
setFinishedHandler:
error
invokeTaskCompletionBlocksWithBlock:
finishTaskOperationWithResult:error:
beginTaskOperation
responseDomainVersion
runWithCompletionHandler:
firstObject
removeObjectAtIndex:
_onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:
cancelType
result
postNotificationName:object:
_onQueueStartNewTimer
_onQueueRunNextPendingTaskBlock
initWithDataSource:bagContext:accountIdentifier:
synchronizeWithCompletionHandler:
initWithStoreBagContext:requestedKey:clientItemPayloadPair:clientItemVersionAnchor:
accountWithUniqueIdentifier:
pollingIntervalInSeconds
_effectiveAutorefreshRate
_updateSettingsFromLoadedBagContext:
contextWithBagType:
URLBagForContext:
loadBagContextFromURLBag:domain:completionBlock:
floatValue
dateToFireNextTimer
isEqualToDate:
_timerFired:
dateWithTimeIntervalSinceNow:
scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
setTimer:
_timerIsStopped
_onQueueScheduleTimer
deprecated_setDataSource:
initWithDomain:dataSource:automaticSynchronizeOptions:isActive:
becomeActive
resignActive
setHasLocalChangesToSync:
hasLocalChangesToSync
setAutomaticallySynchronizeLocalChangesOnResignActive:
automaticallySynchronizeLocalChangesOnResignActive
setAutomaticallySynchronizeOnBecomeActive:
automaticallySynchronizeOnBecomeActive
synchronizeImmediatelyWithCompletionHandler:
pushMetadataItem:completionBlock:
pullMetadataItemWithItemIdentifier:completionBlock:
synchronizeImmediatelyWithCompletionBlock:
checkForAvailabilityWithCompletionBlock:
loadRemoteDomainVersionWithCompletionBlock:
loadBagContextWithCompletionBlock:
dataSource
setCurrentTask:
setLookupDomainVersionTask:
setBagLookupTask:
currentTaskRequestHandler
setCurrentTaskRequestHandler:
_isActive
_hasLocalChangesToSync
_pendingTaskBlocks
_accountIdentifier
_automaticSynchronizeOptions
_initialAutosyncInterval
_pollingLimitFromBag
_autorefreshInterval
_refreshTimerActive
_accountsObserver
_prefsObserver
_dataSource
_currentTask
_lookupDomainVersionTask
_bagLookupTask
_currentTaskRequestHandler
_dateToFireNextTimer
_timer
T@"SBKAsynchronousTask",&,N,V_currentTask
T@"SBKAsynchronousTask",&,N,V_lookupDomainVersionTask
T@"SBKAsynchronousTask",&,N,V_bagLookupTask
T@"SBKRequestHandler",&,N,V_currentTaskRequestHandler
T@"NSDate",&,N,V_dateToFireNextTimer
T@"NSTimer",&,N,V_timer
T@"<SBKUniversalPlaybackPositionDataSource>",R,W,N,V_dataSource
TQ,N
TB,N
initWithBagContext:accountIdentifier:
setDataSource:
setMetadataItemsFromDataSource:
setMetadataItemsToCommitToDataSource:
setMetadataItemsToCommitToKVSStorage:
setResponseMetadataItemsToCommitToDataSource:
setResponseMetadataItemsMergedToCommitBackToKVSStorage:
setKvsController:
setDataSourceTransactionContext:
setCurrentKVSTransaction:
metadataItemsFromDataSource
responseMetadataItemsToCommitToDataSource
responseMetadataItemsMergedToCommitBackToKVSStorage
clearTransactionResponseData
cancelUniversalPlaybackPositionTransaction:
dataSourceTransactionContext
syncInProgress
setSyncInProgress:
beginTransactionWithItemsToSyncEnumerationBlock:
_shouldStop
_dataSourceCancelTransaction
metadataItemsToCommitToKVSStorage
newKVSSyncTransactionWithUpdatedMetadataItemIdentifiers:processConflicts:
currentKVSTransaction
_synchronouslyRunKVSTransaction:
_mergeMetadataItemsFromSyncResponse
metadataItemsToCommitToDataSource
objectEnumerator
nextObject
commitUniversalPlaybackPositionTransaction:domainVersion:metadataEnumerationBlock:
fatalSyncError
setCanceled:
kvsController
_signalKVSTransactionCompletion:withError:
_synchronize:
removeObjectForKey:
bagContext
lastSyncedDomainVersion
initWithStoreBagContext:syncAnchor:keysToUpdate:keysToDelete:conflictDetectionType:
setTransactionProcessor:
initWithCondition:
lockWhenCondition:beforeDate:
setFatalSyncError:
unlockWithCondition:
_signalKVSTransactionCompletion:
transaction:willProcessResponseData:
transaction:didProcessResponseData:
transaction:processUpdatedKey:data:conflict:isDirty:
_mergeConflictedItemFromSyncResponse:
transaction:processDeletedKey:isDirty:
transaction:keyValuePairForUpdatedKey:
transaction:syncAnchorForTransactionSyncAnchor:
transaction:keysForTransactionForTransactionKeysToUpdate:
transaction:keysForTransactionForTransactionKeysToDelete:
transaction:conflictDetectionTypeForTransactionDetectionType:
transaction:conflictDetectionOrdinalForKey:
initWithDataSource:bagContext:
overrideSyncAnchor
setOverrideSyncAnchor:
_syncOperationQueue
_syncInProgress
_kvsController
_dataSourceTransactionContext
_metadataItemsFromDataSource
_metadataItemsToCommitToDataSource
_metadataItemsToCommitToKVSStorage
_responseMetadataItemsToCommitToDataSource
_responseMetadataItemsMergedToCommitBackToKVSStorage
_currentKVSTransaction
_fatalSyncError
_overrideSyncAnchor
T@"SBKTransactionController",&,N,V_kvsController
T@"<SBKUniversalPlaybackPositionDataSource>",&,N,V_dataSource
T@"<SBKUniversalPlaybackPositionTransactionContext>",&,N,V_dataSourceTransactionContext
T@"NSMutableDictionary",&,N,V_metadataItemsFromDataSource
T@"NSDictionary",&,N,V_metadataItemsToCommitToDataSource
T@"NSDictionary",&,N,V_metadataItemsToCommitToKVSStorage
T@"NSMutableDictionary",&,N,V_responseMetadataItemsToCommitToDataSource
T@"NSMutableDictionary",&,N,V_responseMetadataItemsMergedToCommitBackToKVSStorage
T@"SBKSyncTransaction",&,N,V_currentKVSTransaction
TB,N,V_syncInProgress
TB,N,V_canceled
T@"NSError",&,N,V_fatalSyncError
T@"NSString",&,N,V_overrideSyncAnchor
enumerateKeysAndObjectsUsingBlock:
_findFirstValueInBag:keyEnumerator:valueTransformer:defaultValue:completionBlock:
loadValueForKey:completionBlock:
loadWithCompletionBlock:
initWithBag:domain:
URLWithString:
enumerateRequestURLBagKeysWithBlock:
_initWithDomain:syncRequestURL:domainDisabled:
UPPDomainIdentifier
ExtrasDomainIdentifier
mutableCopyWithZone:
setPollingIntervalInSeconds:
setSyncRequestURL:
setPushKeyValueRequestURL:
pullKeyValueRequestURL
setPullKeyValueRequestURL:
pushAllKeyValueRequestURL
setPushAllKeyValueRequestURL:
pullAllKeyValueRequestURL
setPullAllKeyValueRequestURL:
setDomainDisabled:
setBag:
_domainDisabled
_pollingIntervalInSeconds
_syncRequestURL
_pushKeyValueRequestURL
_pullKeyValueRequestURL
_pushAllKeyValueRequestURL
_pullAllKeyValueRequestURL
_bag
T@"SSURLBag",&,N,V_bag
T@"NSString",C,N,V_domain
T@"NSURL",&,N,V_syncRequestURL
T@"NSURL",&,N,V_pushKeyValueRequestURL
T@"NSURL",&,N,V_pullKeyValueRequestURL
T@"NSURL",&,N,V_pushAllKeyValueRequestURL
T@"NSURL",&,N,V_pullAllKeyValueRequestURL
TB,N,V_domainDisabled
Td,N,V_pollingIntervalInSeconds
T@"NSString",C,D,N
T@"NSURL",&,D,N
TB,D,N
Td,D,N
itemValuePayload
itemKey
itemVersion
_requestedKey
T@"NSString",R,C,N,V_requestedKey
responseWithResponse:
deserializeResponseBodyWithTransaction:
responseDictionary
objectForKeyedSubscript:
_domainVersion
_conflictItemValuePayload
_conflictItemKey
_conflictItemVersionAnchor
T@"NSString",R,N,V_domainVersion
T@"NSData",R,N,V_conflictItemValuePayload
T@"NSString",R,N,V_conflictItemKey
T@"NSString",R,N,V_conflictItemVersionAnchor
initWithTransaction:
syncResponseData
_syncResponseData
T@"SBKSyncResponseData",R,N,V_syncResponseData
initWithSyncRequestURL:domain:syncAnchor:keysToUpdate:keysToDelete:conflictDetectionType:
type
transactionProcessor
_validateTransactionProcessor:
initWithResponseData:
enumerateKeysInResponseForTransaction:completionBlock:
_keysToUpdate
_keysToDelete
_conflictDetectionType
_transactionProcessor
_type
Tq,R,N,V_type
Tq,R,N,V_conflictDetectionType
T@"NSURL",R,N,V_syncRequestURL
T@"NSArray",R,N,V_keysToUpdate
T@"NSArray",R,N,V_keysToDelete
T@"<SBKSyncTransactionProcessing>",W,N,V_transactionProcessor
_processNextKey
_processUpdatedKey:isConflict:isDirty:
_processDeletedKey:isDirty:
responseData
setResponseData:
completionBlock
resolvedConflictsNeedSyncToServer
setResolvedConflictsNeedSyncToServer:
updatedKeysEnumerator
setUpdatedKeysEnumerator:
conflictedKeysEnumerator
setConflictedKeysEnumerator:
deletedKeysEnumerator
setDeletedKeysEnumerator:
_resolvedConflictsNeedSyncToServer
_responseData
_completionBlock
_updatedKeysEnumerator
_conflictedKeysEnumerator
_deletedKeysEnumerator
T@"SBKSyncResponseData",&,N,V_responseData
T@"SBKSyncTransaction",&,N,V_transaction
T@?,C,N,V_completionBlock
TB,N,V_resolvedConflictsNeedSyncToServer
T@"NSEnumerator",&,N,V_updatedKeysEnumerator
T@"NSEnumerator",&,N,V_conflictedKeysEnumerator
T@"NSEnumerator",&,N,V_deletedKeysEnumerator
setCompletions:
_invalidateTimer
_invalidateAssertion:
setCancelType:
setResult:
setError:
_onQueueFireExpirationHandlerIfNecesary
finishedHandler
expirationHandler
setTaskAssertion:
completions
endTaskOperation
taskAssertion
_debugDescription
_handlerQueue
_timeoutTimer
_taskInvalidationDisabled
_timeout
_cancelType
_result
_error
_expirationHandler
_finishedHandler
_taskAssertion
_completions
T@,&,N,V_result
T@"NSError",&,N,V_error
T@"SBKTaskAssertion",&,N,V_taskAssertion
T@"NSMutableArray",&,N,V_completions
T@?,C,N,V_finishedHandler
T@?,C,N,V_expirationHandler
Ti,N,V_cancelType
loadsRemoteItemCount
responseUpdatedKeys
startTransactionWithSyncAnchor:keysToUpdate:keysToDelete:finishedBlock:
setLoadsRemoteItemCount:
responseItemCount
itemCount
setItemCount:
_loadsRemoteItemCount
_responseItemCount
_itemCount
TQ,N,V_itemCount
TB,N,V_loadsRemoteItemCount
TQ,R,N,V_responseItemCount
_onQueue_clearTransactionResponseData
setResponseDomainVersion:
responseDeletedKeys
responseConflictedKeys
responseDataForResponseKey:
_overrideResponseDomainVersion
_responseUpdatedKeys
_responseDeletedKeys
_responseConflictedKeys
_responseDataByKey
T@"SBKSyncResponseData",R,N,V_responseData
T@"NSString",C,N
T@"NSArray",R,N,V_responseUpdatedKeys
T@"NSArray",R,N,V_responseDeletedKeys
T@"NSArray",R,N,V_responseConflictedKeys
initWithBufferingSize:compressionType:
writeBuffer:size:
close
data
dataByDeflatingData:
deflatedData
zstream
_outputBuffer
_bufferingSize
raise:format:
initWithRequestURL:
_defaultHeaderFields
setShouldPostFooterSectionChanged:
setShouldProcessDialogs:
setShouldTriggerDownloads:
setResponseDataProvider:
_methodStringForMethod:
bodyContentEncodingType
bodyContentType
dataWithPropertyList:format:options:error:
setBodyData:
initWithURL:
setHTTPMethod:
setValue:forHTTPHeaderField:
setValue:forRequestParameter:
includeDeviceGUID
guid
setHTTPBody:
timeoutInterval
setTimeoutInterval:
acceptsGzipEncoding
_contentEncodingTypeStringForBodyContentEncodingType:
_contentTypeStringForBodyContentType:
descriptionWithoutHeaderFields
setValue:forHeaderField:
setValue:forArgument:
newURLOperation
isConcurrent
method
bodyData
_action
_bodyData
_bodyContentType
_headers
_arguments
_method
_responseDataProvider
_concurrent
_includeDeviceGUID
concurrent
TB,R,N,GisConcurrent,V_concurrent
Tq,N,V_method
TB,N,V_includeDeviceGUID
T@"NSData",&,N,V_bodyData
T@"ISDataProvider",&,N,V_responseDataProvider
allHeaderFields
MIMEType
initWithCode:headerFields:responseDictionary:MIMEType:error:
responseStatusForStatusCodeNumber:
isPuntedError
initWithURLResponse:responseDictionary:
responseCode
responseHeaderFields
consoleDescription
isRecoverable
isError
shouldFileRadar
responseWithCode:headerFields:responseDictionary:MIMEType:error:
responseStatus
_responseDictionary
_responseCode
_responseHeaderFields
_retrySeconds
_MIMEType
_responseStatus
T@"NSString",R,N,V_MIMEType
T@"SBKResponseStatus",R,N,V_responseStatus
TQ,R,N,V_responseCode
T@"NSDictionary",R,N,V_responseHeaderFields
T@"NSDictionary",R,N,V_responseDictionary
T@"NSError",R,N,V_error
Tq,R,N
T@"NSError",R,N
Td,R,N,V_retrySeconds
dictionaryWithObjectsAndKeys:
initWithDomain:code:userInfo:
initWithStatus:isRecoverable:isError:consoleDescription:shouldFileRadar:
_isRecoverable
_isError
_shouldFileRadar
_isPuntedError
_statusCode
_consoleDescription
Tq,R,N,V_statusCode
T@"NSString",R,C,N,V_consoleDescription
TB,R,N,V_isRecoverable
TB,R,N,V_isError
TB,R,N,V_shouldFileRadar
TB,R,N,V_isPuntedError
_bagContext
T@"SBKStoreURLBagContext",R,N,V_bagContext
setUserInfo:
_activeRequest
_userInfo
T@"NSMutableDictionary",&,N,V_userInfo
T@"NSURL",&,N,V_requestURL
T@"SBKRequest",&,N,V_activeRequest
defaultIdentityStore
userIdentitiesForManageableAccountsWithError:
accountDSID
musicLibraryForUserAccount:
databasePath
_itemKey
_itemVersion
_itemValuePayload
T@"NSString",R,N,V_itemKey
T@"NSString",R,N,V_itemVersion
T@"NSData",R,N,V_itemValuePayload
@24@0:8@16
@16@0:8
@24@0:8Q16
B16@0:8
v24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
v16@0:8
v24@0:8@?16
B32@0:8@16^@24
v24@0:8d16
d16@0:8
@"NSObject<OS_dispatch_queue>"
@"NSDictionary"
@"NSData"
@32@0:8@16@24
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@"NSString"
v32@0:8@16@24
v32@0:8@"ISOperation"16@"NSError"24
v32@0:8@"ISOperation"16@"SSOperationProgress"24
v24@0:8@"ISOperation"16
B40@0:8@16@24^@32
q32@0:8@16@24
v32@0:8@"ISURLOperation"16@"NSNumber"24
v32@0:8@"ISURLOperation"16@"NSURLResponse"24
v32@0:8@"ISURLOperation"16@24
@"NSInputStream"32@0:8@"ISURLOperation"16@"NSURLRequest"24
B40@0:8@"ISURLOperation"16@"NSMutableData"24^@32
v32@0:8@"ISURLOperation"16@"NSMutableURLRequest"24
@"NSString"32@0:8@"ISURLOperation"16@"NSString"24
q32@0:8@"ISURLOperation"16@"NSURLAuthenticationChallenge"24
@"NSURLCredential"32@0:8@"ISURLOperation"16@"NSURLAuthenticationChallenge"24
@"NSURLCache"16@0:8
@"NSNumber"16@0:8
v40@0:8@16@24@?32
B32@0:8@16@24
v32@0:8@"ISStoreURLOperation"16@"NSNumber"24
v40@0:8@"ISStoreURLOperation"16@"SSAuthenticationContext"24@?<v@?@"SSAuthenticateResponse"@"NSError">32
B32@0:8@"ISStoreURLOperation"16@"NSString"24
@"SSAccount"16@0:8
@40@0:8@16@24@32
v20@0:8B16
v32@0:8@16@?24
v24@0:8q16
v28@0:8@16i24
v28@0:8@16B24
v32@0:8@16^@24
v36@0:8@16@24B32
B48@0:8@16B24B28@32^B40
q16@0:8
@"<SBKTransactionControllerDelegate>"
@"NSURL"
@"SSAccount"
@"SBKStoreAuthenticationController"
@"SBKTransaction"
@"NSOperationQueue"
@"NSMutableArray"
@"SBKTaskAssertion"
@"SBKSyncTransaction"
@"NSArray"
@"NSMutableDictionary"
@24@0:8^{_NSZone=}16
@48@0:8q16@24@32@40
@48@0:8@16@24@32@40
@40@0:8@16q24@32
@40@0:8@16d24@32
@"SBKRequest"
v36@0:8r*16i24@28
v32@0:8r*16@24
@"NSFileHandle"
@"NSRegularExpression"
@"NSLock"
@"<SBKKeyValuePayloadPair>"
@32@0:8@?16@24
@"BKSProcessAssertion"
@"SBKProcessAssertion"
v28@0:8B16@20
@"SBKTransactionController"
@64@0:8q16@24@32@40@48@56
@52@0:8@16d24d32B40Q44
@36@0:8@16@24B32
v24@0:8Q16
@44@0:8@16@24Q32B40
@52@0:8@16@24Q32@40B48
@24@0:8d16
v32@0:8Q16@?24
v40@0:8@16@?24@?32
@"NSNumber"
@"<SBKUniversalPlaybackPositionDataSource>"
@"SBKAsynchronousTask"
@"SBKRequestHandler"
@"NSDate"
@"NSTimer"
B40@0:8@16@24@32
v40@0:8@16@24@32
B40@0:8@"SBKTransactionController"16@"SBKTransaction"24@"SBKStoreError"32
v40@0:8@"SBKTransactionController"16@"SBKTransaction"24@"SBKStoreError"32
v32@0:8@"SBKTransactionController"16@"SBKTransaction"24
B32@0:8@"SBKTransactionController"16@"SBKTransaction"24
v52@0:8@16@24@32B40^B44
v40@0:8@16@24^B32
q32@0:8@16q24
v32@0:8@"SBKSyncTransaction"16@"SBKSyncResponseData"24
v52@0:8@"SBKSyncTransaction"16@"NSString"24@"NSData"32B40^B44
v40@0:8@"SBKSyncTransaction"16@"NSString"24^B32
@"<SBKKeyValuePayloadPair>"32@0:8@"SBKSyncTransaction"16@"NSString"24
@"NSString"32@0:8@"SBKSyncTransaction"16@"NSString"24
@"NSArray"32@0:8@"SBKSyncTransaction"16@"NSArray"24
q32@0:8@"SBKSyncTransaction"16q24
@"NSNumber"32@0:8@"SBKSyncTransaction"16@"NSString"24
B24@0:8^@16
i24@0:8@16
@28@0:8@16B24
@"<SBKUniversalPlaybackPositionTransactionContext>"
@"NSError"
v56@0:8@16@24@?32@40@?48
@"SSURLBag"
@"SBKSyncResponseData"
@64@0:8@16@24@32@40@48q56
@56@0:8@16@24@32@40q48
@"<SBKSyncTransactionProcessing>"
v36@0:8@16B24^B28
v32@0:8@16^B24
@?16@0:8
@"NSEnumerator"
v20@0:8i16
i16@0:8
@"NSObject<OS_dispatch_source>"
v48@0:8@16@24@32@?40
@28@0:8i16Q20
B32@0:8r*16Q24
@"NSMutableData"
{z_stream_s="next_in"*"avail_in"I"total_in"Q"next_out"*"avail_out"I"total_out"Q"msg"*"state"^{internal_state}"zalloc"^?"zfree"^?"opaque"^v"data_type"i"adler"Q"reserved"Q}
@24@0:8q16
@"ISDataProvider"
@56@0:8Q16@24@32@40@48
@"SBKResponseStatus"
@44@0:8q16B24B28@32B40
@"SBKStoreURLBagContext"
domain
since-version
ERROR: unable to zip large data of size ~%.3f GB
deflateInit2() failed: %s
deflate() failed: %s
0123456789abcdef
MSVHasher+Algorithms.h
void _MSVHasherAppendBytes(MSVHasher * _Nonnull, const void * _Nonnull, size_t)
Cannot append to unknown hasher algorithm
NSString * _Nonnull _MSVHashGetDigest(MSVHash)
Cannot obtain digest from unknown hasher algorithm
MSVHash _MSVHasherFinalize(MSVHasher * _Nonnull)
Cannot finalize unknown hasher algorithm
SBKSyncClamps
com.apple.amp
+[SBKStoreClampsController sharedClampsController]_block_invoke
SBKStoreClampsController.m
Unarchiving SBKStoreClampsController resulted in error:%@
Current Date = %@,
accountIdentifierCheckTimestamp = %@,
authenticationNeededTimestamp = %@,
userAcceptedSyncTimestamp = %@,
networkingBlockedUntil = %@,
backOffUntil= %@,
userCancelledSignInBackOffUntil = %@
SBKTransactionClamps
SBAccountIdentifierCheckTimestamp
SBKAuthenticationNeededTimestamp
SBKUserAcceptedSyncTimestamp
SBKNetworkingBlockedUntil
SBKUserCancelledSignInBackOffUntil
Version
SBKVersion
v16@?0@"NSMutableDictionary"8
-[SBKStoreClampsController saveToUserDefaults]_block_invoke
Archiving SBKStoreClampsController resulted in error:%@
SBK_KVSTORE_CLAMPS_LOG
-[SBKStoreClampsController reset]
Reseting Clamps
-[SBKStoreClampsController hasAuthenticatedTooRecentlyForTransaction:error:]
Drop transaction: %@ -- Too soon since last authentication: %f [%fs]
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKStoreClampsController.m
[StoreBookkeeper] SBKStoreClampsController - will avoid presenting authentication for %02llu:%02llu:%2f
-[SBKStoreClampsController _canScheduleTransactionBasedOnType:error:]
Drop transaction: %@ -- Interval since last request: %f [%fs]
-[SBKStoreClampsController _canScheduleTransactionBasedOfNetworkingBlocked:error:]
Drop transaction: <%p> -- Networking BlockedUntil: %@
-[SBKStoreClampsController _canScheduleTransactionBasedOnAccountIdentifierCheck:error:]
Drop transaction: <%p> -- AccountIdentifierCheck != 0
-[SBKStoreClampsController _canScheduleTransactionBasedOnBackOff:error:]
Drop transaction: <%p> -- BackOff until: %@ [%fs]
-[SBKStoreClampsController _canScheduleTransactionBasedOnUserCancelledSignIn:error:]
Drop transaction: <%p> -- userCancelledBackOff until: %@ [%fs]
kvsKey
kvsPayload
%@: key=%@, payload=%@
com.apple.SBKTransactionController
com.apple.SBKTransactionController.operationQueue
SBKTransactionFinishedBlock
[%@ _beginBackgroundTask]
SBK_KVSTORE_LOG
-[SBKTransactionController _onQueue_cancelTransaction:error:]
Cancelling transaction: %@ -- isCurrentTransaction: %@
-[SBKTransactionController _onQueue_processPendingTransactions]
No Pending Transactions
Transaction In progress: %@
-[SBKTransactionController _onQueue_processCurrentTransaction]
Processing Transaction: %@
-[SBKTransactionController _onQueue_scheduleTransaction:isRetry:]
Scheduling Transaction: %@
Holding transaction %@ (due to clamps) %.2f seconds
-[SBKTransactionController _onQueue_canScheduleTransaction:error:]
Unable to schedule (due to clamps %@) transaction %@.
SBKTransactionController.m
No domain specified in transaction %@!
No url specified in transaction %@!
-[SBKTransactionController _onQueue_currentTransactionDidFinish]
Transaction Finished: %@
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKTransactionController.m
Transaction Failed: %@ -- Error: %@
-[SBKTransactionController _onQueue_transactionDidCancel:withError:]_block_invoke
-[SBKTransactionController _onQueue_processOperationOutput:operation:operationAuthenticated:]
Not using deserialized response because it is not a dictionary as expected!
Deserialized server response: %@
Deserialized server response produced response data: %@
Generic error indicated by response responseDictionary: %@
Validation error indicated by response responseDictionary: %@
Unknown error in response: %@
Not using deserialized responseDictionary because transactions have been cancelled!
Delegate calls should be done on the main thread
transaction controllers with delegates can not use transaction finish blocks
User cancelled sign-in
User entered wrong credentials
-[SBKTransactionController operation:failedWithError:]
Operation failedWithError: %@ -- inputError = %@
-[SBKTransactionController operation:failedWithError:]_block_invoke
[StoreBookkeeper] %@.  Will suppress authentication dialogs for a while.
version
rejected
put-ok
deleted-ok
peer-ops
puts
deletes
value
reason
conflicted
oversize
%@ response: syncAnchor = %@
put-oks(%@), delete-oks(%@), updatedKeys(%@) = %@
conflictedKeys(%@) = %@
deletedKeys(%@) = %@
B24@?0@"NSDictionary"8@"NSString"16
v40@?0@"NSMutableArray"8@"NSString"16@"NSString"24@?<B@?@"NSDictionary"@"NSString">32
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncResponseData.m
ERROR: server rejected %@ because the payload was too big.
SBKStoreErrorDomain
SBKStoreErrorUserInfoKeyCurrentStoreAccountName
SBKStoreErrorUserInfoKeyPreviousStoreAccountName
SBKStoreErrorUserInfoKeyRetrySeconds
<%@:%p> "%@"
SBKTransactionErorGeneric: An unknown server error occurred. (underlyingError = %@) 
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorStoreAccountLoggedOut
SBKStoreErrorStoreAccountMismatch
SBKStoreErrorCodeGeneric: An unspecified server-side error was encountered (underlyingError = %@).
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorCodeGeneric: Request Invalid: It's likely that there is something wrong with the request format (underlyingError = %@).
*** Please file a radar against 'Purple StoreBookkeeper / 1.0'
*** - enable logging in Settings->Internal: iTunes Store->Verbose and iPod->Bookmark Syncing->Verbose
*** - reproduce, then run > 'ituneskvsTool -debug' and attach console and PurplePod output
SBKStoreErrorUserClamp
SBKStoreErrorServerClamp
SBKStoreErrorCodeUnknown
Error Code = %@ (%d)
SBKStoreErrorCodeGenericValidationError
SBKStoreErrorCodeGenericBookkeeperServiceError
SBKStoreErrorCodeAuthenticationError
SBKStoreErrorCodeNoStoreAccount
SBKStoreErrorCodeStoreAccountLoggedOut
SBKStoreErrorCodeStoreAccountMismatch
SBKStoreErrorCodeStoreAccountSessionExpired
SBKStoreErrorCodeStoreAccountUserCancelSignIn
SBKStoreErrorCodeStoreAccountUserCredentials
SBKStoreErrorCodeGeneric
SBKStoreErrorCodeValidation
SBKStoreErrorCodeAuthenticationClamp
SBKStoreErrorCodeServerClamp
SBKStoreErrorCodeUserClamp
SBKStoreErrorCodeNetworkingBlocked
SBKStoreErrorCodeKillSwitch
SBKStoreErrorCodeDisabled
SBKStoreErrorCodeKeyBagKillSwitch
SBKStoreErrorCodeKeyBagLoadFailure
SBKStoreErrorCodeMissingURL
SBKStoreErrorCodeMissingDomain
SBKStoreErrorCodeCancelled
SBKStoreErrorCodeDelegateCancelled
SBKStoreErrorCodeTimeout
Error Code = %lld
SBKTransactionURLOperation.m
Use +operationWithRequest:delegate:
SBK_REQUEST_LOG
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKTransactionURLOperation.m
-[SBKTransactionURLOperation setShouldAuthenticate:]
[StoreBookkeeper] setting up an authentication context - will FORCE authentication!
<%@: %p> (PrimaryURL: %@)
conflict-detection
ordinal
none
delete
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncRequestData.m
WARNING: no data was provided for updated key %@, skipping just that item
SBK_KVSTORE_SERIALIZER_LOG
-[SBKSyncRequestData serializableRequestBodyPropertyList]
Sync request payload (plist): %@
%lld
SBKSync.LastAccountIdentifier
SBKSync.LastAccountName
SBKSync.SyncFailureLastAccountIdentifier
SBKSync.SyncFailureLastAccountName
SBK_STOREAUTHENTICATION_LOG
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKStoreAuthenticationController.m
-[SBKStoreAuthenticationController isAuthenticationValidForTransaction:error:]
Doesn't matter what the DISD is set to since authentication is forced for transaction: %@
-[SBKStoreAuthenticationController authenticationErrorsForTransaction:]
First Use Alert %@ [transaction = %@]
No longer logged in Use Alert %@ [transaction = %@]
AccountIdentifier mismatch: %@ vs %@ [transaction = %@]
SBKLogFilter
SBKLogRuntimeOverride
SBKLogRuntimeOverridePattern
YYYY-MM-dd HH:mm:ss.SSS
logLevel
LogDefaults.v1
LogAuthEvents
LogSyncEvents
LogSyncEventData
LogDefaults.v2
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/Utilities/SBKLogger.m
Invalid RegexPattern: %@ -- Error: %@
, %@
, SBK_UPPSTORE_LOG, SBK_SYNCHANDLER_LOG, SBK_KVSTORE_LOG, SBK_KVSTORE_CLAMPS_LOG, SBK_LOG_TASKS
, SBK_KVSTORE_DESERIALIZER_LOG, SBK_KVSTORE_SERIALIZER_LOG, SBK_KVSTORE_REQUEST_LOG
, SBK_STOREAUTHENTICATION_LOG
[%@:%d] <nil>
[%@:%d] %@
%s <nil>
%s %@
%@ %@[%d:%x] [StoreBookkeeper] %@
[StoreBookkeeper] %@
[client: payload-pair=%@, anchor=%@]
*unversioned*
[result: payload-pair=%@, anchor=%@]
[request: payload-pair=%@, anchor=%@]
%@ domain = %@, PUT: %@, %@, %@
%@-%@
com.apple.storebookkeeper-%@%@
v16@?0@"NSNotification"8
%@, assertionID = %llu
SBK_LOG_TASKS
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/Utilities/SBKTaskAssertion.m
[SBKTaskAssertion] task created underlying assertion: %@
[SBKTaskAssertion] will invalidate underlying assertion: %@
<%@:%p; held=%@; info='%@', underlying assertion = %@>
void DebugNoteAssertionTaken(NSInteger, NSString *__strong)
SBKTaskAssertion.m
Internal Error -- assertion ID %lld is already in use (debugInfo=%@)
acquried assertion (%@) -- %@, active assertionIDs = %@
[SBKTaskAssertion] %@
( %@ )
assertionID = %@
%-2lld
**INVALID**
void DebugNoteAssertionReleased(NSInteger, NSString *__strong)
Internal Error -- released assertion ID %lld can not be found (debugInfo=%@)
released assertion (%@) -- %@, active assertionIDs = %@
SBKPreferencesDidChangeNotification
com.apple.storebookkeeper.defaultschange
_didRegister-
com.apple.storebookkeeper
UIApplicationBackgroundTaskWillExpireNotification
UIApplication
test-item-identifier
itemIdentifier
timestamp
bookmarkTime
hasBeenPlayed
playCount
<SBKMetadata:%p, id=%-32s, bktm=%@, hbpl=%d, plct=%llu, timestamp=%@>
%llu
v32@?0@"NSString"8@16^B24
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/PlaybackPosition/SBKUniversalPlaybackPositionMetadata.m
Unarchiving error: %@
ERROR: encountered invalid data while unarchiving payload for itemIdentifier: %@
pver
bktm
hbpl
plct
tstm
%02llu:%02llu:%.2f
no timestamp
*** 1970 timestamp ***
*** (-) 1970 timestamp ***
*** 1904 timestamp ***
*** (-) 1904 timestamp ***
*** distant past timestamp ***
(%f) %@
storeItemAdamID
subscriptionStoreItemAdamID
podcastURL
podcastGUID
title
artist
albumTitle
hasBeenPalyed
bookmarkMetadataTimestamp
mediaEntityType
SBKUniversalPlaybackPositionStoreDidSynchronizeNotification
9223372036854775807
SBKUniversalPlaybackPositionStore.m
Invalid paramter.  no domain specified
SBKUniversalPlaybackPositionStore.queue
-[SBKUniversalPlaybackPositionStore resignActive]_block_invoke
starting synchronizing changes for resignActive
-[SBKUniversalPlaybackPositionStore resignActive]_block_invoke_2
finished synchronizing changes for resignActive
v20@?0B8@"NSError"12
v24@?0@"SBKStoreURLBagContext"8@"NSError"16
v24@?0@"NSString"8@"NSError"16
domain version lookup
-[SBKUniversalPlaybackPositionStore _onQueueLoadRemoteDomainVersionWithCompletionBlock:]
%s - %@ already in progress.  pending our completion block to be notified when it completes.
%s - beginning %@...
SBKUPPStore LookupDomainVersion
-[SBKUniversalPlaybackPositionStore _onQueueLoadRemoteDomainVersionWithCompletionBlock:]_block_invoke_2
_onQueueSync - %@ completed. %@
 ERROR = '%@'.
v32@?0@?<v@?>8@16@"NSError"24
-[SBKUniversalPlaybackPositionStore _onQueueLoadRemoteDomainVersionWithCompletionBlock:]_block_invoke
_onQueueSync - synchronize operation beginning...
v16@?0@"NSError"8
-[SBKUniversalPlaybackPositionStore _onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:]
_onQueueRunTaskWithName %@ - short circuiting. _accountForSyncing=nil
_onQueueSync - beginning %@ operation...
SBKUPPStore Synchronize
-[SBKUniversalPlaybackPositionStore _onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:]_block_invoke_2
-[SBKUniversalPlaybackPositionStore _onQueueSynchronizeImmediatelyWithCompletionHandler:]
_onQueueSync - synchronize already in progress.  pending our completion block to be notified when it completes.
synchronize
-[SBKUniversalPlaybackPositionStore _onQueueSynchronizeImmediatelyWithCompletionHandler:]_block_invoke
v24@?0@"SBKStoreURLBagContext"8@?<v@?B@"NSError">16
PUT value
-[SBKUniversalPlaybackPositionStore _onQueuePushMetadataItem:completionBlock:]_block_invoke
_onQueueSync - push value operation beginning...
v24@?0B8B12@"NSError"16
GET value
-[SBKUniversalPlaybackPositionStore _onQueuePullMetadataItemWithItemIdentifier:completionBlock:]_block_invoke_2
_onQueueSync - pull value operation beginning...
-[SBKUniversalPlaybackPositionStore _onQueueLoadBagContextWithCompletionHandler:]
_onQueueLoadBag - skipping bag load: _accountIdentifier=%@ [no valid account identifier]
_onQueueLoadBag - load bag already in progress.  pending our completion block to be notified when it completes.
SBKUPPStore Load Bag
-[SBKUniversalPlaybackPositionStore _onQueueLoadBagContextWithCompletionHandler:]_block_invoke_4
_onQueueLoadBag - load bag completed.%@
_onQueueLoadBag - load bag operation beginning...
AutoSyncRateInMinutes
-[SBKUniversalPlaybackPositionStore _onQueueScheduleTimer]_block_invoke
scheduled timer date already passed.  Firing immediately
scheduling next timer update at %@
-[SBKUniversalPlaybackPositionStore _onQueueSuspendTimer]
suspending update timer
%.2f seconds
%lld minutes, %lld seconds
%@ (%@ from now)
SBKPlaybackPositionSyncRequestHandler.m
invalid parameters - data source is required
invalid parameters - bagContext is required
invalid parameters - bagContext.domain is required
Invalid bag.  no domain specified
SBKPlaybackPositionSyncRequestHandler.queue
SBKPlaybackPositionSyncRequestHandler.syncOperationQueue
SBK_REQUEST_HANDLING_LOG
-[SBKPlaybackPositionSyncRequestHandler _synchronize:]
Skipping synchronize: synchronization already in progress
Beginning synchronization
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/PlaybackPosition/SBKPlaybackPositionSyncRequestHandler.m
ERROR: will skip syncing item with no sync metadataIdentifier: %@
v16@?0@"<SBKUniversalPlaybackPositionMediaItem>"8
Gathered local %d items to sync from dataSource: %@
dataSource transaction context = %@
Performing sync with server using syncAnchor = %@
Sending merged items to server: %@
WARNING: sent resolved conflict to server, but still received conflicts in the response, saving those for next time...
Committing merged items with domainRevision: %@ to local database: %@
@"SBKUniversalPlaybackPositionMetadata"8@?0
Finished synchronization
you can not nest synchronization calls
i12@?0i8
-[SBKPlaybackPositionSyncRequestHandler _mergeMetadataItemsFromSyncResponse]
Handled items in response, will save %lld items locally and push back %lld conflict resolutions
keys to save to local db = %@
keys to push to cloud db = %@
completionConditionLock
-[SBKPlaybackPositionSyncRequestHandler _signalKVSTransactionCompletion:withError:]
transaction is being canceled.  error = %@
-[SBKPlaybackPositionSyncRequestHandler transactionController:transactionDidFail:error:]
Detected account change.  Getting remote items since version 0 instead of %@
-[SBKPlaybackPositionSyncRequestHandler transactionController:transactionDidFinish:]
syncRequestURL
kvs-sync
pullKeyValueRequestURL
kvs-get
pushKeyValueRequestURL
kvs-put
pullAllKeyValueRequestURL
kvs-getall
pushAllKeyValueRequestURL
kvs-putall
v32@?0@8@16^B24
com.apple.upp
com.apple.upp-extras
v24@?0@8@"NSError"16
v24@?0@"NSDictionary"8@"NSError"16
key bag contents = 
v32@?0@"NSString"8@16@"NSError"24
%@.%@
v56@?0@"NSString"8@16@?<@@?@>24@"NSString"32@"NSString"40@"NSDictionary"48
@16@?0@8
v24@?0@"NSString"8@"NSString"16
domainDisabled
kvs-sync-disabled
pollingIntervalInSeconds
kvs-sync-polling-interval-secs
SBKStoreURLBagContext.m
Use +loadBagContextFromURLBag:domain:completionBlock:
%@(%@) = %@
%@ domain=%@, enabled=%d, requestURLs = 
%@ domain = %@, GET: key='%@', %@, %@
domain-version
SBKRequestData.m
Subclass must implement
%lld-%@-%lld
SBKSyncTransaction.m
Invalid processor
????
SYNC: anchor=%@
, deletes=%@
, updates=%@
%@ domain = %@, %@
transactions using conflict detection must supply a conflict ordinal
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncTransaction.m
WARNING: Invalid response (%@).  Skipping...
v12@?0B8
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/Utilities/SBKAsynchronousTask.m
[SBKAsynchronousTask] WARNING: task timed out: %@
%@ '%@'
[SBKAsynchronousTask] Invoking expiration handler for %@, with cancelType = %d
[SBKAsynchronousTask] beginTaskOperation %@
SBKAsynchronousTask.m
must have a finish and expiration handler specified
[SBKAsynchronousTask] Invoking completion handler for %@, result = %@, error = %@
v32@?0@8Q16^B24
, itemCount = %@
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKLoadDomainVersionRequestHandler.m
-[SBKLoadDomainVersionRequestHandler runWithCompletionHandler:]_block_invoke
finished loading domain version: domainVersion = %@%@
B24@?0B8B12@"NSError"16
com.apple.storebookkeeper.SBKSyncRequestHandler
v8@?0
@8@?0
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKSyncRequestHandler.m
-[SBKSyncRequestHandler transaction:willProcessResponseData:]_block_invoke
will process response with responseDomainVersion = %@
SBKSyncRequestHandler.m
subclass must supply key-value pair by implementing the SBKSyncTransactionProcessing protocol
1.2.11
ERROR: deflateEnd() failed: %s
SBKZipDeflateMemoryOutputStream.m
stream is already closed.
64-bit buffer writes not supported.
subclass must implement
 %@ [%@] URL = %@, shouldAuthenticate = %d, arguments = %@, headers = %@, bodyData = %@ 
 %@ [%@]
SBKRequestBodyContentType-TextXML
SBKRequestBodyContentType-EncodeGzip
SBKRequest.m
Invalid bodyContentType requested for propertyList
/Library/Caches/com.apple.xbs/Sources/StoreBookkeeper_Sim/StoreBookkeeper/iTMSKeyValueStorage/SBKRequest.m
ERROR: failed to serialize property list with error = %@
v32@?0@"NSString"8@"NSString"16^B24
guid
gzip
Accept-Encoding
Content-Encoding
Content-Type
POST
application/x-plist
text/xml; charset=UTF-8
text/plain; charset=UTF-8
SBKBookkeeperRequestErrorDomain
status
 [%ld]: responseDictionary = %@, (%@)
Success
Unknown server initialization error
The request format was invalid, or referenced an invalid domain
An unspecified server-side error (type 1) was encountered
The request requires an authenticated weak-token
The request deniend (punted - server too busy)
The request denied (too many recent request)
Unknown status
An unspecified server-side error (type 2) was encountered
The client's user agent is not supported
The putAll had a version mismatch
The domain specified in the request is locked
%@ (status = %@)%@
 Please enable logging and file a bug.
SBKRequestHandler.m
SBKTransaction.m
base-version
Unarchiving SBKStoreClampsController resulted in error:%@
Archiving SBKStoreClampsController resulted in error:%@
SBKPullValueRequest
SBKAdditions
SBKStoreClampsController
NSSecureCoding
NSCoding
SBKGenericKeyValuePair
NSObject
SBKTransactionController
SBKTransactionURLOperationDelegate
ISStoreURLOperationDelegate
ISURLOperationDelegate
ISOperationDelegate
SBKSyncResponseData
SBKStoreError
SBKPrivate
SBKTransactionURLOperation
SBKSyncRequestData
SBKStoreAuthenticationController
SBKLogger
SBKPushValueTransaction
SBKProcessAssertion
SBKTaskAssertion
SBKPreferences
SBKSimpleTransactionRequestHandler
SBKUniversalPlaybackPositionMetadata
NSCopying
SBKUniversalPlaybackPositionStore
SBKPlaybackPositionSyncRequestHandler
SBKTransactionControllerDelegate
SBKSyncTransactionProcessing
SBKStoreURLBagContext
NSMutableCopying
SBKMutableStoreURLBagContext
SBKPullValueTransaction
SBKPushValueResponse
SBKRequestData
SBKSyncResponse
SBKSyncTransaction
SBKSyncResponseDataKeyEnumerator
SBKAsynchronousTask
SBKLoadDomainVersionRequestHandler
SBKSyncRequestHandler
SBKZipDeflateMemoryOutputStream
SBKRequest
SBKResponse
SBKResponseStatus
SBKSyncRequest
SBKRequestHandler
SBKTransaction
SBKPullValueResponse
SBKPushValueRequest
clientItemVersionAnchor
domain
requestedKey
dictionaryWithObjects:forKeys:count:
requestURL
requestWithRequestURL:
setMethod:
propertyListBodyWithTransaction:
setBodyDataWithPropertyList:
setTransaction:
setIncludeDeviceGUID:
transaction
responseWithResponse:transaction:
requestForTransaction:
canonicalResponseForResponse:
length
bytes
appendBytes:length:
initWithCapacity:
_SBKDataByInflatingWithNoZipHeader
_SBKDataByDeflatingWithNoZipHeaderWithCompression:
SBKDataByInflatingWithNoZipHeader
SBKDataByDeflatingWithNoZipHeader
SBKDataByInflatingWithGZip
SBKDataByDeflatingWithGZip
SBKStringFromDigestData:
SBKStringByMD5HashingString:
initWithBytesNoCopy:length:encoding:freeWhenDone:
currentHandler
stringWithUTF8String:
handleFailureInFunction:file:lineNumber:description:
UTF8String
storeBookkeeperPreferences
objectForKey:withDefaultValue:
unarchivedObjectOfClass:fromData:error:
init
description
date
dateWithTimeIntervalSinceReferenceDate:
stringWithFormat:
encodeObject:forKey:
encodeDouble:forKey:
encodeInteger:forKey:
decodeIntegerForKey:
decodePropertyListForKey:
mutableCopy
removeAllObjects
setValuesForKeysWithDictionary:
accessTransactionClampsWithBlock:
decodeDoubleForKey:
pendingUserDefaultArchivedData
archivedDataWithRootObject:requiringSecureCoding:error:
setPendingUserDefaultArchivedData:
setObject:forKey:
transactionClamps
_canScheduleTransactionBasedOfNetworkingBlocked:error:
_canScheduleTransactionBasedOnBackOff:error:
_canScheduleTransactionBasedOnUserCancelledSignIn:error:
_canScheduleTransactionBasedOnAccountIdentifierCheck:error:
_canScheduleTransactionBasedOnType:error:
sharedLogger
shouldOverrideCondition:file:
logFunction:format:
clearAccountIdentifierCheckTimestamp
clearAuthenticationRequest
clearBackOff
clearNetworkingBlocked
clearUserAcceptedSyncTimestamp
clearUserCancelledSignIn
saveToUserDefaults
_keyForTransaction:
setValue:forKey:
_rightNow
setAccountIdentifierCheckTimestamp:
setAuthenticationNeededTimestamp:
authenticationNeededTimestamp
userClampErrorWithTransaction:retrySeconds:underlyingError:
setUserAcceptedSyncTimestamp:
userAcceptedSyncTimestamp
setUserCancelledSignInBackOffUntil:
timeIntervalSinceReferenceDate
logFile:lineNumber:format:
setBackOffUntil:
setNetworkingBlockedUntil:
networkingBlockedUntil
clampsKey
valueForKey:
timeIntervalSinceNow
serverClampErrorWithTransaction:retrySeconds:underlyingError:
clearTimestampForTransaction:
isNetworkingBlocked
networkingBlockedErrorWithTransaction:underlyingError:
accountIdentifierCheckTimestamp
backOffUntil
userCancelledSignInBackOffUntil
sharedClampsController
supportsSecureCoding
encodeWithCoder:
initWithCoder:
TB,R
canScheduleTransaction:error:
reset
setTimestampForTransaction:
setAccountIdentifierCheckTimestamp
setAuthenticationRequest
hasAuthenticatedTooRecentlyForTransaction:error:
setUserAcceptedSyncTimestamp
hasUserRecentlyAcceptedSync
setUserCancelledSignIn
backOffForTimeInterval:
setNetworkingBlocked
queue
setQueue:
setTransactionClamps:
nextUserCancelBackOffInterval
setNextUserCancelBackOffInterval:
.cxx_destruct
_queue
_transactionClamps
_accountIdentifierCheckTimestamp
_authenticationNeededTimestamp
_userAcceptedSyncTimestamp
_networkingBlockedUntil
_backOffUntil
_userCancelledSignInBackOffUntil
_nextUserCancelBackOffInterval
_pendingUserDefaultArchivedData
T@"NSObject<OS_dispatch_queue>",&,N,V_queue
T@"NSDictionary",&,N,V_transactionClamps
Td,N,V_accountIdentifierCheckTimestamp
Td,N,V_authenticationNeededTimestamp
Td,N,V_userAcceptedSyncTimestamp
Td,N,V_networkingBlockedUntil
Td,N,V_backOffUntil
Td,N,V_userCancelledSignInBackOffUntil
Td,N,V_nextUserCancelBackOffInterval
T@"NSData",&,N,V_pendingUserDefaultArchivedData
initWithKVSKey:kvsPayload:
decodeObjectOfClass:forKey:
pairWithKVSKey:kvsPayload:
isEqual:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
isMemberOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
hash
superclass
debugDescription
TQ,R
T#,R
T@"NSString",R,C
kvsValueDescription
timestamp
kvsKey
kvsPayload
_kvsKey
_kvsPayload
T@"NSString",R,N,V_kvsKey
T@"NSData",R,N,V_kvsPayload
initWithDomain:requestURL:forAccount:
copy
setName:
setMaxConcurrentOperationCount:
initWithStoreAccount:
defaultCenter
_networkTypeChangedNotification:
sharedInstance
addObserver:selector:name:object:
removeObserver:name:object:
_onQueue_endBackgroundTask
operations
countByEnumeratingWithState:objects:count:
setDelegate:
dealloc
isEqualToString:
_onQueue_clampsController
_onQueue_processPendingTransactions
keyValueStoreDisabledErrorWithTransaction:underlyingError:
_onQueue_cancelAllPendingTransactions:
count
_onQueue_isIdle
setTransactionContext:forKey:
scheduleTransaction:
noStoreAccountErrorWithTransaction:underlyingError:
_delegateShouldScheduleTransaction:error:
_onQueue_scheduleTransaction:isRetry:
_onQueue_transactionDidFail:withError:
transactionCancelledErrorWithTransaction:underlyingError:
_onQueue_cancelTransaction:error:
transactionCancelledErrorWithTransaction:code:underlyingError:
_storeOperationDidComplete:
setCompletionBlock:
addOperation:
delegate
_onQueue_resolveError:resolution:
_onQueue_beginBackgroundTask
backgroundTaskAssertion
_endBackgroundTask
newBackgroundTaskWithExpirationHandler:debugInfo:
invalidate
cancelAllOperations
setActiveRequest:
_onQueue_transactionDidCancel:withError:
removeObject:
objectAtIndex:
_onQueue_processCurrentTransaction
_onQueue_authenticationCanProcessTransaction:error:
newRequest
shouldAuthenticate
setShouldAuthenticate:
newURLOperationWithDelegate:
_enqueueStoreOperation:
_onQueue_canScheduleTransaction:error:
_onQueue_addPendingTransaction:
isClampError
retrySeconds
insertObject:atIndex:
addObject:
_onQueue_isEnabledForTransaction:error:
_onQueue_assertIsTransactionValid:error:
_onQueue_clampsCanScheduleTransaction:error:
isEnabled
handleFailureInMethod:object:file:lineNumber:description:
isAuthenticationValidForTransaction:error:
_delegateTransactionDidFinish:
_delegateTransactionDidFail:withError:
_resolveError:resolution:
_delegateTransactionDidCancel:withError:
storeGenericErrorWithTransaction:underlyingError:
_onQueue_currentTransactionDidFinish
processDataInResponse:withCompletionHandler:
response
responseWithURLResponse:responseDictionary:
activeRequest
isSuccess
saveAccountToLastSyncedDefaults
_processDataInResponse:
requestError
isUnsupportedClient
killSwitchErrorWithTransaction:underlyingError:
isGenericError
isValidationError
storeValidationErrorWithTransaction:underlyingError:
isAuthenticationError
saveAccountToLastFailedSyncDefaults
shouldAuthenticateIfNecessary
storeAccountSessionExpiredWithTransaction:underlyingError:
unknownErrorWithTransaction:underlyingError:
isTransactionCancelledError
_onQueue_performRetryErrorHandlingForError:
_onQueue_performCancelErrorHandlingForError:
_onQueue_performDefaultErrorHandlingForError:
isAccountsChangedError
transactionController:shouldScheduleTransaction:
delegateCancelledErrorWithTransaction:underlyingError:
transactionContextForKey:
isMainThread
_sendFinishedBlockForTransaction:success:cancelled:error:handledAsFinishedBlock:
transactionController:transactionDidFail:error:
transactionController:transactionDidCancel:error:
transactionController:transactionDidFinish:
needsAuthentication
_onQueue_processOperationOutput:operation:operationAuthenticated:
statusCode
code
userCancelledSignInErrorWithTransaction:underlyingError:
userEnteredWrongCredentialsErrorWithTransaction:underlyingError:
requestProperties
operation:failedWithError:
operation:updatedProgress:
operationFinished:
operationWillStart:
operation:didDiscoverContentLength:
operation:didReceiveResponse:
operation:finishedWithOutput:
operation:needNewBodyStream:
operation:processData:error:
operation:willSendRequest:
operation:sanitizedStringForString:
operation:dispositionForAuthenticationChallenge:
operation:credentialForAuthenticationChallenge:
URLCache
URLCacheID
metricsLoadURLSessionDuration
metricsLoadURLSamplingPercentage
metricsLoadURLSamplingPercentageCachedResponses
T@"NSNumber",R,N
operation:didAuthenticateWithDSID:
operation:shouldAuthenticateWithContext:responseHandler:
operation:shouldSetStoreFrontID:
account
T@"SSAccount",R
initWithDomain:requestURL:
setDomain:
setRequestURL:
setEnabled:
isIdle
scheduleTransaction:withTransactionFinishedBlock:
cancelScheduledTransaction:
cancelAllTransactions
cancelAllTransactionsCancelCode:
_beginBackgroundTask
authenticationController
setAuthenticationController:
setShouldAuthenticateIfNecessary:
currentTransaction
setCurrentTransaction:
operationQueue
setOperationQueue:
pendingTransactions
setPendingTransactions:
isResolvingError
setIsResolvingError:
setBackgroundTaskAssertion:
networkTypeObserver
setNetworkTypeObserver:
conflictResolutionAttempts
setConflictResolutionAttempts:
_enabled
_shouldAuthenticateIfNecessary
_isResolvingError
_delegate
_domain
_requestURL
_account
_authenticationController
_currentTransaction
_operationQueue
_pendingTransactions
_backgroundTaskAssertion
_networkTypeObserver
_conflictResolutionAttempts
T@"NSOperationQueue",&,N,V_operationQueue
T@"NSMutableArray",&,N,V_pendingTransactions
T@"SBKTransaction",&,N,V_currentTransaction
TB,N,V_isResolvingError
T@"SBKTaskAssertion",&,N,V_backgroundTaskAssertion
T@,W,N,V_networkTypeObserver
Tq,N,V_conflictResolutionAttempts
T@"<SBKTransactionControllerDelegate>",W,N,V_delegate
T@"NSString",R,C,N,V_domain
T@"NSURL",R,N,V_requestURL
T@"SSAccount",R,N,V_account
enabled
TB,R,N,GisEnabled,V_enabled
idle
TB,R,N,GisIdle
T@"SBKStoreAuthenticationController",&,N,V_authenticationController
TB,N,V_shouldAuthenticateIfNecessary
initWithTransaction:responseDictionary:response:
dictionary
array
_deserializeResponseDictionary:response:
numberWithUnsignedInteger:
objectForKey:
arrayWithObjects:count:
containsObject:
stringValue
deserializedResponseBodyWithTransaction:responseDictionary:response:
payloadDataForUpdateResponseKey:
syncAnchor
updatedKeys
conflictedKeys
deletedKeys
successfullyUpdatedKeys
successfullyDeletedKeys
responseOpEntiesByKey
setResponseOpEntiesByKey:
_transaction
_syncAnchor
_updatedKeys
_conflictedKeys
_deletedKeys
_successfullyUpdatedKeys
_successfullyDeletedKeys
_responseOpEntiesByKey
T@"NSMutableDictionary",&,N,V_responseOpEntiesByKey
T@"SBKSyncTransaction",R,N,V_transaction
T@"NSString",R,C,N,V_syncAnchor
T@"NSArray",R,N,V_updatedKeys
T@"NSArray",R,N,V_conflictedKeys
T@"NSArray",R,N,V_deletedKeys
T@"NSArray",R,N,V_successfullyUpdatedKeys
T@"NSArray",R,N,V_successfullyDeletedKeys
appendString:
enumerateObjectsUsingBlock:
localizedDescription
copyWithZone:
userInfo
doubleValue
isRecoverableError
isTransactionMissingInformationError
previousStoreAccountName
currentStoreAccountName
T@"SBKTransaction",&,N,V_transaction
TB,R,N
T@"NSString",R,C,N
Td,R,N
dictionaryWithObject:forKey:
errorWithDomain:code:userInfo:
keyValueStoreErrorWithCode:localizedDescription:transaction:underlyingError:
mainBundle
localizedStringForKey:value:table:
numberWithDouble:
storeLoggedOutErrorWithPreviousStoreAccountName:transaction:underlyingError:
storeAccountMismatchErrorWithPreviousStoreAccountName:currentStoreAccountName:transaction:underlyingError:
transactionMissingDomainErrorWithTransaction:underlyingError:
transactionMissingURLErrorWithTransaction:underlyingError:
transactionTimeoutErrorWithTransaction:underlyingError:
_init
copyRequestProperties
setRequestProperties:
setShouldMessageMainThread:
setQueuePriority:
responseDataProvider
setDataProvider:
setSBKRequest:
setNeedsAuthentication:
defaultStore
activeAccount
initWithAccount:
setPromptStyle:
setAllowsSilentAuthentication:
setAuthenticationContext:
operationWithRequest:delegate:
SBKRequest
_shouldAuthenticate
_SBKRequest
TB,N,V_shouldAuthenticate
T@"SBKRequest",&,N,V_SBKRequest
syncTransaction
keysToUpdate
_serializableUpdateItemPayloadDictionaryForKey:
keysToDelete
_serializableDeleteItemPayloadDictionaryForKey:
_serializableConflictDetectionValue
arrayByAddingObjectsFromArray:
_needsConflictDetection
conflictDetectionType
numberWithInteger:
conflictDetectionOrdinalForKey:
longLongValue
keyValuePairForUpdatedKey:
_serializableConflictDetectionOrdinalForKey:
serializableRequestBodyPropertyList
storeAccount
uniqueIdentifier
lastSyncedAccountIdentifier
shouldForceAuthenticationForTransaction:
authenticationErrorsForTransaction:
accountName
lastSyncedAccountName
numberWithLongLong:
clearLastSyncnedAccount
lastFailedSyncAccountIdentifier
lastFailedSyncAccountName
_storeAccount
T@"SSAccount",R,N,V_storeAccount
setDefaultFormatterBehavior:
setDateFormat:
stringFromDate:
integerValue
verboseLoggingEnabled
infoDictionary
processInfo
environment
setFilter:
setBool:forKey:
registerDefaultsIfKeyNotSet:registrationBlock:
_updateSettingsFromPreferences:
initWithPattern:options:error:
standardUserDefaults
stringByAppendingFormat:
boolForKey:
setRuntimeOverride:
removeObserver:
closeFile
fileExistsAtPath:
createFileAtPath:contents:attributes:
fileHandleForWritingAtPath:
runtimeOverride
lastPathComponent
stringByDeletingPathExtension
rangeOfString:options:
rangeOfFirstMatchInString:options:range:
lock
unlock
logString:
initWithFormat:arguments:
rangeOfString:
initWithFormat:
dataUsingEncoding:
writeData:
performLoggingBlock:
stringByAppendingString:
stringByReplacingOccurrencesOfString:withString:
debugLoggingEnabled
setAuxPath:
auxPath
addRuntimeOverride:
removeRuntimeOverride:
filter
_auxPath
_fileHandle
_filter
_runtimeOverride
_pid
_procName
_runtimeOverrideRegex
_lock
T@"NSString",C,N,V_filter
T@"NSString",C,N,V_runtimeOverride
pushKeyValueRequestURL
conflictItemValuePayload
conflictItemKey
_resolveConflictBetweenClientPayloadPair:andServerPayloadPair:
conflictItemVersionAnchor
domainVersion
initWithStoreBagContext:clientItemPayloadPair:clientItemVersionAnchor:
clientItemPayloadPair
requestItemPayloadPair
requestItemVersionAnchor
success
resultItemPayloadPair
resultItemVersionAnchor
resultDomainVersion
_isRechedulable
_success
_clientItemPayloadPair
_clientItemVersionAnchor
_requestItemPayloadPair
_requestItemVersionAnchor
_resultItemPayloadPair
_resultItemVersionAnchor
_resultDomainVersion
T@"<SBKKeyValuePayloadPair>",R,N,V_clientItemPayloadPair
T@"NSString",R,N,V_clientItemVersionAnchor
T@"<SBKKeyValuePayloadPair>",R,N,V_requestItemPayloadPair
T@"NSString",R,N,V_requestItemVersionAnchor
TB,R,N,V_success
T@"<SBKKeyValuePayloadPair>",R,N,V_resultItemPayloadPair
T@"NSString",R,N,V_resultItemVersionAnchor
T@"NSString",R,N,V_resultDomainVersion
processName
initWithPID:flags:reason:name:withHandler:
setBkProcessAssertion:
_expireBackgroundTask
addObserverForName:object:queue:usingBlock:
setExpirationObserver:
setInvalidationHandler:
_onQueueSetBkProcessAssertion:
initWithExpirationBlock:debugDescription:
bkProcessAssertion
identifier
expirationObserver
_expirationBlock
_identifier
_bkProcessAssertion
_expirationObserver
TQ,R,N,V_identifier
T@"BKSProcessAssertion",&,N,V_bkProcessAssertion
T@,&,N,V_expirationObserver
initWithExpirationHandler:debugInfo:
performExpirationHandler
_expireHandler
_debugInfo
_processAssertion
componentsJoinedByString:
postNotificationName:object:userInfo:
numberWithBool:
_preferencesDidChange
syncRequestURL
transactionController
cancelWithError:
initWithBagContext:
scheduleTransaction:finishedBlock:
timeout
cancel
canceled
_canceled
_transactionController
T@"SBKTransactionController",R,N,V_transactionController
TB,R,N,V_canceled
sharedApplication
metadataWithItemIdentifier:keyValueStorePayload:failuresOkay:
decodeBoolForKey:
encodeBool:forKey:
initAsTestableItem
itemIdentifier
bookmarkTime
hasBeenPlayed
playCount
setItemIdentifier:
setTimestamp:
setBookmarkTime:
setHasBeenPlayed:
setPlayCount:
unsignedLongLongValue
setObject:forKeyedSubscript:
distantPast
initWithObjectsAndKeys:
allKeys
setWithArray:
enumerateValuesForProperties:usingBlock:
keyValueStoreItemIdentifierForItem:
boolValue
initForReadingFromData:error:
setDecodingFailurePolicy:
setWithObjects:
decodeObjectOfClasses:forKey:
finishDecoding
dictionaryWithObjects:forKeys:
keyValueStorePayload
_testableMetadataItem_1
keyValueStoreItemIdentifierForUniqueStoreID:itemTitle:albumName:itemArtistName:feedURL:feedGUID:
metadataWithValuesFromDataSourceItem:
metadataWithItemIdentifier:bookmarkTime:bookmarkTimestamp:hasBeenPlayed:playCount:
metadataWithItemIdentifier:keyValueStorePayload:
_hasBeenPlayed
_itemIdentifier
_timestamp
_bookmarkTime
_playCount
T@"NSString",C,N,V_itemIdentifier
Td,N,V_timestamp
Td,N,V_bookmarkTime
TB,N,V_hasBeenPlayed
TQ,N,V_playCount
setTimeStyle:
setDateStyle:
dictionaryWithCapacity:
string
absoluteString
initWithDomain:dataSource:automaticSynchronizeOptions:accountIdentifier:isActive:
distantFuture
setDateToFireNextTimer:
_updateAutorefreshRateSettingAndRestartTimer:
_onQueueLoadBagContextWithCompletionHandler:
mainQueue
_updateForStoreAccountsChange
initWithInitialUpdateDelay:
_onQueueStopTimer
_onQueueStartNewTimerWithTimeIntervalSinceNow:
bagLookupTask
currentTask
lookupDomainVersionTask
timer
_onQueueSuspendTimer
_automaticallySynchronizeOnBecomeActive
_onQueueResumeTimer
_onQueueUpdateTimerForActiveChanges
_automaticallySynchronizeLocalChangesOnResignActive
_onQueueSynchronizeWithAutosynchronizeMask:withCompletionBlock:
_onQueueUpdateTimerForAutomaticSyncOptionChanges
automaticSynchronizeOptions
setAutomaticSynchronizeOptions:
_onQueueSynchronizeImmediatelyWithCompletionHandler:
_onQueuePushMetadataItem:completionBlock:
_onQueuePullMetadataItemWithItemIdentifier:completionBlock:
domainDisabled
_accountForSyncing
_onQueueLoadRemoteDomainVersionWithCompletionBlock:
addTaskCompletionBlock:
initWithHandlerQueue:timeout:debugDescription:
setExpirationHandler:
setFinishedHandler:
error
invokeTaskCompletionBlocksWithBlock:
finishTaskOperationWithResult:error:
beginTaskOperation
responseDomainVersion
runWithCompletionHandler:
firstObject
removeObjectAtIndex:
_onQueueRunTaskWithName:taskCompletionHandler:runTaskBlock:
cancelType
result
postNotificationName:object:
_onQueueStartNewTimer
_onQueueRunNextPendingTaskBlock
initWithDataSource:bagContext:accountIdentifier:
synchronizeWithCompletionHandler:
initWithStoreBagContext:requestedKey:clientItemPayloadPair:clientItemVersionAnchor:
accountWithUniqueIdentifier:
pollingIntervalInSeconds
_effectiveAutorefreshRate
_updateSettingsFromLoadedBagContext:
contextWithBagType:
URLBagForContext:
loadBagContextFromURLBag:domain:completionBlock:
floatValue
dateToFireNextTimer
isEqualToDate:
_timerFired:
dateWithTimeIntervalSinceNow:
scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:
setTimer:
_timerIsStopped
_onQueueScheduleTimer
deprecated_setDataSource:
initWithDomain:dataSource:automaticSynchronizeOptions:isActive:
becomeActive
resignActive
setHasLocalChangesToSync:
hasLocalChangesToSync
setAutomaticallySynchronizeLocalChangesOnResignActive:
automaticallySynchronizeLocalChangesOnResignActive
setAutomaticallySynchronizeOnBecomeActive:
automaticallySynchronizeOnBecomeActive
synchronizeImmediatelyWithCompletionHandler:
pushMetadataItem:completionBlock:
pullMetadataItemWithItemIdentifier:completionBlock:
synchronizeImmediatelyWithCompletionBlock:
checkForAvailabilityWithCompletionBlock:
loadRemoteDomainVersionWithCompletionBlock:
loadBagContextWithCompletionBlock:
dataSource
setCurrentTask:
setLookupDomainVersionTask:
setBagLookupTask:
currentTaskRequestHandler
setCurrentTaskRequestHandler:
_isActive
_hasLocalChangesToSync
_pendingTaskBlocks
_accountIdentifier
_automaticSynchronizeOptions
_initialAutosyncInterval
_pollingLimitFromBag
_autorefreshInterval
_refreshTimerActive
_accountsObserver
_prefsObserver
_dataSource
_currentTask
_lookupDomainVersionTask
_bagLookupTask
_currentTaskRequestHandler
_dateToFireNextTimer
_timer
T@"SBKAsynchronousTask",&,N,V_currentTask
T@"SBKAsynchronousTask",&,N,V_lookupDomainVersionTask
T@"SBKAsynchronousTask",&,N,V_bagLookupTask
T@"SBKRequestHandler",&,N,V_currentTaskRequestHandler
T@"NSDate",&,N,V_dateToFireNextTimer
T@"NSTimer",&,N,V_timer
T@"<SBKUniversalPlaybackPositionDataSource>",R,W,N,V_dataSource
TQ,N
TB,N
initWithBagContext:accountIdentifier:
setDataSource:
setMetadataItemsFromDataSource:
setMetadataItemsToCommitToDataSource:
setMetadataItemsToCommitToKVSStorage:
setResponseMetadataItemsToCommitToDataSource:
setResponseMetadataItemsMergedToCommitBackToKVSStorage:
setKvsController:
setDataSourceTransactionContext:
setCurrentKVSTransaction:
metadataItemsFromDataSource
responseMetadataItemsToCommitToDataSource
responseMetadataItemsMergedToCommitBackToKVSStorage
clearTransactionResponseData
cancelUniversalPlaybackPositionTransaction:
dataSourceTransactionContext
syncInProgress
setSyncInProgress:
beginTransactionWithItemsToSyncEnumerationBlock:
_shouldStop
_dataSourceCancelTransaction
metadataItemsToCommitToKVSStorage
newKVSSyncTransactionWithUpdatedMetadataItemIdentifiers:processConflicts:
currentKVSTransaction
_synchronouslyRunKVSTransaction:
_mergeMetadataItemsFromSyncResponse
metadataItemsToCommitToDataSource
objectEnumerator
nextObject
commitUniversalPlaybackPositionTransaction:domainVersion:metadataEnumerationBlock:
fatalSyncError
setCanceled:
kvsController
_signalKVSTransactionCompletion:withError:
_synchronize:
removeObjectForKey:
bagContext
lastSyncedDomainVersion
initWithStoreBagContext:syncAnchor:keysToUpdate:keysToDelete:conflictDetectionType:
setTransactionProcessor:
initWithCondition:
lockWhenCondition:beforeDate:
setFatalSyncError:
unlockWithCondition:
_signalKVSTransactionCompletion:
transaction:willProcessResponseData:
transaction:didProcessResponseData:
transaction:processUpdatedKey:data:conflict:isDirty:
_mergeConflictedItemFromSyncResponse:
transaction:processDeletedKey:isDirty:
transaction:keyValuePairForUpdatedKey:
transaction:syncAnchorForTransactionSyncAnchor:
transaction:keysForTransactionForTransactionKeysToUpdate:
transaction:keysForTransactionForTransactionKeysToDelete:
transaction:conflictDetectionTypeForTransactionDetectionType:
transaction:conflictDetectionOrdinalForKey:
initWithDataSource:bagContext:
overrideSyncAnchor
setOverrideSyncAnchor:
_syncOperationQueue
_syncInProgress
_kvsController
_dataSourceTransactionContext
_metadataItemsFromDataSource
_metadataItemsToCommitToDataSource
_metadataItemsToCommitToKVSStorage
_responseMetadataItemsToCommitToDataSource
_responseMetadataItemsMergedToCommitBackToKVSStorage
_currentKVSTransaction
_fatalSyncError
_overrideSyncAnchor
T@"SBKTransactionController",&,N,V_kvsController
T@"<SBKUniversalPlaybackPositionDataSource>",&,N,V_dataSource
T@"<SBKUniversalPlaybackPositionTransactionContext>",&,N,V_dataSourceTransactionContext
T@"NSMutableDictionary",&,N,V_metadataItemsFromDataSource
T@"NSDictionary",&,N,V_metadataItemsToCommitToDataSource
T@"NSDictionary",&,N,V_metadataItemsToCommitToKVSStorage
T@"NSMutableDictionary",&,N,V_responseMetadataItemsToCommitToDataSource
T@"NSMutableDictionary",&,N,V_responseMetadataItemsMergedToCommitBackToKVSStorage
T@"SBKSyncTransaction",&,N,V_currentKVSTransaction
TB,N,V_syncInProgress
TB,N,V_canceled
T@"NSError",&,N,V_fatalSyncError
T@"NSString",&,N,V_overrideSyncAnchor
enumerateKeysAndObjectsUsingBlock:
_findFirstValueInBag:keyEnumerator:valueTransformer:defaultValue:completionBlock:
loadValueForKey:completionBlock:
loadWithCompletionBlock:
initWithBag:domain:
URLWithString:
enumerateRequestURLBagKeysWithBlock:
_initWithDomain:syncRequestURL:domainDisabled:
UPPDomainIdentifier
ExtrasDomainIdentifier
mutableCopyWithZone:
setPollingIntervalInSeconds:
setSyncRequestURL:
setPushKeyValueRequestURL:
pullKeyValueRequestURL
setPullKeyValueRequestURL:
pushAllKeyValueRequestURL
setPushAllKeyValueRequestURL:
pullAllKeyValueRequestURL
setPullAllKeyValueRequestURL:
setDomainDisabled:
setBag:
_domainDisabled
_pollingIntervalInSeconds
_syncRequestURL
_pushKeyValueRequestURL
_pullKeyValueRequestURL
_pushAllKeyValueRequestURL
_pullAllKeyValueRequestURL
_bag
T@"SSURLBag",&,N,V_bag
T@"NSString",C,N,V_domain
T@"NSURL",&,N,V_syncRequestURL
T@"NSURL",&,N,V_pushKeyValueRequestURL
T@"NSURL",&,N,V_pullKeyValueRequestURL
T@"NSURL",&,N,V_pushAllKeyValueRequestURL
T@"NSURL",&,N,V_pullAllKeyValueRequestURL
TB,N,V_domainDisabled
Td,N,V_pollingIntervalInSeconds
T@"NSString",C,D,N
T@"NSURL",&,D,N
TB,D,N
Td,D,N
itemValuePayload
itemKey
itemVersion
_requestedKey
T@"NSString",R,C,N,V_requestedKey
responseWithResponse:
deserializeResponseBodyWithTransaction:
responseDictionary
objectForKeyedSubscript:
_domainVersion
_conflictItemValuePayload
_conflictItemKey
_conflictItemVersionAnchor
T@"NSString",R,N,V_domainVersion
T@"NSData",R,N,V_conflictItemValuePayload
T@"NSString",R,N,V_conflictItemKey
T@"NSString",R,N,V_conflictItemVersionAnchor
initWithTransaction:
syncResponseData
_syncResponseData
T@"SBKSyncResponseData",R,N,V_syncResponseData
initWithSyncRequestURL:domain:syncAnchor:keysToUpdate:keysToDelete:conflictDetectionType:
type
transactionProcessor
_validateTransactionProcessor:
initWithResponseData:
enumerateKeysInResponseForTransaction:completionBlock:
_keysToUpdate
_keysToDelete
_conflictDetectionType
_transactionProcessor
_type
Tq,R,N,V_type
Tq,R,N,V_conflictDetectionType
T@"NSURL",R,N,V_syncRequestURL
T@"NSArray",R,N,V_keysToUpdate
T@"NSArray",R,N,V_keysToDelete
T@"<SBKSyncTransactionProcessing>",W,N,V_transactionProcessor
_processNextKey
_processUpdatedKey:isConflict:isDirty:
_processDeletedKey:isDirty:
responseData
setResponseData:
completionBlock
resolvedConflictsNeedSyncToServer
setResolvedConflictsNeedSyncToServer:
updatedKeysEnumerator
setUpdatedKeysEnumerator:
conflictedKeysEnumerator
setConflictedKeysEnumerator:
deletedKeysEnumerator
setDeletedKeysEnumerator:
_resolvedConflictsNeedSyncToServer
_responseData
_completionBlock
_updatedKeysEnumerator
_conflictedKeysEnumerator
_deletedKeysEnumerator
T@"SBKSyncResponseData",&,N,V_responseData
T@"SBKSyncTransaction",&,N,V_transaction
T@?,C,N,V_completionBlock
TB,N,V_resolvedConflictsNeedSyncToServer
T@"NSEnumerator",&,N,V_updatedKeysEnumerator
T@"NSEnumerator",&,N,V_conflictedKeysEnumerator
T@"NSEnumerator",&,N,V_deletedKeysEnumerator
setCompletions:
_invalidateTimer
_invalidateAssertion:
setCancelType:
setResult:
setError:
_onQueueFireExpirationHandlerIfNecesary
finishedHandler
expirationHandler
setTaskAssertion:
completions
endTaskOperation
taskAssertion
_debugDescription
_handlerQueue
_timeoutTimer
_taskInvalidationDisabled
_timeout
_cancelType
_result
_error
_expirationHandler
_finishedHandler
_taskAssertion
_completions
T@,&,N,V_result
T@"NSError",&,N,V_error
T@"SBKTaskAssertion",&,N,V_taskAssertion
T@"NSMutableArray",&,N,V_completions
T@?,C,N,V_finishedHandler
T@?,C,N,V_expirationHandler
Ti,N,V_cancelType
loadsRemoteItemCount
responseUpdatedKeys
startTransactionWithSyncAnchor:keysToUpdate:keysToDelete:finishedBlock:
setLoadsRemoteItemCount:
responseItemCount
itemCount
setItemCount:
_loadsRemoteItemCount
_responseItemCount
_itemCount
TQ,N,V_itemCount
TB,N,V_loadsRemoteItemCount
TQ,R,N,V_responseItemCount
_onQueue_clearTransactionResponseData
setResponseDomainVersion:
responseDeletedKeys
responseConflictedKeys
responseDataForResponseKey:
_overrideResponseDomainVersion
_responseUpdatedKeys
_responseDeletedKeys
_responseConflictedKeys
_responseDataByKey
T@"SBKSyncResponseData",R,N,V_responseData
T@"NSString",C,N
T@"NSArray",R,N,V_responseUpdatedKeys
T@"NSArray",R,N,V_responseDeletedKeys
T@"NSArray",R,N,V_responseConflictedKeys
initWithBufferingSize:compressionType:
writeBuffer:size:
close
data
dataByDeflatingData:
deflatedData
zstream
_outputBuffer
_bufferingSize
raise:format:
initWithRequestURL:
_defaultHeaderFields
setShouldPostFooterSectionChanged:
setShouldProcessDialogs:
setShouldTriggerDownloads:
setResponseDataProvider:
_methodStringForMethod:
bodyContentEncodingType
bodyContentType
dataWithPropertyList:format:options:error:
setBodyData:
initWithURL:
setHTTPMethod:
setValue:forHTTPHeaderField:
setValue:forRequestParameter:
includeDeviceGUID
guid
setHTTPBody:
timeoutInterval
setTimeoutInterval:
acceptsGzipEncoding
_contentEncodingTypeStringForBodyContentEncodingType:
_contentTypeStringForBodyContentType:
descriptionWithoutHeaderFields
setValue:forHeaderField:
setValue:forArgument:
newURLOperation
isConcurrent
method
bodyData
_action
_bodyData
_bodyContentType
_headers
_arguments
_method
_responseDataProvider
_concurrent
_includeDeviceGUID
concurrent
TB,R,N,GisConcurrent,V_concurrent
Tq,N,V_method
TB,N,V_includeDeviceGUID
T@"NSData",&,N,V_bodyData
T@"ISDataProvider",&,N,V_responseDataProvider
allHeaderFields
MIMEType
initWithCode:headerFields:responseDictionary:MIMEType:error:
responseStatusForStatusCodeNumber:
isPuntedError
initWithURLResponse:responseDictionary:
responseCode
responseHeaderFields
consoleDescription
isRecoverable
isError
shouldFileRadar
responseWithCode:headerFields:responseDictionary:MIMEType:error:
responseStatus
_responseDictionary
_responseCode
_responseHeaderFields
_retrySeconds
_MIMEType
_responseStatus
T@"NSString",R,N,V_MIMEType
T@"SBKResponseStatus",R,N,V_responseStatus
TQ,R,N,V_responseCode
T@"NSDictionary",R,N,V_responseHeaderFields
T@"NSDictionary",R,N,V_responseDictionary
T@"NSError",R,N,V_error
Tq,R,N
T@"NSError",R,N
Td,R,N,V_retrySeconds
dictionaryWithObjectsAndKeys:
initWithDomain:code:userInfo:
initWithStatus:isRecoverable:isError:consoleDescription:shouldFileRadar:
_isRecoverable
_isError
_shouldFileRadar
_isPuntedError
_statusCode
_consoleDescription
Tq,R,N,V_statusCode
T@"NSString",R,C,N,V_consoleDescription
TB,R,N,V_isRecoverable
TB,R,N,V_isError
TB,R,N,V_shouldFileRadar
TB,R,N,V_isPuntedError
_bagContext
T@"SBKStoreURLBagContext",R,N,V_bagContext
setUserInfo:
_activeRequest
_userInfo
T@"NSMutableDictionary",&,N,V_userInfo
T@"NSURL",&,N,V_requestURL
T@"SBKRequest",&,N,V_activeRequest
defaultIdentityStore
userIdentitiesForManageableAccountsWithError:
accountDSID
musicLibraryForUserAccount:
databasePath
_itemKey
_itemVersion
_itemValuePayload
T@"NSString",R,N,V_itemKey
T@"NSString",R,N,V_itemVersion
T@"NSData",R,N,V_itemValuePayload
@24@0:8@16
@16@0:8
@24@0:8Q16
B16@0:8
v24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
v16@0:8
v24@0:8@?16
B32@0:8@16^@24
v24@0:8d16
d16@0:8
@"NSObject<OS_dispatch_queue>"
@"NSDictionary"
@"NSData"
@32@0:8@16@24
B24@0:8@16
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
Q16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
@"NSString"
v32@0:8@16@24
v32@0:8@"ISOperation"16@"NSError"24
v32@0:8@"ISOperation"16@"SSOperationProgress"24
v24@0:8@"ISOperation"16
B40@0:8@16@24^@32
q32@0:8@16@24
v32@0:8@"ISURLOperation"16@"NSNumber"24
v32@0:8@"ISURLOperation"16@"NSURLResponse"24
v32@0:8@"ISURLOperation"16@24
@"NSInputStream"32@0:8@"ISURLOperation"16@"NSURLRequest"24
B40@0:8@"ISURLOperation"16@"NSMutableData"24^@32
v32@0:8@"ISURLOperation"16@"NSMutableURLRequest"24
@"NSString"32@0:8@"ISURLOperation"16@"NSString"24
q32@0:8@"ISURLOperation"16@"NSURLAuthenticationChallenge"24
@"NSURLCredential"32@0:8@"ISURLOperation"16@"NSURLAuthenticationChallenge"24
@"NSURLCache"16@0:8
@"NSNumber"16@0:8
v40@0:8@16@24@?32
B32@0:8@16@24
v32@0:8@"ISStoreURLOperation"16@"NSNumber"24
v40@0:8@"ISStoreURLOperation"16@"SSAuthenticationContext"24@?<v@?@"SSAuthenticateResponse"@"NSError">32
B32@0:8@"ISStoreURLOperation"16@"NSString"24
@"SSAccount"16@0:8
@40@0:8@16@24@32
v20@0:8B16
v32@0:8@16@?24
v24@0:8q16
v28@0:8@16i24
v28@0:8@16B24
v32@0:8@16^@24
v36@0:8@16@24B32
B48@0:8@16B24B28@32^B40
q16@0:8
@"<SBKTransactionControllerDelegate>"
@"NSURL"
@"SSAccount"
@"SBKStoreAuthenticationController"
@"SBKTransaction"
@"NSOperationQueue"
@"NSMutableArray"
@"SBKTaskAssertion"
@"SBKSyncTransaction"
@"NSArray"
@"NSMutableDictionary"
@24@0:8^{_NSZone=}16
@48@0:8q16@24@32@40
@48@0:8@16@24@32@40
@40@0:8@16q24@32
@40@0:8@16d24@32
@"SBKRequest"
v36@0:8r*16i24@28
v32@0:8r*16@24
@"NSFileHandle"
@"NSRegularExpression"
@"NSLock"
@"<SBKKeyValuePayloadPair>"
@32@0:8@?16@24
@"BKSProcessAssertion"
@"SBKProcessAssertion"
v28@0:8B16@20
@"SBKTransactionController"
@64@0:8q16@24@32@40@48@56
@52@0:8@16d24d32B40Q44
@36@0:8@16@24B32
v24@0:8Q16
@44@0:8@16@24Q32B40
@52@0:8@16@24Q32@40B48
@24@0:8d16
v32@0:8Q16@?24
v40@0:8@16@?24@?32
@"NSNumber"
@"<SBKUniversalPlaybackPositionDataSource>"
@"SBKAsynchronousTask"
@"SBKRequestHandler"
@"NSDate"
@"NSTimer"
B40@0:8@16@24@32
v40@0:8@16@24@32
B40@0:8@"SBKTransactionController"16@"SBKTransaction"24@"SBKStoreError"32
v40@0:8@"SBKTransactionController"16@"SBKTransaction"24@"SBKStoreError"32
v32@0:8@"SBKTransactionController"16@"SBKTransaction"24
B32@0:8@"SBKTransactionController"16@"SBKTransaction"24
v52@0:8@16@24@32B40^B44
v40@0:8@16@24^B32
q32@0:8@16q24
v32@0:8@"SBKSyncTransaction"16@"SBKSyncResponseData"24
v52@0:8@"SBKSyncTransaction"16@"NSString"24@"NSData"32B40^B44
v40@0:8@"SBKSyncTransaction"16@"NSString"24^B32
@"<SBKKeyValuePayloadPair>"32@0:8@"SBKSyncTransaction"16@"NSString"24
@"NSString"32@0:8@"SBKSyncTransaction"16@"NSString"24
@"NSArray"32@0:8@"SBKSyncTransaction"16@"NSArray"24
q32@0:8@"SBKSyncTransaction"16q24
@"NSNumber"32@0:8@"SBKSyncTransaction"16@"NSString"24
B24@0:8^@16
i24@0:8@16
@28@0:8@16B24
@"<SBKUniversalPlaybackPositionTransactionContext>"
@"NSError"
v56@0:8@16@24@?32@40@?48
@"SSURLBag"
@"SBKSyncResponseData"
@64@0:8@16@24@32@40@48q56
@56@0:8@16@24@32@40q48
@"<SBKSyncTransactionProcessing>"
v36@0:8@16B24^B28
v32@0:8@16^B24
@?16@0:8
@"NSEnumerator"
v20@0:8i16
i16@0:8
@"NSObject<OS_dispatch_source>"
v48@0:8@16@24@32@?40
@28@0:8i16Q20
B32@0:8r*16Q24
@"NSMutableData"
{z_stream_s="next_in"*"avail_in"I"total_in"Q"next_out"*"avail_out"I"total_out"Q"msg"*"state"^{internal_state}"zalloc"^?"zfree"^?"opaque"^v"data_type"i"adler"Q"reserved"Q}
@24@0:8q16
@"ISDataProvider"
@56@0:8Q16@24@32@40@48
@"SBKResponseStatus"
@44@0:8q16B24B28@32B40
@"SBKStoreURLBagContext"
