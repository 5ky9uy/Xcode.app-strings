@(#)PROGRAM:BiomeStorage  PROJECT:BiomeStorage-63.5.8
SEGB
%@ %@
segmentName
offset
length
reason
Unknown
UserInitiated
(unknown: %i)
BiomeStorage
Failed to decode key %@
classString
eventBody
metadata
eventCategory
timestamp
frameOffset
eventDataVersion
storeError
com.apple.Biome.BMStoreEvent
v8@?0
Unable to create new framestore filehandle for protection class: %@, create new file: %@, path: %@
com.apple.biome.BiomeStorage
BMDataProtectionClassA
BMDataProtectionClassBA
BMDataProtectionClassB
BMDataProtectionClassC
BMDataProtectionClassD
BMDataProtectionClassUnknown(%lu)
BMFrameStorePermissionReading
BMFrameStorePermissionPruning
BMFrameStorePermissionUnknown(%lu)
<%@: segmentName=%@, offset=%lu, deletionReason=%lu>
data
v24@?0@"BMFrame"8@"BMFrameStore"16
Potentially overwriting whatever data is currently there
BMFrameStore.m
Invalid parameter not satisfying: %@
block
Not Checked
Valid
Not Valid
no prev frame
B24@?0(?=Qd)8(?=Qd)16
-[BMFrameStore writeFrameForBytes:length:dataVersion:timestamp:outOffset:]
BMFrameStatePreWrite
BMFrameStateWritten
BMFrameStatePreDelete
BMFrameStateDeleted
BMFrameStateEOF
BMFrameStateUnknown
BMFrameStateUnknown(%lu)
BMFrameWriteStatusError
BMFrameWriteStatusFileFull
BMFrameWriteStatusDataTooLarge
BMFrameWriteStatusUnknown(%lu)
local
remote
%llu
q24@?0@"NSString"8@"NSString"16
v16@?0@"BMStreamDatastoreDeviceLockState"8
Failed to create new framestore with nil filename
B24@?0@"NSURL"8@"NSError"16
v12@?0i8
B16@?0@"BMStoreEvent"8
B24@?0@"BMStoreEvent"8^B16
v24@?0@"BMFrame"8^B16
B24@?0@"BMFrameStore"8@"NSString"16
B16@?0@"NSString"8
v24@?0@"BMStoreEvent"8@"BMFrameStore"16
BMStreamDatastoreBase.m
start <= end
callback
Failed to create new framestore
lock
BMStoreBookmark.m
streamId != nil
[streamId length] != 0
segmentName != nil
[segmentName length] != 0
streamId
iterationStartTime
%@ - %@
tombstone
BMStreamTombstoneEventDatastore.m
@"BMStoreEvent"28@?0@"BMFrameStore"8@"BMFrame"16C24
eventType
pruningPolicy
pruneOnAccess
maxAge
maxStreamSize
filterByAgeOnRead
com.apple.biome.BMStreamMetadata
v24@?0d8^B16
Event class is missing. We can't deserialize
Event data is missing. We can't deserialize
Event class - %@ doesn't - conform to BMStoreData protocol or Maybe the framework containing the event class isn't linked. We can't deserialize
Failed to deserialize event with event class - %@
Unable to determine event class from string, verify that the following class definition is available at runtime - %@
Unable to create new framestore filehandle for protection class: %{public}@, create new file: %{public}@, path: %{public}@
Failed to create new framestore filehandle with permission: %{public}@, error: %{public}@, path: %{public}@
Data store streamId is %{public}@ while bookmark streamId is %{public}@
initWithStreamDatastore: offset:%zu beyond usedBytes:%d for store: %{public}@
initWithStreamDatastore: offset: %zu not 8-byte aligned %{public}@
bookmark: offset: %zu beyond usedBytes:%d %{public}@
bookmark: offset: %zu not 8-byte aligned %{public}@
Invalid protection class (%ld) sent to %@
Can't seek to end of frame file %{public}@ due to error: %{public}@
Can't seek to beginning of frame file %{public}@ due to error: %{public}@
Frames file %{public}@ is invalid because the current size is less than a valid segment header. Potentially overwriting whatever data is currently there.
Can't read frame header data at frame file %{public}@ due to error: %@
Can't seek to beginning of frame file %{public}@ due to error: %@
Unable to read frames file segment header %{public}@. Received data of %{public}lu length. Potentially overwriting whatever data is currently there
Segment header magic number %{public}.4s doesn't match %{public}.4s in file %{public}@. Potentially overwriting whatever data is currently there
Segment header in %{public}@ says file size is %{public}llu but that is larger than the actual file size(%{public}lu).
Attempted to open %{public}@ for writing but the file is already full, byteUsed:%llu, fileSize:%zu
Not mapping an empty file %{public}@
Segment versions of %{public}@ don't match. Received %{public}d, expected %{public}d.%s
Failed to resize backing file
The Frame Header should never be nil when initializing with write or prune permissions
Failed to map header for %{public}@ with permission %lu
Failed to map frames for %{public}@ with permission %lu
Found a bad lastAbsoluteTimestamp in header for segment file %{public}@ time: %f
Exception when truncating file. %{public}@
Attempting to resize a non-writable file
isValidFrame: Frame is not 8-byte aligned:%d
isValidFrame: Frame size:%d runs past the remaining free space in the segment:%td, frame intended to start at offset:%td
isValidFrame: Unexpected frame state. Expected: %{public}@, found: %{public}@
%@ - exception during %@: %@. Data length: %i
Checksums don't match. Header: %u, Generated checksum: %{public}u. Skipping frame.
frameWithOffset: offset is not 8-byte aligned:%zu
frameWithOffset: offset (%lu) is beyond frame size (%lu)
frameWithOffset: current offset (%lu) leaves insufficient space in the segment size (%lu) for a BMFrameHeader
enumerateWithOptions: offset (%lu) is not 8-byte aligned
enumerateWithOptions: offset (%lu) beyond segment size
Use of reverse enumeration is only supported for reading.
Reverse enumeration offset not found %zu.
Found frame with state: BMFrameStateUnknown
Unrecognized frame state in segment: %{public}@
Unrecognized frame state: %d, frame offset:%td frame size:%zu reverse:%d, frameCount=%d, prevFrameState:%{public}@, prevFrameValid:%{public}@ prevLastSize/offset:%zu prevStateSize:%zu
isValidFrame failed, path:%{public}@, offset:%td
Frame store: %@, bytesUsed: %llu
Attempted to move cursor beyond end of file. This shouldn't be possible
No space left to write to the mapped region
Unable to update creationTimestamp. We expect to see %llu, but instead are seeing %llu. The write status is %d
Sample too large %{public}zu but only %zu supported
Sample is empty but only non-empty samples are supported
Attempt to write data too large to fit in segment
Failed to find a segment header while writing. Dropping incoming data
[%s] Frame should come in chronological order. Input %f < last %f, segment:%{public}@
Unable to write frame for reason: %@
Unable to update status to written, someone else seems to have overwritten the value. We expect to see %llu, but instead are seeing %llu. The write status is %d
Unable to mark frame as pre-delete
Failed to zero out memory. %{public, darwin.errno}d
Unable to mark frame as deleted
Segment name is too large to store in the segment header. Truncating the segment name of %{public}zu to %{public}lu
No segment name provided for the segment header
Failed to create new framestore with nil filename
Failed to enumerate segment files at URL: %{public}@ error: %@
Failed to get file size for %{public}@. %{public}@
Can't create stream folder at %@ with error %@, protectionClass: %@ isUnlocked: %hhd
Unable to open framestore with error: %@
error in segmentFileSize calling stat: %{public}@, error=%{public, darwin.errno}d
Attempt to write nil event
Data type not yet set for stream %{public}@, will be set to %{public}@
Incoming event is of type: %@, while stream - %@ only accepts events of type: %@
Should hold off on pruning future events because time looks like it needs an NTP server sync
Stream has event with a timestamp in the future
Removing frame store: %{public}@
Unable to unlink frame store (%{public}@). Error: %{public, darwin.errno}d
Fail to create enumerator for stream: %@ startTime: %f
Failed to create enumerator with bookmark for stream: %@
deleteEventAtBookmark: couldn't find event with bookmark %@
deleteEventAtBookmark: event at bookmark %@ already in deleted state %u
Fail to write event due to nil event data
Not enough free space to write event of size %zu. Attempting to create new segment
Failed to open new segment
Failed to write frame, length: %zu dataVersion: %u writeStatus: %@
Start date (%lf) is greater than end date (%lf)
No segments to enumerate
Received an index beyond _segmentNames in enumerateSegmentsFrom:to:withBlock:
Received an index beyond _segmentNames in enumerateSegmentsNamesFrom:to:withBlock:
Received an index beyond _segmentNames in reverseEnumerateSegmentsFrom:to:withBlock:
Received an index beyond _segmentNames in reverseEnumerateSegmentsNamesFrom:to:withBlock:
No more events and on last segment
Attempting to create new frame store
Unable to getNextSegment and creation also failed.
Unable to getNextSegment. Error: %@
Failed to create new segment without error code
Failed to create new segment with error code %ld, %@
Failed to create a new framestore with path: %{public}@.
Received an index beyond _segmentNames in newEnumeratorFromStartTime:
updateMetadata: eventBodyClass (%@) does not match existing class metadata (%@)
updateMetadata: unable to update metadata file for %@
Metadata doesn't exist
Unable to decode metadata. Err: %@
Unable to encode metadata. Err: %@
archivedDataWithRootObject returned nil
unable to write metadata to file: %{public}@ Err: %@
Offset too large, frame size:%zu fileSize:%zu offset:%lld file:%{public}@
Offset less than zero, size:%zu offset:%lld file:%{public}@
Attempt to map zero bytes, size:%zu offset:%lld file:%{public}@
Failed to get file descriptor for NSFileHandle. %{public}@
Unable to mmap storage file %{public}@ because %{public, darwin.errno}d, size:%zu, offset:%ld
Failed to madvise() because %{public, darwin.errno}d
Successfully mapped file: %{public}@
Unable to unmap %{public}p size %zu because %{public, darwin.errno}d
Failed to msync because %{public, darwin.errno}d
Cannot atomically access bytes if offset isn't 8 byte aligned. Given offset: %ld
Unable to read data at offset: %ld with length: %ld
Unable to read/write data at offset: %ld with length: %ld
Attempted to move cursor beyond end of file. Setting to End of File instead
Can't get class string
Can't get class from class string - %@
Failed to create file directory: %@
Failed to open lockfile %@: %s (%d)
Failed to acquire lockfile %@: %s (%d)
Failed to unlock lockfile %@: %s (%d)
BMPBTombstoneEvent
NSCopying
BMStoreEvent
NSObject
NSSecureCoding
NSCoding
Testing
BMFileAttributes
BMFileHandleIntern
BMTombstoneEvent
BMProtoBufWrapper
BMStoreData
BMStoreEnumeratorBase
BMDataProtection
BMStoreEnumerator
BMFrameStore
Inspection
BMStreamDatastoreDeviceLockState
BMStreamDatastoreBase
BMMemoryMapping
BMStoreBookmark
BMPBStoreBookmark
BMPruningPolicy
Storage
BMStreamTombstoneEventDatastore
BMSegmentName
BMStoreConfig
BMStreamDatastore
BMTombstoneEventEnumerator
BiomeSync
BMStreamMetadata
BMStreamDatastoreWriter
BMPrivateTesting
BMStreamDatastoreReader
BMStreamDatastorePruner
BMFrame
BMFileLock
description
dictionaryRepresentation
stringWithFormat:
dictionary
setObject:forKey:
numberWithUnsignedInt:
setSegmentName:
allocWithZone:
init
copyWithZone:
isMemberOfClass:
isEqual:
hash
hasSegmentName
setOffset:
setHasOffset:
hasOffset
setLength:
setHasLength:
hasLength
reason
setReason:
setHasReason:
hasReason
reasonAsString:
StringAsReason:
readFrom:
writeTo:
copyTo:
mergeFrom:
segmentName
offset
length
.cxx_destruct
_length
_offset
_reason
_segmentName
_has
TB,R,N
T@"NSString",&,N,V_segmentName
TB,N
TI,N,V_offset
TI,N,V_length
Ti,N,V_reason
isEqualToString:
dataType
eventWithData:dataVersion:
metadata
streamId
initWithStream:segment:iterationStartTime:offset:
initWithFrame:segmentName:error:eventCategory:metadata:dataType:
data
dataVersion
creationTimestamp
initWithFrame:segmentName:frameOffset:eventBodyData:eventBodyDataVersion:dataType:eventCategory:timestamp:metadata:error:
copy
eventDataClass
error
containsValueForKey:
dictionaryWithObjects:forKeys:count:
errorWithDomain:code:userInfo:
failWithError:
decodeObjectOfClass:forKey:
checkAndReportDecodingFailureIfNeededForid:key:coder:errorDomain:errorCode:
unsignedIntValue
doubleValue
eventBody
eventBodyData
serialize
encodeObject:forKey:
timestamp
numberWithDouble:
numberWithUnsignedChar:
eventCategory
numberWithUnsignedInteger:
numberWithUnsignedLong:
supportsSecureCoding
eventWithEventType:eventData:dataVersion:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
superclass
debugDescription
TQ,R
T#,R
T@"NSString",R,C
Td,R,N
T@"<BMStoreData>",R,N
TC,R,N
encodeWithCoder:
initWithCoder:
TB,R
bookmark
initWithFrame:error:
initWithFrame:error:metadata:
frame
_eventBody
_dataType
_frameOffset
_eventBodyData
_eventBodyDataVersion
_error
_timestamp
_frame
_metadata
_eventCategory
T@"BMFrame",R,N,V_frame
T#,R,N
T@"BMStreamMetadata",R,N,V_metadata
T@"NSData",R,N,V_eventBodyData
TQ,R,N,V_eventCategory
Td,R,N,V_timestamp
TC,R,N,V_error
T@"NSString",R,N,V_segmentName
initWithEventBody:timestamp:
initWithFilePath:permission:protectionClass:
path
permission
protectionClass
setPath:
setPermission:
setProtectionClass:
_path
_permission
_protectionClass
T@"NSString",&,N,V_path
TQ,N,V_permission
TQ,N,V_protectionClass
strongToWeakObjectsMapTable
objectForKey:
openFileWithAttributes:createNewFile:error:
canOpenFilesForProtectionClass:createNewFile:
biomeProtectionClassToOSProtectionClass:
fileSystemRepresentation
privacyPathname:
initWithFileDescriptor:closeOnDealloc:
sharedInstance
fileHandleForFilePath:permissions:protectionClass:createIfNotCached:createNewFile:error:
_fhCache
initWithSegmentName:offset:length:reason:
initWithProtoData:
encodeAsProto
proto
initWithData:
initWithProto:
json
TI,R,N
initWithSegmentName:offset:length:
deletionReason
_deletionReason
TQ,R,N,V_offset
TQ,R,N,V_length
TQ,R,N,V_deletionReason
segmentWithFilename:error:
usedBytes
segmentPath
iterationStartTime
distantFuture
timeIntervalSinceReferenceDate
initWithStreamDatastore:currentFrameStore:frameStoreOffset:iterationStartTime:endTime:maxEvents:lastN:options:
frameStoreOfSegmentContainingEventTime:
advanceBookmarkToStartTime:eventsFound:lastN:
copyNextEventAndMoveBookmark:
nextEvent
canReadOrPruneData
copyNextEventAndMoveBookmark:makeEvent:
fetchEventFromFrameStore:atOffset:withOptions:callback:
state
nextOffset
modifiedTimestamp
_eventWithFrameStore:frame:error:
setFrameStoreOffset:
initWithStreamDatastore:bookmark:options:
initWithStreamDatastore:startTime:endTime:maxEvents:lastN:options:
nextEventWithContext:
peekEvent
isDataAccessible
currentFrameStore
_frameStoreOffset
_iterationStartTime
_endTime
_maxEvents
_eventCount
_lastEventCount
_options
_currentFrameStore
T@"BMFrameStore",R,N,V_currentFrameStore
T@"BMStreamMetadata",R,N
T@"BMStreamDatastoreBase",R,N,V_ds
T@"BMStoreBookmark",R,N
isClassCLocked
isUnlocked
requiresUnlockToOpen:
losesReadAccessOnLock:
canOpenFilesForProtectionClass:
seekToEndReturningOffset:error:
bmPathname
seekToOffset:error:
lastPathComponent
readDataUpToLength:error:
bytes
stringByAppendingPathComponent:
segmentHeaderFromFile:withVersion:fileSize:
resizeBackingFileTo:
lastObject
count
firstObject
backingFile
expectedTimestamp:
sync
dealloc
truncateFileAtOffset:
initWithBytes:length:
enumerateWithOptions:fromOffset:usingBlock:
isValidFrame:expectedState:copyOfData:frameStatus:validations:
initWithHeader:storePath:data:framePtr:offset:nextOffset:
unsignedLongValue
addObject:
updateFrameStoreIndex
indexOfObject:
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
distantPast
getReverseOffsetIndex:
objectAtIndexedSubscript:
integerValue
writeFrameForBytes:length:dataVersion:timestamp:outOffset:
appendFrameHeader:offset:
updateHeader
framePtr
setFilterByAgeOnRead:
setPruneOnAccess:
setMaxAge:
initWithFileHandle:streamPath:filename:maxSize:permission:datastoreVersion:
enumerateFromOffset:withCallback:
frameWithOffset:expectedState:
writeFrameForBytes:length:dataVersion:timestamp:
markFrameAsRemoved:
filterByAgeOnRead
pruneOnAccess
maxAge
frameStoreSize
setBackingFile:
_datastoreVersion
_frames
_header
_lastAbsoluteTimestamp
_usedBytes
_frameStoreSize
_framePointers
_filterByAgeOnRead
_pruneOnAccess
_segmentPath
_maxAge
_backingFile
T@"NSString",C,N,V_segmentName
T@"NSFileHandle",&,N,V_backingFile
T@"NSString",R,N,V_segmentPath
TB,R,N,V_filterByAgeOnRead
TB,R,N,V_pruneOnAccess
Td,R,N,V_maxAge
TQ,R,N,V_frameStoreSize
TI,R
UTF8String
arrayWithObjects:count:
initWithDeviceStateIsUnlocked:
setCanReadOrPruneData:
segmentNames
setSegmentNames:
segmentFileHandles
setSegmentFileHandles:
_canReadOrPruneData
_segmentNames
_segmentFileHandles
TB,N,V_canReadOrPruneData
T@"NSMutableOrderedSet",&,N,V_segmentNames
T@"NSMutableDictionary",&,N,V_segmentFileHandles
initWithFormat:
longLongValue
fileNameWithTimestamp:
timestampWithFilename:
compare:
indexOfObject:inSortedRange:options:usingComparator:
updateSegmentsWithGuardedDeviceLockStateData:
runWithLockAcquired:
effectiveStreamPath
orderedSegmentsInDirectory:includeZeroSizeSegments:
shouldCacheFileDescriptors
allKeys
orderedSetWithArray:
mutableCopy
minusOrderedSet:
array
removeObjectsForKeys:
openFiles:saveToOpenFiles:
countByEnumeratingWithState:objects:count:
fileHandleForFile:createNewFile:error:
setObject:forKeyedSubscript:
filePathForFilename:
initFileURLWithPath:
domain
code
privacyURLToString:
defaultManager
enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:
fileSizeOfURL:
numberWithLongLong:
sortUsingComparator:
getResourceValue:forKey:error:
datastorePath
initWithStream:streamPath:permission:config:
newStreamDefaultConfigurationForPublicStream:
segmentSize
datastoreVersion
storeLocationOption
remoteStreamName
pruningPolicy
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
initWithGuardedData:
segmentWithFilename:segmentNames:segmentFileHandles:createNewFile:error:
handleDeviceUnlock
handleDeviceLocking
registerForLockStateChangeNotifications:
unregisterForLockStateChangeNotifications:
_remoteStreamPath
_localStreamPath
framesStore
loadMetadata
contentsOfDirectoryAtPath:error:
attributesOfItemAtPath:error:
fileSize
writeEventWithEventBody:timestamp:outBookmark:
eventBodyClass
updateMetadata:
writeEventData:dataVersion:timestamp:outBookmark:
fetchEventsFrom:to:options:
enumerateEventsFrom:to:options:usingBlock:
removeEventsFrom:to:reason:pruneFutureEvents:shouldDeleteUsingBlock:
removeEventsFrom:to:reason:pruneFutureEvents:usingBlock:
timeIntervalSince1970
updateSegments
isNotLastSegment:
didMarkFrameAsRemovedWithSegmentName:frame:reason:
enumerateSegmentsFrom:to:withBlock:
removeFrameStoreFileWithSegmentName:
segmentFileSize:
reverseEnumerateSegmentsNamesFrom:to:withBlock:
eventsFrom:to:reason:shouldDeleteUsingBlock:
newEnumeratorFromStartTime:options:
newEnumeratorFromStartTime:endTime:options:
newEnumeratorFromStartTime:endTime:maxEvents:options:
newEnumeratorFromStartTime:endTime:maxEvents:lastN:options:
newEnumeratorFromBookmark:options:
didMarkFrameAsRemovedWithSegmentName:frame:reason:outTombstoneBookmark:
writeEventBytes:length:dataVersion:timestamp:outBookmark:
segmentAfterFrameStore:createNewSegment:
_bookmarkWithSegmentName:offset:
indexOfSegmentContainingEventTime:fromSegments:
segmentAfterFrameStore:createNewSegment:direction:
nextSegmentAfterFrameStore:segmentNames:direction:
filelockPath
newFramestoreWithTime:
acquireLockfile:andRunBlock:
setFramesStore:
fileExistsAtPath:
_segmentStillExists:
newFramestoreWithTime:segmentNames:segmentFileHandles:
maxStreamSize
pruneStreamToMaxStreamSizeInBytes:
pruneStreamToMaxSegmentAge:
objectForKeyedSubscript:
removeObject:
updateMetadata:pruningPolicy:
initWithStreamId:eventType:remoteStreamName:pruningPolicy:
saveMetadata:
metadataPath
dataWithContentsOfFile:
unarchivedObjectOfClass:fromData:error:
setRemoteStreamName:
archivedDataWithRootObject:requiringSecureCoding:error:
writeToFile:options:error:
initWithStream:permission:config:
syncMappedFiles
streamSizeInBytes
writeEventWithEventBody:
writeEventWithEventBody:timestamp:
fetchEventsFrom:to:
removeEventsFrom:to:pruneFutureEvents:shouldDeleteUsingBlock:
removeEventsFrom:to:pruneFutureEvents:usingBlock:
eventsFrom:to:shouldDeleteUsingBlock:
newEnumeratorFromStartTime:
newEnumeratorFromBookmark:
deleteEventAtBookmark:outTombstoneBookmark:
writeEventData:dataVersion:timestamp:
writeEventBytes:length:dataVersion:timestamp:
enumerateSegmentsNamesFrom:to:withBlock:
reverseEnumerateSegmentsFrom:to:withBlock:
maxFileSize
config
streamPath
isRemote
_maxFileSize
_streamPath
_isRemote
_isTombstone
_remoteStreamName
_pruningPolicy
_eventDataClass
_config
_lockStateChangeRegistration
_deviceLockStateLock
_streamId
_framesStore
TQ,R,N,V_permission
TQ,R,N,V_datastoreVersion
TQ,R,N
T@"NSString",R,N,V_streamPath
TB,R,N,V_isRemote
T@"NSString",R,N,V_remoteStreamName
T@"BMPruningPolicy",R,N,V_pruningPolicy
T@"NSString",R,C,N,V_streamId
T@"BMFrameStore",&,N,V_framesStore
T@"BMStoreConfig",R,N,V_config
fileDescriptor
bmSegmentName
dataWithBytes:length:
dataWithBytesNoCopy:length:freeWhenDone:
canAtomicallyAccessOffset:
_protection
_advice
_start
_currentOffset
_size
_mappedAddress
_pageAlignedSize
_offsetSpace
_descriptionDict
setStreamId:
setIterationStartTime:
decodeDoubleForKey:
checkAndReportDecodingFailureIfNeededFordouble:key:coder:errorDomain:errorCode:
T@"NSString",R,N,V_streamId
Td,R,N,V_iterationStartTime
hasStreamId
setHasIterationStartTime:
hasIterationStartTime
T@"NSString",&,N,V_streamId
Td,N,V_iterationStartTime
setMaxStreamSize:
initPruneOnAccess:filterByAgeOnRead:maxAge:maxStreamSize:
_maxStreamSize
TB,N,V_pruneOnAccess
TB,N,V_filterByAgeOnRead
Td,N,V_maxAge
TQ,N,V_maxStreamSize
streamIdentifierForStream:
directoryForPublicStreams
storeConfigurationForStream:protectionClass:
newPublicStreamDefaultConfigurationWithProtectionClass:
setPruningPolicy:
streamPathForStream:
storeConfigurationForStream:
initWithStream:streamPath:permission:config:streamDatastore:
eventClass
writeTombstoneEvent:outTombstoneBookmark:
originalEventFromTombstoneEvent:
_streamDatastore
stringWithUTF8String:
T@"NSString",R,N
newStreamDefaultConfigurationForPublicStream:protectionClass:
newStreamDefaultConfigurationForPublicStream:protectionClass:segmentSize:
directoryForPrivateStreams
initWithStoreVersion:storeBasePath:segmentSize:protectionClass:storeLocationOption:remoteStreamName:pruningPolicy:
newRestrictedStreamDefaultConfigurationWithProtectionClass:
newRestrictedStreamWithSegmentSize:protectionClass:
directoryForRestrictedStreams
newPrivateStreamDefaultConfigurationWithStoreBasePath:protectionClass:
initWithStoreBasePath:segmentSize:protectionClass:
streamTypeFromStorePath:
initWithStoreVersion:storeBasePath:segmentSize:protectionClass:
setStoreLocationOption:
hasPrefix:
newPublicStreamDefaultConfiguration
newRestrictedStreamDefaultConfiguration
newRestrictedStreamWithSegmentSize:
newPrivateStreamDefaultConfigurationWithStoreBasePath:
newPrivateStreamDefaultConfigurationWithProtectionClass:segmentSize:
initWithStoreVersion:datastorePath:maxAllowedMappedPages:segmentSize:segmentResizeFactor:segmentPaddingFactor:
initWithStoreBasePath:segmentSize:
streamType
copyStoreConfigWithOption:remoteStreamName:
_streamType
_datastorePath
_segmentSize
_storeLocationOption
Tq,N,V_storeLocationOption
T@"NSString",C,N,V_remoteStreamName
T@"BMPruningPolicy",&,N,V_pruningPolicy
T@"NSString",R,N,V_datastorePath
TQ,R,N,V_segmentSize
TQ,R,N,V_protectionClass
initWithStream:streamPath:permission:config:includeTombstones:
initWithStream:permission:config:includeTombstones:
frameHeader
writeTombstoneEventWithSegmentName:offset:length:reason:outTombstoneBookmark:
tombstoneStore
includeTombstones
initForReadingWithStream:config:includeTombstones:
initForWritingWithStream:config:includeTombstones:
initForPruningWithStream:config:includeTombstones:
updatePruningPolicy:
newTombstoneEnumeratorFromStartTime:
newTombstoneEnumeratorFromBookmark:
writeTombstoneEventWithSegmentName:offset:length:reason:
_tombstoneStore
_includeTombstones
TB,R,N,V_includeTombstones
_originaleventWithFrameStore:frame:error:
peekTombstoneEvent
nextTombstoneEvent
isEqualStreamMetadata:
numberWithBool:
setWithObjects:
decodeObjectOfClasses:forKey:
unsignedIntegerValue
boolValue
T#,R,N,V_eventDataClass
writeEventBodyClass:
initWithStream:config:
_writeEventData:dataVersion:timestamp:outBookmark:
streamIdentifier
_inner
inner
T@"BMStreamDatastore",R,N,V_inner
removeEventsFrom:to:reason:usingBlock:
streamIdentifiers
containsObject:
removeEventsFrom:to:callback:
removeEventsFrom:to:usingBlock:
storePath
_framePtr
_storePath
_data
_nextOffset
_frameHeader
T^v,R,N,V_framePtr
T{?=(?={?=II}Q){?=ddII}},R,N,V_frameHeader
T@"NSString",R,N,V_storePath
T@"NSData",R,N,V_data
TQ,R,N,V_nextOffset
stringByDeletingLastPathComponent
@24@0:8^{_NSZone=}16
B16@0:8
v20@0:8I16
v20@0:8B16
i16@0:8
v20@0:8i16
@20@0:8i16
i24@0:8@16
@16@0:8
B24@0:8@16
v24@0:8@16
Q16@0:8
I16@0:8
v16@0:8
@"NSString"
{?="length"b1"offset"b1"reason"b1}
@36@0:8#16@24I32
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
d16@0:8
C16@0:8
@"<BMStoreData>"16@0:8
@24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@28@0:8@16C24
@36@0:8@16C24@28
@60@0:8@16@24C32Q36@44#52
@88@0:8@16@24Q32@40I48#52Q60d68@76C84
B56@0:8@16@24@32@40q48
@"<BMStoreData>"
@"NSData"
@"BMFrame"
@"BMStreamMetadata"
@32@0:8@16d24
@40@0:8@16Q24Q32
v24@0:8Q16
@56@0:8@16Q24Q32B40B44^@48
@36@0:8@16B24^@28
@"NSMapTable"
@28@0:8@16I24
@24@0:8@"NSData"16
@"NSData"16@0:8
@24@0:8@"PBCodable"16
@"PBCodable"16@0:8
@28@0:8@"NSData"16I24
@48@0:8@16Q24Q32Q40
@40@0:8@16@24Q32
@64@0:8@16d24d32Q40Q48Q56
@80@0:8@16@24Q32d40d48Q56Q64Q72
v24@0:8@?16
@36@0:8@16@24C32
@20@0:8B16
B40@0:8d16^Q24Q32
@28@0:8B16@?20
@"BMFrameStore"
@"BMStreamDatastoreBase"
i24@0:8Q16
B24@0:8Q16
B28@0:8Q16B24
v24@0:8d16
{?=QdI[32c][4c]}36@0:8@16I24^Q28
B24@0:8d16
@64@0:8@16@24@32Q40Q48Q56
B48@0:8^v16I24^@28{?=II}36B44
v32@0:8Q16@?24
@28@0:8Q16I24
q24@0:8Q16
v40@0:8Q16Q24@?32
C32@0:8^{?=(?={?=II}Q){?=ddII}}16^Q24
C44@0:8r^v16Q24I32d36
C52@0:8r^v16Q24I32d36^Q44
@"BMMemoryMapping"
@"NSMutableOrderedSet"
@"NSFileHandle"
@"NSMutableDictionary"
@24@0:8d16
d24@0:8@16
Q32@0:8d16@24
@28@0:8@16B24
q24@0:8@16
v32@0:8@16@24
@40@0:8@16Q24@32
@48@0:8@16@24Q32@40
Q24@0:8@16
B32@0:8@16d24
B40@0:8@16d24^@32
@32@0:8d16d24
@40@0:8d16d24Q32
v44@0:8d16d24B32@?36
v52@0:8d16d24Q32B40@?44
v40@0:8d16d24@?32
v48@0:8d16d24Q32@?40
@32@0:8d16Q24
@48@0:8d16d24Q32Q40
@56@0:8d16d24Q32Q40Q48
@32@0:8@16Q24
B32@0:8@16^@24
B36@0:8@16I24d28
B44@0:8r^v16Q24I32d36
B44@0:8@16I24d28^@36
B52@0:8r^v16Q24I32d36^@44
v48@0:8@16Q24Q32@?40
@36@0:8@16B24Q28
@40@0:8d16@24@32
@32@0:8@16^@24
@52@0:8@16@24@32B40^@44
v40@0:8@16@24Q32
v48@0:8@16@24Q32^@40
B32@0:8#16@24
@"BMPruningPolicy"
@"BMStoreConfig"
@"_PASLock"
@48@0:8@16@24d32Q40
B56@0:8d16@24@32@40q48
{?="iterationStartTime"b1"offset"b1}
@40@0:8B16B20d24Q32
@24@0:8q16
@32@0:8q16Q24
@56@0:8@16@24Q32@40@48
@"BMStreamDatastore"
@28@0:8B16Q20
@36@0:8B16Q20Q28
@24@0:8Q16
@32@0:8Q16Q24
@48@0:8Q16@24Q32Q40
@72@0:8Q16@24Q32Q40q48@56@64
@56@0:8Q16@24Q32Q40f48f52
@32@0:8q16@24
q16@0:8
v24@0:8q16
@52@0:8@16@24Q32@40B48
@44@0:8@16Q24@32B40
@36@0:8@16@24B32
v48@0:8@16Q24Q32Q40
v56@0:8@16Q24Q32Q40^@48
@"BMStreamTombstoneEventDatastore"
@48@0:8@16#24@32@40
@32@0:8@16@24
@88@0:8{?=(?={?=II}Q){?=ddII}}16@48@56^v64Q72Q80
^v16@0:8
{?=(?={?=II}Q){?=ddII}}16@0:8
{?=""(?="frameStatus"{?="size"I"state"I}"frameStatusData"Q)"otherInfo"{?="creationTimestamp"d"modifiedTimestamp"d"checksum"I"dataVersion"I}}
B32@0:8@16@?24
@(#)PROGRAM:BiomeStorage  PROJECT:BiomeStorage-63.5.8
u"AI
(s4B7
SEGB
%@ %@
segmentName
offset
length
reason
Unknown
UserInitiated
(unknown: %i)
BiomeStorage
Failed to decode key %@
classString
eventBody
metadata
eventCategory
timestamp
frameOffset
eventDataVersion
storeError
com.apple.Biome.BMStoreEvent
v8@?0
Unable to create new framestore filehandle for protection class: %@, create new file: %@, path: %@
com.apple.biome.BiomeStorage
BMDataProtectionClassA
BMDataProtectionClassBA
BMDataProtectionClassB
BMDataProtectionClassC
BMDataProtectionClassD
BMDataProtectionClassUnknown(%lu)
BMFrameStorePermissionReading
BMFrameStorePermissionPruning
BMFrameStorePermissionUnknown(%lu)
<%@: segmentName=%@, offset=%lu, deletionReason=%lu>
data
v24@?0@"BMFrame"8@"BMFrameStore"16
Potentially overwriting whatever data is currently there
BMFrameStore.m
Invalid parameter not satisfying: %@
block
Not Checked
Valid
Not Valid
no prev frame
B24@?0(?=Qd)8(?=Qd)16
-[BMFrameStore writeFrameForBytes:length:dataVersion:timestamp:outOffset:]
BMFrameStatePreWrite
BMFrameStateWritten
BMFrameStatePreDelete
BMFrameStateDeleted
BMFrameStateEOF
BMFrameStateUnknown
BMFrameStateUnknown(%lu)
BMFrameWriteStatusError
BMFrameWriteStatusFileFull
BMFrameWriteStatusDataTooLarge
BMFrameWriteStatusUnknown(%lu)
local
remote
%llu
q24@?0@"NSString"8@"NSString"16
v16@?0@"BMStreamDatastoreDeviceLockState"8
Failed to create new framestore with nil filename
B24@?0@"NSURL"8@"NSError"16
v12@?0i8
B16@?0@"BMStoreEvent"8
B24@?0@"BMStoreEvent"8^B16
v24@?0@"BMFrame"8^B16
B24@?0@"BMFrameStore"8@"NSString"16
B16@?0@"NSString"8
v24@?0@"BMStoreEvent"8@"BMFrameStore"16
BMStreamDatastoreBase.m
start <= end
callback
Failed to create new framestore
lock
BMStoreBookmark.m
streamId != nil
[streamId length] != 0
segmentName != nil
[segmentName length] != 0
streamId
iterationStartTime
%@ - %@
tombstone
BMStreamTombstoneEventDatastore.m
@"BMStoreEvent"28@?0@"BMFrameStore"8@"BMFrame"16C24
eventType
pruningPolicy
pruneOnAccess
maxAge
maxStreamSize
filterByAgeOnRead
com.apple.biome.BMStreamMetadata
v24@?0d8^B16
Event class is missing. We can't deserialize
Event data is missing. We can't deserialize
Event class - %@ doesn't - conform to BMStoreData protocol or Maybe the framework containing the event class isn't linked. We can't deserialize
Failed to deserialize event with event class - %@
Unable to determine event class from string, verify that the following class definition is available at runtime - %@
Unable to create new framestore filehandle for protection class: %{public}@, create new file: %{public}@, path: %{public}@
Failed to create new framestore filehandle with permission: %{public}@, error: %{public}@, path: %{public}@
Data store streamId is %{public}@ while bookmark streamId is %{public}@
initWithStreamDatastore: offset:%zu beyond usedBytes:%d for store: %{public}@
initWithStreamDatastore: offset: %zu not 8-byte aligned %{public}@
bookmark: offset: %zu beyond usedBytes:%d %{public}@
bookmark: offset: %zu not 8-byte aligned %{public}@
Invalid protection class (%ld) sent to %@
Can't seek to end of frame file %{public}@ due to error: %{public}@
Can't seek to beginning of frame file %{public}@ due to error: %{public}@
Frames file %{public}@ is invalid because the current size is less than a valid segment header. Potentially overwriting whatever data is currently there.
Can't read frame header data at frame file %{public}@ due to error: %@
Can't seek to beginning of frame file %{public}@ due to error: %@
Unable to read frames file segment header %{public}@. Received data of %{public}lu length. Potentially overwriting whatever data is currently there
Segment header magic number %{public}.4s doesn't match %{public}.4s in file %{public}@. Potentially overwriting whatever data is currently there
Segment header in %{public}@ says file size is %{public}llu but that is larger than the actual file size(%{public}lu).
Attempted to open %{public}@ for writing but the file is already full, byteUsed:%llu, fileSize:%zu
Not mapping an empty file %{public}@
Segment versions of %{public}@ don't match. Received %{public}d, expected %{public}d.%s
Failed to resize backing file
The Frame Header should never be nil when initializing with write or prune permissions
Failed to map header for %{public}@ with permission %lu
Failed to map frames for %{public}@ with permission %lu
Found a bad lastAbsoluteTimestamp in header for segment file %{public}@ time: %f
Exception when truncating file. %{public}@
Attempting to resize a non-writable file
isValidFrame: Frame is not 8-byte aligned:%d
isValidFrame: Frame size:%d runs past the remaining free space in the segment:%td, frame intended to start at offset:%td
isValidFrame: Unexpected frame state. Expected: %{public}@, found: %{public}@
%@ - exception during %@: %@. Data length: %i
Checksums don't match. Header: %u, Generated checksum: %{public}u. Skipping frame.
frameWithOffset: offset is not 8-byte aligned:%zu
frameWithOffset: offset (%lu) is beyond frame size (%lu)
frameWithOffset: current offset (%lu) leaves insufficient space in the segment size (%lu) for a BMFrameHeader
enumerateWithOptions: offset (%lu) is not 8-byte aligned
enumerateWithOptions: offset (%lu) beyond segment size
Use of reverse enumeration is only supported for reading.
Reverse enumeration offset not found %zu.
Found frame with state: BMFrameStateUnknown
Unrecognized frame state in segment: %{public}@
Unrecognized frame state: %d, frame offset:%td frame size:%zu reverse:%d, frameCount=%d, prevFrameState:%{public}@, prevFrameValid:%{public}@ prevLastSize/offset:%zu prevStateSize:%zu
isValidFrame failed, path:%{public}@, offset:%td
Frame store: %@, bytesUsed: %llu
Attempted to move cursor beyond end of file. This shouldn't be possible
No space left to write to the mapped region
Unable to update creationTimestamp. We expect to see %llu, but instead are seeing %llu. The write status is %d
Sample too large %{public}zu but only %zu supported
Sample is empty but only non-empty samples are supported
Attempt to write data too large to fit in segment
Failed to find a segment header while writing. Dropping incoming data
[%s] Frame should come in chronological order. Input %f < last %f, segment:%{public}@
Unable to write frame for reason: %@
Unable to update status to written, someone else seems to have overwritten the value. We expect to see %llu, but instead are seeing %llu. The write status is %d
Unable to mark frame as pre-delete
Failed to zero out memory. %{public, darwin.errno}d
Unable to mark frame as deleted
Segment name is too large to store in the segment header. Truncating the segment name of %{public}zu to %{public}lu
No segment name provided for the segment header
Failed to create new framestore with nil filename
Failed to enumerate segment files at URL: %{public}@ error: %@
Failed to get file size for %{public}@. %{public}@
Can't create stream folder at %@ with error %@, protectionClass: %@ isUnlocked: %hhd
Unable to open framestore with error: %@
error in segmentFileSize calling stat: %{public}@, error=%{public, darwin.errno}d
Attempt to write nil event
Data type not yet set for stream %{public}@, will be set to %{public}@
Incoming event is of type: %@, while stream - %@ only accepts events of type: %@
Should hold off on pruning future events because time looks like it needs an NTP server sync
Stream has event with a timestamp in the future
Removing frame store: %{public}@
Unable to unlink frame store (%{public}@). Error: %{public, darwin.errno}d
Fail to create enumerator for stream: %@ startTime: %f
Failed to create enumerator with bookmark for stream: %@
deleteEventAtBookmark: couldn't find event with bookmark %@
deleteEventAtBookmark: event at bookmark %@ already in deleted state %u
Fail to write event due to nil event data
Not enough free space to write event of size %zu. Attempting to create new segment
Failed to open new segment
Failed to write frame, length: %zu dataVersion: %u writeStatus: %@
Start date (%lf) is greater than end date (%lf)
No segments to enumerate
Received an index beyond _segmentNames in enumerateSegmentsFrom:to:withBlock:
Received an index beyond _segmentNames in enumerateSegmentsNamesFrom:to:withBlock:
Received an index beyond _segmentNames in reverseEnumerateSegmentsFrom:to:withBlock:
Received an index beyond _segmentNames in reverseEnumerateSegmentsNamesFrom:to:withBlock:
No more events and on last segment
Attempting to create new frame store
Unable to getNextSegment and creation also failed.
Unable to getNextSegment. Error: %@
Failed to create new segment without error code
Failed to create new segment with error code %ld, %@
Failed to create a new framestore with path: %{public}@.
Received an index beyond _segmentNames in newEnumeratorFromStartTime:
updateMetadata: eventBodyClass (%@) does not match existing class metadata (%@)
updateMetadata: unable to update metadata file for %@
Metadata doesn't exist
Unable to decode metadata. Err: %@
Unable to encode metadata. Err: %@
archivedDataWithRootObject returned nil
unable to write metadata to file: %{public}@ Err: %@
Offset too large, frame size:%zu fileSize:%zu offset:%lld file:%{public}@
Offset less than zero, size:%zu offset:%lld file:%{public}@
Attempt to map zero bytes, size:%zu offset:%lld file:%{public}@
Failed to get file descriptor for NSFileHandle. %{public}@
Unable to mmap storage file %{public}@ because %{public, darwin.errno}d, size:%zu, offset:%ld
Failed to madvise() because %{public, darwin.errno}d
Successfully mapped file: %{public}@
Unable to unmap %{public}p size %zu because %{public, darwin.errno}d
Failed to msync because %{public, darwin.errno}d
Cannot atomically access bytes if offset isn't 8 byte aligned. Given offset: %ld
Unable to read data at offset: %ld with length: %ld
Unable to read/write data at offset: %ld with length: %ld
Attempted to move cursor beyond end of file. Setting to End of File instead
Can't get class string
Can't get class from class string - %@
Failed to create file directory: %@
Failed to open lockfile %@: %s (%d)
Failed to acquire lockfile %@: %s (%d)
Failed to unlock lockfile %@: %s (%d)
BMPBTombstoneEvent
NSCopying
BMStoreEvent
NSObject
NSSecureCoding
NSCoding
Testing
BMFileAttributes
BMFileHandleIntern
BMTombstoneEvent
BMProtoBufWrapper
BMStoreData
BMStoreEnumeratorBase
BMDataProtection
BMStoreEnumerator
BMFrameStore
Inspection
BMStreamDatastoreDeviceLockState
BMStreamDatastoreBase
BMMemoryMapping
BMStoreBookmark
BMPBStoreBookmark
BMPruningPolicy
Storage
BMStreamTombstoneEventDatastore
BMSegmentName
BMStoreConfig
BMStreamDatastore
BMTombstoneEventEnumerator
BiomeSync
BMStreamMetadata
BMStreamDatastoreWriter
BMPrivateTesting
BMStreamDatastoreReader
BMStreamDatastorePruner
BMFrame
BMFileLock
description
dictionaryRepresentation
stringWithFormat:
dictionary
setObject:forKey:
numberWithUnsignedInt:
setSegmentName:
allocWithZone:
init
copyWithZone:
isMemberOfClass:
isEqual:
hash
hasSegmentName
setOffset:
setHasOffset:
hasOffset
setLength:
setHasLength:
hasLength
reason
setReason:
setHasReason:
hasReason
reasonAsString:
StringAsReason:
readFrom:
writeTo:
copyTo:
mergeFrom:
segmentName
offset
length
.cxx_destruct
_length
_offset
_reason
_segmentName
_has
TB,R,N
T@"NSString",&,N,V_segmentName
TB,N
TI,N,V_offset
TI,N,V_length
Ti,N,V_reason
isEqualToString:
dataType
eventWithData:dataVersion:
metadata
streamId
initWithStream:segment:iterationStartTime:offset:
initWithFrame:segmentName:error:eventCategory:metadata:dataType:
data
dataVersion
creationTimestamp
initWithFrame:segmentName:frameOffset:eventBodyData:eventBodyDataVersion:dataType:eventCategory:timestamp:metadata:error:
copy
eventDataClass
error
containsValueForKey:
dictionaryWithObjects:forKeys:count:
errorWithDomain:code:userInfo:
failWithError:
decodeObjectOfClass:forKey:
checkAndReportDecodingFailureIfNeededForid:key:coder:errorDomain:errorCode:
unsignedIntValue
doubleValue
eventBody
eventBodyData
serialize
encodeObject:forKey:
timestamp
numberWithDouble:
numberWithUnsignedChar:
eventCategory
numberWithUnsignedInteger:
numberWithUnsignedLong:
supportsSecureCoding
eventWithEventType:eventData:dataVersion:
class
self
performSelector:
performSelector:withObject:
performSelector:withObject:withObject:
isProxy
isKindOfClass:
conformsToProtocol:
respondsToSelector:
retain
release
autorelease
retainCount
zone
superclass
debugDescription
TQ,R
T#,R
T@"NSString",R,C
Td,R,N
T@"<BMStoreData>",R,N
TC,R,N
encodeWithCoder:
initWithCoder:
TB,R
bookmark
initWithFrame:error:
initWithFrame:error:metadata:
frame
_eventBody
_dataType
_frameOffset
_eventBodyData
_eventBodyDataVersion
_error
_timestamp
_frame
_metadata
_eventCategory
T@"BMFrame",R,N,V_frame
T#,R,N
T@"BMStreamMetadata",R,N,V_metadata
T@"NSData",R,N,V_eventBodyData
TQ,R,N,V_eventCategory
Td,R,N,V_timestamp
TC,R,N,V_error
T@"NSString",R,N,V_segmentName
initWithEventBody:timestamp:
initWithFilePath:permission:protectionClass:
path
permission
protectionClass
setPath:
setPermission:
setProtectionClass:
_path
_permission
_protectionClass
T@"NSString",&,N,V_path
TQ,N,V_permission
TQ,N,V_protectionClass
strongToWeakObjectsMapTable
objectForKey:
openFileWithAttributes:createNewFile:error:
canOpenFilesForProtectionClass:createNewFile:
biomeProtectionClassToOSProtectionClass:
fileSystemRepresentation
privacyPathname:
initWithFileDescriptor:closeOnDealloc:
sharedInstance
fileHandleForFilePath:permissions:protectionClass:createIfNotCached:createNewFile:error:
_fhCache
initWithSegmentName:offset:length:reason:
initWithProtoData:
encodeAsProto
proto
initWithData:
initWithProto:
json
TI,R,N
initWithSegmentName:offset:length:
deletionReason
_deletionReason
TQ,R,N,V_offset
TQ,R,N,V_length
TQ,R,N,V_deletionReason
segmentWithFilename:error:
usedBytes
segmentPath
iterationStartTime
distantFuture
timeIntervalSinceReferenceDate
initWithStreamDatastore:currentFrameStore:frameStoreOffset:iterationStartTime:endTime:maxEvents:lastN:options:
frameStoreOfSegmentContainingEventTime:
advanceBookmarkToStartTime:eventsFound:lastN:
copyNextEventAndMoveBookmark:
nextEvent
canReadOrPruneData
copyNextEventAndMoveBookmark:makeEvent:
fetchEventFromFrameStore:atOffset:withOptions:callback:
state
nextOffset
modifiedTimestamp
_eventWithFrameStore:frame:error:
setFrameStoreOffset:
initWithStreamDatastore:bookmark:options:
initWithStreamDatastore:startTime:endTime:maxEvents:lastN:options:
nextEventWithContext:
peekEvent
isDataAccessible
currentFrameStore
_frameStoreOffset
_iterationStartTime
_endTime
_maxEvents
_eventCount
_lastEventCount
_options
_currentFrameStore
T@"BMFrameStore",R,N,V_currentFrameStore
T@"BMStreamMetadata",R,N
T@"BMStreamDatastoreBase",R,N,V_ds
T@"BMStoreBookmark",R,N
isClassCLocked
isUnlocked
requiresUnlockToOpen:
losesReadAccessOnLock:
canOpenFilesForProtectionClass:
seekToEndReturningOffset:error:
bmPathname
seekToOffset:error:
lastPathComponent
readDataUpToLength:error:
bytes
stringByAppendingPathComponent:
segmentHeaderFromFile:withVersion:fileSize:
resizeBackingFileTo:
lastObject
count
firstObject
backingFile
expectedTimestamp:
sync
dealloc
truncateFileAtOffset:
initWithBytes:length:
enumerateWithOptions:fromOffset:usingBlock:
isValidFrame:expectedState:copyOfData:frameStatus:validations:
initWithHeader:storePath:data:framePtr:offset:nextOffset:
unsignedLongValue
addObject:
updateFrameStoreIndex
indexOfObject:
currentHandler
handleFailureInMethod:object:file:lineNumber:description:
distantPast
getReverseOffsetIndex:
objectAtIndexedSubscript:
integerValue
writeFrameForBytes:length:dataVersion:timestamp:outOffset:
appendFrameHeader:offset:
updateHeader
framePtr
setFilterByAgeOnRead:
setPruneOnAccess:
setMaxAge:
initWithFileHandle:streamPath:filename:maxSize:permission:datastoreVersion:
enumerateFromOffset:withCallback:
frameWithOffset:expectedState:
writeFrameForBytes:length:dataVersion:timestamp:
markFrameAsRemoved:
filterByAgeOnRead
pruneOnAccess
maxAge
frameStoreSize
setBackingFile:
_datastoreVersion
_frames
_header
_lastAbsoluteTimestamp
_usedBytes
_frameStoreSize
_framePointers
_filterByAgeOnRead
_pruneOnAccess
_segmentPath
_maxAge
_backingFile
T@"NSString",C,N,V_segmentName
T@"NSFileHandle",&,N,V_backingFile
T@"NSString",R,N,V_segmentPath
TB,R,N,V_filterByAgeOnRead
TB,R,N,V_pruneOnAccess
Td,R,N,V_maxAge
TQ,R,N,V_frameStoreSize
TI,R
UTF8String
arrayWithObjects:count:
initWithDeviceStateIsUnlocked:
setCanReadOrPruneData:
segmentNames
setSegmentNames:
segmentFileHandles
setSegmentFileHandles:
_canReadOrPruneData
_segmentNames
_segmentFileHandles
TB,N,V_canReadOrPruneData
T@"NSMutableOrderedSet",&,N,V_segmentNames
T@"NSMutableDictionary",&,N,V_segmentFileHandles
initWithFormat:
longLongValue
fileNameWithTimestamp:
timestampWithFilename:
compare:
indexOfObject:inSortedRange:options:usingComparator:
updateSegmentsWithGuardedDeviceLockStateData:
runWithLockAcquired:
effectiveStreamPath
orderedSegmentsInDirectory:includeZeroSizeSegments:
shouldCacheFileDescriptors
allKeys
orderedSetWithArray:
mutableCopy
minusOrderedSet:
array
removeObjectsForKeys:
openFiles:saveToOpenFiles:
countByEnumeratingWithState:objects:count:
fileHandleForFile:createNewFile:error:
setObject:forKeyedSubscript:
filePathForFilename:
initFileURLWithPath:
domain
code
privacyURLToString:
defaultManager
enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:
fileSizeOfURL:
numberWithLongLong:
sortUsingComparator:
getResourceValue:forKey:error:
datastorePath
initWithStream:streamPath:permission:config:
newStreamDefaultConfigurationForPublicStream:
segmentSize
datastoreVersion
storeLocationOption
remoteStreamName
pruningPolicy
createDirectoryAtPath:withIntermediateDirectories:attributes:error:
initWithGuardedData:
segmentWithFilename:segmentNames:segmentFileHandles:createNewFile:error:
handleDeviceUnlock
handleDeviceLocking
registerForLockStateChangeNotifications:
unregisterForLockStateChangeNotifications:
_remoteStreamPath
_localStreamPath
framesStore
loadMetadata
contentsOfDirectoryAtPath:error:
attributesOfItemAtPath:error:
fileSize
writeEventWithEventBody:timestamp:outBookmark:
eventBodyClass
updateMetadata:
writeEventData:dataVersion:timestamp:outBookmark:
fetchEventsFrom:to:options:
enumerateEventsFrom:to:options:usingBlock:
removeEventsFrom:to:reason:pruneFutureEvents:shouldDeleteUsingBlock:
removeEventsFrom:to:reason:pruneFutureEvents:usingBlock:
timeIntervalSince1970
updateSegments
isNotLastSegment:
didMarkFrameAsRemovedWithSegmentName:frame:reason:
enumerateSegmentsFrom:to:withBlock:
removeFrameStoreFileWithSegmentName:
segmentFileSize:
reverseEnumerateSegmentsNamesFrom:to:withBlock:
eventsFrom:to:reason:shouldDeleteUsingBlock:
newEnumeratorFromStartTime:options:
newEnumeratorFromStartTime:endTime:options:
newEnumeratorFromStartTime:endTime:maxEvents:options:
newEnumeratorFromStartTime:endTime:maxEvents:lastN:options:
newEnumeratorFromBookmark:options:
didMarkFrameAsRemovedWithSegmentName:frame:reason:outTombstoneBookmark:
writeEventBytes:length:dataVersion:timestamp:outBookmark:
segmentAfterFrameStore:createNewSegment:
_bookmarkWithSegmentName:offset:
indexOfSegmentContainingEventTime:fromSegments:
segmentAfterFrameStore:createNewSegment:direction:
nextSegmentAfterFrameStore:segmentNames:direction:
filelockPath
newFramestoreWithTime:
acquireLockfile:andRunBlock:
setFramesStore:
fileExistsAtPath:
_segmentStillExists:
newFramestoreWithTime:segmentNames:segmentFileHandles:
maxStreamSize
pruneStreamToMaxStreamSizeInBytes:
pruneStreamToMaxSegmentAge:
objectForKeyedSubscript:
removeObject:
updateMetadata:pruningPolicy:
initWithStreamId:eventType:remoteStreamName:pruningPolicy:
saveMetadata:
metadataPath
dataWithContentsOfFile:
unarchivedObjectOfClass:fromData:error:
setRemoteStreamName:
archivedDataWithRootObject:requiringSecureCoding:error:
writeToFile:options:error:
initWithStream:permission:config:
syncMappedFiles
streamSizeInBytes
writeEventWithEventBody:
writeEventWithEventBody:timestamp:
fetchEventsFrom:to:
removeEventsFrom:to:pruneFutureEvents:shouldDeleteUsingBlock:
removeEventsFrom:to:pruneFutureEvents:usingBlock:
eventsFrom:to:shouldDeleteUsingBlock:
newEnumeratorFromStartTime:
newEnumeratorFromBookmark:
deleteEventAtBookmark:outTombstoneBookmark:
writeEventData:dataVersion:timestamp:
writeEventBytes:length:dataVersion:timestamp:
enumerateSegmentsNamesFrom:to:withBlock:
reverseEnumerateSegmentsFrom:to:withBlock:
maxFileSize
config
streamPath
isRemote
_maxFileSize
_streamPath
_isRemote
_isTombstone
_remoteStreamName
_pruningPolicy
_eventDataClass
_config
_lockStateChangeRegistration
_deviceLockStateLock
_streamId
_framesStore
TQ,R,N,V_permission
TQ,R,N,V_datastoreVersion
TQ,R,N
T@"NSString",R,N,V_streamPath
TB,R,N,V_isRemote
T@"NSString",R,N,V_remoteStreamName
T@"BMPruningPolicy",R,N,V_pruningPolicy
T@"NSString",R,C,N,V_streamId
T@"BMFrameStore",&,N,V_framesStore
T@"BMStoreConfig",R,N,V_config
fileDescriptor
bmSegmentName
dataWithBytes:length:
dataWithBytesNoCopy:length:freeWhenDone:
canAtomicallyAccessOffset:
_protection
_advice
_start
_currentOffset
_size
_mappedAddress
_pageAlignedSize
_offsetSpace
_descriptionDict
setStreamId:
setIterationStartTime:
decodeDoubleForKey:
checkAndReportDecodingFailureIfNeededFordouble:key:coder:errorDomain:errorCode:
T@"NSString",R,N,V_streamId
Td,R,N,V_iterationStartTime
hasStreamId
setHasIterationStartTime:
hasIterationStartTime
T@"NSString",&,N,V_streamId
Td,N,V_iterationStartTime
setMaxStreamSize:
initPruneOnAccess:filterByAgeOnRead:maxAge:maxStreamSize:
_maxStreamSize
TB,N,V_pruneOnAccess
TB,N,V_filterByAgeOnRead
Td,N,V_maxAge
TQ,N,V_maxStreamSize
streamIdentifierForStream:
directoryForPublicStreams
storeConfigurationForStream:protectionClass:
newPublicStreamDefaultConfigurationWithProtectionClass:
setPruningPolicy:
streamPathForStream:
storeConfigurationForStream:
initWithStream:streamPath:permission:config:streamDatastore:
eventClass
writeTombstoneEvent:outTombstoneBookmark:
originalEventFromTombstoneEvent:
_streamDatastore
stringWithUTF8String:
T@"NSString",R,N
newStreamDefaultConfigurationForPublicStream:protectionClass:
newStreamDefaultConfigurationForPublicStream:protectionClass:segmentSize:
directoryForPrivateStreams
initWithStoreVersion:storeBasePath:segmentSize:protectionClass:storeLocationOption:remoteStreamName:pruningPolicy:
newRestrictedStreamDefaultConfigurationWithProtectionClass:
newRestrictedStreamWithSegmentSize:protectionClass:
directoryForRestrictedStreams
newPrivateStreamDefaultConfigurationWithStoreBasePath:protectionClass:
initWithStoreBasePath:segmentSize:protectionClass:
streamTypeFromStorePath:
initWithStoreVersion:storeBasePath:segmentSize:protectionClass:
setStoreLocationOption:
hasPrefix:
newPublicStreamDefaultConfiguration
newRestrictedStreamDefaultConfiguration
newRestrictedStreamWithSegmentSize:
newPrivateStreamDefaultConfigurationWithStoreBasePath:
newPrivateStreamDefaultConfigurationWithProtectionClass:segmentSize:
initWithStoreVersion:datastorePath:maxAllowedMappedPages:segmentSize:segmentResizeFactor:segmentPaddingFactor:
initWithStoreBasePath:segmentSize:
streamType
copyStoreConfigWithOption:remoteStreamName:
_streamType
_datastorePath
_segmentSize
_storeLocationOption
Tq,N,V_storeLocationOption
T@"NSString",C,N,V_remoteStreamName
T@"BMPruningPolicy",&,N,V_pruningPolicy
T@"NSString",R,N,V_datastorePath
TQ,R,N,V_segmentSize
TQ,R,N,V_protectionClass
initWithStream:streamPath:permission:config:includeTombstones:
initWithStream:permission:config:includeTombstones:
frameHeader
writeTombstoneEventWithSegmentName:offset:length:reason:outTombstoneBookmark:
tombstoneStore
includeTombstones
initForReadingWithStream:config:includeTombstones:
initForWritingWithStream:config:includeTombstones:
initForPruningWithStream:config:includeTombstones:
updatePruningPolicy:
newTombstoneEnumeratorFromStartTime:
newTombstoneEnumeratorFromBookmark:
writeTombstoneEventWithSegmentName:offset:length:reason:
_tombstoneStore
_includeTombstones
TB,R,N,V_includeTombstones
_originaleventWithFrameStore:frame:error:
peekTombstoneEvent
nextTombstoneEvent
isEqualStreamMetadata:
numberWithBool:
setWithObjects:
decodeObjectOfClasses:forKey:
unsignedIntegerValue
boolValue
T#,R,N,V_eventDataClass
writeEventBodyClass:
initWithStream:config:
_writeEventData:dataVersion:timestamp:outBookmark:
streamIdentifier
_inner
inner
T@"BMStreamDatastore",R,N,V_inner
removeEventsFrom:to:reason:usingBlock:
streamIdentifiers
containsObject:
removeEventsFrom:to:callback:
removeEventsFrom:to:usingBlock:
storePath
_framePtr
_storePath
_data
_nextOffset
_frameHeader
T^v,R,N,V_framePtr
T{?=(?={?=II}Q){?=ddII}},R,N,V_frameHeader
T@"NSString",R,N,V_storePath
T@"NSData",R,N,V_data
TQ,R,N,V_nextOffset
stringByDeletingLastPathComponent
@24@0:8^{_NSZone=}16
B16@0:8
v20@0:8I16
v20@0:8B16
i16@0:8
v20@0:8i16
@20@0:8i16
i24@0:8@16
@16@0:8
B24@0:8@16
v24@0:8@16
Q16@0:8
I16@0:8
v16@0:8
@"NSString"
{?="length"b1"offset"b1"reason"b1}
@36@0:8#16@24I32
#16@0:8
@24@0:8:16
@32@0:8:16@24
@40@0:8:16@24@32
B24@0:8#16
B24@0:8:16
Vv16@0:8
^{_NSZone=}16@0:8
B24@0:8@"Protocol"16
@"NSString"16@0:8
d16@0:8
C16@0:8
@"<BMStoreData>"16@0:8
@24@0:8@16
v24@0:8@"NSCoder"16
@24@0:8@"NSCoder"16
@28@0:8@16C24
@36@0:8@16C24@28
@60@0:8@16@24C32Q36@44#52
@88@0:8@16@24Q32@40I48#52Q60d68@76C84
B56@0:8@16@24@32@40q48
@"<BMStoreData>"
@"NSData"
@"BMFrame"
@"BMStreamMetadata"
@32@0:8@16d24
@40@0:8@16Q24Q32
v24@0:8Q16
@56@0:8@16Q24Q32B40B44^@48
@36@0:8@16B24^@28
@"NSMapTable"
@28@0:8@16I24
@24@0:8@"NSData"16
@"NSData"16@0:8
@24@0:8@"PBCodable"16
@"PBCodable"16@0:8
@28@0:8@"NSData"16I24
@48@0:8@16Q24Q32Q40
@40@0:8@16@24Q32
@64@0:8@16d24d32Q40Q48Q56
@80@0:8@16@24Q32d40d48Q56Q64Q72
v24@0:8@?16
@36@0:8@16@24C32
@20@0:8B16
B40@0:8d16^Q24Q32
@28@0:8B16@?20
@"BMFrameStore"
@"BMStreamDatastoreBase"
i24@0:8Q16
B24@0:8Q16
B28@0:8Q16B24
v24@0:8d16
{?=QdI[32c][4c]}36@0:8@16I24^Q28
B24@0:8d16
@64@0:8@16@24@32Q40Q48Q56
B48@0:8^v16I24^@28{?=II}36B44
v32@0:8Q16@?24
@28@0:8Q16I24
q24@0:8Q16
v40@0:8Q16Q24@?32
C32@0:8^{?=(?={?=II}Q){?=ddII}}16^Q24
C44@0:8r^v16Q24I32d36
C52@0:8r^v16Q24I32d36^Q44
@"BMMemoryMapping"
@"NSMutableOrderedSet"
@"NSFileHandle"
@"NSMutableDictionary"
@24@0:8d16
d24@0:8@16
Q32@0:8d16@24
@28@0:8@16B24
q24@0:8@16
v32@0:8@16@24
@40@0:8@16Q24@32
@48@0:8@16@24Q32@40
Q24@0:8@16
B32@0:8@16d24
B40@0:8@16d24^@32
@32@0:8d16d24
@40@0:8d16d24Q32
v44@0:8d16d24B32@?36
v52@0:8d16d24Q32B40@?44
v40@0:8d16d24@?32
v48@0:8d16d24Q32@?40
@32@0:8d16Q24
@48@0:8d16d24Q32Q40
@56@0:8d16d24Q32Q40Q48
@32@0:8@16Q24
B32@0:8@16^@24
B36@0:8@16I24d28
B44@0:8r^v16Q24I32d36
B44@0:8@16I24d28^@36
B52@0:8r^v16Q24I32d36^@44
v48@0:8@16Q24Q32@?40
@36@0:8@16B24Q28
@40@0:8d16@24@32
@32@0:8@16^@24
@52@0:8@16@24@32B40^@44
v40@0:8@16@24Q32
v48@0:8@16@24Q32^@40
B32@0:8#16@24
@"BMPruningPolicy"
@"BMStoreConfig"
@"_PASLock"
@48@0:8@16@24d32Q40
B56@0:8d16@24@32@40q48
{?="iterationStartTime"b1"offset"b1}
@40@0:8B16B20d24Q32
@24@0:8q16
@32@0:8q16Q24
@56@0:8@16@24Q32@40@48
@"BMStreamDatastore"
@28@0:8B16Q20
@36@0:8B16Q20Q28
@24@0:8Q16
@32@0:8Q16Q24
@48@0:8Q16@24Q32Q40
@72@0:8Q16@24Q32Q40q48@56@64
@56@0:8Q16@24Q32Q40f48f52
@32@0:8q16@24
q16@0:8
v24@0:8q16
@52@0:8@16@24Q32@40B48
@44@0:8@16Q24@32B40
@36@0:8@16@24B32
v48@0:8@16Q24Q32Q40
v56@0:8@16Q24Q32Q40^@48
@"BMStreamTombstoneEventDatastore"
@48@0:8@16#24@32@40
@32@0:8@16@24
@88@0:8{?=(?={?=II}Q){?=ddII}}16@48@56^v64Q72Q80
^v16@0:8
{?=(?={?=II}Q){?=ddII}}16@0:8
{?=""(?="frameStatus"{?="size"I"state"I}"frameStatusData"Q)"otherInfo"{?="creationTimestamp"d"modifiedTimestamp"d"checksum"I"dataVersion"I}}
B32@0:8@16@?24
